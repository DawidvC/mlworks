head	1.148;
access;
symbols
	MLWorks_20b2c2_1998_06_19:1.148
	MLWorks_20b2_Windows_1998_06_12:1.148
	MLWorks_20b1c1_1998_05_07:1.147
	MLWorks_20b0_1998_04_07:1.147
	MLWorks_20b0_1998_03_20:1.145
	MLWorks_20m2_1998_02_16:1.144
	MLWorks_20m1_1997_10_23:1.142
	MLWorks_11r1:1.132.1.1.1.2.1
	MLWorks_workspace_97:1.139.2
	MLWorks_dt_wizard:1.139.1
	MLWorks_11c0_1997_09_09:1.132.1.1.1.2
	MLWorks_10r3:1.132.1.1.3
	MLWorks_10r2_551:1.132.1.1.2
	MLWorks_11:1.132.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.132.1.1
	MLWorks_20m0_1997_06_20:1.137
	MLWorks_1_0_r2c2_1997_06_14:1.132.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.132.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.132.1
	MLWorks_BugFix_1997_04_24:1.132
	MLWorks_1_0_r2_Win32_1997_04_11:1.132
	MLWorks_1_0_r2_Unix_1997_04_04:1.132
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.125.3.1.1
	MLWorks_gui_1996_12_18:1.125.4
	MLWorks_1_0_Win32_1996_12_17:1.125.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.125.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.125.1.1
	MLWorks_1_0_Irix_1996_11_28:1.125.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.125.2
	MLWorks_1_0_Unix_1996_11_14:1.125.1
	MLWorks_Open_Beta2_1996_10_11:1.123.2
	MLWorks_License_dev:1.123.1
	MLWorks_1_open_beta_1996_09_13:1.122.1
	MLWorks_Open_Beta_1996_08_22:1.121
	MLWorks_Beta_1996_07_02:1.118
	MLWorks_Beta_1996_06_07:1.117
	MLWorks_Beta_1996_06_06:1.117
	MLWorks_Beta_1996_06_05:1.117
	MLWorks_Beta_1996_06_03:1.117
	MLWorks_Beta_1996_05_31:1.117
	MLWorks_Beta_1996_05_30:1.116
	ML_beta_release_12/08/94:1.67
	ML_beta_release_03/08/94:1.67
	ML_revised_beta_release_25/05/94:1.60
	ML_final_beta_release_02/03/94:1.57
	mlworks-28-01-1994:1.55
	Release:1.51
	mlworks-beta-01-09-1993:1.51
	MLWorks-1-0-4-29/01/1993:1.27
	MLWorks-1-0-3-21/12/1992:1.25
	MLWorks-1-0-2-15/12/1992:1.23
	MLWorks-1-0-1-04/12/1992:1.23
	checkpoint_17_08_92:1.6;
locks; strict;
comment	@ * @;


1.148
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.147;

1.147
date	98.03.26.16.21.00;	author jont;	state Exp;
branches;
next	1.146;

1.146
date	98.03.26.14.08.42;	author jont;	state Exp;
branches;
next	1.145;

1.145
date	98.02.10.15.31.30;	author jont;	state Exp;
branches;
next	1.144;

1.144
date	97.11.26.15.45.22;	author johnh;	state Exp;
branches;
next	1.143;

1.143
date	97.11.09.19.14.52;	author jont;	state Exp;
branches;
next	1.142;

1.142
date	97.10.09.13.45.35;	author jont;	state Exp;
branches;
next	1.141;

1.141
date	97.10.08.17.23.28;	author jont;	state Exp;
branches;
next	1.140;

1.140
date	97.10.07.14.45.19;	author johnh;	state Exp;
branches;
next	1.139;

1.139
date	97.08.04.10.37.27;	author brucem;	state Exp;
branches
	1.139.1.1
	1.139.2.1;
next	1.138;

1.138
date	97.06.17.13.50.58;	author andreww;	state Exp;
branches;
next	1.137;

1.137
date	97.06.12.11.59.49;	author matthew;	state Exp;
branches;
next	1.136;

1.136
date	97.06.12.10.09.57;	author matthew;	state Exp;
branches;
next	1.135;

1.135
date	97.05.28.21.08.46;	author jont;	state Exp;
branches;
next	1.134;

1.134
date	97.05.09.13.39.40;	author jont;	state Exp;
branches;
next	1.133;

1.133
date	97.05.01.11.44.14;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	97.03.25.11.46.48;	author andreww;	state Exp;
branches
	1.132.1.1;
next	1.131;

1.131
date	97.03.18.11.16.10;	author andreww;	state Exp;
branches;
next	1.130;

1.130
date	97.03.07.15.59.34;	author andreww;	state Exp;
branches;
next	1.129;

1.129
date	97.03.03.11.13.53;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	97.01.27.11.07.34;	author andreww;	state Exp;
branches;
next	1.127;

1.127
date	97.01.06.15.55.13;	author andreww;	state Exp;
branches;
next	1.126;

1.126
date	96.11.18.10.27.44;	author matthew;	state Exp;
branches;
next	1.125;

1.125
date	96.10.21.14.42.28;	author andreww;	state Exp;
branches
	1.125.1.1
	1.125.2.1
	1.125.3.1
	1.125.4.1;
next	1.124;

1.124
date	96.10.21.10.34.38;	author andreww;	state Exp;
branches;
next	1.123;

1.123
date	96.09.18.14.10.18;	author io;	state Exp;
branches
	1.123.1.1
	1.123.2.1;
next	1.122;

1.122
date	96.08.21.09.00.38;	author stephenb;	state Exp;
branches
	1.122.1.1;
next	1.121;

1.121
date	96.07.16.15.48.15;	author andreww;	state Exp;
branches;
next	1.120;

1.120
date	96.07.15.12.42.05;	author andreww;	state Exp;
branches;
next	1.119;

1.119
date	96.06.25.10.52.03;	author andreww;	state Exp;
branches;
next	1.118;

1.118
date	96.06.19.13.42.40;	author nickb;	state Exp;
branches;
next	1.117;

1.117
date	96.05.30.11.50.53;	author daveb;	state Exp;
branches;
next	1.116;

1.116
date	96.05.29.12.33.31;	author matthew;	state Exp;
branches;
next	1.115;

1.115
date	96.05.28.11.58.32;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	96.05.22.13.20.01;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	96.05.20.10.00.06;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	96.05.17.10.05.18;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	96.05.16.13.18.56;	author stephenb;	state Exp;
branches;
next	1.110;

1.110
date	96.05.16.13.18.56;	author stephenb;	state Exp;
branches;
next	1.109;

1.109
date	96.05.07.10.22.14;	author jont;	state Exp;
branches;
next	1.108;

1.108
date	96.05.03.12.27.52;	author nickb;	state Exp;
branches;
next	1.107;

1.107
date	96.04.29.14.49.44;	author matthew;	state Exp;
branches;
next	1.106;

1.106
date	96.04.29.10.47.47;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	96.04.19.16.13.05;	author stephenb;	state Exp;
branches;
next	1.104;

1.104
date	96.04.17.11.02.35;	author stephenb;	state Exp;
branches;
next	1.103;

1.103
date	96.03.28.11.34.37;	author matthew;	state Exp;
branches;
next	1.102;

1.102
date	96.03.20.12.19.32;	author matthew;	state Exp;
branches;
next	1.101;

1.101
date	96.03.08.11.42.18;	author daveb;	state Exp;
branches;
next	1.100;

1.100
date	96.02.22.13.15.06;	author daveb;	state Exp;
branches;
next	1.99;

1.99
date	96.02.16.15.00.34;	author nickb;	state Exp;
branches;
next	1.98;

1.98
date	96.01.22.11.01.32;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	96.01.17.16.05.58;	author stephenb;	state Exp;
branches;
next	1.96;

1.96
date	96.01.16.12.22.05;	author nickb;	state Exp;
branches;
next	1.95;

1.95
date	96.01.15.16.18.20;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	96.01.15.11.47.45;	author nickb;	state Exp;
branches;
next	1.93;

1.93
date	96.01.12.10.33.22;	author stephenb;	state Exp;
branches;
next	1.92;

1.92
date	96.01.08.14.18.00;	author nickb;	state Exp;
branches;
next	1.91;

1.91
date	95.12.04.15.55.59;	author daveb;	state Exp;
branches;
next	1.90;

1.90
date	95.11.21.11.22.13;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	95.10.17.12.51.59;	author jont;	state Exp;
branches;
next	1.88;

1.88
date	95.09.13.14.23.26;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	95.09.12.15.08.33;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	95.08.10.15.30.20;	author jont;	state Exp;
branches;
next	1.85;

1.85
date	95.07.26.14.15.01;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	95.07.24.14.20.42;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	95.07.20.17.01.30;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	95.07.19.15.09.52;	author nickb;	state Exp;
branches;
next	1.81;

1.81
date	95.07.19.13.51.55;	author nickb;	state Exp;
branches;
next	1.80;

1.80
date	95.07.17.16.33.47;	author nickb;	state Exp;
branches;
next	1.79;

1.79
date	95.07.17.11.13.21;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	95.06.02.14.02.36;	author nickb;	state Exp;
branches;
next	1.77;

1.77
date	95.05.22.15.45.37;	author nickb;	state Exp;
branches;
next	1.76;

1.76
date	95.05.10.17.51.49;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	95.05.02.13.12.39;	author matthew;	state Exp;
branches;
next	1.74;

1.74
date	95.04.13.14.03.24;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	95.03.01.11.24.16;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	95.01.12.15.23.07;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	94.12.09.14.38.44;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	94.11.24.16.19.45;	author matthew;	state Exp;
branches;
next	1.69;

1.69
date	94.09.28.14.45.11;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	94.08.24.16.31.57;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	94.07.22.15.37.35;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	94.07.22.15.26.24;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	94.07.08.10.08.54;	author nickh;	state Exp;
branches;
next	1.64;

1.64
date	94.06.29.14.58.56;	author nickh;	state Exp;
branches;
next	1.63;

1.63
date	94.06.22.15.27.30;	author nickh;	state Exp;
branches;
next	1.62;

1.62
date	94.06.09.15.37.46;	author nickh;	state Exp;
branches;
next	1.61;

1.61
date	94.06.06.11.46.19;	author nosa;	state Exp;
branches;
next	1.60;

1.60
date	94.03.30.14.46.24;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	94.03.30.13.55.51;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	94.03.30.13.22.12;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	94.02.23.17.04.26;	author nosa;	state Exp;
branches;
next	1.56;

1.56
date	94.02.08.14.37.21;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	93.11.25.13.00.45;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	93.11.22.14.28.13;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	93.11.18.12.05.51;	author nickh;	state Exp;
branches;
next	1.52;

1.52
date	93.11.15.16.44.26;	author nickh;	state Exp;
branches;
next	1.51;

1.51
date	93.08.27.19.34.57;	author daveb;	state Exp;
branches
	1.51.1.1;
next	1.50;

1.50
date	93.08.26.11.13.00;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	93.08.25.14.01.37;	author richard;	state Exp;
branches;
next	1.48;

1.48
date	93.08.18.12.53.36;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	93.08.10.11.28.49;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	93.07.23.11.08.17;	author richard;	state Exp;
branches;
next	1.45;

1.45
date	93.07.19.13.53.26;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	93.06.09.16.06.35;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	93.05.05.17.09.17;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.04.23.14.56.28;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.04.21.15.58.26;	author richard;	state Exp;
branches;
next	1.40;

1.40
date	93.04.20.13.52.57;	author richard;	state Exp;
branches;
next	1.39;

1.39
date	93.04.13.09.50.58;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	93.04.08.17.29.01;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	93.04.02.14.47.39;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.03.26.15.52.31;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.03.23.18.29.31;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	93.03.18.16.34.45;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.03.11.18.36.55;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.03.10.16.40.47;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	93.02.26.11.13.05;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	93.02.25.18.17.57;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.02.18.16.33.36;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.02.09.14.58.38;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	93.01.14.14.45.50;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.01.05.16.52.41;	author richard;	state Exp;
branches;
next	1.25;

1.25
date	92.12.22.11.43.12;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.12.21.11.29.53;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	92.11.30.18.51.17;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.11.30.17.56.05;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.11.12.17.22.21;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.11.10.13.13.37;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.10.29.17.07.45;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.10.06.17.20.26;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.25.14.20.56;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.09.23.16.12.32;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	92.09.01.13.44.40;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.08.28.10.32.51;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.08.28.08.21.53;	author richard;	state Exp;
branches;
next	1.12;

1.12
date	92.08.26.14.14.16;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.08.25.08.37.30;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.08.20.12.54.36;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.20.12.24.43;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.08.18.16.38.55;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.08.18.15.36.27;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.08.17.10.58.26;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	92.08.15.17.30.02;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.08.13.11.40.16;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.08.11.15.33.23;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.08.10.15.26.35;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.08.10.12.18.46;	author davidt;	state Exp;
branches;
next	;

1.51.1.1
date	93.08.27.19.34.57;	author jont;	state Exp;
branches;
next	;

1.122.1.1
date	96.09.13.11.21.03;	author hope;	state Exp;
branches;
next	;

1.123.1.1
date	96.10.07.16.11.01;	author hope;	state Exp;
branches;
next	;

1.123.2.1
date	96.10.17.11.29.36;	author hope;	state Exp;
branches;
next	;

1.125.1.1
date	96.11.14.12.55.27;	author hope;	state Exp;
branches
	1.125.1.1.1.1;
next	;

1.125.1.1.1.1
date	96.11.28.15.06.07;	author hope;	state Exp;
branches;
next	;

1.125.2.1
date	96.11.22.18.13.50;	author hope;	state Exp;
branches;
next	;

1.125.3.1
date	96.12.17.17.52.19;	author hope;	state Exp;
branches
	1.125.3.1.1.1;
next	;

1.125.3.1.1.1
date	97.02.24.11.43.07;	author hope;	state Exp;
branches;
next	;

1.125.4.1
date	96.12.18.09.46.44;	author hope;	state Exp;
branches;
next	;

1.132.1.1
date	97.05.12.10.39.12;	author hope;	state Exp;
branches
	1.132.1.1.1.1
	1.132.1.1.2.1
	1.132.1.1.3.1;
next	;

1.132.1.1.1.1
date	97.07.28.18.24.07;	author daveb;	state Exp;
branches;
next	1.132.1.1.1.2;

1.132.1.1.1.2
date	97.08.06.18.40.18;	author daveb;	state Exp;
branches
	1.132.1.1.1.2.1.1;
next	;

1.132.1.1.1.2.1.1
date	97.10.07.11.49.55;	author jkbrook;	state Exp;
branches;
next	;

1.132.1.1.2.1
date	97.09.08.17.17.30;	author daveb;	state Exp;
branches;
next	;

1.132.1.1.3.1
date	97.09.09.14.13.39;	author daveb;	state Exp;
branches;
next	;

1.139.1.1
date	97.09.10.19.29.46;	author brucem;	state Exp;
branches;
next	;

1.139.2.1
date	97.09.11.20.59.34;	author daveb;	state Exp;
branches;
next	;


desc
@Signature for MLworks pervasive structure.
@


1.148
log
@[Bug #30413]
Move Exit structure to pervasives
@
text
@(*  ==== PERVASIVE MLWORKS LIBRARY ====
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Revision Log
 *  ------------
 *  $Log: mlworks.sml,v $
 * Revision 1.147  1998/03/26  16:21:00  jont
 * [Bug #30090]
 * Remove MLWorks.IO
 *
 * Revision 1.146  1998/03/26  14:08:42  jont
 * [Bug #30090]
 * Remove all of MLWorks.IO
 *
 * Revision 1.145  1998/02/10  15:31:30  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.144  1997/11/26  15:45:22  johnh
 * [Bug #30134]
 * Change meaning of third arg of deliver and convert to datatype.
 *
 * Revision 1.143  1997/11/09  19:14:52  jont
 * [Bug #30089]
 * Furhter work on getting rid of MLWorks.Time
 * Also removing {set_,}file_modified
 *
 * Revision 1.142  1997/10/09  13:45:35  jont
 * [Bug #30204]
 * Add comment indicating restrictions on use of update_exn
 *
 * Revision 1.141  1997/10/08  17:23:28  jont
 * [Bug #30204]
 * Add update_exn and update_exn_cons
 *
 * Revision 1.140  1997/10/07  14:45:19  johnh
 * [Bug #30226]
 * Add exitFn for storing the function to call when the exe exits normally.
 *
 * Revision 1.139  1997/08/04  10:37:27  brucem
 * [Bug #30084]
 * Add datatype MLWorks.Internal.Types.option.
 * Change all occurences of General.option to the new option.
 *
 * Revision 1.138  1997/06/17  13:50:58  andreww
 * [Bug #20014]
 * adding MLWorks.name
 *
 * Revision 1.137  1997/06/12  11:59:49  matthew
 * [Bug #30101]
 *
 * Adding sin and cos
 *
 * Revision 1.136  1997/06/12  10:09:57  matthew
 * Adding print_error to StandardIO
 *
 * Revision 1.135  1997/05/28  21:08:46  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.134  1997/05/09  13:39:40  jont
 * [Bug #30091]
 * Remove MLWorks.Internal.FileIO and related stuff
 *
 * Revision 1.133  1997/05/01  11:44:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.132  1997/03/25  11:46:48  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
 * Revision 1.131  1997/03/18  11:16:10  andreww
 * [Bug #1431]
 * Adding Io exception from basis to Internal Value so that
 * general exnMessage prints it nicely.
 *
 * Revision 1.130  1997/03/07  15:59:34  andreww
 * [Bug #1677]
 * Adding hook for stopping preemption.  This is used to keep
 * the GUI listener operating correctly --- when the user types
 * "stop pre-empting", the listener must claim its access mutex
 * before actually stopping, otherwise it will go to sleep,and
 * a concurrent thread will continue executing.
 *
 * Revision 1.129  1997/03/03  11:13:53  matthew
 * Adding unsafe floatarray operations to Internal.Value
 *
 * Revision 1.128  1997/01/27  11:07:34  andreww
 * [Bug #1891]
 * Adding critical section primitives for threads.
 *
 * Revision 1.127  1997/01/06  15:55:13  andreww
 * [Bug #1818]
 * Adding new FloatArray primitives.
 *
 * Revision 1.126  1996/11/18  10:27:44  matthew
 * Adding real equality builtin to MLWorks.Internal.Value.
 *
 * Revision 1.125  1996/10/21  14:42:28  andreww
 * [Bug #1682]
 * removing MLWorks.General
 *
 * Revision 1.124  1996/10/21  10:34:38  andreww
 * [Bug #1666]
 * Adding Threads exception to MLWorks.Threads
 *
 * Revision 1.123  1996/09/18  14:10:18  io
 * [Bug #1490]
 * update String maxSize
 *
 * Revision 1.122  1996/08/21  09:00:38  stephenb
 * [Bug #1554]
 * Introduce MLWorks.Internal.IO as a repository for file_desc
 * and the read, write, seek, ... etc. stuff.
 *
 * Revision 1.121  1996/07/16  15:48:15  andreww
 * Incorporated gui_standard_io signature.
 *
 * Revision 1.120  1996/07/15  12:42:05  andreww
 * Adding exception Empty.
 *
 * Revision 1.119  1996/06/25  10:52:03  andreww
 * adding General to the top level.
 *
 * Revision 1.118  1996/06/19  13:42:40  nickb
 * Extend datatype MLWorks.Internal.Trace.status.
 *
 * Revision 1.117  1996/05/30  11:50:53  daveb
 * Revising top level for revised basis.
 *
 * Revision 1.116  1996/05/29  12:33:31  matthew
 * Fixing problem with SysErr
 *
 * Revision 1.115  1996/05/28  11:58:32  daveb
 * Removed MLWorks.RawIO.
 *
 * Revision 1.114  1996/05/22  13:20:01  matthew
 * Changing type of real_to_string
 *
 * Revision 1.113  1996/05/20  10:00:06  matthew
 * Changing type of word32 shift operations
 *
 * Revision 1.112  1996/05/17  10:05:18  matthew
 * Moving Bits to Internal
 *
 * Revision 1.111  1996/05/16  13:18:56  stephenb
 * MLWorks.Debugger: moved to MLWorks.Internal.Debugger
 * MLWorks.OS.arguments: moved MLWorks.arguments & removed MLWorks.OS
 *
 * Revision 1.109  1996/05/07  10:22:14  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.108  1996/05/03  12:27:52  nickb
 * Add image delivery hooks.
 *
 * Revision 1.107  1996/04/29  14:49:44  matthew
 * Removing Real structure
 *
 * Revision 1.106  1996/04/29  10:47:47  jont
 * Modifications to deliver and save
 *
 * Revision 1.105  1996/04/19  16:13:05  stephenb
 * Put MLWorks.exit back to enable boostrapping from older compilers.
 *
 * Revision 1.104  1996/04/17  11:02:35  stephenb
 * Remove exit, terminate, atExit and most of the OS structure since
 * they are no longer needed now that OS.Process has been updated.
 *
 * Revision 1.103  1996/03/28  11:34:37  matthew
 * Language revisions
 *
 * Revision 1.102  1996/03/20  12:19:32  matthew
 * Changing the type of some things
 *
 * Revision 1.101  1996/03/08  11:42:18  daveb
 * Changed MLWorks.Internal.Dynamic types to new identifier convention.
 *
 * Revision 1.100  1996/02/22  13:15:06  daveb
 * Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
 * some functionality to the Shell structure.
 *
 * Revision 1.99  1996/02/16  15:00:34  nickb
 * "fn_save" becomes "deliver".
 *
 *  Revision 1.98  1996/01/22  11:01:32  matthew
 *  Simplifying treatment of pervasive exceptions
 *
 *  Revision 1.97  1996/01/17  16:05:58  stephenb
 *  OS reorganisation: remove the Unix and NT code as it is going elsewhere.
 *
 *  Revision 1.96  1996/01/16  12:22:05  nickb
 *  Change to GC interface.
 *
 *  Revision 1.95  1996/01/15  16:18:20  matthew
 *  Adding NT directory operations
 *
 *  Revision 1.94  1996/01/15  11:47:45  nickb
 *  Add thread sleep and wake operations.
 *
 *  Revision 1.93  1996/01/12  10:33:22  stephenb
 *  Add MLWORKS.Threads.Internal.reset_signal_status
 *
 *  Revision 1.92  1996/01/08  14:18:00  nickb
 *  Remove signal reservation.
 *
 *  Revision 1.91  1995/12/04  15:55:59  daveb
 *  pervasive module names now begin with a space.
 *
 *  Revision 1.90  1995/11/21  11:22:13  jont
 *  Add Frame.frame_double for accessing directly spilled reals
 *
 *  Revision 1.89  1995/10/17  12:51:59  jont
 *  Add exec_save for saving executables
 *
 *  Revision 1.88  1995/09/13  14:23:26  jont
 *  Add function save to MLWorks for use by exportFn
 *
 *  Revision 1.87  1995/09/12  15:08:33  daveb
 *  Added types for different sizes of words and integers.
 *
 *  Revision 1.85  1995/07/26  14:15:01  jont
 *  Add makestring to word signature and structure
 *
 *  Revision 1.84  1995/07/24  14:20:42  jont
 *  Add Words signature and structure
 *
 *  Revision 1.83  1995/07/20  17:01:30  jont
 *  Add Overflow to structure Exception
 *
 *  Revision 1.82  1995/07/19  15:09:52  nickb
 *  Two constructors called MLWorks.Profile.Profile.
 *
 *  Revision 1.81  1995/07/19  13:51:55  nickb
 *  Whoops; major type screwups in new profiler.
 *
 *  Revision 1.80  1995/07/17  16:33:47  nickb
 *  Change to profiler interface.
 *
 *  Revision 1.79  1995/07/17  11:13:21  jont
 *  Add hex integer printing facilities
 *
 *  Revision 1.78  1995/06/02  14:02:36  nickb
 *  Change threads restart system.
 *
 *  Revision 1.77  1995/05/22  15:45:37  nickb
 *  Add threads interface
 *
 *  Revision 1.76  1995/05/10  17:51:49  daveb
 *  Changed argument of Unix exception from int to string.
 *  Added OS.Unix.{stat,seek,set_block_mode,can_input}.
 *
 *  Revision 1.75  1995/05/02  13:12:39  matthew
 *  Adding CAST and UMAP primitives
 *
 *  Revision 1.74  1995/04/13  14:03:24  jont
 *  Add terminate, atExit functions
 *
 *  Revision 1.73  1995/03/01  11:24:16  matthew
 *  Unifying Value.Frame and Frame.pointer
 *
 *  Revision 1.72  1995/01/12  15:23:07  jont
 *  Add Win_nt.get_current_directory
 *
 *  Revision 1.71  1994/12/09  14:38:44  jont
 *  Add OS.Win_nt structure
 *
 *  Revision 1.70  1994/11/24  16:19:45  matthew
 *  Adding new "unsafe" pervasives
 *
 *  Revision 1.69  1994/09/28  14:45:11  matthew
 *  Added pervasive Option structure
 *
 *  Revision 1.68  1994/08/24  16:31:57  matthew
 *  Adding unsafe array operations
 *
 *  Revision 1.67  1994/07/22  15:37:35  jont
 *  Modify for new code_module
 *
 *  Revision 1.66  1994/07/22  15:26:24  jont
 *  Modify for new code_module
 *
 *  Revision 1.65  1994/07/08  10:08:54  nickh
 *  Add event functions for stack overflow and interrupt handlers.
 *
 *  Revision 1.64  1994/06/29  14:58:56  nickh
 *  Add MLWorks messages stream.
 *
 *  Revision 1.63  1994/06/22  15:27:30  nickh
 *  Add Trace.restore_all.
 *
 *  Revision 1.62  1994/06/09  15:37:46  nickh
 *  Updated runtime signal handling.
 *
 *  Revision 1.61  1994/06/06  11:46:19  nosa
 *  Breakpoint settings on function exits.
 *
 *  Revision 1.60  1994/03/30  14:46:24  daveb
 *  Revised MLWorks.IO.set_modified_file to take a datatype.
 *
 *  Revision 1.59  1994/03/30  13:55:51  daveb
 *  Removed input_string and output_string.
 *
 *  Revision 1.58  1994/03/30  13:22:12  daveb
 *  Added MLWorks.IO.set_file_modified.
 *
 *  Revision 1.57  1994/02/23  17:04:26  nosa
 *  Step and breakpoints Debugger.
 *
 *  Revision 1.56  1994/02/08  14:37:21  matthew
 *  Added realpath function
 *
 *  Revision 1.55  1993/11/25  13:00:45  jont
 *  Reinstated missing version 1.53
 *
 *  Revision 1.54  1993/11/22  14:28:13  jont
 *  Changed type of modules to include a time stamp field
 *
 *  Revision 1.53  1993/11/18  12:05:51  nickh
 *  Add to IO and RawIO to provide closed_in and closed_out functions, which
 *  test a stream for closed-ness.
 *
 *  Revision 1.52  1993/11/15  16:44:26  nickh
 *  New, more versatile time structure.
 *
 *  Revision 1.51  1993/08/27  19:34:57  daveb
 *  Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
 *
 *  Revision 1.50  1993/08/26  11:13:00  richard
 *  Removed the X exception.  It's now in the Motif interface code.
 *
 *  Revision 1.49  1993/08/25  14:01:37  richard
 *  Changed MLWorks.OS.Unix.vfork_* to return the pid of the forked
 *  process.  Added MLWorks.OS.Unix.kill.
 *
 *  Revision 1.48  1993/08/18  12:53:36  daveb
 *  Added X exception.
 *
 *  Revision 1.47  1993/08/10  11:28:49  daveb
 *  Removed "../pervasive" from require statements, for the new make systems.
 *
 *  Revision 1.46  1993/07/23  11:08:17  richard
 *  Added system calls to read directories and the password file.
 *
 *  Revision 1.45  1993/07/19  13:53:26  nosa
 *  Added two frame functions for debugger
 *
 *  Revision 1.44  1993/06/09  16:06:35  matthew
 *  Added text_preprocess hook
 *
 *  Revision 1.43  1993/05/05  17:09:17  jont
 *  Added MLWorks.OS.Unix.password_file to get the association list of user names
 *  to home directories necessary for translating ~
 *
 *  Revision 1.42  1993/04/23  14:56:28  jont
 *  Added Integer and Real substructures of MLWorks with makestring and print functions
 *
 *  Revision 1.41  1993/04/21  15:58:26  richard
 *  Removed defunct Editor interface and added sytem calls to enable
 *  its replacement.
 *
 *  Revision 1.40  1993/04/20  13:52:57  richard
 *  Added more Unix system call interfaces.
 *  New Trace structure to go with runtime implementation.
 *
 *  Revision 1.39  1993/04/13  09:50:58  matthew
 *  Moved dynamic stuff from MLWorks.Internal.Typerep to MLWorks.Dynamic
 *  Moved break stuff from MLWorks.Internal.Tracing to MLWorks.Debugger
 *
 *  Revision 1.38  1993/04/08  17:29:01  jont
 *  Expose vi_file and emacs_file
 *
 *  Revision 1.37  1993/04/02  14:47:39  jont
 *  Extended images structure to include table of contents reading
 *
 *  Revision 1.36  1993/03/26  15:52:31  matthew
 *  Added break function to Tracing substructure
 *
 *  Revision 1.35  1993/03/23  18:29:31  jont
 *  Added vector primitives
 *
 *  Revision 1.34  1993/03/18  16:34:45  jont
 *  Changed the specification of load_codeset to reflect changes in machtypes
 *
 *  Revision 1.33  1993/03/11  18:36:55  jont
 *  Added Intermal.  Images including save and clean.
 *  Added other_operation to Editor for arbitrary bits of emacs lisp
 *
 *  Revision 1.32  1993/03/10  16:40:47  jont
 *  Added Editor substructure to MLWorks
 *
 *  Revision 1.31  1993/02/26  11:13:05  nosa
 *  Implemented a multi-level profiler
 *
 *  Revision 1.30  1993/02/25  18:17:57  matthew
 *  Changed ByteArray.T to ByteArray.bytearray
 *
 *  Revision 1.29  1993/02/18  16:33:36  matthew
 *  Added TypeRep substructure
 *
 *  Revision 1.28  1993/02/09  14:58:38  jont
 *  Changes for code vector reform.
 *
 *  Revision 1.27  1993/01/14  14:45:50  daveb
 *  Added objectfile version argument to load_wordset, to catch an interpreter
 *  trying to load inconsistent code.
 *
 *  Revision 1.26  1993/01/05  16:52:41  richard
 *  Added extra exceptions to those passed to the runtime system.
 *
 *  Revision 1.25  1992/12/22  11:43:12  jont
 *  Removed pervasive vector
 *
 *  Revision 1.24  1992/12/21  11:29:53  daveb
 *  Added support for the 'agreed' Array and Vector structures.
 *  Renamed the old Array to ExtendedArray.
 *
 *  Revision 1.23  1992/11/30  18:51:17  matthew
 *  Tidied up IO signature
 *
 *  Revision 1.22  1992/11/30  17:56:05  matthew
 *  Added representation of streams as records.  Old IO is now RawIO.
 *
 *  Revision 1.21  1992/11/12  17:22:21  clive
 *  Added tracing hooks to the runtime system
 *
 *  Revision 1.20  1992/11/10  13:13:37  richard
 *  Added StorageManager exception and changed the type of the
 *  StorageManager interface function.
 *
 *  Revision 1.19  1992/10/29  17:07:45  richard
 *  Removed debugger structure and added time and event structures.
 *
 *  Revision 1.18  1992/10/06  17:20:26  clive
 *  Type of call_debugger has changed to take debugger function as well
 *  as exception
 *
 *  Revision 1.17  1992/09/25  14:20:56  matthew
 *  Added Internal.string_to_real
 *
 *  Revision 1.16  1992/09/23  16:12:32  daveb
 *  Added clear_eof function to IO.
 *
 *  Revision 1.15  1992/09/01  13:44:40  richard
 *  Changed the types of the OS information stuff.  Added real_to_string,
 *  arguments, Prod and Value.
 *
 *  Revision 1.14  1992/08/28  10:32:51  clive
 *  Added get_code_object_debug_info
 *
 *  Revision 1.13  1992/08/28  08:21:53  richard
 *  Changed call to environment so that it isn't preserved across
 *  images.
 *  Added floating point exceptions.
 *
 *  Revision 1.12  1992/08/26  14:14:16  richard
 *  Rationalisation of the MLWorks structure.
 *
 *  Revision 1.11  1992/08/25  08:37:30  richard
 *  Copied BITS signature to a separate file.
 *  Added ByteArray structure.
 *
 *  Revision 1.10  1992/08/20  12:54:36  richard
 *  Corrected paths to string and array in requires.
 *
 *  Revision 1.9  1992/08/20  12:24:43  richard
 *  Added extra unsafe value utilities.
 *
 *  Revision 1.8  1992/08/18  16:38:55  richard
 *  Corrected type of input_string.
 *
 *  Revision 1.7  1992/08/18  15:36:27  richard
 *  Added more input and output functions for different types.
 *  Added Value structure for opaque value stuff and removed
 *  duplicates elsewhere.
 *
 *  Revision 1.6  1992/08/17  10:58:26  richard
 *  Added MLWorks.System.Runtime.GC.interface.
 *
 *  Revision 1.5  1992/08/15  17:30:02  davidt
 *  Put in IO.input_line function.
 *
 *  Revision 1.4  1992/08/13  11:40:16  clive
 *  Added a function to get header information from an ml_object
 *
 *  Revision 1.3  1992/08/11  15:33:23  clive
 *  Work on tracing
 *
 *  Revision 1.2  1992/08/10  15:26:35  richard
 *  Added load_wordset to interpreter structure.
 *
 *  Revision 1.1  1992/08/10  12:18:46  davidt
 *  Initial revision
 *
 *)

require " array";
require " vector";
require " bytearray";
require " floatarray";
require " string";
require " bits";
require " general";

signature MLWORKS =
  sig

    structure String : STRING

    exception Interrupt

    structure Deliver :
    sig
      datatype app_style = CONSOLE | WINDOWS
      type deliverer = string * (unit -> unit) * app_style -> unit
      type delivery_hook = deliverer -> deliverer
      val deliver : deliverer
      val with_delivery_hook : delivery_hook -> ('a -> 'b) -> 'a -> 'b
      val add_delivery_hook : delivery_hook -> unit
      val exitFn : (unit -> unit) ref
    end
	
    val arguments : unit -> string list
    val name: unit -> string

    structure Threads :
      sig
	type 'a thread
        exception Threads of string
	
	val fork : ('a -> 'b) -> 'a -> 'b thread
	val yield : unit -> unit
	
	datatype 'a result =
	  Running		(* still running *)
	| Waiting		(* waiting *)
	| Sleeping		(* sleeping *)
	| Result of 'a		(* completed, with this result *)
	| Exception of exn	(* exited with this uncaught exn *)
	| Died			(* died (e.g. bus error) *)
	| Killed		(* killed *)
	| Expired		(* no longer exists (from a previous image) *)
	
	val result : 'a thread -> 'a result

	val sleep : 'a thread -> unit
	val wake : 'a thread -> unit

	structure Internal :
	  sig
	    eqtype thread_id
	
	    val id : unit -> thread_id		(* this thread *)
	    val get_id : 'a thread -> thread_id	(* that thread *)
	
	    val children : thread_id -> thread_id list
	    val parent : thread_id -> thread_id
	
	    val all : unit -> thread_id list	 (* all threads *)
	
	    val kill : thread_id -> unit	 (* kill a thread *)
	    val raise_in : thread_id * exn -> unit (* raise E in the thread *)
	    val yield_to : thread_id -> unit	 (* fiddle with scheduling *)
	
	    val state : thread_id -> unit result (* the state of that thread *)
	    val get_num : thread_id -> int	 (* the 'thread number' *)
	
	    val set_handler  : (int -> unit) -> unit
	    	(* fatal signal handler fn for this thread *)
	
	    val reset_fatal_status : unit -> unit
	      (* Mark the thread as being outside of a fatal handler *)

	    structure Preemption :
	      sig
		val start : unit -> unit
		val stop : unit -> unit
		val on : unit -> bool
		val get_interval : unit -> int	(* milliseconds *)
		val set_interval : int -> unit
                val enter_critical_section: unit -> unit
                val exit_critical_section: unit -> unit
                val in_critical_section: unit -> bool
	      end
	  end
      end

    structure Internal :
      sig

	exception Save of string
	val save : string * (unit -> 'a) -> unit -> 'a
	val execSave : string * (unit -> 'a) -> unit -> 'a
        val real_to_string	: real * int -> string
        exception StringToReal
        val string_to_real : string -> real

        val text_preprocess : ((int -> string) -> int -> string) ref

	structure Types :
	  sig
	    type int8
	    type word8
	    type int16
	    type word16
	    type int32
	    type word32
            datatype 'a option = SOME of 'a | NONE
	    datatype time = TIME of int * int * int (* basis time *)
	  end

        structure Error :
          sig
            type syserror
            exception SysErr of string * syserror Types.option
            val errorMsg: syserror -> string
            val errorName: syserror -> string
            val syserror: string -> syserror Types.option
          end


        structure IO :
          sig
            exception Io of {cause: exn, name: string, function: string}

            datatype file_desc = FILE_DESC of int
            val write     : file_desc * string * int * int -> int
            val read      : file_desc * int -> string
            val seek      : file_desc * int * int -> int
            val close     : file_desc -> unit
            val can_input : file_desc -> int
          end


        structure StandardIO :
          sig
            type IOData = {input: {descriptor: IO.file_desc Types.option,
                                   get: int -> string,
                                   get_pos: (unit -> int) Types.option,
                                   set_pos: (int -> unit) Types.option,
                                   can_input: (unit-> bool) Types.option,
                                   close: unit->unit},
              output: {descriptor: IO.file_desc Types.option,
                       put: {buf:string,i:int,sz:int Types.option} -> int,
                       get_pos: (unit -> int) Types.option,
                       set_pos: (int -> unit) Types.option,
                       can_output: (unit-> bool) Types.option,
                       close: unit->unit},
              error: {descriptor: IO.file_desc Types.option,
                      put: {buf:string,i:int,sz:int Types.option} -> int,
                      get_pos: (unit -> int) Types.option,
                      set_pos: (int -> unit) Types.option,
                      can_output: (unit->bool) Types.option,
                      close: unit-> unit},
              access: (unit->unit)->unit}

            val currentIO: unit -> IOData
            val redirectIO: IOData -> unit
            val resetIO: unit -> unit
            val print : string -> unit
            val printError : string -> unit
          end


	structure Images :
	  sig
	    exception Table of string
	    val clean : unit -> unit
	    val save : string * (unit -> 'a) -> unit -> 'a
	    val table : string -> string list
	  end

        structure Bits : BITS

	structure Word32 :
	  sig
            val word32_orb: Types.word32 * Types.word32 -> Types.word32
            val word32_xorb: Types.word32 * Types.word32 -> Types.word32
            val word32_andb: Types.word32 * Types.word32 -> Types.word32
            val word32_notb: Types.word32 -> Types.word32
            val word32_lshift: Types.word32 * word -> Types.word32
            val word32_rshift: Types.word32 * word -> Types.word32
            val word32_arshift: Types.word32 * word -> Types.word32
	  end;

	structure Word :
	  sig
            val word_orb: word * word -> word
            val word_xorb: word * word -> word
            val word_andb: word * word -> word
            val word_notb: word -> word
            val word_lshift: word * word -> word
            val word_rshift: word * word -> word
            val word_arshift: word * word -> word
	  end;

	structure Array : ARRAY
	structure ByteArray : BYTEARRAY
        structure FloatArray: FLOATARRAY
	structure ExtendedArray : EXTENDED_ARRAY
	structure Vector : VECTOR

        structure Value :
          sig
            type ml_value
            type T = ml_value

            exception Value of string

            val cast		: 'a -> 'b
            val ccast		: 'a -> 'b
            val list_to_tuple	: T list -> T
            val tuple_to_list	: T -> T list
            val string_to_real	: string -> real
            val real_to_string	: real -> string

            (* real equality -- needed now real isn't an equality type *)
            val real_equal : real * real -> bool
            val arctan : real -> real
            val cos : real -> real
            val exp : real -> real
            val sin : real -> real
            val sqrt : real -> real

            (* Unchecked arithmetic *)
            val unsafe_plus : int * int -> int
            val unsafe_minus : int * int -> int

            (* Unchecked structure accessing *)
            val unsafe_array_sub : '_a Array.array * int -> '_a
            val unsafe_array_update : '_a Array.array * int * '_a -> unit

            val unsafe_bytearray_sub : ByteArray.bytearray * int -> int
            val unsafe_bytearray_update : ByteArray.bytearray * int * int -> unit

            val unsafe_floatarray_sub : FloatArray.floatarray * int -> real
            val unsafe_floatarray_update : FloatArray.floatarray * int * real -> unit

            val unsafe_record_sub : 'a  * int -> 'b
            (* This is the really nasty one, only use to update a newer object with an older *)
            val unsafe_record_update : 'a  * int * 'b -> unit

            (* Unchecked ordof *)
            val unsafe_string_sub	: string * int -> int

            (* Allows destructive update of strings -- use with care *)
            val unsafe_string_update	: string * int * int -> unit

            (* Allocate an object of the specified type. *)
            (* alloc_pair and alloc_vector initialize slots to 0 *)
            (* alloc_string returns uninitialized string of given size *)
            (* nb. size (alloc_string n) = n-1 as the terminating 0 is counted *)

            val alloc_pair		: unit -> ml_value
            val alloc_vector		: int -> ml_value
            val alloc_string		: int -> string

            datatype print_options =
              DEFAULT |
              OPTIONS of {depth_max	  	: int,
                          string_length_max	: int,
                          indent		: bool,
                          tags		  	: bool}
            val print		: print_options * ml_value -> unit

            val pointer		: T * int -> T
            val primary		: T -> int
            val header		: T -> int * int
            val update_header	: T * int * int -> unit
            val sub		: T * int -> T
            val update		: T * int * T -> unit
            val sub_byte	: T * int -> int
            val update_byte	: T * int * int -> unit

            val exn_name	: exn -> string
            val exn_argument	: exn -> T

            val code_name	: T -> string

	    (* exceptions *)
	    val update_exn : exn * exn ref -> unit
	    val update_exn_cons : ('a -> exn) * ('a -> exn) ref -> unit
	    (* Note well *)
	    (* Since these functions update a pair, which is something *)
	    (* the gc is not expecting to happen, you should take care *)
	    (* that the value being placed into the pair is older *)
	    (* than the pair itself. Also, you should not use the updated *)
	    (* exception within a handler inside the structure in which *)
	    (* it (the exception which has been updated) was originally *)
	    (* defined. This is because the compiler will already have *)
	    (* the original unique available to it, and will use that *)
	    (* when generating the handle, rather then that update value *)
	    (* I would also advise against creating a handler in the same *)
	    (* structure as the one containing the called to update_exn, *)
	    (* for similar reasons *)

            (* This stuff should be implementable in a platform independent way *)
            (* The meaning of frame offsets could be platform dependent though *)
            structure Frame :
              sig
                eqtype frame
                val sub		: frame * int -> T
                val update	: frame * int * T -> unit

                (* Gives the frame of the calling function *)
                val current	: unit -> frame
                val is_ml_frame : frame -> bool

                (* This stuff is required by the debugger but really ought to be *)
                (* chucked out. *)

                val frame_call      : (frame -> 'a) -> 'a
                val frame_next      : frame -> bool * frame * int
                val frame_offset    : frame * int -> T
		val frame_double    : frame * int -> T
                val frame_allocations : frame -> bool
              end
          end

        structure Trace :
          sig
            exception Trace of string
            val intercept	: ('a -> 'b) * (Value.Frame.frame -> unit) -> unit
            val replace		: ('a -> 'b) * (Value.Frame.frame -> unit) -> unit
            val restore		: ('a -> 'b) -> unit
	    val restore_all	: unit -> unit
            datatype status = INTERCEPT | NONE | REPLACE | UNTRACEABLE
            val status		: ('a -> 'b) -> status
          end

        structure Runtime :
          sig
            exception Unbound of string
            val environment	: string -> 'a

            val modules		: (string * Value.T * Value.T) list ref

            structure Loader :
              sig
                exception Load of string
                val load_module		: string -> (string * Value.T)
                val load_wordset :
		  int *
		  {a_names:string list,
		   b:{a_clos:int, b_spills:int, c_saves:int, d_code:string} list,
		   c_leafs:bool list, d_intercept:int list,
		   e_stack_parameters: int list} ->
                  (int * Value.T) list
              end;

            structure Memory :
              sig
                val gc_message_level	: int ref
		val max_stack_blocks    : int ref
		val collect             : int -> unit
		val collect_all         : unit -> unit
		val collections         : unit -> int * int
		val promote_all       : unit -> unit
              end;

            structure Event :
              sig
                datatype T = SIGNAL of int
                exception Signal of string
                val signal : int * (int -> unit) -> unit
		val stack_overflow_handler : (unit -> unit) -> unit
		val interrupt_handler : (unit -> unit) -> unit
              end;
          end

        structure Dynamic :
          sig
	    (* Dynamics are rather special.  They can only be used in the
	       interpreter, and require special compiler support.  The
	       generalises_ref is set in _scheme and used in the coerce
	       function.  The coerce function is called by code that is
	       constructed by code in _typerep_utils. *)

            type dynamic
            type type_rep

            exception Coerce of type_rep * type_rep

            val generalises_ref : ((type_rep * type_rep) -> bool) ref

            (* return a coerced value or raise Coerce Coerce (t,t') if
	       generalisation fails *)
            val coerce : (dynamic * type_rep) -> Value.ml_value
          end

        structure Exit :
        sig
          eqtype key
          type status = int
          val success : status
          val failure : status
          val uncaughtIOException : status
          val badUsage : status
          val stop : status
          val save : status
          val badInput : status
          val atExit : (unit -> unit) -> key
          val removeAtExit : key -> unit
          val exit : status -> 'a
          val terminate : status -> 'a
        end

        structure Debugger :
          sig
            val break_hook : (string -> unit) ref
            val break      : string -> unit
          end

      end (* of structure Internal *)
    structure Profile :
      sig
	type manner
	type function_id = string
	type cost_centre_profile = unit
	
	datatype object_kind =
	  RECORD
	| PAIR
	| CLOSURE
	| STRING
	| ARRAY
	| BYTEARRAY
	| OTHER		(* includes weak arrays, code objects *)
	| TOTAL		(* only used when specifying a profiling manner *)

	datatype large_size =
	  Large_Size of
	  {megabytes : int,
	   bytes : int}	
	
	datatype object_count =
	  Object_Count of
	  {number : int,
	   size : large_size,
	   overhead : int}
	
	datatype function_space_profile =
	  Function_Space_Profile of
	  {allocated : large_size,	
	   copied : large_size,		
	   copies : large_size list,
	   allocation : (object_kind * object_count) list list}
	
	datatype function_caller =
	  Function_Caller of
	  {id: function_id,
	   found: int,
	   top: int,
	   scans: int,
	   callers: function_caller list}
	
	datatype function_time_profile =
	  Function_Time_Profile of
	  {found: int,
	   top: int,
	   scans: int,
	   depth: int,
	   self: int,
	   callers: function_caller list}
	
	datatype function_profile =
	  Function_Profile of
	  {id: function_id,
	   call_count: int,
	   time: function_time_profile,
	   space: function_space_profile}
	
	datatype general_header =
	  General of
	  {data_allocated: int,
	   period: Internal.Types.time,
	   suspended: Internal.Types.time}
	
	datatype call_header =
	  Call of {functions : int}
	
	datatype time_header =
	  Time of
	  {data_allocated: int,
	   functions: int,
	   scans: int,
	   gc_ticks: int,
	   profile_ticks: int,
	   frames: real,
	   ml_frames: real,
	   max_ml_stack_depth: int}
	
	datatype space_header =
	  Space of
	  {data_allocated: int,
	   functions: int,
	   collections: int,
	   total_profiled : function_space_profile}

	type cost_header = unit
	
	datatype profile =
	  Profile of
	  {general: general_header,
	   call: call_header,
	   time: time_header,
	   space: space_header,
	   cost: cost_header,
	   functions: function_profile list,
	   centres: cost_centre_profile list}

	  datatype options =
	    Options of
	    {scan : int,
	     selector : function_id -> manner}

	  datatype 'a result =
	    Result of 'a
	  | Exception of exn

        exception ProfileError of string

	val profile : options -> ('a -> 'b) -> 'a -> ('b result * profile)

	  val make_manner :
	    {time : bool,
	     space : bool,
	     calls : bool,
	     copies : bool,
	     depth : int,
	     breakdown : object_kind list} -> manner
      end

  end (* of structure MLWorks *) ;
@


1.147
log
@[Bug #30090]
Remove MLWorks.IO
@
text
@d8 4
d520 1
d891 17
@


1.146
log
@[Bug #30090]
Remove all of MLWorks.IO
@
text
@d8 4
a581 5
      end

    structure IO :
      sig
	exception Io of string
@


1.145
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d8 4
a582 35

	type instream
        val instream  : {input		: int -> string,
                         lookahead	: unit -> string,
                         end_of_stream	: unit -> bool,
                         clear_eof	: unit -> unit,
                         close_in	: unit -> unit,
			 closed_in      : unit -> bool} -> instream
	type outstream
        val outstream : {output		: string -> unit,
                         flush_out	: unit -> unit,
                         close_out	: unit -> unit,
			 closed_out     : unit -> bool} -> outstream
        val terminal_in         : instream
        val std_in              : instream
        val terminal_out        : outstream
        val std_out             : outstream
        val std_err             : outstream
        val open_in             : string -> instream
        val open_out            : string -> outstream
        val end_of_stream       : instream -> bool
        val input               : instream * int -> string
	val clear_eof		: instream -> unit
        val lookahead           : instream -> string
        val output              : outstream * string -> unit
        val close_in            : instream -> unit
        val close_out           : outstream -> unit
	val closed_in           : instream -> bool
	val closed_out          : outstream -> bool
        val flush_out		: outstream -> unit
	val input_line		: instream -> string
        val with_standard_output : outstream -> (unit -> 'a) -> 'a
        val with_standard_input : instream -> (unit -> 'a) -> 'a
        val with_standard_error : outstream -> (unit -> 'a) -> 'a

@


1.144
log
@[Bug #30134]
Change meaning of third arg of deliver and convert to datatype.
@
text
@d8 4
a596 1
	val messages		: outstream
@


1.143
log
@[Bug #30089]
Furhter work on getting rid of MLWorks.Time
Also removing {set_,}file_modified
@
text
@d8 5
d499 2
a500 1
      type deliverer = string * (unit -> unit) * bool -> unit
@


1.142
log
@[Bug #30204]
Add comment indicating restrictions on use of update_exn
@
text
@d8 4
d485 1
a485 1
signature MLWORKS = 
a503 79
    structure Time :
      sig
	
	structure Interval :
	  sig

	    eqtype T 	(* an interval is a difference between two times *)

	    (* convert to/from floating-point number of seconds *)

            val to_real : T -> real
	    val from_real : real -> T

	    val - : T * T -> T
	    val + : T * T -> T
	    val * : T * real -> T
	    val / : T * real -> T

	    val < : T * T -> bool

	    (* Exact formatting, and probably as fast as Real.makestring *)

	    val decimal_places : int ref
	    val format : T -> string
	  end

	structure Elapsed :
	  sig

	    (* where did the time go? *)
	
	    datatype T = ELAPSED of {real: Interval.T,
				     user: Interval.T,
				     system: Interval.T,
				     gc: Interval.T}

	    (* time elapsed since this MLWorks started. *)

	    val elapsed : unit -> T

	    (* elapsed_since is provided for efficiency; cheaper than
	     * Elapsed.-(x,Elapsed.elapsed()) *)

	    val elapsed_since : T -> T

	    (* arithmetic *)

	    val - : T * T -> T
	    val + : T * T -> T
	    val * : T * real -> T
	    val / : T * real -> T

	    (* typically: "1.23 (user: 1.07, system: 0.06, gc: 0.03)" *)
	
	    val format: T -> string
	  end
	
	(* a clock time *)

	eqtype time

	val zero : time		 (* constant and before any other time *)

	val now : unit -> time		(* read the clock *)
	val < : time * time -> bool

	val interval: time * time -> Interval.T
	
	val - : time * Interval.T -> time
	val + : time * Interval.T -> time
	
	datatype zone = GREENWICH | LOCAL
	val format : string * zone * time -> string (* ANSI C's strftime *)
	
	val encode : time -> string
	val decode : string -> time
	
      end

a600 3
        val file_modified	: string -> Time.time
	datatype modtime = NOW | TIME of Time.time
        val set_file_modified	: string * modtime -> unit
a606 119
    structure Profile :
      sig
	type manner
	type function_id = string
	type cost_centre_profile = unit
	
	datatype object_kind =
	  RECORD
	| PAIR
	| CLOSURE
	| STRING
	| ARRAY
	| BYTEARRAY
	| OTHER		(* includes weak arrays, code objects *)
	| TOTAL		(* only used when specifying a profiling manner *)

	datatype large_size =
	  Large_Size of
	  {megabytes : int,
	   bytes : int}	
	
	datatype object_count =
	  Object_Count of
	  {number : int,
	   size : large_size,
	   overhead : int}
	
	datatype function_space_profile =
	  Function_Space_Profile of
	  {allocated : large_size,	
	   copied : large_size,		
	   copies : large_size list,
	   allocation : (object_kind * object_count) list list}
	
	datatype function_caller =
	  Function_Caller of
	  {id: function_id,
	   found: int,
	   top: int,
	   scans: int,
	   callers: function_caller list}
	
	datatype function_time_profile =
	  Function_Time_Profile of
	  {found: int,
	   top: int,
	   scans: int,
	   depth: int,
	   self: int,
	   callers: function_caller list}
	
	datatype function_profile =
	  Function_Profile of
	  {id: function_id,
	   call_count: int,
	   time: function_time_profile,
	   space: function_space_profile}
	
	datatype general_header =
	  General of
	  {data_allocated: int,
	   period: Time.Interval.T,
	   suspended: Time.Interval.T}
	
	datatype call_header =
	  Call of {functions : int}
	
	datatype time_header =
	  Time of
	  {data_allocated: int,
	   functions: int,
	   scans: int,
	   gc_ticks: int,
	   profile_ticks: int,
	   frames: real,
	   ml_frames: real,
	   max_ml_stack_depth: int}
	
	datatype space_header =
	  Space of
	  {data_allocated: int,
	   functions: int,
	   collections: int,
	   total_profiled : function_space_profile}

	type cost_header = unit
	
	datatype profile =
	  Profile of
	  {general: general_header,
	   call: call_header,
	   time: time_header,
	   space: space_header,
	   cost: cost_header,
	   functions: function_profile list,
	   centres: cost_centre_profile list}

	  datatype options =
	    Options of
	    {scan : int,
	     selector : function_id -> manner}

	  datatype 'a result =
	    Result of 'a
	  | Exception of exn

        exception ProfileError of string

	val profile : options -> ('a -> 'b) -> 'a -> ('b result * profile)

	  val make_manner :
	    {time : bool,
	     space : bool,
	     calls : bool,
	     copies : bool,
	     depth : int,
	     breakdown : object_kind list} -> manner
      end

d628 1
d855 1
a855 1
            val modules		: (string * Value.T * Time.time) list ref
d917 119
@


1.141
log
@[Bug #30204]
Add update_exn and update_exn_cons
@
text
@d8 4
d998 13
@


1.140
log
@[Bug #30226]
Add exitFn for storing the function to call when the exe exits normally.
@
text
@d8 4
d990 4
@


1.139
log
@[Bug #30084]
Add datatype MLWorks.Internal.Types.option.
Change all occurences of General.option to the new option.
@
text
@d8 5
d486 1
@


1.139.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 5
 * Revision 1.139  1997/08/04  10:37:27  brucem
 * [Bug #30084]
 * Add datatype MLWorks.Internal.Types.option.
 * Change all occurences of General.option to the new option.
 *
@


1.139.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 5
 * Revision 1.139  1997/08/04  10:37:27  brucem
 * [Bug #30084]
 * Add datatype MLWorks.Internal.Types.option.
 * Change all occurences of General.option to the new option.
 *
@


1.138
log
@[Bug #20014]
adding MLWorks.name
@
text
@d8 4
d468 1
a468 1
signature MLWORKS =
d792 1
d802 11
d816 1
a816 1
            exception SysErr of string * syserror General.option
d819 1
a819 1
            val syserror: string -> syserror General.option
d838 1
a838 1
            type IOData = {input: {descriptor: IO.file_desc General.option,
d840 3
a842 3
                                   get_pos: (unit -> int) General.option,
                                   set_pos: (int -> unit) General.option,
                                   can_input: (unit-> bool) General.option,
d844 5
a848 5
              output: {descriptor: IO.file_desc General.option,
                       put: {buf:string,i:int,sz:int General.option} -> int,
                       get_pos: (unit -> int) General.option,
                       set_pos: (int -> unit) General.option,
                       can_output: (unit-> bool) General.option,
d850 5
a854 5
              error: {descriptor: IO.file_desc General.option,
                      put: {buf:string,i:int,sz:int General.option} -> int,
                      get_pos: (unit -> int) General.option,
                      set_pos: (int -> unit) General.option,
                      can_output: (unit->bool) General.option,
a873 10
	structure Types :
	  sig
	    type int8
	    type word8
	    type int16
	    type word16
	    type int32
	    type word32
	  end;

d1081 2
a1082 2
      end
  end;
@


1.137
log
@[Bug #30101]

Adding sin and cos
@
text
@d8 5
d480 1
@


1.136
log
@Adding print_error to StandardIO
@
text
@d8 3
d908 5
@


1.135
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d8 4
d836 2
@


1.134
log
@[Bug #30091]
Remove MLWorks.Internal.FileIO and related stuff
@
text
@d8 4
d1004 2
a1005 1
		   c_leafs:bool list, d_intercept:int list} ->
@


1.133
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d8 4
a1021 14
          end

        structure FileIO :
          sig
            (* Crappy hack until we are rid of NewJersey *)

            type fd
            datatype offset = BEG | CUR | END
            val openf		: string -> fd
            val closef		: fd -> unit
            val seekf		: fd * int * offset -> unit
	    val write_byte	: fd * int -> unit
            val writef		: fd * string -> unit
            val writebf		: fd * ByteArray.bytearray * int * int -> unit
@


1.132
log
@[Bug #1989]
removing Internal.Value.exn_name_string.
@
text
@d8 4
a460 6
    structure Option : 
      sig 
        datatype 'a option = SOME of 'a | NONE 
        datatype ('a,'b) union = INL of 'a | INR of 'b 
      end

d491 1
a491 1
	    
d499 1
a499 1
	    val elapsed : unit -> T  
d504 1
a504 1
	    val elapsed_since : T -> T 
d514 1
a514 1
	      
d528 1
a528 1
	  
d531 1
a531 1
	  
d534 1
a534 1
	  
d537 1
a537 1
	  
d540 1
a540 1
    structure Threads : 
d544 1
a544 1
	  
d547 1
a547 1
	  
d557 1
a557 1
	  
d566 1
a566 1
	      
d569 1
a569 1
	      
d572 1
a572 1
	      
d574 1
a574 1
	      
d578 1
a578 1
	      
d581 1
a581 1
	      
d584 1
a584 1
	      
d588 1
a588 1
	    structure Preemption : 
d651 1
a651 1
	  
d666 1
a666 1
	  
d672 1
a672 1
	  
d679 1
a679 1
	  
d687 1
a687 1
	  
d696 1
a696 1
	  
d703 2
a704 2
	  
	datatype general_header = 
d709 2
a710 2
	  
	datatype call_header = 
d712 1
a712 1
	  
d723 2
a724 2
	  
	datatype space_header = 
d727 3
a729 3
	   functions: int, 
	   collections: int, 
	   total_profiled : function_space_profile} 
d732 1
a732 1
	  
d748 1
a748 1
	  datatype 'a result = 
d779 1
a779 1
            exception SysErr of string * syserror Option.option
d782 1
a782 1
            val syserror: string -> syserror Option.option
d799 1
a799 1
        structure StandardIO : 
d801 1
a801 1
            type IOData = {input: {descriptor: IO.file_desc Option.option,
d803 3
a805 3
                                   get_pos: (unit -> int) Option.option,
                                   set_pos: (int -> unit) Option.option,
                                   can_input: (unit-> bool) Option.option,
d807 5
a811 5
              output: {descriptor: IO.file_desc Option.option,
                       put: {buf:string,i:int,sz:int Option.option} -> int,
                       get_pos: (unit -> int) Option.option,
                       set_pos: (int -> unit) Option.option,
                       can_output: (unit-> bool) Option.option,
d813 5
a817 5
              error: {descriptor: IO.file_desc Option.option,
                      put: {buf:string,i:int,sz:int Option.option} -> int,
                      get_pos: (unit -> int) Option.option,
                      set_pos: (int -> unit) Option.option,
                      can_output: (unit->bool) Option.option,
d820 1
a820 1
              
d1053 1
a1053 1
            
@


1.132.1.1
log
@branched from 1.132
@
text
@a7 4
 * Revision 1.132  1997/03/25  11:46:48  andreww
 * [Bug #1989]
 * removing Internal.Value.exn_name_string.
 *
@


1.132.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.132.1.1  1997/05/12  10:39:12  hope
 * branched from 1.132
 *
@


1.132.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.132.1.1  1997/05/12  10:39:12  hope
 * branched from 1.132
 *
@


1.132.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.132.1.1  1997/05/12  10:39:12  hope
 * branched from 1.132
 *
@


1.132.1.1.1.2
log
@[Bug #30191]
Removed delivery from Student Edition.
@
text
@a7 3
 * Revision 1.132.1.1.1.1  1997/07/28  18:24:07  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d453 8
@


1.132.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 4
 * Revision 1.132.1.1.1.2  1997/08/06  18:40:18  daveb
 * [Bug #30191]
 * Removed delivery from Student Edition.
 *
@


1.131
log
@[Bug #1431]
Adding Io exception from basis to Internal Value so that
general exnMessage prints it nicely.
@
text
@d8 5
d944 1
a944 1
            val exn_name	: exn -> T
a945 1
            val exn_name_string	: T -> string
@


1.130
log
@[Bug #1677]
Adding hook for stopping preemption.  This is used to keep
the GUI listener operating correctly --- when the user types
"stop pre-empting", the listener must claim its access mutex
before actually stopping, otherwise a concurrent thread
it will go to sleep,and
a concurrent thread will continue executing.
@
text
@d8 8
d777 3
d785 2
@


1.129
log
@Adding unsafe floatarray operations to Internal.Value
@
text
@d8 3
d802 2
a803 1
                      close: unit-> unit}}
@


1.128
log
@[Bug #1891]
Adding critical section primitives for threads.
@
text
@d8 4
d882 3
@


1.127
log
@[Bug #1818]
Adding new FloatArray primitives.
@
text
@d8 4
d577 3
@


1.126
log
@Adding real equality builtin to MLWorks.Internal.Value.
@
text
@d8 3
d411 1
d840 1
@


1.125
log
@[Bug #1682]
removing MLWorks.General
@
text
@d8 4
d852 3
@


1.125.4.1
log
@branched from 1.125
@
text
@a7 4
 * Revision 1.125  1996/10/21  14:42:28  andreww
 * [Bug #1682]
 * removing MLWorks.General
 *
@


1.125.3.1
log
@branched from 1.125
@
text
@a7 4
 * Revision 1.125  1996/10/21  14:42:28  andreww
 * [Bug #1682]
 * removing MLWorks.General
 *
@


1.125.3.1.1.1
log
@branched from 1.125.3.1
@
text
@a7 3
 * Revision 1.125.3.1  1996/12/17  17:52:19  hope
 * branched from 1.125
 *
@


1.125.2.1
log
@branched from 1.125
@
text
@a7 4
 * Revision 1.125  1996/10/21  14:42:28  andreww
 * [Bug #1682]
 * removing MLWorks.General
 *
@


1.125.1.1
log
@branched from 1.125
@
text
@a7 4
 * Revision 1.125  1996/10/21  14:42:28  andreww
 * [Bug #1682]
 * removing MLWorks.General
 *
@


1.125.1.1.1.1
log
@branched from 1.125.1.1
@
text
@a7 3
 * Revision 1.125.1.1  1996/11/14  12:55:27  hope
 * branched from 1.125
 *
@


1.124
log
@[Bug #1666]
Adding Threads exception to MLWorks.Threads
@
text
@d8 4
a567 2

    structure General : GENERAL
@


1.123
log
@[Bug #1490]
update String maxSize
@
text
@d8 4
d509 1
@


1.123.2.1
log
@branched from 1.123
@
text
@a7 4
 * Revision 1.123  1996/09/18  14:10:18  io
 * [Bug #1490]
 * update String maxSize
 *
@


1.123.1.1
log
@branched from 1.123
@
text
@a7 4
 * Revision 1.123  1996/09/18  14:10:18  io
 * [Bug #1490]
 * update String maxSize
 *
@


1.122
log
@[Bug #1554]
Introduce MLWorks.Internal.IO as a repository for file_desc
and the read, write, seek, ... etc. stuff.
@
text
@d8 5
a402 1
    structure ByteArray : BYTEARRAY
a735 1

d824 1
@


1.122.1.1
log
@branched from 1.122
@
text
@a7 5
 * Revision 1.122  1996/08/21  09:00:38  stephenb
 * [Bug #1554]
 * Introduce MLWorks.Internal.IO as a repository for file_desc
 * and the read, write, seek, ... etc. stuff.
 *
@


1.121
log
@Incorporated gui_standard_io signature.
@
text
@d8 3
a722 1
        exception SysErr of string * int Option.option
d732 19
d753 1
a753 1
            type IOData = {input: {descriptor: int Option.option,
d759 1
a759 1
              output: {descriptor: int Option.option,
d765 1
a765 1
              error: {descriptor: int Option.option,
a770 6
              
            val read: int * int -> string
            val write: int * string * int * int -> int
            val seek: int * int * int -> int
            val close: int -> unit
            val can_input: int -> int
@


1.120
log
@Adding exception Empty.
@
text
@d8 3
a989 2


@


1.119
log
@adding General to the top level.
@
text
@d8 3
a387 1
require " gui_standard_io";
d727 32
a758 1
        structure GuiStandardIO: GUI_STANDARD_IO
@


1.118
log
@Extend datatype MLWorks.Internal.Trace.status.
@
text
@d8 3
d384 2
d548 2
d725 2
d954 1
@


1.117
log
@Revising top level for revised basis.
@
text
@d8 3
d861 1
a861 1
            datatype status = INTERCEPT | NONE | REPLACE
@


1.116
log
@Fixing problem with SysErr
@
text
@d8 3
a378 19
signature CHAR =
  sig

    eqtype char

    exception Chr

    val chr : int -> char
    val ord : char -> int

    val maxCharOrd : int

    val <  : (char * char) -> bool
    val <= : (char * char) -> bool
    val >  : (char * char) -> bool
    val >= : (char * char) -> bool

  end

d384 2
a385 1
    structure Char : CHAR
d542 2
@


1.115
log
@Removed MLWorks.RawIO.
@
text
@d8 3
d718 1
@


1.114
log
@Changing type of real_to_string
@
text
@d8 3
a551 22
    structure RawIO :
      sig
	type instream
	type outstream
        val std_in              : instream
        val std_out             : outstream
        val std_err             : outstream
        val open_in             : string -> instream
        val open_out            : string -> outstream
        val end_of_stream       : instream -> bool
        val input               : instream * int -> string
	val clear_eof		: instream -> unit
        val lookahead           : instream -> string
        val output              : outstream * string -> unit
	val output_byte		: outstream * int -> unit
	val close_in            : instream -> unit
        val close_out           : outstream -> unit
        val flush_out		: outstream -> unit
	val closed_in           : instream -> bool
	val closed_out          : outstream -> bool
      end

d820 1
a820 1
            val print		: print_options * RawIO.outstream * ml_value -> unit
@


1.113
log
@Changing type of word32 shift operations
@
text
@d8 3
d737 1
a737 1
        val real_to_string	: real -> string
@


1.112
log
@Moving Bits to Internal
@
text
@d8 3
d766 3
a768 3
            val word32_lshift: Types.word32 * Types.word32 -> Types.word32
            val word32_rshift: Types.word32 * Types.word32 -> Types.word32
            val word32_arshift: Types.word32 * Types.word32 -> Types.word32
@


1.111
log
@MLWorks.Debugger: moved to MLWorks.Internal.Debugger
MLWorks.OS.arguments: moved MLWorks.arguments & removed MLWorks.OS
@
text
@d8 4
a387 1
    structure Bits : BITS
d754 2
@


1.110
log
@MLWorks.Debugger: moved to MLWorks.Internal.Debugger
MLWorks.OS.arguments: moved MLWorks.arguments & removed MLWorks.OS
@
text
@@


1.109
log
@Array moving to MLWorks.Array
@
text
@d8 3
d395 1
a395 1
    val exit : int -> unit
a867 13
	(*
        structure Architecture :
          sig
            datatype name = SPARC
            val name	: unit -> name

            structure SPARC :
              sig
                val flush_windows	: unit -> unit
              end
          end
        *)

d952 5
a956 15
      end

(*
    structure Integer :
      sig
	val makestring : int -> string
	val print : int -> unit
	val hexmakestring : int -> string
	val hexprint : int -> unit
      end
*)
    structure OS :
      sig
        val arguments	: unit -> string list
      end
a957 4
    structure Debugger :
      sig
        val break_hook              : (string -> unit) ref
        val break                   : string -> unit
@


1.108
log
@Add image delivery hooks.
@
text
@d8 3
a378 3
    structure Array : ARRAY
    structure ExtendedArray : EXTENDED_ARRAY
    structure Vector : VECTOR
d770 4
@


1.107
log
@Removing Real structure
@
text
@d8 3
d384 8
a391 2
    val deliver : string * (unit -> unit) * bool -> unit

@


1.106
log
@Modifications to deliver and save
@
text
@d8 3
d951 1
d959 1
a959 7

    structure Real :
      sig
	val makestring : real -> string
	val print : real -> unit
      end

@


1.105
log
@Put MLWorks.exit back to enable boostrapping from older compilers.
@
text
@d8 3
d378 1
a378 4
    exception Save of string
    val save : string * (unit -> 'a) -> unit -> 'a
    val deliver : string * (unit -> unit) -> unit
    val exec_save : string * (unit -> 'a) -> unit -> 'a
d710 3
@


1.104
log
@Remove exit, terminate, atExit and most of the OS structure since
they are no longer needed now that OS.Process has been updated.
@
text
@d8 4
d379 2
@


1.103
log
@Language revisions
@
text
@d8 3
a375 4
    val exit : int -> unit
    val terminate : int -> unit
    val atExit : (unit -> unit) -> unit

a954 5
        datatype name = UNIX | WIN_NT

        val name	: unit -> name

        val system	: string -> int
a955 1

@


1.102
log
@Changing the type of some things
@
text
@d8 3
d587 2
a588 4
	type function_id
	  sharing type function_id = string
	type cost_centre_profile
	  sharing type cost_centre_profile = unit
d669 1
a669 2
	type cost_header
	  sharing type cost_header = unit
a752 1
            type T
d754 1
a754 1
            sharing type T = ml_value
@


1.101
log
@Changed MLWorks.Internal.Dynamic types to new identifier convention.
@
text
@d8 3
d761 1
a761 1
            val list_to_tuple	: 'a list -> T
d792 2
a793 2
            val alloc_pair		: unit -> 'a
            val alloc_vector		: int -> 'a
d802 1
a802 1
            val print		: print_options * RawIO.outstream * 'a -> unit
d804 8
a811 8
            val pointer		: 'a * int -> 'b
            val primary		: 'a -> int
            val header		: 'a -> int * int
            val update_header	: 'a * int * int -> unit
            val sub		: 'a * int -> 'b
            val update		: 'a * int * 'b -> unit
            val sub_byte	: 'a * int -> int
            val update_byte	: 'a * int * int -> unit
d814 1
a814 1
            val exn_argument	: exn -> 'a
d836 2
a837 2
                val frame_offset    : frame * int -> 'a
		val frame_double    : frame * int -> 'a
d869 1
a869 1
            val environment	: string -> Value.T
@


1.100
log
@Moved MLWorks.Dynamic to MLWorks.Internal.Dynamic.  Hid some members; moved
some functionality to the Shell structure.
@
text
@d8 4
d924 2
a925 2
            type Dynamic
            type Type
d927 1
a927 1
            exception Coerce of Type * Type
d929 1
a929 1
            val generalises_ref : ((Type * Type) -> bool) ref
d933 1
a933 1
            val coerce : (Dynamic * Type) -> Value.ml_value
@


1.99
log
@"fn_save" becomes "deliver".
@
text
@d8 3
d912 20
a964 19
    structure Dynamic :
      sig
        type Dynamic
        type Type

        exception Coerce of Type * Type

        (* raise Coerce (t,t') if generalisation fails *)
        val generalises_ref : ((Type * Type) -> bool) ref
        val generalises : (Type * Type) -> bool

        (* coerce utility function *)
        (* return a coerced value or raise Coerce *)
        val coerce : (Dynamic * Type) -> Internal.Value.ml_value
                  
        val get_type : Dynamic -> Type
        val get_value : Dynamic -> Internal.Value.ml_value
      end
            
@


1.98
log
@Simplifying treatment of pervasive exceptions
@
text
@d8 3
d357 1
a357 1
    val fn_save : string * (unit -> unit) -> unit
@


1.97
log
@OS reorganisation: remove the Unix and NT code as it is going elsewhere.
@
text
@d8 3
a889 26

            structure Exception :
              sig
                val Abs			: exn ref
                val Diff		: exn ref
                val Div			: exn ref
                val Exp			: exn ref
                val Floor		: exn ref
                val Io			: exn ref
                val Ln			: exn ref
                val Load		: exn ref
                val Mod			: exn ref
		val Overflow		: exn ref
                val Prod		: exn ref
                val Profile		: exn ref
                val Quot		: exn ref
                val Save		: exn ref
                val Signal		: exn ref
                val Sqrt		: exn ref
                val StringToReal        : exn ref
                val Substring		: exn ref
                val Sum			: exn ref
                val Trace		: exn ref
                val Unbound		: exn ref
                val Value		: exn ref
              end
@


1.96
log
@Change to GC interface.
@
text
@d8 3
a910 2
                val Unix		: exn ref
                val WouldBlock		: exn ref
a953 96
        structure Unix :
          sig
            exception Unix of string
            exception WouldBlock
            datatype sockaddr = SOCKADDR_UNIX of string
            val environment	: unit -> string list
            val setwd		: string -> unit
            val getwd		: unit -> string
            val realpath	: string -> string
            val rusage :
              unit ->
              {idrss    : int,            (* integral resident set size *)
               inblock	: int,            (* block input operations *)
               isrss	: int,            (* currently 0 *)
               ixrss	: int,            (* currently 0 *)
               majflt	: int,            (* page faults requiring physical I/O *)
               maxrss	: int,            (* maximum resident set size *)
               minflt	: int,            (* page faults not requiring physical I/O *)
               msgrcv	: int,            (* messages received *)
               msgsnd	: int,            (* messages sent *)
               nivcsw	: int,            (* involuntary context switches *)
               nsignals	: int,            (* signals received *)
               nswap	: int,            (* swaps *)
               nvcsw	: int,            (* voluntary context switches *)
               oublock	: int,            (* block output operations *)
               stime	: Time.Interval.T, (* system time used *)
               utime	: Time.Interval.T} (* user time used *)
	    val stat :
	      int ->
	      {dev	: int,
	       ino	: int,
	       mode	: int,
	       nlink	: int,
	       uid	: int,
	       gid	: int,
	       rdev	: int,
	       size	: int,
	       atime	: Time.time,
	       mtime	: Time.time,
	       ctime	: Time.time,
	       blksize	: int,
	       blocks	: int}
            val open_		: string * int * int -> int
            val close		: int -> unit
	    val unlink		: string -> unit
	    val set_block_mode	: int * bool -> unit
	    val can_input	: int -> int
            val write		: int * string -> int
            val read		: int * int -> string
	    val seek		: int * int -> unit
            val socket		: int * int * int -> int
            val bind		: int * sockaddr -> int
            val getsockname	: int -> sockaddr
            val getpeername	: int -> sockaddr
            val connect		: int * sockaddr -> unit
            val accept		: int -> int * sockaddr
            val listen		: int * int -> unit
            val execve		: string * string list * string list -> unit
            val execv		: string * string list -> unit
            val execvp		: string * string list -> unit
            val vfork_execve	: string * string list * string list -> int
            val vfork_execv	: string * string list -> int
            val vfork_execvp	: string * string list -> int
            val kill		: int * int -> unit
            type dir
            val opendir		: string -> dir
            val readdir		: dir -> string
            val closedir	: dir -> unit
	    val mkdir		: string * int -> unit
	    val rmdir		: string -> unit
            datatype passwd =
              PASSWD of {dir	: string,
                         gecos	: string,
                         gid	: int,
                         name	: string,
                         passwd	: string,
                         shell	: string,
                         uid	: int}
            val getpwent	: unit -> passwd
            val setpwent	: unit -> unit
            val endpwent	: unit -> unit
            val getpwuid	: int -> passwd
            val getpwnam	: string -> passwd
          end

	structure Win_nt :
	  sig
	    exception Nt of int
	    val environment			: unit -> string list
            val get_current_directory		: unit -> string
	    val get_path_name			: string -> string
            type DirHandle
            val find_first_file : string -> string * DirHandle
            val find_next_file : DirHandle -> string
            val find_close : DirHandle -> unit
	  end
@


1.95
log
@Adding NT directory operations
@
text
@d8 3
d866 1
a866 1
            structure StorageManager :
d869 5
a873 2
                exception StorageManager of int
                val interface		: int * 'a -> Value.T
a902 1
                val StorageManager	: exn ref
@


1.94
log
@Add thread sleep and wake operations.
@
text
@d8 3
d1039 4
@


1.93
log
@Add MLWORKS.Threads.Internal.reset_signal_status
@
text
@d8 3
d452 4
a455 1
	  
@


1.92
log
@Remove signal reservation.
@
text
@d8 3
d472 3
@


1.91
log
@pervasive module names now begin with a space.
@
text
@d8 3
d859 3
a861 8
                val signal : int * ('a -> unit) -> unit

		val reserve_signal : int -> unit
		val release_signal : int -> unit
		val signal_reserved : int -> bool

		val stack_overflow_handler : ('a -> unit) -> unit
		val interrupt_handler : ('a -> unit) -> unit
@


1.90
log
@Add Frame.frame_double for accessing directly spilled reals
@
text
@d8 3
d295 5
a299 5
require "array";
require "vector";
require "bytearray";
require "string";
require "bits";
@


1.89
log
@Add exec_save for saving executables
@
text
@d8 3
d794 1
@


1.88
log
@Add function save to MLWorks for use by exportFn
@
text
@d8 3
d328 1
@


1.87
log
@Added types for different sizes of words and integers.
@
text
@d8 3
d324 1
@


1.86
log
@Add ml_char for giving textual representation of chars
@
text
@a305 34
    val ml_char : char -> string
  end

signature WORD = 
  sig
    eqtype word

    val wordSize : int

    val wordToInt  : word -> int
    val signExtend : word -> int
    val intToWord  : int -> word

    val orb  : word * word -> word
    val xorb : word * word -> word
    val andb : word * word -> word
    val notb : word -> word

    val lshift  : word * word -> word
    val rshift  : word * word -> word
    val arshift : word * word -> word

    val + : word * word -> word
    val - : word * word -> word
    val * : word * word -> word
    val div : word * word -> word
    val mod : word * word -> word

    val >  : word * word -> bool
    val >= : word * word -> bool
    val <  : word * word -> bool
    val <= : word * word -> bool

    val makestring : word -> string
a317 1
    structure Word : WORD
d665 32
d787 1
d798 1
@


1.85
log
@Add makestring to word signature and structure
@
text
@d8 3
d306 1
@


1.84
log
@Add Words signature and structure
@
text
@d8 3
d335 1
@


1.83
log
@Add Overflow to structure Exception
@
text
@d8 3
d302 32
d344 1
@


1.82
log
@Two constructors called MLWorks.Profile.Profile.
@
text
@d8 3
d819 1
@


1.81
log
@Whoops; major type screwups in new profiler.
@
text
@d8 3
d624 1
a624 1
        exception Profile of string
@


1.80
log
@Change to profiler interface.
@
text
@d8 3
a540 2
	type object_breakdown = (object_kind * object_count) list
	  
d546 1
a546 1
	   allocation : object_breakdown list}
d575 2
a576 2
	   period: MLWorks.Time.Interval.T,
	   suspended: MLWorks.Time.Interval.T}
d600 1
a600 1
	  sharing cost_header = unit
@


1.79
log
@Add hex integer printing facilities
@
text
@d8 3
d511 86
a596 4
        datatype options =
          OPTIONS of {depth	: int,
                      scan	: int,
                      select	: string list}
d598 22
d622 9
a630 1
        val profile : options -> IO.outstream -> ('a -> 'b) -> 'a -> 'b
@


1.78
log
@Change threads restart system.
@
text
@d8 3
d268 19
d296 1
d735 2
@


1.77
log
@Add threads interface
@
text
@d8 3
d405 2
a406 2
	    val set_restart : (unit -> unit) -> unit
	    	(* restart fn for this thread *)
@


1.76
log
@Changed argument of Unix exception from int to string.
Added OS.Unix.{stat,seek,set_block_mode,can_input}.
@
text
@d8 4
d362 52
@


1.75
log
@Adding CAST and UMAP primitives
@
text
@d8 3
d628 1
d672 2
a673 1
            exception Unix of int
d697 15
d715 2
d719 1
@


1.74
log
@Add terminate, atExit functions
@
text
@d8 3
d458 1
a744 13
        val set_step_hook           : ((int * string) -> unit) ref
        val set_step                : (int * string) -> unit
        val set_breakpoint_hook     : (string -> unit) ref
        val set_breakpoint          : string -> unit
        val set_breakpoint_on_exit_hook     : (string -> unit) ref
        val set_breakpoint_on_exit          : string -> unit
        val delete_breakpoint_hook  : (string -> unit) ref
        val delete_breakpoint       : string -> unit
        val delete_breakpoints_hook : (unit -> unit) ref
        val delete_breakpoints      : unit -> unit
        val list_breakpoints_hook   : (unit -> string list) ref
        val list_breakpoints        : unit -> string list
        val script                  : string list ref
@


1.73
log
@Unifying Value.Frame and Frame.pointer
@
text
@d8 3
d266 2
@


1.72
log
@Add Win_nt.get_current_directory
@
text
@d8 3
d508 20
a527 9
            (* This stuff is required by the debugger but really ought to be *)
            (* chucked out. *)

            eqtype frame
            val frame_call      : (frame -> 'a) -> 'a
            val frame_next      : frame -> bool * frame * int
            val frame_sub       : frame * int -> T
            val frame_offset	: frame * int -> 'a
            val frame_allocations : frame -> bool
a537 8

                structure Frame :
                  sig
                    eqtype pointer
                    val sub		: pointer * int -> Value.T
                    val update		: pointer * int * Value.T -> unit
                    val current		: unit -> pointer
                  end
d544 2
a545 2
            val intercept	: ('a -> 'b) * (Architecture.SPARC.Frame.pointer -> unit) -> unit
            val replace		: ('a -> 'b) * (Architecture.SPARC.Frame.pointer -> unit) -> unit
a733 1
        datatype 'a option = ABSENT | PRESENT of 'a
a735 2
        val step_hook               : (string * exn option -> unit) ref
        val step                    : string * exn option -> unit
a737 2
        val breakpoint_hook         : (string -> unit) ref
        val breakpoint              : string -> unit
a739 2
        val breakpoint_on_exit_hook         : (string -> unit) ref
        val breakpoint_on_exit              : string -> unit
@


1.71
log
@Add OS.Win_nt structure
@
text
@d8 3
d720 3
a722 1
	    val environment : unit -> string list
@


1.70
log
@Adding new "unsafe" pervasives
@
text
@d8 3
d641 1
a641 1
        datatype name = UNIX
d713 6
@


1.69
log
@Added pervasive Option structure
@
text
@d8 3
d446 5
d456 19
@


1.68
log
@Adding unsafe array operations
@
text
@d8 3
d251 6
@


1.67
log
@Modify for new code_module
@
text
@d8 3
d433 6
@


1.66
log
@Modify for new code_module
@
text
@d8 3
d507 1
@


1.65
log
@Add event functions for stack overflow and interrupt handlers.
@
text
@d8 3
d504 3
a506 5
                  int * 
                  (string list *
                   (int * int * string) list *
                   bool list *
                   int list) ->
@


1.64
log
@Add MLWorks messages stream.
@
text
@d8 3
d521 1
d525 3
@


1.63
log
@Add Trace.restore_all.
@
text
@d8 3
d352 1
d354 1
a354 1
        val terminal_in         : instream
d357 1
a357 1
        val terminal_out        : outstream
@


1.62
log
@Updated runtime signal handling.
@
text
@d8 3
d477 1
@


1.61
log
@Breakpoint settings on function exits.
@
text
@d8 3
d510 3
@


1.60
log
@Revised MLWorks.IO.set_modified_file to take a datatype.
@
text
@d8 3
d654 4
@


1.59
log
@Removed input_string and output_string.
@
text
@d8 3
d359 2
a360 1
        val set_file_modified	: string * Time.time -> unit
@


1.58
log
@Added MLWorks.IO.set_file_modified.
@
text
@d8 3
a348 1
        val output_string	: outstream * string -> unit
a354 1
        val input_string	: instream * int -> string
@


1.57
log
@Step and breakpoints Debugger.
@
text
@d8 3
d355 1
@


1.56
log
@Added realpath function
@
text
@d8 3
d494 1
a494 1
                val signal : int * (int -> unit) -> unit
d631 18
a648 2
        val break_hook   : (string -> unit) ref
        val break        : string -> unit
@


1.55
log
@Reinstated missing version 1.53
@
text
@d8 3
d566 1
@


1.54
log
@Changed type of modules to include a time stamp field
@
text
@d8 7
d304 1
d307 2
d318 2
a319 1
                         close_in	: unit -> unit} -> instream
d323 2
a324 1
                         close_out	: unit -> unit} -> outstream
d340 2
@


1.53
log
@Add to IO and RawIO to provide closed_in and closed_out functions, which
test a stream for closed-ness.
@
text
@a296 1
	val close_in            : instream -> unit
a298 2
	val closed_in           : instream -> bool
	val closed_out          : outstream -> bool
d308 1
a308 2
                         close_in	: unit -> unit,
			 closed_in      : unit -> bool} -> instream
d312 1
a312 2
                         close_out	: unit -> unit,
			 closed_out     : unit -> bool} -> outstream
a327 2
	val closed_in           : instream -> bool
	val closed_out          : outstream -> bool
d448 1
a448 1
            val modules		: (string * Value.T) list ref
@


1.52
log
@New, more versatile time structure.
@
text
@d8 3
d297 1
d300 2
d311 2
a312 1
                         close_in	: unit -> unit} -> instream
d316 2
a317 1
                         close_out	: unit -> unit} -> outstream
d333 2
@


1.51
log
@Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
@
text
@d8 3
d202 44
a245 3
        structure Real :
          sig
            type T
d247 4
a250 4
            val now		: unit -> T
            val equal		: T * T -> bool
            val <		: T * T -> bool
            val zero		: T
d252 6
a257 2
            datatype zone = GREENWICH | LOCAL
            val format	: string * zone * T -> string
d259 1
a259 3
            val encode	: T -> string
            val decode	: string -> T
          end
d261 1
a261 3
        structure Virtual :
          sig
            type T
d263 14
a276 6
            val user	: unit -> T
            val system	: unit -> T
            val gc		: unit -> T
            val -		: T * T -> T
            val format	: T -> string
          end
d328 1
a328 1
        val file_modified	: string -> Time.Real.T
d562 2
a563 2
               stime	: Time.Virtual.T, (* system time used *)
               utime	: Time.Virtual.T} (* user time used *)
@


1.51.1.1
log
@Fork for bug fixing
@
text
@a7 3
 *  Revision 1.51  1993/08/27  19:34:57  daveb
 *  Added MLworks.OS.Unix.{unlink,rmdir,mkdir}.
 *
@


1.50
log
@Removed the X exception.  It's now in the Motif interface code.
@
text
@d8 3
d514 1
d535 2
@


1.49
log
@Changed MLWorks.OS.Unix.vfork_* to return the pid of the forked
process.  Added MLWorks.OS.Unix.kill.
@
text
@d8 4
a443 1
                val X			: exn ref
@


1.48
log
@Added X exception.
@
text
@d8 3
d520 4
a523 3
            val vfork_execve	: string * string list * string list -> unit
            val vfork_execv	: string * string list -> unit
            val vfork_execvp	: string * string list -> unit
@


1.47
log
@Removed "../pervasive" from require statements, for the new make systems.
@
text
@d8 3
d437 1
@


1.46
log
@Added system calls to read directories and the password file.
@
text
@d8 3
d163 5
a167 5
require "../pervasive/array";
require "../pervasive/vector";
require "../pervasive/bytearray";
require "../pervasive/string";
require "../pervasive/bits";
@


1.45
log
@Added two frame functions for debugger
@
text
@d8 3
a474 1
	    val password_file   : unit -> (string * string) list
d513 17
@


1.44
log
@Added text_preprocess hook
@
text
@d8 3
d336 2
@


1.43
log
@Added MLWorks.OS.Unix.password_file to get the association list of user names
to home directories necessary for translating ~
@
text
@d8 4
d278 2
@


1.42
log
@Added Integer and Real substructures of MLWorks with makestring and print functions
@
text
@d8 3
d461 1
@


1.41
log
@Removed defunct Editor interface and added sytem calls to enable
its replacement.
@
text
@d8 4
d212 1
a212 1
        val close_in            : instream -> unit
d423 6
a428 5
            val openf  : string -> fd
            val closef : fd -> unit
            val seekf  : fd * int * offset -> unit
            val writef : fd * string -> unit
            val writebf : fd * ByteArray.bytearray * int * int -> unit
d431 12
@


1.40
log
@Added more Unix system call interfaces.
New Trace structure to go with runtime implementation.
@
text
@d8 4
a193 12
    structure Editor :
      sig
	datatype Editor = EMACS | VI
	exception NotFound of string * string
	val load_file : string list -> unit
	val emacs_file : string list -> unit
	val vi_file : string list -> unit
	val other_operation : string -> unit
      (* For arbitrary bits of emacs lisp*)
      (* Vi has no hope here *)
      end

d473 6
@


1.39
log
@Moved dynamic stuff from MLWorks.Internal.Typerep to MLWorks.Dynamic
Moved break stuff from MLWorks.Internal.Tracing to MLWorks.Debugger
@
text
@d8 4
d28 2
a29 2
 *  Added Intermal.Images including save and clean. Added other_operation to Editor
 *  for arbitrary bits of emacs lisp
d77 2
a78 1
 *  Type of call_debugger has changed to take debugger function as well as exception
a201 35
    structure OS :
      sig
        datatype name = UNIX

        val name	: unit -> name

        val system	: string -> int
        val arguments	: unit -> string list

        structure Unix :
          sig
            val environment	: unit -> string list
            val setwd		: string -> unit
            val getwd		: unit -> string
            val rusage :
              unit ->
              {idrss    : int,            (* integral resident set size *)
               inblock	: int,            (* block input operations *)
               isrss	: int,            (* currently 0 *)
               ixrss	: int,            (* currently 0 *)
               majflt	: int,            (* page faults requiring physical I/O *)
               maxrss	: int,            (* maximum resident set size *)
               minflt	: int,            (* page faults not requiring physical I/O *)
               msgrcv	: int,            (* messages received *)
               msgsnd	: int,            (* messages sent *)
               nivcsw	: int,            (* involuntary context switches *)
               nsignals	: int,            (* signals received *)
               nswap	: int,            (* swaps *)
               nvcsw	: int,            (* voluntary context switches *)
               oublock	: int,            (* block output operations *)
               stime	: Time.Virtual.T, (* system time used *)
               utime	: Time.Virtual.T} (* user time used *)
          end
      end

d225 1
a225 1
                         lookahead		: unit -> string,
d227 2
a228 2
                         clear_eof		: unit -> unit,
                         close_in		: unit -> unit} -> instream
d231 2
a232 2
                         flush_out		: unit -> unit,
                         close_out		: unit -> unit} -> outstream
d258 6
d265 1
a265 2
    exception Profile of string
    val profile : int * bool * string list * IO.outstream * int * (unit -> 'a) -> 'a
d267 3
d298 7
a304 1
            val print		: IO.outstream * int * int * bool * 'a -> unit
d321 3
d325 4
d330 17
a346 3
            val frame_call	: (frame -> 'a) -> 'a
            val frame_next	: frame -> bool * frame * int
            val frame_sub	: frame * int -> T
d349 1
a349 1
        structure Tracing :
d351 6
a356 4
            val add_trace    : ('a -> 'b) -> bool
            val remove_trace : ('a -> 'b) -> bool
            val with_tracing : ((Value.ml_value * Value.ml_value) -> 
                                (Value.ml_value -> unit)) -> ('a -> 'b) -> 'a -> 'b
d370 7
a376 3
                val load_wordset	: int *
		  (string list * (int * int * string) list * bool list * int list) ->
					    (int * Value.T) list
d414 1
d416 1
d434 48
@


1.38
log
@Expose vi_file and emacs_file
@
text
@d8 3
a349 2
            val break_hook   : (string -> unit) ref
            val break        : string -> unit
a407 20
        structure TypeRep :
          sig
            datatype Label = LABEL of string
            datatype TyName = TYNAME of (int * string * bool)
            datatype TypeRep =
              TYVAR of (int * bool * bool)
            | RECTYPE of (Label * TypeRep) list
            | FUNTYPE of (TypeRep * TypeRep)
            | CONSTYPE of (TypeRep list * TyName)

            exception Coerce
                
            type Dynamic

            val generalises : (TypeRep * TypeRep) -> bool
                  
            val get_type : Dynamic -> TypeRep
            val get_value : Dynamic -> Value.ml_value
          end
            
d423 25
@


1.37
log
@Extended images structure to include table of contents reading
@
text
@d8 3
d187 2
@


1.36
log
@Added break function to Tracing substructure
@
text
@d8 3
d292 1
d295 1
@


1.35
log
@Added vector primitives
@
text
@d8 3
d337 2
@


1.34
log
@Changed the specification of load_codeset to reflect changes in machtypes
@
text
@d8 3
a132 1
(*
a133 1
*)
d177 1
a177 1
	val load_file : string -> unit
@


1.33
log
@Added Intermal.Images including save and clean. Added other_operation to Editor
for arbitrary bits of emacs lisp
@
text
@d8 4
d346 2
a347 1
                val load_wordset	: int * (string list * (int * int * string) list) ->
@


1.32
log
@Added Editor substructure to MLWorks
@
text
@d8 3
d173 3
d278 6
@


1.31
log
@Implemented a multi-level profiler
@
text
@d8 3
d163 7
@


1.30
log
@Changed ByteArray.T to ByteArray.bytearray
@
text
@d8 3
d255 1
a255 1
    val profile : IO.outstream * int * (unit -> 'a) -> 'a
@


1.29
log
@Added TypeRep substructure
@
text
@d8 3
d391 1
a391 1
            val writebf : fd * ByteArray.T * int * int -> unit
@


1.28
log
@Changes for code vector reform.
@
text
@d8 3
d358 20
@


1.27
log
@Added objectfile version argument to load_wordset, to catch an interpreter
trying to load inconsistent code.
@
text
@d8 4
d311 1
a311 1
                val load_wordset	: int * (int * int * string) list ->
@


1.26
log
@Added extra exceptions to those passed to the runtime system.
@
text
@d8 3
d307 2
a308 1
                val load_wordset	: (int * int * string) list -> (int * Value.T) list
@


1.25
log
@Removed pervasive vector
@
text
@d8 3
d324 1
d327 1
d334 1
d338 1
d341 1
a342 1
                val StorageManager	: exn ref
@


1.24
log
@Added support for the 'agreed' Array and Vector structures.
Renamed the old Array to ExtendedArray.
@
text
@d8 4
d101 1
d103 1
@


1.23
log
@Tidied up IO signature
@
text
@d8 3
d87 1
d96 2
@


1.22
log
@Added representation of streams as records.  Old IO is now RawIO.
@
text
@d8 3
d217 3
@


1.21
log
@Added tracing hooks to the runtime system
@
text
@d8 3
d163 19
d185 5
d191 3
a193 1

d195 1
d198 1
d213 1
d216 1
d290 1
a290 1
                val interface		: int * 'a -> 'b
@


1.20
log
@Added StorageManager exception and changed the type of the
StorageManager interface function.
@
text
@d8 4
d229 8
@


1.19
log
@Removed debugger structure and added time and event structures.
@
text
@d8 3
a90 17
    structure OS :
      sig
        datatype name = UNIX

        val name	: unit -> name

        val system	: string -> int
        val arguments	: unit -> string list

        structure Unix :
          sig
            val environment	: unit -> string list
            val setwd		: string -> unit
            val getwd		: unit -> string
          end
      end

d121 35
d240 1
a240 1
            
d244 2
a245 1
                val interface		: Value.T ref
d272 1
@


1.18
log
@Type of call_debugger has changed to take debugger function as well as exception
@
text
@d5 6
a10 1
 * $Log: mlworks.sml,v $
d83 52
a150 3
        val output_real		: outstream * real -> unit
        val output_int		: outstream * int -> unit
        val output_bool		: outstream * bool -> unit
d156 1
a156 3
        val input_real		: instream -> real
        val input_int		: instream -> int
        val input_bool		: instream -> bool
a161 19
    exception Save of string
    val save : string * (unit -> 'a) -> unit -> 'a

    structure OS :
      sig
        val name	: unit -> string
        val release	: unit -> string
        val version	: unit -> string
        val machine	: unit -> string

        val system	: string -> int
        val arguments	: unit -> string list

        structure Unix :
          sig
            val environment	: unit -> string list
          end
      end

d167 1
a175 2
            type address

a181 2
            val output		: IO.outstream * T -> unit
            val input		: IO.instream -> T
d184 1
a184 3
            val is_pointer	: 'a -> bool
            val pointer		: address * int -> 'a
            val address		: 'a -> address
d186 6
a191 5
            val secondary	: 'a -> int
            val length		: 'a -> int
            val update		: address * int * 'a -> unit
            val update_byte	: address * int * int -> unit
            val update_header	: address * int * int -> unit
a195 1
          end
d197 1
a197 4
        structure Timer :
          sig
            datatype time = TIME of int * int * int
            type timer
d199 1
a199 1
            exception TimerOverflow
d201 3
a203 6
            val start_timer : unit -> timer
            val check_timer : timer -> time
            val check_timer_sys : timer -> time
            val check_timer_gc : timer -> time
            val makestring  : time -> string
            val earlier : time * time -> bool
d226 7
d245 1
a248 1
                val TimerOverflow	: exn ref
a255 5
            type time
            exception FileDoesNotExist
            datatype fname = PATH of string
            val mtime : fname -> time

a266 40
        structure Debugger :
          sig
            eqtype StackFrame

            datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of Value.T
            datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of Value.T * int * int

            val install_debugger : (StackFrame * Type_Of_Exception * Value.T -> Debugger_Result) -> unit
            val call_debugger : (StackFrame * Type_Of_Exception * Value.T -> Debugger_Result) * exn -> unit

            val get_data_from_frame : StackFrame -> string
            val get_next_frame : StackFrame -> bool * StackFrame * int
            val start_single_stepping : unit -> unit
            val stop_single_stepping : unit -> unit

            datatype Register = 
              I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
              L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
            datatype Tag =
              ERROR |
              INTEGER |
              PAIRPTR |
              POINTER |
              REFPTR
            val get_value_from_frame : StackFrame * Register -> Value.T

            val get_primary_tag : Value.T -> Tag
            val get_header : Value.T -> int * int

            val get_object_at_address : Value.T * int -> Value.T
            val exit : int -> 'a

            val call_function : (Value.T * int * int) * Value.T * StackFrame ref -> Value.T

            val tag_as_interesting : Value.T -> unit
            val untag_as_interesting : Value.T -> unit

            val get_code_object_debug_info : Value.T -> string

          end
@


1.17
log
@Added Internal.string_to_real
@
text
@d6 3
d251 1
a251 1
            val call_debugger : exn -> unit
@


1.16
log
@Added clear_eof function to IO.
@
text
@d6 3
d129 2
a130 1

d214 1
@


1.15
log
@Changed the types of the OS information stuff.  Added real_to_string,
arguments, Prod and Value.
@
text
@d6 4
d84 1
@


1.14
log
@Added get_code_object_debug_info
@
text
@d6 3
d75 1
d104 4
a107 4
        val name	: string
        val release	: string
        val version	: string
        val machine	: string
d110 1
d120 2
d201 1
d208 1
@


1.13
log
@Changed call to environment so that it isn't preserved across
images.
Added floating point exceptions.
@
text
@d6 5
d257 3
@


1.12
log
@Rationalisation of the MLWorks structure.
@
text
@d6 3
d104 1
a104 1
            val environment	: string list
d182 3
d186 2
d189 3
a191 1
                val Div			: exn ref
a192 2
                val Save		: exn ref
                val Profile		: exn ref
a193 1
                val Load		: exn ref
@


1.11
log
@Copied BITS signature to a separate file.
Added ByteArray structure.
@
text
@d6 4
a51 82
    structure System :
      sig

        type instream
        type outstream

	val system : string -> int
	val environ : unit -> string list
    
	exception Profile of string
        val profile : outstream * int * (unit -> 'a) -> 'a

        exception Save of string
        val save : string * (unit -> 'a) -> unit -> 'a

        structure Unsafe :
          sig
            structure Value :
              sig
                type T
                type ml_value
                sharing type T = ml_value

                exception Value of string

                type address

                val cast		: 'a -> 'b
                val list_to_tuple	: 'a list -> T
                val tuple_to_list	: T -> T list
                val string_to_real	: string -> real
                val real_to_string	: real -> string

                val output		: outstream * T -> unit
                val input		: instream -> T
                val print		: outstream * int * int * bool * 'a -> unit

                val is_pointer		: 'a -> bool
                val pointer		: address * int -> 'a
                val address		: 'a -> address
                val primary		: 'a -> int
                val secondary		: 'a -> int
                val length		: 'a -> int
                val update		: address * int * 'a -> unit
                val update_byte		: address * int * int -> unit
                val update_header	: address * int * int -> unit

                val exn_name		: exn -> T
                val exn_argument	: exn -> 'a
                val exn_name_string	: T -> string
              end
                          
            structure Int :
	      sig
                val load_wordset	: (int * int * string) list -> (int * Value.T) list
                val ml_require		: string -> Value.T
                val discard_modules	: unit -> unit
                val call_ml_value	: Value.T -> Value.T list
	      end
          end

        structure Runtime :
          sig
            structure GC :
              sig
                val message_level : int ref
                val interface : Unsafe.Value.T ref
              end

            structure Exception :
              sig
                val Io : exn ref
                val Mod : exn ref
                val Div : exn ref
                val Substring : exn ref
                val Save : exn ref
                val Profile : exn ref
                val TimerOverflow : exn ref
              end
          end
      end

a56 13
    structure Timer :
      sig
	exception TimerOverflow
	datatype time = TIME of int * int * int
	type timer
	val start_timer : unit -> timer
	val check_timer : timer -> time
	val check_timer_sys : timer -> time
	val check_timer_gc : timer -> time
	val makestring  : time -> string
	val earlier : time * time -> bool
      end

a59 1
        sharing type instream = System.instream
d61 1
a61 1
        sharing type outstream = System.outstream
d83 8
a90 2
      
    structure FileIO :
d92 11
a102 14
	type time
	exception FileDoesNotExist
	datatype fname = PATH of string
	val mtime : fname -> time

	(* Crappy hack until we are rid of NewJersey *)

	type fd
	datatype offset = BEG | CUR | END
	val openf  : string -> fd
	val closef : fd -> unit
	val seekf  : fd * int * offset -> unit
	val writef : fd * string -> unit
        val writebf : fd * ByteArray.T * int * int -> unit
d105 1
a105 1
    structure Debugger :
d107 108
a214 1
	eqtype StackFrame
d216 2
a217 2
	datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of System.Unsafe.Value.T
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of System.Unsafe.Value.T * int * int
d219 18
a236 2
	val install_debugger : (StackFrame * Type_Of_Exception * System.Unsafe.Value.T -> Debugger_Result) -> unit
	val call_debugger : exn -> unit
d238 8
a245 25
	val get_data_from_frame : StackFrame -> string
	val get_next_frame : StackFrame -> bool * StackFrame * int
	val start_single_stepping : unit -> unit
        val stop_single_stepping : unit -> unit

	datatype Register = 
	  I0 | I1 | I2 | I3 | I4 | I5 | I6 | I7 |
	  L0 | L1 | L2 | L3 | L4 | L5 | L6 | L7
	datatype Tag =
	  ERROR |
	  INTEGER |
	  PAIRPTR |
	  POINTER |
	  REFPTR
	val get_value_from_frame : StackFrame * Register -> System.Unsafe.Value.T

	val get_primary_tag : System.Unsafe.Value.T -> Tag
        val get_header : System.Unsafe.Value.T -> int * int

	val get_object_at_address : System.Unsafe.Value.T * int -> System.Unsafe.Value.T
	val exit : int -> 'a
      
        val call_function : (System.Unsafe.Value.T * int * int) * System.Unsafe.Value.T * StackFrame ref -> System.Unsafe.Value.T
	val tag_as_interesting : System.Unsafe.Value.T -> unit
	val untag_as_interesting : System.Unsafe.Value.T -> unit
@


1.10
log
@Corrected paths to string and array in requires.
@
text
@d6 3
d41 1
d43 1
d131 1
a131 1

d133 1
a133 11

    structure Bits :
      sig
	val andb    : int * int -> int
	val orb     : int * int -> int
	val xorb    : int * int -> int
	val lshift  : int * int -> int
	val rshift  : int * int -> int
	val arshift : int * int -> int
	val notb    : int -> int
      end
d191 1
@


1.9
log
@Added extra unsafe value utilities.
@
text
@d6 3
d37 2
a38 2
require "../rts/array";
require "../rts/string";
@


1.8
log
@Corrected type of input_string.
@
text
@d6 3
a54 2
        val exn_name : exn -> string

d62 1
d64 3
d72 1
d75 15
d96 1
@


1.7
log
@Added more input and output functions for different types.
Added Value structure for opaque value stuff and removed
duplicates elsewhere.
@
text
@d6 5
d150 1
a150 1
        val input_string	: instream -> string
@


1.6
log
@Added MLWorks.System.Runtime.GC.interface.
@
text
@d6 3
d31 64
a109 8
    structure IO :
      sig
	type instream
	type outstream
        val flush_out : outstream -> unit
	val input_line : instream -> string
      end
      
d123 28
a170 1
	type ml_value
d172 2
a173 2
	datatype Debugger_Result = CONTINUE | DO_SINGLE_STEP | TRACE_RETURN_VALUE of ml_value
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int * int
d175 1
a175 1
	val install_debugger : (StackFrame * Type_Of_Exception * ml_value -> Debugger_Result) -> unit
d181 1
d192 1
a192 1
	val get_value_from_frame : StackFrame * Register -> ml_value
d194 2
a195 2
	val get_primary_tag : ml_value -> Tag
        val get_header : ml_value -> int * int
d197 1
a197 1
	val get_object_at_address : ml_value * int -> ml_value
d200 3
a202 7
	val coerce_object_to_string : ml_value -> string
	val coerce_object_to_int : ml_value -> int
	val coerce_object_to_real : ml_value -> real

        val call_function : (ml_value * int * int) * ml_value * StackFrame ref -> ml_value
	val tag_as_interesting : ml_value -> unit
	val untag_as_interesting : ml_value -> unit
a204 49
    structure System :
      sig
	val system : string -> int
	val environ : unit -> string list
    
        type outstream
	exception Profile of string
        val profile : outstream * int * (unit -> 'a) -> 'a

        exception Save of string
        val save : string * (unit -> 'a) -> unit -> 'a

        val val_print : 'a * int -> 'a * int
        val exn_name : exn -> string

        structure Unsafe :
          sig
            structure Int :
	      sig
		type ml_value
		val call_ml_value         : ml_value -> ml_value list
		val make_ml_value         : 'a -> ml_value
		val make_ml_value_tuple   : ml_value list -> ml_value
		val ml_value_from_offset  : ml_value * int -> ml_value
		val ml_require            : string -> ml_value 
                val load_wordset	  : (int * int * string) list -> (int * ml_value) list
	      end
          end

        structure Runtime :
          sig
            structure GC :
              sig
                val message_level : int ref
                val interface : 'a ref
              end

            structure Exception :
              sig
                val Io : exn ref
                val Mod : exn ref
                val Div : exn ref
                val Substring : exn ref
                val Save : exn ref
                val Profile : exn ref
                val TimerOverflow : exn ref
              end
          end
      end
@


1.5
log
@Put in IO.input_line function.
@
text
@d6 3
d156 1
@


1.4
log
@Added a function to get header information from an ml_object
@
text
@d6 3
d42 1
d45 1
@


1.3
log
@Work on tracing
@
text
@d6 3
d98 1
d100 2
a101 1
	  
d107 1
@


1.2
log
@Added load_wordset to interpreter structure.
@
text
@d6 3
d72 1
a72 1
	type StackFrame
d76 1
a76 1
	datatype Type_Of_Exception = CONTINUABLE | NON_CONTINUABLE | SINGLE_STEP of ml_value * int
d103 1
a103 1
	val call_function : ml_value * ml_value * int -> ml_value
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
 * $Log$
d130 1
@
