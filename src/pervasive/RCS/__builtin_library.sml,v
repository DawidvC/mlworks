head	1.48;
access;
symbols
	MLW_daveb_inline_1_4_99:1.48.1
	MLWorks_21c0_1999_03_25:1.48
	MLWorks_20c1_1998_08_20:1.48
	MLWorks_20c0_1998_08_04:1.48
	MLWorks_20b2c2_1998_06_19:1.48
	MLWorks_20b2_Windows_1998_06_12:1.48
	MLWorks_20b1c1_1998_05_07:1.48
	MLWorks_20b0_1998_04_07:1.48
	MLWorks_20b0_1998_03_20:1.48
	MLWorks_20m2_1998_02_16:1.47
	MLWorks_20m1_1997_10_23:1.47
	MLWorks_11r1:1.47.1.1.1.1.1
	MLWorks_workspace_97:1.47.3
	MLWorks_dt_wizard:1.47.2
	MLWorks_11c0_1997_09_09:1.47.1.1.1.1
	MLWorks_10r3:1.47.1.1.3
	MLWorks_10r2_551:1.47.1.1.2
	MLWorks_11:1.47.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.47.1.1
	MLWorks_20m0_1997_06_20:1.47
	MLWorks_1_0_r2c2_1997_06_14:1.47.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.47.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.47.1
	MLWorks_BugFix_1997_04_24:1.47
	MLWorks_1_0_r2_Win32_1997_04_11:1.47
	MLWorks_1_0_r2_Unix_1997_04_04:1.47
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.46.6.1.1
	MLWorks_gui_1996_12_18:1.46.7
	MLWorks_1_0_Win32_1996_12_17:1.46.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.46.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.46.4.1
	MLWorks_1_0_Irix_1996_11_28:1.46.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.46.5
	MLWorks_1_0_Unix_1996_11_14:1.46.4
	MLWorks_Open_Beta2_1996_10_11:1.46.3
	MLWorks_License_dev:1.46.2
	MLWorks_1_open_beta_1996_09_13:1.46.1
	MLWorks_Open_Beta_1996_08_22:1.46
	MLWorks_Beta_1996_07_02:1.46
	MLWorks_Beta_1996_06_07:1.46
	MLWorks_Beta_1996_06_06:1.46
	MLWorks_Beta_1996_06_05:1.46
	MLWorks_Beta_1996_06_03:1.46
	MLWorks_Beta_1996_05_31:1.46
	MLWorks_Beta_1996_05_30:1.46
	ML_beta_release_12/08/94:1.30
	ML_beta_release_03/08/94:1.30
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.28
	mlworks-28-01-1994:1.28
	Release:1.28
	mlworks-beta-01-09-1993:1.28
	MLWorks-1-0-4-29/01/1993:1.24
	MLWorks-1-0-3-21/12/1992:1.23
	MLWorks-1-0-2-15/12/1992:1.23
	MLWorks-1-0-1-04/12/1992:1.23
	checkpoint_17_08_92:1.17;
locks; strict;
comment	@ * @;


1.48
date	98.02.17.13.59.31;	author mitchell;	state Exp;
branches
	1.48.1.1;
next	1.47;

1.47
date	97.01.06.15.55.38;	author andreww;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1;
next	1.46;

1.46
date	96.05.20.10.04.01;	author matthew;	state Exp;
branches
	1.46.1.1
	1.46.2.1
	1.46.3.1
	1.46.4.1
	1.46.5.1
	1.46.6.1
	1.46.7.1;
next	1.45;

1.45
date	96.04.19.14.28.10;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.03.20.10.58.16;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.03.08.12.11.34;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.09.15.15.24.06;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	95.09.12.15.03.26;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	95.07.28.14.51.03;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	95.07.20.15.39.00;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	95.07.14.09.42.59;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.05.31.14.42.58;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.05.25.11.05.05;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.04.28.16.30.49;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.02.10.15.56.30;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.11.18.16.55.33;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.11.10.13.36.29;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.08.31.15.52.44;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	94.07.11.12.51.12;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.03.09.17.14.37;	author nickh;	state Exp;
branches;
next	1.28;

1.28
date	93.07.20.13.53.31;	author jont;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	93.04.21.16.57.38;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	93.03.23.12.45.54;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.03.04.17.06.30;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.01.06.10.39.57;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.11.25.15.17.05;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.09.30.12.08.47;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.08.27.10.48.15;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	92.08.24.07.48.41;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.08.20.12.24.43;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.08.17.13.25.12;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.08.14.20.10.23;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.08.13.16.34.08;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	92.07.28.13.45.09;	author richard;	state Exp;
branches;
next	1.14;

1.14
date	92.06.23.14.15.30;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.06.19.15.47.23;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.06.18.16.21.22;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.06.17.09.40.58;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.06.16.17.03.26;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.06.15.15.43.07;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.06.12.18.32.37;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.05.20.10.25.41;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.05.13.12.02.25;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.03.03.11.19.50;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.02.24.18.14.27;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.02.19.17.27.03;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.02.18.09.53.18;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.02.13.18.05.00;	author clive;	state Exp;
branches;
next	;

1.28.1.1
date	93.07.20.13.53.31;	author jont;	state Exp;
branches;
next	;

1.46.1.1
date	96.09.13.11.21.01;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.10.07.16.10.58;	author hope;	state Exp;
branches;
next	;

1.46.3.1
date	96.10.17.11.29.33;	author hope;	state Exp;
branches;
next	;

1.46.4.1
date	96.11.14.12.55.24;	author hope;	state Exp;
branches
	1.46.4.1.1.1;
next	;

1.46.4.1.1.1
date	96.11.28.15.06.04;	author hope;	state Exp;
branches;
next	;

1.46.5.1
date	96.11.22.18.13.47;	author hope;	state Exp;
branches;
next	;

1.46.6.1
date	96.12.17.17.52.17;	author hope;	state Exp;
branches
	1.46.6.1.1.1;
next	;

1.46.6.1.1.1
date	97.02.24.11.43.04;	author hope;	state Exp;
branches;
next	;

1.46.7.1
date	96.12.18.09.46.41;	author hope;	state Exp;
branches;
next	;

1.47.1.1
date	97.05.12.10.39.10;	author hope;	state Exp;
branches
	1.47.1.1.1.1
	1.47.1.1.2.1
	1.47.1.1.3.1;
next	;

1.47.1.1.1.1
date	97.07.28.18.24.04;	author daveb;	state Exp;
branches
	1.47.1.1.1.1.1.1;
next	;

1.47.1.1.1.1.1.1
date	97.10.07.11.49.52;	author jkbrook;	state Exp;
branches;
next	;

1.47.1.1.2.1
date	97.09.08.17.17.28;	author daveb;	state Exp;
branches;
next	;

1.47.1.1.3.1
date	97.09.09.14.13.37;	author daveb;	state Exp;
branches;
next	;

1.47.2.1
date	97.09.10.19.29.44;	author brucem;	state Exp;
branches;
next	;

1.47.3.1
date	97.09.11.20.59.32;	author daveb;	state Exp;
branches;
next	;

1.48.1.1
date	99.04.01.17.59.50;	author daveb;	state Exp;
branches;
next	;


desc
@First version - should be a dummy function definition for every
builtin that is defined in _pervasives.sml
@


1.48
log
@[Bug #30349]
Warn when lhs of semicolon does not have type unit
@
text
@(* __builtin_library.sml *)
(*
$Log: __builtin_library.sml,v $
 * Revision 1.47  1997/01/06  15:55:38  andreww
 * [Bug #1818]
 * Adding new floatArray primitives.sml
 *
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
 * Revision 1.45  1996/04/19  14:28:10  matthew
 * Removing some exceptions
 *
 * Revision 1.44  1996/03/20  10:58:16  matthew
 * Changes for value polymorphism
 *
 * Revision 1.43  1996/03/08  12:11:34  daveb
 * Changed MLWorks.Internal.Dynamic types to new identifier convention.
 *
 * Revision 1.42  1995/09/15  15:24:06  matthew
 * Adding append (l,nil) case
 *
Revision 1.41  1995/09/12  15:03:26  daveb
Added types for different sizes of words and integers.

Revision 1.40  1995/07/28  14:51:03  jont
Remove div and mod as these are now overloaded

Revision 1.39  1995/07/20  15:39:00  jont
Add word operations

Revision 1.38  1995/07/14  09:42:59  jont
Adding chr and ord for char type
Also add relationals

Revision 1.37  1995/05/31  14:42:58  matthew
Removing unnecessary op

Revision 1.36  1995/05/25  11:05:05  matthew
Extending available builtins when compiling this file
Adding ML definitions of append and explode

Revision 1.35  1995/04/28  16:30:49  matthew
Adding CAST and UMAP primitives
Adding new append function
Removing stuff from debugger structure

Revision 1.34  1995/02/10  15:56:30  matthew
Added get_implicit pervasive for use by the debugger

Revision 1.33  1994/11/18  16:55:33  matthew
Added new "unsafe" pervasives

Revision 1.32  1994/11/10  13:36:29  matthew
Bind sqrt to a C function

Revision 1.31  1994/08/31  15:52:44  matthew
Speedups to map

Revision 1.30  1994/07/11  12:51:12  matthew
Use "internal string less" and "internal string greater" for the builtin string operations.
This is sort of a hack for the new lambda optimiser to distinguish when the call_c is
returning an object for the builtin environment and when it is returning something that is to
be used as an ML function.

Revision 1.29  1994/03/09  17:14:37  nickh
Delete not_equal, which is unused and causes a thinning.

Revision 1.28  1993/07/20  13:53:31  jont
Added unsafeintplus primitive

Revision 1.27  1993/04/21  16:57:38  matthew
Added pervasive types in.

Revision 1.26  1993/03/23  12:45:54  jont
Added vector primitives

Revision 1.25  1993/03/04  17:06:30  jont
Added builtin string relationals

Revision 1.24  1993/01/06  10:39:57  richard
Removed some redundant calls to C versions of real number operations.

Revision 1.23  1992/11/25  15:17:05  clive
Made append check for simple cases before entering the stub

Revision 1.22  1992/09/30  12:08:47  clive
Actually defined compose

Revision 1.21  1992/08/27  10:48:15  richard
Removed unnecessary ops and marked some bindings as obsolete.

Revision 1.20  1992/08/24  07:48:41  richard
Added ByteArray primitives.

Revision 1.19  1992/08/20  12:24:43  richard
Added unsafe_sub and unsafe_updated, and changed the bound name
of ml_require.

Revision 1.18  1992/08/17  13:25:12  jont
Added inline ordof

Revision 1.17  1992/08/14  20:10:23  jont
Minor improvements to map

Revision 1.16  1992/08/13  16:34:08  davidt
Added a few extra cases to do simple reverse and map
calls more quickly.

Revision 1.15  1992/07/28  13:45:09  richard
Rewrote everything to communicate with C using the runtime environment
rather than numeric codes.

Revision 1.14  1992/06/23  14:15:30  jont
Changed types of ml_require and call_ml_value to reflect what they
really should be

Revision 1.13  1992/06/19  15:47:23  jont
Added ML_REQUIRE builtin for interpreter

Revision 1.12  1992/06/18  16:21:22  jont
Added new builtin ml_value_from_offset for getting pointers into
middles of code vectors for letrecs

Revision 1.11  1992/06/17  09:40:58  jont
Removed call to c for call_ml_value, now in line

Revision 1.10  1992/06/16  17:03:26  jont
Removed the abstype, wasn't necessary

Revision 1.9  1992/06/15  15:43:07  jont
Added extra functions load_var, load_exn, load_struct, load_funct for
interpreter

Revision 1.8  1992/06/12  18:32:37  jont
Added functions required for interpretive system

Revision 1.7  1992/05/20  10:25:41  clive
Added Bits.arshift - arithmetic right shift

Revision 1.6  1992/05/13  12:02:25  clive
Added the Bits structure

Revision 1.5  1992/03/03  11:19:50  richard
Added inline and external equality.

Revision 1.4  1992/02/24  18:14:27  clive
Mod and Div defined to call the wrong c functions

Revision 1.3  1992/02/19  17:27:03  clive
Neatened the comments

Revision 1.2  1992/02/18  09:53:18  clive
call_c was before equality and hence overrode the builtin call_c

Revision 1.1  1992/02/13  18:05:00  clive
Initial revision


   Copyright (C) 1992 Harlequin Ltd.

*)

(*
    This models the file main/_primitives - there should be an entry for each of the builtin's.
    This file is compiled in a type basis consisting of only the datatypes int,read,string,bool
    with constructors true,false,::,nil and ref defined

 The following are implicitly defined and are not to be used or defined here
            =,~,abs,*,+,-,<,>,<=,>=

 The environment returned by this file is specially adjusted, so dont change the name of the
 BuiltinLibrary_ without a lot of care

 The type signatures given in this file are not very safe, but this is no problem as they may be
 made safer in the real __pervasive_library file

WARNING: there is an implicit assumption in _mir_cg that the exceptions given here are unit
         exceptions - in exn_for_prim there is no attempt to apply the exception to an argument
         this ought to be checked for in the safety code in _toplevel

*)

structure BuiltinLibrary_ :

  sig
    eqtype ml_value
    eqtype 'a array
    eqtype 'a vector
    eqtype bytearray
    eqtype floatarray
    type dynamic
    type type_rep
    type int8
    type word8
    type int16
    type word16
    type int32
    type word32

    exception Bind
    exception Chr
    exception Div
    exception Exp
    exception Interrupt
    exception Io of string
    exception Ln
    exception Match
    exception Ord
    exception Overflow
    exception Range of int
    exception Size
    exception Sqrt
    exception Subscript

    val !			: 'a ref -> 'a
    val /			: real * real -> real
    val :=			: 'a ref * 'a -> unit
    val <>			: ''a * ''a -> bool
    val @@			: 'a list * 'a list -> 'a list
    val ^			: string * string -> string
    val alloc_pair		: unit -> 'a
    val alloc_string		: int -> string
    val alloc_vector		: int -> 'a
    val andb			: int * int -> int
    val arctan			: real -> real
    val array			: int * '_a -> '_b
    val arshift			: int * int -> int
    val bytearray		: int * int -> bytearray
    val bytearray_length	: bytearray -> int
    val bytearray_sub		: bytearray * int -> int
    val bytearray_unsafe_sub	: bytearray * int -> int
    val bytearray_unsafe_update	: bytearray * int * int -> unit
    val bytearray_update	: bytearray * int * int -> unit
    val floatarray		: int * real -> floatarray
    val floatarray_length	: floatarray -> int
    val floatarray_sub		: floatarray * int -> real
    val floatarray_unsafe_sub	: floatarray * int -> real
    val floatarray_unsafe_update	: floatarray * int * real -> unit
    val floatarray_update	: floatarray * int * real -> unit
    val call_c			: string -> 'a
    val call_ml_value		: ml_value -> ml_value list
    val cast                    : 'a -> 'b
    val chr			: int -> string
    val char_chr		: int -> char
    val char_equal		: char * char -> bool
    val char_not_equal		: char * char -> bool
    val char_less		: char * char -> bool
    val char_less_equal		: char * char -> bool
    val char_greater		: char * char -> bool
    val char_greater_equal	: char * char -> bool
    val cos			: real -> real
    val exp			: real -> real
    val explode			: string -> string list
    val external_equality	: ''a * ''a -> bool
    val get_implicit		: int -> ml_value
    val floor			: real -> int
    val implode			: string list -> string
    val inline_equality		: ''a * ''a -> bool
    val int_abs			: int -> int
    val int_div			: int * int -> int
    val int_equal		: int * int -> bool
    val int_greater		: int * int -> bool
    val int_greater_or_equal	: int * int -> bool
    val int_less		: int * int -> bool
    val int_less_or_equal	: int * int -> bool
    val int_minus		: int * int -> int
    val int_mod			: int * int -> int
    val int_multiply		: int * int -> int
    val int_negate		: int -> int
    val int_not_equal		: int * int -> bool
    val int_plus		: int * int -> int
    val int32_abs		: int32 -> int32
    val int32_div		: int32 * int32 -> int32
    val int32_equal		: int32 * int32 -> bool
    val int32_greater		: int32 * int32 -> bool
    val int32_greater_equal	: int32 * int32 -> bool
    val int32_less		: int32 * int32 -> bool
    val int32_less_equal	: int32 * int32 -> bool
    val int32_minus		: int32 * int32 -> int32
    val int32_mod		: int32 * int32 -> int32
    val int32_multiply		: int32 * int32 -> int32
    val int32_negate		: int32 -> int32
    val int32_not_equal		: int32 * int32 -> bool
    val int32_plus		: int32 * int32 -> int32
    val length			: 'a  array -> int
    val ln			: real -> real
    val load_exn		: string -> unit
    val load_funct		: string -> unit
    val load_string		: string -> unit
    val load_struct		: string -> unit
    val load_var		: string -> unit
    val lshift			: int * int -> int
    val make_ml_value		: 'a -> ml_value
    val make_ml_value_tuple	: ml_value list -> ml_value
    val map			: ('a -> 'b) -> 'a list -> 'b list
    val umap			: (('a -> 'b) * 'a list) -> 'b list
    val ml_require		: string -> ml_value
    val ml_value_from_offset	: ml_value * int -> ml_value
    val not			: bool -> bool
    val notb			: int -> int
    val o			: ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
    val orb			: int * int -> int
    val ord			: string -> int
    val char_ord		: char -> int
    val ordof			: string * int -> int
    val real			: int -> real
    val real_abs		: real -> real
    val real_equal		: real * real -> bool
    val real_greater		: real * real -> bool
    val real_greater_or_equal	: real * real -> bool
    val real_less		: real * real -> bool
    val real_less_or_equal	: real * real -> bool
    val real_minus		: real * real -> real
    val real_multiply		: real * real -> real
    val real_negate		: real -> real
    val real_not_equal		: real * real -> bool
    val real_plus		: real * real -> real
    val record_unsafe_sub	: 'a  * int -> 'b
    val record_unsafe_update	: 'a  * int * 'b -> unit
    val rev			: 'a list -> 'a list
    val rshift			: int * int -> int
    val sin			: real -> real
    val size			: string -> int
    val sqrt			: real -> real
    val string_equal		: string * string -> bool
    val string_not_equal	: string * string -> bool
    val string_less		: string * string -> bool
    val string_less_equal	: string * string -> bool
    val string_greater		: string * string -> bool
    val string_greater_equal	: string * string -> bool
    val string_unsafe_sub	: string * int -> int
    val string_unsafe_update	: string * int * int -> unit
    val sub			: 'a array * int -> 'a
    val unsafe_int_plus		: int * int -> int
    val unsafe_int_minus	: int * int -> int
    val unsafe_sub		: 'a array * int -> 'a
    val unsafe_update		: 'a array * int * 'a -> unit
    val update			: 'a array * int * 'a -> unit
    val vector			: 'a list -> 'a vector
    val vector_length		: 'a vector -> int
    val vector_sub		: 'a vector * int -> 'a
    val word32_orb		: word32 * word32 -> word32
    val word32_xorb		: word32 * word32 -> word32
    val word32_andb		: word32 * word32 -> word32
    val word32_notb		: word32 -> word32
    val word32_lshift		: word32 * word -> word32
    val word32_rshift		: word32 * word -> word32
    val word32_arshift		: word32 * word -> word32
    val word32_plus		: word32 * word32 -> word32
    val word32_minus		: word32 * word32 -> word32
    val word32_star		: word32 * word32 -> word32
    val word32_div		: word32 * word32 -> word32
    val word32_mod		: word32 * word32 -> word32
    val word32_equal		: word32 * word32 -> bool
    val word32_not_equal	: word32 * word32 -> bool
    val word32_less		: word32 * word32 -> bool
    val word32_less_equal	: word32 * word32 -> bool
    val word32_greater		: word32 * word32 -> bool
    val word32_greater_equal	: word32 * word32 -> bool
    val word_orb		: word * word -> word
    val word_xorb		: word * word -> word
    val word_andb		: word * word -> word
    val word_notb		: word -> word
    val word_lshift		: word * word -> word
    val word_rshift		: word * word -> word
    val word_arshift		: word * word -> word
    val word_plus		: word * word -> word
    val word_minus		: word * word -> word
    val word_star		: word * word -> word
    val word_div		: word * word -> word
    val word_mod		: word * word -> word
    val word_equal		: word * word -> bool
    val word_not_equal		: word * word -> bool
    val word_less		: word * word -> bool
    val word_less_equal		: word * word -> bool
    val word_greater		: word * word -> bool
    val word_greater_equal	: word * word -> bool
    val xorb			: int * int -> int
  end

=

  struct

    local

      exception LibraryError of string
      val yes : string -> 'a = call_c
      fun no message = fn _ => raise LibraryError message
      val obsolete = no

    in

      exception Bind
      exception Chr
      exception Div
      exception Exp
      exception Interrupt
      exception Io of string
      exception Ln
      exception Match
      exception Ord
      exception Overflow
      exception Range of int
      exception Size
      exception Sqrt
      exception Subscript

      type ml_value = ml_value
      type 'a array = 'a array
      type 'a vector = 'a vector
      type bytearray = bytearray
      type floatarray = floatarray
      type dynamic = dynamic
      type type_rep = type_rep
      type int8 = int8
      type word8 = word8
      type int16 = int16
      type word16 = word16
      type int32 = int32
      type word32 = word32

      (* Some ML definitions of various functions *)
      (* These definitions can use a limited range of builtins *)
      (* In the initial environment they all have type 'a so we *)
      (* locally constrain them to the correct type *)

      (* (we can only use builtins that are compiled inline and do not reference *)
      (* builtin exceptions) *)

      local
        infix 6 + -
        infix 4 <> < > <= >= =
        val int_equal : int * int -> bool = int_equal
        val op <> : int * int -> bool = int_not_equal
        val op > : int * int -> bool = int_greater
        val op >= : int * int -> bool = int_greater_or_equal
        val op < : int * int -> bool = int_less
        val op <= : int * int -> bool = int_less_or_equal
        val op + : int * int -> int = unsafe_int_plus
        val op - : int * int -> int = unsafe_int_minus
        val alloc_vector : int -> 'a vector = alloc_vector
        val vector_unsafe_sub : 'a vector * int -> 'a = record_unsafe_sub
        val vector_unsafe_update : 'a vector * int * 'a -> unit = record_unsafe_update
        val alloc_string : int -> string = alloc_string
        val size : string -> int = size
        val string_unsafe_update : string * int * int -> unit = string_unsafe_update
        val string_unsafe_sub : string * int -> int = string_unsafe_sub
        val cast : 'a -> 'b = cast
        val length : 'a array -> int = length
        val unsafe_sub : '_a array * int -> '_a = unsafe_sub
        val unsafe_update : '_a array * int * '_a -> unit = unsafe_update
        val real : int -> real = real
      (* There are more here -- see _primitives *)
      in

        (* And now we redefine append *)
        (* This function does 2 scans of the first list *)
        (* The first scan, aux1, builds a list of cons cells on *)
        (* the front of the second list *)
        (* The second scan, aux2, destructively updates the new cells *)
        (* to the contents of the first list *)
        (* Note that this is safe for GC *)
        local
          fun aux2 ([],_,res) = res
            | aux2 (a::b,cell,res) =
              let val _ = record_unsafe_update (cell,0,a) 
               in aux2 (b,record_unsafe_sub (cell,1),res) end
            
          fun aux1 ([],res,x) = aux2 (x,res,res)
            | aux1 (a::b,y,x) = 
              let
                val cell = cast (0,y)
              in
                aux1 (b,cell,x)
              end
        in
          (* Wrap this in a test for short cases *)
          fun @@ (nil,l) = l
            | @@ (l,nil) = l
            | @@ ([a],l) = a::l
            | @@ ([a,b],l) = a::b::l
            | @@ ([a,b,c],l) = a::b::c::l
            | @@ ([a,b,c,d],l) = a::b::c::d::l
            | @@ ([a,b,c,d,e],l) = a::b::c::d::e::l
            | @@ ([a,b,c,d,e,f],l) = a::b::c::d::e::f::l
            | @@ ([a,b,c,d,e,f,g],l) = a::b::c::d::e::f::g::l
            | @@ ([a,b,c,d,e,f,g,h],l) = a::b::c::d::e::f::g::h::l
            | @@ (a::b::c::d::e::f::g::h::r,l) = a::b::c::d::e::f::g::h:: aux1(r,l,r)
        end 

        (* Redefine the explode function!! *)
        local
          fun make_chars (0,acc) = acc
            | make_chars (n,acc) =
              let
                val s = alloc_string 2
              in
                string_unsafe_update (s,0,n-1);
                string_unsafe_update (s,1,0);
                make_chars (n-1,s::acc)
              end
          val char_list = make_chars (256,[])
          val chars = alloc_vector 256
          fun update ([],n) = ()
            | update (c::rest,n) =
              (vector_unsafe_update (chars,n,c);
               update (rest,n+1))
          val _ = update (char_list,0)
        in
          fun explode s : string list =
            let
              (* loop unrolled once *)
              (* chars passed as function argument (so goes in register) *)
              fun aux (n,acc,chars) =
                if n <= 1
                  then
                    if int_equal (n,1)
                      then vector_unsafe_sub (chars,string_unsafe_sub (s,0)) :: acc
                    else acc
                else
                  let
                    val n' = n-1
                    val n'' = n-2
                  in
                    aux (n'',
                         vector_unsafe_sub (chars,string_unsafe_sub (s,n'')) ::
                         vector_unsafe_sub (chars,string_unsafe_sub (s,n')) :: 
                         acc,
                         chars)
                  end
            in
              aux (size s, [], chars)
            end
        end
      end


      fun not true = false
        | not false = true

      local
        fun rev' (done, []) = done
          | rev' (done, x::xs) = rev' (x::done, xs)
      in
        fun rev [] = []
	  | rev (l as [_]) = l
	  | rev l = rev' ([], l)

        (* We seem to use map with short lists a lot so... *)
	fun map f [] = []
	  | map f [x] = [f x]
	  | map f [x,y] = [f x, f y]
	  | map f [x,y,z] = [f x, f y, f z]
	  | map f [x,y,z,w] = [f x, f y, f z, f w]
	  | map f (x :: y :: z :: w :: rest) =
            let
              fun map_sub([], done) = rev' ([], done)
                | map_sub(x :: xs, done) = map_sub (xs, f x :: done)
            in
              f x :: f y :: f z :: f w :: map_sub(rest, [])
            end

        (* We seem to use map with short lists a lot so... *)
	fun umap (f, []) = []
	  | umap (f, [x]) = [f x]
	  | umap (f, [x,y]) = [f x, f y]
	  | umap (f, [x,y,z]) = [f x, f y, f z]
	  | umap (f, [x,y,z,w]) = [f x, f y, f z, f w]
	  | umap (f,(x :: y :: z :: w :: rest)) =
            let
              fun map_sub([], done) = rev' ([], done)
                | map_sub(x :: xs, done) = map_sub (xs, f x :: done)
            in
              f x :: f y :: f z :: f w :: map_sub(rest, [])
            end
      end

      val ! : 'a ref -> 'a =			fn x => no  "deref" x
      val / : real * real -> real =		no  "real divide"
      val := : 'a ref * 'a -> unit =		fn x => no  "becomes" x
      val <> : ''a * ''a -> bool =		fn x => yes "polymorphic inequality" x
      val ^ : string * string ->string  =	yes "string concatenate"
      val o : ('b -> 'c) * ('a -> 'b) -> 'a -> 'c  =	(fn (f,g) => fn x => f(g(x)))
      val alloc_pair : unit -> 'a =	fn x => no  "alloc pair" x
      val alloc_string : int -> string =	no  "alloc string"
      val alloc_vector : int -> 'a =		fn x => no  "alloc_vector" x
      val andb : int * int -> int =		no  "integer bit and"
      val arctan : real -> real =		yes "real arctan"
      val array : int * '_a -> '_b =	fn x => no  "array" x
      val arshift : int * int -> int =		no  "integer bit shift right arithmetic"
      val bytearray : int * int -> bytearray =	no  "bytearray"
      val bytearray_length : bytearray ->int =  no  "bytearray length"
      val bytearray_sub : bytearray * int -> int = no  "bytearray sub"
      val bytearray_unsafe_sub : bytearray * int -> int =
                                            no  "bytearray sub unsafe"
      val bytearray_unsafe_update : bytearray * int * int -> unit =
                                            no  "bytearray update unsafe"
      val bytearray_update : bytearray * int * int -> unit = 
                                            no  "bytearray update"

      val floatarray : int * real -> floatarray =
                                            no  "floatarray"
      val floatarray_length : floatarray -> int =
                                            no  "floatarray length"
      val floatarray_sub : floatarray * int -> real = 
                                            no  "floatarray sub"
      val floatarray_unsafe_sub : floatarray * int -> real = 
                                            no  "floatarray sub unsafe"
      val floatarray_unsafe_update : floatarray * int * real -> unit = 
                                            no  "floatarray update unsafe"
      val floatarray_update : floatarray * int * real -> unit = 
                                            no  "floatarray update"

      val call_c : string -> 'a =		fn x => no  "call_c" x
      val call_ml_value : ml_value -> ml_value list =	obsolete "system call"
      val cast : 'a -> 'b =			fn x => no  "cast" x
      val chr : int -> string =			no  "string chr"
      val char_chr : int -> char =		no  "char chr"
      val char_equal : char * char -> bool =	no  "char equal"
      val char_not_equal : char * char -> bool =no  "char not equal"
      val char_less : char * char -> bool =		no  "char less"
      val char_greater : char * char -> bool =		no  "char greater"
      val char_less_equal : char * char -> bool =	no  "char less equal"
      val char_greater_equal : char * char -> bool =	no  "char greater equal"
      val cos : real -> real =		        yes "real cos"
      val exp : real -> real =                  yes "real exp"
      val external_equality : ''a * ''a -> bool =	fn x => yes "polymorphic equality" x
      val get_implicit : int -> ml_value =		no  "get implicit"
      val floor : real -> int =	no  "real floor" 
      val implode : string list -> string =		yes "string implode"
      val inline_equality : ''a * ''a -> bool =fn x => no  "inline equality" x
      val int_abs : int -> int =		no  "integer abs" 
      val int_div : int * int -> int =			yes "integer divide"
      val int_equal : int * int -> bool =			no  "integer equal"
      val int_greater : int * int -> bool =			no  "integer greater"
      val int_greater_or_equal : int * int -> bool = 	no  "integer greater or equal"
      val int_less : int * int -> bool = 			no  "integer less"
      val int_less_or_equal : int * int -> bool = 		no  "integer less or equal"
      val int_minus : int * int -> int = 			no  "integer minus"
      val int_mod : int * int -> int =			yes "integer modulo"
      val int_multiply : int * int -> int =		yes "integer multiply"
      val int_negate : int -> int =			no  "integer negate"
      val int_not_equal : int * int -> bool =		no  "integer not equal"
      val int_plus : int * int -> int = 		no  "integer plus"
      val unsafe_int_plus : int * int -> int =		no  "unsafe integer plus"
      val unsafe_int_minus : int * int -> int =		no  "unsafe integer minus"
      val int32_abs : int32 -> int32 =			no  "int32 abs"
      val int32_div : int32 * int32 -> int32 =			yes "int32 divide"
      val int32_equal : int32 * int32 -> bool =			no  "int32 equal"
      val int32_greater : int32 * int32 -> bool =		no  "int32 greater"
      val int32_greater_equal : int32 * int32 -> bool = 	no  "int32 greater or equal"
      val int32_less : int32 * int32 -> bool = 			no  "int32 less"
      val int32_less_equal : int32 * int32 -> bool = 		no  "int32 less or equal"
      val int32_minus : int32 * int32 -> int32 = 		no  "int32 minus"
      val int32_mod : int32 * int32 -> int32 =			yes "int32 modulo"
      val int32_multiply : int32 * int32 -> int32 =		yes "int32 multiply"
      val int32_negate : int32 -> int32 =		no  "int32 negate"
      val int32_not_equal : int32 * int32 -> bool =		no  "int32 not equal"
      val int32_plus : int32 * int32 -> int32 = 			no  "int32 plus"
      val length : 'a array -> int =			fn x => no  "array length" x
      val ln : real -> real =				yes "real ln"
      val load_exn : string -> unit =			no  "load exn"
      val load_funct : string -> unit =			no  "load funct"
      val load_string : string -> unit =			no  "load string"
      val load_struct : string -> unit =			no  "load struct"
      val load_var : string -> unit =			no  "load var"
      val lshift : int * int -> int =no  "integer bit shift left"
      val make_ml_value : 'a -> ml_value =	fn x => obsolete "system make ml value" x
      val make_ml_value_tuple : ml_value list -> ml_value =obsolete "system tuple"
      val ml_require : string -> ml_value =			obsolete "system module require"
      val ml_value_from_offset : ml_value * int -> ml_value =no  "system ml value from offset"
      val notb : int -> int =			no  "integer bit not"
      val orb : int * int -> int =		no  "integer bit or"
      val ord : string -> int =		no  "string ord"
      val char_ord : char -> int =	no  "string ord"
      val ordof : string * int -> int =	 	no  "string ordof"
      val real : int -> real =			no  "real"
      val real_abs : real -> real =			no  "real absolute"
      val real_equal : real * real -> bool =			no  "real equal"
      val real_greater : real * real -> bool =		no  "real greater"
      val real_greater_or_equal : real * real -> bool =	no  "real greater or equal"
      val real_less : real * real -> bool =			no  "real less"
      val real_less_or_equal : real * real -> bool =		no  "real less or equal"
      val real_minus : real * real -> real =			no  "real minus"
      val real_multiply : real * real -> real =		no  "real multiply"
      val real_negate : real -> real =			no  "real negate"
      val real_not_equal : real * real -> bool =		no  "real not equal"
      val real_plus : real * real -> real =			no  "real plus"
      val record_unsafe_sub : 'a * int -> 'b =		fn x => no  "record unsafe sub" x
      val record_unsafe_update : 'a * int * 'b -> unit =	fn x => no  "record unsafe update" x
      val rshift : int * int -> int =			no  "integer shift right"
      val sin : real -> real =			yes "real sin"
      val size : string -> int =			no  "string size"
      val sqrt : real -> real =			yes "real square root"
      val string_equal : string * string -> bool =		yes "string equal"
      val string_not_equal : string * string -> bool =            yes "string not equal"
      val string_less : string * string -> bool =			yes "string less"
      val string_greater : string * string -> bool =		yes "string greater"
      val string_unsafe_sub : string * int -> int =		no  "string unsafe sub"
      val string_unsafe_update : string * int * int -> unit =	no  "string unsafe update"
      val sub : 'a array * int -> 'a =				fn x => no  "array sub" x
      val unsafe_sub : 'a array * int -> 'a =			fn x => no  "array sub unsafe" x
      val unsafe_update : 'a array * int * 'a -> unit =		fn x => no  "array update unsafe" x
      val update : 'a array * int * 'a -> unit =			fn x => no  "array update" x
      val vector : 'a list -> 'a vector =			fn x => no  "vector" x
      val vector_length : 'a vector -> int =		fn x => no  "vector length" x
      val vector_sub : 'a vector * int -> 'a =			fn x => no  "vector sub" x
      val word32_orb : word32 * word32 -> word32 =			no  "word32 orb"
      val word32_xorb : word32 * word32 -> word32 =			no  "word32 xorb"
      val word32_andb : word32 * word32 -> word32 =			no  "word32 andb"
      val word32_notb : word32 -> word32 =			no  "word32 notb"
      val word32_lshift : word32 * word -> word32 =		no  "word32 lshift"
      val word32_rshift : word32 * word -> word32 =		no  "word32 rshift"
      val word32_arshift : word32 * word -> word32 =		no  "word32 arshift"
      val word32_plus : word32 * word32 -> word32 =			no  "word32 plus"
      val word32_minus : word32 * word32 -> word32 =		no  "word32 minus"
      val word32_star : word32 * word32 -> word32 =			yes "word32 times"
      val word32_div : word32 * word32 -> word32 =			yes "word32 div"
      val word32_mod : word32 * word32 -> word32 =			yes "word32 mod"
      val word32_equal : word32 * word32 -> bool =		no  "word32 equal"
      val word32_not_equal : word32 * word32 -> bool =		no  "word32 not equal"
      val word32_less : word32 * word32 -> bool =			no  "word32 less"
      val word32_less_equal : word32 * word32 -> bool =		no  "word32 less or equal"
      val word32_greater : word32 * word32 -> bool =		no  "word32 greater"
      val word32_greater_equal : word32 * word32 -> bool =	no  "word32 greater or equal"
      val word_orb : word * word -> word =			no  "word orb"
      val word_xorb : word * word -> word =			no  "word xorb"
      val word_andb : word * word -> word =			no  "word andb"
      val word_notb : word -> word =			no  "word notb"
      val word_lshift : word * word -> word =			no  "word lshift"
      val word_rshift : word * word -> word =			no  "word rshift"
      val word_arshift : word * word -> word =		no  "word arshift"
      val word_plus : word * word -> word =			no  "word plus"
      val word_minus : word * word -> word =			no  "word minus"
      val word_star : word * word -> word =			yes "word multiply"
      val word_div : word * word -> word =			yes "word divide"
      val word_mod : word * word -> word =			yes "word modulus"
      val word_equal : word * word -> bool =			no  "word equal"
      val word_not_equal : word * word -> bool =		no  "word not equal"
      val word_less : word * word -> bool =			no  "word less"
      val word_less_equal : word * word -> bool =		no  "word less or equal"
      val word_greater : word * word -> bool =		no  "word greater"
      val word_greater_equal : word * word -> bool =		no  "word greater or equal"
      val xorb : int * int -> int =			no  "integer bit or exclusive"

      fun string_greater_equal arg = not(string_less arg)
      fun string_less_equal arg = not(string_greater arg)

    end

  end
@


1.48.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.48  1998/02/17  13:59:31  mitchell
 * [Bug #30349]
 * Warn when lhs of semicolon does not have type unit
 *
@


1.47
log
@[Bug #1818]
Adding new floatArray primitives.sml
@
text
@d4 4
d468 2
a469 2
              (record_unsafe_update (cell,0,a);
               aux2 (b,record_unsafe_sub (cell,1),res))
@


1.47.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.47  1997/01/06  15:55:38  andreww
 * [Bug #1818]
 * Adding new floatArray primitives.sml
 *
@


1.47.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.47  1997/01/06  15:55:38  andreww
 * [Bug #1818]
 * Adding new floatArray primitives.sml
 *
@


1.47.1.1
log
@branched from 1.47
@
text
@a3 4
 * Revision 1.47  1997/01/06  15:55:38  andreww
 * [Bug #1818]
 * Adding new floatArray primitives.sml
 *
@


1.47.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.47.1.1  1997/05/12  10:39:10  hope
 * branched from 1.47
 *
@


1.47.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.47.1.1  1997/05/12  10:39:10  hope
 * branched from 1.47
 *
@


1.47.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.47.1.1  1997/05/12  10:39:10  hope
 * branched from 1.47
 *
@


1.47.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.47.1.1.1.1  1997/07/28  18:24:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.46
log
@Changing type of word32 shift operations
@
text
@d4 3
d187 1
d231 6
d410 1
d592 20
a611 3
      val bytearray_unsafe_sub : bytearray * int -> int = no  "bytearray sub unsafe"
      val bytearray_unsafe_update : bytearray * int * int -> unit = no  "bytearray update unsafe"
      val bytearray_update : bytearray * int * int -> unit = no  "bytearray update"
@


1.46.7.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.6.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.6.1.1.1
log
@branched from 1.46.6.1
@
text
@a3 3
 * Revision 1.46.6.1  1996/12/17  17:52:17  hope
 * branched from 1.46
 *
@


1.46.5.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.4.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.4.1.1.1
log
@branched from 1.46.4.1
@
text
@a3 3
 * Revision 1.46.4.1  1996/11/14  12:55:24  hope
 * branched from 1.46
 *
@


1.46.3.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.2.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/05/20  10:04:01  matthew
 * Changing type of word32 shift operations
 *
@


1.45
log
@Removing some exceptions
@
text
@d4 3
d333 3
a335 3
    val word32_lshift		: word32 * word32 -> word32
    val word32_rshift		: word32 * word32 -> word32
    val word32_arshift		: word32 * word32 -> word32
d682 3
a684 3
      val word32_lshift : word32 * word32 -> word32 =		no  "word32 lshift"
      val word32_rshift : word32 * word32 -> word32 =		no  "word32 rshift"
      val word32_arshift : word32 * word32 -> word32 =		no  "word32 arshift"
@


1.44
log
@Changes for value polymorphism
@
text
@d4 3
a189 1
    exception Abs
a191 1
    exception Diff
a193 1
    exception Floor
a197 2
    exception Mod
    exception Neg
a199 2
    exception Prod
    exception Quot
a203 1
    exception Sum
a377 1
      exception Abs
a379 1
      exception Diff
a381 1
      exception Floor
a385 2
      exception Mod
      exception Neg
a387 2
      exception Prod
      exception Quot
a391 1
      exception Sum
@


1.43
log
@Changed MLWorks.Internal.Dynamic types to new identifier convention.
@
text
@d4 3
d221 1
a221 1
    val array			: int * '_a -> (*'_a array*)'b
d223 1
a223 1
    val bytearray		: int * int -> 'a
d274 1
a274 1
    val length			: 'a  -> int
d575 150
a724 150
      val ! =				no  "deref"
      val / =				no  "real divide"
      val := =				no  "becomes"
      val <> =				yes "polymorphic inequality"
      val ^ =				yes "string concatenate"
      val o =				(fn (f,g) => fn x => f(g(x)))
      val alloc_pair =			no  "alloc pair"
      val alloc_string =		no  "alloc string"
      val alloc_vector =		no  "alloc_vector"
      val andb =			no  "integer bit and"
      val arctan =			yes "real arctan"
      val array =			no  "array"
      val arshift =			no  "integer bit shift right arithmetic"
      val bytearray =			no  "bytearray"
      val bytearray_length =		no  "bytearray length"
      val bytearray_sub =		no  "bytearray sub"
      val bytearray_unsafe_sub =	no  "bytearray sub unsafe"
      val bytearray_unsafe_update =	no  "bytearray update unsafe"
      val bytearray_update =		no  "bytearray update"
      val call_c =			no  "call_c"
      val call_ml_value =		obsolete "system call"
      val cast =			no  "cast"
      val chr =				no  "string chr"
      val char_chr =			no  "char chr"
      val char_equal =			no  "char equal"
      val char_not_equal =		no  "char not equal"
      val char_less =			no  "char less"
      val char_greater =		no  "char greater"
      val char_less_equal =		no  "char less equal"
      val char_greater_equal =		no  "char greater equal"
      val cos =			        yes "real cos"
      val exp =	                        yes "real exp"
      val external_equality =		yes "polymorphic equality"
      val get_implicit =		no  "get implicit"
      val floor =			no  "real floor"
      val implode =			yes "string implode"
      val inline_equality =		no  "inline equality"
      val int_abs =			no  "integer abs"
      val int_div =			yes "integer divide"
      val int_equal =			no  "integer equal"
      val int_greater =			no  "integer greater"
      val int_greater_or_equal = 	no  "integer greater or equal"
      val int_less = 			no  "integer less"
      val int_less_or_equal = 		no  "integer less or equal"
      val int_minus = 			no  "integer minus"
      val int_mod =			yes "integer modulo"
      val int_multiply =		yes "integer multiply"
      val int_negate =			no  "integer negate"
      val int_not_equal =		no  "integer not equal"
      val int_plus = 			no  "integer plus"
      val unsafe_int_plus =		no  "unsafe integer plus"
      val unsafe_int_minus =		no  "unsafe integer minus"
      val int32_abs =			no  "int32 abs"
      val int32_div =			yes "int32 divide"
      val int32_equal =			no  "int32 equal"
      val int32_greater =		no  "int32 greater"
      val int32_greater_equal = 	no  "int32 greater or equal"
      val int32_less = 			no  "int32 less"
      val int32_less_equal = 		no  "int32 less or equal"
      val int32_minus = 		no  "int32 minus"
      val int32_mod =			yes "int32 modulo"
      val int32_multiply =		yes "int32 multiply"
      val int32_negate =		no  "int32 negate"
      val int32_not_equal =		no  "int32 not equal"
      val int32_plus = 			no  "int32 plus"
      val length =			no  "array length"
      val ln =				yes "real ln"
      val load_exn =			no  "load exn"
      val load_funct =			no  "load funct"
      val load_string =			no  "load string"
      val load_struct =			no  "load struct"
      val load_var =			no  "load var"
      val lshift =			no  "integer bit shift left"
      val make_ml_value =		obsolete "system make ml value"
      val make_ml_value_tuple =		obsolete "system tuple"
      val ml_require =			obsolete "system module require"
      val ml_value_from_offset =	no  "system ml value from offset"
      val notb =			no  "integer bit not"
      val orb =				no  "integer bit or"
      val ord =		 		no  "string ord"
      val char_ord =	 	        no  "string ord"
      val ordof =	 		no  "string ordof"
      val real =			no  "real"
      val real_abs =			no  "real absolute"
      val real_equal =			no  "real equal"
      val real_greater =		no  "real greater"
      val real_greater_or_equal =	no  "real greater or equal"
      val real_less =			no  "real less"
      val real_less_or_equal =		no  "real less or equal"
      val real_minus =			no  "real minus"
      val real_multiply =		no  "real multiply"
      val real_negate =			no  "real negate"
      val real_not_equal =		no  "real not equal"
      val real_plus =			no  "real plus"
      val record_unsafe_sub =		no  "record unsafe sub"
      val record_unsafe_update =	no  "record unsafe update"
      val rshift =			no  "integer shift right"
      val sin =				yes "real sin"
      val size =			no  "string size"
      val sqrt =			yes "real square root"
      val string_equal =		yes "string equal"
      val string_not_equal =            yes "string not equal"
      val string_less =			yes "string less"
      val string_greater =		yes "string greater"
      val string_unsafe_sub =		no  "string unsafe sub"
      val string_unsafe_update =	no  "string unsafe update"
      val sub =				no  "array sub"
      val unsafe_sub =			no  "array sub unsafe"
      val unsafe_update =		no  "array update unsafe"
      val update =			no  "array update"
      val vector =			no  "vector"
      val vector_length =		no  "vector length"
      val vector_sub =			no  "vector sub"
      val word32_orb =			no  "word32 orb"
      val word32_xorb =			no  "word32 xorb"
      val word32_andb =			no  "word32 andb"
      val word32_notb =			no  "word32 notb"
      val word32_lshift =		no  "word32 lshift"
      val word32_rshift =		no  "word32 rshift"
      val word32_arshift =		no  "word32 arshift"
      val word32_plus =			no  "word32 plus"
      val word32_minus =		no  "word32 minus"
      val word32_star =			yes "word32 times"
      val word32_div =			yes "word32 div"
      val word32_mod =			yes "word32 mod"
      val word32_equal =		no  "word32 equal"
      val word32_not_equal =		no  "word32 not equal"
      val word32_less =			no  "word32 less"
      val word32_less_equal =		no  "word32 less or equal"
      val word32_greater =		no  "word32 greater"
      val word32_greater_equal =	no  "word32 greater or equal"
      val word_orb =			no  "word orb"
      val word_xorb =			no  "word xorb"
      val word_andb =			no  "word andb"
      val word_notb =			no  "word notb"
      val word_lshift =			no  "word lshift"
      val word_rshift =			no  "word rshift"
      val word_arshift =		no  "word arshift"
      val word_plus =			no  "word plus"
      val word_minus =			no  "word minus"
      val word_star =			yes "word multiply"
      val word_div =			yes "word divide"
      val word_mod =			yes "word modulus"
      val word_equal =			no  "word equal"
      val word_not_equal =		no  "word not equal"
      val word_less =			no  "word less"
      val word_less_equal =		no  "word less or equal"
      val word_greater =		no  "word greater"
      val word_greater_equal =		no  "word greater or equal"
      val xorb =			no  "integer bit or exclusive"
@


1.42
log
@Adding append (l,nil) case
@
text
@d4 3
d175 2
a176 2
    type Dynamic
    type Type
d407 2
a408 2
      type Dynamic = Dynamic
      type Type = Type
@


1.41
log
@Added types for different sizes of words and integers.
@
text
@d4 3
d470 1
@


1.40
log
@Remove div and mod as these are now overloaded
@
text
@d4 3
d171 6
a238 1
    val intToWord		: int -> word
d252 13
a301 1
    val signExtend		: word -> int
d322 18
a339 1
    val wordToInt		: word -> int
d403 6
a569 2
      val int_div =			yes "integer divide"
      val int_mod =			yes "integer modulo"
a601 1
      val intToWord =			no  "int to word"
d603 1
d610 1
d617 13
a661 1
      val signExtend = 			no  "sign extend word"
d678 18
a695 1
      val wordToInt =			no  "word to int"
@


1.39
log
@Add word operations
@
text
@d4 3
a222 1
    val div			: int * int -> int
d232 1
d239 1
a257 1
    val mod			: int * int -> int
d527 2
a528 2
      val div =				yes "integer divide"
      val mod =				yes "integer modulo"
@


1.38
log
@Adding chr and ord for char type
Also add relationals
@
text
@d4 4
d180 1
d213 6
d228 1
d278 1
a287 6
    val char_equal		: char * char -> bool
    val char_not_equal		: char * char -> bool
    val char_less		: char * char -> bool
    val char_less_equal		: char * char -> bool
    val char_greater		: char * char -> bool
    val char_greater_equal	: char * char -> bool
d299 19
d348 1
d558 1
d604 1
d621 19
@


1.37
log
@Removing unnecessary op
@
text
@d4 3
d207 1
d248 1
d275 6
d517 7
d559 1
@


1.36
log
@Extending available builtins when compiling this file
Adding ML definitions of append and explode
@
text
@d4 4
d337 1
a337 1
        val op int_equal : int * int -> bool = int_equal
@


1.35
log
@Adding CAST and UMAP primitives
Adding new append function
Removing stuff from debugger structure
@
text
@d4 5
d287 1
a287 1
      val yes = call_c
d322 155
a503 1
      val explode =			yes "string explode"
d571 2
a572 2
      fun not true = false
        | not false = true
d574 1
a574 46
      local 
        val internal_string_less = yes "internal string less"
        val internal_string_greater = yes "internal string greater"
      in
        fun string_greater_equal arg = not(internal_string_less arg)
        fun string_less_equal arg = not(internal_string_greater arg)
      end

      local
        fun rev' (done, []) = done
          | rev' (done, x::xs) = rev' (x::done, xs)

      in
        fun rev [] = []
	  | rev (l as [_]) = l
	  | rev l = rev' ([], l)

        (* We seem to use map with short lists a lot so... *)
	fun map f [] = []
	  | map f [x] = [f x]
	  | map f [x,y] = [f x, f y]
	  | map f [x,y,z] = [f x, f y, f z]
	  | map f [x,y,z,w] = [f x, f y, f z, f w]
	  | map f (x :: y :: z :: w :: rest) =
            let
              fun map_sub([], done) = rev' ([], done)
                | map_sub(x :: xs, done) = map_sub (xs, f x :: done)
            in
              f x :: f y :: f z :: f w :: map_sub(rest, [])
            end

        (* We seem to use map with short lists a lot so... *)
	fun umap (f, []) = []
	  | umap (f, [x]) = [f x]
	  | umap (f, [x,y]) = [f x, f y]
	  | umap (f, [x,y,z]) = [f x, f y, f z]
	  | umap (f, [x,y,z,w]) = [f x, f y, f z, f w]
	  | umap (f,(x :: y :: z :: w :: rest)) =
            let
              fun map_sub([], done) = rev' ([], done)
                | map_sub(x :: xs, done) = map_sub (xs, f x :: done)
            in
              f x :: f y :: f z :: f w :: map_sub(rest, [])
            end

      end
a575 10
      (* This version of append isn't used anymore -- see __pervasive_library *)
      local
        val append = yes "list append"
      in
        fun @@ ([],  ys) = ys
          | @@ ([x], ys) = x::ys
          | @@ (xs,  []) = xs
          | @@ other     = append other
      end
    end
a576 2


@


1.34
log
@Added get_implicit pervasive for use by the debugger
@
text
@d4 3
d193 1
d226 1
d340 1
d445 15
d462 1
@


1.33
log
@Added new "unsafe" pervasives
@
text
@d4 3
d196 1
d340 1
@


1.32
log
@Bind sqrt to a C function
@
text
@d4 3
d172 3
a206 1
    val unsafeint_plus          : int * int -> int
d239 2
d252 2
d255 2
d316 3
d350 2
a351 1
      val unsafeint_plus =		no  "unsafe integer plus"
d380 2
d390 2
d396 1
a396 1
      val vector =			yes "vector"
@


1.31
log
@Speedups to map
@
text
@d4 3
d368 1
a368 1
      val sqrt =			no  "real square root"
@


1.30
log
@Use "internal string less" and "internal string greater" for the builtin string operations.
This is sort of a hack for the new lambda optimiser to distinguish when the call_c is
returning an object for the builtin environment and when it is returning something that is to
be used as an ML function.
@
text
@d4 6
d393 1
d399 1
d402 10
a411 7
	  | map f x =
	    let
	      fun map_sub([], done) = rev'([], done)
		| map_sub(x :: xs, done) = map_sub(xs, f x :: done)
	    in
	      map_sub(x, [])
	    end
@


1.29
log
@Delete not_equal, which is unused and causes a thinning.
@
text
@d4 3
d376 7
a382 2
      fun string_greater_equal arg = not(string_less arg)
      fun string_less_equal arg = not(string_greater arg)
a410 1

@


1.28
log
@Added unsafeintplus primitive
@
text
@d4 3
a336 1
      val not_equal =			yes "polymorphic inequality"
@


1.28.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.28  1993/07/20  13:53:31  jont
Added unsafeintplus primitive

@


1.27
log
@Added pervasive types in.
@
text
@d4 3
d186 1
d321 1
@


1.26
log
@Added vector primitives
@
text
@d4 3
d117 5
d272 5
@


1.25
log
@Added builtin string relationals
@
text
@d4 3
d145 1
a145 1
    val array			: int * '_a -> 'b
d148 5
a152 5
    val bytearray_length	: 'a -> int
    val bytearray_sub		: 'a * int -> int
    val bytearray_unsafe_sub	: 'a * int -> int
    val bytearray_unsafe_update	: 'a * int * int -> unit
    val bytearray_update	: 'a * int * int -> unit
d218 7
a224 4
    val sub			: 'a * int -> 'b
    val unsafe_sub		: 'a * int -> 'b
    val unsafe_update		: 'a * int * 'b -> unit
    val update			: 'a * int * 'b -> unit
d345 3
@


1.24
log
@Removed some redundant calls to C versions of real number operations.
@
text
@d4 3
d211 4
d333 2
d343 3
@


1.23
log
@Made append check for simple cases before entering the stub
@
text
@d4 3
a251 2
      val c_append = yes "list append"

d253 1
a253 1
      val / =				yes "real divide"
a255 4
      val @@ =				(fn ([],x) => x
                                         | ([x],y) => x::y
                                         | (x,[]) => x
                                         | arg => c_append arg)
d309 11
a319 11
      val real_abs =			yes "real absolute"
      val real_equal =			yes "real equal"
      val real_greater =		yes "real greater"
      val real_greater_or_equal =	yes "real greater or equal"
      val real_less =			yes "real less"
      val real_less_or_equal =		yes "real less or equal"
      val real_minus =			yes "real minus"
      val real_multiply =		yes "real multiply"
      val real_negate =			yes "real negate"
      val real_not_equal =		yes "real not equal"
      val real_plus =			yes "real plus"
d323 1
a323 1
      val sqrt =			yes "real square root"
d353 10
@


1.22
log
@Actually defined compose
@
text
@d4 3
d249 2
d255 4
a258 1
      val @@ =				yes "list append"
@


1.21
log
@Removed unnecessary ops and marked some bindings as obsolete.
@
text
@d4 3
d254 1
a254 1
      val o =				no  "function compose"
@


1.20
log
@Added ByteArray primitives.
@
text
@d4 3
d215 1
d243 9
a251 9
      val (op !) =			no  "deref"
      val (op /) =			yes "real divide"
      val (op :=) =			no  "becomes"
      val (op <>) =			yes "polymorphic inequality"
      val (op @@) =			yes "list append"
      val (op ^) =			yes "string concatenate"
      val (op div) =			yes "integer divide"
      val (op mod) =			yes "integer modulo"
      val (op o) =			no  "function compose"
d263 1
a263 1
      val call_ml_value =		no  "system call"
d291 3
a293 3
      val make_ml_value =		no  "system make ml value"
      val make_ml_value_tuple =		yes "system tuple"
      val ml_require =			yes "system module require"
@


1.19
log
@Added unsafe_sub and unsafe_updated, and changed the bound name
of ml_require.
@
text
@d4 4
d113 2
d116 1
a117 2
    exception Size
    exception Subscript
d119 82
a200 76
    val call_c                : string -> 'a
    val floor                 : real -> int
    val real                  : int -> real
    val /                     : real * real -> real
    val div                   : int * int -> int
    val !                     : 'a ref -> 'a
    val :=                    : 'a ref * 'a -> unit
    val   @@                   : 'a list * 'a list -> 'a list
    val arctan                : real -> real
    val chr                   : int -> string
    val o                     : ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
    val ^                     : string * string -> string
    val cos                   : real -> real
    val exp                   : real -> real
    val explode               : string -> string list
    val implode               : string list -> string
    val int_abs               : int -> int
    val int_equal             : int * int -> bool
    val int_greater           : int * int -> bool
    val int_greater_or_equal  : int * int -> bool
    val int_less              : int * int -> bool
    val int_less_or_equal     : int * int -> bool
    val int_minus             : int * int -> int
    val int_multiply          : int * int -> int
    val int_negate            : int -> int
    val int_not_equal         : int * int -> bool
    val int_plus              : int * int -> int
    val ln                    : real -> real
    val load_string           : string -> unit
    val load_var              : string -> unit
    val load_exn              : string -> unit
    val load_struct           : string -> unit
    val load_funct            : string -> unit
    val call_ml_value         : ml_value -> ml_value list
    val make_ml_value         : 'a -> ml_value
    val ml_value_from_offset  : ml_value * int -> ml_value
    val make_ml_value_tuple   : ml_value list -> ml_value
    val ml_require            : string -> ml_value
    val map                   : ('a -> 'b) -> 'a list -> 'b list
    val mod                   : int * int -> int
    val not                   : bool -> bool
    val <>    		      : ''a * ''a -> bool
    val ord                   : string -> int
    val ordof                 : string * int -> int
    val real_abs              : real -> real
    val real_equal            : real * real -> bool
    val real_greater          : real * real -> bool
    val real_greater_or_equal : real * real -> bool
    val real_less             : real * real -> bool
    val real_less_or_equal    : real * real -> bool
    val real_minus            : real * real -> real
    val real_multiply         : real * real -> real
    val real_negate           : real -> real
    val real_not_equal        : real * real -> bool
    val real_plus             : real * real -> real
    val rev                   : 'a list -> 'a list
    val sin                   : real -> real
    val size                  : string -> int
    val sqrt                  : real -> real
    val string_equal          : string * string -> bool
    val string_not_equal      : string * string -> bool
    val sub                   : 'a * int -> 'b
    val update                : 'a * int * 'b -> unit
    val unsafe_sub            : 'a * int -> 'b
    val unsafe_update         : 'a * int * 'b -> unit
    val length                : 'a  -> int
    val array                 : int * '_a -> 'b
    val inline_equality       : ''a * ''a -> bool
    val external_equality     : ''a * ''a -> bool
    val andb                  : int * int -> int
    val orb                   : int * int -> int
    val xorb                  : int * int -> int
    val lshift                : int * int -> int
    val rshift                : int * int -> int
    val arshift               : int * int -> int
    val notb                  : int -> int
d231 2
d234 1
a235 2
      exception Size
      exception Subscript
d252 6
@


1.18
log
@Added inline ordof
@
text
@d4 3
d177 2
d271 1
a271 1
      val ml_require =			yes "system require"
d297 2
@


1.17
log
@Minor improvements to map
@
text
@d4 3
d154 1
d272 1
@


1.16
log
@Added a few extra cases to do simple reverse and map
calls more quickly.
@
text
@d4 4
d300 10
a310 10

      fun map f [] = []
	| map f [x] = [f x]
        | map f x =
          let
            fun map_sub(done, []) = rev done
              | map_sub(done, x :: xs) = map_sub(f x :: done, xs)
          in
            map_sub([], x)
          end
@


1.15
log
@Rewrote everything to communicate with C using the runtime environment
rather than numeric codes.
@
text
@d4 4
d293 3
a295 1
        fun rev list = rev' ([], list)
d299 1
a306 1

a307 1

@


1.14
log
@Changed types of ml_require and call_ml_value to reflect what they
really should be
@
text
@d4 4
d54 1
a54 1
(* 
d65 1
a65 1
 The type signatures given in this file are not very safe, but this is no problem as they may be 
a73 2
require "__callc_codes";

d77 2
a78 1
    type ml_value
d100 1
a100 1
    val call_c                : int * 'a -> 'b
d141 1
a141 1
    val  <>    		: ''a * ''a -> bool
d165 1
a165 1
    val external_equality	: ''a * ''a -> bool
d171 1
a171 1
    val arshift                : int * int -> int
a177 20
    exception Abs
    exception Bind
    exception Chr
    exception Diff
    exception Div
    exception Exp
    exception Floor
    exception Interrupt
    exception Io of string
    exception Ln
    exception Match
    exception Mod
    exception Neg
    exception Ord
    exception Prod
    exception Quot
    exception Sqrt
    exception Sum
    exception Size
    exception Subscript
d179 1
a179 7
    type ml_value = int
    fun make_ml_value x = raise Io "make_ml_value"
    fun ml_value_from_offset x = raise Io "ml_value_from_offset"
    fun make_ml_value_tuple x = call_c (CallCCodes_.ml_value_list, x)
    fun call_ml_value x = raise Io "call_ml_value"
    fun ml_require x = call_c (CallCCodes_.ml_require, x)
    fun (op @@) (list, list') = call_c (CallCCodes_.append, (list, list'))
d181 3
a183 1
    fun arctan (r : real) = raise Io "arctan unimplemented"
d185 1
a185 47
    fun chr (c : int) =
       call_c (CallCCodes_.chr, c) : string

    fun (op o) (f,g) x = f (g x)

    fun (op ^) (s : string, s' : string) =
       call_c (CallCCodes_.concatenate, (s, s')) : string

    fun cos (r : real) = raise Io "cos unimplemented"

    fun exp (r : real) = raise Io "exp unimplemented"

    fun explode (s : string) =
       call_c (CallCCodes_.explode, s) : string list

    fun implode (list : string list) =
       call_c (CallCCodes_.implode, list) : string

    fun int_abs 0 = 0
      | int_abs x =
        case  call_c (CallCCodes_.iabs, x) : int
          of 0 => raise Abs
           | result => result

    fun int_equal (x : int, y : int) = raise Io "int_equal unimplemented"

    fun int_greater (x : int, y : int) = raise Io "int_greater unimplemented"

    fun int_greater_or_equal (x : int, y : int) = raise Io "int_greater_or_equal unimplemented"

    fun int_less (x : int, y : int) = raise Io "int_less unimplemented"

    fun int_less_or_equal (x : int, y : int) = raise Io "int_less_or_equal unimplemented"

    fun int_minus (x : int, y : int) = raise Io "int_minus unimplemented"

    fun int_multiply (multiplier : int, multiplicand : int) =
      case  call_c (CallCCodes_.imultiply,
                          (multiplier, multiplicand)) : bool * int
        of (true, result) => result
         | _ => raise Prod

    fun int_negate 0 = 0
      | int_negate x =
        case  call_c (CallCCodes_.inegate, x) : int
          of 0 => raise Neg
           | result => result
d187 113
a299 1
    fun int_not_equal (x : int, y : int) = raise Io "int_not_equal unimplemented"
a300 62
    fun int_plus (x : int, y : int) = raise Io "int_plus unimplemented"

    fun ln (r : real) = raise Io "ln unimplemented"

    fun load_string (s : string) = raise Io "load_string unimplemented"

    fun load_var (s : string) = raise Io "load_var unimplemented"

    fun load_exn (s : string) = raise Io "load_exn unimplemented"

    fun load_struct (s : string) = raise Io "load_struct unimplemented"

    fun load_funct (s : string) = raise Io "load_funct unimplemented"

    fun (op mod) (divisor : int, dividend : int) =
      case  call_c (CallCCodes_.imodulo,
                          (divisor, dividend)) : bool * int
        of (true, result) => result
         | _ => raise Mod

    fun (op div) (divisor : int, dividend : int) =
      case  call_c (CallCCodes_.idivide,
                          (divisor, dividend)) : bool * int
        of (true, result) => result
         | _ => raise Div

    fun not true = false
      | not false = true

    fun not_equal (x, y) =
       call_c (CallCCodes_.not_equal, (x, y)) : bool

    fun ord (s : string) =
       call_c (CallCCodes_.ord, s) : int

    fun real_abs (r : real) =  call_c (CallCCodes_.rabs, r) : real

    fun real_equal (x : real, y : real) =  call_c (CallCCodes_.requal, (x, y)) : bool

    fun real_greater (x : real, y : real) =  call_c (CallCCodes_.rgt, (x, y)) : bool

    fun real_greater_or_equal (x : real, y : real) =  call_c (CallCCodes_.rge, (x, y)) : bool

    fun real_less (x : real, y : real) =  call_c (CallCCodes_.rlt, (x, y)) : bool

    fun real_less_or_equal (x : real, y : real) =  call_c (CallCCodes_.rle, (x, y)) : bool

    fun real_minus (x : real, y : real) =  call_c (CallCCodes_.rminus, (x, y)) : real

    fun real_multiply (x : real, y : real) =  call_c (CallCCodes_.rmultiply, (x, y)) : real

    fun real_negate (r : real) =  call_c (CallCCodes_.rnegate, r) : real

    fun real_not_equal (x : real, y : real) =  call_c (CallCCodes_.rnequal, (x, y)) : bool

    fun real_plus (x : real, y : real) =  call_c (CallCCodes_.rplus, (x, y)) : real

    local
      fun rev' (done, []) = done
        | rev' (done, x::xs) = rev' (x::done, xs)
    in
      fun rev list = rev' ([], list)
a301 52

    fun map f [] = []
      | map f x =
        let
          fun map_sub(done, []) = rev done
            | map_sub(done, x :: xs) = map_sub(f x :: done, xs)
        in
          map_sub([], x)
        end

    fun sin (r : real) = raise Io "sin unimplemented"

    fun size (s : string) =  call_c (CallCCodes_.size, s) : int

    fun sqrt (r : real) = raise Io "sqrt unimplemented"

    fun string_equal (s : string, s' : string) =
       call_c (CallCCodes_.string_equal, (s, s')) : bool

    fun string_not_equal (s : string, s' : string) =
       call_c (CallCCodes_.string_not_equal, (s, s')) : bool

    fun array(x,y) = raise Io "array unimplemented"

    fun length (x) = raise Io "length unimplemented"
    fun update(x,y,z) = raise Io "update unimplemented"
    fun sub(x,y) = raise Io "sub unimplemented"
    fun floor x = raise Io "floor unimplemented"
    fun real x = raise Io "real unimplemented"
    fun (op /) (x,y) = raise Io "/ unimplemented"

    fun load_string x = raise Io "load_string unimplemented"

    fun (op !) x = raise Io "deref"
    fun (op :=) (x,y) = raise Io "becomes"

    fun (op <>) (x,y) = 
      call_c (CallCCodes_.not_equal, (x,y)) : bool

    fun inline_equality(x,y) = raise Io "inline equality was called"
    fun external_equality(x,y) = 
      call_c (CallCCodes_.equal, (x,y)) : bool

    fun call_c(x,y) = raise Io "call_c"

      fun andb _ = raise Io "andb"                  
      fun orb _ = raise Io "orb"                  
      fun xorb _ = raise Io "xorb"                  
      fun lshift _ = raise Io "lshift"                
      fun rshift _ = raise Io "rshift"                
      fun arshift _ = raise Io "rshift"                
      fun notb _ = raise Io "notb"                  
@


1.13
log
@Added ML_REQUIRE builtin for interpreter
@
text
@d4 3
d130 1
a130 1
    val call_ml_value         : ml_value -> ml_value
d134 1
a134 1
    val ml_require            : string -> ml_value list
@


1.12
log
@Added new builtin ml_value_from_offset for getting pointers into
middles of code vectors for letrecs
@
text
@d4 4
d131 1
d198 1
a198 1

@


1.11
log
@Removed call to c for call_ml_value, now in line
@
text
@d4 3
d69 20
a88 20
      exception Abs
      exception Bind
      exception Chr
      exception Diff
      exception Div
      exception Exp
      exception Floor
      exception Interrupt
      exception Io of string
      exception Ln
      exception Match
      exception Mod
      exception Neg
      exception Ord
      exception Prod
      exception Quot
      exception Sqrt
      exception Sum
      exception Size
      exception Subscript
d90 72
a161 71
      val call_c                : int * 'a -> 'b
      val floor                 : real -> int
      val real                  : int -> real
      val /                     : real * real -> real
      val div                   : int * int -> int
      val !                     : 'a ref -> 'a
      val :=                    : 'a ref * 'a -> unit
      val   @@                   : 'a list * 'a list -> 'a list
      val arctan                : real -> real
      val chr                   : int -> string
      val o                     : ('b -> 'c) * ('a -> 'b) -> ('a -> 'c)
      val ^                     : string * string -> string
      val cos                   : real -> real
      val exp                   : real -> real
      val explode               : string -> string list
      val implode               : string list -> string
      val int_abs               : int -> int
      val int_equal             : int * int -> bool
      val int_greater           : int * int -> bool
      val int_greater_or_equal  : int * int -> bool
      val int_less              : int * int -> bool
      val int_less_or_equal     : int * int -> bool
      val int_minus             : int * int -> int
      val int_multiply          : int * int -> int
      val int_negate            : int -> int
      val int_not_equal         : int * int -> bool
      val int_plus              : int * int -> int
      val ln                    : real -> real
      val load_string           : string -> unit
      val load_var              : string -> unit
      val load_exn              : string -> unit
      val load_struct           : string -> unit
      val load_funct            : string -> unit
      val call_ml_value         : ml_value -> ml_value
      val make_ml_value         : 'a -> ml_value
      val make_ml_value_tuple   : ml_value list -> ml_value
      val map                   : ('a -> 'b) -> 'a list -> 'b list
      val mod                   : int * int -> int
      val not                   : bool -> bool
      val  <>    		: ''a * ''a -> bool
      val ord                   : string -> int
      val real_abs              : real -> real
      val real_equal            : real * real -> bool
      val real_greater          : real * real -> bool
      val real_greater_or_equal : real * real -> bool
      val real_less             : real * real -> bool
      val real_less_or_equal    : real * real -> bool
      val real_minus            : real * real -> real
      val real_multiply         : real * real -> real
      val real_negate           : real -> real
      val real_not_equal        : real * real -> bool
      val real_plus             : real * real -> real
      val rev                   : 'a list -> 'a list
      val sin                   : real -> real
      val size                  : string -> int
      val sqrt                  : real -> real
      val string_equal          : string * string -> bool
      val string_not_equal      : string * string -> bool
      val sub                   : 'a * int -> 'b
      val update                : 'a * int * 'b -> unit
      val length                : 'a  -> int
      val array                 : int * '_a -> 'b
      val inline_equality       : ''a * ''a -> bool
      val external_equality	: ''a * ''a -> bool
      val andb                  : int * int -> int
      val orb                   : int * int -> int
      val xorb                  : int * int -> int
      val lshift                : int * int -> int
      val rshift                : int * int -> int
      val arshift                : int * int -> int
      val notb                  : int -> int
d190 1
@


1.10
log
@Removed the abstype, wasn't necessary
@
text
@d4 3
d187 1
a187 1
    fun call_ml_value x = call_c(CallCCodes_.call_ml_value, x)
@


1.9
log
@Added extra functions load_var, load_exn, load_struct, load_funct for
interpreter
@
text
@d4 4
d181 4
a184 6
    abstype ml_value = A of int
      with
	fun make_ml_value x = raise Io "make_ml_value"
	fun make_ml_value_tuple x = call_c (CallCCodes_.ml_value_list, x)
	fun call_ml_value x = call_c(CallCCodes_.call_ml_value, x)
      end
@


1.8
log
@Added functions required for interpretive system
@
text
@d1 1
d3 4
a6 1
 $Log: __builtin_library.sml,v $
d109 5
d243 8
@


1.7
log
@Added Bits.arshift - arithmetic right shift
@
text
@d3 3
d54 1
a54 1

d105 2
d167 7
@


1.6
log
@Added the Bits structure
@
text
@d3 3
d135 1
d322 1
@


1.5
log
@Added inline and external equality.
@
text
@d3 3
d127 6
d312 7
@


1.4
log
@Mod and Div defined to call the wrong c functions
@
text
@d3 3
d67 1
a67 1
      val call_c                : 'a * 'b -> 'c
d122 2
a123 1
      val equality              : 'a * 'a -> bool
d281 1
a281 2
    fun array(x,y) = 
      raise Io "array unimplemented"
d283 6
a288 12
    fun length (x) =
      raise Io "length unimplemented"
    fun update(x,y,z) =       
      raise Io "update unimplemented"
    fun sub(x,y) = 
      raise Io "sub unimplemented"
    fun floor x = 
      raise Io "floor unimplemented"
    fun real x =    
      raise Io "real unimplemented"
    fun (op /) (x,y) = 
      raise Io "/ unimplemented"
d290 1
a290 2
    fun load_string x =    
      raise Io "load_string unimplemented"
d292 2
a293 2
        fun (op !) x = raise Io "deref"
        fun (op :=) (x,y) = raise Io "becomes"
d295 2
a296 2
        fun (op <>) (x,y) = 
          call_c (CallCCodes_.not_equal, (x,y)) : bool
d298 3
a300 2
        fun equality(x,y) = 
          call_c (CallCCodes_.equal, (x,y)) : bool
d302 1
a302 1
        fun call_c(x,y) = raise Io "call_c"
@


1.3
log
@Neatened the comments
@
text
@d3 3
d207 1
a207 1
      case  call_c (CallCCodes_.idivide,
d212 6
d292 1
a292 2
    fun div(a,b) = 
      raise Io "div unimplemented"
@


1.2
log
@call_c was before equality and hence overrode the builtin call_c
@
text
@d3 3
d25 1
a25 1
 The type signatures given in this file are no very safe, but this is no problem as they may be 
d27 5
@


1.1
log
@Initial revision
@
text
@d2 3
a4 1
 $Log$
d6 1
d286 3
a290 2
        fun equality(x,y) = 
          call_c (CallCCodes_.equal, (x,y)) : bool
@
