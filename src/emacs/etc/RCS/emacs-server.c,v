head	1.1;
access;
symbols
	MLW_daveb_inline_1_4_99:1.1.12
	MLWorks_21c0_1999_03_25:1.1
	MLWorks_20c1_1998_08_20:1.1
	MLWorks_20c0_1998_08_04:1.1
	MLWorks_20b2c2_1998_06_19:1.1
	MLWorks_20b2_Windows_1998_06_12:1.1
	MLWorks_20b1c1_1998_05_07:1.1
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.9.1.1.1.1
	MLWorks_workspace_97:1.1.11
	MLWorks_dt_wizard:1.1.10
	MLWorks_11c0_1997_09_09:1.1.9.1.1.1
	MLWorks_10r3:1.1.9.1.3
	MLWorks_10r2_551:1.1.9.1.2
	MLWorks_11:1.1.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.9.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.9
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.1.7.1.1
	MLWorks_gui_1996_12_18:1.1.8
	MLWorks_1_0_Win32_1996_12_17:1.1.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.1.5.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.1.5.1
	MLWorks_1_0_Irix_1996_11_28:1.1.5.1.1
	MLWorks_1_0_Win32_1996_11_22:1.1.6
	MLWorks_1_0_Unix_1996_11_14:1.1.5
	MLWorks_Open_Beta2_1996_10_11:1.1.4
	MLWorks_License_dev:1.1.3
	MLWorks_1_open_beta_1996_09_13:1.1.2
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1
	ML_beta_release_12/08/94:1.1
	ML_beta_release_03/08/94:1.1
	ML_revised_beta_release_25/05/94:1.1
	ML_final_beta_release_02/03/94:1.1
	mlworks-28-01-1994:1.1
	Release:1.1
	mlworks-beta-01-09-1993:1.1;
locks; strict;


1.1
date	93.03.11.15.21.16;	author jont;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1
	1.1.5.1
	1.1.6.1
	1.1.7.1
	1.1.8.1
	1.1.9.1
	1.1.10.1
	1.1.11.1
	1.1.12.1;
next	;

1.1.1.1
date	93.03.11.15.21.16;	author jont;	state Exp;
branches;
next	;

1.1.2.1
date	96.09.13.11.26.51;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.07.16.17.23;	author hope;	state Exp;
branches;
next	;

1.1.4.1
date	96.10.17.11.37.12;	author hope;	state Exp;
branches;
next	;

1.1.5.1
date	96.11.14.13.05.00;	author hope;	state Exp;
branches
	1.1.5.1.1.1;
next	;

1.1.5.1.1.1
date	96.11.28.15.14.29;	author hope;	state Exp;
branches;
next	;

1.1.6.1
date	96.11.22.18.22.27;	author hope;	state Exp;
branches;
next	;

1.1.7.1
date	96.12.17.18.00.28;	author hope;	state Exp;
branches
	1.1.7.1.1.1;
next	;

1.1.7.1.1.1
date	97.02.24.11.52.08;	author hope;	state Exp;
branches;
next	;

1.1.8.1
date	96.12.18.09.55.49;	author hope;	state Exp;
branches;
next	;

1.1.9.1
date	97.05.12.10.50.31;	author hope;	state Exp;
branches
	1.1.9.1.1.1
	1.1.9.1.2.1
	1.1.9.1.3.1;
next	;

1.1.9.1.1.1
date	97.07.28.18.32.41;	author daveb;	state Exp;
branches
	1.1.9.1.1.1.1.1;
next	;

1.1.9.1.1.1.1.1
date	97.10.07.11.58.47;	author jkbrook;	state Exp;
branches;
next	;

1.1.9.1.2.1
date	97.09.08.17.25.54;	author daveb;	state Exp;
branches;
next	;

1.1.9.1.3.1
date	97.09.09.14.22.38;	author daveb;	state Exp;
branches;
next	;

1.1.10.1
date	97.09.10.19.41.40;	author brucem;	state Exp;
branches;
next	;

1.1.11.1
date	97.09.11.21.09.12;	author daveb;	state Exp;
branches;
next	;

1.1.12.1
date	99.04.01.18.08.01;	author daveb;	state Exp;
branches;
next	;


desc
@The emacs server code for communication over a socket
@


1.1
log
@Initial revision
@
text
@/**************************************************************************
***
***  emacs-server.c  - forked by emacs, listen for find-file's 
***  ---------------------------------------------------------
***
***  SCCS ID: 92/04/07 11:51:36 2.2 emacs-server.c
***
***  Copyright (C) 1991 Claus Bo Nielsen
**************************************************************************/

#ifndef lint
static char      *_Version = "@@(#)92/04/07 11:51:36, 2.2 emacs-server.c";
#endif

#include <sys/types.h>
#include <sys/socket.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <sys/time.h>
#include <netdb.h>
#include <stdio.h>
#include <malloc.h>
#include <signal.h>

#include "se.h"				  /* here we defind mutual things  */


static int     debug = DEBUG;		  /* are we debugging?             */
static int     file_socket = FALSE;	  /* use unix file socket          */
static int     acceptsock;		  /* The connected socket port     */
static FILE   *confp;			  /* the console file pointer      */
static char   *port_path = NULL;

static int     SigInt();		  /* signal handler                */


/***************************************************************************/
int   main(argc, argv)
int   argc;
char *argv[];
/***************************************************************************/
{
   int                ch;
   int                sock;
   int                length;
   struct hostent    *hp, *gethostbyname();
   extern char       *optarg;
   extern int         optind;
   struct sockaddr_in server;
   struct sockaddr_un server_un;
   
   signal(SIGINT, SigInt);

   while ((ch = getopt(argc, argv, "dfp:u")) != -1)
      switch(ch)
      {
      case 'd':
	 debug = TRUE;
	 break;
      case 'p':
	 port_path = optarg;
	 break;
      case 'f':
	 file_socket = TRUE;
	 break;
      case 'u':
      case '?':
	 PrintUsage();
	 exit(0);
	 break;
      }

   /* We open the console for error messages */
   if ((confp = fopen("/dev/console", "a")) == NULL)
   {
      fprintf(stderr,"Can't_fopen_console");
      exit(0);
   }

   if (file_socket)			  /* use UNIX socket */
   {
      sock = socket(AF_UNIX, SOCK_STREAM, 0);
      
      server_un.sun_family = AF_UNIX;
      if (port_path == NULL)
	  strcpy(server_un.sun_path, SOCKET_PATH);
      else
      {
	 if (debug)
	    fprintf(confp, "Using file %s for unix socket\n", port_path);
	 
	 strcpy(server_un.sun_path, port_path);
      }
      
      if (bind(sock, (struct sockaddr *)&server_un, sizeof(server_un)) == -1)
	 err("115 Can't get socket path (remove file %s??)",
	     (port_path == NULL ? SOCKET_PATH : port_path));
      
      listen(sock, 5);
   }
   else					  /* use inet socket */
   {
      sock = socket(AF_INET, SOCK_STREAM, 0);
      
      server.sin_family = AF_INET;
      server.sin_addr.s_addr = INADDR_ANY;
      if (port_path == NULL)
	 server.sin_port = SOCKET_PORT;
      else
	 server.sin_port = atoi(port_path);
      
      if (bind(sock, (struct sockaddr *)&server, sizeof(server)) == -1)
	{
	  close(sock);
	  err("132 Can't bind socket");
	}
      
      listen(sock, 5);
   }
   
   while(1)				  /* just do this forever */
   {
      if (debug)
	 fprintf(confp,"Waiting for some one to call ... ");
      
      if ((acceptsock = accept(sock, (struct sockaddr *)0, (int *)0)) < 0)
	 err("143 Accept failed");
      
      if (debug)
	 fprintf(confp,"Yep! - got it\n");
      
      GetMessageAndSendEmacs();		  /* OK - get file path(s) and send */
      
      close(acceptsock);		  /* we're all done! */
   }
}


/*****************************************************************************/
int GetMessageAndSendEmacs()		  /* get file path(s) and send emacs */
/*****************************************************************************/
{
   char               filepath[PATH_LENGTH];
   char              *elisp;
   int                length;
   
   while(1)				  /* for all files to come */
   {
      memset(filepath, '\0', PATH_LENGTH); /* clear the old one */
      
      if (read(acceptsock, &length, 4) != 4)
	 err("168 Transmission error");

   	 
      if (length == ELISP_EXP)
      {
	 if (read(acceptsock, &length, 4) != 4)
	    err("174 Transmission error");
	 
	 elisp = (char *)calloc(length+1, 1);
	 
	 if (debug)
	    fprintf(confp,"Got a elisp expression of length %d\n", length);
	 
	 if (read(acceptsock, elisp, length) != length)
	    err("182 Transmission error");

	 fprintf(stderr,"%s", elisp);	  /* print it out */
	 free(elisp);
	 usleep(WAIT_TIME);		  /* wait for emacs (1/2 sec.) */
	 continue;
      }
      
      if (length == -1)
	 break;

      if (length >= PATH_LENGTH)	  /* we don't have room for it */
	 err("194 File path too long");

      if (read(acceptsock, filepath, length) != length)
	 err("197 Transmission error");

      if (debug)
	 fprintf(confp,"File path: %s\n", filepath);

      fprintf(stderr,"%s", filepath);	  /* send file path to emacs */
      usleep(WAIT_TIME);		  /* wait for emacs (1/2 sec.) */
   }
   return(0);
}


/***************************************************************************/
static int SigInt()
/***************************************************************************/
{
   unlink(SOCKET_PATH);			  /* remove the socket file   */
   unlink(port_path);
   
   exit(0);
}


/***************************************************************************/
int err(s, arg1, arg2)			  /* send error message to console */
char *s;
int arg1;
int arg2;
/***************************************************************************/
{
   char   str[120];

   strcpy(str, "Error - emacs-server.c:");
   strcat(str, s);
   
   fprintf(confp, str, arg1, arg2);
   exit(1);
}


/***************************************************************************/
int PrintUsage()			  /* print usage on stdout         */
/***************************************************************************/
{
   fprintf(stderr,"emacs-server version: 2.2 (92/04/07 11:51:36)\n");
   fprintf(stderr,"Usage: emacs-server [-d][-f][-p<port/path>]\n");
   fprintf(stderr," -d             : debug information\n");
   fprintf(stderr," -f             : use UNIX socket (other path in -p)\n");
   fprintf(stderr," -p <port/path> : port no or file path to use, default %d or %s\n", SOCKET_PORT, SOCKET_PATH);
}


@


1.1.12.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.1.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.1.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.1.9.1
log
@branched from 1.1
@
text
@@


1.1.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.1.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.1.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.1.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.1.8.1
log
@branched from 1.1
@
text
@@


1.1.7.1
log
@branched from 1.1
@
text
@@


1.1.7.1.1.1
log
@branched from 1.1.7.1
@
text
@@


1.1.6.1
log
@branched from 1.1
@
text
@@


1.1.5.1
log
@branched from 1.1
@
text
@@


1.1.5.1.1.1
log
@branched from 1.1.5.1
@
text
@@


1.1.4.1
log
@branched from 1.1
@
text
@@


1.1.3.1
log
@branched from 1.1
@
text
@@


1.1.2.1
log
@branched from 1.1
@
text
@@


1.1.1.1
log
@Fork for bug fixing
@
text
@@
