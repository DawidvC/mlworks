head	1.7;
access;
symbols
	MLW_daveb_inline_1_4_99:1.7.1
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.5.1.1.1.1
	MLWorks_workspace_97:1.6.7
	MLWorks_dt_wizard:1.6.6
	MLWorks_11c0_1997_09_09:1.6.5.1.1.1
	MLWorks_10r3:1.6.5.1.3
	MLWorks_10r2_551:1.6.5.1.2
	MLWorks_11:1.6.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.5.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.5
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.3.1.1
	MLWorks_gui_1996_12_18:1.6.4
	MLWorks_1_0_Win32_1996_12_17:1.6.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5
	ML_beta_release_12/08/94:1.2
	ML_beta_release_03/08/94:1.2
	ML_revised_beta_release_25/05/94:1.2
	ML_final_beta_release_02/03/94:1.2
	mlworks-28-01-1994:1.2
	Release:1.2
	mlworks-beta-01-09-1993:1.2;
locks; strict;
comment	@ *  @;


1.7
date	99.03.20.16.28.55;	author mitchell;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	96.11.06.12.44.24;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1;
next	1.5;

1.5
date	96.01.31.11.42.07;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	96.01.26.09.20.59;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	95.05.03.13.25.50;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	93.06.22.13.15.48;	author richard;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	93.03.15.14.23.27;	author richard;	state Exp;
branches;
next	;

1.2.1.1
date	93.06.22.13.15.48;	author jont;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.26.49;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.17.20;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.37.09;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.13.04.56;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.15.14.27;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.22.25;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.18.00.26;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	97.02.24.11.52.05;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.18.09.55.47;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	97.05.12.10.50.30;	author hope;	state Exp;
branches
	1.6.5.1.1.1
	1.6.5.1.2.1
	1.6.5.1.3.1;
next	;

1.6.5.1.1.1
date	97.07.28.18.32.39;	author daveb;	state Exp;
branches
	1.6.5.1.1.1.1.1;
next	;

1.6.5.1.1.1.1.1
date	97.10.07.11.58.45;	author jkbrook;	state Exp;
branches;
next	;

1.6.5.1.2.1
date	97.09.08.17.25.53;	author daveb;	state Exp;
branches;
next	;

1.6.5.1.3.1
date	97.09.09.14.22.36;	author daveb;	state Exp;
branches;
next	;

1.6.6.1
date	97.09.10.19.41.39;	author brucem;	state Exp;
branches;
next	;

1.6.7.1
date	97.09.11.21.09.11;	author daveb;	state Exp;
branches;
next	;

1.7.1.1
date	99.04.01.18.07.59;	author daveb;	state Exp;
branches;
next	;


desc
@MLWorks Emacs server program
@


1.7
log
@Fix to work with RedHat 5.2
@
text
@/*	==== MLWORKS EMACS SERVER ====
 *
 *  Copyright (C) 1993 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This program is started as a subprocess under Emacs.  It creates a
 *  UNIX socket (see init_socket_path for info on the name) and then
 *  copies anything coming in on the socket to its standard output.
 *  Emacs evaluates it.  Errors are reported by sending error reporting code
 *  to Emacs.
 *
 *  The socket binding has its permissions set to SOCKET_MODE.  This can be
 *  used to prevents other users sending spurious commands to your Emacs.
 *
 *  Revision Log
 *  ------------
 *  $Log: mlworks-server.c,v $
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
 *  Revision 1.5  1996/01/31  11:42:07  stephenb
 *  Make it work under Irix.  The main change being not to chmod
 *  the socket since for some reason this means that MLWorks cannot
 *  connect to the socket.  Also took the opportunity to clean up
 *  the signal handler code so that the body of the code only uses
 *  sigaction.
 *
 *  Revision 1.4  1996/01/26  09:20:59  stephenb
 *  Fix so that the read call taks account of the fact that it is
 *  reading from a socket.
 *
 *  Revision 1.3  1995/05/03  13:25:50  jont
 *  Conditionalise on OS type
 *  Now works hopefully of all unix platforms. Tested on Solaris and SunOS
 *
 *  Revision 1.2  1993/06/22  13:15:48  richard
 *  The socket name in the user's home directory is now removed when the
 *  server is killed, but only if it's the actual socket created by this
 *  server.
 *
 *  Revision 1.1  1993/03/15  14:23:27  richard
 *  Initial revision
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>		/* strcpy, strcat */
#include <errno.h>
#include <stdarg.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/un.h>
#include "syscalls.h"
#include <unistd.h>
extern char *sys_errlist[];

#define SOCKET_PREFIX "/tmp/."
#define SOCKET_SUFFIX "-mlworks-server"
#define SOCKET_MODE	(S_IFSOCK|S_IRUSR|S_IWUSR)
#define BUFFER_SIZE	4096

/* This next bit needs to be tidied up/removed */
#ifdef MLW_DEFINE_SIGACTION
#define S_IFSOCK        __S_IFSOCK
#define S_IFMT          __S_IFMT
#include <sigaction.h>
#endif

#ifdef MLW_USE_SIGVEC
/*
 * Some pre-POSIX systems don't support sigaction (or do so via optional
 * compatability libraries) but do support sigvec.  For our purposes
 * it is possible to pretend that sigvec is sigaction.
 */
#define sigaction sigvec
#define sa_handler sv_handler
#define sa_mask sv_mask
#define sa_flags sv_flags
#define sigemptyset(m) *(m)= 0 
#endif


/*  == Send error code to Emacs ==
 *
 *  This function packages up an error message in the form of printf() as an
 *  Emacs LISP expression to report the error.  If the code is non-zero the
 *  program is terminated with that code.
 */

static void error(int code, const char *format, ...)
{
  va_list arg;

  va_start(arg, format);
  fputs("(progn (message \"MLWorks server: ", stdout);
  vfprintf(stdout, format, arg);
  fputs("\") (ding))\n", stdout);
  va_end(arg);

  if(code)
    exit(code);
}


/*  == Socket information ==
 *
 *  The device and inode number are those of the created socket.  They are
 *  used in sigterm(), along with the name from the socket address.
 */

static dev_t device;
static ino_t inode;
static struct sockaddr_un sun;	/* socket address structure */


/*  == Termination signal handler ==
 *
 *  If the server is killed then it unlinks the socket it created in the
 *  user's home directory provided it is the same one it created, i.e., has
 *  the same device and inode number.
 */

static void sigterm()
{
  struct stat st;

  if(stat(sun.sun_path, &st))
  {
    if(errno != ENOENT)
      error(0, "Couldn't stat %s: %s", sun.sun_path, sys_errlist[errno]);
    exit(0);
  }

  if(st.st_dev == device && st.st_ino == inode)
    if(unlink(sun.sun_path))
      error(11, "Couldn't remove socket %s: %s",
	    sun.sun_path, sys_errlist[errno]);

  exit(0);
}



ssize_t readn(int fd, void *buff, size_t nbytes)
{
  size_t nleft, nread;

  nleft= nbytes;
  while (nleft > 0)
  {
    nread= read(fd, buff, nleft);
    if (nread < 0)
    {
      return nread;
    }
    else if (nread == 0)
    {
      break;
    }
    else
    {
      nleft -= nread;
      buff += nread;
    }
  }
  return nbytes-nleft;
}



/*
 * init_socket_path tries to fill in sun.sun_path with the
 * pathname of the socket.  It first tries MLWORKS_SERVER_FILE
 * and if this is not defined, it tries to construct a default
 * path of the form "/tmp/.$USER-mlworks-server".  If neither variable
 * is defined, it terminates the program with an error message since
 * it isn't clear whether it is worth defining yet another default to
 * cover this case.
 * 
 * Note that the method of determining the socket name must be kept
 * consistent with that used in the editor interface, see
 * <URI:hope://MLWsrc/unix/_editor.sml#getSocketName>
 */
static void init_socket_path(void)
{
  char const * s= getenv("MLWORKS_SERVER_FILE");
  if (s != NULL) {
    if (strlen(s) > sizeof(sun.sun_path)) {
      error(EXIT_FAILURE, "The socket file name defined by MLWORKS_SERVER_FILE is too long.");
    } else {
      (void)strcpy(sun.sun_path, s);
    }
  } else if ((s= getenv("USER")) != NULL) {
    size_t ul= strlen(s);
    size_t pl= sizeof(SOCKET_PREFIX)-1 + ul + sizeof(SOCKET_SUFFIX)-1;
    if (pl > sizeof(sun.sun_path)) {
      error(EXIT_FAILURE, "The socket file name defined by USER is too long.");
    } else {
      /* Not time critical, so strcat has lower maintenance overhead ... */
      strcpy(sun.sun_path, SOCKET_PREFIX);
      strcat(sun.sun_path, s);
      strcat(sun.sun_path, SOCKET_SUFFIX);
    }
  } else {
    error(EXIT_FAILURE, "Neither MLWORKS_SERVER_FILE nor USER are defined.");
  }
}




int main(void)
{
  int s;
  size_t sun_size;
  struct sigaction signal_handler;

  struct stat st;

  /* Read the HOME environment variable and check that it, plus the socket */
  /* base name, will fit into the socket naming structure. */

  memset(&sun, 0, sizeof(sun));
  init_socket_path();
  sun.sun_family = AF_UNIX;
  sun_size = sizeof(sun.sun_family) + strlen(sun.sun_path);

  s = socket(AF_UNIX, SOCK_STREAM, 0);
  if(s < 0)
    error(3, "Couldn't create socket: %s", sys_errlist[errno]);

  /* Before creating the socket name, set up termination signal handler to */
  /* remove it later. */
  signal_handler.sa_handler = sigterm;
  signal_handler.sa_flags= 0;
  sigemptyset(&signal_handler.sa_mask);
  if(sigaction(SIGTERM, &signal_handler, NULL) ||
     sigaction(SIGHUP, &signal_handler, NULL) ||
     sigaction(SIGINT, &signal_handler, NULL))
    error(0, "Couldn't set up signal handler: %s\n"
	     "Socket %s won't be removed.",
	  sys_errlist[errno], sun.sun_path); 

  if (bind(s, (struct sockaddr *)&sun, sun_size))
    switch (errno)
    {
      /* If the path is already in use try to find out what's occupying it. */
      /* If it's a socket, remove it and try again. */
      case EADDRINUSE:
      {
	struct stat st;
	if(stat(sun.sun_path, &st))
	  error(5, "Couldn't stat %s: %s", sun.sun_path, sys_errlist[errno]);
	if(!S_ISSOCK(st.st_mode))
	  error(6, "%s is in use and isn't a socket", sun.sun_path);
	if(unlink(sun.sun_path))
	  error(7, "Couldn't remove old socket %s: %s",
		sun.sun_path, sys_errlist[errno]);
	if(!bind(s, (struct sockaddr *)&sun, sun_size))
	  break;
      }

      default:
      error(4, "Couldn't bind socket to %s: %s",
		  sun.sun_path, sys_errlist[errno]);
    }

  /* Record the device and inode number for later reference. */

  if(stat(sun.sun_path, &st))
    error(13, "Couldn't stat %s: %s", sun.sun_path, sys_errlist[errno]);
  device = st.st_dev;
  inode = st.st_ino;

  if (listen(s, 5) != 0)
    error(EXIT_FAILURE, "Cannot listen ...");


#ifndef MLW_NO_SOCKET_PROTECTION
  /* Protect the socket. */
  if(chmod(sun.sun_path, SOCKET_MODE) != 0)
    error(0, "Unable to protect %s: %s", sun.sun_path, sys_errlist[errno]);
#endif

  for(;;)
  {
    struct {
      struct sockaddr_un addr;
      int                addr_len;
      int                fd;
    } mlworks;

    mlworks.addr_len= sizeof(mlworks.addr);
    mlworks.fd= accept(s, (struct sockaddr *)&mlworks.addr, &mlworks.addr_len);
    if(mlworks.fd < 0)
      error(9, "Couldn't accept from socket: %s", sys_errlist[errno]);

    for (;;)
    {
      ssize_t nread;
      char    msg_buf[BUFFER_SIZE];
      size_t  msg_len;

      if ((nread= readn(mlworks.fd, msg_buf, 2)) == 0)
	break;
      if (nread != 2) 
	error(EXIT_FAILURE, "Couldn't read message length: %s", sys_errlist[errno]);
      msg_len= ((unsigned char)msg_buf[0])*256 + (unsigned char)msg_buf[1];
      if (msg_len > BUFFER_SIZE)
	error(EXIT_FAILURE, "Message is too long");

      nread= readn(mlworks.fd, msg_buf, msg_len);
      if (nread != msg_len)
	error(EXIT_FAILURE, "Could not read message: %s", sys_errlist[errno]);

      if (write(STDOUT_FILENO, msg_buf, msg_len) != msg_len)
	error(EXIT_FAILURE, "Could not write message: %s", sys_errlist[errno]);
    }

    close(mlworks.fd);
  }

  return EXIT_SUCCESS;
}
@


1.7.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 3
 *  Revision 1.7  1999/03/20  16:28:55  mitchell
 *  Fix to work with RedHat 5.2
 *
@


1.6
log
@[Bug #1719]
change the location of the socket from $HOME/.mlworks-server
to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
to avoid problems with creating sockets on an Andrew file system.
@
text
@d19 6
d69 6
@


1.6.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 *  Revision 1.6.5.1  1997/05/12  10:50:30  hope
 *  branched from 1.6
 *
@


1.6.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 *  Revision 1.6.5.1  1997/05/12  10:50:30  hope
 *  branched from 1.6
 *
@


1.6.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 *  Revision 1.6.5.1  1997/05/12  10:50:30  hope
 *  branched from 1.6
 *
@


1.6.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 *  Revision 1.6.5.1.1.1  1997/07/28  18:32:39  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a18 3
 *  Revision 1.6.3.1  1996/12/17  18:00:26  hope
 *  branched from 1.6
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a18 6
 *  Revision 1.6  1996/11/06  12:44:24  stephenb
 *  [Bug #1719]
 *  change the location of the socket from $HOME/.mlworks-server
 *  to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 *  to avoid problems with creating sockets on an Andrew file system.
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a18 3
 *  Revision 1.6.1.1  1996/11/14  13:04:56  hope
 *  branched from 1.6
 *
@


1.5
log
@Make it work under Irix.  The main change being not to chmod
the socket since for some reason this means that MLWorks cannot
connect to the socket.  Also took the opportunity to clean up
the signal handler code so that the body of the code only uses
sigaction.
@
text
@d8 2
a9 2
 *  socket in the UNIX domain and binds it to $HOME/.mlworks-server.  It
 *  then copies anything coming in on the socket to its standard output.
d19 7
d46 1
a46 1
#include <string.h>
d58 2
a59 1
#define SOCKET_BASE	".mlworks-server"
d166 42
a207 1
int main()
a210 1
  char *home, *path;
a217 7
  home = getenv("HOME");
  if(home == NULL)
    error(1, "Your HOME envariable is not set!");

  if(strlen(home)+1+strlen(SOCKET_BASE)+1 > sizeof(sun.sun_path))
    error(2, "The path of your home directory is too long.");

d219 1
a220 3
  strcpy(sun.sun_path, home);
  strcat(sun.sun_path, "/");
  strcat(sun.sun_path, SOCKET_BASE);
@


1.5.3.1
log
@branched from 1.5
@
text
@a18 7
 *  Revision 1.5  1996/01/31  11:42:07  stephenb
 *  Make it work under Irix.  The main change being not to chmod
 *  the socket since for some reason this means that MLWorks cannot
 *  connect to the socket.  Also took the opportunity to clean up
 *  the signal handler code so that the body of the code only uses
 *  sigaction.
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a18 7
 *  Revision 1.5  1996/01/31  11:42:07  stephenb
 *  Make it work under Irix.  The main change being not to chmod
 *  the socket since for some reason this means that MLWorks cannot
 *  connect to the socket.  Also took the opportunity to clean up
 *  the signal handler code so that the body of the code only uses
 *  sigaction.
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a18 7
 *  Revision 1.5  1996/01/31  11:42:07  stephenb
 *  Make it work under Irix.  The main change being not to chmod
 *  the socket since for some reason this means that MLWorks cannot
 *  connect to the socket.  Also took the opportunity to clean up
 *  the signal handler code so that the body of the code only uses
 *  sigaction.
 *
@


1.4
log
@Fix so that the read call taks account of the fact that it is
reading from a socket.
@
text
@d19 4
d52 1
a52 1
#define SOCKET_MODE	0600
d56 14
d163 1
a163 7
#if defined(__SunOS__) || defined(__Irix__)
  struct sigvec sv;
#else
#if defined(__Solaris__) || defined(__Linux__)
  struct sigaction sv;
#endif
#endif
d190 6
a195 17

#if defined(__SunOS__) || defined(__Irix__)
  sv.sv_handler = sigterm;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  if(sigvec(SIGTERM, &sv, NULL) ||
     sigvec(SIGHUP, &sv, NULL) ||
     sigvec(SIGINT, &sv, NULL))
#else
#if defined(__Solaris__) || defined(__Linux__)
  sv.sa_handler = sigterm;
  sigemptyset(&sv.sa_mask);
  if(sigaction(SIGTERM, &sv, NULL) ||
     sigaction(SIGHUP, &sv, NULL) ||
     sigaction(SIGINT, &sv, NULL))
#endif
#endif
d200 2
a201 2
  if(bind(s, (struct sockaddr *)&sun, sun_size))
    switch(errno)
d235 1
d239 1
d266 1
a266 1
	error(EXIT_FAILURE, "Filename is too long");
@


1.3
log
@Conditionalise on OS type
Now works hopefully of all unix platforms. Tested on Solaris and SunOS
@
text
@d19 4
d44 1
d112 28
d165 1
d173 1
a173 1
  if(s == -1)
d230 3
a232 1
  listen(s, 5);
d235 1
a235 2

  if(chmod(sun.sun_path, SOCKET_MODE))
d240 9
a248 4
    int r;
    int a = accept(s, NULL, NULL);

    if(a < 0)
d251 1
a251 1
    for(;;)
d253 3
a255 6
      char buffer[BUFFER_SIZE];

      r = read(a, buffer, BUFFER_SIZE);

      if(r < 0)
	error(8, "Couldn't read from socket: %s", sys_errlist[errno]);
d257 1
a257 1
      if(r == 0)
d259 9
d269 2
a270 1
      fwrite(buffer, sizeof(char), r, stdout);
d273 1
a273 1
    close(a);
d276 1
a276 1
  return(0);
@


1.2
log
@The socket name in the user's home directory is now removed when the
server is killed, but only if it's the actual socket created by this
server.
@
text
@d19 5
d39 1
d112 1
d114 6
d145 1
d152 9
d165 1
a165 1
  if(bind(s, &sun, sun_size))
d180 1
a180 1
	if(!bind(s, &sun, sun_size))
@


1.2.1.1
log
@Fork for bug fixing
@
text
@a18 5
 *  Revision 1.2  1993/06/22  13:15:48  richard
 *  The socket name in the user's home directory is now removed when the
 *  server is killed, but only if it's the actual socket created by this
 *  server.
 *
@


1.1
log
@Initial revision
@
text
@d18 4
a21 1
 *  $Log$
d29 1
d62 39
a103 1
  struct sockaddr_un sun;
d106 2
d129 13
d165 7
@
