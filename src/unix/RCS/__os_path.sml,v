head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.10
	MLWorks_20m1_1997_10_23:1.10
	MLWorks_11r1:1.10.1.1.1.1.1
	MLWorks_workspace_97:1.10.3
	MLWorks_dt_wizard:1.10.2
	MLWorks_11c0_1997_09_09:1.10.1.1.1.1
	MLWorks_10r3:1.10.1.1.3
	MLWorks_10r2_551:1.10.1.1.2
	MLWorks_11:1.10.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.1.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.10.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.1
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.1.1
	MLWorks_1_0_Irix_1996_11_28:1.8.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.2
	MLWorks_1_0_Unix_1996_11_14:1.8.1
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.4
	MLWorks_Beta_1996_06_05:1.4
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@ *  @;


1.15
date	99.03.19.12.26.48;	author mitchell;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	99.03.17.10.57.16;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	99.02.02.16.01.53;	author mitchell;	state Exp;
branches;
next	1.12;

1.12
date	98.08.13.11.29.37;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	98.02.20.15.36.13;	author mitchell;	state Exp;
branches;
next	1.10;

1.10
date	97.04.02.15.27.04;	author matthew;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	97.03.04.14.19.31;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.11.06.11.31.24;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.10.21.15.22.43;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.06.19.13.41.42;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	96.06.19.13.30.02;	author stephenb;	state Exp;
branches;
next	1.4;

1.4
date	96.05.23.11.43.14;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.05.22.12.19.20;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.21.13.59.21;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.05.17.15.35.43;	author stephenb;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.42.39;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.35.47;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.54.51;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.14.13.23.13;	author hope;	state Exp;
branches
	1.8.1.1.1.1;
next	;

1.8.1.1.1.1
date	96.11.28.15.33.44;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.11.22.18.40.14;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.18.19.15;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.12.13.34;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.10.14.38;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	97.05.12.10.52.48;	author hope;	state Exp;
branches
	1.10.1.1.1.1
	1.10.1.1.2.1
	1.10.1.1.3.1;
next	;

1.10.1.1.1.1
date	97.07.28.18.34.59;	author daveb;	state Exp;
branches
	1.10.1.1.1.1.1.1;
next	;

1.10.1.1.1.1.1.1
date	97.10.07.12.00.42;	author jkbrook;	state Exp;
branches;
next	;

1.10.1.1.2.1
date	97.09.08.17.27.46;	author daveb;	state Exp;
branches;
next	;

1.10.1.1.3.1
date	97.09.09.14.24.52;	author daveb;	state Exp;
branches;
next	;

1.10.2.1
date	97.09.10.19.43.42;	author brucem;	state Exp;
branches;
next	;

1.10.3.1
date	97.09.11.21.11.07;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.18.09.16;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.15
log
@[Bug #30092]
Fix typo
@
text
@(* Copyright 1996 The Harlequin Group Limited.  All rights reserved.
 *
 * Unix OS.Path implementation.
 *
 * Note
 *    Some of the functions are not as efficient as possible.  For example,
 *    much use is made of fromString, toString and mkCanonical when it
 *    would be more efficient to do the work directly on the string.
 *
 * Revision Log
 * ------------
 *
 * $Log: __os_path.sml,v $
 *  Revision 1.14  1999/03/17  10:57:16  daveb
 *  [Bug #30092]
 *  Added InvalidArc exception.
 *
 *  Revision 1.13  1999/02/02  16:01:53  mitchell
 *  [Bug #190500]
 *  Remove redundant require statements
 *
 *  Revision 1.12  1998/08/13  11:29:37  jont
 *  [Bug #30468]
 *  Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 *  Revision 1.11  1998/02/20  15:36:13  mitchell
 *  [Bug #30337]
 *  Change OS.Path.concat to take a string list, instead of a pair of strings.
 *
 *  Revision 1.10  1997/04/02  15:27:04  matthew
 *  Fixing concat
 *
 *  Revision 1.9  1997/03/04  14:19:31  jont
 *  [Bug #1939]
 *  Add fromUnixPath and toUnixPath
 *
 *  Revision 1.8  1996/11/06  11:31:24  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.7  1996/10/21  15:22:43  jont
 *  Remove references to basis.toplevel
 *
 *  Revision 1.6  1996/06/19  13:41:42  stephenb
 *  Remove the out of date comment about mkRelative not working.
 *
 *  Revision 1.5  1996/06/19  13:30:02  stephenb
 *  Fix mkRelative so that it matches the basis spec.
 *
 *  Revision 1.4  1996/05/23  11:43:14  stephenb
 *  Implement mkCanonical, isCanonical, mkAbsolute, mkRelative and isRoot.
 *
 *  Revision 1.3  1996/05/22  12:19:20  stephenb
 *  Fix some of the already implemented functions so that they pass their
 *  section of the test suite.
 *
 *  Revision 1.2  1996/05/21  13:59:21  stephenb
 *  Fix toString, joineDirFile and joinBaseExt so that they pass their
 *  respective test suites.
 *
 *  Revision 1.1  1996/05/17  15:35:43  stephenb
 *  new unit
 *
 *)

require "^.basis.__list";
require "^.basis.__char";
require "^.basis.__string";
require "^.basis.os_path";


structure OSPath_ : OS_PATH =
  struct

    exception Path

    exception InvalidArc

    val dirSeparator = #"/"

    val extSeparator = #"."

    val parentArc = ".."

    val currentArc = "."


    (*
     * Unix doesn't have volumes, so a volume is only valid if it is the
     * empty string.
     *)
    fun validVolume {isAbs = _, vol = vol} = vol = ""

    fun invalidArc s = Char.contains s dirSeparator


    local
      fun fromString' (s, 0, l, arcs) =
        if String.sub (s, 0) = dirSeparator then
          { isAbs= true
          , vol=   ""
          , arcs=  String.substring (s, 1, l)::arcs
          }
        else
          { isAbs= false
          , vol=   ""
          , arcs=  String.substring (s, 0, l+1)::arcs
          }
      | fromString' (s, p, l, arcs) =
        if String.sub (s, p) = dirSeparator then
          fromString' (s, p-1, 0, String.substring (s, p+1, l)::arcs)
        else
          fromString' (s, p-1, l+1, arcs)
    in
      fun fromString s =
        let
          val l = size s
        in
          if l = 0 then
            {isAbs = false, vol = "", arcs = []}
          else if l = 1 then
            if String.sub (s, 0) = dirSeparator then
              {isAbs = true, vol = "", arcs = [""]}
            else
              {isAbs = false, vol = "", arcs = [s]}
          else
            fromString' (s, l-1, 0, [])
        end
    end




    local
      val sep = String.str dirSeparator
    in
      fun toString {isAbs, vol, arcs} =
        if vol <> "" then
          raise Path
        else
          case arcs of
            [] => if isAbs then sep else ""
          | (arc::arcs) =>
              if arc = "" andalso not isAbs then
                raise Path
   	      else if invalidArc arc then
		raise InvalidArc
              else
                let
                  val initialPath = if isAbs then sep^arc else arc

	          fun addArc (arc, path) =
	   	    if invalidArc arc then
		      raise InvalidArc
		    else
		      concat [path, sep, arc]

                in
                  List.foldl addArc initialPath arcs
                end
    end



    (*
     * Unix doesn't have volumes, so no matter what the path, the volume
     * is the empty string.
     *)
    fun getVolume _ = ""




    (* The spec. for this getParent is defined in terms of arcs.
     *
     * An obvious implementation would therefore be to use fromString
     * to convert to arcs, apply the rules and then use toString to
     * convert it back to a string.
     *
     * The following implementation avoids the overhead of this approach
     * at the expense of this approach by applying the rules directly to
     * a string as it is parsed backwards.  However, it does so at the
     * expense of being rather cryptic :-<
     *)
    local
      fun getParent' (s, n) =
        if n = 0 then
          if String.sub (s, 0) = dirSeparator
          then String.str dirSeparator
          else currentArc
        else if String.sub (s, n) = dirSeparator
        then String.substring (s, 0, n)
        else getParent' (s, n-1)
    in
      fun getParent "" = parentArc
        | getParent s = 
        let
          val e = size s - 1
        in
          case String.sub (s, e) of
            #"/" => if e = 0 then s else s ^ parentArc
          | #"." => 
            if e = 0 then
              parentArc
            else 
              (case String.sub (s, e-1) of
                #"." => 
                  if e = 1 
                  then s ^ String.str dirSeparator ^ parentArc
                  else if String.sub (s, e-2) = dirSeparator
                  then s ^ String.str dirSeparator ^ parentArc
                  else getParent' (s, e-2)
              | #"/" => String.substring (s, 0, e) ^ parentArc
              | _    => getParent' (s, e-1))
          | _ => getParent' (s, e)
        end
    end



    local

      (* An auxiliary function which returns (dirLength, fileStart).
       * for a given (path, end, end).  
       *)
      fun splitDirFile' (s, n, e) =
        if n = ~1 then
          (0, 0)
        else
          if String.sub (s, n) = dirSeparator
          then if n = 0 then (n+1, n+1) else (n, n+1)
          else splitDirFile' (s, n-1, e)



    in

      fun splitDirFile s =
        let
          val l = size s
          val e = l - 1
          val (m, n) = splitDirFile' (s, e, e)
        in
          { dir =  String.substring (s, 0, m)
          , file = String.substring (s, n, l-n)
          }
        end


      (*
       * Could implement this as #dir o splitDirFile, but the following
       * is slightly more efficient in that it avoids performing the
       * file substring operation.
       *)
      fun dir s =
        let
          val e = size s - 1
          val (m, n) = splitDirFile' (s, e, e)
        in
          String.substring (s, 0, m)
        end



      (* 
       * Could implement this as #file o splitDirFile, but it is not, for the
       * same reason that dir is not implemented that way.
       *)
      fun file s =
        let
          val l = size s
          val e = l - 1
          val (m, n) = splitDirFile' (s, e, e)
        in
          String.substring (s, n, l-n)
        end
    end



    fun joinDirFile {dir, file} =
      let
	val dirSepStr = String.str dirSeparator
      in
        if invalidArc file then
  	  raise InvalidArc
        else if dir = "" then
	  file
        else if dir = dirSepStr then
	  dirSepStr ^ file
        else
          dir ^ dirSepStr ^ file
      end




    local

      fun splitBaseExt' (s, n, e) =
        if n = ~1 then
          NONE
        else 
          let
            val ch = String.sub (s, n)
          in
            if ch = extSeparator then
              if n = e orelse n = 0 orelse String.sub (s, n-1) = dirSeparator
              then NONE
              else SOME n
            else if ch = dirSeparator
            then NONE
            else splitBaseExt' (s, n-1, e)
          end
    in

      fun splitBaseExt s =
        let
           val e = size s - 1
        in
          case splitBaseExt' (s, e, e) of
            NONE => {base = s, ext = NONE}
          | SOME n => { base = String.substring (s, 0, n)
                      , ext =  SOME (String.substring (s, n+1, e-n))
                      }
        end


      fun base s = 
        let
           val e = size s - 1
        in
          case splitBaseExt' (s, e, e) of
            NONE => s
          | SOME n => String.substring (s, 0, n)
        end


      fun ext s = 
        let
           val e = size s - 1
        in
          case splitBaseExt' (s, e, e) of
            NONE => NONE
          | SOME n => SOME (String.substring (s, n+1, e-n))
        end
    end



    fun joinBaseExt {base, ext = NONE} = base
      | joinBaseExt {base, ext = SOME ""} = base
      | joinBaseExt {base, ext = SOME ext} = base ^ (String.str extSeparator) ^ ext



    (*
     * The following is a slightly modified version of mkCanonical
     * as found in _unixpath.sml.  It would be more efficient to
     * to the cannonicalisation directly on the string, but since
     * this does work ...
     *)
    fun mkCanonical s =
      let
        val {isAbs, vol, arcs} = fromString s
        fun canon ([], 0, result) = result
        |   canon ([], n, result) =
          (* n > 0 => need parent arcs at the beginning, unless the path is
             absolute *)
          if isAbs
          then result
          else canon ([], n-1, parentArc :: result)
        |   canon ("" :: arcs, level, result) =  (* ignore empty arcs *)
          canon (arcs, level, result)
        |   canon ("." :: arcs, level, result) =
          canon (arcs, level, result)
        |   canon (".." :: arcs, level, result) =
          canon (arcs, level + 1, result)
        |   canon (arc :: arcs, 0, result) =
          canon (arcs, 0, arc :: result)
        |   canon (_ :: arcs, n, result) =
          (* n > 0 => this arc is overridden by a parent arc *)
          canon (arcs, n-1, result)

        val arcs' = canon (rev arcs, 0, [])
        val s' = toString {isAbs=isAbs, vol=vol, arcs=arcs'}
      in
        if s' = "" then currentArc else s'
      end



    (* 
     * Should reimplement at some point to be more efficient.
     *)
    fun isCanonical s = s = mkCanonical s



    fun isAbsolute "" = false
      | isAbsolute s = String.sub(s, 0) = dirSeparator


    fun concat2backwards (t, "") = t
      | concat2backwards (t, s) =
      if t <> "" andalso String.sub(t, 0) = dirSeparator then
        raise Path
      else if String.sub(s, size s - 1) = dirSeparator then
        s ^ t
      else
        s ^ String.str dirSeparator ^ t
        
        
    fun concat [] = ""
      | concat (h::t) = foldl concat2backwards h t;


(*
    fun mkAbsolute (p, abs) = 
      if isAbsolute abs then
        if isAbsolute p
        then p
        else mkCanonical (concat2backwards (p, abs))
      else
        raise Path
*)
    fun mkAbsolute {path, relativeTo} =
      if isAbsolute relativeTo then
        if isAbsolute path then
          path
        else mkCanonical (concat2backwards (path, relativeTo))
      else
        raise Path



    fun isRelative "" = true
      | isRelative s = String.sub(s, 0) <> dirSeparator



    (*
     * The following is borrowed from the Win32 version.
     *)
    local
      fun strip_common_prefix (l, []:string list) = (l, [])
      |   strip_common_prefix ([], l) = ([], l)
      |   strip_common_prefix (l1 as h1::t1, l2 as h2::t2) =
        if h1 = h2
        then strip_common_prefix (t1, t2)
        else (l1, l2)


      fun mkRel ([], result) = result
      |   mkRel (_::t, result) = mkRel (t, parentArc :: result)

      fun noroot [""] = []
        | noroot x = x

      fun diff (s1, s2) =
        (* s1 and s2 are both absolute.  s2 is a directory. *)
        let
          val canon1 = mkCanonical s1
          val canon2 = s2
          val {arcs = arcs1, ...} = fromString canon1
          val {arcs = arcs2, ...} = fromString canon2
          val (arcs1', arcs2') = strip_common_prefix (arcs1, arcs2)
          val arcs = mkRel (arcs1', noroot arcs2')
        in
          toString {isAbs = false, vol = "", arcs = arcs}
        end
     
      fun isDir s = String.size s>1 andalso 
                    String.sub(s,String.size s-1) = dirSeparator

    in

(*
      fun mkRelative (p, abs) = 
        let
          val r1 = 
            if isAbsolute abs then
              if isAbsolute p
                then diff (abs, p)
              else p
            else
              raise Path

          val r2 = if isDir p andalso not (isDir r1) 
                   then r1^(String.str dirSeparator) else r1
        in
          if p = "" then "" else if r2="" then currentArc else r2
        end
*)
      fun mkRelative {path, relativeTo} = 
        let
          val r1 = 
            if isAbsolute relativeTo then
              if isAbsolute path
                then diff (relativeTo, path)
              else path
            else
              raise Path

          val r2 = if isDir path andalso not (isDir r1) 
		     then r1^(String.str dirSeparator) else r1

        in
          if path="" then "" else if r2="" then currentArc else r2
        end
    end



    fun isRoot path = path = "/"

    (* Translation between local paths and unix paths. Identity on unix *)
    fun fromUnixPath s = s
    fun toUnixPath s = s

 end
@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 *  Revision 1.15  1999/03/19  12:26:48  mitchell
 *  [Bug #30092]
 *  Fix typo
 *
@


1.14
log
@[Bug #30092]
Added InvalidArc exception.
@
text
@d14 4
d283 1
a283 1
	val dirSepStr = String.str dirSeperator
@


1.13
log
@[Bug #190500]
Remove redundant require statements
@
text
@d14 4
d63 1
d73 2
d90 1
a90 1

d142 2
d147 7
d155 1
a155 1
                  List.foldl (fn (arc, path) => path^sep^arc) initialPath arcs
d277 13
a289 4

    fun joinDirFile {dir = "", file} = file
      | joinDirFile {dir = "/", file} = "/"^file
      | joinDirFile {dir, file} = dir ^ (String.str dirSeparator) ^ file
@


1.12
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d14 4
a59 1
require "^.basis.__int";
@


1.11
log
@[Bug #30337]
Change OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@d14 4
d386 1
d394 8
d446 1
d461 17
@


1.10
log
@Fixing concat
@
text
@d14 3
d368 2
a369 3

    fun concat ("", t) = t
      | concat (s, t) =
d377 4
a380 1
       
d386 1
a386 1
        else mkCanonical (concat (abs, p))
@


1.10.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 3
 *  Revision 1.10  1997/04/02  15:27:04  matthew
 *  Fixing concat
 *
@


1.10.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 3
 *  Revision 1.10  1997/04/02  15:27:04  matthew
 *  Fixing concat
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a13 3
 *  Revision 1.10  1997/04/02  15:27:04  matthew
 *  Fixing concat
 *
@


1.10.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 *  Revision 1.10.1.1  1997/05/12  10:52:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 *  Revision 1.10.1.1  1997/05/12  10:52:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 *  Revision 1.10.1.1  1997/05/12  10:52:48  hope
 *  branched from 1.10
 *
@


1.10.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 *  Revision 1.10.1.1.1.1  1997/07/28  18:34:59  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9
log
@[Bug #1939]
Add fromUnixPath and toUnixPath
@
text
@d14 4
a366 1
      | concat (s, "") = s
d368 1
a368 1
      if String.sub(t, 0) = dirSeparator then
@


1.8
log
@[Bug #1728]
__integer becomes __int
@
text
@d14 4
d445 4
@


1.8.4.1
log
@branched from 1.8
@
text
@a13 4
 *  Revision 1.8  1996/11/06  11:31:24  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a13 4
 *  Revision 1.8  1996/11/06  11:31:24  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a13 3
 *  Revision 1.8.3.1  1996/12/17  18:19:15  hope
 *  branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a13 4
 *  Revision 1.8  1996/11/06  11:31:24  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a13 4
 *  Revision 1.8  1996/11/06  11:31:24  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.8.1.1.1.1
log
@branched from 1.8.1.1
@
text
@a13 3
 *  Revision 1.8.1.1  1996/11/14  13:23:13  hope
 *  branched from 1.8
 *
@


1.7
log
@Remove references to basis.toplevel
@
text
@d14 3
d41 1
a41 1
require "^.basis.__integer";
@


1.6
log
@Remove the out of date comment about mkRelative not working.
@
text
@d14 3
a35 1
require "^.basis.toplevel";
@


1.6.3.1
log
@branched from 1.6
@
text
@a13 3
 *  Revision 1.6  1996/06/19  13:41:42  stephenb
 *  Remove the out of date comment about mkRelative not working.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a13 3
 *  Revision 1.6  1996/06/19  13:41:42  stephenb
 *  Remove the out of date comment about mkRelative not working.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a13 3
 *  Revision 1.6  1996/06/19  13:41:42  stephenb
 *  Remove the out of date comment about mkRelative not working.
 *
@


1.5
log
@Fix mkRelative so that it matches the basis spec.
@
text
@d6 1
a6 1
 * a) Some of the functions are not as efficient as possible.  For example,
a8 3
 * b) mkRelative fails some of the tests since the implementation is
 *    taken almost verbatim from a version which complied with an older
 *    spec.
d14 3
@


1.4
log
@Implement mkCanonical, isCanonical, mkAbsolute, mkRelative and isRoot.
@
text
@d17 3
d381 1
a381 5
     * The following is a slightly modified version of mkRelative
     * as found in _unixpath.sml.  It has not been fully updated to
     * the latest basis spec. though due to lack of time.
     * As it stands it produces incorrect results for some of the
     * tests in the mkAbsolute test file.
d395 3
d402 1
a402 1
          val canon2 = mkCanonical s2
d406 1
a406 1
          val arcs = mkRel (arcs1', arcs2')
d411 2
d417 14
a430 6
        if isAbsolute abs then
          if isAbsolute p
          then diff (abs, p)
          else p
        else
         raise Path
@


1.3
log
@Fix some of the already implemented functions so that they pass their
section of the test suite.
@
text
@d5 8
d17 4
d33 1
a39 2
    exception Unimplemented of string

d59 1
d175 41
a215 7
    fun splitDirFile' (s, n, e) =
      if n = ~1 then
        (0, 0)
      else
        if String.sub (s, n) = dirSeparator
        then if n = 0 then (n+1, n+1) else (n, n+1)
        else splitDirFile' (s, n-1, e)
d219 13
a231 10
    fun splitDirFile s =
      let
        val l = size s
        val e = l - 1
        val (m, n) = splitDirFile' (s, e, e)
      in
        { dir =  String.substring (s, 0, m)
        , file = String.substring (s, n, l-n)
        }
      end
d243 1
a243 12
    (*
     * Could implement this as #dir o splitDirFile, but the following
     * is slightly more efficient in that it avoids performing the
     * file substring operation.
     *)
    fun dir s =
      let
        val e = size s - 1
        val (m, n) = splitDirFile' (s, e, e)
      in
        String.substring (s, 0, m)
      end
d245 16
d262 10
a272 12
    (* 
     * Could implement this as #file o splitDirFile, but it is not, for the
     * same reason that dir is not implemented that way
     *)
    fun file s =
      let
        val l = size s
        val e = l - 1
        val (m, n) = splitDirFile' (s, e, e)
      in
        String.substring (s, n, l-n)
      end
d274 8
d284 1
a284 4
    fun splitBaseExt' (s, n, e) =
      if n = ~1 then
        NONE
      else 
d286 1
a286 1
          val ch = String.sub (s, n)
d288 3
a290 7
          if ch = extSeparator then
            if n = e orelse n = 0 orelse String.sub (s, n-1) = dirSeparator
            then NONE
            else SOME n
          else if ch = dirSeparator
          then NONE
          else splitBaseExt' (s, n-1, e)
d292 1
a292 13



    fun splitBaseExt s =
      let
         val e = size s - 1
      in
        case splitBaseExt' (s, e, e) of
          NONE => {base = s, ext = NONE}
        | SOME n => { base = String.substring (s, 0, n)
                    , ext =  SOME (String.substring (s, n+1, e-n))
                    }
      end
d302 7
a308 1
    fun base s = 
d310 19
a328 8
         val e = size s - 1
      in
        case splitBaseExt' (s, e, e) of
          NONE => s
        | SOME n => String.substring (s, 0, n)
      end


d330 2
a331 3
    fun ext s = 
      let
         val e = size s - 1
d333 1
a333 3
        case splitBaseExt' (s, e, e) of
          NONE => NONE
        | SOME n => SOME (String.substring (s, n+1, e-n))
a336 1
    fun mkCanonical x = raise Unimplemented "mkCanonical"
d338 4
a341 10
    (*
    fun mkCanonical "" = "."
      | mkCanonical s =
          let
            val c0 = Substring.sub (s, 0)
          in
            if c0 = dirSeparator then
            else if c0 = #"." then
            else 
    *)
a342 5
    fun isCanonical x = raise Unimplemented "isCanonical"

    fun mkAbsolute x = raise Unimplemented "mkAbsolute"

    fun mkRelative x = raise Unimplemented "mkRelative"
a348 7
    fun isRelative "" = true
      | isRelative s = String.sub(s, 0) <> dirSeparator



    fun isRoot x = raise Unimplemented "isRoot"

d361 64
@


1.2
log
@Fix toString, joineDirFile and joinBaseExt so that they pass their
respective test suites.
@
text
@d9 4
d39 5
d106 5
d114 47
a160 1
    fun getParent x = raise Unimplemented "getParent"  (* XXX *)
d164 6
a169 4
      if n = ~1 then (0, 0)
      else if String.sub (s, n) = dirSeparator
           then (n, n+1)
           else splitDirFile' (s, n-1, e)
d186 1
d188 2
a189 2
    |   joinDirFile {dir = "/", file} = "/"^file
    |   joinDirFile {dir, file} = dir ^ (String.str dirSeparator) ^ file
d193 6
d209 4
d215 2
a216 1
        val e = size s - 1
d219 1
a219 1
        String.substring (s, n, e-n)
d232 6
a237 8
            if n = e then
              NONE
            else
              SOME n
          else if ch = dirSeparator then
            NONE
          else 
            splitBaseExt' (s, n-1, e)
d241 1
d256 1
d271 1
d277 1
a277 1
          NONE => SOME s
a300 1
    fun isAbsolute x = raise Unimplemented "isAbsolute"
d302 8
a309 1
    fun isRelative x = raise Unimplemented "isRelative"
a312 1
    fun concat x = raise Unimplemented "concat"
d314 12
a325 1
  end
@


1.1
log
@new unit
@
text
@d8 4
a11 1
 * $Log$
d38 1
d75 20
a94 8
    fun toString {isAbs = false, vol = vol, arcs = ""::_} = raise Path
      | toString {isAbs = _,     vol = "",  arcs = _} = raise Path
      | toString {isAbs, vol,arcs} =
          let
            val path= if isAbs then "/" else ""
          in
            List.foldl (fn (arc,path) => path^arc) path arcs
          end
d113 2
a114 1
        val e = size s - 1
d118 1
a118 1
        , file = String.substring (s, n, e-n)
d124 3
a126 1
    fun joinDirFile {dir, file} = dir ^ (String.str dirSeparator) ^ file
a182 1
      | joinBaseExt {base, ext = SOME ""} = base
@
