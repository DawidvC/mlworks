head	1.12;
access;
symbols
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.12.1.1.1.1.1
	MLWorks_workspace_97:1.12.3
	MLWorks_dt_wizard:1.12.2
	MLWorks_11c0_1997_09_09:1.12.1.1.1.1
	MLWorks_10r3:1.12.1.1.3
	MLWorks_10r2_551:1.12.1.1.2
	MLWorks_11:1.12.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.1.1
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.12.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.12.1
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.3.1.1
	MLWorks_gui_1996_12_18:1.11.4
	MLWorks_1_0_Win32_1996_12_17:1.11.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.11.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.11.1.1
	MLWorks_1_0_Irix_1996_11_28:1.11.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.11.2
	MLWorks_1_0_Unix_1996_11_14:1.11.1
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.12
date	97.03.06.17.53.36;	author jont;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.11.04.15.31.41;	author jont;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1
	1.11.4.1;
next	1.10;

1.10
date	96.10.29.19.00.31;	author io;	state Exp;
branches;
next	1.9;

1.9
date	96.05.21.11.32.10;	author stephenb;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1;
next	1.8;

1.8
date	96.04.30.14.15.42;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.04.18.15.25.30;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.03.27.15.18.03;	author stephenb;	state Exp;
branches;
next	1.5;

1.5
date	95.04.20.15.52.08;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.03.06.19.19.05;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.03.06.16.38.39;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.02.28.14.18.01;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.01.25.17.14.09;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.42.42;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.35.49;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.54.53;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.11.14.13.23.15;	author hope;	state Exp;
branches
	1.11.1.1.1.1;
next	;

1.11.1.1.1.1
date	96.11.28.15.33.47;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.11.22.18.40.17;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.12.17.18.19.17;	author hope;	state Exp;
branches
	1.11.3.1.1.1;
next	;

1.11.3.1.1.1
date	97.02.24.12.13.37;	author hope;	state Exp;
branches;
next	;

1.11.4.1
date	96.12.18.10.14.41;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	97.05.12.10.52.51;	author hope;	state Exp;
branches
	1.12.1.1.1.1
	1.12.1.1.2.1
	1.12.1.1.3.1;
next	;

1.12.1.1.1.1
date	97.07.28.18.35.04;	author daveb;	state Exp;
branches
	1.12.1.1.1.1.1.1;
next	;

1.12.1.1.1.1.1.1
date	97.10.07.12.00.46;	author jkbrook;	state Exp;
branches;
next	;

1.12.1.1.2.1
date	97.09.08.17.27.49;	author daveb;	state Exp;
branches;
next	;

1.12.1.1.3.1
date	97.09.09.14.24.57;	author daveb;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.10.19.43.45;	author brucem;	state Exp;
branches;
next	;

1.12.3.1
date	97.09.11.21.11.11;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
The OS.Pathname structure from the basis.
@


1.12
log
@[Bug #1938]
Remove __pre_basis from require list
@
text
@(*  FILE PATH NAME MANIPULATION 
 *
 *  Copyright (C) 1994 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is the definition from the revised standard basis.
 *
 *  Assumes that the arcs in an exploded path are in the same order as in
 *  the unexploded path; that if a path ends in a trailing "/" then the last
 *  component of the exploded path is empty (as opposed to stopping with the
 *  last directory), and that {explode,implode,split,make}Path don't check for
 *  validity.
 *  getParent "/foo" = "/" and getParent "foo" raises Path (it could instead
 *  return "..").
 *  mkCanonical "/../foo" = "/foo"
 *  extension of a name with a trailing "." is NOEXT, and the "." is included
 *  in the name (as in "..").
 *  Arcs may be no longer than 255 characters, and may not include nulls.
 *  mkRelative always treats the second argument as specifying a directory.
 *
 *  Possibly we should have an isDirName predicate, and require that the
 *  second arguments to mkRelative and mkAbsolute, and the argument to
 *  getParent, should be dirNames.  If so, we should probably have a
 *  mkDirName function as well, which adds a trailing separator if needed.
 *  In fact this might be useful anyway.
 *
 *  Revision Log
 *  ------------
 *  $Log: _unixpath.sml,v $
 * Revision 1.11  1996/11/04  15:31:41  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.10  1996/10/29  19:00:31  io
 * moving String from toplevel
 *
 * Revision 1.9  1996/05/21  11:32:10  stephenb
 * Change OS_PATH back to PATH since it is necessary to use the old
 * path implementation (PATH) and the new one (OS_PATH) concurrently
 * for a while.
 *
 * Revision 1.8  1996/04/30  14:15:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.7  1996/04/18  15:25:30  jont
 * initbasis moves to basis
 *
 * Revision 1.6  1996/03/27  15:18:03  stephenb
 * Name change required by the latest version of the basis: PATH -> OS_PATH
 *
 * Revision 1.5  1995/04/20  15:52:08  daveb
 * filesys and path moved from utils to initbasis.
 *
 * Revision 1.4  1995/03/06  19:19:05  daveb
 * Removed redundant strip_separators function.
 *
 * Revision 1.3  1995/03/06  16:38:39  daveb
 * Removed the "last" component from exploded paths, and replaced
 * splitPath with splitExt and splitLast.
 *
 * Revision 1.2  1995/02/28  14:18:01  daveb
 * Removed suffix function.
 *
 * Revision 1.1  1995/01/25  17:14:09  daveb
 * new unit
 * The OS.Pathname structure from the basis.
 *
 *)


require "../basis/path";
require "^.basis.__string";
require "^.basis.__list";


functor UnixPath (
): PATH =
struct
  datatype path_root = REL | ABS of string

  exception Path

  val parent = ".."
  val current = "."

  (* local *) val separator = #"/"
  (* local *) val root_str = #"/"

  (* local *) val ordsep = ord separator
  (* local *) val dot = #"."

  fun implodePath {root, arcs} =
    let
      val first =
        case root
        of REL => ""
        |  ABS s => s

      fun separate_arcs [] = []
      |   separate_arcs [arc] = [arc]
      |   separate_arcs (arc::arcs) =
	arc :: (str separator) :: separate_arcs arcs
    in
      case concat (first :: separate_arcs arcs)
      of "" => current
      |  s => s
    end

  fun isValidRoot "/" = true
  |   isValidRoot _ = false

  (* forall is a local function that returns true if p holds for every
     character in s. *)
  fun forall (p, s) =
    let
      fun scan ~1 = true
      |   scan i =
	p (String.sub(s, i)) andalso scan (i-1)
    in
      scan (size s - 1)
    end

  fun isValidArc s =
    size s < 256 andalso
    forall (fn x => x <> #"\000" andalso x <> separator, s)

  fun isAbsolute "" = false
  |   isAbsolute s = String.sub(s, 0)= root_str

  fun isRelative s = not (isAbsolute s)

  (* scanr is a local function that finds the first occurrence of ch in s,
     scanning from right to left. *)
  fun scanr (s, ch, ~1) =
    NONE
  |   scanr (s, ch, n) =
    if ch = String.sub (s, n) then
      SOME n
    else
      scanr (s, ch, n-1)

  (* find_last is a local function that returns the last arc of s, together
     with the index of the separator. *)
  fun find_last s =
    case scanr (s, separator, size s - 1)
    of SOME n =>
      (substring (s, n + 1, size s - n - 1), n)
    |  NONE =>
      (s, ~1)

  fun explodePath s =
    let
      val root = if isAbsolute s then ABS (str root_str) else REL

      fun scan_arcs (l, n) =
        case scanr (s, separator, n)
        of SOME 0 =>
          substring (s, 1, n) :: l
        |  SOME n' =>
          scan_arcs
            (substring (s, n' + 1, n - n') :: l,
             n' - 1)
        |  NONE => 
          substring (s, 0, n + 1) :: l

      val arcs =
	if s = "" orelse s = "/" then
	  []
	else
	  scan_arcs ([], size s - 1)
    in
      {root = root, arcs = arcs}
    end

  fun isValidPath s =
    let val {arcs, ...} = explodePath s
    in List.all isValidArc arcs
    end

  fun root s = if isAbsolute s then ABS (str root_str) else REL

  fun getParent s =
    case (explodePath s)
    of {root=REL, arcs=[arc]} =>
      raise Path
    |  {root, arcs} =>
      let
        fun prune [] = raise Path
          | prune [x] = []
          | prune (x::r) = x::(prune r)
      in
        implodePath {root=root, arcs=prune arcs}
      end

  fun mkCanonical s =
    let
      val {root, arcs} = explodePath s

      (* canon takes a list of arcs in reverse order, a count of the parent
	 arcs encountered and yet to be discharged, and a result list. *)
      fun canon ([], 0, result) = result
      |   canon ([], n, result) =
	(* n > 0 => need parent arcs at the beginning, unless the path is
	   absolute *)
	(case root
	 of REL => canon ([], n-1, parent :: result)
	 |  ABS _ => result)
      |   canon ("" :: arcs, level, result) =
	(* ignore empty arcs *)
	canon (arcs, level, result)
      |   canon ("." :: arcs, level, result) =
	(* ignore current arcs *)
	canon (arcs, level, result)
      |   canon (".." :: arcs, level, result) =
	(* parent arc => increase count *)
	canon (arcs, level + 1, result)
      |   canon (arc :: arcs, 0, result) =
	(* a real arc => add to result *)
	canon (arcs, 0, arc :: result)
      |   canon (_ :: arcs, n, result) =
	(* n > 0 => this arc is overridden by a parent arc *)
	canon (arcs, n-1, result)

      val canon_list = canon (rev arcs, 0, [])

    in
      implodePath {root=root, arcs=canon_list}
    end

  local
    (* join concatenates two paths, inserting a separator if necessary. *)
    fun join ("", s2) = s2
    |   join (s1, s2) =
      (* Assumes that s2 is relative *)
      if String.sub (s1, size s1-1) = separator then
	s1 ^ s2
      else 
	s1 ^ (str separator) ^ s2

    (* diff finds the relative path from a directory to another file. *)
    fun diff (s1, s2) =
      (* s1 and s2 are both absolute.  s2 is a directory. *)
      let
	val canon1 = mkCanonical s1
	val canon2 = mkCanonical s2

	val {arcs = arcs1, ...} = explodePath canon1
	val {arcs = arcs2, ...} = explodePath canon2

	fun strip_common_prefix (l, []:string list) = (l, [])
	|   strip_common_prefix ([], l) = ([], l)
	|   strip_common_prefix (l1 as h1::t1, l2 as h2::t2) =
	  if h1 = h2 then
	    strip_common_prefix (t1, t2)
	  else
	    (l1, l2)

	val (arcs1', arcs2') = strip_common_prefix (arcs1, arcs2)

	fun mkRel ([], result) = result
	|   mkRel (_::t, result) = mkRel (t, parent :: result)

	val arcs = mkRel (arcs1', arcs2')
      in
	implodePath {root = REL, arcs = arcs}
      end

  in
    fun concatPath (s1, s2) =
      if isRelative s2 then
        join (s1, s2)
      else
        raise Path

    fun mkAbsolute (s1, s2) =
      if isAbsolute s2 then
        if isAbsolute s1 then
	  s1
        else
	  join (s2, s1)
      else
        raise Path

    fun mkRelative (s1, s2) =
      if isAbsolute s2 then
        if isAbsolute s1 then
	  diff (s2, s1)
        else
	  s1
      else
        raise Path

    fun addLast {dir, last} = join (dir, last)
  end

  datatype path_ext = NOEXT | EXT of string

  fun splitLast s =
    let
      val (last, n1) = find_last s

      val dir =
	case n1
	of ~1 => ""
	|  0 => "/"
	|  _ => substring (s, 0, n1)
    in
      {dir = dir, last = last}
    end
    
  val dir = (#dir o splitLast)
  val last = #1 o find_last

  fun find_ext s =
    case scanr (s, dot, size s - 1)
    of SOME n =>
	if n = size s - 1 then
	  (* File names ending in a . have no extension.  E.g. "..". *)
	  (NOEXT, size s)
	else
	  let
	    (* Check that the . occurs after the final separator. *)
	    val ok =
	      case scanr (s, separator, size s - 1)
	      of SOME n' => n' < n 
	      |  NONE => true
	  in
	    if ok then
              (EXT (substring (s, n + 1, size s - n - 1)), n)
	    else
	      (NOEXT, size s)
	  end
    |  NONE => (NOEXT, size s)

  fun splitExt s =
    let
      val (ext, n2) = find_ext s

      val name = substring (s, 0, n2)
    in
      {name = name, ext = ext}
    end
    
  val name = (#name o splitExt)
  val ext = #1 o find_ext

  fun addExt {name, ext=NOEXT} = name
  |   addExt {name, ext=EXT ext} = name ^ "." ^ ext
end;
@


1.12.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a30 4
 * Revision 1.12  1997/03/06  17:53:36  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.12.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a30 4
 * Revision 1.12  1997/03/06  17:53:36  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a30 4
 * Revision 1.12  1997/03/06  17:53:36  jont
 * [Bug #1938]
 * Remove __pre_basis from require list
 *
@


1.12.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a30 3
 * Revision 1.12.1.1  1997/05/12  10:52:51  hope
 * branched from 1.12
 *
@


1.12.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a30 3
 * Revision 1.12.1.1  1997/05/12  10:52:51  hope
 * branched from 1.12
 *
@


1.12.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a30 3
 * Revision 1.12.1.1  1997/05/12  10:52:51  hope
 * branched from 1.12
 *
@


1.12.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a30 3
 * Revision 1.12.1.1.1.1  1997/07/28  18:35:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d31 4
a77 1
require "^.basis.__pre_basis";
@


1.11.4.1
log
@branched from 1.11
@
text
@a30 4
 * Revision 1.11  1996/11/04  15:31:41  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.11.3.1
log
@branched from 1.11
@
text
@a30 4
 * Revision 1.11  1996/11/04  15:31:41  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.11.3.1.1.1
log
@branched from 1.11.3.1
@
text
@a30 3
 * Revision 1.11.3.1  1996/12/17  18:19:17  hope
 * branched from 1.11
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a30 4
 * Revision 1.11  1996/11/04  15:31:41  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a30 4
 * Revision 1.11  1996/11/04  15:31:41  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
@


1.11.1.1.1.1
log
@branched from 1.11.1.1
@
text
@a30 3
 * Revision 1.11.1.1  1996/11/14  13:23:15  hope
 * branched from 1.11
 *
@


1.10
log
@moving String from toplevel
@
text
@d31 3
d119 1
a119 1
	p (unsafe_string_char_sub (s, i)) andalso scan (i-1)
d129 1
a129 1
  |   isAbsolute s = unsafe_string_char_sub (s, 0)= root_str
@


1.9
log
@Change OS_PATH back to PATH since it is necessary to use the old
path implementation (PATH) and the new one (OS_PATH) concurrently
for a while.
@
text
@d31 5
d69 4
a72 1
require "../utils/lists";
a74 1
  structure Lists: LISTS
d84 2
a85 2
  (* local *) val separator = "/"
  (* local *) val root_str = "/"
d87 2
a88 2
  (* local *) val ordsep = String.ord separator
  (* local *) val orddot = String.ord "."
d100 1
a100 1
	arc :: separator :: separate_arcs arcs
d102 1
a102 1
      case String.implode (first :: separate_arcs arcs)
d116 1
a116 1
	p (String.ordof (s, i)) andalso scan (i-1)
d123 1
a123 1
    forall (fn x => x <> 0 andalso x <> ordsep, s)
d126 1
a126 1
  |   isAbsolute s = String.ord s = String.ord root_str
d133 1
a133 1
    MLWorks.Option.NONE
d135 2
a136 2
    if ch = MLWorks.String.ordof (s, n) then
      MLWorks.Option.SOME n
d143 4
a146 4
    case scanr (s, ordsep, size s - 1)
    of MLWorks.Option.SOME n =>
      (MLWorks.String.substring (s, n + 1, size s - n - 1), n)
    |  MLWorks.Option.NONE =>
d151 1
a151 1
      val root = if isAbsolute s then ABS root_str else REL
d154 4
a157 4
        case scanr (s, ordsep, n)
        of MLWorks.Option.SOME 0 =>
          MLWorks.String.substring (s, 1, n) :: l
        |  MLWorks.Option.SOME n' =>
d159 1
a159 1
            (MLWorks.String.substring (s, n' + 1, n - n') :: l,
d161 2
a162 2
        |  MLWorks.Option.NONE => 
          MLWorks.String.substring (s, 0, n + 1) :: l
d175 1
a175 1
    in Lists.forall isValidArc arcs
d178 1
a178 1
  fun root s = if isAbsolute s then ABS root_str else REL
d233 1
a233 1
      if MLWorks.String.substring (s1, size s1 - 1, 1) = separator then
d236 1
a236 1
	s1 ^ separator ^ s2
d304 1
a304 1
	|  _ => MLWorks.String.substring (s, 0, n1)
d313 2
a314 2
    case scanr (s, orddot, size s - 1)
    of MLWorks.Option.SOME n =>
d322 3
a324 3
	      case scanr (s, ordsep, size s - 1)
	      of MLWorks.Option.SOME n' => n' < n 
	      |  MLWorks.Option.NONE => true
d327 1
a327 1
              (EXT (MLWorks.String.substring (s, n + 1, size s - n - 1)), n)
d331 1
a331 1
    |  MLWorks.Option.NONE => (NOEXT, size s)
d337 1
a337 1
      val name = MLWorks.String.substring (s, 0, n2)
@


1.9.3.1
log
@branched from 1.9
@
text
@a30 5
 * Revision 1.9  1996/05/21  11:32:10  stephenb
 * Change OS_PATH back to PATH since it is necessary to use the old
 * path implementation (PATH) and the new one (OS_PATH) concurrently
 * for a while.
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a30 5
 * Revision 1.9  1996/05/21  11:32:10  stephenb
 * Change OS_PATH back to PATH since it is necessary to use the old
 * path implementation (PATH) and the new one (OS_PATH) concurrently
 * for a while.
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a30 5
 * Revision 1.9  1996/05/21  11:32:10  stephenb
 * Change OS_PATH back to PATH since it is necessary to use the old
 * path implementation (PATH) and the new one (OS_PATH) concurrently
 * for a while.
 *
@


1.8
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d31 6
d68 1
a68 1
): OS_PATH =
@


1.7
log
@initbasis moves to basis
@
text
@d31 3
d74 2
a75 2
  (* local *) val ordsep = ord separator
  (* local *) val orddot = ord "."
d89 1
a89 1
      case implode (first :: separate_arcs arcs)
d113 1
a113 1
  |   isAbsolute s = ord s = ord root_str
@


1.6
log
@Name change required by the latest version of the basis: PATH -> OS_PATH
@
text
@d31 3
d37 13
a49 14
# Revision 1.4  1995/03/06  19:19:05  daveb
# Removed redundant strip_separators function.
#
# Revision 1.3  1995/03/06  16:38:39  daveb
# Removed the "last" component from exploded paths, and replaced
# splitPath with splitExt and splitLast.
#
# Revision 1.2  1995/02/28  14:18:01  daveb
# Removed suffix function.
#
# Revision 1.1  1995/01/25  17:14:09  daveb
# new unit
# The OS.Pathname structure from the basis.
#
d54 1
a54 1
require "../initbasis/path";
@


1.5
log
@filesys and path moved from utils to initbasis.
@
text
@d31 3
d57 1
a57 1
): PATH =
@


1.4
log
@Removed redundant strip_separators function.
@
text
@d31 3
d49 1
a49 1
require "../utils/path";
@


1.3
log
@Removed the "last" component from exploded paths, and replaced
splitPath with splitExt and splitLast.
@
text
@d31 4
a213 6
    fun strip_separators (s, i) =
      if MLWorks.String.ordof (s, i) = ordsep then
	strip_separators (s, i+1)
      else
	MLWorks.String.substring (s, i, size s - i)

d235 1
a235 1
	|   mkRel (_::t, result) = mkRel (t, ".." :: result)
@


1.2
log
@Removed suffix function.
@
text
@d10 3
a12 3
 *  the unexploded path; that if the last arc is empty then the "last"
 *  component of an exploded path is empty (as opposed to making it the last
 *  directory), and that {explode,implode,split,make}Path don't check for
d31 3
d62 1
a62 1
  fun implodePath {root, arcs, last} =
d69 4
a72 3
      fun separate_arcs ([], last) = last
      |   separate_arcs (arc::arcs, last) =
	arc :: separator :: separate_arcs (arcs, last)
d74 3
a76 1
      implode (first :: separate_arcs (arcs, [last]))
d118 2
a119 1
    | MLWorks.Option.NONE => (s, ~1)
a124 2
      val (last, n) = find_last s

d137 4
a140 1
        if n <= 0 then [] else scan_arcs ([], n - 1)
d142 1
a142 1
      {root = root, arcs = arcs, last = last}
d152 12
a163 13
  val last = #1 o find_last

  fun getParent s = (case (explodePath s)
       of {root, arcs, last=""} => let
            fun prune [] = raise Path
              | prune [x] = []
              | prune (x::r) = x::(prune r)
            in
              implodePath {root=root, arcs=prune arcs, last=""}
            end
        | {root=REL, arcs=[], last} => raise Path
        | {root, arcs, last} => implodePath {root=root, arcs=arcs, last=""}
      (* end case *))
a164 2
  datatype path_ext = NOEXT | EXT of string

d167 1
a167 6
      val {root, arcs, last} = explodePath s

      val first =
        case root
        of REL => ""
        |  ABS _ => root_str
d176 1
a176 1
	 of REL => canon ([], n-1, "../" :: result)
d188 2
a189 2
	(* a real arc => add to result, with separator *)
	canon (arcs, 0, arc :: separator :: result)
d194 1
a194 5
      val canon_list =
        case last
        of ".." => canon (rev arcs, 1, [])
        |  "." => canon (rev arcs, 0, [""])
        |  _ => canon (rev arcs, 0, [last])
d197 1
a197 3
      case implode (first :: canon_list)
      of "" => "."
      | s => s
d223 2
a224 2
	val {arcs = arcs1, last = last1, ...} = explodePath s1
	val {arcs = arcs2, last = last2, ...} = explodePath s2
d236 1
a236 5
	fun mkRel ([], result) =
	  if last1 = "" then
	    result
	  else
	    ".." :: result
d239 1
a239 10
	val arcs =
	  case (arcs1', arcs2')
	  of ([], []) => mkRel ([], [])
	  |  ([], l as h::t) =>
	    if last1 = h then
	      (* catches cases like diff ("/bar", "/bar/foo"). *)
	      t
	    else
	      mkRel ([], l)
	  |  _ => mkRel (arcs1', arcs2')
d241 1
a241 1
	implodePath {root = REL, arcs = arcs, last = last2}
d269 1
a269 2
    fun makePath {dir, name, ext = NOEXT} = join (dir, name)
    |   makePath {dir, name, ext = EXT ext} = join (dir, name) ^ "." ^ ext
d272 18
d311 1
a311 1
  fun splitPath s =
d313 1
a313 8
      val (last, n1) = find_last s

      val dir =
	case n1 of
	~1 => "" |
	_  => MLWorks.String.substring (s, 0, n1 + 1)

      val (ext, n2) = find_ext last
d315 1
a315 1
      val name = MLWorks.String.substring (last, 0, n2)
d317 1
a317 1
      {dir = dir, name = name, ext = ext}
d320 2
a321 8
  val dir = (#dir o splitPath)
  val name = (#name o splitPath)
  val ext = #1 o find_ext (* #ext o splitPath *)

  fun base s =
    case find_ext s of
    (NOEXT, _) => s |
    (EXT _, n) => MLWorks.String.substring (s, 0, n)
d323 2
@


1.1
log
@new unit
The OS.Pathname structure from the basis.
@
text
@d30 5
a34 1
 *  $Log$
a290 93

  fun suffix (s1, s2) =
    (* suffix tries a character by character comparison of the two paths.
       It then checks whether the suffix of the longer string contains
       any parent arcs.  If it doesn't, the result of the quick check can
       be trusted.  Otherwise it canonicalises the two strings and checks
       again. *)
    let
      val len1 = size s1
      val len2 = size s2

      fun skip_separators n =
        let
	  fun skip i =
	    if i = len1 then
	      i
	    else if MLWorks.String.ordof (s1, i) = ordsep then
	      skip (i + 1)
	    else
	      i
        in
	  skip n
        end 

      (* canonical (s, i) checks that substring (s, i, size s - i) is
	 canonical, i.e. that it contains no occurrences of the parent arc.
	 This tells us whether we can trust the result of quick_check (). *)
      fun canonical (s, i, len) =
	if i = len then
	  true
	else if String.ordof (s, i) = ordsep then
	  if i+2 >= len then
	    true
	  else if String.ordof (s, i + 1) = orddot andalso
	          String.ordof (s, i + 2) = orddot andalso
		  (i+3 = len orelse String.ordof (s, i + 3) = ordsep) then
	    false
	  else
	    canonical (s, i + 3, len)
	else
	  canonical (s, i + 1, len)

      fun full_check () =
	let
	  val canon1 = mkCanonical s1
	  val canon2 = mkCanonical s2
	  val len1 = size canon1
	  val len2 = size canon2

          fun check' i =
	    if i = len2 then
	      if i = len1 then
	        MLWorks.Option.SOME i
	      else if (String.ordof (canon1, i) = ordsep orelse
	               String.ordof (canon2, i - 1) = ordsep) then
	        MLWorks.Option.SOME (skip_separators i)
	      else
	        MLWorks.Option.NONE
	    else if i = len1 then
	      MLWorks.Option.NONE
	    else if String.ordof (canon1, i) = String.ordof (canon2, i) then
	      check' (i + 1)
	    else
	      MLWorks.Option.NONE
	in
	  check' 0
	end

      fun quick_check i =
	if i = len2 then
	  if i = len1 then
	    MLWorks.Option.SOME i
	  else if (String.ordof (s1, i) = ordsep orelse
	           String.ordof (s1, i - 1) = ordsep) andalso
	          canonical (s1, i - 1, len1) then
	    MLWorks.Option.SOME (skip_separators i)
	  else
	    full_check ()
	else if i = len1 then
	  if canonical (s2, i, len2) then
	    MLWorks.Option.NONE
	  else
	    full_check ()
	else if String.ordof (s1, i) = String.ordof (s2, i) then
	  quick_check (i + 1)
	else
	  full_check ()
    in
      if isRelative s1 orelse isRelative s2 then
	raise Path
      else
        quick_check 0
    end
@
