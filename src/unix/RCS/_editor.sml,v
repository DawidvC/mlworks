head	1.40;
access;
symbols
	MLW_daveb_inline_1_4_99:1.40.1
	MLWorks_21c0_1999_03_25:1.40
	MLWorks_20c1_1998_08_20:1.39
	MLWorks_20c0_1998_08_04:1.39
	MLWorks_20b2c2_1998_06_19:1.39
	MLWorks_20b2_Windows_1998_06_12:1.39
	MLWorks_20b1c1_1998_05_07:1.39
	MLWorks_20b0_1998_04_07:1.39
	MLWorks_20b0_1998_03_20:1.38
	MLWorks_20m2_1998_02_16:1.38
	MLWorks_20m1_1997_10_23:1.37
	MLWorks_11r1:1.35.1.1.1.1.1
	MLWorks_workspace_97:1.36.2
	MLWorks_dt_wizard:1.36.1
	MLWorks_11c0_1997_09_09:1.35.1.1.1.1
	MLWorks_10r3:1.35.1.1.3
	MLWorks_10r2_551:1.35.1.1.2
	MLWorks_11:1.35.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.35.1.1
	MLWorks_20m0_1997_06_20:1.36
	MLWorks_1_0_r2c2_1997_06_14:1.35.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.35.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.35.1
	MLWorks_BugFix_1997_04_24:1.35
	MLWorks_1_0_r2_Win32_1997_04_11:1.35
	MLWorks_1_0_r2_Unix_1997_04_04:1.35
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.34.3.1.1
	MLWorks_gui_1996_12_18:1.34.4
	MLWorks_1_0_Win32_1996_12_17:1.34.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.34.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.34.1.1
	MLWorks_1_0_Irix_1996_11_28:1.34.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.34.2
	MLWorks_1_0_Unix_1996_11_14:1.34.1
	MLWorks_Open_Beta2_1996_10_11:1.31.3
	MLWorks_License_dev:1.31.2
	MLWorks_1_open_beta_1996_09_13:1.31.1
	MLWorks_Open_Beta_1996_08_22:1.31
	MLWorks_Beta_1996_07_02:1.28
	MLWorks_Beta_1996_06_07:1.27
	MLWorks_Beta_1996_06_06:1.27
	MLWorks_Beta_1996_06_05:1.27
	MLWorks_Beta_1996_06_03:1.27
	MLWorks_Beta_1996_05_31:1.27
	MLWorks_Beta_1996_05_30:1.27;
locks; strict;
comment	@ * @;


1.40
date	99.03.04.09.56.21;	author johnh;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	98.03.23.14.36.50;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	97.10.31.10.13.21;	author johnh;	state Exp;
branches;
next	1.37;

1.37
date	97.09.18.16.20.13;	author brucem;	state Exp;
branches;
next	1.36;

1.36
date	97.05.02.16.59.11;	author jont;	state Exp;
branches
	1.36.1.1
	1.36.2.1;
next	1.35;

1.35
date	97.03.13.19.14.30;	author brianm;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	96.11.06.12.50.03;	author matthew;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1
	1.34.4.1;
next	1.33;

1.33
date	96.11.06.10.25.34;	author stephenb;	state Exp;
branches;
next	1.32;

1.32
date	96.10.09.14.52.13;	author io;	state Exp;
branches;
next	1.31;

1.31
date	96.08.11.18.41.50;	author brianm;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1;
next	1.30;

1.30
date	96.08.09.12.55.31;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.08.05.15.41.59;	author stephenb;	state Exp;
branches;
next	1.28;

1.28
date	96.06.15.16.33.29;	author brianm;	state Exp;
branches;
next	1.27;

1.27
date	96.05.15.10.59.08;	author stephenb;	state Exp;
branches;
next	1.26;

1.26
date	96.05.03.15.44.25;	author stephenb;	state Exp;
branches;
next	1.25;

1.25
date	96.05.01.09.52.55;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.04.29.15.32.46;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.03.26.13.23.45;	author stephenb;	state Exp;
branches;
next	1.22;

1.22
date	96.01.29.16.59.28;	author stephenb;	state Exp;
branches;
next	1.21;

1.21
date	96.01.26.12.00.37;	author stephenb;	state Exp;
branches;
next	1.20;

1.20
date	96.01.19.16.54.55;	author stephenb;	state Exp;
branches;
next	1.19;

1.19
date	95.10.23.12.51.08;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.10.20.16.43.48;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	95.10.02.13.23.44;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.01.13.17.14.02;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	94.12.08.18.04.03;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	94.08.03.09.24.12;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	94.08.02.16.26.01;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	94.07.29.16.19.00;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.08.31.11.29.18;	author matthew;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	93.08.27.17.20.41;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.08.25.15.06.30;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.06.04.14.12.35;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	93.05.18.16.33.29;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	93.04.22.13.00.22;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	93.04.14.15.23.51;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.04.08.17.42.49;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	93.04.08.15.00.45;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	93.03.23.18.35.09;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	93.03.10.17.24.30;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	93.08.31.11.29.18;	author jont;	state Exp;
branches;
next	;

1.31.1.1
date	96.09.13.11.42.35;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.10.07.16.35.42;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.10.17.11.54.47;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	96.11.14.13.23.08;	author hope;	state Exp;
branches
	1.34.1.1.1.1;
next	;

1.34.1.1.1.1
date	96.11.28.15.33.37;	author hope;	state Exp;
branches;
next	;

1.34.2.1
date	96.11.22.18.40.09;	author hope;	state Exp;
branches;
next	;

1.34.3.1
date	96.12.17.18.19.11;	author hope;	state Exp;
branches
	1.34.3.1.1.1;
next	;

1.34.3.1.1.1
date	97.02.24.12.13.29;	author hope;	state Exp;
branches;
next	;

1.34.4.1
date	96.12.18.10.14.34;	author hope;	state Exp;
branches;
next	;

1.35.1.1
date	97.05.12.10.52.44;	author hope;	state Exp;
branches
	1.35.1.1.1.1
	1.35.1.1.2.1
	1.35.1.1.3.1;
next	;

1.35.1.1.1.1
date	97.07.28.18.34.54;	author daveb;	state Exp;
branches
	1.35.1.1.1.1.1.1;
next	;

1.35.1.1.1.1.1.1
date	97.10.07.12.00.39;	author jkbrook;	state Exp;
branches;
next	;

1.35.1.1.2.1
date	97.09.08.17.27.43;	author daveb;	state Exp;
branches;
next	;

1.35.1.1.3.1
date	97.09.09.14.24.47;	author daveb;	state Exp;
branches;
next	;

1.36.1.1
date	97.09.10.19.43.39;	author brucem;	state Exp;
branches;
next	;

1.36.2.1
date	97.09.11.21.11.04;	author daveb;	state Exp;
branches;
next	;

1.40.1.1
date	99.04.01.18.09.14;	author daveb;	state Exp;
branches;
next	;


desc
@Implementation of interface to external editors
@


1.40
log
@[Bug #30286]
Second arg to exec commands no longer need to include command name.
@
text
@(* _editor.sml the functor *)
(*
$Log: _editor.sml,v $
 * Revision 1.39  1998/03/23  14:36:50  jont
 * [Bug #30090]
 * Remove use of MLWorks.IO
 *
 * Revision 1.38  1997/10/31  10:13:21  johnh
 * [Bug #302333]
 * Change editor interface.
 *
 * Revision 1.37  1997/09/18  16:20:13  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.36  1997/05/02  16:59:11  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.35  1997/03/13  19:14:30  brianm
 * Bug fix for Bug ID 1803 - problems with empty dialog types.
 *
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.33  1996/11/06  10:25:34  stephenb
 * [Bug #1719]
 * emacs_dialog: change the location of the socket from $HOME/.mlworks-server
 * to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 * to avoid problems with creating sockets on an Andrew file system.
 *
 * Revision 1.32  1996/10/09  14:52:13  io
 * moving String from toplevel
 *
 * Revision 1.31  1996/08/11  18:41:50  brianm
 * [Bug #1528]
 * Minor correction to custom_server (& emacs_server in Unix).
 *
 * Revision 1.30  1996/08/09  12:55:31  daveb
 * [Bug #1536]
 * Word8Vector.vector no longer shares with string.
 *
 * Revision 1.29  1996/08/05  15:41:59  stephenb
 * Replace any functions in OldOs with ones from the new basis
 * and subsequently remove any reference to OldOs.
 *
 * Revision 1.28  1996/06/15  16:33:29  brianm
 * Modifications to add custom editor interface ...
 *
 * Revision 1.27  1996/05/15  10:59:08  stephenb
 * Update wrt UnixOS.SysErr -> UnixOS.Error.SysError change.
 *
 * Revision 1.26  1996/05/03  15:44:25  stephenb
 * UnixOS.close has moved to UnixOS.IO.close in line with POSIXification.
 *
 * Revision 1.25  1996/05/01  09:52:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.24  1996/04/29  15:32:46  matthew
 * removing MLWorks.Integer
 *
 * Revision 1.23  1996/03/26  13:23:45  stephenb
 * Update wrt to Unix->SysErr exception name change.
 *
 * Revision 1.22  1996/01/29  16:59:28  stephenb
 * unix.c reorganisation: change vfork_XXX to fork_XXX since vfork
 * isn't important as far as the user is concerned, all they are
 * after is a cheap fork and exec.
 *
Revision 1.21  1996/01/26  12:00:37  stephenb
Fix emacs server.

Revision 1.20  1996/01/19  16:54:55  stephenb
OS reorganisation: Since OS specific stuff is no longer
in the pervasive library, the editor functor needs the
new UnixOS structure as a parameter.

Revision 1.19  1995/10/23  12:51:08  daveb
Changed name of e-lisp highlight function to mlworks-highlight.

Revision 1.18  1995/10/20  16:43:48  daveb
Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.

Revision 1.17  1995/10/02  13:23:44  daveb
Made emacs highlight errors.
Removed next_error and no_more_errors.

Revision 1.16  1995/01/13  17:14:02  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.15  1994/12/08  18:04:03  jont
Move OS specific stuff into a system link directory

Revision 1.14  1994/08/03  09:24:12  matthew
Reinstate call to makestring

Revision 1.13  1994/08/02  16:26:01  daveb
Added support for user-defined editors.

Revision 1.12  1994/07/29  16:19:00  daveb
Moved preferences into separate structure.

Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

Revision 1.10  1993/08/27  17:20:41  matthew
Added call to Unix.kill

Revision 1.9  1993/08/25  15:06:30  matthew
Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]

Revision 1.8  1993/06/04  14:12:35  daveb
Removed filename component of error result for edit functions.

Revision 1.7  1993/05/18  16:33:29  daveb
Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.

Revision 1.6  1993/04/22  13:00:22  richard
The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.

Revision 1.5  1993/04/14  15:23:51  jont
Added editing from location. Added a function to do next error from a list

Revision 1.4  1993/04/08  17:42:49  jont
Modify edit and edit_from_location to use the relevant editor

Revision 1.3  1993/04/08  15:00:45  jont
Added options parameter

Revision 1.2  1993/03/23  18:35:09  jont
Changed editor implementastion slightly.

Revision 1.1  1993/03/10  17:24:30  jont
Initial revision

Copyright (C) 1993 Harlequin Ltd
*)

require "^.basis.__int";
require "^.basis.__byte";
require "^.basis.__string";
require "^.basis.os";
require "^.main.preferences";
require "^.basics.location";
require "^.utils.crash";
require "^.editor.editor";
require "^.editor.custom";
require "^.utils.lists";
require "unixos";

functor Editor
  (structure Preferences: PREFERENCES
   structure Crash : CRASH
   structure Location : LOCATION
   structure OS : OS
   structure UnixOS : UNIXOS
   structure CustomEditor : CUSTOM_EDITOR
   structure Lists : LISTS
  ) : EDITOR =
struct
    structure Location = Location

    type preferences = Preferences.preferences

    fun null_fun () = ()

    fun show_int (i) =
        if i < 0 then "-" ^ Int.toString(~i) else Int.toString(i)

    val member   = Lists.member

    (* Locations etc. *)

    fun line_from_location(Location.UNKNOWN) = 0
      | line_from_location(Location.FILE _) = 0
      | line_from_location(Location.LINE(_, i)) = i
      | line_from_location(Location.POSITION(_, i, _)) = i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = i


    fun get_position_info (Location.EXTENT{s_line, s_col, e_line, e_col, ...}) =
        (s_line,s_col, e_line, e_col)

      | get_position_info (loc) = (line_from_location loc,0,~1,~1)


    (* Socket stuff *)


    (* Convert an integer into a two character string so that it can
     * be sent down a socket.  Probably should check that the 
     * pre-condition is satisified ...
     *
     * pre: i >= 0 /\ i <= 2^16
     *)
    fun marshal_int i = MLWorks.String.implode_char [i div 256, i mod 256]



    (* Write a string to the file descriptor which is attached to a socket.
     * As explained on page 279 of Unix Network Programming by Stevens,
     * just calling UnixOS.write(fd, msg, 0, len) would not guarantee
     * delivery of the whole message, generally due to kernel buffering.
     * Instead, you have to keep calling write until the whole string
     * has been sent.
     *)
    fun socket_write (fd, msg) =
      let
        val msg_len = size msg
	val vec = Byte.stringToBytes msg

        fun write (offset, len) =
          let val nwritten = UnixOS.write (fd , vec, offset, len)
	  in
            if nwritten < len then
              write (offset+nwritten, len-nwritten)
            else
              nwritten
          end
      in
        if write (0, msg_len) <> msg_len then
          raise UnixOS.Error.SysErr ("", NONE)
        else
          ()
      end


    (* Send a message down the file descriptor.  A message consists of a
     * two byte length followed by the string.
     *)
    fun socket_write_msg (fd, msg) =
      let val msg_len = size msg 
      in 
        socket_write (fd, marshal_int msg_len);
        socket_write (fd, msg)
      end



    (* Editor interfaces *)


    (* Argument Specifier Notation:
     * ============================
     *   %f =   filename
     *   %l =   %sl   = start line no.
     *   %c =   %sc   = start char no.
     *   %el =  end line no.
     *   %ec =  end char no.
     *   %%  =  % (percent)
     *)

    fun expand_args (fnm, st_l, st_c, e_l, e_c) =
        let fun trans(#"%" :: #"%" :: l, r) =
                  trans(l, "%" :: r)
              | trans(#"%" :: #"f" :: l, r) =
                  trans(l, fnm :: r)
              | trans(#"%" :: #"l" :: l, r) =
                  trans(l,show_int(st_l) :: r)
              | trans(#"%" :: #"s" :: #"l" :: l, r) =
                  trans(l,show_int(st_l) :: r)
              | trans(#"%" :: #"c" :: l, r) = trans(l,show_int(st_c) :: r)
              | trans(#"%" :: #"s" :: #"c" :: l, r) =
                  trans(l,show_int(st_c) :: r)
              | trans(#"%" :: #"e" :: #"l" :: l, r) =
                  trans(l,show_int(e_l) :: r)
              | trans(#"%" :: #"e" :: #"c" :: l, r) =
                  trans(l,show_int(e_c) :: r)
              | trans(c :: l, r) =
                  trans (l, (String.str c) :: r )
              | trans(_, r) =
                  String.concat (rev r) 

            fun doit str = trans(explode str,[])
        in
            doit
        end

    fun transEntry loc_details (server,commands) =
      let 
	val translate = expand_args loc_details
      in
        (server, map translate commands)
      end

    (* Emacs server & commands *)

    val standard_emacs_commands =
        let val find_file = "(find-file \"%f\")"
            val goto_line = "(goto-line %sl)"
            val fwd_char  = "(forward-char %sc)"
            val highlight = "(mlworks-highlight %sl %sc %el %ec)"
            val raise_win = "(raise-this-window)"

            val startup_cmds = [find_file, goto_line, fwd_char]

            val full_dialog  = [find_file, goto_line, fwd_char, highlight, raise_win]
        in
            CustomEditor.addConnectDialog ("Emacs", "Emacs", full_dialog);
            (startup_cmds,[highlight],[raise_win])
        end;


    (* Adding Vi command as a custom editor *)

    val _ = CustomEditor.addCommand ("Vi","xterm -name visual -e %f");


    (* Emacs Dialog support *)

    (* Keep this consistent with, the mechanism in the mlworks-server
     * <URI:hope://MLWsrc/emacs/etc/mlworks-server.c#init_socket_path>
     *)
    fun getSocketName ():string option =
      case OS.Process.getEnv "MLWORKS_SERVER_FILE" of
        SOME fileName => SOME fileName
      | NONE => 
          (case OS.Process.getEnv "USER" of
             SOME userName => SOME (concat ["/tmp/.", userName, "-mlworks-server"])
           | NONE => NONE)


    fun emacs_dialog (commands) =
        let val s   = UnixOS.socket (UnixOS.af_unix, UnixOS.sock_stream, 0)
            val cmd = concat ("(progn " :: (commands @@ [")"]))
        in
          case getSocketName () of
            SOME socketName => 
              ((UnixOS.connect (s, UnixOS.SOCKADDR_UNIX socketName);
                (*
                 * should check that the length of the message is less
                 * than the allowed maximum.
                 *)
                socket_write_msg (s, cmd);
                UnixOS.IO.close s;
                (NONE, null_fun)
              )
              handle
                UnixOS.Error.SysErr _ =>
                  (UnixOS.IO.close s;
                   (SOME "Unable to contact MLWorks Emacs server", null_fun)
                  ))
          | NONE =>
             (SOME "Unable to determine socket name, check MLWORKS_SERVER_FILE setting", null_fun)
        end
        handle
           UnixOS.Error.SysErr _ =>
              (SOME "Unable to contact MLWorks Emacs server", null_fun)

    fun xterm parsed_command =
      let
        val pid = 
          (UnixOS.fork_execvp
             ("xterm", ["-name", "visual", "-e"] @@ parsed_command))
      in
        (NONE,fn () =>
         UnixOS.kill (pid,9)
         handle UnixOS.Error.SysErr _ => ())
      end
      handle UnixOS.Error.SysErr _ =>
        (SOME ("Unable to launch xterm editor processes"),null_fun)


    fun do_command (command :: args) =
      (let val pid = UnixOS.fork_execvp (command, args)
       in
         (NONE,
          fn () =>
             (UnixOS.kill (pid,9)
                handle UnixOS.Error.SysErr _ => ()
             )
         )
       end
          handle UnixOS.Error.SysErr _ =>
             (SOME ("Unable to launch editor process"),null_fun)
      )

    |  do_command nil = (SOME "No editor command specified", null_fun)

    local
       val wsp = [ #" ", #"\t", #"\n" ]

       fun scan (c :: s, [], lst) =
           if member (c,wsp) then scan (s,[],lst)
           else scan (s,[String.str c],lst)

         | scan (c :: s, tok, lst) =
           if member (c,wsp) then scan (s,[],concat(rev tok)::lst)
           else scan (s,(String.str c)::tok,lst)

         | scan ([],[],lst)  = rev lst
         | scan ([],tok,lst) = rev (concat(rev tok) :: lst)
    in

       fun parse_command (string) = scan (explode string, [], [])

    end


    (* this function provides an external editor - by launching an editor
       each time it is needed - a `one-shot' editor.
    *)
    fun external_server extCmd (string, s_l, s_c, e_l, e_c) =
        let val translate = expand_args (string, s_l, s_c, e_l, e_c)
            val cmds      = parse_command (translate extCmd)
        in
            do_command ( cmds )
        end

    fun one_way_server customName loc_details = 
      let 
	val translate = expand_args loc_details
	val cmd = translate (CustomEditor.getCommandEntry customName)

	val cmd_result = 
	  if (cmd <> "") then do_command (parse_command cmd)
	  else (SOME "invalid choice for editor", null_fun)
      in
	cmd_result
      end

    fun two_way_server customName loc_details =
      let
	val (dialog_type, commands) = 
	  transEntry loc_details (CustomEditor.getDialogEntry customName)

	val (service, topic, commands) = 
	  case commands of 
	    s::t::cmds => (s,t,cmds)
	  | _ => ("","",commands)
      in
	case dialog_type of 
	  "Emacs" => emacs_dialog commands
	| _ => (SOME ("Unknown custom dialog type : " ^ dialog_type), null_fun)
      end

    fun edit
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, i) =
        case !editor of
          "External" =>
             external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)

        | "OneWay" =>
             one_way_server (!oneWayEditorName) (string, i, 0, ~1, ~1)

        | "TwoWay" =>
             two_way_server (!twoWayEditorName) (string, i, 0, ~1, ~1)

        | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")


    fun edit_from_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, location) =
        let val (s_l, s_c, e_l, e_c) = get_position_info location
        in
           case !editor of
             "External" =>
                 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)

           | "OneWay" =>
                 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

           | "TwoWay" =>
                 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end


    fun show_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, location) =
        let val (s_l, s_c, e_l, e_c) = get_position_info location
        in
           case !editor of
             "External" =>
                 (SOME("show location requires emacs"), null_fun)

           | "OneWay" =>
                 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

           | "TwoWay" =>
                 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end
end
@


1.40.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@d3 1
a3 5
$Log: _editor.sml,v $
 * Revision 1.40  1999/03/04  09:56:21  johnh
 * [Bug #30286]
 * Second arg to exec commands no longer need to include command name.
 *
@


1.39
log
@[Bug #30090]
Remove use of MLWorks.IO
@
text
@d1 508
a508 504
(* _editor.sml the functor *)
(*
$Log: _editor.sml,v $
 * Revision 1.38  1997/10/31  10:13:21  johnh
 * [Bug #302333]
 * Change editor interface.
 *
 * Revision 1.37  1997/09/18  16:20:13  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.36  1997/05/02  16:59:11  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.35  1997/03/13  19:14:30  brianm
 * Bug fix for Bug ID 1803 - problems with empty dialog types.
 *
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.33  1996/11/06  10:25:34  stephenb
 * [Bug #1719]
 * emacs_dialog: change the location of the socket from $HOME/.mlworks-server
 * to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
 * to avoid problems with creating sockets on an Andrew file system.
 *
 * Revision 1.32  1996/10/09  14:52:13  io
 * moving String from toplevel
 *
 * Revision 1.31  1996/08/11  18:41:50  brianm
 * [Bug #1528]
 * Minor correction to custom_server (& emacs_server in Unix).
 *
 * Revision 1.30  1996/08/09  12:55:31  daveb
 * [Bug #1536]
 * Word8Vector.vector no longer shares with string.
 *
 * Revision 1.29  1996/08/05  15:41:59  stephenb
 * Replace any functions in OldOs with ones from the new basis
 * and subsequently remove any reference to OldOs.
 *
 * Revision 1.28  1996/06/15  16:33:29  brianm
 * Modifications to add custom editor interface ...
 *
 * Revision 1.27  1996/05/15  10:59:08  stephenb
 * Update wrt UnixOS.SysErr -> UnixOS.Error.SysError change.
 *
 * Revision 1.26  1996/05/03  15:44:25  stephenb
 * UnixOS.close has moved to UnixOS.IO.close in line with POSIXification.
 *
 * Revision 1.25  1996/05/01  09:52:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.24  1996/04/29  15:32:46  matthew
 * removing MLWorks.Integer
 *
 * Revision 1.23  1996/03/26  13:23:45  stephenb
 * Update wrt to Unix->SysErr exception name change.
 *
 * Revision 1.22  1996/01/29  16:59:28  stephenb
 * unix.c reorganisation: change vfork_XXX to fork_XXX since vfork
 * isn't important as far as the user is concerned, all they are
 * after is a cheap fork and exec.
 *
Revision 1.21  1996/01/26  12:00:37  stephenb
Fix emacs server.

Revision 1.20  1996/01/19  16:54:55  stephenb
OS reorganisation: Since OS specific stuff is no longer
in the pervasive library, the editor functor needs the
new UnixOS structure as a parameter.

Revision 1.19  1995/10/23  12:51:08  daveb
Changed name of e-lisp highlight function to mlworks-highlight.

Revision 1.18  1995/10/20  16:43:48  daveb
Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.

Revision 1.17  1995/10/02  13:23:44  daveb
Made emacs highlight errors.
Removed next_error and no_more_errors.

Revision 1.16  1995/01/13  17:14:02  daveb
Replaced Option structure with references to MLWorks.Option.

Revision 1.15  1994/12/08  18:04:03  jont
Move OS specific stuff into a system link directory

Revision 1.14  1994/08/03  09:24:12  matthew
Reinstate call to makestring

Revision 1.13  1994/08/02  16:26:01  daveb
Added support for user-defined editors.

Revision 1.12  1994/07/29  16:19:00  daveb
Moved preferences into separate structure.

Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

Revision 1.10  1993/08/27  17:20:41  matthew
Added call to Unix.kill

Revision 1.9  1993/08/25  15:06:30  matthew
Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]

Revision 1.8  1993/06/04  14:12:35  daveb
Removed filename component of error result for edit functions.

Revision 1.7  1993/05/18  16:33:29  daveb
Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.

Revision 1.6  1993/04/22  13:00:22  richard
The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.

Revision 1.5  1993/04/14  15:23:51  jont
Added editing from location. Added a function to do next error from a list

Revision 1.4  1993/04/08  17:42:49  jont
Modify edit and edit_from_location to use the relevant editor

Revision 1.3  1993/04/08  15:00:45  jont
Added options parameter

Revision 1.2  1993/03/23  18:35:09  jont
Changed editor implementastion slightly.

Revision 1.1  1993/03/10  17:24:30  jont
Initial revision

Copyright (C) 1993 Harlequin Ltd
*)

require "^.basis.__int";
require "^.basis.__byte";
require "^.basis.__string";
require "^.basis.os";
require "^.main.preferences";
require "^.basics.location";
require "^.utils.crash";
require "^.editor.editor";
require "^.editor.custom";
require "^.utils.lists";
require "unixos";

functor Editor
  (structure Preferences: PREFERENCES
   structure Crash : CRASH
   structure Location : LOCATION
   structure OS : OS
   structure UnixOS : UNIXOS
   structure CustomEditor : CUSTOM_EDITOR
   structure Lists : LISTS
  ) : EDITOR =
struct
    structure Location = Location

    type preferences = Preferences.preferences

    fun null_fun () = ()

    fun show_int (i) =
        if i < 0 then "-" ^ Int.toString(~i) else Int.toString(i)

    val member   = Lists.member

    (* Locations etc. *)

    fun line_from_location(Location.UNKNOWN) = 0
      | line_from_location(Location.FILE _) = 0
      | line_from_location(Location.LINE(_, i)) = i
      | line_from_location(Location.POSITION(_, i, _)) = i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = i


    fun get_position_info (Location.EXTENT{s_line, s_col, e_line, e_col, ...}) =
        (s_line,s_col, e_line, e_col)

      | get_position_info (loc) = (line_from_location loc,0,~1,~1)


    (* Socket stuff *)


    (* Convert an integer into a two character string so that it can
     * be sent down a socket.  Probably should check that the 
     * pre-condition is satisified ...
     *
     * pre: i >= 0 /\ i <= 2^16
     *)
    fun marshal_int i = MLWorks.String.implode_char [i div 256, i mod 256]



    (* Write a string to the file descriptor which is attached to a socket.
     * As explained on page 279 of Unix Network Programming by Stevens,
     * just calling UnixOS.write(fd, msg, 0, len) would not guarantee
     * delivery of the whole message, generally due to kernel buffering.
     * Instead, you have to keep calling write until the whole string
     * has been sent.
     *)
    fun socket_write (fd, msg) =
      let
        val msg_len = size msg
	val vec = Byte.stringToBytes msg

        fun write (offset, len) =
          let val nwritten = UnixOS.write (fd , vec, offset, len)
	  in
            if nwritten < len then
              write (offset+nwritten, len-nwritten)
            else
              nwritten
          end
      in
        if write (0, msg_len) <> msg_len then
          raise UnixOS.Error.SysErr ("", NONE)
        else
          ()
      end


    (* Send a message down the file descriptor.  A message consists of a
     * two byte length followed by the string.
     *)
    fun socket_write_msg (fd, msg) =
      let val msg_len = size msg 
      in 
        socket_write (fd, marshal_int msg_len);
        socket_write (fd, msg)
      end



    (* Editor interfaces *)


    (* Argument Specifier Notation:
     * ============================
     *   %f =   filename
     *   %l =   %sl   = start line no.
     *   %c =   %sc   = start char no.
     *   %el =  end line no.
     *   %ec =  end char no.
     *   %%  =  % (percent)
     *)

    fun expand_args (fnm, st_l, st_c, e_l, e_c) =
        let fun trans(#"%" :: #"%" :: l, r) =
                  trans(l, "%" :: r)
              | trans(#"%" :: #"f" :: l, r) =
                  trans(l, fnm :: r)
              | trans(#"%" :: #"l" :: l, r) =
                  trans(l,show_int(st_l) :: r)
              | trans(#"%" :: #"s" :: #"l" :: l, r) =
                  trans(l,show_int(st_l) :: r)
              | trans(#"%" :: #"c" :: l, r) = trans(l,show_int(st_c) :: r)
              | trans(#"%" :: #"s" :: #"c" :: l, r) =
                  trans(l,show_int(st_c) :: r)
              | trans(#"%" :: #"e" :: #"l" :: l, r) =
                  trans(l,show_int(e_l) :: r)
              | trans(#"%" :: #"e" :: #"c" :: l, r) =
                  trans(l,show_int(e_c) :: r)
              | trans(c :: l, r) =
                  trans (l, (String.str c) :: r )
              | trans(_, r) =
                  String.concat (rev r) 

            fun doit str = trans(explode str,[])
        in
            doit
        end

    fun transEntry loc_details (server,commands) =
      let 
	val translate = expand_args loc_details
      in
        (server, map translate commands)
      end

    (* Emacs server & commands *)

    val standard_emacs_commands =
        let val find_file = "(find-file \"%f\")"
            val goto_line = "(goto-line %sl)"
            val fwd_char  = "(forward-char %sc)"
            val highlight = "(mlworks-highlight %sl %sc %el %ec)"
            val raise_win = "(raise-this-window)"

            val startup_cmds = [find_file, goto_line, fwd_char]

            val full_dialog  = [find_file, goto_line, fwd_char, highlight, raise_win]
        in
            CustomEditor.addConnectDialog ("Emacs", "Emacs", full_dialog);
            (startup_cmds,[highlight],[raise_win])
        end;


    (* Adding Vi command as a custom editor *)

    val _ = CustomEditor.addCommand ("Vi","xterm -name visual -e %f");


    (* Emacs Dialog support *)

    (* Keep this consistent with, the mechanism in the mlworks-server
     * <URI:hope://MLWsrc/emacs/etc/mlworks-server.c#init_socket_path>
     *)
    fun getSocketName ():string option =
      case OS.Process.getEnv "MLWORKS_SERVER_FILE" of
        SOME fileName => SOME fileName
      | NONE => 
          (case OS.Process.getEnv "USER" of
             SOME userName => SOME (concat ["/tmp/.", userName, "-mlworks-server"])
           | NONE => NONE)


    fun emacs_dialog (commands) =
        let val s   = UnixOS.socket (UnixOS.af_unix, UnixOS.sock_stream, 0)
            val cmd = concat ("(progn " :: (commands @@ [")"]))
        in
          case getSocketName () of
            SOME socketName => 
              ((UnixOS.connect (s, UnixOS.SOCKADDR_UNIX socketName);
                (*
                 * should check that the length of the message is less
                 * than the allowed maximum.
                 *)
                socket_write_msg (s, cmd);
                UnixOS.IO.close s;
                (NONE, null_fun)
              )
              handle
                UnixOS.Error.SysErr _ =>
                  (UnixOS.IO.close s;
                   (SOME "Unable to contact MLWorks Emacs server", null_fun)
                  ))
          | NONE =>
             (SOME "Unable to determine socket name, check MLWORKS_SERVER_FILE setting", null_fun)
        end
        handle
           UnixOS.Error.SysErr _ =>
              (SOME "Unable to contact MLWorks Emacs server", null_fun)

    fun xterm parsed_command =
      let
        val pid = 
          (UnixOS.fork_execvp
             ("xterm", ["xterm", "-name", "visual", "-e"] @@ parsed_command))
      in
        (NONE,fn () =>
         UnixOS.kill (pid,9)
         handle UnixOS.Error.SysErr _ => ())
      end
      handle UnixOS.Error.SysErr _ =>
        (SOME ("Unable to launch xterm editor processes"),null_fun)


    fun do_command (parsed_command as command :: _) =
      (let val pid = UnixOS.fork_execvp (command, parsed_command)
       in
         (NONE,
          fn () =>
             (UnixOS.kill (pid,9)
                handle UnixOS.Error.SysErr _ => ()
             )
         )
       end
          handle UnixOS.Error.SysErr _ =>
             (SOME ("Unable to launch editor process"),null_fun)
      )

    |  do_command nil = (SOME "No editor command specified", null_fun)

    local
       val wsp = [ #" ", #"\t", #"\n" ]

       fun scan (c :: s, [], lst) =
           if member (c,wsp) then scan (s,[],lst)
           else scan (s,[String.str c],lst)

         | scan (c :: s, tok, lst) =
           if member (c,wsp) then scan (s,[],concat(rev tok)::lst)
           else scan (s,(String.str c)::tok,lst)

         | scan ([],[],lst)  = rev lst
         | scan ([],tok,lst) = rev (concat(rev tok) :: lst)
    in

       fun parse_command (string) = scan (explode string, [], [])

    end


    (* this function provides an external editor - by launching an editor
       each time it is needed - a `one-shot' editor.
    *)
    fun external_server extCmd (string, s_l, s_c, e_l, e_c) =
        let val translate = expand_args (string, s_l, s_c, e_l, e_c)
            val cmds      = parse_command (translate extCmd)
        in
            do_command ( cmds )
        end

    fun one_way_server customName loc_details = 
      let 
	val translate = expand_args loc_details
	val cmd = translate (CustomEditor.getCommandEntry customName)

	val cmd_result = 
	  if (cmd <> "") then do_command (parse_command cmd)
	  else (SOME "invalid choice for editor", null_fun)
      in
	cmd_result
      end

    fun two_way_server customName loc_details =
      let
	val (dialog_type, commands) = 
	  transEntry loc_details (CustomEditor.getDialogEntry customName)

	val (service, topic, commands) = 
	  case commands of 
	    s::t::cmds => (s,t,cmds)
	  | _ => ("","",commands)
      in
	case dialog_type of 
	  "Emacs" => emacs_dialog commands
	| _ => (SOME ("Unknown custom dialog type : " ^ dialog_type), null_fun)
      end

    fun edit
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, i) =
        case !editor of
          "External" =>
             external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)

        | "OneWay" =>
             one_way_server (!oneWayEditorName) (string, i, 0, ~1, ~1)

        | "TwoWay" =>
             two_way_server (!twoWayEditorName) (string, i, 0, ~1, ~1)

        | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")


    fun edit_from_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, location) =
        let val (s_l, s_c, e_l, e_c) = get_position_info location
        in
           case !editor of
             "External" =>
                 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)

           | "OneWay" =>
                 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

           | "TwoWay" =>
                 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end


    fun show_location
          (Preferences.PREFERENCES
             {editor_options=Preferences.EDITOR_OPTIONS
                {editor, externalEditorCommand, oneWayEditorName, twoWayEditorName, ...},
              ...})
          (string, location) =
        let val (s_l, s_c, e_l, e_c) = get_position_info location
        in
           case !editor of
             "External" =>
                 (SOME("show location requires emacs"), null_fun)

           | "OneWay" =>
                 one_way_server (!oneWayEditorName) (string, s_l, s_c, e_l, e_c)

           | "TwoWay" =>
                 two_way_server (!twoWayEditorName) (string, s_l, s_c, e_l, e_c)

           | opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
        end
end
@


1.38
log
@[Bug #302333]
Change editor interface.
@
text
@d4 4
a177 7
(*
    fun message s = MLWorks.IO.output(MLWorks.IO.std_out,(s ^ "\n"));
    fun messages str = map (fn x => message (str ^ x))
*)      



a178 1

@


1.37
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d289 6
a294 8
    fun transEntry (file,s_line,s_char,e_line,e_char) (cmd,server,commands) =
        let val translate = expand_args (file,s_line,s_char,e_line,e_char)
        in
           ( translate cmd
           , server
           , map translate commands
           )
        end
a359 18

    (* This function initiates dialog with an emacs editor via a socket
       connection.  The editor must already be running for the connection to
       be made.  Once established, various emacs commands can then be sent
       from MLWorks to Emacs.
     *)
    fun emacs_server (fname, st_l, st_c, e_l, e_c, raise_flag) =
        let val (start_cmd,hilight_cmd,rwin_cmd) = standard_emacs_commands

            val hilite    = if (e_l = ~1) then [] else hilight_cmd
            val raise_win = if raise_flag then rwin_cmd else [] 

            val cmds      = start_cmd @@ hilite @@ raise_win
            val translate = expand_args (fname,st_l,st_c,e_l,e_c) 
        in
            emacs_dialog(map translate cmds)
        end

d420 16
a435 2
    (* this function provides custom editing services *)
    fun custom_server customName (string, s_l, s_c, e_l, e_c) =
d437 9
a445 31
                        (* first expand the string *) 
        let val trans = transEntry (string, s_l, s_c, e_l, e_c)
	    
                        (* fetch commands etc. *) 
            val (cmd,dialog_type,commands) = trans (CustomEditor.getEntry customName)

                        (* perform non-trivial editor launcher command *) 
            val cmd_result as (res_msg,callback) = 
                   if (cmd <> "") then do_command (parse_command cmd)
                   else  (NONE,null_fun)
        in
            (* analyse return message from editor launcher command *)
            case res_msg of
              NONE =>     (* i.e. normal situation *)
                ( case dialog_type of
                    "Emacs" => emacs_dialog (commands)

                  | "DDE"   =>
                     ( SOME ("DDE dialog only supported on Win 32 platforms")
                     , callback
                     )

                  | ""  => (NONE, callback) (* empty dialog type *)

                  | _ =>  
                     ( SOME ("Unknown custom dialog type : " ^ dialog_type)
                     , callback
                     )
               )
            | _ => cmd_result
        end
d450 1
a450 1
                {editor, externalEditorCommand, customEditorName, ...},
d454 2
a455 2
          "EmacsServer" =>
             emacs_server (string, i, 0, ~1, ~1, true)
d457 2
a458 2
        | "External" =>
             external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)
d460 2
a461 2
        | "Custom" =>
             custom_server (!customEditorName) (string, i, 0, ~1, ~1)
d469 1
a469 1
                {editor, externalEditorCommand, customEditorName, ...},
d475 2
a476 2
             "EmacsServer" =>
                 emacs_server (string, s_l, s_c, e_l, e_c, true)
d478 2
a479 2
           | "External" =>
                 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)
d481 2
a482 2
           | "Custom" =>
                 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
d491 1
a491 1
                {editor, externalEditorCommand, customEditorName, ...},
d497 2
a498 2
             "EmacsServer" =>
                 emacs_server (string, s_l, s_c, e_l, e_c, false)
d500 2
a501 2
           | "External" =>
                 (SOME("show location requires emacs"), null_fun)
d503 2
a504 2
           | "Custom" =>
                 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
@


1.36
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d139 1
a147 3
require "^.basis.__old";


d259 20
a278 16
    fun expand_args (fnm,st_l,st_c,e_l,e_c) =
        let fun trans ("%" :: "%" :: l, r) = trans(l, "%" :: r)

              | trans ("%" :: "f" :: l, r) = trans(l, fnm :: r)

              | trans ("%" :: "l" :: l, r)        = trans(l,show_int(st_l) :: r)
              | trans ("%" :: "s" :: "l" :: l, r) = trans(l,show_int(st_l) :: r)

              | trans ("%" :: "c" :: l, r)        = trans(l,show_int(st_c) :: r)
              | trans ("%" :: "s" :: "c" :: l, r) = trans(l,show_int(st_c) :: r)

              | trans ("%" :: "e" :: "l" :: l, r) = trans(l,show_int(e_l) :: r)
              | trans ("%" :: "e" :: "c" :: l, r) = trans(l,show_int(e_c) :: r)

              | trans (c :: l, r) = trans (l,c::r)
              | trans (_, r)      = concat (rev r) 
d280 1
a280 1
            fun doit str = trans(Old.explode str,[])
d407 1
a407 1
       val wsp = [" ","\t","\n"]
d411 1
a411 1
           else scan (s,[c],lst)
d415 1
a415 1
           else scan (s,c::tok,lst)
d421 1
a421 1
       fun parse_command (string) = scan (Old.explode string, [], [])
@


1.36.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.36  1997/05/02  16:59:11  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.36.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.36  1997/05/02  16:59:11  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.35
log
@Bug fix for Bug ID 1803 - problems with empty dialog types.
@
text
@d4 3
d338 1
a338 1
                (MLWorks.Option.NONE, null_fun)
d376 1
a376 1
        (MLWorks.Option.NONE,fn () =>
d387 1
a387 1
         (MLWorks.Option.NONE,
d442 1
a442 1
                   else  (MLWorks.Option.NONE,null_fun)
@


1.35.1.1
log
@branched from 1.35
@
text
@a3 3
 * Revision 1.35  1997/03/13  19:14:30  brianm
 * Bug fix for Bug ID 1803 - problems with empty dialog types.
 *
@


1.35.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.35.1.1  1997/05/12  10:52:44  hope
 * branched from 1.35
 *
@


1.35.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.35.1.1  1997/05/12  10:52:44  hope
 * branched from 1.35
 *
@


1.35.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.35.1.1  1997/05/12  10:52:44  hope
 * branched from 1.35
 *
@


1.35.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.35.1.1.1.1  1997/07/28  18:34:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.34
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d350 5
d416 4
d427 1
d429 2
d433 1
d436 1
d441 1
d443 1
a443 1
              NONE =>
d446 1
d451 3
@


1.34.4.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.3.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.3.1.1.1
log
@branched from 1.34.3.1
@
text
@a3 3
 * Revision 1.34.3.1  1996/12/17  18:19:11  hope
 * branched from 1.34
 *
@


1.34.2.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.1.1
log
@branched from 1.34
@
text
@a3 4
 * Revision 1.34  1996/11/06  12:50:03  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.1.1.1.1
log
@branched from 1.34.1.1
@
text
@a3 3
 * Revision 1.34.1.1  1996/11/14  13:23:08  hope
 * branched from 1.34
 *
@


1.33
log
@[Bug #1719]
emacs_dialog: change the location of the socket from $HOME/.mlworks-server
to read MLWORKS_SERVER_FILE which defaults to /tmp/.$USER-mlworks-server
to avoid problems with creating sockets on an Andrew file system.
@
text
@d4 6
d126 1
a126 1
require "^.basis.__integer";
@


1.32
log
@moving String from toplevel
@
text
@d4 3
a141 1
   val server_socket_name : string
d300 12
d316 3
a318 4
          case OS.Process.getEnv "HOME" of
            SOME home =>
              (( UnixOS.connect
                  (s, UnixOS.SOCKADDR_UNIX (concat [home, "/", server_socket_name]));
d333 1
a333 1
             (SOME "Unable to determine value of $HOME", null_fun)
@


1.31
log
@[Bug #1528]
Minor correction to custom_server (& emacs_server in Unix).
@
text
@d4 4
d127 1
a150 2
    val explode  = String.explode
    val implode  = String.implode
d185 1
a185 1
    fun marshal_int i = String.implode_char [i div 256, i mod 256]
d211 1
a211 1
          raise UnixOS.Error.SysErr ("", MLWorks.Option.NONE)
d257 1
a257 1
              | trans (_, r)      = implode(rev r) 
d259 1
a259 1
            fun doit str = trans(explode str,[])
d300 1
a300 1
            val cmd = implode ("(progn " :: (commands @@ [")"]))
d305 1
a305 1
                  (s, UnixOS.SOCKADDR_UNIX (implode [home, "/", server_socket_name]));
d317 1
a317 1
                   (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)
d320 1
a320 1
             (MLWorks.Option.SOME "Unable to determine value of $HOME", null_fun)
d324 1
a324 1
              (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)
d350 1
a350 1
        (MLWorks.Option.SOME ("Unable to launch xterm editor processes"),null_fun)
d364 1
a364 1
             (MLWorks.Option.SOME ("Unable to launch editor process"),null_fun)
d367 1
a367 1
    |  do_command nil = (MLWorks.Option.SOME "No editor command specified", null_fun)
d377 1
a377 1
           if member (c,wsp) then scan (s,[],implode(rev tok)::lst)
d381 1
a381 1
         | scan ([],tok,lst) = rev (implode(rev tok) :: lst)
d384 1
a384 1
       fun parse_command (string) = scan (explode string, [], [])
d405 1
a405 1
              MLWorks.Option.NONE =>
d409 1
a409 1
                     ( MLWorks.Option.SOME ("DDE dialog only supported on Win 32 platforms")
d413 1
a413 1
                     ( MLWorks.Option.SOME ("Unknown custom dialog type : " ^ dialog_type)
d474 1
a474 1
                 (MLWorks.Option.SOME("show location requires emacs"), null_fun)
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/08/11  18:41:50  brianm
 * [Bug #1528]
 * Minor correction to custom_server (& emacs_server in Unix).
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/08/11  18:41:50  brianm
 * [Bug #1528]
 * Minor correction to custom_server (& emacs_server in Unix).
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/08/11  18:41:50  brianm
 * [Bug #1528]
 * Minor correction to custom_server (& emacs_server in Unix).
 *
@


1.30
log
@[Bug #1536]
Word8Vector.vector no longer shares with string.
@
text
@d4 4
d152 1
d156 1
d324 1
a324 1
    fun emacs_server (fname, st_l, st_c, e_l, e_c,raise_flag) =
d327 1
a327 1
            val hilite    = if (e_l = ~1) then hilight_cmd else []
d394 3
a396 1
            val (cmd,dialog_type,commands) = trans (CustomEditor.getEntry string)
@


1.29
log
@Replace any functions in OldOs with ones from the new basis
and subsequently remove any reference to OldOs.
@
text
@d4 4
d110 1
d190 2
d193 2
a194 2
          let val nwritten = UnixOS.write (fd, msg, offset, len)
          in
@


1.28
log
@Modifications to add custom editor interface ...
@
text
@d4 3
d106 1
a106 1
require "^.make.old_os";
d121 1
a121 1
   structure OldOs : OLD_OS
d164 9
a172 2
    fun marshal_int i =
      String.implode_char [i div 256, i mod 256]
d185 1
a185 1
	fun write (offset, len) =
d188 4
a191 4
	    if nwritten < len then
	      write (offset+nwritten, len-nwritten)
	    else
	      nwritten
d194 2
a195 2
	if write (0, msg_len) <> msg_len then
	  raise UnixOS.Error.SysErr ("", MLWorks.Option.NONE)
d197 1
a197 1
	  ()
d207 2
a208 2
	socket_write (fd, marshal_int msg_len);
	socket_write (fd, msg)
d227 1
a227 1
	let fun trans ("%" :: "%" :: l, r) = trans(l, "%" :: r)
d229 1
a229 1
	      | trans ("%" :: "f" :: l, r) = trans(l, fnm :: r)
d231 2
a232 2
	      | trans ("%" :: "l" :: l, r)        = trans(l,show_int(st_l) :: r)
	      | trans ("%" :: "s" :: "l" :: l, r) = trans(l,show_int(st_l) :: r)
d234 2
a235 2
	      | trans ("%" :: "c" :: l, r)        = trans(l,show_int(st_c) :: r)
	      | trans ("%" :: "s" :: "c" :: l, r) = trans(l,show_int(st_c) :: r)
d237 2
a238 2
	      | trans ("%" :: "e" :: "l" :: l, r) = trans(l,show_int(e_l) :: r)
	      | trans ("%" :: "e" :: "c" :: l, r) = trans(l,show_int(e_c) :: r)
d240 1
a240 1
	      | trans (c :: l, r) = trans (l,c::r)
d270 1
a270 1
	    CustomEditor.addConnectDialog ("Emacs", "Emacs", full_dialog);
d283 26
a308 23
	let val s   = UnixOS.socket (UnixOS.af_unix, UnixOS.sock_stream, 0)
	    val cmd = implode ("(progn " :: (commands @@ [")"]))
	in
	   ( UnixOS.connect
		(s, UnixOS.SOCKADDR_UNIX
		      (implode [OldOs.home "", "/", server_socket_name]));
	      (*
	       * should check that the length of the message is less
	       * than the allowed maximum.
	       *)
	      socket_write_msg (s, cmd);
	      UnixOS.IO.close s;
	      (MLWorks.Option.NONE, null_fun)
	   )
	 handle
	   UnixOS.Error.SysErr _ =>
	      (UnixOS.IO.close s;
	       (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)
	      )
	end
	handle
	   UnixOS.Error.SysErr _ =>
	      (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)
d342 3
a344 3
	     (UnixOS.kill (pid,9)
		handle UnixOS.Error.SysErr _ => ()
	     )
d357 2
a358 2
	   if member (c,wsp) then scan (s,[],lst)
	   else scan (s,[c],lst)
d360 3
a362 3
	 | scan (c :: s, tok, lst) =
	   if member (c,wsp) then scan (s,[],implode(rev tok)::lst)
	   else scan (s,c::tok,lst)
d364 2
a365 2
	 | scan ([],[],lst)  = rev lst
	 | scan ([],tok,lst) = rev (implode(rev tok) :: lst)
d373 1
a373 1
	let val translate = expand_args (string, s_l, s_c, e_l, e_c)
d375 3
a377 3
	in
	    do_command ( cmds )
	end
d388 10
a397 10
		( case dialog_type of
		    "Emacs" => emacs_dialog (commands)
		  | "DDE"   =>
		     ( MLWorks.Option.SOME ("DDE dialog only supported on Win 32 platforms")
		     , callback
		     )
		  | _ =>  
		     ( MLWorks.Option.SOME ("Unknown custom dialog type : " ^ dialog_type)
		     , callback
		     )
d405 2
a406 2
	        {editor, externalEditorCommand, customEditorName, ...},
	      ...})
d408 3
a410 3
	case !editor of
	  "EmacsServer" =>
	     emacs_server (string, i, 0, ~1, ~1, true)
d412 2
a413 2
	| "External" =>
	     external_server (!externalEditorCommand) (string, i, 0, ~1, ~1)
d415 2
a416 2
	| "Custom" =>
	     custom_server (!customEditorName) (string, i, 0, ~1, ~1)
d418 1
a418 1
	| opt => Crash.impossible ("Unknown option `" ^ opt ^ "'")
d424 2
a425 2
	        {editor, externalEditorCommand, customEditorName, ...},
	      ...})
d427 5
a431 5
	let val (s_l, s_c, e_l, e_c) = get_position_info location
	in
	   case !editor of
	     "EmacsServer" =>
		 emacs_server (string, s_l, s_c, e_l, e_c, true)
d433 2
a434 2
	   | "External" =>
		 external_server (!externalEditorCommand) (string, s_l, s_c, e_l, e_c)
d436 2
a437 2
	   | "Custom" =>
		 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
d446 2
a447 2
	        {editor, externalEditorCommand, customEditorName, ...},
	      ...})
d449 5
a453 5
	let val (s_l, s_c, e_l, e_c) = get_position_info location
	in
	   case !editor of
	     "EmacsServer" =>
		 emacs_server (string, s_l, s_c, e_l, e_c, false)
d455 2
a456 2
	   | "External" =>
		 (MLWorks.Option.SOME("show location requires emacs"), null_fun)
d458 2
a459 2
	   | "Custom" =>
		 custom_server (!customEditorName) (string, s_l, s_c, e_l, e_c)
@


1.27
log
@Update wrt UnixOS.SysErr -> UnixOS.Error.SysError change.
@
text
@d4 3
d108 2
d113 1
d120 2
d129 17
a151 1
    fun null_fun () = ()
d153 7
d202 38
a239 29
    fun emacs (filename, s_line, s_col, e_line, e_col, raise_window) =
      let
        val s = UnixOS.socket (UnixOS.af_unix, UnixOS.sock_stream, 0)
      in
	let
	  val find_file =
            [" (find-file \"", filename, "\")"]

          val goto_line =
            [" (goto-line ", Int.toString s_line, ")"]

          val forward_char =
            [" (forward-char ", Int.toString s_col, ")"]
  
	  val set_highlight =
	    if e_line <> ~1 then
	      [" (mlworks-highlight ",
	       Int.toString s_line, " ",
	       Int.toString s_col, " ",
	       Int.toString e_line, " ",
	       Int.toString e_col, ")"]
	    else
	      []
  
	  val raise_code =
	    if raise_window then
	      [" (raise-this-window)"]
	    else
	      []
d241 4
a244 12
	  UnixOS.connect
	    (s, UnixOS.SOCKADDR_UNIX
	          (String.implode [OldOs.home "", "/", server_socket_name]));
	  (*
	   * should check that the length of the message is less
	   * than the allowed maximum.
	   *)
	  socket_write_msg
	    (s, String.implode (["(progn"] @@ find_file @@ goto_line @@ forward_char
			 @@ set_highlight @@ raise_code @@ [")\n"]));
	  UnixOS.IO.close s;
          (MLWorks.Option.NONE, null_fun)
d246 47
d294 9
a302 7
	UnixOS.Error.SysErr _ =>
          (UnixOS.IO.close s;
           (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server",
	    null_fun))
      end
      handle UnixOS.Error.SysErr _ =>
        (MLWorks.Option.SOME "Unable to contact MLWorks Emacs server", null_fun)
d304 5
a308 19
    fun parse_command (s, filename, line) =
      let fun parse (~1, [], list) = list
          |   parse (~1, word, list) = String.implode word :: list
	  |   parse (i, word, list) =
	    let val ch = String.ordof (s, i)
	    in
	      if ch = String.ord " " then
		case word of
		  [] => parse (i-1, [], list)
	        | _  => parse (i-1, [], String.implode (word) :: list)
	      else if ch = String.ord "l" andalso i > 0
		   andalso String.ordof (s, i-1) = String.ord "%" then
                   parse (i-2, Int.toString line :: word, list)
	      else
	        parse (i-1, String.chr ch :: word, list)
	    end
      in
	parse (size s - 1, [], [filename])
      end
d323 3
a325 3
    fun x (parsed_command as command :: _) =
      (let
         val pid = UnixOS.fork_execvp (command, parsed_command)
d327 6
a332 3
         (MLWorks.Option.NONE,fn () =>
          UnixOS.kill (pid,9)
          handle UnixOS.Error.SysErr _ => ())
d334 54
a387 3
       handle UnixOS.Error.SysErr _ =>
         (MLWorks.Option.SOME ("Unable to launch x editor process"),null_fun))
    |  x nil = Crash.impossible "nil argument to x editor"
d392 1
a392 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d395 12
a406 6
      case !editor of
        "emacs_server" => emacs (string, i, 0, ~1, ~1, true)
      | "xterm" => xterm (parse_command (!xterm_editor_command, string, i))
      | "x" =>
	x (parse_command (!x_editor_command, string, i))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)
d411 1
a411 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d414 15
a428 13
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, true)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, true))
      | "xterm" =>
	xterm (parse_command
		 (!xterm_editor_command, string, line_from_location location))
      | "x" =>
	x (parse_command
	     (!x_editor_command, string, line_from_location location))
      | _ => (MLWorks.Option.SOME ("Unknown editor `" ^ !editor ^ "'"),null_fun)
d433 1
a433 1
	        {editor, x_editor_command, xterm_editor_command, ...},
d436 15
a450 8
      case !editor of
        "emacs_server" =>
	(case location
	 of Location.EXTENT{s_line, s_col, e_line, e_col, ...} =>
	   emacs (string, s_line, s_col, e_line, e_col, false)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1, false))
      | _ => (MLWorks.Option.SOME ("Show location require emacs"), null_fun)
  end
@


1.26
log
@UnixOS.close has moved to UnixOS.IO.close in line with POSIXification.
@
text
@d4 3
d154 1
a154 1
	  raise UnixOS.SysErr ("", MLWorks.Option.NONE)
d215 1
a215 1
	UnixOS.SysErr _ =>
d220 1
a220 1
      handle UnixOS.SysErr _ =>
d251 1
a251 1
         handle UnixOS.SysErr _ => ())
d253 1
a253 1
      handle UnixOS.SysErr _ =>
d262 1
a262 1
          handle UnixOS.SysErr _ => ())
d264 1
a264 1
       handle UnixOS.SysErr _ =>
@


1.25
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d96 6
a101 7
require "../basis/__integer";

require "../make/old_os";
require "../main/preferences";
require "../basics/location";
require "../utils/crash";
require "../editor/editor";
d208 1
a208 1
	  UnixOS.close s;
d213 1
a213 1
          (UnixOS.close s;
@


1.24
log
@removing MLWorks.Integer
@
text
@d4 3
d195 1
a195 1
	          (implode [OldOs.home "", "/", server_socket_name]));
d201 1
a201 1
	    (s, implode (["(progn"] @@ find_file @@ goto_line @@ forward_char
d217 1
a217 1
          |   parse (~1, word, list) = implode word :: list
d221 1
a221 1
	      if ch = ord " " then
d224 3
a226 3
	        | _  => parse (i-1, [], implode (word) :: list)
	      else if ch = ord "l" andalso i > 0
		   andalso String.ordof (s, i-1) = ord "%" then
d229 1
a229 1
	        parse (i-1, chr ch :: word, list)
@


1.23
log
@Update wrt to Unix->SysErr exception name change.
@
text
@d4 3
d87 2
d169 1
a169 1
            [" (goto-line ", MLWorks.Integer.makestring s_line, ")"]
d172 1
a172 1
            [" (forward-char ", MLWorks.Integer.makestring s_col, ")"]
d177 4
a180 4
	       MLWorks.Integer.makestring s_line, " ",
	       MLWorks.Integer.makestring s_col, " ",
	       MLWorks.Integer.makestring e_line, " ",
	       MLWorks.Integer.makestring e_col, ")"]
d224 1
a224 1
                   parse (i-2, MLWorks.Integer.makestring line :: word, list)
@


1.22
log
@unix.c reorganisation: change vfork_XXX to fork_XXX since vfork
isn't important as far as the user is concerned, all they are
after is a cheap fork and exec.
@
text
@d4 5
d84 1
a84 1
require "../make/os";
d96 1
a96 1
   structure Os : OS
d138 1
a138 1
	  raise UnixOS.Unix ""
d187 1
a187 1
	          (implode [Os.home "", "/", server_socket_name]));
d199 1
a199 1
	UnixOS.Unix msg =>
d204 1
a204 1
      handle UnixOS.Unix _ =>
d235 1
a235 1
         handle UnixOS.Unix _ => ())
d237 1
a237 1
      handle UnixOS.Unix _ =>
d246 1
a246 1
          handle UnixOS.Unix _ => ())
d248 1
a248 1
       handle UnixOS.Unix _ =>
@


1.21
log
@Fix emacs server.
@
text
@d4 3
d225 1
a225 1
          (UnixOS.vfork_execvp
d237 1
a237 3
         val pid = 
           (UnixOS.vfork_execvp
              (command, parsed_command))
@


1.20
log
@OS reorganisation: Since OS specific stuff is no longer
in the pervasive library, the editor functor needs the
new UnixOS structure as a parameter.
@
text
@d4 5
d106 41
d149 1
a149 1
        val s = UnixOS.socket (1, 1, 0)
d153 1
a153 1
            ["(find-file \"", filename, "\")\n"]
d156 1
a156 1
            ["(goto-line ", MLWorks.Integer.makestring s_line, ")\n"]
d159 1
a159 1
            ["(forward-char ", MLWorks.Integer.makestring s_col, ")\n"]
d163 1
a163 1
	      ["(mlworks-highlight ",
d167 1
a167 1
	       MLWorks.Integer.makestring e_col, ")\n"]
d169 1
a169 1
	      ["\n"]
d173 1
a173 1
	      ["(raise-this-window)\n"]
d178 1
a178 1
            (s, UnixOS.SOCKADDR_UNIX
d180 8
a187 5
          UnixOS.write (s, implode find_file);
          UnixOS.write
	    (s, implode (["(progn "] @@ goto_line @@ forward_char
			 @@ set_highlight @@ raise_code @@ [")"]));
          UnixOS.close s;
@


1.19
log
@Changed name of e-lisp highlight function to mlworks-highlight.
@
text
@d4 3
d75 3
a77 1
require "editor";
d84 1
d103 1
a103 1
        val s = MLWorks.OS.Unix.socket (1, 1, 0)
d131 2
a132 2
	  MLWorks.OS.Unix.connect
            (s, MLWorks.OS.Unix.SOCKADDR_UNIX
d134 2
a135 2
          MLWorks.OS.Unix.write (s, implode find_file);
          MLWorks.OS.Unix.write
d138 1
a138 1
          MLWorks.OS.Unix.close s;
d142 2
a143 2
	MLWorks.OS.Unix.Unix msg =>
          (MLWorks.OS.Unix.close s;
d147 1
a147 1
      handle MLWorks.OS.Unix.Unix _ =>
d173 1
a173 1
          (MLWorks.OS.Unix.vfork_execvp
d177 2
a178 2
         MLWorks.OS.Unix.kill (pid,9)
         handle MLWorks.OS.Unix.Unix _ => ())
d180 1
a180 1
      handle MLWorks.OS.Unix.Unix _ =>
d186 1
a186 1
           (MLWorks.OS.Unix.vfork_execvp
d190 2
a191 2
          MLWorks.OS.Unix.kill (pid,9)
          handle MLWorks.OS.Unix.Unix _ => ())
d193 1
a193 1
       handle MLWorks.OS.Unix.Unix _ =>
@


1.18
log
@Sent the emacs commands as separate S-expressions, to avoid buffer
overflow problems.
@
text
@d4 4
d111 1
a111 1
	      ["(set-highlight ",
@


1.17
log
@Made emacs highlight errors.
Removed next_error and no_more_errors.
@
text
@d4 4
d90 2
a91 1
    fun emacs (filename, s_line, s_col, e_line, e_col) =
a93 19

	val find_file =
	  ["(progn (find-file \"",
           filename,
           "\") (goto-line ",
           MLWorks.Integer.makestring s_line,
           ") (forward-char ",
	   MLWorks.Integer.makestring s_col,
	   ")"]
	
	val set_highlight =
	  if e_line <> ~1 then
	    ["(set-highlight ",
	     MLWorks.Integer.makestring s_line, " ",
	     MLWorks.Integer.makestring s_col, " ",
	     MLWorks.Integer.makestring e_line, " ",
	     MLWorks.Integer.makestring e_col, "))\n"]
	  else
	    [")\n"]
d95 41
a135 6
        MLWorks.OS.Unix.connect
          (s, MLWorks.OS.Unix.SOCKADDR_UNIX
	        (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode (find_file @@ set_highlight));
        MLWorks.OS.Unix.close s;
        (MLWorks.Option.NONE, null_fun)
d138 1
a138 1
        (MLWorks.Option.SOME ("Unable to contact MLWorks Emacs server"), null_fun)
d194 1
a194 1
        "emacs_server" => emacs (string, i, 0, ~1, ~1)
d210 2
a211 2
	   emacs (string, s_line, s_col, e_line, e_col)
	 |  _ => emacs (string, line_from_location location, 0, ~1, ~1))
d219 14
@


1.16
log
@Replaced Option structure with references to MLWorks.Option.
@
text
@d4 3
a77 2
    exception no_more_errors

d86 1
a86 1
    fun emacs (filename, line) =
d89 19
d110 3
a112 6
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Os.home "", "/", server_socket_name]));
        MLWorks.OS.Unix.write (s, implode ["(progn (find-file \"",
                                           filename,
                                           "\") (goto-line ",
                                           MLWorks.Integer.makestring line,
                                           "))\n"]);
d114 1
a114 1
        (MLWorks.Option.NONE,null_fun)
d167 5
a171 5
      (Preferences.PREFERENCES
         {editor_options=Preferences.EDITOR_OPTIONS
	    {editor, x_editor_command, xterm_editor_command, ...},
	  ...})
      (string, i) =
d173 1
a173 1
        "emacs_server" => emacs (string, i)
d179 19
a197 17
    fun edit_from_location options (string, location) =
      edit options (string, line_from_location location)

    fun next_error options [] = raise no_more_errors
      | next_error options ((location, string) :: rest) =
	let
	  val file = case location of
	    Location.UNKNOWN => Crash.impossible("Unknown error location")
	  | Location.FILE file => file
	  | Location.LINE(file, _) => file
	  | Location.POSITION(file, _, _) => file
	  | Location.EXTENT{name=file, ...} => file
	in
	  output(std_out, string ^ "\n");
	  edit_from_location options (file, location);
	  rest
	end
@


1.15
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
a57 1
require "../main/options";
a59 1
require "../utils/option";
a64 1
   structure Option : OPTION
a71 1
    structure Option = Option
d97 1
a97 1
        (Option.ABSENT,null_fun)
d100 1
a100 1
        (Option.PRESENT ("Unable to contact MLWorks Emacs server"), null_fun)
d128 1
a128 1
        (Option.ABSENT,fn () =>
d133 1
a133 1
        (Option.PRESENT ("Unable to launch xterm editor processes"),null_fun)
d141 1
a141 1
         (Option.ABSENT,fn () =>
d146 1
a146 1
         (Option.PRESENT ("Unable to launch x editor process"),null_fun))
d160 1
a160 1
      | _ => (Option.PRESENT ("Unknown editor `" ^ !editor ^ "'"),null_fun)
@


1.14
log
@Reinstate call to makestring
@
text
@d4 3
d54 1
a59 1
require "../make/unix";
d67 1
a67 1
   structure Unix : UNIX
d91 1
a91 1
        (s, MLWorks.OS.Unix.SOCKADDR_UNIX (implode [Unix.home "", "/", server_socket_name]));
@


1.13
log
@Added support for user-defined editors.
@
text
@d4 3
d112 1
a112 1
	        parse (i-2, (* MLWorks.Integer.makestring line *) "23" :: word, list)
@


1.12
log
@Moved preferences into separate structure.
@
text
@d4 3
d97 21
a117 1
    fun vi (filename, line) =
d121 1
a121 2
           ("xterm", ["xterm", "-name", "visual",
                      "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]))
d128 15
a142 1
        (Option.PRESENT ("Unable to launch vi process"),null_fun)
d146 3
a148 1
         {editor_options=Preferences.EDITOR_OPTIONS{editor, ...}, ...})
d151 4
a154 2
        "emacs" => emacs (string, i)
      | "vi" => vi (string, i)
@


1.11
log
@reversed arguments to kill
added handler for Unix exception
@
text
@d4 4
d46 1
d53 9
a61 8
functor Editor(
  structure Options : OPTIONS
  structure Option : OPTION
  structure Crash : CRASH
  structure Location : LOCATION
  structure Unix : UNIX
  val server_socket_name : string) : EDITOR =
  struct
d64 2
a65 1
    structure Options = Options
d109 2
a110 2
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
@


1.11.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.11  1993/08/31  11:29:18  matthew
reversed arguments to kill
added handler for Unix exception

@


1.10
log
@Added call to Unix.kill
@
text
@d4 3
d94 3
a96 1
        (Option.ABSENT,fn () => MLWorks.OS.Unix.kill (9,pid))
@


1.9
log
@Return quit function from ShellUtils.edit_string
Need to uncomment call to kill]
@
text
@d4 4
d91 1
a91 1
        (Option.ABSENT,fn () => output(std_out,"Poo\n") (* MLWorks.OS.Unix.kill pid *))
@


1.8
log
@Removed filename component of error result for edit functions.
@
text
@d4 3
d61 2
d75 1
a75 1
        Option.ABSENT
d78 1
a78 1
        Option.PRESENT ("Unable to contact MLWorks Emacs server")
d81 8
a88 4
      (MLWorks.OS.Unix.vfork_execvp
       ("xterm", ["xterm", "-name", "visual",
                  "-e", "vi", "+" ^ MLWorks.Integer.makestring line, filename]);
       Option.ABSENT)
d90 1
a90 1
        Option.PRESENT ("Unable to launch vi process")
d99 1
a99 1
      | _ => Option.PRESENT ("Unknown editor `" ^ !editor ^ "'")
@


1.7
log
@Changed Integer.makestring to MLWorks.Integer.makestring and removed
the Integer structure.
@
text
@d4 4
d73 1
a73 1
        Option.PRESENT (filename, "Unable to contact MLWorks Emacs server")
d81 1
a81 1
        Option.PRESENT (filename, "Unable to launch vi process")
d90 1
a90 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ !editor ^ "'")
@


1.6
log
@The editor interface is now implemented directly through
Unix system calls, and is not part of the pervasive library
or the runtime system.
@
text
@d4 5
a29 1
require "../utils/integer";
a36 1
  structure Integer : INTEGER
d63 1
a63 1
                                           Integer.makestring line,
d74 1
a74 1
                  "-e", "vi", "+" ^ Integer.makestring line, filename]);
d83 1
a83 1
      case editor of
d86 1
a86 1
      | _ => Option.PRESENT (string, "Unknown editor `" ^ editor ^ "'")
@


1.5
log
@Added editing from location. Added a function to do next error from a list
@
text
@d4 3
d27 1
d35 3
a37 1
  structure Location : LOCATION) : EDITOR =
d45 5
a49 5
    fun line_from_location(Location.UNKNOWN) = "+0"
      | line_from_location(Location.FILE _) = "+0"
      | line_from_location(Location.LINE(_, i)) = "+" ^ Integer.makestring i
      | line_from_location(Location.POSITION(_, i, _)) = "+" ^ Integer.makestring i
      | line_from_location(Location.EXTENT{s_line=i, ...}) = "+" ^ Integer.makestring i
d51 16
a66 10
    fun edit_from_location
      (Options.OPTIONS
       {editor_options=Options.EDITOR_OPTIONS{editor, ...}, ...})
      (string, location) =
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file [string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file [line_from_location location, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
d68 8
d80 7
a86 6
      ((case editor of
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file[string]
	| MLWorks.Editor.VI =>
	    MLWorks.Editor.vi_file["+" ^ Integer.makestring i, string]);
	  Option.ABSENT)
      handle MLWorks.Editor.NotFound arg => Option.PRESENT arg
@


1.4
log
@Modify edit and edit_from_location to use the relevant editor
@
text
@d4 3
d22 2
d29 2
d37 8
d50 3
a52 3
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)
	  [string];
d61 3
a63 2
	  MLWorks.Editor.EMACS => MLWorks.Editor.emacs_file
	| MLWorks.Editor.VI => MLWorks.Editor.vi_file)[string];
d66 15
@


1.3
log
@Added options parameter
@
text
@d4 3
d34 5
a38 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
d45 4
a48 2
      (MLWorks.Editor.load_file[string];
       Option.ABSENT)
@


1.2
log
@Changed editor implementastion slightly.
@
text
@d4 3
d13 1
d19 1
d25 1
d27 4
a30 1
    fun edit_from_location (string, location) =
d35 4
a38 1
    fun edit(string, i) =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d22 1
a22 1
      (MLWorks.Editor.load_file string;
d27 1
a27 1
      (MLWorks.Editor.load_file string;
@
