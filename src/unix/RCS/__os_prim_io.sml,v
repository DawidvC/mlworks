head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.13
	MLWorks_20b0_1998_04_07:1.13
	MLWorks_20b0_1998_03_20:1.13
	MLWorks_20m2_1998_02_16:1.12
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.9.1.1.1.4.1
	MLWorks_workspace_97:1.12.2
	MLWorks_dt_wizard:1.12.1
	MLWorks_11c0_1997_09_09:1.9.1.1.1.4
	MLWorks_10r3:1.9.1.1.3
	MLWorks_10r2_551:1.9.1.1.2
	MLWorks_11:1.9.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.1.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.9.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.1
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.3.1.1
	MLWorks_gui_1996_12_18:1.6.4
	MLWorks_1_0_Win32_1996_12_17:1.6.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.4;
locks; strict;
comment	@ *  @;


1.15
date	99.02.02.16.01.56;	author mitchell;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.13;

1.13
date	98.02.19.21.09.49;	author mitchell;	state Exp;
branches;
next	1.12;

1.12
date	97.07.15.15.06.52;	author brucem;	state Exp;
branches
	1.12.1.1
	1.12.2.1;
next	1.11;

1.11
date	97.07.11.11.22.55;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	97.05.09.12.47.17;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	97.03.24.13.19.15;	author andreww;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	97.01.15.12.13.43;	author io;	state Exp;
branches;
next	1.7;

1.7
date	96.11.16.01.59.05;	author io;	state Exp;
branches;
next	1.6;

1.6
date	96.10.21.15.22.56;	author jont;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1;
next	1.5;

1.5
date	96.08.21.11.02.47;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	96.08.14.09.17.00;	author andreww;	state Exp;
branches;
next	1.3;

1.3
date	96.08.09.11.00.49;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	96.08.05.16.05.33;	author andreww;	state Exp;
branches;
next	1.1;

1.1
date	96.07.18.13.25.48;	author andreww;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.42.41;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.35.49;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.54.52;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.13.23.15;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.15.33.46;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.40.16;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.18.19.16;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	97.02.24.12.13.36;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.18.10.14.40;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	97.05.12.10.52.50;	author hope;	state Exp;
branches
	1.9.1.1.1.1
	1.9.1.1.2.1
	1.9.1.1.3.1;
next	;

1.9.1.1.1.1
date	97.07.28.18.35.03;	author daveb;	state Exp;
branches;
next	1.9.1.1.1.2;

1.9.1.1.1.2
date	97.08.08.09.01.01;	author johnh;	state Exp;
branches;
next	1.9.1.1.1.3;

1.9.1.1.1.3
date	97.08.08.09.13.08;	author johnh;	state Exp;
branches;
next	1.9.1.1.1.4;

1.9.1.1.1.4
date	97.08.08.09.27.32;	author johnh;	state Exp;
branches
	1.9.1.1.1.4.1.1;
next	;

1.9.1.1.1.4.1.1
date	97.10.07.12.00.45;	author jkbrook;	state Exp;
branches;
next	;

1.9.1.1.2.1
date	97.09.08.17.27.48;	author daveb;	state Exp;
branches;
next	;

1.9.1.1.3.1
date	97.09.09.14.24.56;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	97.09.10.19.43.45;	author brucem;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.11.21.11.10;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.18.09.17;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
[Bug 1453]: updated wrt May 30 basis doc, and renamed from __primio.sml
@


1.15
log
@[Bug #190500]
Remove redundant require statements
@
text
@(*  ==== INITIAL BASIS : OS_PRIM_IO ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This is part of the extended Initial Basis.
 *
 *  Revision Log
 *  ------------
 *  $Log: __os_prim_io.sml,v $
 *  Revision 1.14  1998/05/26  13:56:24  mitchell
 *  [Bug #30413]
 *  Rename stdErr stream stdErr rather than StdOut
 *
 *  Revision 1.13  1998/02/19  21:09:49  mitchell
 *  [Bug #30349]
 *  Fix to avoid non-unit sequence warnings
 *
 *  Revision 1.12  1997/07/15  15:06:52  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to
 *  IO.RandomAccessNotSupported.
 *
 *  Revision 1.11  1997/07/11  11:22:55  daveb
 *  [Bug #30192]
 *  Made attempts to close stdIn etc. raise IO.Io.
 *
 *  Revision 1.10  1997/05/09  12:47:17  jont
 *  [Bug #20045]
 *  Ensure getPos for writes return position rather than size of last write
 *
 *  Revision 1.9  1997/03/24  13:19:15  andreww
 *  [Bug #1960]
 *  tidying up stdErr writer
 *
 *  Revision 1.8  1997/01/15  12:13:43  io
 *  [Bug #1892]
 *  rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
 *
 *  Revision 1.7  1996/11/16  01:59:05  io
 *  [Bug #1757]
 *  renamed __char{array,vector} to __char_{array,vector}
 *
 *  Revision 1.6  1996/10/21  15:22:56  jont
 *  Remove references to basis.toplevel
 *
 *  Revision 1.5  1996/08/21  11:02:47  stephenb
 *  [Bug #1554]
 *  Add a call to UnixOS.fdToIOD now that file descriptors and
 *  io descriptors aren't the same type.
 *  l
 *
 *  Revision 1.4  1996/08/14  09:17:00  andreww
 *  [Bug #1537]
 *  File primIO records will return io Descriptors
 *
 *  Revision 1.3  1996/08/09  11:00:49  daveb
 *  [Bug #1536]
 *  BinPrimIO.vector no longer shares with string.
 *
 *  Revision 1.2  1996/08/05  16:05:33  andreww
 *  [Bug #1530]
 *  Ensuring that length counters are set appropriately.
 *
 *  Revision 1.1  1996/07/18  13:25:48  andreww
 *  new unit
 *  [Bug 1453]: updated wrt May 30 basis doc, and renamed from __primio.sml
 *
 *  Revision 1.15  1996/07/16  10:18:27  andreww
 *  Simplifying standard in, out and err.
 *
 *  Revision 1.14  1996/07/03  09:59:09  andreww
 *  Routing standard input/output/error through the listener.
 *
 *  Revision 1.13  1996/06/14  13:23:27  andreww
 *  correcting sets to unix blocking mode.
 *
 *  Revision 1.12  1996/06/10  09:51:29  andreww
 *  converting out-of-date IO magic numbers (which don't work under Solaris)
 *  into appropriate sums of corresponding unix constants.
 *
 *  Revision 1.11  1996/05/31  12:36:51  andreww
 *  removing text, bin structures.
 *
 *  Revision 1.10  1996/05/30  16:40:43  andreww
 *  removing too-early modifications.
 *
 *  Revision 1.9  1996/05/30  14:00:34  andreww
 *  removing TextPrimIO and BinPrimIO structures.
 *
 *  Revision 1.8  1996/05/24  11:24:37  andreww
 *  expose TextPrimIO and BinPrimIO at top-level.
 *
 *  Revision 1.7  1996/05/20  12:29:12  jont
 *  Update to latest primio signature
 *
 *  Revision 1.6  1996/05/15  13:29:41  jont
 *  __fileposint moved to __position
 *
 *  Revision 1.5  1996/05/03  15:56:18  stephenb
 *  UnixOS_.fstat has moved to UnixOS_.FileSys.fstat
 *
 *  Revision 1.4  1996/04/23  16:27:35  matthew
 *  Changing some word8s to chars
 *
 *  Revision 1.3  1996/04/18  15:23:45  jont
 *  initbasis moves to basis
 *
 *  Revision 1.2  1996/04/02  09:42:52  stephenb
 *  Replace UnixOS_.stat by UnixOS_.fstat
 *
 *  Revision 1.1  1996/02/29  16:54:11  jont
 *  new unit
 *  Moved from __unixprimio.sml for common naming scheme with NT
 *
 *  Revision 1.5  1996/01/29  08:38:41  stephenb
 *  Update wrt change in UnixOS_.write.
 *
 *  Revision 1.4  1996/01/23  13:49:00  stephenb
 *  OS reorganisation: since OS specific code is no longer in the
 *  pervasive library, any use of MLWorks.OS.Unix changes to using
 *  UnixOS structure.  Note that the UnixOS_ structure is being
 *  hardwired in rather than turning UnixPrimIO into a functor.
 *
 *  Revision 1.3  1995/09/12  09:59:23  daveb
 *  Word conversions are temporarily in abeyance.
 *
 *  Revision 1.2  1995/05/10  14:46:03  daveb
 *  Added support for blocking, seek, stat, etc.
 *
 *
 *)

require "^.basis.__word8_vector";
require "^.basis.__char_array";
require "^.basis.__char_vector";
require "^.basis.os_prim_io";
require "^.basis.__bin_prim_io";
require "^.basis.__text_prim_io";
require "^.basis.__io";
require "__unixos";

structure OSPrimIO : OS_PRIM_IO =
struct

  type bin_reader = BinPrimIO.reader
  type bin_writer = BinPrimIO.writer
  type text_reader = TextPrimIO.reader
  type text_writer = TextPrimIO.writer
  type file_desc = UnixOS_.FileSys.file_desc


  (*                                         *)
  (* Readers and Writers for Unix filesystem *)
  (*                                         *)

  val FROM_BEGINNING = 0     (* magic numbers for seek *)
  val FROM_CURRENT   = 1
  

  fun mkUnixReader
       {fd: file_desc, name: string, initialPos: BinPrimIO.pos,
        initialBlockMode: bool} =
    let
      val blockMode = ref initialBlockMode
      val pos = ref initialPos

      fun ensureBlockMode b =
	if !blockMode = b then
	  ()
	else
	  (UnixOS_.set_block_mode (fd, b);
	   blockMode := b)

      val stringsize = size

      val {size, blksize, ...} = UnixOS_.FileSys.fstat fd
    in
      BinPrimIO.augmentReader
        (BinPrimIO.RD
	   {readVec =
	      SOME (fn i =>
	              (ensureBlockMode true;
	               let val result = UnixOS_.read (fd, i)
		       in
		         pos := !pos + Word8Vector.length result;
			 result
		       end)),
            readVecNB =
	      SOME (fn i =>
	              (ensureBlockMode false;
	               let val result =
			     UnixOS_.read (fd, i)
		       in
		         pos := !pos + Word8Vector.length result;
			 SOME result
		       end)
	               handle
	                 UnixOS_.WouldBlock => NONE),
            readArr = NONE,
            readArrNB = NONE,
            block = NONE,
            canInput = SOME (fn () => UnixOS_.can_input fd <> 0),
            avail = fn() => SOME(UnixOS_.size fd - 
                                   UnixOS_.seek(fd,0,FROM_CURRENT)),
            name = name,
            chunkSize =  blksize,
            close = fn () => UnixOS_.IO.close fd,
            getPos = SOME(fn () => !pos),
            setPos = SOME(fn newPos =>
		       (ignore(UnixOS_.seek (fd, newPos,FROM_BEGINNING));
		        pos := newPos)),
            endPos = SOME(fn () => size),
            verifyPos = SOME(fn() => UnixOS_.seek(fd,0,FROM_CURRENT)),
	    ioDesc=SOME (UnixOS_.FileSys.fdToIOD fd)})
    end

  fun openRd filename =
    mkUnixReader
      {fd = UnixOS_.open_ (filename, UnixOS_.o_rdonly, 0),
       name = filename,
       initialPos = (* Position.fromDefault *) 0,
       initialBlockMode = true}






  fun mkUnixWriter
       {fd: file_desc, name: string, blocksize: int, size: int,
        initialPos: BinPrimIO.pos, initialBlockMode: bool} =
    let
      val blockMode = ref initialBlockMode
      val pos = ref initialPos

      fun ensureBlockMode b =
	if !blockMode = b then
	  ()
	else
	  (UnixOS_.set_block_mode (fd, b);
	   blockMode := b)
    in
      BinPrimIO.augmentWriter
        (BinPrimIO.WR
           {writeVec =
	      SOME (fn {buf, i, sz} => 
	              (ensureBlockMode true;
	               let
			 val nelems = case sz of
			   SOME i => i
			 | NONE => Word8Vector.length buf - i
			 val result = UnixOS_.write (fd, buf, i, nelems)
		       in
		         pos := !pos + result;
			 result
		       end)),
            writeVecNB =
	      SOME (fn {buf, i, sz} => 
	              (ensureBlockMode false;
	               let
			 val nelems = case sz of
			   SOME i => i
			 | NONE => Word8Vector.length buf - i
			 val result = UnixOS_.write (fd, buf, i, nelems)
		       in
		         pos := !pos + result;
			 SOME result
		       end)
	               handle
	                 UnixOS_.WouldBlock => NONE),
            writeArrNB = NONE,
            writeArr = NONE,
            block = NONE,
            canOutput = NONE,
            name = name,
            chunkSize = blocksize,
            close = fn () => UnixOS_.IO.close fd,
            getPos = SOME(fn () => !pos),
            setPos = SOME(fn newPos =>
		       (ignore(UnixOS_.seek (fd, newPos,FROM_BEGINNING));
		        pos := newPos)),
            endPos = SOME(fn () => size),
            verifyPos = SOME(fn() => UnixOS_.seek(fd,0,FROM_CURRENT)),
	    ioDesc=SOME (UnixOS_.FileSys.fdToIOD fd)})
    end

   
  fun openWr filename =
    let 
      val fd = UnixOS_.open_ (filename, UnixOS_.o_wronly
                                       +UnixOS_.o_creat
                                       +UnixOS_.o_trunc, 438)
			                           (* 438 = 0666 *)
      val {size, blksize, ...} = UnixOS_.FileSys.fstat fd
    in
      mkUnixWriter
        {fd = fd,
         name = filename,
	 blocksize = blksize,
	 size = size,
         initialPos = (* Position.fromDefault *) 0,
         initialBlockMode = true}
    end



  fun openApp filename =
    let 
      val fd = UnixOS_.open_ (filename, UnixOS_.o_wronly
                                       +UnixOS_.o_append
                                       +UnixOS_.o_creat, 438)
		                                   (* 438 = 0666 *)
      val {size, blksize, ...} = UnixOS_.FileSys.fstat fd
    in
      mkUnixWriter
        {fd = fd,
         name = filename,
	 blocksize = blksize,
	 size = size,
         initialPos = (* Position.fromDefault *) size,
         initialBlockMode = true}
    end



  fun openString s =
    let
      val pos = ref 0
      val len = size s
        
      fun stringReadVec i = 
        if !pos>=len then "" else
        (CharVector.extract(s,!pos,if !pos+i>=len
                                    then (pos:=len;NONE)
                                  else (pos:=(!pos+i);SOME i)))

      fun stringReadArr {buf,i,sz} =
        if !pos>=len then 0 else
        let val startPos = !pos
          val num_elems = case sz
                            of NONE => (pos:=len;
                                        len-startPos)
                             | (SOME n) =>
                                 if !pos+n>=len then
                                   (pos:=len;
                                    len-startPos)
                                 else (pos:=(!pos+n); n)
        in
          CharArray.copyVec {src=s, si= !pos, len=SOME num_elems,
                             dst=buf, di=i};
          num_elems
        end
      
    in
      TextPrimIO.RD
      {readVec=SOME(stringReadVec),
       readArr=SOME(stringReadArr),
       readVecNB=SOME(SOME o stringReadVec),
       readArrNB=SOME(SOME o stringReadArr),
       block=NONE,
       canInput=SOME(fn ()=> !pos< (len-1)),
       avail=fn()=> SOME(len-(!pos)),
       name="<stringIn>",
       chunkSize=1,
       close=fn () => pos:=len-1,
       getPos=SOME(fn()=> !pos),
       setPos=SOME(fn i => pos:=i),
       endPos=SOME(fn()=> len-1),
       verifyPos=SOME(fn() => !pos),
       ioDesc=NONE}
    end









  (* unix standard IO readers and writers. *)


  val terminalOut = 
    let 
      val fd = UnixOS_.FileSys.stdout
      val {blksize, ...} = UnixOS_.FileSys.fstat fd
    in
      mkUnixWriter
      {fd = fd,
       name = "<stdOut>",
       size = 0,
       blocksize = blksize,
       initialPos = 0,
       initialBlockMode = true}
    end


  val terminalErr =
    let 
      val fd = UnixOS_.FileSys.stderr
      val {blksize, ...} = UnixOS_.FileSys.fstat fd
    in
      mkUnixWriter
      {fd = fd,
       name = "<stdErr>",
       size = 0,
       blocksize = 1,
       initialPos = 0,
       initialBlockMode = true}
    end


         (* note that in the following reader and writers, getPos and setPos
          * have to handle SysErr --- this occurs when one tries to seek
          * on redirected input (for example, when creating guib.img).  In
          * this case, it is best to return default values. *)



  local
    open MLWorks.Internal.StandardIO
    val cast = MLWorks.Internal.Value.cast
  in
    val stdIn = BinPrimIO.augmentReader
      (BinPrimIO.RD
       {readVec = SOME (fn i => cast (#get(#input(currentIO()))) i),
        readVecNB =NONE,
        readArr = NONE,
        readArrNB = NONE,
        block = NONE,
        canInput = SOME(fn ()=>valOf(#can_input(#input(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported),
        name = "<stdIn>",
        avail = fn()=>NONE,
        chunkSize =  1,                        (* arbitrary! *)
        close = fn () =>
          raise IO.Io
                  {name = "<stdIn>",
                   function = "close",
                   cause = Fail "Cannot close stdIn"},
        getPos = SOME(fn ()=> valOf(#get_pos(#input(currentIO())))()
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => 0),
        setPos = SOME(fn newPos => valOf(#set_pos(#input(currentIO()))) newPos
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => ()),
        endPos = NONE,
        verifyPos = SOME(fn ()=> valOf(#get_pos(#input(currentIO())))()
                      handle Option => raise IO.RandomAccessNotSupported
                           | MLWorks.Internal.Error.SysErr _ => 0),
        ioDesc = NONE}) (* this value cannot be redirected dynamically*)
      
    val stdOut =
      BinPrimIO.augmentWriter
      (BinPrimIO.WR
       {writeVec = SOME (fn s => #put(#output(currentIO())) (cast s)),
       writeVecNB = NONE,
       writeArrNB = NONE,
       writeArr = NONE,
       block = NONE,
       canOutput = SOME(fn () => valOf(#can_output(#output(currentIO())))()
                        handle Option => true),
       name = "<stdOut>",
       chunkSize = 1,               (* arbitrary! *)
       close = fn () =>
         raise IO.Io
                 {name = "<stdOut>",
                  function = "close",
                  cause = Fail "Cannot close stdOut"},
       getPos = SOME(fn ()=> valOf(#get_pos(#output(currentIO())))()
                 handle Option => raise IO.RandomAccessNotSupported
                      | MLWorks.Internal.Error.SysErr _ => 0),
       setPos = SOME(fn newPos => valOf(#set_pos(#output(currentIO()))) newPos
                     handle Option => raise IO.RandomAccessNotSupported
                          | MLWorks.Internal.Error.SysErr _ => ()),
       endPos = NONE,
       verifyPos = SOME(fn ()=> valOf(#get_pos(#output(currentIO())))()
                 handle Option => raise IO.RandomAccessNotSupported
                      | MLWorks.Internal.Error.SysErr _ => 0),
       ioDesc=NONE})   
      
    val stdErr =
      BinPrimIO.augmentWriter
      (BinPrimIO.WR
       {writeVec = SOME (fn s => #put(#error(currentIO())) (cast s)),
       writeVecNB = NONE,
       writeArrNB = NONE,
       writeArr = NONE,
       block = NONE,
       canOutput = SOME(fn ()=> valOf(#can_output(#error(currentIO())))()
                       handle Option => raise IO.RandomAccessNotSupported),
       name = "<stdErr>",
       chunkSize = 1,               (* arbitrary! *)
       close = fn () =>
         raise IO.Io
                 {name = "<stdErr>",
                  function = "close",
                  cause = Fail "Cannot close stdErr"},
       getPos = SOME(fn () => valOf(#get_pos(#error(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => 0),
       setPos = SOME(fn newPos => valOf(#set_pos(#error(currentIO()))) newPos
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => ()),
       endPos = NONE,
       verifyPos = SOME(fn () => valOf(#get_pos(#error(currentIO()))) ()
                       handle Option => raise IO.RandomAccessNotSupported
                            | MLWorks.Internal.Error.SysErr _ => 0),
       ioDesc=NONE})   
      
  end



    

  (* On Unix, text is binary *) (* HACK !!!!! *)
  (* We should do this properly *)
  fun translateIn x = MLWorks.Internal.Value.cast x
  fun translateOut x = MLWorks.Internal.Value.cast x

end


@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 *  Revision 1.15  1999/02/02  16:01:56  mitchell
 *  [Bug #190500]
 *  Remove redundant require statements
 *
@


1.14
log
@[Bug #30413]
Rename stdErr stream stdErr rather than StdOut
@
text
@d12 4
a134 2
require "^.basis.__word8";
require "^.basis.__word8_array";
a140 1
require "^.basis.__position";
@


1.13
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d12 4
d494 1
a494 1
       name = "<stdOut>",
@


1.12
log
@[Bug #30197]
Change exception Fail "RandomAccessNotSupported" to
IO.RandomAccessNotSupported.
@
text
@d12 5
d207 1
a207 1
		       (UnixOS_.seek (fd, newPos,FROM_BEGINNING);
d277 1
a277 1
		       (UnixOS_.seek (fd, newPos,FROM_BEGINNING);
@


1.12.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 5
 *  Revision 1.12  1997/07/15  15:06:52  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to
 *  IO.RandomAccessNotSupported.
 *
@


1.12.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 5
 *  Revision 1.12  1997/07/15  15:06:52  brucem
 *  [Bug #30197]
 *  Change exception Fail "RandomAccessNotSupported" to
 *  IO.RandomAccessNotSupported.
 *
@


1.11
log
@[Bug #30192]
Made attempts to close stdIn etc. raise IO.Io.
@
text
@d12 4
d425 1
a425 1
                       handle Option => raise Fail "RandomAccessNotSupported"),
d435 1
a435 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d438 1
a438 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d442 1
a442 1
                      handle Option => raise Fail "RandomAccessNotSupported"
d464 1
a464 1
                 handle Option => raise Fail "RandomAccessNotSupported"
d467 1
a467 1
                     handle Option => raise Fail "RandomAccessNotSupported"
d471 1
a471 1
                 handle Option => raise Fail "RandomAccessNotSupported"
d484 1
a484 1
                       handle Option => raise Fail "RandomAccessNotSupported"),
d493 1
a493 1
                       handle Option => raise Fail "RandomAccessNotSupported"
d496 1
a496 1
                       handle Option => raise Fail "RandomAccessNotSupported"
d500 1
a500 1
                       handle Option => raise Fail "RandomAccessNotSupported"
@


1.10
log
@[Bug #20045]
Ensure getPos for writes return position rather than size of last write
@
text
@d12 4
d127 1
a129 1

d425 5
a429 1
        close = fn () => #close(#input(currentIO()))(),
d454 5
a458 1
       close = fn() => #close(#output(currentIO()))(),
d483 5
a487 1
       close = fn () => #close(#error(currentIO()))(),
@


1.9
log
@[Bug #1960]
tidying up stdErr writer
@
text
@d12 4
d238 1
a238 1
		         pos := result;
d250 1
a250 1
		         pos := result;
@


1.9.1.1
log
@branched from 1.9
@
text
@a11 4
 *  Revision 1.9  1997/03/24  13:19:15  andreww
 *  [Bug #1960]
 *  tidying up stdErr writer
 *
@


1.9.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 *  Revision 1.9.1.1  1997/05/12  10:52:50  hope
 *  branched from 1.9
 *
@


1.9.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 *  Revision 1.9.1.1  1997/05/12  10:52:50  hope
 *  branched from 1.9
 *
@


1.9.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 *  Revision 1.9.1.1  1997/05/12  10:52:50  hope
 *  branched from 1.9
 *
@


1.9.1.1.1.2
log
@[Bug #20045]
Merging from trunk into MLWorks_11.
Ensure getPos for writes return position rather than size of last write
@
text
@a11 3
 *  Revision 1.9.1.1.1.1  1997/07/28  18:35:03  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d241 1
a241 1
		         pos := !pos + result;
d253 1
a253 1
		         pos := !pos + result;
@


1.9.1.1.1.3
log
@[Bug #30192]
Merging into MLWorks_11 - Made attempts to close stdIn etc. raise IO.Io.
@
text
@a11 6
 *
 *  Revision 1.9.1.1.1.2  1997/08/08  09:01:01  johnh
 *  [Bug #20045]
 *  Merging from trunk into MLWorks_11.
 *  Ensure getPos for writes return position rather than size of last write
 *
a128 1
require "^.basis.__io";
d131 1
d427 1
a427 5
        close = fn () =>
          raise IO.Io
                  {name = "<stdIn>",
                   function = "close",
                   cause = Fail "Cannot close stdIn"},
d452 1
a452 5
       close = fn () =>
         raise IO.Io
                 {name = "<stdOut>",
                  function = "close",
                  cause = Fail "Cannot close stdOut"},
d477 1
a477 5
       close = fn () =>
         raise IO.Io
                 {name = "<stdErr>",
                  function = "close",
                  cause = Fail "Cannot close stdErr"},
@


1.9.1.1.1.4
log
@[Bug #30197]
Merging into MLWorks_11.
Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
@
text
@a11 3
 *  Revision 1.9.1.1.1.3  1997/08/08  09:13:08  johnh
 *  [Bug #30192]
 *  Merging into MLWorks_11 - Made attempts to close stdIn etc. raise IO.Io.
d429 1
a429 1
                       handle Option => raise IO.RandomAccessNotSupported),
d439 1
a439 1
                      handle Option => raise IO.RandomAccessNotSupported
d442 1
a442 1
                      handle Option => raise IO.RandomAccessNotSupported
d446 1
a446 1
                      handle Option => raise IO.RandomAccessNotSupported
d468 1
a468 1
                 handle Option => raise IO.RandomAccessNotSupported
d471 1
a471 1
                     handle Option => raise IO.RandomAccessNotSupported
d475 1
a475 1
                 handle Option => raise IO.RandomAccessNotSupported
d488 1
a488 1
                       handle Option => raise IO.RandomAccessNotSupported),
d497 1
a497 1
                       handle Option => raise IO.RandomAccessNotSupported
d500 1
a500 1
                       handle Option => raise IO.RandomAccessNotSupported
d504 1
a504 1
                       handle Option => raise IO.RandomAccessNotSupported
@


1.9.1.1.1.4.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 5
 *  Revision 1.9.1.1.1.4  1997/08/08  09:27:32  johnh
 *  [Bug #30197]
 *  Merging into MLWorks_11.
 *  Change exception Fail "RandomAccessNotSupported" to IO.RandomAccessNotSupported.
 *
@


1.8
log
@[Bug #1892]
rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
@
text
@d12 4
d474 1
a474 1
       endPos = SOME(fn () => raise Fail "RandomAccessNotSupported"),
@


1.7
log
@[Bug #1757]
renamed __char{array,vector} to __char_{array,vector}
@
text
@d12 4
d107 2
a108 2
require "^.basis.__word8array";
require "^.basis.__word8vector";
@


1.6
log
@Remove references to basis.toplevel
@
text
@d12 3
d105 2
a106 2
require "^.basis.__chararray";
require "^.basis.__charvector";
@


1.6.4.1
log
@branched from 1.6
@
text
@a11 3
 *  Revision 1.6  1996/10/21  15:22:56  jont
 *  Remove references to basis.toplevel
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a11 3
 *  Revision 1.6  1996/10/21  15:22:56  jont
 *  Remove references to basis.toplevel
 *
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a11 3
 *  Revision 1.6.3.1  1996/12/17  18:19:16  hope
 *  branched from 1.6
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a11 3
 *  Revision 1.6  1996/10/21  15:22:56  jont
 *  Remove references to basis.toplevel
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a11 3
 *  Revision 1.6  1996/10/21  15:22:56  jont
 *  Remove references to basis.toplevel
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a11 3
 *  Revision 1.6.1.1  1996/11/14  13:23:15  hope
 *  branched from 1.6
 *
@


1.5
log
@[Bug #1554]
Add a call to UnixOS.fdToIOD now that file descriptors and
io descriptors aren't the same type.
l
@
text
@d12 6
a106 1
require "^.basis.toplevel";
@


1.5.3.1
log
@branched from 1.5
@
text
@a11 6
 *  Revision 1.5  1996/08/21  11:02:47  stephenb
 *  [Bug #1554]
 *  Add a call to UnixOS.fdToIOD now that file descriptors and
 *  io descriptors aren't the same type.
 *  l
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a11 6
 *  Revision 1.5  1996/08/21  11:02:47  stephenb
 *  [Bug #1554]
 *  Add a call to UnixOS.fdToIOD now that file descriptors and
 *  io descriptors aren't the same type.
 *  l
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a11 6
 *  Revision 1.5  1996/08/21  11:02:47  stephenb
 *  [Bug #1554]
 *  Add a call to UnixOS.fdToIOD now that file descriptors and
 *  io descriptors aren't the same type.
 *  l
 *
@


1.4
log
@[Bug #1537]
File primIO records will return io Descriptors
@
text
@d12 4
d178 1
a178 1
	    ioDesc=SOME fd})
d248 1
a248 1
	    ioDesc=SOME fd})
d404 1
a404 1
                           | MLWorks.Internal.SysErr _ => 0),
d407 1
a407 1
                           | MLWorks.Internal.SysErr _ => ()),
d411 1
a411 1
                           | MLWorks.Internal.SysErr _ => 0),
d429 1
a429 1
                      | MLWorks.Internal.SysErr _ => 0),
d432 1
a432 1
                          | MLWorks.Internal.SysErr _ => ()),
d436 1
a436 1
                      | MLWorks.Internal.SysErr _ => 0),
d454 1
a454 1
                            | MLWorks.Internal.SysErr _ => 0),
d457 1
a457 1
                            | MLWorks.Internal.SysErr _ => ()),
d461 1
a461 1
                            | MLWorks.Internal.SysErr _ => 0),
@


1.3
log
@[Bug #1536]
BinPrimIO.vector no longer shares with string.
@
text
@d12 4
d174 1
a174 1
	    ioDesc=NONE})
d244 1
a244 1
	    ioDesc=NONE})
@


1.2
log
@[Bug #1530]
Ensuring that length counters are set appropriately.
@
text
@d12 4
d150 1
a150 1
		         pos := !pos + stringsize result;
d379 1
d383 1
a383 1
       {readVec = SOME (fn i => #get(#input(currentIO())) i),
d409 1
a409 1
       {writeVec = SOME (fn s => #put(#output(currentIO())) s),
d434 1
a434 1
       {writeVec = SOME (fn s => #put(#error(currentIO())) s),
@


1.1
log
@new unit
[Bug 1453]: updated wrt May 30 basis doc, and renamed from __primio.sml
@
text
@d11 5
a15 1
 *  $Log: __primio.sml,v $
d284 1
d286 1
a286 1
                                    then (pos:=len-1;NONE)
d290 1
d293 1
a293 1
                            of NONE => (pos:=len-1;
d297 1
a297 1
                                   (pos:=len-1;
@
