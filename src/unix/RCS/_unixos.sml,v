head	1.29;
access;
symbols
	MLW_daveb_inline_1_4_99:1.29.1
	MLWorks_21c0_1999_03_25:1.29
	MLWorks_20c1_1998_08_20:1.26
	MLWorks_20c0_1998_08_04:1.26
	MLWorks_20b2c2_1998_06_19:1.26
	MLWorks_20b2_Windows_1998_06_12:1.26
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.25
	MLWorks_11r1:1.24.1.1.1.1.1
	MLWorks_workspace_97:1.25.2
	MLWorks_dt_wizard:1.25.1
	MLWorks_11c0_1997_09_09:1.24.1.1.1.1
	MLWorks_10r3:1.24.1.1.3
	MLWorks_10r2_551:1.24.1.1.2
	MLWorks_11:1.24.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.24.1.1
	MLWorks_20m0_1997_06_20:1.25
	MLWorks_1_0_r2c2_1997_06_14:1.24.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.24.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.24.1
	MLWorks_BugFix_1997_04_24:1.24
	MLWorks_1_0_r2_Win32_1997_04_11:1.24
	MLWorks_1_0_r2_Unix_1997_04_04:1.24
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.22.3.1.1
	MLWorks_gui_1996_12_18:1.22.4
	MLWorks_1_0_Win32_1996_12_17:1.22.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.22.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.22.1.1
	MLWorks_1_0_Irix_1996_11_28:1.22.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.22.2
	MLWorks_1_0_Unix_1996_11_14:1.22.1
	MLWorks_Open_Beta2_1996_10_11:1.20.3
	MLWorks_License_dev:1.20.2
	MLWorks_1_open_beta_1996_09_13:1.20.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.16
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13;
locks; strict;
comment	@ * @;


1.29
date	99.03.22.17.02.25;	author mitchell;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	99.03.14.12.13.53;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	99.03.03.14.20.14;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	97.11.09.17.51.29;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	97.05.27.13.33.47;	author jkbrook;	state Exp;
branches
	1.25.1.1
	1.25.2.1;
next	1.24;

1.24
date	97.03.18.11.04.24;	author andreww;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	97.01.15.12.22.44;	author io;	state Exp;
branches;
next	1.22;

1.22
date	96.11.08.14.29.29;	author matthew;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1
	1.22.4.1;
next	1.21;

1.21
date	96.10.21.15.23.32;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	96.08.21.09.37.33;	author stephenb;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1;
next	1.19;

1.19
date	96.08.09.10.34.28;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	96.07.18.13.38.48;	author andreww;	state Exp;
branches;
next	1.17;

1.17
date	96.07.12.17.01.01;	author andreww;	state Exp;
branches;
next	1.16;

1.16
date	96.06.19.09.44.29;	author stephenb;	state Exp;
branches;
next	1.15;

1.15
date	96.06.10.12.05.20;	author stephenb;	state Exp;
branches;
next	1.14;

1.14
date	96.06.07.15.03.58;	author andreww;	state Exp;
branches;
next	1.13;

1.13
date	96.05.29.12.35.03;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.05.28.11.10.19;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.05.16.14.10.44;	author stephenb;	state Exp;
branches;
next	1.10;

1.10
date	96.05.08.13.53.34;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	96.05.03.15.51.31;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	96.04.02.08.25.59;	author stephenb;	state Exp;
branches;
next	1.7;

1.7
date	96.04.01.11.08.48;	author stephenb;	state Exp;
branches;
next	1.6;

1.6
date	96.03.20.12.21.33;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.01.29.16.58.02;	author stephenb;	state Exp;
branches;
next	1.4;

1.4
date	96.01.24.16.57.25;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.01.23.09.52.27;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.01.22.14.46.04;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.01.22.09.27.27;	author stephenb;	state Exp;
branches;
next	;

1.20.1.1
date	96.09.13.11.42.34;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.10.07.16.35.41;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.10.17.11.54.46;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	96.11.14.13.23.07;	author hope;	state Exp;
branches
	1.22.1.1.1.1;
next	;

1.22.1.1.1.1
date	96.11.28.15.33.36;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.11.22.18.40.09;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.12.17.18.19.10;	author hope;	state Exp;
branches
	1.22.3.1.1.1;
next	;

1.22.3.1.1.1
date	97.02.24.12.13.28;	author hope;	state Exp;
branches;
next	;

1.22.4.1
date	96.12.18.10.14.33;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	97.05.12.10.52.43;	author hope;	state Exp;
branches
	1.24.1.1.1.1
	1.24.1.1.2.1
	1.24.1.1.3.1;
next	;

1.24.1.1.1.1
date	97.07.28.18.35.18;	author daveb;	state Exp;
branches
	1.24.1.1.1.1.1.1;
next	;

1.24.1.1.1.1.1.1
date	97.10.07.12.00.55;	author jkbrook;	state Exp;
branches;
next	;

1.24.1.1.2.1
date	97.09.08.17.27.58;	author daveb;	state Exp;
branches;
next	;

1.24.1.1.3.1
date	97.09.09.14.25.11;	author daveb;	state Exp;
branches;
next	;

1.25.1.1
date	97.09.10.19.43.55;	author brucem;	state Exp;
branches;
next	;

1.25.2.1
date	97.09.11.21.11.20;	author daveb;	state Exp;
branches;
next	;

1.29.1.1
date	99.04.01.18.09.26;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
OS reorganisation: separated out of the pervasive library so
that it only has to be supported on UNIX OSes.
@


1.29
log
@[Bug #30286]
Support for the Unix structure
@
text
@(* Copyright (C) 1996 Harlequin Ltd.
 *
 * See ./unixos.sml
 *
 * Revision Log
 * ------------
 *
 * $Log: _unixos.sml,v $
 * Revision 1.28  1999/03/14  12:13:53  daveb
 * [Bug #190521]
 * OS.FileSys.readDir now returns an option type.
 *
 * Revision 1.27  1999/03/03  14:20:14  johnh
 * Change spec of fork_execv
 *
 * Revision 1.26  1997/11/09  17:51:29  jont
 * [Bug #30089]
 * Modify rusage to return stime and utime as basis times
 *
 * Revision 1.25  1997/05/27  13:33:47  jkbrook
 * [Bug #01749]
 * Use __sys_word for SysWord structure
 *
 * Revision 1.24  1997/03/18  11:04:24  andreww
 * [Bug #1431]
 * changing runtime call name of POSIX.Error.ErrorMsg/Name to make it
 * compatible with Win32 implementation.
 *
 * Revision 1.23  1997/01/15  12:22:44  io
 * [Bug #1892]
 * rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
 *
 * Revision 1.22  1996/11/08  14:29:29  matthew
 * [Bug #1661]
 * Changing io_desc to iodesc
 *
 * Revision 1.21  1996/10/21  15:23:32  jont
 * Remove references to basis.toplevel
 *
 * Revision 1.20  1996/08/21  09:37:33  stephenb
 * [Bug #1554]
 * Redefine syserror and file_desc in terms of the newly
 * created MLWorks.Internal.Error.syserror and
 * MLWorks.Internal.IO.file_desc.
 *
 * Revision 1.19  1996/08/09  10:34:28  daveb
 * [Bug #1536]
 * Made read and write use Word8Vector.vectors instead of strings.
 *
 * Revision 1.18  1996/07/18  13:38:48  andreww
 * [Bug #1453]
 * provding size function on file descriptors for up-to-date
 * revised basis IO.
 *
 * Revision 1.17  1996/07/12  17:01:01  andreww
 * propagating changes to system calls etc. engendered by the need to dynamically
 * redirect IO through the GUI.
 *
 * Revision 1.16  1996/06/19  09:44:29  stephenb
 * Change the FileSys.dirstream type so that it holds some state to
 * indicate whether the stream is closed or not.  This is needed because
 * rewinddir doesn't give an error if you pass it a closed stream.
 *
 * Revision 1.15  1996/06/10  12:05:20  stephenb
 * Add POSIX.FileSys.{openf,creatf,creat,link,umask} and
 * POSIX>FileSys.O.*
 *
 * Revision 1.14  1996/06/07  15:03:58  andreww
 * exposing unix IO constants.
 *
 * Revision 1.13  1996/05/29  12:35:03  matthew
 * Fixing problem with SysErr
 *
 * Revision 1.12  1996/05/28  11:10:19  stephenb
 * Implement POSIX.Error.{errorName,syserror}
 *
 * Revision 1.11  1996/05/16  14:10:44  stephenb
 * Introduce the Error structure, move SysErr ... etc. into it
 * and implement Error.errorMsg.
 *
 * Revision 1.10  1996/05/08  13:53:34  matthew
 * Changes to Int structure
 *
 * Revision 1.9  1996/05/03  15:51:31  stephenb
 * Add file_desc type so that it can be used as the basis for the
 * various file descriptor types that are required by OS and POSIX.
 * Also started POSIXification of the structure i.e. various routines
 * that were at the top level are now embedded in sub-structures that
 * follow the signatures defined in the latest basis revision.
 *
 * Revision 1.8  1996/04/02  08:25:59  stephenb
 * typo fix: tmpnam -> tmpname
 *
 * Revision 1.7  1996/04/01  11:08:48  stephenb
 * Rename the Unix exception to be SysErr.  This simplifies the
 * implementation of the Unix version of the OS interface in the
 * latest basis.
 *
 * Revision 1.6  1996/03/20  12:21:33  matthew
 * Changes for language revisions
 *
 * Revision 1.5  1996/01/29  16:58:02  stephenb
 * unix.c reorganisation: change vfork_XXX to fork_XXX since vfork
 * isn't important as far as the user is concerned, all they are
 * after is a cheap fork and exec.
 *
 *  Revision 1.4  1996/01/24  16:57:25  stephenb
 *  Add af+imox. af_inet, sock_stream, sock_dgram so that the
 *  editor no longer has to pass magic constants to the socket call.
 *
 *  Revision 1.3  1996/01/23  09:52:27  stephenb
 *  Change a require to be NJSML compatible.
 *
 *  Revision 1.2  1996/01/22  14:46:04  stephenb
 *  Bind the declared exceptions to their C counterparts.
 *
 *  Revision 1.1  1996/01/22  09:27:27  stephenb
 *  new unit
 *  OS reorganisation: separated out of the pervasive library so
 *  that it only has to be supported on UNIX OSes.
 *
 *
 *)

require "^.basis.__word32";
require "^.basis.__sys_word";
require "^.basis.__word8_vector";
require "^.basis.__position";
require "unixos";
require "__time";

functor UnixOS () : UNIXOS =
struct
  val env = MLWorks.Internal.Runtime.environment

  structure Error = struct
    type syserror = MLWorks.Internal.Error.syserror
    exception SysErr = MLWorks.Internal.Error.SysErr
    val toWord = Word32.fromInt
    val fromWord = Word32.toInt
    val errorMsg = MLWorks.Internal.Error.errorMsg
    val errorName = MLWorks.Internal.Error.errorName
    val syserror = MLWorks.Internal.Error.syserror
  end

  exception WouldBlock
  val would_block_ref = env "system os unix exception Would Block"
  val _ = would_block_ref := WouldBlock

  datatype sockaddr = SOCKADDR_UNIX of string
  val environment : unit -> string list = env "system os unix environment"
  val rusage :
    unit ->
      {idrss    : int,            (* integral resident set size *)
       inblock	: int,            (* block input operations *)
       isrss	: int,            (* currently 0 *)
       ixrss	: int,            (* currently 0 *)
       majflt	: int,            (* page faults requiring physical I/O *)
       maxrss	: int,            (* maximum resident set size *)
       minflt	: int,            (* page faults not requiring physical I/O *)
       msgrcv	: int,            (* messages received *)
       msgsnd	: int,            (* messages sent *)
       nivcsw	: int,            (* involuntary context switches *)
       nsignals	: int,            (* signals received *)
       nswap	: int,            (* swaps *)
       nvcsw	: int,            (* voluntary context switches *)
       oublock	: int,            (* block output operations *)
       stime	: Time.time,      (* system time used *)
       utime	: Time.time}      (* user time used *) = env "system os unix rusage"

  val getsockname : int -> sockaddr = env "system os unix getsockname"
  val getpeername : int -> sockaddr = env "system os unix getpeername"
  val accept : int -> int * sockaddr = env "system os unix accept"
  val listen : int * int -> unit = env "system os unix listen"
  val execve : string * string list * string list -> unit = env "system os unix execve"
  val execv : string * string list -> unit = env "system os unix execv"
  val execvp : string * string list -> unit = env "system os unix execvp"
  val fork_execve : string * string list * string list * int * int * int -> int  = env "system os unix fork_execve"
  val fork_execv : string * string list * int * int * int -> int = env "system os unix fork_execv"
  val fork_execvp : string * string list -> int = env "system os unix fork_execvp"



  datatype iodesc = IODESC of int


  structure FileSys = struct

    type file_desc = MLWorks.Internal.IO.file_desc
    fun fdToWord (MLWorks.Internal.IO.FILE_DESC i) = Word32.fromInt i
    fun wordToFD w = MLWorks.Internal.IO.FILE_DESC (Word32.toInt w)
    fun fdToIOD (MLWorks.Internal.IO.FILE_DESC fd) = IODESC fd
    fun iodToFD (IODESC iod) = MLWorks.Internal.IO.FILE_DESC iod

    datatype dirstream = DIRSTREAM of MLWorks.Internal.Value.T * bool
    val opendir : string -> dirstream = env "POSIX.FileSys.opendir"
    val readdir : dirstream -> string option = env "POSIX.FileSys.readdir"
    val rewinddir : dirstream -> unit = env "POSIX.FileSys.rewinddir"
    val closedir : dirstream -> unit = env "POSIX.FileSys.closedir"

    val chdir : string -> unit = env "POSIX.FileSys.chdir"
    val getcwd : unit -> string = env "POSIX.FileSys.getcwd"

    val stdin = MLWorks.Internal.IO.FILE_DESC 0
    val stdout = MLWorks.Internal.IO.FILE_DESC 1
    val stderr = MLWorks.Internal.IO.FILE_DESC 2

    structure S = struct
      type mode = int
      val irwxo = 511
    end


    structure O = struct
      type flags = int
      val append   : flags = env "POSIX.FileSys.O.append"
      val excl     : flags = env "POSIX.FileSys.O.excl"
      val noctty   : flags = env "POSIX.FileSys.O.noctty"
      val nonblock : flags = env "POSIX.FileSys.O.nonblock"
      val sync     : flags = env "POSIX.FileSys.O.sync"
      val trunc    : flags = env "POSIX.FileSys.O.trunc"
    end

    datatype open_mode = O_RDONLY | O_WRONLY | O_RDWR

    val openf : string * open_mode * O.flags -> file_desc =
      env "POSIX.FileSys.openf"

    val createf : string * open_mode * O.flags * S.mode -> file_desc =
      env "POSIX.FileSys.createf"

    val creat : string * S.mode -> file_desc = env "POSIX.FileSys.creat"

    val umask : S.mode -> S.mode = env "POSIX.FileSys.umask"

    val link : {new: string, old: string} -> unit = env "POSIX.FileSys.link"

    val mkdir : string * S.mode -> unit = env "POSIX.FileSys.mkdir"

    val rmdir : string -> unit = env "POSIX.FileSys.rmdir"

    val rename : {new: string, old: string} -> unit = env "POSIX.FileSys.rename"
    val unlink : string -> unit = env "POSIX.FileSys.unlink"

    val readlink : string -> string = env "POSIX.FileSys.readlink"


    datatype dev = DEV of int

    fun wordToDev w = DEV (SysWord.toInt w)
    fun devToWord (DEV d) = SysWord.fromInt d


    datatype ino = I_NODE of int

    fun wordToIno w = I_NODE (SysWord.toInt w)
    fun inoToWord (I_NODE i) = SysWord.fromInt i


    structure ST = struct
      type stat = 
        {dev	: dev,
         ino	: ino,
         mode	: S.mode,
         nlink	: int,
         uid	: int,
         gid	: int,
         rdev	: int,
         size	: Position.int,
         atime	: Time.time,
         mtime	: Time.time,
         ctime	: Time.time,
         blksize: int,
         blocks	: int}

      val isDir:  stat -> bool = env "POSIX.FileSys.ST.isdir"
      val isChr:  stat -> bool = env "POSIX.FileSys.ST.ischr"
      val isBlk:  stat -> bool = env "POSIX.FileSys.ST.isblk"
      val isReg:  stat -> bool = env "POSIX.FileSys.ST.isreg"
      val isFIFO: stat -> bool = env "POSIX.FileSys.ST.isfifo"
      val isLink: stat -> bool = env "POSIX.FileSys.ST.islink"
      val isSock: stat -> bool = env "POSIX.FileSys.ST.issock"

      val mode : stat -> S.mode = #mode
      val ino : stat -> ino = #ino
      val dev : stat -> dev = #dev
      val size : stat -> Position.int = #size
      val mtime : stat -> Time.time = #mtime

    end

    val stat : string -> ST.stat = env "POSIX.FileSys.stat"
    val fstat : file_desc -> ST.stat = env "POSIX.FileSys.fstat"
    val lstat : string -> ST.stat = env "POSIX.FileSys.lstat"

    datatype access_mode = A_READ | A_WRITE | A_EXEC

    val access : (string * access_mode list) -> bool = env "POSIX.FileSys.access"

    local
      val utime_ : (string * Time.time * Time.time) -> unit = env "system os unix utime"
    in
      fun utime (pathName, NONE) = 
        let
          val now = Time.now ();
        in 
          utime_ (pathName, now, now)
        end
      |   utime (pathName, SOME {actime, modtime}) =
        utime_ (pathName, actime, modtime)
    end

  end

  structure IO = struct
    val close : FileSys.file_desc -> unit = MLWorks.Internal.IO.close
  end

  val can_input : FileSys.file_desc -> int = MLWorks.Internal.IO.can_input

  val set_block_mode : FileSys.file_desc * bool -> unit = 
    env "system os unix set block mode"

  val open_ : string * int * int -> FileSys.file_desc = 
    env "system os unix open"

  val read : FileSys.file_desc * int -> Word8Vector.vector = 
    MLWorks.Internal.Value.cast MLWorks.Internal.IO.read

  val write : FileSys.file_desc * Word8Vector.vector * int * int -> int = 
    MLWorks.Internal.Value.cast MLWorks.Internal.IO.write


  val seek : FileSys.file_desc * int * int-> int = MLWorks.Internal.IO.seek 

  val size : FileSys.file_desc -> int = FileSys.ST.size o FileSys.fstat

  val socket : int * int * int -> FileSys.file_desc = 
                                       env "system os unix socket"
  val connect : FileSys.file_desc * sockaddr -> unit = 
                                       env "system os unix connect"

  val bind : int * sockaddr -> int = env "system os unix bind"

    datatype passwd =
    PASSWD of {dir	: string,
	       gecos	: string,
	       gid	: int,
	       name	: string,
	       passwd	: string,
	       shell	: string,
	       uid	: int}


  val getpwent : unit -> passwd = env "system os unix getpwent"
  val setpwent : unit -> unit = env "system os unix setpwent"
  val endpwent : unit -> unit = env "system os unix endpwent"
  val getpwuid : int -> passwd = env "system os unix getpwuid"
  val getpwnam : string -> passwd = env "system os unix getpwnam"
  val kill : int * int -> unit = env "system os unix kill"

  val af_unix : int    = env "system os unix af_unix"
  val af_inet : int     = env "system os unix af_inet"
  val sock_stream : int = env "system os unix sock_stream"
  val sock_dgram  : int = env "system os unix sock_dgram"
  val o_rdonly    : int = env "system os unix o_rdonly"
  val o_wronly    : int = env "system os unix o_wronly"
  val o_append    : int = env "system os unix o_append"
  val o_creat     : int = env "system os unix o_creat"
  val o_trunc     : int = env "system os unix o_trunc"

end


@


1.29.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.29  1999/03/22  17:02:25  mitchell
 * [Bug #30286]
 * Support for the Unix structure
 *
@


1.28
log
@[Bug #190521]
OS.FileSys.readDir now returns an option type.
@
text
@d9 4
d178 1
a178 1
  val fork_execve : string * string list * string list -> int  = env "system os unix fork_execve"
@


1.27
log
@Change spec of fork_execv
@
text
@d9 3
d193 1
a193 1
    val readdir : dirstream -> string = env "POSIX.FileSys.readdir"
@


1.26
log
@[Bug #30089]
Modify rusage to return stime and utime as basis times
@
text
@d9 4
d172 1
a172 1
  val fork_execv : string * string list -> int = env "system os unix fork_execv"
@


1.25
log
@[Bug #01749]
Use __sys_word for SysWord structure
@
text
@d9 4
d157 2
a158 2
       stime	: MLWorks.Time.Interval.T, (* system time used *)
       utime	: MLWorks.Time.Interval.T} (* user time used *) = env "system os unix rusage"
@


1.25.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 4
 * Revision 1.25  1997/05/27  13:33:47  jkbrook
 * [Bug #01749]
 * Use __sys_word for SysWord structure
 *
@


1.25.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 4
 * Revision 1.25  1997/05/27  13:33:47  jkbrook
 * [Bug #01749]
 * Use __sys_word for SysWord structure
 *
@


1.24
log
@[Bug #1431]
changing runtime call name of POSIX.Error.ErrorMsg/Name to make it
compatible with Win32 implementation.
@
text
@d9 5
d111 1
@


1.24.1.1
log
@branched from 1.24
@
text
@a8 5
 * Revision 1.24  1997/03/18  11:04:24  andreww
 * [Bug #1431]
 * changing runtime call name of POSIX.Error.ErrorMsg/Name to make it
 * compatible with Win32 implementation.
 *
@


1.24.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.24.1.1  1997/05/12  10:52:43  hope
 * branched from 1.24
 *
@


1.24.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.24.1.1  1997/05/12  10:52:43  hope
 * branched from 1.24
 *
@


1.24.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.24.1.1  1997/05/12  10:52:43  hope
 * branched from 1.24
 *
@


1.24.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.24.1.1.1.1  1997/07/28  18:35:18  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.23
log
@[Bug #1892]
rename __word{8,16,32}{array,vector} to __word{8,16,32}_{array,vector}
@
text
@d9 4
d120 3
a122 3
    val errorMsg : syserror -> string = env "POSIX.Error.errorMsg"
    val errorName : syserror -> string = env "POSIX.Error.errorName"
    val syserror : string -> syserror option = env "POSIX.Error.syserror"
@


1.22
log
@[Bug #1661]
Changing io_desc to iodesc
@
text
@d9 4
d102 1
a102 1
require "^.basis.__word8vector";
@


1.22.4.1
log
@branched from 1.22
@
text
@a8 4
 * Revision 1.22  1996/11/08  14:29:29  matthew
 * [Bug #1661]
 * Changing io_desc to iodesc
 *
@


1.22.3.1
log
@branched from 1.22
@
text
@a8 4
 * Revision 1.22  1996/11/08  14:29:29  matthew
 * [Bug #1661]
 * Changing io_desc to iodesc
 *
@


1.22.3.1.1.1
log
@branched from 1.22.3.1
@
text
@a8 3
 * Revision 1.22.3.1  1996/12/17  18:19:10  hope
 * branched from 1.22
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a8 4
 * Revision 1.22  1996/11/08  14:29:29  matthew
 * [Bug #1661]
 * Changing io_desc to iodesc
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a8 4
 * Revision 1.22  1996/11/08  14:29:29  matthew
 * [Bug #1661]
 * Changing io_desc to iodesc
 *
@


1.22.1.1.1.1
log
@branched from 1.22.1.1
@
text
@a8 3
 * Revision 1.22.1.1  1996/11/14  13:23:07  hope
 * branched from 1.22
 *
@


1.21
log
@Remove references to basis.toplevel
@
text
@d9 3
d155 1
a155 1
  datatype io_desc = IO_DESC of int
d163 2
a164 2
    fun fdToIOD (MLWorks.Internal.IO.FILE_DESC fd) = IO_DESC fd
    fun iodToFD (IO_DESC iod) = MLWorks.Internal.IO.FILE_DESC iod
@


1.20
log
@[Bug #1554]
Redefine syserror and file_desc in terms of the newly
created MLWorks.Internal.Error.syserror and
MLWorks.Internal.IO.file_desc.
@
text
@d9 6
a93 1
require "^.basis.toplevel";
@


1.20.3.1
log
@branched from 1.20
@
text
@a8 6
 * Revision 1.20  1996/08/21  09:37:33  stephenb
 * [Bug #1554]
 * Redefine syserror and file_desc in terms of the newly
 * created MLWorks.Internal.Error.syserror and
 * MLWorks.Internal.IO.file_desc.
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a8 6
 * Revision 1.20  1996/08/21  09:37:33  stephenb
 * [Bug #1554]
 * Redefine syserror and file_desc in terms of the newly
 * created MLWorks.Internal.Error.syserror and
 * MLWorks.Internal.IO.file_desc.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a8 6
 * Revision 1.20  1996/08/21  09:37:33  stephenb
 * [Bug #1554]
 * Redefine syserror and file_desc in terms of the newly
 * created MLWorks.Internal.Error.syserror and
 * MLWorks.Internal.IO.file_desc.
 *
@


1.19
log
@[Bug #1536]
Made read and write use Word8Vector.vectors instead of strings.
@
text
@d9 4
d100 2
a101 2
    type syserror = int
    exception SysErr = MLWorks.Internal.SysErr
d145 5
d151 7
a157 3
    datatype file_desc = FILE_DESC of int
    fun fdToWord (FILE_DESC i) = Word32.fromInt i
    fun wordToFD w = FILE_DESC (Word32.toInt w)
d163 1
d166 4
a169 3
    val stdin = FILE_DESC 0
    val stdout = FILE_DESC 1
    val stderr = FILE_DESC 2
d279 1
a279 2
    val close : FileSys.file_desc -> unit = 
      fn(FileSys.FILE_DESC fd)=> MLWorks.Internal.StandardIO.close fd
d282 2
a283 2
  val can_input : FileSys.file_desc -> int =
    fn (FileSys.FILE_DESC fd) => MLWorks.Internal.StandardIO.can_input fd
d285 2
a286 1
                                        env "system os unix set block mode"
d288 2
a289 1
                                        env "system os unix open"
d291 1
a291 3
        fn (FileSys.FILE_DESC fd,i)=>
	  MLWorks.Internal.Value.cast
	    (MLWorks.Internal.StandardIO.read (fd, i))
d294 4
a297 10
        fn (FileSys.FILE_DESC fd, v, i, j)=>
	  let
	    val s = MLWorks.Internal.Value.cast v
	  in
            MLWorks.Internal.StandardIO.write (fd, s, i, j)
	  end

  val seek : FileSys.file_desc * int * int-> int =
            fn (FileSys.FILE_DESC fd,d,meth) =>
                    MLWorks.Internal.StandardIO.seek (fd,d,meth)
@


1.18
log
@[Bug #1453]
provding size function on file descriptors for up-to-date
revised basis IO.
@
text
@d9 5
d86 1
d274 13
a286 5
  val read : FileSys.file_desc * int -> string = 
         fn (FileSys.FILE_DESC fd,i)=>MLWorks.Internal.StandardIO.read(fd,i)
  val write : FileSys.file_desc * string * int * int -> int = 
         fn(FileSys.FILE_DESC fd,s,i,j)=>
                       MLWorks.Internal.StandardIO.write(fd,s,i,j)
@


1.17
log
@propagating changes to system calls etc. engendered by the need to dynamically
redirect IO through the GUI.
@
text
@d9 4
d273 6
a278 5
  val seek : FileSys.file_desc * int -> unit =
         fn(FileSys.FILE_DESC fd,i)=>
                    (MLWorks.Internal.StandardIO.seek(fd,i,0);())
                                        (* 0=MAGIC NUMBER for seek from start*)
                                        (* see rts/src/OS/Unix/unix.c        *)
@


1.16
log
@Change the FileSys.dirstream type so that it holds some state to
indicate whether the stream is closed or not.  This is needed because
rewinddir doesn't give an error if you pass it a closed stream.
@
text
@d9 5
d254 2
a255 1
    val close : FileSys.file_desc -> unit = env "POSIX.IO.close"
d258 20
a277 8
  val can_input : FileSys.file_desc -> int = env "system os unix can input"
  val set_block_mode : FileSys.file_desc * bool -> unit = env "system os unix set block mode"
  val open_ : string * int * int -> FileSys.file_desc = env "system os unix open"
  val read : FileSys.file_desc * int -> string = env "system os unix read"
  val write : FileSys.file_desc * string * int * int -> int = env "system os unix write"
  val seek : FileSys.file_desc * int -> unit = env "system os unix seek"
  val socket : int * int * int -> FileSys.file_desc = env "system os unix socket"
  val connect : FileSys.file_desc * sockaddr -> unit = env "system os unix connect"
d309 2
@


1.15
log
@Add POSIX.FileSys.{openf,creatf,creat,link,umask} and
POSIX>FileSys.O.*
@
text
@d9 4
d130 1
a130 1
    datatype dirstream = DIR of MLWorks.Internal.Value.T
@


1.14
log
@exposing unix IO constants.
@
text
@d9 3
d142 25
d168 1
d170 1
d173 1
@


1.13
log
@Fixing problem with SysErr
@
text
@d9 3
d249 6
@


1.12
log
@Implement POSIX.Error.{errorName,syserror}
@
text
@d9 3
d72 1
a72 3
    exception SysErr of (string * syserror option)
    val sysErrRef = env "exception syserr"
    val _ = sysErrRef := SysErr ("", NONE)
@


1.11
log
@Introduce the Error structure, move SysErr ... etc. into it
and implement Error.errorMsg.
@
text
@d9 4
d75 2
@


1.10
log
@Changes to Int structure
@
text
@d9 3
d53 3
a55 1
require "^.basis.__word";
d63 9
a71 4
  type syserror = int
  exception SysErr of (string * syserror MLWorks.Option.option)
  val sysErrRef = env "exception syserr"
  val _ = sysErrRef := SysErr ("", MLWorks.Option.NONE)
a78 1
  val realpath : string -> string = env "system os unix realpath"
a97 2
  val tmpName : unit -> string = env "system os unix tmpname"

d111 2
a112 2
    fun fdToWord (FILE_DESC i) = Word.fromInt i (* XXX: should be SysWord *)
    fun wordToFD w = FILE_DESC (Word.toInt w)   (* XXX: should be SysWord *)
d114 6
a119 6
    val opendir : string -> dirstream = env "system os unix opendir"
    val readdir : dirstream -> string = env "system os unix readdir"
    val rewinddir : dirstream -> unit = env "system os unix rewinddir"
    val closedir : dirstream -> unit = env "system os unix closedir"
    val chDir : string -> unit = env "system os unix setwd"
    val getcwd : unit -> string = env "system os unix getwd"
d123 24
a146 4
    val mkdir : string * int -> unit = env "system os unix mkdir"
    val rmdir : string -> unit = env "system os unix rmdir"
    val rename : string * string -> unit = env "system os unix rename"
    val unlink : string -> unit = env "system os unix unlink"
d150 3
a152 3
        {dev	: int,
         ino	: int,
         mode	: int,
d157 1
a157 1
         size	: int,
d164 12
a175 10
      val isDir:  stat -> bool = env "system os unix st isdir"
      val isChr:  stat -> bool = env "system os unix st ischr"
      val isBlk:  stat -> bool = env "system os unix st isblk"
      val isReg:  stat -> bool = env "system os unix st isreg"
      val isFIFO: stat -> bool = env "system os unix st isfifo"
      val isLink: stat -> bool = env "system os unix st islink"
      val isSock: stat -> bool = env "system os unix st issock"

      val size : stat -> int = #size

d180 20
a200 3
    val stat : string -> ST.stat = env "system os unix stat"
    val fstat : file_desc -> ST.stat = env "system os unix fstat"
    val lstat : string -> ST.stat = env "system os unix lstat"
d204 1
a204 1
    val close : FileSys.file_desc -> unit = env "system os unix close"
@


1.9
log
@Add file_desc type so that it can be used as the basis for the
various file descriptor types that are required by OS and POSIX.
Also started POSIXification of the structure i.e. various routines
that were at the top level are now embedded in sub-structures that
follow the signatures defined in the latest basis revision.
@
text
@d9 7
d104 2
a105 2
    val fdToWord = Word.IntCvt.from  (* XXX: should be SysWord *)
    val wordToFD = Word.IntCvt.to    (* XXX: should be SysWord *)
@


1.8
log
@typo fix: tmpnam -> tmpname
@
text
@d9 3
d43 3
a45 1
require "../system/unixos";
a61 2
  val setwd : string -> unit = env "system os unix setwd"
  val getwd : unit -> string = env "system os unix getwd"
a81 34
  structure ST = struct
    type stat = 
      {dev	: int,
       ino	: int,
       mode	: int,
       nlink	: int,
       uid	: int,
       gid	: int,
       rdev	: int,
       size	: int,
       atime	: MLWorks.Time.time,
       mtime	: MLWorks.Time.time,
       ctime	: MLWorks.Time.time,
       blksize	: int,
       blocks	: int}

    val isDir:  stat -> bool = env "system os unix st isdir"
    val isChr:  stat -> bool = env "system os unix st ischr"
    val isBlk:  stat -> bool = env "system os unix st isblk"
    val isReg:  stat -> bool = env "system os unix st isreg"
    val isFIFO: stat -> bool = env "system os unix st isfifo"
    val isLink: stat -> bool = env "system os unix st islink"
    val isSock: stat -> bool = env "system os unix st issock"

    val size : stat -> int = #size

    val mtime : stat -> MLWorks.Time.time = #mtime

  end

  val stat : string -> ST.stat = env "system os unix stat"
  val fstat : int -> ST.stat = env "system os unix fstat"
  val lstat : string -> ST.stat = env "system os unix lstat"
  val rename : string * string -> unit = env "system os unix rename"
a83 10
  val open_ : string * int * int -> int = env "system os unix open"
  val close : int -> unit = env "system os unix close"
  val unlink : string -> unit = env "system os unix unlink"
  val set_block_mode : int * bool -> unit = env "system os unix set block mode"
  val can_input : int -> int = env "system os unix can input"
  val seek : int * int -> unit = env "system os unix seek"
  val write : int * string * int * int -> int = env "system os unix write"
  val read : int * int -> string = env "system os unix read"
  val socket : int * int * int -> int = env "system os unix socket"
  val bind : int * sockaddr -> int = env "system os unix bind"
a85 1
  val connect : int * sockaddr -> unit = env "system os unix connect"
d94 72
a165 8
  datatype dir = DIR of MLWorks.Internal.Value.T
  val opendir : string -> dir = env "system os unix opendir"
  val readdir : dir -> string = env "system os unix readdir"
  val rewinddir : dir -> unit = env "system os unix rewinddir"
  val closedir : dir -> unit = env "system os unix closedir"
  val mkdir : string * int -> unit = env "system os unix mkdir"
  val rmdir : string -> unit = env "system os unix rmdir"
  datatype passwd =
d173 2
@


1.7
log
@Rename the Unix exception to be SysErr.  This simplifies the
implementation of the Unix version of the OS interface in the
latest basis.
@
text
@d9 5
d113 1
a113 1
  val tmpName : unit -> string = env "system os unix tmpnam"
@


1.6
log
@Changes for language revisions
@
text
@d9 3
d39 7
a45 1
  exception Unix of string
a46 3
  val env = MLWorks.Internal.Runtime.environment
  val unix_ref = env "system os unix exception Unix"
  val _ = unix_ref := Unix ""
d49 1
d73 3
a75 2
  val stat :
    int ->
d88 22
a109 1
       blocks	: int} = env "system os unix stat"
d134 1
@


1.5
log
@unix.c reorganisation: change vfork_XXX to fork_XXX since vfork
isn't important as far as the user is concerned, all they are
after is a cheap fork and exec.
@
text
@d9 5
d38 1
a38 1
  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
d44 58
a101 27
  val environment = env "system os unix environment"
  val setwd = env "system os unix setwd"
  val getwd = env "system os unix getwd"
  val realpath = env "system os unix realpath"
  val rusage = env "system os unix rusage"
  val stat = env "system os unix stat"
  val open_ = env "system os unix open"
  val close = env "system os unix close"
  val unlink = env "system os unix unlink"
  val set_block_mode = env "system os unix set block mode"
  val can_input = env "system os unix can input"
  val seek = env "system os unix seek"
  val write = env "system os unix write"
  val read = env "system os unix read"
  val socket = env "system os unix socket"
  val bind = env "system os unix bind"
  val getsockname = env "system os unix getsockname"
  val getpeername = env "system os unix getpeername"
  val connect = env "system os unix connect"
  val accept = env "system os unix accept"
  val listen = env "system os unix listen"
  val execve = env "system os unix execve"
  val execv = env "system os unix execv"
  val execvp = env "system os unix execvp"
  val fork_execve = env "system os unix fork_execve"
  val fork_execv = env "system os unix fork_execv"
  val fork_execvp = env "system os unix fork_execvp"
d103 5
a107 5
  val opendir = env "system os unix opendir"
  val readdir = env "system os unix readdir"
  val closedir = env "system os unix closedir"
  val mkdir = env "system os unix mkdir"
  val rmdir = env "system os unix rmdir"
d116 6
a121 6
  val getpwent = env "system os unix getpwent"
  val setpwent = env "system os unix setpwent"
  val endpwent = env "system os unix endpwent"
  val getpwuid = env "system os unix getpwuid"
  val getpwnam = env "system os unix getpwnam"
  val kill = env "system os unix kill"
d123 4
a126 4
  val af_unix     = env "system os unix af_unix"
  val af_inet     = env "system os unix af_inet"
  val sock_stream = env "system os unix sock_stream"
  val sock_dgram  = env "system os unix sock_dgram"
@


1.4
log
@Add af+imox. af_inet, sock_stream, sock_dgram so that the
editor no longer has to pass magic constants to the socket call.
@
text
@d9 4
d63 3
a65 3
  val vfork_execve = env "system os unix vfork_execve"
  val vfork_execv = env "system os unix vfork_execv"
  val vfork_execvp = env "system os unix vfork_execvp"
@


1.3
log
@Change a require to be NJSML compatible.
@
text
@d9 3
d82 5
@


1.2
log
@Bind the declared exceptions to their C counterparts.
@
text
@d9 3
d20 1
a20 1
require "unixos";
@


1.1
log
@new unit
OS reorganisation: separated out of the pervasive library so
that it only has to be supported on UNIX OSes.
@
text
@d8 6
a13 1
 * $Log$
d23 5
a28 1
  fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)
@
