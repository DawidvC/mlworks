head	1.21;
access;
symbols
	MLW_daveb_inline_1_4_99:1.21.1
	MLWorks_21c0_1999_03_25:1.21
	MLWorks_20c1_1998_08_20:1.21
	MLWorks_20c0_1998_08_04:1.21
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.21
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.20
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.19.8.1.1.1.1
	MLWorks_workspace_97:1.19.10
	MLWorks_dt_wizard:1.19.9
	MLWorks_11c0_1997_09_09:1.19.8.1.1.1
	MLWorks_10r3:1.19.8.1.3
	MLWorks_10r2_551:1.19.8.1.2
	MLWorks_11:1.19.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.8.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.19.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.8
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.19.6.1.1
	MLWorks_gui_1996_12_18:1.19.7
	MLWorks_1_0_Win32_1996_12_17:1.19.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.4.1
	MLWorks_1_0_Irix_1996_11_28:1.19.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.5
	MLWorks_1_0_Unix_1996_11_14:1.19.4
	MLWorks_Open_Beta2_1996_10_11:1.19.3
	MLWorks_License_dev:1.19.2
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.19
	MLWorks_Beta_1996_06_07:1.19
	MLWorks_Beta_1996_06_06:1.19
	MLWorks_Beta_1996_06_05:1.19
	MLWorks_Beta_1996_06_03:1.19
	MLWorks_Beta_1996_05_31:1.19
	MLWorks_Beta_1996_05_30:1.19
	ML_beta_release_12/08/94:1.18
	ML_beta_release_03/08/94:1.18
	ML_revised_beta_release_25/05/94:1.17
	ML_final_beta_release_02/03/94:1.16
	mlworks-28-01-1994:1.16
	Release:1.15
	mlworks-beta-01-09-1993:1.15
	MLWorks-1-0-4-29/01/1993:1.15
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.15
	checkpoint_17_08_92:1.14
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.21
date	98.02.19.16.24.11;	author mitchell;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	97.11.25.18.37.28;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	95.03.29.16.10.25;	author brianm;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1
	1.19.5.1
	1.19.6.1
	1.19.7.1
	1.19.8.1
	1.19.9.1
	1.19.10.1;
next	1.18;

1.18
date	94.05.26.13.56.12;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	94.03.10.12.16.36;	author io;	state Exp;
branches;
next	1.16;

1.16
date	93.10.28.15.34.35;	author nickh;	state Exp;
branches;
next	1.15;

1.15
date	92.09.25.14.55.25;	author clive;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	92.08.13.16.39.46;	author davidt;	state Exp;
branches;
next	1.13;

1.13
date	92.07.28.13.10.33;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.06.25.08.58.00;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	92.04.16.12.12.44;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.02.03.12.33.29;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	91.11.21.17.01.32;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.10.09.11.11.01;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	91.10.08.11.13.36;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.09.30.11.41.05;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.09.20.16.40.25;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.09.17.13.48.31;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.09.05.11.52.49;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.06.13.19.42.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.15.57.13;	author colin;	state Exp;
branches;
next	;

1.15.1.1
date	92.09.25.14.55.25;	author jont;	state Exp;
branches;
next	1.15.1.2;

1.15.1.2
date	93.10.27.16.19.15;	author nickh;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.43.05;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.10.07.16.36.16;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.10.17.11.55.17;	author hope;	state Exp;
branches;
next	;

1.19.4.1
date	96.11.14.13.23.39;	author hope;	state Exp;
branches
	1.19.4.1.1.1;
next	;

1.19.4.1.1.1
date	96.11.28.15.34.16;	author hope;	state Exp;
branches;
next	;

1.19.5.1
date	96.11.22.18.40.44;	author hope;	state Exp;
branches;
next	;

1.19.6.1
date	96.12.17.18.19.42;	author hope;	state Exp;
branches
	1.19.6.1.1.1;
next	;

1.19.6.1.1.1
date	97.02.24.12.14.05;	author hope;	state Exp;
branches;
next	;

1.19.7.1
date	96.12.18.10.15.12;	author hope;	state Exp;
branches;
next	;

1.19.8.1
date	97.05.12.10.53.11;	author hope;	state Exp;
branches
	1.19.8.1.1.1
	1.19.8.1.2.1
	1.19.8.1.3.1;
next	;

1.19.8.1.1.1
date	97.07.28.18.35.47;	author daveb;	state Exp;
branches
	1.19.8.1.1.1.1.1;
next	;

1.19.8.1.1.1.1.1
date	97.10.07.12.01.13;	author jkbrook;	state Exp;
branches;
next	;

1.19.8.1.2.1
date	97.09.08.17.28.16;	author daveb;	state Exp;
branches;
next	;

1.19.8.1.3.1
date	97.09.09.14.25.48;	author daveb;	state Exp;
branches;
next	;

1.19.9.1
date	97.09.10.19.44.31;	author brucem;	state Exp;
branches;
next	;

1.19.10.1
date	97.09.11.21.11.49;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	99.04.01.18.09.44;	author daveb;	state Exp;
branches;
next	;


desc
@List Utilities
@


1.21
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _lists.sml the functor *)
(*
$Log: _lists.sml,v $
 * Revision 1.20  1997/11/25  18:37:28  jont
 * [Bug #30328]
 * Add early exit fold function findOption
 *
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
Revision 1.18  1994/05/26  13:56:12  jont
Added msort and check_order

Revision 1.17  1994/03/10  12:16:36  io
adding last

Revision 1.16  1993/10/28  15:34:35  nickh
Merging fixes.

Revision 1.15.1.2  1993/10/27  16:19:15  nickh
Removed function number_with_size, which was (a) difficult to figure out,
(b) inefficient, and (c) only used in particular places in the lambda
optimiser.

Revision 1.15.1.1  1992/09/25  14:55:25  jont
Fork for bug fixing

Revision 1.15  1992/09/25  14:55:25  clive
Tried to optimise the dorting function a bit

Revision 1.14  1992/08/13  16:39:46  davidt
Removed foldl and foldr functions (use reducel and reducer
instead, they are much faster).

Revision 1.13  1992/07/28  13:10:33  jont
Removed internal currying from filter_length. Modified filter to
make less calls to member

Revision 1.12  1992/06/25  08:58:00  davida
Added filter_outp - it's more elegant and efficient
than filterp (not o P).

Revision 1.11  1992/04/16  12:12:44  jont
Added subset function

Revision 1.10  1992/02/03  12:33:29  clive
Added a new version of assoc

Revision 1.9  1991/11/21  17:01:32  jont
Added copyright message

Revision 1.8  91/10/09  11:11:01  davidt

Put in the functions unzip, iterate, filter_length and
number_with_size. Also made a few of the existing implementations
tail recursive.

Revision 1.7  91/10/08  11:13:36  jont
Added number_from and number_from_by_one

Revision 1.6  91/09/30  11:41:05  richard
Added list printing function.

Revision 1.6  91/09/30  10:42:22  richard
Added list print function.

Revision 1.5  91/09/20  16:40:25  davida
Added qsort

Revision 1.4  91/09/17  13:48:31  richard
Added findp function.

Revision 1.3  91/09/05  11:52:49  davida
Added new functions, improved length

Revision 1.2  91/06/13  19:42:00  jont
Added zip function for joining two lists of equal length
Also exception Tl for tl([])

Revision 1.1  91/06/07  15:57:13  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "lists";

functor Lists() :LISTS =
  struct
    exception Assoc
    exception Find
    exception Hd
    exception Last
    exception Nth
    exception Tl
    exception Zip

    fun length ([], acc) = acc
	 | length (_::t, acc) = length(t, 1+acc)

    fun member (_,[]) = false
	 | member (a,h::t) = (a=h) orelse member(a,t)

    fun last [x] = x
	 | last (_::xs) = last xs
	 | last [] = raise Last


    fun rev_append ([],ys) = ys
      | rev_append (x::xs,ys) = rev_append(xs,x::ys)

    fun adjoin(a,l) = if member(a,l) then l else a::l     

    local

      fun adjoin2(a,b,acc) = if a = b then acc else adjoin(a,acc)

      fun filter_sub([],acc) = acc
        | filter_sub([a],acc) = adjoin(a,acc)
        | filter_sub(a::(l as b :: _),acc) = filter_sub(l,adjoin2(a,b,acc))

    in

	 fun filter [] = []
	   | filter(arg as [_]) = arg
	   | filter(x :: xs) = filter_sub(xs, [x])

    end

    val rev_remove_dups = filter
 
    fun filter_length filter_fun filter_list =
	 let
	   fun loop([], n) = n
	     | loop(h :: t, n) = loop(t, if filter_fun h then n+1 else n)
	 in
	   loop(filter_list, 0)
	 end

    fun hd ([]) = raise Hd
	 | hd (h::t) = h
	   
    fun tl ([]) = raise Tl
	 | tl (h::t) = t
	   
    fun difference (nil,x) = nil
	 | difference (hd::tl,x) = 
	   if member (hd,x) then
	      difference (tl,x)
	   else
	      hd :: difference(tl,x)
	      
    fun sublist ([],l2) = true
	 | sublist (h::t,l2) = 
	   member (h,l2) andalso sublist (t,l2)

    fun iterate f [] = ()
	 | iterate f (h :: t) = (ignore(f h); iterate f t)
			  
    fun zip (L1,L2) =
	 let
	   fun loop ([], [], res) = rev res
	     | loop (h1 :: t1, h2 :: t2, res) = loop (t1, t2, (h1, h2) :: res)
	     | loop _ = raise Zip
	 in
	   loop (L1,L2,[])
	 end

    fun unzip L =
	 let
	   fun loop ([], res1, res2) = (rev res1, rev res2)
	     | loop ((p,q)::xs, res1, res2) = loop(xs, p :: res1, q :: res2)
	 in
	   loop (L,[],[])
	 end


    (*  Find the nth element, starting from zero  *)

    fun nth (0, x::_) = x
	 | nth (n, _::t) = nth(n-1,t)
	 | nth _ = raise Nth

    fun nthtail (_,[]) = raise Nth
      | nthtail (0,_::t) = t
      | nthtail (n,_::t) = nthtail(n-1,t)


    (*  Return the number of elements before the given one  *)

    fun find (x,xs) = 
	  let
	     fun count (n,z::zs) = if x=z then n else count(n+1,zs)
	       | count _ = raise Find
	  in 
	     count (0,xs)
	  end


    (*  Find and return an element satisfying a predicate *)

    fun findp predicate list =
	 let
	   fun f [] = raise Find
	     | f (x::xs) =
	       if predicate x then x else f xs
	 in
	   f list
	 end


    (*  filterp: keep elements satisfying P *)

    fun filterp P list =
	  let
	     fun filter (acc,[]) = rev acc
	       | filter (acc,x::xs) = if P x
					 then filter(x::acc,xs)
				      else filter(acc,xs)
	  in
	     filter ([],list)
	  end


    (*  filter_outp: remove elements satisfying P *)

    fun filter_outp P list =
	  let
	     fun filter (acc,[]) = rev acc
	       | filter (acc,x::xs) = if P x
					 then filter(acc,xs)
				      else filter(x::acc,xs)
	  in
	     filter ([],list)
	  end


    (*  Partition a into elements satisfying P and those not  *)

    fun partition P list =
	  let
	     fun part (ys,ns,[]) = (rev ys, rev ns)
	       | part (ys,ns,x::xs) = if P x 
					 then part(x::ys,ns,xs)
				      else part(ys,x::ns,xs)
	  in 
	     part ([],[],list)
	  end

    (* Produce a list with the elements numbered *)

    fun number_from (L, start : int, inc : int, num_fun) =
	 let
	   fun loop ([], result, next) = (rev result, next)
	     | loop (x :: xs, result, i) =
	       loop (xs, (x, num_fun i) :: result, i+inc)
	 in
	   loop (L, [], start)
	 end

    fun number_from_by_one (l, i, f) = number_from (l, i, 1, f)

    (*  Test if a predicate holds for all elements  *)
 
    fun forall P =
	  let 
	     fun test [] = true
	       | test (x::xs) = (P x) andalso test xs
	  in
	     test
	  end;
  

    (*  Test if a predicate holds for at least one element  *)

    fun exists P =
	  let 
	     fun test [] = false
	       | test (x::xs) = (P x) orelse test xs
	  in
	     test
	  end
  

    (*  Lookup in an association list  *)

    fun assoc (key, list) =
	  let
	     fun ass [] = raise Assoc
	       | ass ((thiskey,value)::kvs) = if thiskey=key
						 then value
					      else ass kvs
	  in
	     ass list
	  end


     fun assoc_returning_others(key,list) = 
       let
         fun ass (others,[]) = raise Assoc
           | ass (others,(this as (thiskey,value))::kvs) = if thiskey=key
             then (rev_append(others, kvs),value)
               else ass(this::others,kvs)
       in
         ass([],list)
       end

    (*  Left associative fold on binary functions  *)

    fun reducel f = 
	  let
	    fun red (acc, []) = acc
	      | red (acc, x::xs) = red (f(acc,x), xs)
	  in 
	    red
	  end

    (*  Right associate fold on binary functions  *)

    fun reducer f (list,i) = 
	 let
	   fun red ([], acc) = acc
	     | red (x::xs, acc) = red (xs, f(x,acc))
	 in
	   red (rev list,i)
	 end

    (* Early exit fold function *)

    fun findOption element_fn =
      let
	   fun search [] = NONE
	     | search (x :: xs) = case element_fn x of
	         NONE => search xs
            | x => x
      in
	   search
      end

    (* quicksort *)

    fun merge (order_fn,args) =
	 let
	   fun do_merge (x,[]) = x
	     | do_merge ([],x) = x
	     | do_merge (arg as (h::t),arg' as (a::b)) =
	       if order_fn (h,a) 
		 then h :: do_merge(t,arg')
	       else a :: do_merge(arg,b)
	 in
	   do_merge args
	 end
      
    fun qsort order_fn [] = []
      | qsort order_fn (arg as [x]) = arg
      | qsort order_fn (arg as [a,b]) =
        if order_fn (a,b)
          then arg
        else [b,a]
      | qsort order_fn (a::(rest as [b,c])) =
        merge(order_fn,([a],if order_fn(b,c) then rest else [c,b]))
      | qsort order_fn [a,b,c,d] =
        merge(order_fn,
              (if order_fn(a,b) 
                 then [a,b] 
               else [b,a],
                 if order_fn(c,d)
                   then [c,d] 
                 else [d,c]))
      | qsort order_fn yukky_list =
        let
          fun qs ([],nice_list) = nice_list
            | qs (pivot::xs, sofar) = 
              let
                fun part (left,right,[]) = qs(left, pivot::(qs (right, sofar)))
                  | part (left,right,y::ys) = if order_fn(y,pivot)
                                                then part (y::left,right,ys)
                                              else part (left,y::right,ys)
              in
                part([],[],xs)
              end
        in
          qs (yukky_list,[])
        end

    local
	 fun split' (0,a,b) = (a,b)
	   | split' (n,a::b,c) = split' (n-1,b,a::c)
	   | split' (n,[],res) = ([],res)

	 fun split l =
	   split' (length (l,0) div 2,l,[])
    in
	 fun msort order_fn l =
	   let
	     fun merge ([],l,acc) = rev_append (acc,l)
	       | merge (l,[],acc) = rev_append (acc,l)
	       | merge (l1 as (a::b),l2 as (c::d),acc) =
		 if order_fn (a,c) then 
		   merge (b,l2,a::acc)
		 else
		   merge (l1,d,c::acc)

	     fun mergesort [] = []
	       | mergesort (arg as [x]) = arg
	       | mergesort (arg as [a,b]) =
		 if order_fn (a,b)
		   then arg
		 else [b,a]
	       | mergesort (arg as [a,b,c]) =
		 if order_fn (a,b)
		   then if order_fn (b,c) then arg
			else
			  if order_fn (a,c) then [a,c,b]
			  else [c,a,b]
		 else
		   if order_fn (a,c) then [b,a,c]
		   else
		     if order_fn (b,c) then [b,c,a]
		     else [c,b,a]
	       | mergesort l =
		 let
		   val (l1,l2) = split (l)
		 in
		   merge (mergesort l1,
			  mergesort l2,
			  [])
		 end
	   in
	     mergesort l
	   end
    end

   (* Print nicely *)

    fun to_string _ [] = "[]"
	 | to_string print_element list =
	   let
	     fun p (s,[]) = s
	       | p (s,[x]) = s ^ print_element x
	       | p (s,x::xs) = p(s ^ print_element x ^ ", " , xs)
	   in
	     "[" ^ p ("", list) ^ "]"
	   end

    fun check_order order_fn =
	 let
	   fun check [] = true
	     | check [_] = true
	     | check (x :: (rest as (y :: z))) =
	       order_fn(x, y) andalso check rest
	 in
	   check
	 end

    val length =
	 fn [] => 0
	  | (_ :: xs) => length(xs, 1)

  end
@


1.21.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.21  1998/02/19  16:24:11  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.20
log
@[Bug #30328]
Add early exit fold function findOption
@
text
@d4 4
d162 1
a162 1
	 | iterate f (h :: t) = (f h; iterate f t)
@


1.19
log
@Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
so that it doesn't use equality types.  Noted that `filter' is actually
a `reverse and remove duplicates' function - so added `rev_remove_dups'.
Incidentally, the new Initial Basis uses `filter' for what we have
named `filterp'.
@
text
@d4 7
d85 1
d89 8
a96 8
    struct
       exception Assoc
       exception Find
       exception Hd
       exception Last
       exception Nth
       exception Tl
       exception Zip
d98 1
a98 1
       fun length ([], acc) = acc
d101 1
a101 1
       fun member (_,[]) = false
d104 1
a104 1
       fun last [x] = x
d109 2
a110 2
       fun rev_append ([],ys) = ys
         | rev_append (x::xs,ys) = rev_append(xs,x::ys)
d112 1
a112 1
       fun adjoin(a,l) = if member(a,l) then l else a::l     
d114 1
a114 1
       local
d116 1
a116 1
         fun adjoin2(a,b,acc) = if a = b then acc else adjoin(a,acc)
d118 3
a120 3
         fun filter_sub([],acc) = acc
           | filter_sub([a],acc) = adjoin(a,acc)
           | filter_sub(a::(l as b :: _),acc) = filter_sub(l,adjoin2(a,b,acc))
d122 1
a122 1
       in
d128 1
a128 1
       end
d130 3
a132 3
       val rev_remove_dups = filter
    
       fun filter_length filter_fun filter_list =
d140 1
a140 1
       fun hd ([]) = raise Hd
d143 1
a143 1
       fun tl ([]) = raise Tl
d146 1
a146 1
       fun difference (nil,x) = nil
d153 1
a153 1
       fun sublist ([],l2) = true
d157 1
a157 1
       fun iterate f [] = ()
d160 1
a160 1
       fun zip (L1,L2) =
d169 1
a169 1
       fun unzip L =
d178 1
a178 1
       (*  Find the nth element, starting from zero  *)
d180 1
a180 1
       fun nth (0, x::_) = x
d184 3
a186 3
       fun nthtail (_,[]) = raise Nth
         | nthtail (0,_::t) = t
         | nthtail (n,_::t) = nthtail(n-1,t)
d189 1
a189 1
       (*  Return the number of elements before the given one  *)
d191 1
a191 1
       fun find (x,xs) = 
d200 1
a200 1
       (*  Find and return an element satisfying a predicate *)
d202 1
a202 1
       fun findp predicate list =
d212 1
a212 1
       (*  filterp: keep elements satisfying P *)
d214 1
a214 1
       fun filterp P list =
d225 1
a225 1
       (*  filter_outp: remove elements satisfying P *)
d227 1
a227 1
       fun filter_outp P list =
d238 1
a238 1
       (*  Partition a into elements satisfying P and those not  *)
d240 1
a240 1
       fun partition P list =
d250 1
a250 1
       (* Produce a list with the elements numbered *)
d252 1
a252 1
       fun number_from (L, start : int, inc : int, num_fun) =
d261 1
a261 1
       fun number_from_by_one (l, i, f) = number_from (l, i, 1, f)
d263 3
a265 3
       (*  Test if a predicate holds for all elements  *)
    
       fun forall P =
d272 1
a272 1
     
d274 1
a274 1
       (*  Test if a predicate holds for at least one element  *)
d276 1
a276 1
       fun exists P =
d283 1
a283 1
     
d285 1
a285 1
       (*  Lookup in an association list  *)
d287 1
a287 1
       fun assoc (key, list) =
d298 9
a306 9
        fun assoc_returning_others(key,list) = 
          let
            fun ass (others,[]) = raise Assoc
              | ass (others,(this as (thiskey,value))::kvs) = if thiskey=key
                then (rev_append(others, kvs),value)
                  else ass(this::others,kvs)
          in
            ass([],list)
          end
d308 1
a308 1
       (*  Left associative fold on binary functions  *)
d310 1
a310 1
       fun reducel f = 
d318 1
a318 1
       (*  Right associate fold on binary functions  *)
d320 1
a320 1
       fun reducer f (list,i) = 
d328 1
a328 1
       (* quicksort *)
d330 13
a342 1
       fun merge (order_fn,args) =
d353 32
a384 32
         
       fun qsort order_fn [] = []
         | qsort order_fn (arg as [x]) = arg
         | qsort order_fn (arg as [a,b]) =
           if order_fn (a,b)
             then arg
           else [b,a]
         | qsort order_fn (a::(rest as [b,c])) =
           merge(order_fn,([a],if order_fn(b,c) then rest else [c,b]))
         | qsort order_fn [a,b,c,d] =
           merge(order_fn,
                 (if order_fn(a,b) 
                    then [a,b] 
                  else [b,a],
                    if order_fn(c,d)
                      then [c,d] 
                    else [d,c]))
         | qsort order_fn yukky_list =
           let
             fun qs ([],nice_list) = nice_list
               | qs (pivot::xs, sofar) = 
                 let
                   fun part (left,right,[]) = qs(left, pivot::(qs (right, sofar)))
                     | part (left,right,y::ys) = if order_fn(y,pivot)
                                                   then part (y::left,right,ys)
                                                 else part (left,y::right,ys)
                 in
                   part([],[],xs)
                 end
           in
             qs (yukky_list,[])
           end
d386 1
a386 1
       local
d393 1
a393 1
       in
d432 1
a432 1
       end
d434 1
a434 1
      (* Print nicely *)
d436 1
a436 1
       fun to_string _ [] = "[]"
d446 1
a446 1
       fun check_order order_fn =
d456 1
a456 1
       val length =
d460 1
a460 1
    end
@


1.19.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.8.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:53:11  hope
 * branched from 1.19
 *
@


1.19.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:53:11  hope
 * branched from 1.19
 *
@


1.19.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.19.8.1  1997/05/12  10:53:11  hope
 * branched from 1.19
 *
@


1.19.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.19.8.1.1.1  1997/07/28  18:35:47  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.19.7.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.6.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.6.1.1.1
log
@branched from 1.19.6.1
@
text
@a3 3
 * Revision 1.19.6.1  1996/12/17  18:19:42  hope
 * branched from 1.19
 *
@


1.19.5.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.4.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.4.1.1.1
log
@branched from 1.19.4.1
@
text
@a3 3
 * Revision 1.19.4.1  1996/11/14  13:23:39  hope
 * branched from 1.19
 *
@


1.19.3.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a3 7
 * Revision 1.19  1995/03/29  16:10:25  brianm
 * Added adjoin, rev_append, nthtail.  Changed signature entry for `last'
 * so that it doesn't use equality types.  Noted that `filter' is actually
 * a `reverse and remove duplicates' function - so added `rev_remove_dups'.
 * Incidentally, the new Initial Basis uses `filter' for what we have
 * named `filterp'.
 *
@


1.18
log
@Added msort and check_order
@
text
@d4 3
d100 14
a113 5
       local 
	 fun filter_sub([],acc) = acc
	   | filter_sub(h::t,acc) = 
	     if member (h,acc) then filter_sub(t,acc)
	     else filter_sub(t,h::acc)
d115 1
d119 1
d121 2
d169 1
d176 5
a180 1
	   
d294 1
a294 1
                then ((rev others) @@ kvs,value)
d322 11
a332 11
     fun merge (order_fn,args) =
       let
         fun do_merge (x,[]) = x
           | do_merge ([],x) = x
           | do_merge (arg as (h::t),arg' as (a::b)) =
             if order_fn (h,a) 
               then h :: do_merge(t,arg')
             else a :: do_merge(arg,b)
       in
         do_merge args
       end
a366 3
	 fun rev' ([],acc) = acc
	   | rev' (a::b,acc) = rev' (b,a::acc)

d376 2
a377 2
	     fun merge ([],l,acc) = rev' (acc,l)
	       | merge (l,[],acc) = rev' (acc,l)
@


1.17
log
@adding last
@
text
@d4 3
d87 2
a88 7
       fun length ([]) = 0
	 | length (_::t) = let
			      fun length' (acc,[]) = acc
				| length' (acc,_::t) = length'(1+acc,t)
			   in
			      length'(1,t)
			   end
d345 50
d408 13
@


1.16
log
@Merging fixes.
@
text
@d4 3
d79 1
a83 1

d94 4
@


1.15
log
@Tried to optimise the dorting function a bit
@
text
@d4 11
a227 14

       (* Produce another kind of list *)

       fun number_with_size (L, start, num_fun) =
	 let
	   fun loop ([], size) = (fn s => [], size)
	     | loop (x :: xs, i) =
	       let val (rest, size) = loop(xs, i+1)
	       in
		 (fn s => (x, num_fun {index = i, size = s}) :: (rest s), size)
	       end
	 in
	   loop (L,start)
	 end
@


1.15.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.15  1992/09/25  14:55:25  clive
Tried to optimise the dorting function a bit

@


1.15.1.2
log
@Removed function number_with_size, which was (a) difficult to figure out,
(b) inefficient, and (c) only used in particular places in the lambda
optimiser.
@
text
@a3 3
Revision 1.15.1.1  1992/09/25  14:55:25  jont
Fork for bug fixing

d220 14
@


1.14
log
@Removed foldl and foldr functions (use reducel and reducer
instead, they are much faster).
@
text
@d4 4
d299 43
a341 15
       fun qsort order_fn yukky_list =
	let
	 fun qs ([],nice_list) = nice_list
	   | qs (pivot::xs, sofar) = 
	     let
		fun part (left,right,[]) = qs(left, pivot::(qs (right, sofar)))
		  | part (left,right,y::ys) = if order_fn(y,pivot)
						 then part (y::left,right,ys)
					      else part (left,y::right,ys)
	     in
		part([],[],xs)
	     end
	in
	   qs (yukky_list,[])
	end
@


1.13
log
@Removed internal currying from filter_length. Modified filter to
make less calls to member
@
text
@d4 4
d109 3
a111 11
	fun sublist ([],l2) = true
	| sublist (h::t,l2) = 
	  member (h,l2) 
	  andalso 
	  sublist (t,l2)

       fun foldl f i [] = i
	 | foldl f i (h :: t) = foldl f (f h i) t
	   
       fun foldr f i [] = i
	 | foldr f i (h :: t) = f h (foldr f i t)
d277 2
a278 2
	     fun red (acc, []) = acc
	       | red (acc, x::xs) = red (f(acc,x), xs)
d280 1
a280 1
	     red
a282 1

d286 6
a291 7
	  let
	     fun red ([], acc) = acc
	       | red (x::xs, acc) = red (xs, f(x,acc))
	  in
	     red (rev list,i)
	  end

@


1.12
log
@Added filter_outp - it's more elegant and efficient
than filterp (not o P).
@
text
@d4 4
d72 1
a72 1
	  
d74 4
a77 4
	 fun filter([],acc) = acc
	   | filter (h::t,acc) = 
	     if member (h,acc) then filter(t,acc)
	     else filter(t,h::acc)
d79 3
a81 1
	 val filter = (fn l => filter(l,[]))
d86 2
a87 2
	   fun loop [] n = n
	     | loop (h :: t) n = loop t (if filter_fun h then n+1 else n)
d89 1
a89 1
	   loop filter_list 0
@


1.11
log
@Added subset function
@
text
@d4 3
d161 1
a161 1
       (*  Filter out those elements not satisfying the predicate P  *)
d169 13
@


1.10
log
@Added a new version of assoc
@
text
@d4 3
d96 6
@


1.9
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_lists.sml,v $
d234 11
@


1.8
log
@
Put in the functions unzip, iterate, filter_length and
number_with_size. Also made a few of the existing implementations
tail recursive.
@
text
@d1 1
d4 6
d35 1
@


1.7
log
@Added number_from and number_from_by_one
@
text
@d3 3
d53 4
a56 6
	  fun filter([],acc) = acc
	    | filter (h::t,acc) = 
	      if member (h,acc) 
		 then 
		    filter(t,acc)
	      else filter(t,h::acc)
d58 1
a58 1
	  val filter = (fn l=>filter(l,[]))
d61 8
a86 4
	   
       fun zip ([], []) = []
	 | zip (h1 :: t1, h2 :: t2) = (h1, h2) :: zip(t1, t2)
	 | zip (_, _) = raise Zip
d88 11
d100 8
d165 8
a172 6
       fun number_from([], i, _, _) = ([], i)
	 | number_from(x :: xs, i, inc : int, num_fun) =
	   let val (rest, i') = number_from(xs, i+inc, inc, num_fun)
	   in
	     ((x, num_fun i) :: rest, i')
	   end
d174 15
a188 1
       fun number_from_by_one(l, i, f) = number_from(l, i, 1, f)
@


1.6
log
@Added list printing function.
@
text
@d3 3
d139 10
@


1.5
log
@Added qsort
@
text
@d3 6
d210 13
@


1.4
log
@Added findp function.
@
text
@d3 3
d185 19
@


1.3
log
@Added new functions, improved length
@
text
@d3 3
d88 12
@


1.2
log
@Added zip function for joining two lists of equal length
Also exception Tl for tl([])
@
text
@d3 4
d15 6
a20 3
      exception Hd
      exception Tl
      exception Zip
a21 2
      fun length ([]) = 0
	| length (h::t) = 1 + (length t)
d23 10
a32 2
      fun member (_,[]) = false
	| member (a,h::t) = (a=h) orelse member(a,t)
d34 33
a66 10
      local 
	fun filter([],acc) = acc
	  | filter (h::t,acc) = 
	    if member (h,acc) 
	      then 
		filter(t,acc)
	    else filter(t,h::acc)
      in
	val filter = (fn l=>filter(l,[]))
      end
a67 2
      fun hd ([]) = raise Hd
	| hd (h::t) = h
d69 1
a69 2
      fun tl ([]) = raise Tl
	| tl (h::t) = t
d71 3
a73 6
      fun difference (nil,x) = nil
	| difference (hd::tl,x) = 
	  if member (hd,x) then
	    difference (tl,x)
	  else
	    hd :: difference(tl,x)
d75 2
a76 2
      fun foldl f i [] = i
	| foldl f i (h :: t) = foldl f (f h i) t
d78 7
a84 2
      fun foldr f i [] = i
	| foldr f i (h :: t) = f h (foldr f i t)
d86 83
a168 3
      fun zip ([], []) = []
      | zip (h1 :: t1, h2 :: t2) = (h1, h2) :: zip(t1, t2)
      | zip (_, _) = raise Zip
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d12 2
d35 1
a35 1
      fun tl ([]) = []
d50 4
a54 2

  
@
