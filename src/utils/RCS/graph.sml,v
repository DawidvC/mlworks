head	1.5;
access;
symbols
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5
	Release:1.5
	mlworks-beta-01-09-1993:1.5
	MLWorks-1-0-4-29/01/1993:1.5
	MLWorks-1-0-3-21/12/1992:1.5
	MLWorks-1-0-2-15/12/1992:1.5
	MLWorks-1-0-1-04/12/1992:1.5
	checkpoint_17_08_92:1.5;
locks; strict;


1.5
date	91.10.15.12.20.51;	author richard;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	91.10.14.14.56.11;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.08.11.15.50;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	91.10.02.09.37.50;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.09.27.14.33.50;	author richard;	state Exp;
branches;
next	;

1.5.1.1
date	91.10.15.12.20.51;	author jont;	state Exp;
branches;
next	;


desc
@Manipulation and colouring of undirected graphs.
@


1.5
log
@Added precolouring, add_many_to_many and add_one_to_many.
@
text
@(* graph.sml the signature *)

(* $Log:	graph.sml,v $
Revision 1.4  91/10/14  14:56:11  richard
Added precolouring and forbidden colours for vertices.

Revision 1.3  91/10/08  11:15:50  richard
Changed to use two representations which are efficient in different
circumstances.

Revision 1.2  91/10/02  09:37:50  richard
Added facilities for directed graphs.

Revision 1.1  91/09/27  14:33:50  richard
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "set";
require "table";


signature GRAPH =

  sig

    structure Table : TABLE
    structure Set   : SET

    type ''a T



    (*  === GRAPH CONSTRUCTION ===  *)


    (*  == Make an empty graph ==
     *
     *  Given an irreflexive ordering function on vertices, this
     *  function returns a graph with no vertices or edges. Two
     *  representations are available: BUILDABLE and SCANNABLE. The
     *  former is efficient to build. A SCANNABLE graph requires an
     *  ordering function.
     *)

    datatype ''a representation =
      BUILDABLE
    | SCANNABLE of (''a * ''a -> bool)

    val empty : ''a representation -> ''a T


    (*  == Convert graph representation ==
     *
     *  Coverts the graph to the representation given.
     *)

    val convert	: ''a representation -> ''a T -> ''a T


    (*  == Add an edge to a graph ==
     *
     *  Returns a new graph with an (undirected) edge from one vertex
     *  to another added. The vertices specified are not checked to
     *  see if they exist in the graph, and will be added
     *  unconditionally.
     *)

    val add_edge   : ''a T * (''a * ''a) -> ''a T


    (*  == Add a directed edge to a graph ==
     *
     *  Returns a new graph with a directed edge from the first vertex
     *  to the second added. The vertices are not checked to see if
     *  they exist in the graph.
     *)

    val add_directed_edge : ''a T * (''a * ''a) -> ''a T


    (*  == Add edges from one to many ==
     *
     *  Adds edges from a single vertex to all the vertices in a
     *  list, using the function supplied. (This allows directed or
     *  undirected edges to be added.)
     *)

    val add_one_to_many :
      (''a T * (''a * ''a) -> ''a T) ->
      (''a T * ''a * ''a list) ->
      ''a T


    (*  == Add edges between all vertices in a list ==
     *
     *  Adds edges from all the vertices in the first list to all the
     *  vertices in the second using the function supplied.
     *)

    val add_many_to_many :
      (''a T * (''a * ''a) -> ''a T) ->
      (''a T * ''a list * ''a list) ->
      ''a T


    (*  == Return adjacent vertices ==
     *
     *  Returns a Set.Set of the vertices which have edges reaching
     *  them from the vertex specified.
     *)

    val adjacent : (''a * ''a T) -> ''a Set.Set


    (*  == Return set of vertices ==
     *
     *  Returns a Set.Set of the vertices in the graph.
     *)

    val vertices : ''a T -> ''a Set.Set



    (*  === COLOUR A GRAPH ===
     *
     *  This is a suite of algorithms for assigning different
     *  `colours' to vertices which have an edge between them. The aim
     *  is to use as few colours as possible.
     *
     *  The datatype colouring_algorithm allows the method used to be
     *  specified, together with parameters which are only relevant to
     *  that method.
     *
     *  Graph colouring will not produce meaningful results if there
     *  are directed edges in the graph.
     *)


    (*  == Colouring algorithms ==
     *
     *  PERFECT: This method will find the optimal colouring of the
     *  graph, and will assign colours to as many vertices as are
     *  possible. However, this is an NP-complete algorithm, and so
     *  will be very slow for graphs which are not small.
     *
     *  GREEDY: This method goes through the vertices in an arbitrary
     *  order, assigning the first colour it can (i.e. the first
     *  colour not assigned to its neighbours) to each in turn. If all
     *  colours are used by its neighbours then the vertex is failed.
     *  This is the most naive and wasteful method.
     *
     *  NORCROFT: a heuristic method taught to me by Dr Arthur Norman
     *  and used in the Norcroft C compiler. It orders the vertices
     *  according to their connectedness before applying the greedy
     *  algorithm. The idea is that vertices with fewer connections
     *  are less likely to rule out colours in the rest of the graph.
     *)

    datatype colouring_algorithm =
      PERFECT |
      GREEDY |
      NORCROFT


    (*  == Colouring function ==
     *
     *  Parameters:
     *    graph		The graph to colour.
     *    colours	A list of colours to assign to the vertices in
     *			graph. The earlier colours in the list are used
     *			in preference to later ones.
     *    ordering	An ordering function on vertices.
     *    precoloured   A list of (vertex,colour). Vertices will
     *			always be coloured according to this list if
     *			they exist in the graph.
     *    forbidden	A table of vertices to sets of colours. The
     *	 		vertex is not allowed to be coloured with any
     *	 		colour in the set. (precoloured (above) takes
     *	 		precedence over this, however.)
     *
     *  The function returns a look-up table from vertices to colours,
     *	and a list of vertices that it failed to colour at all.
     *)

    val colour :
      colouring_algorithm ->
      {graph		: ''a T,
       colours		: ''b list,
       ordering		: ''a * ''a -> bool,
       precoloured	: (''a * ''b) list,
       forbidden	: (''a, ''b Set.Set) Table.table} ->
       ((''a, ''b) Table.table * ''a list)



    (*  === PRINT A GRAPH ===
     *
     *  Given a function to convert vertices to strings and a graph,
     *  this function returns a string of the form:
     *  ( {vertex, vertex, ...}, {vertex - vertex, ...} )
     *)

    val print : (''a -> string) * ''a T -> string

  end
@


1.5.1.1
log
@Fork for bug fixing
@
text
@d3 1
a3 4
(* $Log: graph.sml,v $
Revision 1.5  1991/10/15  12:20:51  richard
Added precolouring, add_many_to_many and add_one_to_many.

@


1.4
log
@Added precolouring and forbidden colours for vertices.
@
text
@d4 3
d83 25
d175 3
a177 3
     *    precoloured   A table of vertices to colours. Vertices will
     *			always be coloured according to this table if
     *			mentioned.
d192 1
a192 1
       precoloured	: (''a, ''b) Table.table,
@


1.3
log
@Changed to use two representations which are efficient in different
circumstances.
@
text
@d4 4
d141 16
a156 4
     *  The colour function takes a method specification, and a graph,
     *  an ordering function and a list of colours which may be used.
     *  It returns a look-up table from vertices to colours, and a
     *  list of vertices that it failed to colour at all.
d159 8
a166 3
    val colour : colouring_algorithm ->
      		 (''a T * ''b list * (''a * ''a -> bool)) ->
		 ((''a, ''b) Table.table * ''a list)
@


1.2
log
@Added facilities for directed graphs.
@
text
@d4 3
d34 4
a37 1
     *  function returns a graph with no vertices or edges.
d40 3
a42 1
    val empty : (''a * ''a -> bool) -> ''a T
d44 1
d46 2
a47 1
    (*  == Add a vertex to a graph ==
d49 1
a49 1
     *  Returns a new graph with the vertex added.
d52 1
a52 1
    val add_vertex : ''a * ''a T -> ''a T
d59 2
a60 1
     *  see if they exist in the graph.
d63 1
a63 1
    val add_edge   : (''a * ''a) * ''a T -> ''a T
d73 1
a73 1
    val add_directed_edge : (''a * ''a) * ''a T -> ''a T
d85 4
d90 4
d137 4
a140 4
     *  The colour function takes a method specification, and a graph
     *  and a list of colours which may be used. It returns a look-up
     *  table from vertices to colours, and a list of vertices that it
     *  failed to colour at all.
d144 1
a144 1
      		 ''a T * ''b list ->
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
(* $Log$
d10 1
d19 1
d55 6
d62 13
d84 3
@
