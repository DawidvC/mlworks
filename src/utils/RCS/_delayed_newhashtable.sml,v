head	1.5;
access;
symbols
	ML_beta_release_12/08/94:1.5
	ML_beta_release_03/08/94:1.5
	ML_revised_beta_release_25/05/94:1.5
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5
	Release:1.4
	mlworks-beta-01-09-1993:1.4
	MLWorks-1-0-4-29/01/1993:1.3
	MLWorks-1-0-3-21/12/1992:1.3
	MLWorks-1-0-2-15/12/1992:1.3
	MLWorks-1-0-1-04/12/1992:1.3;
locks; strict;
comment	@ * @;


1.5
date	93.12.09.19.45.29;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	93.04.22.17.07.45;	author matthew;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	92.09.21.10.26.44;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	92.09.18.09.18.31;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.09.16.09.46.09;	author clive;	state Exp;
branches;
next	;

1.4.1.1
date	93.04.22.17.07.45;	author jont;	state Exp;
branches;
next	;


desc
@First version
@


1.5
log
@Added copyright message
@
text
@(* _delayed_newhashtable.sml the functor *)
(*
$Log: _delayed_newhashtable.sml,v $
Revision 1.4  1993/04/22  17:07:45  matthew
Added a sharing constraint to Rough signature, else it fails with abstractionsemantics

Revision 1.3  1992/09/21  10:26:44  clive
Changed hashtables to a single structure implementation

Revision 1.2  1992/09/18  09:18:31  clive
Made the signature for Rough type-explicit

Revision 1.1  1992/09/16  09:46:09  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)

require "_newhashtable";
require "newhashtable";
require "delayed_newhashtable";
require "crash";
require "lists";

functor DelayedNewHashTable(
  S : sig
	structure Crash : CRASH
	structure Lists : LISTS
      end
 ) : DELAYED_NEWHASHTABLE =

struct

  structure NewHashTable = NewHashTable(S);

  local 
    structure Rough : 
      sig 
        exception Lookup 
        datatype 'a option = YES of 'a | NO 
        sharing type option = NewHashTable.option
      end = 
      struct
        structure NewHashTable = NewHashTable
        open NewHashTable
      end
  in
    open Rough
  end

  datatype ('_Key,'_Value) HashTableElement = 
    Instantiated of ('_Key,'_Value) NewHashTable.HashTable 
  | NotInstantiated of int * ('_Key * '_Key -> bool) * ('_Key -> int)

  type ('_Key,'_Value) HashTable = ('_Key,'_Value) HashTableElement ref

  fun new x = ref(NotInstantiated x)

  fun lookup (table,key) =
    case ! table of
      NotInstantiated _ => raise Lookup
    | Instantiated table => NewHashTable.lookup(table,key)

  fun lookup_default(ref (NotInstantiated _),value,_) = value
    | lookup_default(ref(Instantiated table),value,key) = NewHashTable.lookup_default(table,value,key)

  fun tryLookup(ref (NotInstantiated _),_) = NO
    | tryLookup(ref(Instantiated table),key) =
      NewHashTable.tryLookup(table,key)

  fun update(table as ref(NotInstantiated x),key,value) =
    let
      val table' = NewHashTable.new x
    in
      table := Instantiated table';
      NewHashTable.update(table',key,value)
    end
    | update(ref(Instantiated table),key,value) =
      NewHashTable.update(table,key,value)

  fun delete(table as ref (NotInstantiated _),key) = 
    raise Lookup 
    | delete(ref(Instantiated table),key) = 
      NewHashTable.delete(table,key)

  fun to_list(table as ref (NotInstantiated _)) = []
    | to_list(ref(Instantiated table)) = NewHashTable.to_list table

  fun copy(ref (NotInstantiated x)) = ref (NotInstantiated x)
    | copy(ref(Instantiated table)) = ref(Instantiated (NewHashTable.copy table))

  fun fold f (a,ref (NotInstantiated _)) = a
    | fold f (a,ref(Instantiated table)) = NewHashTable.fold f (a,table)

  fun iterate f (ref(NotInstantiated _)) = ()
    | iterate f (ref(Instantiated table)) = NewHashTable.iterate f table

  fun stats(ref (NotInstantiated _)) = {size=0,count=0,smallest=0,largest=0}
    | stats(ref(Instantiated table)) = NewHashTable.stats table

  fun string_hash_table_stats(ref(NotInstantiated _)) = "EMPTY"
    | string_hash_table_stats(ref(Instantiated table)) = NewHashTable.string_hash_table_stats table

end







@


1.4
log
@Added a sharing constraint to Rough signature, else it fails with abstractionsemantics
@
text
@a1 1

d4 3
d16 1
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a4 3
Revision 1.4  1993/04/22  17:07:45  matthew
Added a sharing constraint to Rough signature, else it fails with abstractionsemantics

@


1.3
log
@Changed hashtables to a single structure implementation
@
text
@d5 3
d38 1
@


1.2
log
@Made the signature for Rough type-explicit
@
text
@d5 3
a22 5
	type Key
	type Value
	val eq : Key * Key -> bool
	val hash : Key -> int
	val size : int
a28 2
  type Key = S.Key
  type Value = S.Value
d33 1
a33 2
        structure NewHashTable : NEWHASHTABLE
        exception Lookup of NewHashTable.Key 
d44 5
a48 2
  datatype HashTableElement = Instantiated of NewHashTable.HashTable | NotInstantiated
  type HashTable = HashTableElement ref
d50 1
a50 1
  fun new () = ref(NotInstantiated)
d54 1
a54 1
      NotInstantiated => raise Lookup key
d57 1
a57 1
  fun lookup_default(ref NotInstantiated,value,_) = value
d60 1
a60 1
  fun tryLookup(ref NotInstantiated,_) = NO
d64 1
a64 1
  fun update(table as ref(NotInstantiated),key,value) =
d66 1
a66 1
      val table' = NewHashTable.new()
d74 2
a75 2
  fun delete(table as ref NotInstantiated,key) = 
    raise Lookup key
d79 1
a79 1
  fun to_list(table as ref NotInstantiated) = []
d82 1
a82 1
  fun copy(ref NotInstantiated) = ref NotInstantiated
d85 1
a85 1
  fun fold f (a,ref NotInstantiated) = a
d88 1
a88 1
  fun iterate f (ref(NotInstantiated)) = ()
d91 1
a91 1
  fun stats(ref NotInstantiated) = {size=0,count=0,smallest=0,largest=0}
d94 1
a94 1
  fun string_hash_table_stats(ref(NotInstantiated)) = "EMPTY"
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
$Log: $
d11 1
a15 3
require "_newhashtable";


d33 1
d35 10
a44 1
    structure Rough : sig exception Lookup of Key datatype 'a option = YES of 'a | NO end = NewHashTable
@
