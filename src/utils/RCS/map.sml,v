head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.3
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.8.8.1.1.1.1
	MLWorks_workspace_97:1.9.2
	MLWorks_dt_wizard:1.9.1
	MLWorks_11c0_1997_09_09:1.8.8.1.1.1
	MLWorks_10r3:1.8.8.1.3
	MLWorks_10r2_551:1.8.8.1.2
	MLWorks_11:1.8.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.8.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.8.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.8
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.6.1.1
	MLWorks_gui_1996_12_18:1.8.7
	MLWorks_1_0_Win32_1996_12_17:1.8.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.4.1
	MLWorks_1_0_Irix_1996_11_28:1.8.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.5
	MLWorks_1_0_Unix_1996_11_14:1.8.4
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	ML_beta_release_12/08/94:1.5
	ML_beta_release_03/08/94:1.5
	ML_revised_beta_release_25/05/94:1.5
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5
	Release:1.5
	mlworks-beta-01-09-1993:1.5
	MLWorks-1-0-4-29/01/1993:1.5
	MLWorks-1-0-3-21/12/1992:1.5
	MLWorks-1-0-2-15/12/1992:1.5
	MLWorks-1-0-1-04/12/1992:1.5
	checkpoint_17_08_92:1.4
	Ten15_release_19-11-91:1.2.1.1
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ *  @;


1.9
date	97.05.01.12.58.03;	author jont;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1;
next	1.8;

1.8
date	96.03.19.14.21.45;	author matthew;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1
	1.8.7.1
	1.8.8.1;
next	1.7;

1.7
date	96.02.23.18.08.51;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.03.31.14.44.59;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.09.25.16.28.03;	author jont;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	91.11.21.17.04.50;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.19.12.20.50;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.28.09.49.24;	author colin;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.06.07.15.59.03;	author colin;	state Exp;
branches;
next	;

1.2.1.1
date	91.11.19.11.13.42;	author jont;	state Exp;
branches;
next	;

1.5.1.1
date	92.09.25.16.28.03;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.43.20;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.36.31;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.55.33;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.11.14.13.23.54;	author hope;	state Exp;
branches
	1.8.4.1.1.1;
next	;

1.8.4.1.1.1
date	96.11.28.15.34.31;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	96.11.22.18.40.58;	author hope;	state Exp;
branches;
next	;

1.8.6.1
date	96.12.17.18.19.56;	author hope;	state Exp;
branches
	1.8.6.1.1.1;
next	;

1.8.6.1.1.1
date	97.02.24.12.14.22;	author hope;	state Exp;
branches;
next	;

1.8.7.1
date	96.12.18.10.15.27;	author hope;	state Exp;
branches;
next	;

1.8.8.1
date	97.05.12.10.53.44;	author hope;	state Exp;
branches
	1.8.8.1.1.1
	1.8.8.1.2.1
	1.8.8.1.3.1;
next	;

1.8.8.1.1.1
date	97.07.28.18.35.59;	author daveb;	state Exp;
branches
	1.8.8.1.1.1.1.1;
next	;

1.8.8.1.1.1.1.1
date	97.10.07.12.01.22;	author jkbrook;	state Exp;
branches;
next	;

1.8.8.1.2.1
date	97.09.08.17.28.24;	author daveb;	state Exp;
branches;
next	;

1.8.8.1.3.1
date	97.09.09.14.26.00;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	97.09.10.19.44.49;	author brucem;	state Exp;
branches;
next	;

1.9.2.1
date	97.09.11.21.12.03;	author daveb;	state Exp;
branches;
next	;

1.9.3.1
date	99.04.01.18.09.53;	author daveb;	state Exp;
branches;
next	;


desc
@Polymorphic Finite Maps
@


1.9
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*  === GENERAL PURPOSE MAP ===
 *           SIGNATURE
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  A map is a general purpose partial function from some domain to some
 *  range, or, if you prefer, a look-up table.  For the sake of efficiency a
 *  complete order must be provided when constructing a map.
 *
 *  Notes
 *  -----
 *  This signature is intended to have more than one implementation, using
 *  association lists, balanced trees, arrays, etc.  I want to keep the
 *  signature simple and self-contained.
 *
 *  Revision Log
 *  ------------
 *  $Log: map.sml,v $
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
 *  Revision 1.7  1996/02/23  18:08:51  jont
 *  new unit
 *  Old newmap moved here for better naming in CS library
 *
 *  Revision 1.18  1994/10/13  10:05:38  matthew
 *  Use pervasive Option.option for return values
 *
 *  Revision 1.17  1993/06/15  16:53:15  daveb
 *  Added tryApply'Eq, for use in _realise.
 *
 *  Revision 1.16  1992/10/28  14:35:47  jont
 *  Some cosmetic changes to emphasise the need for strict less than functions
 *
 *  Revision 1.15  1992/10/02  14:38:13  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.14  1992/09/15  18:18:50  jont
 *  Added empty'' for strict less than functions which do the less than test
 *  first. this should be more efficient for large maps
 *
 *  Revision 1.13  1992/08/27  15:19:08  davidt
 *  Added the functions fold_in_rev_order and string.
 *
 *  Revision 1.12  1992/08/26  12:51:12  davidt
 *  Changed the type of forall and exists, adding the
 *  function map.
 *
 *  Revision 1.11  1992/08/18  16:55:08  davidt
 *  Added the combine function.
 *
 *  Revision 1.10  1992/08/13  14:20:42  davidt
 *  Added tryApply, tryApply', size, rank, rank, and merge functions.
 *
 *  Revision 1.9  1992/08/11  11:22:14  jont
 *  Removed some redundant structure arguments and sharing
 *  Converted where relevant to use NewMap.{forall,exists,iterate}
 *
 *  Revision 1.8  1992/08/04  17:51:49  jont
 *  Added fold, fold_in_order and union on maps
 *
 *  Revision 1.7  1992/07/13  10:31:41  jont
 *  Added is_empty predicate
 *
 *  Revision 1.6  1992/06/17  10:24:09  jont
 *  Added range_ordered for signature matching requirements of lambda translator
 *
 *  Revision 1.5  1992/06/11  14:41:58  jont
 *  Added domain_ordered function (required by lambda translator)
 *
 *  Revision 1.4  1992/06/10  12:13:02  richard
 *  Added to_list_ordered.
 *
 *  Revision 1.3  1992/06/01  09:48:14  richard
 *  Added empty' and from_list'.
 *
 *  Revision 1.2  1992/05/19  10:33:01  richard
 *  Added efficient variants of `apply' for different situations.
 *
 *  Revision 1.1  1991/12/05  14:23:56  richard
 *  Initial revision
 *
 *)


signature MAP =
  sig
    (*  === THE MAP TYPE ===  *)

    type ('object, 'image) map


    (*  === CONSTRUCT AN EMPTY MAP ===
     *
     *  An empty map is undefined everywhere, and is constructed by
     *  supplying an ordering function for the object type (<) and
     *  an equality function
     *  Note:
     *    ForAll f,x . apply (empty f) x = raise Undefined
     *
     *  empty' is a variation which takes a less function (or <) for an
     *  equality-admitting object type.
     *
     *)

    val empty  : (('object * 'object -> bool) * ('object * 'object -> bool)) -> ('object, 'image) map
    val empty' : (''object * ''object -> bool) -> (''object, 'image) map

    (* Determining if a map is empty *)
    val is_empty : ('object, 'image) map -> bool

    (*  === DEFINE THE MAP AT A POINT ===
     *
     *  Adds a mapping from the object to the image such that
     *    apply (define (M, x, y)) x = y
     *)

    val define  : ('object, 'image) map * 'object * 'image -> ('object, 'image) map
    val define' : ('object, 'image) map * ('object * 'image) -> ('object, 'image) map

    (*  === DEFINE THE MAP AT A POINT ===
     *
     *  Adds a mapping from the object to the image, combining the
     *  images using the supplied function if the object is already
     *  present in the mapping.
     *)

    val combine : ('object * 'image * 'image -> 'image) -> ('object, 'image) map * 'object * 'image -> ('object, 'image) map

    (*  === UNDEFINE THE MAP AT A POINT ===
     *
     *  Removed a mapping from the object to the image such that
     *    apply (undefine (M, x)) x = raise Undefined
     *)

    val undefine : ('object, 'image) map * 'object -> ('object, 'image) map


    (*  === APPLY THE MAP TO AN OBJECT ===
     *
     *  Looks up the image of an object in the map, and raises Undefined if
     *  no mapping has been defined for that object.  apply M is the partial
     *  function represented by the map M, and should be lifted out of loops
     *  and functions so that apply has a chance to optimise the map.
     *
     *  apply' is an uncurried alternative to apply.  Use the curried
     *  version if it can be lifted (see previous paragraph).  apply_default
     *  and apply_default' will return a default image rather than raise
     *  Undefined.
     *
     *  tryApply and tryApply' encode the result status in the return value.
     *  tryApply'Eq uses polymorphic equality during the lookup instead of
     *  the one with which the tree was built.  This is for signature
     *  realisation, when (unusually) the constructor status of entries in
     *  the value environment is important.
     *)

    exception Undefined

    val apply          : ('object, 'image) map -> 'object -> 'image
    val apply'         : ('object, 'image) map * 'object -> 'image
    val tryApply       : ('object, 'image) map -> 'object -> 'image option
    val tryApply'      : ('object, 'image) map * 'object -> 'image option
    val tryApply'Eq    : (''object, 'image) map * ''object -> 'image option
    val apply_default  : ('object, 'image) map * 'image -> 'object -> 'image
    val apply_default' : ('object, 'image) map * 'image * 'object -> 'image


    (*  === EXTRACT THE DOMAIN OF A MAP ===
     *
     *  A list of all objects for which the map is defined is returned.
     *)

    val domain : ('object, 'image) map -> 'object list
    val domain_ordered : ('object, 'image) map -> 'object list


    (*  === EXTRACT THE RANGE OF A MAP ===
     *
     *  A list of all images mapped to in the map is returned.  This may
     *  contain duplicate entries.
     *)

    val range : ('object, 'image) map -> 'image list
    val range_ordered : ('object, 'image) map -> 'image list


    (*  === CONVERT MAP TO LIST ===
     *
     *  Converts a map to a list of pairs of the form (object, image), in no
     *  particular order.  to_list_ordered produces the pairs in ascending
     *  order of object.
     *)

    val to_list         : ('object, 'image) map -> ('object * 'image) list
    val to_list_ordered : ('object, 'image) map -> ('object * 'image) list


    (*  === CONVERT LIST TO MAP ===
     *
     *  Converts a list of pairs of the form (object, image) to a map
     *  defined for all such objects.  An ordering function on the objects
     *  is also required as for `empty' (see above).
     *)

    val from_list :
      (('object * 'object -> bool) * ('object * 'object -> bool)) ->
      ('object * 'image) list ->
      ('object, 'image) map

    val from_list' :
      (''object * ''object -> bool) ->
      (''object * 'image) list ->
      (''object, 'image) map

    (*  === FOLD OVER MAP ===
     *
     *  Folds over all the live elements of a map.
     *)

    val fold : ('a * 'b * 'c -> 'a) -> 'a * ('b, 'c) map -> 'a
    val fold_in_order : ('a * 'b * 'c -> 'a) -> 'a * ('b, 'c) map -> 'a
    val fold_in_rev_order : ('a * 'b * 'c -> 'a) -> 'a * ('b, 'c) map -> 'a

    (*  === FOLD OVER MAP ===
     *
     *  Map over all the live elements of a map in order.
     *)

    val map : ('a * 'b -> 'c) -> ('a, 'b) map -> ('a, 'c) map

    (*
     *  Calculate the number of entries in a map.
     *)

    val size : ('a, 'b) map -> int

    (*
     * Given an equality function on the image, checks if two maps are equal.
     *)

    val eq : ('a * 'b -> bool) -> ('o, 'a) map * ('o, 'b) map -> bool

    (*
     *  Find the position of an object in the domain (wrt to the domain
     *  ordering), counting from zero for the least object. Raises Undefined
     *  if the object is not present in the domain.
     *)

    val rank  : ('a, 'b) map -> 'a -> int
    val rank' : ('a, 'b) map * 'a -> int

    (*  === UNITE MAPS ===
     *
     *  Overrides the first map with the second
     *)

    val union : ('a, 'b) map * ('a, 'b) map -> ('a, 'b) map

    (*  === UNITE MAPS ===
     *
     *  Merges the first map with the second, using the function
     *  provided if both maps map the same object.
     *)

    val merge : ('a * 'b * 'b -> 'b) -> ('a, 'b) map * ('a, 'b) map -> ('a, 'b) map

    (*  === LOGICAL FUNCTIONS OVER MAP RANGES ===
     *
     *  Forall and Exists quantifiers
     *)

    val forall : ('a * 'b -> bool) -> ('a, 'b) map -> bool
    val exists : ('a * 'b -> bool) -> ('a, 'b) map -> bool

    (*  === ITERATION OVER MAPS ===
     *
     *  Iterate and Iterate ordered
     *)

    val iterate : ('a * 'b -> unit) -> ('a, 'b) map -> unit
    val iterate_ordered : ('a * 'b -> unit) -> ('a, 'b) map -> unit

    (* === PRINTING OF MAPS ===
     *
     * Make a map into a string.
     *)

    val string :
      ('a -> string) -> ('b -> string) ->
      {start : string, domSep : string, itemSep : string, finish : string} ->
      ('a, 'b) map -> string

  (* === GET RELATION === 
   *
   * Get the ordering relation from a map
   *)

    val get_ordering : ('a,'b) map -> ('a * 'a -> bool)
    val get_equality : ('a,'b) map -> ('a * 'a -> bool)

  end
@


1.9.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 4
 *  Revision 1.9  1997/05/01  12:58:03  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.9.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 *  Revision 1.9  1997/05/01  12:58:03  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.9.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 4
 *  Revision 1.9  1997/05/01  12:58:03  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.8
log
@Adding extra parameter to merge
@
text
@d21 3
d164 3
a166 3
    val tryApply       : ('object, 'image) map -> 'object -> 'image MLWorks.Option.option
    val tryApply'      : ('object, 'image) map * 'object -> 'image MLWorks.Option.option
    val tryApply'Eq    : (''object, 'image) map * ''object -> 'image MLWorks.Option.option
@


1.8.8.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 3
 *  Revision 1.8.8.1  1997/05/12  10:53:44  hope
 *  branched from 1.8
 *
@


1.8.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 3
 *  Revision 1.8.8.1  1997/05/12  10:53:44  hope
 *  branched from 1.8
 *
@


1.8.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 3
 *  Revision 1.8.8.1  1997/05/12  10:53:44  hope
 *  branched from 1.8
 *
@


1.8.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 *  Revision 1.8.8.1.1.1  1997/07/28  18:35:59  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.8.7.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.6.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.6.1.1.1
log
@branched from 1.8.6.1
@
text
@a20 3
 *  Revision 1.8.6.1  1996/12/17  18:19:56  hope
 *  branched from 1.8
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.4.1.1.1
log
@branched from 1.8.4.1
@
text
@a20 3
 *  Revision 1.8.4.1  1996/11/14  13:23:54  hope
 *  branched from 1.8
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a20 3
 *  Revision 1.8  1996/03/19  14:21:45  matthew
 *  Adding extra parameter to merge
 *
@


1.7
log
@new unit
Old newmap moved here for better naming in CS library
@
text
@d20 5
a24 1
 *  $Log: newmap.sml,v $
d265 1
a265 1
    val merge : ('b * 'b -> 'b) -> ('a, 'b) map * ('a, 'b) map -> ('a, 'b) map
@


1.6
log
@Don't need equality function in map anymore
@
text
@d1 79
a79 29
(* map.sml the signature *)
(*
$Log: map.sml,v $
Revision 1.5  1992/09/25  16:28:03  jont
Removed a number of unused values

Revision 1.4  1991/11/21  17:04:50  jont
Added copyright message

Revision 1.3  91/11/19  12:20:50  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.2.1.1  91/11/19  11:13:42  jont
Added comments for DRA on functions

Revision 1.2  91/06/28  09:49:24  colin
Relaxed type of compare and size to allow comparison of maps with different
domains (though ranges must still be the same)

Revision 1.1  91/06/07  15:59:03  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* Maps are used throughout the compiler, for obvious reasons. Maps
have equality functions on the domain type, which can be user defined.
The map-manipulating functions are mostly intuitive, except for those
commented below *)
d82 2
a83 33
    sig
	type ('a,'b) Map

	exception Lookup

	val empty_map : (''a,'b) Map
        val lookup : (''a * (''a,'b) Map) -> 'b
	val add : ((''a * 'b) * (''a,'b) Map * (''a * ''a -> bool)) -> (''a,'b) Map 

		   (* the third argument is an ordering function on
		    the 'a's, which speeds the addition (the map does
		    not need to be entirely scanned) *)

        val forall : (('a,'b) Map * ('b -> bool)) -> bool
	val exists : (('a,'b) Map * ('b -> bool)) -> bool
	val mapit : (('a,'b) Map * ('b -> 'c)) -> ('a,'c) Map 
	val plus : (('a,'b) Map * ('a,'b) Map * ('a * 'a -> bool)) -> ('a,'b) Map
	val eqmaps : ((''a,'b) Map * (''a,'b) Map * ('b * 'b -> bool)) -> bool

	datatype map_result = EQUAL | NOT_EQUAL | DIFFERENT_DOMAINS

	val compare : (''a,'b) Map * (''a,'c) Map * ('b * 'c -> bool) -> map_result

	datatype size_result = BIGGER | NOT_BIGGER | DIFFERENT_RANGE

	val size :
	  (''a,'b) Map * (''a,'c) Map * (''a * ''a -> bool) * ('b * 'c -> bool) -> 
          size_result

	  (* The 'b and 'c are usually the same, and comparing the two
	     maps compares range values pairwise to determine if they
	     are all bigger. *)

d85 1
a85 4
	val splice_maps : (((''a,'b) Map * (''a,'b) Map * 
			    ('b -> 'b) * ('b -> 'b) *
			    ('b * 'b -> bool) * (''a * ''a -> bool))
			   ->  (''a,'b) Map)
a86 4
	  (* splice_maps m1 m2 lf rf bdo aorder
	   returns a map which is (lf m1)+(rf m2), with bdo performed
	   on each pair of b's with equal a's, and aorder used to
	   order the a's in the  resulting map *)
d88 205
a292 6
	val print_map : (('a,'b) Map * ('a -> string) * ('b -> string) * 
			 string -> string)
	val domain : ('a,'b) Map -> 'a list
	val range : ('a,'b) Map -> 'b list
	val assoc : ('a,'b) Map -> ('a * 'b) list
	val domain_member : (''a * (''a,'b) Map) -> bool
d294 2
a295 2
	val fold : (('c * 'b) -> 'c) -> ('c * ('a, 'b) Map) -> 'c
	val Fold : ('a -> 'b -> 'c -> 'c) -> 'c -> ('a, 'b) Map -> 'c
d297 1
a297 1
    end
@


1.5
log
@Removed a number of unused values
@
text
@d4 3
d38 2
a39 4
	val empty_eqfunmap : ('a * 'a -> bool) -> ('a, 'b) Map
        val lookup : ('a * ('a,'b) Map) -> 'b
	val add : (('a * 'b) * ('a,'b) Map * ('a * 'a -> bool))
	           -> ('a,'b) Map 
d48 2
a49 4
	val plus : (('a,'b) Map * ('a,'b) Map * 
		    ('a * 'a -> bool)) -> ('a,'b) Map
	val eqmaps : (('a,'b) Map * ('a,'b) Map * 
		      ('b * 'b -> bool)) -> bool
d51 1
a51 2
	datatype map_result =
	  EQUAL | NOT_EQUAL | DIFFERENT_DOMAINS
d53 1
a53 2
	val compare :
	  ('a,'b) Map * ('a,'c) Map * ('b * 'c -> bool) -> map_result
d55 1
a55 2
	datatype size_result =
	  BIGGER | NOT_BIGGER | DIFFERENT_RANGE
d58 2
a59 2
	  ('a,'b) Map * ('a,'c) Map * ('a * 'a -> bool) *
	  ('b * 'c -> bool) -> size_result
d66 1
a66 1
	val splice_maps : ((('a,'b) Map * ('a,'b) Map * 
d68 2
a69 2
			    ('b * 'b -> bool) * ('a * 'a -> bool))
			   ->  ('a,'b) Map)
d81 1
a81 1
	val domain_member : ('a * ('a,'b) Map) -> bool
@


1.5.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.5  1992/09/25  16:28:03  jont
Removed a number of unused values

@


1.4
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	map.sml,v $
d35 1
a35 1
	val empty_eqfunmap : ('a * 'a -> bool) -> ('a,'b) Map
a46 7
	val mapit2 : (('a,'b) Map * 'c * 'd * ('b * 'c * 'd -> 'b * 'c)) ->
		      ('a,'b) Map * 'c

		      (* A combination of mapit with fold (over the
			 'd) *)

	val cond_mapit : (('a,'b) Map * ('a * 'b -> 'c) ) -> ('a,'c) Map 
a84 2
	val emptymap_p : ('a,'b) Map -> bool
	val remove : ('a * ('a,'b) Map) -> ('a,'b) Map
d87 1
a87 1
	val fold : ('b -> 'c -> 'c) -> 'c -> ('a, 'b) Map -> 'c
d89 1
a90 2


@


1.3
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d17 1
@


1.2
log
@Relaxed type of compare and size to allow comparison of maps with different
domains (though ranges must still be the same)
@
text
@d3 7
d14 6
d31 5
d41 4
d64 5
d73 6
@


1.2.1.1
log
@Added comments for DRA on functions
@
text
@a2 4
Revision 1.2  91/06/28  09:49:24  colin
Relaxed type of compare and size to allow comparison of maps with different
domains (though ranges must still be the same)

a6 6

(* Maps are used throughout the compiler, for obvious reasons. Maps
have equality functions on the domain type, which can be user defined.
The map-manipulating functions are mostly intuitive, except for those
commented below *)

a17 5

		   (* the third argument is an ordering function on
		    the 'a's, which speeds the addition (the map does
		    not need to be entirely scanned) *)

a22 4

		      (* A combination of mapit with fold (over the
			 'd) *)

a41 5
	  (* The 'b and 'c are usually the same, and comparing the two
	     maps compares range values pairwise to determine if they
	     are all bigger. *)


a45 6

	  (* splice_maps m1 m2 lf rf bdo aorder
	   returns a map which is (lf m1)+(rf m2), with bdo performed
	   on each pair of b's with equal a's, and aorder used to
	   order the a's in the  resulting map *)

@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d33 1
a33 1
	  ('a,'b) Map * ('a,'b) Map * ('b * 'b -> bool) -> map_result
d39 2
a40 2
	  ('a,'b) Map * ('a,'b) Map * ('a * 'a -> bool) *
	  ('b * 'b -> bool) -> size_result
@
