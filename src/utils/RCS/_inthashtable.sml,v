head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.3
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.7.5.1.1.1.1
	MLWorks_workspace_97:1.9.2
	MLWorks_dt_wizard:1.9.1
	MLWorks_11c0_1997_09_09:1.7.5.1.1.1
	MLWorks_10r3:1.7.5.1.3
	MLWorks_10r2_551:1.7.5.1.2
	MLWorks_11:1.7.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.5.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.7.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.5
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.3.1.1
	MLWorks_gui_1996_12_18:1.7.4
	MLWorks_1_0_Win32_1996_12_17:1.7.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.1.1
	MLWorks_1_0_Irix_1996_11_28:1.7.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.2
	MLWorks_1_0_Unix_1996_11_14:1.7.1
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.9
date	97.05.19.13.16.13;	author jont;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1;
next	1.8;

1.8
date	97.05.01.15.15.24;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.11.06.10.52.55;	author matthew;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1;
next	1.6;

1.6
date	96.05.17.09.19.06;	author matthew;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	96.05.07.10.49.05;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.04.30.16.16.53;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.04.29.15.08.42;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	94.10.07.14.04.57;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	94.09.23.14.48.52;	author matthew;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.42.53;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.36.03;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.55.05;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.11.14.13.23.27;	author hope;	state Exp;
branches
	1.7.1.1.1.1;
next	;

1.7.1.1.1.1
date	96.11.28.15.34.02;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.11.22.18.40.30;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.12.17.18.19.30;	author hope;	state Exp;
branches
	1.7.3.1.1.1;
next	;

1.7.3.1.1.1
date	97.02.24.12.13.51;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.12.18.10.14.57;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	97.05.12.10.53.04;	author hope;	state Exp;
branches
	1.7.5.1.1.1
	1.7.5.1.2.1
	1.7.5.1.3.1;
next	;

1.7.5.1.1.1
date	97.07.28.18.36.15;	author daveb;	state Exp;
branches
	1.7.5.1.1.1.1.1;
next	;

1.7.5.1.1.1.1.1
date	97.10.07.12.01.32;	author jkbrook;	state Exp;
branches;
next	;

1.7.5.1.2.1
date	97.09.08.17.28.34;	author daveb;	state Exp;
branches;
next	;

1.7.5.1.3.1
date	97.09.09.14.26.16;	author daveb;	state Exp;
branches;
next	;

1.9.1.1
date	97.09.10.19.44.15;	author brucem;	state Exp;
branches;
next	;

1.9.2.1
date	97.09.11.21.11.38;	author daveb;	state Exp;
branches;
next	;

1.9.3.1
date	99.04.01.18.10.03;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.9
log
@[Bug #30090]
Translate output std_out to print
@
text
@(* _inthashtable.sml the functor *)
(*
 * $Log: _inthashtable.sml,v $
 * Revision 1.8  1997/05/01  15:15:24  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.6  1996/05/17  09:19:06  matthew
 * Moving Bits to MLWorks.Internal
 *
 * Revision 1.5  1996/05/07  10:49:05  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.4  1996/04/30  16:16:53  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.3  1996/04/29  15:08:42  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.2  1994/10/07  14:04:57  matthew
 * Diddling
 *
 * Revision 1.1  1994/09/23  14:48:52  matthew
 * new file
 *
 * Copyright (c) 1994 Harlequin Ltd.
 *)

require "../basis/__int";

require "inthashtable";
require "lists";

(* A hash table with more than one table *)

functor IntHashTable(structure Lists : LISTS
                       ) : INTHASHTABLE =
  struct

    structure Bits = MLWorks.Internal.Bits

    (* 
     An assoc list
     Number of free slots
     mask for hashing
     *)
       
    type '_a T = ((int * '_a option) list MLWorks.Internal.Array.array * int ref * int) ref

    val array_sub = MLWorks.Internal.Value.unsafe_array_sub
    val array_update = MLWorks.Internal.Value.unsafe_array_update

    val print_debug = false

    (* This expansion ratio of 2 is used to maintain the fact that the tables
     are a power of two in size. This means we may use bitwise operations to go from
     hash value to table index, and can do the resize operation much more
     quickly - if this is changed, some of the other functions need to be re-written *)

    val expansion_ratio = 2 (* factor to increase by on re-size - if this is changed from 2, adjust
                             partitioning part of the re-sizing code in update *)
    val max_size_ratio = 4 (* resize when number of elements is this multiplied by the size *)

    exception Lookup 

    local
      fun nearest_power_of_two (size,x:int) =
        if x >= size
          then x
        else nearest_power_of_two (size,x+x)
    in
      fun new size =
        let
          val initial_size = nearest_power_of_two(size,1)
        in
          ref(MLWorks.Internal.Array.array(initial_size, []),
              ref(max_size_ratio * initial_size),
              initial_size - 1)
        end
    end

    fun lookup(ref (elt_array,_,mask), key:int) =
      let
        fun assoc [] = raise Lookup
          | assoc((k, v) :: xs) =
            if key = k then 
              (case v of
                 SOME x => x
               | _ => raise Lookup)
            else assoc xs
	val list_map = array_sub (elt_array, Bits.andb(key,mask))
      in
	assoc list_map
      end

    fun tryLookup(ref (elt_array,_,mask),key:int) =
      let
        fun assoc_default (key,[]) = NONE
          | assoc_default (key,(k, v) :: xs) =
            if key = k
              then v
            else assoc_default (key,xs)
	val list_map = array_sub(elt_array, Bits.andb(key,mask))
      in
        assoc_default(key,list_map)
      end

    fun member (_, []) = false
      | member (key:int, (k, _) :: rest) =
        key = k orelse member (key,rest)

    fun is_defined (ref (elt_array,_,mask),key) =
      let
        val list_map = array_sub(elt_array, Bits.andb(key,mask))
      in
        member (key,list_map)
      end
        
    fun lookup_default (table,value,key) =
      case tryLookup (table,key) of
        SOME res => res
      | _ => value

    fun iterate_hash f (arr,_,_) =
      let
        val len = MLWorks.Internal.Array.length arr
        fun down i =
          if i = len 
            then ()
          else 
            (Lists.iterate 
             (fn (k, SOME v) => f(k,v) | _ => ())
             (array_sub (arr, i));
             down (i+1))
      in
        down 0
      end

    fun iterate f (ref h) = iterate_hash f h

    fun fold f (res, ref (arr,_,_)) =
      let
        val len = MLWorks.Internal.Array.length arr
        fun do_bucket (res,((k,SOME v)::rest)) =
          do_bucket (f (res,k,v),rest)
          | do_bucket (res, ((k,NONE)::rest)) =
            do_bucket (res,rest)
          | do_bucket (res,[]) = res
        fun down (res, i) =
          if i = len 
            then res
          else down (do_bucket (res, array_sub(arr,i)),i+1)
      in
        down (res, 0)
      end

    val makestring = Int.toString

    fun assoc_default' (_, []) = NONE
      | assoc_default' (key:int, (k, vref) :: xs) =
	if key = k
          then SOME vref
        else assoc_default' (key, xs)

    exception Crash of string
    fun crash s = raise Crash s

    fun replace (k:int,value,[],acc) = crash "empty list in replace"
      | replace (k:int,value,(entry as (k',_))::rest,acc) =
        if k = k'
          then (k,SOME value) :: acc @@ rest
        else
          replace (k,value,rest,entry::acc)
          
    fun update(initial as ref (elt_array,count_down as ref c,old_mask), key, value) =
      let
	val pos = Bits.andb(key,old_mask)
	val list_map = array_sub(elt_array, pos)
      in
        (if member (key,list_map)
           then MLWorks.Internal.Array.update (elt_array,pos,replace (key,value,list_map,[]))
         else
             (if c <= 0
                then 
                  let
                    val old_size = MLWorks.Internal.Array.length elt_array
                    val _ = if print_debug then
		      print("Resizing int table: " ^ makestring(old_size) ^ "...\n")
                            else ()
                    val new_size = old_size * expansion_ratio
                    val new_arr = MLWorks.Internal.Array.array(new_size, [])
                    val new_mask = new_size - 1
                    val _ = initial := (new_arr,ref(max_size_ratio * (new_size - old_size) + c - 1),new_mask)
		    (* Since the expansion size is two, we can calculate the new position  *)
		    (* of the elements from the old positions very easily *)
		    fun partition([],size,f,s) = (f,s)
		      | partition((elem as (key,_))::rest,size,f,s) =
			if Bits.andb(key,size) = 0
			  then partition(rest,size,elem::f,s)
			else partition(rest,size,f,elem::s)

                    fun deal_with_elements index = 
                      if index < 0
                        then ()
                      else
                        let
                          val elems = array_sub(elt_array,index)
                       in
                         case elems of
                           [] => deal_with_elements (index-1)
                         | _ =>
                             let
                               val (f,s) =
                                 partition(elems,old_size,[],[])
                             in
                               array_update(new_arr,index,f);
                               array_update(new_arr,index + old_size,s);
                               deal_with_elements (index-1)
                             end
                       end
                 in
                   deal_with_elements (old_size-1);
                   let
                     val new_pos = Bits.andb(key,new_mask)                     
                     val old_value = array_sub(new_arr, new_pos)
                   in 
                     array_update(new_arr, new_pos, (key,SOME value)::old_value)
                   end
                 end
             else (count_down := c - 1;
                   array_update(elt_array, pos, (key, SOME value) :: list_map))))
      end

    fun delete_from_list (key, [], acc) = (acc, false)
      | delete_from_list (key:int, (elt as (k, _)) :: rest, acc) =
	if key =  k then
	  (acc @@ rest, true)
	else
	  delete_from_list(key, rest, elt :: acc)

    fun delete(ref (elt_array,count_down,mask), key) =
      let
	val pos = Bits.andb(key,mask)
	val list_map = array_sub(elt_array, pos)
	val (list_map, found) = delete_from_list(key, list_map, [])
        val _ = count_down := !count_down + 1
      in
	array_update(elt_array, pos, list_map)
      end

    fun check_nil(array, curr, max) =
      if curr >= max then true
      else
	case array_sub(array, curr) of
	  [] => check_nil(array, curr + 1, max)
	| _ => false

    fun empty_setp(ref (elt_array,_,_)) =
      check_nil(elt_array, 0, MLWorks.Internal.Array.length elt_array)

    fun add_members(pos:int, max, mems, elts) =
      if pos >= max then
	mems
      else
	let
	  val set = map (fn (x,SOME y) => (x,y) | _ => crash "add_members") (array_sub(elts, pos))
	in
	  add_members(pos+1, max, set @@ mems, elts)
	end

    fun to_list(ref (elt_array,_,_)) =
      add_members(0, MLWorks.Internal.Array.length elt_array, [], elt_array)

    fun copy_array(old_array, new_array, max, curr) =
      if curr >= max then new_array
      else
	let
	  val this = array_sub(old_array, curr)
	  val _ = array_update(new_array, curr, this)
	in
	  copy_array(old_array, new_array, max, curr+1)
	end

    fun copy(ref (elt_array,count_down,mask)) =
      let
	val len = MLWorks.Internal.Array.length elt_array
	val new_array = MLWorks.Internal.Array.array(len, [])
	val _ = copy_array(elt_array, new_array, len, 0)
      in
	ref (new_array,ref(!count_down),mask)
      end

    fun map f (ref(table as (elt_array,count_down,_))) =
      let
        val new_table = new(MLWorks.Internal.Array.length elt_array)
      in
        iterate_hash (fn (x,y) => update(new_table,x,f (x,y))) table;
        new_table
      end

    fun stats(ref (arr,_,_)) = 
      let
        val len = MLWorks.Internal.Array.length arr
        val largest = ref 0
        val smallest = ref(if len >0
                             then Lists.length(array_sub(arr,0))
                           else 0)
        val count = ref(0)

        fun walk_buckets x =
          if x<0
            then ()
          else
            let
              val length = Lists.length(array_sub(arr,x))
              val _ = if length > !largest 
                        then largest := length
                      else ()
              val _ = if length < !smallest
                        then smallest := length
                      else ()
            in
              (count := !count + length;
               walk_buckets(x-1))
            end

        val _ = walk_buckets (len - 1)
      in
        {size = len,
         smallest = !smallest,
         largest = ! largest,
         count = ! count}
      end

    fun print_stats table =
      let
        val {size : int ,count : int ,smallest : int ,largest : int} = stats table
        val string =
        if count>0
          then
            ("statistics:\n"^
             " size = "^(makestring size)^"\n"^
             " count = "^(makestring count)^"\n"^
             " smallest = " ^(makestring smallest)^"\n"^
             " largest = "^(makestring largest)^"\n")
        else " EMPTY\n"
      in
	print string
      end
        

  end
@


1.9.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.9  1997/05/19  13:16:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.9.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.9  1997/05/19  13:16:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.9.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.9  1997/05/19  13:16:13  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.8
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d194 2
a195 2
                    val _ = if print_debug 
                              then MLWorks.IO.output(MLWorks.IO.std_out,"Resizing int table: " ^ makestring(old_size) ^ "...\n")
d355 1
a355 1
        MLWorks.IO.output (MLWorks.IO.std_out,string)
@


1.7
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
a43 1
    structure Option = MLWorks.Option
d51 1
a51 1
    type '_a T = ((int * '_a Option.option) list MLWorks.Internal.Array.array * int ref * int) ref
d91 1
a91 1
                 Option.SOME x => x
d101 1
a101 1
        fun assoc_default (key,[]) = Option.NONE
d124 1
a124 1
        Option.SOME res => res
d135 1
a135 1
             (fn (k, Option.SOME v) => f(k,v) | _ => ())
d147 1
a147 1
        fun do_bucket (res,((k,Option.SOME v)::rest)) =
d149 1
a149 1
          | do_bucket (res, ((k,Option.NONE)::rest)) =
d162 1
a162 1
    fun assoc_default' (_, []) = Option.NONE
d165 1
a165 1
          then Option.SOME vref
d174 1
a174 1
          then (k,Option.SOME value) :: acc @@ rest
d230 1
a230 1
                     array_update(new_arr, new_pos, (key,Option.SOME value)::old_value)
d234 1
a234 1
                   array_update(elt_array, pos, (key, Option.SOME value) :: list_map))))
d269 1
a269 1
	  val set = map (fn (x,Option.SOME y) => (x,y) | _ => crash "add_members") (array_sub(elts, pos))
@


1.7.5.1
log
@branched from 1.7
@
text
@a3 4
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.7.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.7.5.1  1997/05/12  10:53:04  hope
 * branched from 1.7
 *
@


1.7.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.7.5.1  1997/05/12  10:53:04  hope
 * branched from 1.7
 *
@


1.7.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.7.5.1  1997/05/12  10:53:04  hope
 * branched from 1.7
 *
@


1.7.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.7.5.1.1.1  1997/07/28  18:36:15  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a3 4
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a3 4
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.7.3.1.1.1
log
@branched from 1.7.3.1
@
text
@a3 3
 * Revision 1.7.3.1  1996/12/17  18:19:30  hope
 * branched from 1.7
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a3 4
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a3 4
 * Revision 1.7  1996/11/06  10:52:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.7.1.1.1.1
log
@branched from 1.7.1.1
@
text
@a3 3
 * Revision 1.7.1.1  1996/11/14  13:23:27  hope
 * branched from 1.7
 *
@


1.6
log
@Moving Bits to MLWorks.Internal
@
text
@d4 3
d28 1
a28 1
require "../basis/__integer";
@


1.6.3.1
log
@branched from 1.6
@
text
@a3 3
 * Revision 1.6  1996/05/17  09:19:06  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a3 3
 * Revision 1.6  1996/05/17  09:19:06  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a3 3
 * Revision 1.6  1996/05/17  09:19:06  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.5
log
@Array moving to MLWorks.Array
@
text
@d4 3
d36 1
d195 1
a195 1
			if MLWorks.Bits.andb(key,size) = 0
@


1.4
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d41 1
a41 1
    type '_a T = ((int * '_a Option.option) list Array.array * int ref * int) ref
d69 1
a69 1
          ref(Array.array(initial_size, []),
d119 1
a119 1
        val len = Array.length arr
d136 1
a136 1
        val len = Array.length arr
d174 1
a174 1
           then Array.update (elt_array,pos,replace (key,value,list_map,[]))
d179 1
a179 1
                    val old_size = Array.length elt_array
d184 1
a184 1
                    val new_arr = Array.array(new_size, [])
d252 1
a252 1
      check_nil(elt_array, 0, Array.length elt_array)
d265 1
a265 1
      add_members(0, Array.length elt_array, [], elt_array)
d279 2
a280 2
	val len = Array.length elt_array
	val new_array = Array.array(len, [])
d288 1
a288 1
        val new_table = new(Array.length elt_array)
d296 1
a296 1
        val len = Array.length arr
@


1.3
log
@Removing MLWorks.Integer
@
text
@d3 4
a6 1
$Log: _inthashtable.sml,v $
d10 5
a14 6
# Revision 1.1  1994/09/23  14:48:52  matthew
# new file
#

Copyright (c) 1994 Harlequin Ltd.
*)
d175 1
a175 1
                              then output(std_out,"Resizing int table: " ^ makestring(old_size) ^ "...\n")
d335 1
a335 1
        output (std_out,string)
@


1.2
log
@Diddling
@
text
@d4 3
d14 2
d142 1
a142 1
    val makestring = MLWorks.Integer.makestring
@


1.1
log
@new file
@
text
@d4 3
d22 7
a28 1
    type '_a T = ((int * '_a ref) list Array.array * int ref * int) ref
d30 3
d42 1
a42 1
    val max_size_ratio = 1  (* resize when number of elements is this multiplied by the size *)
d47 1
a47 1
      fun nearest_power_of_two (size,x) =
d50 1
a50 1
        else nearest_power_of_two (size,2*x)
d66 6
a71 2
            if key = k then !v else assoc xs
	val list_map = Array.sub (elt_array, Bits.andb(key,mask))
d76 1
a76 7
    fun assoc_default (_, []) = Option.NONE
      | assoc_default (key:int, (k, ref v) :: xs) =
	if key = k
          then Option.SOME v
        else assoc_default (key, xs)

    fun tryLookup(ref (elt_array,_,mask),key) =
d78 6
a83 1
	val list_map = Array.sub(elt_array, Bits.andb(key,mask))
d88 4
d94 1
a94 4
        fun member (_, []) = false
          | member (key:int, (k, _) :: rest) =
            key = k orelse member (key,rest)
        val list_map = Array.sub(elt_array, Bits.andb(key,mask))
d112 2
a113 2
             (fn (k, ref v) => f(k,v))
             (Array.sub (arr, i));
d124 5
d130 3
a132 6
          if i = len then res
          else
	    down(Lists.reducel 
                 (fn (res, (k, ref v)) => f(res, k, v))
                 (res, Array.sub(arr,i)), 
                 i+1)
d145 10
d158 1
a158 2
	val list_map = Array.sub(elt_array, pos)
        val assoced = assoc_default'(key, list_map)
d160 3
a162 3
        (case assoced of
           Option.SOME r => r := value 
         | Option.NONE => 
d168 1
a168 1
                              then output(std_out,"Resizing " ^ makestring(old_size) ^ "...\n")
d187 1
a187 1
                          val elems = Array.sub(elt_array,index)
d196 2
a197 2
                               Array.update(new_arr,index,f);
                               Array.update(new_arr,index + old_size,s);
d205 1
a205 1
                     val old_value = Array.sub(new_arr, new_pos)
d207 1
a207 1
                     Array.update(new_arr, new_pos, (key,ref value)::old_value)
d211 1
a211 1
                   Array.update(elt_array, pos, (key, ref value) :: list_map))))
d224 1
a224 1
	val list_map = Array.sub(elt_array, pos)
d228 1
a228 1
	Array.update(elt_array, pos, list_map)
d234 1
a234 1
	case Array.sub(array, curr) of
d246 1
a246 1
	  val set = map (fn (x,ref y) => (x,y)) (Array.sub(elts, pos))
a253 6
    (* have to copy each entry because it's all ref cells *)

    fun copy_list (acc,[]) = acc (* reversal doesn't matter *)
      | copy_list (acc,(k,ref v)::xs) =
      copy_list ((k,ref v)::acc,xs)

d258 2
a259 2
	  val this = Array.sub(old_array, curr)
	  val _ = Array.update(new_array, curr, copy_list ([],this))
d286 1
a286 1
                             then Lists.length(Array.sub(arr,0))
d295 1
a295 1
              val length = Lists.length(Array.sub(arr,x))
@
