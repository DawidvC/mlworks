head	1.1;
access;
symbols
	MLW_daveb_inline_1_4_99:1.1.4
	MLWorks_21c0_1999_03_25:1.1
	MLWorks_20c1_1998_08_20:1.1
	MLWorks_20c0_1998_08_04:1.1
	MLWorks_20b2c2_1998_06_19:1.1
	MLWorks_20b2_Windows_1998_06_12:1.1
	MLWorks_20b1c1_1998_05_07:1.1
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_11r1:1.1.1.1.1.1.1
	MLWorks_workspace_97:1.1.3
	MLWorks_dt_wizard:1.1.2
	MLWorks_11c0_1997_09_09:1.1.1.1.1.1
	MLWorks_10r3:1.1.1.1.3
	MLWorks_10r2_551:1.1.1.1.2
	MLWorks_11:1.1.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.1.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.1
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1;
locks; strict;
comment	@ *  @;


1.1
date	97.01.29.10.27.54;	author andreww;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1;
next	;

1.1.1.1
date	97.05.12.10.53.36;	author hope;	state Exp;
branches
	1.1.1.1.1.1
	1.1.1.1.2.1
	1.1.1.1.3.1;
next	;

1.1.1.1.1.1
date	97.07.28.18.35.52;	author daveb;	state Exp;
branches
	1.1.1.1.1.1.1.1;
next	;

1.1.1.1.1.1.1.1
date	97.10.07.12.01.17;	author jkbrook;	state Exp;
branches;
next	;

1.1.1.1.2.1
date	97.09.08.17.28.20;	author daveb;	state Exp;
branches;
next	;

1.1.1.1.3.1
date	97.09.09.14.25.53;	author daveb;	state Exp;
branches;
next	;

1.1.2.1
date	97.09.10.19.44.38;	author brucem;	state Exp;
branches;
next	;

1.1.3.1
date	97.09.11.21.11.54;	author daveb;	state Exp;
branches;
next	;

1.1.4.1
date	99.04.01.18.09.47;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
new mutual exclusion primitives.
@


1.1
log
@new unit
new mutual exclusion primitives.
@
text
@(*
 * MLWorks mutual exclusion primitives.
 *
 * Revision Log:
 * -------------
 * $Log:,v$
 *
 *
 * Copyright (C) 1997 Harlequin Ltd.
 *)



require "mutex.sml";



structure Mutex : MUTEX =
struct
  structure T = MLWorks.Threads;
  structure I = T.Internal;
  structure P = I.Preemption;

  exception Mutex of string;

  (* note that the Threads.result datatype is not an equality type
     (since exceptions don't admit equality) *)

  fun state_eq(T.Died,T.Died) = true
    | state_eq(T.Running,T.Running) = true
    | state_eq(T.Sleeping,T.Sleeping) = true
    | state_eq(T.Exception _,T.Exception _) = true
    | state_eq(T.Expired,T.Expired) = true
    | state_eq(T.Killed,T.Killed) = true
    | state_eq(T.Result _,T.Result _) = true
    | state_eq(T.Waiting,T.Waiting) = true
    | state_eq _ = false




  abstype mutex = COUNTING of {counter: int, waiting: I.thread_id list} ref
                |   BINARY of {claimed: bool, waiting: I.thread_id list} ref
  with
    fun newCountingMutex size = 
      COUNTING (ref {counter=
                  (if size<0
                     then raise Mutex "initial counter must be greater than 0"
                   else size),
                  waiting=[]})
        

    fun newBinaryMutex flag = BINARY (ref {claimed=flag, waiting=[]})



      (* wait l
         1. enters critical section.
         tests if all mutexes in l are free:
           If so, it claims them all, and stops, exiting the critical section.
           Otherwise we have to sleep, exiting the critical section.
           If we are dead or killed, we can't sleep --- so we just exit
           the critical section until next time round the loop. *)


    fun wait mutices =
      let
        val self = I.id()

        fun allFree [] = true
          | allFree (COUNTING(m as ref{counter,waiting})::rest) =
          if counter=0 then (m:={counter=counter,
                                 waiting=waiting@@[self]};
                             false)
          else allFree rest
          | allFree (BINARY(m as ref{claimed,waiting})::rest) =
            if claimed then (m:={claimed=claimed,
                                 waiting=waiting@@[self]};
                             false)
            else allFree rest
              
              
        fun claimAll [] = ()
          | claimAll (COUNTING(m as ref{counter,waiting})::rest) =
                      (m:={counter=counter-1,waiting=waiting};
                       claimAll rest)
          | claimAll (BINARY(m as ref{claimed,waiting})::rest) =
                      (m:={claimed=true,waiting=waiting};
                       claimAll rest)
      in
        P.enter_critical_section();
        if allFree mutices
          then (
                claimAll mutices;
                P.exit_critical_section()
                )
          else (
                T.sleep(self);      (*self-sleep leaves critical section*)
                wait mutices
                )    (* when thread is next wakened, at least one mutex
                        may be free: still need to check the rest though. *)
      end

      
      
    (* returns true if mutexes are all available, false otherwise. *)

      
    fun test mutices =
      let
        fun allFree [] = true
          | allFree (COUNTING(ref{counter,...})::rest) =
          counter>0 andalso allFree rest
          | allFree (BINARY(ref{claimed,...})::rest) =
          not claimed andalso allFree rest
      in
        (P.enter_critical_section();
         allFree mutices before (P.exit_critical_section()))
      end
    
    


    (* tests and claims mutices if all free, returing true,
     otherwise returns false *)

    fun testAndClaim mutices =
      let
        fun allFree [] = true
          | allFree (COUNTING(ref{counter,...})::rest) =
          counter>0 andalso allFree rest
          | allFree (BINARY(ref{claimed,...})::rest) =
          not claimed andalso allFree rest

        fun claimAll [] = ()
          | claimAll (COUNTING(m as ref{counter,waiting})::rest) =
                      (m:={counter=counter-1,waiting=waiting};
                       claimAll rest)
          | claimAll (BINARY(m as ref{claimed,waiting})::rest) =
                      (m:={claimed=true,waiting=waiting};
                       claimAll rest)
      in
        (P.enter_critical_section();
         (if allFree mutices then (claimAll mutices; true)
          else false) before (P.exit_critical_section())
        )
      end




    fun signal mutices =
       let
         fun wakeAll [] = ()
           | wakeAll (h::t) =
              (if state_eq(I.state h,T.Sleeping)  (* thread may be dead*)
                 then T.wake h
               else ();
               wakeAll t)


         fun releaseAll [] = ()
           | releaseAll (COUNTING(m as ref{counter,waiting})::rest) =
                (wakeAll waiting;
                 m:={counter=counter+1,waiting=[]};
                 releaseAll rest)
           | releaseAll (BINARY(m as ref{claimed,waiting})::rest) =
                (wakeAll waiting;
                 m:={claimed=false,waiting=[]};
                 releaseAll rest)

       in
         P.enter_critical_section();
         releaseAll mutices;
         P.exit_critical_section()
       end

      
    fun query (COUNTING(ref{counter,waiting})) = waiting
      | query (BINARY(ref{claimed,waiting})) = waiting



    fun allSleeping mutices =
      let
        fun allAsleep [] = true
          | allAsleep (h::t) = state_eq(I.state h,T.Sleeping)
                               andalso allAsleep t

      in
        P.enter_critical_section();
        allAsleep mutices before
        (P.exit_critical_section())
      end


    (* the following restores a clean thread state *)

    fun cleanUp () =
      let
        fun kill [] = P.exit_critical_section()
          | kill (h::t) = 
            (if I.get_num h>1 then I.kill h else (); kill t)
          
      in
        P.enter_critical_section();
        kill(I.all());
        P.exit_critical_section()
      end

  end



  (* Higher-level synchronization devices. *)

  fun critical (mutices,f) x =
    let val _ = wait mutices
        val result = f x
        val _ = signal mutices
    in
      result
    end handle e => (signal mutices; raise e)



      (* note that the following does *not* release mutexes when the
         awaited condition is satisifed. *)

  fun await(mutices,condition) =
    (wait mutices;
     if (condition() handle e => (signal mutices; raise e)) then ()
     else await((signal mutices;mutices),condition)
    )
end;

@


1.1.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@d6 1
a6 5
 * $Log: __mutex.sml,v $
 *  Revision 1.1  1997/01/29  10:27:54  andreww
 *  new unit
 *  new mutual exclusion primitives.
 *
@


1.1.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@d6 1
a6 5
 * $Log: __mutex.sml,v $
 *  Revision 1.1  1997/01/29  10:27:54  andreww
 *  new unit
 *  new mutual exclusion primitives.
 *
@


1.1.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@d6 1
a6 5
 * $Log: __mutex.sml,v $
 *  Revision 1.1  1997/01/29  10:27:54  andreww
 *  new unit
 *  new mutual exclusion primitives.
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d6 1
a6 5
 * $Log: __mutex.sml,v $
 *  Revision 1.1  1997/01/29  10:27:54  andreww
 *  new unit
 *  new mutual exclusion primitives.
 *
@


1.1.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 *  Revision 1.1.1.1  1997/05/12  10:53:36  hope
 *  branched from 1.1
 *
@


1.1.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 *  Revision 1.1.1.1  1997/05/12  10:53:36  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 *  Revision 1.1.1.1  1997/05/12  10:53:36  hope
 *  branched from 1.1
 *
@


1.1.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 *  Revision 1.1.1.1.1.1  1997/07/28  18:35:52  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@
