head	1.5;
access;
symbols
	MLW_daveb_inline_1_4_99:1.5.8
	MLWorks_21c0_1999_03_25:1.5
	MLWorks_20c1_1998_08_20:1.5
	MLWorks_20c0_1998_08_04:1.5
	MLWorks_20b2c2_1998_06_19:1.5
	MLWorks_20b2_Windows_1998_06_12:1.5
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.5.5.1.1.1.1
	MLWorks_workspace_97:1.5.7
	MLWorks_dt_wizard:1.5.6
	MLWorks_11c0_1997_09_09:1.5.5.1.1.1
	MLWorks_10r3:1.5.5.1.3
	MLWorks_10r2_551:1.5.5.1.2
	MLWorks_11:1.5.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.5.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.5
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.3.1.1
	MLWorks_gui_1996_12_18:1.5.4
	MLWorks_1_0_Win32_1996_12_17:1.5.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.3.3
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3;
locks; strict;
comment	@ * @;


1.5
date	96.11.06.10.53.10;	author matthew;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1
	1.5.7.1
	1.5.8.1;
next	1.4;

1.4
date	96.11.02.19.35.35;	author io;	state Exp;
branches;
next	1.3;

1.3
date	96.05.01.11.44.27;	author jont;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1;
next	1.2;

1.2
date	96.04.30.14.58.23;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.03.30.11.55.24;	author brianm;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.43.34;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.36.47;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.10.17.11.55.47;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.13.24.08;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.15.34.52;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.41.14;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.18.20.11;	author hope;	state Exp;
branches
	1.5.3.1.1.1;
next	;

1.5.3.1.1.1
date	97.02.24.12.14.39;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.18.10.15.43;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	97.05.12.10.53.51;	author hope;	state Exp;
branches
	1.5.5.1.1.1
	1.5.5.1.2.1
	1.5.5.1.3.1;
next	;

1.5.5.1.1.1
date	97.07.28.18.35.25;	author daveb;	state Exp;
branches
	1.5.5.1.1.1.1.1;
next	;

1.5.5.1.1.1.1.1
date	97.10.07.12.01.00;	author jkbrook;	state Exp;
branches;
next	;

1.5.5.1.2.1
date	97.09.08.17.28.02;	author daveb;	state Exp;
branches;
next	;

1.5.5.1.3.1
date	97.09.09.14.25.26;	author daveb;	state Exp;
branches;
next	;

1.5.6.1
date	97.09.10.19.44.04;	author brucem;	state Exp;
branches;
next	;

1.5.7.1
date	97.09.11.21.11.29;	author daveb;	state Exp;
branches;
next	;

1.5.8.1
date	99.04.01.18.09.30;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.5
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== UTILITIES : STRING LIBRARY ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Will add `to_intarray'/`from_intarray' later - as C primitives.
 *  The use of int arrays means that items are word indexed rather
 *  than byte accessed.  Also, standard integer operations can be
 *  applied - converting back to a string does the implicit byte
 *  conversion.
 *
 * 
 *  Revision Log
 *  ------------
 *  $Log: _stringlib.sml,v $
 * Revision 1.4  1996/11/02  19:35:35  io
 * [Bug #1614]
 * remove toplevel String.
 *
 * Revision 1.3  1996/05/01  11:44:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.2  1996/04/30  14:58:23  matthew
 * Removing utils/*integer
 *
 * Revision 1.1  1995/03/30  11:55:24  brianm
 * new unit
 * New file.
 *
 *
 *)

require "^.basis.__char";
require "^.basis.__string";
require "^.basis.__int";
require "lists";
require "stringlib";

functor StringLib(
   structure Lists : LISTS
) : STRING_LIB =

   struct

   (* Implementation : auxiliaries *)

      fun substr_excl (str,left,right1) =
          let val origin = Int.max(0, left)
              val size   = Int.max(0, right1-origin)
                           (* Note: 1 <= right1 <= size(str) *)
          in
              substring(str,origin,size)
          end

      fun substr_incl (str,left,right) = substr_excl(str,left,1+right)
          (* for 0 <= right0 <= size(str) - 1 *)

      fun rev_explode_char(str) =
	  let fun getord(0,_,l) = l
  		| getord(n,i,l) = getord(n-1,i+1,MLWorks.String.ordof(str,i)::l)
	  in
	      getord(size(str),0,[])
	  end
	
      fun rev_explode_char s = 
	let fun scan (0, _, l) = l
	      | scan (n,i,l) = scan (n-1, i+1, chr (MLWorks.String.ordof (s,i)) ::l)
	in
	  scan (size s, 0, [])
	end
	  



   (* Definitions *)

      fun memstr(str) =
          let val chars = rev_explode_char(str)
          in
              fn (c) => Lists.member(c,chars)
          end

      fun squash(P,str) =
	implode(Lists.filter_outp P (explode str))

      fun trim_left(P, str) =
          let val len_str   = size(str)
              val len_str1  = len_str - 1
              fun from_left(k,i) =
                  if (k<=0) then i else
		  if P(chr (MLWorks.String.ordof(str,i))) then from_left(k-1,i+1) else i
          in
              substr_excl(str,from_left(len_str1,0),len_str)
          end

      fun trim_right(P, str) =
          let val len_str1  = size(str) - 1
              fun from_right(i) =
                  if (i<=0) then i else
		  if P(chr (MLWorks.String.ordof(str,i))) then from_right(i-1) else i
          in
              substr_incl(str,0,from_right(len_str1))
          end
 
      local

         fun find_first_char(str,sz,P) =
             let fun fst_ch(k,i) =
                     if (k<0) then i else
		     if P(String.sub(str,i)) then i else fst_ch(k-1,i+1)
             in
                 fst_ch(sz,0)
             end
      in
	 fun leading(P, str) =
	     let val len_str1   = size(str) - 1
		 val first_idx  = find_first_char(str,len_str1,P)
	     in
		 substr_excl(str,0,first_idx)
  	     end

	 fun leading_split(P,str) =
	     let val len_str     = size(str)
                 val len_str1    = len_str - 1
		 val split_idx   = find_first_char(str,len_str1,P)
                 val left_str    = substr_excl(str,0,split_idx)
		 val right_str   = substr_excl(str,split_idx,len_str)
	     in
		 ( left_str, right_str )
  	     end
      end

      local
         fun find_last_char(str,sz,P) =
             let fun lst_ch(k) =
                       if (k<0) then ~1 else
		       if P(String.sub(str,k)) then k+1 else lst_ch(k-1)
             in
                 lst_ch(sz)
             end
      in
	 fun trailing(P,str) =
	     let val len_str    = size(str)
                 val len_str1   = len_str - 1
		 val last_idx   = find_last_char(str,len_str1,P)
	     in
		 substr_excl(str,last_idx,len_str)
  	     end

	 fun trailing_split(P,str) =
	     let val len_str     = size(str)
                 val len_str1    = len_str - 1
		 val split_idx   = find_last_char(str,len_str1,P)
                 val left_str    = substr_excl(str,0,split_idx)
		 val right_str   = substr_excl(str,split_idx,len_str)
	     in
		 ( left_str, right_str )
  	     end
      end

      local
         val a =  #"a"
         val A =  #"A"

         val z =  #"z"
         val Z =  #"Z"

         fun is_lc(i)  =  ( a <= i andalso i <= z ) 
         fun is_uc(i)  =  ( A <= i andalso i <= Z ) 

         val zero =  #"0"
         val one  =  #"1"
         val nine =  #"9"

         fun is_dg(i)  =  ( one <= i andalso i <= nine ) orelse ( zero = i ) 

         fun lc'(i) = chr (ord i - ord A + ord a)
         fun uc'(i) = chr (ord i - ord a + ord A)
  
         fun lc(i) = if is_uc(i) then lc'(i) else i
         fun uc(i) = if is_lc(i) then uc'(i) else i

         datatype cap_state = UC | LC

         fun cap_char(UC,i) = uc(i)
           | cap_char(LC,i) = lc(i)
      in

         val is_lower_case = Char.isLower
         val is_upper_case = Char.isUpper
         val is_digit      = Char.isDigit
         
         val is_letter      = Char.isAlpha
         val is_alpha       = Char.isAlphaNum
	   
	 fun to_lower(str) =
	   let fun doit(i::l,r) = doit(l,lc(i)::r)
		 | doit([],r)   = r
	   in
	     implode (doit(explode str,[]))
	   end
	 val to_lower = implode o (map Char.toLower) o explode

	 fun to_upper(str) =
             let fun doit(i::l,r) = doit(l,uc(i)::r)
                   | doit([],r)   = r
             in
	       implode (doit(rev_explode_char(str),[]))
             end
	 val to_upper = implode o (map Char.toUpper) o explode
	   
         fun capitalise(P,str) =
             let fun doit(st,0,_,r) = rev r
                   | doit(st,i,j,r) =
                     let val a = chr (MLWorks.String.ordof(str,j))
		       val letterp = is_letter(a)
		         val a'  = if letterp then cap_char(st,a) else a
                         val st' = if letterp then LC else
                                   if P(a) then UC else st
                     in
                         doit(st',i-1,j+1,a'::r)
                     end
             in
	       implode (doit(UC,size(str),0,[]))
             end
      end
   end
@


1.5.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a16 3
 * Revision 1.5.5.1  1997/05/12  10:53:51  hope
 * branched from 1.5
 *
@


1.5.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a16 3
 * Revision 1.5.5.1  1997/05/12  10:53:51  hope
 * branched from 1.5
 *
@


1.5.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a16 3
 * Revision 1.5.5.1  1997/05/12  10:53:51  hope
 * branched from 1.5
 *
@


1.5.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a16 3
 * Revision 1.5.5.1.1.1  1997/07/28  18:35:25  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.3.1.1.1
log
@branched from 1.5.3.1
@
text
@a16 3
 * Revision 1.5.3.1  1996/12/17  18:20:11  hope
 * branched from 1.5
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a16 4
 * Revision 1.5  1996/11/06  10:53:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a16 3
 * Revision 1.5.1.1  1996/11/14  13:24:08  hope
 * branched from 1.5
 *
@


1.4
log
@[Bug #1614]
remove toplevel String.
@
text
@d17 4
d39 1
a39 1
require "^.basis.__integer";
@


1.3
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d17 6
d33 3
a35 2
require "../basis/__integer";

a36 1

a39 1

a40 1

a44 12
   (* Mapping *)

      val member       = Lists.member
      val filter_outp  = Lists.filter_outp

      val substring    = String.substring
      val ordof        = String.ordof          (* (string * int) -> int *)
      val implode_char = String.implode_char
   
      val max = Int.max


d48 2
a49 2
          let val origin = max(0, left)
              val size   = max(0, right1-origin)
d60 1
a60 1
  		| getord(n,i,l) = getord(n-1,i+1,ordof(str,i)::l)
d64 9
d80 1
a80 1
              fn (c) => member(c,chars)
d84 1
a84 1
             String.implode(filter_outp (P o String.ord) (String.explode str))
d91 1
a91 1
		  if P(ordof(str,i)) then from_left(k-1,i+1) else i
d100 1
a100 1
		  if P(ordof(str,i)) then from_right(i-1) else i
d110 1
a110 1
		     if P(ordof(str,i)) then i else fst_ch(k-1,i+1)
d137 1
a137 1
		       if P(ordof(str,k)) then k+1 else lst_ch(k-1)
d162 2
a163 2
         val a = String.ord("a")
         val A = String.ord("A")
d165 2
a166 2
         val z = String.ord("z")
         val Z = String.ord("Z")
d171 3
a173 3
         val zero = String.ord("0")
         val one  = String.ord("1")
         val nine = String.ord("9")
d177 2
a178 2
         fun lc'(i) = i - A + a
         fun uc'(i) = i - a + A
d189 3
a191 3
         val is_lower_case = is_lc
         val is_upper_case = is_uc
         val is_digit      = is_dg
d193 3
a195 3
         fun is_letter c     = is_lc(c) orelse is_uc(c)
         fun is_alpha  c     = is_letter(c) orelse is_dg(c)

d197 6
a202 5
             let fun doit(i::l,r) = doit(l,lc(i)::r)
                   | doit([],r)   = r
             in
                 implode_char(doit(rev_explode_char(str),[]))
             end
d208 1
a208 1
                 implode_char(doit(rev_explode_char(str),[]))
d210 2
a211 1

d215 2
a216 2
                     let val a = ordof(str,j)
                         val letterp = is_letter(a)
d224 1
a224 1
                 implode_char(doit(UC,size(str),0,[]))
@


1.3.3.1
log
@branched from 1.3
@
text
@a16 6
 * Revision 1.3  1996/05/01  11:44:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a16 6
 * Revision 1.3  1996/05/01  11:44:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a16 6
 * Revision 1.3  1996/05/01  11:44:27  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.2
log
@Removing utils/*integer
@
text
@d17 3
d83 1
a83 1
             implode(filter_outp (P o ord) (explode str))
d161 2
a162 2
         val a = ord("a")
         val A = ord("A")
d164 2
a165 2
         val z = ord("z")
         val Z = ord("Z")
d170 3
a172 3
         val zero = ord("0")
         val one  = ord("1")
         val nine = ord("9")
@


1.1
log
@new unit
New file.
@
text
@d16 5
a20 1
 *  $Log$
d24 2
a26 1
require "integer";
a32 1
   structure Integer : INTEGER
d47 1
a47 1
      val max = Integer.max
@
