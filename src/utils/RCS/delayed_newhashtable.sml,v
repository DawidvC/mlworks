head	1.4;
access;
symbols
	ML_beta_release_12/08/94:1.4
	ML_beta_release_03/08/94:1.4
	ML_revised_beta_release_25/05/94:1.4
	ML_final_beta_release_02/03/94:1.4
	mlworks-28-01-1994:1.4
	Release:1.3
	mlworks-beta-01-09-1993:1.3
	MLWorks-1-0-4-29/01/1993:1.3
	MLWorks-1-0-3-21/12/1992:1.3
	MLWorks-1-0-2-15/12/1992:1.3
	MLWorks-1-0-1-04/12/1992:1.3;
locks; strict;


1.4
date	93.12.09.19.45.46;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.09.22.13.13.08;	author clive;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	92.09.21.10.24.51;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.09.16.09.58.09;	author clive;	state Exp;
branches;
next	;

1.3.1.1
date	92.09.22.13.13.08;	author jont;	state Exp;
branches;
next	;


desc
@First version
@


1.4
log
@Added copyright message
@
text
@(* delayed_newhashtable the signature *)
(*
$Log: delayed_newhashtable.sml,v $
Revision 1.3  1992/09/22  13:13:08  clive
Needed to make some type variables weak

Revision 1.2  1992/09/21  10:24:51  clive
Changed hashtables to a single structure implementation

Revision 1.1  1992/09/16  09:58:09  clive
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
*)


signature DELAYED_NEWHASHTABLE =
  sig
    type ('_Key,'_Value) HashTable
    datatype 'a option = YES of 'a | NO
    exception Lookup 
    val new     : int * ('_Key * '_Key -> bool) * ('_Key -> int) -> ('_Key,'_Value) HashTable
    val lookup  : (('_Key,'_Value) HashTable * '_Key) -> '_Value
    val lookup_default  : (('_Key,'_Value) HashTable * '_Value * '_Key) -> '_Value
    val tryLookup : (('_Key,'_Value) HashTable * '_Key) -> '_Value option
    val update  : (('_Key,'_Value) HashTable * '_Key * '_Value) -> unit
    val delete  : (('_Key,'_Value) HashTable * '_Key) -> unit
    val to_list : ('_Key,'_Value) HashTable -> ('_Key * '_Value) list
    val copy    : ('_Key,'_Value) HashTable -> ('_Key,'_Value) HashTable
    val fold    : ('a * '_Key * '_Value -> 'a) -> ('a * ('_Key,'_Value) HashTable) -> 'a
    val iterate : ('_Key * '_Value -> unit) -> ('_Key,'_Value) HashTable -> unit
    val stats : ('_Key,'_Value) HashTable -> {size:int, count:int, smallest:int, largest:int}
    val string_hash_table_stats : ('_Key,'_Value) HashTable -> string
  end
@


1.3
log
@Needed to make some type variables weak
@
text
@d4 3
d13 1
@


1.3.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.3  1992/09/22  13:13:08  clive
Needed to make some type variables weak

@


1.2
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d19 3
a21 3
    val lookup  : (('Key,'Value) HashTable * 'Key) -> 'Value
    val lookup_default  : (('Key,'Value) HashTable * 'Value * 'Key) -> 'Value
    val tryLookup : (('Key,'Value) HashTable * 'Key) -> 'Value option
d23 2
a24 2
    val delete  : (('Key,'Value) HashTable * 'Key) -> unit
    val to_list : ('Key,'Value) HashTable -> ('Key * 'Value) list
d26 4
a29 4
    val fold    : ('a * 'Key * 'Value -> 'a) -> ('a * ('Key,'Value) HashTable) -> 'a
    val iterate : ('Key * 'Value -> unit) -> ('Key,'Value) HashTable -> unit
    val stats : ('Key,'Value) HashTable -> {size:int, count:int, smallest:int, largest:int}
    val string_hash_table_stats : ('Key,'Value) HashTable -> string
a30 1

@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log:$
d12 1
a12 3
    type HashTable
    type Key
    type Value
d14 13
a26 13
    exception Lookup of Key
    val new     : unit -> HashTable
    val lookup  : (HashTable * Key) -> Value
    val lookup_default  : (HashTable * Value * Key) -> Value
    val tryLookup : (HashTable * Key) -> Value option
    val update  : (HashTable * Key * Value) -> unit
    val delete  : (HashTable * Key) -> unit
    val to_list : HashTable -> (Key * Value) list
    val copy    : HashTable -> HashTable
    val fold    : ('a * Key * Value -> 'a) -> ('a * HashTable) -> 'a
    val iterate : (Key * Value -> unit) -> HashTable -> unit
    val stats : HashTable -> {size:int, count:int, smallest:int, largest:int}
    val string_hash_table_stats : HashTable -> string
@
