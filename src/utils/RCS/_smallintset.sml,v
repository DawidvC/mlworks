head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.8
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.17.5.1.1.1.1
	MLWorks_workspace_97:1.17.7
	MLWorks_dt_wizard:1.17.6
	MLWorks_11c0_1997_09_09:1.17.5.1.1.1
	MLWorks_10r3:1.17.5.1.3
	MLWorks_10r2_551:1.17.5.1.2
	MLWorks_11:1.17.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.5.1
	MLWorks_20m0_1997_06_20:1.17
	MLWorks_1_0_r2c2_1997_06_14:1.17.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.5
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.3.1.1
	MLWorks_gui_1996_12_18:1.17.4
	MLWorks_1_0_Win32_1996_12_17:1.17.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.1.1
	MLWorks_1_0_Irix_1996_11_28:1.17.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.2
	MLWorks_1_0_Unix_1996_11_14:1.17.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.16
	MLWorks_Beta_1996_06_07:1.16
	MLWorks_Beta_1996_06_06:1.16
	MLWorks_Beta_1996_06_05:1.16
	MLWorks_Beta_1996_06_03:1.16
	MLWorks_Beta_1996_05_31:1.16
	MLWorks_Beta_1996_05_30:1.16
	ML_beta_release_12/08/94:1.12
	ML_beta_release_03/08/94:1.12
	ML_revised_beta_release_25/05/94:1.12
	ML_final_beta_release_02/03/94:1.12
	mlworks-28-01-1994:1.12
	Release:1.11
	mlworks-beta-01-09-1993:1.11
	MLWorks-1-0-4-29/01/1993:1.10
	MLWorks-1-0-3-21/12/1992:1.10
	MLWorks-1-0-2-15/12/1992:1.9
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.7;
locks; strict;
comment	@ * @;


1.17
date	96.11.06.10.53.02;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1
	1.17.7.1
	1.17.8.1;
next	1.16;

1.16
date	96.05.17.09.19.28;	author matthew;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.05.07.10.57.25;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.04.29.15.08.29;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	94.08.17.16.20.42;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.10.11.18.03.54;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	93.05.18.14.56.04;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	92.12.21.16.11.03;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	92.09.03.15.31.44;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.08.24.14.17.21;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.08.10.17.07.58;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	92.08.07.16.49.52;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.08.03.10.22.12;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.06.18.15.06.28;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.06.09.13.10.07;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.06.04.09.06.02;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.06.01.09.37.13;	author richard;	state Exp;
branches;
next	;

1.11.1.1
date	93.05.18.14.56.04;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.43.07;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.36.18;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.55.19;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.11.14.13.23.41;	author hope;	state Exp;
branches
	1.17.1.1.1.1;
next	;

1.17.1.1.1.1
date	96.11.28.15.34.18;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.11.22.18.40.46;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.12.17.18.19.43;	author hope;	state Exp;
branches
	1.17.3.1.1.1;
next	;

1.17.3.1.1.1
date	97.02.24.12.14.07;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.12.18.10.15.14;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	97.05.12.10.53.12;	author hope;	state Exp;
branches
	1.17.5.1.1.1
	1.17.5.1.2.1
	1.17.5.1.3.1;
next	;

1.17.5.1.1.1
date	97.07.28.18.35.49;	author daveb;	state Exp;
branches
	1.17.5.1.1.1.1.1;
next	;

1.17.5.1.1.1.1.1
date	97.10.07.12.01.16;	author jkbrook;	state Exp;
branches;
next	;

1.17.5.1.2.1
date	97.09.08.17.28.18;	author daveb;	state Exp;
branches;
next	;

1.17.5.1.3.1
date	97.09.09.14.25.50;	author daveb;	state Exp;
branches;
next	;

1.17.6.1
date	97.09.10.19.44.32;	author brucem;	state Exp;
branches;
next	;

1.17.7.1
date	97.09.11.21.11.50;	author daveb;	state Exp;
branches;
next	;

1.17.8.1
date	99.04.01.18.09.45;	author daveb;	state Exp;
branches;
next	;


desc
@Mutable sets of small integers.
Functor.
@


1.17
log
@[Bug #1728]
__integer becomes __int
@
text
@(*  ==== SMALL INTEGER SETS ====
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  The implementation uses arrays of integers which are used as bitfields.
 *  These sets should only be used for densely packed small non-negative
 *  integers.  This implementation was designed for use with packed virtual
 *  registers in the MIR optimiser.
 *
 *  Notes
 *  -----
 *  The structure below opens NewJersey.Array and NewJersey.Bits in order
 *  that SML/NJ can inline the bit and array operations and produce
 *  reasonable code.
 *
 *  Only 16 bits may be used in each integer as shift operations are used to
 *  do the division into array elements.
 *
 *  This functor should be converted to use ByteArrays as soon as they are
 *  implemented.
 *
 *  Revision Log
 *  ------------
 *  $Log: _smallintset.sml,v $
 * Revision 1.16  1996/05/17  09:19:28  matthew
 * Moving Bits to MLWorks.Internal
 *
 * Revision 1.15  1996/05/07  10:57:25  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.14  1996/04/29  15:08:29  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.13  1994/08/17  16:20:42  matthew
 * Efficiency improvements -- removed ExtendedArray.reduce functions and used unsafe operations
 *
 *  Revision 1.12  1993/10/11  18:03:54  jont
 *  Improved word function inside iterate to avoid rebuilding chunk
 *
 *  Revision 1.11  1993/05/18  14:56:04  jont
 *  Revision integer parameter
 *
 *  Revision 1.10  1992/12/21  16:11:03  daveb
 *  Chnaged references to Array to ExtendedArray, where appropriate.
 *
 *  Revision 1.9  1992/09/03  15:31:44  jont
 *  Changed to use MLWorks improved array operations
 *
 *  Revision 1.8  1992/08/24  14:17:21  richard
 *  Changed MLWorks.Bits to Bits so that New Jersey can inline it.
 *  Oh well.
 *
 *  Revision 1.7  1992/08/10  17:07:58  davidt
 *  Changed MLworks to MLWorks.
 *
 *  Revision 1.6  1992/08/07  16:49:52  davidt
 *  Took out a number of open statements and changed code to
 *  use MLworks structure instead of NewJersey.
 *
 *  Revision 1.5  1992/08/03  10:22:12  jont
 *  Improved implementation of add'
 *
 *  Revision 1.4  1992/06/18  15:06:28  richard
 *  Implemented some more efficient versions of reduce and iterate.
 *
 *  Revision 1.3  1992/06/09  13:10:07  richard
 *  Added checks for identity of sets.  For example, union (x,x)
 *  returns x.
 *
 *  Revision 1.2  1992/06/04  09:06:02  richard
 *  Added is_empty and copy'.
 *
 *  Revision 1.1  1992/06/01  09:37:13  richard
 *  Initial revision
 *
 *)


require "../basis/__int";

require "text";
require "crash";
require "lists";
require "mutableintset";


functor SmallIntSet (structure Text    : TEXT
                     structure Crash   : CRASH
                     structure Lists   : LISTS
                     val int_to_text   : int -> Text.T) : MUTABLEINTSET =
  struct

    structure Bits = MLWorks.Internal.Bits
    structure Text = Text

    fun crash message = Crash.impossible ("SmallIntSet: " ^ message)
    val % = Int.toString

    type T = int MLWorks.Internal.Array.array
    type element = int

    fun min (x : int, y : int) = if x<y then x else y
    fun max (x : int, y : int) = if x>y then x else y

    val update = MLWorks.Internal.Value.unsafe_array_update
    val sub = MLWorks.Internal.Value.unsafe_array_sub
      
    (* Test whether elements from base to base+size-1 of array are zero. *)

    fun zero (set, base, size) =
      let
        fun zero' 0 = true
          | zero' n = sub (set, base+n-1) = 0 andalso zero' (n-1)
      in
        zero' size
      end

    (* Copy elements base to base+size-1 from `from' to `to', returning *)
    (* `to'. *)

    fun copy (to, from, base, size) =
      let
        fun copy' 0 = to
          | copy' n = (update (to, base+n-1, sub (from, base+n-1)); copy' (n-1))
      in
        copy' size
      end

    (* Copy array `set' and resize it to `size' integers. *)

    fun resize (set, size) =
      let
        val current = MLWorks.Internal.Array.length set
        val new = MLWorks.Internal.Array.array (size, 0)
        fun loop i =
          if i = current
            then ()
          else 
            (update (new,i,sub(set,i));
             loop (i+1))
      in
        loop 0;
	new
      end

    val empty = MLWorks.Internal.Array.array (0, 0)

    fun singleton int =
      let
        val index = Bits.rshift (int, 4)
        val mask = Bits.lshift (1, Bits.andb (int, 15))
        val new = MLWorks.Internal.Array.array (index+1, 0)
      in
        update (new, index, mask);
        new
      end

    fun add (set, int) =
      let
        val index = Bits.rshift (int, 4)
        val mask = Bits.lshift (1, Bits.andb (int, 15))
        val new = resize (set, max (MLWorks.Internal.Array.length set, index+1))
      in
        update (new, index, Bits.orb (sub (new, index), mask));
        new
      end

    fun add' (set, int) =
      let
        val index = Bits.rshift (int, 4)
        val mask = Bits.lshift (1, Bits.andb (int, 15))
      in
	if index < MLWorks.Internal.Array.length set then
	  let
	    val old = sub(set, index)
	  in
	    update(set, index, Bits.orb(old, mask));
	    set
	  end
	else
	  let
	    val new = resize(set, index+1)
	  in
	    update(new, index, mask);
	    new
	  end
      end
	
    fun remove (set, int) =
      let
        val size = MLWorks.Internal.Array.length set
        val index = Bits.rshift (int, 4)
      in
        if index >= size then
          set
        else
          let
            val new = resize (set, size)
            val mask = Bits.notb (Bits.lshift (1, Bits.andb (int, 15)))
          in
            update (new, index, Bits.andb (sub (new, index), mask));
            new
          end
      end

    fun remove' (set, int) =
      let
        val size = MLWorks.Internal.Array.length set
        val index = Bits.rshift (int, 4)
      in
        if index >= size then
          set
        else
          let
            val mask = Bits.notb (Bits.lshift (1, Bits.andb (int, 15)))
          in
            update (set, index, Bits.andb (sub (set, index), mask));
            set
          end
      end

    fun member (set, int) =
      let
        val index = Bits.rshift (int, 4)
      in 
        if index >= MLWorks.Internal.Array.length set orelse index < 0
          then false
        else
          let
            val mask = Bits.lshift (1, Bits.andb (int, 15))
          in
            (case Bits.andb (sub (set, index), mask)
               of 0 => false
                | _ => true)
          end
      end

    fun is_empty set =
      set = empty orelse
      let
        val size = MLWorks.Internal.Array.length set
      in
        zero (set, 0, size)
      end

    fun equal (set, set') =
      set = set' orelse
      let
        val size' = MLWorks.Internal.Array.length set'
        val size  = MLWorks.Internal.Array.length set

        fun compare 0 = true
          | compare n = sub (set, n-1) = sub (set', n-1) andalso compare (n-1)
      in
        if size <= size' then
          compare size  andalso zero (set', size, size'-size)
        else
          compare size' andalso zero (set, size', size-size')
      end

    fun subset (set, set') =
      set = set' orelse
      let
        val size' = MLWorks.Internal.Array.length set'
        val size  = MLWorks.Internal.Array.length set

        fun subset' 0 = true
          | subset' n = Bits.andb (sub (set, n-1), Bits.notb (sub (set', n-1))) = 0 andalso subset' (n-1)
      in
        if size <= size' then
          subset' size
        else
          subset' size' andalso zero (set, size', size-size')
      end

    fun intersection (set, set') =
      if set = set' then set else
        let
          val size = min (MLWorks.Internal.Array.length set, MLWorks.Internal.Array.length set')

          val new = MLWorks.Internal.Array.array (size, 0)

          fun intersection' 0 = new
            | intersection' n =
              (update (new, n-1, Bits.andb (sub (set, n-1), sub (set', n-1)));
               intersection' (n-1))
        in
	  intersection' size
        end

    fun intersection' (set, set') =
      if set = set' then set else
        let
          val size = min (MLWorks.Internal.Array.length set, MLWorks.Internal.Array.length set')

          fun intersection' 0 = set
            | intersection' n =
              (update (set, n-1, Bits.andb (sub (set, n-1), sub (set', n-1)));
               intersection' (n-1))
        in
          intersection' size
        end

    fun union (set, set') =
      if set = set' then set else
        let
          val size' = MLWorks.Internal.Array.length set'
          val size = MLWorks.Internal.Array.length set

          val new = MLWorks.Internal.Array.array (max (size, size'), 0)

          fun union' 0 = new
            | union' n =
              (update (new, n-1, Bits.orb (sub (set, n-1), sub (set', n-1)));
               union' (n-1))
        in
          if size <= size' then
	    (MLWorks.Internal.ExtendedArray.iterate_index
	     (fn (index, a) =>
	      update (new, index, Bits.orb (a, sub (set', index))))
	     set;
	     copy (new, set', size, size'-size))
	  else
	    (MLWorks.Internal.ExtendedArray.iterate_index
	     (fn (index, a) =>
	      update (new, index, Bits.orb (a, sub (set, index))))
	     set';
	     copy (new, set, size', size-size'))
        end

    fun union' (set, set') =
      if set = set' then set else
        let
          val size = MLWorks.Internal.Array.length set
          val size' = MLWorks.Internal.Array.length set'
        in
          if size < size' then
            let
              val new = MLWorks.Internal.Array.array (size', 0)
              fun loop i =
                if i = size then ()
                else
                  (update (new,i,Bits.orb (sub(set,i),sub(set',i)));
                   loop (i+1))
            in
              loop 0;
              copy (new, set', size, size'-size)
            end
          else
            let
              fun loop i =
                if i = size' then ()
                else
                  (update (set,i,Bits.orb(sub (set',i),sub(set,i)));
                   loop (i+1))
            in
              (loop 0;
               set)
            end
        end

    fun difference (set, set') =
      if set = set' then empty else
        let
          val size = MLWorks.Internal.Array.length set
          val size' = min (size, MLWorks.Internal.Array.length set')

          val new = MLWorks.Internal.Array.array (size, 0)

          fun difference' 0 = ()
            | difference' n =
              (update (new, n-1, Bits.andb (sub (set, n-1), Bits.notb (sub (set', n-1))));
               difference' (n-1))
        in
          difference' size';
          copy (new, set, size', size - size')
        end

    fun difference' (set, set') =
      if set = set' then empty else
        let
          val size = min (MLWorks.Internal.Array.length set, MLWorks.Internal.Array.length set')

          fun difference' 0 = set
            | difference' n =
              (update (set, n-1, Bits.andb (sub (set, n-1), Bits.notb (sub (set', n-1))));
               difference' (n-1))
        in
          difference' size
        end

    fun cardinality set =
      let
        fun count (c, 0) = c
          | count (c, w) = count (c+1, Bits.andb (w, w-1))

      in
	MLWorks.Internal.ExtendedArray.reducel count (0, set)
      end

    (* reduce and iterate are time critical *)

    fun reduce f (identity, set) =
      let
        val size = MLWorks.Internal.Array.length set

        fun word (result, p, i) =
          if i = size then
            result
          else
            let
              fun chunk (result, p, 0) = result
                | chunk (result, p, w) =
                  let
                    val result' =
                      case Bits.andb (w, 15)
                        of  0 => result
                         |  1 => f (result, p)
                         |  2 => f (result, p+1)
                         |  3 => f (f (result, p), p+1)
                         |  4 => f (result, p+2)
                         |  5 => f (f (result, p), p+2)
                         |  6 => f (f (result, p+1), p+2)
                         |  7 => f (f (f (result, p), p+1), p+2)
                         |  8 => f (result, p+3)
                         |  9 => f (f (result, p), p+3)
                         | 10 => f (f (result, p+1), p+3)
                         | 11 => f (f (f (result, p), p+1), p+3)
                         | 12 => f (f (result, p+2), p+3)
                         | 13 => f (f (f (result, p), p+2), p+3)
                         | 14 => f (f (f (result, p+1), p+2), p+3)
                         | _  => f (f (f (f (result, p), p+1), p+2), p+3)
                  in
                    chunk (result', p+4, Bits.rshift (w, 4))
                  end
            in
              word (chunk (result, p, sub (set, i)), p+16, i+1)
            end
      in
        word (identity, 0, 0)
      end

    fun iterate f set =
      let
        val size = MLWorks.Internal.Array.length set

        fun word (p, i) =
          if i = size then
            ()
          else
	    (chunk (p, sub (set, i));
	     word (p+16, i+1))

	and chunk (p, 0) = ()
	  | chunk (p, w) =
	    (case Bits.andb (w, 15)
	       of  0 => ()
	     |  1 => f p
	     |  2 => f (p+1)
	     |  3 => (f p; f (p+1))
	     |  4 => f (p+2)
	     |  5 => (f p; f (p+2))
	     |  6 => (f (p+1); f (p+2))
	     |  7 => (f p; f (p+1); f (p+2))
	     |  8 => f (p+3)
	     |  9 => (f p; f (p+3))
	     | 10 => (f (p+1); f (p+3))
	     | 11 => (f p; f (p+1); f (p+3))
	     | 12 => (f (p+2); f (p+3))
	     | 13 => (f p; f (p+2); f (p+3))
	     | 14 => (f (p+1); f (p+2); f (p+3))
	     | _  => (f p; f (p+1); f (p+2); f (p+3));
		 chunk (p+4, Bits.rshift (w, 4)))

      in
        word (0, 0)
      end

    fun filter predicate set =
      let
        val size = MLWorks.Internal.Array.length set
        val new = MLWorks.Internal.Array.array (size, 0)

        fun word 0 = new
          | word i =
            let
              val element = sub (set, i-1)
            in
              case element
                of 0 => word (i-1)
                 | _ => 
                   let
                     val base = Bits.lshift (i-1, 4)

                     fun bit (w, 0) = w
                       | bit (w, b) =
                         let
                           val w' =
                             case Bits.andb (Bits.rshift (element, b-1), 1)
                               of 0 => Bits.lshift (w, 1)
                                | _ => Bits.orb (Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
                         in
                           bit (w', b-1)
                         end
                   in
                     update (new, i-1, bit (0, 16));
                     word (i-1)
                   end
            end
      in
        word size
      end

    fun filter' predicate set =
      let
        val size = MLWorks.Internal.Array.length set

        fun word 0 = set
          | word i =
            let
              val element = sub (set, i-1)
              val base = Bits.lshift (i-1, 4)

              fun bit (w, 0) = w
                | bit (w, b) =
                  let
                    val w' =
                      case Bits.andb (Bits.rshift (element, b-1), 1)
                        of 0 => Bits.lshift (w, 1)
                         | _ => Bits.orb (Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
                  in
                    bit (w', b-1)
                  end
            in
              update (set, i-1, bit (0, 16));
              word (i-1)
            end
      in
        word size
      end

    fun to_list set = reduce (fn (list, int) => int::list) ([], set)

    fun from_list list =
      let
        val largest = Lists.reducel max (0, list)
        val new = MLWorks.Internal.Array.array (Bits.rshift (largest, 4) + 1, 0)
      in
        Lists.iterate
        (fn int =>
         let
           val index = Bits.rshift (int, 4)
           val mask = Bits.lshift (1, Bits.andb (int, 15))
         in
           update (new, index, Bits.orb (sub (new, index), mask))
         end)
        list;
        new
      end

    fun to_text set =
      let
        infix ^^
        val (op^^) = Text.concatenate
        val $ = Text.from_string

        val (_, text) =
          reduce (fn ((0, text), int) => (1, int_to_text int)
                   | ((_, text), int) => (1, text ^^ $"," ^^ int_to_text int)) ((0, $""), set)
      in
        $"{" ^^ text ^^ $"}"
      end

    val copy' = MLWorks.Internal.ExtendedArray.duplicate

  end
@


1.17.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a26 3
 * Revision 1.17.5.1  1997/05/12  10:53:12  hope
 * branched from 1.17
 *
@


1.17.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a26 3
 * Revision 1.17.5.1  1997/05/12  10:53:12  hope
 * branched from 1.17
 *
@


1.17.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a26 3
 * Revision 1.17.5.1  1997/05/12  10:53:12  hope
 * branched from 1.17
 *
@


1.17.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a26 3
 * Revision 1.17.5.1.1.1  1997/07/28  18:35:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.3.1.1.1
log
@branched from 1.17.3.1
@
text
@a26 3
 * Revision 1.17.3.1  1996/12/17  18:19:43  hope
 * branched from 1.17
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a26 4
 * Revision 1.17  1996/11/06  10:53:02  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.17.1.1.1.1
log
@branched from 1.17.1.1
@
text
@a26 3
 * Revision 1.17.1.1  1996/11/14  13:23:41  hope
 * branched from 1.17
 *
@


1.16
log
@Moving Bits to MLWorks.Internal
@
text
@d27 3
d81 1
a81 1
require "../basis/__integer";
@


1.16.3.1
log
@branched from 1.16
@
text
@a26 3
 * Revision 1.16  1996/05/17  09:19:28  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a26 3
 * Revision 1.16  1996/05/17  09:19:28  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a26 3
 * Revision 1.16  1996/05/17  09:19:28  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.15
log
@Array moving to MLWorks.Array
@
text
@d27 3
d92 1
@


1.14
log
@Removing MLWorks.Integer
@
text
@d27 3
d94 1
a94 1
    type T = int Array.array
d128 2
a129 2
        val current = Array.length set
        val new = Array.array (size, 0)
a136 5
(*	MLWorks.ExtendedArray.iterate_index
	(fn (index, a) =>
	 update (new, index, a))
	set;
*)
d141 1
a141 1
    val empty = Array.array (0, 0)
d147 1
a147 1
        val new = Array.array (index+1, 0)
d157 1
a157 1
        val new = resize (set, max (Array.length set, index+1))
d168 1
a168 1
	if index < Array.length set then
d186 1
a186 1
        val size = Array.length set
d203 1
a203 1
        val size = Array.length set
d221 1
a221 1
        if index >= Array.length set orelse index < 0
d236 1
a236 1
        val size = Array.length set
d244 2
a245 2
        val size' = Array.length set'
        val size  = Array.length set
d259 2
a260 2
        val size' = Array.length set'
        val size  = Array.length set
d274 1
a274 1
          val size = min (Array.length set, Array.length set')
d276 1
a276 1
          val new = Array.array (size, 0)
d289 1
a289 1
          val size = min (Array.length set, Array.length set')
d302 2
a303 2
          val size' = Array.length set'
          val size = Array.length set
d305 1
a305 1
          val new = Array.array (max (size, size'), 0)
d313 1
a313 1
	    (MLWorks.ExtendedArray.iterate_index
d319 1
a319 1
	    (MLWorks.ExtendedArray.iterate_index
d329 2
a330 2
          val size = Array.length set
          val size' = Array.length set'
d334 1
a334 1
              val new = Array.array (size', 0)
a340 6
(*
	      MLWorks.ExtendedArray.iterate_index
	      (fn (index, a) =>
	       update(new, index, Bits.orb(a, sub(set', index))))
	      set;
*)
d352 1
a352 6
              ((*
                MLWorks.ExtendedArray.iterate_index
               (fn (index, a) =>
                update(set, index, Bits.orb(a, sub(set, index))))
               set'; *)
               loop 0;
d360 2
a361 2
          val size = Array.length set
          val size' = min (size, Array.length set')
d363 1
a363 1
          val new = Array.array (size, 0)
d377 1
a377 1
          val size = min (Array.length set, Array.length set')
d393 1
a393 1
	MLWorks.ExtendedArray.reducel count (0, set)
d400 1
a400 1
        val size = Array.length set
d440 1
a440 1
        val size = Array.length set
d476 2
a477 2
        val size = Array.length set
        val new = Array.array (size, 0)
d511 1
a511 1
        val size = Array.length set
d542 1
a542 1
        val new = Array.array (Bits.rshift (largest, 4) + 1, 0)
d569 1
a569 8
    val copy' = MLWorks.ExtendedArray.duplicate
(*
      let
        val size = Array.length set
      in
        copy (Array.array (Array.length set, 0), set, 0, size)
      end
*)
@


1.13
log
@Efficiency improvements -- removed ExtendedArray.reduce functions and used unsafe operations
@
text
@d27 3
d72 2
d89 1
a89 1
    val % = MLWorks.Integer.makestring
@


1.12
log
@Improved word function inside iterate to avoid rebuilding chunk
@
text
@d27 3
d92 3
d100 1
a100 1
          | zero' n = Array.sub (set, base+n-1) = 0 andalso zero' (n-1)
d111 1
a111 1
          | copy' n = (Array.update (to, base+n-1, Array.sub (from, base+n-1)); copy' (n-1))
d122 6
d129 1
a129 1
	MLWorks.ExtendedArray.iterate_index
d131 1
a131 1
	 Array.update (new, index, a))
d133 2
d146 1
a146 1
        Array.update (new, index, mask);
d156 1
a156 1
        Array.update (new, index, Bits.orb (Array.sub (new, index), mask));
d167 1
a167 1
	    val old = Array.sub(set, index)
d169 1
a169 1
	    Array.update(set, index, Bits.orb(old, mask));
d176 1
a176 1
	    Array.update(new, index, mask);
d193 1
a193 1
            Array.update (new, index, Bits.andb (Array.sub (new, index), mask));
d209 1
a209 1
            Array.update (set, index, Bits.andb (Array.sub (set, index), mask));
d217 11
a227 6
        val mask = Bits.lshift (1, Bits.andb (int, 15))
      in
        (case Bits.andb (Array.sub (set, index), mask)
           of 0 => false
            | _ => true)
          handle Array.Subscript => false
d245 1
a245 1
          | compare n = Array.sub (set, n-1) = Array.sub (set', n-1) andalso compare (n-1)
d260 1
a260 1
          | subset' n = Bits.andb (Array.sub (set, n-1), Bits.notb (Array.sub (set', n-1))) = 0 andalso subset' (n-1)
d277 1
a277 1
              (Array.update (new, n-1, Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d290 1
a290 1
              (Array.update (set, n-1, Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d306 1
a306 1
              (Array.update (new, n-1, Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
d312 1
a312 1
	      Array.update (new, index, Bits.orb (a, Array.sub (set', index))))
d318 1
a318 1
	      Array.update (new, index, Bits.orb (a, Array.sub (set, index))))
a327 1

d332 5
d338 1
d341 1
a341 1
	       Array.update(new, index, Bits.orb(a, Array.sub(set', index))))
d343 2
d348 15
a362 5
	    (MLWorks.ExtendedArray.iterate_index
	     (fn (index, a) =>
	      Array.update(set, index, Bits.orb(a, Array.sub(set, index))))
	     set';
	     set)
d375 1
a375 1
              (Array.update (new, n-1, Bits.andb (Array.sub (set, n-1), Bits.notb (Array.sub (set', n-1))));
d389 1
a389 1
              (Array.update (set, n-1, Bits.andb (Array.sub (set, n-1), Bits.notb (Array.sub (set', n-1))));
d440 1
a440 1
              word (chunk (result, p, Array.sub (set, i)), p+16, i+1)
d454 1
a454 1
	    (chunk (p, Array.sub (set, i));
d490 1
a490 1
              val element = Array.sub (set, i-1)
d509 1
a509 1
                     Array.update (new, i-1, bit (0, 16));
d524 1
a524 1
              val element = Array.sub (set, i-1)
d538 1
a538 1
              Array.update (set, i-1, bit (0, 16));
d558 1
a558 1
           Array.update (new, index, Bits.orb (Array.sub (new, index), mask))
@


1.11
log
@Revision integer parameter
@
text
@d27 3
a150 25
(*
        (Array.update (set, index, Bits.orb (Array.sub (set, index), mask));
         set)
          handle Array.Subscript =>
            let
              val new = resize (set, max (Array.length set, index+1))
            in
              Array.update (new, index, Bits.orb (Array.sub (new, index), mask));
              new
            end
*)
(*
	let
	  val old = Array.sub(set, index)
	in
	  Array.update(set, index, Bits.orb(old, mask));
	  set
	end handle Array.Subscript =>
	  let
	    val new = resize(set, index+1)
	  in
	    Array.update(new, index, mask);
	    new
	  end
*)
a295 3
(*
	    (union' size; copy (new, set', size, size'-size))
*)
a301 3
(*
	    (union' size'; copy (new, set, size', size-size'))
*)
d418 24
a441 25
            let
              fun chunk (p, 0) = ()
                | chunk (p, w) =
                  (case Bits.andb (w, 15)
                     of  0 => ()
                      |  1 => f p
                      |  2 => f (p+1)
                      |  3 => (f p; f (p+1))
                      |  4 => f (p+2)
                      |  5 => (f p; f (p+2))
                      |  6 => (f (p+1); f (p+2))
                      |  7 => (f p; f (p+1); f (p+2))
                      |  8 => f (p+3)
                      |  9 => (f p; f (p+3))
                      | 10 => (f (p+1); f (p+3))
                      | 11 => (f p; f (p+1); f (p+3))
                      | 12 => (f (p+2); f (p+3))
                      | 13 => (f p; f (p+2); f (p+3))
                      | 14 => (f (p+1); f (p+2); f (p+3))
                      | _  => (f p; f (p+1); f (p+2); f (p+3));
                   chunk (p+4, Bits.rshift (w, 4)))
            in
              chunk (p, Array.sub (set, i));
              word (p+16, i+1)
            end
@


1.11.1.1
log
@Fork for bug fixing
@
text
@a26 3
 *  Revision 1.11  1993/05/18  14:56:04  jont
 *  Revision integer parameter
 *
@


1.10
log
@Chnaged references to Array to ExtendedArray, where appropriate.
@
text
@d27 3
a65 1
require "integer";
a71 1
                     structure Integer : INTEGER
d78 1
a78 1
    val % = Integer.makestring
@


1.9
log
@Changed to use MLWorks improved array operations
@
text
@d27 3
d113 1
a113 1
	MLWorks.Array.iterate_index
d312 1
a312 1
	    (MLWorks.Array.iterate_index
d321 1
a321 1
	    (MLWorks.Array.iterate_index
d342 1
a342 1
	      MLWorks.Array.iterate_index
d349 1
a349 1
	    (MLWorks.Array.iterate_index
d392 1
a392 1
	MLWorks.Array.reducel count (0, set)
d569 1
a569 1
    val copy' = MLWorks.Array.duplicate
@


1.8
log
@Changed MLWorks.Bits to Bits so that New Jersey can inline it.
Oh well.
@
text
@d27 4
a108 3

        fun copy 0 = new
          | copy n = (Array.update (new, n-1, Array.sub (set, n-1)); copy (n-1))
d110 5
a114 1
        copy (min (size, current))
d279 1
a279 1
          intersection' size
d309 17
a325 3
            (union' size; copy (new, set', size, size'-size))
          else
            (union' size'; copy (new, set, size', size-size'))
a333 6
          val new = if size' > size then Array.array (size', 0) else set

          fun union' new 0 = new
            | union' new n =
              (Array.update (new, n-1, Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
               union' new (n-1))
d339 4
a342 1
              union' new size;
d346 5
a350 1
            union' set size'
d361 1
a361 1
          fun difference' 0 = new
a387 3
        fun cardinality' (c, 0) = c
          | cardinality' (c, n) =
            cardinality' (count (c, Array.sub (set, n-1)), n-1)
d389 1
a389 1
        cardinality' (0, Array.length set)
d566 2
a567 1
    fun copy' set =
d573 1
@


1.7
log
@Changed MLworks to MLWorks.
@
text
@d27 3
d116 2
a117 2
        val index = MLWorks.Bits.rshift (int, 4)
        val mask = MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15))
d126 2
a127 2
        val index = MLWorks.Bits.rshift (int, 4)
        val mask = MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15))
d130 1
a130 1
        Array.update (new, index, MLWorks.Bits.orb (Array.sub (new, index), mask));
d136 2
a137 2
        val index = MLWorks.Bits.rshift (int, 4)
        val mask = MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15))
d140 1
a140 1
        (Array.update (set, index, MLWorks.Bits.orb (Array.sub (set, index), mask));
d146 1
a146 1
              Array.update (new, index, MLWorks.Bits.orb (Array.sub (new, index), mask));
d154 1
a154 1
	  Array.update(set, index, MLWorks.Bits.orb(old, mask));
d168 1
a168 1
	    Array.update(set, index, MLWorks.Bits.orb(old, mask));
d183 1
a183 1
        val index = MLWorks.Bits.rshift (int, 4)
d190 1
a190 1
            val mask = MLWorks.Bits.notb (MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15)))
d192 1
a192 1
            Array.update (new, index, MLWorks.Bits.andb (Array.sub (new, index), mask));
d200 1
a200 1
        val index = MLWorks.Bits.rshift (int, 4)
d206 1
a206 1
            val mask = MLWorks.Bits.notb (MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15)))
d208 1
a208 1
            Array.update (set, index, MLWorks.Bits.andb (Array.sub (set, index), mask));
d215 2
a216 2
        val index = MLWorks.Bits.rshift (int, 4)
        val mask = MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15))
d218 1
a218 1
        (case MLWorks.Bits.andb (Array.sub (set, index), mask)
d254 1
a254 1
          | subset' n = MLWorks.Bits.andb (Array.sub (set, n-1), MLWorks.Bits.notb (Array.sub (set', n-1))) = 0 andalso subset' (n-1)
d271 1
a271 1
              (Array.update (new, n-1, MLWorks.Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d284 1
a284 1
              (Array.update (set, n-1, MLWorks.Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d300 1
a300 1
              (Array.update (new, n-1, MLWorks.Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
d319 1
a319 1
              (Array.update (new, n-1, MLWorks.Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
d343 1
a343 1
              (Array.update (new, n-1, MLWorks.Bits.andb (Array.sub (set, n-1), MLWorks.Bits.notb (Array.sub (set', n-1))));
d357 1
a357 1
              (Array.update (set, n-1, MLWorks.Bits.andb (Array.sub (set, n-1), MLWorks.Bits.notb (Array.sub (set', n-1))));
d366 1
a366 1
          | count (c, w) = count (c+1, MLWorks.Bits.andb (w, w-1))
d390 1
a390 1
                      case MLWorks.Bits.andb (w, 15)
d408 1
a408 1
                    chunk (result', p+4, MLWorks.Bits.rshift (w, 4))
d428 1
a428 1
                  (case MLWorks.Bits.andb (w, 15)
d445 1
a445 1
                   chunk (p+4, MLWorks.Bits.rshift (w, 4)))
d468 1
a468 1
                     val base = MLWorks.Bits.lshift (i-1, 4)
d474 3
a476 3
                             case MLWorks.Bits.andb (MLWorks.Bits.rshift (element, b-1), 1)
                               of 0 => MLWorks.Bits.lshift (w, 1)
                                | _ => MLWorks.Bits.orb (MLWorks.Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d497 1
a497 1
              val base = MLWorks.Bits.lshift (i-1, 4)
d503 3
a505 3
                      case MLWorks.Bits.andb (MLWorks.Bits.rshift (element, b-1), 1)
                        of 0 => MLWorks.Bits.lshift (w, 1)
                         | _ => MLWorks.Bits.orb (MLWorks.Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d522 1
a522 1
        val new = Array.array (MLWorks.Bits.rshift (largest, 4) + 1, 0)
d527 2
a528 2
           val index = MLWorks.Bits.rshift (int, 4)
           val mask = MLWorks.Bits.lshift (1, MLWorks.Bits.andb (int, 15))
d530 1
a530 1
           Array.update (new, index, MLWorks.Bits.orb (Array.sub (new, index), mask))
@


1.6
log
@Took out a number of open statements and changed code to
use MLworks structure instead of NewJersey.
@
text
@d27 4
d113 2
a114 2
        val index = MLworks.Bits.rshift (int, 4)
        val mask = MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15))
d123 2
a124 2
        val index = MLworks.Bits.rshift (int, 4)
        val mask = MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15))
d127 1
a127 1
        Array.update (new, index, MLworks.Bits.orb (Array.sub (new, index), mask));
d133 2
a134 2
        val index = MLworks.Bits.rshift (int, 4)
        val mask = MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15))
d137 1
a137 1
        (Array.update (set, index, MLworks.Bits.orb (Array.sub (set, index), mask));
d143 1
a143 1
              Array.update (new, index, MLworks.Bits.orb (Array.sub (new, index), mask));
d151 1
a151 1
	  Array.update(set, index, MLworks.Bits.orb(old, mask));
d165 1
a165 1
	    Array.update(set, index, MLworks.Bits.orb(old, mask));
d180 1
a180 1
        val index = MLworks.Bits.rshift (int, 4)
d187 1
a187 1
            val mask = MLworks.Bits.notb (MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15)))
d189 1
a189 1
            Array.update (new, index, MLworks.Bits.andb (Array.sub (new, index), mask));
d197 1
a197 1
        val index = MLworks.Bits.rshift (int, 4)
d203 1
a203 1
            val mask = MLworks.Bits.notb (MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15)))
d205 1
a205 1
            Array.update (set, index, MLworks.Bits.andb (Array.sub (set, index), mask));
d212 2
a213 2
        val index = MLworks.Bits.rshift (int, 4)
        val mask = MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15))
d215 1
a215 1
        (case MLworks.Bits.andb (Array.sub (set, index), mask)
d251 1
a251 1
          | subset' n = MLworks.Bits.andb (Array.sub (set, n-1), MLworks.Bits.notb (Array.sub (set', n-1))) = 0 andalso subset' (n-1)
d268 1
a268 1
              (Array.update (new, n-1, MLworks.Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d281 1
a281 1
              (Array.update (set, n-1, MLworks.Bits.andb (Array.sub (set, n-1), Array.sub (set', n-1)));
d297 1
a297 1
              (Array.update (new, n-1, MLworks.Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
d316 1
a316 1
              (Array.update (new, n-1, MLworks.Bits.orb (Array.sub (set, n-1), Array.sub (set', n-1)));
d340 1
a340 1
              (Array.update (new, n-1, MLworks.Bits.andb (Array.sub (set, n-1), MLworks.Bits.notb (Array.sub (set', n-1))));
d354 1
a354 1
              (Array.update (set, n-1, MLworks.Bits.andb (Array.sub (set, n-1), MLworks.Bits.notb (Array.sub (set', n-1))));
d363 1
a363 1
          | count (c, w) = count (c+1, MLworks.Bits.andb (w, w-1))
d387 1
a387 1
                      case MLworks.Bits.andb (w, 15)
d405 1
a405 1
                    chunk (result', p+4, MLworks.Bits.rshift (w, 4))
d425 1
a425 1
                  (case MLworks.Bits.andb (w, 15)
d442 1
a442 1
                   chunk (p+4, MLworks.Bits.rshift (w, 4)))
d465 1
a465 1
                     val base = MLworks.Bits.lshift (i-1, 4)
d471 3
a473 3
                             case MLworks.Bits.andb (MLworks.Bits.rshift (element, b-1), 1)
                               of 0 => MLworks.Bits.lshift (w, 1)
                                | _ => MLworks.Bits.orb (MLworks.Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d494 1
a494 1
              val base = MLworks.Bits.lshift (i-1, 4)
d500 3
a502 3
                      case MLworks.Bits.andb (MLworks.Bits.rshift (element, b-1), 1)
                        of 0 => MLworks.Bits.lshift (w, 1)
                         | _ => MLworks.Bits.orb (MLworks.Bits.lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d519 1
a519 1
        val new = Array.array (MLworks.Bits.rshift (largest, 4) + 1, 0)
d524 2
a525 2
           val index = MLworks.Bits.rshift (int, 4)
           val mask = MLworks.Bits.lshift (1, MLworks.Bits.andb (int, 15))
d527 1
a527 1
           Array.update (new, index, MLworks.Bits.orb (Array.sub (new, index), mask))
@


1.5
log
@Improved implementation of add'
@
text
@d27 3
d65 1
a65 5
    open NewJersey.Bits
    open NewJersey.Array
    nonfix sub

    type T = int array
d76 1
a76 1
          | zero' n = sub (set, base+n-1) = 0 andalso zero' (n-1)
d87 1
a87 1
          | copy' n = (update (to, base+n-1, sub (from, base+n-1)); copy' (n-1))
d96 2
a97 2
        val current = length set
        val new = array (size, 0)
d100 1
a100 1
          | copy n = (update (new, n-1, sub (set, n-1)); copy (n-1))
d105 1
a105 1
    val empty = array (0, 0)
d109 3
a111 3
        val index = rshift (int, 4)
        val mask = lshift (1, andb (int, 15))
        val new = array (index+1, 0)
d113 1
a113 1
        update (new, index, mask);
d119 3
a121 3
        val index = rshift (int, 4)
        val mask = lshift (1, andb (int, 15))
        val new = resize (set, max (length set, index+1))
d123 1
a123 1
        update (new, index, orb (sub (new, index), mask));
d129 2
a130 2
        val index = rshift (int, 4)
        val mask = lshift (1, andb (int, 15))
d133 1
a133 1
        (update (set, index, orb (sub (set, index), mask));
d135 1
a135 1
          handle Subscript =>
d137 1
a137 1
              val new = resize (set, max (length set, index+1))
d139 1
a139 1
              update (new, index, orb (sub (new, index), mask));
d145 1
a145 1
	  val old = sub(set, index)
d147 1
a147 1
	  update(set, index, orb(old, mask));
d149 1
a149 1
	end handle Subscript =>
d153 1
a153 1
	    update(new, index, mask);
d157 1
a157 1
	if index < length set then
d159 1
a159 1
	    val old = sub(set, index)
d161 1
a161 1
	    update(set, index, orb(old, mask));
d168 1
a168 1
	    update(new, index, mask);
d175 2
a176 2
        val size = length set
        val index = rshift (int, 4)
d183 1
a183 1
            val mask = notb (lshift (1, andb (int, 15)))
d185 1
a185 1
            update (new, index, andb (sub (new, index), mask));
d192 2
a193 2
        val size = length set
        val index = rshift (int, 4)
d199 1
a199 1
            val mask = notb (lshift (1, andb (int, 15)))
d201 1
a201 1
            update (set, index, andb (sub (set, index), mask));
d208 2
a209 2
        val index = rshift (int, 4)
        val mask = lshift (1, andb (int, 15))
d211 1
a211 1
        (case andb (sub (set, index), mask)
d214 1
a214 1
          handle Subscript => false
d220 1
a220 1
        val size = length set
d228 2
a229 2
        val size' = length set'
        val size  = length set
d232 1
a232 1
          | compare n = sub (set, n-1) = sub (set', n-1) andalso compare (n-1)
d243 2
a244 2
        val size' = length set'
        val size  = length set
d247 1
a247 1
          | subset' n = andb (sub (set, n-1), notb (sub (set', n-1))) = 0 andalso subset' (n-1)
d258 1
a258 1
          val size = min (length set, length set')
d260 1
a260 1
          val new = array (size, 0)
d264 1
a264 1
              (update (new, n-1, andb (sub (set, n-1), sub (set', n-1)));
d273 1
a273 1
          val size = min (length set, length set')
d277 1
a277 1
              (update (set, n-1, andb (sub (set, n-1), sub (set', n-1)));
d286 2
a287 2
          val size' = length set'
          val size = length set
d289 1
a289 1
          val new = array (max (size, size'), 0)
d293 1
a293 1
              (update (new, n-1, orb (sub (set, n-1), sub (set', n-1)));
d305 2
a306 2
          val size = length set
          val size' = length set'
d308 1
a308 1
          val new = if size' > size then array (size', 0) else set
d312 1
a312 1
              (update (new, n-1, orb (sub (set, n-1), sub (set', n-1)));
d317 1
a317 1
              val new = array (size', 0)
d329 2
a330 2
          val size = length set
          val size' = min (size, length set')
d332 1
a332 1
          val new = array (size, 0)
d336 1
a336 1
              (update (new, n-1, andb (sub (set, n-1), notb (sub (set', n-1))));
d346 1
a346 1
          val size = min (length set, length set')
d350 1
a350 1
              (update (set, n-1, andb (sub (set, n-1), notb (sub (set', n-1))));
d359 1
a359 1
          | count (c, w) = count (c+1, andb (w, w-1))
d363 1
a363 1
            cardinality' (count (c, sub (set, n-1)), n-1)
d365 1
a365 1
        cardinality' (0, length set)
d372 1
a372 1
        val size = length set
d383 1
a383 1
                      case andb (w, 15)
d401 1
a401 1
                    chunk (result', p+4, rshift (w, 4))
d404 1
a404 1
              word (chunk (result, p, sub (set, i)), p+16, i+1)
d412 1
a412 1
        val size = length set
d421 1
a421 1
                  (case andb (w, 15)
d438 1
a438 1
                   chunk (p+4, rshift (w, 4)))
d440 1
a440 1
              chunk (p, sub (set, i));
d449 2
a450 2
        val size = length set
        val new = array (size, 0)
d455 1
a455 1
              val element = sub (set, i-1)
d461 1
a461 1
                     val base = lshift (i-1, 4)
d467 3
a469 3
                             case andb (rshift (element, b-1), 1)
                               of 0 => lshift (w, 1)
                                | _ => orb (lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d474 1
a474 1
                     update (new, i-1, bit (0, 16));
d484 1
a484 1
        val size = length set
d489 2
a490 2
              val element = sub (set, i-1)
              val base = lshift (i-1, 4)
d496 3
a498 3
                      case andb (rshift (element, b-1), 1)
                        of 0 => lshift (w, 1)
                         | _ => orb (lshift (w, 1), if predicate (base + b-1) then 1 else 0)
d503 1
a503 1
              update (set, i-1, bit (0, 16));
d515 1
a515 1
        val new = array (rshift (largest, 4) + 1, 0)
d520 2
a521 2
           val index = rshift (int, 4)
           val mask = lshift (1, andb (int, 15))
d523 1
a523 1
           update (new, index, orb (sub (new, index), mask))
d544 1
a544 1
        val size = length set
d546 1
a546 1
        copy (array (length set, 0), set, 0, size)
@


1.4
log
@Implemented some more efficient versions of reduce and iterate.
@
text
@d27 3
d133 1
d143 29
d173 1
a173 1

@


1.3
log
@Added checks for identity of sets.  For example, union (x,x)
returns x.
@
text
@d27 4
d336 3
a338 1
    fun reduce function (identity, set) =
d340 6
a345 2
        fun word (result, 0) = result
          | word (result, i) =
d347 2
a348 5
              val element = sub (set, i-1)
              val base = lshift (i-1, 4)

              fun bit (result, 0) = result
                | bit (result, b) =
d351 17
a367 3
                      case andb (rshift (element, b-1), 1)
                        of 0 => result
                         | _ => function (result, base + b-1)
d369 1
a369 1
                    bit (result', b-1)
d372 1
a372 1
              word (bit (result, 16), i-1)
d375 1
a375 1
        word (identity, length set)
d378 1
a378 1
    fun iterate function set =
d380 6
a385 2
        fun word 0 = ()
          | word i =
d387 20
a406 9
              val element = sub (set, i-1)
              val base = lshift (i-1, 4)

              fun bit 0 = ()
                | bit b =
                  (case andb (rshift (element, b-1), 1)
                     of 0 => ()
                      | _ => function (base + b-1);
                   bit (b-1))
d408 2
a409 2
              bit 16;
              word (i-1)
d412 1
a412 1
        word (length set)
a423 12
              val base = lshift (i-1, 4)

              fun bit (w, 0) = w
                | bit (w, b) =
                  let
                    val w' =
                      case andb (rshift (element, b-1), 1)
                        of 0 => lshift (w, 1)
                         | _ => orb (lshift (w, 1), if predicate (base + b-1) then 1 else 0)
                  in
                    bit (w', b-1)
                  end
d425 20
a444 2
              update (new, i-1, bit (0, 16));
              word (i-1)
@


1.2
log
@Added is_empty and copy'.
@
text
@d27 3
d182 1
d190 1
d205 1
d220 13
a232 12
      let
        val size = min (length set, length set')

        val new = array (size, 0)

        fun intersection' 0 = new
          | intersection' n =
            (update (new, n-1, andb (sub (set, n-1), sub (set', n-1)));
             intersection' (n-1))
      in
        intersection' size
      end
d235 11
a245 10
      let
        val size = min (length set, length set')

        fun intersection' 0 = set
          | intersection' n =
            (update (set, n-1, andb (sub (set, n-1), sub (set', n-1)));
             intersection' (n-1))
      in
        intersection' size
      end
d248 17
a264 16
      let
        val size' = length set'
        val size = length set

        val new = array (max (size, size'), 0)

        fun union' 0 = new
          | union' n =
            (update (new, n-1, orb (sub (set, n-1), sub (set', n-1)));
             union' (n-1))
      in
        if size <= size' then
          (union' size; copy (new, set', size, size'-size))
        else
          (union' size'; copy (new, set, size', size-size'))
      end
d267 22
a288 21
      let
        val size = length set
        val size' = length set'

        val new = if size' > size then array (size', 0) else set

        fun union' new 0 = new
          | union' new n =
            (update (new, n-1, orb (sub (set, n-1), sub (set', n-1)));
             union' new (n-1))
      in
        if size < size' then
          let
            val new = array (size', 0)
          in
            union' new size;
            copy (new, set', size, size'-size)
          end
        else
          union' set size'
      end
d291 15
a305 14
      let
        val size = length set
        val size' = min (size, length set')

        val new = array (size, 0)

        fun difference' 0 = new
          | difference' n =
            (update (new, n-1, andb (sub (set, n-1), notb (sub (set', n-1))));
             difference' (n-1))
      in
        difference' size';
        copy (new, set, size', size - size')
      end
d308 11
a318 10
      let
        val size = min (length set, length set')

        fun difference' 0 = set
          | difference' n =
            (update (set, n-1, andb (sub (set, n-1), notb (sub (set', n-1))));
             difference' (n-1))
      in
        difference' size
      end
@


1.1
log
@Initial revision
@
text
@d26 4
a29 1
 *  $Log$
d178 7
d454 7
@
