head	1.2;
access;
symbols
	MLW_daveb_inline_1_4_99:1.2.3
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.1.8.1.1.1.1
	MLWorks_workspace_97:1.2.2
	MLWorks_dt_wizard:1.2.1
	MLWorks_11c0_1997_09_09:1.1.8.1.1.1
	MLWorks_10r3:1.1.8.1.3
	MLWorks_10r2_551:1.1.8.1.2
	MLWorks_11:1.1.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.8.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.1.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.8
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.1.6.1.1
	MLWorks_gui_1996_12_18:1.1.7
	MLWorks_1_0_Win32_1996_12_17:1.1.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.1.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.1.4.1
	MLWorks_1_0_Irix_1996_11_28:1.1.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.1.5
	MLWorks_1_0_Unix_1996_11_14:1.1.4
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ *  @;


1.2
date	97.05.01.12.58.16;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.02.26.12.45.32;	author jont;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1
	1.1.5.1
	1.1.6.1
	1.1.7.1
	1.1.8.1;
next	;

1.1.1.1
date	96.09.13.11.43.16;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.36.27;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.55.28;	author hope;	state Exp;
branches;
next	;

1.1.4.1
date	96.11.14.13.23.50;	author hope;	state Exp;
branches
	1.1.4.1.1.1;
next	;

1.1.4.1.1.1
date	96.11.28.15.34.27;	author hope;	state Exp;
branches;
next	;

1.1.5.1
date	96.11.22.18.40.54;	author hope;	state Exp;
branches;
next	;

1.1.6.1
date	96.12.17.18.19.52;	author hope;	state Exp;
branches
	1.1.6.1.1.1;
next	;

1.1.6.1.1.1
date	97.02.24.12.14.18;	author hope;	state Exp;
branches;
next	;

1.1.7.1
date	96.12.18.10.15.23;	author hope;	state Exp;
branches;
next	;

1.1.8.1
date	97.05.12.10.53.41;	author hope;	state Exp;
branches
	1.1.8.1.1.1
	1.1.8.1.2.1
	1.1.8.1.3.1;
next	;

1.1.8.1.1.1
date	97.07.28.18.35.57;	author daveb;	state Exp;
branches
	1.1.8.1.1.1.1.1;
next	;

1.1.8.1.1.1.1.1
date	97.10.07.12.01.21;	author jkbrook;	state Exp;
branches;
next	;

1.1.8.1.2.1
date	97.09.08.17.28.23;	author daveb;	state Exp;
branches;
next	;

1.1.8.1.3.1
date	97.09.09.14.25.57;	author daveb;	state Exp;
branches;
next	;

1.2.1.1
date	97.09.10.19.44.45;	author brucem;	state Exp;
branches;
next	;

1.2.2.1
date	97.09.11.21.12.00;	author daveb;	state Exp;
branches;
next	;

1.2.3.1
date	99.04.01.18.09.50;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Moved from mononewmap
@


1.2
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*  === SPECIAL PURPOSE MAP ===
 *           SIGNATURE
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  A map is a general purpose partial function from some domain to some
 *  range, or, if you prefer, a look-up table.  For the sake of efficiency a
 *  complete order must be provided when constructing a map.
 *
 *  Notes
 *  -----
 *  This signature is intended to have more than one implementation, using
 *  association lists, balanced trees, arrays, etc.  I want to keep the
 *  signature simple and self-contained.
 *
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
Revision 1.2  1994/10/13  10:05:57  matthew
Use pervasive Option.option for return values

Revision 1.1  1992/10/29  14:50:00  jont
Initial revision

 *)


signature MONOMAP =
  sig
    (*  === THE MAP TYPE ===  *)

    type ('image) T (* The map type *)
    eqtype object   (* The domain type *)

    (*  === CONSTRUCT AN EMPTY MAP ===
     *
     *  An empty map is undefined everywhere, and is constructed by
     *  supplying an ordering function for the object type (<) and
     *  an equality function
     *  Note:
     *    ForAll f,x . apply (empty f) x = raise Undefined
     *
     *)

    val empty  : ('image) T

    (* Determining if a map is empty *)
    val is_empty : ('image) T -> bool

    (*  === DEFINE THE MAP AT A POINT ===
     *
     *  Adds a mapping from the object to the image such that
     *    apply (define (M, x, y)) x = y
     *)

    val define  : ('image) T * object * 'image -> ('image) T
    val define' : ('image) T * (object * 'image) -> ('image) T

    (*  === DEFINE THE MAP AT A POINT ===
     *
     *  Adds a mapping from the object to the image, combining the
     *  images using the supplied function if the object is already
     *  present in the mapping.
     *)

    val combine : (object * 'image * 'image -> 'image) -> ('image) T * object * 'image -> ('image) T

    (*  === UNDEFINE THE MAP AT A POINT ===
     *
     *  Removed a mapping from the object to the image such that
     *    apply (undefine (M, x)) x = raise Undefined
     *)

    val undefine : ('image) T * object -> ('image) T


    (*  === APPLY THE MAP TO AN OBJECT ===
     *
     *  Looks up the image of an object in the map, and raises Undefined if
     *  no mapping has been defined for that object.  apply M is the partial
     *  function represented by the map M, and should be lifted out of loops
     *  and functions so that apply has a chance to optimise the map.
     *
     *  apply' is an uncurried alternative to apply.  Use the curried
     *  version if it can be lifted (see previous paragraph).  apply_default
     *  and apply_default' will return a default image rather than raise
     *  Undefined.
     *)

    exception Undefined

    val apply          : ('image) T -> object -> 'image
    val apply'         : ('image) T * object -> 'image
    val tryApply       : ('image) T -> object -> 'image option
    val tryApply'      : ('image) T * object -> 'image option
    val apply_default  : ('image) T * 'image -> object -> 'image
    val apply_default' : ('image) T * 'image * object -> 'image

    (*  === EXTRACT THE DOMAIN OF A MAP ===
     *
     *  A list of all objects for which the map is defined is returned.
     *)

    val domain : ('image) T -> object list
    val domain_ordered : ('image) T -> object list

    (*  === EXTRACT THE RANGE OF A MAP ===
     *
     *  A list of all images mapped to in the map is returned.  This may
     *  contain duplicate entries.
     *)

    val range : ('image) T -> 'image list
    val range_ordered : ('image) T -> 'image list

    (*  === CONVERT MAP TO LIST ===
     *
     *  Converts a map to a list of pairs of the form (object, image), in no
     *  particular order.  to_list_ordered produces the pairs in ascending
     *  order of object.
     *)

    val to_list         : ('image) T -> (object * 'image) list
    val to_list_ordered : ('image) T -> (object * 'image) list

    (*  === CONVERT LIST TO MAP ===
     *
     *  Converts a list of pairs of the form (object, image) to a map
     *  defined for all such objects.  An ordering function on the objects
     *  is also required as for `empty' (see above).
     *)

    val from_list :
      (object * 'image) list ->
      ('image) T

    (*  === FOLD OVER MAP ===
     *
     *  Folds over all the live elements of a map.
     *)

    val fold : ('a * object * 'c -> 'a) -> 'a * ('c)T -> 'a
    val fold_in_order : ('a * object * 'c -> 'a) -> 'a * ('c)T -> 'a
    val fold_in_rev_order : ('a * object * 'c -> 'a) -> 'a * ('c)T -> 'a

    (*  === MAP OVER MAP ===
     *
     *  Map over all the live elements of a map in order.
     *)

    val map : (object * 'b -> 'c) -> ('b)T -> ('c)T

    (*
     *  Calculate the number of entries in a map.
     *)

    val size : ('b)T -> int

    (*
     * Given an equality function on the image, checks if two maps are equal.
     *)

    val eq : ('a * 'b -> bool) -> ('a)T * ('b)T -> bool

    (*
     *  Find the position of an object in the domain (wrt to the domain
     *  ordering), counting from zero for the least object. Raises Undefined
     *  if the object is not present in the domain.
     *)

    val rank  : ('b)T -> object -> int
    val rank' : ('b)T * object -> int

    (*  === UNITE MAPS ===
     *
     *  Overrides the first map with the second
     *)

    val union : ('b)T * ('b)T -> ('b)T

    (*  === UNITE MAPS ===
     *
     *  Merges the first map with the second, using the function
     *  provided if both maps map the same object.
     *)

    val merge : ('b * 'b -> 'b) -> ('b)T * ('b)T -> ('b)T

    (*  === LOGICAL FUNCTIONS OVER MAP RANGES ===
     *
     *  Forall and Exists quantifiers
     *)

    val forall : (object * 'b -> bool) -> ('b)T -> bool
    val exists : (object * 'b -> bool) -> ('b)T -> bool

    (*  === ITERATION OVER MAPS ===
     *
     *  Iterate and Iterate ordered
     *)

    val iterate : (object * 'b -> unit) -> ('b)T -> unit
    val iterate_ordered : (object * 'b -> unit) -> ('b)T -> unit

    (* === PRINTING OF MAPS ===
     *
     * Make a map into a string.
     *)

    val string :
      (object -> string) -> ('b -> string) ->
      {start : string, domSep : string, itemSep : string, finish : string} ->
      ('b)T -> string

  end
@


1.2.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a18 4
 *  Revision 1.2  1997/05/01  12:58:16  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.2.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a18 4
 *  Revision 1.2  1997/05/01  12:58:16  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.2.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a18 4
 *  Revision 1.2  1997/05/01  12:58:16  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
@


1.1
log
@new unit
Moved from mononewmap
@
text
@d18 5
a22 1
 *  $Log: mononewmap.sml,v $
d98 2
a99 2
    val tryApply       : ('image) T -> object -> 'image MLWorks.Option.option
    val tryApply'      : ('image) T * object -> 'image MLWorks.Option.option
@


1.1.8.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a18 3
 *  Revision 1.1.8.1  1997/05/12  10:53:41  hope
 *  branched from 1.1
 *
@


1.1.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a18 3
 *  Revision 1.1.8.1  1997/05/12  10:53:41  hope
 *  branched from 1.1
 *
@


1.1.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a18 3
 *  Revision 1.1.8.1  1997/05/12  10:53:41  hope
 *  branched from 1.1
 *
@


1.1.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a18 3
 *  Revision 1.1.8.1.1.1  1997/07/28  18:35:57  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.1.7.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.6.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.6.1.1.1
log
@branched from 1.1.6.1
@
text
@a18 3
 *  Revision 1.1.6.1  1996/12/17  18:19:52  hope
 *  branched from 1.1
 *
@


1.1.5.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.4.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.4.1.1.1
log
@branched from 1.1.4.1
@
text
@a18 3
 *  Revision 1.1.4.1  1996/11/14  13:23:50  hope
 *  branched from 1.1
 *
@


1.1.3.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d18 1
a18 5
 *  $Log: monomap.sml,v $
 *  Revision 1.1  1996/02/26  12:45:32  jont
 *  new unit
 *  Moved from mononewmap
 *
@
