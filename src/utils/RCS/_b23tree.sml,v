head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.10
	MLWorks_20b2_Windows_1998_06_12:1.10
	MLWorks_20b1c1_1998_05_07:1.10
	MLWorks_20b0_1998_04_07:1.10
	MLWorks_20b0_1998_03_20:1.10
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.9.5.1.1.1.1
	MLWorks_workspace_97:1.9.7
	MLWorks_dt_wizard:1.9.6
	MLWorks_11c0_1997_09_09:1.9.5.1.1.1
	MLWorks_10r3:1.9.5.1.3
	MLWorks_10r2_551:1.9.5.1.2
	MLWorks_11:1.9.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.5.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.9.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.5
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.3.1.1
	MLWorks_gui_1996_12_18:1.9.4
	MLWorks_1_0_Win32_1996_12_17:1.9.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.1.1
	MLWorks_1_0_Irix_1996_11_28:1.9.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.2
	MLWorks_1_0_Unix_1996_11_14:1.9.1
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8;
locks; strict;
comment	@ * @;


1.10
date	98.02.19.16.25.22;	author mitchell;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.10.28.14.09.39;	author io;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1;
next	1.8;

1.8
date	96.04.30.17.44.58;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1;
next	1.7;

1.7
date	96.04.29.13.14.50;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.14.23.55;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	96.02.23.16.51.47;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	95.03.16.12.38.12;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.02.02.18.11.43;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.13.10.09.27;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	94.10.11.13.43.55;	author matthew;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.43.14;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.36.25;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.55.26;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.11.14.13.23.48;	author hope;	state Exp;
branches
	1.9.1.1.1.1;
next	;

1.9.1.1.1.1
date	96.11.28.15.34.25;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.11.22.18.40.52;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.12.17.18.19.50;	author hope;	state Exp;
branches
	1.9.3.1.1.1;
next	;

1.9.3.1.1.1
date	97.02.24.12.14.16;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.12.18.10.15.21;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	97.05.12.10.53.39;	author hope;	state Exp;
branches
	1.9.5.1.1.1
	1.9.5.1.2.1
	1.9.5.1.3.1;
next	;

1.9.5.1.1.1
date	97.07.28.18.36.27;	author daveb;	state Exp;
branches
	1.9.5.1.1.1.1.1;
next	;

1.9.5.1.1.1.1.1
date	97.10.07.12.01.39;	author jkbrook;	state Exp;
branches;
next	;

1.9.5.1.2.1
date	97.09.08.17.28.42;	author daveb;	state Exp;
branches;
next	;

1.9.5.1.3.1
date	97.09.09.14.26.29;	author daveb;	state Exp;
branches;
next	;

1.9.6.1
date	97.09.10.19.44.43;	author brucem;	state Exp;
branches;
next	;

1.9.7.1
date	97.09.11.21.11.57;	author daveb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.10.11;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.10
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(*  ==== GENERAL PURPOSE MAP ====
 *   ===    BALANCED TREE    ===
 *             FUNCTOR
 *
 *  Copyright (C) 1994 Harlequin Ltd.
 *
 *  $Log: _b23tree.sml,v $
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.8  1996/04/30  17:44:58  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.7  1996/04/29  13:14:50  matthew
 * Changes to Integer
 *
 * Revision 1.6  1996/03/19  14:23:55  matthew
 * Adding extra parameter to merge
 *
 * Revision 1.5  1996/02/23  16:51:47  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.4  1995/03/16  12:38:12  matthew
 * Added EMPTY special cases for union and merge
 *
 * Revision 1.3  1995/02/02  18:11:43  jont
 * Add header, copyright
 *
 *)
require "map";

functor B23Tree () : MAP =
  struct
    type 'a result = 'a option

    datatype ('a,'b) Node =
      L1 of ('a * 'b result) |
      L2 of ('a * 'b result * 'a * 'b result) |
      N2 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node | 
      N3 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node * 'a * 'b result * ('a,'b) Node

    datatype ('a,'b) map = 
      EMPTY of ('a * 'a -> bool) * ('a * 'a -> bool)
    | TREE of ('a,'b) Node * int * ('a * 'a -> bool) * ('a * 'a -> bool)

    (* The identifiers for the comparison functions *)

    infix eq lt

    fun get_lt (EMPTY (op lt,_)) = op lt
      | get_lt (TREE (_,_,op lt,_)) = op lt

    fun get_eq (EMPTY (_,op eq)) = op eq
      | get_eq (TREE (_,_,_,op eq)) = op eq

    val get_equality = get_eq 
    val get_ordering = get_lt

    fun empty (op lt,op eq) = EMPTY (op lt,op eq)
    fun empty' (op lt) = EMPTY (op lt, op=)

    fun is_empty (EMPTY _) = true
      | is_empty (TREE (_,0,_,_)) = true
      | is_empty _ = false

    (* And now a CPS insert function *)
    (* The continuation type.  Note reuse of node data. *)

    datatype ('a,'b) Cont = 
      C1 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node | 
      C2 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node |
      C3 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node * 'a * 'b result * ('a,'b) Node |
      C4 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node * 'a * 'b result * ('a,'b) Node |
      C5 of ('a,'b) Node * 'a * 'b result * ('a,'b) Node * 'a * 'b result * ('a,'b) Node

    (* Whether the recursive call splits or not is indicated by the continuation function it calls *)

    fun unwind1 (t1',C1(t1,k1,v1,t2)::c) = unwind1(N2 (t1',k1,v1,t2),c)
      | unwind1 (t2',C2(t1,k1,v1,t2)::c) = unwind1 (N2 (t1,k1,v1,t2'),c)
      | unwind1 (t1',C3(t1,k1,v1,t2,k2,v2,t3)::c) = unwind1 (N3 (t1',k1,v1,t2,k2,v2,t3),c)
      | unwind1 (t2',C4(t1,k1,v1,t2,k2,v2,t3)::c) = unwind1 (N3 (t1,k1,v1,t2',k2,v2,t3),c)
      | unwind1 (t3',C5(t1,k1,v1,t2,k2,v2,t3)::c) = unwind1 (N3 (t1,k1,v1,t2,k2,v2,t3'),c)
      | unwind1 (t,[]) = t

    fun unwind2 (t1',k1',v1',t2',C1(t1,k1,v1,t2)::c) = unwind1 (N3 (t1',k1',v1',t2',k1,v1,t2),c)
      | unwind2 (t2',k2',v2',t3',C2(t1,k1,v1,t2)::c) = unwind1 (N3 (t1,k1,v1,t2',k2',v2',t3'),c)
      | unwind2 (t1',k1',v1',t2',C3(t1,k1,v1,t2,k2,v2,t3)::c) =
        unwind2 (N2 (t1',k1',v1',t2'),k1,v1,N2 (t2,k2,v2,t3),c)
      | unwind2 (t2',k2',v2',t3',C4(t1,k1,v1,t2,k2,v2,t3)::c) =
        unwind2 (N2 (t1,k1,v1,t2'),k2',v2',N2 (t3',k2,v2,t3),c)
      | unwind2 (t3',k3',v3',t4',C5(t1,k1,v1,t2,k2,v2,t3)::c) =
        unwind2 (N2 (t1,k1,v1,t2),k2,v2,N2 (t3',k3',v3',t4'),c)
      | unwind2 (t1,k1,v1,t2,[]) = N2 (t1,k1,v1,t2)
 
(* This is the insert function before CPS conversion *)
(*
    datatype ('a,'b) Result =
      SINGLE of ('a,'b) Node |
      SPLIT of ('a,'b) Node * object * 'a result * ('a,'b) Node

    fun insert (t,k,v,f,op lt,op eq) =
      let
        fun scan (L1 (k1,v1)) =
          if k lt k1 
            then 
              SINGLE (L2 (k,v,k1,v1))
          else 
            if k eq k1
              then SINGLE (L1 (k,f v1))
            else SINGLE (L2 (k1,v1,k,v))
          | scan (L2 (k1,v1,k2,v2)) =
            if k lt k1 
              then SPLIT (L1 (k,v),k1,v1,L1 (k2,v2))
            else if k lt k2
               then 
                 if k eq k1 
                   then SINGLE (L2 (k,f v1,k2,v2))
                 else SPLIT (L1 (k1,v1),k,v,L1 (k2,v2))
            else if k eq k2 then SINGLE (L2 (k1,v1,k,f v2))
            else SPLIT (L1 (k1,v1),k2,v2,L1 (k,v))
          | scan (N2 (t1,k1,v1,t2)) =
            if k lt k1
              then
                (case scan t1 of
                   SINGLE (t1') => SINGLE (N2 (t1',k1,v1,t2))
                 | SPLIT (t1',k1',v1',t2') => SINGLE (N3 (t1',k1',v1',t2',k1,v1,t2)))
            else if k eq k1
                   then SINGLE (N2 (t1,k,f v1,t2))
                 else
                   (case scan t2 of
                      SINGLE (t2') => SINGLE (N2 (t1,k1,v1,t2'))
                    | SPLIT (t2',k2',v2',t3') => SINGLE (N3 (t1,k1,v1,t2',k2',v2',t3')))
          | scan (N3 (t1,k1,v1,t2,k2,v2,t3)) = 
            if k lt k1
              then
                (case scan t1 of
                   SINGLE (t1') => SINGLE (N3 (t1',k1,v1,t2,k2,v2,t3))
                 | SPLIT (t1',k1',v1',t2') =>
                     SPLIT (N2 (t1',k1',v1',t2'),k1,v1,N2 (t2,k2,v2,t3)))
            else if k lt k2
                   then if k eq k1
                          then SINGLE (N3 (t1,k,f v1,t2,k2,v2,t3))
                        else
                          (case scan t2 of
                             SINGLE (t2') => SINGLE (N3 (t1,k1,v1,t2',k2,v2,t3))
                           | SPLIT (t2',k2',v2',t3') =>
                               SPLIT (N2 (t1,k1,v1,t2'),k2',v2',N2 (t3',k2,v2,t3)))
            else if k eq k2
                   then SINGLE (N3 (t1,k1,v1,t2,k,f v2,t3))
            else
              (case scan t3 of
                 SINGLE (t3') => SINGLE (N3 (t1,k1,v1,t2,k2,v2,t3'))
               | SPLIT (t3',k3',v3',t4') =>
                   SPLIT (N2 (t1,k1,v1,t2),k2,v2,N2 (t3',k3',v3',t4')))
      in
        case scan t of
          SINGLE t' => t'
        | SPLIT data => N2 data
      end
*)

    val count = ref 0
    (* Specialized version for straightforward insertion *)
    fun insert_value (t,k,v,size,op lt, op eq) =
      let
        fun scan (L1 (k1,v1),k,op lt,op eq,c) =
          if k lt k1 
            then 
              unwind1(L2 (k,v,k1,v1),c)
          else 
            if k eq k1
              then (size := !size-1;unwind1 (L1 (k,v),c))
            else unwind1 (L2 (k1,v1,k,v),c)
          | scan (L2 (k1,v1,k2,v2),k,op lt,op eq,c) =
            if k lt k1 
              then unwind2 (L1 (k,v),k1,v1,L1 (k2,v2),c)
            else if k lt k2
                   then 
                     if k eq k1
                       then (size := !size-1;unwind1 (L2 (k,v,k2,v2),c))
                     else unwind2 (L1 (k1,v1),k,v,L1 (k2,v2),c)
            else if k eq k2 then (size := !size-1;unwind1 (L2 (k1,v1,k,v),c))
                 else unwind2 (L1 (k1,v1),k2,v2,L1 (k,v),c)
          | scan (N2 (data as (t1,k1,v1,t2)),k,op lt,op eq,c) =
            if k lt k1
              then scan (t1,k,op lt,op eq,C1 data :: c)
            else if k eq k1
                   then (size := !size-1;unwind1 (N2 (t1,k,v,t2),c))
                 else scan (t2,k,op lt,op eq,C2 data :: c)
          | scan (N3 (data as (t1,k1,v1,t2,k2,v2,t3)),k,op lt,op eq,c) = 
            if k lt k1
              then scan (t1,k,op lt,op eq,C3 data :: c)
            else if k lt k2
                   then if k eq k1
                          then (size := !size-1;unwind1 (N3 (t1,k,v,t2,k2,v2,t3),c))
                        else scan (t2,k,op lt,op eq,C4 data::c)
            else if k eq k2
                   then (size := !size-1;unwind1 (N3 (t1,k1,v1,t2,k,v,t3),c))
                 else scan (t3,k,op lt,op eq,C5 data::c)
      in
        scan (t,k,op lt,op eq,[])
      end

    fun define (EMPTY (op lt,op eq),k,v) = TREE (L1 (k,SOME v),1,op lt,op eq)
      | define (TREE (t,size,op lt, op eq),k,v) = 
        let
(*
          val _ = 
            if size > 15
              then
                (output (std_out,".");
                 count := !count + 1;
                 if !count = 80 then (output (std_out,"\n"); count := 0) else ())
            else ()
*)
          val sz = ref (size+1)
        in
          TREE (insert_value (t,k,SOME v,sz,op lt,op eq),!sz,op lt,op eq)
        end

    fun define' (t,(k,v)) = define (t,k,v)

    fun insert (t,k,v,combine,op lt, op eq) =
      let
        fun scan (L1 (k1,v1),k,op lt,op eq,c) =
          if k lt k1 
            then 
              unwind1(L2 (k,v,k1,v1),c)
          else 
            if k eq k1
              then unwind1 (L1 (k,combine v1),c)
            else unwind1 (L2 (k1,v1,k,v),c)
          | scan (L2 (k1,v1,k2,v2),k,op lt,op eq,c) =
            if k lt k1 
              then unwind2 (L1 (k,v),k1,v1,L1 (k2,v2),c)
            else if k lt k2
                   then 
                     if k eq k1
                       then unwind1 (L2 (k,combine v1,k2,v2),c)
                     else unwind2 (L1 (k1,v1),k,v,L1 (k2,v2),c)
            else if k eq k2 then unwind1 (L2 (k1,v1,k,combine v2),c)
                 else unwind2 (L1 (k1,v1),k2,v2,L1 (k,v),c)
          | scan (N2 (data as (t1,k1,v1,t2)),k,op lt,op eq,c) =
            if k lt k1
              then scan (t1,k,op lt,op eq,C1 data :: c)
            else if k eq k1
                   then unwind1 (N2 (t1,k,combine v1,t2),c)
                 else scan (t2,k,op lt,op eq,C2 data :: c)
          | scan (N3 (data as (t1,k1,v1,t2,k2,v2,t3)),k,op lt,op eq,c) = 
            if k lt k1
              then scan (t1,k,op lt,op eq,C3 data :: c)
            else if k lt k2
                   then if k eq k1
                          then unwind1 (N3 (t1,k,combine v1,t2,k2,v2,t3),c)
                        else scan (t2,k,op lt,op eq,C4 data::c)
            else if k eq k2
                   then unwind1 (N3 (t1,k1,v1,t2,k,combine v2,t3),c)
                 else scan (t3,k,op lt,op eq,C5 data::c)
      in
        scan (t,k,op lt,op eq,[])
      end

    fun combine f (EMPTY(op lt,op eq),k,v) = TREE (L1 (k,SOME v),1,op lt,op eq)
      | combine f (TREE (t,size,op lt,op eq),k,v) = 
        let
          val newv = SOME v
          val sz = ref (size+1)
          fun combine (SOME v') = (sz := size; SOME (f (k,v',v)))
            | combine _ = SOME v
        in
          TREE (insert (t,k,newv,combine,op lt,op eq),!sz,op lt,op eq)
        end
      
    fun undefine (t as (EMPTY _),k) = t
      | undefine (TREE (t,size,op lt,op eq),k) = 
        let
          val sz = ref size
          (* If its there and defined, then decrement the size *)
          fun combine (SOME _) = (sz := size-1; NONE)
            | combine NONE = NONE
          fun remove (t,k) =
            let
              (* Slight modification of scan function above *)
              fun scan (L1 (k1,v1),c) =
                if k eq k1
                  then unwind1 (L1 (k,combine v1),c)
                else unwind1 (L1 (k1,v1),c)
                | scan (L2 (k1,v1,k2,v2),c) =
                  if k eq k1 
                    then unwind1 (L2 (k,combine v1,k2,v2),c)
                  else if k eq k2 
                    then unwind1 (L2 (k1,v1,k,combine v2),c)
                  else unwind1 (L2 (k1,v1,k2,v2),c)
                | scan (N2 (data as (t1,k1,v1,t2)),c) =
                  if k lt k1
                    then scan (t1,C1 data :: c)
                  else if k eq k1
                         then unwind1 (N2 (t1,k,combine v1,t2),c)
                       else scan (t2,C2 data :: c)
                | scan (N3 (data as (t1,k1,v1,t2,k2,v2,t3)),c) = 
                  if k lt k1
                    then scan (t1,C3 data :: c)
                  else if k lt k2
                    then if k eq k1
                                then unwind1 (N3 (t1,k,combine v1,t2,k2,v2,t3),c)
                              else scan (t2,C4 data::c)
                  else if k eq k2
                    then unwind1 (N3 (t1,k1,v1,t2,k,combine v2,t3),c)
                  else scan (t3,C5 data::c)
            in
              scan (t,[])
            end
        in
          TREE (remove (t,k),!sz,op lt,op eq)
        end
      
    fun tryApply' (EMPTY(op lt,op eq),k) = NONE
      | tryApply' (TREE (t,_,op lt,op eq),k) =
        let 
          fun find (L1 (k1,v1)) =
            if k eq k1 then v1 else NONE
            | find (L2 (k1,v1,k2,v2)) =
              if k eq k1 then v1 else if k eq k2 then v2 else NONE
            | find (N2 (t1,k1,v1,t2)) =
              if k lt k1 then find t1 else if k eq k1 then v1 else find t2
            | find (N3 (t1,k1,v1,t2,k2,v2,t3)) =
              if k lt k1 then find t1
              else if k lt k2 then if k eq k1 then v1 else find t2
              else if k eq k2 then v2 else find t3
        in
          find t
        end
      
    fun tryApply t k = tryApply'(t,k)

    exception Undefined

    fun apply' (t,k) =
      case tryApply' (t,k) of
        NONE => raise Undefined
      | SOME x => x

    fun apply t k = apply' (t,k)

    fun apply_default' (t,v,k) =
      case tryApply' (t,k) of
        NONE => v
      | SOME x => x

    fun apply_default (t,v) k = apply_default'(t,v,k)

    fun tryApply'Eq (EMPTY _, k) = NONE
      | tryApply'Eq (TREE (t,size,op lt,op eq),k) =
        tryApply' (TREE (t,size,op lt,op =),k)

    fun fold f (acc,EMPTY _) = acc
      | fold f (acc,TREE (t,_,_,_)) =
        let
          fun one (k,SOME x,acc) =
            f (acc,k,x)
            | one (_,_,acc) = acc
          fun aux (L1 (k1,v1),acc) = one (k1,v1,acc)
            | aux (L2 (k1,v1,k2,v2),acc) = one (k2,v2,one (k1,v1,acc))
            | aux (N2 (t1,k1,v1,t2),acc) =
              aux (t2,one(k1,v1,aux (t1,acc)))
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3),acc) =
              aux (t3,one(k2,v2,aux (t2,one (k1,v1,aux (t1,acc)))))
        in
          aux (t,acc)
        end
    
    val fold_in_order = fold
      
    fun fold_in_rev_order f (acc,EMPTY _) = acc
      | fold_in_rev_order f (acc,TREE (t,_,_,_)) =
        let
          fun one (k,SOME x,acc) =
            f (acc,k,x)
            | one (_,_,acc) = acc
          fun aux (L1 (k1,v1),acc) = one (k1,v1,acc)
            | aux (L2 (k1,v1,k2,v2),acc) = one (k1,v1,one (k2,v2,acc))
            | aux (N2 (t1,k1,v1,t2),acc) =
              aux (t1,one(k1,v1,aux (t2,acc)))
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3),acc) =
              aux (t1,one(k1,v1,aux (t2,one (k2,v2,aux (t3,acc)))))
        in
          aux (t,acc)
        end

    fun size (EMPTY _) = 0
      | size (TREE (_,n,_,_)) = n

    (* Add the second set of items to the first *)
    (* Simple test for simple cases *)
    fun union (EMPTY _,t2) = t2
      | union (t1,EMPTY _) = t1
      | union (t1,t2) = 
(*
        (* Do the fold over the smaller tree -- maybe? *)
        if size t1 > size t2
          then fold (combine (fn (ob,im,im') => im')) (t1,t2)
        else fold (combine (fn (ob,im,im') => im)) (t2,t1)
*)
        fold define (t1,t2)

    fun merge f (EMPTY _,t2) = t2
      | merge f (t1,EMPTY _) = t1
      | merge f (t1,t2) = 
        fold (combine f) (t1,t2)

    exception Found of int

    fun rank' (m, ob) =
      let
        val op lt = get_lt m
        val op eq = get_eq m
	fun f (res, object, _) =
	  if object lt ob then
	      res + 1
	  else
	    if object eq ob then
		raise Found(res)
	    else
	      raise Undefined
      in
	(ignore(fold_in_order f (0, m)); raise Undefined)
	handle Found(res) => res
      end

    fun rank m ob = rank' (m, ob)

    fun to_list (EMPTY _) = []
      | to_list (TREE (t,_,_,_)) =
        let
          fun add (k,SOME x,acc) =
            (k,x)::acc
            | add (_,_,acc) = acc
          fun aux (L1 (k1,v1),acc) = add (k1,v1,acc)
            | aux (L2 (k1,v1,k2,v2),acc) = add (k1,v1,add(k2,v2,acc))
            | aux (N2 (t1,k1,v1,t2),acc) =
              aux (t1,add(k1,v1,aux (t2,acc)))
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3),acc) =
              aux (t1,add(k1,v1,aux (t2,add (k2,v2,aux (t3,acc)))))
        in
          aux (t,[])
        end
    
    val to_list_ordered = to_list

    fun from_list (op lt,op eq) l =
      let
        fun aux ((k,v)::l,acc) =
          aux (l,define (acc,k,v))
          | aux ([],acc) = acc
      in
        aux (l,EMPTY (op lt,op eq))
      end

    fun from_list' (op lt) = from_list (op lt,op =)

    fun range (EMPTY _) = []
      | range (TREE (t,_,_,_)) =
        let
          fun add (k,SOME x,acc) = x::acc
            | add (_,_,acc) = acc
          fun aux (L1 (k1,v1),acc) = add (k1,v1,acc)
            | aux (L2 (k1,v1,k2,v2),acc) = add (k1,v1,add(k2,v2,acc))
            | aux (N2 (t1,k1,v1,t2),acc) =
              aux (t1,add(k1,v1,aux (t2,acc)))
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3),acc) =
              aux (t1,add(k1,v1,aux (t2,add (k2,v2,aux (t3,acc)))))
        in
          aux (t,[])
        end
    
    val range_ordered = range

    fun domain (EMPTY _) = []
      | domain (TREE (t,_,_,_)) =
        let
          fun add (k,SOME x,acc) = k::acc
            | add (_,_,acc) = acc
          fun aux (L1 (k1,v1),acc) = add (k1,v1,acc)
            | aux (L2 (k1,v1,k2,v2),acc) = add (k1,v1,add(k2,v2,acc))
            | aux (N2 (t1,k1,v1,t2),acc) =
              aux (t1,add(k1,v1,aux (t2,acc)))
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3),acc) =
              aux (t1,add(k1,v1,aux (t2,add (k2,v2,aux (t3,acc)))))
        in
          aux (t,[])
        end
    
    val domain_ordered = domain

    fun iterate f (EMPTY _) = ()
      | iterate f (TREE (t,_,_,_)) =
        let
          fun one (k,SOME x) = f (k,x)
            | one (_,_) = ()
          fun aux (L1 (k1,v1)) = one(k1,v1)
            | aux (L2 (k1,v1,k2,v2)) = (one (k1,v1);one(k2,v2))
            | aux (N2 (t1,k1,v1,t2)) =
              (aux t1;one (k1,v1);aux t2)
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3)) =
              (aux t1;one(k1,v1);aux t2;one (k2,v2);aux t3)
        in
          aux t
        end

    val iterate_ordered = iterate

    fun map f (t as EMPTY (op lt,op eq)) = EMPTY (op lt,op eq)
      | map f (TREE (t,size,op lt,op eq)) =
        let
          fun one (k,SOME x) = SOME (f (k,x))
            | one (_,_) = NONE
          fun aux (L1 (k1,v1)) = L1(k1,one(k1,v1))
            | aux (L2 (k1,v1,k2,v2)) = L2(k1,one (k1,v1),k2,one(k2,v2))
            | aux (N2 (t1,k1,v1,t2)) =
              N2 (aux t1,k1,one (k1,v1),aux t2)
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3)) =
              N3(aux t1,k1,one(k1,v1),aux t2,k2,one (k2,v2),aux t3)
        in
          TREE (aux t,size,op lt,op eq)
        end

    fun forall p (EMPTY _) = true
      | forall p (TREE (t,_,_,_)) =
        let
          fun one (k,SOME x) = p (k,x)
            | one (_,_) = true
          fun aux (L1 (k1,v1)) = one(k1,v1)
            | aux (L2 (k1,v1,k2,v2)) = one (k1,v1) andalso one(k2,v2)
            | aux (N2 (t1,k1,v1,t2)) =
              aux t1 andalso one (k1,v1) andalso aux t2
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3)) =
              aux t1 andalso one(k1,v1) andalso aux t2 andalso one (k2,v2) andalso aux t3
        in
          aux t
        end

    fun exists p (EMPTY _) = false
      | exists p (TREE (t,_,_,_)) =
        let
          fun one (k,SOME x) = p (k,x)
            | one (_,_) = false
          fun aux (L1 (k1,v1)) = one(k1,v1)
            | aux (L2 (k1,v1,k2,v2)) = one (k1,v1) orelse one(k2,v2)
            | aux (N2 (t1,k1,v1,t2)) =
              aux t1 orelse one (k1,v1) orelse aux t2
            | aux (N3 (t1,k1,v1,t2,k2,v2,t3)) =
              aux t1 orelse one(k1,v1) orelse aux t2 orelse one (k2,v2) orelse aux t3
        in
          aux t
        end

    local nonfix eq
    in
      fun eq f (m1, m2) =
        size m1 = size m2 andalso
        ((forall (fn (ob, im) => f (apply'(m1, ob), im)) m2)
         handle Undefined => false)
    end

      
    (* === PRINT A MAP === *)

    fun string obP imP {start, domSep, itemSep, finish} m =
      let
	fun make ((doSep, res), ob, im) =
	  (true, obP ob :: domSep :: imP im :: (if doSep then itemSep :: res else res))
      in
	concat(start :: #2 (fold_in_rev_order make ((false, [finish]), m)))
      end
  
  end;
@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.10  1998/02/19  16:25:22  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.9
log
@[Bug #1614]
basifying String
@
text
@d8 4
d430 1
a430 1
	(fold_in_order f (0, m); raise Undefined)
@


1.9.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.9.5.1  1997/05/12  10:53:39  hope
 * branched from 1.9
 *
@


1.9.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.9.5.1  1997/05/12  10:53:39  hope
 * branched from 1.9
 *
@


1.9.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.9.5.1  1997/05/12  10:53:39  hope
 * branched from 1.9
 *
@


1.9.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.9.5.1.1.1  1997/07/28  18:36:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.3.1.1.1
log
@branched from 1.9.3.1
@
text
@a7 3
 * Revision 1.9.3.1  1996/12/17  18:19:50  hope
 * branched from 1.9
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a7 4
 * Revision 1.9  1996/10/28  14:09:39  io
 * [Bug #1614]
 * basifying String
 *
@


1.9.1.1.1.1
log
@branched from 1.9.1.1
@
text
@a7 3
 * Revision 1.9.1.1  1996/11/14  13:23:48  hope
 * branched from 1.9
 *
@


1.8
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d8 6
d34 1
a34 2
    structure Option = MLWorks.Option
    type 'a result = 'a Option.option
d204 1
a204 1
    fun define (EMPTY (op lt,op eq),k,v) = TREE (L1 (k,Option.SOME v),1,op lt,op eq)
d218 1
a218 1
          TREE (insert_value (t,k,Option.SOME v,sz,op lt,op eq),!sz,op lt,op eq)
d263 1
a263 1
    fun combine f (EMPTY(op lt,op eq),k,v) = TREE (L1 (k,Option.SOME v),1,op lt,op eq)
d266 1
a266 1
          val newv = Option.SOME v
d268 2
a269 2
          fun combine (Option.SOME v') = (sz := size; Option.SOME (f (k,v',v)))
            | combine _ = Option.SOME v
d279 2
a280 2
          fun combine (Option.SOME _) = (sz := size-1; Option.NONE)
            | combine Option.NONE = Option.NONE
d317 1
a317 1
    fun tryApply' (EMPTY(op lt,op eq),k) = Option.NONE
d321 1
a321 1
            if k eq k1 then v1 else Option.NONE
d323 1
a323 1
              if k eq k1 then v1 else if k eq k2 then v2 else Option.NONE
d340 2
a341 2
        Option.NONE => raise Undefined
      | Option.SOME x => x
d347 2
a348 2
        Option.NONE => v
      | Option.SOME x => x
d352 1
a352 1
    fun tryApply'Eq (EMPTY _, k) = Option.NONE
d359 1
a359 1
          fun one (k,Option.SOME x,acc) =
d377 1
a377 1
          fun one (k,Option.SOME x,acc) =
d435 1
a435 1
          fun add (k,Option.SOME x,acc) =
d464 1
a464 1
          fun add (k,Option.SOME x,acc) = x::acc
d481 1
a481 1
          fun add (k,Option.SOME x,acc) = k::acc
d498 1
a498 1
          fun one (k,Option.SOME x) = f (k,x)
d515 2
a516 2
          fun one (k,Option.SOME x) = Option.SOME (f (k,x))
            | one (_,_) = Option.NONE
d530 1
a530 1
          fun one (k,Option.SOME x) = p (k,x)
d545 1
a545 1
          fun one (k,Option.SOME x) = p (k,x)
d573 1
a573 1
	String.implode(start :: #2 (fold_in_rev_order make ((false, [finish]), m)))
@


1.8.3.1
log
@branched from 1.8
@
text
@a7 6
 * Revision 1.8  1996/04/30  17:44:58  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a7 6
 * Revision 1.8  1996/04/30  17:44:58  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a7 6
 * Revision 1.8  1996/04/30  17:44:58  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.7
log
@Changes to Integer
@
text
@d8 3
d568 1
a568 1
	implode(start :: #2 (fold_in_rev_order make ((false, [finish]), m)))
@


1.6
log
@Adding extra parameter to merge
@
text
@d8 3
a381 3
    fun simple_print (EMPTY _) = "Tree 0"
      | simple_print (TREE (_,size,_,_)) = "Tree " ^ MLWorks.Integer.makestring size

d401 1
a401 2
      ((* output (std_out,"Merge: " ^ simple_print t1 ^ " & " ^ simple_print t2 ^ "\n"); *)
       fold (combine f) (t1,t2))
@


1.5
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d8 3
d402 1
a402 1
       fold (combine (fn (ob, im, im') => f(im, im'))) (t1,t2))
@


1.4
log
@Added EMPTY special cases for union and merge
@
text
@d8 5
a12 3
# Revision 1.3  1995/02/02  18:11:43  jont
# Add header, copyright
#: _btree.sml,v $
d15 1
a15 1
require "newmap";
d17 1
a17 1
functor B23Tree () : NEWMAP =
d28 1
a28 1
    datatype ('a,'b) T = 
@


1.3
log
@Add header, copyright
@
text
@d7 4
a10 1
 *  $Log$: _btree.sml,v $
a78 40
    fun insert (t,k,v,combine,op lt, op eq) =
      let
        fun scan (L1 (k1,v1),k,op lt,op eq,c) =
          if k lt k1 
            then 
              unwind1(L2 (k,v,k1,v1),c)
          else 
            if k eq k1
              then unwind1 (L1 (k,combine v1),c)
            else unwind1 (L2 (k1,v1,k,v),c)
          | scan (L2 (k1,v1,k2,v2),k,op lt,op eq,c) =
            if k lt k1 
              then unwind2 (L1 (k,v),k1,v1,L1 (k2,v2),c)
            else if k lt k2
                   then 
                     if k eq k1
                       then unwind1 (L2 (k,combine v1,k2,v2),c)
                     else unwind2 (L1 (k1,v1),k,v,L1 (k2,v2),c)
            else if k eq k2 then unwind1 (L2 (k1,v1,k,combine v2),c)
                 else unwind2 (L1 (k1,v1),k2,v2,L1 (k,v),c)
          | scan (N2 (data as (t1,k1,v1,t2)),k,op lt,op eq,c) =
            if k lt k1
              then scan (t1,k,op lt,op eq,C1 data :: c)
            else if k eq k1
                   then unwind1 (N2 (t1,k,combine v1,t2),c)
                 else scan (t2,k,op lt,op eq,C2 data :: c)
          | scan (N3 (data as (t1,k1,v1,t2,k2,v2,t3)),k,op lt,op eq,c) = 
            if k lt k1
              then scan (t1,k,op lt,op eq,C3 data :: c)
            else if k lt k2
                   then if k eq k1
                          then unwind1 (N3 (t1,k,combine v1,t2,k2,v2,t3),c)
                        else scan (t2,k,op lt,op eq,C4 data::c)
            else if k eq k2
                   then unwind1 (N3 (t1,k1,v1,t2,k,combine v2,t3),c)
                 else scan (t3,k,op lt,op eq,C5 data::c)
      in
        scan (t,k,op lt,op eq,[])
      end

d146 42
d191 9
a200 3
          val newv = Option.SOME v
          fun combine (Option.SOME _) = (sz := size; newv)
            | combine _ = newv
d202 1
a202 1
          TREE (insert (t,k,newv,combine,op lt,op eq),!sz,op lt,op eq)
d207 40
d374 18
a391 1
    val union = fold define
d393 5
a397 1
    fun merge f = fold (combine (fn (ob, im, im') => f(im, im')))
a482 3
    fun size (EMPTY _) = 0
      | size (TREE (_,n,_,_)) = n
        
@


1.2
log
@Use pervasive Option.option for return values
@
text
@d1 9
@


1.1
log
@new file
@
text
@d5 2
a6 1
    datatype 'b result = YES of 'b | NO
d174 1
a174 1
    fun define (EMPTY (op lt,op eq),k,v) = TREE (L1 (k,YES v),1,op lt,op eq)
d178 2
a179 2
          val newv = YES v
          fun combine (YES _) = (sz := size; newv)
d187 1
a187 1
    fun combine f (EMPTY(op lt,op eq),k,v) = TREE (L1 (k,YES v),1,op lt,op eq)
d190 1
a190 1
          val newv = YES v
d192 2
a193 2
          fun combine (YES v') = (sz := size; YES (f (k,v',v)))
            | combine _ = YES v
d203 2
a204 2
          fun combine (YES _) = (sz := size-1; NO)
            | combine NO = NO
d241 1
a241 1
    fun tryApply' (EMPTY(op lt,op eq),k) = NO
d245 1
a245 1
            if k eq k1 then v1 else NO
d247 1
a247 1
              if k eq k1 then v1 else if k eq k2 then v2 else NO
d264 2
a265 2
        NO => raise Undefined
      | YES x => x
d271 2
a272 2
        NO => v
      | YES x => x
d276 1
a276 1
    fun tryApply'Eq (EMPTY _, k) = NO
d283 1
a283 1
          fun one (k,YES x,acc) =
d301 1
a301 1
          fun one (k,YES x,acc) =
d342 1
a342 1
          fun add (k,YES x,acc) =
d371 1
a371 1
          fun add (k,YES x,acc) = x::acc
d388 1
a388 1
          fun add (k,YES x,acc) = k::acc
d408 1
a408 1
          fun one (k,YES x) = f (k,x)
d425 2
a426 2
          fun one (k,YES x) = YES (f (k,x))
            | one (_,_) = NO
d440 1
a440 1
          fun one (k,YES x) = p (k,x)
d455 1
a455 1
          fun one (k,YES x) = p (k,x)
@
