head	1.19;
access;
symbols
	MLW_daveb_inline_1_4_99:1.19.1
	MLWorks_21c0_1999_03_25:1.19
	MLWorks_20c1_1998_08_20:1.19
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.19
	MLWorks_20b2_Windows_1998_06_12:1.19
	MLWorks_20b1c1_1998_05_07:1.19
	MLWorks_20b0_1998_04_07:1.19
	MLWorks_20b0_1998_03_20:1.19
	MLWorks_20m2_1998_02_16:1.18
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.18.5.1.1.1.1
	MLWorks_workspace_97:1.18.7
	MLWorks_dt_wizard:1.18.6
	MLWorks_11c0_1997_09_09:1.18.5.1.1.1
	MLWorks_10r3:1.18.5.1.3
	MLWorks_10r2_551:1.18.5.1.2
	MLWorks_11:1.18.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.18.5.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.18.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.18.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.18.5
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.18
	MLWorks_1_0_r2_Unix_1997_04_04:1.18
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.18.3.1.1
	MLWorks_gui_1996_12_18:1.18.4
	MLWorks_1_0_Win32_1996_12_17:1.18.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.18.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.18.1.1
	MLWorks_1_0_Irix_1996_11_28:1.18.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.18.2
	MLWorks_1_0_Unix_1996_11_14:1.18.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.16
	MLWorks_Beta_1996_06_07:1.16
	MLWorks_Beta_1996_06_06:1.16
	MLWorks_Beta_1996_06_05:1.16
	MLWorks_Beta_1996_06_03:1.16
	MLWorks_Beta_1996_05_31:1.16
	MLWorks_Beta_1996_05_30:1.16
	ML_beta_release_12/08/94:1.12
	ML_beta_release_03/08/94:1.12
	ML_revised_beta_release_25/05/94:1.12
	ML_final_beta_release_02/03/94:1.12
	mlworks-28-01-1994:1.12
	Release:1.12
	mlworks-beta-01-09-1993:1.12
	MLWorks-1-0-4-29/01/1993:1.9
	MLWorks-1-0-3-21/12/1992:1.9
	MLWorks-1-0-2-15/12/1992:1.7
	MLWorks-1-0-1-04/12/1992:1.7
	checkpoint_17_08_92:1.5;
locks; strict;
comment	@ * @;


1.19
date	98.02.19.16.46.57;	author mitchell;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	96.11.06.10.53.55;	author matthew;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1
	1.18.4.1
	1.18.5.1
	1.18.6.1
	1.18.7.1;
next	1.17;

1.17
date	96.10.28.14.25.57;	author io;	state Exp;
branches;
next	1.16;

1.16
date	96.05.17.09.18.31;	author matthew;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.05.07.10.44.29;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.04.30.17.45.12;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.04.29.13.50.56;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.05.20.12.48.37;	author jont;	state Exp;
branches
	1.12.1.1;
next	1.11;

1.11
date	93.05.18.18.35.45;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	93.03.01.11.48.58;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.12.22.10.54.13;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.12.21.13.28.29;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	92.12.01.18.37.30;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.27.16.23.06;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.08.13.16.15.29;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.08.04.19.07.11;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	92.08.04.11.02.53;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.07.16.16.23.04;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.04.21.16.57.29;	author jont;	state Exp;
branches;
next	;

1.12.1.1
date	93.05.20.12.48.37;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.43.37;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.36.51;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.55.50;	author hope;	state Exp;
branches;
next	;

1.18.1.1
date	96.11.14.13.24.11;	author hope;	state Exp;
branches
	1.18.1.1.1.1;
next	;

1.18.1.1.1.1
date	96.11.28.15.34.58;	author hope;	state Exp;
branches;
next	;

1.18.2.1
date	96.11.22.18.41.17;	author hope;	state Exp;
branches;
next	;

1.18.3.1
date	96.12.17.18.20.14;	author hope;	state Exp;
branches
	1.18.3.1.1.1;
next	;

1.18.3.1.1.1
date	97.02.24.12.14.42;	author hope;	state Exp;
branches;
next	;

1.18.4.1
date	96.12.18.10.15.46;	author hope;	state Exp;
branches;
next	;

1.18.5.1
date	97.05.12.10.53.52;	author hope;	state Exp;
branches
	1.18.5.1.1.1
	1.18.5.1.2.1
	1.18.5.1.3.1;
next	;

1.18.5.1.1.1
date	97.07.28.18.35.29;	author daveb;	state Exp;
branches
	1.18.5.1.1.1.1.1;
next	;

1.18.5.1.1.1.1.1
date	97.10.07.12.01.02;	author jkbrook;	state Exp;
branches;
next	;

1.18.5.1.2.1
date	97.09.08.17.28.04;	author daveb;	state Exp;
branches;
next	;

1.18.5.1.3.1
date	97.09.09.14.25.30;	author daveb;	state Exp;
branches;
next	;

1.18.6.1
date	97.09.10.19.44.07;	author brucem;	state Exp;
branches;
next	;

1.18.7.1
date	97.09.11.21.11.31;	author daveb;	state Exp;
branches;
next	;

1.19.1.1
date	99.04.01.18.09.32;	author daveb;	state Exp;
branches;
next	;


desc
@A new implementation of sets based on hashing. This is mildly imperative.
Beware.
@


1.19
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _hashset.sml the functor *)
(*
$Log: _hashset.sml,v $
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.17  1996/10/28  14:25:57  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.16  1996/05/17  09:18:31  matthew
 * Moving Bits to MLWorks.Internal
 *
 * Revision 1.15  1996/05/07  10:44:29  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.14  1996/04/30  17:45:12  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.13  1996/04/29  13:50:56  matthew
 * Integer changes
 *
 * Revision 1.12  1993/05/20  12:48:37  jont
 * Added a rehash function to deal with sets where the hash value changes
 * due to update (eg Namesets)
 *
Revision 1.11  1993/05/18  18:35:45  jont
Removed integer parameter

Revision 1.10  1993/03/01  11:48:58  jont
Modified to allow expansion and contraction of the hashset according to amount
of data.

Revision 1.9  1992/12/22  10:54:13  clive
Corrected references to ExtendedArray

Revision 1.8  1992/12/21  13:28:29  daveb
Chnaged references to Array to ExtendedArray, where appropriate.

Revision 1.7  1992/12/01  18:37:30  jont
Improved to avoid parameter recopying in numerous places

Revision 1.6  1992/08/27  16:23:06  jont
Recoded using new array utilities

Revision 1.5  1992/08/13  16:15:29  davidt
Added iterate function.

Revision 1.4  1992/08/04  19:07:11  davidt
Added fold function.

Revision 1.3  1992/08/04  11:02:53  jont
Removed unnecessary require

Revision 1.2  1992/07/16  16:23:04  jont
Removed array parameter, now uses pervasive one

Revision 1.1  1992/04/21  16:57:29  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "^.basis.__int";
require "hashset";
require "crash";
require "lists";

(* A few basic well-known set functions, using a hashtable internally *)

functor HashSet(
  structure Crash : CRASH
  structure Lists : LISTS
  type element
  val eq : element * element -> bool
  val hash : element -> int
) : HASHSET =
  struct

    structure Bits = MLWorks.Internal.Bits

    type element = element

    type HashSet = ((int * element) list MLWorks.Internal.ExtendedArray.array * int ref) ref
    (* (hash value, element) list array * available until we resize count *)

    val max_size = 16384
    (* A safe amount by which to reduce during hash calculation *)

    fun member(elt, []) = false
      | member(elt, (_, x) :: xs) = eq(elt, x) orelse member(elt, xs)

    (*
     This expansion ratio of 2 is used to maintain the fact that the tables
     are a power of two in size. This means we may use bitwise operations to go from
     hash value to table index, and can do the resize operation much more
     quickly - if this is changed, some of the other functions need to be re-written
     *)

    val expansion_ratio = 2
    (* factor to increase by on re-size - if this is changed from 2, adjust
     partitioning part of the re-sizing code in update *)
    val max_size_ratio = 4
    (* resize when number of elements is this multiplied by the size *)

    fun set_size(ref(the_lists, ref count)) =
      let
	val c1 =
	  MLWorks.Internal.ExtendedArray.reducel
	  (fn (sum, list) => sum + length list)
	  (0, the_lists)
	val c2 = MLWorks.Internal.ExtendedArray.length the_lists * max_size_ratio - count
      in
	if c1 = c2 then c1
	else
	  Crash.impossible
	  (concat["Strange hashset size not as expected\n",
		   "Length = ",
		   Int.toString(MLWorks.Internal.ExtendedArray.length the_lists),
		   ", count = ",
		   Int.toString count,
		   ", c1 = ",
		   Int.toString c1,
		   "\n"])
      end

    local
      fun nearest_power_of_two (size,x) =
        if x >= size
          then x
        else nearest_power_of_two (size,2*x)
    in
      fun empty_set size =
	let
	  val initial_size = nearest_power_of_two(size, 1)
	in
	  ref(MLWorks.Internal.ExtendedArray.array(initial_size, [] : (int * element) list),
	      ref(max_size_ratio * initial_size))
	end
    end

    fun force_shrink(elts as ref(the_list, count as ref c)) =
      let
	val old_size = MLWorks.Internal.ExtendedArray.length the_list
	val new_size = old_size div expansion_ratio
	val _ =
	  if new_size <= 0 then
	    Crash.impossible"Hashset resized down to zero length??"
	  else
	    ()
	val new_arr = MLWorks.Internal.ExtendedArray.array(new_size, [] : (int * element) list)
	(* Since the expansion size is two, *)
	(* we can calculate the new position  *)
	(* of the elements from the old positions very easily *)
	(* The resulting f and s are the first and second *)
	(* halves of the table *)

	fun deal_with_elements index =
	  if index < 0 then ()
	  else
	    (let
	       val f = MLWorks.Internal.ExtendedArray.sub(the_list, index)
	       val s = MLWorks.Internal.ExtendedArray.sub(the_list, index + new_size)
	     in
	       MLWorks.Internal.ExtendedArray.update(new_arr, index, f @@ s)
	     end;
	     deal_with_elements(index - 1))

	val new_count = max_size_ratio * (new_size - old_size) + c
      in
	deal_with_elements(new_size - 1);
	elts := (new_arr, ref new_count);
	elts
      end

    fun force_resize(elts as ref(the_list, count as ref c)) =
      let
	val old_size = MLWorks.Internal.ExtendedArray.length the_list
	val new_size = old_size * expansion_ratio
	val new_arr = MLWorks.Internal.ExtendedArray.array(new_size, [] : (int * element) list)
	(* Since the expansion size is two, *)
	(* we can calculate the new position  *)
	(* of the elements from the old positions very easily *)
	(* The resulting f and s are the first and second *)
	(* halves of the table *)

	fun partition([], size, f, s) = (f, s)
	  | partition((elem as (hashvalue,_)) :: rest, size, f, s) =
	    if Bits.andb(hashvalue, size) = 0
	      then partition(rest, size, elem :: f, s)
	    else partition(rest, size, f, elem :: s)

	fun deal_with_elements(_, []) = ()
	  | deal_with_elements(index, elems) =
	    let
	      val (f,s) = partition(elems, old_size, [], [])
	    in
	      MLWorks.Internal.ExtendedArray.update(new_arr, index, f);
	      MLWorks.Internal.ExtendedArray.update(new_arr, index + old_size, s)
	    end
	val new_count = max_size_ratio * (new_size - old_size) + c
      in
	MLWorks.Internal.ExtendedArray.iterate_index deal_with_elements the_list;
	elts := (new_arr, ref new_count);
	elts
      end

    fun resize(elts as ref(_, ref c)) =
      if c >= 0 then elts
      else
	resize(force_resize elts)

    fun add_member'(elts as ref(the_list, count as ref c), elt) =
      let
	val hash = hash elt
	val old_size = MLWorks.Internal.ExtendedArray.length the_list
	val pos = Bits.andb(hash, old_size-1)
	val set = MLWorks.Internal.ExtendedArray.sub(the_list, pos)
      in
	if member(elt, set) then
	  elts
	else
	  (MLWorks.Internal.ExtendedArray.update(the_list, pos, (hash, elt) :: set);
	   count := c - 1;
	   resize elts)
      end

    fun add_member(arg as (elts, _)) = (ignore(add_member' arg); elts)

    fun remove_member(elts as ref(the_list, count as ref c), elt) =
      let
	val hash = hash elt
	val size = MLWorks.Internal.ExtendedArray.length the_list
	val pos = Bits.andb(hash, size-1)
	val set = MLWorks.Internal.ExtendedArray.sub(the_list, pos)
      in
	if member(elt, set) then
	  (MLWorks.Internal.ExtendedArray.update(the_list, pos,
					Lists.filterp (fn (_, x) => not(eq(x, elt))) set);
	   count := c + 1; (* One more space available *)
	   elts)
	else
	  elts
      end

    fun empty_setp(ref(the_list, _)) =
      MLWorks.Internal.ExtendedArray.reducel
      (fn (false, _) => false
       | (_, []) => true
       | _ => false)
      (true, the_list)

    fun is_member(ref(the_list, _), elt) =
      let
	val hash = hash elt
	val size = MLWorks.Internal.ExtendedArray.length the_list
	val pos = Bits.andb(hash, size-1)
	val set = MLWorks.Internal.ExtendedArray.sub(the_list, pos)
      in
	member(elt, set)
      end

    fun fold f (base, ref(the_list, _)) =
      MLWorks.Internal.ExtendedArray.reducel
      (Lists.reducel (fn (acc, (_, x)) => f(acc, x)))
      (base, the_list)

    fun iterate f (ref(the_list, _)) =
      MLWorks.Internal.ExtendedArray.iterate
      (Lists.iterate (fn (_, x) => f x))
      the_list

    fun set_to_list s = fold (fn (L, e) => e :: L) ([], s)

    val add_list_to_set = Lists.reducel add_member

    val add_list = add_list_to_set

    fun list_to_set set = add_list_to_set(empty_set(length set div 2), set)

    fun union_lists([], _, acc) = acc
      | union_lists((z as (_, x)) :: xs, y, acc) =
	union_lists(xs, y, if member(x, y) then acc else z :: acc)

    fun unite_sets(ref(list, ref count), ref(list', _)) =
      let
	val count = ref count
      in
	resize
	(ref
	 (MLWorks.Internal.ExtendedArray.map_index
	  (fn (index, elem) =>
	   let
	     val old_list = MLWorks.Internal.ExtendedArray.sub(list, index)
	     val new_list = union_lists(old_list, elem, elem)
	   in
	     count := !count - length new_list + length old_list;
	     new_list
	   end)
	  list', count))
      end

    (* Think about resizing here *)

    fun union(arg as (a1 as ref(set1, _), a2 as ref(set2, _))) =
      let
	val l1 = MLWorks.Internal.ExtendedArray.length set1
	val l2 = MLWorks.Internal.ExtendedArray.length set2
      in
	if l1 = l2 then
	  unite_sets arg
	else
	  if l1 < l2 then
	    union(force_resize a1, a2)
	  else
	    union(a1, force_resize a2)
      end
	  
    fun intersect_lists([], list, acc) = acc
      | intersect_lists(list, [], acc) = acc
      | intersect_lists((z as (_, x)) :: xs, y, acc) =
	intersect_lists(xs, y, if member(x, y) then z :: acc else acc)

    fun intersect_sets(set1 as ref(list, ref count), ref(list', _)) =
      let
	val count = ref count
      in
	ref
	(MLWorks.Internal.ExtendedArray.map_index
	 (fn (index, elem) =>
	  let
	    val old_list = MLWorks.Internal.ExtendedArray.sub(list, index)
	    val new_list = intersect_lists(old_list, elem, [])
	  in
	    count := !count - length new_list + length old_list;
	    new_list
	  end)
	 list', count)
      end

    fun intersection(arg as (a1 as ref(set1, _), a2 as ref(set2, _))) =
      let
	val l1 = MLWorks.Internal.ExtendedArray.length set1
	val l2 = MLWorks.Internal.ExtendedArray.length set2
      in
	if l1 = l2 then
	  intersect_sets arg
	else
	  if l2 < l1 then
	    intersection(force_shrink a1, a2)
	  else
	    intersection(a1, force_shrink a2)
      end

    fun subset(ref(list, _), arg2 as ref(list', _)) =
      MLWorks.Internal.ExtendedArray.reducel
      (fn (false, _) => false
       | (_, list) => Lists.forall (fn (_, elt) => is_member(arg2, elt)) list)
      (true, list)

    fun list_diff([], _, acc) = acc
      | list_diff((z as (_, x)) :: xs, y, acc) =
	list_diff(xs, y, if member(x, y) then acc else z :: acc)

    fun diff_sets(ref(list, ref count), ref(list', _)) =
      let
	val count = ref count
      in
	ref
	(MLWorks.Internal.ExtendedArray.map_index
	 (fn (index, elem) =>
	  let
	    val old_list = MLWorks.Internal.ExtendedArray.sub(list, index)
	    val new_list = list_diff(old_list, elem, [])
	  in
	    count := !count - length new_list + length old_list;
	    new_list
	  end)
	 list', count)
      end

    fun setdiff(arg as (a1 as ref(set1, _), a2 as ref(set2, _))) =
      let
	val l1 = MLWorks.Internal.ExtendedArray.length set1
	val l2 = MLWorks.Internal.ExtendedArray.length set2
      in
	if l1 = l2 then
	  diff_sets arg
	else
	  if l1 < l2 then
	    setdiff(force_resize a1, a2)
	  else
	    setdiff(a1, force_resize a2)
      end

    fun seteq(arg as (set1, set2)) =
      subset(set1, set2) andalso
      set_size set1 = set_size set2

    fun set_print(hashset, printfun) =
      let
	val list = set_to_list hashset
	fun print_sub([], acc) = concat(rev acc)
	  | print_sub([x], acc) = concat(rev(printfun x :: acc))
	  | print_sub(x :: xs, acc) = print_sub(xs, "," :: printfun x :: acc)
      in
	print_sub(list, [])
      end

    fun rehash(set as ref(array, _)) =
      let
	val length = MLWorks.Internal.ExtendedArray.length array
	val new_array = MLWorks.Internal.ExtendedArray.array(length, [] : (int * element)list)
	val array_and_count =
	  (new_array, ref(max_size_ratio * length))
	val new_set = ref array_and_count
      in
	MLWorks.Internal.ExtendedArray.iterate
	(fn list =>
	 Lists.iterate (fn (_, element) => add_member'(new_set, element))
	 (list))
	array;
	set := array_and_count
      end
  end
@


1.19.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.19  1998/02/19  16:46:57  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.18
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d232 1
a232 1
    fun add_member(arg as (elts, _)) = (add_member' arg; elts)
@


1.18.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.5.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.18.5.1  1997/05/12  10:53:52  hope
 * branched from 1.18
 *
@


1.18.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.18.5.1  1997/05/12  10:53:52  hope
 * branched from 1.18
 *
@


1.18.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.18.5.1  1997/05/12  10:53:52  hope
 * branched from 1.18
 *
@


1.18.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.18.5.1.1.1  1997/07/28  18:35:29  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.18.4.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.3.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.3.1.1.1
log
@branched from 1.18.3.1
@
text
@a3 3
 * Revision 1.18.3.1  1996/12/17  18:20:14  hope
 * branched from 1.18
 *
@


1.18.2.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.1.1
log
@branched from 1.18
@
text
@a3 4
 * Revision 1.18  1996/11/06  10:53:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.18.1.1.1.1
log
@branched from 1.18.1.1
@
text
@a3 3
 * Revision 1.18.1.1  1996/11/14  13:24:11  hope
 * branched from 1.18
 *
@


1.17
log
@[Bug #1614]
basifying String
@
text
@d4 4
d64 1
a64 1
require "^.basis.__integer";
@


1.16
log
@Moving Bits to MLWorks.Internal
@
text
@d4 3
d60 1
a60 2
require "../basis/__integer";

d106 1
a106 1
	  (fn (sum, list) => sum + Lists.length list)
d113 1
a113 1
	  (String.implode["Strange hashset size not as expected\n",
d275 1
a275 1
    fun list_to_set set = add_list_to_set(empty_set(Lists.length set div 2), set)
d293 1
a293 1
	     count := !count - Lists.length new_list + Lists.length old_list;
d331 1
a331 1
	    count := !count - Lists.length new_list + Lists.length old_list;
d372 1
a372 1
	    count := !count - Lists.length new_list + Lists.length old_list;
d399 2
a400 2
	fun print_sub([], acc) = String.implode(rev acc)
	  | print_sub([x], acc) = String.implode(rev(printfun x :: acc))
@


1.16.3.1
log
@branched from 1.16
@
text
@a3 3
 * Revision 1.16  1996/05/17  09:18:31  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a3 3
 * Revision 1.16  1996/05/17  09:18:31  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a3 3
 * Revision 1.16  1996/05/17  09:18:31  matthew
 * Moving Bits to MLWorks.Internal
 *
@


1.15
log
@Array moving to MLWorks.Array
@
text
@d4 3
d73 3
d183 1
a183 1
	    if MLWorks.Bits.andb(hashvalue, size) = 0
@


1.14
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d72 1
a72 1
    type HashSet = ((int * element) list MLWorks.ExtendedArray.array * int ref) ref
d97 1
a97 1
	  MLWorks.ExtendedArray.reducel
d100 1
a100 1
	val c2 = MLWorks.ExtendedArray.length the_lists * max_size_ratio - count
d107 1
a107 1
		   Int.toString(MLWorks.ExtendedArray.length the_lists),
d125 1
a125 1
	  ref(MLWorks.ExtendedArray.array(initial_size, [] : (int * element) list),
d132 1
a132 1
	val old_size = MLWorks.ExtendedArray.length the_list
d139 1
a139 1
	val new_arr = MLWorks.ExtendedArray.array(new_size, [] : (int * element) list)
d150 2
a151 2
	       val f = MLWorks.ExtendedArray.sub(the_list, index)
	       val s = MLWorks.ExtendedArray.sub(the_list, index + new_size)
d153 1
a153 1
	       MLWorks.ExtendedArray.update(new_arr, index, f @@ s)
d166 1
a166 1
	val old_size = MLWorks.ExtendedArray.length the_list
d168 1
a168 1
	val new_arr = MLWorks.ExtendedArray.array(new_size, [] : (int * element) list)
d186 2
a187 2
	      MLWorks.ExtendedArray.update(new_arr, index, f);
	      MLWorks.ExtendedArray.update(new_arr, index + old_size, s)
d191 1
a191 1
	MLWorks.ExtendedArray.iterate_index deal_with_elements the_list;
d204 1
a204 1
	val old_size = MLWorks.ExtendedArray.length the_list
d206 1
a206 1
	val set = MLWorks.ExtendedArray.sub(the_list, pos)
d211 1
a211 1
	  (MLWorks.ExtendedArray.update(the_list, pos, (hash, elt) :: set);
d221 1
a221 1
	val size = MLWorks.ExtendedArray.length the_list
d223 1
a223 1
	val set = MLWorks.ExtendedArray.sub(the_list, pos)
d226 1
a226 1
	  (MLWorks.ExtendedArray.update(the_list, pos,
d235 1
a235 1
      MLWorks.ExtendedArray.reducel
d244 1
a244 1
	val size = MLWorks.ExtendedArray.length the_list
d246 1
a246 1
	val set = MLWorks.ExtendedArray.sub(the_list, pos)
d252 1
a252 1
      MLWorks.ExtendedArray.reducel
d257 1
a257 1
      MLWorks.ExtendedArray.iterate
d279 1
a279 1
	 (MLWorks.ExtendedArray.map_index
d282 1
a282 1
	     val old_list = MLWorks.ExtendedArray.sub(list, index)
d295 2
a296 2
	val l1 = MLWorks.ExtendedArray.length set1
	val l2 = MLWorks.ExtendedArray.length set2
d317 1
a317 1
	(MLWorks.ExtendedArray.map_index
d320 1
a320 1
	    val old_list = MLWorks.ExtendedArray.sub(list, index)
d331 2
a332 2
	val l1 = MLWorks.ExtendedArray.length set1
	val l2 = MLWorks.ExtendedArray.length set2
d344 1
a344 1
      MLWorks.ExtendedArray.reducel
d358 1
a358 1
	(MLWorks.ExtendedArray.map_index
d361 1
a361 1
	    val old_list = MLWorks.ExtendedArray.sub(list, index)
d372 2
a373 2
	val l1 = MLWorks.ExtendedArray.length set1
	val l2 = MLWorks.ExtendedArray.length set2
d400 2
a401 2
	val length = MLWorks.ExtendedArray.length array
	val new_array = MLWorks.ExtendedArray.array(length, [] : (int * element)list)
d406 1
a406 1
	MLWorks.ExtendedArray.iterate
@


1.13
log
@Integer changes
@
text
@d4 3
d99 1
a99 1
	  (implode["Strange hashset size not as expected\n",
d385 2
a386 2
	fun print_sub([], acc) = implode(rev acc)
	  | print_sub([x], acc) = implode(rev(printfun x :: acc))
@


1.12
log
@Added a rehash function to deal with sets where the hash value changes
due to update (eg Namesets)
@
text
@d4 4
d45 2
d98 1
a98 1
		   MLWorks.Integer.makestring(MLWorks.ExtendedArray.length the_lists),
d100 1
a100 1
		   MLWorks.Integer.makestring count,
d102 1
a102 1
		   MLWorks.Integer.makestring c1,
@


1.12.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.12  1993/05/20  12:48:37  jont
Added a rehash function to deal with sets where the hash value changes
due to update (eg Namesets)

@


1.11
log
@Removed integer parameter
@
text
@d4 3
d186 1
a186 1
    fun add_member(elts as ref(the_list, count as ref c), elt) =
d201 2
d383 15
@


1.10
log
@Modified to allow expansion and contraction of the hashset according to amount
of data.
@
text
@d4 4
a40 1
require "__integer";
a51 1
    structure Integer = Integer_
d89 1
a89 1
		   Integer.makestring(MLWorks.ExtendedArray.length the_lists),
d91 1
a91 1
		   Integer.makestring count,
d93 1
a93 1
		   Integer.makestring c1,
@


1.9
log
@Corrected references to ExtendedArray
@
text
@d4 3
d37 1
a46 1
  val size : int
d49 1
d52 2
a53 1
    type HashSet = element list MLWorks.ExtendedArray.array
d59 1
a59 1
      | member(elt, x :: xs) = eq(elt, x) orelse member(elt, xs)
d61 6
a66 2
    fun empty_set _ =
      MLWorks.ExtendedArray.array(size, [] : element list)
d68 7
a74 1
    fun add_member(elts, elt) =
d76 107
d184 3
a186 2
	val pos = hash mod size
	val set = MLWorks.ExtendedArray.sub(elts, pos)
d191 3
a193 2
	  (MLWorks.ExtendedArray.update(elts, pos, elt :: set);
	   elts)
d196 1
a196 1
    fun remove_member(elts, elt) =
d199 3
a201 2
	val pos = hash mod size
	val set = MLWorks.ExtendedArray.sub(elts, pos)
d204 3
a206 2
	  (MLWorks.ExtendedArray.update(elts, pos,
			Lists.filterp (fn x => not(eq(x, elt))) set);
d212 1
a212 1
    fun empty_setp elts =
d217 1
a217 1
      (true, elts)
d219 1
a219 1
    fun is_member(elts, elt) =
d222 3
a224 1
	val set = MLWorks.ExtendedArray.sub(elts, hash mod size)
d229 1
a229 1
    fun fold f (base, elts) =
d231 2
a232 2
      (Lists.reducel f)
      (base, elts)
d234 1
a234 1
    fun iterate f elts =
d236 2
a237 2
      (Lists.iterate f)
      elts
d239 1
a239 1
    fun set_to_list s = fold (fn (L,e) => e :: L) ([], s)
d245 1
a245 1
    fun list_to_set set = add_list_to_set(empty_set(), set)
d248 2
a249 2
    | union_lists(x :: xs, y, acc) =
      union_lists(xs, y, if member(x, y) then acc else x :: acc)
d251 17
a267 5
    fun unite_sets(elts, elts') =
      MLWorks.ExtendedArray.map_index
      (fn (index, elem) =>
       union_lists(MLWorks.ExtendedArray.sub(elts, index), elem, elem))
      elts'
d269 15
a283 1
    val union = unite_sets
d286 3
a288 3
    | intersect_lists(list, [], acc) = acc
    | intersect_lists(x :: xs, y, acc) =
      intersect_lists(xs, y, if member(x, y) then x :: acc else acc)
d290 16
a305 5
    fun intersect_sets(elts, elts') =
      MLWorks.ExtendedArray.map_index
      (fn (index, elem) =>
       intersect_lists(MLWorks.ExtendedArray.sub(elts, index), elem, []))
      elts'
d307 13
a319 1
    val intersection = intersect_sets
d321 5
a325 13
    fun subset(elts, elts') =
      (* This could be done better by comparing individual hash chains *)
      MLWorks.ExtendedArray.reducel_index
      (fn (_, false, _) => false
       | (index, _, elt) =>
	 let
	   val elt' = MLWorks.ExtendedArray.sub(elts', index)
	 in
	   Lists.forall
	   (fn mem => member(mem, elt'))
	   elt
	 end)
      (true, elts)
d328 2
a329 2
    | list_diff(x :: xs, y, acc) =
      list_diff(xs, y, if member(x, y) then acc else x :: acc)
d331 16
a346 5
    fun diff_sets(elts, elts') =
      MLWorks.ExtendedArray.map_index
      (fn (index, elem) =>
       list_diff(MLWorks.ExtendedArray.sub(elts, index), elem, []))
      elts'
d348 13
a360 1
    val setdiff = diff_sets
d362 3
a364 1
    val seteq = subset
@


1.8
log
@Chnaged references to Array to ExtendedArray, where appropriate.
@
text
@d4 3
d48 1
a48 1
    type HashSet = element list ExtendedArray.array
d57 1
a57 1
      ExtendedArray.array(size, [] : element list)
d63 1
a63 1
	val set = ExtendedArray.sub(elts, pos)
d68 1
a68 1
	  (ExtendedArray.update(elts, pos, elt :: set);
d76 1
a76 1
	val set = ExtendedArray.sub(elts, pos)
d79 1
a79 1
	  (ExtendedArray.update(elts, pos,
d96 1
a96 1
	val set = ExtendedArray.sub(elts, hash mod size)
d126 1
a126 1
       union_lists(ExtendedArray.sub(elts, index), elem, elem))
d139 1
a139 1
       intersect_lists(ExtendedArray.sub(elts, index), elem, []))
d150 1
a150 1
	   val elt' = ExtendedArray.sub(elts', index)
d165 1
a165 1
       list_diff(ExtendedArray.sub(elts, index), elem, []))
@


1.7
log
@Improved to avoid parameter recopying in numerous places
@
text
@d4 3
d45 1
a45 1
    type HashSet = element list Array.array
d54 1
a54 1
      Array.array(size, [] : element list)
d60 1
a60 1
	val set = Array.sub(elts, pos)
d65 1
a65 1
	  (Array.update(elts, pos, elt :: set);
d73 1
a73 1
	val set = Array.sub(elts, pos)
d76 1
a76 1
	  (Array.update(elts, pos,
d84 1
a84 1
      MLWorks.Array.reducel
d93 1
a93 1
	val set = Array.sub(elts, hash mod size)
d99 1
a99 1
      MLWorks.Array.reducel
d104 1
a104 1
      MLWorks.Array.iterate
d121 1
a121 1
      MLWorks.Array.map_index
d123 1
a123 1
       union_lists(Array.sub(elts, index), elem, elem))
d134 1
a134 1
      MLWorks.Array.map_index
d136 1
a136 1
       intersect_lists(Array.sub(elts, index), elem, []))
d143 1
a143 1
      MLWorks.Array.reducel_index
d147 1
a147 1
	   val elt' = Array.sub(elts', index)
d160 1
a160 1
      MLWorks.Array.map_index
d162 1
a162 1
       list_diff(Array.sub(elts, index), elem, []))
@


1.6
log
@Recoded using new array utilities
@
text
@d4 3
d53 1
a53 1
    fun add_member(elt, elts) =
d66 1
a66 1
    fun remove_member(elt, elts) =
d87 1
a87 1
    fun is_member(elt, elts) =
d107 1
a107 4
    fun add_list_to_set(list, set) =
      Lists.reducel
      (fn (set, elt) => add_member(elt, set))
      (set, list)
d111 1
a111 1
    fun list_to_set set = add_list_to_set(set, empty_set())
@


1.5
log
@Added iterate function.
@
text
@d4 3
d39 1
a39 2
    type HashSet =
      {count : int, elts: element list Array.array}
d48 1
a48 1
      {count=0, elts = Array.array(size, [] : element list)}
d50 1
a50 1
    fun add_member(elt, hashset as {count=count, elts=elts}) =
d57 1
a57 1
	  hashset
d60 1
a60 2
	   {count=count+1,
	    elts = elts})
d63 1
a63 30
    fun remove_member(elt, hashset as {count=count, elts=elts}) =
      if count = 0 then hashset
      else
	let
	  val hash = hash elt
	  val pos = hash mod size
	  val set = Array.sub(elts, pos)
	in
	  if member(elt, set) then
	    (Array.update(elts, pos,
			  Lists.filterp (fn x => not(eq(x, elt))) set);
	     {count=count-1, elts=elts}
	     )	      
	  else
	    hashset
      end

    fun empty_setp({count=count, ...} : HashSet) = count = 0

    fun is_member(elt, {count=count, elts=elts}) =
      if count = 0 then false
      else
	let
	  val hash = hash elt
	  val set = Array.sub(elts, hash mod size)
	in
	  member(elt, set)
	end

    fun fold f (base, {elts = elts, count = _}) =
d65 3
a67 3
	fun itr (pos, res) =
	  if pos >= size then res
	  else itr (pos+1, Lists.reducel f (res, Array.sub(elts, pos)))
d69 6
a74 1
	itr(0, base)
d77 8
a84 1
    fun iterate f {elts = elts, count = _} =
d86 2
a87 3
	fun itr pos =
	  if pos >= size then ()
	  else (Lists.iterate f (Array.sub(elts, pos)); itr (pos+1))
d89 1
a89 1
	itr 0
d92 10
d117 5
a121 12
    fun unite_sets(pos, elts, elts', new_set as {count=count, elts=elems}) =
      if pos >= size then new_set
      else
	let
	  val l = Array.sub(elts', pos)
	  val new_list =
	    union_lists(Array.sub(elts, pos), l, l)
	  val _ = Array.update(elems, pos, new_list)
	in
	  unite_sets(pos+1, elts, elts',
		     {count=count + Lists.length new_list, elts=elems})
	end
d123 1
a123 3
    fun union(hashset as {count=count, elts=elts},
	      hashset' as {count=count', elts=elts'}) =
      unite_sets(0, elts, elts', empty_set())
d130 5
a134 12
    fun intersect_sets(pos, elts, elts',
		       new_set as {count=count, elts=elems}) =
      if pos >= size then new_set
      else
	let
	  val new_list =
	    intersect_lists(Array.sub(elts, pos), Array.sub(elts', pos), [])
	  val _ = Array.update(elems, pos, new_list)
	in
	  intersect_sets(pos+1, elts, elts',
		     {count=count + Lists.length new_list, elts=elems})
	end
d136 1
a136 6
    fun intersection(hashset as {count=count, elts=elts},
		     hashset' as {count=count', elts=elts'}) =
      if count = 0 orelse count' = 0 then
	empty_set()
      else
	intersect_sets(0, elts, elts', empty_set())
d138 1
a138 2
    fun subset(hashset as {elts=elts, count=_},
	       hashset' as {elts=elts', count=_}) =
d140 11
a150 14
      let
	fun subset_sub pos =
	  pos >= size orelse
	  let
	    val l1 = Array.sub(elts, pos)
	    val l2 = Array.sub(elts', pos)
	  in
	    (Lists.forall (fn elt => member(elt, l2)) l1)
	    andalso
	    subset_sub(pos + 1)
	  end
      in
	subset_sub 0
      end
d156 5
a160 12
    fun diff_sets(pos, elts, elts', res as {count=count, elts=elems}) =
      if pos >= size then res
      else
	let
	  val new_list =
	    list_diff(Array.sub(elts, pos), Array.sub(elts', pos), [])
	  val _ = Array.update(elems, pos, new_list)
	in
	  diff_sets(pos+1, elts, elts',
		    {count=count + Lists.length new_list,
		     elts=elems})
	end
d162 1
a162 5
    fun setdiff({count=count, elts=elts}, {count=_, elts=elts'}) =
      if count = 0 then
	empty_set()
      else
	diff_sets(0, elts, elts', empty_set())
d164 1
a164 3
    fun seteq(hashset as {count=count, ...},
	      hashset' as {count=count', ...}) =
      count = count' andalso subset(hashset, hashset')
@


1.4
log
@Added fold function.
@
text
@d4 3
d93 3
a95 5
	fun itr (pos:int, res) =
	  if pos >= size then
	    res
	  else
	    itr (pos+1, Lists.reducel f (res, Array.sub(elts, pos)))
d98 9
@


1.3
log
@Removed unnecessary require
@
text
@d4 3
d88 10
a97 9
    fun add_members(pos:int, mems, elts) =
      if pos >= size then
	mems
      else
	let
	  val set = Array.sub(elts, pos)
	in
	  add_members(pos+1, set @@ mems, elts)
	end
d99 1
a99 2
    fun set_to_list{count=count, elts = elts} =
      add_members(0, [], elts)
@


1.2
log
@Removed array parameter, now uses pervasive one
@
text
@d4 3
a14 1
require "array";
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a17 1
  structure Array : ARRAY
@
