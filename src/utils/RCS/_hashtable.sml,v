head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.3
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.12.5.1.1.1.1
	MLWorks_workspace_97:1.14.2
	MLWorks_dt_wizard:1.14.1
	MLWorks_11c0_1997_09_09:1.12.5.1.1.1
	MLWorks_10r3:1.12.5.1.3
	MLWorks_10r2_551:1.12.5.1.2
	MLWorks_11:1.12.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.12.5.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.12.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.12.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.12.5
	MLWorks_BugFix_1997_04_24:1.12
	MLWorks_1_0_r2_Win32_1997_04_11:1.12
	MLWorks_1_0_r2_Unix_1997_04_04:1.12
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.12.3.1.1
	MLWorks_gui_1996_12_18:1.12.4
	MLWorks_1_0_Win32_1996_12_17:1.12.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.12.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.12.1.1
	MLWorks_1_0_Irix_1996_11_28:1.12.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.12.2
	MLWorks_1_0_Unix_1996_11_14:1.12.1
	MLWorks_Open_Beta2_1996_10_11:1.11.3
	MLWorks_License_dev:1.11.2
	MLWorks_1_open_beta_1996_09_13:1.11.1
	MLWorks_Open_Beta_1996_08_22:1.11
	MLWorks_Beta_1996_07_02:1.11
	MLWorks_Beta_1996_06_07:1.11
	MLWorks_Beta_1996_06_06:1.11
	MLWorks_Beta_1996_06_05:1.11
	MLWorks_Beta_1996_06_03:1.11
	MLWorks_Beta_1996_05_31:1.11
	MLWorks_Beta_1996_05_30:1.11
	ML_final_beta_release_02/03/94:1.6
	mlworks-28-01-1994:1.6
	Release:1.6
	mlworks-beta-01-09-1993:1.6
	MLWorks-1-0-4-29/01/1993:1.6
	MLWorks-1-0-3-21/12/1992:1.6
	MLWorks-1-0-2-15/12/1992:1.6
	MLWorks-1-0-1-04/12/1992:1.6
	checkpoint_17_08_92:1.6
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ *  @;


1.14
date	97.05.19.13.10.22;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	97.05.01.13.20.35;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.11.06.10.53.27;	author matthew;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1
	1.12.5.1;
next	1.11;

1.11
date	96.05.16.16.35.46;	author matthew;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1;
next	1.10;

1.10
date	96.05.07.10.40.02;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.04.30.17.45.27;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.04.29.15.07.22;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	96.02.26.12.05.54;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.13.16.11.18;	author davidt;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	92.07.08.11.51.03;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	92.04.23.09.07.31;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.02.03.09.57.27;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	91.11.21.17.01.11;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.15.56.47;	author colin;	state Exp;
branches;
next	;

1.6.1.1
date	92.08.13.16.11.18;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	96.09.13.11.43.29;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.10.07.16.36.42;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.10.17.11.55.42;	author hope;	state Exp;
branches;
next	;

1.12.1.1
date	96.11.14.13.24.03;	author hope;	state Exp;
branches
	1.12.1.1.1.1;
next	;

1.12.1.1.1.1
date	96.11.28.15.34.42;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.11.22.18.41.09;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.12.17.18.20.06;	author hope;	state Exp;
branches
	1.12.3.1.1.1;
next	;

1.12.3.1.1.1
date	97.02.24.12.14.33;	author hope;	state Exp;
branches;
next	;

1.12.4.1
date	96.12.18.10.15.36;	author hope;	state Exp;
branches;
next	;

1.12.5.1
date	97.05.12.10.53.47;	author hope;	state Exp;
branches
	1.12.5.1.1.1
	1.12.5.1.2.1
	1.12.5.1.3.1;
next	;

1.12.5.1.1.1
date	97.07.28.18.35.23;	author daveb;	state Exp;
branches
	1.12.5.1.1.1.1.1;
next	;

1.12.5.1.1.1.1.1
date	97.10.07.12.00.59;	author jkbrook;	state Exp;
branches;
next	;

1.12.5.1.2.1
date	97.09.08.17.28.01;	author daveb;	state Exp;
branches;
next	;

1.12.5.1.3.1
date	97.09.09.14.25.25;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.09.10.19.43.59;	author brucem;	state Exp;
branches;
next	;

1.14.2.1
date	97.09.11.21.11.24;	author daveb;	state Exp;
branches;
next	;

1.14.3.1
date	99.04.01.18.09.29;	author daveb;	state Exp;
branches;
next	;


desc
@SML hashtables
@


1.14
log
@[Bug #30090]
Translate output std_out to print
@
text
@(* _newhashtable.sml the functor *)
(*
$Log: _hashtable.sml,v $
 *  Revision 1.13  1997/05/01  13:20:35  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.11  1996/05/16  16:35:46  matthew
 *  Bits becomes MLWorks.Internal.Bits
 *
 *  Revision 1.10  1996/05/07  10:40:02  jont
 *  Array moving to MLWorks.Array
 *
 *  Revision 1.9  1996/04/30  17:45:27  jont
 *  String functions explode, implode, chr and ord now only available from String
 *  io functions and types
 *  instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 *  now only available from MLWorks.IO
 *
 *  Revision 1.8  1996/04/29  15:07:22  matthew
 *  Integer changes
 *
 *  Revision 1.7  1996/02/26  12:05:54  jont
 *  new unit
 *  Renamed from newhashtable
 *
Revision 1.15  1994/09/07  11:51:50  matthew
Use MLWorks.Integer.makestring

Revision 1.14  1993/11/01  14:39:54  nickh
Fixed bugs in map() and copy(), which previously returned empty hash tables.

Revision 1.13  1993/02/25  13:43:19  jont
Fixed a bug in the resizing code which allowed more to be placed in the
new table than it should

Revision 1.12  1992/09/22  09:08:30  clive
Changed hashtables to a single structure implementation

Revision 1.11  1992/09/16  14:08:37  clive
Added tryLookup

Revision 1.10  1992/09/14  14:20:21  jont
Added a lookup_default function to assign a default value when the
key is not found

Revision 1.9  1992/08/26  14:56:11  richard
Changed MLWorks.Bits to Bits to improve performance under
New Jersey.

Revision 1.8  1992/08/21  09:00:59  clive
Don't recalculate hash function on resize

Revision 1.7  1992/08/13  16:47:41  davidt
Added fold and iterate functions.

Revision 1.6  1992/08/10  16:51:20  davidt
Changed MLworks to MLWorks.

Revision 1.5  1992/08/07  16:05:13  davidt
Now uses MLworks structure instead of NewJersey structure.

Revision 1.4  1992/07/28  09:53:20  clive
Added some functionality including the printing of statistics, and resizing

Revision 1.3  1992/07/16  17:28:16  jont
Removed count from tables. Allows better imperative use

Revision 1.2  1992/07/16  16:23:25  jont
Removed array parameter, now uses pervasive one

Revision 1.1  1992/07/16  11:21:17  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../basis/__int";

require "hashtable";
require "crash";
require "lists";

(* A hash table with more than one table *)

functor HashTable(
  structure Crash : CRASH
  structure Lists : LISTS
 ) : HASHTABLE =
  struct

    structure Bits = MLWorks.Internal.Bits

    type HashValue = int
    type ('Key,'Value) HashTable = (('Key * HashValue * 'Value ref) list MLWorks.Internal.Array.array 
                                    * int ref
                                    * ('Key * 'Key -> bool) 
                                    * ('Key -> int)) ref

    val print_debug = false

    (* This expansion ratio of 2 is used to maintain the fact that the tables
     are a power of two in size. This means we may use bitwise operations to go from
     hash value to table index, and can do the resize operation much more
     quickly - if this is changed, some of the other functions need to be re-written *)

    val expansion_ratio = 2 (* factor to increase by on re-size - if this is changed from 2, adjust
                             partitioning part of the re-sizing code in update *)
    val max_size_ratio = 4  (* resize when number of elements is this multiplied by the size *)

    exception Lookup 

    local
      fun nearest_power_of_two (size,x) =
        if x >= size
          then x
        else nearest_power_of_two (size,2*x)
    in
      fun new (size,eq,hash) =
        let
          val initial_size = nearest_power_of_two(size,1)
        in
          ref(MLWorks.Internal.Array.array(initial_size, []),
              ref(max_size_ratio * initial_size),
              eq,
              hash)
        end
    end

    fun assoc(eq,key, []) = raise Lookup
      | assoc(eq,key, (k, _, v) :: xs) =
	if eq(key, k) then v else assoc(eq,key, xs)

    fun lookup(ref (elt_array,_,eq,hash), key) =
      let
	val hash = hash key
	val len = MLWorks.Internal.Array.length elt_array
	val list_map = MLWorks.Internal.Array.sub(elt_array, Bits.andb(hash,len-1))
      in
	!(assoc(eq,key, list_map))
      end

    fun assoc_default(eq,_, []) = NONE
      | assoc_default(eq, key, (k, _, ref v) :: xs) =
	if eq(key, k) 
          then SOME v
        else assoc_default(eq,key, xs)

    fun tryLookup(ref (elt_array,_,eq,hash),key) =
      let
	val hash = hash key
	val len = MLWorks.Internal.Array.length elt_array
	val list_map = MLWorks.Internal.Array.sub(elt_array, Bits.andb(hash,len-1))
      in
        assoc_default(eq,key,list_map)
      end

    fun lookup_default (table,value,key) =
      case tryLookup (table,key) of
        SOME res => res
      | _ => value

    fun iterate_hash f (arr,_,_,_) =
      let
        fun down x =
          if x < 0 then ()
          else (Lists.iterate (fn (k, v', ref v) => f(k,v',v)) (MLWorks.Internal.Array.sub(arr,x)); down (x-1))
      in
        down (MLWorks.Internal.Array.length arr - 1)
      end

    fun iterate f (ref h) = iterate_hash (fn (x,_,y) => f(x,y)) h

    fun fold f (res, ref (arr,_,_,_)) =
      let
        fun down (res, x) =
          if x < 0 then
	    res
          else
	    down(Lists.reducel (fn (res, (k, _, ref v)) => f(res, k, v)) (res, MLWorks.Internal.Array.sub(arr,x)), x-1)
      in
        down (res, MLWorks.Internal.Array.length arr - 1)
      end

    val makestring = Int.toString

    fun assoc_default'(eq,_, []) = NONE
      | assoc_default'(eq,key, (k, _, v) :: xs) =
	if eq(key, k) 
          then SOME v
        else assoc_default'(eq,key, xs)

    fun update(initial as ref (elt_array,count_down as ref c,eq,hash_fn), key, value) =
      let
	val hash = hash_fn key
	val old_size = MLWorks.Internal.Array.length elt_array
	val pos = Bits.andb(hash,old_size - 1)
	val list_map = MLWorks.Internal.Array.sub(elt_array, pos)
        val assoced = assoc_default'(eq,key, list_map)
      in
        (case assoced of
           SOME r => r := value 
         | NONE => 
             (if c <= 0
                then 
                  let
                    val _ = if print_debug then
		      print("Resizing " ^ makestring(old_size) ^ "...\n")
                            else ()
                    val new_size = old_size * expansion_ratio
                    val new_arr = MLWorks.Internal.Array.array(new_size, [])
                    val _ = initial := (new_arr,ref(max_size_ratio * (new_size - old_size) + c - 1),eq,hash_fn)
		    (* Since the expansion size is two, we can calculate the new position  *)
		    (* of the elements from the old positions very easily *)
		    fun partition([],size,f,s) = (f,s)
		      | partition((elem as (_,hashvalue,_))::rest,size,f,s) =
			if Bits.andb(hashvalue,size) = 0
			  then partition(rest,size,elem::f,s)
			else partition(rest,size,f,elem::s)

                    fun deal_with_elements index = 
                      if index < 0
                        then ()
                      else
                        let
                          val elems = MLWorks.Internal.Array.sub(elt_array,index)
                       in
                         case elems of
                           [] => deal_with_elements (index-1)
                         | _ =>
                             let
                               val (f,s) =
                                 partition(elems,old_size,[],[])
                             in
                               MLWorks.Internal.Array.update(new_arr,index,f);
                               MLWorks.Internal.Array.update(new_arr,index + old_size,s);
                               deal_with_elements (index-1)
                             end
                       end
                 in
                   deal_with_elements (old_size-1);
                   let
                     val new_pos = Bits.andb(hash,new_size - 1)                     
                     val old_value = MLWorks.Internal.Array.sub(new_arr, new_pos)
                   in 
                     MLWorks.Internal.Array.update(new_arr, new_pos, (key, hash,ref value)::old_value)
                   end
                 end
             else (count_down := c - 1;
                   MLWorks.Internal.Array.update(elt_array, pos, (key, hash,ref value) :: list_map))))
      end

    fun delete_from_list(eq,key, [], acc) = (acc, false)
      | delete_from_list(eq,key, (elt as (k, _, _)) :: rest, acc) =
	if eq(key, k) then
	  (acc @@ rest, true)
	else
	  delete_from_list(eq,key, rest, elt :: acc)

    fun delete(ref (elt_array,count_down,eq,hash), key) =
      let
	val hash = hash key
	val len = MLWorks.Internal.Array.length elt_array
	val pos = Bits.andb(hash,len-1)
	val list_map = MLWorks.Internal.Array.sub(elt_array, pos)
	val (list_map, found) = delete_from_list(eq,key, list_map, [])
        val _ = count_down := !count_down + 1
      in
	MLWorks.Internal.Array.update(elt_array, pos, list_map)
      end

    fun check_nil(array, curr, max) =
      if curr >= max then true
      else
	case MLWorks.Internal.Array.sub(array, curr) of
	  [] => check_nil(array, curr + 1, max)
	| _ => false

    fun empty_setp(ref (elt_array,_)) =
      check_nil(elt_array, 0, MLWorks.Internal.Array.length elt_array)

    fun add_members(pos:int, max, mems, elts) =
      if pos >= max then
	mems
      else
	let
	  val set = map (fn (x,_,ref y) => (x,y)) (MLWorks.Internal.Array.sub(elts, pos))
	in
	  add_members(pos+1, max, set @@ mems, elts)
	end

    fun to_list(ref (elt_array,_,_,_)) =
      add_members(0, MLWorks.Internal.Array.length elt_array, [], elt_array)

    (* have to copy each entry because it's all ref cells *)

    fun copy_list (acc,[]) = acc (* reversal doesn't matter *)
      | copy_list (acc,(k,h,ref v)::xs) =
      copy_list ((k,h,ref v)::acc,xs)

    fun copy_array(old_array, new_array, max, curr) =
      if curr >= max then new_array
      else
	let
	  val this = MLWorks.Internal.Array.sub(old_array, curr)
	  val _ = MLWorks.Internal.Array.update(new_array, curr, copy_list ([],this))
	in
	  copy_array(old_array, new_array, max, curr+1)
	end

    fun copy(ref (elt_array,count_down,eq,hash)) =
      let
	val len = MLWorks.Internal.Array.length elt_array
	val new_array = MLWorks.Internal.Array.array(len, [])
	val _ = copy_array(elt_array, new_array, len, 0)
      in
	ref (new_array,ref(!count_down),eq,hash)
      end

    fun map f (ref(table as (elt_array,count_down,eq,hash))) =
      let
        val new_table = new(MLWorks.Internal.Array.length elt_array,eq,hash)
      in
        iterate_hash (fn (x,_,y) => update(new_table,x,f (x,y))) table;
        new_table
      end

    fun stats(ref (arr,_,_,_)) = 
      let
        val len = MLWorks.Internal.Array.length(arr)
        val largest = ref(0)
        val smallest = ref(if len >0
                             then Lists.length(MLWorks.Internal.Array.sub(arr,0))
                           else 0)
        val count = ref(0)

        fun walk_buckets x =
          if x<0
            then ()
          else
            let
              val length = Lists.length(MLWorks.Internal.Array.sub(arr,x))
              val _ = if length > !largest 
                        then largest := length
                      else ()
              val _ = if length < !smallest
                        then smallest := length
                      else ()
            in
              (count := !count + length;
               walk_buckets(x-1))
            end

        val _ = walk_buckets (len - 1)
      in
        {size = len,
         smallest = !smallest,
         largest = ! largest,
         count = ! count}
      end

    fun string_hash_table_stats(table) =
      let
        val {size : int ,count : int ,smallest : int ,largest : int} = stats table
      in
        if count>0 then
          (" statistics: "^
           "size = "^(makestring size)^
           " count = "^(makestring count)^
           "\n                              smallest = "^
           (makestring smallest)^
           " largest = "^(makestring largest))
        else " EMPTY"
      end
        

  end
@


1.14.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 *  Revision 1.14  1997/05/19  13:10:22  jont
 *  [Bug #30090]
 *  Translate output std_out to print
 *
@


1.14.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 *  Revision 1.14  1997/05/19  13:10:22  jont
 *  [Bug #30090]
 *  Translate output std_out to print
 *
@


1.14.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 *  Revision 1.14  1997/05/19  13:10:22  jont
 *  [Bug #30090]
 *  Translate output std_out to print
 *
@


1.13
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d211 2
a212 2
                    val _ = if print_debug 
                              then MLWorks.IO.output(MLWorks.IO.std_out,"Resizing " ^ makestring(old_size) ^ "...\n")
@


1.12
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d143 1
a143 1
    fun assoc_default(eq,_, []) = MLWorks.Option.NONE
d146 1
a146 1
          then MLWorks.Option.SOME v
d160 1
a160 1
        MLWorks.Option.SOME res => res
d187 1
a187 1
    fun assoc_default'(eq,_, []) = MLWorks.Option.NONE
d190 1
a190 1
          then MLWorks.Option.SOME v
d202 2
a203 2
           MLWorks.Option.SOME r => r := value 
         | MLWorks.Option.NONE => 
@


1.12.5.1
log
@branched from 1.12
@
text
@a3 4
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.12.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 *  Revision 1.12.5.1  1997/05/12  10:53:47  hope
 *  branched from 1.12
 *
@


1.12.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 *  Revision 1.12.5.1  1997/05/12  10:53:47  hope
 *  branched from 1.12
 *
@


1.12.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 *  Revision 1.12.5.1  1997/05/12  10:53:47  hope
 *  branched from 1.12
 *
@


1.12.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 *  Revision 1.12.5.1.1.1  1997/07/28  18:35:23  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.12.4.1
log
@branched from 1.12
@
text
@a3 4
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.12.3.1
log
@branched from 1.12
@
text
@a3 4
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.12.3.1.1.1
log
@branched from 1.12.3.1
@
text
@a3 3
 *  Revision 1.12.3.1  1996/12/17  18:20:06  hope
 *  branched from 1.12
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a3 4
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a3 4
 *  Revision 1.12  1996/11/06  10:53:27  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.12.1.1.1.1
log
@branched from 1.12.1.1
@
text
@a3 3
 *  Revision 1.12.1.1  1996/11/14  13:24:03  hope
 *  branched from 1.12
 *
@


1.11
log
@Bits becomes MLWorks.Internal.Bits
@
text
@d4 3
d74 1
a74 1
require "../basis/__integer";
@


1.11.3.1
log
@branched from 1.11
@
text
@a3 3
 *  Revision 1.11  1996/05/16  16:35:46  matthew
 *  Bits becomes MLWorks.Internal.Bits
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a3 3
 *  Revision 1.11  1996/05/16  16:35:46  matthew
 *  Bits becomes MLWorks.Internal.Bits
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a3 3
 *  Revision 1.11  1996/05/16  16:35:46  matthew
 *  Bits becomes MLWorks.Internal.Bits
 *
@


1.10
log
@Array moving to MLWorks.Array
@
text
@d4 3
d85 2
d210 1
a210 1
			if MLWorks.Bits.andb(hashvalue,size) = 0
@


1.9
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d83 1
a83 1
    type ('Key,'Value) HashTable = (('Key * HashValue * 'Value ref) list Array.array 
d111 1
a111 1
          ref(Array.array(initial_size, []),
d125 2
a126 2
	val len = Array.length elt_array
	val list_map = Array.sub(elt_array, Bits.andb(hash,len-1))
d140 2
a141 2
	val len = Array.length elt_array
	val list_map = Array.sub(elt_array, Bits.andb(hash,len-1))
d155 1
a155 1
          else (Lists.iterate (fn (k, v', ref v) => f(k,v',v)) (Array.sub(arr,x)); down (x-1))
d157 1
a157 1
        down (Array.length arr - 1)
d168 1
a168 1
	    down(Lists.reducel (fn (res, (k, _, ref v)) => f(res, k, v)) (res, Array.sub(arr,x)), x-1)
d170 1
a170 1
        down (res, Array.length arr - 1)
d184 1
a184 1
	val old_size = Array.length elt_array
d186 1
a186 1
	val list_map = Array.sub(elt_array, pos)
d199 1
a199 1
                    val new_arr = Array.array(new_size, [])
d214 1
a214 1
                          val elems = Array.sub(elt_array,index)
d223 2
a224 2
                               Array.update(new_arr,index,f);
                               Array.update(new_arr,index + old_size,s);
d232 1
a232 1
                     val old_value = Array.sub(new_arr, new_pos)
d234 1
a234 1
                     Array.update(new_arr, new_pos, (key, hash,ref value)::old_value)
d238 1
a238 1
                   Array.update(elt_array, pos, (key, hash,ref value) :: list_map))))
d251 1
a251 1
	val len = Array.length elt_array
d253 1
a253 1
	val list_map = Array.sub(elt_array, pos)
d257 1
a257 1
	Array.update(elt_array, pos, list_map)
d263 1
a263 1
	case Array.sub(array, curr) of
d268 1
a268 1
      check_nil(elt_array, 0, Array.length elt_array)
d275 1
a275 1
	  val set = map (fn (x,_,ref y) => (x,y)) (Array.sub(elts, pos))
d281 1
a281 1
      add_members(0, Array.length elt_array, [], elt_array)
d293 2
a294 2
	  val this = Array.sub(old_array, curr)
	  val _ = Array.update(new_array, curr, copy_list ([],this))
d301 2
a302 2
	val len = Array.length elt_array
	val new_array = Array.array(len, [])
d310 1
a310 1
        val new_table = new(Array.length elt_array,eq,hash)
d318 1
a318 1
        val len = Array.length(arr)
d321 1
a321 1
                             then Lists.length(Array.sub(arr,0))
d330 1
a330 1
              val length = Lists.length(Array.sub(arr,x))
@


1.8
log
@Integer changes
@
text
@d4 3
d190 1
a190 1
                              then output(std_out,"Resizing " ^ makestring(old_size) ^ "...\n")
@


1.7
log
@new unit
Renamed from newhashtable
@
text
@d3 5
a7 1
$Log: _newhashtable.sml,v $
d59 2
d164 1
a164 1
    val makestring = MLWorks.Integer.makestring
@


1.6
log
@NO LONGER IN USE. Commented out code so that a parse
error is generated if the file is used.
@
text
@d1 1
a1 1
(* _hashtable.sml the functor *)
d3 3
a5 12
$Log: _hashtable.sml,v $
Revision 1.5  1992/07/08  11:51:03  davida
Changed clear function to declare a new array
with the initial size, instead of clearing out
the old one.

Revision 1.4  1992/04/23  09:07:31  clive
Added largest row details returned from the statistics function

Revision 1.3  1992/02/03  09:57:27  clive
There were references to min,max and length that were assumed free (our Compiler
would not compile this file)
d7 2
a8 2
Revision 1.2  1991/11/21  17:01:11  jont
Added copyright message
d10 3
a12 2
Revision 1.1  91/06/07  15:56:47  colin
Initial revision
d14 2
a15 2
Copyright (c) 1991 Harlequin Ltd.
*)
d17 2
a18 1
(*require "hashtable";*)
d20 3
a22 2
functor HashTable (*(Spec : HASHSPEC) : HASHTABLE  =
  struct
d24 3
a26 3
    type Key = Spec.Key
    type Value = Spec.Value
    exception Lookup of Key
d28 2
a29 20
    local
      (* Note that prime assumes that n is odd and greater than 4 *)

      fun prime n =
	let
	  fun prime' divisor =
	    let 
	      val quotient = n div divisor
	    in
	      if quotient < divisor then
		true
	      else
		if divisor * quotient = n then
		  false
		else
		  prime' (divisor+2)
	    end
	in
	  prime' 3
	end
d31 2
a32 2
      fun make_prime' n =
	if prime n then n else make_prime' (n+2)
d34 2
a35 2
      fun make_prime n =
	make_prime' (if (n mod 2) = 0 then n+1 else n)
d37 2
a38 6
      val initial_size = 
	make_prime
	(if Spec.size < 31 then
	   31
	 else
	   Spec.size)
d40 2
a41 1
      type Table = (int ref * int ref * (Key * Value ref) list Array.array ref)
d43 2
a44 2
      val table : Table = 
	(ref initial_size,ref 0, ref (Array.array (initial_size,nil)))
d46 2
a47 1
    in
d49 2
a50 4
(* old version:
      fun clear () = 
	let
	  val (ref size, countref, ref vector) = table
d52 1
a52 6
	  fun iterate n = 
	    (Array.update (vector,n,nil); iterate (n+1)) handle Array.Subscript => ()
	in
	  (iterate 0;
	   countref := 0)
	end
d55 11
a65 8
      fun clear () = 
	let
	  val (sizeref,countref,vectorref) = table
	in 
	  (sizeref := initial_size;
	   countref := 0;
	   vectorref := Array.array (initial_size,nil))
	end
d67 16
a82 15
      fun lookup' (key,table) =
	let 
	  val (ref size,_,ref vector) = table
	  val n = Spec.hash key mod size
	  val bucket = Array.sub (vector,n)

	  fun search nil = raise Lookup key
	    | search ((k,vref)::rest) =
	      if Spec.eq (k,key) then
		!vref
	      else
		search rest
	in
	  search bucket
	end
d84 1
a84 1
      fun lookup key = lookup' (key,table)
d86 16
a101 23
      fun update' ((pair as (key,value)),table) =
	let 
	  val (ref size, countref as (ref count), ref vector) = table
	in
	  if count >= size then
	    (rehash (); update' (pair,table))
	  else
	    let 
	      val n = Spec.hash key mod size
	      val bucket = Array.sub (vector,n)

	      fun search nil =
		(Array.update (vector,n,(key,ref value)::bucket);
		 countref := count + 1)
		| search ((k,vref)::rest) =
		  if Spec.eq (k,key) then
		    vref := value
		  else
		    search rest
	    in
	      search bucket
	    end
	end
d103 156
a258 1
      and rehash () =
d260 1
a260 20
	  val (sizeref as (ref size),countref,vectorref as (ref vector)) =
	    table
	  val new_size = make_prime (size + size);
	  val new_vector = Array.array (new_size,nil)
	  val new_countref = ref 0
	  val new_table : Table = 
	    (ref new_size,new_countref,ref new_vector)
	    
	  fun scan 0 = ()
	    | scan n = 
	      let 
		val n' = n-1
		val _ = 
		  map
		  (fn (key,ref value) => update' ((key,value),new_table))
		  (Array.sub (vector,n'))
	      in
		scan n'
	      end
	  val _ = scan size
d262 1
a262 3
	  (sizeref := new_size;
	   vectorref := new_vector;
	   countref := !new_countref)
d265 4
a268 1
      fun update pair = update' (pair,table)
d270 7
a276 1
      fun stats () =
d278 2
a279 28
	  val (ref size,ref count,ref vector) = table
	  val smallest = ref 1000000
	  val largest = ref 0
	  val used = ref 0

	  fun scan (0,x) = x
	    | scan (n,largest_row_contents) = 
	      let 
                fun length ([]) = 0
                  | length (_::t) = let
                      fun length' (acc,[]) = acc
                        | length' (acc,_::t) = length'(1+acc,t)
                    in
                      length'(1,t)
                    end
		val n' = n-1
		val m = length (Array.sub (vector,n'))
                fun max (m:int,n) = if m >= n then m else n
                fun min (m:int,n) = if m <= n then m else n
	      in
		(smallest := min (m,!smallest);
		 largest := max (m,!largest);
		 if m = 0 then () else used := !used + 1;
		 scan (n',if m = !largest then Array.sub(vector,n') else largest_row_contents))
	      end
	  val largest_row_contents = scan (size,[])
          fun row_to_list [] = []
            | row_to_list ((a,ref b) :: rest) = (a,b)::row_to_list rest
d281 1
a281 2
	  {count = count,size = size,smallest = !smallest,largest = !largest,
	   used = !used,largest_row_contents = row_to_list largest_row_contents}
d284 66
a349 1
    end
a350 1
*)
@


1.6.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.6  1992/08/13  16:11:18  davidt
NO LONGER IN USE. Commented out code so that a parse
error is generated if the file is used.

@


1.5
log
@Changed clear function to declare a new array
with the initial size, instead of clearing out
the old one.
@
text
@d4 5
d24 2
a25 1
require "hashtable";
d27 1
a27 1
functor HashTable (Spec : HASHSPEC) : HASHTABLE  =
d206 1
@


1.4
log
@Added largest row details returned from the statistics function
@
text
@d4 3
d68 2
d74 2
a75 8
	  fun iterate 0 = ()
	    | iterate n = 
	      let 
		val n' = n-1
		val _ = Array.update (vector,n',nil)
	      in
		iterate n'
	      end
d77 1
a77 1
	  (iterate size;
d79 10
@


1.3
log
@There were references to min,max and length that were assumed free (our Compiler
would not compile this file)
@
text
@d4 4
d160 3
a162 3
	    
	  fun scan 0 = ()
	    | scan n = 
d179 1
a179 1
		 scan n')
d181 3
a183 1
	  val _ = scan size
d186 1
a186 1
	   used = !used}
@


1.2
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	_hashtable.sml,v $
d160 7
d169 2
@


1.1
log
@Initial revision
@
text
@d1 1
d3 5
a7 1
$Log$
@
