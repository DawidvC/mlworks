head	1.28;
access;
symbols
	MLW_daveb_inline_1_4_99:1.28.1
	MLWorks_21c0_1999_03_25:1.28
	MLWorks_20c1_1998_08_20:1.27
	MLWorks_20c0_1998_08_04:1.27
	MLWorks_20b2c2_1998_06_19:1.27
	MLWorks_20b2_Windows_1998_06_12:1.27
	MLWorks_20b1c1_1998_05_07:1.27
	MLWorks_20b0_1998_04_07:1.27
	MLWorks_20b0_1998_03_20:1.27
	MLWorks_20m2_1998_02_16:1.27
	MLWorks_20m1_1997_10_23:1.26
	MLWorks_11r1:1.26.1.1.1.1.1
	MLWorks_workspace_97:1.26.3
	MLWorks_dt_wizard:1.26.2
	MLWorks_11c0_1997_09_09:1.26.1.1.1.1
	MLWorks_10r3:1.26.1.1.3
	MLWorks_10r2_551:1.26.1.1.2
	MLWorks_11:1.26.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.1.1
	MLWorks_20m0_1997_06_20:1.26
	MLWorks_1_0_r2c2_1997_06_14:1.26.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.26.1
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.3.1.1
	MLWorks_gui_1996_12_18:1.24.4
	MLWorks_1_0_Win32_1996_12_17:1.24.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.1.1
	MLWorks_1_0_Irix_1996_11_28:1.24.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.2
	MLWorks_1_0_Unix_1996_11_14:1.24.1
	MLWorks_Open_Beta2_1996_10_11:1.23.3
	MLWorks_License_dev:1.23.2
	MLWorks_1_open_beta_1996_09_13:1.23.1
	MLWorks_Open_Beta_1996_08_22:1.23
	MLWorks_Beta_1996_07_02:1.23
	MLWorks_Beta_1996_06_07:1.23
	MLWorks_Beta_1996_06_06:1.23
	MLWorks_Beta_1996_06_05:1.23
	MLWorks_Beta_1996_06_03:1.23
	MLWorks_Beta_1996_05_31:1.23
	MLWorks_Beta_1996_05_30:1.23
	ML_beta_release_12/08/94:1.7
	ML_beta_release_03/08/94:1.7
	ML_revised_beta_release_25/05/94:1.7
	ML_final_beta_release_02/03/94:1.7
	mlworks-28-01-1994:1.7
	Release:1.7
	mlworks-beta-01-09-1993:1.7
	MLWorks-1-0-4-29/01/1993:1.6
	MLWorks-1-0-3-21/12/1992:1.6
	MLWorks-1-0-2-15/12/1992:1.6
	MLWorks-1-0-1-04/12/1992:1.6
	checkpoint_17_08_92:1.6
	Ten15_release_19-11-91:1.1
	Ten15_release_21-08-91:1.1;
locks; strict;
comment	@ * @;


1.28
date	99.02.02.16.02.02;	author mitchell;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	98.02.02.10.07.00;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	97.01.14.17.49.19;	author io;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	97.01.06.14.45.45;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.10.28.15.05.31;	author io;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1;
next	1.23;

1.23
date	96.04.30.16.21.18;	author jont;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1;
next	1.22;

1.22
date	96.04.19.11.07.50;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.02.06.16.46.43;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	96.01.04.12.57.09;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.09.19.14.11.44;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.09.15.14.55.02;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	95.08.24.14.15.53;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	95.08.15.12.17.50;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.08.15.11.57.47;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.08.14.14.55.34;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.07.27.14.57.09;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.07.27.12.17.47;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	95.07.26.13.56.57;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.07.25.11.38.18;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.07.17.16.49.21;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	95.07.17.14.42.35;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	93.07.20.11.44.53;	author jont;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	92.03.27.11.20.52;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.02.20.10.15.52;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	91.11.21.17.00.19;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.22.15.02.53;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.08.30.15.24.22;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.08.19.18.24.33;	author davida;	state Exp;
branches;
next	;

1.7.1.1
date	93.07.20.11.44.53;	author jont;	state Exp;
branches;
next	;

1.23.1.1
date	96.09.13.11.43.23;	author hope;	state Exp;
branches;
next	;

1.23.2.1
date	96.10.07.16.36.35;	author hope;	state Exp;
branches;
next	;

1.23.3.1
date	96.10.17.11.55.36;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	96.11.14.13.23.57;	author hope;	state Exp;
branches
	1.24.1.1.1.1;
next	;

1.24.1.1.1.1
date	96.11.28.15.34.35;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.11.22.18.41.03;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.12.17.18.20.00;	author hope;	state Exp;
branches
	1.24.3.1.1.1;
next	;

1.24.3.1.1.1
date	97.02.24.12.14.26;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.12.18.10.15.30;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	97.05.12.10.53.45;	author hope;	state Exp;
branches
	1.26.1.1.1.1
	1.26.1.1.2.1
	1.26.1.1.3.1;
next	;

1.26.1.1.1.1
date	97.07.28.18.36.02;	author daveb;	state Exp;
branches
	1.26.1.1.1.1.1.1;
next	;

1.26.1.1.1.1.1.1
date	97.10.07.12.01.24;	author jkbrook;	state Exp;
branches;
next	;

1.26.1.1.2.1
date	97.09.08.17.28.26;	author daveb;	state Exp;
branches;
next	;

1.26.1.1.3.1
date	97.09.09.14.26.03;	author daveb;	state Exp;
branches;
next	;

1.26.2.1
date	97.09.10.19.44.53;	author brucem;	state Exp;
branches;
next	;

1.26.3.1
date	97.09.11.21.12.07;	author daveb;	state Exp;
branches;
next	;

1.28.1.1
date	99.04.01.18.09.54;	author daveb;	state Exp;
branches;
next	;


desc
@
@


1.28
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _bignum.sml the functor *)
(*
   Integer Arithmetic to Arbitrary Size.

$Log: _bignum.sml,v $
 * Revision 1.27  1998/02/02  10:07:00  jont
 * [Bug #70056]
 * Fix ~(n+1) div n yields zero bug
 *
 * Revision 1.26  1997/01/14  17:49:19  io
 * [Bug #1757]
 * rename __preinteger to __pre_int
 *
 * Revision 1.25  1997/01/06  14:45:45  matthew
 * Using PreInt instead of Int structure.
 *
 * Revision 1.24  1996/10/28  15:05:31  io
 * moving String from toplevel
 *
 * Revision 1.23  1996/04/30  16:21:18  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.22  1996/04/19  11:07:50  matthew
 * Changes to exceptions
 *
 * Revision 1.21  1996/02/06  16:46:43  jont
 * Fix conversion of negative hex integers to bignums to avoid
 * overflowing as positive (ie convert directly to negative
 * rather than negating the conversin to positive)
 *
Revision 1.20  1996/01/04  12:57:09  matthew
Adding bignum to int function.

Revision 1.19  1995/09/19  14:11:44  daveb
Corrected a mistaken change I made to hex_string_to_bignum.

Revision 1.18  1995/09/15  14:55:02  daveb
Corrected offsets in hex_string_to_bignum.

Revision 1.17  1995/08/24  14:15:53  daveb
Made int_to_bignum handle zero correctly.

Revision 1.16  1995/08/15  12:17:50  jont
Get correct exceptions out for range checking failures on hex conversions

Revision 1.14  1995/08/14  14:55:34  jont
Working on allowing multiple ranges

Revision 1.13  1995/07/27  14:57:09  jont
Fix mod problem with two negative arguments

Revision 1.12  1995/07/27  12:17:47  jont
Modify mod to use divilists so as to avoid overflows on words

Revision 1.11  1995/07/26  13:56:57  jont
Fix problems with word_string_to_bignum

Revision 1.10  1995/07/25  11:38:18  jont
Add operations for words (unsigned ints)

Revision 1.9  1995/07/17  16:49:21  jont
Add hex_string_to_bignum

Revision 1.8  1995/07/17  14:42:35  jont
Add int_to_bignum function

Revision 1.7  1993/07/20  11:44:53  jont
Changed the base integer size to 256 to ensure multiplications can be done
safely

Revision 1.6  1992/03/27  11:20:52  jont
Added require "crash". Disambiguated an integer <

Revision 1.5  1992/02/20  10:15:52  clive
The case    Zero          < (Positive _) = true
was missed out

Revision 1.4  1991/11/21  17:00:19  jont
Added copyright message

Revision 1.3  91/10/22  15:02:53  davidt
Now uses Crash.impossible instead of raising an exception.

Revision 1.2  91/08/30  15:24:22  davida
Added div and mod, fixed conversion
routines to cope with any base.

Revision 1.1  91/08/19  18:24:33  davida
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "crash";
require "bignum";
require "^.basis.__string";
require "^.basis.__char";
require "^.basis.__list";

functor BigNumFun
  (structure Crash  : CRASH
   val check_range  : bool
   val largest_int  : string
   val smallest_int : string
   val largest_word : string) : BIGNUM =
struct

  (*  miscellany  *)

  fun int_plus(x, y: int) = x + y

  fun int_minus(x, y: int) = x - y

  fun int_less_eq(x, y: int) = x <= y

  fun strip_zeros (#"0" :: (xs as #"0"::_)) = strip_zeros xs
    | strip_zeros (#"0" :: (xs as _::_)) = xs
    | strip_zeros x = x
     
  (*   Representation is by reversed list of integers representing   *)
  (*   digits in the given radix.  Functions assume they are called  *)
  (*   with correctly represented bignums, in normal form - i.e.     *)
  (*   Zero, or Positive/Negative of some list with no trailing      *)
  (*   (most significant) zeroes.				     *)

  datatype bignum = Positive of int list | Negative of int list | Zero

  val base = 256
  val bigone = Positive [1]

  fun int_to_bignum 0 = Zero
  |   int_to_bignum i =
    if i > 0 andalso i < base then Positive[i]
    else if i < 0 andalso i > ~base then Negative [~i]
    else
      Crash.impossible"int_to_bignum:int too big for simple conversion"

  fun fromHexChar (c:char):int = 
      if #"0" <= c andalso c <= #"9" then
        ord c - ord #"0"
      else if #"A" <= c andalso c <= #"F" then
        ord c - ord #"A" + 10
      else if #"a" <= c andalso c <= #"f" then
        (ord c) - ord #"a" + 10
      else raise Fail ("fromHexChar " ^ (str c))
				 
  (* raise Unrepresentable if the conversion cannot be done *) 
  exception Unrepresentable

  local
    fun convert_intlist ([],acc) = acc
      | convert_intlist (a::rest,acc) =
        convert_intlist (rest,a + base * acc)
        handle Overflow => raise Unrepresentable
  in
    fun bignum_to_int Zero = 0
      | bignum_to_int (Positive l) =
        convert_intlist (rev l,0)
      | bignum_to_int (Negative l) =
        ~ (convert_intlist (rev l,0))
  end

  exception Runtime of string
 
  val Prod_exn = Runtime "Prod"
  and Sum_exn  = Runtime "Sum"
  and Diff_exn = Runtime "Diff"
  and Mod_exn  = Runtime "Mod"
  and Div_exn  = Runtime "Div"
  and Neg_exn  = Runtime "Neg"
  and Abs_exn  = Runtime "Abs"

  (*  operations on digit lists  *)

  fun normilist l =
    let 
      fun strip_zero (0::xs) = strip_zero xs
	| strip_zero xs = xs
    in 
      rev (strip_zero (rev l))
    end
   
  fun addilists (x,y) =
    let 
      fun add (acc, x::xs, y::ys, carry) = add((x+y+carry) mod base :: acc,
					       xs, ys,
					       (x+y+carry) div base)
	| add (acc, [], [], carry) = if carry=0 then rev acc
				     else add(acc,[carry],[],0)
	| add (acc, x::xs, [], carry) = add((x+carry) mod base :: acc,
					    xs, [], (x+carry) div base)
	| add (acc, [], ys, carry) = add(acc, ys, [], carry)
    in 
      normilist(add ([], x, y, 0))
    end
   
  fun subilists (x,y) = 
    let
      fun sbt (acc, x::xs, y::ys, carry) = sbt((x-y+carry) mod base :: acc,
					       xs, ys,
					       (x-y+carry) div base)
	| sbt (acc, [], [], carry) = if carry=0 
				       then rev acc
				     else sbt(acc,[carry],[],0)
	| sbt (acc, xs, [], carry) = if carry=0 
				       then rev acc @@ xs
				     else sbt(acc,xs,[~carry],0)
	| sbt (acc, [], y::ys, carry) = sbt((~y+carry) mod base :: acc,
					    [], ys,
					    (~y+carry) div base)
    in
      normilist(sbt ([],x,y,0))
    end


  fun multilists(x: int list, y:int list) =
    let
      val lx = length x and ly = length y

      fun buildpps (shortlist, longlist) = 
	let
	  fun pp dig =
	    let
	      fun formpp (acc,x::xs,carry) = 
		formpp((x*dig+carry) mod base :: acc,
		       xs,
		       (x*dig+carry) div base)
		| formpp (acc,[],carry) = 
		  if carry=0 
		    then rev acc
		  else formpp(acc,[0],carry)
	    in 
	      normilist(formpp ([],longlist,0))
	    end

	  fun shiftleft (pref,acc,[]) = rev acc
	    | shiftleft (pref,acc,x::xs) = shiftleft(0::pref,
						     (pref@@x)::acc,
						     xs)
	in
	  shiftleft([],[],map pp shortlist)
	end
    in
      foldl addilists [] (buildpps (if lx<ly then (x,y) else (y,x)))
      (* Lists.reducel addilists ([],buildpps (if lx<ly then (x,y) else (y,x))) *)
    end

  fun ltilists(x:int list, y:int list) = 
    let
      val lx=(length x) and ly=(length y)

      fun lt ([],[]) = false
	| lt ([x:int],[y]) = x<y
	| lt (x::xs,y::ys) = x<y orelse (x=y andalso lt(xs,ys))
	| lt _ = Crash.impossible "ltilists"
    in
      (lx < ly) orelse (lx=ly andalso lt(rev x,rev y))
    end

 (*  With hearty thanks for the next one due to  *)
 (*  that ol' prankster, Don E. Knuth himself.   *) (*<Ref ACP, Vol2, 4.3.1>*)

 (*  ...and also to nickh for suggesting that Knuth was bound to have an  *)
 (*  ace way of doing long division.  If any one dares to say "overkill", *)
 (*  well... 								  *)

  local
    fun fst (x,_) = x

    fun split (n,xs) =
      let
	fun take(0, acc, xs) = (rev acc, xs)
	  | take(n, acc, x::xs) = take(n-1, x::acc, xs)
	  | take(_, _, []) = Crash.impossible "split"
      in
	take (n, [], xs)
      end

    fun pad (n,xs) = 
      let
	fun padzero (0,xs) = xs
	  | padzero (n,xs) = padzero(n-1,0::xs)
      in
	if (length xs<n)
	  then padzero(n - (length xs),xs) 
	else xs
      end

  in
    (*  divilists takes a pair (u,v) of reversed digit lists, and  *)
    (*  returns a pair (q,r) where q = u div v and r = u mod v     *)
    (*  Division by zero (empty list) returns (0,u).               *)

    fun divilists ([]:int list, v:int list) = ([],[])
      | divilists (u, [v]) =
    (* the Noddy Algorithm *)
	let 
	  fun noddy(qs,u::us,r) = noddy(((r*base+u) div v)::qs, 
					us, 
					(r*base+u) mod v)
	    | noddy(qs,[],r) = (normilist qs, normilist [r])
	in
	  noddy ([],rev u,0)
	end
      | divilists (u', v') =
	if (length u') >= (length v')
	  then
	    (* the Well-Hard Algorithm *)
	    let
	      val n = length v'
	      val m = (length u') - n
	      val b = base

	      (* Normalise *)

	      val d = b div (hd (rev v') + 1)

	      val u = let
			val u'' = multilists(u',[d])
		      in 
			if (length u'')=(length u')
			  then u''@@[0]
			else u''
		      end

	      val v = multilists(v',[d])
	      val (v1,v2) = case (rev v) of
		(v1::v2::_) => (v1,v2)
	      | _ => Crash.impossible "size of v in divilists"


	      (* Division Loop *) 

	      fun well_hard (us, qs, ~1) = (normilist qs, 
					    fst(divilists(normilist
							  (rev us), [d])))

		| well_hard (us as uj::uj1::uj2::_, qs, jm) = 
		  let 
		    val (u,urest) = split(n+1,us)

		    (* Calculate qhat *)

		    fun fiddle_qhat qhat = 
		      if (qhat*v2) > ((uj*b + uj1 - qhat*v1) * b + uj2)
			then fiddle_qhat (qhat-1)
		      else qhat

		    val qhat = fiddle_qhat (if uj=v1
					      then b-1
					    else (uj*b + uj1) div v1)

		    (* Multiply and Subtract *)

		    val (qj,u) =
		       let
			 val qhv = multilists(v, [qhat])
		       in
			  if ltilists(normilist (rev u), qhv)
			    then
			      let
				val u' = addilists(pad(n+1,[1]),
						   normilist (rev u))
				val bcomp = subilists(u',qhv)
			      in
				(qhat-1, rev(addilists(v,bcomp)))
			      end
			  else
			    (qhat, rev (subilists(normilist (rev u), qhv)))
		       end
		  in
		    well_hard((tl (pad(n+1,u)))@@urest, qj::qs, jm-1)
		  end
		| well_hard (us,qs,jm) = Crash.impossible "well hard"
	    in
	      well_hard (rev u, [], m)
	    end
	else ([],u')
  end


 (*  converting to and from strings  *)

  fun bignum_to_string bn =
    let
      fun barbeque (digs, value) = 
	let 
	  val (q,r) = divilists(value, [10])
	in 
	  if q=[] (* i.e. zero *)
	    then (r@@digs)
	  else barbeque((case r of []=>0 | [r]=>r | _=> 
			   Crash.impossible "base in b_to_s")::digs, q)
	end

      fun chargrill il = implode (strip_zeros (map (fn c=>chr (c + ord #"0"))
					       (barbeque([],il))))
    in
      case bn of
	Positive il => chargrill il
      | Negative il => str #"~" ^ (chargrill il)
      | Zero => "0"
    end

  fun string_to_bignum s =  (* NB: assumes base>10 *)
    let
      val (signval,rest) = case explode s of
	(#"~" :: ss) => (false,strip_zeros ss)
      | ss => (true,strip_zeros ss)

      fun make_big (biglist, []) = biglist
	| make_big (biglist, c::cs) = 
	  let
	    val digval = ord c - ord #"0"
	    val biglist' = addilists(multilists(biglist, [10]),
				     [digval])
	  in
	    make_big (biglist',cs)
	  end
    in
      if List.all Char.isDigit rest then
	case rest of
	  [#"0"]  => Zero
	| _ => let
		 val ilist = make_big ([],rest)
	       in
		 if signval then
		   Positive ilist
		 else 
		   Negative ilist
	       end
      else
	Crash.impossible ("string_to_bignum: bad characters in string '" ^ s ^ "'")
(*
      else
	(output(std_out, "string_to_bignum: bad characters in string '" ^ s ^ "'\n");
	 raise Match)
*)
    end

  (************************)
  (*  THE BIGNUM ROUTINES *)
  (************************)

  infix 4  eq <>  <  >  <=  >=
  infix 6  +  -
  infix 7  div  mod  *

  (************************)
  (* Relational Operators *)
  (************************)
   
  fun Zero         eq Zero         = true
    | (Positive x) eq (Positive y) = x=y
    | (Negative x) eq (Negative y) = x=y
    |      _       eq      _       = false

  fun x <> y = not(x eq y)

  fun Zero          < Zero         = false
    | Zero          < (Positive _) = true
    | (Positive x)  < (Positive y) = ltilists(x,y)
    | (Negative x)  < (Negative y) = ltilists(y,x)
    | (Negative x)  <     _        = true
    |      _        <     _        = false

  fun x <= y = (x eq y) orelse (x < y)

  fun x > y = not(x <= y)

  fun x >= y = not(x < y)


  (*  range_check also normalises bignums - normal form is Zero else  *)
  (*  shortest possible list of ints  (i.e. no trailing zeros)        *)
  (* word_range_check does the same but for unsigned values           *)
  local
    val maximum_positive = string_to_bignum largest_int
    val minimum_negative = string_to_bignum smallest_int
    val maximum_positive_word = string_to_bignum largest_word
  in
    fun normalise x =          (* ensure in normal form *)
      case x of 
	Zero => Zero
      | Positive l => (case normilist l of
			   [] => Zero
			 | x => Positive x)
      | Negative l => (case normilist l of
			   [] => Zero
			 | x => Negative x)

    fun range_check(bignum, exn) =
      let
	val rc =
	  if check_range then
	    fn Zero => Zero
	     | (n as Positive _) =>
		 if n <= maximum_positive then n else
		   ((*output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");*)
		    raise exn)
	     | (n as Negative _) =>
		 if n >= minimum_negative then n else
		   ((*output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");*)
		    raise exn)
	  else
	    fn x => x
      in
	rc(normalise bignum)
      end

    fun word_range_check(bignum, exn) =
      let
	val rc =
	  if check_range then
	    fn Zero => Zero
	     | (n as Positive _) =>
		 if n <= maximum_positive_word then n else
		   ((*output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");*)
		    raise exn)
	     | (n as Negative _) => raise exn
	  else
	    fn x => x
      in
	rc(normalise bignum)
      end
  end

  (****************)   
  (*  Arithmetic  *)
  (****************)   

  fun neg Zero = Zero                   (*  for internal use  *)
    | neg (Positive x) = Negative x
    | neg (Negative x) = Positive x

  fun ~x = range_check(neg x, Neg_exn)

  fun abs Zero = Zero
    | abs (Positive x) = Positive x
    | abs (Negative x) = range_check(Positive x, Abs_exn)

  fun (Positive x) + (Positive y) =range_check(Positive(addilists(x,y)),Sum_exn)
    | (Negative x) + (Negative y) =range_check(Negative(addilists(x,y)),Sum_exn)
    | (Positive x) + (Negative y) = 
      if x=y then Zero 
      else if (Positive x) > (Positive y) 
	     then range_check(Positive(subilists(x,y)),Sum_exn)
	   else range_check(Negative(subilists(y,x)),Sum_exn)
    | Zero         + anything     = anything
    | x + y = y + x

  fun x - y = (x + (neg y)) handle Runtime "Sum" => raise Diff_exn

  fun Zero        * anything    = Zero
    | anything    * Zero        = Zero
    | (Positive x)*(Positive y) =range_check(Positive(multilists(x,y)),Prod_exn)
    | (Negative x)*(Negative y) =range_check(Positive(multilists(x,y)),Prod_exn)
    | (Positive x)*(Negative y) =range_check(Negative(multilists(x,y)),Prod_exn)
    | (Negative x)*(Positive y) =range_check(Negative(multilists(x,y)),Prod_exn)

  fun word_plus((Positive x), (Positive y)) =
    word_range_check(Positive(addilists(x,y)), Sum_exn)
    | word_plus(x as Positive _, Zero) = x
    | word_plus(x as Negative _, _) = Crash.impossible"word_plus: negative values"
    | word_plus(Zero, Zero) = Zero
    | word_plus(x, y) = word_plus(y, x)

  fun word_star(Zero, _) = Zero
    | word_star(Positive x, Positive y) =
      word_range_check(Positive(multilists(x, y)), Prod_exn)
    | word_star(Negative _, _) =
      Crash.impossible"word_star: negative values"
    | word_star(x, y) = word_star(y, x)

  fun is_positive (Positive _) = true
    | is_positive _ = false

  local
    fun divit((u,v), sign) =
      if u=v then sign [1]
      else if ltilists(u,v) then Zero
	   else 
	     let 
	       val (quotient,_) = divilists(u,v)
	     in 
	       range_check (sign quotient, Runtime "div range")
	     end
  in
    fun            _ div Zero         = raise Div_exn
      |         Zero div _            = Zero
      | (Positive i) div (Positive d) = divit((i,d), Positive)
      | (Negative i) div (Negative d) = divit((i,d), Positive)
      | (Positive i) div (Negative d) =
	divit((subilists(i,[1]),d), Negative) - bigone
      | (Negative i) div (Positive d) =
	divit((subilists(i,[1]),d), Negative) - bigone
  end

  fun _ mod Zero = raise Mod_exn
    | Zero mod _ = Zero
    | i mod d    =
      let
	fun modi(i, d) =
	  let
	    val (_, r) = divilists(i, d)
	  in
	    r
	  end

	val r = case (i, d) of
	  (Positive i', Positive d') => normalise(Positive(modi(i', d')))
	| (Negative i', Positive d') =>
	    let
	      val r = Positive(modi(i', d'))
	    in
	      case normalise r of
		Zero => Zero
	      | _ => d - r
	    end
	| (Positive i', Negative d') =>
	    let
	      val r = Positive(modi(i', d'))
	    in
	      case normalise r of
		Zero => Zero
	      | _ => r + d
	    end
	| (Negative i', Negative d') =>
	    let
	      val r = Positive(modi(i', d'))
	    in
	      case normalise r of
		Zero => Zero
	      | r => neg r
	    end
	| _ => Crash.impossible"mod: unexpected case"
      in
	r
      end

    fun quot(a, b) =
      let
        val q = a div b
        val r = a mod b
      in
        if r = Zero orelse (a > Zero andalso b > Zero) orelse
	   (a < Zero andalso b < Zero) then
          q
        else
          q + bigone
      end

    fun rem(a, b) =
      let
        val r = a mod b
      in
        if r = Zero orelse (a > Zero andalso b > Zero) orelse
	   (a < Zero andalso b < Zero) then
          r 
        else
          r - b
      end

  val bignum_sixteen = int_to_bignum 16

  fun convert_hex_to_bignum(chars, ptr) =
    let
      val size = size chars
      fun do_hex_digit(ptr', acc) =
	if int_less_eq(size, ptr') then acc
	else
	  let
	    val digit =
	      fromHexChar (String.sub (chars, ptr'))
	  in
	    do_hex_digit(int_plus(ptr', 1), (bignum_sixteen * acc) +
			 int_to_bignum digit)
	  end
    in
      do_hex_digit(ptr, Zero)
    end

  fun neg_convert_hex_to_bignum(chars, ptr) =
    let
      val size = size chars
      fun do_hex_digit(ptr', acc) =
	if int_less_eq(size, ptr') then acc
	else
	  let
	    val digit = fromHexChar (String.sub (chars, ptr'))
	  in
	    do_hex_digit(int_plus(ptr', 1), (bignum_sixteen * acc) -
			 int_to_bignum digit)
	  end
    in
      do_hex_digit(ptr, Zero)
    end

  fun convert_hex_word_to_bignum(chars, ptr) =
    let
      val size = size chars
      fun do_hex_digit(ptr', acc) =
	if int_less_eq(size, ptr') then acc
	else
	  let
	    val digit = fromHexChar (String.sub (chars, ptr'))
	  in
	    do_hex_digit(int_plus(ptr', 1),
			 word_plus(word_star(bignum_sixteen, acc),
				   int_to_bignum digit))
	  end
    in
      do_hex_digit(ptr, Zero)
    end

  (*  for export  *)

  fun hex_string_to_bignum (chars:string) =
    (if String.sub (chars, 0) = #"~" then
       neg_convert_hex_to_bignum (chars, 3)
     else
       convert_hex_to_bignum(chars, 2))
       handle Runtime _ => raise Unrepresentable

  fun hex_word_string_to_bignum chars =
    (convert_hex_word_to_bignum(chars, 3))
    handle Runtime _ => raise Unrepresentable
      

  fun word_string_to_bignum (x:string) = 
    if String.isPrefix "0w" x then
      word_range_check (string_to_bignum (substring (x, 2, int_minus(size x, 2))),
			Unrepresentable)
    else
      Crash.impossible ("word_string_to_bignum:bad word string '" ^ x ^ "'")
      
  val string_to_bignum = fn s=>range_check(string_to_bignum s, Unrepresentable)
    
end (* functor BigNumFun *)
@


1.28.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.28  1999/02/02  16:02:02  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.27
log
@[Bug #70056]
Fix ~(n+1) div n yields zero bug
@
text
@d6 4
a98 2
require "^.basis.__string_cvt";
require "^.basis.__pre_int";
d141 9
a667 7

  fun fromHexChar (c:char):int = 
    PreInt.toDigit StringCvt.HEX c 
  (* might raise Fail s
   * previously raised Crash.impossible "hex_digit_to_bignum:bad digit:" ^ (str o chr) digit)
   *)
				 
@


1.26
log
@[Bug #1757]
rename __preinteger to __pre_int
@
text
@d6 4
d572 1
a572 1
      if u=v then bigone
@


1.26.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.26  1997/01/14  17:49:19  io
 * [Bug #1757]
 * rename __preinteger to __pre_int
 *
@


1.26.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.26  1997/01/14  17:49:19  io
 * [Bug #1757]
 * rename __preinteger to __pre_int
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a5 4
 * Revision 1.26  1997/01/14  17:49:19  io
 * [Bug #1757]
 * rename __preinteger to __pre_int
 *
@


1.26.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.26.1.1  1997/05/12  10:53:45  hope
 * branched from 1.26
 *
@


1.26.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.26.1.1  1997/05/12  10:53:45  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.26.1.1  1997/05/12  10:53:45  hope
 * branched from 1.26
 *
@


1.26.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.26.1.1.1.1  1997/07/28  18:36:02  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25
log
@Using PreInt instead of Int structure.
@
text
@d6 3
d92 1
a92 1
require "^.basis.__preinteger";
@


1.24
log
@moving String from toplevel
@
text
@d6 3
d652 1
a652 1
    Int.toDigit StringCvt.HEX c 
@


1.24.4.1
log
@branched from 1.24
@
text
@a5 3
 * Revision 1.24  1996/10/28  15:05:31  io
 * moving String from toplevel
 *
@


1.24.3.1
log
@branched from 1.24
@
text
@a5 3
 * Revision 1.24  1996/10/28  15:05:31  io
 * moving String from toplevel
 *
@


1.24.3.1.1.1
log
@branched from 1.24.3.1
@
text
@a5 3
 * Revision 1.24.3.1  1996/12/17  18:20:00  hope
 * branched from 1.24
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a5 3
 * Revision 1.24  1996/10/28  15:05:31  io
 * moving String from toplevel
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a5 3
 * Revision 1.24  1996/10/28  15:05:31  io
 * moving String from toplevel
 *
@


1.24.1.1.1.1
log
@branched from 1.24.1.1
@
text
@a5 3
 * Revision 1.24.1.1  1996/11/14  13:23:57  hope
 * branched from 1.24
 *
@


1.23
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
a83 1
require "lists";
d85 5
a92 1
   structure Lists  : LISTS
d107 2
a108 4
  fun is_digit x = String.ord(x)>=String.ord("0") andalso String.ord(x)<=String.ord("9");

  fun strip_zeros ("0" :: (xs as "0"::_)) = strip_zeros xs
    | strip_zeros ("0" :: (xs as _::_)) = xs
d200 1
a200 1
      val lx=(Lists.length x) and ly=(Lists.length y)
d226 2
a227 1
      Lists.reducel addilists ([],buildpps (if lx<ly then (x,y) else (y,x)))
d232 1
a232 1
      val lx=(Lists.length x) and ly=(Lists.length y)
a249 6
    fun hd (x::_) = x
      | hd []     = Crash.impossible "hd"

    fun tl (_::xs) = xs
      | tl []      = Crash.impossible "tl"

d266 2
a267 2
	if (Lists.length xs<n)
	  then padzero(n - (Lists.length xs),xs) 
d288 1
a288 1
	if (Lists.length u') >= (Lists.length v')
d292 2
a293 2
	      val n = Lists.length v'
	      val m = (Lists.length u') - n
d303 1
a303 1
			if (Lists.length u'')=(Lists.length u')
d378 1
a378 1
      fun chargrill il = String.implode (strip_zeros (map (fn c=>String.chr(c+String.ord("0"))) 
d383 1
a383 1
      | Negative il => "~" ^ (chargrill il)
d389 2
a390 2
      val (signval,rest) = case String.explode s of
	("~"::ss) => (false,strip_zeros ss)
d396 1
a396 1
	    val digval = String.ord(c)-String.ord("0")
d403 3
a405 3
      if Lists.forall is_digit rest
	then case rest of
	  ["0"]  => Zero
d409 4
a412 3
		 if signval
		   then Positive ilist
		 else Negative ilist
d648 6
a653 11
  fun hex_digit_to_bignum digit =
    if int_less_eq(String.ord"0", digit) andalso int_less_eq(digit, String.ord"9") then
      int_minus(digit, String.ord"0")
    else
      if int_less_eq(String.ord"a", digit ) andalso int_less_eq(digit, String.ord"f") then
	int_plus(int_minus(digit, String.ord"a"), 10)
      else
	if int_less_eq(String.ord"A", digit) andalso int_less_eq(digit, String.ord"F") then
	  int_plus(int_minus(digit, String.ord"A"), 10)
	else
	  Crash.impossible("hex_digit_to_bignum:bad digit:" ^ String.chr digit)
d662 2
a663 1
	    val digit = hex_digit_to_bignum(String.ordof(chars, ptr'))
d679 1
a679 1
	    val digit = hex_digit_to_bignum(String.ordof(chars, ptr'))
d695 1
a695 1
	    val digit = hex_digit_to_bignum(String.ordof(chars, ptr'))
d707 3
a709 3
  fun hex_string_to_bignum chars =
    (if String.ordof(chars, 0) = String.ord"~" then
       neg_convert_hex_to_bignum(chars, 3)
d717 1
d719 7
a725 14
  fun word_string_to_bignum x =
    let
      val size = size x
    in
      if int_less_eq(size, 2) then
	Crash.impossible("word_string_to_bignum:bad word string '" ^ x ^ "'")
      else
	case String.substring(x, 0, 2) of
	  "0w" => word_range_check(string_to_bignum
				   (String.substring(x, 2, int_minus(size, 2))),
				   Unrepresentable)
	| _ => Crash.impossible("word_string_to_bignum:bad word string '" ^ x ^ "'")
    end

d727 2
a728 2

end
@


1.23.3.1
log
@branched from 1.23
@
text
@a5 6
 * Revision 1.23  1996/04/30  16:21:18  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.23.2.1
log
@branched from 1.23
@
text
@a5 6
 * Revision 1.23  1996/04/30  16:21:18  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.23.1.1
log
@branched from 1.23
@
text
@a5 6
 * Revision 1.23  1996/04/30  16:21:18  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.22
log
@Changes to exceptions
@
text
@d6 3
d98 1
a98 1
  fun is_digit x = ord(x)>=ord("0") andalso ord(x)<=ord("9");
d376 1
a376 1
      fun chargrill il = implode (strip_zeros (map (fn c=>chr(c+ord("0"))) 
d387 1
a387 1
      val (signval,rest) = case explode s of
d394 1
a394 1
	    val digval = ord(c)-ord("0")
d646 2
a647 2
    if int_less_eq(ord"0", digit) andalso int_less_eq(digit, ord"9") then
      int_minus(digit, ord"0")
d649 2
a650 2
      if int_less_eq(ord"a", digit ) andalso int_less_eq(digit, ord"f") then
	int_plus(int_minus(digit, ord"a"), 10)
d652 2
a653 2
	if int_less_eq(ord"A", digit) andalso int_less_eq(digit, ord"F") then
	  int_plus(int_minus(digit, ord"A"), 10)
d655 1
a655 1
	  Crash.impossible("hex_digit_to_bignum:bad digit:" ^ chr digit)
d709 1
a709 1
    (if String.ordof(chars, 0) = ord"~" then
@


1.21
log
@Fix conversion of negative hex integers to bignums to avoid
overflowing as positive (ie convert directly to negative
rather than negating the conversin to positive)
@
text
@d6 5
d126 1
a126 2
        handle Prod => raise Unrepresentable
             | Sum => raise Unrepresentable
@


1.20
log
@Adding bignum to int function.
@
text
@d6 3
d666 16
d703 1
a703 1
       Zero - convert_hex_to_bignum(chars, 3)
@


1.19
log
@Corrected a mistaken change I made to hex_string_to_bignum.
@
text
@d6 3
d111 17
a680 2

  exception Unrepresentable
@


1.18
log
@Corrected offsets in hex_string_to_bignum.
@
text
@d6 3
d666 1
a666 1
       Zero - convert_hex_to_bignum(chars, 1)
d668 1
a668 1
       convert_hex_to_bignum(chars, 0))
@


1.17
log
@Made int_to_bignum handle zero correctly.
@
text
@d6 3
d587 23
d663 1
a663 1
       Zero - convert_hex_to_bignum(chars, 3)
d665 1
a665 1
       convert_hex_to_bignum(chars, 2))
@


1.16
log
@Get correct exceptions out for range checking failures on hex conversions
@
text
@d6 3
d95 4
a98 2
  fun int_to_bignum i =
    if i >= 0 andalso i < base then Positive[i]
@


1.15
log
@Remove superfluous diagnostic
@
text
@a608 6
  fun hex_string_to_bignum chars =
    if String.ordof(chars, 0) = ord"~" then
      Zero - convert_hex_to_bignum(chars, 3)
    else
      convert_hex_to_bignum(chars, 2)

a625 2
  fun hex_word_string_to_bignum chars = convert_hex_word_to_bignum(chars, 3)

d629 11
@


1.14
log
@Working on allowing multiple ranges
@
text
@d6 3
d437 1
a437 1
		   (output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");
d441 1
a441 1
		   (output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");
d456 1
a456 1
		   (output(std_out, "Raising on " ^ bignum_to_string n ^ "\n");
@


1.13
log
@Fix mod problem with two negative arguments
@
text
@d6 3
d58 1
d367 2
a368 1
      else Crash.impossible ("string_to_bignum: bad characters in string '" ^ s ^ "'")
a379 1

a383 1

d427 1
a427 1
    fun range_check (bignum, exn) =
d429 13
a441 5
	fun rc Zero = Zero
	  | rc (n as Positive _) =
	    if n <= maximum_positive then n else raise exn
	  | rc (n as Negative _) =
	    if n >= minimum_negative then n else raise exn
d448 10
a457 4
	fun rc Zero = Zero
	  | rc (n as Positive _) =
	    if n <= maximum_positive_word then n else raise exn
	  | rc (n as Negative _) = raise exn
a634 2
  val string_to_bignum = fn s=>range_check(string_to_bignum s, Unrepresentable)

d648 2
@


1.12
log
@Modify mod to use divilists so as to avoid overflows on words
@
text
@d6 3
d552 1
a552 1
	      | _ => r + d
@


1.11
log
@Fix problems with word_string_to_bignum
@
text
@d6 3
d360 6
a365 1
      else Crash.impossible "string_to_bignum: bad characters in string"
d515 40
a554 1
    | i mod d    = i - d*(i div d)  (* instead, could use divilists, cf above *)
@


1.10
log
@Add operations for words (unsigned ints)
@
text
@d6 3
d578 2
a579 1
	  "0w" => word_range_check(string_to_bignum(String.substring(x, 2, size)),
@


1.9
log
@Add hex_string_to_bignum
@
text
@d6 3
d40 1
d45 1
d47 2
a48 1
   and smallest_int : string) : BIGNUM =
a64 20
  fun forall p = 
    let
      fun fora [] = true
	| fora (x::xs) = p x andalso fora xs
    in 
      fora
    end

  fun length [] = 0
    | length (_::xs) = 1+length xs;

  fun reduce_left f =
    let
      fun itl(i,x::xs) = itl(f(i,x),xs)
	| itl(i,[]) = i
    in
      itl
    end


d136 1
a136 1
      val lx=(length x) and ly=(length y)
d162 1
a162 1
      reduce_left addilists ([],buildpps (if lx<ly then (x,y) else (y,x)))
d167 1
a167 1
      val lx=(length x) and ly=(length y)
d207 2
a208 2
	if (length xs<n)
	  then padzero(n - (length xs),xs) 
d229 1
a229 1
	if (length u') >= (length v')
d233 2
a234 2
	      val n = length v'
	      val m = (length u') - n
d244 1
a244 1
			if (length u'')=(length u')
d344 1
a344 1
      if forall is_digit rest
d394 1
a394 1

d398 1
d400 11
a410 1
    fun range_check (bignum,exn) =
d412 8
a419 9
	fun normalise x =          (* ensure in normal form *)
	  case x of 
	    Zero => Zero
	  | (Positive l) => (case (normilist l) of
			       [] => Zero
			     | _ => Positive (normilist l))
	  | (Negative l) => (case (normilist l) of
			       [] => Zero
			     | _ => Negative (normilist l))
d421 2
d424 3
a426 6
	  | rc (n as Positive _) = if n <= maximum_positive
				     then n
				   else raise exn
	  | rc (n as Negative _) = if n >= minimum_negative
				     then n
				   else raise exn
d428 1
a428 1
	rc (normalise bignum)
d465 14
d520 1
a520 1
  fun convert_hex_to_bignum chars =
d533 1
a533 1
      do_hex_digit(2, Zero)
d538 1
a538 2
      Zero - convert_hex_to_bignum(String.substring(chars, 1,
						    int_minus(size chars, 1)))
d540 20
a559 1
      convert_hex_to_bignum chars
d565 14
a578 1
  val string_to_bignum = fn s=>range_check(string_to_bignum s, Unrepresentable);
@


1.8
log
@Add int_to_bignum function
@
text
@d6 3
d45 5
a49 1
 (*  miscellany  *)
d51 1
a51 1
 fun is_digit x = ord(x)>=ord("0") andalso ord(x)<=ord("9");
d53 5
a57 3
 fun strip_zeros ("0" :: (xs as "0"::_)) = strip_zeros xs
   | strip_zeros ("0" :: (xs as _::_)) = xs
   | strip_zeros x = x
d59 7
a65 7
 fun forall p = 
   let
     fun fora [] = true
       | fora (x::xs) = p x andalso fora xs
   in 
     fora
   end;
d67 2
a68 3
 fun length [] = 0
   | length (_::xs) = 1+length xs;
     
d70 1
a70 1
 fun reduce_left f =
d72 2
a73 2
       fun itl(i,x::xs) = itl(f(i,x),xs)
	 | itl(i,[]) = i
d75 2
a76 2
       itl
    end;
d85 1
a85 1
 datatype bignum = Positive of int list | Negative of int list | Zero
d87 2
a88 2
 val base = 256
 val bigone = Positive [1]
d90 4
a93 4
 fun int_to_bignum i =
   if i >= 0 andalso i < base then Positive[i]
   else
     Crash.impossible"int_to_bignum:int too big for simple conversion"
d95 1
a95 1
 exception Runtime of string;
d97 7
a103 7
 val Prod_exn = Runtime "Prod"
 and Sum_exn  = Runtime "Sum"
 and Diff_exn = Runtime "Diff"
 and Mod_exn  = Runtime "Mod"
 and Div_exn  = Runtime "Div"
 and Neg_exn  = Runtime "Neg"
 and Abs_exn  = Runtime "Abs"
d105 1
a105 1
 (*  operations on digit lists  *)
d107 1
a107 1
 fun normilist l =
d109 2
a110 2
       fun strip_zero (0::xs) = strip_zero xs
	 | strip_zero xs = xs
d112 1
a112 1
       rev (strip_zero (rev l))
d115 13
a127 13
 fun addilists (x,y) =
   let 
     fun add (acc, x::xs, y::ys, carry) = add((x+y+carry) mod base :: acc,
					      xs, ys,
					      (x+y+carry) div base)
       | add (acc, [], [], carry) = if carry=0 then rev acc
				    else add(acc,[carry],[],0)
       | add (acc, x::xs, [], carry) = add((x+carry) mod base :: acc,
					   xs, [], (x+carry) div base)
       | add (acc, [], ys, carry) = add(acc, ys, [], carry)
   in 
     normilist(add ([], x, y, 0))
   end;
d129 1
a129 1
 fun subilists (x,y) = 
d131 12
a142 12
       fun sbt (acc, x::xs, y::ys, carry) = sbt((x-y+carry) mod base :: acc,
						xs, ys,
						(x-y+carry) div base)
	 | sbt (acc, [], [], carry) = if carry=0 
					 then rev acc
				      else sbt(acc,[carry],[],0)
	 | sbt (acc, xs, [], carry) = if carry=0 
					 then rev acc @@ xs
				      else sbt(acc,xs,[~carry],0)
	 | sbt (acc, [], y::ys, carry) = sbt((~y+carry) mod base :: acc,
					     [], ys,
					     (~y+carry) div base)
d144 2
a145 2
       normilist(sbt ([],x,y,0))
    end;
d148 1
a148 1
 fun multilists(x: int list, y:int list) =
d150 17
a166 1
       val lx=(length x) and ly=(length y)
d168 10
a177 26
       fun buildpps (shortlist, longlist) = 
	  let
	     fun pp dig =
		let
		   fun formpp (acc,x::xs,carry) = 
		          formpp((x*dig+carry) mod base :: acc,
				 xs,
				 (x*dig+carry) div base)
		     | formpp (acc,[],carry) = 
		          if carry=0 
			     then rev acc
			  else formpp(acc,[0],carry)
		in 
		   normilist(formpp ([],longlist,0))
		end

	     fun shiftleft (pref,acc,[]) = rev acc
	       | shiftleft (pref,acc,x::xs) = shiftleft(0::pref,
							(pref@@x)::acc,
							xs)
	  in
	     shiftleft([],[],map pp shortlist)
	  end
    in 
       reduce_left addilists ([],buildpps (if lx<ly then (x,y) else (y,x)))
    end;
d179 1
a179 1
 fun ltilists(x:int list, y:int list) = 
d181 1
a181 1
       val lx=(length x) and ly=(length y)
d183 4
a186 4
       fun lt ([],[]) = false
	 | lt ([x:int],[y]) = x<y
	 | lt (x::xs,y::ys) = x<y orelse (x=y andalso lt(xs,ys))
	 | lt _ = Crash.impossible "ltilists"
d188 2
a189 3
       (lx < ly) orelse (lx=ly andalso lt(rev x,rev y))
    end;

a190 2


d198 1
a198 1
 local
d208 7
a214 7
       let
	  fun take(0, acc, xs) = (rev acc, xs)
	    | take(n, acc, x::xs) = take(n-1, x::acc, xs)
	    | take(_, _, []) = Crash.impossible "split"
       in
	  take (n, [], xs)
       end
d217 8
a224 8
       let
	  fun padzero (0,xs) = xs
	    | padzero (n,xs) = padzero(n-1,0::xs)
       in
	  if (length xs<n)
	     then padzero(n - (length xs),xs) 
	  else xs
       end
d226 1
a226 1
 in
d234 13
a246 13
    let 
       fun noddy(qs,u::us,r) = noddy(((r*base+u) div v)::qs, 
				     us, 
				     (r*base+u) mod v)
	 | noddy(qs,[],r) = (normilist qs, normilist [r])
    in
       noddy ([],rev u,0)
    end
   | divilists (u', v') =
     if (length u') >= (length v')
	then
	   (* the Well-Hard Algorithm *)
	   let
d256 1
a256 1
			 val u'' = multilists(u',[d])
d258 3
a260 3
			 if (length u'')=(length u')
			    then u''@@[0]
			 else u''
d265 2
a266 2
		 		(v1::v2::_) => (v1,v2)
			      | _ => Crash.impossible "size of v in divilists"
d276 1
a276 1
		 let 
d282 3
a284 3
		       if (qhat*v2) > ((uj*b + uj1 - qhat*v1) * b + uj2)
			  then fiddle_qhat (qhat-1)
		       else qhat
d287 1
a287 1
					       then b-1
d292 4
a295 4
		    val (qj,u) = 
		       let 
			  val qhv = multilists(v, [qhat])
		       in 
d297 10
a306 11
			     then 
				let 
				   val u' = addilists(pad(n+1,[1]),
						      normilist (rev u))
				      
				   val bcomp = subilists(u',qhv)
				in
				   (qhat-1, rev(addilists(v,bcomp)))
				end
			  else 
			     (qhat, rev (subilists(normilist (rev u), qhv)))
d308 1
a308 1
		 in
d310 1
a310 1
		 end
d312 1
a312 1
	   in
d314 3
a316 3
	   end
     else ([],u')
 end
d321 30
a350 31
    fun bignum_to_string bn =
     let
	fun barbeque (digs, value) = 
	   let 
	      val (q,r) = divilists(value, [10])
	   in 
	      if q=[] (* i.e. zero *)
		 then (r@@digs)
	      else barbeque((case r of []=>0 | [r]=>r | _=> 
				Crash.impossible "base in b_to_s")::digs, q)
	   end

	fun chargrill il = implode (strip_zeros (map (fn c=>chr(c+ord("0"))) 
						 (barbeque([],il))))
     in
       case bn of
	 Positive il => chargrill il
       | Negative il => "~" ^ (chargrill il)
       | Zero => "0"
     end;


 fun string_to_bignum s =  (* NB: assumes base>10 *)
   let
     val (signval,rest) = case explode s of
       				("~"::ss) => (false,strip_zeros ss)
			      | ss => (true,strip_zeros ss)

     fun make_big (biglist, []) = biglist
       | make_big (biglist, c::cs) = 
	 let
d354 1
a354 1
	 in
d356 3
a358 3
	 end
   in
     if forall is_digit rest
d360 24
a383 24
	   ["0"]  => Zero
	 | _ => let
		   val ilist = make_big ([],rest)
		in
		   if signval
		      then Positive ilist
		   else Negative ilist
		end
     else Crash.impossible "string_to_bignum: bad characters in string"
   end

 (************************)
 (*  THE BIGNUM ROUTINES *)
 (************************)


 infix 4  eq <>  <  >  <=  >=
 infix 6  +  -
 infix 7  div  mod  *


 (************************)
 (* Relational Operators *)
 (************************)
d385 29
a413 29
 fun Zero         eq Zero         = true
   | (Positive x) eq (Positive y) = x=y
   | (Negative x) eq (Negative y) = x=y
   |      _       eq      _       = false

 fun x <> y = not(x eq y)
	  
 fun Zero          < Zero         = false
   | Zero          < (Positive _) = true
   | (Positive x)  < (Positive y) = ltilists(x,y)
   | (Negative x)  < (Negative y) = ltilists(y,x)
   | (Negative x)  <     _        = true
   |      _        <     _        = false

 fun x <= y = (x eq y) orelse (x < y)

 fun x > y = not(x <= y)

 fun x >= y = not(x < y)


 (*  range_check also normalises bignums - normal form is Zero else  *)
 (*  shortest possible list of ints  (i.e. no trailing zeros)        *)
			 
 local
   val maximum_positive = string_to_bignum largest_int
   val minimum_negative = string_to_bignum smallest_int
 in
   fun range_check (bignum,exn) =
d415 17
a431 17
	 fun normalise x =          (* ensure in normal form *)
	    case x of 
	       Zero => Zero
	     | (Positive l) => (case (normilist l) of
				   [] => Zero
				 | _ => Positive (normilist l))
	     | (Negative l) => (case (normilist l) of
				   [] => Zero
				 | _ => Negative (normilist l))

	 fun rc Zero = Zero
	   | rc (n as Positive _) = if n <= maximum_positive
				       then n
				    else raise exn
	   | rc (n as Negative _) = if n >= minimum_negative
				       then n
				    else raise exn
d433 1
a433 1
	 rc (normalise bignum)
d435 1
a435 1
 end 
d437 73
a509 7
 (****************)   
 (*  Arithmetic  *)
 (****************)   
     
 fun neg Zero = Zero                   (*  for internal use  *)
   | neg (Positive x) = Negative x
   | neg (Negative x) = Positive x
d511 15
a525 52
 fun ~x = range_check(neg x, Neg_exn)
     
 fun abs Zero = Zero
   | abs (Positive x) = Positive x
   | abs (Negative x) = range_check(Positive x, Abs_exn)
     
 fun (Positive x) + (Positive y) =range_check(Positive(addilists(x,y)),Sum_exn)
   | (Negative x) + (Negative y) =range_check(Negative(addilists(x,y)),Sum_exn)
   | (Positive x) + (Negative y) = 
     if x=y then Zero 
     else if (Positive x) > (Positive y) 
	    then range_check(Positive(subilists(x,y)),Sum_exn)
	  else range_check(Negative(subilists(y,x)),Sum_exn)
   | Zero         + anything     = anything
   | x + y = y + x
					     

 fun x - y = (x + (neg y)) handle Runtime "Sum" => raise Diff_exn


 fun Zero        * anything    = Zero
   | anything    * Zero        = Zero
   | (Positive x)*(Positive y) =range_check(Positive(multilists(x,y)),Prod_exn)
   | (Negative x)*(Negative y) =range_check(Positive(multilists(x,y)),Prod_exn)
   | (Positive x)*(Negative y) =range_check(Negative(multilists(x,y)),Prod_exn)
   | (Negative x)*(Positive y) =range_check(Negative(multilists(x,y)),Prod_exn)


 fun is_positive (Positive _) = true
   | is_positive _ = false


 local
   fun divit((u,v), sign) =
     if u=v then bigone
     else if ltilists(u,v) then Zero
	  else 
	    let 
	      val (quotient,_) = divilists(u,v)
	    in 
	      range_check (sign quotient, Runtime "div range")
	    end
 in
   fun            _ div Zero         = raise Div_exn
     |         Zero div _            = Zero
     | (Positive i) div (Positive d) = divit((i,d), Positive)
     | (Negative i) div (Negative d) = divit((i,d), Positive)
     | (Positive i) div (Negative d) =
       divit((subilists(i,[1]),d), Negative) - bigone
     | (Negative i) div (Positive d) =
       divit((subilists(i,[1]),d), Negative) - bigone
 end
d527 6
a532 4
 fun _ mod Zero = raise Mod_exn
   | i mod d    = i - d*(i div d)  (* instead, could use divilists, cf above *)

   
d534 1
a534 1
(*  for export  *)
d536 1
a536 1
exception Unrepresentable;
d538 1
a538 1
val string_to_bignum = fn s=>range_check(string_to_bignum s, Unrepresentable);
d540 1
a540 1
end;
@


1.7
log
@Changed the base integer size to 256 to ensure multiplications can be done
safely
@
text
@d6 4
d81 5
@


1.7.1.1
log
@Fork for bug fixing
@
text
@a5 4
Revision 1.7  1993/07/20  11:44:53  jont
Changed the base integer size to 256 to ensure multiplications can be done
safely

@


1.6
log
@Added require "crash". Disambiguated an integer <
@
text
@d6 3
d75 1
a75 1
 val base = 65536
@


1.5
log
@The case    Zero          < (Positive _) = true
was missed out
@
text
@d6 4
d26 1
d164 1
a164 1
	 | lt ([x],[y]) = x<y
@


1.4
log
@Added copyright message
@
text
@d5 4
a8 1
$Log:	_bignum.sml,v $
d373 1
@


1.3
log
@Now uses Crash.impossible instead of raising an exception.
@
text
@d1 1
d6 3
d16 1
@


1.2
log
@Added div and mod, fixed conversion
routines to cope with any base.
@
text
@d5 4
d16 4
a19 2
functor BigNumFun(val largest_int  : string
		  and smallest_int : string) : BIGNUM =
a71 4
 exception impossible of string;
 fun imposs s = raise impossible s;
   

d153 1
a153 1
	 | lt _ = imposs "ltilists"
d170 1
a170 1
      | hd []     = imposs "hd"
d173 1
a173 1
      | tl []      = imposs "tl"
d181 1
a181 1
	    | take(_, _, []) = imposs "split"
d236 1
a236 1
			      | _ => imposs "size of v in divilists"
d282 1
a282 1
		| well_hard (us,qs,jm) = imposs "well hard"
d301 1
a301 1
				imposs "base in b_to_s")::digs, q)
d340 1
a340 1
     else imposs "string_to_bignum: bad characters in string"
d449 9
a457 11
    fun divit((u,v), sign) = if u=v
				then bigone
			     else if ltilists(u,v)
				     then Zero
				  else 
				     let 
					val (quotient,_) = divilists(u,v)
				     in 
					range_check (sign quotient,
						     impossible "div range")
				     end
d459 8
a466 8
    fun            _ div Zero         = raise Div_exn
      |         Zero div _            = Zero
      | (Positive i) div (Positive d) = divit((i,d), Positive)
      | (Negative i) div (Negative d) = divit((i,d), Positive)
      | (Positive i) div (Negative d) = divit((subilists(i,[1]),d), Negative)
					      -bigone
      | (Negative i) div (Positive d) = divit((subilists(i,[1]),d), Negative)
					      -bigone
d480 1
a480 2
					        
end
@


1.1
log
@Initial revision
@
text
@d4 4
a7 1
$Log$
d53 2
a54 3
 val base = 1000;               (* NB! change to 1024 *)
 val bigone = Positive [1];
 val bigten = Positive [10];
a65 4
 infix 4  eq <>  <  >  <=  >=
 infix 6  +  -
 infix 7  div  mod  *

d71 8
d91 1
a91 1
     add ([], x, y, 0)
d109 1
a109 1
       sbt ([],x,y,0)
d130 1
a130 1
		   formpp ([],longlist,0)
d148 2
a149 1
       fun lt ([x],[y]) = x<y
a156 3
(* fun divilists(x:int list, y:int list) =
    let
       fun quot(acc,x::xs,carry) =
a157 1
*)
d159 2
d162 3
d166 3
d170 2
a171 1
 (*  converting to and from strings  *)
d173 1
a173 3
 fun bignum_to_string bn =
     let
	val divtimes = floor(ln (real(base))/(ln 10.0) + 0.5)
d175 8
a182 4
	fun convert (acc, i, n::ns) = convdig (acc, i*base+n, ns)
	  | convert (acc, i, []) = if i>0 
				       then convdig (acc, i*base, [])
				      else acc
d184 97
a280 4
	and convdig (acc, i, ns) =
	   let 
	      fun dodig (i,a,0) = convert(a@@acc,i,ns)
		| dodig (i,a,c) = dodig(i div 10, (i mod 10)::a, c-1)
d282 4
a285 2
	      dodig(i,[],divtimes)
	   end 
d287 15
d303 1
a303 1
						 (convert([],0,il))))
d312 1
a312 1
 fun string_to_bignum s =
d318 2
a319 2
     fun make_big (acc,next,m,[]) = rev (if next>0 then next::acc else acc)
       | make_big (acc,next,m,c::cs) = 
d321 3
a323 3
 	   val digval = ord(c)-ord("0")
	   val sum = next + (m * digval)
	   val (r,q) = (sum mod base, sum div base)
d325 1
a325 2
	   if q=0 then make_big(acc,r,10*m,cs)
	   else make_big(r::acc,q,10,cs)
d332 1
a332 1
		   val ilist = make_big ([],0,1,rev rest)
d342 10
a354 1

d384 9
a392 19
	 fun normalise x = 
	    let
	       fun norm l =
		  let 
		     fun strip_zero (0::xs) = strip_zero xs
		       | strip_zero xs = xs
		  in 
		     rev (strip_zero (rev l))
		  end
	    in
	       case x of 
		  Zero => Zero
		| (Positive l) => (case (norm l) of
				      [] => Zero
				    | _ => Positive (norm l))
		| (Negative l) => (case (norm l) of
				      [] => Zero
				    | _ => Negative (norm l))
	    end
d446 22
a467 11
 fun _ div Zero = raise Div_exn
   | x div y = Zero
(*
   let
     fun divit(count,remd) = if is_positive remd then divit(count + bigone,
							    remd - y)
			    else (count - bigone)
   in
     divit(Zero, x)
   end
*)
d470 1
a470 8
   | x mod y = Zero (* and this !! 
   let
     fun modit(count,remd) = if is_positive remd then modit(count + bigone,
							    remd - y)
			     else (count + y)
   in
      modit(Zero,x)
   end
a471 1
*)
a472 1

@
