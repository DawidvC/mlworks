head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.8
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.6
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.5.1.1.1.1
	MLWorks_workspace_97:1.6.7
	MLWorks_dt_wizard:1.6.6
	MLWorks_11c0_1997_09_09:1.6.5.1.1.1
	MLWorks_10r3:1.6.5.1.3
	MLWorks_10r2_551:1.6.5.1.2
	MLWorks_11:1.6.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.5.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.5
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.3.1.1
	MLWorks_gui_1996_12_18:1.6.4
	MLWorks_1_0_Win32_1996_12_17:1.6.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5
	ML_beta_release_12/08/94:1.3
	ML_beta_release_03/08/94:1.3
	ML_revised_beta_release_25/05/94:1.3
	ML_final_beta_release_02/03/94:1.3
	mlworks-28-01-1994:1.3
	Release:1.3
	mlworks-beta-01-09-1993:1.3;
locks; strict;
comment	@ * @;


1.6
date	96.11.01.12.18.31;	author io;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1;
next	1.5;

1.5
date	96.05.16.12.56.22;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	95.02.02.16.54.16;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	93.04.05.12.34.37;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	93.04.01.14.34.14;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	93.03.26.15.57.06;	author jont;	state Exp;
branches;
next	;

1.3.1.1
date	93.04.05.12.34.37;	author jont;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.19.47;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.09.40;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.27.59;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.12.53.36;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.15.04.32;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.12.31;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.17.51.00;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	97.02.24.11.41.29;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.18.09.45.13;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	97.05.12.10.37.43;	author hope;	state Exp;
branches
	1.6.5.1.1.1
	1.6.5.1.2.1
	1.6.5.1.3.1;
next	;

1.6.5.1.1.1
date	97.07.28.18.22.56;	author daveb;	state Exp;
branches
	1.6.5.1.1.1.1.1;
next	;

1.6.5.1.1.1.1.1
date	97.10.07.11.48.38;	author jkbrook;	state Exp;
branches;
next	;

1.6.5.1.2.1
date	97.09.08.17.16.19;	author daveb;	state Exp;
branches;
next	;

1.6.5.1.3.1
date	97.09.09.14.12.17;	author daveb;	state Exp;
branches;
next	;

1.6.6.1
date	97.09.10.19.28.20;	author brucem;	state Exp;
branches;
next	;

1.6.7.1
date	97.09.11.20.58.17;	author daveb;	state Exp;
branches;
next	;

1.6.8.1
date	99.04.01.17.58.51;	author daveb;	state Exp;
branches;
next	;


desc
@runtime script generator for stand alone ml programs
@


1.6
log
@[Bug #1614]
remove toplevel String.
@
text
@(* script.sml *)
(*
 *
 * runtime system script maker for ML
 *
 * $Log: script.sml,v $
 * Revision 1.5  1996/05/16  12:56:22  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
 * Revision 1.4  1995/02/02  16:54:16  jont
 * Modify in light of BTree changes
 * Still not correct following module naming changes
 *
Revision 1.3  1993/04/05  12:34:37  jont
Added code to deal with image contents

Revision 1.2  1993/04/01  14:34:14  jont
Added ability to make an image file from this

Revision 1.1  1993/03/26  15:57:06  jont
Initial revision

 * Copyright (c) 1993 Harlequin Ltd.
 *)

require "../utils/__option";
require "../utils/__btree";
require "../utils/__lists";
require "../main/__io";
require "../main/__info";
require "../main/__options";
require "../lexer/__lexer";

val output1 = "#!/bin/sh\nLIBDIR=/usr/local/lib/MLWorks\nBINDIR=/usr/local/lib/MLWorks/bin\nSCRIPTDIR=/usr/local/lib/MLWorks/bin\nRUNTIME=mlrunx\nexec $BINDIR/$RUNTIME -load "

fun get_imports_from_stream (error_info, ts, imports) =
  let
    val get = Lexer_.getToken error_info
  in
    case get(Options_.default_options, Lexer_.Token.PLAIN_STATE, ts) of
      Lexer_.Token.RESERVED Lexer_.Token.REQUIRE =>
	(case get(Options_.default_options, Lexer_.Token.PLAIN_STATE, ts) of
	   Lexer_.Token.STRING filename =>
	     (case get(Options_.default_options, Lexer_.Token.PLAIN_STATE, ts) of
		Lexer_.Token.RESERVED Lexer_.Token.SEMICOLON =>
		  ()
	      | _ =>
		  Info_.error' Info_.default_options
		  (Info_.RECOVERABLE,
		   Lexer_.locate ts,
		   "missing ; after require");
		  get_imports_from_stream (error_info, ts, filename :: imports)
		  )
	 | _ =>
	     Info_.error' Info_.default_options
	     (Info_.FATAL,
	      Lexer_.locate ts,
	      "missing string after require")
	     )
    | _ => imports
  end

fun get_imports error_info filename =
  let
    val stream = open_in filename
    val ts = Lexer_.mkFileTokenStream (stream, filename)
    val imports = get_imports_from_stream (error_info, ts, [])
  in
    close_in stream;
    imports
  end handle Io _ => []

exception bad_args of string

fun make_list(acc, [], _) = acc
  | make_list(acc as (load_list, name_map), file :: files_to_do, inprogress) =
    let
      val sml_name = Io_.sml_name file
      val comp_name = Io_.compilation_name sml_name
      val _ = case BTree_.tryApply'(inprogress, comp_name) of
	MLWorks.Option.NONE => ()
      | _ => raise bad_args ("Circularity at '" ^ sml_name ^ "'")
    in
      case BTree_.tryApply'(name_map, comp_name) of
	MLWorks.Option.NONE =>
	  let
	    val comp_path = Io_.compilation_path sml_name
	    (* Now accumulate all the requires of this files and prepend them *)
	    (* to the files_to_do list, add this file to the map and load_list *)
	    (* and recurse *)
	    val imports = get_imports Info_.default_options sml_name
	    val import_names =
	      map (fn name => Io_.relative_name(comp_path, name)) imports
	    val inprogress = BTree_.define(inprogress, comp_name, true)
	    val (load_list, name_map) =
	      Lists_.reducel
	      (fn (acc as (load_list, name_map), filename) =>
	       let
		 val co_name = Io_.compilation_name filename
	       in
		 case BTree_.tryApply'(name_map, co_name) of
		   MLWorks.Option.NONE =>
		     make_list(acc, [filename], inprogress)
		 | _ => acc
	       end)
	      (acc, import_names)
	  in
	    make_list((Io_.mo_name sml_name :: " " :: load_list,
		       BTree_.define(name_map, comp_name, true)), files_to_do, inprogress)
	  end
      | _ => make_list((load_list, name_map), files_to_do, inprogress)
    end

fun make_script(command_name, library, args_delim, ml_source) =
  let
    val (args_needed, delim) = case args_delim of
      Option_.PRESENT x => (true, x)
    | _ => (false, "")
    val (library, lib_string) = case library of
      Option_.PRESENT library => (library, library)
    | _ => (output(std_out, "No library specified, assuming '/usr/local/lib/MLWorks/images/pervasive.img'\n");
	    ("/usr/local/lib/MLWorks/images/pervasive.img", "$LIBDIR/images/pervasive.img"))
    val lib_names = MLWorks.Internal.Images.table library
      handle MLWorks.Internal.Images.Table string => raise bad_args string
    val lib_names = map (fn str => (str, true)) lib_names
    val files = implode(rev(#1(make_list(([], BTree_.from_list' ((op<):string*string->bool) lib_names),
					 [ml_source], BTree_.empty' ((op<):string*string->bool)))))
    val script = output1 ^ lib_string ^
      (if args_needed then " -pass " ^ delim ^ " $* " ^ delim else "") ^
	 files ^ "\n"
  in
    output(std_out, script)
  end

fun check_option(Option_.ABSENT, string) = string
  | check_option(_, _) = ""

fun do_help() =
  (output(std_out, "script args:\n");
   output(std_out, "-command <filename> : the name of the resulting command\n");
   output(std_out, "-library <filename> : the name of a library to be loaded\n");
   output(std_out, "-arg_delimiter <string> : a string which may be safely used as an argument delimiter\n");
   output(std_out, "-source <filename> : the top level source program.\n"))

fun obey([], Option_.PRESENT command_name, library, args_delim,
	 Option_.PRESENT ml_source) =
  make_script(command_name, library, args_delim, ml_source)
  | obey([], a, _, _, b) = raise bad_args
    ("Missing args:" ^ check_option(a, " -command") ^ check_option(b, " -source") ^ "\n")
  | obey(args, a, b, c, d) =
    (case args of
       (hd as "-command") :: x :: xs =>
	 (case a of
	    Option_.ABSENT => obey(xs, Option_.PRESENT x, b, c, d)
	  | _ => raise bad_args ("Option '" ^ hd ^ "' is already specified" ))
     | (hd as "-library") :: x :: xs =>
	 (case b of
	    Option_.ABSENT => obey(xs, a, Option_.PRESENT x, c, d)
	  | _ => raise bad_args ("Option '" ^ hd ^ "' is already specified" ))
     | (hd as "-arg_delimiter") :: x :: xs =>
	 (case c of
	    Option_.ABSENT => obey(xs, a, b, Option_.PRESENT x, d)
	  | _ => raise bad_args ("Option '" ^ hd ^ "' is already specified" ))
     | (hd as "-source") :: x :: xs =>
	 (case d of
	    Option_.ABSENT => obey(xs, a, b, c, Option_.PRESENT x)
	  | _ => raise bad_args ("Option '" ^ hd ^ "' is already specified" ))
     | "-help" :: _ => do_help()
     | x :: _ => raise bad_args ("Unknown option '" ^ x ^ "'or wrong arguments to '" ^ x)
     | _ => raise bad_args"Compiler error")

fun obey1 str_list =
  obey(str_list, Option_.ABSENT, Option_.ABSENT, Option_.ABSENT, Option_.ABSENT)
  handle bad_args string =>
    output(MLWorks.IO.std_err, "script: " ^ string ^ "\n")

fun obey2["-save", filename] =
  (MLWorks.save(filename, fn () => obey1(MLWorks.arguments()));
   ())
  | obey2 arg = (output(std_out, "Bad initial args\n");
		 Lists_.iterate (fn str => output(std_out, str ^ "\n")) arg;
		 ())

val _ = obey2(MLWorks.arguments());
@


1.6.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.6.5.1  1997/05/12  10:37:43  hope
 * branched from 1.6
 *
@


1.6.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.6.5.1  1997/05/12  10:37:43  hope
 * branched from 1.6
 *
@


1.6.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.6.5.1  1997/05/12  10:37:43  hope
 * branched from 1.6
 *
@


1.6.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.6.5.1.1.1  1997/07/28  18:22:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a6 3
 * Revision 1.6.3.1  1996/12/17  17:51:00  hope
 * branched from 1.6
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a6 4
 * Revision 1.6  1996/11/01  12:18:31  io
 * [Bug #1614]
 * remove toplevel String.
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a6 3
 * Revision 1.6.1.1  1996/11/14  12:53:36  hope
 * branched from 1.6
 *
@


1.5
log
@Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
@
text
@d7 3
d126 2
a127 2
    val files = implode(rev(#1(make_list(([], BTree_.from_list' String.< lib_names),
					 [ml_source], BTree_.empty' String.<))))
@


1.5.3.1
log
@branched from 1.5
@
text
@a6 3
 * Revision 1.5  1996/05/16  12:56:22  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a6 3
 * Revision 1.5  1996/05/16  12:56:22  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a6 3
 * Revision 1.5  1996/05/16  12:56:22  stephenb
 * Update wrt MLWorks.OS.arguments -> MLWorks.arguments change.
 *
@


1.4
log
@Modify in light of BTree changes
Still not correct following module naming changes
@
text
@d7 4
d175 1
a175 1
  (MLWorks.save(filename, fn () => obey1(MLWorks.OS.arguments()));
d181 1
a181 1
val _ = obey2(MLWorks.OS.arguments());
@


1.3
log
@Added code to deal with image contents
@
text
@d7 3
d74 1
a74 1
	BTree_.NO => ()
d78 1
a78 1
	BTree_.NO =>
d95 1
a95 1
		   BTree_.NO =>
@


1.3.1.1
log
@Fork for bug fixing
@
text
@a6 3
Revision 1.3  1993/04/05  12:34:37  jont
Added code to deal with image contents

@


1.2
log
@Added ability to make an image file from this
@
text
@d7 3
d113 5
a117 2
    val files = implode(rev(#1(make_list(([], BTree_.empty' String.<), [ml_source],
					 BTree_.empty' String.<))))
d128 7
d138 2
a139 4
  | obey([], a, _, _, b) =
    output(MLWorks.IO.std_err, "Missing args:" ^
	   check_option(a, " -command") ^
	   check_option(b, " -source") ^ "\n")
d158 1
d164 2
@


1.1
log
@Initial revision
@
text
@d6 4
a9 1
 * $Log$
d18 1
d24 25
a48 21
  case Lexer_.getToken error_info ts of
    Lexer_.Token.RESERVED Lexer_.Token.REQUIRE =>
      (case Lexer_.getToken error_info ts of
	 Lexer_.Token.STRING filename =>
	   (case Lexer_.getToken error_info ts of
	      Lexer_.Token.RESERVED Lexer_.Token.SEMICOLON =>
		()
	    | _ =>
		Info_.error' Info_.default_options
		(Info_.RECOVERABLE,
		 Lexer_.locate ts,
		 "missing ; after require");
		get_imports_from_stream (error_info, ts, filename :: imports)
		)
       | _ =>
	   Info_.error' Info_.default_options
	   (Info_.FATAL,
	    Lexer_.locate ts,
	    "missing string after require")
	   )
  | _ => imports
d153 6
a158 7
fun obey2 str_list =
  obey1 str_list
  handle bad_args x => output(MLWorks.IO.std_err, x ^ "\n")
	| exn => output(MLWorks.IO.std_err,
	    "Uncaught exception " ^
	    MLWorks.Internal.Value.exn_name_string
	    (MLWorks.Internal.Value.exn_name exn) ^ "\n")
d160 1
a160 6
val _ = obey1(MLWorks.OS.arguments())
  handle bad_args x => output(MLWorks.IO.std_err, x ^ "\n")
	| exn => output(MLWorks.IO.std_err,
	    "Uncaught exception " ^
	    MLWorks.Internal.Value.exn_name_string
	    (MLWorks.Internal.Value.exn_name exn) ^ "\n")
@
