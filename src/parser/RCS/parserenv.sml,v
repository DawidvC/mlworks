head	1.14;
access;
symbols
	MLW_daveb_inline_1_4_99:1.14.3
	MLWorks_21c0_1999_03_25:1.14
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.14
	MLWorks_20b2_Windows_1998_06_12:1.14
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.14
	MLWorks_20b0_1998_03_20:1.14
	MLWorks_20m2_1998_02_16:1.14
	MLWorks_20m1_1997_10_23:1.14
	MLWorks_11r1:1.13.5.1.1.1.1
	MLWorks_workspace_97:1.14.2
	MLWorks_dt_wizard:1.14.1
	MLWorks_11c0_1997_09_09:1.13.5.1.1.1
	MLWorks_10r3:1.13.5.1.3
	MLWorks_10r2_551:1.13.5.1.2
	MLWorks_11:1.13.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.5.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.13.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.5
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.3.1.1
	MLWorks_gui_1996_12_18:1.13.4
	MLWorks_1_0_Win32_1996_12_17:1.13.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.1.1
	MLWorks_1_0_Irix_1996_11_28:1.13.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.2
	MLWorks_1_0_Unix_1996_11_14:1.13.1
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12
	ML_beta_release_12/08/94:1.7
	ML_beta_release_03/08/94:1.7
	ML_revised_beta_release_25/05/94:1.7
	ML_final_beta_release_02/03/94:1.7
	mlworks-28-01-1994:1.7
	Release:1.7
	mlworks-beta-01-09-1993:1.7
	MLWorks-1-0-4-29/01/1993:1.6
	MLWorks-1-0-3-21/12/1992:1.6
	MLWorks-1-0-2-15/12/1992:1.6
	MLWorks-1-0-1-04/12/1992:1.6
	checkpoint_17_08_92:1.4
	Ten15_release_19-11-91:1.1.1.1
	Ten15_release_21-08-91:1.1
	Ten15_release_19-08-91:1.1
	ten15_release:1.1;
locks; strict;
comment	@ * @;


1.14
date	97.05.01.12.52.08;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	96.10.25.13.22.05;	author andreww;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1;
next	1.12;

1.12
date	96.03.19.14.26.46;	author matthew;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1;
next	1.11;

1.11
date	96.02.23.16.54.45;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.04.12.13.08.06;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.02.06.13.00.27;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	94.10.13.09.18.00;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.26.16.10.28;	author jont;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	92.08.26.13.02.32;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.08.18.17.40.39;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.12.17.15.54.46;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.37.24;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.19.12.21.19;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.16.18.22;	author colin;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	91.11.19.11.12.35;	author jont;	state Exp;
branches;
next	;

1.7.1.1
date	93.04.26.16.10.28;	author jont;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.20.36;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.10.33;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.29.05;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.11.14.12.54.50;	author hope;	state Exp;
branches
	1.13.1.1.1.1;
next	;

1.13.1.1.1.1
date	96.11.28.15.05.34;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.11.22.18.13.23;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.12.17.17.51.52;	author hope;	state Exp;
branches
	1.13.3.1.1.1;
next	;

1.13.3.1.1.1
date	97.02.24.11.42.33;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.12.18.09.46.11;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	97.05.12.10.38.40;	author hope;	state Exp;
branches
	1.13.5.1.1.1
	1.13.5.1.2.1
	1.13.5.1.3.1;
next	;

1.13.5.1.1.1
date	97.07.28.18.23.41;	author daveb;	state Exp;
branches
	1.13.5.1.1.1.1.1;
next	;

1.13.5.1.1.1.1.1
date	97.10.07.11.49.23;	author jkbrook;	state Exp;
branches;
next	;

1.13.5.1.2.1
date	97.09.08.17.17.03;	author daveb;	state Exp;
branches;
next	;

1.13.5.1.3.1
date	97.09.09.14.13.09;	author daveb;	state Exp;
branches;
next	;

1.14.1.1
date	97.09.10.19.29.13;	author brucem;	state Exp;
branches;
next	;

1.14.2.1
date	97.09.11.20.59.08;	author daveb;	state Exp;
branches;
next	;

1.14.3.1
date	99.04.01.17.59.32;	author daveb;	state Exp;
branches;
next	;


desc
@Parser Environment datatypes + manipulating functions
(Used to handle fixity and resolve identifier classes)
@


1.14
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* parserenv.sml the signature *)
(*
$Log: parserenv.sml,v $
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
 * Revision 1.12  1996/03/19  14:26:46  matthew
 * Adding unique_augment_pE
 *
 * Revision 1.11  1996/02/23  16:54:45  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.10  1995/04/12  13:08:06  matthew
 * Adding exception raising long valid lookup
 *
Revision 1.9  1995/02/06  13:00:27  matthew
Improving lookup error messages

Revision 1.8  1994/10/13  09:18:00  matthew
Added option-returning tryLookupValid

Revision 1.7  1993/04/26  16:10:28  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

Revision 1.6  1992/08/26  13:02:32  matthew
Changed error parameter to addValid etc.

Revision 1.5  1992/08/18  17:40:39  davidt
Removed Symbol structure from result and changed everything to use NewMap.

Revision 1.4  1991/12/17  15:54:46  jont
Added addFixity for updating a fixity env for the benefit of the
encapsulator

Revision 1.3  91/11/21  16:37:24  jont
Added copyright message

Revision 1.2  91/11/19  12:21:19  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.1.1.1  91/11/19  11:12:35  jont
Added comments for DRA on functions

Revision 1.1  91/06/07  16:18:22  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/map";
require "../basics/ident";

(* The parser must keep an environment, of the fixity and identifier
class of identifiers, in order to (a) parse expressions according to
the proper precedence and associativity of infixed operators, and (b)
enforce the first two syntactic restrictions in section 2.9 of the
Definition. (for instance, the first specifies "No pattern may contain
the same var twice". In order for the parser to check this, it must
distinguish between vars and cons.

This module defines datastructures for these environments, and
functions for manipulating them. The function names, and the sources,
are self-explanatory. *)

signature PARSERENV =
  sig
    structure Map   : MAP
    structure Ident : IDENT

    (* pFE is fixity environment *)
    (* pVE is valid environment  *)
    (* pTE is tycon environment: used to store pVE of datatype decs
           (so that they can be copied when parsing replicated datatypes)*)
    (* pSE is structure environment *)
    (* pE is parser environment *)
    (* pB is parser basis *)

    datatype Fixity = LEFT of int | RIGHT of int | NONFIX

    datatype 
      pFE = FE of (Ident.Symbol.Symbol,Fixity) Map.map
    and
      pVE = VE of (Ident.Symbol.Symbol,Ident.ValId) Map.map
    and 
      pTE = TE of (Ident.TyCon,pVE) Map.map
    and
      pSE = SE of (Ident.StrId,pE) Map.map
    and
      pE = E of (pFE * pVE * pTE * pSE)

    datatype
      pF = F of (Ident.FunId,pE) Map.map
    and
      pG = G of (Ident.SigId,pE * Ident.TyCon list) Map.map
      
    datatype pB = B of (pF * pG * pE)

    val empty_pFE : pFE
    val empty_pVE : pVE
    val empty_pTE : pTE
    val empty_pSE : pSE
    val empty_pE  : pE

    val builtins_pE: pE

    val augment_pE  : pE * pE -> pE
    val unique_augment_pE  : ((Ident.ValId -> unit) * 
                              (Ident.StrId -> unit)) * pE * pE -> pE

    val empty_pF : pF
    val empty_pG : pG
    val empty_pB : pB

    val augment_pF : pF * pF -> pF
    val augment_pG : pG * pG -> pG
    val augment_pB : pB * pB -> pB

    val remove_str : pB * Ident.StrId -> pB

    (* the lookup functions *)

    val lookupFixity : Ident.Symbol.Symbol * pE -> Fixity

    (* lookupFixity never raises Lookup - instead it returns NONFIX *)

    exception Lookup
    exception LookupStrId of Ident.Symbol.Symbol

    (* This one raises LookupStrId if a structure isn't defined *)
    val lookupValId :
      (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE -> 
      Ident.ValId option

    val tryLookupValId :
      (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE ->
      Ident.ValId option

    val lookupTycon :  Ident.LongTyCon  * pE -> pVE option

    val lookupStrId : (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE
                     -> pE

    val lookupFunId : (Ident.FunId * pB) -> pE
    val lookupSigId : (Ident.SigId * pB) -> pE * Ident.TyCon list

    val make_pFE : Ident.Symbol.Symbol list * Fixity -> pFE

    val addFixity : (Ident.Symbol.Symbol * Fixity) * pFE -> pFE

    (*
     * The functions passed as the first argument to the following
     * functions are called if there already exists a mapping for that
     * identifier.
     *)

    val addValId : (Ident.Symbol.Symbol * Ident.ValId * Ident.ValId ->
                    Ident.ValId) * Ident.ValId * pVE -> pVE
    val addTyCon :  (Ident.TyCon * pVE * pVE -> pVE) *
                     Ident.TyCon * pVE * pTE -> pTE
    val addStrId : (Ident.StrId * pE * pE -> pE) * Ident.StrId * pE * pSE 
                    -> pSE
    val addFunId : (Ident.FunId * pE * pE -> pE) * Ident.FunId * pE * pF -> pF
    val addSigId : (Ident.SigId * (pE * Ident.TyCon list) * 
                    (pE * Ident.TyCon list) -> 
                    (pE * Ident.TyCon list)) * Ident.SigId * pE * 
                    Ident.TyCon list * pG -> pG
  end;
@


1.14.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.14  1997/05/01  12:52:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.14.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.14  1997/05/01  12:52:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.14.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.14  1997/05/01  12:52:08  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.13
log
@[Bug #1686]
adding type constructor environment to parser environment (to
ensure replicated datatype constructors are seen as constructors)
@
text
@d4 5
d134 1
a134 1
      Ident.ValId MLWorks.Option.option
d138 1
a138 1
      Ident.ValId MLWorks.Option.option
d140 1
a140 1
    val lookupTycon :  Ident.LongTyCon  * pE -> pVE MLWorks.Option.option
@


1.13.5.1
log
@branched from 1.13
@
text
@a3 5
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
@


1.13.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:38:40  hope
 * branched from 1.13
 *
@


1.13.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:38:40  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.13.5.1  1997/05/12  10:38:40  hope
 * branched from 1.13
 *
@


1.13.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.13.5.1.1.1  1997/07/28  18:23:41  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a3 5
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a3 5
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
@


1.13.3.1.1.1
log
@branched from 1.13.3.1
@
text
@a3 3
 * Revision 1.13.3.1  1996/12/17  17:51:52  hope
 * branched from 1.13
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a3 5
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a3 5
 * Revision 1.13  1996/10/25  13:22:05  andreww
 * [Bug #1686]
 * adding type constructor environment to parser environment (to
 * ensure replicated datatype constructors are seen as constructors)
 *
@


1.13.1.1.1.1
log
@branched from 1.13.1.1
@
text
@a3 3
 * Revision 1.13.1.1  1996/11/14  12:54:50  hope
 * branched from 1.13
 *
@


1.12
log
@Adding unique_augment_pE
@
text
@d4 3
d69 2
d82 2
d86 1
a86 1
      pE = E of (pFE * pVE * pSE)
d97 1
d101 2
d104 2
a105 1
    val unique_augment_pE  : ((Ident.ValId -> unit) * (Ident.StrId -> unit)) * pE * pE -> pE
d128 2
a129 1
      (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE -> Ident.ValId MLWorks.Option.option
d132 4
a135 1
      (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE -> Ident.ValId MLWorks.Option.option
d137 2
a138 1
    val lookupStrId : (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE -> pE
d148 3
a150 2
     * The functions passed as the first argument to the following functions are called
     * if there already exists a mapping for that identifier.
d153 6
a158 2
    val addValId : (Ident.Symbol.Symbol * Ident.ValId * Ident.ValId -> Ident.ValId) * Ident.ValId * pVE -> pVE
    val addStrId : (Ident.StrId * pE * pE -> pE) * Ident.StrId * pE * pSE -> pSE
d160 4
a163 1
    val addSigId : (Ident.SigId * (pE * Ident.TyCon list) * (pE * Ident.TyCon list)-> (pE * Ident.TyCon list)) * Ident.SigId * pE * Ident.TyCon list * pG -> pG
@


1.12.3.1
log
@branched from 1.12
@
text
@a3 3
 * Revision 1.12  1996/03/19  14:26:46  matthew
 * Adding unique_augment_pE
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a3 3
 * Revision 1.12  1996/03/19  14:26:46  matthew
 * Adding unique_augment_pE
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a3 3
 * Revision 1.12  1996/03/19  14:26:46  matthew
 * Adding unique_augment_pE
 *
@


1.11
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d84 1
a84 1
      pG = G of (Ident.SigId,pE) Map.map
d94 1
d125 1
a125 1
    val lookupSigId : (Ident.SigId * pB) -> pE
d139 1
a139 1
    val addSigId : (Ident.SigId * pE * pE -> pE) * Ident.SigId * pE * pG -> pG
@


1.10
log
@Adding exception raising long valid lookup
@
text
@d4 3
d41 1
a41 1
require "../utils/newmap";
d58 1
a58 1
    structure Map   : NEWMAP
d70 1
a70 1
      pFE = FE of (Ident.Symbol.Symbol,Fixity) Map.T
d72 1
a72 1
      pVE = VE of (Ident.Symbol.Symbol,Ident.ValId) Map.T
d74 1
a74 1
      pSE = SE of (Ident.StrId,pE) Map.T
d79 1
a79 1
      pF = F of (Ident.FunId,pE) Map.T
d81 1
a81 1
      pG = G of (Ident.SigId,pE) Map.T
@


1.9
log
@Improving lookup error messages
@
text
@d4 3
d108 1
a108 1
(*
d110 1
a110 2
      (Ident.Symbol.Symbol list * Ident.Symbol.Symbol) * pE -> Ident.ValId
*)
@


1.8
log
@Added option-returning tryLookupValid
@
text
@d4 3
d103 1
d105 1
d108 1
@


1.7
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d4 3
d103 3
@


1.7.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.7  1993/04/26  16:10:28  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

@


1.6
log
@Changed error parameter to addValid etc.
@
text
@d4 3
d87 2
@


1.5
log
@Removed Symbol structure from result and changed everything to use NewMap.
@
text
@d4 3
d110 4
a113 4
    val addValId : (Ident.Symbol.Symbol -> Ident.ValId) * Ident.ValId * pVE -> pVE
    val addStrId : (Ident.StrId -> pE) * Ident.StrId * pE * pSE -> pSE
    val addFunId : (Ident.FunId -> pE) * Ident.FunId * pE * pF -> pF
    val addSigId : (Ident.SigId -> pE) * Ident.SigId * pE * pG -> pG
@


1.4
log
@Added addFixity for updating a fixity env for the benefit of the
encapsulator
@
text
@d3 5
a7 1
$Log:	parserenv.sml,v $
d22 2
a23 1
require "../utils/map";
a24 1
require "../basics/symbol";
d40 2
a41 4

    structure Map    : MAP
    structure Ident  : IDENT
    structure Symbol : SYMBOL
a42 2
    sharing Ident.Symbol = Symbol

d52 1
a52 1
      pFE = FE of (Symbol.Symbol,Fixity) Map.Map
d54 1
a54 1
      pVE = VE of (Symbol.Symbol,Ident.ValId) Map.Map
d56 1
a56 1
      pSE = SE of (Ident.StrId,pE) Map.Map
d61 1
a61 1
      pF = F of (Ident.FunId,pE) Map.Map
d63 1
a63 1
      pG = G of (Ident.SigId,pE) Map.Map
d84 1
a84 1
    val lookupFixity : Symbol.Symbol * pE -> Fixity
d91 1
a91 1
      (Symbol.Symbol list * Symbol.Symbol) * pE -> Ident.ValId
d93 1
a93 1
    val lookupStrId : (Symbol.Symbol list * Symbol.Symbol) * pE -> pE
d98 1
a98 7
    val make_pFE : Symbol.Symbol list * Fixity -> pFE

    exception Seen

    val addFixity : (Symbol.Symbol * Fixity) * pFE -> pFE
    val addValId : Ident.ValId * pVE -> pVE
    val addStrId : (Ident.StrId * pE) * pSE -> pSE
d100 1
a100 2
    val addFunId : (Ident.FunId * pE) * pF -> pF
    val addSigId : (Ident.SigId * pE) * pG -> pG
d102 10
a111 1
  end
@


1.3
log
@Added copyright message
@
text
@d4 3
d102 1
@


1.2
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d13 1
@


1.1
log
@Initial revision
@
text
@d2 7
a8 1
$Log$
d14 11
a24 1
(* parser environment stuff *)
@


1.1.1.1
log
@Added comments for DRA on functions
@
text
@d2 1
a2 4
$Log:	parserenv.sml,v $
Revision 1.1  91/06/07  16:18:22  colin
Initial revision

d8 1
a8 11
(* The parser must keep an environment, of the fixity and identifier
class of identifiers, in order to (a) parse expressions according to
the proper precedence and associativity of infixed operators, and (b)
enforce the first two syntactic restrictions in section 2.9 of the
Definition. (for instance, the first specifies "No pattern may contain
the same var twice". In order for the parser to check this, it must
distinguish between vars and cons.

This module defines datastructures for these environments, and
functions for manipulating them. The function names, and the sources,
are self-explanatory. *)
@
