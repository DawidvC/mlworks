head	1.95;
access;
symbols
	MLW_daveb_inline_1_4_99:1.95.1
	MLWorks_21c0_1999_03_25:1.95
	MLWorks_20c1_1998_08_20:1.94
	MLWorks_20c0_1998_08_04:1.94
	MLWorks_20b2c2_1998_06_19:1.94
	MLWorks_20b2_Windows_1998_06_12:1.94
	MLWorks_20b1c1_1998_05_07:1.94
	MLWorks_20b0_1998_04_07:1.94
	MLWorks_20b0_1998_03_20:1.94
	MLWorks_20m2_1998_02_16:1.91
	MLWorks_20m1_1997_10_23:1.90
	MLWorks_11r1:1.85.1.2.1.2.1
	MLWorks_workspace_97:1.89.2
	MLWorks_dt_wizard:1.89.1
	MLWorks_11c0_1997_09_09:1.85.1.2.1.2
	MLWorks_10r3:1.85.1.2.3
	MLWorks_10r2_551:1.85.1.2.2
	MLWorks_11:1.85.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.85.1.2
	MLWorks_20m0_1997_06_20:1.88
	MLWorks_1_0_r2c2_1997_06_14:1.85.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.85.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.85.1
	MLWorks_BugFix_1997_04_24:1.85
	MLWorks_1_0_r2_Win32_1997_04_11:1.85
	MLWorks_1_0_r2_Unix_1997_04_04:1.85
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.84.3.1.1
	MLWorks_gui_1996_12_18:1.84.4
	MLWorks_1_0_Win32_1996_12_17:1.84.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.84.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.84.1.1
	MLWorks_1_0_Irix_1996_11_28:1.84.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.84.2
	MLWorks_1_0_Unix_1996_11_14:1.84.1
	MLWorks_Open_Beta2_1996_10_11:1.79.1
	MLWorks_License_dev:1.78.1
	MLWorks_1_open_beta_1996_09_13:1.76.1
	MLWorks_Open_Beta_1996_08_22:1.76
	MLWorks_Beta_1996_07_02:1.76
	MLWorks_Beta_1996_06_07:1.76
	MLWorks_Beta_1996_06_06:1.76
	MLWorks_Beta_1996_06_05:1.76
	MLWorks_Beta_1996_06_03:1.76
	MLWorks_Beta_1996_05_31:1.76
	MLWorks_Beta_1996_05_30:1.76
	ML_beta_release_12/08/94:1.51
	ML_beta_release_03/08/94:1.51
	ML_revised_beta_release_25/05/94:1.50
	ML_final_beta_release_02/03/94:1.47
	mlworks-28-01-1994:1.45
	Release:1.38
	mlworks-beta-01-09-1993:1.38
	MLWorks-1-0-4-29/01/1993:1.15
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.11;
locks; strict;
comment	@ * @;


1.95
date	99.02.02.16.01.35;	author mitchell;	state Exp;
branches
	1.95.1.1;
next	1.94;

1.94
date	98.02.27.10.41.14;	author mitchell;	state Exp;
branches;
next	1.93;

1.93
date	98.02.19.16.35.19;	author mitchell;	state Exp;
branches;
next	1.92;

1.92
date	98.02.17.13.05.18;	author mitchell;	state Exp;
branches;
next	1.91;

1.91
date	98.02.02.16.00.48;	author mitchell;	state Exp;
branches;
next	1.90;

1.90
date	97.09.18.16.03.25;	author brucem;	state Exp;
branches;
next	1.89;

1.89
date	97.07.31.12.28.18;	author daveb;	state Exp;
branches
	1.89.1.1
	1.89.2.1;
next	1.88;

1.88
date	97.05.19.12.30.11;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	97.05.07.14.53.47;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	97.05.06.10.17.17;	author andreww;	state Exp;
branches;
next	1.85;

1.85
date	96.11.28.16.11.48;	author andreww;	state Exp;
branches
	1.85.1.1;
next	1.84;

1.84
date	96.11.06.12.46.05;	author andreww;	state Exp;
branches
	1.84.1.1
	1.84.2.1
	1.84.3.1
	1.84.4.1;
next	1.83;

1.83
date	96.11.04.16.03.55;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	96.10.30.18.57.31;	author io;	state Exp;
branches;
next	1.81;

1.81
date	96.10.29.12.58.12;	author andreww;	state Exp;
branches;
next	1.80;

1.80
date	96.10.25.13.53.39;	author andreww;	state Exp;
branches;
next	1.79;

1.79
date	96.10.04.17.52.44;	author andreww;	state Exp;
branches
	1.79.1.1;
next	1.78;

1.78
date	96.10.04.11.00.11;	author matthew;	state Exp;
branches
	1.78.1.1;
next	1.77;

1.77
date	96.09.20.14.49.47;	author andreww;	state Exp;
branches;
next	1.76;

1.76
date	96.05.09.09.51.19;	author daveb;	state Exp;
branches
	1.76.1.1;
next	1.75;

1.75
date	96.05.07.10.37.10;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	96.04.30.15.14.37;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	96.04.01.09.51.32;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	96.03.26.16.26.54;	author matthew;	state Exp;
branches;
next	1.71;

1.71
date	96.03.19.14.51.54;	author matthew;	state Exp;
branches;
next	1.70;

1.70
date	96.01.16.12.28.06;	author daveb;	state Exp;
branches;
next	1.69;

1.69
date	95.12.27.10.51.43;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	95.11.22.09.14.02;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	95.09.11.11.02.32;	author daveb;	state Exp;
branches;
next	1.66;

1.66
date	95.09.08.11.04.40;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	95.08.31.13.32.27;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	95.07.28.14.28.22;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	95.07.24.16.07.39;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	95.07.19.11.59.18;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	95.05.12.14.38.35;	author matthew;	state Exp;
branches;
next	1.60;

1.60
date	95.04.12.13.39.45;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	95.04.10.15.27.04;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	95.03.08.17.26.41;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	95.02.14.12.39.49;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.02.06.14.27.35;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	95.01.17.12.58.39;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	94.11.16.10.27.20;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	94.10.13.09.36.15;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	94.09.15.10.08.21;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	94.06.14.16.23.37;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	94.05.09.16.12.08;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	94.04.22.15.12.25;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.03.18.12.55.45;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.02.22.01.36.10;	author nosa;	state Exp;
branches;
next	1.46;

1.46
date	94.02.02.12.30.44;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	93.12.10.16.13.05;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	93.12.08.10.57.59;	author nickh;	state Exp;
branches;
next	1.43;

1.43
date	93.12.03.16.50.34;	author nickh;	state Exp;
branches;
next	1.42;

1.42
date	93.11.25.09.35.31;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	93.11.09.11.44.55;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.10.08.15.51.21;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.09.03.10.25.28;	author nosa;	state Exp;
branches;
next	1.38;

1.38
date	93.08.27.15.19.03;	author matthew;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	93.08.26.11.13.25;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	93.08.24.14.09.03;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	93.08.12.16.10.00;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.08.06.14.14.51;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.07.09.12.08.56;	author nosa;	state Exp;
branches;
next	1.32;

1.32
date	93.07.02.17.20.57;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.07.02.13.35.42;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.06.15.13.34.05;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.06.10.13.25.18;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.05.24.15.41.47;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.05.18.19.16.35;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	93.05.17.15.45.29;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.05.14.18.24.34;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.04.26.16.18.14;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.04.06.11.54.39;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.03.29.11.11.21;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.03.09.11.23.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.02.24.12.59.22;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.23.13.55.17;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.02.18.10.59.29;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.02.08.19.30.14;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.01.22.16.41.55;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.12.22.10.37.17;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.12.21.19.09.32;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.12.18.11.30.56;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.12.08.15.16.36;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.12.02.17.17.27;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.12.01.14.21.11;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.11.26.19.36.08;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	92.11.24.19.49.27;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	92.11.19.19.25.43;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.11.05.16.11.16;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.10.14.12.03.17;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.10.09.13.41.06;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.09.09.13.54.52;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	92.09.04.09.11.59;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.08.25.15.23.34;	author matthew;	state Exp;
branches;
next	;

1.38.1.1
date	93.08.27.15.19.03;	author jont;	state Exp;
branches;
next	1.38.1.2;

1.38.1.2
date	93.10.06.15.20.06;	author matthew;	state Exp;
branches;
next	1.38.1.3;

1.38.1.3
date	93.10.22.11.31.17;	author daveb;	state Exp;
branches;
next	;

1.76.1.1
date	96.09.13.11.20.34;	author hope;	state Exp;
branches;
next	;

1.78.1.1
date	96.10.07.16.10.31;	author hope;	state Exp;
branches;
next	;

1.79.1.1
date	96.10.17.11.29.02;	author hope;	state Exp;
branches;
next	;

1.84.1.1
date	96.11.14.12.54.47;	author hope;	state Exp;
branches
	1.84.1.1.1.1;
next	;

1.84.1.1.1.1
date	96.11.28.15.05.32;	author hope;	state Exp;
branches;
next	;

1.84.2.1
date	96.11.22.18.13.21;	author hope;	state Exp;
branches;
next	;

1.84.3.1
date	96.12.17.17.51.49;	author hope;	state Exp;
branches
	1.84.3.1.1.1;
next	;

1.84.3.1.1.1
date	97.02.24.11.42.30;	author hope;	state Exp;
branches;
next	;

1.84.4.1
date	96.12.18.09.46.09;	author hope;	state Exp;
branches;
next	;

1.85.1.1
date	97.05.12.10.38.38;	author hope;	state Exp;
branches;
next	1.85.1.2;

1.85.1.2
date	97.05.14.14.13.31;	author daveb;	state Exp;
branches
	1.85.1.2.1.1
	1.85.1.2.2.1
	1.85.1.2.3.1;
next	;

1.85.1.2.1.1
date	97.07.28.18.23.38;	author daveb;	state Exp;
branches;
next	1.85.1.2.1.2;

1.85.1.2.1.2
date	97.08.11.12.11.03;	author daveb;	state Exp;
branches
	1.85.1.2.1.2.1.1;
next	;

1.85.1.2.1.2.1.1
date	97.10.07.11.49.21;	author jkbrook;	state Exp;
branches;
next	;

1.85.1.2.2.1
date	97.09.08.17.17.01;	author daveb;	state Exp;
branches;
next	;

1.85.1.2.3.1
date	97.09.09.14.13.07;	author daveb;	state Exp;
branches;
next	;

1.89.1.1
date	97.09.10.19.29.11;	author brucem;	state Exp;
branches;
next	;

1.89.2.1
date	97.09.11.20.59.06;	author daveb;	state Exp;
branches;
next	;

1.95.1.1
date	99.04.01.17.59.31;	author daveb;	state Exp;
branches;
next	;


desc
@Semantic functions for parser
@


1.95
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _actionfunctions.sml functor *)
(*
$Log: _actionfunctions.sml,v $
 * Revision 1.94  1998/02/27  10:41:14  mitchell
 * [Bug #30352]
 * Prune parser value environment after abstype
 *
 * Revision 1.93  1998/02/19  16:35:19  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.92  1998/02/17  13:05:18  mitchell
 * [Bug #30341]
 * Correct derived form of where in grammar
 *
 * Revision 1.91  1998/02/02  16:00:48  mitchell
 * [Bug #50015]
 * Add missing call to check_rec_bindings
 *
 * Revision 1.90  1997/09/18  16:03:25  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.89  1997/07/31  12:28:18  daveb
 * [Bug #30209]
 * Added type constructor environments for datatype specifications.
 *
 * Revision 1.88  1997/05/19  12:30:11  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.87  1997/05/07  14:53:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.86  1997/05/06  10:17:17  andreww
 * [Bug #30110]
 * Handling LookupStrId exception in datatype replication properly.
 *
 * Revision 1.85  1996/11/28  16:11:48  andreww
 * [Bug #1759]
 * Allowing constructor rebinding when in a val rec binding and
 * also in a funbind.
 *
 * Revision 1.84  1996/11/06  12:46:05  andreww
 * [Bug #1711]
 * forbidding real literals as patterns in SML'96 mode.
 *
 * Revision 1.83  1996/11/04  16:03:55  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.82  1996/10/30  18:57:31  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.81  1996/10/29  12:58:12  andreww
 * [Bug #1708]
 * Altering the syntax of datatype replication: no tyvarseqs available.
 *
 * Revision 1.80  1996/10/25  13:53:39  andreww
 * [Bug #1686]
 * Removing use of "is constructor" tests --- these are done in typechecker
 * anyway, and they don't take into account replicated constructors.
 *
 * Revision 1.79  1996/10/04  17:52:44  andreww
 * [Bug #1592]
 * threading locations in Absyn.LOCALexp
 *
 * Revision 1.78  1996/10/04  11:00:11  matthew
 * [Bug #1622]
 * Adding some locations to datatype descriptors
 *
 * Revision 1.77  1996/09/20  14:49:47  andreww
 * [Bug #1577]
 * Adding function "check_same_tyvars" that implements the syntactic restriction
 * on datatype replication.
 *
 * Revision 1.76  1996/05/09  09:51:19  daveb
 * Improved error message for "op".
 *
 * Revision 1.75  1996/05/07  10:37:10  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.74  1996/04/30  15:14:37  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.73  1996/04/01  09:51:32  matthew
 * Adding type abbreviations
 *
 * Revision 1.72  1996/03/26  16:26:54  matthew
 * Updating for new language
 *
 * Revision 1.71  1996/03/19  14:51:54  matthew
 * New language definition
 *
 * Revision 1.70  1996/01/16  12:28:06  daveb
 * Added location information to Absyn.SIGNATUREtopdec.
 *
Revision 1.69  1995/12/27  10:51:43  jont
Removing Option in favour of MLWorks.Option

Revision 1.68  1995/11/22  09:14:02  daveb
Changed Absyn.REQUIREtopdec to take a string instead of a module_id.

Revision 1.67  1995/09/11  11:02:32  daveb
Added types for different lengths of words, ints and reals.

Revision 1.66  1995/09/08  11:04:40  matthew
Improving error message for fun nil x = x;

Revision 1.65  1995/08/31  13:32:27  jont
Add location info to wild pats

Revision 1.64  1995/07/28  14:28:22  matthew
Disallowing = as a strid etc.

Revision 1.63  1995/07/24  16:07:39  jont
Adding literal words

Revision 1.62  1995/07/19  11:59:18  jont
Adding CHAR to grammar

Revision 1.61  1995/05/12  14:38:35  matthew
Adding more checks for error ids

Revision 1.60  1995/04/12  13:39:45  matthew
Add information about unbound structure identifiers in LONGVALIDs

Revision 1.59  1995/04/10  15:27:04  matthew
Problems with infix function definitions

Revision 1.58  1995/03/08  17:26:41  matthew
Improving error messages

Revision 1.57  1995/02/14  12:39:49  matthew
Need to check an exbind is to an exception constructor

Revision 1.56  1995/02/06  14:27:35  matthew
Improving lookup errors

Revision 1.55  1995/01/17  12:58:39  matthew
Rationalizing debugger
/

Revision 1.54  1994/11/16  10:27:20  matthew
Fixed problem with IfStarStack being raise
(d)

Revision 1.53  1994/10/13  09:36:15  matthew
Efficiency improvements to lookup

Revision 1.52  1994/09/15  10:08:21  matthew
Added make_id_value and print_token
Abstraction of  debug information

Revision 1.51  1994/06/14  16:23:37  jont
Modified check_rec_bindings to check the pattern being bound
for constructors, in order to get better error messages

Revision 1.50  1994/05/09  16:12:08  jont
Modify effect of fixiy in open to be more sensible

Revision 1.49  1994/04/22  15:12:25  matthew
Fixed abstractions for the second time.

Revision 1.48  1994/03/18  12:55:45  matthew
Added check for exception constructor status in "excon = excon" clause

Revision 1.47  1994/02/22  01:36:10  nosa
Type function, debugger structure, and structure recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.

Revision 1.46  1994/02/02  12:30:44  daveb
Changed from_unix_string to from_require_string.

Revision 1.45  1993/12/10  16:13:05  matthew
Parse abstractions as abstractions (again!).

Revision 1.44  1993/12/08  10:57:59  nickh
Pass Info.options to the withtype derived functions.

Revision 1.43  1993/12/03  16:50:34  nickh
Added location information to COERCEexp.

Revision 1.42  1993/11/25  09:35:31  matthew
Added fixity annotations to abstract syntax
;

Revision 1.41  1993/11/09  11:44:55  daveb
Incorporated bug fix.

Revision 1.40  1993/10/08  15:51:21  matthew
Bug fixing

Revision 1.39  1993/09/03  10:25:28  nosa
Instances for polymorphic debugger.

Revision 1.38.1.2  1993/10/06  15:20:06  matthew
Added check on multiple occurences of variables in infix function declarations

Revision 1.38.1.1  1993/08/27  15:19:03  jont
Fork for bug fixing

Revision 1.38  1993/08/27  15:19:03  matthew
Improved message for undefined constructors in patterns

Revision 1.37  1993/08/26  11:13:25  daveb
Wired up nj_op_in_datatype option.

Revision 1.36  1993/08/24  14:09:03  daveb
Use new ModuleId.create to check that moduleids are alphanumeric.

Revision 1.35  1993/08/12  16:10:00  daveb
Require declarations now take moduleids instead of strings.

Revision 1.34  1993/08/06  14:14:51  matthew
Added location information to matches

Revision 1.33  1993/07/09  12:08:56  nosa
structure Option.

Revision 1.32  1993/07/02  17:20:57  daveb
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.

Revision 1.31  1993/07/02  13:35:42  matthew
Fixed problem with undefined structure names in signatures.

Revision 1.30  1993/06/15  13:34:05  matthew
Changed to allow no semicolons between topdecs

Revision 1.29  1993/06/10  13:25:18  matthew
Extended grammar for NJ compatibility

Revision 1.28  1993/05/24  15:41:47  matthew
Added code for abstractions.

Revision 1.27  1993/05/18  19:16:35  jont
Removed integer parameter

Revision 1.26  1993/05/17  15:45:29  jont
Modified to allow options to determine association of two different equal
precedence right associative operators

Revision 1.25  1993/05/14  18:24:34  jont
Added New Jersey interpretation of weak type variables under option control

Revision 1.24  1993/04/26  16:18:14  matthew
 Changed format of debug_info strings.

Revision 1.23  1993/04/06  11:54:39  matthew
Change to DYNAMICexp absyn

Revision 1.22  1993/03/29  11:11:21  daveb
Minor changes to reflect addition of Lexerstate to _token.
Minor improvements to error messages.

Revision 1.21  1993/03/09  11:23:17  matthew
Options & Info changes

Revision 1.20  1993/02/24  12:59:22  matthew
Changed warning on unbound signature to an error

Revision 1.19  1993/02/23  13:55:17  matthew
Changed interface to Derived to pass a pE for some functions

Revision 1.18  1993/02/18  10:59:29  matthew
Changes for dynamic and coerce expressions
 Changed to improve error detection

Revision 1.17  1993/02/08  19:30:14  matthew
ref Nameset removed from FunBind abstract syntax

Revision 1.16  1993/01/22  16:41:55  matthew
Changed sigexps
Fixed integer label bug
Changed asterisk tycon error to be an ordinary error.

Revision 1.15  1992/12/22  10:37:17  matthew
Put back marks in SCONs

Revision 1.14  1992/12/21  19:09:32  matthew
Changed location in scons to UNKNOWNs

Revision 1.13  1992/12/18  11:30:56  matthew
Changed int and real scons to carry a location around

Revision 1.12  1992/12/08  15:16:36  jont
Removed a number of duplicated signatures and structures

Revision 1.11  1992/12/02  17:17:27  matthew
Fixed more error messages

Revision 1.10  1992/12/01  14:21:11  matthew
Changed error messages

Revision 1.9  1992/11/26  19:36:08  daveb
 Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.8  1992/11/24  19:49:27  matthew
Fixed parsing bugs
with rec and abstype

Copyright (c) 1992 Harlequin Ltd.
*)

require "^.basis.__string";
require "../utils/lists";
require "../utils/set";
require "../basics/identprint";
require "../basics/token";
require "../parser/derived";
require "../utils/crash";
require "LRbasics";
require "actionfunctions";

functor ActionFunctions (
  structure LRbasics : LRBASICS
  structure Derived : DERIVED
  structure Lists : LISTS
  structure IdentPrint : IDENTPRINT
  structure Token : TOKEN
  structure Crash : CRASH
  structure Set : SET

  sharing Set = Derived.Absyn.Set
  sharing Derived.Absyn.Ident.Symbol = Token.Symbol
  sharing Derived.PE.Ident = IdentPrint.Ident
) : ACTIONFUNCTIONS =

struct

(* structures exported *)
structure Token = Token
structure Absyn = Derived.Absyn
structure LRbasics = LRbasics
structure PE = Derived.PE
structure Info = Derived.Info
structure Options = IdentPrint.Options

(* Internal structures *)
structure Map = PE.Map
structure Location = Info.Location
structure Absyn = Derived.Absyn
structure Ident = Absyn.Ident
structure Location = Ident.Location
structure Symbol = Ident.Symbol
(* types exported *)
type ParserBasis = PE.pB;

(* the parsed_object type *)
local
  type TyVarSet = Ident.TyVar Set.Set
  type TyVarList = Ident.TyVar list
  type PatExp = Absyn.Pat * Absyn.Exp * Location.T
  type PatExpMark = Absyn.Pat * Absyn.Exp * Location.T
  type TypeRef = Absyn.Type ref
  type ConBind = ((Ident.ValId * TypeRef) * Absyn.Ty option)
  type FVal = Ident.ValId * Absyn.Pat list * Absyn.Exp * Location.T
  type LabExp = Ident.Lab * Absyn.Exp
  type LabPat = Ident.Lab * Absyn.Pat
  type ConType = Ident.ValId * Absyn.Ty option * Location.T
  type ExType = Ident.ValId * Absyn.Ty option * Location.T
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * (Absyn.SigExp * bool) option * string * bool ref * Location.T * Absyn.DebuggerStr ref option * Absyn.Structure option ref option)
  type DatBind = TyVarList * Ident.TyCon * TypeRef  * Absyn.Tyfun ref option * ConBind list
in
datatype Parsed_Object =
  (* Store the environment *)
    ENV of PE.pE

  (* id tokens *)
  | LONGID of Symbol.Symbol list * Symbol.Symbol
  (* parsed identifiers *)
  | LONGVALID of Ident.LongValId * string option
  | SYM of Symbol.Symbol
  | FUNID of Ident.FunId
  | STRID of Ident.StrId
  | SIGID of Ident.SigId
  | LONGSTRID of Ident.LongStrId
  | LONGTYCON of Ident.LongTyCon
  | LAB of Ident.Lab
  | SCON of Ident.SCon
  | TYVAR of Ident.TyVar
  | VALID of Ident.ValId
  | TYCON of Ident.TyCon

  (* Basic constants *)
  | INTEGER of string
  | REAL of string
  | STRING of string
  | CHAR of string
  | WORD of string

  | BOOL of bool	

  (* Abstract syntax *)
  | EXP of Absyn.Exp * TyVarSet
  | DEC of Absyn.Dec * PE.pE * TyVarSet
  | CONBIND of ConBind list * PE.pVE * TyVarSet
  | CONBIND1 of ConBind * Ident.ValId * TyVarSet
  | DATAHDR of TyVarList * Ident.TyCon
  | DATREPL of TyVarList * Ident.TyCon * Ident.LongTyCon
  | DATBIND of DatBind list * PE.pVE * PE.pTE
  | DATBIND1 of DatBind * PE.pVE * PE.pTE
  | PAT of Absyn.Pat * PE.pVE * TyVarSet
  | BINPAT of Absyn.Pat * Ident.ValId * Absyn.Pat * PE.pVE * TyVarSet
  | TY of Absyn.Ty * TyVarSet

  (* Modules *)
  | STRDEC of Absyn.StrDec * PE.pE
  | STRDECLIST of Absyn.StrDec list * PE.pE
  | STREXP of Absyn.StrExp * PE.pE
  | SIGEXP of Absyn.SigExp * (PE.pE * Ident.TyCon list)
  | SPEC of Absyn.Spec * (PE.pE * Ident.TyCon list)
  | SHAREQ of (Absyn.SharEq * Location.T) list
  | SIGBIND of (Ident.SigId * Absyn.SigExp * Location.T) list * PE.pG
  | FUNBIND of FunBind list * PE.pF
  | TOPDEC of Absyn.TopDec * PE.pB
  | EXBIND of Absyn.ExBind list * PE.pVE * TyVarSet
  | EXBIND1 of Absyn.ExBind * Ident.ValId * TyVarSet

  (* Auxiliary module structures *)

  | VALDESC of (Ident.ValId * Absyn.Ty * TyVarSet) list * PE.pVE
  | TYPDESC of (TyVarList * Ident.TyCon * (Absyn.Ty * TyVarSet) option) list
  | DATDESC of (TyVarList * Ident.TyCon * (ConType list)) list * PE.pVE * PE.pTE
  | DATREPLDESC of (TyVarList * Ident.TyCon * Ident.LongTyCon)
  | DATDESC1 of (TyVarList * Ident.TyCon * (ConType list)) * PE.pVE * PE.pTE
  | CONDESC of ConType list * PE.pVE * TyVarSet
  | EXDESC of ExType list * PE.pVE
  | EXDESC1 of ExType
  | STRDESC of (Ident.StrId * Absyn.SigExp) list * PE.pSE
  | STRDESC1 of Ident.StrId * Absyn.SigExp * PE.pE
  | STRBIND  of ((Ident.StrId * (Absyn.SigExp * bool) option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref option * Absyn.Structure option ref option) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * (Absyn.SigExp * bool) option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref option * Absyn.Structure option ref option) * (Ident.StrId * PE.pE))
  | FUNDEC of Absyn.FunBind list * PE.pF
  | SIGDEC of Absyn.SigBind list * PE.pG
  | FUNBIND1 of FunBind * Ident.FunId * PE.pE
  | STARTFUNBIND1 of Ident.FunId * PE.pE * Ident.StrId * Absyn.SigExp * PE.pE
  | STARTFUNBIND2 of Ident.FunId * PE.pE * Absyn.Spec * PE.pE
  | FUNIDBIND of Ident.FunId * PE.pE

  (* Auxiliary structures *)
  | LONGIDLIST of (Symbol.Symbol list * Symbol.Symbol) list
  | DECLIST of Absyn.Dec list * PE.pE * TyVarSet
  | EXPLIST of Absyn.Exp list * TyVarSet
  | EXPSEQ of (Absyn.Exp * string * Location.T) list * TyVarSet
  | EXPROW of LabExp list * TyVarSet
  | LONGSTRIDLIST of Ident.LongStrId list
  | LONGTYCONLIST of Ident.LongTyCon list
  | SIGIDLIST of Ident.SigId list
  | TYLIST of Absyn.Ty list * TyVarSet
  | TYVARLIST of TyVarList
  | TYROW of (Ident.Lab * Absyn.Ty) list * TyVarSet
  | PATROW1 of LabPat * PE.pVE * TyVarSet
  | PATROW of (LabPat list) * bool * PE.pVE * TyVarSet
  | PATLIST of Absyn.Pat list * PE.pVE * TyVarSet
  | SYMLIST of Symbol.Symbol list
  | MRULE of PatExp * TyVarSet
  | MATCH of PatExp list * TyVarSet
  | VALBIND of PatExpMark list * PatExpMark list * TyVarSet * PE.pVE
  | TYPBIND of (TyVarList * Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref option) list
  | LONGTYPBIND of (TyVarList * Ident.LongTyCon * Absyn.Ty * Location.T) list
  | FVAL of (FVal * TyVarSet) * Ident.ValId
  | FVALLIST of FVal list * TyVarSet * Ident.ValId * Location.T
  | FVALBIND of ((FVal list * (string -> string) * Location.T) list * TyVarSet) * PE.pVE
  | NULLTYPE   (* represents absent types *)
  | LABEXP of LabExp * TyVarSet
  | OPPRESENT
  | DUMMY
  | EQVAL
  | LOCATION of Location.T
  | OPTsigexp of Absyn.SigExp option
(*  | OPTOFTYPE of Absyn.Ty option *)
end


datatype ActionOpts = OPTS of (Location.T * Info.options * Options.options)

fun get_location (OPTS(l,_,_)) = l
fun options_of (OPTS(_,x,_)) = x
fun options_of' (OPTS(_,_,x)) = x
fun print_options_of (OPTS(_,_,Options.OPTIONS{print_options,...})) = print_options
fun compat_options_of (OPTS(_,_,Options.OPTIONS{compat_options,...})) = compat_options

fun op_optional (OPTS(_,_,Options.OPTIONS
			    {compat_options = Options.COMPATOPTIONS x, ...})) =
  #nj_op_in_datatype x


fun generate_moduler(OPTS(_,_,
                          Options.OPTIONS
                          {compiler_options=Options.COMPILEROPTIONS{generate_moduler, ...}, ...})) =
  generate_moduler

(* Change the outermost signature constraint to be abstract *)
fun do_abstraction  (strid,SOME (sigexp,abs),strexp,boolref,location,a,b) =
  (strid,SOME (sigexp,true),strexp,boolref,location,a,b)
  | do_abstraction  (strid,NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,_,bref,location'),boolref,location,a,b) =
    (strid,NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,true,bref,location),boolref,location,a,b)
  | do_abstraction a = a

(* location *)

val dummy_location = Location.UNKNOWN

fun get_sym (Ident.VAR s) = s
  | get_sym (Ident.CON s) = s
  | get_sym (Ident.EXCON s) = s
  | get_sym (_) = Crash.impossible "get_sym:actionfunctions"

(* source info construction *)
local
  fun locate(OPTS(location,_,_),string) =
    concat [string,"[",Location.to_string location,"]"]
  fun locate'(location,string) =
    concat [string,"[",Location.to_string location,"]"]
in
  fun make_hash_info (opts,Ident.LAB sym) = locate (opts,"#" ^ Symbol.symbol_name sym ^ " ")
  fun make_seq_info (opts) = locate (opts,"<seq>")
  fun make_and_info (opts) = locate (opts,"<andalso>")
  fun make_orelse_info (opts) = locate (opts,"<orelse>")
  fun make_handle_info (opts) = locate (opts,"<handle>")
  fun make_if_info (opts) = locate (opts,"<if>")
  fun make_case_info (opts) = locate (opts,"<case>")
  fun make_fn_info (opts) = locate (opts,"<anon>")
  fun make_exbind_info (opts,Ident.EXCON sym) = locate (opts,Symbol.symbol_name sym)
    | make_exbind_info _ = Crash.impossible "Not an excon in an exbind"
  fun make_funbind_info (opts,Ident.FUNID sym) = locate (opts,"Functor " ^ Symbol.symbol_name sym)
  fun make_while_info (opts) = fn x => locate(opts,x)
  fun make_fval_info loc = fn x => locate'(loc,x)
end

(* error reporting *)
fun do_info (OPTS(location,options,_),message_type,message) =
  Info.error options (message_type,location,message)

fun error (opts,message) =
  do_info(opts,Info.RECOVERABLE,message)

fun warn (opts,message) =
  do_info(opts,Info.WARNING,message)

fun function_pattern_error (opts,pattern) =
  let
    val message = 
      case pattern of
        Absyn.VALpat ((longid,_),_) => 
          "Constructor " ^ 
          IdentPrint.printLongValId (print_options_of opts) longid ^ 
          " occurs as function name"
      | _ => "Pattern occurs as function name"
  in
    error (opts,message)
  end

fun make_id_name ([],s) =
  Symbol.symbol_name s
  | make_id_name (str :: l,s) =
    Symbol.symbol_name str ^ "." ^ make_id_name(l,s)

fun print_token (LRbasics.LONGID,LONGID x) = make_id_name x
  | print_token (LRbasics.INTEGER,INTEGER i) = i
  | print_token (LRbasics.STRING,STRING s) = "\"" ^ MLWorks.String.ml_string (s,10) ^ "\""
  | print_token (LRbasics.CHAR,CHAR s) = "#\"" ^ MLWorks.String.ml_string (s,10) ^ "\""
  | print_token (LRbasics.REAL,REAL s) = s
  | print_token (LRbasics.WORD, WORD s) = s
  | print_token (x,_) = LRbasics.token_string x

fun report_long_error (opts,longid,ty) =
  error(opts,"Unexpected long " ^ ty ^ ": " ^ (make_id_name longid))

(* debuggery *)

val do_debug = ref false

fun do_output message = (print message; print"\n")

fun debug message =
  if !do_debug then do_output message else ()

(* stuff for setting up infixes *)
fun char_digit s = (ord (String.sub(s, 0))) - ord #"0"

fun parse_precedence (opts,s) =
  case size s of
    1 => char_digit s
  | _ => (error(opts,"Only Single digit allowed for precedence, using 0");
          0)

(* symbol manipulation *)
val asterisk_symbol = Symbol.find_symbol "*"

val equal_symbol = Symbol.find_symbol "="

fun mkTyCon (opts,sym) = 
  (if sym = asterisk_symbol then
     error(opts,"Asterisk not allowed as type constructor")
   else
     ();
   Ident.TYCON sym)

val mkPath = Ident.mkPath
(* Should be done by an optimiser, but New Jersey doesn't have one *)

fun mkLongVar (syms,sym) = 
  Ident.LONGVALID (mkPath syms, Ident.VAR sym)

val equal_lvalid = mkLongVar ([],equal_symbol)

fun mkLongCon (syms,sym) = 
  Ident.LONGVALID (mkPath syms, Ident.CON sym)

fun mkLongExCon (syms,sym) = 
  Ident.LONGVALID (mkPath syms, Ident.EXCON sym)

fun mkLongTyCon (opts,syms,sym) = 
  (if sym = asterisk_symbol then
     error(opts,"Asterisk not allowed as type constructor")
   else
     ();
   Ident.LONGTYCON (mkPath syms, Ident.TYCON sym))

fun mkLongStrId (syms,sym) = 
  Ident.LONGSTRID (mkPath syms, Ident.STRID sym)

exception LongError

(* convert from short to long *)
fun make_long_id x = Ident.LONGVALID (Ident.NOPATH, x)

fun is_constructor (Ident.CON _) = true
  | is_constructor (Ident.EXCON _) = true
  | is_constructor _ = false

fun is_long_constructor (Ident.LONGVALID(_,id)) =
  is_constructor id

val error_symbol = Symbol.find_symbol "<Error>"
fun make_id_value s = LONGID ([],Symbol.find_symbol s)
val error_id_value = LONGID ([],error_symbol)
val error_id = Ident.VAR error_symbol

fun is_error_longid (Ident.LONGVALID (Ident.NOPATH,valid)) =
  get_sym valid = error_symbol
  | is_error_longid _ = false

fun get_old_definition opts =
  let
    val Options.COMPATOPTIONS {old_definition,...} = compat_options_of opts  
  in
    old_definition
  end

fun check_is_old_definition (opts,message) =
  if get_old_definition opts then ()
  else
    error (opts,message)

fun check_is_new_definition (opts,message) =
  if get_old_definition opts then error (opts,message)
  else ()


fun check_is_constructor (opts,id,strname_opt) =
  let val print_options = print_options_of opts
  in
    if is_long_constructor id then
      ()
    else
      case strname_opt of
        SOME strname =>
          error (opts,"Unbound structure " ^ strname ^ " in " ^ (IdentPrint.printLongValId print_options id))
      | _ => 
          error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options id) ^ " not defined")
  end

(* Typechecker doesn't check for constructor status *)
(*
fun make_constructor (id as Ident.LONGVALID(path,valid)) =
  case valid of
    Ident.CON _ => id
  | Ident.EXCON _ => id
  | _ => Ident.LONGVALID (path,Ident.CON (get_sym valid))
*)

fun check_is_short_constructor (opts,id) =
  if get_sym id = error_symbol then ()
  else
    let val print_options = print_options_of opts
    in
      if is_constructor id then
        ()
      else
        error (opts,"Non-constructor " ^ 
               (IdentPrint.printValId print_options id) ^ " used in pattern")
    end

fun check_not_short_constructor (opts,id) =
  if get_sym id = error_symbol then ()
  else
    let val print_options = print_options_of opts
    in
      if is_constructor id then
        error (opts,"Cannot bind constructor " ^ 
               (IdentPrint.printValId print_options id))
      else
        ()
    end


fun check_integer_bounds (opts, int:string) = 
(* must be > 0 *)
  if size int = 0 then
    error (opts, "Malformed integer label")
  else
    let val c = String.sub(int, 0)
    in
      if c = #"0" then
	error (opts, "Leading zero in numeric label not allowed")
      else if c = #"~" then
	error (opts, "Integer label must be positive")
      else
	()
    end (* check_integer_bounds *)
      
(* environment manipulation *)

(* functions on environments *)

(* used when storing structure declarations *)
fun zap_pFE (OPTS(_,_,options),x as PE.E(_,pVE,pTE,pSE)) =
  let
    val Options.OPTIONS {compat_options = Options.COMPATOPTIONS{open_fixity, ...},
                         ...} = options
  in
    if open_fixity
      then x
    else
      PE.E(PE.empty_pFE,pVE,pTE,pSE)
  end

fun zap_pFE(_, x ) = x
(* Always keep the fixity environment. Throw away at open if necessary. *)

(* When adding environments in a signature, want to disregard identifier status *)
(* and fixity *)
 
fun zap_for_sig (PE.E(_,_,pTE,pSE)) =
  PE.E(PE.empty_pFE,PE.empty_pVE,pTE,pSE)

fun pe_error _ = Crash.impossible"identifier clash in empty env"

(* create initial environments *)
fun make_pSE (opts,id,pE) = PE.addStrId (pe_error,id,zap_pFE (opts,pE),PE.empty_pSE)

fun make_pVE id = PE.addValId (pe_error,id, PE.empty_pVE)
fun make_pTE (id,pVE) = PE.addTyCon (pe_error,id, pVE, PE.empty_pTE)
fun make_pFE ids_fixity = PE.make_pFE ids_fixity
fun make_pF (id,pE) = PE.addFunId (pe_error,id,pE,PE.empty_pF)
fun make_pG (id,pE,tycons) = PE.addSigId (pe_error,id,pE,tycons,PE.empty_pG)

(* injection functions *)
fun pVE_in_pE pVE = PE.E (PE.empty_pFE,pVE,PE.empty_pTE,PE.empty_pSE)
fun pVEpTE_in_pE (pVE,pTE) = PE.E (PE.empty_pFE,pVE,pTE,PE.empty_pSE)
fun pTE_in_pE pTE = PE.E (PE.empty_pFE,PE.empty_pVE,pTE,PE.empty_pSE)
fun pSE_in_pE pSE = PE.E(PE.empty_pFE,PE.empty_pVE,PE.empty_pTE,pSE)
fun pFE_in_pE pFE = PE.E(pFE,PE.empty_pVE,PE.empty_pTE,PE.empty_pSE)

fun pE_in_pB pE = PE.B(PE.empty_pF,PE.empty_pG,pE)
fun pF_in_pB pF = PE.B(pF,PE.empty_pG,PE.empty_pE)
fun pG_in_pB pG = PE.B(PE.empty_pF,pG,PE.empty_pE)

(* some functions for manipulating the global environment *)

(* store the global pE in here *)
val ref_pE = ref PE.empty_pE;
fun get_current_pE () = !ref_pE
fun set_pE pE = ref_pE := pE
(* extend global pE *)

fun extend_pE (pE) = ref_pE := PE.augment_pE (!ref_pE,pE)
fun extend_pVE (pVE) = extend_pE (pVE_in_pE pVE)
fun extend_pTE (pTE) = extend_pE (pTE_in_pE pTE)
fun extend_pSE (pSE) = extend_pE (pSE_in_pE pSE)

fun lookupValId x = PE.tryLookupValId (x,!ref_pE)
fun lookupLongTycon x  = 
  (case PE.lookupTycon (x,!ref_pE)
    of NONE => (case PE.lookupTycon (x,PE.builtins_pE)
                  of NONE => PE.empty_pVE  (* attempting to replicate
                                              non-existing datatype *)
                   | SOME x => x)
     | SOME x => x)
     handle PE.LookupStrId _ => PE.empty_pVE (*error caught in typechecker*)
               
                          

fun lookupStrId (opts,strid) =
  PE.lookupStrId (strid,!ref_pE)
  handle PE.LookupStrId sym =>
    (error (opts,
            concat (case strid of 
                       ([],_) => ["Unbound structure ",
                                  IdentPrint.printLongStrId (mkLongStrId strid)]
                     | _ => ["Unbound structure ", Symbol.symbol_name sym, 
                             " in " ^ IdentPrint.printLongStrId (mkLongStrId strid)]));
     PE.empty_pE)

(* no error here if the var is currently undefined, since it may be a pattern variable *)
fun getValId (id as ([],sym)) = 
  (case lookupValId id of
     SOME x => x
   | NONE => Ident.VAR sym)
  | getValId id = Crash.impossible "Longid in getvalid"

(* Finding status of identifiers in the global environment *)
(* The optional string returned is the name of an undefined structure, if any *)
(* In fact, I think it is always an error if we can't find the identifier *)
(* Perhaps we should just signal an error here and be done with it *)
fun resolveLongValId (opts,id) =
  let val print_options = print_options_of opts
  in
    (case PE.lookupValId (id,!ref_pE) of
       SOME (Ident.VAR _) => (mkLongVar id,NONE)
     | SOME (Ident.CON _) => (mkLongCon id,NONE)
     | SOME (Ident.EXCON _) => (mkLongExCon id,NONE)
     | SOME _ => Crash.impossible "TYCON':resolveLongValId:actionfunctions"
     | NONE => (mkLongVar id,NONE))
    handle PE.LookupStrId sym => (mkLongVar id,SOME (Symbol.symbol_name sym))
  end


fun resolveValId sym =
  case lookupValId ([],sym) of
    SOME x => x
  | NONE => Ident.VAR sym


fun is_infix s =
  case PE.lookupFixity (s, !ref_pE) of
    PE.NONFIX => false
  | _ => true

fun check_excon (id as Ident.LONGVALID (_,valid),strname_opt,opts) =
  if is_error_longid id then ()
  else
    case valid of 
      Ident.EXCON _ => ()
    | _ => 
        (case strname_opt of
           SOME strname => 
             error (opts, "Unbound Structure " ^ strname ^ " in " ^
                    IdentPrint.printLongValId (print_options_of opts) id)
         | _ => 
             error (opts,"Identifier " ^ 
                    IdentPrint.printLongValId (print_options_of opts) id ^
                    " not an exception constructor"))

fun check_is_infix (opts,id) =
  let
    val sym = get_sym id
  in
    if sym = error_symbol
      then ()
    else
      if is_infix sym then ()
      else
        let val print_options = print_options_of opts
        in
          error (opts,"Symbol " ^ 
                 (IdentPrint.printValId print_options id) ^ 
                 " not infix")
        end
  end

fun check_is_infix_constructor (opts,longid) =
  if is_error_longid longid
    then ()
  else
    let
      val print_options = print_options_of opts
      val infixp =
        (case longid of
           Ident.LONGVALID(Ident.NOPATH,id) => is_infix (get_sym id)
         | _ => false)
      val consp = is_long_constructor longid
    in
      if consp then
        if infixp
          then ()
        else
          error (opts,"Constructor " ^ 
                 (IdentPrint.printLongValId print_options longid) ^ 
                 " not infix")
      else
        if infixp
          then error (opts,"Infix constructor " ^ 
                      (IdentPrint.printLongValId print_options longid) ^
                      " not defined")
        else
          error (opts,"Constructor " ^ 
                 (IdentPrint.printLongValId print_options longid) ^ 
                 " not defined and not infix")
    end

fun check_not_constructor_symbol (opts,s) =
  (case lookupValId ([],s) of
     SOME valid =>
       if is_constructor valid
         then error (opts,"Trying to bind constructor " ^
                     Symbol.symbol_name s ^ " in record")
       else ()
   | NONE => ())

(* global parser basis *)

val ref_pB = ref PE.empty_pB
fun set_pB (pB) = ref_pB := pB

fun setParserBasis (pB as (PE.B(pF,pG,pE))) = (set_pB pB;ref_pE := pE)
fun getParserBasis () =
  let val (PE.B(pF,pG,_)) = !ref_pB
  in
    PE.B(pF,pG,!ref_pE)
  end

fun lookupFunId (opts,x) =
  PE.lookupFunId (x,!ref_pB)
  handle PE.Lookup =>
    (error (opts,"functor " ^ IdentPrint.printFunId x ^ " not defined");
     PE.empty_pE)

fun lookupSigId (opts,x) =
  PE.lookupSigId (x,!ref_pB)
  handle PE.Lookup =>
    (error (opts,"signature " ^ IdentPrint.printSigId x ^ " not defined");
     (PE.empty_pE,[]))


local
  fun get_pB () = !ref_pB
in
  fun extend_pF (pF) = set_pB(PE.augment_pB(get_pB(),
                                            PE.B(pF,PE.empty_pG,PE.empty_pE)))
  fun extend_pG (pG) = set_pB(PE.augment_pB(get_pB(),PE.B(PE.empty_pF,pG,
                                                          PE.empty_pE)))
end

fun augment_tycons ([],tycons2,opts) = tycons2
  | augment_tycons (tycon::rest,tycons2,opts) =
    (if Lists.member (tycon, tycons2)
       then error (opts,"Duplicate type specifications in signature: " ^
                   IdentPrint.printTyCon tycon)
     else ();
     augment_tycons (rest,tycon::tycons2,opts))
         
fun spec_augment_pE ((pe1,tycons1),(pe2,tycons2),opts) = 
  if get_old_definition opts
    then
      (PE.augment_pE (pe1,pe2),tycons1 @@ tycons2)
  else
    (PE.unique_augment_pE 
     ((fn id => error (opts,"Duplicate value specifications in signature: " ^
                       IdentPrint.printValId (print_options_of opts) id),
       fn id => error (opts,
                       "Duplicate structure specifications in signature: " ^
                       IdentPrint.printStrId id)),
     pe1,pe2),
     augment_tycons (tycons1,tycons2,opts))

fun combine_specs (Absyn.SEQUENCEspec speclist1,Absyn.SEQUENCEspec speclist2) =
  Absyn.SEQUENCEspec (speclist1 @@ speclist2)
  | combine_specs (Absyn.SEQUENCEspec speclist1,spec2) =
  Absyn.SEQUENCEspec (speclist1 @@ [spec2])
  | combine_specs (spec1,Absyn.SEQUENCEspec speclist2) =
  Absyn.SEQUENCEspec (spec1 :: speclist2)
  | combine_specs (spec1,spec2) =
  Absyn.SEQUENCEspec [spec1,spec2]

fun names_of_typedesc t = map (fn (a,b,c) => b) t
fun names_of_datdesc t = map (fn (a,b,c) => b) t

fun make_long tycon = Ident.LONGTYCON (Ident.NOPATH,tycon)

fun do_type_spec (eq,speclist,opts) =
  Absyn.SEQUENCEspec
  (map
   (fn (tyvars,name,optty) =>
    case optty of
      NONE => if eq then Absyn.EQTYPEspec [(tyvars,name)]
                     else Absyn.TYPEspec [(tyvars,name)]
    | SOME (ty,tyvarset) => 
        let
          val location = get_location opts
        in
          Absyn.INCLUDEspec 
          (Absyn.WHEREsigexp(Absyn.NEWsigexp
                            (if eq then Absyn.EQTYPEspec [(tyvars,name)] 
                             else Absyn.TYPEspec [(tyvars,name)],
                               ref NONE),
                               [(tyvars,make_long name,ty,get_location opts)]),
                            get_location opts)
        end)
   speclist)

(* Semantic action for fixity declarations *)

fun extend_pE_for_fixity symbols_fixity =
  let val new_pE = pFE_in_pE (make_pFE symbols_fixity)
  in
    (extend_pE new_pE; DEC (Absyn.SEQUENCEdec [],new_pE,Set.empty_set))
  end

fun make_fixity_pE (symbols_fixity) =
  pFE_in_pE (make_pFE symbols_fixity)

(* the names of things *)
fun label_name (Ident.LAB sym) = Symbol.symbol_name sym
fun tyvar_name (Ident.TYVAR(sym,_,_)) = Symbol.symbol_name sym

(* absyn utilities *)

(* this should be in utils somewhere I think *)
fun member eq_test (a,l) =
  let
    fun member_aux [] = false
      | member_aux (b::l) =
        eq_test(a,b) orelse member_aux l
  in
    member_aux l
  end

fun get_intersection (l1,l2,eq_test,key) =
  let
    val member' = member eq_test
    fun aux ([],result) = rev result
      | aux (a::l,result) =
        if member'(a,l2)
          then aux(l,(key a)::result)
        else aux(l,result)
  in
    aux(l1,[])
  end

fun check_list_inclusion (sublist,list,eq_test) =
  let
    val member' = member eq_test
    fun check_all ([],_) = true
      | check_all (x::l,l') = member'(x,l') andalso check_all(l,l')
  in
    check_all(sublist,list)
  end

(* error checking here *)
(* numerous functions for checking on disjointness of declarations etc. *)

fun check_disjoint_labels (opts,lab,[]) = ()
  | check_disjoint_labels (opts,lab,(lab',_):: l) =
    if Ident.lab_eq(lab,lab')
      then error(opts,"Duplicate labels in record: " ^ (label_name lab))
    else check_disjoint_labels(opts,lab,l)

fun check_disjoint_tyvars (opts,tyvar,[]) = ()
  | check_disjoint_tyvars (opts,tyvar,(tyvar'::tyvars)) =
    if Ident.tyvar_eq(tyvar,tyvar')
      then error(opts,"Duplicate type variables in sequence: " ^ (tyvar_name tyvar))
    else check_disjoint_tyvars (opts,tyvar,tyvars)
  
fun check_tyvar_inclusion (opts,tyvars,tyvarlist) =
  (* ensure that all elements in tyvars are in tyvarlist *)
  (* need set operations that take an equality test parameter *)
  (* or this should be part of the specification of a set *)
  (* or I could be naughty and use polymorphic equality *)
  if check_list_inclusion (Set.set_to_list tyvars,tyvarlist,Ident.tyvar_eq)
    then ()
  else error(opts,"Free type variable in type declaration")

fun check_empty_tyvars (opts,tyvars) =
  (* checks that the list of tyvars is empty.  The revised syntax of
     datatype replication removes the need to specify type variables. *)
  if tyvars=[] then ()
  else error (opts,"Unexpected type variables in datatype replication.")



local
  fun check_disjoint_tycons (key,message)(opts,item,list) =
    if member(fn (x,y) => Ident.tycon_eq(key x,key y))(item,list)
      then
        let val Ident.TYCON sym = key item
        in
          error (opts,"Multiple declaration of type constructor " ^
                 Symbol.symbol_name sym ^ " in " ^ message)
        end
    else ()
in
  val check_disjoint_datbind = check_disjoint_tycons
                               (fn (_,x,_,_,_) => x, "datatype binding")
  val check_disjoint_typbind = check_disjoint_tycons
                               (fn (_,x,_,_) => x, "type binding")
  val check_disjoint_datdesc = check_disjoint_tycons
                               (fn (_,x,_) => x, "datatype specification")
  val check_disjoint_typdesc = check_disjoint_tycons
                               (fn (_,x,_) => x, "type specification")
end

(* need to ensure that all bindings in a rec are of form <pat,fn match> *)

fun is_con_pat(Absyn.WILDpat _) = false
  | is_con_pat(Absyn.SCONpat _) = false
  | is_con_pat(Absyn.VALpat({1=long_valid, ...}, _)) =
    is_long_constructor long_valid
  | is_con_pat(Absyn.RECORDpat _) = false
  | is_con_pat(Absyn.APPpat _) = false
  | is_con_pat(Absyn.TYPEDpat{1=pat, ...}) = is_con_pat pat
  | is_con_pat(Absyn.LAYEREDpat({1=valid, ...}, pat)) =
    is_constructor valid orelse is_con_pat pat


fun is_fn (Absyn.FNexp _) = true
  | is_fn (Absyn.TYPEDexp (exp,_,_)) = is_fn exp
  | is_fn _ = false

fun check_rec_bindings (opts,[]) = ()
  | check_rec_bindings(opts,(pat,exp,location)::l) =
    (if is_fn exp then
       if not (get_old_definition opts) orelse not (is_con_pat pat) then
	 ()
       else
	 error(opts, "Attempt to rebind constructor as variable")
     else
       error(opts,"Non-function expression in value binding");
(**)
      check_rec_bindings(opts,l))
(**)

fun check_disjoint_withtype (opts,datbindlist,typbindlist) =
  let
    fun get_datbind_tycon (_,tycon,_,_,_) = tycon
    fun get_typbind_tycon (_,tycon,_,_) = tycon
    fun compare (datbind,typbind) = Ident.tycon_eq (get_datbind_tycon datbind,get_typbind_tycon typbind)
    fun make_string [] = ""
      | make_string [Ident.TYCON sym] = Symbol.symbol_name sym
      | make_string ((Ident.TYCON sym) :: l) = (Symbol.symbol_name sym) ^ ", " ^ make_string l
    val intersection = get_intersection (datbindlist,typbindlist,compare,get_datbind_tycon)
  in
    case intersection of
      [] => ()
    | tycons => (error (opts,"Duplicate bindings in withtype: " ^ make_string tycons))
  end

(* these functions augment the environment as expected, but also generate a warning *)
(* if variable already present *)

fun identity x = x;

fun print_list([],_) = ""
  | print_list([x],f) = f x
  | print_list(x::l,f) = f x ^ ", " ^ print_list(l,f)

fun ordered_intersection(l1,l2,eq,order,key) =
  let
    fun aux([],_,result) = rev result
      | aux(_,[],result) = rev result
      | aux(all as (a::l),all' as (a'::l'),result) =
        let
          val b = key a and b' = key a'
        in
          if eq(b,b')
            then aux(l,l',b::result)
          else
            if order(b,b')
              then aux(l,all',result)
            else aux(all,l',result)
        end
  in
    aux (l1,l2,[])
  end

fun merge_pVEs (opts as OPTS(location,options,_),pVE1 as (PE.VE ve1),
                pVE2 as (PE.VE ve2)) =
  let 
    val print_options = print_options_of opts
    fun error_fun (_,valid1,valid2) =
    (error (opts,"Multiple declaration of value " ^
		 IdentPrint.printValId print_options valid1);
     valid1)
  in
    PE.VE (Map.merge error_fun (ve1,ve2))
  end


fun merge_pTEs (opts as OPTS(location,options,_),pTE1 as (PE.TE te1),
                pTE2 as (PE.TE te2)) =
  let
    val print_options = print_options_of opts
    fun error_fun (_,tycon1,tycon2) = tycon1
                 (* multiple declarations of typeconstructors dealt
                    with already when merging pVEs. *)
  in
      PE.TE (Map.merge error_fun (te1,te2))
  end

	(* varify is used in the case when we rebind constructors in
	   function definitions in sml'96 mode. *)

fun varify (v as Ident.VAR x) = v
  | varify (Ident.CON x) = Ident.VAR x
  | varify (Ident.EXCON x) = Ident.VAR x
  | varify (Ident.TYCON' x ) = Ident.VAR x


	(* The following is used in val rec bindings in sml'96 mode.
	   In those situations, constructors which appear in variable
	   positions may be rebound.  *)

local

  	(* the following version of varify and varifyLong are used by 
	   varify_valbind.  The latter only varifies longvars if they
	   have no path, as these are the only kind
	   of constructors that can be rebound in val recs and fundefs.
	   In case the constructor is rebound, we have to add it to
	   the parser Value Environment, (because they aren't in
	   ATPATS).  This will also check that the same constructor
	   isn't rebound twice. We do this using side-effects to
	   save tupling and untupling results. *)

  fun newvar (x,opts,pVE) =
	let val vid = Ident.VAR x
	 in pVE:=merge_pVEs(opts,!pVE,make_pVE vid);
	    vid
	end


  fun varify (v as Ident.VAR x,_,_) = v
    | varify (Ident.CON x,opts,pVE) = newvar (x,opts,pVE)
    | varify (Ident.EXCON x,opts,pVE) = newvar(x,opts,pVE)
    | varify (Ident.TYCON' x,opts,pVE) = newvar(x,opts,pVE)


  fun varifyLong(Ident.LONGVALID(Ident.NOPATH,id),opts,pVE) = 
	    Ident.LONGVALID(Ident.NOPATH,varify (id,opts,pVE))
    | varifyLong (x,_,_) = x


  fun map f [] = []
    | map f (h::t) = (f h)::(map f t)


  fun varify_pat (w as Absyn.WILDpat _,_,_) = w
    | varify_pat (s as Absyn.SCONpat _,_,_) = s
    | varify_pat (Absyn.VALpat((vid,s),l),opts,pVE) = 
	 Absyn.VALpat((varifyLong (vid,opts,pVE),s),l)
    | varify_pat (Absyn.RECORDpat(l,b,r),opts,pVE) = 
  	let fun varify_label_binding (lab,pat) = 
	                     (lab,varify_pat(pat,opts,pVE))
         in Absyn.RECORDpat(map varify_label_binding l,b,r)
	end
    | varify_pat (Absyn.APPpat(c,p,l,b),opts,pVE) =
	 Absyn.APPpat(c,varify_pat (p,opts,pVE),l,b)
    | varify_pat (Absyn.TYPEDpat(pat,ty,loc),opts,pVE) = 
	Absyn.TYPEDpat(varify_pat (pat,opts,pVE),ty,loc)
    | varify_pat (Absyn.LAYEREDpat((vid,tuple),pat),opts,pVE) =
	Absyn.LAYEREDpat((varify (vid,opts,pVE),tuple),
	                  varify_pat (pat,opts,pVE))

in

  fun varify_valbind(VALBIND(v1,v2,tyvars,pVE),opts) =
  	let val global_pVE = ref pVE
	    fun varify_patexp (pat,exp,loc) = 
	         (varify_pat (pat,opts,global_pVE),exp,loc)
         in VALBIND(map varify_patexp v1,
		    map varify_patexp v2, tyvars, !global_pVE)
	end
    | varify_valbind _ = Crash.impossible "_actionfunctions:varify_valbind"
end





local
  fun valid_error opts (_,_,valid) =
    let 
      val print_options = print_options_of opts
    in
      (error(opts,"Multiple declaration of value " ^
             IdentPrint.printValId print_options valid);
       valid)
    end
  fun tycon_error opts (_,_,x) = x   (* duplicate tycons ignored *)

  fun strid_error opts (strid,_,pE) =
    (error(opts,"Multiple declaration of structure " ^
		IdentPrint.printStrId strid);
     pE)
  fun funid_error opts (funid,_,pE) =
    (error(opts,"Multiple declaration of functor " ^
		IdentPrint.printFunId funid);
     pE)
  fun sigid_error opts (sigid,_,pE) =
    (error(opts,"Multiple declaration of signature " ^
		IdentPrint.printSigId sigid);
     pE)
in
  (* need to remove pFE from the pE for this one *)
  fun addNewStrId (opts,(strid,pE),pSE) =
    PE.addStrId (strid_error opts,strid,zap_pFE (opts,pE),pSE)
  fun addNewSigId (opts,(id,pE,tycons),pGE) = 
                  PE.addSigId (sigid_error opts,id,pE,tycons,pGE)
  fun addNewFunId (opts,(id,pE),pFE) = PE.addFunId (funid_error opts,id,pE,pFE)
  fun addNewValId (opts,id,pE) = PE.addValId (valid_error opts,id,pE)
  fun addNewTycon (opts,id,pVE,pTE) = PE.addTyCon (tycon_error opts,id,
                                                   pVE,pTE)
end

fun addNewSymId (opts,sym,pVE) = addNewValId(opts,Ident.VAR sym,pVE)

fun make_Sym_pVE (sym) = make_pVE(Ident.VAR sym)

(* these functions test for longvalids *)
local
  fun is_needed (Ident.NOPATH,s) = is_infix s
    | is_needed _ = false
in
  fun check_longid_op (opts,id as Ident.LONGVALID (p,v)) =
    if is_error_longid id
      then ()
    else
      if is_needed (p, get_sym v) then
        ()
      else
        warn (opts,"Reserved word `op' ignored before `" ^ Symbol.symbol_name(get_sym v) ^ "'")

  fun check_non_longid_op (opts,id as Ident.LONGVALID (p,v)) =
    if is_error_longid id
      then ()
    else
      if is_needed (p, get_sym v) then
        error (opts,"Reserved word `op' required before infix identifier `" ^ Symbol.symbol_name(get_sym v) ^ "'")
      else
        ()
end

fun check_valid_op (opts,v) =
  if get_sym v = error_symbol then ()
  else
    if is_infix (get_sym v) then
      ()
    else
      warn (opts,"Reserved word `op' ignored before `" ^
            Symbol.symbol_name(get_sym v) ^ "'")
    
fun check_non_valid_op (opts,v) =
  if get_sym v = error_symbol then ()
  else
    if is_infix (get_sym v) then
      error (opts,"Reserved word `op' required before infix identifier `" ^
             Symbol.symbol_name(get_sym v) ^ "'") else
      ()

fun check_conid_op (opts,v) =
  if get_sym v = error_symbol then ()
  else
    if not(is_infix (get_sym v)) orelse op_optional opts then
      warn (opts,"Reserved word `op' ignored before `" ^ 
            Symbol.symbol_name(get_sym v) ^ "'")
    else
      ()
    
fun check_non_conid_op (opts,v) =
  if get_sym v = error_symbol then ()
  else
    if is_infix (get_sym v) andalso not (op_optional opts) then
      error (opts,"Reserved word `op' required before infix identifier `" ^ 
             Symbol.symbol_name(get_sym v) ^ "'")
    else
      ()

(* General Utilities *)

fun annotate x = (x,ref Absyn.nullType)
fun annotate' x = (x,(ref Absyn.nullType,ref (Absyn.nullRuntimeInfo)))
fun mannotate (OPTS(l,_,_),x) = 
  (x,ref Absyn.nullType,l,
   ref(Absyn.nullInstanceInfo,NONE))

(* handling opens and includes *)

fun fold_pEs pEs =
  let fun fold ([],pE) = pE
        | fold (pE'::l,pE) = fold(l,PE.augment_pE(pE,pE'))
  in
    fold (pEs,PE.empty_pE)
  end

fun fold_sig_pEs (pEs,opts) =
  let fun fold ([],e) = e
        | fold (e::l,e') = 
          fold(l,spec_augment_pE (e,e',opts))
  in
    fold (pEs,(PE.empty_pE,[]))
  end

fun do_open_dec_action (opts as OPTS(_, _, options),longids) =
  let
    val Options.OPTIONS {compat_options = 
                         Options.COMPATOPTIONS{open_fixity, ...},
                         ...} = options
    val pEs = map (fn x => lookupStrId(opts,x)) longids
    val valids = map mkLongStrId longids
    val new_pE as PE.E(fixity, pVE, pTE, pSE) = fold_pEs pEs
    val new_pE = if open_fixity then new_pE else
                               PE.E(PE.empty_pFE, pVE, pTE, pSE)
  in
    (extend_pE new_pE;
     DEC (Absyn.OPENdec (valids,get_location opts),new_pE,Set.empty_set))
  end

fun do_open_spec_action (opts,longids) =
  let
    val pEs = map (fn x => zap_for_sig (lookupStrId(opts,x))) longids
    val valids = map mkLongStrId longids
    val new_pE = fold_pEs pEs
  in
    (extend_pE new_pE;
     SPEC(Absyn.OPENspec (valids,get_location opts),(new_pE,[])))
  end

fun do_include_action (opts,sigids) =
  let 
    val pEs = map (fn x => lookupSigId(opts,x)) sigids
    val (new_pE,new_tycons) = fold_sig_pEs (pEs,opts)
    val location = get_location opts
  in
    (extend_pE new_pE;
     SPEC (Absyn.SEQUENCEspec
           (map (fn sigid => 
                 Absyn.INCLUDEspec 
                  (Absyn.OLDsigexp 
                   (sigid,ref NONE,location),
                   location)) 
            sigids),
           (new_pE,new_tycons)))
  end

(* infix function declarations *)

fun join_tyvars [] = Set.empty_set
  | join_tyvars [t] = t
  | join_tyvars (t::l) = Set.union (t,join_tyvars l)

fun make_infix_fval (opts,id,pat1,pat2,patlist,exp,tvarlist) =
  (check_not_short_constructor(opts,id);
   check_is_infix (opts,id);
   ((id,(Derived.make_tuple_pat [pat1,pat2]) :: patlist,
     exp,get_location opts),join_tyvars tvarlist))

(* Functor bindings with specifications *)

fun do_derived_funbind (opts,funid,spec,opt_sig,strexp,pE) =
  (* pE is environment to be associated with the functor funid *)
  let
    val generate_moduler = generate_moduler opts
    val (a,b,c,d,f) =
    Derived.make_funbind (funid,
                         Absyn.NEWsigexp(spec,ref NONE),
                          strexp,
                          opt_sig,
                          get_location opts)
  in
    FUNBIND1 ((a,b,c,d,f,make_funbind_info(opts,funid),ref false,
               get_location opts,
               if generate_moduler
                 then SOME (ref(Absyn.nullDebuggerStr))
               else NONE,
               if generate_moduler
                 then SOME(ref(NONE))
               else NONE),funid,pE)
  end

fun do_fixity_spec (ids,precedence,opts as OPTS(_,_,options)) =
  let
    val Options.OPTIONS {compat_options = 
                         Options.COMPATOPTIONS{fixity_specs, ...},
                         ...} = options
  in
    if fixity_specs
      then
        SPEC(Absyn.STRUCTUREspec [],
             (make_fixity_pE (ids,precedence),
              []))
    else
      (error (opts,"Fixity declarations in signatures not valid in this mode");
       SPEC(Absyn.STRUCTUREspec [],(PE.empty_pE,[])))
  end

exception FoundTopDec of (Absyn.TopDec * PE.pB)
exception ActionError of int

(* the actions *)

val actions =
MLWorks.Internal.Array.arrayoflist[
(* Do not delete this line 1 *)










(* (defpackage "ML")  *)

(* ;; A grammar for ML for use in the LispWorks parser generator.  *)

(* (in-package 'ml)  *)

(* ;; General points --  *)
(* ;; each action assumes that the function call current_mark() returns  *)
(* ;; the mark object for the first token of the parsed sequence.  This  *)
(* ;; simplifies the data that needs to be carried around.  *)
(*     *)
(* (setq *mlg*  *)
(*   '(((START PROGRAM))  *)

                   fn ([dec],opts) => dec
 | _ => raise ActionError 0,

(* 	((ATEXP SCON))  *)

                   fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
 | _ => raise ActionError 1,

(* 	((ATEXP OPLONGVAR))  *)

                   fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
 | _ => raise ActionError 2,

(* ;; Don't want to just make :equal an identifier, otherwise too much  *)
(* ;; checking needed in patterns etc.  *)

(* 	((ATEXP :equal))  *)

                   fn ([_],opts) =>
  (check_non_longid_op (opts,equal_lvalid); 
   EXP (Absyn.VALexp (mannotate (opts,equal_lvalid)), Set.empty_set))
 | _ => raise ActionError 3,

(* 	((ATEXP :op :equal))  *)

                   fn ([_,_],opts) => 
  (check_longid_op (opts,equal_lvalid);
   EXP (Absyn.VALexp (mannotate (opts,equal_lvalid)), Set.empty_set))
 | _ => raise ActionError 4,

(* 	((ATEXP :lbrace EXPROW :rbrace))  *)

                   fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
 | _ => raise ActionError 5,

(* 	((ATEXP :lbrace :rbrace))  *)

                   fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
 | _ => raise ActionError 6,

(* 	((ATEXP :hash LAB))  *)

                 fn ([_,LAB lab],opts) =>
  EXP (Derived.make_select (lab,get_location opts,make_hash_info(opts,lab)),Set.empty_set)
 | _ => raise ActionError 7,

(* 	((ATEXP :magicopen EXP :rpar)) *)
                   fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
 | _ => raise ActionError 8,

(* 	((ATEXP :magicopen :type EXP :colon TY :rpar)) *)
                   fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
 | _ => raise ActionError 9,

(* 	((ATEXP :LPAR :RPAR))  *)

                   fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
 | _ => raise ActionError 10,

(* 	((ATEXP :LPAR EXPLIST2 :RPAR))  *)

                   fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
 | _ => raise ActionError 11,

(* 	((ATEXP :bra EXPLIST :ket)) ;; Expand into :: form  *)

                 fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
 | _ => raise ActionError 12,

(* 	((ATEXP :LPAR EXPSEQ2 :RPAR))  *)

                   fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
 | _ => raise ActionError 13,

(* 	((ATEXP START_LET DEC :in EXPSEQ :end))  *)

                   fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
  (set_pE pE; EXP (Absyn.LOCALexp (dec,Derived.make_sequence_exp (rev l),
                         get_location opts),Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 14,

(* 	((ATEXP :LPAR EXP :RPAR))  *)

                   fn ([_,x,_],opts) => x
 | _ => raise ActionError 15,

(* 	((START_LET :let))  *)

                   fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 16,

(* 	((EXPLIST2 EXPLIST2 :comma EXP))  *)

                   fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 17,

(* 	((EXPLIST2 EXP :comma EXP))  *)

                   fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 18,

(* 	((EXPLIST))  *)

                   fn ([],opts) => EXPLIST ([],Set.empty_set)
 | _ => raise ActionError 19,

(* 	((EXPLIST EXP))  *)

                   fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
 | _ => raise ActionError 20,

(* 	((EXPLIST EXPLIST2))  *)

                   fn ([exp],opts) => exp
 | _ => raise ActionError 21,

(* 	((EXPSEQ EXPSEQ :semicolon EXP))  *)

                   fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
  EXPSEQ ((exp,make_seq_info(opts),get_location opts)::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 22,

(* 	((EXPSEQ EXP))  *)

                   fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
 | _ => raise ActionError 23,

(* 	((EXPSEQ2 EXPSEQ :semicolon EXP))  *)

                   fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
  EXPSEQ ((exp,make_seq_info(opts),get_location opts)::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 24,

(* 	((EXPROW LAB :EQUAL EXP))  *)

                   fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
 | _ => raise ActionError 25,

(* 	((EXPROW EXPROW :comma LAB :EQUAL EXP))  *)

                   fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
  (check_disjoint_labels(opts,lab,l);EXPROW ((lab,exp)::l,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 26,

(* 	((APPEXP ATEXP))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 27,

(* 	((APPEXP APPEXP ATEXP))  *)

                   fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
  EXP(Absyn.APPexp(exp1,exp2,get_location opts,ref Absyn.nullType,false),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 28,

(* 	((INFEXP APPEXP))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 29,

(* 	((INFEXP INFEXP INFVAR INFEXP))  *)

                   fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
  EXP (Absyn.APPexp (Absyn.VALexp (mannotate(opts,id)),Derived.make_tuple_exp [exp1,exp2],get_location opts,ref Absyn.nullType,true),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 30,

(* 	((INFVAR VAR))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 31,

(* 	((INFVAR :equal))  *)

                   fn ([_],opts) => LONGVALID (equal_lvalid,NONE)
 | _ => raise ActionError 32,

(* 	((EXP INFEXP))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 33,

(* 	((EXP EXP :colon TY))  *)

                   fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
  EXP (Absyn.TYPEDexp (exp,ty,get_location opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 34,

(* 	((EXP EXP :andalso EXP))  *)

                 fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),get_location opts,get_current_pE()),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 35,

(* 	((EXP EXP :orelse EXP))  *)

                 fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),get_location opts,get_current_pE()),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 36,

(* 	((EXP EXP :handle MATCH))  *)

                   fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
  EXP (Absyn.HANDLEexp (exp1, ref Absyn.nullType, (rev match),get_location opts,make_handle_info(opts)),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 37,

(* 	((EXP :RAISE EXP))  *)

                   fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
 | _ => raise ActionError 38,


(* 	((EXP :if EXP :then EXP :else EXP))  *)

                   fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
  EXP(Derived.make_if (exp1,exp2,exp3,make_if_info(opts),get_location opts,get_current_pE()),join_tyvars[tyvars1,tyvars2,tyvars3])
 | _ => raise ActionError 39,

(* 	((EXP :while EXP :do EXP))  *)

                 fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_while (exp1,exp2,make_while_info(opts),get_location opts,get_current_pE()),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 40,

(* 	((EXP :case EXP :of MATCH))  *)

                   fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
  EXP (Derived.make_case (exp,(rev m),make_case_info(opts),get_location opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 41,

(* 	((EXP :fn MATCH))  *)

                   fn ([_,MATCH (match,tyvars)],opts) =>
  let val (a,b) = annotate (rev match) in EXP (Absyn.FNexp (a,b,make_fn_info(opts),get_location opts),tyvars) end
 | _ => raise ActionError 42,

(* 	((MATCH MATCH :vbar MRULE))  *)

                   fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 43,

(* 	((MATCH MRULE))  *)

                   fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
 | _ => raise ActionError 44,

(* 	((MRULE PAT :darrow EXP));; PAT determines variables present in EXP.  *)
(* 	;; Use to augment environment.  *)

                  fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 45,


(* 	((DECSEP DECSEP :semicolon))  *)

                   fn ([_,_],opts) => DUMMY
 | _ => raise ActionError 46,

(* 	((DEC DECSEP))  *)

                   fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 47,

(* 	((DEC DECSEP DEC1 DECSEP))  *)

                   fn ([_,dec,_],opts) => dec
 | _ => raise ActionError 48,

(* 	((DEC DECSEP DEC0 DECSEP))  *)

                   fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
 | _ => raise ActionError 49,

(* 	((DEC0 DEC1 DECSEP DEC1))  *)

                   fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 50,

(* 	((DEC0 DEC0 DECSEP DEC1))  *)

                   fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 51,

(* ;; End of new bit for decs  *)

(* ;; These two don't extend the global environment, as we only need constructors in there  *)

(* 	((DEC1 :val TYVARSEQ1 VALBIND))		; Extend value bindings ;; reverse both lists!!  *)

                   fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
  DEC (Absyn.VALdec (rev valbinds1,rev valbinds2,tyvars,explicit_tyvars),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 52,

(* 	((DEC1 :val VALBIND))		; Extend value bindings ;; reverse both lists!!  *)

                   fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
  DEC (Absyn.VALdec (rev valbinds1,rev valbinds2,tyvars,[]),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 53,

(* 	((DEC1 :fun TYVARSEQ1 FVALBIND))		; Extend function/value bindings ?  *)

                 fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind (y,options_of opts)) (rev l)),
                       tyvars,explicit_tyvars,get_location opts),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 54,

(* 	((DEC1 :fun FVALBIND))		; Extend function/value bindings ?  *)

                 fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind (y,options_of opts)) (rev l)),
                       tyvars,[],get_location opts),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 55,

(* 	((DEC1 :type TYPBIND))		; Type binding  *)

                   fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 56,


(* 	((DEC1 :datatype DATREPL)) *)

                  fn ([_,DATREPL(tyvars,tycon,longtycon)],opts)=>
  (check_is_new_definition(opts,
            "Datatype replication is not a feature of SML'90");
   check_empty_tyvars(opts,tyvars);
   let val pVE = lookupLongTycon longtycon
       val pTE = (make_pTE (tycon,pVE))
    in 
      extend_pVE pVE;
      extend_pTE pTE;
      DEC (Absyn.DATATYPErepl (get_location opts,(tycon,longtycon),
                               ref NONE),
        pVEpTE_in_pE(pVE,pTE),Set.empty_set)
   end)
 | _ => raise ActionError 57,



(* ;; Need to extend global env with constructor definitions in next 5 rules  *)

(* 	((DEC1 :datatype DATBIND))	; Extend type constructors.  *)

                   fn ([_,DATBIND (d,pVE,pTE)],opts) => 
  (extend_pVE pVE; 
   extend_pTE pTE;
   DEC (Absyn.DATATYPEdec (get_location opts,rev d),pVEpTE_in_pE (pVE,pTE),
        Set.empty_set))
 | _ => raise ActionError 58,


(* 	((DEC1 :datatype DATBIND :withtype TYPBIND))  *)

                   fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t],opts) =>
  (check_disjoint_withtype(opts,d,t);
   extend_pVE pVE; extend_pTE pTE;
   DEC (Derived.make_datatype_withtype (get_location opts,rev d, t, 
					options_of opts),
	pVEpTE_in_pE(pVE,pTE),Set.empty_set))
 | _ => raise ActionError 59,

(* 	((DEC1 :abstype ABSDATBIND :with DEC :end))  *)

                   fn ([_,DATBIND (d,pVE,pTE),_,DEC(dec,pE,tyvars),_],opts) =>
  DEC (Absyn.ABSTYPEdec (get_location opts,rev d,dec),
       PE.augment_pE (pTE_in_pE(pTE),pE),tyvars) 
 | _ => raise ActionError 60,



(* 	((DEC1 :abstype ABSDATBIND :withtype TYPBIND :with DEC :end))  *)

          fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t,_,DEC(dec,pE,tyvars),_],
          opts) =>
        (check_disjoint_withtype(opts,d,t);
         DEC (Derived.make_abstype_withtype
                 (get_location opts,rev d,t,dec,options_of opts),
              PE.augment_pE (pTE_in_pE(pTE),pE),tyvars))
 | _ => raise ActionError 61,



(* 	((ABSDATBIND DATBIND)) *)

          fn ([d as (DATBIND(_,pVE,pTE))],opts) =>
         (extend_pVE pVE; extend_pTE pTE; d)
 | _ => raise ActionError 62,



(* 	((DEC1 :exception EXBIND))  *)

          fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
        (extend_pVE pVE; DEC (Absyn.EXCEPTIONdec (rev l),pVE_in_pE pVE,
         tyvars))
 | _ => raise ActionError 63,



(* 	((DEC1 START_LOCAL DEC :in DEC :end))  *)

          fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,
           DEC (dec2,pE,tyvars2),_],opts) =>
        (set_pE (PE.augment_pE (env_pE,pE));
         DEC (Absyn.LOCALdec (dec1,dec2),pE,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 64,



(* ;; Extends global environment with new definitions  *)


(* 	((DEC1 :open LONGIDLIST))  *)

          fn ([_,LONGIDLIST l],opts) => 
         do_open_dec_action (opts,rev l)
 | _ => raise ActionError 65,



(* ;; Infix declarations extend global environment  *)
(* ;; These lists are reversed, but I don't think that matters here  *)


(* 	((DEC1 :infix SYMLIST));; Extend fixity environment.  *)

          fn ([_,SYMLIST l],opts) =>
          extend_pE_for_fixity (l, PE.LEFT 0)
 | _ => raise ActionError 66,



(* 	((DEC1 :infix :integer SYMLIST))  *)

          fn ([_,INTEGER i,SYMLIST l],opts) =>
         extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
 | _ => raise ActionError 67,



(* 	((DEC1 :infixr SYMLIST))  *)

          fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
 | _ => raise ActionError 68,



(* 	((DEC1 :infixr :integer SYMLIST))  *)

          fn ([_,INTEGER i,SYMLIST l],opts) =>
         extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
 | _ => raise ActionError 69,



(* 	((DEC1 :nonfix SYMLIST))  *)

          fn ([_,SYMLIST l],opts) =>
          extend_pE_for_fixity (l, PE.NONFIX)
 | _ => raise ActionError 70,



(* ;; Used to store the current environment when entering a scope  *)


(* 	((START_LOCAL :local))  *)

          fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 71,



(* 	((VALBIND VALBIND1))  *)

          fn ([x],opts) => x
 | _ => raise ActionError 72,



(* 	((VALBIND VALBIND :and VALBIND1))  *)

          fn ([VALBIND(v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],
          opts) =>
      VALBIND (a::v1,v2,Set.union(tyvars1,tyvars2),
               merge_pVEs(opts,pVE1,pVE2))
 | _ => raise ActionError 73,



(* 	((VALBIND VALBIND :and :rec VALBIND))  *)

          fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,
           VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
        (check_rec_bindings (opts,v2);
         VALBIND (v1,v1' @@ v2 @@ v2',Set.union(tyvars1,tyvars2),
                  merge_pVEs(opts,pVE1,pVE2)))
 | _ => raise ActionError 74,



(* 	((VALBIND :rec VALBIND))  *)

        fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
        (check_rec_bindings (opts,v1); 
         let val vbind = VALBIND ([],v2@@v1,tyvars,pVE)
          in if get_old_definition opts then vbind
             else varify_valbind (vbind,opts)  (* change all constructors
                                           that occur in var positions
                                           into vars (so can be rebound)*)
         end)
 | _ => raise ActionError 75,



(* 	((VALBIND1 PAT :EQUAL EXP))  *)

          fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
        VALBIND ([(pat,exp,get_location opts)],[],
                 Set.union (tyvars1,tyvars2),pVE)
 | _ => raise ActionError 76,



(* ;; Function definitions should return a pVE with the names of the *)
(* ;; functions declared in it.  *)


(* 	((FVALBIND FVALLIST))  *)

          fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
        FVALBIND (([((rev fvals),make_fval_info loc,get_location opts)],
                   tyvars),make_pVE id)
 | _ => raise ActionError 77,



(* 	((FVALBIND FVALBIND :and FVALLIST))  *)

          fn ([FVALBIND ((l,tyvars1),pVE),_,
           FVALLIST (fvals,tyvars2,id,loc)],opts) =>
        FVALBIND (((rev fvals,make_fval_info loc,get_location opts)::l,
                   Set.union(tyvars1,tyvars2)),addNewValId(opts,id,pVE))
 | _ => raise ActionError 78,



(* 	((FVALLIST FVAL))  *)

          fn ([FVAL ((fval,tyvars),id)],opts) => 
          FVALLIST ([fval],tyvars,id,get_location opts)
 | _ => raise ActionError 79,



(* ;; checking that the function names are the same is done in Derived  *)


(* 	((FVALLIST FVALLIST :vbar FVAL))  *)

          fn ([FVALLIST (fvals,tyvars1,id,_),_,
           FVAL ((fval,tyvars2),id')],opts) =>
        FVALLIST (fval::fvals,Set.union(tyvars1,tyvars2),id,
                  get_location opts)
 | _ => raise ActionError 80,



(* 	((FVAL OPVARDEF ATPATLIST OPTTYPE :EQUAL EXP))  *)

          fn ([VALID id,PATLIST(l,pE,tyvars1),TY(ty,tyvars2),
           _,EXP (exp,tyvars3)],opts) =>
         let val vid = varify id 
          in FVAL(((vid,rev l,Absyn.TYPEDexp(exp,ty,get_location opts),
                    get_location opts),
                   join_tyvars[tyvars1,tyvars2,tyvars3]),vid)
         end
       | ([VALID id,PATLIST (l,pE,tyvars1),NULLTYPE,_,
           EXP (exp,tyvars3)],opts) =>
         let val vid = varify id
          in FVAL(((vid,rev l,exp,get_location opts),
                   Set.union(tyvars1,tyvars3)),vid)
         end
 | _ => raise ActionError 81,



(* 	((FVAL ATPAT1 VARDEF ATPAT OPTTYPE :EQUAL EXP))  *)

          fn ([PAT(pat1,pVE1,tyvars1),VALID id,PAT(pat2,pVE2,tyvars2),
           TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
        let val vid = varify id
         in (ignore(merge_pVEs(opts,pVE1,pVE2));
             FVAL(make_infix_fval (opts,vid,pat1,pat2,[],
                  Absyn.TYPEDexp(exp,ty,get_location opts),
                  [tyvars1,tyvars2,tyvars3,tyvars4]),vid))
        end
       | ([PAT (pat1,pVE1,tyvars1),VALID id,PAT(pat2,pVE2,tyvars2),
           NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
        let val vid = varify id
         in
          (ignore(merge_pVEs(opts,pVE1,pVE2));
           FVAL(make_infix_fval(opts,vid,pat1,pat2,[],exp,
                [tyvars1,tyvars2,tyvars3]),vid))
        end
 | _ => raise ActionError 82,


(* 	((FVAL ATPAT1 VARDEF ATPAT ATPATLIST OPTTYPE :EQUAL EXP))  *)

          fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),
           _,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
        (error (opts,"Too many patterns for infix identifier "
                     ^ IdentPrint.printValId (print_options_of opts) id);
         ignore(merge_pVEs(opts,pVE1,pVE2));
         FVAL(make_infix_fval (opts,id,pat1,pat2,[],
              Absyn.TYPEDexp(exp,ty,get_location opts),
              [tyvars1,tyvars2,tyvars3,tyvars4]),id))
       | ([PAT (pat1,pVE1,tyvars1),VALID id,PAT(pat2,pVE2,tyvars2),
           _,NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
         (error (opts,"Too many patterns for infix identifier "
                      ^ IdentPrint.printValId (print_options_of opts) id);
          ignore(merge_pVEs(opts,pVE1,pVE2));
          FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,
               [tyvars1,tyvars2,tyvars3]),id))
 | _ => raise ActionError 83,



(* 	((FVAL ATPAT1 ATPATLIST OPTTYPE :EQUAL EXP))  *)

          fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),
           TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
        (function_pattern_error (opts,pat1);
         FVAL(((error_id,rev l,Absyn.TYPEDexp(exp,ty,get_location opts),
                get_location opts),
               Set.union (tyvars2,Set.union (tyvars3,tyvars4))),error_id))
       | ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),NULLTYPE,_,
           EXP(exp,tyvars3)],opts) =>
        (function_pattern_error (opts,pat1);
         FVAL(((error_id,rev l,exp,get_location opts),
               Set.union (tyvars2,tyvars3)),error_id))
 | _ => raise ActionError 84,



(* 	((FVAL ATPAT1 VARDEF OPTTYPE :EQUAL EXP))  *)

          fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,
           EXP (exp,tyvars4)],opts) =>
        (function_pattern_error (opts,pat1);
         FVAL(make_infix_fval (opts,id,pat1,pat1,[],
                               Absyn.TYPEDexp(exp,ty,get_location opts),
                               [tyvars1,tyvars3,tyvars4]),id))
       | ([PAT (pat1,pVE1,tyvars1),VALID id,NULLTYPE,_,
           EXP (exp,tyvars3)],opts) =>
        (function_pattern_error (opts,pat1);
         FVAL(make_infix_fval (opts,id,pat1,pat1,[],exp,
                               [tyvars1,tyvars3]),id))
 | _ => raise ActionError 85,



(* 	((FVAL BIN_ATPAT OPTTYPE :EQUAL EXP))  *)

          fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,
           EXP (exp,tyvars3)],opts) =>
        let val vid = varify id
         in FVAL(make_infix_fval (opts,vid,pat1,pat2,[],
                 Absyn.TYPEDexp(exp,ty,get_location opts),
                 [tyvars1,tyvars2,tyvars3]),vid)
        end
       | ([BINPAT (pat1,id,pat2,pE1,tyvars1),NULLTYPE,_,
           EXP (exp,tyvars2)],opts) =>
        let val vid = varify id
         in FVAL(make_infix_fval (opts,vid,pat1,pat2,[],exp,
                                  [tyvars1,tyvars2]),vid)
        end
 | _ => raise ActionError 86,


(* 	((FVAL BIN_ATPAT ATPATLIST OPTTYPE :EQUAL EXP))  *)

          fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),
           PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,
           EXP (exp,tyvars4)],opts) =>
        let val vid = varify id
         in FVAL(make_infix_fval(opts,vid,pat1,pat2,rev patl,
                                 Absyn.TYPEDexp(exp,ty,get_location opts),
                                 [tyvars1,tyvars2,tyvars3,tyvars4]),vid)
        end
       | ([BINPAT (pat1,id,pat2,pE1,tyvars1),
           PATLIST(patl,pE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
        let val vid = varify id
         in FVAL(make_infix_fval(opts,vid,pat1,pat2,rev patl,exp,
                                 [tyvars1,tyvars2,tyvars3]),vid)
        end
 | _ => raise ActionError 87,


(* 	((OPTTYPE))  *)

          fn ([],opts) => NULLTYPE
 | _ => raise ActionError 88,



(* 	((OPTTYPE :colon TY))  *)

          fn ([_,ty],opts) => ty
 | _ => raise ActionError 89,



(* 	((TYPBIND TYPBIND1))  *)

          fn ([x],opts) => x
 | _ => raise ActionError 90,



(* 	((TYPBIND TYPBIND :and TYPBIND1)) *)

          fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
       (check_disjoint_typbind(opts,tb,tbl);TYPBIND (tb::tbl))
 | _ => raise ActionError 91,

(* 	((TYPBIND1 TYVARSEQ TYCON :EQUAL TY)) *)

                   fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND [(rev tyvarlist,tycon,ty,if generate_moduler opts then SOME(ref(Absyn.nullTyfun))
   else NONE)])
 | _ => raise ActionError 92,

(* 	((LONGTYPBIND LONGTYPBIND1))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 93,

(* 	((LONGTYPBIND LONGTYPBIND :and LONGTYPBIND1))  *)

                   fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
   LONGTYPBIND (tb::tbl)
 | _ => raise ActionError 94,

(* 	((LONGTYPBIND1 TYVARSEQ LONGTYCON :EQUAL TY)) *)

                   fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);
   LONGTYPBIND [(rev tyvarlist,tycon,ty,get_location opts)])
 | _ => raise ActionError 95,

(* 	((TYVARSEQ))  *)

                   fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 96,

(* 	((TYVARSEQ TYVARSEQ1)) *)

         	 fn ([x],opts) => x
 | _ => raise ActionError 97,

(* 	((TYVARSEQ1 :tyvar))  *)

                   fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 98,

(* 	((TYVARSEQ1 :lpar TYVARLIST :rpar))  *)

                   fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 99,

(* 	((TYVARLIST :tyvar))  *)

                   fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 100,

(* 	((TYVARLIST TYVARLIST :comma :tyvar))  *)

                   fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 101,

(* 	((DATREPL DATAHEADER :datatype LONGTYCON)) *)
(* 	                                ; Datatype replication. *)

                   fn ([DATAHDR(tyvars, tycon),_, LONGTYCON longtycon],opts) =>
            DATREPL(tyvars,tycon,longtycon)
 | _ => raise ActionError 102,



(* 	((DATBIND DATBIND1))  *)

                   fn ([DATBIND1(d,pVE,pTE)],opts) => DATBIND([d],pVE,pTE)
 | _ => raise ActionError 103,

(* 	((DATBIND DATBIND :and DATBIND1))  *)

                   fn ([DATBIND(l,pVE,pTE),_,DATBIND1(d,pVE',pTE')],opts) =>
(check_disjoint_datbind(opts,d,l);DATBIND(d::l,merge_pVEs(opts,pVE,pVE'),
                                          merge_pTEs(opts,pTE,pTE')))
 | _ => raise ActionError 104,

(* 	((DATBIND1 DATAHEADER CONBIND))  *)

                   fn ([DATAHDR(tyvarlist,tycon),CONBIND (conbind,pVE,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);
   DATBIND1 ((rev tyvarlist,tycon,ref Absyn.nullType,
              if generate_moduler opts 
                then SOME(ref(Absyn.nullTyfun))
              else NONE,rev conbind),
             pVE, make_pTE (tycon,pVE)))
 | _ => raise ActionError 105,

(* 	((DATAHEADER TYVARSEQ TYCON :EQUAL)) *)

                  fn ([TYVARLIST tyvarlist, TYCON tycon,_],opts) =>
  DATAHDR(tyvarlist,tycon)
 | _ => raise ActionError 106,


(* 	((CONBIND CONBIND1))  *)

                   fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 107,

(* 	((CONBIND CONBIND :vbar CONBIND1))  *)

                   fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
  CONBIND(cb::cbl,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 108,

(* 	((CONBIND1 OPCONDEF OPTOFTYPE))  *)

                      fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,SOME ty),id,tyvars)
| ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,NONE),id,Set.empty_set)
 | _ => raise ActionError 109,

(* 	((EXBIND EXBIND1))  *)

                   fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 110,

(* 	((EXBIND EXBIND :and EXBIND1))  *)

                   fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
  EXBIND (e::l,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 111,

(* 	((EXBIND1 OPEXCONDEF OPTOFTYPE))  *)

                      fn ([VALID id, TY (ty,tyvars)],opts) => 
  EXBIND1 (Absyn.NEWexbind (annotate id,SOME ty,get_location opts,make_exbind_info(opts,id)),id,tyvars)
| ([VALID id, NULLTYPE],opts) => 
  EXBIND1 (Absyn.NEWexbind (annotate id,NONE,get_location opts,make_exbind_info(opts,id)),id,Set.empty_set)
 | _ => raise ActionError 112,

(* 	((EXBIND1 OPEXCONDEF :EQUAL OPLONGVAR))  *)

                   fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
    (check_excon (id',strname_opt,opts);
     EXBIND1 (Absyn.OLDexbind (annotate id,id',get_location opts,make_exbind_info (opts,id)),id,Set.empty_set))
 | _ => raise ActionError 113,

(* 	((OPTOFTYPE))  *)

                   fn ([],opts) => NULLTYPE
 | _ => raise ActionError 114,

(* 	((OPTOFTYPE :OF TY))  *)

                   fn ([_,x],opts) => x
 | _ => raise ActionError 115,

(* 	((ATPAT :underbar))  *)

                   fn ([_],opts as OPTS(location,options,_)) =>
       PAT (Absyn.WILDpat location,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 116,

(* 	((ATPAT SCON))  *)

       fn ([SCON (x as (Ident.REAL _))],opts) => 
        (check_is_old_definition
         (opts, "Real is not an equality type in SML'96");
        PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set))
    | ([SCON x], opts) => 
        PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 117,

(* ;; This is where variables are introduced.  Make a new environment  *)
(* ;; with just it in.  *)
(* ;; Note that there is a complication.  In sml'96 constructors *)
(* ;; may be rebound in val rec decs but not ordinary val decs.  Thus *)
(* ;; at this point, an OPVARDEF may be a short constructor.  In that *)
(* ;; case, we don't yet know if it can be rebound or not.  If it can't *)
(* ;; then there may be many occurrences of a constructor, if it can, *)
(* ;; then there may be only one.  This problem can only be resolved *)
(* ;; when we know for sure it is a val rec.  Thus to solve problems *)
(* ;; with multiple occurrences of short constructors, we do not update *)
(* ;; pVE with them until we know they can be rebound.  This will be *)
(* ;; done by the function varify_valbind. *)

(* 	((ATPAT OPVARDEF))  *)

          fn ([VALID id],opts) => 
         PAT (Absyn.VALpat (annotate' (make_long_id id),
                            get_location opts),
              if is_constructor id then PE.empty_pVE
                                   else make_pVE id,Set.empty_set)
 | _ => raise ActionError 118,



(* 	((ATPAT OPLONGVAR))  *)

        fn ([LONGVALID (id,strname_opt)],opts) => 
      (check_is_constructor (opts,id,strname_opt);
       (PAT (Absyn.VALpat (annotate' id,get_location opts),
             PE.empty_pVE,Set.empty_set)))
 | _ => raise ActionError 119,



(* 	((ATPAT :lbrace PATROW :rbrace))  *)

                   fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
  PAT (Absyn.RECORDpat (rev columns,wild,ref Absyn.nullType),pVE,tyvars)
 | _ => raise ActionError 120,

(* 	((ATPAT :lbrace PATROW :comma :ellipsis :rbrace))  *)

                   fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
  PAT (Absyn.RECORDpat (rev columns,true,ref Absyn.nullType),pVE,tyvars)
 | _ => raise ActionError 121,

(* 	((ATPAT :lbrace :ellipsis :rbrace))  *)

                   fn ([_,_,_],opts) => 
  PAT (Absyn.RECORDpat ([],true,ref Absyn.nullType),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 122,

(* 	((ATPAT :lbrace :rbrace))  *)

                   fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 123,

(* 	((ATPAT :lpar :rpar))  *)

                   fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 124,

(* 	((ATPAT :lpar PATLIST2 :rpar))  *)

                   fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 125,

(* 	((ATPAT :bra :ket))  *)

                   fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 126,

(* 	((ATPAT :bra PAT :ket))  *)

                   fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 127,

(* 	((ATPAT :lpar PAT :rpar))  *)

                   fn ([_,x,_],opts) => x
 | _ => raise ActionError 128,

(* 	((ATPAT :bra PATLIST2 :ket))  *)

                   fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 129,

(* 	((BIN_ATPAT :lpar ATPAT PATVAR ATPAT :rpar))  *)

                   fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,
                   PAT (pat2,pVE2,tyvars2),_],opts) =>
  BINPAT(pat1,id,pat2,merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 130,

(* 	((ATPAT1 BIN_ATPAT))  *)

                   fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
  (check_is_short_constructor (opts,id);
   PAT (Absyn.APPpat (annotate (make_long_id id), 
                      Derived.make_tuple_pat[pat1,pat2],
                      get_location opts,true),pVE,tyvars))
 | _ => raise ActionError 131,

(* 	((ATPAT1 ATPAT))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 132,

(* 	((PATLIST2 PAT :COMMA PAT))  *)

                   fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
  PATLIST ([pat2,pat1], merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 133,

(* 	((PATLIST2 PATLIST2 :COMMA PAT))  *)

                   fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
  PATLIST (pat2::pat1, merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 134,

(* 	((PATROW PATROW1))  *)

                   fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 135,

(* 	((PATROW PATROW :comma PATROW1))  *)

                   fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
  (check_disjoint_labels(opts,lab,l);
   PATROW (lp :: l,wild,merge_pVEs(opts,pVE1,pVE2), Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 136,

(* 	((PATROW1 LAB :EQUAL PAT))  *)

                   fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 137,

(* 	((PATROW1 SYMID OPTTYPE))  *)

                   fn ([SYM sym, TY (ty,tyvars)],opts) =>
  (check_not_constructor_symbol (opts,sym);
   PATROW1 ((Derived.make_patrow (sym, SOME ty, NONE,get_location opts)),make_Sym_pVE sym,tyvars))
| ([SYM sym, NULLTYPE],opts) =>
  (check_not_constructor_symbol (opts,sym);
   PATROW1 (Derived.make_patrow (sym, NONE, NONE,get_location opts),make_Sym_pVE sym,Set.empty_set))
 | _ => raise ActionError 138,

(* 	((PATROW1 SYMID OPTTYPE :as PAT))  *)

                   fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
  (check_not_constructor_symbol (opts,sym);
   PATROW1 (Derived.make_patrow (sym, SOME ty, SOME pat,get_location opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
| ([SYM sym, NULLTYPE,_,PAT (pat,pVE,tyvars)],opts) =>
  (check_not_constructor_symbol (opts,sym);
   PATROW1 (Derived.make_patrow (sym, NONE, SOME pat,get_location opts),addNewSymId(opts,sym,pVE),tyvars))
 | _ => raise ActionError 139,

(* 	((PAT ATPAT))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 140,

(* 	((PAT OPLONGVAR ATPAT))  *)

                    fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
     (check_is_constructor (opts,id,strname_opt);
      (PAT (Absyn.APPpat (annotate id, pat,get_location opts,false),pVE,tyvars)))
 | _ => raise ActionError 141,

(* 	((PAT OPVARDEF ATPAT))  *)

(* ;; This is really an error case, but now we just coerce to a constructor *)
                   fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
    (check_is_short_constructor (opts,id);
     PAT (Absyn.APPpat (annotate (make_long_id id), pat,get_location opts,false),pVE,tyvars))
 | _ => raise ActionError 142,

(* 	((PAT PAT VAR PAT))  *)

                   fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
  (check_is_infix_constructor (opts,id);
   PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2],get_location opts,true),merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 143,

(* 	((PAT PAT :colon TY))  *)

                   fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 144,

(* 	((PAT OPVARDEF OPTTYPE :as PAT))  *)

                     fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
  PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate' id, pat), ty,get_location opts),addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
| ([VALID id, NULLTYPE,_,PAT (pat,pVE,tyvars)],opts) =>
  PAT (Absyn.LAYEREDpat (annotate' id, pat),addNewValId(opts,id,pVE),tyvars)
 | _ => raise ActionError 145,

(* ;; Types need to have tyvar set added -- a field in Ty maybe?  *)

(* 	((TY :tyvar))  *)

                   fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 146,

(* 	((TY :lbrace TYROW :rbrace))  *)

                   fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 147,

(* 	((TY :lbrace :rbrace))  *)

                   fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 148,

(* 	((TY TYSEQ LONGTYCON))  *)

                   fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
 | _ => raise ActionError 149,

(* 	((TY TY LONGTYCON))  *)

                   fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
 | _ => raise ActionError 150,

(* 	((TY LONGTYCON))  *)

                   fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
 | _ => raise ActionError 151,

(* 	((TY TYTUPLE))  *)

                   fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 152,

(* 	((TY TY :arrow TY))  *)

                   fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 153,

(* 	((TY :LPAR TY :RPAR))  *)

                   fn ([_,t,_],opts) => t
 | _ => raise ActionError 154,

(* 	((TYSEQ :lpar TYLIST :comma TY :rpar))  *)

                   fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 155,

(* 	((TYLIST TY))  *)

                   fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 156,

(* 	((TYLIST TYLIST :comma TY))  *)

                   fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 157,

(* 	((TYTUPLE TYTUPLE STAR TY))  *)

                   fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 158,

(* 	((TYTUPLE TY STAR TY))  *)

                   fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 159,

(* 	((TYROW LAB :colon TY))  *)

                   fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 160,

(* 	((TYROW TYROW :comma LAB :colon TY))  *)

                   fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
(check_disjoint_labels(opts,lab,l);TYROW ((lab,ty)::l,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 161,

(* 	;; LISTS  *)

(* 	((ATPATLIST ATPAT))  *)

                   fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 162,

(* 	((ATPATLIST ATPATLIST ATPAT))  *)

                   fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
  PATLIST (pat::l,merge_pVEs(opts,pVE1,pVE2),Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 163,

(* ;; Longid lists used for structure reference lists -- these are kept as longids  *)

(* 	((LONGIDLIST LONGIDLIST :longid))  *)

                   fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 164,

(* 	((LONGIDLIST :longid))  *)

                   fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 165,

(* ;; Long symbol lists  *)

(* 	((LONGSTRIDLIST LONGSTRIDLIST LONGSTRID))  *)

                   fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 166,

(* 	((LONGSTRIDLIST LONGSTRID))  *)

                   fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 167,

(* ;; Symbol lists  *)

(* 	((SYMLIST SYM))  *)

                   fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 168,

(* 	((SYMLIST SYMLIST SYM))  *)

                   fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 169,

(* 	;; Constants  *)

(* ((SCON :integer))  *)

                   fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
 | _ => raise ActionError 170,

(* 	((SCON :real))  *)

                   fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
 | _ => raise ActionError 171,

(* 	((SCON :string))  *)

                   fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 172,

(* 	((SCON :char))  *)

                   fn ([CHAR s],opts) => SCON (Ident.CHAR s)
 | _ => raise ActionError 173,

(* 	((SCON :word))  *)

                   fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
 | _ => raise ActionError 174,

(* 	;; Labels  *)

(* 	((LAB :longid))  *)

                   fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
| ([LONGID (id as (p,s))],opts) =>
  (report_long_error (opts,id,"record label"); LAB (Ident.LAB s))
 | _ => raise ActionError 175,

(* 	((LAB :integer)) ;; need to check its within allowable bounds  *)

                   fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 176,

(* 	;; Long variables  *)

(* 	((LONGVAR :longid))  *)

                   fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 177,

(* 	((OPLONGVAR LONGVAR))  *)

                   fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 178,

(* 	((OPLONGVAR :op LONGVAR))  *)

                   fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 179,

(* 	((LONGTYCON :longid))  *)

                   fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 180,

(* 	((LONGSTRID :longid))  *)

                   fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 181,

(* ;; This one is parsed as a symbol.  *)

(* 	((SYM :longid))  *)

                   fn ([LONGID ([],s)],opts) => SYM s
| ([LONGID (id as (l,s))],opts) =>
  (report_long_error (opts,id,"symbol"); SYM s)
 | _ => raise ActionError 182,

(* 	((SYM :equal))  *)

                   fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 183,


(* 	((SYMID :longid))  *)

                   fn ([LONGID ([],s)],opts) => SYM s
| ([LONGID (id as (l,s))],opts) =>
  (report_long_error (opts,id,"symbol"); SYM s)
 | _ => raise ActionError 184,

(* 	((FUNID SYMID))  *)

                   fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 185,

(* 	((SIGID SYMID))  *)

                   fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 186,

(* 	((STRID SYMID))  *)

                   fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 187,

(* ;; These ones become long valids.  *)

(* ;; This one appears only in infix expressions and patterns, and can be a  *)
(* ;; constructor or a variable.  *)
(* 	((VAR :longid))  *)

                   fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),NONE)
 | ([LONGID (longid as (_,id))],opts) => (report_long_error(opts,longid,"variable");LONGVALID (Ident.LONGVALID(Ident.NOPATH,Ident.VAR id),NONE))
 | _ => raise ActionError 188,

(* ;; This is used for defining occurences of variables in patterns.  *)

(* 	((VARDEF :longid))  *)

          fn ([LONGID ([],id)],opts) => 
          let val valid = resolveValId id 
           in if get_old_definition opts
                then check_not_short_constructor (opts,valid)
              else (); VALID valid
          end
       | ([LONGID (longid as (_,id))],opts) =>
            (report_long_error (opts,longid,"variable"); 
            VALID (Ident.VAR id))
 | _ => raise ActionError 189,

(* 	((OPVARDEF VARDEF))  *)

                   fn ([valid as VALID id],opts) => 
              (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 190,

(* 	((OPVARDEF :op VARDEF))  *)

                   fn ([_,valid as VALID id],opts) => 
              (check_valid_op(opts,id); valid)
 | _ => raise ActionError 191,

(* ;; this is used in bin-atpats where the infixed var might be a constructor or a var  *)
(* 	((PATVAR :longid))  *)

                   fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"variable"); VALID (Ident.VAR id))
 | _ => raise ActionError 192,

(* 	((CONDEF :longid))  *)

                   fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"constructor"); VALID (Ident.CON s))
 | _ => raise ActionError 193,

(* 	((OPCONDEF CONDEF))  *)

                   fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 194,

(* 	((OPCONDEF :op CONDEF))  *)

                   fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 195,

(* 	((EXCONDEF :longid))  *)

                   fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"exception constructor"); VALID (Ident.EXCON s))
 | _ => raise ActionError 196,

(* 	((OPEXCONDEF EXCONDEF))  *)

                   fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 197,

(* 	((OPEXCONDEF :op EXCONDEF))  *)

                   fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 198,

(* 	((TYCON :longid))  *)

                   fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
| ([LONGID (id as (l,s))],opts) => (report_long_error (opts,id,"type constructor"); TYCON (mkTyCon(opts,s)))
 | _ => raise ActionError 199,

(* 	((STAR :longid))  *)

                   fn ([LONGID ([],s)],opts) => DUMMY 
               (* should check its an asterisk *)
 | _ => raise ActionError 200,

(* 	;; Modules  *)

(* 	((STREXP STRUCT_START STRDEC :end))  *)

                   fn ([ENV pE,STRDEC (x,e),_],opts) =>
              (set_pE pE;
               STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 201,

(* 	((STREXP :longid))  *)

                   fn ([LONGID x],opts) =>
    STREXP (Absyn.OLDstrexp (mkLongStrId x,get_location opts,
                             if generate_moduler opts then SOME(ref(NONE))
                             else NONE),lookupStrId(opts,x))
 | _ => raise ActionError 202,

(* 	((STREXP FUNID :lpar STREXP :rpar))  *)

                   fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,strexp,ref false,get_location opts,if generate_moduler opts then SOME(ref(Absyn.nullDebuggerStr)) else NONE),lookupFunId (opts,funid))
 | _ => raise ActionError 203,

(* 	((STREXP FUNID :lpar STRDEC :rpar))  *)

                   fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,ref false,get_location opts,if generate_moduler opts then SOME(ref(Absyn.nullDebuggerStr)) else NONE),lookupFunId (opts,funid))
 | _ => raise ActionError 204,

(* 	((STREXP START_LET STRDEC :in STREXP :end))  *)

                   fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
  (set_pE pE; STREXP (Absyn.LOCALstrexp(strdec,strexp),e'))
 | _ => raise ActionError 205,


(*         ((STREXP STREXP SIGBINDER SIGEXP)) *)

           fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
  STREXP (Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false,get_location opts),e')
 | _ => raise ActionError 206,

(* 	((STRUCT_START :struct))  *)

                   fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 207,

(* 	((STRDEC DECSEP))  *)

                   fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 208,

(* 	((STRDEC DECSEP STRDEC1 DECSEP))  *)

                   fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 209,

(* 	((STRDEC DECSEP STRDEC0 DECSEP))  *)

                   fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 210,

(* 	((STRDEC0 STRDEC1 DECSEP STRDEC1))  *)

                   fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 211,

(* 	((STRDEC0 STRDEC0 DECSEP STRDEC1))  *)

                   fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 212,

(* ;; This is used for strdecs as topdecs - don't allow them to be separated by semicolons.  *)

(* 	((STRDEC1PLUS STRDEC1))  *)

                   fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 213,

(* 	((STRDEC1PLUS STRDEC1PLUS0))  *)

                   fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 214,

(* 	((STRDEC1PLUS0 STRDEC1 STRDEC1))  *)

                   fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
  STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 215,

(* 	((STRDEC1PLUS0 STRDEC1PLUS0 STRDEC1))  *)

                   fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
  STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 216,

(* ;; Single strdecs  *)

(* 	((STRDEC1 DEC1))  *)

                   fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 217,

(* 	((STRDEC1 :structure STRBIND))  *)

                   fn ([_,STRBIND(l,pSE)],opts) => 
  (extend_pSE pSE;STRDEC(Absyn.STRUCTUREstrdec l,pSE_in_pE pSE))
 | _ => raise ActionError 218,

(* 	((STRDEC1 :abstraction STRBIND))  *)

                   fn ([_,STRBIND(l,pSE)],opts) => 
  (extend_pSE pSE;STRDEC(Absyn.ABSTRACTIONstrdec (map do_abstraction l),pSE_in_pE pSE))
 | _ => raise ActionError 219,

(* 	((STRDEC1 START_LOCAL STRDEC :in STRDEC :end))  *)

                   fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
  (set_pE (PE.augment_pE(pE,pE'));STRDEC(Absyn.LOCALstrdec(strdec1,strdec2),pE'))
 | _ => raise ActionError 220,

(*         ((SIGBINDER :colon)) *)
          fn ([_],opts) => BOOL false
 | _ => raise ActionError 221,

(*         ((SIGBINDER :abscolon)) *)
          fn ([_],opts) => BOOL true
 | _ => raise ActionError 222,

(* 	((STRBIND STRBIND1))  *)

                   fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 223,

(* 	((STRBIND STRBIND :and STRBIND1))  *)

                   fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
   STRBIND(d::l,addNewStrId(opts,id_pE,pSE))
 | _ => raise ActionError 224,

(* 	((STRBIND1 STRID SIGBINDER SIGEXP :equal STREXP))  *)

                  fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,
                  STREXP(strexp,pE2)],opts) => 
             STRBIND1((id,NONE,
                       Absyn.CONSTRAINTstrexp
                       (strexp,sigexp,abs,ref false,get_location opts),
                       ref false,
                       get_location opts,
                       if generate_moduler opts 
                         then SOME(ref(Absyn.nullDebuggerStr))
                       else NONE,
                       if generate_moduler opts
                         then SOME(ref(NONE))
                       else NONE),(id,pE1))
 | _ => raise ActionError 225,

(* 	((STRBIND1 STRID :equal STREXP))  *)

                  fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
  STRBIND1((id,NONE,strexp,ref false,
            get_location opts,
            if generate_moduler opts
              then SOME(ref(Absyn.nullDebuggerStr))
            else NONE,
            if generate_moduler opts
              then SOME(ref(NONE))
            else NONE),(id,pE))
 | _ => raise ActionError 226,

(* 	((SIGEXP SIG_START SPEC :end))  *)

              fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
     (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref NONE),(e,tycons)))
 | _ => raise ActionError 227,

(* 	((SIGEXP SIGID))  *)

              fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref NONE,get_location opts),lookupSigId(opts,id))
 | _ => raise ActionError 228,

(*         ((SIGEXP SIGEXP :where :type LONGTYPBIND1)) *)
           fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
   SIGEXP (Absyn.WHEREsigexp (sigexp,tybind),e)
 | _ => raise ActionError 229,

(* 	((SIG_START :sig))  *)

                   fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 230,

(* 	((SIGDEC1PLUS SIGDEC1))  *)

                   fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 231,

(* 	((SIGDEC1PLUS SIGDEC1PLUS SIGDEC1))  *)

                   fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 232,

(* 	((SIGDEC1 :signature SIGBIND))  *)

                   fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 233,

(* 	((SIGBIND SIGID :EQUAL SIGEXP))  *)

                   fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
 | _ => raise ActionError 234,

(* 	((SIGBIND  SIGBIND :and SIGID :EQUAL SIGEXP))  *)

             fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
  SIGBIND((id,sigexp,get_location opts)::l,addNewSigId(opts,(id,e,tycons),pG))
 | _ => raise ActionError 235,

(* 	((SIGBIND  SIGBIND :and :type LONGTYPBIND1))  *)

             fn ([sb as SIGBIND(l,pG),_,_,LONGTYPBIND tybind],opts) => 
    ( case l of
        (id, wsigexp as Absyn.WHEREsigexp _, loc) :: t
           => let val new_sigexp = Absyn.WHEREsigexp(wsigexp, tybind)
               in SIGBIND((id, new_sigexp, loc) :: t, pG)
              end
      | _ => (error(opts, "Unexpected occurrence of \"and type\""); sb) )
 | _ => raise ActionError 236,


(* 	((SPEC))  *)
             fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
 | _ => raise ActionError 237,

(* 	((SPEC SPEC SPEC1))  *)

             fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
  SPEC (combine_specs (spec1,spec2),spec_augment_pE (specstuff1,specstuff2,opts))
 | _ => raise ActionError 238,

(* 	((SPEC SPEC :sharing SHAREQ)) *)

           fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
   SPEC(Absyn.SHARINGspec (spec,rev l),(pE,tycons))
 | _ => raise ActionError 239,

(* ;; Don't need to extend global environment here -- no constructors here  *)

(*        ((SPEC1 :semicolon)) *)
         fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
 | _ => raise ActionError 240,

(* 	((SPEC1 :val VALDESC))  *)

             fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
 | _ => raise ActionError 241,

(* 	((SPEC1 :type TYPDESC))  *)

             fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 242,

(* 	((SPEC1 :eqtype TYPDESC))  *)

                   fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 243,


(*         ((SPEC1 :datatype DATREPLDESC)) *)

                   fn ([_,DATREPLDESC(tyvars,tycon,longtycon)],opts) =>
    (check_is_new_definition(opts, 
         "Datatype replication is not a feature of SML'90.");		       
     check_empty_tyvars(opts,tyvars);
     let val pVE = lookupLongTycon longtycon
         val pTE = (make_pTE (tycon,pVE))
     in 
       extend_pVE pVE;
       extend_pTE pTE;
       SPEC(Absyn.DATATYPEreplSpec(get_location opts,tycon,longtycon,
                                    ref NONE),
            (pVEpTE_in_pE(pVE,pTE), nil))
     end)
 | _ => raise ActionError 244,

(* 	((SPEC1 :datatype DATDESC))  *)

                   fn ([_,DATDESC(l,pVE,pTE)],opts) =>
		  (extend_pVE pVE;
		   extend_pTE pTE;
		   SPEC(Absyn.DATATYPEspec (rev l), (pVEpTE_in_pE (pVE,pTE),
			names_of_datdesc l)))
 | _ => raise ActionError 245,

(* 	((SPEC1 :exception EXDESC))  *)

                   fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
 | _ => raise ActionError 246,

(* 	((SPEC1 :structure STRDESC))  *)

                   fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
 | _ => raise ActionError 247,

(* 	((SPEC1 START_LOCAL SPEC :in SPEC :end))  *)

              fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
     (check_is_old_definition (opts,"local specification no longer in language");
      set_pE (PE.augment_pE(pE,pE2));SPEC(Absyn.LOCALspec(spec1,spec2),(pE2,tycons2)))
 | _ => raise ActionError 248,

(* 	((SPEC1 :open LONGIDLIST))  *)

              fn ([_,LONGIDLIST l],opts) => 
     (check_is_old_definition (opts,"open specification no longer in language");
      do_open_spec_action (opts,rev l))
 | _ => raise ActionError 249,

(* 	((SPEC1 :include SIGIDLIST))  *)

                   fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 250,

(* 	((SPEC1 :include SIGEXP))  *)
         
  fn ([_,SIGEXP (e,(pE,tycons))],opts) => 
  SPEC (Absyn.INCLUDEspec (e,get_location opts),(pE,tycons))
 | _ => raise ActionError 251,

(* ;; For compatibility with NJ *)
(* 	((SPEC1 :infix SYMLIST)) *)

                     fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 252,

(* 	((SPEC1 :infix :integer SYMLIST)) *)

                     fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 253,

(* 	((SPEC1 :infixr SYMLIST)) *)

                     fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 254,

(* 	((SPEC1 :infixr :integer SYMLIST)) *)

                     fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 255,

(* 	((SIGIDLIST SIGID))  *)

                   fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 256,

(* 	((SIGIDLIST SIGIDLIST SIGID))  *)

                   fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 257,

(* 	((VALDESC VARDEF :colon TY))  *)

                   fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 258,

(* 	((VALDESC VALDESC :and VARDEF :colon TY))  *)

                   fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
  VALDESC((v,ty,tyvars)::l,addNewValId(opts,v,pVE))
 | _ => raise ActionError 259,

(* 	((TYPDESC TYPDESC1))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 260,

(* 	((TYPDESC TYPDESC :and TYPDESC1))  *)

                   fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
  (check_disjoint_typdesc(opts,t,l); TYPDESC (t::l))
 | _ => raise ActionError 261,

(* 	((TYPDESC1 TYVARSEQ TYCON))  *)

             fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
     TYPDESC[(rev tyvarlist,tycon,NONE)]
 | _ => raise ActionError 262,

(* 	((TYPDESC1 TYVARSEQ TYCON :equal TY))  *)

             fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
     TYPDESC[(rev tyvarlist,tycon,SOME (ty,tyvarset))]
 | _ => raise ActionError 263,

(*         ((DATREPLDESC DATAHEADER :datatype LONGTYCON)) *)

                   fn ([DATAHDR(tyvars,tycon),_,LONGTYCON longtycon],opts) =>
              DATREPLDESC(tyvars,tycon,longtycon)
 | _ => raise ActionError 264,

(* ; Needs a value environment	  *)
(* 	((DATDESC DATDESC1))  *)

                   fn ([DATDESC1(d,pVE,pTE)],opts) =>
		  DATDESC([d],pVE,pTE)
 | _ => raise ActionError 265,

(* 	((DATDESC DATDESC :and DATDESC1))  *)

                   fn ([DATDESC(l,pVE,pTE),_,DATDESC1(d,pVE',pTE')],opts) =>
  (check_disjoint_datdesc(opts,d,l);
   DATDESC(d::l, merge_pVEs(opts,pVE,pVE'), merge_pTEs(opts,pTE,pTE')))
 | _ => raise ActionError 266,

(* 	((DATDESC1 DATAHEADER CONDESC)) *)

                   fn ([DATAHDR(tyvarlist,tycon),CONDESC (l,pVE,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);
   DATDESC1((rev tyvarlist,tycon,(rev l)), pVE, make_pTE (tycon,pVE)))
 | _ => raise ActionError 267,

(* 	((CONDESC CONDESC1))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 268,

(* 	((CONDESC CONDESC :vbar CONDESC1))  *)

                   fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
  CONDESC(x::l,merge_pVEs(opts,e,e'),Set.union(tyvars,tyvars'))
 | _ => raise ActionError 269,

(* 	((CONDESC1 CONDEF OPTOFTYPE))  *)

                      fn ([VALID con,TY(ty,tyvars)],opts) => 
  CONDESC([(con,SOME ty,get_location opts)],make_pVE con,tyvars)
 | ([VALID con,NULLTYPE],opts) => 
  CONDESC([(con,NONE,get_location opts)],make_pVE con,Set.empty_set)
 | _ => raise ActionError 270,

(* 	((EXDESC EXDESC1))  *)

                   fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 271,

(* 	((EXDESC EXDESC :and EXDESC1))  *)

                   fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
  EXDESC((excon,ty,marks)::l,addNewValId(opts,excon,pVE))
 | _ => raise ActionError 272,

(* 	((EXDESC1 EXCONDEF OPTOFTYPE))  *)

                      fn ([VALID excon,TY(ty,_)],opts) => 
  EXDESC1(excon,SOME ty,get_location opts)
 | ([VALID excon,NULLTYPE],opts) => 
  EXDESC1(excon,NONE,get_location opts)
 | _ => raise ActionError 273,

(* 	((STRDESC STRDESC1))  *)

                   fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 274,

(* 	((STRDESC STRDESC :and STRDESC1))  *)

                   fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
  STRDESC((strid,e)::l,addNewStrId(opts,(strid,pE),pSE))
 | _ => raise ActionError 275,

(* 	((STRDESC1 STRID :colon SIGEXP))  *)

                   fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 276,

(* ((SHAREQ SHAREQ1))  *)

                   fn ([x],opts) => x
 | _ => raise ActionError 277,

(* 	((SHAREQ SHAREQ :and SHAREQ1))  *)

                   fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 278,

(* 	((SHAREQ1 LONGSTRIDEQLIST))  *)

                   fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
 | _ => raise ActionError 279,

(* 	((SHAREQ1 :type LONGTYCONEQLIST))  *)

                   fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
 | _ => raise ActionError 280,

(* 	((LONGSTRIDEQLIST LONGSTRID :EQUAL LONGSTRID))  *)

                   fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 281,

(* 	((LONGSTRIDEQLIST LONGSTRIDEQLIST :EQUAL LONGSTRID))  *)

                   fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 282,

(* 	((LONGTYCONEQLIST LONGTYCON :EQUAL LONGTYCON))  *)

                   fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 283,

(* 	((LONGTYCONEQLIST LONGTYCONEQLIST :EQUAL LONGTYCON))  *)

                   fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 284,

(* 	((FUNDEC1PLUS FUNDEC1))  *)

                   fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 285,

(* 	((FUNDEC1PLUS FUNDEC1PLUS FUNDEC1))  *)

                   fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 286,

(* 	((FUNDEC1 :functor FUNBIND))  *)

                   fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 287,

(* 	((FUNBIND FUNBIND1))  *)

                   fn ([FUNBIND1(fbind,funid,pE)],opts) =>
FUNBIND([fbind],make_pF(funid,pE))
 | _ => raise ActionError 288,

(* 	((FUNBIND FUNBIND :and FUNBIND1))  *)

                   fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
FUNBIND (fbind::l,addNewFunId(opts,(funid,pE),pF))
 | _ => raise ActionError 289,

(* 	((FUNBIND1 STARTFUNBIND1 SIGBINDER SIGEXP :EQUAL STREXP))  *)

                  fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
          (set_pE pE;
           FUNBIND1((funid,
                     strid,
                     sigexp,
                     Absyn.CONSTRAINTstrexp (strexp,sigexp',abs,ref false,get_location opts),
                     NONE,
                     make_funbind_info(opts,funid),
                     ref false,
                     get_location opts,
                     if generate_moduler opts then SOME (ref(Absyn.nullDebuggerStr)) else NONE,
                     if generate_moduler opts then SOME (ref(NONE)) else NONE),
           funid,pE''))
 | _ => raise ActionError 290,

(* 	((FUNBIND1 STARTFUNBIND1 :EQUAL STREXP))  *)

             fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
     (set_pE pE;
      FUNBIND1((funid,
                strid,
                sigexp,
                strexp,
                NONE,
                make_funbind_info (opts,funid),
                ref false,
                get_location opts,
                if generate_moduler opts then SOME (ref (Absyn.nullDebuggerStr)) else NONE,
                if generate_moduler opts then SOME (ref (NONE)) else NONE),
      funid,pE'''))
 | _ => raise ActionError 291,

(* 	((FUNBIND1 STARTFUNBIND2 SIGBINDER SIGEXP :EQUAL STREXP))  *)

                      fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false,get_location opts),pE''))
 | _ => raise ActionError 292,

(* 	((FUNBIND1 STARTFUNBIND2 :EQUAL STREXP))  *)

                      fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,NONE,strexp,pE'''))
 | _ => raise ActionError 293,

(* 	((STARTFUNBIND1 FUNIDBIND :lpar STRID :colon SIGEXP :rpar))  *)

                   fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
(extend_pSE(make_pSE(opts,strid,pE'));STARTFUNBIND1(funid,pE,strid,sigexp,pE'))
 | _ => raise ActionError 294,

(* 	((STARTFUNBIND2 FUNIDBIND :lpar SPEC :rpar))  *)

                   fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
(extend_pE pE'; STARTFUNBIND2(funid,pE,spec,pE'))
 | _ => raise ActionError 295,

(*         ((FUNIDBIND FUNID))  *)

                   fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 296,

(* ;       ((TOPDEC))  *)

(* ; ;# fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB) *)

(*         ((TOPDEC STRDEC1PLUS))  *)

                   fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
 | _ => raise ActionError 297,

(*         ((TOPDEC SIGDEC1PLUS))  *)

                   fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
 | _ => raise ActionError 298,

(*         ((TOPDEC FUNDEC1PLUS))  *)

                   fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
 | _ => raise ActionError 299,

(*          ((TOPDEC EXP))  *)

                   fn ([EXP(exp,tyvars)],opts) =>
   TOPDEC (Derived.make_it_strdec(exp,tyvars,get_location opts,get_current_pE()),PE.empty_pB)
 | _ => raise ActionError 300,

(*          ((TOPDEC :require :string))  *)

                   fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
 | _ => raise ActionError 301,

(*          ((TOPDEC1 TOPDEC)) *)

                   fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 302,

(*          ((PROGRAM TOPDEC1 DECSEP PROGRAM))  *)

                   fn ([x,_,_],opts) => x
 | _ => raise ActionError 303,

(*          ((PROGRAM DECSEP PROGRAM))  *)

                   fn ([_,x],opts) => x
 | _ => raise ActionError 304,

(*         ((PROGRAM TOPDEC1 DECSEP))  *)

                   fn ([x,_],opts) => x
 | _ => raise ActionError 305,

(*         ((PROGRAM DECSEP))  *)

                   fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
 | _ => raise ActionError 306,

(* ;; New bit - this clause is at the end of the file to ensure correct *)
(* ;; handling of ambiguity. *)
(* ((DECSEP))  *)

                   fn ([],opts) => DUMMY
 | _ => raise ActionError 307,

(* 	))  *)

(* (setq parsergen::*simple-resolutions*  *)
(*   '(;; associativity of tupling  *)
(* 	((:reduce (tytuple tytuple star ty))  *)
(* 	 (:shift (ty ty :arrow ty)))  *)

(* 	((:reduce (tytuple ty star ty))  *)
(* 	 (:shift (ty ty :arrow ty)))  *)

(* 	((:shift (tytuple ty star ty))  *)
(* 	 (:reduce (ty ty :arrow ty)))  *)

(* 	;; always make a tuple before a type  *)
(* 	((:shift (tytuple tytuple star ty))  *)
(* 	 (:reduce (ty tytuple)))  *)

(* 	((:shift (ty ty longtycon))  *)
(* 	 (:reduce (pat pat :colon ty))) *)

(* 	((:shift (ty ty longtycon)) *)
(* 	 (:reduce (exp exp :colon ty))) *)

(* 	((:shift (ty ty longtycon)) *)
(* 	 (:reduce (optoftype :of ty))) *)

(* 	((:shift (ty ty longtycon)) *)
(* 	 (:reduce (longtypbind1 tyvarseq longtycon :equal ty))) *)

(* 	((:shift (ty ty longtycon)) *)
(* 	 (:reduce (typbind1 tyvarseq tycon :equal ty))) *)

(* 	;; matches go far to the left  *)
(* 	((:shift (match match :vbar mrule))  *)
(* 	 (:reduce (exp exp :handle match)))  *)

(* 	((:shift (match match :vbar mrule))  *)
(* 	 (:reduce (exp :fn match)))  *)

(* 	((:shift (match match :vbar mrule))  *)
(* 	 (:reduce (exp :case exp :of match)))  *)

(* 	;; semicolons,strdecs and decs  *)
(* 	;; Reduce decs to strdecs wherever possible  *)
(* 	((:reduce (strdec decsep))  *)
(*          (:reduce (dec decsep)))  *)

(* 	((:reduce (strdec1 dec1)) *)
(* 	 (:reduce (decsep))) *)

(* 	((:shift (strdec1plus0 strdec1 strdec1))  *)
(* 	 (:reduce (strdec1plus strdec1))) *)

(* 	((:shift (strdec1plus0 strdec1plus0 strdec1))  *)
(* 	 (:reduce (strdec1plus strdec1plus0))) *)

(* 	((:shift (symlist symlist sym))  *)
(* 	 (:reduce (dec1 :nonfix symlist)))  *)

(* 	((:shift (symlist symlist sym))  *)
(* 	 (:reduce (dec1 :infixr symlist)))  *)

(* 	((:shift (symlist symlist sym))  *)
(* 	 (:reduce (dec1 :infixr :integer symlist)))  *)


(* 	((:shift (longidlist longidlist :longid))  *)
(* 	 (:reduce (dec1 :open longidlist)))  *)

(* 	((:shift (symlist symlist sym))  *)
(* 	 (:reduce (dec1 :infix symlist)))  *)


(* 	((:shift (symlist symlist sym))  *)
(* 	 (:reduce (dec1 :infix :integer symlist)))  *)

(* 	((:reduce (sigidlist sigid)) *)
(* 	 (:reduce (sigexp sigid))) *)

(* ;; self conflicts  *)
(* 	((:reduce (tytuple ty star ty))  *)
(* 	 (:shift (tytuple ty star ty)))  *)

(* 	((:shift (ty ty :arrow ty))  *)
(*          (:reduce (ty ty :arrow ty)))  *)

(* 	((:reduce (exp exp :andalso exp))  *)
(*          (:shift (exp exp :andalso exp)))  *)

(* 	((:reduce (exp exp :orelse exp))  *)
(*          (:shift (exp exp :orelse exp)))  *)

(* 	((:reduce (program topdec1 decsep)) *)
(* 	 (:reduce (topdec))) *)

(* 	((:shift (program topdec1 decsep program)) *)
(* 	 (:reduce (topdec))) *)

(* 	((:shift (program topdec1 program)) *)
(* 	 (:reduce (topdec))) *)

(* 	((:reduce (program topdec1))  *)
(* 	 (:reduce (topdec))) *)
(*  	))  *)

(* (setq parsergen::*complex-resolutions*  *)
(*   '((((:reduce (atpat opvardef))(:shift (pat opvardef opttype :as pat)))  *)
(*       (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift)  *)
(*       (:colon (:resolve (:reduce (atpat opvardef)) :shift)))  *)

(*     (((:shift (pat oplongvar atpat))(:reduce (atpat oplongvar)))  *)
(*      (:funcall ifinfixinput (:reduce (atpat oplongvar)) :shift))  *)

(*     (((:shift (pat opvardef atpat))(:reduce (atpat opvardef)))  *)
(*      (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift))  *)

(*     (((:reduce (infexp appexp))(:shift (appexp appexp atexp)))  *)
(*      (:funcall ifinfixinput (:reduce (infexp appexp))(:shift (appexp appexp atexp))))  *)

(*     (((:reduce (pat atpat))(:shift (fval :lpar atpat vardef atpat :rpar opttype :equal exp)))  *)
(*      (:funcall ifinfixinput (:reduce (pat atpat)) :shift))  *)

(*     (((:reduce (atpat opvardef))(:shift (fval opvardef atpatlist opttype :equal exp)))  *)
(*      (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift))  *)

(*     (((:reduce (atpat1 bin_atpat))(:shift (fval bin_atpat atpatlist opttype :equal exp)))  *)
(*      (:funcall ifinfixinput (:reduce (atpat1 bin_atpat)):shift))  *)

(*     (((:reduce (pat atpat)) (:shift (bin_atpat :lpar atpat patvar atpat :rpar)))  *)
(*      (:funcall ifinfixinput :shift (:reduce (pat atpat))))  *)

(*     ;; problems with type tuples  *)
(*     (((:reduce (tytuple ty star ty)) (:shift (ty ty longtycon)))  *)
(*      (:funcall ifstarinput (:reduce (tytuple ty star ty)) :shift))  *)
(*     (((:reduce (tytuple tytuple star ty)) (:shift (ty ty longtycon)))  *)
(*      (:funcall ifstarinput (:reduce (tytuple tytuple star ty)) :shift))  *)
(*      *)
(*     ;; precedences  *)
(*     (((:reduce (pat pat var pat)) (:shift (pat pat var pat)))  *)
(*      (:funcall ifleftassoc (:reduce (pat pat var pat)) :shift))  *)
(*     (((:reduce (infexp infexp infvar infexp)) (:shift (infexp infexp infvar infexp)))  *)
(*      (:funcall ifleftassoc (:reduce (infexp infexp infvar infexp)) :shift))  *)
(*      *)
(*     ;; reduce-reduce conflicts  *)
(*     (((:reduce (vardef :longid)) (:reduce (longvar :longid))) *)
(*      (:funcall ifvarstack (:reduce (vardef :longid)) (:reduce (longvar :longid)))) *)
(*      *)
(*     (((:reduce (star :longid)) (:reduce (longtycon :longid)))  *)
(*      (:funcall ifstarstack (:reduce (star :longid)) (:reduce (longtycon :longid))))  *)
(*     ))  *)

(* (defun test ()  *)
(*   (parsergen::make-parsing-tables *mlg* ))  *)

(* (defun make-it ()  *)
(*   (compile-file "grammar.lisp" :load t)  *)
(*   (test))  *)

(* ;(op-parser::makeit)  *)
(* Do not delete this line 2 *)
fn _ => DUMMY
]

fun get_function n =
  MLWorks.Internal.Array.sub (actions,n)

type FinalValue = Absyn.TopDec

exception FinalValue

val dummy = DUMMY
fun get_final_value (TOPDEC x) = x
  | get_final_value _ = raise FinalValue

(* ambiguity resolution functions *)

(* ifInfixInput, ifVarStack, ifStarStack,ifStarInput,ifLeftAssoc *)
(* functions are of form action(s) stack_value list * stack_value => action *)

exception ResolveError of string

(* if the input symbol is an infix operator then do act1 else act2 *)
fun ifInfixInput _ (act1,act2, [], LONGID ([],s)) =
  (debug ("Checking infix for " ^ Symbol.symbol_name s);
   if is_infix s then act1 else act2)
  | ifInfixInput _ (act1,act2,[], EQVAL) =
  (debug "Checking infix for =";
   if is_infix equal_symbol then act1 else act2)
  | ifInfixInput _ (act1,act2,_,_) = act2

(* if the LongId on the stack is a short variable, do first action else 
   its a constructor and (if in sml'90 mode) do the second action *)
fun ifVarStack oldDefinition (varred,conred,[LONGID (id as ([],s))],_) =
  (case lookupValId id of
     SOME (Ident.VAR _) => varred
   | SOME (Ident.CON _) => if oldDefinition then conred else varred
   | SOME _ => conred
   | NONE => varred)
  | ifVarStack _ (_,conred,_,_) = conred

(* if the symbol on top of the stack is a star, do the first action *)
fun ifStarStack _ (starred,tyconred,[LONGID (id as ([],s))],_) =
  if Symbol.eq_symbol(s,asterisk_symbol) then starred else tyconred
  | ifStarStack _ (starred,tyconred,_,_) = tyconred

(* if the current input symbol is a star then do the first action *)
fun ifStarInput _ (staract,otheract,[],LONGID ([],s)) =
  if Symbol.eq_symbol(s,asterisk_symbol) then staract else otheract
  | ifStarInput _ (_,otheract,_,_) = otheract

fun get_precedence s =
  case PE.lookupFixity (s, !ref_pE) of
    PE.LEFT n => n
  | PE.RIGHT n => n
  | _ => 0
(*  | _ => Crash.impossible ("No fixity for infix symbol " ^ Symbol.symbol_name s) *)

fun associate_left s = 
  case PE.lookupFixity (s, !ref_pE) of
    PE.LEFT n => true
  | PE.RIGHT n => false
  | _ => false
(*  | _ => Crash.impossible "No fixity for infix symbol"  *)

(* return true if the two symbols associate to the left *)
fun get_associativity(old_definition, s1, s2) =
  ((*debug ("Comparing " ^ Symbol.symbol_name s1 ^ " and " ^ Symbol.symbol_name s2);*)
   if Symbol.eq_symbol(s1,s2)
    then associate_left s1
  else
    let
      val p1 = get_precedence s1
      val p2 = get_precedence s2
    in
      if p1 <> p2 then
	p1 > p2
      else
        if  old_definition then true
        else associate_left s1 (* New standard says use the associativity of the left hand operator *)
    end)

(* Do act1 if the symbol 2 down in the stack and the current input
   symbol associate to the left, otherwise act2 *)

fun ifLeftAssoc old_definition (act1,act2,[LONGVALID (lvalid,_),_], LONGID ([],s)) =
  let
    val Ident.LONGVALID (_,valid) = lvalid
  in
    if get_associativity (old_definition, get_sym valid, s) then act1 else act2
  end
  | ifLeftAssoc old_definition (act1,act2, [LONGVALID (lvalid,_),_], EQVAL) =
    let
      val Ident.LONGVALID (_,valid) = lvalid
    in
      if get_associativity (old_definition, get_sym valid,equal_symbol) then act1 else act2
    end
  | ifLeftAssoc _ (act1,act2,[LONGVALID (lvalid,_),_], _) = act1
  | ifLeftAssoc _ _ = raise ResolveError "Error in precedence"

type Act = LRbasics.Action
val resolutions  : (bool -> Act * Act * Parsed_Object list * Parsed_Object -> Act) MLWorks.Internal.Array.array =
  MLWorks.Internal.Array.arrayoflist[ifInfixInput,  (* 0, arity 0 *)
                    ifVarStack,    (* 1, arity 1 *)
                    ifStarStack,   (* 2, arity 1 *)
                    ifStarInput,   (* 3, arity 0 *)
                    ifLeftAssoc    (* 4, arity 2 *)
                    ]
                    
(*
MLWorks.Internal.Array.arrayoflist[
(* 0 *) sort_infexp (LRbasics.Reduce (1,LRbasics.INFEXP,27)), 
(* 1 *) sort_pat_prec (LRbasics.Reduce (3,LRbasics.INFEXP,28)),
(* 2 *) sort_patcon (LRbasics.Reduce (1,LRbasics.VARDEF,167), LRbasics.Reduce (1,LRbasics.LONGVAR,155)),
(* 3 *) sort_pat_prec (LRbasics.Reduce (3,LRbasics.PAT,131)),
(* 4 *) sort_out_asterisk (LRbasics.Reduce (1,LRbasics.STAR,177), LRbasics.Reduce (1,LRbasics.LONGTYCON,158)),
(* 5 *) sort_infexp (LRbasics.Reduce (1,LRbasics.ATPAT1,119)),
(* 6 *) sort_infexp (LRbasics.Reduce (1,LRbasics.ATPAT,108)),
(* 7 *) sort_infixfun (LRbasics.Reduce (1,LRbasics.PAT,129)),
(* 8 *) ifStarInput (LRbasics.Reduce(3,LRbasics.TYTUPLE,146),LRbasics.Shift),
(* 9 *) ifStarInput (LRbasics.Reduce(3,LRbasics.TYTUPLE,147),LRbasics.Shift)
]
*)

fun get_resolution (n, Options.OPTIONS{compat_options =
                                       Options.COMPATOPTIONS{old_definition, ...}, ...}) =
  MLWorks.Internal.Array.sub(resolutions,n) old_definition

exception UnexpectedIgnore

fun token_to_parsed_object (weak_tyvars, token) =
  case token of
    Token.RESERVED (x) =>
      (case x of
           Token.ABSTYPE => (LRbasics.ABSTYPE,DUMMY)
         | Token.ABSTRACTION => (LRbasics.ABSTRACTION,DUMMY)
         | Token.AND => (LRbasics.AND,DUMMY)
         | Token.ANDALSO => (LRbasics.ANDALSO,DUMMY)
         | Token.AS => (LRbasics.AS,DUMMY)
         | Token.CASE => (LRbasics.CASE,DUMMY)
         | Token.DO => (LRbasics.DO,DUMMY)
         | Token.DATATYPE => (LRbasics.DATATYPE,DUMMY)
         | Token.ELSE => (LRbasics.ELSE,DUMMY)
         | Token.END => (LRbasics.END,DUMMY)
         | Token.EXCEPTION => (LRbasics.EXCEPTION,DUMMY)
         | Token.FN => (LRbasics.FN,DUMMY)
         | Token.FUN => (LRbasics.FUN,DUMMY)
         | Token.HANDLE => (LRbasics.HANDLE,DUMMY)
         | Token.IF => (LRbasics.IF,DUMMY)
         | Token.IN => (LRbasics.IN,DUMMY)
         | Token.INFIX => (LRbasics.INFIX,DUMMY)
         | Token.INFIXR => (LRbasics.INFIXR,DUMMY)
         | Token.LET => (LRbasics.LET,DUMMY)
         | Token.LOCAL => (LRbasics.LOCAL,DUMMY)
         | Token.NONFIX => (LRbasics.NONFIX,DUMMY)
         | Token.OF => (LRbasics.OF,DUMMY)
         | Token.OP => (LRbasics.OP,DUMMY)
         | Token.OPEN => (LRbasics.OPEN,DUMMY)
         | Token.ORELSE => (LRbasics.ORELSE,DUMMY)
         | Token.RAISE => (LRbasics.RAISE,DUMMY)
         | Token.REC => (LRbasics.REC,DUMMY)
         | Token.REQUIRE => (LRbasics.REQUIRE,DUMMY)
         | Token.THEN => (LRbasics.THEN,DUMMY)
         | Token.TYPE => (LRbasics.TYPE,DUMMY)
         | Token.VAL => (LRbasics.VAL,DUMMY)
         | Token.WITH => (LRbasics.WITH,DUMMY)
         | Token.WITHTYPE => (LRbasics.WITHTYPE,DUMMY)
         | Token.WHERE => (LRbasics.WHERE,DUMMY)
         | Token.WHILE => (LRbasics.WHILE,DUMMY)
         | Token.EQTYPE => (LRbasics.EQTYPE,DUMMY)
         | Token.FUNCTOR => (LRbasics.FUNCTOR,DUMMY)
         | Token.INCLUDE => (LRbasics.INCLUDE,DUMMY)
         | Token.SHARING => (LRbasics.SHARING,DUMMY)
         | Token.SIG => (LRbasics.SIG,DUMMY)
         | Token.SIGNATURE => (LRbasics.SIGNATURE,DUMMY)
         | Token.STRUCT => (LRbasics.STRUCT,DUMMY)
         | Token.STRUCTURE => (LRbasics.STRUCTURE,DUMMY)
         | Token.LPAR => (LRbasics.LPAR,DUMMY)
         | Token.RPAR => (LRbasics.RPAR,DUMMY)
         | Token.BRA => (LRbasics.BRA,DUMMY)
         | Token.KET => (LRbasics.KET,DUMMY)
         | Token.LBRACE => (LRbasics.LBRACE,DUMMY)
         | Token.RBRACE => (LRbasics.RBRACE,DUMMY)
         | Token.COMMA => (LRbasics.COMMA,DUMMY)
         | Token.COLON => (LRbasics.COLON,DUMMY)
         | Token.ABSCOLON => (LRbasics.ABSCOLON,DUMMY)
         | Token.SEMICOLON => (LRbasics.SEMICOLON,DUMMY)
         | Token.ELLIPSIS => (LRbasics.ELLIPSIS,DUMMY)
         | Token.UNDERBAR => (LRbasics.UNDERBAR,DUMMY)
         | Token.VBAR => (LRbasics.VBAR,DUMMY)
         | Token.EQUAL => (LRbasics.EQUAL,EQVAL)
         | Token.DARROW => (LRbasics.DARROW,DUMMY)
         | Token.ARROW => (LRbasics.ARROW,DUMMY)
         | Token.HASH => (LRbasics.HASH,DUMMY)
         | Token.MAGICOPEN =>  (LRbasics.MAGICOPEN,DUMMY))
  | Token.EOF _ => (LRbasics.EOF,DUMMY)
  | Token.INTEGER s => (LRbasics.INTEGER,INTEGER s)
  | Token.REAL s => (LRbasics.REAL,REAL s)
  | Token.STRING s => (LRbasics.STRING, STRING s)
  | Token.CHAR s => (LRbasics.CHAR, CHAR s)
  | Token.WORD s => (LRbasics.WORD, WORD s)
  | Token.LONGID (l,s) => (LRbasics.LONGID,LONGID (l,s))
  | Token.TYVAR t =>
      if weak_tyvars then
	let
	  val (sy, eq, imp) = t
	  val string = Symbol.symbol_name sy
	  val len = size string
	  val weak =
	    if len <= 1 orelse (eq andalso len <= 2) then
	      false
	    else
	      let
		val weak_char =
		  MLWorks.String.ordof(string, if eq then 2 else 1)
	      in
		ord #"1" <= weak_char andalso ord #"9" >= weak_char
	      end
	in
	  (LRbasics.TYVAR, TYVAR (Ident.TYVAR(if weak then (sy, eq, true) else t)))
	end
      else
	(LRbasics.TYVAR, TYVAR (Ident.TYVAR t))
  | Token.IGNORE => raise UnexpectedIgnore

end;
@


1.95.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.95  1999/02/02  16:01:35  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.94
log
@[Bug #30352]
Prune parser value environment after abstype
@
text
@d4 4
a316 1
require "../parser/parserenv";
@


1.93
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d1898 1
a1898 1
       PE.augment_pE (pVEpTE_in_pE(pVE,pTE),pE),tyvars)
d1910 1
a1910 1
              PE.augment_pE (pVEpTE_in_pE(pVE,pTE),pE),tyvars))
@


1.92
log
@[Bug #30341]
Correct derived form of where in grammar
@
text
@d4 4
d2121 1
a2121 1
         in (merge_pVEs(opts,pVE1,pVE2);
d2130 1
a2130 1
          (merge_pVEs(opts,pVE1,pVE2);
d2143 1
a2143 1
         merge_pVEs(opts,pVE1,pVE2);
d2151 1
a2151 1
          merge_pVEs(opts,pVE1,pVE2);
@


1.91
log
@[Bug #50015]
Add missing call to check_rec_bindings
@
text
@d4 4
d1510 3
d1527 1
a1527 1
                fn ([dec],opts) => dec
d1532 1
a1532 1
                fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1537 1
a1537 1
                fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1545 1
a1545 1
                fn ([_],opts) =>
d1552 1
a1552 1
                fn ([_,_],opts) => 
d1559 1
a1559 1
                fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1564 1
a1564 1
                fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1569 1
a1569 1
              fn ([_,LAB lab],opts) =>
d1574 1
a1574 1
                fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1578 1
a1578 1
                fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
d1583 1
a1583 1
                fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1588 1
a1588 1
                fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1593 1
a1593 1
              fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
d1598 1
a1598 1
                fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1603 1
a1603 1
                fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1610 1
a1610 1
                fn ([_,x,_],opts) => x
d1615 1
a1615 1
                fn ([_],opts) => ENV (get_current_pE())
d1620 1
a1620 1
                fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1625 1
a1625 1
                fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1630 1
a1630 1
                fn ([],opts) => EXPLIST ([],Set.empty_set)
d1635 1
a1635 1
                fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1640 1
a1640 1
                fn ([exp],opts) => exp
d1645 1
a1645 1
                fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1651 1
a1651 1
                fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
d1656 1
a1656 1
                fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1662 1
a1662 1
                fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1667 1
a1667 1
                fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1673 1
a1673 1
                fn ([x],opts) => x
d1678 1
a1678 1
                fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1684 1
a1684 1
                fn ([x],opts) => x
d1689 1
a1689 1
                fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1695 1
a1695 1
                fn ([x],opts) => x
d1700 1
a1700 1
                fn ([_],opts) => LONGVALID (equal_lvalid,NONE)
d1705 1
a1705 1
                fn ([x],opts) => x
d1710 1
a1710 1
                fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1716 1
a1716 1
              fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1722 1
a1722 1
              fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1728 1
a1728 1
                fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1734 1
a1734 1
                fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
d1740 1
a1740 1
                fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1746 1
a1746 1
              fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1752 1
a1752 1
                fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1758 1
a1758 1
                fn ([_,MATCH (match,tyvars)],opts) =>
d1764 1
a1764 1
                fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1769 1
a1769 1
                fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1775 1
a1775 1
               fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
d1781 1
a1781 1
                fn ([_,_],opts) => DUMMY
d1786 1
a1786 1
                fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1791 1
a1791 1
                fn ([_,dec,_],opts) => dec
d1796 1
a1796 1
                fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1801 1
a1801 1
                fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1806 1
a1806 1
                fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1815 1
a1815 1
                fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1821 1
a1821 1
                fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1827 1
a1827 1
              fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1834 1
a1834 1
              fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1841 1
a1841 1
                fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1847 1
a1847 1
               fn ([_,DATREPL(tyvars,tycon,longtycon)],opts)=>
d1868 1
a1868 1
                fn ([_,DATBIND (d,pVE,pTE)],opts) => 
d1878 1
a1878 1
                fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t],opts) =>
d1888 1
a1888 1
                fn ([_,DATBIND (d,pVE,pTE),_,DEC(dec,pE,tyvars),_],opts) =>
d1897 1
a1897 1
       fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t,_,DEC(dec,pE,tyvars),_],
d1909 1
a1909 1
       fn ([d as (DATBIND(_,pVE,pTE))],opts) =>
d1917 1
a1917 1
       fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1926 1
a1926 1
       fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,
d1939 1
a1939 1
       fn ([_,LONGIDLIST l],opts) => 
d1951 1
a1951 1
       fn ([_,SYMLIST l],opts) =>
d1959 1
a1959 1
       fn ([_,INTEGER i,SYMLIST l],opts) =>
d1967 1
a1967 1
       fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1974 1
a1974 1
       fn ([_,INTEGER i,SYMLIST l],opts) =>
d1982 1
a1982 1
       fn ([_,SYMLIST l],opts) =>
d1993 1
a1993 1
       fn ([_],opts) => ENV (get_current_pE())
d2000 1
a2000 1
       fn ([x],opts) => x
d2007 1
a2007 1
       fn ([VALBIND(v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],
d2017 1
a2017 1
       fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,
d2028 1
a2028 1
     fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d2042 1
a2042 1
       fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d2055 1
a2055 1
       fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d2064 1
a2064 1
       fn ([FVALBIND ((l,tyvars1),pVE),_,
d2074 1
a2074 1
       fn ([FVAL ((fval,tyvars),id)],opts) => 
d2085 1
a2085 1
       fn ([FVALLIST (fvals,tyvars1,id,_),_,
d2095 1
a2095 1
       fn ([VALID id,PATLIST(l,pE,tyvars1),TY(ty,tyvars2),
d2114 1
a2114 1
       fn ([PAT(pat1,pVE1,tyvars1),VALID id,PAT(pat2,pVE2,tyvars2),
d2135 1
a2135 1
       fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),
a2142 1

d2156 1
a2156 1
       fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),
a2161 1

d2173 1
a2173 1
       fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,
a2178 1

d2190 1
a2190 1
       fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,
d2208 1
a2208 1
       fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),
d2227 1
a2227 1
       fn ([],opts) => NULLTYPE
d2234 1
a2234 1
       fn ([_,ty],opts) => ty
d2241 1
a2241 1
       fn ([x],opts) => x
d2248 1
a2248 1
       fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
d2254 1
a2254 1
                fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d2261 1
a2261 1
                fn ([x],opts) => x
d2266 1
a2266 1
                fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d2272 1
a2272 1
                fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
d2279 1
a2279 1
                fn ([],opts) => TYVARLIST []
d2284 1
a2284 1
      	 fn ([x],opts) => x
d2289 1
a2289 1
                fn ([TYVAR t],opts) => TYVARLIST [t]
d2294 1
a2294 1
                fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d2299 1
a2299 1
                fn ([TYVAR t],opts) => TYVARLIST [t]
d2304 1
a2304 1
                fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d2310 1
a2310 1
                fn ([DATAHDR(tyvars, tycon),_, LONGTYCON longtycon],opts) =>
d2318 1
a2318 1
                fn ([DATBIND1(d,pVE,pTE)],opts) => DATBIND([d],pVE,pTE)
d2323 1
a2323 1
                fn ([DATBIND(l,pVE,pTE),_,DATBIND1(d,pVE',pTE')],opts) =>
d2330 1
a2330 1
                fn ([DATAHDR(tyvarlist,tycon),CONBIND (conbind,pVE,tyvars)],opts) =>
d2341 1
a2341 1
               fn ([TYVARLIST tyvarlist, TYCON tycon,_],opts) =>
d2348 1
a2348 1
                fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d2353 1
a2353 1
                fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d2359 1
a2359 1
                   fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,SOME ty),id,tyvars)
d2365 1
a2365 1
                fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d2370 1
a2370 1
                fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d2376 1
a2376 1
                   fn ([VALID id, TY (ty,tyvars)],opts) => 
d2384 1
a2384 1
                fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d2391 1
a2391 1
                fn ([],opts) => NULLTYPE
d2396 1
a2396 1
                fn ([_,x],opts) => x
d2401 1
a2401 1
                fn ([_],opts as OPTS(location,options,_)) =>
d2407 1
a2407 1
    fn ([SCON (x as (Ident.REAL _))],opts) => 
d2430 1
a2430 1
       fn ([VALID id],opts) => 
d2441 1
a2441 1
     fn ([LONGVALID (id,strname_opt)],opts) => 
d2451 1
a2451 1
                fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d2457 1
a2457 1
                fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d2463 1
a2463 1
                fn ([_,_,_],opts) => 
d2469 1
a2469 1
                fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2474 1
a2474 1
                fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2479 1
a2479 1
                fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d2484 1
a2484 1
                fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d2489 1
a2489 1
                fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
d2494 1
a2494 1
                fn ([_,x,_],opts) => x
d2499 1
a2499 1
                fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
d2504 1
a2504 1
                fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,
d2511 1
a2511 1
                fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2520 1
a2520 1
                fn ([x],opts) => x
d2525 1
a2525 1
                fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2531 1
a2531 1
                fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2537 1
a2537 1
                fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d2542 1
a2542 1
                fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2549 1
a2549 1
                fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d2554 1
a2554 1
                fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2564 1
a2564 1
                fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2574 1
a2574 1
                fn ([x],opts) => x
d2579 1
a2579 1
                 fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2587 1
a2587 1
                fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2594 1
a2594 1
                fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2601 1
a2601 1
                fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
d2606 1
a2606 1
                  fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2616 1
a2616 1
                fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d2621 1
a2621 1
                fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d2626 1
a2626 1
                fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d2631 1
a2631 1
                fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
d2636 1
a2636 1
                fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
d2641 1
a2641 1
                fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
d2646 1
a2646 1
                fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d2651 1
a2651 1
                fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d2656 1
a2656 1
                fn ([_,t,_],opts) => t
d2661 1
a2661 1
                fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d2666 1
a2666 1
                fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2671 1
a2671 1
                fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2676 1
a2676 1
                fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2681 1
a2681 1
                fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2686 1
a2686 1
                fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2691 1
a2691 1
                fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2699 1
a2699 1
                fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2704 1
a2704 1
                fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2712 1
a2712 1
                fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2717 1
a2717 1
                fn ([LONGID id],opts) => LONGIDLIST[id]
d2724 1
a2724 1
                fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2729 1
a2729 1
                fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2736 1
a2736 1
                fn ([SYM sym],opts) => SYMLIST [sym]
d2741 1
a2741 1
                fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2748 1
a2748 1
                fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
d2753 1
a2753 1
                fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
d2758 1
a2758 1
                fn ([STRING s],opts) => SCON (Ident.STRING s)
d2763 1
a2763 1
                fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2768 1
a2768 1
                fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
d2775 1
a2775 1
                fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2782 1
a2782 1
                fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2789 1
a2789 1
                fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2794 1
a2794 1
                fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2799 1
a2799 1
                fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2804 1
a2804 1
                fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2809 1
a2809 1
                fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2816 1
a2816 1
                fn ([LONGID ([],s)],opts) => SYM s
d2823 1
a2823 1
                fn ([_],opts) => SYM equal_symbol
d2829 1
a2829 1
                fn ([LONGID ([],s)],opts) => SYM s
d2836 1
a2836 1
                fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2841 1
a2841 1
                fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2846 1
a2846 1
                fn ([SYM s],opts) => STRID(Ident.STRID s)
d2855 1
a2855 1
                fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),NONE)
d2863 1
a2863 1
       fn ([LONGID ([],id)],opts) => 
d2876 1
a2876 1
                fn ([valid as VALID id],opts) => 
d2882 1
a2882 1
                fn ([_,valid as VALID id],opts) => 
d2889 1
a2889 1
                fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2895 1
a2895 1
                fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2901 1
a2901 1
                fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2906 1
a2906 1
                fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2911 1
a2911 1
                fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2917 1
a2917 1
                fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2922 1
a2922 1
                fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2927 1
a2927 1
                fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2933 1
a2933 1
                fn ([LONGID ([],s)],opts) => DUMMY 
d2941 1
a2941 1
                fn ([ENV pE,STRDEC (x,e),_],opts) =>
d2948 1
a2948 1
                fn ([LONGID x],opts) =>
d2956 1
a2956 1
                fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2962 1
a2962 1
                fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2968 1
a2968 1
                fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2975 1
a2975 1
        fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
d2981 1
a2981 1
                fn ([_],opts) => ENV (get_current_pE())
d2986 1
a2986 1
                fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2991 1
a2991 1
                fn ([_,strdec,_],opts) => strdec
d2996 1
a2996 1
                fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d3001 1
a3001 1
                fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d3006 1
a3006 1
                fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d3013 1
a3013 1
                fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d3018 1
a3018 1
                fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d3023 1
a3023 1
                fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d3029 1
a3029 1
                fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d3037 1
a3037 1
                fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d3042 1
a3042 1
                fn ([_,STRBIND(l,pSE)],opts) => 
d3048 1
a3048 1
                fn ([_,STRBIND(l,pSE)],opts) => 
d3054 1
a3054 1
                fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d3059 1
a3059 1
       fn ([_],opts) => BOOL false
d3063 1
a3063 1
       fn ([_],opts) => BOOL true
d3068 1
a3068 1
                fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d3073 1
a3073 1
                fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d3079 1
a3079 1
               fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,
d3096 1
a3096 1
               fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d3109 1
a3109 1
           fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d3115 1
a3115 1
           fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref NONE,get_location opts),lookupSigId(opts,id))
d3118 2
a3119 2
(*         ((SIGEXP SIGEXP :where :type LONGTYPBIND)) *)
        fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
d3125 1
a3125 1
                fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d3130 1
a3130 1
                fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d3135 1
a3135 1
                fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d3140 1
a3140 1
                fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d3145 1
a3145 1
                fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
d3150 1
a3150 1
          fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d3154 12
d3167 2
a3168 2
          fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
 | _ => raise ActionError 236,
d3172 1
a3172 1
          fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
d3174 1
a3174 1
 | _ => raise ActionError 237,
d3178 1
a3178 1
        fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
d3180 1
a3180 1
 | _ => raise ActionError 238,
d3185 2
a3186 2
      fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
 | _ => raise ActionError 239,
d3190 2
a3191 2
          fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
 | _ => raise ActionError 240,
d3195 2
a3196 2
          fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 241,
d3200 2
a3201 2
                fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 242,
d3206 1
a3206 1
                fn ([_,DATREPLDESC(tyvars,tycon,longtycon)],opts) =>
d3219 1
a3219 1
 | _ => raise ActionError 243,
d3223 1
a3223 1
                fn ([_,DATDESC(l,pVE,pTE)],opts) =>
d3228 1
a3228 1
 | _ => raise ActionError 244,
d3232 2
a3233 2
                fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
 | _ => raise ActionError 245,
d3237 2
a3238 2
                fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
 | _ => raise ActionError 246,
d3242 1
a3242 1
           fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d3245 1
a3245 1
 | _ => raise ActionError 247,
d3249 1
a3249 1
           fn ([_,LONGIDLIST l],opts) => 
d3252 1
a3252 1
 | _ => raise ActionError 248,
d3256 2
a3257 2
                fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 249,
d3260 1
a3260 1
      
d3263 1
a3263 1
 | _ => raise ActionError 250,
d3268 2
a3269 2
                  fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 251,
d3273 2
a3274 2
                  fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 252,
d3278 2
a3279 2
                  fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 253,
d3283 2
a3284 2
                  fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 254,
d3288 2
a3289 2
                fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 255,
d3293 2
a3294 2
                fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 256,
d3298 2
a3299 2
                fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 257,
d3303 1
a3303 1
                fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d3305 1
a3305 1
 | _ => raise ActionError 258,
d3309 2
a3310 2
                fn ([x],opts) => x
 | _ => raise ActionError 259,
d3314 1
a3314 1
                fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
d3316 1
a3316 1
 | _ => raise ActionError 260,
d3320 1
a3320 1
          fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
d3322 1
a3322 1
 | _ => raise ActionError 261,
d3326 1
a3326 1
          fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
d3328 1
a3328 1
 | _ => raise ActionError 262,
d3332 1
a3332 1
                fn ([DATAHDR(tyvars,tycon),_,LONGTYCON longtycon],opts) =>
d3334 1
a3334 1
 | _ => raise ActionError 263,
d3339 1
a3339 1
                fn ([DATDESC1(d,pVE,pTE)],opts) =>
d3341 1
a3341 1
 | _ => raise ActionError 264,
d3345 1
a3345 1
                fn ([DATDESC(l,pVE,pTE),_,DATDESC1(d,pVE',pTE')],opts) =>
d3348 1
a3348 1
 | _ => raise ActionError 265,
d3352 1
a3352 1
                fn ([DATAHDR(tyvarlist,tycon),CONDESC (l,pVE,tyvars)],opts) =>
d3355 1
a3355 1
 | _ => raise ActionError 266,
d3359 2
a3360 2
                fn ([x],opts) => x
 | _ => raise ActionError 267,
d3364 1
a3364 1
                fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d3366 1
a3366 1
 | _ => raise ActionError 268,
d3370 1
a3370 1
                   fn ([VALID con,TY(ty,tyvars)],opts) => 
d3374 1
a3374 1
 | _ => raise ActionError 269,
d3378 2
a3379 2
                fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 270,
d3383 1
a3383 1
                fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d3385 1
a3385 1
 | _ => raise ActionError 271,
d3389 1
a3389 1
                   fn ([VALID excon,TY(ty,_)],opts) => 
d3393 1
a3393 1
 | _ => raise ActionError 272,
d3397 2
a3398 2
                fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 273,
d3402 1
a3402 1
                fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d3404 1
a3404 1
 | _ => raise ActionError 274,
d3408 2
a3409 2
                fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 275,
d3413 2
a3414 2
                fn ([x],opts) => x
 | _ => raise ActionError 276,
d3418 2
a3419 2
                fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 277,
d3423 2
a3424 2
                fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
 | _ => raise ActionError 278,
d3428 2
a3429 2
                fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
 | _ => raise ActionError 279,
d3433 2
a3434 2
                fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 280,
d3438 2
a3439 2
                fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 281,
d3443 2
a3444 2
                fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 282,
d3448 2
a3449 2
                fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 283,
d3453 2
a3454 2
                fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 284,
d3458 2
a3459 2
                fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 285,
d3463 2
a3464 2
                fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 286,
d3468 1
a3468 1
                fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d3470 1
a3470 1
 | _ => raise ActionError 287,
d3474 1
a3474 1
                fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d3476 1
a3476 1
 | _ => raise ActionError 288,
d3480 1
a3480 1
               fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3493 1
a3493 1
 | _ => raise ActionError 289,
d3497 1
a3497 1
          fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d3510 1
a3510 1
 | _ => raise ActionError 290,
d3514 1
a3514 1
                   fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3516 1
a3516 1
 | _ => raise ActionError 291,
d3520 1
a3520 1
                   fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d3522 1
a3522 1
 | _ => raise ActionError 292,
d3526 1
a3526 1
                fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d3528 1
a3528 1
 | _ => raise ActionError 293,
d3532 1
a3532 1
                fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d3534 1
a3534 1
 | _ => raise ActionError 294,
d3538 2
a3539 2
                fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 295,
d3547 2
a3548 2
                fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
 | _ => raise ActionError 296,
d3552 2
a3553 2
                fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
 | _ => raise ActionError 297,
d3557 2
a3558 2
                fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
 | _ => raise ActionError 298,
d3562 1
a3562 1
                fn ([EXP(exp,tyvars)],opts) =>
d3564 1
a3564 1
 | _ => raise ActionError 299,
d3568 2
a3569 2
                fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
 | _ => raise ActionError 300,
d3573 2
a3574 2
                fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 301,
d3578 2
a3579 2
                fn ([x,_,_],opts) => x
 | _ => raise ActionError 302,
d3583 2
a3584 2
                fn ([_,x],opts) => x
 | _ => raise ActionError 303,
d3588 2
a3589 2
                fn ([x,_],opts) => x
 | _ => raise ActionError 304,
d3593 2
a3594 2
                fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
 | _ => raise ActionError 305,
d3600 2
a3601 2
                fn ([],opts) => DUMMY
 | _ => raise ActionError 306,
@


1.90
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d2012 3
a2014 2
        VALBIND (v1,v1' @@ v2 @@ v2',Set.union(tyvars1,tyvars2),
                 merge_pVEs(opts,pVE1,pVE2))
@


1.89
log
@[Bug #30209]
Added type constructor environments for datatype specifications.
@
text
@d4 4
a291 1
require "^.basis.__old";
d569 1
a569 1
fun char_digit s = Old.ord s - ord #"0"
@


1.89.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.89  1997/07/31  12:28:18  daveb
 * [Bug #30209]
 * Added type constructor environments for datatype specifications.
 *
@


1.89.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.89  1997/07/31  12:28:18  daveb
 * [Bug #30209]
 * Added type constructor environments for datatype specifications.
 *
@


1.88
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d409 1
a409 1
  | DATDESC of (TyVarList * Ident.TyCon * (ConType list)) list * PE.pVE
d411 1
a411 1
  | DATDESC1 of (TyVarList * Ident.TyCon * (ConType list)) * PE.pVE
d3186 9
a3194 3
     SPEC(Absyn.DATATYPEreplSpec(get_location opts,tycon,longtycon,
                                 ref NONE),
          (PE.empty_pE,nil)))
d3199 5
a3203 2
                fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),
                                                                (pVE_in_pE pVE,names_of_datdesc l)))
d3315 2
a3316 1
                fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d3321 3
a3323 2
                fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
  (check_disjoint_datdesc(opts,d,l); DATDESC(d::l,merge_pVEs(opts,pVE,pVE')))
d3330 1
a3330 1
   DATDESC1((rev tyvarlist,tycon,(rev l)),pVE))
@


1.87
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d556 1
a556 3
fun do_output message =
  (MLWorks.IO.output(MLWorks.IO.std_out,message);
   MLWorks.IO.output(MLWorks.IO.std_out,"\n"))
@


1.86
log
@[Bug #30110]
Handling LookupStrId exception in datatype replication properly.
@
text
@d4 4
a314 1
structure Option = MLWorks.Option
d349 1
a349 1
  | LONGVALID of Ident.LongValId * string Option.option
@


1.85
log
@[Bug #1759]
Allowing constructor rebinding when in a val rec binding and
also in a funbind.
@
text
@d4 5
d763 1
a763 1
  case PE.lookupTycon (x,!ref_pE)
d768 2
a769 1
     | SOME x => x
@


1.85.1.1
log
@branched from 1.85
@
text
@a3 5
 * Revision 1.85  1996/11/28  16:11:48  andreww
 * [Bug #1759]
 * Allowing constructor rebinding when in a val rec binding and
 * also in a funbind.
 *
@


1.85.1.2
log
@[Bug #30110]
Handling LookupStrId exception in datatype replication properly.
@
text
@a3 11
 * Revision 1.85.1.1  1997/05/12  10:38:38  hope
 * branched from 1.85
 *
 * Revision 1.87  1997/05/07  14:53:47  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.86  1997/05/06  10:17:17  andreww
 * [Bug #30110]
 * Handling LookupStrId exception in datatype replication properly.
 *
d311 1
d346 1
a346 1
  | LONGVALID of Ident.LongValId * string option
d763 1
a763 1
  (case PE.lookupTycon (x,!ref_pE)
d768 1
a768 2
     | SOME x => x)
     handle PE.LookupStrId _ => PE.empty_pVE (*error caught in typechecker*)
@


1.85.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 4
 * Revision 1.85.1.2  1997/05/14  14:13:31  daveb
 * [Bug #30110]
 * Handling LookupStrId exception in datatype replication properly.
 *
@


1.85.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 4
 * Revision 1.85.1.2  1997/05/14  14:13:31  daveb
 * [Bug #30110]
 * Handling LookupStrId exception in datatype replication properly.
 *
@


1.85.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 4
 * Revision 1.85.1.2  1997/05/14  14:13:31  daveb
 * [Bug #30110]
 * Handling LookupStrId exception in datatype replication properly.
 *
@


1.85.1.2.1.2
log
@[Bug #30209]
Merged datatype replication change.
@
text
@a3 3
 * Revision 1.85.1.2.1.1  1997/07/28  18:23:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d412 1
a412 1
  | DATDESC of (TyVarList * Ident.TyCon * (ConType list)) list * PE.pVE * PE.pTE
d414 1
a414 1
  | DATDESC1 of (TyVarList * Ident.TyCon * (ConType list)) * PE.pVE * PE.pTE
d3191 3
a3193 9
     let val pVE = lookupLongTycon longtycon
         val pTE = (make_pTE (tycon,pVE))
     in 
       extend_pVE pVE;
       extend_pTE pTE;
       SPEC(Absyn.DATATYPEreplSpec(get_location opts,tycon,longtycon,
                                    ref NONE),
            (pVEpTE_in_pE(pVE,pTE), nil))
     end)
d3198 2
a3199 5
                fn ([_,DATDESC(l,pVE,pTE)],opts) =>
		  (extend_pVE pVE;
		   extend_pTE pTE;
		   SPEC(Absyn.DATATYPEspec (rev l), (pVEpTE_in_pE (pVE,pTE),
			names_of_datdesc l)))
d3311 1
a3311 2
                fn ([DATDESC1(d,pVE,pTE)],opts) =>
		  DATDESC([d],pVE,pTE)
d3316 2
a3317 3
                fn ([DATDESC(l,pVE,pTE),_,DATDESC1(d,pVE',pTE')],opts) =>
  (check_disjoint_datdesc(opts,d,l);
   DATDESC(d::l, merge_pVEs(opts,pVE,pVE'), merge_pTEs(opts,pTE,pTE')))
d3324 1
a3324 1
   DATDESC1((rev tyvarlist,tycon,(rev l)), pVE, make_pTE (tycon,pVE)))
@


1.85.1.2.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.85.1.2.1.2  1997/08/11  12:11:03  daveb
 * [Bug #30209]
 * Merged datatype replication change.
 *
@


1.84
log
@[Bug #1711]
forbidding real literals as patterns in SML'96 mode.
@
text
@d4 4
d801 1
d807 1
d1088 1
d1096 1
a1096 1
       if not (is_con_pat pat) then
d1173 79
d1483 1
d1498 1
a1498 1
               fn ([dec],opts) => dec
d1503 1
a1503 1
               fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1508 1
a1508 1
               fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1516 1
a1516 1
               fn ([_],opts) =>
d1523 1
a1523 1
               fn ([_,_],opts) => 
d1530 1
a1530 1
               fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1535 1
a1535 1
               fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1540 1
a1540 1
             fn ([_,LAB lab],opts) =>
d1545 1
a1545 1
               fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1549 1
a1549 1
               fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
d1554 1
a1554 1
               fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1559 1
a1559 1
               fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1564 1
a1564 1
             fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
d1569 1
a1569 1
               fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1574 1
a1574 1
               fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1581 1
a1581 1
               fn ([_,x,_],opts) => x
d1586 1
a1586 1
               fn ([_],opts) => ENV (get_current_pE())
d1591 1
a1591 1
               fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1596 1
a1596 1
               fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1601 1
a1601 1
               fn ([],opts) => EXPLIST ([],Set.empty_set)
d1606 1
a1606 1
               fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1611 1
a1611 1
               fn ([exp],opts) => exp
d1616 1
a1616 1
               fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1622 1
a1622 1
               fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
d1627 1
a1627 1
               fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1633 1
a1633 1
               fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1638 1
a1638 1
               fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1644 1
a1644 1
               fn ([x],opts) => x
d1649 1
a1649 1
               fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1655 1
a1655 1
               fn ([x],opts) => x
d1660 1
a1660 1
               fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1666 1
a1666 1
               fn ([x],opts) => x
d1671 1
a1671 1
               fn ([_],opts) => LONGVALID (equal_lvalid,NONE)
d1676 1
a1676 1
               fn ([x],opts) => x
d1681 1
a1681 1
               fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1687 1
a1687 1
             fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1693 1
a1693 1
             fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1699 1
a1699 1
               fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1705 1
a1705 1
               fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
d1711 1
a1711 1
               fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1717 1
a1717 1
             fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1723 1
a1723 1
               fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1729 1
a1729 1
               fn ([_,MATCH (match,tyvars)],opts) =>
d1735 1
a1735 1
               fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1740 1
a1740 1
               fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1746 1
a1746 1
              fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
d1752 1
a1752 1
               fn ([_,_],opts) => DUMMY
d1757 1
a1757 1
               fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1762 1
a1762 1
               fn ([_,dec,_],opts) => dec
d1767 1
a1767 1
               fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1772 1
a1772 1
               fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1777 1
a1777 1
               fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1786 1
a1786 1
               fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1792 1
a1792 1
               fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1798 1
a1798 1
             fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1805 1
a1805 1
             fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1812 1
a1812 1
               fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1818 1
a1818 1
              fn ([_,DATREPL(tyvars,tycon,longtycon)],opts)=>
d1839 1
a1839 1
               fn ([_,DATBIND (d,pVE,pTE)],opts) => 
d1849 1
a1849 1
               fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t],opts) =>
d1859 1
a1859 1
               fn ([_,DATBIND (d,pVE,pTE),_,DEC(dec,pE,tyvars),_],opts) =>
d1864 2
d1868 6
a1873 5
               fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
  (check_disjoint_withtype(opts,d,t);
   DEC (Derived.make_abstype_withtype (get_location opts,rev d,t,dec,
				       options_of opts),
        PE.augment_pE (pVEpTE_in_pE(pVE,pTE),pE),tyvars))
d1876 2
d1879 3
a1881 2
               fn ([d as (DATBIND(_,pVE,pTE))],opts) => (extend_pVE pVE;
                                                        extend_pTE pTE; d)
d1884 2
d1888 3
a1890 2
               fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
  (extend_pVE pVE; DEC (Absyn.EXCEPTIONdec (rev l),pVE_in_pE pVE,tyvars))
d1893 2
d1897 4
a1900 3
               fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
  (set_pE (PE.augment_pE (env_pE,pE));
   DEC (Absyn.LOCALdec (dec1,dec2),pE,Set.union(tyvars1,tyvars2)))
d1903 2
d1907 1
d1910 2
a1911 1
               fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1914 2
d1919 1
d1922 2
a1923 1
               fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1926 2
d1930 2
a1931 1
               fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1934 2
d1938 1
a1938 1
               fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1941 2
d1945 2
a1946 1
               fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1949 2
d1953 2
a1954 1
               fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1957 2
d1961 1
d1964 1
a1964 1
               fn ([_],opts) => ENV (get_current_pE())
d1967 2
d1971 1
a1971 1
               fn ([x],opts) => x
d1974 2
d1978 4
a1981 2
               fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
  VALBIND (a::v1,v2,Set.union(tyvars1,tyvars2),merge_pVEs(opts,pVE1,pVE2))
d1984 2
d1988 4
a1991 2
               fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
  VALBIND (v1,v1' @@ v2 @@ v2',Set.union(tyvars1,tyvars2),merge_pVEs(opts,pVE1,pVE2))
d1994 2
d1998 8
a2005 2
               fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
(check_rec_bindings (opts,v1); VALBIND ([],v2@@v1,tyvars,pVE))
d2008 2
d2012 3
a2014 2
               fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
  VALBIND ([(pat,exp,get_location opts)],[],Set.union (tyvars1,tyvars2),pVE)
d2017 5
a2021 1
(* ;; Function definitions should return a pVE with the names of the functions declared in it.  *)
d2025 3
a2027 2
               fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
  FVALBIND (([((rev fvals),make_fval_info loc,get_location opts)],tyvars),make_pVE id)
d2030 2
d2034 4
a2037 2
               fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
  FVALBIND (((rev fvals,make_fval_info loc,get_location opts)::l,Set.union(tyvars1,tyvars2)),addNewValId(opts,id,pVE))
d2040 2
d2044 2
a2045 1
               fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,get_location opts)
d2048 2
d2051 2
d2055 4
a2058 2
               fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
  FVALLIST (fval::fvals,Set.union(tyvars1,tyvars2),id,get_location opts)
d2061 2
d2065 13
a2077 4
              fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
 FVAL(((id,rev l,Absyn.TYPEDexp(exp,ty,get_location opts),get_location opts),join_tyvars[tyvars1,tyvars2,tyvars3]),id)
|([VALID id,PATLIST (l,pE,tyvars1),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
   FVAL(((id,rev l,exp,get_location opts),Set.union(tyvars1,tyvars3)),id)
d2080 2
d2084 16
a2099 4
               fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(merge_pVEs(opts,pVE1,pVE2);FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,get_location opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id))
| ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
(merge_pVEs(opts,pVE1,pVE2);FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id))
d2102 1
d2105 16
a2120 8
      fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(error (opts,"Too many patterns for infix identifier " ^ IdentPrint.printValId (print_options_of opts) id);
 merge_pVEs(opts,pVE1,pVE2);
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,get_location opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id))
| ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
(error (opts,"Too many patterns for infix identifier " ^ IdentPrint.printValId (print_options_of opts) id);
 merge_pVEs(opts,pVE1,pVE2);
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id))
d2123 2
d2127 12
a2138 6
               fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(function_pattern_error (opts,pat1);
 FVAL(((error_id,rev l,Absyn.TYPEDexp(exp,ty,get_location opts),get_location opts),Set.union (tyvars2,Set.union (tyvars3,tyvars4))),error_id))
| ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
(function_pattern_error (opts,pat1);
 FVAL(((error_id,rev l,exp,get_location opts), Set.union (tyvars2,tyvars3)),error_id))
d2141 2
d2145 12
a2156 6
               fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(function_pattern_error (opts,pat1);
 FVAL(make_infix_fval (opts,id,pat1,pat1,[],Absyn.TYPEDexp(exp,ty,get_location opts),[tyvars1,tyvars3,tyvars4]),id))
| ([PAT (pat1,pVE1,tyvars1),VALID id,NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
(function_pattern_error (opts,pat1);
 FVAL(make_infix_fval (opts,id,pat1,pat1,[],exp,[tyvars1,tyvars3]),id))
d2159 2
d2163 13
a2175 4
               fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,get_location opts),[tyvars1,tyvars2,tyvars3]),id)
| ([BINPAT (pat1,id,pat2,pE1,tyvars1),NULLTYPE,_,EXP (exp,tyvars2)],opts) =>
FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2]),id)
d2178 1
d2181 14
a2194 4
               fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
  FVAL(make_infix_fval(opts,id,pat1,pat2,rev patl,Absyn.TYPEDexp(exp,ty,get_location opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
| ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
  FVAL(make_infix_fval(opts,id,pat1,pat2,rev patl,exp,[tyvars1,tyvars2,tyvars3]),id)
d2197 1
d2200 1
a2200 1
               fn ([],opts) => NULLTYPE
d2203 2
d2207 1
a2207 1
               fn ([_,ty],opts) => ty
d2210 2
d2214 1
a2214 1
               fn ([x],opts) => x
d2217 2
d2221 2
a2222 2
               fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
   (check_disjoint_typbind(opts,tb,tbl);TYPBIND (tb::tbl))
d2227 1
a2227 1
               fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d2234 1
a2234 1
               fn ([x],opts) => x
d2239 1
a2239 1
               fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d2245 1
a2245 1
               fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
d2252 1
a2252 1
               fn ([],opts) => TYVARLIST []
d2257 1
a2257 1
     	 fn ([x],opts) => x
d2262 1
a2262 1
               fn ([TYVAR t],opts) => TYVARLIST [t]
d2267 1
a2267 1
               fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d2272 1
a2272 1
               fn ([TYVAR t],opts) => TYVARLIST [t]
d2277 1
a2277 1
               fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d2283 1
a2283 1
               fn ([DATAHDR(tyvars, tycon),_, LONGTYCON longtycon],opts) =>
d2291 1
a2291 1
               fn ([DATBIND1(d,pVE,pTE)],opts) => DATBIND([d],pVE,pTE)
d2296 1
a2296 1
               fn ([DATBIND(l,pVE,pTE),_,DATBIND1(d,pVE',pTE')],opts) =>
d2303 1
a2303 1
               fn ([DATAHDR(tyvarlist,tycon),CONBIND (conbind,pVE,tyvars)],opts) =>
d2314 1
a2314 1
              fn ([TYVARLIST tyvarlist, TYCON tycon,_],opts) =>
d2321 1
a2321 1
               fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d2326 1
a2326 1
               fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d2332 1
a2332 1
                  fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,SOME ty),id,tyvars)
d2338 1
a2338 1
               fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d2343 1
a2343 1
               fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d2349 1
a2349 1
                  fn ([VALID id, TY (ty,tyvars)],opts) => 
d2357 1
a2357 1
               fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d2364 1
a2364 1
               fn ([],opts) => NULLTYPE
d2369 1
a2369 1
               fn ([_,x],opts) => x
d2374 1
a2374 1
               fn ([_],opts as OPTS(location,options,_)) =>
d2380 1
a2380 1
   fn ([SCON (x as (Ident.REAL _))],opts) => 
d2388 12
a2399 1
(* ;; This is where variables are introduced.  Make a new environment with just it in.  *)
d2403 5
a2407 2
                 fn ([VALID id],opts) => 
  PAT (Absyn.VALpat (annotate' (make_long_id id),get_location opts),make_pVE id,Set.empty_set)
d2410 2
d2414 4
a2417 3
               fn ([LONGVALID (id,strname_opt)],opts) => 
    (check_is_constructor (opts,id,strname_opt);
     (PAT (Absyn.VALpat (annotate' id,get_location opts),PE.empty_pVE,Set.empty_set)))
d2420 2
d2424 1
a2424 1
               fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d2430 1
a2430 1
               fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d2436 1
a2436 1
               fn ([_,_,_],opts) => 
d2442 1
a2442 1
               fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2447 1
a2447 1
               fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2452 1
a2452 1
               fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d2457 1
a2457 1
               fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d2462 1
a2462 1
               fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
d2467 1
a2467 1
               fn ([_,x,_],opts) => x
d2472 1
a2472 1
               fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
d2477 1
a2477 1
               fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,
d2484 1
a2484 1
               fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2493 1
a2493 1
               fn ([x],opts) => x
d2498 1
a2498 1
               fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2504 1
a2504 1
               fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2510 1
a2510 1
               fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d2515 1
a2515 1
               fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2522 1
a2522 1
               fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d2527 1
a2527 1
               fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2537 1
a2537 1
               fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2547 1
a2547 1
               fn ([x],opts) => x
d2552 1
a2552 1
                fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2560 1
a2560 1
               fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2567 1
a2567 1
               fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2574 1
a2574 1
               fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
d2579 1
a2579 1
                 fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2589 1
a2589 1
               fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d2594 1
a2594 1
               fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d2599 1
a2599 1
               fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d2604 1
a2604 1
               fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
d2609 1
a2609 1
               fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
d2614 1
a2614 1
               fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
d2619 1
a2619 1
               fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d2624 1
a2624 1
               fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d2629 1
a2629 1
               fn ([_,t,_],opts) => t
d2634 1
a2634 1
               fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d2639 1
a2639 1
               fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2644 1
a2644 1
               fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2649 1
a2649 1
               fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2654 1
a2654 1
               fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2659 1
a2659 1
               fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2664 1
a2664 1
               fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2672 1
a2672 1
               fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2677 1
a2677 1
               fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2685 1
a2685 1
               fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2690 1
a2690 1
               fn ([LONGID id],opts) => LONGIDLIST[id]
d2697 1
a2697 1
               fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2702 1
a2702 1
               fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2709 1
a2709 1
               fn ([SYM sym],opts) => SYMLIST [sym]
d2714 1
a2714 1
               fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2721 1
a2721 1
               fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
d2726 1
a2726 1
               fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
d2731 1
a2731 1
               fn ([STRING s],opts) => SCON (Ident.STRING s)
d2736 1
a2736 1
               fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2741 1
a2741 1
               fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
d2748 1
a2748 1
               fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2755 1
a2755 1
               fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2762 1
a2762 1
               fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2767 1
a2767 1
               fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2772 1
a2772 1
               fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2777 1
a2777 1
               fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2782 1
a2782 1
               fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2789 1
a2789 1
               fn ([LONGID ([],s)],opts) => SYM s
d2796 1
a2796 1
               fn ([_],opts) => SYM equal_symbol
d2802 1
a2802 1
               fn ([LONGID ([],s)],opts) => SYM s
d2809 1
a2809 1
               fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2814 1
a2814 1
               fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2819 1
a2819 1
               fn ([SYM s],opts) => STRID(Ident.STRID s)
d2828 1
a2828 1
               fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),NONE)
d2836 9
a2844 2
               fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
 | ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"variable"); VALID (Ident.VAR id))
d2849 1
a2849 1
               fn ([valid as VALID id],opts) => 
d2855 1
a2855 1
               fn ([_,valid as VALID id],opts) => 
d2862 1
a2862 1
               fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2868 1
a2868 1
               fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2874 1
a2874 1
               fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2879 1
a2879 1
               fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2884 1
a2884 1
               fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2890 1
a2890 1
               fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2895 1
a2895 1
               fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2900 1
a2900 1
               fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2906 1
a2906 1
               fn ([LONGID ([],s)],opts) => DUMMY 
d2914 1
a2914 1
               fn ([ENV pE,STRDEC (x,e),_],opts) =>
d2921 1
a2921 1
               fn ([LONGID x],opts) =>
d2929 1
a2929 1
               fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2935 1
a2935 1
               fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2941 1
a2941 1
               fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2948 1
a2948 1
       fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
d2954 1
a2954 1
               fn ([_],opts) => ENV (get_current_pE())
d2959 1
a2959 1
               fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2964 1
a2964 1
               fn ([_,strdec,_],opts) => strdec
d2969 1
a2969 1
               fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2974 1
a2974 1
               fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2979 1
a2979 1
               fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2986 1
a2986 1
               fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2991 1
a2991 1
               fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2996 1
a2996 1
               fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d3002 1
a3002 1
               fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d3010 1
a3010 1
               fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d3015 1
a3015 1
               fn ([_,STRBIND(l,pSE)],opts) => 
d3021 1
a3021 1
               fn ([_,STRBIND(l,pSE)],opts) => 
d3027 1
a3027 1
               fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d3032 1
a3032 1
      fn ([_],opts) => BOOL false
d3036 1
a3036 1
      fn ([_],opts) => BOOL true
d3041 1
a3041 1
               fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d3046 1
a3046 1
               fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d3052 1
a3052 1
              fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,
d3069 1
a3069 1
              fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d3082 1
a3082 1
          fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d3088 1
a3088 1
          fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref NONE,get_location opts),lookupSigId(opts,id))
d3092 1
a3092 1
       fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
d3098 1
a3098 1
               fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d3103 1
a3103 1
               fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d3108 1
a3108 1
               fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d3113 1
a3113 1
               fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d3118 1
a3118 1
               fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
d3123 1
a3123 1
         fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d3128 1
a3128 1
         fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
d3133 1
a3133 1
         fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
d3139 1
a3139 1
       fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
d3146 1
a3146 1
     fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
d3151 1
a3151 1
         fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
d3156 1
a3156 1
         fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d3161 1
a3161 1
               fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d3167 1
a3167 1
               fn ([_,DATREPLDESC(tyvars,tycon,longtycon)],opts) =>
d3178 1
a3178 1
               fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),
d3184 1
a3184 1
               fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
d3189 1
a3189 1
               fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
d3194 1
a3194 1
          fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d3201 1
a3201 1
          fn ([_,LONGIDLIST l],opts) => 
d3208 1
a3208 1
               fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d3212 1
a3212 1
     
d3220 1
a3220 1
                 fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d3225 1
a3225 1
                 fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d3230 1
a3230 1
                 fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d3235 1
a3235 1
                 fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d3240 1
a3240 1
               fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d3245 1
a3245 1
               fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d3250 1
a3250 1
               fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d3255 1
a3255 1
               fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d3261 1
a3261 1
               fn ([x],opts) => x
d3266 1
a3266 1
               fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
d3272 1
a3272 1
         fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
d3278 1
a3278 1
         fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
d3284 1
a3284 1
               fn ([DATAHDR(tyvars,tycon),_,LONGTYCON longtycon],opts) =>
d3291 1
a3291 1
               fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d3296 1
a3296 1
               fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d3302 1
a3302 1
               fn ([DATAHDR(tyvarlist,tycon),CONDESC (l,pVE,tyvars)],opts) =>
d3309 1
a3309 1
               fn ([x],opts) => x
d3314 1
a3314 1
               fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d3320 1
a3320 1
                  fn ([VALID con,TY(ty,tyvars)],opts) => 
d3328 1
a3328 1
               fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d3333 1
a3333 1
               fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d3339 1
a3339 1
                  fn ([VALID excon,TY(ty,_)],opts) => 
d3347 1
a3347 1
               fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d3352 1
a3352 1
               fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d3358 1
a3358 1
               fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
d3363 1
a3363 1
               fn ([x],opts) => x
d3368 1
a3368 1
               fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d3373 1
a3373 1
               fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
d3378 1
a3378 1
               fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
d3383 1
a3383 1
               fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d3388 1
a3388 1
               fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d3393 1
a3393 1
               fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d3398 1
a3398 1
               fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d3403 1
a3403 1
               fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d3408 1
a3408 1
               fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d3413 1
a3413 1
               fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d3418 1
a3418 1
               fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d3424 1
a3424 1
               fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d3430 1
a3430 1
              fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3447 1
a3447 1
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d3464 1
a3464 1
                  fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3470 1
a3470 1
                  fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d3476 1
a3476 1
               fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d3482 1
a3482 1
               fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d3488 1
a3488 1
               fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d3497 1
a3497 1
               fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
d3502 1
a3502 1
               fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
d3507 1
a3507 1
               fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
d3512 1
a3512 1
               fn ([EXP(exp,tyvars)],opts) =>
d3518 1
a3518 1
               fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
d3523 1
a3523 1
               fn ([TOPDEC x],opts) => raise FoundTopDec x
d3528 1
a3528 1
               fn ([x,_,_],opts) => x
d3533 1
a3533 1
               fn ([_,x],opts) => x
d3538 1
a3538 1
               fn ([x,_],opts) => x
d3543 1
a3543 1
               fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
d3550 1
a3550 1
               fn ([],opts) => DUMMY
d3743 3
a3745 3
(* if the LongId on the stack is a short variable, do first action else its a constructor and
   do the second action *)
fun ifVarStack _ (varred,conred,[LONGID (id as ([],s))],_) =
d3748 1
@


1.84.4.1
log
@branched from 1.84
@
text
@a3 4
 * Revision 1.84  1996/11/06  12:46:05  andreww
 * [Bug #1711]
 * forbidding real literals as patterns in SML'96 mode.
 *
@


1.84.3.1
log
@branched from 1.84
@
text
@a3 4
 * Revision 1.84  1996/11/06  12:46:05  andreww
 * [Bug #1711]
 * forbidding real literals as patterns in SML'96 mode.
 *
@


1.84.3.1.1.1
log
@branched from 1.84.3.1
@
text
@a3 3
 * Revision 1.84.3.1  1996/12/17  17:51:49  hope
 * branched from 1.84
 *
@


1.84.2.1
log
@branched from 1.84
@
text
@a3 4
 * Revision 1.84  1996/11/06  12:46:05  andreww
 * [Bug #1711]
 * forbidding real literals as patterns in SML'96 mode.
 *
@


1.84.1.1
log
@branched from 1.84
@
text
@a3 4
 * Revision 1.84  1996/11/06  12:46:05  andreww
 * [Bug #1711]
 * forbidding real literals as patterns in SML'96 mode.
 *
@


1.84.1.1.1.1
log
@branched from 1.84.1.1
@
text
@a3 3
 * Revision 1.84.1.1  1996/11/14  12:54:47  hope
 * branched from 1.84
 *
@


1.83
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d4 4
d2141 6
a2146 1
               fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
@


1.82
log
@[Bug #1614]
removing toplevel String.
@
text
@d4 4
d49 1
a49 1
 * New language definition]
d262 1
d264 1
d678 1
a678 1
    let val c = MLWorks.Internal.Value.unsafe_string_sub (int, 0)
d680 1
a680 1
      if c = ord #"0" then
d682 1
a682 1
      else if c = ord #"~" then
@


1.81
log
@[Bug #1708]
Altering the syntax of datatype replication: no tyvarseqs available.
@
text
@d4 4
d258 1
d311 1
a311 1
  type ConBind = ((Ident.ValId * TypeRef) * Absyn.Ty MLWorks.Option.option)
d315 4
a318 4
  type ConType = Ident.ValId * Absyn.Ty MLWorks.Option.option * Location.T
  type ExType = Ident.ValId * Absyn.Ty MLWorks.Option.option * Location.T
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * (Absyn.SigExp * bool) MLWorks.Option.option * string * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option)
  type DatBind = TyVarList * Ident.TyCon * TypeRef  * Absyn.Tyfun ref MLWorks.Option.option * ConBind list
d378 1
a378 1
  | TYPDESC of (TyVarList * Ident.TyCon * (Absyn.Ty * TyVarSet) MLWorks.Option.option) list
d387 2
a388 2
  | STRBIND  of ((Ident.StrId * (Absyn.SigExp * bool) MLWorks.Option.option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * (Absyn.SigExp * bool) MLWorks.Option.option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option) * (Ident.StrId * PE.pE))
d415 1
a415 1
  | TYPBIND of (TyVarList * Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref MLWorks.Option.option) list
d426 2
a427 2
  | OPTsigexp of Absyn.SigExp MLWorks.Option.option
(*  | OPTOFTYPE of Absyn.Ty MLWorks.Option.option *)
d450 4
a453 4
fun do_abstraction  (strid,Option.SOME (sigexp,abs),strexp,boolref,location,a,b) =
  (strid,Option.SOME (sigexp,true),strexp,boolref,location,a,b)
  | do_abstraction  (strid,Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,_,bref,location'),boolref,location,a,b) =
    (strid,Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,true,bref,location),boolref,location,a,b)
d468 1
a468 1
    String.implode [string,"[",Location.to_string location,"]"]
d470 1
a470 1
    String.implode [string,"[",Location.to_string location,"]"]
d538 1
a538 1
fun char_digit s = String.ord s - String.ord "0"
d627 1
a627 1
        Option.SOME strname =>
a665 19
fun check_integer_bounds (opts,int) =
  (* int is a string *)
  (* must be > 0 *)
    case String.explode int of
      digits as (first::_) =>
        if first = "0"
          then error(opts,"Leading zero in numeric label not allowed")
        else
          let val not_posint =
            first = "~"
            orelse
            Lists.forall(fn s => s = "0") digits
          in
            if not_posint then
              error(opts,"Integer label must be positive")
            else
              ()
          end
      | _ => Crash.impossible "Malformed integer label"
d667 15
d757 1
a757 1
            String.implode (case strid of 
d767 2
a768 2
     Option.SOME x => x
   | Option.NONE => Ident.VAR sym)
d779 6
a784 6
       Option.SOME (Ident.VAR _) => (mkLongVar id,Option.NONE)
     | Option.SOME (Ident.CON _) => (mkLongCon id,Option.NONE)
     | Option.SOME (Ident.EXCON _) => (mkLongExCon id,Option.NONE)
     | Option.SOME _ => Crash.impossible "TYCON':resolveLongValId:actionfunctions"
     | Option.NONE => (mkLongVar id,Option.NONE))
    handle PE.LookupStrId sym => (mkLongVar id,Option.SOME (Symbol.symbol_name sym))
d789 2
a790 2
    Option.SOME x => x
  | Option.NONE => Ident.VAR sym
d804 1
a804 1
           Option.SOME strname => 
d861 1
a861 1
     Option.SOME valid =>
d866 1
a866 1
   | Option.NONE => ())
d943 1
a943 1
      Option.NONE => if eq then Absyn.EQTYPEspec [(tyvars,name)]
d945 1
a945 1
    | Option.SOME (ty,tyvarset) => 
d953 1
a953 1
                               ref Option.NONE),
d1261 1
a1261 1
   ref(Absyn.nullInstanceInfo,MLWorks.Option.NONE))
d1316 1
a1316 1
                   (sigid,ref Option.NONE,location),
d1342 1
a1342 1
                         Absyn.NEWsigexp(spec,ref MLWorks.Option.NONE),
d1350 2
a1351 2
                 then MLWorks.Option.SOME (ref(Absyn.nullDebuggerStr))
               else MLWorks.Option.NONE,
d1353 2
a1354 2
                 then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
               else MLWorks.Option.NONE),funid,pE)
d1574 1
a1574 1
               fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1979 2
a1980 2
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND [(rev tyvarlist,tycon,ty,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullTyfun))
   else MLWorks.Option.NONE)])
d2058 2
a2059 2
                then MLWorks.Option.SOME(ref(Absyn.nullTyfun))
              else MLWorks.Option.NONE,rev conbind),
d2083 2
a2084 2
                  fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
| ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,MLWorks.Option.NONE),id,Set.empty_set)
d2101 1
a2101 1
  EXBIND1 (Absyn.NEWexbind (annotate id,MLWorks.Option.SOME ty,get_location opts,make_exbind_info(opts,id)),id,tyvars)
d2103 1
a2103 1
  EXBIND1 (Absyn.NEWexbind (annotate id,MLWorks.Option.NONE,get_location opts,make_exbind_info(opts,id)),id,Set.empty_set)
d2256 1
a2256 1
   PATROW1 ((Derived.make_patrow (sym, MLWorks.Option.SOME ty, MLWorks.Option.NONE,get_location opts)),make_Sym_pVE sym,tyvars))
d2259 1
a2259 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.NONE, MLWorks.Option.NONE,get_location opts),make_Sym_pVE sym,Set.empty_set))
d2266 1
a2266 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.SOME ty, MLWorks.Option.SOME pat,get_location opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
d2269 1
a2269 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.NONE, MLWorks.Option.SOME pat,get_location opts),addNewSymId(opts,sym,pVE),tyvars))
d2555 2
a2556 2
               fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
 | ([LONGID (longid as (_,id))],opts) => (report_long_error(opts,longid,"variable");LONGVALID (Ident.LONGVALID(Ident.NOPATH,Ident.VAR id),Option.NONE))
d2643 2
a2644 2
                             if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
                             else MLWorks.Option.NONE),lookupStrId(opts,x))
d2650 1
a2650 1
  STREXP (Absyn.APPstrexp (funid,strexp,ref false,get_location opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE),lookupFunId (opts,funid))
d2656 1
a2656 1
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,ref false,get_location opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE),lookupFunId (opts,funid))
d2774 1
a2774 1
             STRBIND1((id,MLWorks.Option.NONE,
d2780 2
a2781 2
                         then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
                       else MLWorks.Option.NONE,
d2783 2
a2784 2
                         then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
                       else MLWorks.Option.NONE),(id,pE1))
d2790 1
a2790 1
  STRBIND1((id,MLWorks.Option.NONE,strexp,ref false,
d2793 2
a2794 2
              then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
            else MLWorks.Option.NONE,
d2796 2
a2797 2
              then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
            else MLWorks.Option.NONE),(id,pE))
d2803 1
a2803 1
     (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref MLWorks.Option.NONE),(e,tycons)))
d2808 1
a2808 1
          fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,get_location opts),lookupSigId(opts,id))
d2993 1
a2993 1
     TYPDESC[(rev tyvarlist,tycon,Option.NONE)]
d2999 1
a2999 1
     TYPDESC[(rev tyvarlist,tycon,Option.SOME (ty,tyvarset))]
d3041 1
a3041 1
  CONDESC([(con,MLWorks.Option.SOME ty,get_location opts)],make_pVE con,tyvars)
d3043 1
a3043 1
  CONDESC([(con,MLWorks.Option.NONE,get_location opts)],make_pVE con,Set.empty_set)
d3060 1
a3060 1
  EXDESC1(excon,MLWorks.Option.SOME ty,get_location opts)
d3062 1
a3062 1
  EXDESC1(excon,MLWorks.Option.NONE,get_location opts)
d3156 1
a3156 1
                     MLWorks.Option.NONE,
d3160 2
a3161 2
                     if generate_moduler opts then MLWorks.Option.SOME (ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE,
                     if generate_moduler opts then MLWorks.Option.SOME (ref(MLWorks.Option.NONE)) else MLWorks.Option.NONE),
d3173 1
a3173 1
                MLWorks.Option.NONE,
d3177 2
a3178 2
                if generate_moduler opts then MLWorks.Option.SOME (ref (Absyn.nullDebuggerStr)) else MLWorks.Option.NONE,
                if generate_moduler opts then MLWorks.Option.SOME (ref (MLWorks.Option.NONE)) else MLWorks.Option.NONE),
d3185 1
a3185 1
(set_pE pE;do_derived_funbind (opts,funid,spec,MLWorks.Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false,get_location opts),pE''))
d3191 1
a3191 1
(set_pE pE;do_derived_funbind (opts,funid,spec,MLWorks.Option.NONE,strexp,pE'''))
d3467 3
a3469 3
     Option.SOME (Ident.VAR _) => varred
   | Option.SOME _ => conred
   | Option.NONE => varred)
d3645 1
a3645 1
		  String.ordof(string, if eq then 2 else 1)
d3647 1
a3647 1
		String.ord"1" <= weak_char andalso String.ord"9" >= weak_char
@


1.80
log
@[Bug #1686]
Removing use of "is constructor" tests --- these are done in typechecker
anyway, and they don't take into account replicated constructors.
@
text
@d4 5
d350 1
a350 1
  | DATREPL of TyVarList * Ident.TyCon * TyVarList * Ident.LongTyCon
d375 1
a375 1
  | DATREPLDESC of (TyVarList * Ident.TyCon * TyVarList * Ident.LongTyCon)
d1030 5
a1034 6
fun check_same_tyvars (opts,tyvars,tyvars') =
  (* checks that the two lists are the same; otherwise raise an error.
     used to implement the syntactic constraint on the datatype replication
     rule. *)
  if tyvars=tyvars' then ()
  else error (opts,"The replicated datatype has different type variables from the original")
d1385 1
d1400 1
a1400 1
              fn ([dec],opts) => dec
d1405 1
a1405 1
              fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1410 1
a1410 1
              fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1418 1
a1418 1
              fn ([_],opts) =>
d1425 1
a1425 1
              fn ([_,_],opts) => 
d1432 1
a1432 1
              fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1437 1
a1437 1
              fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1442 1
a1442 1
            fn ([_,LAB lab],opts) =>
d1447 1
a1447 1
              fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1451 1
a1451 1
              fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
d1456 1
a1456 1
              fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1461 1
a1461 1
              fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1466 1
a1466 1
            fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
d1471 1
a1471 1
              fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1476 1
a1476 1
              fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1483 1
a1483 1
              fn ([_,x,_],opts) => x
d1488 1
a1488 1
              fn ([_],opts) => ENV (get_current_pE())
d1493 1
a1493 1
              fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1498 1
a1498 1
              fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1503 1
a1503 1
              fn ([],opts) => EXPLIST ([],Set.empty_set)
d1508 1
a1508 1
              fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1513 1
a1513 1
              fn ([exp],opts) => exp
d1518 1
a1518 1
              fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1524 1
a1524 1
              fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
d1529 1
a1529 1
              fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1535 1
a1535 1
              fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1540 1
a1540 1
              fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1546 1
a1546 1
              fn ([x],opts) => x
d1551 1
a1551 1
              fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1557 1
a1557 1
              fn ([x],opts) => x
d1562 1
a1562 1
              fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1568 1
a1568 1
              fn ([x],opts) => x
d1573 1
a1573 1
              fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1578 1
a1578 1
              fn ([x],opts) => x
d1583 1
a1583 1
              fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1589 1
a1589 1
            fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1595 1
a1595 1
            fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1601 1
a1601 1
              fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1607 1
a1607 1
              fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
d1613 1
a1613 1
              fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1619 1
a1619 1
            fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1625 1
a1625 1
              fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1631 1
a1631 1
              fn ([_,MATCH (match,tyvars)],opts) =>
d1637 1
a1637 1
              fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1642 1
a1642 1
              fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1648 1
a1648 1
             fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
d1654 1
a1654 1
              fn ([_,_],opts) => DUMMY
d1659 1
a1659 1
              fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1664 1
a1664 1
              fn ([_,dec,_],opts) => dec
d1669 1
a1669 1
              fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1674 1
a1674 1
              fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1679 1
a1679 1
              fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1688 1
a1688 1
              fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1694 1
a1694 1
              fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1700 1
a1700 1
            fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1707 1
a1707 1
            fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1714 1
a1714 1
              fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1720 1
a1720 1
             fn ([_,DATREPL(tyvars,tycon,tyvars',longtycon)],opts)=>
d1723 1
a1723 1
   check_same_tyvars(opts,tyvars,tyvars');
d1729 1
a1729 1
      DEC (Absyn.DATATYPErepl (get_location opts,(tyvars,tycon,longtycon),
d1741 1
a1741 1
              fn ([_,DATBIND (d,pVE,pTE)],opts) => 
d1751 1
a1751 1
              fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t],opts) =>
d1761 1
a1761 1
              fn ([_,DATBIND (d,pVE,pTE),_,DEC(dec,pE,tyvars),_],opts) =>
d1768 1
a1768 1
              fn ([_,DATBIND (d,pVE,pTE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1776 1
a1776 1
              fn ([d as (DATBIND(_,pVE,pTE))],opts) => (extend_pVE pVE;
d1782 1
a1782 1
              fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1788 1
a1788 1
              fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1797 1
a1797 1
              fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1805 1
a1805 1
              fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1810 1
a1810 1
              fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1815 1
a1815 1
              fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1820 1
a1820 1
              fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1825 1
a1825 1
              fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1832 1
a1832 1
              fn ([_],opts) => ENV (get_current_pE())
d1837 1
a1837 1
              fn ([x],opts) => x
d1842 1
a1842 1
              fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1848 1
a1848 1
              fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1854 1
a1854 1
              fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1860 1
a1860 1
              fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1868 1
a1868 1
              fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1874 1
a1874 1
              fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1880 1
a1880 1
              fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,get_location opts)
d1886 1
a1886 1
              fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1892 1
a1892 1
             fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1900 1
a1900 1
              fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1908 1
a1908 1
     fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1920 1
a1920 1
              fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1930 1
a1930 1
              fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1940 1
a1940 1
              fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1948 1
a1948 1
              fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1956 1
a1956 1
              fn ([],opts) => NULLTYPE
d1961 1
a1961 1
              fn ([_,ty],opts) => ty
d1966 1
a1966 1
              fn ([x],opts) => x
d1971 1
a1971 1
              fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
d1977 1
a1977 1
              fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1984 1
a1984 1
              fn ([x],opts) => x
d1989 1
a1989 1
              fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d1995 1
a1995 1
              fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
d2002 1
a2002 1
              fn ([],opts) => TYVARLIST []
d2007 1
a2007 1
    	 fn ([x],opts) => x
d2012 1
a2012 1
              fn ([TYVAR t],opts) => TYVARLIST [t]
d2017 1
a2017 1
              fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d2022 1
a2022 1
              fn ([TYVAR t],opts) => TYVARLIST [t]
d2027 1
a2027 1
              fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d2030 1
a2030 1
(* 	((DATREPL DATAHEADER :datatype TYVARSEQ LONGTYCON)) *)
d2033 2
a2034 3
              fn ([DATAHDR(tyvars, tycon),_,
		   TYVARLIST tyvars', LONGTYCON longtycon],opts) => 
            DATREPL(tyvars,tycon,tyvars',longtycon)
d2041 1
a2041 1
              fn ([DATBIND1(d,pVE,pTE)],opts) => DATBIND([d],pVE,pTE)
d2046 1
a2046 1
              fn ([DATBIND(l,pVE,pTE),_,DATBIND1(d,pVE',pTE')],opts) =>
d2053 1
a2053 1
              fn ([DATAHDR(tyvarlist,tycon),CONBIND (conbind,pVE,tyvars)],opts) =>
d2064 1
a2064 1
             fn ([TYVARLIST tyvarlist, TYCON tycon,_],opts) =>
d2071 1
a2071 1
              fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d2076 1
a2076 1
              fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d2082 1
a2082 1
                 fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
d2088 1
a2088 1
              fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d2093 1
a2093 1
              fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d2099 1
a2099 1
                 fn ([VALID id, TY (ty,tyvars)],opts) => 
d2107 1
a2107 1
              fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d2114 1
a2114 1
              fn ([],opts) => NULLTYPE
d2119 1
a2119 1
              fn ([_,x],opts) => x
d2124 1
a2124 1
              fn ([_],opts as OPTS(location,options,_)) =>
d2130 1
a2130 1
              fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
d2137 1
a2137 1
                fn ([VALID id],opts) => 
d2143 1
a2143 1
              fn ([LONGVALID (id,strname_opt)],opts) => 
d2150 1
a2150 1
              fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d2156 1
a2156 1
              fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d2162 1
a2162 1
              fn ([_,_,_],opts) => 
d2168 1
a2168 1
              fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2173 1
a2173 1
              fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2178 1
a2178 1
              fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d2183 1
a2183 1
              fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d2188 1
a2188 1
              fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
d2193 1
a2193 1
              fn ([_,x,_],opts) => x
d2198 1
a2198 1
              fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
d2203 1
a2203 1
              fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,
d2210 1
a2210 1
              fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2219 1
a2219 1
              fn ([x],opts) => x
d2224 1
a2224 1
              fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2230 1
a2230 1
              fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2236 1
a2236 1
              fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d2241 1
a2241 1
              fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2248 1
a2248 1
              fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d2253 1
a2253 1
              fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2263 1
a2263 1
              fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2273 1
a2273 1
              fn ([x],opts) => x
d2278 1
a2278 1
               fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2286 1
a2286 1
              fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2293 1
a2293 1
              fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2300 1
a2300 1
              fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
d2305 1
a2305 1
                fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2315 1
a2315 1
              fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d2320 1
a2320 1
              fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d2325 1
a2325 1
              fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d2330 1
a2330 1
              fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
d2335 1
a2335 1
              fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
d2340 1
a2340 1
              fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
d2345 1
a2345 1
              fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d2350 1
a2350 1
              fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d2355 1
a2355 1
              fn ([_,t,_],opts) => t
d2360 1
a2360 1
              fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d2365 1
a2365 1
              fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2370 1
a2370 1
              fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2375 1
a2375 1
              fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2380 1
a2380 1
              fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2385 1
a2385 1
              fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2390 1
a2390 1
              fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2398 1
a2398 1
              fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2403 1
a2403 1
              fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2411 1
a2411 1
              fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2416 1
a2416 1
              fn ([LONGID id],opts) => LONGIDLIST[id]
d2423 1
a2423 1
              fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2428 1
a2428 1
              fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2435 1
a2435 1
              fn ([SYM sym],opts) => SYMLIST [sym]
d2440 1
a2440 1
              fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2447 1
a2447 1
              fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
d2452 1
a2452 1
              fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
d2457 1
a2457 1
              fn ([STRING s],opts) => SCON (Ident.STRING s)
d2462 1
a2462 1
              fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2467 1
a2467 1
              fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
d2474 1
a2474 1
              fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2481 1
a2481 1
              fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2488 1
a2488 1
              fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2493 1
a2493 1
              fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2498 1
a2498 1
              fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2503 1
a2503 1
              fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2508 1
a2508 1
              fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2515 1
a2515 1
              fn ([LONGID ([],s)],opts) => SYM s
d2522 1
a2522 1
              fn ([_],opts) => SYM equal_symbol
d2528 1
a2528 1
              fn ([LONGID ([],s)],opts) => SYM s
d2535 1
a2535 1
              fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2540 1
a2540 1
              fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2545 1
a2545 1
              fn ([SYM s],opts) => STRID(Ident.STRID s)
d2554 1
a2554 1
              fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2562 1
a2562 1
              fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2568 1
a2568 1
              fn ([valid as VALID id],opts) => 
d2574 1
a2574 1
              fn ([_,valid as VALID id],opts) => 
d2581 1
a2581 1
              fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2587 1
a2587 1
              fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2593 1
a2593 1
              fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2598 1
a2598 1
              fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2603 1
a2603 1
              fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2609 1
a2609 1
              fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2614 1
a2614 1
              fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2619 1
a2619 1
              fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2625 1
a2625 1
              fn ([LONGID ([],s)],opts) => DUMMY 
d2633 1
a2633 1
              fn ([ENV pE,STRDEC (x,e),_],opts) =>
d2636 1
a2636 1
               | _ => raise ActionError 201,
d2640 1
a2640 1
              fn ([LONGID x],opts) =>
d2648 1
a2648 1
              fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2654 1
a2654 1
              fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2660 1
a2660 1
              fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2667 1
a2667 1
      fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
d2673 1
a2673 1
              fn ([_],opts) => ENV (get_current_pE())
d2678 1
a2678 1
              fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2683 1
a2683 1
              fn ([_,strdec,_],opts) => strdec
d2688 1
a2688 1
              fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2693 1
a2693 1
              fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2698 1
a2698 1
              fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2705 1
a2705 1
              fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2710 1
a2710 1
              fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2715 1
a2715 1
              fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2721 1
a2721 1
              fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2729 1
a2729 1
              fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2734 1
a2734 1
              fn ([_,STRBIND(l,pSE)],opts) => 
d2740 1
a2740 1
              fn ([_,STRBIND(l,pSE)],opts) => 
d2746 1
a2746 1
              fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2751 1
a2751 1
     fn ([_],opts) => BOOL false
d2755 1
a2755 1
     fn ([_],opts) => BOOL true
d2760 1
a2760 1
              fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2765 1
a2765 1
              fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2771 1
a2771 1
             fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,
d2784 1
a2784 1
                | _ => raise ActionError 225,
d2788 1
a2788 1
             fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2801 1
a2801 1
         fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d2807 1
a2807 1
         fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,get_location opts),lookupSigId(opts,id))
d2811 1
a2811 1
      fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
d2817 1
a2817 1
              fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2822 1
a2822 1
              fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2827 1
a2827 1
              fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2832 1
a2832 1
              fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2837 1
a2837 1
              fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
d2842 1
a2842 1
        fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d2847 1
a2847 1
        fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
d2852 1
a2852 1
        fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
d2858 1
a2858 1
      fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
d2865 1
a2865 1
    fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
d2870 1
a2870 1
        fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
d2875 1
a2875 1
        fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d2880 1
a2880 1
              fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d2886 1
a2886 1
              fn ([_,DATREPLDESC(tyvars,tycon,tyvars',longtycon)],opts) =>
d2889 2
a2890 2
     check_same_tyvars(opts,tyvars,tyvars');
     SPEC(Absyn.DATATYPEreplSpec(get_location opts,tyvars,tycon,longtycon,
d2897 1
a2897 1
              fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),
d2903 1
a2903 1
              fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
d2908 1
a2908 1
              fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
d2913 1
a2913 1
         fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d2920 1
a2920 1
         fn ([_,LONGIDLIST l],opts) => 
d2927 1
a2927 1
              fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2931 1
a2931 1
    
d2939 1
a2939 1
                fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2944 1
a2944 1
                fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2949 1
a2949 1
                fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2954 1
a2954 1
                fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2959 1
a2959 1
              fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2964 1
a2964 1
              fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2969 1
a2969 1
              fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2974 1
a2974 1
              fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2980 1
a2980 1
              fn ([x],opts) => x
d2985 1
a2985 1
              fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
d2991 1
a2991 1
        fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
d2997 1
a2997 1
        fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
d3001 1
a3001 1
(*         ((DATREPLDESC DATAHEADER :datatype TYVARSEQ LONGTYCON)) *)
d3003 2
a3004 3
              fn ([DATAHDR(tyvars,tycon),_,
                 TYVARLIST tyvars', LONGTYCON longtycon],opts) =>
              DATREPLDESC(tyvars,tycon,tyvars',longtycon)
d3010 1
a3010 1
              fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d3015 1
a3015 1
              fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d3021 1
a3021 1
              fn ([DATAHDR(tyvarlist,tycon),CONDESC (l,pVE,tyvars)],opts) =>
d3028 1
a3028 1
              fn ([x],opts) => x
d3033 1
a3033 1
              fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d3039 1
a3039 1
                 fn ([VALID con,TY(ty,tyvars)],opts) => 
d3047 1
a3047 1
              fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d3052 1
a3052 1
              fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d3058 1
a3058 1
                 fn ([VALID excon,TY(ty,_)],opts) => 
d3066 1
a3066 1
              fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d3071 1
a3071 1
              fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d3077 1
a3077 1
              fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
d3082 1
a3082 1
              fn ([x],opts) => x
d3087 1
a3087 1
              fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d3092 1
a3092 1
              fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
d3097 1
a3097 1
              fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
d3102 1
a3102 1
              fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d3107 1
a3107 1
              fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d3112 1
a3112 1
              fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d3117 1
a3117 1
              fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d3122 1
a3122 1
              fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d3127 1
a3127 1
              fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d3132 1
a3132 1
              fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d3137 1
a3137 1
              fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d3143 1
a3143 1
              fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d3149 1
a3149 1
             fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3166 1
a3166 1
        fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d3183 1
a3183 1
                 fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3189 1
a3189 1
                 fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d3195 1
a3195 1
              fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d3201 1
a3201 1
              fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d3207 1
a3207 1
              fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d3216 1
a3216 1
              fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
d3221 1
a3221 1
              fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
d3226 1
a3226 1
              fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
d3231 1
a3231 1
              fn ([EXP(exp,tyvars)],opts) =>
d3237 1
a3237 1
              fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
d3242 1
a3242 1
              fn ([TOPDEC x],opts) => raise FoundTopDec x
d3247 1
a3247 1
              fn ([x,_,_],opts) => x
d3252 1
a3252 1
              fn ([_,x],opts) => x
d3257 1
a3257 1
              fn ([x,_],opts) => x
d3262 1
a3262 1
              fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
d3269 1
a3269 1
              fn ([],opts) => DUMMY
@


1.79
log
@[Bug #1592]
threading locations in Absyn.LOCALexp
@
text
@d4 4
d346 2
a347 2
  | DATBIND of DatBind list * PE.pVE
  | DATBIND1 of DatBind * PE.pVE
d640 2
a641 1
        error (opts,"Non-constructor " ^ (IdentPrint.printValId print_options id) ^ " used in pattern")
d650 2
a651 1
        error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId print_options id))
d681 1
a681 1
fun zap_pFE (OPTS(_,_,options),x as PE.E(_,pVE,pSE)) =
d689 1
a689 1
      PE.E(PE.empty_pFE,pVE,pSE)
d698 2
a699 2
fun zap_for_sig (PE.E(_,_,pSE)) =
  PE.E(PE.empty_pFE,PE.empty_pVE,pSE)
d707 1
d713 5
a717 3
fun pVE_in_pE pVE = PE.E (PE.empty_pFE,pVE,PE.empty_pSE)
fun pSE_in_pE pSE = PE.E(PE.empty_pFE,PE.empty_pVE,pSE)
fun pFE_in_pE pFE = PE.E(pFE,PE.empty_pVE,PE.empty_pSE)
a728 1

d733 1
d737 9
d799 2
a800 1
             error (opts, "Unbound Structure " ^ strname ^ " in " ^ IdentPrint.printLongValId (print_options_of opts) id)
d802 3
a804 1
             error (opts,"Identifier " ^ IdentPrint.printLongValId (print_options_of opts) id ^ " not an exception constructor"))
d817 3
a819 1
          error (opts,"Symbol " ^ (IdentPrint.printValId print_options id) ^ " not infix")
d839 3
a841 1
          error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not infix")
d844 3
a846 1
          then error (opts,"Infix constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not defined")
d848 3
a850 1
          error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not defined and not infix")
d857 2
a858 1
         then error (opts,"Trying to bind constructor " ^ Symbol.symbol_name s ^ " in record")
d890 4
a893 2
  fun extend_pF (pF) = set_pB(PE.augment_pB(get_pB(),PE.B(pF,PE.empty_pG,PE.empty_pE)))
  fun extend_pG (pG) = set_pB(PE.augment_pB(get_pB(),PE.B(PE.empty_pF,pG,PE.empty_pE)))
d899 2
a900 1
       then error (opts,"Duplicate type specifications in signature: " ^ IdentPrint.printTyCon tycon)
d909 7
a915 5
    (PE.unique_augment_pE ((fn id => error (opts,"Duplicate value specifications in signature: " ^ 
                                                  IdentPrint.printValId (print_options_of opts) id),
                            fn id => error (opts,"Duplicate structure specifications in signature: " ^
                                                 IdentPrint.printStrId id)),
                           pe1,pe2),
d937 2
a938 1
      Option.NONE => if eq then Absyn.EQTYPEspec [(tyvars,name)] else Absyn.TYPEspec [(tyvars,name)]
d943 7
a949 7
          Absyn.INCLUDEspec (Absyn.WHEREsigexp (Absyn.NEWsigexp 
                                                (if eq 
                                                   then Absyn.EQTYPEspec [(tyvars,name)] 
                                                 else Absyn.TYPEspec [(tyvars,name)],
                                                   ref Option.NONE),
                                                   [(tyvars,make_long name,ty,get_location opts)]),
                             get_location opts)
d1040 2
a1041 1
          error (opts,"Multiple declaration of type constructor " ^ Symbol.symbol_name sym ^ " in " ^ message)
d1045 8
a1052 4
  val check_disjoint_datbind = check_disjoint_tycons(fn (_,x,_,_,_) => x, "datatype binding")
  val check_disjoint_typbind = check_disjoint_tycons(fn (_,x,_,_) => x, "type binding")
  val check_disjoint_datdesc = check_disjoint_tycons(fn (_,x,_) => x, "datatype specification")
  val check_disjoint_typdesc = check_disjoint_tycons(fn (_,x,_) => x, "type specification")
d1127 2
a1128 1
fun merge_pVEs (opts as OPTS(location,options,_),pVE1 as (PE.VE ve1),pVE2 as (PE.VE ve2)) =
d1139 13
d1161 2
d1179 2
a1180 1
  fun addNewSigId (opts,(id,pE,tycons),pGE) = PE.addSigId (sigid_error opts,id,pE,tycons,pGE)
d1183 2
d1221 2
a1222 1
      warn (opts,"Reserved word `op' ignored before `" ^ Symbol.symbol_name(get_sym v) ^ "'")
d1228 2
a1229 1
      error (opts,"Reserved word `op' required before infix identifier `" ^ Symbol.symbol_name(get_sym v) ^ "'") else
d1236 2
a1237 1
      warn (opts,"Reserved word `op' ignored before `" ^ Symbol.symbol_name(get_sym v) ^ "'")
d1245 2
a1246 1
      error (opts,"Reserved word `op' required before infix identifier `" ^ Symbol.symbol_name(get_sym v) ^ "'")
d1277 2
a1278 1
    val Options.OPTIONS {compat_options = Options.COMPATOPTIONS{open_fixity, ...},
d1282 3
a1284 2
    val new_pE as PE.E(fixity, pVE, pSE) = fold_pEs pEs
    val new_pE = if open_fixity then new_pE else PE.E(PE.empty_pFE, pVE, pSE)
d1307 8
a1314 1
     SPEC (Absyn.SEQUENCEspec (map (fn sigid => Absyn.INCLUDEspec (Absyn.OLDsigexp (sigid,ref Option.NONE,location),location)) sigids),(new_pE,new_tycons)))
d1326 2
a1327 1
   ((id,(Derived.make_tuple_pat [pat1,pat2]) :: patlist,exp,get_location opts),join_tyvars tvarlist))
d1344 2
a1345 1
               if generate_moduler then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
d1347 2
a1348 1
               if generate_moduler then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
d1354 2
a1355 1
    val Options.OPTIONS {compat_options = Options.COMPATOPTIONS{fixity_specs, ...},
d1719 9
a1727 3
   DEC (Absyn.DATATYPErepl (get_location opts,(tyvars,tycon,longtycon),
                            ref NONE),
        PE.empty_pE,Set.empty_set))
d1736 5
a1740 2
              fn ([_,DATBIND (d,pVE)],opts) => 
  (extend_pVE pVE; DEC (Absyn.DATATYPEdec (get_location opts,rev d),pVE_in_pE pVE,Set.empty_set))
d1746 1
a1746 1
              fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1748 1
a1748 1
   extend_pVE pVE;
d1751 1
a1751 1
	pVE_in_pE pVE,Set.empty_set))
d1756 3
a1758 2
              fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
  DEC (Absyn.ABSTYPEdec (get_location opts,rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars)
d1763 1
a1763 1
              fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1766 2
a1767 1
				       options_of opts),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
d1771 2
a1772 1
              fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d2037 1
a2037 1
              fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d2042 3
a2044 2
              fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
(check_disjoint_datbind(opts,d,l);DATBIND(d::l,merge_pVEs(opts,pVE,pVE')))
d2051 5
a2055 2
   DATBIND1 ((rev tyvarlist,tycon,ref Absyn.nullType,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullTyfun))
else MLWorks.Option.NONE,rev conbind),pVE))
d2199 2
a2200 1
              fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d2208 3
a2210 1
   PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],get_location opts,true),pVE,tyvars))
d2564 2
a2565 1
              fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d2570 2
a2571 1
              fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d2621 2
a2622 1
              fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2629 4
a2632 2
              fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 201,
d2767 14
a2780 6
             fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,STREXP(strexp,pE2)],opts) => 
  STRBIND1((id,MLWorks.Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false,get_location opts),ref false,
            get_location opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
else MLWorks.Option.NONE,if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
else MLWorks.Option.NONE),(id,pE1))
 | _ => raise ActionError 225,
d2786 7
a2792 3
            get_location opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
else MLWorks.Option.NONE,if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE))
else MLWorks.Option.NONE),(id,pE))
@


1.79.1.1
log
@branched from 1.79
@
text
@a3 4
 * Revision 1.79  1996/10/04  17:52:44  andreww
 * [Bug #1592]
 * threading locations in Absyn.LOCALexp
 *
@


1.78
log
@[Bug #1622]
Adding some locations to datatype descriptors
@
text
@d4 4
d1303 1
d1318 1
a1318 1
             fn ([dec],opts) => dec
d1323 1
a1323 1
             fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1328 1
a1328 1
             fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1336 1
a1336 1
             fn ([_],opts) =>
d1343 1
a1343 1
             fn ([_,_],opts) => 
d1350 1
a1350 1
             fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1355 1
a1355 1
             fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1360 1
a1360 1
           fn ([_,LAB lab],opts) =>
d1365 1
a1365 1
             fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1369 1
a1369 1
             fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
d1374 1
a1374 1
             fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1379 1
a1379 1
             fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1384 1
a1384 1
           fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
d1389 1
a1389 1
             fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1394 3
a1396 2
             fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
  (set_pE pE; EXP (Absyn.LOCALexp (dec,Derived.make_sequence_exp (rev l)),Set.union(tyvars1,tyvars2)))
d1401 1
a1401 1
             fn ([_,x,_],opts) => x
d1406 1
a1406 1
             fn ([_],opts) => ENV (get_current_pE())
d1411 1
a1411 1
             fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1416 1
a1416 1
             fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1421 1
a1421 1
             fn ([],opts) => EXPLIST ([],Set.empty_set)
d1426 1
a1426 1
             fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1431 1
a1431 1
             fn ([exp],opts) => exp
d1436 1
a1436 1
             fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1442 1
a1442 1
             fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
d1447 1
a1447 1
             fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1453 1
a1453 1
             fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1458 1
a1458 1
             fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1464 1
a1464 1
             fn ([x],opts) => x
d1469 1
a1469 1
             fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1475 1
a1475 1
             fn ([x],opts) => x
d1480 1
a1480 1
             fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1486 1
a1486 1
             fn ([x],opts) => x
d1491 1
a1491 1
             fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1496 1
a1496 1
             fn ([x],opts) => x
d1501 1
a1501 1
             fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1507 1
a1507 1
           fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1513 1
a1513 1
           fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1519 1
a1519 1
             fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1525 1
a1525 1
             fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
d1531 1
a1531 1
             fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1537 1
a1537 1
           fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1543 1
a1543 1
             fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1549 1
a1549 1
             fn ([_,MATCH (match,tyvars)],opts) =>
d1555 1
a1555 1
             fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1560 1
a1560 1
             fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1566 1
a1566 1
            fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
d1572 1
a1572 1
             fn ([_,_],opts) => DUMMY
d1577 1
a1577 1
             fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1582 1
a1582 1
             fn ([_,dec,_],opts) => dec
d1587 1
a1587 1
             fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1592 1
a1592 1
             fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1597 1
a1597 1
             fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1606 1
a1606 1
             fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1612 1
a1612 1
             fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1618 1
a1618 1
           fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1625 1
a1625 1
           fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1632 1
a1632 1
             fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1638 1
a1638 1
            fn ([_,DATREPL(tyvars,tycon,tyvars',longtycon)],opts)=>
d1653 1
a1653 1
             fn ([_,DATBIND (d,pVE)],opts) => 
d1660 1
a1660 1
             fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1670 1
a1670 1
             fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1676 1
a1676 1
             fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1683 1
a1683 1
             fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1688 1
a1688 1
             fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1694 1
a1694 1
             fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1703 1
a1703 1
             fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1711 1
a1711 1
             fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1716 1
a1716 1
             fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1721 1
a1721 1
             fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1726 1
a1726 1
             fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1731 1
a1731 1
             fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1738 1
a1738 1
             fn ([_],opts) => ENV (get_current_pE())
d1743 1
a1743 1
             fn ([x],opts) => x
d1748 1
a1748 1
             fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1754 1
a1754 1
             fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1760 1
a1760 1
             fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1766 1
a1766 1
             fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1774 1
a1774 1
             fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1780 1
a1780 1
             fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1786 1
a1786 1
             fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,get_location opts)
d1792 1
a1792 1
             fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1798 1
a1798 1
            fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1806 1
a1806 1
             fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1814 1
a1814 1
    fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1826 1
a1826 1
             fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1836 1
a1836 1
             fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1846 1
a1846 1
             fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1854 1
a1854 1
             fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1862 1
a1862 1
             fn ([],opts) => NULLTYPE
d1867 1
a1867 1
             fn ([_,ty],opts) => ty
d1872 1
a1872 1
             fn ([x],opts) => x
d1877 1
a1877 1
             fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
d1883 1
a1883 1
             fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1890 1
a1890 1
             fn ([x],opts) => x
d1895 1
a1895 1
             fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d1901 1
a1901 1
             fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
d1908 1
a1908 1
             fn ([],opts) => TYVARLIST []
d1913 1
a1913 1
   	 fn ([x],opts) => x
d1918 1
a1918 1
             fn ([TYVAR t],opts) => TYVARLIST [t]
d1923 1
a1923 1
             fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1928 1
a1928 1
             fn ([TYVAR t],opts) => TYVARLIST [t]
d1933 1
a1933 1
             fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1939 1
a1939 1
             fn ([DATAHDR(tyvars, tycon),_,
d1948 1
a1948 1
             fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1953 1
a1953 1
             fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1959 1
a1959 1
             fn ([DATAHDR(tyvarlist,tycon),CONBIND (conbind,pVE,tyvars)],opts) =>
d1967 1
a1967 1
            fn ([TYVARLIST tyvarlist, TYCON tycon,_],opts) =>
d1974 1
a1974 1
             fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1979 1
a1979 1
             fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1985 1
a1985 1
                fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
d1991 1
a1991 1
             fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1996 1
a1996 1
             fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d2002 1
a2002 1
                fn ([VALID id, TY (ty,tyvars)],opts) => 
d2010 1
a2010 1
             fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d2017 1
a2017 1
             fn ([],opts) => NULLTYPE
d2022 1
a2022 1
             fn ([_,x],opts) => x
d2027 1
a2027 1
             fn ([_],opts as OPTS(location,options,_)) =>
d2033 1
a2033 1
             fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
d2040 1
a2040 1
               fn ([VALID id],opts) => 
d2046 1
a2046 1
             fn ([LONGVALID (id,strname_opt)],opts) => 
d2053 1
a2053 1
             fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d2059 1
a2059 1
             fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d2065 1
a2065 1
             fn ([_,_,_],opts) => 
d2071 1
a2071 1
             fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2076 1
a2076 1
             fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2081 1
a2081 1
             fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d2086 1
a2086 1
             fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d2091 1
a2091 1
             fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
d2096 1
a2096 1
             fn ([_,x,_],opts) => x
d2101 1
a2101 1
             fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
d2106 1
a2106 1
             fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d2112 1
a2112 1
             fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2119 1
a2119 1
             fn ([x],opts) => x
d2124 1
a2124 1
             fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2130 1
a2130 1
             fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2136 1
a2136 1
             fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d2141 1
a2141 1
             fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2148 1
a2148 1
             fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d2153 1
a2153 1
             fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2163 1
a2163 1
             fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2173 1
a2173 1
             fn ([x],opts) => x
d2178 1
a2178 1
              fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2186 1
a2186 1
             fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2193 1
a2193 1
             fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2200 1
a2200 1
             fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
d2205 1
a2205 1
               fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2215 1
a2215 1
             fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d2220 1
a2220 1
             fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d2225 1
a2225 1
             fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d2230 1
a2230 1
             fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
d2235 1
a2235 1
             fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
d2240 1
a2240 1
             fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
d2245 1
a2245 1
             fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d2250 1
a2250 1
             fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d2255 1
a2255 1
             fn ([_,t,_],opts) => t
d2260 1
a2260 1
             fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d2265 1
a2265 1
             fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2270 1
a2270 1
             fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2275 1
a2275 1
             fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2280 1
a2280 1
             fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2285 1
a2285 1
             fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2290 1
a2290 1
             fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2298 1
a2298 1
             fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2303 1
a2303 1
             fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2311 1
a2311 1
             fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2316 1
a2316 1
             fn ([LONGID id],opts) => LONGIDLIST[id]
d2323 1
a2323 1
             fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2328 1
a2328 1
             fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2335 1
a2335 1
             fn ([SYM sym],opts) => SYMLIST [sym]
d2340 1
a2340 1
             fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2347 1
a2347 1
             fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
d2352 1
a2352 1
             fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
d2357 1
a2357 1
             fn ([STRING s],opts) => SCON (Ident.STRING s)
d2362 1
a2362 1
             fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2367 1
a2367 1
             fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
d2374 1
a2374 1
             fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2381 1
a2381 1
             fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2388 1
a2388 1
             fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2393 1
a2393 1
             fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2398 1
a2398 1
             fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2403 1
a2403 1
             fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2408 1
a2408 1
             fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2415 1
a2415 1
             fn ([LONGID ([],s)],opts) => SYM s
d2422 1
a2422 1
             fn ([_],opts) => SYM equal_symbol
d2428 1
a2428 1
             fn ([LONGID ([],s)],opts) => SYM s
d2435 1
a2435 1
             fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2440 1
a2440 1
             fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2445 1
a2445 1
             fn ([SYM s],opts) => STRID(Ident.STRID s)
d2454 1
a2454 1
             fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2462 1
a2462 1
             fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2468 1
a2468 1
             fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d2473 1
a2473 1
             fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d2479 1
a2479 1
             fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2485 1
a2485 1
             fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2491 1
a2491 1
             fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2496 1
a2496 1
             fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2501 1
a2501 1
             fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2507 1
a2507 1
             fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2512 1
a2512 1
             fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2517 1
a2517 1
             fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2523 1
a2523 1
             fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2530 1
a2530 1
             fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d2535 1
a2535 1
             fn ([LONGID x],opts) =>
d2543 1
a2543 1
             fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2549 1
a2549 1
             fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2555 1
a2555 1
             fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2562 1
a2562 1
     fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
d2568 1
a2568 1
             fn ([_],opts) => ENV (get_current_pE())
d2573 1
a2573 1
             fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2578 1
a2578 1
             fn ([_,strdec,_],opts) => strdec
d2583 1
a2583 1
             fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2588 1
a2588 1
             fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2593 1
a2593 1
             fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2600 1
a2600 1
             fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2605 1
a2605 1
             fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2610 1
a2610 1
             fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2616 1
a2616 1
             fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2624 1
a2624 1
             fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2629 1
a2629 1
             fn ([_,STRBIND(l,pSE)],opts) => 
d2635 1
a2635 1
             fn ([_,STRBIND(l,pSE)],opts) => 
d2641 1
a2641 1
             fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2646 1
a2646 1
    fn ([_],opts) => BOOL false
d2650 1
a2650 1
    fn ([_],opts) => BOOL true
d2655 1
a2655 1
             fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2660 1
a2660 1
             fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2666 1
a2666 1
            fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,STREXP(strexp,pE2)],opts) => 
d2675 1
a2675 1
            fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2684 1
a2684 1
        fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d2690 1
a2690 1
        fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,get_location opts),lookupSigId(opts,id))
d2694 1
a2694 1
     fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
d2700 1
a2700 1
             fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2705 1
a2705 1
             fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2710 1
a2710 1
             fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2715 1
a2715 1
             fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2720 1
a2720 1
             fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
d2725 1
a2725 1
       fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d2730 1
a2730 1
       fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
d2735 1
a2735 1
       fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
d2741 1
a2741 1
     fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
d2748 1
a2748 1
   fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
d2753 1
a2753 1
       fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
d2758 1
a2758 1
       fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d2763 1
a2763 1
             fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
d2769 1
a2769 1
             fn ([_,DATREPLDESC(tyvars,tycon,tyvars',longtycon)],opts) =>
d2780 1
a2780 1
             fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),
d2786 1
a2786 1
             fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
d2791 1
a2791 1
             fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
d2796 1
a2796 1
        fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d2803 1
a2803 1
        fn ([_,LONGIDLIST l],opts) => 
d2810 1
a2810 1
             fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2814 1
a2814 1
   
d2822 1
a2822 1
               fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2827 1
a2827 1
               fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2832 1
a2832 1
               fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2837 1
a2837 1
               fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2842 1
a2842 1
             fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2847 1
a2847 1
             fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2852 1
a2852 1
             fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2857 1
a2857 1
             fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2863 1
a2863 1
             fn ([x],opts) => x
d2868 1
a2868 1
             fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
d2874 1
a2874 1
       fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
d2880 1
a2880 1
       fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
d2886 1
a2886 1
             fn ([DATAHDR(tyvars,tycon),_,
d2894 1
a2894 1
             fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2899 1
a2899 1
             fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2905 1
a2905 1
             fn ([DATAHDR(tyvarlist,tycon),CONDESC (l,pVE,tyvars)],opts) =>
d2912 1
a2912 1
             fn ([x],opts) => x
d2917 1
a2917 1
             fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2923 1
a2923 1
                fn ([VALID con,TY(ty,tyvars)],opts) => 
d2931 1
a2931 1
             fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2936 1
a2936 1
             fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2942 1
a2942 1
                fn ([VALID excon,TY(ty,_)],opts) => 
d2950 1
a2950 1
             fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d2955 1
a2955 1
             fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2961 1
a2961 1
             fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
d2966 1
a2966 1
             fn ([x],opts) => x
d2971 1
a2971 1
             fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2976 1
a2976 1
             fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
d2981 1
a2981 1
             fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
d2986 1
a2986 1
             fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2991 1
a2991 1
             fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2996 1
a2996 1
             fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d3001 1
a3001 1
             fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d3006 1
a3006 1
             fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d3011 1
a3011 1
             fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d3016 1
a3016 1
             fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d3021 1
a3021 1
             fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d3027 1
a3027 1
             fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d3033 1
a3033 1
            fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3050 1
a3050 1
       fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d3067 1
a3067 1
                fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3073 1
a3073 1
                fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d3079 1
a3079 1
             fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d3085 1
a3085 1
             fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d3091 1
a3091 1
             fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d3100 1
a3100 1
             fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
d3105 1
a3105 1
             fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
d3110 1
a3110 1
             fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
d3115 1
a3115 1
             fn ([EXP(exp,tyvars)],opts) =>
d3121 1
a3121 1
             fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
d3126 1
a3126 1
             fn ([TOPDEC x],opts) => raise FoundTopDec x
d3131 1
a3131 1
             fn ([x,_,_],opts) => x
d3136 1
a3136 1
             fn ([_,x],opts) => x
d3141 1
a3141 1
             fn ([x,_],opts) => x
d3146 1
a3146 1
             fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
d3153 1
a3153 1
             fn ([],opts) => DUMMY
@


1.78.1.1
log
@branched from 1.78
@
text
@a3 4
 * Revision 1.78  1996/10/04  11:00:11  matthew
 * [Bug #1622]
 * Adding some locations to datatype descriptors
 *
@


1.77
log
@[Bug #1577]
Adding function "check_same_tyvars" that implements the syntactic restriction
on datatype replication.
@
text
@d4 5
d297 1
a297 1
  type ConType = Ident.ValId * Absyn.Ty MLWorks.Option.option
d2918 1
a2918 1
  CONDESC([(con,MLWorks.Option.SOME ty)],make_pVE con,tyvars)
d2920 1
a2920 1
  CONDESC([(con,MLWorks.Option.NONE)],make_pVE con,Set.empty_set)
@


1.76
log
@Improved error message for "op".
@
text
@d4 3
d331 2
d357 1
d419 2
d592 5
d980 9
d1293 1
d1308 1
a1308 1
            fn ([dec],opts) => dec
d1313 1
a1313 1
            fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1318 1
a1318 1
            fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1326 1
a1326 1
            fn ([_],opts) =>
d1333 1
a1333 1
            fn ([_,_],opts) => 
d1340 1
a1340 1
            fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1345 1
a1345 1
            fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1350 1
a1350 1
          fn ([_,LAB lab],opts) =>
d1355 1
a1355 1
            fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1359 1
a1359 1
            fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, get_location opts),Set.union(tyvars,tyvars'))
d1364 1
a1364 1
            fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1369 1
a1369 1
            fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1374 1
a1374 1
          fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,get_location opts,get_current_pE()),tyvars)
d1379 1
a1379 1
            fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1384 1
a1384 1
            fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1390 1
a1390 1
            fn ([_,x,_],opts) => x
d1395 1
a1395 1
            fn ([_],opts) => ENV (get_current_pE())
d1400 1
a1400 1
            fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1405 1
a1405 1
            fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1410 1
a1410 1
            fn ([],opts) => EXPLIST ([],Set.empty_set)
d1415 1
a1415 1
            fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1420 1
a1420 1
            fn ([exp],opts) => exp
d1425 1
a1425 1
            fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1431 1
a1431 1
            fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),get_location opts)],tyvars)
d1436 1
a1436 1
            fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1442 1
a1442 1
            fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1447 1
a1447 1
            fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1453 1
a1453 1
            fn ([x],opts) => x
d1458 1
a1458 1
            fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1464 1
a1464 1
            fn ([x],opts) => x
d1469 1
a1469 1
            fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1475 1
a1475 1
            fn ([x],opts) => x
d1480 1
a1480 1
            fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1485 1
a1485 1
            fn ([x],opts) => x
d1490 1
a1490 1
            fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1496 1
a1496 1
          fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1502 1
a1502 1
          fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1508 1
a1508 1
            fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1514 1
a1514 1
            fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,get_location opts),tyvars)
d1520 1
a1520 1
            fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1526 1
a1526 1
          fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1532 1
a1532 1
            fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1538 1
a1538 1
            fn ([_,MATCH (match,tyvars)],opts) =>
d1544 1
a1544 1
            fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1549 1
a1549 1
            fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1555 1
a1555 1
           fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,get_location opts),Set.union(tyvars1,tyvars2))
d1558 1
d1561 1
a1561 1
            fn ([_,_],opts) => DUMMY
d1566 1
a1566 1
            fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1571 1
a1571 1
            fn ([_,dec,_],opts) => dec
d1576 1
a1576 1
            fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1581 1
a1581 1
            fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1586 1
a1586 1
            fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1595 1
a1595 1
            fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1601 1
a1601 1
            fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1607 1
a1607 1
          fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1614 1
a1614 1
          fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1621 1
a1621 1
            fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1624 14
d1642 1
a1642 1
            fn ([_,DATBIND (d,pVE)],opts) => 
d1644 2
a1645 1
 | _ => raise ActionError 57,
d1649 1
a1649 1
            fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1655 1
a1655 1
 | _ => raise ActionError 58,
d1659 1
a1659 1
            fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1661 1
a1661 1
 | _ => raise ActionError 59,
d1665 1
a1665 1
            fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1669 1
a1669 1
 | _ => raise ActionError 60,
d1672 2
a1673 2
            fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
 | _ => raise ActionError 61,
d1677 1
a1677 1
            fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1679 1
a1679 1
 | _ => raise ActionError 62,
d1683 1
a1683 1
            fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1686 1
a1686 1
 | _ => raise ActionError 63,
d1692 2
a1693 2
            fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
 | _ => raise ActionError 64,
d1700 2
a1701 2
            fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
 | _ => raise ActionError 65,
d1705 2
a1706 2
            fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
 | _ => raise ActionError 66,
d1710 2
a1711 2
            fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
 | _ => raise ActionError 67,
d1715 2
a1716 2
            fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
 | _ => raise ActionError 68,
d1720 2
a1721 2
            fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
 | _ => raise ActionError 69,
d1727 2
a1728 2
            fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 70,
d1732 2
a1733 2
            fn ([x],opts) => x
 | _ => raise ActionError 71,
d1737 1
a1737 1
            fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1739 1
a1739 1
 | _ => raise ActionError 72,
d1743 1
a1743 1
            fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1745 1
a1745 1
 | _ => raise ActionError 73,
d1749 1
a1749 1
            fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1751 1
a1751 1
 | _ => raise ActionError 74,
d1755 1
a1755 1
            fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1757 1
a1757 1
 | _ => raise ActionError 75,
d1763 1
a1763 1
            fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1765 1
a1765 1
 | _ => raise ActionError 76,
d1769 1
a1769 1
            fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1771 1
a1771 1
 | _ => raise ActionError 77,
d1775 2
a1776 2
            fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,get_location opts)
 | _ => raise ActionError 78,
d1781 1
a1781 1
            fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1783 1
a1783 1
 | _ => raise ActionError 79,
d1787 1
a1787 1
           fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1791 1
a1791 1
 | _ => raise ActionError 80,
d1795 1
a1795 1
            fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1799 1
a1799 1
 | _ => raise ActionError 81,
d1803 1
a1803 1
   fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1811 1
a1811 1
 | _ => raise ActionError 82,
d1815 1
a1815 1
            fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1821 1
a1821 1
 | _ => raise ActionError 83,
d1825 1
a1825 1
            fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1831 1
a1831 1
 | _ => raise ActionError 84,
d1835 1
a1835 1
            fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1839 1
a1839 1
 | _ => raise ActionError 85,
d1843 1
a1843 1
            fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1847 1
a1847 1
 | _ => raise ActionError 86,
d1851 2
a1852 2
            fn ([],opts) => NULLTYPE
 | _ => raise ActionError 87,
d1856 2
a1857 2
            fn ([_,ty],opts) => ty
 | _ => raise ActionError 88,
d1861 2
a1862 2
            fn ([x],opts) => x
 | _ => raise ActionError 89,
d1866 1
a1866 1
            fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
d1868 1
a1868 1
 | _ => raise ActionError 90,
d1872 1
a1872 1
            fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1875 1
a1875 1
 | _ => raise ActionError 91,
d1879 2
a1880 2
            fn ([x],opts) => x
 | _ => raise ActionError 92,
d1884 1
a1884 1
            fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d1886 1
a1886 1
 | _ => raise ActionError 93,
d1890 1
a1890 1
            fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
d1893 1
a1893 1
 | _ => raise ActionError 94,
d1897 2
a1898 2
            fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 95,
d1902 2
a1903 2
  	 fn ([x],opts) => x
 | _ => raise ActionError 96,
d1907 2
a1908 2
            fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 97,
d1912 2
a1913 2
            fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 98,
d1917 2
a1918 2
            fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 99,
d1922 12
a1933 2
            fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 100,
d1937 2
a1938 2
            fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
 | _ => raise ActionError 101,
d1942 1
a1942 1
            fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1944 1
a1944 1
 | _ => raise ActionError 102,
d1946 1
a1946 1
(* 	((DATBIND1 TYVARSEQ TYCON :EQUAL CONBIND))  *)
d1948 1
a1948 1
            fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1952 8
a1959 1
 | _ => raise ActionError 103,
d1963 2
a1964 2
            fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 104,
d1968 1
a1968 1
            fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1970 1
a1970 1
 | _ => raise ActionError 105,
d1974 1
a1974 1
               fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
d1976 1
a1976 1
 | _ => raise ActionError 106,
d1980 2
a1981 2
            fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 107,
d1985 1
a1985 1
            fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1987 1
a1987 1
 | _ => raise ActionError 108,
d1991 1
a1991 1
               fn ([VALID id, TY (ty,tyvars)],opts) => 
d1995 1
a1995 1
 | _ => raise ActionError 109,
d1999 1
a1999 1
            fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d2002 1
a2002 1
 | _ => raise ActionError 110,
d2006 2
a2007 2
            fn ([],opts) => NULLTYPE
 | _ => raise ActionError 111,
d2011 2
a2012 2
            fn ([_,x],opts) => x
 | _ => raise ActionError 112,
d2016 1
a2016 1
            fn ([_],opts as OPTS(location,options,_)) =>
d2018 1
a2018 1
 | _ => raise ActionError 113,
d2022 2
a2023 2
            fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 114,
d2029 1
a2029 1
              fn ([VALID id],opts) => 
d2031 1
a2031 1
 | _ => raise ActionError 115,
d2035 1
a2035 1
            fn ([LONGVALID (id,strname_opt)],opts) => 
d2038 1
a2038 1
 | _ => raise ActionError 116,
d2042 1
a2042 1
            fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d2044 1
a2044 1
 | _ => raise ActionError 117,
d2048 1
a2048 1
            fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d2050 1
a2050 1
 | _ => raise ActionError 118,
d2054 1
a2054 1
            fn ([_,_,_],opts) => 
d2056 1
a2056 1
 | _ => raise ActionError 119,
d2060 2
a2061 2
            fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 120,
d2065 2
a2066 2
            fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 121,
d2070 2
a2071 2
            fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 122,
d2075 2
a2076 2
            fn ([_,_],opts) => PAT (Derived.make_list_pat([],get_location opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 123,
d2080 2
a2081 2
            fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],get_location opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 124,
d2085 2
a2086 2
            fn ([_,x,_],opts) => x
 | _ => raise ActionError 125,
d2090 2
a2091 2
            fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,get_location opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 126,
d2095 1
a2095 1
            fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d2097 1
a2097 1
 | _ => raise ActionError 127,
d2101 1
a2101 1
            fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2104 1
a2104 1
 | _ => raise ActionError 128,
d2108 2
a2109 2
            fn ([x],opts) => x
 | _ => raise ActionError 129,
d2113 1
a2113 1
            fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2115 1
a2115 1
 | _ => raise ActionError 130,
d2119 1
a2119 1
            fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2121 1
a2121 1
 | _ => raise ActionError 131,
d2125 2
a2126 2
            fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 132,
d2130 1
a2130 1
            fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2133 1
a2133 1
 | _ => raise ActionError 133,
d2137 2
a2138 2
            fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 134,
d2142 1
a2142 1
            fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2148 1
a2148 1
 | _ => raise ActionError 135,
d2152 1
a2152 1
            fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2158 1
a2158 1
 | _ => raise ActionError 136,
d2162 2
a2163 2
            fn ([x],opts) => x
 | _ => raise ActionError 137,
d2167 1
a2167 1
             fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2170 1
a2170 1
 | _ => raise ActionError 138,
d2175 1
a2175 1
            fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2178 1
a2178 1
 | _ => raise ActionError 139,
d2182 1
a2182 1
            fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2185 1
a2185 1
 | _ => raise ActionError 140,
d2189 2
a2190 2
            fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,get_location opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 141,
d2194 1
a2194 1
              fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2198 1
a2198 1
 | _ => raise ActionError 142,
d2204 2
a2205 2
            fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 143,
d2209 2
a2210 2
            fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 144,
d2214 2
a2215 2
            fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 145,
d2219 2
a2220 2
            fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,get_location opts),tvs)
 | _ => raise ActionError 146,
d2224 2
a2225 2
            fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,get_location opts),tvs)
 | _ => raise ActionError 147,
d2229 2
a2230 2
            fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,get_location opts),Set.empty_set)
 | _ => raise ActionError 148,
d2234 2
a2235 2
            fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 149,
d2239 2
a2240 2
            fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 150,
d2244 2
a2245 2
            fn ([_,t,_],opts) => t
 | _ => raise ActionError 151,
d2249 2
a2250 2
            fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 152,
d2254 2
a2255 2
            fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 153,
d2259 2
a2260 2
            fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 154,
d2264 2
a2265 2
            fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 155,
d2269 2
a2270 2
            fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 156,
d2274 2
a2275 2
            fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 157,
d2279 1
a2279 1
            fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2281 1
a2281 1
 | _ => raise ActionError 158,
d2287 2
a2288 2
            fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 159,
d2292 1
a2292 1
            fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2294 1
a2294 1
 | _ => raise ActionError 160,
d2300 2
a2301 2
            fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 161,
d2305 2
a2306 2
            fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 162,
d2312 2
a2313 2
            fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 163,
d2317 2
a2318 2
            fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 164,
d2324 2
a2325 2
            fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 165,
d2329 2
a2330 2
            fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 166,
d2336 2
a2337 2
            fn ([INTEGER s],opts) => SCON (Ident.INT(s,get_location opts))
 | _ => raise ActionError 167,
d2341 2
a2342 2
            fn ([REAL s],opts) => SCON (Ident.REAL (s,get_location opts))
 | _ => raise ActionError 168,
d2346 2
a2347 2
            fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 169,
d2351 2
a2352 2
            fn ([CHAR s],opts) => SCON (Ident.CHAR s)
 | _ => raise ActionError 170,
d2356 2
a2357 2
            fn ([WORD s],opts) => SCON (Ident.WORD(s, get_location opts))
 | _ => raise ActionError 171,
d2363 1
a2363 1
            fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2366 1
a2366 1
 | _ => raise ActionError 172,
d2370 2
a2371 2
            fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 173,
d2377 2
a2378 2
            fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 174,
d2382 2
a2383 2
            fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 175,
d2387 2
a2388 2
            fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 176,
d2392 2
a2393 2
            fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 177,
d2397 2
a2398 2
            fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 178,
d2404 1
a2404 1
            fn ([LONGID ([],s)],opts) => SYM s
d2407 1
a2407 1
 | _ => raise ActionError 179,
d2411 2
a2412 2
            fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 180,
d2417 1
a2417 1
            fn ([LONGID ([],s)],opts) => SYM s
d2420 1
a2420 1
 | _ => raise ActionError 181,
d2424 2
a2425 2
            fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 182,
d2429 2
a2430 2
            fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 183,
d2434 2
a2435 2
            fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 184,
d2443 1
a2443 1
            fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2445 1
a2445 1
 | _ => raise ActionError 185,
d2451 1
a2451 1
            fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2453 1
a2453 1
 | _ => raise ActionError 186,
d2457 2
a2458 2
            fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 187,
d2462 2
a2463 2
            fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 188,
d2468 1
a2468 1
            fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2470 1
a2470 1
 | _ => raise ActionError 189,
d2474 1
a2474 1
            fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2476 1
a2476 1
 | _ => raise ActionError 190,
d2480 2
a2481 2
            fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 191,
d2485 2
a2486 2
            fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 192,
d2490 1
a2490 1
            fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2492 1
a2492 1
 | _ => raise ActionError 193,
d2496 2
a2497 2
            fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 194,
d2501 2
a2502 2
            fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 195,
d2506 1
a2506 1
            fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2508 1
a2508 1
 | _ => raise ActionError 196,
d2512 2
a2513 2
            fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 197,
d2519 2
a2520 2
            fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 198,
d2524 1
a2524 1
            fn ([LONGID x],opts) =>
d2528 1
a2528 1
 | _ => raise ActionError 199,
d2532 1
a2532 1
            fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2534 1
a2534 1
 | _ => raise ActionError 200,
d2538 1
a2538 1
            fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2540 1
a2540 1
 | _ => raise ActionError 201,
d2544 1
a2544 1
            fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2546 1
a2546 1
 | _ => raise ActionError 202,
d2551 1
a2551 1
    fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
d2553 1
a2553 1
 | _ => raise ActionError 203,
d2557 2
a2558 2
            fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 204,
d2562 2
a2563 2
            fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 205,
d2567 2
a2568 2
            fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 206,
d2572 2
a2573 2
            fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 207,
d2577 2
a2578 2
            fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 208,
d2582 2
a2583 2
            fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 209,
d2589 2
a2590 2
            fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 210,
d2594 2
a2595 2
            fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 211,
d2599 1
a2599 1
            fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2601 1
a2601 1
 | _ => raise ActionError 212,
d2605 1
a2605 1
            fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2607 1
a2607 1
 | _ => raise ActionError 213,
d2613 2
a2614 2
            fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 214,
d2618 1
a2618 1
            fn ([_,STRBIND(l,pSE)],opts) => 
d2620 1
a2620 1
 | _ => raise ActionError 215,
d2624 1
a2624 1
            fn ([_,STRBIND(l,pSE)],opts) => 
d2626 1
a2626 1
 | _ => raise ActionError 216,
d2630 1
a2630 1
            fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2632 1
a2632 1
 | _ => raise ActionError 217,
d2635 2
a2636 2
   fn ([_],opts) => BOOL false
 | _ => raise ActionError 218,
d2639 2
a2640 2
   fn ([_],opts) => BOOL true
 | _ => raise ActionError 219,
d2644 2
a2645 2
            fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 220,
d2649 1
a2649 1
            fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2651 1
a2651 1
 | _ => raise ActionError 221,
d2655 1
a2655 1
           fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,STREXP(strexp,pE2)],opts) => 
d2660 1
a2660 1
 | _ => raise ActionError 222,
d2664 1
a2664 1
           fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2669 1
a2669 1
 | _ => raise ActionError 223,
d2673 1
a2673 1
       fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d2675 1
a2675 1
 | _ => raise ActionError 224,
d2679 2
a2680 2
       fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,get_location opts),lookupSigId(opts,id))
 | _ => raise ActionError 225,
d2683 1
a2683 1
    fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND tybind],opts) =>
d2685 1
a2685 1
 | _ => raise ActionError 226,
d2689 2
a2690 2
            fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 227,
d2694 2
a2695 2
            fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 228,
d2699 2
a2700 2
            fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 229,
d2704 2
a2705 2
            fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 230,
d2709 2
a2710 2
            fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,get_location opts)],make_pG(id,e,tycons))
 | _ => raise ActionError 231,
d2714 1
a2714 1
      fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d2716 1
a2716 1
 | _ => raise ActionError 232,
d2719 2
a2720 2
      fn ([],opts) => SPEC(Absyn.SEQUENCEspec [],(PE.empty_pE,[]))
 | _ => raise ActionError 233,
d2724 1
a2724 1
      fn ([SPEC (spec1,specstuff1),SPEC (spec2,specstuff2)],opts) => 
d2726 1
a2726 1
 | _ => raise ActionError 234,
d2730 1
a2730 1
    fn ([SPEC (spec,(pE,tycons)),_,SHAREQ l],opts) => 
d2732 1
a2732 1
 | _ => raise ActionError 235,
d2737 2
a2738 2
  fn ([_],opts) => (SPEC (Absyn.SEQUENCEspec [],(PE.empty_pE,[])))
 | _ => raise ActionError 236,
d2742 2
a2743 2
      fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l,get_location opts),(pVE_in_pE pVE,[]))
 | _ => raise ActionError 237,
d2747 2
a2748 2
      fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (false,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 238,
d2752 5
a2756 2
            fn ([_,TYPDESC t],opts) => SPEC(do_type_spec (true,rev t,opts),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 239,
d2758 8
d2769 1
a2769 1
            fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),
d2771 1
a2771 1
 | _ => raise ActionError 240,
d2775 2
a2776 2
            fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
 | _ => raise ActionError 241,
d2780 2
a2781 2
            fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
 | _ => raise ActionError 242,
d2785 1
a2785 1
       fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d2788 1
a2788 1
 | _ => raise ActionError 243,
d2792 1
a2792 1
       fn ([_,LONGIDLIST l],opts) => 
d2795 1
a2795 1
 | _ => raise ActionError 244,
d2799 2
a2800 2
            fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 245,
d2803 1
a2803 1
  
d2806 1
a2806 1
 | _ => raise ActionError 246,
d2811 2
a2812 2
              fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 247,
d2816 2
a2817 2
              fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 248,
d2821 2
a2822 2
              fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 249,
d2826 2
a2827 2
              fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 250,
d2831 2
a2832 2
            fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 251,
d2836 2
a2837 2
            fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 252,
d2841 2
a2842 2
            fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 253,
d2846 1
a2846 1
            fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2848 1
a2848 1
 | _ => raise ActionError 254,
d2852 2
a2853 2
            fn ([x],opts) => x
 | _ => raise ActionError 255,
d2857 1
a2857 1
            fn ([TYPDESC l,_,TYPDESC [t]],opts) => 
d2859 1
a2859 1
 | _ => raise ActionError 256,
d2863 1
a2863 1
      fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => 
d2865 1
a2865 1
 | _ => raise ActionError 257,
d2869 1
a2869 1
      fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => 
d2871 8
a2878 1
 | _ => raise ActionError 258,
d2883 2
a2884 2
            fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 259,
d2888 1
a2888 1
            fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2890 1
a2890 1
 | _ => raise ActionError 260,
d2892 1
a2892 1
(* 	((DATDESC1 TYVARSEQ TYCON :EQUAL CONDESC))  *)
d2894 1
a2894 1
            fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2897 1
a2897 1
 | _ => raise ActionError 261,
d2901 2
a2902 2
            fn ([x],opts) => x
 | _ => raise ActionError 262,
d2906 1
a2906 1
            fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2908 1
a2908 1
 | _ => raise ActionError 263,
d2912 1
a2912 1
               fn ([VALID con,TY(ty,tyvars)],opts) => 
d2916 1
a2916 1
 | _ => raise ActionError 264,
d2920 2
a2921 2
            fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 265,
d2925 1
a2925 1
            fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2927 1
a2927 1
 | _ => raise ActionError 266,
d2931 1
a2931 1
               fn ([VALID excon,TY(ty,_)],opts) => 
d2935 1
a2935 1
 | _ => raise ActionError 267,
d2939 2
a2940 2
            fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 268,
d2944 1
a2944 1
            fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2946 1
a2946 1
 | _ => raise ActionError 269,
d2950 2
a2951 2
            fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 270,
d2955 2
a2956 2
            fn ([x],opts) => x
 | _ => raise ActionError 271,
d2960 2
a2961 2
            fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 272,
d2965 2
a2966 2
            fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),get_location opts)]
 | _ => raise ActionError 273,
d2970 2
a2971 2
            fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),get_location opts)]
 | _ => raise ActionError 274,
d2975 2
a2976 2
            fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 275,
d2980 2
a2981 2
            fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 276,
d2985 2
a2986 2
            fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 277,
d2990 2
a2991 2
            fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 278,
d2995 2
a2996 2
            fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 279,
d3000 2
a3001 2
            fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 280,
d3005 2
a3006 2
            fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 281,
d3010 1
a3010 1
            fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d3012 1
a3012 1
 | _ => raise ActionError 282,
d3016 1
a3016 1
            fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d3018 1
a3018 1
 | _ => raise ActionError 283,
d3022 1
a3022 1
           fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3035 1
a3035 1
 | _ => raise ActionError 284,
d3039 1
a3039 1
      fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d3052 1
a3052 1
 | _ => raise ActionError 285,
d3056 1
a3056 1
               fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
d3058 1
a3058 1
 | _ => raise ActionError 286,
d3062 1
a3062 1
               fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d3064 1
a3064 1
 | _ => raise ActionError 287,
d3068 1
a3068 1
            fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d3070 1
a3070 1
 | _ => raise ActionError 288,
d3074 1
a3074 1
            fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d3076 1
a3076 1
 | _ => raise ActionError 289,
d3080 2
a3081 2
            fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 290,
d3089 2
a3090 2
            fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,get_location opts),pE_in_pB pE)
 | _ => raise ActionError 291,
d3094 2
a3095 2
            fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,get_location opts),pG_in_pB pG)
 | _ => raise ActionError 292,
d3099 2
a3100 2
            fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,get_location opts),pF_in_pB pF)
 | _ => raise ActionError 293,
d3104 1
a3104 1
            fn ([EXP(exp,tyvars)],opts) =>
d3106 1
a3106 1
 | _ => raise ActionError 294,
d3110 2
a3111 2
            fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, get_location opts),PE.empty_pB)
 | _ => raise ActionError 295,
d3115 2
a3116 2
            fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 296,
d3120 2
a3121 2
            fn ([x,_,_],opts) => x
 | _ => raise ActionError 297,
d3125 2
a3126 2
            fn ([_,x],opts) => x
 | _ => raise ActionError 298,
d3130 2
a3131 2
            fn ([x,_],opts) => x
 | _ => raise ActionError 299,
d3135 2
a3136 2
            fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],get_location opts),PE.empty_pB))
 | _ => raise ActionError 300,
d3142 2
a3143 2
            fn ([],opts) => DUMMY
 | _ => raise ActionError 301,
@


1.76.1.1
log
@branched from 1.76
@
text
@a3 3
 * Revision 1.76  1996/05/09  09:51:19  daveb
 * Improved error message for "op".
 *
@


1.75
log
@Array moving to MLWorks.Array
@
text
@d4 3
d1112 1
a1112 1
        warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d1119 1
a1119 1
        error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
d1130 1
a1130 1
      warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d1136 1
a1136 2
      error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
    else
d1143 1
a1143 1
      warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d1151 1
a1151 1
      error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
@


1.74
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d1264 1
a1264 1
Array.arrayoflist[
d3233 1
a3233 1
  Array.sub (actions,n)
d3328 2
a3329 2
val resolutions  : (bool -> Act * Act * Parsed_Object list * Parsed_Object -> Act) Array.array =
  Array.arrayoflist[ifInfixInput,  (* 0, arity 0 *)
d3337 1
a3337 1
Array.arrayoflist[
d3353 1
a3353 1
  Array.sub(resolutions,n) old_definition
@


1.73
log
@Adding type abbreviations
@
text
@d4 3
d428 1
a428 1
    implode [string,"[",Location.to_string location,"]"]
d430 1
a430 1
    implode [string,"[",Location.to_string location,"]"]
d491 2
a492 2
  (output(std_out,message);
   output(std_out,"\n"))
d498 1
a498 1
fun char_digit s = ord s - ord "0"
d622 1
a622 1
    case explode int of
d702 1
a702 1
            implode (case strid of 
d3437 1
a3437 1
		ord"1" <= weak_char andalso ord"9" >= weak_char
@


1.72
log
@Updating for new language
@
text
@d4 3
a327 1
  | SPECLIST of Absyn.Spec list * (PE.pE * Ident.TyCon list)
d338 1
a338 2
  | TYPDESC of (TyVarList * Ident.TyCon) list
  | TYPDESC1 of (TyVarList * Ident.TyCon)
d375 1
a375 1
  | LONGTYPBIND of (TyVarList * Ident.LongTyCon * Absyn.Ty * Absyn.Tyfun ref MLWorks.Option.option) list
d392 1
a392 1
fun marks_of (OPTS(l,_,_)) = l
d409 2
a410 2
  | do_abstraction  (strid,Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,_,bref),boolref,location,a,b) =
    (strid,Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,true,bref),boolref,location,a,b)
d849 10
a858 1
fun names_of_typedesc t = map (fn (a,b) => b) t
d861 22
a882 1
  
d968 1
a968 1
  val check_disjoint_typdesc = check_disjoint_tycons(fn (_,x) => x, "type specification")
d1179 1
a1179 1
     DEC (Absyn.OPENdec (valids,marks_of opts),new_pE,Set.empty_set))
d1189 1
a1189 1
     SPEC(Absyn.OPENspec (valids,marks_of opts),(new_pE,[])))
d1196 1
a1196 1
    val location = marks_of opts
d1211 1
a1211 1
   ((id,(Derived.make_tuple_pat [pat1,pat2]) :: patlist,exp,marks_of opts),join_tyvars tvarlist))
d1224 1
a1224 1
                          marks_of opts)
d1227 1
a1227 1
               marks_of opts,
d1259 1
d1274 1
a1274 1
           fn ([dec],opts) => dec
d1279 1
a1279 1
           fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1284 1
a1284 1
           fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1292 1
a1292 1
           fn ([_],opts) =>
d1299 1
a1299 1
           fn ([_,_],opts) => 
d1306 1
a1306 1
           fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1311 1
a1311 1
           fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1316 2
a1317 2
         fn ([_,LAB lab],opts) =>
  EXP (Derived.make_select (lab,marks_of opts,make_hash_info(opts,lab)),Set.empty_set)
d1321 1
a1321 1
           fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1325 1
a1325 1
           fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1330 1
a1330 1
           fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1335 1
a1335 1
           fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1340 1
a1340 1
         fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1345 1
a1345 1
           fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1350 1
a1350 1
           fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1356 1
a1356 1
           fn ([_,x,_],opts) => x
d1361 1
a1361 1
           fn ([_],opts) => ENV (get_current_pE())
d1366 1
a1366 1
           fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1371 1
a1371 1
           fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1376 1
a1376 1
           fn ([],opts) => EXPLIST ([],Set.empty_set)
d1381 1
a1381 1
           fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1386 1
a1386 1
           fn ([exp],opts) => exp
d1391 2
a1392 2
           fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
  EXPSEQ ((exp,make_seq_info(opts),marks_of opts)::l,Set.union (tyvars1,tyvars2))
d1397 1
a1397 1
           fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1402 2
a1403 2
           fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
  EXPSEQ ((exp,make_seq_info(opts),marks_of opts)::l,Set.union (tyvars1,tyvars2))
d1408 1
a1408 1
           fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1413 1
a1413 1
           fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1419 1
a1419 1
           fn ([x],opts) => x
d1424 2
a1425 2
           fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
  EXP(Absyn.APPexp(exp1,exp2,marks_of opts,ref Absyn.nullType,false),Set.union(tyvars1,tyvars2))
d1430 1
a1430 1
           fn ([x],opts) => x
d1435 2
a1436 2
           fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
  EXP (Absyn.APPexp (Absyn.VALexp (mannotate(opts,id)),Derived.make_tuple_exp [exp1,exp2],marks_of opts,ref Absyn.nullType,true),Set.union(tyvars1,tyvars2))
d1441 1
a1441 1
           fn ([x],opts) => x
d1446 1
a1446 1
           fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1451 1
a1451 1
           fn ([x],opts) => x
d1456 2
a1457 2
           fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
  EXP (Absyn.TYPEDexp (exp,ty,marks_of opts),Set.union(tyvars1,tyvars2))
d1462 2
a1463 2
         fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1468 2
a1469 2
         fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1474 2
a1475 2
           fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
  EXP (Absyn.HANDLEexp (exp1, ref Absyn.nullType, (rev match),marks_of opts,make_handle_info(opts)),Set.union(tyvars1,tyvars2))
d1480 1
a1480 1
           fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1486 2
a1487 2
           fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
  EXP(Derived.make_if (exp1,exp2,exp3,make_if_info(opts),marks_of opts,get_current_pE()),join_tyvars[tyvars1,tyvars2,tyvars3])
d1492 2
a1493 2
         fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_while (exp1,exp2,make_while_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1498 2
a1499 2
           fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
  EXP (Derived.make_case (exp,(rev m),make_case_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
d1504 2
a1505 2
           fn ([_,MATCH (match,tyvars)],opts) =>
  let val (a,b) = annotate (rev match) in EXP (Absyn.FNexp (a,b,make_fn_info(opts),marks_of opts),tyvars) end
d1510 1
a1510 1
           fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1515 1
a1515 1
           fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1521 1
a1521 1
          fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1526 1
a1526 1
           fn ([_,_],opts) => DUMMY
d1531 1
a1531 1
           fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1536 1
a1536 1
           fn ([_,dec,_],opts) => dec
d1541 1
a1541 1
           fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1546 1
a1546 1
           fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1551 1
a1551 1
           fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1560 1
a1560 1
           fn ([_, TYVARLIST explicit_tyvars, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1566 1
a1566 1
           fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1572 1
a1572 1
         fn ([_,TYVARLIST explicit_tyvars,FVALBIND ((l,tyvars),pVE)],opts) =>
d1574 1
a1574 1
                       tyvars,explicit_tyvars,marks_of opts),pVE_in_pE pVE,Set.empty_set)
d1579 1
a1579 1
         fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1581 1
a1581 1
                       tyvars,[],marks_of opts),pVE_in_pE pVE,Set.empty_set)
d1586 1
a1586 1
           fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1593 2
a1594 2
           fn ([_,DATBIND (d,pVE)],opts) => 
  (extend_pVE pVE; DEC (Absyn.DATATYPEdec (marks_of opts,rev d),pVE_in_pE pVE,Set.empty_set))
d1599 1
a1599 1
           fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1602 1
a1602 1
   DEC (Derived.make_datatype_withtype (marks_of opts,rev d, t, 
d1609 2
a1610 2
           fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
  DEC (Absyn.ABSTYPEdec (marks_of opts,rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars)
d1615 1
a1615 1
           fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1617 1
a1617 1
   DEC (Derived.make_abstype_withtype (marks_of opts,rev d,t,dec,
d1622 1
a1622 1
           fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1627 1
a1627 1
           fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1633 1
a1633 1
           fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1642 1
a1642 1
           fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1650 1
a1650 1
           fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1655 1
a1655 1
           fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1660 1
a1660 1
           fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1665 1
a1665 1
           fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1670 1
a1670 1
           fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1677 1
a1677 1
           fn ([_],opts) => ENV (get_current_pE())
d1682 1
a1682 1
           fn ([x],opts) => x
d1687 1
a1687 1
           fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1693 1
a1693 1
           fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1699 1
a1699 1
           fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1705 2
a1706 2
           fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
  VALBIND ([(pat,exp,marks_of opts)],[],Set.union (tyvars1,tyvars2),pVE)
d1713 2
a1714 2
           fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
  FVALBIND (([((rev fvals),make_fval_info loc,marks_of opts)],tyvars),make_pVE id)
d1719 2
a1720 2
           fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
  FVALBIND (((rev fvals,make_fval_info loc,marks_of opts)::l,Set.union(tyvars1,tyvars2)),addNewValId(opts,id,pVE))
d1725 1
a1725 1
           fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1731 2
a1732 2
           fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
  FVALLIST (fval::fvals,Set.union(tyvars1,tyvars2),id,marks_of opts)
d1737 2
a1738 2
          fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
 FVAL(((id,rev l,Absyn.TYPEDexp(exp,ty,marks_of opts),marks_of opts),join_tyvars[tyvars1,tyvars2,tyvars3]),id)
d1740 1
a1740 1
   FVAL(((id,rev l,exp,marks_of opts),Set.union(tyvars1,tyvars3)),id)
d1745 2
a1746 2
           fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(merge_pVEs(opts,pVE1,pVE2);FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id))
d1753 1
a1753 1
  fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1756 1
a1756 1
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id))
d1765 1
a1765 1
           fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1767 1
a1767 1
 FVAL(((error_id,rev l,Absyn.TYPEDexp(exp,ty,marks_of opts),marks_of opts),Set.union (tyvars2,Set.union (tyvars3,tyvars4))),error_id))
d1770 1
a1770 1
 FVAL(((error_id,rev l,exp,marks_of opts), Set.union (tyvars2,tyvars3)),error_id))
d1775 1
a1775 1
           fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1777 1
a1777 1
 FVAL(make_infix_fval (opts,id,pat1,pat1,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars3,tyvars4]),id))
d1785 2
a1786 2
           fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3]),id)
d1793 2
a1794 2
           fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
  FVAL(make_infix_fval(opts,id,pat1,pat2,rev patl,Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
d1801 1
a1801 1
           fn ([],opts) => NULLTYPE
d1806 1
a1806 1
           fn ([_,ty],opts) => ty
d1811 1
a1811 1
           fn ([x],opts) => x
d1816 1
a1816 1
           fn ([TYPBIND tbl,_,TYPBIND [tb]],opts) =>
d1822 1
a1822 1
           fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1829 1
a1829 1
           fn ([x],opts) => x
d1834 1
a1834 1
           fn ([LONGTYPBIND tbl,_,LONGTYPBIND [tb]],opts) =>
d1840 3
a1842 3
           fn ([TYVARLIST tyvarlist, LONGTYCON tycon,_,TY (ty,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);LONGTYPBIND [(rev tyvarlist,tycon,ty,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullTyfun))
  else MLWorks.Option.NONE)])
d1847 1
a1847 1
           fn ([],opts) => TYVARLIST []
d1852 1
a1852 1
 	 fn ([x],opts) => x
d1857 1
a1857 1
           fn ([TYVAR t],opts) => TYVARLIST [t]
d1862 1
a1862 1
           fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1867 1
a1867 1
           fn ([TYVAR t],opts) => TYVARLIST [t]
d1872 1
a1872 1
           fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1877 1
a1877 1
           fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1882 1
a1882 1
           fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1888 1
a1888 1
           fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1896 1
a1896 1
           fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1901 1
a1901 1
           fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1907 1
a1907 1
              fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
d1913 1
a1913 1
           fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1918 1
a1918 1
           fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1924 2
a1925 2
              fn ([VALID id, TY (ty,tyvars)],opts) => 
  EXBIND1 (Absyn.NEWexbind (annotate id,MLWorks.Option.SOME ty,marks_of opts,make_exbind_info(opts,id)),id,tyvars)
d1927 1
a1927 1
  EXBIND1 (Absyn.NEWexbind (annotate id,MLWorks.Option.NONE,marks_of opts,make_exbind_info(opts,id)),id,Set.empty_set)
d1932 1
a1932 1
           fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1934 1
a1934 1
     EXBIND1 (Absyn.OLDexbind (annotate id,id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set))
d1939 1
a1939 1
           fn ([],opts) => NULLTYPE
d1944 1
a1944 1
           fn ([_,x],opts) => x
d1949 1
a1949 1
           fn ([_],opts as OPTS(location,options,_)) =>
d1955 1
a1955 1
           fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
d1962 2
a1963 2
             fn ([VALID id],opts) => 
  PAT (Absyn.VALpat (annotate' (make_long_id id),marks_of opts),make_pVE id,Set.empty_set)
d1968 1
a1968 1
           fn ([LONGVALID (id,strname_opt)],opts) => 
d1970 1
a1970 1
     (PAT (Absyn.VALpat (annotate' id,marks_of opts),PE.empty_pVE,Set.empty_set)))
d1975 1
a1975 1
           fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1981 1
a1981 1
           fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1987 1
a1987 1
           fn ([_,_,_],opts) => 
d1993 1
a1993 1
           fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1998 1
a1998 1
           fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d2003 1
a2003 1
           fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d2008 1
a2008 1
           fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d2013 1
a2013 1
           fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d2018 1
a2018 1
           fn ([_,x,_],opts) => x
d2023 1
a2023 1
           fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d2028 1
a2028 1
           fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d2034 1
a2034 1
           fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2036 1
a2036 1
   PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],marks_of opts,true),pVE,tyvars))
d2041 1
a2041 1
           fn ([x],opts) => x
d2046 1
a2046 1
           fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2052 1
a2052 1
           fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2058 1
a2058 1
           fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d2063 1
a2063 1
           fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2070 1
a2070 1
           fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d2075 1
a2075 1
           fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2077 1
a2077 1
   PATROW1 ((Derived.make_patrow (sym, MLWorks.Option.SOME ty, MLWorks.Option.NONE,marks_of opts)),make_Sym_pVE sym,tyvars))
d2080 1
a2080 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.NONE, MLWorks.Option.NONE,marks_of opts),make_Sym_pVE sym,Set.empty_set))
d2085 1
a2085 1
           fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2087 1
a2087 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.SOME ty, MLWorks.Option.SOME pat,marks_of opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
d2090 1
a2090 1
   PATROW1 (Derived.make_patrow (sym, MLWorks.Option.NONE, MLWorks.Option.SOME pat,marks_of opts),addNewSymId(opts,sym,pVE),tyvars))
d2095 1
a2095 1
           fn ([x],opts) => x
d2100 1
a2100 1
            fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2102 1
a2102 1
      (PAT (Absyn.APPpat (annotate id, pat,marks_of opts,false),pVE,tyvars)))
d2108 1
a2108 1
           fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2110 1
a2110 1
     PAT (Absyn.APPpat (annotate (make_long_id id), pat,marks_of opts,false),pVE,tyvars))
d2115 1
a2115 1
           fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2117 1
a2117 1
   PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2],marks_of opts,true),merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2)))
d2122 1
a2122 1
           fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d2127 2
a2128 2
             fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
  PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate' id, pat), ty,marks_of opts),addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
d2137 1
a2137 1
           fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d2142 1
a2142 1
           fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d2147 1
a2147 1
           fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d2152 1
a2152 1
           fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d2157 1
a2157 1
           fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d2162 1
a2162 1
           fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d2167 1
a2167 1
           fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d2172 1
a2172 1
           fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d2177 1
a2177 1
           fn ([_,t,_],opts) => t
d2182 1
a2182 1
           fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d2187 1
a2187 1
           fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2192 1
a2192 1
           fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2197 1
a2197 1
           fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2202 1
a2202 1
           fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2207 1
a2207 1
           fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2212 1
a2212 1
           fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2220 1
a2220 1
           fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2225 1
a2225 1
           fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2233 1
a2233 1
           fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2238 1
a2238 1
           fn ([LONGID id],opts) => LONGIDLIST[id]
d2245 1
a2245 1
           fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2250 1
a2250 1
           fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2257 1
a2257 1
           fn ([SYM sym],opts) => SYMLIST [sym]
d2262 1
a2262 1
           fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2269 1
a2269 1
           fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d2274 1
a2274 1
           fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d2279 1
a2279 1
           fn ([STRING s],opts) => SCON (Ident.STRING s)
d2284 1
a2284 1
           fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2289 1
a2289 1
           fn ([WORD s],opts) => SCON (Ident.WORD(s, marks_of opts))
d2296 1
a2296 1
           fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2303 1
a2303 1
           fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2310 1
a2310 1
           fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2315 1
a2315 1
           fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2320 1
a2320 1
           fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2325 1
a2325 1
           fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2330 1
a2330 1
           fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2337 1
a2337 1
           fn ([LONGID ([],s)],opts) => SYM s
d2344 1
a2344 1
           fn ([_],opts) => SYM equal_symbol
d2350 1
a2350 1
           fn ([LONGID ([],s)],opts) => SYM s
d2357 1
a2357 1
           fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2362 1
a2362 1
           fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2367 1
a2367 1
           fn ([SYM s],opts) => STRID(Ident.STRID s)
d2376 1
a2376 1
           fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2384 1
a2384 1
           fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2390 1
a2390 1
           fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d2395 1
a2395 1
           fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d2401 1
a2401 1
           fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2407 1
a2407 1
           fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2413 1
a2413 1
           fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2418 1
a2418 1
           fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2423 1
a2423 1
           fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2429 1
a2429 1
           fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2434 1
a2434 1
           fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2439 1
a2439 1
           fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2445 1
a2445 1
           fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2452 1
a2452 1
           fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d2457 2
a2458 2
           fn ([LONGID x],opts) =>
    STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts,
d2465 2
a2466 2
           fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,strexp,ref false,marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE),lookupFunId (opts,funid))
d2471 2
a2472 2
           fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,ref false,marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE),lookupFunId (opts,funid))
d2477 1
a2477 1
           fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2484 2
a2485 2
   fn ([STREXP (strexp,e),BOOL abs,SIGEXP (sigexp,(e',tycons))],opts) =>
  STREXP (Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false),e')
d2490 1
a2490 1
           fn ([_],opts) => ENV (get_current_pE())
d2495 1
a2495 1
           fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2500 1
a2500 1
           fn ([_,strdec,_],opts) => strdec
d2505 1
a2505 1
           fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2510 1
a2510 1
           fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2515 1
a2515 1
           fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2522 1
a2522 1
           fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2527 1
a2527 1
           fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2532 1
a2532 1
           fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2538 1
a2538 1
           fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2546 1
a2546 1
           fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2551 1
a2551 1
           fn ([_,STRBIND(l,pSE)],opts) => 
d2557 1
a2557 1
           fn ([_,STRBIND(l,pSE)],opts) => 
d2563 1
a2563 1
           fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2568 1
a2568 1
  fn ([_],opts) => BOOL false
d2572 1
a2572 1
  fn ([_],opts) => BOOL true
d2577 1
a2577 1
           fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2582 1
a2582 1
           fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2588 3
a2590 3
          fn ([STRID id,BOOL abs,SIGEXP(sigexp,(pE1,tycons)),_,STREXP(strexp,pE2)],opts) => 
  STRBIND1((id,MLWorks.Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false),ref false,
            marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
d2597 1
a2597 1
          fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2599 1
a2599 1
            marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr))
d2606 1
a2606 1
      fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d2612 1
a2612 1
      fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,marks_of opts),lookupSigId(opts,id))
d2616 2
a2617 2
   fn ([SIGEXP (sigexp,e),_,_,LONGTYPBIND _],opts) =>
   SIGEXP (Absyn.WHEREsigexp (sigexp),e)
d2622 1
a2622 1
           fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2627 1
a2627 1
           fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2632 1
a2632 1
           fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2637 1
a2637 1
           fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2642 1
a2642 1
           fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e,tycons))
d2647 2
a2648 2
           fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
  SIGBIND((id,sigexp,marks_of opts)::l,addNewSigId(opts,(id,e,tycons),pG))
d2651 2
a2652 3
(* 	((SPEC DECSEP))  *)

           fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],(PE.empty_pE,[]))
d2655 1
a2655 1
(* 	((SPEC DECSEP SPEC1 DECSEP))  *)
d2657 2
a2658 1
           fn ([_,spec,_],opts) => spec
d2661 1
a2661 1
(* 	((SPEC DECSEP SPEC0 DECSEP))  *)
d2663 2
a2664 1
           fn([_,SPECLIST(l,(pE,tycons)),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),(pE,tycons))
d2667 1
a2667 1
(* 	((SPEC0 SPEC1 DECSEP SPEC1))  *)
d2669 2
a2670 2
           fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
  SPECLIST([spec2,spec1],spec_augment_pE(pE1,pE2,opts))
d2673 1
a2673 1
(* 	((SPEC0 SPEC0 DECSEP SPEC1))  *)
d2675 1
a2675 2
           fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
  SPECLIST(spec::l,spec_augment_pE(pE1,pE2,opts))
d2678 1
a2678 1
(* ;; Don't need to extend global environment here -- no constructors here  *)
d2680 1
a2680 3
(* 	((SPEC1 :val VALDESC))  *)

           fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),(pVE_in_pE pVE,[]))
d2683 1
a2683 1
(* 	((SPEC1 :type TYPDESC))  *)
d2685 1
a2685 1
           fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),(PE.empty_pE,names_of_typedesc t))
a2687 5
(* 	((SPEC1 :eqtype TYPDESC))  *)

           fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 240,

d2691 3
a2693 2
           fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),(pVE_in_pE pVE,names_of_datdesc l)))
 | _ => raise ActionError 241,
d2697 2
a2698 2
           fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
 | _ => raise ActionError 242,
d2702 2
a2703 7
           fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
 | _ => raise ActionError 243,

(* 	((SPEC1 :sharing SHAREQ))  *)

           fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),(PE.empty_pE,[]))
 | _ => raise ActionError 244,
d2707 1
a2707 1
      fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d2710 1
a2710 1
 | _ => raise ActionError 245,
d2714 1
a2714 1
      fn ([_,LONGIDLIST l],opts) => 
d2717 1
a2717 1
 | _ => raise ActionError 246,
d2721 2
a2722 2
           fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 247,
d2725 1
a2725 1
 
d2727 2
a2728 2
  SPEC (Absyn.INCLUDEspec (e,marks_of opts),(pE,tycons))
 | _ => raise ActionError 248,
d2733 2
a2734 2
             fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 249,
d2738 2
a2739 2
             fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 250,
d2743 2
a2744 2
             fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 251,
d2748 2
a2749 2
             fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 252,
d2753 2
a2754 2
           fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 253,
d2758 2
a2759 2
           fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 254,
d2763 2
a2764 2
           fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 255,
d2768 1
a2768 1
           fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2770 1
a2770 1
 | _ => raise ActionError 256,
d2774 2
a2775 2
           fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 257,
d2779 1
a2779 1
           fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2781 1
a2781 1
 | _ => raise ActionError 258,
d2785 3
a2787 2
           fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 259,
d2791 3
a2793 2
           fn ([TYVARLIST tyvarlist,TYCON tycon,_,TY (ty,tyvarset)],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 260,
d2798 2
a2799 2
           fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 261,
d2803 1
a2803 1
           fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2805 1
a2805 1
 | _ => raise ActionError 262,
d2809 1
a2809 1
           fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2812 1
a2812 1
 | _ => raise ActionError 263,
d2816 2
a2817 2
           fn ([x],opts) => x
 | _ => raise ActionError 264,
d2821 1
a2821 1
           fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2823 1
a2823 1
 | _ => raise ActionError 265,
d2827 1
a2827 1
              fn ([VALID con,TY(ty,tyvars)],opts) => 
d2831 1
a2831 1
 | _ => raise ActionError 266,
d2835 2
a2836 2
           fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 267,
d2840 1
a2840 1
           fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2842 1
a2842 1
 | _ => raise ActionError 268,
d2846 2
a2847 2
              fn ([VALID excon,TY(ty,_)],opts) => 
  EXDESC1(excon,MLWorks.Option.SOME ty,marks_of opts)
d2849 2
a2850 2
  EXDESC1(excon,MLWorks.Option.NONE,marks_of opts)
 | _ => raise ActionError 269,
d2854 2
a2855 2
           fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 270,
d2859 1
a2859 1
           fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2861 1
a2861 1
 | _ => raise ActionError 271,
d2865 2
a2866 2
           fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 272,
d2870 2
a2871 2
           fn ([x],opts) => x
 | _ => raise ActionError 273,
d2875 2
a2876 2
           fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 274,
d2880 2
a2881 2
           fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 275,
d2885 2
a2886 2
           fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 276,
d2890 2
a2891 2
           fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 277,
d2895 2
a2896 2
           fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 278,
d2900 2
a2901 2
           fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 279,
d2905 2
a2906 2
           fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 280,
d2910 2
a2911 2
           fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 281,
d2915 2
a2916 2
           fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 282,
d2920 2
a2921 2
           fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 283,
d2925 1
a2925 1
           fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2927 1
a2927 1
 | _ => raise ActionError 284,
d2931 1
a2931 1
           fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2933 1
a2933 1
 | _ => raise ActionError 285,
d2937 14
a2950 3
          fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),BOOL abs,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;FUNBIND1((funid,strid,sigexp,Absyn.CONSTRAINTstrexp (strexp,sigexp',abs,ref false),MLWorks.Option.NONE ,make_funbind_info(opts,funid),ref false,marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE,if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE)) else MLWorks.Option.NONE),funid,pE''))
 | _ => raise ActionError 286,
d2954 14
a2967 3
          fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,MLWorks.Option.NONE,make_funbind_info (opts,funid),ref false,marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE,if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE)) else MLWorks.Option.NONE),funid,pE'''))
 | _ => raise ActionError 287,
d2971 3
a2973 3
              fn ([STARTFUNBIND2(funid,pE,spec,pE'),BOOL abs,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,MLWorks.Option.NONE,Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,ref false),pE''))
 | _ => raise ActionError 288,
d2977 1
a2977 1
              fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2979 1
a2979 1
 | _ => raise ActionError 289,
d2983 1
a2983 1
           fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d2985 1
a2985 1
 | _ => raise ActionError 290,
d2989 1
a2989 1
           fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d2991 1
a2991 1
 | _ => raise ActionError 291,
d2995 2
a2996 2
           fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 292,
d3000 1
a3000 1
(* ; ;# fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB) *)
d3004 2
a3005 2
           fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 293,
d3009 2
a3010 2
           fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,marks_of opts),pG_in_pB pG)
 | _ => raise ActionError 294,
d3014 2
a3015 2
           fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 295,
d3019 3
a3021 3
           fn ([EXP(exp,tyvars)],opts) =>
   TOPDEC (Derived.make_it_strdec(exp,tyvars,marks_of opts,get_current_pE()),PE.empty_pB)
 | _ => raise ActionError 296,
d3025 2
a3026 2
           fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 297,
d3030 2
a3031 2
           fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 298,
d3035 2
a3036 2
           fn ([x,_,_],opts) => x
 | _ => raise ActionError 299,
d3040 2
a3041 2
           fn ([_,x],opts) => x
 | _ => raise ActionError 300,
d3045 2
a3046 2
           fn ([x,_],opts) => x
 | _ => raise ActionError 301,
d3050 2
a3051 2
           fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 302,
d3057 2
a3058 2
           fn ([],opts) => DUMMY
 | _ => raise ActionError 303,
@


1.71
log
@New language definition]
@
text
@d4 3
d276 1
a276 1
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp MLWorks.Option.option * string * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option)
d306 2
d345 2
a346 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp MLWorks.Option.option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp MLWorks.Option.option * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref MLWorks.Option.option * Absyn.Structure MLWorks.Option.option ref MLWorks.Option.option) * (Ident.StrId * PE.pE))
d374 1
a374 1
  | TYPBIND1 of (TyVarList * Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref MLWorks.Option.option)
d405 7
d1131 3
a1133 3
  let fun fold ([],(pE,tycons)) = (pE,tycons)
        | fold ((pE',tycons')::l,(pE,tycons)) = 
          fold(l,(PE.augment_pE(pE,pE'),augment_tycons (tycons',tycons,opts)))
d1165 1
d1168 1
a1168 1
     SPEC(Absyn.INCLUDEspec(sigids,marks_of opts),(new_pE,new_tycons)))
d1227 1
d1242 1
a1242 1
          fn ([dec],opts) => dec
d1247 1
a1247 1
          fn ([SCON scon],opts) => EXP (Absyn.SCONexp (annotate scon),Set.empty_set)
d1252 1
a1252 1
          fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1260 1
a1260 1
          fn ([_],opts) =>
d1267 1
a1267 1
          fn ([_,_],opts) => 
d1274 1
a1274 1
          fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1279 1
a1279 1
          fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1284 1
a1284 1
        fn ([_,LAB lab],opts) =>
d1289 1
a1289 1
          fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1293 1
a1293 1
          fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1298 1
a1298 1
          fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1303 1
a1303 1
          fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1308 1
a1308 1
        fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1313 1
a1313 1
          fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1318 1
a1318 1
          fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1324 1
a1324 1
          fn ([_,x,_],opts) => x
d1329 1
a1329 1
          fn ([_],opts) => ENV (get_current_pE())
d1334 1
a1334 1
          fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1339 1
a1339 1
          fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1344 1
a1344 1
          fn ([],opts) => EXPLIST ([],Set.empty_set)
d1349 1
a1349 1
          fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1354 1
a1354 1
          fn ([exp],opts) => exp
d1359 1
a1359 1
          fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1365 1
a1365 1
          fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1370 1
a1370 1
          fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1376 1
a1376 1
          fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1381 1
a1381 1
          fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1387 1
a1387 1
          fn ([x],opts) => x
d1392 1
a1392 1
          fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1398 1
a1398 1
          fn ([x],opts) => x
d1403 1
a1403 1
          fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1409 1
a1409 1
          fn ([x],opts) => x
d1414 1
a1414 1
          fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1419 1
a1419 1
          fn ([x],opts) => x
d1424 1
a1424 1
          fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1430 1
a1430 1
        fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1436 1
a1436 1
        fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1442 1
a1442 1
          fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1448 1
a1448 1
          fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1454 1
a1454 1
          fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1460 1
a1460 1
        fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1466 1
a1466 1
          fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1472 1
a1472 1
          fn ([_,MATCH (match,tyvars)],opts) =>
d1478 1
a1478 1
          fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1483 1
a1483 1
          fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1489 1
a1489 1
         fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1494 1
a1494 1
          fn ([_,_],opts) => DUMMY
d1499 1
a1499 1
          fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1504 1
a1504 1
          fn ([_,dec,_],opts) => dec
d1509 1
a1509 1
          fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1514 1
a1514 1
          fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1519 1
a1519 1
          fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1526 6
d1534 10
a1543 3
          fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
  DEC (Absyn.VALdec (rev valbinds1,rev valbinds2,tyvars),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 52,
d1547 1
a1547 1
        fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1549 2
a1550 2
                       tyvars,marks_of opts),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 53,
d1554 2
a1555 2
          fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 54,
d1561 1
a1561 1
          fn ([_,DATBIND (d,pVE)],opts) => 
d1563 1
a1563 1
 | _ => raise ActionError 55,
d1567 1
a1567 1
          fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1573 1
a1573 1
 | _ => raise ActionError 56,
d1577 1
a1577 1
          fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1579 1
a1579 1
 | _ => raise ActionError 57,
d1583 1
a1583 1
          fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1587 1
a1587 1
 | _ => raise ActionError 58,
d1590 2
a1591 2
          fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
 | _ => raise ActionError 59,
d1595 1
a1595 1
          fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1597 1
a1597 1
 | _ => raise ActionError 60,
d1601 1
a1601 1
          fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1604 1
a1604 1
 | _ => raise ActionError 61,
d1610 2
a1611 2
          fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
 | _ => raise ActionError 62,
d1618 2
a1619 2
          fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
 | _ => raise ActionError 63,
d1623 2
a1624 2
          fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
 | _ => raise ActionError 64,
d1628 2
a1629 2
          fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
 | _ => raise ActionError 65,
d1633 2
a1634 2
          fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
 | _ => raise ActionError 66,
d1638 2
a1639 2
          fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
 | _ => raise ActionError 67,
d1645 2
a1646 2
          fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 68,
d1650 2
a1651 2
          fn ([x],opts) => x
 | _ => raise ActionError 69,
d1655 1
a1655 1
          fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1657 1
a1657 1
 | _ => raise ActionError 70,
d1661 1
a1661 1
          fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1663 1
a1663 1
 | _ => raise ActionError 71,
d1667 1
a1667 1
          fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1669 1
a1669 1
 | _ => raise ActionError 72,
d1673 1
a1673 1
          fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1675 1
a1675 1
 | _ => raise ActionError 73,
d1681 1
a1681 1
          fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1683 1
a1683 1
 | _ => raise ActionError 74,
d1687 1
a1687 1
          fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1689 1
a1689 1
 | _ => raise ActionError 75,
d1693 2
a1694 2
          fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
 | _ => raise ActionError 76,
d1699 1
a1699 1
          fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1701 1
a1701 1
 | _ => raise ActionError 77,
d1705 1
a1705 1
         fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1709 1
a1709 1
 | _ => raise ActionError 78,
d1713 1
a1713 1
          fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1717 1
a1717 1
 | _ => raise ActionError 79,
d1721 1
a1721 1
 fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1729 1
a1729 1
 | _ => raise ActionError 80,
d1733 1
a1733 1
          fn ([PAT (pat1,pVE1,tyvars1),PATLIST(l,pE,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1739 1
a1739 1
 | _ => raise ActionError 81,
d1743 1
a1743 1
          fn ([PAT (pat1,pVE1,tyvars1),VALID id,TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1749 1
a1749 1
 | _ => raise ActionError 82,
d1753 1
a1753 1
          fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1757 1
a1757 1
 | _ => raise ActionError 83,
d1761 1
a1761 1
          fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1765 1
a1765 1
 | _ => raise ActionError 84,
d1769 2
a1770 2
          fn ([],opts) => NULLTYPE
 | _ => raise ActionError 85,
d1774 2
a1775 2
          fn ([_,ty],opts) => ty
 | _ => raise ActionError 86,
d1779 2
a1780 2
          fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
 | _ => raise ActionError 87,
d1782 1
a1782 1
(* 	((TYPBIND TYPBIND :and TYPBIND1))  *)
d1784 1
a1784 1
          fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1786 19
a1804 1
 | _ => raise ActionError 88,
d1806 1
a1806 1
(* 	((TYPBIND1 TYVARSEQ TYCON :EQUAL TY))  *)
d1808 4
a1811 4
          fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullTyfun))
else MLWorks.Option.NONE))
 | _ => raise ActionError 89,
d1815 7
a1821 2
          fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 90,
d1823 1
a1823 1
(* 	((TYVARSEQ :tyvar))  *)
d1825 2
a1826 2
          fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 91,
d1828 1
a1828 1
(* 	((TYVARSEQ :lpar TYVARLIST :rpar))  *)
d1830 2
a1831 2
          fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 92,
d1835 2
a1836 2
          fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 93,
d1840 2
a1841 2
          fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 94,
d1845 2
a1846 2
          fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
 | _ => raise ActionError 95,
d1850 1
a1850 1
          fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1852 1
a1852 1
 | _ => raise ActionError 96,
d1856 1
a1856 1
          fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1860 1
a1860 1
 | _ => raise ActionError 97,
d1864 2
a1865 2
          fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 98,
d1869 1
a1869 1
          fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1871 1
a1871 1
 | _ => raise ActionError 99,
d1875 1
a1875 1
             fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,MLWorks.Option.SOME ty),id,tyvars)
d1877 1
a1877 1
 | _ => raise ActionError 100,
d1881 2
a1882 2
          fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 101,
d1886 1
a1886 1
          fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1888 1
a1888 1
 | _ => raise ActionError 102,
d1892 1
a1892 1
             fn ([VALID id, TY (ty,tyvars)],opts) => 
d1896 1
a1896 1
 | _ => raise ActionError 103,
d1900 1
a1900 1
          fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1903 1
a1903 1
 | _ => raise ActionError 104,
d1907 2
a1908 2
          fn ([],opts) => NULLTYPE
 | _ => raise ActionError 105,
d1912 2
a1913 2
          fn ([_,x],opts) => x
 | _ => raise ActionError 106,
d1917 1
a1917 1
          fn ([_],opts as OPTS(location,options,_)) =>
d1919 1
a1919 1
 | _ => raise ActionError 107,
d1923 2
a1924 2
          fn ([SCON x],opts) => PAT (Absyn.SCONpat (annotate x),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 108,
d1930 1
a1930 1
            fn ([VALID id],opts) => 
d1932 1
a1932 1
 | _ => raise ActionError 109,
d1936 1
a1936 1
          fn ([LONGVALID (id,strname_opt)],opts) => 
d1939 1
a1939 1
 | _ => raise ActionError 110,
d1943 1
a1943 1
          fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1945 1
a1945 1
 | _ => raise ActionError 111,
d1949 1
a1949 1
          fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1951 1
a1951 1
 | _ => raise ActionError 112,
d1955 1
a1955 1
          fn ([_,_,_],opts) => 
d1957 1
a1957 1
 | _ => raise ActionError 113,
d1961 2
a1962 2
          fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 114,
d1966 2
a1967 2
          fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 115,
d1971 2
a1972 2
          fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 116,
d1976 2
a1977 2
          fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 117,
d1981 2
a1982 2
          fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 118,
d1986 2
a1987 2
          fn ([_,x,_],opts) => x
 | _ => raise ActionError 119,
d1991 2
a1992 2
          fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 120,
d1996 1
a1996 1
          fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1998 1
a1998 1
 | _ => raise ActionError 121,
d2002 1
a2002 1
          fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d2005 1
a2005 1
 | _ => raise ActionError 122,
d2009 2
a2010 2
          fn ([x],opts) => x
 | _ => raise ActionError 123,
d2014 1
a2014 1
          fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2016 1
a2016 1
 | _ => raise ActionError 124,
d2020 1
a2020 1
          fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d2022 1
a2022 1
 | _ => raise ActionError 125,
d2026 2
a2027 2
          fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 126,
d2031 1
a2031 1
          fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d2034 1
a2034 1
 | _ => raise ActionError 127,
d2038 2
a2039 2
          fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 128,
d2043 1
a2043 1
          fn ([SYM sym, TY (ty,tyvars)],opts) =>
d2049 1
a2049 1
 | _ => raise ActionError 129,
d2053 1
a2053 1
          fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d2059 1
a2059 1
 | _ => raise ActionError 130,
d2063 2
a2064 2
          fn ([x],opts) => x
 | _ => raise ActionError 131,
d2068 1
a2068 1
           fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d2071 1
a2071 1
 | _ => raise ActionError 132,
d2076 1
a2076 1
          fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d2079 1
a2079 1
 | _ => raise ActionError 133,
d2083 1
a2083 1
          fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d2086 1
a2086 1
 | _ => raise ActionError 134,
d2090 2
a2091 2
          fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 135,
d2095 1
a2095 1
            fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d2099 1
a2099 1
 | _ => raise ActionError 136,
d2105 2
a2106 2
          fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 137,
d2110 2
a2111 2
          fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 138,
d2115 2
a2116 2
          fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 139,
d2120 2
a2121 2
          fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
 | _ => raise ActionError 140,
d2125 2
a2126 2
          fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
 | _ => raise ActionError 141,
d2130 2
a2131 2
          fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
 | _ => raise ActionError 142,
d2135 2
a2136 2
          fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 143,
d2140 2
a2141 2
          fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 144,
d2145 2
a2146 2
          fn ([_,t,_],opts) => t
 | _ => raise ActionError 145,
d2150 2
a2151 2
          fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 146,
d2155 2
a2156 2
          fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 147,
d2160 2
a2161 2
          fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 148,
d2165 2
a2166 2
          fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 149,
d2170 2
a2171 2
          fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 150,
d2175 2
a2176 2
          fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 151,
d2180 1
a2180 1
          fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2182 1
a2182 1
 | _ => raise ActionError 152,
d2188 2
a2189 2
          fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 153,
d2193 1
a2193 1
          fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2195 1
a2195 1
 | _ => raise ActionError 154,
d2201 2
a2202 2
          fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 155,
d2206 2
a2207 2
          fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 156,
d2213 2
a2214 2
          fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 157,
d2218 2
a2219 2
          fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 158,
d2225 2
a2226 2
          fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 159,
d2230 2
a2231 2
          fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 160,
d2237 2
a2238 2
          fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
 | _ => raise ActionError 161,
d2242 2
a2243 2
          fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
 | _ => raise ActionError 162,
d2247 2
a2248 2
          fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 163,
d2252 2
a2253 2
          fn ([CHAR s],opts) => SCON (Ident.CHAR s)
 | _ => raise ActionError 164,
d2257 2
a2258 2
          fn ([WORD s],opts) => SCON (Ident.WORD(s, marks_of opts))
 | _ => raise ActionError 165,
d2264 1
a2264 1
          fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2267 1
a2267 1
 | _ => raise ActionError 166,
d2271 2
a2272 2
          fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 167,
d2278 2
a2279 2
          fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 168,
d2283 2
a2284 2
          fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 169,
d2288 2
a2289 2
          fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 170,
d2293 2
a2294 2
          fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 171,
d2298 2
a2299 2
          fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 172,
d2305 1
a2305 1
          fn ([LONGID ([],s)],opts) => SYM s
d2308 1
a2308 1
 | _ => raise ActionError 173,
d2312 2
a2313 2
          fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 174,
d2318 1
a2318 1
          fn ([LONGID ([],s)],opts) => SYM s
d2321 1
a2321 1
 | _ => raise ActionError 175,
d2325 2
a2326 2
          fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 176,
d2330 2
a2331 2
          fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 177,
d2335 2
a2336 2
          fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 178,
d2344 1
a2344 1
          fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2346 1
a2346 1
 | _ => raise ActionError 179,
d2352 1
a2352 1
          fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2354 1
a2354 1
 | _ => raise ActionError 180,
d2358 2
a2359 2
          fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 181,
d2363 2
a2364 2
          fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 182,
d2369 1
a2369 1
          fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2371 1
a2371 1
 | _ => raise ActionError 183,
d2375 1
a2375 1
          fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2377 1
a2377 1
 | _ => raise ActionError 184,
d2381 2
a2382 2
          fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 185,
d2386 2
a2387 2
          fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 186,
d2391 1
a2391 1
          fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2393 1
a2393 1
 | _ => raise ActionError 187,
d2397 2
a2398 2
          fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 188,
d2402 2
a2403 2
          fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 189,
d2407 1
a2407 1
          fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2409 1
a2409 1
 | _ => raise ActionError 190,
d2413 2
a2414 2
          fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 191,
d2420 2
a2421 2
          fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 192,
d2425 1
a2425 1
          fn ([LONGID x],opts) =>
d2429 1
a2429 1
 | _ => raise ActionError 193,
d2433 1
a2433 1
          fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2435 1
a2435 1
 | _ => raise ActionError 194,
d2439 1
a2439 1
          fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2441 1
a2441 1
 | _ => raise ActionError 195,
d2445 1
a2445 1
          fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2447 8
a2454 1
 | _ => raise ActionError 196,
d2458 2
a2459 2
          fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 197,
d2463 2
a2464 2
          fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 198,
d2468 2
a2469 2
          fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 199,
d2473 2
a2474 2
          fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 200,
d2478 2
a2479 2
          fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 201,
d2483 2
a2484 2
          fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 202,
d2490 2
a2491 2
          fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 203,
d2495 2
a2496 2
          fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 204,
d2500 1
a2500 1
          fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2502 1
a2502 1
 | _ => raise ActionError 205,
d2506 1
a2506 1
          fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2508 1
a2508 1
 | _ => raise ActionError 206,
d2514 2
a2515 2
          fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 207,
d2519 1
a2519 1
          fn ([_,STRBIND(l,pSE)],opts) => 
d2521 1
a2521 1
 | _ => raise ActionError 208,
d2525 3
a2527 3
          fn ([_,STRBIND(l,pSE)],opts) => 
  (extend_pSE pSE;STRDEC(Absyn.ABSTRACTIONstrdec l,pSE_in_pE pSE))
 | _ => raise ActionError 209,
d2531 1
a2531 1
          fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2533 9
a2541 1
 | _ => raise ActionError 210,
d2545 2
a2546 2
          fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 211,
d2550 1
a2550 1
          fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2552 1
a2552 1
 | _ => raise ActionError 212,
d2554 1
a2554 1
(* 	((STRBIND1 STRID :colon SIGEXP :equal STREXP))  *)
d2556 2
a2557 2
         fn ([STRID id,_,SIGEXP(sigexp,(pE1,tycons)),_,STREXP(strexp,pE2)],opts) => 
  STRBIND1((id,MLWorks.Option.SOME sigexp,strexp,ref false,
d2561 1
a2561 1
 | _ => raise ActionError 213,
d2565 1
a2565 1
         fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2570 1
a2570 1
 | _ => raise ActionError 214,
d2574 1
a2574 1
     fn ([ENV pE,SPEC (spec,(e,tycons)),_],opts) => 
d2576 1
a2576 1
 | _ => raise ActionError 215,
d2580 7
a2586 2
     fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 216,
d2590 2
a2591 2
          fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 217,
d2595 2
a2596 2
          fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 218,
d2600 2
a2601 2
          fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 219,
d2605 2
a2606 2
          fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 220,
d2610 2
a2611 2
          fn ([SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e,tycons))
 | _ => raise ActionError 221,
d2615 1
a2615 1
          fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,(e,tycons))],opts) => 
d2617 1
a2617 1
 | _ => raise ActionError 222,
d2621 2
a2622 2
          fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],(PE.empty_pE,[]))
 | _ => raise ActionError 223,
d2626 2
a2627 2
          fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 224,
d2631 2
a2632 2
          fn([_,SPECLIST(l,(pE,tycons)),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),(pE,tycons))
 | _ => raise ActionError 225,
d2636 1
a2636 1
          fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2638 1
a2638 1
 | _ => raise ActionError 226,
d2642 1
a2642 1
          fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2644 1
a2644 1
 | _ => raise ActionError 227,
d2650 2
a2651 2
          fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),(pVE_in_pE pVE,[]))
 | _ => raise ActionError 228,
d2655 2
a2656 2
          fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),(PE.empty_pE,names_of_typedesc t))
 | _ => raise ActionError 229,
d2660 2
a2661 1
          fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),(PE.empty_pE,names_of_typedesc t))
a2662 1
 | _ => raise ActionError 230,
d2666 2
a2667 2
          fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),(pVE_in_pE pVE,names_of_datdesc l)))
 | _ => raise ActionError 231,
d2671 2
a2672 2
          fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),(pVE_in_pE pVE,[])))
 | _ => raise ActionError 232,
d2676 2
a2677 2
          fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),(pSE_in_pE pSE,[])))
 | _ => raise ActionError 233,
d2681 2
a2682 2
          fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),(PE.empty_pE,[]))
 | _ => raise ActionError 234,
d2686 1
a2686 1
     fn ([ENV pE,SPEC(spec1,(pE1,tycons1)),_,SPEC(spec2,(pE2,tycons2)),_],opts) => 
d2689 1
a2689 1
 | _ => raise ActionError 235,
d2693 1
a2693 1
     fn ([_,LONGIDLIST l],opts) => 
d2696 1
a2696 1
 | _ => raise ActionError 236,
d2700 8
a2707 2
          fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 237,
d2712 2
a2713 2
            fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 238,
d2717 2
a2718 2
            fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 239,
d2722 2
a2723 2
            fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 240,
d2727 2
a2728 2
            fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 241,
d2732 2
a2733 2
          fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 242,
d2737 2
a2738 2
          fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 243,
d2742 2
a2743 2
          fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 244,
d2747 1
a2747 1
          fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2749 1
a2749 1
 | _ => raise ActionError 245,
d2753 2
a2754 2
          fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 246,
d2758 1
a2758 1
          fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2760 1
a2760 1
 | _ => raise ActionError 247,
d2764 7
a2770 2
          fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 248,
d2775 2
a2776 2
          fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 249,
d2780 1
a2780 1
          fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2782 1
a2782 1
 | _ => raise ActionError 250,
d2786 1
a2786 1
          fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2789 1
a2789 1
 | _ => raise ActionError 251,
d2793 2
a2794 2
          fn ([x],opts) => x
 | _ => raise ActionError 252,
d2798 1
a2798 1
          fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2800 1
a2800 1
 | _ => raise ActionError 253,
d2804 1
a2804 1
             fn ([VALID con,TY(ty,tyvars)],opts) => 
d2806 1
a2806 1
| ([VALID con,NULLTYPE],opts) => 
d2808 1
a2808 1
 | _ => raise ActionError 254,
d2812 2
a2813 2
          fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 255,
d2817 1
a2817 1
          fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2819 1
a2819 1
 | _ => raise ActionError 256,
d2823 1
a2823 1
             fn ([VALID excon,TY(ty,_)],opts) => 
d2825 1
a2825 1
| ([VALID excon,NULLTYPE],opts) => 
d2827 1
a2827 1
 | _ => raise ActionError 257,
d2831 2
a2832 2
          fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 258,
d2836 1
a2836 1
          fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2838 1
a2838 1
 | _ => raise ActionError 259,
d2842 2
a2843 2
          fn ([STRID strid,_,SIGEXP(e,(pE,tycons))],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 260,
d2847 2
a2848 2
          fn ([x],opts) => x
 | _ => raise ActionError 261,
d2852 2
a2853 2
          fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 262,
d2857 2
a2858 2
          fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 263,
d2862 2
a2863 2
          fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 264,
d2867 2
a2868 2
          fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 265,
d2872 2
a2873 2
          fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 266,
d2877 2
a2878 2
          fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 267,
d2882 2
a2883 2
          fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 268,
d2887 2
a2888 2
          fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 269,
d2892 2
a2893 2
          fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 270,
d2897 2
a2898 2
          fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 271,
d2902 1
a2902 1
          fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2904 1
a2904 1
 | _ => raise ActionError 272,
d2908 1
a2908 1
          fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2910 1
a2910 1
 | _ => raise ActionError 273,
d2912 1
a2912 1
(* 	((FUNBIND1 STARTFUNBIND1 :colon SIGEXP :EQUAL STREXP))  *)
d2914 3
a2916 3
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,MLWorks.Option.SOME sigexp',make_funbind_info(opts,funid),ref false,marks_of opts,if generate_moduler opts then MLWorks.Option.SOME(ref(Absyn.nullDebuggerStr)) else MLWorks.Option.NONE,if generate_moduler opts then MLWorks.Option.SOME(ref(MLWorks.Option.NONE)) else MLWorks.Option.NONE),funid,pE''))
 | _ => raise ActionError 274,
d2920 1
a2920 1
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2922 1
a2922 1
 | _ => raise ActionError 275,
d2924 1
a2924 1
(* 	((FUNBIND1 STARTFUNBIND2 :colon SIGEXP :EQUAL STREXP))  *)
d2926 3
a2928 3
             fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,(pE'',tycons)),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,MLWorks.Option.SOME sigexp,strexp,pE''))
 | _ => raise ActionError 276,
d2932 1
a2932 1
             fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2934 1
a2934 1
 | _ => raise ActionError 277,
d2938 1
a2938 1
          fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,(pE',tycons)),_],opts) =>
d2940 1
a2940 1
 | _ => raise ActionError 278,
d2944 1
a2944 1
          fn ([FUNIDBIND (funid,pE),_,SPEC(spec,(pE',tycons)),_],opts) => 
d2946 1
a2946 1
 | _ => raise ActionError 279,
d2950 2
a2951 2
          fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 280,
d2959 2
a2960 2
          fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 281,
d2964 2
a2965 2
          fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l,marks_of opts),pG_in_pB pG)
 | _ => raise ActionError 282,
d2969 2
a2970 2
          fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 283,
d2974 1
a2974 1
          fn ([EXP(exp,tyvars)],opts) =>
d2976 1
a2976 1
 | _ => raise ActionError 284,
d2980 2
a2981 2
          fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 285,
d2985 2
a2986 2
          fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 286,
d2990 2
a2991 2
          fn ([x,_,_],opts) => x
 | _ => raise ActionError 287,
d2995 2
a2996 2
          fn ([_,x],opts) => x
 | _ => raise ActionError 288,
d3000 2
a3001 2
          fn ([x,_],opts) => x
 | _ => raise ActionError 289,
d3005 2
a3006 2
          fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 290,
d3012 2
a3013 2
          fn ([],opts) => DUMMY
 | _ => raise ActionError 291,
d3042 3
d3091 3
d3125 2
a3126 2
(* 	(((:shift (pat oplongvar atpat))(:reduce (atpat oplongvar)))  *)
(* 	 (:funcall ifinfixinput (:reduce (atpat oplongvar)) :shift))  *)
d3128 2
a3129 2
(* 	(((:shift (pat opvardef atpat))(:reduce (atpat opvardef)))  *)
(* 	 (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift))  *)
d3131 2
a3132 2
(* 	(((:reduce (infexp appexp))(:shift (appexp appexp atexp)))  *)
(*           (:funcall ifinfixinput (:reduce (infexp appexp))(:shift (appexp appexp atexp))))  *)
d3134 31
a3164 31
(* 	(((:reduce (pat atpat))(:shift (fval :lpar atpat vardef atpat :rpar opttype :equal exp)))  *)
(*           (:funcall ifinfixinput (:reduce (pat atpat)) :shift))  *)

(* 	(((:reduce (atpat opvardef))(:shift (fval opvardef atpatlist opttype :equal exp)))  *)
(*           (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift))  *)

(* 	(((:reduce (atpat1 bin_atpat))(:shift (fval bin_atpat atpatlist opttype :equal exp)))  *)
(*           (:funcall ifinfixinput (:reduce (atpat1 bin_atpat)):shift))  *)

(* 	(((:reduce (pat atpat)) (:shift (bin_atpat :lpar atpat patvar atpat :rpar)))  *)
(*           (:funcall ifinfixinput :shift (:reduce (pat atpat))))  *)

(* 	;; problems with type tuples  *)
(* 	(((:reduce (tytuple ty star ty)) (:shift (ty ty longtycon)))  *)
(*            (:funcall ifstarinput (:reduce (tytuple ty star ty)) :shift))  *)
(* 	(((:reduce (tytuple tytuple star ty)) (:shift (ty ty longtycon)))  *)
(*           (:funcall ifstarinput (:reduce (tytuple tytuple star ty)) :shift))  *)

(* 	;; precedences  *)
(*        (((:reduce (pat pat var pat)) (:shift (pat pat var pat)))  *)
(* 	 (:funcall ifleftassoc (:reduce (pat pat var pat)) :shift))  *)
(* 	(((:reduce (infexp infexp infvar infexp)) (:shift (infexp infexp infvar infexp)))  *)
(* 	 (:funcall ifleftassoc (:reduce (infexp infexp infvar infexp)) :shift))  *)

(* 	;; reduce-reduce conflicts  *)
(* 	(((:reduce (vardef :longid)) (:reduce (longvar :longid))) *)
(* 	 (:funcall ifvarstack (:reduce (vardef :longid)) (:reduce (longvar :longid)))) *)

(* 	(((:reduce (star :longid)) (:reduce (longtycon :longid)))  *)
(*          (:funcall ifstarstack (:reduce (star :longid)) (:reduce (longtycon :longid))))  *)
(* 	))  *)
d3340 1
a3340 1
         | Token.WHERE => (LRbasics.WHILE,DUMMY)
d3358 1
a3358 1
         | Token.ABSCOLON => (LRbasics.COLON,DUMMY)
@


1.70
log
@Added location information to Absyn.SIGNATUREtopdec.
@
text
@d4 3
d318 3
a320 3
  | SIGEXP of Absyn.SigExp * PE.pE
  | SPEC of Absyn.Spec * PE.pE
  | SPECLIST of Absyn.Spec list * PE.pE
d390 2
d547 12
d656 1
a656 1
fun make_pG (id,pE) = PE.addSigId (pe_error,id,pE,PE.empty_pG)
d807 1
a807 1
     PE.empty_pE)
d817 23
d845 1
a845 1
    (extend_pE new_pE; DEC(Absyn.SEQUENCEdec [],new_pE,Set.empty_set))
d922 4
a925 4
  val check_disjoint_datbind = check_disjoint_tycons(fn (_,x,_,_,_) => x, "datbind")
  val check_disjoint_typbind = check_disjoint_tycons(fn (_,x,_,_) => x, "typbind")
  val check_disjoint_datdesc = check_disjoint_tycons(fn (_,x,_) => x, "datdesc")
  val check_disjoint_typdesc = check_disjoint_tycons(fn (_,x) => x, "typdesc")
d1003 1
a1003 1
    fun error_fun (valid1,valid2) =
d1036 1
a1036 1
  fun addNewSigId (opts,(id,pE),pGE) = PE.addSigId (sigid_error opts,id,pE,pGE)
d1118 8
d1146 1
a1146 1
     SPEC(Absyn.OPENspec (valids,marks_of opts),new_pE))
d1152 1
a1152 1
    val new_pE = fold_pEs pEs
d1155 1
a1155 1
     SPEC(Absyn.INCLUDEspec(sigids,marks_of opts),new_pE))
d1198 2
a1199 1
             make_fixity_pE (ids,precedence))
d1202 1
a1202 1
       SPEC(Absyn.STRUCTUREspec [],PE.empty_pE))
d2491 1
a2491 1
         fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2509 2
a2510 2
             fn ([ENV pE,SPEC (spec,e),_],opts) => 
  (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref MLWorks.Option.NONE),e))
d2515 1
a2515 1
             fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref MLWorks.Option.NONE,marks_of opts),lookupSigId(opts,id))
d2540 1
a2540 1
          fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2545 2
a2546 2
          fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
  SIGBIND((id,sigexp,marks_of opts)::l,addNewSigId(opts,(id,e),pG))
d2551 1
a2551 1
          fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2561 1
a2561 1
          fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2567 1
a2567 1
  SPECLIST([spec2,spec1],PE.augment_pE(pE1,pE2))
d2573 1
a2573 1
  SPECLIST(spec::l,PE.augment_pE(pE1,pE2))
d2580 1
a2580 1
          fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2585 1
a2585 1
          fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2590 2
a2591 1
          fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2596 1
a2596 1
          fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2601 1
a2601 1
          fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2606 1
a2606 1
          fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2611 1
a2611 1
          fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2616 3
a2618 2
          fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
  (set_pE (PE.augment_pE(pE,pE2));SPEC(Absyn.LOCALspec(spec1,spec2),pE2))
d2623 3
a2625 1
          fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2761 1
a2761 1
          fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2833 1
a2833 1
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2845 1
a2845 1
             fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2857 1
a2857 1
          fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2863 1
a2863 1
          fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d3152 1
a3152 1
fun get_associativity(right_assoc, s1, s2) =
d3164 2
a3165 1
	(not right_assoc) orelse associate_left s1 orelse associate_left s2
d3171 1
a3171 1
fun ifLeftAssoc right_assoc (act1,act2,[LONGVALID (lvalid,_),_], LONGID ([],s)) =
d3175 1
a3175 1
    if get_associativity (right_assoc, get_sym valid, s) then act1 else act2
d3177 1
a3177 1
  | ifLeftAssoc right_assoc (act1,act2, [LONGVALID (lvalid,_),_], EQVAL) =
d3181 1
a3181 1
      if get_associativity (right_assoc, get_sym valid,equal_symbol) then act1 else act2
d3210 3
a3212 3
fun get_resolution(n, Options.OPTIONS{compat_options =
				      Options.COMPATOPTIONS{infixr_assoc, ...}, ...}) =
  Array.sub(resolutions,n) infixr_assoc
d3253 1
d3271 1
@


1.69
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d2830 1
a2830 1
          fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
@


1.68
log
@Changed Absyn.REQUIREtopdec to take a string instead of a module_id.
@
text
@d4 3
d261 1
a261 1
  type ConBind = ((Ident.ValId * TypeRef) * Absyn.Ty Absyn.Option.opt)
d265 4
a268 4
  type ConType = Ident.ValId * Absyn.Ty Absyn.Option.opt
  type ExType = Ident.ValId * Absyn.Ty Absyn.Option.opt * Location.T
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.Option.opt * string * bool ref * Location.T * Absyn.DebuggerStr ref Absyn.Option.opt * Absyn.Structure Absyn.Option.opt ref Absyn.Option.opt)
  type DatBind = TyVarList * Ident.TyCon * TypeRef  * Absyn.Tyfun ref Absyn.Option.opt * ConBind list
d334 2
a335 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.Option.opt * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref Absyn.Option.opt * Absyn.Structure Absyn.Option.opt ref Absyn.Option.opt) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.Option.opt * Absyn.StrExp * bool ref * Location.T * Absyn.DebuggerStr ref Absyn.Option.opt * Absyn.Structure Absyn.Option.opt ref Absyn.Option.opt) * (Ident.StrId * PE.pE))
d362 2
a363 2
  | TYPBIND of (TyVarList * Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref Absyn.Option.opt) list
  | TYPBIND1 of (TyVarList * Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref Absyn.Option.opt)
d373 2
a374 2
  | OPTsigexp of Absyn.SigExp Absyn.Option.opt
(*  | OPTOFTYPE of Absyn.Ty Absyn.Option.opt *)
d1064 1
a1064 1
   ref(Absyn.nullInstanceInfo,Absyn.Option.ABSENT))
d1126 1
a1126 1
                         Absyn.NEWsigexp(spec,ref Absyn.Option.ABSENT),
d1133 4
a1136 4
               if generate_moduler then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr))
               else Absyn.Option.ABSENT,
               if generate_moduler then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT))
               else Absyn.Option.ABSENT),funid,pE)
d1712 2
a1713 2
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullTyfun))
else Absyn.Option.ABSENT))
d1756 2
a1757 2
   DATBIND1 ((rev tyvarlist,tycon,ref Absyn.nullType,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullTyfun))
else Absyn.Option.ABSENT,rev conbind),pVE))
d1773 2
a1774 2
             fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
| ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,Absyn.Option.ABSENT),id,Set.empty_set)
d1791 1
a1791 1
  EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.Option.PRESENT ty,marks_of opts,make_exbind_info(opts,id)),id,tyvars)
d1793 1
a1793 1
  EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.Option.ABSENT,marks_of opts,make_exbind_info(opts,id)),id,Set.empty_set)
d1943 1
a1943 1
   PATROW1 ((Derived.make_patrow (sym, Absyn.Option.PRESENT ty, Absyn.Option.ABSENT,marks_of opts)),make_Sym_pVE sym,tyvars))
d1946 1
a1946 1
   PATROW1 (Derived.make_patrow (sym, Absyn.Option.ABSENT, Absyn.Option.ABSENT,marks_of opts),make_Sym_pVE sym,Set.empty_set))
d1953 1
a1953 1
   PATROW1 (Derived.make_patrow (sym, Absyn.Option.PRESENT ty, Absyn.Option.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
d1956 1
a1956 1
   PATROW1 (Derived.make_patrow (sym, Absyn.Option.ABSENT, Absyn.Option.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),tyvars))
d2325 2
a2326 2
                             if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT))
                             else Absyn.Option.ABSENT),lookupStrId(opts,x))
d2332 1
a2332 1
  STREXP (Absyn.APPstrexp (funid,strexp,ref false,marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr)) else Absyn.Option.ABSENT),lookupFunId (opts,funid))
d2338 1
a2338 1
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,ref false,marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr)) else Absyn.Option.ABSENT),lookupFunId (opts,funid))
d2440 4
a2443 4
  STRBIND1((id,Absyn.Option.PRESENT sigexp,strexp,ref false,
            marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr))
else Absyn.Option.ABSENT,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT))
else Absyn.Option.ABSENT),(id,pE1))
d2449 4
a2452 4
  STRBIND1((id,Absyn.Option.ABSENT,strexp,ref false,
            marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr))
else Absyn.Option.ABSENT,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT))
else Absyn.Option.ABSENT),(id,pE))
d2458 1
a2458 1
  (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref Absyn.Option.ABSENT),e))
d2463 1
a2463 1
             fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
d2668 1
a2668 1
  CONDESC([(con,Absyn.Option.PRESENT ty)],make_pVE con,tyvars)
d2670 1
a2670 1
  CONDESC([(con,Absyn.Option.ABSENT)],make_pVE con,Set.empty_set)
d2687 1
a2687 1
  EXDESC1(excon,Absyn.Option.PRESENT ty,marks_of opts)
d2689 1
a2689 1
  EXDESC1(excon,Absyn.Option.ABSENT,marks_of opts)
d2778 1
a2778 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.Option.PRESENT sigexp',make_funbind_info(opts,funid),ref false,marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr)) else Absyn.Option.ABSENT,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT)) else Absyn.Option.ABSENT),funid,pE''))
d2784 1
a2784 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.Option.ABSENT,make_funbind_info (opts,funid),ref false,marks_of opts,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.nullDebuggerStr)) else Absyn.Option.ABSENT,if generate_moduler opts then Absyn.Option.PRESENT(ref(Absyn.Option.ABSENT)) else Absyn.Option.ABSENT),funid,pE'''))
d2790 1
a2790 1
(set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.Option.PRESENT sigexp,strexp,pE''))
d2796 1
a2796 1
(set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.Option.ABSENT,strexp,pE'''))
@


1.67
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a209 1
require "../basics/module_id";
a223 1
  structure ModuleId : MODULE_ID
a227 3
  sharing type ModuleId.ModuleId = Derived.Absyn.ModuleId
  sharing type ModuleId.Symbol = Derived.Absyn.Ident.Symbol.Symbol
  sharing type Derived.Info.Location.T = ModuleId.Location
d2840 1
a2840 1
          fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
@


1.66
log
@Improving error message for fun nil x = x;
@
text
@d4 3
d1180 1
a1180 1
          fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1820 1
a1820 1
          fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
@


1.65
log
@Add location info to wild pats
@
text
@d4 3
d429 13
d529 1
d1172 1
a1172 1
       fn ([dec],opts) => dec
d1177 1
a1177 1
       fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1182 1
a1182 1
       fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1190 1
a1190 1
       fn ([_],opts) =>
d1197 1
a1197 1
       fn ([_,_],opts) => 
d1204 1
a1204 1
       fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1209 1
a1209 1
       fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1214 1
a1214 1
     fn ([_,LAB lab],opts) =>
d1219 1
a1219 1
       fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1223 1
a1223 1
       fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1228 1
a1228 1
       fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1233 1
a1233 1
       fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1238 1
a1238 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1243 1
a1243 1
       fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1248 1
a1248 1
       fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1254 1
a1254 1
       fn ([_,x,_],opts) => x
d1259 1
a1259 1
       fn ([_],opts) => ENV (get_current_pE())
d1264 1
a1264 1
       fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1269 1
a1269 1
       fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1274 1
a1274 1
       fn ([],opts) => EXPLIST ([],Set.empty_set)
d1279 1
a1279 1
       fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1284 1
a1284 1
       fn ([exp],opts) => exp
d1289 1
a1289 1
       fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1295 1
a1295 1
       fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1300 1
a1300 1
       fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1306 1
a1306 1
       fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1311 1
a1311 1
       fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1317 1
a1317 1
       fn ([x],opts) => x
d1322 1
a1322 1
       fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1328 1
a1328 1
       fn ([x],opts) => x
d1333 1
a1333 1
       fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1339 1
a1339 1
       fn ([x],opts) => x
d1344 1
a1344 1
       fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1349 1
a1349 1
       fn ([x],opts) => x
d1354 1
a1354 1
       fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1360 1
a1360 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1366 1
a1366 1
     fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1372 1
a1372 1
       fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1378 1
a1378 1
       fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1384 1
a1384 1
       fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1390 1
a1390 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1396 1
a1396 1
       fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1402 1
a1402 1
       fn ([_,MATCH (match,tyvars)],opts) =>
d1408 1
a1408 1
       fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1413 1
a1413 1
       fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1419 1
a1419 1
      fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1424 1
a1424 1
       fn ([_,_],opts) => DUMMY
d1429 1
a1429 1
       fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1434 1
a1434 1
       fn ([_,dec,_],opts) => dec
d1439 1
a1439 1
       fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1444 1
a1444 1
       fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1449 1
a1449 1
       fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1458 1
a1458 1
       fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1464 1
a1464 1
     fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1471 1
a1471 1
       fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1478 1
a1478 1
       fn ([_,DATBIND (d,pVE)],opts) => 
d1484 1
a1484 1
       fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1494 1
a1494 1
       fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1500 1
a1500 1
       fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1507 1
a1507 1
       fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1512 1
a1512 1
       fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1518 1
a1518 1
       fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1527 1
a1527 1
       fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1535 1
a1535 1
       fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1540 1
a1540 1
       fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1545 1
a1545 1
       fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1550 1
a1550 1
       fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1555 1
a1555 1
       fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1562 1
a1562 1
       fn ([_],opts) => ENV (get_current_pE())
d1567 1
a1567 1
       fn ([x],opts) => x
d1572 1
a1572 1
       fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1578 1
a1578 1
       fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1584 1
a1584 1
       fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1590 1
a1590 1
       fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1598 1
a1598 1
       fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1604 1
a1604 1
       fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1610 1
a1610 1
       fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1616 1
a1616 1
       fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1622 1
a1622 1
      fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1630 1
a1630 1
       fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1636 32
d1670 1
a1670 1
       fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1674 1
a1674 1
 | _ => raise ActionError 80,
d1678 1
a1678 1
       fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1682 1
a1682 1
 | _ => raise ActionError 81,
d1686 2
a1687 2
       fn ([],opts) => NULLTYPE
 | _ => raise ActionError 82,
d1691 2
a1692 2
       fn ([_,ty],opts) => ty
 | _ => raise ActionError 83,
d1696 2
a1697 2
       fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
 | _ => raise ActionError 84,
d1701 1
a1701 1
       fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1703 1
a1703 1
 | _ => raise ActionError 85,
d1707 1
a1707 1
       fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1710 1
a1710 1
 | _ => raise ActionError 86,
d1714 2
a1715 2
       fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 87,
d1719 2
a1720 2
       fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 88,
d1724 2
a1725 2
       fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 89,
d1729 2
a1730 2
       fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 90,
d1734 2
a1735 2
       fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 91,
d1739 2
a1740 2
       fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
 | _ => raise ActionError 92,
d1744 1
a1744 1
       fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1746 1
a1746 1
 | _ => raise ActionError 93,
d1750 1
a1750 1
       fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1754 1
a1754 1
 | _ => raise ActionError 94,
d1758 2
a1759 2
       fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 95,
d1763 1
a1763 1
       fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1765 1
a1765 1
 | _ => raise ActionError 96,
d1769 1
a1769 1
          fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1771 1
a1771 1
 | _ => raise ActionError 97,
d1775 2
a1776 2
       fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 98,
d1780 1
a1780 1
       fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1782 1
a1782 1
 | _ => raise ActionError 99,
d1786 1
a1786 1
          fn ([VALID id, TY (ty,tyvars)],opts) => 
d1790 1
a1790 1
 | _ => raise ActionError 100,
d1794 1
a1794 1
       fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1797 1
a1797 1
 | _ => raise ActionError 101,
d1801 2
a1802 2
       fn ([],opts) => NULLTYPE
 | _ => raise ActionError 102,
d1806 2
a1807 2
       fn ([_,x],opts) => x
 | _ => raise ActionError 103,
d1811 1
a1811 1
       fn ([_],opts as OPTS(location,options,_)) =>
d1813 1
a1813 1
 | _ => raise ActionError 104,
d1817 2
a1818 2
       fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 105,
d1824 1
a1824 1
         fn ([VALID id],opts) => 
d1826 1
a1826 1
 | _ => raise ActionError 106,
d1830 1
a1830 1
       fn ([LONGVALID (id,strname_opt)],opts) => 
d1833 1
a1833 1
 | _ => raise ActionError 107,
d1837 1
a1837 1
       fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1839 1
a1839 1
 | _ => raise ActionError 108,
d1843 1
a1843 1
       fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1845 1
a1845 1
 | _ => raise ActionError 109,
d1849 1
a1849 1
       fn ([_,_,_],opts) => 
d1851 1
a1851 1
 | _ => raise ActionError 110,
d1855 2
a1856 2
       fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 111,
d1860 2
a1861 2
       fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 112,
d1865 2
a1866 2
       fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 113,
d1870 2
a1871 2
       fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 114,
d1875 2
a1876 2
       fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 115,
d1880 2
a1881 2
       fn ([_,x,_],opts) => x
 | _ => raise ActionError 116,
d1885 2
a1886 2
       fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 117,
d1890 1
a1890 1
       fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1892 1
a1892 1
 | _ => raise ActionError 118,
d1896 1
a1896 1
       fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1899 1
a1899 1
 | _ => raise ActionError 119,
d1903 2
a1904 2
       fn ([x],opts) => x
 | _ => raise ActionError 120,
d1908 1
a1908 1
       fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1910 1
a1910 1
 | _ => raise ActionError 121,
d1914 1
a1914 1
       fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1916 1
a1916 1
 | _ => raise ActionError 122,
d1920 2
a1921 2
       fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 123,
d1925 1
a1925 1
       fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1928 1
a1928 1
 | _ => raise ActionError 124,
d1932 2
a1933 2
       fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 125,
d1937 1
a1937 1
       fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1943 1
a1943 1
 | _ => raise ActionError 126,
d1947 1
a1947 1
       fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1953 1
a1953 1
 | _ => raise ActionError 127,
d1957 2
a1958 2
       fn ([x],opts) => x
 | _ => raise ActionError 128,
d1962 1
a1962 1
        fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d1965 1
a1965 1
 | _ => raise ActionError 129,
d1970 1
a1970 1
       fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1973 1
a1973 1
 | _ => raise ActionError 130,
d1977 1
a1977 1
       fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d1980 1
a1980 1
 | _ => raise ActionError 131,
d1984 2
a1985 2
       fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 132,
d1989 1
a1989 1
         fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1993 1
a1993 1
 | _ => raise ActionError 133,
d1999 2
a2000 2
       fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 134,
d2004 2
a2005 2
       fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 135,
d2009 2
a2010 2
       fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 136,
d2014 2
a2015 2
       fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
 | _ => raise ActionError 137,
d2019 2
a2020 2
       fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
 | _ => raise ActionError 138,
d2024 2
a2025 2
       fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
 | _ => raise ActionError 139,
d2029 2
a2030 2
       fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 140,
d2034 2
a2035 2
       fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 141,
d2039 2
a2040 2
       fn ([_,t,_],opts) => t
 | _ => raise ActionError 142,
d2044 2
a2045 2
       fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 143,
d2049 2
a2050 2
       fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 144,
d2054 2
a2055 2
       fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 145,
d2059 2
a2060 2
       fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 146,
d2064 2
a2065 2
       fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 147,
d2069 2
a2070 2
       fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 148,
d2074 1
a2074 1
       fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2076 1
a2076 1
 | _ => raise ActionError 149,
d2082 2
a2083 2
       fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 150,
d2087 1
a2087 1
       fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2089 1
a2089 1
 | _ => raise ActionError 151,
d2095 2
a2096 2
       fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 152,
d2100 2
a2101 2
       fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 153,
d2107 2
a2108 2
       fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 154,
d2112 2
a2113 2
       fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 155,
d2119 2
a2120 2
       fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 156,
d2124 2
a2125 2
       fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 157,
d2131 2
a2132 2
       fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
 | _ => raise ActionError 158,
d2136 2
a2137 2
       fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
 | _ => raise ActionError 159,
d2141 2
a2142 2
       fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 160,
d2146 2
a2147 2
       fn ([CHAR s],opts) => SCON (Ident.CHAR s)
 | _ => raise ActionError 161,
d2151 2
a2152 2
       fn ([WORD s],opts) => SCON (Ident.WORD(s, marks_of opts))
 | _ => raise ActionError 162,
d2158 1
a2158 1
       fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2161 1
a2161 1
 | _ => raise ActionError 163,
d2165 2
a2166 2
       fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 164,
d2172 2
a2173 2
       fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 165,
d2177 2
a2178 2
       fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 166,
d2182 2
a2183 2
       fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 167,
d2187 2
a2188 2
       fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 168,
d2192 2
a2193 2
       fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 169,
d2199 1
a2199 1
       fn ([LONGID ([],s)],opts) => SYM s
d2202 1
a2202 1
 | _ => raise ActionError 170,
d2206 2
a2207 2
       fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 171,
d2212 1
a2212 1
       fn ([LONGID ([],s)],opts) => SYM s
d2215 1
a2215 1
 | _ => raise ActionError 172,
d2219 2
a2220 2
       fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 173,
d2224 2
a2225 2
       fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 174,
d2229 2
a2230 2
       fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 175,
d2238 1
a2238 1
       fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2240 1
a2240 1
 | _ => raise ActionError 176,
d2246 1
a2246 1
       fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2248 1
a2248 1
 | _ => raise ActionError 177,
d2252 2
a2253 2
       fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 178,
d2257 2
a2258 2
       fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 179,
d2263 1
a2263 1
       fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2265 1
a2265 1
 | _ => raise ActionError 180,
d2269 1
a2269 1
       fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2271 1
a2271 1
 | _ => raise ActionError 181,
d2275 2
a2276 2
       fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 182,
d2280 2
a2281 2
       fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 183,
d2285 1
a2285 1
       fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2287 1
a2287 1
 | _ => raise ActionError 184,
d2291 2
a2292 2
       fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 185,
d2296 2
a2297 2
       fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 186,
d2301 1
a2301 1
       fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2303 1
a2303 1
 | _ => raise ActionError 187,
d2307 2
a2308 2
       fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 188,
d2314 2
a2315 2
       fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 189,
d2319 1
a2319 1
       fn ([LONGID x],opts) =>
d2323 1
a2323 1
 | _ => raise ActionError 190,
d2327 1
a2327 1
       fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2329 1
a2329 1
 | _ => raise ActionError 191,
d2333 1
a2333 1
       fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2335 1
a2335 1
 | _ => raise ActionError 192,
d2339 1
a2339 1
       fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2341 1
a2341 1
 | _ => raise ActionError 193,
d2345 2
a2346 2
       fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 194,
d2350 2
a2351 2
       fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 195,
d2355 2
a2356 2
       fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 196,
d2360 2
a2361 2
       fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 197,
d2365 2
a2366 2
       fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 198,
d2370 2
a2371 2
       fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 199,
d2377 2
a2378 2
       fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 200,
d2382 2
a2383 2
       fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 201,
d2387 1
a2387 1
       fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2389 1
a2389 1
 | _ => raise ActionError 202,
d2393 1
a2393 1
       fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2395 1
a2395 1
 | _ => raise ActionError 203,
d2401 2
a2402 2
       fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 204,
d2406 1
a2406 1
       fn ([_,STRBIND(l,pSE)],opts) => 
d2408 1
a2408 1
 | _ => raise ActionError 205,
d2412 1
a2412 1
       fn ([_,STRBIND(l,pSE)],opts) => 
d2414 1
a2414 1
 | _ => raise ActionError 206,
d2418 1
a2418 1
       fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2420 1
a2420 1
 | _ => raise ActionError 207,
d2424 2
a2425 2
       fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 208,
d2429 1
a2429 1
       fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2431 1
a2431 1
 | _ => raise ActionError 209,
d2435 1
a2435 1
      fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2440 1
a2440 1
 | _ => raise ActionError 210,
d2444 1
a2444 1
      fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2449 1
a2449 1
 | _ => raise ActionError 211,
d2453 1
a2453 1
          fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2455 1
a2455 1
 | _ => raise ActionError 212,
d2459 2
a2460 2
          fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 213,
d2464 2
a2465 2
       fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 214,
d2469 2
a2470 2
       fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 215,
d2474 2
a2475 2
       fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 216,
d2479 2
a2480 2
       fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 217,
d2484 2
a2485 2
       fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 218,
d2489 1
a2489 1
       fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2491 1
a2491 1
 | _ => raise ActionError 219,
d2495 2
a2496 2
       fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 220,
d2500 2
a2501 2
       fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 221,
d2505 2
a2506 2
       fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 222,
d2510 1
a2510 1
       fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2512 1
a2512 1
 | _ => raise ActionError 223,
d2516 1
a2516 1
       fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2518 1
a2518 1
 | _ => raise ActionError 224,
d2524 2
a2525 2
       fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 225,
d2529 2
a2530 2
       fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 226,
d2534 2
a2535 2
       fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 227,
d2539 2
a2540 2
       fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 228,
d2544 2
a2545 2
       fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 229,
d2549 2
a2550 2
       fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 230,
d2554 2
a2555 2
       fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 231,
d2559 1
a2559 1
       fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2561 1
a2561 1
 | _ => raise ActionError 232,
d2565 2
a2566 2
       fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 233,
d2570 2
a2571 2
       fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 234,
d2576 2
a2577 2
         fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 235,
d2581 2
a2582 2
         fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 236,
d2586 2
a2587 2
         fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 237,
d2591 2
a2592 2
         fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 238,
d2596 2
a2597 2
       fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 239,
d2601 2
a2602 2
       fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 240,
d2606 2
a2607 2
       fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 241,
d2611 1
a2611 1
       fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2613 1
a2613 1
 | _ => raise ActionError 242,
d2617 2
a2618 2
       fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 243,
d2622 1
a2622 1
       fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2624 1
a2624 1
 | _ => raise ActionError 244,
d2628 2
a2629 2
       fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 245,
d2634 2
a2635 2
       fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 246,
d2639 1
a2639 1
       fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2641 1
a2641 1
 | _ => raise ActionError 247,
d2645 1
a2645 1
       fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2648 1
a2648 1
 | _ => raise ActionError 248,
d2652 2
a2653 2
       fn ([x],opts) => x
 | _ => raise ActionError 249,
d2657 1
a2657 1
       fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2659 1
a2659 1
 | _ => raise ActionError 250,
d2663 1
a2663 1
          fn ([VALID con,TY(ty,tyvars)],opts) => 
d2667 1
a2667 1
 | _ => raise ActionError 251,
d2671 2
a2672 2
       fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 252,
d2676 1
a2676 1
       fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2678 1
a2678 1
 | _ => raise ActionError 253,
d2682 1
a2682 1
          fn ([VALID excon,TY(ty,_)],opts) => 
d2686 1
a2686 1
 | _ => raise ActionError 254,
d2690 2
a2691 2
       fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 255,
d2695 1
a2695 1
       fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2697 1
a2697 1
 | _ => raise ActionError 256,
d2701 2
a2702 2
       fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 257,
d2706 2
a2707 2
       fn ([x],opts) => x
 | _ => raise ActionError 258,
d2711 2
a2712 2
       fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 259,
d2716 2
a2717 2
       fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 260,
d2721 2
a2722 2
       fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 261,
d2726 2
a2727 2
       fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 262,
d2731 2
a2732 2
       fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 263,
d2736 2
a2737 2
       fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 264,
d2741 2
a2742 2
       fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 265,
d2746 2
a2747 2
       fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 266,
d2751 2
a2752 2
       fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 267,
d2756 2
a2757 2
       fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 268,
d2761 1
a2761 1
       fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2763 1
a2763 1
 | _ => raise ActionError 269,
d2767 1
a2767 1
       fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2769 1
a2769 1
 | _ => raise ActionError 270,
d2773 1
a2773 1
      fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2775 1
a2775 1
 | _ => raise ActionError 271,
d2779 1
a2779 1
      fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2781 1
a2781 1
 | _ => raise ActionError 272,
d2785 1
a2785 1
          fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2787 1
a2787 1
 | _ => raise ActionError 273,
d2791 1
a2791 1
          fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2793 1
a2793 1
 | _ => raise ActionError 274,
d2797 1
a2797 1
       fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2799 1
a2799 1
 | _ => raise ActionError 275,
d2803 1
a2803 1
       fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2805 1
a2805 1
 | _ => raise ActionError 276,
d2809 2
a2810 2
       fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 277,
d2818 2
a2819 2
       fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 278,
d2823 2
a2824 2
       fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 279,
d2828 2
a2829 2
       fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 280,
d2833 1
a2833 1
       fn ([EXP(exp,tyvars)],opts) =>
d2835 1
a2835 1
 | _ => raise ActionError 281,
d2839 2
a2840 2
       fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 282,
d2844 2
a2845 2
       fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 283,
d2849 2
a2850 2
       fn ([x,_,_],opts) => x
 | _ => raise ActionError 284,
d2854 2
a2855 2
       fn ([_,x],opts) => x
 | _ => raise ActionError 285,
d2859 2
a2860 2
       fn ([x,_],opts) => x
 | _ => raise ActionError 286,
d2864 2
a2865 2
       fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 287,
d2871 2
a2872 2
       fn ([],opts) => DUMMY
 | _ => raise ActionError 288,
@


1.64
log
@Disallowing = as a strid etc.
@
text
@d4 3
d866 1
a866 1
fun is_con_pat(Absyn.WILDpat) = false
d1762 2
a1763 1
       fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
@


1.63
log
@Adding literal words
@
text
@d4 3
a1137 4




d1152 1
a1152 1
      fn ([dec],opts) => dec
d1157 1
a1157 1
      fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1162 1
a1162 1
      fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1170 1
a1170 1
      fn ([_],opts) =>
d1177 1
a1177 1
      fn ([_,_],opts) => 
d1184 1
a1184 1
      fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1189 1
a1189 1
      fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1194 1
a1194 1
    fn ([_,LAB lab],opts) =>
d1198 2
a1199 2
(* 	((ATEXP :magicopen EXP :magicclose)) *)
      fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1202 2
a1203 2
(* 	((ATEXP :magicopen :type EXP :colon TY :magicclose)) *)
      fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1208 1
a1208 1
      fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1213 1
a1213 1
      fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1218 1
a1218 1
    fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1223 1
a1223 1
      fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1228 1
a1228 1
      fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1234 1
a1234 1
      fn ([_,x,_],opts) => x
d1239 1
a1239 1
      fn ([_],opts) => ENV (get_current_pE())
d1244 1
a1244 1
      fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1249 1
a1249 1
      fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1254 1
a1254 1
      fn ([],opts) => EXPLIST ([],Set.empty_set)
d1259 1
a1259 1
      fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1264 1
a1264 1
      fn ([exp],opts) => exp
d1269 1
a1269 1
      fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1275 1
a1275 1
      fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1280 1
a1280 1
      fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1286 1
a1286 1
      fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1291 1
a1291 1
      fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1297 1
a1297 1
      fn ([x],opts) => x
d1302 1
a1302 1
      fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1308 1
a1308 1
      fn ([x],opts) => x
d1313 1
a1313 1
      fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1319 1
a1319 1
      fn ([x],opts) => x
d1324 1
a1324 1
      fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1329 1
a1329 1
      fn ([x],opts) => x
d1334 1
a1334 1
      fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1340 1
a1340 1
    fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1346 1
a1346 1
    fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1352 1
a1352 1
      fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1358 1
a1358 1
      fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1364 1
a1364 1
      fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1370 1
a1370 1
    fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1376 1
a1376 1
      fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1382 1
a1382 1
      fn ([_,MATCH (match,tyvars)],opts) =>
d1388 1
a1388 1
      fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1393 1
a1393 1
      fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1399 1
a1399 1
     fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1404 1
a1404 1
      fn ([_,_],opts) => DUMMY
d1409 1
a1409 1
      fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1414 1
a1414 1
      fn ([_,dec,_],opts) => dec
d1419 1
a1419 1
      fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1424 1
a1424 1
      fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1429 1
a1429 1
      fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1438 1
a1438 1
      fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1444 1
a1444 1
    fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1451 1
a1451 1
      fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1458 1
a1458 1
      fn ([_,DATBIND (d,pVE)],opts) => 
d1464 1
a1464 1
      fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1474 1
a1474 1
      fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1480 1
a1480 1
      fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1487 1
a1487 1
      fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1492 1
a1492 1
      fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1498 1
a1498 1
      fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1507 1
a1507 1
      fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1515 1
a1515 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1520 1
a1520 1
      fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1525 1
a1525 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1530 1
a1530 1
      fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1535 1
a1535 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1542 1
a1542 1
      fn ([_],opts) => ENV (get_current_pE())
d1547 1
a1547 1
      fn ([x],opts) => x
d1552 1
a1552 1
      fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1558 1
a1558 1
      fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1564 1
a1564 1
      fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1570 1
a1570 1
      fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1578 1
a1578 1
      fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1584 1
a1584 1
      fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1590 1
a1590 1
      fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1596 1
a1596 1
      fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1602 1
a1602 1
     fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1610 1
a1610 1
      fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1618 1
a1618 1
      fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1626 1
a1626 1
      fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1634 1
a1634 1
      fn ([],opts) => NULLTYPE
d1639 1
a1639 1
      fn ([_,ty],opts) => ty
d1644 1
a1644 1
      fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1649 1
a1649 1
      fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1655 1
a1655 1
      fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1662 1
a1662 1
      fn ([],opts) => TYVARLIST []
d1667 1
a1667 1
      fn ([TYVAR t],opts) => TYVARLIST [t]
d1672 1
a1672 1
      fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1677 1
a1677 1
      fn ([TYVAR t],opts) => TYVARLIST [t]
d1682 1
a1682 1
      fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1687 1
a1687 1
      fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1692 1
a1692 1
      fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1698 1
a1698 1
      fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1706 1
a1706 1
      fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1711 1
a1711 1
      fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1717 1
a1717 1
         fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1723 1
a1723 1
      fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1728 1
a1728 1
      fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1734 1
a1734 1
         fn ([VALID id, TY (ty,tyvars)],opts) => 
d1742 1
a1742 1
      fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1749 1
a1749 1
      fn ([],opts) => NULLTYPE
d1754 1
a1754 1
      fn ([_,x],opts) => x
d1759 1
a1759 1
      fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1764 1
a1764 1
      fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1771 1
a1771 1
        fn ([VALID id],opts) => 
d1777 1
a1777 1
      fn ([LONGVALID (id,strname_opt)],opts) => 
d1784 1
a1784 1
      fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1790 1
a1790 1
      fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1796 1
a1796 1
      fn ([_,_,_],opts) => 
d1802 1
a1802 1
      fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1807 1
a1807 1
      fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1812 1
a1812 1
      fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1817 1
a1817 1
      fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1822 1
a1822 1
      fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1827 1
a1827 1
      fn ([_,x,_],opts) => x
d1832 1
a1832 1
      fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1837 1
a1837 1
      fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1843 1
a1843 1
      fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1850 1
a1850 1
      fn ([x],opts) => x
d1855 1
a1855 1
      fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1861 1
a1861 1
      fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1867 1
a1867 1
      fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1872 1
a1872 1
      fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1879 1
a1879 1
      fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1882 1
a1882 1
(* 	((PATROW1 SYM OPTTYPE))  *)
d1884 1
a1884 1
      fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1892 1
a1892 1
(* 	((PATROW1 SYM OPTTYPE :as PAT))  *)
d1894 1
a1894 1
      fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1904 1
a1904 1
      fn ([x],opts) => x
d1909 1
a1909 1
       fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d1917 1
a1917 1
      fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1924 1
a1924 1
      fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d1931 1
a1931 1
      fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1936 1
a1936 1
        fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1946 1
a1946 1
      fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1951 1
a1951 1
      fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1956 1
a1956 1
      fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1961 1
a1961 1
      fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1966 1
a1966 1
      fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1971 1
a1971 1
      fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1976 1
a1976 1
      fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1981 1
a1981 1
      fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1986 1
a1986 1
      fn ([_,t,_],opts) => t
d1991 1
a1991 1
      fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1996 1
a1996 1
      fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2001 1
a2001 1
      fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2006 1
a2006 1
      fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2011 1
a2011 1
      fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2016 1
a2016 1
      fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2021 1
a2021 1
      fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2029 1
a2029 1
      fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2034 1
a2034 1
      fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2042 1
a2042 1
      fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2047 1
a2047 1
      fn ([LONGID id],opts) => LONGIDLIST[id]
d2054 1
a2054 1
      fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2059 1
a2059 1
      fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2066 1
a2066 1
      fn ([SYM sym],opts) => SYMLIST [sym]
d2071 1
a2071 1
      fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2078 1
a2078 1
      fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d2083 1
a2083 1
      fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d2088 1
a2088 1
      fn ([STRING s],opts) => SCON (Ident.STRING s)
d2093 1
a2093 1
      fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2098 1
a2098 1
      fn ([WORD s],opts) => SCON (Ident.WORD(s, marks_of opts))
d2105 1
a2105 1
      fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2112 1
a2112 1
      fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d2119 1
a2119 1
      fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d2124 1
a2124 1
      fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
d2129 1
a2129 1
      fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
d2134 1
a2134 1
      fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d2139 1
a2139 1
      fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d2146 1
a2146 1
      fn ([LONGID ([],s)],opts) => SYM s
d2153 1
a2153 1
      fn ([_],opts) => SYM equal_symbol
a2155 1
(* 	((FUNID SYM))  *)
d2157 5
a2161 1
      fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d2164 1
a2164 1
(* 	((SIGID SYM))  *)
d2166 1
a2166 1
      fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2169 1
a2169 1
(* 	((STRID SYM))  *)
d2171 1
a2171 1
      fn ([SYM s],opts) => STRID(Ident.STRID s)
d2174 5
d2185 1
a2185 1
      fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2187 1
a2187 1
 | _ => raise ActionError 175,
d2193 1
a2193 1
      fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2195 1
a2195 1
 | _ => raise ActionError 176,
d2199 2
a2200 2
      fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 177,
d2204 2
a2205 2
      fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 178,
d2210 1
a2210 1
      fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2212 1
a2212 1
 | _ => raise ActionError 179,
d2216 1
a2216 1
      fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2218 1
a2218 1
 | _ => raise ActionError 180,
d2222 2
a2223 2
      fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 181,
d2227 2
a2228 2
      fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 182,
d2232 1
a2232 1
      fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2234 1
a2234 1
 | _ => raise ActionError 183,
d2238 2
a2239 2
      fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 184,
d2243 2
a2244 2
      fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 185,
d2248 1
a2248 1
      fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2250 1
a2250 1
 | _ => raise ActionError 186,
d2254 2
a2255 2
      fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 187,
d2261 2
a2262 2
      fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 188,
d2266 1
a2266 1
      fn ([LONGID x],opts) =>
d2270 1
a2270 1
 | _ => raise ActionError 189,
d2274 1
a2274 1
      fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2276 1
a2276 1
 | _ => raise ActionError 190,
d2280 1
a2280 1
      fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2282 1
a2282 1
 | _ => raise ActionError 191,
d2286 1
a2286 1
      fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2288 1
a2288 1
 | _ => raise ActionError 192,
d2292 2
a2293 2
      fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 193,
d2297 2
a2298 2
      fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 194,
d2302 2
a2303 2
      fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 195,
d2307 2
a2308 2
      fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 196,
d2312 2
a2313 2
      fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 197,
d2317 2
a2318 2
      fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 198,
d2324 2
a2325 2
      fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 199,
d2329 2
a2330 2
      fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 200,
d2334 1
a2334 1
      fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2336 1
a2336 1
 | _ => raise ActionError 201,
d2340 1
a2340 1
      fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2342 1
a2342 1
 | _ => raise ActionError 202,
d2348 2
a2349 2
      fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 203,
d2353 1
a2353 1
      fn ([_,STRBIND(l,pSE)],opts) => 
d2355 1
a2355 1
 | _ => raise ActionError 204,
d2359 1
a2359 1
      fn ([_,STRBIND(l,pSE)],opts) => 
d2361 1
a2361 1
 | _ => raise ActionError 205,
d2365 1
a2365 1
      fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2367 1
a2367 1
 | _ => raise ActionError 206,
d2371 2
a2372 2
      fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 207,
d2376 1
a2376 1
      fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2378 1
a2378 1
 | _ => raise ActionError 208,
d2382 1
a2382 1
     fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2387 1
a2387 1
 | _ => raise ActionError 209,
d2391 1
a2391 1
     fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2396 1
a2396 1
 | _ => raise ActionError 210,
d2400 1
a2400 1
         fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2402 1
a2402 1
 | _ => raise ActionError 211,
d2406 2
a2407 2
         fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 212,
d2411 2
a2412 2
      fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 213,
d2416 2
a2417 2
      fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 214,
d2421 2
a2422 2
      fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 215,
d2426 2
a2427 2
      fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 216,
d2431 2
a2432 2
      fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 217,
d2436 1
a2436 1
      fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2438 1
a2438 1
 | _ => raise ActionError 218,
d2442 2
a2443 2
      fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 219,
d2447 2
a2448 2
      fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 220,
d2452 2
a2453 2
      fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 221,
d2457 1
a2457 1
      fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2459 1
a2459 1
 | _ => raise ActionError 222,
d2463 1
a2463 1
      fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2465 1
a2465 1
 | _ => raise ActionError 223,
d2471 2
a2472 2
      fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 224,
d2476 2
a2477 2
      fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 225,
d2481 2
a2482 2
      fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 226,
d2486 2
a2487 2
      fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 227,
d2491 2
a2492 2
      fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 228,
d2496 2
a2497 2
      fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 229,
d2501 2
a2502 2
      fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 230,
d2506 1
a2506 1
      fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2508 1
a2508 1
 | _ => raise ActionError 231,
d2512 2
a2513 2
      fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 232,
d2517 2
a2518 2
      fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 233,
d2523 2
a2524 2
        fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 234,
d2528 2
a2529 2
        fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 235,
d2533 2
a2534 2
        fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 236,
d2538 2
a2539 2
        fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 237,
d2543 2
a2544 2
      fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 238,
d2548 2
a2549 2
      fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 239,
d2553 2
a2554 2
      fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 240,
d2558 1
a2558 1
      fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2560 1
a2560 1
 | _ => raise ActionError 241,
d2564 2
a2565 2
      fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 242,
d2569 1
a2569 1
      fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2571 1
a2571 1
 | _ => raise ActionError 243,
d2575 2
a2576 2
      fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 244,
d2581 2
a2582 2
      fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 245,
d2586 1
a2586 1
      fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2588 1
a2588 1
 | _ => raise ActionError 246,
d2592 1
a2592 1
      fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2595 1
a2595 1
 | _ => raise ActionError 247,
d2599 2
a2600 2
      fn ([x],opts) => x
 | _ => raise ActionError 248,
d2604 1
a2604 1
      fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2606 1
a2606 1
 | _ => raise ActionError 249,
d2610 1
a2610 1
         fn ([VALID con,TY(ty,tyvars)],opts) => 
d2614 1
a2614 1
 | _ => raise ActionError 250,
d2618 2
a2619 2
      fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 251,
d2623 1
a2623 1
      fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2625 1
a2625 1
 | _ => raise ActionError 252,
d2629 1
a2629 1
         fn ([VALID excon,TY(ty,_)],opts) => 
d2633 1
a2633 1
 | _ => raise ActionError 253,
d2637 2
a2638 2
      fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 254,
d2642 1
a2642 1
      fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2644 1
a2644 1
 | _ => raise ActionError 255,
d2648 2
a2649 2
      fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 256,
d2653 2
a2654 2
      fn ([x],opts) => x
 | _ => raise ActionError 257,
d2658 2
a2659 2
      fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 258,
d2663 2
a2664 2
      fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 259,
d2668 2
a2669 2
      fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 260,
d2673 2
a2674 2
      fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 261,
d2678 2
a2679 2
      fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 262,
d2683 2
a2684 2
      fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 263,
d2688 2
a2689 2
      fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 264,
d2693 2
a2694 2
      fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 265,
d2698 2
a2699 2
      fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 266,
d2703 2
a2704 2
      fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 267,
d2708 1
a2708 1
      fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2710 1
a2710 1
 | _ => raise ActionError 268,
d2714 1
a2714 1
      fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2716 1
a2716 1
 | _ => raise ActionError 269,
d2720 1
a2720 1
     fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2722 1
a2722 1
 | _ => raise ActionError 270,
d2726 1
a2726 1
     fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2728 1
a2728 1
 | _ => raise ActionError 271,
d2732 1
a2732 1
         fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2734 1
a2734 1
 | _ => raise ActionError 272,
d2738 1
a2738 1
         fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2740 1
a2740 1
 | _ => raise ActionError 273,
d2744 1
a2744 1
      fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2746 1
a2746 1
 | _ => raise ActionError 274,
d2750 1
a2750 1
      fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2752 1
a2752 1
 | _ => raise ActionError 275,
d2756 2
a2757 2
      fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 276,
d2765 2
a2766 2
      fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 277,
d2770 2
a2771 2
      fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 278,
d2775 2
a2776 2
      fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 279,
d2780 1
a2780 1
      fn ([EXP(exp,tyvars)],opts) =>
d2782 1
a2782 1
 | _ => raise ActionError 280,
d2786 2
a2787 2
      fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 281,
d2791 2
a2792 2
      fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 282,
d2796 2
a2797 2
      fn ([x,_,_],opts) => x
 | _ => raise ActionError 283,
d2801 2
a2802 2
      fn ([_,x],opts) => x
 | _ => raise ActionError 284,
d2806 2
a2807 2
      fn ([x,_],opts) => x
 | _ => raise ActionError 285,
d2811 2
a2812 2
      fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 286,
d2818 2
a2819 2
      fn ([],opts) => DUMMY
 | _ => raise ActionError 287,
d3164 1
a3164 2
         | Token.MAGICOPEN =>  (LRbasics.MAGICOPEN,DUMMY)
         | Token.MAGICCLOSE =>  (LRbasics.MAGICCLOSE,DUMMY))
@


1.62
log
@Adding CHAR to grammar
@
text
@d4 3
d282 1
d430 1
d1138 1
d1153 1
a1153 1
     fn ([dec],opts) => dec
d1158 1
a1158 1
     fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1163 1
a1163 1
     fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1171 1
a1171 1
     fn ([_],opts) =>
d1178 1
a1178 1
     fn ([_,_],opts) => 
d1185 1
a1185 1
     fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1190 1
a1190 1
     fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1195 1
a1195 1
   fn ([_,LAB lab],opts) =>
d1200 1
a1200 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1204 1
a1204 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1209 1
a1209 1
     fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1214 1
a1214 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1219 1
a1219 1
   fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1224 1
a1224 1
     fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1229 1
a1229 1
     fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1235 1
a1235 1
     fn ([_,x,_],opts) => x
d1240 1
a1240 1
     fn ([_],opts) => ENV (get_current_pE())
d1245 1
a1245 1
     fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1250 1
a1250 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1255 1
a1255 1
     fn ([],opts) => EXPLIST ([],Set.empty_set)
d1260 1
a1260 1
     fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1265 1
a1265 1
     fn ([exp],opts) => exp
d1270 1
a1270 1
     fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1276 1
a1276 1
     fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1281 1
a1281 1
     fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1287 1
a1287 1
     fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1292 1
a1292 1
     fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1298 1
a1298 1
     fn ([x],opts) => x
d1303 1
a1303 1
     fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1309 1
a1309 1
     fn ([x],opts) => x
d1314 1
a1314 1
     fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1320 1
a1320 1
     fn ([x],opts) => x
d1325 1
a1325 1
     fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1330 1
a1330 1
     fn ([x],opts) => x
d1335 1
a1335 1
     fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1341 1
a1341 1
   fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1347 1
a1347 1
   fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1353 1
a1353 1
     fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1359 1
a1359 1
     fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1365 1
a1365 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1371 1
a1371 1
   fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1377 1
a1377 1
     fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1383 1
a1383 1
     fn ([_,MATCH (match,tyvars)],opts) =>
d1389 1
a1389 1
     fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1394 1
a1394 1
     fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1400 1
a1400 1
    fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1405 1
a1405 1
     fn ([_,_],opts) => DUMMY
d1410 1
a1410 1
     fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1415 1
a1415 1
     fn ([_,dec,_],opts) => dec
d1420 1
a1420 1
     fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1425 1
a1425 1
     fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1430 1
a1430 1
     fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1439 1
a1439 1
     fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1445 1
a1445 1
   fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1452 1
a1452 1
     fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1459 1
a1459 1
     fn ([_,DATBIND (d,pVE)],opts) => 
d1465 1
a1465 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1475 1
a1475 1
     fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1481 1
a1481 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1488 1
a1488 1
     fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1493 1
a1493 1
     fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1499 1
a1499 1
     fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1508 1
a1508 1
     fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1516 1
a1516 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1521 1
a1521 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1526 1
a1526 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1531 1
a1531 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1536 1
a1536 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1543 1
a1543 1
     fn ([_],opts) => ENV (get_current_pE())
d1548 1
a1548 1
     fn ([x],opts) => x
d1553 1
a1553 1
     fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1559 1
a1559 1
     fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1565 1
a1565 1
     fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1571 1
a1571 1
     fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1579 1
a1579 1
     fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1585 1
a1585 1
     fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1591 1
a1591 1
     fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1597 1
a1597 1
     fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1603 1
a1603 1
    fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1611 1
a1611 1
     fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1619 1
a1619 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1627 1
a1627 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1635 1
a1635 1
     fn ([],opts) => NULLTYPE
d1640 1
a1640 1
     fn ([_,ty],opts) => ty
d1645 1
a1645 1
     fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1650 1
a1650 1
     fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1656 1
a1656 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1663 1
a1663 1
     fn ([],opts) => TYVARLIST []
d1668 1
a1668 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1673 1
a1673 1
     fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1678 1
a1678 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1683 1
a1683 1
     fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1688 1
a1688 1
     fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1693 1
a1693 1
     fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1699 1
a1699 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1707 1
a1707 1
     fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1712 1
a1712 1
     fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1718 1
a1718 1
        fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1724 1
a1724 1
     fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1729 1
a1729 1
     fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1735 1
a1735 1
        fn ([VALID id, TY (ty,tyvars)],opts) => 
d1743 1
a1743 1
     fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1750 1
a1750 1
     fn ([],opts) => NULLTYPE
d1755 1
a1755 1
     fn ([_,x],opts) => x
d1760 1
a1760 1
     fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1765 1
a1765 1
     fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1772 1
a1772 1
       fn ([VALID id],opts) => 
d1778 1
a1778 1
     fn ([LONGVALID (id,strname_opt)],opts) => 
d1785 1
a1785 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1791 1
a1791 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1797 1
a1797 1
     fn ([_,_,_],opts) => 
d1803 1
a1803 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1808 1
a1808 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1813 1
a1813 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1818 1
a1818 1
     fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1823 1
a1823 1
     fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1828 1
a1828 1
     fn ([_,x,_],opts) => x
d1833 1
a1833 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1838 1
a1838 1
     fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1844 1
a1844 1
     fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1851 1
a1851 1
     fn ([x],opts) => x
d1856 1
a1856 1
     fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1862 1
a1862 1
     fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1868 1
a1868 1
     fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1873 1
a1873 1
     fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1880 1
a1880 1
     fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1885 1
a1885 1
     fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1895 1
a1895 1
     fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1905 1
a1905 1
     fn ([x],opts) => x
d1910 1
a1910 1
      fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d1918 1
a1918 1
     fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1925 1
a1925 1
     fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d1932 1
a1932 1
     fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1937 1
a1937 1
       fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1947 1
a1947 1
     fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1952 1
a1952 1
     fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1957 1
a1957 1
     fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1962 1
a1962 1
     fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1967 1
a1967 1
     fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1972 1
a1972 1
     fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1977 1
a1977 1
     fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1982 1
a1982 1
     fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1987 1
a1987 1
     fn ([_,t,_],opts) => t
d1992 1
a1992 1
     fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1997 1
a1997 1
     fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d2002 1
a2002 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2007 1
a2007 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2012 1
a2012 1
     fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2017 1
a2017 1
     fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2022 1
a2022 1
     fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2030 1
a2030 1
     fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2035 1
a2035 1
     fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2043 1
a2043 1
     fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2048 1
a2048 1
     fn ([LONGID id],opts) => LONGIDLIST[id]
d2055 1
a2055 1
     fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2060 1
a2060 1
     fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2067 1
a2067 1
     fn ([SYM sym],opts) => SYMLIST [sym]
d2072 1
a2072 1
     fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2079 1
a2079 1
     fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d2084 1
a2084 1
     fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d2089 1
a2089 1
     fn ([STRING s],opts) => SCON (Ident.STRING s)
d2094 1
a2094 1
     fn ([CHAR s],opts) => SCON (Ident.CHAR s)
d2097 5
d2106 1
a2106 1
     fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2109 1
a2109 1
 | _ => raise ActionError 162,
d2113 2
a2114 2
     fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 163,
d2120 2
a2121 2
     fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 164,
d2125 2
a2126 2
     fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 165,
d2130 2
a2131 2
     fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 166,
d2135 2
a2136 2
     fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 167,
d2140 2
a2141 2
     fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 168,
d2147 1
a2147 1
     fn ([LONGID ([],s)],opts) => SYM s
d2150 1
a2150 1
 | _ => raise ActionError 169,
d2154 2
a2155 2
     fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 170,
d2159 2
a2160 2
     fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 171,
d2164 2
a2165 2
     fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 172,
d2169 2
a2170 2
     fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 173,
d2178 1
a2178 1
     fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2180 1
a2180 1
 | _ => raise ActionError 174,
d2186 1
a2186 1
     fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2188 1
a2188 1
 | _ => raise ActionError 175,
d2192 2
a2193 2
     fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 176,
d2197 2
a2198 2
     fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 177,
d2203 1
a2203 1
     fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2205 1
a2205 1
 | _ => raise ActionError 178,
d2209 1
a2209 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2211 1
a2211 1
 | _ => raise ActionError 179,
d2215 2
a2216 2
     fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 180,
d2220 2
a2221 2
     fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 181,
d2225 1
a2225 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2227 1
a2227 1
 | _ => raise ActionError 182,
d2231 2
a2232 2
     fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 183,
d2236 2
a2237 2
     fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 184,
d2241 1
a2241 1
     fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2243 1
a2243 1
 | _ => raise ActionError 185,
d2247 2
a2248 2
     fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 186,
d2254 2
a2255 2
     fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 187,
d2259 1
a2259 1
     fn ([LONGID x],opts) =>
d2263 1
a2263 1
 | _ => raise ActionError 188,
d2267 1
a2267 1
     fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2269 1
a2269 1
 | _ => raise ActionError 189,
d2273 1
a2273 1
     fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2275 1
a2275 1
 | _ => raise ActionError 190,
d2279 1
a2279 1
     fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2281 1
a2281 1
 | _ => raise ActionError 191,
d2285 2
a2286 2
     fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 192,
d2290 2
a2291 2
     fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 193,
d2295 2
a2296 2
     fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 194,
d2300 2
a2301 2
     fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 195,
d2305 2
a2306 2
     fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 196,
d2310 2
a2311 2
     fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 197,
d2317 2
a2318 2
     fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 198,
d2322 2
a2323 2
     fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 199,
d2327 1
a2327 1
     fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2329 1
a2329 1
 | _ => raise ActionError 200,
d2333 1
a2333 1
     fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2335 1
a2335 1
 | _ => raise ActionError 201,
d2341 2
a2342 2
     fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 202,
d2346 1
a2346 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2348 1
a2348 1
 | _ => raise ActionError 203,
d2352 1
a2352 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2354 1
a2354 1
 | _ => raise ActionError 204,
d2358 1
a2358 1
     fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2360 1
a2360 1
 | _ => raise ActionError 205,
d2364 2
a2365 2
     fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 206,
d2369 1
a2369 1
     fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2371 1
a2371 1
 | _ => raise ActionError 207,
d2375 1
a2375 1
    fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2380 1
a2380 1
 | _ => raise ActionError 208,
d2384 1
a2384 1
    fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2389 1
a2389 1
 | _ => raise ActionError 209,
d2393 1
a2393 1
        fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2395 1
a2395 1
 | _ => raise ActionError 210,
d2399 2
a2400 2
        fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 211,
d2404 2
a2405 2
     fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 212,
d2409 2
a2410 2
     fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 213,
d2414 2
a2415 2
     fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 214,
d2419 2
a2420 2
     fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 215,
d2424 2
a2425 2
     fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 216,
d2429 1
a2429 1
     fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2431 1
a2431 1
 | _ => raise ActionError 217,
d2435 2
a2436 2
     fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 218,
d2440 2
a2441 2
     fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 219,
d2445 2
a2446 2
     fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 220,
d2450 1
a2450 1
     fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2452 1
a2452 1
 | _ => raise ActionError 221,
d2456 1
a2456 1
     fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2458 1
a2458 1
 | _ => raise ActionError 222,
d2464 2
a2465 2
     fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 223,
d2469 2
a2470 2
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 224,
d2474 2
a2475 2
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 225,
d2479 2
a2480 2
     fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 226,
d2484 2
a2485 2
     fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 227,
d2489 2
a2490 2
     fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 228,
d2494 2
a2495 2
     fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 229,
d2499 1
a2499 1
     fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2501 1
a2501 1
 | _ => raise ActionError 230,
d2505 2
a2506 2
     fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 231,
d2510 2
a2511 2
     fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 232,
d2516 2
a2517 2
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 233,
d2521 2
a2522 2
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 234,
d2526 2
a2527 2
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 235,
d2531 2
a2532 2
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 236,
d2536 2
a2537 2
     fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 237,
d2541 2
a2542 2
     fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 238,
d2546 2
a2547 2
     fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 239,
d2551 1
a2551 1
     fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2553 1
a2553 1
 | _ => raise ActionError 240,
d2557 2
a2558 2
     fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 241,
d2562 1
a2562 1
     fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2564 1
a2564 1
 | _ => raise ActionError 242,
d2568 2
a2569 2
     fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 243,
d2574 2
a2575 2
     fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 244,
d2579 1
a2579 1
     fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2581 1
a2581 1
 | _ => raise ActionError 245,
d2585 1
a2585 1
     fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2588 1
a2588 1
 | _ => raise ActionError 246,
d2592 2
a2593 2
     fn ([x],opts) => x
 | _ => raise ActionError 247,
d2597 1
a2597 1
     fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2599 1
a2599 1
 | _ => raise ActionError 248,
d2603 1
a2603 1
        fn ([VALID con,TY(ty,tyvars)],opts) => 
d2607 1
a2607 1
 | _ => raise ActionError 249,
d2611 2
a2612 2
     fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 250,
d2616 1
a2616 1
     fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2618 1
a2618 1
 | _ => raise ActionError 251,
d2622 1
a2622 1
        fn ([VALID excon,TY(ty,_)],opts) => 
d2626 1
a2626 1
 | _ => raise ActionError 252,
d2630 2
a2631 2
     fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 253,
d2635 1
a2635 1
     fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2637 1
a2637 1
 | _ => raise ActionError 254,
d2641 2
a2642 2
     fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 255,
d2646 2
a2647 2
     fn ([x],opts) => x
 | _ => raise ActionError 256,
d2651 2
a2652 2
     fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 257,
d2656 2
a2657 2
     fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 258,
d2661 2
a2662 2
     fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 259,
d2666 2
a2667 2
     fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 260,
d2671 2
a2672 2
     fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 261,
d2676 2
a2677 2
     fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 262,
d2681 2
a2682 2
     fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 263,
d2686 2
a2687 2
     fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 264,
d2691 2
a2692 2
     fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 265,
d2696 2
a2697 2
     fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 266,
d2701 1
a2701 1
     fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2703 1
a2703 1
 | _ => raise ActionError 267,
d2707 1
a2707 1
     fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2709 1
a2709 1
 | _ => raise ActionError 268,
d2713 1
a2713 1
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2715 1
a2715 1
 | _ => raise ActionError 269,
d2719 1
a2719 1
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2721 1
a2721 1
 | _ => raise ActionError 270,
d2725 1
a2725 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2727 1
a2727 1
 | _ => raise ActionError 271,
d2731 1
a2731 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2733 1
a2733 1
 | _ => raise ActionError 272,
d2737 1
a2737 1
     fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2739 1
a2739 1
 | _ => raise ActionError 273,
d2743 1
a2743 1
     fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2745 1
a2745 1
 | _ => raise ActionError 274,
d2749 2
a2750 2
     fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 275,
d2758 2
a2759 2
     fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 276,
d2763 2
a2764 2
     fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 277,
d2768 2
a2769 2
     fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 278,
d2773 1
a2773 1
     fn ([EXP(exp,tyvars)],opts) =>
d2775 1
a2775 1
 | _ => raise ActionError 279,
d2779 2
a2780 2
     fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 280,
d2784 2
a2785 2
     fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 281,
d2789 2
a2790 2
     fn ([x,_,_],opts) => x
 | _ => raise ActionError 282,
d2794 2
a2795 2
     fn ([_,x],opts) => x
 | _ => raise ActionError 283,
d2799 2
a2800 2
     fn ([x,_],opts) => x
 | _ => raise ActionError 284,
d2804 2
a2805 2
     fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 285,
d2811 2
a2812 2
     fn ([],opts) => DUMMY
 | _ => raise ActionError 286,
d3164 1
@


1.61
log
@Adding more checks for error ids
@
text
@d4 3
d278 1
d423 2
a424 1
  | print_token (LRbasics.STRING,STRING s) = MLWorks.String.ml_string (s,10)
d1132 1
d1147 1
a1147 1
    fn ([dec],opts) => dec
d1152 1
a1152 1
    fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1157 1
a1157 1
    fn ([LONGVALID (id,_)],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1165 1
a1165 1
    fn ([_],opts) =>
d1172 1
a1172 1
    fn ([_,_],opts) => 
d1179 1
a1179 1
    fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1184 1
a1184 1
    fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1189 1
a1189 1
  fn ([_,LAB lab],opts) =>
d1194 1
a1194 1
    fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1198 1
a1198 1
    fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1203 1
a1203 1
    fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1208 1
a1208 1
    fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1213 1
a1213 1
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1218 1
a1218 1
    fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1223 1
a1223 1
    fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1229 1
a1229 1
    fn ([_,x,_],opts) => x
d1234 1
a1234 1
    fn ([_],opts) => ENV (get_current_pE())
d1239 1
a1239 1
    fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1244 1
a1244 1
    fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1249 1
a1249 1
    fn ([],opts) => EXPLIST ([],Set.empty_set)
d1254 1
a1254 1
    fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1259 1
a1259 1
    fn ([exp],opts) => exp
d1264 1
a1264 1
    fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1270 1
a1270 1
    fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1275 1
a1275 1
    fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1281 1
a1281 1
    fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1286 1
a1286 1
    fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1292 1
a1292 1
    fn ([x],opts) => x
d1297 1
a1297 1
    fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1303 1
a1303 1
    fn ([x],opts) => x
d1308 1
a1308 1
    fn ([EXP (exp1,tyvars1), LONGVALID (id,_), EXP (exp2,tyvars2)],opts) =>
d1314 1
a1314 1
    fn ([x],opts) => x
d1319 1
a1319 1
    fn ([_],opts) => LONGVALID (equal_lvalid,Option.NONE)
d1324 1
a1324 1
    fn ([x],opts) => x
d1329 1
a1329 1
    fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1335 1
a1335 1
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1341 1
a1341 1
  fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1347 1
a1347 1
    fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1353 1
a1353 1
    fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1359 1
a1359 1
    fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1365 1
a1365 1
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1371 1
a1371 1
    fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1377 1
a1377 1
    fn ([_,MATCH (match,tyvars)],opts) =>
d1383 1
a1383 1
    fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1388 1
a1388 1
    fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1394 1
a1394 1
   fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1399 1
a1399 1
    fn ([_,_],opts) => DUMMY
d1404 1
a1404 1
    fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1409 1
a1409 1
    fn ([_,dec,_],opts) => dec
d1414 1
a1414 1
    fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1419 1
a1419 1
    fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1424 1
a1424 1
    fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1433 1
a1433 1
    fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1439 1
a1439 1
  fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1446 1
a1446 1
    fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1453 1
a1453 1
    fn ([_,DATBIND (d,pVE)],opts) => 
d1459 1
a1459 1
    fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1469 1
a1469 1
    fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1475 1
a1475 1
    fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1482 1
a1482 1
    fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1487 1
a1487 1
    fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1493 1
a1493 1
    fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1502 1
a1502 1
    fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1510 1
a1510 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1515 1
a1515 1
    fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1520 1
a1520 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1525 1
a1525 1
    fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1530 1
a1530 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1537 1
a1537 1
    fn ([_],opts) => ENV (get_current_pE())
d1542 1
a1542 1
    fn ([x],opts) => x
d1547 1
a1547 1
    fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1553 1
a1553 1
    fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1559 1
a1559 1
    fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1565 1
a1565 1
    fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1573 1
a1573 1
    fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1579 1
a1579 1
    fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1585 1
a1585 1
    fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1591 1
a1591 1
    fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1597 1
a1597 1
   fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1605 1
a1605 1
    fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1613 1
a1613 1
    fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1621 1
a1621 1
    fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1629 1
a1629 1
    fn ([],opts) => NULLTYPE
d1634 1
a1634 1
    fn ([_,ty],opts) => ty
d1639 1
a1639 1
    fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1644 1
a1644 1
    fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1650 1
a1650 1
    fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1657 1
a1657 1
    fn ([],opts) => TYVARLIST []
d1662 1
a1662 1
    fn ([TYVAR t],opts) => TYVARLIST [t]
d1667 1
a1667 1
    fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1672 1
a1672 1
    fn ([TYVAR t],opts) => TYVARLIST [t]
d1677 1
a1677 1
    fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1682 1
a1682 1
    fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1687 1
a1687 1
    fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1693 1
a1693 1
    fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1701 1
a1701 1
    fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1706 1
a1706 1
    fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1712 1
a1712 1
       fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1718 1
a1718 1
    fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1723 1
a1723 1
    fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1729 1
a1729 1
       fn ([VALID id, TY (ty,tyvars)],opts) => 
d1737 1
a1737 1
    fn ([VALID id,_,LONGVALID (id',strname_opt)],opts) => 
d1744 1
a1744 1
    fn ([],opts) => NULLTYPE
d1749 1
a1749 1
    fn ([_,x],opts) => x
d1754 1
a1754 1
    fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1759 1
a1759 1
    fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1766 1
a1766 1
      fn ([VALID id],opts) => 
d1772 1
a1772 1
    fn ([LONGVALID (id,strname_opt)],opts) => 
d1779 1
a1779 1
    fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1785 1
a1785 1
    fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1791 1
a1791 1
    fn ([_,_,_],opts) => 
d1797 1
a1797 1
    fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1802 1
a1802 1
    fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1807 1
a1807 1
    fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1812 1
a1812 1
    fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1817 1
a1817 1
    fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1822 1
a1822 1
    fn ([_,x,_],opts) => x
d1827 1
a1827 1
    fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1832 1
a1832 1
    fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1838 1
a1838 1
    fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1845 1
a1845 1
    fn ([x],opts) => x
d1850 1
a1850 1
    fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1856 1
a1856 1
    fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1862 1
a1862 1
    fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1867 1
a1867 1
    fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1874 1
a1874 1
    fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1879 1
a1879 1
    fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1889 1
a1889 1
    fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1899 1
a1899 1
    fn ([x],opts) => x
d1904 1
a1904 1
     fn ([LONGVALID (id,strname_opt), PAT (pat,pVE,tyvars)],opts) => 
d1912 1
a1912 1
    fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1919 1
a1919 1
    fn ([PAT(pat1,pVE1,tyvars1), LONGVALID (id,_), PAT(pat2,pVE2,tyvars2)],opts) =>
d1926 1
a1926 1
    fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1931 1
a1931 1
      fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1941 1
a1941 1
    fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1946 1
a1946 1
    fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1951 1
a1951 1
    fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1956 1
a1956 1
    fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1961 1
a1961 1
    fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1966 1
a1966 1
    fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1971 1
a1971 1
    fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1976 1
a1976 1
    fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1981 1
a1981 1
    fn ([_,t,_],opts) => t
d1986 1
a1986 1
    fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1991 1
a1991 1
    fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1996 1
a1996 1
    fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2001 1
a2001 1
    fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d2006 1
a2006 1
    fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d2011 1
a2011 1
    fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d2016 1
a2016 1
    fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d2024 1
a2024 1
    fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d2029 1
a2029 1
    fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d2037 1
a2037 1
    fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d2042 1
a2042 1
    fn ([LONGID id],opts) => LONGIDLIST[id]
d2049 1
a2049 1
    fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d2054 1
a2054 1
    fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d2061 1
a2061 1
    fn ([SYM sym],opts) => SYMLIST [sym]
d2066 1
a2066 1
    fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d2073 1
a2073 1
    fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d2078 1
a2078 1
    fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d2083 1
a2083 1
    fn ([STRING s],opts) => SCON (Ident.STRING s)
d2086 5
d2095 1
a2095 1
    fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d2098 1
a2098 1
 | _ => raise ActionError 161,
d2102 2
a2103 2
    fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 162,
d2109 2
a2110 2
    fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 163,
d2114 2
a2115 2
    fn ([l as LONGVALID (id,_)],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 164,
d2119 2
a2120 2
    fn ([_, l as LONGVALID (id,_)],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 165,
d2124 2
a2125 2
    fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 166,
d2129 2
a2130 2
    fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 167,
d2136 1
a2136 1
    fn ([LONGID ([],s)],opts) => SYM s
d2139 1
a2139 1
 | _ => raise ActionError 168,
d2143 2
a2144 2
    fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 169,
d2148 2
a2149 2
    fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 170,
d2153 2
a2154 2
    fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 171,
d2158 2
a2159 2
    fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 172,
d2167 1
a2167 1
    fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id),Option.NONE)
d2169 1
a2169 1
 | _ => raise ActionError 173,
d2175 1
a2175 1
    fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_short_constructor (opts,valid); VALID valid end
d2177 1
a2177 1
 | _ => raise ActionError 174,
d2181 2
a2182 2
    fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 175,
d2186 2
a2187 2
    fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 176,
d2192 1
a2192 1
    fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2194 1
a2194 1
 | _ => raise ActionError 177,
d2198 1
a2198 1
    fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2200 1
a2200 1
 | _ => raise ActionError 178,
d2204 2
a2205 2
    fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 179,
d2209 2
a2210 2
    fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 180,
d2214 1
a2214 1
    fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2216 1
a2216 1
 | _ => raise ActionError 181,
d2220 2
a2221 2
    fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 182,
d2225 2
a2226 2
    fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 183,
d2230 1
a2230 1
    fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2232 1
a2232 1
 | _ => raise ActionError 184,
d2236 2
a2237 2
    fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 185,
d2243 2
a2244 2
    fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 186,
d2248 1
a2248 1
    fn ([LONGID x],opts) =>
d2252 1
a2252 1
 | _ => raise ActionError 187,
d2256 1
a2256 1
    fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2258 1
a2258 1
 | _ => raise ActionError 188,
d2262 1
a2262 1
    fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2264 1
a2264 1
 | _ => raise ActionError 189,
d2268 1
a2268 1
    fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2270 1
a2270 1
 | _ => raise ActionError 190,
d2274 2
a2275 2
    fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 191,
d2279 2
a2280 2
    fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 192,
d2284 2
a2285 2
    fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 193,
d2289 2
a2290 2
    fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 194,
d2294 2
a2295 2
    fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 195,
d2299 2
a2300 2
    fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 196,
d2306 2
a2307 2
    fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 197,
d2311 2
a2312 2
    fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 198,
d2316 1
a2316 1
    fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2318 1
a2318 1
 | _ => raise ActionError 199,
d2322 1
a2322 1
    fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2324 1
a2324 1
 | _ => raise ActionError 200,
d2330 2
a2331 2
    fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 201,
d2335 1
a2335 1
    fn ([_,STRBIND(l,pSE)],opts) => 
d2337 1
a2337 1
 | _ => raise ActionError 202,
d2341 1
a2341 1
    fn ([_,STRBIND(l,pSE)],opts) => 
d2343 1
a2343 1
 | _ => raise ActionError 203,
d2347 1
a2347 1
    fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2349 1
a2349 1
 | _ => raise ActionError 204,
d2353 2
a2354 2
    fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 205,
d2358 1
a2358 1
    fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2360 1
a2360 1
 | _ => raise ActionError 206,
d2364 1
a2364 1
   fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2369 1
a2369 1
 | _ => raise ActionError 207,
d2373 1
a2373 1
   fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2378 1
a2378 1
 | _ => raise ActionError 208,
d2382 1
a2382 1
       fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2384 1
a2384 1
 | _ => raise ActionError 209,
d2388 2
a2389 2
       fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 210,
d2393 2
a2394 2
    fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 211,
d2398 2
a2399 2
    fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 212,
d2403 2
a2404 2
    fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 213,
d2408 2
a2409 2
    fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 214,
d2413 2
a2414 2
    fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 215,
d2418 1
a2418 1
    fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2420 1
a2420 1
 | _ => raise ActionError 216,
d2424 2
a2425 2
    fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 217,
d2429 2
a2430 2
    fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 218,
d2434 2
a2435 2
    fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 219,
d2439 1
a2439 1
    fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2441 1
a2441 1
 | _ => raise ActionError 220,
d2445 1
a2445 1
    fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2447 1
a2447 1
 | _ => raise ActionError 221,
d2453 2
a2454 2
    fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 222,
d2458 2
a2459 2
    fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 223,
d2463 2
a2464 2
    fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 224,
d2468 2
a2469 2
    fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 225,
d2473 2
a2474 2
    fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 226,
d2478 2
a2479 2
    fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 227,
d2483 2
a2484 2
    fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 228,
d2488 1
a2488 1
    fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2490 1
a2490 1
 | _ => raise ActionError 229,
d2494 2
a2495 2
    fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 230,
d2499 2
a2500 2
    fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 231,
d2505 2
a2506 2
      fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 232,
d2510 2
a2511 2
      fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 233,
d2515 2
a2516 2
      fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 234,
d2520 2
a2521 2
      fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 235,
d2525 2
a2526 2
    fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 236,
d2530 2
a2531 2
    fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 237,
d2535 2
a2536 2
    fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 238,
d2540 1
a2540 1
    fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2542 1
a2542 1
 | _ => raise ActionError 239,
d2546 2
a2547 2
    fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 240,
d2551 1
a2551 1
    fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2553 1
a2553 1
 | _ => raise ActionError 241,
d2557 2
a2558 2
    fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 242,
d2563 2
a2564 2
    fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 243,
d2568 1
a2568 1
    fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2570 1
a2570 1
 | _ => raise ActionError 244,
d2574 1
a2574 1
    fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2577 1
a2577 1
 | _ => raise ActionError 245,
d2581 2
a2582 2
    fn ([x],opts) => x
 | _ => raise ActionError 246,
d2586 1
a2586 1
    fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2588 1
a2588 1
 | _ => raise ActionError 247,
d2592 1
a2592 1
       fn ([VALID con,TY(ty,tyvars)],opts) => 
d2596 1
a2596 1
 | _ => raise ActionError 248,
d2600 2
a2601 2
    fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 249,
d2605 1
a2605 1
    fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2607 1
a2607 1
 | _ => raise ActionError 250,
d2611 1
a2611 1
       fn ([VALID excon,TY(ty,_)],opts) => 
d2615 1
a2615 1
 | _ => raise ActionError 251,
d2619 2
a2620 2
    fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 252,
d2624 1
a2624 1
    fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2626 1
a2626 1
 | _ => raise ActionError 253,
d2630 2
a2631 2
    fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 254,
d2635 2
a2636 2
    fn ([x],opts) => x
 | _ => raise ActionError 255,
d2640 2
a2641 2
    fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 256,
d2645 2
a2646 2
    fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 257,
d2650 2
a2651 2
    fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 258,
d2655 2
a2656 2
    fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 259,
d2660 2
a2661 2
    fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 260,
d2665 2
a2666 2
    fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 261,
d2670 2
a2671 2
    fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 262,
d2675 2
a2676 2
    fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 263,
d2680 2
a2681 2
    fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 264,
d2685 2
a2686 2
    fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 265,
d2690 1
a2690 1
    fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2692 1
a2692 1
 | _ => raise ActionError 266,
d2696 1
a2696 1
    fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2698 1
a2698 1
 | _ => raise ActionError 267,
d2702 1
a2702 1
   fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2704 1
a2704 1
 | _ => raise ActionError 268,
d2708 1
a2708 1
   fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2710 1
a2710 1
 | _ => raise ActionError 269,
d2714 1
a2714 1
       fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2716 1
a2716 1
 | _ => raise ActionError 270,
d2720 1
a2720 1
       fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2722 1
a2722 1
 | _ => raise ActionError 271,
d2726 1
a2726 1
    fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2728 1
a2728 1
 | _ => raise ActionError 272,
d2732 1
a2732 1
    fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2734 1
a2734 1
 | _ => raise ActionError 273,
d2738 2
a2739 2
    fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 274,
d2747 2
a2748 2
    fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 275,
d2752 2
a2753 2
    fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 276,
d2757 2
a2758 2
    fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 277,
d2762 1
a2762 1
    fn ([EXP(exp,tyvars)],opts) =>
d2764 1
a2764 1
 | _ => raise ActionError 278,
d2768 2
a2769 2
    fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 279,
d2773 1
a2773 1
    fn ([TOPDEC x],opts) => raise FoundTopDec x
d2778 1
a2778 1
    fn ([x,_,_],opts) => x
d2783 1
a2783 1
    fn ([_,x],opts) => x
d2788 1
a2788 1
    fn ([x,_],opts) => x
d2793 1
a2793 1
    fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
d2800 1
a2800 1
    fn ([],opts) => DUMMY
d3152 1
@


1.60
log
@Add information about unbound structure identifiers in LONGVALIDs
@
text
@d4 3
d682 13
a694 6
  if is_infix (get_sym id) then ()
  else
    let val print_options = print_options_of opts
    in
      error (opts,"Symbol " ^ (IdentPrint.printValId print_options id) ^ " not infix")
    end
@


1.59
log
@Problems with infix function definitions
@
text
@d4 3
d220 1
d255 1
a255 1
  | LONGVALID of Ident.LongValId
d499 1
a499 1
fun check_is_constructor (opts,id) =
d505 5
a509 1
      error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options id) ^ " not defined")
d636 2
a637 2
     MLWorks.Option.SOME x => x
   | MLWorks.Option.NONE => Ident.VAR sym)
d641 3
a643 1
(* This could error if the identifier is long *)
d647 7
a653 6
    case lookupValId id of
      MLWorks.Option.SOME (Ident.VAR _) => mkLongVar id          
    | MLWorks.Option.SOME (Ident.CON _) => mkLongCon id
    | MLWorks.Option.SOME (Ident.EXCON _) => mkLongExCon id
    | MLWorks.Option.SOME _ => Crash.impossible "TYCON':resolveLongValId:actionfunctions"
    | MLWorks.Option.NONE => mkLongVar id
d658 2
a659 2
    MLWorks.Option.SOME x => x
  | MLWorks.Option.NONE => Ident.VAR sym
d666 1
a666 1
fun check_excon (id as Ident.LONGVALID (_,valid),opts) =
d671 6
a676 1
    | _ => error (opts,"Identifier " ^ IdentPrint.printLongValId (print_options_of opts) id ^ " not an exception constructor")
d712 1
a712 1
     MLWorks.Option.SOME valid =>
d716 1
a716 1
   | MLWorks.Option.NONE => ())
d1141 1
a1141 1
    fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1292 1
a1292 1
    fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1303 1
a1303 1
    fn ([_],opts) => LONGVALID equal_lvalid
d1721 2
a1722 2
    fn ([VALID id,_,LONGVALID id'],opts) => 
    (check_excon (id',opts);
d1756 2
a1757 2
    fn ([LONGVALID id],opts) => 
    (check_is_constructor (opts,id);
d1888 2
a1889 2
     fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
     (check_is_constructor (opts,id);
d1903 1
a1903 1
    fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d2093 1
a2093 1
    fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d2098 1
a2098 1
    fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d2146 2
a2147 2
    fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
 | ([LONGID (longid as (_,id))],opts) => (report_long_error(opts,longid,"variable");LONGVALID (Ident.LONGVALID(Ident.NOPATH,Ident.VAR id)))
d2970 3
a2972 3
     MLWorks.Option.SOME (Ident.VAR _) => varred
   | MLWorks.Option.SOME _ => conred
   | MLWorks.Option.NONE => varred)
d3018 1
a3018 1
fun ifLeftAssoc right_assoc (act1,act2,[LONGVALID lvalid,_], LONGID ([],s)) =
d3024 1
a3024 1
  | ifLeftAssoc right_assoc (act1,act2, [LONGVALID lvalid,_], EQVAL) =
d3030 1
a3030 1
  | ifLeftAssoc _ (act1,act2,[LONGVALID lvalid,_], _) = act1
@


1.58
log
@Improving error messages
@
text
@d4 3
d662 8
d1052 1
@


1.57
log
@Need to check an exbind is to an exception constructor
@
text
@d4 3
d484 8
a491 1
(*
a499 1
*)
d501 2
d508 1
d511 9
a519 7
  let val print_options = print_options_of opts
  in
    if is_constructor id then
      ()
    else
      error (opts,"Non-constructor " ^ (IdentPrint.printValId print_options id) ^ " used in pattern")
  end
a520 9
fun check_not_constructor (opts,id) =
  let val print_options = print_options_of opts
  in
    if is_constructor id then
      error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId print_options id))
    else
      ()
  end

d522 9
a530 7
  let val print_options = print_options_of opts
  in
    if is_constructor id then
      error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId print_options id))
    else
      ()
  end
d653 5
a657 3
  case valid of 
    Ident.EXCON _ => ()
  | _ => error (opts,"Identifier " ^ IdentPrint.printLongValId (print_options_of opts) id ^ " not an exception constructor")
d660 16
a675 11
  let
    val print_options = print_options_of opts
    val infixp =
      (case longid of
         Ident.LONGVALID(Ident.NOPATH,id) => is_infix (get_sym id)
       | _ => false)
    val consp = is_long_constructor longid
  in
    if consp then
      if infixp
        then ()
d677 5
a681 7
        error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not infix")
    else
      if infixp
        then error (opts,"Infix constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not defined")
      else
        error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options longid) ^ " not defined and not infix")
  end
d934 2
a935 2
    if is_needed (p, get_sym v) then
      ()
d937 4
a940 1
      warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d943 2
a944 2
    if is_needed (p, get_sym v) then
      error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
d946 4
a949 1
      ()
d953 1
a953 2
  if is_infix (get_sym v) then
    ()
d955 4
a958 1
    warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d961 1
a961 2
  if is_infix (get_sym v) then
    error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
d963 4
a966 1
    ()
d969 1
a969 2
  if not(is_infix (get_sym v)) orelse op_optional opts then
    warn (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d971 4
a974 1
    ()
d977 1
a977 2
  if is_infix (get_sym v) andalso not (op_optional opts) then
    error (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
d979 4
a982 1
    ()
d1729 2
a1730 1
    (PAT (Absyn.VALpat (annotate' (make_constructor id),marks_of opts),PE.empty_pVE,Set.empty_set))
d1860 3
a1862 2
    fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
  (PAT (Absyn.APPpat (annotate (make_constructor id), pat,marks_of opts,false),pVE,tyvars))
d1869 2
a1870 1
    PAT (Absyn.APPpat (annotate (make_constructor (make_long_id id)), pat,marks_of opts,false),pVE,tyvars)
d2126 1
a2126 1
    fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
a2918 2
fun make_id_value s = LONGID ([],Symbol.find_symbol s)

@


1.56
log
@Improving lookup errors
@
text
@d4 3
a196 1
  sharing Derived.Options = IdentPrint.Options
d645 1
a645 1
fun make_excon (id as Ident.LONGVALID(path,valid)) =
d647 2
a648 2
    Ident.EXCON _ => id
  | _ => Ident.LONGVALID (path,Ident.EXCON (get_sym valid))
d1668 2
a1669 1
 (EXBIND1 (Absyn.OLDexbind (annotate id,make_excon id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set))
@


1.55
log
@Rationalizing debugger
/
@
text
@d4 4
d360 5
d469 1
a469 1
(* convert from short to long -- only used once!! *)
d479 1
d488 1
d490 6
a542 5
fun get_sym (Ident.VAR s) = s
  | get_sym (Ident.CON s) = s
  | get_sym (Ident.EXCON s) = s
  | get_sym (_) = Crash.impossible "get_sym:actionfunctions"

d568 1
a568 1
fun pe_error _ = Crash.impossible"Id clash in empty env"
d602 9
a610 4
fun lookupStrId (opts,x) =
  PE.lookupStrId (x,!ref_pE)
  handle PE.Lookup =>
    (error (opts,"Structure identifier " ^ IdentPrint.printLongStrId (mkLongStrId x) ^ " not defined");
d630 1
a630 3
    | MLWorks.Option.NONE =>
        ((* warn (opts,"Identifier " ^ IdentPrint.printLongValId popts (mkLongVar id) ^ " not defined"); *)
         mkLongVar id)
d643 4
a646 4
fun check_is_excon (opts,Ident.LONGVALID(_,Ident.EXCON _)) =
  ()
  | check_is_excon (opts,id) =
  error (opts,"Id " ^ (IdentPrint.printLongValId (print_options_of opts) id) ^ " is not an exception constructor")
d692 1
a692 1
    (error (opts,"Functor identifier " ^ IdentPrint.printFunId x ^ " not defined");
d698 1
a698 1
    (error (opts,"Signature identifier " ^ IdentPrint.printSigId x ^ " not defined");
d873 1
a873 1
    (error (opts,"Multiple declaration of value identifier: " ^
d885 1
a885 1
      (error(opts,"Multiple declaration of value identifier: " ^
d890 1
a890 1
    (error(opts,"Multiple declaration of structure identifier: " ^
d894 1
a894 1
    (error(opts,"Multiple declaration of functor identifier: " ^
d898 1
a898 1
    (error(opts,"Multiple declaration of signature identifier: " ^
d1666 1
a1666 2
 (check_is_excon (opts,id');
  EXBIND1 (Absyn.OLDexbind (annotate id,id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set))
d1700 1
a1700 2
  (check_is_constructor (opts,id);
   PAT (Absyn.VALpat (annotate' id,marks_of opts),PE.empty_pVE,Set.empty_set))
d1831 1
a1831 1
  (check_is_constructor (opts,id); PAT (Absyn.APPpat (annotate id, pat,marks_of opts,false),pVE,tyvars))
d1836 1
d1838 1
a1838 2
  (error (opts,"Constructor " ^ (IdentPrint.printValId (print_options_of opts) id) ^ " not defined");
   PAT (Absyn.APPpat (annotate (make_long_id id), pat,marks_of opts,false),pVE,tyvars))
@


1.54
log
@Fixed problem with IfStarStack being raise
(d)
@
text
@d4 4
d947 1
a947 1
   ref([],Absyn.Option.ABSENT))
@


1.53
log
@Efficiency improvements to lookup
@
text
@d4 3
a2899 2
exception IfStarStack

d2903 1
a2903 4
  | ifStarStack _ (starred,tyconred,[LONGID _],_) = tyconred
  | ifStarStack _ _ = raise IfStarStack

exception IfStarInput
d2908 1
a2908 2
  | ifStarInput _ (_,otheract,[],_) = otheract
  | ifStarInput _ _ = raise IfStarInput
@


1.52
log
@Added make_id_value and print_token
Abstraction of  debug information
@
text
@d4 4
d581 1
a581 1
fun lookupValId x = PE.lookupValId (x,!ref_pE)
d590 4
a593 2
fun getValId
 (id as ([],sym)) = (lookupValId id handle PE.Lookup => Ident.VAR sym)
d601 8
a608 8
    (case lookupValId id of
       Ident.VAR _ => mkLongVar id          
     | Ident.CON _ => mkLongCon id
     | Ident.EXCON _ => mkLongExCon id
     | _ => Crash.impossible "TYCON':resolveLongValId:actionfunctions")
       handle PE.Lookup =>
         ((* warn (opts,"Identifier " ^ IdentPrint.printLongValId popts (mkLongVar id) ^ " not defined"); *)
          mkLongVar id)
d612 3
a614 2
  lookupValId ([],sym)
  handle PE.Lookup => Ident.VAR sym
d648 6
a653 8
  let
    val valid = lookupValId(nil,s)
  in
    if is_constructor valid
      then error (opts,"Trying to bind constructor " ^ Symbol.symbol_name s ^ " in record")
    else ()
  end
  handle PE.Lookup => ()
d940 1
a940 1
   ref(nil,Absyn.Option.ABSENT))
d2890 5
a2894 6
fun
  ifVarStack _ (varred,conred,[LONGID (id as ([],s))],_) =
  ((case lookupValId id of
      Ident.VAR _ => varred
    | _ => conred)
      handle PE.Lookup => varred)
@


1.51
log
@Modified check_rec_bindings to check the pattern being bound
for constructors, in order to get better error messages
@
text
@d4 4
d381 7
a387 1
  
d932 1
a932 1
fun annotate' x = (x,ref (Absyn.nullType,Absyn.Option.ABSENT,nil))
d2862 1
@


1.50
log
@Modify effect of fixiy in open to be more sensible
@
text
@d4 3
d762 14
d778 10
a787 10
    let
      fun is_fn (Absyn.FNexp _) = true
        | is_fn (Absyn.TYPEDexp (exp,_,_)) = is_fn exp
        | is_fn _ = false
    in
      if is_fn exp
        then ()
      else error(opts,"Non-function expression in value binding");
        check_rec_bindings(opts,l)
    end
@


1.49
log
@Fixed abstractions for the second time.
@
text
@d4 3
d523 3
d919 1
a919 1
fun do_open_dec_action (opts,longids) =
d921 2
d925 2
a926 1
    val new_pE = fold_pEs pEs
@


1.48
log
@Added check for exception constructor status in "excon = excon" clause
@
text
@d4 3
d2200 1
a2200 1
  (extend_pSE pSE;STRDEC(Absyn.STRUCTUREstrdec l,pSE_in_pE pSE))
@


1.47
log
@Type function, debugger structure, and structure recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.
@
text
@d4 4
d592 5
d1600 2
a1601 1
  EXBIND1 (Absyn.OLDexbind (annotate id,id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set)
@


1.46
log
@Changed from_unix_string to from_require_string.
@
text
@d4 3
d201 2
a202 2
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.Option.opt * string * bool ref * Location.T)
  type DatBind = TyVarList * Ident.TyCon * TypeRef * ConBind list
d266 2
a267 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.Option.opt * Absyn.StrExp * bool ref * Location.T) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.Option.opt * Absyn.StrExp * bool ref * Location.T) * (Ident.StrId * PE.pE))
d294 2
a295 2
  | TYPBIND of (TyVarList * Ident.TyCon * Absyn.Ty) list
  | TYPBIND1 of (TyVarList * Ident.TyCon * Absyn.Ty)
d319 4
d495 1
d572 2
a573 1
     | Ident.EXCON _ => mkLongExCon id)
d733 2
a734 2
  val check_disjoint_datbind = check_disjoint_tycons(fn (_,x,_,_) => x, "datbind")
  val check_disjoint_typbind = check_disjoint_tycons(fn (_,x,_) => x, "typbind")
d756 2
a757 2
    fun get_datbind_tycon (_,tycon,_,_) = tycon
    fun get_typbind_tycon (_,tycon,_) = tycon
d887 2
a888 4
fun annotate' x = (x,ref (Absyn.nullType,Absyn.Option.ABSENT))
fun mannotate (OPTS(l,_,
                    Options.OPTIONS{compiler_options = 
                                    Options.COMPILEROPTIONS{debug_polyvariables,...},...}),x) = 
d890 1
a890 4
   if debug_polyvariables then
     Absyn.Option.PRESENT(ref(nil,Absyn.Option.ABSENT))
   else 
     Absyn.Option.ABSENT)
d944 3
a946 1
  let val (a,b,c,d,f) =
d953 6
a958 1
    FUNBIND1 ((a,b,c,d,f,make_funbind_info(opts,funid),ref false,marks_of opts),funid,pE)
a985 1

d1000 1
a1000 1
     fn ([dec],opts) => dec
d1005 1
a1005 1
     fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d1010 1
a1010 1
     fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d1018 1
a1018 1
     fn ([_],opts) =>
d1025 1
a1025 1
     fn ([_,_],opts) => 
d1032 1
a1032 1
     fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1037 1
a1037 1
     fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1042 2
a1043 2
   fn ([_,LAB lab],opts) =>
  EXP (Derived.make_select (lab,marks_of opts,make_hash_info(opts,lab),options_of' opts),Set.empty_set)
d1047 1
a1047 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1051 1
a1051 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType, marks_of opts),Set.union(tyvars,tyvars'))
d1056 1
a1056 1
     fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1061 1
a1061 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1066 1
a1066 1
   fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE(),options_of' opts),tyvars)
d1071 1
a1071 1
     fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1076 1
a1076 1
     fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1082 1
a1082 1
     fn ([_,x,_],opts) => x
d1087 1
a1087 1
     fn ([_],opts) => ENV (get_current_pE())
d1092 1
a1092 1
     fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1097 1
a1097 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1102 1
a1102 1
     fn ([],opts) => EXPLIST ([],Set.empty_set)
d1107 1
a1107 1
     fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1112 1
a1112 1
     fn ([exp],opts) => exp
d1117 1
a1117 1
     fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1123 1
a1123 1
     fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1128 1
a1128 1
     fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1134 1
a1134 1
     fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1139 1
a1139 1
     fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1145 1
a1145 1
     fn ([x],opts) => x
d1150 1
a1150 1
     fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1156 1
a1156 1
     fn ([x],opts) => x
d1161 1
a1161 1
     fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1167 1
a1167 1
     fn ([x],opts) => x
d1172 1
a1172 1
     fn ([_],opts) => LONGVALID equal_lvalid
d1177 1
a1177 1
     fn ([x],opts) => x
d1182 1
a1182 1
     fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1188 2
a1189 2
   fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),marks_of opts,get_current_pE(),options_of' opts),Set.union(tyvars1,tyvars2))
d1194 2
a1195 2
   fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),marks_of opts,get_current_pE(),options_of' opts),Set.union(tyvars1,tyvars2))
d1200 1
a1200 1
     fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1206 1
a1206 1
     fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1212 1
a1212 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1218 2
a1219 2
   fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_while (exp1,exp2,make_while_info(opts),marks_of opts,get_current_pE(),options_of' opts),Set.union(tyvars1,tyvars2))
d1224 1
a1224 1
     fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1230 1
a1230 1
     fn ([_,MATCH (match,tyvars)],opts) =>
d1236 1
a1236 1
     fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1241 1
a1241 1
     fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1247 1
a1247 1
    fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1252 1
a1252 1
     fn ([_,_],opts) => DUMMY
d1257 1
a1257 1
     fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1262 1
a1262 1
     fn ([_,dec,_],opts) => dec
d1267 1
a1267 1
     fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1272 1
a1272 1
     fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1277 1
a1277 1
     fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1286 1
a1286 1
     fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1292 3
a1294 3
   fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind (y,options_of opts,options_of' opts)) (rev l)),
                       tyvars,marks_of opts,options_of' opts),pVE_in_pE pVE,Set.empty_set)
d1299 1
a1299 1
     fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1306 1
a1306 1
     fn ([_,DATBIND (d,pVE)],opts) => 
d1312 1
a1312 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1322 1
a1322 1
     fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1328 1
a1328 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1335 1
a1335 1
     fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1340 1
a1340 1
     fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1346 1
a1346 1
     fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1355 1
a1355 1
     fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1363 1
a1363 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1368 1
a1368 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1373 1
a1373 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1378 1
a1378 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1383 1
a1383 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1390 1
a1390 1
     fn ([_],opts) => ENV (get_current_pE())
d1395 1
a1395 1
     fn ([x],opts) => x
d1400 1
a1400 1
     fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1406 1
a1406 1
     fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1412 1
a1412 1
     fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1418 1
a1418 1
     fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1426 1
a1426 1
     fn ([FVALLIST (fvals,tyvars,id,loc)],opts) =>
d1432 1
a1432 1
     fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id,loc)],opts) =>
d1438 1
a1438 1
     fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id,marks_of opts)
d1444 1
a1444 1
     fn ([FVALLIST (fvals,tyvars1,id,_),_,FVAL ((fval,tyvars2),id')],opts) =>
d1450 1
a1450 1
    fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1458 1
a1458 1
     fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1466 1
a1466 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1474 1
a1474 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1482 1
a1482 1
     fn ([],opts) => NULLTYPE
d1487 1
a1487 1
     fn ([_,ty],opts) => ty
d1492 1
a1492 1
     fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1497 1
a1497 1
     fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1503 3
a1505 2
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
  (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty))
d1510 1
a1510 1
     fn ([],opts) => TYVARLIST []
d1515 1
a1515 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1520 1
a1520 1
     fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1525 1
a1525 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1530 1
a1530 1
     fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1535 1
a1535 1
     fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1540 1
a1540 1
     fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1546 1
a1546 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1548 2
a1549 1
   DATBIND1 ((rev tyvarlist,tycon,ref Absyn.nullType,rev conbind),pVE))
d1554 1
a1554 1
     fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1559 1
a1559 1
     fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1565 1
a1565 1
        fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1571 1
a1571 1
     fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1576 1
a1576 1
     fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1582 1
a1582 1
        fn ([VALID id, TY (ty,tyvars)],opts) => 
d1590 1
a1590 1
     fn ([VALID id,_,LONGVALID id'],opts) => 
d1596 1
a1596 1
     fn ([],opts) => NULLTYPE
d1601 1
a1601 1
     fn ([_,x],opts) => x
d1606 1
a1606 1
     fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1611 1
a1611 1
     fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1618 1
a1618 1
       fn ([VALID id],opts) => 
d1624 1
a1624 1
     fn ([LONGVALID id],opts) => 
d1631 1
a1631 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1637 1
a1637 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1643 1
a1643 1
     fn ([_,_,_],opts) => 
d1649 1
a1649 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1654 1
a1654 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1659 1
a1659 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1664 1
a1664 1
     fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1669 1
a1669 1
     fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1674 1
a1674 1
     fn ([_,x,_],opts) => x
d1679 1
a1679 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1684 1
a1684 1
     fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1690 1
a1690 1
     fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1697 1
a1697 1
     fn ([x],opts) => x
d1702 1
a1702 1
     fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1708 1
a1708 1
     fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1714 1
a1714 1
     fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1719 1
a1719 1
     fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1726 1
a1726 1
     fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1731 1
a1731 1
     fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1741 1
a1741 1
     fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1751 1
a1751 1
     fn ([x],opts) => x
d1756 1
a1756 1
     fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1762 1
a1762 1
     fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1769 1
a1769 1
     fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1776 1
a1776 1
     fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1781 1
a1781 1
       fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1791 1
a1791 1
     fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1796 1
a1796 1
     fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1801 1
a1801 1
     fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1806 1
a1806 1
     fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1811 1
a1811 1
     fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1816 1
a1816 1
     fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1821 1
a1821 1
     fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1826 1
a1826 1
     fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1831 1
a1831 1
     fn ([_,t,_],opts) => t
d1836 1
a1836 1
     fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1841 1
a1841 1
     fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1846 1
a1846 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1851 1
a1851 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1856 1
a1856 1
     fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1861 1
a1861 1
     fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1866 1
a1866 1
     fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1874 1
a1874 1
     fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1879 1
a1879 1
     fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1887 1
a1887 1
     fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1892 1
a1892 1
     fn ([LONGID id],opts) => LONGIDLIST[id]
d1899 1
a1899 1
     fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1904 1
a1904 1
     fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1911 1
a1911 1
     fn ([SYM sym],opts) => SYMLIST [sym]
d1916 1
a1916 1
     fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1923 1
a1923 1
     fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1928 1
a1928 1
     fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1933 1
a1933 1
     fn ([STRING s],opts) => SCON (Ident.STRING s)
d1940 1
a1940 1
     fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1947 1
a1947 1
     fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1954 1
a1954 1
     fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1959 1
a1959 1
     fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1964 1
a1964 1
     fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1969 1
a1969 1
     fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1974 1
a1974 1
     fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1981 1
a1981 1
     fn ([LONGID ([],s)],opts) => SYM s
d1988 1
a1988 1
     fn ([_],opts) => SYM equal_symbol
d1993 1
a1993 1
     fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1998 1
a1998 1
     fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d2003 1
a2003 1
     fn ([SYM s],opts) => STRID(Ident.STRID s)
d2012 1
a2012 1
     fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d2020 1
a2020 1
     fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d2026 1
a2026 1
     fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d2031 1
a2031 1
     fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d2037 1
a2037 1
     fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2043 1
a2043 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2049 1
a2049 1
     fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2054 1
a2054 1
     fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2059 1
a2059 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2065 1
a2065 1
     fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2070 1
a2070 1
     fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2075 1
a2075 1
     fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2081 1
a2081 1
     fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2088 1
a2088 1
     fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d2093 4
a2096 1
     fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d2101 2
a2102 2
     fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,strexp,ref false,marks_of opts),lookupFunId (opts,funid))
d2107 2
a2108 2
     fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,ref false,marks_of opts),lookupFunId (opts,funid))
d2113 1
a2113 1
     fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2119 1
a2119 1
     fn ([_],opts) => ENV (get_current_pE())
d2124 1
a2124 1
     fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2129 1
a2129 1
     fn ([_,strdec,_],opts) => strdec
d2134 1
a2134 1
     fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2139 1
a2139 1
     fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2144 1
a2144 1
     fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2151 1
a2151 1
     fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2156 1
a2156 1
     fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2161 1
a2161 1
     fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2167 1
a2167 1
     fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2175 1
a2175 1
     fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2180 1
a2180 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2186 2
a2187 2
     fn ([_,STRBIND(l,pSE)],opts) => 
  (extend_pSE pSE;STRDEC(Absyn.ABSTRACTIONstrdec l,pSE_in_pE pSE))
d2192 1
a2192 1
     fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2198 1
a2198 1
     fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2203 1
a2203 1
     fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2209 5
a2213 2
    fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
  STRBIND1((id,Absyn.Option.PRESENT sigexp,strexp,ref false,marks_of opts),(id,pE1))
d2218 5
a2222 2
    fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
  STRBIND1((id,Absyn.Option.ABSENT,strexp,ref false,marks_of opts),(id,pE))
d2227 1
a2227 1
        fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2233 1
a2233 1
        fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
d2238 1
a2238 1
     fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2243 1
a2243 1
     fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2248 1
a2248 1
     fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2253 1
a2253 1
     fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2258 1
a2258 1
     fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2263 1
a2263 1
     fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2269 1
a2269 1
     fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2274 1
a2274 1
     fn ([_,spec,_],opts) => spec
d2279 1
a2279 1
     fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2284 1
a2284 1
     fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2290 1
a2290 1
     fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2298 1
a2298 1
     fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2303 1
a2303 1
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2308 1
a2308 1
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2313 1
a2313 1
     fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2318 1
a2318 1
     fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2323 1
a2323 1
     fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2328 1
a2328 1
     fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2333 1
a2333 1
     fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2339 1
a2339 1
     fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2344 1
a2344 1
     fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2350 1
a2350 1
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2355 1
a2355 1
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2360 1
a2360 1
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2365 1
a2365 1
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2370 1
a2370 1
     fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2375 1
a2375 1
     fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2380 1
a2380 1
     fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2385 1
a2385 1
     fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2391 1
a2391 1
     fn ([TYPDESC1 x],opts) => TYPDESC[x]
d2396 1
a2396 1
     fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2402 1
a2402 1
     fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
d2408 1
a2408 1
     fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2413 1
a2413 1
     fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2419 1
a2419 1
     fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2426 1
a2426 1
     fn ([x],opts) => x
d2431 1
a2431 1
     fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2437 1
a2437 1
        fn ([VALID con,TY(ty,tyvars)],opts) => 
d2445 1
a2445 1
     fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2450 1
a2450 1
     fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2456 1
a2456 1
        fn ([VALID excon,TY(ty,_)],opts) => 
d2464 1
a2464 1
     fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d2469 1
a2469 1
     fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2475 1
a2475 1
     fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2480 1
a2480 1
     fn ([x],opts) => x
d2485 1
a2485 1
     fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2490 1
a2490 1
     fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
d2495 1
a2495 1
     fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
d2500 1
a2500 1
     fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2505 1
a2505 1
     fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2510 1
a2510 1
     fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d2515 1
a2515 1
     fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d2520 1
a2520 1
     fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d2525 1
a2525 1
     fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2530 1
a2530 1
     fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d2535 1
a2535 1
     fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2541 1
a2541 1
     fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2547 2
a2548 2
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.Option.PRESENT sigexp',make_funbind_info(opts,funid),ref false,marks_of opts),funid,pE''))
d2553 2
a2554 2
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.Option.ABSENT,make_funbind_info (opts,funid),ref false,marks_of opts),funid,pE'''))
d2559 1
a2559 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2565 1
a2565 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2571 1
a2571 1
     fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2577 1
a2577 1
     fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2583 1
a2583 1
     fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2592 1
a2592 1
     fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2597 1
a2597 1
     fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2602 1
a2602 1
     fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2607 1
a2607 1
     fn ([EXP(exp,tyvars)],opts) =>
d2613 1
a2613 1
     fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_require_string (s, marks_of opts), marks_of opts),PE.empty_pB)
d2618 2
a2619 2
     fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 280,
d2623 2
a2624 2
     fn ([x,_,_],opts) => x
 | _ => raise ActionError 281,
d2628 2
a2629 2
     fn ([_,x],opts) => x
 | _ => raise ActionError 282,
d2633 2
a2634 2
     fn ([x,_],opts) => x
 | _ => raise ActionError 283,
d2638 2
a2639 2
     fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 284,
d2645 2
a2646 2
     fn ([],opts) => DUMMY
 | _ => raise ActionError 285,
@


1.45
log
@Parse abstractions as abstractions (again!).
@
text
@d4 3
d2592 1
a2592 1
     fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_unix_string (s, marks_of opts), marks_of opts),PE.empty_pB)
@


1.44
log
@Pass Info.options to the withtype derived functions.
@
text
@d4 3
d2169 1
a2169 1
  (extend_pSE pSE;STRDEC(Absyn.STRUCTUREstrdec l,pSE_in_pE pSE))
@


1.43
log
@Added location information to COERCEexp.
@
text
@d4 3
d1299 3
a1301 1
   DEC (Derived.make_datatype_withtype (marks_of opts,rev d, t),pVE_in_pE pVE,Set.empty_set))
d1314 2
a1315 1
   DEC (Derived.make_abstype_withtype (marks_of opts,rev d,t,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
@


1.42
log
@Added fixity annotations to abstract syntax
;
@
text
@d4 4
d1032 1
a1032 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
@


1.41
log
@Incorporated bug fix.
@
text
@d4 3
d281 1
a281 1
  | FVALLIST of FVal list * TyVarSet * Ident.ValId
d312 2
d327 1
a327 1
  fun make_fval_info (opts) = fn x => locate(opts,x)
d1128 1
a1128 1
  EXP(Absyn.APPexp(exp1,exp2,marks_of opts,ref Absyn.nullType),Set.union(tyvars1,tyvars2))
d1139 1
a1139 1
  EXP (Absyn.APPexp (Absyn.VALexp (mannotate(opts,id)),Derived.make_tuple_exp [exp1,exp2],marks_of opts,ref Absyn.nullType),Set.union(tyvars1,tyvars2))
d1400 2
a1401 2
     fn ([FVALLIST (fvals,tyvars,id)],opts) =>
  FVALBIND (([((rev fvals),make_fval_info(opts),marks_of opts)],tyvars),make_pVE id)
d1406 2
a1407 2
     fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
  FVALBIND (((rev fvals,make_fval_info(opts),marks_of opts)::l,Set.union(tyvars1,tyvars2)),addNewValId(opts,id,pVE))
d1412 1
a1412 1
     fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1418 2
a1419 2
     fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
  FVALLIST (fval::fvals,Set.union(tyvars1,tyvars2),id)
d1664 1
a1664 1
   PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],marks_of opts),pVE,tyvars))
d1729 1
a1729 1
  (check_is_constructor (opts,id); PAT (Absyn.APPpat (annotate id, pat,marks_of opts),pVE,tyvars))
d1736 1
a1736 1
   PAT (Absyn.APPpat (annotate (make_long_id id), pat,marks_of opts),pVE,tyvars))
d1743 1
a1743 1
   PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2],marks_of opts),merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2)))
@


1.40
log
@Bug fixing
@
text
@d4 3
d957 1
d972 1
a972 1
    fn ([dec],opts) => dec
d977 1
a977 1
    fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d982 1
a982 1
    fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d990 1
a990 1
    fn ([_],opts) =>
d997 1
a997 1
    fn ([_,_],opts) => 
d1004 1
a1004 1
    fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d1009 1
a1009 1
    fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d1014 1
a1014 1
  fn ([_,LAB lab],opts) =>
d1019 1
a1019 1
    fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1023 1
a1023 1
    fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d1028 1
a1028 1
    fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1033 1
a1033 1
    fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1038 1
a1038 1
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE(),options_of' opts),tyvars)
d1043 1
a1043 1
    fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1048 1
a1048 1
    fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1054 1
a1054 1
    fn ([_,x,_],opts) => x
d1059 1
a1059 1
    fn ([_],opts) => ENV (get_current_pE())
d1064 1
a1064 1
    fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1069 1
a1069 1
    fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1074 1
a1074 1
    fn ([],opts) => EXPLIST ([],Set.empty_set)
d1079 1
a1079 1
    fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1084 1
a1084 1
    fn ([exp],opts) => exp
d1089 1
a1089 1
    fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1095 1
a1095 1
    fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1100 1
a1100 1
    fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1106 1
a1106 1
    fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1111 1
a1111 1
    fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1117 1
a1117 1
    fn ([x],opts) => x
d1122 1
a1122 1
    fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1128 1
a1128 1
    fn ([x],opts) => x
d1133 1
a1133 1
    fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1139 1
a1139 1
    fn ([x],opts) => x
d1144 1
a1144 1
    fn ([_],opts) => LONGVALID equal_lvalid
d1149 1
a1149 1
    fn ([x],opts) => x
d1154 1
a1154 1
    fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1160 1
a1160 1
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1166 1
a1166 1
  fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1172 1
a1172 1
    fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1178 1
a1178 1
    fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1184 1
a1184 1
    fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1190 1
a1190 1
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1196 1
a1196 1
    fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1202 1
a1202 1
    fn ([_,MATCH (match,tyvars)],opts) =>
d1208 1
a1208 1
    fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1213 1
a1213 1
    fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1219 1
a1219 1
   fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1224 1
a1224 1
    fn ([_,_],opts) => DUMMY
d1229 1
a1229 1
    fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1234 1
a1234 1
    fn ([_,dec,_],opts) => dec
d1239 1
a1239 1
    fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1244 1
a1244 1
    fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1249 1
a1249 1
    fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1258 1
a1258 1
    fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1264 1
a1264 1
  fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1271 1
a1271 1
    fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1278 1
a1278 1
    fn ([_,DATBIND (d,pVE)],opts) => 
d1284 1
a1284 1
    fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1292 1
a1292 1
    fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1298 1
a1298 1
    fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1304 1
a1304 1
    fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1309 1
a1309 1
    fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1315 1
a1315 1
    fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1324 1
a1324 1
    fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1332 1
a1332 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1337 1
a1337 1
    fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1342 1
a1342 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1347 1
a1347 1
    fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1352 1
a1352 1
    fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1359 1
a1359 1
    fn ([_],opts) => ENV (get_current_pE())
d1364 1
a1364 1
    fn ([x],opts) => x
d1369 1
a1369 1
    fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1375 1
a1375 1
    fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1381 1
a1381 1
    fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1387 1
a1387 1
    fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1395 1
a1395 1
    fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1401 1
a1401 1
    fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1407 1
a1407 1
    fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1413 1
a1413 1
    fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1419 1
a1419 1
   fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1427 1
a1427 1
    fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1435 1
a1435 1
    fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1443 1
a1443 1
    fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1451 1
a1451 1
    fn ([],opts) => NULLTYPE
d1456 1
a1456 1
    fn ([_,ty],opts) => ty
d1461 1
a1461 1
    fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1466 1
a1466 1
    fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1472 1
a1472 1
    fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1478 1
a1478 1
    fn ([],opts) => TYVARLIST []
d1483 1
a1483 1
    fn ([TYVAR t],opts) => TYVARLIST [t]
d1488 1
a1488 1
    fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1493 1
a1493 1
    fn ([TYVAR t],opts) => TYVARLIST [t]
d1498 1
a1498 1
    fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1503 1
a1503 1
    fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1508 1
a1508 1
    fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1514 1
a1514 1
    fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1521 1
a1521 1
    fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1526 1
a1526 1
    fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1532 1
a1532 1
       fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1538 1
a1538 1
    fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1543 1
a1543 1
    fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1549 1
a1549 1
       fn ([VALID id, TY (ty,tyvars)],opts) => 
d1557 1
a1557 1
    fn ([VALID id,_,LONGVALID id'],opts) => 
d1563 1
a1563 1
    fn ([],opts) => NULLTYPE
d1568 1
a1568 1
    fn ([_,x],opts) => x
d1573 1
a1573 1
    fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1578 1
a1578 1
    fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1585 1
a1585 1
      fn ([VALID id],opts) => 
d1591 1
a1591 1
    fn ([LONGVALID id],opts) => 
d1598 1
a1598 1
    fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1604 1
a1604 1
    fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1610 1
a1610 1
    fn ([_,_,_],opts) => 
d1616 1
a1616 1
    fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1621 1
a1621 1
    fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1626 1
a1626 1
    fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1631 1
a1631 1
    fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1636 1
a1636 1
    fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1641 1
a1641 1
    fn ([_,x,_],opts) => x
d1646 1
a1646 1
    fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1651 1
a1651 1
    fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1657 1
a1657 1
    fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1664 1
a1664 1
    fn ([x],opts) => x
d1669 1
a1669 1
    fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1675 1
a1675 1
    fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1681 1
a1681 1
    fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1686 1
a1686 1
    fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1693 1
a1693 1
    fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1698 1
a1698 1
    fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1708 1
a1708 1
    fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1718 1
a1718 1
    fn ([x],opts) => x
d1723 1
a1723 1
    fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1729 1
a1729 1
    fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1736 1
a1736 1
    fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1743 1
a1743 1
    fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1748 1
a1748 1
      fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1758 1
a1758 1
    fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1763 1
a1763 1
    fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1768 1
a1768 1
    fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1773 1
a1773 1
    fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1778 1
a1778 1
    fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1783 1
a1783 1
    fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1788 1
a1788 1
    fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1793 1
a1793 1
    fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1798 1
a1798 1
    fn ([_,t,_],opts) => t
d1803 1
a1803 1
    fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1808 1
a1808 1
    fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1813 1
a1813 1
    fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1818 1
a1818 1
    fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1823 1
a1823 1
    fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1828 1
a1828 1
    fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1833 1
a1833 1
    fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1841 1
a1841 1
    fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1846 1
a1846 1
    fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1854 1
a1854 1
    fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1859 1
a1859 1
    fn ([LONGID id],opts) => LONGIDLIST[id]
d1866 1
a1866 1
    fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1871 1
a1871 1
    fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1878 1
a1878 1
    fn ([SYM sym],opts) => SYMLIST [sym]
d1883 1
a1883 1
    fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1890 1
a1890 1
    fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1895 1
a1895 1
    fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1900 1
a1900 1
    fn ([STRING s],opts) => SCON (Ident.STRING s)
d1907 1
a1907 1
    fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1914 1
a1914 1
    fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1921 1
a1921 1
    fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1926 1
a1926 1
    fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1931 1
a1931 1
    fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1936 1
a1936 1
    fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1941 1
a1941 1
    fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1948 1
a1948 1
    fn ([LONGID ([],s)],opts) => SYM s
d1955 1
a1955 1
    fn ([_],opts) => SYM equal_symbol
d1960 1
a1960 1
    fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1965 1
a1965 1
    fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1970 1
a1970 1
    fn ([SYM s],opts) => STRID(Ident.STRID s)
d1979 1
a1979 1
    fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1987 1
a1987 1
    fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1993 1
a1993 1
    fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1998 1
a1998 1
    fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d2004 1
a2004 1
    fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d2010 1
a2010 1
    fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d2016 1
a2016 1
    fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2021 1
a2021 1
    fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2026 1
a2026 1
    fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2032 1
a2032 1
    fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2037 1
a2037 1
    fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2042 1
a2042 1
    fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2048 1
a2048 1
    fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2055 1
a2055 1
    fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d2060 1
a2060 1
    fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d2065 1
a2065 1
    fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2071 1
a2071 1
    fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2077 1
a2077 1
    fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2083 1
a2083 1
    fn ([_],opts) => ENV (get_current_pE())
d2088 1
a2088 1
    fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2093 1
a2093 1
    fn ([_,strdec,_],opts) => strdec
d2098 1
a2098 1
    fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2103 1
a2103 1
    fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2108 1
a2108 1
    fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2115 1
a2115 1
    fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2120 1
a2120 1
    fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2125 1
a2125 1
    fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2131 1
a2131 1
    fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2139 1
a2139 1
    fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2144 1
a2144 1
    fn ([_,STRBIND(l,pSE)],opts) => 
d2150 1
a2150 1
    fn ([_,STRBIND(l,pSE)],opts) => 
d2156 1
a2156 1
    fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2162 1
a2162 1
    fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2167 1
a2167 1
    fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2173 1
a2173 1
   fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2179 1
a2179 1
   fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2185 1
a2185 1
       fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2191 1
a2191 1
       fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
d2196 1
a2196 1
    fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2201 1
a2201 1
    fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2206 1
a2206 1
    fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2211 1
a2211 1
    fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2216 1
a2216 1
    fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2221 1
a2221 1
    fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2227 1
a2227 1
    fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2232 1
a2232 1
    fn ([_,spec,_],opts) => spec
d2237 1
a2237 1
    fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2242 1
a2242 1
    fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2248 1
a2248 1
    fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2256 1
a2256 1
    fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2261 1
a2261 1
    fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2266 1
a2266 1
    fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2271 1
a2271 1
    fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2276 1
a2276 1
    fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2281 1
a2281 1
    fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2286 1
a2286 1
    fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2291 1
a2291 1
    fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2297 1
a2297 1
    fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2302 1
a2302 1
    fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2308 1
a2308 1
      fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2313 1
a2313 1
      fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2318 1
a2318 1
      fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2323 1
a2323 1
      fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2328 1
a2328 1
    fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2333 1
a2333 1
    fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2338 1
a2338 1
    fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2343 1
a2343 1
    fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2349 1
a2349 1
    fn ([TYPDESC1 x],opts) => TYPDESC[x]
d2354 1
a2354 1
    fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2360 1
a2360 1
    fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
d2366 1
a2366 1
    fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2371 1
a2371 1
    fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2377 1
a2377 1
    fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2384 1
a2384 1
    fn ([x],opts) => x
d2389 1
a2389 1
    fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2395 1
a2395 1
       fn ([VALID con,TY(ty,tyvars)],opts) => 
d2403 1
a2403 1
    fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2408 1
a2408 1
    fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2414 1
a2414 1
       fn ([VALID excon,TY(ty,_)],opts) => 
d2422 1
a2422 1
    fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d2427 1
a2427 1
    fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2433 1
a2433 1
    fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2438 1
a2438 1
    fn ([x],opts) => x
d2443 1
a2443 1
    fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2448 1
a2448 1
    fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
d2453 1
a2453 1
    fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
d2458 1
a2458 1
    fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2463 1
a2463 1
    fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2468 1
a2468 1
    fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d2473 1
a2473 1
    fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d2478 1
a2478 1
    fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d2483 1
a2483 1
    fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2488 1
a2488 1
    fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d2493 1
a2493 1
    fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2499 1
a2499 1
    fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2505 1
a2505 1
   fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2511 1
a2511 1
   fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2517 1
a2517 1
       fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2523 1
a2523 1
       fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2529 1
a2529 1
    fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2535 1
a2535 1
    fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2541 1
a2541 1
    fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2550 1
a2550 1
    fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2555 1
a2555 1
    fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2560 1
a2560 1
    fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2565 1
a2565 1
    fn ([EXP(exp,tyvars)],opts) =>
d2569 1
a2569 1
(*          ((TOPDEC :require :longid))  *)
d2571 1
a2571 1
    fn ([_,LONGID (l, s)],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.create (l, s, marks_of opts), marks_of opts),PE.empty_pB)
d2574 1
a2574 1
(*          ((TOPDEC :require :string))  *)
d2576 1
a2576 1
    fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_unix_string (s, marks_of opts), marks_of opts),PE.empty_pB)
d2579 1
a2579 1
(*          ((TOPDEC1 TOPDEC)) *)
d2581 1
a2581 1
    fn ([TOPDEC x],opts) => raise FoundTopDec x
d2584 1
a2584 1
(*          ((PROGRAM TOPDEC1 DECSEP PROGRAM))  *)
d2586 1
a2586 1
    fn ([x,_,_],opts) => x
d2589 1
a2589 1
(*          ((PROGRAM DECSEP PROGRAM))  *)
d2591 1
a2591 1
    fn ([_,x],opts) => x
d2594 1
a2594 1
(*         ((PROGRAM TOPDEC1 DECSEP))  *)
d2596 1
a2596 1
    fn ([x,_],opts) => x
a2598 5
(*         ((PROGRAM DECSEP))  *)

    fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 285,

d2603 2
a2604 2
    fn ([],opts) => DUMMY
 | _ => raise ActionError 286,
@


1.39
log
@Instances for polymorphic debugger.
@
text
@d4 9
d1423 4
a1426 4
    fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
| ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id)
@


1.38
log
@Improved message for undefined constructors in patterns
@
text
@d4 3
d131 1
d283 1
d848 9
a856 2
fun annotate' x = (x,ref Absyn.nullType)
fun mannotate (opts,x) = (x,ref Absyn.nullType,marks_of opts)
d1001 2
a1002 2
    fn ([_,LAB lab],opts) =>
  EXP (Derived.make_select (lab,marks_of opts,make_hash_info(opts,lab)),Set.empty_set)
d1025 1
a1025 1
    fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1147 2
a1148 2
    fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1153 2
a1154 2
    fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1177 2
a1178 2
    fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
  EXP (Derived.make_while (exp1,exp2,make_while_info(opts),marks_of opts,get_current_pE()),Set.union(tyvars1,tyvars2))
d1251 3
a1253 2
    fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind (y,options_of opts)) (rev l)),tyvars,marks_of opts),pVE_in_pE pVE,Set.empty_set)
@


1.38.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.38  1993/08/27  15:19:03  matthew
Improved message for undefined constructors in patterns

@


1.38.1.2
log
@Added check on multiple occurences of variables in infix function declarations
@
text
@a3 3
Revision 1.38.1.1  1993/08/27  15:19:03  jont
Fork for bug fixing

d1404 4
a1407 4
    fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
(merge_pVEs(opts,pVE1,pVE2);FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id))
| ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
(merge_pVEs(opts,pVE1,pVE2);FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id))
@


1.38.1.3
log
@Removed option of giving a long id to require.
@
text
@a3 3
Revision 1.38.1.2  1993/10/06  15:20:06  matthew
Added check on multiple occurences of variables in infix function declarations

a938 1

d953 1
a953 1
     fn ([dec],opts) => dec
d958 1
a958 1
     fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d963 1
a963 1
     fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d971 1
a971 1
     fn ([_],opts) =>
d978 1
a978 1
     fn ([_,_],opts) => 
d985 1
a985 1
     fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d990 1
a990 1
     fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d995 1
a995 1
     fn ([_,LAB lab],opts) =>
d1000 1
a1000 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d1004 1
a1004 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d1009 1
a1009 1
     fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1014 1
a1014 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1019 1
a1019 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1024 1
a1024 1
     fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1029 1
a1029 1
     fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1035 1
a1035 1
     fn ([_,x,_],opts) => x
d1040 1
a1040 1
     fn ([_],opts) => ENV (get_current_pE())
d1045 1
a1045 1
     fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1050 1
a1050 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1055 1
a1055 1
     fn ([],opts) => EXPLIST ([],Set.empty_set)
d1060 1
a1060 1
     fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1065 1
a1065 1
     fn ([exp],opts) => exp
d1070 1
a1070 1
     fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1076 1
a1076 1
     fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1081 1
a1081 1
     fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1087 1
a1087 1
     fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1092 1
a1092 1
     fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1098 1
a1098 1
     fn ([x],opts) => x
d1103 1
a1103 1
     fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1109 1
a1109 1
     fn ([x],opts) => x
d1114 1
a1114 1
     fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1120 1
a1120 1
     fn ([x],opts) => x
d1125 1
a1125 1
     fn ([_],opts) => LONGVALID equal_lvalid
d1130 1
a1130 1
     fn ([x],opts) => x
d1135 1
a1135 1
     fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1141 1
a1141 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1147 1
a1147 1
     fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1153 1
a1153 1
     fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1159 1
a1159 1
     fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1165 1
a1165 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1171 1
a1171 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1177 1
a1177 1
     fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1183 1
a1183 1
     fn ([_,MATCH (match,tyvars)],opts) =>
d1189 1
a1189 1
     fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1194 1
a1194 1
     fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1200 1
a1200 1
    fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1205 1
a1205 1
     fn ([_,_],opts) => DUMMY
d1210 1
a1210 1
     fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1215 1
a1215 1
     fn ([_,dec,_],opts) => dec
d1220 1
a1220 1
     fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1225 1
a1225 1
     fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1230 1
a1230 1
     fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1239 1
a1239 1
     fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1245 1
a1245 1
     fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1251 1
a1251 1
     fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1258 1
a1258 1
     fn ([_,DATBIND (d,pVE)],opts) => 
d1264 1
a1264 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1272 1
a1272 1
     fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1278 1
a1278 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1284 1
a1284 1
     fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1289 1
a1289 1
     fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1295 1
a1295 1
     fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1304 1
a1304 1
     fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1312 1
a1312 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1317 1
a1317 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1322 1
a1322 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1327 1
a1327 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1332 1
a1332 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1339 1
a1339 1
     fn ([_],opts) => ENV (get_current_pE())
d1344 1
a1344 1
     fn ([x],opts) => x
d1349 1
a1349 1
     fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1355 1
a1355 1
     fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1361 1
a1361 1
     fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1367 1
a1367 1
     fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1375 1
a1375 1
     fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1381 1
a1381 1
     fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1387 1
a1387 1
     fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1393 1
a1393 1
     fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1399 1
a1399 1
    fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1407 1
a1407 1
     fn ([PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1415 1
a1415 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1423 1
a1423 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1431 1
a1431 1
     fn ([],opts) => NULLTYPE
d1436 1
a1436 1
     fn ([_,ty],opts) => ty
d1441 1
a1441 1
     fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1446 1
a1446 1
     fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1452 1
a1452 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1458 1
a1458 1
     fn ([],opts) => TYVARLIST []
d1463 1
a1463 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1468 1
a1468 1
     fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1473 1
a1473 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1478 1
a1478 1
     fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1483 1
a1483 1
     fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1488 1
a1488 1
     fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1494 1
a1494 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1501 1
a1501 1
     fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1506 1
a1506 1
     fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1512 1
a1512 1
        fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1518 1
a1518 1
     fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1523 1
a1523 1
     fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1529 1
a1529 1
        fn ([VALID id, TY (ty,tyvars)],opts) => 
d1537 1
a1537 1
     fn ([VALID id,_,LONGVALID id'],opts) => 
d1543 1
a1543 1
     fn ([],opts) => NULLTYPE
d1548 1
a1548 1
     fn ([_,x],opts) => x
d1553 1
a1553 1
     fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1558 1
a1558 1
     fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1565 1
a1565 1
       fn ([VALID id],opts) => 
d1571 1
a1571 1
     fn ([LONGVALID id],opts) => 
d1578 1
a1578 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1584 1
a1584 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1590 1
a1590 1
     fn ([_,_,_],opts) => 
d1596 1
a1596 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1601 1
a1601 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1606 1
a1606 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1611 1
a1611 1
     fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1616 1
a1616 1
     fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1621 1
a1621 1
     fn ([_,x,_],opts) => x
d1626 1
a1626 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1631 1
a1631 1
     fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1637 1
a1637 1
     fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1644 1
a1644 1
     fn ([x],opts) => x
d1649 1
a1649 1
     fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1655 1
a1655 1
     fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1661 1
a1661 1
     fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1666 1
a1666 1
     fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1673 1
a1673 1
     fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1678 1
a1678 1
     fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1688 1
a1688 1
     fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1698 1
a1698 1
     fn ([x],opts) => x
d1703 1
a1703 1
     fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1709 1
a1709 1
     fn ([VALID id, PAT (pat,pVE,tyvars)],opts) => 
d1716 1
a1716 1
     fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1723 1
a1723 1
     fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1728 1
a1728 1
       fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1738 1
a1738 1
     fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1743 1
a1743 1
     fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1748 1
a1748 1
     fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1753 1
a1753 1
     fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1758 1
a1758 1
     fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1763 1
a1763 1
     fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1768 1
a1768 1
     fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1773 1
a1773 1
     fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1778 1
a1778 1
     fn ([_,t,_],opts) => t
d1783 1
a1783 1
     fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1788 1
a1788 1
     fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1793 1
a1793 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1798 1
a1798 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1803 1
a1803 1
     fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1808 1
a1808 1
     fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1813 1
a1813 1
     fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1821 1
a1821 1
     fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1826 1
a1826 1
     fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1834 1
a1834 1
     fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1839 1
a1839 1
     fn ([LONGID id],opts) => LONGIDLIST[id]
d1846 1
a1846 1
     fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1851 1
a1851 1
     fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1858 1
a1858 1
     fn ([SYM sym],opts) => SYMLIST [sym]
d1863 1
a1863 1
     fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1870 1
a1870 1
     fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1875 1
a1875 1
     fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1880 1
a1880 1
     fn ([STRING s],opts) => SCON (Ident.STRING s)
d1887 1
a1887 1
     fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1894 1
a1894 1
     fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1901 1
a1901 1
     fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1906 1
a1906 1
     fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1911 1
a1911 1
     fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1916 1
a1916 1
     fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1921 1
a1921 1
     fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1928 1
a1928 1
     fn ([LONGID ([],s)],opts) => SYM s
d1935 1
a1935 1
     fn ([_],opts) => SYM equal_symbol
d1940 1
a1940 1
     fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1945 1
a1945 1
     fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1950 1
a1950 1
     fn ([SYM s],opts) => STRID(Ident.STRID s)
d1959 1
a1959 1
     fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1967 1
a1967 1
     fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1973 1
a1973 1
     fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1978 1
a1978 1
     fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d1984 1
a1984 1
     fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1990 1
a1990 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1996 1
a1996 1
     fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
d2001 1
a2001 1
     fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
d2006 1
a2006 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2012 1
a2012 1
     fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
d2017 1
a2017 1
     fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
d2022 1
a2022 1
     fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2028 1
a2028 1
     fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d2035 1
a2035 1
     fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d2040 1
a2040 1
     fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d2045 1
a2045 1
     fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2051 1
a2051 1
     fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2057 1
a2057 1
     fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2063 1
a2063 1
     fn ([_],opts) => ENV (get_current_pE())
d2068 1
a2068 1
     fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2073 1
a2073 1
     fn ([_,strdec,_],opts) => strdec
d2078 1
a2078 1
     fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2083 1
a2083 1
     fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2088 1
a2088 1
     fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2095 1
a2095 1
     fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2100 1
a2100 1
     fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2105 1
a2105 1
     fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2111 1
a2111 1
     fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2119 1
a2119 1
     fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2124 1
a2124 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2130 1
a2130 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2136 1
a2136 1
     fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2142 1
a2142 1
     fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2147 1
a2147 1
     fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2153 1
a2153 1
    fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2159 1
a2159 1
    fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2165 1
a2165 1
        fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2171 1
a2171 1
        fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
d2176 1
a2176 1
     fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2181 1
a2181 1
     fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2186 1
a2186 1
     fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2191 1
a2191 1
     fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2196 1
a2196 1
     fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2201 1
a2201 1
     fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2207 1
a2207 1
     fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2212 1
a2212 1
     fn ([_,spec,_],opts) => spec
d2217 1
a2217 1
     fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2222 1
a2222 1
     fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2228 1
a2228 1
     fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2236 1
a2236 1
     fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2241 1
a2241 1
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2246 1
a2246 1
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2251 1
a2251 1
     fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2256 1
a2256 1
     fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2261 1
a2261 1
     fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2266 1
a2266 1
     fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2271 1
a2271 1
     fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2277 1
a2277 1
     fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2282 1
a2282 1
     fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2288 1
a2288 1
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2293 1
a2293 1
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2298 1
a2298 1
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2303 1
a2303 1
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2308 1
a2308 1
     fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2313 1
a2313 1
     fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2318 1
a2318 1
     fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2323 1
a2323 1
     fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2329 1
a2329 1
     fn ([TYPDESC1 x],opts) => TYPDESC[x]
d2334 1
a2334 1
     fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2340 1
a2340 1
     fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
d2346 1
a2346 1
     fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2351 1
a2351 1
     fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2357 1
a2357 1
     fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2364 1
a2364 1
     fn ([x],opts) => x
d2369 1
a2369 1
     fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2375 1
a2375 1
        fn ([VALID con,TY(ty,tyvars)],opts) => 
d2383 1
a2383 1
     fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2388 1
a2388 1
     fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2394 1
a2394 1
        fn ([VALID excon,TY(ty,_)],opts) => 
d2402 1
a2402 1
     fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d2407 1
a2407 1
     fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2413 1
a2413 1
     fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2418 1
a2418 1
     fn ([x],opts) => x
d2423 1
a2423 1
     fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2428 1
a2428 1
     fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
d2433 1
a2433 1
     fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
d2438 1
a2438 1
     fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2443 1
a2443 1
     fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2448 1
a2448 1
     fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d2453 1
a2453 1
     fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d2458 1
a2458 1
     fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d2463 1
a2463 1
     fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2468 1
a2468 1
     fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d2473 1
a2473 1
     fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2479 1
a2479 1
     fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2485 1
a2485 1
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2491 1
a2491 1
    fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2497 1
a2497 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2503 1
a2503 1
        fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2509 1
a2509 1
     fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2515 1
a2515 1
     fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2521 1
a2521 1
     fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2530 1
a2530 1
     fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2535 1
a2535 1
     fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2540 1
a2540 1
     fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2545 1
a2545 1
     fn ([EXP(exp,tyvars)],opts) =>
d2549 5
d2556 2
a2557 2
     fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_unix_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 279,
d2561 2
a2562 2
     fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 280,
d2566 2
a2567 2
     fn ([x,_,_],opts) => x
 | _ => raise ActionError 281,
d2571 2
a2572 2
     fn ([_,x],opts) => x
 | _ => raise ActionError 282,
d2576 2
a2577 2
     fn ([x,_],opts) => x
 | _ => raise ActionError 283,
d2581 2
a2582 2
     fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 284,
d2588 2
a2589 2
     fn ([],opts) => DUMMY
 | _ => raise ActionError 285,
@


1.37
log
@Wired up nj_op_in_datatype option.
@
text
@d4 3
d544 8
a551 2
fun check_is_infix (opts,Ident.LONGVALID(Ident.NOPATH,id)) =
  let val sym = get_sym id
d553 5
a557 3
    if is_infix sym
      then
        ()
d559 4
a562 1
      error (opts,"Identifier " ^ Symbol.symbol_name sym ^ " is not infix")
a563 1
  | check_is_infix _ = () (* An error should have been reported elsewhere *)
d932 1
d947 1
a947 1
   fn ([dec],opts) => dec
d952 1
a952 1
   fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d957 1
a957 1
   fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d965 1
a965 1
   fn ([_],opts) =>
d972 1
a972 1
   fn ([_,_],opts) => 
d979 1
a979 1
   fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d984 1
a984 1
   fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d989 1
a989 1
   fn ([_,LAB lab],opts) =>
d994 1
a994 1
   fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d998 1
a998 1
   fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d1003 1
a1003 1
   fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d1008 1
a1008 1
   fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d1013 1
a1013 1
   fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d1018 1
a1018 1
   fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d1023 1
a1023 1
   fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d1029 1
a1029 1
   fn ([_,x,_],opts) => x
d1034 1
a1034 1
   fn ([_],opts) => ENV (get_current_pE())
d1039 1
a1039 1
   fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1044 1
a1044 1
   fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1049 1
a1049 1
   fn ([],opts) => EXPLIST ([],Set.empty_set)
d1054 1
a1054 1
   fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1059 1
a1059 1
   fn ([exp],opts) => exp
d1064 1
a1064 1
   fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1070 1
a1070 1
   fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1075 1
a1075 1
   fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1081 1
a1081 1
   fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1086 1
a1086 1
   fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1092 1
a1092 1
   fn ([x],opts) => x
d1097 1
a1097 1
   fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1103 1
a1103 1
   fn ([x],opts) => x
d1108 1
a1108 1
   fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1114 1
a1114 1
   fn ([x],opts) => x
d1119 1
a1119 1
   fn ([_],opts) => LONGVALID equal_lvalid
d1124 1
a1124 1
   fn ([x],opts) => x
d1129 1
a1129 1
   fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1135 1
a1135 1
   fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1141 1
a1141 1
   fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1147 1
a1147 1
   fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1153 1
a1153 1
   fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1159 1
a1159 1
   fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1165 1
a1165 1
   fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1171 1
a1171 1
   fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1177 1
a1177 1
   fn ([_,MATCH (match,tyvars)],opts) =>
d1183 1
a1183 1
   fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1188 1
a1188 1
   fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1194 1
a1194 1
  fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp,marks_of opts),Set.union(tyvars1,tyvars2))
d1199 1
a1199 1
   fn ([_,_],opts) => DUMMY
d1204 1
a1204 1
   fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1209 1
a1209 1
   fn ([_,dec,_],opts) => dec
d1214 1
a1214 1
   fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1219 1
a1219 1
   fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1224 1
a1224 1
   fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1233 1
a1233 1
   fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1239 1
a1239 1
   fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1245 1
a1245 1
   fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1252 1
a1252 1
   fn ([_,DATBIND (d,pVE)],opts) => 
d1258 1
a1258 1
   fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1266 1
a1266 1
   fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1272 1
a1272 1
   fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1278 1
a1278 1
   fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1283 1
a1283 1
   fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1289 1
a1289 1
   fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1298 1
a1298 1
   fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1306 1
a1306 1
   fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1311 1
a1311 1
   fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1316 1
a1316 1
   fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1321 1
a1321 1
   fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1326 1
a1326 1
   fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1333 1
a1333 1
   fn ([_],opts) => ENV (get_current_pE())
d1338 1
a1338 1
   fn ([x],opts) => x
d1343 1
a1343 1
   fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1349 1
a1349 1
   fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1355 1
a1355 1
   fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1361 1
a1361 1
   fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1369 1
a1369 1
   fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1375 1
a1375 1
   fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1381 1
a1381 1
   fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1387 1
a1387 1
   fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1393 1
a1393 1
  fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1401 1
a1401 1
   fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1409 1
a1409 1
   fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1417 1
a1417 1
   fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1425 1
a1425 1
   fn ([],opts) => NULLTYPE
d1430 1
a1430 1
   fn ([_,ty],opts) => ty
d1435 1
a1435 1
   fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1440 1
a1440 1
   fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1446 1
a1446 1
   fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1452 1
a1452 1
   fn ([],opts) => TYVARLIST []
d1457 1
a1457 1
   fn ([TYVAR t],opts) => TYVARLIST [t]
d1462 1
a1462 1
   fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1467 1
a1467 1
   fn ([TYVAR t],opts) => TYVARLIST [t]
d1472 1
a1472 1
   fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1477 1
a1477 1
   fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1482 1
a1482 1
   fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1488 1
a1488 1
   fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1495 1
a1495 1
   fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1500 1
a1500 1
   fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1506 1
a1506 1
      fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.Option.PRESENT ty),id,tyvars)
d1512 1
a1512 1
   fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1517 1
a1517 1
   fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1523 1
a1523 1
      fn ([VALID id, TY (ty,tyvars)],opts) => 
a1524 1

d1531 1
a1531 1
   fn ([VALID id,_,LONGVALID id'],opts) => 
d1537 1
a1537 1
   fn ([],opts) => NULLTYPE
d1542 1
a1542 1
   fn ([_,x],opts) => x
d1547 1
a1547 1
   fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1552 1
a1552 1
   fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1559 1
a1559 1
     fn ([VALID id],opts) => 
d1565 1
a1565 1
   fn ([LONGVALID id],opts) => 
d1572 1
a1572 1
   fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1578 1
a1578 1
   fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1584 1
a1584 1
   fn ([_,_,_],opts) => 
d1590 1
a1590 1
   fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1595 1
a1595 1
   fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1600 1
a1600 1
   fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1605 1
a1605 1
   fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1610 1
a1610 1
   fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1615 1
a1615 1
   fn ([_,x,_],opts) => x
d1620 1
a1620 1
   fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1625 1
a1625 1
   fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1631 1
a1631 1
   fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1638 1
a1638 1
   fn ([x],opts) => x
d1643 1
a1643 1
   fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1649 1
a1649 1
   fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1655 1
a1655 1
   fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1660 1
a1660 1
   fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1667 1
a1667 1
   fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1672 1
a1672 1
   fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1682 1
a1682 1
   fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1692 1
a1692 1
   fn ([x],opts) => x
d1697 1
a1697 1
   fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1701 7
d1710 2
a1711 3
   fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
  (check_is_constructor (opts,id);
   check_is_infix (opts,id);
d1713 1
a1713 1
 | _ => raise ActionError 130,
d1717 2
a1718 2
   fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 131,
d1722 1
a1722 1
     fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
a1723 1

d1726 1
a1726 1
 | _ => raise ActionError 132,
d1732 2
a1733 2
   fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 133,
d1737 2
a1738 2
   fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 134,
d1742 2
a1743 2
   fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 135,
d1747 2
a1748 2
   fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
 | _ => raise ActionError 136,
d1752 2
a1753 2
   fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
 | _ => raise ActionError 137,
d1757 2
a1758 2
   fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
 | _ => raise ActionError 138,
d1762 2
a1763 2
   fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 139,
d1767 2
a1768 2
   fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 140,
d1772 2
a1773 2
   fn ([_,t,_],opts) => t
 | _ => raise ActionError 141,
d1777 2
a1778 2
   fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 142,
d1782 2
a1783 2
   fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 143,
d1787 2
a1788 2
   fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 144,
d1792 2
a1793 2
   fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 145,
d1797 2
a1798 2
   fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 146,
d1802 2
a1803 2
   fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 147,
d1807 1
a1807 1
   fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1809 1
a1809 1
 | _ => raise ActionError 148,
d1815 2
a1816 2
   fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 149,
d1820 1
a1820 1
   fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1822 1
a1822 1
 | _ => raise ActionError 150,
d1828 2
a1829 2
   fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 151,
d1833 2
a1834 2
   fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 152,
d1840 2
a1841 2
   fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 153,
d1845 2
a1846 2
   fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 154,
d1852 2
a1853 2
   fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 155,
d1857 2
a1858 2
   fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 156,
d1864 2
a1865 2
   fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
 | _ => raise ActionError 157,
d1869 2
a1870 2
   fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
 | _ => raise ActionError 158,
d1874 2
a1875 2
   fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 159,
d1881 1
a1881 1
   fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1884 1
a1884 1
 | _ => raise ActionError 160,
d1888 2
a1889 2
   fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 161,
d1895 2
a1896 2
   fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 162,
d1900 2
a1901 2
   fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 163,
d1905 2
a1906 2
   fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 164,
d1910 2
a1911 2
   fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 165,
d1915 2
a1916 2
   fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 166,
d1922 1
a1922 1
   fn ([LONGID ([],s)],opts) => SYM s
d1925 1
a1925 1
 | _ => raise ActionError 167,
d1929 2
a1930 2
   fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 168,
d1934 2
a1935 2
   fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 169,
d1939 2
a1940 2
   fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 170,
d1944 2
a1945 2
   fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 171,
d1953 1
a1953 1
   fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1955 1
a1955 1
 | _ => raise ActionError 172,
d1961 1
a1961 1
   fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1963 1
a1963 1
 | _ => raise ActionError 173,
d1967 2
a1968 2
   fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 174,
d1972 2
a1973 2
   fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 175,
d1978 1
a1978 1
   fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1980 1
a1980 1
 | _ => raise ActionError 176,
d1984 1
a1984 1
   fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1986 1
a1986 1
 | _ => raise ActionError 177,
d1990 2
a1991 2
   fn ([valid as (VALID con)],opts) => (check_non_conid_op(opts,con); valid)
 | _ => raise ActionError 178,
d1995 2
a1996 2
   fn ([_,valid as (VALID con)],opts) => (check_conid_op(opts,con); valid)
 | _ => raise ActionError 179,
d2000 1
a2000 1
   fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d2002 1
a2002 1
 | _ => raise ActionError 180,
d2006 2
a2007 2
   fn ([valid as (VALID excon)],opts) => (check_non_conid_op(opts,excon); valid)
 | _ => raise ActionError 181,
d2011 2
a2012 2
   fn ([_,valid as (VALID excon)],opts) => (check_conid_op(opts,excon); valid)
 | _ => raise ActionError 182,
d2016 1
a2016 1
   fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d2018 1
a2018 1
 | _ => raise ActionError 183,
d2022 2
a2023 2
   fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 184,
d2029 2
a2030 2
   fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 185,
d2034 2
a2035 2
   fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
 | _ => raise ActionError 186,
d2039 1
a2039 1
   fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2041 1
a2041 1
 | _ => raise ActionError 187,
d2045 1
a2045 1
   fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2047 1
a2047 1
 | _ => raise ActionError 188,
d2051 1
a2051 1
   fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2053 1
a2053 1
 | _ => raise ActionError 189,
d2057 2
a2058 2
   fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 190,
d2062 2
a2063 2
   fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 191,
d2067 2
a2068 2
   fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 192,
d2072 2
a2073 2
   fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 193,
d2077 2
a2078 2
   fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 194,
d2082 2
a2083 2
   fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 195,
d2089 2
a2090 2
   fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 196,
d2094 2
a2095 2
   fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 197,
d2099 1
a2099 1
   fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2101 1
a2101 1
 | _ => raise ActionError 198,
d2105 1
a2105 1
   fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2107 1
a2107 1
 | _ => raise ActionError 199,
d2113 2
a2114 2
   fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 200,
d2118 1
a2118 1
   fn ([_,STRBIND(l,pSE)],opts) => 
d2120 1
a2120 1
 | _ => raise ActionError 201,
d2124 1
a2124 1
   fn ([_,STRBIND(l,pSE)],opts) => 
d2126 1
a2126 1
 | _ => raise ActionError 202,
d2130 1
a2130 1
   fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2132 1
a2132 1
 | _ => raise ActionError 203,
d2136 2
a2137 2
   fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 204,
d2141 1
a2141 1
   fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2143 1
a2143 1
 | _ => raise ActionError 205,
d2147 1
a2147 1
  fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2149 1
a2149 1
 | _ => raise ActionError 206,
d2153 1
a2153 1
  fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2155 1
a2155 1
 | _ => raise ActionError 207,
d2159 1
a2159 1
      fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2161 1
a2161 1
 | _ => raise ActionError 208,
d2165 2
a2166 2
      fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.Option.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 209,
d2170 2
a2171 2
   fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
 | _ => raise ActionError 210,
d2175 2
a2176 2
   fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 211,
d2180 2
a2181 2
   fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 212,
d2185 2
a2186 2
   fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 213,
d2190 2
a2191 2
   fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 214,
d2195 1
a2195 1
   fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2197 1
a2197 1
 | _ => raise ActionError 215,
d2201 2
a2202 2
   fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 216,
d2206 2
a2207 2
   fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 217,
d2211 2
a2212 2
   fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 218,
d2216 1
a2216 1
   fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2218 1
a2218 1
 | _ => raise ActionError 219,
d2222 1
a2222 1
   fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2224 1
a2224 1
 | _ => raise ActionError 220,
d2230 2
a2231 2
   fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 221,
d2235 2
a2236 2
   fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 222,
d2240 2
a2241 2
   fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 223,
d2245 2
a2246 2
   fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 224,
d2250 2
a2251 2
   fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 225,
d2255 2
a2256 2
   fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 226,
d2260 2
a2261 2
   fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 227,
d2265 1
a2265 1
   fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2267 1
a2267 1
 | _ => raise ActionError 228,
d2271 2
a2272 2
   fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 229,
d2276 2
a2277 2
   fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 230,
d2282 2
a2283 2
     fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 231,
d2287 2
a2288 2
     fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 232,
d2292 2
a2293 2
     fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 233,
d2297 2
a2298 2
     fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 234,
d2302 2
a2303 2
   fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 235,
d2307 2
a2308 2
   fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 236,
d2312 2
a2313 2
   fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 237,
d2317 1
a2317 1
   fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2319 1
a2319 1
 | _ => raise ActionError 238,
d2323 2
a2324 2
   fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 239,
d2328 1
a2328 1
   fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2330 1
a2330 1
 | _ => raise ActionError 240,
d2334 2
a2335 2
   fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 241,
d2340 2
a2341 2
   fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 242,
d2345 1
a2345 1
   fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2347 1
a2347 1
 | _ => raise ActionError 243,
d2351 1
a2351 1
   fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2354 1
a2354 1
 | _ => raise ActionError 244,
d2358 2
a2359 2
   fn ([x],opts) => x
 | _ => raise ActionError 245,
d2363 1
a2363 1
   fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2365 1
a2365 1
 | _ => raise ActionError 246,
d2369 1
a2369 1
      fn ([VALID con,TY(ty,tyvars)],opts) => 
d2373 1
a2373 1
 | _ => raise ActionError 247,
d2377 2
a2378 2
   fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 248,
d2382 1
a2382 1
   fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2384 1
a2384 1
 | _ => raise ActionError 249,
d2388 1
a2388 1
      fn ([VALID excon,TY(ty,_)],opts) => 
d2392 1
a2392 1
 | _ => raise ActionError 250,
d2396 2
a2397 2
   fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 251,
d2401 1
a2401 1
   fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2403 1
a2403 1
 | _ => raise ActionError 252,
d2407 2
a2408 2
   fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 253,
d2412 2
a2413 2
   fn ([x],opts) => x
 | _ => raise ActionError 254,
d2417 2
a2418 2
   fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 255,
d2422 2
a2423 2
   fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 256,
d2427 2
a2428 2
   fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 257,
d2432 2
a2433 2
   fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 258,
d2437 2
a2438 2
   fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 259,
d2442 2
a2443 2
   fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 260,
d2447 2
a2448 2
   fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 261,
d2452 2
a2453 2
   fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 262,
d2457 2
a2458 2
   fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 263,
d2462 2
a2463 2
   fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 264,
d2467 1
a2467 1
   fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2469 1
a2469 1
 | _ => raise ActionError 265,
d2473 1
a2473 1
   fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2475 1
a2475 1
 | _ => raise ActionError 266,
d2479 1
a2479 1
  fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2481 1
a2481 1
 | _ => raise ActionError 267,
d2485 1
a2485 1
  fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2487 1
a2487 1
 | _ => raise ActionError 268,
d2491 1
a2491 1
      fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2493 1
a2493 1
 | _ => raise ActionError 269,
d2497 1
a2497 1
      fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2499 1
a2499 1
 | _ => raise ActionError 270,
d2503 1
a2503 1
   fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2505 1
a2505 1
 | _ => raise ActionError 271,
d2509 1
a2509 1
   fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2511 1
a2511 1
 | _ => raise ActionError 272,
d2515 2
a2516 2
   fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 273,
d2524 2
a2525 2
   fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 274,
d2529 2
a2530 2
   fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 275,
d2534 2
a2535 2
   fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 276,
d2539 1
a2539 1
   fn ([EXP(exp,tyvars)],opts) =>
d2541 1
a2541 1
 | _ => raise ActionError 277,
d2545 2
a2546 2
   fn ([_,LONGID (l, s)],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.create (l, s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 278,
d2550 2
a2551 2
   fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.from_unix_string (s, marks_of opts), marks_of opts),PE.empty_pB)
 | _ => raise ActionError 279,
d2555 2
a2556 2
   fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 280,
d2560 2
a2561 2
   fn ([x,_,_],opts) => x
 | _ => raise ActionError 281,
d2565 2
a2566 2
   fn ([_,x],opts) => x
 | _ => raise ActionError 282,
d2570 2
a2571 2
   fn ([x,_],opts) => x
 | _ => raise ActionError 283,
d2575 2
a2576 2
   fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 284,
d2582 2
a2583 2
   fn ([],opts) => DUMMY
 | _ => raise ActionError 285,
d2691 3
@


1.36
log
@Use new ModuleId.create to check that moduleids are alphanumeric.
@
text
@d4 3
d277 3
d815 12
d1972 1
a1972 1
   fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
d1977 1
a1977 1
   fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
d1988 1
a1988 1
   fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
d1993 1
a1993 1
   fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
@


1.35
log
@Require declarations now take moduleids instead of strings.
@
text
@d4 3
d2509 1
a2509 1
   fn ([_,LONGID (l, s)],opts) => TOPDEC (Absyn.REQUIREtopdec (ModuleId.MODID (rev l, s), marks_of opts),PE.empty_pB)
@


1.34
log
@Added location information to matches
@
text
@d4 3
d99 1
d114 1
d119 3
d897 1
d912 1
a912 1
  fn ([dec],opts) => dec
d917 1
a917 1
  fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d922 1
a922 1
  fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d930 1
a930 1
  fn ([_],opts) =>
d937 1
a937 1
  fn ([_,_],opts) => 
d944 1
a944 1
  fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d949 1
a949 1
  fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d954 1
a954 1
  fn ([_,LAB lab],opts) =>
d959 1
a959 1
  fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d963 1
a963 1
  fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d968 1
a968 1
  fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d973 1
a973 1
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d978 1
a978 1
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d983 1
a983 1
  fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d988 1
a988 1
  fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d994 1
a994 1
  fn ([_,x,_],opts) => x
d999 1
a999 1
  fn ([_],opts) => ENV (get_current_pE())
d1004 1
a1004 1
  fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d1009 1
a1009 1
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d1014 1
a1014 1
  fn ([],opts) => EXPLIST ([],Set.empty_set)
d1019 1
a1019 1
  fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d1024 1
a1024 1
  fn ([exp],opts) => exp
d1029 1
a1029 1
  fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1035 1
a1035 1
  fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1040 1
a1040 1
  fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1046 1
a1046 1
  fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1051 1
a1051 1
  fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1057 1
a1057 1
  fn ([x],opts) => x
d1062 1
a1062 1
  fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1068 1
a1068 1
  fn ([x],opts) => x
d1073 1
a1073 1
  fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1079 1
a1079 1
  fn ([x],opts) => x
d1084 1
a1084 1
  fn ([_],opts) => LONGVALID equal_lvalid
d1089 1
a1089 1
  fn ([x],opts) => x
d1094 1
a1094 1
  fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1100 1
a1100 1
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1106 1
a1106 1
  fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1112 1
a1112 1
  fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1118 1
a1118 1
  fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1124 1
a1124 1
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1130 1
a1130 1
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1136 1
a1136 1
  fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1142 1
a1142 1
  fn ([_,MATCH (match,tyvars)],opts) =>
d1148 1
a1148 1
  fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1153 1
a1153 1
  fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1164 1
a1164 1
  fn ([_,_],opts) => DUMMY
d1169 1
a1169 1
  fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1174 1
a1174 1
  fn ([_,dec,_],opts) => dec
d1179 1
a1179 1
  fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1184 1
a1184 1
  fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1189 1
a1189 1
  fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1198 1
a1198 1
  fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1204 1
a1204 1
  fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1210 1
a1210 1
  fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1217 1
a1217 1
  fn ([_,DATBIND (d,pVE)],opts) => 
d1223 1
a1223 1
  fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1231 1
a1231 1
  fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1237 1
a1237 1
  fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1243 1
a1243 1
  fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1248 1
a1248 1
  fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1254 1
a1254 1
  fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1263 1
a1263 1
  fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1271 1
a1271 1
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1276 1
a1276 1
  fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1281 1
a1281 1
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1286 1
a1286 1
  fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1291 1
a1291 1
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1298 1
a1298 1
  fn ([_],opts) => ENV (get_current_pE())
d1303 1
a1303 1
  fn ([x],opts) => x
d1308 1
a1308 1
  fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1314 1
a1314 1
  fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1320 1
a1320 1
  fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1326 1
a1326 1
  fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1334 1
a1334 1
  fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1340 1
a1340 1
  fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1346 1
a1346 1
  fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1352 1
a1352 1
  fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1366 1
a1366 1
  fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1374 1
a1374 1
  fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1382 1
a1382 1
  fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1390 1
a1390 1
  fn ([],opts) => NULLTYPE
d1395 1
a1395 1
  fn ([_,ty],opts) => ty
d1400 1
a1400 1
  fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1405 1
a1405 1
  fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1411 1
a1411 1
  fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1417 1
a1417 1
  fn ([],opts) => TYVARLIST []
d1422 1
a1422 1
  fn ([TYVAR t],opts) => TYVARLIST [t]
d1427 1
a1427 1
  fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1432 1
a1432 1
  fn ([TYVAR t],opts) => TYVARLIST [t]
d1437 1
a1437 1
  fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1442 1
a1442 1
  fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1447 1
a1447 1
  fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1453 1
a1453 1
  fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1460 1
a1460 1
  fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1465 1
a1465 1
  fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1477 1
a1477 1
  fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1482 1
a1482 1
  fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1497 1
a1497 1
  fn ([VALID id,_,LONGVALID id'],opts) => 
d1503 1
a1503 1
  fn ([],opts) => NULLTYPE
d1508 1
a1508 1
  fn ([_,x],opts) => x
d1513 1
a1513 1
  fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1518 1
a1518 1
  fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1531 1
a1531 1
  fn ([LONGVALID id],opts) => 
d1538 1
a1538 1
  fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1544 1
a1544 1
  fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1550 1
a1550 1
  fn ([_,_,_],opts) => 
d1556 1
a1556 1
  fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1561 1
a1561 1
  fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1566 1
a1566 1
  fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1571 1
a1571 1
  fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1576 1
a1576 1
  fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1581 1
a1581 1
  fn ([_,x,_],opts) => x
d1586 1
a1586 1
  fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1591 1
a1591 1
  fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1597 1
a1597 1
  fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1604 1
a1604 1
  fn ([x],opts) => x
d1609 1
a1609 1
  fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1615 1
a1615 1
  fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1621 1
a1621 1
  fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1626 1
a1626 1
  fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1633 1
a1633 1
  fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1638 1
a1638 1
  fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1648 1
a1648 1
  fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1658 1
a1658 1
  fn ([x],opts) => x
d1663 1
a1663 1
  fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1669 1
a1669 1
  fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1677 1
a1677 1
  fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1693 1
a1693 1
  fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1698 1
a1698 1
  fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1703 1
a1703 1
  fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1708 1
a1708 1
  fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1713 1
a1713 1
  fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1718 1
a1718 1
  fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1723 1
a1723 1
  fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1728 1
a1728 1
  fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1733 1
a1733 1
  fn ([_,t,_],opts) => t
d1738 1
a1738 1
  fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1743 1
a1743 1
  fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1748 1
a1748 1
  fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1753 1
a1753 1
  fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1758 1
a1758 1
  fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1763 1
a1763 1
  fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1768 1
a1768 1
  fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1776 1
a1776 1
  fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1781 1
a1781 1
  fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1789 1
a1789 1
  fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1794 1
a1794 1
  fn ([LONGID id],opts) => LONGIDLIST[id]
d1801 1
a1801 1
  fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1806 1
a1806 1
  fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1813 1
a1813 1
  fn ([SYM sym],opts) => SYMLIST [sym]
d1818 1
a1818 1
  fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1825 1
a1825 1
  fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1830 1
a1830 1
  fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1835 1
a1835 1
  fn ([STRING s],opts) => SCON (Ident.STRING s)
d1842 1
a1842 1
  fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1849 1
a1849 1
  fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1856 1
a1856 1
  fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1861 1
a1861 1
  fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1866 1
a1866 1
  fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1871 1
a1871 1
  fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1876 1
a1876 1
  fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1883 1
a1883 1
  fn ([LONGID ([],s)],opts) => SYM s
d1890 1
a1890 1
  fn ([_],opts) => SYM equal_symbol
d1895 1
a1895 1
  fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1900 1
a1900 1
  fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1905 1
a1905 1
  fn ([SYM s],opts) => STRID(Ident.STRID s)
d1914 1
a1914 1
  fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1922 1
a1922 1
  fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1928 1
a1928 1
  fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1933 1
a1933 1
  fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d1939 1
a1939 1
  fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1945 1
a1945 1
  fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1951 1
a1951 1
  fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
d1956 1
a1956 1
  fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
d1961 1
a1961 1
  fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d1967 1
a1967 1
  fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
d1972 1
a1972 1
  fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
d1977 1
a1977 1
  fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d1983 1
a1983 1
  fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d1990 1
a1990 1
  fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d1995 1
a1995 1
  fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d2000 1
a2000 1
  fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d2006 1
a2006 1
  fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d2012 1
a2012 1
  fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d2018 1
a2018 1
  fn ([_],opts) => ENV (get_current_pE())
d2023 1
a2023 1
  fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2028 1
a2028 1
  fn ([_,strdec,_],opts) => strdec
d2033 1
a2033 1
  fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2038 1
a2038 1
  fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2043 1
a2043 1
  fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2050 1
a2050 1
  fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2055 1
a2055 1
  fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2060 1
a2060 1
  fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2066 1
a2066 1
  fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2074 1
a2074 1
  fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2079 1
a2079 1
  fn ([_,STRBIND(l,pSE)],opts) => 
d2085 1
a2085 1
  fn ([_,STRBIND(l,pSE)],opts) => 
d2091 1
a2091 1
  fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2097 1
a2097 1
  fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
d2102 1
a2102 1
  fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2131 1
a2131 1
  fn ([_],opts) => let val pE = get_current_pE() in set_pE (zap_for_sig pE); ENV pE end
d2136 1
a2136 1
  fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2141 1
a2141 1
  fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2146 1
a2146 1
  fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2151 1
a2151 1
  fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2156 1
a2156 1
  fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2162 1
a2162 1
  fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2167 1
a2167 1
  fn ([_,spec,_],opts) => spec
d2172 1
a2172 1
  fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2177 1
a2177 1
  fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2183 1
a2183 1
  fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2191 1
a2191 1
  fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2196 1
a2196 1
  fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2201 1
a2201 1
  fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2206 1
a2206 1
  fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2211 1
a2211 1
  fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2216 1
a2216 1
  fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2221 1
a2221 1
  fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2226 1
a2226 1
  fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2232 1
a2232 1
  fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2237 1
a2237 1
  fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2243 1
a2243 1
    fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
d2248 1
a2248 1
    fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
d2253 1
a2253 1
    fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
d2258 1
a2258 1
    fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
d2263 1
a2263 1
  fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2268 1
a2268 1
  fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2273 1
a2273 1
  fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2278 1
a2278 1
  fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2284 1
a2284 1
  fn ([TYPDESC1 x],opts) => TYPDESC[x]
d2289 1
a2289 1
  fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2295 1
a2295 1
  fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
d2301 1
a2301 1
  fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2306 1
a2306 1
  fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2312 1
a2312 1
  fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2319 1
a2319 1
  fn ([x],opts) => x
d2324 1
a2324 1
  fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2338 1
a2338 1
  fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2343 1
a2343 1
  fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2357 1
a2357 1
  fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
d2362 1
a2362 1
  fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2368 1
a2368 1
  fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2373 1
a2373 1
  fn ([x],opts) => x
d2378 1
a2378 1
  fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2383 1
a2383 1
  fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
d2388 1
a2388 1
  fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
d2393 1
a2393 1
  fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2398 1
a2398 1
  fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2403 1
a2403 1
  fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d2408 1
a2408 1
  fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d2413 1
a2413 1
  fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d2418 1
a2418 1
  fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2423 1
a2423 1
  fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d2428 1
a2428 1
  fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2434 1
a2434 1
  fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2464 1
a2464 1
  fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2470 1
a2470 1
  fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2476 1
a2476 1
  fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2485 1
a2485 1
  fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2490 1
a2490 1
  fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2495 1
a2495 1
  fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2500 1
a2500 1
  fn ([EXP(exp,tyvars)],opts) =>
d2504 5
d2511 2
a2512 2
  fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 278,
d2516 2
a2517 2
  fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 279,
d2521 2
a2522 2
  fn ([x,_,_],opts) => x
 | _ => raise ActionError 280,
d2526 2
a2527 2
  fn ([_,x],opts) => x
 | _ => raise ActionError 281,
d2531 2
a2532 2
  fn ([x,_],opts) => x
 | _ => raise ActionError 282,
d2536 2
a2537 2
  fn ([_],opts) => raise (FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB))
 | _ => raise ActionError 283,
d2539 2
a2540 1
(* ;; New bit  *)
d2543 2
a2544 2
  fn ([],opts) => DUMMY
 | _ => raise ActionError 284,
@


1.33
log
@structure Option.
@
text
@d4 3
d140 1
a140 1
  type PatExp = Absyn.Pat * Absyn.Exp
d144 1
a144 1
  type FVal = Ident.ValId * Absyn.Pat list * Absyn.Exp
d850 1
a850 1
   ((id,(Derived.make_tuple_pat [pat1,pat2]) :: patlist,exp),join_tyvars tvarlist))
d1150 1
a1150 1
  fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d1350 1
a1350 1
 FVAL(((id,rev l,Absyn.TYPEDexp(exp,ty,marks_of opts)),join_tyvars[tyvars1,tyvars2,tyvars3]),id)
d1352 1
a1352 1
   FVAL(((id,rev l,exp),Set.union(tyvars1,tyvars3)),id)
@


1.32
log
@Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.
@
text
@d4 4
d140 1
a140 1
  type ConBind = ((Ident.ValId * TypeRef) * Absyn.Ty Absyn.opt)
d144 3
a146 3
  type ConType = Ident.ValId * Absyn.Ty Absyn.opt
  type ExType = Ident.ValId * Absyn.Ty Absyn.opt * Location.T
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * string * bool ref * Location.T)
d211 2
a212 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * bool ref * Location.T) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * bool ref * Location.T) * (Ident.StrId * PE.pE))
d250 2
a251 2
  | OPTsigexp of Absyn.SigExp Absyn.opt
(*  | OPTOFTYPE of Absyn.Ty Absyn.opt *)
d798 1
d855 1
a855 1
                         Absyn.NEWsigexp(spec,ref Absyn.ABSENT),
d1459 2
a1460 2
  fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
| ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,Absyn.ABSENT),id,Set.empty_set)
d1476 3
a1478 2
  fn ([VALID id, TY (ty,tyvars)],opts) => 
  EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.PRESENT ty,marks_of opts,make_exbind_info(opts,id)),id,tyvars)
d1480 1
a1480 1
  EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.ABSENT,marks_of opts,make_exbind_info(opts,id)),id,Set.empty_set)
d1513 2
a1514 2
  fn ([VALID id],opts) => 
  PAT (Absyn.VALpat (annotate (make_long_id id),marks_of opts),make_pVE id,Set.empty_set)
d1521 1
a1521 1
   PAT (Absyn.VALpat (annotate id,marks_of opts),PE.empty_pVE,Set.empty_set))
d1628 1
a1628 1
   PATROW1 ((Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.ABSENT,marks_of opts)),make_Sym_pVE sym,tyvars))
d1631 1
a1631 1
   PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.ABSENT,marks_of opts),make_Sym_pVE sym,Set.empty_set))
d1638 1
a1638 1
   PATROW1 (Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
d1641 1
a1641 1
   PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),tyvars))
d1670 3
a1672 2
  fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
  PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate id, pat), ty,marks_of opts),addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
d1674 1
a1674 1
  PAT (Absyn.LAYEREDpat (annotate id, pat),addNewValId(opts,id,pVE),tyvars)
d2097 1
a2097 1
  STRBIND1((id,Absyn.PRESENT sigexp,strexp,ref false,marks_of opts),(id,pE1))
d2103 1
a2103 1
  STRBIND1((id,Absyn.ABSENT,strexp,ref false,marks_of opts),(id,pE))
d2108 2
a2109 2
  fn ([ENV pE,SPEC (spec,e),_],opts) => 
  (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref Absyn.ABSENT),e))
d2114 1
a2114 1
  fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.ABSENT,marks_of opts),lookupSigId(opts,id))
d2318 2
a2319 2
  fn ([VALID con,TY(ty,tyvars)],opts) => 
  CONDESC([(con,Absyn.PRESENT ty)],make_pVE con,tyvars)
d2321 1
a2321 1
  CONDESC([(con,Absyn.ABSENT)],make_pVE con,Set.empty_set)
d2337 2
a2338 2
  fn ([VALID excon,TY(ty,_)],opts) => 
  EXDESC1(excon,Absyn.PRESENT ty,marks_of opts)
d2340 1
a2340 1
  EXDESC1(excon,Absyn.ABSENT,marks_of opts)
d2429 1
a2429 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.PRESENT sigexp',make_funbind_info(opts,funid),ref false,marks_of opts),funid,pE''))
d2435 1
a2435 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.ABSENT,make_funbind_info (opts,funid),ref false,marks_of opts),funid,pE'''))
d2440 2
a2441 2
  fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.PRESENT sigexp,strexp,pE''))
d2446 2
a2447 2
  fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
(set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.ABSENT,strexp,pE'''))
@


1.31
log
@Fixed problem with undefined structure names in signatures.
@
text
@d4 3
d142 1
a142 1
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * string * Location.T)
d207 2
a208 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Location.T) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Location.T) * (Ident.StrId * PE.pE))
d855 1
a855 1
    FUNBIND1 ((a,b,c,d,f,make_funbind_info(opts,funid),marks_of opts),funid,pE)
d1982 1
a1982 1
  STREXP (Absyn.APPstrexp (funid,strexp,marks_of opts),lookupFunId (opts,funid))
d1988 1
a1988 1
  STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,marks_of opts),lookupFunId (opts,funid))
d2090 1
a2090 1
  STRBIND1((id,Absyn.PRESENT sigexp,strexp,marks_of opts),(id,pE1))
d2096 1
a2096 1
  STRBIND1((id,Absyn.ABSENT,strexp,marks_of opts),(id,pE))
d2422 1
a2422 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.PRESENT sigexp',make_funbind_info(opts,funid),marks_of opts),funid,pE''))
d2428 1
a2428 1
(set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.ABSENT,make_funbind_info (opts,funid),marks_of opts),funid,pE'''))
@


1.30
log
@Changed to allow no semicolons between topdecs
@
text
@d4 3
d440 6
d814 1
a814 1
    val pEs = map (fn x => lookupStrId(opts,x)) longids
d2109 1
a2109 1
  fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
@


1.29
log
@Extended grammar for NJ compatibility
@
text
@d4 3
a868 2


d881 1
a881 1
(*       '(((START PROGRAM))  *)
d883 1
a883 1
         fn ([dec],opts) => dec
d888 1
a888 1
         fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d893 1
a893 1
         fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d901 1
a901 1
         fn ([_],opts) =>
d908 1
a908 1
         fn ([_,_],opts) => 
d915 1
a915 1
         fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d920 1
a920 1
         fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d925 1
a925 1
         fn ([_,LAB lab],opts) =>
d930 1
a930 1
         fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d934 1
a934 1
         fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d939 1
a939 1
         fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d944 1
a944 1
         fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d949 1
a949 1
         fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d954 1
a954 1
         fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d959 1
a959 1
         fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d965 1
a965 1
         fn ([_,x,_],opts) => x
d970 1
a970 1
         fn ([_],opts) => ENV (get_current_pE())
d975 1
a975 1
         fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d980 1
a980 1
         fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d985 1
a985 1
         fn ([],opts) => EXPLIST ([],Set.empty_set)
d990 1
a990 1
         fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d995 1
a995 1
         fn ([exp],opts) => exp
d1000 1
a1000 1
         fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1006 1
a1006 1
         fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1011 1
a1011 1
         fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1017 1
a1017 1
         fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1022 1
a1022 1
         fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1028 1
a1028 1
         fn ([x],opts) => x
d1033 1
a1033 1
         fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1039 1
a1039 1
         fn ([x],opts) => x
d1044 1
a1044 1
         fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1050 1
a1050 1
         fn ([x],opts) => x
d1055 1
a1055 1
         fn ([_],opts) => LONGVALID equal_lvalid
d1060 1
a1060 1
         fn ([x],opts) => x
d1065 1
a1065 1
         fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1071 1
a1071 1
         fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1077 1
a1077 1
         fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1083 1
a1083 1
         fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1089 1
a1089 1
         fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1095 1
a1095 1
         fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1101 1
a1101 1
         fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1107 1
a1107 1
         fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1113 1
a1113 1
         fn ([_,MATCH (match,tyvars)],opts) =>
d1119 1
a1119 1
         fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1124 1
a1124 1
         fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1128 1
a1128 1
(* 	                        ;; Use to augment environment.  *)
d1130 1
a1130 1
         fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d1133 1
a1133 2
(* ;; New bit  *)
(*         ((DECSEP))  *)
d1135 1
a1135 1
         fn ([],opts) => DUMMY
d1138 1
a1138 1
(* 	((DECSEP DECSEP :semicolon))  *)
d1140 1
a1140 1
         fn ([_,_],opts) => DUMMY
d1143 1
a1143 1
(* 	((DEC DECSEP))  *)
d1145 1
a1145 1
         fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1148 1
a1148 1
(* 	((DEC DECSEP DEC1 DECSEP))  *)
d1150 1
a1150 1
         fn ([_,dec,_],opts) => dec
d1153 1
a1153 1
(* 	((DEC DECSEP DEC0 DECSEP))  *)
d1155 1
a1155 1
         fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1158 1
a1158 1
(* 	((DEC0 DEC1 DECSEP DEC1))  *)
d1160 1
a1160 1
         fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
a1162 5
(* 	((DEC0 DEC0 DECSEP DEC1))  *)

         fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 52,

d1169 1
a1169 1
         fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1171 1
a1171 1
 | _ => raise ActionError 53,
d1175 1
a1175 1
         fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1177 1
a1177 1
 | _ => raise ActionError 54,
d1181 2
a1182 2
         fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 55,
d1188 1
a1188 1
         fn ([_,DATBIND (d,pVE)],opts) => 
d1190 1
a1190 1
 | _ => raise ActionError 56,
d1194 1
a1194 1
         fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1198 1
a1198 1
 | _ => raise ActionError 57,
d1202 1
a1202 1
         fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1204 1
a1204 1
 | _ => raise ActionError 58,
d1208 1
a1208 1
         fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1211 1
a1211 1
 | _ => raise ActionError 59,
d1214 2
a1215 2
         fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
 | _ => raise ActionError 60,
d1219 1
a1219 1
         fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1221 1
a1221 1
 | _ => raise ActionError 61,
d1225 1
a1225 1
         fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1228 1
a1228 1
 | _ => raise ActionError 62,
d1234 2
a1235 2
         fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
 | _ => raise ActionError 63,
d1242 2
a1243 2
         fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
 | _ => raise ActionError 64,
d1247 2
a1248 2
         fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
 | _ => raise ActionError 65,
d1252 2
a1253 2
         fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
 | _ => raise ActionError 66,
d1257 2
a1258 2
         fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
 | _ => raise ActionError 67,
d1262 2
a1263 2
         fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
 | _ => raise ActionError 68,
d1269 2
a1270 2
         fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 69,
d1274 2
a1275 2
         fn ([x],opts) => x
 | _ => raise ActionError 70,
d1279 1
a1279 1
         fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1281 1
a1281 1
 | _ => raise ActionError 71,
d1285 1
a1285 1
         fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1287 1
a1287 1
 | _ => raise ActionError 72,
d1291 1
a1291 1
         fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1293 1
a1293 1
 | _ => raise ActionError 73,
d1297 1
a1297 1
         fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1299 1
a1299 1
 | _ => raise ActionError 74,
d1305 1
a1305 1
         fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1307 1
a1307 1
 | _ => raise ActionError 75,
d1311 1
a1311 1
         fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1313 1
a1313 1
 | _ => raise ActionError 76,
d1317 2
a1318 2
         fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
 | _ => raise ActionError 77,
d1323 1
a1323 1
         fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1325 1
a1325 1
 | _ => raise ActionError 78,
d1329 1
a1329 1
         fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1333 1
a1333 1
 | _ => raise ActionError 79,
d1337 1
a1337 1
         fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1341 1
a1341 1
 | _ => raise ActionError 80,
d1345 1
a1345 1
         fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1349 1
a1349 1
 | _ => raise ActionError 81,
d1353 1
a1353 1
         fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1357 1
a1357 1
 | _ => raise ActionError 82,
d1361 2
a1362 2
         fn ([],opts) => NULLTYPE
 | _ => raise ActionError 83,
d1366 2
a1367 2
         fn ([_,ty],opts) => ty
 | _ => raise ActionError 84,
d1371 2
a1372 2
         fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
 | _ => raise ActionError 85,
d1376 1
a1376 1
         fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1378 1
a1378 1
 | _ => raise ActionError 86,
d1382 1
a1382 1
         fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1384 1
a1384 1
 | _ => raise ActionError 87,
d1388 2
a1389 2
         fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 88,
d1393 2
a1394 2
         fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 89,
d1398 2
a1399 2
         fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 90,
d1403 2
a1404 2
         fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 91,
d1408 2
a1409 2
         fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 92,
d1413 2
a1414 2
         fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
 | _ => raise ActionError 93,
d1418 1
a1418 1
         fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1420 1
a1420 1
 | _ => raise ActionError 94,
d1424 1
a1424 1
         fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1427 1
a1427 1
 | _ => raise ActionError 95,
d1431 2
a1432 2
         fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 96,
d1436 1
a1436 1
         fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1438 1
a1438 1
 | _ => raise ActionError 97,
d1442 1
a1442 1
         fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
d1444 1
a1444 1
 | _ => raise ActionError 98,
d1448 2
a1449 2
         fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 99,
d1453 1
a1453 1
         fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1455 1
a1455 1
 | _ => raise ActionError 100,
d1459 1
a1459 1
         fn ([VALID id, TY (ty,tyvars)],opts) => 
d1463 1
a1463 1
 | _ => raise ActionError 101,
d1467 1
a1467 1
         fn ([VALID id,_,LONGVALID id'],opts) => 
d1469 1
a1469 1
 | _ => raise ActionError 102,
d1473 2
a1474 2
         fn ([],opts) => NULLTYPE
 | _ => raise ActionError 103,
d1478 2
a1479 2
         fn ([_,x],opts) => x
 | _ => raise ActionError 104,
d1483 2
a1484 2
         fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 105,
d1488 2
a1489 2
         fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 106,
d1495 1
a1495 1
         fn ([VALID id],opts) => 
d1497 1
a1497 1
 | _ => raise ActionError 107,
d1501 1
a1501 1
         fn ([LONGVALID id],opts) => 
d1504 1
a1504 1
 | _ => raise ActionError 108,
d1508 1
a1508 1
         fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1510 1
a1510 1
 | _ => raise ActionError 109,
d1514 1
a1514 1
         fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1516 1
a1516 1
 | _ => raise ActionError 110,
d1520 1
a1520 1
         fn ([_,_,_],opts) => 
d1522 1
a1522 1
 | _ => raise ActionError 111,
d1526 2
a1527 2
         fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 112,
d1531 2
a1532 2
         fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 113,
d1536 2
a1537 2
         fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 114,
d1541 2
a1542 2
         fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 115,
d1546 2
a1547 2
         fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 116,
d1551 2
a1552 2
         fn ([_,x,_],opts) => x
 | _ => raise ActionError 117,
d1556 2
a1557 2
         fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
 | _ => raise ActionError 118,
d1561 1
a1561 1
         fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1563 1
a1563 1
 | _ => raise ActionError 119,
d1567 1
a1567 1
         fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1570 1
a1570 1
 | _ => raise ActionError 120,
d1574 2
a1575 2
         fn ([x],opts) => x
 | _ => raise ActionError 121,
d1579 1
a1579 1
         fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1581 1
a1581 1
 | _ => raise ActionError 122,
d1585 1
a1585 1
         fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1587 1
a1587 1
 | _ => raise ActionError 123,
d1591 2
a1592 2
         fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 124,
d1596 1
a1596 1
         fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1599 1
a1599 1
 | _ => raise ActionError 125,
d1603 2
a1604 2
         fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 126,
d1608 1
a1608 1
         fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1614 1
a1614 1
 | _ => raise ActionError 127,
d1618 1
a1618 1
         fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1624 1
a1624 1
 | _ => raise ActionError 128,
d1628 2
a1629 2
         fn ([x],opts) => x
 | _ => raise ActionError 129,
d1633 1
a1633 1
         fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1635 1
a1635 1
 | _ => raise ActionError 130,
d1639 1
a1639 1
         fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1643 1
a1643 1
 | _ => raise ActionError 131,
d1647 2
a1648 2
         fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 132,
d1652 1
a1652 1
         fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1656 1
a1656 1
 | _ => raise ActionError 133,
d1662 2
a1663 2
         fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 134,
d1667 2
a1668 2
         fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 135,
d1672 2
a1673 2
         fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 136,
d1677 2
a1678 2
         fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
 | _ => raise ActionError 137,
d1682 2
a1683 2
         fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
 | _ => raise ActionError 138,
d1687 2
a1688 2
         fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
 | _ => raise ActionError 139,
d1692 2
a1693 2
         fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 140,
d1697 2
a1698 2
         fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 141,
d1702 2
a1703 2
         fn ([_,t,_],opts) => t
 | _ => raise ActionError 142,
d1707 2
a1708 2
         fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 143,
d1712 2
a1713 2
         fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 144,
d1717 2
a1718 2
         fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 145,
d1722 2
a1723 2
         fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 146,
d1727 2
a1728 2
         fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 147,
d1732 2
a1733 2
         fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 148,
d1737 1
a1737 1
         fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1739 1
a1739 1
 | _ => raise ActionError 149,
d1745 2
a1746 2
         fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 150,
d1750 1
a1750 1
         fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1752 1
a1752 1
 | _ => raise ActionError 151,
d1758 2
a1759 2
         fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 152,
d1763 2
a1764 2
         fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 153,
d1770 2
a1771 2
         fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 154,
d1775 2
a1776 2
         fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 155,
d1782 2
a1783 2
         fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 156,
d1787 2
a1788 2
         fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 157,
d1792 1
a1792 1
(*         ((SCON :integer))  *)
d1794 2
a1795 2
         fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
 | _ => raise ActionError 158,
d1799 2
a1800 2
         fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
 | _ => raise ActionError 159,
d1804 2
a1805 2
         fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 160,
d1811 1
a1811 1
         fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1814 1
a1814 1
 | _ => raise ActionError 161,
d1818 2
a1819 2
         fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 162,
d1825 2
a1826 2
         fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
 | _ => raise ActionError 163,
d1830 2
a1831 2
         fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 164,
d1835 2
a1836 2
         fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 165,
d1840 2
a1841 2
         fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 166,
d1845 2
a1846 2
         fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 167,
d1852 1
a1852 1
         fn ([LONGID ([],s)],opts) => SYM s
d1855 1
a1855 1
 | _ => raise ActionError 168,
d1859 2
a1860 2
         fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 169,
d1864 2
a1865 2
         fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 170,
d1869 2
a1870 2
         fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 171,
d1874 2
a1875 2
         fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 172,
d1883 1
a1883 1
         fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1885 1
a1885 1
 | _ => raise ActionError 173,
d1891 1
a1891 1
         fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1893 1
a1893 1
 | _ => raise ActionError 174,
d1897 2
a1898 2
         fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 175,
d1902 2
a1903 2
         fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 176,
d1908 1
a1908 1
         fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1910 1
a1910 1
 | _ => raise ActionError 177,
d1914 1
a1914 1
         fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1916 1
a1916 1
 | _ => raise ActionError 178,
d1920 2
a1921 2
         fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
 | _ => raise ActionError 179,
d1925 2
a1926 2
         fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
 | _ => raise ActionError 180,
d1930 1
a1930 1
         fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d1932 1
a1932 1
 | _ => raise ActionError 181,
d1936 2
a1937 2
         fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
 | _ => raise ActionError 182,
d1941 2
a1942 2
         fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
 | _ => raise ActionError 183,
d1946 1
a1946 1
         fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d1948 1
a1948 1
 | _ => raise ActionError 184,
d1952 2
a1953 2
         fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 185,
d1959 2
a1960 2
         fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 186,
d1964 2
a1965 2
         fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
 | _ => raise ActionError 187,
d1969 1
a1969 1
         fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d1971 1
a1971 1
 | _ => raise ActionError 188,
d1975 1
a1975 1
         fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d1977 1
a1977 1
 | _ => raise ActionError 189,
d1981 1
a1981 1
         fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d1983 1
a1983 1
 | _ => raise ActionError 190,
d1987 2
a1988 2
         fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 191,
d1992 2
a1993 2
         fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 192,
d1997 2
a1998 2
         fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 193,
d2002 2
a2003 2
         fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 194,
d2007 2
a2008 2
         fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 195,
d2012 2
a2013 2
         fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 196,
d2019 2
a2020 2
         fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 197,
d2024 2
a2025 2
         fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 198,
d2029 1
a2029 1
         fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2031 1
a2031 1
 | _ => raise ActionError 199,
d2035 1
a2035 1
         fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2037 1
a2037 1
 | _ => raise ActionError 200,
d2043 2
a2044 2
         fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 201,
d2048 1
a2048 1
         fn ([_,STRBIND(l,pSE)],opts) => 
d2050 1
a2050 1
 | _ => raise ActionError 202,
d2054 1
a2054 1
         fn ([_,STRBIND(l,pSE)],opts) => 
d2056 1
a2056 1
 | _ => raise ActionError 203,
d2060 1
a2060 1
         fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2062 1
a2062 1
 | _ => raise ActionError 204,
d2066 2
a2067 2
         fn ([STRBIND1 (d,(id,pE))],opts) => STRBIND([d],make_pSE (opts,id,pE))
 | _ => raise ActionError 205,
d2071 1
a2071 1
         fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2073 1
a2073 1
 | _ => raise ActionError 206,
d2077 1
a2077 1
         fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2079 1
a2079 1
 | _ => raise ActionError 207,
d2083 1
a2083 1
         fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2085 1
a2085 1
 | _ => raise ActionError 208,
d2089 1
a2089 1
         fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2091 1
a2091 1
 | _ => raise ActionError 209,
d2095 2
a2096 2
         fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 210,
d2100 2
a2101 2
         fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
 | _ => raise ActionError 211,
d2105 2
a2106 2
         fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 212,
d2110 2
a2111 2
         fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 213,
d2115 2
a2116 2
         fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 214,
d2120 2
a2121 2
         fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 215,
d2125 1
a2125 1
         fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2127 1
a2127 1
 | _ => raise ActionError 216,
d2131 2
a2132 2
         fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 217,
d2136 2
a2137 2
         fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 218,
d2141 2
a2142 2
         fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 219,
d2146 1
a2146 1
         fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2148 1
a2148 1
 | _ => raise ActionError 220,
d2152 1
a2152 1
         fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2154 1
a2154 1
 | _ => raise ActionError 221,
d2160 2
a2161 2
         fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 222,
d2165 2
a2166 2
         fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 223,
d2170 2
a2171 2
         fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 224,
d2175 2
a2176 2
         fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 225,
d2180 2
a2181 2
         fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 226,
d2185 2
a2186 2
         fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 227,
d2190 2
a2191 2
         fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 228,
d2195 1
a2195 1
         fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2197 1
a2197 1
 | _ => raise ActionError 229,
d2201 2
a2202 2
         fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 230,
d2206 2
a2207 2
         fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 231,
d2212 2
a2213 2
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.LEFT 0,opts)
 | _ => raise ActionError 232,
d2217 2
a2218 2
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.LEFT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 233,
d2222 2
a2223 2
       fn ([_,SYMLIST l],opts) => do_fixity_spec (l,PE.RIGHT 0,opts)
 | _ => raise ActionError 234,
d2227 2
a2228 2
       fn ([_,INTEGER i,SYMLIST l],opts) => do_fixity_spec(l,PE.RIGHT(parse_precedence (opts,i)),opts)
 | _ => raise ActionError 235,
d2232 2
a2233 2
         fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 236,
d2237 2
a2238 2
         fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 237,
d2242 2
a2243 2
         fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 238,
d2247 1
a2247 1
         fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2249 1
a2249 1
 | _ => raise ActionError 239,
d2253 2
a2254 2
         fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 240,
d2258 1
a2258 1
         fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2260 1
a2260 1
 | _ => raise ActionError 241,
d2264 2
a2265 2
         fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 242,
d2270 2
a2271 2
         fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 243,
d2275 1
a2275 1
         fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2277 1
a2277 1
 | _ => raise ActionError 244,
d2281 1
a2281 1
         fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2284 1
a2284 1
 | _ => raise ActionError 245,
d2288 2
a2289 2
         fn ([x],opts) => x
 | _ => raise ActionError 246,
d2293 1
a2293 1
         fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2295 1
a2295 1
 | _ => raise ActionError 247,
d2299 1
a2299 1
         fn ([VALID con,TY(ty,tyvars)],opts) => 
d2303 1
a2303 1
 | _ => raise ActionError 248,
d2307 2
a2308 2
         fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 249,
d2312 1
a2312 1
         fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2314 1
a2314 1
 | _ => raise ActionError 250,
d2318 1
a2318 1
         fn ([VALID excon,TY(ty,_)],opts) => 
d2322 1
a2322 1
 | _ => raise ActionError 251,
d2326 2
a2327 2
         fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(opts,strid,pE))
 | _ => raise ActionError 252,
d2331 1
a2331 1
         fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2333 1
a2333 1
 | _ => raise ActionError 253,
d2337 2
a2338 2
         fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 254,
d2340 1
a2340 1
(*         ((SHAREQ SHAREQ1))  *)
d2342 2
a2343 2
         fn ([x],opts) => x
 | _ => raise ActionError 255,
d2347 2
a2348 2
         fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 256,
d2352 2
a2353 2
         fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 257,
d2357 2
a2358 2
         fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 258,
d2362 2
a2363 2
         fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 259,
d2367 2
a2368 2
         fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 260,
d2372 2
a2373 2
         fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 261,
d2377 2
a2378 2
         fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 262,
d2382 2
a2383 2
         fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 263,
d2387 2
a2388 2
         fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 264,
d2392 2
a2393 2
         fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 265,
d2397 1
a2397 1
         fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2399 1
a2399 1
 | _ => raise ActionError 266,
d2403 1
a2403 1
         fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2405 1
a2405 1
 | _ => raise ActionError 267,
d2409 1
a2409 1
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2411 1
a2411 1
 | _ => raise ActionError 268,
d2415 1
a2415 1
         fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2417 1
a2417 1
 | _ => raise ActionError 269,
d2421 1
a2421 1
         fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2423 1
a2423 1
 | _ => raise ActionError 270,
d2427 1
a2427 1
         fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2429 1
a2429 1
 | _ => raise ActionError 271,
d2433 1
a2433 1
         fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2435 1
a2435 1
 | _ => raise ActionError 272,
d2439 1
a2439 1
         fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2441 5
d2448 3
a2450 1
(* 	((FUNIDBIND FUNID))  *)
d2452 3
a2454 1
         fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2457 1
a2457 1
(* 	((TOPDEC))  *)
d2459 1
a2459 1
         fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB)
d2462 1
a2462 1
(* 	((TOPDEC STRDEC1PLUS))  *)
d2464 1
a2464 1
         fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2467 1
a2467 1
(* 	((TOPDEC SIGDEC1PLUS))  *)
d2469 2
a2470 1
         fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2473 1
a2473 1
(* 	((TOPDEC FUNDEC1PLUS))  *)
d2475 1
a2475 1
         fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2478 1
a2478 1
(*         ((TOPDEC EXP))  *)
d2480 1
a2480 2
         fn ([EXP(exp,tyvars)],opts) =>
       TOPDEC (Derived.make_it_strdec(exp,tyvars,marks_of opts,get_current_pE()),PE.empty_pB)
d2483 1
a2483 1
(* 	((TOPDEC :require :string))  *)
d2485 1
a2485 1
         fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
d2488 1
a2488 2

(* 	((TOPDEC1 TOPDEC)) *)
d2490 1
a2490 1
         fn ([TOPDEC x],opts) => raise FoundTopDec x
d2493 1
a2493 1
(* 	((PROGRAM TOPDEC1 :semicolon PROGRAM))  *)
d2495 1
a2495 1
         fn ([x,_,_],opts) => x
d2498 1
a2498 1
(* 	((PROGRAM TOPDEC1 :semicolon))  *)
d2500 1
a2500 1
         fn ([x,_],opts) => x
d2503 2
a2504 1
(* 	((PROGRAM TOPDEC1))  *)
d2506 1
a2506 1
         fn ([x],opts) => x
d2512 1
a2512 1
(*       '(;; associativity of tupling  *)
d2528 10
a2537 1
(*   *)
d2553 2
a2554 2
(* 	((:reduce (strdec1 dec1))  *)
(*          (:reduce (decsep)))  *)
d2556 2
a2557 2
(* 	((:reduce (strdec1 dec1))  *)
(*          (:reduce (decsep)))  *)
d2559 24
a2582 1
(*         ;; self conflicts  *)
d2595 10
a2604 1
(* 	((:reduce (program topdec1 :semicolon)) *)
d2609 3
a2611 3
(*       '((((:reduce (atpat opvardef))(:shift (pat opvardef opttype :as pat)))  *)
(*          (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift)  *)
(*          (:colon (:resolve (:reduce (atpat opvardef)) :shift)))  *)
d2617 1
a2617 1
(*          (:funcall ifinfixinput (:reduce (infexp appexp))(:shift (appexp appexp atexp))))  *)
d2620 1
a2620 1
(*          (:funcall ifinfixinput (:reduce (pat atpat)) :shift))  *)
d2623 1
a2623 1
(*          (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift))  *)
d2626 1
a2626 1
(*          (:funcall ifinfixinput (:reduce (atpat1 bin_atpat)):shift))  *)
d2629 1
a2629 1
(*          (:funcall ifinfixinput :shift (:reduce (pat atpat))))  *)
d2633 1
a2633 1
(*          (:funcall ifstarinput (:reduce (tytuple ty star ty)) :shift))  *)
d2635 1
a2635 1
(*          (:funcall ifstarinput (:reduce (tytuple tytuple star ty)) :shift))  *)
d2638 1
a2638 1
(*         (((:reduce (pat pat var pat)) (:shift (pat pat var pat)))  *)
@


1.28
log
@Added code for abstractions.
@
text
@d4 3
d242 1
a242 1
datatype ActionOpts = OPTS of (Location.T * Info.options * Options.print_options)
d246 1
a246 1
fun print_options_of (OPTS(_,_,x)) = x
d358 8
a365 5
fun check_is_constructor (opts as OPTS(_,_,print_options),id) =
  if is_long_constructor id then
    ()
  else
    error (opts,"Constructor " ^ (IdentPrint.printLongValId print_options id) ^ " not defined")
d367 8
a374 5
fun check_is_short_constructor (opts as OPTS(_,_,print_options),id) =
  if is_constructor id then
    ()
  else
    error (opts,"Non-constructor " ^ (IdentPrint.printValId print_options id) ^ " used in pattern")
d376 8
a383 5
fun check_not_constructor (opts as OPTS(_,_,print_options),id) =
  if is_constructor id then
    error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId print_options id))
  else
    ()
d385 8
a392 5
fun check_not_short_constructor (opts as OPTS(_,_,print_options),id) =
  if is_constructor id then
    error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId print_options id))
  else
    ()
d423 10
a432 1
fun zap_pFE (PE.E(_,pVE,pSE)) = PE.E(PE.empty_pFE,pVE,pSE)
d437 2
a440 1
fun make_pSE (id,pE) = PE.addStrId (pe_error,id,zap_pFE pE,PE.empty_pSE)
d481 11
a491 8
fun resolveLongValId (opts as OPTS(_,_,print_options),id) =
  (case lookupValId id of
     Ident.VAR _ => mkLongVar id          
   | Ident.CON _ => mkLongCon id
   | Ident.EXCON _ => mkLongExCon id)
   handle PE.Lookup =>
     ((* warn (opts,"Identifier " ^ IdentPrint.printLongValId popts (mkLongVar id) ^ " not defined"); *)
      mkLongVar id)
d563 3
d701 4
a704 2
fun merge_pVEs (opts as OPTS(location,options,print_options),pVE1 as (PE.VE ve1),pVE2 as (PE.VE ve2)) =
  let fun error_fun (valid1,valid2) =
d713 8
a720 4
  fun valid_error (opts as OPTS(location,options,print_options)) (_,_,valid) =
    (error(opts,"Multiple declaration of value identifier: " ^
		IdentPrint.printValId print_options valid);
     valid)
d736 1
a736 1
    PE.addStrId (strid_error opts,strid,zap_pFE pE,pSE)
d843 14
a867 2


d882 1
a882 1
      fn ([dec],opts) => dec
d887 1
a887 1
      fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d892 1
a892 1
      fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d900 1
a900 1
      fn ([_],opts) =>
d907 1
a907 1
      fn ([_,_],opts) => 
d914 1
a914 1
      fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d919 1
a919 1
      fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d924 1
a924 1
      fn ([_,LAB lab],opts) =>
d929 1
a929 1
      fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d933 1
a933 1
      fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d938 1
a938 1
      fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d943 1
a943 1
      fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d948 1
a948 1
      fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d953 1
a953 1
      fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d958 1
a958 1
      fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d964 1
a964 1
      fn ([_,x,_],opts) => x
d969 1
a969 1
      fn ([_],opts) => ENV (get_current_pE())
d974 1
a974 1
      fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d979 1
a979 1
      fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d984 1
a984 1
      fn ([],opts) => EXPLIST ([],Set.empty_set)
d989 1
a989 1
      fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d994 1
a994 1
      fn ([exp],opts) => exp
d999 1
a999 1
      fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d1005 1
a1005 1
      fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d1010 1
a1010 1
      fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d1016 1
a1016 1
      fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d1021 1
a1021 1
      fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d1027 1
a1027 1
      fn ([x],opts) => x
d1032 1
a1032 1
      fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d1038 1
a1038 1
      fn ([x],opts) => x
d1043 1
a1043 1
      fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1049 1
a1049 1
      fn ([x],opts) => x
d1054 1
a1054 1
      fn ([_],opts) => LONGVALID equal_lvalid
d1059 1
a1059 1
      fn ([x],opts) => x
d1064 1
a1064 1
      fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1070 1
a1070 1
      fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1076 1
a1076 1
      fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1082 1
a1082 1
      fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1088 1
a1088 1
      fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1094 1
a1094 1
      fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1100 1
a1100 1
      fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1106 1
a1106 1
      fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1112 1
a1112 1
      fn ([_,MATCH (match,tyvars)],opts) =>
d1118 1
a1118 1
      fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1123 1
a1123 1
      fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1129 1
a1129 1
      fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d1135 1
a1135 1
      fn ([],opts) => DUMMY
d1140 1
a1140 1
      fn ([_,_],opts) => DUMMY
d1145 1
a1145 1
      fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1150 1
a1150 1
      fn ([_,dec,_],opts) => dec
d1155 1
a1155 1
      fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1160 1
a1160 1
      fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1165 1
a1165 1
      fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1174 1
a1174 1
      fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1180 1
a1180 1
      fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1186 1
a1186 1
      fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1193 1
a1193 1
      fn ([_,DATBIND (d,pVE)],opts) => 
d1199 1
a1199 1
      fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1207 1
a1207 1
      fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1213 1
a1213 1
      fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1219 1
a1219 1
      fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1224 1
a1224 1
      fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1230 1
a1230 1
      fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1239 1
a1239 1
      fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1247 1
a1247 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1252 1
a1252 1
      fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1257 1
a1257 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1262 1
a1262 1
      fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1267 1
a1267 1
      fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1274 1
a1274 1
      fn ([_],opts) => ENV (get_current_pE())
d1279 1
a1279 1
      fn ([x],opts) => x
d1284 1
a1284 1
      fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1290 1
a1290 1
      fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1296 1
a1296 1
      fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1302 1
a1302 1
      fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1310 1
a1310 1
      fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1316 1
a1316 1
      fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1322 1
a1322 1
      fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1328 1
a1328 1
      fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1334 1
a1334 1
      fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1342 1
a1342 1
      fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1350 1
a1350 1
      fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1358 1
a1358 1
      fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1366 1
a1366 1
      fn ([],opts) => NULLTYPE
d1371 1
a1371 1
      fn ([_,ty],opts) => ty
d1376 1
a1376 1
      fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1381 1
a1381 1
      fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1387 1
a1387 1
      fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1393 1
a1393 1
      fn ([],opts) => TYVARLIST []
d1398 1
a1398 1
      fn ([TYVAR t],opts) => TYVARLIST [t]
d1403 1
a1403 1
      fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1408 1
a1408 1
      fn ([TYVAR t],opts) => TYVARLIST [t]
d1413 1
a1413 1
      fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1418 1
a1418 1
      fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1423 1
a1423 1
      fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1429 1
a1429 1
      fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1436 1
a1436 1
      fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1441 1
a1441 1
      fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1447 1
a1447 1
      fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
d1453 1
a1453 1
      fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1458 1
a1458 1
      fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1464 1
a1464 1
      fn ([VALID id, TY (ty,tyvars)],opts) => 
d1472 1
a1472 1
      fn ([VALID id,_,LONGVALID id'],opts) => 
d1478 1
a1478 1
      fn ([],opts) => NULLTYPE
d1483 1
a1483 1
      fn ([_,x],opts) => x
d1488 1
a1488 1
      fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1493 1
a1493 1
      fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1500 1
a1500 1
      fn ([VALID id],opts) => 
d1506 1
a1506 1
      fn ([LONGVALID id],opts) => 
d1513 1
a1513 1
      fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1519 1
a1519 1
      fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1525 1
a1525 1
      fn ([_,_,_],opts) => 
d1531 1
a1531 1
      fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1536 1
a1536 1
      fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1541 1
a1541 1
      fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1546 1
a1546 1
      fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1551 1
a1551 1
      fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1556 1
a1556 1
      fn ([_,x,_],opts) => x
d1561 1
a1561 1
      fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1566 1
a1566 1
      fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1572 1
a1572 1
      fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1579 1
a1579 1
      fn ([x],opts) => x
d1584 1
a1584 1
      fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1590 1
a1590 1
      fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1596 1
a1596 1
      fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1601 1
a1601 1
      fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1608 1
a1608 1
      fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1613 1
a1613 1
      fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1623 1
a1623 1
      fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1633 1
a1633 1
      fn ([x],opts) => x
d1638 1
a1638 1
      fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1644 1
a1644 1
      fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1652 1
a1652 1
      fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1657 1
a1657 1
      fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1667 1
a1667 1
      fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1672 1
a1672 1
      fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1677 1
a1677 1
      fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1682 1
a1682 1
      fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1687 1
a1687 1
      fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1692 1
a1692 1
      fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1697 1
a1697 1
      fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1702 1
a1702 1
      fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1707 1
a1707 1
      fn ([_,t,_],opts) => t
d1712 1
a1712 1
      fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1717 1
a1717 1
      fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1722 1
a1722 1
      fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1727 1
a1727 1
      fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1732 1
a1732 1
      fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1737 1
a1737 1
      fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1742 1
a1742 1
      fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1750 1
a1750 1
      fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1755 1
a1755 1
      fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1763 1
a1763 1
      fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1768 1
a1768 1
      fn ([LONGID id],opts) => LONGIDLIST[id]
d1775 1
a1775 1
      fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1780 1
a1780 1
      fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1787 1
a1787 1
      fn ([SYM sym],opts) => SYMLIST [sym]
d1792 1
a1792 1
      fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1799 1
a1799 1
      fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1804 1
a1804 1
      fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1809 1
a1809 1
      fn ([STRING s],opts) => SCON (Ident.STRING s)
d1816 1
a1816 1
      fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1823 1
a1823 1
      fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1830 1
a1830 1
      fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1835 1
a1835 1
      fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1840 1
a1840 1
      fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1845 1
a1845 1
      fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1850 1
a1850 1
      fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1857 1
a1857 1
      fn ([LONGID ([],s)],opts) => SYM s
d1864 1
a1864 1
      fn ([_],opts) => SYM equal_symbol
d1869 1
a1869 1
      fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1874 1
a1874 1
      fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1879 1
a1879 1
      fn ([SYM s],opts) => STRID(Ident.STRID s)
d1888 1
a1888 1
      fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1896 1
a1896 1
      fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1902 1
a1902 1
      fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1907 1
a1907 1
      fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d1913 1
a1913 1
      fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1919 1
a1919 1
      fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1925 1
a1925 1
      fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
d1930 1
a1930 1
      fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
d1935 1
a1935 1
      fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d1941 1
a1941 1
      fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
d1946 1
a1946 1
      fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
d1951 1
a1951 1
      fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d1957 1
a1957 1
      fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d1964 1
a1964 1
      fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d1969 1
a1969 1
      fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d1974 1
a1974 1
      fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d1980 1
a1980 1
      fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d1986 1
a1986 1
      fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d1992 1
a1992 1
      fn ([_],opts) => ENV (get_current_pE())
d1997 1
a1997 1
      fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d2002 1
a2002 1
      fn ([_,strdec,_],opts) => strdec
d2007 1
a2007 1
      fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2012 1
a2012 1
      fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d2017 1
a2017 1
      fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d2024 1
a2024 1
      fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d2029 1
a2029 1
      fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d2034 1
a2034 1
      fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d2040 1
a2040 1
      fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d2048 1
a2048 1
      fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2053 1
a2053 1
      fn ([_,STRBIND(l,pSE)],opts) => 
d2059 2
a2060 2
      fn ([_,STRBIND(l,pSE)],opts) => 
  (extend_pSE pSE;STRDEC(Absyn.ABSTRACTIONstrdec l,pSE_in_pE pSE))
d2065 1
a2065 1
      fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2071 1
a2071 1
      fn ([STRBIND1 (d,id_pE)],opts) => STRBIND([d],make_pSE id_pE)
d2076 1
a2076 1
      fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2082 1
a2082 1
      fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2088 1
a2088 1
      fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2094 1
a2094 1
      fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2100 1
a2100 1
      fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.ABSENT,marks_of opts),lookupSigId(opts,id))
d2105 1
a2105 1
      fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
d2110 1
a2110 1
      fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d2115 1
a2115 1
      fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d2120 1
a2120 1
      fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d2125 1
a2125 1
      fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d2130 1
a2130 1
      fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2136 1
a2136 1
      fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d2141 1
a2141 1
      fn ([_,spec,_],opts) => spec
d2146 1
a2146 1
      fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d2151 1
a2151 1
      fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2157 1
a2157 1
      fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2165 1
a2165 1
      fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2170 1
a2170 1
      fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2175 1
a2175 1
      fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2180 1
a2180 1
      fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2185 1
a2185 1
      fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2190 1
a2190 1
      fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2195 1
a2195 1
      fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2200 1
a2200 1
      fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2206 1
a2206 1
      fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2211 1
a2211 1
      fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2214 21
d2237 2
a2238 2
      fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 232,
d2242 2
a2243 2
      fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 233,
d2247 2
a2248 2
      fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 234,
d2252 1
a2252 1
      fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2254 1
a2254 1
 | _ => raise ActionError 235,
d2258 2
a2259 2
      fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 236,
d2263 1
a2263 1
      fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2265 1
a2265 1
 | _ => raise ActionError 237,
d2269 2
a2270 2
      fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 238,
d2275 2
a2276 2
      fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 239,
d2280 1
a2280 1
      fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2282 1
a2282 1
 | _ => raise ActionError 240,
d2286 1
a2286 1
      fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2289 1
a2289 1
 | _ => raise ActionError 241,
d2293 2
a2294 2
      fn ([x],opts) => x
 | _ => raise ActionError 242,
d2298 1
a2298 1
      fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2300 1
a2300 1
 | _ => raise ActionError 243,
d2304 1
a2304 1
      fn ([VALID con,TY(ty,tyvars)],opts) => 
d2308 1
a2308 1
 | _ => raise ActionError 244,
d2312 2
a2313 2
      fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 245,
d2317 1
a2317 1
      fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2319 1
a2319 1
 | _ => raise ActionError 246,
d2323 1
a2323 1
      fn ([VALID excon,TY(ty,_)],opts) => 
d2327 1
a2327 1
 | _ => raise ActionError 247,
d2331 2
a2332 2
      fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(strid,pE))
 | _ => raise ActionError 248,
d2336 1
a2336 1
      fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2338 1
a2338 1
 | _ => raise ActionError 249,
d2342 2
a2343 2
      fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 250,
d2347 2
a2348 2
      fn ([x],opts) => x
 | _ => raise ActionError 251,
d2352 2
a2353 2
      fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 252,
d2357 2
a2358 2
      fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 253,
d2362 2
a2363 2
      fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 254,
d2367 2
a2368 2
      fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 255,
d2372 2
a2373 2
      fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 256,
d2377 2
a2378 2
      fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 257,
d2382 2
a2383 2
      fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 258,
d2387 2
a2388 2
      fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 259,
d2392 2
a2393 2
      fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 260,
d2397 2
a2398 2
      fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 261,
d2402 1
a2402 1
      fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2404 1
a2404 1
 | _ => raise ActionError 262,
d2408 1
a2408 1
      fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2410 1
a2410 1
 | _ => raise ActionError 263,
d2414 1
a2414 1
      fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2416 1
a2416 1
 | _ => raise ActionError 264,
d2420 1
a2420 1
      fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2422 1
a2422 1
 | _ => raise ActionError 265,
d2426 1
a2426 1
      fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2428 1
a2428 1
 | _ => raise ActionError 266,
d2432 1
a2432 1
      fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2434 1
a2434 1
 | _ => raise ActionError 267,
d2438 3
a2440 3
      fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
(extend_pSE(make_pSE(strid,pE'));STARTFUNBIND1(funid,pE,strid,sigexp,pE'))
 | _ => raise ActionError 268,
d2444 1
a2444 1
      fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2446 1
a2446 1
 | _ => raise ActionError 269,
d2450 2
a2451 2
      fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 270,
d2455 2
a2456 2
      fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB)
 | _ => raise ActionError 271,
d2460 2
a2461 2
      fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 272,
d2465 2
a2466 2
      fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 273,
d2470 2
a2471 2
      fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 274,
d2475 1
a2475 1
      fn ([EXP(exp,tyvars)],opts) =>
d2477 1
a2477 1
 | _ => raise ActionError 275,
d2481 2
a2482 2
      fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 276,
d2487 2
a2488 2
      fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 277,
d2492 2
a2493 2
      fn ([x,_,_],opts) => x
 | _ => raise ActionError 278,
d2497 2
a2498 2
      fn ([x,_],opts) => x
 | _ => raise ActionError 279,
d2502 2
a2503 2
      fn ([x],opts) => x
 | _ => raise ActionError 280,
@


1.27
log
@Removed integer parameter
@
text
@d4 3
d818 1
d833 1
a833 1
     fn ([dec],opts) => dec
d838 1
a838 1
     fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d843 1
a843 1
     fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d851 1
a851 1
     fn ([_],opts) =>
d858 1
a858 1
     fn ([_,_],opts) => 
d865 1
a865 1
     fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d870 1
a870 1
     fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d875 1
a875 1
     fn ([_,LAB lab],opts) =>
d880 1
a880 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, tyvars, ref (Absyn.nullType,0,tyvars)),tyvars)
d884 1
a884 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Absyn.nullType),Set.union(tyvars,tyvars'))
d889 1
a889 1
     fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d894 1
a894 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d899 1
a899 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (rev l,marks_of opts,get_current_pE()),tyvars)
d904 1
a904 1
     fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d909 1
a909 1
     fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d915 1
a915 1
     fn ([_,x,_],opts) => x
d920 1
a920 1
     fn ([_],opts) => ENV (get_current_pE())
d925 1
a925 1
     fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d930 1
a930 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d935 1
a935 1
     fn ([],opts) => EXPLIST ([],Set.empty_set)
d940 1
a940 1
     fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d945 1
a945 1
     fn ([exp],opts) => exp
d950 1
a950 1
     fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d956 1
a956 1
     fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d961 1
a961 1
     fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d967 1
a967 1
     fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d972 1
a972 1
     fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d978 1
a978 1
     fn ([x],opts) => x
d983 1
a983 1
     fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d989 1
a989 1
     fn ([x],opts) => x
d994 1
a994 1
     fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d1000 1
a1000 1
     fn ([x],opts) => x
d1005 1
a1005 1
     fn ([_],opts) => LONGVALID equal_lvalid
d1010 1
a1010 1
     fn ([x],opts) => x
d1015 1
a1015 1
     fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d1021 1
a1021 1
     fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1027 1
a1027 1
     fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1033 1
a1033 1
     fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d1039 1
a1039 1
     fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d1045 1
a1045 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d1051 1
a1051 1
     fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d1057 1
a1057 1
     fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d1063 1
a1063 1
     fn ([_,MATCH (match,tyvars)],opts) =>
d1069 1
a1069 1
     fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d1074 1
a1074 1
     fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d1080 1
a1080 1
     fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d1086 1
a1086 1
     fn ([],opts) => DUMMY
d1091 1
a1091 1
     fn ([_,_],opts) => DUMMY
d1096 1
a1096 1
     fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1101 1
a1101 1
     fn ([_,dec,_],opts) => dec
d1106 1
a1106 1
     fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1111 1
a1111 1
     fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1116 1
a1116 1
     fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1125 1
a1125 1
     fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1131 1
a1131 1
     fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1137 1
a1137 1
     fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1144 1
a1144 1
     fn ([_,DATBIND (d,pVE)],opts) => 
d1150 1
a1150 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1158 1
a1158 1
     fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
d1164 1
a1164 1
     fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
d1170 1
a1170 1
     fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
d1175 1
a1175 1
     fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1181 1
a1181 1
     fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
d1190 1
a1190 1
     fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1198 1
a1198 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1203 1
a1203 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1208 1
a1208 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1213 1
a1213 1
     fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1218 1
a1218 1
     fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1225 1
a1225 1
     fn ([_],opts) => ENV (get_current_pE())
d1230 1
a1230 1
     fn ([x],opts) => x
d1235 1
a1235 1
     fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1241 1
a1241 1
     fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
d1247 1
a1247 1
     fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1253 1
a1253 1
     fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1261 1
a1261 1
     fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1267 1
a1267 1
     fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1273 1
a1273 1
     fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
d1279 1
a1279 1
     fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1285 1
a1285 1
     fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1293 1
a1293 1
     fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1301 1
a1301 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1309 1
a1309 1
     fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1317 1
a1317 1
     fn ([],opts) => NULLTYPE
d1322 1
a1322 1
     fn ([_,ty],opts) => ty
d1327 1
a1327 1
     fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1332 1
a1332 1
     fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
d1338 1
a1338 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
d1344 1
a1344 1
     fn ([],opts) => TYVARLIST []
d1349 1
a1349 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1354 1
a1354 1
     fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1359 1
a1359 1
     fn ([TYVAR t],opts) => TYVARLIST [t]
d1364 1
a1364 1
     fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1369 1
a1369 1
     fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1374 1
a1374 1
     fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
d1380 1
a1380 1
     fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
d1387 1
a1387 1
     fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1392 1
a1392 1
     fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
d1398 1
a1398 1
     fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
d1404 1
a1404 1
     fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1409 1
a1409 1
     fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
d1415 1
a1415 1
     fn ([VALID id, TY (ty,tyvars)],opts) => 
d1423 1
a1423 1
     fn ([VALID id,_,LONGVALID id'],opts) => 
d1429 1
a1429 1
     fn ([],opts) => NULLTYPE
d1434 1
a1434 1
     fn ([_,x],opts) => x
d1439 1
a1439 1
     fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1444 1
a1444 1
     fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1451 1
a1451 1
     fn ([VALID id],opts) => 
d1457 1
a1457 1
     fn ([LONGVALID id],opts) => 
d1464 1
a1464 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
d1470 1
a1470 1
     fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
d1476 1
a1476 1
     fn ([_,_,_],opts) => 
d1482 1
a1482 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1487 1
a1487 1
     fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1492 1
a1492 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1497 1
a1497 1
     fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts,get_current_pE()),PE.empty_pVE,Set.empty_set)
d1502 1
a1502 1
     fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts,get_current_pE()),pVE,tyvars)
d1507 1
a1507 1
     fn ([_,x,_],opts) => x
d1512 1
a1512 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts,get_current_pE()),pVE,tyvars)
d1517 1
a1517 1
     fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
d1523 1
a1523 1
     fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
d1530 1
a1530 1
     fn ([x],opts) => x
d1535 1
a1535 1
     fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1541 1
a1541 1
     fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
d1547 1
a1547 1
     fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1552 1
a1552 1
     fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1559 1
a1559 1
     fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
d1564 1
a1564 1
     fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1574 1
a1574 1
     fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1584 1
a1584 1
     fn ([x],opts) => x
d1589 1
a1589 1
     fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1595 1
a1595 1
     fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1603 1
a1603 1
     fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
d1608 1
a1608 1
     fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1618 1
a1618 1
     fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
d1623 1
a1623 1
     fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
d1628 1
a1628 1
     fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1633 1
a1633 1
     fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1638 1
a1638 1
     fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1643 1
a1643 1
     fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1648 1
a1648 1
     fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1653 1
a1653 1
     fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1658 1
a1658 1
     fn ([_,t,_],opts) => t
d1663 1
a1663 1
     fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1668 1
a1668 1
     fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1673 1
a1673 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1678 1
a1678 1
     fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1683 1
a1683 1
     fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1688 1
a1688 1
     fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1693 1
a1693 1
     fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
d1701 1
a1701 1
     fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1706 1
a1706 1
     fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
d1714 1
a1714 1
     fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1719 1
a1719 1
     fn ([LONGID id],opts) => LONGIDLIST[id]
d1726 1
a1726 1
     fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1731 1
a1731 1
     fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1738 1
a1738 1
     fn ([SYM sym],opts) => SYMLIST [sym]
d1743 1
a1743 1
     fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1750 1
a1750 1
     fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1755 1
a1755 1
     fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
d1760 1
a1760 1
     fn ([STRING s],opts) => SCON (Ident.STRING s)
d1767 1
a1767 1
     fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1774 1
a1774 1
     fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1781 1
a1781 1
     fn ([LONGID id],opts) => LONGVALID (resolveLongValId(opts,id))
d1786 1
a1786 1
     fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1791 1
a1791 1
     fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1796 1
a1796 1
     fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1801 1
a1801 1
     fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1808 1
a1808 1
     fn ([LONGID ([],s)],opts) => SYM s
d1815 1
a1815 1
     fn ([_],opts) => SYM equal_symbol
d1820 1
a1820 1
     fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1825 1
a1825 1
     fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1830 1
a1830 1
     fn ([SYM s],opts) => STRID(Ident.STRID s)
d1839 1
a1839 1
     fn ([LONGID (longid as ([],id))],opts) => LONGVALID (Ident.LONGVALID(Ident.NOPATH,resolveValId id))
d1847 1
a1847 1
     fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
d1853 1
a1853 1
     fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1858 1
a1858 1
     fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d1864 1
a1864 1
     fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1870 1
a1870 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1876 1
a1876 1
     fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
d1881 1
a1881 1
     fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
d1886 1
a1886 1
     fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d1892 1
a1892 1
     fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
d1897 1
a1897 1
     fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
d1902 1
a1902 1
     fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d1908 1
a1908 1
     fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d1915 1
a1915 1
     fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d1920 1
a1920 1
     fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId(opts,x))
d1925 1
a1925 1
     fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
d1931 1
a1931 1
     fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
d1937 1
a1937 1
     fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
d1943 1
a1943 1
     fn ([_],opts) => ENV (get_current_pE())
d1948 1
a1948 1
     fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d1953 1
a1953 1
     fn ([_,strdec,_],opts) => strdec
d1958 1
a1958 1
     fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1963 1
a1963 1
     fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d1968 1
a1968 1
     fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d1975 1
a1975 1
     fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d1980 1
a1980 1
     fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1985 1
a1985 1
     fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
d1991 1
a1991 1
     fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
d1999 1
a1999 1
     fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d2004 1
a2004 1
     fn ([_,STRBIND(l,pSE)],opts) => 
d2008 6
d2016 1
a2016 1
     fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
d2018 1
a2018 1
 | _ => raise ActionError 203,
d2022 2
a2023 2
     fn ([STRBIND1 (d,id_pE)],opts) => STRBIND([d],make_pSE id_pE)
 | _ => raise ActionError 204,
d2027 1
a2027 1
     fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
d2029 1
a2029 1
 | _ => raise ActionError 205,
d2033 1
a2033 1
     fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
d2035 1
a2035 1
 | _ => raise ActionError 206,
d2039 1
a2039 1
     fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
d2041 1
a2041 1
 | _ => raise ActionError 207,
d2045 1
a2045 1
     fn ([ENV pE,SPEC (spec,e),_],opts) => 
d2047 1
a2047 1
 | _ => raise ActionError 208,
d2051 2
a2052 2
     fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.ABSENT,marks_of opts),lookupSigId(opts,id))
 | _ => raise ActionError 209,
d2056 2
a2057 2
     fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
 | _ => raise ActionError 210,
d2061 2
a2062 2
     fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 211,
d2066 2
a2067 2
     fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 212,
d2071 2
a2072 2
     fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 213,
d2076 2
a2077 2
     fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 214,
d2081 1
a2081 1
     fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
d2083 1
a2083 1
 | _ => raise ActionError 215,
d2087 2
a2088 2
     fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 216,
d2092 2
a2093 2
     fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 217,
d2097 2
a2098 2
     fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 218,
d2102 1
a2102 1
     fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
d2104 1
a2104 1
 | _ => raise ActionError 219,
d2108 1
a2108 1
     fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
d2110 1
a2110 1
 | _ => raise ActionError 220,
d2116 2
a2117 2
     fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 221,
d2121 2
a2122 2
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 222,
d2126 2
a2127 2
     fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 223,
d2131 2
a2132 2
     fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 224,
d2136 2
a2137 2
     fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 225,
d2141 2
a2142 2
     fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 226,
d2146 2
a2147 2
     fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 227,
d2151 1
a2151 1
     fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
d2153 1
a2153 1
 | _ => raise ActionError 228,
d2157 2
a2158 2
     fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 229,
d2162 2
a2163 2
     fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 230,
d2167 2
a2168 2
     fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 231,
d2172 2
a2173 2
     fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 232,
d2177 2
a2178 2
     fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 233,
d2182 1
a2182 1
     fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
d2184 1
a2184 1
 | _ => raise ActionError 234,
d2188 2
a2189 2
     fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 235,
d2193 1
a2193 1
     fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
d2195 1
a2195 1
 | _ => raise ActionError 236,
d2199 2
a2200 2
     fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 237,
d2205 2
a2206 2
     fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 238,
d2210 1
a2210 1
     fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
d2212 1
a2212 1
 | _ => raise ActionError 239,
d2216 1
a2216 1
     fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
d2219 1
a2219 1
 | _ => raise ActionError 240,
d2223 2
a2224 2
     fn ([x],opts) => x
 | _ => raise ActionError 241,
d2228 1
a2228 1
     fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
d2230 1
a2230 1
 | _ => raise ActionError 242,
d2234 1
a2234 1
     fn ([VALID con,TY(ty,tyvars)],opts) => 
d2238 1
a2238 1
 | _ => raise ActionError 243,
d2242 2
a2243 2
     fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 244,
d2247 1
a2247 1
     fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
d2249 1
a2249 1
 | _ => raise ActionError 245,
d2253 1
a2253 1
     fn ([VALID excon,TY(ty,_)],opts) => 
d2257 1
a2257 1
 | _ => raise ActionError 246,
d2261 2
a2262 2
     fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(strid,pE))
 | _ => raise ActionError 247,
d2266 1
a2266 1
     fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
d2268 1
a2268 1
 | _ => raise ActionError 248,
d2272 2
a2273 2
     fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 249,
d2277 2
a2278 2
     fn ([x],opts) => x
 | _ => raise ActionError 250,
d2282 2
a2283 2
     fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 251,
d2287 2
a2288 2
     fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 252,
d2292 2
a2293 2
     fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 253,
d2297 2
a2298 2
     fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 254,
d2302 2
a2303 2
     fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 255,
d2307 2
a2308 2
     fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 256,
d2312 2
a2313 2
     fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 257,
d2317 2
a2318 2
     fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 258,
d2322 2
a2323 2
     fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 259,
d2327 2
a2328 2
     fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 260,
d2332 1
a2332 1
     fn ([FUNBIND1(fbind,funid,pE)],opts) =>
d2334 1
a2334 1
 | _ => raise ActionError 261,
d2338 1
a2338 1
     fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
d2340 1
a2340 1
 | _ => raise ActionError 262,
d2344 1
a2344 1
     fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
d2346 1
a2346 1
 | _ => raise ActionError 263,
d2350 1
a2350 1
     fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
d2352 1
a2352 1
 | _ => raise ActionError 264,
d2356 1
a2356 1
     fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
d2358 1
a2358 1
 | _ => raise ActionError 265,
d2362 1
a2362 1
     fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
d2364 1
a2364 1
 | _ => raise ActionError 266,
d2368 1
a2368 1
     fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
d2370 1
a2370 1
 | _ => raise ActionError 267,
d2374 1
a2374 1
     fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
d2376 1
a2376 1
 | _ => raise ActionError 268,
d2380 2
a2381 2
     fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 269,
d2385 2
a2386 2
     fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB)
 | _ => raise ActionError 270,
d2390 2
a2391 2
     fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 271,
d2395 2
a2396 2
     fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 272,
d2400 2
a2401 2
     fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 273,
d2405 1
a2405 1
     fn ([EXP(exp,tyvars)],opts) =>
d2407 1
a2407 1
 | _ => raise ActionError 274,
d2411 2
a2412 2
     fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 275,
d2417 2
a2418 2
     fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 276,
d2422 2
a2423 2
     fn ([x,_,_],opts) => x
 | _ => raise ActionError 277,
d2427 2
a2428 2
     fn ([x,_],opts) => x
 | _ => raise ActionError 278,
d2432 2
a2433 2
     fn ([x],opts) => x
 | _ => raise ActionError 279,
d2685 1
@


1.26
log
@Modified to allow options to determine association of two different equal
precedence right associative operators
@
text
@d4 4
a70 1
require "../utils/integer";
a83 1
  structure Integer : INTEGER
@


1.25
log
@Added New Jersey interpretation of weak type variables under option control
@
text
@d4 3
d2556 1
a2556 1
fun ifInfixInput (act1,act2, [], LONGID ([],s)) =
d2559 1
a2559 1
  | ifInfixInput (act1,act2,[], EQVAL) =
d2562 1
a2562 1
  | ifInfixInput (act1,act2,_,_) = act2
d2567 1
a2567 1
  ifVarStack (varred,conred,[LONGID (id as ([],s))],_) =
d2572 1
a2572 1
  | ifVarStack (_,conred,_,_) = conred
d2577 1
a2577 1
fun ifStarStack (starred,tyconred,[LONGID (id as ([],s))],_) =
d2579 2
a2580 2
  | ifStarStack (starred,tyconred,[LONGID _],_) = tyconred
  | ifStarStack _ = raise IfStarStack
d2585 1
a2585 1
fun ifStarInput (staract,otheract,[],LONGID ([],s)) =
d2587 2
a2588 2
  | ifStarInput (_,otheract,[],_) = otheract
  | ifStarInput _ = raise IfStarInput
d2605 2
a2606 2
fun get_associativity (s1,s2) =
  (debug ("Comparing " ^ Symbol.symbol_name s1 ^ " and " ^ Symbol.symbol_name s2);
d2610 9
a2618 1
    (get_precedence s1) >= (get_precedence s2))
d2623 5
a2627 5
fun ifLeftAssoc (act1,act2,[LONGVALID lvalid,_], LONGID ([],s)) =
  let val Ident.LONGVALID (_,valid) = lvalid
  in if get_associativity (get_sym valid,s)
       then act1
     else act2
d2629 8
a2636 8
  | ifLeftAssoc (act1,act2, [LONGVALID lvalid,_], EQVAL) =
  let val Ident.LONGVALID (_,valid) = lvalid
  in if get_associativity (get_sym valid,equal_symbol)
       then act1
     else act2
  end
  | ifLeftAssoc (act1,act2,[LONGVALID lvalid,_], _) = act1
  | ifLeftAssoc _ = raise ResolveError "Error in precedence"
d2639 1
a2639 1
val resolutions  : (Act * Act * Parsed_Object list * Parsed_Object -> Act) Array.array =
d2662 3
a2664 2
fun get_resolution n =
  Array.sub (resolutions,n)
@


1.24
log
@ Changed format of debug_info strings.
@
text
@d4 3
d2656 1
a2656 1
fun token_to_parsed_object (token) =
d2724 21
a2744 1
  | Token.TYVAR t => (LRbasics.TYVAR, TYVAR (Ident.TYVAR t))
@


1.23
log
@Change to DYNAMICexp absyn
@
text
@d4 3
d241 1
a241 1
    implode [string, " ", Location.to_string location]
d244 7
a250 7
  fun make_seq_info (opts) = locate (opts,"part of sequence")
  fun make_and_info (opts) = locate (opts,"andalso expression")
  fun make_orelse_info (opts) = locate (opts,"orelse expression")
  fun make_handle_info (opts) = locate (opts,"handle expression")
  fun make_if_info (opts) = locate (opts,"if expression")
  fun make_case_info (opts) = locate (opts,"case expression")
  fun make_fn_info (opts) = locate (opts,"anonymous function")
@


1.22
log
@Minor changes to reflect addition of Lexerstate to _token.
Minor improvements to error messages.
@
text
@d4 4
d865 1
a865 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, ref Absyn.nullType),tyvars)
@


1.21
log
@Options & Info changes
@
text
@d4 3
d317 1
a317 1
     error(opts,"Asterisk not allowed as TyCon")
d463 1
a463 1
      error (opts,"Symbol " ^ Symbol.symbol_name sym ^ " is not infix")
d584 1
a584 1
          error (opts,"Multiple declaration of tycon " ^ Symbol.symbol_name sym ^ " in " ^ message)
d605 1
a605 1
      else error(opts,"Non-fn expression in valbind");
d654 2
a655 1
    (error (opts,"Multiple declaration of valid: " ^ IdentPrint.printValId print_options valid1);
d663 2
a664 1
    (error(opts,"Multiple declaration of valid: " ^  IdentPrint.printValId print_options valid);
d667 2
a668 1
    (error(opts,"Multiple declaration of strid: " ^  IdentPrint.printStrId strid);
d671 2
a672 1
    (error(opts,"Multiple declaration of funid: " ^  IdentPrint.printFunId funid);
d675 2
a676 1
    (error(opts,"Multiple declaration of sigid: " ^  IdentPrint.printSigId sigid);
d2708 2
a2709 2
         | Token.MAGICCLOSE =>  (LRbasics.MAGICCLOSE,DUMMY)
         | Token.EOF => (LRbasics.EOF,DUMMY))
d2715 1
a2715 1
  | Token.IGNORE _ => raise UnexpectedIgnore
@


1.20
log
@Changed warning on unbound signature to an error
@
text
@d4 3
d72 1
a72 1
  sharing Derived.Absyn.Datatypes.Ident.Symbol = Token.Symbol
a73 1
  sharing Derived.Info = IdentPrint.Info
d84 1
d90 2
a91 2
structure Datatypes = Absyn.Datatypes
structure Ident = Datatypes.Ident
d101 2
a102 2
  type PatExpMark = Absyn.Pat * Absyn.Exp * Absyn.Location.T
  type TypeRef = Datatypes.Type ref
d108 2
a109 2
  type ExType = Ident.ValId * Absyn.Ty Absyn.opt * Absyn.Location.T
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * string * Absyn.Location.T)
d155 2
a156 2
  | SHAREQ of (Absyn.SharEq * Absyn.Location.T) list
  | SIGBIND of (Ident.SigId * Absyn.SigExp * Absyn.Location.T) list * PE.pG
d174 2
a175 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Absyn.Location.T) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Absyn.Location.T) * (Ident.StrId * PE.pE))
d187 1
a187 1
  | EXPSEQ of (Absyn.Exp * string * Absyn.Location.T) list * TyVarSet
d206 1
a206 1
  | FVALBIND of ((FVal list * (string -> string) * Absyn.Location.T) list * TyVarSet) * PE.pVE
d212 1
a212 1
  | LOCATION of Absyn.Location.T
d218 1
a218 1
datatype ActionOpts = OPTS of (Absyn.Location.T * Info.options)
d220 3
a222 2
fun marks_of (OPTS(l,_)) = l
fun options_of (OPTS(_,x)) = x
d226 1
a226 1
val dummy_location = Absyn.Location.UNKNOWN
d230 2
a231 2
  fun locate(OPTS(location,_),string) =
    implode [string, " ", Absyn.Location.to_string location]
d249 1
a249 1
fun do_info (OPTS(location,options),message_type,message) =
d334 1
a334 1
fun check_is_constructor (opts as OPTS(location,options),id) =
d338 1
a338 1
    error (opts,"Constructor " ^ (IdentPrint.printLongValId options id) ^ " not defined")
d340 1
a340 1
fun check_is_short_constructor (opts as OPTS(location,options),id) =
d344 1
a344 1
    error (opts,"Non-constructor " ^ (IdentPrint.printValId options id) ^ " used in pattern")
d346 1
a346 1
fun check_not_constructor (opts as OPTS(location,options),id) =
d348 1
a348 1
    error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId options id))
d352 1
a352 1
fun check_not_short_constructor (opts as OPTS(location,options),id) =
d354 1
a354 1
    error (opts,"Cannot bind constructor " ^ (IdentPrint.printValId options id))
d435 1
a435 1
fun resolveLongValId (opts as OPTS(location,popts),id) =
d649 1
a649 1
fun merge_pVEs (opts as OPTS(location,options),pVE1 as (PE.VE ve1),pVE2 as (PE.VE ve2)) =
d651 1
a651 1
    (error (opts,"Multiple declaration of valid: " ^ IdentPrint.printValId options valid1);
d658 2
a659 2
  fun valid_error (opts as OPTS(location,options)) (_,_,valid) =
    (error(opts,"Multiple declaration of valid: " ^  IdentPrint.printValId options valid);
d715 2
a716 2
fun annotate x = (x,ref Datatypes.NULLTYPE)
fun mannotate (opts,x) = (x,ref Datatypes.NULLTYPE,marks_of opts)
d853 1
a853 1
     fn ([_,EXP (e,tyvars),_],opts) => EXP(Absyn.DYNAMICexp (e, ref Datatypes.NULLTYPE),tyvars)
d857 1
a857 1
     fn ([_,_,EXP(e,tyvars),_,TY(ty,tyvars'),_],opts) => EXP (Absyn.COERCEexp(e,ty,ref Datatypes.NULLTYPE),Set.union(tyvars,tyvars'))
d957 1
a957 1
  EXP(Absyn.APPexp(exp1,exp2,marks_of opts,ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
d968 1
a968 1
  EXP (Absyn.APPexp (Absyn.VALexp (mannotate(opts,id)),Derived.make_tuple_exp [exp1,exp2],marks_of opts,ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
d1007 1
a1007 1
  EXP (Absyn.HANDLEexp (exp1, ref Datatypes.NULLTYPE, (rev match),marks_of opts,make_handle_info(opts)),Set.union(tyvars1,tyvars2))
d1355 1
a1355 1
   DATBIND1 ((rev tyvarlist,tycon,ref Datatypes.NULLTYPE,rev conbind),pVE))
d1438 1
a1438 1
  PAT (Absyn.RECORDpat (rev columns,wild,ref Datatypes.NULLTYPE),pVE,tyvars)
d1444 1
a1444 1
  PAT (Absyn.RECORDpat (rev columns,true,ref Datatypes.NULLTYPE),pVE,tyvars)
d1450 1
a1450 1
  PAT (Absyn.RECORDpat ([],true,ref Datatypes.NULLTYPE),PE.empty_pVE,Set.empty_set)
@


1.19
log
@Changed interface to Derived to pass a pE for some functions
@
text
@d4 3
d421 1
a421 1
    (warn (opts,"Structure identifier " ^ IdentPrint.printLongStrId (mkLongStrId x) ^ " not defined");
@


1.18
log
@Changes for dynamic and coerce expressions
 Changed to improve error detection
@
text
@d4 4
a60 1
  structure PE : PARSERENV
d67 1
a67 1
  sharing Derived.Absyn.Datatypes.Ident = PE.Ident = IdentPrint.Ident
d77 1
a77 1
structure PE = PE
a758 16
(* it strdecs *)
fun make_it_strdec (e,tyvars,OPTS(location,_)) =
  Absyn.STRDECtopdec
  (Absyn.DECstrdec
   (Absyn.VALdec ([(Absyn.VALpat 
                    (annotate
                     (Ident.LONGVALID 
                      (mkPath [],
                       Ident.VAR (Symbol.find_symbol "it"))),
                     location),
                    e,
                    location)],
                   nil,
                   tyvars)),
  location)

d865 1
a865 1
     fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (marks_of opts) (rev l),tyvars)
d988 1
a988 1
  EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
d994 1
a994 1
  EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
d1012 1
a1012 1
  EXP(Derived.make_if (exp1,exp2,exp3,make_if_info(opts),marks_of opts),join_tyvars[tyvars1,tyvars2,tyvars3])
d1018 1
a1018 1
  EXP (Derived.make_while (exp1,exp2,make_while_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
d1463 1
a1463 1
     fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts),PE.empty_pVE,Set.empty_set)
d1468 1
a1468 1
     fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts),pVE,tyvars)
d1478 1
a1478 1
     fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts),pVE,tyvars)
d2365 2
a2366 1
     fn ([EXP(exp,tyvars)],opts) => TOPDEC (make_it_strdec(exp,tyvars,opts),PE.empty_pB)
@


1.17
log
@ref Nameset removed from FunBind abstract syntax
@
text
@d4 3
d328 1
a328 1
    error (opts,"Non-constructor " ^ (IdentPrint.printLongValId options id) ^ " used in pattern")
d354 1
a354 1
          then error(opts,"Leading zero in integer label not allowed")
a410 1
fun lookupStrId x = PE.lookupStrId (x,!ref_pE)
d412 9
a420 1
fun getValId (id as ([],sym)) = (lookupValId id handle PE.Lookup => Ident.VAR sym)
d424 2
a425 2

fun resolveLongValId id =
d430 7
a436 4
     handle PE.Lookup => mkLongVar id

fun resolveValId id =
  let val Ident.LONGVALID(_,res) = resolveLongValId([],id) in res end
d443 10
a452 8
fun check_is_infix (opts,[],s) =
  if is_infix s
    then
      ()
  else
    error (opts,"Symbol " ^ Symbol.symbol_name s ^ " is not infix")
    | check_is_infix _ =
      Crash.impossible "Bad arg to check_is_infix"
d476 11
a486 2
fun lookupFunId x = PE.lookupFunId (x,!ref_pB)
fun lookupSigId x = PE.lookupSigId (x,!ref_pB)
d488 1
d719 1
a719 1
    val pEs = map lookupStrId longids
d729 1
a729 1
    val pEs = map lookupStrId longids
d739 1
a739 1
    val pEs = map lookupSigId sigids
d793 3
d797 1
d812 1
a812 1
  fn ([dec],opts) => dec
d817 1
a817 1
  fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d822 1
a822 1
  fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d830 3
a832 3
  fn ([_],opts) =>
   (check_non_longid_op (opts,equal_lvalid); 
    EXP (Absyn.VALexp (mannotate (opts,equal_lvalid)), Set.empty_set))
d837 3
a839 3
  fn ([_,_],opts) => 
   (check_longid_op (opts,equal_lvalid);
    EXP (Absyn.VALexp (mannotate (opts,equal_lvalid)), Set.empty_set))
d844 1
a844 1
  fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d849 1
a849 1
  fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d854 2
a855 2
  fn ([_,LAB lab],opts) =>
   EXP (Derived.make_select (lab,marks_of opts,make_hash_info(opts,lab)),Set.empty_set)
d858 8
d868 2
a869 2
  fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
 | _ => raise ActionError 8,
d873 2
a874 2
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
 | _ => raise ActionError 9,
d878 2
a879 2
  fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (marks_of opts) (rev l),tyvars)
 | _ => raise ActionError 10,
d883 2
a884 2
  fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
 | _ => raise ActionError 11,
d888 3
a890 3
  fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
   (set_pE pE; EXP (Absyn.LOCALexp (dec,Derived.make_sequence_exp (rev l)),Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 12,
d894 2
a895 2
  fn ([_,x,_],opts) => x
 | _ => raise ActionError 13,
d899 2
a900 2
  fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 14,
d904 2
a905 2
  fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 15,
d909 2
a910 2
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 16,
d914 2
a915 2
  fn ([],opts) => EXPLIST ([],Set.empty_set)
 | _ => raise ActionError 17,
d919 2
a920 2
  fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
 | _ => raise ActionError 18,
d924 2
a925 2
  fn ([exp],opts) => exp
 | _ => raise ActionError 19,
d929 3
a931 3
  fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
   EXPSEQ ((exp,make_seq_info(opts),marks_of opts)::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 20,
d935 2
a936 2
  fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
 | _ => raise ActionError 21,
d940 3
a942 3
  fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
   EXPSEQ ((exp,make_seq_info(opts),marks_of opts)::l,Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 22,
d946 2
a947 2
  fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
 | _ => raise ActionError 23,
d951 3
a953 3
  fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
   (check_disjoint_labels(opts,lab,l);EXPROW ((lab,exp)::l,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 24,
d957 2
a958 2
  fn ([x],opts) => x
 | _ => raise ActionError 25,
d962 3
a964 3
  fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
   EXP(Absyn.APPexp(exp1,exp2,marks_of opts,ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 26,
d968 2
a969 2
  fn ([x],opts) => x
 | _ => raise ActionError 27,
d973 3
a975 3
  fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
   EXP (Absyn.APPexp (Absyn.VALexp (mannotate(opts,id)),Derived.make_tuple_exp [exp1,exp2],marks_of opts,ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 28,
d979 2
a980 2
  fn ([x],opts) => x
 | _ => raise ActionError 29,
d984 2
a985 2
  fn ([_],opts) => LONGVALID equal_lvalid
 | _ => raise ActionError 30,
d989 2
a990 2
  fn ([x],opts) => x
 | _ => raise ActionError 31,
d994 3
a996 3
  fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
   EXP (Absyn.TYPEDexp (exp,ty,marks_of opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 32,
d1000 3
a1002 3
  fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
   EXP (Derived.make_andalso (exp1,exp2,make_and_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 33,
d1006 3
a1008 3
  fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
   EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 34,
d1012 3
a1014 3
  fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
   EXP (Absyn.HANDLEexp (exp1, ref Datatypes.NULLTYPE, (rev match),marks_of opts,make_handle_info(opts)),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 35,
d1018 2
a1019 2
  fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
 | _ => raise ActionError 36,
d1024 3
a1026 3
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
   EXP(Derived.make_if (exp1,exp2,exp3,make_if_info(opts),marks_of opts),join_tyvars[tyvars1,tyvars2,tyvars3])
 | _ => raise ActionError 37,
d1030 3
a1032 3
  fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
   EXP (Derived.make_while (exp1,exp2,make_while_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 38,
d1036 3
a1038 3
  fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
   EXP (Derived.make_case (exp,(rev m),make_case_info(opts),marks_of opts),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 39,
d1042 3
a1044 3
  fn ([_,MATCH (match,tyvars)],opts) =>
   let val (a,b) = annotate (rev match) in EXP (Absyn.FNexp (a,b,make_fn_info(opts),marks_of opts),tyvars) end
 | _ => raise ActionError 40,
d1048 2
a1049 2
  fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 41,
d1053 2
a1054 2
  fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
 | _ => raise ActionError 42,
d1059 2
a1060 2
  fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 43,
d1065 2
a1066 2
  fn ([],opts) => DUMMY
 | _ => raise ActionError 44,
d1070 2
a1071 2
  fn ([_,_],opts) => DUMMY
 | _ => raise ActionError 45,
d1075 2
a1076 2
  fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 46,
d1080 2
a1081 2
  fn ([_,dec,_],opts) => dec
 | _ => raise ActionError 47,
d1085 2
a1086 2
  fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
 | _ => raise ActionError 48,
d1090 2
a1091 2
  fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 49,
d1095 2
a1096 2
  fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 50,
d1104 3
a1106 3
  fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
   DEC (Absyn.VALdec (rev valbinds1,rev valbinds2,tyvars),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 51,
d1110 3
a1112 3
  fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
 DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind (y,options_of opts)) (rev l)),tyvars,marks_of opts),pVE_in_pE pVE,Set.empty_set)
 | _ => raise ActionError 52,
d1116 2
a1117 2
  fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
 | _ => raise ActionError 53,
d1123 3
a1125 3
  fn ([_,DATBIND (d,pVE)],opts) => 
   (extend_pVE pVE; DEC (Absyn.DATATYPEdec (marks_of opts,rev d),pVE_in_pE pVE,Set.empty_set))
 | _ => raise ActionError 54,
d1129 5
a1133 5
  fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
   (check_disjoint_withtype(opts,d,t);
    extend_pVE pVE;
    DEC (Derived.make_datatype_withtype (marks_of opts,rev d, t),pVE_in_pE pVE,Set.empty_set))
 | _ => raise ActionError 55,
d1137 3
a1139 3
  fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
   DEC (Absyn.ABSTYPEdec (marks_of opts,rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars)
 | _ => raise ActionError 56,
d1143 4
a1146 4
  fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
   (check_disjoint_withtype(opts,d,t);
    DEC (Derived.make_abstype_withtype (marks_of opts,rev d,t,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
 | _ => raise ActionError 57,
d1149 2
a1150 2
  fn ([d as (DATBIND(_,pVE))],opts) => (extend_pVE pVE;d)
 | _ => raise ActionError 58,
d1154 3
a1156 3
  fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
   (extend_pVE pVE; DEC (Absyn.EXCEPTIONdec (rev l),pVE_in_pE pVE,tyvars))
 | _ => raise ActionError 59,
d1160 4
a1163 4
  fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
   (set_pE (PE.augment_pE (env_pE,pE));
    DEC (Absyn.LOCALdec (dec1,dec2),pE,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 60,
d1169 2
a1170 2
  fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
 | _ => raise ActionError 61,
d1177 2
a1178 2
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
 | _ => raise ActionError 62,
d1182 2
a1183 2
  fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
 | _ => raise ActionError 63,
d1187 2
a1188 2
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
 | _ => raise ActionError 64,
d1192 2
a1193 2
  fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
 | _ => raise ActionError 65,
d1197 2
a1198 2
  fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
 | _ => raise ActionError 66,
d1204 2
a1205 2
  fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 67,
d1209 2
a1210 2
  fn ([x],opts) => x
 | _ => raise ActionError 68,
d1214 3
a1216 3
  fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
   VALBIND (a::v1,v2,Set.union(tyvars1,tyvars2),merge_pVEs(opts,pVE1,pVE2))
 | _ => raise ActionError 69,
d1220 3
a1222 3
  fn ([VALBIND (v1,v1',tyvars1,pVE1),_,_,VALBIND(v2,v2',tyvars2,pVE2)],opts) =>
   VALBIND (v1,v1' @@ v2 @@ v2',Set.union(tyvars1,tyvars2),merge_pVEs(opts,pVE1,pVE2))
 | _ => raise ActionError 70,
d1226 3
a1228 3
  fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
 (check_rec_bindings (opts,v1); VALBIND ([],v2@@v1,tyvars,pVE))
 | _ => raise ActionError 71,
d1232 3
a1234 3
  fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
   VALBIND ([(pat,exp,marks_of opts)],[],Set.union (tyvars1,tyvars2),pVE)
 | _ => raise ActionError 72,
d1240 3
a1242 3
  fn ([FVALLIST (fvals,tyvars,id)],opts) =>
   FVALBIND (([((rev fvals),make_fval_info(opts),marks_of opts)],tyvars),make_pVE id)
 | _ => raise ActionError 73,
d1246 3
a1248 3
  fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
   FVALBIND (((rev fvals,make_fval_info(opts),marks_of opts)::l,Set.union(tyvars1,tyvars2)),addNewValId(opts,id,pVE))
 | _ => raise ActionError 74,
d1252 2
a1253 2
  fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
 | _ => raise ActionError 75,
d1258 3
a1260 3
  fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
   FVALLIST (fval::fvals,Set.union(tyvars1,tyvars2),id)
 | _ => raise ActionError 76,
d1264 5
a1268 5
  fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
  FVAL(((id,rev l,Absyn.TYPEDexp(exp,ty,marks_of opts)),join_tyvars[tyvars1,tyvars2,tyvars3]),id)
 |([VALID id,PATLIST (l,pE,tyvars1),NULLTYPE,_,EXP (exp,tyvars3)],opts) =>
    FVAL(((id,rev l,exp),Set.union(tyvars1,tyvars3)),id)
 | _ => raise ActionError 77,
d1272 2
a1273 2
  fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
d1275 2
a1276 2
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id)
 | _ => raise ActionError 78,
d1280 2
a1281 2
  fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3]),id)
d1283 2
a1284 2
 FVAL(make_infix_fval (opts,id,pat1,pat2,[],exp,[tyvars1,tyvars2]),id)
 | _ => raise ActionError 79,
d1288 2
a1289 2
  fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
   FVAL(make_infix_fval(opts,id,pat1,pat2,rev patl,Absyn.TYPEDexp(exp,ty,marks_of opts),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
d1291 2
a1292 2
   FVAL(make_infix_fval(opts,id,pat1,pat2,rev patl,exp,[tyvars1,tyvars2,tyvars3]),id)
 | _ => raise ActionError 80,
d1296 2
a1297 2
  fn ([],opts) => NULLTYPE
 | _ => raise ActionError 81,
d1301 2
a1302 2
  fn ([_,ty],opts) => ty
 | _ => raise ActionError 82,
d1306 2
a1307 2
  fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
 | _ => raise ActionError 83,
d1311 3
a1313 3
  fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
    (check_disjoint_typbind(opts,tb,tbl);TYPBIND (tb::tbl))
 | _ => raise ActionError 84,
d1317 3
a1319 3
  fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty))
 | _ => raise ActionError 85,
d1323 2
a1324 2
  fn ([],opts) => TYVARLIST []
 | _ => raise ActionError 86,
d1328 2
a1329 2
  fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 87,
d1333 2
a1334 2
  fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
 | _ => raise ActionError 88,
d1338 2
a1339 2
  fn ([TYVAR t],opts) => TYVARLIST [t]
 | _ => raise ActionError 89,
d1343 2
a1344 2
  fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
 | _ => raise ActionError 90,
d1348 2
a1349 2
  fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
 | _ => raise ActionError 91,
d1353 3
a1355 3
  fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
 (check_disjoint_datbind(opts,d,l);DATBIND(d::l,merge_pVEs(opts,pVE,pVE')))
 | _ => raise ActionError 92,
d1359 4
a1362 4
  fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);
    DATBIND1 ((rev tyvarlist,tycon,ref Datatypes.NULLTYPE,rev conbind),pVE))
 | _ => raise ActionError 93,
d1366 2
a1367 2
  fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
 | _ => raise ActionError 94,
d1371 3
a1373 3
  fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
   CONBIND(cb::cbl,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 95,
d1377 3
a1379 3
  fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
 | ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,Absyn.ABSENT),id,Set.empty_set)
 | _ => raise ActionError 96,
d1383 2
a1384 2
  fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
 | _ => raise ActionError 97,
d1388 3
a1390 3
  fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
   EXBIND (e::l,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 98,
d1394 2
a1395 2
  fn ([VALID id, TY (ty,tyvars)],opts) => 
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.PRESENT ty,marks_of opts,make_exbind_info(opts,id)),id,tyvars)
d1397 2
a1398 2
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.ABSENT,marks_of opts,make_exbind_info(opts,id)),id,Set.empty_set)
 | _ => raise ActionError 99,
d1402 3
a1404 3
  fn ([VALID id,_,LONGVALID id'],opts) => 
   EXBIND1 (Absyn.OLDexbind (annotate id,id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set)
 | _ => raise ActionError 100,
d1408 2
a1409 2
  fn ([],opts) => NULLTYPE
 | _ => raise ActionError 101,
d1413 2
a1414 2
  fn ([_,x],opts) => x
 | _ => raise ActionError 102,
d1418 2
a1419 2
  fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 103,
d1423 2
a1424 2
  fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 104,
d1430 3
a1432 3
  fn ([VALID id],opts) => 
   PAT (Absyn.VALpat (annotate (make_long_id id),marks_of opts),make_pVE id,Set.empty_set)
 | _ => raise ActionError 105,
d1436 4
a1439 4
  fn ([LONGVALID id],opts) => 
   (check_is_constructor (opts,id);
    PAT (Absyn.VALpat (annotate id,marks_of opts),PE.empty_pVE,Set.empty_set))
 | _ => raise ActionError 106,
d1443 3
a1445 3
  fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
   PAT (Absyn.RECORDpat (rev columns,wild,ref Datatypes.NULLTYPE),pVE,tyvars)
 | _ => raise ActionError 107,
d1449 3
a1451 3
  fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
   PAT (Absyn.RECORDpat (rev columns,true,ref Datatypes.NULLTYPE),pVE,tyvars)
 | _ => raise ActionError 108,
d1455 3
a1457 3
  fn ([_,_,_],opts) => 
   PAT (Absyn.RECORDpat ([],true,ref Datatypes.NULLTYPE),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 109,
d1461 2
a1462 2
  fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 110,
d1466 2
a1467 2
  fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 111,
d1471 2
a1472 2
  fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
 | _ => raise ActionError 112,
d1476 2
a1477 2
  fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts),PE.empty_pVE,Set.empty_set)
 | _ => raise ActionError 113,
d1481 2
a1482 2
  fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts),pVE,tyvars)
 | _ => raise ActionError 114,
d1486 2
a1487 2
  fn ([_,x,_],opts) => x
 | _ => raise ActionError 115,
d1491 2
a1492 2
  fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts),pVE,tyvars)
 | _ => raise ActionError 116,
d1496 3
a1498 3
  fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
   BINPAT(pat1,id,pat2,merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 117,
d1502 4
a1505 4
  fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
   (check_is_short_constructor (opts,id);
    PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],marks_of opts),pVE,tyvars))
 | _ => raise ActionError 118,
d1509 2
a1510 2
  fn ([x],opts) => x
 | _ => raise ActionError 119,
d1514 3
a1516 3
  fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
   PATLIST ([pat2,pat1], merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 120,
d1520 3
a1522 3
  fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
   PATLIST (pat2::pat1, merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 121,
d1526 2
a1527 2
  fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
 | _ => raise ActionError 122,
d1531 4
a1534 4
  fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
   (check_disjoint_labels(opts,lab,l);
    PATROW (lp :: l,wild,merge_pVEs(opts,pVE1,pVE2), Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 123,
d1538 2
a1539 2
  fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 124,
d1543 3
a1545 3
  fn ([SYM sym, TY (ty,tyvars)],opts) =>
   (check_not_constructor_symbol (opts,sym);
    PATROW1 ((Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.ABSENT,marks_of opts)),make_Sym_pVE sym,tyvars))
d1547 3
a1549 3
   (check_not_constructor_symbol (opts,sym);
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.ABSENT,marks_of opts),make_Sym_pVE sym,Set.empty_set))
 | _ => raise ActionError 125,
d1553 3
a1555 3
  fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
   (check_not_constructor_symbol (opts,sym);
    PATROW1 (Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),Set.union (tyvars1,tyvars2)))
d1557 3
a1559 3
   (check_not_constructor_symbol (opts,sym);
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.PRESENT pat,marks_of opts),addNewSymId(opts,sym,pVE),tyvars))
 | _ => raise ActionError 126,
d1563 2
a1564 2
  fn ([x],opts) => x
 | _ => raise ActionError 127,
d1568 3
a1570 3
  fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
   (check_is_constructor (opts,id); PAT (Absyn.APPpat (annotate id, pat,marks_of opts),pVE,tyvars))
 | _ => raise ActionError 128,
d1574 5
a1578 4
  fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
   (check_is_constructor (opts,id);
    PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2],marks_of opts),merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 129,
d1582 2
a1583 2
  fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 130,
d1587 2
a1588 2
  fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
   PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate id, pat), ty,marks_of opts),addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
d1590 2
a1591 2
   PAT (Absyn.LAYEREDpat (annotate id, pat),addNewValId(opts,id,pVE),tyvars)
 | _ => raise ActionError 131,
d1597 2
a1598 2
  fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 132,
d1602 2
a1603 2
  fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 133,
d1607 2
a1608 2
  fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
 | _ => raise ActionError 134,
d1612 2
a1613 2
  fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
 | _ => raise ActionError 135,
d1617 2
a1618 2
  fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
 | _ => raise ActionError 136,
d1622 2
a1623 2
  fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
 | _ => raise ActionError 137,
d1627 2
a1628 2
  fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
 | _ => raise ActionError 138,
d1632 2
a1633 2
  fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
 | _ => raise ActionError 139,
d1637 2
a1638 2
  fn ([_,t,_],opts) => t
 | _ => raise ActionError 140,
d1642 2
a1643 2
  fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 141,
d1647 2
a1648 2
  fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
 | _ => raise ActionError 142,
d1652 2
a1653 2
  fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 143,
d1657 2
a1658 2
  fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 144,
d1662 2
a1663 2
  fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 145,
d1667 2
a1668 2
  fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
 | _ => raise ActionError 146,
d1672 3
a1674 3
  fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
 (check_disjoint_labels(opts,lab,l);TYROW ((lab,ty)::l,Set.union(tyvars1,tyvars2)))
 | _ => raise ActionError 147,
d1680 2
a1681 2
  fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
 | _ => raise ActionError 148,
d1685 3
a1687 3
  fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
   PATLIST (pat::l,merge_pVEs(opts,pVE1,pVE2),Set.union (tyvars1,tyvars2))
 | _ => raise ActionError 149,
d1693 2
a1694 2
  fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
 | _ => raise ActionError 150,
d1698 2
a1699 2
  fn ([LONGID id],opts) => LONGIDLIST[id]
 | _ => raise ActionError 151,
d1705 2
a1706 2
  fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
 | _ => raise ActionError 152,
d1710 2
a1711 2
  fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
 | _ => raise ActionError 153,
d1717 2
a1718 2
  fn ([SYM sym],opts) => SYMLIST [sym]
 | _ => raise ActionError 154,
d1722 2
a1723 2
  fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
 | _ => raise ActionError 155,
d1729 2
a1730 2
  fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
 | _ => raise ActionError 156,
d1734 2
a1735 2
  fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
 | _ => raise ActionError 157,
d1739 2
a1740 2
  fn ([STRING s],opts) => SCON (Ident.STRING s)
 | _ => raise ActionError 158,
d1746 1
a1746 1
  fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
d1748 2
a1749 2
   (report_long_error (opts,id,"record label"); LAB (Ident.LAB s))
 | _ => raise ActionError 159,
d1753 2
a1754 2
  fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
 | _ => raise ActionError 160,
d1760 2
a1761 2
  fn ([LONGID id],opts) => LONGVALID (resolveLongValId id)
 | _ => raise ActionError 161,
d1765 2
a1766 2
  fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
 | _ => raise ActionError 162,
d1770 2
a1771 2
  fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
 | _ => raise ActionError 163,
d1775 2
a1776 2
  fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
 | _ => raise ActionError 164,
d1780 2
a1781 2
  fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
 | _ => raise ActionError 165,
d1787 1
a1787 1
  fn ([LONGID ([],s)],opts) => SYM s
d1789 2
a1790 2
   (report_long_error (opts,id,"symbol"); SYM s)
 | _ => raise ActionError 166,
d1794 2
a1795 2
  fn ([_],opts) => SYM equal_symbol
 | _ => raise ActionError 167,
d1799 2
a1800 2
  fn ([SYM s],opts) => FUNID(Ident.FUNID s)
 | _ => raise ActionError 168,
d1804 2
a1805 2
  fn ([SYM s],opts) => SIGID(Ident.SIGID s)
 | _ => raise ActionError 169,
d1809 2
a1810 2
  fn ([SYM s],opts) => STRID(Ident.STRID s)
 | _ => raise ActionError 170,
d1818 3
a1820 3
  fn ([LONGID (id as ([],_))],opts) => LONGVALID (resolveLongValId id)
| ([LONGID id],opts) => (report_long_error (opts,id,"variable"); LONGVALID (resolveLongValId id))
 | _ => raise ActionError 171,
d1826 3
a1828 3
  fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"variable"); VALID (Ident.VAR id))
 | _ => raise ActionError 172,
d1832 2
a1833 2
  fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
 | _ => raise ActionError 173,
d1837 2
a1838 2
  fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
 | _ => raise ActionError 174,
d1843 1
a1843 1
  fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
d1845 1
a1845 1
 | _ => raise ActionError 175,
d1849 1
a1849 1
  fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
d1851 1
a1851 1
 | _ => raise ActionError 176,
d1855 2
a1856 2
  fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
 | _ => raise ActionError 177,
d1860 2
a1861 2
  fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
 | _ => raise ActionError 178,
d1865 1
a1865 1
  fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
d1867 1
a1867 1
 | _ => raise ActionError 179,
d1871 2
a1872 2
  fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
 | _ => raise ActionError 180,
d1876 2
a1877 2
  fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
 | _ => raise ActionError 181,
d1881 1
a1881 1
  fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
d1883 1
a1883 1
 | _ => raise ActionError 182,
d1887 2
a1888 2
  fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
 | _ => raise ActionError 183,
d1894 2
a1895 2
  fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
 | _ => raise ActionError 184,
d1899 2
a1900 2
  fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId x)
 | _ => raise ActionError 185,
d1904 3
a1906 3
  fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
   STREXP (Absyn.APPstrexp (funid,strexp,marks_of opts),lookupFunId funid)
 | _ => raise ActionError 186,
d1910 3
a1912 3
  fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
   STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,marks_of opts),lookupFunId funid)
 | _ => raise ActionError 187,
d1916 3
a1918 3
  fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
   (set_pE pE; STREXP (Absyn.LOCALstrexp(strdec,strexp),e'))
 | _ => raise ActionError 188,
d1922 2
a1923 2
  fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 189,
d1927 2
a1928 2
  fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
 | _ => raise ActionError 190,
d1932 2
a1933 2
  fn ([_,strdec,_],opts) => strdec
 | _ => raise ActionError 191,
d1937 2
a1938 2
  fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 192,
d1942 2
a1943 2
  fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 193,
d1947 2
a1948 2
  fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 194,
d1954 2
a1955 2
  fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
 | _ => raise ActionError 195,
d1959 2
a1960 2
  fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
 | _ => raise ActionError 196,
d1964 3
a1966 3
  fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
   STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 197,
d1970 3
a1972 3
  fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
   STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 198,
d1978 2
a1979 2
  fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
 | _ => raise ActionError 199,
d1983 3
a1985 3
  fn ([_,STRBIND(l,pSE)],opts) => 
   (extend_pSE pSE;STRDEC(Absyn.STRUCTUREstrdec l,pSE_in_pE pSE))
 | _ => raise ActionError 200,
d1989 3
a1991 3
  fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
   (set_pE (PE.augment_pE(pE,pE'));STRDEC(Absyn.LOCALstrdec(strdec1,strdec2),pE'))
 | _ => raise ActionError 201,
d1995 2
a1996 2
  fn ([STRBIND1 (d,id_pE)],opts) => STRBIND([d],make_pSE id_pE)
 | _ => raise ActionError 202,
d2000 3
a2002 3
  fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
    STRBIND(d::l,addNewStrId(opts,id_pE,pSE))
 | _ => raise ActionError 203,
d2006 3
a2008 3
  fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
   STRBIND1((id,Absyn.PRESENT sigexp,strexp,marks_of opts),(id,pE1))
 | _ => raise ActionError 204,
d2012 3
a2014 3
  fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
   STRBIND1((id,Absyn.ABSENT,strexp,marks_of opts),(id,pE))
 | _ => raise ActionError 205,
d2018 3
a2020 3
  fn ([ENV pE,SPEC (spec,e),_],opts) => 
   (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref Absyn.ABSENT),e))
 | _ => raise ActionError 206,
d2024 2
a2025 2
  fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Absyn.ABSENT,marks_of opts),lookupSigId id)
 | _ => raise ActionError 207,
d2029 2
a2030 2
  fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
 | _ => raise ActionError 208,
d2034 2
a2035 2
  fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
 | _ => raise ActionError 209,
d2039 2
a2040 2
  fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
 | _ => raise ActionError 210,
d2044 2
a2045 2
  fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
 | _ => raise ActionError 211,
d2049 2
a2050 2
  fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
 | _ => raise ActionError 212,
d2054 3
a2056 3
  fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
   SIGBIND((id,sigexp,marks_of opts)::l,addNewSigId(opts,(id,e),pG))
 | _ => raise ActionError 213,
d2060 2
a2061 2
  fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
 | _ => raise ActionError 214,
d2065 2
a2066 2
  fn ([_,spec,_],opts) => spec
 | _ => raise ActionError 215,
d2070 2
a2071 2
  fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
 | _ => raise ActionError 216,
d2075 3
a2077 3
  fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
   SPECLIST([spec2,spec1],PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 217,
d2081 3
a2083 3
  fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
   SPECLIST(spec::l,PE.augment_pE(pE1,pE2))
 | _ => raise ActionError 218,
d2089 2
a2090 2
  fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
 | _ => raise ActionError 219,
d2094 2
a2095 2
  fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 220,
d2099 2
a2100 2
  fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
 | _ => raise ActionError 221,
d2104 2
a2105 2
  fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
 | _ => raise ActionError 222,
d2109 2
a2110 2
  fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
 | _ => raise ActionError 223,
d2114 2
a2115 2
  fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
 | _ => raise ActionError 224,
d2119 2
a2120 2
  fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
 | _ => raise ActionError 225,
d2124 3
a2126 3
  fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
   (set_pE (PE.augment_pE(pE,pE2));SPEC(Absyn.LOCALspec(spec1,spec2),pE2))
 | _ => raise ActionError 226,
d2130 2
a2131 2
  fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
 | _ => raise ActionError 227,
d2135 2
a2136 2
  fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
 | _ => raise ActionError 228,
d2140 2
a2141 2
  fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
 | _ => raise ActionError 229,
d2145 2
a2146 2
  fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
 | _ => raise ActionError 230,
d2150 2
a2151 2
  fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
 | _ => raise ActionError 231,
d2155 3
a2157 3
  fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
   VALDESC((v,ty,tyvars)::l,addNewValId(opts,v,pVE))
 | _ => raise ActionError 232,
d2161 2
a2162 2
  fn ([TYPDESC1 x],opts) => TYPDESC[x]
 | _ => raise ActionError 233,
d2166 3
a2168 3
  fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
   (check_disjoint_typdesc(opts,t,l); TYPDESC (t::l))
 | _ => raise ActionError 234,
d2172 2
a2173 2
  fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
 | _ => raise ActionError 235,
d2178 2
a2179 2
  fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
 | _ => raise ActionError 236,
d2183 3
a2185 3
  fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
   (check_disjoint_datdesc(opts,d,l); DATDESC(d::l,merge_pVEs(opts,pVE,pVE')))
 | _ => raise ActionError 237,
d2189 4
a2192 4
  fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);
    DATDESC1((rev tyvarlist,tycon,(rev l)),pVE))
 | _ => raise ActionError 238,
d2196 2
a2197 2
  fn ([x],opts) => x
 | _ => raise ActionError 239,
d2201 3
a2203 3
  fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
   CONDESC(x::l,merge_pVEs(opts,e,e'),Set.union(tyvars,tyvars'))
 | _ => raise ActionError 240,
d2207 2
a2208 2
  fn ([VALID con,TY(ty,tyvars)],opts) => 
   CONDESC([(con,Absyn.PRESENT ty)],make_pVE con,tyvars)
d2210 2
a2211 2
   CONDESC([(con,Absyn.ABSENT)],make_pVE con,Set.empty_set)
 | _ => raise ActionError 241,
d2215 2
a2216 2
  fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
 | _ => raise ActionError 242,
d2220 3
a2222 3
  fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
   EXDESC((excon,ty,marks)::l,addNewValId(opts,excon,pVE))
 | _ => raise ActionError 243,
d2226 2
a2227 2
  fn ([VALID excon,TY(ty,_)],opts) => 
   EXDESC1(excon,Absyn.PRESENT ty,marks_of opts)
d2229 2
a2230 2
   EXDESC1(excon,Absyn.ABSENT,marks_of opts)
 | _ => raise ActionError 244,
d2234 2
a2235 2
  fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(strid,pE))
 | _ => raise ActionError 245,
d2239 3
a2241 3
  fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
   STRDESC((strid,e)::l,addNewStrId(opts,(strid,pE),pSE))
 | _ => raise ActionError 246,
d2245 2
a2246 2
  fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
 | _ => raise ActionError 247,
d2250 2
a2251 2
  fn ([x],opts) => x
 | _ => raise ActionError 248,
d2255 2
a2256 2
  fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
 | _ => raise ActionError 249,
d2260 2
a2261 2
  fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
 | _ => raise ActionError 250,
d2265 2
a2266 2
  fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
 | _ => raise ActionError 251,
d2270 2
a2271 2
  fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
 | _ => raise ActionError 252,
d2275 2
a2276 2
  fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
 | _ => raise ActionError 253,
d2280 2
a2281 2
  fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
 | _ => raise ActionError 254,
d2285 2
a2286 2
  fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
 | _ => raise ActionError 255,
d2290 2
a2291 2
  fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
 | _ => raise ActionError 256,
d2295 2
a2296 2
  fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
 | _ => raise ActionError 257,
d2300 2
a2301 2
  fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
 | _ => raise ActionError 258,
d2305 3
a2307 3
  fn ([FUNBIND1(fbind,funid,pE)],opts) =>
 FUNBIND([fbind],make_pF(funid,pE))
 | _ => raise ActionError 259,
d2311 3
a2313 3
  fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
 FUNBIND (fbind::l,addNewFunId(opts,(funid,pE),pF))
 | _ => raise ActionError 260,
d2317 3
a2319 3
  fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.PRESENT sigexp',make_funbind_info(opts,funid),marks_of opts),funid,pE''))
 | _ => raise ActionError 261,
d2323 3
a2325 3
  fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,strexp,Absyn.ABSENT,make_funbind_info (opts,funid),marks_of opts),funid,pE'''))
 | _ => raise ActionError 262,
d2329 3
a2331 3
  fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.PRESENT sigexp,strexp,pE''))
 | _ => raise ActionError 263,
d2335 3
a2337 3
  fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.ABSENT,strexp,pE'''))
 | _ => raise ActionError 264,
d2341 3
a2343 3
  fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
 (extend_pSE(make_pSE(strid,pE'));STARTFUNBIND1(funid,pE,strid,sigexp,pE'))
 | _ => raise ActionError 265,
d2347 3
a2349 3
  fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
 (extend_pE pE'; STARTFUNBIND2(funid,pE,spec,pE'))
 | _ => raise ActionError 266,
d2353 2
a2354 2
  fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
 | _ => raise ActionError 267,
d2358 2
a2359 2
  fn ([],opts) => TOPDEC (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB)
 | _ => raise ActionError 268,
d2363 2
a2364 2
  fn ([STRDEC(strdec,pE)],opts) => TOPDEC (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
 | _ => raise ActionError 269,
d2368 2
a2369 2
  fn ([SIGDEC(l,pG)],opts) => TOPDEC (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
 | _ => raise ActionError 270,
d2373 2
a2374 2
  fn ([FUNDEC(l,pF)],opts) => TOPDEC (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
 | _ => raise ActionError 271,
d2378 2
a2379 2
  fn ([EXP(exp,tyvars)],opts) => TOPDEC (make_it_strdec(exp,tyvars,opts),PE.empty_pB)
 | _ => raise ActionError 272,
d2383 2
a2384 2
  fn ([_,STRING s],opts) => TOPDEC (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
 | _ => raise ActionError 273,
d2389 2
a2390 2
  fn ([TOPDEC x],opts) => raise FoundTopDec x
 | _ => raise ActionError 274,
d2394 2
a2395 2
  fn ([x,_,_],opts) => x
 | _ => raise ActionError 275,
d2399 2
a2400 2
  fn ([x,_],opts) => x
 | _ => raise ActionError 276,
d2404 2
a2405 2
  fn ([x],opts) => x
 | _ => raise ActionError 277,
d2501 3
a2503 2
(* 	(((:reduce (vardef :longid)) (:reduce (longvar :longid)))  *)
(*          (:funcall ifvarstack (:reduce (vardef :longid)) (:reduce (longvar :longid))))  *)
a2507 66
(* (setq parsergen::*unresolve*  *)
(*       '(((atpat opvardef)  *)
(* 	 (pat opvardef opttype :as pat))  *)
(* 	((pat oplongvar atpat)  *)
(* 	 (atpat oplongvar))  *)
(* 	((infexp appexp)  *)
(* 	 (appexp appexp atexp))  *)
(* 	((pat atpat)  *)
(* 	 (fval :lpar atpat vardef atpat :rpar opttype :equal exp))  *)
(* 	((atpat opvardef)  *)
(* 	 (fval opvardef atpatlist opttype :equal exp))  *)
(* 	((atpat1 bin_atpat)  *)
(* 	 (fval bin_atpat atpatlist opttype :equal exp))  *)
(* 	((pat atpat)  *)
(* 	 (bin_atpat :lpar atpat patvar atpat :rpar))  *)

(* 	;; problems with type tuples  *)
(* 	((tytuple ty star ty)  *)
(* 	 (ty ty longtycon))  *)
(* 	((tytuple tytuple star ty)  *)
(* 	 (ty ty longtycon))  *)
(* 	  *)
(* 	;; reduce-reduce conflicts  *)
(* 	((vardef :longid)  *)
(* 	 (longvar :longid))  *)
(* 	((star :longid)  *)
(* 	 (longtycon :longid))  *)
(* 	))  *)

(* (setq parsergen::*resolutions*  *)
(*       '(;; associativity of tupling  *)
(* 	((tytuple tytuple star ty)  *)
(* 	 (ty ty :arrow ty))  *)
(* 	((tytuple ty star ty)  *)
(* 	 (ty ty :arrow ty))  *)
(* 	((ty ty longtycon)  *)
(* 	 (pat pat :colon ty))  *)
(* 	;; always make a tuple before a type  *)
(* 	((tytuple tytuple star ty)  *)
(* 	 (ty tytuple))  *)
(* 	;; matches go far to the left  *)
(* 	((match match :vbar mrule)  *)
(* 	 (exp :handle match))  *)
(* 	((match match :vbar mrule)  *)
(* 	 (exp :fn match))  *)
(* 	((match match :vbar mrule)  *)
(* 	 (exp :case exp :of match))  *)

(* 	;; semicolons,strdecs and decs  *)
(* 	;; Reduce decs to strdecs wherever possible  *)
(* 	((strdec decsep)(dec decsep))  *)
(* 	((strdec1 dec1)(decsep))  *)
(* 	((strdec1 dec1)(decsep))  *)
(* 	))  *)

(* (setq parsergen::*single-conflicts*  *)
(*       '(((pat pat var pat) :both)  *)
(* 	((tytuple ty star ty) :reduce)  *)
(* 	((ty ty :arrow ty) :shift)  *)
(* 	;; just a guess  *)
(* 	((exp exp :andalso exp) :reduce)  *)
(* 	;; just a guess  *)
(* 	((exp exp :orelse exp) :reduce)  *)
(* 	((infexp infexp infvar infexp) :both)  *)
(* 	))  *)

d2516 1
d2550 2
a2551 1
fun ifVarStack (varred,conred,[LONGID (id as ([],s))],_) =
d2704 2
@


1.16
log
@Changed sigexps
Fixed integer label bug
Changed asterisk tycon error to be an ordinary error.
@
text
@d4 5
a80 2
structure Nameset = Absyn.Nameset

d97 1
a97 1
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Nameset.Nameset ref * Absyn.StrExp * Absyn.SigExp Absyn.opt * string * Absyn.Location.T)
d751 1
a751 1
  let val (a,b,c,d,e,f) =
d758 1
a758 1
    FUNBIND1 ((a,b,c,d,e,f,make_funbind_info(opts,funid),marks_of opts),funid,pE)
d2280 1
a2280 1
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.PRESENT sigexp',make_funbind_info(opts,funid),marks_of opts),funid,pE''))
d2286 1
a2286 1
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.ABSENT,make_funbind_info (opts,funid),marks_of opts),funid,pE'''))
@


1.15
log
@Put back marks in SCONs
@
text
@d4 3
a76 1
structure Interface = Absyn.Interface
d277 1
a277 1
     do_info(opts, Info.NONSTANDARD, "Asterisk not allowed as type constructor")
d298 1
a298 1
     do_info(opts,Info.NONSTANDARD,"Asterisk not allowed as TyCon")
d347 13
a359 10
        let val not_posint =
          first = "~"
          orelse
          Lists.forall(fn s => s = "0") digits
        in
          if not_posint then
            error(opts,"Integer label must be positive")
          else
            ()
        end
d750 1
a750 1
                          Absyn.NEWsigexp(spec,ref Interface.emptyInt),
d1978 1
a1978 1
   (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref Interface.emptyInt),e))
d1983 1
a1983 1
  fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Interface.emptyInt,marks_of opts),lookupSigId id)
@


1.14
log
@Changed location in scons to UNKNOWNs
@
text
@d4 3
d1683 1
a1683 1
  fn ([INTEGER s],opts) => SCON (Ident.INT(s,Info.Location.UNKNOWN))
d1688 1
a1688 1
  fn ([REAL s],opts) => SCON (Ident.REAL (s,Info.Location.UNKNOWN))
@


1.13
log
@Changed int and real scons to carry a location around
@
text
@d4 3
d1680 1
a1680 1
  fn ([INTEGER s],opts) => SCON (Ident.INT(s,marks_of opts))
d1685 1
a1685 1
  fn ([REAL s],opts) => SCON (Ident.REAL (s,marks_of opts))
@


1.12
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d1677 1
a1677 1
  fn ([INTEGER s],opts) => SCON (Ident.INT s)
d1682 1
a1682 1
  fn ([REAL s],opts) => SCON (Ident.REAL s)
@


1.11
log
@Fixed more error messages
@
text
@d4 3
a26 2
require "../typechecker/interface";
require "../typechecker/nameset";
d40 1
d42 1
d44 1
a44 1
  sharing Derived.Absyn.IdentClass = PE.Ident = IdentPrint.Ident
a63 1
structure Set = Absyn.Set
@


1.10
log
@Changed error messages
@
text
@d4 3
a228 3
fun advise (opts,message) =
  do_info(opts,Info.ADVICE,message)

d319 1
a319 1
    error (opts,"Constructor " ^ (IdentPrint.printValId options id) ^ " used in pattern")
d325 1
a325 1
    error (opts,"Constructor " ^ (IdentPrint.printValId options id) ^ " used in pattern")
d638 1
a638 1
      advise (opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d651 1
a651 1
    advise(opts,"Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d1691 1
a1691 1
   (report_long_error (opts,id,"LABEL"); LAB (Ident.LAB s))
d1732 1
a1732 1
   (report_long_error (opts,id,"ID"); SYM s)
d1762 1
a1762 1
| ([LONGID id],opts) => (report_long_error (opts,id,"VAR"); LONGVALID (resolveLongValId id))
d1770 1
a1770 1
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"VAR"); VALID (Ident.VAR id))
d1787 1
a1787 1
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"VAR"); VALID (Ident.VAR id))
d1793 1
a1793 1
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"CON"); VALID (Ident.CON s))
d1809 1
a1809 1
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"EXCON"); VALID (Ident.EXCON s))
d1825 1
a1825 1
| ([LONGID (id as (l,s))],opts) => (report_long_error (opts,id,"TYCON"); TYCON (mkTyCon(opts,s)))
@


1.9
log
@ Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d597 1
a597 1
    (error(opts,"Duplicate value binding: " ^ IdentPrint.printValId options valid1);
d642 1
a642 1
      warn (opts,"Need an op for " ^ Symbol.symbol_name(get_sym v))
@


1.8
log
@Fixed parsing bugs
with rec and abstype
@
text
@d3 5
a7 1
$Log: actionfunctions.sml,v $
d23 14
a36 12
functor ActionFunctions (structure LRbasics : LRBASICS
                         structure Derived : DERIVED
                         structure Lists : LISTS
                         structure Integer : INTEGER
                         structure IdentPrint : IDENTPRINT
                         structure PE : PARSERENV
                         structure Token : TOKEN
                         structure Crash : CRASH

                         sharing Derived.Absyn.Datatypes.Ident.Symbol = Token.Symbol
                         sharing Derived.Absyn.IdentClass = PE.Ident = IdentPrint.Ident
                           ) : ACTIONFUNCTIONS =
a47 1
structure Info = Info
d301 1
a301 1
fun check_is_constructor (opts,id) =
d305 1
a305 1
    error (opts,"Non-constructor " ^ (IdentPrint.printLongValId id) ^ " used in pattern")
d307 1
a307 1
fun check_is_short_constructor (opts,id) =
d311 1
a311 1
    error (opts,"Non-constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d313 1
a313 1
fun check_not_constructor (opts,id) =
d315 1
a315 1
    error (opts,"Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d319 1
a319 1
fun check_not_short_constructor (opts,id) =
d321 1
a321 1
    error (opts,"Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d591 1
a591 1
fun merge_pVEs (opts,pVE1 as (PE.VE ve1),pVE2 as (PE.VE ve2)) =
d593 1
a593 1
    (error(opts,"Duplicate value binding: " ^ IdentPrint.printValId valid1);
d600 2
a601 2
  fun valid_error opts (_,_,valid) =
    (error(opts,"Multiple declaration of valid: " ^  IdentPrint.printValId valid);
@


1.7
log
@Removed Info structure from parser, tidied upderived
@
text
@d1 5
d741 1
a741 1
(* (defpackage "ML") *)
d743 1
a743 1
(* ;; A grammar for ML for use in the LispWorks parser generator. *)
d745 1
a745 1
(* (in-package 'ml) *)
d747 7
a753 7
(* ;; General points -- *)
(* ;; each action assumes that the function call current_mark() returns *)
(* ;; the mark object for the first token of the parsed sequence.  This *)
(* ;; simplifies the data that needs to be carried around. *)
(*    *)
(* (setq *mlg* *)
(*       '(((START PROGRAM)) *)
d755 1
a755 1
 fn ([dec],opts) => dec
d758 1
a758 1
(* 	((ATEXP SCON)) *)
d760 1
a760 1
 fn ([SCON scon],opts) => EXP (Absyn.SCONexp scon,Set.empty_set)
d763 1
a763 1
(* 	((ATEXP OPLONGVAR)) *)
d765 1
a765 1
 fn ([LONGVALID id],opts) => EXP (Absyn.VALexp (mannotate(opts,id)), Set.empty_set)
d768 2
a769 2
(* ;; Don't want to just make :equal an identifier, otherwise too much *)
(* ;; checking needed in patterns etc. *)
d771 1
a771 1
(* 	((ATEXP :equal)) *)
d773 1
a773 1
 fn ([_],opts) =>
d778 1
a778 1
(* 	((ATEXP :op :equal)) *)
d780 1
a780 1
 fn ([_,_],opts) => 
d785 1
a785 1
(* 	((ATEXP :lbrace EXPROW :rbrace)) *)
d787 1
a787 1
 fn ([_,EXPROW (l,tyvars),_],opts) => EXP (Absyn.RECORDexp (rev l),tyvars)
d790 1
a790 1
(* 	((ATEXP :lbrace :rbrace)) *)
d792 1
a792 1
 fn ([_,_],opts) => EXP (Absyn.RECORDexp [],Set.empty_set)
d795 1
a795 1
(* 	((ATEXP :hash LAB)) *)
d797 1
a797 1
 fn ([_,LAB lab],opts) =>
d801 1
a801 1
(* 	((ATEXP :LPAR :RPAR)) *)
d803 1
a803 1
 fn ([_,_],opts) => EXP (Derived.make_unit_exp (),Set.empty_set)
d806 1
a806 1
(* 	((ATEXP :LPAR EXPLIST2 :RPAR)) *)
d808 1
a808 1
 fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_tuple_exp (rev l),tyvars)
d811 1
a811 1
(* 	((ATEXP :bra EXPLIST :ket)) ;; Expand into :: form *)
d813 1
a813 1
 fn ([_,EXPLIST (l,tyvars),_],opts) => EXP (Derived.make_list_exp (marks_of opts) (rev l),tyvars)
d816 1
a816 1
(* 	((ATEXP :LPAR EXPSEQ2 :RPAR)) *)
d818 1
a818 1
 fn ([_,EXPSEQ (l,tyvars),_],opts) => EXP (Derived.make_sequence_exp (rev l),tyvars)
d821 1
a821 1
(* 	((ATEXP START_LET DEC :in EXPSEQ :end)) *)
d823 1
a823 1
 fn ([ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_],opts) =>
d827 1
a827 1
(* 	((ATEXP :LPAR EXP :RPAR)) *)
d829 1
a829 1
 fn ([_,x,_],opts) => x
d832 1
a832 1
(* 	((START_LET :let)) *)
d834 1
a834 1
 fn ([_],opts) => ENV (get_current_pE())
d837 1
a837 1
(* 	((EXPLIST2 EXPLIST2 :comma EXP)) *)
d839 1
a839 1
 fn ([EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)],opts) => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d842 1
a842 1
(* 	((EXPLIST2 EXP :comma EXP)) *)
d844 1
a844 1
 fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d847 1
a847 1
(* 	((EXPLIST)) *)
d849 1
a849 1
 fn ([],opts) => EXPLIST ([],Set.empty_set)
d852 1
a852 1
(* 	((EXPLIST EXP)) *)
d854 1
a854 1
 fn ([EXP (exp,tyvars)],opts) => EXPLIST ([exp],tyvars)
d857 1
a857 1
(* 	((EXPLIST EXPLIST2)) *)
d859 1
a859 1
 fn ([exp],opts) => exp
d862 1
a862 1
(* 	((EXPSEQ EXPSEQ :semicolon EXP)) *)
d864 1
a864 1
 fn ([EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)],opts) => 
d868 1
a868 1
(* 	((EXPSEQ EXP)) *)
d870 1
a870 1
 fn ([EXP(exp,tyvars)],opts) => EXPSEQ ([(exp,make_seq_info(opts),marks_of opts)],tyvars)
d873 1
a873 1
(* 	((EXPSEQ2 EXPSEQ :semicolon EXP)) *)
d875 1
a875 1
 fn ([EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)],opts) => 
d879 1
a879 1
(* 	((EXPROW LAB :EQUAL EXP)) *)
d881 1
a881 1
 fn ([LAB lab,_,EXP (exp,tyvars)],opts) => EXPROW ([(lab,exp)],tyvars)
d884 1
a884 1
(* 	((EXPROW EXPROW :comma LAB :EQUAL EXP)) *)
d886 1
a886 1
 fn ([EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)],opts) =>
d890 1
a890 1
(* 	((APPEXP ATEXP)) *)
d892 1
a892 1
 fn ([x],opts) => x
d895 1
a895 1
(* 	((APPEXP APPEXP ATEXP)) *)
d897 1
a897 1
 fn ([EXP (exp1,tyvars1), EXP (exp2,tyvars2)],opts) =>
d901 1
a901 1
(* 	((INFEXP APPEXP)) *)
d903 1
a903 1
 fn ([x],opts) => x
d906 1
a906 1
(* 	((INFEXP INFEXP INFVAR INFEXP)) *)
d908 1
a908 1
 fn ([EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)],opts) =>
d912 1
a912 1
(* 	((INFVAR VAR)) *)
d914 1
a914 1
 fn ([x],opts) => x
d917 1
a917 1
(* 	((INFVAR :equal)) *)
d919 1
a919 1
 fn ([_],opts) => LONGVALID equal_lvalid
d922 1
a922 1
(* 	((EXP INFEXP)) *)
d924 1
a924 1
 fn ([x],opts) => x
d927 1
a927 1
(* 	((EXP EXP :colon TY)) *)
d929 1
a929 1
 fn ([EXP (exp,tyvars1),_,TY (ty,tyvars2)],opts) =>
d933 1
a933 1
(* 	((EXP EXP :andalso EXP)) *)
d935 1
a935 1
 fn ([EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d939 1
a939 1
(* 	((EXP EXP :orelse EXP)) *)
d941 1
a941 1
 fn ([EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d945 1
a945 1
(* 	((EXP EXP :handle MATCH)) *)
d947 1
a947 1
 fn ([EXP(exp1,tyvars1),_,MATCH(match,tyvars2)],opts) =>
d951 1
a951 1
(* 	((EXP :RAISE EXP)) *)
d953 1
a953 1
 fn ([_,EXP (exp,tyvars)],opts) => EXP (Absyn.RAISEexp (exp,marks_of opts),tyvars)
d957 1
a957 1
(* 	((EXP :if EXP :then EXP :else EXP)) *)
d959 1
a959 1
 fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)],opts) =>
d963 1
a963 1
(* 	((EXP :while EXP :do EXP)) *)
d965 1
a965 1
 fn ([_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)],opts) =>
d969 1
a969 1
(* 	((EXP :case EXP :of MATCH)) *)
d971 1
a971 1
 fn ([_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)],opts) =>
d975 1
a975 1
(* 	((EXP :fn MATCH)) *)
d977 1
a977 1
 fn ([_,MATCH (match,tyvars)],opts) =>
d981 1
a981 1
(* 	((MATCH MATCH :vbar MRULE)) *)
d983 1
a983 1
 fn ([MATCH (match,tyvars1),_,MRULE (rule,tyvars2)],opts) => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d986 1
a986 1
(* 	((MATCH MRULE)) *)
d988 1
a988 1
 fn ([MRULE(rule,tyvars)],opts) => MATCH([rule],tyvars)
d991 2
a992 2
(* 	((MRULE PAT :darrow EXP));; PAT determines variables present in EXP. *)
(* 	                        ;; Use to augment environment. *)
d994 1
a994 1
 fn ([PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)],opts) => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d997 2
a998 2
(* ;; New bit *)
(*         ((DECSEP)) *)
d1000 1
a1000 1
 fn ([],opts) => DUMMY
d1003 1
a1003 1
(* 	((DECSEP DECSEP :semicolon)) *)
d1005 1
a1005 1
 fn ([_,_],opts) => DUMMY
d1008 1
a1008 1
(* 	((DEC DECSEP)) *)
d1010 1
a1010 1
 fn ([_],opts) => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1013 1
a1013 1
(* 	((DEC DECSEP DEC1 DECSEP)) *)
d1015 1
a1015 1
 fn ([_,dec,_],opts) => dec
d1018 1
a1018 1
(* 	((DEC DECSEP DEC0 DECSEP)) *)
d1020 1
a1020 1
 fn ([_,DECLIST(l,pE,tyvars),_],opts) => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1023 1
a1023 1
(* 	((DEC0 DEC1 DECSEP DEC1)) *)
d1025 1
a1025 1
 fn ([DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)],opts) => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1028 1
a1028 1
(* 	((DEC0 DEC0 DECSEP DEC1)) *)
d1030 1
a1030 1
 fn ([DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)],opts) => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1033 1
a1033 1
(* ;; End of new bit for decs *)
d1035 1
a1035 1
(* ;; These two don't extend the global environment, as we only need constructors in there *)
d1037 1
a1037 1
(* 	((DEC1 :val VALBIND))		; Extend value bindings ;; reverse both lists!! *)
d1039 1
a1039 1
 fn ([_, VALBIND (valbinds1,valbinds2,tyvars,pVE)],opts) =>
d1043 1
a1043 1
(* 	((DEC1 :fun FVALBIND))		; Extend function/value bindings ? *)
d1045 1
a1045 1
 fn ([_,FVALBIND ((l,tyvars),pVE)],opts) =>
d1049 1
a1049 1
(* 	((DEC1 :type TYPBIND))		; Type binding *)
d1051 1
a1051 1
 fn ([_,TYPBIND l],opts) => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1054 1
a1054 1
(* ;; Need to extend global env with constructor definitions in next 5 rules *)
d1056 1
a1056 1
(* 	((DEC1 :datatype DATBIND))	; Extend type constructors. *)
d1058 1
a1058 1
 fn ([_,DATBIND (d,pVE)],opts) => 
d1062 1
a1062 1
(* 	((DEC1 :datatype DATBIND :withtype TYPBIND)) *)
d1064 1
a1064 1
 fn ([_,DATBIND (d,pVE),_,TYPBIND t],opts) =>
d1070 1
a1070 1
(* 	((DEC1 :abstype DATBIND :with DEC :end)) *)
d1072 2
a1073 2
 fn ([_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_],opts) =>
   (extend_pVE pVE; DEC (Absyn.ABSTYPEdec (marks_of opts,rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
d1076 1
a1076 1
(* 	((DEC1 :abstype DATBIND :withtype TYPBIND :with DEC :end)) *)
d1078 1
a1078 1
 fn ([_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_],opts) =>
a1079 1
    extend_pVE pVE;
d1083 5
a1087 1
(* 	((DEC1 :exception EXBIND)) *)
d1089 1
a1089 1
 fn ([_,EXBIND (l,pVE,tyvars)],opts) => 
d1091 1
a1091 1
 | _ => raise ActionError 58,
d1093 1
a1093 1
(* 	((DEC1 START_LOCAL DEC :in DEC :end)) *)
d1095 1
a1095 1
 fn ([ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_],opts) =>
a1097 7
 | _ => raise ActionError 59,

(* ;; Extends global environment with new definitions *)

(* 	((DEC1 :open LONGIDLIST)) *)

 fn ([_,LONGIDLIST l],opts) => do_open_dec_action (opts,rev l)
d1100 1
a1100 2
(* ;; Infix declarations extend global environment *)
(* ;; These lists are reversed, but I don't think that matters here *)
d1102 1
a1102 1
(* 	((DEC1 :infix SYMLIST));; Extend fixity environment. *)
d1104 1
a1104 1
 fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT 0)
d1107 4
a1110 1
(* 	((DEC1 :infix :integer SYMLIST)) *)
d1112 1
a1112 1
 fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.LEFT (parse_precedence(opts,i)))
d1115 1
a1115 1
(* 	((DEC1 :infixr SYMLIST)) *)
d1117 1
a1117 1
 fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT 0)
d1120 1
a1120 1
(* 	((DEC1 :infixr :integer SYMLIST)) *)
d1122 1
a1122 1
 fn ([_,INTEGER i,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence(opts,i)))
d1125 1
a1125 1
(* 	((DEC1 :nonfix SYMLIST)) *)
d1127 1
a1127 1
 fn ([_,SYMLIST l],opts) => extend_pE_for_fixity (l, PE.NONFIX)
d1130 1
a1130 1
(* ;; Used to store the current environment when entering a scope *)
d1132 2
a1133 1
(* 	((START_LOCAL :local)) *)
d1135 1
a1135 2
 fn ([_],opts) => ENV (get_current_pE())
 | _ => raise ActionError 66,
d1137 1
a1137 1
(* 	((VALBIND VALBIND1)) *)
d1139 1
a1139 1
 fn ([x],opts) => x
d1142 1
a1142 1
(* 	((VALBIND VALBIND :and VALBIND1)) *)
d1144 6
a1149 1
 fn ([VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)],opts) =>
d1151 7
a1157 1
 | _ => raise ActionError 68,
d1159 1
a1159 1
(* 	((VALBIND :rec VALBIND)) *)
d1161 1
a1161 1
 fn ([_,VALBIND (v1,v2,tyvars,pVE)],opts) =>
d1163 1
a1163 1
 | _ => raise ActionError 69,
d1165 1
a1165 1
(* 	((VALBIND1 PAT :EQUAL EXP)) *)
d1167 1
a1167 1
 fn ([PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)],opts) =>
d1169 1
a1169 1
 | _ => raise ActionError 70,
d1171 1
a1171 1
(* ;; Function definitions should return a pVE with the names of the functions declared in it. *)
d1173 1
a1173 1
(* 	((FVALBIND FVALLIST)) *)
d1175 1
a1175 1
 fn ([FVALLIST (fvals,tyvars,id)],opts) =>
d1177 1
a1177 1
 | _ => raise ActionError 71,
d1179 1
a1179 1
(* 	((FVALBIND FVALBIND :and FVALLIST)) *)
d1181 1
a1181 1
 fn ([FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)],opts) =>
d1183 1
a1183 1
 | _ => raise ActionError 72,
d1185 1
a1185 1
(* 	((FVALLIST FVAL)) *)
d1187 2
a1188 2
 fn ([FVAL ((fval,tyvars),id)],opts) => FVALLIST ([fval],tyvars,id)
 | _ => raise ActionError 73,
d1190 2
a1191 2
(* ;; checking that the function names are the same is done in Derived *)
(* 	((FVALLIST FVALLIST :vbar FVAL)) *)
d1193 1
a1193 1
 fn ([FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')],opts) =>
d1195 1
a1195 1
 | _ => raise ActionError 74,
d1197 1
a1197 1
(* 	((FVAL OPVARDEF ATPATLIST OPTTYPE :EQUAL EXP)) *)
d1199 1
a1199 1
 fn ([VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1203 1
a1203 1
 | _ => raise ActionError 75,
d1205 1
a1205 1
(* 	((FVAL ATPAT1 VARDEF ATPAT OPTTYPE :EQUAL EXP)) *)
d1207 1
a1207 1
 fn ([PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
d1211 1
a1211 1
 | _ => raise ActionError 76,
d1213 1
a1213 1
(* 	((FVAL BIN_ATPAT OPTTYPE :EQUAL EXP)) *)
d1215 1
a1215 1
 fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)],opts) =>
d1219 1
a1219 1
 | _ => raise ActionError 77,
d1221 1
a1221 1
(* 	((FVAL BIN_ATPAT ATPATLIST OPTTYPE :EQUAL EXP)) *)
d1223 1
a1223 1
 fn ([BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)],opts) =>
a1226 10
 | _ => raise ActionError 78,

(* 	((OPTTYPE)) *)

 fn ([],opts) => NULLTYPE
 | _ => raise ActionError 79,

(* 	((OPTTYPE :colon TY)) *)

 fn ([_,ty],opts) => ty
d1229 1
a1229 1
(* 	((TYPBIND TYPBIND1)) *)
d1231 1
a1231 1
 fn ([TYPBIND1 tb],opts) => TYPBIND [tb]
d1234 1
a1234 1
(* 	((TYPBIND TYPBIND :and TYPBIND1)) *)
d1236 1
a1236 2
 fn ([TYPBIND tbl,_,TYPBIND1 tb],opts) =>
    (check_disjoint_typbind(opts,tb,tbl);TYPBIND (tb::tbl))
d1239 1
a1239 1
(* 	((TYPBIND1 TYVARSEQ TYCON :EQUAL TY)) *)
d1241 1
a1241 2
 fn ([TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty))
d1244 1
a1244 1
(* 	((TYVARSEQ)) *)
d1246 2
a1247 1
 fn ([],opts) => TYVARLIST []
d1250 1
a1250 1
(* 	((TYVARSEQ :tyvar)) *)
d1252 2
a1253 1
 fn ([TYVAR t],opts) => TYVARLIST [t]
d1256 1
a1256 1
(* 	((TYVARSEQ :lpar TYVARLIST :rpar)) *)
d1258 1
a1258 1
 fn ([_,TYVARLIST l,_],opts) => TYVARLIST l
d1261 1
a1261 1
(* 	((TYVARLIST :tyvar)) *)
d1263 1
a1263 1
 fn ([TYVAR t],opts) => TYVARLIST [t]
d1266 1
a1266 1
(* 	((TYVARLIST TYVARLIST :comma :tyvar)) *)
d1268 1
a1268 1
 fn ([TYVARLIST l,_,TYVAR t],opts) => (check_disjoint_tyvars(opts,t,l);TYVARLIST (t::l))
d1271 1
a1271 1
(* 	((DATBIND DATBIND1)) *)
d1273 1
a1273 1
 fn ([DATBIND1(d,pVE)],opts) => DATBIND([d],pVE)
d1276 1
a1276 1
(* 	((DATBIND DATBIND :and DATBIND1)) *)
d1278 1
a1278 2
 fn ([DATBIND(l,pVE),_,DATBIND1(d,pVE')],opts) =>
 (check_disjoint_datbind(opts,d,l);DATBIND(d::l,merge_pVEs(opts,pVE,pVE')))
d1281 1
a1281 1
(* 	((DATBIND1 TYVARSEQ TYCON :EQUAL CONBIND)) *)
d1283 1
a1283 3
 fn ([TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);
    DATBIND1 ((rev tyvarlist,tycon,ref Datatypes.NULLTYPE,rev conbind),pVE))
d1286 1
a1286 1
(* 	((CONBIND CONBIND1)) *)
d1288 2
a1289 1
 fn ([CONBIND1(cb,id,tyvars)],opts) => CONBIND([cb],make_pVE id,tyvars)
d1292 1
a1292 1
(* 	((CONBIND CONBIND :vbar CONBIND1)) *)
d1294 3
a1296 2
 fn ([CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)],opts) =>
   CONBIND(cb::cbl,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
d1299 1
a1299 1
(* 	((CONBIND1 OPCONDEF OPTOFTYPE)) *)
d1301 1
a1301 2
 fn ([VALID id,TY (ty,tyvars)],opts) => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
 | ([VALID id,NULLTYPE], opts) => CONBIND1 ((annotate id,Absyn.ABSENT),id,Set.empty_set)
d1304 1
a1304 1
(* 	((EXBIND EXBIND1)) *)
d1306 2
a1307 1
 fn ([EXBIND1 (e,id,tyvars)],opts) => EXBIND ([e],make_pVE id,tyvars)
d1310 1
a1310 1
(* 	((EXBIND EXBIND :and EXBIND1)) *)
d1312 2
a1313 2
 fn ([EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)],opts) =>
   EXBIND (e::l,addNewValId(opts,id,pVE),Set.union(tyvars1,tyvars2))
d1316 1
a1316 1
(* 	((EXBIND1 OPEXCONDEF OPTOFTYPE)) *)
d1318 1
a1318 4
 fn ([VALID id, TY (ty,tyvars)],opts) => 
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.PRESENT ty,marks_of opts,make_exbind_info(opts,id)),id,tyvars)
| ([VALID id, NULLTYPE],opts) => 
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.ABSENT,marks_of opts,make_exbind_info(opts,id)),id,Set.empty_set)
d1321 1
a1321 1
(* 	((EXBIND1 OPEXCONDEF :EQUAL OPLONGVAR)) *)
d1323 2
a1324 2
 fn ([VALID id,_,LONGVALID id'],opts) => 
   EXBIND1 (Absyn.OLDexbind (annotate id,id',marks_of opts,make_exbind_info (opts,id)),id,Set.empty_set)
d1327 1
a1327 1
(* 	((OPTOFTYPE)) *)
d1329 4
a1332 1
 fn ([],opts) => NULLTYPE
d1335 1
a1335 1
(* 	((OPTOFTYPE :OF TY)) *)
d1337 2
a1338 1
 fn ([_,x],opts) => x
d1341 1
a1341 1
(* 	((ATPAT :underbar)) *)
d1343 1
a1343 1
 fn ([_],opts) => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1346 1
a1346 1
(* 	((ATPAT SCON)) *)
d1348 1
a1348 1
 fn ([SCON x],opts) => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1351 1
a1351 1
(* ;; This is where variables are introduced.  Make a new environment with just it in. *)
d1353 1
a1353 4
(* 	((ATPAT OPVARDEF)) *)

 fn ([VALID id],opts) => 
   PAT (Absyn.VALpat (annotate (make_long_id id),marks_of opts),make_pVE id,Set.empty_set)
d1356 1
a1356 1
(* 	((ATPAT OPLONGVAR)) *)
d1358 1
a1358 3
 fn ([LONGVALID id],opts) => 
   (check_is_constructor (opts,id);
    PAT (Absyn.VALpat (annotate id,marks_of opts),PE.empty_pVE,Set.empty_set))
d1361 1
a1361 1
(* 	((ATPAT :lbrace PATROW :rbrace)) *)
d1363 4
a1366 2
 fn ([_,PATROW (columns,wild,pVE,tyvars),_],opts) => 
   PAT (Absyn.RECORDpat (rev columns,wild,ref Datatypes.NULLTYPE),pVE,tyvars)
d1369 1
a1369 1
(* 	((ATPAT :lbrace PATROW :comma :ellipsis :rbrace)) *)
d1371 3
a1373 2
 fn ([_,PATROW (columns,wild,pVE,tyvars),_,_,_],opts) => 
   PAT (Absyn.RECORDpat (rev columns,true,ref Datatypes.NULLTYPE),pVE,tyvars)
d1376 1
a1376 1
(* 	((ATPAT :lbrace :ellipsis :rbrace)) *)
d1378 2
a1379 2
 fn ([_,_,_],opts) => 
   PAT (Absyn.RECORDpat ([],true,ref Datatypes.NULLTYPE),PE.empty_pVE,Set.empty_set)
d1382 1
a1382 1
(* 	((ATPAT :lbrace :rbrace)) *)
d1384 2
a1385 1
 fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1388 1
a1388 1
(* 	((ATPAT :lpar :rpar)) *)
d1390 2
a1391 1
 fn ([_,_],opts) => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1394 1
a1394 1
(* 	((ATPAT :lpar PATLIST2 :rpar)) *)
d1396 1
a1396 1
 fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1399 1
a1399 1
(* 	((ATPAT :bra :ket)) *)
d1401 1
a1401 1
 fn ([_,_],opts) => PAT (Derived.make_list_pat([],marks_of opts),PE.empty_pVE,Set.empty_set)
d1404 1
a1404 1
(* 	((ATPAT :bra PAT :ket)) *)
d1406 1
a1406 1
 fn ([_,PAT(l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat([l],marks_of opts),pVE,tyvars)
d1409 1
a1409 1
(* 	((ATPAT :lpar PAT :rpar)) *)
d1411 1
a1411 1
 fn ([_,x,_],opts) => x
d1414 1
a1414 1
(* 	((ATPAT :bra PATLIST2 :ket)) *)
d1416 1
a1416 1
 fn ([_,PATLIST (l,pVE,tyvars),_],opts) => PAT (Derived.make_list_pat(rev l,marks_of opts),pVE,tyvars)
d1419 1
a1419 1
(* 	((BIN_ATPAT :lpar ATPAT PATVAR ATPAT :rpar)) *)
d1421 1
a1421 2
 fn ([_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_],opts) =>
   BINPAT(pat1,id,pat2,merge_pVEs(opts,pVE1,pVE2),Set.union(tyvars1,tyvars2))
d1424 1
a1424 1
(* 	((ATPAT1 BIN_ATPAT)) *)
d1426 1
a1426 3
 fn ([BINPAT (pat1,id,pat2,pVE,tyvars)],opts) =>
   (check_is_short_constructor (opts,id);
    PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],marks_of opts),pVE,tyvars))
d1429 1
a1429 1
(* 	((ATPAT1 ATPAT)) *)
d1431 2
a1432 1
 fn ([x],opts) => x
d1435 1
a1435 1
(* 	((PATLIST2 PAT :COMMA PAT)) *)
d1437 3
a1439 2
 fn ([PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
   PATLIST ([pat2,pat1], merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
d1442 1
a1442 1
(* 	((PATLIST2 PATLIST2 :COMMA PAT)) *)
d1444 1
a1444 2
 fn ([PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)],opts) =>
   PATLIST (pat2::pat1, merge_pVEs(opts,pVE1,pVE2), Set.union (tyvars1,tyvars2))
d1447 1
a1447 1
(* 	((PATROW PATROW1)) *)
d1449 2
a1450 1
 fn ([PATROW1 (lp,pVE,tyvars)],opts) => PATROW ([lp],false,pVE,tyvars)
d1453 12
a1464 1
(* 	((PATROW PATROW :comma PATROW1)) *)
d1466 1
a1466 1
 fn ([PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)],opts) =>
d1469 1
a1469 1
 | _ => raise ActionError 121,
d1471 1
a1471 1
(* 	((PATROW1 LAB :EQUAL PAT)) *)
d1473 2
a1474 2
 fn ([LAB lab,_,PAT (pat,pVE,tyvars)],opts) => PATROW1 ((lab,pat),pVE,tyvars)
 | _ => raise ActionError 122,
d1476 1
a1476 1
(* 	((PATROW1 SYM OPTTYPE)) *)
d1478 1
a1478 1
 fn ([SYM sym, TY (ty,tyvars)],opts) =>
d1484 1
a1484 1
 | _ => raise ActionError 123,
d1486 1
a1486 1
(* 	((PATROW1 SYM OPTTYPE :as PAT)) *)
d1488 1
a1488 1
 fn ([SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)],opts) =>
d1494 1
a1494 1
 | _ => raise ActionError 124,
d1496 1
a1496 1
(* 	((PAT ATPAT)) *)
d1498 2
a1499 2
 fn ([x],opts) => x
 | _ => raise ActionError 125,
d1501 1
a1501 1
(* 	((PAT OPLONGVAR ATPAT)) *)
d1503 1
a1503 1
 fn ([LONGVALID id, PAT (pat,pVE,tyvars)],opts) => 
d1505 1
a1505 1
 | _ => raise ActionError 126,
d1507 1
a1507 1
(* 	((PAT PAT VAR PAT)) *)
d1509 1
a1509 1
 fn ([PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)],opts) =>
d1512 1
a1512 1
 | _ => raise ActionError 127,
d1514 1
a1514 1
(* 	((PAT PAT :colon TY)) *)
d1516 2
a1517 2
 fn ([PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)],opts) => PAT (Absyn.TYPEDpat(pat,ty,marks_of opts),pVE,Set.union(tyvars1,tyvars2))
 | _ => raise ActionError 128,
d1519 1
a1519 1
(* 	((PAT OPVARDEF OPTTYPE :as PAT)) *)
d1521 1
a1521 1
 fn ([VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)],opts) =>
d1525 1
a1525 3
 | _ => raise ActionError 129,

(* ;; Types need to have tyvar set added -- a field in Ty maybe? *)
d1527 1
a1527 1
(* 	((TY :tyvar)) *)
d1529 1
a1529 7
 fn ([TYVAR t],opts) => TY (Absyn.TYVARty (t),Set.singleton t)
 | _ => raise ActionError 130,

(* 	((TY :lbrace TYROW :rbrace)) *)

 fn ([_,TYROW (l,tvs),_],opts) => TY (Absyn.RECORDty l,tvs)
 | _ => raise ActionError 131,
d1531 1
a1531 3
(* 	((TY :lbrace :rbrace)) *)

 fn ([_,_],opts) => TY (Absyn.RECORDty [],Set.empty_set)
d1534 1
a1534 1
(* 	((TY TYSEQ LONGTYCON)) *)
d1536 1
a1536 1
 fn ([TYLIST (s,tvs), LONGTYCON c],opts) => TY (Absyn.APPty (rev s,c,marks_of opts),tvs)
d1539 1
a1539 1
(* 	((TY TY LONGTYCON)) *)
d1541 1
a1541 1
 fn ([TY (t,tvs), LONGTYCON c],opts) => TY (Absyn.APPty ([t],c,marks_of opts),tvs)
d1544 1
a1544 1
(* 	((TY LONGTYCON)) *)
d1546 1
a1546 1
 fn ([LONGTYCON c],opts) => TY (Absyn.APPty ([],c,marks_of opts),Set.empty_set)
d1549 1
a1549 1
(* 	((TY TYTUPLE)) *)
d1551 1
a1551 1
 fn ([TYLIST (tl,tvs)],opts) => TY (Derived.make_tuple_ty (rev tl),tvs)
d1554 1
a1554 1
(* 	((TY TY :arrow TY)) *)
d1556 1
a1556 1
 fn ([TY (t1,tvs1),_,TY (t2,tvs2)],opts) => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1559 1
a1559 1
(* 	((TY :LPAR TY :RPAR)) *)
d1561 1
a1561 1
 fn ([_,t,_],opts) => t
d1564 1
a1564 1
(* 	((TYSEQ :lpar TYLIST :comma TY :rpar)) *)
d1566 1
a1566 1
 fn ([_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_],opts) => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1569 1
a1569 1
(* 	((TYLIST TY)) *)
d1571 1
a1571 1
 fn ([TY (ty,tyvars)],opts) => TYLIST ([ty],tyvars)
d1574 1
a1574 1
(* 	((TYLIST TYLIST :comma TY)) *)
d1576 1
a1576 1
 fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1579 1
a1579 1
(* 	((TYTUPLE TYTUPLE STAR TY)) *)
d1581 1
a1581 1
 fn ([TYLIST (tl,tyvars1),_,TY (ty,tyvars2)],opts) => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1584 1
a1584 1
(* 	((TYTUPLE TY STAR TY)) *)
d1586 1
a1586 1
 fn ([TY (t1,tyvars1),_,TY (t2,tyvars2)],opts) => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1589 1
a1589 1
(* 	((TYROW LAB :colon TY)) *)
d1591 1
a1591 1
 fn ([LAB l,_,TY (ty,tyvars)],opts) => TYROW ([(l,ty)],tyvars)
d1594 1
a1594 1
(* 	((TYROW TYROW :comma LAB :colon TY)) *)
d1596 1
a1596 2
 fn ([TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)],opts) =>
 (check_disjoint_labels(opts,lab,l);TYROW ((lab,ty)::l,Set.union(tyvars1,tyvars2)))
d1599 1
a1599 3
(* 	;; LISTS *)

(* 	((ATPATLIST ATPAT)) *)
d1601 1
a1601 1
 fn ([PAT (pat,pE,tyvars)],opts) => PATLIST ([pat],pE,tyvars)
d1604 1
a1604 1
(* 	((ATPATLIST ATPATLIST ATPAT)) *)
d1606 2
a1607 2
 fn ([PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)],opts) => 
   PATLIST (pat::l,merge_pVEs(opts,pVE1,pVE2),Set.union (tyvars1,tyvars2))
d1610 1
a1610 1
(* ;; Longid lists used for structure reference lists -- these are kept as longids *)
d1612 1
a1612 1
(* 	((LONGIDLIST LONGIDLIST :longid)) *)
d1614 1
a1614 1
 fn ([LONGIDLIST l,LONGID id],opts) => LONGIDLIST(id :: l)
d1617 1
a1617 1
(* 	((LONGIDLIST :longid)) *)
d1619 2
a1620 1
 fn ([LONGID id],opts) => LONGIDLIST[id]
d1623 1
a1623 1
(* ;; Long symbol lists *)
d1625 1
a1625 1
(* 	((LONGSTRIDLIST LONGSTRIDLIST LONGSTRID)) *)
d1627 1
a1627 1
 fn ([LONGSTRIDLIST l, LONGSTRID i],opts) => LONGSTRIDLIST(i::l)
d1630 1
a1630 1
(* 	((LONGSTRIDLIST LONGSTRID)) *)
d1632 1
a1632 1
 fn ([LONGSTRID i],opts) => LONGSTRIDLIST[i]
d1635 1
a1635 1
(* ;; Symbol lists *)
d1637 1
a1637 1
(* 	((SYMLIST SYM)) *)
d1639 1
a1639 1
 fn ([SYM sym],opts) => SYMLIST [sym]
d1642 1
a1642 1
(* 	((SYMLIST SYMLIST SYM)) *)
d1644 1
a1644 1
 fn ([SYMLIST l,SYM sym],opts) => SYMLIST (sym::l)
d1647 1
a1647 1
(* 	;; Constants *)
d1649 1
a1649 1
(*         ((SCON :integer)) *)
d1651 1
a1651 1
 fn ([INTEGER s],opts) => SCON (Ident.INT s)
d1654 1
a1654 1
(* 	((SCON :real)) *)
d1656 1
a1656 1
 fn ([REAL s],opts) => SCON (Ident.REAL s)
d1659 3
a1661 1
(* 	((SCON :string)) *)
d1663 1
a1663 1
 fn ([STRING s],opts) => SCON (Ident.STRING s)
d1666 1
a1666 1
(* 	;; Labels *)
d1668 1
a1668 5
(* 	((LAB :longid)) *)

 fn ([LONGID ([],s)],opts) => LAB (Ident.LAB s)
| ([LONGID (id as (p,s))],opts) =>
   (report_long_error (opts,id,"LABEL"); LAB (Ident.LAB s))
d1671 1
a1671 1
(* 	((LAB :integer)) ;; need to check its within allowable bounds *)
d1673 1
a1673 1
 fn ([INTEGER int],opts) => (check_integer_bounds (opts,int); LAB (Ident.LAB (Symbol.find_symbol int)))
d1676 1
a1676 1
(* 	;; Long variables *)
d1678 1
a1678 1
(* 	((LONGVAR :longid)) *)
d1680 3
a1682 1
 fn ([LONGID id],opts) => LONGVALID (resolveLongValId id)
d1685 1
a1685 1
(* 	((OPLONGVAR LONGVAR)) *)
d1687 1
a1687 1
 fn ([l as LONGVALID id],opts) => (check_non_longid_op (opts,id); l)
d1690 3
a1692 1
(* 	((OPLONGVAR :op LONGVAR)) *)
d1694 1
a1694 1
 fn ([_, l as LONGVALID id],opts) => (check_longid_op (opts,id); l)
d1697 1
a1697 1
(* 	((LONGTYCON :longid)) *)
d1699 1
a1699 1
 fn ([LONGID (l,s)],opts) => LONGTYCON (mkLongTyCon (opts,l,s))
d1702 1
a1702 1
(* 	((LONGSTRID :longid)) *)
d1704 1
a1704 1
 fn ([LONGID (l,s)],opts) => LONGSTRID (mkLongStrId (l,s))
d1707 1
a1707 1
(* ;; This one is parsed as a symbol. *)
d1709 1
a1709 5
(* 	((SYM :longid)) *)

 fn ([LONGID ([],s)],opts) => SYM s
| ([LONGID (id as (l,s))],opts) =>
   (report_long_error (opts,id,"ID"); SYM s)
d1712 1
a1712 1
(* 	((SYM :equal)) *)
d1714 1
a1714 1
 fn ([_],opts) => SYM equal_symbol
d1717 3
a1719 1
(* 	((FUNID SYM)) *)
d1721 3
a1723 1
 fn ([SYM s],opts) => FUNID(Ident.FUNID s)
d1726 1
a1726 1
(* 	((SIGID SYM)) *)
d1728 1
a1728 1
 fn ([SYM s],opts) => SIGID(Ident.SIGID s)
d1731 1
a1731 1
(* 	((STRID SYM)) *)
d1733 1
a1733 1
 fn ([SYM s],opts) => STRID(Ident.STRID s)
d1736 1
a1736 1
(* ;; These ones become long valids. *)
d1738 1
a1738 6
(* ;; This one appears only in infix expressions and patterns, and can be a *)
(* ;; constructor or a variable. *)
(* 	((VAR :longid)) *)

 fn ([LONGID (id as ([],_))],opts) => LONGVALID (resolveLongValId id)
| ([LONGID id],opts) => (report_long_error (opts,id,"VAR"); LONGVALID (resolveLongValId id))
d1741 1
a1741 1
(* ;; This is used for defining occurences of variables in patterns. *)
d1743 2
a1744 1
(* 	((VARDEF :longid)) *)
d1746 1
a1746 3
 fn ([LONGID ([],id)],opts) => let val valid = resolveValId id in check_not_constructor(opts,valid); VALID valid end
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"VAR"); VALID (Ident.VAR id))
 | _ => raise ActionError 170,
d1748 3
a1750 1
(* 	((OPVARDEF VARDEF)) *)
d1752 2
a1753 1
 fn ([valid as VALID id],opts) => (check_non_valid_op (opts,id); valid)
d1756 1
a1756 1
(* 	((OPVARDEF :op VARDEF)) *)
d1758 4
a1761 1
 fn ([_,valid as VALID id],opts) => (check_valid_op(opts,id); valid)
d1764 1
a1764 2
(* ;; this is used in bin-atpats where the infixed var might be a constructor or a var *)
(* 	((PATVAR :longid)) *)
d1766 1
a1766 2
 fn ([LONGID (id as ([],_))],opts) => VALID (getValId id)
| ([LONGID (longid as (_,id))],opts) => (report_long_error (opts,longid,"VAR"); VALID (Ident.VAR id))
d1769 1
a1769 1
(* 	((CONDEF :longid)) *)
d1771 1
a1771 2
 fn ([LONGID ([],s)],opts) => VALID (Ident.CON s)
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"CON"); VALID (Ident.CON s))
d1774 2
a1775 1
(* 	((OPCONDEF CONDEF)) *)
d1777 2
a1778 1
 fn ([valid as (VALID con)],opts) => (check_non_valid_op(opts,con); valid)
d1781 1
a1781 1
(* 	((OPCONDEF :op CONDEF)) *)
d1783 2
a1784 1
 fn ([_,valid as (VALID con)],opts) => (check_valid_op(opts,con); valid)
d1787 1
a1787 1
(* 	((EXCONDEF :longid)) *)
d1789 1
a1789 2
 fn ([LONGID ([],s)],opts) => VALID (Ident.EXCON s)
| ([LONGID (id as (p,s))],opts) => (report_long_error (opts,id,"EXCON"); VALID (Ident.EXCON s))
d1792 1
a1792 1
(* 	((OPEXCONDEF EXCONDEF)) *)
d1794 1
a1794 1
 fn ([valid as (VALID excon)],opts) => (check_non_valid_op(opts,excon); valid)
d1797 1
a1797 1
(* 	((OPEXCONDEF :op EXCONDEF)) *)
d1799 2
a1800 1
 fn ([_,valid as (VALID excon)],opts) => (check_valid_op(opts,excon); valid)
d1803 1
a1803 1
(* 	((TYCON :longid)) *)
d1805 1
a1805 2
 fn ([LONGID ([],s)],opts) => TYCON (mkTyCon (opts,s))
| ([LONGID (id as (l,s))],opts) => (report_long_error (opts,id,"TYCON"); TYCON (mkTyCon(opts,s)))
d1808 1
a1808 1
(* 	((STAR :longid)) *)
d1810 1
a1810 1
 fn ([LONGID ([],s)],opts) => DUMMY (* should check its an asterisk *)
d1813 1
a1813 1
(* 	;; Modules *)
d1815 2
a1816 3
(* 	((STREXP STRUCT_START STRDEC :end)) *)

 fn ([ENV pE,STRDEC (x,e),_],opts) => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d1819 1
a1819 1
(* 	((STREXP :longid)) *)
d1821 1
a1821 1
 fn ([LONGID x],opts) => STREXP (Absyn.OLDstrexp (mkLongStrId x,marks_of opts),lookupStrId x)
d1824 1
a1824 1
(* 	((STREXP FUNID :lpar STREXP :rpar)) *)
d1826 3
a1828 2
 fn ([FUNID funid,_,STREXP(strexp,_),_],opts) => 
   STREXP (Absyn.APPstrexp (funid,strexp,marks_of opts),lookupFunId funid)
d1831 1
a1831 1
(* 	((STREXP FUNID :lpar STRDEC :rpar)) *)
d1833 1
a1833 2
 fn ([FUNID funid,_,STRDEC(strdec,e),_],opts) => 
   STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,marks_of opts),lookupFunId funid)
d1836 1
a1836 1
(* 	((STREXP START_LET STRDEC :in STREXP :end)) *)
d1838 2
a1839 2
 fn ([ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_],opts) => 
   (set_pE pE; STREXP (Absyn.LOCALstrexp(strdec,strexp),e'))
d1842 1
a1842 1
(* 	((STRUCT_START :struct)) *)
d1844 2
a1845 1
 fn ([_],opts) => ENV (get_current_pE())
d1848 1
a1848 1
(* 	((STRDEC DECSEP)) *)
d1850 2
a1851 1
 fn ([_],opts) => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d1854 1
a1854 1
(* 	((STRDEC DECSEP STRDEC1 DECSEP)) *)
d1856 1
a1856 1
 fn ([_,strdec,_],opts) => strdec
d1859 1
a1859 1
(* 	((STRDEC DECSEP STRDEC0 DECSEP)) *)
d1861 1
a1861 1
 fn ([_,STRDECLIST(l,pE),_],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1864 1
a1864 1
(* 	((STRDEC0 STRDEC1 DECSEP STRDEC1)) *)
d1866 1
a1866 1
 fn ([STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)],opts) => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d1869 1
a1869 1
(* 	((STRDEC0 STRDEC0 DECSEP STRDEC1)) *)
d1871 1
a1871 1
 fn ([STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)],opts) => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d1874 1
a1874 3
(* ;; This is used for strdecs as topdecs - don't allow them to be separated by semicolons. *)

(* 	((STRDEC1PLUS STRDEC1)) *)
d1876 1
a1876 1
 fn ([STRDEC (x,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d1879 1
a1879 1
(* 	((STRDEC1PLUS STRDEC1PLUS0)) *)
d1881 1
a1881 1
 fn ([STRDECLIST(l,pE)],opts) => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1884 1
a1884 1
(* 	((STRDEC1PLUS0 STRDEC1 STRDEC1)) *)
d1886 3
a1888 2
 fn ([STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)],opts) => 
   STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d1891 1
a1891 1
(* 	((STRDEC1PLUS0 STRDEC1PLUS0 STRDEC1)) *)
d1893 1
a1893 2
 fn ([STRDECLIST(l,pE1),STRDEC(strdec,pE2)],opts) => 
   STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d1896 1
a1896 1
(* ;; Single strdecs *)
d1898 2
a1899 3
(* 	((STRDEC1 DEC1)) *)

 fn ([DEC(dec,pE,tyvars)],opts) => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d1902 1
a1902 1
(* 	((STRDEC1 :structure STRBIND)) *)
d1904 2
a1905 2
 fn ([_,STRBIND(l,pSE)],opts) => 
   (extend_pSE pSE;STRDEC(Absyn.STRUCTUREstrdec l,pSE_in_pE pSE))
d1908 3
a1910 1
(* 	((STRDEC1 START_LOCAL STRDEC :in STRDEC :end)) *)
d1912 1
a1912 2
 fn ([ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_],opts) => 
   (set_pE (PE.augment_pE(pE,pE'));STRDEC(Absyn.LOCALstrdec(strdec1,strdec2),pE'))
d1915 1
a1915 1
(* 	((STRBIND STRBIND1)) *)
d1917 2
a1918 1
 fn ([STRBIND1 (d,id_pE)],opts) => STRBIND([d],make_pSE id_pE)
d1921 1
a1921 1
(* 	((STRBIND STRBIND :and STRBIND1)) *)
d1923 2
a1924 2
 fn ([STRBIND(l,pSE),_,STRBIND1(d,id_pE)],opts) =>
    STRBIND(d::l,addNewStrId(opts,id_pE,pSE))
d1927 1
a1927 1
(* 	((STRBIND1 STRID :colon SIGEXP :equal STREXP)) *)
d1929 1
a1929 2
 fn ([STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)],opts) => 
   STRBIND1((id,Absyn.PRESENT sigexp,strexp,marks_of opts),(id,pE1))
d1932 1
a1932 1
(* 	((STRBIND1 STRID :equal STREXP)) *)
d1934 2
a1935 2
 fn ([STRID id,_,STREXP(strexp,pE)],opts) => 
   STRBIND1((id,Absyn.ABSENT,strexp,marks_of opts),(id,pE))
d1938 1
a1938 1
(* 	((SIGEXP SIG_START SPEC :end)) *)
d1940 2
a1941 2
 fn ([ENV pE,SPEC (spec,e),_],opts) => 
   (set_pE pE; SIGEXP(Absyn.NEWsigexp(spec,ref Interface.emptyInt),e))
d1944 1
a1944 1
(* 	((SIGEXP SIGID)) *)
d1946 2
a1947 1
 fn ([SIGID id],opts) => SIGEXP(Absyn.OLDsigexp(id,ref Interface.emptyInt,marks_of opts),lookupSigId id)
d1950 1
a1950 1
(* 	((SIG_START :sig)) *)
d1952 2
a1953 1
 fn ([_],opts) => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
d1956 1
a1956 1
(* 	((SIGDEC1PLUS SIGDEC1)) *)
d1958 1
a1958 1
 fn ([SIGBIND(sigb,pG)],opts) => SIGDEC([Absyn.SIGBIND sigb],pG)
d1961 1
a1961 1
(* 	((SIGDEC1PLUS SIGDEC1PLUS SIGDEC1)) *)
d1963 1
a1963 1
 fn ([SIGDEC(l,pG),SIGBIND(sigb,pG')],opts) => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d1966 1
a1966 1
(* 	((SIGDEC1 :signature SIGBIND)) *)
d1968 1
a1968 1
 fn ([_,x as SIGBIND(_,pG)],opts) => (extend_pG pG;x)
d1971 1
a1971 1
(* 	((SIGBIND SIGID :EQUAL SIGEXP)) *)
d1973 1
a1973 1
 fn ([SIGID id,_,SIGEXP(sigexp,e)],opts) => SIGBIND([(id,sigexp,marks_of opts)],make_pG(id,e))
d1976 1
a1976 1
(* 	((SIGBIND  SIGBIND :and SIGID :EQUAL SIGEXP)) *)
d1978 1
a1978 2
 fn ([SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)],opts) => 
   SIGBIND((id,sigexp,marks_of opts)::l,addNewSigId(opts,(id,e),pG))
d1981 1
a1981 1
(* 	((SPEC DECSEP)) *)
d1983 1
a1983 1
 fn ([_],opts) => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d1986 1
a1986 1
(* 	((SPEC DECSEP SPEC1 DECSEP)) *)
d1988 2
a1989 1
 fn ([_,spec,_],opts) => spec
d1992 1
a1992 1
(* 	((SPEC DECSEP SPEC0 DECSEP)) *)
d1994 1
a1994 1
 fn([_,SPECLIST(l,pE),_],opts) => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d1997 1
a1997 1
(* 	((SPEC0 SPEC1 DECSEP SPEC1)) *)
d1999 1
a1999 2
 fn([SPEC(spec1,pE1),_,SPEC(spec2,pE2)],opts) => 
   SPECLIST([spec2,spec1],PE.augment_pE(pE1,pE2))
d2002 1
a2002 1
(* 	((SPEC0 SPEC0 DECSEP SPEC1)) *)
d2004 1
a2004 2
 fn([SPECLIST(l,pE1),_,SPEC(spec,pE2)],opts) => 
   SPECLIST(spec::l,PE.augment_pE(pE1,pE2))
d2007 1
a2007 1
(* ;; Don't need to extend global environment here -- no constructors here *)
d2009 2
a2010 3
(* 	((SPEC1 :val VALDESC)) *)

 fn ([_,VALDESC (l,pVE)],opts) => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2013 1
a2013 1
(* 	((SPEC1 :type TYPDESC)) *)
d2015 2
a2016 1
 fn ([_,TYPDESC t],opts) => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2019 3
a2021 1
(* 	((SPEC1 :eqtype TYPDESC)) *)
d2023 1
a2023 1
 fn ([_,TYPDESC t],opts) => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2026 1
a2026 1
(* 	((SPEC1 :datatype DATDESC)) *)
d2028 1
a2028 1
 fn ([_,DATDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2031 1
a2031 1
(* 	((SPEC1 :exception EXDESC)) *)
d2033 1
a2033 1
 fn ([_,EXDESC(l,pVE)],opts) => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2036 1
a2036 1
(* 	((SPEC1 :structure STRDESC)) *)
d2038 1
a2038 1
 fn ([_,STRDESC(l,pSE)],opts) => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2041 1
a2041 1
(* 	((SPEC1 :sharing SHAREQ)) *)
d2043 1
a2043 1
 fn ([_,SHAREQ l],opts) => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2046 1
a2046 1
(* 	((SPEC1 START_LOCAL SPEC :in SPEC :end)) *)
d2048 1
a2048 2
 fn ([ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_],opts) => 
   (set_pE (PE.augment_pE(pE,pE2));SPEC(Absyn.LOCALspec(spec1,spec2),pE2))
d2051 1
a2051 1
(* 	((SPEC1 :open LONGIDLIST)) *)
d2053 1
a2053 1
 fn ([_,LONGIDLIST l],opts) => do_open_spec_action (opts,rev l)
d2056 1
a2056 1
(* 	((SPEC1 :include SIGIDLIST)) *)
d2058 2
a2059 1
 fn ([_,SIGIDLIST l],opts) => do_include_action (opts,rev l)
d2062 1
a2062 1
(* 	((SIGIDLIST SIGID)) *)
d2064 1
a2064 1
 fn ([SIGID sigid],opts) => SIGIDLIST [sigid]
d2067 1
a2067 1
(* 	((SIGIDLIST SIGIDLIST SIGID)) *)
d2069 1
a2069 1
 fn ([SIGIDLIST l,SIGID sigid],opts) => SIGIDLIST(sigid::l)
d2072 1
a2072 1
(* 	((VALDESC VARDEF :colon TY)) *)
d2074 1
a2074 1
 fn ([VALID v,_,TY (ty,tyvars)],opts) => VALDESC([(v,ty,tyvars)], make_pVE v)
d2077 1
a2077 1
(* 	((VALDESC VALDESC :and VARDEF :colon TY)) *)
d2079 1
a2079 2
 fn ([VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)],opts) => 
   VALDESC((v,ty,tyvars)::l,addNewValId(opts,v,pVE))
d2082 1
a2082 1
(* 	((TYPDESC TYPDESC1)) *)
d2084 1
a2084 1
 fn ([TYPDESC1 x],opts) => TYPDESC[x]
d2087 1
a2087 1
(* 	((TYPDESC TYPDESC :and TYPDESC1)) *)
d2089 2
a2090 2
 fn ([TYPDESC l,_,TYPDESC1 t],opts) => 
   (check_disjoint_typdesc(opts,t,l); TYPDESC (t::l))
d2093 1
a2093 1
(* 	((TYPDESC1 TYVARSEQ TYCON)) *)
d2095 1
a2095 1
 fn ([TYVARLIST tyvarlist,TYCON tycon],opts) => TYPDESC1(rev tyvarlist,tycon)
d2098 1
a2098 2
(* ; Needs a value environment	 *)
(* 	((DATDESC DATDESC1)) *)
d2100 2
a2101 1
 fn ([DATDESC1(d,pVE)],opts) => DATDESC([d],pVE)
d2104 1
a2104 1
(* 	((DATDESC DATDESC :and DATDESC1)) *)
d2106 1
a2106 2
 fn ([DATDESC(l,pVE),_,DATDESC1(d,pVE')],opts) =>
   (check_disjoint_datdesc(opts,d,l); DATDESC(d::l,merge_pVEs(opts,pVE,pVE')))
d2109 2
a2110 1
(* 	((DATDESC1 TYVARSEQ TYCON :EQUAL CONDESC)) *)
d2112 1
a2112 3
 fn ([TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)],opts) =>
   (check_tyvar_inclusion(opts,tyvars,tyvarlist);
    DATDESC1((rev tyvarlist,tycon,(rev l)),pVE))
d2115 1
a2115 1
(* 	((CONDESC CONDESC1)) *)
d2117 2
a2118 1
 fn ([x],opts) => x
d2121 1
a2121 1
(* 	((CONDESC CONDESC :vbar CONDESC1)) *)
d2123 3
a2125 2
 fn ([CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')],opts) => 
   CONDESC(x::l,merge_pVEs(opts,e,e'),Set.union(tyvars,tyvars'))
d2128 1
a2128 1
(* 	((CONDESC1 CONDEF OPTOFTYPE)) *)
d2130 1
a2130 4
 fn ([VALID con,TY(ty,tyvars)],opts) => 
   CONDESC([(con,Absyn.PRESENT ty)],make_pVE con,tyvars)
| ([VALID con,NULLTYPE],opts) => 
   CONDESC([(con,Absyn.ABSENT)],make_pVE con,Set.empty_set)
d2133 1
a2133 1
(* 	((EXDESC EXDESC1)) *)
d2135 2
a2136 1
 fn ([EXDESC1(excon,ty,marks)],opts) => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2139 1
a2139 1
(* 	((EXDESC EXDESC :and EXDESC1)) *)
d2141 4
a2144 2
 fn ([EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)],opts) => 
   EXDESC((excon,ty,marks)::l,addNewValId(opts,excon,pVE))
d2147 1
a2147 1
(* 	((EXDESC1 EXCONDEF OPTOFTYPE)) *)
d2149 1
a2149 4
 fn ([VALID excon,TY(ty,_)],opts) => 
   EXDESC1(excon,Absyn.PRESENT ty,marks_of opts)
| ([VALID excon,NULLTYPE],opts) => 
   EXDESC1(excon,Absyn.ABSENT,marks_of opts)
d2152 1
a2152 1
(* 	((STRDESC STRDESC1)) *)
d2154 2
a2155 1
 fn ([STRDESC1(strid,e,pE)],opts) => STRDESC([(strid,e)],make_pSE(strid,pE))
d2158 1
a2158 1
(* 	((STRDESC STRDESC :and STRDESC1)) *)
d2160 4
a2163 2
 fn ([STRDESC(l,pSE),_,STRDESC1(strid,e,pE)],opts) => 
   STRDESC((strid,e)::l,addNewStrId(opts,(strid,pE),pSE))
d2166 1
a2166 1
(* 	((STRDESC1 STRID :colon SIGEXP)) *)
d2168 1
a2168 1
 fn ([STRID strid,_,SIGEXP(e,pE)],opts) => STRDESC1(strid,e,pE)
d2171 1
a2171 1
(*         ((SHAREQ SHAREQ1)) *)
d2173 2
a2174 1
 fn ([x],opts) => x
d2177 1
a2177 1
(* 	((SHAREQ SHAREQ :and SHAREQ1)) *)
d2179 1
a2179 1
 fn ([SHAREQ l,_,SHAREQ [x]],opts) => SHAREQ(x::l)
d2182 1
a2182 1
(* 	((SHAREQ1 LONGSTRIDEQLIST)) *)
d2184 1
a2184 1
 fn ([LONGSTRIDLIST l],opts) => SHAREQ[(Absyn.STRUCTUREshareq (rev l),marks_of opts)]
d2187 1
a2187 1
(* 	((SHAREQ1 :type LONGTYCONEQLIST)) *)
d2189 1
a2189 1
 fn ([_, LONGTYCONLIST l],opts) => SHAREQ[(Absyn.TYPEshareq (rev l),marks_of opts)]
d2192 1
a2192 1
(* 	((LONGSTRIDEQLIST LONGSTRID :EQUAL LONGSTRID)) *)
d2194 1
a2194 1
 fn ([LONGSTRID id,_,LONGSTRID id'],opts) => LONGSTRIDLIST[id',id]
d2197 1
a2197 1
(* 	((LONGSTRIDEQLIST LONGSTRIDEQLIST :EQUAL LONGSTRID)) *)
d2199 1
a2199 1
 fn ([LONGSTRIDLIST l,_,LONGSTRID id],opts) => LONGSTRIDLIST(id::l)
d2202 1
a2202 1
(* 	((LONGTYCONEQLIST LONGTYCON :EQUAL LONGTYCON)) *)
d2204 1
a2204 1
 fn ([LONGTYCON tycon,_,LONGTYCON tycon'],opts) => LONGTYCONLIST[tycon',tycon]
d2207 1
a2207 1
(* 	((LONGTYCONEQLIST LONGTYCONEQLIST :EQUAL LONGTYCON)) *)
d2209 1
a2209 1
 fn ([LONGTYCONLIST l,_,LONGTYCON tycon],opts) => LONGTYCONLIST(tycon::l)
d2212 1
a2212 1
(* 	((FUNDEC1PLUS FUNDEC1)) *)
d2214 1
a2214 1
 fn ([FUNBIND(fbind,pF)],opts) => FUNDEC([Absyn.FUNBIND fbind],pF)
d2217 1
a2217 1
(* 	((FUNDEC1PLUS FUNDEC1PLUS FUNDEC1)) *)
d2219 1
a2219 1
 fn ([FUNDEC(l,pF),FUNBIND(fbind,pF')],opts) => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2222 1
a2222 1
(* 	((FUNDEC1 :functor FUNBIND)) *)
d2224 1
a2224 1
 fn ([_,fbind as FUNBIND(f,pF)],opts) => (extend_pF pF; fbind)
d2227 1
a2227 1
(* 	((FUNBIND FUNBIND1)) *)
d2229 1
a2229 2
 fn ([FUNBIND1(fbind,funid,pE)],opts) =>
 FUNBIND([fbind],make_pF(funid,pE))
d2232 1
a2232 1
(* 	((FUNBIND FUNBIND :and FUNBIND1)) *)
d2234 1
a2234 2
 fn ([FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)],opts) =>
 FUNBIND (fbind::l,addNewFunId(opts,(funid,pE),pF))
d2237 1
a2237 1
(* 	((FUNBIND1 STARTFUNBIND1 :colon SIGEXP :EQUAL STREXP)) *)
d2239 2
a2240 2
 fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.PRESENT sigexp',make_funbind_info(opts,funid),marks_of opts),funid,pE''))
d2243 1
a2243 1
(* 	((FUNBIND1 STARTFUNBIND1 :EQUAL STREXP)) *)
d2245 2
a2246 2
 fn ([STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.ABSENT,make_funbind_info (opts,funid),marks_of opts),funid,pE'''))
d2249 1
a2249 1
(* 	((FUNBIND1 STARTFUNBIND2 :colon SIGEXP :EQUAL STREXP)) *)
d2251 2
a2252 2
 fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.PRESENT sigexp,strexp,pE''))
d2255 1
a2255 1
(* 	((FUNBIND1 STARTFUNBIND2 :EQUAL STREXP)) *)
d2257 2
a2258 2
 fn ([STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')],opts) =>
 (set_pE pE;do_derived_funbind (opts,funid,spec,Absyn.ABSENT,strexp,pE'''))
d2261 1
a2261 1
(* 	((STARTFUNBIND1 FUNIDBIND :lpar STRID :colon SIGEXP :rpar)) *)
d2263 2
a2264 2
 fn ([FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_],opts) =>
 (extend_pSE(make_pSE(strid,pE'));STARTFUNBIND1(funid,pE,strid,sigexp,pE'))
d2267 1
a2267 1
(* 	((STARTFUNBIND2 FUNIDBIND :lpar SPEC :rpar)) *)
d2269 2
a2270 2
 fn ([FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_],opts) => 
 (extend_pE pE'; STARTFUNBIND2(funid,pE,spec,pE'))
d2273 1
a2273 1
(* 	((FUNIDBIND FUNID)) *)
d2275 2
a2276 1
 fn ([FUNID funid],opts) => FUNIDBIND(funid,get_current_pE())
d2279 1
a2279 1
(* 	((TOPDEC)) *)
d2281 2
a2282 1
 fn ([],opts) => raise FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],marks_of opts),PE.empty_pB)
d2285 1
a2285 1
(* 	((TOPDEC STRDEC1PLUS)) *)
d2287 1
a2287 1
 fn ([STRDEC(strdec,pE)],opts) => raise FoundTopDec (Absyn.STRDECtopdec(strdec,marks_of opts),pE_in_pB pE)
d2290 1
a2290 1
(* 	((TOPDEC SIGDEC1PLUS)) *)
d2292 1
a2292 1
 fn ([SIGDEC(l,pG)],opts) => raise FoundTopDec (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2295 1
a2295 1
(* 	((TOPDEC FUNDEC1PLUS)) *)
d2297 1
a2297 1
 fn ([FUNDEC(l,pF)],opts) => raise FoundTopDec (Absyn.FUNCTORtopdec(rev l,marks_of opts),pF_in_pB pF)
d2300 1
a2300 1
(*         ((TOPDEC EXP)) *)
d2302 1
a2302 1
 fn ([EXP(exp,tyvars)],opts) => raise FoundTopDec (make_it_strdec(exp,tyvars,opts),PE.empty_pB)
d2305 1
a2305 1
(* 	((TOPDEC :require :string)) *)
d2307 1
a2307 1
 fn ([_,STRING s],opts) => raise FoundTopDec (Absyn.REQUIREtopdec (s, marks_of opts),PE.empty_pB)
d2310 1
a2310 1
(* 	((PROGRAM TOPDEC :semicolon)) *)
d2312 1
a2312 1
 fn ([x,_],opts) => x
d2315 1
a2315 1
(* 	((PROGRAM TOPDEC)) *)
d2317 1
a2317 1
 fn ([x],opts) => x
d2320 7
a2326 1
(* 	)) *)
d2328 2
a2329 4
(* (setq parsergen::*simple-resolutions* *)
(*       '(;; associativity of tupling *)
(* 	((:reduce (tytuple tytuple star ty)) *)
(* 	 (:shift (ty ty :arrow ty))) *)
d2331 1
a2331 2
(* 	((:reduce (tytuple ty star ty)) *)
(* 	 (:shift (ty ty :arrow ty))) *)
d2333 2
a2334 2
(* 	((:shift (tytuple ty star ty)) *)
(* 	 (:reduce (ty ty :arrow ty))) *)
d2336 1
a2336 3
(* 	;; always make a tuple before a type *)
(* 	((:shift (tytuple tytuple star ty)) *)
(* 	 (:reduce (ty tytuple))) *)
d2338 21
a2358 1
(* 	((:shift (ty ty longtycon)) *)
d2360 153
a2512 150

(* 	;; matches go far to the left *)
(* 	((:shift (match match :vbar mrule)) *)
(* 	 (:reduce (exp exp :handle match))) *)

(* 	((:shift (match match :vbar mrule)) *)
(* 	 (:reduce (exp :fn match))) *)

(* 	((:shift (match match :vbar mrule)) *)
(* 	 (:reduce (exp :case exp :of match))) *)

(* 	;; semicolons,strdecs and decs *)
(* 	;; Reduce decs to strdecs wherever possible *)
(* 	((:reduce (strdec decsep)) *)
(*          (:reduce (dec decsep))) *)

(* 	((:reduce (strdec1 dec1)) *)
(*          (:reduce (decsep))) *)

(* 	((:reduce (strdec1 dec1)) *)
(*          (:reduce (decsep))) *)

(*         ;; self conflicts *)
(* 	((:reduce (tytuple ty star ty)) *)
(* 	 (:shift (tytuple ty star ty))) *)

(* 	((:shift (ty ty :arrow ty)) *)
(*          (:reduce (ty ty :arrow ty))) *)

(* 	((:reduce (exp exp :andalso exp)) *)
(*          (:shift (exp exp :andalso exp))) *)

(* 	((:reduce (exp exp :orelse exp)) *)
(*          (:shift (exp exp :orelse exp))) *)
(* 	)) *)

(* (setq parsergen::*complex-resolutions* *)
(*       '((((:reduce (atpat opvardef))(:shift (pat opvardef opttype :as pat))) *)
(*          (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift) *)
(*          (:colon (:resolve (:reduce (atpat opvardef)) :shift))) *)

(* 	(((:shift (pat oplongvar atpat))(:reduce (atpat oplongvar))) *)
(* 	 (:funcall ifinfixinput (:reduce (atpat oplongvar)) :shift)) *)

(* 	(((:reduce (infexp appexp))(:shift (appexp appexp atexp))) *)
(*          (:funcall ifinfixinput (:reduce (infexp appexp))(:shift (appexp appexp atexp)))) *)

(* 	(((:reduce (pat atpat))(:shift (fval :lpar atpat vardef atpat :rpar opttype :equal exp))) *)
(*          (:funcall ifinfixinput (:reduce (pat atpat)) :shift)) *)

(* 	(((:reduce (atpat opvardef))(:shift (fval opvardef atpatlist opttype :equal exp))) *)
(*          (:funcall ifinfixinput (:reduce (atpat opvardef)) :shift)) *)

(* 	(((:reduce (atpat1 bin_atpat))(:shift (fval bin_atpat atpatlist opttype :equal exp))) *)
(*          (:funcall ifinfixinput (:reduce (atpat1 bin_atpat)):shift)) *)

(* 	(((:reduce (pat atpat)) (:shift (bin_atpat :lpar atpat patvar atpat :rpar))) *)
(*          (:funcall ifinfixinput :shift (:reduce (pat atpat)))) *)

(* 	;; problems with type tuples *)
(* 	(((:reduce (tytuple ty star ty)) (:shift (ty ty longtycon))) *)
(*          (:funcall ifstarinput (:reduce (tytuple ty star ty)) :shift)) *)
(* 	(((:reduce (tytuple tytuple star ty)) (:shift (ty ty longtycon))) *)
(*          (:funcall ifstarinput (:reduce (tytuple tytuple star ty)) :shift)) *)

(* 	;; precedences *)
(*         (((:reduce (pat pat var pat)) (:shift (pat pat var pat))) *)
(* 	 (:funcall ifleftassoc (:reduce (pat pat var pat)) :shift)) *)
(* 	(((:reduce (infexp infexp infvar infexp)) (:shift (infexp infexp infvar infexp))) *)
(* 	 (:funcall ifleftassoc (:reduce (infexp infexp infvar infexp)) :shift)) *)

(* 	;; reduce-reduce conflicts *)
(* 	(((:reduce (vardef :longid)) (:reduce (longvar :longid))) *)
(*          (:funcall ifvarstack (:reduce (vardef :longid)) (:reduce (longvar :longid)))) *)
(* 	(((:reduce (star :longid)) (:reduce (longtycon :longid))) *)
(*          (:funcall ifstarstack (:reduce (star :longid)) (:reduce (longtycon :longid)))) *)
(* 	)) *)

(* (setq parsergen::*unresolve* *)
(*       '(((atpat opvardef) *)
(* 	 (pat opvardef opttype :as pat)) *)
(* 	((pat oplongvar atpat) *)
(* 	 (atpat oplongvar)) *)
(* 	((infexp appexp) *)
(* 	 (appexp appexp atexp)) *)
(* 	((pat atpat) *)
(* 	 (fval :lpar atpat vardef atpat :rpar opttype :equal exp)) *)
(* 	((atpat opvardef) *)
(* 	 (fval opvardef atpatlist opttype :equal exp)) *)
(* 	((atpat1 bin_atpat) *)
(* 	 (fval bin_atpat atpatlist opttype :equal exp)) *)
(* 	((pat atpat) *)
(* 	 (bin_atpat :lpar atpat patvar atpat :rpar)) *)

(* 	;; problems with type tuples *)
(* 	((tytuple ty star ty) *)
(* 	 (ty ty longtycon)) *)
(* 	((tytuple tytuple star ty) *)
(* 	 (ty ty longtycon)) *)
(* 	 *)
(* 	;; reduce-reduce conflicts *)
(* 	((vardef :longid) *)
(* 	 (longvar :longid)) *)
(* 	((star :longid) *)
(* 	 (longtycon :longid)) *)
(* 	)) *)

(* (setq parsergen::*resolutions* *)
(*       '(;; associativity of tupling *)
(* 	((tytuple tytuple star ty) *)
(* 	 (ty ty :arrow ty)) *)
(* 	((tytuple ty star ty) *)
(* 	 (ty ty :arrow ty)) *)
(* 	((ty ty longtycon) *)
(* 	 (pat pat :colon ty)) *)
(* 	;; always make a tuple before a type *)
(* 	((tytuple tytuple star ty) *)
(* 	 (ty tytuple)) *)
(* 	;; matches go far to the left *)
(* 	((match match :vbar mrule) *)
(* 	 (exp :handle match)) *)
(* 	((match match :vbar mrule) *)
(* 	 (exp :fn match)) *)
(* 	((match match :vbar mrule) *)
(* 	 (exp :case exp :of match)) *)

(* 	;; semicolons,strdecs and decs *)
(* 	;; Reduce decs to strdecs wherever possible *)
(* 	((strdec decsep)(dec decsep)) *)
(* 	((strdec1 dec1)(decsep)) *)
(* 	((strdec1 dec1)(decsep)) *)
(* 	)) *)

(* (setq parsergen::*single-conflicts* *)
(*       '(((pat pat var pat) :both) *)
(* 	((tytuple ty star ty) :reduce) *)
(* 	((ty ty :arrow ty) :shift) *)
(* 	;; just a guess *)
(* 	((exp exp :andalso exp) :reduce) *)
(* 	;; just a guess *)
(* 	((exp exp :orelse exp) :reduce) *)
(* 	((infexp infexp infvar infexp) :both) *)
(* 	)) *)

(* (defun test () *)
(*   (parsergen::make-parsing-tables *mlg* )) *)

(* (defun make-it () *)
(*   (compile-file "grammar.lisp" :load t) *)
(*   (test)) *)
d2514 1
a2514 1
(* ;(op-parser::makeit) *)
@


1.6
log
@Changed Error structure to Info
@
text
@a3 2
require "../basics/absyn";
require "../basics/ident";
a5 1
require "../basics/symbol";
a7 1
require "../typechecker/datatypes";
a17 1
                         structure Ident : IDENT
d23 2
a24 2
                         sharing Ident.Symbol = Derived.Symbol = Token.Symbol
                         sharing Ident = Derived.Absyn.IdentClass = PE.Ident = IdentPrint.Ident
d40 3
a43 1
structure Datatypes = Absyn.Datatypes
a45 1
structure Ident = Ident
@


1.5
log
@Added location information to the `require' topdec.
@
text
@a10 1
require "../lexer/lexer";
a15 1
require "../main/error";
d18 1
a18 2
functor ActionFunctions (structure Absyn : ABSYN
                         structure LRbasics : LRBASICS
a20 1
                         structure Set : SET
a24 2
                         structure Datatypes : DATATYPES
                         structure Symbol : SYMBOL
a25 3
                         structure Lexer : LEXER
                         structure Interface : INTERFACE
                         structure Nameset : NAMESET
a26 1
                         structure Error : ERROR
d28 3
a30 10
                         sharing Symbol = Ident.Symbol = Derived.Symbol = Token.Symbol
                         sharing Datatypes = Absyn.Datatypes
                         sharing Derived.Absyn = Absyn
                         sharing Absyn.Set = Set
                         sharing Absyn.Nameset = Nameset
                         sharing Absyn.IdentClass = Ident
                         sharing Ident = Absyn.IdentClass = PE.Ident = IdentPrint.Ident
                         sharing Absyn.Interface = Interface
                         sharing Absyn.Location = Error.Location
                         sharing type Ident.Symbol.Symbol = Symbol.Symbol) : ACTIONFUNCTIONS =
d35 2
a37 4
structure Token = Token
structure Absyn = Absyn
structure Lexer = Lexer
structure Error = Error
d39 4
d44 7
a50 1
structure Location = Error.Location
a175 1
(* location *)
d177 1
a177 1
val dummy_location = Absyn.Location.UNKNOWN
d179 2
a180 1
val current_location_ref = ref dummy_location
d182 1
a182 1
fun current_marks() = ! current_location_ref
d184 1
a184 1
val tokenstream_ref = ref (Lexer.mkTokenStream(fn x => "","Dummy Stream"))
d188 2
a189 2
  fun locate string =
    implode [string, " ", Absyn.Location.to_string (!current_location_ref)]
d191 9
a199 9
  fun make_hash_info (Ident.LAB sym) = locate ("#" ^ Symbol.symbol_name sym ^ " ")
  fun make_seq_info () = locate "part of sequence" 
  fun make_and_info () = locate "andalso expression"
  fun make_orelse_info () = locate "orelse expression"
  fun make_handle_info () = locate "handle expression"
  fun make_if_info () = locate "if expression"
  fun make_case_info () = locate "case expression"
  fun make_fn_info () = locate "anonymous function"
  fun make_exbind_info (Ident.EXCON sym) = locate (Symbol.symbol_name sym)
d201 3
a203 3
  fun make_funbind_info (Ident.FUNID sym) = locate ("Functor " ^ Symbol.symbol_name sym)
  fun make_while_info () = locate
  fun make_fval_info () = locate
d207 2
a208 3
fun error (message) =
  Error.report
  (Error.ERROR (Error.RECOVERABLE, current_marks(), message))
d210 2
a211 3
fun warn (message) =
  Error.report
  (Error.ERROR (Error.WARNING, current_marks(), message))
d213 6
d224 2
a225 2
fun report_long_error (longid,ty) =
  error("Unexpected long " ^ ty ^ ": " ^ (make_id_name longid))
d241 1
a241 1
fun parse_precedence (s) =
d244 1
a244 1
  | _ => (error "Only Single digit allowed for precedence, using 0";
d252 1
a252 1
fun mkTyCon sym = 
d254 1
a254 2
     Error.report
     (Error.ERROR (Error.NONSTANDARD, current_marks(), "Asterisk not allowed as type constructor"))
d273 1
a273 1
fun mkLongTyCon (syms,sym) = 
d275 1
a275 2
     Error.report
     (Error.ERROR (Error.NONSTANDARD, current_marks(), "Asterisk not allowed as TyCon"))
d295 1
a295 1
fun check_is_constructor id =
d299 1
a299 1
    error ("Non-constructor " ^ (IdentPrint.printLongValId id) ^ " used in pattern")
d301 1
a301 1
fun check_is_short_constructor id =
d305 1
a305 1
    error ("Non-constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d307 1
a307 1
fun check_not_constructor id =
d309 1
a309 1
    error ("Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d313 1
a313 1
fun check_not_short_constructor id =
d315 1
a315 1
    error ("Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d319 1
a319 1
fun check_integer_bounds int =
d330 1
a330 1
            error "Integer label must be positive"
d401 1
a401 1
fun check_is_infix ([],s) =
d406 1
a406 1
    error ("Symbol " ^ Symbol.symbol_name s ^ " is not infix")
d410 1
a410 1
fun check_not_constructor_symbol s =
d415 1
a415 1
      then error ("Trying to bind constructor " ^ Symbol.symbol_name s ^ " in record")
d490 2
a491 2
fun check_disjoint_labels (lab,[]) = ()
  | check_disjoint_labels (lab,(lab',_):: l) =
d493 2
a494 2
      then error("Duplicate labels in record: " ^ (label_name lab))
    else check_disjoint_labels(lab,l)
d496 2
a497 2
fun check_disjoint_tyvars (tyvar,[]) = ()
  | check_disjoint_tyvars (tyvar,(tyvar'::tyvars)) =
d499 2
a500 2
      then error("Duplicate type variables in sequence: " ^ (tyvar_name tyvar))
    else check_disjoint_tyvars (tyvar,tyvars)
d502 1
a502 1
fun check_tyvar_inclusion (tyvars,tyvarlist) =
d509 1
a509 1
  else error "Free type variable in type declaration"
d512 1
a512 1
  fun check_disjoint_tycons (key,message)(item,list) =
d517 1
a517 1
          error ("Multiple declaration of tycon " ^ Symbol.symbol_name sym ^ " in " ^ message)
d529 2
a530 2
fun check_rec_bindings [] = ()
  | check_rec_bindings((pat,exp,location)::l) =
d536 4
a539 4
      (if is_fn exp
         then ()
       else (error "Non-fn expression in valbind");
         check_rec_bindings l)
d542 1
a542 1
fun check_disjoint_withtype (datbindlist,typbindlist) =
d554 1
a554 1
    | tycons => (error ("Duplicate bindings in withtype: " ^ make_string tycons))
d585 1
a585 1
fun merge_pVEs (pVE1 as (PE.VE ve1),pVE2 as (PE.VE ve2)) =
d587 1
a587 1
    (error("Duplicate value binding: " ^ IdentPrint.printValId valid1);
d594 2
a595 2
  fun valid_error(_,_,valid) =
    (error("Multiple declaration of valid: " ^  IdentPrint.printValId valid);
d597 2
a598 2
  fun strid_error(strid,_,pE) =
    (error("Multiple declaration of strid: " ^  IdentPrint.printStrId strid);
d600 2
a601 2
  fun funid_error(funid,_,pE) =
    (error("Multiple declaration of funid: " ^  IdentPrint.printFunId funid);
d603 2
a604 2
  fun sigid_error(sigid,_,pE) =
    (error("Multiple declaration of sigid: " ^  IdentPrint.printSigId sigid);
d608 5
a612 5
  fun addNewStrId ((strid,pE),pSE) =
    PE.addStrId (strid_error,strid,zap_pFE pE,pSE)
  fun addNewSigId ((id,pE),pGE) = PE.addSigId (sigid_error,id,pE,pGE)
  fun addNewFunId ((id,pE),pFE) = PE.addFunId (funid_error,id,pE,pFE)
  fun addNewValId (id,pE) = PE.addValId (valid_error,id,pE)
d615 1
a615 1
fun addNewSymId (sym,pVE) = addNewValId(Ident.VAR sym,pVE)
d624 1
a624 1
  fun check_longid_op (id as Ident.LONGVALID (p,v)) =
d628 1
a628 2
      Error.report
      (Error.ERROR (Error.ADVICE, current_marks(), "Unnecessary op for " ^ Symbol.symbol_name(get_sym v)))
d630 1
a630 1
  fun check_non_longid_op (id as Ident.LONGVALID (p,v)) =
d632 1
a632 1
      error ("Need an op for " ^ Symbol.symbol_name(get_sym v))
d637 1
a637 1
fun check_valid_op v =
d641 1
a641 2
    Error.report
    (Error.ERROR (Error.ADVICE, current_marks(), "Unnecessary op for " ^ Symbol.symbol_name(get_sym v)))
d643 1
a643 1
fun check_non_valid_op v =
d645 1
a645 1
    error ("Need an op for " ^ Symbol.symbol_name(get_sym v))
d652 1
a652 1
fun mannotate x = (x,ref Datatypes.NULLTYPE,current_marks())
d663 1
a663 1
fun do_open_dec_action (longids) =
d670 1
a670 1
     DEC (Absyn.OPENdec (valids,current_marks()),new_pE,Set.empty_set))
d673 1
a673 1
fun do_open_spec_action (longids) =
d680 1
a680 1
     SPEC(Absyn.OPENspec (valids,current_marks()),new_pE))
d683 1
a683 1
fun do_include_action (sigids) =
d689 1
a689 1
     SPEC(Absyn.INCLUDEspec(sigids,current_marks()),new_pE))
d698 2
a699 2
fun make_infix_fval (id,pat1,pat2,patlist,exp,tvarlist) =
  (check_not_short_constructor id;
d703 1
a703 1
fun make_it_strdec (e,tyvars,location) =
d716 1
a716 1
  current_marks())
d720 1
a720 1
fun do_derived_funbind (funid,spec,opt_sig,strexp,pE) =
d727 1
a727 1
                          current_marks())
d729 1
a729 1
    FUNBIND1 ((a,b,c,d,e,f,make_funbind_info funid,current_marks()),funid,pE)
d754 1
a754 1
 fn [dec] => dec
d759 1
a759 1
 fn [SCON scon] => EXP (Absyn.SCONexp scon,Set.empty_set)
d764 1
a764 1
 fn [LONGVALID id] => EXP (Absyn.VALexp (mannotate id), Set.empty_set)
d772 3
a774 3
 fn [_] =>
   (check_non_longid_op equal_lvalid; 
    EXP (Absyn.VALexp (mannotate (equal_lvalid)), Set.empty_set))
d779 3
a781 3
 fn [_,_] => 
   (check_longid_op equal_lvalid;
    EXP (Absyn.VALexp (mannotate (equal_lvalid)), Set.empty_set))
d786 1
a786 1
 fn [_,EXPROW (l,tyvars),_] => EXP (Absyn.RECORDexp (rev l),tyvars)
d791 1
a791 1
 fn [_,_] => EXP (Absyn.RECORDexp [],Set.empty_set)
d796 2
a797 2
 fn [_,LAB lab] =>
   EXP (Derived.make_select (lab,current_marks(),make_hash_info lab),Set.empty_set)
d802 1
a802 1
 fn [_,_] => EXP (Derived.make_unit_exp (),Set.empty_set)
d807 1
a807 1
 fn [_,EXPLIST (l,tyvars),_] => EXP (Derived.make_tuple_exp (rev l),tyvars)
d812 1
a812 1
 fn [_,EXPLIST (l,tyvars),_] => EXP (Derived.make_list_exp (current_marks()) (rev l),tyvars)
d817 1
a817 1
 fn [_,EXPSEQ (l,tyvars),_] => EXP (Derived.make_sequence_exp (rev l),tyvars)
d822 1
a822 1
 fn [ENV pE,DEC (dec,_,tyvars1),_,EXPSEQ (l,tyvars2),_] =>
d828 1
a828 1
 fn [_,x,_] => x
d833 1
a833 1
 fn [_] => ENV (get_current_pE())
d838 1
a838 1
 fn [EXPLIST (l,tyvars1),_,EXP (exp,tyvars2)] => EXPLIST (exp::l,Set.union (tyvars1,tyvars2))
d843 1
a843 1
 fn [EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)] => EXPLIST ([exp2,exp1],Set.union (tyvars1,tyvars2))
d848 1
a848 1
 fn [] => EXPLIST ([],Set.empty_set)
d853 1
a853 1
 fn [EXP (exp,tyvars)] => EXPLIST ([exp],tyvars)
d858 1
a858 1
 fn [exp] => exp
d863 2
a864 2
 fn [EXPSEQ(l,tyvars1),_,EXP (exp,tyvars2)] => 
   EXPSEQ ((exp,make_seq_info(),current_marks())::l,Set.union (tyvars1,tyvars2))
d869 1
a869 1
 fn [EXP(exp,tyvars)] => EXPSEQ ([(exp,make_seq_info(),current_marks())],tyvars)
d874 2
a875 2
 fn [EXPSEQ(l,tyvars1),_,EXP(exp,tyvars2)] => 
   EXPSEQ ((exp,make_seq_info(),current_marks())::l,Set.union (tyvars1,tyvars2))
d880 1
a880 1
 fn [LAB lab,_,EXP (exp,tyvars)] => EXPROW ([(lab,exp)],tyvars)
d885 2
a886 2
 fn [EXPROW(l,tyvars1),_,LAB lab,_,EXP (exp,tyvars2)] =>
   (check_disjoint_labels(lab,l);EXPROW ((lab,exp)::l,Set.union(tyvars1,tyvars2)))
d891 1
a891 1
 fn [x] => x
d896 2
a897 2
 fn [EXP (exp1,tyvars1), EXP (exp2,tyvars2)] =>
   EXP(Absyn.APPexp(exp1,exp2,current_marks(),ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
d902 1
a902 1
 fn [x] => x
d907 2
a908 2
 fn [EXP (exp1,tyvars1), LONGVALID id, EXP (exp2,tyvars2)] =>
   EXP (Absyn.APPexp (Absyn.VALexp (mannotate id),Derived.make_tuple_exp [exp1,exp2],current_marks(),ref Datatypes.NULLTYPE),Set.union(tyvars1,tyvars2))
d913 1
a913 1
 fn [x] => x
d918 1
a918 1
 fn [_] => LONGVALID equal_lvalid
d923 1
a923 1
 fn [x] => x
d928 2
a929 2
 fn [EXP (exp,tyvars1),_,TY (ty,tyvars2)] =>
   EXP (Absyn.TYPEDexp (exp,ty,current_marks()),Set.union(tyvars1,tyvars2))
d934 2
a935 2
 fn [EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)] =>
   EXP (Derived.make_andalso (exp1,exp2,make_and_info(),current_marks()),Set.union(tyvars1,tyvars2))
d940 2
a941 2
 fn [EXP(exp1,tyvars1),_,EXP (exp2,tyvars2)] =>
   EXP (Derived.make_orelse (exp1,exp2,make_orelse_info(),current_marks()),Set.union(tyvars1,tyvars2))
d946 2
a947 2
 fn [EXP(exp1,tyvars1),_,MATCH(match,tyvars2)] =>
   EXP (Absyn.HANDLEexp (exp1, ref Datatypes.NULLTYPE, (rev match),current_marks(),make_handle_info()),Set.union(tyvars1,tyvars2))
d952 1
a952 1
 fn [_,EXP (exp,tyvars)] => EXP (Absyn.RAISEexp (exp,current_marks()),tyvars)
d958 2
a959 2
 fn [_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2),_,EXP (exp3,tyvars3)] =>
   EXP(Derived.make_if (exp1,exp2,exp3,make_if_info(),current_marks()),join_tyvars[tyvars1,tyvars2,tyvars3])
d964 2
a965 2
 fn [_,EXP (exp1,tyvars1),_,EXP (exp2,tyvars2)] =>
   EXP (Derived.make_while (exp1,exp2,make_while_info(),current_marks()),Set.union(tyvars1,tyvars2))
d970 2
a971 2
 fn [_,EXP(exp,tyvars1),_,MATCH(m,tyvars2)] =>
   EXP (Derived.make_case (exp,(rev m),make_case_info(),current_marks()),Set.union(tyvars1,tyvars2))
d976 2
a977 2
 fn [_,MATCH (match,tyvars)] =>
   let val (a,b) = annotate (rev match) in EXP (Absyn.FNexp (a,b,make_fn_info(),current_marks()),tyvars) end
d982 1
a982 1
 fn [MATCH (match,tyvars1),_,MRULE (rule,tyvars2)] => MATCH (rule::match,Set.union(tyvars1,tyvars2))
d987 1
a987 1
 fn [MRULE(rule,tyvars)] => MATCH([rule],tyvars)
d993 1
a993 1
 fn [PAT(pat,pE,tyvars1),_,EXP(exp,tyvars2)] => MRULE((pat,exp),Set.union(tyvars1,tyvars2))
d999 1
a999 1
 fn [] => DUMMY
d1004 1
a1004 1
 fn [_,_] => DUMMY
d1009 1
a1009 1
 fn [_] => DEC (Absyn.SEQUENCEdec[],PE.empty_pE,Set.empty_set)
d1014 1
a1014 1
 fn [_,dec,_] => dec
d1019 1
a1019 1
 fn [_,DECLIST(l,pE,tyvars),_] => DEC(Absyn.SEQUENCEdec(rev l),pE,tyvars)
d1024 1
a1024 1
 fn [DEC(dec1,pE1,tyvars1),_,DEC(dec2,pE2,tyvars2)] => DECLIST([dec2,dec1],PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1029 1
a1029 1
 fn [DECLIST(l,pE1,tyvars1),_,DEC(dec,pE2,tyvars2)] => DECLIST(dec::l,PE.augment_pE(pE1,pE2),Set.union(tyvars1,tyvars2))
d1038 1
a1038 1
 fn [_, VALBIND (valbinds1,valbinds2,tyvars,pVE)] =>
d1044 2
a1045 2
 fn [_,FVALBIND ((l,tyvars),pVE)] =>
 DEC (Derived.make_fun ((map (fn y => Derived.make_fvalbind y) (rev l)),tyvars,current_marks()),pVE_in_pE pVE,Set.empty_set)
d1050 1
a1050 1
 fn [_,TYPBIND l] => DEC (Absyn.TYPEdec (rev l),PE.empty_pE,Set.empty_set)
d1057 2
a1058 2
 fn [_,DATBIND (d,pVE)] => 
   (extend_pVE pVE; DEC (Absyn.DATATYPEdec (current_marks(),rev d),pVE_in_pE pVE,Set.empty_set))
d1063 2
a1064 2
 fn [_,DATBIND (d,pVE),_,TYPBIND t] =>
   (check_disjoint_withtype(d,t);
d1066 1
a1066 1
    DEC (Derived.make_datatype_withtype (current_marks(),rev d, t),pVE_in_pE pVE,Set.empty_set))
d1071 2
a1072 2
 fn [_,DATBIND (d,pVE),_,DEC(dec,pE,tyvars),_] =>
   (extend_pVE pVE; DEC (Absyn.ABSTYPEdec (current_marks(),rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
d1077 2
a1078 2
 fn [_,DATBIND (d,pVE),_,TYPBIND t,_,DEC (dec,pE,tyvars),_] =>
   (check_disjoint_withtype(d,t);
d1080 1
a1080 1
    DEC (Derived.make_abstype_withtype (current_marks(),rev d,t,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
d1085 1
a1085 1
 fn [_,EXBIND (l,pVE,tyvars)] => 
d1091 1
a1091 1
 fn [ENV env_pE,DEC (dec1,_,tyvars1),_,DEC (dec2,pE,tyvars2),_] =>
d1100 1
a1100 1
 fn [_,LONGIDLIST l] => do_open_dec_action (rev l)
d1108 1
a1108 1
 fn [_,SYMLIST l] => extend_pE_for_fixity (l, PE.LEFT 0)
d1113 1
a1113 1
 fn [_,INTEGER i,SYMLIST l] => extend_pE_for_fixity (l, PE.LEFT (parse_precedence i))
d1118 1
a1118 1
 fn [_,SYMLIST l] => extend_pE_for_fixity (l, PE.RIGHT 0)
d1123 1
a1123 1
 fn [_,INTEGER i,SYMLIST l] => extend_pE_for_fixity (l, PE.RIGHT (parse_precedence i))
d1128 1
a1128 1
 fn [_,SYMLIST l] => extend_pE_for_fixity (l, PE.NONFIX)
d1135 1
a1135 1
 fn [_] => ENV (get_current_pE())
d1140 1
a1140 1
 fn [x] => x
d1145 2
a1146 2
 fn [VALBIND (v1,v2,tyvars1,pVE1),_,VALBIND([a],[],tyvars2,pVE2)] =>
   VALBIND (a::v1,v2,Set.union(tyvars1,tyvars2),merge_pVEs(pVE1,pVE2))
d1151 2
a1152 2
 fn [_,VALBIND (v1,v2,tyvars,pVE)] =>
 (check_rec_bindings v1;VALBIND ([],v2@@v1,tyvars,pVE))
d1157 2
a1158 2
 fn [PAT (pat,pVE,tyvars1),_,EXP (exp,tyvars2)] =>
   VALBIND ([(pat,exp,current_marks())],[],Set.union (tyvars1,tyvars2),pVE)
d1165 2
a1166 2
 fn [FVALLIST (fvals,tyvars,id)] =>
   FVALBIND (([((rev fvals),make_fval_info(),current_marks())],tyvars),make_pVE id)
d1171 2
a1172 2
 fn [FVALBIND ((l,tyvars1),pVE),_,FVALLIST (fvals,tyvars2,id)] =>
   FVALBIND (((rev fvals,make_fval_info(),current_marks())::l,Set.union(tyvars1,tyvars2)),addNewValId(id,pVE))
d1177 1
a1177 1
 fn [FVAL ((fval,tyvars),id)] => FVALLIST ([fval],tyvars,id)
d1183 1
a1183 1
 fn [FVALLIST (fvals,tyvars1,id),_,FVAL ((fval,tyvars2),id')] =>
d1189 3
a1191 3
 fn [VALID id,PATLIST(l,pE,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)] =>
  FVAL(((id,rev l,Absyn.TYPEDexp(exp,ty,current_marks())),join_tyvars[tyvars1,tyvars2,tyvars3]),id)
 |[VALID id,PATLIST (l,pE,tyvars1),NULLTYPE,_,EXP (exp,tyvars3)] =>
d1197 4
a1200 4
 fn [PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)] =>
 FVAL(make_infix_fval (id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,current_marks()),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
|[PAT (pat1,pE1,tyvars1),VALID id,PAT (pat2,pE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)] =>
 FVAL(make_infix_fval (id,pat1,pat2,[],exp,[tyvars1,tyvars2,tyvars3]),id)
d1205 4
a1208 4
 fn [BINPAT (pat1,id,pat2,pE1,tyvars1),TY (ty,tyvars2),_,EXP (exp,tyvars3)] =>
 FVAL(make_infix_fval (id,pat1,pat2,[],Absyn.TYPEDexp(exp,ty,current_marks()),[tyvars1,tyvars2,tyvars3]),id)
|[BINPAT (pat1,id,pat2,pE1,tyvars1),NULLTYPE,_,EXP (exp,tyvars2)] =>
 FVAL(make_infix_fval (id,pat1,pat2,[],exp,[tyvars1,tyvars2]),id)
d1213 4
a1216 4
 fn [BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),TY (ty,tyvars3),_,EXP (exp,tyvars4)] =>
   FVAL(make_infix_fval (id,pat1,pat2,rev patl,Absyn.TYPEDexp(exp,ty,current_marks()),[tyvars1,tyvars2,tyvars3,tyvars4]),id)
|[BINPAT (pat1,id,pat2,pE1,tyvars1),PATLIST(patl,pE2,tyvars2),NULLTYPE,_,EXP (exp,tyvars3)] =>
   FVAL(make_infix_fval (id,pat1,pat2,rev patl,exp,[tyvars1,tyvars2,tyvars3]),id)
d1221 1
a1221 1
 fn [] => NULLTYPE
d1226 1
a1226 1
 fn [_,ty] => ty
d1231 1
a1231 1
 fn [TYPBIND1 tb] => TYPBIND [tb]
d1236 2
a1237 2
 fn [TYPBIND tbl,_,TYPBIND1 tb] =>
    (check_disjoint_typbind(tb,tbl);TYPBIND (tb::tbl))
d1242 2
a1243 2
 fn [TYVARLIST tyvarlist, TYCON tycon,_,TY (ty,tyvars)] =>
   (check_tyvar_inclusion(tyvars,tyvarlist);TYPBIND1 (rev tyvarlist,tycon,ty))
d1248 1
a1248 1
 fn [] => TYVARLIST []
d1253 1
a1253 1
 fn [TYVAR t] => TYVARLIST [t]
d1258 1
a1258 1
 fn [_,TYVARLIST l,_] => TYVARLIST l
d1263 1
a1263 1
 fn [TYVAR t] => TYVARLIST [t]
d1268 1
a1268 1
 fn [TYVARLIST l,_,TYVAR t] => (check_disjoint_tyvars(t,l);TYVARLIST (t::l))
d1273 1
a1273 1
 fn [DATBIND1(d,pVE)] => DATBIND([d],pVE)
d1278 2
a1279 2
 fn [DATBIND(l,pVE),_,DATBIND1(d,pVE')] =>
 (check_disjoint_datbind(d,l);DATBIND(d::l,merge_pVEs(pVE,pVE')))
d1284 2
a1285 2
 fn [TYVARLIST tyvarlist, TYCON tycon,_,CONBIND (conbind,pVE,tyvars)] =>
   (check_tyvar_inclusion(tyvars,tyvarlist);
d1291 1
a1291 1
 fn [CONBIND1(cb,id,tyvars)] => CONBIND([cb],make_pVE id,tyvars)
d1296 2
a1297 2
 fn [CONBIND (cbl,pVE,tyvars1),_,CONBIND1 (cb,id,tyvars2)] =>
   CONBIND(cb::cbl,addNewValId(id,pVE),Set.union(tyvars1,tyvars2))
d1302 2
a1303 2
 fn [VALID id,TY (ty,tyvars)] => CONBIND1 ((annotate id,Absyn.PRESENT ty),id,tyvars)
 |[VALID id,NULLTYPE] => CONBIND1 ((annotate id,Absyn.ABSENT),id,Set.empty_set)
d1308 1
a1308 1
 fn [EXBIND1 (e,id,tyvars)] => EXBIND ([e],make_pVE id,tyvars)
d1313 2
a1314 2
 fn [EXBIND (l,pVE,tyvars1),_,EXBIND1 (e,id,tyvars2)] =>
   EXBIND (e::l,addNewValId(id,pVE),Set.union(tyvars1,tyvars2))
d1319 4
a1322 4
 fn [VALID id, TY (ty,tyvars)] => 
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.PRESENT ty,current_marks(),make_exbind_info id),id,tyvars)
|[VALID id, NULLTYPE] => 
   EXBIND1 (Absyn.NEWexbind (annotate id,Absyn.ABSENT,current_marks(),make_exbind_info id),id,Set.empty_set)
d1327 2
a1328 2
 fn [VALID id,_,LONGVALID id'] => 
   EXBIND1 (Absyn.OLDexbind (annotate id,id',current_marks(),make_exbind_info id),id,Set.empty_set)
d1333 1
a1333 1
 fn [] => NULLTYPE
d1338 1
a1338 1
 fn [_,x] => x
d1343 1
a1343 1
 fn [_] => PAT (Absyn.WILDpat,PE.empty_pVE,Set.empty_set)
d1348 1
a1348 1
 fn [SCON x] => PAT (Absyn.SCONpat x,PE.empty_pVE,Set.empty_set)
d1355 2
a1356 2
 fn [VALID id] => 
   PAT (Absyn.VALpat (annotate (make_long_id id),current_marks()),make_pVE id,Set.empty_set)
d1361 3
a1363 3
 fn [LONGVALID id] => 
   (check_is_constructor id;
    PAT (Absyn.VALpat (annotate id,current_marks()),PE.empty_pVE,Set.empty_set))
d1368 1
a1368 1
 fn [_,PATROW (columns,wild,pVE,tyvars),_] => 
d1374 1
a1374 1
 fn [_,PATROW (columns,wild,pVE,tyvars),_,_,_] => 
d1380 1
a1380 1
 fn [_,_,_] => 
d1386 1
a1386 1
 fn [_,_] => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1391 1
a1391 1
 fn [_,_] => PAT (Derived.make_unit_pat(),PE.empty_pVE,Set.empty_set)
d1396 1
a1396 1
 fn [_,PATLIST (l,pVE,tyvars),_] => PAT (Derived.make_tuple_pat (rev l),pVE,tyvars)
d1401 1
a1401 1
 fn [_,_] => PAT (Derived.make_list_pat([],current_marks()),PE.empty_pVE,Set.empty_set)
d1406 1
a1406 1
 fn [_,PAT(l,pVE,tyvars),_] => PAT (Derived.make_list_pat([l],current_marks()),pVE,tyvars)
d1411 1
a1411 1
 fn [_,x,_] => x
d1416 1
a1416 1
 fn [_,PATLIST (l,pVE,tyvars),_] => PAT (Derived.make_list_pat(rev l,current_marks()),pVE,tyvars)
d1421 2
a1422 2
 fn [_,PAT (pat1,pVE1,tyvars1),VALID id,PAT (pat2,pVE2,tyvars2),_] =>
   BINPAT(pat1,id,pat2,merge_pVEs(pVE1,pVE2),Set.union(tyvars1,tyvars2))
d1427 3
a1429 3
 fn [BINPAT (pat1,id,pat2,pVE,tyvars)] =>
   (check_is_short_constructor id;
    PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2],current_marks()),pVE,tyvars))
d1434 1
a1434 1
 fn [x] => x
d1439 2
a1440 2
 fn [PAT (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)] =>
   PATLIST ([pat2,pat1], merge_pVEs (pVE1,pVE2), Set.union (tyvars1,tyvars2))
d1445 2
a1446 2
 fn [PATLIST (pat1,pVE1,tyvars1),_,PAT (pat2,pVE2,tyvars2)] =>
   PATLIST (pat2::pat1, merge_pVEs(pVE1,pVE2), Set.union (tyvars1,tyvars2))
d1451 1
a1451 1
 fn [PATROW1 (lp,pVE,tyvars)] => PATROW ([lp],false,pVE,tyvars)
d1456 3
a1458 3
 fn [PATROW (l,wild,pVE1,tyvars1),_,PATROW1 (lp as (lab,_),pVE2,tyvars2)] =>
   (check_disjoint_labels(lab,l);
    PATROW (lp :: l,wild,merge_pVEs(pVE1,pVE2), Set.union(tyvars1,tyvars2)))
d1463 1
a1463 1
 fn [LAB lab,_,PAT (pat,pVE,tyvars)] => PATROW1 ((lab,pat),pVE,tyvars)
d1468 6
a1473 6
 fn [SYM sym, TY (ty,tyvars)] =>
   (check_not_constructor_symbol sym;
    PATROW1 ((Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.ABSENT,current_marks())),make_Sym_pVE sym,tyvars))
|[SYM sym, NULLTYPE] =>
   (check_not_constructor_symbol sym;
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.ABSENT,current_marks()),make_Sym_pVE sym,Set.empty_set))
d1478 6
a1483 6
 fn [SYM sym, TY (ty,tyvars1),_,PAT (pat,pVE,tyvars2)] =>
   (check_not_constructor_symbol sym;
    PATROW1 (Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.PRESENT pat,current_marks()),addNewSymId(sym,pVE),Set.union (tyvars1,tyvars2)))
|[SYM sym, NULLTYPE,_,PAT (pat,pVE,tyvars)] =>
   (check_not_constructor_symbol sym;
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.PRESENT pat,current_marks()),addNewSymId(sym,pVE),tyvars))
d1488 1
a1488 1
 fn [x] => x
d1493 2
a1494 2
 fn [LONGVALID id, PAT (pat,pVE,tyvars)] => 
   (check_is_constructor id; PAT (Absyn.APPpat (annotate id, pat,current_marks()),pVE,tyvars))
d1499 3
a1501 3
 fn [PAT(pat1,pVE1,tyvars1), LONGVALID id, PAT(pat2,pVE2,tyvars2)] =>
   (check_is_constructor id;
    PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2],current_marks()),merge_pVEs(pVE1,pVE2),Set.union(tyvars1,tyvars2)))
d1506 1
a1506 1
 fn [PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)] => PAT (Absyn.TYPEDpat(pat,ty,current_marks()),pVE,Set.union(tyvars1,tyvars2))
d1511 4
a1514 4
 fn [VALID id, TY(ty,tyvars1),_,PAT(pat,pVE,tyvars2)] =>
   PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate id, pat), ty,current_marks()),addNewValId(id,pVE),Set.union(tyvars1,tyvars2))
|[VALID id, NULLTYPE,_,PAT (pat,pVE,tyvars)] =>
   PAT (Absyn.LAYEREDpat (annotate id, pat),addNewValId(id,pVE),tyvars)
d1521 1
a1521 1
 fn [TYVAR t] => TY (Absyn.TYVARty (t),Set.singleton t)
d1526 1
a1526 1
 fn [_,TYROW (l,tvs),_] => TY (Absyn.RECORDty l,tvs)
d1531 1
a1531 1
 fn [_,_] => TY (Absyn.RECORDty [],Set.empty_set)
d1536 1
a1536 1
 fn [TYLIST (s,tvs), LONGTYCON c] => TY (Absyn.APPty (rev s,c,current_marks()),tvs)
d1541 1
a1541 1
 fn [TY (t,tvs), LONGTYCON c] => TY (Absyn.APPty ([t],c,current_marks()),tvs)
d1546 1
a1546 1
 fn [LONGTYCON c] => TY (Absyn.APPty ([],c,current_marks()),Set.empty_set)
d1551 1
a1551 1
 fn [TYLIST (tl,tvs)] => TY (Derived.make_tuple_ty (rev tl),tvs)
d1556 1
a1556 1
 fn [TY (t1,tvs1),_,TY (t2,tvs2)] => TY (Absyn.FNty (t1,t2),Set.union(tvs1,tvs2))
d1561 1
a1561 1
 fn [_,t,_] => t
d1566 1
a1566 1
 fn [_,TYLIST (l,tyvars1),_,TY (ty,tyvars2),_] => TYLIST (ty :: l,Set.union(tyvars1,tyvars2))
d1571 1
a1571 1
 fn [TY (ty,tyvars)] => TYLIST ([ty],tyvars)
d1576 1
a1576 1
 fn [TYLIST (tl,tyvars1),_,TY (ty,tyvars2)] => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1581 1
a1581 1
 fn [TYLIST (tl,tyvars1),_,TY (ty,tyvars2)] => TYLIST (ty::tl,Set.union(tyvars1,tyvars2))
d1586 1
a1586 1
 fn [TY (t1,tyvars1),_,TY (t2,tyvars2)] => TYLIST ([t2,t1],Set.union(tyvars1,tyvars2))
d1591 1
a1591 1
 fn [LAB l,_,TY (ty,tyvars)] => TYROW ([(l,ty)],tyvars)
d1596 2
a1597 2
 fn [TYROW (l,tyvars1),_,LAB lab,_,TY (ty,tyvars2)] =>
 (check_disjoint_labels(lab,l);TYROW ((lab,ty)::l,Set.union(tyvars1,tyvars2)))
d1604 1
a1604 1
 fn [PAT (pat,pE,tyvars)] => PATLIST ([pat],pE,tyvars)
d1609 2
a1610 2
 fn [PATLIST (l,pVE1,tyvars1), PAT (pat,pVE2,tyvars2)] => 
   PATLIST (pat::l,merge_pVEs(pVE1,pVE2),Set.union (tyvars1,tyvars2))
d1617 1
a1617 1
 fn [LONGIDLIST l,LONGID id] => LONGIDLIST(id :: l)
d1622 1
a1622 1
 fn [LONGID id] => LONGIDLIST[id]
d1629 1
a1629 1
 fn [LONGSTRIDLIST l, LONGSTRID i] => LONGSTRIDLIST(i::l)
d1634 1
a1634 1
 fn [LONGSTRID i] => LONGSTRIDLIST[i]
d1641 1
a1641 1
 fn [SYM sym] => SYMLIST [sym]
d1646 1
a1646 1
 fn [SYMLIST l,SYM sym] => SYMLIST (sym::l)
d1653 1
a1653 1
 fn [INTEGER s] => SCON (Ident.INT s)
d1658 1
a1658 1
 fn [REAL s] => SCON (Ident.REAL s)
d1663 1
a1663 1
 fn [STRING s] => SCON (Ident.STRING s)
d1670 3
a1672 3
 fn [LONGID ([],s)] => LAB (Ident.LAB s)
|[LONGID (id as (p,s))] =>
   (report_long_error (id,"LABEL"); LAB (Ident.LAB s))
d1677 1
a1677 1
 fn [INTEGER int] => (check_integer_bounds int; LAB (Ident.LAB (Symbol.find_symbol int)))
d1684 1
a1684 1
 fn [LONGID id] => LONGVALID (resolveLongValId id)
d1689 1
a1689 1
 fn [l as LONGVALID id] => (check_non_longid_op id; l)
d1694 1
a1694 1
 fn [_, l as LONGVALID id] => (check_longid_op id; l)
d1699 1
a1699 1
 fn [LONGID (l,s)] => LONGTYCON (mkLongTyCon (l,s))
d1704 1
a1704 1
 fn [LONGID (l,s)] => LONGSTRID (mkLongStrId (l,s))
d1711 3
a1713 3
 fn [LONGID ([],s)] => SYM s
|[LONGID (id as (l,s))] =>
   (report_long_error (id,"ID"); SYM s)
d1718 1
a1718 1
 fn [_] => SYM equal_symbol
d1723 1
a1723 1
 fn [SYM s] => FUNID(Ident.FUNID s)
d1728 1
a1728 1
 fn [SYM s] => SIGID(Ident.SIGID s)
d1733 1
a1733 1
 fn [SYM s] => STRID(Ident.STRID s)
d1742 2
a1743 2
 fn [LONGID (id as ([],_))] => LONGVALID (resolveLongValId id)
|[LONGID id] => (report_long_error (id,"VAR"); LONGVALID (resolveLongValId id))
d1750 2
a1751 2
 fn [LONGID ([],id)] => let val valid = resolveValId id in check_not_constructor valid; VALID valid end
|[LONGID (longid as (_,id))] => (report_long_error (longid,"VAR"); VALID (Ident.VAR id))
d1756 1
a1756 1
 fn [valid as VALID id] => (check_non_valid_op id; valid)
d1761 1
a1761 1
 fn [_,valid as VALID id] => (check_valid_op id; valid)
d1767 2
a1768 2
 fn [LONGID (id as ([],_))] => VALID (getValId id)
|[LONGID (longid as (_,id))] => (report_long_error (longid,"VAR"); VALID (Ident.VAR id))
d1773 2
a1774 2
 fn [LONGID ([],s)] => VALID (Ident.CON s)
|[LONGID (id as (p,s))] => (report_long_error (id,"CON"); VALID (Ident.CON s))
d1779 1
a1779 1
 fn [valid as (VALID con)] => (check_non_valid_op con; valid)
d1784 1
a1784 1
 fn [_,valid as (VALID con)] => (check_valid_op con; valid)
d1789 2
a1790 2
 fn [LONGID ([],s)] => VALID (Ident.EXCON s)
|[LONGID (id as (p,s))] => (report_long_error (id,"EXCON"); VALID (Ident.EXCON s))
d1795 1
a1795 1
 fn [valid as (VALID excon)] => (check_non_valid_op excon; valid)
d1800 1
a1800 1
 fn [_,valid as (VALID excon)] => (check_valid_op excon; valid)
d1805 2
a1806 2
 fn [LONGID ([],s)] => TYCON (mkTyCon s)
|[LONGID (id as (l,s))] => (report_long_error (id,"TYCON"); TYCON (mkTyCon s))
d1811 1
a1811 1
 fn [LONGID ([],s)] => DUMMY (* should check its an asterisk *)
d1818 1
a1818 1
 fn [ENV pE,STRDEC (x,e),_] => (set_pE pE;STREXP (Absyn.NEWstrexp x,e))
d1823 1
a1823 1
 fn [LONGID x] => STREXP (Absyn.OLDstrexp (mkLongStrId x,current_marks()),lookupStrId x)
d1828 2
a1829 2
 fn [FUNID funid,_,STREXP(strexp,_),_] => 
   STREXP (Absyn.APPstrexp (funid,strexp,current_marks()),lookupFunId funid)
d1834 2
a1835 2
 fn [FUNID funid,_,STRDEC(strdec,e),_] => 
   STREXP (Absyn.APPstrexp (funid,Derived.make_strexp strdec,current_marks()),lookupFunId funid)
d1840 1
a1840 1
 fn [ENV pE,STRDEC(strdec,e),_,STREXP(strexp,e'),_] => 
d1846 1
a1846 1
 fn [_] => ENV (get_current_pE())
d1851 1
a1851 1
 fn [_] => STRDEC (Absyn.SEQUENCEstrdec[],PE.empty_pE)
d1856 1
a1856 1
 fn [_,strdec,_] => strdec
d1861 1
a1861 1
 fn [_,STRDECLIST(l,pE),_] => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1866 1
a1866 1
 fn [STRDEC(strdec1,pE1),_,STRDEC(strdec2,pE2)] => STRDECLIST([strdec2,strdec1],PE.augment_pE(pE1,pE2))
d1871 1
a1871 1
 fn [STRDECLIST(l,pE1),_,STRDEC(strdec,pE2)] => STRDECLIST(strdec::l,PE.augment_pE(pE1,pE2))
d1878 1
a1878 1
 fn [STRDEC (x,pE)] => STRDEC(Absyn.SEQUENCEstrdec[x],pE)
d1883 1
a1883 1
 fn [STRDECLIST(l,pE)] => STRDEC(Absyn.SEQUENCEstrdec(rev l),pE)
d1888 1
a1888 1
 fn [STRDEC(strdec1,pE1),STRDEC(strdec2,pE2)] => 
d1894 1
a1894 1
 fn [STRDECLIST(l,pE1),STRDEC(strdec,pE2)] => 
d1902 1
a1902 1
 fn [DEC(dec,pE,tyvars)] => STRDEC(Absyn.DECstrdec dec,pE) (* ignore tyvars *)
d1907 1
a1907 1
 fn [_,STRBIND(l,pSE)] => 
d1913 1
a1913 1
 fn [ENV pE,STRDEC(strdec1,_),_,STRDEC(strdec2,pE'),_] => 
d1919 1
a1919 1
 fn [STRBIND1 (d,id_pE)] => STRBIND([d],make_pSE id_pE)
d1924 2
a1925 2
 fn [STRBIND(l,pSE),_,STRBIND1(d,id_pE)] =>
    STRBIND(d::l,addNewStrId(id_pE,pSE))
d1930 2
a1931 2
 fn [STRID id,_,SIGEXP(sigexp,pE1),_,STREXP(strexp,pE2)] => 
   STRBIND1((id,Absyn.PRESENT sigexp,strexp,current_marks()),(id,pE1))
d1936 2
a1937 2
 fn [STRID id,_,STREXP(strexp,pE)] => 
   STRBIND1((id,Absyn.ABSENT,strexp,current_marks()),(id,pE))
d1942 1
a1942 1
 fn [ENV pE,SPEC (spec,e),_] => 
d1948 1
a1948 1
 fn [SIGID id] => SIGEXP(Absyn.OLDsigexp(id,ref Interface.emptyInt,current_marks()),lookupSigId id)
d1953 1
a1953 1
 fn [_] => let val pE = get_current_pE() in set_pE PE.empty_pE; ENV pE end
d1958 1
a1958 1
 fn [SIGBIND(sigb,pG)] => SIGDEC([Absyn.SIGBIND sigb],pG)
d1963 1
a1963 1
 fn [SIGDEC(l,pG),SIGBIND(sigb,pG')] => SIGDEC((Absyn.SIGBIND sigb)::l,PE.augment_pG(pG,pG'))
d1968 1
a1968 1
 fn [_,x as SIGBIND(_,pG)] => (extend_pG pG;x)
d1973 1
a1973 1
 fn [SIGID id,_,SIGEXP(sigexp,e)] => SIGBIND([(id,sigexp,current_marks())],make_pG(id,e))
d1978 2
a1979 2
 fn [SIGBIND(l,pG),_,SIGID id,_,SIGEXP(sigexp,e)] => 
   SIGBIND((id,sigexp,current_marks())::l,addNewSigId((id,e),pG))
d1984 1
a1984 1
 fn [_] => SPEC(Absyn.SEQUENCEspec[],PE.empty_pE)
d1989 1
a1989 1
 fn [_,spec,_] => spec
d1994 1
a1994 1
 fn[_,SPECLIST(l,pE),_] => SPEC(Absyn.SEQUENCEspec(rev l),pE)
d1999 1
a1999 1
 fn[SPEC(spec1,pE1),_,SPEC(spec2,pE2)] => 
d2005 1
a2005 1
 fn[SPECLIST(l,pE1),_,SPEC(spec,pE2)] => 
d2013 1
a2013 1
 fn [_,VALDESC (l,pVE)] => SPEC(Absyn.VALspec (rev l),pVE_in_pE pVE)
d2018 1
a2018 1
 fn [_,TYPDESC t] => SPEC(Absyn.TYPEspec (rev t),PE.empty_pE)
d2023 1
a2023 1
 fn [_,TYPDESC t] => SPEC(Absyn.EQTYPEspec (rev t),PE.empty_pE)
d2028 1
a2028 1
 fn [_,DATDESC(l,pVE)] => (extend_pVE pVE;SPEC(Absyn.DATATYPEspec (rev l),pVE_in_pE pVE))
d2033 1
a2033 1
 fn [_,EXDESC(l,pVE)] => (extend_pVE pVE;SPEC(Absyn.EXCEPTIONspec (rev l),pVE_in_pE(pVE)))
d2038 1
a2038 1
 fn [_,STRDESC(l,pSE)] => (extend_pSE pSE;SPEC(Absyn.STRUCTUREspec (rev l),pSE_in_pE pSE))
d2043 1
a2043 1
 fn [_,SHAREQ l] => SPEC(Absyn.SHARINGspec (rev l),PE.empty_pE)
d2048 1
a2048 1
 fn [ENV pE,SPEC(spec1,pE1),_,SPEC(spec2,pE2),_] => 
d2054 1
a2054 1
 fn [_,LONGIDLIST l] => do_open_spec_action (rev l)
d2059 1
a2059 1
 fn [_,SIGIDLIST l] => do_include_action (rev l)
d2064 1
a2064 1
 fn [SIGID sigid] => SIGIDLIST [sigid]
d2069 1
a2069 1
 fn [SIGIDLIST l,SIGID sigid] => SIGIDLIST(sigid::l)
d2074 1
a2074 1
 fn [VALID v,_,TY (ty,tyvars)] => VALDESC([(v,ty,tyvars)], make_pVE v)
d2079 2
a2080 2
 fn [VALDESC(l,pVE),_,VALID v,_,TY (ty,tyvars)] => 
   VALDESC((v,ty,tyvars)::l,addNewValId(v,pVE))
d2085 1
a2085 1
 fn [TYPDESC1 x] => TYPDESC[x]
d2090 2
a2091 2
 fn [TYPDESC l,_,TYPDESC1 t] => 
   (check_disjoint_typdesc(t,l); TYPDESC (t::l))
d2096 1
a2096 1
 fn [TYVARLIST tyvarlist,TYCON tycon] => TYPDESC1(rev tyvarlist,tycon)
d2102 1
a2102 1
 fn [DATDESC1(d,pVE)] => DATDESC([d],pVE)
d2107 2
a2108 2
 fn [DATDESC(l,pVE),_,DATDESC1(d,pVE')] =>
   (check_disjoint_datdesc(d,l); DATDESC(d::l,merge_pVEs(pVE,pVE')))
d2113 2
a2114 2
 fn [TYVARLIST tyvarlist,TYCON tycon,_,CONDESC (l,pVE,tyvars)] =>
   (check_tyvar_inclusion(tyvars,tyvarlist);
d2120 1
a2120 1
 fn [x] => x
d2125 2
a2126 2
 fn [CONDESC (l,e,tyvars),_,CONDESC ([x],e',tyvars')] => 
   CONDESC(x::l,merge_pVEs(e,e'),Set.union(tyvars,tyvars'))
d2131 1
a2131 1
 fn [VALID con,TY(ty,tyvars)] => 
d2133 1
a2133 1
|[VALID con,NULLTYPE] => 
d2139 1
a2139 1
 fn [EXDESC1(excon,ty,marks)] => EXDESC([(excon,ty,marks)],make_pVE(excon))
d2144 2
a2145 2
 fn [EXDESC(l,pVE),_,EXDESC1(excon,ty,marks)] => 
   EXDESC((excon,ty,marks)::l,addNewValId(excon,pVE))
d2150 4
a2153 4
 fn [VALID excon,TY(ty,_)] => 
   EXDESC1(excon,Absyn.PRESENT ty,current_marks())
|[VALID excon,NULLTYPE] => 
   EXDESC1(excon,Absyn.ABSENT,current_marks())
d2158 1
a2158 1
 fn [STRDESC1(strid,e,pE)] => STRDESC([(strid,e)],make_pSE(strid,pE))
d2163 2
a2164 2
 fn [STRDESC(l,pSE),_,STRDESC1(strid,e,pE)] => 
   STRDESC((strid,e)::l,addNewStrId((strid,pE),pSE))
d2169 1
a2169 1
 fn [STRID strid,_,SIGEXP(e,pE)] => STRDESC1(strid,e,pE)
d2174 1
a2174 1
 fn [x] => x
d2179 1
a2179 1
 fn [SHAREQ l,_,SHAREQ [x]] => SHAREQ(x::l)
d2184 1
a2184 1
 fn [LONGSTRIDLIST l] => SHAREQ[(Absyn.STRUCTUREshareq (rev l),current_marks())]
d2189 1
a2189 1
 fn [_, LONGTYCONLIST l] => SHAREQ[(Absyn.TYPEshareq (rev l),current_marks())]
d2194 1
a2194 1
 fn [LONGSTRID id,_,LONGSTRID id'] => LONGSTRIDLIST[id',id]
d2199 1
a2199 1
 fn [LONGSTRIDLIST l,_,LONGSTRID id] => LONGSTRIDLIST(id::l)
d2204 1
a2204 1
 fn [LONGTYCON tycon,_,LONGTYCON tycon'] => LONGTYCONLIST[tycon',tycon]
d2209 1
a2209 1
 fn [LONGTYCONLIST l,_,LONGTYCON tycon] => LONGTYCONLIST(tycon::l)
d2214 1
a2214 1
 fn [FUNBIND(fbind,pF)] => FUNDEC([Absyn.FUNBIND fbind],pF)
d2219 1
a2219 1
 fn [FUNDEC(l,pF),FUNBIND(fbind,pF')] => FUNDEC((Absyn.FUNBIND fbind)::l,PE.augment_pF(pF,pF'))
d2224 1
a2224 1
 fn [_,fbind as FUNBIND(f,pF)] => (extend_pF pF; fbind)
d2229 1
a2229 1
 fn [FUNBIND1(fbind,funid,pE)] =>
d2235 2
a2236 2
 fn [FUNBIND(l,pF),_,FUNBIND1(fbind,funid,pE)] =>
 FUNBIND (fbind::l,addNewFunId((funid,pE),pF))
d2241 2
a2242 2
 fn [STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,SIGEXP(sigexp',pE''),_,STREXP(strexp,pE''')] =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.PRESENT sigexp',make_funbind_info funid,current_marks()),funid,pE''))
d2247 2
a2248 2
 fn [STARTFUNBIND1(funid,pE,strid,sigexp,pE'),_,STREXP(strexp,pE''')] =>
 (set_pE pE;FUNBIND1((funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp,Absyn.ABSENT,make_funbind_info funid,current_marks()),funid,pE'''))
d2253 2
a2254 2
 fn [STARTFUNBIND2(funid,pE,spec,pE'),_,SIGEXP(sigexp,pE''),_,STREXP(strexp,pE''')] =>
 (set_pE pE;do_derived_funbind (funid,spec,Absyn.PRESENT sigexp,strexp,pE''))
d2259 2
a2260 2
 fn [STARTFUNBIND2(funid,pE,spec,pE'),_,STREXP(strexp,pE''')] =>
 (set_pE pE;do_derived_funbind (funid,spec,Absyn.ABSENT,strexp,pE'''))
d2265 1
a2265 1
 fn [FUNIDBIND (funid,pE),_,STRID strid,_,SIGEXP(sigexp,pE'),_] =>
d2271 1
a2271 1
 fn [FUNIDBIND (funid,pE),_,SPEC(spec,pE'),_] => 
d2277 1
a2277 1
 fn [FUNID funid] => FUNIDBIND(funid,get_current_pE())
d2282 1
a2282 1
 fn [] => raise FoundTopDec (Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [],current_marks()),PE.empty_pB)
d2287 1
a2287 1
 fn [STRDEC(strdec,pE)] => raise FoundTopDec (Absyn.STRDECtopdec(strdec,current_marks()),pE_in_pB pE)
d2292 1
a2292 1
 fn [SIGDEC(l,pG)] => raise FoundTopDec (Absyn.SIGNATUREtopdec (rev l),pG_in_pB pG)
d2297 1
a2297 1
 fn [FUNDEC(l,pF)] => raise FoundTopDec (Absyn.FUNCTORtopdec(rev l,current_marks()),pF_in_pB pF)
d2302 1
a2302 1
 fn [EXP(exp,tyvars)] => raise FoundTopDec (make_it_strdec(exp,tyvars,current_marks()),PE.empty_pB)
d2307 1
a2307 1
 fn [_,STRING s] => raise FoundTopDec (Absyn.REQUIREtopdec (s, current_marks()),PE.empty_pB)
d2312 1
a2312 1
 fn [x,_] => x
d2317 1
a2317 1
 fn [x] => x
@


1.4
log
@Tynames now have a slot recording their definition point
@
text
@d2316 1
a2316 1
 fn [_,STRING s] => raise FoundTopDec (Absyn.REQUIREtopdec s,PE.empty_pB)
@


1.3
log
@ Added locations to some absyn types.
@
text
@d1067 1
a1067 1
   (extend_pVE pVE; DEC (Absyn.DATATYPEdec (rev d),pVE_in_pE pVE,Set.empty_set))
d1075 1
a1075 1
    DEC (Derived.make_datatype_withtype (rev d, t),pVE_in_pE pVE,Set.empty_set))
d1081 1
a1081 1
   (extend_pVE pVE; DEC (Absyn.ABSTYPEdec (rev d,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
d1089 1
a1089 1
    DEC (Derived.make_abstype_withtype (rev d,t,dec),PE.augment_pE (pVE_in_pE pVE,pE),tyvars))
@


1.2
log
@Installed central error reporting mechanism.
@
text
@d689 1
a689 1
     SPEC(Absyn.OPENspec valids,new_pE))
d698 1
a698 1
     SPEC(Absyn.INCLUDEspec sigids,new_pE))
d719 2
a720 1
                       Ident.VAR (Symbol.find_symbol "it")))),
d1365 1
a1365 1
   PAT (Absyn.VALpat (annotate (make_long_id id)),make_pVE id,Set.empty_set)
d1372 1
a1372 1
    PAT (Absyn.VALpat (annotate id),PE.empty_pVE,Set.empty_set))
d1410 1
a1410 1
 fn [_,_] => PAT (Derived.make_list_pat [],PE.empty_pVE,Set.empty_set)
d1415 1
a1415 1
 fn [_,PAT(l,pVE,tyvars),_] => PAT (Derived.make_list_pat [l],pVE,tyvars)
d1425 1
a1425 1
 fn [_,PATLIST (l,pVE,tyvars),_] => PAT (Derived.make_list_pat (rev l),pVE,tyvars)
d1438 1
a1438 1
    PAT (Absyn.APPpat (annotate (make_long_id id), Derived.make_tuple_pat[pat1,pat2]),pVE,tyvars))
d1479 1
a1479 1
    PATROW1 ((Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.ABSENT)),make_Sym_pVE sym,tyvars))
d1482 1
a1482 1
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.ABSENT),make_Sym_pVE sym,Set.empty_set))
d1489 1
a1489 1
    PATROW1 (Derived.make_patrow (sym, Absyn.PRESENT ty, Absyn.PRESENT pat),addNewSymId(sym,pVE),Set.union (tyvars1,tyvars2)))
d1492 1
a1492 1
    PATROW1 (Derived.make_patrow (sym, Absyn.ABSENT, Absyn.PRESENT pat),addNewSymId(sym,pVE),tyvars))
d1503 1
a1503 1
   (check_is_constructor id; PAT (Absyn.APPpat (annotate id, pat),pVE,tyvars))
d1510 1
a1510 1
    PAT(Absyn.APPpat(annotate id, Derived.make_tuple_pat[pat1,pat2]),merge_pVEs(pVE1,pVE2),Set.union(tyvars1,tyvars2)))
d1515 1
a1515 1
 fn [PAT (pat,pVE,tyvars1),_,TY (ty,tyvars2)] => PAT (Absyn.TYPEDpat(pat,ty),pVE,Set.union(tyvars1,tyvars2))
d1521 1
a1521 1
   PAT (Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate id, pat), ty),addNewValId(id,pVE),Set.union(tyvars1,tyvars2))
d1545 1
a1545 1
 fn [TYLIST (s,tvs), LONGTYCON c] => TY (Absyn.APPty (rev s,c),tvs)
d1550 1
a1550 1
 fn [TY (t,tvs), LONGTYCON c] => TY (Absyn.APPty ([t],c),tvs)
d1555 1
a1555 1
 fn [LONGTYCON c] => TY (Absyn.APPty ([],c),Set.empty_set)
d1832 1
a1832 1
 fn [LONGID x] => STREXP (Absyn.OLDstrexp (mkLongStrId x),lookupStrId x)
d1957 1
a1957 1
 fn [SIGID id] => SIGEXP(Absyn.OLDsigexp(id,ref Interface.emptyInt),lookupSigId id)
@


1.1
log
@Initial revision
@
text
@d17 1
a18 1
require "parsing-errors";
a21 1
                         structure ParsingErrors : PARSINGERRORS
d36 1
d46 2
a47 3
                         sharing type Absyn.Source_marks = ParsingErrors.Marks
                         sharing type Ident.Symbol.Symbol = Symbol.Symbol
                           ) : ACTIONFUNCTIONS =
d56 1
d59 1
a60 1

a62 1
type Marks = Absyn.Source_marks
d69 1
a69 1
  type PatExpMark = Absyn.Pat * Absyn.Exp * Absyn.Source_marks
d76 2
a77 2
  type ExType = Ident.ValId * Absyn.Ty Absyn.opt * Absyn.Source_marks
  type FunBind = (Ident.FunId * Ident.StrId * Absyn.SigExp * Nameset.Nameset ref * Absyn.StrExp * Absyn.SigExp Absyn.opt * string * Absyn.Source_marks)
d123 2
a124 2
  | SHAREQ of (Absyn.SharEq * Absyn.Source_marks) list
  | SIGBIND of (Ident.SigId * Absyn.SigExp * Absyn.Source_marks) list * PE.pG
d142 2
a143 2
  | STRBIND of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Absyn.Source_marks) list * PE.pSE)
  | STRBIND1 of ((Ident.StrId * Absyn.SigExp Absyn.opt * Absyn.StrExp * Absyn.Source_marks) * (Ident.StrId * PE.pE))
d155 1
a155 1
  | EXPSEQ of (Absyn.Exp * string * Absyn.Source_marks) list * TyVarSet
d174 1
a174 1
  | FVALBIND of ((FVal list * (string -> string) * Absyn.Source_marks) list * TyVarSet) * PE.pVE
d180 1
a180 1
  | MARKS of Absyn.Source_marks
d185 1
a185 3
(* marks *)

val current_marks_ref = ref Absyn.dummy_marks
d187 1
a187 1
val dummy_marks = Absyn.dummy_marks
d189 1
a189 1
fun current_marks() = ! current_marks_ref
d191 1
a191 1
val report_error = ParsingErrors.report_error
a194 17
fun linenum_as_string () =
  let
    val (a,b) = Absyn.Source_marks_to_tuple (!current_marks_ref)
  in
    Integer.makestring a ^"," ^ Integer.makestring b
  end

fun filename() = 
  Lexer.associated_filename (!tokenstream_ref)
 
fun generate_source_file_info () =
  let
    val linenum = linenum_as_string()
  in
    fn name => name ^ " " ^ filename() ^ ":" ^ linenum
  end

d196 18
a213 18
fun make_hash_info (Ident.LAB sym) =
  generate_source_file_info()("#" ^ Symbol.symbol_name sym ^ " ")
  
fun make_seq_info () =
  generate_source_file_info () "part of sequence"

fun make_and_info () = generate_source_file_info () "andalso expression"
fun make_orelse_info () = generate_source_file_info () "orelse expression"
fun make_handle_info () = generate_source_file_info () "handle expression"
fun make_if_info () = generate_source_file_info () "if expression"
fun make_case_info () = generate_source_file_info () "case expression"
fun make_fn_info () = generate_source_file_info () "anonymous function"
fun make_exbind_info (Ident.EXCON sym) =
  generate_source_file_info()(Symbol.symbol_name sym)
  | make_exbind_info _ = Crash.impossible"Not an excon in an exbind"

fun make_funbind_info (Ident.FUNID sym) =
  generate_source_file_info()("Functor " ^ Symbol.symbol_name sym)
a214 5
(* these should be functions *)
fun make_while_info () = generate_source_file_info()

fun make_fval_info () = generate_source_file_info()

d217 2
a218 4
  report_error (message,current_marks(),ParsingErrors.SERIOUS)
    
fun simple_error (message) =
  report_error (message,current_marks(),ParsingErrors.SIMPLE)
d221 2
a222 1
  report_error (message,current_marks(),ParsingErrors.WARNING)
d258 5
a262 3
  (if sym = asterisk_symbol
     then error "Asterisk not allowed as type constructor"
   else ();
d280 5
a284 3
  (if sym = asterisk_symbol
     then error "ASTERISK not allowed as a TyCon"
    else ();
d303 4
a306 3
  if is_long_constructor id
    then ()
  else error ("Non-constructor " ^ (IdentPrint.printLongValId id) ^ " used in pattern")
d309 4
a312 3
  if is_constructor id
    then ()
  else error ("Non-constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
d315 4
a318 3
  if is_constructor id
    then error ("Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
  else ()
d321 4
a324 3
  if is_constructor id
    then error ("Constructor " ^ (IdentPrint.printValId id) ^ " used in pattern")
  else ()
d336 4
a339 3
          if not_posint
            then error "Integer label must be positive"
          else ()
d537 1
a537 1
  | check_rec_bindings((pat,exp,marks)::l) =
d632 5
a636 3
    if is_needed (p, get_sym v)
      then ()
    else warn ("Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d639 4
a642 3
    if is_needed (p, get_sym v)
      then warn("Need an op for " ^ Symbol.symbol_name(get_sym v))
    else ()
d646 5
a650 3
  if is_infix (get_sym v)
    then ()
  else warn("Unnecessary op for " ^ Symbol.symbol_name(get_sym v))
d653 4
a656 3
  if is_infix (get_sym v)
    then warn("Need an op for " ^ Symbol.symbol_name(get_sym v))
  else ()
d712 1
a712 1
fun make_it_strdec (e,tyvars,marks) =
d721 1
a721 1
                    marks)],
@
