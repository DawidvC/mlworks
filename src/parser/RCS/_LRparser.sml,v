head	1.26;
access;
symbols
	MLW_daveb_inline_1_4_99:1.26.1
	MLWorks_21c0_1999_03_25:1.26
	MLWorks_20c1_1998_08_20:1.25
	MLWorks_20c0_1998_08_04:1.25
	MLWorks_20b2c2_1998_06_19:1.25
	MLWorks_20b2_Windows_1998_06_12:1.25
	MLWorks_20b1c1_1998_05_07:1.25
	MLWorks_20b0_1998_04_07:1.25
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_20m1_1997_10_23:1.24
	MLWorks_11r1:1.24.5.1.1.1.1
	MLWorks_workspace_97:1.24.7
	MLWorks_dt_wizard:1.24.6
	MLWorks_11c0_1997_09_09:1.24.5.1.1.1
	MLWorks_10r3:1.24.5.1.3
	MLWorks_10r2_551:1.24.5.1.2
	MLWorks_11:1.24.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.24.5.1
	MLWorks_20m0_1997_06_20:1.24
	MLWorks_1_0_r2c2_1997_06_14:1.24.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.24.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.24.5
	MLWorks_BugFix_1997_04_24:1.24
	MLWorks_1_0_r2_Win32_1997_04_11:1.24
	MLWorks_1_0_r2_Unix_1997_04_04:1.24
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.24.3.1.1
	MLWorks_gui_1996_12_18:1.24.4
	MLWorks_1_0_Win32_1996_12_17:1.24.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.24.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.24.1.1
	MLWorks_1_0_Irix_1996_11_28:1.24.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.24.2
	MLWorks_1_0_Unix_1996_11_14:1.24.1
	MLWorks_Open_Beta2_1996_10_11:1.22.3
	MLWorks_License_dev:1.22.2
	MLWorks_1_open_beta_1996_09_13:1.22.1
	MLWorks_Open_Beta_1996_08_22:1.22
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22
	ML_beta_release_12/08/94:1.15
	ML_beta_release_03/08/94:1.15
	ML_revised_beta_release_25/05/94:1.15
	ML_final_beta_release_02/03/94:1.15
	mlworks-28-01-1994:1.14
	Release:1.13
	mlworks-beta-01-09-1993:1.13
	MLWorks-1-0-4-29/01/1993:1.5
	MLWorks-1-0-3-21/12/1992:1.4
	MLWorks-1-0-2-15/12/1992:1.4
	MLWorks-1-0-1-04/12/1992:1.4;
locks; strict;
comment	@ * @;


1.26
date	99.02.02.16.01.25;	author mitchell;	state Exp;
branches
	1.26.1.1;
next	1.25;

1.25
date	98.02.05.16.03.42;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.11.06.10.56.22;	author matthew;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1
	1.24.4.1
	1.24.5.1
	1.24.6.1
	1.24.7.1;
next	1.23;

1.23
date	96.10.30.19.11.35;	author io;	state Exp;
branches;
next	1.22;

1.22
date	96.04.30.17.39.57;	author jont;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1;
next	1.21;

1.21
date	96.04.29.13.35.43;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.07.27.09.44.47;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	95.03.15.12.03.47;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.02.08.17.15.10;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	94.09.15.10.00.55;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.08.31.10.45.30;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	94.02.02.12.32.29;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.11.23.13.53.40;	author nickh;	state Exp;
branches;
next	1.13;

1.13
date	93.06.10.10.41.05;	author matthew;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	93.05.27.17.00.29;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.05.18.18.01.25;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	93.05.17.12.15.48;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	93.05.14.17.26.14;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	93.03.19.12.13.58;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.03.10.14.54.20;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.04.09.54.03;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.01.14.17.42.58;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.11.05.16.53.05;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	92.10.07.14.16.12;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	92.09.04.09.20.08;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.08.26.09.56.33;	author matthew;	state Exp;
branches;
next	;

1.13.1.1
date	93.06.10.10.41.05;	author jont;	state Exp;
branches;
next	;

1.22.1.1
date	96.09.13.11.20.25;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.10.07.16.10.20;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.10.17.11.28.50;	author hope;	state Exp;
branches;
next	;

1.24.1.1
date	96.11.14.12.54.31;	author hope;	state Exp;
branches
	1.24.1.1.1.1;
next	;

1.24.1.1.1.1
date	96.11.28.15.05.21;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.11.22.18.13.11;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.12.17.17.51.39;	author hope;	state Exp;
branches
	1.24.3.1.1.1;
next	;

1.24.3.1.1.1
date	97.02.24.11.42.16;	author hope;	state Exp;
branches;
next	;

1.24.4.1
date	96.12.18.09.45.58;	author hope;	state Exp;
branches;
next	;

1.24.5.1
date	97.05.12.10.38.27;	author hope;	state Exp;
branches
	1.24.5.1.1.1
	1.24.5.1.2.1
	1.24.5.1.3.1;
next	;

1.24.5.1.1.1
date	97.07.28.18.23.27;	author daveb;	state Exp;
branches
	1.24.5.1.1.1.1.1;
next	;

1.24.5.1.1.1.1.1
date	97.10.07.11.49.11;	author jkbrook;	state Exp;
branches;
next	;

1.24.5.1.2.1
date	97.09.08.17.16.52;	author daveb;	state Exp;
branches;
next	;

1.24.5.1.3.1
date	97.09.09.14.12.57;	author daveb;	state Exp;
branches;
next	;

1.24.6.1
date	97.09.10.19.29.00;	author brucem;	state Exp;
branches;
next	;

1.24.7.1
date	97.09.11.20.58.54;	author daveb;	state Exp;
branches;
next	;

1.26.1.1
date	99.04.01.17.59.23;	author daveb;	state Exp;
branches;
next	;


desc
@LR parser, the functor
@


1.26
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _LRparser.sml the functor *)
(*
$Log: _LRparser.sml,v $
 * Revision 1.25  1998/02/05  16:03:42  jont
 * [Bug #30090]
 * Remove MLWorks.IO.output in favour of print
 *
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.23  1996/10/30  19:11:35  io
 * moving String from toplevel
 *
 * Revision 1.22  1996/04/30  17:39:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.21  1996/04/29  13:35:43  matthew
 * Adding basis Integer
 *
 * Revision 1.20  1995/07/27  09:44:47  jont
 * Mark CHAR and WORD as not shiftable
 *
Revision 1.19  1995/03/15  12:03:47  matthew
Some efficiency improvements.
\n
\nAttempt at improvement to location in unexpected token message.

Revision 1.17  1994/09/15  10:00:55  matthew
Improved error reporting
Stop inserting equality all over the place

Revision 1.16  1994/08/31  10:45:30  matthew
Minor speedups

Revision 1.15  1994/02/02  12:32:29  daveb
Added qute marks around symbols in messages.

Revision 1.14  1993/11/23  13:53:40  nickh
Make WHILE non-shiftable (it was being substituted for VAL).

Revision 1.13  1993/06/10  10:41:05  matthew
Extended grammar for NJ compatibility

Revision 1.12  1993/05/27  17:00:29  matthew
Made WITHTYPE and ABSTRACTION unshiftable

Revision 1.11  1993/05/18  18:01:25  jont
Removed integer parameter

Revision 1.10  1993/05/17  12:15:48  jont
Modified to allow options to determine association of two different equal
precedence right associative operators

Revision 1.9  1993/05/14  17:26:14  jont
Added New Jersey interpretation of weak type variables under option control

Revision 1.8  1993/03/19  12:13:58  matthew
Added is_initial_state function

Revision 1.7  1993/03/10  14:54:20  matthew
Signature revisions

Revision 1.6  1993/03/04  09:54:03  matthew
Options & Info changes

Revision 1.5  1993/01/14  17:42:58  jont
Added range combination on reduction rules

Revision 1.4  1992/11/05  16:53:05  matthew
Changed Error structure to Info

Revision 1.3  1992/10/07  14:16:12  matthew
Added functions for incremental parsing.

Revision 1.2  1992/09/04  09:20:08  richard
Installed central error reporting mechanism.

Revision 1.1  1992/08/26  09:56:33  matthew
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../basis/__int";
require "^.basis.__list";

require "../utils/crash";
require "../utils/lists";
require "LRbasics";
require "LRparser";
require "actionfunctions";

functor LRparser (structure LRbasics : LRBASICS
                  structure ActionFunctions : ACTIONFUNCTIONS
                  structure Lists: LISTS
                  structure Crash : CRASH
                  sharing LRbasics = ActionFunctions.LRbasics
                    ) : LRPARSER =
struct

structure ActionFunctions = ActionFunctions
structure Info = ActionFunctions.Info
structure Location = Info.Location
structure Options = ActionFunctions.Options
structure Token = ActionFunctions.Token

type Parsed_Object = ActionFunctions.Parsed_Object
type TokenType = ActionFunctions.Token.Token
type FinalType = Parsed_Object

val dummy = ActionFunctions.dummy

fun value_for_sym (LRbasics.LONGID) =
  ActionFunctions.error_id_value
  | value_for_sym _ = ActionFunctions.dummy

val print_token = ActionFunctions.print_token

(* next type represents a buffered thingy, that can have things pushed back
   onto it *)

val do_debug = false

type 'item lex_buffer = (unit -> 'item) * 'item list ref

fun mk_lexbuff function = (function,ref [])

fun get_next (next_fn,ref []) = next_fn()
  | get_next (next_fn,r as ref (a::l)) = (r := l; a)


fun push_item (item, (_, r as ref l)) = r := (item::l)

fun peek_next lexbuff =
  let val a = get_next lexbuff
  in
    push_item(a,lexbuff);
    a
  end

(* a parse is found and returned *)
exception Foundit of Parsed_Object

type stack = (int * Parsed_Object * Location.T) list

(* utilities *)

fun concat [] = []
  | concat ([] :: x) = concat x
  | concat ((x :: y) :: z) = x :: (concat (y :: z))

fun popn (0,s) = s
  | popn (n, x :: s) = popn (n - 1, s)
  | popn _ = Crash.impossible "Rubbish stack in parser (popn)"

fun getn (0, x, acc) = acc
  | getn (n, (_,a,_) :: b, acc) = getn (n-1, b, a :: acc)
  | getn _ = Crash.impossible "Rubbish stack in parser (getn)"

(* Combination of getn, get_nth_location and popn *)
fun get_stack_bits (0,rest,end_location,args) = (end_location,rest,args)
  | get_stack_bits (n,(_,arg,end_location)::rest,_,args) =
    get_stack_bits (n-1,rest,end_location,arg::args)
  | get_stack_bits (_,[],_,_) = Crash.impossible "Rubbish stack in parser (get_stack_bits)"

(* yer actual function *)

(* sym is input symbol
 value is the lexed value
 stacks are the list of parsing stacks
 lexer is the lexing function
 *)

fun top_state ((s,_,_) :: _) = s
  | top_state _ = Crash.impossible"Empty stack in run_parser"

(* return a list of possible outcome states given a stack and a symbol *)

fun append_list [] = []
  | append_list (l::ll) = l @@ (append_list ll)

fun remove_duplicates l =
  let
    fun aux ([],acc) = acc
      | aux (a::l,acc) = if Lists.member(a,l) then aux (l,acc) else aux (l, a::acc)
  in
    aux (rev l,[])
  end

fun call_resolution_fn (action1,action2,function,options, n,stack,value) =
  let
    val args = getn (n, stack, [])
  in
    (ActionFunctions.get_resolution(function, options)) (action1,action2,args,value)
  end

fun get_any_reduction state =
  let
    fun find [] = NONE
      | find (action::rest) =
        case action of
          LRbasics.Reduce _ => SOME action
        | _ => find rest
  in
    find (LRbasics.get_all_actions state)
  end
      
fun dummy_apply options (stk as (state,_,_)::_,sym,value,location) =
  let
    val _ = if do_debug 
              then print ("Dummy apply - state=" ^ 
                          Int.toString state ^
                          " symbol=" ^ print_token (sym,value) ^ "\n") 
            else ()
    fun dummy_apply_action (stk as (state,_,current_location)::_,action,sym,value,location) =
      (case action of 
         LRbasics.Accept => [stk]
       | LRbasics.Shift =>
           (* This should attempt to do some reductions next *)
           (* We have just managed to shift the new symbol, so lets see what we can reduce it with *)
           (let 
             val next_state = LRbasics.get_next_state(sym,state)
             val _ =  if do_debug then print ("Shifting " ^ print_token (sym,value) ^ "\n") else ();
             val new_stack = (next_state,dummy,location)::stk
           in 
             (* This doesn't work terribly well -- really need to apply reductions until a
              "significant" (>1 grammar symbols) is found *)
             (*
              case get_any_reduction next_state of
                SOME (LRbasics.Reduce (n,nonT,f)) =>
                  let
                    val (end_location,new_stack,args) =
                      if n = 0 
                        then (location,new_stack,[])
                      else get_stack_bits (n,new_stack,location,[])
                    val new_state = LRbasics.get_next_state (nonT,next_state)
                    val new_location = Location.combine (end_location,location)
                  in
                    [(new_state,dummy,new_location)::new_stack]
                  end
                _ => [new_stack]
                  *)
             [new_stack]
           end)
       | LRbasics.Reduce(n,nonT,f) =>
           (let
             (* args is ignored here *)
             val (end_location,new_stack,args) =
               if n = 0 
                 then (current_location,stk,[])
               else get_stack_bits (n,stk,current_location,[])
             val new_state = LRbasics.get_next_state (nonT,top_state new_stack)
             val new_location = Location.combine (end_location,current_location)
           in
              dummy_apply options ((new_state,dummy,new_location)::new_stack,sym,value,location)
           end)
       | LRbasics.Resolve actions =>
           append_list (map (fn action => dummy_apply_action (stk,action,sym,value,location)) actions)
       | LRbasics.Funcall (function,n,act1,act2) =>
           (dummy_apply_action(stk,call_resolution_fn
                               (act1,act2,function, options, n,stk,value),sym,value,location)
            handle ActionFunctions.ResolveError _ => 
              dummy_apply_action(stk,act1,sym,value,location))
       | LRbasics.NoAction => [])
      | dummy_apply_action _ = Crash.impossible "Bad arg to dummy_apply_action"
  in
    dummy_apply_action (stk,LRbasics.get_action(sym,state),sym,value,location)
  end
  | dummy_apply _ _ = Crash.impossible "Bad arg to dummy_apply"

fun dummy_stklist_apply options (stklist,sym,value,location) =
  append_list (map (fn stk => dummy_apply options (stk,sym,value,location)) stklist)

fun try_one _ ([],_,_,_,acc) = acc
  | try_one options ((sym',stklist)::l,sym,value,location,acc) =
    (case dummy_stklist_apply options (stklist,sym,value,location) of
       (((_,_,location)::_)::_) => try_one options (l,sym,value,location,(sym',location)::acc)
     | _ => try_one options (l,sym,value,location,acc))

fun is_shiftable sym =
  case sym of
    LRbasics.TYVAR => false
  (* | LRbasics.EQUAL => false *)
  | LRbasics.REAL => false
  | LRbasics.INTEGER => false
  | LRbasics.STRING => false
  | LRbasics.CHAR => false
  | LRbasics.WORD => false
  | LRbasics.EOF => false
  | LRbasics.BRA => false
  | LRbasics.LPAR => false
  | LRbasics.LBRACE => false
  | LRbasics.LOCAL => false
  | LRbasics.ABSTYPE => false
  | LRbasics.TYPE => false
  | LRbasics.EXCEPTION => false
  | LRbasics.FUN => false
  | LRbasics.DATATYPE => false
  | LRbasics.SIGNATURE => false
  | LRbasics.STRUCTURE => false
  | LRbasics.FUNCTOR => false
  | LRbasics.AND => false
  (* | LRbasics.VBAR => false *) (* What about this then? *)
  | LRbasics.OP => false
  | LRbasics.INFIX => false
  | LRbasics.INFIXR => false
  | LRbasics.NONFIX => false
  | LRbasics.OPEN => false
  | LRbasics.IN => false
  | LRbasics.HANDLE => false
  (* | LRbasics.LET => false *)
  | LRbasics.WITHTYPE => false
  | LRbasics.ABSTRACTION => false
  | LRbasics.MAGICOPEN => false
  | LRbasics.WHILE => false
  | _ => true

fun is_closing_token sym =
  case sym of
    LRbasics.RPAR => true
  | LRbasics.RBRACE => true
  | LRbasics.KET => true
  | LRbasics.END => true
  | _ => false

fun closing_token_actions [] = []
  | closing_token_actions (((sym,value,location),_)::l) =
    if is_closing_token sym
      then (sym,value,location)::(closing_token_actions l)
    else closing_token_actions l

exception ParsingStopped

fun run_parser_once opts (sym, value, location, []) = Crash.impossible "Empty stack list in parser"
  | run_parser_once (error_info,options as Options.OPTIONS{print_options,...}) (sym, value, location, stacks) =
    let
      fun call_action_fn (function,args,location) =
        (if do_debug then print ("#"^(Int.toString function)^"#") else ();
         (ActionFunctions.get_function function)
           (args,ActionFunctions.OPTS(location,error_info,options)))
      
      fun apply_action (_,[]) = []
        | apply_action (action,stack as (current_state,current_value,current_location) :: _) =
        (case action of
           LRbasics.Shift =>
             let
               val new_state = (LRbasics.get_next_state (sym,current_state))
             in
               [(new_state,value,location)::stack]
             end
         | LRbasics.Reduce (n,non_term,function) =>
             let
               val (end_location,new_stack,args) =
                 if n = 0 
                   then (current_location,stack,[])
                 else get_stack_bits (n,stack,current_location,[])
               val new_location = Location.combine (end_location,current_location)
               val result = call_action_fn (function,args,new_location)
               val new_state = LRbasics.get_next_state (non_term,(top_state new_stack))
               val new_new_stack = (new_state,result,new_location) :: new_stack
               val new_action = LRbasics.get_action (sym, new_state)
             in
               apply_action (new_action,new_new_stack)
             end
         | LRbasics.Resolve actions =>
             (if do_debug then print"Splitting.." else ();
              concat (map (fn act => (apply_action (act,stack))) actions))
         | LRbasics.Funcall (function,n,action1,action2) =>
             apply_action
	     (call_resolution_fn (action1,action2,function,options, n,stack,value),
              stack)
         | LRbasics.Accept => raise Foundit current_value
         | LRbasics.NoAction => [])
          
      fun dostacks [] = []
        | dostacks ([] :: rest) = dostacks rest
        | dostacks (stack :: rest) =
          let
            val current_state = top_state stack
            val action = LRbasics.get_action (sym, current_state)
          in
            case apply_action (action,stack) of
              [] => dostacks rest
            | new => new @@ dostacks rest
          end
    in
      dostacks stacks
    end

(* Switch this out for the moment *)
fun (* start_string (Location.EXTENT {s_line,s_col,...}) =
  " (matching: " ^ Int.toString s_line ^ "," ^ Int.toString s_col ^ ")"
  | *) start_string _ = ""

fun parse_it (options as (error_info, options' as Options.OPTIONS
			  {compat_options = Options.COMPATOPTIONS
			   {weak_type_vars, ...}, ...})) (lexer,interactivep) =
  let
    fun lex_it () =
      let
        val (token,location) = lexer ()
        val (sym,value) = ActionFunctions.token_to_parsed_object(weak_type_vars, token)
      in
        if do_debug then print ("$" ^ Token.makestring token) else ();
        (sym,value,location)
      end

    val (sym,value,location) = lex_it ()
    val lexbuff = mk_lexbuff lex_it
    val run_once = run_parser_once options

    fun restart_parser stklist =
      let val (sym,value,location) = get_next lexbuff
      in
        run_parser (sym,value,location,stklist)
      end

    and try_local_correction (stklist,sym,value,location) =
      (* None of the stacks in stklist will accept sym, need to
       try and find an action that will allow parsing to continue.
       Actions include:
       insert a symbol before the current symbol
       discard the current symbol
       replace the current symbol
       
       if the last symbol shifted has not yet been reduced so
       replace it with something that allows the current smbol
       to be shifted
       delete it completely
       insert another symbol in front of it *)

      let
        val _ = if do_debug then print ("Entering local correction, " ^ Int.toString (length stklist) ^ " stack(s)\n") else ()
        val top_states = map top_state stklist
        val possible_symbols = remove_duplicates (append_list (map LRbasics.get_possible_symbols top_states))
        val (next_symbol,next_value,next_location) = peek_next lexbuff
        val possible_continuations =
          List.filter 
          (fn (_,[]) => false | _ => true)
          (map 
           (fn sym' => 
            let
              val value = value_for_sym sym'
            in
              ((sym',value,location),
               dummy_stklist_apply options' (stklist,sym',value,location))
            end) 
           possible_symbols)
        val continuations_to_try = List.filter (is_shiftable o #1 o #1) possible_continuations
        fun report_error message  =
          Info.error
          error_info
          (Info.RECOVERABLE, location,
           "Unexpected `" ^ print_token (sym,value) ^ "', " ^ message)
      in
        (* now possible continuations are a list of symbol-stklist pairs *)
        (*  try applying possible continuations to the current symbol *)
        case try_one options' (continuations_to_try,sym,value,location,[]) of
          ((sym',value',location'),location'') :: _ => 
            (push_item ((sym,value,location),lexbuff);
             push_item ((sym',value',location'),lexbuff);
             report_error ("inserting `" ^ print_token (sym',value') ^ "'" ^ start_string location'');
             restart_parser stklist)
        | _ => 
            (case try_one options' (continuations_to_try,next_symbol,next_value,next_location,[]) of
               ((sym',value',location'),location'')::_ => 
                 (push_item ((sym',value',location'),lexbuff);
                  report_error ("replacing with `" ^ print_token (sym',value') ^ "'" ^ start_string location'');
                  restart_parser stklist)
             | _ =>
                 (case closing_token_actions(continuations_to_try) of
                    (sym',value',location')::_ =>
                      (push_item ((sym,value,location),lexbuff);
                       push_item ((sym',value',location'),lexbuff);
                       report_error ("inserting `" ^ print_token (sym',value') ^ "'");
                       restart_parser stklist)
                  | _ => (case sym of
                            LRbasics.EOF =>
                              Info.error' error_info (Info.FATAL, location, "Unexpected end of input")
                          | _ => 
                              (report_error "ignoring";
                               restart_parser stklist))))

      end

    and run_parser (args as (sym,value,location,stacks)) =
      let val newstacks = run_once args
      in
        (* check if an error was found -- this is where the error recovery will go *)
        case newstacks of
          [] =>
            if interactivep then
              Info.error' error_info (Info.FATAL, location, "Unexpected `" ^ print_token (sym,value) ^ "'")
            else
              try_local_correction(stacks,sym,value,location)
        | _ =>
            let 
              val (newsym,newval,newlocation) = get_next lexbuff
            in
              run_parser (newsym,newval,newlocation,newstacks)
            end
      end
  in
    run_parser (sym, value, location, [[(0, dummy,ActionFunctions.dummy_location)]])
    handle Foundit x => x
  end

type ParserState = stack list

val initial_parser_state = [[(0, dummy,ActionFunctions.dummy_location)]]

fun is_initial_state [[(0,_,_)]] = true
  | is_initial_state _ = false

fun error_state [] = true
  | error_state _ = false

fun parse_one_token(opts as (_, Options.OPTIONS
			     {compat_options = Options.COMPATOPTIONS
			      {weak_type_vars, ...}, ...}),token,location,state) =
  let
    val (symbol,value) = ActionFunctions.token_to_parsed_object(weak_type_vars, token)
  in
    run_parser_once opts (symbol,value,location,state)
  end
end
@


1.26.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.26  1999/02/02  16:01:25  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.25
log
@[Bug #30090]
Remove MLWorks.IO.output in favour of print
@
text
@d4 4
a92 1
require "../main/info";
@


1.24
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
a174 2
fun print s = MLWorks.IO.output(MLWorks.IO.std_out,s);

d367 1
a367 1
             (if do_debug then MLWorks.IO.output(MLWorks.IO.std_out,"Splitting..") else ();
@


1.24.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.5.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.24.5.1  1997/05/12  10:38:27  hope
 * branched from 1.24
 *
@


1.24.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.24.5.1  1997/05/12  10:38:27  hope
 * branched from 1.24
 *
@


1.24.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.24.5.1  1997/05/12  10:38:27  hope
 * branched from 1.24
 *
@


1.24.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.24.5.1.1.1  1997/07/28  18:23:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.24.4.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.3.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.3.1.1.1
log
@branched from 1.24.3.1
@
text
@a3 3
 * Revision 1.24.3.1  1996/12/17  17:51:39  hope
 * branched from 1.24
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a3 4
 * Revision 1.24  1996/11/06  10:56:22  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.24.1.1.1.1
log
@branched from 1.24.1.1
@
text
@a3 3
 * Revision 1.24.1.1  1996/11/14  12:54:31  hope
 * branched from 1.24
 *
@


1.23
log
@moving String from toplevel
@
text
@d4 3
d80 1
a80 1
require "../basis/__integer";
@


1.22
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d78 1
a100 2
structure Option = MLWorks.Option

d195 1
a195 1
    fun find [] = Option.NONE
d198 1
a198 1
          LRbasics.Reduce _ => Option.SOME action
d226 1
a226 1
                Option.SOME (LRbasics.Reduce (n,nonT,f)) =>
d429 1
a429 1
        val _ = if do_debug then print ("Entering local correction, " ^ Int.toString (Lists.length stklist) ^ " stack(s)\n") else ()
d434 1
a434 1
          Lists.filterp 
d445 1
a445 1
        val continuations_to_try = Lists.filterp (is_shiftable o #1 o #1) possible_continuations
@


1.22.3.1
log
@branched from 1.22
@
text
@a3 6
 * Revision 1.22  1996/04/30  17:39:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a3 6
 * Revision 1.22  1996/04/30  17:39:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a3 6
 * Revision 1.22  1996/04/30  17:39:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21
log
@Adding basis Integer
@
text
@d4 3
d163 1
a163 1
fun print s = output(std_out,s);
d357 1
a357 1
             (if do_debug then output(std_out,"Splitting..") else ();
@


1.20
log
@Mark CHAR and WORD as not shiftable
@
text
@d4 3
d68 2
a90 1
structure Integer = MLWorks.Integer
d200 1
a200 1
                          Integer.makestring state ^
d326 1
a326 1
        (if do_debug then print ("#"^(Integer.makestring function)^"#") else ();
d380 1
a380 1
  " (matching: " ^ Integer.makestring s_line ^ "," ^ Integer.makestring s_col ^ ")"
d421 1
a421 1
        val _ = if do_debug then print ("Entering local correction, " ^ Integer.makestring (Lists.length stklist) ^ " stack(s)\n") else ()
@


1.19
log
@Some efficiency improvements.
\n
\nAttempt at improvement to location in unexpected token message.
@
text
@d4 5
d271 2
@


1.18
log
@Removing catchall handler
@
text
@d81 3
d91 1
a91 1
  ActionFunctions.make_id_value "<Error>"
a122 6
datatype applyactionresult =
    FOUNDACCEPT of Parsed_Object
  | NEWSTACK of stack
  | NEWSTACKS of stack list
  | CANTCONTINUE

d137 6
d176 11
a186 1

d191 1
a191 1
                          MLWorks.Integer.makestring state ^
d194 1
a194 1
    fun dummy_apply_action (stk as (state,_,_)::_,action,sym,value,location) =
d198 26
a223 6
           (let val next_state = LRbasics.get_next_state(sym,state)
           in
              if do_debug then print ("Shifting " ^ print_token (sym,value) ^ "\n") else ();
              [(next_state,dummy,location)::stk]
           end
           handle _ => [])
d226 5
a230 1
             val new_stack = popn (n,stk)
d232 1
d234 2
a235 3
              dummy_apply options ((new_state,dummy,location)::new_stack,sym,value,location)
           end
           handle _ => [])
d239 4
a242 2
           dummy_apply_action(stk,call_resolution_fn
			      (act1,act2,function, options, n,stk,value),sym,value,location)
d256 2
a257 2
       [] => try_one options(l,sym,value,location,acc)
     | _ => try_one options (l,sym,value,location,sym'::acc))
d280 1
a280 1
  | LRbasics.VBAR => false
d288 1
a288 1
  | LRbasics.LET => false
a313 6
      (* Combination of getn, get_nth_location and popn *)
      fun get_stack_bits (0,rest,end_location,args) = (end_location,rest,args)
        | get_stack_bits (n,(_,arg,end_location)::rest,_,args) =
          get_stack_bits (n-1,rest,end_location,arg::args)
        | get_stack_bits (_,[],_,_) = Crash.impossible "Rubbish stack in parser (get_stack_bits)"
          
d315 1
a315 1
        (if do_debug then print ("#"^(MLWorks.Integer.makestring function)^"#") else ();
d319 2
a320 1
      fun apply_action (action,stack as (current_state,current_value,current_location) :: _) =
d326 1
a326 1
               NEWSTACK ((new_state,value,location)::stack)
d344 1
a344 7
              NEWSTACKS (concat (map (fn act =>
                                      case (apply_action (act,stack)) of
                                        NEWSTACK s => [s]
                                      | CANTCONTINUE => []
                                      | NEWSTACKS s => s
                                      | FOUNDACCEPT s => raise Foundit s)
                actions)))
d347 4
a350 5
	     (call_resolution_fn
	      (action1,action2,function,options, n,stack,value),stack)
         | LRbasics.Accept => FOUNDACCEPT current_value
         | LRbasics.NoAction => CANTCONTINUE)
        | apply_action _ = Crash.impossible "apply_action with empty stack"
d353 2
a354 2
        | dostacks ([] :: ss) = dostacks ss
        | dostacks (stack :: ss) =
d360 2
a361 4
              FOUNDACCEPT x => raise Foundit x
            | NEWSTACK ns => ns :: dostacks ss
            | NEWSTACKS sl => sl @@ dostacks ss
            | CANTCONTINUE => dostacks ss
d367 5
d410 1
a410 1
        val _ = if do_debug then print ("Entering local correction, " ^ MLWorks.Integer.makestring (Lists.length stklist) ^ " stack(s)\n") else ()
d436 1
a436 1
          (sym',value',location') :: _ => 
d439 1
a439 1
             report_error ("inserting `" ^ print_token (sym',value') ^ "'");
d443 1
a443 1
               (sym',value',location')::_ => 
d445 1
a445 1
                  report_error ("replacing with `" ^ print_token (sym',value') ^ "'");
@


1.17
log
@Improved error reporting
Stop inserting equality all over the place
@
text
@d4 4
d136 2
a137 2
fun getn (0, x, y) = y
  | getn (n, (_,a,_) :: b, y) = getn (n-1, b, a :: y)
d190 1
a190 1
              handle _ => [])
d198 1
a198 1
         handle _ => [])
a271 13
fun get_nth_location (0,(_,_,m)::_) = m
  | get_nth_location (1,(_,_,m)::_) = m
  | get_nth_location (n,_::s) = get_nth_location (n-1,s)
  | get_nth_location _ = Crash.impossible "Rubbish stack in parser (get_nth_location)"

fun get_top_location((_,_,m) :: _) = m
  | get_top_location _ = Crash.impossible "Rubbish stack in parser (get_top_location)"


val get_nth_location =
  fn (arg as (n, stack)) =>
  Location.combine(get_nth_location arg, get_top_location stack)

d275 10
a284 9

      fun call_action_fn (function,n,stack) =
        let
          val args = getn (n, stack, [])
        in
          if do_debug then print ("#"^(MLWorks.Integer.makestring function)^"#") else ();
          (ActionFunctions.get_function function)
	  (args,ActionFunctions.OPTS(get_nth_location(n,stack),error_info,options))
        end
d296 6
a301 3
               val result = call_action_fn (function,n,stack)
               val new_stack = (popn (n,stack))
               val new_location = get_nth_location (n,stack)
d303 2
d306 1
a306 1
               apply_sym ((new_state,result,new_location) :: new_stack)
d325 1
a325 8
      and apply_sym stack =
        let
          val current_state = top_state stack
          val action = LRbasics.get_action (sym, current_state)
        in
          apply_action (action, stack)
        end
      and dostacks [] = []
d327 11
a337 6
        | dostacks (s :: ss) =
          (case (apply_sym s) of
             FOUNDACCEPT x => raise Foundit x
           | NEWSTACK ns => ns :: dostacks ss
           | NEWSTACKS sl => sl @@ dostacks ss
           | CANTCONTINUE => dostacks ss)
@


1.16
log
@Minor speedups
@
text
@d4 3
d83 6
d172 5
a176 1
    val _ = if do_debug then print ("Dummy apply - state=" ^ MLWorks.Integer.makestring state ^" symbol=" ^ LRbasics.token_string sym ^ "\n") else ()
d183 1
a183 1
              if do_debug then print ("Shifting " ^ LRbasics.token_string sym ^ "\n") else ();
a209 11
(*
fun dummy_seq_apply options (stklist,symvallist) =
  let
    fun aux (stklist,[]) = stklist
      | aux (stklist,(sym,value,location)::symlist) =
        aux (dummy_stklist_apply options (stklist,sym,value,location),symlist)
  in
    aux (stklist,symvallist)
  end
*)

a215 15
(*
fun get_symbol_name x = "Foo"
*)

fun make_item (sym,value,location) = (sym,value,location)

fun print_symbols [] = ""
  | print_symbols [s] = LRbasics.token_string s
  | print_symbols (s::l) = LRbasics.token_string s ^ "," ^ print_symbols l

fun is_ignorable sym =
  case sym of
    LRbasics.EOF => false
  | _ => true

d219 1
a219 1
  | LRbasics.LONGID => false
d359 1
d390 11
a400 2
          Lists.filterp (fn (_,[]) => false | _ => true)
          (map (fn sym' => ((sym',dummy,location),dummy_stklist_apply options' (stklist,sym',dummy,location))) possible_symbols)
d406 1
a406 1
           "Unexpected `" ^ LRbasics.token_string sym ^ "', " ^ message)
d411 5
a415 4
          (sym',value',location') ::_ => (push_item(make_item (sym,value,location),lexbuff);
                                       push_item(make_item (sym',value',location'),lexbuff);
                                       report_error ("inserting `" ^ LRbasics.token_string sym' ^ "'");
                                       restart_parser stklist)
d418 4
a421 3
               (sym',value',location')::_ => (push_item(make_item (sym',value',location'),lexbuff);
                                           report_error("replacing with `" ^ LRbasics.token_string sym' ^ "'");
                                           restart_parser stklist)
d425 3
a427 3
                      (push_item(make_item(sym,value,location),lexbuff);
                       push_item(make_item(sym',value',location'),lexbuff);
                       report_error ("inserting `" ^ LRbasics.token_string sym' ^ "'");
d445 1
a445 1
              Info.error' error_info (Info.FATAL, location, "Unexpected `" ^ LRbasics.token_string sym ^ "'")
@


1.15
log
@Added qute marks around symbols in messages.
@
text
@d4 3
d83 1
a83 1
val do_debug = ref false
d108 4
a111 4
    FoundAccept of Parsed_Object
  | NewStack of stack
  | NewStacks of stack list
  | CantContinue
d163 1
a163 1
    val _ = if !do_debug then print ("Dummy apply - state=" ^ MLWorks.Integer.makestring state ^" symbol=" ^ LRbasics.token_string sym ^ "\n") else ()
d170 1
a170 1
              if !do_debug then print ("Shifting " ^ LRbasics.token_string sym ^ "\n") else ();
d302 1
a302 1
          if !do_debug then print("#"^(MLWorks.Integer.makestring function)^"#") else ();
d309 1
a309 2
           LRbasics.Accept => FoundAccept current_value
         | LRbasics.Shift =>
d313 1
a313 1
               NewStack ((new_state,value,location)::stack)
a314 13
         | LRbasics.Resolve actions =>
             (if (!do_debug) then output(std_out,"Splitting..") else ();
                NewStacks (concat (map (fn act =>
                                        case (apply_action (act,stack)) of
                                          NewStack s => [s]
                                        | CantContinue => []
                                        | NewStacks s => s
                                        | FoundAccept s => raise Foundit s)
                actions)))
         | LRbasics.Funcall (function,n,action1,action2) =>
             apply_action
	     (call_resolution_fn
	      (action1,action2,function,options, n,stack,value),stack)
d324 15
a338 1
         | LRbasics.NoAction => CantContinue)
d352 4
a355 4
             FoundAccept x => raise Foundit x
           | NewStack ns => ns :: dostacks ss
           | NewStacks sl => sl @@ dostacks ss
           | CantContinue => dostacks ss)
d369 1
a369 1
        if !do_debug then print ("$" ^ Token.makestring token) else ();
d397 1
a397 1
        val _ = if !do_debug then print ("Entering local correction, " ^ MLWorks.Integer.makestring (Lists.length stklist) ^ " stack(s)\n") else ()
@


1.14
log
@Make WHILE non-shiftable (it was being substituted for VAL).
@
text
@d4 3
d406 1
a406 1
           "Unexpected " ^ LRbasics.token_string sym ^ ", " ^ message)
d413 1
a413 1
                                       report_error ("inserting " ^ LRbasics.token_string sym');
d418 1
a418 1
                                           report_error("replacing with " ^ LRbasics.token_string sym');
d425 1
a425 1
                       report_error ("inserting " ^ LRbasics.token_string sym');
d443 1
a443 1
              Info.error' error_info (Info.FATAL, location, "Unexpected " ^ LRbasics.token_string sym)
@


1.13
log
@Extended grammar for NJ compatibility
@
text
@d4 3
d256 1
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.13  1993/06/10  10:41:05  matthew
Extended grammar for NJ compatibility

@


1.12
log
@Made WITHTYPE and ABSTRACTION unshiftable
@
text
@d4 3
d252 1
d294 1
a294 1
	  (args,ActionFunctions.OPTS(get_nth_location(n,stack),error_info,print_options))
@


1.11
log
@Removed integer parameter
@
text
@d4 3
d247 2
@


1.10
log
@Modified to allow options to determine association of two different equal
precedence right associative operators
@
text
@d4 4
a38 1
require "../utils/integer";
a46 1
                  structure Integer: INTEGER
d148 1
a148 1
    val _ = if !do_debug then print ("Dummy apply - state=" ^ Integer.makestring state ^" symbol=" ^ LRbasics.token_string sym ^ "\n") else ()
d283 1
a283 1
          if !do_debug then print("#"^(Integer.makestring function)^"#") else ();
d378 1
a378 1
        val _ = if !do_debug then print ("Entering local correction, " ^ Integer.makestring (Lists.length stklist) ^ " stack(s)\n") else ()
@


1.9
log
@Added New Jersey interpretation of weak type variables under option control
@
text
@d4 3
d136 3
a138 2
fun call_resolution_fn (action1,action2,function,n,stack,value) =
  let val args = getn (n, stack, [])
d140 1
a140 1
    (ActionFunctions.get_resolution function) (action1,action2,args,value)
d144 1
a144 1
fun dummy_apply (stk as (state,_,_)::_,sym,value,location) =
d162 1
a162 1
              dummy_apply ((new_state,dummy,location)::new_stack,sym,value,location)
d168 2
a169 1
           dummy_apply_action (stk,call_resolution_fn (act1,act2,function,n,stk,value),sym,value,location)
d175 1
a175 1
  | dummy_apply _ = Crash.impossible "Bad arg to dummy_apply"
d177 2
a178 2
fun dummy_stklist_apply (stklist,sym,value,location) =
  append_list (map (fn stk => dummy_apply(stk,sym,value,location)) stklist)
d180 2
a181 1
fun dummy_seq_apply (stklist,symvallist) =
d185 1
a185 1
        aux (dummy_stklist_apply (stklist,sym,value,location),symlist)
d189 1
d191 5
a195 5
fun try_one ([],_,_,_,acc) = acc
  | try_one ((sym',stklist)::l,sym,value,location,acc) =
    (case dummy_stklist_apply(stklist,sym,value,location) of
       [] => try_one(l,sym,value,location,acc)
     | _ => try_one(l,sym,value,location,sym'::acc))
d197 1
d199 1
d274 1
a274 1
  | run_parser_once (error_info,Options.OPTIONS{print_options,...}) (sym, value, location, stacks) =
d305 3
a307 1
             apply_action (call_resolution_fn (action1,action2,function,n,stack,value),stack)
d339 1
a339 1
fun parse_it (options as (error_info, Options.OPTIONS
d382 1
a382 1
          (map (fn sym' => ((sym',dummy,location),dummy_stklist_apply (stklist,sym',dummy,location))) possible_symbols)
d392 1
a392 1
        case try_one(continuations_to_try,sym,value,location,[]) of
d398 1
a398 1
            (case try_one(continuations_to_try,next_symbol,next_value,next_location,[]) of
@


1.8
log
@Added is_initial_state function
@
text
@d4 3
d328 3
a330 1
fun parse_it (options as (error_info,_)) (lexer,interactivep) =
d335 1
a335 1
        val (sym,value) = ActionFunctions.token_to_parsed_object token
d439 5
a443 2
fun parse_one_token (opts,token,location,state) =
  let val (symbol,value) = ActionFunctions.token_to_parsed_object token
@


1.7
log
@Signature revisions
@
text
@d4 3
d425 1
d427 3
@


1.6
log
@Options & Info changes
@
text
@d4 3
d45 2
a48 1

a49 3

structure Token = ActionFunctions.Token

d259 1
a259 1
  | run_parser_once (error_info,print_opts) (sym, value, location, stacks) =
d268 1
a268 1
	  (args,ActionFunctions.OPTS(get_nth_location(n,stack),error_info,print_opts))
@


1.5
log
@Added range combination on reduction rules
@
text
@d4 3
d258 1
a258 1
  | run_parser_once opts (sym, value, location, stacks) =
d267 1
a267 1
	  (args,ActionFunctions.OPTS(get_nth_location(n,stack),opts))
d321 1
a321 1
fun parse_it options (lexer,interactivep) =
d366 1
a366 1
          options
d391 1
a391 1
                              Info.error' options (Info.FATAL, location, "Unexpected end of input")
d405 1
a405 1
              Info.error' options (Info.FATAL, location, "Unexpected " ^ LRbasics.token_string sym)
@


1.4
log
@Changed Error structure to Info
@
text
@d4 3
d241 13
d257 1
a257 5
      fun get_nth_location (0,(_,_,m)::_) = m
        | get_nth_location (1,(_,_,m)::_) = m
        | get_nth_location (n,_::s) = get_nth_location (n-1,s)
        | get_nth_location _ = Crash.impossible "Rubbish stack in parser (get_nth_location)"
          
d263 2
a264 1
          (ActionFunctions.get_function function) (args,ActionFunctions.OPTS(get_nth_location(n,stack),opts))
@


1.3
log
@Added functions for incremental parsing.
@
text
@d4 3
d19 1
a19 1
require "../main/error";
a28 1
                  structure Error : ERROR
d30 1
a30 1
                  sharing Error.Location = ActionFunctions.Location) : LRPARSER =
d34 2
a35 2
structure Error = Error
structure Location = ActionFunctions.Location
d238 2
a239 2
fun run_parser_once (sym, value, location, []) = Crash.impossible "Empty stack list in parser"
  | run_parser_once (sym, value, location, stacks) =
d251 1
a251 2
            ActionFunctions.current_location_ref := get_nth_location(n,stack);
            (ActionFunctions.get_function function) args
d305 1
a305 1
fun parse_it (lexer,interactivep) =
d317 1
d349 4
a352 3
          Error.report
          (Error.ERROR (Error.RECOVERABLE, location,
                        "Unexpected " ^ LRbasics.token_string sym ^ ", " ^ message))
d375 1
a375 2
                              Error.report'
                              (Error.ERROR (Error.FATAL, location, "Unexpected end of input"))
d383 1
a383 1
      let val newstacks = run_parser_once args
d389 1
a389 2
              Error.report'
              (Error.ERROR (Error.FATAL, location, "Unexpected " ^ LRbasics.token_string sym))
d410 1
a410 1
fun parse_one_token (token,location,state) =
d413 1
a413 1
    run_parser_once (symbol,value,location,state)
@


1.2
log
@Installed central error reporting mechanism.
@
text
@d4 3
d236 68
d380 14
a393 11
    and run_parser (sym, value, location, []) = Crash.impossible "Empty stack list in parser"
      | run_parser (sym, value, location, stacks) =
        let
          fun get_nth_location (0,(_,_,m)::_) = m
            | get_nth_location (1,(_,_,m)::_) = m
            | get_nth_location (n,_::s) = get_nth_location (n-1,s)
            | get_nth_location _ = Crash.impossible "Rubbish stack in parser (get_nth_location)"
              
          fun call_action_fn (function,n,stack) =
            let
              val args = getn (n, stack, [])
d395 1
a395 3
              if !do_debug then print("#"^(Integer.makestring function)^"#") else ();
                ActionFunctions.current_location_ref := get_nth_location(n,stack);
                (ActionFunctions.get_function function) args
d397 1
a397 69
          
          fun apply_action (action,stack as (current_state,current_value,current_location) :: _) =
            (case action of
               LRbasics.Accept => FoundAccept current_value
             | LRbasics.Shift =>
                 let
                   val new_state = (LRbasics.get_next_state (sym,current_state))
                 in
                   NewStack ((new_state,value,location)::stack)
                 end
             | LRbasics.Resolve actions =>
                 (if (!do_debug) then output(std_out,"Splitting..") else ();
                    NewStacks (concat (map (fn act =>
                                            case (apply_action (act,stack)) of
                                              NewStack s => [s]
                                            | CantContinue => []
                                            | NewStacks s => s
                                            | FoundAccept s => raise Foundit s)
                    actions)))
             | LRbasics.Funcall (function,n,action1,action2) =>
                 apply_action (call_resolution_fn (action1,action2,function,n,stack,value),stack)
             | LRbasics.Reduce (n,non_term,function) =>
                 let
                   val result = call_action_fn (function,n,stack)
                   val new_stack = (popn (n,stack))
                   val new_location = get_nth_location (n,stack)
                   val new_state = LRbasics.get_next_state (non_term,(top_state new_stack))
                 in
                   apply_sym ((new_state,result,new_location) :: new_stack)
                 end
             | LRbasics.NoAction => CantContinue)
            | apply_action _ = Crash.impossible "apply_action with empty stack"
              
          and apply_sym stack =
            let
              val current_state = top_state stack
              val action = LRbasics.get_action (sym, current_state)
            in
              apply_action (action, stack)
            end

          and dostacks [] = []
            | dostacks ([] :: ss) = dostacks ss
            | dostacks (s :: ss) =
              (case (apply_sym s) of
                 FoundAccept x => raise Foundit x
               | NewStack ns => ns :: dostacks ss
               | NewStacks sl => sl @@ dostacks ss
               | CantContinue => dostacks ss)
        in
          let
            val newstacks = dostacks stacks
          in
            (* check if an error was found -- this is where the error recovery will go *)
            case newstacks of
              [] =>
                if interactivep then
                  Error.report'
                  (Error.ERROR (Error.FATAL, location, "Unexpected " ^ LRbasics.token_string sym))
                else
                  try_local_correction(stacks,sym,value,location)
            | _ =>
                let 
                  val (newsym,newval,newlocation) = get_next lexbuff
                in
                  run_parser (newsym,newval,newlocation,newstacks)
                end
          end
        end
d401 12
@


1.1
log
@Initial revision
@
text
@d4 3
d13 1
a15 1
require "parsing-errors";
a19 1
                  structure ParsingErrors : PARSINGERRORS
d23 3
a25 4
                  sharing type ActionFunctions.Marks = ParsingErrors.Marks
                  sharing  LRbasics = ActionFunctions.LRbasics
                    ) : LRPARSER =

d29 2
a39 2
type Marks = ActionFunctions.Marks

d67 1
a67 1
type stack = (int * Parsed_Object * Marks) list
a88 2
exception SyntaxError

d122 1
a122 1
fun dummy_apply (stk as (state,_,_)::_,sym,value,marks) =
d125 1
a125 1
    fun dummy_apply_action (stk as (state,_,_)::_,action,sym,value,marks) =
d132 1
a132 1
              [(next_state,dummy,marks)::stk]
d140 1
a140 1
              dummy_apply ((new_state,dummy,marks)::new_stack,sym,value,marks)
d144 1
a144 1
           append_list (map (fn action => dummy_apply_action (stk,action,sym,value,marks)) actions)
d146 1
a146 1
           dummy_apply_action (stk,call_resolution_fn (act1,act2,function,n,stk,value),sym,value,marks)
d150 1
a150 1
    dummy_apply_action (stk,LRbasics.get_action(sym,state),sym,value,marks)
d154 2
a155 2
fun dummy_stklist_apply (stklist,sym,value,marks) =
  append_list (map (fn stk => dummy_apply(stk,sym,value,marks)) stklist)
d160 2
a161 2
      | aux (stklist,(sym,value,marks)::symlist) =
        aux (dummy_stklist_apply (stklist,sym,value,marks),symlist)
d167 4
a170 4
  | try_one ((sym',stklist)::l,sym,value,marks,acc) =
    (case dummy_stklist_apply(stklist,sym,value,marks) of
       [] => try_one(l,sym,value,marks,acc)
     | _ => try_one(l,sym,value,marks,sym'::acc))
d174 1
a174 1
fun make_item (sym,value,marks) = (sym,value,marks)
d226 1
a226 1
  | closing_token_actions (((sym,value,marks),_)::l) =
d228 1
a228 1
      then (sym,value,marks)::(closing_token_actions l)
d237 1
a237 1
        val (token,marks) = lexer ()
d241 1
a241 1
        (sym,value,marks)
d243 1
a243 1
    val (sym,value,marks) = lex_it ()
d247 1
a247 1
      let val (sym,value,marks) = get_next lexbuff
d249 1
a249 1
        run_parser (sym,value,marks,stklist)
d252 1
a252 9
    and signal_error_and_stop (stklist,sym,marks) =
      (ParsingErrors.report_error ("Found \"" ^
                                   (LRbasics.token_string sym) ^
                                   "\" at ",
                                   marks,
                                   ParsingErrors.SERIOUS);
      raise SyntaxError)

    and try_local_correction (stklist,sym,value,marks) =
d270 1
a270 1
        val (next_symbol,next_value,next_marks) = peek_next lexbuff
d273 1
a273 1
          (map (fn sym' => ((sym',dummy,marks),dummy_stklist_apply (stklist,sym',dummy,marks))) possible_symbols)
d275 4
a278 2
        fun report_error mess  =
          ParsingErrors.report_error ("Found \"" ^ (LRbasics.token_string sym) ^ "\", " ^ mess,marks,ParsingErrors.SERIOUS)
d282 3
a284 3
        case try_one(continuations_to_try,sym,value,marks,[]) of
          (sym',value',marks') ::_ => (push_item(make_item (sym,value,marks),lexbuff);
                                       push_item(make_item (sym',value',marks'),lexbuff);
d288 2
a289 2
            (case try_one(continuations_to_try,next_symbol,next_value,next_marks,[]) of
               (sym',value',marks')::_ => (push_item(make_item (sym',value',marks'),lexbuff);
d294 3
a296 3
                    (sym',value',marks')::_ =>
                      (push_item(make_item(sym,value,marks),lexbuff);
                       push_item(make_item(sym',value',marks'),lexbuff);
d301 2
a302 2
                              (ParsingErrors.report_error("Unexpected end of input",marks,ParsingErrors.SERIOUS);
                               raise SyntaxError)
d304 1
a304 1
                              (report_error "ignoring it";
d309 2
a310 2
    and run_parser (sym, value, marks, []) = Crash.impossible "Empty stack list in parser"
      | run_parser (sym, value, marks, stacks) =
d312 4
a315 4
          fun get_nth_mark (0,(_,_,m)::_) = m
            | get_nth_mark (1,(_,_,m)::_) = m
            | get_nth_mark (n,_::s) = get_nth_mark (n-1,s)
            | get_nth_mark _ = Crash.impossible "Rubbish stack in parser (get_nth_mark)"
d322 1
a322 1
                ActionFunctions.current_marks_ref := get_nth_mark(n,stack);
d326 1
a326 1
          fun apply_action (action,stack as (current_state,current_value,current_marks) :: _) =
d333 1
a333 1
                   NewStack ((new_state,value,marks)::stack)
d350 1
a350 1
                   val new_marks = get_nth_mark (n,stack)
d353 1
a353 1
                   apply_sym ((new_state,result,new_marks) :: new_stack)
d380 6
a385 5
              [] => if interactivep
                      then
                        signal_error_and_stop (stacks,sym,marks)
                    else
                      try_local_correction(stacks,sym,value,marks)
d388 1
a388 1
                  val (newsym,newval,newmarks) = get_next lexbuff
d390 1
a390 1
                  run_parser (newsym,newval,newmarks,newstacks)
d395 1
a395 1
    run_parser (sym, value, marks, [[(0, dummy,ActionFunctions.dummy_marks)]])
@
