head	1.32;
access;
symbols
	MLW_daveb_inline_1_4_99:1.32.1
	MLWorks_21c0_1999_03_25:1.32
	MLWorks_20c1_1998_08_20:1.32
	MLWorks_20c0_1998_08_04:1.32
	MLWorks_20b2c2_1998_06_19:1.32
	MLWorks_20b2_Windows_1998_06_12:1.32
	MLWorks_20b1c1_1998_05_07:1.32
	MLWorks_20b0_1998_04_07:1.32
	MLWorks_20b0_1998_03_20:1.32
	MLWorks_20m2_1998_02_16:1.31
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.31.7.1.1.1.1
	MLWorks_workspace_97:1.31.9
	MLWorks_dt_wizard:1.31.8
	MLWorks_11c0_1997_09_09:1.31.7.1.1.1
	MLWorks_10r3:1.31.7.1.3
	MLWorks_10r2_551:1.31.7.1.2
	MLWorks_11:1.31.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.7.1
	MLWorks_20m0_1997_06_20:1.31
	MLWorks_1_0_r2c2_1997_06_14:1.31.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.7
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.5.1.1
	MLWorks_gui_1996_12_18:1.31.6
	MLWorks_1_0_Win32_1996_12_17:1.31.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.3.1
	MLWorks_1_0_Irix_1996_11_28:1.31.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.4
	MLWorks_1_0_Unix_1996_11_14:1.31.3
	MLWorks_Open_Beta2_1996_10_11:1.31.2
	MLWorks_License_dev:1.31.1
	MLWorks_1_open_beta_1996_09_13:1.30.1
	MLWorks_Open_Beta_1996_08_22:1.30
	MLWorks_Beta_1996_07_02:1.29
	MLWorks_Beta_1996_06_07:1.29
	MLWorks_Beta_1996_06_06:1.29
	MLWorks_Beta_1996_06_05:1.29
	MLWorks_Beta_1996_06_03:1.29
	MLWorks_Beta_1996_05_31:1.29
	MLWorks_Beta_1996_05_30:1.29
	ML_beta_release_12/08/94:1.22
	ML_beta_release_03/08/94:1.22
	ML_revised_beta_release_25/05/94:1.22
	ML_final_beta_release_02/03/94:1.22
	mlworks-28-01-1994:1.22
	Release:1.22
	mlworks-beta-01-09-1993:1.22
	MLWorks-1-0-4-29/01/1993:1.7
	MLWorks-1-0-3-21/12/1992:1.7
	MLWorks-1-0-2-15/12/1992:1.6
	MLWorks-1-0-1-04/12/1992:1.6;
locks; strict;
comment	@ * @;


1.32
date	98.02.19.16.35.48;	author mitchell;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	96.09.25.11.12.48;	author matthew;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1
	1.31.5.1
	1.31.6.1
	1.31.7.1
	1.31.8.1
	1.31.9.1;
next	1.30;

1.30
date	96.08.09.11.38.41;	author daveb;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	96.04.19.14.29.40;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.03.25.11.05.22;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.03.18.16.18.04;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	96.03.15.14.38.02;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	95.07.19.12.17.50;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.05.15.14.50.20;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.02.28.11.00.13;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.08.12.14.58.55;	author jont;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	93.07.28.16.07.44;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.06.16.10.37.00;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.06.09.16.33.46;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.05.20.10.47.59;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	93.05.14.17.05.08;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	93.04.26.16.08.45;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.04.01.12.33.14;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.03.30.11.54.46;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.03.24.13.29.26;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.03.19.12.15.43;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.03.16.16.04.56;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	93.03.10.14.56.57;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	93.03.09.11.30.46;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	93.02.03.18.02.51;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	92.12.21.10.37.40;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	92.11.25.20.12.59;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	92.11.05.17.48.15;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	92.10.14.11.42.35;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	92.10.07.16.11.48;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	92.09.04.08.56.39;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.08.26.10.18.00;	author matthew;	state Exp;
branches;
next	;

1.22.1.1
date	93.08.12.14.58.55;	author jont;	state Exp;
branches;
next	;

1.30.1.1
date	96.09.13.11.20.27;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	96.10.07.16.10.23;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.10.17.11.28.53;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.11.14.12.54.34;	author hope;	state Exp;
branches
	1.31.3.1.1.1;
next	;

1.31.3.1.1.1
date	96.11.28.15.05.24;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.11.22.18.13.13;	author hope;	state Exp;
branches;
next	;

1.31.5.1
date	96.12.17.17.51.42;	author hope;	state Exp;
branches
	1.31.5.1.1.1;
next	;

1.31.5.1.1.1
date	97.02.24.11.42.20;	author hope;	state Exp;
branches;
next	;

1.31.6.1
date	96.12.18.09.46.01;	author hope;	state Exp;
branches;
next	;

1.31.7.1
date	97.05.12.10.38.30;	author hope;	state Exp;
branches
	1.31.7.1.1.1
	1.31.7.1.2.1
	1.31.7.1.3.1;
next	;

1.31.7.1.1.1
date	97.07.28.18.23.30;	author daveb;	state Exp;
branches
	1.31.7.1.1.1.1.1;
next	;

1.31.7.1.1.1.1.1
date	97.10.07.11.49.14;	author jkbrook;	state Exp;
branches;
next	;

1.31.7.1.2.1
date	97.09.08.17.16.54;	author daveb;	state Exp;
branches;
next	;

1.31.7.1.3.1
date	97.09.09.14.13.00;	author daveb;	state Exp;
branches;
next	;

1.31.8.1
date	97.09.10.19.29.02;	author brucem;	state Exp;
branches;
next	;

1.31.9.1
date	97.09.11.20.58.57;	author daveb;	state Exp;
branches;
next	;

1.32.1.1
date	99.04.01.17.59.24;	author daveb;	state Exp;
branches;
next	;


desc
@New LR parser functor.
@


1.32
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _newparser.sml the functor *)
(*
$Log: _parser.sml,v $
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
 * Revision 1.30  1996/08/09  11:38:41  daveb
 * [Bug #1534]
 * Added infix declaration for "before".
 *
 * Revision 1.29  1996/04/19  14:29:40  matthew
 * Removing exceptions
 *
 * Revision 1.28  1996/03/25  11:05:22  matthew
 * Extra field in VALdec
 *
 * Revision 1.27  1996/03/18  16:18:04  matthew
 * Removed topdec_semicolons option
 *
 * Revision 1.26  1996/03/15  14:38:02  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.25  1995/07/19  12:17:50  matthew
 * Changing parser error reporting.
 *
Revision 1.24  1995/05/15  14:50:20  matthew
Renaming nj_semicolons

Revision 1.23  1995/02/28  11:00:13  matthew
Changes to Lexer signatture

Revision 1.22  1993/08/12  14:58:55  jont
modified to use new multiple unget facility

Revision 1.21  1993/07/28  16:07:44  matthew
Added error check for Foo.Bar. longids

Revision 1.20  1993/06/16  10:37:00  matthew
Changed to allow no semicolons between topdecs

Revision 1.19  1993/06/09  16:33:46  matthew
Semi clean up of parser state

Revision 1.18  1993/05/20  10:47:59  jont
Changed default status of @@ to infixr 5

Revision 1.17  1993/05/14  17:05:08  jont
Added New Jersey interpretation of weak type variables under option control

Revision 1.16  1993/04/26  16:08:45  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

Revision 1.15  1993/04/01  12:33:14  daveb
Exposed LexerState so that _shell can set prompts appropriately.
Changed parse_incremental so that it distinguishes between the end of lines
and the end of files.

Revision 1.14  1993/03/30  11:54:46  daveb
Changes to EOF handling to support LexerState.

Revision 1.13  1993/03/24  13:29:26  daveb
Lexer.getToken now takes an options parameter.

Revision 1.12  1993/03/19  12:15:43  matthew
Added is_initial_state function
/

Revision 1.11  1993/03/16  16:04:56  matthew
Changed type of parse_incrementally to fit with error wrapping

Revision 1.10  1993/03/10  14:56:57  matthew
Options changes

Revision 1.9  1993/03/09  11:30:46  matthew
Options & Info changes

Revision 1.8  1993/02/03  18:02:51  matthew
Rationalised sharing.

Revision 1.7  1992/12/21  10:37:40  matthew
Changed SyntaxError exception to include a location and print the token differently.

Revision 1.6  1992/11/25  20:12:59  daveb
 Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.5  1992/11/05  17:48:15  matthew
Changed Error structure to Info

Revision 1.4  1992/10/14  11:42:35  richard
Added line number to token stream input functions.

Revision 1.3  1992/10/07  16:11:48  matthew
Added functions for incremental parsing.

Revision 1.2  1992/09/04  08:56:39  richard
Installed central error reporting mechanism.

Revision 1.1  1992/08/26  10:18:00  matthew
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "LRparser";
require "../lexer/lexer";
require "../utils/crash";
require "parser";

functor NewParser (
  structure LRparser : LRPARSER
  structure Lexer : LEXER
  structure Crash : CRASH

  sharing Lexer.Token = LRparser.ActionFunctions.Token
  sharing LRparser.ActionFunctions.Info.Location = Lexer.Info.Location
  sharing Lexer.Token.Symbol = LRparser.ActionFunctions.Absyn.Ident.Symbol
  sharing LRparser.ActionFunctions.Info = Lexer.Info
    
  sharing type LRparser.ActionFunctions.Options.options = Lexer.Options
) : PARSER =
struct

structure Lexer = Lexer
structure Absyn = LRparser.ActionFunctions.Absyn
structure ActionFunctions = LRparser.ActionFunctions
structure Info = ActionFunctions.Info
structure Token = Lexer.Token
structure Options = ActionFunctions.Options
structure PE = ActionFunctions.PE
structure Symbol = Absyn.Ident.Symbol

type ParserBasis = PE.pB

val empty_pB = PE.empty_pB

exception WrongParseResultType

exception SeriousParseError

fun with_parser_basis pB f =
  let 
    val old_pB = ActionFunctions.getParserBasis()
    val _ = ActionFunctions.setParserBasis pB
    val result = 
      f ()
      handle exn =>
        (ActionFunctions.setParserBasis old_pB;raise exn)
  in
    ActionFunctions.setParserBasis old_pB;
    result
  end

fun token_to_string tok =
  ActionFunctions.print_token (ActionFunctions.token_to_parsed_object (false, tok))

(* The location should be the location before the token *)    
fun check_semicolon (error_info,options,ts,(tok,loc)) =
  case tok of
    Token.RESERVED Token.SEMICOLON => ()
  | Token.EOF _ => ()
  | Token.IGNORE => ()
  | _ => Lexer.ungetToken((tok,loc), ts)

(* this function filters out longids with null names since the lexer no
 longer checks for this *)

fun getToken error_info (args as (options, ls, ts)) =
  let
    val token = Lexer.getToken error_info args
    val _ =
      case token of
        Token.LONGID (_,sym) =>
          if Symbol.symbol_name sym = ""
            then Info.error error_info (Info.RECOVERABLE, 
                                        Lexer.locate ts,
                                        "Invalid long identifier: " ^ Token.makestring token)
          else ()
      | _ => ()
  in
    token
  end
  
(* EOFs in the middle of comments and strings are treated differently
   by each parser, so they're handled here instead of in the lexer. *)
(* There is a nasty hack whereby we have to record the location of the token stream *)
(* before reading the current token *)
fun parse_topdec error_info (options,ts,pB) =
  let
    val gettok = getToken error_info
    val parse_it = LRparser.parse_it (error_info,options)
    val lasttok = ref (Token.IGNORE, Info.Location.UNKNOWN)
    fun get_next () =
      let
        val loc1 = Lexer.locate ts
        val tok = gettok (options, Token.PLAIN_STATE, ts)
        val loc = Lexer.locate ts
      in
	(lasttok := (tok,loc1);
         case tok of
	   Token.EOF (Token.IN_COMMENT _) =>
	     Info.error error_info
			(Info.RECOVERABLE, loc,
			 "End of file reached while reading comment")
	 | Token.EOF (Token.IN_STRING _) =>
	     Info.error error_info
			(Info.RECOVERABLE, loc,
			 "End of file reached while reading string")
	 | _ => ();
	 (tok, loc))
      end
  in
    with_parser_basis
    pB
    (fn () =>
     (ignore(parse_it (get_next, Lexer.is_interactive ts));
      Crash.impossible "Topdec not found in parser??!!"))
    handle ActionFunctions.FoundTopDec x =>
      (check_semicolon (error_info,options,ts,!lasttok);
       x)
  end

exception NotExpression

fun parse_string (s,error_info,options,pB) =
  let
    open Absyn
    fun get_expression (STRDECtopdec (strdec,_)) =
      (case strdec of
         (DECstrdec (VALdec ([(pat,exp,_)],[],_,_))) =>
           (case pat of
              VALpat ((valid,_),_) =>
                (case valid of
                   Ident.LONGVALID (Ident.NOPATH,Ident.VAR sym) =>
                     if Symbol.symbol_name sym = "it"
                       then exp
                     else raise NotExpression
                 | _ => raise NotExpression)
            | _ => raise NotExpression)
       | _ => raise NotExpression)
      | get_expression _ = raise NotExpression
    val sref = ref s
    fun input_fn _ = let val result = !sref in sref := ""; result end
    val ts = Lexer.mkTokenStream(input_fn,"String Input")
    val (topdec,_) = parse_topdec error_info (options,ts,pB)
  in
    get_expression topdec
  end

val (initial_pB,initial_pB_for_builtin_library) = 
  let
      fun parse pB s =
	let
	  val done = ref false
	  val ts =
            Lexer.mkTokenStream
            (fn _ => if !done then "" else (done := true; s), "")
	in
	  parse_topdec
	    (Info.make_default_options ())
	    (Options.default_options,ts,pB)
	end
      
      val (_, initial) =
	parse empty_pB   
	
	"(* first value constructors *) \
          \  datatype constructors = true | false | nil | :: | ref \

          \  (* next exception constructors *) \
          \  exception Ord and Chr and Div and Sqrt and Exp and Ln and Io \
          \ and Match and Bind and Interrupt \

          \  (* next value variables *) \
          \  val map = () and rev = () and not = () and ~ = () and abs = () \
          \  and floor = () and real = () and sqrt = () and sin = () and cos = () \
          \  and arctan = () and exp = () and ln = () and size = () and chr = () \
          \  and ord = () and explode = () and implode = () and ! = () \
          \  and substring = ()   \
          
          \  and / = () and div = () and mod = () and + = () and * = () and - = () \
          \  and ^ = () and @@ = () and <> = () and < = () and > = () \
          \  and <= = () and >= = () and := = () and o = () \

          \  (* finally we define the infix identifiers *) \
          \  infix 7 / * div mod \
          \  infix 6 + - ^ \
          \  (*infix 5 @@*) \
          \  infixr 5 :: @@ \
          \  infix 4 <> < > <= >= =\
          \  infix 3 := o   \
          \  infix 0 before \
          \\
          \\
          \ structure Array = \
           \    struct     \
           \       val update = () and length = () and array = () \
           \         and sub = () and tabulate = () and arrayoflist = () \
           \        exception Size and Subscript   \
           \    end ; ";

      val (_, initial') =
	parse empty_pB   
	
	"(* first value constructors *) \
          \  datatype constructors = true | false | nil | :: | ref \

          \  (* next value variables *) \
          \  fun call_c x = ()  \

          \  (* finally we define the infix identifiers *) \
          \  infixr 5 ::  \
          \        ;"


    in
      (initial,initial')
    end

  val augment_pB = PE.augment_pB

  val remove_str = PE.remove_str

  (* Incremental Parsing *)
  
  type ParserState = LRparser.ParserState

  val initial_parser_state = LRparser.initial_parser_state

  fun is_initial_state ps = LRparser.is_initial_state ps

  exception FoundTopDec of (Absyn.TopDec * ParserBasis * Info.Location.T)

  exception SyntaxError of string * Info.Location.T

  (* End of file is overloaded here - a "fake" EOF is found at the end of
     each line, which must be distinguished from a real EOF.  So the shell
     indicates a real EOF by creating a tokenstream for which eof returns
     true before any tokens have been read. *)
  (* There is a nasty hack whereby we have to record the location of the token stream *)
  (* before reading the current token *)
  (* This is to ensure that ungetting tokens resets the location appropriately *)
  fun parse_incrementally error_info (options,ts,pB,ps,ls) =
    let
      val gettok = getToken error_info
      val lasttok = ref (Token.IGNORE, Info.Location.UNKNOWN)
      fun loop (ps, ls) =
        let
          val loc1 = Lexer.locate ts
          val tok = gettok (options, ls, ts)
          val location = Lexer.locate ts
        in
          lasttok := (tok,loc1);
	  case tok of 
            Token.EOF ls' =>
	      (* End of line *)
              (ActionFunctions.getParserBasis(), ps, ls')
          | _ =>
            let val new_state =
                  LRparser.parse_one_token((error_info,options),tok,location,ps)
            in
	      if LRparser.error_state new_state then
	        raise SyntaxError ("Unexpected `" ^ token_to_string tok ^ "'",location)
	      else
                loop (new_state, Token.PLAIN_STATE)
            end
        end
    in
      with_parser_basis
      pB
      (fn () =>
       if Lexer.eof ts then
         (* this is a real EOF, not just an end of line *)
         let
           val location = Lexer.locate ts
         in
           case ls of
             (Token.IN_COMMENT _) =>
               (Info.error error_info
                (Info.RECOVERABLE, location,
                 "End of file reached while reading comment");
                (pB, ps, ls))
           | (Token.IN_STRING _) =>
               (Info.error error_info
                (Info.RECOVERABLE, location,
                 "End of file reached while reading string");
                (pB, ps, ls))
           | _ =>
               let
                 val new_state =
                   LRparser.parse_one_token ((error_info,options),
                                             Lexer.Token.EOF ls, location, ps)
               in
                 (ActionFunctions.getParserBasis(), new_state, ls)
               end
         end
       else
         loop (ps, ls))
      handle ActionFunctions.FoundTopDec (dec, pB) =>
	(check_semicolon (error_info,options,ts,!lasttok);
         raise FoundTopDec (dec, pB, Lexer.locate ts))
    end
end

@


1.32.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.32  1998/02/19  16:35:48  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.31
log
@Problem with end location in parse_incrementally
@
text
@d4 3
d216 1
a216 1
     (parse_it (get_next, Lexer.is_interactive ts);
@


1.31.9.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.8.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.7.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.31.7.1  1997/05/12  10:38:30  hope
 * branched from 1.31
 *
@


1.31.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.31.7.1  1997/05/12  10:38:30  hope
 * branched from 1.31
 *
@


1.31.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.31.7.1  1997/05/12  10:38:30  hope
 * branched from 1.31
 *
@


1.31.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.31.7.1.1.1  1997/07/28  18:23:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31.6.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.5.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.5.1.1.1
log
@branched from 1.31.5.1
@
text
@a3 3
 * Revision 1.31.5.1  1996/12/17  17:51:42  hope
 * branched from 1.31
 *
@


1.31.4.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.3.1.1.1
log
@branched from 1.31.3.1
@
text
@a3 3
 * Revision 1.31.3.1  1996/11/14  12:54:34  hope
 * branched from 1.31
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/09/25  11:12:48  matthew
 * Problem with end location in parse_incrementally
 *
@


1.30
log
@[Bug #1534]
Added infix declaration for "before".
@
text
@d4 4
d153 8
a160 12
    
fun check_semicolon (error_info,options,ts) =
  let
    val tok = Lexer.lastToken ts
    val loc = Lexer.locate ts
  in
    case tok of
      Token.RESERVED Token.SEMICOLON => ()
    | Token.EOF _ => ()
    | Token.IGNORE => ()
    | _ => Lexer.ungetToken(Lexer.lastToken ts, ts)
  end
d183 2
d189 1
d192 1
d194 1
d196 2
a197 1
	(case tok of
d200 1
a200 1
			(Info.RECOVERABLE, Lexer.locate ts,
d204 1
a204 1
			(Info.RECOVERABLE, Lexer.locate ts,
d207 1
a207 1
	 (tok, Lexer.locate ts))
d216 1
a216 1
      (check_semicolon (error_info,options,ts);
d337 3
d343 1
d346 1
d350 1
d397 1
a397 1
	(check_semicolon (error_info,options,ts);
@


1.30.1.1
log
@branched from 1.30
@
text
@a3 4
 * Revision 1.30  1996/08/09  11:38:41  daveb
 * [Bug #1534]
 * Added infix declaration for "before".
 *
@


1.29
log
@Removing exceptions
@
text
@d4 3
d283 1
@


1.28
log
@Extra field in VALdec
@
text
@d4 3
d259 1
a259 2
          \  exception Abs and Ord and Chr and Div and Mod and Quot and Prod \
          \ and Neg and Sum and Diff and Floor and Sqrt and Exp and Ln and Io \
@


1.27
log
@Removed topdec_semicolons option
@
text
@d4 3
d215 1
a215 1
         (DECstrdec (VALdec ([(pat,exp,_)],[],_))) =>
@


1.26
log
@Fixed use of Info.default_options.
@
text
@d4 3
a144 2
    val Options.OPTIONS{extension_options,...} = options
    val Options.EXTENSIONOPTIONS{topdec_semicolons,...} = extension_options
d150 1
a150 9
    | _ => (Lexer.ungetToken(Lexer.lastToken ts, ts);
            if topdec_semicolons
              then ()
            else
              Info.error 
              error_info
              (Info.RECOVERABLE,
               Lexer.locate ts,
               "Semicolon expected at end of topdec"))
@


1.25
log
@Changing parser error reporting.
@
text
@d4 3
d248 3
a250 1
	  parse_topdec Info.default_options (Options.default_options,ts,pB)
@


1.24
log
@Renaming nj_semicolons
@
text
@d4 3
d133 1
a133 4
  let val (sym,_) = ActionFunctions.token_to_parsed_object(false, tok)
  in
    ActionFunctions.LRbasics.token_string sym
  end
d341 1
a341 1
	        raise SyntaxError (token_to_string tok,location)
@


1.23
log
@Changes to Lexer signatture
@
text
@d4 3
d139 2
a140 2
    val Options.OPTIONS{compat_options,...} = options
    val Options.COMPATOPTIONS{nj_semicolons,...} = compat_options
d147 1
a147 1
            if nj_semicolons
@


1.22
log
@modified to use new multiple unget facility
@
text
@d4 3
d92 1
a92 1
  sharing type LRparser.ActionFunctions.Options.options = Lexer.options
@


1.22.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.22  1993/08/12  14:58:55  jont
modified to use new multiple unget facility

@


1.21
log
@Added error check for Foo.Bar. longids
@
text
@d4 3
d140 1
a140 1
    | _ => (Lexer.unGetToken ts;
@


1.20
log
@Changed to allow no semicolons between topdecs
@
text
@d4 3
d148 19
d171 1
a171 1
    val getToken = Lexer.getToken error_info
d175 1
a175 1
        val tok = getToken (options, Token.PLAIN_STATE, ts)
d317 1
a317 1
      val getToken = Lexer.getToken error_info
d320 1
a320 1
          val tok = getToken (options, ls, ts)
@


1.19
log
@Semi clean up of parser state
@
text
@d4 3
d116 29
a144 1
     
d173 3
a175 1
    handle ActionFunctions.FoundTopDec x => x
a288 6
  fun token_to_string tok =
    let val (sym,_) = ActionFunctions.token_to_parsed_object(false, tok)
    in
      ActionFunctions.LRbasics.token_string sym
    end
    
d347 2
a348 1
	raise FoundTopDec (dec, pB, Lexer.locate ts)
@


1.18
log
@Changed default status of @@ to infixr 5
@
text
@d4 3
d79 1
d91 1
d101 13
d137 5
a141 3
    ActionFunctions.setParserBasis pB;
    (parse_it (get_next, Lexer.is_interactive ts);
     Crash.impossible "Topdec not found in parser??!!")
d145 27
d289 30
a318 28
      (ActionFunctions.setParserBasis pB;
      if Lexer.eof ts then
        (* this is a real EOF, not just an end of line *)
	let
          val location = Lexer.locate ts
	in
	  case ls of
	    (Token.IN_COMMENT _) =>
	      (Info.error error_info
	  		  (Info.RECOVERABLE, location,
	  		   "End of file reached while reading comment");
	       (pB, ps, ls))
	  | (Token.IN_STRING _) =>
	      (Info.error error_info
			  (Info.RECOVERABLE, location,
			   "End of file reached while reading string");
	       (pB, ps, ls))
	  | _ =>
	    let
              val new_state =
                    LRparser.parse_one_token ((error_info,options),
					      Lexer.Token.EOF ls, location, ps)
	    in
              (ActionFunctions.getParserBasis(), new_state, ls)
	    end
	end
      else
        loop (ps, ls))
@


1.17
log
@Added New Jersey interpretation of weak type variables under option control
@
text
@d4 3
d162 2
a163 2
          \  infix 5 @@ \
          \  infixr 5 :: \
@


1.16
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d4 3
d207 1
a207 1
    let val (sym,_) = ActionFunctions.token_to_parsed_object tok
@


1.15
log
@Exposed LexerState so that _shell can set prompts appropriately.
Changed parse_incremental so that it distinguishes between the end of lines
and the end of files.
@
text
@d4 5
d188 2
@


1.14
log
@Changes to EOF handling to support LexerState.
@
text
@d4 3
d186 1
a186 1
  type ParserState = LRparser.ParserState * Token.LexerState
d188 1
a188 2
  val initial_parser_state =
    (LRparser.initial_parser_state, Token.PLAIN_STATE)
d190 1
a190 2
  fun is_initial_state (ps, ls) =
    ls = Token.PLAIN_STATE andalso LRparser.is_initial_state ps
d192 1
a192 1
  exception FoundTopDec of (Absyn.TopDec * ParserBasis)
d202 5
a206 1
  fun parse_incrementally error_info (options,ts,pB,state) =
d214 1
a214 1
          case tok of 
d216 2
a217 1
              (ActionFunctions.getParserBasis(), (ps, ls'))
d219 8
a226 7
              let val new_state =
                LRparser.parse_one_token((error_info,options),tok,location,ps)
              in
                if LRparser.error_state new_state
                  then raise SyntaxError (token_to_string tok,location)
                else loop (new_state, Token.PLAIN_STATE)
              end
d229 30
a258 3
      ActionFunctions.setParserBasis pB;
      loop state
      handle ActionFunctions.FoundTopDec x => raise FoundTopDec x
d261 1
@


1.13
log
@Lexer.getToken now takes an options parameter.
@
text
@d4 3
d82 2
d90 1
a90 1
        val tok = getToken (options, ts)
d92 11
a102 1
        (tok, Lexer.locate ts)
a110 11
fun skip_topdec error_info (options, tokenstream) =
  let
    val getToken = Lexer.getToken error_info
    fun findsemi () =
      case getToken (options, tokenstream) of
	Token.RESERVED (Token.SEMICOLON) => ()
      | _ => findsemi ()
  in
    findsemi ()
  end

d183 4
a186 2
  type ParserState = LRparser.ParserState
  val initial_parser_state = LRparser.initial_parser_state
d188 2
a189 1
  val is_initial_state = LRparser.is_initial_state
d204 1
a204 1
      fun loop (state) =
d206 1
a206 1
          val tok = getToken (options, ts)
d210 2
a211 2
            Token.RESERVED(Token.EOF) =>
              (ActionFunctions.getParserBasis(),state)
d214 1
a214 1
                LRparser.parse_one_token((error_info,options),tok,location,state)
d218 1
a218 1
                else loop (new_state)
@


1.12
log
@Added is_initial_state function
/
@
text
@d4 4
d50 11
a60 11
functor NewParser (structure LRparser : LRPARSER
                   structure Lexer : LEXER
                   structure Crash : CRASH

                   sharing Lexer.Token = LRparser.ActionFunctions.Token
                   sharing LRparser.ActionFunctions.Info.Location = Lexer.Info.Location
                   sharing Lexer.Token.Symbol = LRparser.ActionFunctions.Absyn.Ident.Symbol
                   sharing LRparser.ActionFunctions.Info = Lexer.Info

                     ) : PARSER =

d85 1
a85 1
        val tok = getToken ts
d96 1
a96 1
fun skip_topdec (error_info,tokenstream) =
d100 1
a100 1
      case getToken tokenstream of
d199 1
a199 1
          val tok = getToken ts
@


1.11
log
@Changed type of parse_incrementally to fit with error wrapping
@
text
@d4 3
d177 2
@


1.10
log
@Options changes
@
text
@d4 3
d185 1
a185 1
  fun parse_incrementally (param as (error_info,options)) (ts,pB,state) =
d197 2
a198 1
              let val new_state = LRparser.parse_one_token(param,tok,location,state)
@


1.9
log
@Options & Info changes
@
text
@d4 3
d106 1
a106 1
	  parse_topdec Info.default_options (Options.default_print_options,ts,pB)
d182 1
a182 1
  fun parse_incrementally (param as (error_info,_)) (ts,pB,state) =
@


1.8
log
@Rationalised sharing.
@
text
@d4 3
d43 1
a43 1
                   sharing Lexer.Token.Symbol = LRparser.ActionFunctions.Absyn.Datatypes.Ident.Symbol
d55 1
a55 1

d66 1
a66 1
fun parse_topdec options (ts,pB) =
d68 2
a69 2
    val getToken = Lexer.getToken options
    val parse_it = LRparser.parse_it options
d83 1
a83 1
fun skip_topdec (options,tokenstream) =
d85 1
a85 1
    val getToken = Lexer.getToken options
d103 1
a103 1
	  parse_topdec Info.default_options (ts,pB)
d179 1
a179 1
  fun parse_incrementally options (ts,pB,state) =
d181 1
a181 1
      val getToken = Lexer.getToken options
d191 1
a191 1
              let val new_state = LRparser.parse_one_token(options,tok,location,state)
@


1.7
log
@Changed SyntaxError exception to include a location and print the token differently.
@
text
@d4 3
a28 3
require "../basics/absyn";
require "../basics/token";
require "../utils/crash";
a29 1
require "actionfunctions";
d31 1
a34 2
                   structure Absyn : ABSYN
                   structure ActionFunctions : ACTIONFUNCTIONS
a35 1
                   structure Token : TOKEN
d38 6
a43 7
                   sharing ActionFunctions = LRparser.ActionFunctions
                   sharing Lexer.Token = Token = ActionFunctions.Token
                   sharing ActionFunctions.Info.Location = Absyn.Location
                   sharing type LRparser.Parsed_Object = ActionFunctions.Parsed_Object
                   sharing type LRparser.TokenType = Token.Token
                   sharing ActionFunctions.Info = Lexer.Info
                   sharing type ActionFunctions.FinalValue = Absyn.TopDec) : PARSER =
d48 2
a49 1
structure Absyn = Absyn
d51 1
@


1.6
log
@ Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d42 1
a42 1
                   sharing Lexer.Token = Token
d170 1
a170 1
  exception SyntaxError of string
d172 6
d193 1
a193 1
                  then raise SyntaxError (Token.makestring tok)
@


1.5
log
@Changed Error structure to Info
@
text
@d4 3
a88 15
local val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                               flush_out = fn () => (),
                                               close_out = fn () => ()}
in
  val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                               stop = Info.FATAL,
                                               report = Info.ADVICE,
                                               worst = ref Info.ADVICE},
                                      information = {outstream = dummy_stream,
                                                     level = 2},
                                      listing = {outstream = dummy_stream,
                                                 level = 2},
                                      diagnostic = {outstream = dummy_stream,
                                                    level = 2}}
end
d98 1
a98 1
	  parse_topdec default_options (ts,pB)
@


1.4
log
@Added line number to token stream input functions.
@
text
@d4 3
d24 1
d30 1
d35 2
a36 2
                   sharing ActionFunctions.Lexer.Token = Token
                   sharing LRparser.Location = Absyn.Location
d39 1
a39 1
                   sharing LRparser.Error = ActionFunctions.Lexer.Error
d44 1
a44 1
structure Lexer = ActionFunctions.Lexer
d46 1
a46 1
structure Error = LRparser.Error
d58 1
a58 1
fun parse_topdec (ts,pB) =
d60 2
d64 1
a64 1
        val tok = Lexer.getToken ts
d70 1
a70 2
    ActionFunctions.tokenstream_ref := ts;
    (LRparser.parse_it (get_next, Lexer.is_interactive ts);
d75 1
a75 7
fun get_next_token tokenstream =
  let val token = (Lexer.getToken tokenstream)
  in
    token
  end

fun skip_topdec tokenstream =
d77 1
d79 1
a79 1
      case get_next_token tokenstream of
d86 15
d110 1
a110 1
	  parse_topdec (ts,pB)
d180 1
a180 1
  fun parse_incrementally (ts,pB,state) =
d182 1
d185 1
a185 1
          val tok = Lexer.getToken ts
d192 1
a192 1
              let val new_state = LRparser.parse_one_token(tok,location,state)
a200 1
      ActionFunctions.tokenstream_ref := ts;
@


1.3
log
@Added functions for incremental parsing.
@
text
@d4 3
d90 3
a92 4
	  val ts = Lexer.mkTokenStream (fn () => if !done then
					 ""
						  else
						    (done := true; s),"")
@


1.2
log
@Installed central error reporting mechanism.
@
text
@d4 3
d153 33
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log: _newparser.sml,v $
a14 1
require "parsing-errors";
a20 1
                   structure ParsingErrors : PARSINGERRORS
d25 1
a25 1
                   sharing type LRparser.Marks = Absyn.Source_marks
d28 2
a29 2
                   sharing type ActionFunctions.FinalValue = Absyn.TopDec
                     ) : PARSER =
d35 1
a42 2
exception ParseError of string

a46 8
fun get_linenum ts =
  (1 + Lexer.linenum ts,
   Lexer.linepos ts)

fun get_marks ts =
  Absyn.tuple_to_Source_marks(get_linenum ts)


d48 7
a54 7
  let fun get_next () =
    let
      val tok = Lexer.getToken ts
      val marks = get_marks ts
    in
      (tok,marks)
    end
a56 1
    ParsingErrors.reset_errors();
d58 3
a60 14
    let val topdec =
      (LRparser.parse_it (get_next, Lexer.is_interactive ts);
       Crash.impossible "Topdec not found in parser??!!")
       handle
       ActionFunctions.FoundTopDec x => x
     | exn as LRparser.SyntaxError =>
         raise ParseError "Parse failed"
    in
      if ParsingErrors.serious_error_occurred()
        then
          raise ParseError "Parse Failed"
      else
        topdec
    end
a67 1
  
@
