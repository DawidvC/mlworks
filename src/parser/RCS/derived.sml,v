head	1.26;
access;
symbols
	MLW_daveb_inline_1_4_99:1.26.3
	MLWorks_21c0_1999_03_25:1.26
	MLWorks_20c1_1998_08_20:1.26
	MLWorks_20c0_1998_08_04:1.26
	MLWorks_20b2c2_1998_06_19:1.26
	MLWorks_20b2_Windows_1998_06_12:1.26
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.26
	MLWorks_11r1:1.25.8.1.1.1.1
	MLWorks_workspace_97:1.26.2
	MLWorks_dt_wizard:1.26.1
	MLWorks_11c0_1997_09_09:1.25.8.1.1.1
	MLWorks_10r3:1.25.8.1.3
	MLWorks_10r2_551:1.25.8.1.2
	MLWorks_11:1.25.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.25.8.1
	MLWorks_20m0_1997_06_20:1.26
	MLWorks_1_0_r2c2_1997_06_14:1.25.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.25.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.25.8
	MLWorks_BugFix_1997_04_24:1.25
	MLWorks_1_0_r2_Win32_1997_04_11:1.25
	MLWorks_1_0_r2_Unix_1997_04_04:1.25
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.25.6.1.1
	MLWorks_gui_1996_12_18:1.25.7
	MLWorks_1_0_Win32_1996_12_17:1.25.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.25.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.25.4.1
	MLWorks_1_0_Irix_1996_11_28:1.25.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.25.5
	MLWorks_1_0_Unix_1996_11_14:1.25.4
	MLWorks_Open_Beta2_1996_10_11:1.25.3
	MLWorks_License_dev:1.25.2
	MLWorks_1_open_beta_1996_09_13:1.25.1
	MLWorks_Open_Beta_1996_08_22:1.25
	MLWorks_Beta_1996_07_02:1.25
	MLWorks_Beta_1996_06_07:1.25
	MLWorks_Beta_1996_06_06:1.25
	MLWorks_Beta_1996_06_05:1.25
	MLWorks_Beta_1996_06_03:1.25
	MLWorks_Beta_1996_05_31:1.25
	MLWorks_Beta_1996_05_30:1.25
	ML_beta_release_12/08/94:1.22
	ML_beta_release_03/08/94:1.22
	ML_revised_beta_release_25/05/94:1.22
	ML_final_beta_release_02/03/94:1.22
	mlworks-28-01-1994:1.21
	Release:1.19
	mlworks-beta-01-09-1993:1.19
	MLWorks-1-0-4-29/01/1993:1.14
	MLWorks-1-0-3-21/12/1992:1.14
	MLWorks-1-0-2-15/12/1992:1.14
	MLWorks-1-0-1-04/12/1992:1.14
	checkpoint_17_08_92:1.8
	Ten15_release_19-11-91:1.2.1.1
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.26
date	97.05.01.12.51.53;	author jont;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	96.03.25.12.49.51;	author matthew;	state Exp;
branches
	1.25.1.1
	1.25.2.1
	1.25.3.1
	1.25.4.1
	1.25.5.1
	1.25.6.1
	1.25.7.1
	1.25.8.1;
next	1.24;

1.24
date	95.12.27.10.44.22;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	95.02.14.12.11.53;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	94.02.22.01.33.33;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.12.08.10.57.34;	author nickh;	state Exp;
branches;
next	1.20;

1.20
date	93.08.13.15.52.54;	author nosa;	state Exp;
branches;
next	1.19;

1.19
date	93.08.06.13.21.49;	author matthew;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	93.06.01.08.39.04;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	93.03.09.11.16.41;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.02.23.13.53.49;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.02.08.19.25.02;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.11.19.19.17.31;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.11.05.15.55.52;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.10.09.13.32.52;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.09.11.11.46.16;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.09.08.16.32.24;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.09.04.08.56.37;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.08.05.16.04.42;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.05.19.10.56.56;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.05.01.09.44.40;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.04.13.13.29.12;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	91.11.21.16.37.03;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.19.12.21.15;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.27.13.55.18;	author colin;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	91.06.07.16.18.09;	author colin;	state Exp;
branches;
next	;

1.2.1.1
date	91.11.19.11.12.34;	author jont;	state Exp;
branches;
next	;

1.19.1.1
date	93.08.06.13.21.49;	author jont;	state Exp;
branches;
next	;

1.25.1.1
date	96.09.13.11.20.23;	author hope;	state Exp;
branches;
next	;

1.25.2.1
date	96.10.07.16.10.19;	author hope;	state Exp;
branches;
next	;

1.25.3.1
date	96.10.17.11.28.48;	author hope;	state Exp;
branches;
next	;

1.25.4.1
date	96.11.14.12.54.28;	author hope;	state Exp;
branches
	1.25.4.1.1.1;
next	;

1.25.4.1.1.1
date	96.11.28.15.05.19;	author hope;	state Exp;
branches;
next	;

1.25.5.1
date	96.11.22.18.13.09;	author hope;	state Exp;
branches;
next	;

1.25.6.1
date	96.12.17.17.51.38;	author hope;	state Exp;
branches
	1.25.6.1.1.1;
next	;

1.25.6.1.1.1
date	97.02.24.11.42.14;	author hope;	state Exp;
branches;
next	;

1.25.7.1
date	96.12.18.09.45.57;	author hope;	state Exp;
branches;
next	;

1.25.8.1
date	97.05.12.10.38.25;	author hope;	state Exp;
branches
	1.25.8.1.1.1
	1.25.8.1.2.1
	1.25.8.1.3.1;
next	;

1.25.8.1.1.1
date	97.07.28.18.23.45;	author daveb;	state Exp;
branches
	1.25.8.1.1.1.1.1;
next	;

1.25.8.1.1.1.1.1
date	97.10.07.11.49.27;	author jkbrook;	state Exp;
branches;
next	;

1.25.8.1.2.1
date	97.09.08.17.17.07;	author daveb;	state Exp;
branches;
next	;

1.25.8.1.3.1
date	97.09.09.14.13.15;	author daveb;	state Exp;
branches;
next	;

1.26.1.1
date	97.09.10.19.29.17;	author brucem;	state Exp;
branches;
next	;

1.26.2.1
date	97.09.11.20.59.12;	author daveb;	state Exp;
branches;
next	;

1.26.3.1
date	99.04.01.17.59.35;	author daveb;	state Exp;
branches;
next	;


desc
@Code for producing abstract syntax for SML derived forms
@


1.26
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(* derived.sml the signature *)
(*
$Log: derived.sml,v $
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
 * Revision 1.24  1995/12/27  10:44:22  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.23  1995/02/14  12:11:53  matthew
Removing Options structure

Revision 1.22  1994/02/22  01:33:33  nosa
Type function recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.

Revision 1.21  1993/12/08  10:57:34  nickh
Change the types of the withtype functions to take an Info.options.

Revision 1.20  1993/08/13  15:52:54  nosa
structure Options.

Revision 1.19  1993/08/06  13:21:49  matthew
Added location information to matches

Revision 1.18  1993/06/01  08:39:04  nosa
structure Option.

Revision 1.17  1993/03/09  11:16:41  matthew
Options & Info changes
Absyn changes

Revision 1.16  1993/02/23  13:53:49  matthew
Added parser env parameter.  Removed open Datatypes

Revision 1.15  1993/02/08  19:25:02  matthew
ref Nameset removed from FunBind abstract syntax

Revision 1.14  1992/11/19  19:17:31  jont
Removed Info structure from parser, tidied upderived

Revision 1.13  1992/11/05  15:55:52  matthew
Changed Error structure to Info

Revision 1.12  1992/10/09  13:32:52  clive
Tynames now have a slot recording their definition point

Revision 1.11  1992/09/11  11:46:16  matthew
Added generation of local uncurried versions of curried functions.
Also don't generate intermediate functions in uncurried case.

Revision 1.10  1992/09/08  16:32:24  matthew
Improved error messages.

Revision 1.9  1992/09/04  08:56:37  richard
Installed central error reporting mechanism.

Revision 1.8  1992/08/05  16:04:42  jont
Removed some structures and sharing

Revision 1.7  1992/05/19  10:56:56  clive
Added marks to allow position reporting from the typechecker

Revision 1.6  1992/05/01  09:44:40  clive
Added more useful annotations to if,while,case statements to give better info in a stack backtrace

Revision 1.5  1992/04/13  13:29:12  clive
First version of the profiler

Revision 1.4  1991/11/21  16:37:03  jont
Added copyright message

Revision 1.3  91/11/19  12:21:15  jont
Merging in comments from Ten15 branch to main trunk

Revision 1.2.1.1  91/11/19  11:12:34  jont
Added comments for DRA on functions

Revision 1.2  91/06/27  13:55:18  colin
changed to handle Interface annotations in signature expressions

Revision 1.1  91/06/07  16:18:09  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(* This module provides (to the parser module) functions to produce
abstract syntax trees for the Derived forms of the ML language, i.e.
those parts of the language which are defined in terms of the Bare
language. The abstract syntax which we use is just that of the Bare
language (which enables us to ensure conformance with the Definition
Semantics, which only deal with the Bare language), so the parser must
convert Derived forms into Bare forms.

For details see Appendix A of the definition.

All of these functions have a very straightforward implementation. *)

require "../basics/absyn";
require "../main/info";
require "parserenv";

signature DERIVED =
  sig

    structure Absyn  : ABSYN
    structure Info : INFO
    structure PE : PARSERENV

    sharing Info.Location = Absyn.Ident.Location
    sharing Absyn.Ident = PE.Ident

    (* generally useful functions *)
    val new_var : unit -> Absyn.Ident.LongValId
    val new_vars : int -> Absyn.Ident.LongValId list

    (* type expressions *)
    val make_tuple_ty : Absyn.Ty list -> Absyn.Ty

    (* expressions *)
    val make_unit_exp : unit -> Absyn.Exp
    val make_tuple_exp : Absyn.Exp list -> Absyn.Exp
    val make_select : Absyn.Ident.Lab * Absyn.Ident.Location.T * string -> Absyn.Exp
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list 
      * string * Absyn.Ident.Location.T -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string 
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string 
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string 
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_sequence_exp : (Absyn.Exp * string 
                             * Absyn.Ident.Location.T) list  -> Absyn.Exp
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) 
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_list_exp : (Absyn.Exp list * Absyn.Ident.Location.T * PE.pE) -> Absyn.Exp

    (* patterns *)
    val make_unit_pat : unit -> Absyn.Pat
    val make_tuple_pat : Absyn.Pat list -> Absyn.Pat
    val make_list_pat : Absyn.Pat list * Absyn.Ident.Location.T * PE.pE -> Absyn.Pat


    (* pattern rows *)
    val make_patrow :
      Absyn.Ident.Symbol.Symbol * Absyn.Ty option 
      * Absyn.Pat option * Absyn.Ident.Location.T
      -> Absyn.Ident.Lab * Absyn.Pat
  
    exception FvalBind of string

    (* function value bindings *) 
    val make_fvalbind :
      ((Absyn.Ident.ValId * Absyn.Pat list * Absyn.Exp * Absyn.Ident.Location.T) list 
       * (string -> string) * Info.Location.T) * Info.options
      -> (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list

    (* declarations *)
    val make_it_strdec :
      Absyn.Exp *
      Absyn.Ident.TyVar Absyn.Set.Set * 
      Absyn.Ident.Location.T * PE.pE ->
      Absyn.TopDec

    val make_fun : 
      (Absyn.Pat * Absyn.Exp * Absyn.Ident.Location.T) list list * 
      Absyn.Ident.TyVar Absyn.Set.Set * Absyn.Ident.TyVar list *
      Absyn.Ident.Location.T  -> Absyn.Dec

    val make_datatype_withtype : 
      Absyn.Ident.Location.T *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref option * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty option) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref option) list *
      Info.options -> Absyn.Dec

    val make_abstype_withtype : 
      Absyn.Ident.Location.T *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref option * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty option) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref option) list * Absyn.Dec *
      Info.options -> Absyn.Dec
     
    (* modules *)

    val make_strexp : Absyn.StrDec -> Absyn.StrExp 
      
    val make_funbind : 
      (Absyn.Ident.FunId * Absyn.SigExp * Absyn.StrExp * (Absyn.SigExp * bool) option 
       * Absyn.Ident.Location.T) ->
      (Absyn.Ident.FunId * Absyn.Ident.StrId * Absyn.SigExp * Absyn.StrExp 
       * (Absyn.SigExp * bool) option)
      

  end    
@


1.26.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.26  1997/05/01  12:51:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.26.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.26  1997/05/01  12:51:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.26.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.26  1997/05/01  12:51:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.25
log
@Explicit type variables in VALdecs
@
text
@d4 3
d147 2
a148 2
      Absyn.Ident.Symbol.Symbol * Absyn.Ty MLWorks.Option.option 
      * Absyn.Pat MLWorks.Option.option * Absyn.Ident.Location.T
d173 3
a175 3
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref MLWorks.Option.option * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty MLWorks.Option.option) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref MLWorks.Option.option) list *
d180 3
a182 3
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref MLWorks.Option.option * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty MLWorks.Option.option) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref MLWorks.Option.option) list * Absyn.Dec *
d190 1
a190 1
      (Absyn.Ident.FunId * Absyn.SigExp * Absyn.StrExp * (Absyn.SigExp * bool) MLWorks.Option.option 
d193 1
a193 1
       * (Absyn.SigExp * bool) MLWorks.Option.option)
@


1.25.8.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.25.8.1  1997/05/12  10:38:25  hope
 * branched from 1.25
 *
@


1.25.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.25.8.1  1997/05/12  10:38:25  hope
 * branched from 1.25
 *
@


1.25.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.25.8.1  1997/05/12  10:38:25  hope
 * branched from 1.25
 *
@


1.25.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.25.8.1.1.1  1997/07/28  18:23:45  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25.7.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.6.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.6.1.1.1
log
@branched from 1.25.6.1
@
text
@a3 3
 * Revision 1.25.6.1  1996/12/17  17:51:38  hope
 * branched from 1.25
 *
@


1.25.5.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.4.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.4.1.1.1
log
@branched from 1.25.4.1
@
text
@a3 3
 * Revision 1.25.4.1  1996/11/14  12:54:28  hope
 * branched from 1.25
 *
@


1.25.3.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.2.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.25.1.1
log
@branched from 1.25
@
text
@a3 3
 * Revision 1.25  1996/03/25  12:49:51  matthew
 * Explicit type variables in VALdecs
 *
@


1.24
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d165 1
a165 1
      Absyn.Ident.TyVar Absyn.Set.Set *
d187 1
a187 1
      (Absyn.Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp MLWorks.Option.option 
d190 1
a190 1
       * Absyn.SigExp MLWorks.Option.option)
@


1.23
log
@Removing Options structure
@
text
@d4 3
d141 2
a142 2
      Absyn.Ident.Symbol.Symbol * Absyn.Ty Absyn.Option.opt 
      * Absyn.Pat Absyn.Option.opt * Absyn.Ident.Location.T
d167 3
a169 3
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref Absyn.Option.opt * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty Absyn.Option.opt) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref Absyn.Option.opt) list *
d174 3
a176 3
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * Absyn.Tyfun ref Absyn.Option.opt * 
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty Absyn.Option.opt) list) list *
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty * Absyn.Tyfun ref Absyn.Option.opt) list * Absyn.Dec *
d184 1
a184 1
      (Absyn.Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.Option.opt 
d187 1
a187 1
       * Absyn.SigExp Absyn.Option.opt)
@


1.22
log
@Type function recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.
@
text
@d4 4
a92 1
require "../main/options";
a99 1
    structure Options : OPTIONS
@


1.21
log
@Change the types of the withtype functions to take an Info.options.
@
text
@d4 3
d113 1
a113 1
    val make_select : Absyn.Ident.Lab * Absyn.Ident.Location.T * string * Options.options -> Absyn.Exp
d119 1
a119 1
      * Absyn.Ident.Location.T * PE.pE  * Options.options -> Absyn.Exp
d121 1
a121 1
      * Absyn.Ident.Location.T * PE.pE  * Options.options -> Absyn.Exp
d125 2
a126 2
      * Absyn.Ident.Location.T * PE.pE  * Options.options -> Absyn.Exp
    val make_list_exp : (Absyn.Exp list * Absyn.Ident.Location.T * PE.pE * Options.options) -> Absyn.Exp
d145 1
a145 1
       * (string -> string) * Info.Location.T) * Info.options  * Options.options
d158 1
a158 1
      Absyn.Ident.Location.T  * Options.options -> Absyn.Dec
d162 1
a162 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * 
d164 1
a164 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty) list *
d169 1
a169 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Type ref * 
d171 1
a171 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty) list * Absyn.Dec *
@


1.20
log
@structure Options.
@
text
@d4 3
d161 2
a162 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty) list -> Absyn.Dec
d168 2
a169 1
      (Absyn.Ident.TyVar list * Absyn.Ident.TyCon * Absyn.Ty) list * Absyn.Dec -> Absyn.Dec
@


1.19
log
@Added location information to matches
@
text
@d4 3
d83 1
d91 1
d107 1
a107 1
    val make_select : Absyn.Ident.Lab * Absyn.Ident.Location.T * string -> Absyn.Exp
d113 1
a113 1
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
d115 1
a115 1
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
d119 2
a120 2
      * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_list_exp : (Absyn.Exp list * Absyn.Ident.Location.T * PE.pE) -> Absyn.Exp
d139 1
a139 1
       * (string -> string) * Info.Location.T) * Info.options
d152 1
a152 1
      Absyn.Ident.Location.T -> Absyn.Dec
@


1.19.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.19  1993/08/06  13:21:49  matthew
Added location information to matches

@


1.18
log
@structure Option.
@
text
@d4 3
d103 1
a103 1
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list 
d133 1
a133 1
      ((Absyn.Ident.ValId * Absyn.Pat list * Absyn.Exp ) list 
d135 1
a135 1
      -> (Absyn.Pat * Absyn.Exp) list
d145 3
a147 2
      (Absyn.Pat * Absyn.Exp) list list * Absyn.Ident.TyVar Absyn.Set.Set 
      * Absyn.Ident.Location.T -> Absyn.Dec
@


1.17
log
@Options & Info changes
Absyn changes
@
text
@d4 4
d100 12
a111 6
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list * string * Absyn.Ident.Location.T -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
    val make_sequence_exp : (Absyn.Exp * string * Absyn.Ident.Location.T) list  -> Absyn.Exp
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) * Absyn.Ident.Location.T * PE.pE -> Absyn.Exp
d122 2
a123 1
      Absyn.Ident.Symbol.Symbol * Absyn.Ty Absyn.opt * Absyn.Pat Absyn.opt * Absyn.Ident.Location.T
d130 2
a131 1
      ((Absyn.Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) * Info.Location.T) * Info.options
d142 2
a143 1
      (Absyn.Pat * Absyn.Exp) list list * Absyn.Ident.TyVar Absyn.Set.Set * Absyn.Ident.Location.T -> Absyn.Dec
d148 1
a148 1
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty Absyn.opt) list) list *
d154 1
a154 1
       ((Absyn.Ident.ValId * Absyn.Type ref) * Absyn.Ty Absyn.opt) list) list *
d162 4
a165 2
      (Absyn.Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * Absyn.Ident.Location.T) ->
      (Absyn.Ident.FunId * Absyn.Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt)
@


1.16
log
@Added parser env parameter.  Removed open Datatypes
@
text
@d4 3
d82 2
a83 2
    sharing Info.Location = Absyn.Location
    sharing Absyn.Datatypes.Ident = PE.Ident
d86 2
a87 2
    val new_var : unit -> Absyn.Datatypes.Ident.LongValId
    val new_vars : int -> Absyn.Datatypes.Ident.LongValId list
d95 8
a102 8
    val make_select : Absyn.Datatypes.Ident.Lab * Absyn.Location.T * string -> Absyn.Exp
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list * string * Absyn.Location.T -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string * Absyn.Location.T * PE.pE -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string * Absyn.Location.T * PE.pE -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string * Absyn.Location.T * PE.pE -> Absyn.Exp
    val make_sequence_exp : (Absyn.Exp * string * Absyn.Location.T) list  -> Absyn.Exp
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) * Absyn.Location.T * PE.pE -> Absyn.Exp
    val make_list_exp : (Absyn.Exp list * Absyn.Location.T * PE.pE) -> Absyn.Exp
d107 1
a107 1
    val make_list_pat : Absyn.Pat list * Absyn.Location.T * PE.pE -> Absyn.Pat
d112 2
a113 2
      Absyn.Datatypes.Ident.Symbol.Symbol * Absyn.Ty Absyn.opt * Absyn.Pat Absyn.opt * Absyn.Location.T
      -> Absyn.Datatypes.Ident.Lab * Absyn.Pat
d119 1
a119 1
      ((Absyn.Datatypes.Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) * Info.Location.T) * Info.options
d125 2
a126 2
      Absyn.Datatypes.Ident.TyVar Absyn.Set.Set * 
      Absyn.Location.T * PE.pE ->
d130 1
a130 1
      (Absyn.Pat * Absyn.Exp) list list * Absyn.Datatypes.Ident.TyVar Absyn.Set.Set * Absyn.Location.T -> Absyn.Dec
d133 4
a136 4
      Absyn.Location.T *
      (Absyn.Datatypes.Ident.TyVar list * Absyn.Datatypes.Ident.TyCon * Absyn.Datatypes.Type ref * 
       ((Absyn.Datatypes.Ident.ValId * Absyn.Datatypes.Type ref) * Absyn.Ty Absyn.opt) list) list *
      (Absyn.Datatypes.Ident.TyVar list * Absyn.Datatypes.Ident.TyCon * Absyn.Ty) list -> Absyn.Dec
d139 4
a142 4
      Absyn.Location.T *
      (Absyn.Datatypes.Ident.TyVar list * Absyn.Datatypes.Ident.TyCon * Absyn.Datatypes.Type ref * 
       ((Absyn.Datatypes.Ident.ValId * Absyn.Datatypes.Type ref) * Absyn.Ty Absyn.opt) list) list *
      (Absyn.Datatypes.Ident.TyVar list * Absyn.Datatypes.Ident.TyCon * Absyn.Ty) list * Absyn.Dec -> Absyn.Dec
d149 2
a150 2
      (Absyn.Datatypes.Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * Absyn.Location.T) ->
      (Absyn.Datatypes.Ident.FunId * Absyn.Datatypes.Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt)
@


1.15
log
@ref Nameset removed from FunBind abstract syntax
@
text
@d4 3
d70 1
d77 1
d80 1
a80 2

    open Absyn.Datatypes
d83 2
a84 2
    val new_var : unit -> Ident.LongValId
    val new_vars : int -> Ident.LongValId list
d92 1
a92 1
    val make_select : Ident.Lab * Absyn.Location.T * string -> Absyn.Exp
d94 3
a96 3
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string * Absyn.Location.T -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string * Absyn.Location.T -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string * Absyn.Location.T -> Absyn.Exp
d98 2
a99 2
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) * Absyn.Location.T -> Absyn.Exp
    val make_list_exp : Absyn.Location.T -> Absyn.Exp list -> Absyn.Exp
d104 1
a104 1
    val make_list_pat : Absyn.Pat list * Absyn.Location.T -> Absyn.Pat
d110 1
a110 1
      -> Ident.Lab * Absyn.Pat
d116 1
a116 1
      ((Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) * Info.Location.T) * Info.options
d120 6
d127 1
a127 1
      (Absyn.Pat * Absyn.Exp) list list * Ident.TyVar Absyn.Set.Set * Absyn.Location.T -> Absyn.Dec
d131 3
a133 3
      (Ident.TyVar list * Ident.TyCon * Type ref * 
       ((Ident.ValId * Type ref) * Absyn.Ty Absyn.opt) list) list *
      (Ident.TyVar list * Ident.TyCon * Absyn.Ty) list -> Absyn.Dec
d137 3
a139 3
      (Ident.TyVar list * Ident.TyCon * Type ref * 
       ((Ident.ValId * Type ref) * Absyn.Ty Absyn.opt) list) list *
      (Ident.TyVar list * Ident.TyCon * Absyn.Ty) list * Absyn.Dec -> Absyn.Dec
d146 2
a147 2
      (Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * Absyn.Location.T) ->
      (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt)
@


1.14
log
@Removed Info structure from parser, tidied upderived
@
text
@d4 3
d137 1
a137 2
      (Ident.FunId * Ident.StrId * Absyn.SigExp * Absyn.Nameset.Nameset ref *
       Absyn.StrExp * Absyn.SigExp Absyn.opt)
@


1.13
log
@Changed Error structure to Info
@
text
@d4 3
a62 1
require "../basics/symbol";
a68 1
    structure Symbol : SYMBOL
a70 1
    sharing Absyn.Datatypes.Ident.Symbol = Symbol
d102 1
a102 1
      Symbol.Symbol * Absyn.Ty Absyn.opt * Absyn.Pat Absyn.opt * Absyn.Location.T
@


1.12
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d61 1
d68 1
d71 1
d109 1
a109 1
      (Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) * Absyn.Location.T 
@


1.11
log
@Added generation of local uncurried versions of curried functions.
Also don't generate intermediate functions in uncurried case.
@
text
@d4 4
d111 2
a112 1
      (Ident.TyVar list * Ident.TyCon * Type ref *
d117 2
a118 1
      (Ident.TyVar list * Ident.TyCon * Type ref *
@


1.10
log
@Improved error messages.
@
text
@d4 3
d100 1
a100 1
      -> Absyn.Pat * Absyn.Exp
d104 1
a104 1
      (Absyn.Pat * Absyn.Exp) list * Ident.TyVar Absyn.Set.Set * Absyn.Location.T -> Absyn.Dec
@


1.9
log
@Installed central error reporting mechanism.
@
text
@d4 3
d84 1
a84 1
    val make_list_pat : Absyn.Pat list -> Absyn.Pat
d89 1
a89 1
      Symbol.Symbol * Absyn.Ty Absyn.opt * Absyn.Pat Absyn.opt
@


1.8
log
@Removed some structures and sharing
@
text
@d4 3
d69 8
a76 8
    val make_select : Ident.Lab * Absyn.Source_marks * string -> Absyn.Exp
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list * string * Absyn.Source_marks -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string * Absyn.Source_marks -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string * Absyn.Source_marks -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string * Absyn.Source_marks -> Absyn.Exp
    val make_sequence_exp : (Absyn.Exp * string * Absyn.Source_marks) list  -> Absyn.Exp
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) * Absyn.Source_marks -> Absyn.Exp
    val make_list_exp : Absyn.Source_marks -> Absyn.Exp list -> Absyn.Exp
d93 1
a93 1
      (Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) * Absyn.Source_marks 
d98 1
a98 1
      (Absyn.Pat * Absyn.Exp) list * Ident.TyVar Absyn.Set.Set * Absyn.Source_marks -> Absyn.Dec
d115 1
a115 1
      (Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt * Absyn.Source_marks) ->
@


1.7
log
@Added marks to allow position reporting from the typechecker
@
text
@d4 3
a42 2
require "../typechecker/datatypes";
require "../typechecker/nameset";
a44 1
require "../utils/set";
a48 2
    structure Datatypes : DATATYPES
    structure Nameset : NAMESET
a50 1
    structure Set : SET
d52 1
a52 4
    sharing Datatypes = Absyn.Datatypes
    sharing Absyn.IdentClass = Datatypes.Ident
    sharing Datatypes.Ident.Symbol = Symbol
    sharing Absyn.Nameset = Nameset
d54 1
a54 1
    open Datatypes
d95 1
a95 1
      (Absyn.Pat * Absyn.Exp) list * Ident.TyVar Set.Set * Absyn.Source_marks -> Absyn.Dec
d113 1
a113 1
      (Ident.FunId * Ident.StrId * Absyn.SigExp * Nameset.Nameset ref *
@


1.6
log
@Added more useful annotations to if,while,case statements to give better info in a stack backtrace
@
text
@d4 3
d72 8
a79 8
    val make_select : Ident.Lab -> Absyn.Exp
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list * string -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp * string -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp * string -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp * string -> Absyn.Exp
    val make_sequence_exp : (Absyn.Exp * string) list  -> Absyn.Exp
    val make_while : Absyn.Exp * Absyn.Exp * (string -> string) -> Absyn.Exp
    val make_list_exp : Absyn.Exp list -> Absyn.Exp
d96 2
a97 1
      (Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * (string -> string) -> Absyn.Pat * Absyn.Exp
d101 1
a101 1
      (Absyn.Pat * Absyn.Exp) list * Ident.TyVar Set.Set -> Absyn.Dec
d118 1
a118 1
      (Ident.FunId * Absyn.SigExp * Absyn.StrExp * Absyn.SigExp Absyn.opt) ->
@


1.5
log
@First version of the profiler
@
text
@d4 3
d70 5
a74 5
    val make_case : Absyn.Exp * (Absyn.Pat * Absyn.Exp) list -> Absyn.Exp
    val make_if : Absyn.Exp * Absyn.Exp * Absyn.Exp -> Absyn.Exp
    val make_orelse : Absyn.Exp * Absyn.Exp -> Absyn.Exp
    val make_andalso : Absyn.Exp * Absyn.Exp -> Absyn.Exp
    val make_sequence_exp : Absyn.Exp list -> Absyn.Exp
@


1.4
log
@Added copyright message
@
text
@d3 4
a6 1
$Log:	derived.sml,v $
d72 1
a72 1
    val make_while : Absyn.Exp * Absyn.Exp -> Absyn.Exp
d90 1
a90 1
      (Ident.ValId * Absyn.Pat list * Absyn.Exp ) list * int list -> Absyn.Pat * Absyn.Exp
@


1.3
log
@Merging in comments from Ten15 branch to main trunk
@
text
@d1 1
d4 3
d16 1
@


1.2
log
@changed to handle Interface annotations in signature expressions
@
text
@d3 6
d13 13
@


1.2.1.1
log
@Added comments for DRA on functions
@
text
@a2 3
Revision 1.2  91/06/27  13:55:18  colin
changed to handle Interface annotations in signature expressions

a6 13

(* This module provides (to the parser module) functions to produce
abstract syntax trees for the Derived forms of the ML language, i.e.
those parts of the language which are defined in terms of the Bare
language. The abstract syntax which we use is just that of the Bare
language (which enables us to ensure conformance with the Definition
Semantics, which only deal with the Bare language), so the parser must
convert Derived forms into Bare forms.

For details see Appendix A of the definition.

All of these functions have a very straightforward implementation. *)

@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d84 1
a84 1
      (Ident.FunId * Absyn.Spec * Absyn.StrExp * Absyn.SigExp Absyn.opt) ->
@
