head	1.22;
access;
symbols
	MLW_daveb_inline_1_4_99:1.22.1
	MLWorks_21c0_1999_03_25:1.22
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.22
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.20.5.1.1.1.1
	MLWorks_workspace_97:1.21.2
	MLWorks_dt_wizard:1.21.1
	MLWorks_11c0_1997_09_09:1.20.5.1.1.1
	MLWorks_10r3:1.20.5.1.3
	MLWorks_10r2_551:1.20.5.1.2
	MLWorks_11:1.20.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.20.5.1
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.20.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.20.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.20.5
	MLWorks_BugFix_1997_04_24:1.20
	MLWorks_1_0_r2_Win32_1997_04_11:1.20
	MLWorks_1_0_r2_Unix_1997_04_04:1.20
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.20.3.1.1
	MLWorks_gui_1996_12_18:1.20.4
	MLWorks_1_0_Win32_1996_12_17:1.20.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.20.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.20.1.1
	MLWorks_1_0_Irix_1996_11_28:1.20.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.2
	MLWorks_1_0_Unix_1996_11_14:1.20.1
	MLWorks_Open_Beta2_1996_10_11:1.19.3
	MLWorks_License_dev:1.19.2
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.19
	MLWorks_Beta_1996_06_07:1.19
	MLWorks_Beta_1996_06_06:1.19
	MLWorks_Beta_1996_06_05:1.19
	MLWorks_Beta_1996_06_03:1.19
	MLWorks_Beta_1996_05_31:1.19
	MLWorks_Beta_1996_05_30:1.19
	ML_beta_release_12/08/94:1.13
	ML_beta_release_03/08/94:1.13
	ML_revised_beta_release_25/05/94:1.13
	ML_final_beta_release_02/03/94:1.13
	mlworks-28-01-1994:1.12
	Release:1.12
	mlworks-beta-01-09-1993:1.12
	MLWorks-1-0-4-29/01/1993:1.10
	MLWorks-1-0-3-21/12/1992:1.10
	MLWorks-1-0-2-15/12/1992:1.10
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.7
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.22
date	98.02.19.16.34.03;	author mitchell;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	97.05.01.13.17.36;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1;
next	1.20;

1.20
date	96.10.25.13.21.55;	author andreww;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1
	1.20.5.1;
next	1.19;

1.19
date	96.03.19.14.30.10;	author matthew;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1;
next	1.18;

1.18
date	96.02.23.16.55.26;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.04.12.13.26.39;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.02.06.13.20.58;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	94.10.13.10.26.00;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	94.10.06.09.35.40;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.12.03.12.49.00;	author nosa;	state Exp;
branches;
next	1.12;

1.12
date	93.04.26.16.13.54;	author jont;	state Exp;
branches
	1.12.1.1;
next	1.11;

1.11
date	93.02.17.17.38.55;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	92.10.27.18.55.32;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.08.26.13.02.32;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	92.08.18.17.20.27;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.08.05.16.24.35;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.03.30.11.23.32;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.02.27.17.34.08;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.12.17.15.56.57;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.21.16.36.37;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.11.16.39.33;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.16.18.00;	author colin;	state Exp;
branches;
next	;

1.12.1.1
date	93.04.26.16.13.54;	author jont;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.20.32;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.10.07.16.10.29;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.10.17.11.29.00;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.11.14.12.54.43;	author hope;	state Exp;
branches
	1.20.1.1.1.1;
next	;

1.20.1.1.1.1
date	96.11.28.15.05.30;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.11.22.18.13.19;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.12.17.17.51.47;	author hope;	state Exp;
branches
	1.20.3.1.1.1;
next	;

1.20.3.1.1.1
date	97.02.24.11.42.28;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	96.12.18.09.46.06;	author hope;	state Exp;
branches;
next	;

1.20.5.1
date	97.05.12.10.38.36;	author hope;	state Exp;
branches
	1.20.5.1.1.1
	1.20.5.1.2.1
	1.20.5.1.3.1;
next	;

1.20.5.1.1.1
date	97.07.28.18.23.36;	author daveb;	state Exp;
branches
	1.20.5.1.1.1.1.1;
next	;

1.20.5.1.1.1.1.1
date	97.10.07.11.49.20;	author jkbrook;	state Exp;
branches;
next	;

1.20.5.1.2.1
date	97.09.08.17.17.00;	author daveb;	state Exp;
branches;
next	;

1.20.5.1.3.1
date	97.09.09.14.13.06;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	97.09.10.19.29.09;	author brucem;	state Exp;
branches;
next	;

1.21.2.1
date	97.09.11.20.59.04;	author daveb;	state Exp;
branches;
next	;

1.22.1.1
date	99.04.01.17.59.30;	author daveb;	state Exp;
branches;
next	;


desc
@Parser Environment datatypes + manipulating functions
(Used to handle fixity and resolve identifier classes)
@


1.22
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _parserenv.sml the functor *)
(*
$Log: _parserenv.sml,v $
 * Revision 1.21  1997/05/01  13:17:36  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
 * Revision 1.19  1996/03/19  14:30:10  matthew
 * Adding unique_augment_pE
 *
 * Revision 1.18  1996/02/23  16:55:26  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.17  1995/04/12  13:26:39  matthew
 * Adding exception raising long valid lookup
 *
Revision 1.16  1995/02/06  13:20:58  matthew
Improving lookup error messages

Revision 1.15  1994/10/13  10:26:00  matthew
Added option-returning tryLookupValid

Revision 1.14  1994/10/06  09:35:40  matthew
Remove uses of Map.empty'

Revision 1.13  1993/12/03  12:49:00  nosa
TYCON' for type function functions in lambda code for Modules Debugger.

Revision 1.12  1993/04/26  16:13:54  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

Revision 1.11  1993/02/17  17:38:55  matthew
Changed to generate errors when an unbound signature,structure,functor or constructor
name is used.

Revision 1.10  1992/10/27  18:55:32  jont
Modified to use less than functions for maps

Revision 1.9  1992/08/26  13:02:32  matthew
Changed error parameter to addValid etc.

Revision 1.8  1992/08/18  17:20:27  davidt
Removed Symbol structure from result and changed everything to use NewMap.

Revision 1.7  1992/08/05  16:24:35  jont
Removed some structures and sharing

Revision 1.6  1992/03/30  11:23:32  matthew
Added some more exception handlers

Revision 1.5  1992/02/27  17:34:08  jont
Changed to use equality functions for all maps, and to remove
use of exceptions to detect seen

Revision 1.4  1991/12/17  15:56:57  jont
Added addFixity for updating a fixity env for the benefit of the
encapsulator

Revision 1.3  91/11/21  16:36:37  jont
Added copyright message

Revision 1.2  91/07/11  16:39:33  colin
Made lookupStrId, lookupFunId and lookupSigId return empty environment
if Lookup fails

Revision 1.1  91/06/07  16:18:00  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "parserenv";
require "../utils/lists";
require "../utils/map";
require "../basics/ident";

(* parser environment stuff *)

functor ParserEnv
  (structure Lists : LISTS
   structure Map   : MAP
   structure Ident : IDENT
     ) : PARSERENV =
  struct
    structure Map = Map
    structure Ident = Ident
    structure Symbol = Ident.Symbol

    datatype Fixity = LEFT of int | RIGHT of int | NONFIX

    datatype
      pFE = FE of (Symbol.Symbol,Fixity) Map.map
    and
      pVE = VE of (Symbol.Symbol,Ident.ValId) Map.map
    and 
      pTE = TE of (Ident.TyCon,pVE) Map.map
    and
      pSE = SE of (Ident.StrId,pE) Map.map
    and
      pE = E of (pFE * pVE * pTE * pSE)
      
    datatype
      pF = F of (Ident.FunId,pE) Map.map
    and
      pG = G of (Ident.SigId,pE * Ident.TyCon list) Map.map
      
    datatype pB = B of (pF * pG * pE)

    val empty_pFE = FE(Map.empty (Symbol.symbol_lt,Symbol.eq_symbol))
    val empty_pVE = VE(Map.empty (Symbol.symbol_lt,Symbol.eq_symbol))
    val empty_pTE = TE(Map.empty (Ident.tycon_lt,Ident.tycon_eq))
    val empty_pSE = SE(Map.empty (Ident.strid_lt,Ident.strid_eq))
    val empty_pE  = E(empty_pFE,empty_pVE,empty_pTE,empty_pSE)

      (* the following is the parser type constructor environment
         for the builtin datatypes: bool, list and ref. *)
         
    local
      val true_sym = Symbol.find_symbol "true"
      val false_sym = Symbol.find_symbol "false"
      val bool_sym = Symbol.find_symbol "bool"
      val ref_sym = Symbol.find_symbol "ref"
      val cons_sym = Symbol.find_symbol "::"
      val nil_sym = Symbol.find_symbol "nil"
      val list_sym = Symbol.find_symbol "list"


      val bool_pVE = VE (Map.from_list (Symbol.symbol_lt,Symbol.eq_symbol)
                         [(true_sym,Ident.CON true_sym),
                          (false_sym, Ident.CON false_sym)])
      val ref_pVE = VE (Map.from_list (Symbol.symbol_lt,Symbol.eq_symbol)
                         [(ref_sym,Ident.CON ref_sym)])
      val list_pVE = VE (Map.from_list (Symbol.symbol_lt,Symbol.eq_symbol)
                         [(cons_sym,Ident.CON cons_sym),
                          (nil_sym,Ident.CON nil_sym)])

      val builtins_pTE = TE(Map.from_list (Ident.tycon_lt,Ident.tycon_eq)
                            [(Ident.TYCON bool_sym,bool_pVE),
                             (Ident.TYCON ref_sym, ref_pVE),
                             (Ident.TYCON list_sym, list_pVE)])
    in
      val builtins_pE = E(empty_pFE,empty_pVE,builtins_pTE,empty_pSE)
    end




    fun augment_pE (E(FE fe,VE ve,TE te,SE se),
                    E(FE fe',VE ve',TE te',SE se')) =
      E(FE (Map.union (fe,fe')), VE (Map.union (ve,ve')),
        TE (Map.union (te,te')), SE (Map.union (se,se')))
      
    fun unique_augment_pE ((valid_fn,strid_fn),E(FE fe,VE ve,TE te,SE se), 
                           E(FE fe',VE ve',TE te',SE se')) =
      E(FE (Map.union (fe,fe')), 
        VE (Map.merge (fn (x,a,b) => (ignore(valid_fn a);b))(ve,ve')),
        TE (Map.merge (fn (x,a,b) => b)             (te,te')),
        SE (Map.merge (fn (x,a,b) => (ignore(strid_fn x);b))(se,se')))
      
    val empty_pF = F(Map.empty (Ident.funid_lt,Ident.funid_eq))
    val empty_pG = G(Map.empty (Ident.sigid_lt,Ident.sigid_eq))
    val empty_pB = B (empty_pF,empty_pG,empty_pE)

    fun augment_pF (F map,F map') =
      F (Map.union (map,map'))

    fun augment_pG (G map,G map') =
      G (Map.union (map,map'))

    fun augment_pB (B(F f,G g,pE),B(F f',G g',pE')) =
      B (F (Map.union (f,f')), G (Map.union (g,g')), (augment_pE (pE,pE')))

    fun remove_str (B(f, g, E(fE, vE, tE, SE sE)), strid) =
      B(f, g, E(fE, vE, tE, SE(Map.undefine(sE, strid))))

    fun lookupFixity (sym, E (FE map,_,_,_)) =
      Map.apply_default'(map, NONFIX, sym)
      
    exception Lookup = Map.Undefined

    exception LookupStrId of Symbol.Symbol

    (* This one raises LookupStrId if it can't find a structure Id *)
    fun lookupValId ((syms,sym),pe) =
      let
        fun follow ([],pe) = pe
          | follow (sym ::strids,E(_,_,_,SE map)) =
            case Map.tryApply'(map,Ident.STRID sym) of
              SOME pe' => follow (strids,pe')
            | _ => raise LookupStrId sym
        val (E (_,VE map,_,_)) = follow (syms,pe)
      in
        Map.tryApply'(map, sym)
      end

    fun tryLookupValId ((syms,sym),pe) =
      let
        fun follow ([],pe) = SOME pe
          | follow (sym ::strids,E(_,_,_,SE map)) =
            case Map.tryApply'(map,Ident.STRID sym) of
              SOME pe' => follow (strids,pe')
            | _ => NONE
      in
        case follow (syms,pe) of
          SOME (E (_,VE map,_,_)) => Map.tryApply'(map, sym)
        | _ => NONE
      end

    (* This one raises LookupStrId if it can't find a structure Id *)
    fun lookupTycon (Ident.LONGTYCON(path,tycon),pe) =
      let
        fun follower (strId as Ident.STRID sym,E(_,_,_,SE map)) = 
            case Map.tryApply'(map, strId)
              of SOME pe' => pe'
               | _ => raise LookupStrId sym
        val (E (_,_,TE map,_)) = Ident.followPath follower (path,pe)
      in
        Map.tryApply'(map, tycon)
      end



    fun lookupStrId ((syms,sym),pe) =
      let
        fun aux ([],pe) = pe
          | aux ((s::ss),E (_,_,_,SE map)) =
            (case Map.tryApply' (map,Ident.STRID s) of
               SOME pe => aux (ss,pe)
             | _ => raise LookupStrId s)
      in
        aux (syms@@[sym],pe)
      end

    fun lookupFunId (funid, B(F map,_,_)) = 
      Map.apply'(map, funid)

    fun lookupSigId (sigid,B(_,G map,_)) = 
      Map.apply'(map, sigid)

    fun make_pFE (syms, fixity) =
      let
        fun f (res, sym) = Map.define(res, sym, fixity)
      in
        FE (Lists.reducel f (Map.empty (Symbol.symbol_lt,Symbol.eq_symbol), syms))
      end

    exception Seen

    fun addFixity((symbol, fixity), FE map) =
      FE (Map.define(map, symbol, fixity))

    fun addValId (f, valid, VE map) =
      let
	val sym =
	  case valid of
	    Ident.VAR sym => sym
	  | Ident.CON sym => sym 
	  | Ident.EXCON sym => sym
	  | Ident.TYCON' sym => sym
      in
	VE(Map.combine f (map, sym, valid))
      end

    fun addTyCon (f, tycon, ve, TE map) =
	TE(Map.combine f (map, tycon, ve))


    fun addStrId (f, strid, pe, SE map) =
      SE(Map.combine f (map, strid, pe))

    fun addFunId (f, funid, pe, F map) =
      F(Map.combine f (map, funid, pe))

    fun addSigId (f, sigid, pe, tycons, G map) =
      G(Map.combine f (map, sigid, (pe,tycons)))
  end;
@


1.22.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.22  1998/02/19  16:34:03  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.21
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d160 1
a160 1
        VE (Map.merge (fn (x,a,b) => (valid_fn a;b))(ve,ve')),
d162 1
a162 1
        SE (Map.merge (fn (x,a,b) => (strid_fn x;b)) (se,se')))
@


1.21.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.21  1997/05/01  13:17:36  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.21.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.21  1997/05/01  13:17:36  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.20
log
@[Bug #1686]
adding type constructor environment to parser env.
@
text
@d4 4
d189 1
a189 1
              MLWorks.Option.SOME pe' => follow (strids,pe')
d198 1
a198 1
        fun follow ([],pe) = MLWorks.Option.SOME pe
d201 2
a202 2
              MLWorks.Option.SOME pe' => follow (strids,pe')
            | _ => MLWorks.Option.NONE
d205 2
a206 2
          MLWorks.Option.SOME (E (_,VE map,_,_)) => Map.tryApply'(map, sym)
        | _ => MLWorks.Option.NONE
d214 1
a214 1
              of MLWorks.Option.SOME pe' => pe'
d228 1
a228 1
               MLWorks.Option.SOME pe => aux (ss,pe)
@


1.20.5.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
@


1.20.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.20.5.1  1997/05/12  10:38:36  hope
 * branched from 1.20
 *
@


1.20.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.20.5.1  1997/05/12  10:38:36  hope
 * branched from 1.20
 *
@


1.20.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.20.5.1  1997/05/12  10:38:36  hope
 * branched from 1.20
 *
@


1.20.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.20.5.1.1.1  1997/07/28  18:23:36  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.20.4.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
@


1.20.3.1.1.1
log
@branched from 1.20.3.1
@
text
@a3 3
 * Revision 1.20.3.1  1996/12/17  17:51:47  hope
 * branched from 1.20
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/10/25  13:21:55  andreww
 * [Bug #1686]
 * adding type constructor environment to parser env.
 *
@


1.20.1.1.1.1
log
@branched from 1.20.1.1
@
text
@a3 3
 * Revision 1.20.1.1  1996/11/14  12:54:43  hope
 * branched from 1.20
 *
@


1.19
log
@Adding unique_augment_pE
@
text
@d4 3
d92 2
d96 1
a96 1
      pE = E of (pFE * pVE * pSE)
d107 1
d109 32
a140 1
    val empty_pE  = E(empty_pFE,empty_pVE,empty_pSE)
d142 6
a147 2
    fun augment_pE (E(FE fe,VE ve,SE se), E(FE fe',VE ve',SE se')) =
      E(FE (Map.union (fe,fe')), VE (Map.union (ve,ve')), SE (Map.union (se,se')))
d149 2
a150 1
    fun unique_augment_pE ((valid_fn,strid_fn),E(FE fe,VE ve,SE se), E(FE fe',VE ve',SE se')) =
d153 1
d169 2
a170 2
    fun remove_str (B(f, g, E(fE, vE, SE sE)), strid) =
      B(f, g, E(fE, vE, SE(Map.undefine(sE, strid))))
d172 1
a172 1
    fun lookupFixity (sym, E (FE map,_,_)) =
d183 1
a183 1
          | follow (sym ::strids,E(_,_,SE map)) =
d187 1
a187 1
        val (E (_,VE map,_)) = follow (syms,pe)
d195 1
a195 1
          | follow (sym ::strids,E(_,_,SE map)) =
d201 1
a201 1
          MLWorks.Option.SOME (E (_,VE map,_)) => Map.tryApply'(map, sym)
d205 14
d222 1
a222 1
          | aux ((s::ss),E (_,_,SE map)) =
d259 4
@


1.19.3.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/03/19  14:30:10  matthew
 * Adding unique_augment_pE
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/03/19  14:30:10  matthew
 * Adding unique_augment_pE
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a3 3
 * Revision 1.19  1996/03/19  14:30:10  matthew
 * Adding unique_augment_pE
 *
@


1.18
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d96 1
a96 1
      pG = G of (Ident.SigId,pE) Map.map
d108 5
d209 2
a210 2
    fun addSigId (f, sigid, pe, G map) =
      G(Map.combine f (map, sigid, pe))
@


1.17
log
@Adding exception raising long valid lookup
@
text
@d4 3
d64 1
a64 1
require "../utils/newmap";
d71 1
a71 1
   structure Map   : NEWMAP
d82 1
a82 1
      pFE = FE of (Symbol.Symbol,Fixity) Map.T
d84 1
a84 1
      pVE = VE of (Symbol.Symbol,Ident.ValId) Map.T
d86 1
a86 1
      pSE = SE of (Ident.StrId,pE) Map.T
d91 1
a91 1
      pF = F of (Ident.FunId,pE) Map.T
d93 1
a93 1
      pG = G of (Ident.SigId,pE) Map.T
@


1.16
log
@Improving lookup error messages
@
text
@d4 3
d125 13
a149 13

(*
    local
      val follow = Ident.followPath (fn (strid,E(_,_,SE map)) => Map.apply'(map, strid))
    in
      fun lookupValId ((syms,sym),pe) =
        let
	  val E(_,VE map,_) = follow (Ident.mkPath syms,pe)
        in
          Map.apply'(map, sym)
        end
    end
*)
@


1.15
log
@Added option-returning tryLookupValid
@
text
@d4 3
d120 16
d145 2
a146 13

      fun tryLookupValId ((syms,sym),pe) =
        let
          fun follow ([],pe) = MLWorks.Option.SOME pe
            | follow (sym ::strids,E(_,_,SE map)) =
              case Map.tryApply'(map,Ident.STRID sym) of
                MLWorks.Option.SOME pe' => follow (strids,pe')
              | _ => MLWorks.Option.NONE
        in
          case follow (syms,pe) of
            MLWorks.Option.SOME (E (_,VE map,_)) => Map.tryApply'(map, sym)
          | _ => MLWorks.Option.NONE
        end
d148 10
a157 7
      fun lookupStrId ((syms,sym),pe) =
        let
	  val E(_,_,SE map) = follow (Ident.mkPath syms,pe)
        in
          (Map.apply'(map, Ident.STRID sym)) 
        end
    end
@


1.14
log
@Remove uses of Map.empty'
@
text
@d4 3
d118 1
a118 3
      val follow = 
        Ident.followPath (fn (strid,E(_,_,SE map)) =>
                          Map.apply'(map, strid))
d125 13
@


1.13
log
@TYCON' for type function functions in lambda code for Modules Debugger.
@
text
@d4 3
d85 3
a87 3
    val empty_pFE = FE(Map.empty' Symbol.symbol_lt)
    val empty_pVE = VE(Map.empty' Symbol.symbol_lt)
    val empty_pSE = SE(Map.empty' Ident.strid_lt)
d93 2
a94 2
    val empty_pF = F(Map.empty' Ident.funid_lt)
    val empty_pG = G(Map.empty' Ident.sigid_lt)
d144 1
a144 1
        FE (Lists.reducel f (Map.empty' Symbol.symbol_lt, syms))
@


1.12
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d4 3
d156 1
@


1.12.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.12  1993/04/26  16:13:54  jont
Added remove_str for getting rid of FullPervasiveLibrary_ from initial env

@


1.11
log
@Changed to generate errors when an unbound signature,structure,functor or constructor
name is used.
@
text
@d4 4
d99 3
@


1.10
log
@Modified to use less than functions for maps
@
text
@d4 3
d103 2
a104 1
        Ident.followPath (fn (strid,E(_,_,SE map)) => Map.apply'(map, strid)) 
a118 1
        handle Lookup => empty_pE
d122 1
a122 1
      Map.apply_default'(map, empty_pE, funid)
d125 1
a125 1
      Map.apply_default'(map, empty_pE, sigid)
@


1.9
log
@Changed error parameter to addValid etc.
@
text
@d4 3
d72 3
a74 3
    val empty_pFE = FE(Map.empty' Symbol.symbol_order)
    val empty_pVE = VE(Map.empty' Symbol.symbol_order)
    val empty_pSE = SE(Map.empty' Ident.strid_order)
d80 2
a81 2
    val empty_pF = F(Map.empty' Ident.funid_order)
    val empty_pG = G(Map.empty' Ident.sigid_order)
d128 1
a128 1
        FE (Lists.reducel f (Map.empty' Symbol.symbol_order, syms))
@


1.8
log
@Removed Symbol structure from result and changed everything to use NewMap.
@
text
@d4 3
d141 1
a141 1
	VE(Map.combine (fn (x, _, _) => f x) (map, sym, valid))
d145 1
a145 1
      SE(Map.combine (fn (x, _, _) => f x) (map, strid, pe))
d148 1
a148 1
      F(Map.combine (fn (x, _, _) => f x) (map, funid, pe))
d151 1
a151 1
      G(Map.combine (fn (x, _, _) => f x) (map, sigid, pe))
@


1.7
log
@Removed some structures and sharing
@
text
@d4 3
d30 1
d32 2
a33 1
require "../utils/map";
d38 5
a42 2
functor ParserEnv (structure Map : MAP
                   structure Ident : IDENT) : PARSERENV =
a43 1

d50 2
a51 2
    datatype 
      pFE = FE of (Symbol.Symbol,Fixity) Map.Map
d53 1
a53 1
      pVE = VE of (Symbol.Symbol,Ident.ValId) Map.Map
d55 1
a55 1
      pSE = SE of (Ident.StrId,pE) Map.Map
d60 1
a60 1
      pF = F of (Ident.FunId,pE) Map.Map
d62 1
a62 2
      pG = G of (Ident.SigId,pE) Map.Map

d66 3
a68 3
    val empty_pFE = FE(Map.empty_eqfunmap Symbol.eq_symbol)
    val empty_pVE = VE(Map.empty_eqfunmap Symbol.eq_symbol)
    val empty_pSE = SE(Map.empty_eqfunmap Ident.strid_eq)
d71 2
a72 4
    fun augment_pE (E(FE fe,VE ve,SE se),E(FE fe',VE ve',SE se')) =
      E (FE (Map.plus (fe,fe',Symbol.symbol_order)),
         VE (Map.plus (ve,ve',Symbol.symbol_order)),
         SE (Map.plus (se,se',Ident.strid_order)))
d74 2
a75 2
    val empty_pF = F(Map.empty_eqfunmap Ident.funid_eq)
    val empty_pG = G(Map.empty_eqfunmap Ident.sigid_eq)
d79 1
a79 1
      F (Map.plus (map,map',Ident.funid_order))
d82 1
a82 1
      G (Map.plus (map,map',Ident.sigid_order))
d85 1
a85 3
      B (F (Map.plus (f,f',Ident.funid_order)),
         G (Map.plus (g,g',Ident.sigid_order)),
         (augment_pE (pE,pE')))
d87 2
a88 2
    fun lookupFixity (sym,E (FE map,_,_)) =
      Map.lookup(sym,map) handle Map.Lookup => NONFIX
d90 1
a90 1
    exception Lookup = Map.Lookup
a92 1

d94 1
a94 2
        Ident.followPath (fn (strid,E(_,_,SE map)) => Map.lookup (strid,map)) 

a95 1

d97 2
a98 1
        let val E(_,VE map,_) = follow (Ident.mkPath syms,pe)
d100 1
a100 1
          Map.lookup (sym,map)
d104 2
a105 1
        let val E(_,_,SE map) = follow (Ident.mkPath syms,pe)
d107 1
a107 1
          (Map.lookup (Ident.STRID sym,map)) 
d112 2
a113 2
    fun lookupFunId (funid,B(F map,_,_)) = 
      (Map.lookup (funid,map)) handle Lookup => empty_pE
d116 1
a116 1
      (Map.lookup (sigid,map)) handle Lookup => empty_pE
d120 1
a120 3
        fun iterate nil = Map.empty_eqfunmap Symbol.eq_symbol
          | iterate (sym::syms) = 
            Map.add((sym,fixity),iterate(syms),Symbol.symbol_order)
d122 1
a122 1
        FE (iterate syms)
d127 2
a128 2
    fun addFixity((symbol, fixity),FE map) =
      FE (Map.add ((symbol,fixity), map, Symbol.symbol_order))
d130 7
a136 6
    fun addValId (valid,VE map) =
      let val sym =
        case valid of
          Ident.VAR sym => sym
        | Ident.CON sym => sym 
        | Ident.EXCON sym => sym
d138 1
a138 4
	if Map.domain_member(sym, map) then
          raise Seen
	else
          VE (Map.add ((sym,valid),map,Symbol.symbol_order))
d141 2
a142 17
    fun addStrId ((strid,pe),SE map) =
      if Map.domain_member(strid, map) then
        raise Seen
      else
        SE (Map.add ((strid,pe),map,Ident.strid_order))

    fun addFunId ((funid,pe),F map) =
      if Map.domain_member(funid, map) then
        raise Seen
      else
        F (Map.add ((funid,pe),map,Ident.funid_order))

    fun addSigId ((sigid,pe),G map) =
      if Map.domain_member(sigid, map) then
        raise Seen
      else
        G (Map.add ((sigid,pe),map,Ident.sigid_order))
d144 2
d147 3
a149 1
  end
@


1.6
log
@Added some more exception handlers
@
text
@d4 3
a29 1
require "../basics/symbol";
d34 1
a34 3
                   structure Ident : IDENT
		   structure Symbol : SYMBOL
		   sharing Symbol = Ident.Symbol) : PARSERENV =
d39 1
a39 1
    structure Symbol = Symbol
@


1.5
log
@Changed to use equality functions for all maps, and to remove
use of exceptions to detect seen
@
text
@d4 4
d106 1
a106 1
          (Map.lookup (Ident.STRID sym,map)) handle Lookup => empty_pE
d108 1
a108 1

@


1.4
log
@Added addFixity for updating a fixity env for the benefit of the
encapsulator
@
text
@d3 5
a7 1
$Log:	_parserenv.sml,v $
d56 4
a59 4
    val empty_pFE = FE Map.empty_map
    val empty_pVE = VE Map.empty_map
    val empty_pSE = SE Map.empty_map
    val empty_pE  = E (empty_pFE,empty_pVE,empty_pSE)
d66 2
a67 2
    val empty_pF = F Map.empty_map
    val empty_pG = G Map.empty_map
d115 1
a115 1
        fun iterate nil = Map.empty_map
d134 1
a134 2
        let val _ = Map.lookup (sym,map)
        in
d136 1
a136 1
        end handle Map.Lookup =>
d141 1
a141 2
      let val _ = Map.lookup (strid,map)
      in
d143 1
a143 1
      end handle Map.Lookup =>
d147 1
a147 2
      let val _ = Map.lookup (funid,map)
      in
d149 1
a149 1
      end handle Map.Lookup =>
d153 1
a153 2
      let val _ = Map.lookup (sigid,map)
      in
d155 1
a155 1
      end handle Map.Lookup =>
a159 1

@


1.3
log
@Added copyright message
@
text
@d4 3
d119 3
@


1.2
log
@Made lookupStrId, lookupFunId and lookupSigId return empty environment
if Lookup fails
@
text
@d1 1
d4 4
d11 1
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d89 1
a89 1
          Map.lookup (Ident.STRID sym,map)
d94 5
a98 2
    fun lookupFunId (funid,B(F map,_,_)) = Map.lookup (funid,map)
    fun lookupSigId (sigid,B(_,G map,_)) = Map.lookup (sigid,map)
@
