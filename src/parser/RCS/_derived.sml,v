head	1.50;
access;
symbols
	MLW_daveb_inline_1_4_99:1.50.1
	MLWorks_21c0_1999_03_25:1.50
	MLWorks_20c1_1998_08_20:1.50
	MLWorks_20c0_1998_08_04:1.50
	MLWorks_20b2c2_1998_06_19:1.50
	MLWorks_20b2_Windows_1998_06_12:1.50
	MLWorks_20b1c1_1998_05_07:1.50
	MLWorks_20b0_1998_04_07:1.50
	MLWorks_20b0_1998_03_20:1.50
	MLWorks_20m2_1998_02_16:1.49
	MLWorks_20m1_1997_10_23:1.49
	MLWorks_11r1:1.48.5.1.1.1.1
	MLWorks_workspace_97:1.49.2
	MLWorks_dt_wizard:1.49.1
	MLWorks_11c0_1997_09_09:1.48.5.1.1.1
	MLWorks_10r3:1.48.5.1.3
	MLWorks_10r2_551:1.48.5.1.2
	MLWorks_11:1.48.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.48.5.1
	MLWorks_20m0_1997_06_20:1.49
	MLWorks_1_0_r2c2_1997_06_14:1.48.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.48.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.48.5
	MLWorks_BugFix_1997_04_24:1.48
	MLWorks_1_0_r2_Win32_1997_04_11:1.48
	MLWorks_1_0_r2_Unix_1997_04_04:1.48
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.48.3.1.1
	MLWorks_gui_1996_12_18:1.48.4
	MLWorks_1_0_Win32_1996_12_17:1.48.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.48.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.48.1.1
	MLWorks_1_0_Irix_1996_11_28:1.48.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.48.2
	MLWorks_1_0_Unix_1996_11_14:1.48.1
	MLWorks_Open_Beta2_1996_10_11:1.47.1
	MLWorks_License_dev:1.46.2
	MLWorks_1_open_beta_1996_09_13:1.46.1
	MLWorks_Open_Beta_1996_08_22:1.46
	MLWorks_Beta_1996_07_02:1.46
	MLWorks_Beta_1996_06_07:1.46
	MLWorks_Beta_1996_06_06:1.46
	MLWorks_Beta_1996_06_05:1.46
	MLWorks_Beta_1996_06_03:1.46
	MLWorks_Beta_1996_05_31:1.46
	MLWorks_Beta_1996_05_30:1.46
	ML_beta_release_12/08/94:1.33
	ML_beta_release_03/08/94:1.33
	ML_revised_beta_release_25/05/94:1.31
	ML_final_beta_release_02/03/94:1.31
	mlworks-28-01-1994:1.30
	Release:1.25
	mlworks-beta-01-09-1993:1.25
	MLWorks-1-0-4-29/01/1993:1.18
	MLWorks-1-0-3-21/12/1992:1.18
	MLWorks-1-0-2-15/12/1992:1.18
	MLWorks-1-0-1-04/12/1992:1.18
	checkpoint_17_08_92:1.13
	Ten15_release_19-11-91:1.2
	Ten15_release_21-08-91:1.2
	Ten15_release_19-08-91:1.2
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.50
date	98.02.18.13.51.09;	author mitchell;	state Exp;
branches
	1.50.1.1;
next	1.49;

1.49
date	97.05.01.13.21.27;	author jont;	state Exp;
branches
	1.49.1.1
	1.49.2.1;
next	1.48;

1.48
date	96.11.06.10.56.17;	author matthew;	state Exp;
branches
	1.48.1.1
	1.48.2.1
	1.48.3.1
	1.48.4.1
	1.48.5.1;
next	1.47;

1.47
date	96.09.25.17.21.18;	author andreww;	state Exp;
branches
	1.47.1.1;
next	1.46;

1.46
date	96.05.07.10.36.08;	author jont;	state Exp;
branches
	1.46.1.1
	1.46.2.1;
next	1.45;

1.45
date	96.04.29.13.30.55;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.03.26.16.33.01;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.12.27.10.46.00;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	95.09.08.13.06.10;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	95.08.31.13.22.14;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	95.07.27.14.24.20;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	95.02.14.12.14.13;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	95.01.17.12.57.23;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	94.11.14.12.56.36;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.10.13.09.39.08;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.09.14.12.01.49;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.08.31.13.50.37;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.06.29.17.06.24;	author brianm;	state Exp;
branches;
next	1.32;

1.32
date	94.05.27.16.06.15;	author nickh;	state Exp;
branches;
next	1.31;

1.31
date	94.02.21.21.23.56;	author nosa;	state Exp;
branches;
next	1.30;

1.30
date	93.12.10.12.26.14;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	93.12.08.11.41.05;	author nickh;	state Exp;
branches;
next	1.28;

1.28
date	93.11.25.09.35.58;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	93.09.29.16.39.13;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.08.26.12.41.54;	author nosa;	state Exp;
branches;
next	1.25;

1.25
date	93.08.06.13.50.19;	author matthew;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	93.07.09.11.57.20;	author nosa;	state Exp;
branches;
next	1.23;

1.23
date	93.05.18.18.05.50;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	93.03.09.11.16.09;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.02.23.14.13.26;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.02.22.13.33.16;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.08.19.26.20;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	92.12.02.16.44.51;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	92.11.05.15.56.04;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	92.10.09.13.38.11;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.09.11.11.53.26;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.09.09.14.01.02;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.08.05.16.22.49;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.07.27.15.20.56;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.07.08.08.51.36;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.06.24.18.17.58;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.06.23.11.12.40;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.06.11.10.21.16;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.05.19.10.56.12;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.05.01.10.21.25;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.04.13.13.27.45;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.02.14.13.05.48;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.19.17.23.17;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.27.13.54.56;	author colin;	state Exp;
branches;
next	1.1;

1.1
date	91.06.07.16.17.43;	author colin;	state Exp;
branches;
next	;

1.25.1.1
date	93.08.06.13.50.19;	author jont;	state Exp;
branches;
next	1.25.1.2;

1.25.1.2
date	93.09.29.16.31.12;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	96.09.13.11.20.22;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.10.07.16.10.18;	author hope;	state Exp;
branches;
next	;

1.47.1.1
date	96.10.17.11.28.47;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	96.11.14.12.54.27;	author hope;	state Exp;
branches
	1.48.1.1.1.1;
next	;

1.48.1.1.1.1
date	96.11.28.15.05.18;	author hope;	state Exp;
branches;
next	;

1.48.2.1
date	96.11.22.18.13.08;	author hope;	state Exp;
branches;
next	;

1.48.3.1
date	96.12.17.17.51.37;	author hope;	state Exp;
branches
	1.48.3.1.1.1;
next	;

1.48.3.1.1.1
date	97.02.24.11.42.13;	author hope;	state Exp;
branches;
next	;

1.48.4.1
date	96.12.18.09.45.56;	author hope;	state Exp;
branches;
next	;

1.48.5.1
date	97.05.12.10.38.24;	author hope;	state Exp;
branches
	1.48.5.1.1.1
	1.48.5.1.2.1
	1.48.5.1.3.1;
next	;

1.48.5.1.1.1
date	97.07.28.18.23.44;	author daveb;	state Exp;
branches
	1.48.5.1.1.1.1.1;
next	;

1.48.5.1.1.1.1.1
date	97.10.07.11.49.26;	author jkbrook;	state Exp;
branches;
next	;

1.48.5.1.2.1
date	97.09.08.17.17.06;	author daveb;	state Exp;
branches;
next	;

1.48.5.1.3.1
date	97.09.09.14.13.14;	author daveb;	state Exp;
branches;
next	;

1.49.1.1
date	97.09.10.19.29.16;	author brucem;	state Exp;
branches;
next	;

1.49.2.1
date	97.09.11.20.59.11;	author daveb;	state Exp;
branches;
next	;

1.50.1.1
date	99.04.01.17.59.35;	author daveb;	state Exp;
branches;
next	;


desc
@Code for producing abstract syntax for SML derived forms
@


1.50
log
@[Bug #30349]
Warn when lhs of semicolon does not have type unit
@
text
@(*
$Log: _derived.sml,v $
 * Revision 1.49  1997/05/01  13:21:27  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.47  1996/09/25  17:21:18  andreww
 * [Bug #1592]
 * threading location information in Absyn.LOCALexp
 *
 * Revision 1.46  1996/05/07  10:36:08  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.45  1996/04/29  13:30:55  matthew
 * Integer changes
 *
 * Revision 1.44  1996/03/26  16:33:01  matthew
 * Explicit type variables in VALdecs
 *
 * Revision 1.43  1995/12/27  10:46:00  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.42  1995/09/08  13:06:10  matthew
Improving "Inconsistent function names" message

Revision 1.41  1995/08/31  13:22:14  jont
Add location info to wild pats

Revision 1.40  1995/07/27  14:24:20  matthew
Simplifying derived form for #label construct

Revision 1.39  1995/02/14  12:14:13  matthew
Removing structure Options

Revision 1.38  1995/01/17  12:57:23  matthew
Rationalizing debugger

Revision 1.37  1994/11/14  12:56:36  matthew
Removed currying transform, this is now redundant.

Revision 1.36  1994/10/13  09:39:08  matthew
Efficiency improvements to lookup

Revision 1.35  1994/09/14  12:01:49  matthew
Abstraction of  debug information

Revision 1.34  1994/08/31  13:50:37  matthew
Minor efficiency improvement to labn

Revision 1.33  1994/06/29  17:06:24  brianm
tail recursions for types, patterns etc. make_funs

Revision 1.32  1994/05/27  16:06:15  nickh
Make make_list_exp' tail-recursive, to improve parsing of files with
long lists.

Revision 1.31  1994/02/21  21:23:56  nosa
Type function recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.

Revision 1.30  1993/12/10  12:26:14  matthew
Changed info name associated with uncurried versions of functions

Revision 1.29  1993/12/08  11:41:05  nickh
Added error checking in the withtype construct (see the comment there).

Revision 1.28  1993/11/25  09:35:58  matthew
Added fixity annotations to abstract syntax.

Revision 1.27  1993/09/29  16:39:13  daveb
Merged in bug fix.

Revision 1.26  1993/08/26  12:41:54  nosa
Instances for polymorphic debugger.

Revision 1.25.1.2  1993/09/29  16:31:12  daveb
Changed order of cases in translation of andalso, to make generation of
error messages easier in typechecker._core_rules.

Revision 1.25.1.1  1993/08/06  13:50:19  jont
Fork for bug fixing

Revision 1.25  1993/08/06  13:50:19  matthew
Added location information to matches

Revision 1.24  1993/07/09  11:57:20  nosa
structure Option.

Revision 1.23  1993/05/18  18:05:50  jont
Removed integer parameter

Revision 1.22  1993/03/09  11:16:09  matthew
Options & Info changes
Absyn changes

Revision 1.21  1993/02/23  14:13:26  matthew
Look up true,false etc. in parser env. for derived forms

Revision 1.20  1993/02/22  13:33:16  matthew
Changed the functor parameter signature name in the derived funbinds to
be "_".  There is no need to have different names for different functors.

Revision 1.19  1993/02/08  19:26:20  matthew
ref Nameset removed from FunBind abstract syntax

Revision 1.18  1992/12/02  16:44:51  matthew
Fixed problem in make_fvalbind to cope with error recovery.

Revision 1.17  1992/11/05  15:56:04  matthew
Changed Error structure to Info

Revision 1.16  1992/10/09  13:38:11  clive
Tynames now have a slot recording their definition point

Revision 1.15  1992/09/11  11:53:26  matthew
Added generation of local uncurried versions of curried functions.
Also don't generate intermediate functions in uncurried case.

Revision 1.14  1992/09/09  14:01:02  matthew
Improved error messages.

Revision 1.13  1992/08/05  16:22:49  jont
Removed some structures and sharing

Revision 1.12  1992/07/27  15:20:56  matthew
Made NILpat a function, not a constant.  This may or may not have been a bug.

Revision 1.11  1992/07/08  08:51:36  clive
Call point information added, and fixed a bug with withtype

Revision 1.10  1992/06/24  18:17:58  jont
Changed to imperative implementation of namesets with hashing

Revision 1.9  1992/06/23  11:12:40  clive
More annotation in the make_case' generated functions

Revision 1.8  1992/06/11  10:21:16  clive
Added marks for some error messages from the typechecker

Revision 1.7  1992/05/19  10:56:12  clive
Added marks to allow position reporting from the typechecker

Revision 1.6  1992/05/01  10:21:25  clive
Added more useful annotations to if,while,case statements to give better info in a stack backtrace

Revision 1.5  1992/04/13  13:27:45  clive
First version of the profiler

Revision 1.4  1992/02/14  13:05:48  jont
Added lists and integer parameters to the functor

Revision 1.3  1991/11/19  17:23:17  jont
Fixed inexhaustive matches

Revision 1.2  91/06/27  13:54:56  colin
changed to handle Interface annotations in signature expressions

Revision 1.1  91/06/07  16:17:43  colin
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/lists";
require "../utils/counter";
require "../utils/crash";
require "../basics/absyn";
require "../basics/identprint";
require "../main/info";
require "parserenv";
require "derived";

functor Derived(
  structure Lists : LISTS
  structure Counter : COUNTER
  structure Crash : CRASH		
  structure Absyn : ABSYN
  structure Info : INFO
  structure PE : PARSERENV
  structure IdentPrint : IDENTPRINT

  sharing PE.Ident = Absyn.Ident = IdentPrint.Ident
  sharing Absyn.Ident.Location = Info.Location
    ) : DERIVED =

  struct
    
    structure Absyn = Absyn
    structure Ident = Absyn.Ident
    structure Symbol = Ident.Symbol
    structure Set = Absyn.Set
    structure Info = Info
    structure PE = PE

    (* we need this to create dummy annotations *)
    fun annotate thing = (thing, ref Absyn.nullType)
    fun annotate_exp (thing,location) = 
      (thing, ref Absyn.nullType, location,ref(Absyn.nullInstanceInfo,NONE))
    fun annotate_pat thing = (thing, (ref Absyn.nullType,ref (Absyn.nullRuntimeInfo)))

    fun new_var () = 
      let
	val s = "_id" ^ Int.toString (Counter.counter ())
      in
	Ident.LONGVALID (Ident.mkPath [],Ident.VAR (Symbol.find_symbol s))
      end

    fun new_vars 0 = nil
      | new_vars n = new_var () :: new_vars (n - 1)

    val small_labs =
      MLWorks.Internal.Array.tabulate (16,
                      fn n => Ident.LAB (Symbol.find_symbol (Int.toString n)))

    val num_small_labs = MLWorks.Internal.Array.length small_labs

    fun labn n = 
      if n >= 0 andalso n < num_small_labs
        then MLWorks.Internal.Array.sub (small_labs,n)
      else Ident.LAB (Symbol.find_symbol (Int.toString n))

    local
      fun lookup s =
        let val sym = Symbol.find_symbol s
        in
          (fn pE => 
           (case PE.tryLookupValId (([],sym),pE) of 
              SOME x => x
            | _ => Ident.VAR sym))
        end
    in
      val NILid = lookup "nil"
      val CONSid = lookup "::"
      val TRUEid =  lookup "true"
      val FALSEid = lookup "false"
      val itid =  lookup"it"
    end

    local 
      fun make_exp idfn (location,pE) = 
	Absyn.VALexp (annotate_exp (Ident.LONGVALID (Ident.mkPath [], idfn pE),location))
    in
      val NILexp = make_exp NILid 
      val CONSexp = make_exp CONSid
      val TRUEexp = make_exp TRUEid
      val FALSEexp = make_exp FALSEid
    end

    local 
      fun make_pat(x,location) = 
	Absyn.VALpat (annotate_pat (Ident.LONGVALID (Ident.mkPath [], x)),location)
    in
      fun NILpat(location,pE) = make_pat (NILid pE,location) (* now a function *)
      fun TRUEpat (location,pE) = make_pat (TRUEid pE,location)
      fun FALSEpat (location,pE) = make_pat (FALSEid pE,location)
      fun itpat (location,pE) = make_pat (itid pE,location)
    end

    (* types *)


    fun make_tuple l  =
      let
	fun make' ([],_,r) = rev r
	  | make' (a::l,n,r) = make'(l, n+1, (labn n, a)::r)
      in
        make'(l,1,[])
      end


    fun make_tuple_ty tys = Absyn.RECORDty (make_tuple tys)

    (* patterns *)

    fun make_unit_pat () = Absyn.RECORDpat ([],false,ref Absyn.nullType)

    fun make_tuple_pat [pat] = pat
      | make_tuple_pat pats =
        Absyn.RECORDpat (make_tuple pats, false, ref Absyn.nullType)

    fun make_list_pat (l,location,pE) =
      let
        val init_val = NILpat(location,pE)

        val annotation =
	  annotate (Ident.LONGVALID (Ident.mkPath [], CONSid pE))

	fun mk_list_pat ([],res) = res
	  | mk_list_pat (pat::pats,res) =
	    let
	      val new_val =
		Absyn.APPpat(annotation, make_tuple_pat[pat,res], location, true)
	    in
	       mk_list_pat(pats,new_val)  
	    end

      in
          mk_list_pat(rev l,init_val)
      end

    fun make_patrow (sym, opt_ty, opt_pat,location) =
        let 
	  val lab = Ident.LAB sym
	  val var = Ident.VAR sym
	  val valpat = 
	    Absyn.VALpat (annotate_pat (Ident.LONGVALID (Ident.mkPath [], var)),location)
	in
	  case (opt_ty, opt_pat) of
	    (NONE, NONE) => (lab,valpat)
	  | (NONE, SOME pat) => 
	      (lab, Absyn.LAYEREDpat (annotate_pat var, pat))
	  | (SOME ty, NONE) =>
	      (lab, Absyn.TYPEDpat (valpat, ty,location))
	  | (SOME ty, SOME pat) => 
	      (lab, Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate_pat var, pat), ty, location))
	end      

    (* expressions *)

    fun make_unit_exp () = Absyn.RECORDexp []

    fun make_tuple_exp [exp] = exp
      | make_tuple_exp exps  = Absyn.RECORDexp (make_tuple exps)

    fun make_select (lab as Ident.LAB sym,location,annotation) = 
      let 
	val var = Ident.LONGVALID (Ident.mkPath [],Ident.VAR sym)
	val (a,b) = 
	  (annotate 
	   [(Absyn.RECORDpat ([(lab,Absyn.VALpat (annotate_pat var,location))],
			      true,ref Absyn.nullType),
	     Absyn.VALexp (annotate_exp (var,location)),
             location)])
      in
	Absyn.FNexp (a,b,annotation,location)
		     
      end

    fun make_case (exp,match,annotation,location) =
      let val (a,b) = (annotate match)
      in
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, 
                      location,ref Absyn.nullType,false)
      end

    fun make_case' (exp,match,annotation,location) = 
      let val (a,b) = (annotate match)
      in
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, 
                      location,ref(Absyn.nullType),false)
      end

    fun make_if (exp1,exp2,exp3,annotation,location,pE) =
      make_case (exp1,[(TRUEpat(location,pE),exp2,location),
                       (FALSEpat(location,pE),exp3,location)],
                 annotation,
                 location)

    fun make_orelse (exp1,exp2,annotation,location,pE) =
      make_if (exp1,TRUEexp(location,pE),exp2,annotation,location,pE)

    (* Handle andalso explicitly, so that the cases are in the right order
       for constructing error messages in the case of type mismatches.
       See typechecker._core_rules. *)
    fun make_andalso (exp1,exp2,annotation,location,pE) =
      make_case
	(exp1,[(FALSEpat(location,pE), FALSEexp(location,pE), location),
	       (TRUEpat(location,pE),exp2,location)],
         annotation, location)

    local
      fun mk_sequence_exp ([],res) = res
	| mk_sequence_exp ((exp,annotation,location)::exps,res) =
	  let
	    val new_val =
	      make_case (exp,[(Absyn.WILDpat location,res,location)],
			 "Sequence expression",location)
	  in
      	    mk_sequence_exp(exps,new_val)
	  end
    in  	      
      fun make_sequence_exp ([(exp,_,_)]) = exp 
	| make_sequence_exp (exps as (_ :: _)) = 
	  let
            val rev_exps   = rev exps
            val (exp,_,_)  = Lists.hd rev_exps
	    val rest       = Lists.tl rev_exps
	  in
	     mk_sequence_exp(rest,exp)
	  end
	| make_sequence_exp ([]) = Crash.impossible"make_sequence nil"
    end

    fun make_while (exp1,exp2,annotation_function,location,pE) =
      let 
	val var = new_var ()
	val (a,b) =
	  (annotate 
	   [(make_unit_pat (),
	     make_if (exp1,
		      make_sequence_exp [(exp2,"in make_while",location),
					 (Absyn.APPexp (Absyn.VALexp 
                                                        (annotate_exp(var,location)), 
                                                        make_unit_exp (),
                                                        location,
                                                        ref Absyn.nullType,
                                                        false), 
                                         "in make_while",location)],
		      make_unit_exp (),
                      "While statement",
                      location,
                      pE),
             location)])      
      in
	Absyn.LOCALexp
	(Absyn.VALdec 
	 ([],
	  [(Absyn.VALpat (annotate_pat var,location),
	    Absyn.FNexp (a,b,annotation_function "while statement",location),location)],
	  Set.empty_set,[]),
	 Absyn.APPexp (Absyn.VALexp (annotate_exp(var,location)),
		       make_unit_exp (),location,
                       ref(Absyn.nullType),
                       false),
         location)
      end

    fun make_list_exp (exps,location,pE) =
      let
	val cons = CONSexp (location,pE)
	fun make_list_exp' (acc,[]) = acc
	  | make_list_exp' (acc,h::t) =
	    make_list_exp' (Absyn.APPexp(cons,
					 make_tuple_exp [h,acc],
					 location, ref Absyn.nullType, true),
			    t)
      in
	make_list_exp' (NILexp (location,pE), rev exps)
      end

    exception FvalBind of string

    fun make_fvalbind ((clauses as ((var,patlist,_,_) :: _),info_generator,location),
                       options) =
      let

        (* Sometimes get CONs here after error recovery *)
        fun name_to_string(Ident.VAR x) = Ident.Symbol.symbol_name x
          | name_to_string(Ident.CON x) = Ident.Symbol.symbol_name x
          | name_to_string(Ident.EXCON x) = Ident.Symbol.symbol_name x
          | name_to_string(Ident.TYCON' _) = Crash.impossible "name_to_string:make_fvalbind:derived"

        val name_string = name_to_string var
	val patlength = Lists.length patlist
	val vars = new_vars patlength

	fun make_line (var',patlist',exp,loc) =
          (if var = var' then
             if Lists.length patlist' = patlength then
               ()
             else Info.error options(Info.RECOVERABLE, loc, "Different pattern lengths in clauses")
           else Info.error options (Info.RECOVERABLE, loc, "Inconsistent function names");
           (make_tuple_pat patlist',exp,loc))

	fun wrap (nil,body,_,_) = body
	  | wrap (var::vars,body,num,location) =
	    let val (a,b) =
	      (annotate 
	       [(Absyn.VALpat (annotate_pat var,location), wrap (vars,body,num+1,location),location)])
	      in
		Absyn.FNexp (a,b,
                         info_generator(name_string ^ (" argument " ^ Int.toString num)),
                location)
	    end

        val (patexplist,ty) = (annotate (map make_line clauses))
      in
        if patlength = 1
          then
            let
              val body = Absyn.FNexp(patexplist,ty,info_generator name_string,location)
            in
              [(Absyn.VALpat (annotate_pat (Ident.LONGVALID (Ident.mkPath [], var)),location),body,location)]
            end
        else
          let
            val funid = Ident.LONGVALID (Ident.mkPath [], var)
            val tuple_exp = make_tuple_exp (map (fn var => Absyn.VALexp 
                                                 (annotate_exp(var,location))) vars)
            val body = Absyn.FNexp(patexplist,ty,info_generator (name_string^"<Uncurried>"),location)
          in
            [(Absyn.VALpat (annotate_pat funid,location),
              wrap (vars,
                    Absyn.APPexp (body,
                                  tuple_exp,
                                  location,
                                  ref Absyn.nullType,
                                  false),
                    0,
                    location),
              location)]
          end

(*
          let
            val funid = Ident.LONGVALID (Ident.mkPath [], var)
            val aux_funid = new_var()
            val tuple_exp = make_tuple_exp (map (fn var => Absyn.VALexp 
                                                 (annotate_exp(var,location))) vars)
            val body = Absyn.FNexp(patexplist,ty,info_generator (name_string^"<Uncurried>"),location)
          in
            [(Absyn.VALpat (annotate_pat funid,location),
              wrap (vars,
                    Absyn.APPexp (Absyn.VALexp (annotate_exp(aux_funid,location)),
                                  tuple_exp,
                                  location,
                                  ref Absyn.nullType,
                                  false),
                    0,
                    location),
              location),
            (Absyn.VALpat (annotate_pat aux_funid,location),body,location)]
          end
*)
      end
    | make_fvalbind _ = Crash.impossible"make_fvalbind bad parameters"

    (* declarations *)

    (* it strdecs *)
    fun make_it_strdec (e,tyvars,location,pE) =
      Absyn.STRDECtopdec
      (Absyn.DECstrdec
       (Absyn.VALdec ([(itpat (location,pE),
                        e,
                        location)],
       nil,
       tyvars,[])),
       location)

  
(*
    fun make_fun (match,tyvarset,location) = 
      Absyn.VALdec ([], map (fn (x,y) => (x,y,location)) match, tyvarset)
*)

    fun make_fun (matches,tyvarset,explicitys,location) =
      let
        val no_subfns =
          Lists.forall (fn [_] => true | _ => false) matches
      in
        if no_subfns
          then
            Absyn.VALdec ([],
                          map (fn [triple] => triple
                                      | _ => Crash.impossible "Bad singleton list in make_fun")
                          matches, 
                          tyvarset,
                          explicitys)
        else
          (* need to make a local declaration *)
          let
            val match = Lists.reducer (op @@) (matches,[])
            val external_pats = 
              map (fn ((x,_,_)::_) => 
                   (case x of
                      Absyn.VALpat((lvi,_),loc) => 
                        Absyn.VALpat((lvi,(ref Absyn.nullType,ref Absyn.nullRuntimeInfo)),loc)
                    | _ => x)
                   | _ => Crash.impossible "Bad list in make_fun") matches
            val external_exps = map (fn (Absyn.VALpat ((valid,_),location)) => Absyn.VALexp (annotate_exp(valid,location))
                                       | _ => Crash.impossible "Bad pattern variables in make_fun")
                                external_pats
            val external_decs = Absyn.VALdec (map (fn (pat,exp) => (pat,exp,location))
                                              (Lists.zip (external_pats,external_exps)),
                                              [],
                                              Set.empty_set,
                                              explicitys)
          in
            Absyn.LOCALdec (Absyn.VALdec ([],match, tyvarset,[]),
                            external_decs)
          end
      end

    (* handling withtype. We have to substitute in for uses of the
     * withtype tycons (see Definition, Appendix A, page 66). There
     * are two possibilities for error:
     * 1. we use a withtype tycon with the wrong arity.
     * 2. a withtype tycon uses an unbound tycon (such as another
     *    one of the withtype tycons (see rule 28)).
     *
     * in case 1 we catch the error here and report it.
     * in case 2 we don't want to report the unbound tycon where it
     * has been substituted, just where the user has typed it (in the
     * withtype declaration). To enable the typechecker to spot these
     * cases, we plug Unknown locations in the substitution. Then the
     * typechecker doesn't report unbound tycons with Unknown locations. *)

    fun substitute_datbind (datbind,typbind,opts) =
      let
	fun subst_ty (ty as (Absyn.TYVARty _)) = ty
	  | subst_ty (Absyn.RECORDty tyrow) = 
	    Absyn.RECORDty (map (fn (lab,ty) => (lab, subst_ty ty)) tyrow)
	  | subst_ty (Absyn.FNty (ty,ty')) =
	    Absyn.FNty (subst_ty ty, subst_ty ty')
	  | subst_ty (ty as (Absyn.APPty (tys,tycon,location))) =
	    let
	      fun subst_appty nil = Absyn.APPty(map subst_ty tys,tycon,location)
		| subst_appty ((tyvars',tycon',ty',_)::rest) = 
		  if tycon = Ident.LONGTYCON (Ident.mkPath [],tycon') then
		    (if Lists.length tys = Lists.length tyvars' then ()
		     else (* error case 1 *)
		       Info.error opts
		       (Info.RECOVERABLE,
			location,
			"Wrong number of arguments to type constructor " ^
			IdentPrint.printLongTyCon tycon);
		     let 
		       fun subst_tyvars (Absyn.RECORDty tyrow) =
			 Absyn.RECORDty 
			 (map (fn (lab,ty) => (lab, subst_tyvars ty)) tyrow)
			 | subst_tyvars (Absyn.FNty (ty,ty')) =
			   Absyn.FNty (subst_tyvars ty, subst_tyvars ty')
			 | subst_tyvars (Absyn.APPty (tys,tycon,location)) =
			   (* possible error case 2 *)
			   Absyn.APPty (map subst_tyvars tys, tycon,
					Ident.Location.UNKNOWN)
			 | subst_tyvars (ty as (Absyn.TYVARty tyvar)) =
			   let
			     fun subst_tyvar (nil,nil) = ty
			       | subst_tyvar (tyvar'::tyvars,ty'::tys) =
				 if tyvar = tyvar' then
				   ty'
				 else
				   subst_tyvar (tyvars,tys)
			       (* error case 1 again *)
			       | subst_tyvar _ = ty
			   in
			     subst_tyvar (tyvars',tys)
			   end
		     in
		       subst_tyvars ty'
		     end)
		  else
		    subst_appty rest
	    in
	      subst_appty typbind
	    end
	    
	fun subst_conbind nil = nil
	  | subst_conbind ((binding as (_,NONE)) :: rest) =
	    binding :: subst_conbind rest
	  | subst_conbind ((con,SOME ty) :: rest) =
	    (con,SOME (subst_ty ty)) :: subst_conbind rest
	    
	fun subst_binding (tyvars,tycon,tyref,tyfunref,conbind) =
	      (tyvars,tycon,tyref,tyfunref,subst_conbind conbind)

      in
	map subst_binding datbind
      end

    fun make_datatype_withtype (location,datbind,typbind,opts) =
      Absyn.SEQUENCEdec 
      [Absyn.DATATYPEdec (location,substitute_datbind (datbind,typbind,opts)),
       Absyn.TYPEdec typbind]

    fun make_abstype_withtype (location,datbind,typbind,dec,opts) =
      Absyn.ABSTYPEdec
      (location,substitute_datbind (datbind,typbind,opts),
       Absyn.SEQUENCEdec [Absyn.TYPEdec typbind, dec])

    fun make_strexp (strdec) = Absyn.NEWstrexp strdec

    (* There is no need to make the parameter strname different for different functors *)

    val dummy_strid = Ident.STRID (Symbol.find_symbol "_")

    val dummy_longstrid = Ident.LONGSTRID (Ident.mkPath [], dummy_strid)

    (* This needs some work *)
    fun make_funbind (funid,sigexp,strexp,sigexp',location) =
      let
	val sigexp'' = 
	  case sigexp' of
	    NONE => sigexp'
          | SOME (e as Absyn.WHEREsigexp sigexp,abs) => Crash.impossible "Meep!"
	  | SOME (e as Absyn.OLDsigexp _,abs) => sigexp'
	  | SOME (Absyn.NEWsigexp (spec',int),abs) => 
	      SOME
	      (Absyn.NEWsigexp
	       (Absyn.LOCALspec (Absyn.OPENspec ([dummy_longstrid],location), spec'),int),
               abs)

	val strexp' =
	  Absyn.LOCALstrexp
	  (Absyn.DECstrdec (Absyn.OPENdec ([dummy_longstrid],location)), strexp)
      in	
	(funid,dummy_strid,sigexp,strexp',sigexp'')
      end

  end
@


1.50.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.50  1998/02/18  13:51:09  mitchell
 * [Bug #30349]
 * Warn when lhs of semicolon does not have type unit
 *
@


1.49
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d3 4
d383 1
a383 1
			 annotation,location)
@


1.49.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.49  1997/05/01  13:21:27  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.49.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.49  1997/05/01  13:21:27  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.48
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
a196 2
    structure Option = MLWorks.Option

d200 1
a200 1
      (thing, ref Absyn.nullType, location,ref(Absyn.nullInstanceInfo,Option.NONE))
d230 1
a230 1
              Option.SOME x => x
d311 2
a312 2
	    (Option.NONE, Option.NONE) => (lab,valpat)
	  | (Option.NONE, Option.SOME pat) => 
d314 1
a314 1
	  | (Option.SOME ty, Option.NONE) =>
d316 1
a316 1
	  | (Option.SOME ty, Option.SOME pat) => 
d653 1
a653 1
	  | subst_conbind ((binding as (_,Option.NONE)) :: rest) =
d655 2
a656 2
	  | subst_conbind ((con,Option.SOME ty) :: rest) =
	    (con,Option.SOME (subst_ty ty)) :: subst_conbind rest
d688 5
a692 5
	    Option.NONE => sigexp'
          | Option.SOME (e as Absyn.WHEREsigexp sigexp,abs) => Crash.impossible "Meep!"
	  | Option.SOME (e as Absyn.OLDsigexp _,abs) => sigexp'
	  | Option.SOME (Absyn.NEWsigexp (spec',int),abs) => 
	      Option.SOME
@


1.48.5.1
log
@branched from 1.48
@
text
@a2 4
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.48.5.1  1997/05/12  10:38:24  hope
 * branched from 1.48
 *
@


1.48.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.48.5.1  1997/05/12  10:38:24  hope
 * branched from 1.48
 *
@


1.48.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.48.5.1  1997/05/12  10:38:24  hope
 * branched from 1.48
 *
@


1.48.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.48.5.1.1.1  1997/07/28  18:23:44  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.48.4.1
log
@branched from 1.48
@
text
@a2 4
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.3.1
log
@branched from 1.48
@
text
@a2 4
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.3.1.1.1
log
@branched from 1.48.3.1
@
text
@a2 3
 * Revision 1.48.3.1  1996/12/17  17:51:37  hope
 * branched from 1.48
 *
@


1.48.2.1
log
@branched from 1.48
@
text
@a2 4
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.1.1
log
@branched from 1.48
@
text
@a2 4
 * Revision 1.48  1996/11/06  10:56:17  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.1.1.1.1
log
@branched from 1.48.1.1
@
text
@a2 3
 * Revision 1.48.1.1  1996/11/14  12:54:27  hope
 * branched from 1.48
 *
@


1.47
log
@[Bug #1592]
threading location information in Absyn.LOCALexp
@
text
@d3 4
d160 1
a160 1
require "../basis/__integer";
@


1.47.1.1
log
@branched from 1.47
@
text
@a2 4
 * Revision 1.47  1996/09/25  17:21:18  andreww
 * [Bug #1592]
 * threading location information in Absyn.LOCALexp
 *
@


1.46
log
@Array moving to MLWorks.Array
@
text
@d3 3
d420 2
a421 1
                       false))
@


1.46.2.1
log
@branched from 1.46
@
text
@a2 3
 * Revision 1.46  1996/05/07  10:36:08  jont
 * Array moving to MLWorks.Array
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a2 3
 * Revision 1.46  1996/05/07  10:36:08  jont
 * Array moving to MLWorks.Array
 *
@


1.45
log
@Integer changes
@
text
@d3 3
d205 1
a205 1
      Array.tabulate (16,
d208 1
a208 1
    val num_small_labs = Array.length small_labs
d212 1
a212 1
        then Array.sub (small_labs,n)
@


1.44
log
@Explicit type variables in VALdecs
@
text
@d3 3
d150 2
d193 1
a193 1
	val s = "_id" ^ MLWorks.Integer.makestring (Counter.counter ())
d203 1
a203 1
                      fn n => Ident.LAB (Symbol.find_symbol (MLWorks.Integer.makestring n)))
d210 1
a210 1
      else Ident.LAB (Symbol.find_symbol (MLWorks.Integer.makestring n))
d461 1
a461 1
                         info_generator(name_string ^ (" argument " ^ MLWorks.Integer.makestring num)),
@


1.43
log
@Removing Option in favour of MLWorks.Option
@
text
@d3 3
d178 2
d183 1
a183 1
      (thing, ref Absyn.nullType, location,ref(Absyn.nullInstanceInfo,MLWorks.Option.NONE))
d213 1
a213 1
              MLWorks.Option.SOME x => x
d294 2
a295 2
	    (MLWorks.Option.NONE, MLWorks.Option.NONE) => (lab,valpat)
	  | (MLWorks.Option.NONE, MLWorks.Option.SOME pat) => 
d297 1
a297 1
	  | (MLWorks.Option.SOME ty, MLWorks.Option.NONE) =>
d299 1
a299 1
	  | (MLWorks.Option.SOME ty, MLWorks.Option.SOME pat) => 
d405 1
a405 1
	  Set.empty_set),
d522 1
a522 1
       tyvars)),
d531 1
a531 1
    fun make_fun (matches,tyvarset,location) =
d542 2
a543 1
                          tyvarset)
d561 2
a562 1
                                              Set.empty_set)
d564 1
a564 1
            Absyn.LOCALdec (Absyn.VALdec ([],match, tyvarset),
d635 1
a635 1
	  | subst_conbind ((binding as (_,MLWorks.Option.NONE)) :: rest) =
d637 2
a638 2
	  | subst_conbind ((con,MLWorks.Option.SOME ty) :: rest) =
	    (con,MLWorks.Option.SOME (subst_ty ty)) :: subst_conbind rest
d664 2
a665 1
      
d670 5
a674 4
	    MLWorks.Option.NONE => sigexp'
	  | MLWorks.Option.SOME (Absyn.OLDsigexp _) => sigexp'
	  | MLWorks.Option.SOME (Absyn.NEWsigexp (spec',int)) => 
	      MLWorks.Option.SOME
d676 2
a677 1
	       (Absyn.LOCALspec (Absyn.OPENspec ([dummy_longstrid],location), spec'),int))
@


1.42
log
@Improving "Inconsistent function names" message
@
text
@d3 3
d178 1
a178 1
      (thing, ref Absyn.nullType, location,ref(Absyn.nullInstanceInfo,Absyn.Option.ABSENT))
d289 2
a290 2
	    (Absyn.Option.ABSENT, Absyn.Option.ABSENT) => (lab,valpat)
	  | (Absyn.Option.ABSENT, Absyn.Option.PRESENT pat) => 
d292 1
a292 1
	  | (Absyn.Option.PRESENT ty, Absyn.Option.ABSENT) =>
d294 1
a294 1
	  | (Absyn.Option.PRESENT ty, Absyn.Option.PRESENT pat) => 
d628 1
a628 1
	  | subst_conbind ((binding as (_,Absyn.Option.ABSENT)) :: rest) =
d630 2
a631 2
	  | subst_conbind ((con,Absyn.Option.PRESENT ty) :: rest) =
	    (con,Absyn.Option.PRESENT (subst_ty ty)) :: subst_conbind rest
d662 4
a665 4
	    Absyn.Option.ABSENT => sigexp'
	  | Absyn.Option.PRESENT (Absyn.OLDsigexp _) => sigexp'
	  | Absyn.Option.PRESENT (Absyn.NEWsigexp (spec',int)) => 
	      Absyn.Option.PRESENT
@


1.41
log
@Add location info to wild pats
@
text
@d3 3
d437 2
a438 4
             else
               Info.error options(Info.RECOVERABLE, location, "Different pattern lengths in clauses")
           else
             Info.error options (Info.RECOVERABLE, location, "Inconsistent function names");
@


1.40
log
@Simplifying derived form for #label construct
@
text
@d3 3
d350 2
a351 1
	      make_case (exp,[(Absyn.WILDpat,res,location)],annotation,location)
@


1.39
log
@Removing structure Options
@
text
@d3 3
d174 1
a174 1
	val s = "_G" ^ MLWorks.Integer.makestring (Counter.counter ())
a271 1

a279 1
	    
a280 1

a282 1
	      
a284 1

a288 2
	

d296 1
a296 1
    fun make_select (lab,location,annotation) = 
d298 1
a298 1
	val var = new_var ()
@


1.38
log
@Rationalizing debugger
@
text
@d3 3
a137 1
require "../main/options";
a146 1
  structure Options : OPTIONS
a160 1
    structure Options = Options
@


1.37
log
@Removed currying transform, this is now redundant.
@
text
@d3 3
d165 3
a167 3
    fun annotate' (thing,location) = 
      (thing, ref Absyn.nullType, location,ref(nil,Absyn.Option.ABSENT))
    fun annotate'' thing = (thing, (ref Absyn.nullType,ref (Absyn.nullRuntimeInfo)))
d209 1
a209 1
	Absyn.VALexp (annotate' (Ident.LONGVALID (Ident.mkPath [], idfn pE),location))
d219 1
a219 1
	Absyn.VALpat (annotate'' (Ident.LONGVALID (Ident.mkPath [], x)),location)
d275 1
a275 1
	    Absyn.VALpat (annotate'' (Ident.LONGVALID (Ident.mkPath [], var)),location)
d282 1
a282 1
	      (lab, Absyn.LAYEREDpat (annotate'' var, pat))
d288 1
a288 1
	      (lab, Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate'' var, pat), ty, location))
d305 1
a305 1
	   [(Absyn.RECORDpat ([(lab,Absyn.VALpat (annotate'' var,location))],
d307 1
a307 1
	     Absyn.VALexp (annotate' (var,location)),
d377 1
a377 1
                                                        (annotate'(var,location)), 
d392 1
a392 1
	  [(Absyn.VALpat (annotate'' var,location),
d395 1
a395 1
	 Absyn.APPexp (Absyn.VALexp (annotate'(var,location)),
d444 1
a444 1
	       [(Absyn.VALpat (annotate'' var,location), wrap (vars,body,num+1,location),location)])
d458 1
a458 1
              [(Absyn.VALpat (annotate'' (Ident.LONGVALID (Ident.mkPath [], var)),location),body,location)]
d464 1
a464 1
                                                 (annotate'(var,location))) vars)
d467 1
a467 1
            [(Absyn.VALpat (annotate'' funid,location),
d484 1
a484 1
                                                 (annotate'(var,location))) vars)
d487 1
a487 1
            [(Absyn.VALpat (annotate'' funid,location),
d489 1
a489 1
                    Absyn.APPexp (Absyn.VALexp (annotate'(aux_funid,location)),
d497 1
a497 1
            (Absyn.VALpat (annotate'' aux_funid,location),body,location)]
d545 1
a545 1
            val external_exps = map (fn (Absyn.VALpat ((valid,_),location)) => Absyn.VALexp (annotate'(valid,location))
@


1.36
log
@Efficiency improvements to lookup
@
text
@d3 3
d448 1
a448 2
        val (a,b) = (annotate (map make_line clauses))
        
d453 1
a453 1
              val body = Absyn.FNexp(a,b,info_generator name_string,location)
d460 19
d482 1
a482 1
            val body = Absyn.FNexp(a,b,info_generator (name_string^"<Uncurried>"),location)
d496 1
@


1.35
log
@Abstraction of  debug information
@
text
@d3 3
d188 4
a191 1
          (fn pE => PE.lookupValId (([],sym),pE) handle PE.Lookup => Ident.VAR sym)
@


1.34
log
@Minor efficiency improvement to labn
@
text
@d3 3
d156 3
a158 4
    fun annotate' (thing,location)
      = (thing, ref Absyn.nullType, location,
         ref(nil,Absyn.Option.ABSENT))
    fun annotate'' thing = (thing, ref (Absyn.nullType,Absyn.Option.ABSENT,nil))
d511 1
a511 1
                        Absyn.VALpat((lvi,ref (Absyn.nullType,Absyn.Option.ABSENT,nil)),loc)
@


1.33
log
@tail recursions for types, patterns etc. make_funs
@
text
@d3 3
d168 10
a177 1
    fun labn (n) = Ident.LAB (Symbol.find_symbol (MLWorks.Integer.makestring n))
d216 1
a216 1
    fun trec_make (action) =
d218 2
a219 2
	fun trec_make' ([],_,r) = rev r
	  | trec_make' (a::l,n,r) = trec_make'(l,n+1,(action(n),a)::r)
d221 1
a221 1
        fn (l,n) => trec_make'(l,n,[])
d225 1
a225 6
    local
      val make_tuple = trec_make(labn)      
    in
      fun make_tuple_ty tys = Absyn.RECORDty (make_tuple (tys,1))
    end

d231 3
a233 8
    local
      val make_tuple = trec_make(labn)
    in
       fun make_tuple_pat [pat] = pat
	 | make_tuple_pat pats =
	     Absyn.RECORDpat (make_tuple (pats,1), false, ref Absyn.nullType)
    end

d283 2
a284 6
    local
      val  make_tuple = trec_make(labn)
    in
      fun make_tuple_exp [exp] = exp
	| make_tuple_exp exps  = Absyn.RECORDexp (make_tuple (exps,1))
    end
@


1.32
log
@Make make_list_exp' tail-recursive, to improve parsing of files with
long lists.
@
text
@d3 4
d202 3
a204 2
  
    fun make_tuple_ty tys =
d206 2
a207 4
	(* not tail recursive *)
	fun make_tuple (nil,_) = nil
	  | make_tuple (ty::tys,n) =
	    (labn n, ty) :: make_tuple (tys,n+1)
d209 1
a209 1
	Absyn.RECORDty (make_tuple (tys,1))
d213 7
d224 24
a247 10
    fun make_tuple_pat [pat] = pat
      | make_tuple_pat pats =
	let
	  (* not tail recursive *)
	  fun make_tuple (nil,_) = nil
	    | make_tuple (pat::pats,n) =
	      (labn n, pat) :: make_tuple (pats,n+1)
	in
	  Absyn.RECORDpat (make_tuple (pats,1), false, ref Absyn.nullType)
	end
d249 3
a251 7
    (* not tail recursive *)
    fun make_list_pat (nil,location,pE) = NILpat(location,pE)
      | make_list_pat (pat::pats,location,pE) =
	Absyn.APPpat (annotate (Ident.LONGVALID (Ident.mkPath [], CONSid pE)),
		      make_tuple_pat[pat,make_list_pat(pats,location,pE)],
                      location,
                      true)
d281 7
a287 11
    fun make_tuple_exp [exp] = exp
      | make_tuple_exp exps =
	let
	  (* not tail recursive *)
	  fun make_tuple (nil,_) = nil
	    | make_tuple (exp::exps,n) =
	      (labn n, exp) :: make_tuple (exps,n+1)
	in
	  Absyn.RECORDexp (make_tuple (exps,1))
	end
  
d334 21
a354 6
    (* not tail recursive *)
    fun make_sequence_exp [(exp,_,_)] = exp
      | make_sequence_exp ((exp,annotation,location)::exps) =
	make_case (exp,[(Absyn.WILDpat,make_sequence_exp exps,location)],annotation,location)
      | make_sequence_exp _ =
	Crash.impossible"make_sequence nil"
@


1.31
log
@Type function recording for Modules Debugger;
Deleted compiler option debug_polyvariables passing to parser functions.
@
text
@d3 4
d198 1
a198 1

d201 1
d217 1
d225 1
d264 1
d318 1
d360 7
a366 7
        fun make_list_exp' nil = NILexp (location,pE)
          | make_list_exp' (exp::exps) =
            Absyn.APPexp (CONSexp (location,pE),
                          make_tuple_exp[exp,make_list_exp' exps],
                          location,
                          ref Absyn.nullType,
                          true)
d368 1
a368 1
        make_list_exp' exps
@


1.30
log
@Changed info name associated with uncurried versions of functions
@
text
@d3 3
d142 1
a142 3
    fun annotate' 
      (thing,location,
       Options.OPTIONS{compiler_options = Options.COMPILEROPTIONS{debug_polyvariables,...},...})
d144 2
a145 5
         if debug_polyvariables then
           Absyn.Option.PRESENT(ref(nil,Absyn.Option.ABSENT))
         else 
           Absyn.Option.ABSENT)
    fun annotate'' thing = (thing, ref (Absyn.nullType,Absyn.Option.ABSENT))
d174 2
a175 2
      fun make_exp idfn (location,pE,options) = 
	Absyn.VALexp (annotate' (Ident.LONGVALID (Ident.mkPath [], idfn pE),location,options))
d264 1
a264 1
    fun make_select (lab,location,annotation,options) = 
d271 1
a271 1
	     Absyn.VALexp (annotate' (var,location,options)),
d298 2
a299 2
    fun make_orelse (exp1,exp2,annotation,location,pE,options) =
      make_if (exp1,TRUEexp(location,pE,options),exp2,annotation,location,pE)
d304 1
a304 1
    fun make_andalso (exp1,exp2,annotation,location,pE,options) =
d306 1
a306 1
	(exp1,[(FALSEpat(location,pE), FALSEexp(location,pE,options), location),
d316 1
a316 1
    fun make_while (exp1,exp2,annotation_function,location,pE,options) =
d325 1
a325 1
                                                        (annotate'(var,location,options)), 
d343 1
a343 1
	 Absyn.APPexp (Absyn.VALexp (annotate'(var,location,options)),
d349 1
a349 1
    fun make_list_exp (exps,location,pE,options) =
d351 1
a351 1
        fun make_list_exp' nil = NILexp (location,pE,options)
d353 1
a353 1
            Absyn.APPexp (CONSexp (location,pE,options),
d365 1
a365 1
                       options,options') =
d372 1
d395 1
a395 3
                         info_generator(if num=0 
                                          then name_string 
                                        else name_string ^ (" argument " ^ MLWorks.Integer.makestring num)),
d398 1
d414 1
a414 1
                                                 (annotate'(var,location,options'))) vars)
d419 1
a419 1
                    Absyn.APPexp (Absyn.VALexp (annotate'(aux_funid,location,options')),
d451 1
a451 1
    fun make_fun (matches,tyvarset,location,options) =
d471 1
a471 1
                        Absyn.VALpat((lvi,ref (Absyn.nullType,Absyn.Option.ABSENT)),loc)
d474 1
a474 1
            val external_exps = map (fn (Absyn.VALpat ((valid,_),location)) => Absyn.VALexp (annotate'(valid,location,options))
d511 1
a511 1
		| subst_appty ((tyvars',tycon',ty')::rest) = 
d558 2
a559 2
	fun subst_binding (tyvars,tycon,tyref,conbind) =
	      (tyvars,tycon,tyref,subst_conbind conbind)
@


1.29
log
@Added error checking in the withtype construct (see the comment there).
@
text
@d3 3
d397 2
a398 2
                                                  then name_string 
                                                else name_string ^ (" argument " ^ MLWorks.Integer.makestring num)),
a400 2
        val tuple_exp = make_tuple_exp (map (fn var => Absyn.VALexp 
                                             (annotate'(var,location,options'))) vars)
d402 1
a402 1
        val body = Absyn.FNexp(a,b,info_generator name_string,location)
d406 5
a410 1
            [(Absyn.VALpat (annotate'' (Ident.LONGVALID (Ident.mkPath [], var)),location), body,location)]
d415 3
@


1.28
log
@Added fixity annotations to abstract syntax.
@
text
@d3 3
d104 1
d118 1
d120 1
a120 1
  sharing PE.Ident = Absyn.Ident
d481 15
a495 1
    fun substitute_datbind (datbind,typbind) =
d507 33
a539 24
		    let 
		      fun subst_tyvars (Absyn.RECORDty tyrow) =
			  Absyn.RECORDty 
			  (map (fn (lab,ty) => (lab, subst_tyvars ty)) tyrow)
			| subst_tyvars (Absyn.FNty (ty,ty')) =
			  Absyn.FNty (subst_tyvars ty, subst_tyvars ty')
			| subst_tyvars (Absyn.APPty (tys,tycon,location)) =
			  Absyn.APPty (map subst_tyvars tys, tycon,location)
			| subst_tyvars (ty as (Absyn.TYVARty tyvar)) =
			  let
			    fun subst_tyvar (nil,nil) = ty
			      | subst_tyvar (tyvar'::tyvars,ty'::tys) =
				if tyvar = tyvar' then
				  ty'
				else
				  subst_tyvar (tyvars,tys)
			      | subst_tyvar _ =
				Crash.impossible"subst_tyvars list length"
			  in
			    subst_tyvar (tyvars',tys)
			  end
		    in
		      subst_tyvars ty'
		    end
d559 1
a559 1
    fun make_datatype_withtype (location,datbind,typbind) =
d561 1
a561 1
      [Absyn.DATATYPEdec (location,substitute_datbind (datbind,typbind)),
d564 1
a564 1
    fun make_abstype_withtype (location,datbind,typbind,dec) =
d566 1
a566 1
      (location,substitute_datbind (datbind,typbind),
a595 4
    



@


1.27
log
@Merged in bug fix.
@
text
@d3 3
d217 2
a218 1
                      location)
d276 1
a276 1
                      location,ref Absyn.nullType)
d283 1
a283 1
                      location,ref(Absyn.nullType))
d322 2
a323 1
                                                        ref Absyn.nullType), 
d339 2
a340 1
                       ref(Absyn.nullType)))
d350 2
a351 1
                          ref Absyn.nullType)
d411 2
a412 1
                                  ref Absyn.nullType),
@


1.26
log
@Instances for polymorphic debugger.
@
text
@d3 10
d291 3
d295 4
a298 1
      make_if (exp1,exp2,FALSEexp(location,pE,options),annotation,location,pE)
@


1.25
log
@Added location information to matches
@
text
@d3 3
d89 1
d99 1
d113 1
d118 9
a126 2
    fun annotate' (thing,location) = (thing, ref Absyn.nullType, location)
    fun annotate'' thing = (thing, ref (Absyn.nullType))
d155 2
a156 2
      fun make_exp idfn (location,pE) = 
	Absyn.VALexp (annotate' (Ident.LONGVALID (Ident.mkPath [], idfn pE),location))
d158 1
a158 1
      val NILexp = make_exp NILid
d244 1
a244 1
    fun make_select (lab,location,annotation) = 
d251 1
a251 1
	     Absyn.VALexp (annotate' (var,location)),
d278 2
a279 2
    fun make_orelse (exp1,exp2,annotation,location,pE) =
      make_if (exp1,TRUEexp(location,pE),exp2,annotation,location,pE)
d281 2
a282 2
    fun make_andalso (exp1,exp2,annotation,location,pE) =
      make_if (exp1,exp2,FALSEexp(location,pE),annotation,location,pE)
d290 1
a290 1
    fun make_while (exp1,exp2,annotation_function,location,pE) =
d298 2
a299 1
					 (Absyn.APPexp (Absyn.VALexp (annotate'(var,location)), 
d316 1
a316 1
	 Absyn.APPexp (Absyn.VALexp (annotate'(var,location)),
d321 1
a321 1
    fun make_list_exp (exps,location,pE) =
d323 1
a323 1
        fun make_list_exp' nil = NILexp (location,pE)
d325 1
a325 1
            Absyn.APPexp (CONSexp (location,pE),
d335 2
a336 1
    fun make_fvalbind ((clauses as ((var,patlist,_,_) :: _),info_generator,location),options) =
d370 2
a371 1
        val tuple_exp = make_tuple_exp (map (fn var => Absyn.VALexp (annotate'(var,location))) vars)
d385 1
a385 1
                    Absyn.APPexp (Absyn.VALexp (annotate'(aux_funid,location)),
d416 1
a416 1
    fun make_fun (matches,tyvarset,location) =
d432 8
a439 2
            val external_pats = map (fn ((x,_,_)::_) => x | _ => Crash.impossible "Bad list in make_fun") matches
            val external_exps = map (fn (Absyn.VALpat ((valid,_),location)) => Absyn.VALexp (annotate'(valid,location))
@


1.25.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.25  1993/08/06  13:50:19  matthew
Added location information to matches

@


1.25.1.2
log
@Changed order of cases in translation of andalso, to make generation of
error messages easier in typechecker._core_rules.
@
text
@a2 3
Revision 1.25.1.1  1993/08/06  13:50:19  jont
Fork for bug fixing

a270 3
    (* Handle andalso explicitly, so that the cases are in the right order
       for constructing error messages in the case of type mismatches.
       See typechecker._core_rules. *)
d272 1
a272 4
      make_case (exp1,[(FALSEpat(location,pE),FALSEexp(location,pE),location),
      		       (TRUEpat(location,pE),exp2,location)],
                 annotation,
                 location)
@


1.24
log
@structure Option.
@
text
@d3 3
d238 2
a239 1
	     Absyn.VALexp (annotate' (var,location)))])
d260 4
a263 1
      make_case (exp1,[(TRUEpat(location,pE),exp2),(FALSEpat(location,pE),exp3)],annotation,location)
d273 1
a273 1
	make_case (exp,[(Absyn.WILDpat,make_sequence_exp exps)],annotation,location)
d293 2
a294 1
                      pE))])      
d321 1
a321 1
    fun make_fvalbind ((clauses as ((var,patlist,_) :: _),info_generator,location),options) =
d333 1
a333 1
	fun make_line (var',patlist',exp) =
d341 1
a341 1
           (make_tuple_pat patlist',exp))
d343 2
a344 2
	fun wrap (nil,body,_) = body
	  | wrap (var::vars,body,num) =
d347 1
a347 1
	       [(Absyn.VALpat (annotate'' var,location), wrap (vars,body,num+1))])
d361 1
a361 1
            [(Absyn.VALpat (annotate'' (Ident.LONGVALID (Ident.mkPath [], var)),location), body)]
d373 4
a376 2
                    0)),
            (Absyn.VALpat (annotate'' aux_funid,location),body)]
d407 5
a411 1
            Absyn.VALdec ([], map (fn [(x,y)] => (x,y,location)| _ => Crash.impossible "Bad singleton list in make_fun") matches, tyvarset)
d416 1
a416 1
            val external_pats = map (fn ((x,_)::_) => x | _ => Crash.impossible "Bad list in make_fun") matches
d425 1
a425 1
            Absyn.LOCALdec (Absyn.VALdec ([],map (fn (x,y) => (x,y,location)) match, tyvarset),
@


1.23
log
@Removed integer parameter
@
text
@d3 3
d109 1
a109 1
    fun annotate' (thing,location) = (thing, ref Absyn.nullType,location)
d199 1
a199 1
	    (Absyn.ABSENT, Absyn.ABSENT) => (lab,valpat)
d201 1
a201 1
	  | (Absyn.ABSENT, Absyn.PRESENT pat) => 
d204 1
a204 1
	  | (Absyn.PRESENT ty, Absyn.ABSENT) =>
d207 1
a207 1
	  | (Absyn.PRESENT ty, Absyn.PRESENT pat) => 
d243 2
a244 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, location,ref Absyn.nullType)
d250 2
a251 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, location,ref(Absyn.nullType))
d280 2
a281 1
                                                        ref Absyn.nullType), "in make_while",location)],
d340 2
a341 1
		Absyn.FNexp (a,b,info_generator(if num=0 
d458 1
a458 1
	  | subst_conbind ((binding as (_,Absyn.ABSENT)) :: rest) =
d460 2
a461 2
	  | subst_conbind ((con,Absyn.PRESENT ty) :: rest) =
	    (con,Absyn.PRESENT (subst_ty ty)) :: subst_conbind rest
d492 4
a495 4
	    Absyn.ABSENT => sigexp'
	  | Absyn.PRESENT (Absyn.OLDsigexp _) => sigexp'
	  | Absyn.PRESENT (Absyn.NEWsigexp (spec',int)) => 
	      Absyn.PRESENT
@


1.22
log
@Options & Info changes
Absyn changes
@
text
@d3 4
a77 1
require "../utils/integer";
a86 1
  structure Integer : INTEGER
d110 1
a110 1
	val s = "_G" ^ Integer.makestring (Counter.counter ())
d118 1
a118 1
    fun labn (n) = Ident.LAB (Symbol.find_symbol (Integer.makestring n))
d336 1
a336 1
                                                else name_string ^ (" argument " ^ Integer.makestring num)),
@


1.21
log
@Look up true,false etc. in parser env. for derived forms
@
text
@d3 3
d89 2
a90 2
  sharing PE.Ident = Absyn.Datatypes.Ident
  sharing Absyn.Location = Info.Location
d96 1
a96 2
    structure Datatypes = Absyn.Datatypes
    structure Ident = Datatypes.Ident
d103 2
a104 2
    fun annotate thing = (thing, ref Datatypes.NULLTYPE)
    fun annotate' (thing,location) = (thing, ref Datatypes.NULLTYPE,location)
d166 1
a166 1
    fun make_unit_pat () = Absyn.RECORDpat ([],false,ref Datatypes.NULLTYPE)
d175 1
a175 1
	  Absyn.RECORDpat (make_tuple (pats,1), false, ref Datatypes.NULLTYPE)
d228 1
a228 1
			      true,ref Datatypes.NULLTYPE),
d238 1
a238 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, location,ref Datatypes.NULLTYPE)
d244 1
a244 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,location) , exp, location,ref(Datatypes.NULLTYPE))
d273 1
a273 1
                                                        ref Datatypes.NULLTYPE), "in make_while",location)],
d287 1
a287 1
                       ref(Datatypes.NULLTYPE)))
d297 1
a297 1
                          ref Datatypes.NULLTYPE)
d354 1
a354 1
                                  ref Datatypes.NULLTYPE),
@


1.20
log
@Changed the functor parameter signature name in the derived funbinds to
be "_".  There is no need to have different names for different functors.
@
text
@d3 4
d74 1
d84 3
d94 2
a95 1
    structure Symbol = Datatypes.Ident.Symbol
d98 1
a99 2
    open Datatypes
      
d101 2
a102 2
    fun annotate thing = (thing, ref NULLTYPE)
    fun annotate' (thing,marks) = (thing, ref NULLTYPE,marks)
d116 13
a128 5
    val NILcon = Ident.CON (Symbol.find_symbol "nil")
    val CONScon = Ident.CON (Symbol.find_symbol "::")
    val TRUEcon = Ident.CON (Symbol.find_symbol "true")
    val FALSEcon = Ident.CON (Symbol.find_symbol "false")
    val itvar = Ident.VAR (Symbol.find_symbol "it")
d131 2
a132 2
      fun make_exp x marks = 
	Absyn.VALexp (annotate' (Ident.LONGVALID (Ident.mkPath [], x),marks))
d134 4
a137 4
      val NILexp = make_exp NILcon
      val CONSexp = make_exp CONScon
      val TRUEexp = make_exp TRUEcon
      val FALSEexp = make_exp FALSEcon
d144 4
a147 4
      fun NILpat(marks) = make_pat (NILcon,marks) (* now a function *)
      val TRUEpat = make_pat (TRUEcon,Absyn.Location.UNKNOWN)
      val FALSEpat = make_pat (FALSEcon,Absyn.Location.UNKNOWN)
      val itpat = make_pat (itvar,Absyn.Location.UNKNOWN)
d164 1
a164 1
    fun make_unit_pat () = Absyn.RECORDpat ([],false,ref NULLTYPE)
d173 1
a173 1
	  Absyn.RECORDpat (make_tuple (pats,1), false, ref NULLTYPE)
d176 5
a180 5
    fun make_list_pat (nil,marks) = NILpat marks
      | make_list_pat (pat::pats,marks) =
	Absyn.APPpat (annotate (Ident.LONGVALID (Ident.mkPath [], CONScon)),
		      make_tuple_pat[pat,make_list_pat(pats,marks)],
                      marks)
d183 1
a183 1
    fun make_patrow (sym, opt_ty, opt_pat,marks) =
d188 1
a188 1
	    Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], var)),marks)
d198 1
a198 1
	      (lab, Absyn.TYPEDpat (valpat, ty,marks))
d201 1
a201 1
	      (lab, Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate var, pat), ty, marks))
d220 1
a220 1
    fun make_select (lab,marks,annotation) = 
d225 3
a227 3
	   [(Absyn.RECORDpat ([(lab,Absyn.VALpat (annotate var,marks))],
			      true,ref NULLTYPE),
	     Absyn.VALexp (annotate' (var,marks)))])
d229 1
a229 1
	Absyn.FNexp (a,b,annotation,marks)
d233 1
a233 1
    fun make_case (exp,match,annotation,marks) =
d236 1
a236 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,marks) , exp, marks,ref Datatypes.NULLTYPE)
d239 1
a239 1
    fun make_case' (exp,match,annotation,marks) = 
d242 1
a242 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,marks) , exp, marks,ref(Datatypes.NULLTYPE))
d245 2
a246 2
    fun make_if (exp1,exp2,exp3,annotation,marks) =
      make_case (exp1,[(TRUEpat,exp2),(FALSEpat,exp3)],annotation,marks)
d248 2
a249 2
    fun make_orelse (exp1,exp2,annotation,marks) =
      make_if (exp1,TRUEexp marks,exp2,annotation,marks)
d251 2
a252 2
    fun make_andalso (exp1,exp2,annotation,marks) =
      make_if (exp1,exp2,FALSEexp marks,annotation,marks)
d255 2
a256 2
      | make_sequence_exp ((exp,annotation,marks)::exps) =
	make_case (exp,[(Absyn.WILDpat,make_sequence_exp exps)],annotation,marks)
d260 1
a260 1
    fun make_while (exp1,exp2,annotation_function,marks) =
d267 2
a268 2
		      make_sequence_exp [(exp2,"in make_while",marks),
					 (Absyn.APPexp (Absyn.VALexp (annotate'(var,marks)), 
d270 2
a271 2
                                                        marks,
                                                        ref Datatypes.NULLTYPE), "in make_while",marks)],
d273 3
a275 1
                      "While statement",marks))])      
d280 2
a281 2
	  [(Absyn.VALpat (annotate var,marks),
	    Absyn.FNexp (a,b,annotation_function "while statement",marks),marks)],
d283 2
a284 2
	 Absyn.APPexp (Absyn.VALexp (annotate'(var,marks)),
		       make_unit_exp (),marks,
d288 1
a288 1
    fun make_list_exp marks expr =
d290 1
a290 1
        fun make_list_exp' nil = NILexp marks
d292 1
a292 1
            Absyn.APPexp (CONSexp marks,
d294 1
a294 1
                          marks,
d297 1
a297 1
        make_list_exp' expr
d302 1
a302 1
    fun make_fvalbind ((clauses as ((var,patlist,_) :: _),info_generator,marks),options) =
d319 1
a319 1
               Info.error options(Info.RECOVERABLE, marks, "Different pattern lengths in clauses")
d321 1
a321 1
             Info.error options (Info.RECOVERABLE, marks, "Inconsistent function names");
d328 1
a328 1
	       [(Absyn.VALpat (annotate var,marks), wrap (vars,body,num+1))])
d333 1
a333 1
                marks)
d335 1
a335 1
        val tuple_exp = make_tuple_exp (map (fn var => Absyn.VALexp (annotate'(var,marks))) vars)
d337 1
a337 1
        val body = Absyn.FNexp(a,b,info_generator name_string,marks)
d341 1
a341 1
            [(Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], var)),marks), body)]
d347 1
a347 1
            [(Absyn.VALpat (annotate funid,marks),
d349 1
a349 1
                    Absyn.APPexp (Absyn.VALexp (annotate'(aux_funid,marks)),
d351 1
a351 1
                                  marks,
d354 1
a354 1
            (Absyn.VALpat (annotate aux_funid,marks),body)]
d359 12
a371 1
    (* declarations *)
d374 2
a375 2
    fun make_fun (match,tyvarset,marks) = 
      Absyn.VALdec ([], map (fn (x,y) => (x,y,marks)) match, tyvarset)
d378 1
a378 1
    fun make_fun (matches,tyvarset,marks) =
d385 1
a385 1
            Absyn.VALdec ([], map (fn [(x,y)] => (x,y,marks)| _ => Crash.impossible "Bad singleton list in make_fun") matches, tyvarset)
d391 1
a391 1
            val external_exps = map (fn (Absyn.VALpat ((valid,_),marks)) => Absyn.VALexp (annotate'(valid,marks))
d394 1
a394 1
            val external_decs = Absyn.VALdec (map (fn (pat,exp) => (pat,exp,marks))
d399 1
a399 1
            Absyn.LOCALdec (Absyn.VALdec ([],map (fn (x,y) => (x,y,marks)) match, tyvarset),
d411 1
a411 1
	  | subst_ty (ty as (Absyn.APPty (tys,tycon,marks))) =
d413 1
a413 1
	      fun subst_appty nil = Absyn.APPty(map subst_ty tys,tycon,marks)
d422 2
a423 2
			| subst_tyvars (Absyn.APPty (tys,tycon,marks)) =
			  Absyn.APPty (map subst_tyvars tys, tycon,marks)
d477 1
a477 1
    fun make_funbind (funid,sigexp,strexp,sigexp',marks) =
d486 1
a486 1
	       (Absyn.LOCALspec (Absyn.OPENspec ([dummy_longstrid],marks), spec'),int))
d490 1
a490 1
	  (Absyn.DECstrdec (Absyn.OPENdec ([dummy_longstrid],marks)), strexp)
@


1.19
log
@ref Nameset removed from FunBind abstract syntax
@
text
@d3 3
a107 8
    fun new_strid () = 
      let
	val s = "_S" ^ Integer.makestring (Counter.counter ())
      in
	Ident.STRID (Symbol.find_symbol s)
      end


d442 6
a449 3
	val strid = new_strid ()
	val longstrid = Ident.LONGSTRID (Ident.mkPath [],strid)

d457 1
a457 1
	       (Absyn.LOCALspec (Absyn.OPENspec ([longstrid],marks), spec'),int))
d461 1
a461 1
	  (Absyn.DECstrdec (Absyn.OPENdec ([longstrid],marks)), strexp)
d463 1
a463 1
	(funid,strid,sigexp,strexp',sigexp'')
@


1.18
log
@Fixed problem in make_fvalbind to cope with error recovery.
@
text
@d3 3
a84 1
    structure Nameset = Absyn.Nameset
d465 1
a465 1
	(funid,strid,sigexp,ref (Nameset.empty_nameset()),strexp',sigexp'')
@


1.17
log
@Changed Error structure to Info
@
text
@d3 3
d290 1
d292 2
a293 1
          | name_to_string _ = Crash.impossible "function name not of the correct form in _derived"
@


1.16
log
@Tynames now have a slot recording their definition point
@
text
@d3 3
d60 1
a60 1
require "../main/error";
d69 2
a70 2
  structure Error : ERROR
  sharing Absyn.Location = Error.Location
d80 2
d284 1
a284 2
(*
    fun make_fvalbind (clauses as ((var,patlist,_) :: _),info_generator,marks) =
d299 1
a299 2
               Error.report
               (Error.ERROR (Error.RECOVERABLE, marks, "Different pattern lengths in clauses"))
d301 1
a301 51
             Error.report
             (Error.ERROR (Error.RECOVERABLE, marks, "Inconsistent function names"));
           (make_tuple_pat patlist',exp))

	fun wrap (nil,body,_) = body
	  | wrap (var::vars,body,num) =
	    let val (a,b) =
	      (annotate 
	       [(Absyn.VALpat (annotate var,marks), wrap (vars,body,num+1))])
	      in
		Absyn.FNexp (a,b,info_generator(if num=0 
                                                  then name_string 
                                                else name_string ^ (" argument " ^ Integer.makestring num)),
                marks)
	    end
      in
	let 
	  val tuple_exp = 
	    make_tuple_exp 
	    (map (fn var => Absyn.VALexp (annotate'(var,marks))) vars)

	  val body = make_case' (tuple_exp, map make_line clauses,info_generator name_string,marks)

	in
	  (Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], var)),marks),
	   wrap (vars,body,0))
	end
      end
    | make_fvalbind _ = Crash.impossible"make_fvalbind bad parameters"
 *)

    fun make_fvalbind (clauses as ((var,patlist,_) :: _),info_generator,marks) =
      let

        fun name_to_string(Ident.VAR x) = Ident.Symbol.symbol_name x
          | name_to_string _ = Crash.impossible "function name not of the correct form in _derived"

        val name_string = name_to_string var
	val patlength = Lists.length patlist
	val vars = new_vars patlength

	fun make_line (var',patlist',exp) =
          (if var = var' then
             if Lists.length patlist' = patlength then
               ()
             else
               Error.report
               (Error.ERROR (Error.RECOVERABLE, marks, "Different pattern lengths in clauses"))
           else
             Error.report
             (Error.ERROR (Error.RECOVERABLE, marks, "Inconsistent function names"));
@


1.15
log
@Added generation of local uncurried versions of curried functions.
Also don't generate intermediate functions in uncurried case.
@
text
@d3 4
d475 1
a475 1
    fun make_datatype_withtype (datbind,typbind) =
d477 1
a477 1
      [Absyn.DATATYPEdec (substitute_datbind (datbind,typbind)),
d480 1
a480 1
    fun make_abstype_withtype (datbind,typbind,dec) =
d482 1
a482 1
      (substitute_datbind (datbind,typbind),
@


1.14
log
@Improved error messages.
@
text
@d3 3
d275 1
d323 59
d385 1
d388 27
@


1.13
log
@Removed some structures and sharing
@
text
@d3 3
d50 1
d59 2
a60 1

d113 2
a114 2
      fun make_pat x = 
	Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], x)))
d116 4
a119 4
      fun NILpat() = make_pat NILcon (* now a function *)
      val TRUEpat = make_pat TRUEcon
      val FALSEpat = make_pat FALSEcon
      val itpat = make_pat itvar
d148 2
a149 2
    fun make_list_pat nil = NILpat()
      | make_list_pat (pat::pats) =
d151 2
a152 1
		      make_tuple_pat[pat,make_list_pat pats])
d155 1
a155 1
    fun make_patrow (sym, opt_ty, opt_pat) =
d160 1
a160 1
	    Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], var)))
d170 1
a170 1
	      (lab, Absyn.TYPEDpat (valpat, ty))
d173 1
a173 1
	      (lab, Absyn.TYPEDpat (Absyn.LAYEREDpat (annotate var, pat), ty))
d197 1
a197 2
	   [(Absyn.RECORDpat ([(lab,Absyn.VALpat 
				(annotate var))],
d250 1
a250 1
	  [(Absyn.VALpat (annotate var),
d283 10
a292 7
	    if var = var' then
	      if Lists.length patlist' = patlength then
		(make_tuple_pat patlist',exp)
	      else
		raise (FvalBind "Different pattern lengths in clauses")
	    else
	      raise (FvalBind "Inconsistent function names")
d298 1
a298 1
	       [(Absyn.VALpat (annotate var), wrap (vars,body,num+1))])
d314 1
a314 1
	  (Absyn.VALpat (annotate (Ident.LONGVALID (Ident.mkPath [], var))),
d332 1
a332 1
	  | subst_ty (ty as (Absyn.APPty (tys,tycon))) =
d334 1
a334 1
	      fun subst_appty nil = Absyn.APPty(map subst_ty tys,tycon)
d343 2
a344 2
			| subst_tyvars (Absyn.APPty (tys,tycon)) =
			  Absyn.APPty (map subst_tyvars tys, tycon)
d404 1
a404 1
	       (Absyn.LOCALspec (Absyn.OPENspec [longstrid], spec'),int))
@


1.12
log
@Made NILpat a function, not a constant.  This may or may not have been a bug.
@
text
@d3 3
d41 1
a41 1
require "../utils/set";
a46 4
require "../basics/symbol";
require "../basics/identprint";
require "../typechecker/datatypes";
require "../typechecker/nameset";
a49 1
  structure Set : SET
a54 4
  structure Symbol : SYMBOL
  structure Datatypes : DATATYPES
  structure Nameset : NAMESET
  structure IdentPrint : IDENTPRINT
a55 5
  sharing Absyn.Nameset = Nameset
  sharing Absyn.Set = Set
  sharing Symbol = Datatypes.Ident.Symbol
  sharing Datatypes = Absyn.Datatypes
  sharing Absyn.IdentClass = Datatypes.Ident = IdentPrint.Ident
a59 2
    structure Datatypes = Datatypes
    structure Nameset = Nameset
d61 4
a64 3
    structure Symbol = Symbol
    structure Set = Set
    
@


1.11
log
@Call point information added, and fixed a bug with withtype
@
text
@d3 3
d123 1
a123 2
      val NILpat = make_pat NILcon
      val CONSpat = make_pat CONScon
d155 1
a155 1
    fun make_list_pat nil = NILpat
@


1.10
log
@Changed to imperative implementation of namesets with hashing
@
text
@d3 3
d213 1
a213 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,marks) , exp, marks)
d219 1
a219 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation,marks) , exp, marks)
d247 2
a248 1
                                                        marks), "in make_while",marks)],
d259 2
a260 1
		       make_unit_exp (),marks))
d269 2
a270 1
                          marks)
d336 1
a336 1
	      fun subst_appty nil = ty
@


1.9
log
@More annotation in the make_case' generated functions
@
text
@d3 3
d406 1
a406 1
	(funid,strid,sigexp,ref Nameset.empty_nameset,strexp',sigexp'')
@


1.8
log
@Added marks for some error messages from the typechecker
@
text
@d3 3
d210 1
a210 1
    fun make_case' (exp,match,marks) = 
d213 1
a213 1
	Absyn.APPexp (Absyn.FNexp(a,b,"make case' in derived",marks) , exp, marks)
d304 1
a304 1
	  val body = make_case' (tuple_exp, map make_line clauses,marks)
@


1.7
log
@Added marks to allow position reporting from the typechecker
@
text
@d3 3
d197 1
a197 1
	Absyn.FNexp (a,b,annotation)
d204 1
a204 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation) , exp, marks)
d210 1
a210 1
	Absyn.APPexp (Absyn.FNexp(a,b,"make case' in derived") , exp, marks)
d246 1
a246 1
	    Absyn.FNexp (a,b,annotation_function "while statement"),marks)],
d292 2
a293 1
                                                else name_string ^ (" argument " ^ Integer.makestring num)))
@


1.6
log
@Added more useful annotations to if,while,case statements to give better info in a stack backtrace
@
text
@d3 3
d66 1
d95 2
a96 2
      fun make_exp x = 
	Absyn.VALexp (annotate (Ident.LONGVALID (Ident.mkPath [], x)))
d98 2
a99 2
      fun NILexp() = make_exp NILcon
      fun CONSexp() = make_exp CONScon
d184 1
a184 1
    fun make_select (lab) = 
d192 1
a192 1
	     Absyn.VALexp (annotate var))])
d194 1
a194 1
	Absyn.FNexp (a,b,"select statement in derived")
d198 1
a198 1
    fun make_case (exp,match,annotation) = 
d201 1
a201 1
	Absyn.APPexp (Absyn.FNexp(a,b,annotation) , exp)
d204 1
a204 1
    fun make_case' (exp,match) = 
d207 1
a207 1
	Absyn.APPexp (Absyn.FNexp(a,b,"make case' in derived") , exp)
d210 2
a211 2
    fun make_if (exp1,exp2,exp3,annotation) =
      make_case (exp1,[(TRUEpat,exp2),(FALSEpat,exp3)],annotation)
d213 2
a214 2
    fun make_orelse (exp1,exp2,annotation) =
      make_if (exp1,TRUEexp,exp2,annotation)
d216 2
a217 2
    fun make_andalso (exp1,exp2,annotation) =
      make_if (exp1,exp2,FALSEexp,annotation)
d219 3
a221 3
    fun make_sequence_exp [(exp,_)] = exp
      | make_sequence_exp ((exp,annotation)::exps) =
	make_case (exp,[(Absyn.WILDpat,make_sequence_exp exps)],annotation)
d225 1
a225 1
    fun make_while (exp1,exp2,annotation_function) =
d232 4
a235 4
		      make_sequence_exp [(exp2,"in make_while"),
					 (Absyn.APPexp (Absyn.VALexp (annotate
								     var), 
                                                        make_unit_exp ()), "in make_while")],
d237 1
a237 1
                      "While statement"))])      
d243 1
a243 1
	    Absyn.FNexp (a,b,annotation_function "while statement"))],
d245 2
a246 2
	 Absyn.APPexp (Absyn.VALexp (annotate var),
		       make_unit_exp ()))
d249 10
a258 4
    fun make_list_exp nil = NILexp()
      | make_list_exp (exp::exps) =
	Absyn.APPexp (CONSexp(),
		      make_tuple_exp[exp,make_list_exp exps])
d262 1
a262 1
    fun make_fvalbind (clauses as ((var,patlist,_) :: _),info_generator) =
d295 1
a295 1
	    (map (fn var => Absyn.VALexp (annotate var)) vars)
d297 1
a297 1
	  val body = make_case' (tuple_exp, map make_line clauses)
d308 2
a309 1
    fun make_fun (match,tyvarset) = Absyn.VALdec ([], match, tyvarset)
d378 1
a378 1
    fun make_funbind (funid,sigexp,strexp,sigexp') =
d394 1
a394 1
	  (Absyn.DECstrdec (Absyn.OPENdec [longstrid]), strexp)
a398 4
    (* topdec *)

    fun make_itdec (exp,tyvars) =
      Absyn.VALdec ([(itpat,exp)],nil,tyvars)
@


1.5
log
@First version of the profiler
@
text
@d3 3
d194 1
a194 1
    fun make_case (exp,match) = 
d197 1
a197 1
	Absyn.APPexp (Absyn.FNexp(a,b,"make case in derived") , exp)
d206 2
a207 2
    fun make_if (exp1,exp2,exp3) =
      make_case (exp1,[(TRUEpat,exp2),(FALSEpat,exp3)])
d209 2
a210 2
    fun make_orelse (exp1,exp2) =
      make_if (exp1,TRUEexp,exp2)
d212 2
a213 2
    fun make_andalso (exp1,exp2) =
      make_if (exp1,exp2,FALSEexp)
d215 3
a217 3
    fun make_sequence_exp [exp] = exp
      | make_sequence_exp (exp::exps) =
	make_case (exp,[(Absyn.WILDpat,make_sequence_exp exps)])
d228 2
a229 2
		      make_sequence_exp [exp2,
					 Absyn.APPexp (Absyn.VALexp (annotate
d231 3
a233 2
						       make_unit_exp ())],
		      make_unit_exp ()))])      
@


1.4
log
@Added lists and integer parameters to the functor
@
text
@d3 3
d24 1
d39 1
d45 1
a45 1
  sharing Absyn.IdentClass = Datatypes.Ident
d187 1
a187 1
	Absyn.FNexp (a,b,[])
d194 1
a194 1
	Absyn.APPexp (Absyn.FNexp(a,b,[]) , exp)
d197 1
a197 1
    fun make_case' (exp,match,marks) = 
d200 1
a200 1
	Absyn.APPexp (Absyn.FNexp(a,b,marks) , exp)
d218 1
a218 1
    fun make_while (exp1,exp2) =
d235 1
a235 1
	    Absyn.FNexp (a,b,[]))],
d248 1
a248 1
    fun make_fvalbind (clauses as ((var,patlist,_) :: _),marks) =
d251 4
d267 2
a268 2
	fun wrap (nil,body) = body
	  | wrap (var::vars,body) =
d271 1
a271 1
	       [(Absyn.VALpat (annotate var), wrap (vars,body))])
d273 3
a275 1
		Absyn.FNexp (a,b,marks)
d283 1
a283 1
	  val body = make_case' (tuple_exp, map make_line clauses,marks)
d287 1
a287 1
	   wrap (vars,body))
@


1.3
log
@Fixed inexhaustive matches
@
text
@d2 4
a5 1
$Log:	_derived.sml,v $
a13 4
require "../typechecker/datatypes";
require "../typechecker/nameset";
require "../basics/absyn";
require "../basics/symbol";
d15 1
d18 5
d25 10
a34 7
functor Derived (structure Datatypes : DATATYPES
		 structure Nameset : NAMESET
		 structure Absyn : ABSYN
		 structure Symbol : SYMBOL
		 structure Set : SET
		 structure Counter : COUNTER
		 structure Crash : CRASH		
d36 6
a41 6
		 sharing Absyn.Nameset = Nameset
		 sharing Absyn.Set = Set
		 sharing Symbol = Datatypes.Ident.Symbol
		 sharing Datatypes = Absyn.Datatypes
		 sharing Absyn.IdentClass = Datatypes.Ident) 
  : DERIVED =
d246 1
a246 1
	val patlength = length patlist
d251 1
a251 1
	      if length patlist' = patlength then
@


1.2
log
@changed to handle Interface annotations in signature expressions
@
text
@d3 3
d9 1
d17 1
d26 2
a27 1
		
d202 2
d271 1
d305 2
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d333 1
a333 1
    fun make_funbind (funid,spec,strexp,sigexp) =
d338 5
a342 5
	val sigexp' = 
	  case sigexp of
	    Absyn.ABSENT => sigexp
	  | Absyn.PRESENT (Absyn.OLDsigexp sigid) => sigexp
	  | Absyn.PRESENT (Absyn.NEWsigexp spec') => 
d345 1
a345 1
	       (Absyn.LOCALspec (Absyn.OPENspec [longstrid], spec')))
d351 1
a351 2
	(funid,strid,Absyn.NEWsigexp spec,ref Nameset.empty_nameset,
	 strexp',sigexp')
@
