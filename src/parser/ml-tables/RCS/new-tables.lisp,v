head	1.2;
access;
symbols
	MLW_daveb_inline_1_4_99:1.2.11
	MLWorks_21c0_1999_03_25:1.2
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.2
	MLWorks_20b0_1998_03_20:1.2
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_20m1_1997_10_23:1.2
	MLWorks_11r1:1.2.8.1.1.1.1
	MLWorks_workspace_97:1.2.10
	MLWorks_dt_wizard:1.2.9
	MLWorks_11c0_1997_09_09:1.2.8.1.1.1
	MLWorks_10r3:1.2.8.1.3
	MLWorks_10r2_551:1.2.8.1.2
	MLWorks_11:1.2.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.8.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.8
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.6.1.1
	MLWorks_gui_1996_12_18:1.2.7
	MLWorks_1_0_Win32_1996_12_17:1.2.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2
	ML_beta_release_12/08/94:1.1
	ML_beta_release_03/08/94:1.1
	ML_revised_beta_release_25/05/94:1.1
	ML_final_beta_release_02/03/94:1.1
	mlworks-28-01-1994:1.1
	Release:1.1
	mlworks-beta-01-09-1993:1.1;
locks; strict;


1.2
date	96.03.25.15.14.40;	author matthew;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1
	1.2.9.1
	1.2.10.1
	1.2.11.1;
next	1.1;

1.1
date	93.02.12.16.33.24;	author matthew;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	93.02.12.16.33.24;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.20.49;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.10.46;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.29.18;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.12.55.06;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.15.05.48;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.13.35;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.17.52.04;	author hope;	state Exp;
branches
	1.2.6.1.1.1;
next	;

1.2.6.1.1.1
date	97.02.24.11.42.50;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	96.12.18.09.46.27;	author hope;	state Exp;
branches;
next	;

1.2.8.1
date	97.05.12.10.38.55;	author hope;	state Exp;
branches
	1.2.8.1.1.1
	1.2.8.1.2.1
	1.2.8.1.3.1;
next	;

1.2.8.1.1.1
date	97.07.28.18.23.53;	author daveb;	state Exp;
branches
	1.2.8.1.1.1.1.1;
next	;

1.2.8.1.1.1.1.1
date	97.10.07.11.49.40;	author jkbrook;	state Exp;
branches;
next	;

1.2.8.1.2.1
date	97.09.08.17.17.15;	author daveb;	state Exp;
branches;
next	;

1.2.8.1.3.1
date	97.09.09.14.13.25;	author daveb;	state Exp;
branches;
next	;

1.2.9.1
date	97.09.10.19.29.31;	author brucem;	state Exp;
branches;
next	;

1.2.10.1
date	97.09.11.20.59.20;	author daveb;	state Exp;
branches;
next	;

1.2.11.1
date	99.04.01.17.59.41;	author daveb;	state Exp;
branches;
next	;


desc
@Part of lisp parsergen for ML grammar
@


1.2
log
@Changing apply 'append to apply-append
@
text
@(in-package ml)

(defvar *actions-list*)
(defvar *actions-index*)

;; Take the actions output of make-parsing-tables and split into an array with
;; numbers and a vector with actions themselves.

(defun make-actions-list (actions)
  (let* ((*actions-list* nil)
	 (new-vector (map 'vector 'doitems actions)))
    (values (length *actions-list*) new-vector (reverse *actions-list*))))


(defun action-equal (action1 action2)
  (flet ((is-shift (action)
	     (and (null (cdr action))
		  (consp (car action))
		  (eq (car (car action)) :shift))))
    (or (and (is-shift action1)
	     (is-shift action2))
	(equal action1 action2))))

(defun doitems (x)
  (mapcar #'(lambda (item)
              (let* ((token (first item))
                     (actions (rest item))
                     (sub (member actions
			          *actions-list*
			          :test 'action-equal)))
		(cond (sub
		       (list token (1- (length sub))))
		      (t
		       (push actions *actions-list*)
		       (list token (1- (length *actions-list*)))))))
	  x))

(defun make-gotos (gotos length)
  (flet ((munge (x)
                (mapcar #'(lambda (x) (list (car x)(cdr x)))
                        x)))
    (let ((goto-vector (make-array length)))
      (maphash #'(lambda (x y) (setf (aref goto-vector x) (munge y)))
               gotos)
      goto-vector)))

(defun apply-append (l)
  (let ((result nil))
    (dolist (subl l)
      (dolist (item subl)
	(push item result)))
    (reverse result)))

(defun make-grammar-symbols (grammar)
  (sort (mapcar 'symbol-name
                (remove-duplicates
                 (apply-append (apply-append grammar))))
        'string<))

(defvar *symbols*)

(defun make-tables (grammar)
  (setq *symbols* (make-grammar-symbols grammar)))

(defun get-symbol-from-index (n)
  (nth n *symbols*))

(defun get-index-from-string (string)
  (position string *symbols* :test 'string=))

(defun get-index-from-symbol (sym)
  (get-index-from-string (symbol-name sym)))

(defun indexify (x)
  (cond ((null x) nil)
        ((numberp x) x)
        ((eq x :eoi) -1)
        ((symbolp x) (get-index-from-symbol x))
        ((consp x) (cons (indexify (car x)) (indexify (cdr x))))
        (t (map 'vector 'indexify x))))

(defun doitall (grammar)
  (multiple-value-bind (actions gotos) (parsergen::make-parsing-tables grammar)
    (let* ((length (length actions))
	   (symbols (make-grammar-symbols grammar))
           (*symbols* symbols)
           (goto-table (indexify (make-gotos gotos length))))
      (multiple-value-bind (no-of-actions actions-temp actions-list)
	  (make-actions-list actions)
        (let ((actions (indexify actions-temp)))
          (values length symbols goto-table actions actions-list))))))


(defun set-vars ()
  (multiple-value-setq (*length* *symbols* *gotos* *actions* *actions-list*)
    (doitall *mlg*))
  nil)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing functions
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; This prints the action table and the goto table
(defun print-ml-table (stream table)
  (print-separated-list stream
			(coerce table 'list)
                        ",~%  "
                        #'(lambda (row stream)
                          (print-separated-list stream
						row ", "
                                                #'(lambda (item stream)
                                                  (format stream
                                                          "(~D,~D)"
                                                          (first item)
                                                          (second item)))
                                                "[" "]"))
                        "[~%" "]~%"))

;; Print the list of actions
(defun print-action-list (stream alist)
  (print-separated-list stream
			alist
			",~%  "
			#'(lambda (actions stream)
			    (if (= (length actions) 1)
				(princ (action-string (first actions)) stream)
                              (error "Bad action list")))
			""
			"~%"))

(defun action-string (action)
  (if (eq action :accept)
      "Accept"
    (ecase (car action)
      (:shift "Shift")
      (:reduce (format nil "Reduce(~D,~A,~D)"
		       (third action)
		       (fourth action)
		       (second action)))
      (:funcall
       (destructuring-bind (name act1 act2) (cdr action)
         (format nil "Funcall(~A,~Aarity,~A,~A)"
                 (string-downcase name)
                 (string-downcase name)
                 (action-string act1)
                 (action-string act2))))
       (:resolve
        (format nil
                "Resolve[~A]"
                (actions-list-string (cdr action)))))))

(defun actions-list-string (alist)
  (cond
   ((null alist) "")
   ((null (cdr alist))
    (action-string (car alist)))
   (t
    (format nil "~A,~A"
            (action-string (car alist))
            (actions-list-string (cdr alist))))))

(defun print-separated-list (stream list separator printfun &optional (open "") (close ""))
  (format stream open)
  (when list
    (funcall printfun (car list) stream)
    (when (cdr list)
      (dolist (item (cdr list))
        (format stream separator)
        (funcall printfun item stream))))
  (format stream close))

;; Print capitalized symbols separated by "|"

(defun print-ml-symbols (syms stream)
  (print-separated-list stream syms "~% | " #'(lambda(sym stream)
						(format stream   "~A"
							(string-upcase
							 sym))) " | " "~%"))

(defun print-ml-symbol-list (syms stream)
  (print-separated-list stream syms ", ~%  " #'(lambda(sym
						       stream)(format
							       stream "~A" (string-upcase sym))) "" "~%"))

(defun print-table (table stream)
  (setq table (coerce table 'list))
  (dolist (row table)
	  (dolist (item row)
		  (dolist (n item)
			  (format stream "~D " n)))
	  (terpri stream)))

(defun print-tables (gotofile actionsfile symbolfile actionlistfile symbollistfile)
   (multiple-value-bind (length symbols gotos actions actions-list)
       (doitall *mlg*)
       (format t "~d actions~%" length)
       (with-open-file (stream gotofile :direction :output :if-exists :supersede)
	    (print-table gotos stream))
       (with-open-file (stream actionsfile :direction :output :if-exists :supersede)
	    (print-table actions stream))
       (with-open-file (stream symbolfile :direction :output :if-exists :supersede)
	    (print-ml-symbols symbols stream))
       (with-open-file (stream actionlistfile :direction :output :if-exists :supersede)
	    (print-action-list stream actions-list))
       (with-open-file (stream symbollistfile :direction :output :if-exists :supersede)
	    (print-ml-symbol-list symbols stream))))
		       

(defun print-the-tables ()
  (print-tables "gotos.data" "actions.data" "symbols.data"
		"actionlist.data" "symbollist.data"))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Action printing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun make-ml-actions (stream &optional (outstream *standard-output*))
  (let ((line (read-line stream nil nil))
	(action-number 0))
    (loop while line
	  do
	  (cond ((is-ml-line line)
		 (print-ml-header outstream action-number)
		 (loop do
		       (print-ml-line outstream line)
		       (setq line (read-line stream nil nil))
		       until
		       (not (is-ml-line line)))
		 (print-ml-tail outstream action-number)
		 (incf action-number))
		(t (if (equal line "")
		       (terpri outstream)
		     (format outstream "~%(* ~A *)" line))))
	  (setq line (read-line stream nil nil)))))

(defun print-ml-header (stream number)
  (format stream "~% " number))

(defun print-ml-tail (stream number)
  (format stream " | _ => raise ActionError ~D,~%" number))

(defun print-ml-line (stream string)
  (princ (subseq string 2) stream)
  (terpri stream))

(defun is-ml-line (string)
  (and (> (length string) 1)
       (string= (subseq string 0 2) ";#")))

(defun write-action-functions (infile outfile)
  (with-open-file (instream infile :direction :input)
     (with-open-file (outstream outfile :direction :output :if-exists :supersede)
        (make-ml-actions instream outstream)
	(format outstream "~%"))))

;; Assume here that we are in the directory where the data is to go

(defun write-the-actions ()
  (write-action-functions "new-grammar.lisp" "action-functions.data"))

;;;;; End of action writing section ;;;;;
@


1.2.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@@


1.2.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@@


1.2.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@@


1.2.8.1
log
@branched from 1.2
@
text
@@


1.2.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@@


1.2.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@@


1.2.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@@


1.2.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@@


1.2.7.1
log
@branched from 1.2
@
text
@@


1.2.6.1
log
@branched from 1.2
@
text
@@


1.2.6.1.1.1
log
@branched from 1.2.6.1
@
text
@@


1.2.5.1
log
@branched from 1.2
@
text
@@


1.2.4.1
log
@branched from 1.2
@
text
@@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@@


1.2.3.1
log
@branched from 1.2
@
text
@@


1.2.2.1
log
@branched from 1.2
@
text
@@


1.2.1.1
log
@branched from 1.2
@
text
@@


1.1
log
@Initial revision
@
text
@d47 7
d57 1
a57 1
                 (apply 'append (apply 'append grammar))))
@


1.1.1.1
log
@Fork for bug fixing
@
text
@@
