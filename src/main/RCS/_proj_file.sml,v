head	1.27;
access;
symbols
	MLW_daveb_inline_1_4_99:1.27.1
	MLWorks_21c0_1999_03_25:1.27
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.19
	MLWorks_20b2c2_1998_06_19:1.16
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.2
	MLWorks_workspace_97:1.1.1;
locks; strict;
comment	@ *  @;


1.27
date	99.03.18.10.19.43;	author mitchell;	state Exp;
branches
	1.27.1.1;
next	1.26;

1.26
date	99.03.04.12.21.35;	author mitchell;	state Exp;
branches;
next	1.25;

1.25
date	99.02.02.16.00.59;	author mitchell;	state Exp;
branches;
next	1.24;

1.24
date	98.12.15.13.24.50;	author johnh;	state Exp;
branches;
next	1.23;

1.23
date	98.12.08.16.30.38;	author johnh;	state Exp;
branches;
next	1.22;

1.22
date	98.08.14.15.46.15;	author mitchell;	state Exp;
branches;
next	1.21;

1.21
date	98.08.13.14.23.18;	author mitchell;	state Exp;
branches;
next	1.20;

1.20
date	98.08.13.10.46.54;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	98.07.30.11.14.09;	author mitchell;	state Exp;
branches;
next	1.18;

1.18
date	98.07.29.11.17.35;	author johnh;	state Exp;
branches;
next	1.17;

1.17
date	98.06.29.10.50.08;	author johnh;	state Exp;
branches;
next	1.16;

1.16
date	98.06.16.11.44.25;	author mitchell;	state Exp;
branches;
next	1.15;

1.15
date	98.06.12.12.12.15;	author mitchell;	state Exp;
branches;
next	1.14;

1.14
date	98.06.09.13.22.17;	author mitchell;	state Exp;
branches;
next	1.13;

1.13
date	98.06.08.12.20.08;	author mitchell;	state Exp;
branches;
next	1.12;

1.12
date	98.06.01.14.26.22;	author johnh;	state Exp;
branches;
next	1.11;

1.11
date	98.05.01.11.24.56;	author mitchell;	state Exp;
branches;
next	1.10;

1.10
date	98.04.24.16.02.46;	author mitchell;	state Exp;
branches;
next	1.9;

1.9
date	98.04.24.14.38.56;	author jkbrook;	state Exp;
branches;
next	1.8;

1.8
date	98.04.22.10.35.36;	author johnh;	state Exp;
branches;
next	1.7;

1.7
date	98.04.06.17.10.13;	author mitchell;	state Exp;
branches;
next	1.6;

1.6
date	98.03.13.16.18.46;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	98.02.23.15.22.32;	author johnh;	state Exp;
branches;
next	1.4;

1.4
date	98.02.19.20.16.21;	author mitchell;	state Exp;
branches;
next	1.3;

1.3
date	98.02.18.17.05.21;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	98.02.06.16.01.40;	author johnh;	state Exp;
branches;
next	1.1;

1.1
date	97.09.12.10.00.00;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.09.12.10.00.01;	author johnh;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.09.12.14.37.16;	author johnh;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.11.04.14.45.05;	author daveb;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.11.11.09.35.16;	author johnh;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.11.24.16.29.40;	author johnh;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.11.28.16.41.48;	author daveb;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.12.01.14.28.08;	author johnh;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.12.02.16.03.30;	author johnh;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.12.03.10.37.48;	author johnh;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.12.03.17.14.06;	author daveb;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	97.12.23.16.36.11;	author daveb;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	98.01.06.15.46.30;	author johnh;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.01.08.15.17.14;	author johnh;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.01.26.15.19.06;	author johnh;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	98.02.02.16.31.18;	author johnh;	state Exp;
branches;
next	;

1.27.1.1
date	99.04.01.17.58.04;	author daveb;	state Exp;
branches;
next	;


desc
@new file on MLWorks_workspace_97
@


1.27
log
@[Bug #190534]
Ensure projects created by Shell.Project have Debug and Release modes as default
@
text
@(*
 * $Log: _proj_file.sml,v $
 *  Revision 1.26  1999/03/04  12:21:35  mitchell
 *  [Bug #190511]
 *  Fix target ordering
 *
 *  Revision 1.25  1999/02/02  16:00:59  mitchell
 *  [Bug #190500]
 *  Remove redundant require statements
 *
 *  Revision 1.24  1998/12/15  13:24:50  johnh
 *  [Bug #190497]
 *  handle NoConfigDetails exn for removing invalid targets.
 *
 *  Revision 1.23  1998/12/08  16:30:38  johnh
 *  [Bug #190494]
 *  No longer rely on configuration begin changed if current one is removed.
 *  Current configuration should not be removed by setConfigurations.
 *
 *  Revision 1.22  1998/08/14  15:46:15  mitchell
 *  [Bug #30478]
 *  Add missing call to fromUnixPath
 *
 *  Revision 1.21  1998/08/13  14:23:18  mitchell
 *  [Bug #30471]
 *  Avoid writing project paths with spaces in them
 *
 *  Revision 1.20  1998/08/13  10:46:54  jont
 *  [Bug #30468]
 *  Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 *  Revision 1.19  1998/07/30  11:14:09  mitchell
 *  [Bug #30439]
 *  Add .mlp extension when saving a project file with no extension
 *
 *  Revision 1.18  1998/07/29  11:17:35  johnh
 *  [Bug #30453]
 *  Modify setFiles and setTargets to perform consistency checks.
 *
 *  Revision 1.17  1998/06/29  10:50:08  johnh
 *  [Bug #20111]
 *  Fix incorrect case problems.
 *
 *  Revision 1.16  1998/06/16  11:44:25  mitchell
 *  [Bug #30422]
 *  Add setProjectDir
 *
 *  Revision 1.15  1998/06/12  12:12:15  mitchell
 *  [Bug #30418]
 *  Set project name when proj_file is saved
 *
 *  Revision 1.14  1998/06/09  13:22:17  mitchell
 *  [Bug #30405]
 *  Remove current configuration when all configurations zapped
 *
 *  Revision 1.13  1998/06/08  12:20:08  mitchell
 *  [Bug #30418]
 *  Convert to use sectioned files
 *
 *  Revision 1.12  1998/06/01  14:26:22  johnh
 *  [Bug #30361]
 *  Fix save project problem.
 *
 *  Revision 1.11  1998/05/01  11:24:56  mitchell
 *  [Bug #50071]
 *  Extend interface to support close project, and fix parsing of description and version info
 *
 *  Revision 1.10  1998/04/24  16:02:46  mitchell
 *  [Bug #30389]
 *  Keep projects more in step with projfiles
 *
 *  Revision 1.9  1998/04/24  14:38:56  jkbrook
 *  [Bug #30376]
 *  Add objects suffix to default object path (for installations)
 *
 *  Revision 1.8  1998/04/22  10:35:36  johnh
 *  [Bug #50073]
 *  Fix getProjectDir to use get_startup_dir, not OS.FileSys.getDir.
 *
 *  Revision 1.7  1998/04/06  17:10:13  mitchell
 *  [Bug #30386]
 *  Allow spaces to appear in paths
 *
 *  Revision 1.6  1998/03/13  16:18:46  johnh
 *  [Bug #30365]
 *  Implement support for sub-projects.
 *
 *  Revision 1.5  1998/02/23  15:22:32  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
*Revision 1.3  1998/02/18  17:05:21  jont
*[Bug #70070]
*Remove MLWorks.IO.terminal_out in favour of Terminal.output
*
*Revision 1.2  1998/02/06  16:01:40  johnh
*new unit
*[Bug #30071]
*Stores project file information for the new Project Workspace.
*
 *  Revision 1.1.1.15  1998/02/02  16:31:18  johnh
 *  [Bug #30071]
 *  Handle exceptions.
 *
 *  Revision 1.1.1.14  1998/01/26  15:19:06  johnh
 *  [Bug #30071]
 *  Introducing subprojects.
 *
 *  Revision 1.1.1.13  1998/01/08  15:17:14  johnh
 *  [Bug #30071]
 *  Add directory location for different modes.
 *  Remove objects location from configurations.
 *
 *  Revision 1.1.1.12  1998/01/06  15:46:30  johnh
 *  [Bug #30071]
 *  Add about information.
 *
 *  Revision 1.1.1.11  1997/12/23  16:36:11  daveb
 *  [Bug #30071]
 *  Made project file store all paths in Unix path format, for portability.
 *  Added conversions to local path format in the appropriate places.
 *  Added diagnostics.
 *
 *  Revision 1.1.1.10  1997/12/03  17:14:06  daveb
 *  [Bug #30071]
 *  Ensured that stored projectNames are always absolute path names.
 *
 *  Revision 1.1.1.9  1997/12/03  10:37:48  johnh
 *  [Bug #30071]
 *  Fix problem with saving and loading empty locations.
 *
 *  Revision 1.1.1.8  1997/12/02  16:03:30  johnh
 *  [Bug #30071]
 *  Fixing return value of getProjectDir when projectName is SOME "".
 *
 *  Revision 1.1.1.7  1997/12/01  14:28:08  johnh
 *  [Bug #30071]
 *  Use ProfFile.getProjectName returning SOME "" to mean new project created.
 *
 *  Revision 1.1.1.6  1997/11/28  16:41:48  daveb
 *  [Bug #30071]
 *  Made getProjectName return an option type; removed setProjectName;
 *  removed old comments.
 *  Added getProjectDir.
 *
 *  Revision 1.1.1.5  1997/11/24  16:29:40  johnh
 *  [Bug #30071]
 *  Improve save/load mechanism.
 *
 *  Revision 1.1.1.4  1997/11/11  09:35:16  johnh
 *  [Bug #30071]
 *  Handling exceptions.
 *
 *  Revision 1.1.1.3  1997/11/04  14:45:05  daveb
 *  [Bug #30071]
 *  Added support for current configurations, modes and targets.
 *
 *  Revision 1.1.1.2  1997/09/12  14:37:16  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
 *
 * 
 * Copyright (C) 1997.  The Harlequin Group Limited.  All rights reserved.
 *
 *)

require "../basis/__list";
require "../basis/__string";
require "../basis/__substring";
require "../basis/__char";

require "^.basis.os";
require "^.basis.text_io";
require "^.utils.terminal";
require "^.utils.getenv";

require "^.main.info";
require "^.utils.diagnostic";
require "^.utils.lists";

require "sectioned_file";
require "proj_file";

functor ProjFile (
  structure OS: OS
  structure SectionedFile: SECTIONED_FILE
  structure TextIO: TEXT_IO
  structure Terminal: TERMINAL
  structure Getenv: GETENV

  structure Info: INFO
  structure Lists: LISTS
  structure Diagnostic: DIAGNOSTIC
): PROJ_FILE = 
struct
  type error_info = Info.options
  type location = Info.Location.T

  val _ = Diagnostic.set 0

(* Do not use this function until the TextIO bug has been fixed as this 
 * causes MLW to hang. *)
  fun diagnostic (level, output_function) =
    Diagnostic.output
      level
      (fn verbosity => output_function verbosity)

(* Uncomment this function to use diagnostics instead of setting diagnostic
 * level - see comment above about TextIO problem. *)
(*
  fun diagnostic (level, output_fn) = 
    let 
      val p_list = output_fn ()
      fun P s = Terminal.output(s ^ "\t")
    in
      app P p_list;
      Terminal.output"\n"
    end
*)

  val STAMP = "MLWorks 2.0"  (* The filestamp added to project files *)

  exception InvalidProjectFile of string

  fun get_sectioned_file fname =
      let val (STAMP', sf) = 
            SectionedFile.readSectionedFile fname
              handle SectionedFile.InvalidSectionedFile s =>
                       raise (InvalidProjectFile s)
       in if STAMP' = STAMP 
          then sf 
          else raise (InvalidProjectFile ("Invalid file header in " ^ fname))
      end

  val fromUnixPath = OS.Path.fromUnixPath;
  val toUnixPath = OS.Path.toUnixPath;

  datatype target_type = IMAGE | OBJECT_FILE | EXECUTABLE | LIBRARY

  (* (name, type) *)
  type target_details = (string * target_type)

  type target_refs =
    {curTargets:    string list ref,
     disTargets:    string list ref,
     targetDetails: target_details list ref}

  type mode_details =  
    {name:                                      string,
     location:                                  string ref,
     generate_interruptable_code:               bool ref,
     generate_interceptable_code:               bool ref,
     generate_debug_info:                       bool ref,
     generate_variable_debug_info:              bool ref,
     optimize_leaf_fns:                         bool ref,
     optimize_tail_calls:                       bool ref,
     optimize_self_tail_calls:                  bool ref,
     mips_r4000:                                bool ref,
     sparc_v7:                                  bool ref}

  type mode_refs =
    {modes:       string list ref,
     modeDetails: mode_details list ref,
     currentMode: string option ref}

  type config_details =
    {name: string, 
     files: string list, 
     library: string list}

  type configuration_refs =
    {configs:           string list ref,
     configDetails:     config_details list ref,
     currentConfig:     string option ref}

  type locations =
    {libraryPath:       string list ref,
     objectsLoc:        string ref,
     binariesLoc:       string ref}

  type about_refs = 
    {description:       string ref,
     version:           string ref}

  datatype project_file = PROJECT_FILE of 
    {projectName:       string option ref,
     projectDir:        string ref,
     files:             string list ref,
     subprojects:       string list ref,
     targets:           target_refs,
     modes:             mode_refs,
     configs:           configuration_refs,
     locations:         locations,
     about:             about_refs}

  fun warn_error s = Terminal.output(s ^ "\n")

  fun mk_empty_proj () = 
    PROJECT_FILE {projectName = ref NONE, 
                  projectDir = ref "",
                  files = ref [],
                  subprojects = ref [],
                  about =
                        {description = ref "",
                         version = ref ""},
                  targets = 
                        {curTargets = ref [],
                         disTargets = ref [],
                         targetDetails = ref []},
                  modes = 
                        {modes = ref [],
                         modeDetails = ref [],
                         currentMode = ref NONE},
                  configs = 
                        {configs = ref [],
                         configDetails = ref [],
                         currentConfig = ref NONE},
                  locations = 
                        {libraryPath = ref [],
                         objectsLoc = ref "",
                         binariesLoc = ref ""}}


  val proj_file_changed = ref false;

  fun changed() = !proj_file_changed before (proj_file_changed := false);

  fun initialize project_file = 
    let
      val PROJECT_FILE {projectName, projectDir, files, subprojects, targets, 
                        modes, configs, locations, about} = project_file
      val {curTargets, disTargets, targetDetails} = targets
      val {modes, modeDetails, currentMode} = modes
      val {configs, configDetails, currentConfig} = configs
      val {libraryPath, objectsLoc, binariesLoc} = locations
      val {description, version} = about
    in
      diagnostic (1, fn _ => ["Initializing project file info"]);
      (* SOME "" is used here to indicate a new project has been created *)
      projectName := SOME "";  
      projectDir := OS.FileSys.getDir();
      description := "";
      version := "";
      files := [];
      subprojects := [];
      curTargets := [];
      disTargets := [];
      targetDetails := [];
      modes := [];
      modeDetails := [];
      currentMode := NONE; 
      configs := [];
      configDetails := [];
      currentConfig := NONE;
      libraryPath := [];
      objectsLoc := "objects";
      binariesLoc := ""
    end
 
  
  (* Getters and Setters *)

  fun getProjectName project_file =
    let 
      val PROJECT_FILE {projectName, ...} = project_file
    in
      !projectName
    end

  fun getProjectDir project_file =
    let 
      val PROJECT_FILE {projectName, projectDir, ...} = project_file
    in
      case !projectName of 
        NONE => 
          (diagnostic (2, fn _ => ["Project Name is not set"]);
           OS.FileSys.getDir())
      | SOME _ => !projectDir
    end

  fun getAboutInfo project_file = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      (!description, !version)
    end

  fun setAboutInfo project_file (descStr, verStr) = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      proj_file_changed := true;
      description := descStr;
      version := verStr
    end


  fun getLocations project_file = 
    let 
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
    in
      (!libraryPath, !objectsLoc, !binariesLoc)
    end

  fun setLocations project_file (libPath, obj, bin) = 
    let 
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
    in
      proj_file_changed := true;
      libraryPath := libPath;
      objectsLoc := obj;
      binariesLoc := bin
    end


  fun getSubprojects project_file = 
    let 
      val PROJECT_FILE {subprojects, ...} = project_file
    in
      (!subprojects)
    end

  fun setSubprojects project_file proj_list = 
    let 
      val PROJECT_FILE {subprojects, ...} = project_file
    in
      proj_file_changed := true;
      subprojects := proj_list
    end

  exception NoConfigDetailsFound of string
  fun getConfigDetails (configName, detailsList: config_details list) = 
    let 
      val details = 
        List.find (fn {name=n, ...} => n = configName) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoConfigDetailsFound configName
    end

  (* TARGETS *)
  exception NoTargetDetailsFound of string

  fun getTargets project_file = 
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
    in
      (!curTargets, !disTargets, !targetDetails)
    end

  fun getTargetDetails (name, detailsList) = 
    let 
      val details = List.find (fn (n,t) => n = name) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoTargetDetailsFound name
    end


  (* TODO: check that the arguments to setTargets are consistent *)

  (* Target does not exist in the total list of files including those
   * belonging to the current configuration. *)
  exception InvalidTarget of string

  fun setTargets project_file (current, disabled, details) = 
    let 
      val PROJECT_FILE {targets, files, configs, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
      val {configs, configDetails, currentConfig} = configs
      val {name, files = c_files, library} = 
	case (!currentConfig) of 
	  NONE => {name = "", files = [], library = []}
	| SOME cc => getConfigDetails (cc, !configDetails)
	    handle NoConfigDetailsFound c => {name="", files=[], library=[]}
      val total_files = (!files) @@ c_files
      fun check_targets [] = ()
	| check_targets (t::rest) = 
	    if List.exists (fn f => (OS.Path.file f) = t) total_files then
	      check_targets rest
	    else
	      raise InvalidTarget t
    in
      check_targets current;
      check_targets disabled;
      proj_file_changed := true;
      curTargets := current;
      disTargets := disabled;
      targetDetails := details
    end

  fun setCurrentTargets project_file (error_info, location) targetList =
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, ...} = targets

      (* Begin by assuming that all targets are disabled *)
      val _ = disTargets := !curTargets @@ !disTargets
      val _ = curTargets := []

      (* Then move specified targets from the disabled list to
         the current list, one at a time. *)
      fun setOne target =
        case (List.find (fn s => s=target) (!disTargets))
        of SOME _ =>
          (curTargets := target :: !curTargets;
           disTargets := List.filter (fn s => s<>target) (!disTargets))
          | NONE =>
            Info.error'
              error_info
              (Info.FATAL, location, "No such target as " ^ target)
    in
      proj_file_changed := true;
      app setOne (rev targetList)
    end


  fun remove_invalid_targets project_file = 
    let
      val PROJECT_FILE {files, targets, configs, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
      val {configs, configDetails, currentConfig} = configs
      val c_files = 
	case (!currentConfig) of 
	  NONE => []
	| SOME cc => #files (getConfigDetails (cc, !configDetails))
	    handle NoConfigDetailsFound c => []
      val target_files = map OS.Path.file ((!files) @@ c_files)

      fun remove_t_details (target, details) = 
	#2 (List.partition (fn (a,_) => a=target) details)

      fun remove_targets ([], details) = ([], details)
	| remove_targets (target::rest, details) = 
	    let val (targ_test, ts) = List.partition (fn f => f=target) target_files
	    in
	      if null targ_test then 
		remove_targets (rest, remove_t_details (target, details))
	      else
		let val (ts,ds) = remove_targets (rest, details)
		in (target::ts, ds)
		end
	    end

      val (new_cur, cur_details) = remove_targets (!curTargets, !targetDetails)
      val (new_dis, final_details) = remove_targets (!disTargets, cur_details)
    in
      setTargets project_file (new_cur, new_dis, final_details)
    end


  (* CONFIGURATIONS *)

  fun getConfigurations project_file = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails, currentConfig} = configs
    in
      (!configs, !configDetails, !currentConfig)
    end

  (* Configuration details are modified by replacing an entry in the
     configDetails list *)
  fun modifyConfigDetails
        ({name = testName, files = f, library = l},
        (detailsList: config_details list)) =
    let 
      val {name=configName, ...} = 
        case (List.find (fn {name=n, ...} => n=testName) detailsList) of
           SOME result => result
         | NONE => raise NoConfigDetailsFound testName
      val others = List.filter (fn {name=n, ...} => n <> testName) detailsList;
    in 
      {name = configName, 
       files = f,
       library = l} :: others
    end

  (* The comment about setModes applies here as well *)

  fun setConfigurations project_file (configList, details) = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails, currentConfig} = configs
    in
      proj_file_changed := true;
      configs := configList;
      configDetails := details;
      remove_invalid_targets project_file
    end

  fun setCurrentConfiguration 
        project_file (error_info, location) optional_config =
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, currentConfig, ...} = configs
    in
      proj_file_changed := true;
      case optional_config of
        SOME config =>      
         (case (List.find (fn {name, ...} => name=config) (!configDetails)) of 
	    SOME _ => currentConfig := SOME config
          | NONE =>
            Info.error'
              error_info
              (Info.FATAL, location, "No such configuration as " ^ config))
      | NONE => currentConfig := NONE;
      remove_invalid_targets project_file
    end


  (* MODES *)
  exception NoModeDetailsFound of string

  fun getModes project_file = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, currentMode} = modes
    in
      (!modes, !modeDetails, !currentMode)
    end

  fun getModeDetails (modeName, detailsList: mode_details list) = 
    let 
      val details = 
        List.find (fn {name=n, ...} => n = modeName) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoModeDetailsFound modeName
    end

  (* We should change how we do this.  What's the point in specifying both
     modeList and details, when the modeList can be constucted from the
     details.  Specifying both means that they can be inconsistent.  If we
     are going to specify both then we should check for consistency.  But
     setModes doesn't take error_info and location arguments, so we can't 
     call Info.error' here.  We also need a consistent story regarding errors.
     For example, setting the current mode to a mode that we don't know about
     calls Info.error', whereas getting the mode details for a mode we don't
     know about raises an exception *)

  fun setModes project_file (modeList, details) = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, ...} = modes
    in
      proj_file_changed := true;
      modes := modeList;
      modeDetails := details
    end

  fun setInitialModes project_file = 
    let 
      val debugMode =
        {name = "Debug",
         location = ref "Debug",
         generate_interruptable_code = ref true,
         generate_interceptable_code = ref true,
         generate_debug_info = ref true,
         generate_variable_debug_info = ref true,
         optimize_leaf_fns = ref false,
         optimize_tail_calls = ref false,
         optimize_self_tail_calls = ref false,
         mips_r4000 = ref true,
         sparc_v7 = ref false}

      val releaseMode =
        {name = "Release",
         location = ref "Release",
         generate_interruptable_code = ref true,
         generate_interceptable_code = ref false,
         generate_debug_info = ref false,
         generate_variable_debug_info = ref false,
         optimize_leaf_fns = ref true,
         optimize_tail_calls = ref true,
         optimize_self_tail_calls = ref true,
         mips_r4000 = ref true,
         sparc_v7 = ref false}

      val (modeList, details) = 
            (["Debug", "Release"],
              [debugMode, releaseMode]);

      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, ...} = modes
    in
      proj_file_changed := true;
      modes := modeList;
      modeDetails := details
    end

  fun setCurrentMode project_file (error_info, location) mode =
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, currentMode, ...} = modes
    in
      proj_file_changed := true;
      case (List.find (fn {name, ...} => name=mode) (!modeDetails))
      of SOME _ =>
        currentMode := SOME mode
      | NONE =>
        Info.error'
          error_info
          (Info.FATAL, location, "No such mode as " ^ mode)
    end


  (* FILES *)
  fun getFiles project_file = 
    let 
      val PROJECT_FILE {files, ...} = project_file
    in
      (!files)
    end


  fun setFiles project_file new_files = 
    let
      val PROJECT_FILE {files, ...} = project_file
    in
      proj_file_changed := true;
      files := new_files;
      remove_invalid_targets project_file
    end



  (* Next we have the functions for reading and writing project files 
     For now we read in a sectioned file and convert it to a proj_file.  It
     might be simpler eventually to just manipulate a sectioned file
     directly, as it's more functional, and just cache anything that's 
     accessed very frequently in the project datastructure. *)

  fun getFullFilename (filename, dirName) = 
    let 
      val local_name = fromUnixPath filename
      val abs_name = OS.Path.mkAbsolute {path=local_name, relativeTo=dirName}
    in
      abs_name
    end

  fun split2 s = (* Split a string into two substrings at the first space *)
        let val (ss1,ss2) = 
                Substring.splitl (not o Char.isSpace) (Substring.all s)
            val (_, ss2) = Substring.splitl Char.isSpace ss2
         in (Substring.string ss1, Substring.string ss2) end

  fun item_to_target_item str =
        case split2 str of
          (name, "EXECUTABLE") => (name, EXECUTABLE)
        | (name, "LIBRARY")    => (name, LIBRARY)
        | (name, "IMAGE")      => (name, IMAGE)
        | (name, "OBJECT_FILE")=> (name, OBJECT_FILE)
        | (name, _) => (name, EXECUTABLE);

  fun target_item_to_item (name, EXECUTABLE)  = name ^ " " ^ "EXECUTABLE"
    | target_item_to_item (name, LIBRARY)     = name ^ " " ^ "LIBRARY"
    | target_item_to_item (name, IMAGE)       = name ^ " " ^ "IMAGE"
    | target_item_to_item (name, OBJECT_FILE) = name ^ " " ^ "OBJECT_FILE"

  fun newModeDetails name = 
      {name = name,
       location = ref name,
       generate_interruptable_code = ref false,
       generate_interceptable_code = ref false,
       generate_debug_info = ref false,
       generate_variable_debug_info = ref false,
       optimize_leaf_fns = ref false,
       optimize_tail_calls = ref false,
       optimize_self_tail_calls = ref false,
       mips_r4000 = ref false,
       sparc_v7 = ref false}

  fun mode_flags_to_refs (r: mode_details) =
      [("generate_interruptable_code", #generate_interruptable_code r), 
       ("generate_interceptable_code", #generate_interceptable_code r),
       ("generate_debug_info",         #generate_debug_info r),
       ("generate_variable_debug_info",#generate_variable_debug_info r),
       ("optimize_leaf_fns",           #optimize_leaf_fns r),
       ("optimize_tail_calls",         #optimize_tail_calls r), 
       ("optimize_self_tail_calls",    #optimize_self_tail_calls r),
       ("mips_r4000",                  #mips_r4000 r), 
       ("sparc_v7",                    #sparc_v7 r)]

  fun item_to_set_mode_flag mode_flag_refs str =
        let val (s, b) = split2 str 
         in case List.find (fn (s', r) => s = s') mode_flag_refs of
              SOME (_, r) => r := (b = "true")
            | NONE => () end;
      
  fun mode_flags_to_items mode_flag_refs =
        List.mapPartial (fn (s, r) => if !r then SOME (s ^ " true") else NONE)
                        mode_flag_refs



  fun getAllSubProjects filename = 
      let 
        fun subprojects (fname, seen) =
            let fun real_file_name proj = 
                      if OS.Path.isRelative proj then 
                        OS.Path.mkCanonical 
                          (OS.Path.mkAbsolute {path=proj, relativeTo=OS.Path.dir fname})
                      else
                        OS.Path.mkCanonical proj
            in 
              if List.exists (fn n => fname = n) seen then seen 
              else 
                let val sf = get_sectioned_file fname
                    val subs = 
                          SectionedFile.getItems(
                            SectionedFile.getDescendent(sf,["Subprojects"]))
                          handle SectionedFile.InvalidPath => []
                    val filenames = map (real_file_name o fromUnixPath) subs
                 in fname :: (foldl subprojects seen filenames)
                end
            end
      in rev (subprojects (OS.Path.mkCanonical filename, [])) end


  (* getSubTargets assumes given filename is canonical absolute *)
  fun getSubTargets1 filename = 
        let val sf = get_sectioned_file filename
         in SectionedFile.getItems(
              SectionedFile.getDescendent(sf,["Targets"]))
        end handle SectionedFile.InvalidPath => []

  fun getSubTargets filename = 
        let val sf = get_sectioned_file filename
            val enabled_targets = 
                  SectionedFile.getItems(
                    SectionedFile.getDescendent(sf,["Targets", "Enabled"]))
         in map (#1 o item_to_target_item) enabled_targets
        end handle SectionedFile.InvalidPath => getSubTargets1 filename

  fun maybe_add_extension extension filename =
        let val {base, ext} = OS.Path.splitBaseExt filename
         in case ext of
              SOME _ => filename (* Don't add ext if we already have one *)
            | NONE => OS.Path.joinBaseExt { base = base, ext = SOME extension }
        end

  fun save_proj projfile filename =
      let 
        val filename = maybe_add_extension "mlp" filename
        val PROJECT_FILE 
              {projectName, projectDir, files, subprojects, 
               targets     as {curTargets, disTargets, targetDetails}, 
               modes = m   as {modes, currentMode, modeDetails}, 
               configs = c as {configs, currentConfig, configDetails}, 
               locations   as {libraryPath, objectsLoc, binariesLoc}, 
               about       as {description, version}} = projfile
        val abs_name = getFullFilename (filename, getProjectDir projfile);
        val _ = projectName := SOME abs_name;
        val _ = projectDir := OS.Path.dir abs_name;

        val create = SectionedFile.createSection

        val about_info_section = 
            create("AboutInfo",
                   [create("Version", [], 
                           if !version = "" then [] else [!version]),
                    create("Description", [], 
                           if !description = "" then [] else [!description])],
                   [])

        val target_section =
            create("Targets", 
             [create("Details",
                     [], map target_item_to_item (!targetDetails))],
             !curTargets)

        val mode_section = 
            let
              fun section_mode name = 
                let 
                  val mode = getModeDetails(name, !modeDetails)
                  handle NoModeDetailsFound m => 
                    (warn_error ("Warning: Error in saving mode " ^ m);
                     newModeDetails m)
                in
                  create(name, 
                    [create("Location", [], [!(#location mode)]),
                     create("Flags", [],
                       mode_flags_to_items (mode_flags_to_refs mode))], [])
                end
            in
              create("Modes", map section_mode (!modes), 
                     case !currentMode of SOME name => [name] | NONE => [])
            end

        val config_section =
            let 
              fun section_config name = 
                let 
                  val configRec = getConfigDetails (name, !configDetails)
                    handle NoConfigDetailsFound c => 
                      (warn_error 
                         ("Warning: Error in saving configuration " ^ c);
                       {name=name, library=[], files=[]})
                in
                  create(name,
                    [create("Library",[],map toUnixPath (#library configRec))],
                    map toUnixPath (#files configRec))
                end
            in
              create("Configurations", map section_config (!configs), 
                     case !currentConfig of SOME name => [name] | NONE => [])
            end

        val locations_section =
            create("Locations",
             [create("LibraryPath", [], map toUnixPath (!libraryPath)),
              create("Objects",  [], [toUnixPath (!objectsLoc)]),
              create("Binaries", [], [toUnixPath (!binariesLoc)])],
             [])

        val sectioned_file =
            create(String.toString(OS.Path.file abs_name),
              [ about_info_section,
                create("Files",       [], map toUnixPath (!files)),
                create("Subprojects", [], map toUnixPath (!subprojects)),
                target_section, mode_section, config_section,
                locations_section ],
              [])
      in
        SectionedFile.writeSectionedFile (abs_name, STAMP, sectioned_file)
      end


  fun load_from_file(project_file, abs_name) =
      let 
        open SectionedFile
        val PROJECT_FILE 
              {projectName, projectDir, files, subprojects, 
               targets     as {curTargets, disTargets, targetDetails}, 
               modes = m   as {modes, currentMode, modeDetails}, 
               configs = c as {configs, currentConfig, configDetails}, 
               locations   as {libraryPath, objectsLoc, binariesLoc}, 
               about       as {description, version}} = project_file
        val sf = get_sectioned_file abs_name
        fun get_items sf path =
              getItems(getDescendent(sf, path)) handle InvalidPath => []
        val get_sf_items = get_items sf
        fun hd_item (h::_) = h | hd_item _ = ""
      in
        projectDir := OS.Path.dir abs_name;
        version := hd_item(get_sf_items ["AboutInfo", "Version"]);
        description := hd_item(get_sf_items ["AboutInfo", "Description"]);
        files := map fromUnixPath (get_sf_items ["Files"]);
        subprojects := map fromUnixPath (get_sf_items ["Subprojects"]);

        let val details = 
                map item_to_target_item (get_sf_items ["Targets", "Details"])
            val target_names = map #1 details
            val current_targets = get_sf_items ["Targets"]
            fun is_current t = List.exists (fn t' => t = t') current_targets
         in targetDetails := details;
            curTargets := current_targets;
            disTargets := List.filter (not o is_current) target_names
        end;

        let val mode_sec = getDescendent(sf, ["Modes"])
            val mode_names = map getName (getSubsections mode_sec)
               
            fun get_details sec =
              let val md = newModeDetails (getName sec)
               in ( #location md := (hd_item(get_items sec ["Location"]));
                    app (item_to_set_mode_flag (mode_flags_to_refs md)) 
                        (get_items sec ["Flags"]);
                    md) end

          in modes := mode_names;
             modeDetails := map get_details (getSubsections mode_sec);
             case getItems mode_sec of
               [current_mode] => currentMode := SOME current_mode
             | _ => currentMode := NONE
        end;

        let val config_sec = getDescendent(sf, ["Configurations"])
            val config_names = map getName (getSubsections config_sec)
            fun get_details sec =
              {name = getName sec, 
               files = map fromUnixPath (getItems sec),
               library = map fromUnixPath (get_items sec ["Library"])}
         in configs := config_names;
            configDetails := map get_details (getSubsections config_sec);
            case getItems config_sec of
              [current_config] => currentConfig := SOME current_config
            | _ => currentConfig := NONE
        end;

        libraryPath := 
          map fromUnixPath (get_sf_items ["Locations", "LibraryPath"]);
        objectsLoc := 
          fromUnixPath (hd_item(get_sf_items ["Locations", "Objects"]));
        binariesLoc := 
          fromUnixPath (hd_item(get_sf_items ["Locations", "Binaries"]))
      end

  fun new_proj (project_file as PROJECT_FILE fields) working_dir =
    ( initialize project_file;
      #projectDir fields := OS.Path.mkAbsolute{path=working_dir, 
                                               relativeTo=OS.FileSys.getDir()} )

  fun open_proj project_file filename =
      let val PROJECT_FILE {projectName, ...} = project_file
          val abs_name = getFullFilename (filename, OS.FileSys.getDir())
      in
        proj_file_changed := true;
        initialize project_file; 
        projectName := SOME abs_name;
        diagnostic (2, fn _ => ["Project opened from ", filename]);
        load_from_file (project_file, abs_name)
      end

  fun peek_project project_file filename = 
      let 
        val new_proj = mk_empty_proj()
        val PROJECT_FILE 
              {projectName, projectDir, files, subprojects, 
               targets     as {curTargets, disTargets, targetDetails}, 
               modes = m   as {modes, currentMode, modeDetails}, 
               configs = c as {configs, currentConfig, configDetails}, 
               locations   as {libraryPath, objectsLoc, binariesLoc}, 
               about       as {description, version}} = new_proj
        val abs_name = getFullFilename (filename, getProjectDir project_file)
      in
        diagnostic (2, fn _ => ["Project opened from ", abs_name]);
        projectName := SOME abs_name;
        load_from_file (new_proj, abs_name);
        {name = abs_name,
         files = !files,
         curTargets = !curTargets,
         disTargets = !disTargets,
         subprojects = !subprojects,
         libraryPath = !libraryPath,
         objectsLoc = !objectsLoc,
         binariesLoc = !binariesLoc,
         currentConfig = !currentConfig, 
         configDetails = !configDetails,
         currentMode = !currentMode,
         modeDetails = !modeDetails}
      end


  fun close_proj project_file =
      let 
        val PROJECT_FILE {projectName, ...} = project_file
      in
        proj_file_changed := true;
        initialize project_file;
        projectName := NONE
      end


  (* For now we treat most of the functions as operating on a single hidden
     project file, so we partially apply the relevant functions to this project
     file.  Eventually we would like to avoid doing this, which would mesh
     better with the project datastructure, which is treated functionally,
     and would also avoid the need for things like peek_project *)

  val project_file = mk_empty_proj() (* This is the global hidden proj_file *)

  val new_proj                = new_proj project_file
  val open_proj               = open_proj project_file
  val peek_project            = peek_project project_file
  val save_proj               = save_proj project_file
  val close_proj              = fn () => close_proj project_file
  val getAboutInfo            = fn () => getAboutInfo project_file
  val setAboutInfo            = setAboutInfo project_file
  val getProjectName          = fn () => getProjectName project_file
  val getProjectDir           = fn () => getProjectDir project_file
  val getFiles                = fn () => getFiles project_file
  val setFiles                = setFiles project_file
  val getSubprojects          = fn () => getSubprojects project_file
  val setSubprojects          = setSubprojects project_file
  val getTargets              = fn () => getTargets project_file
  val setTargets              = setTargets project_file
  val setCurrentTargets       = setCurrentTargets project_file
  val getModes                = fn () => getModes project_file 
  val setModes                = setModes project_file
  val setInitialModes         = fn () => setInitialModes project_file
  val setCurrentMode          = setCurrentMode project_file;
  val getConfigurations       = fn () => getConfigurations project_file
  val setConfigurations       = setConfigurations project_file
  val setCurrentConfiguration = setCurrentConfiguration project_file
  val getLocations            = fn () => getLocations project_file
  val setLocations            = setLocations project_file
end





@


1.27.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 *  Revision 1.27  1999/03/18  10:19:43  mitchell
 *  [Bug #190534]
 *  Ensure projects created by Shell.Project have Debug and Release modes as default
 *
@


1.26
log
@[Bug #190511]
Fix target ordering
@
text
@d3 4
d661 40
d1092 1
@


1.25
log
@[Bug #190500]
Remove redundant require statements
@
text
@d3 4
d518 1
a518 1
      app setOne targetList
@


1.24
log
@[Bug #190497]
handle NoConfigDetails exn for removing invalid targets.
@
text
@d3 4
a159 1
require "../basis/__int";
@


1.23
log
@[Bug #190494]
No longer rely on configuration begin changed if current one is removed.
Current configuration should not be removed by setConfigurations.
@
text
@d3 5
d472 1
d524 1
@


1.22
log
@[Bug #30478]
Add missing call to fromUnixPath
@
text
@d3 4
a576 8
      case (configList, !currentConfig) of
        ([], _) => currentConfig := NONE
      | (h::_, NONE) => currentConfig := SOME h
      | (l as h::_, SOME name) => 
          ( case (List.find (fn name' => name=name') l) of
              SOME _ => ()
            | NONE => (* Better set currentConfig to something that exists *)
                currentConfig := SOME h );
d591 2
a592 3
         (case (List.find (fn {name, ...} => name=config) (!configDetails))
          of SOME _ =>
            currentConfig := SOME config
d597 1
a597 1
        | NONE => currentConfig := NONE;
@


1.21
log
@[Bug #30471]
Avoid writing project paths with spaces in them
@
text
@d3 4
d770 1
a770 1
                    val filenames = map real_file_name subs
@


1.20
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d3 4
d871 1
a871 1
            create(abs_name,
@


1.19
log
@[Bug #30439]
Add .mlp extension when saving a project file with no extension
@
text
@d3 4
d685 1
a685 1
      val abs_name = OS.Path.mkAbsolute (local_name, dirName)
d751 1
a751 1
                          (OS.Path.mkAbsolute (proj, OS.Path.dir fname))
d951 2
a952 2
      #projectDir fields := OS.Path.mkAbsolute(working_dir, 
                                               OS.FileSys.getDir()) )
@


1.18
log
@[Bug #30453]
Modify setFiles and setTargets to perform consistency checks.
@
text
@d3 4
d780 6
d789 1
@


1.17
log
@[Bug #20111]
Fix incorrect case problems.
@
text
@d3 4
a384 16
  fun getFiles project_file = 
    let 
      val PROJECT_FILE {files, ...} = project_file
    in
      (!files)
    end

  fun setFiles project_file new_files = 
    let
      val PROJECT_FILE {files, ...} = project_file
    in
      proj_file_changed := true;
      files := new_files
    end


d400 10
d434 4
d440 1
a440 1
      val PROJECT_FILE {targets, ...} = project_file
d442 12
d455 2
d489 25
a513 10
  (* MODES *)
  exception NoModeDetailsFound of string

  fun getModes project_file = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, currentMode} = modes
    in
      (!modes, !modeDetails, !currentMode)
    end
d515 2
a516 24
  fun getModeDetails (modeName, detailsList: mode_details list) = 
    let 
      val details = 
        List.find (fn {name=n, ...} => n = modeName) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoModeDetailsFound modeName
    end

  (* We should change how we do this.  What's the point in specifying both
     modeList and details, when the modeList can be constucted from the
     details.  Specifying both means that they can be inconsistent.  If we
     are going to specify both then we should check for consistency.  But
     setModes doesn't take error_info and location arguments, so we can't 
     call Info.error' here.  We also need a consistent story regarding errors.
     For example, setting the current mode to a mode that we don't know about
     calls Info.error', whereas getting the mode details for a mode we don't
     know about raises an exception *)

  fun setModes project_file (modeList, details) = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, ...} = modes
d518 1
a518 18
      proj_file_changed := true;
      modes := modeList;
      modeDetails := details
    end

  fun setCurrentMode project_file (error_info, location) mode =
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, currentMode, ...} = modes
    in
      proj_file_changed := true;
      case (List.find (fn {name, ...} => name=mode) (!modeDetails))
      of SOME _ =>
        currentMode := SOME mode
      | NONE =>
        Info.error'
          error_info
          (Info.FATAL, location, "No such mode as " ^ mode)
a522 1
  exception NoConfigDetailsFound of string
a531 10
  fun getConfigDetails (configName, detailsList: config_details list) = 
    let 
      val details = 
        List.find (fn {name=n, ...} => n = configName) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoConfigDetailsFound configName
    end

d566 2
a567 1
      configDetails := details
d586 78
a663 1
        | NONE => currentConfig := NONE
@


1.16
log
@[Bug #30422]
Add setProjectDir
@
text
@d3 4
d620 1
a620 1
      OS.Path.mkCanonical abs_name
@


1.15
log
@[Bug #30418]
Set project name when proj_file is saved
@
text
@d3 4
d244 1
d257 1
d287 1
a287 1
      val PROJECT_FILE {projectName, files, subprojects, targets, 
d298 1
d327 1
a327 2
  val baseDirRef = ref NONE
  fun get_base_dir () =
d329 1
a329 1
      val base_dir = !baseDirRef
d331 5
a335 8
      case base_dir of 
        SOME dir => dir
      | NONE => 
        let
          val dir = getOpt(Getenv.get_startup_dir(), OS.FileSys.getDir())
        in
          (baseDirRef := SOME dir; dir)
        end
a337 13
  fun getProjectDir project_file =
    case getProjectName project_file 
    of SOME ""   => 
      (diagnostic (2, fn _ => ["Project Name is empty"]);
       get_base_dir())
     | SOME file => 
      (diagnostic (2, fn _ => ["Project Name is ", file]);
       OS.Path.dir file)
     | NONE      => 
      (diagnostic (2, fn _ => ["Project Name is not set"]);
       OS.FileSys.getDir())


d717 1
a717 1
              {projectName, files, subprojects, 
d725 1
d805 1
a805 1
              {projectName, files, subprojects, 
d817 1
d871 4
d878 1
a878 1
          val abs_name = getFullFilename (filename, getProjectDir project_file)
a886 1

d891 1
a891 1
              {projectName, files, subprojects, 
d935 1
a935 1
  val initialize              = fn () => initialize project_file
@


1.14
log
@[Bug #30405]
Remove current configuration when all configurations zapped
@
text
@d3 4
d733 2
d798 1
a798 1
            create(getFullFilename (filename, getProjectDir projfile),
d806 1
a806 1
        SectionedFile.writeSectionedFile (filename, STAMP, sectioned_file)
d808 1
a808 1
            
@


1.13
log
@[Bug #30418]
Convert to use sectioned files
@
text
@d3 4
d578 8
@


1.12
log
@[Bug #30361]
Fix save project problem.
@
text
@d3 4
d114 1
d126 1
d131 1
a145 1

d166 17
d194 11
a204 11
    {name:					string,
     location:					string ref,
     generate_interruptable_code:		bool ref,
     generate_interceptable_code:		bool ref,
     generate_debug_info:			bool ref,
     generate_variable_debug_info:		bool ref,
     optimize_leaf_fns:				bool ref,
     optimize_tail_calls:			bool ref,
     optimize_self_tail_calls:			bool ref,
     mips_r4000:				bool ref,
     sparc_v7:					bool ref}
d207 1
a207 1
    {modes:	  string list ref,
d217 3
a219 3
    {configs:		string list ref,
     configDetails:	config_details list ref,
     currentConfig:	string option ref}
d222 3
a224 3
    {libraryPath:	string list ref,
     objectsLoc:	string ref,
     binariesLoc:	string ref}
d227 2
a228 2
    {description:	string ref,
     version:		string ref}
d231 8
a238 8
    {projectName:	string option ref,
     files:		string list ref,
     subprojects:	string list ref,
     targets:		target_refs,
     modes:		mode_refs,
     configs:		configuration_refs,
     locations:		locations,
     about:		about_refs}
d244 21
a264 21
		  files = ref [],
		  subprojects = ref [],
		  about =
			{description = ref "",
			 version = ref ""},
		  targets = 
			{curTargets = ref [],
			 disTargets = ref [],
			 targetDetails = ref []},
		  modes = 
			{modes = ref [],
			 modeDetails = ref [],
			 currentMode = ref NONE},
		  configs = 
			{configs = ref [],
			 configDetails = ref [],
			 currentConfig = ref NONE},
		  locations = 
			{libraryPath = ref [],
			 objectsLoc = ref "",
			 binariesLoc = ref ""}}
a265 1
  val project_file = mk_empty_proj ()
d271 1
a271 160
  fun setCurrentTargets (error_info, location) targetList =
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, ...} = targets

      (* Begin by assuming that all targets are disabled *)
      val _ = disTargets := !curTargets @@ !disTargets
      val _ = curTargets := []

      (* Then move specified targets from the disabled list to
	 the current list, one at a time. *)
      fun setOne target =
        case (List.find (fn s => s=target) (!disTargets))
        of SOME _ =>
	  (curTargets := target :: !curTargets;
	   disTargets := List.filter (fn s => s<>target) (!disTargets))
          | NONE =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "No such target as " ^ target)
    in
      proj_file_changed := true;
      app setOne targetList
    end

  exception NoTargetDetailsFound of string
  fun getTargetDetails (name, detailsList) = 
    let 
      val details = List.find (fn (n,t) => n = name) detailsList
    in
      if isSome details then valOf(details) 
      else 
        raise NoTargetDetailsFound name
    end

  fun get_target_details name = 
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {targetDetails, ...} = targets
    in
      getTargetDetails (name, !targetDetails)
    end

  fun setCurrentMode (error_info, location) mode =
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, currentMode, ...} = modes
    in
      proj_file_changed := true;
      case (List.find (fn {name, ...} => name=mode) (!modeDetails))
      of SOME _ =>
        currentMode := SOME mode
      | NONE =>
	Info.error'
	  error_info
	  (Info.FATAL, location, "No such mode as " ^ mode)
    end

  exception NoModeDetailsFound of string
  fun getModeDetails (modeName, detailsList: mode_details list) = 
    let 
      val details = 
	List.find (fn {name=n, ...} => n = modeName) detailsList
    in
      if isSome details then valOf(details) 
      else 
	raise NoModeDetailsFound modeName
    end

  fun get_mode_details modeName = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, ...} = modes
    in
      getModeDetails (modeName, !modeDetails)
    end

  exception NoConfigDetailsFound of string

  (* Configuration details are modified by replacing an entry in the
     configDetails list *)
  fun modifyConfigDetails
	({name = testName, files = f, library = l},
	(detailsList: config_details list)) =
    let 
      val {name=configName, ...} = 
	case (List.find (fn {name=n, ...} => n=testName) detailsList) of
	   SOME result => result
	 | NONE => raise NoConfigDetailsFound testName
      val others = List.filter (fn {name=n, ...} => n <> testName) detailsList;
    in 
      {name = configName, 
       files = f,
       library = l} :: others
    end

  fun setCurrentConfiguration (error_info, location) optional_config =
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, currentConfig, ...} = configs
    in
      proj_file_changed := true;
      case optional_config of
        SOME config =>      
         (case (List.find (fn {name, ...} => name=config) (!configDetails))
          of SOME _ =>
            currentConfig := SOME config
          | NONE =>
    	    Info.error'
	      error_info
	      (Info.FATAL, location, "No such configuration as " ^ config))
        | NONE => currentConfig := NONE
    end

  fun modify_config_details details =
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, ...} = configs
    in 
      proj_file_changed := true;
      modifyConfigDetails (details, !configDetails)
    end

  fun getConfigDetails (configName, detailsList: config_details list) = 
    let 
      val details = 
	List.find (fn {name=n, ...} => n = configName) detailsList
    in
      if isSome details then valOf(details) 
      else 
	raise NoConfigDetailsFound configName
    end

  fun get_config_details configName = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, ...} = configs
    in
      getConfigDetails (configName, !configDetails)
    end

  fun getAboutInfo () = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      (!description, !version)
    end

  fun setAboutInfo (descStr, verStr) = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      proj_file_changed := true;
      description := descStr;
      version := verStr
    end

  fun initialize () = 
d274 1
a274 1
			modes, configs, locations, about} = project_file
a282 1

d301 3
d305 1
a305 1
  fun getProjectName () =
d309 1
a309 1
      (!projectName)
d318 1
a318 1
	SOME dir => dir
d320 5
a324 5
	let
	  val dir = getOpt(Getenv.get_startup_dir(), OS.FileSys.getDir())
	in
	  (baseDirRef := SOME dir; dir)
	end
d327 3
a329 3
  fun getProjectDir () =
    case getProjectName () 
    of SOME "" 	 => 
d335 1
a335 1
     | NONE 	 => 
d339 5
a343 3
  fun getFiles () = 
    let 
      val PROJECT_FILE {files, ...} = project_file
d345 1
a345 1
      (!files)
d348 4
a351 3
  fun getSubprojects () = 
    let 
      val PROJECT_FILE {subprojects, ...} = project_file
d353 3
a355 1
      (!subprojects)
d358 2
a359 1
  fun getTargets () = 
d361 2
a362 2
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
d364 1
a364 1
      (!curTargets, !disTargets, !targetDetails)
d367 1
a367 1
  fun getModes () = 
d369 2
a370 2
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails, currentMode} = modes
d372 4
a375 1
      (!modes, !modeDetails, !currentMode)
a377 7
  fun getConfigurations () = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails, currentConfig} = configs
    in
      (!configs, !configDetails, !currentConfig)
    end
d379 1
a379 1
  fun getLocations () = 
d381 1
a381 2
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
d383 1
a383 1
      (!libraryPath, !objectsLoc, !binariesLoc)
d386 1
a386 1
  fun setFiles new_files = 
d394 9
a402 1
  fun setSubprojects proj_list = 
d410 25
a434 1
  fun setTargets (current, disabled, details) = 
d445 58
a502 1
  fun setModes (modeList, details) = 
d512 1
a512 1
  fun setConfigurations (configList, details) = 
d514 2
a515 2
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails, ...} = configs
d518 7
a524 2
      configs := configList;
      configDetails := details
d527 5
a531 1
  fun setLocations (libPath, obj, bin) = 
d533 2
a534 2
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
d536 1
a536 4
      proj_file_changed := true;
      libraryPath := libPath;
      objectsLoc := obj;
      binariesLoc := bin
d539 9
a547 27
  fun separator arg = 
    (MLWorks.String.ordof arg = ord #" ") orelse
    (MLWorks.String.ordof arg = ord #"\013") orelse
    (MLWorks.String.ordof arg = ord #"\n");

  fun find_space(arg as (s, i)) =
    if i >= size s orelse separator arg then 
      i
    else
      find_space(s, i+1);

  fun ignore_spaces(arg as (s, i)) =
    if i >= size s orelse (not (separator arg)) then
      i
    else
      ignore_spaces(s, i+1);

  fun renumber_up (s, n) = (s, n + 1)
  fun renumber_down (s, n) = (s, n - 1)

  local
    fun escape_string s =
      let val escaped_s = String.toCString s
       in if Char.contains s #" "
          then String.translate (fn #" " => "\\040" | c => str c) escaped_s
          else escaped_s
      end
d549 16
a564 10
    fun unescape_string s =
      case String.fromCString s of
        SOME s' => s'
      | NONE => s

    fun out (outstream, []) = TextIO.output (outstream, "\n")
      | out (outstream, [h]) = TextIO.output (outstream, (escape_string h) ^ "\n")
      | out (outstream, h::t) = 
	  (TextIO.output (outstream, (escape_string h) ^ " ");
	   out (outstream, t))
d566 1
a566 7
    fun getFullFilename (filename, dirName) = 
      let 
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, dirName)
      in
	OS.Path.mkCanonical abs_name
      end
d568 9
a576 21
    (* ins: takes an input stream and returns a list of strings which form 
     * the next line in the stream. *)
    fun ins (instream) = 
      let 
	val in_line = TextIO.inputLine instream
	fun get_next name = 
	  let val i = ignore_spaces(name, 0)
	  in
	    if i >= size name then
	      ("","")
	    else
	      let val j = find_space(name, i)
	      in
		(substring(name, i, j-i), substring(name, j, (size name)-j))
	      end
	  end

	fun recurse (a,b) = 
	  if b <> "" 
          then ((unescape_string a)::(recurse(get_next b))) 
          else [unescape_string a]
d578 18
a595 7
      in
	recurse (get_next in_line)
      end 

    fun write_bool true = "true"
      | write_bool false = "false"
    val write_int = Int.toString
a596 1
    fun outSpace s = if s = "" then "___" else s
a597 3
    fun saveFiles outstream =
      (map (fn s => out (outstream, ["File", OS.Path.toUnixPath s]))
           (getFiles()))
d599 32
a630 34
    fun saveSubprojects outstream =
      (map (fn s => out (outstream, ["Subproject", OS.Path.toUnixPath s]))
           (getSubprojects()))

    fun saveTargets outstream = 
      let 
	fun outTargetType EXECUTABLE = "EXECUTABLE"
	  | outTargetType LIBRARY = "LIBRARY"
	  | outTargetType IMAGE = "IMAGE"
	  | outTargetType OBJECT_FILE = "OBJECT_FILE"

	fun save_one (target, targetType, disabled) = 
	  out (outstream, [if disabled then "DisabledTarget" else "Target", 
			   target, 
			   outTargetType targetType])

	fun save_target disabled name = 
	  let 
	    val (n, tarType) = get_target_details name
	    handle NoTargetDetailsFound t => 
	      (warn_error ("Warning: Error in saving target " ^ t);
	       (name, EXECUTABLE))
	  in 
	    save_one (name, tarType, disabled)
	  end
	  handle NoTargetDetailsFound t => 
	    warn_error ("Warning: Error in saving target " ^ t)

	val PROJECT_FILE {targets, ...} = project_file
	val {curTargets, disTargets, ...} = targets
      in
	(app (save_target false) (!curTargets);
	 app (save_target true) (!disTargets))
      end
d632 1
a632 1
    fun newModeDetails name = 
d645 21
a665 30
    fun saveModes outstream = 
      let
	(* Only those mode options that are true are saved to save space, and
         * speed up the save and load operations. *)
	fun save_one (modeName, optionName, value) = 
	  if (!value) then 
	    out (outstream, ["ModeDetails", modeName, optionName, write_bool (!value)])
	  else ()

	fun save_mode name = 
	  let 
	    val modeRec = get_mode_details name
	    handle NoModeDetailsFound m => 
	      (warn_error ("Warning: Error in saving mode " ^ m);
	       newModeDetails m)
	  in
	    out (outstream, ["Mode", name]);
	    out (outstream, ["ModeLocation", name, !(#location modeRec)]);
	    save_one (name, "GenInterruptableCode", #generate_interruptable_code modeRec);
	    save_one (name, "GenInterceptableCode", #generate_interceptable_code modeRec);
	    save_one (name, "GenDebugInfo", #generate_debug_info modeRec);
	    save_one (name, "GenVarDebugInfo", #generate_variable_debug_info modeRec);
	    save_one (name, "OptLeafFns", #optimize_leaf_fns modeRec);
	    save_one (name, "OptTailCalls", #optimize_tail_calls modeRec);
	    save_one (name, "OptSelfTailCalls", #optimize_self_tail_calls modeRec);
	    save_one (name, "MipsR4000", #mips_r4000 modeRec);
	    save_one (name, "SparcV7", #sparc_v7 modeRec)
	  end
	  handle NoModeDetailsFound m => 
	    warn_error ("Warning: Error in saving mode " ^ m)
a666 10
	val PROJECT_FILE {modes, ...} = project_file
	val {modes, currentMode, ...} = modes
      in
	app save_mode (!modes);
	case !currentMode of
	  SOME name => 
	    out (outstream, ["CurrentMode", name])
	| NONE =>
	    ()
      end
d668 1
a668 1
    fun saveConfigs outstream =
d670 36
a706 27
	fun save_files (name, file_list) = 
	  app
            (fn f =>
               out
                 (outstream, ["ConfigFile", name, OS.Path.toUnixPath f]))
            file_list

	fun save_library (name, lPath) = 
	  app
            (fn l =>
               out
                 (outstream, ["ConfigLibrary", name, OS.Path.toUnixPath l]))
            lPath

	fun save_config name = 
	  let 
	    val configRec = get_config_details name
	    handle NoConfigDetailsFound c => 
	      (warn_error ("Warning: Error in saving configuration " ^ c);
	       {name=name, library=[], files=[]})
	  in
	    out (outstream, ["Configuration", name]);
	    save_files (name, #files configRec);
	    save_library (name, #library configRec)
	  end
	  handle NoConfigDetailsFound c => 
	    warn_error ("Warning: Error in saving configuration " ^ c)
d708 79
a786 2
	val PROJECT_FILE {configs, ...} = project_file
	val {configs, currentConfig, ...} = configs
d788 1
a788 6
	app save_config (!configs);
	case !currentConfig of
	  SOME name => 
	    out (outstream, ["CurrentConfig", name])
	| NONE =>
	    ()
d790 1
d792 1
a792 1
    fun saveLocations outstream = 
d794 71
a864 2
	val PROJECT_FILE {locations, ...} = project_file
	val {libraryPath, objectsLoc, binariesLoc} = locations
d866 5
a870 9
        app 
          (fn s => out (outstream, ["LocationsPath", OS.Path.toUnixPath s]))
          (!libraryPath);
        out
          (outstream,
           ["LocationsObj", outSpace (OS.Path.toUnixPath (!objectsLoc))]);
        out
          (outstream,
           ["LocationsBin", outSpace (OS.Path.toUnixPath (!binariesLoc))])
a872 235
    fun saveAboutInfo outstream = 
      let
	val PROJECT_FILE {about, ...} = project_file
	val {description, version} = about
      in
	out (outstream, ["!!!", !description]);
	out (outstream, ["!!!", !version]);
	out (outstream, ["Description", !description]);
	out (outstream, ["Version", !version])
      end

    fun save_to_stream outstream =
      (saveAboutInfo outstream;
       ignore(saveFiles outstream);
       ignore(saveSubprojects outstream);
       saveTargets outstream;
       saveModes outstream;
       saveConfigs outstream;
       saveLocations outstream)

    fun load_from_stream (proj, instream) = 
      let 
	fun read_bool "true" = true
	  | read_bool _ = false
	fun inTargetType "EXECUTABLE" = EXECUTABLE
	  | inTargetType "LIBRARY" = LIBRARY
	  | inTargetType "IMAGE" = IMAGE
	  | inTargetType "OBJECT_FILE" = OBJECT_FILE
	  | inTargetType _ = EXECUTABLE
	fun getBoolRef s (r: mode_details) = 
	  case s of 
	     "GenInterruptableCode" 	=> #generate_interruptable_code r
           | "GenInterceptableCode" 	=> #generate_interceptable_code r
      	   | "GenDebugInfo"		=> #generate_debug_info r
      	   | "GenVarDebugInfo"		=> #generate_variable_debug_info r
      	   | "OptLeafFns"		=> #optimize_leaf_fns r
      	   | "OptTailCalls"		=> #optimize_tail_calls r
      	   | "OptSelfTailCalls"		=> #optimize_self_tail_calls r
       	   | "MipsR4000"		=> #mips_r4000 r
       	   | "SparcV7"			=> #sparc_v7 r
     	   | _ => ref false

	fun get_line () =
	  let 
	    val theList = ins instream 
	    fun conv s = if s = "___" then "" else s
	    fun remove_nl (nl :: rest) = rev rest
	      | remove_nl l = l
	    val PROJECT_FILE {files, subprojects, targets, modes, 
			      configs, locations, about, ...} = proj
	    val {curTargets, disTargets, targetDetails} = targets
	    val {modes, modeDetails, currentMode} = modes
	    val {configs, configDetails, currentConfig} = configs
	    val {libraryPath, objectsLoc, binariesLoc} = locations
	    val {description, version} = about
            fun flatten_with_space [] = ""
              | flatten_with_space [h] = h
              | flatten_with_space (h :: t) = h ^ " " ^ (flatten_with_space t)
	  in
	    if theList = [] then () 
	    else case theList of 
	        ("Description" :: descStrList) => 
		    description := flatten_with_space
			(remove_nl (rev descStrList))
	      | ("Version" :: verStrList) => 
		    version := flatten_with_space
			(remove_nl (rev verStrList))
              | ["File", new_file, nl] =>
                    files := (!files) @@ [OS.Path.fromUnixPath new_file]
              | ["Subproject", proj, nl] =>
                    subprojects := (!subprojects) @@ [OS.Path.fromUnixPath proj]
	      | ["Target", tar, tarType, nl] => 
		    (targetDetails := 
			(tar, inTargetType tarType) :: (!targetDetails);
		     curTargets := (!curTargets) @@ [tar])
	      | ["DisabledTarget", tar, tarType, nl] =>
		    (targetDetails := 
			(tar, inTargetType tarType) :: (!targetDetails);
		     disTargets := (!disTargets) @@ [tar])
	      | ["Mode", name, nl] => 
		    (modes := (!modes) @@ [name];
		     modeDetails := (newModeDetails name) :: (!modeDetails))
	      | ["ModeLocation", modeName, loc, nl] =>
		    (let 
		       val {name, location, ...} = 
			 getModeDetails (modeName, !modeDetails)
		    in
		      location := loc
		    end
		    handle NoModeDetailsFound m => 
		      warn_error ("Warning: Error in loading mode " ^ m))
	      | ["ModeDetails", modeName, option, value, nl] => 
		    (let val details = getModeDetails (modeName, !modeDetails)
		    in
		      (getBoolRef option details) := read_bool value
		    end
		    handle NoModeDetailsFound m => 
		      warn_error ("Warning: Error in loading mode " ^ m))
	      | ["CurrentMode", name, nl] =>
		    currentMode := SOME name
	      (* XXX need some consistency checking once the whole file
		 has been processed (or insist that Mode
		 definitions precede the CurrentMode spec. *)
	      | ["Configuration", name, nl] =>
		    (configs := (!configs) @@ [name];
		     configDetails := {name = name,
				       files = [],
				       library = []} :: (!configDetails))
	      | ["CurrentConfig", name, nl] =>
		    currentConfig := SOME name
	      (* XXX need some consistency checking once the whole fiel
		 has been processed (or insist that Configuration 
		 definitions precede the CurrentConfig spec. *)
	      | ["ConfigFile", configName, filename, nl] =>
		  let 
		    val {name, files, library} = 
			getConfigDetails (configName, !configDetails)
		    handle NoConfigDetailsFound c =>
		      (warn_error ("Warning: Error in loading configuration " ^ c);
			{library = [], name = configName, files = []})
		  in
		    configDetails := 
		      modifyConfigDetails 
                        ({name = name,
			  files = files @@ [OS.Path.fromUnixPath filename],
			  library = library}, 
			 !configDetails)
		    handle NoConfigDetailsFound c =>
		      warn_error ("Warning: Error in loading configuration " ^ c)
		  end
	      | ["ConfigLibrary", configName, dir, nl] =>
		  let 
		    val {name, files, library} = 
			getConfigDetails (configName, !configDetails)
		    handle NoConfigDetailsFound c =>
		      (warn_error ("Warning: Error in loading configuration " ^ c);
			{library = [], name = configName, files = []})
		  in
		    configDetails := 
		      modifyConfigDetails
                        ({name = name,
			  files = files,
			  library = library @@ [OS.Path.fromUnixPath dir]},
			 !configDetails)
		    handle NoConfigDetailsFound c =>
		      warn_error ("Warning: Error in loading configuration " ^ c)
		  end
	      | ["LocationsPath", dir, nl] => 
                  libraryPath := (!libraryPath) @@ [OS.Path.fromUnixPath dir]
	      | ["LocationsObj", loc, nl] =>
                  objectsLoc := OS.Path.fromUnixPath (conv loc)
	      | ["LocationsBin", loc, nl] => 
                  binariesLoc := OS.Path.fromUnixPath (conv loc)

	      | ("!!!" :: rest) => ()

	      | s => app warn_error s;
	    if (not (TextIO.endOfStream instream)) then get_line () else ()
	  end
      in 
	get_line()
      end (* load_from_stream *)

  in

    fun getChildren filename = 
      let
        fun getFileName proj = 
          if OS.Path.isRelative proj then 
            OS.Path.mkCanonical (OS.Path.mkAbsolute (proj, OS.Path.dir filename))
          else
            OS.Path.mkCanonical proj

	val instream = TextIO.openIn (OS.Path.mkCanonical filename)

        fun add_file (fl, addList) = 
          let val fname = getFileName fl
          in
	    if isSome (List.find (fn f => f=fname) addList) then addList
	    else fname :: addList
          end

	val directChildren = ref []
	fun get_subprojs istream = 
	  let 
	    val theList = 
	      if (not (TextIO.endOfStream istream)) then
	        ins istream 
	      else []
	  in
	    case theList of
	      ["Subproject", proj, nl] => 
		(directChildren := add_file (proj, !directChildren); get_subprojs istream)
	    | [] => (!directChildren)
	    | _ => get_subprojs istream
	  end

	val subprojects = get_subprojs instream
	handle exn => (TextIO.closeIn instream; raise exn)
      in
	TextIO.closeIn instream;
	subprojects
      end (* getChildren *);

    fun getAllSubProjects' [] = []
      | getAllSubProjects' files = 
	let val children = foldl (op @@) [] (map getChildren files)
	in
	  files @@ (getAllSubProjects' children)
	end

    fun getAllSubProjects filename = rev (Lists.filter (getAllSubProjects' [filename]))

    (* getSubTargets assumes given filename is canonical absolute *)
    fun getSubTargets filename = 
      let
	val instream = TextIO.openIn filename

	fun get_sub_targets stream = 
	  let 
	    val theList = 
	      if (not (TextIO.endOfStream stream)) then
	        ins stream 
	      else []

	    fun add_target (t, tList) = 
	      if isSome (List.find (fn f=>f=t) tList) then tList
	      else t :: tList
	  in
	    case theList of
	      ["Target", tar, tarType, nl] => 
		add_target (tar, get_sub_targets stream)
	    | [] => []
	    | _ => get_sub_targets stream
	  end
d874 1
a874 21
	val sub_targets = get_sub_targets instream
	handle exn => (TextIO.closeIn instream; raise exn)
      in
	TextIO.closeIn instream;
	sub_targets
      end (* getSubTargets *)

    fun save_proj filename =
      let
	val PROJECT_FILE {projectName, ...} = project_file
	val abs_name = getFullFilename (filename, getProjectDir())
        val outstream = TextIO.openOut abs_name
      in
	projectName := SOME abs_name;
        diagnostic (2, fn _ => ["Project saved to ", abs_name]);
	save_to_stream outstream
        handle exn => (TextIO.closeOut outstream; raise exn);
        TextIO.closeOut outstream
      end

    fun open_proj filename =
d876 9
a884 3
	val PROJECT_FILE {projectName, ...} = project_file
	val abs_name = getFullFilename (filename, getProjectDir())
	val instream = TextIO.openIn abs_name
d886 1
a886 2
        proj_file_changed := true;
	initialize();
d888 13
a900 4
        diagnostic (2, fn _ => ["Project opened from ", abs_name]);
        load_from_stream (project_file, instream)
        handle exn => (TextIO.closeIn instream; raise exn)
        TextIO.closeIn instream
d903 2
a904 1
    fun close_proj () =
d906 1
a906 1
	val PROJECT_FILE {projectName, ...} = project_file
d909 1
a909 1
	initialize();
a912 31
    fun peek_project filename = 
      let 
	val new_proj = mk_empty_proj()
	val PROJECT_FILE {projectName, ...} = new_proj
	val abs_name = getFullFilename (filename, getProjectDir())
	val instream = TextIO.openIn abs_name

        val PROJECT_FILE {files, subprojects, targets, modes,
			  configs, locations, ...} = new_proj
	val {curTargets, disTargets, ...} = targets
	val {configDetails, currentConfig, ...} = configs
	val {libraryPath, objectsLoc, binariesLoc} = locations
	val {modeDetails, currentMode, ...} = modes
      in
        projectName := SOME abs_name;
        diagnostic (2, fn _ => ["Project opened from ", abs_name]);
        load_from_stream (new_proj, instream)
        handle exn => (TextIO.closeIn instream; raise exn)
        TextIO.closeIn instream;
	{name = abs_name,
	 files = !files,
	 curTargets = !curTargets,
	 disTargets = !disTargets,
	 subprojects = !subprojects,
	 libraryPath = !libraryPath,
	 objectsLoc = !objectsLoc,
	 binariesLoc = !binariesLoc,
	 currentConfig = !currentConfig, 
	 configDetails = !configDetails,
	 currentMode = !currentMode,
	 modeDetails = !modeDetails}
d914 36
a949 1
      end
a950 1
  end  (* local *)
a951 1
end
@


1.11
log
@[Bug #50071]
Extend interface to support close project, and fix parsing of description and version info
@
text
@d3 4
d190 1
a190 1
     source: string list, 
d209 1
a209 1
     sourcePath:	string list ref,
d221 1
a221 1
		  sourcePath = ref [],
d331 1
a331 1
	({name = testName, source = s, library = l},
d341 1
a341 1
       source = s,
d410 1
a410 1
      val PROJECT_FILE {projectName, sourcePath, subprojects, targets, 
d424 1
a424 1
      sourcePath := [];
d474 1
a474 1
  fun getSourcePath () = 
d476 1
a476 1
      val PROJECT_FILE {sourcePath, ...} = project_file
d478 1
a478 1
      (!sourcePath)
d520 1
a520 1
  fun setSourcePath path = 
d522 1
a522 1
      val PROJECT_FILE {sourcePath, ...} = project_file
d525 1
a525 1
      sourcePath := path
d657 3
a659 3
    fun saveSourcePath outstream =
      (map (fn s => out (outstream, ["SourceDir", OS.Path.toUnixPath s]))
           (getSourcePath()))
d753 2
a754 1
	fun save_source (name, sPath) = 
d756 1
a756 1
            (fn s =>
d758 3
a760 2
                 (outstream, ["ConfigSource", name, OS.Path.toUnixPath s]))
            sPath
d773 1
a773 1
	       {name=name, library=[], source=[]})
d776 1
a776 1
	    save_source (name, #source configRec);
d822 1
a822 1
       ignore(saveSourcePath outstream);
d857 1
a857 1
	    val PROJECT_FILE {sourcePath, subprojects, targets, modes, 
d876 2
a877 2
              | ["SourceDir", dir, nl] =>
                    sourcePath := (!sourcePath) @@ [OS.Path.fromUnixPath dir]
d915 1
a915 1
				       source = [],
d922 1
a922 1
	      | ["ConfigSource", configName, dir, nl] =>
d924 1
a924 1
		    val {name, source, library} = 
d928 1
a928 1
			{library = [], name = configName, source = []})
d933 1
a933 1
			  source = source @@ [OS.Path.fromUnixPath dir],
d941 1
a941 1
		    val {name, source, library} = 
d945 1
a945 1
			{library = [], name = configName, source = []})
d950 1
a950 1
			  source = source,
d1096 1
a1096 1
        val PROJECT_FILE {sourcePath, subprojects, targets, modes,
d1109 1
a1109 1
	 sourcePath = !sourcePath,
@


1.10
log
@[Bug #30389]
Keep projects more in step with projfiles
@
text
@d3 4
d341 1
a341 1
  fun setCurrentConfiguration (error_info, location) config =
d347 10
a356 7
      case (List.find (fn {name, ...} => name=config) (!configDetails))
      of SOME _ =>
        currentConfig := SOME config
      | NONE =>
	Info.error'
	  error_info
	  (Info.FATAL, location, "No such configuration as " ^ config)
d858 3
d865 1
a865 1
		    description := foldr (fn (a, b) => a ^ " " ^ b) "" 
d868 1
a868 1
		    version := foldr (fn (a, b) => a ^ " " ^ b) "" 
d1072 9
@


1.9
log
@[Bug #30376]
Add objects suffix to default object path (for installations)
@
text
@d3 4
d237 4
d262 1
d289 1
d342 1
d357 1
d392 1
d513 1
d521 1
d530 1
d541 1
d551 1
d561 1
d1055 1
@


1.8
log
@[Bug #50073]
Fix getProjectDir to use get_startup_dir, not OS.FileSys.getDir.
@
text
@d3 4
d412 1
a412 1
      objectsLoc := "";
@


1.7
log
@[Bug #30386]
Allow spaces to appear in paths
@
text
@d3 4
d95 5
a99 3
require "../system/__os";
require "../basis/__text_io";
require "^.utils.__terminal";
d108 5
d419 15
d438 1
a438 1
       OS.FileSys.getDir())
@


1.6
log
@[Bug #30365]
Implement support for sub-projects.
@
text
@d3 4
d89 2
d539 11
d552 1
a552 1
      | out (outstream, [h]) = TextIO.output (outstream, h ^ "\n")
d554 1
a554 1
	  (TextIO.output (outstream, h ^ " ");
d583 3
a585 1
	  if b <> "" then (a::(recurse(get_next b))) else [a]
d598 2
a599 1
      (map (fn s => out (outstream, ["SourceDir", s])) (getSourcePath()))
d602 2
a603 1
      (map (fn s => out (outstream, ["Subproject", s])) (getSubprojects()))
@


1.5
log
@Automatic checkin:
changed attribute _comment to ' *  '
@
text
@d3 4
d91 1
d97 1
d114 3
a116 1

d125 1
a125 1

d129 2
a130 2
  (* (name, type, mode, configuration) *)
  type target_details = (string * target_type * string * string)
d239 1
a239 1
      val details = List.find (fn (n,t,m,c) => n = name) detailsList
a375 2

      Terminal.output"past diag 1 in initialize\n";
d540 8
d591 1
a591 1
	fun save_one (target, targetType, mode, config, disabled) = 
d594 1
a594 3
			   outTargetType targetType, 
			   outSpace mode, 
			   outSpace config])
d598 1
a598 1
	    val (n, tarType, mode, config) = get_target_details name
d601 1
a601 1
	       (name, EXECUTABLE, "", ""))
d603 1
a603 1
	    save_one (name, tarType, mode, config, disabled)
d794 1
a794 1
	      | ["Target", tar, tarType, mode, config, nl] => 
d796 1
a796 2
			(tar, inTargetType tarType, conv mode, conv config) ::
			  (!targetDetails);
d798 1
a798 1
	      | ["DisabledTarget", tar, tarType, mode, config, nl] =>
d800 1
a800 2
			(tar, inTargetType tarType, conv mode, conv config) ::
			  (!targetDetails);
d807 2
a808 1
		       val {name, location, ...} = get_mode_details modeName
d815 1
a815 1
		    (let val details = get_mode_details modeName
d839 1
a839 1
			get_config_details configName
d845 5
a849 4
		      modify_config_details 
                        {name = name,
			 source = source @@ [OS.Path.fromUnixPath dir],
			 library = library}
d856 1
a856 1
			get_config_details configName
d862 5
a866 4
		      modify_config_details
                        {name = name,
			 source = source,
			 library = library @@ [OS.Path.fromUnixPath dir]}
d888 1
a888 1
    fun getSubProjects filename = 
d898 8
a911 7

	    fun add_file (fl, addList) = 
	      let val fname = getFileName fl
	      in
		if isSome (List.find (fn f => f=fname) addList) then addList
		else fname :: addList
	      end
d915 2
a916 2
		add_file (proj, (get_subprojs istream) @@ (getSubProjects (getFileName proj)))
	    | [] => add_file (filename, [])
d925 10
a934 1
      end (* getSubProjects *)
d953 1
a953 1
	      ["Target", tar, tarType, mode, config, nl] => 
d969 1
a969 2
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
d982 1
a982 2
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
d997 1
a997 2
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
d1000 1
a1000 1
        val PROJECT_FILE {sourcePath, subprojects, targets, 
d1005 1
d1012 1
a1012 1
	{dir = OS.Path.dir abs_name,
d1021 3
a1023 1
	 configDetails = !configDetails}
@


1.4
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@@


1.3
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d3 4
d727 2
a728 2
       saveSourcePath outstream;
       saveSubprojects outstream;
@


1.2
log
@new unit
[Bug #30071]
Stores project file information for the new Project Workspace.
@
text
@d3 5
d79 1
d108 1
a108 1
      fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\t")
d111 1
a111 1
      MLWorks.IO.output (MLWorks.IO.terminal_out, "\n")
d172 1
a172 1
  fun warn_error s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\n")
d365 1
a365 1
      MLWorks.IO.output (MLWorks.IO.terminal_out, "past diag 1 in initialize\n");
@


1.1
log
@new file on MLWorks_workspace_97
@
text
@d1 996
@


1.1.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a0 573
(*
 * $Log: _proj_file.sml,v $
 *
 * 
 * Copyright (C) 1997.  The Harlequin Group Limited.  All rights reserved.
 *
 *)

require "../basis/__int";
require "../basis/list";

require "proj_file";

functor ProjFile (
  structure List: LIST
): PROJ_FILE = 
struct
  datatype target_type = IMAGE | OBJECT_FILE | EXECUTABLE | LIBRARY

  (* curTargets, disTargets: (string * int) list meaning (name, position) *)
  (* These reference lists store the items that are displayed in the listbox control. *)

  (* (name (string), type (targetType), mode (string), configuration (string)) list *)
  type target_details = (string * target_type * string * string)

  type Targets =
    {curTargets:    string list ref,
     disTargets:    string list ref,
     targetDetails: target_details list ref}

  type mode_details =  
    {name:					string,
     generate_interruptable_code:		bool ref,
     generate_interceptable_code:		bool ref,
     generate_debug_info:			bool ref,
     generate_variable_debug_info:		bool ref,
     optimize_leaf_fns:				bool ref,
     optimize_tail_calls:			bool ref,
     optimize_self_tail_calls:			bool ref,
     mips_r4000:				bool ref,
     sparc_v7:					bool ref}

  type Modes =
    {modes:	  string list ref,
     modeDetails: mode_details list ref}

  type config_details =
    {name: string, 
     source: string list, 
     library: string list,
     objects: string,
     bins: string}

  type Configurations =
    {configs:		string list ref,
     configDetails:	config_details list ref}

  type Locations =
    {libraryPath:	string list ref,
     objectsLoc:	string ref,
     binariesLoc:	string ref}

  datatype ProjectFile = PROJECT_FILE of 
    {projectName:	string ref,
     sourcePath:	string list ref,
     targets:		Targets,
     modes:		Modes,
     configs:		Configurations,
     locations:		Locations}

  val project_file = 
    PROJECT_FILE {projectName = ref "", 
		  sourcePath = ref [],
		  targets = 
			{curTargets = ref [],
			 disTargets = ref [],
			 targetDetails = ref []},
		  modes = 
			{modes = ref [],
			 modeDetails = ref []},
		  configs = 
			{configs = ref [],
			 configDetails = ref []},
		  locations = 
			{libraryPath = ref [],
			 objectsLoc = ref "",
			 binariesLoc = ref ""}}

  exception NoTargetDetailsFound of string
  fun getTargetDetails (name, detailsList) = 
    let 
      val details = List.find (fn (n,t,m,c) => n = name) detailsList
    in
      if isSome details then valOf(details) 
      else raise NoTargetDetailsFound name
    end

  fun get_target_details name = 
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {targetDetails, ...} = targets
    in
      getTargetDetails (name, !targetDetails)
    end

  exception NoModeDetailsFound of string
  fun getModeDetails (modeName, detailsList: mode_details list) = 
    let 
      val details = 
	List.find (fn {name=n, ...} => n = modeName) detailsList
    in
      if isSome details then valOf(details) 
      else raise NoModeDetailsFound modeName
    end

  fun get_mode_details modeName = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, ...} = modes
    in
      getModeDetails (modeName, !modeDetails)
    end

  (* Configuration details are modified by replacing an entry in the configDetails list *)
  fun modifyConfigDetails
	({name = testName, source = s, library = l, objects = obj, bins = b},
	(detailsList: config_details list)) =
    let 
      val {name=configName, ...} = 
	valOf (List.find (fn {name=n, ...} => n=testName) detailsList)
      val others = List.filter (fn {name=n, ...} => n <> testName) detailsList;
    in 
      {name = configName, 
       source = s,
       library = l,
       objects = obj,
       bins = b} :: others
    end

  fun modify_config_details details =
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, ...} = configs
    in 
      modifyConfigDetails (details, !configDetails)
    end

  exception NoConfigDetailsFound of string
  fun getConfigDetails (configName, detailsList: config_details list) = 
    let 
      val details = 
	List.find (fn {name=n, ...} => n = configName) detailsList
    in
      if isSome details then valOf(details) 
      else 
	raise NoConfigDetailsFound configName
    end

  fun get_config_details configName = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, ...} = configs
    in
      getConfigDetails (configName, !configDetails)
    end

  fun initialize () = 
    let
      val PROJECT_FILE {projectName, sourcePath, targets, 
			modes, configs, locations} = project_file
      val {curTargets, disTargets, targetDetails} = targets
      val {modes, modeDetails} = modes
      val {configs, configDetails} = configs
      val {libraryPath, objectsLoc, binariesLoc} = locations
    in
      sourcePath := [];
      curTargets := [];
      disTargets := [];
      targetDetails := [];
      modes := [];
      modeDetails := [];
      configs := [];
      configDetails := [];
      libraryPath := [];
      objectsLoc := "";
      binariesLoc := ""
    end

  fun getProjectName () =
    let 
      val PROJECT_FILE {projectName, ...} = project_file
    in
      (!projectName)
    end

  fun getSourcePath () = 
    let 
      val PROJECT_FILE {sourcePath, ...} = project_file
    in
      (!sourcePath)
    end

  fun getTargets () = 
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
    in
      (!curTargets, !disTargets, !targetDetails)
    end

  fun getModes () = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails} = modes
    in
      (!modes, !modeDetails)
    end

  fun getConfigurations () = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails} = configs
    in
      (!configs, !configDetails)
    end

  fun getLocations () = 
    let 
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
    in
      (!libraryPath, !objectsLoc, !binariesLoc)
    end

  fun setProjectName name = 
    let
      val PROJECT_FILE {projectName, ...} = project_file
    in
      projectName := name
    end

  fun setSourcePath path = 
    let
      val PROJECT_FILE {sourcePath, ...} = project_file
    in
      sourcePath := path
    end

  fun setTargets (current, disabled, details) = 
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, targetDetails} = targets
    in
      curTargets := current;
      disTargets := disabled;
      targetDetails := details
    end

  fun setModes (modeList, details) = 
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modes, modeDetails} = modes
    in
      modes := modeList;
      modeDetails := details
    end

  fun setConfigurations (configList, details) = 
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configs, configDetails} = configs
    in
      configs := configList;
      configDetails := details
    end

  fun setLocations (libPath, obj, bin) = 
    let 
      val PROJECT_FILE {locations, ...} = project_file
      val {libraryPath, objectsLoc, binariesLoc} = locations
    in
      libraryPath := libPath;
      objectsLoc := obj;
      binariesLoc := bin
    end

  fun find_space(arg as (s, i)) =
    if i >= size s orelse MLWorks.String.ordof arg = ord #" " then
      i
    else
      find_space(s, i+1)

  fun renumber_up (s, n) = (s, n + 1)
  fun renumber_down (s, n) = (s, n - 1)

  local

    fun out (outstream, []) = MLWorks.IO.output (outstream, "\n")
      | out (outstream, h::t) = 
	  (MLWorks.IO.output (outstream, h ^ " ");
	   out (outstream, t))

    (* ins: takes an input stream and returns a list of strings which form 
     * the next line in the stream. *)
    fun ins (instream) = 
      let 
	val in_line = MLWorks.IO.input_line instream
	fun get_next s = 
	  let val i = find_space (s, 0)
	  in
	   if i >= size s then ("","") else
	    (substring (s, 0, i), substring (s, i+1, (size s)-i-1))
		handle Substring => ("","")
	  end
	fun recurse (a,b) = 
	  if b <> "" then (a::(recurse(get_next b))) else [a]
      in
	recurse (get_next in_line)
      end 

    fun write_bool true = "true"
      | write_bool false = "false"
    val write_int = Int.toString

    fun saveSourcePath outstream =
      (map (fn s => out (outstream, ["SourceDir", s])) (getSourcePath()))

    fun saveTargets outstream = 
      let 
	fun outTargetType EXECUTABLE = "EXECUTABLE"
	  | outTargetType LIBRARY = "LIBRARY"
	  | outTargetType IMAGE = "IMAGE"
	  | outTargetType OBJECT_FILE = "OBJECT_FILE"
	fun outMC s = if s = "" then "___" else s

	fun save_one (target, targetType, mode, config, disabled) = 
	  out (outstream, [if disabled then "DisabledTarget" else "Target", 
			   target, 
			   outTargetType targetType, 
			   outMC mode, 
			   outMC config])

	fun save_target disabled name = 
	  let val (n, tarType, mode, config) = get_target_details name
	  in 
	    save_one (name, tarType, mode, config, disabled)
	  end

	val PROJECT_FILE {targets, ...} = project_file
	val {curTargets, disTargets, ...} = targets
      in
	(app (save_target false) (!curTargets);
	 app (save_target true) (!disTargets))
      end

    fun saveModes outstream = 
      let
	(* Only those mode options that are true are saved to save space, and
         * speed up the save and load operations. *)
	fun save_one (modeName, optionName, value) = 
	  if (!value) then 
	    out (outstream, ["ModeDetails", modeName, optionName, write_bool (!value)])
	  else ()

	fun save_mode name = 
	  let val modeRec = get_mode_details name
	  in
	    out (outstream, ["Mode", name]);
	    save_one (name, "GenInterruptableCode", #generate_interruptable_code modeRec);
	    save_one (name, "GenInterceptableCode", #generate_interceptable_code modeRec);
	    save_one (name, "GenDebugInfo", #generate_debug_info modeRec);
	    save_one (name, "GenVarDebugInfo", #generate_variable_debug_info modeRec);
	    save_one (name, "OptLeafFns", #optimize_leaf_fns modeRec);
	    save_one (name, "OptTailCalls", #optimize_tail_calls modeRec);
	    save_one (name, "OptSelfTailCalls", #optimize_self_tail_calls modeRec);
	    save_one (name, "MipsR4000", #mips_r4000 modeRec);
	    save_one (name, "SparcV7", #sparc_v7 modeRec)
	  end

	val PROJECT_FILE {modes, ...} = project_file
	val {modes, ...} = modes
      in
	app save_mode (!modes)
      end

    fun saveConfigs outstream =
      let 
	fun save_source (name, sPath) = 
	  app (fn s => out (outstream, ["ConfigSource", name, s])) sPath
	fun save_library (name, lPath) = 
	  app (fn l => out (outstream, ["ConfigLibrary", name, l])) lPath

	fun outObjBin s = if s = "" then "___" else s
	fun save_locations (name, objLoc, binLoc) =
	  out (outstream, ["ConfigLocations", name, outObjBin objLoc, outObjBin binLoc])

	fun save_config name = 
	  let val configRec = get_config_details name
	  in
	    out (outstream, ["Configuration", name]);
	    save_source (name, #source configRec);
	    save_library (name, #library configRec);
	    save_locations (name, #objects configRec, #bins configRec)
	  end

	val PROJECT_FILE {configs, ...} = project_file
	val {configs, ...} = configs
      in
	app save_config (!configs)
      end

    fun saveLocations outstream = 
      let 
	val PROJECT_FILE {locations, ...} = project_file
	val {libraryPath, objectsLoc, binariesLoc} = locations
      in
        app (fn s => out (outstream, ["LocationsPath", s])) (!libraryPath);
        out (outstream, ["LocationsObj", (!objectsLoc)]);
        out (outstream, ["LocationsBin", (!binariesLoc)])
      end

    fun save_to_stream outstream =
      (saveSourcePath outstream;
       saveTargets outstream;
       saveModes outstream;
       saveConfigs outstream;
       saveLocations outstream)

    fun load_from_stream instream = 
      let 
	fun read_bool "true" = true
	  | read_bool _ = false
	fun inTargetType "EXECUTABLE" = EXECUTABLE
	  | inTargetType "LIBRARY" = LIBRARY
	  | inTargetType "IMAGE" = IMAGE
	  | inTargetType "OBJECT_FILE" = OBJECT_FILE
	  | inTargetType _ = EXECUTABLE
	fun getBoolRef s (r: mode_details) = 
	  case s of 
	     "GenInterruptableCode" 	=> #generate_interruptable_code r
           | "GenInterceptableCode" 	=> #generate_interceptable_code r
      	   | "GenDebugInfo"		=> #generate_debug_info r
      	   | "GenVarDebugInfo"		=> #generate_variable_debug_info r
      	   | "OptLeafFns"		=> #optimize_leaf_fns r
      	   | "OptTailCalls"		=> #optimize_tail_calls r
      	   | "OptSelfTailCalls"		=> #optimize_self_tail_calls r
       	   | "MipsR4000"		=> #mips_r4000 r
       	   | "SparcV7"			=> #sparc_v7 r
     	   | _ => ref false

	fun get_line () =
	  let 
	    val theList = ins instream 
	    fun conv s = if s = "___" then "" else s
	    val PROJECT_FILE {sourcePath, targets, modes, configs, locations, ...} = 
		  project_file
	    val {curTargets, disTargets, targetDetails} = targets
	    val {modes, modeDetails} = modes
	    val {configs, configDetails} = configs
	    val {libraryPath, objectsLoc, binariesLoc} = locations
	  in
	    if theList = [] then () 
	    else case theList of 
                ["SourceDir", dir, nl] => sourcePath := dir:: (!sourcePath)
	      | ["Target", tar, tarType, mode, config, nl] => 
		    (targetDetails := 
			(tar, inTargetType tarType, conv mode, conv config) :: 
				(!targetDetails);
		     curTargets := tar :: (!curTargets))
	      | ["DisabledTarget", tar, tarType, mode, config, nl] =>
		    (targetDetails := 
			(tar, inTargetType tarType, conv mode, conv config) :: 
				(!targetDetails);
		     disTargets := tar :: (!disTargets))
	      | ["Mode", name, nl] => 
		    (modes := name :: (!modes);
		     modeDetails := {name = name,
				     generate_interruptable_code = ref false,
				     generate_interceptable_code = ref false,
				     generate_debug_info = ref false,
				     generate_variable_debug_info = ref false,
				     optimize_leaf_fns = ref false,
				     optimize_tail_calls = ref false,
				     optimize_self_tail_calls = ref false,
				     mips_r4000 = ref false,
				     sparc_v7 = ref false} :: (!modeDetails))
	      | ["ModeDetails", modeName, option, value, nl] => 
		    let val details = get_mode_details modeName
		    in
		      (getBoolRef option details) := read_bool value
		    end
	      | ["Configuration", name, nl] =>
		    (configs := name :: (!configs);
		     configDetails := {name = name,
				       source = [],
				       library = [],
				       objects = "",
				       bins = ""} :: (!configDetails))
	      | ["ConfigSource", configName, dir, nl] =>
		  let 
		    val {name, source, library, objects, bins} = 
			get_config_details configName
		  in
		    configDetails := 
		      modify_config_details {name = name,
					     source = dir :: source,
					     library = library,
					     objects = objects,
					     bins = bins}
		  end
	      | ["ConfigLibrary", configName, dir, nl] =>
		  let 
		    val {name, source, library, objects, bins} = 
			get_config_details configName
		  in
		    configDetails := 
		      modify_config_details {name = name,
					     source = source,
					     library = dir :: library,
					     objects = objects,
					     bins = bins}
		  end
	      | ["ConfigLocations", configName, newObjects, newBins, nl] =>
		  let 
		    val {name, source, library, objects, bins} = 
			get_config_details configName
		  in
		    configDetails := 
		      modify_config_details {name = name,
					     source = source,
					     library = library,
					     objects = conv newObjects,
					     bins = conv newBins}
		  end
	      | ["LocationsPath", dir, nl] => libraryPath := dir :: (!libraryPath)
	      | ["LocationsObj", loc, nl] => objectsLoc := loc
	      | ["LocationsBin", loc, nl] => binariesLoc := loc

	      | s => app (fn s => MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\n")) s;
	    if (not (MLWorks.IO.end_of_stream instream)) then get_line () else ()
	  end
      in 
	initialize();
	get_line()
      end (* load_from_stream *)

  in

    fun save_proj filename =
      let
	val PROJECT_FILE {projectName, ...} = project_file
        val outstream = MLWorks.IO.open_out filename
      in
	projectName := filename;
	save_to_stream outstream
        handle exn => (MLWorks.IO.close_out outstream; raise exn);
        MLWorks.IO.close_out outstream
      end

    fun open_proj filename =
      let 
	val PROJECT_FILE {projectName, ...} = project_file
	val instream = MLWorks.IO.open_in filename
      in
        projectName := filename;
        load_from_stream instream
        handle exn => (MLWorks.IO.close_in instream; raise exn)
        MLWorks.IO.close_in instream
      end

  end  (* local *)

end
@


1.1.1.2
log
@Automatic checkin:
changed attribute _comment to ' *  '
@
text
@@


1.1.1.3
log
@[Bug #30071]
Added support for current configurations, modes and targets.
@
text
@a2 4
 *  Revision 1.1.1.2  1997/09/12  14:37:16  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
a11 2
require "^.main.info";

a15 1
  structure Info: INFO
d18 1
a18 2
  type error_info = Info.options
  type location = Info.Location.T
d20 2
a21 1
  datatype target_type = IMAGE | OBJECT_FILE | EXECUTABLE | LIBRARY
d23 1
a23 1
  (* (name, type, mode, configuration) *)
d26 1
a26 8
  (*
  type targets =
    {curTargets:    string list,
     disTargets:    string list,
     targetDetails: target_details list}
  *)

  type target_refs =
d43 1
a43 8
  (*
  type modes =
    {modes:	  string list,
     modeDetails: mode_details list,
     currentMode: (string * mode_details) option}
  *)

  type mode_refs =
d45 1
a45 2
     modeDetails: mode_details list ref,
     currentMode: string option ref}
d54 1
a54 8
  (*
  type configurations =
    {configs:		string list,
     configDetails:	config_details list,
     currentConfig:	string option}
  *)

  type configuration_refs =
d56 1
a56 2
     configDetails:	config_details list ref,
     currentConfig:	string option ref}
d58 1
a58 1
  type locations =
d63 1
a63 1
  datatype project_file = PROJECT_FILE of 
d66 4
a69 4
     targets:		target_refs,
     modes:		mode_refs,
     configs:		configuration_refs,
     locations:		locations}
d80 1
a80 2
			 modeDetails = ref [],
			 currentMode = ref NONE},
d83 1
a83 2
			 configDetails = ref [],
			 currentConfig = ref NONE},
a88 24
  fun setCurrentTargets (error_info, location) targetList =
    let 
      val PROJECT_FILE {targets, ...} = project_file
      val {curTargets, disTargets, ...} = targets

      (* Begin by assuming that all targets are disabled *)
      val _ = disTargets := !curTargets @@ !disTargets
      val _ = curTargets := []

      (* Then move specified targets from the disabled list to
	 the current list, one at a time. *)
      fun setOne target =
        case (List.find (fn s => s=target) (!disTargets))
        of SOME _ =>
	  (curTargets := target :: !curTargets;
	   disTargets := List.filter (fn s => s<>target) (!disTargets))
          | NONE =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "No such target as " ^ target)
    in
      app setOne targetList
    end

a105 14
  fun setCurrentMode (error_info, location) mode =
    let 
      val PROJECT_FILE {modes, ...} = project_file
      val {modeDetails, currentMode, ...} = modes
    in
      case (List.find (fn {name, ...} => name=mode) (!modeDetails))
      of SOME _ =>
        currentMode := SOME mode
      | NONE =>
	Info.error'
	  error_info
	  (Info.FATAL, location, "No such mode as " ^ mode)
    end

d124 1
a124 2
  (* Configuration details are modified by replacing an entry in the
     configDetails list *)
a139 14
  fun setCurrentConfiguration (error_info, location) config =
    let 
      val PROJECT_FILE {configs, ...} = project_file
      val {configDetails, currentConfig, ...} = configs
    in
      case (List.find (fn {name, ...} => name=config) (!configDetails))
      of SOME _ =>
        currentConfig := SOME config
      | NONE =>
	Info.error'
	  error_info
	  (Info.FATAL, location, "No such configuration as " ^ config)
    end

d172 2
a173 2
      val {modes, modeDetails, currentMode} = modes
      val {configs, configDetails, currentConfig} = configs
a181 1
      currentMode := NONE; 
a183 1
      currentConfig := NONE;
d214 1
a214 1
      val {modes, modeDetails, currentMode} = modes
d216 1
a216 1
      (!modes, !modeDetails, !currentMode)
d222 1
a222 1
      val {configs, configDetails, currentConfig} = configs
d224 1
a224 1
      (!configs, !configDetails, !currentConfig)
d262 1
a262 1
      val {modes, modeDetails, ...} = modes
d271 1
a271 1
      val {configs, configDetails, ...} = configs
d381 1
a381 1
	val {modes, currentMode, ...} = modes
d383 1
a383 6
	app save_mode (!modes);
	case !currentMode of
	  SOME name => 
	    out (outstream, ["CurrentMode", name])
	| NONE =>
	    ()
d407 1
a407 1
	val {configs, currentConfig, ...} = configs
d409 1
a409 6
	app save_config (!configs);
	case !currentConfig of
	  SOME name => 
	    out (outstream, ["CurrentConfig", name])
	| NONE =>
	    ()
d458 2
a459 2
	    val {modes, modeDetails, currentMode} = modes
	    val {configs, configDetails, currentConfig} = configs
a491 5
	      | ["CurrentMode", name, nl] =>
		    currentMode := SOME name
	      (* XXX need some consistency checking once the whole fiel
		 has been processed (or insist that Mode
		 definitions precede the CurrentMode spec. *)
a498 5
	      | ["CurrentConfig", name, nl] =>
		    currentConfig := SOME name
	      (* XXX need some consistency checking once the whole fiel
		 has been processed (or insist that Configuration 
		 definitions precede the CurrentConfig spec. *)
@


1.1.1.4
log
@[Bug #30071]
Handling exceptions.
@
text
@a2 4
 *  Revision 1.1.1.3  1997/11/04  14:45:05  daveb
 *  [Bug #30071]
 *  Added support for current configurations, modes and targets.
 *
a100 2
  fun warn_error s = MLWorks.IO.output (MLWorks.IO.std_err, s ^ "\n")

d151 1
a151 2
      else 
        raise NoTargetDetailsFound name
d183 1
a183 2
      else 
	raise NoModeDetailsFound modeName
a193 2
  exception NoConfigDetailsFound of string

d201 1
a201 3
	case (List.find (fn {name=n, ...} => n=testName) detailsList) of
	   SOME result => result
	 | NONE => raise NoConfigDetailsFound testName
d233 1
a434 2
	  handle NoTargetDetailsFound t => 
	    warn_error ("Warning: Error in saving target " ^ t)
d453 1
a453 2
	  let 
	    val modeRec = get_mode_details name
a465 2
	  handle NoModeDetailsFound m => 
	    warn_error ("Warning: Error in saving mode " ^ m)
a496 2
	  handle NoConfigDetailsFound c => 
	    warn_error ("Warning: Error in saving configuration " ^ c)
d585 1
a585 1
		    (let val details = get_mode_details modeName
a588 2
		    handle NoModeDetailsFound m => 
		      warn_error ("Warning: Error in loading mode " ^ m))
d591 1
a591 1
	      (* XXX need some consistency checking once the whole file
a616 2
		    handle NoConfigDetailsFound c =>
		      warn_error ("Warning: Error in loading configuration " ^ c)
a628 2
		    handle NoConfigDetailsFound c =>
		      warn_error ("Warning: Error in loading configuration " ^ c)
a640 2
		    handle NoConfigDetailsFound c =>
		      warn_error ("Warning: Error in loading configuration " ^ c)
@


1.1.1.5
log
@[Bug #30071]
Improve save/load mechanism.
@
text
@a2 4
 *  Revision 1.1.1.4  1997/11/11  09:35:16  johnh
 *  [Bug #30071]
 *  Handling exceptions.
 *
a384 5
  fun separator arg = 
    (MLWorks.String.ordof arg = ord #" ") orelse
    (MLWorks.String.ordof arg = ord #"\013") orelse
    (MLWorks.String.ordof arg = ord #"\n");

d386 1
a386 7
    if i >= size s orelse separator arg then 
      i
    else
      find_space(s, i+1);

  fun ignore_spaces(arg as (s, i)) =
    if i >= size s orelse (not (separator arg)) then
d389 1
a389 1
      ignore_spaces(s, i+1);
a396 1
      | out (outstream, [h]) = MLWorks.IO.output (outstream, h ^ "\n")
d406 2
a407 2
	fun get_next name = 
	  let val i = ignore_spaces(name, 0)
d409 3
a411 7
	    if i >= size name then
	      ("","")
	    else
	      let val j = find_space(name, i)
	      in
		(substring(name, i, j-i), substring(name, j, (size name)-j))
	      end
a412 1

a414 1

d579 1
a579 1
                ["SourceDir", dir, nl] => sourcePath := (!sourcePath) @@ [dir]
d582 3
a584 3
			(tar, inTargetType tarType, conv mode, conv config) ::
			  (!targetDetails);
		     curTargets := (!curTargets) @@ [tar])
d587 3
a589 3
			(tar, inTargetType tarType, conv mode, conv config) ::
			  (!targetDetails);
		     disTargets := (!disTargets) @@ [tar])
d591 1
a591 1
		    (modes := (!modes) @@ [name];
d615 1
a615 1
		    (configs := (!configs) @@ [name];
d633 1
a633 1
					     source = source @@ [dir],
d668 1
a668 1
	      | ["LocationsPath", dir, nl] => libraryPath := (!libraryPath) @@ [dir]
@


1.1.1.6
log
@[Bug #30071]
Made getProjectName return an option type; removed setProjectName;
removed old comments.
Added getProjectDir.
@
text
@a2 4
 *  Revision 1.1.1.5  1997/11/24  16:29:40  johnh
 *  [Bug #30071]
 *  Improve save/load mechanism.
 *
d22 1
a22 2
require "../basis/__list";
require "../system/__os";
d29 1
d41 7
d65 7
d84 7
d102 1
a102 1
    {projectName:	string option ref,
d112 1
a112 1
    PROJECT_FILE {projectName = ref NONE, 
a275 1
      projectName := NONE;
a297 7
  fun getProjectDir () =
    case getProjectName ()
    of SOME file =>
      OS.Path.dir file
    |  NONE =>
      OS.Path.currentArc

d337 7
d698 1
d709 1
a709 1
	projectName := SOME filename;
d720 1
a720 2
	initialize();
        projectName := SOME filename;
@


1.1.1.7
log
@[Bug #30071]
Use ProfFile.getProjectName returning SOME "" to mean new project created.
@
text
@a2 6
 *  Revision 1.1.1.6  1997/11/28  16:41:48  daveb
 *  [Bug #30071]
 *  Made getProjectName return an option type; removed setProjectName;
 *  removed old comments.
 *  Added getProjectDir.
 *
d259 1
a259 2
      (* SOME "" is used here to indicate a new project has been created *)
      projectName := SOME "";  
@


1.1.1.8
log
@[Bug #30071]
Fixing return value of getProjectDir when projectName is SOME "".
@
text
@a2 4
 *  Revision 1.1.1.7  1997/12/01  14:28:08  johnh
 *  [Bug #30071]
 *  Use ProfFile.getProjectName returning SOME "" to mean new project created.
 *
d290 5
a294 4
    case getProjectName () 
    of SOME "" 	 => OS.FileSys.getDir()
     | SOME file => OS.Path.dir file
     | NONE 	 => OS.FileSys.getDir()
@


1.1.1.9
log
@[Bug #30071]
Fix problem with saving and loading empty locations.
@
text
@a2 4
 *  Revision 1.1.1.8  1997/12/02  16:03:30  johnh
 *  [Bug #30071]
 *  Fixing return value of getProjectDir when projectName is SOME "".
 *
a438 2
    fun outSpace s = if s = "" then "___" else s

d448 1
d454 2
a455 2
			   outSpace mode, 
			   outSpace config])
d517 1
d519 1
a519 1
	  out (outstream, ["ConfigLocations", name, outSpace objLoc, outSpace binLoc])
d549 2
a550 2
        out (outstream, ["LocationsObj", outSpace (!objectsLoc)]);
        out (outstream, ["LocationsBin", outSpace (!binariesLoc)])
d685 2
a686 2
	      | ["LocationsObj", loc, nl] => objectsLoc := conv loc
	      | ["LocationsBin", loc, nl] => binariesLoc := conv loc
@


1.1.1.10
log
@[Bug #30071]
Ensured that stored projectNames are always absolute path names.
@
text
@a2 4
 *  Revision 1.1.1.9  1997/12/03  10:37:48  johnh
 *  [Bug #30071]
 *  Fix problem with saving and loading empty locations.
 *
d704 1
a704 2
	val abs_name = OS.Path.mkAbsolute (filename, OS.FileSys.getDir ())
        val outstream = MLWorks.IO.open_out abs_name
d706 1
a706 1
	projectName := SOME abs_name;
d715 1
a715 2
	val abs_name = OS.Path.mkAbsolute (filename, OS.FileSys.getDir ())
	val instream = MLWorks.IO.open_in abs_name
d718 1
a718 1
        projectName := SOME abs_name;
@


1.1.1.11
log
@[Bug #30071]
Made project file store all paths in Unix path format, for portability.
Added conversions to local path format in the appropriate places.
Added diagnostics.
@
text
@a2 4
 *  Revision 1.1.1.10  1997/12/03  17:14:06  daveb
 *  [Bug #30071]
 *  Ensured that stored projectNames are always absolute path names.
 *
a47 1
require "^.utils.diagnostic";
a52 1
  structure Diagnostic: DIAGNOSTIC
a57 7
  val _ = Diagnostic.set 0

  fun diagnostic (level, output_function) =
    Diagnostic.output
      level
      (fn verbosity => output_function verbosity)

a276 1
      diagnostic (1, fn _ => ["Initializing project file info"]);
d303 3
a305 9
    of SOME "" 	 => 
      (diagnostic (2, fn _ => ["Project Name is empty"]);
       OS.FileSys.getDir())
     | SOME file => 
      (diagnostic (2, fn _ => ["Project Name is ", file]);
       OS.Path.dir file)
     | NONE 	 => 
      (diagnostic (2, fn _ => ["Project Name is not set"]);
       OS.FileSys.getDir())
d522 1
a522 5
	  app
            (fn s =>
               out
                 (outstream, ["ConfigSource", name, OS.Path.toUnixPath s]))
            sPath
d524 1
a524 5
	  app
            (fn l =>
               out
                 (outstream, ["ConfigLibrary", name, OS.Path.toUnixPath l]))
            lPath
d527 1
a527 4
	  out (outstream,
               ["ConfigLocations", name, 
                outSpace (OS.Path.toUnixPath objLoc), 
                outSpace (OS.Path.toUnixPath binLoc)])
d556 3
a558 9
        app 
          (fn s => out (outstream, ["LocationsPath", OS.Path.toUnixPath s]))
          (!libraryPath);
        out
          (outstream,
           ["LocationsObj", outSpace (OS.Path.toUnixPath (!objectsLoc))]);
        out
          (outstream,
           ["LocationsBin", outSpace (OS.Path.toUnixPath (!binariesLoc))])
d603 1
a603 2
                ["SourceDir", dir, nl] =>
                    sourcePath := (!sourcePath) @@ [OS.Path.fromUnixPath dir]
d656 5
a660 6
		      modify_config_details 
                        {name = name,
			 source = source @@ [OS.Path.fromUnixPath dir],
			 library = library,
			 objects = objects,
			 bins = bins}
d670 5
a674 6
		      modify_config_details
                        {name = name,
			 source = source,
			 library = library @@ [OS.Path.fromUnixPath dir],
			 objects = objects,
			 bins = bins}
d684 5
a688 6
		      modify_config_details
                        {name = name,
			 source = source,
			 library = library,
			 objects = OS.Path.fromUnixPath (conv newObjects),
			 bins = OS.Path.fromUnixPath (conv newBins)}
d692 3
a694 6
	      | ["LocationsPath", dir, nl] => 
                  libraryPath := (!libraryPath) @@ [OS.Path.fromUnixPath dir]
	      | ["LocationsObj", loc, nl] =>
                  objectsLoc := OS.Path.fromUnixPath (conv loc)
	      | ["LocationsBin", loc, nl] => 
                  binariesLoc := OS.Path.fromUnixPath (conv loc)
d708 1
a708 2
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, OS.FileSys.getDir ())
a711 1
        diagnostic (2, fn _ => ["Project saved to ", abs_name]);
d720 1
a720 2
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, OS.FileSys.getDir ())
a724 1
        diagnostic (2, fn _ => ["Project opened from ", abs_name]);
@


1.1.1.12
log
@[Bug #30071]
Add about information.
@
text
@a2 6
 *  Revision 1.1.1.11  1997/12/23  16:36:11  daveb
 *  [Bug #30071]
 *  Made project file store all paths in Unix path format, for portability.
 *  Added conversions to local path format in the appropriate places.
 *  Added diagnostics.
 *
a114 4
  type about_refs = 
    {description:	string ref,
     version:		string ref}

d121 1
a121 2
     locations:		locations,
     about:		about_refs}
a127 3
		  about =
			{description = ref "",
			 version = ref ""},
a280 17
  fun getAboutInfo () = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      (!description, !version)
    end

  fun setAboutInfo (descStr, verStr) = 
    let
      val PROJECT_FILE {about, ...} = project_file
      val {description, version} = about
    in
      description := descStr;
      version := verStr
    end

d284 1
a284 1
			modes, configs, locations, about} = project_file
a288 1
      val {description, version} = about
a292 2
      description := "";
      version := "";
a597 11
    fun saveAboutInfo outstream = 
      let
	val PROJECT_FILE {about, ...} = project_file
	val {description, version} = about
      in
	out (outstream, ["!!!", !description]);
	out (outstream, ["!!!", !version]);
	out (outstream, ["Description", !description]);
	out (outstream, ["Version", !version])
      end

d599 1
a599 2
      (saveAboutInfo outstream;
       saveSourcePath outstream;
d631 1
a631 4
	    fun remove_nl (nl :: rest) = rev rest
	      | remove_nl l = l
	    val PROJECT_FILE {sourcePath, targets, modes, 
			      configs, locations, about, ...} = 
a636 1
	    val {description, version} = about
d640 1
a640 7
	        ("Description" :: descStrList) => 
		    description := foldr (fn (a, b) => a ^ " " ^ b) "" 
			(remove_nl (rev descStrList))
	      | ("Version" :: verStrList) => 
		    version := foldr (fn (a, b) => a ^ " " ^ b) "" 
			(remove_nl (rev verStrList))
              | ["SourceDir", dir, nl] =>
a738 2

	      | ("!!!" :: rest) => ()
@


1.1.1.13
log
@[Bug #30071]
Add directory location for different modes.
Remove objects location from configurations.
@
text
@a2 4
 *  Revision 1.1.1.12  1998/01/06  15:46:30  johnh
 *  [Bug #30071]
 *  Add about information.
 *
a88 1
     location:					string ref,
d107 3
a109 1
     library: string list}
d239 1
a239 1
	({name = testName, source = s, library = l},
d250 3
a252 1
       library = l} :: others
a548 1
	    out (outstream, ["ModeLocation", name, !(#location modeRec)]);
d588 6
d599 2
a600 1
	    save_library (name, #library configRec)
a710 1
				     location = ref name,
a719 7
	      | ["ModeLocation", modeName, loc, nl] =>
		    (let val {name, location, ...} = get_mode_details modeName
		    in
		      location := loc
		    end
		    handle NoModeDetailsFound m => 
		      warn_error ("Warning: Error in loading mode " ^ m))
d736 3
a738 1
				       library = []} :: (!configDetails))
d746 1
a746 1
		    val {name, source, library} = 
d753 3
a755 1
			 library = library}
d761 16
a776 1
		    val {name, source, library} = 
d783 3
a785 1
			 library = library @@ [OS.Path.fromUnixPath dir]}
@


1.1.1.14
log
@[Bug #30071]
Introducing subprojects.
@
text
@a2 5
 *  Revision 1.1.1.13  1998/01/08  15:17:14  johnh
 *  [Bug #30071]
 *  Add directory location for different modes.
 *  Remove objects location from configurations.
 *
a59 1
require "../basis/__text_io";
a80 11
(*
  fun diagnostic (level, output_fn) = 
    let 
      val p_list = output_fn ()
      fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\t")
    in
      app P p_list;
      MLWorks.IO.output (MLWorks.IO.terminal_out, "\n")
    end
*)

a130 1
     subprojects:	string list ref,
d137 1
a137 1
  fun warn_error s = TextIO.output (TextIO.stdErr, s ^ "\n")
d139 1
a139 2

  fun mk_empty_proj () = 
a141 1
		  subprojects = ref [],
a161 2
  val project_file = mk_empty_proj ()

d315 1
a315 1
      val PROJECT_FILE {projectName, sourcePath, subprojects, targets, 
a328 1
      subprojects := [];
a368 7
  fun getSubprojects () = 
    let 
      val PROJECT_FILE {subprojects, ...} = project_file
    in
      (!subprojects)
    end

a407 7
  fun setSubprojects proj_list = 
    let 
      val PROJECT_FILE {subprojects, ...} = project_file
    in
      subprojects := proj_list
    end

d468 2
a469 2
    fun out (outstream, []) = TextIO.output (outstream, "\n")
      | out (outstream, [h]) = TextIO.output (outstream, h ^ "\n")
d471 1
a471 1
	  (TextIO.output (outstream, h ^ " ");
d478 1
a478 1
	val in_line = TextIO.inputLine instream
a506 3
    fun saveSubprojects outstream =
      (map (fn s => out (outstream, ["Subproject", s])) (getSubprojects()))

a640 1
       saveSubprojects outstream;
d646 1
a646 1
    fun load_from_stream (proj, instream) = 
d674 3
a676 2
	    val PROJECT_FILE {sourcePath, subprojects, targets, modes, 
			      configs, locations, about, ...} = proj
a692 2
              | ["Subproject", proj, nl] =>
                    subprojects := (!subprojects) @@ [OS.Path.fromUnixPath proj]
d780 2
a781 2
	      | s => app (fn s => TextIO.output (TextIO.stdErr, s ^ "\n")) s;
	    if (not (TextIO.endOfStream instream)) then get_line () else ()
a788 68
    fun getSubProjects filename = 
      let
        fun getFileName proj = 
          if OS.Path.isRelative proj then 
            OS.Path.mkCanonical (OS.Path.mkAbsolute (proj, OS.Path.dir filename))
          else
            OS.Path.mkCanonical proj

	val instream = TextIO.openIn (OS.Path.mkCanonical filename)

	fun get_subprojs istream = 
	  let 
	    val theList = 
	      if (not (TextIO.endOfStream istream)) then
	        ins istream 
	      else []

	    fun add_file (fl, addList) = 
	      let val fname = getFileName fl
	      in
		if isSome (List.find (fn f => f=fname) addList) then addList
		else fname :: addList
	      end
	  in
	    case theList of
	      ["Subproject", proj, nl] => 
		add_file (proj, (get_subprojs istream) @@ (getSubProjects (getFileName proj)))
	    | [] => add_file (filename, [])
	    | _ => get_subprojs istream
	  end

	val subprojects = get_subprojs instream
	handle exn => (TextIO.closeIn instream; raise exn)
      in
	TextIO.closeIn instream;
	subprojects
      end (* getSubProjects *)

    (* getSubTargets assumes given filename is canonical absolute *)
    fun getSubTargets filename = 
      let
	val instream = TextIO.openIn filename

	fun get_sub_targets stream = 
	  let 
	    val theList = 
	      if (not (TextIO.endOfStream stream)) then
	        ins stream 
	      else []

	    fun add_target (t, tList) = 
	      if isSome (List.find (fn f=>f=t) tList) then tList
	      else t :: tList
	  in
	    case theList of
	      ["Target", tar, tarType, mode, config, nl] => 
		add_target (tar, get_sub_targets stream)
	    | [] => []
	    | _ => get_sub_targets stream
	  end

	val sub_targets = get_sub_targets instream
	handle exn => (TextIO.closeIn instream; raise exn)
      in
	TextIO.closeIn instream;
	sub_targets
      end (* getSubTargets *)

d793 2
a794 2
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
        val outstream = TextIO.openOut abs_name
d799 2
a800 2
        handle exn => (TextIO.closeOut outstream; raise exn);
        TextIO.closeOut outstream
d807 2
a808 2
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
	val instream = TextIO.openIn abs_name
d813 3
a815 35
        load_from_stream (project_file, instream)
        handle exn => (TextIO.closeIn instream; raise exn)
        TextIO.closeIn instream
      end

    fun peek_project filename = 
      let 
	val new_proj = mk_empty_proj()
	val PROJECT_FILE {projectName, ...} = new_proj
        val local_name = OS.Path.fromUnixPath filename
	val abs_name = OS.Path.mkAbsolute (local_name, getProjectDir())
	val instream = TextIO.openIn abs_name

        val PROJECT_FILE {sourcePath, subprojects, targets, 
			  configs, locations, ...} = new_proj
	val {curTargets, disTargets, ...} = targets
	val {configDetails, currentConfig, ...} = configs
	val {libraryPath, objectsLoc, binariesLoc} = locations
      in
        projectName := SOME abs_name;
        diagnostic (2, fn _ => ["Project opened from ", abs_name]);
        load_from_stream (new_proj, instream)
        handle exn => (TextIO.closeIn instream; raise exn)
        TextIO.closeIn instream;
	{dir = OS.Path.dir abs_name,
	 sourcePath = !sourcePath,
	 curTargets = !curTargets,
	 disTargets = !disTargets,
	 subprojects = !subprojects,
	 libraryPath = !libraryPath,
	 objectsLoc = !objectsLoc,
	 binariesLoc = !binariesLoc,
	 currentConfig = !currentConfig, 
	 configDetails = !configDetails}

@


1.1.1.15
log
@[Bug #30071]
Handle exceptions.
@
text
@a2 4
 *  Revision 1.1.1.14  1998/01/26  15:19:06  johnh
 *  [Bug #30071]
 *  Introducing subprojects.
 *
d155 2
a156 1
  fun warn_error s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\n")
d562 1
a562 5
	  let 
	    val (n, tarType, mode, config) = get_target_details name
	    handle NoTargetDetailsFound t => 
	      (warn_error ("Warning: Error in saving target " ^ t);
	       (name, EXECUTABLE, "", ""))
a575 13
    fun newModeDetails name = 
      {name = name,
       location = ref name,
       generate_interruptable_code = ref false,
       generate_interceptable_code = ref false,
       generate_debug_info = ref false,
       generate_variable_debug_info = ref false,
       optimize_leaf_fns = ref false,
       optimize_tail_calls = ref false,
       optimize_self_tail_calls = ref false,
       mips_r4000 = ref false,
       sparc_v7 = ref false}

a587 3
	    handle NoModeDetailsFound m => 
	      (warn_error ("Warning: Error in saving mode " ^ m);
	       newModeDetails m)
d631 1
a631 5
	  let 
	    val configRec = get_config_details name
	    handle NoConfigDetailsFound c => 
	      (warn_error ("Warning: Error in saving configuration " ^ c);
	       {name=name, library=[], source=[]})
d747 11
a757 1
		     modeDetails := (newModeDetails name) :: (!modeDetails))
d759 1
a759 2
		    (let 
		       val {name, location, ...} = get_mode_details modeName
a790 3
		    handle NoConfigDetailsFound c =>
		      (warn_error ("Warning: Error in loading configuration " ^ c);
			{library = [], name = configName, source = []})
a803 3
		    handle NoConfigDetailsFound c =>
		      (warn_error ("Warning: Error in loading configuration " ^ c);
			{library = [], name = configName, source = []})
d822 1
a822 1
	      | s => app warn_error s;
@
