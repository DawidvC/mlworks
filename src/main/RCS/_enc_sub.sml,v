head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.11
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.17.8.1.1.1.1
	MLWorks_workspace_97:1.17.10
	MLWorks_dt_wizard:1.17.9
	MLWorks_11c0_1997_09_09:1.17.8.1.1.1
	MLWorks_10r3:1.17.8.1.3
	MLWorks_10r2_551:1.17.8.1.2
	MLWorks_11:1.17.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.8.1
	MLWorks_20m0_1997_06_20:1.17
	MLWorks_1_0_r2c2_1997_06_14:1.17.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.8
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.6.1.1
	MLWorks_gui_1996_12_18:1.17.7
	MLWorks_1_0_Win32_1996_12_17:1.17.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.4.1
	MLWorks_1_0_Irix_1996_11_28:1.17.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.5
	MLWorks_1_0_Unix_1996_11_14:1.17.4
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.17
	MLWorks_Beta_1996_06_07:1.17
	MLWorks_Beta_1996_06_06:1.17
	MLWorks_Beta_1996_06_05:1.17
	MLWorks_Beta_1996_06_03:1.17
	MLWorks_Beta_1996_05_31:1.17
	MLWorks_Beta_1996_05_30:1.17
	ML_beta_release_12/08/94:1.14
	ML_beta_release_03/08/94:1.14
	ML_revised_beta_release_25/05/94:1.14
	ML_final_beta_release_02/03/94:1.13
	mlworks-28-01-1994:1.12
	Release:1.11
	mlworks-beta-01-09-1993:1.11
	MLWorks-1-0-4-29/01/1993:1.10
	MLWorks-1-0-3-21/12/1992:1.9
	MLWorks-1-0-2-15/12/1992:1.9
	MLWorks-1-0-1-04/12/1992:1.9
	checkpoint_17_08_92:1.5;
locks; strict;
comment	@ * @;


1.17
date	96.03.28.11.10.59;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1
	1.17.7.1
	1.17.8.1
	1.17.9.1
	1.17.10.1
	1.17.11.1;
next	1.16;

1.16
date	96.02.22.14.02.04;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.03.24.16.06.24;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	94.05.05.13.49.40;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.12.03.14.09.56;	author nosa;	state Exp;
branches;
next	1.12;

1.12
date	93.09.22.10.01.12;	author nosa;	state Exp;
branches;
next	1.11;

1.11
date	93.07.19.11.27.12;	author nosa;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	92.12.07.17.38.24;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.10.01.11.38.05;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.09.21.10.44.56;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.09.08.22.40.42;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.28.15.25.32;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.08.06.16.20.32;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.07.24.15.38.12;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.03.19.14.34.17;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.03.16.16.21.52;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.01.22.16.28.10;	author jont;	state Exp;
branches;
next	;

1.11.1.1
date	93.07.19.11.27.12;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.18.26;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.08.19;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.26.33;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.11.14.12.51.53;	author hope;	state Exp;
branches
	1.17.4.1.1.1;
next	;

1.17.4.1.1.1
date	96.11.28.15.02.54;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	96.11.22.18.11.05;	author hope;	state Exp;
branches;
next	;

1.17.6.1
date	96.12.17.17.49.38;	author hope;	state Exp;
branches
	1.17.6.1.1.1;
next	;

1.17.6.1.1.1
date	97.02.24.11.39.48;	author hope;	state Exp;
branches;
next	;

1.17.7.1
date	96.12.18.09.43.43;	author hope;	state Exp;
branches;
next	;

1.17.8.1
date	97.05.12.10.36.12;	author hope;	state Exp;
branches
	1.17.8.1.1.1
	1.17.8.1.2.1
	1.17.8.1.3.1;
next	;

1.17.8.1.1.1
date	97.07.28.18.21.53;	author daveb;	state Exp;
branches
	1.17.8.1.1.1.1.1;
next	;

1.17.8.1.1.1.1.1
date	97.10.07.11.47.33;	author jkbrook;	state Exp;
branches;
next	;

1.17.8.1.2.1
date	97.09.08.17.15.17;	author daveb;	state Exp;
branches;
next	;

1.17.8.1.3.1
date	97.09.09.14.11.09;	author daveb;	state Exp;
branches;
next	;

1.17.9.1
date	97.09.10.19.27.11;	author brucem;	state Exp;
branches;
next	;

1.17.10.1
date	97.09.11.20.57.11;	author daveb;	state Exp;
branches;
next	;

1.17.11.1
date	99.04.01.17.58.15;	author daveb;	state Exp;
branches;
next	;


desc
@Sub functions for the use of encapsulate
@


1.17
log
@Adding where type clause
@
text
@(* _enc_sub.sml the functor *)
(*
$Log: _enc_sub.sml,v $
 * Revision 1.16  1996/02/22  14:02:04  jont
 * Replacing Map with NewMap
 *
 * Revision 1.15  1995/03/24  16:06:24  matthew
 * Use Stamp instead of Tyname_id etc.
 *
Revision 1.14  1994/05/05  13:49:40  daveb
(DataTypes.META_OVERLOADED now has extra arguments.

Revision 1.13  1993/12/03  14:09:56  nosa
TYCON' for type function functions in lambda code for Modules Debugger.

Revision 1.12  1993/09/22  10:01:12  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.11  1993/07/19  11:27:12  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

Revision 1.10  1992/12/07  17:38:24  jont
Anel's last changes

Revision 1.9  1992/10/01  11:38:05  jont
Improved map_eq and type_same

Revision 1.8  1992/09/21  10:44:56  clive
Changed hashtables to a single structure implementation

Revision 1.7  1992/09/08  22:40:42  jont
Allowed NULLTYPES in valenvs, these are inserted by nameset copying

Revision 1.6  1992/08/28  15:25:32  davidt
Now uses NewMap.eq instead of NewMap.to_list (which should
have been NewMap.to_list_ordered anyway!).

Revision 1.5  1992/08/06  16:20:32  jont
Anel's changes to use NewMap instead of Map

Revision 1.5  1992/08/06  16:20:32  jont
Anel's changes to use NewMap instead of Map

Revision 1.4  1992/07/24  15:38:12  clive
Use of new hash tables, removed some concatenation and compression of integers in encapsulator

Revision 1.3  1992/03/19  14:34:17  jont
Added some more hashtables

Revision 1.2  1992/03/16  16:21:52  jont
Added hash tables for encoding of common types (fun, rec, cons) and also
metatynames.

Revision 1.1  1992/01/22  16:28:10  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/diagnostic";
require "../utils/lists";
require "../utils/crash";
require "../typechecker/datatypes";
require "enc_sub";

functor Enc_Sub(
  structure DataTypes : DATATYPES where type Stamp = int
  structure Diagnostic : DIAGNOSTIC
  structure Lists : LISTS
  structure Crash : CRASH
) : ENC_SUB =
struct
  structure Diagnostic = Diagnostic
  structure DataTypes = DataTypes
  structure NewMap = DataTypes.NewMap

  fun pair_eq(first_eq, second_eq) ((a, b), (a', b')) =
    first_eq(a, a') andalso second_eq(b, b')

  fun list_eq eqfn (lista, listb) =
    let
      fun list_subeq([], []) = true
	| list_subeq (x :: xs, y :: ys) =
	  eqfn(x, y) andalso list_subeq (xs, ys)
	| list_subeq _ = false
    in
      list_subeq(lista, listb)
    end

  fun map_eq (map1, map2) = NewMap.eq type_same (map1, map2)
(*
    list_eq (pair_eq(op=, type_same)) (Map.assoc map1, Map.assoc map2)
*)

  and type_same(DataTypes.METATYVAR arg, DataTypes.METATYVAR arg') =
    arg = arg'
  | type_same(DataTypes.META_OVERLOADED arg, DataTypes.META_OVERLOADED arg') =
    arg = arg'
  | type_same(DataTypes.TYVAR arg, DataTypes.TYVAR arg') =
    arg = arg'
  | type_same(DataTypes.METARECTYPE arg, DataTypes.METARECTYPE arg') =
    arg = arg'
  | type_same(DataTypes.RECTYPE arg, DataTypes.RECTYPE arg') =
    map_eq (arg, arg')
  | type_same(DataTypes.FUNTYPE(ty1, ty2), DataTypes.FUNTYPE(ty1', ty2')) =
    type_same(ty1, ty1') andalso type_same(ty2, ty2')
  | type_same(DataTypes.CONSTYPE(l, t), DataTypes.CONSTYPE(l', t')) =
    tyname_same(t, t') andalso list_eq type_same (l, l')
  | type_same(DataTypes.DEBRUIJN arg, DataTypes.DEBRUIJN arg') =
    ((fn ty=>(#1(ty),#2(ty),#3(ty)))arg) = ((fn ty=>(#1(ty),#2(ty),#3(ty)))arg')
  | type_same(DataTypes.NULLTYPE, DataTypes.NULLTYPE) = true
  | type_same _ = false

  and tyname_same(DataTypes.TYNAME{1=id, ...}, DataTypes.TYNAME{1=id', ...}) =
    id = id'
  | tyname_same(DataTypes.METATYNAME arg, DataTypes.METATYNAME arg') =
    arg = arg'
  | tyname_same _ = false

  fun tyfun_same(DataTypes.TYFUN(ty1, i1), DataTypes.TYFUN(ty2, i2)) =
    type_same(ty1, ty2) andalso i1 = i2
  | tyfun_same(DataTypes.ETA_TYFUN tyname, DataTypes.ETA_TYFUN tyname') =
    tyname_same(tyname, tyname')
  | tyfun_same(DataTypes.NULL_TYFUN (id,_), DataTypes.NULL_TYFUN (id',_)) = id = id'
  | tyfun_same _ = false

  fun type_from_scheme(DataTypes.SCHEME(_, (ty,_))) = ty
  | type_from_scheme(DataTypes.UNBOUND_SCHEME (ty,_)) = ty
  | type_from_scheme _ = Crash.impossible"type_from_scheme"

  fun type_same_sort(scheme1, scheme2) =
    case (type_from_scheme scheme1, type_from_scheme scheme2) of
      (DataTypes.FUNTYPE _, DataTypes.FUNTYPE _) => true
    | (DataTypes.CONSTYPE _, DataTypes.CONSTYPE _) => true
    | _ => false

  fun tyname_valenv_same(DataTypes.VE(_, ve1), DataTypes.VE(_, ve2)) =
    NewMap.eq type_same_sort (ve1, ve2)

  fun type_hash(DataTypes.METATYVAR(ref(i, ty,_), _, _)) =
    3 + i + type_hash ty
  | type_hash(DataTypes.META_OVERLOADED {1=ref ty,...}) = 5 + type_hash ty
  | type_hash(DataTypes.TYVAR(ref (i,_,_), tyvar)) = 7 + i
  | type_hash(DataTypes.METARECTYPE(ref(i, _, ty, _, _))) =
    11 + i + type_hash ty
  | type_hash(DataTypes.RECTYPE(lab_ty_map)) =
    NewMap.fold
    (fn (i, _, ty) => i + type_hash ty)
    (13, lab_ty_map)
  | type_hash(DataTypes.FUNTYPE(ty1, ty2)) = 17 + type_hash ty1 + type_hash ty2
  | type_hash(DataTypes.CONSTYPE(ty_list, tyname)) =
    Lists.reducel
    (fn (i, ty) => i + type_hash ty)
    (tyname_hash tyname + 19, ty_list)
  | type_hash(DataTypes.DEBRUIJN(i, b1, b2,_)) = 23 + i
  | type_hash(DataTypes.NULLTYPE) = 47
    
  and tyname_hash(DataTypes.TYNAME{1=tyname_id, ...}) =
    29 + tyname_id
  | tyname_hash(DataTypes.METATYNAME{1 = ref tyfun, ...}) =
    31 + tyfun_hash tyfun
  and tyfun_hash(DataTypes.TYFUN(ty, i)) =
    41 + type_hash ty + i
  | tyfun_hash(DataTypes.ETA_TYFUN tyname) = 43 + tyname_hash tyname
  | tyfun_hash(DataTypes.NULL_TYFUN (id,_)) = 47 + id

  fun symbol_hash symbol = size(DataTypes.Ident.Symbol.symbol_name symbol)

  fun valid_hash(DataTypes.Ident.VAR sy) = symbol_hash sy
  | valid_hash(DataTypes.Ident.CON sy) = symbol_hash sy
  | valid_hash(DataTypes.Ident.EXCON sy) = symbol_hash sy
  | valid_hash(_) = Crash.impossible "TYCON':valid_hash:enc_sub"

  fun tyname_valenv_hash(DataTypes.VE(_, amap)) =
    let
      val assoc = NewMap.to_list_ordered amap
    in
      Lists.reducel
      (fn (i, (valid, typescheme)) =>
       i + valid_hash valid +
       (case type_from_scheme typescheme of
	  DataTypes.FUNTYPE _ => 3
	| DataTypes.CONSTYPE _ => 5
	| DataTypes.NULLTYPE => 5 (* This one from modified signatures *)
	| _ => Crash.impossible"tyname_valenv_hash"))
      (Lists.length assoc, assoc)
    end

end
@


1.17.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.8.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.17.8.1  1997/05/12  10:36:12  hope
 * branched from 1.17
 *
@


1.17.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.17.8.1  1997/05/12  10:36:12  hope
 * branched from 1.17
 *
@


1.17.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.17.8.1  1997/05/12  10:36:12  hope
 * branched from 1.17
 *
@


1.17.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.17.8.1.1.1  1997/07/28  18:21:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17.7.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.6.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.6.1.1.1
log
@branched from 1.17.6.1
@
text
@a3 3
 * Revision 1.17.6.1  1996/12/17  17:49:38  hope
 * branched from 1.17
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.4.1.1.1
log
@branched from 1.17.4.1
@
text
@a3 3
 * Revision 1.17.4.1  1996/11/14  12:51:53  hope
 * branched from 1.17
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 3
 * Revision 1.17  1996/03/28  11:10:59  matthew
 * Adding where type clause
 *
@


1.16
log
@Replacing Map with NewMap
@
text
@d4 3
d68 1
a68 1
  structure DataTypes : DATATYPES
a71 1
  sharing type DataTypes.Stamp = int
@


1.15
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
a73 1
  structure Map = DataTypes.Mapping
d89 2
a90 1
  fun map_eq (map1, map2) =
d92 1
d146 3
a148 3
    Lists.reducel
    (fn (i, (_, ty)) => i + type_hash ty)
    (13, Map.assoc lab_ty_map)
@


1.14
log
@(DataTypes.META_OVERLOADED now has extra arguments.
@
text
@d4 3
d66 1
d154 1
a154 1
    29 + DataTypes.Tyname_id.tyname_id tyname_id
d160 1
a160 1
  | tyfun_hash(DataTypes.NULL_TYFUN (id,_)) = 47 + DataTypes.Tyfun_id.tyfun_id id
@


1.13
log
@TYCON' for type function functions in lambda code for Modules Debugger.
@
text
@d4 3
d133 1
a133 1
  | type_hash(DataTypes.META_OVERLOADED(ref ty,_)) = 5 + type_hash ty
@


1.12
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d160 1
@


1.11
log
@Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.
@
text
@d4 4
d95 1
a95 1
    arg = arg'
d112 2
a113 2
  fun type_from_scheme(DataTypes.SCHEME(_, ty)) = ty
  | type_from_scheme(DataTypes.UNBOUND_SCHEME ty) = ty
d125 1
a125 1
  fun type_hash(DataTypes.METATYVAR(ref(i, ty), _, _)) =
d128 1
a128 1
  | type_hash(DataTypes.TYVAR(ref (i), tyvar)) = 7 + i
d140 1
a140 1
  | type_hash(DataTypes.DEBRUIJN(i, b1, b2)) = 23 + i
@


1.11.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.11  1993/07/19  11:27:12  nosa
Changed type of constructor NULL_TYFUN for value printing in
local and closure variable inspection in the debugger.

@


1.10
log
@Anel's last changes
@
text
@d4 3
d105 1
a105 1
  | tyfun_same(DataTypes.NULL_TYFUN id, DataTypes.NULL_TYFUN id') = id = id'
d124 1
a124 1
  | type_hash(DataTypes.TYVAR(ref i, tyvar)) = 7 + i
d146 1
a146 1
  | tyfun_hash(DataTypes.NULL_TYFUN id) = 47 + DataTypes.Tyfun_id.tyfun_id id
@


1.9
log
@Improved map_eq and type_same
@
text
@d4 3
d120 1
a120 1
  | type_hash(DataTypes.META_OVERLOADED(ref ty)) = 5 + type_hash ty
@


1.8
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d60 3
a62 4
      | list_subeq ([], _) = false
      | list_subeq (_, []) = false
      | list_subeq (x :: xs, y :: ys) =
	eqfn(x, y) andalso list_subeq (xs, ys)
d67 2
a68 7
  fun map_eq (first_eq, second_eq) (map1, map2) =
    let
      val map1 = Map.assoc map1
      val map2 = Map.assoc map2
    in
      list_eq (pair_eq(first_eq, second_eq)) (map1, map2)
    end
d70 1
a70 1
  fun type_same(DataTypes.METATYVAR arg, DataTypes.METATYVAR arg') =
d79 1
a79 1
    map_eq (op=, type_same) (arg, arg')
@


1.7
log
@Allowed NULLTYPES in valenvs, these are inserted by nameset copying
@
text
@d4 3
a35 1
require "../utils/_newhashtable";
a164 90


  structure FuntypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = DataTypes.Type
      type Value = int
      val size = 4000
      val modval = 32768
      val hash = type_hash
      val eq = type_same)

  structure ConstypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = DataTypes.Type
      type Value = int
      val size = 4000
      val modval = 32768
      val hash = type_hash
      val eq = type_same)

  structure RectypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = DataTypes.Type
      type Value = int
      val size = 4000
      val modval = 32768
      val hash = type_hash
      val eq = type_same)

  structure DecFuntypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = int
      type Value = DataTypes.Type
      val size = 4000
      val modval = 4096
      fun hash i = i
      val eq = op = : int * int -> bool)

  structure DecConstypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = int
      type Value = DataTypes.Type
      val size = 4000
      val modval = 4096
      fun hash i = i
      val eq = op = : int * int -> bool)

  structure DecRectypeHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = int
      type Value = DataTypes.Type
      val size = 4000
      val modval = 4096
      fun hash i = i
      val eq = op = : int * int -> bool)

  structure TynameHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = DataTypes.Tyname
      type Value = int
      val size = 4000
      val modval = 32768
      val hash = tyname_hash
      val eq = tyname_same)

  structure ValenvHashTable = 
    NewHashTable(
      structure Lists = Lists
      structure Crash = Crash
      type Key = DataTypes.Valenv
      type Value = int
      val size = 4000
      val modval = 32768
      val hash = tyname_valenv_hash
      val eq = tyname_valenv_same)

@


1.6
log
@Now uses NewMap.eq instead of NewMap.to_list (which should
have been NewMap.to_list_ordered anyway!).
@
text
@d4 4
d159 1
@


1.5
log
@Anel's changes to use NewMap instead of Map
@
text
@d7 3
d110 1
a110 2
    list_eq (pair_eq (DataTypes.Ident.valid_eq, type_same_sort)) 
    (NewMap.to_list ve1, NewMap.to_list ve2)
@


1.4
log
@Use of new hash tables, removed some concatenation and compression of integers in encapsulator
@
text
@d4 6
a23 1
require "../utils/map";
a32 1
  structure Map : MAP
a34 2

  sharing Map = DataTypes.Mapping
d39 2
d107 2
a108 1
    map_eq (DataTypes.Ident.valid_eq, type_same_sort) (ve1, ve2)
d145 1
a145 1
      val assoc = Map.assoc amap
@


1.3
log
@Added some more hashtables
@
text
@d4 3
a19 1
require "../utils/hashtable";
d21 1
a21 1
require "../utils/_hashtable";
d152 5
a156 2
  structure TypeHashSpec : HASHSPEC =
    struct
d162 1
a162 2
      val eq = type_same
    end
d164 26
a189 2
  structure DecTypeHashSpec : HASHSPEC =
    struct
d195 1
a195 2
      val eq = op = : int * int -> bool
    end
d197 26
a222 2
  structure TynameHashSpec : HASHSPEC =
    struct
d228 1
a228 2
      val eq = tyname_same
    end
d230 4
a233 2
  structure ValenvHashSpec : HASHSPEC =
    struct
d239 1
a239 2
      val eq = tyname_valenv_same
    end
a240 15
  structure FuntypeHashTable = HashTable(TypeHashSpec)

  structure ConstypeHashTable = HashTable(TypeHashSpec)

  structure RectypeHashTable = HashTable(TypeHashSpec)

  structure DecFuntypeHashTable = HashTable(DecTypeHashSpec)

  structure DecConstypeHashTable = HashTable(DecTypeHashSpec)

  structure DecRectypeHashTable = HashTable(DecTypeHashSpec)

  structure TynameHashTable = HashTable(TynameHashSpec)

  structure ValenvHashTable = HashTable(ValenvHashSpec)
@


1.2
log
@Added hash tables for encoding of common types (fun, rec, cons) and also
metatynames.
@
text
@d4 4
d18 1
d28 1
d90 13
d130 20
d180 10
d203 2
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d12 3
a17 1

d22 2
d76 79
@
