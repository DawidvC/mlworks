head	1.73;
access;
symbols
	MLW_daveb_inline_1_4_99:1.73.1
	MLWorks_21c0_1999_03_25:1.73
	MLWorks_20c1_1998_08_20:1.59
	MLWorks_20c0_1998_08_04:1.57
	MLWorks_20b2c2_1998_06_19:1.55
	MLWorks_20b2_Windows_1998_06_12:1.55
	MLWorks_20b1c1_1998_05_07:1.53
	MLWorks_20b0_1998_04_07:1.50
	MLWorks_20b0_1998_03_20:1.49
	MLWorks_20m2_1998_02_16:1.45
	MLWorks_20m1_1997_10_23:1.42
	MLWorks_11r1:1.37.1.2.1.1.1
	MLWorks_workspace_97:1.41.2
	MLWorks_dt_wizard:1.41.1
	MLWorks_11c0_1997_09_09:1.37.1.2.1.1
	MLWorks_10r3:1.37.1.2.3
	MLWorks_10r2_551:1.37.1.2.2
	MLWorks_11:1.37.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.37.1.2
	MLWorks_20m0_1997_06_20:1.41
	MLWorks_1_0_r2c2_1997_06_14:1.37.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.37.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.37.1
	MLWorks_BugFix_1997_04_24:1.37
	MLWorks_1_0_r2_Win32_1997_04_11:1.37
	MLWorks_1_0_r2_Unix_1997_04_04:1.37
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.36.3.1.1
	MLWorks_gui_1996_12_18:1.36.4
	MLWorks_1_0_Win32_1996_12_17:1.36.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.36.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.36.1.1
	MLWorks_1_0_Irix_1996_11_28:1.36.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.36.2
	MLWorks_1_0_Unix_1996_11_14:1.36.1
	MLWorks_Open_Beta2_1996_10_11:1.34.1
	MLWorks_License_dev:1.33.2
	MLWorks_1_open_beta_1996_09_13:1.33.1
	MLWorks_Open_Beta_1996_08_22:1.33
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30;
locks; strict;
comment	@ * @;


1.73
date	99.03.18.08.52.50;	author mitchell;	state Exp;
branches
	1.73.1.1;
next	1.72;

1.72
date	99.03.16.16.24.07;	author mitchell;	state Exp;
branches;
next	1.71;

1.71
date	99.03.16.12.42.42;	author mitchell;	state Exp;
branches;
next	1.70;

1.70
date	99.03.16.12.05.51;	author mitchell;	state Exp;
branches;
next	1.69;

1.69
date	99.03.15.12.40.39;	author mitchell;	state Exp;
branches;
next	1.68;

1.68
date	99.03.11.16.13.32;	author mitchell;	state Exp;
branches;
next	1.67;

1.67
date	99.03.10.14.33.37;	author mitchell;	state Exp;
branches;
next	1.66;

1.66
date	99.02.19.10.44.06;	author mitchell;	state Exp;
branches;
next	1.65;

1.65
date	99.02.18.10.44.14;	author mitchell;	state Exp;
branches;
next	1.64;

1.64
date	99.02.11.13.43.49;	author mitchell;	state Exp;
branches;
next	1.63;

1.63
date	99.02.09.09.50.01;	author mitchell;	state Exp;
branches;
next	1.62;

1.62
date	99.02.04.08.30.31;	author mitchell;	state Exp;
branches;
next	1.61;

1.61
date	99.02.02.16.01.07;	author mitchell;	state Exp;
branches;
next	1.60;

1.60
date	98.11.26.14.52.38;	author johnh;	state Exp;
branches;
next	1.59;

1.59
date	98.08.19.08.51.42;	author johnh;	state Exp;
branches;
next	1.58;

1.58
date	98.08.13.10.52.09;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	98.07.30.14.13.31;	author johnh;	state Exp;
branches;
next	1.56;

1.56
date	98.06.30.13.20.12;	author johnh;	state Exp;
branches;
next	1.55;

1.55
date	98.06.01.16.03.18;	author johnh;	state Exp;
branches;
next	1.54;

1.54
date	98.05.12.15.27.16;	author johnh;	state Exp;
branches;
next	1.53;

1.53
date	98.04.24.15.19.29;	author mitchell;	state Exp;
branches;
next	1.52;

1.52
date	98.04.22.15.13.34;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	98.04.03.14.16.14;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	98.03.24.10.38.24;	author johnh;	state Exp;
branches;
next	1.49;

1.49
date	98.03.16.14.54.38;	author johnh;	state Exp;
branches;
next	1.48;

1.48
date	98.03.16.12.22.18;	author johnh;	state Exp;
branches;
next	1.47;

1.47
date	98.02.26.11.35.34;	author johnh;	state Exp;
branches;
next	1.46;

1.46
date	98.02.19.08.57.05;	author mitchell;	state Exp;
branches;
next	1.45;

1.45
date	98.02.06.11.24.42;	author johnh;	state Exp;
branches;
next	1.44;

1.44
date	98.01.26.17.21.31;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	97.10.19.20.14.09;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	97.10.13.10.57.55;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	97.06.13.16.19.09;	author jkbrook;	state Exp;
branches
	1.41.1.1
	1.41.2.1;
next	1.40;

1.40
date	97.05.19.11.19.46;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	97.05.12.16.05.11;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	97.05.07.16.19.43;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	97.02.12.13.22.47;	author daveb;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	96.11.06.11.29.07;	author matthew;	state Exp;
branches
	1.36.1.1
	1.36.2.1
	1.36.3.1
	1.36.4.1;
next	1.35;

1.35
date	96.10.29.16.28.10;	author io;	state Exp;
branches;
next	1.34;

1.34
date	96.10.03.16.56.24;	author daveb;	state Exp;
branches
	1.34.1.1;
next	1.33;

1.33
date	96.08.14.15.52.35;	author daveb;	state Exp;
branches
	1.33.1.1
	1.33.2.1;
next	1.32;

1.32
date	96.07.04.15.16.20;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	96.07.04.08.55.38;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.04.30.17.19.07;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	96.04.29.15.00.06;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.04.23.11.10.49;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	96.04.02.11.14.28;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.04.01.12.36.21;	author stephenb;	state Exp;
branches;
next	1.25;

1.25
date	96.04.01.10.11.38;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.03.25.11.29.44;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	96.03.18.17.22.02;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.03.15.16.59.55;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	96.03.14.16.41.31;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	96.03.14.16.08.25;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	96.03.14.15.35.18;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	96.03.14.15.08.32;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	96.03.07.18.56.27;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	96.03.07.12.23.44;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	96.03.06.14.36.16;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.03.06.14.12.30;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	96.02.27.14.02.33;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.02.23.17.41.54;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.02.21.10.16.22;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	96.01.05.16.37.48;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.12.15.14.24.14;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	95.12.15.13.28.34;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.12.12.13.26.10;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.12.07.17.24.27;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.12.07.17.03.17;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.12.06.18.31.09;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.12.06.12.29.39;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.12.05.15.09.21;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.12.05.10.46.08;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	96.09.13.11.18.20;	author hope;	state Exp;
branches;
next	;

1.33.2.1
date	96.10.07.16.08.12;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	96.10.17.11.26.27;	author hope;	state Exp;
branches;
next	;

1.36.1.1
date	96.11.14.12.51.45;	author hope;	state Exp;
branches
	1.36.1.1.1.1;
next	;

1.36.1.1.1.1
date	96.11.28.15.02.47;	author hope;	state Exp;
branches;
next	;

1.36.2.1
date	96.11.22.18.10.58;	author hope;	state Exp;
branches;
next	;

1.36.3.1
date	96.12.17.17.49.32;	author hope;	state Exp;
branches
	1.36.3.1.1.1;
next	;

1.36.3.1.1.1
date	97.02.24.11.39.40;	author hope;	state Exp;
branches;
next	;

1.36.4.1
date	96.12.18.09.43.36;	author hope;	state Exp;
branches;
next	;

1.37.1.1
date	97.05.12.10.36.05;	author hope;	state Exp;
branches;
next	1.37.1.2;

1.37.1.2
date	97.05.29.18.32.39;	author daveb;	state Exp;
branches
	1.37.1.2.1.1
	1.37.1.2.2.1
	1.37.1.2.3.1;
next	;

1.37.1.2.1.1
date	97.07.28.18.21.46;	author daveb;	state Exp;
branches
	1.37.1.2.1.1.1.1;
next	;

1.37.1.2.1.1.1.1
date	97.10.07.11.47.26;	author jkbrook;	state Exp;
branches;
next	;

1.37.1.2.2.1
date	97.09.08.17.15.10;	author daveb;	state Exp;
branches;
next	;

1.37.1.2.3.1
date	97.09.09.14.11.03;	author daveb;	state Exp;
branches;
next	;

1.41.1.1
date	97.09.10.19.27.04;	author brucem;	state Exp;
branches;
next	;

1.41.2.1
date	97.09.11.20.57.05;	author daveb;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	97.09.17.15.57.37;	author daveb;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	97.10.29.11.41.00;	author daveb;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	97.10.30.16.29.01;	author daveb;	state Exp;
branches;
next	1.41.2.5;

1.41.2.5
date	97.11.06.16.22.28;	author daveb;	state Exp;
branches;
next	1.41.2.6;

1.41.2.6
date	97.11.20.17.01.35;	author daveb;	state Exp;
branches;
next	1.41.2.7;

1.41.2.7
date	97.11.26.16.17.08;	author daveb;	state Exp;
branches;
next	1.41.2.8;

1.41.2.8
date	97.12.01.11.17.15;	author daveb;	state Exp;
branches;
next	1.41.2.9;

1.41.2.9
date	97.12.01.12.24.48;	author daveb;	state Exp;
branches;
next	1.41.2.10;

1.41.2.10
date	97.12.02.14.06.20;	author daveb;	state Exp;
branches;
next	1.41.2.11;

1.41.2.11
date	97.12.04.16.43.42;	author daveb;	state Exp;
branches;
next	1.41.2.12;

1.41.2.12
date	98.01.08.15.00.16;	author johnh;	state Exp;
branches;
next	;

1.73.1.1
date	99.04.01.17.57.50;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
A project stores information about all the files used in a program.
@


1.73
log
@[Bug #190532]
Implement map_dag
@
text
@(*
 * Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *  
 * $Log: _project.sml,v $
 * Revision 1.72  1999/03/16  16:24:07  mitchell
 * [Bug #190526]
 * Fix problem with object_dir when no configuration
 *
 * Revision 1.71  1999/03/16  12:42:42  mitchell
 * [Bug #190526]
 * Put the dependency files below the config.
 *
 * Revision 1.70  1999/03/16  12:05:51  mitchell
 * [Bug #190526]
 * Fix problem with finding dependency files for subprojects
 *
 * Revision 1.68  1999/03/11  16:13:32  mitchell
 * [Bug #190526]
 * Move dependency precis files to object directory
 *
 * Revision 1.67  1999/03/10  14:33:37  mitchell
 * [Bug #190524]
 * File time comparisons should ignore fractions of a second if retrieved from encapsulator
 *
 * Revision 1.66  1999/02/19  10:44:06  mitchell
 * [Bug #190507]
 * Change dependency checking messages to diagnostic messages
 *
 * Revision 1.65  1999/02/18  10:44:14  mitchell
 * [Bug #190507]
 * Merge the CM dependency and existing require mechanisms
 *
 * Revision 1.64  1999/02/11  13:43:49  mitchell
 * [Bug #190507]
 * Require new dependency files, but ignore them for now.
 *
 * Revision 1.63  1999/02/09  09:50:01  mitchell
 * [Bug #190505]
 * Support for precompilation of subprojects
 *
 * Revision 1.62  1999/02/04  08:30:31  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
 * Revision 1.61  1999/02/02  16:01:07  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.60  1998/11/26  14:52:38  johnh
 * [Bug #70240]
 * Change delete function and add function to return units in main project only.
 *
 * Revision 1.59  1998/08/19  08:51:42  johnh
 * [Bug #30481]
 * Fix reading subprojects within different directories.
 *
 * Revision 1.58  1998/08/13  10:52:09  jont
 * [Bug #30468]
 * Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 * Revision 1.57  1998/07/30  14:13:31  johnh
 * [Bug #30420]
 * Include name of project when reporting a unit does not exist.
 *
 * Revision 1.56  1998/06/30  13:20:12  johnh
 * [Bug #20111]
 * Fix incorrect case problems.
 *
 * Revision 1.55  1998/06/01  16:03:18  johnh
 * [Bug #30369]
 * Replace source path with a list of files.
 *
 * Revision 1.54  1998/05/12  15:27:16  johnh
 * [Bug #30385]
 * CHanging mode should affect compilation.
 *
 * Revision 1.53  1998/04/24  15:19:29  mitchell
 * [Bug #30389]
 * Keep projects more in step with projfiles
 *
 * Revision 1.52  1998/04/22  15:13:34  jont
 * [Bug #70091]
 * Remove req_name from DEPEND_LIST
 *
 * Revision 1.51  1998/04/03  14:16:14  jont
 * [Bug #30312]
 * Replacing OS.FileSys.modTime with system dependent version to sort out
 * MS time stamp problems.
 *
 * Revision 1.50  1998/03/24  10:38:24  johnh
 * [Bug #30377]
 * Add check to ensure we know when we are checking deps of a pervasive file.
 *
 * Revision 1.49  1998/03/16  14:54:38  johnh
 * [Bug #70078]
 * When making object directories apply OS.Path.fromUnixPath.
 *
 * Revision 1.48  1998/03/16  12:22:18  johnh
 * [Bug #30365]
 * Implement support for sub-projects.
 *
 * Revision 1.47  1998/02/26  11:35:34  johnh
 * [Bug #30362]
 * Use mode setting to determine where object files go.
 *
 * Revision 1.46  1998/02/19  08:57:05  mitchell
 * [Bug #30337]
 * Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
 *
 * Revision 1.45  1998/02/06  11:24:42  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 * Added pervasiveObjectName.
 *
 * Revision 1.44  1998/01/26  17:21:31  jont
 * [Bug #30311]
 * Make sure we test for correct sequencing of timestamps on object files
 * and their dependents. If a depends on b, then a.mo should be no older
 * then b.mo
 *
 * Revision 1.43  1997/10/19  20:14:09  jont
 * [Bug #30089]
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.42  1997/10/13  10:57:55  daveb
 * [Bug #20090]
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 * Ditto for loaded object files.
 *
 * Revision 1.41.2.12  1998/01/08  15:00:16  johnh
 * [Bug #30071]
 * Remove specification of objects and binaries locations from configurations.
 *
 * Revision 1.41.2.11  1997/12/04  16:43:42  daveb
 * [Bug #30071]
 * Made fromFileInfo take a project to update.
 * Removed update function.
 * Interpret relative library paths w.r.t. to projectDir, not current dir.
 *
 * Revision 1.41.2.10  1997/12/02  14:06:20  daveb
 * [Bug #30071]
 * Search library path for object files.  Remove "%S" option for objects.
 *
 * Revision 1.41.2.9  1997/12/01  12:24:48  daveb
 * [Bug #30071]
 * Unset diagnostics.
 *
 * Revision 1.41.2.8  1997/12/01  11:17:15  daveb
 * [Bug #30071]
 * Relative path names are relative to the directory containing the
 * project file -- ensure this in fromFileInfo.
 *
 * Revision 1.41.2.7  1997/11/26  16:17:08  daveb
 * [Bug #30071]
 *
 * Revision 1.41.2.6  1997/11/20  17:01:35  daveb
 * [Bug #30326]
 *
 * Revision 1.41.2.5  1997/11/06  16:22:28  daveb
 * [Bug #30071]
 * Removed temporary default values for project.
 * Added support for current configurations, modes and targets.
 *
 * Revision 1.41.2.4  1997/10/30  16:29:01  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.41.2.3  1997/10/29  11:41:00  daveb
 * [Bug #20090]
 * Merged from trunk:
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 * Ditto for loaded object files.
 *
 * Revision 1.41.2.2  1997/09/17  15:57:37  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
 * Revision 1.41.2.1  1997/09/11  20:57:05  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.41  1997/06/13  16:19:09  jkbrook
 * [Bug #30158]
 * Merging in changes from 1.0r2c2 to 2.0m0
 *
 * Revision 1.40  1997/05/19  11:19:46  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.39  1997/05/12  16:05:11  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.38  1997/05/07  16:19:43  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 * Make sure reset_pervasives preserves dependencies for Encapsulate.decode_type_basis
 *
 * Revision 1.37  1997/02/12  13:22:47  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 *
 * Revision 1.36  1996/11/06  11:29:07  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.35  1996/10/29  16:28:10  io
 * [Bug #1614]
 * updating toplevel String
 *
 * Revision 1.34  1996/10/03  16:56:24  daveb
 * [Bug #1660]
 * When check_source_load_times finds a unit loaded from source, but no
 * corresponding source file, it now assumes that the loaded module is up
 * to date.
 *
 * Revision 1.33  1996/08/14  15:52:35  daveb
 * [Bug #1220]
 * Changed the check_validity function in check_dep to return an list of out
 * of date files.  Then changed check_source so that if no source file exists,
 * it checks the object files instead.  Intermake now loads an object file if
 * no source file exists; together these changes allow source files to require
 * object files.
 *
 * Revision 1.32  1996/07/04  15:16:20  jont
 * Improve error message when loading object files which are out of date
 *
 * Revision 1.31  1996/07/04  08:55:38  daveb
 * Bug 1448/Support Calls 35 & 37: Added remove_file_info and modified checks
 * to permit missing file information.
 *
 * Revision 1.30  1996/04/30  17:19:07  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.29  1996/04/29  15:00:06  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.28  1996/04/23  11:10:49  daveb
 * Fixed bug whereby read_dependencies didn't recurse on units which only
 * had an object file.
 *
 * Revision 1.27  1996/04/02  11:14:28  daveb
 * Renamed load_dependencies to read_dependencies.
 *
 * Revision 1.26  1996/04/01  12:36:21  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.25  1996/04/01  10:11:38  jont
 * Modification to check_aliases to prevent multiple compilations
 * of files.
 *
 * Revision 1.24  1996/03/25  11:29:44  daveb
 * Added delete function.
 *
 * Revision 1.23  1996/03/18  17:22:02  daveb
 * Added is_visible and set_visible functions.
 *
 * Revision 1.22  1996/03/15  16:59:55  daveb
 * Module.mo_name now takes an Info.options argument.
 *
 * Revision 1.21  1996/03/14  16:41:31  daveb
 * Changed type of loaded field to store just the basis and id_cache fields.
 *
 * Revision 1.20  1996/03/14  16:08:25  jont
 * Fix lack of warning when pervasive files not found
 * and pervasive recompilation requested
 *
 * Revision 1.19  1996/03/14  15:35:18  daveb
 * Changed visited_pervasives to mark_compiled instead of mark_visited.
 * Added some more diagnostics.  Corrected an error message.
 *
 *
 * Revision 1.18  1996/03/14  15:08:32  jont
 * Treat files where the filestamp info is corrupt as out of date
 *
 * Revision 1.17  1996/03/07  18:56:27  daveb
 * Fixed bug with bad requires.
 *
 * Revision 1.16  1996/03/07  12:23:44  daveb
 * Fixed update of source info, to make loadSource work properly.
 *
 * Revision 1.15  1996/03/06  14:36:16  daveb
 * Reset diagnostic level.
 *
 * Revision 1.14  1996/03/06  14:12:30  daveb
 * Fixed information stored for loaded modules, added validity check when
 * loading object files, fixed various details.
 *
 * Revision 1.13  1996/02/27  14:02:33  daveb
 * Hid implementation of the Unit type.
 *
 * Revision 1.12  1996/02/23  17:41:54  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.11  1996/02/21  10:16:22  daveb
 * Revised some error message to say 'object files' instead of 'mo files'.
 *
 * Revision 1.10  1996/01/05  16:37:48  daveb
 * Ensured that check_visited_map always uses the real module_ids, allowing for
 * symbolic links.  Passed a list of resolved module_ids as an argument to
 * check_dep; this builds up a list of the module_ids for the requires in a
 * given unit.
 *
 *  Revision 1.8  1995/12/15  13:28:34  jont
 *  Fixing bug whereby make doesn't always recompile all it should
 *
 *  Revision 1.7  1995/12/12  13:26:10  daveb
 *  Fixing bugs with load_object_dependencies
 *
 *  Revision 1.6  1995/12/07  17:24:27  daveb
 *  Replaced use of error_fn with Info.error.  Replaced an occurrence of
 *  mesg_fn with a diagnostic.  Improved format of mesg_fn output.
 *
 *)

require "../system/__link_support";  (* Just to make sure .mo is built *)

require "../basis/__int";
require "../basis/__real";
require "../basis/__list";
require "../basis/__string";
require "../system/__time";
require "^.system.__file_time";

require "../main/encapsulate";
require "../main/compiler";
require "../main/proj_file";
require "../utils/map";
require "../utils/crash";
require "../utils/lists";
require "../utils/diagnostic";
require "../make/depend";
require "../basics/module_id";
require "../basis/os";
require "options";
require "mlworks_io";

require "../dependency/_group_dag";
require "../dependency/module_dec_io.sml";
require "../dependency/import_export.sml";
require "../dependency/__ordered_set";

require "project";

functor Project (
  structure Encapsulate: ENCAPSULATE;
  structure ProjFile: PROJ_FILE;
  structure Compiler: COMPILER;
  structure Diagnostic: DIAGNOSTIC;
  structure NewMap: MAP;
  structure Crash: CRASH;
  structure ModuleId: MODULE_ID;
  structure Io: MLWORKS_IO;
  structure Depend: DEPEND;
  structure Options: OPTIONS;
  structure Lists: LISTS;
  structure OS : OS
  structure ModuleDecIO : MODULE_DEC_IO
  structure ImportExport : IMPORT_EXPORT

  sharing type Depend.ModuleId = ModuleId.ModuleId = Io.ModuleId
  sharing type Depend.Info.Location.T = ModuleId.Location
  sharing ModuleDecIO.ModuleDec = ImportExport.ModuleDec
  sharing type ImportExport.context = Compiler.Top_Env

): PROJECT =
struct
  structure Info = Depend.Info
  structure Location = Info.Location
  structure FileSys = OS.FileSys
  structure ModuleDec = ModuleDecIO.ModuleDec

  structure GD = GroupDagFun(structure ImportExport = ImportExport
                             structure ModuleId = ModuleId); 

  type Options = Options.options
  type ('a, 'b) Map = ('a, 'b) NewMap.map
  type ModuleId = ModuleId.ModuleId
  type CompilerBasis = Compiler.basis
  type IdCache = Compiler.id_cache
  type target_type = ProjFile.target_type

  val _ = Diagnostic.set 0

  fun diagnostic (level, output_function) =
    Diagnostic.output
      level
      (fn verbosity => output_function verbosity)

  (* This type is used by object files and loaded modules to store the
     time stamps of the object files or loaded modules on which they
     depend.  Using this type in both fields allows the dependency checking code
     to be shared. *)
  datatype Dependencies =
    DEPEND_LIST of
      {mod_name : string, time : Time.time} list
  
  datatype FileTime =
    OBJECT of Time.time
  | SOURCE of Time.time

  (* This is how the project manager represents a compilation unit.
     We store the following information:

     name:
       	In the presence of symbolic links, several module_ids may map to the
	same unit.  The module_id stored in the unit is the "real" module_id.
     source:
	The filename and modification time of the source file, if any.
	The recompilation process begins by re-loading all this information.
     requires:
	A triple of an explicit and an implicit list of dependencies, and
        a list of those dependencies external to the project.
        The explicit list of dependencies is read from the require declarations
        in the source file.  It is updated by the recompilation process if the
	modification time of the source file has changed.  The implicit list
        is obtained by doing a dependency analysis.  If the explicit list is
        non-empty and is a superset of the implicit list, then this list
        is used to drive the recompilation process.  If the explicit list is a
        subset of the implicit list then the implicit list is used. 
        Furthermore, in this case if the explicit list is non-empty then a 
        warning is issued.
     object:
	The filename, modification time, and consistency information of the
	object file, if any.  The consistency information contains the
	modification times of the source file, which is called the time stamp.
	It also contains the time stamps of (i.e. the modification times of the
	source files that correspond to) the pervasive library and all the
	object files that this file depends on.  The recompilation process
	begins by bringing this information up to date.  We assume at most
	one object file per source file.
	The consistency information is set when the file is written by
	Encapsulate.output_file, which is called from <URI:/_toplevel.sml>.
     loaded:
	Contains the modification time of the file from which the compilation
	unit was loaded (if a source file) or its time stamp (if an object file),
        the time that it was loaded, the compiled module, and the load times of
        the loaded modules on which it depends.
	This information is set when loading a module, in
        <URI://MLWinterpreter/_intermake.sml>.
     visible:
	Records whether the loaded unit is visible at top level, i.e. has
	been added to the user's Context.
     options:
	A place holder to record the options with which a loaded unit was
	compiled.  Currently unused.  If this support is added, then the
	object file format should probably be changed to store this
	information as well.
     mod_decls:
        A precis of the module imports and exports for this unit, together
        with a boolean indicating whether this information is only approximate,
        e.g. because of a syntax error in the source file.
  *)

  datatype Unit =
    UNIT of
    {name:     ModuleId.ModuleId, 
     source:   (string * Time.time) option ref,
     requires: {explicit: ModuleId.ModuleId list,
                implicit: ModuleId.ModuleId list,
                subreqs : ModuleId.ModuleId list} ref,
     object:   {file_time: Time.time,
		time_stamp: Time.time,
		file: string,
		stamps: int,
		consistency: Dependencies} option ref,
               (* The int is the stamps field returned by
		  Encapsulate.input_info *)
     loaded:   {file_time: FileTime,
		load_time: Time.time,
		basis: Compiler.basis,
		id_cache: Compiler.id_cache,
		module: MLWorks.Internal.Value.T,
		dependencies: Dependencies} option ref,
     visible:  bool ref,
     options:  Options.options option ref,
     mod_decls: (ModuleDec.Dec * bool) ref
    }
  
  (* The Project type is the definition of a project.  It has the following
     elements:

     units:  A map from module_ids to units.
     files:  A list of files to be included in the project.  Consists 
	only of ML source files at present.
     library_path:  A list of directories to search for libraries
       (libraries are currently implemented as object files).
     object_dir:  A specification of where to put new object files.
     current_targets:  A list of top-level files, in build order, and the
       sort of deliverable.
     disabled_targets:  A list targets that are temporarily disabled.
     dependency_info:  The inferred dependency information for this project.

     Currently the files and object path are global, and targets
     are specified on the command line.
   *)

  datatype Project =
    PROJECT of
      {name: string,
       units: (ModuleId.ModuleId, Unit) NewMap.map,
       files: string list,
       library_path: string list,
       object_dir: {base: string, config: string, mode: string},
       subprojects: Project list,
       current_targets: string list,
       disabled_targets: string list,
       dependency_info: Dependency_info
      }
  
  and Dependency_info = 
    DEPEND of
       (ImportExport.ModuleName.set * dag) list (* current targets *)
     * (ImportExport.ModuleName.set * dag) list (* other units *)

  withtype dag = (ModuleId.ModuleId OrderedSet.set) GD.dag
  
  type project_cache = ({filename: string,
                         targets: string list}, Project) NewMap.map
 
  fun string_list_lt([], []) = false
    | string_list_lt([], _)  = true
    | string_list_lt(h::t, []) = false
    | string_list_lt(h1::t1, h2::t2) = 
        String.<(h1,h2)
        orelse (h1 = h2 andalso string_list_lt(t1,t2))

  fun project_cache_lt 
      ({filename = f1, targets = tl1},
       {filename = f2, targets = tl2}) =
      String.<(f1, f2)
      orelse (f1 = f2
              andalso (string_list_lt(tl1, tl2)))

  val empty_project_cache : project_cache =
        NewMap.empty (project_cache_lt, op =)

  fun get_subprojects (proj as PROJECT{subprojects,...}) = subprojects

  fun set_subprojects (PROJECT{name,units,files,library_path,object_dir,
                               current_targets,disabled_targets,
                               dependency_info,...}, subprojects) =
    PROJECT{name=name,units=units,files=files,library_path=library_path,
            object_dir=object_dir,current_targets=current_targets,
            disabled_targets=disabled_targets,dependency_info=dependency_info,
            subprojects=subprojects}

  fun map_dag (f: Project -> Project) (p: Project) =
    let 
      val project_cache = ref empty_project_cache
      fun process (proj as PROJECT {name, current_targets, subprojects, ...}) =
        case NewMap.tryApply' (!project_cache, 
                   {filename = name, targets = current_targets}) of 
          SOME project => project
        | NONE => 
            let val proj' = f (set_subprojects(proj, map process subprojects))
             in 
               project_cache := 
                 NewMap.define (!project_cache, 
                   { filename=name, targets=current_targets }, 
                   proj');
               proj'
            end 
    in process p
    end
 
  val { union = union_mid_set, memberOf = member_mid_set, ... } =
              OrderedSet.gen { eq = ModuleId.eq, lt = ModuleId.lt }
  val empty_mid_set = OrderedSet.empty
  val singleton_mid_set = OrderedSet.singleton

  (* The NoSuchModule exception is raised when read_dependencies fails to find
     the module corresponding to some dependency information, or when
     set_object_info is called with an invalid module id. *)
  exception NoSuchModule of ModuleId.ModuleId

  (* The Kind type indicates whether a function is checking dependencies of
     a pervasive module or a user module. *)
  datatype Kind = PERVASIVE | USER

  fun currentTargets (PROJECT {current_targets, ...}) = current_targets

  fun combineOpt (NONE, NONE) = NONE
    | combineOpt (NONE, SOME a) = SOME a
    | combineOpt (SOME a, NONE) = SOME a
    | combineOpt (SOME a, SOME b) = SOME a

  fun module_id_in_project (PROJECT {units, ...}, m) = 
    case NewMap.tryApply' (units, m) of
      SOME _ => true
    | NONE => false

  fun get_unit (PROJECT {units, subprojects, ...}, m) = 
    case NewMap.tryApply' (units, m)
    of SOME unit => SOME unit
    |  NONE =>
      case subprojects of
	[] => NONE
      | (a::rest) => 
	foldl combineOpt NONE (map (fn p => get_unit(p, m)) subprojects)

  fun get_project_name (PROJECT {name, ...}) = name
    
  fun get_name (proj, m) =
    case get_unit (proj, m) 
    of SOME (UNIT {name, ...}) => name
    |  NONE =>
      (diagnostic (1,
         fn _ => ["No such module in get_name: `", ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun requires_from_unit 
        (UNIT {name, requires = ref {explicit,implicit,subreqs},...}) = 
      case explicit of
        [] => implicit
      | _  => explicit

  fun get_requires (proj, m) =
    case get_unit(proj, m) of
      SOME u => requires_from_unit u
    | NONE => 
      (diagnostic (1,
         fn _ => ["No such module in get_requires: `", ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun get_external_requires (proj as PROJECT{subprojects,...}) =
    let fun convert (subproject as PROJECT {name,...}) =
          map (fn t => (subproject, ModuleId.from_host (t, Location.FILE name)))
              (currentTargets subproject)
     in List.concat (map convert subprojects)
    end

  fun is_visible (proj, m) =
    case get_unit (proj, m)
    of SOME (UNIT {visible, ...}) => !visible
    |  NONE =>
      (diagnostic (1,
         fn _ => ["No such module in is_visible: `", ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun set_visible (proj, m, b) =
    case get_unit (proj, m)
    of SOME (UNIT {visible, ...}) => visible := b
    |  NONE =>
      (diagnostic (1,
	 fn _ => ["No such module in is_visible: `", ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun get_source_info (proj, m) =
    case get_unit (proj, m)
    of SOME (UNIT {source, ...}) => !source
    |  NONE => NONE
	
  fun set_source_info (proj, m, info) =
    case get_unit (proj, m)
    of SOME (UNIT {source, ...}) => source := info
    |  NONE =>
      (diagnostic (1,
         fn _ => ["No such module in set_source_info: `",
                  ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun get_object_info (proj, m) =
    case get_unit (proj, m)
    of SOME (UNIT {object, ...}) => !object
    |  NONE => NONE

  fun set_object_info (proj, m, info) =
    case get_unit (proj, m)
    of SOME (UNIT {object, ...}) => object := info
    |  NONE =>
      (diagnostic (1,
         fn _ => ["No such module in set_object_info: `",
                  ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun get_loaded_info (proj, m) =
    case get_unit (proj, m)
    of SOME (UNIT {loaded, ...}) => !loaded
    |  NONE => NONE

  fun set_loaded_info (proj, m, info) =
    case get_unit (proj, m)
    of SOME (UNIT {loaded, ...}) => loaded := info
    |  NONE => 
      (diagnostic (1,
         fn _ => ["No such module in set_loaded_info: `",
                  ModuleId.string m, "'"]);
       raise NoSuchModule m)

  fun clear_info pred (PROJECT {units, subprojects, ...}) = 
    (NewMap.iterate 
      (fn (m, UNIT u) =>
	 if pred m then
	   #loaded u := NONE
         else
	   ())
      units;
     app (clear_info pred) subprojects)

  fun clear_all_loaded_info (proj, pred) =
    clear_info pred proj

  fun mesg_fn (location, s) =
    print(Info.Location.to_string location ^ ": " ^ s ^ "\n")
  
  (* Given a module_id for a user module and a search path, findFile
     finds the corresponding file, and returns the file name and
     modification time. *)
  fun findFile ext (search_path, module_id) =
    let
      fun search [] =
        (diagnostic (2, fn _ => ["Failed to find file"]);
	 NONE)
      |   search (dir::rest) =
        let
          val filename =
	    OS.Path.joinDirFile
              {dir = dir,
	       file = ModuleId.module_unit_to_string (module_id, ext)}

          val _ =
            diagnostic (2, fn _ => ["searching: ", filename])
        in
	  let
            val mod_time = FileTime.modTime filename
	  in
	    diagnostic (2, fn _ => ["Found `", filename, "'"]);
	    SOME (filename, mod_time)
	  end
	  handle OS.SysErr _ =>
  	    search rest
        end
    in
      search search_path
    end

  val source_ext = "sml"
  val object_ext = "mo"

  (* findObject is more complicated than findSource.  The first place to
     look is in the object directory, which is simple enough.  If there
     isn't a file there, then there are two cases:
       1. If a source file exists, then stop.
       2. If there isn't a source file, then search the library path
	  for a library entry.  *)
  local
    (* objectName' finds the filename corresponding to an existing
       source file. *)
    fun objectName' ({base, config, mode}, module_id) =
      OS.Path.mkCanonical
        (OS.Path.concat
          [base, config, mode, 
           ModuleId.module_unit_to_string(module_id, object_ext)])

    fun search_lib_path (NONE, _) = NONE
    |   search_lib_path (SOME lib_path, module_id) =
      findFile object_ext (lib_path, module_id)
  in
    (* Given a module_id for a user module, and an optional library path,
       findObject finds the corresponding object file, and returns the
       file name and modification time. *)
    (* We should probably add an argument that specifies whether an object
       file is definitely required, or whether it's OK if it's missing. *)
    fun findObject (object_dir, lib_path_opt, module_id) =
      let
        val filename = objectName' (object_dir, module_id)
      in
	let
	  val mod_time = FileTime.modTime filename
	in
          diagnostic (2, fn _ => ["Found `", filename, "'"]);
          SOME (filename, mod_time)
        end
        handle OS.SysErr _ =>
          search_lib_path (lib_path_opt, module_id)
      end

    (* objectName is externally visible; it finds the object filename
       corresponding to an existing source file. *)
    fun objectName
          (error_info, loc)
	  (PROJECT {units, object_dir, subprojects, ...}, module_id) =
      let
	val top_unit = NewMap.tryApply' (units, module_id) 

	fun get_subproject_info ([], m) = (NONE, object_dir)
	  | get_subproject_info 
		((PROJECT {object_dir, subprojects, units, ...}) :: rest, m) = 
	      case NewMap.tryApply' (units, m) of 
		SOME unit => (SOME unit, object_dir)
	      | NONE => get_subproject_info (subprojects @@ rest, m)

	val (unitOpt, object_dir) = 
	  if isSome(top_unit) then 
	    (top_unit, object_dir)
	  else
	    get_subproject_info (subprojects, module_id)

        val unit = 
          case top_unit of 
	    SOME unit => unit
	  | NONE =>
	      case unitOpt of 
		SOME unit => unit
	      | NONE => 
	        (* This is probably impossible *)
                (Info.default_error'
                   (Info.FATAL, loc,
                    (* LOCALE *)
                    "Missing unit information for module " ^
 	            ModuleId.string module_id))
      in
	case unit of
	  UNIT {object as ref (SOME {file, ...}), ...} =>
	    file
        | _ =>
          objectName' (object_dir, module_id)
      end   

    fun pervasiveObjectName module_id =
      objectName' ({base=Io.get_pervasive_dir(), config="", mode=""},module_id)

  end

  fun findPervasiveFile ext module_id =
    let
      val filename =
        OS.Path.joinDirFile
          {dir = Io.get_pervasive_dir(),
           file = ModuleId.module_unit_to_string (module_id, ext)}

      val _ = diagnostic (2, fn _ => ["looking for: ", filename])

      val mod_time = FileTime.modTime filename
    in
      diagnostic (2, fn _ => ["Found `", filename, "'"]);
      SOME (filename, mod_time)
    end
    handle
      OS.SysErr _ => NONE
    | Io.NotSet _ => NONE

  (* Given a module_id for a pervasive module, findPervasiveObject finds the
     corresponding mo file, and returns the file name and modification time. *)
  val findPervasiveObject = findPervasiveFile object_ext

  (* Given a module_id for a pervasive module, findPervasiveSource finds the
     corresponding source file, and returns the file name, module, and
     modification time. *)
  val findPervasiveSource = findPervasiveFile source_ext

  (* Given a module_id for a user module, and a list of source files, 
   * findSource finds the corresponding source file, and returns the 
   * file name and modification time. 
   *)
  fun findSource (file_list, module_id) =
    let
      val fname = 
	OS.Path.mkCanonical (ModuleId.module_unit_to_string (module_id, "sml"))

      fun search [] = 
        (diagnostic (2, fn _ => ["Failed to find file in Project file list"]);
	 NONE)
	| search (filename::rest) = 
	  if (fname = OS.Path.mkCanonical (OS.Path.file filename)) then 
	    let
	      val mod_time = FileTime.modTime filename
	    in
	      diagnostic (2, fn _ => ["Found `", filename, "'"]);
	      SOME (filename, mod_time)
	    end
	    handle OS.SysErr _ => 
	      (diagnostic (2, fn _ => ["File `", filename, "' cannot be inspected."]);
	       NONE)
	  else
	    search rest
    in
      search file_list
    end


  fun module_id_from_string (filename, is_pervasive) name =
    let val loc = Location.FILE filename
     in if is_pervasive
        then ModuleId.perv_from_require_string(name, loc)
        else ModuleId.from_require_string(name, loc)
    end


  (* This is called before storing a unit's list of required modules. *)
  fun module_name_from_require req_name =
    ModuleId.add_path (ModuleId.empty_path, req_name)
  
  (* load_src loads information about a source file from disk.  The project
     argument (and result) is actually one of the components (pervasive or
     user) of the project type. *)
  fun load_src (is_pervasive, error_info,
		SOME (filename, mod_time), unit,
                object_dir as {base, config, mode}) =
    let
      (* Get the names of the dependencies *)
      val (mod_decs, requires, partial) =
        ModuleDecIO.source_to_module_dec (filename, SOME mod_time, 
          if is_pervasive then Io.get_pervasive_dir() 
          else OS.Path.mkCanonical(OS.Path.concat[base, config]))
      val sub_modules =
        map ( module_name_from_require 
              o (module_id_from_string (filename, is_pervasive)) )
            requires 
    in
      case unit of
        UNIT {source, requires, mod_decls, ...} =>
  	(source := SOME (filename, mod_time);
         mod_decls := (mod_decs, partial);
         requires := {explicit=sub_modules,implicit=[],subreqs=[]})
    end
  | load_src (is_pervasive, error_info, NONE,
                UNIT {name, source, requires, mod_decls, ...}, 
                object_dir as {base, config, mode}) =
    let
      (* Hardwiring in the .sml extension here is undesirable.
         The source field in a Unit should contain the name of the file 
         as it exists in the project file, and just the time should
         be optional if the source file cannot be found. *) 
      val filename = ModuleId.module_unit_to_string(name, "sml")
      val (mod_decs, reqs, partial) =
        ModuleDecIO.source_to_module_dec (filename, NONE, 
          if is_pervasive then Io.get_pervasive_dir() 
          else OS.Path.mkCanonical(OS.Path.concat[base, config]))
      val sub_modules =
        map ( module_name_from_require 
              o (module_id_from_string (filename, is_pervasive)) )
            reqs 
    in
        (source := NONE;
         mod_decls := (mod_decs, partial);
         requires := {explicit=sub_modules,implicit=[],subreqs=[]})
    end  

  (* load_object loads information about a object file from disk.  The project
     argument (and result) is actually one of the components (pervasive or
     user) of the project type. *)
  fun load_object (SOME (filename, mod_time)) unit =
    (let
       val {time_stamp, consistency, mod_name, stamps} =
	 Encapsulate.input_info filename
     (* The mod_name is ignored here.  Does this matter? *)
     in
       case unit of
	 UNIT {object, ...} =>
	   object :=
	   SOME 
	   {file_time = mod_time, 
	    time_stamp = time_stamp,
	    file = filename,
	    stamps = stamps,
	    consistency = DEPEND_LIST consistency}
     end
   handle Encapsulate.BadInput str =>
     (print("Corrupt object file '" ^ filename ^ "' treating as out of date\n");
      case unit of
	UNIT {object, ...} => object := NONE))
    | load_object NONE unit =
      case unit of
	UNIT {object, ...} => object := NONE
  
  (* new_unit creates a new unit. *)
  fun new_unit
	error_info
	(is_pervasive, map, module_id, sml_info, mo_info, info_from_mo, object_dir) =
    let
      val unit =
        UNIT
          {name = module_id,
           source = ref NONE,
           requires = ref {explicit=[],implicit=[],subreqs=[]},
           loaded = ref NONE,
           visible = ref false,
           options = ref NONE,
           mod_decls = ref (ModuleDec.SeqDec [], false),
           object = ref NONE}
  
      (* We can do an optimisation here: if we have info_from_mo, and
	 the mo is up to date, then the consistency contains the list
	 of require names. *)
      val _ = load_src (is_pervasive, error_info, sml_info, unit, object_dir)

      (* We add the object info explicitly here, because we may have
	 already read the necessary info from the mo file, and we don't
	 want to open the file twice. *)
      val _ =
	case info_from_mo of
	  SOME {consistency, mod_name, time_stamp, stamps} =>
	    (case mo_info of
	       SOME (filename, mod_time) =>
		 (case unit of
		    UNIT {object, ...} =>
		      object :=
		      SOME 
		      {file_time = mod_time, 
	             time_stamp = time_stamp,
		       file = filename,
		       stamps = stamps,
		       consistency = DEPEND_LIST consistency})
	     | NONE =>
		  Crash.impossible ("new_unit has info_from_mo but no mo_info in `"
				    ^ ModuleId.string module_id ^ "'!"))
	| NONE =>
	    (* load_object will read the info from the mo file if necessary *)
            (diagnostic (3,
               fn _ => ["calling load_object from new_unit"]);
	     load_object mo_info unit;
	     case (mo_info, sml_info) of
	       (NONE, NONE) =>
		 if is_pervasive then
		   Info.error'
		   error_info
		   (Info.FATAL, Info.Location.UNKNOWN,
		    "No files found for pervasive file: `" ^ ModuleId.string module_id ^ "'")
		 else
		   ()
	     | _ => ())

      val map' = NewMap.define (map, module_id, unit)
    in
      (map', unit)
    end


  (* The StatusMap type stores information about those units for which
     information has been updated during a particular command.  There
     are currently two statuses that may be stored:
        visited: the dependency information is up to date
        compiled: the object file or loaded module is up to date.
   *)

  type StatusMap = (ModuleId, bool) Map

  fun mark_visited (v, m) = NewMap.define (v, m, false)
  fun mark_compiled (v, m) = NewMap.define (v, m, true)

  val empty_map = NewMap.empty (ModuleId.lt, ModuleId.eq)
  val visited_pervasives = mark_compiled (empty_map, Io.pervasive_library_id)

  fun no_targets (error_info, location) projectName = 
    let 
      val name = getOpt (ProjFile.getProjectName(), "")
      val err_project_str = 
	if (name = "") orelse
	   (OS.Path.mkCanonical projectName) = (OS.Path.mkCanonical name) then
	  "No targets specified in current project"
	else
	  "No targets specified in project: " ^ projectName
    in
      Info.error' error_info
	(Info.FATAL, location, err_project_str)
    end

  (* Check that the source info recorded in the project is still valid. *)
  fun check_src (unit as UNIT {source = src_info, ...}, module_id,
                 is_pervasive, files, error_info, location, object_dir)  =
      case !src_info of 
        sml_info as SOME (filename, time_stamp) =>
          (* Check whether the file on disk has changed *)
          (let val mod_time = FileTime.modTime filename
            in if time_stamp = mod_time 
               then ()
               else
                 load_src
                   (is_pervasive, error_info,
                    SOME (filename, mod_time), unit, object_dir)
           end
             handle OS.SysErr _ =>
                 (mesg_fn (location,
                           "Source file " ^ filename ^ " has disappeared");
                  if is_pervasive then
                    load_src
                      (true, error_info,
                       findPervasiveSource module_id,
                       unit, object_dir)
                  else
                    load_src
                      (false, error_info,
                       findSource (files, module_id),
                       unit, object_dir)))
      | NONE => 
          if is_pervasive 
          then
            load_src
                  (true, error_info,
                   findPervasiveSource module_id,
                   unit, object_dir)
          else
            load_src  (* we know this unit is not in a subproject *)
                  (false, error_info,
                   findSource (files, module_id),
                   unit, object_dir)
    
  fun getObject (unit as UNIT {source = src_info, ...}, module_id, 
                 is_pervasive, library_path, object_dir) = 
      if is_pervasive 
      then 
        findPervasiveObject module_id
      else
        let 
          (* Don't search the library path if a source file exists. *)
          val lib_path_opt = 
              if isSome (!src_info) then NONE else SOME library_path
        in
          findObject (object_dir, lib_path_opt, module_id)
        end

  (* Check that the object info recorded in the project is still valid. *)
  fun check_obj (unit as UNIT {object, ...}, module_id, 
                 is_pervasive, library_path, object_dir, location) =
      let 
        val get_object = getObject(unit, module_id, 
                                   is_pervasive, library_path, object_dir)
      in
        case !object of 
          SOME {file, time_stamp, file_time, stamps, consistency} =>
            (* Check whether the file on disk has changed *)
            (let val mod_time = FileTime.modTime file
              in
                case get_object of 
                  NONE => load_object NONE unit
                | SOME (obj_file, obj_time) =>
                    if (obj_file = file) then 
                      if time_stamp = mod_time then 
                        () 
                      else 
                        load_object (SOME (file, mod_time)) unit
                    else
                      load_object (SOME (obj_file, obj_time)) unit
             end handle OS.SysErr _ =>
                   (mesg_fn (location,
                           "Object file " ^ file ^ " has disappeared");
                    load_object get_object unit))
        | NONE => 
            load_object get_object unit
      end

  fun check_module (module_id, is_pervasive, 
                    units, files, subprojects, library_path, object_dir, error_info, location) =
      (* Do we have an entry for this unit in the project? *)
      case NewMap.tryApply' (units, module_id) of 
        SOME unit =>
          (check_src (unit, module_id, is_pervasive, files, error_info, location, object_dir);
           check_obj (unit, module_id, is_pervasive, library_path, object_dir, location);
           (units, SOME unit))
      | NONE =>
          if is_pervasive 
          then
            let
              val sml_info = findPervasiveSource module_id
              val mo_info =  findPervasiveObject module_id

              val (units', unit) = 
                  new_unit
                    error_info
                    (true, units, module_id, sml_info, mo_info, NONE, object_dir)
            in
              (units', SOME unit)
            end
          else
            let
              (* If unit is found in subprojects, then do nothing else
               * create a new unit *)

              val unit = 
                  foldl combineOpt 
                        NONE 
                        (map (fn p => get_unit(p, module_id)) subprojects)

              val returnUnits = 
                  if isSome(unit) then 
                    (units, NONE)
                  else 
                    let 
                      val src_info = findSource (files, module_id)

                      val _ = diagnostic (3, fn _ => ["calling new_unit"]);
                      val (units', unit) = 
                        new_unit
                        error_info
                          (false, units, module_id, src_info, NONE, NONE, object_dir);

                      (* Don't search library path if we have source *)
                      val lib_path_opt =
                        if isSome src_info then NONE else SOME library_path
                    in
                      diagnostic (3, fn _ => ["calling load_object"]);
                      load_object
                        (findObject (object_dir, lib_path_opt, module_id))
                         unit;
                      (units', SOME unit)
                    end
              in
                returnUnits
              end

  (* read_dependencies takes a file name and returns a Project that comprises
     the units required by the named file (including the file itself).
     The is_pervasive flag tells it whether it is checking pervasive or user
     files.  The algorithm used is the same in both cases, except that the
     files are found in different locations.
     The seen argument is a map of modules that are known to have up to date
     dependency info stored in the project.  It is used to avoid
     reading information for a module more than once.  *)
  fun do_read_dependencies
        (error_info, location)
        (PROJECT {name, units, files, library_path, object_dir, 
		  subprojects, current_targets, disabled_targets, dependency_info},
	 module_id, seen_init)
	subprojects_read: (Project * StatusMap) =
    let
      fun getCurTargets (PROJECT {name, current_targets, ...}) = 
	if null current_targets then 
	  no_targets (error_info, location) name
	else
          map (fn t => ModuleId.from_host(t, location)) current_targets

      fun read_subproj_dependencies proj = 
	let 
	  val (pervasive_proj, pervasive_smap) = 
	    do_read_dependencies (error_info, location)
				 (proj, Io.pervasive_library_id, empty_map)
				 true

	  fun read_sub_dep (m, (proj, smap)) = 
	    do_read_dependencies (error_info, location)
			         (proj, m, smap)
			         false

	in
	    #1 (foldl read_sub_dep (pervasive_proj, pervasive_smap) (getCurTargets proj))
	end

      val subprojects = subprojects
(*        
	if subprojects_read then subprojects
	else 
	  map read_subproj_dependencies subprojects
*)

      (* The ancestors argument is a list of modules that have been
	 traversed en route to this one.  It is used to detect circularities. *)
      (* I think it's a pain that we have to traverse the ancestors list on
	 every call.  We could combine this info with the seen map (storing
	 true if the module is an ancestor and false otherwise).  Since we
	 have to check the seen table already, this would save lookup time,
	 but it would require resetting the entry when leaving the function,
	 which would probably take just as long. *)
      fun read_dependencies'
	    (location, ancestors)
	    ((units, seen), module_id) =
	    let
          (* First define some auxiliary functions. *)

	  val mod_name = ModuleId.string module_id

	  (* At this point we are not sure whether the module_id is pervasive 
	   * or not because the return value of sub_units below could contain 
	   * a mixture of pervasive and non-pervasive module ids if the 
	   * dependencies are read from the object file.
	   *)
	  val is_pervasive = ModuleId.is_pervasive (module_id)

  	  val _ =
            diagnostic (2,
              fn _ => ["read_dependencies called with `", mod_name, "'"])
        
	    (* The function sub_units may return a mixture of dependencies of 
	     * pervasive and non-pervasive files depending on whether the 
	     * dependencies are looked up from the object file or not.
	     *)
	    fun sub_units (unit as UNIT {requires, source, object, ...}) =
	      case !source
	      of SOME _ => requires_from_unit unit
	      |  NONE =>
		case !object
		of SOME {consistency = DEPEND_LIST cons, ...} =>
		  map
		    (fn {mod_name, ...} =>
		       ModuleId.from_mo_string (mod_name, Location.UNKNOWN))
		    cons
		|  NONE =>
		  (* Could check for a loaded module here -- if it exists,
		     a load command can continue.  But a compilation will
		     fall over, so we have to be pessimistic.
		     Daveb, 4/12/97. *)
		  Info.error' 
		    error_info
		    (Info.FATAL, location, 
			"In project: " ^ name ^ ", no such unit exists: " ^ mod_name)
          in
	    (* First check for circularities *)
	    if Lists.member (mod_name, ancestors) then
              Info.error'
                error_info
                (Info.FATAL, Info.Location.FILE mod_name,
                 concat
                   ("Circular require structure within"
                    :: map (fn x => "\n" ^ x) ancestors))
	    (* Now check whether we have already seen this module during this
	       call of read_dependencies. *)
            else
	      case NewMap.tryApply'(seen, module_id)
	      of SOME _ =>
                (diagnostic (3, fn _ => ["seen it!"]);
	         (units, seen))
	      |  NONE =>
	        (case
                    check_module (module_id, is_pervasive, 
                    units, files, subprojects, library_path, object_dir, error_info, location) 
		 of (units', SOME unit) =>
  	           Lists.reducel
		     (read_dependencies'
			(Location.FILE mod_name, mod_name :: ancestors))
		     ((units', mark_visited (seen, module_id)),
		      sub_units unit)
		 |  (units', NONE) => (units', mark_visited (seen, module_id)))
                handle Io.NotSet _ =>
                  Info.error'
                    error_info
                    (Info.FATAL, location, "Pervasive directory not set")
	  end
  
	val (units', seen') =
	  read_dependencies'
	    (location, [])
	    ((units, seen_init), module_id)

      in
        (PROJECT
	   {name = name,
	    units = units',
	    files = files,
	    library_path = library_path,
	    object_dir = object_dir,
	    subprojects = subprojects,
	    disabled_targets = disabled_targets,
	    current_targets = current_targets,
            dependency_info = dependency_info},
	 seen')
      end


  (* read_object_dependencies takes a file name and returns a Project that
     comprises the units required by the named object file (including the
     file itself).  This is used for compiling a single file.  The algorithm
     is basically the same as that in read_dependencies.
     The seen argument is a map of modules that are known to have up to date
     dependency info stored in the project.  It is used to avoid
     reading information for a module more than once.  *)
  fun read_object_dependencies
        (error_info, location)
        (proj as PROJECT {name, units, files, library_path, object_dir, 
		  subprojects, current_targets, disabled_targets, dependency_info},
	 module_id, seen_init): Project * StatusMap =
    let
      fun getCurTargets (PROJECT {name, current_targets, ...}) = 
	if null current_targets then
	  no_targets (error_info, location) name
	else
          map (fn t => ModuleId.from_host(t, location)) current_targets

      fun read_subproj_dependencies subproj = 
	let 
	  val (pervasive_proj, pervasive_smap) = 
	    do_read_dependencies (error_info, location)
				 (subproj, Io.pervasive_library_id, empty_map)
				 true

	  fun read_sub_dep (m, (proj, smap)) = 
	    do_read_dependencies (error_info, location)
			         (proj, m, smap)
			         false
	in
	  #1 (foldl read_sub_dep (pervasive_proj, pervasive_smap) (getCurTargets proj))
	end

      val subprojects = 
	map read_subproj_dependencies subprojects

      (* The ancestors argument is a list of modules that have been
	 traversed en route to this one.  It is used to detect circularities.
	 The location argument is where this function was called from. *)
      fun read_object_dependencies'
	    (location, ancestors)
	    (module_id, (units, seen)) =
        let
          (* First define some auxiliary functions. *)

	  val mod_name = ModuleId.string module_id

  	  val _ =
            diagnostic (2,
              fn _ => ["read_object_dependencies called with `",
  		       mod_name, "'"])
        
	  fun getObject' (unit as UNIT {source = src_info, ...}) = 
	    let 
	      (* Don't search the library path if a source file exists. *)
	      val lib_path_opt = 
		if isSome (!src_info) then NONE else SOME library_path
	    in
	      findObject (object_dir, lib_path_opt, module_id)
	    end

  	  fun check_obj' (unit, object) =
  	    case !object
  	    of SOME {file, time_stamp, consistency, file_time, stamps} =>
  	      (* Check whether the file on disk has changed *)
	      (let
		 val mod_time = FileTime.modTime file
		 val get_object = getObject' unit
	       in
		 case get_object of 
		   NONE => load_object NONE unit
		 | SOME (obj_file, obj_time) =>
		     if (obj_file = file) then
		       if time_stamp = mod_time then
			 ()
		       else
			 load_object (SOME (file, mod_time)) unit
		     else
		       load_object (SOME (obj_file, obj_time)) unit
	       end handle OS.SysErr _ =>
		 (mesg_fn (location,
			   "Object file " ^ file ^ " has disappeared");
  	          load_object
	            (findObject (object_dir, SOME library_path, module_id))
		    unit))
  	    |  NONE => 
  	      load_object
	        (findObject (object_dir, SOME library_path, module_id))
		unit

	   (* This function does the bulk of the work *)
           fun check_module' () =
  	      (* Do we have an entry for this unit in the project? *)
  	      case NewMap.tryApply' (units, module_id)
  	      of SOME (unit as UNIT {object, ...}) =>
  	        (check_obj' (unit, object);
  	         (units, SOME unit))
  	      |  NONE =>
		let 
		  val unit = 
		    foldl combineOpt 
			  NONE 
			  (map (fn p => get_unit(p, module_id)) subprojects)
		in
		  case unit of
		    NONE => 
  	              let
		        (* XXX I'm not sure that this works.  The code used to
		         * check for the existence of the object file before
		         * creating the new unit.
		         * - Does findObject cope OK in this case?  (Probably,
		         *   now that we've dropped %S).
		         * - Should we retract the new unit before reporting
		         *   the error?
		         *)
		        val (units', unit) = 
	                  new_unit
	                    error_info
	                    (false, units, module_id, NONE, NONE, NONE, object_dir);
  	              in
	                case findObject (object_dir, SOME library_path, module_id)
		        of mo_info as SOME _ =>
		          (load_object mo_info unit;
		           (units', SOME unit))
		        |  NONE =>
                          Info.error'
                            error_info
                             (Info.FATAL, Info.Location.FILE mod_name,
		             "No object file.")
		      end
		  | SOME u => 
		    (units, NONE)
		end

	    fun recurse ((units, seen), 
			 {mod_name = sub_name, time}) =
	       read_object_dependencies'
		 (Location.FILE mod_name, mod_name :: ancestors)
		 (ModuleId.from_mo_string (sub_name, Location.FILE mod_name),
		  (units, mark_visited (seen, module_id)))
          in
	    (* First check for circularities *)
	    if Lists.member (mod_name, ancestors) then
              Info.error'
                error_info
                (Info.FATAL, Info.Location.FILE mod_name,
                 concat
                   ("Circular require structure within"
                    :: map (fn x => "\n" ^ x) ancestors))
	    (* Now check whether we have already seen this module during this
	       call of read_object_dependencies. *)
            else
	      case NewMap.tryApply'(seen, module_id)
              of SOME _ =>
		(diagnostic (3, fn _ => ["seen it!"]);
	         (units, seen))
	      |  NONE =>
	        (case check_module' () of
  	           (units', 
		    SOME (UNIT {object =
			    ref (SOME {consistency = DEPEND_LIST (_ :: const),
				       ...}),
			    (* We skip the pervasive library entry. *)
			  ...})) =>
  	             Lists.reducel recurse ((units', seen), const)
		 | (units', NONE) => (units', seen)
	         | _ =>
                     Info.error'
                       error_info
                       (Info.FATAL, Info.Location.FILE mod_name,
		        "Invalid consistency information"))
                 handle Io.NotSet _ =>
                   Info.error'
                     error_info
                     (Info.FATAL, location, "Pervasive directory not set")
	  end

	(* Even though this is read_object_dependencies, we still need
	   the source information for the main file, or else we can't
	   compile it! *)
  	fun check_src' (unit, src_info) =
  	  case !src_info
  	  of sml_info as SOME (filename, time_stamp) =>
  	    (* Check whether the file on disk has changed *)
	    (let
	       val mod_time = FileTime.modTime filename
	     in
	       if time_stamp = mod_time then
		 ()
	       else
		 load_src
		   (false, error_info, SOME (filename, mod_time), unit, object_dir)
	     end handle OS.SysErr _ => 
	       (mesg_fn (location,
			 "Source file " ^ filename ^ " has disappeared");
  	        load_src
		  (false, error_info,
		   findSource (files, module_id),
		   unit, object_dir)))
  	  |  NONE => 
  	    load_src
	      (false, error_info,
	       findSource (files, module_id),
	       unit, object_dir)
    
	(* First, load the source info for the file being compiled. *)
	val (units, UNIT unit) =
  	  case NewMap.tryApply' (units, module_id)
  	  of SOME (unit as UNIT {source, ...}) =>
  	    (check_src' (unit, source);
  	     (units, unit))
  	  |  NONE =>
  	    let
  	      val sml_info =
		findSource (files, module_id)
  	    in
	      new_unit
	        error_info
	        (false, units, module_id, sml_info, NONE, NONE, object_dir)
  	    end

        val (units', seen') =
	  let
	    val mod_name = ModuleId.string module_id

	    fun recurse ((units, seen), require_id) =
	      read_object_dependencies'
		(Location.FILE mod_name, [mod_name])
		(require_id, (units, mark_visited (seen, module_id)))
	  in
  	    Lists.reducel recurse ((units, seen_init), 
                                   requires_from_unit (UNIT unit))
	  end
      in
        (PROJECT
	   {name = name,
	    units = units',
	    files = files,
	    library_path = library_path,
	    object_dir = object_dir,
	    subprojects = subprojects,
	    current_targets = current_targets,
	    disabled_targets = disabled_targets,
            dependency_info = dependency_info},
	 seen')
      end

  (* The following functions check whether the info in a project is
     consistent. *)

  (* compare_timestamp allows time stamps to differ by up to 5 seconds from
     the modification time of the file, to allow for InstallShield's unpleasant
     behaviour.  Now that we store time stamps in the consistency information
     of object files, instead of the modification times of the dependent files
     themselves, this doesn't affect us directly.  But it could affect people
     who distribute both source and object files.
     This function should be used whenever a time stamp stored in an object
     file is compared against the actual modification time of a source file.
     It is not needed when two stored time stamps are compared, or when the
     modification times of two source files are compared.  All comparisons
     of file times in _project are commented to explain whether
     compare_timestamp is needed. *)     
  fun compare_timestamp (t1, t2) =
    let
      val diff =
	if Time.<(t1, t2) then Time.-(t2, t1) else Time.-(t1, t2)
      val rdiff = Time.toReal diff
    in
      rdiff < real(5)
    end

  (* check_one_mo checks the time stamp of a given mo file against a
     supplied time.  The supplied time is always from the consistency
     information stored in an object file.  Since both times are read
     from object files, there is no need to use compare_timestamp. *) 
  fun check_one_mo (location, time, UNIT unit, sub_module_name) =
    case !(#object unit)
    of SOME {time_stamp, ...} =>
      (* if time = time_stamp then *)
      (* The encapsulator dumps out times as two integers, and it produces
         these two integers by first converting the time to a real.  If the 
         original time contained fractions of a second then these can be lost
         in the conversion.  So if file modification times can contain 
         fractions of a second then a simple equality check at this point can
         fail.  This seems to happen on FAT file systems for example.  So until
         the encapsulater is changed to dump times in a more reliable fashion
         we check to see if the times are the same to within a second. *)
      if Real.abs(Time.toReal time - Time.toReal time_stamp) < 1.0 then
	(diagnostic (3, fn _ => ["Time OK for `", sub_module_name, "'"]);
	 true)
      else
	(diagnostic (3, fn _ => ["Time mismatch for `", sub_module_name, "'"]);
	 false)
    |  NONE =>
      (mesg_fn (location,
		"can't find object info for `" ^ sub_module_name ^ "'");
       false)

  (* check_one_loaded checks the load time of a given module against a
     supplied time.  This time is usually from the dependency list of
     a loaded module, which stores the time that the dependent module
     was loaded.  If the times differ, the module containing the dependency
     list is out of date.
     The exceptional case is when check_one_loaded is called from is_valid_object
     (see that definition for an explanation).
     Since these times are not the modification times of delivered files, 
     there is no need to use compare_timestamp.  *)
  fun check_one_loaded
	(location, load_time', UNIT unit, sub_module_name) =
    case !(#loaded unit)
    of SOME {load_time, ...} =>
      if load_time = load_time' then
	(diagnostic (2, fn _ => ["load time OK for `", sub_module_name, "'"]);
	 true)
      else
	(diagnostic (2,
   	   fn _ => ["old load time for `", sub_module_name, "'"]);
	 false)
    |  NONE =>
      (mesg_fn (location,
	        "can't find loaded info for `" ^ sub_module_name ^"'");
       false)
  
  (* check_sub_unit checks one entry from a consistency list against the info
     stored in a project.  It requires the project to hold up-to-date info. *)
  fun check_sub_unit
	(error_info, location, project, check_perv, check_normal)
	{mod_name, time} =
    case ModuleId.from_string' mod_name
    of NONE =>
      (mesg_fn
	 (location,
          "invalid module name `" ^ mod_name ^ "' -- treating as out of date");
       false)
    |  SOME sub_module_id =>
      case get_unit (project, sub_module_id)
      of SOME unit =>
	if ModuleId.is_pervasive sub_module_id then
	  (diagnostic (3, fn _ => ["Calling check_perv for `", mod_name, "'"]);
	  check_perv (location, time, unit, mod_name))
	else
	  check_normal (location, time, unit, mod_name)
      |  NONE =>
        (diagnostic (1,
           fn _ => ["Module name `", mod_name,
		    "' from object file not found in project\n",
	            "-- treating as out of date"]);
	 false)

  (* check_dependencies checks a dependency list against the info stored in
     a project.  It returns true if the information is consistent.  *)
  fun check_dependencies
	(error_info, location)
        (proj, dependencies, check_one) =
    Lists.forall
      (check_sub_unit (error_info, location, proj, check_one, check_one))
      dependencies
  
  (* The following functions are passed to check_dep, to parameterise it on
     the sort of compiled objects being checked, .mo files or loaded modules. *)

  (* These validity checks are called to check that the files are safe to
     be loaded at all, in circumstances when we can't bring them up to date
     (e.g. loading object files without recompiling). *)

  fun always_valid _ _ args = args

  fun is_valid_object
	(error_info, location)
	(proj, level, module_id, UNIT unit)
	args =
	case !(#object unit) of
	  NONE =>
	    Info.error'
	    error_info
	    (Info.FATAL, location,
	     "No object file for : `" ^ ModuleId.string module_id ^ "'")
	| SOME {file_time, time_stamp, consistency = DEPEND_LIST cons, ...} =>
	    (* This rather convoluted construct suggests that Lists.findp
	     should really return an option type. *)
 	    (* check_sub_unit is passed check_one_loaded to check the pervasive
	       library.  This works because when the GUI images are built, the
	       loaded info for the pervasive modules is reset to store the
	       time stamps of the files (see reset_pervasives, below). *)
	    (case
	       Lists.findp
	         (not o
		  (check_sub_unit
	           (error_info, location, proj, check_one_loaded, check_one_mo)))
	         cons of
	       {mod_name, ...} =>
		 Info.error'
		   error_info
                   (Info.FATAL, location,
                    "Object file '" ^ ModuleId.string module_id ^
		    "' is out of date with respect to `" ^ mod_name ^ "'"))
	    handle
	      Lists.Find =>
	        (diagnostic (3, fn _ => ["object is valid"]);
	         args)

  (* check_compile_times checks the timestamp in an object file against the
     modification time of the corresponding source file.  If they are equal,
     it then calls check_dependencies to check the object file's consistency
     information. *)
  fun check_compile_times
	(error_info, location)
	(project, module_id, UNIT unit) =
    case !(#source unit)
    of NONE =>
      (* If no source file exists, we assume that the object file
         is up to date. *)
      (diagnostic (2, fn _ => [" no source unit"]);
       true)
    |  SOME (s_file, s_time) =>
      case !(#object unit)
      of SOME {time_stamp, consistency = DEPEND_LIST dependencies, ...} =>
	(* Since we are comparing a stored time stamp against the modification
	   time of an actual file, we use compare_timestamp to allow for
           slippage. *)
        if compare_timestamp (time_stamp, s_time) then
	  (diagnostic (2,
   	     fn _ => ["`", ModuleId.string module_id, "': source stamp OK"]);
	   check_dependencies
	     (error_info, location)
	     (project, dependencies, check_one_mo))
	else
	  false
      |  NONE =>
        (diagnostic (2, fn _ => [" no object file"]);
  	 false)
  (* check_object_load_times and check_object_source_times check the 
     dependencies of a loaded module.  They are complicated by the fact
     that a module may have been loaded from either a source file or an
     object file.

     If the module was loaded from a source file, and the file being 
     loaded is a source file, then it is enough to compare the modification
     time of the file against that in the loaded information. 

     If the module was loaded from a source file, and the file being loaded
     is an object file, or vice versa, then the modification time in the loaded
     info is compared with both the modification time in the source info and
     the time stamp in the object file.  If they are all equal, then the object
     file is equivalent to the loaded module.

     If the module was loaded from an object file, and the file being loaded
     is an object file, then the timestamp of the file being loaded is compared
     against the "modification time" in the loaded information. *)

  fun check_object_load_times
	(error_info, location)
	(project, module_id, UNIT unit) =
    case !(#object unit)
    of NONE =>
      Crash.impossible
        ("No object file for : `" ^ ModuleId.string module_id ^ "'")
    |  SOME {file_time, time_stamp, consistency = DEPEND_LIST cons, ...} =>
      case !(#loaded unit)
      of SOME {file_time = OBJECT time,
	       dependencies = DEPEND_LIST deps, ...} =>
 	(* The time and time_stamp are both read from the object file, so we
           don't need to use compare_timestamp. *)
        if time = time_stamp then
	  (diagnostic (2, fn _ =>
	     ["`", ModuleId.string module_id, "': object stamp OK"]);
	   check_dependencies
	     (error_info, location)
	     (project, deps, check_one_loaded))
	else
	  (diagnostic (2, fn _ =>
	     ["`", ModuleId.string module_id, "': object stamp out of date"]);
	   false)
      |  SOME {file_time = SOURCE time,
	       dependencies = DEPEND_LIST deps, ...} =>
        (case !(#source unit)
         of NONE =>
	   (diagnostic (2,
              fn _ =>
	        ["No source file for loaded compilation unit in load_object: ",
	         ModuleId.string module_id]);
	    (* Assume loaded module is up to date *)
	    true)
         |  SOME (s_file, s_time) =>
           (* We are now comparing a time stamp from an object file with
      	      the actual modification time of the source file, so we use
	      compare_timestamp to allow for slippage.  *)
           if compare_timestamp (time, s_time) then
	     (diagnostic (2, fn _ =>
	        ["`", ModuleId.string module_id, "': source stamp OK"]);
              if compare_timestamp (time_stamp, s_time) then
	        (diagnostic (2, fn _ =>
		   ["`", ModuleId.string module_id, "': object stamp OK"]);
		 (* At this point we know that both the loaded source
		    module and the object file are up to date w.r.t. the
		    source file. *)
	         check_dependencies
	           (error_info, location)
	           (project, deps, check_one_loaded))
	      else
	        (* Object file is older than the source. *)
	        (diagnostic (2, fn _ =>
	           ["`", ModuleId.string module_id, "': old object stamp"]);
	         false))
	   else
	     (* The loaded module is out of date. *)
	     (diagnostic (2, fn _ =>
	        ["`", ModuleId.string module_id, "': old object stamp"]);
	      false))
      |  NONE =>
        (diagnostic (2, fn _ => [" not loaded"]);
         false)

  fun check_source_load_times
	(error_info, location)
	(project, module_id, UNIT unit) =
    case !(#loaded unit)
    of SOME {file_time = SOURCE time, dependencies = DEPEND_LIST deps, ...} =>
      (case !(#source unit)
       of NONE =>
	 (diagnostic (2,
            fn _ =>
	      ["No source file for loaded compilation unit in load_source: ",
	       ModuleId.string module_id]);
	  (* Assume loaded module is up to date, since we can't reload it
	     even if we wanted to. *)
	  true)
       |  SOME (s_file, s_time) =>
	 (* We are comparing the modification time of two source files directly,
   	    so we don't have to allow for slippage; therefore we don't use
	    compare_timestamp. *)
         if time = s_time then
	   (diagnostic (2,
   	      fn _ => ["`", ModuleId.string module_id, "': source stamp OK"]);
	    check_dependencies
	      (error_info, location)
	      (project, deps, check_one_loaded))
	 else
	   (diagnostic (2,
   	      fn _ => ["`", ModuleId.string module_id, "': old source stamp"]);
	    false))
    |  SOME {file_time = OBJECT time, dependencies = DEPEND_LIST deps, ...} =>
      (case !(#object unit)
       of NONE =>
	 (diagnostic (2,
            fn _ =>
	      ["No object file for loaded compilation unit in load_source: ",
	       ModuleId.string module_id]);
	  (* Assume loaded module is up to date *)
	  true)
       |  SOME {file_time, time_stamp, ...} =>
	 (* We are comparing time stamps read from object files, therefore we
	    don't need to use compare_timestamp. *)
         if time = time_stamp then
	   (diagnostic (2,
   	      fn _ => ["`", ModuleId.string module_id, "': object stamp OK"]);
	    case !(#source unit)
	    of NONE =>
	      (* We should allow source files to depend on object files *)
	      (diagnostic (2, fn _ =>
		 ["No source file for `", ModuleId.string module_id,
		  "' assuming object file up to date"]);
	       (* Should check that object file is up to date w.r.t. its
		  dependencies. *)
	       true)
            |  SOME (s_file, s_time) =>
	      (* We are now comparing a time stamp with the actual modification
	         time of a source file.  Therefore we have to allow for slippage
 		 by using compare_timestamp. *)
	      if compare_timestamp (time_stamp, s_time) then
	        (diagnostic (2, fn _ =>
		   ["`", ModuleId.string module_id, "': file time OK"]);
	         check_dependencies
	           (error_info, location)
	           (project, deps, check_one_loaded))
              else
	        (diagnostic (2,
   	           fn _ => ["`", ModuleId.string module_id,
			    "': old file time"]);
	         false))
         else
	   (diagnostic (2,
   	      fn _ => ["`", ModuleId.string module_id, "': old object stamp"]);
	    false))
    |  NONE =>
      (diagnostic (2, fn _ => [" not loaded"]);
       false)

  fun get_sub_mos (UNIT unit) =
    case !(#object unit)
    of NONE => []
    |  SOME {consistency = DEPEND_LIST l, ...} =>
      map
	(fn {mod_name, ...} =>
	   ModuleId.from_mo_string (mod_name, Location.UNKNOWN))
	l

  (* This is used in check_dep to check whether any of the entries in the
     list of requires have already been found to need recompiling. *)
  fun check_visited_map([], _) = true
  |   check_visited_map(x :: xs, visited) =
    case NewMap.tryApply'(visited, x)
    of NONE => check_visited_map(xs, visited)
    |  SOME true => check_visited_map(xs, visited)
    |  SOME false => false

  (* check_dep recursively traverses the info stored in a project, working out
     which files need to be recompiled.  It requires the project info to be
     up to date.  It does not actually compile the out-of-date units.
       check_validity: a function to check the validity of the current unit;
		       raises an exception if invalid; called before checking
		       dependencies.  Returns an updated (out_of_date, visited)
		       pair, which allows check_load_source to check the
		       time stamps of library object files.
       check_times: a function to check the time stamps of the current unit;
		    called only if the dependents are up to date.
       get_sub_units: a function that returns a list of sub_units
       project: the current project info
       module_id: the unit to recompile
       out_of_date: a list of units to be recompiled.
       visited: a status map; stored whether a unit has been visited, or
		up to date. 
       real_ids: a list of the module_ids corresponding to the requires
		in the parent file.
		
     Returns an updated (out_of_date, visited, real_ids) tuple.
     This function may be folded over a list of module_ids.
   *)

  (* This function should check the up-to-dateness of sub-projects as a whole.
   * A sub-project is out of date if any of its files are out of date.  This check
   * can be more easily done if the source path has been replaced by a list of 
   * files. 
   *)
  fun check_dep
        (error_info, level, get_sub_units,
	 check_times, check_validity, project as PROJECT {units, subprojects, ...})
        ((out_of_date, visited, real_ids), module_id) =
    (* The following test is commented out because we now only track the
       real module_id, which may be different (see below).  Possibly the
       read_dependencies function should add a pass so that the requires
       line of each unit contains only real module_ids.  It all depends
       where we want the time to go. *)
    (*
    if NewMap.exists (fn (m, _) => m = module_id) visited then
      (out_of_date, visited)
    else
    *)
      let
	val mod_name = ModuleId.string module_id
  
        val _ =
	  diagnostic (2,
   	    fn _ => [Int.toString level, " `", mod_name, "'"]);

	fun undefined_module mod_id  = 
  	  Crash.impossible ("Undefined module: " ^ ModuleId.string mod_id)

	fun get_defined_unit mod_id = 
	  case get_unit (project, mod_id)
	  of SOME unit => unit
	   | NONE => undefined_module mod_id

	val UNIT unit = get_defined_unit module_id
    
	val real_mod_id = #name unit
	(* The real module_id for this unit is #name unit.  This may differ
	   from the module_id that was passed as an argument, because
	   #name unit has resolved any symbolic links.  Not all aliases are
	   stored in a project, e.g.  if "system.__path" resolves to
	   "unix.__path", and this contains a require for "unix._unixpath",
	   then "system._unixpath" will not be found in the project, even
	   though it is a valid id. *)

	val unit_time = case !(#object unit) of
	  NONE => NONE
	| SOME{file_time, ...} => SOME file_time

	fun check_object_time module_id =
	  (* This function checks the relationship between the object files *)
	  (* for the module parameter to check_dep, and some module it depends on *)
	  (* It returns true for up to date, false for out of date *)
	  case unit_time of
	    NONE => false (* Definitely out of date, but probably shouldn't happen *)
	  | SOME unit_time =>
	      let
		val UNIT sub_unit = get_defined_unit module_id
	      in
		case !(#object sub_unit) of
		  NONE => false (* This shouldn't happen, as this case shouldn't be passed to check_object_time *)
		| SOME{file_time, ...} => Time.>=(unit_time, file_time)
	      end
      in
        if NewMap.exists (fn (m, _) => ModuleId.eq(m,real_mod_id)) visited then
	  (out_of_date, visited, real_mod_id :: real_ids)
	else
	  let
	    val (out_of_date, visited, _) =
	      check_validity
		(error_info, Location.FILE mod_name)
		(project, level, module_id, UNIT unit)
	        (out_of_date, visited, [])

	    val sub_units = get_sub_units (UNIT unit)

            (* Check all the sub_modules *)
            val (out_of_date_now, visited_now, real_sub_ids) =
              Lists.reducel
    	        (check_dep
	           (error_info, level + 1, get_sub_units,
		    check_times, check_validity, project))
    	        ((out_of_date, visited, []), sub_units)
          in
            (* We have to recompile this unit if any of its sub-units need to
               be recompiled, or if the source for this one has been changed
	       (or if it has no object file). *)
	    (*
            if out_of_date_now = out_of_date
	    We could add a quick test here, but comparing the whole list
	    is unnecessary.  If the first elements are different, that
	    will be enough (we would also need to check the nil case).
	    *)
	    if check_visited_map (real_sub_ids, visited_now) andalso
	      check_times
	      (error_info, Location.FILE mod_name)
	      (project, module_id, UNIT unit) andalso
	      Lists.forall check_object_time sub_units
	    then
  	      (* we are up to date *)
              (out_of_date_now, 
	       mark_compiled (visited_now, real_mod_id),
	       real_mod_id :: real_ids)
            else
              (real_mod_id :: out_of_date_now,
	       mark_visited (visited_now, real_mod_id),
	       real_mod_id :: real_ids)
          end
      end
    
  
  (* USER COMMANDS START HERE *)
  
  (* Initialise: create a new project.  Load info about the pervasive files.
     Load_dependencies: given a file name, recursively load source dependencies
        from that file.  If project already contains info about this unit,
        check the modification time of the source and object files.  If the
        project doesn't have info about this file, or the a file has changed,
        load info from disk.  If the source file has changed, read the requires
        from the new file.  If adding an entry, check for an object file.  If
        project contains no info and source file doesn't exist, check for an
        object file, but don't follow its dependencies.  (We will need to
        improve on this, differentiating source dependencies and object
        dependencies).
  *)
  
  (* list_units returns a list of the names of the modules in a project,
     as pairs of strings and module_ids, sorted alphabetically. *)
  fun list_units (PROJECT {units, ...}) =
    Lists.msort
      (fn ((s, _), (s', _)) => s < s')
      (map (fn m => (ModuleId.string m, m)) (NewMap.domain units))
  
  (* The initialize command creates an empty project *)
  fun initialize (error_info, location) =
    let
      val project =
        PROJECT
          {name = "",  (* WWW: should this be the empty string or something else? *)
	   units = NewMap.empty (ModuleId.lt, ModuleId.eq),
           files = [],
           library_path = [],
           object_dir = {base = "", config = "", mode = ""},
	   subprojects = [],
           current_targets = [],
           disabled_targets = [],
           dependency_info = DEPEND([],[])}
    in
      #1 (do_read_dependencies
            (error_info, location)
            (project, Io.pervasive_library_id, empty_map) false)
    end
  
  (* Not clear what this should do now. *)
  fun delete (PROJECT {name, units, files, library_path, object_dir,
		       subprojects, current_targets, disabled_targets, dependency_info}, 
	      module_id,
	      delete_from_sub) =
    PROJECT
      {name = name,
       units = NewMap.undefine (units, module_id),
       files = files,
       library_path = library_path,
       object_dir = object_dir,
       subprojects = if delete_from_sub then 
			map (fn p => delete (p, module_id, true)) subprojects
		     else 
		 	subprojects,
       current_targets = current_targets,
       disabled_targets = disabled_targets,
       dependency_info = DEPEND([],[])}

  fun display_dependency_info (info as h :: t) =
      let
        open MLWorks.Internal.Array
        val _ = print "Displaying dependencies\n"
        val max_node = 
            foldl (fn ((set, GD.DAG {seq_no,...}),max) => Int.max(max, seq_no))
                  0 info
        val info_array = array(max_node + 1, h)
        val _ = app (fn info_node as (set, GD.DAG {seq_no,...}) =>
                       update(info_array, seq_no, info_node)) info

        fun display_dependency 
              (set, GD.DAG {seq_no,marked,smlsource,symmap,intern,extern}) = 
            (print(ModuleId.string smlsource); print " (";
             print (ImportExport.ModuleName.setToString set); 
             print ")\n";
             app (fn GD.DAG {smlsource, ...} =>
                  print ("  -> " ^ (ModuleId.string smlsource) ^ "\n"))
                 (OrderedSet.makelist intern)
            )
(*
         fun loop n = if n > max_node then ()
                      else ( display_dependency(sub(info_array, n));
                             loop (n + 1) )
*)
       in (* loop 0; *)
          app display_dependency info;        
          print "Done\n"
      end
    | display_dependency_info [] = ()

  fun calculate_dependency_info (name, files, units, all_targets, env_fn) =
      let val _ = diagnostic (1, fn _ => ["Calculating dependencies for ", 
                                          name])
          val all_target_mids =
            map (fn t => ModuleId.from_host(t, Location.FILE t)) 
                all_targets
        
          fun is_target m =
              List.exists (fn m' => ModuleId.eq(m,m')) all_target_mids

          fun cvt m = 
              let val UNIT {mod_decls, ...} = valOf(NewMap.tryApply' (units, m))
               in (m, #1(!mod_decls), is_target m) end
              handle exn => 
                (print "cvt error!\n"; 
                 print("Looking for " ^ (ModuleId.string m) ^ "\n");
                 app (fn m => print("  " ^ (ModuleId.string m) ^ "\n"))
                     (NewMap.domain units);
                 raise exn)

          val units_list = 
              map cvt 
                (Lists.filterp (not o ModuleId.is_pervasive) (NewMap.domain units))
          fun eq_dag (GD.DAG { seq_no = s1, ... }: dag,
              GD.DAG { seq_no = s2, ... }) = s1 = s2
          fun lt_dag (GD.DAG { seq_no = s1, ... }: dag,
	      GD.DAG { seq_no = s2, ... }) = s1 < s2
          val { union = union_dag, addl = addl_dag, makeset = makeset_dag, ... } =
              OrderedSet.gen { eq = eq_dag, lt = lt_dag }

          val dependencies = 
              GD.analyze { union_dag = union_dag,
                       smlsources = units_list,
                       enone = empty_mid_set,
                       eglob = env_fn,
                       ecombine = union_mid_set,
                       seq_no = ref 0 }
          fun unit_of m = valOf(NewMap.tryApply' (units, m))

          fun update_requires
                (set, GD.DAG {seq_no,marked,smlsource,symmap,intern,extern}) = 
              let val UNIT unit = unit_of smlsource
                  val {implicit, explicit, subreqs} = !(#requires unit)
                  val implicit = 
                    map (fn GD.DAG {smlsource, ...} => smlsource)
                        (OrderedSet.makelist intern)
                  val subreqs = OrderedSet.makelist extern
                  fun eq m1 m2 = ModuleId.eq(m1,m2)
                  val explicit =
                    List.filter (not o (member_mid_set extern)) explicit
                  val (_, partial_info) = !(#mod_decls unit)
               in case explicit of
                    [] => #requires unit := {explicit=[], implicit=implicit,
                                             subreqs=subreqs}
                  | _ =>
                      let fun print_warning (m, missing, definite) =
                            if partial_info then () else
                            ( print ( "Require of " 
                                    ^ (ModuleId.string m)
                                    ^ " in unit " 
                                    ^ (ModuleId.string smlsource));
                              if missing
                              then
                                print " is missing.\n"
                              else if definite then 
                                print " is unnecessary.\n"
                              else
                                 print " may be unnecessary.\n" )
                      in
                        app (fn m =>
                               if List.exists (eq m) implicit
                               then ()
                               else 
                                 case NewMap.tryApply' (units, m) of
                                   NONE =>
                                     if true (* redundant_requires *)
                                     then ()
                                     else print_warning(m,false,true) 
                                 | SOME _ =>
                                     print_warning(m,false,false))
                            explicit;
                        app (fn m =>
                               if List.exists (eq m) explicit
                               then ()
                               else print_warning(m,true,false))
                            implicit;
                       
                        #requires unit := 
                        {explicit=explicit, implicit=implicit, subreqs=subreqs}
                      end
               end

       in app update_requires dependencies;        
          dependencies
    end handle _ => []


  fun read_dependencies info (p, m, smap) =
    let
      val _ = 
        diagnostic (1,
          fn _ => ["Calling read_dependencies on pervasive library"]);

      val (p', smap') =
	do_read_dependencies
	  info
	  (p, Io.pervasive_library_id, smap) 
	  true
    in
      diagnostic (1,
        fn _ => ["Calling read_dependencies on " ^ ModuleId.string m]);
      do_read_dependencies info (p', m, smap') false
    end

  (* The check commands take a module_id and calls check_dep to find which
     files need to be recompiled to bring that module up to date. *)
  fun check_load_objects (error_info, location) (project, module_id) = 
    let
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, get_sub_mos,
	   check_object_load_times, is_valid_object, project)
	  (([], visited_pervasives, []), module_id)
    in
      rev out_of_date
    end

  fun source_exists
	(error_info, location)
	(project, level, module_id, UNIT unit)
	(out_of_date, visited, real_ids) =
    case !(#source unit)
    of NONE =>
      let
	(* If an object file exists, check it. *)
        val sub_units = get_sub_mos (UNIT unit)
      in
        (* Check all the sub_modules *)
        Lists.reducel
          (check_dep
            (error_info, level + 1, get_sub_mos,
	     check_object_load_times, is_valid_object, project))
    	   ((out_of_date, visited, []), sub_units)
      end
    |  _ => (out_of_date, visited, real_ids)

  fun check_load_source (error_info, location) (project, module_id) = 
    let
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, requires_from_unit,
	   check_source_load_times, source_exists, project)
	  (([], visited_pervasives, []), module_id)
    in
      rev out_of_date
    end

  fun check_compiled (error_info, location) (project, module_id) = 
    let
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, requires_from_unit,
	   check_compile_times, always_valid, project)
	  (([], visited_pervasives, []), module_id)
    in
      rev out_of_date
    end

  (* The check_compiled' command takes a module_id and calls check_dep
     to find which files need to be recompiled to bring that module up to
     date.  It differs from check_compiled in that it takes explicit
     (out_of_date, visited) arguments, and returns updated versions of both. *)
  fun check_compiled'
	(error_info, location) (project, module_id) (out_of_date, visited) =
    let
      val (out_of_date_now, visited_now, _) =
        check_dep
	  (error_info, 0, requires_from_unit,
	   check_compile_times, always_valid, project)
	  ((rev out_of_date, visited, []), module_id)
    in
      (rev out_of_date_now, visited_now)
    end

  (* The check_perv commands call check_dep to find which files need
     to be recompiled to bring the pervasive library up to date. *)
  fun check_perv_compiled (error_info, location) project = 
    let
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, requires_from_unit,
	   check_compile_times, always_valid, project)
	  (([], empty_map, []), Io.pervasive_library_id)
    in
      rev out_of_date
    end

  fun check_perv_loaded (error_info, location) project = 
    let
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, requires_from_unit,
	   check_source_load_times, always_valid, project)
	  (([], empty_map, []), Io.pervasive_library_id)
    in
      rev out_of_date
    end

  (* allObjects returns a list of all object files, ordered by
     dependency.  It is used to write a file for use by the loader. *)
  fun allObjects (error_info, location) (project, module_id) =
    let
      (* The check_times argument to check_dep always returns false,
	 so that every file is added to the list.
	 XXX I attempted to call is_valid_object to check that the object
	     files are up to date.  But is_valid_object checks validity
	     w.r.t. loaded pervasive library (i.e. for loading into the
	     GUI).
	 XXX I'm not sure about get_sub_mos: it silently returns an
	     empty list is the unit doesn't include any object info.
	     But is_valid_object should catch this case first. *)
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, get_sub_mos,
	   fn _ => fn _ => false, always_valid, project)
	  (([], empty_map, []), module_id)
    in
      rev out_of_date
    end

  (* reset_pervasives is called after loading the pervasive files into
     the interpreter.  It ensures that the load time of the pervasive
     modules is kept, but that information about the files on disk is
     removed.  The key difference with remove_file_info (below) is that
     we currently compile the pervasives from source, but need to store
     info about the object files in the loaded field.  *)
  local
    fun reset_file_info (_, UNIT unit) =
      (* First we store the time_stamp of the compiled pervasive file in
         the loaded information, so that we don't load objects that were
         compiled with different pervasives. *)
      let
        val r = #loaded unit
      in
        case !(#object unit) of
	  SOME {time_stamp, file_time = object_time, ...} =>
	    (case !r of
	       SOME {basis, id_cache, module, dependencies, ...} =>
		 r := SOME
		 {file_time = OBJECT object_time,
		  load_time = time_stamp,
		  basis = basis,
		  id_cache = id_cache,
		  module = module,
		  dependencies = dependencies}
	     (* Preserve the dependencies, because type decapsulation needs them *)
	     | NONE =>
		 Crash.impossible
		 ("Can't find loaded info for `"
		  ^ ModuleId.string (#name unit)
		  ^ "' in reset_pervasives"))
        | NONE =>
	       Crash.impossible
	       ("Can't find object file for `"
		^ ModuleId.string (#name unit)
		^ "' in reset_pervasives");
	       #object unit := NONE;
	       #source unit := NONE;
	       #requires unit := {implicit=[],explicit=[],subreqs=[]}
      end
  in
    fun reset_pervasives (PROJECT {units, ...}) =
      NewMap.iterate 
        reset_file_info
        units
  end

  (* This is used to remove all path names when we save an image. *)
  local
    fun reset_file_info (_, UNIT unit) =
      (#object unit := NONE;
       #source unit := NONE;
       #requires unit := {implicit=[],explicit=[],subreqs=[]})
  in
    fun remove_file_info (PROJECT {units, subprojects, ...}) =
      (NewMap.iterate 
	reset_file_info
	units;
       app remove_file_info subprojects)
  end
    
  fun pad_out_units(files, units, updating, library_path, object_dir, error_info) =
      let fun pad ([], units) = units
            | pad (filename::t, units) =
                let val location = Location.FILE filename
                    val module_id = 
                      ModuleId.from_host (OS.Path.file filename, location) 
                 in case NewMap.tryApply' (units, module_id) of
                      SOME unit => 
                        if updating 
                        then 
                          ( check_src (unit, module_id, false, 
                                       files, error_info, location, object_dir);
                            check_obj (unit, module_id, false, 
                                       library_path, object_dir, location);
                            pad(t, units))
                        else 
                          pad(t, units)
                    | NONE =>
                        let val src_info = 
                              let
                                val mod_time = FileTime.modTime filename
                              in
                                SOME (filename, mod_time)
                              end
                              handle OS.SysErr _ => NONE
                            val (units', unit) = 
                              new_unit
                               error_info
                               (false, units, module_id, src_info, 
                                NONE, NONE, object_dir);

                            (* Don't search lib path if we have source *)
                            val lib_path_opt =
                              if isSome src_info 
                              then NONE else SOME library_path
                         in
                           load_object
                             (findObject (object_dir, lib_path_opt, module_id))
                             unit;
                           pad(t, units')
                        end
                end
         val units' = pad(files, units)

         val (units_plus_builtin,_) = 
            check_module(Io.builtin_library_id, true,
                   units',files,[],library_path,object_dir,
                   error_info, Location.UNKNOWN)
         val (units_plus_builtin_plus_pervasive,_) = 
            check_module(Io.pervasive_library_id, true,
                   units_plus_builtin,files,[],library_path,object_dir,
                   error_info, Location.UNKNOWN)
       in 
         units_plus_builtin_plus_pervasive
      end

  fun partition_dependencies current_targets dependencies =
      let 
        val current_target_mids =
          map (fn t => ModuleId.from_host(t, Location.FILE t)) 
              current_targets
          
        fun is_current_target m =
            List.exists (fn m' => ModuleId.eq(m,m')) current_target_mids
      in
        List.partition
          (fn (_, GD.DAG{smlsource, ...}) => is_current_target smlsource)
          dependencies
      end

  fun lookup_function units =
      let
        fun cvt m = 
            let val UNIT {mod_decls, ...} = valOf(NewMap.tryApply' (units, m))
             in (m, #1(!mod_decls)) end

        val (pervasives', _) = 
              Lists.partition ModuleId.is_pervasive (NewMap.domain units)
        val pervasives_list = map cvt pervasives'

        fun mk_lookup (name, decl, default) =
            ImportExport.imports (decl, empty_mid_set, default, union_mid_set, name)

        val Compiler.BASIS{lambda_environment, ...} =
            Compiler.initial_basis

        val initial_env_fn = 
            fn m => raise ImportExport.Undefined m

        val env_fn =
          case pervasives_list of
            [(builtin, builtin_dec), (pervasive, pervasive_dec)] =>
               let val env_fn' =
                     let val (f, i, _) =
                         mk_lookup(ModuleId.string builtin, 
                                   builtin_dec, initial_env_fn)
                      in fn m => (f m,i)
                     end
                   val env_fn'' =
                     let val (f, i, _) =
                         mk_lookup(ModuleId.string pervasive, 
                                   pervasive_dec, env_fn')
                      in fn m => (f m,i)
                     end
               in
                 fn m => env_fn'' m
                         handle ImportExport.Undefined _ =>
                                env_fn' m
                                handle ImportExport.Undefined _ => 
                                       initial_env_fn m
               end
          | _ => initial_env_fn

        fun lookup subprojects modulename =
          let open ImportExport
              fun search [] = 
                    env_fn modulename
                | search ((project as 
                           PROJECT {dependency_info = DEPEND (depinfo,_), 
                                    ...})
                          :: t) =
                    let fun find_in [] = search t
                          | find_in ((set, GD.DAG {symmap,smlsource, ...}) :: rest) =
                              if ModuleName.memberOf set modulename
                              then (symmap modulename, singleton_mid_set smlsource)
                              else find_in rest
                     in find_in depinfo end
           in search subprojects 
          end
   in lookup 
  end

  (* The idea of preserving the units is not to lose information about
     loaded files.  But this doesn't really work, because if the source
     path changes some of the loaded information will be out of date. *)
  fun fromFileInfo
	(error_info, loc)
	(proj as (PROJECT {units, subprojects, ...})) =
    let
      fun getFullFilename (filename, dirName) = 
        let 
          val local_name = OS.Path.fromUnixPath filename
	  val abs_name = OS.Path.mkAbsolute {path=local_name, relativeTo=dirName}
        in
	  abs_name
        end

      val (projName, projDir) = 
	(getOpt (ProjFile.getProjectName(), ""),
	 ProjFile.getProjectDir())

      val projectName = getFullFilename (projName, projDir)

      val (curTargets, disTargets, _) =
	ProjFile.getTargets ()

      val (libraryPath, objectsLoc, binariesLoc) =
	ProjFile.getLocations ()

      val (_, configDetails, currentConfig) = ProjFile.getConfigurations ()
      val (_, modeDetails, currentMode) = ProjFile.getModes ()

      fun toAbs s = OS.Path.mkAbsolute {path=s, relativeTo=projDir}

      val common_files = ProjFile.getFiles()

      val (filesC, libraryC, binariesC, config_ext) =
	case currentConfig of
	  NONE => (common_files, libraryPath, binariesLoc, "")
	| SOME name =>
	  (case ProjFile.getConfigDetails (name, configDetails) of
	     {files, library, ...} =>
	        (files @@ common_files,
	         library @@ libraryPath,
		 OS.Path.concat[binariesLoc, name],
                 name))
        (* XXX - handler needed for NoConfigDetailsFound -
	  or put this functionality in ProjFile *)

      val (files, library, binaries, mode_ext) = 
	case currentMode of 
	  NONE => (filesC, libraryC, binariesC, config_ext)
	| SOME modeName => 
	  (case ProjFile.getModeDetails (modeName, modeDetails) of 
	     {location, ...} => 
		(filesC, libraryC, 
		 OS.Path.concat[binariesC, !location],
		 !location))

      val (abs_files, abs_library, abs_objects, abs_binaries) =
	if OS.Path.isRelative projDir then
	  (* projDir should always be absolute, but we need to return some
	     value in the exceptional case. *)
	  (diagnostic (1, fn _ => ["Project Dir is relative: ", projDir]);
	   (files, library, 
            {base = objectsLoc, config = config_ext, mode = mode_ext},
            binaries))
	else
	  (diagnostic (1, fn _ => ["Project Dir is absolute: ", projDir]);
	   (map toAbs files,
	    map toAbs library,
	    {base = toAbs objectsLoc, config = config_ext, mode = mode_ext},
	    toAbs binaries))

      fun mkdir' s = 
	(if OS.FileSys.isDir(s) then 
	  () 
	else 
	  Info.error' error_info 
	    (Info.FATAL, loc,
            s ^ " is not a valid directory or is inaccessable."))
	handle OS.SysErr _ => 
	   (mkdir' (OS.Path.getParent s); OS.FileSys.mkDir s);

      fun mkdir s = mkdir' (OS.Path.fromUnixPath s)

      val mk_obj_dir =
        let val {base, config, mode} = abs_objects 
         in mkdir (OS.Path.mkCanonical(OS.Path.concat[base, config, mode]))
        end

(*      val mk_bin_dir = mkdir abs_binaries *)

      fun get_proj_units projName (PROJECT {name, subprojects, units, ...}) = 
	if (projName = name) then
	  SOME units
	else get_next_proj_units projName subprojects

      and get_next_proj_units projName [] = NONE
	| get_next_proj_units projName (p::rest) = 
	case (get_proj_units projName p) of
	  SOME u => SOME u
	| NONE => get_next_proj_units projName []

      val units' = pad_out_units(abs_files, units, false, abs_library, abs_objects, error_info) 

      val lookup = lookup_function units'

      val project_cache = ref empty_project_cache
 
      fun getSubDetails config filename = 
	let val filename = getFullFilename (filename, projDir)
            val {name, files, libraryPath, objectsLoc, binariesLoc, 
                 configDetails, modeDetails, subprojects, 
                 curTargets, disTargets, currentMode, ...} = 
                     ProjFile.peek_project filename
        in case NewMap.tryApply' (!project_cache, 
               {filename = filename, targets = curTargets}) of 
             SOME subproject => subproject
           | NONE =>
               let 
                   val {name=configName, files=filesC, library=libraryC} = 
                        ProjFile.getConfigDetails (getOpt(config, ""),
                                                   configDetails)
                        handle ProjFile.NoConfigDetailsFound c => 
                          {name = "", files = [], library = []}

                   val modeName = getOpt(currentMode, "")

                   val {location, ...} = 
                     ProjFile.getModeDetails (modeName, modeDetails)
                     handle ProjFile.NoModeDetailsFound m =>
                     Info.error' error_info
                       (Info.FATAL, loc, 
                        "No mode found or none set when getting details of sub projects")

                   val dir = OS.Path.dir name
                   fun mk_abs f = OS.Path.mkAbsolute {path=f, relativeTo=dir}
                   val abs_files = map mk_abs (files @@ filesC)
                   val abs_library = map mk_abs (libraryPath @@ libraryC)
                   val abs_objects = 
                     {base = 
                         OS.Path.mkAbsolute {path=objectsLoc, relativeTo=dir},
                      config = configName, mode = !location }
                   val abs_binaries = 
                     OS.Path.mkAbsolute 
                       {path=OS.Path.concat[binariesLoc, configName, !location], 
                        relativeTo=dir}

                   val subprojDir = OS.Path.dir filename
                   fun getProjName n = getFullFilename (n, subprojDir)
                   val subprojects = map getProjName subprojects
                   val units = getOpt (get_proj_units name proj, NewMap.empty (ModuleId.lt, ModuleId.eq))
                   val units' = pad_out_units(abs_files, units, false, abs_library, abs_objects, error_info) 
                   val subprojects = map (getSubDetails config) subprojects
                   val dependency_info = DEPEND([],[])
                   val subproject = 
                     PROJECT {name = name,
                       units = units',
                       files = abs_files,
                       library_path = abs_library,
                       object_dir = abs_objects,
                       subprojects = subprojects,
                       current_targets = curTargets,
                       disabled_targets = disTargets,
                       dependency_info = dependency_info}
                in
                  project_cache := 
                    NewMap.define (!project_cache, 
                       { filename=filename,
                         targets=curTargets }, 
                       subproject);
                  subproject
               end
	end 

      val subprojects = 
	if isSome(ProjFile.getProjectName()) then
	  let val proj_name = valOf(ProjFile.getProjectName())
	  in
	    map (getSubDetails currentConfig) (ProjFile.getSubprojects())
	  end
	else []

      val dependency_info = DEPEND([],[])

      val new_proj =
        PROJECT
          {name = projectName,
	   files = abs_files,
           library_path = abs_library,
           object_dir = abs_objects,
	   subprojects = subprojects,
           current_targets = curTargets,
           disabled_targets = disTargets,
           dependency_info = dependency_info,
           units = units'} (* getOpt (get_proj_units projectName proj, NewMap.empty' ModuleId.lt)} *)

    in
      ignore(ProjFile.changed());
      new_proj
    end
    
  fun update_dependencies (error_info, loc) proj =
  let 
    fun update (proj as PROJECT {name, units, files, library_path, object_dir,
                   subprojects, current_targets, disabled_targets,
                   dependency_info}) = 
        let   
          val units' = pad_out_units(files, units, true, library_path, 
                                     object_dir, error_info) 

          val lookup = lookup_function units'

          val (current, other) =
              partition_dependencies current_targets
                 (calculate_dependency_info(name, files, units',
                                            current_targets @@ disabled_targets,
                                                  lookup subprojects))
          val dependency_info' =DEPEND (current,other)

          val proj' = PROJECT
            {name = name, units = units', files = files,
             library_path = library_path, object_dir = object_dir,
             subprojects = subprojects, dependency_info = dependency_info',
             current_targets=current_targets, disabled_targets=disabled_targets}

          val init_proj =
            #1 (do_read_dependencies
                 (error_info, loc)
                  (proj', Io.pervasive_library_id, empty_map)
    	      true)

          fun do_one (target, (p, smap)) =
            do_read_dependencies
        	  (error_info, loc)
	          (p, ModuleId.from_host (target, loc), smap)
	          false

          val result =
            if null current_targets then 
              no_targets (error_info, loc) name
            else
              #1 (foldl do_one (init_proj, empty_map) current_targets)
        in
         result
       end 
   in (* map_dag *) update proj
  end
end


@


1.73.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a4 4
 * Revision 1.73  1999/03/18  08:52:50  mitchell
 * [Bug #190532]
 * Implement map_dag
 *
@


1.72
log
@[Bug #190526]
Fix problem with object_dir when no configuration
@
text
@d5 4
d543 29
a637 10
  fun get_subprojects (proj as PROJECT{subprojects,...}) = subprojects

  fun set_subprojects (PROJECT{name,units,files,library_path,object_dir,
                               current_targets,disabled_targets,
                               dependency_info,...}, subprojects) =
    PROJECT{name=name,units=units,files=files,library_path=library_path,
            object_dir=object_dir,current_targets=current_targets,
            disabled_targets=disabled_targets,dependency_info=dependency_info,
            subprojects=subprojects}

d2812 1
a2812 1
  fun update_dependencies (error_info, loc) =
d2814 3
a2816 7
    val project_cache = ref empty_project_cache

    fun update (proj as PROJECT {name, current_targets, subprojects, ...}) =
      case NewMap.tryApply' (!project_cache, 
                   {filename = name, targets = current_targets}) of 
        SOME project => project
      | NONE => 
a2817 5
          val proj as PROJECT {name, units, files, library_path, object_dir,
                   subprojects, current_targets, disabled_targets,
                   dependency_info} =
              set_subprojects(proj, map update subprojects)

a2853 4
          project_cache := 
            NewMap.define (!project_cache, 
              { filename=name, targets=current_targets }, 
              result);
d2856 1
a2856 1
  in update
d2859 1
@


1.71
log
@[Bug #190526]
Put the dependency files below the config.
@
text
@d5 4
d733 4
a736 3
      OS.Path.concat
	[base, config, mode, 
         ModuleId.module_unit_to_string(module_id, object_ext)]
d888 1
a888 1
          else OS.Path.concat[base, config])
d912 1
a912 1
          else OS.Path.concat[base, config])
d2674 1
a2674 1
         in mkdir (OS.Path.concat[base, config, mode])
@


1.70
log
@[Bug #190526]
Fix problem with finding dependency files for subprojects
@
text
@d5 4
d501 1
a501 1
       object_dir: {base: string, config_mode_ext: string},
d728 1
a728 1
    fun objectName' ({base, config_mode_ext}, module_id) =
d730 1
a730 1
	[base, config_mode_ext, 
d799 1
a799 1
      objectName' ({base=Io.get_pervasive_dir(), config_mode_ext=""},module_id)
d877 1
a877 1
                object_dir as {base, config_mode_ext}) =
d882 2
a883 1
          if is_pervasive then Io.get_pervasive_dir() else base)
d897 1
a897 1
                object_dir as {base, config_mode_ext}) =
d906 2
a907 1
          if is_pervasive then Io.get_pervasive_dir() else base)
d2099 1
a2099 1
           object_dir = {base="", config_mode_ext=""},
d2630 1
a2630 1
      val (files, library, binaries, config_mode_ext) = 
d2638 1
a2638 1
		 OS.Path.concat[config_ext, !location]))
d2646 1
a2646 1
            {base = objectsLoc, config_mode_ext = config_mode_ext},
d2652 1
a2652 1
	    {base = toAbs objectsLoc, config_mode_ext = config_mode_ext},
d2668 2
a2669 2
        let val {base, config_mode_ext} = abs_objects 
         in mkdir (OS.Path.concat[base, config_mode_ext])
d2724 1
a2724 2
                      config_mode_ext = 
                         OS.Path.concat [configName, !location] }
@


1.69
log
@[Bug #190524]
Add missing require statement to keep bootstrap compiler happy
@
text
@d497 1
a497 1
       object_dir: string,
d724 1
a724 1
    fun objectName' (object_dir, module_id) =
d726 2
a727 1
	[object_dir, ModuleId.module_unit_to_string(module_id, object_ext)]
d795 1
a795 1
      objectName' (Io.get_pervasive_dir(), module_id)
d872 2
a873 1
		SOME (filename, mod_time), unit) =
d878 1
a878 4
          if is_pervasive 
          then Io.get_pervasive_dir() 
          else OS.Path.mkAbsolute {path = #2(ProjFile.getLocations()),
                                   relativeTo = ProjFile.getProjectDir()})
d891 2
a892 1
                UNIT {name, source, requires, mod_decls, ...} ) =
d901 1
a901 4
          if is_pervasive 
          then Io.get_pervasive_dir() 
          else OS.Path.mkAbsolute {path = #2(ProjFile.getLocations()),
                                   relativeTo = ProjFile.getProjectDir()})
d942 1
a942 1
	(is_pervasive, map, module_id, sml_info, mo_info, info_from_mo) =
d958 1
a958 1
      val _ = load_src (is_pervasive, error_info, sml_info, unit)
d1033 1
a1033 1
                 is_pervasive, files, error_info, location)  =
d1043 1
a1043 1
                    SOME (filename, mod_time), unit)
d1052 1
a1052 1
                       unit)
d1057 1
a1057 1
                       unit)))
d1064 1
a1064 1
                   unit)
d1069 1
a1069 1
                   unit)
d1120 1
a1120 1
          (check_src (unit, module_id, is_pervasive, files, error_info, location);
d1133 1
a1133 1
                    (true, units, module_id, sml_info, mo_info, NONE)
d1158 1
a1158 1
                          (false, units, module_id, src_info, NONE, NONE);
d1440 1
a1440 1
	                    (false, units, module_id, NONE, NONE, NONE);
d1513 1
a1513 1
		   (false, error_info, SOME (filename, mod_time), unit)
d1520 1
a1520 1
		   unit)))
d1525 1
a1525 1
	       unit)
d1540 1
a1540 1
	        (false, units, module_id, sml_info, NONE, NONE)
d2093 1
a2093 1
           object_dir = "",
d2456 1
a2456 1
                                       files, error_info, location);
d2474 1
a2474 1
                                NONE, NONE);
d2611 1
a2611 1
      val (filesC, libraryC, objectsC, binariesC) =
d2613 1
a2613 1
	  NONE => (common_files, libraryPath, objectsLoc, binariesLoc)
d2619 2
a2620 2
		 OS.Path.concat[objectsLoc, name],
	         OS.Path.concat[binariesLoc, name]))
d2624 1
a2624 1
      val (files, library, objects, binaries) = 
d2626 1
a2626 1
	  NONE => (filesC, libraryC, objectsC, binariesC)
d2631 2
a2632 2
		 OS.Path.concat[objectsC, !location],
		 OS.Path.concat[binariesC, !location]))
d2639 3
a2641 1
	   (files, library, objects, binaries))
d2646 1
a2646 1
	    toAbs objects,
d2661 5
a2665 1
      val mk_obj_dir = mkdir abs_objects
d2716 4
a2719 3
                     OS.Path.mkAbsolute 
                       {path=OS.Path.concat[objectsLoc, configName, !location],
                        relativeTo=dir}
@


1.68
log
@[Bug #190526]
Move dependency precis files to object directory
@
text
@d5 4
d312 1
@


1.67
log
@[Bug #190524]
File time comparisons should ignore fractions of a second if retrieved from encapsulator
@
text
@d5 4
d870 5
a874 2
        ModuleDecIO.source_to_module_dec (filename, mod_time);
  
d886 19
a904 3
  |   load_src (is_pervasive, error_info, NONE, unit) =
    case unit of
      UNIT {source, requires, ...} =>
d906 4
a909 2
         requires := {explicit=[],implicit=[],subreqs=[]})
  
@


1.66
log
@[Bug #190507]
Change dependency checking messages to diagnostic messages
@
text
@d5 4
d1573 10
a1582 1
      if time = time_stamp then
@


1.65
log
@[Bug #190507]
Merge the CM dependency and existing require mechanisms
@
text
@d5 4
d2115 2
a2116 1
      let val _ = print ("Calculating dependencies for " ^ name ^ "\n");
@


1.64
log
@[Bug #190507]
Require new dependency files, but ignore them for now.
@
text
@d5 4
d388 11
a398 3
	The list of dependencies read from the require declarations in the
	source file.  It is updated by the recompilation process, if the
	modification time of the source file has changed.
d425 4
d435 3
a437 1
     requires: ModuleId.ModuleId list ref,
d452 2
a453 1
     options:  Options.options option ref
d468 1
d483 10
a492 1
       disabled_targets: string list}
d514 5
d559 10
a568 11
  fun requires_from_unit (UNIT unit) = !(#requires unit)

  fun get_requires (proj as PROJECT {units,...}, m) =
    case get_unit (proj, m)
    of SOME (UNIT {requires, ...}) => 
          Lists.filterp 
          (fn m => case NewMap.tryApply' (units, m) of
                     SOME unit => true
                   | NONE => false)
          (!requires)
    |  NONE =>
d584 1
a584 1
                               ...}, subprojects) =
d587 1
a587 1
            disabled_targets=disabled_targets,
d838 8
d857 2
a858 1
      val requires = Depend.get_imports (is_pervasive, error_info, filename)
d860 4
a863 1
      val sub_modules = map module_name_from_require requires
d866 1
a866 1
        UNIT {source, requires, ...} =>
d868 2
a869 1
         requires := sub_modules)
d875 1
a875 1
         requires := [])
d913 1
a913 1
           requires = ref [],
d917 1
d1150 1
a1150 1
		  subprojects, current_targets, disabled_targets},
d1280 2
a1281 1
	    current_targets = current_targets},
d1296 1
a1296 1
		  subprojects, current_targets, disabled_targets},
d1339 1
a1339 1
	  fun getObject (unit as UNIT {source = src_info, ...}) = 
d1354 1
a1354 1
		 val get_object = getObject unit
d1517 2
a1518 1
  	    Lists.reducel recurse ((units, seen_init), !(#requires unit))
d1529 2
a1530 1
	    disabled_targets = disabled_targets},
d2052 2
a2053 1
           disabled_targets = []}
d2062 1
a2062 1
		       subprojects, current_targets, disabled_targets}, 
d2076 129
a2204 1
       disabled_targets = disabled_targets}
d2377 1
a2377 1
	       #requires unit := []
d2391 1
a2391 1
       #requires unit := [])
d2456 76
d2630 2
d2679 1
d2688 2
a2689 1
                       disabled_targets = disTargets}
d2708 1
d2719 1
d2738 2
a2739 1
                   subprojects, current_targets, disabled_targets} =
d2745 9
d2757 1
a2757 1
             subprojects = subprojects, 
@


1.63
log
@[Bug #190505]
Support for precompilation of subprojects
@
text
@d5 4
d310 5
d330 2
d335 2
d343 4
@


1.62
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@d5 4
d288 2
d448 20
d484 5
d498 2
d508 3
a510 1
  fun get_requires (proj, m) =
d512 6
a517 1
    of SOME (UNIT {requires, ...}) => !requires
d523 17
d932 143
d1112 2
a1113 1
      val subprojects = 
d1117 1
a1145 146
	  (* Check that the source info recorded in the project is
	     still valid. *)
  	  fun check_src (unit as UNIT {source = src_info, ...})  =
  	    case !src_info
  	    of sml_info as SOME (filename, time_stamp) =>
  	      (* Check whether the file on disk has changed *)
	      (let
		 val mod_time = FileTime.modTime filename
	       in
		 if time_stamp = mod_time then
		   ()
		 else
  	           load_src
		     (is_pervasive, error_info,
		      SOME (filename, mod_time), unit)
	       end
	       handle OS.SysErr _ =>
		 (mesg_fn (location,
			   "Source file " ^ filename ^ " has disappeared");
		  if is_pervasive then
		    load_src
		      (true, error_info,
		       findPervasiveSource module_id,
		       unit)
		  else
		    load_src
		      (false, error_info,
		       findSource (files, module_id),
		       unit)))
  	    |  NONE => 
	      if is_pervasive then
  	        load_src
		  (true, error_info,
		   findPervasiveSource module_id,
		   unit)
	      else
  	        load_src  (* we know this unit is not in a subproject *)
		  (false, error_info,
		   findSource (files, module_id),
		   unit)
    
	  fun getObject (unit as UNIT {source = src_info, ...}) = 
	    if is_pervasive then 
	      findPervasiveObject module_id
	    else
	      let 
	        (* Don't search the library path if a source file exists. *)
		val lib_path_opt = 
		  if isSome (!src_info) then NONE else SOME library_path
	      in
		findObject (object_dir, lib_path_opt, module_id)
	      end

	  (* Check that the object info recorded in the project is
	     still valid. *)
  	  fun check_obj (unit as UNIT {object, ...}) =
	    let 
	      val get_object = getObject unit
	    in
  	      case !object of 
		SOME {file, time_stamp, file_time, stamps, consistency} =>
  	         (* Check whether the file on disk has changed *)
	        (let
		   val mod_time = FileTime.modTime file
	         in
		   case get_object of 
		     NONE => load_object NONE unit
		   | SOME (obj_file, obj_time) =>
		       if (obj_file = file) then 
			 if time_stamp = mod_time then 
			   () 
			 else 
			   load_object (SOME (file, mod_time)) unit
		       else
			 load_object (SOME (obj_file, obj_time)) unit
	         end handle OS.SysErr _ =>
		   (mesg_fn (location,
			   "Object file " ^ file ^ " has disappeared");
		    load_object get_object unit))
  	      | NONE => 
	        load_object get_object unit
	     end

	   (* This function does the bulk of the work *)
           fun check_module () =
  	      (* Do we have an entry for this unit in the project? *)
  	      case NewMap.tryApply' (units, module_id)
  	      of SOME unit =>
  	        (check_src unit;
  	         check_obj unit;
  	         (* Now need to check that either the source or the object
  		    (or both) still exist -- this is done when we try to
		    find the sub-units of this unit (see sub_units, below). *)
  	           (units, SOME unit))
  	      |  NONE =>
	        if is_pervasive then
  	          let
  	            val sml_info =
		      findPervasiveSource module_id
  	            val mo_info =
		      findPervasiveObject module_id

		    val (units', unit) = 
		      new_unit
	                error_info
	                (true, units, module_id, sml_info, mo_info, NONE)
  	          in
		    (units', SOME unit)
  	          end
	        else
  	          let
		    (* If unit is found in subprojects, then do nothing else
		     * create a new unit *)

		    val unit = 
		      foldl combineOpt 
			    NONE 
			    (map (fn p => get_unit(p, module_id)) subprojects)

		    val returnUnits = 
		      if isSome(unit) then 
			(units, NONE)
		      else 
			let 
			  val src_info = findSource (files, module_id)

                          val _ = diagnostic (3, fn _ => ["calling new_unit"]);
		    	  val (units', unit) = 
	              	    new_unit
	                      error_info
	                      (false, units, module_id, src_info, NONE, NONE);

			  (* Don't search library path if we have source *)
		    	  val lib_path_opt =
		      	    if isSome src_info then NONE else SOME library_path
	  	        in
                    	  diagnostic (3, fn _ => ["calling load_object"]);
		    	  load_object
		      	    (findObject (object_dir, lib_path_opt, module_id))
		      	     unit;
		    	  (units', SOME unit)
			end
		  in
		    returnUnits
  	          end

d1150 1
a1150 1
	    fun sub_units (UNIT {requires, source, object, ...}) =
d1152 1
a1152 1
	      of SOME _ => !requires
d1186 3
a1188 1
	        (case check_module ()
d1283 1
a1283 1
  	  fun check_obj (unit, object) =
d1313 1
a1313 1
           fun check_module () =
d1317 1
a1317 1
  	        (check_obj (unit, object);
d1379 1
a1379 1
	        (case check_module () of
d1402 1
a1402 1
  	fun check_src (unit, src_info) =
d1431 1
a1431 1
  	    (check_src (unit, source);
a1798 5
  (* The following two functions are also used to parameterise check_dep,
     this time on the method for finding which sub units to check. *)

  fun requires_from_unit (UNIT unit) = !(#requires unit)

d2204 56
d2356 4
d2361 62
a2422 46
	let 
	  val filename = getFullFilename (filename, projDir)

	  val {name, files, libraryPath, objectsLoc, binariesLoc, 
	       configDetails, modeDetails, subprojects, 
	       curTargets, disTargets, currentMode, ...} = 
		  ProjFile.peek_project filename

	  val {name=configName, files=filesC, library=libraryC} = 
	    ProjFile.getConfigDetails (getOpt(config, ""), configDetails)
	    handle ProjFile.NoConfigDetailsFound c => 
	      {name = "", files = [], library = []}

	  val modeName = getOpt(currentMode, "")

	  val {location, ...} = 
	    ProjFile.getModeDetails (modeName, modeDetails)
	    handle ProjFile.NoModeDetailsFound m =>
	      Info.error' error_info
		(Info.FATAL, loc, 
		  "No mode found or none set when getting details of sub projects")

	  val dir = OS.Path.dir name
	  fun mk_abs f = OS.Path.mkAbsolute {path=f, relativeTo=dir}
	  val abs_files = map mk_abs (files @@ filesC)
	  val abs_library = map mk_abs (libraryPath @@ libraryC)
	  val abs_objects = 
	    OS.Path.mkAbsolute {path=OS.Path.concat[objectsLoc, configName, !location], relativeTo=dir}
	  val abs_binaries = 
	    OS.Path.mkAbsolute {path=OS.Path.concat[binariesLoc, configName, !location], relativeTo=dir}

	  val subprojDir = OS.Path.dir filename
	  fun getProjName n = getFullFilename (n, subprojDir)
	  val subprojects = map getProjName subprojects
          val units = getOpt (get_proj_units name proj, 
                              NewMap.empty (ModuleId.lt, ModuleId.eq))
	in
	  PROJECT {name = name,
		   files = abs_files,
                   units = units,
		   library_path = abs_library,
		   object_dir = abs_objects,
		   subprojects = map (getSubDetails config) subprojects,
		   current_targets = curTargets,
		   disabled_targets = disTargets}
	end
d2432 1
d2442 1
a2442 1
           units = units} (* getOpt (get_proj_units projectName proj, NewMap.empty' ModuleId.lt)} *)
d2449 49
a2497 20
  fun update_dependencies
	(error_info, loc)
	(proj as PROJECT {name, current_targets, ...}) =
    let 
      val init_proj =
        #1 (do_read_dependencies
              (error_info, loc)
              (proj, Io.pervasive_library_id, empty_map)
	      true)
      fun do_one (target, (p, smap)) =
        do_read_dependencies
	  (error_info, loc)
	  (p, ModuleId.from_host (target, loc), smap)
	  false
    in
      if null current_targets then 
	no_targets (error_info, loc) name
      else
        #1 (foldl do_one (init_proj, empty_map) current_targets)
   end
d2499 1
@


1.61
log
@[Bug #190500]
Remove redundant require statements
@
text
@d5 4
d281 2
d858 1
a858 1
  val empty_map = NewMap.empty' ModuleId.lt
d1851 1
a1851 1
        if NewMap.exists (fn (m, _) => m = real_mod_id) visited then
d1926 1
a1926 1
	   units = NewMap.empty' ModuleId.lt,
d2282 2
a2285 1
		   units = getOpt (get_proj_units name proj, NewMap.empty' ModuleId.lt),
d2287 1
@


1.60
log
@[Bug #70240]
Change delete function and add function to return units in main project only.
@
text
@a0 42
(* Changed so far:
   
   Pre 11th August:  Added new field to project type.
   11th August:  Use object path in project instead of global object path.
	Expand %S to the full directory; remove %C.  Existing builds can
	use %S, but we can't have sub-directories of the object directory.
	So my cross-compiling scheme won't work.
	Remove check_aliases; symbolic links have no special effect because
	directory names are no longer part of module ids.

   Implications:
	Cross compiling won't work.
	Checks of module ids in mo files will cause problems.  Need to
	change these to remove directory names.

   20th August:
	GUI can load source OK.

   21st August:
	Now correctly checks dependencies for compiling single files.

   2nd Sep:
	Changes to basics/_module_id mean that compiling single files works.
	Recompiling a fresh checkout works, after renaming clashing file
	names.  Implies a need for separate subprojects.

   10th Sep:
	Can now read project information from a file, and build the
	current targets.


   XXX Various stuff  -- see change log.

   2nd Dec:
	Wired up library path.  Dropped %S, because I've changed our
	makefiles to look in object dir.  Haven't really tested the
	library path stuff yet.
	
*)

  	
   
d5 4
@


1.59
log
@[Bug #30481]
Fix reading subprojects within different directories.
@
text
@d47 4
d1974 2
a1975 1
	      module_id) =
d1982 4
a1985 1
       subprojects = map (fn p => delete (p, module_id)) subprojects,
@


1.58
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d47 4
d2273 2
d2302 4
@


1.57
log
@[Bug #30420]
Include name of project when reporting a unit does not exist.
@
text
@d47 4
d2181 1
a2181 1
	  val abs_name = OS.Path.mkAbsolute (local_name, dirName)
d2201 1
a2201 1
      fun toAbs s = OS.Path.mkAbsolute (s, projDir)
d2289 1
a2289 1
	  fun mk_abs f = OS.Path.mkAbsolute (f, dir)
d2293 1
a2293 1
	    OS.Path.mkAbsolute (OS.Path.concat[objectsLoc, configName, !location], dir)
d2295 1
a2295 1
	    OS.Path.mkAbsolute (OS.Path.concat[binariesLoc, configName, !location], dir)
@


1.56
log
@[Bug #20111]
Fix incorrect case problems.
@
text
@d47 4
d881 14
d910 5
a914 2
      fun getCurTargets (PROJECT {current_targets, ...}) = 
        map (fn t => ModuleId.from_host(t, location)) current_targets
d1131 2
a1132 1
		    (Info.FATAL, location, "No such unit: " ^ mod_name)
d1196 5
a1200 2
      fun getCurTargets (PROJECT {current_targets, ...}) = 
        map (fn t => ModuleId.from_host(t, location)) current_targets
d2329 1
a2329 1
	(proj as PROJECT {current_targets, ...}) =
d2342 4
a2345 1
      #1 (foldl do_one (init_proj, empty_map) current_targets)
@


1.55
log
@[Bug #30369]
Replace source path with a list of files.
@
text
@d47 4
d723 3
d730 1
a730 4
	let 
	  val fname = ModuleId.module_unit_to_string (module_id, "sml")
	in
	  if ((OS.Path.mkCanonical fname) = (OS.Path.file filename)) then 
a741 1
	end
d2154 1
a2154 1
	  OS.Path.mkCanonical abs_name
@


1.54
log
@[Bug #30385]
CHanging mode should affect compilation.
@
text
@d47 4
d430 2
a431 1
     source:  A list of directories to search for source files.
d439 1
a439 1
     Currently the source path and object path are global, and targets
d447 1
a447 1
       source: string list,
a602 5
  (* Given a module_id for a user module, and a source path, findSource
     finds the corresponding source file, and returns the file name and
     modification time. *)
  val findSource = findFile source_ext

d713 30
d884 1
a884 1
        (PROJECT {name, units, source, library_path, object_dir, 
d903 1
d905 1
a905 1
	  #1 (foldl read_sub_dep (pervasive_proj, pervasive_smap) (getCurTargets proj))
d967 1
a967 1
		       findSource (source, module_id),
d978 1
a978 1
		   findSource (source, module_id),
d1064 1
a1064 1
			  val src_info = findSource (source, module_id)
d1132 1
a1132 1
		 |  (units', NONE) => (units', seen))
d1148 1
a1148 1
	    source = source,
d1167 1
a1167 1
        (proj as PROJECT {name, units, source, library_path, object_dir, 
d1353 1
a1353 1
		   findSource (source, module_id),
d1358 1
a1358 1
	       findSource (source, module_id),
d1370 1
a1370 1
		findSource (source, module_id)
d1392 1
a1392 1
	    source = source,
d1919 1
a1919 1
           source = [],
d1932 1
a1932 1
  fun delete (PROJECT {name, units, source, library_path, object_dir,
d1938 1
a1938 1
       source = source,
d2144 1
a2144 1
	(PROJECT {units, ...}) =
d2169 1
a2169 1
      val sourcePath = ProjFile.getSourcePath ()
d2171 3
a2173 1
      val (sourceC, libraryC, objectsC, binariesC) =
d2175 1
a2175 1
	  NONE => (sourcePath, libraryPath, objectsLoc, binariesLoc)
d2178 2
a2179 2
	     {source, library, ...} =>
	        (source @@ sourcePath,
d2186 1
a2186 1
      val (source, library, objects, binaries) = 
d2188 1
a2188 1
	  NONE => (sourceC, libraryC, objectsC, binariesC)
d2192 1
a2192 1
		(sourceC, libraryC, 
d2196 1
a2196 1
      val (abs_source, abs_library, abs_objects, abs_binaries) =
d2201 1
a2201 1
	   (source, library, objects, binaries))
d2204 4
a2207 4
	   (map (fn x => OS.Path.mkAbsolute (x, projDir)) source,
	    map (fn x => OS.Path.mkAbsolute (x, projDir)) library,
	    OS.Path.mkAbsolute (objects, projDir),
	    OS.Path.mkAbsolute (binaries, projDir)))
d2224 11
d2237 1
a2237 1
	  val {name, sourcePath, libraryPath, objectsLoc, binariesLoc, 
d2242 1
a2242 1
	  val {name=configName, source=sourceC, library=libraryC} = 
d2245 1
a2245 1
	      {name = "", source = [], library = []}
d2258 1
a2258 1
	  val abs_source = map mk_abs (sourcePath @@ sourceC)
d2266 2
a2267 2
		   units = NewMap.empty' ModuleId.lt,
		   source = abs_source,
d2286 1
a2286 1
	   source = abs_source,
d2292 1
a2292 1
           units = units}
@


1.53
log
@[Bug #30389]
Keep projects more in step with projfiles
@
text
@d47 4
d950 3
a952 6
	  (* This function is local to check_obj. *)
	  fun load_new_object (unit as UNIT {source = src_info, ...}) =
	    if is_pervasive then
	      load_object
	        (findPervasiveObject module_id)
	        unit
d954 1
a954 1
	      let
d956 1
a956 1
		val lib_path_opt =
d959 1
a959 3
  	        load_object
	          (findObject (object_dir, lib_path_opt, module_id))
		  unit
d965 21
a985 12
  	    case !object
  	    of SOME {file, time_stamp, file_time, stamps, consistency} =>
  	      (* Check whether the file on disk has changed *)
	      (let
		 val mod_time = FileTime.modTime file
	       in
		 if time_stamp = mod_time then
		   ()
		 else
		   load_object (SOME (file, mod_time)) unit
	       end handle OS.SysErr _ =>
		 (mesg_fn (location,
d987 5
a991 4
		  load_new_object unit))
  	    |  NONE => 
	      load_new_object unit
    
d1177 9
d1192 1
d1194 10
a1203 4
		 if time_stamp = mod_time then
		   ()
		 else
		   load_object (SOME (file, mod_time)) unit
@


1.52
log
@[Bug #70091]
Remove req_name from DEPEND_LIST
@
text
@d47 4
d2225 9
d2237 1
a2237 1
              (new_proj, Io.pervasive_library_id, empty_map)
a2238 3
  
      val targets = curTargets

d2245 2
a2246 3
      #1 (foldl do_one (init_proj, empty_map) targets)
    end
    
@


1.51
log
@[Bug #30312]
Replacing OS.FileSys.modTime with system dependent version to sort out
MS time stamp problems.
@
text
@d47 5
d345 1
a345 1
      {mod_name : string, req_name : string, time : Time.time} list
d1231 1
a1231 1
			 {mod_name = sub_name, req_name, time}) =
d1412 1
a1412 1
	{mod_name, req_name, time} =
@


1.50
log
@[Bug #30377]
Add check to ensure we know when we are checking deps of a pervasive file.
@
text
@d47 4
d280 1
d570 1
a570 1
            val mod_time = FileSys.modTime filename
d617 1
a617 1
	  val mod_time = FileSys.modTime filename
d682 1
a682 1
      val mod_time = FileSys.modTime filename
d903 1
a903 1
		 val mod_time = FileSys.modTime filename
d961 1
a961 1
		 val mod_time = FileSys.modTime file
d1164 1
a1164 1
		 val mod_time = FileSys.modTime file
d1276 1
a1276 1
	       val mod_time = FileSys.modTime filename
@


1.49
log
@[Bug #70078]
When making object directories apply OS.Path.fromUnixPath.
@
text
@d47 4
a834 1
	is_pervasive
d847 1
a847 2
	    do_read_dependencies PERVASIVE 
				 (error_info, location)
d852 1
a852 2
	    do_read_dependencies USER
			         (error_info, location)
d880 7
d904 1
a904 1
		     (is_pervasive = PERVASIVE, error_info,
d910 1
a910 1
		  if is_pervasive = PERVASIVE then
d921 1
a921 1
	      if is_pervasive = PERVASIVE then
d934 1
a934 1
	    if is_pervasive = PERVASIVE then
d981 1
a981 1
	        if is_pervasive = PERVASIVE then
d1032 4
d1123 1
a1123 2
	    do_read_dependencies PERVASIVE 
				 (error_info, location)
d1128 1
a1128 2
	    do_read_dependencies USER
			         (error_info, location)
a1856 1
	    PERVASIVE 
a1882 1
	  PERVASIVE
d1889 1
a1889 1
      do_read_dependencies USER info (p', m, smap') false
a2212 1
	      PERVASIVE 
a2220 1
	  USER
@


1.48
log
@[Bug #30365]
Implement support for sub-projects.
@
text
@d47 4
d2129 1
a2129 1
      fun mkdir s = 
d2137 3
a2139 1
	   (mkdir (OS.Path.getParent s); OS.FileSys.mkDir s);
@


1.47
log
@[Bug #30362]
Use mode setting to determine where object files go.
@
text
@d47 4
d414 2
a415 1
      {units: (ModuleId.ModuleId, Unit) NewMap.map,
d419 1
d434 6
a439 1
  fun get_name (PROJECT {units, ...}, m) =
d441 9
d456 2
a457 2
  fun get_requires (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d464 2
a465 2
  fun is_visible (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d472 3
a474 4
  fun set_visible (PROJECT {units, ...}, m, b) =
    case NewMap.tryApply' (units, m)
    of SOME (UNIT {visible, ...}) =>
      visible := b
d477 1
a477 1
         fn _ => ["No such module in is_visible: `", ModuleId.string m, "'"]);
d480 3
a482 3
  fun get_source_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {source, ...}) => !source
d484 4
a487 4

  fun set_source_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {source, ...}) => source := info
d494 3
a496 3
  fun get_object_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {object, ...}) => !object
d499 3
a501 4
  fun set_object_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {object, ...}) => 
      object := info
d508 3
a510 3
  fun get_loaded_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {loaded, ...}) => !loaded
d513 3
a515 4
  fun set_loaded_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
    of SOME (unit as UNIT {loaded, ...}) => 
      loaded := info
d522 2
a523 2
  fun clear_all_loaded_info (PROJECT {units, ...}, pred) =
    NewMap.iterate 
d529 5
a533 1
      units
d617 1
a617 1
	  (PROJECT {units, object_dir, ...}, module_id) =
d619 15
d635 2
a636 3
          case NewMap.tryApply' (units, module_id) of
	    SOME unit => 
	      unit
d638 9
a646 6
	      (* This is probably impossible *)
              (Info.default_error'
                 (Info.FATAL, loc,
                  (* LOCALE *)
                  "Missing unit information for module " ^
 	          ModuleId.string module_id))
d829 4
a832 3
        (PROJECT {units, source, library_path, object_dir,
		  current_targets, disabled_targets},
	 module_id, seen_init): (Project * StatusMap) =
d834 25
d881 1
a881 1
  	  fun check_src (unit as UNIT {source = src_info, ...}) =
d915 1
a915 1
  	        load_src
d967 1
a967 1
  	           (units, unit))
d975 5
d981 1
a981 3
	            new_unit
	              error_info
	              (true, units, module_id, sml_info, mo_info, NONE)
d985 2
a986 1
		    val src_info = findSource (source, module_id)
d988 30
a1017 15
                    val _ = diagnostic (3, fn _ => ["calling new_unit"]);
		    val (units', unit) = 
	              new_unit
	                error_info
	                (false, units, module_id, src_info, NONE, NONE);

		    (* Don't search library path if we have source *)
		    val lib_path_opt =
		      if isSome src_info then NONE else SOME library_path
  	          in
                    diagnostic (3, fn _ => ["calling load_object"]);
		    load_object
		      (findObject (object_dir, lib_path_opt, module_id))
		      unit;
		    (units', unit)
d1020 1
a1020 1
	    fun sub_units (UNIT {requires, source, object, name, ...}) =
d1056 1
a1056 1
		 of (units', unit) =>
d1061 2
a1062 1
		      sub_units unit))
d1073 1
d1076 2
a1077 1
	   {units = units',
d1081 1
d1097 2
a1098 2
        (PROJECT {units, source, library_path, object_dir,
		  current_targets, disabled_targets},
d1101 23
d1161 1
a1161 1
    
d1168 1
a1168 1
  	         (units, unit))
d1170 34
a1203 23
  	        let
		  (* XXX I'm not sure that this works.  The code used to
		   * check for the existence of the object file before
		   * creating the new unit.
		   * - Does findObject cope OK in this case?  (Probably,
		   *   now that we've dropped %S).
		   * - Should we retract the new unit before reporting
		   *   the error?
		   *)
		  val (units', unit) = 
	            new_unit
	              error_info
	              (false, units, module_id, NONE, NONE, NONE);
  	        in
	          case findObject (object_dir, SOME library_path, module_id)
		  of mo_info as SOME _ =>
		    (load_object mo_info unit;
		     (units', unit))
		  |  NONE =>
                    Info.error'
                      error_info
                      (Info.FATAL, Info.Location.FILE mod_name,
		       "No object file.")
a1204 1
		  
d1206 2
a1207 1
	    fun recurse ((units, seen), {mod_name = sub_name, req_name, time}) =
d1230 2
a1231 2
  	           (units',
		    UNIT {object =
d1235 1
a1235 1
			  ...}) =>
d1237 1
d1306 2
a1307 1
	   {units = units',
d1311 1
d1316 1
a1316 1
      
d1387 1
a1387 1
	(error_info, location, proj_info, check_perv, check_normal)
d1396 1
a1396 1
      case NewMap.tryApply' (proj_info, sub_module_id)
d1414 1
a1414 1
        (PROJECT {units, ...}, dependencies, check_one) =
d1416 1
a1416 1
      (check_sub_unit (error_info, location, units, check_one, check_one))
d1430 1
a1430 1
	(PROJECT {units, ...}, level, module_id, UNIT unit)
d1449 1
a1449 1
	           (error_info, location, units, check_one_loaded, check_one_mo)))
d1694 6
d1702 1
a1702 1
	 check_times, check_validity, project as PROJECT {units, ...})
d1720 10
a1729 7
  
        val UNIT unit =
  	  NewMap.apply' (units, module_id)
  	  handle
  	    NewMap.Undefined =>
  	      Crash.impossible
	        ("Undefined module: " ^ mod_name)
d1752 1
a1752 7
		val mod_name = ModuleId.string module_id
		val UNIT sub_unit =
		  NewMap.apply' (units, module_id)
		  handle
		  NewMap.Undefined =>
		    Crash.impossible
		    ("Undefined module: " ^ mod_name)
d1833 2
a1834 1
          {units = NewMap.empty' ModuleId.lt,
d1838 1
d1845 1
a1845 1
            (project, Io.pervasive_library_id, empty_map))
d1849 3
a1851 2
  fun delete (PROJECT {units, source, library_path, object_dir,
		       current_targets, disabled_targets}, module_id) =
d1853 2
a1854 1
      {units = NewMap.undefine (units, module_id),
d1858 1
d1872 2
a1873 1
	  (p, Io.pervasive_library_id, smap)
d1877 1
a1877 1
      do_read_dependencies USER info (p', m, smap')
d2050 2
a2051 2
    fun remove_file_info (PROJECT {units, ...}) =
      NewMap.iterate 
d2053 2
a2054 1
	units
d2064 14
d2113 11
a2123 14
	let val dir = ProjFile.getProjectDir ()
	in
	  if OS.Path.isRelative dir then
	    (* dir should always be absolute, but we need to return some
	       value in the exceptional case. *)
	    (diagnostic (1, fn _ => ["Project Dir is relative: ", dir]);
	     (source, library, objects, binaries))
	  else
	    (diagnostic (1, fn _ => ["Project Dir is absolute: ", dir]);
	     (map (fn x => OS.Path.mkAbsolute (x, dir)) source,
	      map (fn x => OS.Path.mkAbsolute (x, dir)) library,
	      OS.Path.mkAbsolute (objects, dir),
	      OS.Path.mkAbsolute (binaries, dir)))
	end
d2135 50
a2184 2
      val mk_obj_dir = mkdir objects
(*      val mk_bin_dir = mkdir binaries *)
d2188 2
a2189 1
          {source = abs_source,
d2192 1
d2201 2
a2202 1
              (new_proj, Io.pervasive_library_id, empty_map))
d2211 1
@


1.46
log
@[Bug #30337]
Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@d47 4
d1937 1
d1941 1
a1941 1
      val (source, library, objects, binaries) =
d1954 10
d1980 13
d2008 1
a2008 1
      val targets = curTargets @@ disTargets
@


1.45
log
@[Bug #30071]
Merge in Project Workspace changes.
Added pervasiveObjectName.
@
text
@d47 5
d563 1
a563 1
	(object_dir, ModuleId.module_unit_to_string(module_id, object_ext))
d1944 2
a1945 2
		 OS.Path.concat(objectsLoc, name),
	         OS.Path.concat(binariesLoc, name)))
@


1.44
log
@[Bug #30311]
Make sure we test for correct sequencing of timestamps on object files
and their dependents. If a depends on b, then a.mo should be no older
then b.mo
@
text
@d1 42
d47 6
d63 53
d258 3
a260 2
require "../utils/map.sml";
require "../utils/crash.sml";
a264 1
require "../basics/module";
d267 1
a267 1
require "io";
d273 1
a278 1
  structure Module: MODULE;
d285 2
a286 4
  sharing type Depend.ModuleId = ModuleId.ModuleId =
	       Module.ModuleId = Io.ModuleId
  sharing type Depend.Info.Location.T = ModuleId.Location = Module.Location
  sharing type Module.InfoOptions = Depend.Info.options
a296 1
  type Module = Module.Module
d299 1
d364 1
a364 1
     source:   (string * Module.Module * Time.time) option ref,
d383 24
a406 1
  datatype Project = PROJECT of (ModuleId.ModuleId, Unit) NewMap.map
d411 1
a411 1
  exception NoSuchModule of Module.ModuleId
d417 4
a420 2
  fun get_name (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d427 2
a428 2
  fun get_requires (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d435 2
a436 2
  fun is_visible (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d443 2
a444 2
  fun set_visible (PROJECT map, m, b) =
    case NewMap.tryApply' (map, m)
d452 2
a453 2
  fun get_source_info (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d457 2
a458 2
  fun set_source_info (PROJECT map, m, info) =
    case NewMap.tryApply' (map, m)
d466 2
a467 2
  fun get_object_info (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d471 2
a472 2
  fun set_object_info (PROJECT map, m, info) =
    case NewMap.tryApply' (map, m)
d481 2
a482 2
  fun get_loaded_info (PROJECT map, m) =
    case NewMap.tryApply' (map, m)
d486 2
a487 2
  fun set_loaded_info (PROJECT map, m, info) =
    case NewMap.tryApply' (map, m)
d496 1
a496 1
  fun clear_all_loaded_info (PROJECT pmap, pred) =
d503 1
a503 1
      pmap
d508 106
a613 19
  (* Given a module_id for a user module, findObject finds the corresponding
     object file, and returns the file name and modification time. *)
  (* We should probably add an argument that specifies whether an object
     file is definitely required, or whether it's OK if it's missing. *)
  fun findObject (error_info, loc) module_id =
    case Module.findObject (error_info, loc) module_id
    of SOME (file, _, time) =>
      (diagnostic (2, fn _ => ["Found `", file, "'"]);
       SOME (file, time))
    |  _ =>
      NONE
  
  (* Given a module_id for a user module, findSource finds the corresponding
     source file, and returns the file name, module, and modification time. *)
  (* We should probably add an argument that specifies whether a source
     file is definitely required, or whether it's OK if it's missing.
     Unless we always allow the use of an object file when there is no
     source file. *)
  fun findSource (error_info, loc) module_id =
d615 8
a622 1
      val result = Module.findSource (error_info, loc) module_id
d624 2
a625 6
      case result
      of SOME (file, _, _) =>
        diagnostic (2, fn _ => ["Found `", file, "'"])
      |  NONE =>
        diagnostic (2, fn _ => ["Failed to find source"]);
      result
d627 4
a630 1
  
d633 1
a633 8
  fun findPervasiveObject (error_info, loc) module_id =
    case Module.findPervasiveObject (error_info, loc) module_id
    of SOME (file, _, time) =>
      (diagnostic (2, fn _ => ["Found `", file, "'"]);
       SOME (file, time))
    |  _ =>
      (diagnostic (2, fn _ => ["Failed to find source"]);
       NONE)
d638 2
a639 11
  fun findPervasiveSource (error_info, loc) module_id =
    let
      val result = Module.findPervasiveSource (error_info, loc) module_id
    in
      case result
      of SOME (file, _, _) =>
        diagnostic (2, fn _ => ["Found `", file, "'"])
      |  NONE =>
        diagnostic (2, fn _ => ["Failed to find source"]);
      result
    end
d642 2
a643 2
  fun module_name_from_require mod_path req_name =
    ModuleId.add_path (mod_path, req_name)
d649 1
a649 1
		SOME (filename, module, mod_time), unit) =
d654 1
a654 3
      val mod_path = ModuleId.path (Module.module_id module)

      val sub_modules = map (module_name_from_require mod_path) requires
d658 1
a658 1
  	(source := SOME (filename, module, mod_time);
d736 3
a738 1
	    (load_object mo_info unit;
d749 1
a754 25
  (* check_aliases detects whether a module_id is an alias for an existing
     module, e.g. when a compound name refers to a symbolic link.
      This code should only be called when we encounter a new module.
      This means that any additions of symbolic links (etc.) may 
      invalidate any existing project information.  Tough - we have
      to draw the line somewhere. *)
  fun check_aliases (error_info, location) (map, module_id, NONE, NONE) =
    Info.error'
      error_info
      (Info.FATAL, location,
       "No files found for: `" ^ ModuleId.string module_id ^ "'")
  |   check_aliases
	(error_info, location)
	(map, module_id, sml_info, mo_info) =
    let
      (* For source files, we check that the module name calculated from
	 Module.findSource, which uses real_path, equals the one we have. *)
      val src_alias =
        case sml_info
	of SOME (filename, module, mod_time) =>
	  if Module.module_id module <> module_id then
	    SOME (Module.module_id module)
	  else
	    NONE
	|  NONE => NONE
a755 69
      (* For object files, we check that the first entry in the consistency
	 info matches the name we have.  We hang on to the consistency
	 info so that we can add it to the unit info later. *)
      val (mo_alias, info_from_mo) =
	case mo_info of
	  SOME (filename, _) =>
	    (let
	       val info as {consistency, mod_name, time_stamp, stamps} =
		 Encapsulate.input_info filename
	       val real_mod_id =
		 ModuleId.from_mo_string (mod_name, location)
	     in
	       if real_mod_id <> module_id then
		 (SOME real_mod_id, SOME info)
	       else
		 (NONE, SOME info)
	     end
	   handle Encapsulate.BadInput str =>
	     (* new_unit will deal with this later *)
	     (NONE, NONE))
	   
	|  NONE => 
	  (NONE, NONE)
	
      (* If we have two candidates for the real module name, they had
	 better be the same. *)
      val real_mod_name =
	case (src_alias, mo_alias)
	of (SOME m1, SOME m2) =>
	  if m1 <> m2 then
            Info.error'
              error_info
              (Info.FATAL, location,
	       "Module name derived for source (" ^ ModuleId.string m1 
	       ^ ") differs from that in object file (" ^ ModuleId.string m2
	       ^ ")\nCheck your source path setting.")
	  else
	    SOME m1
	| (SOME m1, NONE) => SOME m1
	| (NONE, SOME m2) => SOME m2
	| (NONE, NONE) => NONE

      (* If we do have an alias, we copy the existing entry, so that
	 references are shared.  *)
      val (map', unit) =
	case real_mod_name
	of SOME m =>
	  (* The current module_id is an alias.  Check that the aliased
	     unit exists, creating it if not. *)
	  let
	    val (proj, unit) =
  	      case NewMap.tryApply' (map, m)
  	      of SOME (unit (* as UNIT {source, object, ...} *) ) =>
		(map, unit)
	      |  NONE =>
		new_unit
		  error_info
		  (false, map, m, sml_info, mo_info, info_from_mo)
	  in
            (NewMap.define (proj, module_id, unit), unit)
	  end
	|  NONE =>
	  new_unit
	    error_info
	    (false, map, module_id, sml_info, mo_info, info_from_mo)
    in
      (map', unit)
    end
  
d782 3
a784 1
        (PROJECT proj, module_id, seen_init): (Project * StatusMap) =
d796 1
a796 1
	    ((proj, seen), module_id) =
d806 5
a810 3
  	  fun check_src (unit, source) =
  	    case !source
  	    of sml_info as SOME (filename, module, time_stamp) =>
d818 5
a822 4
		   load_src
		   (is_pervasive = PERVASIVE, error_info,
		    SOME (filename, module, mod_time), unit)
	       end handle OS.SysErr _ =>
d827 3
a829 3
		    (true, error_info,
		     findPervasiveSource (error_info, location) module_id,
		     unit)
d832 3
a834 3
		    (false, error_info,
		     findSource (error_info, location) module_id,
		     unit)))
d839 1
a839 1
		   findPervasiveSource (error_info, location) module_id,
d844 1
a844 1
		   findSource (error_info, location) module_id,
d847 20
a866 1
  	  fun check_obj (unit, object) =
d880 1
a880 8
		  if is_pervasive = PERVASIVE then
		    load_object
		    (findPervasiveObject (error_info, location) module_id)
		    unit
		  else
		    load_object
		    (findObject (error_info, location) module_id)
		    unit))
d882 1
a882 8
	      if is_pervasive = PERVASIVE then
  	        load_object
		  (findPervasiveObject (error_info, location) module_id)
		  unit
	      else
  	        load_object
		  (findObject (error_info, location) module_id)
		  unit
d887 4
a890 4
  	      case NewMap.tryApply' (proj, module_id)
  	      of SOME (unit as UNIT {source, object, ...}) =>
  	        (check_src (unit, source);
  	         check_obj (unit, object);
d894 1
a894 1
  	           (proj, unit))
d899 1
a899 1
		      findPervasiveSource (error_info, location) module_id
d901 1
a901 1
		      findPervasiveObject (error_info, location) module_id
a902 1
		    (* No need to check for aliases in pervasive case. *)
d905 1
a905 1
	              (true, proj, module_id, sml_info, mo_info, NONE)
d909 11
a919 4
  	            val sml_info =
		      findSource (error_info, location) module_id
  	            val mo_info =
		      findObject (error_info, location) module_id
d921 5
a925 3
		    check_aliases
		      (error_info, location)
		      (proj, module_id, sml_info, mo_info)
d928 1
a928 1
	    fun sub_units (UNIT {requires, source, object, ...}) =
d939 4
d961 1
a961 1
	         (proj, seen))
d964 1
a964 1
		 of (proj', unit) =>
d968 1
a968 1
		     ((proj', mark_visited (seen, module_id)),
d976 1
a976 1
	val (proj', seen') =
d979 1
a979 1
	    ((proj, seen_init), module_id)
d981 8
a988 1
        (PROJECT proj', seen')
d992 1
a992 1
  (* load_object_dependencies takes a file name and returns a Project that
d1001 3
a1003 1
        (PROJECT proj, module_id, seen_init): Project * StatusMap =
d1010 1
a1010 1
	    (module_id, (proj, seen)) =
d1035 3
a1037 3
		  load_object
		  (findObject (error_info, location) module_id)
		  unit))
d1040 1
a1040 1
		(findObject (error_info, location) module_id)
d1046 1
a1046 1
  	      case NewMap.tryApply' (proj, module_id)
d1049 1
a1049 1
  	         (proj, unit))
d1051 24
a1074 10
		case findObject (error_info, location) module_id
		of mo_info as SOME _ =>
	          new_unit
		    error_info
		    (false, proj, module_id, NONE, mo_info, NONE)
		|  NONE =>
                  Info.error'
                    error_info
                    (Info.FATAL, Info.Location.FILE mod_name,
		     "No object file.")
d1077 1
a1077 1
	    fun recurse ((proj, seen), {mod_name = sub_name, req_name, time}) =
d1081 1
a1081 1
		  (proj, mark_visited (seen, module_id)))
d1097 1
a1097 1
	         (proj, seen))
d1100 1
a1100 1
  	           (proj',
d1106 1
a1106 1
  	             Lists.reducel recurse ((proj', seen), const)
d1121 3
a1123 3
  	fun check_src (unit, source) =
  	  case !source
  	  of sml_info as SOME (filename, module, time_stamp) =>
d1132 1
a1132 1
		 (false, error_info, SOME (filename, module, mod_time), unit)
d1136 4
a1139 4
		load_src
		(false, error_info,
		 findSource (error_info, location) module_id,
		 unit)))
d1143 1
a1143 1
	       findSource (error_info, location) module_id,
d1147 2
a1148 2
	val (proj, UNIT unit) =
  	  case NewMap.tryApply' (proj, module_id)
d1151 1
a1151 1
  	     (proj, unit))
d1155 1
a1155 1
		findSource (error_info, location) module_id
d1157 3
a1159 3
	      check_aliases
	        (error_info, location)
	        (proj, module_id, sml_info, NONE)
d1162 1
a1162 1
        val (proj', seen') =
d1166 1
a1166 1
	    fun recurse ((proj, seen), require_id) =
d1169 1
a1169 1
		(require_id, (proj, mark_visited (seen, module_id)))
d1171 1
a1171 1
  	    Lists.reducel recurse ((proj, seen_init), !(#requires unit))
d1174 8
a1181 1
        (PROJECT proj', seen')
d1193 6
a1198 5
     This function should be used whenever a time stamp stored in an object file
     is compared against the actual modification time of a source file.  It is
     not needed when two stored time stamps are compared, or when the modification
     times of two source files are compared.  All comparisons of file times in
     _project are commented to explain whether compare_timestamp is needed. *)     
d1267 1
a1267 1
	   check_perv (location, time, unit, mod_name))
d1281 1
a1281 1
        (PROJECT map, dependencies, check_one) =
d1283 1
a1283 1
      (check_sub_unit (error_info, location, map, check_one, check_one))
d1297 1
a1297 1
	(PROJECT map, level, module_id, UNIT unit)
d1316 1
a1316 1
	           (error_info, location, map, check_one_loaded, check_one_mo)))
d1342 1
a1342 1
    |  SOME (s_file, s_module, s_time) =>
d1411 1
a1411 1
         |  SOME (s_file, s_module, s_time) =>
d1455 1
a1455 1
       |  SOME (s_file, s_module, s_time) =>
d1493 1
a1493 1
            |  SOME (s_file, s_module, s_time) =>
d1563 1
a1563 1
	 check_times, check_validity, project as PROJECT proj)
d1583 1
a1583 1
  	  NewMap.apply' (proj, module_id)
d1612 1
a1612 1
		  NewMap.apply' (proj, module_id)
d1687 1
a1687 1
  fun list_units (PROJECT proj) =
d1690 1
a1690 1
      (map (fn m => (ModuleId.string m, m)) (NewMap.domain proj))
d1695 8
a1702 1
      val project = PROJECT (NewMap.empty' ModuleId.lt)
d1710 10
a1719 2
  fun delete (PROJECT proj, module_id) =
    PROJECT (NewMap.undefine (proj, module_id))
d1832 22
d1895 1
a1895 1
    fun reset_pervasives (PROJECT map) =
d1898 1
a1898 1
        map
d1908 1
a1908 1
    fun remove_file_info (PROJECT map) =
d1911 1
a1911 1
	map
d1913 72
@


1.43
log
@[Bug #30089]
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@d5 4
d1436 25
d1491 5
a1495 4
	    if check_visited_map (real_sub_ids, visited_now)
	    andalso check_times
		      (error_info, Location.FILE mod_name)
		      (project, module_id, UNIT unit)
@


1.42
log
@[Bug #20090]
Changed consistency info in object files to store the modification times
of the corresponding source files.
Ditto for loaded object files.
@
text
@d5 6
d149 1
a156 1
require "../make/old_os";
d160 1
a173 1
  structure OldOs: OLD_OS;
d178 1
d189 1
d198 1
a198 1
  val _ = Diagnostic.set 0;
d211 1
a211 1
      {mod_name : string, req_name : string, time : MLWorks.Time.time} list
d214 2
a215 2
    OBJECT of MLWorks.Time.time
  | SOURCE of MLWorks.Time.time
d261 1
a261 1
     source:   (string * Module.Module * MLWorks.Time.time) option ref,
d263 2
a264 2
     object:   {file_time: MLWorks.Time.time,
		time_stamp: MLWorks.Time.time,
d271 1
a271 1
		load_time: MLWorks.Time.time,
d696 11
a706 10
  	      (case OldOs.mtime filename
  	       of OldOs.EXISTS mod_time =>
  	         if time_stamp = mod_time then
  	           ()
  	         else
  	           load_src
		     (is_pervasive = PERVASIVE, error_info,
		      SOME (filename, module, mod_time), unit)
  	       |  OldOs.NOT_EXIST =>
  	         (mesg_fn (location,
d708 10
a717 10
		 if is_pervasive = PERVASIVE then
  	           load_src
		     (true, error_info,
		      findPervasiveSource (error_info, location) module_id,
		      unit)
		 else
  	           load_src
		     (false, error_info,
		      findSource (error_info, location) module_id,
		      unit)))
d734 10
a743 9
  	      (case OldOs.mtime file
  	       of OldOs.EXISTS mod_time =>
  	         if time_stamp = mod_time then
  	           ()
  	         else
  	           load_object (SOME (file, mod_time)) unit
  	       |  OldOs.NOT_EXIST =>
  	         (mesg_fn (location,
		           "Object file " ^ file ^ " has disappeared");
d745 3
a747 3
  	            load_object
		      (findPervasiveObject (error_info, location) module_id)
		      unit
d749 3
a751 3
  	            load_object
		      (findObject (error_info, location) module_id)
		      unit))
d882 9
a890 8
  	      (case OldOs.mtime file
  	       of OldOs.EXISTS mod_time =>
  	         if time_stamp = mod_time then
  	           ()
  	         else
  	           load_object (SOME (file, mod_time)) unit
  	       |  OldOs.NOT_EXIST =>
  	         (mesg_fn (location,
d892 3
a894 3
  	          load_object
		    (findObject (error_info, location) module_id)
		    unit))
d968 10
a977 9
  	    (case OldOs.mtime filename
  	     of OldOs.EXISTS mod_time =>
  	       if time_stamp = mod_time then
  	         ()
  	       else
  	         load_src
		   (false, error_info, SOME (filename, module, mod_time), unit)
  	     |  OldOs.NOT_EXIST =>
  	       (mesg_fn (location,
d979 4
a982 4
  	        load_src
		  (false, error_info,
		   findSource (error_info, location) module_id,
		   unit)))
d1036 3
a1038 2
      val diff = MLWorks.Time.interval (t1, t2)
      val rdiff = MLWorks.Time.Interval.to_real diff
d1040 1
a1040 1
      real(~5) < rdiff andalso rdiff < real(5)
a1193 1

@


1.41
log
@[Bug #30158]
Merging in changes from 1.0r2c2 to 2.0m0
@
text
@d5 4
a8 1
<<<<<<< /u/jkbrook/ml2/MLW/src/main/_project.sml
d198 2
a199 2
     time stamps of the object files or loaded modules on which they depend.
     Using this type in both fields allows the dependency checking code
d225 3
a227 1
	timestamps of the source file, the pervasive library, and all the
d231 2
d234 6
a239 3
	Contains the time stamp of the file from which the compilation unit
	was loaded, the time that it was loaded, the compiled module,
	and the load times of the loaded modules on which it depends.
d1011 12
a1022 3
  (* compare_timestamps allows timestamps to differ by up to 5 seconds, to
     allow for InstaalShield's unpleasant behaviour. *)
  fun compare_timestamps (t1, t2) =
d1030 4
a1033 4
  (* check_one_mo checks the modification time of a given mo file against a
     supplied time stamp.  The modification time is found from the result of
     a call to findObject, which is most likely to have been stored in the
     object field of a Compilation Unit. *)
d1036 2
a1037 2
    of SOME {file_time, ...} =>
      if compare_timestamps (time, file_time) then
d1049 8
a1056 1
     supplied time stamp.  *)
d1061 1
a1061 1
      if compare_timestamps (load_time, load_time') then
d1099 2
a1100 3
  (* check_dependencies checks a dependency list against a time stamp and
     the info stored in a project.  It returns true if the information is
     consistent.  *)
d1130 4
d1151 4
a1154 2
  (* check_compile_times checks the dependencies in an object file against
     the object files in its dependency information. *) 
d1167 4
a1170 1
        if compare_timestamps (time_stamp, s_time) then
d1185 16
a1200 2
     object file. *)
     
d1212 3
a1214 1
        if compare_timestamps (time, file_time) then
d1235 4
a1238 1
           if compare_timestamps (time, s_time) then
d1241 1
a1241 1
              if compare_timestamps (time_stamp, s_time) then
d1279 4
a1282 1
         if compare_timestamps (time, s_time) then
d1302 3
a1304 1
         if compare_timestamps (time, file_time) then
d1317 4
a1320 1
	      if compare_timestamps (time_stamp, s_time) then
d1629 1
a1629 1
	  SOME {file_time = object_time, ...} =>
d1634 1
a1634 1
		  load_time = object_time,
@


1.41.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a4 4
 * Revision 1.41  1997/06/13  16:19:09  jkbrook
 * [Bug #30158]
 * Merging in changes from 1.0r2c2 to 2.0m0
 *
@


1.41.2.2
log
@[Bug #30071]
Converted build system to project workspace.
@
text
@a0 33
(* Changed so far:
   
   Pre 11th August:  Added new field to project type.
   11th August:  Use object path in project instead of global object path.
	Expand %S to the full directory; remove %C.  Existing builds can
	use %S, but we can't have sub-directories of the object directory.
	So my cross-compiling scheme won't work.
	Remove check_aliases; symbolic links have no special effect because
	directory names are no longer part of module ids.

   Implications:
	Cross compiling won't work.
	Checks of module ids in mo files will cause problems.  Need to
	change these to remove directory names.

   20th August:
	GUI can load source OK.

   21st August:
	Now correctly checks dependencies for compiling single files.

   2nd Sep:
	Changes to basics/_module_id mean that compiling single files works.
	Recompiling a fresh checkout works, after renaming clashing file
	names.  Implies a need for separate subprojects.

   10th Sep:
	Can now read project information from a file, and build the
	current targets.
*)

  	
   
a4 3
 * Revision 1.41.2.1  1997/09/11  20:57:05  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d9 1
d147 2
a148 3
require "../main/proj_file";
require "../utils/map";
require "../utils/crash";
a154 1
require "../basis/os";
a161 1
  structure ProjFile: PROJ_FILE;
a168 1
  structure OS: OS;
a189 1
  type target_type = ProjFile.target_type
d247 1
a247 1
     source:   (string * MLWorks.Time.time) option ref,
d266 1
a266 24
  (* The Project type is the definition of a project.  It has the following
     elements:

     units:  A map from module_ids to units.
     source:  A list of directories to search for source files.
     library_path:  A list of directories to search for libraries
       (libraries are currently implemented as object files).
     object_dir:  A specification of where to put new object files.
     current_targets:  A list of top-level files, in build order, and the
       sort of deliverable.
     disabled_targets:  A list targets that are temporarily disabled.

     Currently the source path and object path are global, and targets
     are specified on the command line.
   *)

  datatype Project =
    PROJECT of
      {units: (ModuleId.ModuleId, Unit) NewMap.map,
       source: string list,
       library_path: string list,
       object_dir: string,
       current_targets: string list,
       disabled_targets: string list}
d277 2
a278 4
  fun currentTargets (PROJECT {current_targets, ...}) = current_targets

  fun get_name (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d285 2
a286 2
  fun get_requires (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d293 2
a294 2
  fun is_visible (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d301 2
a302 2
  fun set_visible (PROJECT {units, ...}, m, b) =
    case NewMap.tryApply' (units, m)
d310 2
a311 2
  fun get_source_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d315 2
a316 2
  fun set_source_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
d324 2
a325 2
  fun get_object_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d329 2
a330 2
  fun set_object_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
d339 2
a340 2
  fun get_loaded_info (PROJECT {units, ...}, m) =
    case NewMap.tryApply' (units, m)
d344 2
a345 2
  fun set_loaded_info (PROJECT {units, ...}, m, info) =
    case NewMap.tryApply' (units, m)
d354 1
a354 1
  fun clear_all_loaded_info (PROJECT {units, ...}, pred) =
d361 1
a361 1
      units
d370 15
a384 5

  (* Given a module_id for a user module and a source path, findSource
     finds the corresponding source file, and returns the file name and
     modification time. *)
  fun findFile ext (source_path, module_id) =
d386 1
a386 20
      fun search [] =
        (diagnostic (2, fn _ => ["Failed to find file"]);
	 NONE)
      |   search (dir::rest) =
        let
          val filename =
	    OS.Path.joinDirFile
              {dir = dir,
	       file = ModuleId.module_unit_to_string (module_id, ext)}

          val _ =
            diagnostic (2, fn _ => ["searching: ", filename])
        in
          case OldOs.mtime filename of
            OldOs.NOT_EXIST =>
  	      search rest
          | OldOs.EXISTS stamp =>
	      (diagnostic (2, fn _ => ["Found `", filename, "'"]);
	       SOME (filename, stamp))
        end
d388 6
a393 1
      search source_path
d395 1
a395 122

  (* objectName returns the file name of the mo file, after expanding the
     object path.  The object path consists of a pathname, in which one
     arc may be %S.  %S is replaced by the entry from the source path. *)

  val source_ext = "sml"
  val object_ext = "mo"

  val findSource = findFile source_ext

  local
    fun substitute_object_path (noSourceFn, object_dir, unit, module_id) =
      let
        fun substitute_object_path_arc "%S" =
          (case unit of
	     UNIT {source as ref (SOME (filename, _)), ...} =>
	       OS.Path.dir filename
	   | UNIT {source as ref NONE, ...} =>
	        noSourceFn module_id)
        |   substitute_object_path_arc s = s

        (* Explode the object_path into root and arcs, ready
           for expanding the %S component. *)
        val {isAbs, vol, arcs} =
	  OS.Path.fromString(OS.Path.fromUnixPath object_dir)

        val result =
          OS.Path.toString
            {isAbs = isAbs,
             vol = vol,
             arcs = map substitute_object_path_arc arcs @@
                    [ModuleId.module_unit_to_string(module_id, object_ext)]}
        in
          OS.Path.mkCanonical result
        end

      fun noSourceErrorFn loc module_id =
        (Info.default_error'
           (Info.FATAL, loc,
           (* LOCALE *)
            "Missing source information for module " ^
            ModuleId.string module_id))

      fun dirOfSourceFile (loc, source) module_id =
	case findSource (source, module_id) of
	  SOME (filename, _) =>
	    OS.Path.dir filename
	| NONE =>
            (Info.default_error'
               (Info.FATAL, loc,
               (* LOCALE *)
                "Missing source file for module " ^
                ModuleId.string module_id))


      (* objectName' finds the filename corresponding to an existing
	 source file. *)
      fun objectName' loc (object_dir, unit, module_id) =
	substitute_object_path (noSourceErrorFn loc, object_dir, unit, module_id)
    in
      (* objectFile finds the name and modification time of an object file
	 corresponding to a source file *)
      fun objectFile loc (object_dir, unit, module_id) =
        let
          val filename = objectName' loc (object_dir, unit, module_id)
        in
          case OldOs.mtime filename of
            OldOs.NOT_EXIST =>
              NONE
          | OldOs.EXISTS stamp =>
              (diagnostic (2, fn _ => ["Found `", filename, "'"]);
               SOME (filename, stamp))
        end

      (* findObject is similar to objectFile, but if the object path 
	 includes "%S" and the project doesn't contain info about the
	 source file, findObject searches the source path to find the
	 name of the source file.  (XXX Maybe it should record this
	 name in the project?). *)
      fun findObject location (source, object_dir, unit, module_id) =
        let
          val filename =
	    substitute_object_path
	      (dirOfSourceFile (location, source), object_dir, unit, module_id)
        in
          case OldOs.mtime filename of
            OldOs.NOT_EXIST =>
              (diagnostic (2, fn _ => ["`", filename, "' does not exist"]);
               NONE)
          | OldOs.EXISTS stamp =>
              (diagnostic (2, fn _ => ["Found `", filename, "'"]);
               SOME (filename, stamp))
        end

      (* objectName is externally visible; it finds the object filename
	 corresponding to an existing source file. *)
      fun objectName
	    (error_info, loc)
	    (PROJECT {units, object_dir, ...}, module_id) =
        let
          val unit = 
            case NewMap.tryApply' (units, module_id) of
	      SOME unit => 
		unit
	    | NONE =>
	        (* This is probably impossible *)
                (Info.default_error'
                   (Info.FATAL, loc,
                    (* LOCALE *)
                    "Missing unit information for module " ^
 	            ModuleId.string module_id))
        in
	  case unit of
	    UNIT {object as ref (SOME {file, file_time, ...}), ...} =>
	      file
	  | _ =>
	    objectName' loc (object_dir, unit, module_id)
	end   
    end

	
   
d404 1
a404 1
      (diagnostic (2, fn _ => ["Failed to find object"]);
d415 2
a416 3
      of SOME (file, _, time) =>
        (diagnostic (2, fn _ => ["Found `", file, "'"]);
	 SOME (file, time))
d418 2
a419 2
        (diagnostic (2, fn _ => ["Failed to find source"]);
	 NONE)
d423 2
a424 2
  fun module_name_from_require req_name =
    ModuleId.add_path (ModuleId.empty_path, req_name)
d430 1
a430 1
		SOME (filename, mod_time), unit) =
d435 3
a437 1
      val sub_modules = map module_name_from_require requires
d441 1
a441 1
  	(source := SOME (filename, mod_time);
d519 1
a519 3
            (diagnostic (3,
               fn _ => ["calling load_object from new_unit"]);
	     load_object mo_info unit;
a529 1

a534 1
(*
d629 1
a629 2
*)

d656 1
a656 3
        (PROJECT {units, source, library_path, object_dir,
		  current_targets, disabled_targets},
	 module_id, seen_init): (Project * StatusMap) =
d668 1
a668 1
	    ((units, seen), module_id) =
d678 3
a680 3
  	  fun check_src (unit, src_info) =
  	    case !src_info
  	    of sml_info as SOME (filename, time_stamp) =>
d689 1
a689 1
		      SOME (filename, mod_time), unit)
d701 1
a701 1
		      findSource (source, module_id),
d712 1
a712 1
		   findSource (source, module_id),
d734 1
a734 1
		      (objectFile location (object_dir, unit, module_id))
d743 1
a743 1
		  (objectFile location (object_dir, unit, module_id))
d749 1
a749 1
  	      case NewMap.tryApply' (units, module_id)
d756 1
a756 1
  	           (units, unit))
d768 1
a768 1
	              (true, units, module_id, sml_info, mo_info, NONE)
d772 4
a775 9
		    val src_info =
		      findSource (source, module_id)

                    val _ = diagnostic (3, fn _ => ["calling new_unit"]);
		    val (units', unit) = 
	              new_unit
	                error_info
	                (false, units, module_id, src_info, NONE, NONE);

d777 3
a779 5
                    diagnostic (3, fn _ => ["calling load_object"]);
		    load_object
		        (objectFile location (object_dir, unit, module_id))
		        unit;
		      (units', unit)
d782 1
a782 1
	    fun sub_units (UNIT {requires, source, object, name, ...}) =
d811 1
a811 1
	         (units, seen))
d814 1
a814 1
		 of (units', unit) =>
d818 1
a818 1
		     ((units', mark_visited (seen, module_id)),
d826 1
a826 1
	val (units', seen') =
d829 1
a829 1
	    ((units, seen_init), module_id)
d831 1
a831 8
        (PROJECT
	   {units = units',
	    source = source,
	    library_path = library_path,
	    object_dir = object_dir,
	    disabled_targets = disabled_targets,
	    current_targets = current_targets},
	 seen')
d844 1
a844 3
        (PROJECT {units, source, library_path, object_dir,
		  current_targets, disabled_targets},
	 module_id, seen_init): Project * StatusMap =
d851 1
a851 1
	    (module_id, (units, seen)) =
d876 1
a876 1
		    (findObject location (source, object_dir, unit, module_id))
d880 1
a880 1
		(findObject location (source, object_dir, unit, module_id))
d886 1
a886 1
  	      case NewMap.tryApply' (units, module_id)
d889 1
a889 1
  	         (units, unit))
d891 10
a900 25
  	        let
		  (* XXX I'm not sure that this works.  The code used to
		   * check for the existence of the object file before
		   * creating the new unit.
		   * - Does findObject cope OK in this case?  (Almost
		   *   certainly not).
		   * - Should we retract the new unit before reporting
		   *   the error?
		   *)
		  val (units', unit) = 
	            new_unit
	              error_info
	              (false, units, module_id, NONE, NONE, NONE);
  	        in
		  case findObject
		         location (source, object_dir, unit, module_id)
		  of mo_info as SOME _ =>
		    (load_object mo_info unit;
		     (units', unit))
		  |  NONE =>
                    Info.error'
                      error_info
                      (Info.FATAL, Info.Location.FILE mod_name,
		       "No object file.")
		end
d903 1
a903 1
	    fun recurse ((units, seen), {mod_name = sub_name, req_name, time}) =
d907 1
a907 1
		  (units, mark_visited (seen, module_id)))
d923 1
a923 1
	         (units, seen))
d926 1
a926 1
  	           (units',
d932 1
a932 1
  	             Lists.reducel recurse ((units', seen), const)
d947 3
a949 3
  	fun check_src (unit, src_info) =
  	  case !src_info
  	  of sml_info as SOME (filename, time_stamp) =>
d957 1
a957 1
		   (false, error_info, SOME (filename, mod_time), unit)
d963 1
a963 1
		   findSource (source, module_id),
d968 1
a968 1
	       findSource (source, module_id),
d972 2
a973 2
	val (units, UNIT unit) =
  	  case NewMap.tryApply' (units, module_id)
d976 1
a976 1
  	     (units, unit))
d980 1
a980 1
		findSource (source, module_id)
d982 3
a984 3
	      new_unit
	        error_info
	        (false, units, module_id, sml_info, NONE, NONE)
d987 1
a987 1
        val (units', seen') =
d991 1
a991 1
	    fun recurse ((units, seen), require_id) =
d994 1
a994 1
		(require_id, (units, mark_visited (seen, module_id)))
d996 1
a996 1
  	    Lists.reducel recurse ((units, seen_init), !(#requires unit))
d999 1
a999 8
        (PROJECT
	   {units = units',
	    source = source,
	    library_path = library_path,
	    object_dir = object_dir,
	    current_targets = current_targets,
	    disabled_targets = disabled_targets},
	 seen')
d1082 1
a1082 1
        (PROJECT {units, ...}, dependencies, check_one) =
d1084 1
a1084 1
      (check_sub_unit (error_info, location, units, check_one, check_one))
d1098 1
a1098 1
	(PROJECT {units, ...}, level, module_id, UNIT unit)
d1113 1
a1113 1
	           (error_info, location, units, check_one_loaded, check_one_mo)))
d1137 1
a1137 1
    |  SOME (s_file, s_time) =>
d1188 1
a1188 1
         |  SOME (s_file, s_time) =>
d1229 1
a1229 1
       |  SOME (s_file, s_time) =>
d1262 1
a1262 1
            |  SOME (s_file, s_time) =>
d1329 1
a1329 1
	 check_times, check_validity, project as PROJECT {units, ...})
d1349 1
a1349 1
  	  NewMap.apply' (units, module_id)
d1427 1
a1427 1
  fun list_units (PROJECT {units, ...}) =
d1430 1
a1430 1
      (map (fn m => (ModuleId.string m, m)) (NewMap.domain units))
d1435 1
a1435 43
      val default_source =
	["/u/daveb/ml_irix/MLW/src/basics", 
	 "/u/daveb/ml_irix/MLW/src/basis", 
	 "/u/daveb/ml_irix/MLW/src/debugger", 
	 "/u/daveb/ml_irix/MLW/src/editor", 
	 "/u/daveb/ml_irix/MLW/src/gui", 
	 "/u/daveb/ml_irix/MLW/src/harp", 
	 "/u/daveb/ml_irix/MLW/src/interpreter", 
	 "/u/daveb/ml_irix/MLW/src/lambda", 
	 "/u/daveb/ml_irix/MLW/src/lexer", 
	 "/u/daveb/ml_irix/MLW/src/main", 
	 "/u/daveb/ml_irix/MLW/src/make", 
	 "/u/daveb/ml_irix/MLW/src/match", 
	 "/u/daveb/ml_irix/MLW/src/parser", 
	 "/u/daveb/ml_irix/MLW/src/pervasive", 
	 "/u/daveb/ml_irix/MLW/src/rts/gen", 
	 "/u/daveb/ml_irix/MLW/src/typechecker", 
	 "/u/daveb/ml_irix/MLW/src/utils", 
	 "/u/daveb/ml_irix/MLW/src/unix", 
	 "/u/daveb/ml_irix/MLW/src/motif", 
	 "/u/daveb/ml_irix/MLW/src/sparc"]

      val default_libs = ["pervasive"]

      val default_object_dir = "/u/daveb/ml_irix/MLW/objects/"

      val default_targets =
        ["require_all", "__batch", "xinterpreter"]

	(*
        [("require_all", ProjFile.LIBRARY),
 	 ("__batch", ProjFile.IMAGE),
 	 ("xinterpreter", ProjFile.IMAGE)]
	 *)

      val project =
        PROJECT
          {units = NewMap.empty' ModuleId.lt,
           source = default_source,
           library_path = default_libs,
           object_dir = default_object_dir,
           current_targets = default_targets,
           disabled_targets = []}
d1443 2
a1444 10
  (* Not clear what this should do now. *)
  fun delete (PROJECT {units, source, library_path, object_dir,
		       current_targets, disabled_targets}, module_id) =
    PROJECT
      {units = NewMap.undefine (units, module_id),
       source = source,
       library_path = library_path,
       object_dir = object_dir,
       current_targets = current_targets,
       disabled_targets = disabled_targets}
a1462 31
  fun update
	(error_info, loc)
	(PROJECT
	   {units, source, library_path, object_dir,
	    current_targets, disabled_targets})
	{sourcePath: string list,
	 objectsLoc: string,
	 libraryPath: string list,
	 curTargets: string list,
	 disTargets: string list} =
    let
      val new_proj =
        PROJECT
          {source = sourcePath,
           object_dir = objectsLoc,
           library_path = libraryPath,
           current_targets = curTargets,
           disabled_targets = disTargets,
           units = NewMap.empty' ModuleId.lt}

      val targets = curTargets @@ disTargets

      fun do_one (target, (p, smap)) =
        do_read_dependencies
	  USER
	  (error_info, loc)
	  (p, ModuleId.from_host (target, loc), smap)
    in
      #1 (foldl do_one (new_proj, empty_map) targets)
    end

a1556 22
  (* allObjects returns a list of all object files, ordered by
     dependency.  It is used to write a file for use by the loader. *)
  fun allObjects (error_info, location) (project, module_id) =
    let
      (* The check_times argument to check_dep always returns false,
	 so that every file is added to the list.
	 XXX I attempted to call is_valid_object to check that the object
	     files are up to date.  But is_valid_object checks validity
	     w.r.t. loaded pervasive library (i.e. for loading into the
	     GUI).
	 XXX I'm not sure about get_sub_mos: it silently returns an
	     empty list is the unit doesn't include any object info.
	     But is_valid_object should catch this case first. *)
      val (out_of_date, _, _) =
        check_dep
	  (error_info, 0, get_sub_mos,
	   fn _ => fn _ => false, always_valid, project)
	  (([], empty_map, []), module_id)
    in
      rev out_of_date
    end

d1598 1
a1598 1
    fun reset_pervasives (PROJECT {units, ...}) =
d1601 1
a1601 1
        units
d1611 1
a1611 1
    fun remove_file_info (PROJECT {units, ...}) =
d1614 1
a1614 1
	units
a1615 34
    
  fun fromFileInfo (error_info, loc) =
    let
      val (curTargets, disTargets, _) =
	ProjFile.getTargets ()

      val (libraryPath, objectsLoc, binariesLoc) =
	ProjFile.getLocations ()

      val new_proj =
        PROJECT
          {source = ProjFile.getSourcePath (),
           library_path = libraryPath,
           object_dir = objectsLoc,
           current_targets = curTargets,
           disabled_targets = disTargets,
           units = NewMap.empty' ModuleId.lt}

      val init_proj =
        #1 (do_read_dependencies
	      PERVASIVE 
              (error_info, loc)
              (new_proj, Io.pervasive_library_id, empty_map))

      val targets = curTargets @@ disTargets

      fun do_one (target, (p, smap)) =
        do_read_dependencies
	  USER
	  (error_info, loc)
	  (p, ModuleId.from_host (target, loc), smap)
    in
      #1 (foldl do_one (init_proj, empty_map) targets)
    end
@


1.41.2.3
log
@[Bug #20090]
Merged from trunk:
Changed consistency info in object files to store the modification times
of the corresponding source files.
Ditto for loaded object files.
@
text
@a37 4
 * Revision 1.41.2.2  1997/09/17  15:57:37  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
d239 2
a240 2
     time stamps of the object files or loaded modules on which they
     depend.  Using this type in both fields allows the dependency checking code
d266 1
a266 3
	modification times of the source file, which is called the time stamp.
	It also contains the time stamps of (i.e. the modification times of the
	source files that correspond to) the pervasive library and all the
a269 2
	The consistency information is set when the file is written by
	Encapsulate.output_file, which is called from <URI:/_toplevel.sml>.
d271 3
a273 6
	Contains the modification time of the file from which the compilation
	unit was loaded (if a source file) or its time stamp (if an object file),
        the time that it was loaded, the compiled module, and the load times of
        the loaded modules on which it depends.
	This information is set when loading a module, in
        <URI://MLWinterpreter/_intermake.sml>.
d1239 3
a1241 12
  (* compare_timestamp allows time stamps to differ by up to 5 seconds from
     the modification time of the file, to allow for InstallShield's unpleasant
     behaviour.  Now that we store time stamps in the consistency information
     of object files, instead of the modification times of the dependent files
     themselves, this doesn't affect us directly.  But it could affect people
     who distribute both source and object files.
     This function should be used whenever a time stamp stored in an object file
     is compared against the actual modification time of a source file.  It is
     not needed when two stored time stamps are compared, or when the modification
     times of two source files are compared.  All comparisons of file times in
     _project are commented to explain whether compare_timestamp is needed. *)     
  fun compare_timestamp (t1, t2) =
d1249 4
a1252 4
  (* check_one_mo checks the time stamp of a given mo file against a
     supplied time.  The supplied time is always from the consistency
     information stored in an object file.  Since both times are read
     from object files, there is no need to use compare_timestamp. *) 
d1255 2
a1256 2
    of SOME {time_stamp, ...} =>
      if time = time_stamp then
d1268 1
a1268 8
     supplied time.  This time is usually from the dependency list of
     a loaded module, which stores the time that the dependent module
     was loaded.  If the times differ, the module containing the dependency
     list is out of date.
     The exceptional case is when check_one_loaded is called from is_valid_object
     (see that definition for an explanation).
     Since these times are not the modification times of delivered files, 
     there is no need to use compare_timestamp.  *)
d1273 1
a1273 1
      if load_time = load_time' then
d1311 3
a1313 2
  (* check_dependencies checks a dependency list against the info stored in
     a project.  It returns true if the information is consistent.  *)
a1342 4
 	    (* check_sub_unit is passed check_one_loaded to check the pervasive
	       library.  This works because when the GUI images are built, the
	       loaded info for the pervasive modules is reset to store the
	       time stamps of the files (see reset_pervasives, below). *)
d1360 2
a1361 4
  (* check_compile_times checks the timestamp in an object file against the
     modification time of the corresponding source file.  If they are equal,
     it then calls check_dependencies to check the object file's consistency
     information. *)
d1374 1
a1374 4
	(* Since we are comparing a stored time stamp against the modification
	   time of an actual file, we use compare_timestamp to allow for
           slippage. *)
        if compare_timestamp (time_stamp, s_time) then
d1389 2
a1390 16
     object file.

     If the module was loaded from a source file, and the file being 
     loaded is a source file, then it is enough to compare the modification
     time of the file against that in the loaded information. 

     If the module was loaded from a source file, and the file being loaded
     is an object file, or vice versa, then the modification time in the loaded
     info is compared with both the modification time in the source info and
     the time stamp in the object file.  If they are all equal, then the object
     file is equivalent to the loaded module.

     If the module was loaded from an object file, and the file being loaded
     is an object file, then the timestamp of the file being loaded is compared
     against the "modification time" in the loaded information. *)

d1402 1
a1402 3
 	(* The time and time_stamp are both read from the object file, so we
           don't need to use compare_timestamp. *)
        if time = time_stamp then
d1423 1
a1423 4
           (* We are now comparing a time stamp from an object file with
      	      the actual modification time of the source file, so we use
	      compare_timestamp to allow for slippage.  *)
           if compare_timestamp (time, s_time) then
d1426 1
a1426 1
              if compare_timestamp (time_stamp, s_time) then
d1464 1
a1464 4
	 (* We are comparing the modification time of two source files directly,
   	    so we don't have to allow for slippage; therefore we don't use
	    compare_timestamp. *)
         if time = s_time then
d1484 1
a1484 3
	 (* We are comparing time stamps read from object files, therefore we
	    don't need to use compare_timestamp. *)
         if time = time_stamp then
d1497 1
a1497 4
	      (* We are now comparing a time stamp with the actual modification
	         time of a source file.  Therefore we have to allow for slippage
 		 by using compare_timestamp. *)
	      if compare_timestamp (time_stamp, s_time) then
d1909 1
a1909 1
	  SOME {time_stamp, file_time = object_time, ...} =>
d1914 1
a1914 1
		  load_time = time_stamp,
@


1.41.2.4
log
@[Bug #30089]
Merged from trunk:
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@a37 8
 *
 * Revision 1.41.2.3  1997/10/29  11:41:00  daveb
 * [Bug #20090]
 * Merged from trunk:
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 * Ditto for loaded object files.
 *
a182 1
require "../system/__time";
d191 1
d210 2
a215 1
  structure OS : OS
a225 1
  structure FileSys = OS.FileSys
d235 1
a235 1
  val _ = Diagnostic.set 3
d248 1
a248 1
      {mod_name : string, req_name : string, time : Time.time} list
d251 2
a252 2
    OBJECT of Time.time
  | SOURCE of Time.time
d298 1
a298 1
     source:   (string * Time.time) option ref,
d300 2
a301 2
     object:   {file_time: Time.time,
		time_stamp: Time.time,
d308 1
a308 1
		load_time: Time.time,
d465 6
a470 8
	  let
            val mod_time = FileSys.modTime filename
	  in
	    diagnostic (2, fn _ => ["Found `", filename, "'"]);
	    SOME (filename, mod_time)
	  end
	  handle OS.SysErr _ =>
  	    search rest
d541 6
a546 8
	  let
	     val mod_time = FileSys.modTime filename
	  in
            diagnostic (2, fn _ => ["Found `", filename, "'"]);
            SOME (filename, mod_time)
	  end
	  handle OS.SysErr _ =>
	    NONE
d560 7
a566 9
	  let
	    val mod_time = FileSys.modTime filename
	  in
            diagnostic (2, fn _ => ["Found `", filename, "'"]);
            SOME (filename, mod_time)
	  end
	  handle OS.SysErr _ =>
            (diagnostic (2, fn _ => ["`", filename, "' does not exist"]);
             NONE)
d889 5
a893 6
	      (let
		 val mod_time = FileSys.modTime filename
	       in
		 if time_stamp = mod_time then
		   ()
		 else
d897 2
a898 3
	       end
	       handle OS.SysErr _ =>
		 (mesg_fn (location,
d900 10
a909 10
		  if is_pervasive = PERVASIVE then
		    load_src
		      (true, error_info,
		       findPervasiveSource (error_info, location) module_id,
		       unit)
		  else
		    load_src
		      (false, error_info,
		       findSource (source, module_id),
		       unit)))
d926 9
a934 10
	      (let
		 val mod_time = FileSys.modTime file
	       in
		 if time_stamp = mod_time then
		   ()
		 else
		   load_object (SOME (file, mod_time)) unit
	       end handle OS.SysErr _ =>
		 (mesg_fn (location,
			   "Object file " ^ file ^ " has disappeared");
d936 3
a938 3
		    load_object
		    (findPervasiveObject (error_info, location) module_id)
		    unit
d1089 8
a1096 9
	      (let
		 val mod_time = FileSys.modTime file
	       in
		 if time_stamp = mod_time then
		   ()
		 else
		   load_object (SOME (file, mod_time)) unit
	       end handle OS.SysErr _ =>
		 (mesg_fn (location,
d1189 6
a1194 7
	    (let
	       val mod_time = FileSys.modTime filename
	     in
	       if time_stamp = mod_time then
		 ()
	       else
		 load_src
d1196 2
a1197 2
	     end handle OS.SysErr _ => 
	       (mesg_fn (location,
d1263 2
a1264 3
      val diff =
	if Time.<(t1, t2) then Time.-(t2, t1) else Time.-(t1, t2)
      val rdiff = Time.toReal diff
d1266 1
a1266 1
      rdiff < real(5)
d1420 1
@


1.41.2.5
log
@[Bug #30071]
Removed temporary default values for project.
Added support for current configurations, modes and targets.
@
text
@a37 5
 * Revision 1.41.2.4  1997/10/30  16:29:01  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
d243 1
a243 1
  val _ = Diagnostic.set 0
d1750 35
d1788 4
a1791 4
           source = [],
           library_path = [],
           object_dir = "%S",
           current_targets = [],
a2042 17
      val (_, configDetails, currentConfig) = ProjFile.getConfigurations ()

      val sourcePath = ProjFile.getSourcePath ()

      val (source, library, objects, bins) =
	case currentConfig of
	  NONE => (sourcePath, libraryPath, objectsLoc, binariesLoc)
	| SOME name =>
	  (case ProjFile.getConfigDetails (name, configDetails) of
	     {source, library, objects, bins, ...} =>
	        (source @@ sourcePath,
	         library @@ libraryPath,
	         objects, 
	         bins))
        (* XXX - handler needed for NoConfigDetailsFound -
	  or put this functionality in ProjFile *)

d2045 3
a2047 3
          {source = source,
           library_path = library,
           object_dir = objects,
@


1.41.2.6
log
@[Bug #30326]
@
text
@a37 5
 * Revision 1.41.2.5  1997/11/06  16:22:28  daveb
 * [Bug #30071]
 * Removed temporary default values for project.
 * Added support for current configurations, modes and targets.
 *
d210 1
a210 1
require "mlworks_io";
@


1.41.2.7
log
@[Bug #30071]
@
text
@a37 3
 * Revision 1.41.2.6  1997/11/20  17:01:35  daveb
 * [Bug #30326]
 *
d212 1
d227 1
d234 4
a237 2
  sharing type Depend.ModuleId = ModuleId.ModuleId = Io.ModuleId
  sharing type Depend.Info.Location.T = ModuleId.Location
d248 1
d363 1
a363 1
  exception NoSuchModule of ModuleId.ModuleId
d620 1
a620 19
  fun findPervasiveFile ext module_id =
    let
      val filename =
        OS.Path.joinDirFile
          {dir = Io.get_pervasive_dir(),
           file = ModuleId.module_unit_to_string (module_id, ext)}

      val _ = diagnostic (2, fn _ => ["looking for: ", filename])

      val mod_time = FileSys.modTime filename
    in
      diagnostic (2, fn _ => ["Found `", filename, "'"]);
      SOME (filename, mod_time)
    end
    handle
      OS.SysErr _ => NONE
    | Io.NotSet _ => NONE


d623 8
a630 1
  val findPervasiveObject = findPervasiveFile object_ext
d635 12
a646 2
  val findPervasiveSource = findPervasiveFile source_ext

d762 96
d929 1
a929 1
		       findPervasiveSource module_id,
d940 1
a940 1
		   findPervasiveSource module_id,
d964 1
a964 1
		    (findPervasiveObject module_id)
d973 1
a973 1
		  (findPervasiveObject module_id)
d995 1
a995 1
		      findPervasiveSource module_id
d997 1
a997 1
		      findPervasiveObject module_id
@


1.41.2.8
log
@[Bug #30071]
Relative path names are relative to the directory containing the
project file -- ensure this in fromFileInfo.
@
text
@a37 3
 * Revision 1.41.2.7  1997/11/26  16:17:08  daveb
 * [Bug #30071]
 *
d251 1
a251 1
  val _ = Diagnostic.set 3
d1925 1
a1925 1
      val (source, library, objects, binaries) =
a1937 15
      val (abs_source, abs_objects, abs_binaries) =
	let val dir = ProjFile.getProjectDir ()
	in
	  if OS.Path.isRelative dir then
	    (* dir should always be absolute, but we need to return some
	       value in the exceptional case. *)
	    (diagnostic (1, fn _ => ["Project Dir is relative: ", dir]);
	     (source, objects, binaries))
	  else
	    (diagnostic (1, fn _ => ["Project Dir is absolute: ", dir]);
	     (map (fn x => OS.Path.mkAbsolute (x, dir)) source,
	      OS.Path.mkAbsolute (objects, dir),
	      OS.Path.mkAbsolute (binaries, dir)))
	end

d1940 1
a1940 1
          {source = abs_source,
d1942 1
a1942 1
           object_dir = abs_objects,
@


1.41.2.9
log
@[Bug #30071]
Unset diagnostics.
@
text
@a37 5
 * Revision 1.41.2.8  1997/12/01  11:17:15  daveb
 * [Bug #30071]
 * Relative path names are relative to the directory containing the
 * project file -- ensure this in fromFileInfo.
 *
d254 1
a254 1
  val _ = Diagnostic.set 0
@


1.41.2.10
log
@[Bug #30071]
Search library path for object files.  Remove "%S" option for objects.
@
text
@a29 9


   XXX Various stuff  -- see change log.

   2nd Dec:
	Wired up library path.  Dropped %S, because I've changed our
	makefiles to look in object dir.  Haven't really tested the
	library path stuff yet.
	
a37 4
 * Revision 1.41.2.9  1997/12/01  12:24:48  daveb
 * [Bug #30071]
 * Unset diagnostics.
 *
d466 7
a472 2
  (* Given a module_id for a user module and a search path, findFile
     finds the corresponding file, and returns the file name and
d474 1
a474 1
  fun findFile ext (search_path, module_id) =
d499 1
a499 1
      search search_path
d502 4
a508 3
  (* Given a module_id for a user module, and a source path, findSource
     finds the corresponding source file, and returns the file name and
     modification time. *)
a510 6
  (* findObject is more complicated than findSource.  The first place to
     look is in the object directory, which is simple enough.  If there
     isn't a file there, then there are two cases:
       1. If a source file exists, then stop.
       2. If there isn't a source file, then search the library path
	  for a library entry.  *)
d512 1
a512 16
    (* objectName' finds the filename corresponding to an existing
       source file. *)
    fun objectName' (object_dir, module_id) =
      OS.Path.concat
	(object_dir, ModuleId.module_unit_to_string(module_id, object_ext))

    fun search_lib_path (NONE, _) = NONE
    |   search_lib_path (SOME lib_path, module_id) =
      findFile object_ext (lib_path, module_id)
  in
    (* Given a module_id for a user module, and an optional library path,
       findObject finds the corresponding object file, and returns the
       file name and modification time. *)
    (* We should probably add an argument that specifies whether an object
       file is definitely required, or whether it's OK if it's missing. *)
    fun findObject (object_dir, lib_path_opt, module_id) =
d514 83
a596 7
        val filename = objectName' (object_dir, module_id)
      in
	let
	  val mod_time = FileSys.modTime filename
	in
          diagnostic (2, fn _ => ["Found `", filename, "'"]);
          SOME (filename, mod_time)
a597 3
        handle OS.SysErr _ =>
          search_lib_path (lib_path_opt, module_id)
      end
d599 25
a623 25
    (* objectName is externally visible; it finds the object filename
       corresponding to an existing source file. *)
    fun objectName
          (error_info, loc)
	  (PROJECT {units, object_dir, ...}, module_id) =
      let
        val unit = 
          case NewMap.tryApply' (units, module_id) of
	    SOME unit => 
	      unit
	  | NONE =>
	      (* This is probably impossible *)
              (Info.default_error'
                 (Info.FATAL, loc,
                  (* LOCALE *)
                  "Missing unit information for module " ^
 	          ModuleId.string module_id))
      in
	case unit of
	  UNIT {object as ref (SOME {file, ...}), ...} =>
	    file
        | _ =>
          objectName' (object_dir, module_id)
      end   
  end
d820 1
a820 3
	  (* Check that the source info recorded in the project is
	     still valid. *)
  	  fun check_src (unit as UNIT {source = src_info, ...}) =
d859 1
a859 20
	  (* This function is local to check_obj. *)
	  fun load_new_object (unit as UNIT {source = src_info, ...}) =
	    if is_pervasive = PERVASIVE then
	      load_object
	        (findPervasiveObject module_id)
	        unit
	    else
	      let
	        (* Don't search the library path if a source file exists. *)
		val lib_path_opt =
		  if isSome (!src_info) then NONE else SOME library_path
	      in
  	        load_object
	          (findObject (object_dir, lib_path_opt, module_id))
		  unit
	      end

	  (* Check that the object info recorded in the project is
	     still valid. *)
  	  fun check_obj (unit as UNIT {object, ...}) =
d873 8
a880 1
		  load_new_object unit))
d882 8
a889 1
	      load_new_object unit
d895 3
a897 3
  	      of SOME unit =>
  	        (check_src unit;
  	         check_obj unit;
d910 1
d917 2
a918 1
		    val src_info = findSource (source, module_id)
a925 3
		    (* Don't search library path if we have source *)
		    val lib_path_opt =
		      if isSome src_info then NONE else SOME library_path
d929 3
a931 3
		      (findObject (object_dir, lib_path_opt, module_id))
		      unit;
		    (units', unit)
d1038 1
a1038 1
	            (findObject (object_dir, SOME library_path, module_id))
d1042 1
a1042 1
	        (findObject (object_dir, SOME library_path, module_id))
d1057 2
a1058 2
		   * - Does findObject cope OK in this case?  (Probably,
		   *   now that we've dropped %S).
d1067 2
a1068 1
	          case findObject (object_dir, SOME library_path, module_id)
d1676 1
a1676 1
           object_dir = "",
@


1.41.2.11
log
@[Bug #30071]
Made fromFileInfo take a project to update.
Removed update function.
Interpret relative library paths w.r.t. to projectDir, not current dir.
@
text
@a46 4
 * Revision 1.41.2.10  1997/12/02  14:06:20  daveb
 * [Bug #30071]
 * Search library path for object files.  Remove "%S" option for objects.
 *
d72 1
a907 4
		  (* Could check for a loaded module here -- if it exists,
		     a load command can continue.  But a compilation will
		     fall over, so we have to be pessimistic.
		     Daveb, 4/12/97. *)
d957 1
a957 1
  (* read_object_dependencies takes a file name and returns a Project that
d1158 5
a1162 6
     This function should be used whenever a time stamp stored in an object
     file is compared against the actual modification time of a source file.
     It is not needed when two stored time stamps are compared, or when the
     modification times of two source files are compared.  All comparisons
     of file times in _project are commented to explain whether
     compare_timestamp is needed. *)     
d1231 1
a1231 1
	  check_perv (location, time, unit, mod_name))
a1322 1

d1676 31
d1883 1
a1883 6
  (* The idea of preserving the units is not to lose information about
     loaded files.  But this doesn't really work, because if the source
     path changes some of the loaded information will be out of date. *)
  fun fromFileInfo
	(error_info, loc)
	(PROJECT {units, ...}) =
d1908 1
a1908 1
      val (abs_source, abs_library, abs_objects, abs_binaries) =
d1915 1
a1915 1
	     (source, library, objects, binaries))
a1918 1
	      map (fn x => OS.Path.mkAbsolute (x, dir)) library,
d1926 1
a1926 1
           library_path = abs_library,
d1930 1
a1930 1
           units = units}
d1937 1
a1937 1
  
@


1.41.2.12
log
@[Bug #30071]
Remove specification of objects and binaries locations from configurations.
@
text
@a46 6
 * Revision 1.41.2.11  1997/12/04  16:43:42  daveb
 * [Bug #30071]
 * Made fromFileInfo take a project to update.
 * Removed update function.
 * Interpret relative library paths w.r.t. to projectDir, not current dir.
 *
d1883 1
a1883 1
	     {source, library, ...} =>
d1886 2
a1887 2
		 OS.Path.concat(objectsLoc, name),
	         OS.Path.concat(binariesLoc, name)))
@


1.41.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a4 4
 * Revision 1.41  1997/06/13  16:19:09  jkbrook
 * [Bug #30158]
 * Merging in changes from 1.0r2c2 to 2.0m0
 *
@


1.40
log
@[Bug #30090]
Translate output std_out to print
@
text
@d5 5
d1001 10
d1018 1
a1018 1
      if time = file_time then
d1035 1
a1035 1
      if load_time = load_time' then
d1136 1
a1136 1
        if time_stamp = s_time then
d1164 1
a1164 1
        if time = file_time then
d1185 1
a1185 1
           if time = s_time then
d1188 1
a1188 1
              if time_stamp = s_time then
d1226 1
a1226 1
         if time = s_time then
d1246 1
a1246 1
         if time = file_time then
d1259 1
a1259 1
	      if time_stamp = s_time then
@


1.39
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d5 4
d355 1
a355 1
    MLWorks.IO.output (MLWorks.IO.std_out, Info.Location.to_string location ^ ": " ^ s ^ "\n")
d461 1
a461 2
     (MLWorks.IO.output(MLWorks.IO.std_out, "Corrupt object file '" ^ filename ^
	     "' treating as out of date\n");
@


1.38
log
@[Bug #30088]
Get rid of MLWorks.Option
Make sure reset_pervasives preserves dependencies for Encapsulate.decode_type_basis
@
text
@d5 5
d156 1
a156 1
  structure Io: IO;
@


1.37
log
@Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
@
text
@d5 3
a172 2
  open MLWorks.Option;
  
d1544 25
a1568 24
        case !(#object unit)
        of SOME {file_time = object_time, ...} =>
          (case !r
           of SOME {file_time, load_time, basis, id_cache, module, ...} =>
             r := SOME
                    {file_time = OBJECT object_time,
                     load_time = object_time,
                     basis = basis,
                     id_cache = id_cache,
                     module = module,
                     dependencies = DEPEND_LIST []}
           |  NONE =>
             Crash.impossible
               ("Can't find loaded info for `"
                ^ ModuleId.string (#name unit)
                ^ "' in reset_pervasives"))
        |  NONE =>
          Crash.impossible
            ("Can't find object file for `"
             ^ ModuleId.string (#name unit)
             ^ "' in reset_pervasives");
        #object unit := NONE;
        #source unit := NONE;
        #requires unit := []
@


1.37.1.1
log
@branched from 1.37
@
text
@a4 3
 * Revision 1.37  1997/02/12  13:22:47  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 *
@


1.37.1.2
log
@[Bug #30158]
Allowed time stamps to differ by up to 5 seconds.
@
text
@a4 3
 * Revision 1.37.1.1  1997/05/12  10:36:05  hope
 * branched from 1.37
 *
a989 10
  (* compare_timestamps allows timestamps to differ by up to 5 seconds, to
     allow for InstaalShield's unpleasant behaviour. *)
  fun compare_timestamps (t1, t2) =
    let
      val diff = MLWorks.Time.interval (t1, t2)
      val rdiff = MLWorks.Time.Interval.to_real diff
    in
      real(~5) < rdiff andalso rdiff < real(5)
    end

d997 1
a997 1
      if compare_timestamps (time, file_time) then
d1014 1
a1014 1
      if compare_timestamps (load_time, load_time') then
d1115 1
a1115 1
        if compare_timestamps (time_stamp, s_time) then
d1143 1
a1143 1
        if compare_timestamps (time, file_time) then
d1164 1
a1164 1
           if compare_timestamps (time, s_time) then
d1167 1
a1167 1
              if compare_timestamps (time_stamp, s_time) then
d1205 1
a1205 1
         if compare_timestamps (time, s_time) then
d1225 1
a1225 1
         if compare_timestamps (time, file_time) then
d1238 1
a1238 1
	      if compare_timestamps (time_stamp, s_time) then
@


1.37.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 4
 * Revision 1.37.1.2  1997/05/29  18:32:39  daveb
 * [Bug #30158]
 * Allowed time stamps to differ by up to 5 seconds.
 *
@


1.37.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 4
 * Revision 1.37.1.2  1997/05/29  18:32:39  daveb
 * [Bug #30158]
 * Allowed time stamps to differ by up to 5 seconds.
 *
@


1.37.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 4
 * Revision 1.37.1.2  1997/05/29  18:32:39  daveb
 * [Bug #30158]
 * Allowed time stamps to differ by up to 5 seconds.
 *
@


1.37.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 3
 * Revision 1.37.1.2.1.1  1997/07/28  18:21:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.36
log
@[Bug #1728]
__integer becomes __int
@
text
@d2 2
d5 4
a119 2
 *  
 * Copyright (c) 1995 Harlequin Ltd.
d347 2
a348 2
  (* Given a module_id for a user module, find_mo finds the corresponding mo
     file, and returns the file name and modification time. *)
d351 2
a352 2
  fun find_mo error_info module_id =
    case Module.find_mo error_info module_id
d359 1
a359 1
  (* Given a module_id for a user module, find_sml finds the corresponding
d365 1
a365 1
  fun find_sml error_info module_id =
d367 1
a367 1
      val result = Module.find_sml error_info module_id
d377 1
a377 1
  (* Given a module_id for a pervasive module, find_pervasive_mo finds the
d379 8
a386 13
  fun find_pervasive_mo error_info module_id =
    let
      val module = Module.MODULE (Io.get_pervasive_dir(), module_id)
      val mo_str = Module.mo_name error_info module
    in
      case OldOs.mtime mo_str of
        OldOs.EXISTS time =>
          (diagnostic (2, fn _ => ["Found `", mo_str, "'"]);
	   SOME (mo_str, time))
      | OldOs.NOT_EXIST =>
	  (diagnostic (2, fn _ => ["Failed to find ", mo_str, ""]);
	   NONE)
    end
d388 1
a388 1
  (* Given a module_id for a pervasive module, find_pervasive_sml finds the
d391 1
a391 1
  fun find_pervasive_sml module_id =
d393 1
a393 2
      val module = Module.MODULE (Io.get_pervasive_dir(), module_id)
      val sml_str = Module.sml_name module
d395 6
a400 5
      case OldOs.mtime sml_str of
        OldOs.EXISTS time =>
          (diagnostic (2, fn _ => ["Found `", sml_str, "'"]);
	   SOME (sml_str, module, time))
      | OldOs.NOT_EXIST => NONE
d533 1
a533 1
	 Module.find_sml, which uses real_path, equals the one we have. *)
d677 3
a679 1
		     (true, error_info, find_pervasive_sml module_id, unit)
d682 3
a684 1
		     (false, error_info, find_sml error_info module_id, unit)))
d687 4
a690 1
  	        load_src (true, error_info, find_pervasive_sml module_id, unit)
d693 3
a695 1
		  (false, error_info, find_sml error_info module_id, unit)
d711 3
a713 1
  	            load_object (find_pervasive_mo error_info module_id) unit
d715 3
a717 1
  	            load_object (find_mo error_info module_id) unit))
d720 3
a722 1
  	        load_object (find_pervasive_mo error_info module_id) unit
d724 3
a726 1
  	        load_object (find_mo error_info module_id) unit
d742 4
a745 2
  	            val sml_info = find_pervasive_sml module_id
  	            val mo_info = find_pervasive_mo error_info module_id
d754 4
a757 2
  	            val sml_info = find_sml error_info module_id
  	            val mo_info = find_mo error_info module_id
d857 3
a859 1
  	          load_object (find_mo error_info module_id) unit))
d861 3
a863 1
  	      load_object (find_mo error_info module_id) unit
d873 1
a873 1
		case find_mo error_info module_id
d944 3
a946 1
		  (false, error_info, find_sml error_info module_id, unit)))
d948 4
a951 1
  	    load_src (false, error_info, find_sml error_info module_id, unit)
d961 2
a962 1
  	      val sml_info = find_sml error_info module_id
d989 2
a990 2
     a call to find_mo, which is most likely to have been stored in the object
     field of a Compilation Unit. *)
@


1.36.4.1
log
@branched from 1.36
@
text
@a2 4
 * Revision 1.36  1996/11/06  11:29:07  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.3.1
log
@branched from 1.36
@
text
@a2 4
 * Revision 1.36  1996/11/06  11:29:07  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.3.1.1.1
log
@branched from 1.36.3.1
@
text
@a2 3
 * Revision 1.36.3.1  1996/12/17  17:49:32  hope
 * branched from 1.36
 *
@


1.36.2.1
log
@branched from 1.36
@
text
@a2 4
 * Revision 1.36  1996/11/06  11:29:07  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.1.1
log
@branched from 1.36
@
text
@a2 4
 * Revision 1.36  1996/11/06  11:29:07  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.36.1.1.1.1
log
@branched from 1.36.1.1
@
text
@a2 3
 * Revision 1.36.1.1  1996/11/14  12:51:45  hope
 * branched from 1.36
 *
@


1.35
log
@[Bug #1614]
updating toplevel String
@
text
@d3 4
d118 1
a118 1
require "../basis/__integer";
@


1.34
log
@[Bug #1660]
When check_source_load_times finds a unit loaded from source, but no
corresponding source file, it now assumes that the loaded module is up
to date.
@
text
@d3 6
d379 1
a379 1
	   MLWorks.Option.SOME (mo_str, time))
d382 1
a382 1
	   MLWorks.Option.NONE)
d396 2
a397 2
	   MLWorks.Option.SOME (sml_str, module, time))
      | OldOs.NOT_EXIST => MLWorks.Option.NONE
d760 1
a760 1
                 String.implode
d868 1
a868 1
                 String.implode
@


1.34.1.1
log
@branched from 1.34
@
text
@a2 6
 * Revision 1.34  1996/10/03  16:56:24  daveb
 * [Bug #1660]
 * When check_source_load_times finds a unit loaded from source, but no
 * corresponding source file, it now assumes that the loaded module is up
 * to date.
 *
@


1.33
log
@[Bug #1220]
Changed the check_validity function in check_dep to return an list of out
of date files.  Then changed check_source so that if no source file exists,
it checks the object files instead.  Intermake now loads an object file if
no source file exists; together these changes allow source files to require
object files.
@
text
@d3 8
d1158 3
a1160 2
	  (* Assume loaded module is out of date. *)
	  false)
@


1.33.2.1
log
@branched from 1.33
@
text
@a2 8
 * Revision 1.33  1996/08/14  15:52:35  daveb
 * [Bug #1220]
 * Changed the check_validity function in check_dep to return an list of out
 * of date files.  Then changed check_source so that if no source file exists,
 * it checks the object files instead.  Intermake now loads an object file if
 * no source file exists; together these changes allow source files to require
 * object files.
 *
@


1.33.1.1
log
@branched from 1.33
@
text
@a2 8
 * Revision 1.33  1996/08/14  15:52:35  daveb
 * [Bug #1220]
 * Changed the check_validity function in check_dep to return an list of out
 * of date files.  Then changed check_source so that if no source file exists,
 * it checks the object files instead.  Intermake now loads an object file if
 * no source file exists; together these changes allow source files to require
 * object files.
 *
@


1.32
log
@Improve error message when loading object files which are out of date
@
text
@d3 3
d1018 1
a1018 12
  fun always_valid _ _ _ = ()

  fun source_exists
	(error_info, location)
	(PROJECT map, module_id, UNIT unit) =
    case !(#source unit)
    of NONE =>
      Info.error'
        error_info
        (Info.FATAL, location,
         "No source file for : `" ^ ModuleId.string module_id ^ "'")
    |  _ => ()
d1022 2
a1023 1
	(PROJECT map, module_id, UNIT unit) =
d1035 4
a1038 4
	       (not o
		(check_sub_unit
	         (error_info, location, map, check_one_loaded, check_one_mo)))
	       cons of
d1041 4
a1044 3
		 error_info
           (Info.FATAL, location,
            "Object file '" ^ ModuleId.string module_id ^ "' is out of date with respect to `" ^ mod_name ^ "'"))
d1046 3
a1048 3
	    Lists.Find =>
	      (diagnostic (3, fn _ => ["object is valid"]);
	       ())
d1146 6
a1151 3
         Crash.impossible
	   ("No source file for loaded compilation unit in load_source: "
	    ^ ModuleId.string module_id)
d1233 3
a1235 1
		       dependencies
d1291 5
a1295 3
	    val _ = check_validity
		      (error_info, Location.FILE mod_name)
		      (project, module_id, UNIT unit)
d1388 1
a1388 1
  fun check_load_source (error_info, location) (project, module_id) = 
d1392 2
a1393 2
	  (error_info, 0, requires_from_unit,
	   check_source_load_times, source_exists, project)
d1399 20
a1418 1
  fun check_load_objects (error_info, location) (project, module_id) = 
d1422 2
a1423 2
	  (error_info, 0, get_sub_mos,
	   check_object_load_times, is_valid_object, project)
@


1.31
log
@Bug 1448/Support Calls 35 & 37: Added remove_file_info and modified checks
to permit missing file information.
@
text
@d3 4
d1031 13
a1043 13
    case !(#object unit)
    of NONE =>
      Info.error'
        error_info
        (Info.FATAL, location,
         "No object file for : `" ^ ModuleId.string module_id ^ "'")
    |  SOME {file_time, time_stamp, consistency = DEPEND_LIST cons, ...} =>
      (* This rather convoluted construct suggests that Lists.findp
	   should really return an option type. *)
      (case
	 Lists.findp
	   (not o
	      (check_sub_unit
d1045 4
a1048 4
	   cons
       of {mod_name, ...} =>
	 Info.error'
           error_info
d1050 5
a1054 5
            "Object file out of date: `" ^ mod_name ^ "'"))
      handle
	Lists.Find =>
	  (diagnostic (3, fn _ => ["object is valid"]);
	   ())
@


1.30
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d143 1
a143 1
  val _ = Diagnostic.set 0
d1108 6
a1113 3
           Crash.impossible
	     ("No source file for loaded compilation unit in load_object: "
	      ^ ModuleId.string module_id)
d1165 6
a1170 3
         Crash.impossible
	   ("No object file for loaded compilation unit in load_source: "
	    ^ ModuleId.string module_id)
d1459 3
a1461 1
     removed. *)
d1465 2
a1466 2
	 the loaded information, so that we don't load objects that were
	 compiled with different pervasives. *)
d1468 1
a1468 1
	val r = #loaded unit
d1472 9
a1480 9
	  (case !r
	   of SOME {file_time, load_time, basis, id_cache, module, ...} =>
	     r := SOME
		    {file_time = OBJECT object_time,
		     load_time = object_time,
		     basis = basis,
		     id_cache = id_cache,
		     module = module,
		     dependencies = DEPEND_LIST []}
d1482 4
a1485 4
	     Crash.impossible
	       ("Can't find loaded info for `"
	        ^ ModuleId.string (#name unit)
	        ^ "' in reset_pervasives"))
d1487 4
a1490 4
	  Crash.impossible
	    ("Can't find object file for `"
	     ^ ModuleId.string (#name unit)
	     ^ "' in reset_pervasives");
d1497 13
@


1.29
log
@Removing MLWorks.Integer
@
text
@d3 3
d310 1
a310 1
    output (std_out, Info.Location.to_string location ^ ": " ^ s ^ "\n")
d421 1
a421 1
     (output(std_out, "Corrupt object file '" ^ filename ^
d733 1
a733 1
                 implode
d841 1
a841 1
                 implode
@


1.28
log
@Fixed bug whereby read_dependencies didn't recurse on units which only
had an object file.
@
text
@d3 4
d84 2
d1251 1
a1251 1
   	    fn _ => [MLWorks.Integer.makestring level, " `", mod_name, "'"]);
@


1.27
log
@Renamed load_dependencies to read_dependencies.
@
text
@d3 3
d680 2
a681 7
  		    (or both) still exist. *)
  	         case (!source, !object) of
  	           (NONE, NONE) =>
		      Info.error' 
		        error_info
		        (Info.FATAL, location, "No such unit: " ^ mod_name)
  	         | _ =>
d704 14
d736 1
a736 1
		 of (proj', UNIT {requires, ...}) =>
d741 1
a741 1
		      !requires))
@


1.26
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d3 4
d202 1
a202 1
  (* The NoSuchModule exception is raised when load_dependencies fails to find
d585 1
a585 1
  (* load_dependencies takes a file name and returns a Project that comprises
d593 1
a593 1
  fun do_load_dependencies
d606 1
a606 1
      fun load_dependencies'
d616 1
a616 1
              fn _ => ["load_dependencies called with `", mod_name, "'"])
d716 1
a716 1
	       call of load_dependencies. *)
d726 1
a726 1
		     (load_dependencies'
d737 1
a737 1
	  load_dependencies'
d748 1
a748 1
     is basically the same as that in load_dependencies.
d752 1
a752 1
  fun load_object_dependencies
d759 1
a759 1
      fun load_object_dependencies'
d769 1
a769 1
              fn _ => ["load_object_dependencies called with `",
d810 1
a810 1
	       load_object_dependencies'
d824 1
a824 1
	       call of load_object_dependencies. *)
d850 1
a850 1
	(* Even though this is load_object_dependencies, we still need
d892 1
a892 1
	      load_object_dependencies'
d1220 1
a1220 1
       load_dependencies function should add a pass so that the requires
d1322 1
a1322 1
      #1 (do_load_dependencies
d1331 1
a1331 1
  fun load_dependencies info (p, m, smap) =
d1335 1
a1335 1
          fn _ => ["Calling load_dependencies on pervasive library"]);
d1338 1
a1338 1
	do_load_dependencies
d1344 2
a1345 2
        fn _ => ["Calling load_dependencies on " ^ ModuleId.string m]);
      do_load_dependencies USER info (p', m, smap')
@


1.25
log
@Modification to check_aliases to prevent multiple compilations
of files.
@
text
@d3 4
d79 1
a79 1
require "../make/os";
d96 1
a96 1
  structure Os: OS;
d333 2
a334 2
      case Os.mtime mo_str of
        Os.EXISTS time =>
d337 1
a337 1
      | Os.NOT_EXIST =>
d350 2
a351 2
      case Os.mtime sml_str of
        Os.EXISTS time =>
d354 1
a354 1
      | Os.NOT_EXIST => MLWorks.Option.NONE
d618 2
a619 2
  	      (case Os.mtime filename
  	       of Os.EXISTS mod_time =>
d626 1
a626 1
  	       |  Os.NOT_EXIST =>
d646 2
a647 2
  	      (case Os.mtime file
  	       of Os.EXISTS mod_time =>
d652 1
a652 1
  	       |  Os.NOT_EXIST =>
d772 2
a773 2
  	      (case Os.mtime file
  	       of Os.EXISTS mod_time =>
d778 1
a778 1
  	       |  Os.NOT_EXIST =>
d853 2
a854 2
  	    (case Os.mtime filename
  	     of Os.EXISTS mod_time =>
d860 1
a860 1
  	     |  Os.NOT_EXIST =>
@


1.24
log
@Added delete function.
@
text
@d3 3
d544 1
a544 1
  	      case NewMap.tryApply' (map, module_id)
@


1.23
log
@Added is_visible and set_visible functions.
@
text
@d3 3
d158 2
a159 2
	A place holder to record whether the loaded unit is visible at
	top level.  Currently unused.
d1317 3
@


1.22
log
@Module.mo_name now takes an Info.options argument.
@
text
@d3 3
d199 1
a199 1
    of SOME (unit as UNIT {name, ...}) => name
d207 1
a207 1
    of SOME (unit as UNIT {requires, ...}) => !requires
d211 17
@


1.21
log
@Changed type of loaded field to store just the basis and id_cache fields.
@
text
@d3 3
d92 1
d270 2
a271 2
  fun find_mo module_id =
    case Module.find_mo module_id
d284 1
a284 1
  fun find_sml module_id =
d286 1
a286 1
      val result = Module.find_sml module_id
d298 1
a298 1
  fun find_pervasive_mo module_id =
d301 1
a301 1
      val mo_str = Module.mo_name module
d603 2
a604 1
  	           load_src (false, error_info, find_sml module_id, unit)))
d609 2
a610 1
  	        load_src (false, error_info, find_sml module_id, unit)
d626 1
a626 1
  	            load_object (find_pervasive_mo module_id) unit
d628 1
a628 1
  	            load_object (find_mo module_id) unit))
d631 1
a631 1
  	        load_object (find_pervasive_mo module_id) unit
d633 1
a633 1
  	        load_object (find_mo module_id) unit
d655 1
a655 1
  	            val mo_info = find_pervasive_mo module_id
d664 2
a665 2
  	            val sml_info = find_sml module_id
  	            val mo_info = find_mo module_id
d751 1
a751 1
  	          load_object (find_mo module_id) unit))
d753 1
a753 1
  	      load_object (find_mo module_id) unit
d763 1
a763 1
		case find_mo module_id
d833 2
a834 1
  	        load_src (false, error_info, find_sml module_id, unit)))
d836 1
a836 1
  	    load_src (false, error_info, find_sml module_id, unit)
d846 1
a846 1
  	      val sml_info = find_sml module_id
@


1.20
log
@Fix lack of warning when pervasive files not found
and pervasive recompilation requested
@
text
@d3 4
d99 2
a100 1
  type CompilerResult = Compiler.result
d171 2
a172 1
		result: Compiler.result,
a174 2
      	       (* The Compiler.result is only accessed for the debugger info,
		  as far as I can tell.  It would be nice to get shot of it. *)
d1394 1
a1394 1
	   of SOME {file_time, load_time, result, module, ...} =>
d1398 2
a1399 1
		     result = result,
@


1.19
log
@Changed visited_pervasives to mark_compiled instead of mark_visited.
Added some more diagnostics.  Corrected an error message.
@
text
@d3 4
d399 9
a407 9
	case info_from_mo
	of SOME {consistency, mod_name, time_stamp, stamps} =>
	  (case mo_info
	   of SOME (filename, mod_time) =>
             (case unit of
                UNIT {object, ...} =>
  	        object :=
		  SOME 
                    {file_time = mod_time, 
d409 19
a427 10
	             file = filename,
	             stamps = stamps,
	             consistency = DEPEND_LIST consistency})
	   |  NONE =>
	     Crash.impossible ("new_unit has info_from_mo but no mo_info in `"
			       ^ ModuleId.string module_id ^ "'!"))
	|  NONE =>
	  (* load_object will read the info from the mo file if necessary *)
	  load_object mo_info unit

@


1.18
log
@Treat files where the filestamp info is corrupt as out of date
@
text
@d3 4
d515 7
d528 1
a528 1
  val visited_pervasives = mark_visited (empty_map, Io.pervasive_library_id)
d1016 3
a1018 1
	  false
d1041 3
a1043 1
	        false)
d1046 3
a1048 1
	     false)
d1071 3
a1073 1
	   false)
d1101 4
a1104 1
	        false)
d1106 3
a1108 1
	   false)
d1377 1
a1377 1
	   of SOME {file_time, load_time, result, module, dependencies} =>
d1383 1
a1383 1
		     dependencies = dependencies}
d1386 1
a1386 1
	       ("Can't find object file for `"
@


1.17
log
@Fixed bug with bad requires.
@
text
@d3 3
d343 21
a363 5
    let
      val {time_stamp, consistency, mod_name, stamps} =
	Encapsulate.input_info filename
      (* The mod_name is ignored here.  Does this matter? *)
    in
d365 1
a365 12
        UNIT {object, ...} =>
  	object :=
	  SOME 
            {file_time = mod_time, 
	     time_stamp = time_stamp,
	     file = filename,
	     stamps = stamps,
	     consistency = DEPEND_LIST consistency}
    end
  |   load_object NONE unit =
    case unit of
      UNIT {object, ...} => object := NONE
d446 17
a462 14
	case mo_info
	of SOME (filename, _) =>
	  let
            val info as {consistency, mod_name, time_stamp, stamps} =
	      Encapsulate.input_info filename

	    val real_mod_id =
	      ModuleId.from_mo_string (mod_name, location)
	  in
	    if real_mod_id <> module_id then
	      (SOME real_mod_id, SOME info)
	    else
	      (NONE, SOME info)
	  end
d543 1
a543 1
        let
@


1.16
log
@Fixed update of source info, to make loadSource work properly.
@
text
@d3 3
d906 11
d1259 1
a1259 1
	   check_source_load_times, always_valid, project)
@


1.15
log
@Reset diagnostic level.
@
text
@d3 3
d548 2
a549 1
		     (is_pervasive = PERVASIVE, error_info, sml_info, unit)
d780 2
a781 1
  	         load_src (false, error_info, sml_info, unit)
@


1.14
log
@Fixed information stored for loaded modules, added validity check when
loading object files, fixed various details.
@
text
@d3 4
d82 1
a82 1
  val _ = Diagnostic.set 3
@


1.13
log
@Hid implementation of the Unit type.
@
text
@d3 3
d78 1
a78 1
  val _ = Diagnostic.set 0
d85 6
a90 3
  (* This is the consistency information stored in each .mo file. *)
  datatype Consistency =
    CONSISTENCY of
d93 38
a130 1
  (* This is how the project manager represents a compilation unit. *)
a133 2
     (* In the presence of symbolic links, several module_ids may map to the
	same unit.  The module_id stored in the unit is the "real" module_id. *)
d136 17
a152 11
     loaded:   (MLWorks.Time.time * Compiler.result
		* MLWorks.Internal.Value.T * Consistency) option ref,
      (* The Compiler.result is only accessed for the debugger info, as
	 far as I can tell.  It would be nice to get shot of it. *)
     visible:  bool ref,  (* Should it be visible at top level when loaded? *)
     options:  Options.options option ref,
  	         (* What options should it be compiled with? *)
     object:   (string * MLWorks.Time.time * int * Consistency) option ref
     (* The int is the stamps field returned by Encapsulate.input_info *)
     (* objects should store their compiler options too *)
    } ;
d227 5
a231 4
      (fn (m, UNIT u) => if pred m then
	 #loaded u := NONE
       else
	 ())
d239 2
d251 4
d331 3
a333 1
      val {consistency, stamps} = Encapsulate.input_info filename
d337 7
a343 1
  	object := (SOME (filename, mod_time, stamps, CONSISTENCY consistency))
d364 3
d374 1
a374 1
	of SOME {consistency, stamps} =>
d380 6
a385 1
		  (SOME (filename, mod_time, stamps, CONSISTENCY consistency)))
d431 3
a433 1
            val info as {consistency, stamps} = Encapsulate.input_info filename
d435 1
a435 7
	      case consistency of
		{mod_name, ...} :: _ =>
		  ModuleId.from_mo_string (mod_name, location)
	      | _ =>
		Crash.impossible
		  ("no consistency info for `"
		   ^ ModuleId.string module_id ^ "'")
d494 1
d496 1
d506 1
a506 1
  fun load_dependencies
d551 4
a554 2
  	      (* Assume that the object file exists *)
  	      ()
d558 1
a558 1
  	    of SOME (filename, time_stamp, _, consistency) =>
d560 1
a560 1
  	      (case Os.mtime filename
d565 1
a565 1
  	           load_object (SOME (filename, mod_time)) unit
d568 1
a568 1
		           "Object file " ^ filename ^ " has disappeared");
d574 4
a577 2
  	      (* Assume that the source file exists *)
  	      ()
d593 1
a593 1
  	         | _ => ();
d615 1
d684 1
a684 1
  	    of SOME (filename, time_stamp, _, consistency) =>
d686 1
a686 1
  	      (case Os.mtime filename
d691 1
a691 1
  	           load_object (SOME (filename, mod_time)) unit
d694 1
a694 1
			   "Object file " ^ filename ^ " has disappeared");
d744 3
a746 1
			    ref (SOME (_, _, _, CONSISTENCY (_ :: _ :: const))),
d819 7
a825 2
    of SOME (_, file_time, _, _) =>
      time = file_time
d831 4
a834 4
  fun check_one_loaded (location, time, UNIT unit, sub_module_name) =
    if sub_module_name = Io.pervasive_library_name then
      true
    else
d836 3
a838 3
    of SOME (load_time, _, _, _) =>
      if time = load_time then
	(diagnostic (2, fn _ => ["load_time OK for `", sub_module_name, "'"]);
d842 1
a842 1
   	   fn _ => ["old load_time for `", sub_module_name, "'"]);
d850 1
a850 2
     stored in a project.  It requires the project to hold up-to-date info
     about all the mo files. *)
d852 2
a853 2
	(error_info, location, proj_info, check_one)
	{mod_name, time, req_name} =
d863 5
a867 1
	check_one (location, time, unit, mod_name)
d874 2
a875 2
  
  (* check_consistency checks a consistency list against a time stamp and
d877 2
a878 4
     consistent.  It requires the project to hold up-to-date info about all
     the mo files. *)
  fun check_consistency
	is_pervasive
d880 4
a883 27
        (PROJECT map, s_time, module_id, CONSISTENCY const, check_one) =
    case (is_pervasive, const)
    of (_, []) =>
      Crash.impossible
        ("missing consistency info in " ^ ModuleId.string module_id)
    |  (PERVASIVE, {time=source_stamp, ...} :: dependencies) =>
      source_stamp = s_time
      andalso
        Lists.forall
	  (check_sub_unit (error_info, location, map, check_one))
	  dependencies
    |  (USER, [_]) =>
      Crash.impossible "No entry for pervasive library in consistency info"
    |  (USER,
	{time=source_stamp, ...} :: perv_info :: dependencies) =>
      if source_stamp = s_time then
	(diagnostic (2,
   	   fn _ => ["`", ModuleId.string module_id, "': source stamp OK"]);
	 check_sub_unit
	    (error_info, location, map, check_one)
	    perv_info
	 andalso
           Lists.forall
	     (check_sub_unit (error_info, location, map, check_one))
	     dependencies)
      else
	false
d888 52
a939 16
    fun check_file_times
	  is_pervasive
	  (error_info, location)
	  (project, module_id, UNIT unit) =
      case !(#source unit)
      of NONE =>
        (* If no source file exists, we assume that the object file
	   is up to date. *)
        (diagnostic (2, fn _ => [" no source unit"]);
	 true)
      |  SOME (s_file, s_module, s_time) =>
        case !(#object unit)
        of SOME (_, _, _, consistency) =>
          (diagnostic (3, fn _ => [" checking consistency"]);
	   check_consistency
	     is_pervasive
d941 6
a946 4
	     (project, s_time, module_id, consistency, check_one_mo))
        |  NONE =>
	  (diagnostic (2, fn _ => [" no object file"]);
  	   false)
d948 20
a967 13
    fun check_loaded_times
	  is_pervasive
	  (error_info, location)
	  (project, module_id, UNIT unit) =
      case !(#source unit)
      of NONE =>
        Crash.impossible "No source file for loaded compilation unit"
      |  SOME (s_file, s_module, s_time) =>
        case !(#loaded unit)
        of SOME (_, _, _, consistency) =>
          (diagnostic (3, fn _ => [" checking consistency"]);
	   check_consistency
	     is_pervasive
d969 32
a1000 4
	     (project, s_time, module_id, consistency, check_one_loaded))
        |  NONE =>
	  (diagnostic (2, fn _ => [" not loaded"]);
  	   false)
d1002 52
d1063 1
a1063 1
    |  SOME (_, _, _, CONSISTENCY (_ :: _ :: l)) =>
a1067 2
    |  SOME _ =>
      Crash.impossible "bad consistency info in get_sub_mos"
d1072 5
a1076 5
    | check_visited_map(x :: xs, visited) =
	case NewMap.tryApply'(visited, x) of
	  NONE => check_visited_map(xs, visited)
	| SOME true => check_visited_map(xs, visited)
	| SOME false => false
d1081 5
a1085 1
       check_times: a function to check the time stamps of the current unit
d1099 2
a1100 2
	is_pervasive
        (error_info, level, get_sub_units, check_times, project as PROJECT proj)
d1124 1
a1124 1
	        ("Undefined module: " ^ ModuleId.string module_id)
d1139 4
d1149 2
a1150 2
	           is_pervasive
	           (error_info, level + 1, get_sub_units, check_times, project))
a1163 1
		      is_pervasive
a1191 4
     Load project (unimplemented): given a file name, load project info from
        that file.  Then check it - check existence and modification times
        of all files, and reload dependency info from any source file that
        has changed.
d1206 1
a1206 1
      #1 (load_dependencies
d1212 16
a1227 1
  val load_dependencies = load_dependencies USER
d1235 3
a1237 3
	  USER
	  (error_info, 0, requires_from_unit, check_loaded_times, project)
	  (([], NewMap.empty' ModuleId.lt, []), module_id)
d1242 1
a1242 1
  fun check_loaded (error_info, location) (project, module_id) = 
d1246 3
a1248 3
	  USER
	  (error_info, 0, get_sub_mos, check_loaded_times, project)
	  (([], NewMap.empty' ModuleId.lt, []), module_id)
d1253 1
a1253 1
  fun check_objects (error_info, location) (project, module_id) = 
d1257 3
a1259 3
	  USER
	  (error_info, 0, requires_from_unit, check_file_times, project)
	  (([], NewMap.empty' ModuleId.lt, []), module_id)
d1264 1
a1264 1
  (* The check_objects' command takes a module_id and calls check_dep
d1266 1
a1266 1
     date.  It differs from check_dependencies in that it takes explicit
d1268 1
a1268 1
  fun check_objects'
d1273 2
a1274 2
	  USER
	  (error_info, 0, requires_from_unit, check_file_times, project)
d1282 1
a1282 1
  fun check_perv_objects (error_info, location) project = 
d1286 3
a1288 3
	  PERVASIVE
	  (error_info, 0, requires_from_unit, check_file_times, project)
	  (([], NewMap.empty' ModuleId.lt, []), Io.pervasive_library_id)
d1297 3
a1299 3
	  PERVASIVE
	  (error_info, 0, requires_from_unit, check_loaded_times, project)
	  (([], NewMap.empty' ModuleId.lt, []), Io.pervasive_library_id)
d1304 43
@


1.12
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d3 3
d126 8
d178 1
a178 1
  fun for_all (PROJECT pmap, pred, action) =
d180 4
a183 1
      (fn (m, u) => if pred m then action u else ())
d875 1
a875 1
  fun get_requires (UNIT unit) = !(#requires unit)
d1037 1
a1037 1
	  (error_info, 0, get_requires, check_loaded_times, project)
d1059 1
a1059 1
	  (error_info, 0, get_requires, check_file_times, project)
d1075 1
a1075 1
	  (error_info, 0, get_requires, check_file_times, project)
d1088 1
a1088 1
	  (error_info, 0, get_requires, check_file_times, project)
d1099 1
a1099 1
	  (error_info, 0, get_requires, check_loaded_times, project)
@


1.11
log
@Revised some error message to say 'object files' instead of 'mo files'.
@
text
@d3 3
d28 1
a28 1
require "../utils/newmap.sml";
d45 1
a45 1
  structure NewMap: NEWMAP;
d65 1
a65 1
  type ('a, 'b) Map = ('a, 'b) NewMap.T
d104 1
a104 1
  datatype Project = PROJECT of (ModuleId.ModuleId, Unit) NewMap.T
@


1.10
log
@Ensured that check_visited_map always uses the real module_ids, allowing for
symbolic links.  Passed a list of resolved module_ids as an argument to
check_dep; this builds up a list of the module_ids for the requires in a
given unit.
@
text
@d3 6
d372 1
a372 1
	       ^ ") differs from that in mo file (" ^ ModuleId.string m2
d626 1
a626 1
		     "No .mo file.")
d731 1
a731 1
		"can't find object info for " ^ sub_module_name);
d771 1
a771 1
		    "' from mo file not found in project\n",
@


1.9
log
@Tidy up missing object info message
@
text
@d522 1
a522 1
	    if Lists.member(mod_name, ancestors) then
d630 1
a630 1
	    if Lists.member(mod_name, ancestors) then
d725 1
a725 1
		": can't find object info for " ^ sub_module_name);
d884 2
d887 1
a887 1
     Returns an updated (out_of_date, visited) pair.
d893 1
a893 1
        ((out_of_date, visited), module_id) =
a925 3
        val _ =
	  diagnostic (2,
   	    fn _ => [MLWorks.Integer.makestring level, " real name `", ModuleId.string real_mod_id, "'"]);
d928 1
a928 1
	  (out_of_date, visited)
d934 1
a934 1
            val (out_of_date_now, visited_now) =
d939 1
a939 2
    	        ((out_of_date, visited),
    	         sub_units)
d950 1
a950 1
	    if check_visited_map (sub_units, visited_now)
d958 2
a959 1
	       mark_compiled (visited_now, real_mod_id))
d962 2
a963 4
	       mark_visited(mark_visited(visited_now, real_mod_id), module_id))
	       (* I think we need to mark the non-canonical module_id *)
	       (* as visited but out of date, since other requires may *)
	       (* refer to it *)
d1011 1
a1011 1
      val (out_of_date, _) =
d1015 1
a1015 1
	  (([], NewMap.empty' ModuleId.lt), module_id)
d1022 1
a1022 1
      val (out_of_date, _) =
d1026 1
a1026 1
	  (([], NewMap.empty' ModuleId.lt), module_id)
d1033 1
a1033 1
      val (out_of_date, _) =
d1037 1
a1037 1
	  (([], NewMap.empty' ModuleId.lt), module_id)
d1049 1
a1049 1
      val (out_of_date_now, visited_now) =
d1053 1
a1053 1
	  ((rev out_of_date, visited), module_id)
d1062 1
a1062 1
      val (out_of_date, _) =
d1066 1
a1066 1
	  (([], NewMap.empty' ModuleId.lt), Io.pervasive_library_id)
d1073 1
a1073 1
      val (out_of_date, _) =
d1077 1
a1077 1
	  (([], NewMap.empty' ModuleId.lt), Io.pervasive_library_id)
@


1.8
log
@Fixing bug whereby make doesn't always recompile all it should
@
text
@d3 3
d725 1
a725 1
		"can't find object info for " ^ sub_module_name);
@


1.7
log
@Fixing bugs with load_object_dependencies
@
text
@d3 3
d921 3
d960 4
a963 1
	       mark_visited (visited_now, real_mod_id))
@


1.6
log
@Replaced use of error_fn with Info.error.  Replaced an occurrence of
mesg_fn with a diagnostic.  Improved format of mesg_fn output.
@
text
@d2 5
a6 1
 * $Log$
d567 1
a567 1
      fun load_dependencies'
d605 2
a606 3
  	        let
  	          val mo_info = find_mo module_id
  	        in
d610 6
a615 1
  	        end
d618 1
a618 1
	       load_dependencies'
d632 1
a632 1
	       call of load_dependencies. *)
d676 2
a677 1
	val (proj, unit) =
d686 3
a688 3
	      new_unit
	        error_info
		(false, proj, module_id, sml_info, NONE, NONE)
d692 10
a701 1
	  load_dependencies' (location, []) (module_id, (proj, seen_init))
d706 2
a707 1
  (* The following functions check that the info in a project is consistent. *)
@


1.5
log
@Added header.
@
text
@a152 1
  (* error_fn prints warnings to std_out.  This needs more thought. *)
d154 1
a154 3
    output (std_out, Info.Location.to_string location ^ s ^ "\n")
  exception Error
  fun error_fn s = (output (std_out, s ^ "\n"); raise Error)
d352 6
a357 6
	    error_fn ("Module name derived for source ("
		      ^ ModuleId.string m1 
		      ^ ") differs from that in mo file ("
		      ^ ModuleId.string m2
		      ^ ")\n"
		      ^ "Check your source path setting.")
a733 3
      (*
      (mesg_fn (location, "checking `" ^ mod_name ^ "'");
      *)
d738 4
a741 4
        (mesg_fn
           (location,
	    "Module name `" ^ mod_name ^ "' from mo file not found in project\n"
	    ^ "-- treating as out of date");
@


1.4
log
@Added for_all function.
@
text
@d1 6
@


1.3
log
@Removed dependency on initbasis/lists, which was confusing NJ.
@
text
@d142 5
@


1.2
log
@Removed Module.Cache type.
@
text
@a6 1
require "../initbasis/lists";
a28 1
  structure List: LIST;
d412 1
a412 1
	    (module_id, (proj, seen)) =
d521 1
a521 1
  	           List.foldl
d524 2
a525 2
		     (proj', mark_visited (seen, module_id))
		     (!requires))
d535 1
a535 1
	    (module_id, (proj, seen_init))
d601 1
a601 1
	    fun recurse ({mod_name = sub_name, req_name, time}, (proj, seen)) =
d628 1
a628 1
  	             List.foldl recurse (proj', seen) const
d754 1
a754 1
        List.all
d768 1
a768 1
           List.all
d861 1
a861 1
        (module_id, (out_of_date, visited)) =
d903 1
a903 1
              List.foldl
d907 2
a908 2
    	        (out_of_date, visited)
    	        (sub_units)
d982 1
a982 1
	  (module_id, ([], NewMap.empty' ModuleId.lt))
d993 1
a993 1
	  (module_id, ([], NewMap.empty' ModuleId.lt))
d1004 1
a1004 1
	  (module_id, ([], NewMap.empty' ModuleId.lt))
d1020 1
a1020 1
	  (module_id, (rev out_of_date, visited))
d1033 1
a1033 1
	  (Io.pervasive_library_id, ([], NewMap.empty' ModuleId.lt))
d1044 1
a1044 1
	  (Io.pervasive_library_id, ([], NewMap.empty' ModuleId.lt))
@


1.1
log
@new unit
A project stores information about all the files used in a program.
@
text
@d153 2
a154 2
    case Module.find_mo (module_id, Module.empty_cache)
    of (SOME (file, _, time), _) =>
d164 1
a164 1
      val result = #1 (Module.find_sml (module_id, Module.empty_cache))
d704 1
a704 2
	(diagnostic (2, fn _ =>
   	   ["load_time OK for `", sub_module_name, "'"]);
d712 1
a712 1
		"can't find loaded info for `" ^ sub_module_name ^"'");
@
