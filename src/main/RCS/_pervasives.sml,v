head	1.60;
access;
symbols
	MLW_daveb_inline_1_4_99:1.60.3
	MLWorks_21c0_1999_03_25:1.60
	MLWorks_20c1_1998_08_20:1.60
	MLWorks_20c0_1998_08_04:1.60
	MLWorks_20b2c2_1998_06_19:1.60
	MLWorks_20b2_Windows_1998_06_12:1.60
	MLWorks_20b1c1_1998_05_07:1.60
	MLWorks_20b0_1998_04_07:1.60
	MLWorks_20b0_1998_03_20:1.60
	MLWorks_20m2_1998_02_16:1.60
	MLWorks_20m1_1997_10_23:1.60
	MLWorks_11r1:1.59.1.1.1.1.1
	MLWorks_workspace_97:1.60.2
	MLWorks_dt_wizard:1.60.1
	MLWorks_11c0_1997_09_09:1.59.1.1.1.1
	MLWorks_10r3:1.59.1.1.3
	MLWorks_10r2_551:1.59.1.1.2
	MLWorks_11:1.59.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.59.1.1
	MLWorks_20m0_1997_06_20:1.60
	MLWorks_1_0_r2c2_1997_06_14:1.59.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.59.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.59.1
	MLWorks_BugFix_1997_04_24:1.59
	MLWorks_1_0_r2_Win32_1997_04_11:1.59
	MLWorks_1_0_r2_Unix_1997_04_04:1.59
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.58.3.1.1
	MLWorks_gui_1996_12_18:1.58.4
	MLWorks_1_0_Win32_1996_12_17:1.58.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.58.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.58.1.1
	MLWorks_1_0_Irix_1996_11_28:1.58.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.58.2
	MLWorks_1_0_Unix_1996_11_14:1.58.1
	MLWorks_Open_Beta2_1996_10_11:1.56.3
	MLWorks_License_dev:1.56.2
	MLWorks_1_open_beta_1996_09_13:1.56.1
	MLWorks_Open_Beta_1996_08_22:1.56
	MLWorks_Beta_1996_07_02:1.56
	MLWorks_Beta_1996_06_07:1.56
	MLWorks_Beta_1996_06_06:1.56
	MLWorks_Beta_1996_06_05:1.56
	MLWorks_Beta_1996_06_03:1.56
	MLWorks_Beta_1996_05_31:1.56
	MLWorks_Beta_1996_05_30:1.56
	mlworks-28-01-1994:1.42
	Release:1.42
	mlworks-beta-01-09-1993:1.42
	MLWorks-1-0-4-29/01/1993:1.37
	MLWorks-1-0-3-21/12/1992:1.37
	MLWorks-1-0-2-15/12/1992:1.37
	MLWorks-1-0-1-04/12/1992:1.37
	checkpoint_17_08_92:1.31;
locks; strict;
comment	@ * @;


1.60
date	97.05.19.11.14.56;	author jont;	state Exp;
branches
	1.60.1.1
	1.60.2.1
	1.60.3.1;
next	1.59;

1.59
date	96.12.17.12.35.56;	author andreww;	state Exp;
branches
	1.59.1.1;
next	1.58;

1.58
date	96.11.06.11.28.55;	author matthew;	state Exp;
branches
	1.58.1.1
	1.58.2.1
	1.58.3.1
	1.58.4.1;
next	1.57;

1.57
date	96.10.29.16.43.25;	author io;	state Exp;
branches;
next	1.56;

1.56
date	96.04.30.17.38.26;	author jont;	state Exp;
branches
	1.56.1.1
	1.56.2.1
	1.56.3.1;
next	1.55;

1.55
date	96.04.29.13.43.13;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	96.04.19.10.50.30;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	96.02.23.16.16.37;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	95.09.12.12.23.13;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.07.28.16.03.00;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	95.07.20.15.24.53;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	95.07.14.09.36.10;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	95.05.26.14.27.13;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	95.04.28.11.42.19;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	95.02.10.15.57.57;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.11.18.11.21.45;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	94.10.06.10.15.47;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.09.09.17.34.25;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.07.20.12.33.35;	author jont;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	93.07.07.16.30.02;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	93.05.18.17.00.55;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.03.23.12.57.48;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	93.03.05.11.49.32;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.10.02.16.24.25;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.09.24.12.11.37;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.08.21.14.44.43;	author richard;	state Exp;
branches;
next	1.34;

1.34
date	92.08.20.12.44.24;	author richard;	state Exp;
branches;
next	1.33;

1.33
date	92.08.19.12.14.23;	author richard;	state Exp;
branches;
next	1.32;

1.32
date	92.08.17.13.34.43;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.08.07.16.16.02;	author davidt;	state Exp;
branches;
next	1.30;

1.30
date	92.06.19.15.48.58;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.06.18.16.44.53;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.06.15.17.38.15;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.06.15.11.18.48;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.06.12.19.23.24;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.05.21.19.14.56;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.05.20.10.29.13;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.05.18.14.25.24;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.05.13.10.49.11;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.03.21.14.02.02;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.03.03.11.46.49;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.03.02.17.21.24;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.02.19.16.59.12;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.02.12.12.02.58;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.01.31.11.33.07;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.01.23.11.02.49;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.01.23.09.28.47;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.01.16.09.33.45;	author clive;	state Exp;
branches;
next	1.12;

1.12
date	92.01.10.11.47.58;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	91.12.20.11.49.28;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	91.12.18.15.11.37;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	91.12.10.13.57.58;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	91.11.28.17.07.08;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	91.11.18.15.25.03;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	91.11.15.14.13.23;	author richard;	state Exp;
branches;
next	1.5;

1.5
date	91.11.14.16.51.53;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.14.14.06.54;	author richard;	state Exp;
branches;
next	1.3;

1.3
date	91.10.14.16.15.39;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.09.16.16.57.54;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.08.23.10.57.13;	author jont;	state Exp;
branches;
next	;

1.42.1.1
date	93.07.20.12.33.35;	author jont;	state Exp;
branches;
next	;

1.56.1.1
date	96.09.13.11.18.05;	author hope;	state Exp;
branches;
next	;

1.56.2.1
date	96.10.07.16.07.56;	author hope;	state Exp;
branches;
next	;

1.56.3.1
date	96.10.17.11.26.11;	author hope;	state Exp;
branches;
next	;

1.58.1.1
date	96.11.14.12.51.26;	author hope;	state Exp;
branches
	1.58.1.1.1.1;
next	;

1.58.1.1.1.1
date	96.11.28.15.02.30;	author hope;	state Exp;
branches;
next	;

1.58.2.1
date	96.11.22.18.10.40;	author hope;	state Exp;
branches;
next	;

1.58.3.1
date	96.12.17.17.49.15;	author hope;	state Exp;
branches
	1.58.3.1.1.1;
next	;

1.58.3.1.1.1
date	97.02.24.11.39.21;	author hope;	state Exp;
branches;
next	;

1.58.4.1
date	96.12.18.09.43.19;	author hope;	state Exp;
branches;
next	;

1.59.1.1
date	97.05.12.10.35.48;	author hope;	state Exp;
branches
	1.59.1.1.1.1
	1.59.1.1.2.1
	1.59.1.1.3.1;
next	;

1.59.1.1.1.1
date	97.07.28.18.21.30;	author daveb;	state Exp;
branches
	1.59.1.1.1.1.1.1;
next	;

1.59.1.1.1.1.1.1
date	97.10.07.11.47.06;	author jkbrook;	state Exp;
branches;
next	;

1.59.1.1.2.1
date	97.09.08.17.14.54;	author daveb;	state Exp;
branches;
next	;

1.59.1.1.3.1
date	97.09.09.14.10.47;	author daveb;	state Exp;
branches;
next	;

1.60.1.1
date	97.09.10.19.26.48;	author brucem;	state Exp;
branches;
next	;

1.60.2.1
date	97.09.11.20.56.47;	author daveb;	state Exp;
branches;
next	;

1.60.3.1
date	99.04.01.17.58.08;	author daveb;	state Exp;
branches;
next	;


desc
@Datatype for pervasives
@


1.60
log
@[Bug #30090]
Translate output std_out to print
@
text
@(* _pervasives.sml the functor *)
(*
$Log: _pervasives.sml,v $
 * Revision 1.59  1996/12/17  12:35:56  andreww
 * [Bug #1818]
 * adding builtins for floatarrays.
 *
 * Revision 1.58  1996/11/06  11:28:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.57  1996/10/29  16:43:25  io
 * moving String from toplevel
 *
 * Revision 1.56  1996/04/30  17:38:26  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.55  1996/04/29  13:43:13  matthew
 * Integer changes
 *
 * Revision 1.54  1996/04/19  10:50:30  matthew
 * Removing old pervasives
 *
 * Revision 1.53  1996/02/23  16:16:37  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.52  1995/09/12  12:23:13  daveb
 * Added pervasives for Word32, Int32, etc.
 *
Revision 1.51  1995/07/28  16:03:00  jont
Change mod to be int_mod

Revision 1.50  1995/07/20  15:24:53  jont
Add primitive operations on words

Revision 1.49  1995/07/14  09:36:10  jont
Adding new operations on chars

Revision 1.48  1995/05/26  14:27:13  matthew
Commenting out diagnostics

Revision 1.47  1995/04/28  11:42:19  matthew
Adding CAST and UMAP pervasives

Revision 1.46  1995/02/10  15:57:57  matthew
Adding breakpoint and step builtins

Revision 1.45  1994/11/18  11:21:45  matthew
Adding "unsafe" allocation and update functions

Revision 1.44  1994/10/06  10:15:47  matthew
Added eq function

Revision 1.43  1994/09/09  17:34:25  jont
new file

Revision 1.2  1994/02/11  15:57:55  nickh
y
Fix handling of trapping operations.

Revision 1.1  1994/01/17  16:58:32  daveb
Initial revision

Revision 1.42  1993/07/20  12:33:35  jont
Added unsafeintplus for generating large integers

Revision 1.41  1993/07/07  16:30:02  daveb
Removed EX*VAL values, since we no longer have exception environments.

Revision 1.40  1993/05/18  17:00:55  jont
Removed integer parameter

Revision 1.39  1993/03/23  12:57:48  jont
Added vector primitives

Revision 1.38  1993/03/05  11:49:32  jont
Added builtin string relationals

Revision 1.37  1992/10/02  16:24:25  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.36  1992/09/24  12:11:37  jont
Removed some redundant items from the signature

Revision 1.35  1992/08/21  14:44:43  richard
Added bytearray and unsafe update primitives.
NOTE: Bytearray stuff should raise Range exception.

Revision 1.34  1992/08/20  12:44:24  richard
Changed reference to rts/__builtin_library to pervasive directory.

Revision 1.33  1992/08/19  12:14:23  richard
Added UNSAFE_UPDATE and UNSAFE_SUB.

Revision 1.32  1992/08/17  13:34:43  jont
Added inline ordof

Revision 1.31  1992/08/07  16:16:02  davidt
String structure is now pervasive.

Revision 1.30  1992/06/19  15:48:58  jont
Added ML_REQUIRE builtin for interpreter to get builtin library

Revision 1.29  1992/06/18  16:44:53  jont
Added new builtin ML_OFFSET for computing pointers into middles of
letrec code vectors

Revision 1.28  1992/06/15  17:38:15  jont
Added various loading functions for interpreter, and tidied up

Revision 1.27  1992/06/15  11:18:48  clive
Added extra pervasive in is_fun

Revision 1.26  1992/06/12  19:23:24  jont
Added ident function to alloow type casting required by interpreter

Revision 1.25  1992/05/21  19:14:56  jont
Changed arithmetic_rshift to arshift to agree with builtin library

Revision 1.24  1992/05/20  10:29:13  clive
Added arithmetic right shift operator

Revision 1.23  1992/05/18  14:25:24  clive
Tried to neaten

Revision 1.22  1992/05/13  10:49:11  clive
Added the Bits structure

Revision 1.21  1992/03/21  14:02:02  jont
Changed makestring for Integer.makestring

Revision 1.20  1992/03/03  11:46:49  richard
Improved the method of encoding and decoding pervasives to integers.
Updated documentation which was not corrected by other programmers.

Revision 1.19  1992/03/02  17:21:24  richard
Added EQFUN pervasive and made EQ refer to it.

Revision 1.18  1992/02/19  16:59:12  clive
Incorrectly used exsize instead of exsizeval in implicit_references

Revision 1.17  1992/02/12  12:02:58  clive
New pervasive library code

Revision 1.16  1992/01/31  11:33:07  clive
Array problems - the structure was missing

Revision 1.15  1992/01/23  11:02:49  jont
Fixed inexhaustive/redundant match problem

Revision 1.14  1992/01/23  09:28:47  clive
Added the EXSUBSCRIPTVAL and EXSIZEVAL

Revision 1.13  1992/01/16  09:33:45  clive
Added arrays to the initial basis

Revision 1.12  1992/01/10  11:47:58  richard
Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.

Revision 1.11  1991/12/20  11:49:28  richard
Changed the implicit references to exception values rather than
exception names.  See corresponding change in _mir_cg.

Revision 1.10  91/12/18  15:11:37  richard
 Separated exception values from exception names.

Revision 1.9  91/12/10  13:57:58  richard
Added the EQ (equal) and NE (not equal) pervasives to the
pervasive library.

Revision 1.8  91/11/28  17:07:08  richard
Reworked those parts of the module concerned with the pervasive library.
This module can now provide the field numbers within the library of the
pervasives directly.  Also implemented an ordering on pervasives and
removed the MAKE_NEW_UNIQUE pervasive.

Revision 1.7  91/11/18  15:25:03  richard
Changed the library name of mod to modulo so that it doesn't
clash with the pervasive name when compiling.  This makes it
easier to define.

Revision 1.6  91/11/15  14:13:23  richard
Added library_name to map pervasives on to their names in the library
module.

Revision 1.5  91/11/14  16:51:53  jont
Added is_fun to determine if pervasives are functions, and hence can
be eta_abstracted during compilation.

Revision 1.4  91/11/14  14:06:54  richard
Added CALL_C and SYSTEM pervasives.

Revision 1.3  91/10/14  16:15:39  jont
Added CALL_C

Revision 1.2  91/09/16  16:57:54  davida
Corrected spelling of UNIQUE (!)

Revision 1.2  91/09/16  16:34:50  davida
Corrected spelling of UNIQUE (!)

Revision 1.1  91/08/23  10:57:13  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__int";
require "../utils/crash";
require "../utils/lists";
require "../utils/map";
require "../utils/diagnostic";
require "../basics/ident";
require "../main/pervasives";

functor Pervasives (
  structure Lists      : LISTS
  structure Map	       : MAP
  structure Ident      : IDENT
  structure Diagnostic : DIAGNOSTIC
  structure Crash      : CRASH
    ) : PERVASIVES =
struct
  structure Symbol = Ident.Symbol
  structure Diagnostic = Diagnostic

  datatype pervasive =
    REF |
    EXORD |
    EXCHR |
    EXDIV |
    EXSQRT |
    EXEXP |
    EXLN |
    EXIO |
    EXMATCH |
    EXBIND |
    EXINTERRUPT |
    EXOVERFLOW |
    EXRANGE |
    MAP |
    UMAP |
    REV |
    NOT |
    ABS |
    FLOOR |
    REAL |
    SQRT |
    SIN |
    COS |
    ARCTAN |
    EXP |
    LN |
    SIZE |
    CHR |
    ORD |
    CHARCHR |
    CHARORD |
    ORDOF |
    EXPLODE |
    IMPLODE |
    DEREF |
    FDIV |
    DIV |
    MOD |
    PLUS |
    STAR |
    MINUS |
    HAT |
    AT |
    NE |
    LESS |
    GREATER |
    LESSEQ |
    GREATEREQ |
    BECOMES |
    O |
    UMINUS |
    EQ |
    EQFUN |
    LOAD_STRING |
    REALPLUS |
    INTPLUS |
    UNSAFEINTPLUS |
    UNSAFEINTMINUS |
    REALSTAR |
    INTSTAR |
    REALMINUS |
    INTMINUS |
    REALUMINUS |
    INTUMINUS |
    INTMOD |
    INTDIV |
    INTLESS |
    REALLESS |
    INTGREATER |
    REALGREATER |
    INTLESSEQ |
    REALLESSEQ |
    INTGREATEREQ |
    REALGREATEREQ |
    INTEQ |
    INTNE |
    REALEQ |
    REALNE |
    STRINGEQ |
    STRINGNE |
    STRINGLT |
    STRINGLE |
    STRINGGT |
    STRINGGE |
    CHAREQ |
    CHARNE |
    CHARLT |
    CHARLE |
    CHARGT |
    CHARGE |
    INTABS |
    REALABS |
    CALL_C |
    ARRAY_FN |
    LENGTH |
    SUB |
    UNSAFE_SUB |
    UPDATE |
    UNSAFE_UPDATE |
    BYTEARRAY |
    BYTEARRAY_LENGTH |
    BYTEARRAY_SUB |
    BYTEARRAY_UNSAFE_SUB |
    BYTEARRAY_UPDATE |
    BYTEARRAY_UNSAFE_UPDATE |
    FLOATARRAY |
    FLOATARRAY_LENGTH |
    FLOATARRAY_SUB |
    FLOATARRAY_UNSAFE_SUB |
    FLOATARRAY_UPDATE |
    FLOATARRAY_UNSAFE_UPDATE |
    VECTOR |
    VECTOR_LENGTH |
    VECTOR_SUB |
    EXSIZE |
    EXSUBSCRIPT |
    ANDB |
    LSHIFT |
    NOTB |
    ORB |
    RSHIFT |
    ARSHIFT |
    XORB |
    (* Stuff for words *)
    WORDEQ |
    WORDNE |
    WORDLT |
    WORDLE |
    WORDGT |
    WORDGE |
    WORDPLUS |
    WORDMINUS |
    WORDSTAR |
    WORDDIV |
    WORDMOD |
    WORDORB |
    WORDXORB |
    WORDANDB |
    WORDNOTB |
    WORDLSHIFT |
    WORDRSHIFT |
    WORDARSHIFT |
    INT32PLUS |
    INT32STAR |
    INT32MINUS |
    INT32UMINUS |
    INT32ABS |
    INT32MOD |
    INT32DIV |
    INT32LESS |
    INT32GREATER |
    INT32LESSEQ |
    INT32GREATEREQ |
    INT32EQ |
    INT32NE |
    WORD32EQ |
    WORD32NE |
    WORD32LT |
    WORD32LE |
    WORD32GT |
    WORD32GE |
    WORD32PLUS |
    WORD32MINUS |
    WORD32STAR |
    WORD32DIV |
    WORD32MOD |
    WORD32ORB |
    WORD32XORB |
    WORD32ANDB |
    WORD32NOTB |
    WORD32LSHIFT |
    WORD32RSHIFT |
    WORD32ARSHIFT |
    (* Low level stuff *)
    CAST |
    ALLOC_STRING |
    ALLOC_VECTOR |
    ALLOC_PAIR |
    RECORD_UNSAFE_SUB |
    RECORD_UNSAFE_UPDATE |
    STRING_UNSAFE_SUB |
    STRING_UNSAFE_UPDATE |
    (* Associated with the interpreter only *)
    IDENT_FN |
    ML_OFFSET |
    ENTUPLE |
    ML_CALL |
    ML_REQUIRE |
    LOAD_VAR |
    LOAD_EXN |
    LOAD_STRUCT |
    LOAD_FUNCT |
    GET_IMPLICIT

  fun print_pervasive REF = "ref"
    | print_pervasive EXORD = "<name of Ord>"
    | print_pervasive EXCHR = "<name of Chr>"
    | print_pervasive EXDIV = "<name of Div>"
    | print_pervasive EXSQRT = "<name of Sqrt>"
    | print_pervasive EXEXP = "<name of Exp>"
    | print_pervasive EXLN = "<name of Ln>"
    | print_pervasive EXIO = "<name of Io>"
    | print_pervasive EXMATCH = "<name of Match>"
    | print_pervasive EXBIND = "<name of Bind>"
    | print_pervasive EXINTERRUPT = "<name of Interrupt>"
    | print_pervasive EXOVERFLOW = "<name of Overflow>"
    | print_pervasive EXRANGE = "<name of Range>"
    | print_pervasive MAP = "map"
    | print_pervasive UMAP = "umap"
    | print_pervasive REV = "rev"
    | print_pervasive NOT = "not"
    | print_pervasive ABS = "abs"
    | print_pervasive FLOOR = "floor"
    | print_pervasive REAL = "real"
    | print_pervasive SQRT = "sqrt"
    | print_pervasive SIN = "sin"
    | print_pervasive COS = "cos"
    | print_pervasive ARCTAN = "arctan"
    | print_pervasive EXP = "exp"
    | print_pervasive LN = "ln"
    | print_pervasive SIZE = "size"
    | print_pervasive CHR = "chr"
    | print_pervasive ORD = "ord"
    | print_pervasive CHARCHR = "char_chr"
    | print_pervasive CHARORD = "char_ord"
    | print_pervasive ORDOF = "ordof"
    | print_pervasive EXPLODE = "explode"
    | print_pervasive IMPLODE = "implode"
    | print_pervasive DEREF = "!"
    | print_pervasive FDIV = "/"
    | print_pervasive DIV = "div"
    | print_pervasive MOD = "mod"
    | print_pervasive PLUS = "+"
    | print_pervasive STAR = "*"
    | print_pervasive MINUS = "-"
    | print_pervasive HAT = "^"
    | print_pervasive AT = "@@"
    | print_pervasive NE = "<>"
    | print_pervasive LESS = "<"
    | print_pervasive GREATER = ">"
    | print_pervasive LESSEQ = "<="
    | print_pervasive GREATEREQ = ">="
    | print_pervasive BECOMES = "becomes"
    | print_pervasive O = "o"
    | print_pervasive UMINUS = "~"
    | print_pervasive EQ = "inline_equality"
    | print_pervasive EQFUN = "external_equality"
    | print_pervasive LOAD_STRING = "load_string"
    | print_pervasive REALPLUS = "_real+"
    | print_pervasive INTPLUS = "_int+"
    | print_pervasive UNSAFEINTPLUS = "_unsafeint+"
    | print_pervasive UNSAFEINTMINUS = "_unsafeint-"
    | print_pervasive REALSTAR = "_real*"
    | print_pervasive INTSTAR = "_int*"
    | print_pervasive REALMINUS = "_real-"
    | print_pervasive INTMINUS = "_int-"
    | print_pervasive REALUMINUS = "_real~"
    | print_pervasive INTUMINUS = "_int~"
    | print_pervasive INTDIV = "_intdiv"
    | print_pervasive INTMOD = "_intmod"
    | print_pervasive INTLESS = "_int<"
    | print_pervasive REALLESS = "_real<"
    | print_pervasive INTGREATER = "_int>"
    | print_pervasive REALGREATER = "_real>"
    | print_pervasive INTLESSEQ = "_int<="
    | print_pervasive REALLESSEQ = "_real<="
    | print_pervasive INTGREATEREQ = "_int>="
    | print_pervasive REALGREATEREQ = "_real>="
    | print_pervasive INTEQ = "_int="
    | print_pervasive INTNE = "_int<>"
    | print_pervasive REALEQ = "_real="
    | print_pervasive REALNE = "_real<>"
    | print_pervasive STRINGEQ = "_string="
    | print_pervasive STRINGNE = "_string<>"
    | print_pervasive STRINGLT = "_string<"
    | print_pervasive STRINGLE = "_string<="
    | print_pervasive STRINGGT = "_string>"
    | print_pervasive STRINGGE = "_string>="
    | print_pervasive CHAREQ = "_char="
    | print_pervasive CHARNE = "_char<>"
    | print_pervasive CHARLT = "_char<"
    | print_pervasive CHARLE = "_char<="
    | print_pervasive CHARGT = "_char>"
    | print_pervasive CHARGE = "_char>="
    | print_pervasive INTABS = "_intabs"
    | print_pervasive REALABS = "realabs"
    | print_pervasive CALL_C = "call_c"
    | print_pervasive ARRAY_FN = "array"
    | print_pervasive LENGTH = "length"
    | print_pervasive SUB = "sub"
    | print_pervasive UPDATE = "update"
    | print_pervasive UNSAFE_SUB = "unsafe_sub"
    | print_pervasive UNSAFE_UPDATE = "unsafe_update"
    | print_pervasive BYTEARRAY = "bytearray"
    | print_pervasive BYTEARRAY_LENGTH = "bytearray_length"
    | print_pervasive BYTEARRAY_SUB = "bytearray_sub"
    | print_pervasive BYTEARRAY_UPDATE = "bytearray_update"
    | print_pervasive BYTEARRAY_UNSAFE_SUB = "bytearray_unsafe_sub"
    | print_pervasive BYTEARRAY_UNSAFE_UPDATE = "bytearray_unsafe_update"
    | print_pervasive FLOATARRAY = "floatarray"
    | print_pervasive FLOATARRAY_LENGTH = "floatearray_length"
    | print_pervasive FLOATARRAY_SUB = "floatarray_sub"
    | print_pervasive FLOATARRAY_UPDATE = "floatarray_update"
    | print_pervasive FLOATARRAY_UNSAFE_SUB = "floatarray_unsafe_sub"
    | print_pervasive FLOATARRAY_UNSAFE_UPDATE = "floatarray_unsafe_update"
    | print_pervasive VECTOR = "vector"
    | print_pervasive VECTOR_LENGTH = "vector_length"
    | print_pervasive VECTOR_SUB = "vector_sub"
    | print_pervasive EXSIZE = "<name of Size>"
    | print_pervasive EXSUBSCRIPT = "<name of Subscript>"
    | print_pervasive ANDB = "andb"
    | print_pervasive LSHIFT = "lshift"
    | print_pervasive NOTB = "notb"
    | print_pervasive ORB = "orb"
    | print_pervasive RSHIFT = "rshift"
    | print_pervasive ARSHIFT = "arshift"
    | print_pervasive XORB = "xorb"
    | print_pervasive CAST = "cast"
    | print_pervasive ALLOC_STRING = "alloc_string"
    | print_pervasive ALLOC_VECTOR = "alloc_vector"
    | print_pervasive ALLOC_PAIR = "alloc_pair"
    | print_pervasive RECORD_UNSAFE_SUB = "record_unsafe_sub"
    | print_pervasive RECORD_UNSAFE_UPDATE = "record_unsafe_update"
    | print_pervasive STRING_UNSAFE_SUB = "string_unsafe_sub"
    | print_pervasive STRING_UNSAFE_UPDATE = "string_unsafe_update"
    | print_pervasive IDENT_FN = "make_ml_value"
    | print_pervasive ML_OFFSET = "ml_value_from_offset"
    | print_pervasive ENTUPLE = "make_ml_value_tuple"
    | print_pervasive ML_CALL = "call_ml_value"
    | print_pervasive ML_REQUIRE = "ml_require"
    | print_pervasive LOAD_VAR = "load_var"
    | print_pervasive LOAD_EXN = "load_exn"
    | print_pervasive LOAD_STRUCT = "load_struct"
    | print_pervasive LOAD_FUNCT = "load_funct"
    | print_pervasive GET_IMPLICIT = "get_implicit"
    | print_pervasive WORDEQ = "_word="
    | print_pervasive WORDNE = "_word<>"
    | print_pervasive WORDLT = "_word<"
    | print_pervasive WORDLE = "_word<="
    | print_pervasive WORDGT = "_word>"
    | print_pervasive WORDGE = "_word>="
    | print_pervasive WORDPLUS = "_word+"
    | print_pervasive WORDMINUS = "_word-"
    | print_pervasive WORDSTAR = "_word*"
    | print_pervasive WORDDIV = "_worddiv"
    | print_pervasive WORDMOD = "_wordmod"
    | print_pervasive WORDORB = "word_orb"
    | print_pervasive WORDXORB = "word_xorb"
    | print_pervasive WORDANDB = "word_andb"
    | print_pervasive WORDNOTB = "word_notb"
    | print_pervasive WORDLSHIFT = "word_lshift"
    | print_pervasive WORDRSHIFT = "word_rshift"
    | print_pervasive WORDARSHIFT = "word_arshift"
    | print_pervasive INT32PLUS = "_int32+"
    | print_pervasive INT32STAR = "_int32*"
    | print_pervasive INT32MINUS = "_int32-"
    | print_pervasive INT32UMINUS = "_int32~"
    | print_pervasive INT32ABS = "_int32abs"
    | print_pervasive INT32MOD = "_int32mod"
    | print_pervasive INT32DIV = "_int32div"
    | print_pervasive INT32LESS = "_int32<"
    | print_pervasive INT32GREATER = "_int32>"
    | print_pervasive INT32LESSEQ = "_int32<="
    | print_pervasive INT32GREATEREQ = "_int32>="
    | print_pervasive INT32EQ = "_int32="
    | print_pervasive INT32NE = "_int32<>"
    | print_pervasive WORD32EQ = "_word32="
    | print_pervasive WORD32NE = "_word32<>"
    | print_pervasive WORD32LT = "_word32<"
    | print_pervasive WORD32LE = "_word32<="
    | print_pervasive WORD32GT = "_word32>"
    | print_pervasive WORD32GE = "_word32>="
    | print_pervasive WORD32PLUS = "_word32+"
    | print_pervasive WORD32MINUS = "_word32-"
    | print_pervasive WORD32STAR = "_word32*"
    | print_pervasive WORD32DIV = "_word32div"
    | print_pervasive WORD32MOD = "_word32mod"
    | print_pervasive WORD32ORB = "word32_orb"
    | print_pervasive WORD32XORB = "word32_xorb"
    | print_pervasive WORD32ANDB = "word32_andb"
    | print_pervasive WORD32NOTB = "word32_notb"
    | print_pervasive WORD32LSHIFT = "word32_lshift"
    | print_pervasive WORD32RSHIFT = "word32_rshift"
    | print_pervasive WORD32ARSHIFT = "word32_arshift"

  (*  == Library names ==
   *
   *  List of pairs relating those pervasives in the library to the names
   *  by which they are defined in the BuiltinLibrary_ structure.
   *
   *  IMPORTANT:
   *    1. Any changes to ../pervasive/__builtin_library.sml must be reflected
   *       here.
   *    2. All exceptions must have both a name _and_ a value.
   *)

  val constructor_name_list = [(REF,"ref")]

  val value_name_list =
    [(CALL_C,"call_c"),
     (EQ, "inline_equality"),
     (EQFUN,"external_equality"),
     (NE,"<>"),
     (LENGTH,"length"),
     (SUB,"sub"),
     (UPDATE,"update"),
     (UNSAFE_SUB,"unsafe_sub"),
     (UNSAFE_UPDATE,"unsafe_update"),
     (FLOOR,"floor"),
     (REAL,"real"),
     (FDIV,"/"),
     (LOAD_STRING,"load_string"),
     (AT, "@@"),
     (ARCTAN, "arctan"),
     (CHR, "chr"),
     (CHARCHR, "char_chr"),
     (HAT, "^"),
     (COS, "cos"),
     (EXP, "exp"),
     (EXPLODE, "explode"),
     (IMPLODE, "implode"),
     (INTABS, "int_abs"),
     (INTEQ, "int_equal"),
     (INTGREATER, "int_greater"),
     (INTGREATEREQ, "int_greater_or_equal"),
     (INTLESS, "int_less"),
     (INTLESSEQ, "int_less_or_equal"),
     (INTUMINUS, "int_negate"),
     (INTNE, "int_not_equal"),
     (INTMINUS, "int_minus"),
     (INTSTAR, "int_multiply"),
     (INTPLUS, "int_plus"),
     (INTMOD, "int_mod"),
     (INTDIV, "int_div"),
     (UNSAFEINTPLUS, "unsafe_int_plus"),
     (UNSAFEINTMINUS, "unsafe_int_minus"),
     (LN, "ln"),
     (DEREF,"!"),
     (BECOMES,":="),
     (MAP, "map"),
     (UMAP, "umap"),
     (O, "o"),
     (NOT, "not"),
     (ORD, "ord"),
     (CHARORD, "char_ord"),
     (ORDOF, "ordof"),
     (REALABS, "real_abs"),
     (REALEQ, "real_equal"),
     (REALGREATER, "real_greater"),
     (REALGREATEREQ, "real_greater_or_equal"),
     (REALLESS, "real_less"),
     (REALLESSEQ, "real_less_or_equal"),
     (REALUMINUS, "real_negate"),
     (REALNE, "real_not_equal"),
     (REALMINUS, "real_minus"),
     (REALSTAR, "real_multiply"),
     (REALPLUS, "real_plus"),
     (REV, "rev"),
     (SIN, "sin"),
     (SIZE, "size"),
     (SQRT, "sqrt"),
     (STRINGEQ, "string_equal"),
     (STRINGNE, "string_not_equal"),
     (STRINGLT, "string_less"),
     (STRINGLE, "string_less_equal"),
     (STRINGGT, "string_greater"),
     (STRINGGE, "string_greater_equal"),
     (CHAREQ, "char_equal"),
     (CHARNE, "char_not_equal"),
     (CHARLT, "char_less"),
     (CHARLE, "char_less_equal"),
     (CHARGT, "char_greater"),
     (CHARGE, "char_greater_equal"),
     (ARRAY_FN,"array"),
     (BYTEARRAY, "bytearray"),
     (BYTEARRAY_LENGTH, "bytearray_length"),
     (BYTEARRAY_SUB, "bytearray_sub"),
     (BYTEARRAY_UNSAFE_SUB, "bytearray_unsafe_sub"),
     (BYTEARRAY_UPDATE, "bytearray_update"),
     (BYTEARRAY_UNSAFE_UPDATE, "bytearray_unsafe_update"),
     (FLOATARRAY, "floatarray"),
     (FLOATARRAY_LENGTH, "floatarray_length"),
     (FLOATARRAY_SUB, "floatarray_sub"),
     (FLOATARRAY_UNSAFE_SUB, "floatarray_unsafe_sub"),
     (FLOATARRAY_UPDATE, "floatarray_update"),
     (FLOATARRAY_UNSAFE_UPDATE, "floatarray_unsafe_update"),
     (VECTOR, "vector"),
     (VECTOR_LENGTH, "vector_length"),
     (VECTOR_SUB, "vector_sub"),
     (ANDB,"andb"),
     (LSHIFT,"lshift"),
     (NOTB,"notb"),
     (ORB,"orb"),
     (RSHIFT,"rshift"),
     (ARSHIFT,"arshift"),
     (XORB,"xorb"),
     (CAST, "cast"),
     (ALLOC_STRING, "alloc_string"),
     (ALLOC_VECTOR, "alloc_vector"),
     (ALLOC_PAIR, "alloc_pair"),
     (RECORD_UNSAFE_SUB, "record_unsafe_sub"),
     (RECORD_UNSAFE_UPDATE, "record_unsafe_update"),
     (STRING_UNSAFE_SUB, "string_unsafe_sub"),
     (STRING_UNSAFE_UPDATE, "string_unsafe_update"),
     (IDENT_FN, "make_ml_value"),
     (ML_OFFSET, "ml_value_from_offset"),
     (ENTUPLE, "make_ml_value_tuple"),
     (ML_CALL, "call_ml_value"),
     (ML_REQUIRE, "ml_require"),
     (LOAD_VAR, "load_var"),
     (LOAD_EXN, "load_exn"),
     (LOAD_STRUCT, "load_struct"),
     (LOAD_FUNCT, "load_funct"),
     (GET_IMPLICIT,"get_implicit"),
     (WORDEQ, "word_equal"),
     (WORDNE, "word_not_equal"),
     (WORDLT, "word_less"),
     (WORDLE, "word_less_equal"),
     (WORDGT, "word_greater"),
     (WORDGE, "word_greater_equal"),
     (WORDPLUS, "word_plus"),
     (WORDMINUS, "word_minus"),
     (WORDSTAR, "word_star"),
     (WORDDIV, "word_div"),
     (WORDMOD, "word_mod"),
     (WORDORB, "word_orb"),
     (WORDXORB, "word_xorb"),
     (WORDANDB, "word_andb"),
     (WORDNOTB, "word_notb"),
     (WORDLSHIFT, "word_lshift"),
     (WORDRSHIFT, "word_rshift"),
     (WORDARSHIFT, "word_arshift"),
     (INT32PLUS, "int32_plus"),
     (INT32STAR, "int32_multiply"),
     (INT32MINUS, "int32_minus"),
     (INT32UMINUS, "int32_negate"),
     (INT32ABS, "int32_abs"),
     (INT32MOD, "int32_mod"),
     (INT32DIV, "int32_div"),
     (INT32LESS, "int32_less"),
     (INT32GREATER, "int32_greater"),
     (INT32LESSEQ, "int32_less_equal"),
     (INT32GREATEREQ, "int32_greater_equal"),
     (INT32EQ, "int32_equal"),
     (INT32NE, "int32_not_equal"),
     (WORD32EQ, "word32_equal"),
     (WORD32NE, "word32_not_equal"),
     (WORD32LT, "word32_less"),
     (WORD32LE, "word32_less_equal"),
     (WORD32GT, "word32_greater"),
     (WORD32GE, "word32_greater_equal"),
     (WORD32PLUS, "word32_plus"),
     (WORD32MINUS, "word32_minus"),
     (WORD32STAR, "word32_star"),
     (WORD32DIV, "word32_div"),
     (WORD32MOD, "word32_mod"),
     (WORD32ORB, "word32_orb"),
     (WORD32XORB, "word32_xorb"),
     (WORD32ANDB, "word32_andb"),
     (WORD32NOTB, "word32_notb"),
     (WORD32LSHIFT, "word32_lshift"),
     (WORD32RSHIFT, "word32_rshift"),
     (WORD32ARSHIFT, "word32_arshift")]

  val exception_name_list =
    [(EXBIND, "Bind"),
     (EXCHR, "Chr"),
     (EXDIV, "Div"),
     (EXEXP, "Exp"),
     (EXINTERRUPT, "Interrupt"),
     (EXIO, "Io"),
     (EXLN, "Ln"),
     (EXMATCH, "Match"),
     (EXORD, "Ord"),
     (EXSQRT, "Sqrt"),
     (EXSIZE, "Size"),
     (EXSUBSCRIPT, "Subscript"),
     (EXOVERFLOW, "Overflow"),
     (EXRANGE, "Range")]

  val pervasives =
    map (fn (x,y) => x)
    (value_name_list @@ exception_name_list @@ constructor_name_list)

    val _ =
      map (fn x => ((print_pervasive x) 
                    handle _ => 
                      (print("*** DANGER *** Failed to find a print_pervasive in _pervasives for something\n ");
                       Crash.impossible "_pervasives - failure to print_pervasive for something")))
      pervasives

    (* We use the names for the pervasives in the map, so check that they are all unique *)
    val _ =
      Lists.reducel( fn (y,x) =>
		    let
		      val str = print_pervasive x
		    in
		      if Lists.member(str, y)
			then Crash.impossible("print_pervasive '" ^ str ^
					      "' is not unique")
		      else str::y
		    end)
      ([],pervasives)

  (* Sort the lists of pervasives with names in to the order in which they *)
  (* will be found in the actual PervasiveLibrary_ structure.  This is the *)
  (* same order as is generated by the lambda translator, and is: *)
  (* sorted values & exceptions, sorted structures. *)

    val library_contents =
      let
	fun make_cons (cons, list) =
	  map (fn (pervasive, name) =>
	         (cons (Symbol.find_symbol name), pervasive))
	      list 

	fun make_sorted (list, order) =
	  map #2
	  (Lists.qsort (fn ((id, _), (id', _)) => order (id, id')) list)
      in
	make_sorted
        (make_cons (Ident.VAR, value_name_list) @@
         make_cons (Ident.EXCON, exception_name_list),
         Ident.valid_order)
      end

    (*  === FIELD NUMBERS WITHIN THE BUILTIN LIBRARY ===
     *
     *  This is a function which maps pervasives on to their positions within
     *  the BuiltinLibrary_ structure, such that a SELECT operation on
     *  BuiltinLibrary_ using the field number gives the pervasive object.
     *  Not all of the pervasives have definitions in the pervasive library,
     *  in particular, the overloaded functions are not represented, but their
     *  non-overloaded counterparts are.
     *)

    fun field_number pervasive =
      let
	fun find (_, []) =
	  Crash.impossible ("No field number for " ^ print_pervasive pervasive)
	  | find (number, pervasive'::rest) =
	    if pervasive = pervasive' then
	      number
	    else
	      find (number + 1, rest)

	val field = find (0, library_contents)

(*
	val _ = Diagnostic.output 2
	  (fn _ => ["Pervasives: Field number of " ^
		    print_pervasive pervasive ^ " is " ^
		    Int.toString field])
*)
(*
	val _ = Diagnostic.output 3
	  (fn _ =>
	   let
	     fun show (_, []) = []
	       | show (n, pervasive::pervasives) =
		 ("\n  " ^ Int.toString n ^
		  " : " ^ print_pervasive pervasive) ::
		 show (n+1, pervasives)
	   in
	     "Pervasives: library field numbers:" ::
	     (show (0, library_contents))
	   end)
*)
      in
	field
      end

    val nr_fields = length library_contents

  (*  === ENCODING, DECODING, AND ORDERING FUNCTIONS ===
   *
   *  The sort function provides a syntactic sort for a pervasive.  Pattern
   *  matching is used, and is probably the fastest method of mapping a
   *  given constructor onto an integer.  The inverse of the sort is done
   *  using a Map.T.
   *)

  local
    val sort_map = 
      let
        fun number ([],_) = []
          | number (pervasive::rest,num) = (print_pervasive pervasive,num) :: number(rest,num+1)
      in
        Map.from_list
        ((op<):string*string->bool,op =)
        (number (pervasives,1))
      end

    val sort = fn x => Map.apply sort_map (print_pervasive x)
  in
    val encode = sort

    local
      val inverse =
        Map.apply (Map.from_list
                   ( (op<) : int * int -> bool,(op=) : int * int -> bool)
                   (map (fn p => (encode p, p)) pervasives))
    in
      fun decode i =
        inverse i
        handle Map.Undefined =>
          Crash.impossible 
          ("Pervasives: Unable to find inverse of sort function for " ^ Int.toString i)
    end

    fun order (pervasive, pervasive') = (sort pervasive) < (sort pervasive')

    (* Specialized equality *)
    val eq = op= : pervasive * pervasive -> bool
  end

end
@


1.60.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.60  1997/05/19  11:14:56  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.60.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.60  1997/05/19  11:14:56  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.60.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.60  1997/05/19  11:14:56  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.59
log
@[Bug #1818]
adding builtins for floatarrays.
@
text
@d4 4
d819 1
a819 1
                      (MLWorks.IO.output(MLWorks.IO.std_out,"*** DANGER *** Failed to find a print_pervasive in _pervasives for something\n ");
@


1.59.1.1
log
@branched from 1.59
@
text
@a3 4
 * Revision 1.59  1996/12/17  12:35:56  andreww
 * [Bug #1818]
 * adding builtins for floatarrays.
 *
@


1.59.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.59.1.1  1997/05/12  10:35:48  hope
 * branched from 1.59
 *
@


1.59.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.59.1.1  1997/05/12  10:35:48  hope
 * branched from 1.59
 *
@


1.59.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.59.1.1  1997/05/12  10:35:48  hope
 * branched from 1.59
 *
@


1.59.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.59.1.1.1.1  1997/07/28  18:21:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.58
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d333 6
d527 6
d708 6
@


1.58.4.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:28:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.3.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:28:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.3.1.1.1
log
@branched from 1.58.3.1
@
text
@a3 3
 * Revision 1.58.3.1  1996/12/17  17:49:15  hope
 * branched from 1.58
 *
@


1.58.2.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:28:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.1.1
log
@branched from 1.58
@
text
@a3 4
 * Revision 1.58  1996/11/06  11:28:55  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.58.1.1.1.1
log
@branched from 1.58.1.1
@
text
@a3 3
 * Revision 1.58.1.1  1996/11/14  12:51:26  hope
 * branched from 1.58
 *
@


1.57
log
@moving String from toplevel
@
text
@d4 3
d204 1
a204 1
require "^.basis.__integer";
@


1.56
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d201 1
a201 3

require "../basis/__integer";

d875 1
a875 1
    val nr_fields = Lists.length library_contents
d892 1
a892 1
        (String.<,op =)
@


1.56.3.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  17:38:26  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.56.2.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  17:38:26  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.56.1.1
log
@branched from 1.56
@
text
@a3 6
 * Revision 1.56  1996/04/30  17:38:26  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.55
log
@Integer changes
@
text
@d4 3
d786 1
a786 1
                      (output(std_out,"*** DANGER *** Failed to find a print_pervasive in _pervasives for something\n ");
@


1.54
log
@Removing old pervasives
@
text
@d4 3
d193 2
d848 1
a848 1
		    MLWorks.Integer.makestring field])
d856 1
a856 1
		 ("\n  " ^ MLWorks.Integer.makestring n ^
d903 1
a903 1
          ("Pervasives: Unable to find inverse of sort function for " ^ MLWorks.Integer.makestring i)
@


1.53
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
a209 1
    EXABS |
a212 7
    EXMOD |
    EXQUOT |
    EXPROD |
    EXNEG |
    EXSUM |
    EXDIFF |
    EXFLOOR |
d220 1
a221 1
    EXOVERFLOW |
a397 1
    | print_pervasive EXABS = "<name of Abs>"
a400 7
    | print_pervasive EXMOD = "<name of Mod>"
    | print_pervasive EXQUOT = "<name of Quot>"
    | print_pervasive EXPROD = "<name of Prod>"
    | print_pervasive EXNEG = "<name of Neg>"
    | print_pervasive EXSUM = "<name of Sum>"
    | print_pervasive EXDIFF = "<name of Diff>"
    | print_pervasive EXFLOOR = "<name of Floor>"
d408 1
a409 1
    | print_pervasive EXOVERFLOW = "<name of Overflow>"
d756 1
a756 2
    [(EXABS, "Abs"),
     (EXBIND, "Bind"),
a757 1
     (EXDIFF, "Diff"),
a759 1
     (EXFLOOR, "Floor"),
a763 2
     (EXMOD, "Mod"),
     (EXNEG, "Neg"),
a764 2
     (EXPROD, "Prod"),
     (EXQUOT, "Quot"),
a765 1
     (EXSUM, "Sum"),
@


1.52
log
@Added pervasives for Word32, Int32, etc.
@
text
@d4 3
d189 1
a189 1
require "../utils/newmap";
d196 1
a196 1
  structure Map	       : NEWMAP
@


1.51
log
@Change mod to be int_mod
@
text
@d4 3
a328 2
    INTTOWORD |
    SIGNEXTEND |
a339 1
    WORDTOINT |
d347 31
a541 2
    | print_pervasive INTTOWORD = "intToWord"
    | print_pervasive SIGNEXTEND = "signExtend"
a552 1
    | print_pervasive WORDTOINT = "wordToInt"
d560 31
a714 2
     (INTTOWORD, "intToWord"),
     (SIGNEXTEND, "signExtend"),
a725 1
     (WORDTOINT, "wordToInt"),
d732 32
a763 1
     (WORDARSHIFT, "word_arshift")]
@


1.50
log
@Add primitive operations on words
@
text
@d4 3
d272 2
d440 2
d522 2
a523 2
    | print_pervasive WORDDIV = "word_div"
    | print_pervasive WORDMOD = "word_mod"
a558 1
     (DIV,"div"),
d580 2
a588 1
     (MOD, "mod"),
@


1.49
log
@Adding new operations on chars
@
text
@d4 3
d217 1
d320 22
d383 1
d504 21
d648 22
a669 1
     (GET_IMPLICIT,"get_implicit")]
d692 1
@


1.48
log
@Commenting out diagnostics
@
text
@d4 3
d230 2
d283 6
d373 2
d426 6
d509 1
d537 1
d560 6
@


1.47
log
@Adding CAST and UMAP pervasives
@
text
@d4 3
a178 1

a189 4
  (* The pervasives.  Note that the exceptions have two pervasives, one for *)
  (* the exception `name' (unique) and the other for the exception value *)
  (* (packet constructor). *)

a447 1
    (* Associated with the interpreter only *)
a563 1
     (* Associated with the interpreter only *)
a597 2
  val structure_name_list = []

d639 3
a641 5
	  (make_cons (Ident.VAR, value_name_list) @@
	     make_cons (Ident.EXCON, exception_name_list),
	   Ident.valid_order) @@
	  (make_sorted (make_cons (Ident.STRID, structure_name_list),
			Ident.strid_order))
a643 2
    val library_contents = library_contents

a655 1

d657 1
a657 5
	  Crash.impossible
	  ("Pervasives: I've been asked for the field number of " ^
	   print_pervasive pervasive ^ " which doesn't occur in the " ^
	   "pervasive library name list.")

d666 1
d671 2
a672 1

d685 1
a685 1

d691 1
a700 1

a711 7

    val _ =
      map (fn x => ((sort x) 
                    handle _ => 
                      (output(std_out,"*** DANGER *** Failed to find a sort code in _pervasives for " ^
                              print_pervasive x ^ "\n");
                       Crash.impossible "Failed in _pervasives - see above"))) pervasives
d728 1
a728 2
    fun order (pervasive, pervasive') =
      (sort pervasive) < (sort pervasive')
@


1.46
log
@Adding breakpoint and step builtins
@
text
@d4 3
d214 1
d308 1
d349 1
d442 1
d515 1
d559 1
@


1.45
log
@Adding "unsafe" allocation and update functions
@
text
@d4 3
d320 2
a321 1
    LOAD_FUNCT
d453 1
d567 2
a568 1
     (LOAD_FUNCT, "load_funct")]
@


1.44
log
@Added eq function
@
text
@d4 3
d248 1
d300 8
d380 1
d432 7
d497 2
a498 1
     (UNSAFEINTPLUS, "unsafeint_plus"),
d546 7
@


1.43
log
@new file
@
text
@d4 3
d708 2
@


1.42
log
@Added unsafeintplus for generating large integers
@
text
@d4 10
d162 1
a162 1
require "pervasives";
a657 164


  (*  === EXTRACT IMPLICIT REFERENCES OF PERVASIVE ===
   *
   *  Maps a pervasive onto the list of pervasives it references implicitly
   *  (such as exceptions).
   *
   *  NOTE: At the moment the contents of the list must match what Mir_Cg expects.
   *)

  fun implicit_references INTPLUS          = [EXSUM]
    | implicit_references INTSTAR          = [EXPROD]
    | implicit_references INTMINUS         = [EXDIFF]
    | implicit_references INTUMINUS        = [EXNEG]
    | implicit_references INTABS           = [EXABS]
    | implicit_references DIV              = [EXDIV]
    | implicit_references REALPLUS         = [EXSUM]
    | implicit_references REALSTAR         = [EXPROD]
    | implicit_references REALMINUS        = [EXDIFF]
    | implicit_references REALUMINUS       = [EXNEG]
    | implicit_references REALABS          = [EXABS]
    | implicit_references FDIV             = [EXQUOT]
    | implicit_references MOD              = [EXMOD]
    | implicit_references FLOOR            = [EXFLOOR]
    | implicit_references SQRT             = [EXSQRT]
    | implicit_references EXP              = [EXEXP]
    | implicit_references LN               = [EXLN]
    | implicit_references ORD              = [EXORD]
    | implicit_references ORDOF            = [EXORD]
    | implicit_references CHR              = [EXCHR]
    | implicit_references ARRAY_FN         = [EXSIZE]
    | implicit_references SUB              = [EXSUBSCRIPT]
    | implicit_references UPDATE           = [EXSUBSCRIPT]
    | implicit_references BYTEARRAY        = [EXSIZE]
    | implicit_references BYTEARRAY_SUB    = [EXSUBSCRIPT]
    | implicit_references BYTEARRAY_UPDATE = [EXSUBSCRIPT]
    | implicit_references VECTOR_SUB       = [EXSUBSCRIPT]
    | implicit_references EQ	           = [EQFUN]
    | implicit_references _	           = []

    
  fun is_fun REF = true
    | is_fun EXABS = false
    | is_fun EXORD = false
    | is_fun EXCHR = false
    | is_fun EXDIV = false
    | is_fun EXMOD = false
    | is_fun EXQUOT = false
    | is_fun EXPROD = false
    | is_fun EXNEG = false
    | is_fun EXSUM = false
    | is_fun EXDIFF = false
    | is_fun EXFLOOR = false
    | is_fun EXSQRT = false
    | is_fun EXEXP = false
    | is_fun EXLN = false
    | is_fun EXIO = false
    | is_fun EXMATCH = false
    | is_fun EXBIND = false
    | is_fun EXINTERRUPT = false
    | is_fun EXRANGE = false
    | is_fun MAP = true
    | is_fun REV = true
    | is_fun NOT = true
    | is_fun ABS = true
    | is_fun FLOOR = true
    | is_fun REAL = true
    | is_fun SQRT = true
    | is_fun SIN = true
    | is_fun COS = true
    | is_fun ARCTAN = true
    | is_fun EXP = true
    | is_fun LN = true
    | is_fun SIZE = true
    | is_fun CHR = true
    | is_fun ORD = true
    | is_fun ORDOF = true
    | is_fun EXPLODE = true
    | is_fun IMPLODE = true
    | is_fun DEREF = true
    | is_fun FDIV = true
    | is_fun DIV = true
    | is_fun MOD = true
    | is_fun PLUS = false
    | is_fun STAR = false
    | is_fun MINUS = false
    | is_fun HAT = true
    | is_fun AT = true
    | is_fun NE = true
    | is_fun LESS = false
    | is_fun GREATER = false
    | is_fun LESSEQ = false
    | is_fun GREATEREQ = false
    | is_fun BECOMES = true
    | is_fun O = true
    | is_fun UMINUS = false
    | is_fun EQ = true
    | is_fun EQFUN = true
    | is_fun LOAD_STRING = false
    | is_fun REALPLUS = true
    | is_fun INTPLUS = true
    | is_fun UNSAFEINTPLUS = true
    | is_fun REALSTAR = true
    | is_fun INTSTAR = true
    | is_fun REALMINUS = true
    | is_fun INTMINUS = true
    | is_fun REALUMINUS = true
    | is_fun INTUMINUS = true
    | is_fun INTLESS = true
    | is_fun REALLESS = true
    | is_fun INTGREATER = true
    | is_fun REALGREATER = true
    | is_fun INTLESSEQ = true
    | is_fun REALLESSEQ = true
    | is_fun INTGREATEREQ = true
    | is_fun REALGREATEREQ = true
    | is_fun INTEQ = true
    | is_fun INTNE = true
    | is_fun REALEQ = true
    | is_fun REALNE = true
    | is_fun STRINGEQ = true
    | is_fun STRINGNE = true
    | is_fun STRINGLT = true
    | is_fun STRINGLE = true
    | is_fun STRINGGT = true
    | is_fun STRINGGE = true
    | is_fun INTABS = true
    | is_fun REALABS = true
    | is_fun CALL_C = true
    | is_fun ARRAY_FN = true
    | is_fun LENGTH = true
    | is_fun SUB = true
    | is_fun UPDATE =true
    | is_fun UNSAFE_SUB = true
    | is_fun UNSAFE_UPDATE =true
    | is_fun BYTEARRAY = true
    | is_fun BYTEARRAY_LENGTH = true
    | is_fun BYTEARRAY_SUB = true
    | is_fun BYTEARRAY_UPDATE =true
    | is_fun BYTEARRAY_UNSAFE_SUB = true
    | is_fun BYTEARRAY_UNSAFE_UPDATE = true
    | is_fun VECTOR = true
    | is_fun VECTOR_LENGTH = true
    | is_fun VECTOR_SUB = true
    | is_fun EXSIZE = false
    | is_fun EXSUBSCRIPT =false
    | is_fun ANDB = true
    | is_fun LSHIFT = true
    | is_fun NOTB = true
    | is_fun ORB = true
    | is_fun RSHIFT = true
    | is_fun ARSHIFT = true
    | is_fun XORB = true
    (* Associated with the interpreter only *)
    | is_fun IDENT_FN = true
    | is_fun ML_OFFSET = true
    | is_fun ENTUPLE = true
    | is_fun ML_CALL = true
    | is_fun ML_REQUIRE = true
    | is_fun LOAD_VAR = false
    | is_fun LOAD_EXN = false
    | is_fun LOAD_STRUCT = false
    | is_fun LOAD_FUNCT = false

@


1.42.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.42  1993/07/20  12:33:35  jont
Added unsafeintplus for generating large integers

@


1.41
log
@Removed EX*VAL values, since we no longer have exception environments.
@
text
@d4 3
d231 1
d354 1
d464 1
d562 8
a569 3
                    if Lists.member(print_pervasive(x),y)
                      then Crash.impossible "print_pervasive is not unique"
                    else (print_pervasive x)::y)
d749 1
@


1.40
log
@Removed integer parameter
@
text
@d4 3
a187 19
    EXABSVAL |
    EXORDVAL |
    EXCHRVAL |
    EXDIVVAL |
    EXMODVAL |
    EXQUOTVAL |
    EXPRODVAL |
    EXNEGVAL |
    EXSUMVAL |
    EXDIFFVAL |
    EXFLOORVAL |
    EXSQRTVAL |
    EXEXPVAL |
    EXLNVAL |
    EXIOVAL |
    EXMATCHVAL |
    EXBINDVAL |
    EXINTERRUPTVAL |
    EXRANGEVAL |
a270 1
    EXSIZEVAL |
a271 1
    EXSUBSCRIPTVAL |
a309 19
    | print_pervasive EXABSVAL = "Abs"
    | print_pervasive EXORDVAL = "Ord"
    | print_pervasive EXCHRVAL = "Chr"
    | print_pervasive EXDIVVAL = "Div"
    | print_pervasive EXMODVAL = "Mod"
    | print_pervasive EXQUOTVAL = "Quot"
    | print_pervasive EXPRODVAL = "Prod"
    | print_pervasive EXNEGVAL = "Neg"
    | print_pervasive EXSUMVAL = "Sum"
    | print_pervasive EXDIFFVAL = "Diff"
    | print_pervasive EXFLOORVAL = "Floor"
    | print_pervasive EXSQRTVAL = "Sqrt"
    | print_pervasive EXEXPVAL = "ExpVAL"
    | print_pervasive EXLNVAL = "Ln"
    | print_pervasive EXIOVAL = "Io"
    | print_pervasive EXMATCHVAL = "Match"
    | print_pervasive EXBINDVAL = "Bind"
    | print_pervasive EXINTERRUPTVAL = "Interrupt"
    | print_pervasive EXRANGEVAL = "Range"
a393 2
    | print_pervasive EXSIZEVAL = "Size"
    | print_pervasive EXSUBSCRIPTVAL = "Subscript"
a444 19
     (EXABSVAL, "Abs"),
     (EXBINDVAL, "Bind"),
     (EXCHRVAL, "Chr"),
     (EXDIFFVAL, "Diff"),
     (EXDIVVAL, "Div"),
     (EXEXPVAL, "Exp"),
     (EXFLOORVAL, "Floor"),
     (EXINTERRUPTVAL, "Interrupt"),
     (EXIOVAL, "Io"),
     (EXLNVAL, "Ln"),
     (EXMATCHVAL, "Match"),
     (EXMODVAL, "Mod"),
     (EXNEGVAL, "Neg"),
     (EXORDVAL, "Ord"),
     (EXPRODVAL, "Prod"),
     (EXQUOTVAL, "Quot"),
     (EXSQRTVAL, "Sqrt"),
     (EXSUMVAL, "Sum"),
     (EXRANGEVAL, "Range"),
a488 2
     (EXSIZEVAL, "Size"),
     (EXSUBSCRIPTVAL, "Subscript"),
d564 1
a564 1
  (* sorted values, sorted exceptions, sorted structures. *)
a565 2
  local
    
d568 6
a573 1
	fun make_sorted (list, cons, order) =
d575 1
a575 3
	  (Lists.qsort (fn ((id, _), (id', _)) => order (id, id'))
	   (map (fn (pervasive, name) =>
		 (cons (Symbol.find_symbol name), pervasive)) list))
d577 6
a582 3
	(make_sorted (value_name_list, Ident.VAR, Ident.valid_order)) @@
	(make_sorted (exception_name_list, Ident.EXCON, Ident.valid_order)) @@
	(make_sorted (structure_name_list, Ident.STRID, Ident.strid_order))
a584 17
(* removed, it never worked properly anyway
    fun find_repeats([], _) = ()
      | find_repeats((h::t), exceptions) =
        if Lists.member(h,t) andalso not (Lists.member(h,exceptions))
          then (output(std_out,"*** DANGER REPEATED ELEMENT " ^ h ^ " in _pervasives \n") ; 
                find_repeats(t, exceptions))
        else find_repeats(t, exceptions)

    fun check_found [] _ = ()
      | check_found (h::t) values =
        if Lists.member(h,values) then check_found t values
        else (output(std_out,"*** DANGER the exception " ^ h ^ " does not seem to have a value definition\n");
              check_found t values)
*)

  in

a586 11
(* Removed, it never worked properly anyway
    val to_be_checked = (map #2 value_name_list,
                         map #2 exception_name_list)

    (* Actually check that the lists are of the correct form *)

    val _ = find_repeats (#1 to_be_checked)
    val _ = find_repeats (#2 to_be_checked)
    val _ = check_found (#2 to_be_checked) (#1 to_be_checked)
*)

a635 4
(*
    fun is_in_library pervasive = Lists.member (pervasive, library_contents)
*)

a637 2
  end

d647 27
a673 27
  fun implicit_references INTPLUS          = [EXSUMVAL]
    | implicit_references INTSTAR          = [EXPRODVAL]
    | implicit_references INTMINUS         = [EXDIFFVAL]
    | implicit_references INTUMINUS        = [EXNEGVAL]
    | implicit_references INTABS           = [EXABSVAL]
    | implicit_references DIV              = [EXDIVVAL]
    | implicit_references REALPLUS         = [EXSUMVAL]
    | implicit_references REALSTAR         = [EXPRODVAL]
    | implicit_references REALMINUS        = [EXDIFFVAL]
    | implicit_references REALUMINUS       = [EXNEGVAL]
    | implicit_references REALABS          = [EXABSVAL]
    | implicit_references FDIV             = [EXQUOTVAL]
    | implicit_references MOD              = [EXMODVAL]
    | implicit_references FLOOR            = [EXFLOORVAL]
    | implicit_references SQRT             = [EXSQRTVAL]
    | implicit_references EXP              = [EXEXPVAL]
    | implicit_references LN               = [EXLNVAL]
    | implicit_references ORD              = [EXORDVAL]
    | implicit_references ORDOF            = [EXORDVAL]
    | implicit_references CHR              = [EXCHRVAL]
    | implicit_references ARRAY_FN         = [EXSIZEVAL]
    | implicit_references SUB              = [EXSUBSCRIPTVAL]
    | implicit_references UPDATE           = [EXSUBSCRIPTVAL]
    | implicit_references BYTEARRAY        = [EXSIZEVAL]
    | implicit_references BYTEARRAY_SUB    = [EXSUBSCRIPTVAL]
    | implicit_references BYTEARRAY_UPDATE = [EXSUBSCRIPTVAL]
    | implicit_references VECTOR_SUB       = [EXSUBSCRIPTVAL]
a697 19
    | is_fun EXABSVAL = false
    | is_fun EXORDVAL = false
    | is_fun EXCHRVAL = false
    | is_fun EXDIVVAL = false
    | is_fun EXMODVAL = false
    | is_fun EXQUOTVAL = false
    | is_fun EXPRODVAL = false
    | is_fun EXNEGVAL = false
    | is_fun EXSUMVAL = false
    | is_fun EXDIFFVAL = false
    | is_fun EXFLOORVAL = false
    | is_fun EXSQRTVAL = false
    | is_fun EXEXPVAL = false
    | is_fun EXLNVAL = false
    | is_fun EXIOVAL = true
    | is_fun EXMATCHVAL = false
    | is_fun EXBINDVAL = false
    | is_fun EXINTERRUPTVAL = false
    | is_fun EXRANGEVAL = false
a781 2
    | is_fun EXSIZEVAL = false
    | is_fun EXSUBSCRIPTVAL =false
@


1.39
log
@Added vector primitives
@
text
@d4 3
a144 1
require "../utils/integer";
a145 1
require "../basics/symbol";
a152 2
  structure Symbol     : SYMBOL
  structure Integer    : INTEGER
a154 1
  sharing Symbol = Ident.Symbol
d157 1
a157 1

d701 1
a701 1
		    Integer.makestring field])
d708 1
a708 1
		 ("\n  " ^ Integer.makestring n ^
d952 1
a952 1
          ("Pervasives: Unable to find inverse of sort function for " ^ Integer.makestring i)
@


1.38
log
@Added builtin string relationals
@
text
@d4 3
d285 3
d428 3
d558 3
d765 1
d887 4
a890 1
    | is_fun BYTEARRAY_UNSAFE_UPDATE =true
@


1.37
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d263 4
d403 4
d536 4
d856 4
@


1.36
log
@Removed some redundant items from the signature
@
text
@d4 3
d894 1
a894 5
        (fn (x,y) => if x=y
                       then Map.EQUAL
                     else if String.<(x,y)
                       then Map.LESS
                         else Map.GREATER)
d912 1
a912 2
                   (fn (x:int, y:int) =>
                    if x=y then Map.EQUAL else if x<y then Map.LESS else Map.GREATER)
@


1.35
log
@Added bytearray and unsafe update primitives.
NOTE: Bytearray stuff should raise Range exception.
@
text
@d4 4
d613 3
a615 2
    fun find_repeats [] exceptions = ()
      | find_repeats (h::t) exceptions =
d618 2
a619 2
                find_repeats t exceptions)
        else find_repeats t exceptions;
d626 1
d632 1
d641 1
a642 1

d657 4
a660 4
	    Crash.impossible
	    ("Pervasives: I've been asked for the field number of " ^
	     print_pervasive pervasive ^ " which doesn't occur in the " ^
	     "pervasive library name list.")
d692 1
d694 1
@


1.34
log
@Changed reference to rts/__builtin_library to pervasive directory.
@
text
@d4 3
d173 1
d192 1
d262 6
d309 1
d328 1
d398 6
d477 1
d521 6
d565 2
a566 1
     (EXSUBSCRIPT, "Subscript")]
d700 28
a727 25
  fun implicit_references INTPLUS    = [EXSUMVAL]
    | implicit_references INTSTAR    = [EXPRODVAL]
    | implicit_references INTMINUS   = [EXDIFFVAL]
    | implicit_references INTUMINUS  = [EXNEGVAL]
    | implicit_references INTABS     = [EXABSVAL]
    | implicit_references DIV        = [EXDIVVAL]
    | implicit_references REALPLUS   = [EXSUMVAL]
    | implicit_references REALSTAR   = [EXPRODVAL]
    | implicit_references REALMINUS  = [EXDIFFVAL]
    | implicit_references REALUMINUS = [EXNEGVAL]
    | implicit_references REALABS    = [EXABSVAL]
    | implicit_references FDIV       = [EXQUOTVAL]
    | implicit_references MOD        = [EXMODVAL]
    | implicit_references FLOOR      = [EXFLOORVAL]
    | implicit_references SQRT       = [EXSQRTVAL]
    | implicit_references EXP        = [EXEXPVAL]
    | implicit_references LN         = [EXLNVAL]
    | implicit_references ORD        = [EXORDVAL]
    | implicit_references ORDOF      = [EXORDVAL]
    | implicit_references CHR        = [EXCHRVAL]
    | implicit_references ARRAY_FN   = [EXSIZEVAL]
    | implicit_references SUB        = [EXSUBSCRIPTVAL]
    | implicit_references UPDATE     = [EXSUBSCRIPTVAL]
    | implicit_references EQ	     = [EQFUN]
    | implicit_references _	     = []
d749 1
d768 1
d838 6
@


1.33
log
@Added UNSAFE_UPDATE and UNSAFE_SUB.
@
text
@d4 3
d413 1
a413 1
   *    1. Any changes to ../rts/__builtin_library.sml must be reflected
@


1.32
log
@Added inline ordof
@
text
@d4 3
d251 1
d253 1
d380 2
d425 2
d801 2
@


1.31
log
@String structure is now pervasive.
@
text
@d4 3
d197 1
d323 1
d468 1
d679 1
d740 1
@


1.30
log
@Added ML_REQUIRE builtin for interpreter to get builtin library
@
text
@d4 3
a114 1
require "../utils/string";
d124 7
a130 10

  structure Lists	: LISTS
  structure String      : STRING
  structure Map		: NEWMAP
  structure Ident	: IDENT
  structure Symbol	: SYMBOL
  structure Integer	: INTEGER
  structure Diagnostic	: DIAGNOSTIC
  structure Crash	: CRASH

d132 1
a132 3

) : PERVASIVES =

@


1.29
log
@Added new builtin ML_OFFSET for computing pointers into middles of
letrec code vectors
@
text
@d4 4
d264 1
d389 1
d498 1
d803 1
@


1.28
log
@Added various loading functions for interpreter, and tidied up
@
text
@d4 3
d257 1
d381 1
d489 1
d793 1
@


1.27
log
@Added extra pervasive in is_fun
@
text
@d4 3
d252 8
a259 1
    IDENT_FN
d375 1
d377 6
d481 9
a489 1
     (XORB,"xorb")]
d785 1
d787 6
a793 1

a848 1

@


1.26
log
@Added ident function to alloow type casting required by interpreter
@
text
@d4 3
d760 1
@


1.25
log
@Changed arithmetic_rshift to arshift to agree with builtin library
@
text
@d4 3
d245 2
a246 1
    XORB
d362 1
@


1.24
log
@Added arithmetic right shift operator
@
text
@d4 3
d356 1
a356 1
    | print_pervasive ARSHIFT = "arithmetic_rshift"
d455 1
a455 1
     (ARSHIFT,"arithmetic_rshift"),
@


1.23
log
@Tried to neaten
@
text
@d4 3
d238 1
d353 1
d452 1
d747 1
@


1.22
log
@Added the Bits structure
@
text
@d4 3
d90 1
d102 1
a236 16
  val pervasives =
    [REF, EXABS, EXORD, EXCHR, EXDIV, EXMOD, EXQUOT, EXPROD,
     EXNEG, EXSUM, EXDIFF, EXFLOOR, EXSQRT, EXEXP, EXLN, EXIO, EXMATCH, EXBIND,
     EXINTERRUPT, EXABSVAL, EXORDVAL, EXCHRVAL, EXDIVVAL, EXMODVAL, EXQUOTVAL,
     EXPRODVAL, EXNEGVAL, EXSUMVAL, EXDIFFVAL, EXFLOORVAL, EXSQRTVAL, EXEXPVAL,
     EXLNVAL, EXIOVAL, EXMATCHVAL, EXBINDVAL, EXINTERRUPTVAL, MAP, REV, NOT, ABS,
     FLOOR, REAL, SQRT, SIN, COS, ARCTAN, EXP, LN, SIZE, CHR, ORD, EXPLODE,
     IMPLODE, DEREF, FDIV, DIV, MOD, PLUS, STAR, MINUS, HAT, AT, NE, LESS,
     GREATER, LESSEQ, GREATEREQ, BECOMES, O, UMINUS, EQ, EQFUN, LOAD_STRING,
     REALPLUS, INTPLUS, REALSTAR, INTSTAR, REALMINUS, INTMINUS, REALUMINUS,
     INTUMINUS, INTLESS, REALLESS, INTGREATER, REALGREATER, INTLESSEQ,
     REALLESSEQ, INTGREATEREQ, REALGREATEREQ, INTEQ, INTNE, REALEQ, REALNE,
     STRINGEQ, STRINGNE, INTABS, REALABS, CALL_C, ARRAY_FN, LENGTH, SUB, UPDATE,
     EXSIZE, EXSIZEVAL, EXSUBSCRIPT, EXSUBSCRIPTVAL,ANDB,LSHIFT,NOTB,ORB,RSHIFT,XORB]


d473 19
d753 23
a775 113
    fun sort REF = 0
      | sort EXABS = 1
      | sort EXORD = 2
      | sort EXCHR = 3
      | sort EXDIV = 4
      | sort EXMOD = 5
      | sort EXQUOT = 6
      | sort EXPROD = 7
      | sort EXNEG = 8
      | sort EXSUM = 9
      | sort EXDIFF = 10
      | sort EXFLOOR = 11
      | sort EXSQRT = 12
      | sort EXEXP = 13
      | sort EXLN = 14
      | sort EXIO = 15
      | sort EXMATCH = 16
      | sort EXBIND = 17
      | sort EXINTERRUPT = 18
      | sort MAP = 19
      | sort REV = 20
      | sort NOT = 21
      | sort ABS = 22
      | sort FLOOR = 23
      | sort REAL = 24
      | sort SQRT = 25
      | sort SIN = 26
      | sort COS = 27
      | sort ARCTAN = 28
      | sort EXP = 29
      | sort LN = 30
      | sort SIZE = 31
      | sort CHR = 32
      | sort ORD = 33
      | sort EXPLODE = 34
      | sort IMPLODE = 35
      | sort DEREF = 36
      | sort FDIV = 37
      | sort DIV = 38
      | sort MOD = 39
      | sort PLUS = 40
      | sort STAR = 41
      | sort MINUS = 42
      | sort HAT = 43
      | sort AT = 44
      | sort NE = 45
      | sort LESS = 46
      | sort GREATER = 47
      | sort LESSEQ = 48
      | sort GREATEREQ = 49
      | sort BECOMES = 50
      | sort O = 51
      | sort UMINUS = 52
      | sort EQ = 53
      | sort LOAD_STRING = 65
      | sort REALPLUS = 66
      | sort INTPLUS = 67
      | sort REALSTAR = 68
      | sort INTSTAR = 69
      | sort REALMINUS = 70
      | sort INTMINUS = 71
      | sort REALUMINUS = 72
      | sort INTUMINUS = 73
      | sort INTLESS = 74
      | sort REALLESS = 75
      | sort INTGREATER = 76
      | sort REALGREATER = 77
      | sort INTLESSEQ = 78
      | sort REALLESSEQ = 79
      | sort INTGREATEREQ = 80
      | sort REALGREATEREQ = 81
      | sort INTEQ = 82
      | sort INTNE = 83
      | sort REALEQ = 84
      | sort REALNE = 85
      | sort STRINGEQ = 86
      | sort STRINGNE = 87
      | sort INTABS = 88
      | sort REALABS = 89
      | sort CALL_C = 90
      | sort EXABSVAL = 92
      | sort EXORDVAL = 93
      | sort EXCHRVAL = 94
      | sort EXDIVVAL = 95
      | sort EXMODVAL = 96
      | sort EXQUOTVAL = 97
      | sort EXPRODVAL = 98
      | sort EXNEGVAL = 99
      | sort EXSUMVAL = 100
      | sort EXDIFFVAL = 101
      | sort EXFLOORVAL = 102
      | sort EXSQRTVAL = 103
      | sort EXEXPVAL = 104
      | sort EXLNVAL = 105
      | sort EXIOVAL = 106
      | sort EXMATCHVAL = 107
      | sort EXBINDVAL = 108
      | sort EXINTERRUPTVAL = 109
      | sort ARRAY_FN = 112
      | sort LENGTH = 114
      | sort SUB  = 115
      | sort UPDATE = 117
      | sort EXSIZE = 118
      | sort EXSUBSCRIPT = 119
      | sort EXSIZEVAL = 120
      | sort EXSUBSCRIPTVAL = 121
      | sort EQFUN = 122
      | sort ANDB = 123
      | sort LSHIFT = 124
      | sort NOTB = 125
      | sort ORB = 126
      | sort RSHIFT = 127
      | sort XORB = 128
@


1.21
log
@Changed makestring for Integer.makestring
@
text
@d4 3
d224 7
a230 1
    EXSUBSCRIPTVAL
d245 1
a245 1
     EXSIZE, EXSIZEVAL, EXSUBSCRIPT, EXSUBSCRIPTVAL]
d247 1
d355 6
a360 1
      
a361 2


d452 7
a458 1
     (ARRAY_FN,"array")]
d524 1
a524 1
    (* I suppose some documentation here would be too much to ask for? *)
d728 6
d852 6
@


1.20
log
@Improved the method of encoding and decoding pervasives to integers.
Updated documentation which was not corrected by other programmers.
@
text
@d4 4
d841 1
a841 1
          ("Pervasives: Unable to find inverse of sort function for " ^ makestring i)
@


1.19
log
@Added EQFUN pervasive and made EQ refer to it.
@
text
@d4 3
d80 1
d91 1
d219 15
d305 2
a306 2
    | print_pervasive EQ = "="
    | print_pervasive EQFUN = "external_polymorphic_equality"
d342 4
a345 1
  (*  === FIELD NUMBERS WITHIN THE PERVASIVE LIBRARY ===
d347 7
a353 6
   *  This is a function which maps pervasives on to their positions within
   *  the PervasiveLibrary structure, such that a SELECT operation on
   *  PervasiveLibrary using the field number gives the pervasive object.
   *  Not all of the pervasives have definitions in the pervasive library,
   *  in particular, the overloaded functions are not represented, but their
   *  non-overloaded counterparts are.
d356 1
d358 78
a435 10
    (*  == Library names ==
     *
     *  List of pairs relating those pervasives in the library to the names
     *  by which they are defined in the PervasiveLibrary_ structure.
     *
     *  IMPORTANT:
     *    1. Any changes to ../rts/pervasive_library.sml must be reflected
     *       here.
     *    2. All exceptions must have both a name _and_ a value.
     *)
d437 21
a457 1
    val constructor_name_list = [(REF,"ref")]
d459 1
a459 77
    val value_name_list =
      [(CALL_C,"call_c"),
       (EQFUN,"equality"),
       (NE,"<>"),
       (LENGTH,"length"),
       (SUB,"sub"),
       (UPDATE,"update"),
       (FLOOR,"floor"),
       (REAL,"real"),
       (FDIV,"/"),
       (DIV,"div"),
       (LOAD_STRING,"load_string"),
       (AT, "@@"),
       (ARCTAN, "arctan"),
       (CHR, "chr"),
       (HAT, "^"),
       (COS, "cos"),
       (EXABSVAL, "Abs"),
       (EXBINDVAL, "Bind"),
       (EXCHRVAL, "Chr"),
       (EXDIFFVAL, "Diff"),
       (EXDIVVAL, "Div"),
       (EXEXPVAL, "Exp"),
       (EXFLOORVAL, "Floor"),
       (EXINTERRUPTVAL, "Interrupt"),
       (EXIOVAL, "Io"),
       (EXLNVAL, "Ln"),
       (EXMATCHVAL, "Match"),
       (EXMODVAL, "Mod"),
       (EXNEGVAL, "Neg"),
       (EXORDVAL, "Ord"),
       (EXPRODVAL, "Prod"),
       (EXQUOTVAL, "Quot"),
       (EXSQRTVAL, "Sqrt"),
       (EXSUMVAL, "Sum"),
       (EXP, "exp"),
       (EXPLODE, "explode"),
       (IMPLODE, "implode"),
       (INTABS, "int_abs"),
       (INTEQ, "int_equal"),
       (INTGREATER, "int_greater"),
       (INTGREATEREQ, "int_greater_or_equal"),
       (INTLESS, "int_less"),
       (INTLESSEQ, "int_less_or_equal"),
       (INTUMINUS, "int_negate"),
       (INTNE, "int_not_equal"),
       (INTMINUS, "int_minus"),
       (INTSTAR, "int_multiply"),
       (INTPLUS, "int_plus"),
       (LN, "ln"),
       (DEREF,"!"),
       (BECOMES,":="),
       (MAP, "map"),
       (MOD, "mod"),
       (O, "o"),
       (NOT, "not"),
       (ORD, "ord"),
       (REALABS, "real_abs"),
       (REALEQ, "real_equal"),
       (REALGREATER, "real_greater"),
       (REALGREATEREQ, "real_greater_or_equal"),
       (REALLESS, "real_less"),
       (REALLESSEQ, "real_less_or_equal"),
       (REALUMINUS, "real_negate"),
       (REALNE, "real_not_equal"),
       (REALMINUS, "real_minus"),
       (REALSTAR, "real_multiply"),
       (REALPLUS, "real_plus"),
       (REV, "rev"),
       (SIN, "sin"),
       (SIZE, "size"),
       (SQRT, "sqrt"),
       (STRINGEQ, "string_equal"),
       (STRINGNE, "string_not_equal"),
       (EXSIZEVAL,"Size"),
       (EXSUBSCRIPTVAL,"Subscript"),
       (ARRAY_FN,"array")]
d461 4
a464 21
    val exception_name_list =
      [(EXABS, "Abs"),
       (EXBIND, "Bind"),
       (EXCHR, "Chr"),
       (EXDIFF, "Diff"),
       (EXDIV, "Div"),
       (EXEXP, "Exp"),
       (EXFLOOR, "Floor"),
       (EXINTERRUPT, "Interrupt"),
       (EXIO, "Io"),
       (EXLN, "Ln"),
       (EXMATCH, "Match"),
       (EXMOD, "Mod"),
       (EXNEG, "Neg"),
       (EXORD, "Ord"),
       (EXPROD, "Prod"),
       (EXQUOT, "Quot"),
       (EXSQRT, "Sqrt"),
       (EXSUM, "Sum"),
       (EXSIZE,"Size"),
       (EXSUBSCRIPT,"Subscript")]
a465 7
    val structure_name_list = []

    (* Sort the lists of pervasives with names in to the order in which they *)
    (* will be found in the actual PervasiveLibrary_ structure.  This is the *)
    (* same order as is generated by the lambda translator, and is: *)
    (* sorted values, sorted exceptions, sorted structures. *)

d467 2
a468 2

  val library_contents =
d481 1
a481 1
  fun find_repeats [] exceptions = ()
d490 1
a490 2
        if Lists.member(h,values)
          then check_found t values
a497 3
    val all = (map #1 value_name_list) @@ (map #1 exception_name_list) 
      @@ (map #1 constructor_name_list)

d501 1
a501 3
      val _ = find_repeats (#1 to_be_checked)
      val _ = find_repeats (#2 to_be_checked)
      val _ = check_found (#2 to_be_checked) (#1 to_be_checked)
d503 3
d507 11
a705 107
      fun sort REF = 0
	| sort EXABS = 1
	| sort EXORD = 2
	| sort EXCHR = 3
	| sort EXDIV = 4
	| sort EXMOD = 5
	| sort EXQUOT = 6
	| sort EXPROD = 7
	| sort EXNEG = 8
	| sort EXSUM = 9
	| sort EXDIFF = 10
	| sort EXFLOOR = 11
	| sort EXSQRT = 12
	| sort EXEXP = 13
	| sort EXLN = 14
	| sort EXIO = 15
	| sort EXMATCH = 16
	| sort EXBIND = 17
	| sort EXINTERRUPT = 18
	| sort MAP = 19
	| sort REV = 20
	| sort NOT = 21
	| sort ABS = 22
	| sort FLOOR = 23
	| sort REAL = 24
	| sort SQRT = 25
	| sort SIN = 26
	| sort COS = 27
	| sort ARCTAN = 28
	| sort EXP = 29
	| sort LN = 30
	| sort SIZE = 31
	| sort CHR = 32
	| sort ORD = 33
	| sort EXPLODE = 34
	| sort IMPLODE = 35
	| sort DEREF = 36
	| sort FDIV = 37
	| sort DIV = 38
	| sort MOD = 39
	| sort PLUS = 40
	| sort STAR = 41
	| sort MINUS = 42
	| sort HAT = 43
	| sort AT = 44
	| sort NE = 45
	| sort LESS = 46
	| sort GREATER = 47
	| sort LESSEQ = 48
	| sort GREATEREQ = 49
	| sort BECOMES = 50
	| sort O = 51
	| sort UMINUS = 52
	| sort EQ = 53
	| sort LOAD_STRING = 65
	| sort REALPLUS = 66
	| sort INTPLUS = 67
	| sort REALSTAR = 68
	| sort INTSTAR = 69
	| sort REALMINUS = 70
	| sort INTMINUS = 71
	| sort REALUMINUS = 72
	| sort INTUMINUS = 73
	| sort INTLESS = 74
	| sort REALLESS = 75
	| sort INTGREATER = 76
	| sort REALGREATER = 77
	| sort INTLESSEQ = 78
	| sort REALLESSEQ = 79
	| sort INTGREATEREQ = 80
	| sort REALGREATEREQ = 81
	| sort INTEQ = 82
	| sort INTNE = 83
	| sort REALEQ = 84
	| sort REALNE = 85
	| sort STRINGEQ = 86
	| sort STRINGNE = 87
	| sort INTABS = 88
	| sort REALABS = 89
	| sort CALL_C = 90
	| sort EXABSVAL = 92
	| sort EXORDVAL = 93
	| sort EXCHRVAL = 94
	| sort EXDIVVAL = 95
	| sort EXMODVAL = 96
	| sort EXQUOTVAL = 97
	| sort EXPRODVAL = 98
	| sort EXNEGVAL = 99
	| sort EXSUMVAL = 100
	| sort EXDIFFVAL = 101
	| sort EXFLOORVAL = 102
	| sort EXSQRTVAL = 103
	| sort EXEXPVAL = 104
	| sort EXLNVAL = 105
	| sort EXIOVAL = 106
	| sort EXMATCHVAL = 107
	| sort EXBINDVAL = 108
	| sort EXINTERRUPTVAL = 109
	| sort ARRAY_FN = 112
	| sort LENGTH = 114
	| sort SUB  = 115
	| sort UPDATE = 117
	| sort EXSIZE = 118
	| sort EXSUBSCRIPT = 119
        | sort EXSIZEVAL = 120
        | sort EXSUBSCRIPTVAL = 121
        | sort EQFUN = 122
d707 7
a713 8
      local
        fun test x [] = Crash.impossible ("de sort cockup" ^ makestring x)
          | test x (h::t) = if sort h = x 
                              then h
                            else test x t
      in
        fun de_sort x = test x all
      end
d715 110
d826 6
a831 4
  fun order (pervasive, pervasive') =
    let


d833 5
a837 1
      (sort pervasive) < (sort pervasive')
d840 4
@


1.18
log
@Incorrectly used exsize instead of exsizeval in implicit_references
@
text
@d4 3
d178 1
d286 1
d348 1
a348 1
       (EQ,"equality"),
d548 1
a548 2
   *  NOTE: At the moment only a single exception should be generated here.
   *        The MIR code generator assumes this.
d573 1
d649 1
d791 1
@


1.17
log
@New pervasive library code
@
text
@d4 3
d566 3
a568 3
    | implicit_references ARRAY_FN   = [EXSIZE]
    | implicit_references SUB        = [EXSUBSCRIPT]
    | implicit_references UPDATE     = [EXSUBSCRIPT]
@


1.16
log
@Array problems - the structure was missing
@
text
@d4 3
a171 10
    STD_IN |
    STD_OUT |
    OPEN_IN |
    OPEN_OUT |
    INPUT |
    LOOKAHEAD |
    CLOSE_IN |
    END_OF_STREAM |
    OUTPUT |
    CLOSE_OUT |
a197 4
    SYSTEM |
    SUBSTRING |

    ARRAY |
a198 1
    ARRAY_OF_LIST |
a200 1
    TABULATE |
a278 10
    | print_pervasive STD_IN = "std_in"
    | print_pervasive STD_OUT = "std_out"
    | print_pervasive OPEN_IN = "open_in"
    | print_pervasive OPEN_OUT = "open_out"
    | print_pervasive INPUT = "input"
    | print_pervasive LOOKAHEAD = "lookahead"
    | print_pervasive CLOSE_IN = "close_in"
    | print_pervasive END_OF_STREAM = "end_of_stream"
    | print_pervasive OUTPUT = "output"
    | print_pervasive CLOSE_OUT = "close_out"
a304 3
    | print_pervasive SYSTEM = "System"
    | print_pervasive SUBSTRING = "substring"
    | print_pervasive ARRAY = "Array"
a305 1
    | print_pervasive ARRAY_OF_LIST = "arrayoflist"
a307 1
    | print_pervasive TABULATE = "tabulate"
a323 1
  local
d336 2
d339 12
a350 1
      [(AT, "append"),
d353 1
a353 2
       (CLOSE_IN, "close_in"),
       (HAT, "concatenate"),
a354 2
       (END_OF_STREAM, "end_of_stream"),
       (EQ, "equal"),
d360 1
a360 1
       (EXEXPVAL, "ExpVAL"),
a375 1
       (INPUT, "input"),
a376 1
       (DIV, "int_divide"),
d388 2
a389 2
       (LOAD_STRING, "load_string"),
       (LOOKAHEAD, "lookahead"),
d391 2
a392 4
       (MOD, "modulo"),
       (CLOSE_OUT, "close_out"),
       (O, "compose"),
       (NE, "not_equal"),
a393 2
       (OPEN_IN, "open_in"),
       (OPEN_OUT, "open_out"),
a394 1
       (OUTPUT, "output"),
a395 1
       (FDIV, "real_divide"),
a409 2
       (STD_IN, "std_in"),
       (STD_OUT, "std_out"),
a411 3
       (SUBSTRING, "substring"),
       (TABULATE,"tabulate"),
       (ARRAY_OF_LIST,"arrayoflist"),
d413 2
a414 1
       (EXSUBSCRIPTVAL,"Subscript")]
d438 1
a438 3
    val structure_name_list = 
      [(ARRAY, "Array"),
       (SYSTEM, "System")]
d445 3
a447 1
    val library_contents =
d460 14
d476 13
a640 10
    | is_fun STD_IN = false
    | is_fun STD_OUT = false
    | is_fun OPEN_IN = true
    | is_fun OPEN_OUT = true
    | is_fun INPUT = true
    | is_fun LOOKAHEAD = true
    | is_fun CLOSE_IN = true
    | is_fun END_OF_STREAM = true
    | is_fun OUTPUT = true
    | is_fun CLOSE_OUT = true
a666 3
    | is_fun SYSTEM = false
    | is_fun SUBSTRING = true
    | is_fun ARRAY = false
a667 1
    | is_fun ARRAY_OF_LIST = true
a669 1
    | is_fun TABULATE = true
a675 4

  fun order (pervasive, pervasive') =
    let

a729 10
	| sort STD_IN = 54
	| sort STD_OUT = 55
	| sort OPEN_IN = 56
	| sort OPEN_OUT = 57
	| sort INPUT = 58
	| sort LOOKAHEAD = 59
	| sort CLOSE_IN = 60
	| sort END_OF_STREAM = 61
	| sort OUTPUT = 62
	| sort CLOSE_OUT = 63
a755 1
	| sort SYSTEM = 91
a773 2
        | sort SUBSTRING = 110
	| sort ARRAY = 111
a774 1
	| sort ARRAY_OF_LIST = 113
a776 1
	| sort TABULATE = 116
d782 14
@


1.15
log
@Fixed inexhaustive/redundant match problem
@
text
@d4 3
d469 3
a471 1
    val structure_name_list = []
@


1.14
log
@Added the EXSUBSCRIPTVAL and EXSIZEVAL
@
text
@d4 3
d336 2
a337 2
    | print_pervasive EXSIZE = "Size"
    | print_pervasive EXSUBSCRIPT = "Subscript"
@


1.13
log
@Added arrays to the initial basis
@
text
@d4 3
d210 3
a212 1
    EXSUBSCRIPT
d331 2
d437 3
a439 1
       (ARRAY_OF_LIST,"arrayoflist")]
d684 2
d810 2
@


1.12
log
@Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.
@
text
@d4 4
d197 1
a197 1
    SUBSTRING
d199 10
d319 10
a328 3



d428 3
a430 1
       (SUBSTRING, "substring")]
d450 3
a452 1
       (EXSUM, "Sum")]
d550 3
d666 9
d790 9
d806 1
@


1.11
log
@Changed the implicit references to exception values rather than
exception names.  See corresponding change in _mir_cg.
@
text
@d3 5
a7 1
$Log:	_pervasives.sml,v $
d192 2
a193 1
    SYSTEM
d304 1
d406 2
a407 1
       (STRINGNE, "string_not_equal")]
d636 2
a637 1
    | is_fun SYSTEM = true
d752 1
@


1.10
log
@ Separated exception values from exception names.
@
text
@d4 3
d494 3
d499 19
a517 18
  fun implicit_references INTPLUS    = [EXSUM]
    | implicit_references INTSTAR    = [EXPROD]
    | implicit_references INTMINUS   = [EXDIFF]
    | implicit_references INTUMINUS  = [EXNEG]
    | implicit_references INTABS     = [EXABS]
    | implicit_references REALPLUS   = [EXSUM]
    | implicit_references REALSTAR   = [EXPROD]
    | implicit_references REALMINUS  = [EXDIFF]
    | implicit_references REALUMINUS = [EXNEG]
    | implicit_references DIV        = [EXQUOT]
    | implicit_references MOD        = [EXMOD]
    | implicit_references REALABS    = [EXABS]
    | implicit_references FLOOR      = [EXFLOOR]
    | implicit_references SQRT       = [EXSQRT]
    | implicit_references EXP        = [EXEXP]
    | implicit_references LN         = [EXLN]
    | implicit_references ORD        = [EXORD]
    | implicit_references CHR        = [EXCHR]
d554 1
a554 1
    | is_fun EXIOVAL = false
@


1.9
log
@Added the EQ (equal) and NE (not equal) pervasives to the
pervasive library.
@
text
@d4 4
d72 4
d96 18
d188 36
a223 18
    | print_pervasive EXABS = "Abs"
    | print_pervasive EXORD = "Ord"
    | print_pervasive EXCHR = "Chr"
    | print_pervasive EXDIV = "Div"
    | print_pervasive EXMOD = "Mod"
    | print_pervasive EXQUOT = "Quot"
    | print_pervasive EXPROD = "Prod"
    | print_pervasive EXNEG = "Neg"
    | print_pervasive EXSUM = "Sum"
    | print_pervasive EXDIFF = "Diff"
    | print_pervasive EXFLOOR = "Floor"
    | print_pervasive EXSQRT = "Sqrt"
    | print_pervasive EXEXP = "Exp"
    | print_pervasive EXLN = "Ln"
    | print_pervasive EXIO = "Io"
    | print_pervasive EXMATCH = "Match"
    | print_pervasive EXBIND = "Bind"
    | print_pervasive EXINTERRUPT = "Interrupt"
d317 3
a319 2
     *    Any changes to ../rts/pervasive_library.sml must be reflected
     *    here.
d331 18
d424 1
a424 1
    (* sorted exceptions and values, sorted exceptions, sorted structures. *)
d434 2
a435 3
	(make_sorted (exception_name_list @@ value_name_list,
		      Ident.VAR, Ident.valid_order)) @@
	(make_sorted (exception_name_list, Ident.VAR, Ident.valid_order)) @@
d533 18
d719 18
@


1.8
log
@Reworked those parts of the module concerned with the pervasive library.
This module can now provide the field numbers within the library of the
pervasives directly.  Also implemented an ordering on pervasives and
removed the MAKE_NEW_UNIQUE pervasive.
@
text
@d4 6
d285 1
d309 1
@


1.7
log
@Changed the library name of mod to modulo so that it doesn't
clash with the pervasive name when compiling.  This makes it
easier to define.
@
text
@d4 5
d35 7
d44 12
a55 1
functor Pervasives(
d57 1
d59 3
a126 1
    MAKE_NEW_UNIQUE |
d156 90
a245 91
  | print_pervasive EXABS = "Abs"
  | print_pervasive EXORD = "Ord"
  | print_pervasive EXCHR = "Chr"
  | print_pervasive EXDIV = "Div"
  | print_pervasive EXMOD = "Mod"
  | print_pervasive EXQUOT = "Quot"
  | print_pervasive EXPROD = "Prod"
  | print_pervasive EXNEG = "Neg"
  | print_pervasive EXSUM = "Sum"
  | print_pervasive EXDIFF = "Diff"
  | print_pervasive EXFLOOR = "Floor"
  | print_pervasive EXSQRT = "Sqrt"
  | print_pervasive EXEXP = "Exp"
  | print_pervasive EXLN = "Ln"
  | print_pervasive EXIO = "Io"
  | print_pervasive EXMATCH = "Match"
  | print_pervasive EXBIND = "Bind"
  | print_pervasive EXINTERRUPT = "Interrupt"
  | print_pervasive MAP = "map"
  | print_pervasive REV = "rev"
  | print_pervasive NOT = "not"
  | print_pervasive ABS = "abs"
  | print_pervasive FLOOR = "floor"
  | print_pervasive REAL = "real"
  | print_pervasive SQRT = "sqrt"
  | print_pervasive SIN = "sin"
  | print_pervasive COS = "cos"
  | print_pervasive ARCTAN = "arctan"
  | print_pervasive EXP = "exp"
  | print_pervasive LN = "ln"
  | print_pervasive SIZE = "size"
  | print_pervasive CHR = "chr"
  | print_pervasive ORD = "ord"
  | print_pervasive EXPLODE = "explode"
  | print_pervasive IMPLODE = "implode"
  | print_pervasive DEREF = "!"
  | print_pervasive FDIV = "/"
  | print_pervasive DIV = "div"
  | print_pervasive MOD = "mod"
  | print_pervasive PLUS = "+"
  | print_pervasive STAR = "*"
  | print_pervasive MINUS = "-"
  | print_pervasive HAT = "^"
  | print_pervasive AT = "@@"
  | print_pervasive NE = "<>"
  | print_pervasive LESS = "<"
  | print_pervasive GREATER = ">"
  | print_pervasive LESSEQ = "<="
  | print_pervasive GREATEREQ = ">="
  | print_pervasive BECOMES = "becomes"
  | print_pervasive O = "o"
  | print_pervasive UMINUS = "~"
  | print_pervasive EQ = "="
  | print_pervasive STD_IN = "std_in"
  | print_pervasive STD_OUT = "std_out"
  | print_pervasive OPEN_IN = "open_in"
  | print_pervasive OPEN_OUT = "open_out"
  | print_pervasive INPUT = "input"
  | print_pervasive LOOKAHEAD = "lookahead"
  | print_pervasive CLOSE_IN = "close_in"
  | print_pervasive END_OF_STREAM = "end_of_stream"
  | print_pervasive OUTPUT = "output"
  | print_pervasive CLOSE_OUT = "close_out"
  | print_pervasive MAKE_NEW_UNIQUE = "make_new_unique"
  | print_pervasive LOAD_STRING = "load_string"
  | print_pervasive REALPLUS = "_real+"
  | print_pervasive INTPLUS = "_int+"
  | print_pervasive REALSTAR = "_real*"
  | print_pervasive INTSTAR = "_int*"
  | print_pervasive REALMINUS = "_real-"
  | print_pervasive INTMINUS = "_int-"
  | print_pervasive REALUMINUS = "_real~"
  | print_pervasive INTUMINUS = "_int~"
  | print_pervasive INTLESS = "_int<"
  | print_pervasive REALLESS = "_real<"
  | print_pervasive INTGREATER = "_int>"
  | print_pervasive REALGREATER = "_real>"
  | print_pervasive INTLESSEQ = "_int<="
  | print_pervasive REALLESSEQ = "_real<="
  | print_pervasive INTGREATEREQ = "_int>="
  | print_pervasive REALGREATEREQ = "_real>="
  | print_pervasive INTEQ = "_int="
  | print_pervasive INTNE = "_int<>"
  | print_pervasive REALEQ = "_real="
  | print_pervasive REALNE = "_real<>"
  | print_pervasive STRINGEQ = "_string="
  | print_pervasive STRINGNE = "_string<>"
  | print_pervasive INTABS = "_intabs"
  | print_pervasive REALABS = "realabs"
  | print_pervasive CALL_C = "call_c"
  | print_pervasive SYSTEM = "System"
d247 196
a442 92
fun library_name EXABS		= "Abs"
  | library_name EXBIND		= "Bind"
  | library_name EXCHR		= "Chr"
  | library_name EXDIFF		= "Diff"
  | library_name EXDIV		= "Div"
  | library_name EXEXP		= "Exp"
  | library_name EXFLOOR	= "Floor"
  | library_name EXINTERRUPT	= "Interrupt"
  | library_name EXIO		= "Io"
  | library_name EXLN		= "Ln"
  | library_name EXMATCH	= "Match"
  | library_name EXMOD		= "Mod"
  | library_name EXNEG		= "Neg"
  | library_name EXORD		= "Ord"
  | library_name EXPROD		= "Prod"
  | library_name EXQUOT		= "Quot"
  | library_name EXSQRT		= "Sqrt"
  | library_name EXSUM		= "Sum"
  | library_name SYSTEM		= "System"
  | library_name ABS		= "abs"
  | library_name AT		= "append"
  | library_name ARCTAN		= "arctan"
  | library_name BECOMES	= "becomes"
  | library_name CALL_C		= "call_c"
  | library_name CHR		= "chr"
  | library_name CLOSE_IN	= "close_in"
  | library_name CLOSE_OUT	= "close_out"
  | library_name O		= "compose"
  | library_name HAT		= "concatenate"
  | library_name COS		= "cos"
  | library_name DEREF		= "dereference"
  | library_name END_OF_STREAM	= "end_of_stream"
  | library_name EQ		= "equal"
  | library_name EXP		= "exp"
  | library_name EXPLODE	= "explode"
  | library_name FLOOR		= "floor"
  | library_name GREATER	= "greater"
  | library_name GREATEREQ	= "greater_or_equal"
  | library_name IMPLODE	= "implode"
  | library_name INPUT		= "input"
  | library_name INTABS		= "int_abs"
  | library_name DIV		= "int_divide"
  | library_name INTEQ		= "int_equal"
  | library_name INTGREATER	= "int_greater"
  | library_name INTGREATEREQ	= "int_greater_or_equal"
  | library_name INTLESS	= "int_less"
  | library_name INTLESSEQ	= "int_less_or_equal"
  | library_name INTMINUS	= "int_minus"
  | library_name INTSTAR	= "int_multiply"
  | library_name INTUMINUS	= "int_negate"
  | library_name INTNE		= "int_not_equal"
  | library_name INTPLUS	= "int_plus"
  | library_name LESS		= "less"
  | library_name LESSEQ		= "less_or_equal"
  | library_name LN		= "ln"
  | library_name LOAD_STRING	= "load_string"
  | library_name LOOKAHEAD	= "lookahead"
  | library_name MAKE_NEW_UNIQUE= "make_new_unique"
  | library_name MAP		= "map"
  | library_name MINUS		= "minus"
  | library_name MOD		= "modulo"
  | library_name STAR		= "multiply"
  | library_name UMINUS		= "negate"
  | library_name NOT		= "not"
  | library_name NE		= "not_equal"
  | library_name OPEN_IN	= "open_in"
  | library_name OPEN_OUT	= "open_out"
  | library_name ORD		= "ord"
  | library_name OUTPUT		= "output"
  | library_name PLUS		= "plus"
  | library_name REAL		= "real"
  | library_name REALABS	= "real_abs"
  | library_name FDIV		= "real_divide"
  | library_name REALEQ		= "real_equal"
  | library_name REALGREATER	= "real_greater"
  | library_name REALGREATEREQ	= "real_greater_or_equal"
  | library_name REALLESS	= "real_less"
  | library_name REALLESSEQ	= "real_less_or_equal"
  | library_name REALMINUS	= "real_minus"
  | library_name REALSTAR	= "real_multiply"
  | library_name REALUMINUS	= "real_negate"
  | library_name REALNE		= "real_not_equal"
  | library_name REALPLUS	= "real_plus"
  | library_name REF		= "ref"
  | library_name REV		= "rev"
  | library_name SIN		= "sin"
  | library_name SIZE		= "size"
  | library_name SQRT		= "sqrt"
  | library_name STD_IN		= "std_in"
  | library_name STD_OUT	= "std_out"
  | library_name STRINGEQ	= "string_equal"
  | library_name STRINGNE	= "string_not_equal"
d445 192
a636 91
  | is_fun EXABS = false
  | is_fun EXORD = false
  | is_fun EXCHR = false
  | is_fun EXDIV = false
  | is_fun EXMOD = false
  | is_fun EXQUOT = false
  | is_fun EXPROD = false
  | is_fun EXNEG = false
  | is_fun EXSUM = false
  | is_fun EXDIFF = false
  | is_fun EXFLOOR = false
  | is_fun EXSQRT = false
  | is_fun EXEXP = false
  | is_fun EXLN = false
  | is_fun EXIO = false
  | is_fun EXMATCH = false
  | is_fun EXBIND = false
  | is_fun EXINTERRUPT = false
  | is_fun MAP = true
  | is_fun REV = true
  | is_fun NOT = true
  | is_fun ABS = true
  | is_fun FLOOR = true
  | is_fun REAL = true
  | is_fun SQRT = true
  | is_fun SIN = true
  | is_fun COS = true
  | is_fun ARCTAN = true
  | is_fun EXP = true
  | is_fun LN = true
  | is_fun SIZE = true
  | is_fun CHR = true
  | is_fun ORD = true
  | is_fun EXPLODE = true
  | is_fun IMPLODE = true
  | is_fun DEREF = true
  | is_fun FDIV = true
  | is_fun DIV = true
  | is_fun MOD = true
  | is_fun PLUS = false
  | is_fun STAR = false
  | is_fun MINUS = false
  | is_fun HAT = true
  | is_fun AT = true
  | is_fun NE = true
  | is_fun LESS = false
  | is_fun GREATER = false
  | is_fun LESSEQ = false
  | is_fun GREATEREQ = false
  | is_fun BECOMES = true
  | is_fun O = true
  | is_fun UMINUS = false
  | is_fun EQ = true
  | is_fun STD_IN = false
  | is_fun STD_OUT = false
  | is_fun OPEN_IN = true
  | is_fun OPEN_OUT = true
  | is_fun INPUT = true
  | is_fun LOOKAHEAD = true
  | is_fun CLOSE_IN = true
  | is_fun END_OF_STREAM = true
  | is_fun OUTPUT = true
  | is_fun CLOSE_OUT = true
  | is_fun MAKE_NEW_UNIQUE = true
  | is_fun LOAD_STRING = false
  | is_fun REALPLUS = true
  | is_fun INTPLUS = true
  | is_fun REALSTAR = true
  | is_fun INTSTAR = true
  | is_fun REALMINUS = true
  | is_fun INTMINUS = true
  | is_fun REALUMINUS = true
  | is_fun INTUMINUS = true
  | is_fun INTLESS = true
  | is_fun REALLESS = true
  | is_fun INTGREATER = true
  | is_fun REALGREATER = true
  | is_fun INTLESSEQ = true
  | is_fun REALLESSEQ = true
  | is_fun INTGREATEREQ = true
  | is_fun REALGREATEREQ = true
  | is_fun INTEQ = true
  | is_fun INTNE = true
  | is_fun REALEQ = true
  | is_fun REALNE = true
  | is_fun STRINGEQ = true
  | is_fun STRINGNE = true
  | is_fun INTABS = true
  | is_fun REALABS = true
  | is_fun CALL_C = true
  | is_fun SYSTEM = true
@


1.6
log
@Added library_name to map pervasives on to their names in the library
module.
@
text
@d4 4
d282 1
a282 1
  | library_name MOD		= "mod"
@


1.5
log
@Added is_fun to determine if pervasives are functions, and hence can
be eta_abstracted during compilation.
@
text
@d4 4
d218 93
@


1.4
log
@Added CALL_C and SYSTEM pervasives.
@
text
@d4 3
d213 93
@


1.3
log
@Added CALL_C
@
text
@d4 3
d115 2
a116 1
    CALL_C
d209 1
@


1.2
log
@Corrected spelling of UNIQUE (!)
@
text
@d4 3
d111 2
a112 1
    REALABS
d204 1
@


1.1
log
@Initial revision
@
text
@d3 7
a9 1
$Log$
d83 1
a83 1
    MAKE_NEW_UNQIUE |
d174 1
a174 1
  | print_pervasive MAKE_NEW_UNQIUE = "make_new_unqiue"
@
