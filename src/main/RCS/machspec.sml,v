head	1.19;
access;
symbols
	MLW_daveb_inline_1_4_99:1.19.1
	MLWorks_21c0_1999_03_25:1.19
	MLWorks_20c1_1998_08_20:1.18
	MLWorks_20c0_1998_08_04:1.18
	MLWorks_20b2c2_1998_06_19:1.18
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.18
	MLWorks_20b0_1998_04_07:1.18
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.18
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.15.1.1.1.1.1
	MLWorks_workspace_97:1.18.2
	MLWorks_dt_wizard:1.18.1
	MLWorks_11c0_1997_09_09:1.15.1.1.1.1
	MLWorks_10r3:1.15.1.1.3
	MLWorks_10r2_551:1.15.1.1.2
	MLWorks_11:1.15.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.1.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.15.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.1
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.12.6.1.1
	MLWorks_gui_1996_12_18:1.12.7
	MLWorks_1_0_Win32_1996_12_17:1.12.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.12.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.12.4.1
	MLWorks_1_0_Irix_1996_11_28:1.12.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.12.5
	MLWorks_1_0_Unix_1996_11_14:1.12.4
	MLWorks_Open_Beta2_1996_10_11:1.12.3
	MLWorks_License_dev:1.12.2
	MLWorks_1_open_beta_1996_09_13:1.12.1
	MLWorks_Open_Beta_1996_08_22:1.12
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.12
	MLWorks_Beta_1996_06_06:1.12
	MLWorks_Beta_1996_06_05:1.12
	MLWorks_Beta_1996_06_03:1.12
	MLWorks_Beta_1996_05_31:1.12
	MLWorks_Beta_1996_05_30:1.12
	ML_beta_release_12/08/94:1.4
	ML_beta_release_03/08/94:1.4
	ML_revised_beta_release_25/05/94:1.3;
locks; strict;
comment	@ * @;


1.19
date	98.08.27.12.13.11;	author jont;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	97.05.13.13.35.42;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1;
next	1.17;

1.17
date	97.05.01.12.44.14;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	97.04.18.12.58.15;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	97.03.25.10.21.48;	author matthew;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	97.01.16.16.59.16;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.12.03.14.02.09;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.12.20.12.47.15;	author jont;	state Exp;
branches
	1.12.1.1
	1.12.2.1
	1.12.3.1
	1.12.4.1
	1.12.5.1
	1.12.6.1
	1.12.7.1;
next	1.11;

1.11
date	95.08.14.11.48.48;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.07.25.10.21.30;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.05.30.12.52.40;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	94.11.11.13.56.45;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.09.21.16.06.11;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.09.15.17.52.06;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.07.29.11.27.50;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.07.25.11.43.00;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.05.10.14.46.37;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.03.08.17.23.54;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.03.04.17.24.54;	author jont;	state Exp;
branches;
next	;

1.12.1.1
date	96.09.13.11.18.03;	author hope;	state Exp;
branches;
next	;

1.12.2.1
date	96.10.07.16.07.54;	author hope;	state Exp;
branches;
next	;

1.12.3.1
date	96.10.17.11.26.09;	author hope;	state Exp;
branches;
next	;

1.12.4.1
date	96.11.14.12.51.24;	author hope;	state Exp;
branches
	1.12.4.1.1.1;
next	;

1.12.4.1.1.1
date	96.11.28.15.02.28;	author hope;	state Exp;
branches;
next	;

1.12.5.1
date	96.11.22.18.10.37;	author hope;	state Exp;
branches;
next	;

1.12.6.1
date	96.12.17.17.49.13;	author hope;	state Exp;
branches
	1.12.6.1.1.1;
next	;

1.12.6.1.1.1
date	97.02.24.11.39.19;	author hope;	state Exp;
branches;
next	;

1.12.7.1
date	96.12.18.09.43.17;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	97.05.12.10.35.46;	author hope;	state Exp;
branches
	1.15.1.1.1.1
	1.15.1.1.2.1
	1.15.1.1.3.1;
next	;

1.15.1.1.1.1
date	97.07.28.18.21.28;	author daveb;	state Exp;
branches
	1.15.1.1.1.1.1.1;
next	;

1.15.1.1.1.1.1.1
date	97.10.07.11.47.03;	author jkbrook;	state Exp;
branches;
next	;

1.15.1.1.2.1
date	97.09.08.17.14.53;	author daveb;	state Exp;
branches;
next	;

1.15.1.1.3.1
date	97.09.09.14.10.45;	author daveb;	state Exp;
branches;
next	;

1.18.1.1
date	97.09.10.19.26.46;	author brucem;	state Exp;
branches;
next	;

1.18.2.1
date	97.09.11.20.56.44;	author daveb;	state Exp;
branches;
next	;

1.19.1.1
date	99.04.01.17.57.42;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.19
log
@[Bug #70040]
Modify register colourer to use stack colourer only if requested from machspec
@
text
@(*   ==== MACHINE SPECIFICATION ====
 *             SIGNATURE
 *
 * Copyright (C) 1991 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module contains all the information necessary to generate MIR code
 * suitable for the machine code generator.  For example, it specifies the
 * register model and which pervasives can be generated as in-line code.
 * Inlining of pervasives now moved to machperv
 *
 * Revision Log
 * ------------
 * $Log: machspec.sml,v $
 * Revision 1.18  1997/05/13  13:35:42  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
 * Revision 1.17  1997/05/01  12:44:14  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.16  1997/04/18  12:58:15  jont
 * [Bug #20007]
 * [Bug #20007]
 * Adding reserved_but_preferencable registers
 *
 * Revision 1.15  1997/03/25  10:21:48  matthew
 * Adding mach_type value
 *
 * Revision 1.14  1997/01/16  16:59:16  jont
 * Add in corrupted_by_alloc and leaf_regs
 *
 * Revision 1.13  1996/12/03  14:02:09  matthew
 * Addin fp_arg_regs
 *
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
 * Revision 1.11  1995/08/14  11:48:48  jont
 * Add bits_per_word to backend specification
 *
 * Revision 1.10  1995/07/25  10:21:30  jont
 * Add largest_word machine limit
 *
 * Revision 1.9  1995/05/30  12:52:40  matthew
 * Adding debugger_reserved register set
 *
 * Revision 1.8  1994/11/11  13:56:45  jont
 * Add has_immediate_store flag
 *
 * Revision 1.7  1994/09/21  16:06:11  jont
 * Add do_unspill value to control register allocator
 *
 * Revision 1.6  1994/09/15  17:52:06  jont
 * Add chr and ord to signature
 * Also add Chr and Ord
 *
 * Revision 1.5  1994/07/29  11:27:50  matthew
 * More work on multiple argument passing
 *
 * Revision 1.4  1994/07/25  11:43:00  matthew
 * Adding extra arg register
 *
 * Revision 1.3  1994/05/10  14:46:37  jont
 * Remove lr, gc1, gc2, stack_limit from register interface
 *
 * Revision 1.2  1994/03/08  17:23:54  jont
 * Move digits_in_real here
 *
 * Revision 1.1  1994/03/04  17:24:54  jont
 * new file
 *
 * Revision 1.21  1993/05/28  14:42:01  nosa
 * Changed Option.T to Option.opt.
 *
 * Revision 1.20  1992/11/21  19:33:07  jont
 * Removed is_inline to machperv in order to remove dependence of entire
 * mir stage on pervasives
 *
 * Revision 1.19  1992/10/02  17:02:08  clive
 * Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 * Revision 1.18  1992/06/08  15:21:17  richard
 * Added allocation_order.
 *
 * Revision 1.17  1992/06/03  16:27:49  richard
 * The reserved registers are now complete sets rather than a list
 * of preferences.
 *
 * Revision 1.16  1992/04/07  10:11:10  richard
 * Partitioned corrupted_by_callee according to register type to
 * avoid naming clashes.
 *
 * Revision 1.15  1992/02/06  10:55:52  richard
 * Added `temporary'.
 *
 * Revision 1.14  1992/01/07  09:17:03  clive
 * Added stack limit register definitions
 *
 * Revision 1.13  1992/01/03  15:44:00  richard
 * Added the zero register.
 *
 * Revision 1.12  1991/12/04  13:08:29  richard
 * Tidied up the documentation.
 *
 * Revision 1.11  91/11/29  11:47:12  richard
 * Added `reserved' to prevent register allocation from very special
 * registers.
 * 
 * Revision 1.10  91/11/25  15:33:05  jont
 * Added fp_global as a temporary for conversions from fp to int
 * 
 * Revision 1.9  91/11/14  10:56:54  richard
 * Removed references to fp_double registers.
 * 
 * Revision 1.8  91/11/12  16:54:28  jont
 * Added is_inline function to the signature
 * 
 * Revision 1.7  91/10/29  14:16:08  jont
 * Added values indicating existence on machin level multiply, divide
 * and modulus
 * 
 * Revision 1.6  91/10/24  15:29:01  davidt
 * Now knows about the `implicit' register.
 * 
 * Revision 1.5  91/10/15  15:14:58  richard
 * Changed corrupted_by_callee to a set rather than a list.
 * 
 * Revision 1.4  91/10/14  14:31:33  richard
 * Added corrupted_by_callee.
 * 
 * Revision 1.3  91/10/10  14:28:50  richard
 * indicates allocation preferences. after_preserve and after_restore
 * discarded.
 * 
 * Revision 1.2  91/10/09  14:27:05  richard
 * Added some new register definitions
 * 
 * Revision 1.1  91/10/07  11:22:56  richard
 * Initial revision
 *)


require "../utils/set";

signature MACHSPEC =

  sig

    structure Set	 : SET

    (* === What sort of machine is it? === *)

    datatype MachType = SPARC | MIPS | I386

    val mach_type : MachType

    (*  === MACHINE REGISTERS ===  *)

    eqtype register


    (*  == General registers ==
     *
     *  These are the general purpose allocatable registers for the
     *  different types of virtual register.  The order is significant:
     *  earlier registers should be used in preference to later ones.
     *
     *  gcs:		int/ptr visible to garbage collector
     *  non_gcs:	int/ptr not visible to garbage collector
     *  fps:		floating point registers
     *)

    val gcs		: register list
    val non_gcs		: register list
    val fps		: register list


    (*  == Special purpose reserved registers ==  *)

    val caller_arg 	: register	(* function argument from caller *)
    val callee_arg	: register 	(* ditto to callees (may be same) *)
    val caller_arg_regs : register list
    val callee_arg_regs	: register list
    val caller_closure	: register	(* closure pointer from caller *)
    val callee_closure	: register	(* ditto to callees (may be same) *)
    val fp_arg_regs     : register list
    val fp		: register	(* frame pointer *)
    val sp		: register	(* stack pointer *)
    val handler		: register	(* pointer to exception handler code *)
    val global		: register	(* not affected by PRESERVE/RESTORE *)
    val fp_global	: register	(* spare for fp temporaries *)
    val implicit	: register	(* Always holds the implicit vector *)
    val zero		: register option
    					(* Register which is always zero *)

    val tail_arg        : register      (* Where to put the arg for a tail call *)
    val tail_closure    : register      (* Where to out the closure for a tail call *)

    (*  == Calling conventions ==  *)

    val corrupted_by_callee : {gc     : register Set.Set,
                               non_gc : register Set.Set,
                               fp     : register Set.Set}


    val corrupted_by_alloc :  {gc     : register Set.Set,
                               non_gc : register Set.Set,
                               fp     : register Set.Set}

    val referenced_by_alloc : {gc     : register Set.Set,
                               non_gc : register Set.Set,
                               fp     : register Set.Set}

    val defined_on_entry :    {gc     : register Set.Set,
                               non_gc : register Set.Set,
                               fp     : register Set.Set}

    (*  == Reserved registers ==
     *
     *  These can never be used for anything except their special purpose,
     *  they can't even be temporarily spilled.
     *)

    val reserved : {gc : register Set.Set, non_gc : register Set.Set, fp : register Set.Set}
    (* and another set of reserved registers for when we want debuggable code *)
    val debugging_reserved : {gc : register Set.Set, non_gc : register Set.Set, fp : register Set.Set}
    val reserved_but_preferencable : {gc : register list, non_gc : register list, fp : register list}
    (* and another set of reserved registers for when we want debuggable code *)
    val debugging_reserved_but_preferencable : {gc : register list, non_gc : register list, fp : register list}


    (*  == Temporary registers ==
     *
     *  These are the recommended registers to use for temporaries when
     *  spilling.  They are in order of preference.
     *)

    val temporary : {gc     : register list,
                     non_gc : register list,
                     fp     : register list}


    (*  == Allocation order ==
     *
     *  Given two registers this determines the order in which they should
     *  be allocated.  If LESS the first should be allocated in preference
     *  to the second, the other way if GREATER.  If EQUAL they should be
     *  allocated equally and will be selected at random.
     *)

    val allocation_order :
      {gc     : register * register -> bool,
       non_gc : register * register -> bool,
       fp     : register * register -> bool}

    val allocation_equal :
      {gc     : register * register -> bool,
       non_gc : register * register -> bool,
       fp     : register * register -> bool}

    (*  == Spill handling == *)

    val do_unspilling : bool

    (*  == Register printing ==  *)

    val print_register	: register -> string

    (* Immediate stores for CISCs *)

    val has_immediate_stores : bool

    (*  === MACHINE LIMITS ===  *)

    val digits_in_real : int
    val bits_per_word : int
    val leaf_regs : int (* Number of registers available before a stack frame is required *)

    (* === REGISTER ALLOCATION STRATEGY === *)

    val use_stack_colourer : bool

    (*  === MACHINE FUNCTIONS === *)

    exception Ord
    exception Chr

    val ord: string -> int
    val chr: int -> string

  end
@


1.19.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a15 4
 * Revision 1.19  1998/08/27  12:13:11  jont
 * [Bug #70040]
 * Modify register colourer to use stack colourer only if requested from machspec
 *
@


1.18
log
@[Bug #20038]
Add referenced_by_alloc
@
text
@d16 4
d282 4
@


1.18.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a15 4
 * Revision 1.18  1997/05/13  13:35:42  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.18.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a15 4
 * Revision 1.18  1997/05/13  13:35:42  jont
 * [Bug #20038]
 * Add referenced_by_alloc
 *
@


1.17
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d16 4
d210 7
@


1.16
log
@[Bug #20007]
[Bug #20007]
Adding reserved_but_preferencable registers
@
text
@d16 5
d189 1
a189 1
    val zero		: register MLWorks.Option.option
@


1.15
log
@Adding mach_type value
@
text
@d16 3
d211 3
@


1.15.1.1
log
@branched from 1.15
@
text
@a15 3
 * Revision 1.15  1997/03/25  10:21:48  matthew
 * Adding mach_type value
 *
@


1.15.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a15 3
 * Revision 1.15.1.1  1997/05/12  10:35:46  hope
 * branched from 1.15
 *
@


1.15.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a15 3
 * Revision 1.15.1.1  1997/05/12  10:35:46  hope
 * branched from 1.15
 *
@


1.15.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a15 3
 * Revision 1.15.1.1  1997/05/12  10:35:46  hope
 * branched from 1.15
 *
@


1.15.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a15 3
 * Revision 1.15.1.1.1.1  1997/07/28  18:21:28  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.14
log
@Add in corrupted_by_alloc and leaf_regs
@
text
@d16 3
d138 6
@


1.13
log
@Addin fp_arg_regs
@
text
@d16 3
d185 5
d246 1
@


1.12
log
@Add extra field to procedure_parameters to contain old (pre register allocation)
spill sizes. This is for the i386, where spill assignment is done in the backend
@
text
@d16 4
d162 1
@


1.12.7.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.6.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.6.1.1.1
log
@branched from 1.12.6.1
@
text
@a15 3
 * Revision 1.12.6.1  1996/12/17  17:49:13  hope
 * branched from 1.12
 *
@


1.12.5.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.4.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.4.1.1.1
log
@branched from 1.12.4.1
@
text
@a15 3
 * Revision 1.12.4.1  1996/11/14  12:51:24  hope
 * branched from 1.12
 *
@


1.12.3.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.2.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.12.1.1
log
@branched from 1.12
@
text
@a15 4
 * Revision 1.12  1995/12/20  12:47:15  jont
 * Add extra field to procedure_parameters to contain old (pre register allocation)
 * spill sizes. This is for the i386, where spill assignment is done in the backend
 *
@


1.11
log
@Add bits_per_word to backend specification
@
text
@d16 3
a121 1
require "../utils/option";
a127 1
    structure Option	 : OPTION
d164 1
a164 1
    val zero		: register Option.opt
@


1.10
log
@Add largest_word machine limit
@
text
@d16 3
a229 3
    val largest_int	: string
    val smallest_int	: string
    val largest_word	: string
d231 1
@


1.9
log
@Adding debugger_reserved register set
@
text
@d2 1
a2 1
 *              SIGNATURE
d4 1
a4 1
 *  Copyright (C) 1991 Harlequin Ltd.
d6 106
a111 103
 *  Description
 *  -----------
 *  This module contains all the information necessary to generate MIR code
 *  suitable for the machine code generator.  For example, it specifies the
 *  register model and which pervasives can be generated as in-line code.
 *  Inlining of pervasives now moved to machperv
 *
 *  Revision Log
 *  ------------
 *  $Log: machspec.sml,v $
Revision 1.8  1994/11/11  13:56:45  jont
Add has_immediate_store flag

Revision 1.7  1994/09/21  16:06:11  jont
Add do_unspill value to control register allocator

Revision 1.6  1994/09/15  17:52:06  jont
Add chr and ord to signature
Also add Chr and Ord

Revision 1.5  1994/07/29  11:27:50  matthew
More work on multiple argument passing

Revision 1.4  1994/07/25  11:43:00  matthew
Adding extra arg register

Revision 1.3  1994/05/10  14:46:37  jont
Remove lr, gc1, gc2, stack_limit from register interface

Revision 1.2  1994/03/08  17:23:54  jont
Move digits_in_real here

Revision 1.1  1994/03/04  17:24:54  jont
new file

 *  Revision 1.21  1993/05/28  14:42:01  nosa
 *  Changed Option.T to Option.opt.
 *
 *  Revision 1.20  1992/11/21  19:33:07  jont
 *  Removed is_inline to machperv in order to remove dependence of entire
 *  mir stage on pervasives
 *
 *  Revision 1.19  1992/10/02  17:02:08  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.18  1992/06/08  15:21:17  richard
 *  Added allocation_order.
 *
 *  Revision 1.17  1992/06/03  16:27:49  richard
 *  The reserved registers are now complete sets rather than a list
 *  of preferences.
 *
 *  Revision 1.16  1992/04/07  10:11:10  richard
 *  Partitioned corrupted_by_callee according to register type to
 *  avoid naming clashes.
 *
 *  Revision 1.15  1992/02/06  10:55:52  richard
 *  Added `temporary'.
 *
 *  Revision 1.14  1992/01/07  09:17:03  clive
 *  Added stack limit register definitions
 *
 *  Revision 1.13  1992/01/03  15:44:00  richard
 *  Added the zero register.
 *
 *  Revision 1.12  1991/12/04  13:08:29  richard
 *  Tidied up the documentation.
 *
 *  Revision 1.11  91/11/29  11:47:12  richard
 *  Added `reserved' to prevent register allocation from very special
 *  registers.
 *  
 *  Revision 1.10  91/11/25  15:33:05  jont
 *  Added fp_global as a temporary for conversions from fp to int
 *  
 *  Revision 1.9  91/11/14  10:56:54  richard
 *  Removed references to fp_double registers.
 *  
 *  Revision 1.8  91/11/12  16:54:28  jont
 *  Added is_inline function to the signature
 *  
 *  Revision 1.7  91/10/29  14:16:08  jont
 *  Added values indicating existence on machin level multiply, divide
 *  and modulus
 *  
 *  Revision 1.6  91/10/24  15:29:01  davidt
 *  Now knows about the `implicit' register.
 *  
 *  Revision 1.5  91/10/15  15:14:58  richard
 *  Changed corrupted_by_callee to a set rather than a list.
 *  
 *  Revision 1.4  91/10/14  14:31:33  richard
 *  Added corrupted_by_callee.
 *  
 *  Revision 1.3  91/10/10  14:28:50  richard
 *  indicates allocation preferences. after_preserve and after_restore
 *  discarded.
 *  
 *  Revision 1.2  91/10/09  14:27:05  richard
 *  Added some new register definitions
 *  
 *  Revision 1.1  91/10/07  11:22:56  richard
 *  Initial revision
d229 1
@


1.8
log
@Add has_immediate_store flag
@
text
@d16 3
d177 2
@


1.7
log
@Add do_unspill value to control register allocator
@
text
@d16 3
d213 1
d215 1
@


1.6
log
@Add chr and ord to signature
Also add Chr and Ord
@
text
@d16 19
a34 15
# Revision 1.5  1994/07/29  11:27:50  matthew
# More work on multiple argument passing
#
# Revision 1.4  1994/07/25  11:43:00  matthew
# Adding extra arg register
#
# Revision 1.3  1994/05/10  14:46:37  jont
# Remove lr, gc1, gc2, stack_limit from register interface
#
# Revision 1.2  1994/03/08  17:23:54  jont
# Move digits_in_real here
#
# Revision 1.1  1994/03/04  17:24:54  jont
# new file
#
d202 3
@


1.5
log
@More work on multiple argument passing
@
text
@d16 3
d210 9
@


1.4
log
@Adding extra arg register
@
text
@d16 3
d134 2
a135 2
    val caller_arg2 	: register	(* function argument from caller *)
    val callee_arg2	: register 	(* ditto to callees (may be same) *)
a147 1
    val tail_arg2       : register      (* Where to put the second arg for a tail call *)
@


1.3
log
@Remove lr, gc1, gc2, stack_limit from register interface
@
text
@d16 3
d131 2
d144 2
a145 1
    val tail_arg        : register      (* Where to pout the arg for a tail call *)
@


1.2
log
@Move digits_in_real here
@
text
@d16 3
a131 1
    val lr		: register	(* link register *)
a134 2
    val gc1		: register	(* reserved for garbage collector *)
    val gc2		: register	(* reserved for garbage collector *)
a135 2
    val stack_limit     : register      
                                   (* Holds the limit of the current stack *)
@


1.1
log
@new file
@
text
@d16 3
d200 1
@
