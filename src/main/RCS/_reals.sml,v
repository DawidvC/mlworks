head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.11
	MLWorks_20b2c2_1998_06_19:1.11
	MLWorks_20b2_Windows_1998_06_12:1.11
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.10.5.1.1.1.1
	MLWorks_workspace_97:1.10.7
	MLWorks_dt_wizard:1.10.6
	MLWorks_11c0_1997_09_09:1.10.5.1.1.1
	MLWorks_10r3:1.10.5.1.3
	MLWorks_10r2_551:1.10.5.1.2
	MLWorks_11:1.10.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.5.1
	MLWorks_20m0_1997_06_20:1.10
	MLWorks_1_0_r2c2_1997_06_14:1.10.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.5
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.3.1.1
	MLWorks_gui_1996_12_18:1.10.4
	MLWorks_1_0_Win32_1996_12_17:1.10.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.1.1
	MLWorks_1_0_Irix_1996_11_28:1.10.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.2
	MLWorks_1_0_Unix_1996_11_14:1.10.1
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.9
	MLWorks_Beta_1996_06_07:1.9
	MLWorks_Beta_1996_06_06:1.9
	MLWorks_Beta_1996_06_05:1.9
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9
	ML_beta_release_12/08/94:1.6
	ML_beta_release_03/08/94:1.6
	ML_revised_beta_release_25/05/94:1.6
	ML_final_beta_release_02/03/94:1.4
	mlworks-28-01-1994:1.4
	Release:1.4
	mlworks-beta-01-09-1993:1.4
	MLWorks-1-0-4-29/01/1993:1.4
	MLWorks-1-0-3-21/12/1992:1.4
	MLWorks-1-0-2-15/12/1992:1.4
	MLWorks-1-0-1-04/12/1992:1.4
	checkpoint_17_08_92:1.3;
locks; strict;
comment	@ * @;


1.11
date	97.09.19.11.59.18;	author daveb;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.10.29.16.21.43;	author io;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1;
next	1.9;

1.9
date	96.05.16.16.32.10;	author matthew;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1;
next	1.8;

1.8
date	96.05.07.11.09.41;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.04.30.16.58.59;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.04.13.14.22.22;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.03.09.10.27.28;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.09.28.16.56.11;	author matthew;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	92.04.23.11.49.34;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.12.11.59.05;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.11.11.17.56.53;	author jont;	state Exp;
branches;
next	;

1.4.1.1
date	92.09.28.16.56.11;	author jont;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.18.45;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.08.38;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.26.52;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.11.14.12.52.17;	author hope;	state Exp;
branches
	1.10.1.1.1.1;
next	;

1.10.1.1.1.1
date	96.11.28.15.03.15;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.11.22.18.11.27;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.12.17.17.49.59;	author hope;	state Exp;
branches
	1.10.3.1.1.1;
next	;

1.10.3.1.1.1
date	97.02.24.11.40.11;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.12.18.09.44.03;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	97.05.12.10.36.32;	author hope;	state Exp;
branches
	1.10.5.1.1.1
	1.10.5.1.2.1
	1.10.5.1.3.1;
next	;

1.10.5.1.1.1
date	97.07.28.18.21.15;	author daveb;	state Exp;
branches
	1.10.5.1.1.1.1.1;
next	;

1.10.5.1.1.1.1.1
date	97.10.07.11.46.46;	author jkbrook;	state Exp;
branches;
next	;

1.10.5.1.2.1
date	97.09.08.17.14.41;	author daveb;	state Exp;
branches;
next	;

1.10.5.1.3.1
date	97.09.09.14.10.33;	author daveb;	state Exp;
branches;
next	;

1.10.6.1
date	97.09.10.19.26.31;	author brucem;	state Exp;
branches;
next	;

1.10.7.1
date	97.09.11.20.56.32;	author daveb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.17.57.39;	author daveb;	state Exp;
branches;
next	;


desc
@Reading and converting real numbers to strings
@


1.11
log
@[Bug #30214]
Corrected the translation of ~0.0, and allowed subnormal real literals.
@
text
@(* _reals.sml the functor *)
(*
$Log: _reals.sml,v $
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
 * Revision 1.9  1996/05/16  16:32:10  matthew
 * Bits becomes MLWorks.Internal.Bits
 *
 * Revision 1.8  1996/05/07  11:09:41  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.7  1996/04/30  16:58:59  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.6  1994/04/13  14:22:22  jont
 * Fix inexhaustive bindings
 *
Revision 1.5  1994/03/09  10:27:28  jont
Replace use of machtypes with machspec

Revision 1.4  1992/09/28  16:56:11  matthew
Bug fixes -- completely new code pretty much.  Assumes doubles are used, though
extraction functions are isolate.  decode_real now calls pervasive string_to_real

Revision 1.3  1992/04/23  11:49:34  jont
Removed reference to pervasive length function. Added type specifier
on normalise

Revision 1.2  1991/11/12  11:59:05  jont
Tidied up a lot. Removed symbolic arithmetic, replaced by integer
arithmetic.

Revision 1.1  91/11/11  17:56:53  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "../main/machspec";
require "reals";

functor Reals(
  structure Crash : CRASH
  structure MachSpec : MACHSPEC
) : REALS =

struct
  exception too_small
  exception too_big

  structure Bits = MLWorks.Internal.Bits

fun convert_nybble n =
  let val blist = MLWorks.Internal.Array.arrayoflist
    ["0000",
     "0001",
     "0010",
     "0011",
     "0100",
     "0101",
     "0110",
     "0111",
     "1000",
     "1001",
     "1010",
     "1011",
     "1100",
     "1101",
     "1110",
     "1111"]
  in
    MLWorks.Internal.Array.sub(blist,n)
  end

fun convert_byte b
  = convert_nybble (Bits.rshift (b,4)) ^ convert_nybble (Bits.andb(b,15))

fun make_n_list (n:int,a:char) =
  let fun aux (0,r) = r
        | aux (n,r) = aux(n-1,a::r)
  in
    aux(n,[])
  end

fun pad (n,string,c:char) = 
  let val len = size string
  in
    if len > n then 
      substring (string,0,n)
    else if len = n then 
      string
    else
      string ^ implode (make_n_list (n - len, c))
  end

val zero_exp = ~1023

fun extract_double_exponent (exp1::exp2::rest) =
  ((Bits.andb(exp1,127) * 16) + (Bits.rshift(exp2,4))) - 1023
  | extract_double_exponent _ = Crash.impossible"extract_double_exponent"

fun extract_double_mantissa (exp1::exp2::rest) =
  (convert_nybble (Bits.andb(exp2,15))) :: (map convert_byte rest)
  | extract_double_mantissa _ = Crash.impossible"extract_double_mantissa"

fun find_real_components x =
  let
    val str = MLWorks.Internal.Value.real_to_string x
    val bytes = map ord (explode str)
    val (exp1, exp2, rest) = case bytes of
      (exp1 :: exp2 :: rest) => (exp1, exp2, rest)
    | _ => Crash.impossible"find_real_components gets bad value from MLWorks.Internal.Value.real_to_string"
    val sign = not (Bits.andb(exp1,128) = 0)
    val exponent = extract_double_exponent bytes
    val mant1 = concat ("1" :: extract_double_mantissa bytes)
  in
    (sign, pad(MachSpec.digits_in_real,mant1,#"0"), exponent)
  end

  val evaluate_real = MLWorks.Internal.string_to_real

end
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.11  1997/09/19  11:59:18  daveb
 * [Bug #30214]
 * Corrected the translation of ~0.0, and allowed subnormal real literals.
 *
@


1.10
log
@moving String from toplevel
@
text
@d4 3
d120 1
d122 1
a122 8
    if exponent = zero_exp
      then 
        (false, pad(MachSpec.digits_in_real,"",#"0"), 0)
    else
      let val mant1 = concat ("1" :: extract_double_mantissa bytes)
      in
        (sign, pad(MachSpec.digits_in_real,mant1,#"0"), exponent)
      end
@


1.10.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:36:32  hope
 * branched from 1.10
 *
@


1.10.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:36:32  hope
 * branched from 1.10
 *
@


1.10.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.10.5.1  1997/05/12  10:36:32  hope
 * branched from 1.10
 *
@


1.10.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.10.5.1.1.1  1997/07/28  18:21:15  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.3.1.1.1
log
@branched from 1.10.3.1
@
text
@a3 3
 * Revision 1.10.3.1  1996/12/17  17:49:59  hope
 * branched from 1.10
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a3 3
 * Revision 1.10  1996/10/29  16:21:43  io
 * moving String from toplevel
 *
@


1.10.1.1.1.1
log
@branched from 1.10.1.1
@
text
@a3 3
 * Revision 1.10.1.1  1996/11/14  12:52:17  hope
 * branched from 1.10
 *
@


1.9
log
@Bits becomes MLWorks.Internal.Bits
@
text
@d4 3
d80 1
a80 1
fun make_n_list (n,a) =
d87 1
a87 1
fun pad (n,string,char) = 
d90 4
a93 1
    if len > n then String.substring(string,0,n)
d95 1
a95 3
      if len = n then string
      else
        string ^ String.implode (make_n_list (n - len, char))
d111 1
a111 1
    val bytes = map String.ord (String.explode str)
d120 1
a120 1
        (false, pad(MachSpec.digits_in_real,"","0"), 0)
d122 1
a122 1
      let val mant1 = String.implode ("1" :: extract_double_mantissa bytes)
d124 1
a124 1
        (sign, pad(MachSpec.digits_in_real,mant1,"0"), exponent)
@


1.9.3.1
log
@branched from 1.9
@
text
@a3 3
 * Revision 1.9  1996/05/16  16:32:10  matthew
 * Bits becomes MLWorks.Internal.Bits
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a3 3
 * Revision 1.9  1996/05/16  16:32:10  matthew
 * Bits becomes MLWorks.Internal.Bits
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a3 3
 * Revision 1.9  1996/05/16  16:32:10  matthew
 * Bits becomes MLWorks.Internal.Bits
 *
@


1.8
log
@Array moving to MLWorks.Array
@
text
@d4 3
d50 2
d75 1
a75 1
  = convert_nybble (MLWorks.Bits.rshift (b,4)) ^ convert_nybble (MLWorks.Bits.andb(b,15))
d97 1
a97 1
  ((MLWorks.Bits.andb(exp1,127) * 16) + (MLWorks.Bits.rshift(exp2,4))) - 1023
d101 1
a101 1
  (convert_nybble (MLWorks.Bits.andb(exp2,15))) :: (map convert_byte rest)
d111 1
a111 1
    val sign = not (MLWorks.Bits.andb(exp1,128) = 0)
@


1.7
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d48 1
a48 1
  let val blist = Array.arrayoflist
d66 1
a66 1
    Array.sub(blist,n)
@


1.6
log
@Fix inexhaustive bindings
@
text
@d4 3
d80 1
a80 1
        string ^ implode (make_n_list (n - len, char))
d96 1
a96 1
    val bytes = map ord (explode str)
d107 1
a107 1
      let val mant1 = implode ("1" :: extract_double_mantissa bytes)
@


1.5
log
@Replace use of machtypes with machspec
@
text
@d4 3
d93 4
a96 1
    val bytes as (exp1 :: exp2 :: rest) = map ord (explode str)
@


1.4
log
@Bug fixes -- completely new code pretty much.  Assumes doubles are used, though
extraction functions are isolate.  decode_real now calls pervasive string_to_real
@
text
@d4 4
d23 1
a23 1
require "../machine/machtypes";
d28 1
a28 1
  structure MachTypes : MACHTYPES
d96 1
a96 1
        (false, pad(MachTypes.digits_in_real,"","0"), 0)
d100 1
a100 1
        (sign, pad(MachTypes.digits_in_real,mant1,"0"), exponent)
@


1.4.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.4  1992/09/28  16:56:11  matthew
Bug fixes -- completely new code pretty much.  Assumes doubles are used, though
extraction functions are isolate.  decode_real now calls pervasive string_to_real

@


1.3
log
@Removed reference to pervasive length function. Added type specifier
on normalise
@
text
@d4 4
a18 2
require "../utils/lists";
require "../utils/integer";
a23 2
  structure Lists : LISTS
  structure Integer : INTEGER
d26 1
d31 62
a92 45
  fun decode_real x =
    let
      val string_chars = explode x
      val (sign, string_chars) = case string_chars of
	[] => Crash.impossible"Empty real"
      | "~" :: xs => (true, xs)
      | _ => (false, string_chars)
      val (integer, fraction, exponent) =
	let
	  fun find_point_exp(integer, fraction, exponent, _, _, []) =
	    (rev integer, rev fraction, rev exponent)
	  | find_point_exp(integer, fraction, exponent, got_point, got_exp,
			   "." :: xs) =
	    find_point_exp(integer, [], [], true, false, xs)
	  | find_point_exp(integer, fraction, exponent, got_point, got_exp,
			   "E" :: xs) =
	    find_point_exp(integer, fraction, [], true, true, xs)
	  | find_point_exp(integer, fraction, exponent, got_point, got_exp,
			   x :: xs) =
	    if got_exp then
	      find_point_exp(integer, fraction, x :: exponent, true, true, xs)
	    else
	      if got_point then
		find_point_exp(integer, x :: fraction, [], true, false, xs)
	      else
		find_point_exp(x :: integer, [], [], false, false, xs)
	in
	  find_point_exp([], [], [], false, false, string_chars)
	end
      val (exponent_sign, exponent) = case exponent of
	[] => (false, ["0"])
      | "~" :: xs => (true, xs)
      | _ => (false, exponent)
      val integer = integer @@ fraction
      val exponent =
	Integer.getint(implode exponent)
	handle _ => raise(if exponent_sign then too_small else too_big)
      val exponent =
	(if exponent_sign then ~exponent else exponent) - Lists.length fraction
    in
      (sign, integer, exponent < 0, abs exponent)
    end

  fun normalise(r:real) =
    if r = 0.0 then 0.0
d94 1
a94 2
      let
	val r = abs r
d96 1
a96 6
	if r < 1.0 then
	  normalise(2.0 * r)
	else
	  if r >= 2.0 then normalise(r / 2.0)
	  else
	    r
d98 1
d100 1
a100 12
  fun find_real_exponent r =
    if r = 0.0 then 0
    else
      let
	fun sub_fun(r, exponent) =
	  if r < 1.0 then sub_fun(2.0*r, exponent-1)
	  else
	    if r >= 2.0 then sub_fun(r/2.0, exponent+1)
	    else exponent
      in
	sub_fun(abs r, 0)
      end
a101 37
  fun find_mantissa r =
    let
      fun mant_sub(done, 0, r) = implode(rev done)
      | mant_sub(done, digits_to_go, r) =
	if r >= 1.0 then
	  mant_sub("1" :: done, digits_to_go - 1, 2.0 * (r - 1.0))
	else
	  mant_sub("0" :: done, digits_to_go - 1, 2.0 * r)
    in
      mant_sub([], MachTypes.digits_in_real, abs r)
    end

  fun find_real_components r =
    (r < 0.0, find_mantissa(normalise r), find_real_exponent r)

  fun evaluate_real chars =
    let
      val (sign, floor, exp_sign, exponent) = decode_real chars

      fun floor_to_real([], result) = result
      | floor_to_real(x :: xs, result) =
	floor_to_real(xs, 10.0 * result + real(ord(x) - ord"0"))
      val r = floor_to_real(floor, 0.0)

      fun apply_exponent(r, sign, exponent) =
	if exponent = 0 then r
	else
	  let
	    val conv = real exponent * ln 10.0
	    val conv = if sign then ~conv else conv
	  in
	    r * exp conv handle _ => raise(if sign then too_small else too_big)
	  end
	val r = apply_exponent(r, exp_sign, exponent)
    in
      if sign then ~r else r
    end
@


1.2
log
@Tidied up a lot. Removed symbolic arithmetic, replaced by integer
arithmetic.
@
text
@d3 5
a7 1
$Log:	_reals.sml,v $
d15 1
d22 1
d68 1
a68 1
	(if exponent_sign then ~exponent else exponent) - length fraction
d73 1
a73 1
  fun normalise r =
a136 1

@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
a22 17
  fun unsigned_rev_add(done, [], y, carry) =
    (if not carry then
      rev y @@ done
    else
      case y of
	[] => "1" :: done
      | "9" :: xs => unsigned_rev_add("0" :: done, [], xs, true)
      | x :: xs => unsigned_rev_add(chr(ord x + 1) :: done, [], xs, false))
  | unsigned_rev_add(done, x, [], carry) = unsigned_rev_add(done, [], x, carry)
  | unsigned_rev_add(done, x :: xs, y :: ys, carry) =
    let
      val new_digit =
	ord x - ord "0" + ord y - ord "0" + if carry then 1 else 0
    in
      unsigned_rev_add(chr(ord "0" + new_digit mod 10) :: done, xs, ys,
		       new_digit > 9)
    end
a23 113
  fun unsigned_add(x, y) =
    unsigned_rev_add([], rev x, rev y, false)

  fun unsigned_rev_subtract(done, [], [], false) = done
  | unsigned_rev_subtract(done, [], _, _) =
    Crash.impossible"unsigned_rev_subtract changes sign"
  | unsigned_rev_subtract(done, x, [], carry) =
    if carry then
      unsigned_rev_subtract(done, x, ["1"], false)
    else rev x @@ done
  | unsigned_rev_subtract(done, x :: xs, y :: ys, carry) =
    let
      val new_digit =
	ord x - ord "0" - (ord y - ord "0") - if carry then 1 else 0
      val (new_digit, carry) =
	if new_digit >= 0 then
	  (new_digit, false)
	else (new_digit + 10, true)
    in
      unsigned_rev_subtract(chr(ord "0" + new_digit) :: done, xs, ys, carry)
    end

  fun unsigned_subtract(x, y) =
    unsigned_rev_subtract([], rev x, rev y, false)

  fun convert 0 = ["0"]
  | convert x =
    let
      fun conv_sub(done, 0) = rev done
      | conv_sub(done, x) =
	let
	  val remainder = chr(x mod 10 + ord "0")
	  val quotient = x div 10
	in
	  conv_sub(remainder :: done, quotient)
	end
    in
      conv_sub([], x)
    end

  fun strip [] = ["0"]
  | strip("0" :: xs) = strip xs
  | strip x = x

  fun compare_stripped(x, y) =
    let
      val len_diff = length x - length y
    in
      if len_diff > 0 then true
      else
	if len_diff < 0 then false
	else
	  let
	    fun compare_sub([], []) = true
	    | compare_sub(x :: xs, y :: ys) =
	      if ord x > ord y then true
	      else
		if ord x < ord y then false
		else compare_sub(xs, ys)
	    | compare_sub _ =
	      Crash.impossible"Compare_sub on non-equal length lists"
	  in
	    compare_sub(x, y)
	  end
    end

  fun dec_exp(sign, exponent, dec) =
    if sign then
      (sign, unsigned_add(exponent, dec))
    else
      if compare_stripped(exponent, dec) then
	(false, unsigned_subtract(exponent, dec))
      else
	(true, unsigned_subtract(dec, exponent))

(*
  fun div2 [] = ([], "0")
  | div2 [x] =
    let
      val digit = ord x - ord "0"
    in
      ([chr(ord"0" + digit div 2)], if digit mod 2 = 0 then "0" else "1")
    end
  | div2(x :: y :: xs) =
    let
      val digit = ord x - ord "0"
      (* Note: do not try to optimise the following two lines *)
      (* NJ can't cope with it *)
      val b = digit mod 2
      val c = digit div 2
      val new_y = if b = 0 then y else chr(ord y + 10)
      val (rest, remainder) = div2(new_y :: xs)
    in
      case c of
	0 => (rest, remainder)
      | _ => (chr(ord"0" + c) :: rest, remainder)
    end

  fun to_binary(done, []) = done
  | to_binary(done, ["0"]) = done
  | to_binary(done, x) =
    let
(*
      val _ = print"Dividing "
      val _ = map print x
      val _ = print" by 2"
*)
      val (div2val, remainder) = div2 x
    in
      to_binary(remainder :: done, div2val)
    end
*)

a52 1
      val integer = strip integer
d55 2
a56 6
      | "~" :: xs => (true, strip xs)
      | _ => (false, strip exponent)
(*
      val _ =
	print(implode["Integer = ", implode integer, " fraction = ", implode fraction, " exponent = ", implode exponent])
*)
d58 5
a62 13
(*
      val _ = print"Appended fraction"
      val binary_integer = to_binary([], integer)
      val _ = print"Got to_binary"
*)
      val (exponent_sign, exponent) =
	dec_exp(exponent_sign, exponent, convert(length fraction))
(*
      val _ = print"Got exponent and sign"
      val binary_exponent = to_binary([], exponent)
      val _ =
	print(implode["Sign = ", if sign then "-" else "+", " integer = ", implode integer, " exponent sign = ", if exponent_sign then "-" else "+", " exponent = ", implode exponent])
*)
d64 1
a64 1
      (sign, integer, exponent_sign, exponent)
d112 1
d117 1
a117 3
      val exponent =
	Integer.getint(implode exponent)
	handle _ => raise(if exp_sign then too_small else too_big)
@
