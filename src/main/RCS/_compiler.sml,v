head	1.77;
access;
symbols
	MLW_daveb_inline_1_4_99:1.77.1
	MLWorks_21c0_1999_03_25:1.77
	MLWorks_20c1_1998_08_20:1.77
	MLWorks_20c0_1998_08_04:1.77
	MLWorks_20b2c2_1998_06_19:1.77
	MLWorks_20b2_Windows_1998_06_12:1.77
	MLWorks_20b1c1_1998_05_07:1.77
	MLWorks_20b0_1998_04_07:1.77
	MLWorks_20b0_1998_03_20:1.77
	MLWorks_20m2_1998_02_16:1.77
	MLWorks_20m1_1997_10_23:1.75
	MLWorks_11r1:1.73.1.1.1.1.1
	MLWorks_workspace_97:1.75.2
	MLWorks_dt_wizard:1.75.1
	MLWorks_11c0_1997_09_09:1.73.1.1.1.1
	MLWorks_10r3:1.73.1.1.3
	MLWorks_10r2_551:1.73.1.1.2
	MLWorks_11:1.73.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.73.1.1
	MLWorks_20m0_1997_06_20:1.75
	MLWorks_1_0_r2c2_1997_06_14:1.73.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.73.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.73.1
	MLWorks_BugFix_1997_04_24:1.73
	MLWorks_1_0_r2_Win32_1997_04_11:1.73
	MLWorks_1_0_r2_Unix_1997_04_04:1.73
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.72.3.1.1
	MLWorks_gui_1996_12_18:1.72.4
	MLWorks_1_0_Win32_1996_12_17:1.72.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.72.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.72.1.1
	MLWorks_1_0_Irix_1996_11_28:1.72.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.72.2
	MLWorks_1_0_Unix_1996_11_14:1.72.1
	MLWorks_Open_Beta2_1996_10_11:1.71.2
	MLWorks_License_dev:1.71.1
	MLWorks_1_open_beta_1996_09_13:1.70.1
	MLWorks_Open_Beta_1996_08_22:1.70
	MLWorks_Beta_1996_07_02:1.69
	MLWorks_Beta_1996_06_07:1.69
	MLWorks_Beta_1996_06_06:1.69
	MLWorks_Beta_1996_06_05:1.69
	MLWorks_Beta_1996_06_03:1.69
	MLWorks_Beta_1996_05_31:1.69
	MLWorks_Beta_1996_05_30:1.69
	ML_beta_release_12/08/94:1.48
	ML_beta_release_03/08/94:1.48
	ML_revised_beta_release_25/05/94:1.45
	ML_final_beta_release_02/03/94:1.44
	mlworks-28-01-1994:1.42
	Release:1.36
	mlworks-beta-01-09-1993:1.36
	MLWorks-1-0-4-29/01/1993:1.17
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.14;
locks; strict;
comment	@ * @;


1.77
date	98.01.30.09.42.54;	author johnh;	state Exp;
branches
	1.77.1.1;
next	1.76;

1.76
date	97.11.13.11.18.30;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	97.05.21.17.15.13;	author jont;	state Exp;
branches
	1.75.1.1
	1.75.2.1;
next	1.74;

1.74
date	97.05.12.15.58.40;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	96.12.02.16.12.27;	author matthew;	state Exp;
branches
	1.73.1.1;
next	1.72;

1.72
date	96.10.29.17.05.47;	author io;	state Exp;
branches
	1.72.1.1
	1.72.2.1
	1.72.3.1
	1.72.4.1;
next	1.71;

1.71
date	96.09.25.10.40.23;	author matthew;	state Exp;
branches
	1.71.1.1
	1.71.2.1;
next	1.70;

1.70
date	96.08.06.12.54.28;	author andreww;	state Exp;
branches
	1.70.1.1;
next	1.69;

1.69
date	96.04.30.17.15.43;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	96.04.29.14.58.15;	author matthew;	state Exp;
branches;
next	1.67;

1.67
date	96.03.28.11.13.37;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	96.03.21.10.00.15;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	96.03.19.16.44.36;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	96.03.18.16.03.21;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	96.02.23.17.40.12;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	96.01.16.12.53.45;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	95.12.27.14.16.17;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	95.11.22.09.49.01;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	95.09.05.14.48.21;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	95.08.18.10.12.57;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	95.08.01.14.25.33;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	95.07.13.11.34.21;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	95.06.12.14.17.15;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	95.06.12.13.42.18;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	95.05.30.12.02.32;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	95.04.05.14.45.28;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	95.03.06.11.43.11;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.02.14.14.18.35;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	94.10.14.09.19.07;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.07.19.16.20.09;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.06.22.14.53.36;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	94.06.17.13.21.53;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	94.03.18.14.32.21;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	94.02.28.08.28.46;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	94.02.25.15.57.47;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	94.01.26.18.03.35;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	94.01.07.14.37.40;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.12.20.10.07.26;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	93.12.17.15.31.34;	author io;	state Exp;
branches;
next	1.38;

1.38
date	93.12.15.13.44.06;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.10.06.11.42.09;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.08.16.11.18.35;	author daveb;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	93.08.12.17.01.09;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.08.03.17.50.16;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	93.07.29.14.28.36;	author nosa;	state Exp;
branches;
next	1.32;

1.32
date	93.07.09.10.16.34;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.07.06.10.32.47;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	93.06.02.17.41.40;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	93.05.27.17.10.54;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	93.05.25.16.52.54;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	93.05.18.19.02.51;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	93.05.12.16.32.57;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	93.05.11.12.53.05;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	93.04.26.16.28.54;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	93.04.02.13.30.39;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.03.17.12.18.25;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.03.12.11.57.12;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.03.09.14.46.04;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	93.02.09.10.05.27;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	93.02.04.15.06.55;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.01.28.15.16.56;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	93.01.04.15.57.57;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.12.08.20.46.23;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.12.03.12.09.44;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	92.12.02.15.58.56;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	92.12.02.15.34.41;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.11.27.15.43.12;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	92.11.26.17.21.18;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.11.21.15.45.12;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.11.20.15.26.34;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.11.19.14.50.47;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.11.17.14.35.01;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.11.04.12.37.48;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.10.27.18.35.01;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	92.10.14.12.09.23;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.10.08.11.26.40;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.07.16.10.32;	author richard;	state Exp;
branches;
next	;

1.36.1.1
date	93.08.16.11.18.35;	author jont;	state Exp;
branches;
next	;

1.70.1.1
date	96.09.13.11.18.48;	author hope;	state Exp;
branches;
next	;

1.71.1.1
date	96.10.07.16.08.41;	author hope;	state Exp;
branches;
next	;

1.71.2.1
date	96.10.17.11.26.56;	author hope;	state Exp;
branches;
next	;

1.72.1.1
date	96.11.14.12.52.21;	author hope;	state Exp;
branches
	1.72.1.1.1.1;
next	;

1.72.1.1.1.1
date	96.11.28.15.03.19;	author hope;	state Exp;
branches;
next	;

1.72.2.1
date	96.11.22.18.11.32;	author hope;	state Exp;
branches;
next	;

1.72.3.1
date	96.12.17.17.50.03;	author hope;	state Exp;
branches
	1.72.3.1.1.1;
next	;

1.72.3.1.1.1
date	97.02.24.11.40.15;	author hope;	state Exp;
branches;
next	;

1.72.4.1
date	96.12.18.09.44.07;	author hope;	state Exp;
branches;
next	;

1.73.1.1
date	97.05.12.10.36.37;	author hope;	state Exp;
branches
	1.73.1.1.1.1
	1.73.1.1.2.1
	1.73.1.1.3.1;
next	;

1.73.1.1.1.1
date	97.07.28.18.21.19;	author daveb;	state Exp;
branches
	1.73.1.1.1.1.1.1;
next	;

1.73.1.1.1.1.1.1
date	97.10.07.11.46.52;	author jkbrook;	state Exp;
branches;
next	;

1.73.1.1.2.1
date	97.09.08.17.14.44;	author daveb;	state Exp;
branches;
next	;

1.73.1.1.3.1
date	97.09.09.14.10.36;	author daveb;	state Exp;
branches;
next	;

1.75.1.1
date	97.09.10.19.26.36;	author brucem;	state Exp;
branches;
next	;

1.75.2.1
date	97.09.11.20.56.36;	author daveb;	state Exp;
branches;
next	1.75.2.2;

1.75.2.2
date	97.11.20.17.12.17;	author daveb;	state Exp;
branches;
next	;

1.77.1.1
date	99.04.01.17.58.04;	author daveb;	state Exp;
branches;
next	;


desc
@Compiler interface.
Functor.
@


1.77
log
@[Bug #30326]
Merge in change from branch MLWorks_workspace_97
@
text
@(*  ==== COMPILER INTERFACE ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Notes
 *  -----
 *  Do not use module-global state!  This module needs to be used in a
 *  referentially transparent manner.
 *
 *  Revision Log
 *  ------------
 *  $Log: _compiler.sml,v $
 * Revision 1.76  1997/11/13  11:18:30  jont
 * [Bug #30089]
 * Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
 *
 * Revision 1.75.2.2  1997/11/20  17:12:17  daveb
 * [Bug #30326]
 *
 * Revision 1.75.2.1  1997/09/11  20:56:36  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.75  1997/05/21  17:15:13  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.74  1997/05/12  15:58:40  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.73  1996/12/02  16:12:27  matthew
 * lambda code changed
 *
 * Revision 1.72  1996/10/29  17:05:47  io
 * moving String from toplevel
 *
 * Revision 1.71  1996/09/25  10:40:23  matthew
 * Adding location to Lexer.ungetToken
 *
 * Revision 1.70  1996/08/06  12:54:28  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 * (pass options rather than print_options)
 *
 * Revision 1.69  1996/04/30  17:15:43  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.68  1996/04/29  14:58:15  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.67  1996/03/28  11:13:37  matthew
 * Adding where type clause
 *
 * Revision 1.66  1996/03/21  10:00:15  matthew
 * Making extract_identifiers return items in lexicographical order
 *
 * Revision 1.65  1996/03/19  16:44:36  matthew
 * Change for value polymorphism
 *
 * Revision 1.64  1996/03/18  16:03:21  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
 * Revision 1.63  1996/02/23  17:40:12  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.62  1996/01/16  12:53:45  daveb
 * Added location information to Absyn.SIGNATUREtopdec.
 *
 *  Revision 1.61  1995/12/27  14:16:17  jont
 *  Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.60  1995/11/22  09:49:01  daveb
 *  Removed no_execute.
 *
 *  Revision 1.59  1995/09/05  14:48:21  daveb
 *  LambdaTypes.changes.
 *
 *  Revision 1.58  1995/08/18  10:12:57  jont
 *  Start assemblies from basis for builtin library compilation
 *
 *  Revision 1.57  1995/08/01  14:25:33  matthew
 *  Adding environment simplication function
 *
 *  Revision 1.56  1995/07/13  11:34:21  matthew
 *  Moving Compiler.identifier type to Ident
 *
 *  Revision 1.55  1995/06/12  14:17:15  daveb
 *  Corrected minor mistake in order of identifiers in result list.
 *
 *  Revision 1.54  1995/06/12  13:42:18  daveb
 *  Added some explanatory comments.
 *
 *  Revision 1.53  1995/05/30  12:02:32  matthew
 *  Added make_debug_code to miroptimiser.optimise
 *
 *  Revision 1.52  1995/04/05  14:45:28  matthew
 *  Change Tyfun_id etc to Stamp
 *
 *  Revision 1.51  1995/03/06  11:43:11  daveb
 *  Added dummy identifier value.
 *
 *  Revision 1.50  1995/02/14  14:18:35  matthew
 *  Change to augment_information
 *
 *  Revision 1.49  1994/10/14  09:19:07  matthew
 *  Changed Map.fold to Map.fold_in_rev_order
 *  so identifier list is in alphabetic sequence
 *
 *  Revision 1.48  1994/07/19  16:20:09  matthew
 *  Multiple arguments to functions
 *
 *  Revision 1.47  1994/06/22  14:53:36  jont
 *  Update debugger information production
 *
 *  Revision 1.46  1994/06/17  13:21:53  daveb
 *  Added compare_identifiers and empty_basis.
 *
 *  Revision 1.45  1994/03/18  14:32:21  matthew
 *  Added add_debug_info function
 *
 *  Revision 1.44  1994/02/28  08:28:46  nosa
 *  Debugger environments for Modules Debugger.
 *
 *  Revision 1.43  1994/02/25  15:57:47  daveb
 *  Removed old parameter to trans_top_dec, added clear_debug functionality.
 *
 *  Revision 1.42  1994/01/26  18:03:35  matthew
 *  Simplification.
 *
 *  Revision 1.41  1994/01/07  14:37:40  matthew
 *  Added information on tyname_ids etc. to result
 *
 *  Revision 1.40  1993/12/20  10:07:26  matthew
 *  Added level parameter to basis. (This should have been revision 1.38, but it got lost).
 *
 *  Revision 1.39  1993/12/17  15:31:34  io
 *   Moved over from machine/ for SPARC/MIPS targetting
 *
 *  Revision 1.37  1993/10/06  11:42:09  jont
 *  Changed type of compile to indicate whether the file in question is pervasive
 *
 *  Revision 1.36  1993/08/16  11:18:35  daveb
 *  Removed spurious ".sml" from require declarations.
 *
 *  Revision 1.35  1993/08/12  17:01:09  daveb
 *  Removed Io parameter.
 *
 *  Revision 1.34  1993/08/03  17:50:16  jont
 *  Modified to disallow mid file requires
 *
 *  Revision 1.33  1993/07/29  14:28:36  nosa
 *  structure Option.
 *
 *  Revision 1.32  1993/07/09  10:16:34  daveb
 *  Augmented tyoe basis before passing it to trans_topdec.
 *
 *  Revision 1.31  1993/07/06  10:32:47  daveb
 *  Added basis argument to Lambda.trans_top_dec.
 *  Removed EXCEPTION identifier class.
 *
 *  Revision 1.30  1993/06/02  17:41:40  jont
 *  Changed to use new mod_rules interface. All unnecessary
 *  assembly calculations removed. More needs to be done, to decouple
 *  assemblies for Shell.Make.make from those for use
 *
 *  Revision 1.29  1993/05/27  17:10:54  matthew
 *  Added Location parameter to Info.wrap
 *
 *  Revision 1.28  1993/05/25  16:52:54  jont
 *  Changes because Assemblies now has Basistypes instead of Datatypes
 *
 *  Revision 1.27  1993/05/18  19:02:51  jont
 *  Removed integer parameter
 *
 *  Revision 1.26  1993/05/12  16:32:57  jont
 *  Changed compile to return list of modules compiled. Also implemented
 *  no_execute option for make to give make -n behaviouor
 *
 *  Revision 1.25  1993/05/11  12:53:05  jont
 *  Changes to lambda optimiser to allow removal of inlining for tracing
 *
 *  Revision 1.24  1993/04/26  16:28:54  jont
 *  Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
 *
 *  Revision 1.23  1993/04/02  13:30:39  matthew
 *  Removed Debugger_Types from the signature
 *
 *  Revision 1.22  1993/03/17  12:18:25  matthew
 *  Added parserbasis field to source type
 *
 *  Revision 1.21  1993/03/12  11:57:12  matthew
 *  Options changes
 *  Signature revisions
 *
 *  Revision 1.20  1993/03/09  14:46:04  matthew
 *  Options & Info changes
 *  Removed Parser and BasisTypes substructures from signature
 *
 *  Revision 1.19  1993/02/09  10:05:27  matthew
 *  Changes for typechecker BASISTYPES signature
 *
 *  Revision 1.18  1993/02/04  15:06:55  matthew
 *  Changed functor parameter
 *
 *  Revision 1.17  1993/01/28  15:16:56  jont
 *  Modified to print abstract syntax, lambda calculus etc on request
 *
 *  Revision 1.16  1993/01/04  15:57:57  jont
 *  Modified to deal with extra options for code listing
 *
 *  Revision 1.15  1992/12/08  20:46:23  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.14  1992/12/03  12:09:44  daveb
 *  Fixed sharing constraint
 *
 *  Revision 1.13  1992/12/02  15:58:56  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *
 *  Revision 1.12  1992/12/02  15:34:41  jont
 *  Modified to remove redundant info signatures
 *
 *  Revision 1.11  1992/11/27  15:43:12  daveb
 *  Changes to make show_id_class and show_eq_info part of Info structure
 *  instead of references.
 *
 *  Revision 1.10  1992/11/26  17:21:18  clive
 *  Added clear_debug_info function
 *
 *  Revision 1.9  1992/11/21  15:45:12  clive
 *  Changed the result type to allow the code to be deleted
 *
 *  Revision 1.8  1992/11/20  15:26:34  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.7  1992/11/19  14:50:47  clive
 *  Added a few debug_info functions
 *
 *  Revision 1.6  1992/11/17  14:35:01  matthew
 *  Changed Error structure to Info
 *
 *  Revision 1.5  1992/11/04  12:37:48  richard
 *  Removed an obsolete sharing constraint.
 *
 *  Revision 1.4  1992/10/27  18:35:01  jont
 *  Modified to use sigid_lt instead of sigid_order
 *
 *  Revision 1.3  1992/10/14  12:09:23  richard
 *  Added location information to the `require' topdec and passed
 *  this through to the require function passed to compile.
 *
 *  Revision 1.2  1992/10/08  11:26:40  richard
 *  Added a source type and split parsing away from the rest of compilation
 *  in order to implement it.
 *
 *  Revision 1.1  1992/10/07  16:10:32  richard
 *  Initial revision
 *
 *)

require "../basis/__text_io";

require "../utils/diagnostic";
require "../parser/parser";
require "../lambda/lambda";
require "../lambda/lambdaoptimiser";
require "../lambda/lambdamodule";
require "../lambda/lambdaprint";
require "../lambda/topdecprint";
require "../mir/mir_cg";
require "../mir/miroptimiser";
require "../mir/mirprint";
require "mach_cg";
require "machprint";
require "../utils/lists";
require "../utils/crash";
require "../lambda/environ";
require "../lambda/environprint";
require "../typechecker/mod_rules";
require "../typechecker/basis";
require "../typechecker/stamp";
require "../main/primitives";
require "../main/pervasives";
require "../main/mlworks_io";
require "compiler";

functor Compiler (include sig
                  structure Parser : PARSER
                  structure Lambda : LAMBDA
                  structure LambdaOptimiser : LAMBDAOPTIMISER
                  structure LambdaModule : LAMBDAMODULE
                  structure LambdaPrint : LAMBDAPRINT
                  structure Environ : ENVIRON
                  structure EnvironPrint : ENVIRONPRINT
                  structure Mir_Cg : MIR_CG
                  structure MirOptimiser : MIROPTIMISER
		  structure MirPrint : MIRPRINT 
                  structure Mach_Cg : MACH_CG
                  structure MachPrint : MACHPRINT
                  structure Mod_Rules : MODULE_RULES
                  structure Basis : BASIS
                  structure Stamp : STAMP
                  structure Primitives : PRIMITIVES
                  structure Pervasives : PERVASIVES
		  structure Io : MLWORKS_IO
                  structure Lists : LISTS
                  structure Crash : CRASH
                  structure TopdecPrint : TOPDECPRINT
                  structure Diagnostic : DIAGNOSTIC

                  sharing Lambda.Options =
		    LambdaPrint.Options =
		    TopdecPrint.Options =
		    LambdaOptimiser.Options =
		    EnvironPrint.Options =
                    Mod_Rules.Options =
                    Mir_Cg.Options =
                    Mach_Cg.Options
                  sharing Parser.Lexer.Info =
		    Lambda.Info =
                    Mod_Rules.Info =
                    Mach_Cg.Info =
                    Mir_Cg.Info
                  sharing LambdaOptimiser.LambdaTypes =
                    LambdaPrint.LambdaTypes =
                    Mir_Cg.LambdaTypes =
		    Environ.EnvironTypes.LambdaTypes
                  sharing Environ.EnvironTypes =
                    LambdaModule.EnvironTypes =
                    Lambda.EnvironTypes =
                    Primitives.EnvironTypes =
		    EnvironPrint.EnvironTypes
                  sharing MirOptimiser.MirTypes =
                    Mir_Cg.MirTypes =
                    Mach_Cg.MirTypes =
		    MirPrint.MirTypes
                  sharing MirOptimiser.MachSpec = Mach_Cg.MachSpec
                  sharing Mod_Rules.Assemblies.Basistypes = Basis.BasisTypes
                  sharing Parser.Absyn = Mod_Rules.Absyn =
                    Lambda.Absyn = TopdecPrint.Absyn

                  sharing Basis.BasisTypes.Datatypes.NewMap = Environ.EnvironTypes.NewMap
                  sharing Basis.BasisTypes.Datatypes.Ident = Parser.Absyn.Ident =
                    Environ.EnvironTypes.LambdaTypes.Ident

                  sharing type Lambda.DebugInformation = Mir_Cg.MirTypes.Debugger_Types.information
                  sharing type Parser.Lexer.Options = Lambda.Options.options
		  sharing type Basis.BasisTypes.Basis = Lambda.BasisTypes.Basis
		  sharing type Mach_Cg.Opcode = MachPrint.Opcode
                  sharing type Mir_Cg.MirTypes.Debugger_Types.Type = 
                    Parser.Absyn.Type = Basis.BasisTypes.Datatypes.Type
                  sharing type Pervasives.pervasive = Environ.EnvironTypes.LambdaTypes.Primitive
                  sharing type Basis.BasisTypes.Datatypes.Stamp = Stamp.Stamp
                  sharing type Basis.BasisTypes.Datatypes.StampMap = Stamp.Map.T
                    end where type Environ.EnvironTypes.LambdaTypes.LVar = int

) : COMPILER =



  struct

    structure Diagnostic = Diagnostic
    structure Parser = Parser
    structure Lexer = Parser.Lexer
    structure Token = Lexer.Token
    structure Assemblies = Mod_Rules.Assemblies
    structure BasisTypes = Basis.BasisTypes
    structure EnvironTypes = Environ.EnvironTypes
    structure LambdaTypes = EnvironTypes.LambdaTypes
    structure Pervasives = Pervasives
    structure MirTypes = Mir_Cg.MirTypes
    structure Debugger_Types = MirTypes.Debugger_Types
    structure Map = BasisTypes.Datatypes.NewMap
    structure Info = Lexer.Info
    structure Options = LambdaPrint.Options
    structure NewMap = Map
    structure Location = Info.Location

    structure Absyn = Parser.Absyn
    structure Datatypes = BasisTypes.Datatypes
    structure Ident = Datatypes.Ident

    type Top_Env = EnvironTypes.Top_Env
    type DebuggerEnv = EnvironTypes.DebuggerEnv
    type LambdaExp = LambdaTypes.LambdaExp
    type Module = Mach_Cg.Module
    type ParserBasis = Parser.ParserBasis
    type TypeBasis = BasisTypes.Basis
    type DebugInformation = Debugger_Types.information
    type tokenstream = Lexer.TokenStream

    val (str_ass, ty_ass) =
      Assemblies.new_assemblies_from_basis Basis.initial_basis_for_builtin_library
    val str_ass = ref str_ass
    val ty_ass = ref ty_ass

    fun diagnostic (level, output_function) =
      Diagnostic.output level
      (fn verbosity => "Compiler: " :: (output_function verbosity))

    fun diagnostic_fn (level, output_function) =
      Diagnostic.output_fn level
      (fn (verbosity, stream) => (TextIO.output (stream, "Compiler: "); output_function (verbosity, stream)))

    datatype basis =
      BASIS of {parser_basis		: Parser.ParserBasis,
                type_basis		: BasisTypes.Basis,
                lambda_environment	: EnvironTypes.Top_Env,
                debugger_environment	: DebuggerEnv,
                debug_info		: Debugger_Types.information}

    val empty_basis =
      BASIS
        {parser_basis = Parser.empty_pB,
         type_basis = Basis.empty_basis,
         lambda_environment = Environ.empty_top_env,
         debugger_environment =
           EnvironTypes.DENV
             (Map.empty (Ident.valid_lt,Ident.valid_eq),
              Map.empty (Ident.strid_lt,Ident.strid_eq)),
         debug_info = Debugger_Types.empty_information}

    fun augment (Options.OPTIONS{compiler_options = Options.COMPILEROPTIONS{generate_debug_info,...},...},
		 BASIS {parser_basis, type_basis, lambda_environment, debugger_environment, debug_info},
                 BASIS {parser_basis = delta_parser_basis,
                        type_basis = delta_type_basis,
                        lambda_environment = delta_lambda_environment,
                        debugger_environment = delta_debugger_environment,
                        debug_info = delta_debug_info}) =
      BASIS {parser_basis = Parser.augment_pB (parser_basis, delta_parser_basis),
             type_basis = Basis.basis_circle_plus_basis (type_basis, delta_type_basis),
             lambda_environment = Environ.augment_top_env (lambda_environment, delta_lambda_environment),
             debugger_environment = Environ.augment_denv (debugger_environment, delta_debugger_environment),
             debug_info = Debugger_Types.augment_information (generate_debug_info, debug_info, delta_debug_info)}

    fun add_debug_info (Options.OPTIONS{compiler_options = Options.COMPILEROPTIONS{generate_debug_info,...},...},
                        new_debug_info,
                        BASIS {parser_basis, type_basis, lambda_environment, debugger_environment, debug_info}) =
      BASIS {parser_basis = parser_basis,
             type_basis = type_basis,
             lambda_environment = lambda_environment,
             debugger_environment = debugger_environment,
             debug_info = Debugger_Types.augment_information (generate_debug_info, debug_info, new_debug_info)}

    fun remove_str(BASIS {parser_basis, type_basis, lambda_environment, debugger_environment, debug_info},
		   strid) =
      BASIS{parser_basis = Parser.remove_str(parser_basis, strid),
	    type_basis = Basis.remove_str(type_basis, strid),
	    lambda_environment = lambda_environment,
	    debugger_environment = debugger_environment,
	    debug_info = debug_info}

    fun adjust_compiler_basis_debug_info(BASIS{parser_basis,type_basis,lambda_environment,debugger_environment,...},
					 new_debug_info) =
      BASIS{parser_basis=parser_basis,
	    type_basis=type_basis,
	    lambda_environment=lambda_environment,
	    debugger_environment=debugger_environment,
	    debug_info=new_debug_info}

    fun get_basis_debug_info(BASIS{debug_info,...}) = debug_info

    fun clear_debug_info
	  (name,
	   BASIS{parser_basis,type_basis,lambda_environment,debugger_environment,debug_info}) =
      BASIS{parser_basis=parser_basis,
	    type_basis=type_basis,
	    lambda_environment=lambda_environment,
	    debugger_environment=debugger_environment,
	    debug_info = Debugger_Types.clear_information (name, debug_info)}

    fun clear_debug_all_info
	  (BASIS{parser_basis,type_basis,lambda_environment,debugger_environment,...}) =
      BASIS{parser_basis=parser_basis,
	    type_basis=type_basis,
	    lambda_environment=lambda_environment,
	    debugger_environment=debugger_environment,
	    debug_info = Debugger_Types.empty_information}

    fun make_external (BASIS {parser_basis, type_basis, lambda_environment,
                                       debugger_environment, debug_info}) =
      BASIS {parser_basis = parser_basis,
             type_basis = type_basis,
             lambda_environment = Environ.make_external lambda_environment,
             debugger_environment = debugger_environment,
             debug_info = debug_info}

    (*  == Initial bases ==
     *
     *  These are assembled from other parts of the compiler.  No extra
     *  information is added here.
     *)

    local
      val initial_top_env =
        EnvironTypes.TOP_ENV (Primitives.env_for_not_ml_definable_builtins, Environ.empty_fun_env)
      val initial_top_env_for_builtin_library =
        EnvironTypes.TOP_ENV (Primitives.initial_env_for_builtin_library, Environ.empty_fun_env)
      val builtin_top_env = EnvironTypes.TOP_ENV (Primitives.env_after_builtin, Environ.empty_fun_env)
    in
      val initial_basis =
        BASIS {parser_basis = Parser.initial_pB,
               type_basis = Basis.initial_basis,
               lambda_environment = initial_top_env,
               debugger_environment = Environ.empty_denv,
               debug_info = Debugger_Types.empty_information}

      val initial_basis_for_builtin_library =
        BASIS {parser_basis = Parser.initial_pB_for_builtin_library,
               type_basis = Basis.initial_basis_for_builtin_library,
               lambda_environment = initial_top_env_for_builtin_library,
               debugger_environment = Environ.empty_denv,
               debug_info = Debugger_Types.empty_information}

      val builtin_lambda_environment = builtin_top_env
    end

    datatype id_cache = ID_CACHE of {stamp_start:int,
                                     stamp_no:int}

    datatype result =
      RESULT of {basis		: basis,
                 signatures	: (Ident.SigId, Parser.Absyn.SigExp) Map.map,
                 code		: Module option,
                 id_cache       : id_cache}

    (*  == Extract signatures from absyn ==
     *
     *  This function augments the signatures map with any signatures in the
     *  abstract syntax.  It is applied after parsing in order to return the
     *  signatures information to the user.
     *)

    fun extract_signatures
	  (signatures, Parser.Absyn.SIGNATUREtopdec (sigbinds, _)) =
        Lists.reducel
        (fn (map, Parser.Absyn.SIGBIND bindings) =>
         Lists.reducel
         (fn (map, (ident, exp, _)) => Map.define (map, ident, exp))
         (map, bindings))
        (signatures, sigbinds)
      | extract_signatures (signatures, _) = signatures


    (*  == Extract identifiers from type basis ==
     *
     *  This function augments the identifier list with any identifiers
     *  found in a type basis.  It is applied to the type basis that results
     *  from the compilation in order to supply the identifiers information
     *  to the user.
     *)

    fun extract_identifiers (identifiers,
                             BasisTypes.BASIS (_,_,
                                               BasisTypes.FUNENV functor_env,
                                               BasisTypes.SIGENV signature_env,
                                               Datatypes.ENV (Datatypes.SE structure_env,
                                                              Datatypes.TE type_env,
                                                              Datatypes.VE (_, value_env)))) =
      let
        val identifiers =
          Map.fold_in_rev_order
          (fn (identifiers, valid, _) => (Ident.VALUE valid)::identifiers)
          (identifiers, value_env)

        val identifiers =
          Map.fold_in_rev_order
          (fn (identifiers, tycon, _) => (Ident.TYPE tycon)::identifiers)
          (identifiers, type_env)

        val identifiers =
          Map.fold_in_rev_order
          (fn (identifiers, strid, _) => (Ident.STRUCTURE strid)::identifiers)
          (identifiers, structure_env)

        val identifiers =
          Map.fold_in_rev_order
          (fn (identifiers, funid, _) => (Ident.FUNCTOR funid)::identifiers)
          (identifiers, functor_env)

        val identifiers =
          Map.fold_in_rev_order
          (fn (identifiers, sigid, _) => (Ident.SIGNATURE sigid)::identifiers)
          (identifiers, signature_env)
      in
        identifiers
      end


    (*  === COMPILER ===
     *
     *  This applies each stage of compilation in a straighforward manner.
     *  The only subtlety is the compile_topdec function which is invoked
     *  once or many times depending on the `consume' parameter.
     *)

    datatype source =
      TOKENSTREAM of Lexer.TokenStream |
      TOKENSTREAM1 of Lexer.TokenStream |
      (* the parser basis is an augmentation *)
      TOPDEC of string * Parser.Absyn.TopDec * ParserBasis

    fun compile (info_opts,
                 options as (Options.OPTIONS
                             {listing_options = Options.LISTINGOPTIONS list_opts,
                              compiler_options =
			      Options.COMPILEROPTIONS{generate_debug_info,
                                                      generate_moduler, ...},
                              print_options,
                              compat_options =
                              Options.COMPATOPTIONS{old_definition,...},
                              ...}))
                 require_function
                 (require_value, 
                  BASIS {parser_basis = initial_parser_basis,
                         type_basis = initial_type_basis,
                         lambda_environment = initial_lambda_environment,
                         debugger_environment = initial_debugger_environment,
                         ...}, 
                 making)
                (pervasive, source) =
      let
        (* Record the stamp count at the beginning *)
        val stamp_start = ref (Stamp.read_counter ())

        val (filename, token_stream) =
          case source of
            TOKENSTREAM token_stream =>
	      (Lexer.associated_filename token_stream, SOME token_stream)
          | TOKENSTREAM1 token_stream =>
	      (Lexer.associated_filename token_stream, SOME token_stream)
          | TOPDEC (filename,_,_) => (filename, NONE)

        fun error_wrap arg = Info.wrap info_opts (Info.FATAL, Info.RECOVERABLE, Info.FAULT, Location.FILE filename) arg

        val _ = diagnostic
          (1, fn _ =>
           case source of
             TOKENSTREAM _ => ["Consuming token stream `", filename, "'"]
           | TOKENSTREAM1 _ => ["Consuming one topdec from token stream `", filename, "'"]
           | TOPDEC _ => ["Consuming absyn topdec from source `", filename, "'"])

        val (require_value,
             _, _, _, _,
             parser_basis, type_basis,
             lambda_environment, debugger_environment, lambda_bindings, debug_info,
             signatures, _) =
          let
          (*  == Topdec compiling functions ==
           *
	   *  This scope contains two functions:
	   * 
           *  parse_topdec:
           *    environments * token_stream -> environments * Absyn.Topdec
           *  compile_topdec:
           *    environments * Absyn.Topdec -> environments
	   *
	   *  parse_topdec preserves most of its arguments unchanged, just
	   *  updating the parser_bases.  It has the above type because of
	   *  the way it is used to make an argument for compile_topdec later
	   *  in the file:
           *      fun until_eof environments =
           *        if Parser.Lexer.eof token_stream then
           *          environments
           *        else
           *          until_eof
	   *            (compile_topdec
	   *               (parse_topdec (environments, token_stream)))
           *
           *  Two sets of bases are maintained while compiling topdecs: one
           *  is a `total' which includes all declarations made so far
           *  including those from other modules and the initial basis, the
           *  other is the sum of the topdecs actually compiled here, and
           *  forms the result.
	   *
           *)

            fun compile_topdec ((require_value,
                                 total_parser_basis, total_type_basis, total_lambda_environment, total_debugger_environment,
                                 parser_basis, type_basis, lambda_environment, debugger_environment,
                                 lambda_bindings, debug_info,
                                 signatures, had_topdec),
                                absyn) =
	      (* There are two cases of topdecs.  Require topdecs must occur
		 before all other topdecs in the file.  The had_topdec
		 parameter keeps track of this. *)
              case absyn of
                Absyn.REQUIREtopdec (module, location) =>
		  if had_topdec then
		    Info.error'
		    info_opts
		    (Info.FATAL, location, concat ["Too late for require statement"])
		  else
		    let
		      val (require_value,
			   full_module_name,
			   BASIS {parser_basis = require_parser_basis,
				  type_basis = require_type_basis,
				  lambda_environment = require_lambda_environment,
				  debugger_environment = require_debugger_environment,
				  ...}) =
			require_function (require_value, module, location)

                      val module_expression =
                        LambdaTypes.APP
                        (LambdaTypes.BUILTIN Pervasives.LOAD_STRING,
                         ([LambdaTypes.SCON (Ident.STRING full_module_name, NONE)],[]),
                         NONE)

		      val (require_lambda_environment, require_bindings) =
			LambdaModule.unpack (require_lambda_environment, module_expression)
		    in
                      (* Update counters if another file has been done *)
                      stamp_start := Stamp.read_counter ();

		      (require_value,
		       Parser.augment_pB (total_parser_basis, require_parser_basis),
		       Basis.basis_circle_plus_basis (total_type_basis, require_type_basis),
		       Environ.augment_top_env (total_lambda_environment, require_lambda_environment),
                       Environ.augment_denv (total_debugger_environment,require_debugger_environment),
		       parser_basis,
		       type_basis,
		       lambda_environment,
		       debugger_environment,
		       lambda_bindings @@ require_bindings,
		       debug_info,
		       signatures,
		       false)
		    end
              | absyn =>
		    let
		      val topdec_type_basis =
			error_wrap Mod_Rules.check_topdec
			(options,false,absyn, total_type_basis,
			 Mod_Rules.ASSEMBLY(!str_ass, !ty_ass))
		      val (str_ass', ty_ass') =
			Assemblies.compose_assemblies
			(Assemblies.new_assemblies_from_basis topdec_type_basis,
			 (!str_ass, !ty_ass), topdec_type_basis, total_type_basis)
		      val _ = str_ass := str_ass'
		      val _ = ty_ass := ty_ass'
		      (* This gives the same semantics as before *)
		      (* Watch this space for more improvements *)
		      val _ =
			if #show_absyn list_opts then
			  (Info.listing_fn
			   info_opts
			   (3, fn stream => TextIO.output(stream, "The abstract syntax\n"));
			   Info.listing_fn
			   info_opts
			   (3, fn stream =>
			    TextIO.output(stream, 
                           TopdecPrint.topdec_to_string options absyn));
			   Info.listing_fn
			   info_opts
			 (3, fn stream => TextIO.output(stream, "\n"))
			 )
			else ()

		      val result_type_basis =
			Basis.basis_circle_plus_basis
			  (total_type_basis, topdec_type_basis)

		      val (topdec_lambda_environment, topdec_debugger_environment, topdec_lambda_bindings, debug_info) =
			error_wrap
			  Lambda.trans_top_dec
			  (options,absyn, total_lambda_environment, total_debugger_environment,
			   debug_info, result_type_basis, false)
		    in
		      (require_value,
		       total_parser_basis,
		       result_type_basis,
		       Environ.augment_top_env
			 (total_lambda_environment, topdec_lambda_environment),
		       Environ.augment_denv
			 (total_debugger_environment, topdec_debugger_environment),
		       parser_basis,
		       Basis.basis_circle_plus_basis
			 (type_basis, topdec_type_basis),
		       Environ.augment_top_env
			 (lambda_environment, topdec_lambda_environment),
		       Environ.augment_denv
			 (debugger_environment, topdec_debugger_environment),
		       lambda_bindings @@ topdec_lambda_bindings,
		       debug_info,
		       extract_signatures (signatures, absyn),
		       true)
		    end

            fun parse_topdec ((require_value,
                               total_parser_basis, total_type_basis, total_lambda_environment, total_debugger_environment,
                               parser_basis, type_basis, lambda_environment, debugger_environment,
                               lambda_bindings, debug_info,
                               signatures, had_topdec),
                              token_stream) =
              let
                val (absyn, topdec_parser_basis) = error_wrap Parser.parse_topdec (options,token_stream, total_parser_basis)
              in
                diagnostic (2, fn _ => ["parsed topdec:\n", 
                                        TopdecPrint.topdec_to_string 
                                        options absyn]);
                ((require_value,
                  Parser.augment_pB (total_parser_basis, topdec_parser_basis),
                  total_type_basis,
                  total_lambda_environment,
                  total_debugger_environment,
                  Parser.augment_pB (parser_basis, topdec_parser_basis),
                  type_basis,
                  lambda_environment,
                  debugger_environment,
                  lambda_bindings,
                  debug_info,
                  signatures,
		  had_topdec),
                 absyn)
              end

            val environments =
              (require_value,
               initial_parser_basis,
               initial_type_basis,
               initial_lambda_environment,
               initial_debugger_environment,
               (case source of
                  TOPDEC(_,_,parserbasis) => parserbasis
                | _ => Parser.empty_pB),
               Basis.empty_basis,
               Environ.empty_top_env,
               Environ.empty_denv,
               [],
               Debugger_Types.empty_information,
               Map.empty' Datatypes.Ident.sigid_lt,
               false)

	    val _ =
	      if pervasive orelse not making then
		() (* Don't add anything if pervasive or use*)
	      else
		let
		  val the_token_list =
		    [Token.RESERVED(Token.REQUIRE),
		     Token.STRING(Io.pervasive_library_name),
		     Token.RESERVED(Token.SEMICOLON)]
		  val token_stream = case token_stream of
		    SOME token_stream => token_stream
		  | _ => Crash.impossible "Non-pervasive make with no stream"
		in
		  app
		  (fn token => Lexer.ungetToken((token,Info.Location.UNKNOWN), token_stream))
		  (rev the_token_list)
		end

          in
            case source of
              TOPDEC (_, absyn,_) =>
		 compile_topdec (environments, absyn)
            | TOKENSTREAM1 token_stream =>
                compile_topdec (parse_topdec (environments, token_stream))
            | TOKENSTREAM token_stream =>
                let
                  fun until_eof environments =
                    if Parser.Lexer.eof token_stream then
                      environments
                    else
                      until_eof (compile_topdec (parse_topdec (environments, token_stream)))
                in
                  until_eof environments
                end
          end

        (* Close the lambda bindings into a single expression to be compiled *)
        (* into the new module. *)

        val stamp_no = Stamp.read_counter () - !stamp_start

        val new_id_cache = ID_CACHE{stamp_start = !stamp_start,
                                    stamp_no = stamp_no}
      in
	  let
	    val (lambda_environment, lambda_expression) =
	      LambdaModule.pack (lambda_environment, lambda_bindings)

	    val _ =
	      if #show_lambda list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The unoptimised lambda code\n"));
		 Info.listing_fn info_opts
		 (3, fn stream =>
		  LambdaPrint.output_lambda options (stream, lambda_expression)))
	      else ()

	    (* Optimise the lambda expression *)

	    val lambda_expression = LambdaOptimiser.optimise options lambda_expression

	    val _ =
	      if #show_opt_lambda list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The optimised lambda code\n"));
		 Info.listing_fn info_opts
		 (3, fn stream =>
		  LambdaPrint.output_lambda options (stream, lambda_expression)))
	      else ()

            val lambda_environment = Environ.simplify_topenv (lambda_environment,lambda_expression)

	    val _ =
	      if #show_environ list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The environment\n"));
		 Info.listing_fn info_opts
		 (3, EnvironPrint.printtopenv print_options lambda_environment);
		 Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "\n")))
	      else ()

	    (* Generate intermediate code from the lambda expression and *)
	    (* optimise it *)

	    val (mir, debug_info) =
	      error_wrap
	      Mir_Cg.mir_cg
	      (options, lambda_expression, filename, debug_info)
	    val _ =
	      if #show_mir list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The unoptimised intermediate code\n"));
		 Info.listing_fn info_opts (3, MirPrint.print_mir_code mir))
	      else
		()

	    val mir = MirOptimiser.optimise (mir,generate_debug_info)
	    val _ =
	      if #show_opt_mir list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The optimised intermediate code\n"));
		 Info.listing_fn info_opts (3, MirPrint.print_mir_code mir))
	      else
		()

	    (* Generate the module machine code from the MIR *)

	    val ((code, debug_info), code_list_list) =
	      let
		val {gc, non_gc, fp} = MirOptimiser.machine_register_assignments
	      in
		error_wrap
		Mach_Cg.mach_cg
		(options, mir, (gc, non_gc, fp), debug_info)
	      end
	    val _ =
	      if #show_mach list_opts then
		(Info.listing_fn
		 info_opts
		 (3, fn stream => TextIO.output(stream, "The final machine code\n"));
		 Info.listing_fn info_opts (3, MachPrint.print_mach_code code_list_list))
	      else
		()

	  in
	    (require_value,
	     RESULT {basis = BASIS {parser_basis = parser_basis,
				    type_basis = type_basis,
				    lambda_environment = lambda_environment,
				    debugger_environment = debugger_environment,
				    debug_info = debug_info},
		     signatures = signatures,
                     id_cache = new_id_cache,
		     code = SOME code})
	  end
      end

  end
@


1.77.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.77  1998/01/30  09:42:54  johnh
 * [Bug #30326]
 * Merge in change from branch MLWorks_workspace_97
 *
@


1.76
log
@[Bug #30089]
Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
@
text
@d13 10
d288 1
a288 1
require "../main/io";
@


1.75
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d13 4
a257 1
require "../utils/timer";
a303 1
                  structure Timer : TIMER
@


1.75.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 * Revision 1.75  1997/05/21  17:15:13  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.75.2.2
log
@[Bug #30326]
@
text
@a12 3
 * Revision 1.75.2.1  1997/09/11  20:56:36  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d258 1
a258 1
require "../utils/mlworks_timer";
d279 1
a279 1
require "../main/mlworks_io";
@


1.75.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 4
 * Revision 1.75  1997/05/21  17:15:13  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.74
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d13 4
d251 2
d396 1
a396 1
      (fn (verbosity, stream) => (MLWorks.IO.output (stream, "Compiler: "); output_function (verbosity, stream)))
d741 1
a741 1
			   (3, fn stream => MLWorks.IO.output(stream, "The abstract syntax\n"));
d745 1
a745 1
			    MLWorks.IO.output(stream, 
d749 1
a749 1
			 (3, fn stream => MLWorks.IO.output(stream, "\n"))
d880 1
a880 1
		 (3, fn stream => MLWorks.IO.output(stream, "The unoptimised lambda code\n"));
d894 1
a894 1
		 (3, fn stream => MLWorks.IO.output(stream, "The optimised lambda code\n"));
d906 1
a906 1
		 (3, fn stream => MLWorks.IO.output(stream, "The environment\n"));
d911 1
a911 1
		 (3, fn stream => MLWorks.IO.output(stream, "\n")))
d925 1
a925 1
		 (3, fn stream => MLWorks.IO.output(stream, "The unoptimised intermediate code\n"));
d935 1
a935 1
		 (3, fn stream => MLWorks.IO.output(stream, "The optimised intermediate code\n"));
d954 1
a954 1
		 (3, fn stream => MLWorks.IO.output(stream, "The final machine code\n"));
@


1.73
log
@lambda code changed
@
text
@d13 3
d290 1
a290 1
		  structure Io : IO
@


1.73.1.1
log
@branched from 1.73
@
text
@a12 3
 * Revision 1.73  1996/12/02  16:12:27  matthew
 * lambda code changed
 *
@


1.73.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.73.1.1  1997/05/12  10:36:37  hope
 * branched from 1.73
 *
@


1.73.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.73.1.1  1997/05/12  10:36:37  hope
 * branched from 1.73
 *
@


1.73.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.73.1.1  1997/05/12  10:36:37  hope
 * branched from 1.73
 *
@


1.73.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.73.1.1.1.1  1997/07/28  18:21:19  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.72
log
@moving String from toplevel
@
text
@d13 3
d691 1
a691 1
                         [LambdaTypes.SCON (Ident.STRING full_module_name, NONE)],
@


1.72.4.1
log
@branched from 1.72
@
text
@a12 3
 * Revision 1.72  1996/10/29  17:05:47  io
 * moving String from toplevel
 *
@


1.72.3.1
log
@branched from 1.72
@
text
@a12 3
 * Revision 1.72  1996/10/29  17:05:47  io
 * moving String from toplevel
 *
@


1.72.3.1.1.1
log
@branched from 1.72.3.1
@
text
@a12 3
 * Revision 1.72.3.1  1996/12/17  17:50:03  hope
 * branched from 1.72
 *
@


1.72.2.1
log
@branched from 1.72
@
text
@a12 3
 * Revision 1.72  1996/10/29  17:05:47  io
 * moving String from toplevel
 *
@


1.72.1.1
log
@branched from 1.72
@
text
@a12 3
 * Revision 1.72  1996/10/29  17:05:47  io
 * moving String from toplevel
 *
@


1.72.1.1.1.1
log
@branched from 1.72.1.1
@
text
@a12 3
 * Revision 1.72.1.1  1996/11/14  12:52:21  hope
 * branched from 1.72
 *
@


1.71
log
@Adding location to Lexer.ungetToken
@
text
@d13 3
d505 1
a505 1
                 code		: Module MLWorks.Option.option,
d610 1
a610 1
	      (Lexer.associated_filename token_stream, MLWorks.Option.SOME token_stream)
d612 2
a613 2
	      (Lexer.associated_filename token_stream, MLWorks.Option.SOME token_stream)
          | TOPDEC (filename,_,_) => (filename, MLWorks.Option.NONE)
d673 1
a673 1
		    (Info.FATAL, location, String.implode ["Too late for require statement"])
d688 2
a689 2
                         [LambdaTypes.SCON (Ident.STRING full_module_name, MLWorks.Option.NONE)],
                         MLWorks.Option.NONE)
d826 1
a826 1
		    MLWorks.Option.SOME token_stream => token_stream
d829 1
a829 1
		  Lists.iterate
d956 1
a956 1
		     code = MLWorks.Option.SOME code})
@


1.71.2.1
log
@branched from 1.71
@
text
@a12 3
 * Revision 1.71  1996/09/25  10:40:23  matthew
 * Adding location to Lexer.ungetToken
 *
@


1.71.1.1
log
@branched from 1.71
@
text
@a12 3
 * Revision 1.71  1996/09/25  10:40:23  matthew
 * Adding location to Lexer.ungetToken
 *
@


1.70
log
@[Bug #1521]
propagating changes made to typechecker/_types.sml
(pass options rather than print_options)
@
text
@d13 5
d827 1
a827 1
		  (fn token => Lexer.ungetToken(token, token_stream))
@


1.70.1.1
log
@branched from 1.70
@
text
@a12 5
 * Revision 1.70  1996/08/06  12:54:28  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 * (pass options rather than print_options)
 *
@


1.69
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d13 6
d583 2
d725 2
a726 1
			    MLWorks.IO.output(stream, TopdecPrint.topdec_to_string print_options absyn));
d772 3
a774 1
                diagnostic (2, fn _ => ["parsed topdec:\n", TopdecPrint.topdec_to_string print_options absyn]);
d863 1
a863 1
		  LambdaPrint.output_lambda print_options (stream, lambda_expression)))
d877 1
a877 1
		  LambdaPrint.output_lambda print_options (stream, lambda_expression)))
@


1.68
log
@Removing MLWorks.Integer
@
text
@d13 3
d370 1
a370 1
      (fn (verbosity, stream) => (output (stream, "Compiler: "); output_function (verbosity, stream)))
d657 1
a657 1
		    (Info.FATAL, location, implode ["Too late for require statement"])
d713 1
a713 1
			   (3, fn stream => output(stream, "The abstract syntax\n"));
d717 1
a717 1
			    output(stream, TopdecPrint.topdec_to_string print_options absyn));
d720 1
a720 1
			 (3, fn stream => output(stream, "\n"))
d849 1
a849 1
		 (3, fn stream => output(stream, "The unoptimised lambda code\n"));
d863 1
a863 1
		 (3, fn stream => output(stream, "The optimised lambda code\n"));
d875 1
a875 1
		 (3, fn stream => output(stream, "The environment\n"));
d880 1
a880 1
		 (3, fn stream => output(stream, "\n")))
d894 1
a894 1
		 (3, fn stream => output(stream, "The unoptimised intermediate code\n"));
d904 1
a904 1
		 (3, fn stream => output(stream, "The optimised intermediate code\n"));
d923 1
a923 1
		 (3, fn stream => output(stream, "The final machine code\n"));
@


1.67
log
@Adding where type clause
@
text
@d13 3
a345 2

    structure Integer = MLWorks.Integer
@


1.66
log
@Making extract_identifiers return items in lexicographical order
@
text
@d13 3
d246 2
a247 1
functor Compiler (structure Parser : PARSER
a312 1
                  sharing type Environ.EnvironTypes.LambdaTypes.LVar = int
d315 2
@


1.65
log
@Change for value polymorphism
@
text
@d13 3
d520 1
a520 1
          Map.fold_in_order
d525 1
a525 1
          Map.fold_in_order
d530 1
a530 1
          Map.fold_in_order
d535 1
a535 1
          Map.fold_in_order
d540 1
a540 1
          Map.fold_in_order
@


1.64
log
@Removed the identifiers field from the Compiler.result type.  This information
can be synthesised from the type basis.
@
text
@d13 4
d587 1
a587 1
        val error_wrap = Info.wrap info_opts (Info.FATAL, Info.RECOVERABLE, Info.FAULT, Location.FILE filename)
@


1.63
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d13 3
a474 1
                 identifiers	: Ident.Identifier list,
d596 1
a596 1
             signatures, identifiers, _) =
d631 1
a631 1
                                 signatures, identifiers, had_topdec),
a676 1
		       identifiers,
a734 1
		       extract_identifiers (identifiers, topdec_type_basis),
d742 1
a742 1
                               signatures, identifiers, had_topdec),
a759 1
                  identifiers,
d779 1
a779 1
               [], false)
a919 1
		     identifiers = rev identifiers,
@


1.62
log
@Added location information to Absyn.SIGNATUREtopdec.
@
text
@d13 3
d471 1
a471 1
                 signatures	: (Ident.SigId, Parser.Absyn.SigExp) Map.T,
@


1.61
log
@Removing Option in favour of MLWorks.Option
@
text
@d13 3
d480 2
a481 1
    fun extract_signatures (signatures, Parser.Absyn.SIGNATUREtopdec sigbinds) =
@


1.60
log
@Removed no_execute.
@
text
@d13 3
a203 1
require "../utils/option";
a244 1
                  structure Option : OPTION
a317 2
    structure Option = Option

d467 1
a467 1
                 code		: Module Option.opt,
d569 1
a569 1
	      (Lexer.associated_filename token_stream, Option.PRESENT token_stream)
d571 2
a572 2
	      (Lexer.associated_filename token_stream, Option.PRESENT token_stream)
          | TOPDEC (filename,_,_) => (filename, Option.ABSENT)
d785 1
a785 1
		    Option.PRESENT token_stream => token_stream
d916 1
a916 1
		     code = Option.PRESENT code})
@


1.59
log
@LambdaTypes.changes.
@
text
@d13 3
a550 1
                                                      no_execute,
a672 16
		  if no_execute andalso making then
		    (require_value,
		     total_parser_basis,
		     total_type_basis,
		     total_lambda_environment,
		     total_debugger_environment,
		     parser_basis,
		     type_basis,
		     lambda_environment,
		     debugger_environment,
		     lambda_bindings,
		     debug_info,
		     Map.empty' Datatypes.Ident.sigid_lt,
		     [],
		     true)
		  else
a819 13
	if no_execute andalso making then
	  (require_value,
	   RESULT {basis = BASIS {parser_basis = parser_basis,
				  type_basis = Basis.empty_basis,
				  lambda_environment = Environ.empty_top_env,
				  debugger_environment = Environ.empty_denv,
				  debug_info = Debugger_Types.empty_information},
		   signatures = Map.empty' Datatypes.Ident.sigid_lt,
		   identifiers = [],
                   id_cache = new_id_cache,
		   code = Option.ABSENT})

	else
@


1.58
log
@Start assemblies from basis for builtin library compilation
@
text
@d13 3
d646 2
a647 2
                         [LambdaTypes.SCON (Ident.STRING full_module_name)],
                         LambdaTypes.Option.ABSENT)
@


1.57
log
@Adding environment simplication function
@
text
@d13 3
d329 4
a332 2
    val str_ass = ref (Assemblies.empty_strassembly())
    val ty_ass = ref(Assemblies.empty_tyassembly)
@


1.56
log
@Moving Compiler.identifier type to Ident
@
text
@d13 3
d866 2
@


1.55
log
@Corrected minor mistake in order of identifiers in result list.
@
text
@d13 3
a446 23
    datatype identifier =
      VALUE of Ident.ValId |
      TYPE of Ident.TyCon |
      STRUCTURE of Ident.StrId |
      SIGNATURE of Ident.SigId |
      FUNCTOR of Ident.FunId

    val dummy_identifier = VALUE (Ident.VAR (Ident.Symbol.find_symbol "it"))

    fun compare_identifiers (VALUE i, VALUE i') = Ident.valid_lt (i, i')
    |   compare_identifiers (VALUE _, _) = true
    |   compare_identifiers (_, VALUE _) = false
    |   compare_identifiers (TYPE i, TYPE i') = Ident.tycon_lt (i, i')
    |   compare_identifiers (TYPE _, _) = true
    |   compare_identifiers (_, TYPE _) = false
    |   compare_identifiers (STRUCTURE i, STRUCTURE i') = Ident.strid_lt (i, i')
    |   compare_identifiers (STRUCTURE _, _) = true
    |   compare_identifiers (_, STRUCTURE _) = false
    |   compare_identifiers (SIGNATURE i, SIGNATURE i') = Ident.sigid_lt (i, i')
    |   compare_identifiers (SIGNATURE _, _) = true
    |   compare_identifiers (FUNCTOR _, SIGNATURE _) = false
    |   compare_identifiers (FUNCTOR i, FUNCTOR i') = Ident.funid_lt (i, i')

d453 1
a453 1
                 identifiers	: identifier list,
d492 1
a492 1
          (fn (identifiers, valid, _) => (VALUE valid)::identifiers)
d497 1
a497 1
          (fn (identifiers, tycon, _) => (TYPE tycon)::identifiers)
d502 1
a502 1
          (fn (identifiers, strid, _) => (STRUCTURE strid)::identifiers)
d507 1
a507 1
          (fn (identifiers, funid, _) => (FUNCTOR funid)::identifiers)
d512 1
a512 1
          (fn (identifiers, sigid, _) => (SIGNATURE sigid)::identifiers)
@


1.54
log
@Added some explanatory comments.
@
text
@d13 3
d511 1
a511 1
          Map.fold_in_rev_order
d516 1
a516 1
          Map.fold_in_rev_order
d521 1
a521 1
          Map.fold_in_rev_order
d526 1
a526 1
          Map.fold_in_rev_order
d531 1
a531 1
          Map.fold_in_rev_order
d949 1
a949 1
		     identifiers = identifiers,
@


1.53
log
@Added make_debug_code to miroptimiser.optimise
@
text
@d13 3
d594 28
a621 9

            (*  == Topdec compiling functions ==
             *
             *  Two environments are maintained while compiling topdecs: one
             *  is a `total' which includes all declarations made so far
             *  including those from other modules and the initial basis, the
             *  other is the sum of the topdecs actually compiled here, and
             *  forms the result.
             *)
d629 3
@


1.52
log
@Change Tyfun_id etc to Stamp
@
text
@d13 3
d884 1
a884 1
	    val mir = MirOptimiser.optimise mir
@


1.51
log
@Added dummy identifier value.
@
text
@d13 3
d195 1
d215 1
d269 2
d458 2
a459 6
    datatype id_cache = ID_CACHE of {tyname_start:int,
                                     strname_start:int,
                                     tyfun_start:int,
                                     tyname_no:int,
                                     strname_no:int,
                                     tyfun_no:int}
d562 2
a563 4
        (* Record the tyname_id count at the beginning *)
        val tyname_start = ref (Datatypes.Tyname_id.read_counter ())
        val strname_start = ref (Datatypes.Strname_id.read_counter ())
        val tyfun_start = ref (Datatypes.Tyfun_id.read_counter ())
d631 1
a631 3
                      tyname_start := Datatypes.Tyname_id.read_counter ();
                      strname_start := Datatypes.Strname_id.read_counter ();
                      tyfun_start := Datatypes.Tyfun_id.read_counter ();
d668 1
a668 1
			(options,absyn, total_type_basis,
d807 4
a810 21
        val tyname_no = Datatypes.Tyname_id.read_counter () - !tyname_start
        val strname_no = Datatypes.Strname_id.read_counter () - !strname_start
        val tyfun_no = Datatypes.Tyfun_id.read_counter () - !tyfun_start

(*
        val _ = output(std_out,
                       "Numbers : " ^ Integer.makestring (!tyname_start) ^ " " ^
                       Integer.makestring (!strname_start) ^ " " ^
                       Integer.makestring (!tyfun_start) ^ " " ^
                       Integer.makestring tyname_no ^ " " ^
                       Integer.makestring strname_no ^ " " ^
                       Integer.makestring tyfun_no ^ " " ^
                       "\n");
*)

        val new_id_cache = ID_CACHE{tyname_start = !tyname_start,
                                strname_start = !strname_start,
                                tyfun_start = !tyfun_start,
                                tyname_no = tyname_no,
                                strname_no = strname_no,
                                tyfun_no = tyfun_no}
@


1.50
log
@Change to augment_information
@
text
@d13 3
d434 2
@


1.49
log
@Changed Map.fold to Map.fold_in_rev_order
so identifier list is in alphabetic sequence
@
text
@d13 4
d218 1
a218 1
                  sharing Lambda.Debugger_Types.Options =
d224 1
a224 1
                    Parser.Options =
a239 2
                  sharing Mir_Cg.MirTypes.Debugger_Types =
                    Lambda.Debugger_Types
d249 1
a249 2
                  sharing Basis.BasisTypes.Datatypes.NewMap = Environ.EnvironTypes.NewMap =
                    Lambda.Debugger_Types.NewMap
d253 2
d263 2
d277 1
a277 1
    structure Debugger_Types = Lambda.Debugger_Types
d330 1
a330 1
    fun augment (options,
d341 1
a341 1
             debug_info = Debugger_Types.augment_information (options, debug_info, delta_debug_info)}
d343 2
a344 1
    fun add_debug_info (options, new_debug_info,
d350 1
a350 1
             debug_info = Debugger_Types.augment_information (options, debug_info, new_debug_info)}
d539 3
a541 1
			      Options.COMPILEROPTIONS{debug, no_execute, generate_moduler, ...},
d545 7
a551 5
                 (require_value, BASIS {parser_basis = initial_parser_basis,
                                       type_basis = initial_type_basis,
                                       lambda_environment = initial_lambda_environment,
                                       debugger_environment = initial_debugger_environment,
                                       ...}, making)
d775 1
a775 1
		  | _ => Crash.impossible"Non-pervasive make with no stream"
@


1.48
log
@Multiple arguments to functions
@
text
@d13 3
d488 1
a488 1
          Map.fold
d493 1
a493 1
          Map.fold
d498 1
a498 1
          Map.fold
d503 1
a503 1
          Map.fold
d508 1
a508 1
          Map.fold
@


1.47
log
@Update debugger information production
@
text
@d13 3
d605 1
a605 1
                         LambdaTypes.SCON (Ident.STRING full_module_name),
@


1.46
log
@Added compare_identifiers and empty_basis.
@
text
@d13 3
d319 2
a320 1
    fun augment (BASIS {parser_basis, type_basis, lambda_environment, debugger_environment, debug_info},
d330 1
a330 1
             debug_info = Debugger_Types.augment_information (debug_info, delta_debug_info)}
d332 1
a332 1
    fun add_debug_info (new_debug_info,
d338 1
a338 1
             debug_info = Debugger_Types.augment_information (debug_info, new_debug_info)}
@


1.45
log
@Added add_debug_info function
@
text
@d13 3
d305 11
d415 14
@


1.44
log
@Debugger environments for Modules Debugger.
@
text
@d13 3
d313 8
@


1.43
log
@Removed old parameter to trans_top_dec, added clear_debug functionality.
@
text
@d13 3
d242 1
d273 1
d296 1
d299 1
a299 1
    fun augment (BASIS {parser_basis, type_basis, lambda_environment, debug_info},
d303 1
d308 1
d311 1
a311 1
    fun remove_str(BASIS {parser_basis, type_basis, lambda_environment, debug_info},
d316 1
d319 1
a319 1
    fun adjust_compiler_basis_debug_info(BASIS{parser_basis,type_basis,lambda_environment,...},
d324 1
d331 1
a331 1
	   BASIS{parser_basis,type_basis,lambda_environment,debug_info}) =
d335 1
d339 1
a339 1
	  (BASIS{parser_basis,type_basis,lambda_environment,...}) =
d343 1
d346 2
a347 1
    fun make_external (BASIS {parser_basis, type_basis, lambda_environment, debug_info}) =
d351 1
a353 1

d371 1
d378 1
d431 1
a431 2
                             BasisTypes.BASIS (_,
                                               _,
d484 1
a484 1
			      Options.COMPILEROPTIONS{debug, no_execute, ...},
d491 1
d518 1
a518 1
             _, _, _,
d520 1
a520 1
             lambda_environment, lambda_bindings, debug_info,
d534 2
a535 2
                                 total_parser_basis, total_type_basis, total_lambda_environment,
                                 parser_basis, type_basis, lambda_environment,
d552 1
d574 1
d578 1
d591 1
d595 1
d634 1
a634 1
		      val (topdec_lambda_environment, topdec_lambda_bindings, debug_info) =
d637 2
a638 2
			  (options,absyn, total_lambda_environment,
			   debug_info, result_type_basis)
d645 2
d652 2
d662 2
a663 2
                               total_parser_basis, total_type_basis, total_lambda_environment,
                               parser_basis, type_basis, lambda_environment,
d675 1
d679 1
d693 1
d699 1
d771 1
d869 1
@


1.42
log
@Simplification.
@
text
@d13 3
d319 10
a328 1
    fun clear_debug_info(BASIS{parser_basis,type_basis,lambda_environment,...}) =
d617 1
a617 1
			  (options,absyn, total_lambda_environment, debug,
@


1.41
log
@Added information on tyname_ids etc. to result
@
text
@d13 3
d322 7
d465 1
a465 1
                                       ...}, done, making)
a489 2
	val first_is_pervasive = ref true

d494 1
a494 1
             signatures, identifiers, done, _) =
d510 1
a510 1
                                 signatures, identifiers, done, had_topdec),
d521 1
a521 1
			   module_expression,
d525 2
a526 3
				  ...}, done) =
			require_function (require_value, module, location, done,
					  !first_is_pervasive)
d528 5
a532 1
		      val _ = first_is_pervasive := pervasive
d553 1
a553 1
		       done, false)
d568 1
a568 1
		     done, true)
d622 1
a622 1
		       done, true)
d629 1
a629 1
                               signatures, identifiers, done, had_topdec),
d646 1
a646 1
		  done, had_topdec),
d663 1
a663 1
               [], done, false)
a676 3
(* Don't need, this, the first require will now always be pervasive
		  val _ = first_is_pervasive := true
*)
d682 1
a685 1
		((*output(std_out, "Compiling TOPDEC\n");*)
a686 1
		 )
d688 1
a688 8
		((*output(std_out, "Compiling TOKENSTREAM1\n");*)
                compile_topdec
		let
		  val (env, absyn) = parse_topdec (environments, token_stream)
		in
		  (env, absyn)
		end
		 )
a689 1
		((*output(std_out, "Compiling TOKENSTREAM\n");*)
a698 1
	      )
a703 2
	val done = filename :: done

d735 1
a735 2
		   code = Option.ABSENT},
	   done)
d832 1
a832 2
		     code = Option.PRESENT code},
	     done)
@


1.40
log
@Added level parameter to basis. (This should have been revision 1.38, but it got lost).
@
text
@d13 3
d260 2
d354 7
d365 2
a366 1
                 code		: Module Option.opt}
d458 5
d526 5
d708 21
d738 1
d836 1
@


1.39
log
@ Moved over from machine/ for SPARC/MIPS targetting
@
text
@d13 3
d382 1
@


1.38
log
@Added level field to Basis.
@
text
@d147 2
a148 2
require "../machine/mach_cg";
require "../machine/machprint";
a378 1
                                               _,
@


1.37
log
@Changed type of compile to indicate whether the file in question is pervasive
@
text
@d13 3
d379 1
@


1.36
log
@Removed spurious ".sml" from require declarations.
@
text
@d13 3
d147 1
d154 1
d173 1
d176 1
d230 2
d240 1
a240 1
    structure Info = Parser.Lexer.Info
d257 1
a257 1
    type tokenstream = Parser.Lexer.TokenStream
d419 2
a420 2
      TOKENSTREAM of Parser.Lexer.TokenStream |
      TOKENSTREAM1 of Parser.Lexer.TokenStream |
d436 1
a436 1
                source =
d438 1
a438 1
        val filename =
d440 5
a444 3
            TOKENSTREAM token_stream => Parser.Lexer.associated_filename token_stream
          | TOKENSTREAM1 token_stream => Parser.Lexer.associated_filename token_stream
          | TOPDEC (filename,_,_) => filename
d455 2
d493 2
a494 1
			require_function (require_value, module, location, done)
d496 2
d624 20
d646 4
a649 2
              TOPDEC (_, absyn,_) => 
                compile_topdec (environments, absyn)
d651 1
d658 1
d660 1
d670 1
@


1.36.1.1
log
@Fork for bug fixing
@
text
@a12 3
 *  Revision 1.36  1993/08/16  11:18:35  daveb
 *  Removed spurious ".sml" from require declarations.
 *
@


1.35
log
@Removed Io parameter.
@
text
@d13 3
d144 2
a145 2
require "../lambda/environ.sml";
require "../lambda/environprint.sml";
@


1.34
log
@Modified to disallow mid file requires
@
text
@d13 3
a128 1
require "../main/io";
a164 1
                  structure Io : IO
@


1.33
log
@structure Option.
@
text
@d13 3
d444 1
a444 1
             signatures, identifiers, done) =
d460 1
a460 1
                                 signatures, identifiers, done),
d464 13
a476 8
                  let
                    val (require_value,
                         module_expression,
                         BASIS {parser_basis = require_parser_basis,
                                type_basis = require_type_basis,
                                lambda_environment = require_lambda_environment,
                                ...}, done) =
                      require_function (require_value, module, location, done)
d478 16
a493 16
                    val (require_lambda_environment, require_bindings) =
                      LambdaModule.unpack (require_lambda_environment, module_expression)
                  in
                    (require_value,
                     Parser.augment_pB (total_parser_basis, require_parser_basis),
                     Basis.basis_circle_plus_basis (total_type_basis, require_type_basis),
                     Environ.augment_top_env (total_lambda_environment, require_lambda_environment),
                     parser_basis,
                     type_basis,
                     lambda_environment,
                     lambda_bindings @@ require_bindings,
                     debug_info,
                     signatures,
                     identifiers,
		     done)
                  end
d507 1
a507 1
		     done)
d561 1
a561 1
		       done)
d568 1
a568 1
                               signatures, identifiers, done),
d585 1
a585 1
		  done),
d602 1
a602 1
               [], done)
d609 6
a614 1
                compile_topdec (parse_topdec (environments, token_stream))
@


1.32
log
@Augmented tyoe basis before passing it to trans_topdec.
@
text
@d13 3
d122 1
d161 1
d228 2
a326 2
    datatype 'a option = ABSENT | PRESENT of 'a

d331 1
a331 1
                 code		: Module option}
d628 1
a628 1
		   code = ABSENT},
d725 1
a725 1
		     code = PRESENT code},
@


1.31
log
@Added basis argument to Lambda.trans_top_dec.
Removed EXCEPTION identifier class.
@
text
@d13 4
d523 5
d532 1
a532 1
			   debug_info, total_type_basis)
d536 3
a538 2
		       Basis.basis_circle_plus_basis (total_type_basis, topdec_type_basis),
		       Environ.augment_top_env (total_lambda_environment, topdec_lambda_environment),
d540 4
a543 2
		       Basis.basis_circle_plus_basis (type_basis, topdec_type_basis),
		       Environ.augment_top_env (lambda_environment, topdec_lambda_environment),
@


1.30
log
@Changed to use new mod_rules interface. All unnecessary
assembly calculations removed. More needs to be done, to decouple
assemblies for Shell.Make.make from those for use
@
text
@d13 5
d173 3
a175 3
                    Mir_Cg.EnvironTypes.LambdaTypes
                  sharing Mir_Cg.EnvironTypes =
                    Environ.EnvironTypes =
d196 1
a310 1
      EXCEPTION of Ident.ValId |
d355 1
a355 2
                                                              Datatypes.VE (_, value_env),
                                                              Datatypes.VE (_, exception_env)))) =
a368 5
          (fn (identifiers, valid, _) => (EXCEPTION valid)::identifiers)
          (identifiers, exception_env)

        val identifiers =
          Map.fold
d521 3
a523 2
			Lambda.trans_top_dec
			(options,absyn, total_lambda_environment, debug, debug_info)
d661 1
a661 1
	      (options, lambda_expression, lambda_environment, filename, debug_info)
@


1.29
log
@Added Location parameter to Info.wrap
@
text
@d13 3
d201 1
d226 3
d495 11
a505 1
			error_wrap Mod_Rules.check_topdec (options,absyn, total_type_basis)
@


1.28
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d13 3
d208 1
d413 1
a413 1
        val error_wrap = Info.wrap info_opts (Info.FATAL, Info.RECOVERABLE, Info.FAULT)
@


1.27
log
@Removed integer parameter
@
text
@d13 3
d176 1
a176 1
                  sharing Mod_Rules.BasisTypes = Basis.BasisTypes
@


1.26
log
@Changed compile to return list of modules compiled. Also implemented
no_execute option for make to give make -n behaviouor
@
text
@d13 4
a113 1
require "../utils/integer";
a139 1
                  structure Integer : INTEGER
@


1.25
log
@Changes to lambda optimiser to allow removal of inlining for tracing
@
text
@d13 3
d387 2
a388 1
                              compiler_options = Options.COMPILEROPTIONS{debug,...},
d395 1
a395 1
                                       ...})
d417 1
a417 1
             signatures, identifiers) =
d433 1
a433 1
                                 signatures, identifiers),
d443 2
a444 2
                                ...}) =
                      require_function (require_value, module, location)
d459 2
a460 1
                     identifiers)
d462 29
a490 15
              | absyn => 
                  let
                    val topdec_type_basis =
		      error_wrap Mod_Rules.check_topdec (options,absyn, total_type_basis)
		    val _ =
		      if #show_absyn list_opts then
			(Info.listing_fn
			 info_opts
			 (3, fn stream => output(stream, "The abstract syntax\n"));
			 Info.listing_fn
			 info_opts
			 (3, fn stream =>
			  output(stream, TopdecPrint.topdec_to_string print_options absyn));
			 Info.listing_fn
			 info_opts
d493 19
a511 18
		      else ()
                    val (topdec_lambda_environment, topdec_lambda_bindings, debug_info) =
                      error_wrap
                      Lambda.trans_top_dec
                      (options,absyn, total_lambda_environment, debug, debug_info)
                  in
                    (require_value,
                     total_parser_basis,
                     Basis.basis_circle_plus_basis (total_type_basis, topdec_type_basis),
                     Environ.augment_top_env (total_lambda_environment, topdec_lambda_environment),
                     parser_basis,
                     Basis.basis_circle_plus_basis (type_basis, topdec_type_basis),
                     Environ.augment_top_env (lambda_environment, topdec_lambda_environment),
                     lambda_bindings @@ topdec_lambda_bindings,
                     debug_info,
                     extract_signatures (signatures, absyn),
                     extract_identifiers (identifiers, topdec_type_basis))
                  end
d517 1
a517 1
                               signatures, identifiers),
d533 2
a534 1
                  identifiers),
d551 1
a551 1
               [])
d574 1
a574 2
        val (lambda_environment, lambda_expression) =
          LambdaModule.pack (lambda_environment, lambda_bindings)
d576 11
a586 15
	val _ =
	  if #show_lambda list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The unoptimised lambda code\n"));
	     Info.listing_fn info_opts
	     (3, fn stream =>
	      LambdaPrint.output_lambda print_options (stream, lambda_expression)))
	  else ()
(*
        val _ = diagnostic_fn
          (5, fn (_, outstream) =>
           (output (outstream, "lambda:\n");
            LambdaPrint.output_lambda print_options (outstream, lambda_expression)))
*)
d588 4
a591 1
        (* Optimise the lambda expression *)
d593 9
a601 1
        val lambda_expression = LambdaOptimiser.optimise options lambda_expression
d603 1
a603 26
	val _ =
	  if #show_opt_lambda list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The optimised lambda code\n"));
	     Info.listing_fn info_opts
	     (3, fn stream =>
	      LambdaPrint.output_lambda print_options (stream, lambda_expression)))
	  else ()
(*
        val _ = diagnostic_fn
          (2, fn (_, outstream) =>
           (output (outstream, "optimised lambda:\n");
            LambdaPrint.output_lambda print_options (outstream, lambda_expression)))
*)
	val _ =
	  if #show_environ list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The environment\n"));
	     Info.listing_fn info_opts
	     (3, EnvironPrint.printtopenv print_options lambda_environment);
	     Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "\n")))
	  else ()
d605 1
a605 2
        (* Generate intermediate code from the lambda expression and *)
        (* optimise it *)
d607 9
a615 12
        val (mir, debug_info) =
          error_wrap
 	    Mir_Cg.mir_cg
	    (options, lambda_expression, lambda_environment, filename, debug_info)
	val _ =
	  if #show_mir list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The unoptimised intermediate code\n"));
	     Info.listing_fn info_opts (3, MirPrint.print_mir_code mir))
	  else
	    ()
d617 11
a627 9
        val mir = MirOptimiser.optimise mir
	val _ =
	  if #show_opt_mir list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The optimised intermediate code\n"));
	     Info.listing_fn info_opts (3, MirPrint.print_mir_code mir))
	  else
	    ()
d629 2
a630 1
        (* Generate the module machine code from the MIR *)
d632 12
a643 16
        val ((code, debug_info), code_list_list) =
          let
            val {gc, non_gc, fp} = MirOptimiser.machine_register_assignments
          in
            error_wrap
	      Mach_Cg.mach_cg
	      (options, mir, (gc, non_gc, fp), debug_info)
          end
	val _ =
	  if #show_mach list_opts then
	    (Info.listing_fn
	     info_opts
	     (3, fn stream => output(stream, "The final machine code\n"));
	     Info.listing_fn info_opts (3, MachPrint.print_mach_code code_list_list))
	  else
	    ()
d645 40
a684 9
      in
        (require_value,
         RESULT {basis = BASIS {parser_basis = parser_basis,
                                type_basis = type_basis,
                                lambda_environment = lambda_environment,
                                debug_info = debug_info},
                 signatures = signatures,
                 identifiers = identifiers,
                 code = PRESENT code})
@


1.24
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d13 3
d574 1
a574 1
        val lambda_expression = LambdaOptimiser.optimise print_options lambda_expression
@


1.23
log
@Removed Debugger_Types from the signature
@
text
@d13 3
d231 6
a236 6
     fun adjust_compiler_basis_debug_info(BASIS{parser_basis,type_basis,lambda_environment,...},
                                          new_debug_info) =
       BASIS{parser_basis=parser_basis,
             type_basis=type_basis,
             lambda_environment=lambda_environment,
             debug_info=new_debug_info}
d238 6
a243 1
     fun get_basis_debug_info(BASIS{debug_info,...}) = debug_info
d245 7
a251 5
     fun clear_debug_info(BASIS{parser_basis,type_basis,lambda_environment,...}) =
       BASIS{parser_basis=parser_basis,
             type_basis=type_basis,
             lambda_environment=lambda_environment,
             debug_info = Debugger_Types.empty_information}
@


1.22
log
@Added parserbasis field to source type
@
text
@d13 3
d190 1
d201 1
@


1.21
log
@Options changes
Signature revisions
@
text
@d13 4
d360 2
a361 1
      TOPDEC of string * Parser.Absyn.TopDec
d380 1
a380 1
          | TOPDEC (filename, _) => filename
d504 3
a506 1
               Parser.empty_pB,
d516 2
a517 1
              TOPDEC (_, absyn) => compile_topdec (environments, absyn)
@


1.20
log
@Options & Info changes
Removed Parser and BasisTypes substructures from signature
@
text
@d13 4
d132 2
a133 1
                    Parser.Options
d152 1
a152 1
                    Mach_Cg.Sparc_Assembly.MirTypes =
a154 1
		  sharing Mach_Cg.Sparc_Assembly = MachPrint.Sparc_Assembly
a155 2
                  sharing Basis.BasisTypes.Datatypes =
                    Mir_Cg.MirTypes.Debugger_Types.Datatypes
d159 8
a166 1
                  sharing type Parser.Absyn.Type = Basis.BasisTypes.Datatypes.Type
d179 1
a179 2
    structure Debugger_Types = MirTypes.Debugger_Types
    structure MachTypes = Mach_Cg.Sparc_Assembly.Sparc_Opcodes.MachTypes
d186 1
a186 1
    structure IdentClass = Datatypes.Ident
d188 3
d263 6
a268 6
      VALUE of IdentClass.ValId |
      EXCEPTION of IdentClass.ValId |
      TYPE of IdentClass.TyCon |
      STRUCTURE of IdentClass.StrId |
      SIGNATURE of IdentClass.SigId |
      FUNCTOR of IdentClass.FunId
d274 1
a274 1
                 signatures	: (IdentClass.SigId, Parser.Absyn.SigExp) Map.T,
d276 1
a276 1
                 code		: MachTypes.module option}
d359 5
a363 3
                 Options.OPTIONS(Options.LISTINGOPTIONS list_opts,
                                 compiler_options as Options.COMPILEROPTIONS{debug,...},
                                 print_options))
d437 1
a437 1
		      error_wrap Mod_Rules.check_topdec (print_options,absyn, total_type_basis)
d455 1
a455 1
                      (print_options,absyn, total_lambda_environment, debug, debug_info)
d477 1
a477 1
                val (absyn, topdec_parser_basis) = error_wrap Parser.parse_topdec (print_options,token_stream, total_parser_basis)
d583 1
a583 1
	    (compiler_options, lambda_expression, lambda_environment, filename, debug_info)
d611 1
a611 1
	      (compiler_options, mir, (gc, non_gc, fp), debug_info)
@


1.19
log
@Changes for typechecker BASISTYPES signature
@
text
@d13 3
d122 7
d131 3
a133 6
		    Basis.BasisTypes.Info =
		    Lambda.Debugger_Types.Info =
		    LambdaPrint.Info =
		    TopdecPrint.Info =
		    LambdaOptimiser.Info =
		    EnvironPrint.Info
d153 1
a153 2
                    Mir_Cg.MirTypes.Debugger_Types.Datatypes =
		    Parser.Absyn.Datatypes
d156 2
d173 2
a174 1
    structure Info = BasisTypes.Info
d180 4
d347 6
a352 4
    fun compile (options as MirTypes.OPTIONS {info_opts, list_opts = MirTypes.BELO list_opts,
					      debug, ...})
    		require_function
                (require_value, BASIS {parser_basis = initial_parser_basis,
d424 1
a424 1
		      error_wrap Mod_Rules.check_topdec (absyn, total_type_basis)
d433 1
a433 1
			  output(stream, TopdecPrint.topdec_to_string info_opts absyn));
d440 3
a442 1
                      error_wrap Lambda.trans_top_dec (absyn, total_lambda_environment, debug, debug_info)
d464 1
a464 1
                val (absyn, topdec_parser_basis) = error_wrap Parser.parse_topdec (token_stream, total_parser_basis)
d466 1
a466 1
                diagnostic (2, fn _ => ["parsed topdec:\n", TopdecPrint.topdec_to_string info_opts absyn]);
d524 1
a524 1
	      LambdaPrint.output_lambda info_opts (stream, lambda_expression)))
d530 1
a530 1
            LambdaPrint.output_lambda info_opts (outstream, lambda_expression)))
d535 1
a535 1
        val lambda_expression = LambdaOptimiser.optimise info_opts lambda_expression
d544 1
a544 1
	      LambdaPrint.output_lambda info_opts (stream, lambda_expression)))
d550 1
a550 1
            LambdaPrint.output_lambda info_opts (outstream, lambda_expression)))
d558 1
a558 1
	     (3, EnvironPrint.printtopenv info_opts lambda_environment);
d570 1
a570 1
	    (options, lambda_expression, lambda_environment, filename, debug_info)
d598 1
a598 1
	      (options, mir, (gc, non_gc, fp), debug_info)
@


1.18
log
@Changed functor parameter
@
text
@d13 3
a89 3
require "../typechecker/types";
require "../typechecker/valenv";
require "../typechecker/tyenv";
d91 1
a107 1
                  structure Types : TYPES
d109 1
a109 2
                  structure Valenv : VALENV
                  structure Tyenv : TYENV
d121 1
a121 1
		    Mod_Rules.Basis.Sigenv.Sigma.Nameset.Info =
d144 2
a145 5
                  sharing Types.Datatypes =
                    Valenv.Datatypes =
                    Tyenv.Datatypes =
                    Mod_Rules.Basis.Sigenv.Sigma.Nameset.Datatypes =
                    Mod_Rules.Basis.Tyvarenv.Datatypes =
d157 1
a157 1
    structure Basis = Mod_Rules.Basis
d164 2
a165 2
    structure Map = Basis.Tyvarenv.Datatypes.NewMap
    structure Info = Parser.Lexer.Info
d168 1
a168 1
    structure Datatypes = Basis.Tyvarenv.Datatypes
d181 1
a181 1
                type_basis		: Basis.Basis,
d280 7
a286 7
                             Basis.BASIS (_,
                                          Basis.Funenv.FUNENV functor_env,
                                          Basis.Sigenv.SIGENV signature_env,
                                          Datatypes.ENV (Datatypes.SE structure_env,
                                                         Datatypes.TE type_env,
                                                         Datatypes.VE (_, value_env),
                                                         Datatypes.VE (_, exception_env)))) =
d474 1
a474 1
               Map.empty' Valenv.Datatypes.Ident.sigid_lt,
@


1.17
log
@Modified to print abstract syntax, lambda calculus etc on request
@
text
@d13 3
a89 1
require "../typechecker/strenv";
a109 1
                  structure Strenv : STRENV
a146 1
                    Strenv.Datatypes =
@


1.16
log
@Modified to deal with extra options for code listing
@
text
@d13 3
d77 1
d79 1
d83 1
d99 1
d102 1
d104 1
d125 2
a126 1
		    LambdaOptimiser.Info
d134 2
a135 1
                    Primitives.EnvironTypes
d140 2
a141 1
                    Mach_Cg.Sparc_Assembly.MirTypes
d143 1
d338 2
a339 1
    fun compile (options as MirTypes.OPTIONS {info_opts, debug, ...})
d412 16
a427 1
                    val topdec_type_basis = error_wrap Mod_Rules.check_topdec (absyn, total_type_basis)
d504 10
d518 1
d524 10
d538 12
d558 9
d568 8
d579 1
a579 1
        val ((code, debug_info), _) =
d587 9
@


1.15
log
@Removed a number of duplicated signatures and structures
@
text
@d13 3
d129 1
a129 1
                    Mach_Cg.MirTypes
d154 1
a154 1
    structure MachTypes = Mach_Cg.MachTypes
d500 1
a500 1
        val (code, debug_info) =
@


1.14
log
@Fixed sharing constraint
@
text
@d13 3
a78 1
require "../typechecker/datatypes";
a109 1
		    Mir_Cg.MirTypes.Info =
d134 2
a135 1
                    Mir_Cg.MirTypes.Debugger_Types.Datatypes
a137 1
                  sharing Parser.Absyn.IdentClass = Valenv.Datatypes.Ident
a155 1
    structure IdentClass = Absyn.IdentClass
d157 1
d227 6
a232 6
      VALUE of Parser.Absyn.IdentClass.ValId |
      EXCEPTION of Parser.Absyn.IdentClass.ValId |
      TYPE of Parser.Absyn.IdentClass.TyCon |
      STRUCTURE of Parser.Absyn.IdentClass.StrId |
      SIGNATURE of Parser.Absyn.IdentClass.SigId |
      FUNCTOR of Parser.Absyn.IdentClass.FunId
d238 1
a238 1
                 signatures	: (Parser.Absyn.IdentClass.SigId, Parser.Absyn.SigExp) Map.T,
@


1.13
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d13 3
d107 1
a107 1
		    Mod_Rules.Basis.Sigenv.Sigma.Nameset.Info
d109 1
@


1.12
log
@Modified to remove redundant info signatures
@
text
@d13 3
d102 6
a107 3
                  sharing Parser.Lexer.Info = Lambda.Info =
		    Mod_Rules.Basis.Sigenv.Sigma.Nameset.Info = Mach_Cg.Info =
		    Mir_Cg.Info = LambdaPrint.Info = TopdecPrint.Info =
d144 2
a145 1
    structure Debugger_Types = Mir_Cg.MirTypes.Debugger_Types
a236 6
    datatype options =
      OPTIONS of {info_opts	        : Info.options,
                  debug			: bool,
                  profile		: bool}


d317 2
a318 2
    fun compile require_function
                (OPTIONS {info_opts, debug, profile})
d485 3
a487 1
          error_wrap Mir_Cg.mir_cg (lambda_expression, lambda_environment, filename, debug_info, debug)
d496 3
a498 1
            error_wrap Mach_Cg.mach_cg (mir, (gc, non_gc, fp), debug, debug_info)
@


1.11
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d13 4
d99 4
a102 1
                  sharing Parser.Lexer.Info = Lambda.Info = Mod_Rules.Info = Mach_Cg.Info = Mir_Cg.Info = LambdaPrint.Info = TopdecPrint.Info = LambdaOptimiser.Info
@


1.10
log
@Added clear_debug_info function
@
text
@d13 3
d95 1
a95 1
                  sharing Parser.Lexer.Info = Lambda.Info = Mod_Rules.Info = Mach_Cg.Info = Mir_Cg.Info
d408 1
a408 1
                diagnostic (2, fn _ => ["parsed topdec:\n", TopdecPrint.topdec_to_string absyn]);
d462 1
a462 1
            LambdaPrint.output_lambda (outstream, lambda_expression)))
d466 1
a466 1
        val lambda_expression = LambdaOptimiser.optimise lambda_expression
d471 1
a471 1
            LambdaPrint.output_lambda (outstream, lambda_expression)))
@


1.9
log
@Changed the result type to allow the code to be deleted
@
text
@d13 3
d169 6
@


1.8
log
@Modified sharing constraints to remove superfluous structures
@
text
@d13 3
d203 2
d209 1
a209 1
                 code		: MachTypes.module}
d484 1
a484 1
                 code = code})
@


1.7
log
@Added a few debug_info functions
@
text
@d13 3
d86 1
a86 1
                  sharing Parser.Info = Lambda.Info = Mod_Rules.Info = Mach_Cg.Info = Mir_Cg.Info
d125 1
a125 1
    structure Info = Parser.Info
@


1.6
log
@Changed Error structure to Info
@
text
@d13 3
d152 8
@


1.5
log
@Removed an obsolete sharing constraint.
@
text
@d13 3
d80 1
d119 1
a119 1
    structure Error = Parser.Error
d193 1
a193 1
      OPTIONS of {error_output_level	: Error.severity,
d279 1
a279 1
                (OPTIONS {error_output_level, debug, profile})
d292 1
a292 1
        val error_wrap = Error.wrap (Error.FATAL, Error.RECOVERABLE, error_output_level)
@


1.4
log
@Modified to use sigid_lt instead of sigid_order
@
text
@d13 3
a86 2
                  sharing MirOptimiser.Map =
                    Mach_Cg.MirTypes.Debugger_Types.Datatypes.NewMap
@


1.3
log
@Added location information to the `require' topdec and passed
this through to the require function passed to compile.
@
text
@d13 4
d397 1
a397 1
               Map.empty' Valenv.Datatypes.Ident.sigid_order,
@


1.2
log
@Added a source type and split parsing away from the rest of compilation
in order to implement it.
@
text
@d13 4
d44 1
d62 1
d91 2
a92 1
                    Mod_Rules.Basis.Tyvarenv.Datatypes
d96 1
d105 2
d109 1
a109 1
    structure Map = Basis.Sigenv.Sigma.Nameset.Datatypes.NewMap
d315 1
a315 1
                Absyn.REQUIREtopdec module =>
d318 1
d323 4
a326 1
                      require_function (require_value, module)
d335 1
a335 1
                     lambda_bindings,
@


1.1
log
@Initial revision
@
text
@d12 4
a15 1
 *  $Log$
d167 6
d254 5
d265 1
a265 1
                (consume, token_stream) =
d267 6
a272 1
        val filename = Parser.Lexer.associated_filename token_stream
d276 5
a280 3
          (1, fn _ => ["Consuming ",
                       if consume then "`" else "one topdec from `",
                         filename, "'"])
d282 6
a287 1
        local
d289 8
a296 8
          (*  == Compile a single topdec ==
           *
           *  Two environments are maintained while compiling topdecs: one
           *  is a `total' which includes all declarations made so far
           *  including those from other modules and the initial basis, the
           *  other is the sum of the topdecs actually compiled here, and
           *  forms the result.
           *)
d298 6
a303 9
          fun compile_topdec (require_value,
                              total_parser_basis, total_type_basis, total_lambda_environment,
                              parser_basis, type_basis, lambda_environment,
                              lambda_bindings, debug_info,
                              signatures, identifiers) =
            let
              val (absyn, topdec_parser_basis) = error_wrap Parser.parse_topdec (token_stream, total_parser_basis)
              val _ = diagnostic (2, fn _ => ["parsed topdec:\n", TopdecPrint.topdec_to_string absyn])
            in
d333 1
a333 1
                     Parser.augment_pB (total_parser_basis, topdec_parser_basis),
d336 1
a336 1
                     Parser.augment_pB (parser_basis, topdec_parser_basis),
a343 1
            end
d345 23
a367 1
        in
d369 12
a380 1
          (* Consume one or many topdecs *)
d382 6
a387 20
          val (require_value,
               _, _, _,
               parser_basis, type_basis,
               lambda_environment, lambda_bindings, debug_info,
               signatures, identifiers) =
            let
              val environment =
                (require_value,
                 initial_parser_basis,
                 initial_type_basis,
                 initial_lambda_environment,
                 Parser.empty_pB,
                 Basis.empty_basis,
                 Environ.empty_top_env,
                 [],
                 Debugger_Types.empty_information,
                 Map.empty' Valenv.Datatypes.Ident.sigid_order,
                 [])
            in
              if consume then
d389 1
a389 1
                  fun consume environment =
d391 1
a391 1
                      environment
d393 1
a393 1
                      consume (compile_topdec environment)
d395 1
a395 1
                  consume environment
d397 1
a397 3
              else
                compile_topdec environment
            end
a398 2
        end

d436 7
a442 7
         {basis = BASIS {parser_basis = parser_basis,
                         type_basis = type_basis,
                         lambda_environment = lambda_environment,
                         debug_info = debug_info},
          signatures = signatures,
          identifiers = identifiers,
          code = code})
@
