head	1.262;
access;
symbols
	MLW_daveb_inline_1_4_99:1.262.1
	MLWorks_21c0_1999_03_25:1.262
	MLWorks_20c1_1998_08_20:1.251
	MLWorks_20c0_1998_08_04:1.251
	MLWorks_20b2c2_1998_06_19:1.251
	MLWorks_20b2_Windows_1998_06_12:1.251
	MLWorks_20b1c1_1998_05_07:1.251
	MLWorks_20b0_1998_04_07:1.247
	MLWorks_20b0_1998_03_20:1.247
	MLWorks_20m2_1998_02_16:1.246
	MLWorks_20m1_1997_10_23:1.241
	MLWorks_11r1:1.235.1.2.1.1.1
	MLWorks_workspace_97:1.240.2
	MLWorks_dt_wizard:1.240.1
	MLWorks_11c0_1997_09_09:1.235.1.2.1.1
	MLWorks_10r3:1.235.1.2.3
	MLWorks_10r2_551:1.235.1.2.2
	MLWorks_11:1.235.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.235.1.2
	MLWorks_20m0_1997_06_20:1.240
	MLWorks_1_0_r2c2_1997_06_14:1.235.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.235.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.235.1
	MLWorks_BugFix_1997_04_24:1.236
	MLWorks_1_0_r2_Win32_1997_04_11:1.235
	MLWorks_1_0_r2_Unix_1997_04_04:1.235
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.230.3.1.1
	MLWorks_gui_1996_12_18:1.230.4
	MLWorks_1_0_Win32_1996_12_17:1.230.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.230.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.230.1.1
	MLWorks_1_0_Irix_1996_11_28:1.230.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.230.2
	MLWorks_1_0_Unix_1996_11_14:1.230.1
	MLWorks_Open_Beta2_1996_10_11:1.228.2
	MLWorks_License_dev:1.228.1
	MLWorks_1_open_beta_1996_09_13:1.227.1
	MLWorks_Open_Beta_1996_08_22:1.226
	MLWorks_Beta_1996_07_02:1.223
	MLWorks_Beta_1996_06_07:1.223
	MLWorks_Beta_1996_06_06:1.223
	MLWorks_Beta_1996_06_05:1.223
	MLWorks_Beta_1996_06_03:1.223
	MLWorks_Beta_1996_05_31:1.223
	MLWorks_Beta_1996_05_30:1.222
	ML_beta_release_12/08/94:1.192
	ML_beta_release_03/08/94:1.192
	ML_revised_beta_release_25/05/94:1.190
	ML_final_beta_release_02/03/94:1.186
	mlworks-28-01-1994:1.181
	Release:1.170
	mlworks-beta-01-09-1993:1.170
	MLWorks-1-0-4-29/01/1993:1.140
	MLWorks-1-0-3-21/12/1992:1.138
	MLWorks-1-0-2-15/12/1992:1.137
	MLWorks-1-0-1-04/12/1992:1.134
	checkpoint_17_08_92:1.99
	Ten15_release_19-08-91:1.14
	ten15_release:1.8
	ten15:1.8;
locks; strict;
comment	@ * @;


1.262
date	99.03.23.17.37.54;	author mitchell;	state Exp;
branches
	1.262.1.1;
next	1.261;

1.261
date	99.03.18.08.53.40;	author mitchell;	state Exp;
branches;
next	1.260;

1.260
date	99.02.12.12.03.33;	author mitchell;	state Exp;
branches;
next	1.259;

1.259
date	99.02.10.12.37.01;	author mitchell;	state Exp;
branches;
next	1.258;

1.258
date	99.02.09.10.28.40;	author mitchell;	state Exp;
branches;
next	1.257;

1.257
date	99.02.05.14.15.40;	author mitchell;	state Exp;
branches;
next	1.256;

1.256
date	99.02.05.11.56.19;	author mitchell;	state Exp;
branches;
next	1.255;

1.255
date	99.02.03.15.20.28;	author mitchell;	state Exp;
branches;
next	1.254;

1.254
date	98.10.22.16.07.47;	author jont;	state Exp;
branches;
next	1.253;

1.253
date	98.10.22.13.06.53;	author jont;	state Exp;
branches;
next	1.252;

1.252
date	98.06.24.10.54.02;	author jont;	state Exp;
branches;
next	1.251;

1.251
date	98.04.24.16.07.57;	author jont;	state Exp;
branches;
next	1.250;

1.250
date	98.04.24.15.31.24;	author mitchell;	state Exp;
branches;
next	1.249;

1.249
date	98.04.22.15.59.42;	author jont;	state Exp;
branches;
next	1.248;

1.248
date	98.04.02.12.50.17;	author jont;	state Exp;
branches;
next	1.247;

1.247
date	98.02.19.17.16.20;	author mitchell;	state Exp;
branches;
next	1.246;

1.246
date	98.02.06.11.26.08;	author johnh;	state Exp;
branches;
next	1.245;

1.245
date	98.01.30.17.52.34;	author jont;	state Exp;
branches;
next	1.244;

1.244
date	97.11.25.10.27.18;	author jont;	state Exp;
branches;
next	1.243;

1.243
date	97.11.13.11.19.16;	author jont;	state Exp;
branches;
next	1.242;

1.242
date	97.10.20.20.24.49;	author jont;	state Exp;
branches;
next	1.241;

1.241
date	97.10.08.17.45.58;	author daveb;	state Exp;
branches;
next	1.240;

1.240
date	97.05.27.15.50.31;	author jont;	state Exp;
branches
	1.240.1.1
	1.240.2.1;
next	1.239;

1.239
date	97.05.27.12.24.22;	author daveb;	state Exp;
branches;
next	1.238;

1.238
date	97.05.12.16.09.56;	author jont;	state Exp;
branches;
next	1.237;

1.237
date	97.05.02.16.41.29;	author jont;	state Exp;
branches;
next	1.236;

1.236
date	97.04.10.16.49.24;	author jont;	state Exp;
branches;
next	1.235;

1.235
date	97.03.25.11.44.35;	author matthew;	state Exp;
branches
	1.235.1.1;
next	1.234;

1.234
date	97.03.21.11.33.05;	author johnh;	state Exp;
branches;
next	1.233;

1.233
date	97.02.12.13.22.33;	author daveb;	state Exp;
branches;
next	1.232;

1.232
date	97.01.21.11.03.38;	author matthew;	state Exp;
branches;
next	1.231;

1.231
date	97.01.02.15.24.10;	author matthew;	state Exp;
branches;
next	1.230;

1.230
date	96.11.06.11.29.12;	author matthew;	state Exp;
branches
	1.230.1.1
	1.230.2.1
	1.230.3.1
	1.230.4.1;
next	1.229;

1.229
date	96.10.29.16.12.18;	author io;	state Exp;
branches;
next	1.228;

1.228
date	96.10.04.13.05.16;	author matthew;	state Exp;
branches
	1.228.1.1
	1.228.2.1;
next	1.227;

1.227
date	96.09.04.11.26.45;	author daveb;	state Exp;
branches
	1.227.1.1;
next	1.226;

1.226
date	96.08.06.14.21.39;	author andreww;	state Exp;
branches;
next	1.225;

1.225
date	96.07.30.10.57.46;	author daveb;	state Exp;
branches;
next	1.224;

1.224
date	96.07.18.17.20.04;	author jont;	state Exp;
branches;
next	1.223;

1.223
date	96.05.30.12.50.18;	author daveb;	state Exp;
branches;
next	1.222;

1.222
date	96.04.30.17.23.25;	author jont;	state Exp;
branches;
next	1.221;

1.221
date	96.04.29.15.00.26;	author matthew;	state Exp;
branches;
next	1.220;

1.220
date	96.04.02.11.17.59;	author daveb;	state Exp;
branches;
next	1.219;

1.219
date	96.03.27.10.58.03;	author stephenb;	state Exp;
branches;
next	1.218;

1.218
date	96.03.25.15.32.13;	author daveb;	state Exp;
branches;
next	1.217;

1.217
date	96.03.15.17.01.19;	author daveb;	state Exp;
branches;
next	1.216;

1.216
date	96.03.15.14.36.11;	author daveb;	state Exp;
branches;
next	1.215;

1.215
date	96.03.06.13.14.45;	author daveb;	state Exp;
branches;
next	1.214;

1.214
date	96.02.22.14.12.40;	author jont;	state Exp;
branches;
next	1.213;

1.213
date	96.02.09.15.02.26;	author daveb;	state Exp;
branches;
next	1.212;

1.212
date	95.12.12.11.31.56;	author daveb;	state Exp;
branches;
next	1.211;

1.211
date	95.12.05.11.31.00;	author daveb;	state Exp;
branches;
next	1.210;

1.210
date	95.10.25.17.58.56;	author jont;	state Exp;
branches;
next	1.209;

1.209
date	95.09.11.10.57.59;	author daveb;	state Exp;
branches;
next	1.208;

1.208
date	95.09.05.15.59.35;	author jont;	state Exp;
branches;
next	1.207;

1.207
date	95.08.01.14.25.35;	author matthew;	state Exp;
branches;
next	1.206;

1.206
date	95.05.31.10.05.32;	author matthew;	state Exp;
branches;
next	1.205;

1.205
date	95.05.02.12.07.08;	author matthew;	state Exp;
branches;
next	1.204;

1.204
date	95.04.28.15.43.35;	author jont;	state Exp;
branches;
next	1.203;

1.203
date	95.04.21.13.58.14;	author jont;	state Exp;
branches;
next	1.202;

1.202
date	95.04.20.14.09.10;	author jont;	state Exp;
branches;
next	1.201;

1.201
date	95.04.05.14.45.57;	author matthew;	state Exp;
branches;
next	1.200;

1.200
date	95.03.02.12.58.23;	author matthew;	state Exp;
branches;
next	1.199;

1.199
date	95.02.17.14.53.45;	author daveb;	state Exp;
branches;
next	1.198;

1.198
date	95.02.07.12.56.59;	author matthew;	state Exp;
branches;
next	1.197;

1.197
date	95.01.17.16.15.30;	author daveb;	state Exp;
branches;
next	1.196;

1.196
date	94.12.08.17.30.53;	author jont;	state Exp;
branches;
next	1.195;

1.195
date	94.10.13.11.25.51;	author matthew;	state Exp;
branches;
next	1.194;

1.194
date	94.10.10.10.28.43;	author matthew;	state Exp;
branches;
next	1.193;

1.193
date	94.09.19.13.56.59;	author matthew;	state Exp;
branches;
next	1.192;

1.192
date	94.07.29.17.31.23;	author daveb;	state Exp;
branches;
next	1.191;

1.191
date	94.07.19.16.02.33;	author matthew;	state Exp;
branches;
next	1.190;

1.190
date	94.04.07.16.38.01;	author jont;	state Exp;
branches;
next	1.189;

1.189
date	94.03.21.15.16.38;	author daveb;	state Exp;
branches;
next	1.188;

1.188
date	94.03.16.13.00.42;	author matthew;	state Exp;
branches;
next	1.187;

1.187
date	94.03.15.17.28.36;	author matthew;	state Exp;
branches;
next	1.186;

1.186
date	94.02.28.08.21.10;	author nosa;	state Exp;
branches;
next	1.185;

1.185
date	94.02.25.12.37.25;	author daveb;	state Exp;
branches;
next	1.184;

1.184
date	94.02.16.16.42.31;	author jont;	state Exp;
branches;
next	1.183;

1.183
date	94.02.08.14.52.17;	author daveb;	state Exp;
branches;
next	1.182;

1.182
date	94.02.01.16.14.57;	author daveb;	state Exp;
branches;
next	1.181;

1.181
date	94.01.18.16.06.02;	author matthew;	state Exp;
branches;
next	1.180;

1.180
date	94.01.13.13.05.55;	author matthew;	state Exp;
branches;
next	1.179;

1.179
date	94.01.11.17.00.37;	author matthew;	state Exp;
branches;
next	1.178;

1.178
date	94.01.10.15.17.39;	author matthew;	state Exp;
branches;
next	1.177;

1.177
date	93.12.17.17.24.28;	author io;	state Exp;
branches;
next	1.176;

1.176
date	93.12.15.13.53.39;	author matthew;	state Exp;
branches;
next	1.175;

1.175
date	93.11.15.14.17.31;	author nickh;	state Exp;
branches;
next	1.174;

1.174
date	93.11.05.09.57.58;	author jont;	state Exp;
branches;
next	1.173;

1.173
date	93.09.27.14.57.33;	author jont;	state Exp;
branches;
next	1.172;

1.172
date	93.09.17.14.02.30;	author nosa;	state Exp;
branches;
next	1.171;

1.171
date	93.09.15.18.48.38;	author jont;	state Exp;
branches;
next	1.170;

1.170
date	93.08.28.16.44.19;	author daveb;	state Exp;
branches
	1.170.1.1;
next	1.169;

1.169
date	93.08.26.18.59.00;	author daveb;	state Exp;
branches;
next	1.168;

1.168
date	93.08.26.12.55.27;	author richard;	state Exp;
branches;
next	1.167;

1.167
date	93.08.25.13.12.13;	author daveb;	state Exp;
branches;
next	1.166;

1.166
date	93.08.24.15.23.58;	author daveb;	state Exp;
branches;
next	1.165;

1.165
date	93.08.23.15.17.12;	author richard;	state Exp;
branches;
next	1.164;

1.164
date	93.08.19.14.35.28;	author daveb;	state Exp;
branches;
next	1.163;

1.163
date	93.08.17.16.34.07;	author daveb;	state Exp;
branches;
next	1.162;

1.162
date	93.08.12.14.08.09;	author jont;	state Exp;
branches;
next	1.161;

1.161
date	93.08.03.16.42.19;	author jont;	state Exp;
branches;
next	1.160;

1.160
date	93.07.15.15.50.36;	author nosa;	state Exp;
branches;
next	1.159;

1.159
date	93.07.12.10.55.27;	author daveb;	state Exp;
branches;
next	1.158;

1.158
date	93.06.30.13.21.18;	author daveb;	state Exp;
branches;
next	1.157;

1.157
date	93.06.02.17.40.47;	author jont;	state Exp;
branches;
next	1.156;

1.156
date	93.05.28.13.31.10;	author jont;	state Exp;
branches;
next	1.155;

1.155
date	93.05.28.10.35.42;	author matthew;	state Exp;
branches;
next	1.154;

1.154
date	93.05.27.12.45.32;	author jont;	state Exp;
branches;
next	1.153;

1.153
date	93.05.25.16.02.08;	author jont;	state Exp;
branches;
next	1.152;

1.152
date	93.05.18.17.01.55;	author jont;	state Exp;
branches;
next	1.151;

1.151
date	93.05.11.17.25.14;	author jont;	state Exp;
branches;
next	1.150;

1.150
date	93.05.11.12.49.27;	author jont;	state Exp;
branches;
next	1.149;

1.149
date	93.04.22.15.24.14;	author jont;	state Exp;
branches;
next	1.148;

1.148
date	93.04.21.13.12.32;	author jont;	state Exp;
branches;
next	1.147;

1.147
date	93.04.14.15.57.08;	author matthew;	state Exp;
branches;
next	1.146;

1.146
date	93.04.13.15.13.22;	author matthew;	state Exp;
branches;
next	1.145;

1.145
date	93.04.06.15.45.17;	author jont;	state Exp;
branches;
next	1.144;

1.144
date	93.03.12.11.58.09;	author matthew;	state Exp;
branches;
next	1.143;

1.143
date	93.03.09.12.57.29;	author matthew;	state Exp;
branches;
next	1.142;

1.142
date	93.02.09.09.49.00;	author matthew;	state Exp;
branches;
next	1.141;

1.141
date	93.02.04.16.23.52;	author matthew;	state Exp;
branches;
next	1.140;

1.140
date	93.01.28.09.52.22;	author jont;	state Exp;
branches;
next	1.139;

1.139
date	93.01.05.18.18.23;	author jont;	state Exp;
branches;
next	1.138;

1.138
date	92.12.17.10.40.15;	author clive;	state Exp;
branches;
next	1.137;

1.137
date	92.12.08.20.21.14;	author jont;	state Exp;
branches;
next	1.136;

1.136
date	92.12.08.14.06.29;	author clive;	state Exp;
branches;
next	1.135;

1.135
date	92.12.08.13.41.44;	author daveb;	state Exp;
branches;
next	1.134;

1.134
date	92.12.02.15.57.18;	author daveb;	state Exp;
branches;
next	1.133;

1.133
date	92.12.02.14.05.47;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	92.11.27.15.42.02;	author daveb;	state Exp;
branches;
next	1.131;

1.131
date	92.11.25.17.30.47;	author matthew;	state Exp;
branches;
next	1.130;

1.130
date	92.11.19.19.17.44;	author jont;	state Exp;
branches;
next	1.129;

1.129
date	92.11.18.11.51.50;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	92.11.07.15.40.00;	author richard;	state Exp;
branches;
next	1.127;

1.127
date	92.11.04.16.39.59;	author jont;	state Exp;
branches;
next	1.126;

1.126
date	92.11.03.12.29.09;	author daveb;	state Exp;
branches;
next	1.125;

1.125
date	92.11.03.12.23.36;	author jont;	state Exp;
branches;
next	1.124;

1.124
date	92.10.27.17.11.42;	author jont;	state Exp;
branches;
next	1.123;

1.123
date	92.10.15.16.11.23;	author clive;	state Exp;
branches;
next	1.122;

1.122
date	92.10.14.12.06.31;	author richard;	state Exp;
branches;
next	1.121;

1.121
date	92.10.12.12.00.53;	author clive;	state Exp;
branches;
next	1.120;

1.120
date	92.10.01.13.56.35;	author richard;	state Exp;
branches;
next	1.119;

1.119
date	92.09.24.06.21.11;	author richard;	state Exp;
branches;
next	1.118;

1.118
date	92.09.23.16.43.48;	author jont;	state Exp;
branches;
next	1.117;

1.117
date	92.09.21.18.16.06;	author jont;	state Exp;
branches;
next	1.116;

1.116
date	92.09.16.08.45.36;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	92.09.15.12.30.57;	author jont;	state Exp;
branches;
next	1.114;

1.114
date	92.09.10.10.35.09;	author richard;	state Exp;
branches;
next	1.113;

1.113
date	92.09.09.10.04.28;	author clive;	state Exp;
branches;
next	1.112;

1.112
date	92.09.08.11.55.34;	author richard;	state Exp;
branches;
next	1.111;

1.111
date	92.09.07.10.26.44;	author jont;	state Exp;
branches;
next	1.110;

1.110
date	92.09.04.13.25.59;	author richard;	state Exp;
branches;
next	1.109;

1.109
date	92.09.01.16.44.33;	author clive;	state Exp;
branches;
next	1.108;

1.108
date	92.08.26.17.19.05;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	92.08.26.09.12.49;	author clive;	state Exp;
branches;
next	1.106;

1.106
date	92.08.25.19.01.47;	author davidt;	state Exp;
branches;
next	1.105;

1.105
date	92.08.25.16.19.59;	author richard;	state Exp;
branches;
next	1.104;

1.104
date	92.08.25.13.32.03;	author clive;	state Exp;
branches;
next	1.103;

1.103
date	92.08.20.18.00.17;	author davidt;	state Exp;
branches;
next	1.102;

1.102
date	92.08.19.14.02.54;	author davidt;	state Exp;
branches;
next	1.101;

1.101
date	92.08.18.15.00.55;	author davidt;	state Exp;
branches;
next	1.100;

1.100
date	92.08.17.11.31.07;	author davidt;	state Exp;
branches;
next	1.99;

1.99
date	92.08.14.16.44.37;	author davidt;	state Exp;
branches;
next	1.98;

1.98
date	92.08.12.13.28.21;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	92.08.10.17.28.02;	author davidt;	state Exp;
branches;
next	1.96;

1.96
date	92.08.10.12.00.15;	author davidt;	state Exp;
branches;
next	1.95;

1.95
date	92.08.10.09.53.49;	author clive;	state Exp;
branches;
next	1.94;

1.94
date	92.08.07.16.01.18;	author clive;	state Exp;
branches;
next	1.93;

1.93
date	92.08.06.17.08.29;	author jont;	state Exp;
branches;
next	1.92;

1.92
date	92.08.05.18.25.25;	author jont;	state Exp;
branches;
next	1.91;

1.91
date	92.07.23.12.45.11;	author clive;	state Exp;
branches;
next	1.90;

1.90
date	92.07.23.08.06.29;	author clive;	state Exp;
branches;
next	1.89;

1.89
date	92.07.22.16.09.52;	author jont;	state Exp;
branches;
next	1.88;

1.88
date	92.07.22.15.35.17;	author jont;	state Exp;
branches;
next	1.87;

1.87
date	92.07.21.18.40.55;	author jont;	state Exp;
branches;
next	1.86;

1.86
date	92.07.14.16.17.25;	author richard;	state Exp;
branches;
next	1.85;

1.85
date	92.07.08.15.34.21;	author clive;	state Exp;
branches;
next	1.84;

1.84
date	92.07.03.13.43.21;	author davida;	state Exp;
branches;
next	1.83;

1.83
date	92.06.18.14.50.05;	author jont;	state Exp;
branches;
next	1.82;

1.82
date	92.06.18.09.47.51;	author davida;	state Exp;
branches;
next	1.81;

1.81
date	92.06.16.11.23.22;	author davida;	state Exp;
branches;
next	1.80;

1.80
date	92.06.15.15.26.59;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	92.06.12.19.14.52;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	92.06.11.14.59.49;	author clive;	state Exp;
branches;
next	1.77;

1.77
date	92.06.10.17.54.59;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	92.05.19.10.25.23;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	92.05.14.14.24.53;	author clive;	state Exp;
branches;
next	1.74;

1.74
date	92.05.13.16.51.59;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	92.05.13.11.01.43;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	92.05.08.11.48.18;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	92.05.06.12.10.01;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	92.04.23.19.03.09;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	92.04.23.10.30.21;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	92.04.13.15.31.23;	author clive;	state Exp;
branches;
next	1.67;

1.67
date	92.03.27.12.49.21;	author jont;	state Exp;
branches;
next	1.66;

1.66
date	92.03.25.15.19.12;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	92.03.18.14.48.51;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	92.03.17.18.43.46;	author jont;	state Exp;
branches;
next	1.63;

1.63
date	92.03.13.14.15.23;	author jont;	state Exp;
branches;
next	1.62;

1.62
date	92.03.04.23.06.08;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	92.02.20.12.31.24;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	92.02.18.09.01.10;	author clive;	state Exp;
branches;
next	1.59;

1.59
date	92.02.14.16.07.40;	author richard;	state Exp;
branches;
next	1.58;

1.58
date	92.02.14.12.37.17;	author clive;	state Exp;
branches;
next	1.57;

1.57
date	92.02.14.09.44.34;	author clive;	state Exp;
branches;
next	1.56;

1.56
date	92.02.13.15.43.39;	author clive;	state Exp;
branches;
next	1.55;

1.55
date	92.02.07.13.11.48;	author richard;	state Exp;
branches;
next	1.54;

1.54
date	92.02.04.19.20.16;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	92.01.31.12.59.33;	author clive;	state Exp;
branches;
next	1.52;

1.52
date	92.01.31.12.33.05;	author clive;	state Exp;
branches;
next	1.51;

1.51
date	92.01.28.19.09.46;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	92.01.24.11.14.11;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	92.01.23.16.52.15;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	92.01.22.18.53.30;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	92.01.15.13.43.10;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	92.01.10.19.21.30;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	92.01.08.20.14.37;	author colin;	state Exp;
branches;
next	1.44;

1.44
date	92.01.08.16.36.19;	author colin;	state Exp;
branches;
next	1.43;

1.43
date	92.01.06.19.32.28;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	92.01.06.13.21.35;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	91.12.23.17.33.43;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	91.12.23.16.14.41;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	91.12.20.17.35.52;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	91.12.20.01.29.59;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	91.12.19.18.14.59;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	91.12.18.19.50.52;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.12.17.16.54.19;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	91.12.16.15.48.10;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	91.12.10.14.51.45;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	91.11.18.11.37.34;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	91.11.14.10.57.27;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	91.11.08.17.51.11;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.11.08.17.00.50;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.10.28.16.21.28;	author davidt;	state Exp;
branches;
next	1.27;

1.27
date	91.10.23.13.18.31;	author davidt;	state Exp;
branches;
next	1.26;

1.26
date	91.10.22.17.22.29;	author davidt;	state Exp;
branches;
next	1.25;

1.25
date	91.10.16.11.22.08;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	91.10.15.14.47.14;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	91.10.10.10.20.13;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	91.10.08.17.43.44;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.10.03.09.48.49;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	91.10.03.08.57.04;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	91.09.16.11.37.25;	author davida;	state Exp;
branches;
next	1.18;

1.18
date	91.09.10.13.19.29;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.09.04.17.14.18;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.09.03.11.07.32;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	91.08.23.15.49.18;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.08.06.17.30.23;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.08.06.13.58.07;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.08.06.13.04.13;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.08.05.16.33.10;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.02.10.00.29;	author davida;	state Exp;
branches;
next	1.9;

1.9
date	91.07.31.19.48.07;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.07.30.14.03.50;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.07.25.16.07.06;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.07.19.17.35.58;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.07.12.18.50.38;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.11.15.25.42;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.11.13.12.59;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.10.15.01.49;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.09.18.58.16;	author jont;	state Exp;
branches;
next	;

1.170.1.1
date	93.08.28.16.44.19;	author jont;	state Exp;
branches;
next	1.170.1.2;

1.170.1.2
date	93.09.15.15.49.00;	author jont;	state Exp;
branches;
next	1.170.1.3;

1.170.1.3
date	93.09.27.11.22.14;	author jont;	state Exp;
branches;
next	;

1.227.1.1
date	96.09.13.11.18.09;	author hope;	state Exp;
branches;
next	;

1.228.1.1
date	96.10.07.16.08.00;	author hope;	state Exp;
branches;
next	;

1.228.2.1
date	96.10.17.11.26.15;	author hope;	state Exp;
branches;
next	;

1.230.1.1
date	96.11.14.12.51.31;	author hope;	state Exp;
branches
	1.230.1.1.1.1;
next	;

1.230.1.1.1.1
date	96.11.28.15.02.35;	author hope;	state Exp;
branches;
next	;

1.230.2.1
date	96.11.22.18.10.44;	author hope;	state Exp;
branches;
next	;

1.230.3.1
date	96.12.17.17.49.19;	author hope;	state Exp;
branches
	1.230.3.1.1.1;
next	;

1.230.3.1.1.1
date	97.02.24.11.39.26;	author hope;	state Exp;
branches;
next	;

1.230.4.1
date	96.12.18.09.43.24;	author hope;	state Exp;
branches;
next	;

1.235.1.1
date	97.05.12.10.35.52;	author hope;	state Exp;
branches;
next	1.235.1.2;

1.235.1.2
date	97.05.12.15.15.48;	author daveb;	state Exp;
branches
	1.235.1.2.1.1
	1.235.1.2.2.1
	1.235.1.2.3.1;
next	;

1.235.1.2.1.1
date	97.07.28.18.21.34;	author daveb;	state Exp;
branches
	1.235.1.2.1.1.1.1;
next	;

1.235.1.2.1.1.1.1
date	97.10.07.11.47.13;	author jkbrook;	state Exp;
branches;
next	;

1.235.1.2.2.1
date	97.09.08.17.14.59;	author daveb;	state Exp;
branches;
next	;

1.235.1.2.3.1
date	97.09.09.14.10.51;	author daveb;	state Exp;
branches;
next	;

1.240.1.1
date	97.09.10.19.26.53;	author brucem;	state Exp;
branches;
next	;

1.240.2.1
date	97.09.11.20.56.53;	author daveb;	state Exp;
branches;
next	1.240.2.2;

1.240.2.2
date	97.09.17.15.57.32;	author daveb;	state Exp;
branches;
next	1.240.2.3;

1.240.2.3
date	97.10.29.11.53.47;	author daveb;	state Exp;
branches;
next	1.240.2.4;

1.240.2.4
date	97.10.29.14.00.00;	author daveb;	state Exp;
branches;
next	1.240.2.5;

1.240.2.5
date	97.11.20.17.12.21;	author daveb;	state Exp;
branches;
next	1.240.2.6;

1.240.2.6
date	97.11.26.16.34.12;	author daveb;	state Exp;
branches;
next	1.240.2.7;

1.240.2.7
date	97.12.03.19.30.48;	author daveb;	state Exp;
branches;
next	;

1.262.1.1
date	99.04.01.17.57.45;	author daveb;	state Exp;
branches;
next	;


desc
@Top level of the compiler
@


1.262
log
@[Bug #190532]
Ensure update_dependencies is called on subprojects first
@
text
@(* _toplevel.sml the functor *)
(*
 * Copyright (C) 1997 The Harlequin Group Limited.  All rights reserved.
 *
 * $Log: _toplevel.sml,v $
 * Revision 1.261  1999/03/18  08:53:40  mitchell
 * [Bug #190532]
 * Build subprojects before building project
 *
 * Revision 1.260  1999/02/12  12:03:33  mitchell
 * [Bug #190505]
 * Suppress precompiling messages for pervasives
 *
 * Revision 1.259  1999/02/10  12:37:01  mitchell
 * [Bug #190505]
 * Don't precompile the pervasives when compiling the pervasives...
 *
 * Revision 1.258  1999/02/09  10:28:40  mitchell
 * [Bug #190505]
 * Support for precompilation of subprojects
 *
 * Revision 1.257  1999/02/05  14:15:40  mitchell
 * [Bug #190502]
 * Disable generation of .S files
 *
 * Revision 1.256  1999/02/05  11:56:19  mitchell
 * [Bug #190504]
 * Add ability to dump units in dependency order
 *
 * Revision 1.255  1999/02/03  15:20:28  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
 * Revision 1.254  1998/10/22  16:07:47  jont
 * [Bug #70194]
 * Generate object output direct from .mo files
 *
 * Revision 1.253  1998/10/22  13:06:53  jont
 * [Bug #70218]
 * Modified interface to output_object_code.
 * Also moving this to after output of mo, so that later it can use that instead
 * of direct compiler output. This will allow testing on .o from .mo stuff
 *
 * Revision 1.252  1998/06/24  10:54:02  jont
 * [Bug #70133]
 * Add COFF outputter
 *
 * Revision 1.251  1998/04/24  16:07:57  jont
 * [Bug #70109]
 * Making printing of compiling messages dependent
 * on the print_messages field of options
 *
 * Revision 1.250  1998/04/24  15:31:24  mitchell
 * [Bug #30389]
 * Keep projects more in step with projfiles
 *
 * Revision 1.249  1998/04/22  15:59:42  jont
 * [Bug #70099]
 * Modify following changes to encapsulation order
 *
 * Revision 1.248  1998/04/02  12:50:17  jont
 * [Bug #30312]
 * Replacing OS.FileSys.modTime with system dependent version to sort out
 * MS time stamp problems.
 *
 * Revision 1.247  1998/02/19  17:16:20  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.246  1998/02/06  11:26:08  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 * Added a call to Project.pervasiveObjectName from do_input.
 *
 * Revision 1.245  1998/01/30  17:52:34  jont
 * [Bug #70051]
 * Modify to detect missing pervasive objects without giving compiler fault
 *
 * Revision 1.244  1997/11/25  10:27:18  jont
 * [Bug #30328]
 * Add environment parameter to decode_type_basis
 * for finding pervasive type names
 *
 * Revision 1.243  1997/11/13  11:19:16  jont
 * [Bug #30089]
 * Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
 *
 * Revision 1.242  1997/10/20  20:24:49  jont
 * [Bug #30089]
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.241  1997/10/08  17:45:58  daveb
 * [Bug #20090]
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 *
 * Revision 1.240.2.7  1997/12/03  19:30:48  daveb
 * [Bug #30071]
 * Project.fromFileInfo now takes a project argument.
 *
 * Revision 1.240.2.6  1997/11/26  16:34:12  daveb
 * [Bug #30071]
 *
 * Revision 1.240.2.5  1997/11/20  17:12:21  daveb
 * [Bug #30326]
 *
 * Revision 1.240.2.4  1997/10/29  14:00:00  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 *
 * Revision 1.240.2.3  1997/10/29  11:53:47  daveb
 * [Bug #20090]
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 *
 * Revision 1.240.2.2  1997/09/17  15:57:32  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
 * Revision 1.240.2.1  1997/09/11  20:56:53  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.240  1997/05/27  15:50:31  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.239  1997/05/27  12:24:22  daveb
 * [Bug #30136]
 * Removed early-mips-r4000 option.
 *
 * Revision 1.238  1997/05/12  16:09:56  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.237  1997/05/02  16:41:29  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.236  1997/04/10  16:49:24  jont
 * [Bug #1984]
 * Tidy up the unknown locations when giving No such file errors.
 *
 * Revision 1.235  1997/03/25  11:44:35  matthew
 * Renamed R4000 option
 *
 * Revision 1.234  1997/03/21  11:33:05  johnh
 * [Bug #1965]
 * Handling Io.NotSet for objectName.
 *
 * Revision 1.233  1997/02/12  13:22:33  daveb
 * Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
 * -- Changed name and type of Module.mo_name.
 *
 * Revision 1.232  1997/01/21  11:03:38  matthew
 * Adding architecture specific options
 *
 * Revision 1.231  1997/01/02  15:24:10  matthew
 * Changes to lambda code
 *
 * Revision 1.230  1996/11/06  11:29:12  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.229  1996/10/29  16:12:18  io
 * moving String from toplevel
 *
 * Revision 1.228  1996/10/04  13:05:16  matthew
 * Remove LambdaSub
 *
 * Revision 1.227  1996/09/04  11:26:45  daveb
 * [Bug #1584]
 * Removed mention of object path from error message.
 *
 * Revision 1.226  1996/08/06  14:21:39  andreww
 * [Bug #1521]
 * propagating changes made to typechecker/_types.sml
 * (pass options rather than print_options)
 *
 * Revision 1.225  1996/07/30  10:57:46  daveb
 * Corrected mistake in check_dependencies.
 *
 * Revision 1.224  1996/07/18  17:20:04  jont
 * Add option to turn on/off compilation messages from intermake
 *
 * Revision 1.223  1996/05/30  12:50:18  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.222  1996/04/30  17:23:25  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.221  1996/04/29  15:00:26  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.220  1996/04/02  11:17:59  daveb
 * Changed Project.load_dependencies to Project.read_dependencies.
 *
 * Revision 1.219  1996/03/27  10:58:03  stephenb
 * Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
 * the deprecated OS interface.
 *
 * Revision 1.218  1996/03/25  15:32:13  daveb
 * Added handlers for Module.BadHomeName.
 * Replaced explicit setting of source path with new version of
 * Module.with_source_path.
 *
 * Revision 1.217  1996/03/15  17:01:19  daveb
 * Module.mo_name now takes an Info.options argument.
 *
 * Revision 1.216  1996/03/15  14:36:11  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.215  1996/03/06  13:14:45  daveb
 * Types of Project object info and Encapsulate.input_all have changed.
 *
 * Revision 1.214  1996/02/22  14:12:40  jont
 * Replacing Map with NewMap
 *
 * Revision 1.213  1996/02/09  15:02:26  daveb
 * Added a handler for the case when the encapsulator is given a bad file name.
 *
Revision 1.212  1995/12/12  11:31:56  daveb
Changed wording of warning message.

Revision 1.211  1995/12/05  11:31:00  daveb
Modified type of compile_file' to support Project Tool.

Revision 1.210  1995/10/25  17:58:56  jont
Adding opt_handlers compiler option

Revision 1.209  1995/09/11  10:57:59  daveb
The Type of LambdaTypes.SCON has changed.

Revision 1.208  1995/09/05  15:59:35  jont
Add sml_cache to interface for compile_file' to improve finding
of .mo files

Revision 1.207  1995/08/01  14:25:35  matthew
Adding environment simplication function

Revision 1.206  1995/05/31  10:05:32  matthew
Added debugging flag to mir optimiser

Revision 1.205  1995/05/02  12:07:08  matthew
Removing debug_polyvariables option

Revision 1.204  1995/04/28  15:43:35  jont
Module naming improvements

Revision 1.203  1995/04/21  13:58:14  jont
Eliminate use of require_list
Replaced with an integer option, and removed as a parameter to do_subrequires

Revision 1.202  1995/04/20  14:09:10  jont
Ensure proper module names used in the require lists

Revision 1.201  1995/04/05  14:45:57  matthew
Combining stamp counts in one.
Other simplifications -- removed minor timings and test_string
Argument to mod_rules that describes if we are in separate compilation

Revision 1.200  1995/03/02  12:58:23  matthew
Changes to Debugger_Types

Revision 1.199  1995/02/17  14:53:45  daveb
Added diagnostic when extending the source path.

Revision 1.198  1995/02/07  12:56:59  matthew
Moving pervasive counts to Basis

Revision 1.197  1995/01/17  16:15:30  daveb
Replaced Option structure with references to MLWorks.Option.
Removed obsolete sharing constraint.

Revision 1.196  1994/12/08  17:30:53  jont
Move OS specific stuff into a system link directory

Revision 1.195  1994/10/13  11:25:51  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.194  1994/10/10  10:28:43  matthew
Improved module caching
Lambdatypes changes.

Revision 1.193  1994/09/19  13:56:59  matthew
Changes to lambdatypes

Revision 1.192  1994/07/29  17:31:23  daveb
Moved preferences into a separate structure.

Revision 1.191  1994/07/19  16:02:33  matthew
Functions take a list of parameters

Revision 1.190  1994/04/07  16:38:01  jont
Add original require file names to consistency info.

Revision 1.189  1994/03/21  15:16:38  daveb
added compile_module.

Revision 1.188  1994/03/16  13:00:42  matthew
Changed name of pervasive stream to <Pervasive> (helps with debug info)

Revision 1.187  1994/03/15  17:28:36  matthew
Use the full filename for the location in token stream rather than module id.
This is to allow the error file finding mechanism to work

Revision 1.186  1994/02/28  08:21:10  nosa
Step and Modules Debugger compiler options.

Revision 1.185  1994/02/25  12:37:25  daveb
Removed redundant code.

Revision 1.184  1994/02/16  16:42:31  jont
Fixed so that even empty files produce non-empty require_lists

Revision 1.183  1994/02/08  14:52:17  daveb
Module.module_and_path is now Module.find_file, is functional, and is
called on all arguments to compile_file before any compilation is done.

Revision 1.182  1994/02/01  16:14:57  daveb
Module names have been moved from FileName to Module.

Revision 1.181  1994/01/18  16:06:02  matthew
Undid previous undo.

Revision 1.180  1994/01/13  13:05:55  matthew
Use short module name after all.
Otherwise decapsulation breaks

Revision 1.179  1994/01/11  17:00:37  matthew
Put longer module identifier in mo dependencies.

Revision 1.178  1994/01/10  15:17:39  matthew
Added range information for tyname_id's etc.

Revision 1.177  1993/12/17  17:24:28  io
Moved some sigs from machine/ to main/

Revision 1.176  1993/12/15  13:53:39  matthew
Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes

Revision 1.175  1993/11/15  14:17:31  nickh
New pervasive Time structure.

Revision 1.174  1993/11/05  09:57:58  jont
Added interrupt option

Revision 1.173  1993/09/27  14:57:33  jont
Merging in bug fixes

Revision 1.172  1993/09/17  14:02:30  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger;
change also to Debugger_Types.INFO.

Revision 1.170.1.3  1993/09/27  11:22:14  jont
Changed to returned pervasive_mo cache and to use it.

Revision 1.171  1993/09/15  18:48:38  jont
Merged in bug fixes

Revision 1.170.1.2  1993/09/15  15:49:00  jont
Fixed problem whereby require_table and require_list did not consist of full
module names, and hence multiple versions of modules could arise

Revision 1.170.1.1  1993/08/28  16:44:19  jont
Fork for bug fixing

Revision 1.170  1993/08/28  16:44:19  daveb
Changed find_object and compile_file' to take a filename cache.
Changed type of compile_file to take a list of strings, so that caches can
be preserved between each compilation (I haven't implemented this yet).

Revision 1.169  1993/08/26  18:59:00  daveb
Improved searching for mos.

Revision 1.168  1993/08/26  12:55:27  richard
Changed the require syntax back to old style so that NJ can cope.

Revision 1.167  1993/08/25  13:12:13  daveb
Io.get_pervasive_dir can raise Io.NotSet.

Revision 1.166  1993/08/24  15:23:58  daveb
ModuleId.from_string now takes a location argument.

Revision 1.165  1993/08/23  15:17:12  richard
Added code to output the optimised lambda code into a file called
test.lam if the output_lambda option is enabled.  This is for use
in the COMPARE project.

Revision 1.164  1993/08/19  14:35:28  daveb
Made compiler always announce the start of a new compilation.

Revision 1.163  1993/08/17  16:34:07  daveb
Major changes to support ModuleIds and search path.

Revision 1.162  1993/08/12  14:08:09  jont
Changed the way pervasive require is done to use new multiple unget
in lexer. Much simpler code as a result.

Revision 1.161  1993/08/03  16:42:19  jont
Modified to disallow requires after non-require topdecs. Some modifications to ensure
rigid tynames and strnames are consistent if a file is required and subrequired

Revision 1.160  1993/07/15  15:50:36  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
structure Option.

Revision 1.159  1993/07/12  10:55:27  daveb
Augmented type basis before passing it to trans_topdec.

Revision 1.158  1993/06/30  13:21:18  daveb
Now passes type basis to trans_topdec.
Removed show_match and generate_debug_inhibit_warnings.

Revision 1.157  1993/06/02  17:40:47  jont
Changed to use new mod_rules interface. All unnecessary
assembly calculations removed

Revision 1.156  1993/05/28  13:31:10  jont
Cleaned up after assembly changes

Revision 1.155  1993/05/28  10:35:42  matthew
 Changed Info.wrap
Put filename rather than module name into tokenstream and thence
into locations.

Revision 1.154  1993/05/27  12:45:32  jont
Stopped encapsulating and decapsulating assemblies

Revision 1.153  1993/05/25  16:02:08  jont
Changes because Assemblies now has BasisTypes instead of Datatypes

Revision 1.152  1993/05/18  17:01:55  jont
Removed integer parameter

Revision 1.151  1993/05/11  17:25:14  jont
Fixed bug whereby counters were pushed after resetting them, instead of before

Revision 1.150  1993/05/11  12:49:27  jont
Changes to lambda optimiser to allow removal of inlining for tracing

Revision 1.149  1993/04/22  15:24:14  jont
Added pop_counters to normal exit for compilation

Revision 1.148  1993/04/21  13:12:32  jont
Removed the Lists.exists test in favour of a map for subrequired files

Revision 1.147  1993/04/14  15:57:08  matthew
Changed some print_timings to print_minor_timings and defaulted
print_minor_timings to false.

Revision 1.146  1993/04/13  15:13:22  matthew
Exposed lambda optimisation switches

Revision 1.145  1993/04/06  15:45:17  jont
Made separate compilation push and pop the relevant counters from simple types
round the compilation, thus not affecting the interpreter

Revision 1.144  1993/03/12  11:58:09  matthew
Options changes
Signature revisions

Revision 1.143  1993/03/09  12:57:29  matthew
Options & Info changes

Revision 1.142  1993/02/09  09:49:00  matthew
Typechecker structure changes

Revision 1.141  1993/02/04  16:23:52  matthew
Changed sharing.

Revision 1.140  1993/01/28  09:52:22  jont
Changed explicit definition of default compiler options to refer to new one
in MirTypes

Revision 1.139  1993/01/05  18:18:23  jont
Modified to use Info.listing_fn for code printing etc

Revision 1.138  1992/12/17  10:40:15  clive
Changed debug info to have only module name - needed to pass module table through to window stuff

Revision 1.137  1992/12/08  20:21:14  jont
Removed a number of duplicated signatures and structures

Revision 1.136  1992/12/08  14:06:29  clive
Set the initial start up flags to compile small code at maximum speed

Revision 1.135  1992/12/08  13:41:44  daveb
Options weren't being passed by error_wrap; now they are.

Revision 1.134  1992/12/02  15:57:18  daveb
Changes to propagate compiler options as parameters instead of references.

Revision 1.133  1992/12/02  14:05:47  jont
Modified to remove redundant info signatures

Revision 1.132  1992/11/27  15:42:02  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.131  1992/11/25  17:30:47  matthew
Changed error messages

Revision 1.130  1992/11/19  19:17:44  jont
Removed Info structure from parser, tidied upderived

Revision 1.129  1992/11/18  11:51:50  matthew
Changed Error structure to Info

Revision 1.128  1992/11/07  15:40:00  richard
Changed the pervasives and representation of time.
Added a cache on the results of Encapsulate.input_info.
Changed format of consistency info.

Revision 1.127  1992/11/04  16:39:59  jont
Removed for the second time a sharing constraint on NewMap

Revision 1.126  1992/11/03  12:29:09  daveb
Setting show_mir (etc.) now produces output without the need to call
Diagnostic.set 2.

Revision 1.124  1992/10/27  17:11:42  jont
Removed Error from toplevel signature

Revision 1.123  1992/10/15  16:11:23  clive
Anel's changes for encapsulating assemblies

Revision 1.122  1992/10/14  12:06:31  richard
Added line number to token stream input functions.
Added location information to the `require' topdec.

Revision 1.121  1992/10/12  12:00:53  clive
Tynames now have a slot recording their definition point

Revision 1.120  1992/10/01  13:56:35  richard
Moved lambda module code and strname reducing code elsewhere so that
they can be shared with the incremental compiler.  Also makes things
tidier, imho.

Revision 1.119  1992/09/24  06:21:11  richard
Added sharing contraint on Error to signature.

Revision 1.118  1992/09/23  16:43:48  jont
Removed add_fn_names (obsolete)

Revision 1.117  1992/09/21  18:16:06  jont
Turned off default printing of lambda code and environment

Revision 1.116  1992/09/16  08:45:36  daveb
show_eq_info controls printing of equality attribute of tycons.
show_id_class controls printing of id classes (VAR, CON or EXCON).

Revision 1.115  1992/09/15  12:30:57  jont
Minor improvements in handling requires, mainly removing some from_lists
Removed valenvs from METATYNAMEs where there is a further tyname below

Revision 1.114  1992/09/10  10:35:09  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
Added `augment'.

Revision 1.113  1992/09/09  10:04:28  clive
Added flag to switch off warning messages in generating recipes

Revision 1.112  1992/09/08  11:55:34  richard
Changed error wrapper to cope with new ERROR signature.
Added missing wrappers in compile_ts.

Revision 1.111  1992/09/07  10:26:44  jont
Added reduction of meta typenames and tyfuns to reduce chain length
after sharing/instantiation

Revision 1.110  1992/09/04  13:25:59  richard
Moved the special names out of the compiler as a whole.
Installed central error reporting mechanism.

Revision 1.109  1992/09/01  16:44:33  clive
Switches for self_calling and fix to binding the compilation unit list result

Revision 1.108  1992/08/26  17:19:05  jont
Removed some redundant structures and sharing

Revision 1.107  1992/08/26  09:12:49  clive
Propogation of information about exceptions

Revision 1.106  1992/08/25  19:01:47  davidt
Added Timer.xtime call for Encapsulate.input_all.

Revision 1.105  1992/08/25  16:19:59  richard
Added bytearray and bits to pervasive modules.

Revision 1.104  1992/08/25  13:32:03  clive
Added details about leafness to the debug information

Revision 1.103  1992/08/20  18:00:17  davidt
Made changes to allow mo files to be copied.

Revision 1.102  1992/08/19  14:02:54  davidt
Changed printing of user-level errors so that it prints
'***' at the start of the line, to help find errors
amongst timing info.

Revision 1.101  1992/08/18  15:00:55  davidt
Took out an extra print statement. Now gets input in bigger
chunks using input instead of input_line.

Revision 1.100  1992/08/17  11:31:07  davidt
Changed to use MLWorks.IO.input_line

Revision 1.99  1992/08/14  16:44:37  davidt
Changed to use new Encapsulate interface.

Revision 1.98  1992/08/12  13:28:21  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.97  1992/08/10  17:28:02  davidt
Changed MLworks to MLWorks.

Revision 1.96  1992/08/10  12:00:15  davidt
Encapsulate.output_file now does everything, instead of
TopLevel calling a number of different Encapsulate
files. Changed list of pervasive files.

Revision 1.92  1992/08/05  18:25:25  jont
Added strnasme contraction to reduce the number of refs traversed
in type checking and sharing. Fixed up a naff sharing constraint

Revision 1.91  1992/07/23  12:45:11  clive
Use of new hash tables, removed some concatenation and compression of integers in encapsulator

Revision 1.90  1992/07/23  08:06:29  clive
Equality type problem in info = []

Revision 1.89  1992/07/22  16:09:52  jont
Added return of abstract syntax tree to compile_ts

Revision 1.88  1992/07/22  15:35:17  jont
Moved all file manipulation into Io

Revision 1.87  1992/07/21  18:40:55  jont
Modifications to allow less string concatenation and copying

Revision 1.86  1992/07/14  16:17:25  richard
Removed obsolete memory profiling code.

Revision 1.85  1992/07/08  15:34:21  clive
Added call point information recording

Revision 1.84  1992/07/03  13:43:21  davida
Added LET constructor and new slot to APP.

Revision 1.83  1992/06/18  14:50:05  jont
Modified spec of compile_ts to return lambda expression

Revision 1.82  1992/06/18  09:47:51  davida
Added switch to allow compilation to stop at
lambda, and also display of size of lambda expr.

Revision 1.81  1992/06/16  11:23:22  davida
Changed to use (much) faster Lambda Print,
added margin ref.

Revision 1.80  1992/06/15  15:26:59  jont
Coded main section of compile_ts for interpreter

Revision 1.79  1992/06/12  19:14:52  jont
Added functions to do compiling and return results

Revision 1.78  1992/06/11  14:59:49  clive
Added flags for the recording of debug type information

Revision 1.77  1992/06/10  17:54:59  jont
changed to produce lists as compilation units instead of tuples
changed to use newmap

Revision 1.76  1992/05/19  10:25:23  jont
Changed Mach_Cg_ to Mach_Cg

Revision 1.75  1992/05/14  14:24:53  clive
Added memory profiling flag

Revision 1.74  1992/05/13  16:51:59  jont
Removed a redundant augment_cb from the compilation process

Revision 1.73  1992/05/13  11:01:43  jont
Modified for two integer time stamps

Revision 1.72  1992/05/08  11:48:18  jont
Added timing for entire encapsulation process

Revision 1.71  1992/05/06  12:10:01  jont
Added do_check_bindings bool ref to control the checking of uniqueness
of bound lambda variable names. Default off

Revision 1.70  1992/04/23  19:03:09  jont
Removed reference to pervasive flush_out. Added an input_line function

Revision 1.69  1992/04/23  10:30:21  jont
Expanded some of the decoding messages to give more info

Revision 1.68  1992/04/13  15:31:23  clive
First version of the profiler

Revision 1.67  1992/03/27  12:49:21  jont
*** empty log message ***

Revision 1.66  1992/03/25  15:19:12  matthew
Slight change to parsing error message

Revision 1.65  1992/03/18  14:48:51  jont
Changed an instance of LambdaTypes_ to LambdaTypes

Revision 1.64  1992/03/17  18:43:46  jont
Added bool ref for add_fn_names to control addition of function names

Revision 1.63  1992/03/13  14:15:23  jont
Fixed problem whereby tyname_count, strname_count, tyfun_count overflowed

Revision 1.62  1992/03/04  23:06:08  jont
Added some functions to check lambda calculus consistency

Revision 1.61  1992/02/20  12:31:24  jont
Added show_match to control printing of match trees

Revision 1.60  1992/02/18  09:01:10  clive
Rewrote end_is function in terms of functions already defined

Revision 1.59  1992/02/14  16:07:40  richard
Changes to reflect changes in MirOptimiser signature.

Revision 1.58  1992/02/14  12:37:17  clive
root_name applied to pervasive_library_path before requiring it

Revision 1.57  1992/02/14  09:44:34  clive
Needed an extra newline in one of the print statements

Revision 1.56  1992/02/13  15:43:39  clive
New pervasive library code

Revision 1.55  1992/02/07  13:11:48  richard
Changed Table to Map to reflect changes in MirRegisters.

Revision 1.54  1992/02/04  19:20:16  jont
Removed sharing constraint on Parser.Ident (no longer there)

Revision 1.53  1992/01/31  12:59:33  clive
Nextened the printing

Revision 1.52  1992/01/31  12:33:05  clive
Added timing to the various sections

Revision 1.51  1992/01/28  19:09:46  jont
Added option not to do lambda optimisation

Revision 1.50  1992/01/24  11:14:11  jont
Modified to deal with absolute pathnames in requires

Revision 1.49  1992/01/23  16:52:15  jont
Changed to encode tyfun_ids similarly to tyname_ids

Revision 1.48  1992/01/22  18:53:30  jont
Moved info about reset of tyname and strname counters to level 3

Revision 1.47  1992/01/15  13:43:10  jont
Added call to clean_basis to remove old encodings of pervasives

Revision 1.46  1992/01/10  19:21:30  jont
Added various diagnostics

Revision 1.45  1992/01/08  20:14:37  colin
added call to reset_assemblies before each compilation.

Revision 1.44  1992/01/08  16:36:19  colin
Added code to maintain unique tyname and strname_ids across modules.

Revision 1.43  1992/01/06  19:32:28  jont
Added recursive loading of typechecker bases for requires

Revision 1.42  1992/01/06  13:21:35  jont
Changed to use new binding type

Revision 1.41  1991/12/23  17:33:43  jont
Fixed bug whereby the wrong object file name was being used

Revision 1.40  91/12/23  16:14:41  jont
Added file time stamp checking

Revision 1.39  91/12/20  17:35:52  jont
Added separation of required environments from generated ones. This may
need further thought.

Revision 1.38  91/12/20  01:29:59  jont
Added full parsing and handling of require topdecs, including
rebuilding the environments and making the new bindings

Revision 1.37  91/12/19  18:14:59  jont
Added environment and consistency info reading and writing, and
handling of require topdec s

Revision 1.36  91/12/18  19:50:52  jont
Added output of encoded typechecker basis and rereading

Revision 1.35  91/12/17  16:54:19  jont
Added writing of parser env to output file, and rereading it.

Revision 1.34  91/12/16  15:48:10  jont
Added some progress messages

Revision 1.33  91/12/10  14:51:45  jont
Added output of environment

Revision 1.32  91/11/18  11:37:34  richard
Added some newline characters that were bugging me by their absence.

Revision 1.31  91/11/14  10:57:27  richard
Removed references to fp_doubles.

Revision 1.30  91/11/08  17:51:11  jont
Added show_mach to refer to corresponding item in mach_cg, so we can off
opcode listings

Revision 1.29  91/11/08  17:00:50  jont
Added production of output file names for compile function,
so <name>.sml -> <name>.mo

Revision 1.28  91/10/28  16:21:28  davidt
Changed lots of pervasive prints to Print.print.

Revision 1.27  91/10/23  13:18:31  davidt
Stopped default printing out of mir code (it took too long).
Fixed an non-exhaustive binding using a Crash.impossible.

Revision 1.26  91/10/22  17:22:29  davidt
Removed exception handlers (impossible exception has been replaced
by calls to Crash.impossible).

Revision 1.25  91/10/16  11:22:08  jont
Added calls to encapsulate and output the code

Revision 1.24  91/10/15  14:47:14  richard
Changed the way Mach_Cg is called because the register assignment
tables have moved.

Revision 1.23  91/10/10  10:20:13  jont
Made all code generation take place at all times

Revision 1.22  91/10/08  17:43:44  jont
Added call to Mach_Cg.mach_cg

Revision 1.21  91/10/03  09:48:49  jont
Added machine dependent code generator

Revision 1.21  91/10/03  09:48:49  jont
Temporary checkin.

Revision 1.20  91/10/03  08:57:04  jont
Added show_mach

Revision 1.19  91/09/16  11:37:25  davida
Added show_lambda, show_opt_lambda, show_environ
switches.

Revision 1.18  91/09/10  13:19:29  davida
Added printing of optimised lambda-code, as
the lambda-optimiser no longer prints it by default...

Revision 1.17  91/09/04  17:14:18  jont
Added show_opt_mir to control production and printing of optimised
intermediate code

Revision 1.16  91/09/03  11:07:32  richard
Included MIR optimiser module in compiler run.

Revision 1.15  91/08/23  15:49:18  jont
Removed init_prim, as no longer required

Revision 1.14  91/08/06  17:30:23  jont
Removed code generation from non-optimised lambda code

Revision 1.13  91/08/06  13:58:07  davida
Removed printing of optimised lambda code,
as it's printed by the optimiser by default.

Revision 1.12  91/08/06  13:04:13  davida
Added switches for mir and absyn printing,
changed to use different lambda-print function.

Revision 1.11  91/08/05  16:33:10  jont
Split printing of results into two parts for better diagnostics

Revision 1.10  91/08/02  10:00:29  davida
Removed superfluous argument from LambdaOptimiser.optimise call.

Revision 1.9  91/07/31  19:48:07  jont
Stopped printing abstract syntax tree

Revision 1.8  91/07/30  14:03:50  jont
Minor changes to do with calling mir

Revision 1.7  91/07/25  16:07:06  jont
Added mir stuff

Revision 1.6  91/07/19  17:35:58  jont
First attempt at abstracting out external arguments

Revision 1.5  91/07/12  18:50:38  jont
Used new toplevel environment printer

Revision 1.4  91/07/11  15:25:42  jont
Has topdecprint if required

Revision 1.3  91/07/11  13:12:59  jont
Produced correct top level output in terms of ordering, environment
as fields etc.

Revision 1.2  91/07/10  15:01:49  jont
Completed to handle initial environment and compile files and strings

Revision 1.1  91/07/09  18:58:16  jont
Initial revision

*)

require "../basis/__io";
require "../basis/__text_io";
require "../basis/__int";
require "../basis/os";
require "^.system.__file_time";

require "../utils/crash";
require "../utils/print";
require "../utils/lists";
require "../utils/diagnostic";
require "../utils/mlworks_timer";
require "../basics/module_id";
require "../parser/parser";
require "../typechecker/mod_rules";
require "../typechecker/basis";
require "../typechecker/stamp";
require "../lambda/environ";
require "../lambda/lambdaprint";
require "../lambda/environprint";
require "../lambda/lambda";
require "../lambda/lambdaoptimiser";
require "../lambda/lambdamodule";
require "../lambda/topdecprint";
require "../mir/mir_cg";
require "../mir/mirprint";
require "../mir/miroptimiser";
require "mach_cg";
require "machprint";
require "object_output";
require "project";
require "primitives";
require "pervasives";
require "encapsulate";
require "mlworks_io";
require "toplevel";

functor TopLevel
 (structure OS : OS
  structure Crash : CRASH
  structure Print : PRINT
  structure Lists : LISTS
  structure Diagnostic : DIAGNOSTIC
  structure Timer : INTERNAL_TIMER
  structure Parser : PARSER
  structure Mod_Rules : MODULE_RULES
  structure Basis : BASIS
  structure Stamp : STAMP
  structure Environ : ENVIRON
  structure LambdaPrint : LAMBDAPRINT
  structure EnvironPrint : ENVIRONPRINT
  structure Lambda : LAMBDA
  structure LambdaOptimiser : LAMBDAOPTIMISER
  structure LambdaModule : LAMBDAMODULE
  structure Mir_Cg : MIR_CG
  structure MirPrint : MIRPRINT
  structure MirOptimiser : MIROPTIMISER
  structure Mach_Cg : MACH_CG
  structure MachPrint : MACHPRINT
  structure Object_Output : OBJECT_OUTPUT
  structure TopdecPrint : TOPDECPRINT
  structure Primitives : PRIMITIVES
  structure Pervasives : PERVASIVES
  structure Encapsulate : ENCAPSULATE
  structure Io : MLWORKS_IO
  structure ModuleId : MODULE_ID
  structure Project : PROJECT

  sharing Lambda.Options =
          Mir_Cg.Options =
	  EnvironPrint.Options =
	  LambdaPrint.Options =
	  TopdecPrint.Options =
	  LambdaOptimiser.Options =
          Mod_Rules.Options =
          Mach_Cg.Options

  sharing Parser.Lexer.Info = Lambda.Info = Mir_Cg.Info = Mach_Cg.Info =
          Mod_Rules.Info = Project.Info
  sharing Basis.BasisTypes = Mod_Rules.Assemblies.Basistypes =
	  Encapsulate.BasisTypes = Lambda.BasisTypes
  sharing Mir_Cg.MirTypes.Debugger_Types =
	  Encapsulate.Debugger_Types
  sharing Parser.Absyn.Set = Basis.BasisTypes.Set
  sharing Parser.Absyn =
	  Mod_Rules.Absyn =
	  Lambda.Absyn =
	  TopdecPrint.Absyn
  sharing Environ.EnvironTypes.LambdaTypes =
	  LambdaPrint.LambdaTypes =
    	  LambdaOptimiser.LambdaTypes =
	  Lambda.EnvironTypes.LambdaTypes =
	  Mir_Cg.LambdaTypes
  sharing Environ.EnvironTypes =
	  Lambda.EnvironTypes =
    	  Primitives.EnvironTypes =
	  EnvironPrint.EnvironTypes =
    	  Encapsulate.EnvironTypes =
	  LambdaModule.EnvironTypes
  sharing Mir_Cg.MirTypes =
   	  MirPrint.MirTypes =
	  MirOptimiser.MirTypes =
	  Mach_Cg.MirTypes =
	  MirOptimiser.MirTypes
  sharing Mach_Cg.MachSpec = MirOptimiser.MachSpec
  sharing Basis.BasisTypes.Datatypes.Ident = LambdaPrint.LambdaTypes.Ident
  sharing Encapsulate.ParserEnv.Map = Basis.BasisTypes.Datatypes.NewMap

  sharing type Parser.Lexer.Options = Lambda.Options.options
  sharing type Mach_Cg.Opcode = MachPrint.Opcode = Object_Output.Opcode
  sharing type Mach_Cg.Module = Encapsulate.Module = Object_Output.Module
  sharing type Parser.Absyn.Type = Basis.BasisTypes.Datatypes.Type =
	       Mir_Cg.LambdaTypes.Type
  sharing type Parser.Absyn.Structure = Basis.BasisTypes.Datatypes.Structure
  sharing type Parser.ParserBasis = Encapsulate.ParserEnv.pB
  sharing type LambdaPrint.LambdaTypes.Primitive = Pervasives.pervasive
  sharing type ModuleId.ModuleId = Project.ModuleId = Io.ModuleId = Object_Output.ModuleId
  sharing type ModuleId.Location = Basis.BasisTypes.Datatypes.Ident.Location.T
  sharing type Lambda.DebugInformation =
	       Mir_Cg.MirTypes.Debugger_Types.information
  sharing type Basis.BasisTypes.Datatypes.Stamp = Stamp.Stamp
  sharing type Basis.BasisTypes.Datatypes.StampMap = Stamp.Map.T
  sharing type Object_Output.Project = Project.Project
) : TOPLEVEL =

struct
  structure EnvironTypes = Environ.EnvironTypes
  structure Assemblies = Mod_Rules.Assemblies
  structure BasisTypes = Assemblies.Basistypes
  structure Absyn = Parser.Absyn
  structure LambdaTypes = LambdaPrint.LambdaTypes
  structure Lexer = Parser.Lexer
  structure Datatypes = Basis.BasisTypes.Datatypes
  structure NewMap = Datatypes.NewMap
  structure Ident = Datatypes.Ident
  structure Parser = Parser
  structure Diagnostic = Diagnostic
  structure Set = LambdaTypes.Set
  structure MirTypes = Mir_Cg.MirTypes
  structure Debugger_Types = MirTypes.Debugger_Types
  structure Info = Lexer.Info
  structure Options = LambdaOptimiser.Options
  structure Token = Lexer.Token
  structure FileSys = OS.FileSys

  type TypeBasis = BasisTypes.Basis
  type ParserBasis = Parser.ParserBasis 

  type ModuleId = ModuleId.ModuleId

  type Project = Project.Project



  val do_lambda_opt = ref true
  val print_timings = ref false

  val do_diagnostic = true
  val _ = Diagnostic.set 0

  fun diagnostic_output level =
    if do_diagnostic then Diagnostic.output level else fn f => ()

  (* Redundant now *)
  val do_check_bindings = ref false

  val error_output_level = ref Info.ADVICE

  datatype compiler_basis =
    CB of (Parser.ParserBasis * BasisTypes.Basis * EnvironTypes.Top_Env)

  val empty_cb =
    CB (Parser.empty_pB, Basis.empty_basis, Environ.empty_top_env)

  val initial_cgb =
    EnvironTypes.TOP_ENV
    (Primitives.initial_env, Environ.empty_fun_env)

  fun augment (CB (p, t, c), CB (p', t', c')) =
    CB (Parser.augment_pB (p, p'),
        Basis.basis_circle_plus_basis (t, t'),
        Environ.augment_top_env (c, c'))

  val after_builtin_cgb =
    EnvironTypes.TOP_ENV
    (Primitives.env_after_builtin, Environ.empty_fun_env)

  val non_ml_defineable_cgb =
    EnvironTypes.TOP_ENV
    (Primitives.env_for_not_ml_definable_builtins, Environ.empty_fun_env)

  val initial_cgb_for_builtin_library =
    EnvironTypes.TOP_ENV
    (Primitives.initial_env_for_builtin_library, Environ.empty_fun_env)

  val initial_cb_for_builtin_library =
    CB (Parser.initial_pB_for_builtin_library,
        Basis.initial_basis_for_builtin_library,
        initial_cgb_for_builtin_library)

  val initial_cgb_for_normal_file =
    CB (Parser.initial_pB,
        Basis.initial_basis,
        non_ml_defineable_cgb)

  val BasisTypes.BASIS(_, _, _, _, initial_env_for_normal_file) = Basis.initial_basis

  val initial_compiler_basis = initial_cgb_for_normal_file

  val empty_env =
    CB(Parser.empty_pB, Basis.empty_basis, Environ.empty_top_env)

  val empty_string_map = NewMap.empty (op < : string * string -> bool, op =)

  val empty_debug_info = Debugger_Types.empty_information

  (* this codegen basis will not cope with code including exceptions *)

  fun diagnostic (level, output_function) =
    diagnostic_output level
      (fn verbosity => "TopLevel " :: (output_function verbosity))

  fun diagnose_simple str = diagnostic_output 1 (fn i => [str])

  fun augment_cb (CB(p, t, c), CB(p', t', c')) =
    CB (Parser.augment_pB (p, p'),
        Basis.basis_circle_plus_basis(t, t'),
        Environ.augment_top_env(c, c'))

  fun error_wrap filename error_info =
    Info.wrap error_info
      (Info.FATAL, Info.RECOVERABLE, !error_output_level,
       Info.Location.FILE filename)

  (* The require_table maps module names to pair of module_names with
     pairs of a stamp count and the stamps for that module.  I have no
     idea why the module name is stored in the range of the map as well
     as the domain. *)
  fun do_subrequires
        options
        (first, project, require_table, _, _, nil) =
    (project, require_table)
  |   do_subrequires
        options
        (first, project, require_table, pervasive, 
         location,
         {mod_name = name, time} :: cons) =
      let
        val _ =
          diagnostic (3,
          fn _ => ["do_subrequires of ", name, ", pervasive = ",
                   if pervasive then "true\n" else "false\n"])
        val is_pervasive_file = pervasive orelse first

        val module_id =
          ModuleId.from_mo_string (name, location)

        val module_name_string = OS.Path.mkCanonical(ModuleId.string module_id)
      in
        case NewMap.tryApply'(require_table, module_name_string) of
          SOME _ =>
            do_subrequires options
            (false, project, require_table, pervasive, location, cons)
        | _ =>
            let
              val (consistency, stamps) =
                case Project.get_object_info (project, module_id)
                of SOME
                     {stamps,
                      consistency = Project.DEPEND_LIST cons, ...} =>
                  (cons, stamps)
                |  NONE =>
                  Crash.impossible
                    ("No object info for `" ^ module_name_string ^ "'")

              (* do_subrequires is called recursively on the consistency
                 info, to ensure that their stamps are allowed for. *)
              val (project, require_table) =
                do_subrequires options
                (true, project, require_table, is_pervasive_file,
                 location,
                 consistency)

              val stamp_count = Stamp.read_counter ()

              val _ = Stamp.reset_counter (stamp_count + stamps)

              val module_name_string =
                ModuleId.string
                  (Project.get_name (project, module_id))

              val req_info = (module_name_string, stamp_count, stamps)
            in
              do_subrequires
                options
                (false, project,
                 NewMap.define(require_table, module_name_string, req_info),
                 pervasive, location, cons)
            end
      end

  fun compile_require
      error_info
      (module_id, project, pervasive, location, require_table,
       counters as stamps, debug_info) =
    Timer.xtime
    ("Require",
     !print_timings,
     fn () =>
     let
       val root = ModuleId.string module_id
       val _ = diagnostic (2, fn _ => ["requireDec ", root])

       val (mo_str, mo_stamp) =
         case Project.get_object_info (project, module_id) of
           SOME {file, time_stamp, ...} => (file, time_stamp)
         | NONE =>
             Crash.impossible
               ("Required object file `" ^ root ^ "' in project "
                ^ (Project.get_project_name project) ^ " not found")

       val _ = diagnostic (2, fn _ => ["found mo: ", mo_str])

       val {parser_env, type_env=t_env, lambda_env,
            mod_name, consistency, stamps, ...} =
          Encapsulate.input_all mo_str
          handle Encapsulate.BadInput message =>
            Info.error' error_info  (Info.FATAL, Info.Location.UNKNOWN, message)

      fun error_wrap error_info =
        Info.wrap error_info
          (Info.FATAL, Info.RECOVERABLE, !error_output_level,
            location)

       val (project, require_table) =
         error_wrap 
           error_info
           do_subrequires
           (true, project, require_table, pervasive, location, consistency)

       (* note that counters have already been bumped up by *)
       (* do_subrequires *)

       val stamp_count = Stamp.read_counter ()

       val req_info = (mod_name, stamp_count, stamps)

       val mod_name = OS.Path.mkCanonical mod_name;
       val require_table =
         case NewMap.tryApply' (require_table, mod_name) of
           SOME _ => require_table
         | _ =>
             NewMap.define(require_table, mod_name, req_info)

       val (parser_env, lambda_env, t, _) =
         Encapsulate.decode_all
         {parser_env=parser_env,
          lambda_env=lambda_env,
          type_env=t_env,
          file_name=mod_name,
          sub_modules=require_table,
          decode_debug_information=false,
          pervasive_env=initial_env_for_normal_file}

       val _ = Stamp.reset_counter (stamp_count + stamps)

       val (top_env, decls) =
         LambdaModule.unpack
         (lambda_env,
          LambdaTypes.APP
            (LambdaTypes.BUILTIN Pervasives.LOAD_STRING,
             ([LambdaTypes.SCON (Ident.STRING mod_name, NONE)],[]),
             NONE))
     in
       (project, require_table,
        [{mod_name = mod_name,
          time = mo_stamp}],
          (* This is where the entry for the require list is made *)
        decls, CB(parser_env, t, top_env))
     end)

  fun compile_dependents error_info ([], 
         project, location, pervasive, require_table, requires,
         decls, req_cb,_,_) =
    (project, require_table, requires, decls, req_cb)
    | compile_dependents error_info (m::t,
         project, location, pervasive, require_table, requires,
         decls, req_cb, counters, debug_info) =
        let val (project, require_table, requires',
                 decls', req_cb') =
              compile_require error_info
                 (m, project, pervasive, 
                  location,
                  require_table, counters, debug_info)
         in compile_dependents error_info (t, 
               project, location, pervasive, require_table, 
               requires @@ requires', 
               decls @@ decls', augment_cb(req_cb, req_cb'), counters, debug_info)
        end

  (* compile_program takes a token stream and an initial compiler
   basis (which should be constructed from the included files) and
   returns a lambda expression and a final compiler basis.
   The cb contains those vars and strs declared in the
   stream, with names giving the indices into the tuple *)

  fun compile_program (error_info,
                       Options.OPTIONS({listing_options =
                                        Options.LISTINGOPTIONS listing_options,
                                        print_options,extension_options,
                                        compat_options,
                                        compiler_options=Options.COMPILEROPTIONS
                                        {generate_debug_info,debug_variables,
                                         generate_moduler,
                                         intercept,
                                         opt_leaf_fns, opt_handlers,
                                         opt_tail_calls,opt_self_calls,
                                         local_functions,
					 print_messages,
                                         mips_r4000,
                                         sparc_v7,...}}),
         project, module_id, ts, 
         initial, initial_require_table, initial_requires, initial_decls,
         pervasive) =
    let
      val mod_path = ModuleId.path module_id
      val Options.COMPATOPTIONS{old_definition,...} = compat_options
      val _ =
        diagnostic (2,
          fn _ => ["compile_program called with mod_path = `",
		   ModuleId.path_string mod_path, "'\n"])

      val options =
        Options.OPTIONS({listing_options = Options.LISTINGOPTIONS listing_options,
                         print_options = print_options,
                         extension_options = extension_options,
                         compat_options = compat_options,
                         compiler_options=Options.COMPILEROPTIONS
                         {generate_debug_info = generate_debug_info,
                          debug_variables =
                          debug_variables orelse generate_moduler,
                          generate_moduler = false,
                          intercept = false,
			  interrupt = false,
                          opt_handlers = opt_handlers,
                          opt_leaf_fns = opt_leaf_fns,
                          opt_tail_calls = opt_tail_calls,
                          opt_self_calls = opt_self_calls,
                          local_functions = local_functions,
			  print_messages = print_messages,
                          mips_r4000 = mips_r4000,
                          sparc_v7 = sparc_v7}})
      val filename = Lexer.associated_filename ts

      fun error_wrap error_info =
        Info.wrap error_info
          (Info.FATAL, Info.RECOVERABLE, !error_output_level,
           Info.Location.FILE filename)


      (* compile_topdec takes a path plus the env so far and delivers *)
      (* requires, the code, the updated initial env and *)
      (* the result of this compilation *)

      fun compile_topdec
	    (arg as (project, pervasive, mod_path, stamp_info,
		     cb1 as CB(p, t, c), cb2 as CB(p', t', c'), parse, eof,
		     counters as stamps, debug_info, had_topdec)) =
	let
	  val parse_env = Parser.augment_pB(p, p')
	  val (topdec, p'') =
            Timer.xtime(
	      "Parsing",
	      !print_timings,
	      (fn () => error_wrap error_info parse parse_env)
	    )
	  val _ = diagnose_simple "Parsing complete"
	in
	  (case topdec of
	    Absyn.REQUIREtopdec (root, location) =>
	      if had_topdec then
		Info.error'
		error_info
		(Info.FATAL, location, concat ["Too late for require statement"])
	      else
                (project, stamp_info, [],
		 empty_cb, counters, debug_info, false)

	  | Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [], _) =>
	     (if eof() then
		let
		  val stamp_count = Stamp.read_counter ()

		  val stamp_info = case stamp_info of
		    NONE => SOME stamp_count
		  |_ => stamp_info
		in
		  (project, stamp_info, [], 
		   empty_cb, counters, debug_info, true)
		end
	      else
                 compile_topdec
		   (project, pervasive, mod_path, stamp_info, 
		    cb1, cb2, parse, eof, counters,debug_info, true))
	  | _ =>
	      let
		val CB(p, t, c) = augment_cb(cb1, cb2)
		val stamp_count = Stamp.read_counter ()

		val stamp_info = case stamp_info of
		  NONE => SOME stamp_count
		|_ => stamp_info

		val t' = Timer.xtime
		  ("Type-checking ", !print_timings,
		   fn () => error_wrap
		   error_info
		   Mod_Rules.check_topdec
		   (options,true, topdec,t, Mod_Rules.BASIS t)
		   )

		val _ = Basis.reduce_chains t'
		val _ =
		  if (#show_absyn listing_options) then
		    (Info.listing_fn
		     error_info
		     (3, fn stream => TextIO.output(stream, "The abstract syntax\n"));
		     Info.listing_fn
		     error_info
		     (3, fn stream =>
		      TextIO.output(stream,
                        TopdecPrint.topdec_to_string options topdec));
		     Info.listing_fn
		     error_info
		     (3, fn stream => TextIO.output(stream, "\n"))
		     )
		  else ()

		val _ = diagnose_simple"Typechecking complete"
		val stamp_count = Stamp.read_counter () - stamp_count

		val (c', _, declarations,debug_info') =
                  Timer.xtime (
		    "Lambda translation",
		    ! print_timings,
                    fn () => error_wrap
			       error_info
			       Lambda.trans_top_dec
			         (options, topdec, c, Environ.empty_denv,
				  debug_info,
				  Basis.basis_circle_plus_basis (t, t'), true)
		  )

		val _ = diagnose_simple"Lambda translation complete"
	      in
		(project, stamp_info, 
                 declarations, CB(p'',t',c'),
		 stamps + stamp_count,
                 debug_info', true)
	      end)
	end	

      (* compile_topdecs takes unit and compiles all the
       topdecs remaining in the input stream, returning a
       (reverse-ordered) list of the declarations and a compiler basis
       which does not include the initial compiler basis *)

      fun compile_topdecs'
	(project, mod_path, stamp_info, code,
	 initial_cb, compiled_cb, parse, eof, counters,
	 debug_info, had_topdec) =
        let
          val (project, stamp_info, 
               declarations, comp_cb,
               counters, debug_info, had_topdec) =
            compile_topdec
	      (project, pervasive, mod_path, stamp_info,
	       initial_cb, compiled_cb, parse, eof, counters, debug_info,
	       had_topdec)

          val compiled_cb' = augment_cb(compiled_cb, comp_cb)
          val code' = code @@ declarations
        in
          if eof () then
            (project, stamp_info, code',
	     compiled_cb', counters,debug_info)
          else
            compile_topdecs'
	      (project, mod_path, stamp_info, code',
               initial_cb, compiled_cb', parse, eof,
	       counters, debug_info, had_topdec)
        end

      fun eof () = Lexer.eof ts
      val initial_counters = 0

      fun parse error_info pb = Parser.parse_topdec error_info (options,ts, pb)

      val (project, stamp_info, require_table, reqs_list, decls_list,
	   CB(pbasis, basis, top_env), counters, debug_info) =
        if eof () then
	  let
	    val stamp_count = Stamp.read_counter ()
	  in
            print "_toplevel: eof\n";
	    (project, SOME stamp_count,
	     empty_string_map, [], 
             [], empty_cb, initial_counters,
	     empty_debug_info)
	  end
	else
          let val dependents = 
                  Project.get_requires(project, module_id)
              val dependents = 
                  if pervasive 
                  then dependents 
                  else 
                    (*
                    ModuleId.perv_from_require_string
                      (Io.pervasive_library_name, Info.Location.UNKNOWN) 
                    :: *)
                    dependents 

              val (project, require_table, requires,
                   declarations, req_cb) =
                  compile_dependents error_info (dependents, 
                     project,
                    Info.Location.FILE filename,
                     true, initial_require_table,
                     initial_requires,initial_decls,initial,
                     initial_counters, empty_debug_info)

              val (project, stamp_info, code',
                   compiled_cb', counters,debug_info) =
                  compile_topdecs'
                     (project, mod_path, NONE,  
                      declarations, req_cb,
                      empty_cb, parse, eof, initial_counters,
                      empty_debug_info, false) 
	   in 
              (project, stamp_info, require_table, requires, code',
               compiled_cb', counters,debug_info) 
           end

      val (top_env'', lambda_exp') =
        LambdaModule.pack (top_env, decls_list)

    in
      (project, stamp_info, require_table, reqs_list, lambda_exp',
       CB (pbasis, basis, top_env''), counters,debug_info)
    end (* of compile_program *)

  fun do_input (error_info,
                options as Options.OPTIONS
                {listing_options = Options.LISTINGOPTIONS listing_options,
                 print_options,
                 compiler_options=
                 Options.COMPILEROPTIONS{generate_debug_info,
                                         debug_variables,
                                         generate_moduler,...},
                 ...},
                project, module_id, input_fn, filename, pervasive,
                { require_table = initial_require_table,
                  requires = initial_requires,
                  declarations = initial_decls,
                  compiler_basis = initial_cb,
                  lvar_count = initial_lvar,
                  stamp_count = initial_stamp_count}) =
    let
      val module_str = ModuleId.string module_id

      val _ =
        diagnostic (2,
          fn _ => ["do_input called on `", ModuleId.string module_id, "'\n"])

      val builtin = pervasive andalso 
	              ModuleId.eq(module_id, Io.builtin_library_id)

      fun error_wrap error_info =
        Info.wrap
 	  error_info
	  (Info.FATAL, Info.RECOVERABLE, !error_output_level,
	   Info.Location.FILE module_str)

      val mod_path = ModuleId.path module_id

      val _ = LambdaTypes.reset_counter initial_lvar

      val ts =
        let
          val stream_name =
            if pervasive then "<Pervasive>"
            else filename
        in
          Lexer.mkTokenStream (input_fn, stream_name)
        end

      val _ = Stamp.push_counter()
      val _ = Stamp.reset_counter initial_stamp_count 
    in
      let
	val _ = diagnostic_output 3 (fn _ => ["Cleaning refs in precompiled basis"])
	val _ = let val CB(_,basis,_) = initial_cb
                 in Encapsulate.clean_basis basis end
	(* Set all refs for encoding back to zero *)
	val _ = diagnostic_output 3 (fn _ => ["Cleaned refs in precompiled basis"])
	
	val _ =
	  diagnostic_output 3
	    (fn _ => ["Stamp reset to " ^
		      Int.toString(Stamp.read_counter()) ^ "\n"])

        (* Compile up to lambda translation *)
	val (project, stamp_info, require_table, requires, lambda_exp,
	     cb' as CB(parser_env, type_basis, top_env),
	     stamp_count,debug_information) =
	  compile_program (error_info, options, project,
			   module_id, ts, 
                           initial_cb, initial_require_table, 
                           initial_requires, initial_decls,
                           pervasive)

        (* Need to hack in the final counts of tynames etc. *)

        val stamps =
          case stamp_info of
	    SOME stamps => stamps
          | _ => Crash.impossible "Garbled stamp info"

        val final_stamp_count = Stamp.read_counter ()

        val require_list =
          ("", stamps,final_stamp_count - stamps)
	  :: NewMap.range require_table

	val src_info = Project.get_source_info (project, module_id)

	val src_time =
	  case src_info
	  of SOME (_, time) => time
	  |  NONE =>
	    Crash.impossible
	      ("Can't find source time for `" ^ filename ^ "'")

	val _ =
	  if (#show_lambda listing_options) then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The unoptimised lambda code\n"));
	     Info.listing_fn error_info
	     (3, fn stream =>
	      LambdaPrint.output_lambda options (stream, lambda_exp)))
	  else ()

	val opt_lambda_exp =
	  if (!do_lambda_opt) then
	    Timer.xtime("LambdaOptimiser",
			!print_timings,
			fn () => LambdaOptimiser.optimise options lambda_exp)
	  else
	    lambda_exp

	val _ = diagnose_simple ("Lambda optimisation complete")
	val _ =
	  if (#show_opt_lambda listing_options) then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The optimised lambda code\n"));
	     Info.listing_fn error_info
	     (3, fn stream =>
	      LambdaPrint.output_lambda options (stream, opt_lambda_exp)))
	  else ()

        val top_env = Environ.simplify_topenv (top_env,opt_lambda_exp)

	val _ =
	  if (#show_environ listing_options) then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The environment\n"));
	     Info.listing_fn error_info
	     (3, EnvironPrint.printtopenv print_options top_env);
	     Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "\n")))
	  else ()

	val (the_mir_code,debugger_information) =
	  Timer.xtime("Mir_Cg",
		      ! print_timings,
		      fn () => error_wrap
		      error_info
		      Mir_Cg.mir_cg
		      (options, opt_lambda_exp,
		       module_str, debug_information)
		      )

	val _ = diagnose_simple"Mir translation complete"

	val _ =
	  if #show_mir listing_options then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The unoptimised intermediate code\n"));
	     Info.listing_fn error_info (3, MirPrint.print_mir_code the_mir_code))
	  else
	    ()
        val make_debugging_code = generate_debug_info (* For the moment *)
	val the_optimised_code =
	  Timer.xtime("MirOptimiser", ! print_timings,
		      fn () => MirOptimiser.optimise (the_mir_code,make_debugging_code));

	val _ = diagnose_simple"Mir optimisation complete"
	val _ =
	  if #show_opt_mir listing_options then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The optimised intermediate code\n"));
	     Info.listing_fn error_info (3, MirPrint.print_mir_code the_optimised_code))
	  else
	    ()

	val ((the_machine_code,debugger_information), code_list_list) =
	  let
	    val assign = MirOptimiser.machine_register_assignments
	  in
	    Timer.xtime("Mach_Cg",
			! print_timings,
			fn () => error_wrap
			error_info
			Mach_Cg.mach_cg
			(options, the_optimised_code,
			 (#gc assign, #non_gc assign, #fp assign),
			 debugger_information)
			)
	  end

	val _ = diagnose_simple"Machine code translation complete"

	val _ =
	  if #show_mach listing_options then
	    (Info.listing_fn
	     error_info
	     (3, fn stream => TextIO.output(stream, "The final machine code\n"));
	     Info.listing_fn error_info (3, MachPrint.print_mach_code code_list_list))
	  else
	    ()

	val mo_name =
	  if pervasive then
	    Project.pervasiveObjectName module_id
	  else
	    Project.objectName
	      (error_info, Info.Location.FILE module_str)
	      (project, module_id)

	val top_env =
	  if builtin then
	    if Primitives.check_builtin_env
		 {error_fn =
		    fn s =>
		      Info.error
			error_info
			(Info.RECOVERABLE, Info.Location.FILE module_str, s),
		  topenv = top_env}
	    then
	      (Print.print "*** Changing top level environment\n";
	       after_builtin_cgb)
	    else
              Info.error'
                error_info
                (Info.FATAL, Info.Location.FILE module_str,
		 "Builtin library doesn't match pervasives")
	  else
	    top_env

        (* We explicitly set the debug info to nothing even if we aren't
	   supposed to be generating it *)
	val _ =
	  Timer.xtime
	    ("Outputting", !print_timings,
	     fn () =>
	       (Encapsulate.output_file
		  (debug_variables orelse generate_moduler)
		  {filename = mo_name,
                   code = the_machine_code, parser_env = parser_env,
                   type_basis = type_basis,
                   debug_info =
		     if generate_debug_info then
		       debugger_information
		     else
		       empty_debug_info,
                   require_list = require_list,
		   lambda_env = top_env,
                   stamps = stamp_count,
		   mod_name = ModuleId.string module_id,
		   time_stamp = src_time,
                   consistency = requires}))
	  handle IO.Io _ =>
	    Info.error'
	      error_info
	      (Info.FATAL, Info.Location.FILE module_str,
	       "Can't create object file `" ^ mo_name ^ "'\n");

	val new_mo_time = FileTime.modTime mo_name
	(* Now output the .S files. Later this will produce .o from .mo *)
        (* Disabled until work restarts on DLL development *)
	(* val _ = Object_Output.output_object_code
  	     (Object_Output.ASM, module_id, mo_name, project)
	     (Encapsulate.input_code mo_name) *)

	val _ =
	  Project.set_object_info
	  (project, module_id,
	   SOME {file = mo_name,
		 file_time = new_mo_time,
		 time_stamp = src_time,
		 stamps = stamp_count,
		 consistency = Project.DEPEND_LIST requires})
      in
	Stamp.pop_counter();
	project
      end
      handle exn =>
        (Stamp.pop_counter();
         raise exn)
    end


  fun compile_file''
	error_info
	(options as Options.OPTIONS
	 {compiler_options = Options.COMPILEROPTIONS
	  {print_messages, ...}, ...}, 
         project, module_id, pervasive,
         precompiled_context) =
    Timer.xtime
    ("Compilation", !print_timings,
     fn () =>
     let
       val source_info = Project.get_source_info (project, module_id)

       val file_name =
	 case source_info
	 of SOME (file_name, _) => file_name
	 |  NONE =>
	   Crash.impossible
	     ("No source info while compiling `"
	      ^ ModuleId.string module_id ^ "'")

       val _ =
	 if print_messages then
	   Print.print ("Compiling " ^ file_name ^ "\n")
	 else ()

       val instream =
         TextIO.openIn file_name
         handle IO.Io{name, function, cause} =>
           Info.error'
	     error_info
	     (Info.FATAL, Info.Location.UNKNOWN,
	      "Io error in compile_file: " ^ name)

       val module_str = ModuleId.string module_id

       val result =
         do_input (error_info, options, project, module_id,
		   fn _ => TextIO.inputN(instream, 4096), file_name, pervasive,
                   precompiled_context)
         handle exn => (TextIO.closeIn instream; raise exn)
     in
       TextIO.closeIn instream;
       result
     end)

  fun check_pervasive_objects_exist(error_info, location, project) =
    let
      val units = Project.list_units project
      fun check_one_unit(string, module_id) =
	case Project.get_object_info(project, module_id) of
	  NONE => Info.error
	    error_info
	    (Info.FATAL, location, "Missing pervasive object file `" ^ string ^ "'")
	| _ => ()
    in
      Lists.iterate check_one_unit units
    end

  type precompiled_context =
    { 
      require_table: (string, (string * int * int)) NewMap.map,
      requires: {mod_name: string, time: MLWorks.Internal.Types.time} list,
      declarations: LambdaTypes.binding list,
      compiler_basis: compiler_basis,
      lvar_count: int,
      stamp_count: int
    }

  fun precompile error_info (project, is_pervasive, dependents)
      : precompiled_context =
    let val initial_cb = 
          if is_pervasive 
          then initial_cb_for_builtin_library
          else initial_cgb_for_normal_file

        val dependents' = 
          if is_pervasive 
          then dependents 
          else
            let val pervasive_dependent = 
              (Project.initialize (error_info, Info.Location.UNKNOWN),
               ModuleId.perv_from_require_string
                 (Io.pervasive_library_name, Info.Location.UNKNOWN))
            in
              pervasive_dependent :: dependents
            end

        fun precompile_dependents ([], 
               location, pervasive, require_table, requires,
               decls, req_cb,_,_) =
              let val final_count = Stamp.read_counter()
                  val final_lvar = LambdaTypes.read_counter()
                  val ctxt : precompiled_context =
                     { require_table = require_table,
                       requires = requires, 
                       declarations = decls, 
                       compiler_basis = req_cb, 
                       lvar_count = final_lvar, 
                       stamp_count = final_count }
               in Stamp.pop_counter();
                  ctxt
              end
          | precompile_dependents ((project,m)::t,
               location, pervasive, require_table, requires,
               decls, req_cb, counters, debug_info) =
              let val (_, require_table, requires',
                       decls', req_cb') =
                    compile_require error_info
                       (m, project, pervasive, 
                        location,
                        require_table, counters, debug_info)
               in precompile_dependents (t, 
                     location, pervasive, require_table, 
                     requires @@ requires', 
                     decls @@ decls', augment_cb(req_cb, req_cb'), 
                     counters, debug_info)
              end

     in
       case dependents of
         [] => ()
       | _ => 
         ( print "Precompiling ";
           app (fn (_,m) => print(ModuleId.string m ^ " ")) dependents;
           print "\n" );
       Stamp.push_counter();
       Stamp.reset_counter Basis.pervasive_stamp_count;
       LambdaTypes.init_LVar ();

       precompile_dependents (
         dependents',
         Info.Location.UNKNOWN,
         true, empty_string_map,
                     [],[],initial_cb,
                     0, empty_debug_info)
    end

    fun get_precompiled_context (project, pervasive, error_info) =
      let 
        val precompiled_context = ref NONE
      in 
        fn () =>
          case !precompiled_context of
            NONE => 
              let val dependents =
                    Project.get_external_requires project
                  val context = 
                    precompile error_info (project, pervasive, dependents)
               in precompiled_context := SOME context; context end
          | SOME context => context
      end


  fun compile_file error_info options filenames =
    let
      val location = Info.Location.FILE "<batch compiler:compile-file>"

      val modules = map OS.Path.file filenames

      val init_project = Project.initialize (error_info, location)

      val _ = check_pervasive_objects_exist(error_info, location, init_project)

      val precompiled_context = 
        get_precompiled_context(init_project, false, error_info)

      fun compile_one ((project, status_map), module) =
	let
	  fun do_compile_one mod_id =
	    let
              val (project, status_map) =
                Project.read_object_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, status_map);

	      val project =
	        compile_file''
                  error_info
	          (options, project, mod_id, false,
                   precompiled_context());
	    in
	      (project, status_map)
	    end
	in
	  do_compile_one (ModuleId.from_host (module, location))
	end
    in
      ignore(Lists.reducel
	compile_one
	((init_project, Project.empty_map), modules));
      ()
    end

  fun recompile_file error_info options filenames =
    let
      val location = Info.Location.FILE "<batch compiler:recompile-file>"

      val modules = map OS.Path.file filenames

      val init_project = Project.initialize (error_info, location)

      val _ = check_pervasive_objects_exist(error_info, location, init_project)

      val precompiled_context = 
        get_precompiled_context(init_project, false, error_info)

      fun recompile_one
	    ((project, depend_map, compile_map), module) =
	let
	  fun compile_one (proj, m) =
	    compile_file''
              error_info
	      (options, proj, m, false,
               precompiled_context());

	  fun do_recompile_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map);

	      val (out_of_date, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          ([], compile_map)

	      val project =
	        Lists.reducel compile_one (project, out_of_date);

	      val status_map =
	        Lists.reducel Project.mark_compiled (compile_map, out_of_date)
	    in
	      (project, depend_map, compile_map)
	    end
	in
	  do_recompile_one (ModuleId.from_host (module, location))
	end
    in
      ignore(Lists.reducel
	recompile_one
	((init_project, Project.empty_map, Project.visited_pervasives),
	 modules));
      print"Up to date\n"
    end

  fun recompile_pervasive error_info options =
    let
      val location = Info.Location.FILE "<batch compiler:compile-pervasive>"
      val project = Project.initialize (error_info, location)

      val precompiled_context = 
        get_precompiled_context(project, true, error_info)()

      fun context_for module_id = 
        if ModuleId.eq(module_id, Io.builtin_library_id)
        then precompiled_context
        else
          let val {require_table, requires, declarations, compiler_basis, 
                   lvar_count, stamp_count} = precompiled_context
           in {require_table = require_table, requires = requires,
               declarations = declarations,
               compiler_basis = initial_cgb_for_normal_file,
               lvar_count = lvar_count, stamp_count = stamp_count}
          end

      val out_of_date =
	Project.check_perv_compiled
	(error_info, location)
	project

      fun compile_one (proj, m) =
	compile_file''
	error_info
	(options, proj, m, true, context_for m);
    in
      ignore(Lists.reducel compile_one (project, out_of_date));
      print"Up to date\n"
    end

  fun check_dependencies error_info options filenames =
    let
      val location = Info.Location.FILE "<batch compiler:check-dependencies>"

      val modules = map OS.Path.file filenames

      val project = Project.initialize (error_info, location)

      fun check_one
	    ((project, out_of_date, depend_map, compile_map),
	     module) =
	let
	  fun do_check_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map)

	      val (out_of_date_now, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          (out_of_date, compile_map)
	    in
	      (project, out_of_date_now, depend_map, compile_map)
	    end
	in
	  do_check_one (ModuleId.from_host (module, location))
	end

      val (_, out_of_date, _, _) =
	Lists.reducel
	  check_one
	  ((project, [], Project.empty_map, Project.visited_pervasives),
	   modules)

      fun print_one m = print(ModuleId.string m ^ "\n")
    in
      case out_of_date
      of [] =>
	print"No files to recompile\n"
      |  _ =>
        app print_one out_of_date
    end

  fun dump_objects error_info options filename =
    let
      val location = Info.Location.FILE "<batch compiler:dump objects>"

      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))

      val project =
	Project.map_dag (Project.update_dependencies (error_info, location))
                        initProject

      val units = Project.list_units project
      val targets = 
          ( map (fn t => Lists.assoc(
                           OS.Path.base(OS.Path.mkCanonical t), units))
                (Project.currentTargets project) )
          handle _ => []

      val units' = map #2 units

      fun requires m =
        Lists.filterp 
          (fn m' => Lists.exists (fn m'' => ModuleId.eq(m', m'')) units')
          (Project.get_requires(project, m))

      fun topsort targets = 
        let fun sort([],    visited) = visited 
              | sort(x::xs, visited) =
                  sort(xs, 
                       if Lists.exists (fn x' => ModuleId.eq(x, x')) visited 
                       then visited 
                       else x :: sort(requires x, visited))
         in sort(targets, [])
        end;

      fun reverse l =
        let fun rev([], r) = r
              | rev(h::t, r) = rev(t, h::r)
         in rev(l, [])
        end

      val units = reverse(topsort targets)

    in
      let val stream = TextIO.openOut filename      
       in app (fn m => TextIO.output(stream, ModuleId.string m ^ ".mo\n"))
              units;
          TextIO.closeOut stream
      end
      handle IO.Io _ =>
               Info.error'
	       error_info
	       (Info.FATAL, location,
	         "Can't create dump file `" ^ filename ^ "'\n")
    end

  fun list_objects error_info options filenames =
    let
      val location = Info.Location.FILE "<batch compiler:list-objects>"

      val modules = map OS.Path.file filenames

      val project = Project.initialize (error_info, location)

      fun check_one
	    ((project, out_of_date, depend_map),
	     module) =
	let
	  fun do_check_one mod_id =
	    let
	      (* Use Project.read_dependencies, not
		 Project.read_object_dependencies, because the latter
		 reads only the source information for the first file.
		 (Possibly that behaviour should be improved). *)

              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map)

	      val out_of_date_now =
	        Project.allObjects
	          (Info.make_default_options (), location)
	          (project, mod_id)
	    in
	      (project, out_of_date_now @@ out_of_date, depend_map)
	    end
	in
	  do_check_one (ModuleId.from_host (module, location))
	end

      val (_, out_of_date, _) =
	Lists.reducel
	  check_one
	  ((project, [], Project.empty_map),
	   modules)

      fun print_one m = print(ModuleId.string m ^ "\n")
    in
      case out_of_date
      of [] =>
	print"No files to recompile\n"
      |  _ =>
        app print_one out_of_date
    end

  fun build_targets_for (error_info, options, location) project =
      let
        val initProject =
   	  Project.update_dependencies (error_info, location) project

        val precompiled_context = 
          get_precompiled_context(initProject, false, error_info)

        fun recompile_one
	      ((project, depend_map, compile_map), module) =
	  let
	    fun compile_one (proj, m) =
	        compile_file''
                  error_info
	          (options, proj, m, false,
                   precompiled_context());

	    fun do_recompile_one mod_id =
	      let
                val (project, depend_map) =
                  Project.read_dependencies
                    (Info.make_default_options (), location)
                    (project, mod_id, depend_map);

	        val (out_of_date, compile_map) =
	          Project.check_compiled'
	            (Info.make_default_options (), location)
	            (project, mod_id)
	            ([], compile_map)

	        val project =
	          Lists.reducel compile_one (project, out_of_date);

	        val status_map =
	          Lists.reducel Project.mark_compiled (compile_map, out_of_date)
	      in
	        (project, depend_map, compile_map)
	      end
	  in
	    do_recompile_one (ModuleId.from_host (OS.Path.file module, location))
	  end

        val project' = 
          #1(Lists.reducel
              recompile_one
	      ((initProject, Project.empty_map, Project.visited_pervasives),
	       Project.currentTargets project))
      in
        project'
      end

  fun build error_info options _ =
    let
      val location = Info.Location.FILE "<batch compiler:build>"
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))
    in
      ignore(Project.map_dag 
        (build_targets_for (error_info, options, location)) initProject);
      print"Up to date\n"
    end


  fun show_build_targets_for (error_info, options, location) project =
    let
      val initProject =
	Project.update_dependencies (error_info, location) project

      fun check_one
	    ((project, out_of_date, depend_map, compile_map),
	     module) =
	let
	  fun do_check_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map)

	      val (out_of_date_now, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          (out_of_date, compile_map)
	    in
	      (project, out_of_date_now, depend_map, compile_map)
	    end
	in
	  do_check_one (ModuleId.from_host (OS.Path.file module, location))
	end

      val (project', out_of_date, _, _) =
	Lists.reducel
	  check_one
	  ((initProject, [], Project.empty_map, Project.visited_pervasives),
	   Project.currentTargets initProject)

      val name = Project.get_project_name project
      fun print_one m = print(ModuleId.string m ^ "\n")
    in
      case out_of_date
      of [] =>
	print ("No files to recompile for " ^ name ^ "\n")
      |  _ =>
        ( print ("Files to recompile for " ^ name ^ ":\n");
          app print_one out_of_date );
      project'
    end

  fun show_build error_info options _ =
    let
      val location = Info.Location.FILE "<batch compiler:show_build>"
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))
    in
      ignore(
        Project.map_dag 
          (show_build_targets_for (error_info, options, location)) initProject);
      ()
    end

  fun compile_file'
	error_info
	(options, project, []) = project
    | compile_file'
	error_info
	(options, project, module_ids) =

     let val precompiled_context = 
           get_precompiled_context(project, false, error_info) 

         fun compile_one (proj, m) =
            compile_file''
              error_info
              (options, proj, m, false, precompiled_context()) 

         val module_ids' = 
               Lists.filterp 
                 (fn m => Project.module_id_in_project (project, m))
                 module_ids
      in
        Lists.reducel compile_one (project, module_ids')
     end
end












@


1.262.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.262  1999/03/23  17:37:54  mitchell
 * [Bug #190532]
 * Ensure update_dependencies is called on subprojects first
 *
@


1.261
log
@[Bug #190532]
Build subprojects before building project
@
text
@d6 4
d2197 2
a2198 1
	Project.update_dependencies (error_info, location) initProject
d2354 2
a2355 2
      Project.map_dag 
        (build_targets_for (error_info, options, location)) initProject;
d2359 2
a2360 1
  fun show_build error_info options _ =
a2361 7
      val location = Info.Location.FILE "<batch compiler:show_build>"

      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))

d2363 1
a2363 1
	Project.update_dependencies (error_info, location) initProject
d2388 1
a2388 1
      val (_, out_of_date, _, _) =
d2394 1
d2399 1
a2399 1
	print"No files to recompile\n"
d2401 17
a2417 1
        app print_one out_of_date
@


1.260
log
@[Bug #190505]
Suppress precompiling messages for pervasives
@
text
@d6 4
d1072 2
a1073 1
  type ParserBasis = Parser.ParserBasis
d1078 2
d2290 51
a2343 1

a2347 40

      val initProject =
	Project.update_dependencies (error_info, location) initProject

      val precompiled_context = 
        get_precompiled_context(initProject, false, error_info)

      fun recompile_one
	    ((project, depend_map, compile_map), module) =
	let
	  fun compile_one (proj, m) =
	    compile_file''
              error_info
	      (options, proj, m, false,
               precompiled_context());

	  fun do_recompile_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map);

	      val (out_of_date, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          ([], compile_map)

	      val project =
	        Lists.reducel compile_one (project, out_of_date);

	      val status_map =
	        Lists.reducel Project.mark_compiled (compile_map, out_of_date)
	    in
	      (project, depend_map, compile_map)
	    end
	in
	  do_recompile_one (ModuleId.from_host (OS.Path.file module, location))
	end
d2349 2
a2350 4
      ignore(Lists.reducel
	recompile_one
	((initProject, Project.empty_map, Project.visited_pervasives),
	 Project.currentTargets initProject));
@


1.259
log
@[Bug #190505]
Don't precompile the pervasives when compiling the pervasives...
@
text
@d6 4
d1968 1
a1968 1
       case dependents' of
d1972 1
a1972 1
           app (fn (_,m) => print(ModuleId.string m ^ " ")) dependents';
@


1.258
log
@[Bug #190505]
Support for precompilation of subprojects
@
text
@d6 4
d1916 3
a1918 5
          initial_cgb_for_normal_file
        val pervasive_dependent = 
          (Project.initialize (error_info, Info.Location.UNKNOWN),
           ModuleId.perv_from_require_string
               (Io.pervasive_library_name, Info.Location.UNKNOWN))
d1924 7
a1930 1
             pervasive_dependent :: dependents
d1964 6
a1969 3
       print "Precompiling ";
       app (fn (_,m) => print(ModuleId.string m ^ " ")) dependents';
       print "\n";
d2098 13
a2110 1
        get_precompiled_context(project, false, error_info)
d2120 1
a2120 2
	(options, proj, m, true,
         precompiled_context());
@


1.257
log
@[Bug #190502]
Disable generation of .S files
@
text
@d6 4
d1123 1
a1123 1
  val empty_string_map = NewMap.empty ((op<):string*string->bool, (op=) : string * string -> bool)
d1140 171
d1332 3
a1334 1
         project, mod_path, ts, initial, pervasive) =
d1336 1
d1367 2
a1368 2
	  (Info.FATAL, Info.RECOVERABLE, !error_output_level,
	   Info.Location.FILE filename)
a1369 66
      (* The require_table maps module names to pair of module_names with
	 pairs of a stamp count and the stamps for that module.  I have no
	 idea why the module name is stored in the range of the map as well
	 as the domain. *)
      fun do_subrequires
	    options
	    (first, project, require_table, _, nil) =
	(project, require_table)
      |   do_subrequires
	    options
	    (first, project, require_table, pervasive,
	     {mod_name = name, time} :: cons) =
	  let
	    val _ =
	      diagnostic (3,
	      fn _ => ["do_subrequires of ", name, ", pervasive = ",
		       if pervasive then "true\n" else "false\n"])

	    val is_pervasive_file = pervasive orelse first

	    val module_id =
	      ModuleId.from_mo_string (name, Info.Location.FILE filename)


	    val module_name_string = ModuleId.string module_id
	  in
	    case NewMap.tryApply'(require_table, module_name_string) of
	      SOME _ =>
		do_subrequires options
		(false, project, require_table, pervasive, cons)
	    | _ =>
		let
		  val (consistency, stamps) =
		    case Project.get_object_info (project, module_id)
		    of SOME
			 {stamps,
			  consistency = Project.DEPEND_LIST cons, ...} =>
		      (cons, stamps)
		    |  NONE =>
		      Crash.impossible
			("No object info for `" ^ module_name_string ^ "'")

		  (* do_subrequires is called recursively on the consistency
		     info, to ensure that their stamps are allowed for. *)
		  val (project, require_table) =
		    do_subrequires options
		    (true, project, require_table, is_pervasive_file,
		     consistency)

		  val stamp_count = Stamp.read_counter ()

		  val _ = Stamp.reset_counter (stamp_count + stamps)

		  val module_name_string =
		    ModuleId.string
		      (Project.get_name (project, module_id))

		  val req_info = (module_name_string, stamp_count, stamps)
		in
		  do_subrequires
		    options
		    (false, project,
		     NewMap.define(require_table, module_name_string, req_info),
		     pervasive, cons)
		end
	  end
d1376 1
a1376 1
	    (arg as (project, pervasive, mod_path, stamp_info, require_table,
d1396 2
a1397 14
		Timer.xtime
		("Require",
		 !print_timings,
		 fn () =>
		 let
 		   val _ = diagnostic (2, fn _ => ["requireDec ", root])

		   val sub_module_id =
		     if pervasive then
		       ModuleId.perv_from_require_string (root, location)
		     else
		       ModuleId.from_require_string (root, location)

		   val module_id = ModuleId.add_path(ModuleId.empty_path, sub_module_id)
a1398 64
		   val (mo_str, mo_stamp) =
		     case Project.get_object_info (project, module_id) of
		       SOME {file, time_stamp, ...} => (file, time_stamp)
		     | NONE =>
			 Crash.impossible
			   ("Required object file `"
			    ^ ModuleId.string module_id ^ "' not found")

 		   val _ = diagnostic (2, fn _ => ["found mo: ", mo_str])

		   val {parser_env, type_env=t_env, lambda_env,
			mod_name, consistency, stamps, ...} =
		      Encapsulate.input_all mo_str
		      handle Encapsulate.BadInput message =>
			Info.error' error_info  (Info.FATAL, location, message)

		   val (project, require_table) =
		     error_wrap
		       error_info
		       do_subrequires
		       (true, project, require_table, pervasive, consistency)

		   (* note that counters have already been bumped up by *)
		   (* do_subrequires *)

		   val stamp_count = Stamp.read_counter ()

                   val mod_name = OS.Path.mkCanonical mod_name;

		   val req_info = (mod_name, stamp_count, stamps)

		   val require_table =
		     case NewMap.tryApply' (require_table, mod_name) of
		       SOME _ => require_table
		     | _ =>
			 NewMap.define(require_table, mod_name, req_info)

		   val (parser_env, lambda_env, t, _) =
		     Encapsulate.decode_all
		     {parser_env=parser_env,
		      lambda_env=lambda_env,
		      type_env=t_env,
		      file_name=mod_name,
		      sub_modules=require_table,
		      decode_debug_information=false,
		      pervasive_env=initial_env_for_normal_file}

		   val _ = Stamp.reset_counter (stamp_count + stamps)

		   val (top_env, decls) =
		     LambdaModule.unpack
		     (lambda_env,
		      LambdaTypes.APP
			(LambdaTypes.BUILTIN Pervasives.LOAD_STRING,
		         ([LambdaTypes.SCON (Ident.STRING mod_name, NONE)],[]),
			 NONE))
		 in
		   (project, stamp_info, require_table,
		    [{mod_name = mod_name,
		      time = mo_stamp}],
		      (* This is where the entry for the require list is made *)
		    decls, CB(parser_env, t, top_env), empty_cb,
		    counters, debug_info, false)
		 end)
d1408 1
a1408 1
		  (project, stamp_info, require_table, [], [], empty_cb,
d1413 1
a1413 1
		   (project, pervasive, mod_path, stamp_info, require_table,
d1466 2
a1467 2
		(project, stamp_info, require_table, [],
                 declarations, empty_cb, CB(p'',t',c'),
d1479 1
a1479 1
	(project, mod_path, stamp_info, require_table, reqs, code,
d1483 2
a1484 2
          val (project, stamp_info, require_table, requires,
               declarations, req_cb, comp_cb,
d1487 1
a1487 1
	      (project, pervasive, mod_path, stamp_info, require_table,
a1491 1
          val reqs' = reqs @@ requires
d1495 1
a1495 1
            (project, stamp_info, require_table, reqs', code',
d1499 2
a1500 2
	      (project, mod_path, stamp_info, require_table, reqs', code',
               augment_cb(initial_cb, req_cb), compiled_cb', parse, eof,
d1515 1
d1517 2
a1518 1
	     empty_string_map, [], [], empty_cb, initial_counters,
d1522 32
a1553 48
	  if not pervasive then
	    let
	      val the_expression = ref ""

              val pervasive_library_dir =
		Io.get_pervasive_dir ()
		handle Io.NotSet _ =>
		  Info.error'
		    error_info
		    (Info.FATAL,
		     Info.Location.UNKNOWN,
		     "Pervasive directory not set")

	      val _ =
                the_expression :=
		"require \"" ^ Io.pervasive_library_name ^ "\" ; "

	      fun lex_fun _ =
		let
		  val a = !the_expression
		in
		  the_expression := "";
		  a
		end
	      val token_stream = Lexer.mkTokenStream(lex_fun, "<Pervasive Input>")

	      val (project, stamp_info, require_table, reqs_list,
		   decls_list, full_env, _, counters, debug_info, _) =
		compile_topdec
		  (project, true, ModuleId.empty_path, NONE,
		   empty_string_map, initial, initial_cgb_for_normal_file,
		   fn opts => fn pb =>
			Parser.parse_topdec opts (options,token_stream, pb),
		   fn () => Lexer.eof token_stream,
		   initial_counters, empty_debug_info, false)

	    in
	      compile_topdecs'
		(project, mod_path, stamp_info, require_table, reqs_list,
		 decls_list, augment_cb(initial_cgb_for_normal_file, full_env),
		 empty_cb, parse, eof, initial_counters, empty_debug_info,
		 false)
	    end
	  else
	    compile_topdecs'
	     (project, mod_path, NONE, empty_string_map, [],
	      [], initial, empty_cb, parse, eof, initial_counters,
	      empty_debug_info, false)
d1572 7
a1578 1
                project, module_id, input_fn, filename, pervasive) =
d1586 2
a1587 16
      val (initial_cb, builtin) =
        if pervasive then
	  if ModuleId.eq(module_id, Io.builtin_library_id) then
            (Info.error
               error_info
               (Info.WARNING, Info.Location.FILE module_str,
	        "Compiling as the builtin library");
             (initial_cb_for_builtin_library, true))
          else
             (Info.error
                error_info
                (Info.WARNING, Info.Location.FILE module_str,
	         "Compiling as pervasive");
              (initial_cgb_for_normal_file, false))
        else
          (initial_cgb_for_normal_file, false)
d1597 1
a1597 1
      val _ = LambdaTypes.init_LVar ()
d1609 1
a1609 1
      val _ = Stamp.reset_counter Basis.pervasive_stamp_count
d1612 3
a1614 2
	val _ = diagnostic_output 3 (fn _ => ["Cleaning refs in initial basis"])
	val _ = Encapsulate.clean_basis Basis.initial_basis
d1616 1
a1616 1
	val _ = diagnostic_output 3 (fn _ => ["Cleaned refs in initial basis"])
d1628 4
a1631 1
			   mod_path, ts, initial_cb, pervasive)
d1840 1
a1840 1
  fun compile_file'
d1844 3
a1846 1
	  {print_messages, ...}, ...}, project, module_id, pervasive) =
d1874 2
d1878 2
a1879 1
		   fn _ => TextIO.inputN(instream, 4096), file_name, pervasive)
d1899 88
d1997 3
d2010 1
a2010 1
	        compile_file'
d2012 2
a2013 1
	          (options, project, mod_id, false);
d2037 3
d2044 1
a2044 1
	    compile_file'
d2046 2
a2047 1
	      (options, proj, m, false);
d2086 3
d2095 1
a2095 1
	compile_file'
d2097 2
a2098 1
	(options, proj, m, true);
d2269 3
d2276 1
a2276 1
	    compile_file'
d2278 2
a2279 1
	      (options, proj, m, false);
d2363 22
d2386 12
@


1.256
log
@[Bug #190504]
Add ability to dump units in dependency order
@
text
@d6 4
d1800 4
a1803 3
	val _ = Object_Output.output_object_code
	  (Object_Output.ASM, module_id, mo_name, project)
	  (Encapsulate.input_code mo_name)
@


1.255
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@d6 4
d2021 57
@


1.254
log
@[Bug #70194]
Generate object output direct from .mo files
@
text
@d6 4
d1318 2
d1553 1
a1553 1
	  if module_id = Io.builtin_library_id then
@


1.253
log
@[Bug #70218]
Modified interface to output_object_code.
Also moving this to after output of mo, so that later it can use that instead
of direct compiler output. This will allow testing on .o from .mo stuff
@
text
@d6 6
d1788 1
a1788 1
	  the_machine_code
@


1.252
log
@[Bug #70133]
Add COFF outputter
@
text
@d6 4
a1729 4
	val _ = Object_Output.output_object_code
	  (Object_Output.ASM, module_id, mo_name, project)
	  (the_machine_code, code_list_list)

d1779 5
@


1.251
log
@[Bug #70109]
Making printing of compiling messages dependent
on the print_messages field of options
@
text
@d6 5
d917 1
d947 1
d997 2
a998 2
  sharing type Mach_Cg.Opcode = MachPrint.Opcode
  sharing type Mach_Cg.Module = Encapsulate.Module
d1004 1
a1004 1
  sharing type ModuleId.ModuleId = Project.ModuleId = Io.ModuleId
d1010 1
d1718 12
a1748 8

	val mo_name =
	  if pervasive then
	    Project.pervasiveObjectName module_id
	  else
	    Project.objectName
	      (error_info, Info.Location.FILE module_str)
	      (project, module_id)
@


1.250
log
@[Bug #30389]
Keep projects more in step with projfiles
@
text
@d6 4
d1787 3
a1789 1
	(options, project, module_id, pervasive) =
d1804 4
a1807 1
       val _ = Print.print ("Compiling " ^ file_name ^ "\n")
@


1.249
log
@[Bug #70099]
Modify following changes to encapsulation order
@
text
@d6 4
d2040 3
d2091 3
@


1.248
log
@[Bug #30312]
Replacing OS.FileSys.modTime with system dependent version to sort out
MS time stamp problems.
@
text
@d4 1
a4 1
 * 
d6 5
d949 1
a949 1
          
d996 1
a996 1
  
d1051 1
a1051 1
    
d1065 2
a1066 2
    CB (Parser.initial_pB_for_builtin_library, 
        Basis.initial_basis_for_builtin_library, 
d1070 1
a1070 1
    CB (Parser.initial_pB, 
d1094 2
a1095 2
    CB (Parser.augment_pB (p, p'), 
        Basis.basis_circle_plus_basis(t, t'), 
d1103 1
a1103 1
      
d1105 1
a1105 1
                       Options.OPTIONS({listing_options = 
d1119 1
a1119 1
         project, mod_path, ts, initial, pervasive) = 
d1127 1
a1127 1
      val options = 
d1165 1
a1165 1
	     {mod_name = name, req_name, time} :: cons) =
d1190 1
a1190 1
			  consistency = Project.DEPEND_LIST cons, ...} => 
d1211 1
a1211 1
		  val req_info = (module_name_string, (stamp_count,stamps))
d1288 1
a1288 1
		   val req_info = (mod_name, (stamp_count,stamps))
d1296 9
a1304 4
		   val (t, _) =
                      Encapsulate.decode_type_basis
                        (t_env, mod_name, require_table, false,
			 initial_env_for_normal_file)
a1317 1
		      req_name = root,
d1365 1
a1365 1
		      TextIO.output(stream, 
d1372 1
a1372 1
                    
d1376 1
a1376 1
		val (c', _, declarations,debug_info') = 
d1401 1
a1401 1
       
d1405 1
a1405 1
	 debug_info, had_topdec) = 
d1460 1
a1460 1
		"require \"" ^ Io.pervasive_library_name ^ "\" ; " 
d1462 1
a1462 1
	      fun lex_fun _ = 
d1493 1
a1493 1
             
d1521 1
a1521 1
	  if module_id = Io.builtin_library_id then 
d1527 1
a1527 1
          else 
d1548 1
a1548 1
          val stream_name = 
d1563 1
a1563 1
	  
d1570 1
a1570 1
	val (project, stamp_info, require_table, requires, lambda_exp, 
d1586 1
a1586 1
          ("", (stamps,final_stamp_count - stamps))
d1610 2
a1611 2
	    Timer.xtime("LambdaOptimiser", 
			!print_timings, 
d1641 1
a1641 1
	val (the_mir_code,debugger_information) = 
d1662 1
a1662 1
	val the_optimised_code = 
d1720 1
a1720 1
	    top_env     
d1723 1
a1723 1
	  if pervasive then 
d1740 1
a1740 1
                   type_basis = type_basis, 
d1861 1
a1861 1
  
d1911 1
a1911 1
  
d2075 1
a2075 1
  
@


1.247
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d6 4
d875 1
d1749 1
a1749 1
	val new_mo_time = FileSys.modTime mo_name
@


1.246
log
@[Bug #30071]
Merge in Project Workspace changes.
Added a call to Project.pervasiveObjectName from do_input.
@
text
@d6 5
d1842 1
a1842 1
      Lists.reducel
d1844 1
a1844 1
	((init_project, Project.empty_map), modules);
d1891 1
a1891 1
      Lists.reducel
d1894 1
a1894 1
	 modules);
d1913 1
a1913 1
      Lists.reducel compile_one (project, out_of_date);
d2055 1
a2055 1
      Lists.reducel
d2058 1
a2058 1
	 Project.currentTargets initProject);
@


1.245
log
@[Bug #70051]
Modify to detect missing pervasive objects without giving compiler fault
@
text
@d6 4
d28 28
d871 1
a871 2
require "../utils/timer";
require "../basics/module";
d893 1
a893 1
require "io";
a902 1
  structure Module : MODULE
a968 1
  sharing type Project.Module = Module.Module
d974 2
a975 4
  sharing type Module.ModuleId = ModuleId.ModuleId =
	       Project.ModuleId = Io.ModuleId
  sharing type ModuleId.Location = Basis.BasisTypes.Datatypes.Ident.Location.T =
	       Module.Location
a979 1
  sharing type Project.Info.options = Module.InfoOptions
a1003 1
  type Module = Module.Module
d1153 1
a1153 1
	      diagnostic (2,
d1244 1
a1244 1
		   val module_id = ModuleId.add_path(mod_path, sub_module_id)
d1574 1
a1574 1
	  of SOME (_, _, time) => time
a1702 2
	val mo_info = Project.get_object_info (project, module_id)

d1704 6
a1709 15
	  case mo_info
	  of SOME {file, ...} => file
	  |  NONE =>
	    case src_info
	    of SOME (_, module, _) =>
	      (Module.objectName (error_info, Info.Location.FILE module_str) module
	      handle Io.NotSet _ =>
		Info.error'
		  error_info
		  (Info.FATAL,
		   Info.Location.UNKNOWN,
		   "Object path not set"))
	    |  NONE =>
	      Crash.impossible
	        ("Can't find mo name for `" ^ filename ^ "'")
d1769 1
a1769 1
	 of SOME (file_name, _, _) => file_name
d1810 2
a1811 13
      val modules =
	map
	  (fn s => Module.find_file (s, location))
	  filenames
	handle
	  Module.NoSuchFile s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "No such file `" ^ s ^ "'")
	| Module.BadHomeName s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1817 1
a1817 1
      fun compile_one ((project, status_map), (on_path, module)) =
d1834 1
a1834 4
	  if not on_path then
	    Module.with_source_path (module, "compiling") do_compile_one
	  else
	    do_compile_one (Module.module_id module)
d1846 2
a1847 14
      val modules =
	map
	  (fn s => Module.find_file (s, location))
	  filenames
	handle
	  Module.NoSuchFile s =>
	    Info.error'
	      error_info
	      (Info.FATAL, Info.Location.FILE "<batch compiler:recompile-file>",
	       "No such file `" ^ s ^ "'")
	| Module.BadHomeName s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1854 1
a1854 1
	    ((project, depend_map, compile_map), (on_path, module)) =
d1883 1
a1883 4
	  if not on_path then
	    Module.with_source_path (module, "compiling") do_recompile_one
	  else
	    do_recompile_one (Module.module_id module)
d1915 2
a1916 14
      val modules =
	map
	  (fn s => Module.find_file (s, location))
	  filenames
	handle
	  Module.NoSuchFile s =>
	    Info.error'
	      error_info
	      (Info.FATAL, Info.Location.FILE "<batch compiler:check-dependencies>",
	       "No such file `" ^ s ^ "'")
	| Module.BadHomeName s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1922 1
a1922 1
	     (on_path, module)) =
d1940 1
a1940 6
	  if not on_path then
	    Module.with_source_path
	      (module, "checking dependencies")
	      do_check_one
	  else
	    do_check_one (Module.module_id module)
d1948 146
@


1.244
log
@[Bug #30328]
Add environment parameter to decode_type_basis
for finding pervasive type names
@
text
@d6 5
d1780 13
d1812 2
d1862 2
@


1.243
log
@[Bug #30089]
Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
@
text
@d6 4
d1029 2
d1253 2
a1254 1
                        (t_env, mod_name, require_table, false)
@


1.242
log
@[Bug #30089]
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@d6 4
d862 1
a862 1
  structure Timer : TIMER
@


1.241
log
@[Bug #20090]
Changed consistency info in object files to store the modification times
of the corresponding source files.
@
text
@d6 5
d820 1
a821 1
require "../make/old_os";
d853 1
a853 1
 (structure OldOs : OLD_OS
d961 1
d1709 1
d1711 7
a1717 12
	  case OldOs.mtime mo_name
	  of OldOs.EXISTS new_mo_time =>
	    Project.set_object_info
	      (project, module_id,
	       SOME {file = mo_name,
		     file_time = new_mo_time,
		     time_stamp = src_time,
		     stamps = stamp_count,
		     consistency = Project.DEPEND_LIST requires})
	  |  _ =>
	    Crash.impossible
	      ("Can't find time for newly-written file `" ^ mo_name ^ "'")
@


1.240
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d6 4
d1202 1
a1202 1
		       SOME {file, file_time, ...} => (file, file_time)
d1210 2
a1211 2
		   val {parser_env, type_env=t_env, lambda_env, time_stamp,
			mod_name, consistency, stamps} =
@


1.240.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.240  1997/05/27  15:50:31  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.240.2.2
log
@[Bug #30071]
Converted build system to project workspace.
@
text
@a5 3
 * Revision 1.240.2.1  1997/09/11  20:56:53  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
a814 1
require "../system/__os.sml";
d1107 1
a1107 1
	      diagnostic (3,
d1198 1
a1198 1
		   val module_id = ModuleId.add_path(ModuleId.empty_path, sub_module_id)
d1527 1
a1527 1
	  of SOME (_, time) => time
d1656 2
d1659 15
a1673 3
	  Project.objectName
	    (error_info, Info.Location.FILE module_str)
	    (project, module_id)
d1737 1
a1737 1
	 of SOME (file_name, _) => file_name
d1767 1
a1767 1
	  (fn s => (true, OS.Path.file s))
a1797 1
	  (*
d1801 1
a1801 2
	  *)
	    do_compile_one (ModuleId.from_host (module, location))
d1815 1
a1815 1
	  (fn s => (true, OS.Path.file s))
d1821 1
a1821 1
	      (Info.FATAL, location,
a1859 1
	  (*
d1863 1
a1863 2
	  *)
	    do_recompile_one (ModuleId.from_host (module, location))
d1897 1
a1897 1
	  (fn s => (true, OS.Path.file s))
d1903 1
a1903 1
	      (Info.FATAL, location,
a1931 1
	  (*
d1937 1
a1937 2
	  *)
	    do_check_one (ModuleId.from_host (module, location))
a1944 159

      fun print_one m = print(ModuleId.string m ^ "\n")
    in
      case out_of_date
      of [] =>
	print"No files to recompile\n"
      |  _ =>
        app print_one out_of_date
    end

  fun list_objects error_info options filenames =
    let
      val location = Info.Location.FILE "<batch compiler:list-objects>"
      val modules =
	map
	  (fn s => (true, OS.Path.file s))
	  filenames
	handle
	  Module.NoSuchFile s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location,
	       "No such file `" ^ s ^ "'")
	| Module.BadHomeName s =>
	    Info.error'
	      error_info
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")

      val project = Project.initialize (error_info, location)

      fun check_one
	    ((project, out_of_date, depend_map),
	     (on_path, module)) =
	let
	  fun do_check_one mod_id =
	    let
	      (* Use Project.read_dependencies, not
		 Project.read_object_dependencies, because the latter
		 reads only the source information for the first file.
		 (Possibly that behaviour should be improved). *)

              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map)

	      val out_of_date_now =
	        Project.allObjects
	          (Info.make_default_options (), location)
	          (project, mod_id)
	    in
	      (project, out_of_date_now @@ out_of_date, depend_map)
	    end
	in
	  (*
	  if not on_path then
	    Module.with_source_path
	      (module, "checking dependencies")
	      do_check_one
	  else
	  *)
	    do_check_one (ModuleId.from_host (module, location))
	end

      val (_, out_of_date, _) =
	Lists.reducel
	  check_one
	  ((project, [], Project.empty_map),
	   modules)

      fun print_one m = print(ModuleId.string m ^ "\n")
    in
      case out_of_date
      of [] =>
	print"No files to recompile\n"
      |  _ =>
        app print_one out_of_date
    end

  fun build error_info options _ =
    let
      val location = Info.Location.FILE "<batch compiler:build>"

      val initProject = Project.fromFileInfo (error_info, location)

      fun recompile_one
	    ((project, depend_map, compile_map), module) =
	let
	  fun compile_one (proj, m) =
	    compile_file'
              error_info
	      (options, proj, m, false);

	  fun do_recompile_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map);

	      val (out_of_date, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          ([], compile_map)

	      val project =
	        Lists.reducel compile_one (project, out_of_date);

	      val status_map =
	        Lists.reducel Project.mark_compiled (compile_map, out_of_date)
	    in
	      (project, depend_map, compile_map)
	    end
	in
	  do_recompile_one (ModuleId.from_host (OS.Path.file module, location))
	end
    in
      Lists.reducel
	recompile_one
	((initProject, Project.empty_map, Project.visited_pervasives),
	 Project.currentTargets initProject);
      print"Up to date\n"
    end
  
  fun show_build error_info options _ =
    let
      val location = Info.Location.FILE "<batch compiler:show_build>"

      val initProject = Project.fromFileInfo (error_info, location)

      fun check_one
	    ((project, out_of_date, depend_map, compile_map),
	     module) =
	let
	  fun do_check_one mod_id =
	    let
              val (project, depend_map) =
                Project.read_dependencies
                  (Info.make_default_options (), location)
                  (project, mod_id, depend_map)

	      val (out_of_date_now, compile_map) =
	        Project.check_compiled'
	          (Info.make_default_options (), location)
	          (project, mod_id)
	          (out_of_date, compile_map)
	    in
	      (project, out_of_date_now, depend_map, compile_map)
	    end
	in
	  do_check_one (ModuleId.from_host (OS.Path.file module, location))
	end

      val (_, out_of_date, _, _) =
	Lists.reducel
	  check_one
	  ((initProject, [], Project.empty_map, Project.visited_pervasives),
	   Project.currentTargets initProject)
@


1.240.2.3
log
@[Bug #20090]
Changed consistency info in object files to store the modification times
of the corresponding source files.
@
text
@a5 4
 * Revision 1.240.2.2  1997/09/17  15:57:32  daveb
 * [Bug #30071]
 * Converted build system to project workspace.
 *
d1206 1
a1206 1
		       SOME {file, time_stamp, ...} => (file, time_stamp)
d1214 2
a1215 2
		   val {parser_env, type_env=t_env, lambda_env,
			mod_name, consistency, stamps, ...} =
@


1.240.2.4
log
@[Bug #30089]
Merged from trunk:
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@a5 6
 *
 * Revision 1.240.2.3  1997/10/29  11:53:47  daveb
 * [Bug #20090]
 * Changed consistency info in object files to store the modification times
 * of the corresponding source files.
 *
d822 1
a822 1
require "../basis/os";
d824 1
d856 1
a856 1
 (structure OS : OS
a963 1
  structure FileSys = OS.FileSys
a1696 1
	val new_mo_time = FileSys.modTime mo_name
d1698 12
a1709 7
	  Project.set_object_info
	  (project, module_id,
	   SOME {file = mo_name,
		 file_time = new_mo_time,
		 time_stamp = src_time,
		 stamps = stamp_count,
		 consistency = Project.DEPEND_LIST requires})
@


1.240.2.5
log
@[Bug #30326]
@
text
@a5 5
 * Revision 1.240.2.4  1997/10/29  14:00:00  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
d834 1
a834 1
require "../utils/mlworks_timer";
d857 1
a857 1
require "mlworks_io";
@


1.240.2.6
log
@[Bug #30071]
@
text
@a5 3
 * Revision 1.240.2.5  1997/11/20  17:12:21  daveb
 * [Bug #30326]
 *
d840 1
d872 1
d939 1
d945 4
a948 2
  sharing type ModuleId.ModuleId = Project.ModuleId = Io.ModuleId
  sharing type ModuleId.Location = Basis.BasisTypes.Datatypes.Ident.Location.T
d953 1
d978 1
d1766 13
a1778 2

      val modules = map OS.Path.file filenames
d1782 1
a1782 1
      fun compile_one ((project, status_map), module) =
d1799 6
a1804 1
	  do_compile_one (ModuleId.from_host (module, location))
d1816 14
a1829 2

      val modules = map OS.Path.file filenames
d1834 1
a1834 1
	    ((project, depend_map, compile_map), module) =
d1863 6
a1868 1
	  do_recompile_one (ModuleId.from_host (module, location))
d1900 14
a1913 2

      val modules = map OS.Path.file filenames
d1919 1
a1919 1
	     module) =
d1937 8
a1944 1
	  do_check_one (ModuleId.from_host (module, location))
d1965 14
a1978 2

      val modules = map OS.Path.file filenames
d1984 1
a1984 1
	     module) =
d2006 8
a2013 1
	  do_check_one (ModuleId.from_host (module, location))
@


1.240.2.7
log
@[Bug #30071]
Project.fromFileInfo now takes a project argument.
@
text
@a5 3
 * Revision 1.240.2.6  1997/11/26  16:34:12  daveb
 * [Bug #30071]
 *
d1960 1
a1960 4
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))
d2006 1
a2006 4
      val initProject =
	Project.fromFileInfo
	  (error_info, location)
	  (Project.initialize (error_info, location))
@


1.240.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.240  1997/05/27  15:50:31  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.239
log
@[Bug #30136]
Removed early-mips-r4000 option.
@
text
@d6 4
d808 2
d1291 1
a1291 1
		     (3, fn stream => MLWorks.IO.output(stream, "The abstract syntax\n"));
d1295 1
a1295 1
		      MLWorks.IO.output(stream, 
d1299 1
a1299 1
		     (3, fn stream => MLWorks.IO.output(stream, "\n"))
d1532 1
a1532 1
	     (3, fn stream => MLWorks.IO.output(stream, "The unoptimised lambda code\n"));
d1551 1
a1551 1
	     (3, fn stream => MLWorks.IO.output(stream, "The optimised lambda code\n"));
d1563 1
a1563 1
	     (3, fn stream => MLWorks.IO.output(stream, "The environment\n"));
d1568 1
a1568 1
	     (3, fn stream => MLWorks.IO.output(stream, "\n")))
d1587 1
a1587 1
	     (3, fn stream => MLWorks.IO.output(stream, "The unoptimised intermediate code\n"));
d1601 1
a1601 1
	     (3, fn stream => MLWorks.IO.output(stream, "The optimised intermediate code\n"));
d1627 1
a1627 1
	     (3, fn stream => MLWorks.IO.output(stream, "The final machine code\n"));
d1693 1
a1693 1
	  handle MLWorks.IO.Io _ =>
d1742 2
a1743 2
         MLWorks.IO.open_in file_name
         handle MLWorks.IO.Io s =>
d1747 1
a1747 1
	      "Io error in compile_file: " ^ s)
d1751 2
a1752 2
		   fn _ => MLWorks.IO.input(instream, 4096), file_name, pervasive)
         handle exn => (MLWorks.IO.close_in instream; raise exn)
d1754 1
a1754 1
       MLWorks.IO.close_in instream;
d1866 1
a1866 1
      MLWorks.IO.output (MLWorks.IO.std_out, "Up to date\n")
d1885 1
a1885 1
      MLWorks.IO.output (MLWorks.IO.std_out, "Up to date\n")
d1942 1
a1942 1
      fun print_one m = MLWorks.IO.output (MLWorks.IO.std_out, ModuleId.string m ^ "\n")
d1946 1
a1946 1
	MLWorks.IO.output (MLWorks.IO.std_out, "No files to recompile\n")
@


1.238
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d6 4
a1045 1
                                         early_mips_r4000,
a1073 1
                          early_mips_r4000 = early_mips_r4000,
@


1.237
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d6 4
d299 1
a299 1
Put filename rather than module name into tokenstream (and thence
d860 1
a860 1
  structure Io : IO
@


1.236
log
@[Bug #1984]
Tidy up the unknown locations when giving No such file errors.
@
text
@d6 4
a937 2

  open MLWorks.Option
@


1.235
log
@Renamed R4000 option
@
text
@d6 3
d1746 1
d1749 1
a1749 1
	  (fn s => Module.find_file (s, Info.Location.UNKNOWN))
d1755 1
a1755 1
	      (Info.FATAL, Info.Location.UNKNOWN, "No such file `" ^ s ^ "'")
d1759 1
a1759 1
	      (Info.FATAL, Info.Location.UNKNOWN, "Bad home name `" ^ s ^ "'")
d1761 1
a1761 1
      val init_project = Project.initialize (error_info, Info.Location.UNKNOWN)
d1769 1
a1769 1
                  (Info.make_default_options (), Info.Location.UNKNOWN)
d1794 1
d1797 1
a1797 1
	  (fn s => Module.find_file (s, Info.Location.UNKNOWN))
d1803 2
a1804 1
	      (Info.FATAL, Info.Location.UNKNOWN, "No such file `" ^ s ^ "'")
d1808 1
a1808 1
	      (Info.FATAL, Info.Location.UNKNOWN, "Bad home name `" ^ s ^ "'")
d1810 1
a1810 1
      val init_project = Project.initialize (error_info, Info.Location.UNKNOWN)
d1824 1
a1824 1
                  (Info.make_default_options (), Info.Location.UNKNOWN)
d1829 1
a1829 1
	          (Info.make_default_options (), Info.Location.UNKNOWN)
d1855 9
a1863 3
    fun recompile_pervasive error_info options =
      let
        val project = Project.initialize (error_info, Info.Location.UNKNOWN)
d1865 8
a1872 13
	val out_of_date =
	  Project.check_perv_compiled
	    (error_info, Info.Location.UNKNOWN)
	    project

	fun compile_one (proj, m) =
	  compile_file'
            error_info
	    (options, proj, m, true);
      in
	Lists.reducel compile_one (project, out_of_date);
        MLWorks.IO.output (MLWorks.IO.std_out, "Up to date\n")
      end
d1876 1
d1879 1
a1879 1
	  (fn s => Module.find_file (s, Info.Location.UNKNOWN))
d1885 2
a1886 1
	      (Info.FATAL, Info.Location.UNKNOWN, "No such file `" ^ s ^ "'")
d1890 1
a1890 1
	      (Info.FATAL, Info.Location.UNKNOWN, "Bad home name `" ^ s ^ "'")
d1892 1
a1892 1
      val project = Project.initialize (error_info, Info.Location.UNKNOWN)
d1902 1
a1902 1
                  (Info.make_default_options (), Info.Location.UNKNOWN)
d1907 1
a1907 1
	          (Info.make_default_options (), Info.Location.UNKNOWN)
@


1.235.1.1
log
@branched from 1.235
@
text
@a5 3
 * Revision 1.235  1997/03/25  11:44:35  matthew
 * Renamed R4000 option
 *
@


1.235.1.2
log
@[Bug #1984]
Tidy up the unknown locations when giving No such file errors.
@
text
@a5 11
 * Revision 1.235.1.1  1997/05/12  10:35:52  hope
 * branched from 1.235
 *
 * Revision 1.237  1997/05/02  16:41:29  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.236  1997/04/10  16:49:24  jont
 * [Bug #1984]
 * Tidy up the unknown locations when giving No such file errors.
 *
d935 2
a1745 1
      val location = Info.Location.FILE "<batch compiler:compile-file>"
d1748 1
a1748 1
	  (fn s => Module.find_file (s, location))
d1754 1
a1754 1
	      (Info.FATAL, location, "No such file `" ^ s ^ "'")
d1758 1
a1758 1
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1760 1
a1760 1
      val init_project = Project.initialize (error_info, location)
d1768 1
a1768 1
                  (Info.make_default_options (), location)
a1792 1
      val location = Info.Location.FILE "<batch compiler:recompile-file>"
d1795 1
a1795 1
	  (fn s => Module.find_file (s, location))
d1801 1
a1801 2
	      (Info.FATAL, Info.Location.FILE "<batch compiler:recompile-file>",
	       "No such file `" ^ s ^ "'")
d1805 1
a1805 1
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1807 1
a1807 1
      val init_project = Project.initialize (error_info, location)
d1821 1
a1821 1
                  (Info.make_default_options (), location)
d1826 1
a1826 1
	          (Info.make_default_options (), location)
d1852 3
a1854 4
  fun recompile_pervasive error_info options =
    let
      val location = Info.Location.FILE "<batch compiler:compile-pervasive>"
      val project = Project.initialize (error_info, location)
d1856 13
a1868 13
      val out_of_date =
	Project.check_perv_compiled
	(error_info, location)
	project

      fun compile_one (proj, m) =
	compile_file'
	error_info
	(options, proj, m, true);
    in
      Lists.reducel compile_one (project, out_of_date);
      MLWorks.IO.output (MLWorks.IO.std_out, "Up to date\n")
    end
a1871 1
      val location = Info.Location.FILE "<batch compiler:check-dependencies>"
d1874 1
a1874 1
	  (fn s => Module.find_file (s, location))
d1880 1
a1880 2
	      (Info.FATAL, Info.Location.FILE "<batch compiler:check-dependencies>",
	       "No such file `" ^ s ^ "'")
d1884 1
a1884 1
	      (Info.FATAL, location, "Bad home name `" ^ s ^ "'")
d1886 1
a1886 1
      val project = Project.initialize (error_info, location)
d1896 1
a1896 1
                  (Info.make_default_options (), location)
d1901 1
a1901 1
	          (Info.make_default_options (), location)
@


1.235.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 4
 * Revision 1.235.1.2  1997/05/12  15:15:48  daveb
 * [Bug #1984]
 * Tidy up the unknown locations when giving No such file errors.
 *
@


1.235.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 4
 * Revision 1.235.1.2  1997/05/12  15:15:48  daveb
 * [Bug #1984]
 * Tidy up the unknown locations when giving No such file errors.
 *
@


1.235.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 4
 * Revision 1.235.1.2  1997/05/12  15:15:48  daveb
 * [Bug #1984]
 * Tidy up the unknown locations when giving No such file errors.
 *
@


1.235.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.235.1.2.1.1  1997/07/28  18:21:34  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.234
log
@[Bug #1965]
Handling Io.NotSet for objectName.
@
text
@d6 4
d1033 1
a1034 1
                                         mips2,
d1062 1
a1063 1
                          mips2 = mips2,
@


1.233
log
@Review edit <URI:spring://ML_Notebook/Review/basics/*module.sml>
-- Changed name and type of Module.mo_name.
@
text
@d6 4
d1639 7
a1645 3
	      Module.objectName
		(error_info, Info.Location.FILE module_str)
		module
@


1.232
log
@Adding architecture specific options
@
text
@d3 6
a8 1
$Log: _toplevel.sml,v $
a778 1
Copyright (c) 1991 Harlequin Ltd.
d1634 4
a1637 1
	    of SOME (_, module, _) => Module.mo_name error_info module
@


1.231
log
@Changes to lambda code
@
text
@d4 3
d1020 4
a1023 1
					 print_messages, ...}}),
d1049 4
a1052 1
			  print_messages = print_messages}})
@


1.230
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d1016 1
d1042 1
d1204 1
a1204 2
		         [LambdaTypes.SCON
			    (Ident.STRING mod_name, NONE)],
d1546 1
a1546 1
	  if (#show_mir listing_options) then
@


1.230.4.1
log
@branched from 1.230
@
text
@a3 4
 * Revision 1.230  1996/11/06  11:29:12  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.230.3.1
log
@branched from 1.230
@
text
@a3 4
 * Revision 1.230  1996/11/06  11:29:12  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.230.3.1.1.1
log
@branched from 1.230.3.1
@
text
@a3 3
 * Revision 1.230.3.1  1996/12/17  17:49:19  hope
 * branched from 1.230
 *
@


1.230.2.1
log
@branched from 1.230
@
text
@a3 4
 * Revision 1.230  1996/11/06  11:29:12  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.230.1.1
log
@branched from 1.230
@
text
@a3 4
 * Revision 1.230  1996/11/06  11:29:12  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.230.1.1.1.1
log
@branched from 1.230.1.1
@
text
@a3 3
 * Revision 1.230.1.1  1996/11/14  12:51:31  hope
 * branched from 1.230
 *
@


1.229
log
@moving String from toplevel
@
text
@d4 3
d770 1
a770 1
require "../basis/__integer";
@


1.228
log
@Remove LambdaSub
@
text
@d4 3
d975 1
a975 1
  val empty_string_map = NewMap.empty (String.<, op= : string * string -> bool)
d1069 1
a1069 1
	      MLWorks.Option.SOME _ =>
d1132 1
a1132 1
		(Info.FATAL, location, String.implode ["Too late for require statement"])
d1180 1
a1180 1
		       MLWorks.Option.SOME _ => require_table
d1196 2
a1197 2
			    (Ident.STRING mod_name, MLWorks.Option.NONE)],
			 MLWorks.Option.NONE))
d1213 1
a1213 1
		    MLWorks.Option.NONE => MLWorks.Option.SOME stamp_count
d1229 1
a1229 1
		  MLWorks.Option.NONE => MLWorks.Option.SOME stamp_count
d1324 1
a1324 1
	    (project, MLWorks.Option.SOME stamp_count,
d1358 1
a1358 1
		  (project, true, ModuleId.empty_path, MLWorks.Option.NONE,
d1374 1
a1374 1
	     (project, mod_path, MLWorks.Option.NONE, empty_string_map, [],
d1464 1
a1464 1
	    MLWorks.Option.SOME stamps => stamps
d1889 1
a1889 2
        Lists.iterate print_one out_of_date;
      ()
@


1.228.2.1
log
@branched from 1.228
@
text
@a3 3
 * Revision 1.228  1996/10/04  13:05:16  matthew
 * Remove LambdaSub
 *
@


1.228.1.1
log
@branched from 1.228
@
text
@a3 3
 * Revision 1.228  1996/10/04  13:05:16  matthew
 * Remove LambdaSub
 *
@


1.227
log
@[Bug #1584]
Removed mention of object path from error message.
@
text
@d4 4
a781 1
require "../lambda/lambdasub";
a813 1
  structure LambdaSub : LAMBDASUB
d852 1
a852 3
	  Mir_Cg.LambdaTypes =
    	  LambdaSub.LT (* =
          LambdaIO.LambdaTypes *)
d876 1
a876 1
  sharing type LambdaSub.LT.Primitive = Pervasives.pervasive
d893 1
a893 1
  structure LambdaTypes = LambdaSub.LT
@


1.227.1.1
log
@branched from 1.227
@
text
@a3 4
 * Revision 1.227  1996/09/04  11:26:45  daveb
 * [Bug #1584]
 * Removed mention of object path from error message.
 *
@


1.226
log
@[Bug #1521]
propagating changes made to typechecker/_types.sml
(pass options rather than print_options)
@
text
@d4 5
d1641 1
a1641 2
	       "Can't create object file `" ^ mo_name ^ "'\n"
	       ^ "-- check the setting of your object path.\n");
@


1.225
log
@Corrected mistake in check_dependencies.
@
text
@d4 3
d1004 1
d1241 2
a1242 1
		      MLWorks.IO.output(stream, TopdecPrint.topdec_to_string print_options topdec));
d1481 1
a1481 1
	      LambdaPrint.output_lambda print_options (stream, lambda_exp)))
d1500 1
a1500 1
	      LambdaPrint.output_lambda print_options (stream, opt_lambda_exp)))
@


1.224
log
@Add option to turn on/off compilation messages from intermake
@
text
@d4 3
d1837 3
a1839 1
      fun check_one ((project, out_of_date, status_map), (on_path, module)) =
d1843 1
a1843 1
              val (project, status_map) =
d1846 1
a1846 1
                  (project, mod_id, Project.empty_map);
d1848 1
a1848 1
	      val (out_of_date_now, status_map) =
d1852 1
a1852 1
	          (out_of_date, status_map)
d1854 1
a1854 1
	      (project, out_of_date_now, status_map)
d1865 1
a1865 1
      val (_, out_of_date, _) =
d1868 2
a1869 1
	  ((project, [], Project.visited_pervasives), modules)
@


1.223
log
@The Io exception is no longer at top level.
@
text
@d4 3
d994 2
a995 1
                                         opt_tail_calls,opt_self_calls,...}}),
d1018 2
a1019 1
                          opt_self_calls = opt_self_calls}})
@


1.222
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d1619 1
a1619 1
	  handle Io _ =>
d1670 1
a1670 1
         handle Io s =>
@


1.221
log
@Removing MLWorks.Integer
@
text
@d4 3
d1106 1
a1106 1
		(Info.FATAL, location, implode ["Too late for require statement"])
d1219 1
a1219 1
		     (3, fn stream => output(stream, "The abstract syntax\n"));
d1223 1
a1223 1
		      output(stream, TopdecPrint.topdec_to_string print_options topdec));
d1226 1
a1226 1
		     (3, fn stream => output(stream, "\n"))
d1459 1
a1459 1
	     (3, fn stream => output(stream, "The unoptimised lambda code\n"));
d1478 1
a1478 1
	     (3, fn stream => output(stream, "The optimised lambda code\n"));
d1490 1
a1490 1
	     (3, fn stream => output(stream, "The environment\n"));
d1495 1
a1495 1
	     (3, fn stream => output(stream, "\n")))
d1514 1
a1514 1
	     (3, fn stream => output(stream, "The unoptimised intermediate code\n"));
d1528 1
a1528 1
	     (3, fn stream => output(stream, "The optimised intermediate code\n"));
d1554 1
a1554 1
	     (3, fn stream => output(stream, "The final machine code\n"));
d1663 1
a1663 1
         open_in file_name
d1672 2
a1673 2
		   fn _ => input(instream, 4096), file_name, pervasive)
         handle exn => (close_in instream; raise exn)
d1675 1
a1675 1
       close_in instream;
d1784 1
a1784 1
      output (std_out, "Up to date\n")
d1802 1
a1802 1
        output (std_out, "Up to date\n")
d1854 1
a1854 1
      fun print_one m = output (std_out, ModuleId.string m ^ "\n")
d1858 1
a1858 1
	output (std_out, "No files to recompile\n")
@


1.220
log
@Changed Project.load_dependencies to Project.read_dependencies.
@
text
@d4 3
d737 2
d1421 1
a1421 1
		      MLWorks.Integer.makestring(Stamp.read_counter()) ^ "\n"])
@


1.219
log
@Change any use of Os/OS to OldOs/OLD_OS to emphasise that it is using
the deprecated OS interface.
@
text
@d4 4
d1694 1
a1694 1
                Project.load_object_dependencies
d1747 1
a1747 1
                Project.load_dependencies
d1820 1
a1820 1
                Project.load_dependencies
@


1.218
log
@Added handlers for Module.BadHomeName.
Replaced explicit setting of source path with new version of
Module.with_source_path.
@
text
@d4 5
d730 1
a730 1
require "../make/os";
d763 1
a763 1
 (structure Os : OS
d1609 2
a1610 2
	  case Os.mtime mo_name
	  of Os.EXISTS new_mo_time =>
@


1.217
log
@Module.mo_name now takes an Info.options argument.
@
text
@d4 3
d1673 4
a1676 2

      val old_source_path = Io.get_source_path ()
d1682 14
a1695 31
	  val _ =
	    if not on_path then
	      (output
		 (std_out,
	          "Extending source path with directory "
	          ^ Module.module_dir module
	          ^ " for compilation of module "
	          ^ ModuleId.string (Module.module_id module)
		  ^ "\n");
	       Io.set_source_path
	        (Module.module_dir module :: old_source_path))
	    else
	      ();

	  val module_id = Module.module_id module

          val (project, status_map) =
            Project.load_object_dependencies
              (Info.make_default_options (), Info.Location.UNKNOWN)
              (project, module_id, status_map);

	  val project =
	    compile_file'
              error_info
	      (options, project, module_id, false);

	  val _ =
	    if not on_path then
	      Io.set_source_path old_source_path
	    else
	      ()
d1697 4
a1700 1
	  (project, status_map)
a1701 2
        handle
	  x => (Io.set_source_path old_source_path; raise x)
d1720 4
a1723 2

      val old_source_path = Io.get_source_path ()
a1729 16
	  val _ =
	    if not on_path then
	      (output
		 (std_out,
	          "Extending source path with directory "
	          ^ Module.module_dir module
	          ^ " for compilation of module "
	          ^ ModuleId.string (Module.module_id module)
		  ^ "\n");
	       Io.set_source_path
	        (Module.module_dir module :: old_source_path))
	    else
	      ();

	  val module_id = Module.module_id module

d1735 21
a1755 22
          val (project, depend_map) =
            Project.load_dependencies
              (Info.make_default_options (), Info.Location.UNKNOWN)
              (project, module_id, depend_map);

	  val (out_of_date, compile_map) =
	    Project.check_compiled'
	      (Info.make_default_options (), Info.Location.UNKNOWN)
	      (project, module_id)
	      ([], compile_map)

	  val project =
	    Lists.reducel compile_one (project, out_of_date);

	  val status_map =
	    Lists.reducel Project.mark_compiled (compile_map, out_of_date)

	  val _ =
	    if not on_path then
	      Io.set_source_path old_source_path
	    else
	      ()
d1757 4
a1760 1
	  (project, depend_map, compile_map)
a1761 2
        handle
	  x => (Io.set_source_path old_source_path; raise x)
d1799 4
a1802 2

      val old_source_path = Io.get_source_path ()
d1808 15
a1822 32
	  val _ =
	    if not on_path then
	      (output
		 (std_out,
	          "Extending source path with directory "
	          ^ Module.module_dir module
	          ^ " while checking dependencies of module "
	          ^ ModuleId.string (Module.module_id module)
		  ^ "\n");
	       Io.set_source_path
	        (Module.module_dir module :: old_source_path))
	    else
	      ();

	  val module_id = Module.module_id module

          val (project, status_map) =
            Project.load_dependencies
              (Info.make_default_options (), Info.Location.UNKNOWN)
              (project, module_id, Project.empty_map);

	  val (out_of_date_now, status_map) =
	    Project.check_compiled'
	      (Info.make_default_options (), Info.Location.UNKNOWN)
	      (project, module_id)
	      (out_of_date, status_map)

	  val _ =
	    if not on_path then
	      Io.set_source_path old_source_path
	    else
	      ()
d1824 6
a1829 1
	  (project, out_of_date_now, status_map)
a1830 2
        handle
	  x => (Io.set_source_path old_source_path; raise x)
@


1.216
log
@Fixed use of Info.default_options.
@
text
@d4 3
d845 1
d1566 1
a1566 1
	    of SOME (_, module, _) => Module.mo_name module
@


1.215
log
@Types of Project object info and Encapsulate.input_all have changed.
@
text
@d4 3
d1691 1
a1691 1
              (Info.default_options, Info.Location.UNKNOWN)
d1758 1
a1758 1
              (Info.default_options, Info.Location.UNKNOWN)
d1763 1
a1763 1
	      (Info.default_options, Info.Location.UNKNOWN)
d1845 1
a1845 1
              (Info.default_options, Info.Location.UNKNOWN)
d1850 1
a1850 1
	      (Info.default_options, Info.Location.UNKNOWN)
@


1.214
log
@Replacing Map with NewMap
@
text
@d4 3
d1000 1
a1000 1
	     {mod_name = name, ...} :: cons) =
a1020 3
		  val obj_info =
		    Project.get_object_info (project, module_id)

d1022 4
a1025 2
		    case obj_info
		    of SOME (_, _, stamps, Project.CONSISTENCY cons) => 
d1036 1
a1036 1
		     case consistency of [] => [] | _ :: tl => tl)
d1043 2
a1044 3
		    case consistency of
		      {mod_name, ...} :: _ => mod_name
		    | _ =>Crash.impossible "Strange, no consistency info"
d1098 1
a1098 1
		       SOME (mo_str, mo_stamp, _, _) => (mo_str, mo_stamp)
d1106 2
a1107 1
		   val {parser_env, type_env=t_env, lambda_env, consistency, stamps} =
a1111 4
		   val ({mod_name, req_name, time}, cons) = case consistency of
		     [] => Crash.impossible "Strange, no consistency info"
		   | hd :: tl => (hd, tl)

d1116 1
a1116 1
		       (true, project, require_table, pervasive, cons)
d1123 2
a1124 4
		   val root_module_name_string = case consistency of
		     {mod_name, ...} :: _ => mod_name
		   | _ => Crash.impossible "Strange, no consistency info"
		   val req_info = (root_module_name_string, (stamp_count,stamps))
d1126 1
a1126 2
		     case NewMap.tryApply'
			    (require_table, root_module_name_string) of
d1129 2
a1130 1
			 NewMap.define(require_table, root_module_name_string, req_info)
d1133 1
a1133 1
                      (t_env, root_module_name_string, require_table, false)
d1140 5
a1144 5
		      LambdaTypes.APP(LambdaTypes.BUILTIN
				      Pervasives.LOAD_STRING,
				      [LambdaTypes.SCON(Ident.STRING root_module_name_string,
							MLWorks.Option.NONE)],
				      MLWorks.Option.NONE))
d1147 1
a1147 1
		    [{mod_name = root_module_name_string,
a1427 7
	val requires =
	  let
	    val string = ModuleId.string module_id
	  in
	    {mod_name = string, req_name = string, time = src_time} :: requires
	  end

d1556 1
a1556 1
	  of SOME (file_name, _, _, _) => file_name
d1580 2
a1581 1
                   require_list = require_list, lambda_env = top_env,
d1583 2
d1598 5
a1602 2
	       SOME (mo_name, new_mo_time, stamp_count,
		     Project.CONSISTENCY requires))
d1759 1
a1759 1
	    Project.check_objects'
d1783 2
a1784 1
	((init_project, Project.empty_map, Project.empty_map), modules);
d1793 1
a1793 1
	  Project.check_perv_objects
d1846 1
a1846 1
	    Project.check_objects'
d1863 3
a1865 1
	Lists.reducel check_one ((project, [], Project.empty_map), modules)
@


1.213
log
@Added a handler for the case when the encapsulator is given a bad file name.
@
text
@d4 3
a846 1
  structure Map = Datatypes.Mapping
@


1.212
log
@Changed wording of warning message.
@
text
@d4 3
d1098 1
a1098 1
			   ("Required .mo file `"
d1576 22
a1597 10
	  Timer.xtime("Outputting", !print_timings,
		      fn () =>
		      (Encapsulate.output_file (debug_variables orelse generate_moduler)
		       {filename = mo_name,
                        code = the_machine_code, parser_env = parser_env,
                        type_basis = type_basis, 
                        debug_info = if generate_debug_info then debugger_information else empty_debug_info,
                        require_list = require_list, lambda_env = top_env,
                        stamps = stamp_count,
                        consistency = requires}))
@


1.211
log
@Modified type of compile_file' to support Project Tool.
@
text
@d4 3
d1817 1
a1817 1
	          ^ " for compilation of module "
@


1.210
log
@Adding opt_handlers compiler option
@
text
@d4 3
d729 1
d766 1
d777 2
a778 1
  sharing Parser.Lexer.Info = Lambda.Info = Mir_Cg.Info = Mach_Cg.Info = Mod_Rules.Info
d813 3
a815 1
  sharing type Parser.Absyn.Type = Basis.BasisTypes.Datatypes.Type = Mir_Cg.LambdaTypes.Type
d819 2
a820 1
  sharing type Parser.Absyn.ModuleId = Module.ModuleId = ModuleId.ModuleId
d823 2
a824 1
  sharing type Lambda.DebugInformation = Mir_Cg.MirTypes.Debugger_Types.information
d849 2
d854 3
a856 1
  type ModuleCache = Module.Cache
a925 3
  fun augment_parser_cb_only (CB (p, t, c), CB (p', t', c')) =
    Parser.augment_pB(p, p')

a930 38
  (* A cache is basically remembered results of Encapsulate.input_info *)
  type cache = (string, {stamps : int,
                         consistency : {mod_name : string, 
                                        req_name : string, 
                                        time : MLWorks.Time.time} list}) NewMap.T

  val empty_cache = empty_string_map

  fun find_object (error_info, pervasive, mod_path, perv_mo_cache,mo_cache,
	 	   sub_module_id, location) =
    let
      val _ = diagnostic
		  (2, fn _ => ["find_object ", ModuleId.path_string mod_path,
			       " ", ModuleId.string sub_module_id])
    in
      if pervasive then
	case Module.find_pervasive_mo(sub_module_id, perv_mo_cache) of
	   (MLWorks.Option.SOME f, perv_mo_cache) => (f, perv_mo_cache,mo_cache)
	 | _ =>
	     Info.error'
	     error_info
	     (Info.FATAL, location, "Pervasive directory not set or pervasive mo '" ^
	      ModuleId.string sub_module_id ^ "' not found")
      else
	let
	  val module_id = ModuleId.add_path (mod_path, sub_module_id)
	in
	  case Module.find_mo (module_id, mo_cache) of
	    (MLWorks.Option.SOME f, mo_cache) => (f, perv_mo_cache,mo_cache)
	  | (MLWorks.Option.NONE, mo_cache) =>
	      Info.error'
	      error_info
	      (Info.FATAL, location,
	       implode ["Required .mo file `",
			ModuleId.string sub_module_id, "' not found"])
	end
    end

d945 2
a946 3
                                         intercept,no_execute,
					 opt_handlers,
                                         opt_leaf_fns,
d948 1
a948 1
         cache, sml_cache, perv_mo_cache, mo_cache, mod_path, ts, initial, pervasive) = 
d950 5
d965 1
a965 1
                          intercept = false,no_execute = no_execute,
d978 4
d983 7
a989 7
	options
	(first, cache, perv_mo_cache, mo_cache, require_table, _, nil) =
	(cache, perv_mo_cache, mo_cache, require_table)
	| do_subrequires
	  options
	  (first, cache, perv_mo_cache, mo_cache, require_table, pervasive,
	   {mod_name = name, ...} :: cons) =
d991 12
a1002 18
	    val _ = diagnostic (2, fn _ => ["do_subrequires of ", filename,
					    ", ", name])
	    val pervasive_name = first
	    val pervasive_file = pervasive orelse pervasive_name
	    val module_name = ModuleId.from_string (name, Info.Location.FILE filename)
	    val ((mo_str, _, _), perv_mo_cache,mo_cache) =
	      find_object
	      (error_info, pervasive_file, ModuleId.empty_path,
	       perv_mo_cache,mo_cache,
	       (*ModuleId.from_string (name, Info.Location.FILE filename)*) module_name,
	       Info.Location.FILE filename)
(*
	    val module_name = Module.module_id mo
*)
	    val module_name_string = ModuleId.string module_name
(*
	    val _ = output(std_out, "Toplevel: module_name_string = " ^ module_name_string ^ "\n")
*)
d1007 1
a1007 2
		(false, cache, perv_mo_cache,mo_cache, require_table,
		 pervasive, cons)
d1010 2
a1011 15
		  val (cache, {consistency, stamps}) =
		    case NewMap.tryApply' (cache, module_name_string) of
		      MLWorks.Option.NONE =>
			let
			  val info =
			    Encapsulate.input_info (*Module.mo_name mo*)mo_str
			    handle Encapsulate.BadInput s =>
			      (output (std_out, "In do_subrequires\n");
			       Info.error'
			       Info.default_options
			       (Info.FATAL, Info.Location.FILE filename, s))
			in
			  (NewMap.define (cache, module_name_string, info), info)
			end
		    | MLWorks.Option.SOME info => (cache, info)
d1013 11
a1023 1
		  val (cache, perv_mo_cache, mo_cache, require_table) =
d1025 1
a1025 2
		    (true, cache, perv_mo_cache, mo_cache,
		     require_table, pervasive orelse pervasive_name,
d1031 6
a1036 3
		  val module_name_string = case consistency of
		    {mod_name, ...} :: _ => mod_name
		  | _ =>Crash.impossible "Strange, no consistency info"
d1040 4
a1043 4
		  options
		  (false, cache, perv_mo_cache,mo_cache,
		   NewMap.define(require_table, module_name_string, req_info),
		   pervasive, cons)
d1052 1
a1052 1
	    (arg as (cache, perv_mo_cache, mo_cache,pervasive, mod_path, stamp_info, require_table,
d1054 1
a1054 2
		     counters as stamps,
		     debug_info, had_topdec)) =
d1066 1
a1066 1
	    Absyn.REQUIREtopdec (sub_module_id, location) =>
a1076 1
		   val root = ModuleId.string sub_module_id
d1079 1
a1079 9
		   val module_id = ModuleId.add_path(mod_path, sub_module_id)
		   val module_id =
		     if pervasive then module_id
		     else
		       case Module.find_sml(module_id, sml_cache) of
			 (MLWorks.Option.SOME(_, module, _), _) =>
			   Module.module_id module
		       | _ => module_id
		   val ((mo_str, _, mo_stamp), perv_mo_cache,mo_cache) =
d1081 1
a1081 4
		       find_object
		       (error_info, pervasive, mod_path,
			perv_mo_cache,mo_cache,
			sub_module_id, location)
d1083 11
a1093 9
		       case Module.find_mo (module_id, mo_cache) of
			 (MLWorks.Option.SOME f, mo_cache) =>
			   (f, perv_mo_cache,mo_cache)
		       | (MLWorks.Option.NONE, mo_cache) =>
			   Info.error'
			   error_info
			   (Info.FATAL, location,
			    implode ["Required .mo file `",
				     ModuleId.string sub_module_id, "' not found"])
d1106 1
a1106 1
		   val (cache, perv_mo_cache, mo_cache, require_table) =
d1108 3
a1110 4
		     error_info
		     do_subrequires
		     (true, cache, perv_mo_cache, mo_cache, require_table, pervasive,
		      cons)
d1122 2
a1123 1
		     case NewMap.tryApply'(require_table, root_module_name_string) of
d1142 1
a1142 1
		   (cache, perv_mo_cache, mo_cache,stamp_info, require_table,
d1145 2
a1146 1
		      time = mo_stamp}], (* This is where the entry for the require list is made *)
d1159 2
a1160 2
		  (cache, perv_mo_cache, mo_cache,stamp_info, require_table, [], [], empty_cb, empty_cb, counters,
		   debug_info, true)
d1164 1
a1164 1
		   (cache, perv_mo_cache, mo_cache,pervasive, mod_path, stamp_info, require_table,
d1216 1
a1216 1
		(cache, perv_mo_cache, mo_cache, stamp_info, require_table, [],
d1229 1
a1229 1
	(cache, perv_mo_cache, mo_cache,mod_path, stamp_info, require_table, reqs, code,
d1233 1
a1233 1
          val (cache, perv_mo_cache, mo_cache,stamp_info, require_table, requires,
d1237 1
a1237 1
	      (cache, perv_mo_cache, mo_cache,pervasive, mod_path, stamp_info, require_table,
d1246 1
a1246 1
            (cache, perv_mo_cache, mo_cache,stamp_info, require_table, reqs', code',
d1250 1
a1250 1
	      (cache, perv_mo_cache, mo_cache, mod_path, stamp_info, require_table, reqs', code',
d1260 2
a1261 2
      val (cache, perv_mo_cache, mo_cache,stamp_info, require_table, reqs_list, decls_list, CB(pbasis, basis, top_env),
	   counters,debug_info) =
d1266 1
a1266 2
	    (cache, perv_mo_cache, mo_cache,
	     MLWorks.Option.SOME stamp_count,
d1297 1
a1297 1
	      val (cache, perv_mo_cache, mo_cache,stamp_info, require_table, reqs_list,
d1300 1
a1300 1
		(cache, perv_mo_cache, mo_cache, true, ModuleId.empty_path, MLWorks.Option.NONE,
d1309 1
a1309 1
		(cache, perv_mo_cache, mo_cache,mod_path, stamp_info, require_table, reqs_list,
d1316 3
a1318 2
	     (cache, perv_mo_cache, mo_cache,mod_path, MLWorks.Option.NONE, empty_string_map, [], [], initial,
	      empty_cb, parse, eof, initial_counters, empty_debug_info, false)
d1324 1
a1324 1
      (cache, perv_mo_cache, mo_cache,stamp_info, require_table, reqs_list, lambda_exp',
d1337 1
a1337 1
                cache, sml_cache, perv_mo_cache, mo_cache, input_fn, source, pervasive) =
d1339 22
a1360 21
      val (initial_cb, builtin, module_str, filename) =
            let
              val filename = Module.sml_name source
	      val root = ModuleId.string (Module.module_id source)
            in
              if pervasive then
		if root = Io.builtin_library_name then 
                  (Info.error
                   error_info
                   (Info.WARNING, Info.Location.FILE root,
		    "Compiling as the builtin library");
                   (initial_cb_for_builtin_library, true, root, filename))
                else 
                  (Info.error
                   error_info
                   (Info.WARNING, Info.Location.FILE root,
		    "Compiling as pervasive");
                   (initial_cgb_for_normal_file, false, root, filename))
              else
                (initial_cgb_for_normal_file, false, root, filename)
            end
d1368 1
a1368 1
      val mod_path = ModuleId.path (Module.module_id source)
d1390 4
a1393 1
	val _ = diagnostic_output 3 (fn _ => ["Stamp reset to " ^ MLWorks.Integer.makestring(Stamp.read_counter()) ^ "\n"])
d1396 1
a1396 1
	val (cache, perv_mo_cache, mo_cache, stamp_info, require_table, requires, lambda_exp, 
d1399 1
a1399 1
	  compile_program (error_info, options, cache, sml_cache, perv_mo_cache, mo_cache,
a1402 2
        (* There must be a better way of doing this!! *)
	(* And now there is! *)
d1412 11
a1422 10
          ("", (stamps,final_stamp_count - stamps)) :: NewMap.range require_table
	val sec_time =
	  let
	    val sml_name = Module.sml_name source
	  in
	    (case Os.mtime sml_name of
	       Os.EXISTS i => i
	     | _ => Crash.impossible
		 ("File `" ^ sml_name ^ "' no longer exists"))
	  end
d1426 1
a1426 1
	    val string = ModuleId.string (Module.module_id source)
d1428 1
a1428 1
	    {mod_name = string, req_name = string, time = sec_time} :: requires
d1555 14
a1568 1
        (* We explicitly set the debug info to nothing even if we aren't supposed to be generating it *)
d1573 1
a1573 1
		       {filename = Module.mo_name source,
d1580 11
d1593 1
a1593 1
        (cache, perv_mo_cache,mo_cache)
d1603 1
a1603 1
	(options, cache, sml_cache, perv_mo_cache, mo_cache, file, pervasive) =
d1608 9
a1616 1
       val file_name = Module.sml_name file
d1629 2
a1630 2
         do_input (error_info, options, cache, sml_cache, perv_mo_cache, mo_cache,
		   fn _ => input(instream, 4096), file, pervasive)
d1637 1
a1637 1
  fun compile_module error_info options module_ids =
d1640 51
a1690 12
      map
        (fn s =>
           case Module.find_sml
                  (ModuleId.from_string (s, Info.Location.UNKNOWN),
                   Module.empty_cache)
           of (MLWorks.Option.SOME (_, m, _), _) => m
           |  (MLWorks.Option.NONE, _) =>
             Info.error'
               error_info
               (Info.FATAL, Info.Location.UNKNOWN,
                "Can't find module `" ^ s ^ "' on source path"))
        module_ids
d1693 2
a1694 5
      (fn ((cache, perv_mo_cache,mo_cache), module) =>
         compile_file'
         error_info
         (options, cache, Module.empty_cache, perv_mo_cache, mo_cache, module, false))
      ((empty_cache, Module.empty_cache, Module.empty_cache), modules);
d1697 2
a1698 2

  fun compile_file error_info options filenames =
d1712 4
a1715 1
      fun compile_one ((cache, perv_mo_cache,mo_cache), (on_path, module)) =
d1731 3
a1733 1
	  val result =
d1736 18
a1753 1
	      (options, cache, Module.empty_cache, perv_mo_cache, mo_cache,module, false);
d1761 1
a1761 1
	  result
d1767 89
a1855 2
	compile_one
	((empty_cache, Module.empty_cache,Module.empty_cache), modules);
a1857 15
  
  fun compile_pervasive error_info options =
    (compile_file'
       error_info
	 (options, empty_cache, Module.empty_cache, Module.empty_cache, Module.empty_cache,
          Module.MODULE
	    (Io.get_pervasive_dir(),
	     ModuleId.from_string
	       (Io.pervasive_library_name, Info.Location.UNKNOWN)),
	  true);
     ())
     handle Io.NotSet _ =>
       Info.error'
	 error_info
	 (Info.FATAL, Info.Location.UNKNOWN, "Can't find pervasive library")
@


1.209
log
@The Type of LambdaTypes.SCON has changed.
@
text
@d4 3
d973 1
d990 1
@


1.208
log
@Add sml_cache to interface for compile_file' to improve finding
of .mo files
@
text
@d4 4
d1171 3
a1173 2
				      [LambdaTypes.SCON(Ident.STRING root_module_name_string)],
				      LambdaTypes.Option.ABSENT))
d1371 1
a1371 1
      val (initial_cb, builtin, module_str,filename) =
d1382 1
a1382 1
                   (initial_cb_for_builtin_library, true, root,filename))
d1388 1
a1388 1
                   (initial_cgb_for_normal_file, false, root,filename))
d1390 1
a1390 1
                (initial_cgb_for_normal_file, false, root,filename)
d1566 15
a1580 2
	    (Print.print "*** Changing top level environment\n";
	     after_builtin_cgb)
@


1.207
log
@Adding environment simplication function
@
text
@d4 3
d840 3
a842 1
  val do_diagnostic = false
d943 5
a947 11
(*
	      find_object (error_info, pervasive, ModuleId.parent mod_path,
			   perv_mo_cache,mo_cache, sub_module_id, location)
	      handle
	      ModuleId.NoParent =>
*)
		Info.error'
		error_info
		(Info.FATAL, location,
		 implode ["Required .mo file `",
			  ModuleId.string sub_module_id, "' not found"])
d968 1
a968 1
         cache, perv_mo_cache, mo_cache, mod_path, ts, initial, pervasive) = 
d1100 7
d1108 15
a1122 4
  		     find_object
		     (error_info, pervasive, mod_path,
		      perv_mo_cache,mo_cache,
		      sub_module_id, location)
a1123 6
(*
		   val root_module_name = Module.module_id mo
		   val root_module_name_string = ModuleId.string root_module_name

		   val mo_str = Module.mo_name mo
*)
d1364 1
a1364 1
                cache, perv_mo_cache, mo_cache, input_fn, source, pervasive) =
d1422 1
a1422 1
	  compile_program (error_info, options, cache, perv_mo_cache, mo_cache,
d1590 1
a1590 1
	(options, cache, perv_mo_cache, mo_cache, file, pervasive) =
d1608 1
a1608 1
         do_input (error_info, options, cache, perv_mo_cache, mo_cache,
d1636 1
a1636 1
         (options, cache, perv_mo_cache, mo_cache, module, false))
d1674 1
a1674 1
	      (options, cache,perv_mo_cache, mo_cache,module, false);
d1696 1
a1696 1
	 (options, empty_cache, Module.empty_cache, Module.empty_cache,
@


1.206
log
@Added debugging flag to mir optimiser
@
text
@d4 3
d1472 2
@


1.205
log
@Removing debug_polyvariables option
@
text
@d4 3
d834 4
a889 2
      
  fun diagnose_simple str = Diagnostic.output 1 (fn i => [str])
d892 1
a892 1
    Diagnostic.output level
d895 2
a904 11
  val produce_module = ref true

  val show_absyn       = ref false
  val show_lambda      = ref false
  val show_opt_lambda  = ref false
  val show_environ     = ref false
  val show_mir         = ref false
  val show_opt_mir     = ref false
  val show_mach        = ref false
  val output_lambda    = ref false

d907 4
a910 1
                         consistency : {mod_name : string, req_name : string, time : MLWorks.Time.time} list}) NewMap.T
d1198 1
a1198 1
		  if (#show_absyn listing_options orelse !show_absyn) then
d1397 1
a1397 1
	val _ = Diagnostic.output 3 (fn _ => ["Cleaning refs in initial basis"])
d1400 1
a1400 1
	val _ = Diagnostic.output 3 (fn _ => ["Cleaned refs in initial basis"])
d1402 1
a1402 1
	val _ = Diagnostic.output 3 (fn _ => ["Stamp reset to " ^ MLWorks.Integer.makestring(Stamp.read_counter()) ^ "\n"])
d1442 1
a1442 1
	  if (#show_lambda listing_options orelse !show_lambda) then
d1461 1
a1461 1
	  if (#show_opt_lambda listing_options orelse !show_opt_lambda) then
d1471 1
a1471 1
	  if (#show_environ listing_options orelse !show_environ) then
d1495 1
a1495 1
	  if (#show_mir listing_options orelse !show_mir) then
d1502 1
d1505 1
a1505 1
		      fn () => MirOptimiser.optimise the_mir_code);
d1509 1
a1509 1
	  if #show_opt_mir listing_options orelse !show_opt_mir then
d1535 1
a1535 1
	  if #show_mach listing_options orelse !show_mach then
d1566 3
a1568 3
    handle exn =>
      (Stamp.pop_counter();
       raise exn)
d1613 1
a1613 2
                "Can't find module `" ^ s
                ^ "' on source path"))
@


1.204
log
@Module naming improvements
@
text
@d4 3
d962 2
a963 2
                                        {generate_debug_info,debug_variables,debug_polyvariables,
                                         generate_stepper,generate_stepper_specific,generate_moduler,
d977 1
a977 4
                          debug_variables orelse debug_polyvariables orelse generate_moduler,
                          debug_polyvariables = false,
                          generate_stepper = generate_stepper,
                          generate_stepper_specific = generate_stepper_specific,
a1348 1
                                         debug_polyvariables,
d1554 1
a1554 1
		      (Encapsulate.output_file (debug_variables orelse debug_polyvariables orelse generate_moduler)
@


1.203
log
@Eliminate use of require_list
Replaced with an integer option, and removed as a parameter to do_subrequires
@
text
@d4 4
d924 1
a924 1
	     (Info.FATAL, location, "Pervasive directory not set or pervasive mo " ^
d933 1
d938 1
d993 1
a993 1
	(first, cache, perv_mo_cache, mo_cache, require_table, _, _, nil) =
d998 1
a998 1
	   mod_path, {mod_name = name, ...} :: cons) =
d1004 2
a1005 1
	    val ((mo, info), perv_mo_cache,mo_cache) =
d1007 1
a1007 1
	      (error_info, pervasive_file, mod_path,
d1009 1
a1009 1
	       ModuleId.from_string (name, Info.Location.FILE filename),
d1011 1
d1013 1
d1015 3
d1023 1
a1023 1
		 pervasive, mod_path, cons)
d1031 1
a1031 1
			    Encapsulate.input_info (Module.mo_name mo)
a1045 1
		     ModuleId.path (Module.module_id mo),
d1060 1
a1060 1
		   pervasive, mod_path, cons)
d1098 2
a1099 1
		   val ((mo, mo_stamp), perv_mo_cache,mo_cache) =
d1105 1
d1110 1
a1110 1

d1127 1
a1127 1
		      ModuleId.path (Module.module_id mo), cons)
d1609 1
a1609 1
           of (MLWorks.Option.SOME (m, _), _) => m
@


1.202
log
@Ensure proper module names used in the require lists
@
text
@d4 3
d987 2
a988 2
	(first, cache, perv_mo_cache, mo_cache,require_list, require_table, _, _, nil) =
	(cache, perv_mo_cache, mo_cache, require_list, require_table)
d991 1
a991 1
	  (first, cache, perv_mo_cache, mo_cache, require_list, require_table, pervasive,
d1010 1
a1010 1
		(false, cache, perv_mo_cache,mo_cache,require_list, require_table,
d1030 1
a1030 1
		  val (cache, perv_mo_cache, mo_cache, require_list, require_table) =
d1032 1
a1032 1
		    (true, cache, perv_mo_cache, mo_cache,require_list,
a1047 1
		   req_info :: require_list,
d1058 1
a1058 1
	    (arg as (cache, perv_mo_cache, mo_cache,pervasive, mod_path, require_list, require_table,
d1109 1
a1109 1
		   val (cache, perv_mo_cache, mo_cache,require_list, require_table) =
d1113 1
a1113 1
		     (true, cache, perv_mo_cache, mo_cache,require_list, require_table, pervasive,
d1125 1
a1125 1
		   val (require_table, require_list) =
d1127 1
a1127 1
		       MLWorks.Option.SOME _ => (require_table, require_list)
d1129 1
a1129 5
			 ((*output(std_out, "Toplevel adding '" ^ root_module_name_string ^ "' to require_list for decode_type_basis with mod_path = '" ^ ModuleId.path_string mod_path ^ "' real mod_name = " ^ mod_name ^ " req_name = " ^ req_name ^ "\n");*)
			  
			 (NewMap.define(require_table, root_module_name_string, req_info),
			  req_info :: require_list))

d1144 1
a1144 1
		   (cache, perv_mo_cache, mo_cache,require_list, require_table,
d1156 3
a1158 3
		  val require_list = case require_list of
		    ("", _) :: _ => require_list
		  | _ => ("", (stamp_count,0)) :: require_list
d1160 1
a1160 1
		  (cache, perv_mo_cache, mo_cache,require_list, require_table, [], [], empty_cb, empty_cb, counters,
d1165 1
a1165 1
		   (cache, perv_mo_cache, mo_cache,pervasive, mod_path, require_list, require_table,
d1172 3
a1174 3
		val require_list = case require_list of
		  ("", _) :: _ => require_list
		| _ => ("", (stamp_count,0)) :: require_list
d1217 1
a1217 1
		(cache, perv_mo_cache, mo_cache, require_list, require_table, [],
d1230 1
a1230 1
	(cache, perv_mo_cache, mo_cache,mod_path, require_list, require_table, reqs, code,
d1234 1
a1234 1
          val (cache, perv_mo_cache, mo_cache,require_list, require_table, requires,
d1238 1
a1238 1
	      (cache, perv_mo_cache, mo_cache,pervasive, mod_path, require_list, require_table,
d1247 1
a1247 1
            (cache, perv_mo_cache, mo_cache,require_list, require_table, reqs', code',
d1251 1
a1251 1
	      (cache, perv_mo_cache, mo_cache, mod_path, require_list, require_table, reqs', code',
d1261 1
a1261 1
      val (cache, perv_mo_cache, mo_cache,require_list, _, reqs_list, decls_list, CB(pbasis, basis, top_env),
d1268 1
a1268 1
	     [("", (stamp_count, 0))],
d1299 1
a1299 1
	      val (cache, perv_mo_cache, mo_cache,require_list, require_table, reqs_list,
d1302 1
a1302 1
		  (cache, perv_mo_cache, mo_cache, true, ModuleId.empty_path, [],
d1311 1
a1311 1
		(cache, perv_mo_cache, mo_cache,mod_path, require_list, require_table, reqs_list,
d1318 1
a1318 1
	     (cache, perv_mo_cache, mo_cache,mod_path, [], empty_string_map, [], [], initial,
d1325 1
a1325 1
      (cache, perv_mo_cache, mo_cache,require_list, reqs_list, lambda_exp',
d1394 1
a1394 1
	val (cache, perv_mo_cache, mo_cache, require_list, requires, lambda_exp, 
d1402 1
d1404 4
a1407 5
        val (stamps,other_requires) =
          case require_list of
            (("",(stamps,0)) :: other_requires) =>
              (stamps,other_requires)
          | _ => Crash.impossible "Garbled require list"
d1412 1
a1412 4
          ("",
           (stamps,final_stamp_count - stamps)) ::
          other_requires

d1414 8
a1421 8
	    let
	      val sml_name = Module.sml_name source
	    in
	      (case Os.mtime sml_name of
		 Os.EXISTS i => i
	       | _ => Crash.impossible
			("File `" ^ sml_name ^ "' no longer exists"))
	    end
d1424 5
a1428 5
	      let
		val string = ModuleId.string (Module.module_id source)
	      in
		{mod_name = string, req_name = string, time = sec_time} :: requires
	      end
@


1.201
log
@Combining stamp counts in one.
Other simplifications -- removed minor timings and test_string
Argument to mod_rules that describes if we are in separate compilation
@
text
@d4 5
a693 1
(* require "../lambda/lambdaio"; *)
a724 1
(*  structure LambdaIO : LAMBDAIO *)
d776 1
a903 47
(* This check probably shouldn't be here anyway *)
(*
  local
    fun check_in_set (bindings, (lv, le)) =
      if Map.domain_member (lv, bindings) then
        Crash.impossible ("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
                          "\nto\n" ^ LambdaPrint.string_of_lambda le ^
                          "\nand also to\n" ^
                          LambdaPrint.string_of_lambda(Map.lookup(lv, bindings)) ^
                          "\n")
      else
        Map.add ((lv, le), bindings, LambdaTypes.LVar_order)

    fun check_binding (bindings, LambdaTypes.APP(LambdaTypes.FN([lv], _,_,_,_), [le],_)) =
        ((if Map.domain_member(lv, bindings) then
            Crash.impossible("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
                             "\nto\n" ^ LambdaPrint.string_of_lambda le ^ "\nand also to\n" ^
                             LambdaPrint.string_of_lambda(Map.lookup(lv, bindings)) ^ "\n")
        else
          ());
        bindings)
      | check_binding (bindings, LambdaTypes.APP(LambdaTypes.FN([lv], _,_,_,_), lel,_)) =
        Crash.impossible "Arglist in check_bindings"
      | check_binding (bindings, LambdaTypes.APP(LambdaTypes.FN(lvl, _,_,_,_), lel,_)) =
        Crash.impossible "Varlist in check_bindings"
      | check_binding (bindings, LambdaTypes.LET((lv,_,lb),_)) =
        ((if Map.domain_member(lv, bindings) then
            Crash.impossible("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
                             "\nto\n" ^ LambdaPrint.string_of_lambda lb ^ "\nand also to\n" ^
                             LambdaPrint.string_of_lambda(Map.lookup(lv, bindings)) ^
                             "\n")
        else
          ());
        bindings)
      | check_binding(bindings, le as LambdaTypes.FN([lv], _,_,_,_)) =
        check_in_set(bindings, (lv, le))
      | check_binding(bindings, le as LambdaTypes.FN(lvl, _,_,_,_)) =
        Crash.impossible "Varlist in check_bindings"
      | check_binding(bindings, LambdaTypes.LETREC(lvl, lel, _)) =
        Lists.reducel check_in_set (bindings, Lists.zip(map #1 lvl, lel))
      | check_binding(bindings, _) = bindings
  in
    fun check_bindings expression =
      LambdaSub.reduce_outermost check_binding (Map.empty_map, expression)
  end
*)

d1034 1
a1034 1
	  val stamp_count = Stamp.read_counter ()
d1037 4
d1045 2
a1046 4
		   (module_name_string, 
                    (stamp_count,stamps)) ::
		   require_list,
		   NewMap.define(require_table, module_name_string, true),
d1103 1
a1103 1
		   val cons = case consistency of
d1105 1
a1105 1
		   | _ :: tl => tl
d1119 4
d1127 4
a1130 4
			 (NewMap.define(require_table, root_module_name_string, true),
			  (root_module_name_string, 
                           (stamp_count,stamps)) ::
			  require_list)
d1134 1
a1134 1
                      (t_env, root_module_name_string, require_list, false)
a1266 3
(*
	    val _ = output(std_out, "Compiling immediate eof\n")
*)
a1276 3
(*
	      val _ = output(std_out, "Compiling non-pervasive\n")
*)
a1444 10
(*
	val _ =
	  if !do_check_bindings then
	    (Print.print"Checking bindings from lambda translator\n";
	     check_bindings lambda_exp;
	     Print.print"Checked bindings from lambda translator\n")
	  else
	    ()
*)

a1452 10
(*
	val _ =
	  if !do_check_bindings then
	    (Print.print"Checking bindings from lambda optimiser\n";
	     check_bindings opt_lambda_exp;
	     Print.print"Checked bindings from lambda optimiser\n")
	  else
	    ()
*)

a1462 12

(*
        val _ =
          if #output_lambda listing_options orelse !output_lambda then
            let
              val stream = open_out "test.lam"
            in
              LambdaIO.output (stream, opt_lambda_exp);
              close_out stream
            end
          else ()
*)
@


1.200
log
@Changes to Debugger_Types
@
text
@d4 3
d681 1
d713 1
d785 2
a796 3
  structure Tyname_id = Datatypes.Tyname_id
  structure Tyfun_id = Datatypes.Tyfun_id
  structure Strname_id = Datatypes.Strname_id
a815 1
  val print_minor_timings = ref false
d880 3
a882 5
    Timer.xtime
    ("augment_cb", !print_timings andalso !print_minor_timings,
     fn () => CB (Parser.augment_pB (p, p'), 
                  Basis.basis_circle_plus_basis(t, t'), 
                  Environ.augment_top_env(c, c')))
a894 2
  val lambda_optimisation_switches = LambdaOptimiser.optimise_switches

d896 1
a896 1
  type cache = (string, {tynames : int, strnames : int, tyfuns : int,
d1054 1
a1054 1
		  val (cache, {consistency, tynames, strnames, tyfuns}) =
d1077 3
a1079 7
		  val tyname_count = Tyname_id.read_counter ()
		  val strname_count = Strname_id.read_counter ()
		  val tyfun_count = Tyfun_id.read_counter ()

		  val _ = Tyname_id.reset_counter (tyname_count + tynames)
		  val _ = Strname_id.reset_counter (strname_count + strnames)
		  val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
d1085 1
a1085 3
                    (tyname_count,tynames), 
                    (strname_count,strnames), 
                    (tyfun_count,tyfuns)) ::
a1091 6
      val do_subrequires =
	fn options =>
        fn x => Timer.xtime("do_subrequires",
                            !print_timings andalso !print_minor_timings,
                            (fn () => do_subrequires options x))

d1099 1
a1099 1
		     counters as (tynames, strnames, tyfuns),
d1139 1
a1139 6
		   val {parser_env, type_env=t_env, lambda_env, consistency,
	 		tynames, strnames, tyfuns} =
		     Timer.xtime
		     ("decoding require",
		      !print_timings andalso !print_minor_timings,
		      fn () =>
d1142 1
a1142 1
			Info.error' error_info  (Info.FATAL, location, message))
d1158 1
a1158 3
		   val tyname_count = Tyname_id.read_counter ()
		   val strname_count = Strname_id.read_counter ()
		   val tyfun_count = Tyfun_id.read_counter ()
d1166 1
a1166 3
                           (tyname_count,tynames), 
                           (strname_count,strnames), 
                           (tyfun_count,tyfuns)) ::
d1170 4
a1173 9
		     Timer.xtime("decoding encapsulated type basis of size " ^
				 MLWorks.Integer.makestring(size t_env),
				 !print_timings andalso !print_minor_timings,
				 fn () => Encapsulate.decode_type_basis
				 (t_env, root_module_name_string, require_list, false))

		   val _ = Tyname_id.reset_counter (tyname_count + tynames)
		   val _ = Strname_id.reset_counter (strname_count + strnames)
		   val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
d1193 1
a1193 3
		  val tyname_count = Tyname_id.read_counter ()
		  val strname_count = Strname_id.read_counter ()
		  val tyfun_count = Tyfun_id.read_counter ()
d1196 2
a1197 2
		    ("", _, _, _) :: _ => require_list
		  | _ => ("", (tyname_count,0), (strname_count,0), (tyfun_count,0)) :: require_list
d1209 1
a1209 3
		val tyname_count = Tyname_id.read_counter ()
		val strname_count = Strname_id.read_counter ()
		val tyfun_count = Tyfun_id.read_counter ()
d1212 2
a1213 2
		  ("", _, _, _) :: _ => require_list
		| _ => ("", (tyname_count,0), (strname_count,0), (tyfun_count,0)) :: require_list
d1220 1
a1220 1
		   (options,topdec,t, Mod_Rules.BASIS t)
d1223 1
a1223 5
		val _ = Timer.xtime (
			  "reducing strname chains",
                          !print_timings andalso !print_minor_timings,
                          fn () => Basis.reduce_chains t'
			)
d1240 1
a1240 3
		val tyname_count = Tyname_id.read_counter () - tyname_count
		val strname_count = Strname_id.read_counter () - strname_count
		val tyfun_count = Tyfun_id.read_counter () - tyfun_count
d1258 1
a1258 2
		 (tynames+tyname_count, strnames+strname_count,
		  tyfuns+tyfun_count),
d1296 1
a1296 1
      val initial_counters = (0, 0, 0)
d1307 1
a1307 3
	    val tyname_count = Tyname_id.read_counter ()
	    val strname_count = Strname_id.read_counter ()
	    val tyfun_count = Tyfun_id.read_counter ()
d1310 1
a1310 1
	     [("", (tyname_count, 0), (strname_count, 0), (tyfun_count, 0))],
d1367 1
a1367 3
	Timer.xtime("Packing topenv", 
                    !print_timings andalso !print_minor_timings,
                    fn () => LambdaModule.pack (top_env, decls_list))
a1373 2
  datatype source = FILE of Module.Module | DIRECT
    
d1379 4
a1382 1
                 Options.COMPILEROPTIONS{debug_variables,debug_polyvariables,generate_moduler,...},
a1386 3
        case source of
          DIRECT => (initial_cgb_for_normal_file, false, "direct input","<Direct Input>")
        | FILE file =>
d1388 2
a1389 2
              val filename = Module.sml_name file
	      val root = ModuleId.string (Module.module_id file)
d1414 1
a1414 4
      val mod_path =
	case source of
	  DIRECT => ModuleId.empty_path
	| FILE file => ModuleId.path (Module.module_id file)
d1427 2
a1428 4
      val _ = Datatypes.push_counters()
      val _ = Tyname_id.reset_counter Basis.pervasive_tyname_count
      val _ = Tyfun_id.reset_counter Basis.pervasive_tyfun_count
      val _ = Strname_id.reset_counter Basis.pervasive_strname_count
d1436 1
a1436 2
	val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ MLWorks.Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
	val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ MLWorks.Integer.makestring(Strname_id.read_counter()) ^ "\n"])
d1441 1
a1441 1
	     (tyname_count, strname_count, tyfun_count),debug_information) =
d1448 1
a1448 1
        val (tynames,strnames,tyfuns,other_requires) =
d1450 2
a1451 2
            (("",(tynames,0),(strnames,0),(tyfuns,0)) :: other_requires) =>
              (tynames,strnames,tyfuns,other_requires)
d1454 1
a1454 3
        val final_tyname_count = Tyname_id.read_counter ()
        val final_strname_count = Strname_id.read_counter ()
        val final_tyfun_count = Tyfun_id.read_counter ()
d1458 1
a1458 3
           (tynames,final_tyname_count - tynames),
           (strnames,final_strname_count - strnames),
           (tyfuns,final_tyfun_count - tyfuns)) ::
a1461 3
	  case source of
	    DIRECT => MLWorks.Time.zero
	  | FILE name =>
d1463 1
a1463 1
	      val sml_name = Module.sml_name name
a1471 3
	  case source of
	    DIRECT => requires
	  | FILE name =>
d1473 1
a1473 1
		val string = ModuleId.string (Module.module_id name)
d1618 1
d1623 7
a1629 8
		       {filename = (case source of
                                      FILE name => Module.mo_name name
                                    | DIRECT => "test.mo"),
			 code = the_machine_code, parser_env = parser_env,
			 type_basis = type_basis, debug_info = debugger_information,
			 require_list = require_list, lambda_env = top_env,
			 tynames = tyname_count, strnames = strname_count, tyfuns = tyfun_count,
			 consistency = requires}))
d1631 1
a1631 1
	Datatypes.pop_counters();
d1635 1
a1635 1
      (Datatypes.pop_counters();
d1661 1
a1661 1
		   fn _ => input(instream, 4096), FILE file, pervasive)
a1759 12

  fun test_string x =
    let
      val done = ref false
    in
      do_input
	(Info.default_options, Options.default_options, empty_cache,
	 Module.empty_cache, Module.empty_cache,
	 fn _ => if !done then "" else (done := true; x),
	 DIRECT, false);
      ()
    end
@


1.199
log
@Added diagnostic when extending the source path.
@
text
@d4 3
d685 1
a685 1
require "../lambda/lambdaio";
d716 1
a716 1
  structure LambdaIO : LAMBDAIO
d729 2
a730 1
  sharing Mir_Cg.MirTypes.Debugger_Types.Options =
a735 1
          Parser.Options =
d742 1
a742 2
	  Encapsulate.Debugger_Types =
          Lambda.Debugger_Types
d753 2
a754 2
    	  LambdaSub.LT =
          LambdaIO.LambdaTypes
a767 1
  sharing Lambda.Debugger_Types.NewMap = Basis.BasisTypes.Datatypes.NewMap
d769 1
d779 1
d813 2
d863 1
a863 1
  val empty_debug_info = Debugger_Types.INFO empty_string_map
d901 2
d946 1
a946 1

d992 3
a994 2
                                        compat_options,compiler_options=Options.COMPILEROPTIONS
                                        {debug,debug_variables,debug_polyvariables,
d1007 1
a1007 1
                         {debug = debug,
d1488 1
d1548 1
d1556 1
d1566 1
d1574 1
d1576 1
a1576 2
	val _ = diagnose_simple ("Lambda optimisation complete, final size of expression = " ^
				 MLWorks.Integer.makestring (LambdaSub.size_of_expr opt_lambda_exp))
d1587 1
d1597 1
@


1.198
log
@Moving pervasive counts to Basis
@
text
@d4 3
d1753 14
a1766 6
    in
      Lists.reducel
	(fn ((cache, perv_mo_cache,mo_cache), (on_path, module)) =>
	   (if not on_path then
	      Io.set_source_path
	        (Module.module_dir module :: old_source_path)
d1769 2
d1773 17
a1789 5
	      (options, cache,perv_mo_cache, mo_cache,module, false)))
	((empty_cache, Module.empty_cache,Module.empty_cache), modules)
      handle
	x => (Io.set_source_path old_source_path; raise x);
      Io.set_source_path old_source_path
@


1.197
log
@Replaced Option structure with references to MLWorks.Option.
Removed obsolete sharing constraint.
@
text
@d4 4
a670 2
require "../typechecker/types";
require "../typechecker/strenv";
a702 2
  structure Types : TYPES
  structure Strenv : STRENV
a734 3
  sharing Basis.BasisTypes.Datatypes =
          Strenv.Datatypes =
	  Types.Datatypes
d762 2
a763 2
  sharing Types.Datatypes.Ident = LambdaPrint.LambdaTypes.Ident
  sharing Lambda.Debugger_Types.NewMap = Types.Datatypes.NewMap
d767 2
a768 2
  sharing type Parser.Absyn.Type = Types.Datatypes.Type = Mir_Cg.LambdaTypes.Type
  sharing type Parser.Absyn.Structure = Types.Datatypes.Structure
d772 1
a772 1
  sharing type ModuleId.Location = Types.Datatypes.Ident.Location.T =
d783 1
a783 1
  structure Datatypes = Types.Datatypes
d1464 3
a1466 3
      val _ = Tyname_id.reset_counter Types.pervasive_tyname_count
      val _ = Tyfun_id.reset_counter Types.pervasive_tyfun_count
      val _ = Strname_id.reset_counter Strenv.pervasive_strname_count
@


1.196
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
a774 1
  sharing type Io.Directory = Module.Directory
d950 1
a950 1
	   (Module.Option.PRESENT f, perv_mo_cache) => (f, perv_mo_cache,mo_cache)
d961 2
a962 2
	    (Module.Option.PRESENT f, mo_cache) => (f, perv_mo_cache,mo_cache)
	  | (Module.Option.ABSENT, mo_cache) =>
d1035 1
a1035 1
	       ModuleId.from_require_string (name, Info.Location.FILE filename),
d1722 2
a1723 2
           of (Module.Option.PRESENT (m, _), _) => m
           |  (Module.Option.ABSENT, _) =>
d1776 1
a1776 1
	     ModuleId.from_require_string
@


1.195
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d654 1
a654 1
require "../make/unix";
d688 1
a688 1
 (structure Unix : UNIX
d1511 2
a1512 2
	      (case Unix.mtime sml_name of
		 Unix.EXISTS i => i
@


1.194
log
@Improved module caching
Lambdatypes changes.
@
text
@d4 4
d1036 1
a1036 1
	      NewMap.YES _ =>
d1044 1
a1044 1
		      NewMap.NO =>
d1056 1
a1056 1
		    | NewMap.YES info => (cache, info)
d1169 1
a1169 1
		       NewMap.YES _ => (require_table, require_list)
@


1.193
log
@Changes to lambdatypes
@
text
@d4 3
d847 3
a849 2
  val empty_debug_info =
    Debugger_Types.INFO (NewMap.empty' MLWorks.String.<)
d885 1
a885 1
  val empty_cache = NewMap.empty' MLWorks.String.<
d910 1
a910 1
      | check_binding (bindings, LambdaTypes.LET(lv,_,lb,_)) =
d932 1
a932 1
  fun find_object (error_info, pervasive, mod_path, mo_cache,
d940 2
a941 2
	case Module.find_pervasive_mo(sub_module_id, mo_cache) of
	   (Module.Option.PRESENT f, cache) => (f, cache)
d952 2
a953 2
	    (Module.Option.PRESENT f, _) => (f, mo_cache)
	  | (Module.Option.ABSENT, _) =>
d955 1
a955 1
			   mo_cache, sub_module_id, location)
d1011 2
a1012 2
	(first, cache, perv_mo_cache, require_list, require_table, _, _, nil) =
	(cache, perv_mo_cache, require_list, require_table)
d1015 1
a1015 1
	  (first, cache, perv_mo_cache, require_list, require_table, pervasive,
d1022 1
a1022 1
	    val ((mo, info), mo_cache') =
d1025 1
a1025 1
	       if pervasive_file then perv_mo_cache else mo_cache,
a1027 5
	    val (mo_cache, perv_mo_cache) =
	      if pervasive_file then
		(mo_cache, mo_cache')
	      else
		(mo_cache', perv_mo_cache)
d1034 1
a1034 1
		(false, cache, perv_mo_cache, require_list, require_table,
d1054 1
a1054 1
		  val (cache, perv_mo_cache, require_list, require_table) =
d1056 1
a1056 1
		    (true, cache, perv_mo_cache, require_list,
d1071 1
a1071 1
		  (false, cache, perv_mo_cache,
d1093 1
a1093 1
	    (arg as (cache, perv_mo_cache : Module.Cache, pervasive, mod_path, require_list, require_table,
d1122 1
a1122 1
		   val ((mo, mo_stamp), mo_cache') =
d1125 1
a1125 1
		      if pervasive then perv_mo_cache else mo_cache,
a1127 6
		   val (mo_cache, perv_mo_cache) =
		     if pervasive then
		       (mo_cache, mo_cache')
		     else
		       (mo_cache', perv_mo_cache)

d1149 1
a1149 1
		   val (cache, perv_mo_cache, require_list, require_table) =
d1153 1
a1153 1
		     (true, cache, perv_mo_cache, require_list, require_table, pervasive,
d1193 1
a1193 1
		   (cache, perv_mo_cache, require_list, require_table,
d1211 1
a1211 1
		  (cache, perv_mo_cache, require_list, require_table, [], [], empty_cb, empty_cb, counters,
d1216 1
a1216 1
		   (cache, perv_mo_cache, pervasive, mod_path, require_list, require_table,
d1276 1
a1276 1
		(cache, perv_mo_cache, require_list, require_table, [],
d1290 1
a1290 1
	(cache, perv_mo_cache, mod_path, require_list, require_table, reqs, code,
d1294 1
a1294 1
          val (cache, perv_mo_cache, require_list, require_table, requires,
d1298 1
a1298 1
	      (cache, perv_mo_cache, pervasive, mod_path, require_list, require_table,
d1307 1
a1307 1
            (cache, perv_mo_cache, require_list, require_table, reqs', code',
d1311 1
a1311 1
	      (cache, perv_mo_cache, mod_path, require_list, require_table, reqs', code',
d1321 1
a1321 1
      val (cache, perv_mo_cache, require_list, _, reqs_list, decls_list, CB(pbasis, basis, top_env),
d1332 1
a1332 1
	    (cache, perv_mo_cache,
d1334 1
a1334 1
	     NewMap.empty' String.<, [], [], empty_cb, initial_counters,
d1367 1
a1367 1
	      val (cache, perv_mo_cache, require_list, require_table, reqs_list,
d1370 2
a1371 2
		  (cache, perv_mo_cache, true, ModuleId.empty_path, [],
		   NewMap.empty' String.<, initial, initial_cgb_for_normal_file,
d1379 1
a1379 1
		(cache, perv_mo_cache, mod_path, require_list, require_table, reqs_list,
d1386 1
a1386 1
	     (cache, perv_mo_cache, mod_path, [], NewMap.empty' String.<, [], [], initial,
d1395 1
a1395 1
      (cache, perv_mo_cache, require_list, reqs_list, lambda_exp',
d1397 1
a1397 1
    end
d1408 1
a1408 1
                cache, mo_cache : Module.Cache, perv_mo_cache : Module.Cache, input_fn, source, pervasive) =
d1471 1
a1471 1
	val (cache, perv_mo_cache, require_list, requires, lambda_exp, 
d1669 1
a1669 1
        (cache, perv_mo_cache)
d1679 1
a1679 1
	(options, cache, mo_cache : Module.Cache, perv_mo_cache : Module.Cache, file, pervasive) =
d1696 2
a1697 2
       val result as (cache, perv_mo_cache) =
         do_input (error_info, options, cache, mo_cache, perv_mo_cache,
d1723 1
a1723 1
      (fn ((cache, perv_mo_cache), module) =>
d1725 3
a1727 3
             error_info
           (options, cache, Module.empty_cache, perv_mo_cache, module, false))
      ((empty_cache, Module.empty_cache), modules);
d1746 1
a1746 1
	(fn ((cache, perv_mo_cache), (on_path, module)) =>
d1754 2
a1755 3
	      (options, cache, Module.empty_cache, perv_mo_cache,
 	       module, false)))
	((empty_cache, Module.empty_cache), modules)
@


1.192
log
@Moved preferences into a separate structure.
@
text
@d4 3
d906 1
a906 4
      | check_binding (bindings, LambdaTypes.LET(lv,lb,_)) =
	let 
	  val lv = LambdaTypes.fetch_var lv
	in
a914 1
        end
d920 1
a920 1
        Lists.reducel check_in_set (bindings, Lists.zip(map LambdaTypes.fetch_var lvl, lel))
@


1.191
log
@Functions take a list of parameters
@
text
@d4 3
d972 1
a972 2
                                        print_options,environment_options,
                                        editor_options,extension_options,
a983 2
                         environment_options = environment_options,
                         editor_options = editor_options,
@


1.190
log
@Add original require file names to consistency info.
@
text
@d4 3
d888 1
a888 1
    fun check_binding (bindings, LambdaTypes.APP(LambdaTypes.FN(lv, _,_,_,_), le,_)) =
d896 4
d913 1
a913 1
      | check_binding(bindings, le as LambdaTypes.FN(lv, _,_,_,_)) =
d915 2
d1198 1
a1198 1
				      LambdaTypes.SCON(Ident.STRING root_module_name_string),
@


1.189
log
@added compile_module.
@
text
@d4 3
d871 1
a871 1
                         consistency : (string * MLWorks.Time.time) list}) NewMap.T
d1004 1
a1004 1
	   mod_path, (name,_) :: cons) =
d1193 3
a1195 1
		    [(root_module_name_string, mo_stamp)], (* This is where the entry for the require list is made *)
d1513 5
a1517 1
	      (ModuleId.string (Module.module_id name), sec_time) :: requires
@


1.188
log
@Changed name of pervasive stream to <Pervasive> (helps with debug info)
@
text
@d4 3
d1694 26
@


1.187
log
@Use the full filename for the location in token stream rather than module id.
This is to allow the error file finding mechanism to work
@
text
@d4 4
d1439 9
a1447 2
      val ts = Lexer.mkTokenStream (input_fn, filename)
	
@


1.186
log
@Step and Modules Debugger compiler options.
@
text
@d4 3
d1352 1
a1352 1
	      val token_stream = Lexer.mkTokenStream(lex_fun, "")
d1397 1
a1397 1
      val (initial_cb, builtin, module_str) =
d1399 1
a1399 1
          DIRECT => (initial_cgb_for_normal_file, false, "direct input")
d1402 1
d1411 1
a1411 1
                   (initial_cb_for_builtin_library, true, root))
d1417 1
a1417 1
                   (initial_cgb_for_normal_file, false, root))
d1419 1
a1419 1
                (initial_cgb_for_normal_file, false, root)
d1435 1
a1435 1
      val ts = Lexer.mkTokenStream (input_fn, module_str)
@


1.185
log
@Removed redundant code.
@
text
@d4 3
d823 1
a823 1
    Debugger_Types.INFO (NewMap.empty' MLWorks.String.<,false)
d950 4
a953 1
                                        {debug,intercept,no_execute,opt_leaf_fns,
d965 3
a967 1
                         {debug = debug,debug_variables = false,
d969 3
d1165 1
a1165 1
				 (t_env, root_module_name_string, require_list))
d1246 1
a1246 1
		val (c', declarations,debug_info') = 
d1253 1
a1253 1
			         (options, topdec, c,
d1255 1
a1255 1
				  Basis.basis_circle_plus_basis (t, t'))
d1389 2
d1630 4
a1633 2
		      (Encapsulate.output_file
		       {filename = (case source of FILE name => Module.mo_name name | DIRECT => "test.mo"),
@


1.184
log
@Fixed so that even empty files produce non-empty require_lists
@
text
@d4 3
a852 41
  val generate_profiling = ref true
  val generate_debug_information = ref false
  val print_generated_debug_information = ref false
  val generate_self_call_optimisation = ref true
  val generate_tail_optimisation = ref true
  val force_non_leaf = ref false

  val debug_level = ref 0

  fun set_debug_level level =
    (debug_level := level;
     case level of
       0 => 
         (generate_debug_information := false;
          force_non_leaf := false;
          generate_self_call_optimisation := true;
          generate_tail_optimisation := true)
     | 1 => 
         (generate_debug_information := true;
          force_non_leaf := false;
          generate_self_call_optimisation := true;
          generate_tail_optimisation := true)
     | 2 => 
         (generate_debug_information := true;
          force_non_leaf := false;
          generate_self_call_optimisation := true;
          generate_tail_optimisation := false)
     | 3 => 
         (generate_debug_information := true;
          force_non_leaf := false;
          generate_self_call_optimisation := false;
          generate_tail_optimisation := false)
     | 4 => 
         (generate_debug_information := true;
          force_non_leaf := true;
          generate_self_call_optimisation := false;
          generate_tail_optimisation := false)
     | _ => output(std_out,"0,1,2,3 for debug level\n"))

  val _ = set_debug_level 0

d1243 1
a1243 1
				  !generate_debug_information, debug_info,
a1606 24
	val _ =
	  if !print_generated_debug_information then
	    let
	      val Debugger_Types.INFO (i,_) = debugger_information
	      val info = NewMap.to_list i
	    in
	      case info of
		[] => ()
	      | _ => 
		  (Print.print "Generated debug information\n";
		   Lists.reducer
		   (fn((name,((ty,is_leaf,annotations),_)),_) =>
		    (output(std_out,name ^ " : " ^ Debugger_Types.print_type ty ^ " ");
		     (if is_leaf then
			output(std_out,"leaf\n")
		      else output(std_out,"not leaf\n"));
			Lists.reducer (fn ((x,y),_) =>
				       output(std_out,"  " ^ MLWorks.Integer.makestring x ^ "  " ^ 
					      Debugger_Types.print_backend_annotation y ^ "\n")) 
			(annotations,())))
		   (info,()))
	    end
	  else ()

a1641 4

       val _ = diagnose_simple
		 ("Compiling " ^ file_name ^ " at debugging level " ^
		  MLWorks.Integer.makestring(!debug_level))
@


1.183
log
@Module.module_and_path is now Module.find_file, is functional, and is
called on all arguments to compile_file before any compilation is done.
@
text
@d4 4
d1213 12
a1224 2
		(cache, perv_mo_cache, require_list, require_table, [], [], empty_cb, empty_cb, counters,
		 debug_info, true)
d1334 14
a1347 3
        if eof () then 
          (cache, perv_mo_cache, [], NewMap.empty' String.<, [], [], empty_cb, initial_counters,
	   empty_debug_info)
d1351 3
d1471 1
a1471 1
	  
@


1.182
log
@Module names have been moved from FileName to Module.
@
text
@d4 3
d1700 1
a1700 1
  fun compile_file error_info options modules =
d1702 11
a1712 13
      fun find_file module_name =
	let
          val module_id =
	    ModuleId.from_string (module_name, Info.Location.UNKNOWN)
        in
            case Module.find_sml (module_id, Module.empty_cache)
	    of (Module.Option.PRESENT (f, _), _) => f
	    |  (Module.Option.ABSENT, _) =>
	      Info.error'
	        error_info
	        (Info.FATAL, Info.Location.UNKNOWN,
	         "No such file `" ^ ModuleId.string module_id ^ "'")
	end
d1714 15
a1728 26
      (* This is a bit redundant.  Module_and_path searches the path to see
	 if the file is on the path.  Then find_file does it again to make
	 the module argument. *)
      (* might make more sense to use fold here *)
      Lists.iterate
	(fn filename =>
	   let val (module, old_source_path) =
		 Module.module_and_path (filename, Info.Location.UNKNOWN)

               val result =
		 compile_file'
                   error_info
	           (options, empty_cache, Module.empty_cache,
	            Module.empty_cache, module, false)
	   in Io.set_source_path old_source_path;
	      ()
	   end
	   handle
	     Module.NoSuchFile s =>
               (Info.error
                  error_info
                  (Info.RECOVERABLE, Info.Location.UNKNOWN,
                   "No such file: " ^ s ^ "\n");
                ()))
	modules;
      ()
@


1.181
log
@Undid previous undo.
@
text
@d4 3
d615 1
a615 1
require "../utils/filename";
d649 1
a649 1
  structure FileName : FILENAME
d726 4
a729 4
  sharing type Parser.Absyn.ModuleId = FileName.ModuleId = Io.ModuleId =
	       ModuleId.ModuleId
  sharing type Io.Directory = FileName.Directory
  sharing type ModuleId.Location = Types.Datatypes.Ident.Location.T
d757 2
a758 2
  type Module = FileName.Module
  type FileNameCache = FileName.Cache
d940 2
a941 2
	case FileName.find_pervasive_mo(sub_module_id, mo_cache) of
	   (FileName.Option.PRESENT f, cache) => (f, cache)
d951 3
a953 3
	  case FileName.find_mo (module_id, mo_cache) of
	    (FileName.Option.PRESENT f, _) => (f, mo_cache)
	  | (FileName.Option.ABSENT, _) =>
d1021 1
a1021 1
	       ModuleId.from_string (name, Info.Location.FILE filename),
d1028 1
a1028 1
	    val module_name = FileName.module_id mo
d1043 1
a1043 1
			    Encapsulate.input_info (FileName.mo_name mo)
d1058 1
a1058 1
		     ModuleId.path (FileName.module_id mo),
d1093 1
a1093 1
	    (arg as (cache, perv_mo_cache : FileName.Cache, pervasive, mod_path, require_list, require_table,
d1134 1
a1134 1
		   val root_module_name = FileName.module_id mo
d1137 1
a1137 1
		   val mo_str = FileName.mo_name mo
d1160 1
a1160 1
		      ModuleId.path (FileName.module_id mo), cons)
d1379 1
a1379 1
  datatype source = FILE of FileName.Module | DIRECT
d1386 1
a1386 1
                cache, mo_cache : FileName.Cache, perv_mo_cache : FileName.Cache, input_fn, source, pervasive) =
d1388 1
a1388 1
      val (initial_cb, builtin, filename) =
d1393 1
a1393 2
	      val root = ModuleId.string (FileName.module_id file)
	      val name = FileName.sml_name file
d1399 1
a1399 1
                   (Info.WARNING, Info.Location.FILE name,
d1401 1
a1401 1
                   (initial_cb_for_builtin_library, true, name))
d1405 1
a1405 1
                   (Info.WARNING, Info.Location.FILE name,
d1407 1
a1407 1
                   (initial_cgb_for_normal_file, false, name))
d1409 1
a1409 1
                (initial_cgb_for_normal_file, false, name)
d1416 1
a1416 1
	   Info.Location.FILE filename)
d1421 1
a1421 1
	| FILE file => ModuleId.path (FileName.module_id file)
d1425 1
a1425 1
      val ts = Lexer.mkTokenStream (input_fn, filename)
d1471 4
a1474 1
	      (case Unix.mtime (FileName.sml_name name) of
d1476 3
a1478 1
	       | _ => Crash.impossible ("File `" ^ filename ^ "' no longer exists"))
d1484 1
a1484 1
	      (ModuleId.string (FileName.module_id name), sec_time) :: requires
d1561 1
a1561 1
		       filename, debug_information)
d1649 1
a1649 1
		       {filename = (case source of FILE name => FileName.mo_name name | DIRECT => "test.mo"),
d1667 1
a1667 1
	(options, cache, mo_cache : FileName.Cache, perv_mo_cache : FileName.Cache, file, pervasive) =
d1672 1
a1672 1
       val file_name = FileName.sml_name file
d1704 3
a1706 3
            case FileName.find_sml (module_id, FileName.empty_cache)
	    of (FileName.Option.PRESENT (f, _), _) => f
	    |  (FileName.Option.ABSENT, _) =>
d1713 4
d1718 19
a1736 6
	(fn module_name =>
           compile_file'
             error_info
	     (options, empty_cache, FileName.empty_cache,
	      FileName.empty_cache,
	      find_file module_name, false))
d1744 2
a1745 2
	 (options, empty_cache, FileName.empty_cache, FileName.empty_cache,
          FileName.MODULE
d1747 1
a1747 1
	     ModuleId.from_string
d1762 1
a1762 1
	 FileName.empty_cache, FileName.empty_cache,
@


1.180
log
@Use short module name after all.
Otherwise decapsulation breaks
@
text
@d4 4
d1197 1
a1197 1
		    [(root, mo_stamp)], (* This is where the entry for the require list is made *)
@


1.179
log
@Put longer module identifier in mo dependencies.
@
text
@d4 3
d1193 1
a1193 1
		    [(root_module_name_string, mo_stamp)], (* This is where the entry for the require list is made *)
@


1.178
log
@Added range information for tyname_id's etc.
@
text
@d4 3
d1110 1
a1110 2
 		   val _ = diagnostic
			     (2, fn _ => ["requireDec ", root])
d1190 1
a1190 1
		    [(root, mo_stamp)], (* This is where the entry for the require list is made *)
@


1.177
log
@Moved some sigs from machine/ to main/
@
text
@d4 3
d1059 4
a1062 1
		   (module_name_string, tyname_count, strname_count, tyfun_count) ::
d1162 4
a1165 1
			  (root_module_name_string, tyname_count, strname_count, tyfun_count) ::
d1188 1
a1188 1
		    [(root, mo_stamp)],
d1209 2
a1210 1
		| _ => ("", tyname_count, strname_count, tyfun_count) :: require_list
d1435 21
@


1.176
log
@Renamed Encapsulate.Basistypes to Encapsulate.BasisTypes
@
text
@d4 3
d618 2
a619 2
require "../machine/mach_cg";
require "../machine/machprint";
@


1.175
log
@New pervasive Time structure.
@
text
@d4 3
d95 1
a95 1
Changes because Assemblies now has Basistypes instead of Datatypes
d667 1
a667 1
	  Encapsulate.Basistypes = Lambda.BasisTypes
@


1.174
log
@Added interrupt option
@
text
@d4 3
d864 1
a864 1
                         consistency : (string * MLWorks.Time.Real.T) list}) NewMap.T
d1421 1
a1421 1
	    DIRECT => MLWorks.Time.Real.zero
@


1.173
log
@Merging in bug fixes
@
text
@d4 3
d968 1
@


1.172
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger;
change also to Debugger_Types.INFO.
@
text
@d4 8
d912 7
a918 16
	let
	  val mo_file =
	    FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)
	    handle Io.NotSet _ =>
	      Info.error'
	      error_info
	      (Info.FATAL, location, "Pervasive directory not set")
	in
	  case Unix.mtime (FileName.mo_name mo_file) of
	    Unix.EXISTS time => (mo_file, time)
	  | Unix.NOT_EXIST =>
	      Info.error'
	      error_info
	      (Info.FATAL, location, "Can't find pervasive library '" ^
	       FileName.mo_name mo_file ^ "'")
	end
d924 1
a924 1
	    (FileName.Option.PRESENT f, _) => f
d952 1
a952 1
         cache, mo_cache, mod_path, ts, initial, pervasive) = 
d977 2
a978 2
	(first, cache, require_list, require_table, _, _, nil) =
	(cache, require_list, require_table)
d981 1
a981 1
	  (first, cache, require_list, require_table, pervasive,
a985 10
(*
	    val pervasive_name = name = Io.pervasive_library_name
	    val _ =
	      if pervasive_name then
		output(std_out, "Found pervasive_library_name at position " ^
		       MLWorks.Integer.makestring(Lists.length cons) ^
		       " from the end\n")
	      else
		()
*)
d987 2
a988 1
	    val (mo, info) =
d990 2
a991 1
	      (error_info, pervasive orelse pervasive_name, mod_path, mo_cache,
d994 5
d1004 3
a1006 2
		do_subrequires options (false, cache, require_list, require_table,
					pervasive, mod_path, cons)
a1008 7
(*
		  val (mo, _) =
		    find_object
		    (error_info, pervasive, mod_path, mo_cache,
		     ModuleId.from_string (name, Info.Location.FILE filename),
		     Info.Location.FILE filename)
*)
d1025 1
a1025 1
		  val (cache, require_list, require_table) =
d1027 1
a1027 1
		    (true, cache, require_list,
d1042 1
a1042 1
		  (false, cache,
d1061 1
a1061 1
	    (arg as (cache, pervasive, mod_path, require_list, require_table,
d1091 5
a1095 3
		   val (mo, mo_stamp) =
  		     find_object (error_info, pervasive, mod_path,
				  mo_cache, sub_module_id, location)
d1097 6
a1119 6
(*
		   val ((name, _), cons) =
		     case consistency of
		       [] => Crash.impossible "Strange, no consistency info"
		     | (_, time) :: tl => ((root, time), tl)
*)
d1124 1
a1124 1
		   val (cache, require_list, require_table) =
d1128 1
a1128 1
		     (true, cache, require_list, require_table, pervasive,
d1165 2
a1166 2
		   (cache, require_list, require_table,
		    [(root_module_name_string, mo_stamp)],
d1172 1
a1172 1
		(cache, require_list, require_table, [], [], empty_cb, empty_cb, counters,
d1176 1
a1176 1
		   (cache, pervasive, mod_path, require_list, require_table,
d1235 1
a1235 1
		(cache, require_list, require_table, [],
d1248 4
a1251 3
      fun compile_topdecs' (cache, mod_path, require_list, require_table, reqs, code,
			    initial_cb, compiled_cb, parse, eof, counters,
			    debug_info, had_topdec) = 
d1253 1
a1253 1
          val (cache, require_list, require_table, requires,
d1257 1
a1257 1
	      (cache, pervasive, mod_path, require_list, require_table,
d1266 1
a1266 1
            (cache, require_list, require_table, reqs', code',
d1270 1
a1270 1
	      (cache, mod_path, require_list, require_table, reqs', code',
d1280 1
a1280 1
      val (cache, require_list, _, reqs_list, decls_list, CB(pbasis, basis, top_env),
d1283 1
a1283 1
          (cache, [], NewMap.empty' String.<, [], [], empty_cb, initial_counters,
d1312 1
a1312 1
	      val (cache, require_list, require_table, reqs_list,
d1315 1
a1315 1
		  (cache, true, ModuleId.empty_path, [],
d1324 1
a1324 1
		(cache, mod_path, require_list, require_table, reqs_list,
d1331 1
a1331 1
	     (cache, mod_path, [], NewMap.empty' String.<, [], [], initial,
d1340 1
a1340 1
      (cache, require_list, reqs_list, lambda_exp',
d1351 1
a1351 1
                cache, mo_cache, input_fn, source, pervasive) =
d1386 2
a1387 2
	   DIRECT => ModuleId.empty_path
	|  FILE file => ModuleId.path (FileName.module_id file)
d1403 1
a1403 1

d1406 2
a1407 2

	val (cache, require_list, requires, lambda_exp, 
d1410 1
a1410 1
	  compile_program (error_info, options, cache, mo_cache,
d1445 6
a1450 6
	if (!do_lambda_opt) then
	  Timer.xtime("LambdaOptimiser", 
                      !print_timings, 
                      fn () => LambdaOptimiser.optimise options lambda_exp)
	else
	  lambda_exp
d1585 10
a1594 11
      val result =
	Timer.xtime("Outputting", !print_timings,
		    fn () =>
		    (Encapsulate.output_file
		     {filename = (case source of FILE name => FileName.mo_name name | DIRECT => "test.mo"),
		       code = the_machine_code, parser_env = parser_env,
		       type_basis = type_basis, debug_info = debugger_information,
		       require_list = require_list, lambda_env = top_env,
		       tynames = tyname_count, strnames = strname_count, tyfuns = tyfun_count,
		       consistency = requires};
		       cache));
d1597 1
a1597 1
        result
d1599 3
a1601 3
        handle exn =>
	  (Datatypes.pop_counters();
	   raise exn)
d1607 1
a1607 1
	(options, cache, mo_cache, file, pervasive) =
d1628 2
a1629 2
       val cache =
         do_input (error_info, options, cache, mo_cache,
d1634 1
a1634 1
       cache
d1658 1
d1667 1
a1667 1
	 (options, empty_cache, FileName.empty_cache,
d1685 1
a1685 1
	 FileName.empty_cache,
@


1.171
log
@Merged in bug fixes
@
text
@d4 3
d774 1
a774 1
    Debugger_Types.INFO (NewMap.empty' MLWorks.String.<)
d864 1
a864 1
    fun check_binding (bindings, LambdaTypes.APP(LambdaTypes.FN(lv, _,_,_), le,_)) =
d884 2
a885 2
	end
      | check_binding(bindings, le as LambdaTypes.FN(lv, _,_,_)) =
d945 8
a952 5
  fun compile_program
	(error_info,
         options as Options.OPTIONS
	   ({listing_options = Options.LISTINGOPTIONS listing_options,
             print_options, ...}),
d955 14
d1564 1
a1564 1
	      val Debugger_Types.INFO i = debugger_information
@


1.170
log
@Changed find_object and compile_file' to take a filename cache.
Changed type of compile_file to take a list of strings, so that caches can
be preserved between each compilation (I haven't implemented this yet).
@
text
@d4 12
d895 2
a896 2
    let val module_id = ModuleId.add_path (mod_path, sub_module_id)
	val _ = diagnostic
d901 7
a907 6
	let val mo_file =
              FileName.MODULE (Io.get_pervasive_dir(), module_id)
              handle Io.NotSet _ =>
                Info.error'
                  error_info
                  (Info.FATAL, location, "Pervasive directory not set")
d909 4
a912 4
	  case Unix.mtime (FileName.mo_name mo_file)
	  of Unix.EXISTS time => (mo_file, time)
	  |  Unix.NOT_EXIST =>
	    Info.error'
d914 2
a915 1
	      (Info.FATAL, location, "Can't find pervasive library")
d918 16
a933 12
        case FileName.find_mo (module_id, mo_cache)
        of (FileName.Option.PRESENT f, _) => f
        |  (FileName.Option.ABSENT, _) =>
          find_object (error_info, pervasive, ModuleId.parent mod_path,
		       mo_cache, sub_module_id, location)
          handle
            ModuleId.NoParent =>
              Info.error'
                error_info
                (Info.FATAL, location,
                 implode ["Required .mo file `",
                          ModuleId.string sub_module_id, "' not found"])
d957 2
a958 2
	    options
	    (cache, require_list, require_table, _, _, nil) =
d960 54
a1013 19
      |   do_subrequires
	    options
	    (cache, require_list, require_table, pervasive,
	     mod_path, (name,_) :: cons) =
	let
 	  val _ = diagnostic (2, fn _ => ["do_subrequires of ", filename,
					  ", ", name])
	in
	  case NewMap.tryApply'(require_table, name) of
	    NewMap.YES _ =>
	      do_subrequires options (cache, require_list, require_table,
				      pervasive, mod_path, cons)
	  | _ =>
	    let
	      val (mo, _) =
		find_object
		  (error_info, pervasive, mod_path, mo_cache,
		   ModuleId.from_string (name, Info.Location.FILE filename),
		   Info.Location.FILE filename)
d1015 6
a1020 15
	      val (cache, {consistency, tynames, strnames, tyfuns}) =
                case NewMap.tryApply' (cache, name) of
                  NewMap.NO =>
                    let
                      val info =
                        Encapsulate.input_info (FileName.mo_name mo)
                        handle Encapsulate.BadInput s =>
			  (output (std_out, "In do_subrequires\n");
                          Info.error'
                          Info.default_options
                          (Info.FATAL, Info.Location.FILE filename, s))
                    in
                      (NewMap.define (cache, name, info), info)
                    end
                | NewMap.YES info => (cache, info)
d1022 3
a1024 6
	      val (cache, require_list, require_table) =
		do_subrequires options
                               (cache, require_list,
				require_table, pervasive,
				ModuleId.path (FileName.module_id mo),
				case consistency of [] => [] | _ :: tl => tl)
d1026 13
a1038 3
	      val tyname_count = Tyname_id.read_counter ()
	      val strname_count = Strname_id.read_counter ()
	      val tyfun_count = Tyfun_id.read_counter ()
a1039 13
	      val _ = Tyname_id.reset_counter (tyname_count + tynames)
	      val _ = Strname_id.reset_counter (strname_count + strnames)
	      val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
	    in
	      do_subrequires
              options
              (cache,
               (name, tyname_count, strname_count, tyfun_count) :: require_list,
	       NewMap.define(require_table, name, true),
               pervasive, mod_path, cons)
	    end
	end

d1085 3
d1102 1
d1107 4
d1116 1
a1116 1
		     (cache, require_list, require_table, pervasive,
a1125 8
(* This isn't quite right. If the module in question has already been required
   as a subrequire, it will have already been assigned a set of names somewhere
   else, in which case we should duplicate them.
		val require_list = 
		  (root, tyname_count, strname_count, tyfun_count) ::
		  require_list
*)

d1127 1
a1127 1
		     case NewMap.tryApply'(require_table, root) of
d1130 2
a1131 2
			 (NewMap.define(require_table, root, true),
			  (root, tyname_count, strname_count, tyfun_count) ::
d1139 1
a1139 1
				 (t_env, root, require_list))
d1150 1
a1150 1
				      LambdaTypes.SCON(Ident.STRING  name),
d1153 2
a1154 1
		   (cache, require_list, require_table, [(name, mo_stamp)],
a1171 5
(* Not quite right again
		val require_list =
		  ("", tyname_count, strname_count, tyfun_count) ::
		  require_list
*)
a1307 10
(*
	      val the_token_list =
		[Token.RESERVED(Token.REQUIRE),
		 Token.STRING(Io.pervasive_library_name),
		 Token.RESERVED(Token.SEMICOLON)]
	      val _ =
		Lists.iterate
		(fn x => Lexer.ungetToken(x, ts))
		(rev the_token_list)
*)
a1314 7
(*
	      compile_topdecs'(cache,
                               mod_path, [], NewMap.empty' String.<, [], [],
			       initial_cgb_for_normal_file,
			       empty_cb, parse, eof,
			       initial_counters, empty_debug_info, false)
*)
@


1.170.1.1
log
@Fork for bug fixing
@
text
@a3 5
Revision 1.170  1993/08/28  16:44:19  daveb
Changed find_object and compile_file' to take a filename cache.
Changed type of compile_file to take a list of strings, so that caches can
be preserved between each compilation (I haven't implemented this yet).

@


1.170.1.2
log
@Fixed problem whereby require_table and require_list did not consist of full
module names, and hence multiple versions of modules could arise
@
text
@a3 3
Revision 1.170.1.1  1993/08/28  16:44:19  jont
Fork for bug fixing

d888 2
a889 2
    let
      val _ = diagnostic
d894 6
a899 7
	let
	  val mo_file =
	    FileName.MODULE (Io.get_pervasive_dir(), sub_module_id)
	    handle Io.NotSet _ =>
	      Info.error'
	      error_info
	      (Info.FATAL, location, "Pervasive directory not set")
d901 4
a904 4
	  case Unix.mtime (FileName.mo_name mo_file) of
	    Unix.EXISTS time => (mo_file, time)
	  | Unix.NOT_EXIST =>
	      Info.error'
d906 1
a906 2
	      (Info.FATAL, location, "Can't find pervasive library '" ^
	       FileName.mo_name mo_file ^ "'")
d909 12
a920 16
	let
	  val module_id = ModuleId.add_path (mod_path, sub_module_id)
	in
	  case FileName.find_mo (module_id, mo_cache) of
	    (FileName.Option.PRESENT f, _) => f
	  | (FileName.Option.ABSENT, _) =>
	      find_object (error_info, pervasive, ModuleId.parent mod_path,
			   mo_cache, sub_module_id, location)
	      handle
	      ModuleId.NoParent =>
		Info.error'
		error_info
		(Info.FATAL, location,
		 implode ["Required .mo file `",
			  ModuleId.string sub_module_id, "' not found"])
	end
d944 2
a945 2
	options
	(first, cache, require_list, require_table, _, _, nil) =
d947 19
a965 54
	| do_subrequires
	  options
	  (first, cache, require_list, require_table, pervasive,
	   mod_path, (name,_) :: cons) =
	  let
	    val _ = diagnostic (2, fn _ => ["do_subrequires of ", filename,
					    ", ", name])
(*
	    val pervasive_name = name = Io.pervasive_library_name
	    val _ =
	      if pervasive_name then
		output(std_out, "Found pervasive_library_name at position " ^
		       MLWorks.Integer.makestring(Lists.length cons) ^
		       " from the end\n")
	      else
		()
*)
	    val pervasive_name = first
	    val (mo, info) =
	      find_object
	      (error_info, pervasive orelse pervasive_name, mod_path, mo_cache,
	       ModuleId.from_string (name, Info.Location.FILE filename),
	       Info.Location.FILE filename)
	    val module_name = FileName.module_id mo
	    val module_name_string = ModuleId.string module_name
	  in
	    case NewMap.tryApply'(require_table, module_name_string) of
	      NewMap.YES _ =>
		do_subrequires options (false, cache, require_list, require_table,
					pervasive, mod_path, cons)
	    | _ =>
		let
(*
		  val (mo, _) =
		    find_object
		    (error_info, pervasive, mod_path, mo_cache,
		     ModuleId.from_string (name, Info.Location.FILE filename),
		     Info.Location.FILE filename)
*)
		  val (cache, {consistency, tynames, strnames, tyfuns}) =
		    case NewMap.tryApply' (cache, module_name_string) of
		      NewMap.NO =>
			let
			  val info =
			    Encapsulate.input_info (FileName.mo_name mo)
			    handle Encapsulate.BadInput s =>
			      (output (std_out, "In do_subrequires\n");
			       Info.error'
			       Info.default_options
			       (Info.FATAL, Info.Location.FILE filename, s))
			in
			  (NewMap.define (cache, module_name_string, info), info)
			end
		    | NewMap.YES info => (cache, info)
d967 15
a981 6
		  val (cache, require_list, require_table) =
		    do_subrequires options
		    (true, cache, require_list,
		     require_table, pervasive orelse pervasive_name,
		     ModuleId.path (FileName.module_id mo),
		     case consistency of [] => [] | _ :: tl => tl)
d983 6
a988 3
		  val tyname_count = Tyname_id.read_counter ()
		  val strname_count = Strname_id.read_counter ()
		  val tyfun_count = Tyfun_id.read_counter ()
d990 3
a992 13
		  val _ = Tyname_id.reset_counter (tyname_count + tynames)
		  val _ = Strname_id.reset_counter (strname_count + strnames)
		  val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)
		in
		  do_subrequires
		  options
		  (false, cache,
		   (module_name_string, tyname_count, strname_count, tyfun_count) ::
		   require_list,
		   NewMap.define(require_table, module_name_string, true),
		   pervasive, mod_path, cons)
		end
	  end
d994 13
a1051 3
		   val root_module_name = FileName.module_id mo
		   val root_module_name_string = ModuleId.string root_module_name

a1065 1
(*
a1069 4
*)
		   val cons = case consistency of
		     [] => Crash.impossible "Strange, no consistency info"
		   | _ :: tl => tl
d1075 1
a1075 1
		     (true, cache, require_list, require_table, pervasive,
d1085 8
d1094 1
a1094 1
		     case NewMap.tryApply'(require_table, root_module_name_string) of
d1097 2
a1098 2
			 (NewMap.define(require_table, root_module_name_string, true),
			  (root_module_name_string, tyname_count, strname_count, tyfun_count) ::
d1106 1
a1106 1
				 (t_env, root_module_name_string, require_list))
d1117 1
a1117 1
				      LambdaTypes.SCON(Ident.STRING root_module_name_string),
d1120 1
a1120 2
		   (cache, require_list, require_table,
		    [(root_module_name_string, mo_stamp)],
d1138 5
d1279 10
d1296 7
@


1.170.1.3
log
@Changed to returned pervasive_mo cache and to use it.
@
text
@a3 7
Revision 1.171  1993/09/15  18:48:38  jont
Merged in bug fixes

Revision 1.170.1.2  1993/09/15  15:49:00  jont
Fixed problem whereby require_table and require_list did not consist of full
module names, and hence multiple versions of modules could arise

d897 16
a912 7
	case FileName.find_pervasive_mo(sub_module_id, mo_cache) of
	   (FileName.Option.PRESENT f, cache) => (f, cache)
	 | _ =>
	     Info.error'
	     error_info
	     (Info.FATAL, location, "Pervasive directory not set or pervasive mo " ^
	      ModuleId.string sub_module_id ^ "' not found")
d918 1
a918 1
	    (FileName.Option.PRESENT f, _) => (f, mo_cache)
d943 1
a943 1
         cache, perv_mo_cache, mo_cache, mod_path, ts, initial, pervasive) = 
d954 2
a955 2
	(first, cache, perv_mo_cache, require_list, require_table, _, _, nil) =
	(cache, perv_mo_cache, require_list, require_table)
d958 1
a958 1
	  (first, cache, perv_mo_cache, require_list, require_table, pervasive,
d963 10
d974 1
a974 2
	    val pervasive_file = pervasive orelse pervasive_name
	    val ((mo, info), mo_cache') =
d976 1
a976 2
	      (error_info, pervasive_file, mod_path,
	       if pervasive_file then perv_mo_cache else mo_cache,
a978 5
	    val (mo_cache, perv_mo_cache) =
	      if pervasive_file then
		(mo_cache, mo_cache')
	      else
		(mo_cache', perv_mo_cache)
d984 2
a985 3
		do_subrequires options
		(false, cache, perv_mo_cache, require_list, require_table,
		 pervasive, mod_path, cons)
d988 7
d1011 1
a1011 1
		  val (cache, perv_mo_cache, require_list, require_table) =
d1013 1
a1013 1
		    (true, cache, perv_mo_cache, require_list,
d1028 1
a1028 1
		  (false, cache, perv_mo_cache,
d1047 1
a1047 1
	    (arg as (cache, perv_mo_cache : FileName.Cache, pervasive, mod_path, require_list, require_table,
d1077 3
a1079 5
		   val ((mo, mo_stamp), mo_cache') =
  		     find_object
		     (error_info, pervasive, mod_path,
		      if pervasive then perv_mo_cache else mo_cache,
		      sub_module_id, location)
a1080 6
		   val (mo_cache, perv_mo_cache) =
		     if pervasive then
		       (mo_cache, mo_cache')
		     else
		       (mo_cache', perv_mo_cache)

d1098 6
d1108 1
a1108 1
		   val (cache, perv_mo_cache, require_list, require_table) =
d1112 1
a1112 1
		     (true, cache, perv_mo_cache, require_list, require_table, pervasive,
d1149 2
a1150 2
		   (cache, perv_mo_cache, require_list, require_table,
		    [(root, mo_stamp)],
d1156 1
a1156 1
		(cache, perv_mo_cache, require_list, require_table, [], [], empty_cb, empty_cb, counters,
d1160 1
a1160 1
		   (cache, perv_mo_cache, pervasive, mod_path, require_list, require_table,
d1219 1
a1219 1
		(cache, perv_mo_cache, require_list, require_table, [],
d1232 3
a1234 4
      fun compile_topdecs'
	(cache, perv_mo_cache, mod_path, require_list, require_table, reqs, code,
	 initial_cb, compiled_cb, parse, eof, counters,
	 debug_info, had_topdec) = 
d1236 1
a1236 1
          val (cache, perv_mo_cache, require_list, require_table, requires,
d1240 1
a1240 1
	      (cache, perv_mo_cache, pervasive, mod_path, require_list, require_table,
d1249 1
a1249 1
            (cache, perv_mo_cache, require_list, require_table, reqs', code',
d1253 1
a1253 1
	      (cache, perv_mo_cache, mod_path, require_list, require_table, reqs', code',
d1263 1
a1263 1
      val (cache, perv_mo_cache, require_list, _, reqs_list, decls_list, CB(pbasis, basis, top_env),
d1266 1
a1266 1
          (cache, perv_mo_cache, [], NewMap.empty' String.<, [], [], empty_cb, initial_counters,
d1295 1
a1295 1
	      val (cache, perv_mo_cache, require_list, require_table, reqs_list,
d1298 1
a1298 1
		  (cache, perv_mo_cache, true, ModuleId.empty_path, [],
d1307 1
a1307 1
		(cache, perv_mo_cache, mod_path, require_list, require_table, reqs_list,
d1314 1
a1314 1
	     (cache, perv_mo_cache, mod_path, [], NewMap.empty' String.<, [], [], initial,
d1323 1
a1323 1
      (cache, perv_mo_cache, require_list, reqs_list, lambda_exp',
d1334 1
a1334 1
                cache, mo_cache : FileName.Cache, perv_mo_cache : FileName.Cache, input_fn, source, pervasive) =
d1369 2
a1370 2
	  DIRECT => ModuleId.empty_path
	| FILE file => ModuleId.path (FileName.module_id file)
d1386 1
a1386 1
	  
d1389 2
a1390 2
	  
	val (cache, perv_mo_cache, require_list, requires, lambda_exp, 
d1393 1
a1393 1
	  compile_program (error_info, options, cache, perv_mo_cache, mo_cache,
d1428 6
a1433 6
	  if (!do_lambda_opt) then
	    Timer.xtime("LambdaOptimiser", 
			!print_timings, 
			fn () => LambdaOptimiser.optimise options lambda_exp)
	  else
	    lambda_exp
d1568 11
a1578 10
	val _ =
	  Timer.xtime("Outputting", !print_timings,
		      fn () =>
		      (Encapsulate.output_file
		       {filename = (case source of FILE name => FileName.mo_name name | DIRECT => "test.mo"),
			 code = the_machine_code, parser_env = parser_env,
			 type_basis = type_basis, debug_info = debugger_information,
			 require_list = require_list, lambda_env = top_env,
			 tynames = tyname_count, strnames = strname_count, tyfuns = tyfun_count,
			 consistency = requires}))
d1581 1
a1581 1
        (cache, perv_mo_cache)
d1583 3
a1585 3
    handle exn =>
      (Datatypes.pop_counters();
       raise exn)
d1591 1
a1591 1
	(options, cache, mo_cache : FileName.Cache, perv_mo_cache : FileName.Cache, file, pervasive) =
d1612 2
a1613 2
       val result as (cache, perv_mo_cache) =
         do_input (error_info, options, cache, mo_cache, perv_mo_cache,
d1618 1
a1618 1
       result
a1641 1
	      FileName.empty_cache,
d1650 1
a1650 1
	 (options, empty_cache, FileName.empty_cache, FileName.empty_cache,
d1668 1
a1668 1
	 FileName.empty_cache, FileName.empty_cache,
@


1.169
log
@Improved searching for mos.
@
text
@d4 3
d706 2
a707 1
  type ModuleId = ModuleId.ModuleId
d881 2
a882 1
  fun find_object (error_info, pervasive, mod_path, sub_module_id, location) =
d904 3
a906 3
        case FileName.find_mo module_id
        of FileName.Option.PRESENT f => f
        |  FileName.Option.ABSENT =>
d908 1
a908 1
		       sub_module_id, location)
d929 1
a929 1
         cache, mod_path, ts, initial, pervasive) = 
d958 1
a958 1
		  (error_info, pervasive, mod_path,
d1045 1
a1045 1
			          sub_module_id, location)
d1321 1
a1321 1
                cache, input_fn, source, pervasive) =
d1380 2
a1381 2
	  compile_program (error_info, options, cache, mod_path,
	                   ts, initial_cb, pervasive)
d1576 3
a1578 1
  fun compile_file' error_info (options, cache, module_id, pervasive) =
a1582 12
       val file =
         if pervasive then
           FileName.MODULE (Io.get_pervasive_dir(), module_id)
         else
           case FileName.find_sml module_id
	   of FileName.Option.PRESENT (f, _) => f
	   |  FileName.Option.ABSENT =>
	     Info.error'
	       error_info
	       (Info.FATAL, Info.Location.UNKNOWN,
		"No such file `" ^ ModuleId.string module_id ^ "'")

d1600 2
a1601 2
         do_input (error_info,options,cache, fn _ => input(instream, 4096),
		   FILE file, pervasive)
d1608 25
a1632 7
  fun compile_file error_info options module_name =
    (compile_file'
       error_info
	 (options, empty_cache,
	  ModuleId.from_string (module_name, Info.Location.UNKNOWN),
	  false);
     ())
d1637 5
a1641 3
	 (options, empty_cache,
	  ModuleId.from_string
	    (Io.pervasive_library_name, Info.Location.UNKNOWN),
d1644 4
d1653 5
a1657 7
      do_input (
	Info.default_options,
        Options.default_options,
	empty_cache,
	fn _ => if !done then "" else (done := true; x),
	DIRECT,
	false);
@


1.168
log
@Changed the require syntax back to old style so that NJ can cope.
@
text
@d4 3
a673 1
  sharing type ModuleId.Path = FileName.ModulePath
d877 36
d919 6
a924 9
  fun compile_program (error_info,
                       options as Options.OPTIONS({listing_options = Options.LISTINGOPTIONS listing_options,
                                                   print_options,
                                                   ...}),
                       cache,
                       dir, mod_path,
                       ts,
                       initial,
                       pervasive) = 
d929 3
a931 1
        Info.wrap error_info (Info.FATAL, Info.RECOVERABLE, !error_output_level, Info.Location.FILE filename)
d939 1
a939 1
	    (cache, require_list, require_table, dir,
d942 2
a943 2
 	  val _ = diagnostic (2, fn _ => ["do_subrequires of ", filename, " ",
					  FileName.dir_string dir, ", ", name])
d948 1
a948 1
				      dir, mod_path, cons)
d951 5
a955 12
	      val (mo, _, mo_mod_path) =
		case FileName.find_mo
		       (mod_path,
			ModuleId.from_string
			  (name, Info.Location.FILE filename),
			dir)
		of FileName.Option.PRESENT x => x
		|  FileName.Option.ABSENT =>
                  Info.error'
                    error_info
                    (Info.FATAL, Info.Location.FILE filename,
                     implode ["Required mo `", name, "' does not exist"])
d962 1
a962 1
                        Encapsulate.input_info mo
d975 3
a977 4
                               (cache,
                                require_list, require_table,
				dir,
				mo_mod_path,
d993 1
a993 1
               dir, mod_path, cons)
d1007 5
a1011 5
      fun compile_topdec(arg as (cache, dir, mod_path, require_list, require_table,
				 cb1 as CB(p, t, c),
				 cb2 as CB(p', t', c'), parse, eof,
				 counters as (tynames, strnames, tyfuns),debug_info,
				 had_topdec)) =
d1036 5
a1040 17
			     (2, fn _ => ["requireDec `",
					  FileName.dir_string dir, ", ",
					  root, "'"])

		   val (mo, mo_stamp, mo_mod_path) =
		     case FileName.find_mo (mod_path, sub_module_id, dir)
		     of FileName.Option.PRESENT x => x
		     |  FileName.Option.ABSENT =>
                       Info.error'
                         error_info
                         (Info.FATAL, Info.Location.FILE filename,
                          implode ["Required mo `", root, "' does not exist"])

 		   val _ = diagnostic (2, fn _ => ["found mo: ", mo])
		   val _ = diagnostic
			     (2, fn _ => ["mo_mod_path: ",
					  ModuleId.path_string mo_mod_path]);
d1042 4
d1052 1
a1052 1
		      Encapsulate.input_all mo
d1055 1
d1065 2
a1066 2
		     (cache, require_list, require_table, dir,
		      mo_mod_path, cons)
d1119 3
a1121 2
                 compile_topdec(cache, dir, mod_path, require_list, require_table,
				cb1, cb2, parse, eof, counters,debug_info, true))
d1197 1
a1197 1
      fun compile_topdecs' (cache, dir, mod_path, require_list, require_table, reqs, code,
d1204 4
a1207 2
            compile_topdec (cache, dir, mod_path, require_list, require_table, initial_cb,
			    compiled_cb, parse, eof, counters, debug_info, had_topdec)
d1214 2
a1215 1
            (cache, require_list, require_table, reqs', code', compiled_cb', counters,debug_info)
d1217 4
a1220 3
            compile_topdecs' (cache, dir, mod_path, require_list, require_table, reqs', code',
                              augment_cb(initial_cb, req_cb),
                              compiled_cb', parse, eof, counters, debug_info, had_topdec)
d1262 7
a1268 7
		compile_topdec (cache, pervasive_library_dir, ModuleId.empty_path, [], NewMap.empty' String.<, initial,
				initial_cgb_for_normal_file,
				fn opts =>
				fn pb =>
				Parser.parse_topdec opts (options,token_stream, pb),
				fn () => Lexer.eof token_stream,
				initial_counters, empty_debug_info, false)
d1281 6
a1287 6
                               dir, mod_path, require_list, require_table, reqs_list, decls_list,
			       augment_cb(initial_cgb_for_normal_file, full_env),
			       empty_cb, parse, eof,
			       initial_counters, empty_debug_info, false)
(*
	      compile_topdecs'(cache, dir,
d1295 3
a1297 3
	    compile_topdecs'(cache, dir, mod_path, [], NewMap.empty' String.<, [], [], initial,
			     empty_cb, parse, eof, initial_counters, empty_debug_info,
			     false)
d1305 2
a1306 3
      (cache,
       require_list, reqs_list, lambda_exp', CB(pbasis, basis, top_env''),
       counters,debug_info)
d1330 2
a1331 1
                   (Info.WARNING, Info.Location.FILE name, "Compiling as the builtin library");
d1336 2
a1337 1
                   (Info.WARNING, Info.Location.FILE name, "Compiling as pervasive");
d1344 4
a1347 1
        Info.wrap error_info (Info.FATAL, Info.RECOVERABLE, !error_output_level, Info.Location.FILE filename)
d1349 1
a1349 1
      val (dir, mod_path) =
d1351 3
a1353 2
	   DIRECT => (Io.null_location, ModuleId.empty_path)
	|  FILE file => (FileName.module_dir file, ModuleId.path (FileName.module_id file))
a1371 1
	val _ = diagnostic (2, fn _ => ["dir = " ^ FileName.dir_string dir ^ "\n"]);
d1375 1
a1375 1
	  compile_program (error_info, options, cache, dir, mod_path,
d1580 2
a1581 2
           case FileName.find_file module_id
	   of FileName.Option.PRESENT f => f
@


1.167
log
@Io.get_pervasive_dir can raise Io.NotSet.
@
text
@d4 3
d552 32
a583 32
require make.unix;
require utils.crash;
require utils.print;
require utils.lists;
require utils.diagnostic;
require utils.timer;
require utils.filename;
require basics.module_id;
require parser.parser;
require typechecker.mod_rules;
require typechecker.types;
require typechecker.strenv;
require typechecker.basis;
require lambda.environ;
require lambda.lambdaprint;
require lambda.environprint;
require lambda.lambda;
require lambda.lambdasub;
require lambda.lambdaoptimiser;
require lambda.lambdamodule;
require lambda.lambdaio;
require lambda.topdecprint;
require mir.mir_cg;
require mir.mirprint;
require mir.miroptimiser;
require machine.mach_cg;
require machine.machprint;
require primitives;
require pervasives;
require encapsulate;
require io;
require toplevel;
@


1.166
log
@ModuleId.from_string now takes a location argument.
@
text
@d4 3
d1207 9
a1215 1
              val pervasive_library_dir = Io.get_pervasive_dir ()
d1220 1
@


1.165
log
@Added code to output the optimised lambda code into a file called
test.lam if the output_lambda option is enabled.  This is for use
in the COMPARE project.
@
text
@d4 5
d667 1
d909 5
a913 1
		case FileName.find_mo (mod_path, ModuleId.from_string name, dir)
d1570 3
a1572 1
	 (options, empty_cache, ModuleId.from_string module_name, false);
d1578 3
a1580 1
	 (options, empty_cache, ModuleId.from_string Io.pervasive_library_name,
@


1.164
log
@Made compiler always announce the start of a new compilation.
@
text
@d4 3
d541 32
a572 31
require "../make/unix";
require "../utils/crash";
require "../utils/print";
require "../utils/lists";
require "../utils/diagnostic";
require "../utils/timer";
require "../utils/filename";
require "../basics/module_id";
require "../parser/parser";
require "../typechecker/mod_rules";
require "../typechecker/types";
require "../typechecker/strenv";
require "../typechecker/basis";
require "../lambda/environ";
require "../lambda/lambdaprint";
require "../lambda/environprint";
require "../lambda/lambda";
require "../lambda/lambdasub";
require "../lambda/lambdaoptimiser";
require "../lambda/lambdamodule";
require "../lambda/topdecprint";
require "../mir/mir_cg";
require "../mir/mirprint";
require "../mir/miroptimiser";
require "../machine/mach_cg";
require "../machine/machprint";
require "primitives";
require "pervasives";
require "encapsulate";
require "io";
require "toplevel";
d594 1
d635 2
a636 1
    	  LambdaSub.LT
d770 1
d1380 10
@


1.163
log
@Major changes to support ModuleIds and search path.
@
text
@d4 3
d1521 1
a1521 2
       val _ = if !print_timings then
		 Print.print ("Compiling " ^ file_name ^ "\n") else ()
@


1.162
log
@Changed the way pervasive require is done to use new multiple unget
in lexer. Much simpler code as a result.
@
text
@d4 4
d18 1
a18 1
Augmented tyoe basis before passing it to trans_topdec.
d541 2
d574 1
d597 1
a597 1

d649 4
a652 1

d680 1
d683 1
a683 1
  val print_timings = ref true
a688 2
  val pervasive_library_dir = Io.pervasive_library_dir

d738 4
d830 3
a832 3
        let 
          val lv = LambdaTypes.fetch_var lv
        in
d841 1
a841 1
        end
a852 10
  fun relative_mo (path, name) =
    let
      val root = Io.root_name (Io.compilation_name name)
    in
      if Lists.member (root, Io.pervasive_names) then
	Io.mo_name(Io.relative_name(!pervasive_library_dir, root))
      else
	Io.relative_name(path, Io.mo_name name)
    end

d864 1
a864 1
                       path,
d874 3
a876 2

      fun do_subrequires options (cache, require_list, require_table, _, nil) =
d878 4
a881 2
	| do_subrequires options (cache, require_list, require_table, path,
				  (name,_) :: cons) =
d883 2
a884 1
	  val comp_name = Io.compilation_name name
d886 1
a886 1
	  case NewMap.tryApply'(require_table, comp_name) of
d888 2
a889 1
	      do_subrequires options (cache, require_list, require_table, path, cons)
d892 8
a899 1
	      val mo = relative_mo (path, name)
d902 1
a902 1
                case NewMap.tryApply' (cache, comp_name) of
d908 1
d911 1
a911 1
                          (Info.FATAL, Info.Location.FILE filename, s)
d913 1
a913 1
                      (NewMap.define (cache, comp_name, info), info)
d921 2
a922 1
				Io.compilation_path mo,
d936 3
a938 3
               (comp_name, tyname_count, strname_count, tyfun_count) :: require_list,
	       NewMap.define(require_table, comp_name, true),
               path, cons)
d952 1
a952 1
      fun compile_topdec(arg as (cache, path, require_list, require_table,
d968 1
a968 1
	    Absyn.REQUIREtopdec (s, location) =>
d979 19
a997 7
		   val root = Io.root_name s
		   val mo = relative_mo (path, root)
		   val mo_stamp =
		     case Unix.mtime mo of
		       Unix.EXISTS mo_stamp => mo_stamp
		     | Unix.NOT_EXIST =>
			 Info.error' error_info (Info.FATAL, location, implode ["Required mo `", mo, "' does not exist"])
d999 2
a1000 1
		   val {parser_env, type_env=t_env, lambda_env, consistency, tynames, strnames, tyfuns} =
d1017 2
a1018 1
		     (cache, require_list, require_table, Io.compilation_path mo, cons)
a1026 2
		   val root_name = Io.compilation_name root

d1031 1
a1031 1
		  (root_name, tyname_count, strname_count, tyfun_count) ::
d1036 1
a1036 1
		     case NewMap.tryApply'(require_table, root_name) of
d1039 2
a1040 2
			 (NewMap.define(require_table, root_name, true),
			  (root_name, tyname_count, strname_count, tyfun_count) ::
d1048 1
a1048 1
				 (t_env, root_name, require_list))
d1059 1
a1059 1
				      LambdaTypes.SCON(Ident.STRING(Io.compilation_name name)),
d1071 1
a1071 1
                 compile_topdec(cache, path, require_list, require_table,
d1148 1
a1148 1
      fun compile_topdecs' (cache, path, require_list, require_table, reqs, code,
d1155 1
a1155 1
            compile_topdec (cache, path, require_list, require_table, initial_cb,
d1165 1
a1165 1
            compile_topdecs' (cache, path, require_list, require_table, reqs', code',
a1182 1
(*
d1184 2
d1188 1
a1188 3
		"require \"" ^
                Io.relative_name(!pervasive_library_dir, Io.pervasive_library_name) ^
                "\" ; "(*^ "open FullPervasiveLibrary_ "*)
d1197 1
d1200 1
a1200 1
		compile_topdec (cache, path, [], NewMap.empty' String.<, initial,
d1207 1
a1207 2

*)
d1210 1
a1210 2
		 Token.STRING(Io.relative_name(!pervasive_library_dir,
					       Io.pervasive_library_name)),
d1216 2
a1218 1
(*
d1220 1
a1220 1
                               path, require_list, require_table, reqs_list, decls_list,
d1224 3
a1226 3
*)
	      compile_topdecs'(cache,
                               path, [], NewMap.empty' String.<, [], [],
d1230 1
d1233 1
a1233 1
	    compile_topdecs'(cache, path, [], NewMap.empty' String.<, [], [], initial,
d1248 1
a1248 1
  datatype source = FILE of string | DIRECT
d1255 1
a1255 1
                cache, input_fn, source) =
d1257 1
a1257 1
      val (initial_cb, pervasive, builtin, filename) =
d1259 2
a1260 2
          DIRECT => (initial_cgb_for_normal_file, false, false, "direct input")
        | FILE name =>
d1262 2
a1263 1
              val root = Io.root_name (Io.compilation_name name)
d1265 11
a1275 10
              if root = Io.builtin_library_name then 
                (Info.error
                 error_info
                 (Info.WARNING, Info.Location.FILE name, "Compiling as the builtin library");
                 (initial_cb_for_builtin_library, true, true, name))
              else if Lists.member (root, Io.pervasive_names) then
                (Info.error
                 error_info
                 (Info.WARNING, Info.Location.FILE name, "Compiling as pervasive");
                 (initial_cgb_for_normal_file, true, false, name))
d1277 1
a1277 1
                (initial_cgb_for_normal_file, false, false, name)
d1283 4
d1305 1
d1309 2
a1310 2
	  compile_program (error_info,options,cache,Io.compilation_path filename, ts, initial_cb, pervasive)

d1315 1
a1315 1
	      (case Unix.mtime name of
d1322 2
a1323 1
	  | FILE name => (Io.compilation_name name, sec_time) :: requires
d1478 1
a1478 1
		     {filename = Io.mo_name (case source of FILE name => name | DIRECT => "test"),
d1495 1
a1495 1
  fun compile_file' error_info (options, cache, filename) =
d1500 21
a1520 3
       val sml_name = Io.sml_name filename
       val _ = diagnose_simple ("Compiling " ^ sml_name ^ " at debugging level " ^ MLWorks.Integer.makestring(!debug_level))
       val _ = if !print_timings then Print.print ("Compiling " ^ sml_name ^ "\n") else ()
d1522 1
a1522 1
         open_in sml_name
d1524 5
a1528 1
           Info.error' error_info (Info.FATAL, Info.Location.UNKNOWN, "Io error in compile_file: " ^ s)
d1530 2
a1531 1
         do_input (error_info,options,cache, fn _ => input(instream, 4096), FILE sml_name)
d1538 5
a1542 2
  fun compile_file error_info options filename =
    (compile_file' error_info (options, empty_cache, filename); ())
d1544 7
d1559 3
a1561 1
	fn _ => if !done then "" else (done := true; x), DIRECT);
@


1.161
log
@Modified to disallow requires after non-require topdecs. Some modifications to ensure
rigid tynames and strnames are consistent if a file is required and subrequired
@
text
@d4 4
d666 1
d1154 1
a1168 10
(*
	      val (cache, require_list, require_table, reqs_list, decls_list,
		   full_env, _,_) =
		compile_topdecs'(cache,
                                 path, [], NewMap.empty' String.<, [], [], initial,
				 initial_cgb_for_normal_file,
				 fn opts => fn pb => Parser.parse_topdec opts (options,token_stream, pb),
				 fn () => Lexer.eof token_stream,
				 initial_counters, empty_debug_info, false)
*)
d1179 10
d1190 1
d1194 6
@


1.160
log
@Debugger Environments for local and closure variable inspection
in the debugger;
structure Option.
@
text
@d4 5
d835 10
a866 10
      fun relative_mo (path, name) =
	let
	  val root = Io.root_name (Io.compilation_name name)
	in
	  if Lists.member (root, Io.pervasive_names) then
	    Io.mo_name(Io.relative_name(!pervasive_library_dir, root))
	  else
	    Io.relative_name(path, Io.mo_name name)
	end

d932 3
a934 2
				 cb2 as CB(p', t', c'), eof, parse,
				 counters as (tynames, strnames, tyfuns),debug_info)) =
d947 17
a963 7
              Timer.xtime
              ("Require",
               !print_timings,
               fn () =>
               let
		val root = Io.root_name s
		val mo = relative_mo (path, root)
d965 12
a976 5
                val mo_stamp =
                  case Unix.mtime mo of
                    Unix.EXISTS mo_stamp => mo_stamp
                  | Unix.NOT_EXIST =>
                      Info.error' error_info (Info.FATAL, location, implode ["Required mo `", mo, "' does not exist"])
d978 5
a982 8
		val {parser_env, type_env=t_env, lambda_env, consistency, tynames, strnames, tyfuns, ... } =
		  Timer.xtime
		  ("decoding require",
		   !print_timings andalso !print_minor_timings,
		   fn () =>
		     Encapsulate.input_all mo
                     handle Encapsulate.BadInput message =>
                       Info.error' error_info  (Info.FATAL, location, message))
d984 2
a985 4
		val ((name, _), cons) =
                  case consistency of
                    [] => Crash.impossible "Strange, no consistency info"
                  | (_, time) :: tl => ((root, time), tl)
d987 3
a989 5
		val (cache, require_list, require_table) =
                  error_wrap
		    error_info
		    do_subrequires
		    (cache, require_list, require_table, Io.compilation_path mo, cons)
d991 1
a991 2
		(* note that counters have already been bumped up by *)
		(* do_subrequires *)
d993 3
a995 6
		val tyname_count = Tyname_id.read_counter ()
		val strname_count = Strname_id.read_counter ()
		val tyfun_count = Tyfun_id.read_counter ()

		val root_name = Io.compilation_name root

d999 1
d1001 7
a1007 1
		val require_table = NewMap.define(require_table, root_name, true)
d1009 6
a1014 6
		val (t, _) =
		  Timer.xtime("decoding encapsulated type basis of size " ^
			      MLWorks.Integer.makestring(size t_env),
			      !print_timings andalso !print_minor_timings,
			      fn () => Encapsulate.decode_type_basis
			      (t_env, require_list))
d1016 3
a1018 4
(*
                val _ = Mod_Rules.set_assemblies
		  (Mod_Rules.Assemblies.new_assemblies_from_basis t)
*)
d1020 12
a1031 17
		val _ = Tyname_id.reset_counter (tyname_count + tynames)
		val _ = Strname_id.reset_counter (strname_count + strnames)
		val _ = Tyfun_id.reset_counter (tyfun_count + tyfuns)

		val (top_env, decls) =
                  LambdaModule.unpack
                  (lambda_env,
                   LambdaTypes.APP(LambdaTypes.BUILTIN
                                   Pervasives.LOAD_STRING,
                                   LambdaTypes.SCON(Ident.STRING(Io.compilation_name name)),
                                   LambdaTypes.Option.ABSENT))
	      in
		(* Later this should contain real timestamps *)
		(cache, require_list, require_table, [(name, mo_stamp)],
                 decls, CB(parser_env, t, top_env), empty_cb,
		 counters,debug_info)
	      end)
d1035 1
a1035 1
		 debug_info)
d1037 2
a1038 1
                 compile_topdec arg)
d1045 1
d1049 1
d1051 3
a1068 6
(*
		    Diagnostic.output 0
		    (fn i =>
                     ["The abstract syntax\n",
                      TopdecPrint.topdec_to_string options topdec])
*)
d1105 1
a1105 1
                 debug_info')
d1115 2
a1116 1
			    initial_cb, compiled_cb, parse, eof, counters,debug_info) = 
d1120 1
a1120 1
               counters,debug_info) =
d1122 1
a1122 1
			    compiled_cb, eof, parse, counters,debug_info)
d1133 1
a1133 1
                              compiled_cb', parse, eof, counters,debug_info)
d1154 1
a1154 1
                "\" ; "^ "open FullPervasiveLibrary_ "
d1163 1
d1165 1
a1165 1
		   full_env as CB(pbasis, basis, top_env), _,_) =
d1171 12
a1182 1
				 initial_counters,empty_debug_info)
d1186 3
a1188 2
			       full_env, empty_cb, parse, eof,
			       initial_counters,empty_debug_info)
d1192 2
a1193 1
			     empty_cb, parse, eof, initial_counters,empty_debug_info)
a1255 3
(*
	val _ = Mod_Rules.reset_assemblies ()
*)
@


1.159
log
@Augmented tyoe basis before passing it to trans_topdec.
@
text
@d4 3
d807 3
d818 1
d822 1
a822 1
        Lists.reducel check_in_set (bindings, Lists.zip(lvl, lel))
d955 1
a955 1
		val {parser_env, type_env=t_env, lambda_env, consistency, tynames, strnames, tyfuns} =
d1012 1
a1012 1
                                   LambdaTypes.null_type_annotation))
d1379 1
a1379 1
		   (fn((name,(ty,is_leaf,annotations)),_) =>
@


1.158
log
@Now passes type basis to trans_topdec.
Removed show_match and generate_debug_inhibit_warnings.
@
text
@d4 4
d1075 2
a1076 1
				  !generate_debug_information, debug_info, t)
@


1.157
log
@Changed to use new mod_rules interface. All unnecessary
assembly calculations removed
@
text
@d4 4
d586 2
a587 1
  sharing Basis.BasisTypes = Mod_Rules.Assemblies.Basistypes = Encapsulate.Basistypes
d603 1
a608 1
	  Mir_Cg.EnvironTypes =
d622 1
a622 1
  sharing type Parser.Absyn.Type = Types.Datatypes.Type = Mir_Cg.EnvironTypes.LambdaTypes.Type
d646 2
a647 1
  structure Debugger_Types = Mir_Cg.MirTypes.Debugger_Types
a649 1
  structure MirTypes = Mir_Cg.MirTypes
a730 1
  val show_match       = Lambda.show_match
a736 1
  val generate_debug_inhibit_warnings = ref false
d1070 2
a1071 1
			       (options,topdec,c,!generate_debug_information,debug_info)
d1302 1
a1302 1
		      (options, opt_lambda_exp, top_env, 
@


1.156
log
@Cleaned up after assembly changes
@
text
@d4 3
d626 2
a627 1
  structure BasisTypes = Mod_Rules.Assemblies.Basistypes
d983 1
d986 1
d1021 7
a1027 8
		val t' = Timer.xtime (
		  	   "Type-checking ",
		  	   ! print_timings,
                    	   fn () => error_wrap
				      error_info
				      Mod_Rules.check_topdec
				      (options,topdec,t)
			 )
d1212 1
d1214 1
@


1.155
log
@ Changed Info.wrap
Put filename rather than module name into tokenstream (and thence
into locations.
@
text
@d4 5
a518 1
require "../typechecker/__environment";
d579 1
a579 1
  sharing Basis.BasisTypes = Mod_Rules.Assemblies.Basistypes
a608 1
  sharing Encapsulate.Assemblies = Mod_Rules.Assemblies
a618 1
  sharing type Environment_.Datatypes.Structure = Types.Datatypes.Structure
d972 1
a972 1
		val (t, ty_ass, str_ass, _) =
d979 2
a980 24
		fun make_new_assemblies
		  (BasisTypes.BASIS
		   (_, _, _, env as
		    Datatypes.ENV(Datatypes.SE se, Datatypes.TE te, _, _))) =
		  let
		    fun new_str((str_ass, ty_ass), _, str) =
		      let
			val (m, env) = case Environment_.expand_str str of
			  Datatypes.STR(m, _, env) => (m, env)
			| _ => Crash.impossible"Expanded str is not STR"
			val (str_ass', ty_ass') =
			  Encapsulate.Assemblies.newAssemblies(m, env)
		      in
			(Encapsulate.Assemblies.unionStrAssembly(str_ass, str_ass'),
			 Encapsulate.Assemblies.unionTypeAssembly(ty_ass, ty_ass'))
		      end
		  in
		    NewMap.fold
		    new_str
		    ((Encapsulate.Assemblies.empty_strassembly(),
		      Encapsulate.Assemblies.newTypeAssembly
		      (env, Encapsulate.Assemblies.empty_tyassembly)),
		     se)
		  end
a981 5
(*
                val _ = Mod_Rules.set_assemblies (str_ass, ty_ass)
*)
                val _ = Mod_Rules.set_assemblies(make_new_assemblies t)

a1382 6
(*
		       type_assembly = !Mod_Rules.ty_ass,
		       str_assembly = !Mod_Rules.str_ass, 
*)
		       type_assembly = Encapsulate.Assemblies.empty_tyassembly,
		       str_assembly = Encapsulate.Assemblies.empty_strassembly(),
@


1.154
log
@Stopped encapsulating and decapsulating assemblies
@
text
@d4 3
a648 2
  fun error_wrap error_info =
    Info.wrap error_info (Info.FATAL, Info.RECOVERABLE, !error_output_level)
d828 4
d1212 3
d1217 1
a1217 3
      val module_name = Io.sml_name(Io.compilation_name filename)

      val ts = Lexer.mkTokenStream (input_fn, module_name)
d1317 1
a1317 1
		       module_name, debug_information)
@


1.153
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
d511 1
d612 2
d972 26
d999 2
d1402 6
a1407 1
		       type_assembly = !Mod_Rules.ty_ass, str_assembly = !Mod_Rules.str_ass, 
@


1.152
log
@Removed integer parameter
@
text
@d4 3
d568 1
a568 1
  sharing Basis.BasisTypes = Mod_Rules.BasisTypes = Encapsulate.BasisTypes
d575 1
a575 1
  sharing Parser.Absyn.Set = Mod_Rules.BasisTypes.Set
a579 1
  sharing Mod_Rules.BasisTypes = Encapsulate.BasisTypes
d612 1
a612 1
  structure BasisTypes = Mod_Rules.BasisTypes
@


1.151
log
@Fixed bug whereby counters were pushed after resetting them, instead of before
@
text
@d4 3
a496 1
require "../utils/integer";
a527 1
  structure Integer : INTEGER
d959 1
a959 1
			      Integer.makestring(size t_env),
d1188 2
a1189 2
	val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
	val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n"])
d1245 1
a1245 1
				 Integer.makestring (LambdaSub.size_of_expr opt_lambda_exp))
d1345 1
a1345 1
				       output(std_out,"  " ^ Integer.makestring x ^ "  " ^ 
d1387 1
a1387 1
       val _ = diagnose_simple ("Compiling " ^ sml_name ^ " at debugging level " ^ Integer.makestring(!debug_level))
@


1.150
log
@Changes to lambda optimiser to allow removal of inlining for tracing
@
text
@d4 3
d1176 1
a1179 1
      val _ = Datatypes.push_counters()
@


1.149
log
@Added pop_counters to normal exit for compilation
@
text
@d4 3
d1228 1
a1228 1
                      fn () => LambdaOptimiser.optimise print_options lambda_exp)
@


1.148
log
@Removed the Lists.exists test in favour of a map for subrequired files
@
text
@d4 3
d1096 1
a1096 1
                "\" ; open FullPervasiveLibrary_ "
d1352 1
a1352 1
      in
d1363 4
a1366 1
		       cache))
@


1.147
log
@Changed some print_timings to print_minor_timings and defaulted
print_minor_timings to false.
@
text
@d4 4
d819 4
a822 2
      fun do_subrequires options (cache, require_list, _, nil) = (cache, require_list)
	| do_subrequires options (cache, require_list, path, (name,_) :: cons) =
d826 4
a829 3
	  if Lists.exists (fn (n, _, _, _) => n = comp_name) require_list then
	    do_subrequires options (cache, require_list, path, cons)
	  else
d848 1
a848 1
	      val (cache, require_list) =
d851 1
a851 1
                                require_list,
d867 1
d882 2
a883 1
      fun compile_topdec(arg as (cache, path, require_list, cb1 as CB(p, t, c),
d926 1
a926 1
		val (cache, require_list) =
d930 1
a930 1
		    (cache, require_list, Io.compilation_path mo, cons)
d939 2
d942 1
a942 1
		  (Io.compilation_name root, tyname_count, strname_count, tyfun_count) ::
d945 2
d969 1
a969 1
		(cache, require_list, [(name, mo_stamp)],
d975 2
a976 1
		(cache, require_list, [], [], empty_cb, empty_cb, counters,debug_info)
d1041 1
a1041 1
		(cache, require_list, [],
d1054 2
a1055 2
      fun compile_topdecs' (cache, path, require_list, reqs, code, initial_cb,
                            compiled_cb, parse, eof, counters,debug_info) = 
d1057 1
a1057 1
          val (cache, require_list, requires,
d1060 2
a1061 2
            compile_topdec (cache, path, require_list, initial_cb, compiled_cb,
                            eof, parse, counters,debug_info)
d1068 1
a1068 1
            (cache, require_list, reqs', code', compiled_cb', counters,debug_info)
d1070 1
a1070 1
            compile_topdecs' (cache, path, require_list, reqs', code',
d1080 1
a1080 1
      val (cache, require_list, reqs_list, decls_list, CB(pbasis, basis, top_env),
d1083 2
a1084 1
          (cache, [], [], [], empty_cb, initial_counters,empty_debug_info)
d1102 1
a1102 1
	      val (cache, require_list, reqs_list, decls_list,
d1105 1
a1105 1
                                 path, [], [], [], initial,
d1112 1
a1112 1
                               path, require_list, reqs_list, decls_list,
d1117 2
a1118 2
	    compile_topdecs'(cache, path, [], [], [], initial, empty_cb, parse, eof,
			     initial_counters,empty_debug_info)
@


1.146
log
@Exposed lambda optimisation switches
@
text
@d4 3
d620 1
a620 1
  val print_minor_timings = ref true
d683 4
a686 2
    ("augment_cb", !print_timings,
     fn () => CB (Parser.augment_pB (p, p'), Basis.basis_circle_plus_basis(t, t'), Environ.augment_top_env(c, c')))
d866 3
a868 1
        fn x => Timer.xtime("do_subrequires", !print_timings, (fn () => do_subrequires options x))
d889 5
a893 1
	      let
d959 1
a959 1
	      end
d986 1
a986 1
			  !print_timings,
d1205 3
a1207 1
	  Timer.xtime("LambdaOptimiser", !print_timings, fn () => LambdaOptimiser.optimise print_options lambda_exp)
@


1.145
log
@Made separate compilation push and pop the relevant counters from simple types
round the compilation, thus not affecting the interpreter
@
text
@d4 4
d693 2
@


1.144
log
@Options changes
Signature revisions
@
text
@d4 4
d1138 7
a1144 5
  
      val _ = Diagnostic.output 3 (fn _ => ["Cleaning refs in initial basis"])
      val _ = Encapsulate.clean_basis Basis.initial_basis
      (* Set all refs for encoding back to zero *)
      val _ = Diagnostic.output 3 (fn _ => ["Cleaned refs in initial basis"])
d1146 3
a1148 3
      val _ = Diagnostic.output 3 (fn _ => ["Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
      val _ = Diagnostic.output 3 (fn _ => ["Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n"])
      val _ = Mod_Rules.reset_assemblies ()
d1150 4
a1153 4
      val (cache, require_list, requires, lambda_exp, 
	   cb' as CB(parser_env, type_basis, top_env),
	   (tyname_count, strname_count, tyfun_count),debug_information) =
	compile_program (error_info,options,cache,Io.compilation_path filename, ts, initial_cb, pervasive)
d1155 7
a1161 7
      val sec_time = 
        case source of
          DIRECT => MLWorks.Time.Real.zero
        | FILE name =>
            (case Unix.mtime name of
               Unix.EXISTS i => i
             | _ => Crash.impossible ("File `" ^ filename ^ "' no longer exists"))
d1163 4
a1166 4
      val requires = 
        case source of
          DIRECT => requires
        | FILE name => (Io.compilation_name name, sec_time) :: requires
d1168 9
a1176 14
      val _ =
	if (#show_lambda listing_options orelse !show_lambda) then
(*
	  Diagnostic.output_fn 0
	  (fn (i,strm) => (output (strm, "The lambda code\n");
			   LambdaPrint.output_lambda print_options (strm,lambda_exp)))
*)
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The unoptimised lambda code\n"));
	   Info.listing_fn error_info
	   (3, fn stream =>
	    LambdaPrint.output_lambda print_options (stream, lambda_exp)))
	else ()
d1178 7
a1184 7
      val _ =
	if !do_check_bindings then
	  (Print.print"Checking bindings from lambda translator\n";
	   check_bindings lambda_exp;
	   Print.print"Checked bindings from lambda translator\n")
	else
	  ()
d1186 1
a1186 1
      val opt_lambda_exp =
d1192 7
a1198 7
      val _ =
	if !do_check_bindings then
	  (Print.print"Checking bindings from lambda optimiser\n";
	   check_bindings opt_lambda_exp;
	   Print.print"Checked bindings from lambda optimiser\n")
	else
	  ()
d1200 11
a1210 16
      val _ = diagnose_simple ("Lambda optimisation complete, final size of expression = " ^
                               Integer.makestring (LambdaSub.size_of_expr opt_lambda_exp))
      val _ =
	if (#show_opt_lambda listing_options orelse !show_opt_lambda) then
(*
	  Diagnostic.output_fn 0
	  (fn (i,strm) => (output (strm, "The optimised lambda code\n");
			   LambdaPrint.output_lambda print_options (strm,opt_lambda_exp)))
*)
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The optimised lambda code\n"));
	   Info.listing_fn error_info
	   (3, fn stream =>
	    LambdaPrint.output_lambda print_options (stream, opt_lambda_exp)))
	else ()
d1212 11
a1222 17
      val _ =
	if (#show_environ listing_options orelse !show_environ) then
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The environment\n"));
	   Info.listing_fn error_info
	   (3, EnvironPrint.printtopenv print_options top_env);
	   Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "\n")))
(*
	  Diagnostic.output 0
	  (fn i =>
	   ["The environment\n",
	    EnvironPrint.printtopenv print_options top_env])
*)
	else ()
d1224 9
a1232 9
      val (the_mir_code,debugger_information) = 
        Timer.xtime("Mir_Cg",
	            ! print_timings,
                    fn () => error_wrap
			       error_info
			       Mir_Cg.mir_cg
			       (options, opt_lambda_exp, top_env, 
                                module_name, debug_information)
		   )
d1234 1
a1234 1
      val _ = diagnose_simple"Mir translation complete"
d1236 11
a1246 19
      val _ =
	if (#show_mir listing_options orelse !show_mir) then
(*
	  Diagnostic.output 0
	  (fn i =>
	   ["The unoptimised intermediate code\n",
	    MirPrint.string_mir_code the_mir_code])
	  (Print.print"The unoptimised intermediate code\n";
	   MirPrint.print_mir_code the_mir_code)
*)
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The unoptimised intermediate code\n"));
	   Info.listing_fn error_info (3, MirPrint.print_mir_code the_mir_code))
	else
	  ()
      val the_optimised_code = 
	Timer.xtime("MirOptimiser", ! print_timings,
                    fn () => MirOptimiser.optimise the_mir_code);
d1248 9
a1256 17
      val _ = diagnose_simple"Mir optimisation complete"
      val _ =
	if #show_opt_mir listing_options orelse !show_opt_mir then
(*
	  Diagnostic.output 0
	  (fn i =>
	   ["The optimised intermediate code\n",
	    MirPrint.string_mir_code the_optimised_code])
	  (Print.print"The optimised intermediate code\n";
	   MirPrint.print_mir_code the_optimised_code)
*)
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The optimised intermediate code\n"));
	   Info.listing_fn error_info (3, MirPrint.print_mir_code the_optimised_code))
	else
	  ()
d1258 1
a1258 28
      val ((the_machine_code,debugger_information), code_list_list) =
	let
	  val assign = MirOptimiser.machine_register_assignments
	in
          Timer.xtime("Mach_Cg",
		      ! print_timings,
                      fn () => error_wrap
				 error_info
				 Mach_Cg.mach_cg
				 (options, the_optimised_code,
                                  (#gc assign, #non_gc assign, #fp assign),
                                  debugger_information)
		     )
	end

      val _ = diagnose_simple"Machine code translation complete"

      val _ =
	if #show_mach listing_options orelse !show_mach then
	  (Info.listing_fn
	   error_info
	   (3, fn stream => output(stream, "The final machine code\n"));
	   Info.listing_fn error_info (3, MachPrint.print_mach_code code_list_list))
	else
	  ()

      val _ =
        if !print_generated_debug_information then
d1260 1
a1260 2
            val Debugger_Types.INFO i = debugger_information
	    val info = NewMap.to_list i
d1262 9
a1270 15
	    case info of
	      [] => ()
	    | _ => 
                (Print.print "Generated debug information\n";
                 Lists.reducer
                 (fn((name,(ty,is_leaf,annotations)),_) =>
                  (output(std_out,name ^ " : " ^ Debugger_Types.print_type ty ^ " ");
                   (if is_leaf then
		      output(std_out,"leaf\n")
		    else output(std_out,"not leaf\n"));
		      Lists.reducer (fn ((x,y),_) =>
				     output(std_out,"  " ^ Integer.makestring x ^ "  " ^ 
					    Debugger_Types.print_backend_annotation y ^ "\n")) 
                   (annotations,())))
                 (info,()))
a1271 1
        else ()
d1273 1
a1273 6
      val top_env =
        if builtin then
	  (Print.print "*** Changing top level environment\n";
           after_builtin_cgb)
        else
          top_env     
d1275 56
a1330 12
    in
      Timer.xtime("Outputting", !print_timings,
      fn () =>
      (Encapsulate.output_file
       {filename = Io.mo_name (case source of FILE name => name | DIRECT => "test"),
        code = the_machine_code, parser_env = parser_env,
        type_basis = type_basis, debug_info = debugger_information,
        type_assembly = !Mod_Rules.ty_ass, str_assembly = !Mod_Rules.str_ass, 
        require_list = require_list, lambda_env = top_env,
        tynames = tyname_count, strnames = strname_count, tyfuns = tyfun_count,
        consistency = requires};
       cache))
@


1.143
log
@Options & Info changes
@
text
@d4 3
d536 2
a537 1
          Parser.Options
a542 1
          Mir_Cg.EnvironTypes.LambdaTypes.Datatypes =
d568 1
a568 1
	  Mach_Cg.Sparc_Assembly.MirTypes =
a570 2
  sharing Mach_Cg.Sparc_Assembly.Sparc_Opcodes.MachTypes = Encapsulate.MachTypes
  sharing Mach_Cg.Sparc_Assembly = MachPrint.Sparc_Assembly
d572 2
d575 3
a577 1
  sharing type Parser.Absyn.Type = Types.Datatypes.Type
d604 3
d779 3
a781 3
                       options as Options.OPTIONS(Options.LISTINGOPTIONS listing_options,
                                                  compiler_options,
                                                  print_options),
d960 1
a960 1
				      (print_options,topdec,t)
d1001 1
a1001 1
			       (print_options,topdec,c,!generate_debug_information,debug_info)
d1043 1
a1043 1
      fun parse error_info pb = Parser.parse_topdec error_info (print_options,ts, pb)
d1071 1
a1071 1
				 fn opts => fn pb => Parser.parse_topdec opts (print_options,token_stream, pb),
d1098 4
a1101 3
                options as Options.OPTIONS(Options.LISTINGOPTIONS listing_options,
                                           compiler_options,
                                           print_options),
d1240 1
a1240 1
			       (compiler_options, opt_lambda_exp, top_env, 
d1293 1
a1293 1
				 (compiler_options, the_optimised_code,
d1322 1
a1322 1
                  (output(std_out,name ^ " : " ^ Types.debug_print_type ty ^ " ");
@


1.142
log
@Typechecker structure changes
@
text
@d4 3
d526 10
a535 8
  sharing Parser.Lexer.Info =
	  Mod_Rules.BasisTypes.Info =
	  Lambda.Info =
	  Mir_Cg.MirTypes.Debugger_Types.Info =
	  EnvironPrint.Info =
	  LambdaPrint.Info =
	  LambdaOptimiser.Info =
	  TopdecPrint.Info
a537 1
	  Parser.Absyn.Datatypes =
d571 3
d596 1
a603 2
  val default_compiler_options = MirTypes.default_options

d605 2
a606 2
  fun error_wrap options =
    Info.wrap options (Info.FATAL, Info.RECOVERABLE, !error_output_level)
d770 9
a778 1
  fun compile_program (compiler_options, cache,path, ts, initial, pervasive) = 
a780 2
      val MirTypes.OPTIONS{list_opts = MirTypes.BELO list_opts, info_opts = options, ...} =
	compiler_options
d858 1
a858 1
	      (fn () => error_wrap options parse parse_env)
d872 1
a872 1
                      Info.error' options (Info.FATAL, location, implode ["Required mo `", mo, "' does not exist"])
d881 1
a881 1
                       Info.error' options  (Info.FATAL, location, message))
d890 1
a890 1
		    options
d950 1
a950 1
				      options
d952 1
a952 1
				      (topdec,t)
d961 1
a961 1
		  if (#show_absyn list_opts orelse !show_absyn) then
d969 1
a969 1
		     options
d972 1
a972 1
		     options
d974 1
a974 1
		      output(stream, TopdecPrint.topdec_to_string options topdec));
d976 1
a976 1
		     options
d991 1
a991 1
			       options
d993 1
a993 1
			       (topdec,c,!generate_debug_information,debug_info)
d1035 1
a1035 1
      fun parse options pb = Parser.parse_topdec options (ts, pb)
d1063 1
a1063 1
				 fn opts => fn pb => Parser.parse_topdec opts (token_stream, pb),
d1089 5
a1093 1
  fun do_input (info_opts, compiler_opts, cache, input_fn, source) =
a1094 1
      val MirTypes.OPTIONS{list_opts = MirTypes.BELO list_opts, ...} = compiler_opts
d1104 1
a1104 1
                 info_opts
d1109 1
a1109 1
                 info_opts
d1138 1
a1138 1
	compile_program (compiler_opts,cache,Io.compilation_path filename, ts, initial_cb, pervasive)
d1154 1
a1154 1
	if (#show_lambda list_opts orelse !show_lambda) then
d1158 1
a1158 1
			   LambdaPrint.output_lambda info_opts (strm,lambda_exp)))
d1161 1
a1161 1
	   info_opts
d1163 1
a1163 1
	   Info.listing_fn info_opts
d1165 1
a1165 1
	    LambdaPrint.output_lambda info_opts (stream, lambda_exp)))
d1178 1
a1178 1
	  Timer.xtime("LambdaOptimiser", !print_timings, fn () => LambdaOptimiser.optimise info_opts lambda_exp)
d1193 1
a1193 1
	if (#show_opt_lambda list_opts orelse !show_opt_lambda) then
d1197 1
a1197 1
			   LambdaPrint.output_lambda info_opts (strm,opt_lambda_exp)))
d1200 1
a1200 1
	   info_opts
d1202 1
a1202 1
	   Info.listing_fn info_opts
d1204 1
a1204 1
	    LambdaPrint.output_lambda info_opts (stream, opt_lambda_exp)))
d1208 1
a1208 1
	if (#show_environ list_opts orelse !show_environ) then
d1210 1
a1210 1
	   info_opts
d1212 2
a1213 2
	   Info.listing_fn info_opts
	   (3, EnvironPrint.printtopenv info_opts top_env);
d1215 1
a1215 1
	   info_opts
d1221 1
a1221 1
	    EnvironPrint.printtopenv info_opts top_env])
d1229 1
a1229 1
			       info_opts
d1231 1
a1231 1
			       (compiler_opts, opt_lambda_exp, top_env, 
d1238 1
a1238 1
	if (#show_mir list_opts orelse !show_mir) then
d1248 1
a1248 1
	   info_opts
d1250 1
a1250 1
	   Info.listing_fn info_opts (3, MirPrint.print_mir_code the_mir_code))
d1259 1
a1259 1
	if #show_opt_mir list_opts orelse !show_opt_mir then
d1269 1
a1269 1
	   info_opts
d1271 1
a1271 1
	   Info.listing_fn info_opts (3, MirPrint.print_mir_code the_optimised_code))
d1282 1
a1282 1
				 info_opts
d1284 1
a1284 1
				 (compiler_opts, the_optimised_code,
d1293 1
a1293 1
	if #show_mach list_opts orelse !show_mach then
d1295 1
a1295 1
	   info_opts
d1297 1
a1297 1
	   Info.listing_fn info_opts (3, MachPrint.print_mach_code code_list_list))
d1347 1
a1347 1
  fun compile_file' info_opts (compiler_opts, cache, filename) =
d1358 1
a1358 1
           Info.error' info_opts (Info.FATAL, Info.Location.UNKNOWN, "Io error in compile_file: " ^ s)
d1360 1
a1360 1
         do_input (info_opts,compiler_opts,cache, fn _ => input(instream, 4096), FILE sml_name)
d1367 2
a1368 2
  fun compile_file info_opts compiler_opts filename =
    (compile_file' info_opts (compiler_opts, empty_cache, filename); ())
d1376 1
a1376 1
	default_compiler_options,
@


1.141
log
@Changed sharing.
@
text
@d4 3
d472 1
a472 1
require "../typechecker/valenv";
d502 1
a504 1
  structure Valenv : VALENV
d524 1
a524 1
	  Mod_Rules.Basis.Sigenv.Sigma.Nameset.Info =
d531 2
a532 1
  sharing Mod_Rules.Basis.Tyvarenv.Datatypes =
d534 1
a534 1
          Valenv.Datatypes = Strenv.Datatypes =
d540 1
a540 1
  sharing Parser.Absyn.Set = Mod_Rules.Basis.Set
d545 1
a545 1
  sharing Mod_Rules.Basis = Encapsulate.Basis
d573 1
a573 1
  structure Basis = Mod_Rules.Basis
a587 5
  structure Funenv = Basis.Funenv
  structure Sigenv = Basis.Sigenv
  structure Sigma = Sigenv.Sigma
  structure Nameset = Sigma.Nameset
  structure Phi = Funenv.Phi
d605 1
a605 1
    CB of (Parser.ParserBasis * Basis.Basis * EnvironTypes.Top_Env)
@


1.140
log
@Changed explicit definition of default compiler options to refer to new one
in MirTypes
@
text
@d4 4
d530 1
a530 1
          Valenv.Datatypes =
@


1.139
log
@Modified to use Info.listing_fn for code printing etc
@
text
@d4 3
d593 1
a593 22
  val default_compiler_options =
    MirTypes.OPTIONS {
      info_opts = Info.default_options,
      list_opts =
	MirTypes.BELO {
	  show_absyn = false,
	  show_lambda = false,
	  show_match = false,
          show_opt_lambda = false,
          show_environ = false,
          show_mir = false,
          show_opt_mir = false,
          show_mach = false
	  },
      debug = false,
      debug_warnings = false,
      profile = false,
      trace = false,
      opt_leaf_fns = true,
      opt_tail_calls = true,
      opt_self_calls = true
    }
@


1.138
log
@Changed debug info to have only module name - needed to pass module table through to window stuff
@
text
@d4 3
d475 1
d506 1
a524 1
          Mach_Cg.MirTypes.Debugger_Types.Datatypes =
d526 1
a526 1
  sharing Mach_Cg.MirTypes.Debugger_Types =
d550 1
a550 1
	  Mach_Cg.MirTypes =
d553 2
a554 1
  sharing Mach_Cg.MachTypes = Encapsulate.MachTypes
d593 11
d684 1
d779 1
a779 1
  fun compile_program (options, cache,path, ts, initial, pervasive) = 
d782 2
d964 2
a965 1
		  if (!show_absyn) then
d970 12
a1078 7
(*
      val (top_env', lambda_exp) =
	Timer.xtime("Completing struct from topenv", 
                    ! print_timings andalso ! print_minor_timings,
                    fn () => Lambda.complete_struct_from_topenv (top_env, decls_list))
*)

d1094 1
d1138 1
a1138 1
	compile_program (info_opts,cache,Io.compilation_path filename, ts, initial_cb, pervasive)
d1154 2
a1155 1
	if (!show_lambda) then
d1159 7
d1193 2
a1194 1
	if (!show_opt_lambda) then
d1198 7
d1208 10
a1217 1
	if (!show_environ) then
d1222 1
d1238 2
a1239 1
	if (!show_mir) then
d1243 8
a1250 1
	    MirPrint.print_mir_code the_mir_code])
d1259 2
a1260 1
	if !show_opt_mir then
d1264 8
a1271 1
	    MirPrint.print_mir_code the_optimised_code])
d1275 1
a1275 1
      val (the_machine_code,debugger_information) =
d1290 12
a1301 1
      val _ = 
a1330 2

      val _ = diagnose_simple"Machine code translation complete"
@


1.137
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d1092 3
a1094 1
      val ts = Lexer.mkTokenStream (input_fn, filename)
d1180 1
a1180 1
                                filename, debug_information)
@


1.136
log
@Set the initial start up flags to compile small code at maximum speed
@
text
@d4 3
d508 1
a508 1
	  Mir_Cg.MirTypes.Info =
a521 2
  sharing Parser.Absyn.IdentClass =
    	  Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
@


1.135
log
@Options weren't being passed by error_wrap; now they are.
@
text
@d4 3
d584 1
a584 1
      debug = true,
d586 2
a587 2
      profile = true,
      trace = true,
@


1.134
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d4 3
d591 2
a592 1
  val error_wrap = Info.wrap Info.default_options (Info.FATAL, Info.RECOVERABLE, !error_output_level)
d832 5
a836 1
            Timer.xtime("Parsing", !print_timings, (fn () => error_wrap parse parse_env))
d866 4
a869 1
                  error_wrap do_subrequires (cache, require_list, Io.compilation_path mo, cons)
d923 14
a936 5
		val t' = Timer.xtime ("Type-checking ", ! print_timings,
                                      fn () => error_wrap Mod_Rules.check_topdec (topdec,t))

		val _ = Timer.xtime ("reducing strname chains", !print_timings,
                                     fn () => Basis.reduce_chains t')
d951 8
a958 2
                  Timer.xtime("Lambda translation", ! print_timings,
                              fn () => error_wrap Lambda.trans_top_dec (topdec,c,!generate_debug_information,debug_info))
d1168 1
d1205 1
@


1.133
log
@Modified to remove redundant info signatures
@
text
@d4 3
d499 1
a499 2
	  Mir_Cg.Info =
	  Mach_Cg.Info =
d568 1
a573 1
  val force_non_leaf = Mach_Cg.force_non_leaf
d575 11
a656 1
  val show_mach        = Mach_Cg.show_mach
d659 1
a659 1
  val generate_profiling = Mir_Cg.generate_profiling
d662 4
a665 1
  val generate_debug_inhibit_warnings = Mir_Cg.generate_debug_inhibit_warnings
d675 2
a676 2
          Mir_Cg.generate_self_call_optimisation := true;
          Mir_Cg.generate_tail_optimisation := true)
d680 2
a681 2
          Mir_Cg.generate_self_call_optimisation := true;
          Mir_Cg.generate_tail_optimisation := true)
d685 2
a686 2
          Mir_Cg.generate_self_call_optimisation := true;
          Mir_Cg.generate_tail_optimisation := false)
d690 2
a691 2
          Mir_Cg.generate_self_call_optimisation := false;
          Mir_Cg.generate_tail_optimisation := false)
d695 2
a696 2
          Mir_Cg.generate_self_call_optimisation := false;
          Mir_Cg.generate_tail_optimisation := false)
d1034 1
a1034 1
  fun do_input (options,cache, input_fn, source) =
d1045 1
a1045 1
                 options
d1050 1
a1050 1
                 options
d1077 1
a1077 1
	compile_program (options,cache,Io.compilation_path filename, ts, initial_cb, pervasive)
d1096 1
a1096 1
			   LambdaPrint.output_lambda options (strm,lambda_exp)))
d1109 1
a1109 1
	  Timer.xtime("LambdaOptimiser", !print_timings, fn () => LambdaOptimiser.optimise options lambda_exp)
d1127 1
a1127 1
			   LambdaPrint.output_lambda options (strm,opt_lambda_exp)))
d1135 1
a1135 1
	    EnvironPrint.printtopenv options top_env])
d1139 7
a1145 5
        Timer.xtime("Mir_Cg", ! print_timings,
                    fn () => error_wrap Mir_Cg.mir_cg (opt_lambda_exp, top_env, 
                                                       filename,
                                                       debug_information,
                                                       !generate_debug_information))
d1175 8
a1182 7
          Timer.xtime("Mach_Cg",! print_timings,
                      fn () => error_wrap Mach_Cg.mach_cg(the_optimised_code,
                                                          (#gc assign,
                                                           #non_gc assign,
                                                           #fp assign),
                                                          !generate_debug_information,
                                                          debugger_information))
d1233 1
a1233 1
  fun compile_file' options (cache, filename) =
d1244 1
a1244 1
           Info.error' options (Info.FATAL, Info.Location.UNKNOWN, "Io error in compile_file: " ^ s)
d1246 1
a1246 1
         do_input (options,cache, fn _ => input(instream, 4096), FILE sml_name)
d1253 2
a1254 2
  fun compile_file options filename =
    (compile_file' options (empty_cache, filename); ())
d1262 1
@


1.132
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d494 1
a494 1
	  Mod_Rules.Info =
@


1.131
log
@Changed error messages
@
text
@d4 3
d489 18
a506 7
  sharing Parser.Lexer.Info = Mod_Rules.Info = Lambda.Info = Mir_Cg.Info = Mach_Cg.Info
  sharing Mod_Rules.Basis.Tyvarenv.Datatypes = Parser.Absyn.Datatypes =
    Valenv.Datatypes =
    Mir_Cg.EnvironTypes.LambdaTypes.Datatypes =
    Mach_Cg.MirTypes.Debugger_Types.Datatypes = Types.Datatypes
  sharing Mach_Cg.MirTypes.Debugger_Types = Encapsulate.Debugger_Types =
    Lambda.Debugger_Types
d508 6
a513 3
    Environ.EnvironTypes.LambdaTypes.Datatypes.Ident
  sharing Parser.Absyn.Set = Mod_Rules.Basis.Set(* = Primitives.Set = LambdaSub.Set*)
  sharing Parser.Absyn = Mod_Rules.Absyn = Lambda.Absyn = TopdecPrint.Absyn
d515 17
a531 8
  sharing Environ.EnvironTypes.LambdaTypes = LambdaPrint.LambdaTypes =
    LambdaOptimiser.LambdaTypes = Lambda.EnvironTypes.LambdaTypes =
    LambdaSub.LT
  sharing Environ.EnvironTypes = Lambda.EnvironTypes =
    Primitives.EnvironTypes = EnvironPrint.EnvironTypes = Mir_Cg.EnvironTypes =
    Encapsulate.EnvironTypes = LambdaModule.EnvironTypes
  sharing Mir_Cg.MirTypes = MirPrint.MirTypes = MirOptimiser.MirTypes =
    Mach_Cg.MirTypes = MirOptimiser.MirTypes
d534 1
a536 1
          sharing Encapsulate.Assemblies = Mod_Rules.Assemblies
a562 1
  val lambda_print_margin = LambdaPrint.print_margin
a569 16
  local val dummy_stream = Info.Stream.outstream{output = fn s => output(std_out,s),
                                                 flush_out = fn () => (),
                                                 close_out = fn () => ()}
  in
    val default_options = Info.OPTIONS {error = {outstream = dummy_stream,
                                                 stop = Info.FATAL,
                                                 report = Info.ADVICE,
                                                 worst = ref Info.ADVICE},
                                        information = {outstream = dummy_stream,
                                                       level = 2},
                                        listing = {outstream = dummy_stream,
                                                   level = 2},
                                        diagnostic = {outstream = dummy_stream,
                                                      level = 2}}
  end

d571 1
a571 1
  val error_wrap = Info.wrap default_options (Info.FATAL, Info.RECOVERABLE, !error_output_level)
a641 1
  val show_id_class    = TopdecPrint.show_id_class
d765 1
a765 1
                          default_options
d903 1
a903 1
                      TopdecPrint.topdec_to_string topdec])
d1077 1
a1077 1
			   LambdaPrint.output_lambda (strm,lambda_exp)))
d1090 1
a1090 1
	  Timer.xtime("LambdaOptimiser", !print_timings, fn () => LambdaOptimiser.optimise lambda_exp)
d1108 1
a1108 1
			   LambdaPrint.output_lambda (strm,opt_lambda_exp)))
d1116 1
a1116 1
	    EnvironPrint.printtopenv top_env])
d1175 1
a1175 1
                  (output(std_out,name ^ " : " ^ Types.print_type ty ^ " ");
d1211 1
a1211 37
  fun compile_ts (ts, cb as CB(p, t, c), generate_debug, debug_info) =
    let
      val filename = Lexer.associated_filename ts
      val (topdec, p') =
	Timer.xtime("Parsing", !print_timings, (fn () => error_wrap Parser.parse_topdec(ts, p)))
      val _ = diagnose_simple"Parsing complete"
    in
      case topdec of
	Absyn.REQUIREtopdec (s, _) =>
	  (topdec, empty_cb, LambdaTypes.STRUCT[], debug_info)
      | Absyn.STRDECtopdec(Absyn.SEQUENCEstrdec [], _) =>
          (topdec, empty_cb, LambdaTypes.STRUCT[], debug_info)
      | _ =>
	  let
	    val t' = Timer.xtime("Type-checking ", ! print_timings,
				 fn () => error_wrap Mod_Rules.check_topdec(topdec,t))
	    val _ =
	      if (!show_absyn) then
		Diagnostic.output 0
		(fn i =>
		 ["The abstract syntax\n",
		  TopdecPrint.topdec_to_string topdec])
	      else ()

	    val _ = diagnose_simple"Typechecking complete"
	    val (c', declarations, debug_info') = 
	      Timer.xtime("Lambda translation", ! print_timings,
			  fn () => error_wrap Lambda.trans_top_dec (topdec, c, generate_debug, debug_info))
	    val _ = diagnose_simple"Lambda translation complete"
	    val (c'', lambda_exp) =
              LambdaModule.pack (c', declarations)
	  in
	    (topdec, CB(p', t', c''), lambda_exp, debug_info')
	  end
    end

  fun compile_file' (cache, filename) =
a1215 1
       val options = default_options
d1231 2
a1232 1
  fun compile_file filename = (compile_file' (empty_cache, filename); ())
d1238 4
a1241 1
      do_input (default_options,empty_cache, fn _ => if !done then "" else (done := true; x), DIRECT);
@


1.130
log
@Removed Info structure from parser, tidied upderived
@
text
@d4 3
d874 1
a874 4
                (Info.error
                 options
                 (Info.WARNING, Info.Location.FILE filename, "Empty structure dec sequence");
                 compile_topdec arg))
d1251 1
a1251 1
           Info.error' options (Info.FATAL, Info.Location.UNKNOWN, s)
@


1.129
log
@Changed Error structure to Info
@
text
@d4 3
d483 1
a483 1
  sharing Parser.Info = Mod_Rules.Info = Lambda.Info = Mir_Cg.Info = Mach_Cg.Info
d532 1
a532 1
  structure Info = Parser.Info
@


1.128
log
@Changed the pervasives and representation of time.
Added a cache on the results of Encapsulate.input_info.
Changed format of consistency info.
@
text
@d4 5
d480 1
a480 1
  sharing Parser.Error = Parser.Lexer.Error
d529 1
a529 1
  structure Error = Parser.Error
a537 2
  val error_output_level = ref Error.ADVICE
  val error_wrap = Error.wrap (Error.FATAL, Error.RECOVERABLE, !error_output_level)
d539 19
d718 1
a718 1
  fun compile_program (cache, path, ts, initial, pervasive) = 
d732 2
a733 2
      fun do_subrequires (cache, require_list, _, nil) = (cache, require_list)
	| do_subrequires (cache, require_list, path, (name,_) :: cons) =
d738 1
a738 1
	    do_subrequires (cache, require_list, path, cons)
d750 3
a752 2
                          Error.report'
                          (Error.ERROR (Error.FATAL, Error.Location.FILE filename, s))
d759 2
a760 1
		do_subrequires (cache,
d774 1
d782 2
a783 1
	fn x => Timer.xtime("do_subrequires", !print_timings, (fn () => do_subrequires x))
d808 1
a808 2
                      Error.report'
                      (Error.ERROR (Error.FATAL, location, implode ["Required mo `", mo, "' does not exist"]))
d817 1
a817 2
                       Error.report'
                       (Error.ERROR (Error.FATAL, location, message)))
d868 3
a870 1
                (Error.report (Error.ERROR (Error.WARNING, Error.Location.FILE filename, "Empty structure dec sequence"));
d927 1
d943 1
a943 1
      fun parse pb = Parser.parse_topdec (ts, pb)
d971 1
a971 1
				 fn pb => Parser.parse_topdec (token_stream, pb),
d1004 1
a1004 1
  fun do_input (cache, input_fn, source) =
d1014 3
a1016 2
                (Error.report
                 (Error.ERROR (Error.WARNING, Error.Location.FILE name, "Compiling as the builtin library"));
d1019 3
a1021 2
                (Error.report
                 (Error.ERROR (Error.WARNING, Error.Location.FILE name, "Compiling as pervasive"));
d1047 1
a1047 1
	compile_program (cache, Io.compilation_path filename, ts, initial_cb, pervasive)
d1241 1
d1248 1
a1248 1
           Error.report' (Error.ERROR (Error.FATAL, Error.Location.UNKNOWN, s))
d1250 1
a1250 1
         do_input (cache, fn _ => input(instream, 4096), FILE sml_name)
d1263 1
a1263 1
      do_input (empty_cache, fn _ => if !done then "" else (done := true; x), DIRECT);
@


1.127
log
@Removed for the second time a sharing constraint on NewMap
@
text
@d4 3
d646 5
d696 1
a696 1
  fun compile_program (path, ts, initial, pervasive) = 
d710 2
a711 2
      fun do_subrequires (require_list, _, nil) = require_list
	| do_subrequires (require_list, path, (name,_) :: cons) =
d716 1
a716 1
	    do_subrequires (require_list, path, cons)
d721 13
a733 5
	      val {consistency, tynames, strnames, tyfuns} =
		Encapsulate.input_info mo
		handle Encapsulate.BadInput s =>
                  Error.report'
                  (Error.ERROR (Error.FATAL, Error.Location.FILE filename, s))
d735 3
a737 2
	      val require_list =
		do_subrequires (require_list,
d750 2
a751 1
              ((comp_name, tyname_count, strname_count, tyfun_count) :: require_list,
d763 1
a763 1
      fun compile_topdec(arg as (path, require_list, cb1 as CB(p, t, c),
d778 7
d795 1
a795 1
		val (my_stamp as (name, stamp), cons) =
d798 1
a798 1
                  | (_, (hi, lo)) :: tl => ((root, {hi=hi, lo=lo}), tl)
d800 2
a801 2
		val require_list =
                  error_wrap do_subrequires (require_list, Io.compilation_path mo, cons)
d836 2
a837 1
		(require_list, [my_stamp], decls, CB(parser_env, t, top_env), empty_cb,
d842 1
a842 1
		(require_list, [], [], empty_cb, empty_cb, counters,debug_info)
d880 2
a881 1
		(require_list, [], declarations, empty_cb, CB(p'',t',c'),
d893 2
a894 2
      fun compile_topdecs'(path, require_list, reqs, code, initial_cb,
                           compiled_cb, parse, eof, counters,debug_info) = 
d896 2
a897 1
          val (require_list, requires, declarations, req_cb, comp_cb,
d899 2
a900 2
            compile_topdec(path, require_list, initial_cb, compiled_cb,
                           eof, parse, counters,debug_info)
d906 1
a906 1
            (require_list, reqs', code', compiled_cb', counters,debug_info)
d908 3
a910 3
            compile_topdecs'(path, require_list, reqs', code',
                             augment_cb(initial_cb, req_cb),
                             compiled_cb', parse, eof, counters,debug_info)
d918 1
a918 1
      val (require_list, reqs_list, decls_list, CB(pbasis, basis, top_env),
d921 1
a921 1
             ([], [], [], empty_cb, initial_counters,empty_debug_info)
d939 1
a939 1
	      val (require_list, reqs_list, decls_list,
d941 2
a942 1
		compile_topdecs'(path, [], [], [], initial,
d948 2
a949 1
	      compile_topdecs'(path, require_list, reqs_list, decls_list,
d954 1
a954 1
	    compile_topdecs'(path, [], [], [], initial, empty_cb, parse, eof,
d970 2
a971 1
      (require_list, reqs_list, lambda_exp', CB(pbasis, basis, top_env''),
d977 1
a977 1
  fun do_input(input_fn, source) =
d1015 1
a1015 1
      val (require_list, requires, lambda_exp, 
d1018 2
a1019 1
	compile_program (Io.compilation_path filename, ts, initial_cb, pervasive)
d1022 1
a1022 1
          DIRECT => {hi=0, lo=0}
d1159 9
a1167 8
	Encapsulate.output_file
	  {filename = Io.mo_name (case source of FILE name => name | DIRECT => "test"),
	   code = the_machine_code, parser_env = parser_env,
	   type_basis = type_basis, debug_info = debugger_information,
           type_assembly = !Mod_Rules.ty_ass, str_assembly = !Mod_Rules.str_ass, 
	   require_list = require_list, lambda_env = top_env,
	   tynames = tyname_count, strnames = strname_count, tyfuns = tyfun_count,
	   consistency = requires})
d1207 1
a1207 1
  fun compile_file filename =
d1219 2
a1220 2
       val result =
         do_input(fn _ => input(instream, 4096), FILE sml_name)
d1223 2
a1224 1
       close_in instream
d1226 2
d1233 2
a1234 1
      do_input(fn _ => if !done then "" else (done := true; x), DIRECT)
@


1.126
log
@Setting show_mir (etc.) now produces output without the need to call
Diagnostic.set 2.
@
text
@d4 4
a491 1
  sharing MirOptimiser.Map = Types.Datatypes.NewMap
@


1.125
log
@Reworked in terms of mononewmap
@
text
@d487 2
a488 1
    Mach_Cg.MirTypes
a490 1
  sharing Encapsulate.Assemblies = Mod_Rules.Assemblies
d493 1
d834 1
a834 1
		    Diagnostic.output 2
d1000 1
a1000 1
	  Diagnostic.output_fn 2
d1031 1
a1031 1
	  Diagnostic.output_fn 2
d1038 1
a1038 1
	  Diagnostic.output 2
d1055 1
a1055 1
	  Diagnostic.output 2
d1068 1
a1068 1
	  Diagnostic.output 2
d1153 1
a1153 1
		Diagnostic.output 2
@


1.124
log
@Removed Error from toplevel signature
@
text
@d4 3
d487 1
a487 2
    Mach_Cg.MirTypes = MirOptimiser.MirTypes
  sharing MirOptimiser.Map = Types.Datatypes.NewMap
d490 1
a492 1
          sharing Encapsulate.Assemblies = Mod_Rules.Assemblies
@


1.123
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
a413 1
require "../typechecker/simpletypes";
a428 1
require "error";
a444 3
  structure Tyname_id : TYNAME_ID
  structure Tyfun_id : TYFUN_ID
  structure Strname_id : STRNAME_ID
a463 1
  structure Error : ERROR
d465 1
a465 1
  sharing Error = Parser.Error = Parser.Lexer.Error
d500 3
d515 1
a515 1
  structure Error = Error
@


1.122
log
@Added line number to token stream input functions.
Added location information to the `require' topdec.
@
text
@d4 4
d493 1
d783 1
a783 1
		val (t, _) =
d790 2
d1125 1
@


1.121
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d744 1
a744 1
	    Absyn.REQUIREtopdec s =>
d757 1
a757 1
                       (Error.ERROR (Error.FATAL, Error.Location.FILE filename, message)))
d890 1
a890 1
	      fun lex_fun () = 
d1132 1
a1132 1
	Absyn.REQUIREtopdec s =>
d1173 1
a1173 1
         do_input(fn () => input(instream, 4096), FILE sml_name)
d1183 1
a1183 1
      do_input(fn () => if !done then "" else (done := true; x), DIRECT)
@


1.120
log
@Moved lambda module code and strname reducing code elsewhere so that
they can be shared with the incremental compiler.  Also makes things
tidier, imho.
@
text
@d4 5
a587 1
  val show_eq_info     = Types.show_eq_info
@


1.119
log
@Added sharing contraint on Error to signature.
@
text
@d4 3
d409 1
d444 1
d473 1
a473 1
    Encapsulate.EnvironTypes
a662 230
  fun ident(x as EnvironTypes.FIELD _) = (true,x)
    | ident(x as EnvironTypes.PRIM _) = (false,x)
    | ident _ = Crash.impossible"External env not field"

  fun replace_ident(x, lvar) = lvar

  fun get_field_from_funenv(comp, _, _) = ident comp

  fun replace_field_in_funenv((_, interface, env), lvar) =
    (lvar, interface, env)

  fun get_field_from_strenv(_, comp) = ident comp

  fun replace_field_in_strenv((env, _), lvar) = (env, lvar)

  fun let_lambdas_in_exp(lv_le_list, lambda_exp) =
    Lists.reducer LambdaTypes.do_binding (lv_le_list, lambda_exp)

  fun extract_op (EnvironTypes.LAMB x) = LambdaTypes.VAR x
    | extract_op (EnvironTypes.PRIM x) = LambdaTypes.BUILTIN x
    | extract_op _ = Crash.impossible "extract_op problem"

  fun do_env([], _, le) = le
    | do_env(x :: xs, extract_fn, le) =
      let
	val lexp = extract_op(extract_fn x)
      in
	LambdaTypes.STRUCT[LambdaTypes.INT 0,
			   LambdaTypes.STRUCT([lexp,
					       do_env(xs, extract_fn,
						      le)])]
      end

  fun list_complete_from_topenv(topenv as EnvironTypes.TOP_ENV
				(EnvironTypes.ENV(mv, me, ms),
				 EnvironTypes.FUN_ENV m), decls_list) =
    let
      val valids = NewMap.to_list_ordered mv
      val exns = NewMap.to_list_ordered me
      val strids = NewMap.to_list_ordered ms
      val funids = NewMap.to_list_ordered m
    in
      (Environ.assign_fields topenv,
       let_lambdas_in_exp
       (decls_list,
	do_env(valids, fn (_, x) => x,
	       do_env(exns, fn (_, x) => x,
		      do_env(strids, fn (_, (_, x)) => x,
			     do_env(funids, fn (_, (x, _, _)) => x,
				    LambdaTypes.INT 1))))))
    end

  fun follow_tyname(arg as Datatypes.TYNAME _) = arg
    | follow_tyname(arg as Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...}) = arg
    | follow_tyname(Datatypes.METATYNAME{1=ref(Datatypes.ETA_TYFUN tyname), ...}) = follow_tyname tyname
    | follow_tyname(Datatypes.METATYNAME{1=ref(Datatypes.TYFUN(Datatypes.CONSTYPE([], tyname), 0)), ...}) = follow_tyname tyname
    | follow_tyname tyname = tyname

  fun follow_tyfun(arg as Datatypes.NULL_TYFUN _) = arg
    | follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.TYNAME _)) = arg
    | follow_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref tyfun, ...})) =
      follow_tyfun tyfun
    | follow_tyfun(tyfun as
			Datatypes.TYFUN(Datatypes.CONSTYPE(l, tyname), 0)) =
      if Types.check_debruijns(l, 0) then
	follow_tyfun(Datatypes.ETA_TYFUN tyname)
      else
	tyfun
    | follow_tyfun tyfun = tyfun

  fun long_follow_tyfun(arg as Datatypes.NULL_TYFUN _) = arg
    | long_follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.TYNAME _)) = arg
    | long_follow_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...})) =
      arg
    | long_follow_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref tyfun, ...})) =
      long_follow_tyfun tyfun
    | long_follow_tyfun(tyfun as
			Datatypes.TYFUN(Datatypes.CONSTYPE(l, tyname), 0)) =
      if Types.check_debruijns(l, 0) then
	long_follow_tyfun(Datatypes.ETA_TYFUN tyname)
      else
	tyfun
    | long_follow_tyfun tyfun = tyfun

  fun follow_strname(arg as Datatypes.STRNAME _) = arg
    | follow_strname(arg as Datatypes.NULLNAME _) = arg
    | follow_strname(arg as
		     Datatypes.METASTRNAME(ref(Datatypes.NULLNAME _))) =
      arg
    | follow_strname(arg as Datatypes.METASTRNAME(ref strname)) =
      follow_strname strname

  fun reduce_strname(arg as Datatypes.STRNAME _) = ()
    | reduce_strname(arg as Datatypes.NULLNAME _) = ()
    | reduce_strname(Datatypes.METASTRNAME(r as ref strname)) =
      r := follow_strname strname

  fun reduce_tyfun(arg as Datatypes.NULL_TYFUN _) = ()
    | reduce_tyfun(arg as Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...})) =
      ()
    | reduce_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=r as ref tyfun,
							    5=ref_ve, ...})) =
      let
	val tyfun = long_follow_tyfun tyfun
      in
	(case tyfun of
	   Datatypes.ETA_TYFUN _ => ref_ve := Datatypes.empty_valenv
	 | _ => ());
	   r := tyfun
      end
    | reduce_tyfun(Datatypes.ETA_TYFUN _) = ()
    | reduce_tyfun(Datatypes.TYFUN(ty, _)) = reduce_type ty

  and reduce_tyname(arg as Datatypes.TYNAME _) = ()
    | reduce_tyname(arg as Datatypes.METATYNAME{1=ref(Datatypes.NULL_TYFUN _), ...}) =
      ()
    | reduce_tyname(arg as Datatypes.METATYNAME{1=r as ref tyfun,
						5=ref_ve, ...}) =
      let
	val tyfun = long_follow_tyfun tyfun
      in
	(case tyfun of
	   Datatypes.ETA_TYFUN _ => ref_ve := Datatypes.empty_valenv
	 | _ => ());
	   r := tyfun
      end

  and reduce_scheme(Datatypes.SCHEME(_, ty)) = reduce_type ty
    | reduce_scheme(Datatypes.UNBOUND_SCHEME ty) = reduce_type ty
    | reduce_scheme _ = ()

  and reduce_type(Datatypes.METATYVAR(ref(_, ty), _, _)) = reduce_type ty
    | reduce_type(Datatypes.META_OVERLOADED(ref ty)) = reduce_type ty
    | reduce_type(Datatypes.TYVAR _) = ()
    | reduce_type(Datatypes.METARECTYPE(ref{3=ty, ...})) = reduce_type ty
    | reduce_type(Datatypes.RECTYPE map) =
      Lists.iterate
      (fn (_, ty) => reduce_type ty)
      (Map.assoc map)
    | reduce_type(Datatypes.FUNTYPE(ty1, ty2)) =
      (reduce_type ty1;
       reduce_type ty2)
    | reduce_type(Datatypes.CONSTYPE(l, tyname)) =
      (Lists.iterate reduce_type l;
       reduce_tyname tyname)
    | reduce_type _ = ()

  and reduce_valenv(Datatypes.VE(_, ve_map)) =
    NewMap.iterate (fn (_, type_scheme) => reduce_scheme type_scheme) ve_map

  fun reduce_str(Datatypes.STR(strname, env)) =
    (reduce_strname strname; reduce_env env)

  and reduce_env(Datatypes.ENV(Datatypes.SE strenv,
			       Datatypes.TE tyenv,
			       ve, ee)) =
    (NewMap.iterate (fn (_, str) => reduce_str str) strenv;
     NewMap.iterate (fn (_, Datatypes.TYSTR(tyfun, ve)) =>
		     (reduce_valenv ve;
		      reduce_tyfun tyfun)) tyenv;
     reduce_valenv ve;
     reduce_valenv ee)

  fun reduce_nameset nameset =
    (Lists.iterate reduce_strname (Nameset.strnames_of_nameset nameset);
     Lists.iterate reduce_tyname (Nameset.tynames_of_nameset nameset))

  fun reduce_sigma(Sigma.SIGMA(nameset, str)) =
    (reduce_nameset nameset; reduce_str str)

  fun reduce_basis(Basis.BASIS(nameset, Funenv.FUNENV funid_map,
			       Sigenv.SIGENV sigid_map, env)) =
    let
      val _ = reduce_nameset nameset
      val _ = NewMap.iterate
	(fn (_, Phi.PHI(nameset, (str, sigma))) =>
	 let
	   val _ = reduce_nameset nameset
	   val _ = reduce_str str
	 in
	   reduce_sigma sigma
	 end)
	funid_map
      val _ = NewMap.iterate (fn (_, sigma) => reduce_sigma sigma) sigid_map
    in
      reduce_env env
    end

(*
  fun follow_strname(arg as Datatypes.STRNAME _) = arg
    | follow_strname(arg as Datatypes.NULLNAME _) = arg
    | follow_strname(arg as Datatypes.METASTRNAME(ref(Datatypes.NULLNAME _))) = arg
    | follow_strname(arg as Datatypes.METASTRNAME(ref strname)) =
      follow_strname strname

  fun reduce_strname(arg as Datatypes.STRNAME _) = ()
    | reduce_strname(arg as Datatypes.NULLNAME _) = ()
    | reduce_strname(Datatypes.METASTRNAME(r as ref strname)) =
      r := follow_strname strname

  fun reduce_str(Datatypes.STR(strname, env)) =
    (reduce_strname strname; reduce_env env)

  and reduce_env(Datatypes.ENV(Datatypes.SE strenv, _, _, _)) =
    NewMap.iterate (fn (_, str) => reduce_str str) strenv

  fun reduce_nameset nameset =
    Lists.iterate reduce_strname (Nameset.strnames_of_nameset nameset)

  fun reduce_sigma(Sigma.SIGMA(nameset, str)) =
    (reduce_nameset nameset; reduce_str str)

  fun reduce_basis(Basis.BASIS(nameset, Funenv.FUNENV funid_map,
			       Sigenv.SIGENV sigid_map, env)) =
    let
      val _ = reduce_nameset nameset
      val _ = NewMap.iterate
	(fn (_, Phi.PHI(nameset, (str, sigma))) =>
	 let
	   val _ = reduce_nameset nameset
	   val _ = reduce_str str
	 in
	   reduce_sigma sigma
	 end)
	funid_map
      val _ = NewMap.iterate (fn (_, sigma) => reduce_sigma sigma) sigid_map
    in
      reduce_env env
    end
*)
a673 95
      fun require_lambdas (s,
                           EnvironTypes.TOP_ENV
                           (EnvironTypes.ENV (val_map, exn_map, struct_map),
                            EnvironTypes.FUN_ENV fun_env)) =
	let
	  val fun_list = NewMap.to_list_ordered fun_env
	  val val_list = NewMap.to_list_ordered val_map
	  val exn_list = NewMap.to_list_ordered exn_map
	  val struct_list = NewMap.to_list_ordered struct_map
	  val main_lvar = LambdaTypes.new_LVar()
	  val var_main_lvar = LambdaTypes.VAR main_lvar

	  fun get_new_binding_and_env(bindings, env, get_field, replace_field,
				      x, start_lvar) =
	    (* Modified version for when we use lists instead of tuples *)
	    let
	      fun sub_fun(bindings, env, [], finish_lvar) =
		(bindings, env, finish_lvar)
                | sub_fun(bindings, env, (x, y) :: rest, entry_lvar) =
                  let
                    val (really_is_a_field, field) = get_field y
                    val lvar = LambdaTypes.new_LVar()
                    val lvar' = LambdaTypes.new_LVar()
                    val lvar'' = LambdaTypes.new_LVar()
                  in
                    sub_fun
                    ((let
		        val var_lvar' = LambdaTypes.VAR lvar'
                        val bindings =
                          LambdaTypes.LETB(lvar'', LambdaTypes.SELECT
                                           ({index=1, size=2}, var_lvar'),"") ::
                          LambdaTypes.LETB(lvar', LambdaTypes.SELECT
                                           ({index=1, size=2}, entry_lvar),"") ::
                          bindings
                          (* Note reverse order, we'll reverse it later *)
		      in
                        if really_is_a_field then
                          LambdaTypes.LETB
                          (lvar,
                           LambdaTypes.SELECT({index=0, size=2},
					      var_lvar'),"") ::
                          bindings
                        else
                          (* No need to bind for a builtin *)
                          bindings
		      end),
			NewMap.define
			(env, x,
			 if really_is_a_field then
			   replace_field(y, EnvironTypes.LAMB lvar)
			 else y),
			rest, LambdaTypes.VAR lvar'')
                  end
	    in
	      sub_fun(bindings, env, x, start_lvar)
	    end

	  val main_binding =
	    LambdaTypes.LETB(main_lvar, 
			     LambdaTypes.APP(LambdaTypes.BUILTIN
					     Pervasives.LOAD_STRING,
					     LambdaTypes.SCON(Ident.STRING(Io.compilation_name s)),
                                             LambdaTypes.null_type_annotation),"")

	  val (bindings, val_env, finish_lvar) =
	    get_new_binding_and_env([], NewMap.empty Environ.valid_order,
				    ident, replace_ident, val_list,
				    var_main_lvar)
	  val (bindings, exn_env,finish_lvar) =
	    get_new_binding_and_env(bindings,
				    NewMap.empty Environ.valid_order, ident,
				    replace_ident, exn_list,finish_lvar)
	  val (bindings, struct_env,finish_lvar) =
	    get_new_binding_and_env(bindings,
				     NewMap.empty Environ.strid_order,
				     get_field_from_strenv,
				     replace_field_in_strenv, struct_list,
				     finish_lvar)
	  val (bindings, fun_env,finish_lvar) =
	    get_new_binding_and_env(bindings,
				     NewMap.empty Environ.funid_order,
				     get_field_from_funenv,
				     replace_field_in_funenv, fun_list,
				     finish_lvar)

	  val new_fun_env =
	    EnvironTypes.FUN_ENV fun_env

	  val new_val_env =
	    EnvironTypes.ENV(val_env, exn_env, struct_env)
	in
	  (main_binding :: rev bindings,
	   EnvironTypes.TOP_ENV(new_val_env, new_fun_env))
	end

d781 8
a788 1
		val (decls, top_env) = require_lambdas (name, lambda_env)
d814 1
a814 1
                                     fn () => reduce_basis t')
d907 1
d911 2
a912 1
                    fn () => Lambda.complete_struct_from_topenv(top_env, decls_list))
d915 3
a917 3
	Timer.xtime("Completing list struct from topenv", 
                    ! print_timings andalso ! print_minor_timings,
                    fn () => list_complete_from_topenv(top_env, decls_list))
d1147 1
a1147 1
	      list_complete_from_topenv(c', declarations)
@


1.118
log
@Removed add_fn_names (obsolete)
@
text
@d4 3
d451 1
@


1.117
log
@Turned off default printing of lambda code and environment
@
text
@d4 3
a496 1
  val add_fn_names = Lambda.add_fn_names
@


1.116
log
@show_eq_info controls printing of equality attribute of tycons.
show_id_class controls printing of id classes (VAR, CON or EXCON).
@
text
@d4 4
d495 2
a496 2
  val print_timings = ref true 
  val print_minor_timings = ref false
d566 2
a567 2
  val show_opt_lambda  = ref true
  val show_environ     = ref true
@


1.115
log
@Minor improvements in handling requires, mainly removing some from_lists
Removed valenvs from METATYNAMEs where there is a further tyname below
@
text
@d4 4
d568 2
@


1.114
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
Added `augment'.
@
text
@d4 5
d742 10
a751 2
    | reduce_tyfun(Datatypes.ETA_TYFUN(Datatypes.METATYNAME{1=r as ref tyfun, ...})) =
      r := long_follow_tyfun tyfun
d758 10
a767 2
    | reduce_tyname(arg as Datatypes.METATYNAME{1=r as ref tyfun, ...}) =
      r := follow_tyfun tyfun
d895 2
a896 2
	  fun get_new_binding_and_env'(bindings, env, get_field, replace_field,
				       x,start_lvar) =
d899 2
a900 1
	      fun sub_fun(bindings, env, [], finish_lvar) = (bindings, env, finish_lvar)
d903 1
a903 1
                    val (really_is_a_field,field) = get_field y
d922 2
a923 1
                           LambdaTypes.SELECT({index=0, size=2}, var_lvar'),"") ::
d929 6
a934 5
                     (x,
                      if really_is_a_field then
                        replace_field(y, EnvironTypes.LAMB lvar)
                      else y) :: env,
		     rest, LambdaTypes.VAR lvar'')
a939 21
	  fun get_new_binding_and_env(bindings, env, get_field, replace_field, x) =
	    let
	      fun sub_fun(bindings, env, []) = (bindings, env)
                | sub_fun(bindings, env, (x, y) :: rest) =
                  let
                    val lvar = LambdaTypes.new_LVar()
                  in
                    sub_fun
                    ((case get_field y of
                        (true, EnvironTypes.FIELD f) =>
                          [LambdaTypes.LETB
                           (lvar, LambdaTypes.SELECT(f, var_main_lvar),"")]
                      | (false, _) => []
                      | _ => Crash.impossible "TopLevel.get_field") @@ bindings,
                     (x, replace_field(y, EnvironTypes.LAMB lvar)) :: env,
                     rest)
                  end
	    in
	      sub_fun(bindings, env, x)
	    end

d947 4
a950 3
	  val (bindings, val_env,finish_lvar) =
	    get_new_binding_and_env'([], [], ident, replace_ident,
				    val_list,var_main_lvar)
d952 3
a954 2
	    get_new_binding_and_env'(bindings, [], ident, replace_ident,
				    exn_list,finish_lvar)
d956 5
a960 2
	    get_new_binding_and_env'(bindings, [], get_field_from_strenv,
				    replace_field_in_strenv, struct_list,finish_lvar)
d962 5
a966 2
	    get_new_binding_and_env'(bindings, [], get_field_from_funenv,
				    replace_field_in_funenv, fun_list,finish_lvar)
d969 1
a969 1
	    EnvironTypes.FUN_ENV(NewMap.from_list Environ.funid_order fun_env)
d972 1
a972 3
	    EnvironTypes.ENV(NewMap.from_list Environ.valid_order val_env,
			     NewMap.from_list Environ.valid_order exn_env,
			     NewMap.from_list Environ.strid_order struct_env)
@


1.113
log
@Added flag to switch off warning messages in generating recipes
@
text
@d4 3
d502 5
d534 2
a535 1
  val empty_debug_info = NewMap.empty' MLWorks.String.<
d1315 4
a1318 4
                    fn () => Mir_Cg.mir_cg (opt_lambda_exp, top_env, 
                                            filename,
                                            debug_information,
                                            !generate_debug_information))
d1349 6
a1354 6
                      fn () => Mach_Cg.mach_cg(the_optimised_code,
                                               (#gc assign,
                                                #non_gc assign,
                                                #fp assign),
                                               !generate_debug_information,
                                               debugger_information))
d1360 2
a1361 1
	    val info = NewMap.to_list debugger_information
d1412 1
a1412 1
	  (topdec, empty_cb, LambdaTypes.STRUCT[],debug_info)
d1414 1
a1414 1
          (topdec, empty_cb, LambdaTypes.STRUCT[],debug_info)
d1428 1
a1428 1
	    val (c', declarations,debug_info') = 
d1430 1
a1430 1
			  fn () => error_wrap Lambda.trans_top_dec (topdec,c,generate_debug,debug_info))
d1435 1
a1435 1
	    (topdec, CB(p', t', c''), lambda_exp,debug_info')
@


1.112
log
@Changed error wrapper to cope with new ERROR signature.
Added missing wrappers in compile_ts.
@
text
@d4 4
d554 2
@


1.111
log
@Added reduction of meta typenames and tyfuns to reduce chain length
after sharing/instantiation
@
text
@d4 4
d481 1
a481 1
  val error_wrap = fn f => Error.wrap (Error.RECOVERABLE, !error_output_level) f
d1391 1
a1391 1
	Timer.xtime("Parsing", !print_timings, (fn () => Parser.parse_topdec(ts, p)))
d1402 1
a1402 1
				 fn () => Mod_Rules.check_topdec(topdec,t))
@


1.110
log
@Moved the special names out of the compiler as a whole.
Installed central error reporting mechanism.
@
text
@d4 4
d670 32
d704 89
d831 1
@


1.109
log
@Switches for self_calling and fix to binding the compilation unit list result
@
text
@d4 3
d377 1
d384 2
a385 2
functor TopLevel (
  structure Unix : UNIX
d415 1
d462 1
a462 2

  exception STOP
d472 3
a474 2
  val builtin_library = "__builtin_library.sml"
  val pervasive_library = "__pervasive_library.sml" 
d514 1
a514 7
  val empty_debug_info =
    NewMap.empty(fn (x,y) => 
		 if x=y
		   then NewMap.EQUAL
		 else if MLWorks.String.< (x,y) 
			then NewMap.LESS
		      else NewMap.GREATER)
d516 1
a516 1
(* this codegen basis will not cope with code including exceptions *)
d520 1
a520 1
  fun augment_parser_cb_only(CB (p, t, c), CB (p', t', c')) =
d523 1
a523 1
  fun augment_cb(CB(p, t, c), CB(p', t', c')) =
d526 1
a526 1
     fn () => CB(Parser.augment_pB(p, p'), Basis.basis_circle_plus_basis(t, t'), Environ.augment_top_env(c, c')))
d530 8
a537 9
  val show_absyn      = ref false
  val show_lambda     = ref false
  val show_opt_lambda = ref true
  val show_environ    = ref true
  val show_mir        = ref false
  val show_opt_mir    = ref false
  val only_upto_lambda = ref false
  val show_mach       = Mach_Cg.show_mach
  val show_match      = Lambda.show_match
d540 3
a542 4
  val generate_debug_information = ref(false)
  val print_generated_debug_information = ref(false)

  val debug_level = ref(0)
d576 8
a583 26
  (* compile_program takes a token stream and an initial compiler
   basis (which should be constructed from the included files) and
   returns a lambda expression and a final compiler basis.
   The cb contains those vars and strs declared in the
   stream, with names giving the indices into the tuple *)
      

  fun check_in_set(bindings, (lv, le)) =
    if Map.domain_member(lv, bindings) then
      Crash.impossible("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
		       "\nto\n" ^ LambdaPrint.string_of_lambda le ^
		       "\nand also to\n" ^
		       LambdaPrint.string_of_lambda(Map.lookup(lv, bindings)) ^
		       "\n")
    else
      Map.add((lv, le), bindings, LambdaTypes.LVar_order)

  fun check_binding(bindings,
		    LambdaTypes.APP(LambdaTypes.FN(lv, _,_,_), le,_)) =
    ((if Map.domain_member(lv, bindings) then
	Crash.impossible("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
			 "\nto\n" ^ LambdaPrint.string_of_lambda le ^
			 "\nand also to\n" ^
			 LambdaPrint.string_of_lambda(Map.lookup(lv,
								 bindings)) ^
			 "\n")
d585 1
a585 21
	());
	bindings)
    | check_binding(bindings,
		    LambdaTypes.LET(lv,lb,_)) =
    ((if Map.domain_member(lv, bindings) then
	Crash.impossible("Duplicated binding of v" ^ LambdaTypes.printLVar lv ^
			 "\nto\n" ^ LambdaPrint.string_of_lambda lb ^
			 "\nand also to\n" ^
			 LambdaPrint.string_of_lambda(Map.lookup(lv,
								 bindings)) ^
			 "\n")
      else
	());
	bindings)
  | check_binding(bindings, le as LambdaTypes.FN(lv, _,_,_)) =
    check_in_set(bindings, (lv, le))
  | check_binding(bindings, LambdaTypes.LETREC(lvl, lel, _)) =
    Lists.reducel
    check_in_set
    (bindings, Lists.zip(lvl, lel))
  | check_binding(bindings, _) = bindings
d587 26
a612 2
  fun check_bindings expression =
    LambdaSub.reduce_outermost check_binding (Map.empty_map, expression)
a613 3
  fun de_field(EnvironTypes.FIELD x) = x
    | de_field _ = Crash.impossible "de-field called incorrectly"

a628 3
  fun sort_fn f =
    fn ((x, _), (x', _)) => f(x, x')

d668 1
a668 3
    | follow_strname(arg as
		     Datatypes.METASTRNAME(ref(Datatypes.NULLNAME _))) =
      arg
d707 7
a713 1
  fun compile_program (path, ts, initial, do_pervasive_library) = 
d715 6
a720 5
      fun require_lambdas
	(s, EnvironTypes.TOP_ENV(EnvironTypes.ENV(val_map,
						  exn_map,
						  struct_map),
				 EnvironTypes.FUN_ENV fun_env)) =
d734 33
a766 32
	      | sub_fun(bindings, env, (x, y) :: rest, entry_lvar) =
		let
		  val (really_is_a_field,field) = get_field y
		  val lvar = LambdaTypes.new_LVar()
		  val lvar' = LambdaTypes.new_LVar()
		  val lvar'' = LambdaTypes.new_LVar()
		in
		  sub_fun
		  ((let
		      val var_lvar' = LambdaTypes.VAR lvar'
		      val bindings =
			LambdaTypes.LETB(lvar'', LambdaTypes.SELECT
					({index=1, size=2}, var_lvar'),"") ::
			LambdaTypes.LETB(lvar', LambdaTypes.SELECT
					({index=1, size=2}, entry_lvar),"") ::
			bindings
			(* Note reverse order, we'll reverse it later *)
		    in
		      if really_is_a_field then
			LambdaTypes.LETB
			(lvar,
			 LambdaTypes.SELECT({index=0, size=2}, var_lvar'),"") ::
			bindings
		      (* No need to bind for a builtin *)
		      else bindings
		    end),
		      (x,
		       if really_is_a_field then
			 replace_field(y, EnvironTypes.LAMB lvar)
			 else y) :: env,
		      rest, LambdaTypes.VAR lvar'')
		end
d771 1
a771 2
	  fun get_new_binding_and_env(bindings, env, get_field, replace_field,
				      x) =
d774 14
a787 15
	      | sub_fun(bindings, env, (x, y) :: rest) =
		let
		  val (really_is_a_field,field) = get_field y
		  val lvar = LambdaTypes.new_LVar()
		in
		  sub_fun
		  ((if really_is_a_field then
		      [LambdaTypes.LETB
		       (lvar,
			LambdaTypes.SELECT(de_field field, var_main_lvar),"")]
                    (* No need to bind for a builtin *)
		    else []) @@ bindings,
		      (x, replace_field(y, EnvironTypes.LAMB lvar)) :: env,
		      rest)
		end
d791 1
d798 1
d811 1
d814 1
d824 1
a824 1
      fun get_full_name (path, name) =
d826 1
a826 1
	  val c_name = Io.compilation_name name
d828 2
a829 6
	  if
	    c_name = "__pervasive_library" orelse c_name = "mlworks" orelse
	    c_name = "string" orelse c_name = "array" orelse c_name = "bytearray" orelse
            c_name = "bits"
	  then
	    Io.mo_name(Io.relative_name(!pervasive_library_dir, c_name))
a837 4

	  fun encountered nil = false
	    | encountered ((name,_,_,_)::rest) =
	      name = comp_name orelse encountered rest
d839 1
a839 2
	  if encountered require_list then
	    (* Ignore if already encountered this one *)
d843 1
a843 1
	      val full_name = get_full_name(path, name)
d846 1
a846 1
		Encapsulate.input_info full_name
d848 2
a849 1
		  (Print.print("*** " ^ s ^ "\n"); raise STOP)
d853 1
a853 1
				Io.compilation_path full_name,
d864 3
a866 3
	      do_subrequires((comp_name, tyname_count, strname_count,
			      tyfun_count) :: 
			     require_list, path, cons)
d876 1
d883 2
a884 3
            Timer.xtime("Parsing", !print_timings, (fn () => parse parse_env))
            handle Parser.ParseError x => (Print.print("*** Parse Error: " ^ x ^ "\n"); raise STOP)
	  val _ = diagnose_simple"Parsing complete"
a888 1
		val full_name = get_full_name(path, s)
d890 1
d896 10
a905 8
		   fn _ =>
		   Encapsulate.input_all full_name
		   handle Encapsulate.BadInput s =>
		     (Print.print("*** " ^ s ^ "\n"); raise STOP))

		val (my_stamp as (name, stamp), cons) = case consistency of
		  [] => Crash.impossible"Strange, no consistency info"
		| (_, (hi, lo)) :: tl => ((root, {hi=hi, lo=lo}), tl)
d908 1
a908 1
		  do_subrequires (require_list, Io.compilation_path full_name, cons)
d921 1
a921 1
		val (t,_) =
d927 1
d938 1
a938 2
	     (Print.print"Empty structure dec sequence\n";
	      if eof() then
d940 3
a942 1
	      else compile_topdec arg)
d953 5
a957 6
		val t' = Timer.xtime("Type-checking ", ! print_timings,
                                     fn () => Mod_Rules.check_topdec(topdec,t))
		  handle Mod_Rules.Check_topdec x =>
		    (Print.print"*** Module rules error\n"; raise STOP)
		val _ = Timer.xtime("reducing strname chains", !print_timings,
				    fn () => reduce_basis t')
d970 1
d973 2
a974 1
                              fn () => Lambda.trans_top_dec (topdec,c,!generate_debug_information,debug_info))
d983 1
d989 18
a1006 18
	fun compile_topdecs'(path, require_list, reqs, code, initial_cb,
			     compiled_cb, parse, eof, counters,debug_info) = 
	  let
	    val (require_list, requires, declarations, req_cb, comp_cb,
		 counters,debug_info) =
	      compile_topdec(path, require_list, initial_cb, compiled_cb,
			     eof, parse, counters,debug_info)
	    val compiled_cb' = augment_cb(compiled_cb, comp_cb)
	    val reqs' = reqs @@ requires
	    val code' = code @@ declarations
	  in
	    if eof() then
	      (require_list, reqs', code', compiled_cb', counters,debug_info)
	    else
	      compile_topdecs'(path, require_list, reqs', code',
			       augment_cb(initial_cb, req_cb),
			       compiled_cb', parse, eof, counters,debug_info)
	  end
a1008 1
      fun parse pb = Parser.parse_topdec (ts,pb)
d1011 2
d1015 1
a1015 1
        if eof() then 
d1018 1
a1018 1
	  if do_pervasive_library then
a1019 1
	      val _ = Print.print"Implicitly requiring the pervasive_library\n"
d1021 5
a1025 2
	      val _ = the_expression :=
		"require \"" ^ Io.relative_name(!pervasive_library_dir, pervasive_library) ^ "\" ; open FullPervasiveLibrary_ "
d1028 1
a1028 1
		  val a = ! the_expression
d1033 1
a1033 1
	      val token_stream = Lexer.mkTokenStream(lex_fun,"")
d1038 1
a1038 2
				 fn pb => Parser.parse_topdec
				 (token_stream,pb),
d1064 2
d1067 1
a1067 4
  fun compare_filenames(x,y) = 
    (Io.compilation_name x = Io.compilation_name y)

  fun do_input(input_fn, filename) =
d1069 18
a1086 20
      val do_pervasive_library = ref(true)
      val initial_cb =
        if compare_filenames(builtin_library,filename) then 
	  (Print.print "*** WARNING - compiling specially as builtin_library\n";
	   do_pervasive_library := false;
	   initial_cb_for_builtin_library)
        else
	  if
	    compare_filenames("__pervasive_library.sml", filename) orelse
	    compare_filenames("mlworks.sml", filename) orelse
	    compare_filenames("string.sml", filename) orelse
	    compare_filenames("array.sml", filename) orelse
            compare_filenames("bytearray.sml", filename) orelse
            compare_filenames("bits.sml", filename)
	  then
	    (Print.print "*** WARNING - compiling as pervasive\n";
	     do_pervasive_library := false;
	     initial_cgb_for_normal_file)
	  else
	    initial_cgb_for_normal_file
d1088 1
a1088 1
      val _ = LambdaTypes.init_LVar()
d1090 1
a1090 1
      val ts = Lexer.mkTokenStream (input_fn,filename)
d1108 1
a1108 2
	compile_program (Io.compilation_path filename, ts, initial_cb,
			 !do_pervasive_library)
d1110 11
a1120 5
        if filename = "" then {hi=0,lo=0}
        else case Unix.mtime filename of
          Unix.EXISTS i => i
        | _ => Crash.impossible"File being compiled no longer exists"
      val requires = (Io.compilation_name filename, sec_time) :: requires
d1151 2
a1152 1
      val _ = diagnose_simple("Lambda optimisation complete, final size of expression = "^(Integer.makestring (LambdaSub.size_of_expr opt_lambda_exp)))
a1159 4
      val _ = if not(!only_upto_lambda) 
		then 
      let

d1170 4
a1173 3
                    fn () => Mir_Cg.mir_cg(opt_lambda_exp, top_env,filename,
                                           debug_information,
                                           !generate_debug_information))
d1236 1
a1236 1
        if compare_filenames(builtin_library,filename) then
d1238 1
a1238 1
	  after_builtin_cgb)
d1248 1
a1248 1
	  {filename = Io.mo_name filename,
d1253 1
a1253 2
	   consistency = requires}
      )
a1254 1
       else ()    (* only upto lambda *)
a1255 3
    in
      ()
    end
d1257 1
a1257 2
    
  fun compile_ts(ts, cb as CB(p, t, c),generate_debug,debug_info) =
d1259 1
a1261 2
	handle Parser.ParseError x =>
	  (Print.print("*** Parse Error: " ^ x ^ "\n"); raise STOP)
d1268 1
a1268 2
	  (Print.print"Empty structure dec sequence\n";
	   (topdec, empty_cb, LambdaTypes.STRUCT[],debug_info))
a1272 2
	      handle Mod_Rules.Check_topdec x =>
		(Print.print"*** Module rules error\n"; raise STOP)
d1284 1
a1284 1
			  fn () => Lambda.trans_top_dec (topdec,c,generate_debug,debug_info))
a1292 1

d1294 17
a1310 13
    Timer.xtime("Compilation", ! print_timings,
                fn () => let
                  val sml_name = Io.sml_name filename
                  val _ = diagnose_simple("Compiling " ^ sml_name ^ " at debugging level " 
                                          ^ Integer.makestring(!debug_level))
                  val _ = if !print_timings then Print.print ("Compiling " ^ sml_name ^ "\n") else ()
                  val instream = open_in sml_name
		    handle Io s => (Print.print "*** "; Print.print s; Print.print "\n"; raise STOP)
                  val result = do_input(fn () => input(instream, 4096), sml_name)
                    handle exn => (close_in instream; raise exn)
                in
                  close_in instream
                end)
d1316 1
a1316 1
      do_input(fn () => if !done then "" else (done := true; x), "")
@


1.108
log
@Removed some redundant structures and sharing
@
text
@d4 3
d553 1
d558 1
d563 1
d567 5
d573 1
d748 1
a748 1
				       x) =
d751 1
a751 1
	      fun sub_fun(bindings, env, [], _) = (bindings, env)
d785 1
a785 1
	      sub_fun(bindings, env, x, var_main_lvar)
d814 3
a816 2
					     LambdaTypes.SCON(Ident.STRING(Io.compilation_name s)),LambdaTypes.null_type_annotation),"")
	  val (bindings, val_env) =
d818 2
a819 2
				    val_list)
	  val (bindings, exn_env) =
d821 2
a822 2
				    exn_list)
	  val (bindings, struct_env) =
d824 2
a825 2
				    replace_field_in_strenv, struct_list)
	  val (bindings, fun_env) =
d827 1
a827 1
				    replace_field_in_funenv, fun_list)
@


1.107
log
@Propogation of information about exceptions
@
text
@d4 3
a366 1
require "../mir/mirtypes";
a370 1
require "../debugger/debugger_types";
a407 1
  structure Debugger_Types : DEBUGGER_TYPES
d411 7
a417 4
    Mir_Cg.LambdaTypes.Datatypes = Mach_Cg.Datatypes = Types.Datatypes
  sharing Mach_Cg.Debugger_Types = Mir_Cg.Debugger_Types = Encapsulate.Debugger_Types = Lambda.Debugger_Types
  sharing Parser.Absyn.IdentClass = Environ.Ident = MirPrint.MirTypes.Ident
  sharing Parser.Absyn.Set = Mod_Rules.Basis.Set = Primitives.Set = LambdaSub.Set
d421 2
a422 2
    LambdaOptimiser.LambdaTypes = Primitives.LambdaTypes = Lambda.EnvironTypes.LambdaTypes =
    Mir_Cg.LambdaTypes = LambdaSub.LT
d426 3
a428 4
  sharing Mir_Cg.MirTypes = MirPrint.MirTypes = MirOptimiser.MirTypes = Mach_Cg.MirTypes = MirOptimiser.MirTypes
  sharing Environ.EnvironTypes.NewMap = Mir_Cg.Debugger_Types.Map =
    Types.Datatypes.NewMap = Lambda.Debugger_Types.Map
  sharing Mach_Cg.Map = MirOptimiser.Map
a440 1
  structure NewMap = EnvironTypes.NewMap
d442 1
d444 1
a444 1
  structure Ident = MirPrint.MirTypes.Ident
d448 1
a448 1
  structure Debugger_Types = Mir_Cg.Debugger_Types
a453 1
  structure Debugger_Types = Debugger_Types
d507 6
a512 6
    Mir_Cg.Debugger_Types.Map.empty(fn (x,y) => 
                                    if x=y
                                      then Mir_Cg.Debugger_Types.Map.EQUAL
                                    else if MLWorks.String.< (x,y) 
                                           then Mir_Cg.Debugger_Types.Map.LESS
                                         else Mir_Cg.Debugger_Types.Map.GREATER)
d1215 7
a1221 8
        if !print_generated_debug_information
          then
            let
              val info =  Debugger_Types.Map.to_list debugger_information
            in
              case info of
                [] => ()
              | _ => 
d1226 6
a1231 6
                   (if is_leaf
                      then output(std_out,"leaf\n")
                        else output(std_out,"not leaf\n"));
                   Lists.reducer (fn ((x,y),_) =>
				  output(std_out,"  " ^ Integer.makestring x ^ "  " ^ 
					 Debugger_Types.print_backend_annotation y ^ "\n")) 
d1234 1
a1234 1
            end
@


1.106
log
@Added Timer.xtime call for Encapsulate.input_all.
@
text
@d4 3
d369 1
d407 1
d412 1
a412 1
  sharing Mach_Cg.Debugger_Types = Mir_Cg.Debugger_Types = Encapsulate.Debugger_Types
d425 1
a425 1
    Types.Datatypes.NewMap
d452 1
d505 8
d887 1
a887 1
				 counters as (tynames, strnames, tyfuns))) =
d941 1
a941 1
		 counters)
d946 1
a946 1
		(require_list, [], [], empty_cb, empty_cb, counters)
d976 1
a976 1
		val (c', declarations) = 
d978 1
a978 1
                              fn () => Lambda.trans_top_dec (topdec,c))
d983 2
a984 1
		  tyfuns+tyfun_count))
d993 1
a993 1
			     compiled_cb, parse, eof, counters) = 
d996 1
a996 1
		 counters) =
d998 1
a998 1
			     eof, parse, counters)
d1004 1
a1004 1
	      (require_list, reqs', code', compiled_cb', counters)
d1008 1
a1008 1
			       compiled_cb', parse, eof, counters)
d1016 1
a1016 1
	   counters) =
d1018 1
a1018 1
             ([], [], [], empty_cb, initial_counters)
d1035 1
a1035 1
		   full_env as CB(pbasis, basis, top_env), _) =
d1041 1
a1041 1
				 initial_counters)
d1045 1
a1045 1
			       initial_counters)
d1049 1
a1049 1
			     initial_counters)
d1063 1
a1063 1
       counters)
d1111 1
a1111 1
	   (tyname_count, strname_count, tyfun_count)) =
d1173 1
a1173 6
                                           Mir_Cg.Debugger_Types.Map.empty(fn (x,y) => 
                                                                if x=y
                                                                  then Mir_Cg.Debugger_Types.Map.EQUAL
                                                                else if MLWorks.String.< (x,y) 
                                                                       then Mir_Cg.Debugger_Types.Map.LESS
                                                                     else Mir_Cg.Debugger_Types.Map.GREATER),
d1265 1
a1265 1
  fun compile_ts(ts, cb as CB(p, t, c)) =
d1275 1
a1275 1
	  (topdec, empty_cb, LambdaTypes.STRUCT[])
d1278 1
a1278 1
	   (topdec, empty_cb, LambdaTypes.STRUCT[]))
d1294 1
a1294 1
	    val (c', declarations) = 
d1296 1
a1296 1
			  fn () => Lambda.trans_top_dec (topdec,c))
d1301 1
a1301 1
	    (topdec, CB(p', t', c''), lambda_exp)
@


1.105
log
@Added bytearray and bits to pervasive modules.
@
text
@d4 3
d888 7
a894 3
		  Encapsulate.input_all full_name
		  handle Encapsulate.BadInput s =>
		    (Print.print("*** " ^ s ^ "\n"); raise STOP)
@


1.104
log
@Added details about leafness to the debug information
@
text
@d4 3
d814 2
a815 1
	    c_name = "string" orelse c_name = "array"
d1060 3
a1062 1
	    compare_filenames("array.sml", filename)
@


1.103
log
@Made changes to allow mo files to be copied.
@
text
@d4 3
d450 1
d528 1
d532 1
d536 1
d538 5
a542 1
     | _ => output(std_out,"0,1,2 for debug level\n"))
d1201 5
a1205 2
                 (fn((name,(ty,annotations)),_) =>
                  (output(std_out,name ^ " : " ^ Types.print_type ty ^ "\n");
@


1.102
log
@Changed printing of user-level errors so that it prints
'***' at the start of the line, to help find errors
amongst timing info.
@
text
@d4 5
d450 1
a450 1
  val pervasive_library_path = Io.pervasive_library_path
d794 13
d821 1
a821 2
	      val mo_name = Io.mo_name name
	      val full_name = Io.relative_name (path, mo_name)
d866 1
a866 2
		val mo_name = Io.mo_name s
		val full_name = Io.relative_name (path, mo_name)
d988 1
a988 2
		"require \"" ^ Io.root_name(! pervasive_library_path) 
		^ "\" ; open FullPervasiveLibrary_ "
@


1.101
log
@Took out an extra print statement. Now gets input in bigger
chunks using input instead of input_line.
@
text
@d4 4
d494 1
a494 3
     fn () => CB(Parser.augment_pB(p, p'),
		 Basis.basis_circle_plus_basis(t, t'),
		 Environ.augment_top_env(c, c')))
d654 1
a654 5
    let
      val _ = reduce_strname strname
    in
      reduce_env env
    end
d660 1
a660 5
    let
      val strname_list = Nameset.strnames_of_nameset nameset
    in
      Lists.iterate reduce_strname strname_list
    end
d663 1
a663 5
    let
      val _ = reduce_nameset nameset
    in
      reduce_str str
    end
d809 1
a809 1
		  (Print.print s; raise STOP)
d831 1
a831 3
	fn x =>
	Timer.xtime("do_subrequires", !print_timings,
		    (fn () => do_subrequires x))
d843 1
a843 2
            handle Parser.ParseError x =>
              (Print.print("Parse Error: " ^ x ^ "\n"); raise STOP)
d856 1
a856 1
		    (Print.print s; raise STOP)
d859 1
a859 6
		  [] =>
		    let
		      val _ = Print.print"Strange, no consistency info"
		    in
		      ((root, {hi=0, lo=0}), [])
		    end
d873 1
a873 2
		  (Io.compilation_name root, tyname_count, strname_count,
		   tyfun_count) ::
d909 1
a909 1
		    (Print.print"Module rules error"; raise STOP)
d967 22
a988 28
	  if do_pervasive_library
	    then
	      let
		val _ =
		  output(std_out,"Implicitly requiring the pervasive_library\n")
		val the_expression = ref ""
		val _ = the_expression :=
		  "require \"" ^ Io.root_name(! pervasive_library_path) 
		  ^ "\" ; open FullPervasiveLibrary_ "
		fun lex_fun () = 
		  let
		    val a = ! the_expression
		  in
		    the_expression := "";
		    a
		  end
		val token_stream = Lexer.mkTokenStream(lex_fun,"")
		val (require_list, reqs_list, decls_list,
		     full_env as CB(pbasis, basis, top_env), _) =
		  compile_topdecs'(path, [], [], [], initial,
				   initial_cgb_for_normal_file,
				   fn pb => Parser.parse_topdec
				   (token_stream,pb),
				   fn () => Lexer.eof token_stream,
				   initial_counters)
	      in
		compile_topdecs'(path, require_list, reqs_list, decls_list,
				 full_env, empty_cb, parse, eof,
d990 5
a994 1
	      end
d1021 4
a1024 5
        if compare_filenames(builtin_library,filename)
          then 
            (output(std_out,"**** WARNING - compiling specially as builtin_library\n");
             do_pervasive_library := false;
             initial_cb_for_builtin_library)
d1032 1
a1032 1
	    (output(std_out,"**** WARNING - compiling as pervasive\n");
d1076 3
a1078 7
	  let
	    val _ = Print.print"Checking bindings from lambda translator\n"
	    val _ = check_bindings lambda_exp
	    val _ = Print.print"Checked bindings from lambda translator\n"
	  in
	    ()
	  end
d1084 1
a1084 2
	  Timer.xtime("LambdaOptimiser", ! print_timings,
                      fn () => LambdaOptimiser.optimise lambda_exp)
d1090 3
a1092 7
	  let
	    val _ = Print.print"Checking bindings from lambda optimiser\n"
	    val _ = check_bindings opt_lambda_exp
	    val _ = Print.print"Checked bindings from lambda optimiser\n"
	  in
	    ()
	  end
d1173 1
a1173 1
                (output(std_out,"Generated debug information\n");
d1186 3
a1188 4
        if compare_filenames(builtin_library,filename)
          then
            (output(std_out,"**** Changing top level environment \n");
             after_builtin_cgb)
d1195 1
a1195 1
      Timer.xtime("Outputting", !print_timings andalso !print_minor_timings,
d1218 1
a1218 1
	  (Print.print("Parse Error: " ^ x ^ "\n"); raise STOP)
d1232 1
a1232 1
		(Print.print"Module rules error"; raise STOP)
d1260 1
a1260 3
                  val _ = if ! print_timings
                            then output(std_out,"Compiling " ^ sml_name ^ "\n")
                          else ()
d1262 1
a1262 1
		    handle Io s => (Print.print s; raise STOP)
@


1.100
log
@Changed to use MLWorks.IO.input_line
@
text
@d4 3
d1255 1
a1255 5
	  let
	    val _ = Print.print("Ignoring require \"" ^ s ^ "\"\n")
	  in
	    (topdec, empty_cb, LambdaTypes.STRUCT[])
	  end
d1297 1
a1297 1
                  val result = do_input(fn () => MLWorks.IO.input_line instream, sml_name)
@


1.99
log
@Changed to use new Encapsulate interface.
@
text
@d4 3
d1298 1
a1298 1
                  val result = do_input(fn () => Io.input_line instream, sml_name)
@


1.98
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
a385 3
(*
  sharing Parser.Absyn.Nameset = Mod_Rules.Basis.Nameset
*)
d424 2
d472 1
a472 3
    CB(Parser.empty_pB,
       Basis.empty_basis,
       Environ.empty_top_env)
d810 4
a813 7
	      val (env, cons') =
		case Encapsulate.input_file full_name of
		  Encapsulate.TOTAL_INPUT{env=[env], consistency=cons', ...} => (env, cons')
		| _ => Crash.impossible"bad result from Encapsulate.input_file"
	      val cons' = Encapsulate.decode_cons cons'
	      val {tynames=tynames, strnames=strnames, tyfuns=tyfuns} = 
		Encapsulate.decode_counts env
d818 1
a818 1
				case cons' of [] => [] | _ :: tl => tl)
d848 3
a850 4
            Timer.xtime("Parsing", !print_timings,
                        (fn () => parse parse_env))
            handle exn as Parser.ParseError x =>
              (Print.print("Parse Error: " ^ x ^ "\n"); raise exn)
d860 4
a863 5
		val (env, cons) =
		  case Encapsulate.input_file full_name of
		    Encapsulate.TOTAL_INPUT{env=[env], consistency=cons, ...} => (env, cons)
		  | _ => Crash.impossible"bad result from Encapsulate.input_file"
		  
d865 1
a865 4
		(* consistency check *)

		val cons = Encapsulate.decode_cons cons
		val (my_stamp as (name, stamp), cons) = case cons of
d875 1
a875 16
		  do_subrequires (require_list, Io.compilation_path full_name,
				  cons)

		(* environment handling *)

		val {parser_env=p_env, ty_env=t_env, lambda_env=l_env,
		     tynames = tynames, strnames = strnames, tyfuns=tyfuns} =
		  Timer.xtime("decoding encapsulation of " ^ root,
			      !print_timings andalso !print_minor_timings,
                              fn () => Encapsulate.decode_env env)

		val p =
		  Timer.xtime("decoding encapsulated parser env of size " ^
			      Integer.makestring(size (#1 p_env)),
			      !print_timings andalso !print_minor_timings,
			      fn () => Encapsulate.decode_parser_env p_env)
d891 1
a891 1
			      Integer.makestring(size (#1 t_env)),
d898 1
a898 7
		val l =
		  Timer.xtime
		  ("decoding encapsulated lambda environment of size " ^
		   Integer.makestring(size (#1 l_env)),
		   !print_timings andalso !print_minor_timings,
		   fn () => Encapsulate.decode_lambda_env l_env)
		val (decls, top_env) = require_lambdas (name, l)
d901 1
a901 1
		(require_list, [my_stamp], decls, CB(p, t, top_env), empty_cb,
d921 2
a922 2
		  handle exn as Mod_Rules.Check_topdec x =>
		    (Print.print"Module rules error"; raise exn)
d1226 3
a1228 3
	   ty_env = (type_basis, debugger_information, require_list),
	   lambda_env = top_env, tynames = tyname_count,
	   strnames = strname_count, tyfuns = tyfun_count,
d1242 3
a1244 4
	Timer.xtime("Parsing", !print_timings,
		    (fn () => Parser.parse_topdec(ts, p)))
	handle exn as Parser.ParseError x =>
	  (Print.print("Parse Error: " ^ x ^ "\n"); raise exn)
d1261 2
a1262 2
	      handle exn as Mod_Rules.Check_topdec x =>
		(Print.print"Module rules error"; raise exn)
d1294 2
a1295 2
                  val result = do_input(fn () => Io.input_line instream,
					sml_name)
d1299 1
a1299 1
                end  )
@


1.97
log
@Changed MLworks to MLWorks.
@
text
@d4 3
d376 2
a377 1
  sharing Mod_Rules.Basis.Datatypes = Parser.Absyn.Datatypes  = Valenv.Datatypes =
d382 1
d384 1
d394 2
a395 1
  sharing Environ.EnvironTypes.NewMap = Mir_Cg.Debugger_Types.Map = Mod_Rules.Basis.Datatypes.NewMap
d410 2
a411 1
  structure Map = Basis.Datatypes.Mapping
a413 3
  structure Basis = Basis
  structure Lexer = Lexer
  structure EnvironTypes = EnvironTypes
a414 1
  structure Datatypes = Basis.Datatypes
d417 1
a417 1
  structure Nameset = Basis.Nameset
d420 2
a421 1
  structure Funenv = Basis.Funenv
d652 1
a652 5
    let
      val assoc = NewMap.to_list strenv
    in
      Lists.iterate (fn (_, str) => reduce_str str) assoc
    end
d672 2
a673 3
      val fun_assoc = NewMap.to_list funid_map
      val _ = Lists.iterate
	(fn (_, Basis.Phi.PHI(nameset, (str, sigma))) =>
d680 2
a681 3
	fun_assoc
      val sig_assoc = NewMap.to_list sigid_map
      val _ = Lists.iterate (fn (_, sigma) => reduce_sigma sigma) sig_assoc
@


1.96
log
@Encapsulate.output_file now does everything, instead of
TopLevel calling a number of different Encapsulate
files. Changed list of pervasive files.
@
text
@d4 5
d1176 1
a1176 1
                                                                else if MLworks.String.< (x,y) 
@


1.95
log
@I had inverted the tail-call flag in set_debug_level
@
text
@a3 9
Revision 1.94  1992/08/07  16:01:18  clive
Added the function set_debug_level

Revision 1.93  1992/08/06  17:08:29  jont
Anel's changes to use NewMap instead of Map

Revision 1.93  1992/08/06  17:08:29  jont
Anel's changes to use NewMap instead of Map

a305 2
require "../utils/map";
require "../utils/newmap";
a307 1
require "../utils/string";
a311 4
require "../basics/absyn";
require "../basics/ident";
require "../basics/symbol";
require "../lexer/lexer";
a313 1
require "../typechecker/basis";
a317 2
require "../lambda/environtypes";
require "../lambda/lambdatypes";
a337 2
  structure Map : MAP
  structure NewMap : NEWMAP
a339 1
  structure String : STRING
a343 4
  structure Absyn : ABSYN
  structure Ident : IDENT
  structure Symbol : SYMBOL
  structure Lexer : LEXER
a345 1
  structure Basis : BASIS
a351 2
  structure LambdaTypes : LAMBDATYPES
  structure EnvironTypes : ENVIRONTYPES
a357 1
  structure MirTypes : MIRTYPES
d368 2
a369 4
  sharing Map = Basis.Datatypes.Mapping
  sharing Basis.Datatypes = Absyn.Datatypes  = Valenv.Datatypes =
    Mir_Cg.LambdaTypes.Datatypes = LambdaTypes.Datatypes =
    Mach_Cg.Datatypes = Types.Datatypes
d371 7
a377 10
  sharing Absyn.IdentClass = LambdaTypes.Ident = Ident =
    Environ.Ident = MirTypes.Ident
  sharing Absyn.Set = Basis.Set = Primitives.Set = LambdaSub.Set
  sharing Absyn.Nameset = Basis.Nameset
  sharing Lexer = Parser.Lexer
  sharing Absyn = Parser.Absyn = Mod_Rules.Absyn = Lambda.Absyn =
    TopdecPrint.Absyn
  sharing Basis = Mod_Rules.Basis = Encapsulate.Basis
  sharing EnvironTypes.LambdaTypes = LambdaTypes = LambdaPrint.LambdaTypes =
    LambdaOptimiser.LambdaTypes = Primitives.LambdaTypes =
d379 1
a379 1
  sharing Environ.EnvironTypes = EnvironTypes = Lambda.EnvironTypes =
d382 2
a383 5
  sharing (*Lexer.Token.Symbol = *)Symbol = Ident.Symbol
  sharing Mir_Cg.MirTypes = MirTypes = MirPrint.MirTypes =
    MirOptimiser.MirTypes = Mach_Cg.MirTypes
  sharing EnvironTypes.NewMap = NewMap = Mir_Cg.Debugger_Types.Map =
    Types.Datatypes.NewMap
a384 1
  sharing Mach_Cg.MirTypes = MirOptimiser.MirTypes
d388 1
a388 1
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
d392 8
a403 1
  structure LambdaTypes = LambdaTypes
d1066 11
a1076 10
          if compare_filenames("__callc_codes.sml",filename)
            then (do_pervasive_library := false ;
                  output(std_out,"**** WARNING compiling specially as callc_codes\n");
                  empty_env)
          else
            if compare_filenames("__pervasive_library.sml",filename)
              then (output(std_out,"**** WARNING - compiling as pervasive_library\n");
                    do_pervasive_library := false;
                    initial_cgb_for_normal_file)
            else initial_cgb_for_normal_file
d1101 1
a1101 2
        if filename = ""
          then (* test *) {hi=0,lo=0}
d1171 1
a1171 1
                                                                else if String.< (x,y) 
d1244 13
a1256 47
      val output_name = Io.mo_name filename
      val total_output =
	Timer.xtime
	("encapsulating output", !print_timings,
	 fn () =>
	 let
	   val enc_l_env =
	     Timer.xtime("encoding lambda environment",
			 !print_timings andalso !print_minor_timings,
			 fn () => Encapsulate.encode_lambda_env top_env)
	   val enc_t_env =
	     Timer.xtime("Encoding type basis",
			 !print_timings andalso !print_minor_timings,
			 fn () => Encapsulate.encode_type_basis
			 (type_basis,debugger_information,require_list))
	   val enc_p_env =
	     Timer.xtime("Encoding parser environment",
			 !print_timings andalso !print_minor_timings,
			 fn () => Encapsulate.encode_parser_env parser_env)
	   val enc_env =
	     Timer.xtime("Encapsulating environments",
			 !print_timings andalso !print_minor_timings,
			 fn () => Encapsulate.encode_env
			 {parser_env=enc_p_env, ty_env=enc_t_env,
			  lambda_env=enc_l_env, tynames=tyname_count,
			  strnames=strname_count, tyfuns=tyfun_count})
	   val requires =
	     map
	     (fn (str, {hi=hi, lo=lo}) => (str, (hi, lo)))
	     requires
	   val cons =
	     Timer.xtime("Encapsulating requires",
			 !print_timings andalso !print_minor_timings,
			 fn () => Encapsulate.encode_cons requires)
	 in
	   Encapsulate.TOTAL_OUTPUT
	   {code = Encapsulate.encode_code the_machine_code,
	    env = enc_env,
	    debug = Encapsulate.STRING "",
	    consistency = cons}
	 end)
      val _ =
	Timer.xtime("Outputing", !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.output_file
                    (output_name, total_output))

    in () end else ()    (* only upto lambda *)
@


1.94
log
@Added the function set_debug_level
@
text
@d4 3
d532 1
a532 1
          Mir_Cg.generate_tail_optimisation := false)
d535 1
a535 1
          Mir_Cg.generate_tail_optimisation := false)
d538 1
a538 1
          Mir_Cg.generate_tail_optimisation := true)
@


1.93
log
@Anel's changes to use NewMap instead of Map
@
text
@d7 3
d522 18
d1376 2
a1377 1
                  val _ = diagnose_simple("Compiling " ^ sml_name )
@


1.92
log
@Added strnasme contraction to reduce the number of refs traversed
in type checking and sharing. Fixed up a naff sharing constraint
@
text
@d4 7
d414 2
a415 1
  sharing EnvironTypes.NewMap = NewMap = Mir_Cg.Debugger_Types.Map
d651 1
a651 1
      val assoc = Map.assoc strenv
d674 1
a674 1
      val fun_assoc = Map.assoc funid_map
d684 1
a684 1
      val sig_assoc = Map.assoc sigid_map
@


1.91
log
@Use of new hash tables, removed some concatenation and compression of integers in encapsulator
@
text
@d4 3
d385 1
d399 1
a399 1
    Lambda.LambdaTypes = LambdaOptimiser.LambdaTypes = Primitives.LambdaTypes =
d404 1
a404 1
  sharing Lexer.Symbol = Symbol = Ident.Symbol
d426 4
d621 61
d947 2
@


1.90
log
@Equality type problem in info = []
@
text
@d4 3
d738 1
a738 1
		  Encapsulate.TOTAL_OUTPUT{env=[env], consistency=cons', ...} => (env, cons')
d792 1
a792 1
		    Encapsulate.TOTAL_OUTPUT{env=[env], consistency=cons, ...} => (env, cons)
d1211 1
a1211 1
	    debug = "",
@


1.89
log
@Added return of abstract syntax tree to compile_ts
@
text
@d4 3
d1145 3
a1147 3
              if info=[]
                then ()
              else 
@


1.88
log
@Moved all file manipulation into Io
@
text
@d4 3
d1234 1
a1234 1
	    (empty_cb, LambdaTypes.STRUCT[])
d1238 1
a1238 1
	   (empty_cb, LambdaTypes.STRUCT[]))
d1261 1
a1261 1
	    (CB(p', t', c''), lambda_exp)
@


1.87
log
@Modifications to allow less string concatenation and copying
@
text
@d4 3
d327 1
d371 1
d423 1
a423 1
  val pervasive_library_path = ref"/usr/users/sml/src/rts/__pervasive_library"
a446 5
(*
  val initial_cb =
    CB (Parser.initial_pB, Basis.initial_basis, initial_cgb)
*)

a499 12
  fun root_name filename =
    let
      val len = size filename
      val final_name =
	if len >= 4 then
	  String.substring(filename, len-4, 4)
	else ""
    in
      case final_name of
	".sml" => String.substring(filename, 0, len-4)
      | _ => filename
    end
a500 50
  fun compilation_name filename =
    let
      val root = root_name filename
      val exp_root = explode root
      fun remove_slash(result, []) = result
      | remove_slash(result, "/" :: rest) = remove_slash(rest, rest)
      | remove_slash(result, x :: rest) = remove_slash(result, rest)
    in
      implode(remove_slash(exp_root, exp_root))
    end

  fun compilation_path filename =
    let
      val root = root_name filename
      val final = compilation_name filename
    in
      String.substring(root, 0, size root - size final)
    end

  fun sml_name filename = root_name filename ^ ".sml"

  fun mo_name filename =
    if size filename = 0 then
      "test.mo"
    else
      root_name filename ^ ".mo"

  fun relative_name(path, name) =
    case String.substring(name, 0, 1) of
      "/" => name
    (* Handle case of require via absolute pathname *)
    | _ => 
	let
	  fun join path name =
	    if size name < 3 orelse path = "" then path ^ name
	    else
	      case String.substring(name, 0, 3) of
		"../" =>
		  let
		    val prepath =
		      compilation_path(String.substring(path, 0,
							size path - 1))
		  in
		    join prepath (String.substring(name, 3, size name - 3))
		  end
	      | _ => path ^ name
	in
	  join path name
	end

d686 1
a686 1
					     LambdaTypes.SCON(Ident.STRING(compilation_name s)),LambdaTypes.null_type_annotation),"")
a698 6
(*
	  fun list_to_map(x, order_fun) =
	    Lists.reducel
	    (fn (x, y) => Map.add(y, x, order_fun))
	    (Map.empty_map, x)
*)
d713 1
a713 1
	  val comp_name = compilation_name name
d724 2
a725 2
	      val mo_name = mo_name name
	      val full_name = relative_name (path, mo_name)
d737 1
a737 1
				compilation_path full_name,
d777 3
a779 3
		val mo_name = mo_name s
		val full_name = relative_name (path, mo_name)
		val root = root_name s
d800 2
a801 1
		  do_subrequires (require_list,compilation_path full_name,cons)
d825 1
a825 1
		  (compilation_name root, tyname_count, strname_count,
a856 14
(*
		val _ =
		  case topdec of
		    Absyn.STRDECtopdec strdec =>
		      (Print.print"Is Absyn.STRDECtopdec\n";
		       case strdec of
			 Absyn.SEQUENCEstrdec strdec_list =>
			   (Print.print"Is Absyn.SEQUENCEDECstrdec\n";
			    case strdec_list of
			      [] => Print.print"Is empty list\n"
			    | _ => Print.print"Non-empty list\n")
		       | _ => Print.print"Not Absyn.SEQUENCEDECstrdec\n")
		  | _ => Print.print"Not Absyn.STRDECtopdec\n"
*)
d931 1
a931 1
		  "require \"" ^ root_name(! pervasive_library_path) 
d974 1
a974 1
    (compilation_name x = compilation_name y)
d1017 1
a1017 1
	compile_program (compilation_path filename, ts, initial_cb,
d1025 1
a1025 1
      val requires = (compilation_name filename, sec_time) :: requires
a1152 17
(*
      val _ =
        if !print_generated_debug_information
          then
            let
              val _ = output(std_out,"Generated debug information\n")
            in
              Lists.reducer
              (fn((name,(ty,annotations)),_) =>
               (output(std_out,name ^ " : " ^ Types.print_type ty ^ "\n");
                Lists.reducer (fn ((x,y),_) => output(std_out,"  " ^ Integer.makestring x ^ "  " ^ 
                                                      Debugger_Types.print_backend_annotation y ^ "\n")) 
                (annotations,())))
              (Debugger_Types.Map.to_list debugger_information,())
            end
        else ()
*)
d1164 1
a1164 1
      val output_name = mo_name filename
a1250 5
(*
	    val tyname_count = Tyname_id.read_counter () - tyname_count
	    val strname_count = Strname_id.read_counter () - strname_count
	    val tyfun_count = Tyfun_id.read_counter () - tyfun_count
*)
a1261 18
  fun get_terminated_line file =
    let
      fun extend_line line =
	if end_of_stream file then
	  implode(rev line)
	else
	  let
	    val char = input(file, 1)
	  in
	    if char = "\n" then implode(rev("\n" :: line))
	    else
	      extend_line(char :: line)
	  end
    in
      extend_line []
    end
    
  val input_line = get_terminated_line
d1266 1
a1266 1
                  val sml_name = sml_name filename
d1272 2
a1273 1
                  val result = do_input(fn () => input_line instream, sml_name)
a1285 11
  fun top_level () =
    let
      val _ = output (std_out,"Enter file name: ")
      val _ = NewJersey.flush_out std_out
      val line = (input_line std_in)
      val _ = (compile_file (String.substring (line,0,size line -1)); ())
	handle exn => 
	  output (std_out,"*** Exception "^System.exn_name exn^" raised\n")
    in
      top_level ()
    end
@


1.86
log
@Removed obsolete memory profiling code.
@
text
@d4 3
d748 1
a748 1
					     LambdaTypes.SCON(Ident.STRING(compilation_name s)),LambdaTypes.null_type_annotation()),"")
d795 4
a798 2
	      val Encapsulate.TOTAL_OUTPUT{env=env, consistency=cons', ...} =
		Encapsulate.input_file full_name
d849 5
a853 2
		val Encapsulate.TOTAL_OUTPUT{env=env, consistency=cons, ...} =
		  Encapsulate.input_file full_name
d880 1
a880 1
			      Integer.makestring(size p_env),
d898 1
a898 1
			      Integer.makestring(size t_env),
d908 1
a908 1
		   Integer.makestring(size l_env),
d1218 21
d1250 1
@


1.85
log
@Added call point information recording
@
text
@d4 3
a487 1
  val generate_memory_profiling = Mach_Cg.generate_memory_profiling
@


1.84
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d363 3
a365 1
    Mir_Cg.LambdaTypes.Datatypes = LambdaTypes.Datatypes
d383 1
a383 1
  sharing EnvironTypes.NewMap = NewMap
d401 1
d486 2
a487 2
  val generate_debug_information = Mir_Cg.generate_debug_information
  val print_generated_debug_information = Mir_Cg.print_generated_debug_information
d1158 8
a1165 1
                    fn () => Mir_Cg.mir_cg(opt_lambda_exp, top_env,filename))
d1191 1
a1191 1
      val the_machine_code =
d1197 5
a1201 3
                                      (#gc assign,
                                       #non_gc assign,
                                       #fp assign)))
d1203 16
@


1.83
log
@Modified spec of compile_ts to return lambda expression
@
text
@d4 3
d563 1
a563 1
		    LambdaTypes.APP(LambdaTypes.FN(lv, _,_,_), le)) =
d574 12
d686 1
a686 1
			LambdaTypes.LET(lvar'', LambdaTypes.SELECT
d688 1
a688 1
			LambdaTypes.LET(lvar', LambdaTypes.SELECT
d694 1
a694 1
			LambdaTypes.LET
d722 1
a722 1
		      [LambdaTypes.LET
d734 4
a737 3
	    LambdaTypes.LET(main_lvar, LambdaTypes.APP(LambdaTypes.BUILTIN
					Pervasives.LOAD_STRING,
					LambdaTypes.SCON(Ident.STRING(compilation_name s))),"")
d1164 1
a1164 1
      val the_optimised_code =
@


1.82
log
@Added switch to allow compilation to stop at
lambda, and also display of size of lambda expr.
@
text
@d4 4
d603 37
a1006 37
      fun let_lambdas_in_exp(lv_le_list, lambda_exp) =
	Lists.reducer LambdaTypes.do_binding (lv_le_list, lambda_exp)

      fun extract_op (EnvironTypes.LAMB x) = LambdaTypes.VAR x
	| extract_op (EnvironTypes.PRIM x) = LambdaTypes.BUILTIN x
	| extract_op _ = Crash.impossible "extract_op problem"

      fun do_env([], _, le) = le
	| do_env(x :: xs, extract_fn, le) =
	  let
	    val lexp = extract_op(extract_fn x)
	  in
	    LambdaTypes.STRUCT[LambdaTypes.INT 0,
			       LambdaTypes.STRUCT([lexp,
						   do_env(xs, extract_fn,
							  le)])]
	  end

      fun list_complete_from_topenv(topenv as EnvironTypes.TOP_ENV
				    (EnvironTypes.ENV(mv, me, ms),
				     EnvironTypes.FUN_ENV m), decls_list) =
	let
	  val valids = NewMap.to_list_ordered mv
	  val exns = NewMap.to_list_ordered me
	  val strids = NewMap.to_list_ordered ms
	  val funids = NewMap.to_list_ordered m
	in
	  (Environ.assign_fields topenv,
	   let_lambdas_in_exp
	   (decls_list,
	    do_env(valids, fn (_, x) => x,
		   do_env(exns, fn (_, x) => x,
			  do_env(strids, fn (_, (_, x)) => x,
				 do_env(funids, fn (_, (x, _, _)) => x,
					LambdaTypes.INT 1))))))
	end

d1250 1
a1250 1
	    (empty_cb, [])
d1254 1
a1254 1
	   (empty_cb, []))
d1279 2
d1282 1
a1282 1
	    (CB(p', t', c'), declarations)
@


1.81
log
@Changed to use (much) faster Lambda Print.
@
text
@d4 4
d467 1
d1110 1
a1110 1
      val _ = diagnose_simple"Lambda optimisation complete"
d1118 4
d1224 3
d1230 1
@


1.80
log
@Coded main section of compile_ts for interpreter
@
text
@d4 3
d386 1
d1069 3
a1071 4
	  Diagnostic.output 2
	  (fn i =>
	   ["The lambda code\n",
	    LambdaPrint.string_of_lambda lambda_exp])
d1108 3
a1110 4
	  Diagnostic.output 2
	  (fn i =>
	   ["The optimised lambda code\n",
	    LambdaPrint.string_of_lambda opt_lambda_exp])
@


1.79
log
@Added functions to do compiling and return results
@
text
@d4 3
d708 1
a708 5
	      if name = comp_name
		then
		  true
	      else
		encountered rest
d721 2
a722 2
	      val {tynames=tynames, strnames=strnames, tyfuns=tyfuns, ...} = 
		Encapsulate.decode_env env
d743 5
d1217 47
a1263 2
  fun compile_ts(ts, cb) =
    Crash.unimplemented"compile_ts"
@


1.78
log
@Added flags for the recording of debug type information
@
text
@d4 3
d412 1
d415 1
d417 1
a417 1
    val initial_cb_for_builtin_library =
d427 2
d1213 3
@


1.77
log
@changed to produce lists as compilation units instead of tuples
changed to use newmap
@
text
@d4 4
d339 2
a340 1
  sharing Basis.Datatypes = Absyn.Datatypes  = Valenv.Datatypes
d454 2
d537 1
a537 1
		    LambdaTypes.APP(LambdaTypes.FN(lv, _,_), le)) =
d548 1
a548 1
  | check_binding(bindings, le as LambdaTypes.FN(lv, _,_)) =
d612 1
a612 1
					({index=1, size=2}, var_lvar')) ::
d614 1
a614 1
					({index=1, size=2}, entry_lvar)) ::
d621 1
a621 1
			 LambdaTypes.SELECT({index=0, size=2}, var_lvar')) ::
d649 1
a649 1
			LambdaTypes.SELECT(de_field field, var_main_lvar))]
d661 1
a661 1
					LambdaTypes.SCON(Ident.STRING(compilation_name s))))
d803 1
a803 1
		val t =
d1108 1
a1108 38
      val _ =
        if compare_filenames(builtin_library,filename)
          then
            (output(std_out,"Checking that it contains what we expect\n");
             let 
               val c = Basis.basis_to_context type_basis
               fun check_value name con =
                 (output(std_out,"  checking " ^ name ^ " ");
                  (Basis.lookup_val(Ident.PATH(Symbol.find_symbol "BuiltinLibrary_",Ident.NOPATH),
                                   if con
                                     then Ident.EXCON(Symbol.find_symbol name)
                                   else Ident.VAR(Symbol.find_symbol name),
                                     c);
                  output(std_out,"... ok \n"))
                  handle _ => output(std_out," ... **** Not found ****\n"))
               val Datatypes.STR(_,x) = Basis.lookup_longstrid
                 ((Ident.LONGSTRID(Ident.NOPATH,
                                    Ident.STRID(Symbol.find_symbol "BuiltinLibrary_"))),type_basis)
               val Datatypes.ENV(_,_,varenv,exconenv) = x
               val excon_list = 
                 map (fn Ident.VAR x => Symbol.symbol_name x | _ => Crash.impossible "_toplevel 1" )
                 (Valenv.ve_domain exconenv)
               val var_list = 
                 map (fn Ident.VAR x => Symbol.symbol_name x | _ => Crash.impossible "_toplevel 2")
                  (Valenv.ve_domain varenv)
             in
               (map (fn x => check_value x false) (#1 Pervasives.to_be_checked);
                map (fn x => check_value x false) (#2 Pervasives.to_be_checked);
                map (fn x => check_value x true) (#2 Pervasives.to_be_checked);
                output(std_out,"Differences the other way : ");
                map (fn x => output(std_out,x ^ " ")) (Lists.difference(var_list,#1 Pervasives.to_be_checked));
                map (fn x => output(std_out,x ^ " ")) (Lists.difference(excon_list,#2 Pervasives.to_be_checked));
                output(std_out,"\n"))
             end)
        else
          ()

      val the_mir_code = 
d1171 1
a1171 1
			 (type_basis,require_list))
@


1.76
log
@Changed Mach_Cg_ to Mach_Cg
@
text
@d4 3
d255 1
d296 1
d338 1
a338 2
  sharing EnvironTypes.Map = Map = Environ.Map
  sharing Absyn.Set = Basis.Set = Environ.Set = Primitives.Set = LambdaSub.Set
d353 1
d390 1
a390 1
    (Primitives.initial_env, EnvironTypes.FUN_ENV Map.empty_map)
d394 1
a394 1
    (Primitives.env_after_builtin, EnvironTypes.FUN_ENV Map.empty_map)
d398 1
a398 1
    (Primitives.env_for_not_ml_definable_builtins, EnvironTypes.FUN_ENV Map.empty_map)
d402 1
a402 1
    (Primitives.initial_env_for_builtin_library, EnvironTypes.FUN_ENV Map.empty_map)
d426 2
a427 4
  fun augment_cb (CB (p, t, c), CB (p', t', c')) = 
    CB (Parser.augment_pB (p,p'),
	Basis.basis_circle_plus_basis (t,t'),
	Environ.augment_top_env (c,c'))
d429 7
d552 21
d575 5
a579 6
	  
      fun require_lambdas(s,
			  EnvironTypes.TOP_ENV(EnvironTypes.ENV(val_map,
								exn_map,
								struct_map),
					       EnvironTypes.FUN_ENV fun_env)) =
d581 4
a584 4
	  val fun_list = Map.assoc fun_env
	  val val_list = Map.assoc val_map
	  val exn_list = Map.assoc exn_map
	  val struct_list = Map.assoc struct_map
d587 42
a634 2
                  fun de_field(EnvironTypes.FIELD x) = x
                    | de_field _ = Crash.impossible "de-field called incorrectly"
d639 4
a642 2
		  ((if really_is_a_field
                     then [LambdaTypes.LET(lvar, LambdaTypes.SELECT(de_field field, var_main_lvar))]
d644 3
a646 3
                       else []) @@ bindings,
		   (x, replace_field(y, EnvironTypes.LAMB lvar)) :: env,
		   rest)
a650 10
	  fun ident(x as EnvironTypes.FIELD _) = (true,x)
            | ident(x as EnvironTypes.PRIM _) = (false,x)
	  | ident _ = Crash.impossible"External env not field"
	  fun replace_ident(x, lvar) = lvar
	  fun get_field_from_funenv(comp, _, _) = ident comp
	  fun replace_field_in_funenv((_, interface, env), lvar) =
	    (lvar, interface, env)
	  fun get_field_from_strenv(_, comp) = ident comp
	  fun replace_field_in_strenv((env, _), lvar) =
	    (env, lvar)
a654 3
	  val (bindings, fun_env) =
	    get_new_binding_and_env([], [], get_field_from_funenv,
				    replace_field_in_funenv, fun_list)
d656 1
a656 1
	    get_new_binding_and_env(bindings, [], ident, replace_ident,
d659 1
a659 1
	    get_new_binding_and_env(bindings, [], ident, replace_ident,
d662 1
a662 1
	    get_new_binding_and_env(bindings, [], get_field_from_strenv,
d664 4
d672 1
d674 1
a674 1
	    EnvironTypes.FUN_ENV(list_to_map(fun_env, Ident.funid_order))
d676 3
a678 3
	    EnvironTypes.ENV(list_to_map(val_env, Ident.valid_order),
			     list_to_map(exn_env, Ident.valid_order),
			     list_to_map(struct_env, Ident.strid_order))
d680 1
a680 1
	  (main_binding :: bindings,
d733 3
a735 2
      fun compile_topdec(path, require_list, CB(p, t, c),parse,
			 counters as (tynames, strnames, tyfuns)) =
d737 4
a740 3
	  val (topdec,p') = 
            Timer.xtime("Parsing", ! print_timings,
                        (fn () => parse p))
d817 5
d824 15
d842 1
a842 1
		val require_list = 
d867 1
a867 1
		(require_list, [], declarations, empty_cb, CB(p',t',c'),
d878 1
a878 1
			     compiled_cb,parse,eof, counters) = 
d882 2
a883 3
	      compile_topdec(path, require_list,
			     augment_cb(initial_cb, compiled_cb), parse,
			     counters)
d939 2
d942 34
d981 5
d987 1
a987 1
      (require_list, reqs_list, lambda_exp, CB(pbasis, basis, top_env'),
@


1.75
log
@Added memory profiling flag
@
text
@d4 3
d438 1
a438 1
  val generate_memory_profiling = Mach_Cg_.generate_memory_profiling
@


1.74
log
@Removed a redundant augment_cb from the compilation process
@
text
@d4 3
d435 1
d908 6
a913 3
      val sec_time = case Unix.mtime filename of
	Unix.EXISTS i => i
      | _ => Crash.impossible"File being compiled no longer exists"
@


1.73
log
@Modified for two integer time stamps
@
text
@d4 3
a419 3
  fun concat_cbs cb [] = cb
    | concat_cbs cb (cb'::cbs) = concat_cbs(augment_cb(cb,cb')) cbs

a791 1
	    val initial_cb' = augment_cb(initial_cb, req_cb)
d799 2
a800 1
	      compile_topdecs'(path, require_list, reqs', code', initial_cb',
@


1.72
log
@Added timing for entire encapsulation process
@
text
@d4 3
d690 1
a690 1
		      ((root, (0, 0)), [])
d692 1
a692 1
		| (_, stamp) :: tl => ((root, stamp), tl)
d907 1
a907 1
      val requires = (compilation_name filename, (sec_time, 0)) :: requires
d1077 4
d1090 1
a1090 1
	    consistency = Encapsulate.encode_cons requires}
@


1.71
log
@Added do_check_bindings bool ref to control the checking of uniqueness
of bound lambda variable names. Default off
@
text
@d4 4
d1047 1
d1049 36
a1084 25
      val enc_l_env = 
        Timer.xtime("encoding lambda environment",
		    !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.encode_lambda_env top_env)
      val enc_t_env = 
        Timer.xtime("Encoding type basis",
		    !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.encode_type_basis
		    (type_basis,require_list))
      val enc_p_env = 
        Timer.xtime("Encoding parser environment",
		    !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.encode_parser_env parser_env)
      val enc_env =
        Timer.xtime("Encapsulating environments",
		    !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.encode_env
                    {parser_env=enc_p_env, ty_env=enc_t_env,
		     lambda_env=enc_l_env, tynames=tyname_count,
		     strnames=strname_count, tyfuns=tyfun_count})

      val cons = 
        Timer.xtime("Encapsulating requires",
		    !print_timings andalso !print_minor_timings,
                    fn () => Encapsulate.encode_cons requires)
d1088 1
a1088 6
                    (output_name,
                     Encapsulate.TOTAL_OUTPUT
                     {code = Encapsulate.encode_code the_machine_code,
                      env = enc_env,
                      debug = "",
                      consistency = Encapsulate.encode_cons requires}))
@


1.70
log
@Removed reference to pervasive flush_out. Added an input_line function
@
text
@d4 3
d355 1
d357 3
a359 3
    val builtin_library = "__builtin_library.sml"
    val pervasive_library = "__pervasive_library.sml" 
    val pervasive_library_path = ref("/usr/users/sml/src/rts/__pervasive_library" )
d910 11
a920 3
      val _ = Print.print"Checking bindings from lambda translator\n"
      val _ = check_bindings lambda_exp
      val _ = Print.print"Checked bindings from lambda translator\n"
d929 11
a939 3
      val _ = Print.print"Checking bindings from lambda optimiser\n"
      val _ = check_bindings opt_lambda_exp
      val _ = Print.print"Checked bindings from lambda optimiser\n"
@


1.69
log
@Expanded some of the decoding messages to give more info
@
text
@d4 3
d1062 19
d1106 1
a1106 1
      val _ = flush_out std_out
@


1.68
log
@First version of the profiler
@
text
@d4 3
d233 1
d273 1
d691 5
a695 2
		val p = Timer.xtime("decoding encapsulated parser env",! print_timings andalso ! print_minor_timings,
                                    fn () => Encapsulate.decode_parser_env p_env)
d709 6
a714 17
		val t = Timer.xtime("decoding encapsulated type basis", ! print_timings andalso ! print_minor_timings,
                                    fn () => Encapsulate.decode_type_basis (t_env,require_list))
(*
		val _ = Print.print"Resetting counters\n"
		val _ = Print.print("tyname_count = " ^
				    Integer_.makestring tyname_count ^
				    "\ntynames = " ^
				    Integer_.makestring tynames ^
				    "\nstrname_count = " ^
				    Integer_.makestring strname_count ^
				    "\nstrnames = " ^
				    Integer_.makestring strnames ^
				    "\ntyfun_count = " ^
				    Integer_.makestring tyfun_count ^
				    "\ntyfuns = " ^
				    Integer_.makestring tyfuns ^ "\n")
*)
d718 6
a723 6
(*
		val _ = Print.print"Reset counters\n"
*)
		val l = Timer.xtime("decoding encapsulated lambda environment", 
                                    ! print_timings andalso ! print_minor_timings,
                                    fn () => Encapsulate.decode_lambda_env l_env)
a889 8
(*
      val _ = Print.print("tyname_count this module = " ^
			  Integer_.makestring tyname_count ^
			  "\nstrname_count this module = " ^
			  Integer_.makestring strname_count ^
			  "\ntyfun_count this module = " ^
			  Integer_.makestring tyfun_count ^ "\n")
*)
d1022 2
a1023 1
        Timer.xtime("Encoding lambda environment", ! print_timings andalso ! print_minor_timings,
d1026 4
a1029 2
        Timer.xtime("Encoding type basis", ! print_timings andalso ! print_minor_timings,
                    fn () => Encapsulate.encode_type_basis (type_basis,require_list))
d1031 2
a1032 1
        Timer.xtime("Encoding parser environment", ! print_timings andalso ! print_minor_timings,
a1033 5
(*
      val tyname_count = Tyname_id.read_counter ()
      val strname_count = Strname_id.read_counter ()
      val tyfun_count = Tyfun_id.read_counter ()
*)
d1035 2
a1036 1
        Timer.xtime("Encapsulating environments", ! print_timings andalso ! print_minor_timings,
d1038 3
a1040 2
                    {parser_env=enc_p_env, ty_env=enc_t_env, lambda_env=enc_l_env,
                     tynames=tyname_count, strnames=strname_count, tyfuns=tyfun_count})
d1043 2
a1044 1
        Timer.xtime("Encapsulating requires", ! print_timings andalso ! print_minor_timings,
d1047 1
a1047 1
	Timer.xtime("Outputing", ! print_timings andalso ! print_minor_timings,
@


1.67
log
@*** empty log message ***
@
text
@d4 3
d412 2
d494 1
a494 1
		    LambdaTypes.APP(LambdaTypes.FN(lv, _), le)) =
d505 1
a505 1
  | check_binding(bindings, le as LambdaTypes.FN(lv, _)) =
d818 1
a818 1
		val token_stream = Lexer.mkTokenStream(lex_fun)
d873 1
a873 1
      val ts = Lexer.mkTokenStream input_fn
d985 1
a985 1
                    fn () => Mir_Cg.mir_cg(opt_lambda_exp, top_env))
@


1.66
log
@Slight change to parsing error message
@
text
@d4 3
d677 2
a678 1
		  Timer.xtime("decoding encapsulation", ! print_timings andalso ! print_minor_timings,
@


1.65
log
@Changed an instance of LambdaTypes_ to LambdaTypes
@
text
@d4 3
d642 1
a642 1
              (Print.print("ParseError " ^ x ^ "\n"); raise exn)
@


1.64
log
@Added bool ref for add_fn_names to control addition of function names
@
text
@d4 3
d859 1
a859 1
      val _ = LambdaTypes_.init_LVar()
@


1.63
log
@Fixed problem whereby tyname_count, strname_count, tyfun_count overflowed
@
text
@d4 3
d329 1
@


1.62
log
@Added some functions to check lambda calculus consistency
@
text
@d4 3
d498 1
a498 1
  fun compile_program (path, ts, initial,do_pervasive_library) = 
d625 2
a626 1
      fun compile_topdec(path, require_list, CB(p, t, c),parse) =
d664 1
a664 1
		  Timer.xtime("Decoding encapsulation", ! print_timings andalso ! print_minor_timings,
d667 1
a667 1
		val p = Timer.xtime("Decoding encapsulated parser env",! print_timings andalso ! print_minor_timings,
d682 1
a682 1
		val t = Timer.xtime("Decoded encapsulated type basis", ! print_timings andalso ! print_minor_timings,
d684 15
a698 1

d702 4
a705 1
		val l = Timer.xtime("Decoding encapsulated lambda environment", 
d711 2
a712 1
		(require_list, [my_stamp], decls, CB(p, t, top_env), empty_cb)
d736 3
d744 3
a746 1
		(require_list, [], declarations, empty_cb, CB(p',t',c'))
d755 1
a755 1
			     compiled_cb,parse,eof) = 
d757 2
a758 1
	    val (require_list, requires, declarations, req_cb, comp_cb) =
d760 2
a761 1
			     augment_cb(initial_cb, compiled_cb),parse)
d768 1
a768 1
	      (require_list, reqs', code', compiled_cb')
d771 1
a771 1
			       compiled_cb',parse,eof)
d776 1
d778 38
a815 33
      val (require_list, reqs_list, decls_list, CB(pbasis, basis, top_env)) =
        (if eof()
           then 
             ([], [], [], empty_cb)
         else
           if do_pervasive_library
             then
               let
                 val _ =
                   output(std_out,"Implicitly requiring the pervasive_library\n")
                 val the_expression = ref ""
                 val _ = the_expression :=
                   "require \"" ^ root_name(! pervasive_library_path) 
                   ^ "\" ; open FullPervasiveLibrary_ "
                 fun lex_fun () = 
                   let
                     val a = ! the_expression
                   in
                     the_expression := "";
                     a
                   end
                 val token_stream = Lexer.mkTokenStream(lex_fun)
                 val (require_list, reqs_list, decls_list, full_env as CB(pbasis, basis, top_env)) =
                   compile_topdecs'(path, [], [], [], initial, initial_cgb_for_normal_file,
                                    fn pb => Parser.parse_topdec
                                    (token_stream,pb),fn () => Lexer.eof token_stream)
               in
                 compile_topdecs'(path, require_list, reqs_list, decls_list, full_env, 
                                  (* CB(pbasis,basis,Environ.empty_top_env), *)
                                  empty_cb,parse,eof)
               end
           else
             compile_topdecs'(path, [], [], [], initial, empty_cb,parse,eof))
d824 2
a825 1
      (require_list, reqs_list, lambda_exp, CB(pbasis, basis, top_env'))
d870 12
a881 2
	   cb' as CB(parser_env, type_basis, top_env)) =
	compile_program (compilation_path filename, ts, initial_cb,! do_pervasive_library)
d1022 1
d1026 1
a1026 1

@


1.61
log
@Added show_match to control printing of match trees
@
text
@d4 3
d232 1
d261 6
d274 1
a283 6
  structure Tyname_id : TYNAME_ID
  structure Tyfun_id : TYFUN_ID
  structure Strname_id : STRNAME_ID
  structure Types : TYPES
  structure Strenv : STRENV
  structure Valenv : VALENV
d289 1
a289 1
  sharing Absyn.Set = Basis.Set = Environ.Set = Primitives.Set
d297 1
a297 1
    Mir_Cg.LambdaTypes
d320 1
d439 22
a460 21
fun relative_name(path, name) =
  case String.substring(name, 0, 1) of
    "/" => name
      (* Handle case of require via absolute pathname *)
  | _ => 
      let
	fun join path name =
	  if size name < 3 orelse path = "" then path ^ name
	  else
	    case String.substring(name, 0, 3) of
	      "../" =>
		let
		  val prepath =
		    compilation_path(String.substring(path, 0, size path - 1))
		in
		  join prepath (String.substring(name, 3, size name - 3))
		end
	    | _ => path ^ name
      in
	join path name
      end
d462 33
d849 4
d859 4
@


1.60
log
@Rewrote end_is function in terms of functions already defined
@
text
@d4 3
d385 2
a386 1
      
@


1.59
log
@Changes to reflect changes in MirOptimiser signature.
@
text
@d4 3
d748 2
a749 8
  fun end_is (x,y) = 
    let
      val y = sml_name y
    in
      if size(x) > size(y)
        then false
      else String.substring(y,size(y)-size(x),size(x)) = x
    end
d755 1
a755 1
        if end_is(builtin_library,filename)
d761 1
a761 1
          if end_is("__callc_codes.sml",filename)
d766 1
a766 1
            if end_is("__pervasive_library.sml",filename)
d830 1
a830 1
        if end_is(builtin_library,filename)
d906 1
a906 1
        if end_is(builtin_library,filename)
@


1.58
log
@root_name applied to pervasive_library_path before requiring it
@
text
@d4 3
d293 3
a295 3
  sharing Mach_Cg.Map = MirOptimiser.MirRegisters.Map
  sharing Mach_Cg.MirTypes = MirOptimiser.MirRegisters.MirTypes
  sharing Mach_Cg.MachSpec = MirOptimiser.MirRegisters.MachSpec
d899 1
a899 1
	  val assign = MirOptimiser.MirRegisters.machine_register_assignments
@


1.57
log
@Needed an extra newline in one of the print statements
@
text
@d4 3
d710 2
a711 1
                   "require \"" ^ ! pervasive_library_path ^ "\" ; open FullPervasiveLibrary_ "
@


1.56
log
@New pervasive library code
@
text
@d4 3
d952 1
a952 1
                            then output(std_out,"Compiling " ^ sml_name)
@


1.55
log
@Changed Table to Map to reflect changes in MirRegisters.
@
text
@d4 3
d207 1
d263 1
d265 1
a265 1
  sharing Basis.Datatypes = Absyn.Datatypes
d299 1
d305 4
d319 12
d334 16
a349 1
  (* this codegen basis will not cope with code including exceptions *)
d439 1
a439 1
  fun compile_program (path, ts, initial) = 
a440 2
      fun parse pb = Parser.parse_topdec (ts,pb)
      fun eof () = Lexer.eof ts
d460 3
a462 1
		  val field = get_field y
d466 5
a470 3
		  (LambdaTypes.LET(lvar, LambdaTypes.SELECT(field, var_main_lvar)) ::
		   bindings,
		   (x, replace_field(y, lvar)) :: env,
d476 2
a477 1
	  fun ident(EnvironTypes.FIELD x) = x
d479 1
a479 1
	  fun replace_ident(x, lvar) = EnvironTypes.LAMB lvar
d482 1
a482 1
	    (EnvironTypes.LAMB lvar, interface, env)
d485 1
a485 1
	    (env, EnvironTypes.LAMB lvar)
d489 1
a489 1
					LambdaTypes.SCON(Ident.STRING s)))
d566 1
a566 1
      fun compile_topdec(path, require_list, CB(p, t, c)) =
d575 1
a575 1
	  case topdec of
d664 1
a664 1
	      end
a670 1
      local
d672 1
a672 1
			     compiled_cb) = 
d676 1
a676 1
			     augment_cb(initial_cb, compiled_cb))
d686 1
a686 1
			       compiled_cb')
d688 4
a691 8
      in
	fun compile_topdecs path =
	  if eof() then
	    ([], [], [], empty_cb)
	  else
	    compile_topdecs'(path, [], [], [], initial, empty_cb)
      end
       
d693 32
a724 1
	compile_topdecs path
d735 9
d746 19
d784 1
a784 1
	compile_program (compilation_path filename, ts, initial_cb)
d822 37
d898 8
d944 1
a944 1
    Timer.xtime("Total time for compilation", ! print_timings,
d948 3
@


1.54
log
@Removed sharing constraint on Parser.Ident (no longer there)
@
text
@d4 3
d279 1
a279 1
  sharing Mach_Cg.Table = MirOptimiser.MirRegisters.Table
@


1.53
log
@Nextened the printing
@
text
@d4 3
d258 1
a258 1
  sharing Absyn.IdentClass = Parser.Ident = LambdaTypes.Ident = Ident =
a512 5
(*
	      val _ = Print.print"do_subrequires resetting counters\n"
	      val _ = Print.print("Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n")
	      val _ = Print.print("Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n")
*)
a584 5
(*
		val _ = Print.print"REQUIREtopdec resetting counters\n"
		val _ = Print.print("Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n")
		val _ = Print.print("Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n")
*)
a656 4
(*
      val _ = Print.print("Making top_env from decls_list length " ^ Integer.makestring(length decls_list) ^ "\n")
      val _ = Print.print("Using current top_env\n" ^ (EnvironPrint.printtopenv top_env))
*)
a738 1

@


1.52
log
@Added timing to the various sections
@
text
@d4 3
d532 1
a532 1
	  val _ = diagnose_simple"Parsing complete\n"
d621 1
a621 1
		val _ = diagnose_simple"Typechecking complete\n"
d625 1
a625 1
		val _ = diagnose_simple"Lambda translation complete\n"
d719 1
a719 1
      val _ = diagnose_simple"Lambda optimisation complete\n"
d740 1
a740 1
      val _ = diagnose_simple"Mir translation complete\n"
d755 1
a755 1
      val _ = diagnose_simple"Mir optimisation complete\n"
d776 1
a776 1
      val _ = diagnose_simple"Machine code translation complete\n"
d817 1
a817 1
                  val _ = diagnose_simple("Compiling " ^ sml_name ^ "\n")
@


1.51
log
@Added option not to do lambda optimisation
@
text
@d4 3
d184 1
d221 1
d287 2
d524 5
a528 2
	  val (topdec,p') = parse p handle exn as Parser.ParseError x =>
	    (Print.print("ParseError " ^ x ^ "\n"); raise exn)
d560 2
a561 1
		  Encapsulate.decode_env env
d563 2
a564 1
		val p = Encapsulate.decode_parser_env p_env
d578 2
a579 1
		val t = Encapsulate.decode_type_basis (t_env,require_list)
d589 3
a591 1
		val l = Encapsulate.decode_lambda_env l_env
d606 2
a607 1
		val t' = Mod_Rules.check_topdec(topdec,t)
d614 2
a615 2
		    ["The abstract syntax\n",
		     TopdecPrint.topdec_to_string topdec])
d617 1
a617 1

d619 3
a621 1
		val (c', declarations) = Lambda.trans_top_dec (topdec,c)
d666 3
a668 1
	Lambda.complete_struct_from_topenv(top_env, decls_list)
d711 2
a712 1
	  LambdaOptimiser.optimise lambda_exp
d733 3
a735 1
      val the_mir_code = Mir_Cg.mir_cg(opt_lambda_exp, top_env)
d749 2
a750 1
	MirOptimiser.optimise the_mir_code;
d766 5
a770 4
	  Mach_Cg.mach_cg(the_optimised_code,
			  (#gc assign,
			   #non_gc assign,
			   #fp assign))
d775 9
a783 3
      val enc_l_env = Encapsulate.encode_lambda_env top_env
      val enc_t_env = Encapsulate.encode_type_basis (type_basis,require_list)
      val enc_p_env = Encapsulate.encode_parser_env parser_env
d789 4
a792 3
	Encapsulate.encode_env
	{parser_env=enc_p_env, ty_env=enc_t_env, lambda_env=enc_l_env,
	 tynames=tyname_count, strnames=strname_count, tyfuns=tyfun_count}
d794 3
a796 1
      val cons = Encapsulate.encode_cons requires
d798 8
a805 7
	Encapsulate.output_file
	(output_name,
	 Encapsulate.TOTAL_OUTPUT
	 {code = Encapsulate.encode_code the_machine_code,
	  env = enc_env,
	  debug = "",
	  consistency = Encapsulate.encode_cons requires})
d811 10
a820 9
    let
      val sml_name = sml_name filename
      val _ = diagnose_simple("Compiling " ^ sml_name ^ "\n")
      val instream = open_in sml_name
      val result = do_input(fn () => input_line instream, sml_name)
	handle exn => (close_in instream; raise exn)
    in
      close_in instream
    end  
@


1.50
log
@Modified to deal with absolute pathnames in requires
@
text
@d4 3
d281 2
d689 5
a693 1
      val opt_lambda_exp = LambdaOptimiser.optimise lambda_exp
d715 1
a752 5
(*
      val _ = Print.print("Encoded p_env size = " ^ Integer.makestring(size enc_p_env))
      val _ = Print.print("Encoded t_env size = " ^ Integer.makestring(size enc_t_env))
      val _ = Print.print("Encoded l_env size = " ^ Integer.makestring(size enc_l_env))
*)
a762 4
(*
      val _ = Print.print("Encoded cons size = " ^ Integer.makestring(size cons))
      val _ = Print.print("Encoded env size = " ^ Integer.makestring(size enc_env))
*)
a770 26
(*
      val {parser_env=enc_p_env', ty_env=enc_t_env', lambda_env=enc_l_env'} =
	Encapsulate.decode_env enc_env

      val _ = Print.print"Decoded total env"
      val _ = Print.print("Decoded p_env size = " ^ Integer.makestring(size enc_p_env'))
      val _ = Print.print("Decoded t_env size = " ^ Integer.makestring(size enc_t_env'))
      val _ = Print.print("Decoded l_env size = " ^ Integer.makestring(size enc_l_env'))

      val top_env' = Encapsulate.decode_lambda_env enc_l_env'

      val _ = Print.print"Decoded lambda env"
      val _ =
	if (!show_environ) then
	  (Print.print"The decoded environment\n";
	   Print.print (EnvironPrint.printtopenv top_env'))
	else ()

      val parser_env' = Encapsulate.decode_parser_env enc_p_env'

      val _ = Print.print"Decoded parser env"

      val type_basis' = Encapsulate.decode_type_basis enc_t_env'

      val _ = Print.print"Decoded typechecker basis"
*)
@


1.49
log
@Changed to encode tyfun_ids similarly to tyname_ids
@
text
@d4 3
d360 20
a379 16
  let
    fun join path name =
      if size name < 3 orelse path = "" then path ^ name
      else
	case String.substring(name, 0, 3) of
	  "../" =>
	    let
	      val prepath =
		compilation_path(String.substring(path, 0, size path - 1))
	    in
	      join prepath (String.substring(name, 3, size name - 3))
	    end
	| _ => path ^ name
  in
    join path name
  end
@


1.48
log
@Moved info about reset of tyname and strname counters to level 3
@
text
@d4 3
d235 1
d455 1
a455 1
	    | encountered ((name,_,_)::rest) =
d473 1
a473 1
	      val {tynames = tynames, strnames = strnames, ...} = 
d483 1
d487 1
d494 3
a496 2
	      do_subrequires ((comp_name,tyname_count,strname_count) :: 
			      require_list, path, cons)
d537 1
a537 1
		     tynames = tynames, strnames = strnames} =
d547 1
d550 2
a551 1
		  (compilation_name root,tyname_count,strname_count) ::
d558 1
d574 1
d576 2
a577 1
		  ("",tyname_count,strname_count) :: require_list
d649 1
d743 1
d748 1
a748 1
	 tynames=tyname_count, strnames=strname_count}
@


1.47
log
@Added call to clean_basis to remove old encodings of pervasives
@
text
@d4 3
d482 1
d486 1
d549 1
d553 1
a553 1

d639 1
a639 1
      val _ = Diagnostic.output 2 (fn _ => ["Cleaning refs in initial basis"])
d642 1
a642 1
      val _ = Diagnostic.output 2 (fn _ => ["Cleaned refs in initial basis"])
d644 2
a645 2
      val _ = Diagnostic.output 2 (fn _ => ["Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n"])
      val _ = Diagnostic.output 2 (fn _ => ["Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n"])
@


1.46
log
@Added various diagnostics
@
text
@d4 3
d279 1
a279 1
    CB (Parser.initial_pB ,Basis.initial_basis , initial_cgb)
d633 7
a639 2
      val _ = Print.print("Tyname_id reset to " ^ Integer.makestring(Tyname_id.read_counter()) ^ "\n")
      val _ = Print.print("Strname_id reset to " ^ Integer.makestring(Strname_id.read_counter()) ^ "\n")
@


1.45
log
@added call to reset_assemblies before each compilation.
@
text
@d4 3
d165 1
d201 1
d263 1
d280 2
d476 3
d492 1
a492 1
	  val _ = Print.print"Parsing complete\n"
d541 3
d563 4
a566 2
		    Print.print("The abstract syntax\n" ^
				TopdecPrint.topdec_to_string topdec)
d569 1
a569 1
		val _ = Print.print"Typechecking complete\n"
d571 1
a571 1
		val _ = Print.print"Lambda translation complete\n"
d630 2
d644 4
a647 2
	  (Print.print "The lambda code\n";
	   LambdaPrint.print_lambda lambda_exp)
d652 1
a652 1
      val _ = Print.print"Lambda optimisation complete\n"
d655 4
a658 2
	  (Print.print "The optimised lambda code\n";
	   LambdaPrint.print_lambda opt_lambda_exp)
d663 4
a666 2
	  (Print.print"The environment\n";
	   Print.print (EnvironPrint.printtopenv top_env))
d671 1
a671 1
      val _ = Print.print"Mir translation complete\n"
d674 4
a677 2
	  (Print.print("The unoptimised intermediate code\n");
	   Print.print(MirPrint.print_mir_code the_mir_code))
d684 1
a684 1
      val _ = Print.print"Mir optimisation complete\n"
d687 4
a690 2
	  (Print.print("The optimised intermediate code\n");
	   Print.print(MirPrint.print_mir_code the_optimised_code))
d704 1
a704 1
      val _ = Print.print"Machine code translation complete\n"
d756 1
a756 2
*)
(*
d768 1
a768 1
      val _ = Print.print ("Compiling " ^ sml_name ^ "\n")
@


1.44
log
@Added code to maintain unique tyname and strname_ids across modules.
@
text
@d4 3
d614 2
@


1.43
log
@Added recursive loading of typechecker bases for requires
@
text
@d4 3
d166 3
d217 4
d428 2
a429 4
      fun do_subrequires(require_list_so_far, tc_basis, _, []) =
	(require_list_so_far, tc_basis)
      | do_subrequires(require_list_so_far, tc_basis, path,
		       (name, stamp) :: cons) =
d432 8
d441 1
a441 1
	  if Lists.member(comp_name, require_list_so_far) then
d443 1
a443 1
	    do_subrequires(require_list_so_far, tc_basis, path, cons)
d447 2
a448 1
	      val full_name = relative_name(path, mo_name)
d452 13
a464 6
	      val {ty_env=t_env, ...} = Encapsulate.decode_env env
	      val (require_list_so_far, tc_basis) =
		do_subrequires(require_list_so_far, tc_basis,
			       compilation_path full_name,
			       case cons' of [] => [] | _ :: tl => tl)
	      val t = Encapsulate.decode_type_basis t_env
d466 2
a467 3
	      do_subrequires(comp_name :: require_list_so_far,
			     Basis.basis_circle_plus_basis(tc_basis, t),
			     path, cons)
d484 3
a486 1
		val full_name = relative_name(path, mo_name)
d489 3
a492 3
		val {parser_env=p_env, ty_env=t_env, lambda_env=l_env} =
		  Encapsulate.decode_env env
		val root = root_name s
d501 10
d512 16
a527 1
		val t = Encapsulate.decode_type_basis t_env
d529 1
a529 4
		val (decls, top_env) = require_lambdas(name, l)
		val (require_list, t_basis) =
		  do_subrequires(require_list, Basis.empty_basis,
				 compilation_path full_name, cons)
d532 1
a532 3
		(compilation_name root :: require_list, [my_stamp], decls,
		 CB(p, Basis.basis_circle_plus_basis(t_basis, t), top_env),
		 empty_cb)
d536 5
d575 1
a575 1
	      (reqs', code', compiled_cb')
d583 1
a583 1
	    ([], [], empty_cb)
d588 1
a588 1
      val (reqs_list, decls_list, CB(pbasis, basis, top_env)) =
d599 1
a599 1
      (reqs_list, lambda_exp, CB(pbasis, basis, top_env'))
d607 6
a612 2
	  
      val (requires, lambda_exp, cb' as CB(parser_env, type_basis, top_env)) =
d674 1
a674 1
      val enc_t_env = Encapsulate.encode_type_basis type_basis 
d681 3
d685 4
a688 2
	Encapsulate.encode_env{parser_env=enc_p_env, ty_env=enc_t_env,
			       lambda_env=enc_l_env}
d702 1
d705 1
a705 1
(*
d710 1
a710 1
*)
d712 1
a712 1
(*
d719 1
a719 1
*)
d721 1
a721 1
(*
d724 1
d726 1
a726 1
(*
d736 1
@


1.42
log
@Changed to use new binding type
@
text
@d4 3
a347 3
      (* compile_topdec takes the first topdec from the input
       stream and compiles it *)
	  
d418 30
d451 1
a451 1
      fun compile_topdec(path, CB(p, t, c)) =
d467 2
a468 1
		val my_stamp as (name, stamp) = case cons of
d473 1
a473 1
		      (s, (0, 0))
d475 1
a475 1
		| (_, stamp) :: _ => (root_name s, stamp)
d480 3
d485 3
a487 1
		([my_stamp], decls, CB(p, t, top_env), empty_cb)
d504 1
a504 1
		([], declarations, empty_cb, CB(p',t',c'))
d513 2
a514 1
	fun compile_topdecs'(path, reqs, code, initial_cb, compiled_cb) = 
d516 3
a518 2
	    val (requires, declarations, req_cb, comp_cb) =
	      compile_topdec(path, augment_cb(initial_cb, compiled_cb))
d527 2
a528 1
	      compile_topdecs'(path, reqs', code', initial_cb', compiled_cb')
d535 1
a535 1
	    compile_topdecs'(path, [], [], initial, empty_cb)
@


1.41
log
@Fixed bug whereby the wrong object file name was being used
@
text
@d3 4
a6 1
$Log:	_toplevel.sml,v $
d370 1
a370 1
		  ((lvar, LambdaTypes.SELECT(field, var_main_lvar)) ::
d388 1
a388 1
	    (main_lvar, LambdaTypes.APP(LambdaTypes.BUILTIN
@


1.40
log
@Added file time stamp checking
@
text
@d4 3
d518 1
a518 2
      val the_name = root_name filename
      val sec_time = case Unix.mtime the_name of
a521 1
      (* Later put real timestamps here *)
@


1.39
log
@Added separation of required environments from generated ones. This may
need further thought.
@
text
@d4 4
d141 1
d173 1
d316 18
a423 3
(*
		val _ = Print.print("require \"" ^ s ^ "\"")
*)
d425 1
d427 1
a427 6
		  Encapsulate.input_file(path ^ mo_name)
(*
		val _ = Print.print"Read the envs"
		val _ = Print.print("Cons size = " ^ Integer.makestring(size cons))
		val _ = Print.print("Env size = " ^ Integer.makestring(size env))
*)
a428 3
(*
		val _ = Print.print"Decoded consistency"
*)
a430 6
(*
		val _ = Print.print"Split the env"
		val _ = Print.print("p_env size = " ^ Integer.makestring(size p_env))
		val _ = Print.print("t_env size = " ^ Integer.makestring(size t_env))
		val _ = Print.print("l_env size = " ^ Integer.makestring(size l_env))
*)
d438 1
a438 1
		| x :: _ => x
a439 3
(*
		val _ = Print.print"Decoded parser_env"
*)
a440 3
(*
		val _ = Print.print"Decoded type_basis"
*)
a441 3
(*
		val _ = Print.print"Decoded parser_env"
*)
d471 1
a471 1
	fun compile_topdecs'(path, initial_cb, compiled_cb) = 
d477 2
d481 1
a481 1
	      (requires, declarations, comp_cb)
d483 1
a483 7
	      let
		val (rest_reqs, rest_decs, rest_cb) =
		  compile_topdecs'(path, initial_cb', compiled_cb')
	      in
		(requires @@ rest_reqs, declarations @@ rest_decs,
		 augment_cb(comp_cb, rest_cb))
	      end
d490 1
a490 1
	    compile_topdecs'(path, initial, empty_cb)
d511 1
a511 1
      val ts = Lexer.mkTokenStream (input_fn)
d515 5
a519 2
      val requires =
	(compilation_name filename, (0, 0)) :: requires
@


1.38
log
@Added full parsing and handling of require topdecs, including
rebuilding the environments and makeing the new bindings
@
text
@d4 4
d10 1
a10 1
require topdec handling
d278 3
a280 2
      if final_name <> ".sml" then filename
      else String.substring(filename, 0, len-4)
d294 8
d310 1
a310 1
  fun compile_program (ts, initial) = 
d362 1
a362 1
	    get_new_binding_and_env([main_binding], [], get_field_from_funenv,
d384 2
a385 1
	  (bindings, EnvironTypes.TOP_ENV(new_val_env, new_fun_env))
d388 4
a391 1
      fun compile_topdec (CB(p, t, c)) =
d405 1
a405 1
		  Encapsulate.input_file mo_name
d446 1
a446 1
		([my_stamp], decls, CB(p, t, top_env))
d463 1
a463 1
		([], declarations, CB(p',t',c'))
d472 1
a472 1
	fun compile_topdecs' cb = 
d474 4
a477 3
	    val (requires, declarations, cb') =
	      compile_topdec (augment_cb(initial,cb))
	    val cb'' = augment_cb(cb, cb')
d480 1
a480 1
	      (requires, declarations, cb')
d483 2
a484 1
		val (rest_reqs, rest_decs, rest_cb) = compile_topdecs' cb''
d487 1
a487 1
		 augment_cb(cb', rest_cb))
d491 1
a491 1
	fun compile_topdecs () =
d495 1
a495 1
	    compile_topdecs' empty_cb
d499 1
a499 1
	compile_topdecs ()
d501 4
a507 21
(*
      val load_string =
	case
	  Environ.lookup_valid
	  (Ident.VAR(Symbol.find_symbol"_load_string"),
	   Primitives.initial_env)
	of
	  EnvironTypes.PRIM load_string => load_string
	| _ => Crash.impossible "Couldn't find PRIM load_string"

      val lvar = LambdaTypes.new_LVar()

      (* Here we must find all the external references within lambda_exp
       and abstract them out wrt the above lambda. Not done yet *)

      val top_lambda =
	LambdaTypes.APP(LambdaTypes.FN(lvar, lambda_exp),
	 LambdaTypes.STRUCT(map
          (fn (s, _) => LambdaTypes.APP(LambdaTypes.BUILTIN load_string,
           LambdaTypes.SCON(Ident.STRING s))) reqs_list))
*)
d519 1
a519 1
	compile_program (ts, initial_cb)
@


1.37
log
@Added environment and consistency info reading and writing, and
require topdec handling
@
text
@d4 4
d137 1
a157 1
require "../machine/machprint";
d159 1
d166 1
d168 1
a168 1
  structure Print : PRINT
a187 1
  structure MachPrint : MACHPRINT
d190 1
d217 1
d281 4
d286 1
a286 2
      (* Later will strip of preceding pathanme components *)
      root
d305 69
d378 1
a378 1
	  val _ = print"Parsing complete"
d383 3
a385 1
		val _ = print("require \"" ^ s ^ "\"")
d389 5
a393 2
		val _ = print"Read the envs"
		val _ = print("Cons size = " ^ Integer.makestring(size cons))
d395 3
a397 1
		val _ = print"Decoded consistency"
d400 7
a406 2
		val _ = print"Split the env"
		val my_stamp = case cons of
d409 1
a409 1
		      val _ = print"Strange, no consistency info"
d415 3
a417 1
		val _ = print"Decoded parser_env"
d419 3
a421 1
		val _ = print"Decoded type_basis"
d423 4
a426 1
		val _ = print"Decoded parser_env"
d429 1
a429 1
		([my_stamp], [], CB(p, t, l))
d442 1
a442 1
		val _ = print"Typechecking complete"
d444 1
a444 1
		val _ = print"Lambda translation complete"
d474 1
a474 1
	    ([], [],empty_cb)
d485 1
d505 1
d530 1
a530 1
      val _ = print"Lambda optimisation complete"
d545 1
a545 1
      val _ = print"Mir translation complete"
d556 1
a556 1
      val _ = print"Mir optimisation complete"
d574 1
a574 1
      val _ = print"Machine code translation complete"
d579 5
d588 4
a591 1
      val _ = print("Encoded cons size = " ^ Integer.makestring(size cons))
d602 6
a607 1
      val _ = print"Decoded total env"
d609 2
a610 1
      val _ = print"Decoded lambda env"
d616 1
d618 3
a620 1
      val _ = print"Decoded parser env"
d622 3
a624 1
      val _ = print"Decoded typechecker basis"
@


1.36
log
@Added output of encode typechecker basis
@
text
@d4 3
d259 11
a269 2
  fun drop (n, []) = []
  | drop (n, arg as x::xs) = if n <= 0 then arg else drop(n-1, xs)
d271 16
d299 44
a342 3
	  val t' = Mod_Rules.check_topdec(topdec,t)
	    handle exn as Mod_Rules.Check_topdec x =>
	      (Print.print"Module rules error"; raise exn)
d344 7
a350 12
	  val _ =
	    if (!show_absyn) then
	      Print.print("The abstract syntax\n" ^
			  TopdecPrint.topdec_to_string topdec)
	    else ()

	  val (c', declarations) = Lambda.trans_top_dec (topdec,c)
	  val _ = print"Lambda translation complete"
	in
	  ([], declarations, CB(p',t',c')) (* Extra value will be requires *)
	end
	
d404 1
a404 1
          (fn s => LambdaTypes.APP(LambdaTypes.BUILTIN load_string,
d407 1
a407 1
      (lambda_exp, CB(pbasis, basis, top_env'))
d416 1
a416 1
      val (lambda_exp, cb' as CB(parser_env, type_basis, top_env)) =
d418 3
d475 1
a475 13
      val output_name =
	let
	  val name_size = size filename
	in
	  if name_size = 0 then
	    "test.mo"
	  else
	    let
	      val root = String.substring(filename, 0, name_size-4)
	    in
	      root ^ ".mo"
	    end
	end
d482 2
d491 1
a491 1
	  consistency = ""})
d512 1
a512 7
      fun drop (n, []) = []
	| drop (n, arg as x::xs) = if n <= 0 then arg else drop(n-1, xs)
      val exp_filename = explode filename
      val final_name = drop(length exp_filename - 4, exp_filename)
      val sml_name =
	if implode final_name <> ".sml" then filename ^ ".sml"
	else filename
@


1.35
log
@Added writing of parser env to output file, and rereading it.
@
text
@d4 3
d193 1
a193 1
  sharing Basis = Mod_Rules.Basis
d352 1
a352 1
      val (lambda_exp, cb' as CB(parser_env, _, top_env)) =
d422 1
a422 1
      val enc_t_env = ""
d447 2
@


1.34
log
@Added some progress messages
@
text
@d4 3
d204 1
d349 1
a349 1
      val (lambda_exp, cb' as CB(_, _, top_env)) =
d420 1
a420 1
      val enc_p_env = ""
d436 1
d442 2
d482 1
a482 1
end;
@


1.33
log
@Added output of environment
@
text
@d4 3
d356 1
d371 1
d382 1
d400 1
@


1.32
log
@Added some newline characters that were bugging me by their absence.
@
text
@d4 3
d189 2
a190 1
    Primitives.EnvironTypes = EnvironPrint.EnvironTypes = Mir_Cg.EnvironTypes
d272 1
d407 6
d418 1
a418 1
	  env = "",
d421 9
@


1.31
log
@Removed references to fp_doubles.
@
text
@d4 3
d256 1
a256 1
	    (Print.print("ParseError " ^ x); raise exn)
d342 1
a342 1
	  (Print.print "The lambda code";
d350 1
a350 1
	  (Print.print "The optimised lambda code";
d356 1
a356 1
	  (Print.print"The environment";
d364 1
a364 1
	  (Print.print("The unoptimised intermediate code");
d374 1
a374 1
	  (Print.print("The optimised intermediate code");
@


1.30
log
@Added show_mach to refer to corresponding item in mach_cg, so we can off
opcode listings
@
text
@d4 4
d383 1
a383 2
			   #fp assign,
			   #fp_double assign))
@


1.29
log
@Added production of output file names for compile function,
so <name>.sml -> <name>.mo
@
text
@d4 4
d227 1
a227 1
  val show_mach       = ref true
d229 5
a233 5
  (* compile program takes a token stream and an initial compiler
   basis (which should be constructed from the included files) nd returns
   a load and a final compiler basis. The load is a Ten15 tuple and the
   cb contains those vars and strs declared in the stream, with names
   giving the indices into the tuple *)
@


1.28
log
@Changed lots of pervasive prints to Print.print.
@
text
@d4 3
d105 2
d135 1
d231 3
d320 1
a320 1
  fun do_input input_fn =
d379 13
d394 1
a394 1
	("test.mo",
d414 1
a414 1
      val result = do_input(fn ()  => input_line instream)
d424 1
a424 1
      do_input (fn () => if !done then "" else (done := true; x))
@


1.27
log
@Stopped default printing out of mir code (it took too long).
Fixed an non-exhaustive binding using a Crash.impossible.
@
text
@d4 4
d130 1
a179 1

d186 2
a187 1
  datatype compiler_basis = CB of (Parser.ParserBasis * Basis.Basis * EnvironTypes.Top_Env)
d189 2
a190 1
  val empty_cb = CB (Parser.empty_pB, Basis.empty_basis, Environ.empty_top_env)
d193 2
a194 3
    EnvironTypes.TOP_ENV(Primitives.initial_env,
      EnvironTypes.FUN_ENV Map.empty_map)
  val initial_cb = CB (Parser.initial_pB ,Basis.initial_basis , initial_cgb)
d196 4
a199 1
(* this codegen basis will not cope with code including exceptions *)
d236 1
a236 1
	    (print("ParseError " ^ x); raise exn)
d239 1
a239 1
	      (print"Module rules error"; raise exn)
d241 5
a245 4
	  val _ = if (!show_absyn)
		      then print("The abstract syntax\n" ^
				 TopdecPrint.topdec_to_string topdec)
		  else ()
d271 1
a271 1
		  augment_cb(cb', rest_cb))
d284 1
d287 1
d296 1
d298 1
d301 1
d304 3
a306 3
	  LambdaTypes.STRUCT(map
            (fn s => LambdaTypes.APP(LambdaTypes.BUILTIN load_string,
	      LambdaTypes.SCON(Ident.STRING s))) reqs_list))
d314 1
a314 3
(*
      val _ = LambdaTypes_.init_Prim()
*)
d320 5
a324 4
      val _ = if (!show_lambda)
		 then (print "The lambda code";
		       LambdaPrint.print_lambda lambda_exp)
	      else ()
d328 5
a332 4
      val _ = if (!show_opt_lambda)
		 then (print "The optimised lambda code";
		       LambdaPrint.print_lambda opt_lambda_exp)
	      else ()
d334 5
a338 4
      val _ = if (!show_environ)
		 then (print"The environment";
		       print (EnvironPrint.printtopenv top_env))
	      else ()
d343 6
a348 5
      if (!show_mir) then
	(print("The unoptimised intermediate code");
	 print(MirPrint.print_mir_code the_mir_code))
      else
	()
d351 1
d354 2
a355 2
	  (print("The optimised intermediate code");
	   print(MirPrint.print_mir_code the_optimised_code))
d358 1
d369 1
d378 3
a380 1
    in () end
d383 15
a397 15
  let
    fun drop (n, []) = []
    | drop (n, arg as x::xs) = if n <= 0 then arg
			       else drop(n-1, xs)
    val exp_filename = explode filename
    val final_name = drop(length exp_filename - 4, exp_filename)
    val sml_name =
      if implode final_name <> ".sml" then filename ^ ".sml" else filename
    val instream = open_in sml_name
    val result = do_input(fn ()  => input_line instream)
      handle exn => (close_in instream; raise exn)
  in
    close_in instream
  end  

d399 5
a403 4
  let val done = ref false
  in
    do_input(fn () => if !done then "" else (done := true; x))
  end
d412 1
a412 1
	  output (std_out,"*** Exception " ^ System.exn_name exn ^ " raised\n")
d416 1
a416 1
end
@


1.26
log
@Removed exception handlers (impossible exception has been replaced
by calls to Crash.impossible).
@
text
@d4 4
d95 1
d97 1
d125 1
d207 2
a208 2
  val show_mir        = ref true
  val show_opt_mir    = ref true
d277 8
a284 3
      val EnvironTypes.PRIM load_string =
	Environ.lookup_valid(Ident.VAR(Symbol.find_symbol"_load_string"),
	  Primitives.initial_env)
@


1.25
log
@Added calls to encapsulate and output the code
@
text
@d4 3
a294 4
	handle exn as  LambdaTypes_.not_done_yet x =>
	  (print("not_done_yet "^x); raise exn)
	| exn as LambdaTypes_.impossible x =>
	  (print("impossible "^x); raise exn)
a313 4
	handle exn as LambdaTypes.not_done_yet x =>
	  (print(x ^ " not done yet"); raise exn)
	     | exn as LambdaTypes_.impossible x =>
		 (print("impossible "^x); raise exn)
@


1.24
log
@Changed the way Mach_Cg is called because the register assignment
tables have moved.
@
text
@d4 4
d110 2
a112 1
require "primitives";
d138 1
d161 1
d344 8
a351 1

@


1.23
log
@Made all code generation take place at all times
@
text
@d4 3
d152 3
a154 2
  sharing Mach_Cg.MachSpec = MirOptimiser.MachSpec
  sharing Mach_Cg.Table = MirOptimiser.Table
d328 9
a336 6
	Mach_Cg.mach_cg(the_optimised_code,
			(MirOptimiser.gc_assign,
			 MirOptimiser.non_gc_assign,
			 MirOptimiser.fp_assign,
			 MirOptimiser.fp_double_assign))

@


1.22
log
@Added call to Mach_Cg.mach_cg
@
text
@d4 3
d303 6
d311 18
a328 8
	let
	  val the_mir_code = Mir_Cg.mir_cg(opt_lambda_exp, top_env)
	    handle exn as LambdaTypes.not_done_yet x =>
	      (print(x ^ " not done yet"); raise exn)
		 | exn as LambdaTypes_.impossible x =>
		     (print("impossible "^x); raise exn)
	  val _ = print("The unoptimised intermediate code")
	  val _ = print(MirPrint.print_mir_code the_mir_code);
a329 16
	  val _ =
	    if !show_opt_mir then
	      let
		val the_optimised_code =
		  MirOptimiser.optimise the_mir_code;
		val _ = print("The optimised intermediate code")
		val _ = print(MirPrint.print_mir_code the_optimised_code)
		val _ =
		  if (!show_mach) then
		    let
		      val module =
			Mach_Cg.mach_cg(the_optimised_code,
					(MirOptimiser.gc_assign,
					 MirOptimiser.non_gc_assign,
					 MirOptimiser.fp_assign,
					 MirOptimiser.fp_double_assign))
a330 10
		    in
		      ()
		    end
		  else ()
	      in
		()
	      end
	    else ()
	in () end
      else ()
a331 1

@


1.21
log
@Added machine dependent code generator
@
text
@d5 3
d145 3
a147 1
    MirOptimiser.MirTypes
d301 9
a309 9
      if (!show_mir) 
	  then let
		   val the_mir_code = Mir_Cg.mir_cg(opt_lambda_exp, top_env)
		       handle exn as LambdaTypes.not_done_yet x =>
			   (print(x ^ " not done yet"); raise exn)
			    | exn as LambdaTypes_.impossible x =>
				  (print("impossible "^x); raise exn)
		   val _ = print("The unoptimised intermediate code")
		   val _ = print(MirPrint.print_mir_code the_mir_code);
d311 28
a338 12
		   val _ = if !show_opt_mir then
		     let
		       val the_optimised_code =
			 MirOptimiser.optimise the_mir_code;
		     in
		       (print("The optimised intermediate code");
			print(MirPrint.print_mir_code the_optimised_code))
		     end
		   else ()
	       in () end
      	  else ()
    in () end;
@


1.20
log
@Added show_mach
@
text
@d4 6
d95 2
d120 2
@


1.19
log
@Added show_lambda, show_opt_lambda, show_environ
switches.
@
text
@d4 4
d164 7
a170 6
  val show_absyn      = ref false;
  val show_lambda     = ref false;
  val show_opt_lambda = ref true;
  val show_environ    = ref true;
  val show_mir        = ref true;
  val show_opt_mir    = ref true;
@


1.18
log
@Added printing of optimised lambda-code, as
the lambda-optimiser no longer prints it by default...
@
text
@d4 4
d160 6
a165 3
  val show_absyn = ref false;
  val show_mir   = ref true;
  val show_opt_mir   = ref true;
d263 5
a267 2
      val _ = print "The lambda code"
      val _ = LambdaPrint.print_lambda lambda_exp
d269 10
a278 4
      val _ = print "The optimised lambda code"
      val _ = LambdaPrint.print_lambda opt_lambda_exp
      val _ = print"The environment"
      val _ = print(EnvironPrint.printtopenv top_env)
@


1.17
log
@Added show_opt_mir to control production and printing of optimised
intermediate code
@
text
@d4 4
d259 2
@


1.16
log
@Included MIR optimiser module in compiler run.
@
text
@d4 3
d154 1
d269 9
a277 5
		   val the_optimised_code =
			MirOptimiser.optimise the_mir_code;
		   val _ = print("The optimised intermediate code");
		   val _ = print(MirPrint.print_mir_code the_optimised_code)

@


1.15
log
@Removed init_prim, as no longer required
@
text
@d4 3
d70 4
a73 3
require"../mir/mirtypes";
require"../mir/mir_cg";
require"../mir/mirprint";
d96 1
d116 2
a117 1
  sharing Mir_Cg.MirTypes = MirTypes = MirPrint.MirTypes
d262 2
a263 2
		   val _ = print("The intermediate code")
		   val _ = print(MirPrint.print_mir_code the_mir_code)
d265 5
a269 9
(*
		   val the_mir_code = Mir_Cg.mir_cg(lambda_exp, top_env)
		       handle exn as LambdaTypes.not_done_yet x =>
			   (print(x ^ " not done yet"); raise exn)
			    | exn as LambdaTypes_.impossible x =>
				  (print("impossible "^x); raise exn)
		   val _ = print"The non-optimised intermediate code"
		   val _ = print(MirPrint.print_mir_code the_mir_code)
*)
@


1.14
log
@Removed code generation from non-optimised lambda code
@
text
@d4 3
d230 1
d232 1
@


1.13
log
@Removed printing of optimised lambda code,
as it's printed by the optimiser by default.
@
text
@d4 4
d96 1
a96 2
  sharing Absyn.Set = Basis.Set = Environ.Set = LambdaOptimiser.Set =
    Primitives.Set
a227 3
(*
      val _ = MirTypes.init_counters()
*)
a239 4

(*      val _ = print"The optimised lambda code"
      val _ = LambdaPrint.print_lambda opt_lambda_exp
 *)
d254 1
d262 1
@


1.12
log
@Added switches for mir and absyn printing,
changed to use different lambda-print function.
@
text
@d4 4
d241 1
a241 1
      val _ = print"The optimised lambda code"
d243 1
a243 1
 
@


1.11
log
@Split printing of results into two parts for better diagnostics
@
text
@d4 3
d132 4
a135 1
          
d157 6
a162 4
(*
	  val _ = print("The abstract syntax\n" ^
	    TopdecPrint.topdec_to_string topdec)
*)
d232 11
d244 21
a264 24
	print"The lambda code\n"
      val _ = print(LambdaPrint.printlambda lambda_exp)
      val opt_lambda_exp =
	LambdaOptimiser.optimise lambda_exp
      val _ = print"The optimised lambda code\n"
      val _ = print(LambdaPrint.printlambda opt_lambda_exp)
      val _ = print"The environment\n"
      val _ = print(EnvironPrint.printtopenv top_env)
      val the_mir_code = Mir_Cg.mir_cg(opt_lambda_exp, top_env)
	handle exn as LambdaTypes.not_done_yet x =>
	  (print(x ^ " not done yet"); raise exn)
	| exn as LambdaTypes_.impossible x =>
	  (print("impossible "^x); raise exn)
      val _ = print("The intermediate code\n")
      val _ = print(MirPrint.print_mir_code the_mir_code)
      val the_mir_code = Mir_Cg.mir_cg(lambda_exp, top_env)
	handle exn as LambdaTypes.not_done_yet x =>
	  (print(x ^ " not done yet"); raise exn)
	| exn as LambdaTypes_.impossible x =>
	  (print("impossible "^x); raise exn)
    in
      print"The non-optimised intermediate code\n";
      print(MirPrint.print_mir_code the_mir_code)
    end
@


1.10
log
@Removed superfluous argument from LambdaOptimiser.optimise call.
@
text
@d4 3
d225 2
a226 1
	print("The lambda code\n" ^ (LambdaPrint.printlambda lambda_exp));
d229 4
a232 4
      val _ =
	print("The optimised lambda code\n" ^ (LambdaPrint.printlambda opt_lambda_exp));
      val _ =
	print("The environment\n" ^ (EnvironPrint.printtopenv top_env));
d238 2
a239 2
      val _ = 
	print("The intermediate code\n" ^ (MirPrint.print_mir_code the_mir_code))
d246 2
a247 1
      print("The non-optimised intermediate code\n" ^ (MirPrint.print_mir_code the_mir_code))
@


1.9
log
@Stopped printing abstract syntax tree
@
text
@d4 3
d224 1
a224 1
	LambdaOptimiser.optimise Primitives.imperative_primitives lambda_exp
@


1.8
log
@Minor changes to do with calling mir
@
text
@d4 3
d145 1
d148 1
@


1.7
log
@Added mir stuff
@
text
@d4 3
d202 1
d204 1
d226 7
d234 1
a234 1
      print("The intermediate code\n" ^ (MirPrint.print_mir_code the_mir_code))
@


1.6
log
@First attempt at abstracting out external arguments
@
text
@d4 3
d41 3
d63 3
d71 1
a71 1
    Environ.Ident
d81 2
a82 1
    Lambda.LambdaTypes = LambdaOptimiser.LambdaTypes = Primitives.LambdaTypes
d84 1
a84 1
    Primitives.EnvironTypes = EnvironPrint.EnvironTypes
d86 2
a87 1
    ) : TOPLEVEL =
d199 1
a199 1

d208 2
a209 1

d212 9
d222 1
a222 3
      print("The code\n" ^ (LambdaPrint.printlambda lambda_exp));
      print("The optimised code\n" ^ (LambdaPrint.printlambda opt_lambda_exp));
      print("The environment\n" ^ (EnvironPrint.printtopenv top_env))
@


1.5
log
@Used new toplevel environment printer
@
text
@d4 3
d24 2
d44 2
d61 1
a61 1
  sharing Absyn.IdentClass = Parser.Ident = LambdaTypes.Ident =
d75 1
d132 1
a132 1
	  (declarations, CB(p',t',c'))
d143 2
a144 1
	    val (declarations, cb') = compile_topdec (augment_cb(initial,cb))
d148 1
a148 1
	      (declarations, cb')
d151 1
a151 1
		val (rest_decs, rest_cb) = compile_topdecs' cb''
d153 2
a154 1
		(declarations @@ rest_decs, augment_cb(cb', rest_cb))
d160 1
a160 1
	    ([],empty_cb)
d165 2
a166 1
      val (decls_list, CB(pbasis, basis, top_env)) = compile_topdecs ()
d169 11
@


1.4
log
@Has topdecprint if required
@
text
@d4 3
d169 1
a169 1
      val (lambda_exp, cb' as CB(_, _, EnvironTypes.TOP_ENV(env, fun_env))) =
d181 1
a181 1
      print("The environment\n" ^ (EnvironPrint.printenv env))
@


1.3
log
@Produced correct top level output in terms of ordering, environment
as fields etc.
@
text
@d4 4
d29 1
d47 1
d58 2
a59 1
  sharing Absyn = Parser.Absyn = Mod_Rules.Absyn = Lambda.Absyn
d114 5
a118 1
	  val t' = Mod_Rules.check_topdec (topdec,t)
@


1.2
log
@Completed to handle initial environment and compile files and strings
@
text
@d4 3
d141 3
a143 10
      val (decls_list, cb) = compile_topdecs ()
      val load =
	LambdaTypes.STRUCT(map (fn (lv, _) => LambdaTypes.VAR lv) decls_list)
	  
      fun concat_decls [] load      = load
	| concat_decls ((lv, le)::ds) load =
	  LambdaTypes.APP(LambdaTypes.FN(lv, concat_decls ds load), le)
	    
      val lambda_exp = concat_decls decls_list load
	  
d145 1
a145 1
      (lambda_exp, cb)
@


1.1
log
@Initial revision
@
text
@d3 3
a5 1
$Log$
d19 1
d21 1
d23 1
d36 1
d38 2
d45 2
a46 1
  sharing Absyn.Set = Basis.Set = Environ.Set
d52 3
a54 2
    Lambda.LambdaTypes
  sharing Environ.EnvironTypes = EnvironTypes = Lambda.EnvironTypes
d68 1
a68 3
  fun get_initial_env() =
    raise(LambdaTypes.not_done_yet "toplevel.initial_env")
  val initial_env = get_initial_env()
d70 2
a71 6
    EnvironTypes.TOP_ENV(initial_env, EnvironTypes.FUN_ENV Map.empty_map)
(*
  val initial_cgb = CgEnv.B(CgEnv.emptyFunEnv,
			      CgEnv.E(CgPrim.initialVarEnv(),
				      CgEnv.emptyStrEnv))
*)
d102 2
a103 1
	  val (topdec,p') = parse p
a115 14
(*
	fun compile_topdecs' cb decls_list = 
	  let
	    val (declarations, cb') = compile_topdec (augment_cb(initial,cb))
	    val decls_list = declarations::decls_list
	    val cb'' = augment_cb(cb, cb')
	    val (rest_decs, rest_cb) = 
	  in
	    if eof() then
	      (decls_list, cb'')
	    else
	      compile_topdecs' cb'' decls_list
	  end
*)
a140 5
(*
      val CB(p,b,CgEnv.B(f,cgenv)) = cb
      val (cgenv',load) = Cg.encapsulateEnv cgenv
      val cb' = CB(p,b,CgEnv.B(f,cgenv'))
*)
d152 1
a152 1
  fun compile_file filename =
d157 1
a157 3
      val sml_name = filename ^ ".sml"
      val instream = open_in sml_name
      (* val _ = (visited := [(sml_name, ref INCOMPLETE)]) *)
d159 9
a167 13
      val ts = Lexer.mkTokenStream (fn () => input_line instream)
	  
      val cb = initial_cb
      val (lambda_exp, cb') = compile_program (ts,cb)
      val _ = close_in instream
(*
      val module = if !produce_module
		     then
		       wrap load sml_name modulename
		   else
		     load
      val _ = print(Ten15.printLOAD(module))
*)
d169 3
a171 1
      print("The code\n" ^ (LambdaPrint.printlambda lambda_exp))
d174 22
@
