head	1.39;
access;
symbols
	MLW_daveb_inline_1_4_99:1.39.3
	MLWorks_21c0_1999_03_25:1.39
	MLWorks_20c1_1998_08_20:1.39
	MLWorks_20c0_1998_08_04:1.39
	MLWorks_20b2c2_1998_06_19:1.39
	MLWorks_20b2_Windows_1998_06_12:1.39
	MLWorks_20b1c1_1998_05_07:1.39
	MLWorks_20b0_1998_04_07:1.39
	MLWorks_20b0_1998_03_20:1.39
	MLWorks_20m2_1998_02_16:1.39
	MLWorks_20m1_1997_10_23:1.39
	MLWorks_11r1:1.38.8.1.1.1.1
	MLWorks_workspace_97:1.39.2
	MLWorks_dt_wizard:1.39.1
	MLWorks_11c0_1997_09_09:1.38.8.1.1.1
	MLWorks_10r3:1.38.8.1.3
	MLWorks_10r2_551:1.38.8.1.2
	MLWorks_11:1.38.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.38.8.1
	MLWorks_20m0_1997_06_20:1.39
	MLWorks_1_0_r2c2_1997_06_14:1.38.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.38.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.38.8
	MLWorks_BugFix_1997_04_24:1.38
	MLWorks_1_0_r2_Win32_1997_04_11:1.38
	MLWorks_1_0_r2_Unix_1997_04_04:1.38
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.38.6.1.1
	MLWorks_gui_1996_12_18:1.38.7
	MLWorks_1_0_Win32_1996_12_17:1.38.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.38.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.38.4.1
	MLWorks_1_0_Irix_1996_11_28:1.38.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.38.5
	MLWorks_1_0_Unix_1996_11_14:1.38.4
	MLWorks_Open_Beta2_1996_10_11:1.38.3
	MLWorks_License_dev:1.38.2
	MLWorks_1_open_beta_1996_09_13:1.38.1
	MLWorks_Open_Beta_1996_08_22:1.38
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.38
	MLWorks_Beta_1996_06_06:1.38
	MLWorks_Beta_1996_06_05:1.38
	MLWorks_Beta_1996_06_03:1.38
	MLWorks_Beta_1996_05_31:1.38
	MLWorks_Beta_1996_05_30:1.38
	ML_beta_release_12/08/94:1.31
	ML_beta_release_03/08/94:1.31
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.28
	mlworks-28-01-1994:1.26
	Release:1.23
	mlworks-beta-01-09-1993:1.23
	MLWorks-1-0-4-29/01/1993:1.12
	MLWorks-1-0-3-21/12/1992:1.12
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.10;
locks; strict;
comment	@ * @;


1.39
date	97.05.01.12.44.03;	author jont;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1;
next	1.38;

1.38
date	96.03.18.15.42.29;	author daveb;	state Exp;
branches
	1.38.1.1
	1.38.2.1
	1.38.3.1
	1.38.4.1
	1.38.5.1
	1.38.6.1
	1.38.7.1
	1.38.8.1;
next	1.37;

1.37
date	96.02.23.17.38.16;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	95.12.27.14.11.40;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	95.11.22.09.48.03;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.07.13.11.37.06;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	95.03.30.16.33.38;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	95.03.03.11.18.46;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	94.06.22.14.51.54;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	94.06.17.13.19.16;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.03.18.14.30.44;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	94.02.28.07.31.04;	author nosa;	state Exp;
branches;
next	1.27;

1.27
date	94.02.25.15.52.36;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	94.01.26.18.04.54;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	94.01.06.14.43.26;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.09.07.16.34.08;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	93.07.30.14.52.06;	author daveb;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	93.07.29.14.24.08;	author nosa;	state Exp;
branches;
next	1.21;

1.21
date	93.07.06.10.33.11;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	93.05.12.15.42.47;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.04.26.16.24.46;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.04.02.13.27.15;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	93.03.17.12.11.57;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.03.11.13.08.20;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.03.09.13.51.00;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.02.09.10.01.20;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.02.04.13.29.01;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.12.09.12.39.02;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.12.08.20.40.30;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.12.02.18.02.21;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	92.12.01.12.38.11;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	92.11.26.17.08.43;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.11.21.15.44.41;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.11.20.15.31.58;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.11.19.14.23.56;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.11.04.15.16.50;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	92.10.14.12.09.26;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.10.08.11.26.56;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	92.10.07.15.41.48;	author richard;	state Exp;
branches;
next	;

1.23.1.1
date	93.07.30.14.52.06;	author jont;	state Exp;
branches;
next	;

1.38.1.1
date	96.09.13.11.18.25;	author hope;	state Exp;
branches;
next	;

1.38.2.1
date	96.10.07.16.08.18;	author hope;	state Exp;
branches;
next	;

1.38.3.1
date	96.10.17.11.26.32;	author hope;	state Exp;
branches;
next	;

1.38.4.1
date	96.11.14.12.51.51;	author hope;	state Exp;
branches
	1.38.4.1.1.1;
next	;

1.38.4.1.1.1
date	96.11.28.15.02.53;	author hope;	state Exp;
branches;
next	;

1.38.5.1
date	96.11.22.18.11.04;	author hope;	state Exp;
branches;
next	;

1.38.6.1
date	96.12.17.17.49.37;	author hope;	state Exp;
branches
	1.38.6.1.1.1;
next	;

1.38.6.1.1.1
date	97.02.24.11.39.47;	author hope;	state Exp;
branches;
next	;

1.38.7.1
date	96.12.18.09.43.42;	author hope;	state Exp;
branches;
next	;

1.38.8.1
date	97.05.12.10.36.11;	author hope;	state Exp;
branches
	1.38.8.1.1.1
	1.38.8.1.2.1
	1.38.8.1.3.1;
next	;

1.38.8.1.1.1
date	97.07.28.18.21.52;	author daveb;	state Exp;
branches
	1.38.8.1.1.1.1.1;
next	;

1.38.8.1.1.1.1.1
date	97.10.07.11.47.32;	author jkbrook;	state Exp;
branches;
next	;

1.38.8.1.2.1
date	97.09.08.17.15.16;	author daveb;	state Exp;
branches;
next	;

1.38.8.1.3.1
date	97.09.09.14.11.09;	author daveb;	state Exp;
branches;
next	;

1.39.1.1
date	97.09.10.19.27.10;	author brucem;	state Exp;
branches;
next	;

1.39.2.1
date	97.09.11.20.57.10;	author daveb;	state Exp;
branches;
next	;

1.39.3.1
date	99.04.01.17.58.13;	author daveb;	state Exp;
branches;
next	;


desc
@Compiler interface.
Signature.
@


1.39
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@(*  ==== COMPILER INTERFACE ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This code packages up all stages of the compiler into a single
 *  interface.  See the comments in the signature for details.
 *
 *  Diagnostics (those in brackets are lies)
 *  -----------
 *    0  none
 *    1  displays a message on invocation
 *    2  displays the abstract syntax and optimised lambda
 *    3  (displays the optimised MIR code)
 *    4  (displays the machine code)
 *    5  displays the unoptimised lambda (and unoptimised MIR code)
 *
 *  Revision Log
 *  ------------
 *  $Log: compiler.sml,v $
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
 * Revision 1.37  1996/02/23  17:38:16  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.36  1995/12/27  14:11:40  jont
 * Removing Option in favour of MLWorks.Option
 *
 *  Revision 1.35  1995/11/22  09:48:03  daveb
 *  Changed type Absyn.ModuleId to a local ModuleId type.
 *
 *  Revision 1.34  1995/07/13  11:37:06  matthew
 *  Moving Compiler.identifier type to Ident
 *
 *  Revision 1.33  1995/03/30  16:33:38  matthew
 *  Change Tyfun_id etc to Stamp
 *
 *  Revision 1.32  1995/03/03  11:18:46  daveb
 *  Added dummy identifier value.
 *
 *  Revision 1.31  1994/06/22  14:51:54  jont
 *  Update debugger information production
 *
 *  Revision 1.30  1994/06/17  13:19:16  daveb
 *  Added compare_identifiers and empty_basis.
 *
 *  Revision 1.29  1994/03/18  14:30:44  matthew
 *  Added add_debug_info function
 *
 *  Revision 1.28  1994/02/28  07:31:04  nosa
 *  Debugger environments for Modules Debugger.
 *
 *  Revision 1.27  1994/02/25  15:52:36  daveb
 *  Adding clear_debug functionality.
 *
 *  Revision 1.26  1994/01/26  18:04:54  matthew
 *  Simplification
 *
 *  Revision 1.25  1994/01/06  14:43:26  matthew
 *  Export extract_identifiers
 *  Added id_cache type (what a terrible name!) to record information about tyname_id's etc.
 *
 *  Revision 1.24  1993/09/07  16:34:08  jont
 *  Changed type of compile to indicate whether the file in question is pervasive
 *
 *  Revision 1.23  1993/07/30  14:52:06  daveb
 *  compile now takes a moduleid instead of a string.
 *
 *  Revision 1.22  1993/07/29  14:24:08  nosa
 *  structure Option.
 *
 *  Revision 1.21  1993/07/06  10:33:11  daveb
 *  Removed EXCEPTION identifier class.
 *
 *  Revision 1.20  1993/05/12  15:42:47  jont
 *  Changed signature to allow list of modules compiled to be passed in
 *  and returned by compile
 *
 *  Revision 1.19  1993/04/26  16:24:46  jont
 *  Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
 *
 *  Revision 1.18  1993/04/02  13:27:15  matthew
 *  Removed Debugger_Types
 *
 *  Revision 1.17  1993/03/17  12:11:57  matthew
 *  Added parserbasis field to source type
 *
 *  Revision 1.16  1993/03/11  13:08:20  matthew
 *  Signature revisions
 *
 *  Revision 1.15  1993/03/09  13:51:00  matthew
 *  Options & Info changes
 *  Removed Parser and BasisTypes from signature
 *
 *  Revision 1.14  1993/02/09  10:01:20  matthew
 *  Typechecker structure changes
 *
 *  Revision 1.13  1993/02/04  13:29:01  matthew
 *  Changed sharing.
 *
 *  Revision 1.12  1992/12/09  12:39:02  clive
 *  Added some sharing
 *
 *  Revision 1.11  1992/12/08  20:40:30  jont
 *  Removed a number of duplicated signatures and structures
 *
 *  Revision 1.10  1992/12/02  18:02:21  daveb
 *  Added a sharing constraint
 *
 *  Revision 1.9  1992/12/01  12:38:11  daveb
 *  Changes to propagate compiler options as parameters instead of references.
 *
 *  Revision 1.8  1992/11/26  17:08:43  clive
 *  Added clear_debug_info function
 *
 *  Revision 1.7  1992/11/21  15:44:41  clive
 *  Changed the result type to allow the code to be deleted
 *
 *  Revision 1.6  1992/11/20  15:31:58  jont
 *  Modified sharing constraints to remove superfluous structures
 *
 *  Revision 1.5  1992/11/19  14:23:56  clive
 *  Added a few debug_info functions
 *
 *  Revision 1.4  1992/11/04  15:16:50  matthew
 *  Changed Error structure to Info
 *
 *  Revision 1.3  1992/10/14  12:09:26  richard
 *  Added location information to the `require' topdec and passed
 *  this through to the require function passed to compile.
 *
 *  Revision 1.2  1992/10/08  11:26:56  richard
 *  Added a source type to compile.
 *
 *  Revision 1.1  1992/10/07  15:41:48  richard
 *  Initial revision
 *
 *)

require "../utils/diagnostic";
require "../utils/map";
require "../main/info";
require "../main/options";
require "../basics/absyn";
require "pervasives";

signature COMPILER =
  sig
    structure Info              : INFO
    structure Absyn     	: ABSYN
    structure Pervasives	: PERVASIVES
    structure Diagnostic	: DIAGNOSTIC
    structure Options           : OPTIONS
    structure NewMap            : MAP

    sharing Info.Location = Absyn.Ident.Location

    (*  === COMPILER BASIS ===
     *
     *  A compiler basis encapsulates all the information needed to compile
     *  in the presence of some declarations.  In a sense it is the
     *  `interface' to declarations which have occured earlier or in other
     *  modules.
     *)

    type Top_Env (* EnvironTypes.Top_Env *)
    type DebuggerEnv (* EnvironTypes.DebuggerEnv *)
    type LambdaExp (* LambdaTypes.LambdaExp *)
    type Module  (* was MachTypes.Module *)
    type DebugInformation (* was Debugger_Types.information *)
    type TypeBasis
    type ParserBasis

    datatype basis =
      BASIS of {parser_basis		: ParserBasis,
                type_basis		: TypeBasis,
                lambda_environment	: Top_Env,
                debugger_environment	: DebuggerEnv,
                debug_info		: DebugInformation}

    val augment : Options.options * basis * basis -> basis
    val adjust_compiler_basis_debug_info : basis * DebugInformation -> basis
    val get_basis_debug_info : basis -> DebugInformation
    val clear_debug_info : string * basis -> basis
    val clear_debug_all_info : basis -> basis
    val make_external : basis -> basis
    val add_debug_info : Options.options * DebugInformation * basis -> basis

    (*  == Initial bases ==
     *
     *  initial_basis is a compiler basis which contains only the builtin
     *  declarations for primitives (but not all standard pervasives).  It
     *  should be used as the starting point for compiling normal ML.
     *
     *  initial_basis_for_builtin_library is a special compiler basis for
     *  compiling the builtin library module.  It does not contain bindings
     *  for much except that which cannot be declared, and the call_c
     *  interface function.
     *
     *  builtin_lambda_environment is the lambda environment which replaces
     *  that resulting from compiling the builtin library in order that the
     *  compiler recognise its contents as primitives.
     *)

    val empty_basis	: basis
    val initial_basis	: basis
    val initial_basis_for_builtin_library : basis
    val builtin_lambda_environment : Top_Env


    (*  == Compilation result ==
     *
     *  The compile function returns a compilation `result' consisting of:
     *
     *    basis		the basis which defines the new declarations (but
     *            	does not include the initial basis -- it is a
     *            	`delta')
     *    signatures	a mapping from new signature identifiers to their
     *            	abstract syntax, for information purposes
     *	  code		the machine code for the module
     *)

    val extract_identifiers : Absyn.Ident.Identifier list * TypeBasis -> Absyn.Ident.Identifier list

    datatype id_cache = ID_CACHE of {stamp_start:int,
                                     stamp_no:int}

    datatype result =
      RESULT of {basis		: basis,
                 signatures	: (Absyn.Ident.SigId, Absyn.SigExp) NewMap.map,
                 code		: Module option,
                 id_cache       : id_cache}

    (*  === COMPILER ===
     *
     *  The compiler consumes source code in the environment supplied by the
     *  basis parameter, returning a compilation result (see above).
     *
     *  Source code is taken from a source type with the following
     *  constructors:
     *    TOKENSTREAM  an entire token stream
     *    TOKENSTREAM1 a single topdec from the token stream
     *    TOPDEC       a topdec of abstract syntax (with associated source name)
     *
     *  In the compile function takes a function which is invoked if a
     *  `require' topdec is encountered.  This function should map the
     *  module name parameter of the require into a compiler basis for that
     *  module, which is the incorporated into the compilation (but does not
     *  appear in the result).  The 'a parameter to the require function is
     *  threaded through so that it can cache information, and this cache is
     *  also returned as part of the compilation result.
     *)

    type tokenstream

    datatype source =
      TOKENSTREAM of tokenstream |
      TOKENSTREAM1 of tokenstream |
      (* the ParserBasis is an augmentation *)
      TOPDEC of string * Absyn.TopDec * ParserBasis

    val compile :
      Info.options *
      Options.options ->
      ('a * string * Info.Location.T ->
       'a * string * basis) ->
      'a * basis * bool ->
      (bool * source) ->
      'a * result

    val remove_str : basis * Absyn.Ident.StrId -> basis
  end
@


1.39.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a21 4
 * Revision 1.39  1997/05/01  12:44:03  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.39.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a21 4
 * Revision 1.39  1997/05/01  12:44:03  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.39.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a21 4
 * Revision 1.39  1997/05/01  12:44:03  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.38
log
@Removed the identifiers field from the Compiler.result type.  This information
can be synthesised from the type basis.
@
text
@d22 4
d234 1
a234 1
                 code		: Module MLWorks.Option.option,
@


1.38.8.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a21 3
 * Revision 1.38.8.1  1997/05/12  10:36:11  hope
 * branched from 1.38
 *
@


1.38.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a21 3
 * Revision 1.38.8.1  1997/05/12  10:36:11  hope
 * branched from 1.38
 *
@


1.38.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a21 3
 * Revision 1.38.8.1  1997/05/12  10:36:11  hope
 * branched from 1.38
 *
@


1.38.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a21 3
 * Revision 1.38.8.1.1.1  1997/07/28  18:21:52  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.38.7.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.6.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.6.1.1.1
log
@branched from 1.38.6.1
@
text
@a21 3
 * Revision 1.38.6.1  1996/12/17  17:49:37  hope
 * branched from 1.38
 *
@


1.38.5.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.4.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.4.1.1.1
log
@branched from 1.38.4.1
@
text
@a21 3
 * Revision 1.38.4.1  1996/11/14  12:51:51  hope
 * branched from 1.38
 *
@


1.38.3.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.2.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.38.1.1
log
@branched from 1.38
@
text
@a21 4
 * Revision 1.38  1996/03/18  15:42:29  daveb
 * Removed the identifiers field from the Compiler.result type.  This information
 * can be synthesised from the type basis.
 *
@


1.37
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d22 3
a218 1
     *    identifiers	a list of new identifiers declared
a229 1
                 identifiers	: Absyn.Ident.Identifier list,
@


1.36
log
@Removing Option in favour of MLWorks.Option
@
text
@d22 3
d137 1
a137 1
require "../utils/newmap";
d150 1
a150 1
    structure NewMap            : NEWMAP
d227 1
a227 1
                 signatures	: (Absyn.Ident.SigId, Absyn.SigExp) NewMap.T,
@


1.35
log
@Changed type Absyn.ModuleId to a local ModuleId type.
@
text
@d22 3
a134 1
require "../utils/option";
a145 1
    structure Option            : OPTION
d226 1
a226 1
                 code		: Module Option.opt,
@


1.34
log
@Moving Compiler.identifier type to Ident
@
text
@d22 3
d259 1
a259 1
      ('a * Absyn.ModuleId * Info.Location.T ->
@


1.33
log
@Change Tyfun_id etc to Stamp
@
text
@d22 3
d213 1
a213 10
    datatype identifier =
      VALUE of Absyn.Ident.ValId |
      TYPE of Absyn.Ident.TyCon |
      STRUCTURE of Absyn.Ident.StrId |
      SIGNATURE of Absyn.Ident.SigId |
      FUNCTOR of Absyn.Ident.FunId

    val dummy_identifier: identifier
    val compare_identifiers : identifier * identifier -> bool
    val extract_identifiers : identifier list * TypeBasis -> identifier list
d221 1
a221 1
                 identifiers	: identifier list,
@


1.32
log
@Added dummy identifier value.
@
text
@d22 3
d221 2
a222 6
    datatype id_cache = ID_CACHE of {tyname_start:int,
                                     strname_start:int,
                                     tyfun_start:int,
                                     tyname_no:int,
                                     strname_no:int,
                                     tyfun_no:int}
@


1.31
log
@Update debugger information production
@
text
@d22 3
d214 1
@


1.30
log
@Added compare_identifiers and empty_basis.
@
text
@d22 3
d161 1
a161 1
    val augment : basis * basis -> basis
d167 1
a167 1
    val add_debug_info : DebugInformation * basis -> basis
@


1.29
log
@Added add_debug_info function
@
text
@d22 3
d182 1
d208 1
@


1.28
log
@Debugger environments for Modules Debugger.
@
text
@d22 3
d161 1
@


1.27
log
@Adding clear_debug functionality.
@
text
@d22 3
d138 2
d149 1
@


1.26
log
@Simplification
@
text
@d22 3
d149 2
a150 1
    val clear_debug_info : basis -> basis
@


1.25
log
@Export extract_identifiers
Added id_cache type (what a terrible name!) to record information about tyname_id's etc.
@
text
@d22 4
a131 1
    type LambdaExp (* LambdaTypes.LambdaExp *)
d147 1
d237 3
a239 3
      ('a * Absyn.ModuleId * Info.Location.T * string list * bool ->
       'a * LambdaExp * basis * string list) ->
      'a * basis * string list * bool ->
d241 1
a241 1
      'a * result * string list
@


1.24
log
@Changed type of compile to indicate whether the file in question is pervasive
@
text
@d22 3
d186 9
d199 2
a200 2
                 code		: Module Option.opt}

@


1.23
log
@compile now takes a moduleid instead of a string.
@
text
@d22 3
d221 1
a221 1
      ('a * Absyn.ModuleId * Info.Location.T * string list ->
d224 1
a224 1
      source ->
@


1.23.1.1
log
@Fork for bug fixing
@
text
@a21 3
 *  Revision 1.23  1993/07/30  14:52:06  daveb
 *  compile now takes a moduleid instead of a string.
 *
@


1.22
log
@structure Option.
@
text
@d22 3
d218 1
a218 1
      ('a * string * Info.Location.T * string list ->
@


1.21
log
@Removed EXCEPTION identifier class.
@
text
@d22 3
d92 1
d104 1
a176 2
    datatype 'a option = ABSENT | PRESENT of 'a

d181 1
a181 1
                 code		: Module option}
@


1.20
log
@Changed signature to allow list of modules compiled to be passed in
and returned by compile
@
text
@d22 4
a166 1
      EXCEPTION of Absyn.Ident.ValId |
@


1.19
log
@Added remove_str for getting rid of FullPervasiveLibrary_ from initial env
@
text
@d22 3
d209 3
a211 3
      ('a * string * Info.Location.T ->
       'a * LambdaExp * basis) ->
      'a * basis ->
d213 1
a213 1
      'a * result
@


1.18
log
@Removed Debugger_Types
@
text
@d22 3
d211 2
a213 2


@


1.17
log
@Added parserbasis field to source type
@
text
@d22 3
d78 1
d80 1
a81 1
require "../debugger/debugger_types";
a88 1
    structure Debugger_Types	: DEBUGGER_TYPES
d90 2
a94 2
    sharing type Debugger_Types.Type = Absyn.Type

d106 1
d114 1
a114 1
                debug_info		: Debugger_Types.information}
d117 2
a118 2
    val adjust_compiler_basis_debug_info : basis * Debugger_Types.information -> basis
    val get_basis_debug_info : basis -> Debugger_Types.information
d167 1
a167 1
                 signatures	: (Absyn.Ident.SigId, Absyn.SigExp) Debugger_Types.NewMap.T,
d202 1
a202 1
      Debugger_Types.Options.options ->
@


1.16
log
@Signature revisions
@
text
@d22 3
d193 2
a194 1
      TOPDEC of string * Absyn.TopDec
@


1.15
log
@Options & Info changes
Removed Parser and BasisTypes from signature
@
text
@d22 4
d74 1
a74 3
require "../lambda/environtypes";
require "../machine/machtypes";
require "../mir/mirtypes";
a80 1
    structure EnvironTypes	: ENVIRONTYPES
d82 1
a82 2
    structure MirTypes		: MIRTYPES
    structure MachTypes		: MACHTYPES
a84 1
    sharing MirTypes.Debugger_Types.Datatypes = EnvironTypes.LambdaTypes.Datatypes
d87 1
a87 3
    sharing type EnvironTypes.LambdaTypes.Primitive = Pervasives.pervasive
    sharing type EnvironTypes.LambdaTypes.Datatypes.Type = Absyn.Type
    sharing type EnvironTypes.LambdaTypes.Datatypes.Structure = Absyn.Structure
d97 3
d106 2
a107 2
                lambda_environment	: EnvironTypes.Top_Env,
                debug_info		: MirTypes.Debugger_Types.information}
d110 2
a111 2
    val adjust_compiler_basis_debug_info : basis * MirTypes.Debugger_Types.information -> basis
    val get_basis_debug_info : basis -> MirTypes.Debugger_Types.information
d132 1
a132 1
    val builtin_lambda_environment : EnvironTypes.Top_Env
d160 1
a160 1
                 signatures	: (Absyn.Ident.SigId, Absyn.SigExp) EnvironTypes.LambdaTypes.Datatypes.NewMap.T,
d162 1
a162 1
                 code		: MachTypes.module option}
d194 1
a194 1
      MirTypes.Debugger_Types.Options.options ->
d196 1
a196 1
       'a * EnvironTypes.LambdaTypes.LambdaExp * basis) ->
@


1.14
log
@Typechecker structure changes
@
text
@d22 3
d68 2
a69 2
require "../parser/parser";
require "../typechecker/basistypes";
d77 2
a78 2
    structure Parser		: PARSER
    structure BasisTypes	: BASISTYPES
d85 3
a87 3
    sharing MirTypes.Debugger_Types.Datatypes = BasisTypes.Datatypes =
      Parser.Absyn.Datatypes = EnvironTypes.LambdaTypes.Datatypes
    sharing MirTypes.Debugger_Types.Info = Parser.Lexer.Info = BasisTypes.Info
d89 2
a91 1

d100 3
d104 2
a105 2
      BASIS of {parser_basis		: Parser.ParserBasis,
                type_basis		: BasisTypes.Basis,
d149 6
a154 6
      VALUE of Parser.Absyn.Datatypes.Ident.ValId |
      EXCEPTION of Parser.Absyn.Datatypes.Ident.ValId |
      TYPE of Parser.Absyn.Datatypes.Ident.TyCon |
      STRUCTURE of Parser.Absyn.Datatypes.Ident.StrId |
      SIGNATURE of Parser.Absyn.Datatypes.Ident.SigId |
      FUNCTOR of Parser.Absyn.Datatypes.Ident.FunId
d160 1
a160 1
                 signatures	: (Parser.Absyn.Datatypes.Ident.SigId, Parser.Absyn.SigExp) BasisTypes.Datatypes.NewMap.T,
d185 2
d188 3
a190 3
      TOKENSTREAM of Parser.Lexer.TokenStream |
      TOKENSTREAM1 of Parser.Lexer.TokenStream |
      TOPDEC of string * Parser.Absyn.TopDec
d193 10
a202 7
      MirTypes.options ->
        ('a * string * Parser.Lexer.Info.Location.T ->
	 'a * EnvironTypes.LambdaTypes.LambdaExp * basis) ->
        'a * basis ->
	source ->
	'a * result
  end;
@


1.13
log
@Changed sharing.
@
text
@d22 3
d66 1
a66 1
require "../typechecker/basis";
d75 1
a75 1
    structure Basis		: BASIS
d82 1
a82 1
    sharing MirTypes.Debugger_Types.Datatypes = Basis.Tyvarenv.Datatypes =
d84 1
a84 1
    sharing MirTypes.Debugger_Types.Info = Parser.Lexer.Info
d98 1
a98 1
                type_basis		: Basis.Basis,
d153 1
a153 1
                 signatures	: (Parser.Absyn.Datatypes.Ident.SigId, Parser.Absyn.SigExp) Basis.Tyvarenv.Datatypes.NewMap.T,
@


1.12
log
@Added some sharing
@
text
@d22 3
a70 1
    structure Diagnostic	: DIAGNOSTIC
d77 1
d79 3
a81 1
    sharing MirTypes.Debugger_Types.Datatypes = Basis.Tyvarenv.Datatypes = Parser.Absyn.Datatypes
a82 1
    sharing MirTypes.Debugger_Types.Info = Parser.Lexer.Info
@


1.11
log
@Removed a number of duplicated signatures and structures
@
text
@d22 3
d76 1
a76 1
    sharing MirTypes.Debugger_Types.Datatypes = Basis.Tyvarenv.Datatypes
@


1.10
log
@Added a sharing constraint
@
text
@d22 3
a58 1
require "../debugger/debugger_types";
a59 1
require "../utils/newmap";
a69 1
    structure Debugger_Types	: DEBUGGER_TYPES
a71 1
    structure Map		: NEWMAP
d73 1
a73 2
    sharing Debugger_Types.Datatypes = Basis.Tyvarenv.Datatypes
    sharing Map = Basis.Tyvarenv.Datatypes.NewMap
d75 1
a75 1
    sharing MirTypes.Info = Parser.Lexer.Info = Debugger_Types.Info
d90 1
a90 1
                debug_info		: Debugger_Types.information}
d93 2
a94 2
    val adjust_compiler_basis_debug_info : basis * Debugger_Types.information -> basis
    val get_basis_debug_info : basis -> Debugger_Types.information
d132 6
a137 6
      VALUE of Parser.Absyn.IdentClass.ValId |
      EXCEPTION of Parser.Absyn.IdentClass.ValId |
      TYPE of Parser.Absyn.IdentClass.TyCon |
      STRUCTURE of Parser.Absyn.IdentClass.StrId |
      SIGNATURE of Parser.Absyn.IdentClass.SigId |
      FUNCTOR of Parser.Absyn.IdentClass.FunId
d143 1
a143 1
                 signatures	: (Parser.Absyn.IdentClass.SigId, Parser.Absyn.SigExp) Map.T,
@


1.9
log
@Changes to propagate compiler options as parameters instead of references.
@
text
@d22 3
d77 1
@


1.8
log
@Added clear_debug_info function
@
text
@d22 3
d56 1
a59 1

a60 1

d67 1
a165 5
    datatype options =
      OPTIONS of {info_opts	        : Parser.Lexer.Info.options,
                  debug			: bool,
                  profile		: bool}

d172 6
a177 3
      ('a * string * Parser.Lexer.Info.Location.T -> 'a * EnvironTypes.LambdaTypes.LambdaExp * basis) ->
      options -> 'a * basis -> source -> 'a * result

@


1.7
log
@Changed the result type to allow the code to be deleted
@
text
@d22 3
d90 1
@


1.6
log
@Modified sharing constraints to remove superfluous structures
@
text
@d22 3
d130 2
d136 1
a136 1
                 code		: MachTypes.module}
@


1.5
log
@Added a few debug_info functions
@
text
@d22 3
a47 2
require "../lambda/lambdatypes";
require "info";
a56 1
    structure LambdaTypes	: LAMBDATYPES
a60 1
    structure Info		: INFO
a61 1
    sharing Info = Parser.Info
d64 1
a64 2
    sharing LambdaTypes = EnvironTypes.LambdaTypes
    sharing type LambdaTypes.Primitive = Pervasives.pervasive
d155 1
a155 1
      OPTIONS of {info_opts	        : Info.options,
d165 1
a165 1
      ('a * string * Info.Location.T -> 'a * EnvironTypes.LambdaTypes.LambdaExp * basis) ->
@


1.4
log
@Changed Error structure to Info
@
text
@d22 3
d85 2
a86 1

@


1.3
log
@Added location information to the `require' topdec and passed
this through to the require function passed to compile.
@
text
@d22 4
d43 1
a43 1
require "error";
d58 1
a58 1
    structure Error		: ERROR
d60 1
a60 1
    sharing Error = Parser.Error
d154 1
a154 1
      OPTIONS of {error_output_level	: Error.severity,
d164 1
a164 1
      ('a * string * Error.Location.T -> 'a * EnvironTypes.LambdaTypes.LambdaExp * basis) ->
@


1.2
log
@Added a source type to compile.
@
text
@d22 3
d37 2
d49 2
d57 4
d159 3
a161 1
    val compile : ('a * string -> 'a * basis) -> options -> 'a * basis -> source -> 'a * result
@


1.1
log
@Initial revision
@
text
@d21 4
a24 1
 *  $Log$
d89 14
d111 5
a115 4
    datatype options =
      OPTIONS of {error_output_level	: Error.severity,
                  debug			: bool,
                  profile		: bool}
d120 2
a121 3
     *  The compiler consumes source code from a token stream in the
     *  environment supplied by the basis parameter.  It returns a
     *  compilation `result' consisting of:
d123 5
a127 7
     *    basis		the basis which defines the new declarations (but
     *            	does not include the initial basis -- it is a
     *            	`delta')
     *    signatures	a mapping from new signature identifiers to their
     *            	abstract syntax, for information purposes
     *    identifiers	a list of new identifiers declared
     *	  code		the machine code for the module
d129 2
a130 5
     *  If the bool parameter is false, only one topdec is consumed from the
     *  token stream, otherwise the token stream is exhausted.
     *
     *  In addition, the compile function takes a function which is invoked
     *  if a `require' topdec is encountered.  This function should map the
d138 11
a148 7
    val compile :
      ('a * string -> 'a * basis) -> options ->
      'a * basis -> bool * Parser.Lexer.TokenStream ->
      'a * {basis	: basis,
            signatures	: (Parser.Absyn.IdentClass.SigId, Parser.Absyn.SigExp) Map.T,
            identifiers	: identifier list,
            code	: MachTypes.module}
@
