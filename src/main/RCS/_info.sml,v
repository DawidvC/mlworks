head	1.30;
access;
symbols
	MLW_daveb_inline_1_4_99:1.30.1
	MLWorks_21c0_1999_03_25:1.30
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.29
	MLWorks_20b2c2_1998_06_19:1.28
	MLWorks_20b2_Windows_1998_06_12:1.28
	MLWorks_20b1c1_1998_05_07:1.28
	MLWorks_20b0_1998_04_07:1.28
	MLWorks_20b0_1998_03_20:1.28
	MLWorks_20m2_1998_02_16:1.28
	MLWorks_20m1_1997_10_23:1.28
	MLWorks_11r1:1.27.5.1.1.1.1
	MLWorks_workspace_97:1.28.2
	MLWorks_dt_wizard:1.28.1
	MLWorks_11c0_1997_09_09:1.27.5.1.1.1
	MLWorks_10r3:1.27.5.1.3
	MLWorks_10r2_551:1.27.5.1.2
	MLWorks_11:1.27.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.27.5.1
	MLWorks_20m0_1997_06_20:1.28
	MLWorks_1_0_r2c2_1997_06_14:1.27.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.27.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.27.5
	MLWorks_BugFix_1997_04_24:1.27
	MLWorks_1_0_r2_Win32_1997_04_11:1.27
	MLWorks_1_0_r2_Unix_1997_04_04:1.27
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.27.3.1.1
	MLWorks_gui_1996_12_18:1.27.4
	MLWorks_1_0_Win32_1996_12_17:1.27.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.27.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.27.1.1
	MLWorks_1_0_Irix_1996_11_28:1.27.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.27.2
	MLWorks_1_0_Unix_1996_11_14:1.27.1
	MLWorks_Open_Beta2_1996_10_11:1.26.3
	MLWorks_License_dev:1.26.2
	MLWorks_1_open_beta_1996_09_13:1.26.1
	MLWorks_Open_Beta_1996_08_22:1.26
	MLWorks_Beta_1996_07_02:1.26
	MLWorks_Beta_1996_06_07:1.26
	MLWorks_Beta_1996_06_06:1.26
	MLWorks_Beta_1996_06_05:1.26
	MLWorks_Beta_1996_06_03:1.26
	MLWorks_Beta_1996_05_31:1.26
	MLWorks_Beta_1996_05_30:1.26
	ML_beta_release_12/08/94:1.16
	ML_beta_release_03/08/94:1.16
	ML_revised_beta_release_25/05/94:1.16
	ML_final_beta_release_02/03/94:1.16
	mlworks-28-01-1994:1.16
	Release:1.10
	mlworks-beta-01-09-1993:1.10
	MLWorks-1-0-4-29/01/1993:1.4
	MLWorks-1-0-3-21/12/1992:1.4
	MLWorks-1-0-2-15/12/1992:1.4
	MLWorks-1-0-1-04/12/1992:1.4;
locks; strict;
comment	@ * @;


1.30
date	99.02.17.13.14.32;	author mitchell;	state Exp;
branches
	1.30.1.1;
next	1.29;

1.29
date	98.07.29.13.17.54;	author mitchell;	state Exp;
branches;
next	1.28;

1.28
date	97.05.22.11.59.23;	author jont;	state Exp;
branches
	1.28.1.1
	1.28.2.1;
next	1.27;

1.27
date	96.10.29.16.05.48;	author io;	state Exp;
branches
	1.27.1.1
	1.27.2.1
	1.27.3.1
	1.27.4.1
	1.27.5.1;
next	1.26;

1.26
date	96.04.30.14.21.09;	author jont;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1;
next	1.25;

1.25
date	96.04.01.13.16.53;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.03.27.14.53.45;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	96.03.20.16.19.08;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.03.20.12.12.50;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.03.15.12.29.41;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	96.01.22.16.06.49;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.09.11.14.51.01;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.09.08.13.26.04;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.02.27.16.04.33;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.12.16.15.12.37;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	93.12.15.11.30.18;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.12.10.17.17.58;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.11.30.18.36.20;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	93.11.29.15.50.23;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	93.10.29.16.52.37;	author nickh;	state Exp;
branches;
next	1.10;

1.10
date	93.07.28.14.36.07;	author matthew;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	93.07.12.12.15.13;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	93.05.27.10.20.14;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	93.04.16.15.42.21;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	93.03.03.18.23.49;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	93.02.24.14.59.36;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	92.11.30.17.10.51;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	92.11.25.20.38.32;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	92.11.19.13.26.22;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	92.11.17.16.50.21;	author matthew;	state Exp;
branches;
next	;

1.10.1.1
date	93.07.28.14.36.07;	author jont;	state Exp;
branches;
next	;

1.26.1.1
date	96.09.13.11.18.39;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.10.07.16.08.32;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.10.17.11.26.46;	author hope;	state Exp;
branches;
next	;

1.27.1.1
date	96.11.14.12.52.10;	author hope;	state Exp;
branches
	1.27.1.1.1.1;
next	;

1.27.1.1.1.1
date	96.11.28.15.03.09;	author hope;	state Exp;
branches;
next	;

1.27.2.1
date	96.11.22.18.11.20;	author hope;	state Exp;
branches;
next	;

1.27.3.1
date	96.12.17.17.49.52;	author hope;	state Exp;
branches
	1.27.3.1.1.1;
next	;

1.27.3.1.1.1
date	97.02.24.11.40.04;	author hope;	state Exp;
branches;
next	;

1.27.4.1
date	96.12.18.09.43.57;	author hope;	state Exp;
branches;
next	;

1.27.5.1
date	97.05.12.10.36.26;	author hope;	state Exp;
branches
	1.27.5.1.1.1
	1.27.5.1.2.1
	1.27.5.1.3.1;
next	;

1.27.5.1.1.1
date	97.07.28.18.21.04;	author daveb;	state Exp;
branches
	1.27.5.1.1.1.1.1;
next	;

1.27.5.1.1.1.1.1
date	97.10.07.11.46.32;	author jkbrook;	state Exp;
branches;
next	;

1.27.5.1.2.1
date	97.09.08.17.14.31;	author daveb;	state Exp;
branches;
next	;

1.27.5.1.3.1
date	97.09.09.14.10.24;	author daveb;	state Exp;
branches;
next	;

1.28.1.1
date	97.09.10.19.26.20;	author brucem;	state Exp;
branches;
next	;

1.28.2.1
date	97.09.11.20.56.22;	author daveb;	state Exp;
branches;
next	;

1.30.1.1
date	99.04.01.17.58.01;	author daveb;	state Exp;
branches;
next	;


desc
@General information output structure, replacing Error.
@


1.30
log
@[Bug #190507]
The default error reported shouldn't update the error count.
@
text
@(*  ==== COMPILER INFORMATION OUTPUT ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: _info.sml,v $
 * Revision 1.29  1998/07/29  13:17:54  mitchell
 * [Bug #30450]
 * Fix broken null output routine
 *
 * Revision 1.28  1997/05/22  11:59:23  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.26  1996/04/30  14:21:09  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.25  1996/04/01  13:16:53  matthew
 * Adding error_occurred function
 *
 * Revision 1.24  1996/03/27  14:53:45  jont
 * Modify null_options to use a null_out outstream that throws away its output
 *
 * Revision 1.23  1996/03/20  16:19:08  daveb
 * Changed definition of default_error' so that each application creates
 * a new set of options.
 *
 * Revision 1.22  1996/03/20  12:12:50  matthew
 * Changes for value polymorphism
 *
 * Revision 1.21  1996/03/15  12:29:41  daveb
 * Removed default_options, as it could be used inappropriately.
 * Added default_error' to handle cases where the default options can be used
 * reasonably safely.
 * Removed with_error_list because it wasn't used anywhere.
 *
 * Revision 1.20  1996/01/22  16:06:49  matthew
 * Adding null_options
 *
Revision 1.19  1995/09/11  14:51:01  matthew
Changing default output stream to MLWorks.IO.std_err

Revision 1.18  1995/09/08  13:26:04  matthew
Improving behaviour of wrap when exceptions are raised in body.

Revision 1.17  1995/02/27  16:04:33  daveb
Changed printing of fatal errors.  Users don't see what the difference is.

Revision 1.16  1993/12/16  15:12:37  matthew
 Changed push_error so errors are only recorded in the scope of a with_error_list

Revision 1.15  1993/12/15  11:30:18  matthew
Added type constraint to error_list_ref

Revision 1.14  1993/12/10  17:17:58  matthew
Added with_error_list to determine errors occuring in dynamic scope.
This is a bit grotty and is intended as a quicky fix.

Revision 1.13  1993/11/30  18:36:20  matthew
Made error count ignore warnings.

Revision 1.12  1993/11/29  15:50:23  matthew
Added a limit to the number of recoverable errors occuring.
(Modifiable) maximum number of errors is in max_num_errors: int ref

Revision 1.11  1993/10/29  16:52:37  nickh
Removed redundant string_err function.

Revision 1.10  1993/07/28  14:36:07  matthew
Added make_default_options function

Revision 1.9  1993/07/12  12:15:13  jont
Modified wrap to use the same ref for worst case when making a new wrapper,
and to remember the old value on the procedure stack. This allows for simpler
code when a small section is to be wrapped and its dynamic scope is not
within its lexical scope

Revision 1.8  1993/05/27  10:20:14  matthew
Added Location parameter to wrap
Used when raising Stop exception
Changed outstream field to report_fun
Added with_report_fun

Revision 1.7  1993/04/16  15:42:21  matthew
 Hid definition of options type
Added error list field to Stop exception

Revision 1.6  1993/03/03  18:23:49  matthew
removed printing controls

Revision 1.5  1993/02/24  14:59:36  matthew
Set show_eq_info default to false

Revision 1.4  1992/11/30  17:10:51  matthew
Used pervasive streams

Revision 1.3  1992/11/25  20:38:32  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.2  1992/11/19  13:26:22  matthew
Fixed problem with wrap

Revision 1.1  1992/11/17  16:50:21  matthew
Initial revision

 *)

require "../basis/__char_array";
require "../basis/__char_vector";
require "../basis/__text_io";
require "../basis/__text_prim_io";
require "../basis/__io";

require "^.basics.location";
require "info";

functor Info (structure Location : LOCATION) : INFO =
  struct
    structure Location = Location

    datatype severity =
      ADVICE |                          (* e.g. `unnecessary op' *)
      WARNING |                         (* legal, but odd *)
      NONSTANDARD |                     (* non-standard, but understood *)
      RECOVERABLE |                     (* recoverable error *)
      FATAL |                           (* can't continue *)
      FAULT                             (* fault in the compiler *)

    local
      fun sort ADVICE = 0
        | sort WARNING = 1
        | sort NONSTANDARD = 2
        | sort RECOVERABLE = 3
        | sort FATAL = 4
        | sort FAULT = 4
    in
      val (op<) = fn (s1, s2) => sort s1 < sort s2
    end

    fun level_to_string ADVICE = "advice"
      | level_to_string WARNING = "warning"
      | level_to_string NONSTANDARD = "non-SML feature"
      | level_to_string RECOVERABLE = "error"
      | level_to_string FATAL = "error"
      | level_to_string FAULT = "compiler fault"

    datatype error =
      ERROR of severity * Location.T * string

    datatype options =
      OPTIONS of
      {error       : {report_fun    : (error -> unit) option,
                      stop	: severity,
                      report	: severity,
                      worst	: severity ref},
       listing	   : {outstream : TextIO.outstream,
                      level     : int},
       error_list : error list ref,
       error_count : int ref
       }

    fun worst_error (OPTIONS {error = {worst,...},
                              ...}) =
      !worst

    exception Stop of error * error list

    fun make_list (severity,location,message) =
      [Location.to_string location, ": ", level_to_string severity,
       ": ", message]

    fun string_error (ERROR packet) = concat (make_list packet)

    fun report_fun (ERROR packet) =
      (app
       (fn s => TextIO.output(TextIO.stdErr,s))
       (make_list packet);
       TextIO.output(TextIO.stdErr,"\n"))

    fun make_default_options () =
      OPTIONS {error = {report_fun = SOME report_fun,
                        stop = FATAL,
                        report = ADVICE,
                        worst = ref ADVICE},
               listing = {outstream = TextIO.stdOut,
                          level = 2},
               error_list = ref [],
               error_count = ref 0
               }

    val null_writer =
      let
	fun null_fun_vec {buf, i, sz} = 
          CharVector.length(CharVector.extract(buf,i,sz))
	fun null_fun_arr {buf, i, sz} = 
          CharVector.length(CharArray.extract(buf,i,sz))
	val null_fun_option = fn _ => NONE
      in
	TextPrimIO.WR
	{writeVecNB = SOME null_fun_option,
	 writeArrNB = SOME null_fun_option,
	 writeVec = SOME null_fun_vec,
	 writeArr = SOME null_fun_arr,
	 block = NONE,
	 canOutput = SOME(fn _ => true),
	 name = "sink",
	 chunkSize = 1,
	 close = fn _ => (),
	 getPos = NONE,
	 setPos = NONE,
	 endPos = NONE,
	 verifyPos = NONE,
	 ioDesc = NONE}
      end

    val null_out =
      TextIO.mkOutstream(TextIO.StreamIO.mkOutstream(null_writer, IO.NO_BUF))

    val null_options =
      OPTIONS {error = {report_fun = NONE,
                        stop = FATAL,
                        report = ADVICE,
                        worst = ref ADVICE},
               listing = {outstream = null_out,
                          level = 2},
               error_list = ref [],
               error_count = ref 0
               }

      
    val max_num_errors = ref 30;

    fun error (OPTIONS {error = {report_fun=NONE, stop, ...},error_list,...})
              (packet as (severity, location, message)) =
          if severity < stop then () else raise Stop (ERROR packet,[])

      | error (OPTIONS {error = {report_fun=SOME report_fun, stop, report, worst},
                        error_list, error_count,...})
              (packet as (severity, location, message)) =
      let
        val error = ERROR packet
      in
        error_list := error :: (!error_list);
        if severity < report then () else report_fun error;
        if severity < !worst then () else worst := severity;
        if NONSTANDARD < severity then error_count := (!error_count) + 1 else ();
        if (!error_count) >= (!max_num_errors)
          then
            let val error2 = ERROR (FATAL,location,"Too many errors, giving up")
            in
              report_fun error2;
              raise Stop (error2,(error2::(!error_list)))
            end
        else
          if severity < stop then () else raise Stop (error,!error_list)
      end
    
    fun error'
	  (OPTIONS {error = {report_fun=NONE, report, worst, ...}, 
                             error_list,...})
          (packet as (severity, location, message)) =
          raise Stop (ERROR packet,[])
      | error'
	  (OPTIONS {error = {report_fun=SOME report_fun, report, worst, ...}, 
                             error_list,...})
          (packet as (severity, location, message)) =
      let
        val error = ERROR packet
      in
        error_list := error :: (!error_list);
        if severity < report then () else report_fun error;
        if severity < !worst then () else worst := severity;
        raise Stop (error,!error_list)
      end
    
    fun default_error' packet = error' (make_default_options ()) packet

    fun with_report_fun
      (OPTIONS {error = {report_fun, stop, report, worst},
                listing,
                error_list,
                error_count})
      new_report_fun f a =
      f
      (OPTIONS
       {error = {report_fun = SOME new_report_fun,
                 stop   = stop,
                 report = report,
                 worst  = worst},
       listing = listing,
       error_list = error_list,
       error_count = error_count
       })
      a

    fun wrap (OPTIONS {error = {report_fun, stop, report, worst},
		       listing,
                       ...})
             (stop', finish', report',location) f a =
      let
        val error_list = ref []
        val error_count = ref 0
	val old_worst = !worst (* Remember current value *)
	val _ = worst := ADVICE
        fun finish () =
          if  !worst < finish' 
            then
              if !worst < old_worst then worst := old_worst else ()
          else 
            raise Stop (ERROR (!worst,location,"Finish of block"),!error_list)
        val result =
          f (OPTIONS 
             {error = {report_fun = report_fun,
                       stop   = if stop' < stop then stop' else stop,
                       report = if report' < report then report' else report,
                       worst  = worst},
             listing = listing,
             error_list = error_list,
             error_count = error_count
             })
            a
            handle exn => (finish (); raise exn)
      in
        finish ();
        result
      end

    fun listing_fn(OPTIONS {listing = {level,outstream},...}) (level',text_fn) = 
      if level' > level
        then text_fn outstream
      else ()

  end
@


1.30.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a7 4
 * Revision 1.30  1999/02/17  13:14:32  mitchell
 * [Bug #190507]
 * The default error reported shouldn't update the error count.
 *
@


1.29
log
@[Bug #30450]
Fix broken null output routine
@
text
@d8 4
d161 1
a161 1
      {error       : {report_fun    : error -> unit,
d190 1
a190 1
      OPTIONS {error = {report_fun = report_fun,
d229 1
a229 1
      OPTIONS {error = {report_fun = fn _ => (),
d242 7
a248 2
    fun error (OPTIONS {error = {report_fun, stop, report, worst},error_list, error_count,...})
      (packet as (severity, location, message)) =
d268 7
a274 1
	  (OPTIONS {error = {report_fun, report, worst, ...}, error_list,...})
d295 1
a295 1
       {error = {report_fun = new_report_fun,
@


1.28
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@d8 4
d113 2
d198 4
a201 1
	val null_fun = fn _ => 0
d207 2
a208 2
	 writeVec = SOME null_fun,
	 writeArr = SOME null_fun,
@


1.28.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a7 4
 * Revision 1.28  1997/05/22  11:59:23  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.28.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a7 4
 * Revision 1.28  1997/05/22  11:59:23  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.27
log
@[Bug #1614]
basifying String
@
text
@d8 4
d109 4
d155 1
a155 1
       listing	   : {outstream : MLWorks.IO.outstream,
d175 1
a175 1
       (fn s => MLWorks.IO.output(MLWorks.IO.std_err,s))
d177 1
a177 1
       MLWorks.IO.output(MLWorks.IO.std_err,"\n"))
d184 1
a184 1
               listing = {outstream = MLWorks.IO.std_out,
d190 24
a213 5
    val null_out = MLWorks.IO.outstream
      {close_out = fn _ => (),
       closed_out = fn _ => false,
       flush_out = fn _ => (),
       output = fn _ => ()}
@


1.27.5.1
log
@branched from 1.27
@
text
@a7 4
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
@


1.27.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a7 3
 * Revision 1.27.5.1  1997/05/12  10:36:26  hope
 * branched from 1.27
 *
@


1.27.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a7 3
 * Revision 1.27.5.1  1997/05/12  10:36:26  hope
 * branched from 1.27
 *
@


1.27.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a7 3
 * Revision 1.27.5.1  1997/05/12  10:36:26  hope
 * branched from 1.27
 *
@


1.27.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a7 3
 * Revision 1.27.5.1.1.1  1997/07/28  18:21:04  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.27.4.1
log
@branched from 1.27
@
text
@a7 4
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
@


1.27.3.1
log
@branched from 1.27
@
text
@a7 4
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
@


1.27.3.1.1.1
log
@branched from 1.27.3.1
@
text
@a7 3
 * Revision 1.27.3.1  1996/12/17  17:49:52  hope
 * branched from 1.27
 *
@


1.27.2.1
log
@branched from 1.27
@
text
@a7 4
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
@


1.27.1.1
log
@branched from 1.27
@
text
@a7 4
 * Revision 1.27  1996/10/29  16:05:48  io
 * [Bug #1614]
 * basifying String
 *
@


1.27.1.1.1.1
log
@branched from 1.27.1.1
@
text
@a7 3
 * Revision 1.27.1.1  1996/11/14  12:52:10  hope
 * branched from 1.27
 *
@


1.26
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d8 6
d105 1
a105 3
require "../utils/lists";
require "../basics/location";

d108 1
a108 2
functor Info (structure Lists : LISTS
              structure Location : LOCATION) : INFO =
d163 1
a163 1
    fun string_error (ERROR packet) = String.implode (make_list packet)
d166 1
a166 1
      (Lists.iterate
@


1.26.3.1
log
@branched from 1.26
@
text
@a7 6
 * Revision 1.26  1996/04/30  14:21:09  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a7 6
 * Revision 1.26  1996/04/30  14:21:09  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a7 6
 * Revision 1.26  1996/04/30  14:21:09  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.25
log
@Adding error_occurred function
@
text
@d8 3
d144 1
a144 1
       listing	   : {outstream : outstream,
d160 1
a160 1
    fun string_error (ERROR packet) = implode (make_list packet)
d164 1
a164 1
       (fn s => output(MLWorks.IO.std_err,s))
d166 1
a166 1
       output(MLWorks.IO.std_err,"\n"))
d173 1
a173 1
               listing = {outstream = std_out,
@


1.24
log
@Modify null_options to use a null_out outstream that throws away its output
@
text
@d8 3
d146 4
@


1.23
log
@Changed definition of default_error' so that each application creates
a new set of options.
@
text
@d8 4
d169 6
d180 1
a180 1
               listing = {outstream = std_out,
@


1.22
log
@Changes for value polymorphism
@
text
@d8 3
d210 2
a211 6

    local
      val default_options = make_default_options ()
    in
      fun default_error' args = error' default_options args
    end
@


1.21
log
@Removed default_options, as it could be used inappropriately.
Added default_error' to handle cases where the default options can be used
reasonably safely.
Removed with_error_list because it wasn't used anywhere.
@
text
@d8 6
d207 6
a212 2
    
    val default_error' = error' (make_default_options ())
@


1.20
log
@Adding null_options
@
text
@d8 3
a155 2
    val default_options = make_default_options ()

a169 9
    (* Use this flag to prevent errors being kept when not in with_error_list *)
    val accumulate_errors = ref false
    val error_list_ref = ref ([] : error list);

    fun push_error e = 
      if !accumulate_errors
        then error_list_ref := (e :: !error_list_ref)
      else ()

a175 1
        push_error error;
d190 3
a192 2
    fun error' (OPTIONS {error = {report_fun, report, worst, ...}, error_list,...})
      (packet as (severity, location, message)) =
a195 1
        push_error error;
d202 2
a221 19
    fun with_error_list f x =
      let
        val old_error_list = !error_list_ref
        val old_accumulate_errors = !accumulate_errors
        (* Only accumulate errors in this dynamic scope *)
        val _ = error_list_ref := []
        val _ = accumulate_errors := true
        val result = f x 
                     handle exn =>
                       (error_list_ref := old_error_list;
                        accumulate_errors := old_accumulate_errors;
                        raise exn)
        val result_error_list = !error_list_ref
      in
        error_list_ref := old_error_list;
        accumulate_errors := old_accumulate_errors;
        (result,result_error_list)
      end
        
@


1.19
log
@Changing default output stream to MLWorks.IO.std_err
@
text
@d8 3
a121 2
       information : {outstream : outstream,
                      level	: int},
a123 2
       diagnostic  : {outstream : outstream,
                      level     : int},
a146 2
               information = {outstream = std_out,
                              level = 2},
a148 2
               diagnostic = {outstream = std_out,
                             level = 2},
d154 13
a166 1
    
a212 1
                information,
a213 1
                diagnostic,
a222 1
       information = information,
a223 1
       diagnostic = diagnostic,
a248 1
		       information,
a249 1
		       diagnostic,
a268 1
             information = information,
a269 1
             diagnostic = diagnostic,
a278 15

    fun information(OPTIONS {information = {outstream,level},...}) (level',text) = 
      if level' > level
        then output(outstream,text)
      else ()

    fun diagnostic(OPTIONS {diagnostic = {outstream,level},...}) (level',text) = 
      if level' > level
        then output(outstream,text)
      else ()

    fun diagnostic_fn(OPTIONS {diagnostic = {level,outstream},...}) (level',text_fn) = 
      if level' > level
        then text_fn outstream
      else ()
@


1.18
log
@Improving behaviour of wrap when exceptions are raised in body.
@
text
@d8 3
d139 1
a139 1
       (fn s => output(std_out,s))
d141 1
a141 1
       output(std_out,"\n"))
@


1.17
log
@Changed printing of fatal errors.  Users don't see what the difference is.
@
text
@d8 3
d253 6
d272 1
d274 2
a275 5
        if  !worst < finish' then
            (if !worst < old_worst then worst := old_worst else ();
               result)
        else 
          raise Stop (ERROR (!worst,location,"Finish of block"),!error_list)
@


1.16
log
@ Changed push_error so errors are only recorded in the scope of a with_error_list
@
text
@d8 3
d101 1
a101 1
      | level_to_string FATAL = "fatal error"
@


1.15
log
@Added type constraint to error_list_ref
@
text
@d8 3
d153 2
d157 4
a160 1
    fun push_error e = error_list_ref := (e :: !error_list_ref)
d220 9
a228 1
        val result = f x handle exn => (error_list_ref := old_error_list;raise exn)
d232 1
@


1.14
log
@Added with_error_list to determine errors occuring in dynamic scope.
This is a bit grotty and is intended as a quicky fix.
@
text
@d8 4
d150 1
a150 1
    val error_list_ref = ref [];
@


1.13
log
@Made error count ignore warnings.
@
text
@d8 3
d146 4
d156 1
d176 1
d205 10
@


1.12
log
@Added a limit to the number of recoverable errors occuring.
(Modifiable) maximum number of errors is in max_num_errors: int ref
@
text
@d8 4
d106 2
a107 1
       error_list : error list ref
d135 2
a136 1
               error_list = ref []
d143 1
a143 1
    fun error (OPTIONS {error = {report_fun, stop, report, worst},error_list, ...})
d151 2
a152 1
        if (Lists.length (!error_list)) >= (!max_num_errors)
d170 2
a171 2
          if severity < !worst then () else worst := severity;
            raise Stop (error,!error_list)
d179 2
a180 1
                error_list})
d191 2
a192 1
       error_list = error_list
d204 1
d216 2
a217 1
             error_list = error_list
@


1.11
log
@Removed redundant string_err function.
@
text
@d8 3
d135 2
d144 10
a153 2
          if severity < !worst then () else worst := severity;
            if severity < stop then () else raise Stop (error,!error_list)
@


1.10
log
@Added make_default_options function
@
text
@d8 3
a131 10
    fun string_err severity =
      case severity of
	ADVICE => "advice"
      | WARNING => "warning"
      | NONSTANDARD => "non-SML feature"
      | RECOVERABLE => "error"
      | FATAL => "fatal error"
      | FAULT => "compiler fault"


@


1.10.1.1
log
@Fork for bug fixing
@
text
@a7 3
Revision 1.10  1993/07/28  14:36:07  matthew
Added make_default_options function

@


1.9
log
@Modified wrap to use the same ref for worst case when making a new wrapper,
and to remember the old value on the procedure stack. This allows for simpler
code when a small section is to be wrapped and its dynamic scope is not
within its lexical scope
@
text
@d8 6
d113 1
a113 1
    val default_options =
d127 1
@


1.8
log
@Added Location parameter to wrap
Used when raising Stop exception
Changed outstream field to report_fun
Added with_report_fun
@
text
@d8 6
d68 6
a73 8
    fun level_to_string level =
      case level
        of ADVICE => "advice"
         | WARNING => "warning"
         | NONSTANDARD => "non-SML feature"
         | RECOVERABLE => "error"
         | FATAL => "fatal error"
         | FAULT => "compiler fault"
d96 2
a97 9
      [Location.to_string location, ": ",
       case severity
         of ADVICE => "advice"
          | WARNING => "warning"
          | NONSTANDARD => "non-SML feature"
          | RECOVERABLE => "error"
          | FATAL => "fatal error"
          | FAULT => "compiler fault",
              ": ", message]
d122 10
d182 2
a183 1
        val worst' = ref ADVICE
d189 1
a189 1
                       worst  = worst'},
d197 2
a198 3
        if  !worst' < finish'
          then
            (if !worst < !worst' then worst := !worst' else ();
d201 1
a201 1
          raise Stop (ERROR (!worst',location,"Finish of block"),!error_list)
@


1.7
log
@ Hid definition of options type
Added error list field to Stop exception
@
text
@d8 4
d76 1
a76 1
      {error       : {outstream : outstream,
d89 21
d111 1
a111 1
      OPTIONS {error = {outstream = std_out,
d124 42
a165 36
    exception Stop of error * error list

    local

      fun write (outstream, (severity, location, message)) =
        let
          val print = Lists.iterate (fn s => output (outstream, s))
        in
          print [Location.to_string location, ": "];
          print [case severity
                   of ADVICE => "advice"
                    | WARNING => "warning"
                    | NONSTANDARD => "non-SML feature"
                    | RECOVERABLE => "error"
                    | FATAL => "fatal error"
                    | FAULT => "compiler fault",
                 ": ", message, "\n"]
        end

    in

      fun error (OPTIONS {error = {outstream, stop, report, worst},error_list, ...})
                (packet as (severity, location, message)) =
        (error_list := (ERROR packet) :: (!error_list);
         if severity < report then () else write (outstream, packet);
         if severity < !worst then () else worst := severity;
         if severity < stop then () else raise Stop (ERROR packet,!error_list))

      fun error' (OPTIONS {error = {outstream, report, worst, ...}, error_list,...})
                 (packet as (severity, location, message)) =
        (error_list := (ERROR packet) :: (!error_list);
         if severity < report then () else write (outstream, packet);
         if severity < !worst then () else worst := severity;
         raise Stop (ERROR packet,!error_list))

    end
d167 1
a167 1
    fun wrap (OPTIONS {error = {outstream, stop, report, worst},
d172 1
a172 1
             (stop', finish', report') f a =
d178 1
a178 1
             {error = {outstream = outstream,
d194 1
a194 1
          raise Stop (ERROR (!worst',Location.UNKNOWN,"Finish of block"),!error_list)
@


1.6
log
@removed printing controls
@
text
@d8 3
d67 3
d81 2
a82 1
                      level     : int}
d95 2
a96 1
                             level = 2}
d99 1
a99 4
    datatype error =
      ERROR of severity * Location.T * string

    exception Stop of error
d120 1
a120 1
      fun error (OPTIONS {error = {outstream, stop, report, worst}, ...})
d122 2
a123 1
        (if severity < report then () else write (outstream, packet);
d125 1
a125 1
         if severity < stop then () else raise Stop (ERROR packet))
d127 1
a127 1
      fun error' (OPTIONS {error = {outstream, report, worst, ...}, ...})
d129 2
a130 1
        (if severity < report then () else write (outstream, packet);
d132 1
a132 1
         raise Stop (ERROR packet))
d139 2
a140 2
		       diagnostic
	     })
d143 1
d153 2
a154 1
             diagnostic = diagnostic
d163 1
a163 1
          raise Stop (ERROR (!worst',Location.UNKNOWN,"Finish of block"))
@


1.5
log
@Set show_eq_info default to false
@
text
@d8 3
d75 2
a76 4
                      level     : int},
       show_id_class: bool,
       show_eq_info : bool
      }
d88 2
a89 4
                             level = 2},
               show_eq_info = false,
               show_id_class = false
      }
d132 1
a132 3
		       diagnostic,
       		       show_id_class,
       		       show_eq_info
d145 1
a145 3
             diagnostic = diagnostic,
	     show_id_class = show_id_class,
	     show_eq_info = show_eq_info
@


1.4
log
@Used pervasive streams
@
text
@d8 3
d88 1
a88 1
               show_eq_info = true,
@


1.3
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d8 4
a19 1
require "../utils/stream";
d25 1
a25 2
functor Info (structure Stream	 : STREAM
              structure Lists : LISTS
a27 1
    structure Stream = Stream
d60 1
a60 1
      {error       : {outstream : Stream.outstream,
d64 1
a64 1
       information : {outstream : Stream.outstream,
d66 1
a66 1
       listing	   : {outstream : Stream.outstream,
d68 1
a68 1
       diagnostic  : {outstream : Stream.outstream,
a73 6
    val dummy_stream =
      Stream.outstream{output = fn s => output(std_out,s),
                       flush_out = fn () => (),
                       close_out = fn () => ()
      }

d75 1
a75 1
      OPTIONS {error = {outstream = dummy_stream,
d79 1
a79 1
               information = {outstream = dummy_stream,
d81 1
a81 1
               listing = {outstream = dummy_stream,
d83 1
a83 1
               diagnostic = {outstream = dummy_stream,
d98 1
a98 1
          val print = Lists.iterate (fn s => Stream.output (outstream, s))
d161 1
a161 1
        then Stream.output(outstream,text)
d166 1
a166 1
        then Stream.output(outstream,text)
@


1.2
log
@Fixed problem with wrap
@
text
@d8 3
d68 25
a92 2
                      level     : int}}

d132 7
a138 1
    fun wrap (OPTIONS {error = {outstream, stop, report, worst}, information, listing, diagnostic})
d150 3
a152 1
             diagnostic = diagnostic
a184 2


@


1.1
log
@Initial revision
@
text
@d7 4
a10 1
 *  $Log$
d45 9
d107 1
a107 1
             (stop', finish', report') f =
d120 1
d122 4
a125 2
        if finish' < !worst' 
          then raise Stop (ERROR (!worst',Location.UNKNOWN,"Finish of block"))
d127 1
a127 2
          (if !worst < !worst' then worst := !worst' else ();
             result)
@
