head	1.50;
access;
symbols
	MLWorks_20m1_1997_10_23:1.50
	MLWorks_11r1:1.46.1.1.1.1.1
	MLWorks_workspace_97:1.50.2
	MLWorks_dt_wizard:1.50.1
	MLWorks_11c0_1997_09_09:1.46.1.1.1.1
	MLWorks_10r3:1.46.1.1.3
	MLWorks_10r2_551:1.46.1.1.2
	MLWorks_11:1.46.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.46.1.1
	MLWorks_20m0_1997_06_20:1.50
	MLWorks_1_0_r2c2_1997_06_14:1.46.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.46.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.46.1
	MLWorks_BugFix_1997_04_24:1.46
	MLWorks_1_0_r2_Win32_1997_04_11:1.46
	MLWorks_1_0_r2_Unix_1997_04_04:1.46
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.45.3.1.1
	MLWorks_gui_1996_12_18:1.45.4
	MLWorks_1_0_Win32_1996_12_17:1.45.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.45.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.45.1.1
	MLWorks_1_0_Irix_1996_11_28:1.45.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.45.2
	MLWorks_1_0_Unix_1996_11_14:1.45.1
	MLWorks_Open_Beta2_1996_10_11:1.44.3
	MLWorks_License_dev:1.44.2
	MLWorks_1_open_beta_1996_09_13:1.44.1
	MLWorks_Open_Beta_1996_08_22:1.44
	MLWorks_Beta_1996_07_02:1.43
	MLWorks_Beta_1996_06_07:1.43
	MLWorks_Beta_1996_06_06:1.43
	MLWorks_Beta_1996_06_05:1.43
	MLWorks_Beta_1996_06_03:1.43
	MLWorks_Beta_1996_05_31:1.43
	MLWorks_Beta_1996_05_30:1.43
	ML_beta_release_12/08/94:1.25
	ML_beta_release_03/08/94:1.25
	ML_revised_beta_release_25/05/94:1.25
	ML_final_beta_release_02/03/94:1.25
	mlworks-28-01-1994:1.21
	Release:1.17
	mlworks-beta-01-09-1993:1.17
	MLWorks-1-0-4-29/01/1993:1.8
	MLWorks-1-0-3-21/12/1992:1.8
	MLWorks-1-0-2-15/12/1992:1.8
	MLWorks-1-0-1-04/12/1992:1.8
	checkpoint_17_08_92:1.3;
locks; strict;
comment	@ * @;


1.50
date	97.05.27.09.01.29;	author johnh;	state Exp;
branches
	1.50.1.1
	1.50.2.1;
next	1.49;

1.49
date	97.05.19.11.09.11;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	97.05.12.15.55.06;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	97.05.01.13.14.53;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	97.03.06.14.14.32;	author jont;	state Exp;
branches
	1.46.1.1;
next	1.45;

1.45
date	96.10.29.17.04.43;	author io;	state Exp;
branches
	1.45.1.1
	1.45.2.1
	1.45.3.1
	1.45.4.1;
next	1.44;

1.44
date	96.07.11.17.03.41;	author jont;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1;
next	1.43;

1.43
date	96.05.23.12.16.41;	author stephenb;	state Exp;
branches;
next	1.42;

1.42
date	96.05.21.11.33.24;	author stephenb;	state Exp;
branches;
next	1.41;

1.41
date	96.04.30.14.37.16;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	96.04.18.15.18.55;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	96.04.17.14.36.27;	author stephenb;	state Exp;
branches;
next	1.38;

1.38
date	96.04.17.10.20.54;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	96.03.27.10.11.22;	author stephenb;	state Exp;
branches;
next	1.36;

1.36
date	96.03.25.17.35.42;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	96.03.15.14.35.38;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	95.12.05.11.04.14;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	95.04.21.16.53.43;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	95.04.21.14.33.20;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.04.19.12.35.15;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	95.04.12.13.28.41;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	95.01.25.17.27.50;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	95.01.23.17.50.38;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	95.01.18.14.06.38;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	94.12.08.16.56.01;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	94.02.24.11.04.20;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	94.02.09.09.41.34;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	94.02.08.15.16.30;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	94.02.01.15.16.55;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	93.11.19.18.22.38;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	93.11.18.14.43.03;	author nickh;	state Exp;
branches;
next	1.19;

1.19
date	93.11.16.16.02.30;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.10.27.14.03.56;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.08.29.18.30.30;	author daveb;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	93.08.25.12.58.26;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	93.08.25.11.21.52;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	93.08.19.14.39.26;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	93.08.18.12.58.22;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	93.08.12.16.51.49;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	93.06.17.14.33.58;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	93.05.05.17.16.46;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	93.02.24.14.32.14;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.09.02.14.22.01;	author richard;	state Exp;
branches;
next	1.7;

1.7
date	92.08.21.14.23.10;	author richard;	state Exp;
branches;
next	1.6;

1.6
date	92.08.20.15.02.19;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.08.20.12.44.37;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.08.17.14.02.31;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	92.08.10.11.33.10;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	92.08.03.11.53.05;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	92.07.22.15.35.35;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	93.08.29.18.30.30;	author jont;	state Exp;
branches;
next	1.17.1.2;

1.17.1.2
date	93.10.27.16.27.18;	author daveb;	state Exp;
branches;
next	;

1.44.1.1
date	96.09.13.11.18.23;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.10.07.16.08.15;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.10.17.11.26.29;	author hope;	state Exp;
branches;
next	;

1.45.1.1
date	96.11.14.12.51.48;	author hope;	state Exp;
branches
	1.45.1.1.1.1;
next	;

1.45.1.1.1.1
date	96.11.28.15.02.50;	author hope;	state Exp;
branches;
next	;

1.45.2.1
date	96.11.22.18.11.00;	author hope;	state Exp;
branches;
next	;

1.45.3.1
date	96.12.17.17.49.35;	author hope;	state Exp;
branches
	1.45.3.1.1.1;
next	;

1.45.3.1.1.1
date	97.02.24.11.39.44;	author hope;	state Exp;
branches;
next	;

1.45.4.1
date	96.12.18.09.43.38;	author hope;	state Exp;
branches;
next	;

1.46.1.1
date	97.05.12.10.36.08;	author hope;	state Exp;
branches
	1.46.1.1.1.1
	1.46.1.1.2.1
	1.46.1.1.3.1;
next	;

1.46.1.1.1.1
date	97.07.28.18.21.49;	author daveb;	state Exp;
branches
	1.46.1.1.1.1.1.1;
next	;

1.46.1.1.1.1.1.1
date	97.10.07.11.47.29;	author jkbrook;	state Exp;
branches;
next	;

1.46.1.1.2.1
date	97.09.08.17.15.14;	author daveb;	state Exp;
branches;
next	;

1.46.1.1.3.1
date	97.09.09.14.11.06;	author daveb;	state Exp;
branches;
next	;

1.50.1.1
date	97.09.10.19.27.07;	author brucem;	state Exp;
branches;
next	;

1.50.2.1
date	97.09.11.20.57.08;	author daveb;	state Exp;
branches;
next	;


desc
@Common file and filename manipulation functions
@


1.50
log
@[Bug #20033]
Pass 'silent' param to set_source_path_from_env.
@
text
@(* _io.sml the functor *)
(*
$Log: _io.sml,v $
 * Revision 1.49  1997/05/19  11:09:11  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
 * Revision 1.48  1997/05/12  15:55:06  jont
 * [Bug #20050]
 * Change name to MLWorksIO to avoid clash with basis.io
 *
 * Revision 1.47  1997/05/01  13:14:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.46  1997/03/06  14:14:32  jont
 * [Bug #1940]
 * Modify set_pervasive_dir such that bad pervasive dirs merely warn.
 * Do similar modifications for setting source and object paths
 *
 * Revision 1.45  1996/10/29  17:04:43  io
 * moving String from toplevel
 *
 * Revision 1.44  1996/07/11  17:03:41  jont
 * Handle OS.SysErr in set_source_path
 *
 * Revision 1.43  1996/05/23  12:16:41  stephenb
 * Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
 * now does what the former used to do.
 *
 * Revision 1.42  1996/05/21  11:33:24  stephenb
 * Change to pull in Path directly rather than OS.Path since the latter
 * now conforms to the latest basis and it is too much effort to update
 * the code to OS.Path at this point.
 *
 * Revision 1.41  1996/04/30  14:37:16  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.40  1996/04/18  15:18:55  jont
 * initbasis moves to basis
 *
 * Revision 1.39  1996/04/17  14:36:27  stephenb
 * Update wrt Os -> OS name change.
 *
 * Revision 1.38  1996/04/17  10:20:54  jont
 * Ensure set_source_path does realpath expansion
 *
 * Revision 1.37  1996/03/27  10:11:22  stephenb
 * Update to use the OS structure from the latest revised basis.
 *
 * Revision 1.36  1996/03/25  17:35:42  jont
 * Print message when setting object path from environment
 *
 * Revision 1.35  1996/03/15  14:35:38  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.34  1995/12/05  11:04:14  daveb
 * Added space to beginning of pervasive module names.
 * Changed ModuleId.from_string to ModuleId.from_mo_string.
 *
Revision 1.33  1995/04/21  16:53:43  jont
Remove FileSys.realPath call from set_object_path (delayed application required)

Revision 1.32  1995/04/21  14:33:20  daveb
The path setting functions now handle the BadHomeName exception
themselves, and take a location argument.
Expansion of home dirs has moved from filesys to getenv.
filesys and path have moved from utils to initbasis.

Revision 1.31  1995/04/19  12:35:15  jont
Modifications to add object paths

Revision 1.30  1995/04/12  13:28:41  jont
Change FILESYS to FILE_SYS

Revision 1.29  1995/01/25  17:27:50  daveb
Moved functionality for parsing environment paths into getenv.sml.
Replaced Option structure with references to MLWorks.Option.

Revision 1.28  1995/01/23  17:50:38  jont
Ensure preceding spaces are removed from pervasive_dir environment values

Revision 1.27  1995/01/18  14:06:38  jont
Parameterise environment value separator on getenv

Revision 1.26  1994/12/08  16:56:01  jont
Move OS specific stuff into a system link directory

Revision 1.25  1994/02/24  11:04:20  daveb
Fixed types of set_pervasive_dir.

Revision 1.24  1994/02/09  09:41:34  matthew
Fixed NJ type bug

Revision 1.23  1994/02/08  15:16:30  daveb
source_path is no longer a list option ref, just a list ref.
set_source_path takes a directory list argument.  Other set_source_path
functions call FileName.parse_directory, thus ensuring expansion.

Revision 1.22  1994/02/01  15:16:55  daveb
Added  pervasive_library_id and builtin_library_id, made ModuleId an
eqtype, moved getenv functionality to a separate module, and moved\ntrans_home_name functionality to filename.

Revision 1.21  1993/11/19  18:22:38  daveb
Ensured that pervasive dir always undergoes ~ translation and ends in /.

Revision 1.20  1993/11/18  14:43:03  nickh
Change when "Setting pervasive dir..." message is printed, to make
MLWorks startup less intimidating.

Revision 1.19  1993/11/16  16:02:30  jont
Made set_pervasive_dir call trans_home_name on its argument

Revision 1.18  1993/10/27  14:03:56  daveb
Ensured entries in source path have a trailing /, for Unix.

Revision 1.17  1993/08/29  18:30:30  daveb
Expand "." in environment variables.
Capitalised messages.

Revision 1.16  1993/08/25  12:58:26  daveb
Changed pervasive_dir to be optional.  Raises NotSet if it's not set.

Revision 1.15  1993/08/25  11:21:52  daveb
Check for empty UNIX environment variables.
Change variable names to be less than 19 characters, or else csh complains.
Print message when setting variables from the environment.

Revision 1.14  1993/08/19  14:39:26  daveb
Added MLWORKS_ to the start of UNIX environment variables.

Revision 1.13  1993/08/18  12:58:22  daveb
Fix to work around bug in SML/NJ.  Also removed two debugging statements.

Revision 1.12  1993/08/12  16:51:49  daveb
Removed several functions that are now unused or moved to filename.

Revision 1.11  1993/06/17  14:33:58  richard
Tilde expansion now uses MLWorks.OS.Unix.getpwnam system call.

Revision 1.10  1993/05/05  17:16:46  jont
Added a trans_home_name function for translating filenames satarting with ~

Revision 1.9  1993/02/24  14:32:14  jont
Added get_pervasive_dir to get value of PERVASIVE_DIR environment variable

Revision 1.8  1992/09/02  14:22:01  richard
Moved the special names out of the compiler as a whole.

Revision 1.7  1992/08/21  14:23:10  richard
Corrected relative_name to accept paths not ending in `/'.

Revision 1.6  1992/08/20  15:02:19  davidt
Made changes to allow mo files to be copied.

Revision 1.5  1992/08/20  12:44:37  richard
Changed default pervasive library path to use pervasives
directory.

Revision 1.4  1992/08/17  14:02:31  davidt
Took out input_line function (there is one in MLWorks.IO now).

Revision 1.3  1992/08/10  11:33:10  davidt
String structure is now pervasive.

Revision 1.2  1992/08/03  11:53:05  jont
Added ignore_line function

Revision 1.1  1992/07/22  15:35:35  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../basis/os";
require "../basis/path";
require "../main/info";
require "../basics/module_id";
require "../utils/getenv";
require "io";

functor MLWorksIo(
  structure OS : OS
  structure Path : PATH
  structure Info: INFO
  structure ModuleId: MODULE_ID
  structure Getenv : GETENV

  sharing type Info.Location.T = ModuleId.Location

  val pervasive_library_name : string
  val builtin_library_name : string
  val default_source_path : string list
) : MLWORKS_IO =
  struct
    type ModuleId = ModuleId.ModuleId
    type Location = Info.Location.T

    val pervasive_library_name = " " ^ pervasive_library_name
    val builtin_library_name = " " ^ builtin_library_name

    (* The module_id's are converted with from_mo_string, because they
       contain leading spaces. *)
    val pervasive_library_id =
      ModuleId.from_mo_string
	(pervasive_library_name, Info.Location.FILE "<Initialisation>")

    val builtin_library_id =
      ModuleId.from_mo_string
	(builtin_library_name, Info.Location.FILE "<Initialisation>")
      
    exception NotSet of string

    fun remove_spaces ("",_) = ""
      | remove_spaces(arg as (str, n)) =
	if MLWorks.String.ordof arg = ord #" " then
	  remove_spaces(str, n+1)
	else if n = 0 then 
	  str
	else 
	  substring (* could raise Substring *)(str, n, size str - n)
	    
    local
      val source_path = ref ([] : string list)
    in
      fun set_source_path_without_expansion l =
	source_path := l

      fun set_source_path(l, location) =
	let
	  val expand_path = OS.FileSys.fullPath o Getenv.expand_home_dir
	  fun map_sub(acc, []) = rev acc
	    | map_sub(acc, x::xs) =
	      let
		val s = expand_path x
	      in
		map_sub(s::acc, xs)
	      end
	    handle
	    OS.SysErr _ =>
	      (Info.error (Info.make_default_options())
	       (Info.WARNING, location,
		"Bad path '" ^ x ^ "', ignoring");
	       map_sub(acc, xs))
	    | Getenv.BadHomeName s =>
	      (Info.error (Info.make_default_options())
	       (Info.WARNING, location,
		"Problem expanding source path - "
		^ "can't find home directory for " ^ s);
	       map_sub(acc, xs))
	  val expanded = map_sub([], l)
	in
	  case expanded of
	    [] => false
	  | _ => (set_source_path_without_expansion expanded; true)
	end

      fun set_source_path_from_string(s, location) =
	let
	  val old_source_path = !source_path
	in
	  set_source_path(Getenv.env_path_to_list s, location)
	  handle
          Getenv.BadHomeName s =>
            (Info.error (Info.make_default_options())
	     (Info.WARNING, location,
	      "Problem expanding source path - "
	      ^ "can't find home directory for " ^ s);
	     set_source_path_without_expansion old_source_path;
	     false)
	end

      fun set_source_path_from_env (location, silent) =
	(* Note, no handlers needed here, as set_source_path *)
	(* and set_source_path_from_string handle it all *)
	case Getenv.get_source_path() of
	  NONE =>
	    (set_source_path
	     (map
	      (fn s => (remove_spaces(s,0)))
	      default_source_path, location);
	     ())
	| SOME str =>
	    (if set_source_path_from_string(str, location) andalso (not silent) then
	       print("Setting source path to: " ^ str ^ "\n")
	     else
	       ())

      val set_source_path_from_string =
	fn arg => (set_source_path_from_string arg; ())
      val set_source_path = fn s => (set_source_path(s, Info.Location.UNKNOWN); ())
      fun get_source_path () = (!source_path)
    end

    local
      (* We need the type constraints since NJ 0.75 doesn't handle locals
	 properly *)

      val pervasive_dir =
	ref NONE : string option ref
      
      val object_path =
	ref (SOME(Path.concatPath("%S", "%C"))) :
	  string option ref

    in
      fun get_pervasive_dir () =
	case !pervasive_dir
	of SOME str => str
	|  NONE => raise NotSet "pervasive_dir"

      fun set_pervasive_dir (s, location) =
        pervasive_dir := SOME
	  (OS.FileSys.fullPath (Getenv.expand_home_dir s))
        handle
          Getenv.BadHomeName s =>
            Info.error (Info.make_default_options())
	      (Info.WARNING, location,
	       "Problem expanding pervasive directory - "
	       ^ "can't find home directory for " ^ s)
	     | OS.SysErr _ =>
		 Info.error (Info.make_default_options())
		 (Info.WARNING, location,
	       "Problem setting pervasive directory - "
	       ^ s ^ " is not a valid path")

      fun set_pervasive_dir_from_env location =
        case Getenv.get_pervasive_dir () of
	  SOME s =>
	    set_pervasive_dir (remove_spaces (s,0), location)
        | NONE => ()

      fun print_pervasive_dir () = 
	case !pervasive_dir of
	  SOME str => 
	    print("Pervasive directory set to: " ^ str ^ "\n")
	| NONE =>
	    print("Pervasive directory not set.\n")

      fun get_object_path () =
	case !object_path
	of SOME str => str
	|  NONE => raise NotSet "object_path"

      fun set_object_path(s, location) =
        (object_path := SOME
	 (Getenv.expand_home_dir s); true)
        handle
          Getenv.BadHomeName s =>
            (Info.error (Info.make_default_options())
	     (Info.WARNING, location,
	      "Problem expanding object path - "
	      ^ "can't find home directory for " ^ s);
	     false)

      fun set_object_path_from_env location =
        case Getenv.get_object_path() of
	  SOME s =>
	    if set_object_path(remove_spaces(s,0), location) then
	      print("Setting object path to: " ^ s ^ "\n")
	    else
	      ()
        |  NONE => ()

      val set_object_path = fn arg => (set_object_path arg; ())
    end

    val _ = (set_pervasive_dir_from_env (Info.Location.FILE "main/_io.sml");
	     print_pervasive_dir ())
  end
@


1.50.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.50  1997/05/27  09:01:29  johnh
 * [Bug #20033]
 * Pass 'silent' param to set_source_path_from_env.
 *
@


1.50.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.50  1997/05/27  09:01:29  johnh
 * [Bug #20033]
 * Pass 'silent' param to set_source_path_from_env.
 *
@


1.49
log
@[Bug #30090]
Translate output std_out to print
@
text
@d4 4
d276 1
a276 1
      fun set_source_path_from_env location =
d287 1
a287 1
	    (if set_source_path_from_string(str, location) then
@


1.48
log
@[Bug #20050]
Change name to MLWorksIO to avoid clash with basis.io
@
text
@d4 4
d284 1
a284 1
	       MLWorks.IO.output(MLWorks.IO.std_out, "Setting source path to: " ^ str ^ "\n")
d335 1
a335 1
	    MLWorks.IO.output (MLWorks.IO.std_out, "Pervasive directory set to: " ^ str ^ "\n")
d337 1
a337 1
	    MLWorks.IO.output (MLWorks.IO.std_out, "Pervasive directory not set.\n")
d359 1
a359 1
	      MLWorks.IO.output(MLWorks.IO.std_out, "Setting object path to: " ^ s ^ "\n")
@


1.47
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d177 1
a177 1
functor Io(
d189 1
a189 1
) : IO =
@


1.46
log
@[Bug #1940]
Modify set_pervasive_dir such that bad pervasive dirs merely warn.
Do similar modifications for setting source and object paths
@
text
@d4 5
d294 1
a294 1
	ref (MLWorks.Option.SOME(Path.concatPath("%S", "%C"))) :
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 5
 * Revision 1.46  1997/03/06  14:14:32  jont
 * [Bug #1940]
 * Modify set_pervasive_dir such that bad pervasive dirs merely warn.
 * Do similar modifications for setting source and object paths
 *
@


1.46.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.46.1.1  1997/05/12  10:36:08  hope
 * branched from 1.46
 *
@


1.46.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.46.1.1  1997/05/12  10:36:08  hope
 * branched from 1.46
 *
@


1.46.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.46.1.1  1997/05/12  10:36:08  hope
 * branched from 1.46
 *
@


1.46.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.46.1.1.1.1  1997/07/28  18:21:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.45
log
@moving String from toplevel
@
text
@d4 3
d215 1
a215 1
      fun set_source_path l =
d225 11
a235 2
	    handle OS.SysErr _ =>
	      (MLWorks.IO.output(MLWorks.IO.std_out, "Bad path '" ^ x ^ "', ignoring\n");
d239 3
a241 1
	  set_source_path_without_expansion expanded
d244 6
a249 3
      fun set_source_path_from_string (s, location) =
	set_source_path(Getenv.env_path_to_list s)
        handle
d251 7
a257 4
            Info.default_error'
	      (Info.FATAL, location,
	       "Problem expanding source path - "
	       ^ "can't find home directory for " ^ s)
d260 5
a264 3
	(case Getenv.get_source_path () of
	   NONE =>
	     set_source_path_without_expansion
d266 12
a277 13
	      (fn s => (OS.FileSys.fullPath o Getenv.expand_home_dir) (remove_spaces (s,0)))
	      default_source_path)
	 | SOME str =>
	     (MLWorks.IO.output(MLWorks.IO.std_out, "Setting source path to: " ^ str ^ "\n");
	      set_source_path_from_string (str, location)))
        handle
          Getenv.BadHomeName s =>
	    Info.default_error'
	      (Info.FATAL, location,
	       "Problem expanding source path - " ^
	       "can't find home directory for " ^ s)
          (* XXXEXCEPTION: should handle OS.SysErr due to OS.FileSys.fullPath*)

d303 2
a304 2
            Info.default_error'
	      (Info.FATAL, location,
d308 2
a309 2
		 Info.default_error'
		 (Info.FATAL, location,
d314 4
a317 4
        case Getenv.get_pervasive_dir ()
        of SOME s =>
	  set_pervasive_dir (remove_spaces (s,0), location)
        |  NONE => ()
d331 3
a333 3
      fun set_object_path (s, location) =
        object_path := SOME
	  (Getenv.expand_home_dir s)
d336 5
a340 4
            Info.default_error'
	      (Info.FATAL, location,
	       "Problem expanding object path - "
	       ^ "can't find home directory for " ^ s)
d343 6
a348 4
        case Getenv.get_object_path ()
        of SOME s =>
	  (MLWorks.IO.output (MLWorks.IO.std_out, "Setting object path to: " ^ s ^ "\n");
	   set_object_path (remove_spaces (s,0), location))
d351 1
a356 1

@


1.45.4.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/10/29  17:04:43  io
 * moving String from toplevel
 *
@


1.45.3.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/10/29  17:04:43  io
 * moving String from toplevel
 *
@


1.45.3.1.1.1
log
@branched from 1.45.3.1
@
text
@a3 3
 * Revision 1.45.3.1  1996/12/17  17:49:35  hope
 * branched from 1.45
 *
@


1.45.2.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/10/29  17:04:43  io
 * moving String from toplevel
 *
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/10/29  17:04:43  io
 * moving String from toplevel
 *
@


1.45.1.1.1.1
log
@branched from 1.45.1.1
@
text
@a3 3
 * Revision 1.45.1.1  1996/11/14  12:51:48  hope
 * branched from 1.45
 *
@


1.44
log
@Handle OS.SysErr in set_source_path
@
text
@d4 3
d197 1
a197 1
    fun remove_spaces(arg as ("", _)) = ""
d199 1
a199 1
	if String.ordof arg = String.ord " " then
d201 5
a205 3
	else
	  if n = 0 then str else String.substring(str, n, size str - n)

d241 1
a241 1
	   MLWorks.Option.NONE =>
d244 1
a244 1
	      (fn s => (OS.FileSys.fullPath o Getenv.expand_home_dir) (remove_spaces (s, 0)))
d246 1
a246 1
	 | MLWorks.Option.SOME str =>
d265 1
a265 1
	ref MLWorks.Option.NONE : string MLWorks.Option.option ref
d269 1
a269 1
	  string MLWorks.Option.option ref
d274 2
a275 2
	of MLWorks.Option.SOME str => str
	|  MLWorks.Option.NONE => raise NotSet "pervasive_dir"
d278 1
a278 1
        pervasive_dir := MLWorks.Option.SOME
d294 3
a296 3
        of MLWorks.Option.SOME s =>
	  set_pervasive_dir (remove_spaces(s, 0), location)
        |  MLWorks.Option.NONE => ()
d300 1
a300 1
	  MLWorks.Option.SOME str => 
d302 1
a302 1
	| MLWorks.Option.NONE =>
d307 2
a308 2
	of MLWorks.Option.SOME str => str
	|  MLWorks.Option.NONE => raise NotSet "object_path"
d311 1
a311 1
        object_path := MLWorks.Option.SOME
d322 1
a322 1
        of MLWorks.Option.SOME s =>
d324 2
a325 2
	   set_object_path (remove_spaces(s, 0), location))
        |  MLWorks.Option.NONE => ()
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/07/11  17:03:41  jont
 * Handle OS.SysErr in set_source_path
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/07/11  17:03:41  jont
 * Handle OS.SysErr in set_source_path
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/07/11  17:03:41  jont
 * Handle OS.SysErr in set_source_path
 *
@


1.43
log
@Replace OS.FileSys.realPath with OS.FileSys.fullPath since the latter
now does what the former used to do.
@
text
@d4 4
d208 16
a223 4
	set_source_path_without_expansion
	(map (OS.FileSys.fullPath o Getenv.expand_home_dir) l)
        (* XXXEXCEPTION: should handle OS.SysErr *)

d242 1
a242 1
	     (MLWorks.IO.output (MLWorks.IO.std_out, "Setting source path to: " ^ str ^ "\n");
d281 5
a285 1
          (* XXX: should handle OS.SysErr  *)
@


1.42
log
@Change to pull in Path directly rather than OS.Path since the latter
now conforms to the latest basis and it is too much effort to update
the code to OS.Path at this point.
@
text
@d4 5
d205 1
a205 1
	(map (OS.FileSys.realPath o Getenv.expand_home_dir) l)
d223 1
a223 1
	      (fn s => (OS.FileSys.realPath o Getenv.expand_home_dir) (remove_spaces (s, 0)))
d234 1
a234 1
          (* XXXEXCEPTION: should handle OS.SysErr due to OS.FileSys.realPath*)
d258 1
a258 1
	  (OS.FileSys.realPath (Getenv.expand_home_dir s))
@


1.41
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d147 1
d155 1
d242 1
a242 1
	ref (MLWorks.Option.SOME(OS.Path.concatPath("%S", "%C"))) :
@


1.40
log
@initbasis moves to basis
@
text
@d4 3
d179 1
a179 1
	if String.ordof arg = ord " " then
d213 1
a213 1
	     (output (std_out, "Setting source path to: " ^ str ^ "\n");
d263 1
a263 1
	    output (std_out, "Pervasive directory set to: " ^ str ^ "\n")
d265 1
a265 1
	    output (std_out, "Pervasive directory not set.\n")
d285 1
a285 1
	  (output (std_out, "Setting object path to: " ^ s ^ "\n");
@


1.39
log
@Update wrt Os -> OS name change.
@
text
@d4 3
d137 1
a137 1
require "../initbasis/os";
@


1.38
log
@Ensure set_source_path does realpath expansion
@
text
@d4 3
d141 1
a141 1
  structure Os : OS
d186 3
a188 1
	(map (Os.FileSys.realPath o Getenv.expand_home_dir) l)
d204 1
a204 1
	      (fn s => (Os.FileSys.realPath o Getenv.expand_home_dir) (remove_spaces (s, 0)))
d215 1
d228 1
a228 1
	ref (MLWorks.Option.SOME(Os.Path.concatPath("%S", "%C"))) :
d239 1
a239 1
	  (Os.FileSys.realPath (Getenv.expand_home_dir s))
d246 1
@


1.37
log
@Update to use the OS structure from the latest revised basis.
@
text
@d4 3
d178 3
d182 2
a183 1
	source_path := l
d186 1
a186 4
	set_source_path
	  (map
	     (Os.FileSys.realPath o Getenv.expand_home_dir)
	     (Getenv.env_path_to_list s))
d195 3
a197 3
	(case Getenv.get_source_path ()
	 of MLWorks.Option.NONE =>
	   set_source_path
d199 5
a203 6
	 	(fn s => Os.FileSys.realPath
			   (Getenv.expand_home_dir (remove_spaces (s, 0))))
		default_source_path)
	 |  MLWorks.Option.SOME str =>
	   (output (std_out, "Setting source path to: " ^ str ^ "\n");
	    set_source_path_from_string (str, location)))
@


1.36
log
@Print message when setting object path from environment
@
text
@d4 3
d128 1
a128 3
require "../utils/lists";
require "../initbasis/filesys";
require "../initbasis/path";
d135 1
a135 3
  structure Lists : LISTS
  structure FileSys : FILE_SYS
  structure Path : PATH
d181 1
a181 1
	     (FileSys.realPath o Getenv.expand_home_dir)
d195 1
a195 1
	 	(fn s => FileSys.realPath
d219 1
a219 1
	ref (MLWorks.Option.SOME(Path.concatPath("%S", "%C"))) :
d230 1
a230 1
	  (FileSys.realPath (Getenv.expand_home_dir s))
@


1.35
log
@Fixed use of Info.default_options.
@
text
@d4 3
d270 2
a271 1
	  set_object_path (remove_spaces(s, 0), location)
@


1.34
log
@Added space to beginning of pervasive module names.
Changed ModuleId.from_string to ModuleId.from_mo_string.
@
text
@d4 4
d183 1
a183 2
            Info.error'
	      Info.default_options
d201 1
a201 2
	    Info.error
	      Info.default_options
d231 1
a231 2
            Info.error'
	      Info.default_options
d259 1
a259 2
            Info.error'
	      Info.default_options
@


1.33
log
@Remove FileSys.realPath call from set_object_path (delayed application required)
@
text
@d4 3
d144 2
a145 2
    val pervasive_library_name = pervasive_library_name
    val builtin_library_name = builtin_library_name
d147 2
d150 1
a150 1
      ModuleId.from_string
d154 1
a154 1
      ModuleId.from_string
@


1.32
log
@The path setting functions now handle the BadHomeName exception
themselves, and take a location argument.
Expansion of home dirs has moved from filesys to getenv.
filesys and path have moved from utils to initbasis.
@
text
@d4 6
d250 1
a250 1
	  (FileSys.realPath (Getenv.expand_home_dir s))
@


1.31
log
@Modifications to add object paths
@
text
@d4 3
d110 2
a111 1
require "../utils/filesys";
a114 1
require "../utils/path";
d133 1
d139 3
a141 1
      ModuleId.from_string (pervasive_library_name, Info.Location.UNKNOWN)
d143 2
a144 1
      ModuleId.from_string (builtin_library_name, Info.Location.UNKNOWN)
d161 5
a165 2
      fun set_source_path_from_string s =
	set_source_path (map FileSys.expand_path (Getenv.env_path_to_list s))
d167 1
a167 1
          FileSys.BadHomeName s =>
d170 1
a170 1
	      (Info.FATAL, Info.Location.UNKNOWN,
d174 4
a177 4
      fun set_source_path_from_env () =
	case Getenv.get_source_path ()
	of MLWorks.Option.NONE =>
	  (set_source_path
d179 2
a180 1
		(fn s => FileSys.expand_path (remove_spaces (s, 0)))
d182 10
a191 10
           handle
             FileSys.BadHomeName s =>
	       Info.error
	       Info.default_options
	       (Info.FATAL, Info.Location.UNKNOWN,
	        "Problem expanding source path - " ^
	        "can't find home directory for " ^ s))
	|  MLWorks.Option.SOME str =>
	  (output (std_out, "Setting source path to: " ^ str ^ "\n");
	   set_source_path_from_string str)
d197 3
d202 1
d204 3
a206 2
	ref(MLWorks.Option.SOME(Path.concatPath("%S", "%C"))) : string MLWorks.Option.option ref
    (* We need the type constraints since NJ doesn't handle locals properly *)
d213 10
a222 2
      fun set_pervasive_dir s =
        pervasive_dir := MLWorks.Option.SOME s
d224 5
a228 12
      fun set_pervasive_dir_from_env () =
        (case Getenv.get_pervasive_dir ()
         of MLWorks.Option.SOME s =>
	   (set_pervasive_dir (FileSys.expand_path (remove_spaces(s, 0)))
	    handle
              FileSys.BadHomeName s =>
                Info.error'
                  Info.default_options
                  (Info.FATAL, Info.Location.UNKNOWN,
                     "Problem expanding source path - " ^
                     "can't find home directory for " ^ s))
         |  MLWorks.Option.NONE => ())
d242 10
a251 2
      fun set_object_path s =
        object_path := MLWorks.Option.SOME s
d253 5
a257 12
      fun set_object_path_from_env () =
        (case Getenv.get_object_path ()
         of MLWorks.Option.SOME s =>
	   (set_object_path (FileSys.expand_path (remove_spaces(s, 0)))
	    handle
              FileSys.BadHomeName s =>
                Info.error'
                  Info.default_options
                  (Info.FATAL, Info.Location.UNKNOWN,
                     "Problem expanding source path - " ^
                     "can't find home directory for " ^ s))
         |  MLWorks.Option.NONE => ())
d261 1
a261 1
    val _ = (set_pervasive_dir_from_env ();
@


1.30
log
@Change FILESYS to FILE_SYS
@
text
@d4 3
d111 1
d117 1
d186 5
a190 6
      (* Bloody New Jersey treats the following valdecs as topdecs, even
         though they are local.  So we have to use a monomorphic option
         type in this case. *)
      datatype local_opt = ABSENT | PRESENT of string

      val pervasive_dir = ref ABSENT
d194 2
a195 2
	of PRESENT str => str
	|  ABSENT => raise NotSet "pervasive_dir"
d198 1
a198 1
        pervasive_dir := PRESENT s
d215 1
a215 1
	  PRESENT str => 
d217 1
a217 1
	| ABSENT =>
d219 22
@


1.29
log
@Moved functionality for parsing environment paths into getenv.sml.
Replaced Option structure with references to MLWorks.Option.
@
text
@d4 4
d112 1
a112 1
  structure FileSys : FILESYS
@


1.28
log
@Ensure preceding spaces are removed from pervasive_dir environment values
@
text
@d4 3
d21 2
a22 1
set_source_path takes a directory list argument.  Other set_source_path\nfunctions call FileName.parse_directory, thus ensuring expansion.
d100 1
a100 1
require "../utils/filename";
d108 1
a108 1
  structure FileName : FILENAME
a119 2
    structure Option = Getenv.Option 

a120 1
    type Directory = FileName.Directory
d140 1
a140 27
      val source_path = ref ([] : Directory list)

      fun str_to_path str =
	let
	  fun parse_substring (from, to) =
	    FileName.parse_directory 
	      (String.substring (str, from, to))
            handle
              FileName.BadHomeName s =>
	        Info.error'
	        Info.default_options
	        (Info.FATAL, Info.Location.UNKNOWN,
	         "Problem expanding source path - " ^
	         "can't find home directory for " ^ s)

	  fun str_to_path' (0, separator_index, result) =
	    parse_substring (0, separator_index) :: result
	    | str_to_path' (n, separator_index, result) =
	    if String.substring (str, n, 1) = Getenv.separator then
	      str_to_path' (n - 1, n,
		 	    parse_substring
			      (n + 1, separator_index - n - 1) :: result)
	    else
	      str_to_path' (n - 1, separator_index, result)
	in
	  str_to_path' (size str - 1, size str, [])
	end
d146 8
a153 1
	set_source_path (str_to_path s)
d156 3
a158 3
	case Getenv.get_source_path () of
	  Option.ABSENT =>
	    (set_source_path
d160 4
a163 4
	      (fn s => FileName.parse_directory(remove_spaces(s, 0)))
	      default_source_path)
	     handle
             FileName.BadHomeName s =>
d169 3
a171 3
	| Option.PRESENT str =>
	    (output (std_out, "Setting source path to: " ^ str ^ "\n");
	     set_source_path_from_string str)
d173 1
a173 1
      fun get_source_path () = (!source_path) : Directory list
d180 1
a180 1
      datatype local_opt = ABSENT | PRESENT of FileName.Directory
d193 5
a197 5
        (case Getenv.get_pervasive_dir () of
	   Option.PRESENT s =>
	     (set_pervasive_dir (FileName.parse_directory(remove_spaces(s, 0)))
	      handle
              FileName.BadHomeName s =>
d199 5
a203 5
		Info.default_options
		(Info.FATAL, Info.Location.UNKNOWN,
		 "Problem expanding source path - " ^
		 "can't find home directory for " ^ s))
         | Option.ABSENT => ())
d208 1
a208 3
	    output (std_out,
		    "Pervasive directory set to: " ^
		    FileName.directory_name str ^ "\n")
d210 1
a210 2
	    output (std_out,
		    "Pervasive directory not set.\n")
@


1.27
log
@Parameterise environment value separator on getenv
@
text
@d4 3
d131 7
d174 7
a180 5
	case Getenv.get_source_path ()
	of Option.ABSENT =>
	  (set_source_path
	     (map FileName.parse_directory default_source_path)
           handle
d187 3
a189 3
	|  Option.PRESENT str =>
	  (output (std_out, "Setting source path to: " ^ str ^ "\n");
	   set_source_path_from_string str)
d211 4
a214 4
        (case Getenv.get_pervasive_dir ()
         of Option.PRESENT s =>
	   (set_pervasive_dir (FileName.parse_directory s)
	    handle
d217 5
a221 5
                  Info.default_options
                  (Info.FATAL, Info.Location.UNKNOWN,
                     "Problem expanding source path - " ^
                     "can't find home directory for " ^ s))
         |  Option.ABSENT => ())
@


1.26
log
@Move OS specific stuff into a system link directory
@
text
@d4 3
d144 4
a147 4
	  fun str_to_path' (0, seperator_index, result) =
	    parse_substring (0, seperator_index) :: result
	  |   str_to_path' (n, seperator_index, result) =
	    if String.substring (str, n, 1) = ":" then
d150 1
a150 1
			      (n + 1, seperator_index - n - 1) :: result)
d152 1
a152 1
	      str_to_path' (n - 1, seperator_index, result)
@


1.25
log
@Fixed types of set_pervasive_dir.
@
text
@d4 3
d93 1
a93 1
require "../basics/getenv";
@


1.24
log
@Fixed NJ type bug
@
text
@d4 3
d190 1
a190 8
        pervasive_dir := PRESENT(FileName.parse_directory s)
	handle
	  FileName.BadHomeName s =>
	    Info.error'
	      Info.default_options
	      (Info.FATAL, Info.Location.UNKNOWN,
	       "Problem expanding pervasive directory - " ^
		 "can't find home directory for " ^ s)
d195 8
a202 1
	   set_pervasive_dir s
@


1.23
log
@source_path is no longer a list option ref, just a list ref.
set_source_path takes a directory list argument.  Other set_source_path\nfunctions call FileName.parse_directory, thus ensuring expansion.
@
text
@d4 4
d120 1
a120 1
      val source_path = ref []
d170 1
a170 2
      fun get_source_path () =
	!source_path
@


1.22
log
@Added  pervasive_library_id and builtin_library_id, made ModuleId an
eqtype, moved getenv functionality to a separate module, and moved\ntrans_home_name functionality to filename.
@
text
@d4 4
d107 1
a107 1
      
d116 1
a116 4
      (* Bloody New Jersey treats the following valdecs as topdecs, even
         though they are local.  So we have to use a monomorphic option
         type in this case. *)
      datatype local_opt = ABSENT | PRESENT of FileName.Directory list
a117 2
      val source_path = ref ABSENT

d120 11
d132 1
a132 1
	    String.substring (str, 0, seperator_index) :: result
d136 2
a137 2
		 	    String.substring
		   	      (str, n + 1, seperator_index - n - 1) :: result)
d145 1
a145 9
	source_path := PRESENT (map FileName.parse_directory l)
	handle
	  FileName.BadHomeName s =>
	    Info.error'
	      Info.default_options
	      (Info.FATAL, Info.Location.UNKNOWN,
	       "Problem expanding source path - " ^
		 "can't find home directory for " ^ s)

d153 9
a161 1
	  set_source_path default_source_path
d167 1
a167 3
	case !source_path
	of PRESENT str => str
	|  ABSENT => raise NotSet "source_path"
d171 3
a173 1
      (* Note string, not string list. *)
@


1.21
log
@Ensured that pervasive dir always undergoes ~ translation and ends in /.
@
text
@d4 3
a74 1
require "../utils/option";
d76 1
d79 1
a82 1
  structure Option : OPTION
d84 1
d87 3
d96 2
d99 1
a99 1
    type Directory = string
a100 1
    val null_location = ""
d104 5
a108 56
    fun get_option_value option_name =
      let
	val option_length = size option_name
	fun get_value [] = Option.ABSENT
	  | get_value(arg :: rest) =
	  if size arg < option_length then
	    get_value rest
	  else if String.substring(arg, 0, option_length) = option_name then
	    if size arg - option_length = 0 then
	      Option.ABSENT
	    else
	      Option.PRESENT(String.substring(arg, option_length,
					      size arg - option_length))
          else
            get_value rest
      in
	get_value
      end

    exception BadHomeName of string

    fun upto_slash(n, []) = n
      | upto_slash(n, "/" :: _) = n
      | upto_slash(n, _ :: rest) = upto_slash(n+1, rest)
	
    fun get_user_name() =
      get_option_value "USER=" (MLWorks.OS.Unix.environment())

    fun trans_home_name string =
      let
        val len = size string
      in
	if string = "." then
	  MLWorks.OS.Unix.getwd ()
        else if len = 0 orelse String.ordof(string, 0) <> ord"~" then
          string
        else
          let
            val start = upto_slash(0, explode string)
            val name =
              if start = 1 then
                case get_user_name() of
                  Option.PRESENT s => s
                | _ => raise BadHomeName string
              else
                String.substring(string, 1, start-1)
            val rest = String.substring(string, start, len-start)
            val MLWorks.OS.Unix.PASSWD {dir, ...} =
              MLWorks.OS.Unix.getpwnam name
              handle MLWorks.OS.Unix.Unix _ =>
                raise BadHomeName string
          in
            dir ^ rest
          end
      end

a110 3
    fun add_slash s =
      if String.ordof (s, size s - 1) = ord "/" then s else s ^ "/"

d115 1
a115 1
      datatype local_opt = ABSENT | PRESENT of string list
d135 1
a135 1
	source_path := PRESENT (map (add_slash o trans_home_name) l)
d137 1
a137 1
	  BadHomeName s =>
d149 1
a149 3
	case get_option_value
	       "MLWORKS_SRC_PATH="
	       (MLWorks.OS.Unix.environment())
d164 1
a164 1
      datatype local_opt = ABSENT | PRESENT of string
d174 8
a181 1
        pervasive_dir := PRESENT(add_slash (trans_home_name s))
d184 1
a184 3
        (case get_option_value
	        "MLWORKS_PERVASIVE="
	        (MLWorks.OS.Unix.environment())
d193 2
a194 1
		    "Pervasive directory set to: " ^ str ^ "\n")
d203 1
@


1.20
log
@Change when "Setting pervasive dir..." message is printed, to make
MLWorks startup less intimidating.
@
text
@d4 4
d154 3
a178 3

      fun add_slash s =
	if String.ordof (s, size s - 1) = ord "/" then s else s ^ "/"
d221 3
d229 1
a229 1
	   pervasive_dir := PRESENT s
a230 3

      fun set_pervasive_dir s =
        pervasive_dir := PRESENT(trans_home_name s)
@


1.19
log
@Made set_pervasive_dir call trans_home_name on its argument
@
text
@d4 3
d222 1
a222 2
	  (output (std_out, "Setting pervasive directory to: " ^ s ^ "\n");
           pervasive_dir := PRESENT s)
d227 9
d238 2
a239 1
    val _ = set_pervasive_dir_from_env ()
@


1.18
log
@Ensured entries in source path have a trailing /, for Unix.
@
text
@d4 3
d224 1
a224 1
        pervasive_dir := PRESENT s
@


1.17
log
@Expand "." in environment variables.
Capitalised messages.
@
text
@d4 4
d116 1
a116 1
        val size = size string
d120 1
a120 1
        else if size = 0 orelse String.ordof(string, 0) <> ord"~" then
d132 1
a132 1
            val rest = String.substring(string, start, size-start)
d166 3
d171 1
a171 1
	source_path := PRESENT (map trans_home_name l)
@


1.17.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.17  1993/08/29  18:30:30  daveb
Expand "." in environment variables.
Capitalised messages.

@


1.17.1.2
log
@Merged bug fix into bug fixing branch.
@
text
@a3 6
Revision 1.17.1.1  1993/08/29  18:30:30  jont
Fork for bug fixing

Revision 1.18  1993/10/27  14:03:56  daveb
Ensured entries in source path have a trailing /, for Unix.

d116 1
a116 1
        val len = size string
d120 1
a120 1
        else if len = 0 orelse String.ordof(string, 0) <> ord"~" then
d132 1
a132 1
            val rest = String.substring(string, start, len-start)
a165 3

      fun add_slash s =
	if String.ordof (s, size s - 1) = ord "/" then s else s ^ "/"
d168 1
a168 1
	source_path := PRESENT (map (add_slash o trans_home_name) l)
@


1.16
log
@Changed pervasive_dir to be optional.  Raises NotSet if it's not set.
@
text
@d4 3
d114 3
a116 1
        if size = 0 orelse String.ordof(string, 0) <> ord"~" then
d184 1
a184 1
	  (output (std_out, "setting source path to: " ^ str ^ "\n");
d209 1
a209 1
	  (output (std_out, "setting pervasive directory to: " ^ s ^ "\n");
@


1.15
log
@Check for empty UNIX environment variables.
Change variable names to be less than 19 characters, or else csh complains.
Print message when setting variables from the environment.
@
text
@d4 5
a68 1
  val default_pervasive_dir : string
d136 3
a138 3
      (* Bloody New Jersey treats the following valdec as a topdec, even
	 though it's in a local.  So we have to use a monomorphic option
	 type in this case. *)
d188 3
a190 1
    val pervasive_dir_arg = "MLWORKS_PERVASIVE="
d192 6
a197 3
    val pervasive_dir = ref ""

    fun get_pervasive_dir () = !pervasive_dir
d199 1
a199 2
    fun set_pervasive_dir_from_env () =
      pervasive_dir :=
d201 1
a201 1
	        pervasive_dir_arg
d204 3
a206 2
	   (output (std_out, "setting pervasive directory to: " ^ s ^ "\n"); s)
         |  Option.ABSENT => !pervasive_dir)
d208 3
a210 2
    fun set_pervasive_dir s =
      pervasive_dir := s
@


1.14
log
@Added MLWORKS_ to the start of UNIX environment variables.
@
text
@d4 3
d80 5
a84 2
	    if size arg < option_length then
	      get_value rest
d86 2
a87 3
	      if String.substring(arg, 0, option_length) = option_name then
		Option.PRESENT(String.substring(arg, option_length,
						size arg - option_length))
d170 1
a170 1
	       "MLWORKS_SOURCE_PATH="
d173 1
a173 1
	  (set_source_path default_source_path)
d175 2
a176 1
	  (set_source_path_from_string str)
d184 1
a184 1
    val pervasive_dir_arg = "MLWORKS_PERVASIVE_DIR="
d195 2
a196 1
         of Option.PRESENT s => s
@


1.13
log
@Fix to work around bug in SML/NJ.  Also removed two debugging statements.
@
text
@d4 3
d165 1
a165 1
	       "ML_SOURCE_PATH="
d175 1
a175 1
	|  ABSENT => raise NotSet "ML_SOURCE_PATH"
d178 1
a178 1
    val pervasive_dir_arg = "PERVASIVE_DIR="
@


1.12
log
@Removed several functions that are now unused or moved to filename.
@
text
@d4 3
a61 1
    structure Option = Option
d124 6
a129 1
      val source_path = ref Option.ABSENT
d147 1
a147 1
	source_path := Option.PRESENT (map trans_home_name l)
d165 1
a165 2
	  (output(std_out, "failed to read ML_SOURCE_PATH\n");
	   set_source_path default_source_path)
d167 1
a167 2
	  (output(std_out, "read ML_SOURCE_PATH=" ^ str ^ "\n");
	   set_source_path_from_string str)
d171 2
a172 2
	of Option.PRESENT str => str
	|  Option.ABSENT => raise NotSet "ML_SOURCE_PATH"
@


1.11
log
@Tilde expansion now uses MLWorks.OS.Unix.getpwnam system call.
@
text
@d4 3
d43 2
d50 8
a57 4
  val pervasive_library_name		: string
  val builtin_library_name		: string
  val pervasive_names			: string list
  val default_pervasive_library_dir	: string) : IO =
d60 4
a65 2
    val pervasive_names = pervasive_names
    val pervasive_library_dir = ref default_pervasive_library_dir
d84 1
a84 35
    fun root_name filename =
      let
	val len = size filename
      in
	if len >= 4 then
	  (case String.substring(filename, len-4, 4) of
	     ".sml" => String.substring(filename, 0, len-4)
	   | _ => filename)
	else
	  filename
      end

    fun compilation_name filename =
      let
	val root = explode(root_name filename)
	fun remove_slash(result, []) = result
	  | remove_slash(result, "/" :: rest) = remove_slash(rest, rest)
	  | remove_slash(result, x :: rest) = remove_slash(result, rest)
      in
	implode(remove_slash(root, root))
      end

    fun compilation_path filename =
      let
	val root = root_name filename
	val final = compilation_name filename
      in
	String.substring(root, 0, size root - size final)
      end

    fun sml_name filename = root_name filename ^ ".sml"

    fun mo_name filename = root_name filename ^ ".mo"

    exception bad_home_name of string
d90 2
a91 1
    fun get_user_name() = get_option_value "USER=" (MLWorks.OS.Unix.environment())
d106 1
a106 1
                | _ => raise bad_home_name string
d113 1
a113 1
                raise bad_home_name string
d119 1
a119 41
    fun relative_name ("", name) = name
      | relative_name (path, name) =
        case String.substring (name, 0, 1)
          of "/" => name
           | _ => 
               let
                 fun join ("", name) = name
                   | join (path, name) =
                     if size name < 3 then
                       path ^ name
                     else
                       case String.substring (name, 0, 3)
                         of "../" =>
                           let
                             val prepath =
                               compilation_path (String.substring(path, 0, size path - 1))
                           in
                             join (prepath, String.substring(name, 3, size name - 3))
                           end
                          | _ => path ^ name
               in
                 join
                 (if String.substring (path, size path - 1, 1) = "/" then
                    path
                  else
                    path ^ "/",
                  name)
               end

    fun ignore_spaces [] = []
      | ignore_spaces(" " :: rest) = ignore_spaces rest
      | ignore_spaces x = x

    fun strip ("\""::x) = x     (* Damn emacs messes up \" *)
      | strip (_::x) = strip x
      | strip [] = []

    fun strip_to_quote [] = false
      | strip_to_quote("\"" :: _) = true
      | strip_to_quote(" " :: _) = false
      | strip_to_quote(_ :: rest) = strip_to_quote rest
d121 2
a122 2
    fun extract_path line =   (* get part in quotes *)
      implode (rev (strip (rev (strip (explode line)))))
d124 45
a168 2
    fun ignore_line stream =
      (MLWorks.IO.input_line stream; ())
d172 16
a187 1
    val get_pervasive_dir = get_option_value pervasive_dir_arg
@


1.10
log
@Added a trans_home_name function for translating filenames satarting with ~
@
text
@d4 3
d117 1
a117 1
	val size = size string
d119 20
a138 18
	if size = 0 orelse String.ordof(string, 0) <> ord"~" then
	  string
	else
	  let
	    val trans_table = MLWorks.OS.Unix.password_file()
	    val start = upto_slash(0, explode string)
	    val name =
	      if start = 1 then
		case get_user_name() of
		  Option.PRESENT s => s
		| _ => raise bad_home_name string
	      else
		String.substring(string, 1, start-1)
	  val rest = String.substring(string, start, size-start)
	  in
	    (Lists.assoc(name, trans_table) ^ rest)
	    handle Lists.Assoc => raise bad_home_name string
	  end
@


1.9
log
@Added get_pervasive_dir to get value of PERVASIVE_DIR environment variable
@
text
@d4 3
d36 1
d41 1
d53 17
d104 32
a184 1
    val pervasive_dir_arg_len = size pervasive_dir_arg
d186 1
a186 12
    fun get_pervasive_dir [] = Option.ABSENT
      | get_pervasive_dir(arg :: rest) =
        if size arg < pervasive_dir_arg_len then
          get_pervasive_dir rest
        else
          if String.substring(arg, 0, pervasive_dir_arg_len) =
            pervasive_dir_arg then
            Option.PRESENT(String.substring(arg, pervasive_dir_arg_len,
                                            size arg - pervasive_dir_arg_len))
          else
            get_pervasive_dir rest

@


1.8
log
@Moved the special names out of the compiler as a whole.
@
text
@d4 3
d32 1
d35 6
a40 4
functor Io(val pervasive_library_name		: string
           val builtin_library_name		: string
           val pervasive_names			: string list
           val default_pervasive_library_dir	: string) : IO =
d42 1
d129 15
@


1.7
log
@Corrected relative_name to accept paths not ending in `/'.
@
text
@d4 3
d31 4
a34 1
functor Io() : IO =
d36 5
d73 1
a73 3
    fun mo_name filename =
      if size filename = 0 then "test.mo"
      else root_name filename ^ ".mo"
a122 2
    val pervasive_library_dir =
      ref"/usr/users/sml/src/pervasive/"
@


1.6
log
@Made changes to allow mo files to be copied.
@
text
@d4 3
d66 28
a93 21
    fun relative_name(path, name) =
      case String.substring(name, 0, 1) of
	"/" => name
      | _ =>
	  let
	    fun join path name =
	      if size name < 3 orelse path = "" then
		path ^ name
	      else
		case String.substring(name, 0, 3) of
		  "../" =>
		    let
		      val prepath =
			compilation_path(String.substring(path, 0, size path - 1))
		    in
		      join prepath (String.substring(name, 3, size name - 3))
		    end
		| _ => path ^ name
	  in
	    join path name
	  end
@


1.5
log
@Changed default pervasive library path to use pervasives
directory.
@
text
@d4 4
a29 4
	val final_name =
	  if len >= 4 then
	    String.substring(filename, len-4, 4)
	  else ""
d31 6
a36 3
	case final_name of
	  ".sml" => String.substring(filename, 0, len-4)
	| _ => filename
d41 1
a41 2
	val root = root_name filename
	val exp_root = explode root
d46 1
a46 1
	implode(remove_slash(exp_root, exp_root))
d60 2
a61 4
      if size filename = 0 then
	"test.mo"
      else
	root_name filename ^ ".mo"
a65 1
      (* Handle case of require via absolute pathname *)
d69 2
a70 1
	      if size name < 3 orelse path = "" then path ^ name
d104 2
a105 2
    val pervasive_library_path =
      ref"/usr/users/sml/src/pervasive/__pervasive_library"
@


1.4
log
@Took out input_line function (there is one in MLWorks.IO now).
@
text
@d4 3
d105 1
a105 1
      ref"/usr/users/sml/src/rts/__pervasive_library"
@


1.3
log
@String structure is now pervasive.
@
text
@d4 3
a97 19
    fun get_terminated_line file =
      let
	fun extend_line line =
	  if end_of_stream file then
	    implode(rev line)
	  else
	    let
	      val char = input(file, 1)
	    in
	      if char = "\n" then implode(rev("\n" :: line))
	      else
		extend_line(char :: line)
	    end
      in
	extend_line []
      end
    
    val input_line = get_terminated_line

d99 1
a99 5
      if end_of_stream stream then ()
      else
	case input(stream, 1) of
	  "\n" => ()
	| _ => ignore_line stream
@


1.2
log
@Added ignore_line function
@
text
@d4 3
a12 1
require "../utils/string";
d15 1
a15 3
functor Io(
  structure String : STRING
) : IO =
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d113 7
@
