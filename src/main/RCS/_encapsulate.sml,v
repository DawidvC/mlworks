head	1.186;
access;
symbols
	MLW_daveb_inline_1_4_99:1.186.1
	MLWorks_21c0_1999_03_25:1.186
	MLWorks_20c1_1998_08_20:1.181
	MLWorks_20c0_1998_08_04:1.181
	MLWorks_20b2c2_1998_06_19:1.181
	MLWorks_20b2_Windows_1998_06_12:1.181
	MLWorks_20b1c1_1998_05_07:1.180
	MLWorks_20b0_1998_04_07:1.177
	MLWorks_20b0_1998_03_20:1.177
	MLWorks_20m2_1998_02_16:1.175
	MLWorks_20m1_1997_10_23:1.168
	MLWorks_11r1:1.165.5.1.1.1.1
	MLWorks_workspace_97:1.168.2
	MLWorks_dt_wizard:1.168.1
	MLWorks_11c0_1997_09_09:1.165.5.1.1.1
	MLWorks_10r3:1.165.5.1.3
	MLWorks_10r2_551:1.165.5.1.2
	MLWorks_11:1.165.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.165.5.1
	MLWorks_20m0_1997_06_20:1.168
	MLWorks_1_0_r2c2_1997_06_14:1.165.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.165.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.165.5
	MLWorks_BugFix_1997_04_24:1.165
	MLWorks_1_0_r2_Win32_1997_04_11:1.165
	MLWorks_1_0_r2_Unix_1997_04_04:1.165
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.165.3.1.1
	MLWorks_gui_1996_12_18:1.165.4
	MLWorks_1_0_Win32_1996_12_17:1.165.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.165.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.165.1.1
	MLWorks_1_0_Irix_1996_11_28:1.165.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.165.2
	MLWorks_1_0_Unix_1996_11_14:1.165.1
	MLWorks_Open_Beta2_1996_10_11:1.161.1
	MLWorks_License_dev:1.160.1
	MLWorks_1_open_beta_1996_09_13:1.159.1
	MLWorks_Open_Beta_1996_08_22:1.159
	MLWorks_Beta_1996_07_02:1.157
	MLWorks_Beta_1996_06_07:1.157
	MLWorks_Beta_1996_06_06:1.157
	MLWorks_Beta_1996_06_05:1.157
	MLWorks_Beta_1996_06_03:1.157
	MLWorks_Beta_1996_05_31:1.157
	MLWorks_Beta_1996_05_30:1.156
	ML_beta_release_12/08/94:1.128
	ML_beta_release_03/08/94:1.128
	ML_revised_beta_release_25/05/94:1.123
	ML_final_beta_release_02/03/94:1.117
	mlworks-28-01-1994:1.114
	Release:1.107
	mlworks-beta-01-09-1993:1.107
	MLWorks-1-0-4-29/01/1993:1.87
	MLWorks-1-0-3-21/12/1992:1.84
	MLWorks-1-0-2-15/12/1992:1.83
	MLWorks-1-0-1-04/12/1992:1.83
	checkpoint_17_08_92:1.56;
locks; strict;
comment	@ * @;


1.186
date	99.02.03.16.31.40;	author mitchell;	state Exp;
branches
	1.186.1.1;
next	1.185;

1.185
date	99.02.02.16.00.55;	author mitchell;	state Exp;
branches;
next	1.184;

1.184
date	98.10.23.15.05.49;	author jont;	state Exp;
branches;
next	1.183;

1.183
date	98.10.23.10.59.13;	author jont;	state Exp;
branches;
next	1.182;

1.182
date	98.09.25.16.42.06;	author jont;	state Exp;
branches;
next	1.181;

1.181
date	98.05.26.13.56.24;	author mitchell;	state Exp;
branches;
next	1.180;

1.180
date	98.04.22.11.38.00;	author jont;	state Exp;
branches;
next	1.179;

1.179
date	98.04.16.21.44.35;	author jont;	state Exp;
branches;
next	1.178;

1.178
date	98.04.16.11.00.51;	author jont;	state Exp;
branches;
next	1.177;

1.177
date	98.02.19.17.13.42;	author mitchell;	state Exp;
branches;
next	1.176;

1.176
date	98.02.19.15.01.44;	author jont;	state Exp;
branches;
next	1.175;

1.175
date	98.02.06.16.05.17;	author jont;	state Exp;
branches;
next	1.174;

1.174
date	98.02.06.13.35.44;	author johnh;	state Exp;
branches;
next	1.173;

1.173
date	98.02.05.12.07.48;	author jont;	state Exp;
branches;
next	1.172;

1.172
date	98.01.28.12.23.44;	author jont;	state Exp;
branches;
next	1.171;

1.171
date	97.11.25.19.48.08;	author jont;	state Exp;
branches;
next	1.170;

1.170
date	97.11.13.11.19.00;	author jont;	state Exp;
branches;
next	1.169;

1.169
date	97.10.21.12.35.16;	author jont;	state Exp;
branches;
next	1.168;

1.168
date	97.06.03.17.30.50;	author jont;	state Exp;
branches
	1.168.1.1
	1.168.2.1;
next	1.167;

1.167
date	97.05.30.10.41.53;	author jont;	state Exp;
branches;
next	1.166;

1.166
date	97.05.09.14.40.30;	author jont;	state Exp;
branches;
next	1.165;

1.165
date	96.11.06.11.28.49;	author matthew;	state Exp;
branches
	1.165.1.1
	1.165.2.1
	1.165.3.1
	1.165.4.1
	1.165.5.1;
next	1.164;

1.164
date	96.11.04.16.28.03;	author jont;	state Exp;
branches;
next	1.163;

1.163
date	96.10.29.15.23.19;	author io;	state Exp;
branches;
next	1.162;

1.162
date	96.10.25.09.22.26;	author andreww;	state Exp;
branches;
next	1.161;

1.161
date	96.10.04.15.48.57;	author andreww;	state Exp;
branches
	1.161.1.1;
next	1.160;

1.160
date	96.09.18.15.25.07;	author io;	state Exp;
branches
	1.160.1.1;
next	1.159;

1.159
date	96.08.01.12.27.22;	author jont;	state Exp;
branches
	1.159.1.1;
next	1.158;

1.158
date	96.07.12.13.44.33;	author jont;	state Exp;
branches;
next	1.157;

1.157
date	96.05.30.12.41.56;	author daveb;	state Exp;
branches;
next	1.156;

1.156
date	96.05.16.16.30.50;	author matthew;	state Exp;
branches;
next	1.155;

1.155
date	96.05.07.11.17.28;	author jont;	state Exp;
branches;
next	1.154;

1.154
date	96.04.30.17.12.53;	author jont;	state Exp;
branches;
next	1.153;

1.153
date	96.04.29.14.59.39;	author matthew;	state Exp;
branches;
next	1.152;

1.152
date	96.04.25.14.48.53;	author stephenb;	state Exp;
branches;
next	1.151;

1.151
date	96.03.20.12.52.42;	author matthew;	state Exp;
branches;
next	1.150;

1.150
date	96.03.01.14.24.16;	author daveb;	state Exp;
branches;
next	1.149;

1.149
date	96.02.26.11.27.44;	author jont;	state Exp;
branches;
next	1.148;

1.148
date	96.02.23.17.36.12;	author jont;	state Exp;
branches;
next	1.147;

1.147
date	96.02.22.14.09.22;	author jont;	state Exp;
branches;
next	1.146;

1.146
date	95.12.27.13.10.50;	author jont;	state Exp;
branches;
next	1.145;

1.145
date	95.11.20.16.51.09;	author jont;	state Exp;
branches;
next	1.144;

1.144
date	95.09.21.14.10.46;	author matthew;	state Exp;
branches;
next	1.143;

1.143
date	95.09.08.17.48.28;	author daveb;	state Exp;
branches;
next	1.142;

1.142
date	95.07.28.09.47.00;	author jont;	state Exp;
branches;
next	1.141;

1.141
date	95.07.25.12.19.38;	author jont;	state Exp;
branches;
next	1.140;

1.140
date	95.07.19.11.24.11;	author jont;	state Exp;
branches;
next	1.139;

1.139
date	95.04.27.12.57.44;	author matthew;	state Exp;
branches;
next	1.138;

1.138
date	95.04.21.14.26.23;	author jont;	state Exp;
branches;
next	1.137;

1.137
date	95.04.20.14.10.00;	author jont;	state Exp;
branches;
next	1.136;

1.136
date	95.04.06.10.28.12;	author matthew;	state Exp;
branches;
next	1.135;

1.135
date	95.03.01.14.07.00;	author matthew;	state Exp;
branches;
next	1.134;

1.134
date	95.02.07.13.02.42;	author matthew;	state Exp;
branches;
next	1.133;

1.133
date	95.01.17.10.11.41;	author matthew;	state Exp;
branches;
next	1.132;

1.132
date	94.10.13.10.46.16;	author matthew;	state Exp;
branches;
next	1.131;

1.131
date	94.10.06.11.54.16;	author matthew;	state Exp;
branches;
next	1.130;

1.130
date	94.09.28.16.29.36;	author nickb;	state Exp;
branches;
next	1.129;

1.129
date	94.09.22.10.32.59;	author matthew;	state Exp;
branches;
next	1.128;

1.128
date	94.07.19.14.49.28;	author jont;	state Exp;
branches;
next	1.127;

1.127
date	94.06.24.14.53.27;	author jont;	state Exp;
branches;
next	1.126;

1.126
date	94.06.22.15.25.23;	author jont;	state Exp;
branches;
next	1.125;

1.125
date	94.06.21.16.03.00;	author nickh;	state Exp;
branches;
next	1.124;

1.124
date	94.06.09.16.05.47;	author nickh;	state Exp;
branches;
next	1.123;

1.123
date	94.05.23.17.14.31;	author jont;	state Exp;
branches;
next	1.122;

1.122
date	94.05.16.13.41.36;	author daveb;	state Exp;
branches;
next	1.121;

1.121
date	94.05.05.13.49.46;	author daveb;	state Exp;
branches;
next	1.120;

1.120
date	94.04.13.10.53.04;	author jont;	state Exp;
branches;
next	1.119;

1.119
date	94.04.07.15.09.06;	author jont;	state Exp;
branches;
next	1.118;

1.118
date	94.03.08.17.43.46;	author jont;	state Exp;
branches;
next	1.117;

1.117
date	94.02.28.08.14.22;	author nosa;	state Exp;
branches;
next	1.116;

1.116
date	94.02.22.11.17.48;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	94.02.21.16.51.32;	author daveb;	state Exp;
branches;
next	1.114;

1.114
date	94.01.18.17.18.11;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	94.01.07.17.33.04;	author matthew;	state Exp;
branches;
next	1.112;

1.112
date	94.01.05.12.52.17;	author daveb;	state Exp;
branches;
next	1.111;

1.111
date	93.12.16.14.03.07;	author matthew;	state Exp;
branches;
next	1.110;

1.110
date	93.11.30.13.41.03;	author matthew;	state Exp;
branches;
next	1.109;

1.109
date	93.11.15.14.13.59;	author nickh;	state Exp;
branches;
next	1.108;

1.108
date	93.09.21.16.18.25;	author nosa;	state Exp;
branches;
next	1.107;

1.107
date	93.08.26.17.39.54;	author daveb;	state Exp;
branches
	1.107.1.1;
next	1.106;

1.106
date	93.08.03.14.32.02;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	93.07.19.12.41.12;	author nosa;	state Exp;
branches;
next	1.104;

1.104
date	93.07.07.17.46.46;	author daveb;	state Exp;
branches;
next	1.103;

1.103
date	93.05.28.11.39.08;	author jont;	state Exp;
branches;
next	1.102;

1.102
date	93.05.26.11.01.28;	author jont;	state Exp;
branches;
next	1.101;

1.101
date	93.05.25.15.04.53;	author jont;	state Exp;
branches;
next	1.100;

1.100
date	93.05.13.14.41.08;	author richard;	state Exp;
branches;
next	1.99;

1.99
date	93.04.23.13.24.48;	author jont;	state Exp;
branches;
next	1.98;

1.98
date	93.04.21.14.10.34;	author jont;	state Exp;
branches;
next	1.97;

1.97
date	93.03.24.15.42.09;	author richard;	state Exp;
branches;
next	1.96;

1.96
date	93.03.18.13.52.41;	author matthew;	state Exp;
branches;
next	1.95;

1.95
date	93.03.18.13.29.25;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	93.03.11.11.12.05;	author matthew;	state Exp;
branches;
next	1.93;

1.93
date	93.03.09.12.57.03;	author matthew;	state Exp;
branches;
next	1.92;

1.92
date	93.03.01.15.23.58;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	93.02.19.11.44.55;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	93.02.10.17.27.07;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	93.02.09.10.46.21;	author matthew;	state Exp;
branches;
next	1.88;

1.88
date	93.02.02.11.10.11;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	93.01.15.11.24.44;	author daveb;	state Exp;
branches;
next	1.86;

1.86
date	93.01.14.14.37.57;	author daveb;	state Exp;
branches;
next	1.85;

1.85
date	93.01.06.12.32.19;	author jont;	state Exp;
branches;
next	1.84;

1.84
date	92.12.22.16.51.56;	author jont;	state Exp;
branches;
next	1.83;

1.83
date	92.12.01.16.59.44;	author matthew;	state Exp;
branches;
next	1.82;

1.82
date	92.11.30.14.17.40;	author jont;	state Exp;
branches;
next	1.81;

1.81
date	92.11.25.12.26.32;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	92.11.02.11.30.26;	author richard;	state Exp;
branches;
next	1.79;

1.79
date	92.10.30.14.22.02;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	92.10.28.12.10.15;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	92.10.27.18.47.38;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	92.10.15.16.19.18;	author clive;	state Exp;
branches;
next	1.75;

1.75
date	92.10.09.14.22.48;	author clive;	state Exp;
branches;
next	1.74;

1.74
date	92.10.02.16.31.40;	author clive;	state Exp;
branches;
next	1.73;

1.73
date	92.09.25.17.23.50;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	92.09.22.13.37.54;	author clive;	state Exp;
branches;
next	1.71;

1.71
date	92.09.21.11.30.20;	author clive;	state Exp;
branches;
next	1.70;

1.70
date	92.09.17.12.14.40;	author clive;	state Exp;
branches;
next	1.69;

1.69
date	92.09.14.15.06.53;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	92.09.11.16.18.25;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	92.09.10.10.34.21;	author richard;	state Exp;
branches;
next	1.66;

1.66
date	92.09.04.12.22.44;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	92.09.02.16.18.18;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	92.08.28.01.08.39;	author davidt;	state Exp;
branches;
next	1.63;

1.63
date	92.08.27.09.41.43;	author richard;	state Exp;
branches;
next	1.62;

1.62
date	92.08.26.18.33.05;	author davidt;	state Exp;
branches;
next	1.61;

1.61
date	92.08.26.16.47.16;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	92.08.25.10.52.42;	author clive;	state Exp;
branches;
next	1.59;

1.59
date	92.08.24.19.11.17;	author davidt;	state Exp;
branches;
next	1.58;

1.58
date	92.08.19.13.00.36;	author davidt;	state Exp;
branches;
next	1.57;

1.57
date	92.08.18.13.38.26;	author davidt;	state Exp;
branches;
next	1.56;

1.56
date	92.08.14.17.47.13;	author davidt;	state Exp;
branches;
next	1.55;

1.55
date	92.08.12.17.51.48;	author davidt;	state Exp;
branches;
next	1.54;

1.54
date	92.08.12.14.41.40;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	92.08.12.14.03.58;	author davidt;	state Exp;
branches;
next	1.52;

1.52
date	92.08.12.10.40.36;	author davidt;	state Exp;
branches;
next	1.51;

1.51
date	92.08.10.17.23.46;	author davidt;	state Exp;
branches;
next	1.50;

1.50
date	92.08.10.11.27.02;	author davidt;	state Exp;
branches;
next	1.49;

1.49
date	92.08.06.16.55.33;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	92.07.29.17.02.54;	author clive;	state Exp;
branches;
next	1.47;

1.47
date	92.07.28.08.54.21;	author clive;	state Exp;
branches;
next	1.46;

1.46
date	92.07.22.07.53.15;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.07.21.17.40.28;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	92.07.16.16.33.11;	author clive;	state Exp;
branches;
next	1.43;

1.43
date	92.07.15.16.31.38;	author clive;	state Exp;
branches;
next	1.42;

1.42
date	92.07.07.09.45.49;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.06.18.12.17.12;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	92.06.15.14.27.50;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.06.11.09.43.26;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.06.10.15.08.40;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.05.12.15.50.15;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.05.01.10.12.08;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.04.03.10.24.36;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.03.20.15.42.49;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.03.16.18.38.28;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.03.03.12.39.21;	author richard;	state Exp;
branches;
next	1.31;

1.31
date	92.02.27.17.40.52;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.02.12.11.11.36;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.01.30.15.34.51;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.01.25.00.55.18;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.01.23.16.09.32;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.01.22.18.31.19;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.01.22.16.52.40;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.01.21.13.37.10;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.01.20.16.30.04;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.01.17.21.21.27;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.01.15.20.41.56;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.01.15.14.23.27;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.01.14.12.05.54;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.01.10.18.48.34;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.01.09.10.59.30;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.01.08.17.10.15;	author colin;	state Exp;
branches;
next	1.15;

1.15
date	92.01.07.17.09.25;	author colin;	state Exp;
branches;
next	1.14;

1.14
date	92.01.06.15.20.20;	author colin;	state Exp;
branches;
next	1.13;

1.13
date	91.12.20.16.25.17;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.12.20.12.00.13;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.12.20.01.19.22;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.12.19.17.03.10;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.12.18.19.44.40;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.12.17.19.34.04;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.12.16.19.25.15;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.12.16.17.04.38;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.12.11.11.44.41;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.11.11.16.55.04;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.18.15.23.04;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.10.17.18.02.29;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.10.16.13.47.53;	author jont;	state Exp;
branches;
next	;

1.107.1.1
date	93.08.26.17.39.54;	author jont;	state Exp;
branches;
next	;

1.159.1.1
date	96.09.13.11.18.15;	author hope;	state Exp;
branches;
next	;

1.160.1.1
date	96.10.07.16.08.07;	author hope;	state Exp;
branches;
next	;

1.161.1.1
date	96.10.17.11.26.22;	author hope;	state Exp;
branches;
next	;

1.165.1.1
date	96.11.14.12.51.39;	author hope;	state Exp;
branches
	1.165.1.1.1.1;
next	;

1.165.1.1.1.1
date	96.11.28.15.02.42;	author hope;	state Exp;
branches;
next	;

1.165.2.1
date	96.11.22.18.10.52;	author hope;	state Exp;
branches;
next	;

1.165.3.1
date	96.12.17.17.49.27;	author hope;	state Exp;
branches
	1.165.3.1.1.1;
next	;

1.165.3.1.1.1
date	97.02.24.11.39.35;	author hope;	state Exp;
branches;
next	;

1.165.4.1
date	96.12.18.09.43.31;	author hope;	state Exp;
branches;
next	;

1.165.5.1
date	97.05.12.10.36.00;	author hope;	state Exp;
branches
	1.165.5.1.1.1
	1.165.5.1.2.1
	1.165.5.1.3.1;
next	;

1.165.5.1.1.1
date	97.07.28.18.21.41;	author daveb;	state Exp;
branches
	1.165.5.1.1.1.1.1;
next	;

1.165.5.1.1.1.1.1
date	97.10.07.11.47.22;	author jkbrook;	state Exp;
branches;
next	;

1.165.5.1.2.1
date	97.09.08.17.15.05;	author daveb;	state Exp;
branches;
next	;

1.165.5.1.3.1
date	97.09.09.14.10.58;	author daveb;	state Exp;
branches;
next	;

1.168.1.1
date	97.09.10.19.26.59;	author brucem;	state Exp;
branches;
next	;

1.168.2.1
date	97.09.11.20.57.00;	author daveb;	state Exp;
branches;
next	1.168.2.2;

1.168.2.2
date	97.10.29.14.10.27;	author daveb;	state Exp;
branches;
next	1.168.2.3;

1.168.2.3
date	97.11.20.17.59.48;	author daveb;	state Exp;
branches;
next	;

1.186.1.1
date	99.04.01.17.57.47;	author daveb;	state Exp;
branches;
next	;


desc
@Binary encapsulation of data for separate compilation
@


1.186
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@(* _encapsulate.sml the functor *)
(*
$Log: _encapsulate.sml,v $
 * Revision 1.185  1999/02/02  16:00:55  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.184  1998/10/23  15:05:49  jont
 * [Bug #70198]
 * Add interface to get code_offset
 *
 * Revision 1.183  1998/10/23  10:59:13  jont
 * [Bug #70194]
 * Add interface for input_code taking filename to code_module
 *
 * Revision 1.182  1998/09/25  16:42:06  jont
 * [Bug #70181]
 * Handle Time.Time which can occur from decode_cons
 *
 * Revision 1.181  1998/05/26  13:56:24  mitchell
 * [Bug #30413]
 * Close streams at the stream_io level, rather than just the underlying stream
 *
 * Revision 1.180  1998/04/22  11:38:00  jont
 * [Bug #70099]
 * Changing encapsulation order to do type_env
 * before lambda_env and parser_env
 *
 * Revision 1.179  1998/04/16  21:44:35  jont
 * [Bug #70058]
 * Remove __terminal from list of requires
 *
 * Revision 1.178  1998/04/16  11:00:51  jont
 * [Bug #70058]
 * Use the proper submodule table when getting debug info
 *
 * Revision 1.177  1998/02/19  17:13:42  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.176  1998/02/19  15:01:44  jont
 * [Bug #30341]
 * Fix where type ... and syntax
 *
 * Revision 1.175  1998/02/06  16:05:17  jont
 * [Bug #70053]
 * Change Crash.impossible calls for debug info decapsulation into user errors
 *
 * Revision 1.174  1998/02/06  13:35:44  johnh
 * [Bug #30326]
 * Merge in change from branch MLWorks_workspace_97
 *
 * Revision 1.173  1998/02/05  12:07:48  jont
 * [Bug #30331]
 * Add input_debug_info to interface
 *
 * Revision 1.172  1998/01/28  12:23:44  jont
 * [Bug #30330]
 * Modify encapsulation mechanism for valenvs found in tynames
 * so as to avoid circularity problems.
 *
 * Revision 1.171  1997/11/25  19:48:08  jont
 * [Bug #30328]
 * Add environment parameter to decode_type_basis
 * for finding pervasive type names
 *
 * Revision 1.170  1997/11/13  11:19:00  jont
 * [Bug #30089]
 * Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
 *
 * Revision 1.169  1997/10/21  12:35:16  jont
 * [Bug #30089]
 * Replacing MLWorks.Time with Time from the basis
 *
 * $Log: _encapsulate.sml,v $
 * Revision 1.184  1998/10/23  15:05:49  jont
 * [Bug #70198]
 * Add interface to get code_offset
 *
 * Revision 1.183  1998/10/23  10:59:13  jont
 * [Bug #70194]
 * Add interface for input_code taking filename to code_module
 *
 * Revision 1.182  1998/09/25  16:42:06  jont
 * [Bug #70181]
 * Handle Time.Time which can occur from decode_cons
 *
 * Revision 1.181  1998/05/26  13:56:24  mitchell
 * [Bug #30413]
 * Close streams at the stream_io level, rather than just the underlying stream
 *
 * Revision 1.180  1998/04/22  11:38:00  jont
 * [Bug #70099]
 * Changing encapsulation order to do type_env
 * before lambda_env and parser_env
 *
 * Revision 1.179  1998/04/16  21:44:35  jont
 * [Bug #70058]
 * Remove __terminal from list of requires
 *
 * Revision 1.178  1998/04/16  11:00:51  jont
 * [Bug #70058]
 * Use the proper submodule table when getting debug info
 *
 * Revision 1.177  1998/02/19  17:13:42  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.176  1998/02/19  15:01:44  jont
 * [Bug #30341]
 * Fix where type ... and syntax
 *
 * Revision 1.175  1998/02/06  16:05:17  jont
 * [Bug #70053]
 * Change Crash.impossible calls for debug info decapsulation into user errors
 *
 * Revision 1.174  1998/02/06  13:35:44  johnh
 * [Bug #30326]
 * Merge in change from branch MLWorks_workspace_97
 *
 * Revision 1.168.2.3  1997/11/20  17:59:48  daveb
 * [Bug #30326]
 * Renamed utils/*timer to utils/*mlworks_timer.
 *
 * Revision 1.168.2.2  1997/10/29  14:10:27  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Replacing MLWorks.Time with Time from the basis
 *
 *
 * Revision 1.168.2.1  1997/09/11  20:57:00  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.168  1997/06/03  17:30:50  jont
 * [Bug #30090]
 * Modify to handle IO.Io near BinIO.openIn
 *
 * Revision 1.167  1997/05/30  10:41:53  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.166  1997/05/09  14:40:30  jont
 * [Bug #30091]
 * Convert from MLWorks.Internal.FileIO to BinIO from the basis
 *
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.164  1996/11/04  16:28:03  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.163  1996/10/29  15:23:19  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.162  1996/10/25  09:22:26  andreww
 * [Bug #1686]
 * extending parser environment
 *
 * Revision 1.161  1996/10/04  15:48:57  andreww
 * [Bug #1592]
 * Threading extra "level" argument to tynames.
 *
 * Revision 1.160  1996/09/18  15:25:07  io
 * [Bug #1603]
 * convert MLWorks.ByteArray to MLWorks.Internal.ByteArray or equivalent basis functions
 *
 * Revision 1.159  1996/08/01  12:27:22  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
 * Revision 1.158  1996/07/12  13:44:33  jont
 * [Bug #1469]
 * Fix problems in decode_spill
 *
 * Revision 1.157  1996/05/30  12:41:56  daveb
 * The Io and Ord exceptions are no longer at top level.
 *
 * Revision 1.156  1996/05/16  16:30:50  matthew
 * Bits becomes MLWorks.Internal.Bits
 *
 * Revision 1.155  1996/05/07  11:17:28  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.154  1996/04/30  17:12:53  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, outstream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.153  1996/04/29  14:59:39  matthew
 * Removing MLWorks.Integer
 *
 * Revision 1.152  1996/04/25  14:48:53  stephenb
 * Change interceptible so that it doesn't always return false.
 * This gets the runtime and image back in sync and so fixes bug #913.
 *
 * Revision 1.151  1996/03/20  12:52:42  matthew
 * Changes to parser signature environment
 *
 * Revision 1.150  1996/03/01  14:24:16  daveb
 * Changed type of input_info.
 *
 * Revision 1.149  1996/02/26  11:27:44  jont
 * Change newhashtable to hashtable
 *
 * Revision 1.148  1996/02/23  17:36:12  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.147  1996/02/22  14:09:22  jont
 * Replacing Map with NewMap
 *
 * Revision 1.146  1995/12/27  13:10:50  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.145  1995/11/20  16:51:09  jont
Modifications for improved runtime environments in the debugger

Revision 1.144  1995/09/21  14:10:46  matthew
Fixing problem with modules with no stamps defined

Revision 1.143  1995/09/08  17:48:28  daveb
Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.

Revision 1.142  1995/07/28  09:47:00  jont
Add handling for overloading on words

Revision 1.141  1995/07/25  12:19:38  jont
Add WORD to runtime_env

Revision 1.140  1995/07/19  11:24:11  jont
Add CHAR constructor in runtime_env

Revision 1.139  1995/04/27  12:57:44  matthew
decode_ and write_ runtime_env used inconsistent string functions

Revision 1.138  1995/04/21  14:26:23  jont
Modify stamp_module in output_file to use an ordered array

Revision 1.137  1995/04/20  14:10:00  jont
Change decode_type_basis to accept a btree

Revision 1.136  1995/04/06  10:28:12  matthew
Use Stamp instead of Tyname_id etc.

Revision 1.135  1995/03/01  14:07:00  matthew
Changes to debugger types

Revision 1.134  1995/02/07  13:02:42  matthew
Moving pervasive name counts to Basis

Revision 1.133  1995/01/17  10:11:41  matthew
Rationalizing debugger

Revision 1.132  1994/10/13  10:46:16  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.131  1994/10/06  11:54:16  matthew
Rationalizing data structures

Revision 1.130  1994/09/28  16:29:36  nickb
Reorganise the whole file so it's more legible.
Also buffer output.

Revision 1.129  1994/09/22  10:32:59  matthew
Abstraction of debug information

Revision 1.128  1994/07/19  14:49:28  jont
Modifications to include number of callee saves in wordsets

Revision 1.127  1994/06/24  14:53:27  jont
Ensure exception debug info flag stored

Revision 1.126  1994/06/22  15:25:23  jont
Update debugger information production

Revision 1.125  1994/06/21  16:03:00  nickh
Change .mo format to enable loading with immutable ancillary slots.

Revision 1.124  1994/06/09  16:05:47  nickh
New runtime directory structure.

Revision 1.123  1994/05/23  17:14:31  jont
Removed a couple of superfluous handlers and tidied up

Revision 1.122  1994/05/16  13:41:36  daveb
Added support for int_literal_tyvar and real_literal_tyvar.

Revision 1.121  1994/05/05  13:49:46  daveb
Changes for new overloading scheme.

Revision 1.120  1994/04/13  10:53:04  jont
Remove message about reset_str

Revision 1.119  1994/04/07  15:09:06  jont
Add original require file names to consistency info.

Revision 1.118  1994/03/08  17:43:46  jont
Moved module type into separate file

Revision 1.117  1994/02/28  08:14:22  nosa
Monomorphic debugger encapsulation.

Revision 1.116  1994/02/22  11:17:48  daveb
Changed Info.default_options to Info.make_default_options ().

Revision 1.115  1994/02/21  16:51:32  daveb
Added call to Info.error' to report missing modules.

Revision 1.114  1994/01/18  17:18:11  matthew
Changed NewMap.Undefined exception to BadInput

Revision 1.114  1994/01/18  17:18:11  matthew
Changed NewMap.Undefined exception to BadInput

Revision 1.113  1994/01/07  17:33:04  matthew
Added some debug info.

Also changed type of submodule info for output_file and decode_type_basis to include range information.

Revision 1.112  1994/01/05  12:52:17  daveb
Added sharing constraint to match one in result signature.

Revision 1.111  1993/12/16  14:03:07  matthew
Added level field to Basis.
Added and commented out line to save Wordset name as ""

Revision 1.110  1993/11/30  13:41:03  matthew
Added is_abs field to TYNAME and METATYNAME

Revision 1.109  1993/11/15  14:13:59  nickh
New pervasive time structure.

Revision 1.108  1993/09/21  16:18:25  nosa
Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.

Revision 1.107  1993/08/26  17:39:54  daveb
Replaced header_size with ObjectFile.HEADER_SIZE.

Revision 1.106  1993/08/03  14:32:02  jont
Modifications to decode_type_basis to take module name, and to remove the gaps
stuff in encoding now that equires can't be mixed with other topdecs

Revision 1.105  1993/07/19  12:41:12  nosa
Debugger Environments for local and closure variable inspection
in the debugger;
structure Option.

Revision 1.104  1993/07/07  17:46:46  daveb
Removed exception environments and interfaces.
Funenvs no longer have interface components.
On the other hand, the constructor status of valids in lambda environments
is important now.

Revision 1.103  1993/05/28  11:39:08  jont
Cleaned up after assembly changes

Revision 1.102  1993/05/26  11:01:28  jont
Stopped encapsulating and decapsulating assemblies

Revision 1.101  1993/05/25  15:04:53  jont
Changes because Assemblies now has BasisTypes instead of Datatypes

Revision 1.100  1993/05/13  14:41:08  richard
Changed the layout of code vectors to make life _much_ easier for
the runtime system loader.

Revision 1.99  1993/04/23  13:24:48  jont
Modified to use rts write_byte. Bug fixed assembly encapsulation

Revision 1.98  1993/04/21  14:10:34  jont
Improved encapsulation of integers in assemblies

Revision 1.97  1993/03/24  15:42:09  richard
Corrected #define symbols to upper case.

Revision 1.96  1993/03/18  13:52:41  matthew
Nameset signature changes

Revision 1.95  1993/03/18  13:29:25  jont
Encapsulated extra WORDSET information

Revision 1.94  1993/03/11  11:12:05  matthew
Signature revisions

Revision 1.93  1993/03/09  12:57:03  matthew
Options & Info changes

Revision 1.92  1993/03/01  15:23:58  matthew
Added crash when trying to encapsulate an MLVALUE object
I guess this should really be an ordinary error

Revision 1.91  1993/02/19  11:44:55  jont
Modified to spot common strs. Big size improvement for large .mo files

Revision 1.90  1993/02/10  17:27:07  jont
Changes for code vector reform.

Revision 1.89  1993/02/09  10:46:21  matthew
Typechecker structure changes

Revision 1.88  1993/02/02  11:10:11  matthew
Changed for COPYSTR structures.
Added cached values in interfaces and structures.

Revision 1.87  1993/01/15  11:24:44  daveb
Changed ObjectFile.version to ObjectFile.object_file_version to avoid
problem on the C side of the run time system.

Revision 1.86  1993/01/14  14:37:57  daveb
Moved currentVersion into ObjectFile, so that it's accessible to the run-time
system too.

Revision 1.85  1993/01/06  12:32:19  jont
Anel's last changes

Revision 1.84  1992/12/22  16:51:56  jont
Ensure decode_cons is done before close_in file_handle in order to
fix file already closed bug

Revision 1.83  1992/12/01  16:59:44  matthew
Simplified some error messages

Revision 1.82  1992/11/30  14:17:40  jont
Changed to encode tyenvs where they're in common.
Some minor efficiency improvements to do with module name searching

Revision 1.81  1992/11/25  12:26:32  matthew
Changed error messages

Revision 1.80  1992/11/02  11:30:26  richard
Time is now represented by a pervasive structure.

Revision 1.79  1992/10/30  14:22:02  jont
Modified assembly encapsulation to use IntMap

Revision 1.78  1992/10/28  12:10:15  jont
Removed dependence on environ in favour of environtypes

Revision 1.77  1992/10/27  18:47:38  jont
Modified to use less than functions for maps

Revision 1.76  1992/10/15  16:19:18  clive
Anel's changes for encapsulating assemblies

Revision 1.75  1992/10/09  14:22:48  clive
Tynames now have a slot recording their definition point

Revision 1.74  1992/10/02  16:31:40  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.73  1992/09/25  17:23:50  jont
Stopped using empty_eqfunmap, no longer necessary. Simplified decode_map
and encode_map

Revision 1.72  1992/09/22  13:37:54  clive
Added a type annotation

Revision 1.71  1992/09/21  11:30:20  clive
Changed hashtables to a single structure implementation

Revision 1.70  1992/09/17  12:14:40  clive
Typo meant some things looked up in the wrong hashtable

Revision 1.69  1992/09/14  15:06:53  jont
Changed a number of handle statements for uses of lookup_default

Revision 1.68  1992/09/11  16:18:25  jont
Allowed NULLTYPEs in valenvs, produced by nameset copying

Revision 1.67  1992/09/10  10:34:21  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.66  1992/09/04  12:22:44  jont
Converted all instances to Lists.nth to use hash tables

Revision 1.65  1992/09/02  16:18:18  jont
Changed encapsulation format to include number of strings found.
Should improve input speed

Revision 1.64  1992/08/28  01:08:39  davidt
Took out some unnecessary diagnostic output.

Revision 1.63  1992/08/27  09:41:43  richard
Rationalisation of the MLWorks structure.

Revision 1.62  1992/08/26  18:33:05  davidt
Removed some of the large lists that were being built
during encapsulation. Changed some sharing constraints.

Revision 1.60  1992/08/25  10:52:42  clive
Added details about leafness to the debug information

Revision 1.59  1992/08/24  19:11:17  davidt
Added various optimisations, the most important of which being the
compression of identical strings, which results in very large
(up to 40% or 50%) reductions in the size of mo files.

Revision 1.58  1992/08/19  13:00:36  davidt
Fixed up changes since parserenv now uses NewMap. The exception BadInput
now includes the filename as part of the error messages.

Revision 1.57  1992/08/18  13:38:26  davidt
Took out various exception handlers and put them all round the
top level function body, hence only building the handlers
once for each object file.

Revision 1.56  1992/08/14  17:47:13  davidt
Implemented inputting of consistency info without requiring the
whole object file to be read.

Revision 1.55  1992/08/12  17:51:48  davidt
Did a bit more tidying up.

Revision 1.54  1992/08/12  14:41:40  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.53  1992/08/12  14:03:58  davidt
Started optimisations, removing Map.to_list etc.

Revision 1.52  1992/08/12  10:40:36  davidt
Fixed nasty bug in encapsulation of strname counts.

Revision 1.51  1992/08/10  17:23:46  davidt
Changed MLworks to MLWorks.

Revision 1.50  1992/08/10  11:27:02  davidt
Deleted various redundant structure arguments. Changed some
of the output routines to output stuff directly to the
mo file, instead of building intermediate lists etc.

Revision 1.48  1992/07/29  17:02:54  clive
Better version of the output function for the delayed structure

Revision 1.47  1992/07/28  08:54:21  clive
Use of new hash tables, removed some concatenation and compression of integers in encapsulator

Revision 1.46  1992/07/22  07:53:15  clive
Added three : int annotations required by our compiler

Revision 1.45  1992/07/21  17:40:28  jont
Modified to observe commonality within parser environments and
code generation environments in order to reduce encoding/decoding time
and size of encoded objects

Revision 1.44  1992/07/16  16:33:11  clive
Change in sharing constraint to reflect change in debugger_types

Revision 1.43  1992/07/15  16:31:38  clive
Added an element to the recipe type so needed to change encapsulator

Revision 1.42  1992/07/07  09:45:49  clive
Added call point information recording

Revision 1.41  1992/06/18  12:17:12  jont
Added furhter constructors to the module element type to express
interpretive stuff

Revision 1.40  1992/06/15  14:27:50  jont
Added decode_counts functions to speed up subrequiresd

Revision 1.39  1992/06/11  09:43:26  clive
Added the encapsulation of function debugging information

Revision 1.38  1992/06/10  15:08:40  jont
changed to use newmap

Revision 1.37  1992/05/12  15:50:15  jont
Changed version number to two for update of magic number

Revision 1.36  1992/05/01  10:12:08  jont
Some minor improvements and revisions. Fixity is now a byte

Revision 1.35  1992/04/03  10:24:36  jont
Add integer parameter to functor. Removed references to pervasive length.
Added type specifier to resolve some +

Revision 1.34  1992/03/20  15:42:49  jont
Changed to use hash tables in various places. Altered the encoding
of valenvs in tynames to give only the domain plus whether the range
is a fun or cons type. This is all the code generator needs, and the
typechecker doesn't look at this stuff. This breaks the circularity for
metatynames so we now encode them as well. Also fixed the code output
to give both the number of module elements and the number of top level
tags (both are need by the runtime system when sets of mutually
recursive procedures are around). Changed the version number to reflect
this.

Revision 1.33  1992/03/16  18:38:28  jont
Added use of hastable for encoding comon types and tynames

Revision 1.33  1992/03/16  16:57:50  jont
Added hash tables for encoding of common types (fun, rec, cons) and also
metatynames.

Revision 1.32  1992/03/03  12:39:21  richard
Changed names of functions in Pervasives.

Revision 1.31  1992/02/27  17:40:52  jont
Changed such that all maps are created with equality functions

Revision 1.30  1992/02/12  11:11:36  clive
New pervasive library code - cut some things out of the initial type basis

Revision 1.29  1992/01/30  15:34:51  jont
Fixed bug in decode_refvalenv whereby valenv maps were created
with op=, should be done with Ident.valid_eq

Revision 1.28  1992/01/25  00:55:18  jont
Modified to allow valenv field in METATYNAMEs. These are not encoded
or decoded to avoid the circularity problem. They are recalculated
by the cor rules typechecking phase as necessary

Revision 1.27  1992/01/23  16:09:32  jont
Changed to encode tyfun_ids similarly to tyname_ids

Revision 1.26  1992/01/22  18:31:19  jont
Changed encoding of Tyname slightly since we don't spot repeats any
more for TYNAME

Revision 1.25  1992/01/22  16:52:40  jont
Used new type_same from Enc_Sub to do equality on Type (not equality
types themselves)/ Pointer eq would probably be nicer

Revision 1.24  1992/01/21  13:37:10  jont
Split type encoding into all constituent parts, for improved speed.
There is a lurking problem here, Type is not an equality type,
although NJ believes it is.

Revision 1.23  1992/01/20  16:30:04  jont
Removed diagnostic stuff. Improved speed by a further factor of six or so

Revision 1.22  1992/01/17  21:21:27  jont
Fixed problem with encoding types, caused by Tyname -> Valenv -> Typescheme
-> Type -> Tyname circularity, such that the second instance of tyname
was incorrectly read as an existing Tyname, even though it hadn't been
fully decoded. Ugh!

Revision 1.21  1992/01/15  20:41:56  jont
Modified to output only one instance of each METATYNAME and Type,
for improved efficiency

Revision 1.20  1992/01/15  14:23:27  jont
Changed to use the ref int in the valenv as the encoding number

Revision 1.19  1992/01/14  12:05:54  clive
Added code for non_gc spills number in front of code objects in a closure
by changing encode_code to propogate it through

Revision 1.18  1992/01/10  18:48:34  jont
Added more diagnostics. Tried to improve output of type environments
by using balanced trees instead of association lists. Not very successful

Revision 1.17  1992/01/09  10:59:30  jont
Fixed fault in decode_tyname whereby entire string was being inserted
rather than the relevant substring.

Revision 1.16  1992/01/08  17:10:15  colin
Added code to maintain unique tyname and strname_ids across modules.

Revision 1.15  1992/01/07  17:09:25  colin
changed encode and decode tyname_id to work with new tyname_id (ie no
number of constructor field)

Revision 1.14  1992/01/06  15:20:20  colin
Changed encoding for meta strnames to mainting sharing of identical
refs on decoding of type environments.

Revision 1.13  1991/12/20  16:25:17  jont
Fixed bug whereby decoded lists arrived backwards

Revision 1.12  91/12/20  12:00:13  jont
Changed the header ordering to a more readily extensible system

Revision 1.11  91/12/20  01:19:22  jont
Fixed problem in decoding parser envs where the pointer was being reset
to 0

Revision 1.10  91/12/19  17:03:10  jont
Tidied up to use map and list and pair encodings and decodings. Should
improve consistency between encode and decode

Revision 1.9  91/12/18  19:44:40  jont
Added encoding and decoding of typechecker bases

Revision 1.8  91/12/17  19:34:04  jont
Finished parser environment encapsulation. Began typechecker basis work.

Revision 1.7  91/12/16  19:25:15  jont
Wrote input_file, and added temporary versions for encoding and decoding
parser environments

Revision 1.6  91/12/16  17:04:38  jont
Completed decoding of lambda environments

Revision 1.5  91/12/11  11:44:41  jont
Added encoding and decoding of lambda environments

Revision 1.4  91/11/11  16:55:04  jont
Output of real numbers added

Revision 1.3  91/10/18  15:23:04  jont
Put zero termination on strings

Revision 1.2  91/10/17  18:02:29  jont
Acquired opcodes and magic number from ObjectFile

Revision 1.1  91/10/16  13:47:53  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

(*
Straightforward encoding of typechecker bases, with two special points:

1. because there is a circular data structure with valenv ->
typescheme -> type -> tyname -> ref valenv, valenvs are cached (by
their ref unit component) and repeated valenvs are just encoded by
their number. Decoding is similar (although a dummy ref valenv must be
used for each valenv on the cache list until its decoding is complete).

2. tynames repeat frequently in a basis, and are cached (in a similar
way, using their ref bool) to save volume of output (a 3-fold saving
for the initial basis).

Note: we might well have to change this to modify type and structure
names (so that several decoded specs can just be added together using
the existing functions (basis_circle_plus_basis in this case, which
does a nameset union, which tests for equality among tynames, etc.).)
*)
(* 8/1/92 cim

The code has been added which maintains uniqueness of strname_id's and
tyname_id's so that generativity works properly over separately compiled
modules. The following two points should be noted:

1. tyfun_id's are not treated using this mechanism. I think that tyfun_id's are
always bound in the module's basis. but if this is a problem the code for
tyname and strname_id's can easily be applied to tyfun_id's.

2. equality of ref's in metastrnames is not guaranteed between modules
(internally within modules this is guaranteed as there was a now fixed bug with
this). However, metastrnames are only compared by ptr equality when they are
pointing to NULLNAME. (as opposed to the STRNAME of Strname_id case in which
case ptrs are followed and strname_ids are compared and the new mechanism
ensures that strname_ids are kept consistent). This would be a problem if
metastrnames pointing to NULLNAME are shared across modules but I ASSUME this
doesn't happen.

*)

require "^.basis.__int";
require "^.basis.__real";
require "^.basis.__byte";
require "^.basis.__string";
require "^.basis.__list";
require "^.basis.__word8_array";
require "^.basis.__word8";
require "^.basis.bin_io";
require "^.basis.prim_io";
require "^.basis.__io";
require "^.system.__os";
require "^.system.__time";

require "../utils/mlworks_timer";
require "../utils/crash";
require "../utils/lists";
require "../utils/intnewmap";
require "../utils/hashtable";
require "../utils/inthashtable";
require "../parser/parserenv";
require "../typechecker/basis";
require "../typechecker/nameset";
require "../typechecker/types";
require "../typechecker/stamp";
require "../typechecker/strnames";
require "../typechecker/environment";
require "../lambda/environtypes";
require "../main/pervasives";
require "../main/info";
require "../main/code_module";
require "../rts/gen/objectfile";
require "../debugger/debugger_types";
require "enc_sub";
require "encapsulate";

functor Encapsulate (
  structure Timer : INTERNAL_TIMER
  structure Crash : CRASH
  structure Lists : LISTS
  structure IntMap : INTNEWMAP
  structure ParserEnv : PARSERENV
  structure Basis : BASIS
  structure Nameset : NAMESET
  structure Types : TYPES
  structure Stamp : STAMP
  structure Strnames : STRNAMES
  structure Env : ENVIRONMENT
  structure Pervasives : PERVASIVES
  structure Info : INFO
  structure Code_Module : CODE_MODULE
  structure ObjectFile : OBJECTFILE
  structure Enc_Sub : ENC_SUB
  structure Debugger_Types : DEBUGGER_TYPES
  structure HashTable : HASHTABLE
  structure IntHashTable : INTHASHTABLE
  structure EnvironTypes : ENVIRONTYPES
  structure BinIO : BIN_IO where type StreamIO.pos = int
  structure PrimIO : PRIM_IO where type pos = int where type writer = BinIO.StreamIO.writer where type vector = BinIO.vector where type reader = BinIO.StreamIO.reader

  sharing Basis.BasisTypes.Datatypes = Types.Datatypes =
    Enc_Sub.DataTypes =
    Env.Datatypes = Strnames.Datatypes = Nameset.Datatypes
  sharing ParserEnv.Ident = Types.Datatypes.Ident = EnvironTypes.LambdaTypes.Ident
  sharing Types.Datatypes.NewMap = ParserEnv.Map = EnvironTypes.NewMap
  sharing ParserEnv.Ident.Location = Info.Location

  sharing type Basis.BasisTypes.Nameset = Nameset.Nameset
  sharing type Debugger_Types.Tyname = Basis.BasisTypes.Datatypes.Tyname
  sharing type Debugger_Types.Type = EnvironTypes.LambdaTypes.Type =
    Basis.BasisTypes.Datatypes.Type = Debugger_Types.RuntimeEnv.Type
  sharing type Pervasives.pervasive = EnvironTypes.LambdaTypes.Primitive
  sharing type Basis.BasisTypes.Datatypes.Stamp = Stamp.Stamp
  sharing type Basis.BasisTypes.Datatypes.StampMap = Stamp.Map.T
) : ENCAPSULATE =
  struct
    structure Ident = ParserEnv.Ident
    structure BasisTypes = Basis.BasisTypes
    structure Datatypes = BasisTypes.Datatypes
    structure EnvironTypes = EnvironTypes
    structure Symbol = Ident.Symbol
    structure Code_Module = Code_Module
    structure ParserEnv = ParserEnv
    structure Basis = Basis
    structure Debugger_Types = Debugger_Types
    structure NewMap = Datatypes.NewMap
    structure IntMap = IntMap
    structure RuntimeEnv = Debugger_Types.RuntimeEnv
    structure Info = Info

    structure Bits = MLWorks.Internal.Bits

    type Module = Code_Module.Module

(*    val filename_debugging_ref = ref ""  (* for debugging *)
*)

    (* A constant for hash table sizes *)
    (* We could diddle with this maybe *)

    val hash_size = 128

    (* should we print encapsulation/decapsulation timings? *)

    val do_timings = ref false

    val real_divisor = Real.fromInt(1000000);

    (* A string hashing function adding together the character values
       of a string, plus the length of the string *)

    fun add_together_ords s =
      let
	fun add_together_ords'(x, acc) =
	  if x<0 then acc
	  else add_together_ords'(x-1, acc + ord(String.sub(s,x)))
      in
	add_together_ords'(size s - 1, size s)
      end

    (* bad input exception and some functions for constructing it *)

    exception BadInput of string
    fun CorruptFile n = BadInput ("Corrupt object file - " ^
				  Int.toString n)
    fun TypeDecapError n = BadInput ("Corrupt object file \
				     \(Failed during type decapsulation) - " ^
				     Int.toString n)
    fun VersionError n = BadInput (".mo file version incorrect " ^
				   Int.toString n)

    (* First, decodings. The signature has functions input_all and
     input_info to actually open a file, read information, and decode
     bits of it. input_info reads the consistency information and the
     number of generative names (e.g. strnames). input_all also reads
     the parser and lambda environments and decodes them. It reads the
     type environment but does not decode it. Instead it returns it as
     a string. If we want a decoded version, we call decode_type_basis
     on the string. *)

    (* functions for reading values from a buffer string: *)

    (* first, ints and optints: *)

    local
      fun inputi (s:string, ptr:int):int =
	let val sz = size s
	in
	  if (ptr+3) < sz then
	    let
	      val x = Bits.lshift(ord(String.sub(s, ptr)), 8)
	      val y = Bits.lshift(Bits.orb(ord(String.sub(s, ptr + 1)), x), 8)
	      val z = Bits.lshift(Bits.orb(ord(String.sub(s, ptr + 2)), y), 8)
	    in
	      Bits.orb (z, ord(String.sub(s, ptr+3)))
	    end
	  else
	    raise MLWorks.String.Ord (* make this explicit *)
	end (* inputi *)

    in
      fun input_int(s, ptr) = (inputi(s, ptr), ptr + 4)

      fun input_opt_int(s, ptr) =
	let
	  val tag = MLWorks.String.ordof(s,ptr)
	in
	  if tag = 254 then
	    (Bits.orb(Bits.lshift(MLWorks.String.ordof(s, ptr + 1), 8),
		      MLWorks.String.ordof(s, ptr + 2)), ptr + 3)
	  else if tag = 255 then
	    (inputi(s, ptr + 1), ptr + 5)
	       else
		 (tag, ptr + 1)
	end
    end

  (* now bytes: *)

    fun input_byte(s, ptr) = (MLWorks.String.ordof(s, ptr), ptr + 1)

  (* now sized strings (the size is an optint) *)

    fun input_sz_string (s, ptr) =
      let val (sz, ptr) = input_opt_int(s, ptr)
      in (MLWorks.String.substring(s, ptr, sz), ptr + sz)
      end

  (* now opt_strings. These are cached, so many copies don't get
   * written out. They are used for (e.g) symbol names.  The cache is
   * simply an association between ints and strings. An opt_string is
   * an opt_int, followed by a sized string if the int is zero. If the
   * int is non-zero n, the string is the n'th string to appear in
   * this file. *)

    local
      val stringId = ref 1
      val stringMap = ref (MLWorks.Internal.Array.array(1, ""))
    in
      fun clear_string_map n = (stringId := 1;
				stringMap := MLWorks.Internal.Array.array(n,""))

      fun input_opt_string (s, ptr) =
	let
	  val (id, ptr) = input_opt_int(s, ptr)
	in
	  if id = 0 then
	    let
	      val (str, ptr) = input_sz_string(s, ptr)
	      val strId = !stringId
	    in
	      MLWorks.Internal.Array.update(!stringMap, strId, str);
	      stringId := strId + 1;
	      (str, ptr)
	    end
	  else
	     (MLWorks.Internal.Array.sub(!stringMap, id), ptr)
	end
    end

    (* now functions to input pairs, triples, &c *)

    fun input_pair f g ptr =
      let
	val (fval, ptr) = f ptr
	val (gval, ptr) = g ptr
      in
	((fval, gval), ptr)
      end

    fun input_triple f g h ptr =
      let
	val (fval, ptr) = f ptr
	val (gval, ptr) = g ptr
	val (hval, ptr) = h ptr
      in
	((fval, gval,hval), ptr)
      end

    fun input_quadruple f g h i ptr =
      let
	val (fval, ptr) = f ptr
	val (gval, ptr) = g ptr
	val (hval, ptr) = h ptr
	val (ival, ptr) = i ptr
      in
	((fval, gval,hval,ival), ptr)
      end

    fun input_fivetuple f g h i j ptr =
      let
	val (fval, ptr) = f ptr
	val (gval, ptr) = g ptr
	val (hval, ptr) = h ptr
	val (ival, ptr) = i ptr
	val (jval, ptr) = j ptr
      in
	((fval, gval,hval,ival,jval), ptr)
      end

    fun input_sixtuple f g h i j k ptr =
      let
	val (fval, ptr) = f ptr
	val (gval, ptr) = g ptr
	val (hval, ptr) = h ptr
	val (ival, ptr) = i ptr
	val (jval, ptr) = j ptr
	val (kval, ptr) = k ptr
      in
	((fval, gval,hval,ival,jval,kval), ptr)
      end

    (* functions to input lists. Lists are preceded by a length optint *)

    fun input_list(s, f, ptr) =
      let
	val (count, ptr) = input_opt_int(s, ptr)

	fun dec_sub(0, ptr, done) = (rev done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
      in
	dec_sub(count, ptr, [])
      end

    (* a function to input maps. This is basically
     from_list (orderfn,eqfn) (input_list (s, input_pair f g, ptr))
     but avoiding reversing the list. *)

    fun input_newmap(s, f, g, ptr, orderfn, eqfn) =
      let
	val (count, ptr) = input_opt_int(s, ptr)
	fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (fval, ptr) = f ptr
	      val (gval, ptr) = g ptr
	    in
	      dec_sub(n-1, ptr, (fval, gval) :: done)
	    end
	val (list, ptr) = dec_sub(count, ptr, [])
      in
	(NewMap.from_list (orderfn,eqfn) list, ptr)
      end

    (* functions to decode various symbols. They are curried on the
     * input string so they can be specialized in each function
     * which reads symbols *)

    fun decode_symbol s ptr =
      let val (str, ptr) = input_opt_string(s, ptr)
      in (Symbol.find_symbol str, ptr)
      end

    fun decode_strid decode_symbol ptr =
      let val (sy, ptr) = decode_symbol ptr
      in (Ident.STRID sy, ptr)
      end

    fun decode_funid decode_symbol ptr =
      let val (sy, ptr) = decode_symbol ptr
      in (Ident.FUNID sy, ptr)
      end

    fun decode_sigid decode_symbol ptr =
      let val (sy, ptr) = decode_symbol ptr
      in (Ident.SIGID sy, ptr)
      end

    (* a valid is preceded by a byte indicating the identifier class *)

    fun decode_valid (decode_symbol, s) ptr =
      let
	val (sy_type, ptr) = input_byte(s, ptr)
	val (sy, ptr) = decode_symbol ptr
	val id = case sy_type of
	  0 => Ident.VAR sy
	| 1 => Ident.CON sy
	| 2 => Ident.EXCON sy
	| _ => raise CorruptFile 1
      in
	(id, ptr)
      end




    (* a similarly curried function for reading a list in reverse *)

    fun decode_rev_list s f ptr =
      let
	fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	val (count, ptr) = input_opt_int(s, ptr)
      in
	dec_sub(count, ptr, [])
      end

    (* Now the type basis, which is quite heavy, but which we only
     * decode if we actually need it (i.e. this function is separately
     * visible in the signature, and is not called in input_all). *)

    fun decode_type_basis
      {type_env, file_name, sub_modules, decode_debug_information,
       pervasive_env = Datatypes.ENV(strenv, tyenv, _)} =
      let
	val s = type_env
	val debug_variables : bool ref = ref(false)
	val decfuntypehashtable = IntHashTable.new hash_size
	val strmap = ref(IntMap.empty : Datatypes.Structure IntMap.T)
	val strmap_count = ref 0
	val dummy_valenvs = ref([] : (int * Datatypes.Valenv ref) list)

	fun search_list element_fn (l, id) =
	  Lists.findOption (fn x => element_fn(x, id)) l

	fun search_tyfun(Datatypes.ETA_TYFUN name, id) =
	  search_tyname(name, id)
	  | search_tyfun(Datatypes.TYFUN(ty, _), id) =
	  search_type(ty, id)
	  | search_tyfun(Datatypes.NULL_TYFUN(_, ref tyf), id) =
	  search_tyfun(tyf, id)

	and search_tyname(Datatypes.METATYNAME{1=ref tyf, ...}, id) =
	  search_tyfun(tyf, id)
	  | search_tyname(name as Datatypes.TYNAME{1=stamp, ...}, id) =
	  if id = stamp then SOME name else NONE

	and search_type(Datatypes.METATYVAR(ref(_, ty, _), _, _), id) =
	  search_type(ty, id)
	  | search_type(Datatypes.META_OVERLOADED{1=ref ty, ...}, id) =
	  search_type(ty, id)
	  | search_type(Datatypes.TYVAR(ref(_, ty, _), _), id) =
	  search_type(ty, id)
	  | search_type(Datatypes.METARECTYPE(ref{3=ty, ...}), id) =
	  search_type(ty, id)
	  | search_type(Datatypes.RECTYPE map, id) =
	  search_list
	  (fn ((_, ty), id) => search_type(ty, id))
	  (Datatypes.NewMap.to_list map, id)
	  | search_type(Datatypes.FUNTYPE(ty1, ty2), id) =
	  (case search_type(ty1, id) of
	     NONE => search_type(ty2, id)
	   | x => x)
	  | search_type(Datatypes.CONSTYPE(ty_list, tyname), id) =
	     (case search_tyname(tyname, id) of
		NONE => search_list search_type (ty_list, id)
	      | x => x)
	  | search_type(Datatypes.DEBRUIJN _, id) = NONE
	  | search_type(Datatypes.NULLTYPE, id) = NONE

	fun search_tyenv(Datatypes.TE map, id) =
	  search_list
	  (fn ((_, Datatypes.TYSTR(tyf, _)), id) =>
	   search_tyfun(tyf, id))
	  (Datatypes.NewMap.to_list map, id)

	fun search_str(Datatypes.STR(_, _, Datatypes.ENV(s, t, _)), id) =
	  (case search_tyenv(t, id) of
	     NONE => search_strenv(s, id)
	   | x => x)
	  | search_str(str as Datatypes.COPYSTR _, id) =
	     search_str(Env.expand_str str, id)

	and search_strenv(Datatypes.SE map, id) =
	  search_list
	  (fn ((_, str), id) => search_str(str, id))
	  (Datatypes.NewMap.to_list map, id)

	fun find_pervasive_tyname tyname_id =
	  case search_tyenv(tyenv, tyname_id) of
	    NONE => search_strenv(strenv, tyname_id)
	  | x => x

	val stamp_count =
	  let
	    val name = OS.Path.base(OS.Path.file file_name)
	  in
	    case NewMap.tryApply'(sub_modules, name) of
	      SOME(_, elt, _) => elt
	    | _ =>
		raise BadInput("sub_module '" ^ name ^ "' missing")
	  end

	fun print_sub_modules_table table =
	  let
	    val names = map
	      (fn dom => dom ^ "\n")
	      (NewMap.domain table)
	  in
	    concat("Table contains:-\n" :: names)
	  end

	fun name_offsets sub_name ptr =
	  case NewMap.tryApply'(sub_modules, sub_name) of
	    SOME(_, x, _) => x
	  | _ =>
	      Info.error'
	      (Info.make_default_options ())
	      (Info.FATAL, Info.Location.FILE file_name,
	       "Unknown module " ^ sub_name)

	fun decode_bool (ptr:int) =
	  let
	    val sz = size s
	  in
	    if ptr < sz then
	      (case ord(String.sub(s, ptr)) of
		 0 => (false, ptr+1)
	       | 1 => (true, ptr+1)
	       | _ => raise CorruptFile 4)
	    else
	      raise MLWorks.String.Ord (* make this explicit *)
	  end (* decode_bool *)
	
	fun decode_string ptr =
	  input_opt_string(s, ptr)

	val decode_symbol = decode_symbol s
	val decode_funid = decode_funid decode_symbol
	val decode_strid = decode_strid decode_symbol
	val decode_sigid = decode_sigid decode_symbol
	val decode_valid = decode_valid (decode_symbol,s)

        fun decode_tycon ptr =
          let val (sy, ptr) = decode_symbol ptr
          in (Ident.TYCON sy, ptr)
          end


	fun decode_tyvar ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	    val (b1, ptr) = decode_bool ptr
	    val (b2, ptr) = decode_bool ptr
	  in
	    (Ident.TYVAR(sy, b1, b2), ptr)
	  end

	fun decode_lab ptr =
	  let val (sy, ptr) = decode_symbol ptr
	  in (Ident.LAB sy, ptr)
	  end

	fun decode_tyname_id ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of

	      (* absolute - used for pervasives *)
	      0 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Stamp.make_stamp_n n, ptr, true)
		end

	    (* local *)
	    | 1 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Stamp.make_stamp_n (stamp_count + n), ptr, false)
		end

	    (* external *)
	    | 2 =>
		let
		  val (module, ptr) = decode_string ptr
                  val module = OS.Path.mkCanonical module
		  val (n, ptr) = input_opt_int(s, ptr)
		  val stamp_count = name_offsets module ptr
		in
		  (Stamp.make_stamp_n (stamp_count + n), ptr, false)
		end

	    | _ => raise CorruptFile 6
	  end

	fun decode_tyfun_id ptr =
	  let val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of

	      (* absolute - used for pervasives *)
	      0 =>
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n n, ptr)
		end

	    (* local *)
	    | 1 =>
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n (stamp_count + n), ptr)
		end

	    (* external *)
	    | 2 =>
		let
		  val (module, ptr) = decode_string ptr
                  val module = OS.Path.mkCanonical module
		  val (n, ptr) = input_opt_int(s, ptr)
		  val stamp_count = name_offsets module ptr
		in
		  (Stamp.make_stamp_n (stamp_count + n), ptr)
		end

	    | _ => raise CorruptFile 7
	  end

	fun decode_strname_id ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of

	      (* absolute - used for pervasives *)
	      0 =>
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n n, ptr)
		end

	    (* local *)
	    | 1 =>
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n (stamp_count + n), ptr)
		end

	    (* external *)
	    | 2 =>
		let
		  val (module, ptr) = decode_string ptr
                  val module = OS.Path.mkCanonical module
		  val (n, ptr) = input_opt_int(s, ptr)
		  val stamp_count = name_offsets module ptr
		in
		  (Stamp.make_stamp_n (stamp_count + n), ptr)
		end

	    | _ => raise CorruptFile 8
	  end

	fun decode_ol_tyvar ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      5 => (Ident.num_tyvar, ptr)
	    | 7 => (Ident.int_literal_tyvar, ptr)
	    | 8 => (Ident.real_tyvar, ptr)
	    | 9 => (Ident.real_literal_tyvar, ptr)
	    | 10 => (Ident.numtext_tyvar, ptr)
	    | 11 => (Ident.realint_tyvar, ptr)
	    | 12 => (Ident.word_literal_tyvar, ptr)
	    | 13 => (Ident.wordint_tyvar, ptr)
	    | _ => raise CorruptFile 17
	  end

	val dummy_var = Ident.VAR (Ident.Symbol.find_symbol "")

	fun decode_over_loaded ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	    val (tyvar, ptr) = decode_ol_tyvar ptr
	  in
	    case i of
	      1 => (Datatypes.UNARY (dummy_var, tyvar), ptr)
	    | 2 => (Datatypes.BINARY (dummy_var, tyvar), ptr)
	    | 3 => (Datatypes.PREDICATE (dummy_var, tyvar), ptr)
	    | _ => raise CorruptFile 9
	  end

	fun decode_map f g ptr orderfn =
	  let
	    val (assoc_list, ptr) = decode_rev_list s (input_pair f g) ptr
	  in
	    (NewMap.from_list' Ident.lab_lt assoc_list, ptr)
	  end

	val valenvs_so_far = ref 0
	val tyname_valenvs_so_far = ref 0
	val tynames_so_far = ref 0
	val meta_tynames_decoded_in_tree =
	  ref (NewMap.empty ((op<):int * int -> bool,op =))
	  : (int, Datatypes.Tyname ref)NewMap.map ref
	val meta_tynames_so_far = ref 0
	val dummy_tyname =
	  Datatypes.METATYNAME(ref(Datatypes.TYFUN(Datatypes.NULLTYPE, 0)), "",
			       0, ref false, ref Datatypes.empty_valenv,
			       ref false)
	val metatyvar_types_so_far = ref 0
	val meta_overloaded_types_so_far = ref 0
	val tyvar_types_so_far = ref 0
	val metarectype_types_so_far = ref 0
	val rectype_types_so_far = ref 0
	val funtype_types_so_far = ref 0
	val constype_types_so_far = ref 0
	val debruijn_types_so_far = ref 0
	val dummy_funtypescheme =
	  Datatypes.UNBOUND_SCHEME(Datatypes.FUNTYPE(Datatypes.NULLTYPE,
						     Datatypes.NULLTYPE),
				   NONE)
	val dummy_constypescheme =
	  Datatypes.UNBOUND_SCHEME(Types.int_type,
				   NONE)
	val strnames_so_far = ref 0

	fun makehashtable () = IntHashTable.new hash_size

	val strnamehashtable =        makehashtable()
	val metatyvarhashtable =      makehashtable()
	val metaoverloadedhashtable = makehashtable()
	val tyvarhashtable =          makehashtable()
	val metarectypehashtable =    makehashtable()
	val rectypehashtable =        makehashtable()
	val constypehashtable =       makehashtable()
	val debruijnhashtable =       makehashtable()
	val valenvhashtable =         makehashtable()
	val tynamevalenvhashtable =   makehashtable()
	val tynamehashtable =         makehashtable()
	val tyenv_table = ref(IntMap.empty : Datatypes.Tyenv IntMap.T)
	val tyenvs = ref 0

	fun I constructor (env,ptr) = (constructor env,ptr)

	fun decode_strname ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      1 => I Datatypes.STRNAME(decode_strname_id ptr)
	    | 2 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  if n=0 then
		    let
		      val n = (!strnames_so_far)+1
		      val _ = strnames_so_far := n
		      val (name, ptr) = decode_strname ptr
		      val strname = Datatypes.METASTRNAME(ref name)
		      val _ =
			IntHashTable.update(strnamehashtable, n, strname)
		    in
		      (strname, ptr)
		    end
		  else
		    (IntHashTable.lookup(strnamehashtable, n), ptr)
		end
	    | 3 => I Datatypes.NULLNAME(decode_strname_id ptr)
	    | _ => raise CorruptFile 10
	  end

	fun decode_tyfun ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      1 =>
		let
		  val (ty , ptr) = decode_type ptr
		  val (i, ptr) = input_opt_int(s, ptr)
		in
		  (Datatypes.TYFUN(ty, i), ptr)
		end
	    | 2 => I Datatypes.ETA_TYFUN (decode_tyname ptr)
	    | 3 =>
		let val (tyfunid, ptr) = decode_tyfun_id ptr
		in
		  (Datatypes.NULL_TYFUN(tyfunid,
					(ref(Datatypes.TYFUN(Datatypes.NULLTYPE
							     ,0)))),
		   ptr)
		end
	    | _ => raise CorruptFile 11
	  end

	and decode_typescheme ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      1 =>
		let
		  val (i, ptr) = input_opt_int(s, ptr)
		  val (ty, ptr) = decode_type ptr
		in
		  (Datatypes.SCHEME(i, (ty,NONE)), ptr)
		end
	    | 2 =>
		let val (ty, ptr) = decode_type ptr
		in (Datatypes.UNBOUND_SCHEME(ty,NONE), ptr)
		end
	    | 3 =>
		let val (over, ptr) = decode_over_loaded ptr
		in (Datatypes.OVERLOADED_SCHEME over, ptr)
		end
	    | _ => raise CorruptFile 12
	  end
	
	and decode_type ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      1 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = !metatyvar_types_so_far + 1
		      val _ = metatyvar_types_so_far := n
		      val (i, ptr) = input_opt_int(s, ptr)
		      val (ty, ptr) = decode_type ptr
		      val (b1, ptr) = decode_bool ptr
		      val (b2, ptr) = decode_bool ptr
		      val ty = Datatypes.METATYVAR(ref(i, ty,Datatypes.NO_INSTANCE), b1, b2)
		      val _ = IntHashTable.update (metatyvarhashtable, n, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup(metatyvarhashtable, i), ptr)
		end
	    | 2 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = !meta_overloaded_types_so_far + 1
		      val _ = meta_overloaded_types_so_far := n
		      val (ty, ptr) = decode_type ptr
		      val (tv, ptr) = decode_ol_tyvar ptr
		      val ty = Datatypes.META_OVERLOADED
			(ref ty, tv,
			 Ident.VAR (Ident.Symbol.find_symbol ""),
			 Info.Location.UNKNOWN)
		      val _ = IntHashTable.update (metaoverloadedhashtable, n, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup(metaoverloadedhashtable, i), ptr)
		end
	    | 3 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = (!tyvar_types_so_far)+1
		      val _ = tyvar_types_so_far := n
		      val (i, ptr) = input_opt_int(s, ptr)
		      val (tyvar, ptr) = decode_tyvar ptr
		      val ty = Datatypes.TYVAR(ref (i,Datatypes.NULLTYPE,
						    Datatypes.NO_INSTANCE), tyvar)
		      val _ = IntHashTable.update (tyvarhashtable, n, ty)
		    in
		      (ty, ptr)
		    end		
		  else
		    (IntHashTable.lookup(tyvarhashtable, i), ptr)
		end
	    | 4 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = !metarectype_types_so_far + 1
		      val _ = metarectype_types_so_far := n
		      val (i, ptr) = input_opt_int(s, ptr)
		      val (b1, ptr) = decode_bool ptr
		      val (ty, ptr) = decode_type ptr
		      val (b2, ptr) = decode_bool ptr
		      val (b3, ptr) = decode_bool ptr
		      val ty = Datatypes.METARECTYPE(ref(i, b1, ty, b2, b3))
		      val _ = IntHashTable.update (metarectypehashtable, n, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup(metarectypehashtable, i), ptr)
		end
	    | 5 =>
		let
		  val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = !rectype_types_so_far + 1
		      val _ = rectype_types_so_far := n
		      val (ty,ptr) =
			I Datatypes.RECTYPE (decode_map decode_lab
					     decode_type ptr Ident.lab_order)
		      val _ = IntHashTable.update (rectypehashtable, n, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup(rectypehashtable, i), ptr)
		end
	    | 6 =>
		let
		  val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val c = !funtype_types_so_far + 1
		      val _ = funtype_types_so_far := c
		      val (ty1, ptr) = decode_type ptr
		      val (ty2, ptr) = decode_type ptr
		      val ty = Datatypes.FUNTYPE(ty1, ty2)
		      val _ = IntHashTable.update(decfuntypehashtable,c, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup (decfuntypehashtable,i), ptr)
		end
	    | 7 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val n = !constype_types_so_far + 1
		      val _ = constype_types_so_far := n
		      val (the_list, ptr) = input_list(s, decode_type, ptr)
		      val (tyname, ptr) = decode_tyname ptr
		      val ty = Datatypes.CONSTYPE(the_list,tyname)
		      val _ = IntHashTable.update (constypehashtable, n, ty)
		    in
		      (ty, ptr)
		    end
		  else
		    (IntHashTable.lookup(constypehashtable, i), ptr)
		end
	    | 8 =>
		let val (i, ptr) = input_opt_int(s, ptr)
		in
		  if i = 0 then
		    let
		      val (i, ptr) = input_opt_int(s, ptr)
		      val (b1, ptr) = decode_bool ptr
		      val (b2, ptr) = decode_bool ptr
		      val ty = Datatypes.DEBRUIJN(i, b1, b2,NONE)
		      val n = (!debruijn_types_so_far)+1
		      val _ = debruijn_types_so_far := n
		      val _ = IntHashTable.update(debruijnhashtable, n, ty)
		    in
		      (ty, ptr)
		    end		
		  else
		    (IntHashTable.lookup(debruijnhashtable, i), ptr)
		end
	    | 9 => (Datatypes.NULLTYPE, ptr)
	    | _ => raise CorruptFile 13
	  end

	and decode_valenv ptr =
	  let
	    val (n, ptr) = input_opt_int(s, ptr)
	  in
	    if n=0 then
	      let
		val n = (!valenvs_so_far)+1
		val _ = valenvs_so_far := n
		val valenv : Datatypes.Valenv ref = ref(Datatypes.empty_valenv)
		val _ = IntHashTable.update(valenvhashtable, n, valenv)
	      in
                I (fn map => (valenv := Datatypes.VE (ref 0, map);
                              valenv))
                (input_newmap (s, decode_valid, decode_typescheme,
                               ptr, Ident.valid_lt, Ident.valid_eq))
	      end
	    else
	      let
		val (valenv,ptr) =
		  (IntHashTable.lookup(valenvhashtable, n), ptr)
	      in
		(valenv,ptr)
	      end
	  end

	and decode_dummy_scheme ptr =
	  let
	    val (n, ptr) = input_byte(s, ptr)
	  in
	    case n of
	      1 => (dummy_constypescheme, ptr)
	    | 2 => (dummy_funtypescheme, ptr)
	    | _ => raise CorruptFile 14
	  end

	and decode_dummy_valenv updatetynamehashtable ptr =
	  let
	    val (n, ptr) = input_opt_int(s, ptr)
	    val valenv = ref(Datatypes.VE(ref 0, NewMap.empty(Ident.valid_lt, Ident.valid_eq)))
	  in
	    updatetynamehashtable valenv;
	    dummy_valenvs := (n, valenv) :: !dummy_valenvs;
	    (valenv, ptr)
	  end

	and decode_dummy_valenv_no_update ptr =
	  decode_dummy_valenv (fn _ => ()) ptr

	and decode_tyname ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      1 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  if n = 0 then
		    let
		      val n = !tynames_so_far + 1
		      val _ = tynames_so_far := n
		      val (tyname_id, ptr, is_pervasive) =
			decode_tyname_id ptr
		      val pervasive_tyname =
			if is_pervasive then
			  find_pervasive_tyname tyname_id
			else
			  NONE
		      val (st, ptr) = decode_string ptr
		      val (i, ptr) = input_opt_int(s, ptr)
		      val (b, ptr) = (I ref o decode_bool) ptr
		      val is_abs = ref(false)
		      val (valenv, ptr) =
			(if !debug_variables then
			   decode_dummy_valenv
			   (fn valenv =>
			    let
			      val tyname =
				case pervasive_tyname of
				  SOME tyname => tyname
				| NONE =>
				    Datatypes.TYNAME
				    (tyname_id,st,i,b,valenv,
				     NONE,is_abs,
				     valenv, 0)
			    (* level is 0 since it is a topdec.
			     (see end of decode_type_basis fn) *)
			    in
			      IntHashTable.update (tynamehashtable, n, tyname)
			    end)
			 else decode_dummy_valenv_no_update) ptr
		      val (is_abs',ptr) = decode_bool ptr
		      val _ = is_abs := is_abs'
		      val tyname =
			case pervasive_tyname of
			  SOME tyname => tyname
			| NONE =>
			    Datatypes.TYNAME
			    (tyname_id,st,i,b,valenv,
			     NONE,
			     is_abs,valenv, 0)
		      (* level 0 for toplevel dec *)

		      val _ = IntHashTable.update (tynamehashtable, n, tyname)
		    in
		      (tyname, ptr)
		    end
		  else
		    (IntHashTable.lookup(tynamehashtable, n), ptr)
		end
	    | 2 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  if n = 0 then
		    let
		      val r = ref dummy_tyname
		      val tf = ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))
		      val next = (!meta_tynames_so_far)+1
		      val _ = meta_tynames_so_far := next
		      val _ =
			meta_tynames_decoded_in_tree :=
			NewMap.define(!meta_tynames_decoded_in_tree, next, r)
		      val ((tyfun,st,i,b,valenv,is_abs),ptr) =
			if !debug_variables then
			  let
			    val ((st,i,b,is_abs),ptr) =
			      input_quadruple
			      decode_string (fn ptr =>input_opt_int(s, ptr))
			      (I ref o decode_bool) (I ref o decode_bool)
			      ptr
			    val ((valenv,tyfun),ptr) =
			      input_pair
			      (decode_dummy_valenv
			       (fn valenv => r:=
				Datatypes.METATYNAME(tf,st,i,b,valenv,is_abs)))
			      decode_tyfun ptr
			  in
			    ((tyfun,st,i,b,valenv,is_abs),ptr)
			  end
			else
			  input_sixtuple
			  decode_tyfun decode_string
			  (fn ptr=>input_opt_int(s, ptr)) (I ref o decode_bool)
			  decode_dummy_valenv_no_update (I ref o decode_bool)
			  ptr
		      val tyname =Datatypes.METATYNAME(tf,st,i,b,valenv,is_abs)
		      val _ = tf := tyfun
		    in
		      (r := tyname;
		       (tyname, ptr))
		    end
		  else
		    (!(NewMap.apply (!meta_tynames_decoded_in_tree) n), ptr)
		end
	    | _ => raise CorruptFile 16
	  end

	and decode_runtime_env ptr =
	  let
	    val input_byte = fn ptr => input_byte(s, ptr)
	    fun input_spill_area ptr =
	      let
		val (i, ptr) = input_byte ptr
	      in
		(case i of
		   0 => RuntimeEnv.GC
		 | 1 => RuntimeEnv.NONGC
		 | 2 => RuntimeEnv.FP
		 | _ => raise BadInput"input_spill_area:decode_runtime_env:encapsulate", ptr)
	      end
	    val input_int = fn ptr => input_int(s, ptr)
	    val input_list = fn f=> fn ptr=> input_list(s,f,ptr)
	    val decode_spill =
	      fn ptr =>
	      I ref(
		    let
		      val (i, ptr) = input_byte ptr
		    in
		      case i of
			1 =>
			  let
			    val (j, ptr) = input_int ptr
			  in
			    (RuntimeEnv.OFFSET1 j, ptr)
			  end
		      | 2 =>
			  let
			    val (k, ptr) = input_spill_area ptr
			    val (j, ptr) = input_int ptr
			  in
			    (RuntimeEnv.OFFSET2(k, j), ptr)
			  end
		      | _ => raise BadInput"decode_spill:decode_runtime_env:encapsulate"
		    end)
	    fun decode_string ptr = input_sz_string(s, ptr)
	    fun decode_option decode ptr =
	      let val (i, ptr) = input_byte ptr
	      in
		case i of
		  1 => (NONE,ptr)
		| 2 => I SOME (decode ptr)
		| _ => raise BadInput"decode_option:encapsulate"
	      end
            fun decode_varinfo ptr =
	      let val (i, ptr) = input_byte ptr
	      in
		case i of
		  1 => (RuntimeEnv.NOVARINFO,ptr)
		| 2 =>
                    I RuntimeEnv.VARINFO
                    (input_triple
                     decode_string
                     (fn ptr =>
                      I (fn t =>
                         (ref t, ref (RuntimeEnv.RUNTIMEINFO
                                      (NONE,nil))))
                      (decode_type ptr))
                     (decode_option decode_spill)
                     ptr)
		| _ => raise BadInput"decode_varinfo:encapsulate"
	      end

	    val (i, ptr) = input_byte ptr
	  in
	    case i of
	      1 => I RuntimeEnv.APP(input_triple
				    decode_runtime_env decode_runtime_env
				    (decode_option input_int) ptr)
	    | 2 => (RuntimeEnv.EMPTY,ptr)
            (* Should this attempt to decode the FunInfo slot? *)
	    | 3 => I RuntimeEnv.FN(input_quadruple
				   decode_string decode_runtime_env
				   decode_spill (fn ptr => (RuntimeEnv.INTERNAL_FUNCTION,ptr))
				   ptr)
	    | 4 => I RuntimeEnv.LET
		(input_pair
		 (input_list
		  (input_pair
                   decode_varinfo
		   decode_runtime_env))
                 decode_runtime_env ptr)
	    | 5 => I RuntimeEnv.HANDLE(input_fivetuple
				       decode_runtime_env decode_spill
				       input_int input_int decode_runtime_env
				       ptr)
	    | 6 => I RuntimeEnv.RAISE(decode_runtime_env ptr)
	    | 7 => I RuntimeEnv.SELECT(input_pair input_int decode_runtime_env
				       ptr)
	    | 8 => I RuntimeEnv.STRUCT(input_list decode_runtime_env ptr)
	    | 9 =>
		I RuntimeEnv.SWITCH
		(input_quadruple decode_runtime_env decode_spill input_int
		 (input_list
		  (input_pair
		   (fn ptr =>
		    let
		      val (i, ptr) = input_byte ptr
		    in
		      case i of
			1 => I RuntimeEnv.CONSTRUCTOR(decode_string ptr)
		      | 2 => I RuntimeEnv.INT(decode_string ptr)
		      | 3 => I RuntimeEnv.REAL(decode_string ptr)
		      | 4 => I RuntimeEnv.STRING(decode_string ptr)
		      | 7 => I RuntimeEnv.CHAR(decode_string ptr)
		      | 8 => I RuntimeEnv.WORD(decode_string ptr)
		      | 5 => (RuntimeEnv.DYNAMIC,ptr)
		      | 6 => (RuntimeEnv.DEFAULT,ptr)
		      | _ => raise BadInput"decode_tag:decode_runtime_env:encapsulate"
		    end)
		   decode_runtime_env)) ptr)
	    | 10 => I RuntimeEnv.LIST(input_list decode_runtime_env ptr)
	    | 11 => (RuntimeEnv.BUILTIN,ptr)
	    | _ => raise BadInput"decode_runtime_env:decode_type_basis:encapsulate"
	  end

	fun decode_tystr ptr =
	  let
	    val (tyfun, ptr) = decode_tyfun ptr
	    val (valenv, ptr) = decode_valenv ptr
	  in
	    (Datatypes.TYSTR(tyfun, !valenv), ptr)
	  end

	fun decode_tyenv ptr =
	  let
	    val (i, ptr) = input_opt_int(s, ptr)
	    val table = !tyenv_table
	  in
	    if i = 0 then
	      let
		val (tyenv, ptr) =
		  input_newmap(s, decode_tycon, decode_tystr,
			       ptr, Ident.tycon_lt, Ident.tycon_eq)
		val tyenv = Datatypes.TE tyenv
		val envs = !tyenvs + 1
	      in
		tyenvs := envs;
		tyenv_table := IntMap.define(table, envs, tyenv);
		(tyenv, ptr)
	      end
	    else
	      (IntMap.apply'(table, i), ptr)
	  end

	fun decode_env ptr =
	  let
	    val (strenv, ptr) = decode_strenv ptr
	    val (tyenv, ptr) = decode_tyenv ptr
	    val (valenv, ptr) = decode_valenv ptr
	  in
	    (Datatypes.ENV(strenv, tyenv, !valenv), ptr)
	  end

	and decode_str ptr =
	  let
	    val (n, ptr) = input_opt_int(s, ptr)
	  in
	    case n of
	      0 =>
		let
		  val count = !strmap_count + 1
		  val _ = strmap_count := count
		  val (strname, ptr) = decode_strname ptr
		  val (env, ptr) = decode_env ptr
		  val str = Datatypes.STR(strname,ref NONE,env)
		in
		  strmap := IntMap.define(!strmap, count, str);
		  (str, ptr)
		end
	    | _ => (IntMap.apply'(!strmap, n), ptr)
	  end

	and decode_strenv ptr =
	  let
	    val (strenv, ptr) =
	      input_newmap(s, decode_strid, decode_str,
			   ptr, Ident.strid_lt, Ident.strid_eq)
	  in
	    (Datatypes.SE strenv, ptr)
	  end

	fun decode_nameset ptr =
	  let
	    val (tynames, ptr) = decode_rev_list s decode_tyname ptr
	    val (strnames, ptr) = decode_rev_list s decode_strname ptr
	  in
	    (Nameset.nameset_of_name_lists(tynames, strnames), ptr)
	  end

	fun decode_sigma ptr =
	  let
	    val (nameset, ptr) = decode_nameset ptr
	    val (str, ptr) = decode_str ptr
	  in
	    (BasisTypes.SIGMA(nameset, str), ptr)
	  end

	fun decode_sigenv ptr =
	  let
	    val (sigenv, ptr) =
	      input_newmap(s, decode_sigid, decode_sigma,
			   ptr, Ident.sigid_lt, Ident.sigid_eq)
	  in
	    (BasisTypes.SIGENV sigenv, ptr)
	  end

	fun decode_phi ptr =
	  let
	    val (nameset, ptr) = decode_nameset ptr
	    val (str, ptr) = decode_str ptr
	    val (sigma, ptr) = decode_sigma ptr
	  in
	    (BasisTypes.PHI(nameset, (str, sigma)), ptr)
	  end

	fun decode_funenv ptr =
	  let
	    val (funenv, ptr) =
	      input_newmap(s, decode_funid, decode_phi,
			   ptr, Ident.funid_lt, Ident.funid_eq)
	  in
	    (BasisTypes.FUNENV funenv, ptr)
	  end

	fun decode_int ptr = input_opt_int(s, ptr)

	fun decode_recipe ptr =
	  let
	    val (i, ptr) = input_byte(s, ptr)
	  in
	    case i of
	      0 => (Debugger_Types.NOP,ptr)
	    | 1 =>
		let val (arg,ptr) = input_pair decode_int decode_recipe ptr
		in (Debugger_Types.SELECT arg,ptr)
		end
	    | 2 =>
		let val (args,ptr) =
		  input_list(s, input_pair decode_string decode_recipe, ptr)
		in (Debugger_Types.MAKERECORD args,ptr)
		end
	    | 3 =>
		let val (arg,ptr) = decode_recipe ptr
		in (Debugger_Types.FUNARG arg,ptr)
		end
	    | 4 =>
		let val (arg,ptr) = decode_recipe ptr
		in (Debugger_Types.FUNRES arg,ptr)
		end
	    | 5 =>
		let val (arg,ptr) = input_pair decode_recipe decode_recipe ptr
		in (Debugger_Types.MAKEFUNTYPE arg,ptr)
		end
	    | 6 =>
		let val (arg,ptr) = input_pair decode_int decode_recipe ptr
		in (Debugger_Types.DECONS arg,ptr)
		end
	    | 7 =>
		let val (arg,ptr) =
		  input_pair (fn ptr => input_list(s, decode_recipe, ptr))
		  decode_tyname ptr
		in (Debugger_Types.MAKECONSTYPE arg,ptr)
		end
	    | 8 => (Debugger_Types.ERROR "Encapsulated error string",ptr)
	    | _ => raise BadInput"problems in decoding a recipe"
	  end

        fun decode_funinfo ptr =
          let
            fun foo ptr = input_list(s, input_pair decode_int decode_recipe, ptr)
            val (ty,ptr) = decode_type ptr
            val (is_leaf,ptr) = decode_bool ptr
            val (has_saved_arg,ptr) = decode_bool ptr
            val (annotations,ptr) = foo ptr
            val (runtime_env,ptr) = decode_runtime_env ptr
            val (is_exn,ptr) = decode_bool ptr
          in
            (Debugger_Types.FUNINFO
             {ty = ty,
              is_leaf = is_leaf,
	      has_saved_arg = has_saved_arg,
              annotations = annotations,
              runtime_env = runtime_env,
              is_exn = is_exn},
             ptr)
          end

	fun decode_debug decode_runtime_env ptr =
          let
            val (list,ptr) =
              input_list (s,
                          input_pair decode_string decode_funinfo,
                          ptr)
          in
            (Debugger_Types.debug_info_from_list list, ptr)
          end

	val (debug_variables, ptr) =
	  I (fn b =>
	     (debug_variables := b;b))
	  (decode_bool 0)
	val ((nameset,funenv,sigenv,env), ptr) =
	  if decode_debug_information andalso not debug_variables then
	    ((Nameset.empty_nameset(),
	      BasisTypes.FUNENV(NewMap.empty (fn _ => false,fn _ => true)),
	      BasisTypes.SIGENV(NewMap.empty (fn _ => false,fn _ => true)),
	      Datatypes.ENV
	      (Datatypes.SE(NewMap.empty (fn _ => false,fn _ => true)),
	       Datatypes.TE(NewMap.empty (fn _ => false,fn _ => true)),
	       Datatypes.empty_valenv)),
	    ptr)
	  else
	    input_quadruple
	    decode_nameset decode_funenv decode_sigenv decode_env ptr

	fun read_dummy_valenvs(map, ptr) =
	  let
	    val (count, ptr) = input_opt_int(s, ptr) (* Number of items *)
	    fun read_sub(0, res) = res
	      | read_sub(n, (map, ptr)) =
	      let
		val (i, ptr) = input_byte(s, ptr)
	      in
		case i of
		  1 =>
		    let
		      val (res, ptr) = input_pair decode_int decode_int ptr
		    in
		      read_sub(n-1, (IntMap.define'(map, res), ptr))
		    end
		| 2 =>
		    let
		      (* Here we read a new full valenv as well *)
		      val (res, ptr) = input_pair decode_int decode_int ptr
		      val (valenv, ptr) = decode_valenv ptr
		    in
		      read_sub(n-1, (IntMap.define'(map, res), ptr))
		    end
		| _ => raise CorruptFile 18
	      end

	    val (map, ptr) = read_sub(count, (map, ptr))
	    val (i, ptr) = input_byte(s, ptr) (* See if further lists to be read *)
	  in
	    case i of
	      1 => (map, ptr)
	    | 2 => read_dummy_valenvs(map, ptr)
	    | _ => raise CorruptFile 19
	  end
	val (dummy_valenv_map, ptr) = read_dummy_valenvs(IntMap.empty, ptr)

	fun fixup_valenv(n, ref_ve) =
	  let
	    val m = case IntMap.tryApply'(dummy_valenv_map, n) of
	      NONE => raise CorruptFile 17
	    | SOME m => m
	    val ve = !(IntHashTable.lookup(valenvhashtable, m))
	  in
	    ref_ve := ve
	  end
	val _ =
	  Lists.iterate
	  fixup_valenv
	  (!dummy_valenvs)

	val (debug_information,_) =
	  if debug_variables then
	    decode_debug decode_runtime_env ptr
	  else
	    if decode_debug_information then
	      decode_debug (fn ptr=>(RuntimeEnv.EMPTY,ptr)) ptr
	    else
	      (Debugger_Types.empty_information,ptr)

	(* Set level to 0 since it will be for a topdec *)
	val result = (BasisTypes.BASIS(0,nameset, funenv, sigenv, env),
		      debug_information)
      in
	result
      end handle
      MLWorks.String.Ord => raise TypeDecapError 1
    | MLWorks.String.Substring => raise TypeDecapError 2
    | NewMap.Undefined => raise TypeDecapError 3
    | BadInput m => raise BadInput(m ^ " (Failed during type decapsulation 2)")
    | IntHashTable.Lookup => raise TypeDecapError 4

    local
      (* Now we define input_info, input_all, and input_debug_info *)

      (* See lambda/environtypes.sml. a Top_Env is encoded as an
       * environment size, followed by the Fun_Env, then the
       * Env. FunEnvs and Envs use NewMap encodings. However, ValEnvs
       * occurring in Envs can be repeated, so are cached in a table. *)

      fun decode_lambda_env s =
	let
	  val decode_symbol = decode_symbol s
	  val decode_strid = decode_strid decode_symbol
	  val decode_funid = decode_funid decode_symbol
	  val decode_valid = decode_valid (decode_symbol,s)
	
	  (* keep a map of valenvs *)
	  val val_map = ref(IntMap.empty) :
	    (Ident.ValId, EnvironTypes.comp) NewMap.map IntMap.T ref
	  val val_size = ref 0
	
	  val (total_size, ptr) = input_opt_int(s, 0)
	
	  fun read_env ptr =
	    let
	      val (env_size, ptr) = input_opt_int(s, ptr)
		
	      fun read_field ptr =
		(* every field is either a FIELD or a PRIM *)
		(case input_byte(s, ptr) of
		   (0, ptr) =>
		     let val (offset, ptr) = input_opt_int(s, ptr)
		     in (EnvironTypes.FIELD{index = offset,
					    size = env_size}, ptr)
		     end
		 | (1, ptr) =>
		     let val (offset, ptr) = input_opt_int(s, ptr)
		     in (EnvironTypes.PRIM(Pervasives.decode offset), ptr)
		     end
		 | _ =>
		     raise BadInput"Decoding a field - got neither 1 nor 0")
		
	      fun decode_val_env ptr =
		case input_opt_int(s, ptr) of
		  (* if 0, we haven't seen it before *)
		  (0, ptr) =>
		    let
		      val (val_env, ptr) =
			input_newmap(s, decode_valid, read_field, ptr,
				     Ident.valid_lt, Ident.valid_eq)
		      val new_num = !val_size + 1
		    in
		      val_size := new_num;
		      val_map := IntMap.define(!val_map, new_num, val_env);
		      (val_env, ptr)
		    end
		(* otherwise, we have seen it before; look it up *)
		| (valnum, ptr) => (IntMap.apply'(!val_map, valnum), ptr)
		
	      (* the valenv precedes the strenv *)
	      val (v_env, ptr) = decode_val_env ptr
	      val (s_env, ptr) =
		input_newmap
		(s, decode_strid,
		 input_triple read_env read_field (fn ptr => (false,ptr)),
		 ptr, Ident.strid_lt, Ident.strid_eq)
	    in
	      (EnvironTypes.ENV(v_env, s_env), ptr)
	    end
	
	  fun read_functor_range ptr =
	    let
	      val (offset, ptr) = input_opt_int(s, ptr)
	      val (env, ptr) = read_env ptr
	    in
	      ((EnvironTypes.FIELD{index=offset, size=total_size}, env, false),
	       ptr)
	    end
	
	  val (fun_env, ptr) =
	    input_newmap(s, decode_funid, read_functor_range,
			 ptr, Ident.funid_lt, Ident.funid_eq)
	  val (env, _) = read_env ptr
	in
	  EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)
	end

      (* Now the parser environment, which is encoded in the obvious way *)

      fun decode_parser_env s =
	let
	  val fix_map = ref IntMap.empty :
            (Symbol.Symbol, ParserEnv.Fixity) NewMap.map IntMap.T ref
	  val fix_size = ref 0
	  val val_map = ref IntMap.empty : ParserEnv.pVE IntMap.T ref
	  val val_size = ref 0

	  val decode_symbol = decode_symbol s
	  val decode_strid = decode_strid decode_symbol
	  val decode_funid = decode_funid decode_symbol
	  val decode_sigid = decode_sigid decode_symbol
	  val decode_valid = decode_valid (decode_symbol,s)
	  val decode_rev_valid_list = decode_rev_list s decode_valid

	  fun decode_fixity ptr =
	    let val (fixity, ptr) = input_byte(s, ptr)
	    in
	      case fixity of
		0 =>
		  let val (prec, ptr) = input_byte(s, ptr)
		  in (ParserEnv.LEFT prec, ptr)
		  end
	      | 1 =>
		  let val (prec, ptr) = input_byte(s, ptr)
		  in (ParserEnv.RIGHT prec, ptr)
		  end
	      | 2 => (ParserEnv.NONFIX, ptr)
	      | _ => raise CorruptFile 2
	    end
	
	  fun decode_fix_env ptr =
	    let val (fixnum, ptr) = input_opt_int(s, ptr)
	    in
	      case fixnum of
		0 =>
		  let
		    val (fix_env, ptr) =
		      input_newmap(s, decode_symbol, decode_fixity,
				   ptr, Symbol.symbol_lt, Symbol.eq_symbol)
		    val new_num = !fix_size + 1
		  in
		    fix_size := new_num;
		    fix_map := IntMap.define(!fix_map, new_num, fix_env);
		    (fix_env, ptr)
		  end
	      | _ =>
		  (IntMap.apply'(!fix_map, fixnum), ptr)
	    end
	
	  fun error_fn _ = raise BadInput"Encapsulate.decode_val_env"
	
	  fun decode_val_env ptr =
	    let val (valnum, ptr) = input_opt_int(s, ptr)
	    in
	      case valnum of
		0 =>
		  let
		    val (val_env, ptr) = decode_rev_valid_list ptr
		    val val_env =
		      Lists.reducel (fn (pve, valid) =>
				     ParserEnv.addValId(error_fn, valid, pve))
		      (ParserEnv.empty_pVE, val_env)
		    val new_num = !val_size + 1
		  in
		    (val_size := new_num;
		     val_map := IntMap.define(!val_map, new_num, val_env);
		     (val_env, ptr))
		  end
	      | _ =>
		  (IntMap.apply'(!val_map, valnum), ptr)
	    end
	

          fun decode_tycon ptr =
            let
              val (sy, ptr) = decode_symbol ptr
            in
              (Ident.TYCON sy, ptr)
            end


	  fun read_parse_env ptr =
	    let
	      val (fix_env, ptr) = decode_fix_env ptr
	      val (val_env, ptr) = decode_val_env ptr
              val (tycon_env, ptr) =
                input_newmap(s, decode_tycon, decode_val_env,
                             ptr, Ident.tycon_lt,Ident.tycon_eq)
	      val (struct_env, ptr) =
		input_newmap(s, decode_strid, read_parse_env,
			     ptr, Ident.strid_lt,Ident.strid_eq)
	    in
	      (ParserEnv.E(ParserEnv.FE fix_env, val_env,
                           ParserEnv.TE tycon_env,
			   ParserEnv.SE struct_env),
	       ptr)
	    end
	

	  val (fun_env, ptr) =
	    input_newmap(s, decode_funid, read_parse_env,
			 0, Ident.funid_lt, Ident.funid_eq)
	  val (sig_env, ptr) =
	    input_newmap(s, decode_sigid,
                         input_pair read_parse_env
                              (fn ptr => input_list (s,decode_tycon,ptr)),
			 ptr, Ident.sigid_lt, Ident.sigid_eq)
	  val (parse_env, _) = read_parse_env ptr
	in
	  ParserEnv.B(ParserEnv.F fun_env, ParserEnv.G sig_env, parse_env)
	end

      (* Now the consistency information *)

      fun decode_cons s =
	let
	  fun time_from_ints(a, b) =
	    let
	      val high = Real.fromInt a * real_divisor
	      val low = Real.fromInt b
	    in
	      high + low
	    end

	  fun decode_time ptr =
	    let
	      val (a, ptr) = input_int(s, ptr)
	      val (b, ptr) = input_int(s, ptr)
	    in
	      (Time.fromReal(time_from_ints(a, b)), ptr)
	    end
	
	  fun decode_string ptr = input_sz_string(s, ptr)
	
	  fun decode_cons_pair ptr =
	    let
	      val (mod_name, ptr) = decode_string ptr
	      val (time, ptr) = decode_time ptr
	    in
	      ({mod_name = mod_name, time = time}, ptr)
	    end
	
	  val (result, _) =
	    input_list(s, decode_cons_pair, 0)
	in
	  case result
	  of [] => raise BadInput "Missing consistency information"
	  |  {mod_name, time} :: l =>
	    {mod_name = mod_name, time_stamp = time, consistency = l}
	end

      (* Now the file header *)

      fun decode_header header =
	let
	  val (magic,       ptr) = input_int(header, 0)
	  val (version,     ptr) = input_int(header, ptr)
	  val (code_offset, ptr) = input_int(header, ptr)
	  val (cons_size,   ptr) = input_int(header, ptr)
	  val (parser_size, ptr) = input_int(header, ptr)
	  val (type_size,   ptr) = input_int(header, ptr)
	  val (lambda_size, ptr) = input_int(header, ptr)
	  val (strings,     ptr) = input_int(header, ptr)
	  val (stamps,      ptr) = input_int(header, ptr)
	in
	  if magic = ObjectFile.GOOD_MAGIC then
	    if version = ObjectFile.OBJECT_FILE_VERSION then
	      {cons_size = cons_size, parser_size = parser_size,
	       type_size = type_size, lambda_size = lambda_size,
	       stamps = stamps,
	       strings = strings,
	       code_offset = code_offset}
	    else
	      raise VersionError version
	  else
	    raise BadInput "Corrupt object file (1)"
	end

      (* Now a function to actually read from a file *)
      fun checked_input(f, len) =
	let
	  val s = Byte.bytesToString(BinIO.inputN(f, len))
	in
	  if size s <> len then raise BadInput("Corrupt object file (2) " ^ Int.toString(size s) ^ " " ^ Int.toString len)
	  else s
	end
    in
      (* just input the consistency info and numbers of generative names *)

      fun input_info filename =
	let
	  val Error = BadInput("Corrupt object file (3): " ^ filename)
	  val file_handle =
	    BinIO.openIn filename
	    handle IO.Io{name, ...} =>
	      raise BadInput ("Io error in decapsulate: " ^ name)
	in
	  let
	    val header = checked_input(file_handle, ObjectFile.HEADER_SIZE)
	    val {cons_size, stamps, ...} =
	      decode_header header
	    val cons = checked_input(file_handle, cons_size)
	    val {mod_name, time_stamp, consistency} = decode_cons cons
	  (* This must be done before the close_in *)
	  (* Otherwise we end up trying to close files already closed *)
	  in
	    BinIO.closeIn file_handle;
	    {stamps = stamps,
	     mod_name = mod_name,
	     time_stamp = time_stamp,
	     consistency = consistency}
	  end handle
	  MLWorks.String.Ord => (BinIO.closeIn file_handle; raise Error)
	| Lists.Nth => (BinIO.closeIn file_handle; raise Error) (* I dont think this is necessary, see Log 1.66 *)
	| MLWorks.String.Substring => (BinIO.closeIn file_handle; raise Error)
	| NewMap.Undefined => (BinIO.closeIn file_handle; raise Error)
	| BadInput s => (BinIO.closeIn file_handle;
			 raise BadInput (s ^ ": " ^ filename))
	| IntHashTable.Lookup => (BinIO.closeIn file_handle; raise Error)
	| Time.Time => (BinIO.closeIn file_handle; raise Error)
	end

      (* Input the environment and everything else *)

      (*
       * Beware! The ordering of the inputs in the following function
       * is important. This function is written so that immediately
       * after decoding a string it goes out of scope, hence hopefully
       * avoiding sudden increases in heap size due to a number
       * of large live (but already decoded) strings.
       *)


      fun input_all filename =
	let
	  fun error s =
	    raise BadInput ("Corrupt object file (4): " ^ s ^ ": " ^ filename)
	  val file_handle =
	    BinIO.openIn filename
	    handle IO.Io{name, ...} =>
	      raise BadInput ("Io error in decapsulate: " ^ name)
	in
	  let
	    val
	      {cons_size, parser_size, type_size,
	       lambda_size, stamps, strings, ...} =
	      decode_header(checked_input(file_handle,
					  ObjectFile.HEADER_SIZE))
	    val _ = clear_string_map strings

	    val {time_stamp, mod_name, consistency} =
	      decode_cons (checked_input (file_handle, cons_size))

	    val result =
	      {consistency = consistency,
	       time_stamp  = time_stamp,
	       mod_name    = mod_name,
	       type_env    = (checked_input(file_handle, type_size)),
	       parser_env  = (checked_input(file_handle, parser_size)),
	       lambda_env  = (checked_input(file_handle, lambda_size)),
	       stamps = stamps}
	  in
	    BinIO.closeIn file_handle;
	    result
	  end handle
	  MLWorks.String.Ord => (BinIO.closeIn file_handle; error "ord")
	| Lists.Nth => (BinIO.closeIn file_handle; error "nth")
	| MLWorks.String.Substring => (BinIO.closeIn file_handle; error "substring")
	| NewMap.Undefined => (BinIO.closeIn file_handle; error "undefined")
	| BadInput s => (BinIO.closeIn file_handle;
			 raise BadInput (s ^ ": " ^ filename))
	| IntHashTable.Lookup => (BinIO.closeIn file_handle; error "lookup")
	| Time.Time => (BinIO.closeIn file_handle; error "Time")
	end

      fun input_debug_info{file_name, sub_modules} =
	let
	  fun error s =
	    raise BadInput ("Corrupt object file (4): " ^ s ^ ": " ^ file_name)
	  val file_handle =
	    BinIO.openIn file_name
	    handle IO.Io{name, ...} =>
	      raise BadInput ("Io error in decapsulate: " ^ name)
	in
	  let
	    val
	      {cons_size, parser_size, type_size,
	       lambda_size, stamps, strings, ...} =
	      decode_header(checked_input(file_handle,
					  ObjectFile.HEADER_SIZE))
	    val _ = clear_string_map strings

	    val _ = decode_cons(checked_input(file_handle, cons_size))
	    val type_env = (checked_input(file_handle, type_size))
	  in
	    BinIO.closeIn file_handle;
	    #2(decode_type_basis
	       {type_env=type_env,
		file_name=file_name,
		sub_modules=sub_modules,
		decode_debug_information=true,
		pervasive_env =
		Datatypes.ENV(Datatypes.SE(NewMap.empty' (op =)),
			      Datatypes.TE(NewMap.empty' (op =)),
			      Datatypes.empty_valenv)})
	  end handle
	  MLWorks.String.Ord => (BinIO.closeIn file_handle; error "ord")
	| Lists.Nth => (BinIO.closeIn file_handle; error "nth")
	| MLWorks.String.Substring => (BinIO.closeIn file_handle; error "substring")
	| NewMap.Undefined => (BinIO.closeIn file_handle; error "undefined")
	| BadInput s => (BinIO.closeIn file_handle;
			 raise BadInput (s ^ ": " ^ file_name))
	| IntHashTable.Lookup => (BinIO.closeIn file_handle; error "lookup")
	| Time.Time => (BinIO.closeIn file_handle; error "Time")
	end

      fun decode_all
	{parser_env,
	 lambda_env,
	 type_env,
	 file_name,
	 sub_modules,
	 decode_debug_information,
	 pervasive_env} =
	let
	  val (type_env, debug_info) =
	    decode_type_basis
	    {type_env=type_env,
	     file_name=file_name,
	     sub_modules=sub_modules,
	     decode_debug_information=decode_debug_information,
	     pervasive_env=pervasive_env}
	in
	  (decode_parser_env parser_env,
	   decode_lambda_env lambda_env, type_env, debug_info)
	end

      fun code_offset file_name =
	let
	  fun error s =
	    raise BadInput ("Corrupt object file (4): " ^ s ^ ": " ^ file_name)

	  val file_handle =
	    BinIO.openIn file_name
	    handle IO.Io{name, ...} =>
	      raise BadInput ("Io error in decapsulate: " ^ name)
	in
	  let
	    val
	      {code_offset, ...} =
	      decode_header(checked_input(file_handle,
					  ObjectFile.HEADER_SIZE))
	  in
	    BinIO.closeIn file_handle;
	    code_offset
	  end handle
	  MLWorks.String.Ord => (BinIO.closeIn file_handle; error "ord")
	| Lists.Nth => (BinIO.closeIn file_handle; error "nth")
	| MLWorks.String.Substring => (BinIO.closeIn file_handle; error "substring")
	| NewMap.Undefined => (BinIO.closeIn file_handle; error "undefined")
	| BadInput s => (BinIO.closeIn file_handle;
			 raise BadInput (s ^ ": " ^ file_name))
	| IntHashTable.Lookup => (BinIO.closeIn file_handle; error "lookup")
	| Time.Time => (BinIO.closeIn file_handle; error "Time")
	end

      fun input_code file_name =
	let
	  fun error s =
	    raise BadInput ("Corrupt object file (4): " ^ s ^ ": " ^ file_name)

	  val file_handle =
	    BinIO.openIn file_name
	    handle IO.Io{name, ...} =>
	      raise BadInput ("Io error in decapsulate: " ^ name)

	  fun read_byte _ =
	    case BinIO.input1 file_handle of
	      SOME elem => Word8.toInt elem
	    | NONE => error"read_byte failure"

	  fun ignore_byte _ = ignore(read_byte());

	  fun read_int _ =
	    let
	      val b1 = read_byte()
	      val b2 = read_byte()
	      val b3 = read_byte()
	      val b4 = read_byte()
	    in
	      Bits.orb(Bits.lshift(b1, 24),
		       Bits.orb(Bits.lshift(b2, 16),
				Bits.orb(Bits.lshift(b3, 8), b4)))
	    end
	
	  fun read_sized_string size =
	    Byte.bytesToString(BinIO.inputN(file_handle, size))

	  fun read_string() = read_sized_string(read_int())

	  fun read_extended_string() =
	    let
	      val sz = read_int()
	      val vec = BinIO.inputN(file_handle, sz-1)
	      val string = Byte.bytesToString vec
	    in
	      (case Bits.andb(size string, 3) of
		 0 => (ignore_byte(); ignore_byte(); ignore_byte(); ignore_byte())
	       | 1 => (ignore_byte(); ignore_byte(); ignore_byte())
	       | 2 => (ignore_byte(); ignore_byte())
	       | 3 => ignore_byte()
	       | _ => Crash.impossible "Encapsulate.read_extended_string");
		 string
	    end

	  fun read_element() =
	    let
	      val opcode = read_int()
	    in
	      if opcode = ObjectFile.OPCODE_REAL then
		let
		  val i = read_int()
		  val sz = read_int()
		  val r = read_sized_string(sz * 4)
		in
		  Code_Module.REAL(i, r)
		end
	      else
	      if opcode = ObjectFile.OPCODE_STRING then
		let
		  val i = read_int()
		  val s = read_extended_string()
		in
		  Code_Module.STRING(i, s)
		end
	      else
	      if opcode = ObjectFile.OPCODE_CODESET then
		let
		  val len = read_int()
		  val wordset_size = read_int()
		  fun read_names(res, n) =
		    if n <= 0 then
		      rev res
		    else
		      let
			val str = read_extended_string()
		      in
			read_names(str :: res, n-1)
		      end
		  val names = read_names([], len)
		  val interceptible = read_int()
		  fun read(w_list, leafs, intercepts, parms, n) =
		    if n <= 0 then
		      (rev w_list, rev leafs, rev intercepts, rev parms)
		    else
		      let
			val a_clos = read_int()
			val b_spills = read_int()
			val c_saves = read_int()
			val leaf = read_int() = 1
			val offset = read_int()
			val parm = read_int()
			val d_code = read_string()
		      in
			read({a_clos=a_clos, b_spills=b_spills, c_saves=c_saves, d_code=d_code} :: w_list,
			     leaf :: leafs, offset :: intercepts, parm :: parms, n-1)
		      end
		  val (w_list, leaf_list, offsets_list, parms_list) =
		    read([], [], [], [], len)
		in
		  Code_Module.WORDSET(Code_Module.WORD_SET
				      {a_names = names,
				       b = w_list,
				       c_leafs=leaf_list,
				       d_intercept=offsets_list,
				       e_stack_parameters=parms_list})
		end
	      else
	      if opcode = ObjectFile.OPCODE_EXTERNAL then
		let
		  val i = read_int()
		  val s = read_extended_string()
		in
		  Code_Module.EXTERNAL(i, s)
		end
	      else
		error"Unknown opcode"
	    end

	  fun read_elements(elts, n) =
	    if n <= 0 then rev elts else read_elements(read_element() :: elts, n-1)

	  fun decode_code(arg as (file_handle, offset)) =
	    let
	      val _ = checked_input arg
	      (* Skip the type info etc *)
	      val elements = read_int()
	      val real_objects = read_int()
	    in
	      Code_Module.MODULE(read_elements([], elements))
	    end

	in
	  let
	    val
	      {cons_size, parser_size, type_size,
	       lambda_size, stamps, strings, code_offset} =
	      decode_header(checked_input(file_handle,
					  ObjectFile.HEADER_SIZE))
	    val code = decode_code(file_handle, code_offset - ObjectFile.HEADER_SIZE)
	  in
	    BinIO.closeIn file_handle;
	    code
	  end handle
	  MLWorks.String.Ord => (BinIO.closeIn file_handle; error "ord")
	| Lists.Nth => (BinIO.closeIn file_handle; error "nth")
	| MLWorks.String.Substring => (BinIO.closeIn file_handle; error "substring")
	| NewMap.Undefined => (BinIO.closeIn file_handle; error "undefined")
	| BadInput s => (BinIO.closeIn file_handle;
			 raise BadInput (s ^ ": " ^ file_name))
	| IntHashTable.Lookup => (BinIO.closeIn file_handle; error "lookup")
	| Time.Time => (BinIO.closeIn file_handle; error "Time")
	end

    end

    (* Now the definition of clean_basis, which resets all the uniques
     * in a type basis *)

    local

      fun reset_refs(BasisTypes.BASIS(_, nameset, funenv, sigenv, env), value)=
	let
	  fun reset_map_range fun2 m =
	    NewMap.iterate (fun2 o #2) m
	  fun reset_newmap_range fun2 m = NewMap.iterate (fun2 o #2) m
	  fun reset_strnameid_map_range fun2 m =
	    Stamp.Map.iterate (fun2 o #2) m
	  fun reset_tynameid_map_range fun2 m =
	    Stamp.Map.iterate (fun2 o #2) m
	  fun reset_tyname_id n = ()
	  fun reset_strname_id n = ()
	  fun reset_strname(Datatypes.STRNAME s) = reset_strname_id s
	    | reset_strname(Datatypes.METASTRNAME s) = ()
	    | reset_strname(Datatypes.NULLNAME s) = reset_strname_id s
	
	  fun reset_valenv(Datatypes.VE(r, M)) =
	    let val n = !r
	    in
	      if n = value then
		()
	      else
		(r := value;
		 reset_newmap_range reset_typescheme M)
	    end
	
	  and reset_tyname(Datatypes.TYNAME(ti, _, _, _, ref ve,_,_,_,_)) =
	    (reset_tyname_id ti;
	     reset_valenv ve)
	    | reset_tyname(Datatypes.METATYNAME(ref tf, _, _, _, ref ve, _)) =
	      (reset_tyfun tf;
	       reset_valenv ve)
	
	  and reset_type(Datatypes.METATYVAR(ref(_, t,_), _, _)) = reset_type t
	    | reset_type(Datatypes.META_OVERLOADED{1=ref t,...}) = reset_type t
	    | reset_type(Datatypes.TYVAR _) = ()
	    | reset_type(Datatypes.METARECTYPE(ref(_,_,t,_,_))) = reset_type t
	    | reset_type(Datatypes.RECTYPE M) =
	      reset_map_range reset_type M
	    | reset_type(Datatypes.FUNTYPE(t1, t2)) =
	      (reset_type t1;
	       reset_type t2)
	    | reset_type(Datatypes.CONSTYPE(l, t)) =
	      (app reset_type l;
	       reset_tyname t)
	    | reset_type(Datatypes.DEBRUIJN _) = ()
	    | reset_type(Datatypes.NULLTYPE) = ()
	
	  and reset_typescheme(Datatypes.SCHEME(_, (t,_))) = reset_type t
	    | reset_typescheme(Datatypes.UNBOUND_SCHEME (t,_)) = reset_type t
	    | reset_typescheme(Datatypes.OVERLOADED_SCHEME _) = ()
	
	  and reset_tyfun(Datatypes.TYFUN(t, n)) = reset_type t
	    | reset_tyfun(Datatypes.ETA_TYFUN tn) = reset_tyname tn
	    | reset_tyfun(Datatypes.NULL_TYFUN tfi) = ()
	
	  and reset_tystr(Datatypes.TYSTR(tf, ve)) =
	    (reset_tyfun tf;
	     reset_valenv ve)
	
	  and reset_tyenv(Datatypes.TE M) =
	    reset_newmap_range reset_tystr M
	
	  and reset_str(Datatypes.STR(sn,_,e)) =
	    (reset_strname sn;
	     reset_env e)
	    | reset_str(Datatypes.COPYSTR((smap,tmap),str)) =
	      (reset_str str;
	       reset_strnameid_map_range reset_strname smap;
	       reset_tynameid_map_range reset_tyname tmap)
	
	  and reset_strenv(Datatypes.SE M) = reset_newmap_range reset_str M
	
	  and reset_env(Datatypes.ENV(se, te, ve)) =
	    (reset_strenv se;
	     reset_tyenv te;
	     reset_valenv ve)
	
	  and reset_sigma(BasisTypes.SIGMA(ns, s)) =
	    (reset_nameset ns;
	     reset_str s)
	
	  and reset_sigenv(BasisTypes.SIGENV M) =
	    reset_newmap_range reset_sigma M
	
	  and reset_phi(BasisTypes.PHI(ns, (s, sg))) =
	    (reset_nameset ns;
	     reset_str s;
	     reset_sigma sg)
	
	  and reset_funenv(BasisTypes.FUNENV M) =
	    reset_newmap_range reset_phi M
	
	  and reset_nameset ns =
	    (app reset_tyname (Nameset.tynames_of_nameset ns);
	     app reset_strname (Nameset.strnames_of_nameset ns))
	in
	  (reset_nameset nameset;
	   reset_funenv funenv;
	   reset_sigenv sigenv;
	   reset_env env)
	end
    in
      fun clean_basis basis =
	(reset_refs(basis, ~1);
	 reset_refs(basis, 0))
    end

  (* Now encodings. We're working towards a definition of the function
   * output_file, which takes type information, parser environment,
   * code, &c and writes it all out. First we define a bunch of
   * encoding functions for common types. *)

    (* a type for remembering lists of things to output.  We pass
     * around reversed lists of these objects, then output them together.
     * Optimised ints use this encoding to save bytes:
     * x < 254:		one byte
     * 254 <= x < 2^16: three bytes (254, x div 256, x mod 256)
     * 2^16 <= x : 	five bytes  (255, x) *)

    datatype DelayedEvaluation =
      STRING of string
      | SYMBOL of Symbol.Symbol
      | OPTINT of int
      | BYTE of int
      | INT of int

    fun output_byte i = BYTE i
    fun output_int i = INT i
    fun optimised_output_int i = OPTINT i

    fun encode_bool false = BYTE 0
      | encode_bool true  = BYTE 1

    (* now encodings for generally useful objects. Note that most
     * encoding functions pass around a list of completed encodings,
     * onto which the result is consed. *)

    fun encode_string(done, s) = STRING(s) :: done

    fun encode_list done f l =
      let
	fun rev_map (done, []) = done
	  | rev_map (done, x :: xs) = rev_map(f(done, x), xs)
      in
	rev_map(optimised_output_int(length l) :: done, l)
      end

    fun encode_newmap done f g m =
      let
	val sz = optimised_output_int(NewMap.size m)
      in
	NewMap.fold_in_rev_order
	(fn (done, a, b) => g(f(done, a), b)) (sz :: done, m)
      end

    fun encode_map done f g m =
      let
	val sz =
	  optimised_output_int(NewMap.size m)
      in
	NewMap.fold
	(fn (done, a, b) => g(f(done, a), b))
	(sz :: done, m)
      end

    (* Now encodings for the type system *)

    fun encode_symbol(done, sy) = SYMBOL(sy) :: done

    fun encode_valid(done, Ident.VAR sy) =
      encode_symbol(output_byte 0 :: done, sy)
      | encode_valid(done, Ident.CON sy) =
	encode_symbol(output_byte 1 :: done, sy)
      | encode_valid(done, Ident.EXCON sy) =
	encode_symbol(output_byte 2 :: done, sy)
      | encode_valid _ = Crash.impossible "TYCON':encode_valid:encapsulate"

    fun encode_lab(done, Ident.LAB lab) =
      encode_symbol(done, lab)

    fun encode_tyvar(done, Ident.TYVAR(tyvar, b1, b2)) =
      encode_bool b2 :: encode_bool b1 :: encode_symbol(done, tyvar)

    fun encode_ol_tyvar tyvar =
      if tyvar = Ident.num_tyvar then output_byte 5
      else if tyvar = Ident.int_literal_tyvar then output_byte 7
      else if tyvar = Ident.real_tyvar then output_byte 8
      else if tyvar = Ident.real_literal_tyvar then output_byte 9
      else if tyvar = Ident.numtext_tyvar then output_byte 10
      else if tyvar = Ident.realint_tyvar then output_byte 11
      else if tyvar = Ident.word_literal_tyvar then output_byte 12
      else if tyvar = Ident.wordint_tyvar then output_byte 13
      else case tyvar of
	Ident.TYVAR(sym, _, _) =>
	  Crash.impossible
	  ("Bad tyvar in overloaded type: " ^ Symbol.symbol_name sym)

    fun encode_over_loaded (Datatypes.UNARY (_, tv)) =
      [output_byte 1, encode_ol_tyvar tv]
      | encode_over_loaded (Datatypes.BINARY (_, tv)) =
	[output_byte 2, encode_ol_tyvar tv]
      | encode_over_loaded (Datatypes.PREDICATE (_, tv)) =
	[output_byte 3, encode_ol_tyvar tv]

    (* bigger and more complex type system objects are encoded by
     * subfunctions of output_file, below *)

    (* how many objects in this list of wordsets? *)

    local
      fun count_real_objects'(count, []) = count
	| count_real_objects'(count,
			      Code_Module.WORDSET(Code_Module.WORD_SET
						  {b=w_list, ...})
			      :: rest) =
	  count_real_objects'(count + length w_list, rest)
	| count_real_objects'(count, _ :: rest) =
	  count_real_objects'(count + 1, rest)
    in
      fun count_real_objects l = count_real_objects'(0,l)
    end

    (* Now our one big function for creating a .mo file : *)

    fun output_file debug_variables
      {filename, code, stamps, parser_env, lambda_env,
       type_basis, debug_info, require_list,
       mod_name, time_stamp, consistency} =
      let
	local
	  (* We buffer non-string I/O in a bytearray here. So we
	   * abstract all the actual I/O in this 'local'. *)

          val out_stream = BinIO.getOutstream(BinIO.openOut filename)
	  val (file_handle, buffer_mode) = BinIO.StreamIO.getWriter out_stream
	  val PrimIO.WR{writeVec, getPos, setPos, ...} = file_handle
          fun close() = BinIO.StreamIO.closeOut out_stream
	  val writeVec = valOf writeVec
	  exception WriteFailed
	  fun write s =
	    let
	      val wrote = writeVec{buf=Byte.stringToBytes s, i=0, sz=NONE}
	    in
	      if wrote <> size s then
		raise WriteFailed
	      else
		()
	    end
	  val bufsize = 4096
	  val buffer = Word8Array.array(bufsize, Byte.charToByte#"\000");
	  val bufpos = ref 0		(* next byte position in buffer *)
	  fun flush_buffer () =		(* call this before any I/O op *)
	    if !bufpos > 0 then
	      (write(Byte.unpackString(buffer, 0, SOME(!bufpos)));
	       bufpos := 0)
	    else
	      ()
	in
	  val getPos = valOf getPos
	  val setpos = valOf setPos
	  fun getpos () = (flush_buffer (); getPos ())
	  fun seek pos = (flush_buffer (); setpos pos)
	  fun write_byte i =
	    (if !bufpos >= bufsize
				then flush_buffer ()
			      else ();
			      Word8Array.update(buffer,!bufpos,Word8.fromInt i);
			      bufpos := (!bufpos)+1)
	  fun write_string s = (flush_buffer (); write s)

	  (* pad a string *)
	  fun write_extended_string s =
	    (flush_buffer();
	     write s;
	     case Bits.andb(size s, 3) of
	       0 => (write_byte 0; write_byte 0; write_byte 0; write_byte 0)
	     | 1 => (write_byte 0; write_byte 0; write_byte 0)
	     | 2 => (write_byte 0; write_byte 0)
	     | 3 => (write_byte 0)
	     | _ => Crash.impossible "Encapsulate.write_extended_string")
	
	  val close = fn _ => (flush_buffer(); close());
	end

	fun write_int i =
	  let
	    val b1 = Bits.andb(Bits.rshift(i, 24), 255)
	    val b2 = Bits.andb(Bits.rshift(i, 16), 255)
	    val b3 = Bits.andb(Bits.rshift(i,  8), 255)
	    val b4 = Bits.andb(i, 255)
	  in
	    write_byte b1; write_byte b2; write_byte b3; write_byte b4
	  end
	
	fun write_dummies 0 = ()
	  | write_dummies n = (write_int 0; write_dummies (n-1))
	
	fun write_opt_int i =
	  if i < 254 then
	    write_byte i
	  else if i < 65535 then
	    (write_byte 254;
	     write_byte (Bits.andb(Bits.rshift(i, 8), 255));
	     write_byte(Bits.andb(i, 255)))
	       else
		 (write_byte 255; write_int i)
		
	fun write_bool false = write_byte 0
	  | write_bool true  = write_byte 1
	
	fun write_sz_string s =
	  (write_opt_int(size s); write_string s)

	val total_strings = ref 1
	local
	  val id = ref 0
	  val encodeId = total_strings
	  val encodeMap = ref (NewMap.empty
			       ((op<):string*string->bool,(op=):string*string->bool))
	  fun present (_, old, new) = (id := old; old)
	  val combine = NewMap.combine present
	in
	  fun write_opt_string s =
	    let
	      val new = !encodeId
	    in
	      id := 0;
	      encodeMap := combine (!encodeMap, s, new);
	      if !id = 0 then
		(encodeId := new + 1; write_opt_int 0; write_sz_string s)
	      else
		write_opt_int (!id)
	    end
	end

	fun write_symbol sy =
	  write_opt_string(Symbol.symbol_name sy)
	
	fun do_output object =
	  let
	    fun out [] = ()
	      | out (INT(i)::rest) = (write_int i; out rest)
	      | out (BYTE(i)::rest) = (write_byte i; out rest)
	      | out (OPTINT(i)::rest) = (write_opt_int i; out rest)
	      | out (STRING(s)::rest) = (write_opt_string s; out rest)
	      | out (SYMBOL(sy)::rest) = (write_symbol sy; out rest)
	  in
	    out (rev object)
	  end
	
	fun write_list f l =
	  (write_opt_int(length l); app f l)
	
	fun write_pair f g (a, b) =
	  (ignore(f a); g b)
	
	fun write_triple f g h (a, b, c) =
	  (ignore(f a); ignore(g b); h c)
	
	fun write_quadruple f g h i (a, b, c, d) =
	  (ignore(f a); ignore(g b); ignore(h c); i d)
	
	fun write_fivetuple f g h i j (a, b, c, d, e) =
	  (ignore(f a); ignore(g b); ignore(h c); ignore(i d); j e)
	
	fun write_newmap f g m =
	  (write_opt_int(NewMap.size m);
	   NewMap.iterate_ordered (write_pair f g) m)
	
	fun write_intmap g m =
	  (write_opt_int(IntMap.size m);
	   IntMap.iterate_ordered (write_pair write_opt_int g) m)
	
	fun write_assoc f g a =
	  write_list (write_pair f g) a
	
	(* Now some type-system things *)

	fun write_valid (Ident.VAR sy) =
	  (write_byte 0; write_symbol sy)
	  | write_valid (Ident.CON sy) =
	    (write_byte 1; write_symbol sy)
	  | write_valid (Ident.EXCON sy) =
	    (write_byte 2; write_symbol sy)
	  | write_valid _ = Crash.impossible "TYCON':write_valid:encapsulate"
	
	fun write_sigid (Ident.SIGID sigid) = write_symbol sigid
	
	fun write_funid (Ident.FUNID funid) = write_symbol funid
	
	fun write_strid (Ident.STRID strid) = write_symbol strid
	
	fun write_tycon (Ident.TYCON tycon) = write_symbol tycon
	
	fun write_index (EnvironTypes.FIELD{index, ...}) = write_opt_int index
	  | write_index _ = Crash.impossible"write_index not FIELD"
	
	fun write_index' (EnvironTypes.FIELD{index, ...}) =
          (write_byte 0; write_opt_int index)
	  | write_index' (EnvironTypes.PRIM x) =
	    (write_byte 1; write_opt_int (Pervasives.encode x))
	  | write_index' _ = Crash.impossible"write_index' not FIELD OR PRIM"
	

	(* The parser environment *)

	fun write_parser_env(ParserEnv.B(ParserEnv.F fun_map,
					 ParserEnv.G sig_map,
					 parse_env)) =
	  let
	    fun hash [] = 0
	      | hash ((sy, _) :: _) = add_together_ords (Symbol.symbol_name sy)
		
	    val valhashtable = HashTable.new(hash_size,op =,hash)
	    val fixhashtable = HashTable.new(hash_size,op =,hash)
	
	    val valsize = ref 0
	    val fixsize = ref 0
	
	    fun write_fixity (ParserEnv.LEFT i) = (write_byte 0; write_byte i)
	      | write_fixity (ParserEnv.RIGHT i) = (write_byte 1; write_byte i)
	      | write_fixity (ParserEnv.NONFIX) = write_byte 2
		
            fun write_pve (ParserEnv.VE val_map) =
              let
                val val_list = NewMap.to_list val_map
                val n = HashTable.lookup_default(valhashtable, 0,
                                                 val_list)
                val _ =
                  if n = 0 then
                    let
                      val newsize = !valsize + 1
                    in
                      valsize := newsize;
                      HashTable.update(valhashtable, val_list, newsize);
                      write_opt_int 0;
                      write_list (write_valid o #2) val_list
                    end
                  else
                    write_opt_int n
              in
                ()
              end


	    fun write_pe (ParserEnv.E(ParserEnv.FE fix_map,
                                      pve,
                                      ParserEnv.TE tycon_map,
				      ParserEnv.SE struct_map)) =
	      let
		val fix_list = NewMap.to_list fix_map
		val fixnum =
		  HashTable.lookup_default(fixhashtable, 0, fix_list)
		val _ =
		  if fixnum = 0 then
		    let
		      val newsize = !fixsize + 1
		    in
		      fixsize := newsize;
		      HashTable.update(fixhashtable, fix_list, newsize);
		      write_opt_int 0;
		      write_assoc write_symbol write_fixity fix_list
		    end
		  else
		    write_opt_int fixnum
		
                val _ = write_pve pve
                val _ = write_newmap write_tycon write_pve tycon_map

	      in
		write_newmap write_strid write_pe struct_map
	      end
	  in
	    Timer.xtime
	    ("outputting parser env", !do_timings,
	     fn () =>
	     (write_newmap write_funid write_pe fun_map;
	      write_newmap write_sigid (write_pair write_pe (write_list write_tycon)) sig_map;
	      write_pe parse_env))
	  end

	(* The lambda environment *)
	
	fun write_lambda_env(EnvironTypes.TOP_ENV
			     (env as EnvironTypes.ENV(v, s),
			      EnvironTypes.FUN_ENV fun_env)) =
	  let
	    fun hash [] = 0
	      | hash ((valid, _) :: _) =
		let
		  val sy = case valid of
		    Ident.VAR sy => sy
		  | Ident.CON sy => sy
		  | Ident.EXCON sy => sy
		  | _ => Crash.impossible "TYCON':write_lambda_env:encapsulate"
		in
		  add_together_ords (Symbol.symbol_name sy)
		end	
	
	    val lambdavalhashtable = HashTable.new(hash_size,op =,hash)
	    val valsize = ref 0
	
	    val f_map = NewMap.to_list fun_env
	    val f_len = length f_map
	    val v_len = NewMap.size v
	    val s_len = NewMap.size s
	    val env_len = v_len + s_len
	
	    fun write_sub extra (EnvironTypes.ENV(v_map, s_map)) =
	      let
		val v_list = NewMap.to_list_ordered v_map
		val s_list = NewMap.to_list s_map
		val v_len = length v_list
		val s_len = length s_list
		val env_len = v_len + s_len + extra
		
		val vnum =
		  HashTable.lookup_default(lambdavalhashtable, 0,
					      v_list)
		val _ =
		  if vnum = 0 then
		    let
		      val newsize = !valsize + 1
		    in
		      valsize := newsize;
		      HashTable.update(lambdavalhashtable, v_list, newsize)
		    end
		  else
		    ()

	      in
		write_opt_int env_len;
		write_opt_int vnum;
		if vnum = 0 then write_assoc write_valid write_index' v_list
		else ();
		write_newmap
		write_strid
		(write_triple (write_sub 0) write_index' (fn _=> ())) s_map
	      end
	
	    fun do_ftr_range (field, env, _) =
	      (write_index field; write_sub 0 env)
	
	    val _ =
	      Timer.xtime
	      ("writing lambda env", !do_timings, fn () =>
	       (write_opt_int (f_len + env_len);
		write_newmap write_funid do_ftr_range fun_env;
		write_sub f_len env))
	  in
	    ()
	  end

	(* The type basis (this is the hard part...) *)
	
	fun write_type_basis(BasisTypes.BASIS(_, nameset, funenv, sigenv, env),
			     debug_info, sub_modules) =
	  let
	    val tyenv_table =
	      ref((NewMap.empty (Ident.tycon_lt,Ident.tycon_eq)) :
		  (Ident.TyCon,
		   ((Ident.TyCon, Datatypes.Tystr) NewMap.map * int) list)
		  NewMap.map)

	    val tyenvs = ref 0
	    val metatynamehashtable =
	      HashTable.new(hash_size,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
	    val tynamehashtable =
	      HashTable.new(hash_size,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
	    val funtypehashtable =
	      HashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
	    val constypehashtable =
	      HashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
	    val rectypehashtable =
	      HashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
	    val valenvhashtable =
	      HashTable.new(hash_size,Enc_Sub.tyname_valenv_same,
			       Enc_Sub.tyname_valenv_hash)

            local
              (* This is used to look find the module unique stamps are defined in *)
              (* To prevent later confusion, we filter out the modules that define no stamps *)
              val sub_modules_array =
                MLWorks.Internal.Array.arrayoflist
                (Lists.msort
                 (fn ((_, n : int, _), (_, n', _)) => n < n')
                 (List.filter (fn (_,start,extent:int) => extent > 0) sub_modules))

              fun find_module(stamp, first, last) =
                if first+1 = last then
                  let
                    val (module, start, extent) = MLWorks.Internal.Array.sub(sub_modules_array, first)
                  in
                    if stamp >= start andalso stamp < start + extent then
                      (module, stamp - start)
                    else
                      Crash.impossible"stamp_module"
                  end
                else
                  let
                    val mid = (first + last) div 2
                    val (module, start, extent) = MLWorks.Internal.Array.sub(sub_modules_array, mid)
                  in
                    if stamp < start then
                      find_module(stamp, first, mid)
                    else
                      find_module(stamp, mid, last)
                  end
            in
              fun stamp_module n = find_module(n, 0, MLWorks.Internal.Array.length sub_modules_array)
            end

	    val strnames_encoded = ref [] : Datatypes.Strname ref list ref

	    fun strname_hash(Datatypes.STRNAME id) = Stamp.stamp id
	      | strname_hash(Datatypes.NULLNAME id) = Stamp.stamp id
	      | strname_hash(Datatypes.METASTRNAME(ref s)) = strname_hash s
		
	    val strname_enc_hashtable =
	      HashTable.new(hash_size, op=, strname_hash)
	    val strname_enc_count = ref 0
	
	    val valenv_no = ref 0 (* For encoding top level valenvs *)
	    val dummy_valenv_no = ref 0 (* For encoding embedded valenvs (ie in tynames) *)
	    val dummy_valenv_list = ref([] : (int * Datatypes.Valenv) list)
	    val metatyvar_types_encoded =
	      ref [] : ((int * Datatypes.Type * Datatypes.Instance) ref
			* bool * bool) list ref
	    val meta_overloaded_types_encoded = ref [] : Datatypes.Type ref list ref
	    val tyvar_types_encoded = ref [] : (int * Ident.TyVar) list ref
	    val metarectype_types_encoded =
	      ref [] : (int * bool * Datatypes.Type * bool * bool) ref list ref
	    val rectype_types_encoded = ref [] : Datatypes.Type list ref
	    val funtype_types_encoded =
	      ref [] : (Datatypes.Type * Datatypes.Type) list ref
	    val constype_types_encoded = ref [] : Datatypes.Type list ref
	    val debruijn_types_encoded = ref [] : (int * bool * bool) list ref
	    val meta_tynames_encoded = ref [] : Datatypes.Tyname list ref
	    val tyname_valenvs_encoded = ref [] : int ref list ref
	    val meta_tyname_count = ref 0
	    val tyname_count = ref 0
	    val valenv_tyname_count = ref 0
	    val funtype_count = ref 0
	    val constype_count = ref 0
	    val rectype_count = ref 0
	
	    fun encode_tyname_id (done, n) =
	      let val id = Stamp.stamp n
	      in
		if id < Basis.pervasive_stamp_count then
		  optimised_output_int id :: output_byte 0 :: done
		else
		  let
		    val (module,id') = stamp_module id
		  in
		    if module = "" then
		      optimised_output_int id' :: output_byte 1 :: done
		    else
		      optimised_output_int id' ::
		      encode_string (output_byte 2 :: done, module)
		  end
	      end
	
	    fun write_strname_id n =
	      let val id = Stamp.stamp n
	      in	
		if id < Basis.pervasive_stamp_count then
		  (write_byte 0; write_opt_int id)
		else
		  let val (module,id') = stamp_module id
		  in
		    if module = "" then
		      (write_byte 1; write_opt_int id')
		    else
		      (write_byte 2; write_opt_string module;
		       write_opt_int id')
		  end
	      end
	
	    fun encode_tyfun_id (done, n) =
	      let val id = Stamp.stamp n
	      in	
		if id < Basis.pervasive_stamp_count then
		  optimised_output_int id :: output_byte 0 :: done
		else
		  let val (module,id') = stamp_module id
		  in
		    if module = "" then
		      optimised_output_int id' :: output_byte 1 :: done
		    else
		      optimised_output_int id' ::
		      encode_string (output_byte 2 :: done, module)
		  end
	      end
	
	    fun write_strname (Datatypes.STRNAME s) =
	      (write_byte 1; write_strname_id s)
	      | write_strname (Datatypes.METASTRNAME s) =
		let
		  fun es' (h::t) =
		    if h = s then length t + 1 else es' t
		    | es' [] =
		      (strnames_encoded := (s::(!strnames_encoded)); 0)
		  val n = es'(!strnames_encoded)
		in
		  write_byte 2; write_opt_int n;
		  if n = 0 then write_strname (!s) else ()
		end
	      | write_strname (Datatypes.NULLNAME s) =
		(write_byte 3; write_strname_id s)
		
	    fun scheme_type scheme =
	      case Enc_Sub.type_from_scheme scheme of
		Datatypes.CONSTYPE _ => 1
	      | Datatypes.NULLTYPE => 1
	      | Datatypes.FUNTYPE _ => 2
	      | _ => Crash.impossible"encode_fun_or_cons"
		
	    fun encode_fun_or_cons(done, scheme) =
	      output_byte(scheme_type scheme) :: done

	    fun encode_valenv(done, Datatypes.VE(r, M)) =
	      let
		val n = !r
		val done = optimised_output_int n :: done
	      in
		if n = 0 then
		  let
		    val m = !valenv_no + 1
		  in
		    (valenv_no := m;
		     r := m;
		     encode_newmap done encode_valid encode_typescheme M)
		  end
		else done
	      end

	    and encode_dummy_valenv(done, ve) =
	      let
		val n = !dummy_valenv_no + 1
	      in
		dummy_valenv_list := (n, ve) :: !dummy_valenv_list;
		dummy_valenv_no := n;
		optimised_output_int n :: done
	      end

	    and encode_tyname(done,
			      tyn as Datatypes.TYNAME(ti, s, n, ref b,
						      ref ve,_,ref is_abs,
                                                      _,_)) =
	      let
		val pos = HashTable.lookup_default(tynamehashtable, 0, tyn)
		val done = optimised_output_int pos :: output_byte 1 :: done
	      in
		if pos = 0 then
		  let
		    val c = !tyname_count + 1
		    val _ = tyname_count := c
		    val _ = HashTable.update(tynamehashtable,tyn, c)
		  in
		    encode_bool is_abs ::
		    encode_dummy_valenv
		    (encode_bool b :: optimised_output_int n ::
		     encode_string(encode_tyname_id(done, ti), s),
		     ve)
		  end
		else
		  done
	      end
	
	      | encode_tyname(done,
			      tyn as Datatypes.METATYNAME(ref tf, s, n, ref b,
							  ref ve,ref is_abs)) =
		let
		  val pos = HashTable.lookup_default
		    (metatynamehashtable, 0, tyn)
		  val done = optimised_output_int pos :: output_byte 2 :: done
		in
		  if pos = 0 then
		    let
		      val c = !meta_tyname_count + 1
		      val _ = meta_tyname_count := c
		      val _ = HashTable.update(metatynamehashtable,tyn, c)
		    in
		      if debug_variables then
			encode_tyfun(encode_dummy_valenv
				     (encode_bool is_abs ::
				      encode_bool b ::
				      optimised_output_int n ::
				      encode_string(done, s),ve),
				     tf)
		      else
			encode_bool is_abs ::
			(encode_dummy_valenv(encode_bool b ::
					     optimised_output_int n ::
					     encode_string(encode_tyfun
							   (done, tf), s),
					     ve))
		    end
		  else
		    done
		end
	
	    and write_runtime_env env =
	      let
		fun write_spill_area RuntimeEnv.GC = write_byte 0
		  | write_spill_area RuntimeEnv.NONGC = write_byte 1
		  | write_spill_area RuntimeEnv.FP = write_byte 2

		fun write_spill (ref (RuntimeEnv.OFFSET1 spill)) =
		    (write_byte 1; write_int spill)
		  | write_spill (ref (RuntimeEnv.OFFSET2(area, spill))) =
		    (write_byte 2; write_spill_area area; write_int spill)
		fun write_option _ NONE = write_byte 1
		  | write_option write_object (SOME object) =
		    (write_byte 2;write_object object)
		fun write_tag (RuntimeEnv.CONSTRUCTOR s) =
		  (write_byte 1;write_sz_string s)
		  | write_tag (RuntimeEnv.INT s) =
		    (write_byte 2;write_sz_string s)
		  | write_tag  (RuntimeEnv.REAL s) =
		    (write_byte 3;write_sz_string s)
		  | write_tag (RuntimeEnv.STRING s) =
		    (write_byte 4;write_sz_string s)
		  | write_tag (RuntimeEnv.CHAR s) =
		    (write_byte 7;write_sz_string s)
		  | write_tag (RuntimeEnv.WORD s) =
		    (write_byte 8;write_sz_string s)
	          | write_tag RuntimeEnv.DYNAMIC = write_byte 5
		  | write_tag RuntimeEnv.DEFAULT = write_byte 6
		fun write_runtime_env(RuntimeEnv.APP(env)) =
		  (write_byte 1;
		   write_triple write_runtime_env write_runtime_env
		   (write_option write_int) env)
		  | write_runtime_env(RuntimeEnv.EMPTY) = write_byte 2
		  | write_runtime_env(RuntimeEnv.FN(env)) =
		    (write_byte 3;
		     write_quadruple write_sz_string write_runtime_env
		     write_spill (fn _ => ()) env)
		  | write_runtime_env(RuntimeEnv.LET(env as (env1,env2))) =
		    (case env2 of
		       RuntimeEnv.LET([env2],env3) =>
			 write_runtime_env(RuntimeEnv.LET(env1@@[env2],env3))
		     | _ =>
			 (write_byte 4;
			  write_pair
			  (write_list
                           (write_pair
                            (fn RuntimeEnv.NOVARINFO =>
                             write_byte 1
                           | RuntimeEnv.VARINFO info =>
                               (write_byte 2;
                                write_triple
                                write_sz_string
                                (fn (ref ty,_) =>
                                 do_output(encode_type([],ty)))
                                (write_option write_spill)
                                info))
                            write_runtime_env))
			  write_runtime_env env))
		  | write_runtime_env(RuntimeEnv.HANDLE(env)) =
		    (write_byte 5;
		     write_fivetuple write_runtime_env write_spill
		     write_int write_int write_runtime_env env)
		  | write_runtime_env(RuntimeEnv.RAISE(env)) =
		    (write_byte 6;write_runtime_env env)
		  | write_runtime_env(RuntimeEnv.SELECT(env)) =
		    (write_byte 7;
		     write_pair write_int
		     write_runtime_env env)
		  | write_runtime_env(RuntimeEnv.STRUCT(envs)) =
		    (write_byte 8;
		     write_list write_runtime_env envs)
		  | write_runtime_env(RuntimeEnv.SWITCH(envs)) =
		    (write_byte 9;
		     write_quadruple write_runtime_env write_spill write_int
		     (write_list
		      (write_pair write_tag write_runtime_env)) envs)
		  | write_runtime_env(RuntimeEnv.LIST(envs)) =
		    (write_byte 10;
		     write_list write_runtime_env envs)
		  | write_runtime_env(RuntimeEnv.BUILTIN) = write_byte 11
	      in
		write_runtime_env env
	      end
	
	    and encode_type(done,
			    Datatypes.METATYVAR(arg as (ref(n, t,_), b1, b2)))=
	      let
		fun et'(h::t) = if h = arg then length t + 1
				else et' t
		  | et' [] =
		    (metatyvar_types_encoded :=
		     (arg::(!metatyvar_types_encoded)); 0)
		val pos = et'(!metatyvar_types_encoded)
		val done = optimised_output_int pos :: output_byte 1 :: done
	      in
		if pos = 0 then
		  encode_bool b2 :: encode_bool b1 ::
		  encode_type(optimised_output_int n :: done, t)
		else
		  done
	      end
	      | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t,
							    tv, _, _)) =
		let
		  fun et'(h::t) = if h = arg then length t + 1
				  else et' t
		    | et' [] =
		      (meta_overloaded_types_encoded :=
		       (arg::(!meta_overloaded_types_encoded)); 0)
		  val pos = et'(!meta_overloaded_types_encoded)
		  val done = optimised_output_int pos :: output_byte 2 :: done
		in
		  if pos = 0 then
		    encode_ol_tyvar tv :: encode_type(done, t)
		  else
		    done
		end
	      | encode_type(done, Datatypes.TYVAR(ref (n,_,_), t)) =
		let
		  fun et'((n', t')::tl) =
		    if  n = n' andalso t =  t' then
		      length tl + 1
		    else et' tl
		    | et' [] =
		      (tyvar_types_encoded := ((n, t)::
					       (!tyvar_types_encoded)); 0)
		  val pos = et'(!tyvar_types_encoded)
		  val done = optimised_output_int pos :: output_byte 3 :: done
		in
		  if pos = 0 then
		    encode_tyvar(optimised_output_int n :: done, t)
		  else
		    done
		end	
	      | encode_type(done,
			    Datatypes.METARECTYPE(arg as ref(n, b1, t,
							     b2, b3))) =
		let
		  fun et'(h::t) = if h = arg then length t + 1
				  else et' t
		    | et' [] =
		      (metarectype_types_encoded :=
		       (arg::(!metarectype_types_encoded)); 0)
		  val pos = et'(!metarectype_types_encoded)
		  val done = optimised_output_int pos :: output_byte 4 :: done
		in
		  if pos = 0 then
		    encode_bool b3 :: encode_bool b2 ::
		    encode_type(encode_bool b1 :: optimised_output_int n ::
				done, t)
		  else
		    done
		end
	      | encode_type(done, arg as Datatypes.RECTYPE M) =
		let
		  val pos =
		    HashTable.lookup_default
		    (rectypehashtable, 0, arg)
		  val done = optimised_output_int pos :: output_byte 5 :: done
		in
		  if pos = 0 then
		    let
		      val c = !rectype_count + 1
		      val _ = rectype_count := c
		      val _ = if debug_variables then ()
			      else HashTable.update(rectypehashtable,arg, c)
		    in
		      encode_map done encode_lab encode_type M
		    end
		  else
		    done
		end
	      | encode_type(done,
			    full_arg as Datatypes.FUNTYPE(arg as (t1, t2))) =
		let
		  val pos =
		    HashTable.lookup_default
		    (funtypehashtable, 0, full_arg)
		
		  val done = optimised_output_int pos :: output_byte 6 :: done
		in
		  if pos = 0 then
		    let
		      val c = !funtype_count + 1
		      val _ = funtype_count := c
		      val _ = if debug_variables then ()
			      else HashTable.update(funtypehashtable,
						       full_arg, c)
		    in
		      encode_type(encode_type(done, t1), t2)
		    end
		  else
		    done
		end
	      | encode_type(done, arg as Datatypes.CONSTYPE(l, t)) =
		let
		  val pos =
		    HashTable.lookup_default
		    (constypehashtable, 0, arg)
		  val done = optimised_output_int pos :: output_byte 7 :: done
		in
		  if pos = 0 then
		    let
		      val c = !constype_count + 1
		      val _ = constype_count := c
		      val _ = if debug_variables then ()
			      else HashTable.update(constypehashtable,
						       arg, c)
		    in
		      encode_tyname(encode_list done encode_type l, t)
		    end
		  else
		    done
		end
	      | encode_type(done, Datatypes.DEBRUIJN(arg as (n, b1, b2,_))) =
		let
		  fun et'(h::t) = if h = (n,b1,b2) then length t + 1
				  else et' t
		    | et' [] =
		      (debruijn_types_encoded :=
		       ((n,b1,b2)::(!debruijn_types_encoded)); 0)
		  val pos = et'(!debruijn_types_encoded)
		  val done = optimised_output_int pos :: output_byte 8 :: done
		in
		  if pos = 0 then
		    encode_bool b2 :: encode_bool b1 ::
		    optimised_output_int n :: done
		  else
		    done
		end
	      | encode_type(done, Datatypes.NULLTYPE) = output_byte 9 ::
		done
		
	    and encode_typescheme(done, Datatypes.SCHEME(n, (t,_))) =
	      encode_type(optimised_output_int n :: output_byte 1 :: done, t)
	    | encode_typescheme(done, Datatypes.UNBOUND_SCHEME (t,_)) =
	      encode_type(output_byte 2 :: done, t)
	      | encode_typescheme(done, Datatypes.OVERLOADED_SCHEME ov) =
		encode_over_loaded ov @@ (output_byte 3 :: done)
		
	    and encode_tyfun(done, tyfun as Datatypes.TYFUN(t, n)) =
	      optimised_output_int n :: encode_type(output_byte 1 :: done, t)
	      | encode_tyfun(done, Datatypes.ETA_TYFUN tn) =
		encode_tyname(output_byte 2 :: done, tn)
	      | encode_tyfun(done, Datatypes.NULL_TYFUN (tfi,_)) =
		encode_tyfun_id(output_byte 3 :: done, tfi)
		
	    fun write_tystr (Datatypes.TYSTR(tf, ve)) =
	      do_output(encode_valenv(encode_tyfun([], tf), ve))
	
	    fun scheme_eq(scheme1, scheme2) =
	      case scheme1 of
		Datatypes.SCHEME(i, (ty,_)) =>
		  (case scheme2 of
		     Datatypes.SCHEME(i', (ty',_)) =>
		       i = i' andalso Types.type_eq(ty, ty', true, false)
		   | _ => false)
	      | Datatypes.UNBOUND_SCHEME (ty,_) =>
		  (case scheme2 of
		     Datatypes.UNBOUND_SCHEME (ty',_) =>
		       Types.type_eq(ty, ty', true, false)
		   | _ => false)
	      | Datatypes.OVERLOADED_SCHEME ov =>
		  (case scheme2 of
		     Datatypes.OVERLOADED_SCHEME ov' => ov = ov'
		   | _ => false)
		
	    fun ve_eq(Datatypes.VE(_, map1), Datatypes.VE(_, map2)) =
	      NewMap.eq (*Scheme.type*) scheme_eq (map1, map2)
	
	    fun pair_eq(eq1, eq2) =
	      fn ((a, b), (a', b')) => eq1(a, a') andalso eq2(b, b')
	
	    fun tystr_eq(Datatypes.TYSTR a, Datatypes.TYSTR b) =
	      pair_eq(Types.tyfun_eq, ve_eq) (a, b)
	
	    val tyenv_eq = NewMap.eq tystr_eq
	
	    fun str_eq(Datatypes.STR(sn, _, env),
		       Datatypes.STR(sn', _, env')) =
	      Strnames.strname_eq(sn, sn') andalso env_eq(env, env')
	      | str_eq _ = Crash.impossible"str_eq on COPYSTR"
		
	    and env_eq(Datatypes.ENV(Datatypes.SE se, Datatypes.TE te, ve),
		       Datatypes.ENV(Datatypes.SE se', Datatypes.TE te', ve'))=
	      NewMap.eq str_eq (se, se') andalso
	      tyenv_eq (te, te') andalso ve_eq (ve, ve')
	
	    datatype 'a option = YES of 'a | NO
	
	    fun eq_assoc eq_fun =
	      let
		fun eq_elt elt =
		  let
		    fun try [] = NO
		      | try ((dom, ran) :: xs) =
			if eq_fun(elt, dom) then
			  YES ran
			else
			  try xs
		  in
		    try
		  end
	      in
		eq_elt
	      end
	
	    fun write_tyenv (Datatypes.TE m) =
	      let
		val tycon =
		  case NewMap.domain_ordered m of
		    tycon :: _ => tycon
		  | _ => Ident.TYCON(Symbol.find_symbol"")
		val table = !tyenv_table
		val envs = !tyenvs + 1
		val i = case NewMap.tryApply'(table, tycon) of
		  SOME list =>
		    (case eq_assoc tyenv_eq m list of
		       YES i => i
		     | NO =>
			 (tyenvs := envs;
			  tyenv_table := NewMap.define(table, tycon,
						       (m, envs) :: list);
			  0))
		| _ =>
		    (tyenvs := envs;
		     tyenv_table := NewMap.define(table, tycon, [(m, envs)]);
		     0)
	      in
		write_opt_int i;
		if i = 0 then
		  write_newmap write_tycon write_tystr m
		else
		  ()
	      end
	
	    fun str_hash(Datatypes.STR{1 = sn, ...}) = strname_hash sn
	      | str_hash(Datatypes.COPYSTR _) =
		Crash.impossible"str_hash on COPYSTR"
		
	    val strhashtable = HashTable.new(hash_size, str_eq, str_hash)
	    val strhashtable_count = ref 0
	
	    fun write_str(str as Datatypes.STR(sn,_,e)) =
	      (case HashTable.lookup_default(strhashtable, 0, str) of
		 0 =>
		   let
		     val count = !strhashtable_count + 1
		   in
		     strhashtable_count := count;
		     HashTable.update(strhashtable, str, count);
		     write_opt_int 0;
		     write_strname sn; write_env e
		   end
	       | n => write_opt_int n)
	      | write_str(Datatypes.COPYSTR((smap, tmap), str)) =
		write_str(Env.str_copy (str,smap,tmap))
		
	    and write_strenv (Datatypes.SE m) =
	      write_newmap write_strid write_str m
	
	    and write_env (Datatypes.ENV(se, te, ve)) =
	      (write_strenv se; write_tyenv te;
	       do_output(encode_valenv([], ve)))
	
	    fun write_nameset ns =
	      (do_output(encode_list []
			 encode_tyname (Nameset.tynames_of_nameset ns));
	       write_list write_strname (Nameset.strnames_of_nameset ns))
	
	    fun write_sigma (BasisTypes.SIGMA(ns, s)) =
	      (write_nameset ns; write_str s)
	
	    fun write_sigenv (BasisTypes.SIGENV M) =
	      write_newmap write_sigid write_sigma M
	
	    fun write_phi (BasisTypes.PHI(ns, (s, sg))) =
	      (write_nameset ns; write_str s; write_sigma sg)
	
	    fun write_funenv (BasisTypes.FUNENV M) =
	      write_newmap write_funid write_phi M
	
	    fun write_dummy_valenv_element(n, ve as Datatypes.VE(ve_ref as ref m, _)) =
	      if m = 0 then
		let
		  val done = encode_valenv([], ve)
		  val m = !ve_ref
		in
		  write_byte 2; write_opt_int n; write_opt_int m; do_output done
		end
	      else
		(write_byte 1; write_opt_int n; write_opt_int m)

	    fun write_dummy_valenvs _ =
	      let
		val valenvs = !dummy_valenv_list
	      in
		dummy_valenv_list := [];
		write_list write_dummy_valenv_element valenvs;
		(case !dummy_valenv_list of
		   [] => write_byte 1 (* Indicate finished writing *)
		 | _ => (write_byte 2; write_dummy_valenvs()))
	      end

	    fun write_recipe value =
	      case value of
		Debugger_Types.NOP =>
		  write_byte 0
	      | Debugger_Types.SELECT(x,y) =>
		  (write_byte 1; write_opt_int x; write_recipe y)
	      | Debugger_Types.MAKERECORD args =>
		  (write_byte 2;
		   write_assoc write_opt_string write_recipe args)
	      | Debugger_Types.FUNARG arg =>
		  (write_byte 3; write_recipe arg)
	      | Debugger_Types.FUNRES arg =>
		  (write_byte 4; write_recipe arg)
	      | Debugger_Types.MAKEFUNTYPE(x,y) =>
		  (write_byte 5; write_recipe x; write_recipe y)
	      | Debugger_Types.DECONS(x,y) =>
		  (write_byte 6; write_opt_int x; write_recipe y)
	      | Debugger_Types.MAKECONSTYPE(x, y) =>
		  (write_byte 7; write_list write_recipe x;
		   do_output(encode_tyname([], y)))
	      | Debugger_Types.ERROR _ =>
		  write_byte 8

            fun write_funinfo (Debugger_Types.FUNINFO {ty,is_leaf,has_saved_arg,annotations,runtime_env,is_exn}) =
              (do_output (encode_type ([],ty));
               write_bool is_leaf;
               write_bool has_saved_arg;
               write_assoc write_opt_int write_recipe annotations;
               write_runtime_env runtime_env;
               write_bool is_exn)

	    fun write_debug write_runtime_env debug_info =
	      write_list (write_pair  write_opt_string write_funinfo)
              (Debugger_Types.debug_info_to_list debug_info)
	  in
	    write_bool debug_variables;
	    Timer.xtime("write_nameset", !do_timings,
			fn () => write_nameset nameset);
	    Timer.xtime("write_funenv",  !do_timings,
			fn () => write_funenv funenv);
	    Timer.xtime("write_sigenv",  !do_timings,
			fn () => write_sigenv sigenv);
	    Timer.xtime("write_env",     !do_timings,
			fn () => write_env env);
	    Timer.xtime("write_dummy_valenvs", !do_timings,
			fn () => write_dummy_valenvs ());
	    Timer.xtime("write_debug",   !do_timings,
			fn () => write_debug (if debug_variables
						then write_runtime_env
					      else fn _ => ())
			debug_info);
	    ()
	  end

	(* The code *)
	
	fun write_code(Code_Module.MODULE element_list) =
	  let
	    fun output_module_element(Code_Module.REAL(i, r)) =
	      (write_int ObjectFile.OPCODE_REAL; write_int i;
	       write_int (size r div 4); write_string r)
	      | output_module_element(Code_Module.STRING(i, s)) =
		(write_int ObjectFile.OPCODE_STRING; write_int i;
		 write_int (size s + 1); write_extended_string s)
	      | output_module_element(Code_Module.MLVALUE(i, s)) =
		Crash.impossible "trying to encapsulate an MLVALUE"
	      | output_module_element
		(Code_Module.WORDSET(Code_Module.WORD_SET
				     {a_names=str_list,
				      b=w_list,
				      c_leafs=leaf_list,
				      d_intercept=offsets_list,
				      e_stack_parameters=parms_list})) =
		let
		  fun write ([], [], [], []) = ()
		    | write ({a_clos=i, b_spills=spills,
			      c_saves=saves, d_code=words}::sets,
			     leaf::leafs,
			     offset::offsets,
			     parm:: parms) =
		      (write_int i;		(* position in closure *)
		       write_int spills;	(* nr of non-gc spills *)
		       write_int saves;		(* nr of callee saves *)
		       write_int (if leaf then 1 else 0); (* leaf flag *)
		       write_int offset;	(* intercept offset *)
		       write_int parm;		(* number of stacked parameters *)
		       write_int (size words);	(* the code length *)
		       write_string words;	(* the code itself*)
		       write (sets, leafs, offsets, parms))
		    | write _ = Crash.impossible"Outputting wordset"
		  fun write_names [] = ()
		    | write_names (n::ns) =
		      (write_int (size n + 1);		(* length of name *)
		       write_extended_string n;		(* name of code item *)
		       write_names ns)
		  val wordset_size =
		    Lists.reducel (fn (res,{d_code, ...})
				   => res+size d_code) (0,w_list)
		  fun interceptible [] = false
		    | interceptible (off::offs) =
		      off <> ~1 orelse (interceptible offs)
		  val interceptible = interceptible offsets_list
		in
		  write_int ObjectFile.OPCODE_CODESET;
		  write_int (length str_list);
		  write_int wordset_size;
		  write_names str_list;
		  write_int (if interceptible then 1 else 0);
		  write (w_list, leaf_list, offsets_list, parms_list)
		end
	      | output_module_element(Code_Module.EXTERNAL(i, s)) =
		(write_int ObjectFile.OPCODE_EXTERNAL; write_int i;
		 write_int (size s + 1); write_extended_string s)
	      | output_module_element(Code_Module.VAR _) =
		Crash.impossible"Encapsulating interpretive code"
	      | output_module_element(Code_Module.EXN _) =
		Crash.impossible"Encapsulating interpretive code"
	      | output_module_element(Code_Module.STRUCT _) =
		Crash.impossible"Encapsulating interpretive code"
	      | output_module_element(Code_Module.FUNCT _) =
		Crash.impossible"Encapsulating interpretive code"
	  in
	    Timer.xtime
	    ("Outputting code", !do_timings, fn () =>
	     (write_int (length element_list);
	      write_int (count_real_objects element_list);
	      app output_module_element element_list))
	  end

	(* The consistency information *)

	fun time_to_ints time =
	  let
	    val real_time = Time.toReal time
	    val high = Real.realFloor(real_time / real_divisor)
	  in
	    (Real.floor high, Real.floor(real_time - high * real_divisor))
	  end

	fun write_cons_pair{mod_name, time} =
	  (write_sz_string mod_name;
	   write_pair write_int write_int (time_to_ints time))
	
	val write_cons = write_list write_cons_pair

	val consistency' =
	  {mod_name = mod_name, time = time_stamp} ::
	  consistency
	
	(* Finally, we start writing to the file: *)

	val _ = (write_int ObjectFile.GOOD_MAGIC;
		 write_int ObjectFile.OBJECT_FILE_VERSION)
	val (header_start, _, header_end) =
	  (getpos(), (write_dummies 6;
		      write_int stamps),
	   getpos())
	val (cons_start, _, cons_end) =
	  (getpos(), write_cons consistency', getpos())
	val (ty_start, _, ty_end) =
	  (getpos(),
	   write_type_basis (type_basis, debug_info, require_list),
	   getpos())
	val (parser_start, _, parser_end) =
	  (getpos(), write_parser_env parser_env, getpos())
	val (lambda_start, _, lambda_end) =
	  (getpos(), write_lambda_env lambda_env, getpos())
	val (code_start, _, code_end) = (getpos(), write_code code, getpos())
      in

	(* go back to the beginning of the file and write the size
	 * fields in the header *)
	seek header_start;
	write_int (code_start);
	write_int (cons_end   - cons_start);
	write_int (parser_end - parser_start);
	write_int (ty_end     - ty_start);
	write_int (lambda_end - lambda_start);
	write_int(!total_strings);
	close ()
      end
  end
@


1.186.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.186  1999/02/03  16:31:40  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
a75 4
 * Revision 1.186  1999/02/03  16:31:40  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
@


1.185
log
@[Bug #190500]
Remove redundant require statements
@
text
@d4 4
d1295 1
d1326 1
d1358 1
@


1.184
log
@[Bug #70198]
Add interface to get code_offset
@
text
@d4 4
d72 4
d763 1
a763 1
require "^.system.__os_path";
d1197 1
a1197 1
	    val name = OSPath_.base(OSPath_.file file_name)
@


1.183
log
@[Bug #70194]
Add interface for input_code taking filename to code_module
@
text
@d4 4
d68 4
d178 1
a178 1
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
d2639 29
@


1.182
log
@[Bug #70181]
Handle Time.Time which can occur from decode_cons
@
text
@d4 4
d64 4
d2466 2
a2467 1
	       strings = strings}
d2541 1
a2541 1
	       lambda_size, stamps, strings} =
d2583 1
a2583 1
	       lambda_size, stamps, strings} =
d2633 158
d3042 1
a3042 1
		(print"Write failed\n"; raise WriteFailed)
@


1.181
log
@[Bug #30413]
Close streams at the stream_io level, rather than just the underlying stream
@
text
@d4 4
d60 4
d2506 1
d2559 1
d2600 1
@


1.180
log
@[Bug #70099]
Changing encapsulation order to do type_env
before lambda_env and parser_env
@
text
@d4 5
d56 5
d2853 4
a2856 3
	  val (file_handle, buffer_mode) =
	    BinIO.StreamIO.getWriter(BinIO.getOutstream(BinIO.openOut filename))
	  val PrimIO.WR{writeVec, getPos, setPos, close, ...} = file_handle
@


1.179
log
@[Bug #70058]
Remove __terminal from list of requires
@
text
@d4 4
d51 4
d1081 3
a1083 3
    fun decode_type_basis (s, file_name, sub_modules,
			   decode_debug_information,
			   pervasive_env as Datatypes.ENV(strenv, tyenv, _)) =
d1085 1
d1153 1
a1153 1
	val (_, (stamp_count, _)) =
d1158 1
a1158 1
	      SOME elt => elt
d1174 1
a1174 1
	    SOME x => x
d1250 1
a1250 1
		  val (_, (stamp_count, _)) = name_offsets module ptr
d1280 1
a1280 1
		  val (_,(stamp_count, _)) = name_offsets module ptr
d1311 1
a1311 1
		  val (_, (stamp_count, _)) = name_offsets module ptr
d2404 1
a2404 1
	  fun decode_cons_triple ptr =
a2406 1
	      val (req_name, ptr) = decode_string ptr
d2409 1
a2409 1
	      ({mod_name = mod_name, req_name = req_name, time = time}, ptr)
d2413 1
a2413 1
	    input_list(s, decode_cons_triple, 0)
d2417 1
a2417 1
	  |  {mod_name, req_name, time} :: l =>
d2525 3
a2527 5
	       parser_env  = (decode_parser_env(checked_input(file_handle,
							     parser_size))),
	       lambda_env  = (decode_lambda_env(checked_input(file_handle,
							     lambda_size))),
	       type_env    = ((*print_pos(ObjectFile.HEADER_SIZE+cons_size+parser_size+lambda_size, "type_env for " ^ filename);*)checked_input(file_handle, type_size)),
d2542 1
a2542 1
      fun input_debug_info(filename, submodules) =
d2545 1
a2545 1
	    raise BadInput ("Corrupt object file (4): " ^ s ^ ": " ^ filename)
d2547 1
a2547 1
	    BinIO.openIn filename
d2558 1
a2558 1
	  
d2560 1
a2560 5
	    val _ = decode_parser_env(checked_input(file_handle,
						    parser_size))
	    val _ = decode_lambda_env(checked_input(file_handle,
						    lambda_size))
	    val type_env = ((*print_pos(ObjectFile.HEADER_SIZE+cons_size+parser_size+lambda_size, "type_env for " ^ filename);*)checked_input(file_handle, type_size))
d2564 5
a2568 1
	       (type_env, filename, submodules, true,
d2571 1
a2571 1
			      Datatypes.empty_valenv)))
d2578 1
a2578 1
			 raise BadInput (s ^ ": " ^ filename))
d2582 21
d3194 2
a3195 2
                 (fn ((_, (n : int, _)), (_, (n', _))) => n < n')
                 (List.filter (fn (_,(start,extent:int)) => extent > 0) sub_modules))
d3200 1
a3200 1
                    val (module, (start, extent)) = MLWorks.Internal.Array.sub(sub_modules_array, first)
d3210 1
a3210 1
                    val (module, (start, extent)) = MLWorks.Internal.Array.sub(sub_modules_array, mid)
d3954 1
a3954 1
	fun write_cons_triple{mod_name, req_name, time} =
a3955 1
	   write_sz_string req_name;
d3958 1
a3958 1
	val write_cons = write_list write_cons_triple
d3961 1
a3961 1
	  {mod_name = mod_name, req_name = mod_name, time = time_stamp} ::
d3974 4
a3981 4
	val (ty_start, _, ty_end) =
	  (getpos(),
	   write_type_basis (type_basis, debug_info, require_list),
	   getpos())
@


1.178
log
@[Bug #70058]
Use the proper submodule table when getting debug info
@
text
@d4 4
d47 4
a702 1
require "^.utils.__terminal";
@


1.177
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d43 4
d695 1
d706 1
d1066 2
a1067 1
    fun decode_type_basis (s, name, sub_modules, decode_debug_information,
d1138 8
a1145 6
	  case NewMap.tryApply'(sub_modules, name) of
	    SOME elt => elt
	  | _ =>
	      if decode_debug_information then
		("",(Basis.pervasive_stamp_count, 0))
	      else raise BadInput("sub_module '" ^ name ^ "' missing")
d1156 1
a1156 1
	fun name_offsets sub_name =
d1160 4
a1163 7
	      if decode_debug_information then
		("", (Basis.pervasive_stamp_count, 0))
	      else
		Info.error'
		(Info.make_default_options ())
		(Info.FATAL, Info.Location.FILE name,
		 "Unknown module " ^ sub_name)
d1234 1
a1234 1
		  val (_, (stamp_count, _)) = name_offsets module
d1264 1
a1264 1
		  val (_,(stamp_count, _)) = name_offsets module
d1295 1
a1295 1
		  val (_, (stamp_count, _)) = name_offsets module
a1652 32
(*
	and decode_tyname_valenv ptr =
	  let
	    val (n, ptr) = input_byte(s, ptr)
	  in
	    case n of
	      1 => decode_valenv (fn _ => ()) ptr
	    | 2 =>
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  if n = 0 then
		    let
		      val (mapping, ptr) =
			input_newmap(s,
				     decode_valid, decode_dummy_scheme,
				     ptr, Ident.valid_lt, Ident.valid_eq)
		      val valenv = Datatypes.VE(ref 0, mapping)
		      val n = (!tyname_valenvs_so_far)+1
		    in
		      tyname_valenvs_so_far := n;
		      IntHashTable.update
		      (tynamevalenvhashtable, n, valenv);
		      (ref valenv, ptr)
		    end
		  else
		    (ref(IntHashTable.lookup(tynamevalenvhashtable, n)), ptr)
		end
	    | _ => raise CorruptFile 15
	  end
*)

d2437 1
a2437 1
	  if size s <> len then raise BadInput "Corrupt object file (2)"
d2485 1
a2487 1
(*          val _ = filename_debugging_ref:=filename*)
d2514 1
a2514 1
	       type_env    = checked_input(file_handle, type_size),
a2530 1
(*          val _ = filename_debugging_ref:=filename*)
a2544 15

	    val stream = BinIO.getInstream file_handle
	    val (reader, _) = BinIO.StreamIO.getReader stream

	    fun skip size =
	      case reader of
		PrimIO.RD{setPos = SOME setter, getPos = SOME getter, ...} =>
		  let
		    val here = getter()
		  in
		    setter(here + size)
		  end
	      | _ =>
		  (ignore(checked_input(file_handle, type_size)); ())
	    (* If no setter and getter, do it the hard way *)
d2546 6
a2551 4
	    val _ = skip parser_size
	    val _ = skip lambda_size
	    val type_env = checked_input(file_handle, type_size)

a2568 1

a2738 3
(*
	Map.Fold (fn a => fn b => fn done => g(f(done, a), b)) (sz :: done) m
*)
a3153 16
(*
	    fun stamp_module (n : int) =
	      let
		fun search [] = Crash.impossible ("stamp_module")
		  | search ((module,(stamp_count,stamp_no))::rest) =
		    if not (n >= stamp_count andalso
			    n < (stamp_count + stamp_no))
		      then search rest
		    else
		      (module,stamp_count,rest)
		val (module,stamp_count,rest) = search sub_modules
	      in
		(module, n - stamp_count)
	      end
*)

a3294 28
	
(*
	    fun encode_tyname_valenv(done, valenv as Datatypes.VE(r, M)) =
	      let val n = !r
	      in
		if n = 0 then
		  let
		    val pos =
		      HashTable.lookup_default
		      (valenvhashtable, 0, valenv)
		    val done = (optimised_output_int pos ::
				output_byte 2 :: done)
		  in
		    if pos = 0 then
		      let
			val c = !valenv_tyname_count + 1
			val _ = valenv_tyname_count := c
			val _ = HashTable.update(valenvhashtable,valenv, c)
		      in
			encode_newmap done encode_valid encode_fun_or_cons M
		      end
		    else
		      done
		  end
		else
		  optimised_output_int n :: output_byte 1 :: done
	      end
*)	
d3721 1
a3721 6
	      (
(*
               output (std_out,"Writing structure:\n");
               output (std_out,Env.string_str str);
*)
               case HashTable.lookup_default(strhashtable, 0, str) of
@


1.176
log
@[Bug #30341]
Fix where type ... and syntax
@
text
@d4 4
d39 4
d2581 1
a2581 1
		  (checked_input(file_handle, type_size); ())
d2969 1
a2969 1
	  (f a; g b)
d2972 1
a2972 1
	  (f a; g b; h c)
d2975 1
a2975 1
	  (f a; g b; h c; i d)
d2978 1
a2978 1
	  (f a; g b; h c; i d; j e)
@


1.175
log
@[Bug #70053]
Change Crash.impossible calls for debug info decapsulation into user errors
@
text
@d4 4
d35 4
d735 1
a735 1
  structure PrimIO : PRIM_IO where type pos = int and writer = BinIO.StreamIO.writer and vector = BinIO.vector and reader = BinIO.StreamIO.reader
@


1.174
log
@[Bug #30326]
Merge in change from branch MLWorks_workspace_97
@
text
@d4 4
d31 4
d1116 1
a1116 1
	      else Crash.impossible("sub_module '" ^ name ^ "' missing")
d1793 1
a1793 1
		 | _ => Crash.impossible"input_spill_area:decode_runtime_env:encapsulate", ptr)
d1817 1
a1817 2
		      | _ => Crash.impossible
			  "decode_spill:decode_runtime_env:encapsulate"
d1826 1
a1826 1
		| _ => Crash.impossible "decode_option:encapsulate"
d1844 1
a1844 1
		| _ => Crash.impossible "decode_varinfo:encapsulate"
d1892 1
a1892 2
		      | _ => Crash.impossible
			  "decode_tag:decode_runtime_env:encapsulate"
d1897 1
a1897 2
	    | _ => Crash.impossible
		"decode_runtime_env:decode_type_basis:encapsulate"
d2049 1
a2049 1
	    | _ => Crash.impossible "problems in decoding a recipe"
d2210 1
a2210 1
		     Crash.impossible "Decoding a field - got neither 1 nor 0")
d2309 1
a2309 1
	  fun error_fn _ = Crash.impossible "Encapsulate.decode_val_env"
@


1.173
log
@[Bug #30331]
Add input_debug_info to interface
@
text
@d4 4
d26 14
d675 1
a675 1
require "../utils/timer";
@


1.172
log
@[Bug #30330]
Modify encapsulation mechanism for valenvs found in tynames
so as to avoid circularity problems.
@
text
@d4 5
d701 1
a701 1
  structure PrimIO : PRIM_IO where type pos = int and writer = BinIO.StreamIO.writer and vector = BinIO.vector
d2149 1
a2149 1
      (* Now we define input_info and input_all *)
d2502 54
@


1.171
log
@[Bug #30328]
Add environment parameter to decode_type_basis
for finding pervasive type names
@
text
@d4 5
d1016 1
d1561 1
a1561 1
	and decode_valenv updatetynamehashtable ptr =
a1570 1
		val _ = updatetynamehashtable valenv
d1582 1
a1582 2
		(updatetynamehashtable valenv;
		 (valenv,ptr))
d1596 1
d1626 14
d1667 1
a1667 1
			   decode_valenv
d1683 1
a1683 1
			 else decode_tyname_valenv) ptr
d1726 1
a1726 1
			      (decode_valenv
d1737 1
a1737 1
			  decode_tyname_valenv (I ref o decode_bool)
d1875 1
a1875 1
	    val (valenv, ptr) = decode_valenv (fn _ => ()) ptr
d1905 1
a1905 1
	    val (valenv, ptr) = decode_valenv (fn _ => ()) ptr
a1982 24
	fun decode_tyfun_int ptr =
	  let
	    val (tyfun,ptr) = decode_tyfun ptr
	    val (n,ptr) = input_opt_int (s,ptr)
	  in
	    ((tyfun,n),ptr)
	  end

	fun decode_valenv_int ptr =
	  let
	    val (valenv,ptr) = decode_valenv (fn _ => ()) ptr
	    val (n,ptr) = input_opt_int (s,ptr)
	  in
	    ((!valenv,n),ptr)
	  end

	fun decode_strname_int ptr =
	  let
	    val (strname,ptr) = decode_strname ptr
	    val (n,ptr) = input_opt_int (s,ptr)
	  in
	    ((strname,n),ptr)
	  end

d2071 51
d2506 2
d3155 3
a3157 1
	    val valenv_no = ref 0
d3254 1
d3280 3
a3282 2
	
	    and encode_valenv(done, Datatypes.VE(r, M)) =
d3297 10
a3306 1
	
d3322 4
a3325 5
		    (if debug_variables then encode_valenv
		     else encode_tyname_valenv)
		       (encode_bool b :: optimised_output_int n ::
			encode_string(encode_tyname_id(done, ti), s),
			ve)
d3346 1
a3346 1
			encode_tyfun(encode_valenv
d3354 5
a3358 5
			(encode_tyname_valenv(encode_bool b ::
					      optimised_output_int n ::
					      encode_string(encode_tyfun
							    (done, tf), s),
					      ve))
d3750 22
d3816 2
@


1.170
log
@[Bug #30089]
Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
@
text
@d4 4
d1004 2
a1005 1
    fun decode_type_basis (s, name, sub_modules, decode_debug_information) =
d1012 60
a1071 6
(*
	val sub_modules = sub_modules
	  NewMap.from_list'
	  ((op<):string*string->bool)
	  (map (fn (elt as (name, _)) => (name, elt)) sub_modules)
*)
d1100 1
a1100 1
		 "Unknown module " ^ sub_name (*^ print_sub_modules_table sub_modules*))
d1145 2
a1146 1
	  let val (i, ptr) = input_byte(s, ptr)
d1152 4
a1155 2
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n n, ptr)
d1160 4
a1163 2
		let val (n, ptr) = input_opt_int(s, ptr)
		in (Stamp.make_stamp_n (stamp_count + n), ptr)
d1173 1
a1173 1
		  (Stamp.make_stamp_n (stamp_count + n), ptr)
d1635 7
a1641 1
		      val (tyname_id, ptr) = decode_tyname_id ptr
d1652 9
a1660 5
				Datatypes.TYNAME(tyname_id,st,i,b,valenv,
						 NONE,is_abs,
                                                 valenv, 0)
                                    (* level is 0 since it is a topdec.
                                       (see end of decode_type_basis fn) *)
d1667 9
a1675 4
		      val tyname = Datatypes.TYNAME(tyname_id,st,i,b,valenv,
                                                    NONE,
                                                    is_abs,valenv, 0)
                                  (* level 0 for toplevel dec *)
@


1.169
log
@[Bug #30089]
Replacing MLWorks.Time with Time from the basis
@
text
@d4 4
d666 1
a666 1
  structure Timer : TIMER
@


1.168
log
@[Bug #30090]
Modify to handle IO.Io near BinIO.openIn
@
text
@d4 4
d628 1
d637 1
d731 2
d2219 8
d2228 5
a2232 2
	    let val (time_string, ptr) = input_sz_string (s, ptr)
	    in (MLWorks.Time.decode time_string, ptr)
d3735 9
a3743 1
	
d3747 1
a3747 1
	   write_sz_string(MLWorks.Time.encode time))
@


1.168.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.168  1997/06/03  17:30:50  jont
 * [Bug #30090]
 * Modify to handle IO.Io near BinIO.openIn
 *
@


1.168.2.2
log
@[Bug #30089]
Merged from trunk:
Replacing MLWorks.Time with Time from the basis
@
text
@d3 1
a3 5
 * $Log: _encapsulate.sml,v $
 *
 * Revision 1.168.2.1  1997/09/11  20:57:00  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
a627 1
require "^.basis.__real";
a635 1
require "^.system.__time";
a728 2
    val real_divisor = Real.fromInt(1000000);

a2214 8
	  fun time_from_ints(a, b) =
	    let
	      val high = Real.fromInt a * real_divisor
	      val low = Real.fromInt b
	    in
	      high + low
	    end

d2216 2
a2217 5
	    let
	      val (a, ptr) = input_int(s, ptr)
	      val (b, ptr) = input_int(s, ptr)
	    in
	      (Time.fromReal(time_from_ints(a, b)), ptr)
d3720 1
a3720 9

	fun time_to_ints time =
	  let
	    val real_time = Time.toReal time
	    val high = Real.realFloor(real_time / real_divisor)
	  in
	    (Real.floor high, Real.floor(real_time - high * real_divisor))
	  end

d3724 1
a3724 1
	   write_pair write_int write_int (time_to_ints time))
@


1.168.2.3
log
@[Bug #30326]
Renamed utils/*timer to utils/*mlworks_timer.
@
text
@a3 5
 * Revision 1.168.2.2  1997/10/29  14:10:27  daveb
 * [Bug #30089]
 * Merged from trunk:
 * Replacing MLWorks.Time with Time from the basis
 *
d643 1
a643 1
require "../utils/mlworks_timer";
@


1.168.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.168  1997/06/03  17:30:50  jont
 * [Bug #30090]
 * Modify to handle IO.Io near BinIO.openIn
 *
@


1.167
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d4 4
d2322 2
a2323 2
	    handle MLWorks.IO.Io m =>
	      raise BadInput ("Io error in decapsulate: " ^ m)
@


1.166
log
@[Bug #30091]
Convert from MLWorks.Internal.FileIO to BinIO from the basis
@
text
@d4 4
d627 1
d2260 2
a2261 1
	let val s = MLWorks.IO.input(f, len)
d2273 3
a2275 3
	    MLWorks.IO.open_in filename
	    handle MLWorks.IO.Io m =>
	      raise BadInput ("Io error in decapsulate: " ^ m)
d2286 1
a2286 1
	    MLWorks.IO.close_in file_handle;
d2292 5
a2296 5
	  MLWorks.String.Ord => (MLWorks.IO.close_in file_handle; raise Error)
	| Lists.Nth => (MLWorks.IO.close_in file_handle; raise Error) (* I dont think this is necessary, see Log 1.66 *)
	| MLWorks.String.Substring => (MLWorks.IO.close_in file_handle; raise Error)
	| NewMap.Undefined => (MLWorks.IO.close_in file_handle; raise Error)
	| BadInput s => (MLWorks.IO.close_in file_handle;
d2298 1
a2298 1
	| IntHashTable.Lookup => (MLWorks.IO.close_in file_handle; raise Error)
d2317 1
a2317 1
	    MLWorks.IO.open_in filename
d2343 1
a2343 1
	    MLWorks.IO.close_in file_handle;
d2346 5
a2350 5
	  MLWorks.String.Ord => (MLWorks.IO.close_in file_handle; error "ord")
	| Lists.Nth => (MLWorks.IO.close_in file_handle; error "nth")
	| MLWorks.String.Substring => (MLWorks.IO.close_in file_handle; error "substring")
	| NewMap.Undefined => (MLWorks.IO.close_in file_handle; error "undefined")
	| BadInput s => (MLWorks.IO.close_in file_handle;
d2352 1
a2352 1
	| IntHashTable.Lookup => (MLWorks.IO.close_in file_handle; error "lookup")
d3653 2
a3654 1
				      d_intercept=offsets_list,...})) =
d3656 1
a3656 1
		  fun write ([], [], []) = ()
d3659 3
a3661 1
			     leaf::leafs, offset::offsets) =
d3667 4
a3670 3
		     write_int (size words);	(* the code length *)
		     write_string words;	(* the code itself*)
		     write (sets, leafs, offsets))
d3690 1
a3690 1
		  write (w_list, leaf_list, offsets_list)
@


1.165
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d616 1
d619 4
d667 2
d935 1
a935 1
      
d1022 1
a1022 1
	fun decode_bool (ptr:int) = 
d1034 1
a1034 1
	      
d1170 1
a1170 1
  
d1684 1
a1684 1
		| 2 => 
d1686 1
a1686 1
                    (input_triple 
d1697 1
a1697 1
              
d1952 1
a1952 1
              input_list (s, 
d2004 1
a2004 1
      
d2011 1
a2011 1
	    
d2016 1
a2016 1
	    
d2018 1
a2018 1
	    
d2037 1
a2037 1
		   
d2054 1
a2054 1
		    
d2065 1
a2065 1
	  
d2074 1
a2074 1
	  
d2084 1
a2084 1
    
d2115 1
a2115 1
	  
d2134 1
a2134 1
	  
d2136 1
a2136 1
	    
d2160 1
a2160 1
            let 
d2162 1
a2162 1
            in 
d2171 1
a2171 1
              val (tycon_env, ptr) = 
d2184 1
a2184 1
  
d2189 2
a2190 2
	    input_newmap(s, decode_sigid, 
                         input_pair read_parse_env 
d2199 1
a2199 1
    
d2206 1
a2206 1
	  
d2208 1
a2208 1
	    
d2217 1
a2217 1
	  
d2228 1
a2228 1
    
d2252 1
a2252 1
      
d2294 1
a2294 1
      
d2296 1
a2296 1
    
d2304 1
a2304 1
     
d2369 1
a2369 1
	      
d2379 1
a2379 1
	  
d2386 1
a2386 1
	      
d2401 1
a2401 1
	      
d2405 1
a2405 1
	      
d2409 1
a2409 1
	      
d2413 1
a2413 1
	    
d2416 1
a2416 1
	    
d2424 1
a2424 1
	      
d2426 1
a2426 1
	    
d2431 1
a2431 1
	    
d2435 1
a2435 1
	    
d2438 1
a2438 1
	    
d2443 1
a2443 1
	    
d2446 1
a2446 1
	    
d2473 1
a2473 1
    
d2581 1
a2581 1
    
d2591 14
a2604 2
	  val file_handle = MLWorks.Internal.FileIO.openf filename
	  val write = MLWorks.Internal.FileIO.writef
d2606 1
a2606 2
	  val buffer = MLWorks.Internal.ByteArray.array(bufsize,0);
	  val fpos = ref 0		(* actual file position *)
d2609 2
a2610 4
	    if !bufpos > 0 then 
	      (MLWorks.Internal.FileIO.writebf (file_handle,
						buffer, 0, !bufpos);
	       fpos := (!fpos)+(!bufpos);
d2615 6
a2620 8
	  fun getpos () = (flush_buffer ();
			   !fpos)
	  fun seek pos = (flush_buffer ();
			  MLWorks.Internal.FileIO.seekf
			  (file_handle, pos,
			   MLWorks.Internal.FileIO.BEG);
			  fpos := pos)
	  fun write_byte i = (if !bufpos >= bufsize
d2623 1
a2623 1
			      MLWorks.Internal.ByteArray.update (buffer,!bufpos,i);
d2625 1
a2625 3
	  fun write_string s = (flush_buffer ();
				write(file_handle, s);
				fpos := !fpos + size s)
d2630 1
a2630 2
	     write(file_handle, s);
	     fpos := !fpos + size s;
d2637 2
a2638 3
	    
	  fun close () = (flush_buffer();
			  MLWorks.Internal.FileIO.closef file_handle)
d2653 1
a2653 1
	    
d2663 1
a2663 1
		 
d2666 1
a2666 1
	    
d2674 1
a2674 1
	  val encodeMap = ref (NewMap.empty 
d2691 1
a2691 1
      
d2694 1
a2694 1
	  
d2709 1
a2709 1
	  
d2712 1
a2712 1
	  
d2715 1
a2715 1
	  
d2718 1
a2718 1
	  
d2721 1
a2721 1
	  
d2725 1
a2725 1
	  
d2729 1
a2729 1
	  
d2732 1
a2732 1
	  
d2742 1
a2742 1
	    
d2744 1
a2744 1
	  
d2746 1
a2746 1
	  
d2748 1
a2748 1
	  
d2750 1
a2750 1
	  
d2753 1
a2753 1
	    
d2759 1
a2759 1
	    
d2772 1
a2772 1
	      
d2775 1
a2775 1
	      
d2822 1
a2822 1
		    
d2841 1
a2841 1
			     (env as EnvironTypes.ENV(v, s), 
d2855 1
a2855 1
	      
d2858 1
a2858 1
	      
d2864 1
a2864 1
	      
d2872 1
a2872 1
		  
d2896 1
a2896 1
	    
d2899 1
a2899 1
	      
d2994 1
a2994 1
	      
d3016 1
a3016 1
	      
d3033 1
a3033 1
	    
d3049 1
a3049 1
	    
d3065 1
a3065 1
	    
d3088 1
a3088 1
		  
d3091 1
a3091 1
	      
d3117 1
a3117 1
	    
d3133 1
a3133 1
	    
d3158 1
a3158 1
	    
d3191 1
a3191 1
	      
d3235 1
a3235 1
			  (write_list 
d3241 1
a3241 1
                                write_triple 
d3274 1
a3274 1
	    
d3369 1
a3369 1
		    
d3440 1
a3440 1
	      
d3457 1
a3457 1
		     
d3460 1
a3460 1
	      
d3463 1
a3463 1
	      
d3466 1
a3466 1
	      
d3468 1
a3468 1
	      
d3478 1
a3478 1
	      
d3480 1
a3480 1
	      
d3497 1
a3497 1
	    
d3526 1
a3526 1
	    
d3533 1
a3533 1
	      
d3556 1
a3556 1
	      
d3560 1
a3560 1
	      
d3565 1
a3565 1
	      
d3568 1
a3568 1
	      
d3571 1
a3571 1
	      
d3574 1
a3574 1
	      
d3577 1
a3577 1
	      
d3610 1
a3610 1
	      write_list (write_pair  write_opt_string write_funinfo) 
d3646 1
a3646 1
				      c_leafs=leaf_list, 
d3707 1
a3707 1
	  
d3713 1
a3713 1
	  
d3724 9
a3732 9
      val (parser_start, _, parser_end) =
	(getpos(), write_parser_env parser_env, getpos())
      val (lambda_start, _, lambda_end) =
	(getpos(), write_lambda_env lambda_env, getpos())
      val (ty_start, _, ty_end) =
        (getpos(),
         write_type_basis (type_basis, debug_info, require_list),
         getpos())
      val (code_start, _, code_end) = (getpos(), write_code code, getpos())
@


1.165.5.1
log
@branched from 1.165
@
text
@a3 4
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.165.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.165.5.1  1997/05/12  10:36:00  hope
 * branched from 1.165
 *
@


1.165.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.165.5.1  1997/05/12  10:36:00  hope
 * branched from 1.165
 *
@


1.165.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.165.5.1  1997/05/12  10:36:00  hope
 * branched from 1.165
 *
@


1.165.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.165.5.1.1.1  1997/07/28  18:21:41  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.165.4.1
log
@branched from 1.165
@
text
@a3 4
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.165.3.1
log
@branched from 1.165
@
text
@a3 4
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.165.3.1.1.1
log
@branched from 1.165.3.1
@
text
@a3 3
 * Revision 1.165.3.1  1996/12/17  17:49:27  hope
 * branched from 1.165
 *
@


1.165.2.1
log
@branched from 1.165
@
text
@a3 4
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.165.1.1
log
@branched from 1.165
@
text
@a3 4
 * Revision 1.165  1996/11/06  11:28:49  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.165.1.1.1.1
log
@branched from 1.165.1.1
@
text
@a3 3
 * Revision 1.165.1.1  1996/11/14  12:51:39  hope
 * branched from 1.165
 *
@


1.164
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d4 4
d611 1
a611 1
require "^.basis.__integer";
@


1.163
log
@[Bug #1614]
basifying String
@
text
@d4 4
d608 1
d708 1
a708 1
	  else add_together_ords'(x-1, acc + MLWorks.Internal.Value.unsafe_string_sub (s,x))
d743 3
a745 3
	      val x = Bits.lshift(MLWorks.Internal.Value.unsafe_string_sub (s, ptr), 8)
	      val y = Bits.lshift(Bits.orb(MLWorks.Internal.Value.unsafe_string_sub (s, ptr + 1), x), 8)
	      val z = Bits.lshift(Bits.orb(MLWorks.Internal.Value.unsafe_string_sub (s, ptr + 2), y), 8)
d747 1
a747 1
	      Bits.orb (z, MLWorks.Internal.Value.unsafe_string_sub (s, ptr+3))
d1012 1
a1012 1
	      (case MLWorks.Internal.Value.unsafe_string_sub (s, ptr) of
@


1.162
log
@[Bug #1686]
extending parser environment
@
text
@d4 4
d603 2
a604 1
require "../basis/__integer";
d703 1
a703 1
	  else add_together_ords'(x-1, acc + MLWorks.String.ordof(s,x))
d733 2
a734 5
      fun inputi(s, ptr) =
	let
	  val x = Bits.lshift(MLWorks.String.ordof(s, ptr), 8)
	  val y = Bits.lshift(Bits.orb(MLWorks.String.ordof(s, ptr + 1), x), 8)
	  val z = Bits.lshift(Bits.orb(MLWorks.String.ordof(s, ptr + 2), y), 8)
d736 12
a747 2
	  Bits.orb(z, MLWorks.String.ordof(s, ptr + 3))
	end
d969 1
a969 1
	  MLWorks.String.<
d975 1
a975 1
	    MLWorks.Option.SOME elt => elt
d987 1
a987 1
	    MLWorks.String.implode("Table contains:-\n" :: names)
d992 1
a992 1
	    MLWorks.Option.SOME x => x
d1002 13
a1014 6
	fun decode_bool ptr =
	  case MLWorks.String.ordof(s, ptr) of
	    0 => (false, ptr+1)
	  | 1 => (true, ptr+1)
	  | _ => raise CorruptFile 4

a1174 1
	fun decode_order(i, j:int) = i<j
d1176 1
a1176 1
	  ref (NewMap.empty (decode_order,op =))
d1194 1
a1194 1
				   MLWorks.Option.NONE)
d1197 1
a1197 1
				   MLWorks.Option.NONE)
d1280 1
a1280 1
		  (Datatypes.SCHEME(i, (ty,MLWorks.Option.NONE)), ptr)
d1284 1
a1284 1
		in (Datatypes.UNBOUND_SCHEME(ty,MLWorks.Option.NONE), ptr)
d1436 1
a1436 1
		      val ty = Datatypes.DEBRUIJN(i, b1, b2,MLWorks.Option.NONE)
d1542 1
a1542 1
						 MLWorks.Option.NONE,is_abs,
d1553 1
a1553 1
                                                    MLWorks.Option.NONE,
d1655 2
a1656 2
		  1 => (MLWorks.Option.NONE,ptr)
		| 2 => I MLWorks.Option.SOME(decode ptr)
d1671 1
a1671 1
                                      (MLWorks.Option.NONE,nil))))
d1782 1
a1782 1
		  val str = Datatypes.STR(strname,ref MLWorks.Option.NONE,env)
d2267 1
a2267 1
	| Lists.Nth => (MLWorks.IO.close_in file_handle; raise Error)
d2377 1
a2377 1
	      (Lists.iterate reset_type l;
d2428 2
a2429 2
	    (Lists.iterate reset_tyname (Nameset.tynames_of_nameset ns);
	     Lists.iterate reset_strname (Nameset.strnames_of_nameset ns))
d2479 1
a2479 1
	rev_map(optimised_output_int(Lists.length l) :: done, l)
d2553 1
a2553 1
	  count_real_objects'(count + Lists.length w_list, rest)
d2651 2
a2652 1
	  val encodeMap = ref (NewMap.empty (MLWorks.String.<, op= : string * string -> bool))
d2685 1
a2685 1
	  (write_opt_int(Lists.length l); Lists.iterate f l)
d2837 1
a2837 1
	    val f_len = Lists.length f_map
d2846 2
a2847 2
		val v_len = Lists.length v_list
		val s_len = Lists.length s_list
d2936 1
a2936 1
                 (Lists.filterp (fn (_,(start,extent:int)) => extent > 0) sub_modules))
d3048 1
a3048 1
		    if h = s then Lists.length t + 1 else es' t
d3179 2
a3180 3
		fun write_option _ (MLWorks.Option.NONE) = write_byte 1
		  | write_option write_object (MLWorks.Option.SOME
					       (object)) =
d3255 1
a3255 1
		fun et'(h::t) = if h = arg then Lists.length t + 1
d3272 1
a3272 1
		  fun et'(h::t) = if h = arg then Lists.length t + 1
d3289 1
a3289 1
		      Lists.length tl + 1
d3306 1
a3306 1
		  fun et'(h::t) = if h = arg then Lists.length t + 1
d3384 1
a3384 1
		  fun et'(h::t) = if h = (n,b1,b2) then Lists.length t + 1
d3484 1
a3484 1
		  MLWorks.Option.SOME list =>
d3653 1
a3653 1
		  write_int (Lists.length str_list);
d3673 1
a3673 1
	     (write_int (Lists.length element_list);
d3675 1
a3675 1
	      Lists.iterate output_module_element element_list))
@


1.161
log
@[Bug #1592]
Threading extra "level" argument to tynames.
@
text
@d4 4
d425 1
a425 1
Changed to use has tables in various places. Altered the encoding
d679 3
d924 3
d1010 1
d2049 2
a2050 1
	  val fix_map = ref IntMap.empty : (Symbol.Symbol, ParserEnv.Fixity) NewMap.map IntMap.T ref
d2054 1
a2054 1
	    
d2061 1
a2061 1
	    
d2120 9
d2133 3
d2141 1
a2145 7
          fun decode_tycon ptr =
            let 
              val (sy, ptr) = decode_symbol ptr
            in 
              (Ident.TYCON sy, ptr)
            end

d2151 3
a2153 1
	    input_newmap(s, decode_sigid, input_pair read_parse_env (fn ptr => input_list (s,decode_tycon,ptr)),
d2269 1
d2738 22
d2761 2
a2762 1
				      ParserEnv.VE val_map,
d2781 3
a2783 15
		val val_list = NewMap.to_list val_map
		val n = HashTable.lookup_default(valhashtable, 0, val_list)
		val _ =
		  if n = 0 then
		    let
		      val newsize = !valsize + 1
		    in
		      valsize := newsize;
		      HashTable.update(valhashtable, val_list, newsize);
		      write_opt_int 0;
		      write_list (write_valid o #2) val_list
		    end
		  else
		    write_opt_int n
		    
@


1.161.1.1
log
@branched from 1.161
@
text
@a3 4
 * Revision 1.161  1996/10/04  15:48:57  andreww
 * [Bug #1592]
 * Threading extra "level" argument to tynames.
 *
@


1.160
log
@[Bug #1603]
convert MLWorks.ByteArray to MLWorks.Internal.ByteArray or equivalent basis functions
@
text
@d4 4
d1513 4
a1516 1
						 MLWorks.Option.NONE,is_abs,valenv)
d1523 5
a1527 1
		      val tyname = Datatypes.TYNAME(tyname_id,st,i,b,valenv,MLWorks.Option.NONE,is_abs,valenv)
d2321 1
a2321 1
	  and reset_tyname(Datatypes.TYNAME(ti, _, _, _, ref ve,_,_,_)) =
d3062 2
a3063 1
						      ref ve,_,ref is_abs,_)) =
@


1.160.1.1
log
@branched from 1.160
@
text
@a3 4
 * Revision 1.160  1996/09/18  15:25:07  io
 * [Bug #1603]
 * convert MLWorks.ByteArray to MLWorks.Internal.ByteArray or equivalent basis functions
 *
@


1.159
log
@[Bug #1503]
Add field to FUNINFO to say if arg actually saved
@
text
@d4 4
d2524 1
a2524 1
	  val buffer = MLWorks.ByteArray.array(bufsize,0);
d2546 1
a2546 1
			      MLWorks.ByteArray.update (buffer,!bufpos,i);
@


1.159.1.1
log
@branched from 1.159
@
text
@a3 4
 * Revision 1.159  1996/08/01  12:27:22  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
@


1.158
log
@[Bug #1469]
Fix problems in decode_spill
@
text
@d4 4
d1870 1
d1877 2
a1878 1
              is_leaf= is_leaf,
d3512 1
a3512 1
            fun write_funinfo (Debugger_Types.FUNINFO {ty,is_leaf,annotations,runtime_env,is_exn}) =
d3515 1
@


1.157
log
@The Io and Ord exceptions are no longer at top level.
@
text
@d4 3
d1585 16
a1600 16
		      (case i of
			 1 =>
			   let
			     val (j, ptr) = input_int ptr
			   in
			     RuntimeEnv.OFFSET1 j
			   end
		       | 2 =>
			   let
			     val (k, ptr) = input_spill_area ptr
			     val (j, ptr) = input_int ptr
			   in
			     RuntimeEnv.OFFSET2(k, j)
			   end
		       | _ => Crash.impossible
			   "decode_spill:decode_runtime_env:encapsulate", ptr)
@


1.156
log
@Bits becomes MLWorks.Internal.Bits
@
text
@d4 3
d676 1
a676 1
	  else add_together_ords'(x-1, acc + String.ordof(s,x))
d708 3
a710 3
	  val x = Bits.lshift(String.ordof(s, ptr), 8)
	  val y = Bits.lshift(Bits.orb(String.ordof(s, ptr + 1), x), 8)
	  val z = Bits.lshift(Bits.orb(String.ordof(s, ptr + 2), y), 8)
d712 1
a712 1
	  Bits.orb(z, String.ordof(s, ptr + 3))
d719 1
a719 1
	  val tag = String.ordof(s,ptr)
d722 2
a723 2
	    (Bits.orb(Bits.lshift(String.ordof(s, ptr + 1), 8),
		      String.ordof(s, ptr + 2)), ptr + 3)
d733 1
a733 1
    fun input_byte(s, ptr) = (String.ordof(s, ptr), ptr + 1)
d739 1
a739 1
      in (String.substring(s, ptr, sz), ptr + sz)
d932 1
a932 1
	  String.<
d950 1
a950 1
	    String.implode("Table contains:-\n" :: names)
d966 1
a966 1
	  case String.ordof(s, ptr) of
d1918 2
a1919 2
      Ord => raise TypeDecapError 1
    | String.Substring => raise TypeDecapError 2
d2184 4
a2187 2
	  val file_handle = MLWorks.IO.open_in filename
	    handle Io m => raise BadInput ("Io error in decapsulate: " ^ m)
d2204 1
a2204 1
	  Ord => (MLWorks.IO.close_in file_handle; raise Error)
d2206 1
a2206 1
	| String.Substring => (MLWorks.IO.close_in file_handle; raise Error)
d2227 4
a2230 2
	  val file_handle = MLWorks.IO.open_in filename
	    handle Io m => raise BadInput ("Io error in decapsulate: " ^ m)
d2257 1
a2257 1
	  Ord => (MLWorks.IO.close_in file_handle; error "ord")
d2259 1
a2259 1
	| String.Substring => (MLWorks.IO.close_in file_handle; error "substring")
d2588 1
a2588 1
	  val encodeMap = ref (NewMap.empty (String.<, op= : string * string -> bool))
@


1.155
log
@Array moving to MLWorks.Array
@
text
@d4 3
d652 2
@


1.154
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d743 1
a743 1
      val stringMap = ref (Array.array(1, ""))
d746 1
a746 1
				stringMap := Array.array(n,""))
d757 1
a757 1
	      Array.update(!stringMap, strId, str);
d762 1
a762 1
	     (Array.sub(!stringMap, id), ptr)
d2846 1
a2846 1
                Array.arrayoflist
d2854 1
a2854 1
                    val (module, (start, extent)) = Array.sub(sub_modules_array, first)
d2864 1
a2864 1
                    val (module, (start, extent)) = Array.sub(sub_modules_array, mid)
d2872 1
a2872 1
              fun stamp_module n = find_module(n, 0, Array.length sub_modules_array)
@


1.153
log
@Removing MLWorks.Integer
@
text
@d4 3
d936 1
a936 1
	    implode("Table contains:-\n" :: names)
d2159 1
a2159 1
	let val s = input(f, len)
d2170 1
a2170 1
	  val file_handle = open_in filename
d2182 1
a2182 1
	    close_in file_handle;
d2188 5
a2192 5
	  Ord => (close_in file_handle; raise Error)
	| Lists.Nth => (close_in file_handle; raise Error)
	| String.Substring => (close_in file_handle; raise Error)
	| NewMap.Undefined => (close_in file_handle; raise Error)
	| BadInput s => (close_in file_handle;
d2194 1
a2194 1
	| IntHashTable.Lookup => (close_in file_handle; raise Error)
d2211 1
a2211 1
	  val file_handle = open_in filename
d2236 1
a2236 1
	    close_in file_handle;
d2239 5
a2243 5
	  Ord => (close_in file_handle; error "ord")
	| Lists.Nth => (close_in file_handle; error "nth")
	| String.Substring => (close_in file_handle; error "substring")
	| NewMap.Undefined => (close_in file_handle; error "undefined")
	| BadInput s => (close_in file_handle;
d2245 1
a2245 1
	| IntHashTable.Lookup => (close_in file_handle; error "lookup")
@


1.152
log
@Change interceptible so that it doesn't always return false.
This gets the runtime and image back in sync and so fixes bug #913.
@
text
@d4 4
d565 2
a640 2
    structure Integer = MLWorks.Integer

d668 1
a668 1
				  Integer.makestring n)
d671 1
a671 1
				     Integer.makestring n)
d673 1
a673 1
				   Integer.makestring n)
@


1.151
log
@Changes to parser signature environment
@
text
@d4 3
d3548 1
a3548 1
		      off <> ~1 andalso (interceptible offs)
@


1.150
log
@Changed type of input_info.
@
text
@d4 3
d956 5
a974 5
	fun decode_tycon ptr =
	  let val (sy, ptr) = decode_symbol ptr
	  in (Ident.TYCON sy, ptr)
	  end

a1095 2
	val decode_rev_list = decode_rev_list s

d1098 1
a1098 1
	    val (assoc_list, ptr) = decode_rev_list (input_pair f g) ptr
d1726 2
a1727 2
	    val (tynames, ptr) = decode_rev_list decode_tyname ptr
	    val (strnames, ptr) = decode_rev_list decode_strname ptr
d2072 9
a2080 1
	  
d2085 1
a2085 1
	    input_newmap(s, decode_sigid, read_parse_env,
d2708 1
a2708 1
	      write_newmap write_sigid write_pe sig_map;
@


1.149
log
@Change newhashtable to hashtable
@
text
@d4 3
d2106 4
a2109 1
	  result
d2159 1
a2159 1
	    val consistency = decode_cons cons
d2165 2
d2202 4
d2207 3
a2209 2
	      {consistency = decode_cons(checked_input(file_handle,
						       cons_size)),
d2465 1
a2465 1
       consistency} =
d3573 4
d3587 1
a3587 1
	  (getpos(), write_cons consistency, getpos())
@


1.148
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d556 1
a556 1
require "../utils/newhashtable";
d592 1
a592 1
  structure NewHashTable : NEWHASHTABLE
d2633 2
a2634 2
	    val valhashtable = NewHashTable.new(hash_size,op =,hash)
	    val fixhashtable = NewHashTable.new(hash_size,op =,hash)
d2649 1
a2649 1
		  NewHashTable.lookup_default(fixhashtable, 0, fix_list)
d2656 1
a2656 1
		      NewHashTable.update(fixhashtable, fix_list, newsize);
d2664 1
a2664 1
		val n = NewHashTable.lookup_default(valhashtable, 0, val_list)
d2671 1
a2671 1
		      NewHashTable.update(valhashtable, val_list, newsize);
d2708 1
a2708 1
	    val lambdavalhashtable = NewHashTable.new(hash_size,op =,hash)
d2726 1
a2726 1
		  NewHashTable.lookup_default(lambdavalhashtable, 0,
d2734 1
a2734 1
		      NewHashTable.update(lambdavalhashtable, v_list, newsize)
d2775 1
a2775 1
	      NewHashTable.new(hash_size,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
d2777 1
a2777 1
	      NewHashTable.new(hash_size,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
d2779 1
a2779 1
	      NewHashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
d2781 1
a2781 1
	      NewHashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
d2783 1
a2783 1
	      NewHashTable.new(hash_size,Enc_Sub.type_same,Enc_Sub.type_hash)
d2785 1
a2785 1
	      NewHashTable.new(hash_size,Enc_Sub.tyname_valenv_same,
d2844 1
a2844 1
	      NewHashTable.new(hash_size, op=, strname_hash)
d2950 1
a2950 1
		      NewHashTable.lookup_default
d2959 1
a2959 1
			val _ = NewHashTable.update(valenvhashtable,valenv, c)
d2990 1
a2990 1
		val pos = NewHashTable.lookup_default(tynamehashtable, 0, tyn)
d2997 1
a2997 1
		    val _ = NewHashTable.update(tynamehashtable,tyn, c)
d3014 1
a3014 1
		  val pos = NewHashTable.lookup_default
d3022 1
a3022 1
		      val _ = NewHashTable.update(metatynamehashtable,tyn, c)
d3199 1
a3199 1
		    NewHashTable.lookup_default
d3208 1
a3208 1
			      else NewHashTable.update(rectypehashtable,arg, c)
d3219 1
a3219 1
		    NewHashTable.lookup_default
d3229 1
a3229 1
			      else NewHashTable.update(funtypehashtable,
d3240 1
a3240 1
		    NewHashTable.lookup_default
d3249 1
a3249 1
			      else NewHashTable.update(constypehashtable,
d3383 1
a3383 1
	    val strhashtable = NewHashTable.new(hash_size, str_eq, str_hash)
d3392 1
a3392 1
               case NewHashTable.lookup_default(strhashtable, 0, str) of
d3398 1
a3398 1
		     NewHashTable.update(strhashtable, str, count);
@


1.147
log
@Replacing Map with NewMap
@
text
@d4 3
d1102 1
a1102 1
	  : (int, Datatypes.Tyname ref)NewMap.T ref
d1910 1
a1910 1
	    (Ident.ValId, EnvironTypes.comp) NewMap.T IntMap.T ref
d1983 1
a1983 1
	  val fix_map = ref IntMap.empty : (Symbol.Symbol, ParserEnv.Fixity) NewMap.T IntMap.T ref
d2767 2
a2768 2
		   ((Ident.TyCon, Datatypes.Tystr) NewMap.T * int) list)
		  NewMap.T)
@


1.146
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
a614 1
    structure Map = Datatypes.Mapping
d1090 1
a1090 2
	    (Lists.reducel (fn (m, x) => Map.add(x, m, orderfn))
	     (Map.empty_map, assoc_list), ptr)
d2218 2
a2219 1
	  fun reset_map_range fun2 m = Lists.iterate (fun2 o #2) (Map.assoc m)
d2374 1
a2374 1
	  optimised_output_int(Lists.length(Map.assoc m))
d2376 4
d2381 1
@


1.145
log
@Modifications for improved runtime environments in the debugger
@
text
@d4 3
a591 1
  sharing Debugger_Types.RuntimeEnv.Option = Basis.BasisTypes.Datatypes.Option
a616 1
    structure Option = Datatypes.Option
d1115 1
a1115 1
				   Option.ABSENT)
d1118 1
a1118 1
				   Option.ABSENT)
d1201 1
a1201 1
		  (Datatypes.SCHEME(i, (ty,Option.ABSENT)), ptr)
d1205 1
a1205 1
		in (Datatypes.UNBOUND_SCHEME(ty,Option.ABSENT), ptr)
d1357 1
a1357 1
		      val ty = Datatypes.DEBRUIJN(i, b1, b2,Option.ABSENT)
d1463 1
a1463 1
						 Option.ABSENT,is_abs,valenv)
d1470 1
a1470 1
		      val tyname = Datatypes.TYNAME(tyname_id,st,i,b,valenv,Option.ABSENT,is_abs,valenv)
d1569 2
a1570 2
		  1 => (Option.ABSENT,ptr)
		| 2 => I Option.PRESENT(decode ptr)
d1585 1
a1585 1
                                      (Option.ABSENT,nil))))
d1696 1
a1696 1
		  val str = Datatypes.STR(strname,ref Option.ABSENT,env)
d3040 2
a3041 2
		fun write_option _ (Option.ABSENT) = write_byte 1
		  | write_option write_object (Datatypes.Option.PRESENT
@


1.144
log
@Fixing problem with modules with no stamps defined
@
text
@d4 3
d1528 10
d1541 22
a1562 12
	      (fn ptr =>
	       I ref(
		     let val (i, ptr) = input_byte ptr
		     in
		       I
		       (case i of
			  1 => RuntimeEnv.OFFSET1
			| 2 => RuntimeEnv.OFFSET2
			| _ => Crash.impossible
			    "decode_spill:decode_runtime_env:encapsulate")
			  (input_int ptr)
		     end))
d3031 4
d3037 2
a3038 2
		  | write_spill (ref (RuntimeEnv.OFFSET2 spill)) =
		    (write_byte 2; write_int spill)
@


1.143
log
@Added realint_tyvar for abs and ~; removed real_tyvar and int_tyvar.
@
text
@d4 3
a2749 6
	      
	    val sub_modules_array =
	      Array.arrayoflist
	      (Lists.qsort
	       (fn ((_, (n : int, _)), (_, (n', _))) => n < n')
	       sub_modules)
d2767 32
a2798 22
	    fun find_module(stamp, first, last) =
	      if first+1 = last then
		let
		  val (module, (start, extent)) = Array.sub(sub_modules_array, first)
		in
		  if stamp >= start andalso stamp < start + extent then
		    (module, stamp - start)
		  else
		    Crash.impossible"stamp_module"
		end
	      else
		let
		  val mid = (first + last) div 2
		  val (module, (start, extent)) = Array.sub(sub_modules_array, mid)
		in
		  if stamp < start then
		    find_module(stamp, first, mid)
		  else
		    find_module(stamp, mid, last)
		end

	    fun stamp_module n = find_module(n, 0, Array.length sub_modules_array)
@


1.142
log
@Add handling for overloading on words
@
text
@d4 3
a1050 1
	    | 6 => (Ident.int_tyvar, ptr)
d1055 1
a1055 1
	    | 11 => (Ident.word_tyvar, ptr)
a2369 1
      else if tyvar = Ident.int_tyvar then output_byte 6
d2374 1
a2374 1
      else if tyvar = Ident.word_tyvar then output_byte 11
@


1.141
log
@Add WORD to runtime_env
@
text
@d4 3
d1053 3
d2373 3
@


1.140
log
@Add CHAR constructor in runtime_env
@
text
@d4 3
d1599 1
d3009 2
@


1.139
log
@decode_ and write_ runtime_env used inconsistent string functions
@
text
@d4 3
d1595 1
d3003 2
@


1.138
log
@Modify stamp_module in output_file to use an ordered array
@
text
@d4 3
a525 1
require "../utils/integer";
a548 1
  structure Integer : INTEGER
d599 2
d1523 1
a1523 1
	    fun decode_string ptr = input_opt_string(s, ptr)
@


1.137
log
@Change decode_type_basis to accept a btree
@
text
@d4 3
d2727 7
d2747 25
a2771 1
	    
@


1.136
log
@Use Stamp instead of Tyname_id etc.
@
text
@d4 3
a861 2
	val sub_modules = map (fn (modname,(a,b)) =>
			      (modname,a)) sub_modules
d866 2
a867 1
	val sub_modules' =
d871 1
d873 2
a874 2
	val (_, stamp_count) =
	  case NewMap.tryApply'(sub_modules', name) of
d878 1
a878 1
		("",Basis.pervasive_stamp_count)
d881 9
d891 1
a891 1
	  case NewMap.tryApply'(sub_modules', sub_name) of
d895 1
a895 1
		("", Basis.pervasive_stamp_count)
d900 1
a900 1
		 "Unknown module " ^ sub_name)
d958 1
a958 1
		  val (_, stamp_count) = name_offsets module
d988 1
a988 1
		  val (_,stamp_count) = name_offsets module
d1019 1
a1019 1
		  val (_,stamp_count) = name_offsets module
@


1.135
log
@Changes to debugger types
@
text
@d4 3
d524 1
d546 1
d572 2
a578 3
    structure Strname_id = Datatypes.Strname_id
    structure Tyname_id = Datatypes.Tyname_id
    structure Tyfun_id = Datatypes.Tyfun_id
d859 2
a860 2
	val sub_modules = map (fn (modname,(a,b),(c,d),(e,f)) =>
			      (modname,a,c,e)) sub_modules
d868 1
a868 1
	  (map (fn (elt as (name, _, _, _)) => (name, elt)) sub_modules)
d870 1
a870 1
	val (_, tyname_count,strname_count,tyfun_count) =
d875 1
a875 4
		("",
                 Basis.pervasive_tyname_count,
		 Basis.pervasive_strname_count,
		 Basis.pervasive_tyfun_count)
d883 1
a883 4
		("",
                 Basis.pervasive_tyname_count,
		 Basis.pervasive_strname_count,
		 Basis.pervasive_tyfun_count)
d932 1
a932 1
		in (Tyname_id.make_tyname_n n, ptr)
d938 1
a938 1
		in (Tyname_id.make_tyname_n (tyname_count + n), ptr)
d946 1
a946 1
		  val (_, tyname_count,_,_) = name_offsets module
d948 1
a948 1
		  (Tyname_id.make_tyname_n (tyname_count + n), ptr)
d962 1
a962 1
		in (Tyfun_id.make_tyfun_n n, ptr)
d968 1
a968 1
		in (Tyfun_id.make_tyfun_n (tyfun_count + n), ptr)
d976 1
a976 1
		  val (_, _,_,tyfun_count) = name_offsets module
d978 1
a978 1
		  (Tyfun_id.make_tyfun_n (tyfun_count + n), ptr)
d993 1
a993 1
		in (Strname_id.make_strname_n n, ptr)
d999 1
a999 1
		in (Strname_id.make_strname_n (strname_count + n), ptr)
d1007 1
a1007 1
		  val (_, _,strname_count,_) = name_offsets module
d1009 1
a1009 1
		  (Strname_id.make_strname_n (strname_count + n), ptr)
d1812 2
a1814 2
	    else
	      decode_debug (fn ptr=>(RuntimeEnv.EMPTY,ptr)) ptr
a2048 3
	  val (tynames,     ptr) = input_int(header, ptr)
	  val (strnames,    ptr) = input_int(header, ptr)
	  val (tyfuns,      ptr) = input_int(header, ptr)
d2050 1
d2056 1
a2056 1
	       tynames = tynames, strnames = strnames, tyfuns = tyfuns,
d2082 1
a2082 1
	    val {cons_size, tynames, strnames, tyfuns, ...} =
d2090 1
a2090 1
	    {tynames = tynames, strnames = strnames, tyfuns = tyfuns,
d2115 1
a2115 1
	    raise BadInput ("Corrupt object file (4): " ^ s ^ filename)
d2122 1
a2122 1
	       lambda_size, tynames, strnames, tyfuns, strings} =
d2134 1
a2134 1
	       tynames = tynames, strnames = strnames, tyfuns = tyfuns}
d2159 1
a2159 1
	    Strname_id.Map.iterate (fun2 o #2) m
d2161 1
a2161 1
	    Tyfun_id.Map.iterate (fun2 o #2) m
d2374 1
a2374 1
      {filename, code, tynames, strnames, tyfuns, parser_env, lambda_env,
d2712 1
a2712 15
	    fun tyname_module (n : int) =
	      let
		fun search [] = Crash.impossible ("tyname_module")
		  | search ((module,(tyname_count,tyname_no),_,_)::rest) =
		    if not (n >= tyname_count andalso
			    n < (tyname_count + tyname_no))
		      then search rest
		    else
		      (module,tyname_count,rest)
		val (module,tyname_count,rest) = search sub_modules
	      in
		(module, n - tyname_count)
	      end
	    
	    fun strname_module (n : int) =
d2714 4
a2717 4
		fun search [] = Crash.impossible ("strname_module")
		  | search ((module,_,(strname_count,strname_no),_)::rest) =
		    if not (n >= strname_count andalso
			    n < (strname_count + strname_no))
d2720 2
a2721 2
		      (module,strname_count,rest)
		val (module,strname_count,rest) = search sub_modules
d2723 1
a2723 1
		(module, n - strname_count)
a2725 16
	    fun tyfun_module (n : int) =
	      let
		fun search [] = Crash.impossible ("tyfun_module")
		  | search ((module,_,_,(tyfun_count,tyfun_no))::rest) =
		    if not (n >= tyfun_count andalso
			    n < (tyfun_count + tyfun_no))
		      then search rest
		    else
		      (module,tyfun_count,rest)
		val (module,tyfun_count,rest) = search sub_modules
	      in
		(module, n - tyfun_count)
	      end
	    
	    val tynames_encoded = ref [] : Tyname_id.Tyname_id list ref
	      
d2727 3
a2729 4
	    fun strname_hash(Datatypes.STRNAME id) =
	      Datatypes.Strname_id.strname_id id
	      | strname_hash(Datatypes.NULLNAME id) =
		Datatypes.Strname_id.strname_id id
d2759 1
a2759 1
	      let val id = Tyname_id.tyname_id n
d2761 1
a2761 1
		if id < Basis.pervasive_tyname_count then
d2765 1
a2765 1
		    val (module,id') = tyname_module id
d2776 1
a2776 1
	      let val id = Strname_id.strname_id n
d2778 1
a2778 1
		if id < Basis.pervasive_strname_count then
d2781 1
a2781 1
		  let val (module,id') = strname_module id
d2792 1
a2792 1
	      let val id = Tyfun_id.tyfun_id n
d2794 1
a2794 1
		if id < Basis.pervasive_tyfun_count then
d2797 1
a2797 1
		  let val (module,id') = tyfun_module id
d3268 6
a3273 1
	      (case NewHashTable.lookup_default(strhashtable, 0, str) of
d3447 2
a3448 5
	  (getpos(), (write_dummies 5;
		      write_int tynames;
		      write_int strnames;
		      write_int tyfuns;
		      write_int 0),
a3470 1
	seek (header_start + 4 * 8);
@


1.134
log
@Moving pervasive name counts to Basis
@
text
@d4 3
a513 1
require "../utils/print";
a514 1
require "../utils/diagnostic";
a536 1
  structure Print : PRINT
a537 1
  structure Diagnostic : DIAGNOSTIC
d558 1
a558 2
  sharing Types.Datatypes.NewMap = ParserEnv.Map = Debugger_Types.NewMap
    = EnvironTypes.NewMap
a576 1
    structure Diagnostic = Diagnostic
d1542 1
d1545 1
a1545 1
				   decode_spill (fn ptr => (Option.ABSENT,ptr))
d1784 4
a1787 6
            val (map,ptr) =
              input_newmap (s, decode_string,
                            decode_funinfo,
                            ptr,
                            String.<,
                            op =)
d1789 1
a1789 1
            (Debugger_Types.INFO map,ptr)
d2379 1
a2379 1
       type_basis, debug_info = Debugger_Types.INFO debug_info, require_list,
d2693 1
a2693 1
			     debug_information, sub_modules) =
d3371 3
a3373 9
	    fun write_debug write_runtime_env =
	      write_newmap write_opt_string write_funinfo
(*
	      (write_triple
	       (write_triple (fn ty => do_output(encode_type([], ty)))
		write_bool
		(write_assoc write_opt_int write_recipe))
	       write_runtime_env write_bool)
*)
d3388 1
a3388 1
			debug_information);
@


1.133
log
@Rationalizing debugger
@
text
@d4 3
a520 1
require "../typechecker/strenv";
a542 1
  structure Strenv : STRENV
d874 4
a877 3
		("",Types.pervasive_tyname_count,
		 Strenv.pervasive_strname_count,
		 Types.pervasive_tyfun_count)
d885 4
a888 3
		("",Types.pervasive_tyname_count,
		 Strenv.pervasive_strname_count,
		 Types.pervasive_tyfun_count)
d2800 1
a2800 1
		if id < Types.pervasive_tyname_count then
d2817 1
a2817 1
		if id < Strenv.pervasive_strname_count then
d2833 1
a2833 1
		if id < Types.pervasive_tyfun_count then
@


1.132
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d1516 19
d1550 1
a1550 12
                   (fn ptr =>
                    I RuntimeEnv.VARINFO
                    (decode_option
                     (input_triple 
                      decode_string
                      (fn ptr =>
		       I (fn t =>
			  (ref t, ref (RuntimeEnv.RUNTIMEINFO
				       (Option.ABSENT,nil))))
		       (decode_type ptr))
                      (decode_option decode_spill))
                     ptr))
d1727 1
a1727 1
	      0 => (Debugger_Types.Nop,ptr)
d1730 1
a1730 1
		in (Debugger_Types.Select arg,ptr)
d1735 1
a1735 1
		in (Debugger_Types.MakeRecord args,ptr)
d1739 1
a1739 1
		in (Debugger_Types.Funarg arg,ptr)
d1743 1
a1743 1
		in (Debugger_Types.Funres arg,ptr)
d1747 1
a1747 1
		in (Debugger_Types.MakeFunType arg,ptr)
d1751 1
a1751 1
		in (Debugger_Types.DeCons arg,ptr)
d1757 1
a1757 1
		in (Debugger_Types.MakeConsType arg,ptr)
d1759 1
a1759 1
	    | 8 => (Debugger_Types.Error,ptr)
d1763 17
a1779 1
	fun foo ptr = input_list(s, input_pair decode_int decode_recipe, ptr)
d1782 10
a1791 10
	  input_newmap (s, decode_string,
			input_triple
			(input_triple
			 decode_type
			 decode_bool
			 foo)
			decode_runtime_env decode_bool,
			ptr,
			String.<,
			op =)
d1815 1
a1815 1
	      (NewMap.empty (fn _ => false,fn _ => true),ptr)
d3004 13
a3016 10
			  (write_list (write_pair
				       (fn RuntimeEnv.VARINFO info =>
					(write_option 
					 (write_triple 
					  write_sz_string
					  (fn (ref ty,_) =>
					   do_output(encode_type([],ty)))
					  (write_option write_spill))
					 info))
				       write_runtime_env))
d3344 1
a3344 1
		Debugger_Types.Nop =>
d3346 1
a3346 1
	      | Debugger_Types.Select(x,y) =>
d3348 1
a3348 1
	      | Debugger_Types.MakeRecord args =>
d3351 1
a3351 1
	      | Debugger_Types.Funarg arg =>
d3353 1
a3353 1
	      | Debugger_Types.Funres arg =>
d3355 1
a3355 1
	      | Debugger_Types.MakeFunType(x,y) =>
d3357 1
a3357 1
	      | Debugger_Types.DeCons(x,y) =>
d3359 1
a3359 1
	      | Debugger_Types.MakeConsType(x, y) =>
d3362 1
a3362 1
	      | Debugger_Types.Error =>
d3364 8
a3371 1
		  
d3373 2
a3374 1
	      write_newmap write_opt_string
d3380 1
@


1.131
log
@Rationalizing data structures
@
text
@d4 3
d867 1
a867 1
	    NewMap.YES elt => elt
d877 1
a877 1
	    NewMap.YES x => x
d3246 1
a3246 1
		  NewMap.YES list =>
@


1.130
log
@Reorganise the whole file so it's more legible.
Also buffer output.
@
text
@d4 4
d506 1
d545 1
d586 5
d853 1
a853 2
	val decfuntypehashtable =
	  NewHashTable.new(4000,op = : int * int -> bool, fn x => x)
d1078 2
a1079 3
	fun makehashtable () = 
	  NewHashTable.new(128,(op = : int * int -> bool),fn x => x)
	(* Any old type will do *)
d1113 1
a1113 1
			NewHashTable.update(strnamehashtable, n, strname)
d1118 1
a1118 1
		    (NewHashTable.lookup(strnamehashtable, n), ptr)
d1188 1
a1188 1
		      val _ = NewHashTable.update (metatyvarhashtable, n, ty)
d1193 1
a1193 1
		    (NewHashTable.lookup(metatyvarhashtable, i), ptr)
d1208 1
a1208 1
		      val _ = NewHashTable.update (metaoverloadedhashtable, n, ty)
d1213 1
a1213 1
		    (NewHashTable.lookup(metaoverloadedhashtable, i), ptr)
d1226 1
a1226 1
		      val _ = NewHashTable.update (tyvarhashtable, n, ty)
d1231 1
a1231 1
		    (NewHashTable.lookup(tyvarhashtable, i), ptr)
d1246 1
a1246 1
		      val _ = NewHashTable.update (metarectypehashtable, n, ty)
d1251 1
a1251 1
		    (NewHashTable.lookup(metarectypehashtable, i), ptr)
d1264 1
a1264 1
		      val _ = NewHashTable.update (rectypehashtable, n, ty)
d1269 1
a1269 1
		    (NewHashTable.lookup(rectypehashtable, i), ptr)
d1282 1
a1282 1
		      val _ = NewHashTable.update(decfuntypehashtable,c, ty)
d1287 1
a1287 1
		    (NewHashTable.lookup (decfuntypehashtable,i), ptr)
d1299 1
a1299 1
		      val _ = NewHashTable.update (constypehashtable, n, ty)
d1304 1
a1304 1
		    (NewHashTable.lookup(constypehashtable, i), ptr)
d1317 1
a1317 1
		      val _ = NewHashTable.update(debruijnhashtable, n, ty)
d1322 1
a1322 1
		    (NewHashTable.lookup(debruijnhashtable, i), ptr)
d1337 1
a1337 1
		val _ = NewHashTable.update(valenvhashtable, n, valenv)
d1348 1
a1348 1
		  (NewHashTable.lookup(valenvhashtable, n), ptr)
d1385 1
a1385 1
		      NewHashTable.update
d1390 1
a1390 1
		    (ref(NewHashTable.lookup(tynamevalenvhashtable, n)), ptr)
d1422 1
a1422 1
			      NewHashTable.update (tynamehashtable, n, tyname)
d1428 1
a1428 1
		      val _ = NewHashTable.update (tynamehashtable, n, tyname)
d1433 1
a1433 1
		    (NewHashTable.lookup(tynamehashtable, n), ptr)
d1799 1
a1799 1
    | NewHashTable.Lookup => raise TypeDecapError 4
d1817 2
a1818 2
	  val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	    (int, (Ident.ValId, EnvironTypes.comp)NewMap.T) NewMap.T ref
d1853 1
a1853 1
		      val_map := NewMap.define(!val_map, new_num, val_env);
d1857 1
a1857 1
		| (valnum, ptr) => (NewMap.apply'(!val_map, valnum), ptr)
d1891 1
a1891 2
	  val fix_map = (ref(NewMap.empty' ((op<) : int * int -> bool))) :
	    (int, (Symbol.Symbol, ParserEnv.Fixity) NewMap.T) NewMap.T ref
d1893 1
a1893 2
	  val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	    (int, ParserEnv.pVE) NewMap.T ref
d1931 1
a1931 1
		    fix_map := NewMap.define(!fix_map, new_num, fix_env);
d1935 1
a1935 1
		  (NewMap.apply'(!fix_map, fixnum), ptr)
d1954 1
a1954 1
		     val_map := NewMap.define(!val_map, new_num, val_env);
d1958 1
a1958 1
		  (NewMap.apply'(!val_map, valnum), ptr)
d2074 1
a2074 1
	| NewHashTable.Lookup => (close_in file_handle; raise Error)
d2120 1
a2120 1
	| NewHashTable.Lookup => (close_in file_handle; error "lookup")
d2437 1
a2437 1
	  val encodeMap = ref (NewMap.empty' String.<)
d2532 2
a2533 2
	    val valhashtable = NewHashTable.new(128,op =,hash)
	    val fixhashtable = NewHashTable.new(128,op =,hash)
d2607 1
a2607 1
	    val lambdavalhashtable = NewHashTable.new(128,op =,hash)
d2667 1
a2667 1
	      ref((NewMap.empty' Ident.tycon_lt) :
d2674 1
a2674 1
	      NewHashTable.new(4000,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
d2676 1
a2676 1
	      NewHashTable.new(200,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
d2678 1
a2678 1
	      NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
d2680 1
a2680 1
	      NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
d2682 1
a2682 1
	      NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
d2684 1
a2684 1
	      NewHashTable.new(4000,Enc_Sub.tyname_valenv_same,
d2739 1
a2739 1
	      NewHashTable.new(512, op=, strname_hash)
d3267 1
a3267 1
	    val strhashtable = NewHashTable.new(100, str_eq, str_hash)
@


1.129
log
@Abstraction of debug information
@
text
@d4 3
d580 3
a582 1
    val domydebug = false
d584 2
a585 7
    fun lookup (n,a,b) =
      NewHashTable.lookup (a,b)
(*
    handle exn as NewHashTable.Lookup =>
      (output(std_out,Integer.makestring n ^ " - Lookup failed for " ^ Integer.makestring b ^ "\n");
       raise exn)
*)
d587 1
a587 1
    fun add_together_ords(s,x) =
d593 1
a593 1
	add_together_ords'(size s - 1, x)
d596 1
a596 8
    datatype DelayedEvaluation =
      STRING of string
      | SYMBOL of Symbol.Symbol
      | OPTINT of int
      | BYTE of int
      | INT of int

    fun make_concat(x,y) = STRING(x ^ y)
d599 16
a614 7
    fun CorruptFile n = BadInput ("Corrupt object file - " ^ Integer.makestring n)

    val do_timings = ref false
    val print_stats = false
    val print_hash_table_stats = ref(false)

    fun diagnose_counts str = Diagnostic.output 1 (fn i => [str])
d616 1
a616 1
    fun diagnose_calls str = Diagnostic.output 2 (fn i => [str])
d618 1
a618 1
    fun diagnose_consistency str = Diagnostic.output 3 (fn i => [str])
a619 11
    fun diagnose_sizes str = Diagnostic.output 4 (fn i => [str])

    fun string_list_sub(n, []) = n
      | string_list_sub(n, str :: rest) = string_list_sub(n + size str, rest)

    fun string_list_size str = string_list_sub(0, str)

    fun output_byte i = BYTE i
    fun output_int i = INT i
    fun optimised_output_int i = OPTINT i

d623 1
a623 1
	  val x = Bits.lshift(String.ordof(s, ptr    )    , 8)
d630 1
a630 2
      fun input_int(s, ptr) =
	(inputi(s, ptr), ptr + 4)
d646 1
a646 2
    fun input_byte(s, ptr) =
      (String.ordof(s, ptr), ptr + 1)
d648 4
d653 2
a654 4
      let
	val (sz, ptr) = input_opt_int(s, ptr)
      in
	(String.substring(s, ptr, sz), ptr + sz)
d657 31
a687 2
    val stringId = ref 1
    val stringMap = ref (Array.array(1, ""))
d689 1
a689 16
    fun input_opt_string (s, ptr) =
      let
	val (id, ptr) = input_opt_int(s, ptr)
      in
	if id = 0 then
	  let
	    val (str, ptr) = input_sz_string(s, ptr)
	    val strId = !stringId
	  in
	    Array.update(!stringMap, strId, str);
	    stringId := strId + 1;
	    (str, ptr)
	  end
	else
	  (Array.sub(!stringMap, id), ptr)
      end
d741 2
d758 4
d778 3
a780 20
    fun input_newmap'(s, f, g, ptr, orderfn) =
      let
	val (count, ptr) = input_opt_int(s, ptr)

	fun dec_sub(0, ptr, m) = (m, ptr)
	  | dec_sub(n, ptr, m) =
	    let
	      val (fval, ptr) = f ptr
	      val (gval, ptr) = g ptr
	    in
	      dec_sub(n-1, ptr, (fval, gval) :: (*done*)m)
	    end
	val (list, ptr) = dec_sub(count, ptr, [])
      in
	(NewMap.from_list' orderfn list, ptr)
      end

    fun input_intmap(s, g, ptr) =
      let
	val (count, ptr) = input_opt_int(s, ptr)
d782 3
a784 11
	fun dec_sub(0, ptr, m) = (m, ptr)
	  | dec_sub(n, ptr, m) =
	    let
	      val (fval, ptr) = input_opt_int(s, ptr)
	      val (gval, ptr) = g ptr
	    in
	      dec_sub(n-1, ptr, (fval, gval) :: (*done*)m)
	    end
	val (list, ptr) = dec_sub(count, ptr, [])
      in
	(IntMap.from_list list, ptr)
d787 3
a789 14
    fun input_tyfunid_map(s, f, g, ptr) =
      let
	val (count, ptr) = input_opt_int(s, ptr)

	fun dec_sub(0, ptr, m) = (m, ptr)
	  | dec_sub(n, ptr, m) =
	    let
	      val (fval, ptr) = f ptr
	      val (gval, ptr) = g ptr
	    in
	      dec_sub(n-1, ptr, Tyfun_id.Map.define(m, fval, gval))
	    end
      in
	dec_sub(count, ptr, Tyfun_id.Map.empty)
d792 3
a794 14
    fun input_strnameid_map(s, f, g, ptr) =
      let
	val (count, ptr) = input_opt_int(s, ptr)

	fun dec_sub(0, ptr, m) = (m, ptr)
	  | dec_sub(n, ptr, m) =
	    let
	      val (fval, ptr) = f ptr
	      val (gval, ptr) = g ptr
	    in
	      dec_sub(n-1, ptr, Strname_id.Map.define(m, fval, gval))
	    end
      in
	dec_sub(count, ptr, Strname_id.Map.empty)
d796 4
a799 52

    fun count_real_objects(count, []) = count
      | count_real_objects(count, Code_Module.WORDSET(Code_Module.WORD_SET{b=w_list, ...}) :: rest) =
	count_real_objects(count + Lists.length w_list, rest)
      | count_real_objects(count, _ :: rest) = count_real_objects(count + 1, rest)

    fun encode_bool false = BYTE 0
      | encode_bool true  = BYTE 1

    fun encode_string(done, s) = STRING(s) :: done

    fun encode_symbol(done, sy) = SYMBOL(sy) :: done

    fun encode_valid(done, Ident.VAR sy) =
      encode_symbol(output_byte 0 :: done, sy)
      | encode_valid(done, Ident.CON sy) =
	encode_symbol(output_byte 1 :: done, sy)
      | encode_valid(done, Ident.EXCON sy) =
	encode_symbol(output_byte 2 :: done, sy)
      | encode_valid _ = Crash.impossible "TYCON':encode_valid:encapsulate"

    fun encode_lab(done, Ident.LAB lab) =
      encode_symbol(done, lab)

    fun encode_tyvar(done, Ident.TYVAR(tyvar, b1, b2)) =
      encode_bool b2 :: encode_bool b1 :: encode_symbol(done, tyvar)

    fun encode_ol_tyvar tyvar =
      if tyvar = Ident.num_tyvar then output_byte 5
      else if tyvar = Ident.int_tyvar then output_byte 6
      else if tyvar = Ident.int_literal_tyvar then output_byte 7
      else if tyvar = Ident.real_tyvar then output_byte 8
      else if tyvar = Ident.real_literal_tyvar then output_byte 9
      else if tyvar = Ident.numtext_tyvar then output_byte 10
      else case tyvar of
	Ident.TYVAR(sym, _, _) =>
	  Crash.impossible
	  ("Bad tyvar in overloaded type: " ^ Symbol.symbol_name sym)

    fun encode_over_loaded (Datatypes.UNARY (_, tv)) =
      [output_byte 1, encode_ol_tyvar tv]
      | encode_over_loaded (Datatypes.BINARY (_, tv)) =
	[output_byte 2, encode_ol_tyvar tv]
      | encode_over_loaded (Datatypes.PREDICATE (_, tv)) =
	[output_byte 3, encode_ol_tyvar tv]

    fun encode_list done f l =
      let
	fun rev_map (done, []) = done
	  | rev_map (done, x :: xs) = rev_map(f(done, x), xs)
      in
	rev_map(optimised_output_int(Lists.length l) :: done, l)
d802 1
a802 1
    fun encode_pair f g (done, (a, b)) = g(f(done, a), b)
d804 1
a804 1
    fun encode_newmap done f g m =
d806 7
a812 1
	val sz = optimised_output_int(NewMap.size m)
d814 1
a814 2
	NewMap.fold_in_rev_order
	(fn (done, a, b) => g(f(done, a), b)) (sz :: done, m)
d817 1
a817 7
    fun encode_map done f g m =
      let
	val sz =
	  optimised_output_int(Lists.length(Map.assoc m))
      in
	Map.Fold (fn a => fn b => fn done => g(f(done, a), b)) (sz :: done) m
      end
d819 1
a819 1
    fun decode_lambda_env s =
d821 8
a828 96
	val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	  (int, (Ident.ValId, EnvironTypes.comp)NewMap.T) NewMap.T ref
	val val_size = ref 0

	val (total_size, ptr) = input_opt_int(s, 0)

	fun decode_symbol ptr =
	  let
	    val (str, ptr) = input_opt_string(s, ptr)
	  in
	    (Symbol.find_symbol str, ptr)
	  end

	fun decode_strid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.STRID sy, ptr)
	  end

	fun decode_funid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.FUNID sy, ptr)
	  end

	fun decode_valid ptr =
	  let
	    val (sy_type, ptr) = input_byte(s, ptr)
	    val (sy, ptr) = decode_symbol ptr
	    val id = case sy_type of
	      0 => Ident.VAR sy
	    | 1 => Ident.CON sy
	    | 2 => Ident.EXCON sy
	    | _ => raise CorruptFile 1
	  in
	    (id, ptr)
	  end

	fun read_env ptr =
	  let
	    val (env_size, ptr) = input_opt_int(s, ptr)

	    fun read_field ptr =
	      (case input_byte(s, ptr) of
		 (0, ptr) =>
		   let
		     val (offset, ptr) = input_opt_int(s, ptr)
		   in
		     (EnvironTypes.FIELD{index = offset, size = env_size}, ptr)
		   end
	       | (1, ptr) =>
		   let
		     val (offset, ptr) = input_opt_int(s, ptr)
		   in
		     (EnvironTypes.PRIM(Pervasives.decode offset), ptr)
		   end
	       | _ => Crash.impossible "Decoding a field - got neither 1 nor 0 ")

	    fun decode_val_env ptr =
	      case input_opt_int(s, ptr) of
		(0, ptr) =>
		  let
		    val (val_env, ptr) =
		      input_newmap(s, decode_valid, read_field, ptr,
				   Ident.valid_lt, Ident.valid_eq)
		    val new_num = !val_size + 1
		  in
		    val_size := new_num;
		    val_map := NewMap.define(!val_map, new_num, val_env);
		    (val_env, ptr)
		  end
	      | (valnum, ptr) =>
		  (NewMap.apply'(!val_map, valnum), ptr)

	    val (v_env, ptr) = decode_val_env ptr
	    val (s_env, ptr) =
	      input_newmap(s, decode_strid, input_triple read_env read_field (fn ptr => (false,ptr)), ptr, Ident.strid_lt, Ident.strid_eq)
	  in
	    (EnvironTypes.ENV(v_env, s_env), ptr)
	  end

	fun read_ftr_range ptr =
	  let
	    val (offset, ptr) = input_opt_int(s, ptr)
	    val (env, ptr) = read_env ptr
	  in
	    ((EnvironTypes.FIELD{index=offset, size=total_size}, env, false),
	     ptr)
	  end

	val (fun_env, ptr) =
	  input_newmap(s, decode_funid, read_ftr_range, ptr, Ident.funid_lt, Ident.funid_eq)
	val (env, _) = read_env ptr

d830 1
a830 151
	EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)
      end

    fun decode_parser_env s =
      let
	val fix_map = (ref(NewMap.empty' ((op<) : int * int -> bool))) :
	  (int, (Symbol.Symbol, ParserEnv.Fixity) NewMap.T) NewMap.T ref
	val fix_size = ref 0
	val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	  (int, ParserEnv.pVE) NewMap.T ref
	val val_size = ref 0

	fun decode_symbol ptr =
	  let
	    val (s, ptr) = input_opt_string(s, ptr)
	  in
	    (Symbol.find_symbol s, ptr)
	  end

	fun decode_valid ptr =
	  let
	    val (sy_type, ptr) = input_byte(s, ptr)
	    val (sy, ptr) = decode_symbol ptr
	    val id = case sy_type of
	      0 => Ident.VAR sy
	    | 1 => Ident.CON sy
	    | 2 => Ident.EXCON sy
	    | _ => raise CorruptFile 2
	  in
	    (id, ptr)
	  end

	fun decode_strid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.STRID sy, ptr)
	  end

	fun decode_funid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.FUNID sy, ptr)
	  end

	fun decode_sigid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.SIGID sy, ptr)
	  end

	fun decode_fixity ptr =
	  let
	    val (fixity, ptr) = input_byte(s, ptr)
	  in
	    case fixity of
	      0 =>
		let
		  val (prec, ptr) = input_byte(s, ptr)
		in
		  (ParserEnv.LEFT prec, ptr)
		end
	    | 1 =>
		let
		  val (prec, ptr) = input_byte(s, ptr)
		in
		  (ParserEnv.RIGHT prec, ptr)
		end
	    | 2 => (ParserEnv.NONFIX, ptr)
	    | _ => raise CorruptFile 2
	  end

	fun decode_rev_list f ptr =
	  let
	    fun dec_sub(0, ptr, done) = (done, ptr)
	      | dec_sub(n, ptr, done) =
		let
		  val (d, ptr) = f ptr
		in
		  dec_sub(n-1, ptr, d :: done)
		end
	    val (count, ptr) = input_opt_int(s, ptr)
	  in
	    dec_sub(count, ptr, [])
	  end

	fun decode_fix_env ptr =
	  let
	    val (fixnum, ptr) = input_opt_int(s, ptr)
	  in
	    case fixnum of
	      0 =>
		let
		  val (fix_env, ptr) =
		    input_newmap(s, decode_symbol, decode_fixity, ptr, Symbol.symbol_lt, Symbol.eq_symbol)
		  val new_num = !fix_size + 1
		in
		  fix_size := new_num;
		  fix_map := NewMap.define(!fix_map, new_num, fix_env);
		  (fix_env, ptr)
		end
	    | _ =>
		(NewMap.apply'(!fix_map, fixnum), ptr)
	  end

	fun error_fn _ = Crash.impossible "Encapsulate.decode_val_env"

	fun decode_val_env ptr =
	  let
	    val (valnum, ptr) = input_opt_int(s, ptr)
	  in
	    case valnum of
	      0 =>
		let
		  val (val_env, ptr) =
		    decode_rev_list decode_valid ptr
		  val val_env =
		    Lists.reducel (fn (pve, valid) => ParserEnv.addValId(error_fn, valid, pve)) (ParserEnv.empty_pVE, val_env)
		  val new_num = !val_size + 1
		in
		  (val_size := new_num;
		   val_map := NewMap.define(!val_map, new_num, val_env);
		   (val_env, ptr))
		end
	    | _ =>
		(NewMap.apply'(!val_map, valnum), ptr)
	  end

	fun read_parse_env ptr =
	  let
	    val (fix_env, ptr) = decode_fix_env ptr

	    val (val_env, ptr) = decode_val_env ptr

	    val (struct_env, ptr) =
	      input_newmap(s, decode_strid, read_parse_env, ptr, Ident.strid_lt, Ident.strid_eq)
	  in
	    (ParserEnv.E(ParserEnv.FE fix_env, val_env, ParserEnv.SE struct_env),
	     ptr)
	  end

	val (fun_env, ptr) =
	  input_newmap(s, decode_funid, read_parse_env, 0, Ident.funid_lt, Ident.funid_eq)
	val (sig_env, ptr) =
	  input_newmap(s, decode_sigid, read_parse_env, ptr, Ident.sigid_lt, Ident.sigid_eq)
	val (parse_env, _) =
	  read_parse_env ptr
      in
	ParserEnv.B(ParserEnv.F fun_env, ParserEnv.G sig_env, parse_env)
d833 3
a835 12
    fun print_reqlist (require_list) =
      if domydebug
	then
	  (output(std_out,"Requires:\n");
	   Lists.iterate
	   (fn (name,a,b,c) =>
	    output(std_out,name ^ " " ^ Integer.makestring a ^ " " ^ Integer.makestring b ^ " " ^ Integer.makestring c ^ "\n"))
	   require_list)
      else
	()

    fun TypeDecapError n = BadInput ("Corrupt object file (Failed during type decapsulation) - " ^ Integer.makestring n)
d840 4
a843 3
	val sub_modules = map (fn (modname,(a,b),(c,d),(e,f)) => (modname,a,c,e)) sub_modules
	val _ = print_reqlist sub_modules
	val decfuntypehashtable = NewHashTable.new(4000,op = : int * int -> bool, fn x => x)
d857 2
a858 1
		("",Types.pervasive_tyname_count,Strenv.pervasive_strname_count,
d867 2
a868 1
		("",Types.pervasive_tyname_count,Strenv.pervasive_strname_count,
d873 2
a874 1
		(Info.FATAL, Info.Location.FILE name, "Unknown module " ^ sub_name)
d885 5
a889 19
	fun decode_symbol ptr =
	  let
	    val (sy, ptr) = input_opt_string(s, ptr)
	  in
	    (Symbol.find_symbol sy, ptr)
	  end

	fun decode_valid ptr =
	  let
	    val (sy_type, ptr) = input_byte(s, ptr)
	    val (sy, ptr) = decode_symbol ptr
	    val id = case sy_type of
	      0 => Ident.VAR sy
	    | 1 => Ident.CON sy
	    | 2 => Ident.EXCON sy
	    | _ => raise CorruptFile 5
	  in
	    (id, ptr)
	  end
d901 2
a902 4
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.LAB sy, ptr)
d906 2
a907 11
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.TYCON sy, ptr)
	  end

	fun decode_funid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.FUNID sy, ptr)
a909 14
	fun decode_sigid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.SIGID sy, ptr)
	  end

	fun decode_strid ptr =
	  let
	    val (sy, ptr) = decode_symbol ptr
	  in
	    (Ident.STRID sy, ptr)
	  end

d911 1
a911 2
	  let
	    val (i, ptr) = input_byte(s, ptr)
d917 2
a918 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Tyname_id.make_tyname_n n, ptr)
d923 2
a924 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Tyname_id.make_tyname_n (tyname_count + n), ptr)
d941 1
a941 2
	  let
	    val (i, ptr) = input_byte(s, ptr)
d947 2
a948 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Tyfun_id.make_tyfun_n n, ptr)
d953 2
a954 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Tyfun_id.make_tyfun_n (tyfun_count + n), ptr)
d978 2
a979 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Strname_id.make_strname_n n, ptr)
d984 2
a985 4
		let
		  val (n, ptr) = input_opt_int(s, ptr)
		in
		  (Strname_id.make_strname_n (strname_count + n), ptr)
d1029 1
a1029 13
	fun decode_rev_list f ptr =
	  let
	    fun dec_sub(0, ptr, done) = (done, ptr)
	      | dec_sub(n, ptr, done) =
		let
		  val (d, ptr) = f ptr
		in
		  dec_sub(n-1, ptr, d :: done)
		end
	    val (count, ptr) = input_opt_int(s, ptr)
	  in
	    dec_sub(count, ptr, [])
	  end
d1044 2
a1045 1
	  ref (NewMap.empty (decode_order,op =)) : (int, Datatypes.Tyname ref)NewMap.T ref
d1049 2
a1050 1
			       0, ref false, ref Datatypes.empty_valenv,ref false)
d1066 4
d1071 11
a1081 12
	val strnames_so_far = ref 0
	val strnamehashtable = NewHashTable.new(128,(op = : int * int -> bool),fn x => x)
	val metatyvarhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val metaoverloadedhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val tyvarhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val metarectypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val rectypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val constypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val debruijnhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val valenvhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val tynamevalenvhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
	val tynamehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
d1109 1
a1109 1
		    (lookup(1,strnamehashtable, n), ptr)
d1129 1
a1129 2
		let
		  val (tyfunid, ptr) = decode_tyfun_id ptr
d1131 4
a1134 1
		  (Datatypes.NULL_TYFUN(tyfunid,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0)))), ptr)
d1152 2
a1153 5
		let
		  val (ty, ptr) = decode_type ptr
		in
		  (Datatypes.UNBOUND_SCHEME(ty,Option.ABSENT),
		   ptr)
d1156 2
a1157 4
		let
		  val (over, ptr) = decode_over_loaded ptr
		in
		  (Datatypes.OVERLOADED_SCHEME over, ptr)
d1168 1
a1168 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1184 1
a1184 1
		    (lookup(2,metatyvarhashtable, i), ptr)
d1187 1
a1187 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1204 1
a1204 1
		    (lookup(3,metaoverloadedhashtable, i), ptr)
d1207 1
a1207 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1222 1
a1222 1
		    (lookup(4,tyvarhashtable, i), ptr)
d1225 1
a1225 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1242 1
a1242 1
		    (lookup(5,metarectypehashtable, i), ptr)
d1252 3
a1254 2
		      val (ty,ptr) = I Datatypes.RECTYPE (decode_map decode_lab
							  decode_type ptr Ident.lab_order)
d1260 1
a1260 1
		    (lookup(6,rectypehashtable, i), ptr)
d1278 1
a1278 1
		    (lookup (7,decfuntypehashtable,i), ptr)
d1281 1
a1281 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1295 1
a1295 1
		    (lookup(8,constypehashtable, i), ptr)
d1298 1
a1298 2
		let
		  val (i, ptr) = input_opt_int(s, ptr)
d1313 1
a1313 1
		    (lookup(9,debruijnhashtable, i), ptr)
d1339 1
a1339 1
		  (lookup(10,valenvhashtable, n), ptr)
d1369 3
a1371 1
			input_newmap(s, decode_valid, decode_dummy_scheme, ptr, Ident.valid_lt, Ident.valid_eq)
d1381 1
a1381 1
		    (ref(lookup(11,tynamevalenvhashtable, n)), ptr)
d1410 2
a1411 1
				Datatypes.TYNAME(tyname_id,st,i,b,valenv,Option.ABSENT,is_abs,valenv)
d1424 1
a1424 1
		    (lookup(12,tynamehashtable, n), ptr)
d1443 4
a1446 2
			      input_quadruple decode_string (fn ptr =>input_opt_int(s, ptr))
			      (I ref o decode_bool) (I ref o decode_bool) ptr
d1450 3
a1452 6
			       (fn valenv =>
				let
				  val tyname = Datatypes.METATYNAME(tf, st, i, b, valenv, is_abs)
				in
				  r := tyname
				end)) decode_tyfun ptr
d1457 6
a1462 4
			  input_sixtuple decode_tyfun decode_string
			  (fn ptr =>input_opt_int(s, ptr)) (I ref o decode_bool)
			  decode_tyname_valenv (I ref o decode_bool) ptr
		      val tyname = Datatypes.METATYNAME(tf, st, i, b, valenv, is_abs)
d1482 1
a1482 2
		     let
		       val (i, ptr) = input_byte ptr
d1488 2
a1489 1
			| _ => Crash.impossible "decode_spill:decode_runtime_env:encapsulate")
d1492 1
a1492 6
	    fun decode_string ptr =
	      let
		val (size, ptr) = input_int ptr
	      in
		(String.substring(s, ptr, size), ptr + size)
	      end
d1494 1
a1494 2
	      let
		val (i, ptr) = input_byte ptr
d1504 3
a1506 2
	      1 => I RuntimeEnv.APP(input_triple decode_runtime_env decode_runtime_env
				      (decode_option input_int) ptr)
d1508 4
a1511 2
	    | 3 => I RuntimeEnv.FN(input_quadruple decode_string decode_runtime_env decode_spill
				     (fn ptr => (Option.ABSENT,ptr)) ptr)
d1521 5
a1525 1
                      (fn ptr => I (fn t => (ref t,ref (RuntimeEnv.RUNTIMEINFO (Option.ABSENT,nil)))) (decode_type ptr))
d1530 4
a1533 2
	    | 5 => I RuntimeEnv.HANDLE(input_fivetuple decode_runtime_env decode_spill
					 input_int input_int decode_runtime_env ptr)
d1535 2
a1536 1
	    | 7 => I RuntimeEnv.SELECT(input_pair input_int decode_runtime_env ptr)
d1554 2
a1555 2
		      | _ =>
			  Crash.impossible "decode_tag:decode_runtime_env:decode_type_basis:encapsulate"
d1560 2
a1561 2
	    | _ =>
		Crash.impossible "decode_runtime_env:decode_type_basis:encapsulate"
d1580 2
a1581 1
		  input_newmap(s, decode_tycon, decode_tystr, ptr, Ident.tycon_lt, Ident.tycon_eq)
d1624 2
a1625 1
	      input_newmap(s, decode_strid, decode_str, ptr, Ident.strid_lt, Ident.strid_eq)
d1649 2
a1650 1
	      input_newmap(s, decode_sigid, decode_sigma, ptr, Ident.sigid_lt, Ident.sigid_eq)
d1667 2
a1668 1
	      input_newmap(s, decode_funid, decode_phi, ptr, Ident.funid_lt, Ident.funid_eq)
d1673 1
a1673 2
	fun decode_int ptr =
	  input_opt_int(s, ptr)
d1706 2
a1707 4
		let
		  val (arg,ptr) = input_pair decode_int decode_recipe ptr
		in
		  (Debugger_Types.Select arg,ptr)
d1710 3
a1712 4
		let
		  val (args,ptr) = input_list(s, input_pair decode_string decode_recipe, ptr)
		in
		  (Debugger_Types.MakeRecord args,ptr)
d1715 2
a1716 4
		let
		  val (arg,ptr) = decode_recipe ptr
		in
		  (Debugger_Types.Funarg arg,ptr)
d1719 2
a1720 4
		let
		  val (arg,ptr) = decode_recipe ptr
		in
		  (Debugger_Types.Funres arg,ptr)
d1723 2
a1724 4
		let
		  val (arg,ptr) = input_pair decode_recipe decode_recipe ptr
		in
		  (Debugger_Types.MakeFunType arg,ptr)
d1727 2
a1728 4
		let
		  val (arg,ptr) = input_pair decode_int decode_recipe ptr
		in
		  (Debugger_Types.DeCons arg,ptr)
d1731 4
a1734 4
		let
		  val (arg,ptr) = input_pair (fn ptr => input_list(s, decode_recipe, ptr)) decode_tyname ptr
		in
		  (Debugger_Types.MakeConsType arg,ptr)
a1739 14
	fun decode_rev_list f ptr =
	  let
	    fun dec_sub(0, ptr, done) = (done, ptr)
	      | dec_sub(n, ptr, done) =
		let
		  val (d, ptr) = f ptr
		in
		  dec_sub(n-1, ptr, d :: done)
		end
	    val (count, ptr) = input_opt_int(s, ptr)
	  in
	    dec_sub(count, ptr, [])
	  end

d1760 2
a1761 1
	    ((Nameset.empty_nameset(),BasisTypes.FUNENV(NewMap.empty (fn _ => false,fn _ => true)),
d1763 4
a1766 3
	      Datatypes.ENV(Datatypes.SE(NewMap.empty (fn _ => false,fn _ => true)),
			    Datatypes.TE(NewMap.empty (fn _ => false,fn _ => true)),
			    Datatypes.empty_valenv)),
d1769 2
a1770 1
	    input_quadruple decode_nameset decode_funenv decode_sigenv decode_env ptr
a1782 6

	val _ =
	  if !print_hash_table_stats then
	    output(std_out,"DecFuntypeHashTable in _encapsulate: " ^
		   NewHashTable.string_hash_table_stats(decfuntypehashtable) ^ "\n")
	  else ()
d1792 2
a1793 15
    fun reset_refs(BasisTypes.BASIS(_, nameset, funenv, sigenv, env), value) =
      let
	fun reset_map_range fun2 m =
	  Lists.iterate (fun2 o #2) (Map.assoc m)
	fun reset_newmap_range fun2 m =
	  NewMap.iterate (fun2 o #2) m
	fun reset_strnameid_map_range fun2 m =
	  Strname_id.Map.iterate (fun2 o #2) m
	fun reset_tynameid_map_range fun2 m =
	  Tyfun_id.Map.iterate (fun2 o #2) m
	fun reset_tyname_id n = ()
	fun reset_strname_id n = ()
	fun reset_strname(Datatypes.STRNAME s) = reset_strname_id s
	  | reset_strname(Datatypes.METASTRNAME s) = ()
	  | reset_strname(Datatypes.NULLNAME s) = reset_strname_id s
d1795 82
a1876 10
	fun reset_valenv(Datatypes.VE(r, M)) =
	  let
	    val n = !r
	  in
	    if n = value then
	      ()
	    else
	      (r := value;
	       reset_newmap_range reset_typescheme M)
	  end
d1878 99
a1976 137
	and reset_tyname(Datatypes.TYNAME(ti, s, n, r as ref b, ref ve,_,_,_)) =
	  (reset_tyname_id ti;
	   reset_valenv ve)
	  | reset_tyname(Datatypes.METATYNAME(ref tf, s, n, ref b, ref ve, _)) =
	    (reset_tyfun tf;
	     reset_valenv ve)

	and reset_type(Datatypes.METATYVAR(ref(n, t,_), b1, b2)) =
	  reset_type t
	  | reset_type(Datatypes.META_OVERLOADED{1=ref t, ...}) =
	    reset_type t
	  | reset_type(Datatypes.TYVAR(ref (n,_,_), t)) = ()
	  | reset_type(Datatypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
	    reset_type t
	  | reset_type(Datatypes.RECTYPE M) =
	    reset_map_range reset_type M
	  | reset_type(Datatypes.FUNTYPE(t1, t2)) =
	    (reset_type t1;
	     reset_type t2)
	  | reset_type(Datatypes.CONSTYPE(l, t)) =
	    (Lists.iterate reset_type l;
	     reset_tyname t)
	  | reset_type(Datatypes.DEBRUIJN(n, b1, b2,_)) = ()
	  | reset_type(Datatypes.NULLTYPE) = ()

	and reset_typescheme(Datatypes.SCHEME(n, (t,_))) =
	  reset_type t
	  | reset_typescheme(Datatypes.UNBOUND_SCHEME (t,_)) =
	    reset_type t
	  | reset_typescheme(Datatypes.OVERLOADED_SCHEME _) = ()

	and reset_tyfun(Datatypes.TYFUN(t, n)) =
	  reset_type t
	  | reset_tyfun(Datatypes.ETA_TYFUN tn) =
	    reset_tyname tn
	  | reset_tyfun(Datatypes.NULL_TYFUN tfi) = ()

	and reset_tystr(Datatypes.TYSTR(tf, ve)) =
	  (reset_tyfun tf;
	   reset_valenv ve)

	and reset_tyenv(Datatypes.TE M) =
	  reset_newmap_range reset_tystr M

	and reset_str(Datatypes.STR(sn,_,e)) =
	  (reset_strname sn;
	   reset_env e)
	  | reset_str(Datatypes.COPYSTR((smap,tmap),str)) =
	    (
	     reset_str str;
	     reset_strnameid_map_range reset_strname smap;
	     reset_tynameid_map_range reset_tyname tmap
	     )

	and reset_strenv(Datatypes.SE M) =
	  reset_newmap_range reset_str M

	and reset_env(Datatypes.ENV(se, te, ve)) =
	  (reset_strenv se;
	   reset_tyenv te;
	   reset_valenv ve)

	and reset_sigma(BasisTypes.SIGMA(ns, s)) =
	  (reset_nameset ns;
	   reset_str s)

	and reset_sigenv(BasisTypes.SIGENV M) =
	  reset_newmap_range reset_sigma M

	and reset_phi(BasisTypes.PHI(ns, (s, sg))) =
	  (reset_nameset ns;
	   reset_str s;
	   reset_sigma sg)

	and reset_funenv(BasisTypes.FUNENV M) =
	  reset_newmap_range reset_phi M

	and reset_nameset ns =
	  (Lists.iterate reset_tyname (Nameset.tynames_of_nameset ns);
	   Lists.iterate reset_strname (Nameset.strnames_of_nameset ns))
      in
	(reset_nameset nameset;
	 reset_funenv funenv;
	 reset_sigenv sigenv;
	 reset_env env)
      end

    fun clean_basis basis =
      (reset_refs(basis, ~1);
       reset_refs(basis, 0))

    fun decode_cons s =
      let
	fun decode_time ptr =
	  let
	    val (time_string, ptr) = input_sz_string (s, ptr)
	  in
	    (MLWorks.Time.decode time_string, ptr)
	  end

	fun decode_string ptr = input_sz_string(s, ptr)

	fun decode_cons_triple ptr =
	  let
	    val (mod_name, ptr) = decode_string ptr
	    val (req_name, ptr) = decode_string ptr
	    val (time, ptr) = decode_time ptr
	  in
	    ({mod_name = mod_name, req_name = req_name, time = time}, ptr)
	  end

	val (result, _) =
	  input_list(s, decode_cons_triple, 0)
      in
	result
      end

    fun print_info (filename,tynames,strnames,tyfuns,require_list) =
      if domydebug
	then
	  (output(std_out,filename ^ " " ^ Integer.makestring tynames ^ " " ^ Integer.makestring strnames ^ " " ^ Integer.makestring tyfuns ^ "\n");
	   Lists.iterate
	   (fn (name,a,b,c) =>
	    output(std_out,name ^ " " ^ Integer.makestring a ^ " " ^ Integer.makestring b ^ " " ^ Integer.makestring c ^ "\n"))
	   require_list)
      else ()

    fun output_file debug_variables
      {filename, code, tynames, strnames, tyfuns, parser_env, lambda_env,
       type_basis, debug_info = Debugger_Types.INFO debug_info, require_list, consistency} =
      let
	val file_handle = MLWorks.Internal.FileIO.openf filename
	val close = MLWorks.Internal.FileIO.closef
	val write = MLWorks.Internal.FileIO.writef
	fun seek pos = MLWorks.Internal.FileIO.seekf(file_handle, pos, MLWorks.Internal.FileIO.BEG)

	val fpos = ref 0
d1978 3
a1980 4
	fun write_byte i =
	  (MLWorks.Internal.FileIO.write_byte(file_handle, i); fpos := !fpos + 1)

      fun write_int i =
d1982 18
a1999 4
	  val b1 = Bits.andb(Bits.rshift(i, 24), 255)
	  val b2 = Bits.andb(Bits.rshift(i, 16), 255)
	  val b3 = Bits.andb(Bits.rshift(i,  8), 255)
	  val b4 = Bits.andb(i, 255)
d2001 1
a2001 5
(*
	  write(file_handle, implode[chr b1, chr b2, chr b3, chr b4]);
	  fpos := !fpos + 4
*)
	  write_byte b1; write_byte b2; write_byte b3; write_byte b4
d2004 22
a2025 45
      fun write_dummies x =
	if x = 0 then () else (write_int 0; write_dummies (x-1))

      fun write_opt_int i =
	if i < 254 then
	  write_byte i
	else if i < 65535 then
	  (write_byte 254;
	   write_byte (Bits.andb(Bits.rshift(i, 8), 255));
	   write_byte(Bits.andb(i, 255)))
        else
	  (write_byte 255; write_int i)

      fun write_string s =
	(write(file_handle, s); fpos := !fpos + size s)

      fun write_extended_string s =
	(write(file_handle, s);
	 fpos := !fpos + size s;
	 case Bits.andb(size s, 3) of
	   0 => (write_byte 0; write_byte 0; write_byte 0; write_byte 0)
	 | 1 => (write_byte 0; write_byte 0; write_byte 0)
	 | 2 => (write_byte 0; write_byte 0)
	 | 3 => (write_byte 0)
	 | _ => Crash.impossible "Encapsulate.write_extended_string")

      fun write_sz_string s =
	(write_opt_int(size s); write_string s)

      val total_strings = ref 1
      local
	val id = ref 0
	val encodeId = total_strings
	val encodeMap = ref (NewMap.empty' String.<)
	fun present (_, old, new) = (id := old; old)
	val combine = NewMap.combine present
      in
	fun write_opt_string s =
	  let
	    val new = !encodeId
	  in
	    id := 0;
	    encodeMap := combine (!encodeMap, s, new);
	    if !id = 0 then
	      (encodeId := new + 1; write_opt_int 0; write_sz_string s)
d2027 14
a2040 9
	      write_opt_int (!id)
	  end
      end

      fun write_bool false = write_byte 0
	| write_bool true  = write_byte 1

      fun write_symbol sy =
	write_opt_string(Symbol.symbol_name sy)
d2042 1
a2042 1
      fun do_output object =
d2044 3
a2046 6
	  fun out [] = ()
	    | out (INT(i)::rest) = (write_int i; out rest)
	    | out (BYTE(i)::rest) = (write_byte i; out rest)
	    | out (OPTINT(i)::rest) = (write_opt_int i; out rest)
	    | out (STRING(s)::rest) = (write_opt_string s; out rest)
	    | out (SYMBOL(sy)::rest) = (write_symbol sy; out rest)
d2048 20
a2067 1
	  out(rev object)
d2069 12
a2080 58

      fun write_list f l =
	(write_opt_int(Lists.length l); Lists.iterate f l)

      fun write_pair f g (a, b) =
	(f a; g b)
	
      fun write_triple f g h (a, b, c) =
	(f a; g b; h c)

      fun write_quadruple f g h i (a, b, c, d) =
	(f a; g b; h c; i d)

      fun write_fivetuple f g h i j (a, b, c, d, e) =
	(f a; g b; h c; i d; j e)

      fun write_newmap f g m =
	(write_opt_int(NewMap.size m);
	 NewMap.iterate_ordered (write_pair f g) m)

      fun write_intmap g m =
	(write_opt_int(IntMap.size m);
	 IntMap.iterate_ordered (write_pair write_opt_int g) m)

      fun write_assoc f g a =
	write_list (write_pair f g) a

      fun write_valid (Ident.VAR sy) =
	  (write_byte 0; write_symbol sy)
	| write_valid (Ident.CON sy) =
	  (write_byte 1; write_symbol sy)
	| write_valid (Ident.EXCON sy) =
	  (write_byte 2; write_symbol sy)
        | write_valid _ = Crash.impossible "TYCON':write_valid:encapsulate"

      fun write_sigid (Ident.SIGID sigid) =
	write_symbol sigid

      fun write_funid (Ident.FUNID funid) =
	write_symbol funid

      fun write_strid (Ident.STRID strid) =
	write_symbol strid

      fun write_tycon (Ident.TYCON tycon) =
	write_symbol tycon

      fun write_index (EnvironTypes.FIELD{index, ...}) =
	  write_opt_int index
	| write_index _ = Crash.impossible"write_index not FIELD"

      fun write_index' (EnvironTypes.FIELD{index, ...}) =
          (write_byte 0; write_opt_int index)
	| write_index' (EnvironTypes.PRIM x) =
	  (write_byte 1; write_opt_int (Pervasives.encode x))
	| write_index' _ = Crash.impossible"write_index' not FIELD OR PRIM"

      fun write_code(Code_Module.MODULE element_list) =
d2082 4
a2085 51
	  fun output_module_element(Code_Module.REAL(i, r)) =
	      (write_int ObjectFile.OPCODE_REAL; write_int i;
	       write_int (size r div 4); write_string r)
	    | output_module_element(Code_Module.STRING(i, s)) =
	      (write_int ObjectFile.OPCODE_STRING; write_int i;
	       write_int (size s + 1); write_extended_string s)
	    | output_module_element(Code_Module.MLVALUE(i, s)) =
              Crash.impossible "trying to encapsulate an MLVALUE"
	    | output_module_element(Code_Module.WORDSET(Code_Module.WORD_SET{a_names=str_list, b=w_list, c_leafs=leaf_list, d_intercept=offsets_list,...})) =
	      let
                fun write ([], [], []) = ()
                  | write ({a_clos=i, b_spills=spills, c_saves=saves, d_code=words}::sets, leaf::leafs, offset::offsets) =
		    (write_int i;			(* position in closure *)
		     write_int spills;			(* nr of non-gc spills *)
		     write_int saves;			(* nr of callee save registers *)
		     write_int (if leaf then 1 else 0);	(* leaf flag *)
		     write_int offset;			(* intercept offset *)
		     write_int (size words);		(* the code length *)
		     write_string words;		(* the code *)
		     write (sets, leafs, offsets))
                  | write _ = Crash.impossible"Outputting wordset"
		fun write_names [] = ()
		  | write_names (n::ns) =
		    (write_int (size n + 1);		(* length of name *)
		     write_extended_string n;		(* name of code item *)
		     write_names ns)
		val wordset_size =
                  Lists.reducel (fn (res,{d_code, ...}) => res+size d_code) (0,w_list)
		fun interceptible [] = false
		  | interceptible (off::offs) =
		    off <> ~1 andalso (interceptible offs)
		val interceptible = interceptible offsets_list
	      in
		write_int ObjectFile.OPCODE_CODESET;
                write_int (Lists.length str_list);
                write_int wordset_size;
		write_names str_list;
		write_int (if interceptible then 1 else 0);
                write (w_list, leaf_list, offsets_list)
	      end
            | output_module_element(Code_Module.EXTERNAL(i, s)) =
	      (write_int ObjectFile.OPCODE_EXTERNAL; write_int i;
	       write_int (size s + 1); write_extended_string s)
            | output_module_element(Code_Module.VAR _) =
	      Crash.impossible"Encapsulating interpretive code"
	    | output_module_element(Code_Module.EXN _) =
	      Crash.impossible"Encapsulating interpretive code"
	    | output_module_element(Code_Module.STRUCT _) =
	      Crash.impossible"Encapsulating interpretive code"
	    | output_module_element(Code_Module.FUNCT _) =
	      Crash.impossible"Encapsulating interpretive code"
d2087 27
a2113 5
	  Timer.xtime
	  ("Outputting code", !do_timings, fn () =>
	  (write_int (Lists.length element_list);
           write_int (count_real_objects(0, element_list));
           Lists.iterate output_module_element element_list))
d2115 1
d2117 2
a2118 30
      fun write_parser_env(ParserEnv.B(ParserEnv.F fun_map, ParserEnv.G sig_map, parse_env)) =
	let
          fun hash [] = 0
            | hash ((sy, _) :: _) =
              let
                val str = Symbol.symbol_name sy
              in
                add_together_ords(str,size str)
              end	
          val valhashtable =
            NewHashTable.new(128,op =,hash)

          fun hash [] = 0
            | hash ((sy, _) :: _) =
              let
                val str = Symbol.symbol_name sy
              in
                add_together_ords(str,size str)
              end
	  val fixhashtable = NewHashTable.new(128,op =,hash)

	  val valsize = ref 0
	  val fixsize = ref 0

	  fun write_fixity (ParserEnv.LEFT i) =
	      (write_byte 0; write_byte i)
	    | write_fixity (ParserEnv.RIGHT i) =
	      (write_byte 1; write_byte i)
	    | write_fixity (ParserEnv.NONFIX) =
	      write_byte 2
d2120 1
a2120 19
	  fun write_pe (ParserEnv.E(ParserEnv.FE fix_map, ParserEnv.VE val_map,
                                    ParserEnv.SE struct_map)) =
	    let
	      val fix_list = NewMap.to_list fix_map
	      val fixnum =
		NewHashTable.lookup_default(fixhashtable, 0, fix_list)
	      val _ =
		if fixnum = 0 then
		  let
		    val newsize = !fixsize + 1
		  in
		    fixsize := newsize;
		    NewHashTable.update(fixhashtable, fix_list, newsize);
		    write_opt_int 0;
		    write_assoc write_symbol write_fixity fix_list
		    (*write_newmap write_symbol write_fixity fix_map*)
		  end
		else
		  write_opt_int fixnum
d2122 16
a2137 16
	      val val_list = NewMap.to_list val_map
	      val n = NewHashTable.lookup_default(valhashtable, 0, val_list)
	      val _ =
		if n = 0 then
		  let
		    val newsize = !valsize + 1
		  in
		    valsize := newsize;
		    NewHashTable.update(valhashtable, val_list, newsize);
		    write_opt_int 0;
		    write_list (write_valid o #2) val_list
		    (*write_newmap (fn _ => ()) write_valid val_map*)
		  end
		else
		  write_opt_int n

d2139 5
a2143 1
	      write_newmap write_strid write_pe struct_map
d2145 71
d2217 4
a2220 6
	  Timer.xtime
	  ("outputting parser env", !do_timings,
	   fn () =>
	   (write_newmap write_funid write_pe fun_map;
	    write_newmap write_sigid write_pe sig_map;
	    write_pe parse_env))
d2222 31
d2254 3
a2256 24
      fun write_lambda_env(EnvironTypes.TOP_ENV(env as EnvironTypes.ENV(v, s), EnvironTypes.FUN_ENV fun_env)) =
	let
          fun hash [] = 0
            | hash ((valid, _) :: _) =
              let
                val sy = case valid of
                  Ident.VAR sy => sy
                | Ident.CON sy => sy
                | Ident.EXCON sy => sy
                | _ => Crash.impossible "TYCON':write_lambda_env:encapsulate"
                val str = Symbol.symbol_name sy
              in
                add_together_ords(str,size str)
              end	

          val lambdavalhashtable =
            NewHashTable.new(128,op =,hash)
	  val valsize = ref 0

	  val f_map = NewMap.to_list fun_env
	  val f_len = Lists.length f_map
	  val v_len = NewMap.size v
	  val s_len = NewMap.size s
	  val env_len = v_len + s_len
d2258 1
a2258 21
	  fun write_sub extra (EnvironTypes.ENV(v_map, s_map)) =
	    let
	      val v_list = NewMap.to_list_ordered v_map
	      val s_list = NewMap.to_list s_map
	      val v_len = Lists.length v_list
	      val s_len = Lists.length s_list
	      val env_len = v_len + s_len + extra

	      val vnum =
		NewHashTable.lookup_default(lambdavalhashtable, 0,
						  v_list)
	      val _ =
		if vnum = 0 then
		  let
		    val newsize = !valsize + 1
		  in
		    valsize := newsize;
		    NewHashTable.update(lambdavalhashtable, v_list, newsize)
		  end
		else
		  ()
d2260 7
a2266 5
	    in
	      write_opt_int env_len;
	      write_opt_int vnum; if vnum = 0 then write_assoc write_valid write_index' v_list else ();
	      write_newmap write_strid (write_triple (write_sub 0) write_index' (fn _=> ())) s_map
	    end
d2268 7
d2276 7
a2282 2
	  fun do_ftr_range (field, env, _) =
	    (write_index field; write_sub 0 env)
d2284 1
a2284 12
	  val _ =
	    Timer.xtime
	    ("writing lambda env", !do_timings, fn () =>
	    (write_opt_int (f_len + env_len);
	     write_newmap write_funid do_ftr_range fun_env;
	     write_sub f_len env))
	in
	  if !print_hash_table_stats then
	    output(std_out,"lambdavalhashtable in _encapsulate: "^
		   NewHashTable.string_hash_table_stats(lambdavalhashtable) ^ "\n")
	  else ()
	end
d2286 1
a2286 18
      fun write_type_basis(BasisTypes.BASIS(_, nameset, funenv, sigenv, env),
			   debug_information, sub_modules) =
	let
	  val tyenv_table =
	    ref((NewMap.empty' Ident.tycon_lt) :
		(Ident.TyCon,
		 ((Ident.TyCon, Datatypes.Tystr) NewMap.T * int) list) NewMap.T)
	  val tyenvs = ref 0
(*
	  val tyenv_repeats = ref 0
*)
	  val metatynamehashtable = NewHashTable.new(4000,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
	  val tynamehashtable = NewHashTable.new(200,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
	  val funtypehashtable = NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
	  val constypehashtable = NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
	  val rectypehashtable = NewHashTable.new(4000,Enc_Sub.type_same,Enc_Sub.type_hash)
	  val valenvhashtable =
            NewHashTable.new(4000,Enc_Sub.tyname_valenv_same,Enc_Sub.tyname_valenv_hash)
d2288 7
a2294 7
(*
	  fun gaps (tyname_id:int,_,nil) = tyname_id
	    | gaps (tyname_id,last,("",tyname_count,_,_)::rest) =
	      gaps (tyname_id + last - tyname_count,tyname_count,rest)
	    | gaps (tyname_id,_,(_,tyname_count,_,_)::rest) =
	      gaps (tyname_id,tyname_count,rest)
*)
d2296 2
a2297 29
	  fun tyname_module (n : int) =
	    let
	      fun search [] = Crash.impossible ("tyname_module")
		| search ((module,(tyname_count,tyname_no),_,_)::rest) =
		  if not (n >= tyname_count andalso n < (tyname_count + tyname_no))
                    then search rest
		  else
		    (module,tyname_count,rest)
	      val (module,tyname_count,rest) = search sub_modules
(*
	      val _ = output(std_out, "tyname_module for " ^ MLWorks.Integer.makestring n ^
			     " = '" ^ module ^ "' with count = " ^
			     MLWorks.Integer.makestring tyname_count ^ "\n")
	      val _ = output(std_out, "Submodules =\n")
	      val _ = Lists.iterate
		(fn (name, tyn, strn, tyf) =>
		 output(std_out, "Name = '" ^ name ^
			"', tyn = " ^ MLWorks.Integer.makestring tyn ^
			", strn = " ^ MLWorks.Integer.makestring strn ^
			", tyf = " ^ MLWorks.Integer.makestring tyf ^ "\n"))
		sub_modules
*)
	    in
	      (module,
(*
	       case module of
		 "" => gaps (n - tyname_count,tyname_count,rest)
	       | _ => *)n - tyname_count)
	    end
d2299 2
a2300 7
(*
	  fun gaps (strname_id:int,_,nil) = strname_id
	    | gaps (strname_id,last,("",_,strname_count,_)::rest) =
	      gaps (strname_id + last - strname_count,strname_count,rest)
	    | gaps (strname_id,_,(_,_,strname_count,_)::rest) =
	      gaps (strname_id,strname_count,rest)
*)
d2302 11
a2312 15
	  fun strname_module (n : int) =
	    let
	      fun search [] = Crash.impossible ("strname_module")
		| search ((module,_,(strname_count,strname_no),_)::rest) =
		  if not (n >= strname_count andalso n < (strname_count + strname_no))
		    then search rest
		  else
		    (module,strname_count,rest)
	      val (module,strname_count,rest) = search sub_modules
	    in
	      (module,
	       (*case module of
		 "" => gaps (n - strname_count,strname_count,rest)
	       | _ => *)n - strname_count)
	    end
d2314 6
a2319 7
(*
	  fun gaps (tyfun_id:int,_,nil) = tyfun_id
	    | gaps (tyfun_id,last,("",_,_,tyfun_count)::rest) =
	      gaps (tyfun_id + last - tyfun_count,tyfun_count,rest)
	    | gaps (tyfun_id,_,(_,_,_,tyfun_count)::rest) =
	      gaps (tyfun_id,tyfun_count,rest)
*)
d2321 2
a2322 15
	  fun tyfun_module (n : int) =
	    let
	      fun search [] = Crash.impossible ("tyfun_module")
		| search ((module,_,_,(tyfun_count,tyfun_no))::rest) =
		  if not (n >= tyfun_count andalso n < (tyfun_count + tyfun_no))
                    then search rest
		  else
		    (module,tyfun_count,rest)
	      val (module,tyfun_count,rest) = search sub_modules
	    in
	      (module,
	       (*case module of
		 "" => gaps (n - tyfun_count,tyfun_count,rest)
	       | _ => *)n - tyfun_count)
	    end
d2324 1
a2324 1
	  val tynames_encoded = ref [] : Tyname_id.Tyname_id list ref
d2326 12
a2337 6
	  val strnames_encoded = ref [] : Datatypes.Strname ref list ref
	  fun strname_hash(Datatypes.STRNAME id) =
	    Datatypes.Strname_id.strname_id id
	    | strname_hash(Datatypes.NULLNAME id) =
	      Datatypes.Strname_id.strname_id id
	    | strname_hash(Datatypes.METASTRNAME(ref s)) = strname_hash s
d2339 57
a2395 27
	  val strname_enc_hashtable =
	    NewHashTable.new(512, op=, strname_hash)
	  val strname_enc_count = ref 0

	  val valenv_no = ref 0
	  val metatyvar_types_encoded =
	    ref [] : ((int * Datatypes.Type * Datatypes.Instance) ref
                      * bool * bool) list ref
	  val meta_overloaded_types_encoded = ref [] : Datatypes.Type ref list ref
	  val tyvar_types_encoded = ref [] : (int * Ident.TyVar) list ref
	  val metarectype_types_encoded =
	    ref [] : (int * bool * Datatypes.Type * bool * bool) ref list ref
	  val rectype_types_encoded =
	    ref [] : Datatypes.Type list ref
	  val funtype_types_encoded =
	    ref [] : (Datatypes.Type * Datatypes.Type) list ref
	  val constype_types_encoded = ref [] : Datatypes.Type list ref
	  val debruijn_types_encoded = ref [] : (int * bool * bool) list ref
	  val meta_tynames_encoded = ref [] : Datatypes.Tyname list ref
	  val tyname_valenvs_encoded =
	    ref [] : int ref list ref
	  val meta_tyname_count = ref 0
	  val tyname_count = ref 0
	  val valenv_tyname_count = ref 0
	  val funtype_count = ref 0
	  val constype_count = ref 0
	  val rectype_count = ref 0
d2397 38
a2434 1
	  fun encode_tyname_id (done, n) =
d2436 1
a2436 1
	      val id = Tyname_id.tyname_id n
d2438 4
a2441 2
	      if id < Types.pervasive_tyname_count then
		optimised_output_int id :: output_byte 0 :: done
d2443 1
a2443 8
		let
		  val (module,id') = tyname_module id
		in
		  if module = "" then
		    optimised_output_int id' :: output_byte 1 :: done
		  else
		    optimised_output_int id' :: encode_string (output_byte 2 :: done, module)
		end
d2445 44
d2490 62
a2551 12
	  fun write_strname_id n =
	    let
	      val id = Strname_id.strname_id n
	    in	
	      if id < Strenv.pervasive_strname_count then
		(write_byte 0; write_opt_int id)
	      else
		let
		  val (module,id') = strname_module id
		in
		  if module = "" then
		    (write_byte 1; write_opt_int id')
d2553 14
a2566 16
		    (write_byte 2; write_opt_string module; write_opt_int id')
		end
	    end

	  fun encode_tyfun_id (done, n) =
	    let
	      val id = Tyfun_id.tyfun_id n
	    in	
	      if id < Types.pervasive_tyfun_count then
		optimised_output_int id :: output_byte 0 :: done
	      else
		let
		  val (module,id') = tyfun_module id
		in
		  if module = "" then
		    optimised_output_int id' :: output_byte 1 :: done
d2568 2
a2569 15
		    optimised_output_int id' :: encode_string (output_byte 2 :: done, module)
		end
	    end

	  fun write_tyfun_id id = do_output(encode_tyfun_id([],  id))

	  fun write_strname (Datatypes.STRNAME s) =
	    (write_byte 1; write_strname_id s)
	    | write_strname (Datatypes.METASTRNAME s) =
	      let
		fun es' (h::t) =
		  if h = s then Lists.length t + 1 else es' t
		  | es' [] =
		    (strnames_encoded := (s::(!strnames_encoded)); 0)
		val n = es'(!strnames_encoded)
d2571 1
a2571 2
		write_byte 2; write_opt_int n;
		if n = 0 then write_strname (!s) else ()
d2573 8
a2580 2
	    | write_strname (Datatypes.NULLNAME s) =
	      (write_byte 3; write_strname_id s)
d2582 40
a2621 22
	  fun scheme_type scheme =
	    case Enc_Sub.type_from_scheme scheme of
	      Datatypes.CONSTYPE _ => 1
	    | Datatypes.NULLTYPE => 1
	    | Datatypes.FUNTYPE _ => 2
	    | _ => Crash.impossible"encode_fun_or_cons"

	  fun encode_fun_or_cons(done, scheme) =
	    output_byte(scheme_type scheme) :: done

	  fun encode_tyname_valenv(done, valenv as Datatypes.VE(r, M)) =
	    let
	      val n = !r
	    in
	      if n = 0 then
		let
		  val pos =
		    NewHashTable.lookup_default
		    (valenvhashtable, 0, valenv)
		  val done = optimised_output_int pos :: output_byte 2 :: done
		in
		  if pos = 0 then
d2623 1
a2623 3
		      val c = !valenv_tyname_count + 1
		      val _ = valenv_tyname_count := c
		      val _ = NewHashTable.update(valenvhashtable,valenv, c)
d2625 2
a2626 1
		      encode_newmap done encode_valid encode_fun_or_cons M
d2629 1
a2629 5
		    done
		end
	      else
		optimised_output_int n :: output_byte 1 :: done
	    end
d2631 22
a2652 15
	  and encode_valenv(done, Datatypes.VE(r, M)) =
	    let
	      val n = !r
	      val done = optimised_output_int n :: done
	    in
	      if n = 0 then
		let
		  val m = !valenv_no + 1
		in
		  (valenv_no := m;
		   r := m;
                   encode_newmap done encode_valid encode_typescheme M)
		end
	      else done
	    end
d2654 27
a2680 32
	  and encode_tyname(done, tyn as Datatypes.TYNAME(ti, s, n, ref b, ref ve,_,ref is_abs,_)) =
	    let
	      val pos = NewHashTable.lookup_default(tynamehashtable, 0, tyn)
(*
	      fun et'(h::t) = if h = ti then Lists.length t + 1
			      else et' t
		| et' [] =
		  (tynames_encoded := (ti::(!tynames_encoded)); 0)
	      val pos = et'(!tynames_encoded)
*)
	      val done = optimised_output_int pos :: output_byte 1 :: done
	    in
	      if pos = 0 then
		let
		  val c = !tyname_count + 1
		  val _ = tyname_count := c
		  val _ = NewHashTable.update(tynamehashtable,tyn, c)
		in
		  encode_bool is_abs ::
		  (if debug_variables then encode_valenv
                   else encode_tyname_valenv)
                     (encode_bool b :: optimised_output_int n ::
                      encode_string(encode_tyname_id(done, ti), s),
                      ve)
		end
	      else
		done
	    end

	    | encode_tyname(done,
			    tyn as Datatypes.METATYNAME(ref tf, s, n, ref b,
							ref ve,ref is_abs)) =
d2682 8
a2689 2
		val pos = NewHashTable.lookup_default(metatynamehashtable, 0, tyn)
		val done = optimised_output_int pos :: output_byte 2 :: done
d2691 1
a2691 19
		if pos = 0 then
		  let
		    val c = !meta_tyname_count + 1
		    val _ = meta_tyname_count := c
		    val _ = NewHashTable.update(metatynamehashtable,tyn, c)
		  in
                    if debug_variables then
                      encode_tyfun(encode_valenv
                                   (encode_bool is_abs :: encode_bool b :: optimised_output_int n ::
                                    encode_string(done, s),ve),
                                   tf)
                    else
                      encode_bool is_abs ::
                      (encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
                                            encode_string(encode_tyfun(done, tf), s),
                                            ve))
		  end
		else
		  done
d2693 2
a2694 93

          and write_runtime_env env =
            let
              val write_spill =
                (fn ref(spill)=>
                 (case spill of
                    RuntimeEnv.OFFSET1(spill)=>
                      (write_byte 1; write_int spill)
                  | RuntimeEnv.OFFSET2(spill)=>
                      (write_byte 2; write_int spill)))
              fun write_string s =
                let val size_s = size s
                in
                  (write_int size_s;write(file_handle, s); fpos := !fpos + size_s)
                end
              fun write_option _ (Option.ABSENT) = write_byte 1
                | write_option write_object (Datatypes.Option.PRESENT(object)) =
                  (write_byte 2;write_object object)
              fun write_runtime_env(RuntimeEnv.APP(env)) =
                (write_byte 1;
                 write_triple write_runtime_env write_runtime_env (write_option write_int) env)
                | write_runtime_env(RuntimeEnv.EMPTY) = write_byte 2
                | write_runtime_env(RuntimeEnv.FN(env)) =
                  (write_byte 3;
                   write_quadruple write_string write_runtime_env write_spill (fn _ => ()) env)
                | write_runtime_env(RuntimeEnv.LET(env as (env1,env2))) =
                  (case env2 of
                     RuntimeEnv.LET([env2],env3) =>
                       write_runtime_env(RuntimeEnv.LET(env1@@[env2],env3))
                   | _ =>
                       (write_byte 4;
                        write_pair
                        (write_list (write_pair
                                     (fn RuntimeEnv.VARINFO info =>
                                      (write_option 
                                       (write_triple 
                                        write_string
                                        (fn (ref ty,_) => do_output(encode_type([],ty)))
                                        (write_option write_spill))
                                       info))
                                     write_runtime_env))
                        write_runtime_env env))
                | write_runtime_env(RuntimeEnv.HANDLE(env)) =
                  (write_byte 5;
                   write_fivetuple write_runtime_env write_spill
                   write_int write_int write_runtime_env env)
                | write_runtime_env(RuntimeEnv.RAISE(env)) =
                  (write_byte 6;write_runtime_env env)
                | write_runtime_env(RuntimeEnv.SELECT(env)) =
                  (write_byte 7;
                   write_pair write_int
                   write_runtime_env env)
                | write_runtime_env(RuntimeEnv.STRUCT(envs)) =
                  (write_byte 8;
                   write_list write_runtime_env envs)
                | write_runtime_env(RuntimeEnv.SWITCH(envs)) =
                  (write_byte 9;
                   write_quadruple write_runtime_env write_spill write_int
                   (write_list (write_pair
                                (fn tag =>
                                 case tag of
                                   RuntimeEnv.CONSTRUCTOR(s) => (write_byte 1;write_string s)
                                 | RuntimeEnv.INT(s) => (write_byte 2;write_string s)
                                 | RuntimeEnv.REAL(s) => (write_byte 3;write_string s)
                                 | RuntimeEnv.STRING(s) => (write_byte 4;write_string s)
                                 | RuntimeEnv.DYNAMIC => write_byte 5
                                 | RuntimeEnv.DEFAULT => write_byte 6)
                                write_runtime_env)) envs)
                | write_runtime_env(RuntimeEnv.LIST(envs)) =
                  (write_byte 10;
                   write_list write_runtime_env envs)
                | write_runtime_env(RuntimeEnv.BUILTIN) = write_byte 11
            in
              write_runtime_env env
            end

	  and encode_type(done,
			  Datatypes.METATYVAR(arg as (ref(n, t,_), b1, b2))) =
	    let
	      fun et'(h::t) = if h = arg then Lists.length t + 1
			      else et' t
		| et' [] =
		  (metatyvar_types_encoded := (arg::(!metatyvar_types_encoded)); 0)
	      val pos = et'(!metatyvar_types_encoded)
	      val done = optimised_output_int pos :: output_byte 1 :: done
	    in
	      if pos = 0 then
		encode_bool b2 :: encode_bool b1 ::
		encode_type(optimised_output_int n :: done, t)
	      else
		done
	    end
	    | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t, tv, _, _)) =
d2696 8
a2703 7
		fun et'(h::t) = if h = arg then Lists.length t + 1
				else et' t
		  | et' [] =
		    (meta_overloaded_types_encoded :=
		     (arg::(!meta_overloaded_types_encoded)); 0)
		val pos = et'(!meta_overloaded_types_encoded)
		val done = optimised_output_int pos :: output_byte 2 :: done
d2705 1
a2705 4
		if pos = 0 then
		  encode_ol_tyvar tv :: encode_type(done, t)
		else
		  done
d2707 2
a2708 1
	    | encode_type(done, Datatypes.TYVAR(ref (n,_,_), t)) =
d2710 49
a2758 8
		fun et'((n', t')::tl) =
		  if (*h = arg*) n = n' andalso t =  t' then
		    Lists.length tl + 1
		  else et' tl
		  | et' [] =
		    (tyvar_types_encoded := ((n, t)::(!tyvar_types_encoded)); 0)
		val pos = et'(!tyvar_types_encoded)
		val done = optimised_output_int pos :: output_byte 3 :: done
d2760 19
a2778 2
		if pos = 0 then
		  encode_tyvar(optimised_output_int n :: done, t)
d2780 15
a2794 16
		  done
	      end	
	    | encode_type(done,
			  Datatypes.METARECTYPE(arg as ref(n, b1, t, b2, b3))) =
	      let
		fun et'(h::t) = if h = arg then Lists.length t + 1
				else et' t
		  | et' [] =
		    (metarectype_types_encoded :=
		     (arg::(!metarectype_types_encoded)); 0)
		val pos = et'(!metarectype_types_encoded)
		val done = optimised_output_int pos :: output_byte 4 :: done
	      in
		if pos = 0 then
		  encode_bool b3 :: encode_bool b2 ::
		  encode_type(encode_bool b1 :: optimised_output_int n :: done, t)
d2796 8
a2803 1
		  done
d2805 29
a2833 6
	    | encode_type(done, arg as Datatypes.RECTYPE M) =
	      let
		val pos =
		  NewHashTable.lookup_default
		  (rectypehashtable, 0, arg)
		val done = optimised_output_int pos :: output_byte 5 :: done
d2835 1
a2835 1
		if pos = 0 then
d2837 5
a2841 4
		    val c = !rectype_count + 1
		    val _ = rectype_count := c
		    val _ = if debug_variables then ()
                            else NewHashTable.update(rectypehashtable,arg, c)
d2843 10
a2852 1
		    encode_map done encode_lab encode_type M
d2855 1
a2855 1
                  done
d2857 2
a2858 1
	    | encode_type(done, full_arg as Datatypes.FUNTYPE(arg as (t1, t2))) =
d2860 2
a2861 5
		val pos =
		  NewHashTable.lookup_default
		  (funtypehashtable, 0, full_arg)

		val done = optimised_output_int pos :: output_byte 6 :: done
d2863 1
a2863 1
		if pos = 0 then
d2865 1
a2865 4
		    val c = !funtype_count + 1
		    val _ = funtype_count := c
		    val _ = if debug_variables then ()
                            else NewHashTable.update(funtypehashtable,full_arg, c)
d2867 3
a2869 1
		    encode_type(encode_type(done, t1), t2)
d2871 1
a2871 2
		else
		  done
d2873 4
a2876 1
	    | encode_type(done, arg as Datatypes.CONSTYPE(l, t)) =
d2878 2
a2879 4
		val pos =
		  NewHashTable.lookup_default
		  (constypehashtable, 0, arg)
		val done = optimised_output_int pos :: output_byte 7 :: done
d2883 3
a2885 4
		    val c = !constype_count + 1
		    val _ = constype_count := c
		    val _ = if debug_variables then ()
                            else NewHashTable.update(constypehashtable,arg, c)
d2887 6
a2892 1
		    encode_tyname(encode_list done encode_type l, t)
d2897 109
a3005 1
	    | encode_type(done, Datatypes.DEBRUIJN(arg as (n, b1, b2,_))) =
d3007 1
a3007 1
		fun et'(h::t) = if h = (n,b1,b2) then Lists.length t + 1
d3010 4
a3013 3
		    (debruijn_types_encoded := ((n,b1,b2)::(!debruijn_types_encoded)); 0)
		val pos = et'(!debruijn_types_encoded)
		val done = optimised_output_int pos :: output_byte 8 :: done
d3016 2
a3017 1
		  encode_bool b2 :: encode_bool b1 :: optimised_output_int n :: done
d3021 131
a3151 2
	    | encode_type(done, Datatypes.NULLTYPE) = output_byte 9 ::
	      done
d3153 2
a3154 2
	  and encode_typescheme(done, Datatypes.SCHEME(n, (t,_))) =
            encode_type(optimised_output_int n :: output_byte 1 :: done, t)
d3157 192
a3348 2
	    | encode_typescheme(done, Datatypes.OVERLOADED_SCHEME ov) =
	      encode_over_loaded ov @@ (output_byte 3 :: done)
d3350 70
a3419 51
	  and encode_tyfun(done, tyfun as Datatypes.TYFUN(t, n)) =
	    optimised_output_int n :: encode_type(output_byte 1 :: done, t)
	    | encode_tyfun(done, Datatypes.ETA_TYFUN tn) =
	      encode_tyname(output_byte 2 :: done, tn)
	    | encode_tyfun(done, Datatypes.NULL_TYFUN (tfi,_)) =
              encode_tyfun_id(output_byte 3 :: done, tfi)

	  fun write_tyname tyname = do_output(encode_tyname([], tyname))

	  fun write_tystr (Datatypes.TYSTR(tf, ve)) =
	    do_output(encode_valenv(encode_tyfun([], tf), ve))

	  fun scheme_eq(scheme1, scheme2) =
	    case scheme1 of
	      Datatypes.SCHEME(i, (ty,_)) =>
		(case scheme2 of
		   Datatypes.SCHEME(i', (ty',_)) =>
		     i = i' andalso Types.type_eq(ty, ty', true, false)
		 | _ => false)
	    | Datatypes.UNBOUND_SCHEME (ty,_) =>
		(case scheme2 of
		   Datatypes.UNBOUND_SCHEME (ty',_) =>
		     Types.type_eq(ty, ty', true, false)
		 | _ => false)
	    | Datatypes.OVERLOADED_SCHEME ov =>
		(case scheme2 of
		   Datatypes.OVERLOADED_SCHEME ov' => ov = ov'
		 | _ => false)

	  fun ve_eq(Datatypes.VE(_, map1), Datatypes.VE(_, map2)) =
	    NewMap.eq (*Scheme.type*) scheme_eq (map1, map2)

	  fun pair_eq(eq1, eq2) =
	    fn ((a, b), (a', b')) => eq1(a, a') andalso eq2(b, b')

	  fun tystr_eq(Datatypes.TYSTR a, Datatypes.TYSTR b) =
	    pair_eq(Types.tyfun_eq, ve_eq) (a, b)

	  val tyenv_eq = NewMap.eq tystr_eq

	  fun str_eq(Datatypes.STR(sn, _, env), Datatypes.STR(sn', _, env')) =
	    Strnames.strname_eq(sn, sn') andalso
	    env_eq(env, env')
	    | str_eq _ = Crash.impossible"str_eq on COPYSTR"

	  and env_eq(Datatypes.ENV(Datatypes.SE se, Datatypes.TE te, ve),
		     Datatypes.ENV(Datatypes.SE se', Datatypes.TE te', ve')) =
	    NewMap.eq str_eq (se, se') andalso tyenv_eq (te, te') andalso ve_eq (ve, ve')

	  fun str_hash(Datatypes.STR{1 = sn, ...}) = strname_hash sn
	    | str_hash(Datatypes.COPYSTR _) = Crash.impossible"str_hash on COPYSTR"
d3421 26
a3446 164
	  val strhashtable = NewHashTable.new(100, str_eq, str_hash)
	  val strhashtable_count = ref 0

	  datatype 'a option = YES of 'a | NO

	  fun eq_assoc eq_fun =
	    let
	      fun eq_elt elt =
		let
		  fun try [] = NO
		    | try ((dom, ran) :: xs) =
		      if eq_fun(elt, dom) then
			YES ran
		      else
			try xs
		in
		  try
		end
	    in
	      eq_elt
	    end

	  fun write_tyenv (Datatypes.TE m) =
	    let
	      val tycon =
		case NewMap.domain_ordered m of
		  tycon :: _ => tycon
		| _ => Ident.TYCON(Symbol.find_symbol"")
	      val table = !tyenv_table
	      val envs = !tyenvs + 1
	      val i = case NewMap.tryApply'(table, tycon) of
		NewMap.YES list =>
		  (case eq_assoc tyenv_eq m list of
		     YES i => ((*tyenv_repeats := !tyenv_repeats + 1;*) i)
		   | NO =>
		       (tyenvs := envs;
			tyenv_table := NewMap.define(table, tycon,
						     (m, envs) :: list);
			0))
	      | _ =>
		  (tyenvs := envs;
		   tyenv_table := NewMap.define(table, tycon, [(m, envs)]);
		   0)
	    in
	      write_opt_int i;
	      if i = 0 then
		write_newmap write_tycon write_tystr m
	      else
		()
	    end

	  fun write_str(str as Datatypes.STR(sn,_,e)) =
	    (case NewHashTable.lookup_default(strhashtable, 0, str) of
	       0 =>
		 let
		   val count = !strhashtable_count + 1
		 in
		   strhashtable_count := count;
		   NewHashTable.update(strhashtable, str, count);
		   write_opt_int 0;
		   write_strname sn; write_env e
		 end
	     | n => write_opt_int n)
	    | write_str(Datatypes.COPYSTR((smap, tmap), str)) =
	      write_str(Env.str_copy (str,smap,tmap))

	  and write_strenv (Datatypes.SE m) =
	    write_newmap write_strid write_str m

	  and write_env (Datatypes.ENV(se, te, ve)) =
	    (write_strenv se; write_tyenv te;
	     do_output(encode_valenv([], ve)))

	  fun write_nameset ns =
	    (do_output(encode_list [] encode_tyname (Nameset.tynames_of_nameset ns));
	     write_list write_strname (Nameset.strnames_of_nameset ns))

	  fun write_sigma (BasisTypes.SIGMA(ns, s)) =
	    (write_nameset ns; write_str s)

	  fun write_sigenv (BasisTypes.SIGENV M) =
	    write_newmap write_sigid write_sigma M

	  fun write_phi (BasisTypes.PHI(ns, (s, sg))) =
	    (write_nameset ns; write_str s; write_sigma sg)

	  fun write_funenv (BasisTypes.FUNENV M) =
	    write_newmap write_funid write_phi M

	  fun write_ty_ass_val_entry (tyfun,(valenv,n')) =
	    (do_output (encode_tyfun ([],tyfun));
	     do_output (encode_valenv ([],valenv));
	     write_opt_int n')

	  fun write_recipe value =
	    case value of
	      Debugger_Types.Nop =>
		write_byte 0
	    | Debugger_Types.Select(x,y) =>
		(write_byte 1; write_opt_int x; write_recipe y)
	    | Debugger_Types.MakeRecord args =>
		(write_byte 2; write_assoc write_opt_string write_recipe args)
	    | Debugger_Types.Funarg arg =>
		(write_byte 3; write_recipe arg)
	    | Debugger_Types.Funres arg =>
		(write_byte 4; write_recipe arg)
	    | Debugger_Types.MakeFunType(x,y) =>
		(write_byte 5; write_recipe x; write_recipe y)
	    | Debugger_Types.DeCons(x,y) =>
		(write_byte 6; write_opt_int x; write_recipe y)
	    | Debugger_Types.MakeConsType(x, y) =>
		(write_byte 7; write_list write_recipe x;
		 do_output(encode_tyname([], y)))
	    | Debugger_Types.Error =>
		write_byte 8

	  fun write_debug write_runtime_env =
	    write_newmap write_opt_string
            (write_triple
             (write_triple (fn ty => do_output(encode_type([], ty))) write_bool
	     (write_assoc write_opt_int write_recipe)) write_runtime_env write_bool)
	in
          write_bool debug_variables;
	  Timer.xtime("write_nameset", !do_timings, fn () => write_nameset nameset);
	  Timer.xtime("write_funenv",  !do_timings, fn () => write_funenv funenv);
	  Timer.xtime("write_sigenv",  !do_timings, fn () => write_sigenv sigenv);
	  Timer.xtime("write_env",     !do_timings, fn () => write_env env);
	  Timer.xtime("write_debug",   !do_timings,
            fn () => write_debug (if debug_variables then write_runtime_env
                                  else fn _ => ()) debug_information);
	  (if !print_hash_table_stats then
	    (output(std_out,"Metatynamehashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(metatynamehashtable) ^ "\n");
	     output(std_out,"FunTypehashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(funtypehashtable) ^ "\n");
	     output(std_out,"ConsTypehashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(constypehashtable) ^ "\n");
	     output(std_out,"RecTypehashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(rectypehashtable) ^ "\n");
	     output(std_out,"Valenvhashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(valenvhashtable) ^ "\n"))
	   else ());
	     ()
	end

(*
      fun write_cons l =
	write_assoc write_sz_string (write_sz_string o MLWorks.Time.encode) l
*)

      fun write_cons_triple{mod_name, req_name, time} =
	(write_sz_string mod_name;
	 write_sz_string req_name;
	 write_sz_string(MLWorks.Time.encode time))

      val write_cons = write_list write_cons_triple

      val _ =
	(write_int ObjectFile.GOOD_MAGIC; write_int ObjectFile.OBJECT_FILE_VERSION)
      val (header_start, _, header_end) =
	(!fpos, (write_dummies 5; write_int tynames; write_int strnames; write_int tyfuns; write_int 0), !fpos)
      val (cons_start, _, cons_end) = (!fpos, write_cons consistency, !fpos)
      val (parser_start, _, parser_end) = (!fpos, write_parser_env parser_env, !fpos)
      val (lambda_start, _, lambda_end) = (!fpos, write_lambda_env lambda_env, !fpos)
d3448 1
a3448 1
        (!fpos,
d3450 2
a3451 60
         !fpos)
      val (code_start, _, code_end) = (!fpos, write_code code, !fpos)
    in
      seek header_start;
      write_int (code_start);
      write_int (cons_end   - cons_start);
      write_int (parser_end - parser_start);
      write_int (ty_end     - ty_start);
      write_int (lambda_end - lambda_start);
      seek (header_start + 4 * 8);
      write_int(!total_strings);
      close file_handle
    end

  fun decode_header header =
    let
      val (magic,       ptr) = input_int(header, 0)
      val (version,     ptr) = input_int(header, ptr)
      val (code_offset, ptr) = input_int(header, ptr)
      val (cons_size,   ptr) = input_int(header, ptr)
      val (parser_size, ptr) = input_int(header, ptr)
      val (type_size,   ptr) = input_int(header, ptr)
      val (lambda_size, ptr) = input_int(header, ptr)
      val (tynames,     ptr) = input_int(header, ptr)
      val (strnames,    ptr) = input_int(header, ptr)
      val (tyfuns,      ptr) = input_int(header, ptr)
      val (strings,     ptr) = input_int(header, ptr)
    in
      if magic = ObjectFile.GOOD_MAGIC then
	if version = ObjectFile.OBJECT_FILE_VERSION then
	  {cons_size = cons_size, parser_size = parser_size,
	   type_size = type_size, lambda_size = lambda_size, tynames = tynames,
	   strnames = strnames, tyfuns = tyfuns, strings = strings}
	else
	  raise BadInput (".mo file version incorrect: " ^ Integer.makestring version)
      else
	raise BadInput "Corrupt object file (1)"
    end

  fun checked_input(f, len) =
    let
      val s = input(f, len)
    in
      if size s <> len then raise BadInput "Corrupt object file (2)"
      else s
    end

  fun input_info filename =
    let
      val Error = BadInput("Corrupt object file (3): " ^ filename)
      val file_handle = open_in filename
	handle Io m => raise BadInput ("Io error in decapsulate: " ^ m)
    in
      let
	val header = checked_input(file_handle, ObjectFile.HEADER_SIZE)
	val {cons_size, tynames, strnames, tyfuns, ...} = decode_header header
	val cons = checked_input(file_handle, cons_size)
	val consistency = decode_cons cons
      (* This must be done before the close_in *)
      (* Otherwise we end up trying to close files already closed *)
a3452 11
	close_in file_handle;
	{tynames = tynames, strnames = strnames, tyfuns = tyfuns,
	 consistency = consistency}
      end handle
        Ord => (close_in file_handle; raise Error)
      | Lists.Nth => (close_in file_handle; raise Error)
      | String.Substring => (close_in file_handle; raise Error)
      | NewMap.Undefined => (close_in file_handle; raise Error)
      | BadInput s => (close_in file_handle; raise BadInput (s ^ ": " ^ filename))
      | NewHashTable.Lookup => (close_in file_handle; raise Error)
    end
d3454 13
a3466 39
  (*
   * Beware! The ordering of the inputs in the following function
   * is important. This function is written so that immediately
   * after decoding a string it goes out of scope, hence hopefully
   * avoiding sudden increases in heap size due to a number
   * of large live (but already decoded) strings.
   *)

  fun input_all filename =
    let
      fun error s = raise BadInput ("Corrupt object file (4): " ^ s ^ filename)
      val file_handle = open_in filename
	handle Io m => raise BadInput ("Io error in decapsulate: " ^ m)
    in
      let
	val
	  {cons_size, parser_size, type_size,
	   lambda_size, tynames, strnames, tyfuns, strings} =
	  decode_header(checked_input(file_handle, ObjectFile.HEADER_SIZE))
	val _ = stringMap := Array.array(strings, "")
	val _ = stringId := 1
	val result =
	  {consistency = decode_cons(checked_input(file_handle, cons_size)),
	   parser_env  = decode_parser_env(checked_input(file_handle, parser_size)),
	   lambda_env  = decode_lambda_env(checked_input(file_handle, lambda_size)),
	   type_env    = checked_input(file_handle, type_size),
	   tynames = tynames, strnames = strnames, tyfuns = tyfuns}
      in
	close_in file_handle;
	result
      end handle
        Ord => (close_in file_handle; error "ord")
      | Lists.Nth => (close_in file_handle; error "nth")
      | String.Substring => (close_in file_handle; error "substring")
      | NewMap.Undefined => (close_in file_handle; error "undefined")
      | BadInput s => (close_in file_handle; raise BadInput (s ^ ": " ^ filename))
      | NewHashTable.Lookup => (close_in file_handle; error "lookup")
    end
end
@


1.128
log
@Modifications to include number of callee saves in wordsets
@
text
@d4 3
d545 1
a545 1
  sharing Debugger_Types.Debugger_Env.Option = Basis.BasisTypes.Datatypes.Option
d551 1
a551 1
    Basis.BasisTypes.Datatypes.Type = Debugger_Types.Debugger_Env.Type
d571 1
a571 1
    structure Debugger_Env = Debugger_Types.Debugger_Env
d579 1
a579 1
    fun mylookup (n,a,b) =
d1497 1
a1497 1
		    (mylookup(1,strnamehashtable, n), ptr)
d1576 1
a1576 1
		    (mylookup(2,metatyvarhashtable, i), ptr)
d1597 1
a1597 1
		    (mylookup(3,metaoverloadedhashtable, i), ptr)
d1616 1
a1616 1
		    (mylookup(4,tyvarhashtable, i), ptr)
d1637 1
a1637 1
		    (mylookup(5,metarectypehashtable, i), ptr)
d1654 1
a1654 1
		    (mylookup(6,rectypehashtable, i), ptr)
d1672 1
a1672 1
		    (mylookup (7,decfuntypehashtable,i), ptr)
d1690 1
a1690 1
		    (mylookup(8,constypehashtable, i), ptr)
d1709 1
a1709 1
		    (mylookup(9,debruijnhashtable, i), ptr)
d1735 1
a1735 1
		  (mylookup(10,valenvhashtable, n), ptr)
d1775 1
a1775 1
		    (ref(mylookup(11,tynamevalenvhashtable, n)), ptr)
d1817 1
a1817 1
		    (mylookup(12,tynamehashtable, n), ptr)
d1879 2
a1880 2
			  1 => Debugger_Env.Option.SOME1
			| 2 => Debugger_Env.Option.SOME2
d1902 1
a1902 1
	      1 => I Debugger_Env.APP(input_triple decode_runtime_env decode_runtime_env
d1904 2
a1905 2
	    | 2 => (Debugger_Env.EMPTY,ptr)
	    | 3 => I Debugger_Env.FN(input_quadruple decode_string decode_runtime_env decode_spill
d1907 1
a1907 1
	    | 4 => I Debugger_Env.LET
d1911 11
a1921 7
		   (decode_option
		    (input_triple decode_string
		     (fn ptr => I ref((fn (ty,ptr)=>((ty,Option.ABSENT,nil),ptr))
				      (decode_type ptr)))
		     (decode_option decode_spill)))
		   decode_runtime_env)) decode_runtime_env ptr)
	    | 5 => I Debugger_Env.HANDLE(input_fivetuple decode_runtime_env decode_spill
d1923 3
a1925 3
	    | 6 => I Debugger_Env.RAISE(decode_runtime_env ptr)
	    | 7 => I Debugger_Env.SELECT(input_pair input_int decode_runtime_env ptr)
	    | 8 => I Debugger_Env.STRUCT(input_list decode_runtime_env ptr)
d1927 1
a1927 1
		I Debugger_Env.SWITCH
d1936 6
a1941 6
			1 => I Debugger_Env.CONSTRUCTOR(decode_string ptr)
		      | 2 => I Debugger_Env.INT(decode_string ptr)
		      | 3 => I Debugger_Env.REAL(decode_string ptr)
		      | 4 => I Debugger_Env.STRING(decode_string ptr)
		      | 5 => (Debugger_Env.DYNAMIC,ptr)
		      | 6 => (Debugger_Env.DEFAULT,ptr)
d1946 2
a1947 2
	    | 10 => I Debugger_Env.LIST(input_list decode_runtime_env ptr)
	    | 11 => (Debugger_Env.BUILTIN,ptr)
d2185 1
a2185 1
	      decode_debug (fn ptr=>(Debugger_Env.EMPTY,ptr)) ptr
d3046 1
a3046 1
                    Debugger_Env.Option.SOME1(spill)=>
d3048 1
a3048 1
                  | Debugger_Env.Option.SOME2(spill)=>
d3058 1
a3058 1
              fun write_runtime_env(Debugger_Env.APP(env)) =
d3061 2
a3062 2
                | write_runtime_env(Debugger_Env.EMPTY) = write_byte 2
                | write_runtime_env(Debugger_Env.FN(env)) =
d3065 1
a3065 1
                | write_runtime_env(Debugger_Env.LET(env as (env1,env2))) =
d3067 2
a3068 2
                     Debugger_Env.LET([env2],env3) =>
                       write_runtime_env(Debugger_Env.LET(env1@@[env2],env3))
d3073 7
a3079 4
                                     (write_option (write_triple write_string
                                                    (fn ref(ty,_,_)=>
                                                     do_output(encode_type([],ty)))
                                                    (write_option write_spill)))
d3082 1
a3082 1
                | write_runtime_env(Debugger_Env.HANDLE(env)) =
d3086 1
a3086 1
                | write_runtime_env(Debugger_Env.RAISE(env)) =
d3088 1
a3088 1
                | write_runtime_env(Debugger_Env.SELECT(env)) =
d3092 1
a3092 1
                | write_runtime_env(Debugger_Env.STRUCT(envs)) =
d3095 1
a3095 1
                | write_runtime_env(Debugger_Env.SWITCH(envs)) =
d3101 6
a3106 6
                                   Debugger_Env.CONSTRUCTOR(s) => (write_byte 1;write_string s)
                                 | Debugger_Env.INT(s) => (write_byte 2;write_string s)
                                 | Debugger_Env.REAL(s) => (write_byte 3;write_string s)
                                 | Debugger_Env.STRING(s) => (write_byte 4;write_string s)
                                 | Debugger_Env.DYNAMIC => write_byte 5
                                 | Debugger_Env.DEFAULT => write_byte 6)
d3108 1
a3108 1
                | write_runtime_env(Debugger_Env.LIST(envs)) =
d3111 1
a3111 1
                | write_runtime_env(Debugger_Env.BUILTIN) = write_byte 11
@


1.127
log
@Ensure exception debug info flag stored
@
text
@d4 3
d831 1
a831 1
      | count_real_objects(count, Code_Module.WORDSET(Code_Module.WORD_SET{2=w_list, ...}) :: rest) =
d2514 1
a2514 1
	    | output_module_element(Code_Module.WORDSET(Code_Module.WORD_SET{1=str_list, 2=w_list, 3=leaf_list, 4=offsets_list,...})) =
d2517 1
a2517 1
                  | write ((i, spills, words)::sets, leaf::leafs, offset::offsets) =
d2520 1
d2533 1
a2533 1
                  Lists.reducel (fn (res,(i,spill,s)) => res+size s) (0,w_list)
@


1.126
log
@Update debugger information production
@
text
@d4 3
a2141 2
	fun input_fake_bool ptr = (true, ptr) (* Temporary measure *)

d2149 1
a2149 1
			decode_runtime_env input_fake_bool,
a3415 2
	  fun ignore _ = ()

d3420 1
a3420 1
	     (write_assoc write_opt_int write_recipe)) write_runtime_env ignore)
@


1.125
log
@Change .mo format to enable loading with immutable ancillary slots.
@
text
@d4 3
d2139 2
d2143 1
a2143 1
			input_pair
d2148 1
a2148 1
			decode_runtime_env,
d3415 2
d3419 1
a3419 1
            (write_pair
d3421 1
a3421 1
	     (write_assoc write_opt_int write_recipe)) write_runtime_env)
@


1.124
log
@New runtime directory structure.
@
text
@d4 3
d2507 9
a2515 16
                fun write ([], [], [], []) = ()
                  | write (name::names, (i, spills, words)::sets, leaf::leafs, offset::offsets) =
                    let
                      (* Uncommenting next line saves a few hundred K in image size *)
                      (* val name = "" *)
                    in
                      (write_int i;			(* position in closure *)
                       write_int (size name + 1);		(* length of name *)
                       write_extended_string name;	(* name of code item *)
                       write_int spills;			(* nr of non-gc spills *)
                       write_int (if leaf then 1 else 0);	(* leaf flag *)
                       write_int offset;			(* intercept offset *)
                       write_int (size words);		(* the code length *)
                       write_string words;		(* the code *)
                       write (names, sets, leafs, offsets))
                    end
d2517 5
a2521 1

d2524 4
d2532 3
a2534 1
                write (str_list, w_list, leaf_list, offsets_list)
@


1.123
log
@Removed a couple of superfluous handlers and tidied up
@
text
@d4 3
d495 1
a495 1
require "../rts/objectfile";
@


1.122
log
@Added support for int_literal_tyvar and real_literal_tyvar.
@
text
@d4 3
d456 1
a456 1
modules. The following two points should be noted: 
d532 1
a532 1
  sharing type Debugger_Types.Type = EnvironTypes.LambdaTypes.Type = 
d536 29
a564 28
struct
  structure Ident = ParserEnv.Ident
  structure BasisTypes = Basis.BasisTypes
  structure Datatypes = BasisTypes.Datatypes
  structure Strname_id = Datatypes.Strname_id
  structure Tyname_id = Datatypes.Tyname_id
  structure Tyfun_id = Datatypes.Tyfun_id
  structure EnvironTypes = EnvironTypes
  structure Symbol = Ident.Symbol
  structure Diagnostic = Diagnostic
  structure Code_Module = Code_Module
  structure ParserEnv = ParserEnv
  structure Basis = Basis
  structure Debugger_Types = Debugger_Types
  structure Map = Datatypes.Mapping
  structure NewMap = Datatypes.NewMap 
  structure IntMap = IntMap
  structure Debugger_Env = Debugger_Types.Debugger_Env
  structure Info = Info
  structure Option = Datatypes.Option

  type Module = Code_Module.Module

  val domydebug = false

  fun mylookup (n,a,b) =
    NewHashTable.lookup (a,b)
    handle exn as NewHashTable.Lookup => 
d567 26
d594 26
a619 5
  fun add_together_ords(s,x) =
    let
      fun add_together_ords'(x, acc) =
        if x<0 then acc
        else add_together_ords'(x-1, acc + String.ordof(s,x))
d621 15
a635 1
      add_together_ords'(size s - 1, x)
d638 29
a666 6
  datatype DelayedEvaluation =
      STRING of string
    | SYMBOL of Symbol.Symbol
    | OPTINT of int
    | BYTE of int
    | INT of int
d668 7
a674 1
  fun make_concat(x,y) = STRING(x ^ y)
d676 8
a683 2
  exception BadInput of string
  fun CorruptFile n = BadInput ("Corrupt object file - " ^ Integer.makestring n)
d685 9
a693 3
  val do_timings = ref false
  val print_stats = false
  val print_hash_table_stats = ref(false)
d695 10
a704 1
  fun diagnose_counts str = Diagnostic.output 1 (fn i => [str])
d706 11
a716 1
  fun diagnose_calls str = Diagnostic.output 2 (fn i => [str])
d718 3
a720 1
  fun diagnose_consistency str = Diagnostic.output 3 (fn i => [str])
d722 10
a731 1
  fun diagnose_sizes str = Diagnostic.output 4 (fn i => [str])
d733 15
a747 2
  fun string_list_sub(n, []) = n
    | string_list_sub(n, str :: rest) = string_list_sub(n + size str, rest)
d749 3
a751 1
  fun string_list_size str = string_list_sub(0, str)
d753 12
a764 3
  fun output_byte i = BYTE i
  fun output_int i = INT i
  fun optimised_output_int i = OPTINT i
d766 1
a766 2
  local
    fun inputi(s, ptr) =
d768 11
a778 3
	val x = Bits.lshift(String.ordof(s, ptr    )    , 8)
	val y = Bits.lshift(Bits.orb(String.ordof(s, ptr + 1), x), 8)
	val z = Bits.lshift(Bits.orb(String.ordof(s, ptr + 2), y), 8)
d780 1
a780 1
	Bits.orb(z, String.ordof(s, ptr + 3))
a781 3
  in
    fun input_int(s, ptr) =
      (inputi(s, ptr), ptr + 4)
d783 1
a783 1
    fun input_opt_int(s, ptr) =
d785 10
a794 1
	val tag = String.ordof(s,ptr)
d796 1
a796 7
	if tag = 254 then
	  (Bits.orb(Bits.lshift(String.ordof(s, ptr + 1), 8),
		    String.ordof(s, ptr + 2)), ptr + 3)
	else if tag = 255 then
	  (inputi(s, ptr + 1), ptr + 5)
	else
	  (tag, ptr + 1)
a797 1
  end
d799 3
a801 2
  fun input_byte(s, ptr) =
    (String.ordof(s, ptr), ptr + 1)
d803 11
a813 6
  fun input_sz_string (s, ptr) =
    let
      val (sz, ptr) = input_opt_int(s, ptr)
    in
      (String.substring(s, ptr, sz), ptr + sz)
    end
d815 44
a858 2
  val stringId = ref 1
  val stringMap = ref (Array.array(1, ""))
d860 7
a866 16
  fun input_opt_string (s, ptr) =
    let
      val (id, ptr) = input_opt_int(s, ptr)
    in
      if id = 0 then
	let
	  val (str, ptr) = input_sz_string(s, ptr)
	  val strId = !stringId
	in
	  Array.update(!stringMap, strId, str);
	  stringId := strId + 1;
	  (str, ptr)
	end
      else
	(Array.sub(!stringMap, id), ptr)
    end
d868 1
a868 16
  fun input_pair f g ptr =
    let
      val (fval, ptr) = f ptr
      val (gval, ptr) = g ptr
    in
      ((fval, gval), ptr)
    end
      
  fun input_triple f g h ptr =
    let
      val (fval, ptr) = f ptr
      val (gval, ptr) = g ptr
      val (hval, ptr) = h ptr
    in
      ((fval, gval,hval), ptr)
    end
d870 7
a876 9
  fun input_quadruple f g h i ptr =
    let
      val (fval, ptr) = f ptr
      val (gval, ptr) = g ptr
      val (hval, ptr) = h ptr
      val (ival, ptr) = i ptr
    in
      ((fval, gval,hval,ival), ptr)
    end
d878 7
a884 10
  fun input_fivetuple f g h i j ptr =
    let
      val (fval, ptr) = f ptr
      val (gval, ptr) = g ptr
      val (hval, ptr) = h ptr
      val (ival, ptr) = i ptr
      val (jval, ptr) = j ptr
    in
      ((fval, gval,hval,ival,jval), ptr)
    end
d886 5
a890 11
  fun input_sixtuple f g h i j k ptr =
    let
      val (fval, ptr) = f ptr
      val (gval, ptr) = g ptr
      val (hval, ptr) = h ptr
      val (ival, ptr) = i ptr
      val (jval, ptr) = j ptr
      val (kval, ptr) = k ptr
    in
      ((fval, gval,hval,ival,jval,kval), ptr)
    end
d892 1
a892 3
  fun input_list(s, f, ptr) =
    let
      val (count, ptr) = input_opt_int(s, ptr)
d894 1
a894 2
      fun dec_sub(0, ptr, done) = (rev done, ptr)
	| dec_sub(n, ptr, done) =
d896 1
a896 1
	    val (d, ptr) = f ptr
d898 1
a898 1
	    dec_sub(n-1, ptr, d :: done)
a899 3
    in
      dec_sub(count, ptr, [])
    end
d901 1
a901 5
  fun input_newmap(s, f, g, ptr, orderfn, eqfn) =
    let
      val (count, ptr) = input_opt_int(s, ptr)
      fun dec_sub(0, ptr, done) = (done, ptr)
	| dec_sub(n, ptr, done) =
d903 1
a903 2
	    val (fval, ptr) = f ptr
	    val (gval, ptr) = g ptr
d905 1
a905 1
	    dec_sub(n-1, ptr, (fval, gval) :: done)
a906 8
      val (list, ptr) = dec_sub(count, ptr, [])
    in
      (NewMap.from_list (orderfn,eqfn) list, ptr)
    end

  fun input_newmap'(s, f, g, ptr, orderfn) =
    let
      val (count, ptr) = input_opt_int(s, ptr)
d908 1
a908 2
      fun dec_sub(0, ptr, m) = (m, ptr)
	| dec_sub(n, ptr, m) =
d910 1
a910 2
	    val (fval, ptr) = f ptr
	    val (gval, ptr) = g ptr
d912 1
a912 4
	    dec_sub(n-1, ptr, (fval, gval) :: (*done*)m)
(*
	    dec_sub(n-1, ptr, NewMap.define(m, fval, gval))
*)
a913 11
      val (list, ptr) = dec_sub(count, ptr, [])
    in
      (NewMap.from_list' orderfn list, ptr)
(*
      dec_sub(count, ptr, NewMap.empty' orderfn)
*)
    end

  fun input_intmap(s, g, ptr) =
    let
      val (count, ptr) = input_opt_int(s, ptr)
d915 1
a915 2
      fun dec_sub(0, ptr, m) = (m, ptr)
	| dec_sub(n, ptr, m) =
d917 7
a923 2
	    val (fval, ptr) = input_opt_int(s, ptr)
	    val (gval, ptr) = g ptr
d925 1
a925 4
	    dec_sub(n-1, ptr, (fval, gval) :: (*done*)m)
(*
	    dec_sub(n-1, ptr, IntMap.define(m, fval, gval))
*)
d927 4
a930 7
      val (list, ptr) = dec_sub(count, ptr, [])
    in
(*
      dec_sub(count, ptr, IntMap.empty)
*)
      (IntMap.from_list list, ptr)
    end
d932 31
a962 3
  fun input_tyfunid_map(s, f, g, ptr) =
    let
      val (count, ptr) = input_opt_int(s, ptr)
d964 3
a966 5
      fun dec_sub(0, ptr, m) = (m, ptr)
	| dec_sub(n, ptr, m) =
	  let
	    val (fval, ptr) = f ptr
	    val (gval, ptr) = g ptr
d968 1
a968 1
	    dec_sub(n-1, ptr, Tyfun_id.Map.define(m, fval, gval))
a969 3
    in
      dec_sub(count, ptr, Tyfun_id.Map.empty)
    end
d971 1
a971 6
  fun input_strnameid_map(s, f, g, ptr) =
    let
      val (count, ptr) = input_opt_int(s, ptr)

      fun dec_sub(0, ptr, m) = (m, ptr)
	| dec_sub(n, ptr, m) =
d973 2
a974 2
	    val (fval, ptr) = f ptr
	    val (gval, ptr) = g ptr
d976 2
a977 1
	    dec_sub(n-1, ptr, Strname_id.Map.define(m, fval, gval))
d979 4
a982 3
    in
      dec_sub(count, ptr, Strname_id.Map.empty)
    end
d984 3
a986 52
  fun count_real_objects(count, []) = count
    | count_real_objects(count, Code_Module.WORDSET(Code_Module.WORD_SET{2=w_list, ...}) :: rest) =
      count_real_objects(count + Lists.length w_list, rest)
    | count_real_objects(count, _ :: rest) = count_real_objects(count + 1, rest)

  fun encode_bool false = BYTE 0
    | encode_bool true  = BYTE 1

  fun encode_string(done, s) = STRING(s) :: done

  fun encode_symbol(done, sy) = SYMBOL(sy) :: done

  fun encode_valid(done, Ident.VAR sy) =
    encode_symbol(output_byte 0 :: done, sy)
  | encode_valid(done, Ident.CON sy) =
    encode_symbol(output_byte 1 :: done, sy)
  | encode_valid(done, Ident.EXCON sy) =
    encode_symbol(output_byte 2 :: done, sy)
  | encode_valid _ = Crash.impossible "TYCON':encode_valid:encapsulate"

  fun encode_lab(done, Ident.LAB lab) =
    encode_symbol(done, lab)

  fun encode_tyvar(done, Ident.TYVAR(tyvar, b1, b2)) =
    encode_bool b2 :: encode_bool b1 :: encode_symbol(done, tyvar)

  fun encode_ol_tyvar tyvar =
    if tyvar = Ident.num_tyvar then output_byte 5
    else if tyvar = Ident.int_tyvar then output_byte 6
    else if tyvar = Ident.int_literal_tyvar then output_byte 7
    else if tyvar = Ident.real_tyvar then output_byte 8
    else if tyvar = Ident.real_literal_tyvar then output_byte 9
    else if tyvar = Ident.numtext_tyvar then output_byte 10
    else case tyvar of
	   Ident.TYVAR(sym, _, _) =>
	     Crash.impossible
	       ("Bad tyvar in overloaded type: " ^ Symbol.symbol_name sym)
  
  fun encode_over_loaded (Datatypes.UNARY (_, tv)) =
    [output_byte 1, encode_ol_tyvar tv]
    | encode_over_loaded (Datatypes.BINARY (_, tv)) =
    [output_byte 2, encode_ol_tyvar tv]
    | encode_over_loaded (Datatypes.PREDICATE (_, tv)) =
    [output_byte 3, encode_ol_tyvar tv]

  fun encode_list done f l =
    let
      fun rev_map (done, []) = done
	| rev_map (done, x :: xs) = rev_map(f(done, x), xs)
    in
      rev_map(optimised_output_int(Lists.length l) :: done, l)
    end
d988 8
a995 1
  fun encode_pair f g (done, (a, b)) = g(f(done, a), b)
d997 6
a1002 15
  fun encode_newmap done f g m =
    let
      val sz = optimised_output_int(NewMap.size m)
    in
      NewMap.fold_in_rev_order
      (fn (done, a, b) => g(f(done, a), b)) (sz :: done, m)
    end
    
  fun encode_map done f g m =
    let
      val sz =
	optimised_output_int(Lists.length(Map.assoc m))
    in
      Map.Fold (fn a => fn b => fn done => g(f(done, a), b)) (sz :: done) m
    end
d1004 12
a1015 5
  fun decode_lambda_env s =
    let
      val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	(int, (Ident.ValId, EnvironTypes.comp)NewMap.T) NewMap.T ref
      val val_size = ref 0
d1017 6
a1022 1
      val (total_size, ptr) = input_opt_int(s, 0)
d1024 6
a1029 6
      fun decode_symbol ptr =
	let
	  val (str, ptr) = input_opt_string(s, ptr)
	in
	  (Symbol.find_symbol str, ptr)
	end
d1031 6
a1036 6
      fun decode_strid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.STRID sy, ptr)
	end
d1038 20
a1057 6
      fun decode_funid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.FUNID sy, ptr)
	end
d1059 13
a1071 12
      fun decode_valid ptr =
	let
	  val (sy_type, ptr) = input_byte(s, ptr)
	  val (sy, ptr) = decode_symbol ptr
	  val id = case sy_type of
	    0 => Ident.VAR sy
	  | 1 => Ident.CON sy
	  | 2 => Ident.EXCON sy
	  | _ => raise CorruptFile 1
	in
	  (id, ptr)
	end
d1073 18
a1090 3
      fun read_env ptr =
	let
	  val (env_size, ptr) = input_opt_int(s, ptr)
d1092 1
a1092 15
	  fun read_field ptr =
	    (case input_byte(s, ptr) of
	       (0, ptr) => 
		 let
		   val (offset, ptr) = input_opt_int(s, ptr)
		 in
		   (EnvironTypes.FIELD{index = offset, size = env_size}, ptr)
		 end
	     | (1, ptr) => 
		 let
		   val (offset, ptr) = input_opt_int(s, ptr)
		 in
		   (EnvironTypes.PRIM(Pervasives.decode offset), ptr)
		 end
	     | _ => Crash.impossible "Decoding a field - got neither 1 nor 0 ")
d1094 6
a1099 3
	  fun decode_val_env ptr =
	    case input_opt_int(s, ptr) of
	      (0, ptr) =>
d1102 3
a1104 2
		    input_newmap(s, decode_valid, read_field, ptr,
				 Ident.valid_lt, Ident.valid_eq)
d1107 3
a1109 3
		  val_size := new_num;
		  val_map := NewMap.define(!val_map, new_num, val_env);
		  (val_env, ptr)
d1111 1
a1111 1
	    | (valnum, ptr) =>
d1113 1
a1113 7
	  
	  val (v_env, ptr) = decode_val_env ptr
	  val (s_env, ptr) =
	    input_newmap(s, decode_strid, input_triple read_env read_field (fn ptr => (false,ptr)), ptr, Ident.strid_lt, Ident.strid_eq)
	in
	  (EnvironTypes.ENV(v_env, s_env), ptr)
	end
d1115 3
a1117 8
      fun read_ftr_range ptr =
	let
	  val (offset, ptr) = input_opt_int(s, ptr)
	  val (env, ptr) = read_env ptr
	in
	  ((EnvironTypes.FIELD{index=offset, size=total_size}, env, false),
	   ptr)
	end
d1119 1
a1119 3
      val (fun_env, ptr) =
	input_newmap(s, decode_funid, read_ftr_range, ptr, Ident.funid_lt, Ident.funid_eq)
      val (env, _) = read_env ptr
d1121 6
a1126 3
    in
      EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)
    end
d1128 9
d1138 10
a1147 8
  fun decode_parser_env s =
    let
      val fix_map = (ref(NewMap.empty' ((op<) : int * int -> bool))) :
	(int, (Symbol.Symbol, ParserEnv.Fixity) NewMap.T) NewMap.T ref
      val fix_size = ref 0
      val val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	(int, ParserEnv.pVE) NewMap.T ref
      val val_size = ref 0
d1149 1
a1149 6
      fun decode_symbol ptr =
	let
	  val (s, ptr) = input_opt_string(s, ptr)
	in
	  (Symbol.find_symbol s, ptr)
	end
d1151 40
a1190 12
      fun decode_valid ptr =
	let
	  val (sy_type, ptr) = input_byte(s, ptr)
	  val (sy, ptr) = decode_symbol ptr
	  val id = case sy_type of
	    0 => Ident.VAR sy
	  | 1 => Ident.CON sy
	  | 2 => Ident.EXCON sy
	  | _ => raise CorruptFile 2
	in
	  (id, ptr)
	end
d1192 2
a1193 6
      fun decode_strid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.STRID sy, ptr)
	end
d1195 6
a1200 6
      fun decode_funid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.FUNID sy, ptr)
	end
d1202 12
a1213 6
      fun decode_sigid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.SIGID sy, ptr)
	end
d1215 8
a1222 20
      fun decode_fixity ptr =
	let
	  val (fixity, ptr) = input_byte(s, ptr)
	in
	  case fixity of
	    0 =>
	      let
		val (prec, ptr) = input_byte(s, ptr)
	      in
		(ParserEnv.LEFT prec, ptr)
	      end
	  | 1 =>
	      let
		val (prec, ptr) = input_byte(s, ptr)
	      in
		(ParserEnv.RIGHT prec, ptr)
	      end
	  | 2 => (ParserEnv.NONFIX, ptr)
	  | _ => raise CorruptFile 2
	end
d1224 6
a1229 13
      fun decode_rev_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = input_opt_int(s, ptr)
	in
	  dec_sub(count, ptr, [])
	end
d1231 6
a1236 18
      fun decode_fix_env ptr =
	let
	  val (fixnum, ptr) = input_opt_int(s, ptr)
	in
	  case fixnum of
	    0 =>
	      let
		val (fix_env, ptr) =
		  input_newmap(s, decode_symbol, decode_fixity, ptr, Symbol.symbol_lt, Symbol.eq_symbol)
		val new_num = !fix_size + 1
	      in
		fix_size := new_num;
		fix_map := NewMap.define(!fix_map, new_num, fix_env);
		(fix_env, ptr)
	      end
	  | _ =>
	      (NewMap.apply'(!fix_map, fixnum), ptr)
	end
d1238 6
a1243 1
      fun error_fn _ = Crash.impossible "Encapsulate.decode_val_env"
d1245 6
a1250 20
      fun decode_val_env ptr =
	let
	  val (valnum, ptr) = input_opt_int(s, ptr)
	in
	  case valnum of
	    0 =>
	      let
		val (val_env, ptr) =
		  decode_rev_list decode_valid ptr
		val val_env =
		  Lists.reducel (fn (pve, valid) => ParserEnv.addValId(error_fn, valid, pve)) (ParserEnv.empty_pVE, val_env)
		val new_num = !val_size + 1
	      in
		(val_size := new_num;
		 val_map := NewMap.define(!val_map, new_num, val_env);
		 (val_env, ptr))
	      end
	  | _ =>
	      (NewMap.apply'(!val_map, valnum), ptr)
	end
d1252 6
a1257 3
      fun read_parse_env ptr =
	let
	  val (fix_env, ptr) = decode_fix_env ptr
d1259 5
a1263 1
	  val (val_env, ptr) = decode_val_env ptr
d1265 7
a1271 6
	  val (struct_env, ptr) =
	    input_newmap(s, decode_strid, read_parse_env, ptr, Ident.strid_lt, Ident.strid_eq)
	in
	  (ParserEnv.E(ParserEnv.FE fix_env, val_env, ParserEnv.SE struct_env),
	   ptr)
	end
d1273 7
a1279 9
      val (fun_env, ptr) =
	input_newmap(s, decode_funid, read_parse_env, 0, Ident.funid_lt, Ident.funid_eq)
      val (sig_env, ptr) =
	input_newmap(s, decode_sigid, read_parse_env, ptr, Ident.sigid_lt, Ident.sigid_eq)
      val (parse_env, _) =
	read_parse_env ptr
    in
      ParserEnv.B(ParserEnv.F fun_env, ParserEnv.G sig_env, parse_env)
    end
d1281 9
a1289 10
    fun print_reqlist (require_list) =
    if domydebug
      then
        (output(std_out,"Requires:\n");
         Lists.iterate
         (fn (name,a,b,c) =>
          output(std_out,name ^ " " ^ Integer.makestring a ^ " " ^ Integer.makestring b ^ " " ^ Integer.makestring c ^ "\n"))
         require_list)
    else
      ()
d1291 2
a1292 1
    fun TypeDecapError n = BadInput ("Corrupt object file (Failed during type decapsulation) - " ^ Integer.makestring n)
d1294 5
a1298 38
    fun decode_type_basis (s, name, sub_modules, decode_debug_information) =
    let
      val debug_variables : bool ref = ref(false)
      val sub_modules = map (fn (modname,(a,b),(c,d),(e,f)) => (modname,a,c,e)) sub_modules
      val _ = print_reqlist sub_modules
      val decfuntypehashtable = NewHashTable.new(4000,op = : int * int -> bool, fn x => x)
      val strmap = ref(IntMap.empty : Datatypes.Structure IntMap.T)
      val strmap_count = ref 0

      val sub_modules' =
	NewMap.from_list'
	String.<
	(map (fn (elt as (name, _, _, _)) => (name, elt)) sub_modules)

      val (_, tyname_count,strname_count,tyfun_count) =
	case NewMap.tryApply'(sub_modules', name) of
	  NewMap.YES elt => elt
	| _ => 
            if decode_debug_information then 
              ("",Types.pervasive_tyname_count,Strenv.pervasive_strname_count,
               Types.pervasive_tyfun_count)
            else Crash.impossible("sub_module '" ^ name ^ "' missing")

      fun name_offsets sub_name = NewMap.apply'(sub_modules', sub_name) 
        handle NewMap.Undefined =>
          if decode_debug_information then 
            ("",Types.pervasive_tyname_count,Strenv.pervasive_strname_count,
             Types.pervasive_tyfun_count)
          else 
	  Info.error'
	    (Info.make_default_options ())
	    (Info.FATAL, Info.Location.FILE name, "Unknown module " ^ sub_name)

      fun decode_bool ptr =
	case String.ordof(s, ptr) of
	  0 => (false, ptr+1)
	| 1 => (true, ptr+1)
	| _ => raise CorruptFile 4
d1300 7
a1306 2
      fun decode_string ptr =
	input_opt_string(s, ptr)
d1308 7
a1314 6
      fun decode_symbol ptr =
	let
	  val (sy, ptr) = input_opt_string(s, ptr)
	in
	  (Symbol.find_symbol sy, ptr)
	end
d1316 9
a1324 12
      fun decode_valid ptr =
	let
	  val (sy_type, ptr) = input_byte(s, ptr)
	  val (sy, ptr) = decode_symbol ptr
	  val id = case sy_type of
	    0 => Ident.VAR sy
	  | 1 => Ident.CON sy
	  | 2 => Ident.EXCON sy
	  | _ => raise CorruptFile 5
	in
	  (id, ptr)
	end
d1326 2
a1327 8
      fun decode_tyvar ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	  val (b1, ptr) = decode_bool ptr
	  val (b2, ptr) = decode_bool ptr
	in
	  (Ident.TYVAR(sy, b1, b2), ptr)
	end
d1329 5
a1333 6
      fun decode_lab ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.LAB sy, ptr)
	end
d1335 7
a1341 6
      fun decode_tycon ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.TYCON sy, ptr)
	end
d1343 7
a1349 6
      fun decode_funid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.FUNID sy, ptr)
	end
d1351 9
a1359 6
      fun decode_sigid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.SIGID sy, ptr)
	end
d1361 2
a1362 6
      fun decode_strid ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.STRID sy, ptr)
	end
d1364 15
a1378 5
      fun decode_tyname_id ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
d1380 11
a1390 7
	    (* absolute - used for pervasives *)
	    0 => 
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		(Tyname_id.make_tyname_n n, ptr)
	      end
d1392 13
a1404 7
	  (* local *)
	  | 1 =>
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		(Tyname_id.make_tyname_n (tyname_count + n), ptr)
	      end
d1406 7
a1412 9
	  (* external *)
	  | 2 =>
	      let
		val (module, ptr) = decode_string ptr
		val (n, ptr) = input_opt_int(s, ptr)
		val (_, tyname_count,_,_) = name_offsets module
	      in
		(Tyname_id.make_tyname_n (tyname_count + n), ptr)
	      end
d1414 40
a1453 2
	  | _ => raise CorruptFile 6
	end
d1455 1
a1455 5
      fun decode_tyfun_id ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
d1457 27
a1483 7
	    (* absolute - used for pervasives *)
	    0 => 
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		(Tyfun_id.make_tyfun_n n, ptr)
	      end
d1485 21
a1505 7
	  (* local *)
	  | 1 => 
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		(Tyfun_id.make_tyfun_n (tyfun_count + n), ptr)
	      end
d1507 189
a1695 9
	  (* external *)
	  | 2 => 
	      let
		val (module, ptr) = decode_string ptr
		val (n, ptr) = input_opt_int(s, ptr)
		val (_, _,_,tyfun_count) = name_offsets module
	      in
		(Tyfun_id.make_tyfun_n (tyfun_count + n), ptr)
	      end
d1697 5
a1701 11
	  | _ => raise CorruptFile 7
	end

      fun decode_strname_id ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of

	    (* absolute - used for pervasives *)
	    0 => 
d1703 5
a1707 1
		val (n, ptr) = input_opt_int(s, ptr)
d1709 4
a1712 1
		(Strname_id.make_strname_n n, ptr)
d1714 1
a1714 3

	  (* local *)
	  | 1 => 
d1716 2
a1717 1
		val (n, ptr) = input_opt_int(s, ptr)
d1719 2
a1720 1
		(Strname_id.make_strname_n (strname_count + n), ptr)
d1722 1
d1724 9
a1732 9
	  (* external *)
	  | 2 => 
	      let
		val (module, ptr) = decode_string ptr
		val (n, ptr) = input_opt_int(s, ptr)
		val (_, _,strname_count,_) = name_offsets module
	      in
		(Strname_id.make_strname_n (strname_count + n), ptr)
	      end
d1734 27
a1760 2
	  | _ => raise CorruptFile 8
	end
d1762 85
d1848 32
a1879 116
      fun decode_ol_tyvar ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    5 => (Ident.num_tyvar, ptr)
	  | 6 => (Ident.int_tyvar, ptr)
	  | 7 => (Ident.int_literal_tyvar, ptr)
	  | 8 => (Ident.real_tyvar, ptr)
	  | 9 => (Ident.real_literal_tyvar, ptr)
	  | 10 => (Ident.numtext_tyvar, ptr)
	  | _ => raise CorruptFile 17
	end
  
      val dummy_var = Ident.VAR (Ident.Symbol.find_symbol "")

      fun decode_over_loaded ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	  val (tyvar, ptr) = decode_ol_tyvar ptr
	in
	  case i of
	    1 => (Datatypes.UNARY (dummy_var, tyvar), ptr)
	  | 2 => (Datatypes.BINARY (dummy_var, tyvar), ptr)
	  | 3 => (Datatypes.PREDICATE (dummy_var, tyvar), ptr)
	  | _ => raise CorruptFile 9
	end

      fun decode_rev_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = input_opt_int(s, ptr)
	in
	  dec_sub(count, ptr, [])
	end

      fun decode_map f g ptr orderfn =
	let
	  val (assoc_list, ptr) = decode_rev_list (input_pair f g) ptr
	in
	  (Lists.reducel (fn (m, x) => Map.add(x, m, orderfn))
	   (Map.empty_map, assoc_list), ptr)
	end

      val valenvs_so_far = ref 0
      val tyname_valenvs_so_far = ref 0
      val tynames_so_far = ref 0
      fun decode_order(i, j:int) = i<j
      val meta_tynames_decoded_in_tree =
	ref (NewMap.empty (decode_order,op =)) : (int, Datatypes.Tyname ref)NewMap.T ref
      val meta_tynames_so_far = ref 0
      val dummy_tyname =
	Datatypes.METATYNAME(ref(Datatypes.TYFUN(Datatypes.NULLTYPE, 0)), "",
			     0, ref false, ref Datatypes.empty_valenv,ref false)
      val metatyvar_types_so_far = ref 0
      val meta_overloaded_types_so_far = ref 0
      val tyvar_types_so_far = ref 0
      val metarectype_types_so_far = ref 0
      val rectype_types_so_far = ref 0
      val funtype_types_so_far = ref 0
      val constype_types_so_far = ref 0
      val debruijn_types_so_far = ref 0
      val dummy_funtypescheme =
	Datatypes.UNBOUND_SCHEME(Datatypes.FUNTYPE(Datatypes.NULLTYPE,
						   Datatypes.NULLTYPE),
                                  Option.ABSENT)
      val dummy_constypescheme = 
        Datatypes.UNBOUND_SCHEME(Types.int_type,
                                  Option.ABSENT)
      (* Any old type will do *)
      val strnames_so_far = ref 0
      val strnamehashtable = NewHashTable.new(128,(op = : int * int -> bool),fn x => x)
      val metatyvarhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val metaoverloadedhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val tyvarhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val metarectypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val rectypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val constypehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val debruijnhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val valenvhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val tynamevalenvhashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val tynamehashtable = NewHashTable.new(128,(op= : int * int -> bool),fn x => x)
      val tyenv_table = ref(IntMap.empty : Datatypes.Tyenv IntMap.T)
      val tyenvs = ref 0

      fun I constructor (env,ptr) = (constructor env,ptr)

      fun decode_strname ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    1 => I Datatypes.STRNAME(decode_strname_id ptr)
	  | 2 =>
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		if n=0 then
		  let
		    val n = (!strnames_so_far)+1
		    val _ = strnames_so_far := n
		    val (name, ptr) = decode_strname ptr
		    val strname = Datatypes.METASTRNAME(ref name)
		    val _ =
		      NewHashTable.update(strnamehashtable, n, strname)
		  in
		    (strname, ptr)
		  end
		else
		  (mylookup(1,strnamehashtable, n), ptr)
d1881 48
a1928 3
	  | 3 => I Datatypes.NULLNAME(decode_strname_id ptr)
	  | _ => raise CorruptFile 10
	end
d1930 7
a1936 22
    
      fun decode_tyfun ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    1 =>
	      let
		val (ty , ptr) = decode_type ptr
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		(Datatypes.TYFUN(ty, i), ptr)
	      end
	  | 2 => I Datatypes.ETA_TYFUN (decode_tyname ptr)
	  | 3 =>
	      let
		val (tyfunid, ptr) = decode_tyfun_id ptr
	      in
		(Datatypes.NULL_TYFUN(tyfunid,(ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0)))), ptr)
	      end
	  | _ => raise CorruptFile 11
	end
d1938 6
a1943 6
      and decode_typescheme ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    1 =>
d1945 8
a1952 4
		val (i, ptr) = input_opt_int(s, ptr)
		val (ty, ptr) = decode_type ptr
	      in
		(Datatypes.SCHEME(i, (ty,Option.ABSENT)), ptr)
d1954 3
a1956 15
	  | 2 =>
	      let
		val (ty, ptr) = decode_type ptr
	      in
		(Datatypes.UNBOUND_SCHEME(ty,Option.ABSENT),
                 ptr)
	      end
	  | 3 =>
	      let
		val (over, ptr) = decode_over_loaded ptr
	      in 
		(Datatypes.OVERLOADED_SCHEME over, ptr)
	      end
	  | _ => raise CorruptFile 12
	end
d1958 8
a1965 161
      and decode_type ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    1 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = !metatyvar_types_so_far + 1
		    val _ = metatyvar_types_so_far := n
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (ty, ptr) = decode_type ptr
		    val (b1, ptr) = decode_bool ptr
		    val (b2, ptr) = decode_bool ptr
		    val ty = Datatypes.METATYVAR(ref(i, ty,Datatypes.NO_INSTANCE), b1, b2)
		    val _ = NewHashTable.update (metatyvarhashtable, n, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup(2,metatyvarhashtable, i), ptr)
	      end
	  | 2 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = !meta_overloaded_types_so_far + 1
		    val _ = meta_overloaded_types_so_far := n
		    val (ty, ptr) = decode_type ptr
		    val (tv, ptr) = decode_ol_tyvar ptr
		    val ty = Datatypes.META_OVERLOADED
			       (ref ty, tv,
				Ident.VAR (Ident.Symbol.find_symbol ""),
				Info.Location.UNKNOWN)
		    val _ = NewHashTable.update (metaoverloadedhashtable, n, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup(3,metaoverloadedhashtable, i), ptr)
	      end
	  | 3 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = (!tyvar_types_so_far)+1
		    val _ = tyvar_types_so_far := n
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (tyvar, ptr) = decode_tyvar ptr
		    val ty = Datatypes.TYVAR(ref (i,Datatypes.NULLTYPE,
                                                            Datatypes.NO_INSTANCE), tyvar)
		    val _ = NewHashTable.update (tyvarhashtable, n, ty)
		  in
		    (ty, ptr)
		  end		  
		else
		  (mylookup(4,tyvarhashtable, i), ptr)
	      end
	  | 4 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = !metarectype_types_so_far + 1
		    val _ = metarectype_types_so_far := n
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b1, ptr) = decode_bool ptr
		    val (ty, ptr) = decode_type ptr
		    val (b2, ptr) = decode_bool ptr
		    val (b3, ptr) = decode_bool ptr
		    val ty = Datatypes.METARECTYPE(ref(i, b1, ty, b2, b3))
		    val _ = NewHashTable.update (metarectypehashtable, n, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup(5,metarectypehashtable, i), ptr)
	      end
	  | 5 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = !rectype_types_so_far + 1
		    val _ = rectype_types_so_far := n
		    val (ty,ptr) = I Datatypes.RECTYPE (decode_map decode_lab 
                                             decode_type ptr Ident.lab_order)
		    val _ = NewHashTable.update (rectypehashtable, n, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup(6,rectypehashtable, i), ptr)
	      end
	  | 6 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val c = !funtype_types_so_far + 1
		    val _ = funtype_types_so_far := c
		    val (ty1, ptr) = decode_type ptr
		    val (ty2, ptr) = decode_type ptr
		    val ty = Datatypes.FUNTYPE(ty1, ty2)
		    val _ = NewHashTable.update(decfuntypehashtable,c, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup (7,decfuntypehashtable,i), ptr)
	      end
	  | 7 =>
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val n = !constype_types_so_far + 1
		    val _ = constype_types_so_far := n
                    val (the_list, ptr) = input_list(s, decode_type, ptr)
                    val (tyname, ptr) = decode_tyname ptr
                    val ty = Datatypes.CONSTYPE(the_list,tyname)
		    val _ = NewHashTable.update (constypehashtable, n, ty)
		  in
		    (ty, ptr)
		  end
		else
		  (mylookup(8,constypehashtable, i), ptr)
	      end
	  | 8 => 
	      let
		val (i, ptr) = input_opt_int(s, ptr)
	      in
		if i = 0 then
		  let
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b1, ptr) = decode_bool ptr
		    val (b2, ptr) = decode_bool ptr
		    val ty = Datatypes.DEBRUIJN(i, b1, b2,Option.ABSENT)
		    val n = (!debruijn_types_so_far)+1
		    val _ = debruijn_types_so_far := n
		    val _ = NewHashTable.update(debruijnhashtable, n, ty)
		  in
		    (ty, ptr)
		  end		  
		else
		  (mylookup(9,debruijnhashtable, i), ptr)
	      end
	  | 9 => (Datatypes.NULLTYPE, ptr)
	  | _ => raise CorruptFile 13
	end
d1967 18
a1984 26
      and decode_valenv updatetynamehashtable ptr =
	let
	  val (n, ptr) = input_opt_int(s, ptr)
	in
	  if n=0 then
	    let
	      val n = (!valenvs_so_far)+1
	      val _ = valenvs_so_far := n
              val valenv : Datatypes.Valenv ref = ref(Datatypes.empty_valenv)
              val _ = NewHashTable.update(valenvhashtable, n, valenv)
              val _ = updatetynamehashtable valenv
	    in
                I (fn map => (valenv := Datatypes.VE (ref 0, map);
                              valenv))
                (input_newmap (s, decode_valid, decode_typescheme,  
                               ptr, Ident.valid_lt, Ident.valid_eq))
	    end
	  else
            let
              val (valenv,ptr) = 
                (mylookup(10,valenvhashtable, n), ptr)
            in
              (updatetynamehashtable valenv;
               (valenv,ptr))
            end
        end
d1986 7
a1992 9
      and decode_dummy_scheme ptr =
	let
	  val (n, ptr) = input_byte(s, ptr)
	in
	  case n of
	    1 => (dummy_constypescheme, ptr)
	  | 2 => (dummy_funtypescheme, ptr)
	  | _ => raise CorruptFile 14
	end
d1994 7
a2000 27
      and decode_tyname_valenv ptr =
	let
	  val (n, ptr) = input_byte(s, ptr)
	in
	  case n of
	    1 => decode_valenv (fn _ => ()) ptr
	  | 2 =>
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		if n = 0 then
		  let
		    val (mapping, ptr) =
		      input_newmap(s, decode_valid, decode_dummy_scheme, ptr, Ident.valid_lt, Ident.valid_eq)
		    val valenv = Datatypes.VE(ref 0, mapping)
		    val n = (!tyname_valenvs_so_far)+1
		  in
		    tyname_valenvs_so_far := n;
		    NewHashTable.update
		    (tynamevalenvhashtable, n, valenv);
		    (ref valenv, ptr)
		  end
		else
		  (ref(mylookup(11,tynamevalenvhashtable, n)), ptr)
	      end
	  | _ => raise CorruptFile 15
	end
d2002 7
a2008 85
      and decode_tyname ptr =
	let
	  val (i, ptr) = input_byte(s, ptr)
	in
	  case i of
	    1 =>
	      let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		if n = 0 then
		  let
		    val n = !tynames_so_far + 1
		    val _ = tynames_so_far := n
		    val (tyname_id, ptr) = decode_tyname_id ptr
		    val (st, ptr) = decode_string ptr
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b, ptr) = (I ref o decode_bool) ptr
                    val is_abs = ref(false)
		    val (valenv, ptr) = 
                      (if !debug_variables then 
                         decode_valenv 
                         (fn valenv => 
                          let
                            val tyname =
                              Datatypes.TYNAME(tyname_id,st,i,b,valenv,Option.ABSENT,is_abs,valenv)
                          in
                            NewHashTable.update (tynamehashtable, n, tyname)
                          end)
                       else decode_tyname_valenv) ptr
                    val (is_abs',ptr) = decode_bool ptr
                    val _ = is_abs := is_abs'
		    val tyname = Datatypes.TYNAME(tyname_id,st,i,b,valenv,Option.ABSENT,is_abs,valenv)
		    val _ = NewHashTable.update (tynamehashtable, n, tyname)
		  in
		    (tyname, ptr)
		  end
		else
                  (mylookup(12,tynamehashtable, n), ptr)
	      end
	  | 2 =>
              let
		val (n, ptr) = input_opt_int(s, ptr)
	      in
		if n = 0 then
		  let
		    val r = ref dummy_tyname
                    val tf = ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))
		    val next = (!meta_tynames_so_far)+1
		    val _ = meta_tynames_so_far := next
		    val _ =
		      meta_tynames_decoded_in_tree :=
		      NewMap.define(!meta_tynames_decoded_in_tree, next, r)
                    val ((tyfun,st,i,b,valenv,is_abs),ptr) = 
                      if !debug_variables then
                        let
                          val ((st,i,b,is_abs),ptr) =
                            input_quadruple decode_string (fn ptr =>input_opt_int(s, ptr)) 
                            (I ref o decode_bool) (I ref o decode_bool) ptr
                          val ((valenv,tyfun),ptr) = 
                            input_pair 
                            (decode_valenv
                             (fn valenv => 
                              let
                                val tyname = Datatypes.METATYNAME(tf, st, i, b, valenv, is_abs)
                              in
                                r := tyname
                              end)) decode_tyfun ptr
                        in
                          ((tyfun,st,i,b,valenv,is_abs),ptr)
                        end
                      else
                        input_sixtuple decode_tyfun decode_string 
                        (fn ptr =>input_opt_int(s, ptr)) (I ref o decode_bool) 
                        decode_tyname_valenv (I ref o decode_bool) ptr
		    val tyname = Datatypes.METATYNAME(tf, st, i, b, valenv, is_abs)
                    val _ = tf := tyfun
		  in
                    (r := tyname;
		    (tyname, ptr))
		  end
		else
                  (!(NewMap.apply (!meta_tynames_decoded_in_tree) n), ptr)
	      end
	  | _ => raise CorruptFile 16
	end
d2010 7
a2016 75
      and decode_runtime_env ptr = 
        let 
          val input_byte = fn ptr => input_byte(s, ptr)
          val input_int = fn ptr => input_int(s, ptr)
          val input_list = fn f=> fn ptr=> input_list(s,f,ptr)
          val decode_spill = 
            (fn ptr => I ref(
                  let 
                   val (i, ptr) = input_byte ptr
                  in 
                    I
                    (case i of
                       1 => Debugger_Env.Option.SOME1
                     | 2 => Debugger_Env.Option.SOME2
                     | _ => Crash.impossible "decode_spill:decode_runtime_env:encapsulate")
                       (input_int ptr)
                 end))
          fun decode_string ptr = 
            let
              val (size, ptr) = input_int ptr
            in
              (String.substring(s, ptr, size), ptr + size)
            end
          fun decode_option decode ptr =
            let 
              val (i, ptr) = input_byte ptr
            in 
              case i of
                1 => (Option.ABSENT,ptr)
              | 2 => I Option.PRESENT(decode ptr)
              | _ => Crash.impossible "decode_option:encapsulate"
            end
          val (i, ptr) = input_byte ptr
        in
          case i of
            1 => I Debugger_Env.APP(input_triple decode_runtime_env decode_runtime_env 
                                  (decode_option input_int) ptr)
          | 2 => (Debugger_Env.EMPTY,ptr)
          | 3 => I Debugger_Env.FN(input_quadruple decode_string decode_runtime_env decode_spill
                                 (fn ptr => (Option.ABSENT,ptr)) ptr)
          | 4 => I Debugger_Env.LET(input_pair (input_list (input_pair
                  (decode_option 
                          (input_triple decode_string
                           (fn ptr => I ref((fn (ty,ptr)=>((ty,Option.ABSENT,nil),ptr))
                                            (decode_type ptr)))
                           (decode_option decode_spill)))
                  decode_runtime_env)) decode_runtime_env ptr)
          | 5 => I Debugger_Env.HANDLE(input_fivetuple decode_runtime_env decode_spill
                                       input_int input_int decode_runtime_env ptr)
          | 6 => I Debugger_Env.RAISE(decode_runtime_env ptr)
          | 7 => I Debugger_Env.SELECT(input_pair input_int decode_runtime_env ptr)
          | 8 => I Debugger_Env.STRUCT(input_list decode_runtime_env ptr)
          | 9 => 
            I Debugger_Env.SWITCH(input_quadruple decode_runtime_env decode_spill input_int
             (input_list (input_pair 
              (fn ptr => 
               let 
                 val (i, ptr) = input_byte ptr
               in 
                 case i of
                   1 => I Debugger_Env.CONSTRUCTOR(decode_string ptr)
                 | 2 => I Debugger_Env.INT(decode_string ptr)
                 | 3 => I Debugger_Env.REAL(decode_string ptr)
                 | 4 => I Debugger_Env.STRING(decode_string ptr)
                 | 5 => (Debugger_Env.DYNAMIC,ptr)
                 | 6 => (Debugger_Env.DEFAULT,ptr)
                 | _ => 
                  Crash.impossible "decode_tag:decode_runtime_env:decode_type_basis:encapsulate"
               end)
              decode_runtime_env)) ptr)
          | 10 => I Debugger_Env.LIST(input_list decode_runtime_env ptr)
          | 11 => (Debugger_Env.BUILTIN,ptr)
          | _ => 
              Crash.impossible "decode_runtime_env:decode_type_basis:encapsulate"
        end
d2018 8
a2025 7
      fun decode_tystr ptr =
	let
	  val (tyfun, ptr) = decode_tyfun ptr
	  val (valenv, ptr) = decode_valenv (fn _ => ()) ptr
	in
	  (Datatypes.TYSTR(tyfun, !valenv), ptr)
	end
d2027 7
a2033 19
      fun decode_tyenv ptr =
	let
	  val (i, ptr) = input_opt_int(s, ptr)
	  val table = !tyenv_table
	in
	  if i = 0 then
	    let
	      val (tyenv, ptr) =
		input_newmap(s, decode_tycon, decode_tystr, ptr, Ident.tycon_lt, Ident.tycon_eq)
	      val tyenv = Datatypes.TE tyenv
	      val envs = !tyenvs + 1
	    in
	      tyenvs := envs;
	      tyenv_table := IntMap.define(table, envs, tyenv);
	      (tyenv, ptr)
	    end
	  else
	    (IntMap.apply'(table, i), ptr)
	end
d2035 2
a2036 8
      fun decode_env ptr =
	let
	  val (strenv, ptr) = decode_strenv ptr
	  val (tyenv, ptr) = decode_tyenv ptr
	  val (valenv, ptr) = decode_valenv (fn _ => ()) ptr
	in
	  (Datatypes.ENV(strenv, tyenv, !valenv), ptr)
	end
d2038 7
a2044 18
      and decode_str ptr =
	let
	  val (n, ptr) = input_opt_int(s, ptr)
	in
	  case n of
	    0 =>
	      let
		val count = !strmap_count + 1
		val _ = strmap_count := count  
		val (strname, ptr) = decode_strname ptr
		val (env, ptr) = decode_env ptr
		val str = Datatypes.STR(strname,ref Option.ABSENT,env)
	      in
		strmap := IntMap.define(!strmap, count, str);
		(str, ptr)
	      end
	  | _ => (IntMap.apply'(!strmap, n), ptr)
	end
d2046 7
a2052 7
      and decode_strenv ptr =
	let
	  val (strenv, ptr) =
	    input_newmap(s, decode_strid, decode_str, ptr, Ident.strid_lt, Ident.strid_eq)
	in
	  (Datatypes.SE strenv, ptr)
	end
d2054 7
a2060 7
      fun decode_nameset ptr =
	let
	  val (tynames, ptr) = decode_rev_list decode_tyname ptr
	  val (strnames, ptr) = decode_rev_list decode_strname ptr
	in
	  (Nameset.nameset_of_name_lists(tynames, strnames), ptr)
	end
d2062 51
a2112 7
      fun decode_sigma ptr =
	let
	  val (nameset, ptr) = decode_nameset ptr
	  val (str, ptr) = decode_str ptr
	in
	  (BasisTypes.SIGMA(nameset, str), ptr)
	end
d2114 13
a2126 7
      fun decode_sigenv ptr =
	let
	  val (sigenv, ptr) =
	    input_newmap(s, decode_sigid, decode_sigma, ptr, Ident.sigid_lt, Ident.sigid_eq)
	in
	  (BasisTypes.SIGENV sigenv, ptr)
	end
d2128 1
a2128 8
      fun decode_phi ptr =
	let
	  val (nameset, ptr) = decode_nameset ptr
	  val (str, ptr) = decode_str ptr
	  val (sigma, ptr) = decode_sigma ptr
	in
	  (BasisTypes.PHI(nameset, (str, sigma)), ptr)
	end
d2130 34
a2163 7
      fun decode_funenv ptr =
	let
	  val (funenv, ptr) =
	    input_newmap(s, decode_funid, decode_phi, ptr, Ident.funid_lt, Ident.funid_eq)
	in
	  (BasisTypes.FUNENV funenv, ptr)
	end
d2165 3
a2167 2
      fun decode_int ptr =
        input_opt_int(s, ptr)
d2169 8
a2176 145
      fun decode_tyfun_int ptr =
        let
          val (tyfun,ptr) = decode_tyfun ptr
          val (n,ptr) = input_opt_int (s,ptr)
        in
          ((tyfun,n),ptr)
        end

      fun decode_valenv_int ptr =
        let
          val (valenv,ptr) = decode_valenv (fn _ => ()) ptr
          val (n,ptr) = input_opt_int (s,ptr)
        in
          ((!valenv,n),ptr)
        end

      fun decode_ty_ass_val_entry ptr =
        let 
          val (tyfun,ptr) = decode_tyfun ptr
          val ((valenv,n'),ptr) = decode_valenv_int ptr
        in
          ((tyfun,(valenv,n')),ptr)
        end     

      fun decode_strname_int ptr =
        let
          val (strname,ptr) = decode_strname ptr
          val (n,ptr) = input_opt_int (s,ptr)
        in
          ((strname,n),ptr)
        end

      fun decode_recipe ptr = 
        let
          val (i, ptr) = input_byte(s, ptr)
        in
          case i of 
            0 => (Debugger_Types.Nop,ptr)
          | 1 => 
              let
                val (arg,ptr) = input_pair decode_int decode_recipe ptr
              in
                (Debugger_Types.Select arg,ptr)
              end
          | 2 => 
              let
                val (args,ptr) = input_list(s, input_pair decode_string decode_recipe, ptr)
              in
                (Debugger_Types.MakeRecord args,ptr)
              end
          | 3 =>
              let
                val (arg,ptr) = decode_recipe ptr
              in
                (Debugger_Types.Funarg arg,ptr)
              end
          | 4 =>
              let
                val (arg,ptr) = decode_recipe ptr
              in
                (Debugger_Types.Funres arg,ptr)
              end
          | 5 =>
              let
                val (arg,ptr) = input_pair decode_recipe decode_recipe ptr
              in
                (Debugger_Types.MakeFunType arg,ptr)
              end
          | 6 => 
              let
                val (arg,ptr) = input_pair decode_int decode_recipe ptr
              in
                (Debugger_Types.DeCons arg,ptr)
              end
          | 7 =>
              let
                val (arg,ptr) = input_pair (fn ptr => input_list(s, decode_recipe, ptr)) decode_tyname ptr
              in
                (Debugger_Types.MakeConsType arg,ptr)
              end
          | 8 => (Debugger_Types.Error,ptr)
          | _ => Crash.impossible "problems in decoding a recipe"
        end

      fun decode_rev_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = input_opt_int(s, ptr)
	in
	  dec_sub(count, ptr, [])
	end
      
      fun decode_debug decode_runtime_env ptr = 
            input_newmap (s, decode_string,
                          input_pair
                          (input_triple
                           decode_type
                           decode_bool
                           (fn ptr => input_list(s, input_pair decode_int decode_recipe, ptr)))
                          decode_runtime_env,
                         ptr,
                         String.<,
                         op =)

      val (debug_variables, ptr) = 
        I (fn b => 
           (debug_variables := b;b))
        (decode_bool 0)
      val ((nameset,funenv,sigenv,env), ptr) = 
        if decode_debug_information andalso not debug_variables then
          ((Nameset.empty_nameset(),BasisTypes.FUNENV(NewMap.empty (fn _ => false,fn _ => true)),
            BasisTypes.SIGENV(NewMap.empty (fn _ => false,fn _ => true)),
            Datatypes.ENV(Datatypes.SE(NewMap.empty (fn _ => false,fn _ => true)),
                          Datatypes.TE(NewMap.empty (fn _ => false,fn _ => true)),
                          Datatypes.empty_valenv)),
          ptr)
        else
          input_quadruple decode_nameset decode_funenv decode_sigenv decode_env ptr
      val (debug_information,_) = 
        if debug_variables then 
          decode_debug decode_runtime_env ptr
        else
          if decode_debug_information then
            (NewMap.empty (fn _ => false,fn _ => true),ptr)
          else
            decode_debug (fn ptr=>(Debugger_Env.EMPTY,ptr)) ptr

      (* Set level to 0 since it will be for a topdec *)
      val result = (BasisTypes.BASIS(0,nameset, funenv, sigenv, env), 
                    debug_information)

      val _ =
	if !print_hash_table_stats then
	  output(std_out,"DecFuntypeHashTable in _encapsulate: " ^
		 NewHashTable.string_hash_table_stats(decfuntypehashtable) ^ "\n")
	else ()
    in
      result
    end handle
d2183 26
a2208 15
  fun reset_refs(BasisTypes.BASIS(_, nameset, funenv, sigenv, env), value) =
    let
      fun reset_map_range fun2 m =
	Lists.iterate (fun2 o #2) (Map.assoc m)
      fun reset_newmap_range fun2 m =
	NewMap.iterate (fun2 o #2) m
      fun reset_strnameid_map_range fun2 m =
	Strname_id.Map.iterate (fun2 o #2) m
      fun reset_tynameid_map_range fun2 m =
	Tyfun_id.Map.iterate (fun2 o #2) m
      fun reset_tyname_id n = ()
      fun reset_strname_id n = ()
      fun reset_strname(Datatypes.STRNAME s) = reset_strname_id s
      | reset_strname(Datatypes.METASTRNAME s) = ()
      | reset_strname(Datatypes.NULLNAME s) = reset_strname_id s
d2210 86
a2295 10
      fun reset_valenv(Datatypes.VE(r, M)) =
	let
	  val n = !r
	in
	  if n = value then
	    ()
	  else
	    (r := value;
	     reset_newmap_range reset_typescheme M)
	end
d2297 3
a2299 90
      and reset_tyname(Datatypes.TYNAME(ti, s, n, r as ref b, ref ve,_,_,_)) =
	(reset_tyname_id ti;
	 reset_valenv ve)
      | reset_tyname(Datatypes.METATYNAME(ref tf, s, n, ref b, ref ve, _)) =
	(reset_tyfun tf;
	 reset_valenv ve)

      and reset_type(Datatypes.METATYVAR(ref(n, t,_), b1, b2)) =
	reset_type t
      | reset_type(Datatypes.META_OVERLOADED {1=ref t,...}) =
	reset_type t
      | reset_type(Datatypes.TYVAR(ref (n,_,_), t)) = ()
      | reset_type(Datatypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
	reset_type t
      | reset_type(Datatypes.RECTYPE M) =
	reset_map_range reset_type M
      | reset_type(Datatypes.FUNTYPE(t1, t2)) =
	(reset_type t1;
	 reset_type t2)
      | reset_type(Datatypes.CONSTYPE(l, t)) =
	(Lists.iterate reset_type l;
	 reset_tyname t)
      | reset_type(Datatypes.DEBRUIJN(n, b1, b2,_)) = ()
      | reset_type(Datatypes.NULLTYPE) = ()

      and reset_typescheme(Datatypes.SCHEME(n, (t,_))) =
	reset_type t
      | reset_typescheme(Datatypes.UNBOUND_SCHEME (t,_)) =
	reset_type t
      | reset_typescheme(Datatypes.OVERLOADED_SCHEME _) = ()

      and reset_tyfun(Datatypes.TYFUN(t, n)) =
	reset_type t
      | reset_tyfun(Datatypes.ETA_TYFUN tn) =
	reset_tyname tn
      | reset_tyfun(Datatypes.NULL_TYFUN tfi) = ()

      and reset_tystr(Datatypes.TYSTR(tf, ve)) =
	(reset_tyfun tf;
	 reset_valenv ve)

      and reset_tyenv(Datatypes.TE M) =
	reset_newmap_range reset_tystr M

      and reset_str(Datatypes.STR(sn,_,e)) =
	(reset_strname sn;
	 reset_env e)
        | reset_str(Datatypes.COPYSTR((smap,tmap),str)) =
	  (
(*
	   output(std_out, "Copying a structure during reset_str\n");
	   reset_str (Env.str_copy (str,smap,tmap));
*)
	   reset_str str;
	   reset_strnameid_map_range reset_strname smap;
	   reset_tynameid_map_range reset_tyname tmap
	   )

      and reset_strenv(Datatypes.SE M) =
	reset_newmap_range reset_str M

      and reset_env(Datatypes.ENV(se, te, ve)) =
	(reset_strenv se;
	 reset_tyenv te;
	 reset_valenv ve)

      and reset_sigma(BasisTypes.SIGMA(ns, s)) =
	(reset_nameset ns;
	 reset_str s)

      and reset_sigenv(BasisTypes.SIGENV M) =
	reset_newmap_range reset_sigma M

      and reset_phi(BasisTypes.PHI(ns, (s, sg))) =
	(reset_nameset ns;
	 reset_str s;
	 reset_sigma sg)

      and reset_funenv(BasisTypes.FUNENV M) =
	reset_newmap_range reset_phi M

      and reset_nameset ns =
	(Lists.iterate reset_tyname (Nameset.tynames_of_nameset ns);
	 Lists.iterate reset_strname (Nameset.strnames_of_nameset ns))
    in
      (reset_nameset nameset;
       reset_funenv funenv;
       reset_sigenv sigenv;
       reset_env env)
    end
d2301 8
a2308 12
  fun clean_basis basis =
    (reset_refs(basis, ~1);
     reset_refs(basis, 0))

  fun decode_cons s =
    let
      fun decode_time ptr =
        let
          val (time_string, ptr) = input_sz_string (s, ptr)
        in
          (MLWorks.Time.decode time_string, ptr)
        end
d2310 1
a2310 1
      fun decode_string ptr = input_sz_string(s, ptr)
d2312 8
a2319 8
      fun decode_cons_triple ptr =
	let
	  val (mod_name, ptr) = decode_string ptr
	  val (req_name, ptr) = decode_string ptr
	  val (time, ptr) = decode_time ptr
	in
	  ({mod_name = mod_name, req_name = req_name, time = time}, ptr)
	end
d2321 5
a2325 5
      val (result, _) =
        input_list(s, decode_cons_triple, 0)
    in
      result
    end
d2327 18
a2344 18
  fun print_info (filename,tynames,strnames,tyfuns,require_list) =
    if domydebug
      then
        (output(std_out,filename ^ " " ^ Integer.makestring tynames ^ " " ^ Integer.makestring strnames ^ " " ^ Integer.makestring tyfuns ^ "\n");
         Lists.iterate 
         (fn (name,a,b,c) =>
          output(std_out,name ^ " " ^ Integer.makestring a ^ " " ^ Integer.makestring b ^ " " ^ Integer.makestring c ^ "\n"))
         require_list)
    else ()

  fun output_file debug_variables
    {filename, code, tynames, strnames, tyfuns, parser_env, lambda_env,
     type_basis, debug_info = Debugger_Types.INFO debug_info, require_list, consistency} =
    let
      val file_handle = MLWorks.Internal.FileIO.openf filename
      val close = MLWorks.Internal.FileIO.closef
      val write = MLWorks.Internal.FileIO.writef
      fun seek pos = MLWorks.Internal.FileIO.seekf(file_handle, pos, MLWorks.Internal.FileIO.BEG)
d2346 1
a2346 1
      val fpos = ref 0
d2348 2
a2349 2
      fun write_byte i =
	(MLWorks.Internal.FileIO.write_byte(file_handle, i); fpos := !fpos + 1)
d2555 1
a2555 1
          val valhashtable = 
d2577 1
a2577 1
	  fun write_pe (ParserEnv.E(ParserEnv.FE fix_map, ParserEnv.VE val_map, 
d2638 1
a2638 1
              end	  
d2640 1
a2640 1
          val lambdavalhashtable = 
d2682 1
a2682 1
	  val _ = 
d2695 1
a2695 1
      fun write_type_basis(BasisTypes.BASIS(_, nameset, funenv, sigenv, env), 
d2711 1
a2711 1
	  val valenvhashtable = 
d2763 1
a2763 1
		| search ((module,_,(strname_count,strname_no),_)::rest) = 
d2787 1
a2787 1
		| search ((module,_,_,(tyfun_count,tyfun_no))::rest) = 
d2815 1
a2815 1
	    ref [] : ((int * Datatypes.Type * Datatypes.Instance) ref 
d2896 1
a2896 1
		  | es' [] = 
d3015 3
a3017 3
          and write_runtime_env env = 
            let 
              val write_spill = 
d3020 1
a3020 1
                    Debugger_Env.Option.SOME1(spill)=>  
d3022 1
a3022 1
                  | Debugger_Env.Option.SOME2(spill)=> 
d3032 2
a3033 2
              fun write_runtime_env(Debugger_Env.APP(env)) = 
                (write_byte 1; 
d3036 2
a3037 2
                | write_runtime_env(Debugger_Env.FN(env)) = 
                  (write_byte 3; 
d3039 1
a3039 1
                | write_runtime_env(Debugger_Env.LET(env as (env1,env2))) = 
d3041 1
a3041 1
                     Debugger_Env.LET([env2],env3) => 
d3043 1
a3043 1
                   | _ => 
d3045 1
a3045 1
                        write_pair 
d3053 1
a3053 1
                | write_runtime_env(Debugger_Env.HANDLE(env)) = 
d3055 1
a3055 1
                   write_fivetuple write_runtime_env write_spill 
d3057 1
a3057 1
                | write_runtime_env(Debugger_Env.RAISE(env)) = 
d3059 1
a3059 1
                | write_runtime_env(Debugger_Env.SELECT(env)) = 
d3063 1
a3063 1
                | write_runtime_env(Debugger_Env.STRUCT(envs)) = 
d3066 1
a3066 1
                | write_runtime_env(Debugger_Env.SWITCH(envs)) = 
d3068 2
a3069 2
                   write_quadruple write_runtime_env write_spill write_int 
                   (write_list (write_pair 
d3079 1
a3079 1
                | write_runtime_env(Debugger_Env.LIST(envs)) = 
d3103 1
a3103 2
	    | encode_type
		(done, Datatypes.META_OVERLOADED(arg as ref t, tv, _, _)) =
d3133 1
a3133 1
	      end	  
d3226 1
a3226 1
	  and encode_typescheme(done, Datatypes.SCHEME(n, (t,_))) = 
d3374 3
a3376 3
	  fun write_ty_ass_val_entry (tyfun,(valenv,n')) = 
	    (do_output (encode_tyfun ([],tyfun)); 
	     do_output (encode_valenv ([],valenv)); 
d3412 2
a3413 2
	  Timer.xtime("write_debug",   !do_timings, 
            fn () => write_debug (if debug_variables then write_runtime_env 
d3449 3
a3451 3
      val (ty_start, _, ty_end) = 
        (!fpos, 
         write_type_basis (type_basis, debug_info, require_list), 
@


1.121
log
@Changes for new overloading scheme.
@
text
@d4 3
d851 4
a854 2
    else if tyvar = Ident.real_tyvar then output_byte 7
    else if tyvar = Ident.numtext_tyvar then output_byte 8
d1378 4
a1381 2
	  | 7 => (Ident.real_tyvar, ptr)
	  | 8 => (Ident.numtext_tyvar, ptr)
@


1.120
log
@Remove message about reset_str
@
text
@d4 3
d522 1
d845 16
a860 3
  fun encode_over_loaded (Datatypes.UNARY _) = output_byte 1
    | encode_over_loaded (Datatypes.BINARY _) = output_byte 2
    | encode_over_loaded (Datatypes.PREDICATE _) = output_byte 3
d1366 14
d1383 1
d1386 3
a1388 6
	    1 => (Datatypes.UNARY (Ident.VAR (Ident.Symbol.find_symbol (""))),
                  ptr)
	  | 2 => (Datatypes.BINARY (Ident.VAR (Ident.Symbol.find_symbol (""))),
                  ptr)
	  | 3 => (Datatypes.PREDICATE (Ident.VAR (Ident.Symbol.find_symbol (""))),
                  ptr)
d1570 1
d1572 3
a1574 1
                                  (ref (ty),Ident.VAR (Ident.Symbol.find_symbol ("")))
d2220 1
a2220 1
      | reset_type(Datatypes.META_OVERLOADED(ref t,_)) =
d2240 1
a2240 1
      | reset_typescheme(Datatypes.OVERLOADED_SCHEME ov) = ()
d3108 2
a3109 1
	    | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t,_)) =
d3120 1
a3120 1
		  encode_type(done, t)
d3237 1
a3237 1
	      encode_over_loaded ov :: output_byte 3 :: done
@


1.119
log
@Add original require file names to consistency info.
@
text
@d4 3
d2227 1
a2227 1
	  (output(std_out, "Copying a structure during reset_str\n");
d2229 1
@


1.118
log
@Moved module type into separate file
@
text
@d4 3
d2281 9
d2291 1
a2291 1
        input_list(s, input_pair decode_string decode_time, 0)
d3399 1
d3402 8
@


1.117
log
@Monomorphic debugger encapsulation.
@
text
@d4 3
d476 1
a476 1
require "../machine/machtypes";
d499 1
a499 1
  structure MachTypes : MACHTYPES
d530 1
a530 1
  structure MachTypes = MachTypes
d541 1
a541 1
  type Module = MachTypes.Module
d810 1
a810 1
    | count_real_objects(count, MachTypes.WORDSET(MachTypes.WORD_SET{2=w_list, ...}) :: rest) =
d2446 1
a2446 1
      fun write_code(MachTypes.MODULE element_list) =
d2448 1
a2448 1
	  fun output_module_element(MachTypes.REAL(i, r)) =
d2451 1
a2451 1
	    | output_module_element(MachTypes.STRING(i, s)) =
d2454 1
a2454 1
	    | output_module_element(MachTypes.MLVALUE(i, s)) =
d2456 1
a2456 1
	    | output_module_element(MachTypes.WORDSET(MachTypes.WORD_SET{1=str_list, 2=w_list, 3=leaf_list, 4=offsets_list,...})) =
d2484 1
a2484 1
            | output_module_element(MachTypes.EXTERNAL(i, s)) =
d2487 1
a2487 1
            | output_module_element(MachTypes.VAR _) =
d2489 1
a2489 1
	    | output_module_element(MachTypes.EXN _) =
d2491 1
a2491 1
	    | output_module_element(MachTypes.STRUCT _) =
d2493 1
a2493 1
	    | output_module_element(MachTypes.FUNCT _) =
@


1.116
log
@Changed Info.default_options to Info.make_default_options ().
@
text
@d4 3
a475 1
require "../debugger/debugger_env";
a501 1
  structure Debugger_Env_type : DEBUGGER_ENVIRONMENT_TYPE
d509 1
a509 1
  sharing Debugger_Env_type.Option = Basis.BasisTypes.Datatypes.Option
d514 1
a514 1
    	       Basis.BasisTypes.Datatypes.Type = Debugger_Env_type.Type
a515 2
  sharing type Debugger_Env_type.debugger_env =
	       Debugger_Types.Debugger_Env.debugger_env
d534 1
a534 1
  structure Debugger_Env_type = Debugger_Env_type
d536 1
d664 33
d824 1
d942 1
a942 1
	    input_newmap(s, decode_strid, input_pair read_env read_field, ptr, Ident.strid_lt, Ident.strid_eq)
d952 1
a952 1
	  ((EnvironTypes.FIELD{index=offset, size=total_size}, env),
d1115 1
a1115 1
  fun print_reqlist (require_list) =
d1128 1
a1128 1
    fun decode_type_basis (s, name, sub_modules) =
d1130 1
d1145 5
a1149 1
	| _ => Crash.impossible("sub_module '" ^ name ^ "' missing")
d1153 4
d1397 1
a1397 1
                                  Datatypes.Option.ABSENT)
d1400 1
a1400 1
                                  Datatypes.Option.ABSENT)
d1417 2
d1424 1
a1424 6
	    1 =>
	      let
		val (id, ptr) = decode_strname_id ptr
	      in
		(Datatypes.STRNAME id, ptr)
	      end
d1443 1
a1443 6
	  | 3 =>
	      let
		val (id, ptr) = decode_strname_id ptr
	      in
		(Datatypes.NULLNAME id, ptr)
	      end
d1460 1
a1460 6
	  | 2 =>
	      let
		val (tyname, ptr) = decode_tyname ptr
	      in
		(Datatypes.ETA_TYFUN tyname, ptr)
	      end
d1465 1
a1465 1
		(Datatypes.NULL_TYFUN (tyfunid,Datatypes.Option.ABSENT), ptr)
d1480 1
a1480 1
		(Datatypes.SCHEME(i, (ty,Datatypes.Option.ABSENT)), ptr)
d1486 1
a1486 1
		(Datatypes.UNBOUND_SCHEME(ty,Datatypes.Option.ABSENT), 
d1516 1
a1516 2
		    val _ =
		      NewHashTable.update(metatyvarhashtable, n, ty)
d1533 2
a1534 4
                      (ref ty,Ident.VAR (Ident.Symbol.find_symbol ("")))
		    val _ =
		      NewHashTable.update
		      (metaoverloadedhashtable, n, ty)
d1539 1
a1539 2
		  (mylookup(3,metaoverloadedhashtable, i),
		   ptr)
d1552 2
a1553 3
                                        Datatypes.NO_INSTANCE), tyvar)
		    val _ =
		      NewHashTable.update(tyvarhashtable, n, ty)
d1574 1
a1574 2
		    val _ =
                      NewHashTable.update(metarectypehashtable, n, ty)
d1589 3
a1591 4
		    val (lab_map, ptr) =
		      decode_map decode_lab decode_type ptr Ident.lab_order
		    val ty = Datatypes.RECTYPE lab_map
		    val _ = NewHashTable.update(rectypehashtable, n, ty)
d1624 4
a1627 4
		    val (the_list, ptr) = input_list(s, decode_type, ptr)
		    val (tyname, ptr) = decode_tyname ptr
		    val ty = Datatypes.CONSTYPE(the_list, tyname)
		    val _ = NewHashTable.update(constypehashtable, n, ty)
d1643 1
a1643 1
		    val ty = Datatypes.DEBRUIJN(i, b1, b2,Datatypes.Option.ABSENT)
d1657 1
a1657 1
      and decode_valenv ptr =
d1665 3
a1667 5
	      val (valenv, ptr) =
		input_newmap(s, decode_valid, decode_typescheme,  
                ptr, Ident.valid_lt, Ident.valid_eq)
	      val valenv = Datatypes.VE(ref 0, valenv)
	      val _ = NewHashTable.update(valenvhashtable, n, valenv)
d1669 4
a1672 1
	      (valenv, ptr)
d1675 8
a1682 2
	    (mylookup(10,valenvhashtable, n), ptr)
	end
d1699 1
a1699 6
	    1 =>
	      let
		val (ve, ptr) = decode_valenv ptr
	      in
		(ref ve, ptr)
	      end
d1717 1
a1717 2
		  (ref(mylookup(11,tynamevalenvhashtable, n)),
		   ptr)
d1725 1
a1725 1
          val result = 
d1738 17
a1754 6
		    val (b, ptr) = decode_bool ptr
		    val (valenv, ptr) = decode_tyname_valenv ptr
                    val (is_abs,ptr) = decode_bool ptr
		    val tyname =
		      Datatypes.TYNAME(tyname_id, st, i, ref b, valenv,Datatypes.Option.ABSENT,ref is_abs)
		    val _ = NewHashTable.update(tynamehashtable, n, tyname)
d1759 1
a1759 1
		  (mylookup(12,tynamehashtable, n), ptr)
d1762 1
a1762 1
	      let
d1768 1
d1774 24
a1797 8
		    val (tyfun, ptr) = decode_tyfun ptr
		    val (st, ptr) = decode_string ptr
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b, ptr) = decode_bool ptr
		    val (valenv, ptr) = decode_tyname_valenv ptr
                    val (is_abs,ptr) = decode_bool ptr
		    val ty =
		      Datatypes.METATYNAME(ref tyfun, st, i, ref b, valenv,ref is_abs)
d1799 2
a1800 2
		    (r := ty;
		     (ty, ptr))
d1803 1
a1803 1
		  (!(NewMap.apply (!meta_tynames_decoded_in_tree) n), ptr)
d1806 35
a1840 1
          (*val _ = mydebug(std_out,"Decoding tyname " ^ Types.debug_print_name (#1 result) ^ "\n")*)
d1842 41
a1882 2
          result
	end
d1887 1
a1887 1
	  val (valenv, ptr) = decode_valenv ptr
d1889 1
a1889 1
	  (Datatypes.TYSTR(tyfun, valenv), ptr)
d1916 1
a1916 1
	  val (valenv, ptr) = decode_valenv ptr
d1918 1
a1918 1
	  (Datatypes.ENV(strenv, tyenv, valenv), ptr)
d1932 1
a1932 1
		val str = Datatypes.STR(strname,ref Datatypes.Option.ABSENT,env)
d2002 1
a2002 1
          val (valenv,ptr) = decode_valenv ptr
d2005 1
a2005 1
          ((valenv,n),ptr)
d2090 34
a2123 20
      fun decode_debug ptr = 
        let
          val result = 
            input_newmap(s, decode_string,
            (fn ptr => 
             let 
               val (triple,ptr) = 
                 input_triple
                  decode_type 
                  decode_bool
                  (fn ptr => input_list(s, input_pair decode_int decode_recipe, ptr)) ptr
             in
                  ((triple,Debugger_Env_type.EMPTY),ptr)
             end),
	    ptr,
            String.<,
            op =)
        in
          result
        end
a2124 6
      val (nameset, ptr) = decode_nameset 0
      val (funenv, ptr) = decode_funenv ptr
      val (sigenv, ptr) = decode_sigenv ptr
      val (env, ptr) = decode_env ptr
      val (debug_information,_) = decode_debug ptr

d2143 1
a2143 1
  fun reset_refs(BasisTypes.BASIS(_,nameset, funenv, sigenv, env), value) =
d2170 1
a2170 1
      and reset_tyname(Datatypes.TYNAME(ti, s, n, r as ref b, ref ve,_,_)) =
d2173 1
a2173 1
      | reset_tyname(Datatypes.METATYNAME(ref tf, s, n, ref b, ref ve,_)) =
d2291 1
a2291 1
  fun output_file
d2293 1
a2293 1
     type_basis, debug_info = Debugger_Types.INFO (debug_info,_), require_list, consistency} =
a2294 4
(*
      val require_list = map (fn (modname,(a,b),(c,d),(e,f)) => (modname,a,c,e)) require_list
      val _ = print_info (filename,tynames,strnames,tyfuns,require_list)
*)
d2396 6
d2419 1
d2588 1
d2629 1
a2629 1
	      write_newmap write_strid (write_pair (write_sub 0) write_index') s_map
d2633 1
a2633 1
	  fun do_ftr_range (field, env) =
d2649 1
a2649 1
      fun write_type_basis(BasisTypes.BASIS(_,nameset, funenv, sigenv, env), 
d2679 1
a2679 1
		| search ((module,(tyname_count,tyname_no),_,_)::rest) = 
d2769 1
a2769 1
	    ref [] : ((int * Datatypes.Type * Datatypes.instance) ref 
d2896 1
a2896 1
	  fun encode_valenv(done, Datatypes.VE(r, M)) =
a2898 1
              (* val _ = output(std_out,"Encoding valenv " ^ Integer.makestring n ^ "\n") *)
d2907 1
a2907 1
		   encode_newmap done encode_valid encode_typescheme M)
d2912 1
a2912 1
	  and encode_tyname(done, tyn as Datatypes.TYNAME(ti, s, n, ref b, ref ve,_,ref is_abs)) =
a2913 1
              (* val _ = output(std_out,"Encoding tyname " ^ Types.debug_print_name tyn ^ "\n") *)
d2931 5
a2935 3
                  (encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
                                        encode_string(encode_tyname_id(done, ti), s),
                                        ve))
d2954 10
a2963 4
		    encode_bool is_abs ::
                    (encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
                                          encode_string(encode_tyfun(done, tf), s),
                                          ve))
d2969 72
a3109 1

d3116 2
a3117 1
		    val _ = NewHashTable.update(rectypehashtable,arg, c)
d3122 1
a3122 1
		  done
d3136 2
a3137 1
		    val _ = NewHashTable.update(funtypehashtable,full_arg, c)
d3155 2
a3156 1
		    val _ = NewHashTable.update(constypehashtable,arg, c)
d3192 1
a3192 1
	      encode_tyfun_id(output_byte 3 :: done, tfi)
d3355 1
a3355 1
	  val write_debug =
d3357 3
a3359 3
	    (fn (debug_info,_) => 
             write_triple (fn ty => do_output(encode_type([], ty))) write_bool
	     (write_assoc write_opt_int write_recipe) debug_info)
d3361 1
d3366 3
a3368 1
	  Timer.xtime("write_debug",   !do_timings, fn () => write_debug debug_information);
d3394 4
a3397 2
      val (ty_start, _, ty_end) = (!fpos, write_type_basis (type_basis, 
                                                            debug_info, require_list), !fpos)
@


1.115
log
@Added call to Info.error' to report missing modules.
@
text
@d4 3
d1115 1
a1115 1
	    Info.default_options
@


1.114
log
@Changed NewMap.Undefined exception to BadInput
@
text
@d7 3
d466 1
d490 1
d533 1
d1109 5
a1113 2
      fun name_offsets name = NewMap.apply'(sub_modules', name) 
        handle NewMap.Undefined => raise BadInput ("Can't find entry for " ^ name)
@


1.113
log
@Added some debug info.

Also changed type of submodule info for output_file and decode_type_basis to include range information.
@
text
@d4 8
d1103 2
a1104 1
      fun name_offsets name = NewMap.apply'(sub_modules', name)
@


1.112
log
@Added sharing constraint to match one in result signature.
@
text
@d4 3
d523 8
d550 1
a550 1
  val CorruptFile = BadInput "Corrupt object file"
d848 1
a848 1
	  | _ => raise CorruptFile
d938 1
a938 1
	  | _ => raise CorruptFile
d982 1
a982 1
	  | _ => raise CorruptFile
d1064 10
a1073 1
    val TypeDecapError = BadInput "Corrupt object file (Failed during type decapsulation)"
d1075 2
d1079 2
d1101 1
a1101 1
	| _ => raise CorruptFile
d1121 1
a1121 1
	  | _ => raise CorruptFile
d1202 1
a1202 1
	  | _ => raise CorruptFile
d1237 1
a1237 1
	  | _ => raise CorruptFile
d1272 1
a1272 1
	  | _ => raise CorruptFile
d1287 1
a1287 1
	  | _ => raise CorruptFile
d1380 1
a1380 1
		  (NewHashTable.lookup(strnamehashtable, n), ptr)
d1388 1
a1388 1
	  | _ => raise CorruptFile
d1416 1
a1416 1
	  | _ => raise CorruptFile
d1444 1
a1444 1
	  | _ => raise CorruptFile
d1471 1
a1471 1
		  (NewHashTable.lookup(metatyvarhashtable, i), ptr)
d1491 1
a1491 1
		  (NewHashTable.lookup(metaoverloadedhashtable, i),
d1512 1
a1512 1
		  (NewHashTable.lookup(tyvarhashtable, i), ptr)
d1534 1
a1534 1
		  (NewHashTable.lookup(metarectypehashtable, i), ptr)
d1552 1
a1552 1
		  (NewHashTable.lookup(rectypehashtable, i), ptr)
d1570 1
a1570 1
		  (NewHashTable.lookup (decfuntypehashtable,i), ptr)
d1588 1
a1588 1
		  (NewHashTable.lookup(constypehashtable, i), ptr)
d1607 1
a1607 1
		  (NewHashTable.lookup(debruijnhashtable, i), ptr)
d1610 1
a1610 1
	  | _ => raise CorruptFile
d1630 1
a1630 1
	    (NewHashTable.lookup(valenvhashtable, n), ptr)
d1640 1
a1640 1
	  | _ => raise CorruptFile
d1671 1
a1671 1
		  (ref(NewHashTable.lookup(tynamevalenvhashtable, n)),
d1674 1
a1674 1
	  | _ => raise CorruptFile
d1680 1
a1680 1
	in
d1703 1
a1703 1
		  (NewHashTable.lookup(tynamehashtable, n), ptr)
d1732 4
a1735 1
	  | _ => raise CorruptFile
d1983 3
a1985 3
      Ord => raise TypeDecapError
    | String.Substring => raise TypeDecapError
    | NewMap.Undefined => raise TypeDecapError
d1987 1
a1987 1
    | NewHashTable.Lookup => raise TypeDecapError
d2127 10
d2141 4
d2521 3
a2523 3
		| search ((module,tyname_count,_,_)::rest) = 
		  if n < tyname_count then
		    search rest
d2559 3
a2561 3
		| search ((module,_,strname_count,_)::rest) = 
		  if n < strname_count then
		    search rest
d2583 3
a2585 3
		| search ((module,_,_,tyfun_count)::rest) = 
		  if n < tyfun_count then
		    search rest
d2741 1
d2757 1
@


1.111
log
@Added level field to Basis.
Added and commented out line to save Wordset name as ""
@
text
@d4 4
d494 1
a494 1
    Basis.BasisTypes.Datatypes.Type = Debugger_Env_type.Type
d496 2
@


1.110
log
@Added is_abs field to TYNAME and METATYNAME
@
text
@d4 3
d38 1
a38 1
Changes because Assemblies now has Basistypes instead of Datatypes
d495 2
a496 2
  structure Basistypes = Basis.BasisTypes
  structure Datatypes = Basistypes.Datatypes
d1782 1
a1782 1
	  (Basistypes.SIGMA(nameset, str), ptr)
d1790 1
a1790 1
	  (Basistypes.SIGENV sigenv, ptr)
d1799 1
a1799 1
	  (Basistypes.PHI(nameset, (str, sigma)), ptr)
d1807 1
a1807 1
	  (Basistypes.FUNENV funenv, ptr)
d1938 2
a1939 1
      val result = (Basistypes.BASIS(nameset, funenv, sigenv, env), 
d1956 1
a1956 1
  fun reset_refs(Basistypes.BASIS(nameset, funenv, sigenv, env), value) =
d2048 1
a2048 1
      and reset_sigma(Basistypes.SIGMA(ns, s)) =
d2052 1
a2052 1
      and reset_sigenv(Basistypes.SIGENV M) =
d2055 1
a2055 1
      and reset_phi(Basistypes.PHI(ns, (s, sg))) =
d2060 1
a2060 1
      and reset_funenv(Basistypes.FUNENV M) =
d2253 14
a2266 9
                    (write_int i;			(* position in closure *)
                     write_int (size name + 1);		(* length of name *)
                     write_extended_string name;	(* name of code item *)
                     write_int spills;			(* nr of non-gc spills *)
                     write_int (if leaf then 1 else 0);	(* leaf flag *)
                     write_int offset;			(* intercept offset *)
                     write_int (size words);		(* the code length *)
		     write_string words;		(* the code *)
                     write (names, sets, leafs, offsets))
d2444 1
a2444 1
      fun write_type_basis(Basistypes.BASIS(nameset, funenv, sigenv, env), 
d3029 1
a3029 1
	  fun write_sigma (Basistypes.SIGMA(ns, s)) =
d3032 1
a3032 1
	  fun write_sigenv (Basistypes.SIGENV M) =
d3035 1
a3035 1
	  fun write_phi (Basistypes.PHI(ns, (s, sg))) =
d3038 1
a3038 1
	  fun write_funenv (Basistypes.FUNENV M) =
@


1.109
log
@New pervasive time structure.
@
text
@d4 3
d1288 1
a1288 1
			     0, ref false, ref Datatypes.empty_valenv)
d1662 1
d1664 1
a1664 1
		      Datatypes.TYNAME(tyname_id, st, i, ref b, valenv,Datatypes.Option.ABSENT)
d1689 1
d1691 1
a1691 1
		      Datatypes.METATYNAME(ref tyfun, st, i, ref b, valenv)
d1979 1
a1979 1
      and reset_tyname(Datatypes.TYNAME(ti, s, n, r as ref b, ref ve,_)) =
d1982 1
a1982 1
      | reset_tyname(Datatypes.METATYNAME(ref tf, s, n, ref b, ref ve)) =
d2698 1
a2698 1
	  and encode_tyname(done, tyn as Datatypes.TYNAME(ti, s, n, ref b, ref ve,_)) =
d2716 4
a2719 3
		  encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
				       encode_string(encode_tyname_id(done, ti), s),
				       ve)
d2727 1
a2727 1
							ref ve)) =
d2738 4
a2741 3
		    encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
					 encode_string(encode_tyfun(done, tf), s),
					 ve)
@


1.108
log
@Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
@
text
@d4 3
d2074 1
a2074 1
          (MLWorks.Time.Real.decode time_string, ptr)
d3079 1
a3079 1
	write_assoc write_sz_string (write_sz_string o MLWorks.Time.Real.encode) l
@


1.107
log
@Replaced header_size with ObjectFile.HEADER_SIZE.
@
text
@d4 3
a482 1
  sharing type Debugger_Env_type.spill = int
d1293 2
a1294 1
						   Datatypes.NULLTYPE))
d1296 2
a1297 1
        Datatypes.UNBOUND_SCHEME(Types.int_type)
d1390 1
a1390 1
		(Datatypes.SCHEME(i, ty), ptr)
d1396 2
a1397 1
		(Datatypes.UNBOUND_SCHEME(ty), ptr)
d1425 1
a1425 1
		    val ty = Datatypes.METATYVAR(ref(i, ty), b1, b2)
d1465 2
a1466 1
		    val ty = Datatypes.TYVAR(ref (i), tyvar)
d1560 1
a1560 1
		    val ty = Datatypes.DEBRUIJN(i, b1, b2)
d1978 1
a1978 1
      and reset_type(Datatypes.METATYVAR(ref(n, t), b1, b2)) =
d1982 1
a1982 1
      | reset_type(Datatypes.TYVAR(ref (n), t)) = ()
d1993 1
a1993 1
      | reset_type(Datatypes.DEBRUIJN(n, b1, b2)) = ()
d1996 1
a1996 1
      and reset_typescheme(Datatypes.SCHEME(n, t)) =
d1998 1
a1998 1
      | reset_typescheme(Datatypes.UNBOUND_SCHEME t) =
d2084 1
a2084 1
     type_basis, debug_info = Debugger_Types.INFO debug_info, require_list, consistency} =
d2547 2
a2548 1
	    ref [] : ((int * Datatypes.Type) ref * bool * bool) list ref
d2738 1
a2738 1
			  Datatypes.METATYVAR(arg as (ref(n, t), b1, b2))) =
d2768 1
a2768 1
	    | encode_type(done, Datatypes.TYVAR(ref n, t)) =
d2857 1
a2857 1
	    | encode_type(done, Datatypes.DEBRUIJN(arg as (n, b1, b2))) =
d2859 1
a2859 1
		fun et'(h::t) = if h = arg then Lists.length t + 1
d2862 1
a2862 1
		    (debruijn_types_encoded := (arg::(!debruijn_types_encoded)); 0)
d2874 1
a2874 1
	  and encode_typescheme(done, Datatypes.SCHEME(n, t)) = 
d2876 1
a2876 1
	    | encode_typescheme(done, Datatypes.UNBOUND_SCHEME t) =
d2895 1
a2895 1
	      Datatypes.SCHEME(i, ty) =>
d2897 1
a2897 1
		   Datatypes.SCHEME(i', ty') =>
d2900 1
a2900 1
	    | Datatypes.UNBOUND_SCHEME ty =>
d2902 1
a2902 1
		   Datatypes.UNBOUND_SCHEME ty' =>
@


1.107.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.107  1993/08/26  17:39:54  daveb
Replaced header_size with ObjectFile.HEADER_SIZE.

@


1.106
log
@Modifications to decode_type_basis to take module name, and to remove the gaps
stuff in encoding now that equires can't be mixed with other topdecs
@
text
@d4 4
a3092 2
  val header_size = 44

d3133 1
a3133 1
	val header = checked_input(file_handle, header_size)
d3170 1
a3170 1
	  decode_header(checked_input(file_handle, header_size))
@


1.105
log
@Debugger Environments for local and closure variable inspection
in the debugger;
structure Option.
@
text
@d4 5
d1034 1
a1034 1
    fun decode_type_basis (s, sub_modules) =
a1039 5
      val (_, tyname_count,strname_count,tyfun_count) =
	case sub_modules of
	  elt::_ => elt
	| nil => Crash.impossible "no sub_modules"

d1045 5
d1140 1
a1140 1
	  | 1 => 
d1148 1
a1148 1
	  | 2 => 
d2436 1
d2442 1
d2453 13
d2468 1
d2471 1
a2471 1
	       | _ => n - tyname_count)
d2474 1
d2480 1
d2493 1
a2493 1
	       case module of
d2495 1
a2495 1
	       | _ => n - strname_count)
d2498 1
d2504 1
d2517 1
a2517 1
	       case module of
d2519 1
a2519 1
	       | _ => n - tyfun_count)
d2984 1
a2984 4
	     | n => ((*
		      output(std_out, "Using existing str number " ^ Integer.makestring n ^ " \n");
		      *)
		     write_opt_int n))
a3047 4
(*
	  Timer.xtime("write_type_assembly", !do_timings, fn () => write_type_assembly type_assembly);
	  Timer.xtime("write_str_assembly", !do_timings, fn () => write_str_assembly str_assembly);
*)
a3048 4
	  (*
	   output(std_out, "Number of repeated tyenvs found = " ^
	   Integer.makestring(!tyenv_repeats) ^ "\n");
	   *)
a3060 6
(*
	     output(std_out, "Number of strnames encoded = " ^
		    Integer.makestring(Lists.length(!strnames_encoded)) ^ "\n");
	     output(std_out, "Number of tynames encoded = " ^
		    Integer.makestring(Lists.length(!tynames_encoded)) ^ "\n");
*)
a3061 1
	    
@


1.104
log
@Removed exception environments and interfaces.
Funenvs no longer have interface components.
On the other hand, the constructor status of valids in lambda environments
is important now.
@
text
@d4 6
d430 1
d456 1
d464 1
d469 1
a469 1
    Basis.BasisTypes.Datatypes.Type
d471 1
a471 1

d490 1
d1283 2
a1284 1
      val dummy_constypescheme = Datatypes.UNBOUND_SCHEME(Types.int_type)
d1362 1
a1362 1
		(Datatypes.NULL_TYFUN tyfunid, ptr)
d1383 1
a1383 1
		(Datatypes.UNBOUND_SCHEME ty, ptr)
d1451 1
a1451 1
		    val ty = Datatypes.TYVAR(ref i, tyvar)
d1568 2
a1569 1
		input_newmap(s, decode_valid, decode_typescheme, ptr, Ident.valid_lt, Ident.valid_eq)
d1642 1
a1642 1
		      Datatypes.TYNAME(tyname_id, st, i, ref b, valenv,Datatypes.ABSENT)
d1727 1
a1727 1
		val str = Datatypes.STR(strname,ref Datatypes.ABSENT,env)
d1889 10
a1898 4
            (input_triple
             decode_type 
             decode_bool
             (fn ptr => input_list(s, input_pair decode_int decode_recipe, ptr))),
a1909 1

d1967 1
a1967 1
      | reset_type(Datatypes.TYVAR(ref n, t)) = ()
d2238 1
a2238 1
		  Lists.reducel (fn (res,(i,spill,s)) => res + size s) (0, w_list)
d2260 2
a2261 2
	   write_int (count_real_objects(0, element_list));
	   Lists.iterate output_module_element element_list))
d2295 2
a2296 1
	  fun write_pe (ParserEnv.E(ParserEnv.FE fix_map, ParserEnv.VE val_map, ParserEnv.SE struct_map)) =
d2837 3
a2839 3
	
	  and encode_typescheme(done, Datatypes.SCHEME(n, t)) =
	    encode_type(optimised_output_int n :: output_byte 1 :: done, t)
d2849 1
a2849 1
	    | encode_tyfun(done, Datatypes.NULL_TYFUN tfi) =
d2875 1
a2875 1
	    NewMap.eq (*Scheme.type*)scheme_eq (map1, map2)
d3018 3
a3020 2
	    (write_triple (fn ty => do_output(encode_type([], ty))) write_bool
	     (write_assoc write_opt_int write_recipe))
@


1.103
log
@Cleaned up after assembly changes
@
text
@d4 3
a457 1
  sharing type EnvironTypes.Interface = Basis.BasisTypes.Datatypes.Interface.Int
a480 1
  structure Interface = Datatypes.Interface
a768 9
      val exn_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	(int, (Ident.ValId, EnvironTypes.comp)NewMap.T) NewMap.T ref
      val exn_size = ref 0
      val int_val_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	(int, Ident.ValId list) NewMap.T ref
      val int_val_size = ref 0
      val int_exn_map = ref(NewMap.empty' ((op<) : int * int -> bool)) :
	(int, Ident.ValId list) NewMap.T ref
      val int_exn_size = ref 0
d793 1
a793 1
      fun decode_var ptr =
d795 1
d797 5
d803 1
a803 8
	  (Ident.VAR sy, ptr)
	end

      fun decode_excon ptr =
	let
	  val (sy, ptr) = decode_symbol ptr
	in
	  (Ident.EXCON sy, ptr)
d831 2
a832 1
		    input_newmap(s, decode_var, read_field, ptr, Ident.valid_lt,Ident.valid_eq)
a840 19

	  fun decode_exn_env ptr =
	    let
	      val (exnnum, ptr) = input_opt_int(s, ptr)
	    in
	      case exnnum of
		0 =>
		  let
		    val (exn_env, ptr) =
		      input_newmap(s, decode_excon, read_field, ptr, Ident.valid_lt,Ident.valid_eq)
		    val new_num = !exn_size + 1
		  in
		    exn_size := new_num;
		    exn_map := NewMap.define(!exn_map, new_num, exn_env);
		    (exn_env, ptr)
		  end
	      | _ =>
		  (NewMap.apply'(!exn_map, exnnum), ptr)
	    end
a842 1
	  val (e_env, ptr) = decode_exn_env ptr
d846 1
a846 37
	  (EnvironTypes.ENV(v_env, e_env, s_env), ptr)
	end

      fun read_interface ptr =
	let
	  val (valnum, ptr) = input_opt_int(s, ptr)
	  val (v_int, ptr) = case valnum of
	    0 =>
	      let
		val (v_int, ptr) = input_list(s, decode_var, ptr)
		val new_num = !int_val_size + 1
	      in
		int_val_size := new_num;
		int_val_map := NewMap.define(!int_val_map, new_num, v_int);
		(v_int, ptr)
	      end
	  | _ =>
	      (NewMap.apply'(!int_val_map, valnum), ptr)

	  val (exnnum, ptr) = input_opt_int(s, ptr)
	  val (e_int, ptr) = case exnnum of
	    0 =>
	      let
		val (e_int, ptr) = input_list(s, decode_excon, ptr)
		val new_num = !int_exn_size + 1
	      in
		(int_exn_size := new_num;
		 int_exn_map := NewMap.define(!int_exn_map, new_num, e_int);
		 (e_int, ptr))
	      end
	  | _ =>
	      (NewMap.apply'(!int_exn_map, exnnum), ptr)

	  val (s_int, ptr) =
	    input_newmap(s, decode_strid, read_interface, ptr, Ident.strid_lt, Ident.strid_eq)
	in
	  (Interface.INT(Interface.INTENV s_int, v_int, e_int,ref Interface.ABSENT), ptr)
a851 1
	  val (interface, ptr) = read_interface ptr
d854 1
a854 1
	  ((EnvironTypes.FIELD{index=offset, size=total_size}, interface, env),
a1699 1
	  val (exnenv, ptr) = decode_valenv ptr
d1701 1
a1701 1
	  (Datatypes.ENV(strenv, tyenv, valenv, exnenv), ptr)
d1909 1
a1909 1
    | BadInput m => raise BadInput(m ^ " (Failed during type decapsulation)")
d1999 1
a1999 1
      and reset_env(Datatypes.ENV(se, te, ve, ece)) =
d2002 1
a2002 2
	 reset_valenv ve;
	 reset_valenv ece)
a2172 7
      fun write_valid' (Ident.VAR sy) =
	  write_symbol sy
	| write_valid' (Ident.CON sy) =
	  write_symbol sy
	| write_valid' (Ident.EXCON sy) =
	  write_symbol sy

d2325 1
a2325 1
      fun write_lambda_env(EnvironTypes.TOP_ENV(env as EnvironTypes.ENV(v, e, s), EnvironTypes.FUN_ENV fun_env)) =
a2341 3
	  val lambdaexnhashtable = 
            NewHashTable.new(128,op =,hash)
	  val exnsize = ref 0
a2342 18
          fun hash [] = 0
            | hash (valid :: _) =
              let
                val sy = case valid of
                  Ident.VAR sy => sy
                | Ident.CON sy => sy
                | Ident.EXCON sy => sy
                val str = Symbol.symbol_name sy
              in
                add_together_ords(str,size str)
              end

	  val intvalhashtable = 
            NewHashTable.new(128,op =,hash)
	  val intvalsize = ref 0
	  val intexnhashtable = 
            NewHashTable.new(128,op =,hash)
	  val intexnsize = ref 0
a2345 1
	  val e_len = NewMap.size e
d2347 1
a2347 1
	  val env_len = v_len + e_len + s_len
d2349 1
a2349 1
	  fun write_sub extra (EnvironTypes.ENV(v_map, e_map, s_map)) =
a2351 1
	      val e_list = NewMap.to_list_ordered e_map
a2353 1
	      val e_len = Lists.length e_list
d2355 1
a2355 1
	      val env_len = v_len + e_len + s_len + extra
d2366 1
a2366 17
		    NewHashTable.update(lambdavalhashtable, v_list,
					      newsize)
		  end
		else
		  ()

	      val enum =
		NewHashTable.lookup_default(lambdaexnhashtable, 0,
						  e_list)
	      val _ =
		if enum = 0 then
		  let
		    val newsize = !exnsize + 1
		  in
		    exnsize := newsize;
		    NewHashTable.update(lambdaexnhashtable, e_list,
					      newsize)
d2373 1
a2373 4
	      write_opt_int vnum;
	      if vnum = 0 then write_assoc write_valid' write_index' v_list else ();
	      write_opt_int enum;
	      if enum = 0 then write_assoc write_valid' write_index' e_list else ();
a2376 35
	  fun write_interface (Interface.INT(Interface.INTENV s_map, v_list, e_list,_)) =
	    let
	      val vnum = NewHashTable.lookup_default(intvalhashtable, 0,
						     v_list)
	      val _ =
		if vnum = 0 then
		  let
		    val newsize = !intvalsize + 1
		  in
		    intvalsize := newsize;
		    NewHashTable.update(intvalhashtable, v_list, newsize)
		  end
		else
		  ()

	      val enum = NewHashTable.lookup_default(intexnhashtable, 0,
						     e_list)
	      val _ =
		if enum = 0 then
		  let
		    val newsize = !intexnsize + 1
		  in
		    intexnsize := newsize;
		    NewHashTable.update(intexnhashtable, e_list, newsize)
		  end
		else
		  ()

	    in
	      write_opt_int vnum;
	      if vnum = 0 then write_list write_valid' v_list else ();
	      write_opt_int enum;
	      if enum = 0 then write_list write_valid' e_list else ();
	      write_newmap write_strid write_interface s_map
	    end
d2378 2
a2379 2
	  fun do_ftr_range (field, interface, env) =
	    (write_index field; write_interface interface; write_sub 0 env)
d2389 2
a2390 4
	    (output(std_out,"lambdavalhashtable in _encapsulate: "^
		    NewHashTable.string_hash_table_stats(lambdavalhashtable) ^ "\n");
	     output(std_out,"lambdaexnhashtable in _encapsulate: "^
		    NewHashTable.string_hash_table_stats(lambdaexnhashtable) ^ "\n"))
d2872 3
a2874 4
	  and env_eq(Datatypes.ENV(Datatypes.SE se, Datatypes.TE te, ve, ee),
		     Datatypes.ENV(Datatypes.SE se', Datatypes.TE te', ve', ee')) =
	    NewMap.eq str_eq (se, se') andalso tyenv_eq (te, te') andalso ve_eq (ve, ve') andalso
	    ve_eq (ee, ee')
d2951 1
a2951 1
	  and write_env (Datatypes.ENV(se, te, ve, ece)) =
d2953 1
a2953 1
	     do_output(encode_valenv(encode_valenv([], ve), ece)))
d3087 1
a3087 1
	raise BadInput "Corrupt object file"
d3094 1
a3094 1
      if size s <> len then raise BadInput "Corrupt object file"
d3100 1
a3100 1
      val Error = BadInput("Corrupt object file: " ^ filename)
d3134 1
a3134 1
      val Error = BadInput ("Corrupt object file: " ^ filename)
d3155 4
a3158 4
        Ord => (close_in file_handle; raise Error)
      | Lists.Nth => (close_in file_handle; raise Error)
      | String.Substring => (close_in file_handle; raise Error)
      | NewMap.Undefined => (close_in file_handle; raise Error)
d3160 1
a3160 1
      | NewHashTable.Lookup => (close_in file_handle; raise Error)
@


1.102
log
@Stopped encapsulating and decapsulating assemblies
@
text
@d4 3
d404 1
a411 1
require "../typechecker/assemblies";
d428 1
a444 1
  structure Assemblies : ASSEMBLIES
a449 1
  sharing Basis.BasisTypes = Assemblies.Basistypes
d464 2
a465 2
  structure BasisTypes = Basis.BasisTypes
  structure Datatypes = BasisTypes.Datatypes
d478 1
a478 2
  structure Assemblies = Assemblies
  structure IntMap = Assemblies.IntMap
d1810 1
a1810 1
	  (BasisTypes.SIGMA(nameset, str), ptr)
d1818 1
a1818 1
	  (BasisTypes.SIGENV sigenv, ptr)
d1827 1
a1827 1
	  (BasisTypes.PHI(nameset, (str, sigma)), ptr)
d1835 1
a1835 1
	  (BasisTypes.FUNENV funenv, ptr)
a1864 28
(*
      fun decode_ty_ass_val ptr = 
        decode_rev_list decode_ty_ass_val_entry ptr

      fun decode_type_assembly ptr =
        let 
          val (amap,ptr) = 
            input_intmap (s, decode_ty_ass_val, ptr)
        in
          (Assemblies.map_to_TypeAssembly amap, ptr)
        end
*)

      fun decode_type_assembly ptr =
        let 
          val (list, ptr) = input_list(s, decode_ty_ass_val_entry, ptr)
        in
          (Assemblies.list_to_TypeAssembly list, ptr)
        end

      fun decode_type_offspring ptr =
        let
          val (amap, ptr) = 
            input_newmap' (s, decode_tycon, decode_tyfun_int, ptr, Ident.tycon_lt)
        in
          (Assemblies.map_to_TypeOffspring amap, ptr)
        end

a1872 20
      fun decode_str_offspring ptr =
        let
          val (amap, ptr) = 
            input_newmap' (s, decode_strid, decode_strname_int, ptr, Ident.strid_lt)
        in
          (Assemblies.map_to_StrOffspring amap, ptr)
        end

      fun decode_str_ass_entry ptr = 
        let
          val (strname,ptr) = decode_strname ptr
          val (str_offs,ptr) = decode_str_offspring ptr
          val (ty_offs,ptr) = decode_type_offspring ptr
       in
         ((strname,(str_offs,ty_offs)),ptr)
       end

      fun decode_str_assembly ptr = 
        decode_rev_list decode_str_ass_entry ptr

a1957 4
(*
      val (type_assembly, ptr) = decode_type_assembly ptr
      val (str_assembly, ptr) = decode_str_assembly ptr
*)
d1961 1
a1961 7
      val result = (BasisTypes.BASIS(nameset, funenv, sigenv, env), 
(*
                    type_assembly, 
                    Assemblies.list_to_StrAssembly str_assembly, 
*)
		    Assemblies.empty_tyassembly,
		    Assemblies.empty_strassembly(),
d1978 1
a1978 1
  fun reset_refs(BasisTypes.BASIS(nameset, funenv, sigenv, env), value) =
d2071 1
a2071 1
      and reset_sigma(BasisTypes.SIGMA(ns, s)) =
d2075 1
a2075 1
      and reset_sigenv(BasisTypes.SIGENV M) =
d2078 1
a2078 1
      and reset_phi(BasisTypes.PHI(ns, (s, sg))) =
d2083 1
a2083 1
      and reset_funenv(BasisTypes.FUNENV M) =
d2119 1
a2119 1
     type_basis, type_assembly, str_assembly, debug_info = Debugger_Types.INFO debug_info, require_list, consistency} =
d2548 2
a2549 2
      fun write_type_basis(BasisTypes.BASIS(nameset, funenv, sigenv, env), 
			   type_assembly, str_assembly, debug_information, sub_modules) =
d3114 1
a3114 1
	  fun write_sigma (BasisTypes.SIGMA(ns, s)) =
d3117 1
a3117 1
	  fun write_sigenv (BasisTypes.SIGENV M) =
d3120 1
a3120 1
	  fun write_phi (BasisTypes.PHI(ns, (s, sg))) =
d3123 1
a3123 1
	  fun write_funenv (BasisTypes.FUNENV M) =
a3130 42
(*
	  fun write_tyass_val ty_ass_val = 
	    write_list write_ty_ass_val_entry ty_ass_val

	  fun write_type_assembly ty_ass = 
	    write_intmap write_tyass_val (Assemblies.TypeAssembly_to_map ty_ass)
*)

	  fun write_type_assembly ty_ass =
	    let
	      val the_map = Assemblies.TypeAssembly_to_map ty_ass
	      val length =
		IntMap.fold
		(fn (x, _, list) => x + Lists.length list)
		(0, the_map)
	    in
	      write_opt_int length;
	      IntMap.iterate
	      (fn (_, list) => Lists.iterate write_ty_ass_val_entry list)
	      the_map
	    end

	  fun write_strname_int (strname,n) = 
	    (write_strname strname; write_opt_int n)

	  fun write_str_offs str_offspring_map =
	    write_newmap write_strid write_strname_int str_offspring_map
  
	  fun write_tyfun_int (tyfun,n) =
	    (do_output (encode_tyfun ([],tyfun)); write_opt_int n)

	  fun write_ty_offs type_offspring_map =
	    write_newmap write_tycon write_tyfun_int type_offspring_map 

	  fun write_str_ass_entry (strname,(str_offs,ty_offs)) = 
	    (write_strname strname; 
	     write_str_offs (Assemblies.StrOffspring_to_map str_offs); 
	     write_ty_offs (Assemblies.TypeOffspring_to_map ty_offs))

	  fun write_str_assembly str_ass =
	    write_list write_str_ass_entry (Assemblies.StrAssembly_to_list str_ass)

d3203 1
a3203 1
      val (ty_start, _, ty_end) = (!fpos, write_type_basis (type_basis, type_assembly, str_assembly, 
@


1.101
log
@Changes because Assemblies now has Basistypes instead of Datatypes
@
text
@d4 3
d2005 1
d2008 1
d2013 1
d2016 3
d3261 1
d3264 1
@


1.100
log
@Changed the layout of code vectors to make life _much_ easier for
the runtime system loader.
@
text
@d4 4
d442 1
a442 1
    Enc_Sub.DataTypes = Assemblies.Datatypes =
d444 1
@


1.99
log
@Modified to use rts write_byte. Bug fixed assembly encapsulation
@
text
@d4 3
d2324 13
d2341 3
a2343 10
		write_int (Lists.length w_list);
		Lists.iterate
		(fn str => (write_int (size str + 1); write_extended_string str))
		str_list;
		write_int wordset_size;
		Lists.iterate
		(fn (i, spills, w) => (write_int i; write_int (size w); write_int spills; write_string w))
		w_list;
		Lists.iterate (fn leaf => write_int(if leaf then 1 else 0)) leaf_list;
		Lists.iterate write_int offsets_list
@


1.98
log
@Improved encapsulation of integers in assemblies
@
text
@d4 3
d1853 1
d1864 1
d1866 7
d2169 1
a2169 1
	(write(file_handle, chr i); fpos := !fpos + 1)
d2178 1
d2181 1
a2181 1
(*
a2182 1
*)
d3165 1
d3171 15
@


1.97
log
@Corrected #define symbols to upper case.
@
text
@d4 3
d638 1
a638 1
  fun input_intmap(s, f, g, ptr) =
d645 1
a645 1
	    val (fval, ptr) = f ptr
d1829 1
a1829 1
          val (n,ptr) = input_int (s,ptr)
d1837 1
a1837 1
          val (n,ptr) = input_int (s,ptr)
a1841 3
      fun decode_ty_ass_dom ptr = 
        input_int (s,ptr)

d1856 1
a1856 1
            input_intmap (s, decode_ty_ass_dom, decode_ty_ass_val, ptr)
d1872 1
a1872 1
          val (n,ptr) = input_int (s,ptr)
d2256 1
a2256 1
	 IntMap.iterate_ordered (write_pair write_int g) m)
a2257 8
      fun write_strnameid_map f g m =
	(write_opt_int(Strname_id.Map.size m);
	 Strname_id.Map.iterate_ordered (write_pair f g) m)

      fun write_tyfunid_map f g m =
	(write_opt_int(Tyfun_id.Map.size m);
	 Tyfun_id.Map.iterate_ordered (write_pair f g) m)

d3151 1
a3151 1
	     write_int n')
d3160 1
a3160 1
	    (write_strname strname; write_int n)
d3166 1
a3166 1
	    (do_output (encode_tyfun ([],tyfun)); write_int n)
@


1.96
log
@Nameset signature changes
@
text
@d4 3
d2308 1
a2308 1
	      (write_int ObjectFile.opcode_real; write_int i;
d2311 1
a2311 1
	      (write_int ObjectFile.opcode_string; write_int i;
d2320 1
a2320 1
		write_int ObjectFile.opcode_codeset;
d2333 1
a2333 1
	      (write_int ObjectFile.opcode_external; write_int i;
d3251 1
a3251 1
	(write_int ObjectFile.GOOD_MAGIC; write_int ObjectFile.object_file_version)
d3289 1
a3289 1
	if version = ObjectFile.object_file_version then
@


1.95
log
@Encapsulated extra WORDSET information
@
text
@d4 3
a424 1
  sharing Basis.BasisTypes = Nameset.BasisTypes
d427 1
a427 1
    Env.Datatypes = Strnames.Datatypes
d432 1
@


1.94
log
@Signature revisions
@
text
@d4 3
d616 2
d619 1
d621 1
d623 2
d626 1
d639 2
d642 1
d644 1
d646 1
d648 2
d685 1
a685 1
    | count_real_objects(count, MachTypes.WORDSET(MachTypes.WORD_SET(_, w_list)) :: rest) =
d2309 1
a2309 1
	    | output_module_element(MachTypes.WORDSET(MachTypes.WORD_SET(str_list, w_list))) =
a2312 3
(*
	          (* CT added the four for each non_gc_spill count *)
*)
d2322 3
a2324 1
		w_list
d2583 2
a2584 1
	  val tynamehashtable = NewHashTable.new(4000,Enc_Sub.tyname_same,Enc_Sub.tyname_hash)
d2814 1
a2814 1
	  and encode_tyname(done, Datatypes.TYNAME(ti, s, n, ref b, ref ve,_)) =
d2816 2
a2817 1
	      val _ = tyname_count := !tyname_count + 1
d2823 1
d2827 9
a2835 3
		encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
				     encode_string(encode_tyname_id(done, ti), s),
				     ve)
d2844 1
a2844 3
		val pos =
		  NewHashTable.lookup_default
		  (tynamehashtable, 0, tyn)
d2851 1
a2851 1
		    val _ = NewHashTable.update(tynamehashtable,tyn, c)
d3219 3
a3221 3
	  if !print_hash_table_stats then
	    (output(std_out,"Tynamehashtable in _encapsulate: " ^
		    NewHashTable.string_hash_table_stats(tynamehashtable) ^ "\n");
d3230 9
a3238 1
	  else ()
@


1.93
log
@Options & Info changes
@
text
@d4 3
d421 10
a430 4
    Enc_Sub.DataTypes = Debugger_Types.Datatypes = Assemblies.Datatypes =
    EnvironTypes.LambdaTypes.Datatypes = Env.Datatypes = Strnames.Datatypes
  sharing ParserEnv.Ident = Types.Datatypes.Ident
  sharing Types.Datatypes.NewMap = ParserEnv.Map
d453 2
@


1.92
log
@Added crash when trying to encapsulate an MLVALUE object
I guess this should really be an ordinary error
@
text
@d4 4
a415 1
  sharing Basis.BasisTypes.Info = Debugger_Types.Info
d1035 1
a1035 1
      val strmap = ref(IntMap.empty : Datatypes.Str IntMap.T)
@


1.91
log
@Modified to spot common strs. Big size improvement for large .mo files
@
text
@d4 3
d2276 2
@


1.90
log
@Changes for code vector reform.
@
text
@d4 3
d375 1
d398 1
d413 1
a413 1
    EnvironTypes.LambdaTypes.Datatypes = Env.Datatypes
d618 32
d1029 2
d1714 1
a1714 2
	  val (strname, ptr) = decode_strname ptr
	  val (env, ptr) = decode_env ptr
d1716 13
a1728 1
	  (Datatypes.STR(strname,ref Datatypes.ABSENT,env), ptr)
d1972 4
d2041 8
a2048 1
          reset_str (Env.str_copy (str,smap,tmap))
d2218 8
d2537 2
a2538 2
      fun write_type_basis (BasisTypes.BASIS(nameset, funenv, sigenv, env), 
                            type_assembly, str_assembly, debug_information, sub_modules) =
d2604 1
a2604 1
	      
d2660 1
a2660 1
	    in	
d2707 3
a2709 1
	  
d2711 1
a2711 1
	      (write_byte 1; write_strname_id s)
d2715 1
a2715 1
		    if h = s then Lists.length t + 1 else es' t
d2732 1
a2732 1
	    
a2744 1

d2761 1
a2761 1
	  
d2777 1
a2777 1
	  
d2795 1
a2795 1
	  
a2802 1

d2818 1
a2818 1
	    
d2823 5
a2827 73
			  else et' t
	  | et' [] =
	    (metatyvar_types_encoded := (arg::(!metatyvar_types_encoded)); 0)
	  val pos = et'(!metatyvar_types_encoded)
	  val done = optimised_output_int pos :: output_byte 1 :: done
	in
	  if pos = 0 then
	    encode_bool b2 :: encode_bool b1 ::
	    encode_type(optimised_output_int n :: done, t)
	  else
	    done
	end
      | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t,_)) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (meta_overloaded_types_encoded :=
	     (arg::(!meta_overloaded_types_encoded)); 0)
	  val pos = et'(!meta_overloaded_types_encoded)
	  val done = optimised_output_int pos :: output_byte 2 :: done
	in
	  if pos = 0 then
	    encode_type(done, t)
	  else
	    done
	end
      | encode_type(done, Datatypes.TYVAR(ref n, t)) =
	let
	  fun et'((n', t')::tl) =
	    if (*h = arg*) n = n' andalso t =  t' then
	      Lists.length tl + 1
	    else et' tl
	  | et' [] =
	    (tyvar_types_encoded := ((n, t)::(!tyvar_types_encoded)); 0)
	  val pos = et'(!tyvar_types_encoded)
	  val done = optimised_output_int pos :: output_byte 3 :: done
	in
	  if pos = 0 then
	    encode_tyvar(optimised_output_int n :: done, t)
	  else
	    done
	end	  
      | encode_type(done,
		    Datatypes.METARECTYPE(arg as ref(n, b1, t, b2, b3))) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (metarectype_types_encoded :=
	     (arg::(!metarectype_types_encoded)); 0)
	  val pos = et'(!metarectype_types_encoded)
	  val done = optimised_output_int pos :: output_byte 4 :: done
	in
	  if pos = 0 then
	    encode_bool b3 :: encode_bool b2 ::
	    encode_type(encode_bool b1 :: optimised_output_int n :: done, t)
	  else
	    done
	end
      | encode_type(done, arg as Datatypes.RECTYPE M) =
	let
	  val pos =
	    NewHashTable.lookup_default
	    (rectypehashtable, 0, arg)

	  val done = optimised_output_int pos :: output_byte 5 :: done
	in
	  if pos = 0 then
	    let
	      val c = !rectype_count + 1
	      val _ = rectype_count := c
	      val _ = NewHashTable.update(rectypehashtable,arg, c)
d2829 5
a2833 1
	      encode_map done encode_lab encode_type M
d2835 53
a2887 8
	  else
	    done
	end
      | encode_type(done, full_arg as Datatypes.FUNTYPE(arg as (t1, t2))) =
	let
	  val pos =
	    NewHashTable.lookup_default
	    (funtypehashtable, 0, full_arg)
d2889 18
a2906 18
	  val done = optimised_output_int pos :: output_byte 6 :: done
	in
	  if pos = 0 then
	    let
	      val c = !funtype_count + 1
	      val _ = funtype_count := c
	      val _ = NewHashTable.update(funtypehashtable,full_arg, c)
	    in
	      encode_type(encode_type(done, t1), t2)
	    end
	  else
	    done
	end
      | encode_type(done, arg as Datatypes.CONSTYPE(l, t)) =
	let
	  val pos =
	    NewHashTable.lookup_default
	    (constypehashtable, 0, arg)
d2908 47
a2954 29
	  val done = optimised_output_int pos :: output_byte 7 :: done
	in
	  if pos = 0 then
	    let
	      val c = !constype_count + 1
	      val _ = constype_count := c
	      val _ = NewHashTable.update(constypehashtable,arg, c)
	    in
	      encode_tyname(encode_list done encode_type l, t)
	    end
	  else
	    done
	end
      | encode_type(done, Datatypes.DEBRUIJN(arg as (n, b1, b2))) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (debruijn_types_encoded := (arg::(!debruijn_types_encoded)); 0)
	  val pos = et'(!debruijn_types_encoded)
	  val done = optimised_output_int pos :: output_byte 8 :: done
	in
	  if pos = 0 then
	    encode_bool b2 :: encode_bool b1 :: optimised_output_int n :: done
	  else
	    done
	end	  
      | encode_type(done, Datatypes.NULLTYPE) = output_byte 9 ::
	done
d2956 6
a2961 6
      and encode_typescheme(done, Datatypes.SCHEME(n, t)) =
	encode_type(optimised_output_int n :: output_byte 1 :: done, t)
      | encode_typescheme(done, Datatypes.UNBOUND_SCHEME t) =
	encode_type(output_byte 2 :: done, t)
      | encode_typescheme(done, Datatypes.OVERLOADED_SCHEME ov) =
	encode_over_loaded ov :: output_byte 3 :: done
d2963 6
a2968 6
      and encode_tyfun(done, tyfun as Datatypes.TYFUN(t, n)) =
	optimised_output_int n :: encode_type(output_byte 1 :: done, t)
      | encode_tyfun(done, Datatypes.ETA_TYFUN tn) =
	encode_tyname(output_byte 2 :: done, tn)
      | encode_tyfun(done, Datatypes.NULL_TYFUN tfi) =
	encode_tyfun_id(output_byte 3 :: done, tfi)
d2970 1
a2970 2
      fun write_tystr (Datatypes.TYSTR(tf, ve)) =
	do_output(encode_valenv(encode_tyfun([], tf), ve))
d2972 2
a2973 16
      fun scheme_eq(scheme1, scheme2) =
	case scheme1 of
	  Datatypes.SCHEME(i, ty) =>
	    (case scheme2 of
	       Datatypes.SCHEME(i', ty') =>
		 i = i' andalso Types.type_eq(ty, ty', true, false)
	     | _ => false)
	| Datatypes.UNBOUND_SCHEME ty =>
	    (case scheme2 of
	       Datatypes.UNBOUND_SCHEME ty' =>
		 Types.type_eq(ty, ty', true, false)
	     | _ => false)
	| Datatypes.OVERLOADED_SCHEME ov =>
	    (case scheme2 of
	       Datatypes.OVERLOADED_SCHEME ov' => ov = ov'
	     | _ => false)
d2975 16
a2990 2
      fun ve_eq(Datatypes.VE(_, map1), Datatypes.VE(_, map2)) =
	NewMap.eq (*Scheme.type*)scheme_eq (map1, map2)
d2992 2
a2993 2
      fun pair_eq(eq1, eq2) =
	fn ((a, b), (a', b')) => eq1(a, a') andalso eq2(b, b')
d2995 2
a2996 2
      fun tystr_eq(Datatypes.TYSTR a, Datatypes.TYSTR b) =
	pair_eq(Types.tyfun_eq, ve_eq) (a, b)
d2998 2
a2999 1
      val tyenv_eq = NewMap.eq tystr_eq
d3001 1
a3001 1
      datatype 'a option = YES of 'a | NO
d3003 19
a3021 3
      fun eq_assoc eq_fun =
	let
	  fun eq_elt elt =
d3023 11
a3033 6
	      fun try [] = NO
		| try ((dom, ran) :: xs) =
		  if eq_fun(elt, dom) then
		    YES ran
		  else
		    try xs
d3035 1
a3035 1
	      try
a3036 3
	in
	  eq_elt
	end
d3038 28
a3065 28
      fun write_tyenv (Datatypes.TE m) =
	let
	  val tycon =
	    case NewMap.domain_ordered m of
	      tycon :: _ => tycon
	    | _ => Ident.TYCON(Symbol.find_symbol"")
	  val table = !tyenv_table
	  val envs = !tyenvs + 1
	  val i = case NewMap.tryApply'(table, tycon) of
	    NewMap.YES list =>
	      (case eq_assoc tyenv_eq m list of
		 YES i => ((*tyenv_repeats := !tyenv_repeats + 1;*) i)
	       | NO =>
		   (tyenvs := envs;
		    tyenv_table := NewMap.define(table, tycon,
						 (m, envs) :: list);
		    0))
	  | _ =>
	      (tyenvs := envs;
	       tyenv_table := NewMap.define(table, tycon, [(m, envs)]);
	       0)
	in
	  write_opt_int i;
	  if i = 0 then
	    write_newmap write_tycon write_tystr m
	  else
	    ()
	end
d3067 17
a3083 4
      fun write_str (Datatypes.STR(sn,_,e)) =
	(write_strname sn; write_env e)
        | write_str (Datatypes.COPYSTR ((smap,tmap),str)) =
          write_str (Env.str_copy (str,smap,tmap))
d3085 2
a3086 2
      and write_strenv (Datatypes.SE m) =
	write_newmap write_strid write_str m
d3088 3
a3090 3
      and write_env (Datatypes.ENV(se, te, ve, ece)) =
	(write_strenv se; write_tyenv te;
	 do_output(encode_valenv(encode_valenv([], ve), ece)))
d3092 3
a3094 3
      fun write_nameset ns =
	(do_output(encode_list [] encode_tyname (Nameset.tynames_of_nameset ns));
	 write_list write_strname (Nameset.strnames_of_nameset ns))
d3096 2
a3097 2
      fun write_sigma (BasisTypes.SIGMA(ns, s)) =
	(write_nameset ns; write_str s)
d3099 2
a3100 2
      fun write_sigenv (BasisTypes.SIGENV M) =
	write_newmap write_sigid write_sigma M
d3102 2
a3103 2
      fun write_phi (BasisTypes.PHI(ns, (s, sg))) =
	(write_nameset ns; write_str s; write_sigma sg)
d3105 2
a3106 2
      fun write_funenv (BasisTypes.FUNENV M) =
	write_newmap write_funid write_phi M
d3108 4
a3111 4
      fun write_ty_ass_val_entry (tyfun,(valenv,n')) = 
        (do_output (encode_tyfun ([],tyfun)); 
         do_output (encode_valenv ([],valenv)); 
         write_int n')
d3113 2
a3114 2
      fun write_tyass_val ty_ass_val = 
        write_list write_ty_ass_val_entry ty_ass_val
d3116 2
a3117 2
      fun write_type_assembly ty_ass = 
        write_intmap write_tyass_val (Assemblies.TypeAssembly_to_map ty_ass)
d3119 2
a3120 2
      fun write_strname_int (strname,n) = 
        (write_strname strname; write_int n)
d3122 2
a3123 2
      fun write_str_offs str_offspring_map =
        write_newmap write_strid write_strname_int str_offspring_map
d3125 2
a3126 2
      fun write_tyfun_int (tyfun,n) = 
         (do_output (encode_tyfun ([],tyfun)); write_int n)
d3128 2
a3129 2
      fun write_ty_offs type_offspring_map =
        write_newmap write_tycon write_tyfun_int type_offspring_map 
d3131 4
a3134 4
      fun write_str_ass_entry (strname,(str_offs,ty_offs)) = 
        (write_strname strname; 
        write_str_offs (Assemblies.StrOffspring_to_map str_offs); 
        write_ty_offs (Assemblies.TypeOffspring_to_map ty_offs))
d3136 2
a3137 2
      fun write_str_assembly str_ass = 
        write_list write_str_ass_entry (Assemblies.StrAssembly_to_list str_ass)
d3139 21
a3159 21
      fun write_recipe value = 
        case value of
	  Debugger_Types.Nop =>
	    write_byte 0
	| Debugger_Types.Select(x,y) =>
	    (write_byte 1; write_opt_int x; write_recipe y)
	| Debugger_Types.MakeRecord args =>
	    (write_byte 2; write_assoc write_opt_string write_recipe args)
	| Debugger_Types.Funarg arg =>
	    (write_byte 3; write_recipe arg)
	| Debugger_Types.Funres arg =>
	    (write_byte 4; write_recipe arg)
	| Debugger_Types.MakeFunType(x,y) =>
	    (write_byte 5; write_recipe x; write_recipe y)
	| Debugger_Types.DeCons(x,y) =>
	    (write_byte 6; write_opt_int x; write_recipe y)
        | Debugger_Types.MakeConsType(x, y) =>
            (write_byte 7; write_list write_recipe x;
	     do_output(encode_tyname([], y)))
        | Debugger_Types.Error =>
	    write_byte 8
d3161 29
a3189 29
      val write_debug =
        write_newmap write_opt_string
	(write_triple (fn ty => do_output(encode_type([], ty))) write_bool
	(write_assoc write_opt_int write_recipe))
    in
      Timer.xtime("write_nameset", !do_timings, fn () => write_nameset nameset);
      Timer.xtime("write_funenv",  !do_timings, fn () => write_funenv funenv);
      Timer.xtime("write_sigenv",  !do_timings, fn () => write_sigenv sigenv);
      Timer.xtime("write_env",     !do_timings, fn () => write_env env);
      Timer.xtime("write_type_assembly", !do_timings, fn () => write_type_assembly type_assembly);
      Timer.xtime("write_str_assembly", !do_timings, fn () => write_str_assembly str_assembly);
      Timer.xtime("write_debug",   !do_timings, fn () => write_debug debug_information);
(*
      output(std_out, "Number of repeated tyenvs found = " ^
	     Integer.makestring(!tyenv_repeats) ^ "\n");
*)
      if !print_hash_table_stats then
	(output(std_out,"Tynamehashtable in _encapsulate: " ^
		NewHashTable.string_hash_table_stats(tynamehashtable) ^ "\n");
	 output(std_out,"FunTypehashtable in _encapsulate: " ^
		NewHashTable.string_hash_table_stats(funtypehashtable) ^ "\n");
	 output(std_out,"ConsTypehashtable in _encapsulate: " ^
		NewHashTable.string_hash_table_stats(constypehashtable) ^ "\n");
	 output(std_out,"RecTypehashtable in _encapsulate: " ^
		NewHashTable.string_hash_table_stats(rectypehashtable) ^ "\n");
	 output(std_out,"Valenvhashtable in _encapsulate: " ^
		NewHashTable.string_hash_table_stats(valenvhashtable) ^ "\n"))
      else ()
    end
@


1.89
log
@Typechecker structure changes
@
text
@d4 3
d614 1
a614 1
    | count_real_objects(count, MachTypes.WORDSET(MachTypes.WORD_SET w_list) :: rest) =
d2204 1
a2204 1
	    | output_module_element(MachTypes.WORDSET(MachTypes.WORD_SET w_list)) =
d2207 2
a2208 1
		  Lists.reducel (fn (res,(i,spill,s)) => res + 4 + size s) (0, w_list)
d2210 1
d2214 3
d2219 1
a2219 1
		(fn (i, spills, w) => (write_int i; write_int (4 + size w); write_int spills; write_string w))
@


1.88
log
@Changed for COPYSTR structures.
Added cached values in interfaces and structures.
@
text
@d4 4
d366 1
a366 1
require "../typechecker/valenv";
d388 1
a388 1
  structure Valenv : VALENV
d401 3
a403 1
  sharing Basis.Tyvarenv.Datatypes = Valenv.Datatypes = Types.Datatypes =
d405 3
a407 4
    EnvironTypes.LambdaTypes.Datatypes =
    Env.Datatypes
  sharing ParserEnv.Ident = Valenv.Datatypes.Ident
  sharing Basis.Tyvarenv.Datatypes.NewMap = ParserEnv.Map
d413 2
a414 5
  structure Datatypes = Basis.Tyvarenv.Datatypes
  structure Sigenv = Basis.Sigenv
  structure Sigma = Sigenv.Sigma
  structure Funenv = Basis.Funenv
  structure Phi = Funenv.Phi
a419 1
  structure Nameset = Sigma.Nameset
d425 1
a425 1
  structure Map = Basis.Tyvarenv.Datatypes.Mapping
d1699 1
a1699 1
	  (Sigma.SIGMA(nameset, str), ptr)
d1707 1
a1707 1
	  (Sigenv.SIGENV sigenv, ptr)
d1716 1
a1716 1
	  (Phi.PHI(nameset, (str, sigma)), ptr)
d1724 1
a1724 1
	  (Funenv.FUNENV funenv, ptr)
d1894 1
a1894 1
      val result = (Basis.BASIS(nameset, funenv, sigenv, env), 
d1913 1
a1913 1
  fun reset_refs(Basis.BASIS(nameset, funenv, sigenv, env), value) =
d1995 1
a1995 1
      and reset_sigma(Sigma.SIGMA(ns, s)) =
d1999 1
a1999 1
      and reset_sigenv(Sigenv.SIGENV M) =
d2002 1
a2002 1
      and reset_phi(Phi.PHI(ns, (s, sg))) =
d2007 1
a2007 1
      and reset_funenv(Funenv.FUNENV M) =
d2460 1
a2460 1
      fun write_type_basis (Basis.BASIS(nameset, funenv, sigenv, env), 
d2989 1
a2989 1
      fun write_sigma (Sigma.SIGMA(ns, s)) =
d2992 1
a2992 1
      fun write_sigenv (Sigenv.SIGENV M) =
d2995 1
a2995 1
      fun write_phi (Phi.PHI(ns, (s, sg))) =
d2998 1
a2998 1
      fun write_funenv (Funenv.FUNENV M) =
@


1.87
log
@Changed ObjectFile.version to ObjectFile.object_file_version to avoid
problem on the C side of the run time system.
@
text
@d4 4
d366 1
a366 1
require "../typechecker/interface";
d387 1
a395 1
  structure Interface : INTERFACE
d399 2
a400 1
    EnvironTypes.LambdaTypes.Datatypes = Interface.Datatypes
a402 1
  sharing Interface = EnvironTypes.Interface
a423 1
  structure Interface = Interface
d428 1
d811 1
a811 1
	  (Interface.INT(Interface.INTENV s_int, v_int, e_int), ptr)
d1674 1
a1674 1
	  (Datatypes.STR(strname, env), ptr)
d1979 1
a1979 1
      and reset_str(Datatypes.STR(sn, e)) =
d1982 2
d2405 1
a2405 1
	  fun write_interface (Interface.INT(Interface.INTENV s_map, v_list, e_list)) =
d2972 1
a2972 1
      fun write_str (Datatypes.STR(sn, e)) =
d2974 2
@


1.86
log
@Moved currentVersion into ObjectFile, so that it's accessible to the run-time
system too.
@
text
@d4 4
d3079 1
a3079 1
	(write_int ObjectFile.GOOD_MAGIC; write_int ObjectFile.version)
d3117 1
a3117 1
	if version = ObjectFile.version then
@


1.85
log
@Anel's last changes
@
text
@d4 3
a420 1
  val currentVersion = 2
d3075 1
a3075 1
	(write_int ObjectFile.GOOD_MAGIC; write_int currentVersion)
d3113 1
a3113 1
	if version = currentVersion then
@


1.84
log
@Ensure decode_cons is done before close_in file_handle in order to
fix file already closed bug
@
text
@d4 4
d624 3
a626 3
  fun encode_over_loaded Datatypes.UNARY = output_byte 1
  | encode_over_loaded Datatypes.BINARY = output_byte 2
  | encode_over_loaded Datatypes.PREDICATE = output_byte 3
d1175 6
a1180 3
	    1 => (Datatypes.UNARY, ptr)
	  | 2 => (Datatypes.BINARY, ptr)
	  | 3 => (Datatypes.PREDICATE, ptr)
d1372 2
a1373 1
		    val ty = Datatypes.META_OVERLOADED(ref ty)
d1934 1
a1934 1
      | reset_type(Datatypes.META_OVERLOADED(ref t)) =
d2745 1
a2745 1
      | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t)) =
@


1.83
log
@Simplified some error messages
@
text
@d4 3
d3131 3
d3137 1
a3137 1
	 consistency = decode_cons cons}
@


1.82
log
@Changed to encode tyenvs where they're in common.
Some minor efficiency improvements to do with module name searching
@
text
@d4 4
d3105 1
a3105 1
	  raise BadInput "Inconsistent version number in object file"
d3107 1
a3107 1
	raise BadInput "Bad magic number in object file"
d3114 1
a3114 1
      if size s <> len then raise BadInput "Truncated object file"
@


1.81
log
@Changed error messages
@
text
@d4 3
d406 1
a406 1

d455 2
a456 2
	val y = Bits.lshift(String.ordof(s, ptr + 1) + x, 8)
	val z = Bits.lshift(String.ordof(s, ptr + 2) + y, 8)
d458 1
a458 1
	z + String.ordof(s, ptr + 3)
d469 2
a470 1
	  (Bits.lshift(String.ordof(s, ptr + 1), 8) + String.ordof(s, ptr + 2), ptr + 3)
d582 1
a582 1
	    dec_sub(n-1, ptr, Assemblies.IntMap.define(m, fval, gval))
d585 1
a585 1
      dec_sub(count, ptr, Assemblies.IntMap.empty)
d968 1
a968 1
      val (tyname_count,strname_count,tyfun_count) =
d970 1
a970 2
	  (_,tyname_count,strname_count,tyfun_count)::rest =>
	    (tyname_count,strname_count,tyfun_count)
d973 4
a976 13
      fun name_offsets name =
	let
	  fun search nil = Crash.impossible ("couldn't find module <" ^
					     name ^ "> in name_offsets")
	    | search ((name',tyname_count,strname_count,tyfun_count)::rest) =
	      if name = name'
		then
		  (tyname_count,strname_count,tyfun_count)
	      else
		search rest
	in
	  search sub_modules
	end
d978 2
d1080 1
a1080 1
		val (tyname_count,_,_) = name_offsets module
d1115 1
a1115 1
		val (_,_,tyfun_count) = name_offsets module
d1150 1
a1150 1
		val (_,strname_count,_) = name_offsets module
d1227 2
d1616 2
a1617 2
	  val (tyenv, ptr) =
	    input_newmap(s, decode_tycon, decode_tystr, ptr, Ident.tycon_lt, Ident.tycon_eq)
d1619 13
a1631 1
	  (Datatypes.TE tyenv, ptr)
d2123 2
a2124 2
	(write_opt_int(Assemblies.IntMap.size m);
	 Assemblies.IntMap.iterate_ordered (write_pair write_int g) m)
d2435 8
d2619 1
a2619 1
	  fun encode_fun_or_cons(done, scheme) =
d2621 3
a2623 3
	      Datatypes.CONSTYPE _ => output_byte 1 :: done
	    | Datatypes.NULLTYPE => output_byte 1 :: done
	    | Datatypes.FUNTYPE _ => output_byte 2 :: done
d2625 3
d2869 47
d2917 27
a2943 1
	write_newmap write_tycon write_tystr m
d3036 4
@


1.80
log
@Time is now represented by a pervasive structure.
@
text
@d4 3
d3020 1
a3020 1
	handle Io m => raise BadInput m
d3051 1
a3051 1
	handle Io m => raise BadInput m
@


1.79
log
@Modified assembly encapsulation to use IntMap
@
text
@d4 3
d1985 7
a1991 1
      fun decode_int ptr = input_opt_int(s, ptr)
d1995 1
a1995 1
        input_list(s, input_pair decode_string (input_pair decode_int decode_int), 0)
d2954 1
a2954 1
	write_assoc write_sz_string (fn {hi, lo} => (write_opt_int hi; write_opt_int lo)) l
@


1.78
log
@Removed dependence on environ in favour of environtypes
@
text
@d4 3
d562 16
d1718 1
a1718 1
      fun decode_type_assembly ptr = 
d1721 1
a1721 1
            input_newmap' (s, decode_ty_ass_dom, decode_ty_ass_val, ptr, (op<) : int * int -> bool)
d2100 4
d2874 1
a2874 1
        write_newmap write_int write_tyass_val (Assemblies.TypeAssembly_to_map ty_ass)
@


1.77
log
@Modified to use less than functions for maps
@
text
@d4 3
a327 1
require "../typechecker/simpletypes";
d332 2
a333 1
require "../lambda/environ";
a352 1
  structure Environ : ENVIRON
d360 2
a362 1
  sharing ParserEnv.Ident = Environ.Interface.Datatypes.Ident
d364 3
a366 2
    Enc_Sub.DataTypes = Debugger_Types.Datatypes = Environ.Interface.Datatypes =
    Environ.EnvironTypes.LambdaTypes.Datatypes = Assemblies.Datatypes
d368 3
a370 1
  sharing type Pervasives.pervasive = Environ.EnvironTypes.LambdaTypes.Primitive
d382 1
a382 1
  structure EnvironTypes = Environ.EnvironTypes
d390 1
a390 1
  structure Interface = Environ.Interface
@


1.76
log
@Anel's changes for encapsulating assemblies
@
text
@d4 3
d685 1
a685 1
		    input_newmap(s, decode_var, read_field, ptr, Environ.valid_order,Environ.valid_equal)
d703 1
a703 1
		      input_newmap(s, decode_excon, read_field, ptr, Environ.valid_order,Environ.valid_equal)
d717 1
a717 1
	    input_newmap(s, decode_strid, input_pair read_env read_field, ptr, Environ.strid_order, Environ.strid_equal)
d753 1
a753 1
	    input_newmap(s, decode_strid, read_interface, ptr, Environ.strid_order, Environ.strid_equal)
d769 1
a769 1
	input_newmap(s, decode_funid, read_ftr_range, ptr, Environ.funid_order, Environ.funid_equal)
d870 1
a870 1
		  input_newmap(s, decode_symbol, decode_fixity, ptr, Environ.symbol_order, Environ.symbol_equal)
d911 1
a911 1
	    input_newmap(s, decode_strid, read_parse_env, ptr, Environ.strid_order, Environ.strid_equal)
d918 1
a918 1
	input_newmap(s, decode_funid, read_parse_env, 0, Environ.funid_order, Environ.funid_equal)
d920 1
a920 1
	input_newmap(s, decode_sigid, read_parse_env, ptr, Environ.sigid_order, Environ.sigid_equal)
d1467 1
a1467 1
		input_newmap(s, decode_valid, decode_typescheme, ptr, Environ.valid_order, Environ.valid_equal)
d1505 1
a1505 1
		      input_newmap(s, decode_valid, decode_dummy_scheme, ptr, Environ.valid_order, Environ.valid_equal)
d1588 1
a1588 1
	    input_newmap(s, decode_tycon, decode_tystr, ptr, Datatypes.tycon_order, Datatypes.tycon_equal)
d1614 1
a1614 1
	    input_newmap(s, decode_strid, decode_str, ptr, Environ.strid_order, Environ.strid_equal)
d1638 1
a1638 1
	    input_newmap(s, decode_sigid, decode_sigma, ptr, Sigenv.sigid_order, Sigenv.sigid_equal)
d1655 1
a1655 1
	    input_newmap(s, decode_funid, decode_phi, ptr, Funenv.funid_order, Funenv.funid_equal)
d1704 1
a1704 1
            input_newmap' (s, decode_tycon, decode_tyfun_int, ptr, Datatypes.tycon_order)
d1720 1
a1720 1
            input_newmap' (s, decode_strid, decode_strname_int, ptr, Datatypes.strid_order)
@


1.75
log
@Tynames now have a slot recording their definition point
@
text
@d4 3
d324 1
d354 1
d359 1
a359 1
    Environ.EnvironTypes.LambdaTypes.Datatypes
d384 1
d534 16
d1660 74
d1819 3
d1824 4
a1827 1
      val result = (Basis.BASIS(nameset, funenv, sigenv, env), debug_information)
d1965 1
a1965 1
     type_basis, debug_info = Debugger_Types.INFO debug_info, require_list, consistency} =
d2378 2
a2379 1
      fun write_type_basis(Basis.BASIS(nameset, funenv, sigenv, env), debug_information, sub_modules) =
d2833 31
d2895 2
d2922 2
a2923 1
      val (ty_start, _, ty_end) = (!fpos, write_type_basis(type_basis, debug_info, require_list), !fpos)
@


1.74
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d1515 1
a1515 1
		      Datatypes.TYNAME(tyname_id, st, i, ref b, valenv)
d1764 1
a1764 1
      and reset_tyname(Datatypes.TYNAME(ti, s, n, r as ref b, ref ve)) =
d2504 1
a2504 1
	  and encode_tyname(done, Datatypes.TYNAME(ti, s, n, ref b, ref ve)) =
@


1.73
log
@Stopped using empty_eqfunmap, no longer necessary. Simplified decode_map
and encode_map
@
text
@d4 4
d509 1
a509 1
  fun input_newmap(s, f, g, ptr, orderfn) =
d512 2
a513 3

      fun dec_sub(0, ptr, m) = (m, ptr)
	| dec_sub(n, ptr, m) =
d518 1
a518 1
	    dec_sub(n-1, ptr, NewMap.define(m, fval, gval))
d520 1
d522 1
a522 1
      dec_sub(count, ptr, NewMap.empty orderfn)
d568 2
a569 1
      NewMap.fold (fn (done, a, b) => g(f(done, a), b)) (sz :: done, m)
d657 1
a657 1
		    input_newmap(s, decode_var, read_field, ptr, Environ.valid_order)
d675 1
a675 1
		      input_newmap(s, decode_excon, read_field, ptr, Environ.valid_order)
d689 1
a689 1
	    input_newmap(s, decode_strid, input_pair read_env read_field, ptr, Environ.strid_order)
d725 1
a725 1
	    input_newmap(s, decode_strid, read_interface, ptr, Environ.strid_order)
d741 1
a741 1
	input_newmap(s, decode_funid, read_ftr_range, ptr, Environ.funid_order)
d842 1
a842 1
		  input_newmap(s, decode_symbol, decode_fixity, ptr, Environ.symbol_order)
d883 1
a883 1
	    input_newmap(s, decode_strid, read_parse_env, ptr, Environ.strid_order)
d890 1
a890 1
	input_newmap(s, decode_funid, read_parse_env, 0, Environ.funid_order)
d892 1
a892 1
	input_newmap(s, decode_sigid, read_parse_env, ptr, Environ.sigid_order)
d1140 1
a1140 5
      fun decode_order(i, j:int) =
	if i = j then NewMap.EQUAL
	else
	  if i < j then NewMap.LESS
	  else NewMap.GREATER
d1142 1
a1142 1
	ref (NewMap.empty decode_order) : (int, Datatypes.Tyname ref)NewMap.T ref
d1439 1
a1439 1
		input_newmap(s, decode_valid, decode_typescheme, ptr, Environ.valid_order)
d1477 1
a1477 1
		      input_newmap(s, decode_valid, decode_dummy_scheme, ptr, Environ.valid_order)
d1560 1
a1560 1
	    input_newmap(s, decode_tycon, decode_tystr, ptr, Datatypes.tycon_order)
d1586 1
a1586 1
	    input_newmap(s, decode_strid, decode_str, ptr, Environ.strid_order)
d1610 1
a1610 1
	    input_newmap(s, decode_sigid, decode_sigma, ptr, Sigenv.sigid_order)
d1627 1
a1627 1
	    input_newmap(s, decode_funid, decode_phi, ptr, Funenv.funid_order)
d1710 2
a1711 6
            (fn (x,y) => 
             if x=y
               then NewMap.EQUAL
             else if String.<(x,y)
                then NewMap.LESS
                  else NewMap.GREATER))
d1743 1
a1743 1
	(NewMap.fold (fn (_, _, b) => (fun2 b)) ((), m); ())
d1964 2
a1965 1
	(write_opt_int(NewMap.size m); NewMap.iterate (write_pair f g) m)
d2349 1
d2351 10
@


1.72
log
@Added a type annotation
@
text
@d4 3
d569 2
a570 1
      val sz = optimised_output_int(Map.fold (fn _ => fn res => res + 1) 0 m)
d1124 1
a1124 1
      fun decode_map f g ptr eqfn orderfn =
d1129 1
a1129 1
	   (Map.empty_eqfunmap eqfn, assoc_list), ptr)
d1361 1
a1361 2
		      decode_map decode_lab decode_type ptr Ident.lab_eq
		      Ident.lab_order
@


1.71
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d306 1
a306 1
require "../utils/_newhashtable";
@


1.70
log
@Typo meant some things looked up in the wrong hashtable
@
text
@d4 3
d336 1
a377 192
  structure StringHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = string
    val eq = (op= : int * int -> bool)
    fun hash x = x
    val size = 1024
      )

  structure ValHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = (Symbol.Symbol * Ident.ValId) list
    type Value = int
    val eq = op=
    fun hash [] = 0
      | hash ((sy, _) :: _) =
	let
          val str = Symbol.symbol_name sy
	in
          add_together_ords(str,size str)
	end
    val size = 128
      )

  structure FixHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = (Symbol.Symbol * ParserEnv.Fixity) list
    type Value = int
    val eq = op=
    fun hash [] = 0
      | hash ((sy, _) :: _) =
	let
          val str = Symbol.symbol_name sy
	in
          add_together_ords(str,size str)
	end
    val size = 128
      )

  structure LambdaValHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = (Ident.ValId * EnvironTypes.comp) list
    type Value = int
    val eq = op=
    fun hash [] = 0
      | hash ((valid, _) :: _) =
	let
          val sy = case valid of
	     Ident.VAR sy => sy
	   | Ident.CON sy => sy
	   | Ident.EXCON sy => sy
	  val str = Symbol.symbol_name sy
	in
          add_together_ords(str,size str)
	end
    val size = 128
      )

  structure IntHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = Ident.ValId list
    type Value = int
    val eq = op=
    fun hash [] = 0
      | hash (valid :: _) =
	let
          val sy = case valid of
	     Ident.VAR sy => sy
	   | Ident.CON sy => sy
	   | Ident.EXCON sy => sy
	  val str = Symbol.symbol_name sy
	in
          add_together_ords(str,size str)
	end
    val size = 128
      )

  structure StrnameHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Strname
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure MetaTyvarHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure MetaOverloadedHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure TyvarHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure MetaRectypeHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure RectypeHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure ConstypeHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure DebruijnHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Type
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure ValenvHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Valenv
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure TynameValenvHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Valenv
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

  structure TynameHashTable = NewHashTable(
    structure Crash = Crash
    structure Lists = Lists
    type Key = int
    type Value = Datatypes.Tyname
    val eq = (op= : int * int -> bool)
    val hash = fn x => x
    val size = 128
      )

d891 1
a891 1
      val decfuntypehashtable = Enc_Sub.DecFuntypeHashTable.new()
d1153 11
a1163 11
      val strnamehashtable = StrnameHashTable.new()
      val metatyvarhashtable = MetaTyvarHashTable.new()
      val metaoverloadedhashtable = MetaOverloadedHashTable.new()
      val tyvarhashtable = TyvarHashTable.new()
      val metarectypehashtable = MetaRectypeHashTable.new()
      val rectypehashtable = RectypeHashTable.new()
      val constypehashtable = ConstypeHashTable.new()
      val debruijnhashtable = DebruijnHashTable.new()
      val valenvhashtable = ValenvHashTable.new()
      val tynamevalenvhashtable = TynameValenvHashTable.new()
      val tynamehashtable = TynameHashTable.new()
d1187 1
a1187 1
		      StrnameHashTable.update(strnamehashtable, n, strname)
d1192 1
a1192 1
		  (StrnameHashTable.lookup(strnamehashtable, n), ptr)
d1277 1
a1277 1
		      MetaTyvarHashTable.update(metatyvarhashtable, n, ty)
d1282 1
a1282 1
		  (MetaTyvarHashTable.lookup(metatyvarhashtable, i), ptr)
d1295 1
a1295 1
		      MetaOverloadedHashTable.update
d1301 1
a1301 1
		  (MetaOverloadedHashTable.lookup(metaoverloadedhashtable, i),
d1316 1
a1316 1
		      TyvarHashTable.update(tyvarhashtable, n, ty)
d1321 1
a1321 1
		  (TyvarHashTable.lookup(tyvarhashtable, i), ptr)
d1338 1
a1338 1
		      MetaRectypeHashTable.update(metarectypehashtable, n, ty)
d1343 1
a1343 1
		  (MetaRectypeHashTable.lookup(metarectypehashtable, i), ptr)
d1357 1
a1357 1
		    val _ = RectypeHashTable.update(rectypehashtable, n, ty)
d1362 1
a1362 1
		  (RectypeHashTable.lookup(rectypehashtable, i), ptr)
d1375 1
a1375 1
		    val _ = Enc_Sub.DecFuntypeHashTable.update(decfuntypehashtable,c, ty)
d1380 1
a1380 1
		  (Enc_Sub.DecFuntypeHashTable.lookup (decfuntypehashtable,i), ptr)
d1393 1
a1393 1
		    val _ = ConstypeHashTable.update(constypehashtable, n, ty)
d1398 1
a1398 1
		  (ConstypeHashTable.lookup(constypehashtable, i), ptr)
d1412 1
a1412 1
		    val _ = DebruijnHashTable.update(debruijnhashtable, n, ty)
d1417 1
a1417 1
		  (DebruijnHashTable.lookup(debruijnhashtable, i), ptr)
d1434 1
a1434 1
	      val _ = ValenvHashTable.update(valenvhashtable, n, valenv)
d1439 1
a1439 1
	    (ValenvHashTable.lookup(valenvhashtable, n), ptr)
d1475 1
a1475 1
		    TynameValenvHashTable.update
d1480 1
a1480 1
		  (ref(TynameValenvHashTable.lookup(tynamevalenvhashtable, n)),
d1506 1
a1506 1
		    val _ = TynameHashTable.update(tynamehashtable, n, tyname)
d1511 1
a1511 1
		  (TynameHashTable.lookup(tynamehashtable, n), ptr)
d1724 1
a1724 1
		 Enc_Sub.DecFuntypeHashTable.string_hash_table_stats(decfuntypehashtable) ^ "\n")
d1733 1
a1733 2
    | Enc_Sub.DecFuntypeHashTable.Lookup _ => raise TypeDecapError
    | StringHashTable.Lookup _ => raise TypeDecapError
d2044 19
a2062 2
	  val valhashtable = ValHashTable.new()
	  val fixhashtable = FixHashTable.new()
d2077 1
a2077 1
		FixHashTable.lookup_default(fixhashtable, 0, fix_list)
d2084 1
a2084 1
		    FixHashTable.update(fixhashtable, fix_list, newsize);
d2091 1
a2091 13
(*
		(write_opt_int (FixHashTable.lookup(fixhashtable, fix_list)))
		handle FixHashTable.Lookup _ =>
		  let
		    val newsize = !fixsize + 1
		  in
		    fixsize := newsize;
		    FixHashTable.update(fixhashtable, fix_list, newsize);
		    write_opt_int 0;
		    write_assoc write_symbol write_fixity fix_list
		    (*write_newmap write_symbol write_fixity fix_map*)
		  end
*)
d2093 1
a2093 1
	      val n = ValHashTable.lookup_default(valhashtable, 0, val_list)
d2100 1
a2100 1
		    ValHashTable.update(valhashtable, val_list, newsize);
d2107 1
a2107 13
(*
		(write_opt_int (ValHashTable.lookup(valhashtable, val_list)))
		handle ValHashTable.Lookup _ =>
		  let
		    val newsize = !valsize + 1
		  in
		    valsize := newsize;
		    ValHashTable.update(valhashtable, val_list, newsize);
		    write_opt_int 0;
		    write_list (write_valid o #2) val_list
		    (*write_newmap (fn _ => ()) write_valid val_map*)
		  end
*)
d2122 14
a2135 1
	  val lambdavalhashtable = LambdaValHashTable.new()
d2137 2
a2138 1
	  val lambdaexnhashtable = LambdaValHashTable.new()
d2140 15
a2154 1
	  val intvalhashtable = IntHashTable.new()
d2156 2
a2157 1
	  val intexnhashtable = IntHashTable.new()
d2177 1
a2177 1
		LambdaValHashTable.lookup_default(lambdavalhashtable, 0,
d2185 1
a2185 1
		    LambdaValHashTable.update(lambdavalhashtable, v_list,
d2190 1
a2190 11
(*
		LambdaValHashTable.lookup(lambdavalhashtable, v_list)
		handle LambdaValHashTable.Lookup _ =>
		  let
		    val newsize = !valsize + 1
		  in
		    valsize := newsize;
		    LambdaValHashTable.update(lambdavalhashtable, v_list, newsize);
		    0
		  end
*)
d2192 1
a2192 1
		LambdaValHashTable.lookup_default(lambdaexnhashtable, 0,
d2200 1
a2200 1
		    LambdaValHashTable.update(lambdaexnhashtable, e_list,
d2205 1
a2205 11
(*
		LambdaValHashTable.lookup(lambdaexnhashtable, e_list)
		handle LambdaValHashTable.Lookup _ =>
		  let
		    val newsize = !exnsize + 1
		  in
		    exnsize := newsize;
		    LambdaValHashTable.update(lambdaexnhashtable, e_list, newsize);
		    0
		  end
*)
d2217 1
a2217 1
	      val vnum = IntHashTable.lookup_default(intvalhashtable, 0,
d2225 1
a2225 1
		    IntHashTable.update(intvalhashtable, v_list, newsize)
d2229 2
a2230 12
(*
	      val vnum = IntHashTable.lookup(intvalhashtable, v_list)
		handle IntHashTable.Lookup _ =>
		  let
		    val newsize = !intvalsize + 1
		  in
		    intvalsize := newsize;
		    IntHashTable.update(intvalhashtable, v_list, newsize);
		    0
		  end
*)
	      val enum = IntHashTable.lookup_default(intexnhashtable, 0,
d2238 1
a2238 1
		    IntHashTable.update(intexnhashtable, e_list, newsize)
d2242 1
a2242 11
(*
	      val enum = IntHashTable.lookup(intexnhashtable, e_list)
		handle IntHashTable.Lookup _ =>
		  let
		    val newsize = !intexnsize + 1
		  in
		    intexnsize := newsize;
		    IntHashTable.update(intexnhashtable, e_list, newsize);
		    0
		  end
*)
d2263 1
a2263 1
		    LambdaValHashTable.string_hash_table_stats(lambdavalhashtable) ^ "\n");
d2265 1
a2265 1
		    LambdaValHashTable.string_hash_table_stats(lambdaexnhashtable) ^ "\n"))
d2271 6
a2276 5
	  val tynamehashtable = Enc_Sub.TynameHashTable.new()
	  val funtypehashtable = Enc_Sub.FuntypeHashTable.new()
	  val constypehashtable = Enc_Sub.ConstypeHashTable.new()
	  val rectypehashtable = Enc_Sub.RectypeHashTable.new()
	  val valenvhashtable = Enc_Sub.ValenvHashTable.new()
d2450 1
a2450 1
		    Enc_Sub.ValenvHashTable.lookup_default
d2452 1
a2452 4
(*
		    (Enc_Sub.ValenvHashTable.lookup (valenvhashtable,valenv))
		    handle (Enc_Sub.ValenvHashTable.Lookup _) => 0
*)
d2459 1
a2459 1
		      val _ = Enc_Sub.ValenvHashTable.update(valenvhashtable,valenv, c)
d2509 1
a2509 1
		  Enc_Sub.TynameHashTable.lookup_default
d2511 1
a2511 4
(*
		  (Enc_Sub.TynameHashTable.lookup (tynamehashtable,tyn))
		  handle (Enc_Sub.TynameHashTable.Lookup _) => 0
*)
d2518 1
a2518 1
		    val _ = Enc_Sub.TynameHashTable.update(tynamehashtable,tyn, c)
d2595 1
a2595 1
	    Enc_Sub.RectypeHashTable.lookup_default
a2597 4
(*
	    Enc_Sub.RectypeHashTable.lookup (rectypehashtable,arg)
	    handle Enc_Sub.RectypeHashTable.Lookup _ => 0
*)
d2604 1
a2604 1
	      val _ = Enc_Sub.RectypeHashTable.update(rectypehashtable,arg, c)
d2614 1
a2614 1
	    Enc_Sub.FuntypeHashTable.lookup_default
d2616 1
a2616 4
(*
	    Enc_Sub.FuntypeHashTable.lookup (funtypehashtable,full_arg)
	    handle Enc_Sub.FuntypeHashTable.Lookup _ => 0
*)
d2623 1
a2623 1
	      val _ = Enc_Sub.FuntypeHashTable.update(funtypehashtable,full_arg, c)
d2633 1
a2633 1
	    Enc_Sub.ConstypeHashTable.lookup_default
d2635 1
a2635 4
(*
	    Enc_Sub.ConstypeHashTable.lookup (constypehashtable,arg)
	    handle Enc_Sub.ConstypeHashTable.Lookup _ => 0
*)
d2642 1
a2642 1
	      val _ = Enc_Sub.ConstypeHashTable.update(constypehashtable,arg, c)
d2746 1
a2746 1
		Enc_Sub.TynameHashTable.string_hash_table_stats(tynamehashtable) ^ "\n");
d2748 1
a2748 1
		Enc_Sub.FuntypeHashTable.string_hash_table_stats(funtypehashtable) ^ "\n");
d2750 1
a2750 1
		Enc_Sub.ConstypeHashTable.string_hash_table_stats(constypehashtable) ^ "\n");
d2752 1
a2752 1
		Enc_Sub.RectypeHashTable.string_hash_table_stats(rectypehashtable) ^ "\n");
d2754 1
a2754 1
		Enc_Sub.ValenvHashTable.string_hash_table_stats(valenvhashtable) ^ "\n"))
d2837 1
a2837 2
      | Enc_Sub.DecFuntypeHashTable.Lookup _ => (close_in file_handle; raise Error)
      | StringHashTable.Lookup _ => (close_in file_handle; raise Error)
d2876 1
a2876 2
      | Enc_Sub.DecFuntypeHashTable.Lookup _ => (close_in file_handle; raise Error)
      | StringHashTable.Lookup _ => (close_in file_handle; raise Error)
@


1.69
log
@Changed a number of handle statements for uses of lookup_default
@
text
@d4 3
d1509 1
a1509 1
		  (MetaTyvarHashTable.lookup(metatyvarhashtable, i), ptr)
@


1.68
log
@Allowed NULLTYPEs in valenvs, produced by nameset copying
@
text
@d4 3
d2062 3
d2066 1
d2246 15
d2272 1
d2274 1
d2276 13
d2300 1
d2341 14
d2364 1
a2364 1

d2366 14
d2389 1
d2401 13
d2423 14
a2436 1

d2446 1
d2653 3
d2658 1
d2715 3
d2720 1
d2804 4
d2810 1
d2827 3
d2832 1
d2849 3
d2854 1
@


1.67
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
a629 3
(*
  val stringMap = ref (StringHashTable.new())
*)
a641 3
(*
	  StringHashTable.update(!stringMap, strId, str);
*)
a645 3
(*
	(StringHashTable.lookup(!stringMap, id), ptr)
*)
d1306 1
a1306 2
      
      val valenvs_decoded = ref [] : Datatypes.Valenv ref list ref
a1307 1
      val tyname_valenvs_decoded = ref [] : Datatypes.Valenv list ref
a1308 2
      val dummy_valenv = Datatypes.empty_valenv
      val tynames_decoded = ref [] : Datatypes.Tyname list ref
a1309 1
      val meta_tynames_decoded = ref [] : Datatypes.Tyname ref list ref
a1320 1
      val metatyvar_types_decoded = ref [] : Datatypes.Type ref list ref
a1321 1
      val meta_overloaded_types_decoded = ref [] : Datatypes.Type ref list ref
a1322 1
      val tyvar_types_decoded = ref [] : Datatypes.Type list ref
a1323 1
      val metarectype_types_decoded = ref [] : Datatypes.Type ref list ref
a1324 1
      val rectype_types_decoded = ref [] : Datatypes.Type ref list ref
a1325 1
      val funtype_types_decoded = ref [] : Datatypes.Type ref list ref
a1326 1
      val constype_types_decoded = ref [] : Datatypes.Type ref list ref
a1327 1
      val debruijn_types_decoded = ref [] : Datatypes.Type list ref
a1328 2
      val dummy_type = Datatypes.NULLTYPE
      val dummy_typescheme = Datatypes.UNBOUND_SCHEME Datatypes.NULLTYPE
a1333 1
      val strnames_decoded = ref [] : Datatypes.Strname ref list ref
a1334 2
      val dummy_strname = 
	Datatypes.NULLNAME (Strname_id.make_strname_n 0)
a1363 7
(*
		    val r = ref dummy_strname
		    val _ = strnames_decoded := r :: (!strnames_decoded)
		    val _ = strnames_so_far := (!strnames_so_far)+1
		    val (name, ptr) = decode_strname ptr
		    val _ = r := Datatypes.METASTRNAME (ref name)
*)
a1370 3
(*
		    (!r,ptr)
*)
a1374 3
(*
		  (!(Lists.nth(!strnames_so_far - n, !strnames_decoded)), ptr)
*)
a1449 1
(*
a1450 20
		    val r = ref dummy_type
		    val _ =
		      metatyvar_types_decoded := r :: !metatyvar_types_decoded
		    val _ =
		      metatyvar_types_so_far := !metatyvar_types_so_far + 1
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (ty, ptr) = decode_type ptr
		    val (b1, ptr) = decode_bool ptr
		    val (b2, ptr) = decode_bool ptr
		    val ty = Datatypes.METATYVAR(ref(i, ty), b1, b2)
		  in
		    (r := ty;
		     (ty, ptr))
		  end
		else
		  (!(Lists.nth(!metatyvar_types_so_far - i, 
			       !metatyvar_types_decoded)),
		   ptr)
*)
		  let
a1471 11
(*
		    val r = ref dummy_type
		    val _ =
		      meta_overloaded_types_decoded :=
		      r :: !meta_overloaded_types_decoded
		    val _ =
		      meta_overloaded_types_so_far :=
		      !meta_overloaded_types_so_far + 1
		    val (ty, ptr) = decode_type ptr
		    val ty = Datatypes.META_OVERLOADED(ref ty)
*)
a1479 4
(*
		    (r := ty;
		     (ty, ptr))
*)
a1484 5
(*
		  (!(Lists.nth(!meta_overloaded_types_so_far - i, 
			       !meta_overloaded_types_decoded)),
		   ptr)
*)
a1491 7
(*
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (tyvar, ptr) = decode_tyvar ptr
		    val ty = Datatypes.TYVAR(ref i, tyvar)
		    val _ = tyvar_types_decoded := ty :: (!tyvar_types_decoded)
		    val _ = tyvar_types_so_far := (!tyvar_types_so_far)+1
*)
a1502 3
(*
		  ((Lists.nth(!tyvar_types_so_far - i, !tyvar_types_decoded)), ptr)
*)
a1510 14
(*
		    val r = ref dummy_type
		    val _ =
		      metarectype_types_decoded :=
		      r :: !metarectype_types_decoded
		    val _ =
		      metarectype_types_so_far := !metarectype_types_so_far + 1
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b1, ptr) = decode_bool ptr
		    val (ty, ptr) = decode_type ptr
		    val (b2, ptr) = decode_bool ptr
		    val (b3, ptr) = decode_bool ptr
		    val ty = Datatypes.METARECTYPE(ref(i, b1, ty, b2, b3))
*)
a1521 4
(*
		    (r := ty;
		     (ty, ptr))
*)
a1524 5
(*
		  (!(Lists.nth(!metarectype_types_so_far - i, 
			       !metarectype_types_decoded)),
		   ptr)
*)
a1532 11
(*
		    val r = ref dummy_type
		    val _ =
		      rectype_types_decoded := r :: !rectype_types_decoded
		    val _ =
		      rectype_types_so_far := !rectype_types_so_far + 1
		    val (lab_map, ptr) =
		      decode_map decode_lab decode_type ptr Ident.lab_eq
		      Ident.lab_order
		    val ty = Datatypes.RECTYPE lab_map
*)
a1540 4
(*
		    (r := ty;
		     (ty, ptr))
*)
a1543 5
(*
		  (!(Lists.nth(!rectype_types_so_far - i, 
			       !rectype_types_decoded)),
		   ptr)
*)
a1569 10
(*
		    val r = ref dummy_type
		    val _ =
		      constype_types_decoded := r :: !constype_types_decoded
		    val _ =
		      constype_types_so_far := !constype_types_so_far + 1
		    val (the_list, ptr) = input_list(s, decode_type, ptr)
		    val (tyname, ptr) = decode_tyname ptr
		    val ty = Datatypes.CONSTYPE(the_list, tyname)
*)
a1576 4
(*
		    (r := ty;
		     (ty, ptr))
*)
a1579 5
(*
		  (!(Lists.nth(!constype_types_so_far - i, 
			       !constype_types_decoded)),
		   ptr)
*)
a1591 5
(*
		    val _ = debruijn_types_decoded :=
		      ty :: (!debruijn_types_decoded)
		    val _ = debruijn_types_so_far := (!debruijn_types_so_far)+1
*)
a1598 5
(*
		  ((Lists.nth(!debruijn_types_so_far - i, 
			       !debruijn_types_decoded)),
		   ptr)
*)
a1610 9
(*
	      val r = ref dummy_valenv
	      val _ = valenvs_decoded := r :: (!valenvs_decoded)
	      val _ = valenvs_so_far := (!valenvs_so_far)+1
	      val (valenv, ptr) =
		input_newmap(s, decode_valid, decode_typescheme, ptr, Environ.valid_order)
	      val valenv = Datatypes.VE(ref 0, valenv)
	      val _ = r := valenv
*)
a1621 3
(*
	    (!(Lists.nth(!valenvs_so_far-n, !valenvs_decoded)), ptr)
*)
a1650 1
(*
a1653 7
		  in
		    tyname_valenvs_decoded := valenv :: (!tyname_valenvs_decoded);
		    tyname_valenvs_so_far := (!tyname_valenvs_so_far)+1;
*)
		    val (mapping, ptr) =
		      input_newmap(s, decode_valid, decode_dummy_scheme, ptr, Environ.valid_order)
		    val valenv = Datatypes.VE(ref 0, mapping)
a1661 3
(*
		  (ref (Lists.nth(!tyname_valenvs_so_far-n, !tyname_valenvs_decoded)), ptr)
*)
a1678 11
(*
		    val (tyname_id, ptr) = decode_tyname_id ptr
		    val (st, ptr) = decode_string ptr
		    val (i, ptr) = input_opt_int(s, ptr)
		    val (b, ptr) = decode_bool ptr
		    val (valenv, ptr) = decode_tyname_valenv ptr
		    val tyname =
		      Datatypes.TYNAME(tyname_id, st, i, ref b, valenv)
		    val _ = tynames_decoded := ty :: !tynames_decoded
		    val _ = tynames_so_far := !tynames_so_far + 1
*)
a1693 3
(*
		  (Lists.nth(!tynames_so_far - n, !tynames_decoded), ptr)
*)
a1911 3
(*
    | Lists.Nth => raise TypeDecapError
*)
d2548 1
a2667 3
(*
	  val arg = (n, t)
*)
a2873 4
(*
      val _ = output(std_out, "total_strings = " ^
		     Integer.makestring(!total_strings) ^ "\n")
*)
@


1.66
log
@Converted all instances to Lists.nth to use hash tables
@
text
@d4 3
d2239 1
a2239 1
     type_basis, debug_info, require_list, consistency} =
@


1.65
log
@Changed encapsulation format to include number of strings found.
Should improve input speed
@
text
@d4 4
d443 110
d1355 11
d1384 1
d1390 7
d1398 1
d1400 2
d1404 2
d1407 1
d1483 1
d1503 16
d1526 1
d1536 8
d1545 1
d1548 2
d1552 3
d1558 1
d1566 1
d1572 8
d1584 1
d1586 2
d1595 1
d1608 11
d1620 1
d1623 2
d1627 1
d1631 2
d1640 1
d1650 8
d1659 1
d1662 2
d1666 1
d1670 2
d1697 1
d1706 7
d1714 1
d1717 2
d1721 1
d1725 2
d1738 1
d1742 4
d1750 1
d1754 2
d1761 1
a1761 1
      and decode_refvalenv ptr =
d1767 1
d1773 9
a1781 1
	      val _ = r := Datatypes.VE(ref 0, valenv)
d1783 1
a1783 1
	      (r, ptr)
d1786 4
a1789 1
	    (Lists.nth(!valenvs_so_far-n, !valenvs_decoded), ptr)
d1809 1
a1809 1
		val (ref ve, ptr) = decode_refvalenv ptr
d1819 1
d1826 9
d1838 1
d1840 3
d1858 1
d1864 2
a1865 2
		    val ty = Datatypes.TYNAME(tyname_id, st, i, ref b,
					      valenv)
d1868 11
d1880 1
a1880 1
		    (ty, ptr)
d1883 2
d1886 1
d1920 1
a1920 1
	  val (valenv, ptr) = decode_refvalenv ptr
d1922 1
a1922 1
	  (Datatypes.TYSTR(tyfun, !valenv), ptr)
d1937 2
a1938 2
	  val (valenv, ptr) = decode_refvalenv ptr
	  val (exnenv, ptr) = decode_refvalenv ptr
d1940 1
a1940 1
	  (Datatypes.ENV(strenv, tyenv, !valenv, !exnenv), ptr)
d2105 1
d2107 1
d3072 1
d3075 1
@


1.64
log
@Took out some unnecessary diagnostic output.
@
text
@d4 3
d509 1
d511 2
d523 2
d526 1
d531 1
d533 2
d2005 1
d2008 1
a2008 1
	val encodeId = ref 1
d2784 1
a2784 1
	(!fpos, (write_dummies 5; write_int tynames; write_int strnames; write_int tyfuns), !fpos)
d2790 2
d2799 2
d2804 1
a2804 1
  val header_size = 40
d2818 1
d2822 3
a2824 2
	  {cons_size = cons_size, parser_size = parser_size, type_size = type_size,
	   lambda_size = lambda_size, tynames = tynames, strnames = strnames, tyfuns = tyfuns}
a2875 2
      val _ = stringMap := StringHashTable.new()
      val _ = stringId := 1
d2880 1
a2880 1
	   lambda_size, tynames, strnames, tyfuns} =
d2882 2
@


1.63
log
@Rationalisation of the MLWorks structure.
@
text
@d4 3
d2779 1
a2779 1
      write_int (code_start); output(std_out, "\nCode size: " ^ Integer.makestring (code_end - code_start));
d2781 3
a2783 3
      write_int (parser_end - parser_start); output(std_out, "\nParser size: " ^ Integer.makestring (parser_end - parser_start));
      write_int (ty_end     - ty_start); output(std_out, "\nType size: " ^ Integer.makestring (ty_end - ty_start));
      write_int (lambda_end - lambda_start); output(std_out, "\nLambda size: " ^ Integer.makestring (lambda_end - lambda_start));
@


1.62
log
@Removed some of the large lists that were being built
during encapsulation. Changed some sharing constraints.
@
text
@d4 4
d313 2
a314 2
    Environ.EnvironTypes.LambdaTypes.Datatypes =
    Enc_Sub.DataTypes = Debugger_Types.Datatypes = Environ.Interface.Datatypes
d1941 4
a1944 4
      val file_handle = MLWorks.FileIO.openf filename
      val close = MLWorks.FileIO.closef
      val write = MLWorks.FileIO.writef
      fun seek pos = MLWorks.FileIO.seekf(file_handle, pos, MLWorks.FileIO.BEG)
@


1.61
log
@Removed some redundant structures and sharing
@
text
@a307 1
    (*Environ.EnvironTypes.Ident = Basis.Tyvarenv.Datatypes.Ident*)
d311 1
a311 2
  sharing (*Debugger_Types.Map = Environ.EnvironTypes.NewMap = *)
    Basis.Tyvarenv.Datatypes.NewMap = ParserEnv.Map
a313 1
  
d347 10
d465 3
a467 3
	val x = MLWorks.Bits.lshift(String.ordof(s, ptr    )    , 8)
	val y = MLWorks.Bits.lshift(String.ordof(s, ptr + 1) + x, 8)
	val z = MLWorks.Bits.lshift(String.ordof(s, ptr + 2) + y, 8)
d480 1
a480 1
	  (MLWorks.Bits.lshift(String.ordof(s, ptr + 1), 8) + String.ordof(s, ptr + 2), ptr + 3)
d499 1
a499 2
  val emptyStringMap = (NewMap.empty' (op <)) : (int, string) NewMap.T
  val stringMap = ref emptyStringMap
d508 1
d510 2
a511 2
	  stringMap := NewMap.define(!stringMap, !stringId, str);
	  stringId := !stringId + 1;
d515 1
a515 1
	(NewMap.apply'(!stringMap, id), ptr)
a570 8
  fun rev_map done f x =
    let
      fun rev_sub(done, []) = done
      | rev_sub(done, x :: xs) = rev_sub(f(done, x), xs)
    in
      rev_sub(done, x)
    end

a577 10
  fun encode_index'(done, EnvironTypes.FIELD{index=index, ...}) =
    optimised_output_int index :: optimised_output_int 0 :: done
    | encode_index'(done, EnvironTypes.PRIM x) =
      optimised_output_int (Pervasives.encode x) :: optimised_output_int 1 :: done
    | encode_index' _ = Crash.impossible"encode_index' not FIELD OR PRIM"

  fun encode_index(done, EnvironTypes.FIELD{index=index, ...}) =
    optimised_output_int index :: done
    | encode_index _ = Crash.impossible"encode_index not FIELD"

a584 16
  fun encode_valid'(done, Ident.VAR sy) =
    encode_symbol(done, sy)
  | encode_valid'(done, Ident.CON sy) =
    encode_symbol(done, sy)
  | encode_valid'(done, Ident.EXCON sy) =
    encode_symbol(done, sy)

  fun encode_funid(done, Ident.FUNID funid) =
    encode_symbol(done, funid)

  fun encode_sigid(done, Ident.SIGID sigid) =
    encode_symbol(done, sigid)

  fun encode_strid(done, Ident.STRID strid) =
    encode_symbol(done, strid)

a587 3
  fun encode_tycon(done, Ident.TYCON tycon) =
    encode_symbol(done, tycon)

d595 7
a601 3
(*
  fun encode_tyfun_id n = optimised_output_int(Tyfun_id.tyfun_id n)
*)
a602 5
  fun encode_list done f x =
    (
     rev_map (optimised_output_int(Lists.length x) :: done) f x
     )

d605 6
a610 4
  fun encode_triple f g h (done, (a, b,c)) = h(g(f(done, a), b),c)

  fun encode_newmap done f g x =
    encode_list done (encode_pair f g) (NewMap.to_list x)
d612 6
a617 2
  fun encode_map done f g x =
    encode_list done (encode_pair f g) (Map.assoc x)
d676 1
a676 1
	    (case input_opt_int(s, ptr) of
d938 1
a938 434
  fun encode_type_basis(Basis.BASIS(nameset, funenv, sigenv, env),
                        debug_information,
			sub_modules) =
    let
      val tynamehashtable = Enc_Sub.TynameHashTable.new()
      val funtypehashtable = Enc_Sub.FuntypeHashTable.new()
      val constypehashtable = Enc_Sub.ConstypeHashTable.new()
      val rectypehashtable = Enc_Sub.RectypeHashTable.new()
      val valenvhashtable = Enc_Sub.ValenvHashTable.new()


      fun gaps (tyname_id:int,_,nil) = tyname_id
      | gaps (tyname_id,last,("",tyname_count,_,_)::rest) =
	gaps (tyname_id + last - tyname_count,tyname_count,rest)
      | gaps (tyname_id,_,(_,tyname_count,_,_)::rest) =
	gaps (tyname_id,tyname_count,rest)

      fun tyname_module (n : int) =
	let
	  fun search nil = Crash.impossible ("tyname_module")
	  | search ((module,tyname_count,_,_)::rest) = 
	    if n < tyname_count 
	      then
	    search rest
	    else
	      (module,tyname_count,rest)
	  val (module,tyname_count,rest) = search sub_modules
	in
	  (module,
	   case module of
	     "" =>
	       gaps (n - tyname_count,tyname_count,rest)
	   | _ => 
	       n - tyname_count)
	end

      fun gaps (strname_id:int,_,nil) = strname_id
      | gaps (strname_id,last,("",_,strname_count,_)::rest) =
	gaps (strname_id + last - strname_count,strname_count,rest)
      | gaps (strname_id,_,(_,_,strname_count,_)::rest) =
	gaps (strname_id,strname_count,rest)

      fun strname_module (n : int) =
	let
	  fun search nil = Crash.impossible ("strname_module")
	  | search ((module,_,strname_count,_)::rest) = 
	    if n < strname_count 
	      then
		search rest
	    else
	      (module,strname_count,rest)
	  val (module,strname_count,rest) = search sub_modules
	in
	  (module,
	   case module of
	     "" =>
	       gaps (n - strname_count,strname_count,rest)
	   | _ =>
	       n - strname_count)
	end

      fun gaps (tyfun_id:int,_,nil) = tyfun_id
      | gaps (tyfun_id,last,("",_,_,tyfun_count)::rest) =
	gaps (tyfun_id + last - tyfun_count,tyfun_count,rest)
      | gaps (tyfun_id,_,(_,_,_,tyfun_count)::rest) =
	gaps (tyfun_id,tyfun_count,rest)

      fun tyfun_module (n : int) =
	let
	  fun search nil = Crash.impossible ("tyfun_module")
	  | search ((module,_,_,tyfun_count)::rest) = 
	    if n < tyfun_count 
	      then
		search rest
	    else
	      (module,tyfun_count,rest)
	  val (module,tyfun_count,rest) = search sub_modules
	in
	  (module,
	   case module of
	     "" =>
	       gaps (n - tyfun_count,tyfun_count,rest)
	   | _ =>
	       n - tyfun_count)
	end

      val tynames_encoded = ref [] : Tyname_id.Tyname_id list ref
      val strnames_encoded = ref [] : Datatypes.Strname ref list ref
      val valenv_no = ref 0
      val metatyvar_types_encoded =
	ref [] : ((int * Datatypes.Type) ref * bool * bool) list ref
      val meta_overloaded_types_encoded = ref [] : Datatypes.Type ref list ref
      val tyvar_types_encoded = ref [] : (int * Ident.TyVar) list ref
      val metarectype_types_encoded =
	ref [] : (int * bool * Datatypes.Type * bool * bool) ref list ref
      val rectype_types_encoded =
	ref [] : Datatypes.Type list ref
      val funtype_types_encoded =
	ref [] : (Datatypes.Type * Datatypes.Type) list ref
      val constype_types_encoded = ref [] : Datatypes.Type list ref
      val debruijn_types_encoded = ref [] : (int * bool * bool) list ref
      val meta_tynames_encoded = ref [] : Datatypes.Tyname list ref
      val tyname_valenvs_encoded =
	ref [] : int ref list ref
      val meta_tyname_count = ref 0
      val tyname_count = ref 0
      val valenv_tyname_count = ref 0
      val funtype_count = ref 0
      val constype_count = ref 0
      val rectype_count = ref 0

      fun encode_tyname_id (done, n) =
	let
	  val id = Tyname_id.tyname_id n
	in	
	  if id < Types.pervasive_tyname_count
	    then
	      optimised_output_int id :: output_byte 0 :: done
	  else
	    let
	      val (module,id') = tyname_module id
	    in
	      if module = "" 
		then
		  optimised_output_int id' :: output_byte 1 :: done
	      else
		optimised_output_int id' :: encode_string (output_byte 2 :: done, module)
	    end
	end

      fun encode_strname_id (done, n) =
	let
	  val id = Strname_id.strname_id n
	in	
	  if id < Strenv.pervasive_strname_count
	    then
	      optimised_output_int id :: output_byte 0 :: done
	  else
	    let
	      val (module,id') = strname_module id
	    in
	      if module = "" 
		then
		  optimised_output_int id' :: output_byte 1 :: done
	      else
		optimised_output_int id' :: encode_string (output_byte 2 :: done, module)
	    end
	end

      fun encode_tyfun_id (done, n) =
	let
	  val id = Tyfun_id.tyfun_id n
	in	
	  if id < Types.pervasive_tyfun_count
	    then
	      optimised_output_int id :: output_byte 0 :: done
	  else
	    let
	      val (module,id') = tyfun_module id
	    in
	      if module = "" then
		optimised_output_int id' :: output_byte 1 :: done
	      else
		optimised_output_int id' :: encode_string (output_byte 2 :: done, module)
	    end
	end

      fun encode_strname(done, Datatypes.STRNAME s) =
	 encode_strname_id (output_byte 1 :: done, s)
      | encode_strname(done, Datatypes.METASTRNAME s) =
	let
	  fun es' (h::t) =
	    if h = s then Lists.length t + 1
	    else es' t
	  | es' [] = 
	    (strnames_encoded := (s::(!strnames_encoded)); 0)
	  val n = es'(!strnames_encoded)
	  val done = optimised_output_int n :: output_byte 2 :: done
	in
	  if n = 0 then
	    encode_strname (done, !s)
	  else done
	end

      | encode_strname(done, Datatypes.NULLNAME s) =
	encode_strname_id (output_byte 3 :: done, s)

      fun encode_fun_or_cons(done, scheme) =
	case Enc_Sub.type_from_scheme scheme of
	  Datatypes.CONSTYPE _ => output_byte 1 :: done
	| Datatypes.FUNTYPE _ => output_byte 2 :: done
	| _ => Crash.impossible"encode_fun_or_cons"

      fun encode_tyname_valenv(done, valenv as Datatypes.VE(r, M)) =
	let
	  val n = !r
	in
	  if n = 0 then
	    let
	      val pos =
		(Enc_Sub.ValenvHashTable.lookup (valenvhashtable,valenv))
		handle (Enc_Sub.ValenvHashTable.Lookup _) => 0
	      val done = optimised_output_int pos :: output_byte 2 :: done
	    in
	      if pos = 0 then
		let
		  val c = !valenv_tyname_count + 1
		  val _ = valenv_tyname_count := c
		  val _ = Enc_Sub.ValenvHashTable.update(valenvhashtable,valenv, c)
		in
		  encode_newmap done encode_valid encode_fun_or_cons M
		end
	      else
		done
	    end
	  else
	    optimised_output_int n :: output_byte 1 :: done
	end

      fun encode_valenv(done, Datatypes.VE(r, M)) =
	let
	  val n = !r
	  val done = optimised_output_int n :: done
	in
	  if n = 0 then
	    let
	      val m = !valenv_no + 1
	    in
	      (valenv_no := m;
	       r := m;
	       encode_newmap done encode_valid encode_typescheme M)
	    end
	  else done
	end

      and encode_tyname(done, Datatypes.TYNAME(ti, s, n, ref b, ref ve)) =
	let
	  val _ = tyname_count := !tyname_count + 1
	  fun et'(h::t) = if h = ti then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (tynames_encoded := (ti::(!tynames_encoded)); 0)
	  val pos = et'(!tynames_encoded)
	  val done = optimised_output_int pos :: output_byte 1 :: done
	in
	  if pos = 0 then
	    encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
				 encode_string(encode_tyname_id(done, ti), s),
				 ve)
	  else
	    done
	end

      | encode_tyname(done,
		      tyn as Datatypes.METATYNAME(ref tf, s, n, ref b,
						  ref ve)) =
	let
	  val pos =
	    (Enc_Sub.TynameHashTable.lookup (tynamehashtable,tyn))
	    handle (Enc_Sub.TynameHashTable.Lookup _) => 0
	  val done = optimised_output_int pos :: output_byte 2 :: done
	in
	  if pos = 0 then
	    let
	      val c = !meta_tyname_count + 1
	      val _ = meta_tyname_count := c
	      val _ = Enc_Sub.TynameHashTable.update(tynamehashtable,tyn, c)
	    in
	      encode_tyname_valenv(encode_bool b :: optimised_output_int n ::
				   encode_string(encode_tyfun(done, tf), s),
				   ve)
	    end
	  else
	    done
	end

      and encode_type(done,
		      Datatypes.METATYVAR(arg as (ref(n, t), b1, b2))) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (metatyvar_types_encoded := (arg::(!metatyvar_types_encoded)); 0)
	  val pos = et'(!metatyvar_types_encoded)
	  val done = optimised_output_int pos :: output_byte 1 :: done
	in
	  if pos = 0 then
	    encode_bool b2 :: encode_bool b1 ::
	    encode_type(optimised_output_int n :: done, t)
	  else
	    done
	end
      | encode_type(done, Datatypes.META_OVERLOADED(arg as ref t)) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (meta_overloaded_types_encoded :=
	     (arg::(!meta_overloaded_types_encoded)); 0)
	  val pos = et'(!meta_overloaded_types_encoded)
	  val done = optimised_output_int pos :: output_byte 2 :: done
	in
	  if pos = 0 then
	    encode_type(done, t)
	  else
	    done
	end
      | encode_type(done, Datatypes.TYVAR(ref n, t)) =
	let
(*
	  val arg = (n, t)
*)
	  fun et'((n', t')::tl) =
	    if (*h = arg*) n = n' andalso t =  t' then
	      Lists.length tl + 1
	    else et' tl
	  | et' [] =
	    (tyvar_types_encoded := ((n, t)::(!tyvar_types_encoded)); 0)
	  val pos = et'(!tyvar_types_encoded)
	  val done = optimised_output_int pos :: output_byte 3 :: done
	in
	  if pos = 0 then
	    encode_tyvar(optimised_output_int n :: done, t)
	  else
	    done
	end	  
      | encode_type(done,
		    Datatypes.METARECTYPE(arg as ref(n, b1, t, b2, b3))) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (metarectype_types_encoded :=
	     (arg::(!metarectype_types_encoded)); 0)
	  val pos = et'(!metarectype_types_encoded)
	  val done = optimised_output_int pos :: output_byte 4 :: done
	in
	  if pos = 0 then
	    encode_bool b3 :: encode_bool b2 ::
	    encode_type(encode_bool b1 :: optimised_output_int n :: done, t)
	  else
	    done
	end
      | encode_type(done, arg as Datatypes.RECTYPE M) =
	let
	  val pos =
	    Enc_Sub.RectypeHashTable.lookup (rectypehashtable,arg)
	    handle Enc_Sub.RectypeHashTable.Lookup _ => 0
	  val done = optimised_output_int pos :: output_byte 5 :: done
	in
	  if pos = 0 then
	    let
	      val c = !rectype_count + 1
	      val _ = rectype_count := c
	      val _ = Enc_Sub.RectypeHashTable.update(rectypehashtable,arg, c)
	    in
	      encode_map done encode_lab encode_type M
	    end
	  else
	    done
	end
      | encode_type(done, full_arg as Datatypes.FUNTYPE(arg as (t1, t2))) =
	let
	  val pos =
	    Enc_Sub.FuntypeHashTable.lookup (funtypehashtable,full_arg)
	    handle Enc_Sub.FuntypeHashTable.Lookup _ => 0
	  val done = optimised_output_int pos :: output_byte 6 :: done
	in
	  if pos = 0 then
	    let
	      val c = !funtype_count + 1
	      val _ = funtype_count := c
	      val _ = Enc_Sub.FuntypeHashTable.update(funtypehashtable,full_arg, c)
	    in
	      encode_type(encode_type(done, t1), t2)
	    end
	  else
	    done
	end
      | encode_type(done, arg as Datatypes.CONSTYPE(l, t)) =
	let
	  val pos =
	    Enc_Sub.ConstypeHashTable.lookup (constypehashtable,arg)
	    handle Enc_Sub.ConstypeHashTable.Lookup _ => 0
	  val done = optimised_output_int pos :: output_byte 7 :: done
	in
	  if pos = 0 then
	    let
	      val c = !constype_count + 1
	      val _ = constype_count := c
	      val _ = Enc_Sub.ConstypeHashTable.update(constypehashtable,arg, c)
	    in
	      encode_tyname(encode_list done encode_type l, t)
	    end
	  else
	    done
	end
      | encode_type(done, Datatypes.DEBRUIJN(arg as (n, b1, b2))) =
	let
	  fun et'(h::t) = if h = arg then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (debruijn_types_encoded := (arg::(!debruijn_types_encoded)); 0)
	  val pos = et'(!debruijn_types_encoded)
	  val done = optimised_output_int pos :: output_byte 8 :: done
	in
	  if pos = 0 then
	    encode_bool b2 :: encode_bool b1 :: optimised_output_int n :: done
	  else
	    done
	end	  
      | encode_type(done, Datatypes.NULLTYPE) = output_byte 9 ::
	done
	

      and encode_typescheme(done, Datatypes.SCHEME(n, t)) =
	encode_type(optimised_output_int n :: output_byte 1 :: done, t)
      | encode_typescheme(done, Datatypes.UNBOUND_SCHEME t) =
	encode_type(output_byte 2 :: done, t)
      | encode_typescheme(done, Datatypes.OVERLOADED_SCHEME ov) =
	encode_over_loaded ov :: output_byte 3 :: done

      and encode_tyfun(done, tyfun as Datatypes.TYFUN(t, n)) =
	optimised_output_int n :: encode_type(output_byte 1 :: done, t)
      | encode_tyfun(done, Datatypes.ETA_TYFUN tn) =
	encode_tyname(output_byte 2 :: done, tn)
      | encode_tyfun(done, Datatypes.NULL_TYFUN tfi) =
	encode_tyfun_id(output_byte 3 :: done, tfi)

      fun encode_tystr(done, Datatypes.TYSTR(tf, ve)) =
	encode_valenv(encode_tyfun(done, tf), ve)

      fun encode_tyenv(done, Datatypes.TE M) =
	encode_newmap done encode_tycon encode_tystr M
d940 1
a940 96
      fun encode_str(done, Datatypes.STR(sn, e)) =
	encode_env(encode_strname(done, sn), e)

      and encode_strenv(done, Datatypes.SE M) =
	encode_newmap done encode_strid encode_str M

      and encode_env(done, Datatypes.ENV(se, te, ve, ece)) =
	encode_valenv(encode_valenv(encode_tyenv(encode_strenv(done, se), te), ve), ece)

      fun encode_nameset(done, ns) =
	encode_list (encode_list done encode_tyname (Nameset.tynames_of_nameset ns))
	encode_strname (Nameset.strnames_of_nameset ns)

      fun encode_sigma(done, Sigma.SIGMA(ns, s)) =
	encode_str(encode_nameset(done, ns), s)

      fun encode_sigenv(done, Sigenv.SIGENV M) =
	encode_newmap done encode_sigid encode_sigma M

      fun encode_phi(done, Phi.PHI(ns, (s, sg))) =
	encode_sigma(encode_str(encode_nameset(done, ns), s), sg)

      fun encode_funenv(done, Funenv.FUNENV M) =
	encode_newmap done encode_funid encode_phi M

      fun encode_int(done,i) = optimised_output_int i :: done

      fun encode_recipe(done,value) = 
        (case value of
           Debugger_Types.Nop => (output_byte 0 :: done)
         | Debugger_Types.Select arg =>
             encode_pair encode_int encode_recipe (output_byte 1::done,arg)
         | Debugger_Types.MakeRecord args =>
             encode_list (output_byte 2::done) (encode_pair encode_string encode_recipe) args
         | Debugger_Types.Funarg arg =>
             encode_recipe (output_byte 3::done,arg)
         | Debugger_Types.Funres arg =>
             encode_recipe (output_byte 4::done,arg)
         | Debugger_Types.MakeFunType arg =>
             encode_pair encode_recipe encode_recipe (output_byte 5::done,arg)
         | Debugger_Types.DeCons arg =>
             encode_pair encode_int encode_recipe (output_byte 6 :: done,arg)
        | Debugger_Types.MakeConsType arg =>
            encode_pair 
            (fn (done,x) => encode_list done encode_recipe x)
            encode_tyname
            (output_byte 7::done,arg)
        | Debugger_Types.Error => (output_byte 8 :: done))

      fun encode_debug(done,stuff) = 
        encode_newmap
        done
        encode_string
        (encode_triple
         encode_type
         (fn (done,x) => encode_bool x ::  done)
         (fn (done,x) => encode_list done (encode_pair encode_int encode_recipe) x))
        stuff

       val result =
	Timer.xtime
	("encode_nameset", !do_timings, fn () => encode_nameset([], nameset))
      val _ = diagnose_counts"nameset encoded\n"
      val result =
	Timer.xtime
	("encode_funenv", !do_timings, fn () => encode_funenv(result, funenv))
      val _ = diagnose_counts"funenv encoded\n"
      val result =
	Timer.xtime
	("encode_sigenv", !do_timings, fn () => encode_sigenv(result, sigenv))
      val _ = diagnose_counts"sigenv encoded\n"
      val result =
	Timer.xtime
	("encode_env", !do_timings, fn () => encode_env(result, env))

      val result = 
	Timer.xtime
	("encode debug info", !do_timings, fn () => encode_debug(result, debug_information))

      val _ = if !print_hash_table_stats then
	(output(std_out,"Tynamehashtable in _encapsulate: " ^
		Enc_Sub.TynameHashTable.string_hash_table_stats(tynamehashtable) ^ "\n");
	 output(std_out,"FunTypehashtable in _encapsulate: " ^
		Enc_Sub.FuntypeHashTable.string_hash_table_stats(funtypehashtable) ^ "\n");
	 output(std_out,"ConsTypehashtable in _encapsulate: " ^
		Enc_Sub.ConstypeHashTable.string_hash_table_stats(constypehashtable) ^ "\n");
	 output(std_out,"RecTypehashtable in _encapsulate: " ^
		Enc_Sub.RectypeHashTable.string_hash_table_stats(rectypehashtable) ^ "\n");
	 output(std_out,"Valenvhashtable in _encapsulate: " ^
		Enc_Sub.ValenvHashTable.string_hash_table_stats(valenvhashtable) ^ "\n"))
	      else ()
    in
      result
    end

  fun decode_type_basis (s, sub_modules) =
d1804 8
a1811 1
    end
d1949 4
a1952 4
	  val b1 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i, 24), 255)
	  val b2 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i, 16), 255)
	  val b3 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i,  8), 255)
	  val b4 = MLWorks.Bits.andb(i, 255)
d1965 2
a1966 2
	   write_byte (MLWorks.Bits.andb(MLWorks.Bits.rshift(i, 8), 255));
	   write_byte(MLWorks.Bits.andb(i, 255)))
d1968 1
a1968 2
	  (write_byte 255;
	   write_int i)
d1976 1
a1976 1
	 case MLWorks.Bits.andb(size s, 3) of
d2006 3
d2030 3
d2046 7
d2062 13
a2159 8

	  val _ =
	    Timer.xtime
	    ("outputting parser env", !do_timings,
	     fn () =>
	     (write_newmap write_funid write_pe fun_map;
	      write_newmap write_sigid write_pe sig_map;
	      write_pe parse_env))
d2161 6
a2166 1
	  ()
d2169 1
a2169 1
      fun encode_lambda_env(EnvironTypes.TOP_ENV(env as EnvironTypes.ENV(v, e, s), EnvironTypes.FUN_ENV fun_env)) =
d2186 1
a2186 1
	  fun encode_sub extra (done, EnvironTypes.ENV(v_map, e_map, s_map)) =
a2200 3
		    val _ = valsize := newsize
		    val _ = LambdaValHashTable.update(lambdavalhashtable,
						      v_list, newsize)
d2202 2
d2206 1
a2206 4
	      val done = optimised_output_int vnum :: optimised_output_int env_len :: done
	      val encoded_v_list = case vnum of
		0 => encode_list done (encode_pair encode_valid' encode_index') v_list
	      | n => done
a2211 3
		    val _ = exnsize := newsize
		    val _ = LambdaValHashTable.update(lambdaexnhashtable,
						      e_list, newsize)
d2213 2
a2216 8
	      val done = optimised_output_int enum :: encoded_v_list
	      val encoded_e_list = case enum of
		0 =>
		  encode_list
		  done
		  (encode_pair encode_valid' encode_index')
		  e_list
	      | n => done
d2218 6
a2223 3
	      encode_newmap encoded_e_list encode_strid
	      (encode_pair (encode_sub 0) encode_index')
	      s_map
d2226 1
a2226 1
	  fun encode_interface(done, Interface.INT(Interface.INTENV s_map, v_list, e_list)) =
a2231 3
		    val _ = intvalsize := newsize
		    val _ = IntHashTable.update(intvalhashtable,
						v_list, newsize)
d2233 2
d2237 1
a2237 4
	      val done = optimised_output_int vnum :: done
	      val done = case vnum of
		0 => encode_list done encode_valid' v_list
	      | n => done
a2241 3
		    val _ = intexnsize := newsize
		    val _ = IntHashTable.update(intexnhashtable,
						e_list, newsize)
d2243 2
a2246 4
	      val done = optimised_output_int enum :: done
	      val done = case enum of
		0 => encode_list done encode_valid' e_list
	      | n => done
d2248 5
a2252 1
	      encode_newmap done encode_strid encode_interface s_map
d2255 2
a2256 2
	  fun do_ftr_range(done, (field, interface, env)) =
	    encode_sub 0 (encode_interface(encode_index(done, field), interface), env)
d2258 1
a2258 1
	  val result = 
d2260 377
a2636 11
	    ("building lambda env", !do_timings, fn () =>
	    (encode_sub f_len
	     (encode_newmap [optimised_output_int(f_len + env_len)] encode_funid
	      do_ftr_range fun_env, env)))

	  val _ = if !print_hash_table_stats
		    then (output(std_out,"lambdavalhashtable in _encapsulate: "^
				 LambdaValHashTable.string_hash_table_stats(lambdavalhashtable) ^ "\n");
			  output(std_out,"lambdaexnhashtable in _encapsulate: "^
				 LambdaValHashTable.string_hash_table_stats(lambdaexnhashtable) ^ "\n"))
		  else ()
d2638 10
a2647 1
	  result
d2649 33
d2683 75
d2764 1
a2764 1
	(!fpos, (write_dummies 6; write_int tynames; write_int strnames; write_int tyfuns), !fpos)
d2767 2
a2768 5
      val (lambda_start, _, lambda_end) = (!fpos, Timer.xtime ("outputting lambda env", !do_timings,
         fn () => do_output(encode_lambda_env lambda_env)), !fpos)
      val (ty_start, _, ty_end) = (!fpos, Timer.xtime ("outputting type env", !do_timings,
         fn () => do_output(encode_type_basis (type_basis, debug_info, require_list))), !fpos)
      val (debug_start, _, debug_end) = (!fpos, (), !fpos)
d2772 1
a2772 1
      write_int (code_start);
d2774 3
a2776 4
      write_int (parser_end - parser_start);
      write_int (ty_end     - ty_start);
      write_int (lambda_end - lambda_start);
      write_int (debug_end  - debug_start);
d2780 1
a2780 1
  val header_size = 44
a2790 1
      val (debug_size,  ptr) = input_int(header, ptr)
d2797 2
a2798 3
	  {cons_size = cons_size, debug_size = debug_size,
	   parser_size = parser_size, type_size = type_size, lambda_size = lambda_size,
	   tynames = tynames, strnames = strnames, tyfuns = tyfuns}
d2834 1
d2850 1
a2850 1
      val _ = stringMap := emptyStringMap
d2855 1
a2855 1
	  {cons_size, debug_size, parser_size, type_size,
d2874 1
@


1.60
log
@Added details about leafness to the debug information
@
text
@d4 3
d307 2
a308 2
  sharing ParserEnv.Ident = Environ.Interface.Datatypes.Ident =
    Environ.EnvironTypes.Ident = Basis.Tyvarenv.Datatypes.Ident
d310 1
d312 1
a312 1
  sharing Debugger_Types.Map = Environ.EnvironTypes.NewMap =
d337 1
a337 1
  structure NewMap = Debugger_Types.Map 
@


1.59
log
@Added various optimisations, the most important of which being the
compression of identical strings, which results in very large
(up to 40% or 50%) reductions in the size of mo files.
@
text
@d4 5
d515 9
d632 2
d1447 3
a1449 1
        (encode_pair encode_type
d2323 4
a2326 1
            (input_pair decode_type (fn ptr => input_list(s, input_pair decode_int decode_recipe, ptr))),
@


1.58
log
@Fixed up changes since parserenv now uses NewMap. The exception BadInput
now includes the filename as part of the error messages.
@
text
@d4 4
d414 5
a418 2
    IMPLODE of int * DelayedEvaluation list
  | STRING of string
a419 3
  fun get_length(STRING x) = size x
    | get_length(IMPLODE(x,_)) = x
      
a421 8
  fun make_implode x =
    let
      fun add_lengths([],acc) = acc
        | add_lengths(h::t,acc) = add_lengths(t,get_length(h)+acc)
    in
      IMPLODE(add_lengths(x,0),x)
    end

d438 1
a438 1
  | string_list_sub(n, str :: rest) = string_list_sub(n + size str, rest)
d442 3
a444 3
  fun output_byte i =
    if i < 0 orelse i > 255 then Crash.impossible"Bad byte size"
    else STRING(chr i)
a445 11
  fun make_int i =
    let
      val b1 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i, 24), 255)
      val b2 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i, 16), 255)
      val b3 = MLWorks.Bits.andb(MLWorks.Bits.rshift(i,  8), 255)
      val b4 = MLWorks.Bits.andb(i, 255)
    in
      if i < 0 then Crash.impossible"Cannot encapsulate negative size"
      else implode [chr b1, chr b2, chr b3, chr b4]
    end

a446 8
    val one_byte_max = 254
    val two_byte_max = 65535

    val two_word_tag     = 254
    val two_word_tag_ch  = chr 254
    val four_word_tag    = 255
    val four_word_tag_ch = chr 255

d448 7
a454 2
      String.ordof(s, ptr + 3) + 256 * (String.ordof(s, ptr + 2) +
      256 * (String.ordof(s, ptr + 1) + 256 * String.ordof(s, ptr)))
a455 9
    fun output_int i = STRING(make_int i)

    fun optimised_output_int(x) =
      if x < one_byte_max then STRING(chr x)
      else if x < two_byte_max then
	STRING(two_word_tag_ch ^ chr(MLWorks.Bits.rshift(x, 8)) ^ chr(MLWorks.Bits.andb(x, 255)))
      else
	STRING(four_word_tag_ch ^ make_int x)

d463 1
a463 1
	if tag = two_word_tag then
d465 1
a465 1
	else if tag = four_word_tag then
d475 1
a475 1
  fun input_string (s, ptr) =
d478 11
a488 1
      val str = String.substring(s, ptr, sz)
d490 10
a499 1
      (str, ptr + sz)
a539 27
      
  fun extra_string i =
    case i mod 4 of
      0 => "\000   "
    | 1 => "\000  "
    | 2 => "\000 "
    | 3 => "\000"
    | _ => Crash.impossible"Mod out of range"

  fun extend_string s = s ^ extra_string(size s)

  fun extend_string_list l = extra_string(string_list_size l) :: l

  fun delayed_extend_string s = make_concat(s,extra_string(size s))

  fun delayed_string_list_size(STRING x,acc) = size x + acc
    | delayed_string_list_size(IMPLODE (len,x),acc) = len + acc
  and delayed_list_string_list_size([],acc) = acc
    | delayed_list_string_list_size(h::t,acc) = delayed_list_string_list_size(t,delayed_string_list_size(h,acc))

  fun delayed_extend_string_list l =
    let
      val s = delayed_list_string_list_size (l,0)
      val extra = extra_string(s)
    in
      IMPLODE(size extra + s,rev(STRING(extra) :: l))
    end
d542 3
a544 4
  | count_real_objects(count, MachTypes.WORDSET(MachTypes.WORD_SET w_list) ::
			 rest) =
    count_real_objects(count + Lists.length w_list, rest)
  | count_real_objects(count, _ :: rest) = count_real_objects(count + 1, rest)
d554 2
a555 5
  fun encode_bool false = STRING(chr 0)
    | encode_bool true = STRING(chr 1)

  fun encode_string(done, s) =
    STRING(s) :: optimised_output_int(size s) :: done
d557 1
d559 1
a559 6
  fun encode_symbol(done, sy) =
    let
      val sy = Symbol.symbol_name sy
    in
      encode_string(done, sy)
    end
d643 1
a643 1
	  val (str, ptr) = input_string(s, ptr)
d804 1
a804 2
	  val (sy_size, ptr) = input_opt_int(s, ptr)
	  val sy = Symbol.find_symbol(String.substring(s, ptr, sy_size))
d806 1
a806 1
	  (sy, ptr + sy_size)
a1110 5
	(
(*
	 strnames := !strnames + 1;
	 diagnose_calls("encode_strname done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
a1111 1
	 )
a1113 4
(*
	  val _ = diagnose_calls("encode_strname done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = strnames := !strnames + 1;
*)
a1454 4
      val result =
	delayed_extend_string_list result


d1502 1
a1502 1
	input_string(s, ptr)
d1506 1
a1506 1
	  val (sy, ptr) = input_string(s, ptr)
a1585 3
(*
		val _ = diagnose_calls("Decoding local tyname_id as " ^ Integer.makestring(tyname_count+n) ^ "\n")
*)
a1595 3
(*
		val _ = diagnose_calls("Decoding external tyname_id in module '" ^ module ^ "' as " ^ Integer.makestring(tyname_count+n) ^ "\n")
*)
d2446 1
a2446 1
      fun decode_string ptr = input_string(s, ptr)
d2464 3
a2466 1
      fun incPos i = fpos := !fpos + i
d2468 1
a2468 1
      fun do_output object =
d2470 4
a2473 5
	  fun out([],[]) = ()
	    | out([],h::t) = out(h,t)
	    | out(STRING(x)::rest,rest') = 
	      (write(file_handle, x); incPos(size x); out(rest,rest'))
	    | out(IMPLODE(_,x)::rest,rest') = out(x,rest::rest')
d2475 1
a2475 1
	  out([object],[])
a2477 9
      fun write_byte i =
	if i < 0 orelse i > 255 then
	  Crash.impossible"Bad byte size"
	else
	  (write(file_handle, chr i); incPos 1)

      fun write_int i =
	(write(file_handle, make_int i); incPos 4)

d2481 10
a2490 2
      fun seek_write_int (pos, i) =
	(seek pos; write_int i; seek (!fpos))
d2493 1
a2493 1
	(write(file_handle, s); incPos (size s))
d2495 9
a2503 4
      fun write_opt_int i =
	if i < 254 then write_string(chr i)
	else if i < 65535 then write_string(chr(254) ^ chr(i div 256) ^ chr(i mod 256))
        else (write_byte(255); write_string(make_int i))
d2508 34
a2541 8
      fun write_extended_string s =
	(write(file_handle, s);
	 case (size s mod 4) of
	   0 => (write(file_handle, "\000   "); incPos(size s + 4))
	 | 1 => (write(file_handle, "\000  "); incPos(size s + 3))
	 | 2 => (write(file_handle, "\000 "); incPos(size s + 2))
	 | 3 => (write(file_handle, "\000"); incPos(size s + 1))
	 | _ => Crash.impossible"Mod out of range")
d2549 3
a2554 3
      fun write_symbol sy =
	write_sz_string(Symbol.symbol_name sy)

d2604 5
a2608 3
	  write_int (Lists.length element_list);
	  write_int (count_real_objects(0, element_list));
	  Lists.iterate output_module_element element_list
d2638 1
d2651 1
d2654 1
a2654 1
	      write_assoc write_strid write_pe (NewMap.to_list struct_map)
d2659 1
a2659 1
	    ("building parser env list", !do_timings,
d2661 2
a2662 2
	     (write_assoc write_funid write_pe (NewMap.to_list fun_map);
	      write_assoc write_sigid write_pe (NewMap.to_list sig_map);
d2665 1
a2665 4
	  if !print_hash_table_stats then
	    (output(std_out,"Valhashtable in _encapsulate:" ^ ValHashTable.string_hash_table_stats(valhashtable) ^ "\n");
	     output(std_out,"Fixhashtable in _encapsulate:" ^ FixHashTable.string_hash_table_stats(fixhashtable) ^ "\n"))
	  else ()
d2680 3
a2682 3
	  val v_len = Lists.length(NewMap.to_list v)
	  val e_len = Lists.length(NewMap.to_list e)
	  val s_len = Lists.length(NewMap.to_list s)
d2708 1
a2708 5
		0 =>
		  encode_list
		  done
		  (encode_pair encode_valid' encode_index')
		  v_list
d2770 1
a2770 2
	    encode_sub 0
	    (encode_interface(encode_index(done, field), interface), env)
d2773 2
a2774 1
	    delayed_extend_string_list
d2777 1
a2777 1
	      do_ftr_range fun_env, env))
d2798 4
a2801 6
      val the_ty_env = encode_type_basis (type_basis, debug_info, require_list)
      val the_lambda_env = encode_lambda_env lambda_env
      val t_size = delayed_string_list_size (the_ty_env,0)
      val l_size = delayed_string_list_size (the_lambda_env,0)
      val env_list = [the_ty_env, the_lambda_env]
      val (_, lambda_end) = (Lists.iterate do_output env_list, !fpos)
d2809 2
a2810 2
      write_int t_size;
      write_int l_size;
d2886 2
d2897 1
a2898 1
	   lambda_env  = decode_lambda_env(checked_input(file_handle, lambda_size)),
@


1.57
log
@Took out various exception handlers and put them all round the
top level function body, hence only building the handlers
once for each object file.
@
text
@d4 5
d255 1
a256 1
require "../utils/timer";
a260 1
require "../utils/newmap";
a294 1
  sharing ParserEnv.Map = Basis.Tyvarenv.Datatypes.Mapping
d300 1
a300 1
    Basis.Tyvarenv.Datatypes.NewMap
d323 1
a323 1
  structure Map = ParserEnv.Map 
d427 1
a427 1
  val CorruptFile = BadInput "Corrupted object file"
d447 13
a459 15
    if i < 0 orelse i > 255 then
      Crash.impossible"Bad byte size"
    else
      STRING(chr i)

  fun make_list(done, bytes, value) =
    if bytes <= 0 then done
    else
      make_list(chr(value mod 256) :: done, bytes-1, value div 256)

  fun normal_output_int i =
    if i < 0 then
      Crash.impossible"Negative size of code object"
    else
      implode(make_list([], 4, i))
d462 2
a463 6
    fun exp 0 = 1
      | exp x = 2 * exp (x-1)
    val two_words = 254
    val two_word_max = exp(16) - 1
    val two_word_tag = chr two_words
    val four_word_tag = chr 255
d465 5
d474 1
a474 1
    fun output_int i = STRING(normal_output_int i)
d477 3
a479 3
      if x < two_words then STRING(chr x)
      else if x < two_word_max then
	STRING(two_word_tag ^ chr(x div 256) ^ chr(x mod 256))
d481 1
a481 1
	STRING(implode(four_word_tag :: make_list([], 4, x)))
d488 1
a488 1
	val tag = String.substring(s,ptr,1)
d491 1
a491 1
	  (256 * String.ordof(s, ptr + 1) + String.ordof(s, ptr + 2), ptr + 3)
d495 1
a495 1
	  (ord tag, ptr + 1)
d839 1
a839 1
	(int, (Symbol.Symbol, ParserEnv.Fixity)Map.Map) NewMap.T ref
a921 9
      fun decode_map f g ptr eqfn orderfn =
	let
	  val (assoc_list, ptr) = decode_rev_list (input_pair f g) ptr
	in
	  (Lists.reducel
	   (fn (m, x) => Map.add(x, m, orderfn))
	   (Map.empty_eqfunmap eqfn, assoc_list), ptr)
	end
      
d930 1
a930 6
		  decode_map
		  decode_symbol
		  decode_fixity
		  ptr
		  Symbol.eq_symbol
		  Symbol.symbol_order
d941 2
d951 1
a951 3
		  decode_rev_list
		  decode_valid
		  ptr
d953 1
a953 3
		  Lists.reducel
		  (fn (pve, valid) => ParserEnv.addValId(valid, pve))
		  (ParserEnv.empty_pVE, val_env)
d971 1
a971 6
	    decode_map
	    decode_strid
	    read_parse_env
	    ptr
	    Ident.strid_eq
	    Ident.strid_order
d978 1
a978 1
	decode_map decode_funid read_parse_env 0 Ident.funid_eq Ident.funid_order
d980 1
a980 1
	decode_map decode_sigid read_parse_env ptr Ident.sigid_eq Ident.sigid_order
d2548 1
a2548 4
	if i < 0 then
	  Crash.impossible"Negative size of code object"
	else
	  (write(file_handle, implode(make_list([], 4, i))); incPos 4)
d2562 1
a2562 1
        else (write_byte(255); write_string(implode(make_list([], 4, i))))
d2658 1
a2658 1
	      val fix_list = Map.assoc fix_map
d2670 1
a2670 1
	      val val_list = Map.assoc val_map
d2683 1
a2683 1
	      write_assoc write_strid write_pe (Map.assoc struct_map)
d2690 2
a2691 2
	     (write_assoc write_funid write_pe (Map.assoc fun_map);
	      write_assoc write_sigid write_pe (Map.assoc sig_map);
d2890 1
d2892 18
a2909 14
      val header = checked_input(file_handle, header_size)
      val {cons_size, tynames, strnames, tyfuns, ...} = decode_header header
      val cons = checked_input(file_handle, cons_size)
    in
      close_in file_handle;
      {tynames = tynames, strnames = strnames, tyfuns = tyfuns,
       consistency = decode_cons cons}
    end handle
      Ord => raise CorruptFile
    | Io m => raise BadInput m
    | Lists.Nth => raise CorruptFile
    | String.Substring => raise CorruptFile
    | NewMap.Undefined => raise CorruptFile
    | Enc_Sub.DecFuntypeHashTable.Lookup _ => raise CorruptFile
d2921 1
d2923 1
a2923 10
      val
	{cons_size, debug_size, parser_size, type_size,
	 lambda_size, tynames, strnames, tyfuns} =
	decode_header(checked_input(file_handle, header_size))
      val result =
	{consistency = decode_cons(checked_input(file_handle, cons_size)),
	 parser_env  = decode_parser_env(checked_input(file_handle, parser_size)),
         type_env    = checked_input(file_handle, type_size),
	 lambda_env  = decode_lambda_env(checked_input(file_handle, lambda_size)),
	 tynames = tynames, strnames = strnames, tyfuns = tyfuns}
d2925 22
a2946 9
      close_in file_handle;
      result
    end handle
      Ord => raise CorruptFile
    | Io m => raise BadInput m
    | Lists.Nth => raise CorruptFile
    | String.Substring => raise CorruptFile
    | NewMap.Undefined => raise CorruptFile
    | Enc_Sub.DecFuntypeHashTable.Lookup _ => raise CorruptFile
@


1.56
log
@Implemented inputting of consistency info without requiring the
whole object file to be read.
@
text
@d4 4
a503 1
	handle String.Substring => raise CorruptFile
d738 13
a750 15
	    (case input_opt_int(s, ptr) of
	       (0, ptr) =>
		 let
		   val (val_env, ptr) =
		     input_newmap(s, decode_var, read_field, ptr, Environ.valid_order)
		   val new_num = !val_size + 1
		 in
		   val_size := new_num;
		   val_map := NewMap.define(!val_map, new_num, val_env);
		   (val_env, ptr)
		 end
	     | (valnum, ptr) =>
		 (NewMap.apply'(!val_map, valnum), ptr)
		 handle NewMap.Undefined => Crash.impossible
		   ("Undefined valnum (" ^ Integer.makestring valnum ^ ") in decode_val_env\n"))
d763 3
a765 3
		    (exn_size := new_num;
		     exn_map := NewMap.define(!exn_map, new_num, exn_env);
		     (exn_env, ptr))
a768 2
		  handle NewMap.Undefined => Crash.impossible
		    ("Undefined exnum (" ^ Integer.makestring exnnum ^ ") in decode_exn_env\n")
d788 3
a790 3
		(int_val_size := new_num;
		 int_val_map := NewMap.define(!int_val_map, new_num, v_int);
		 (v_int, ptr))
d794 1
a794 2
	      handle NewMap.Undefined => Crash.impossible
		("Undefined valnum (" ^ Integer.makestring valnum ^ ") in read_interface\n")
d808 1
a808 2
	      handle NewMap.Undefined => Crash.impossible
		("Undefined exnnum (" ^ Integer.makestring exnnum ^ ") in read_interface\n")
d945 3
a947 3
		(fix_size := new_num;
		 fix_map := NewMap.define(!fix_map, new_num, fix_env);
		 (fix_env, ptr))
a950 2
	      handle NewMap.Undefined => Crash.impossible
		("Undefined fixnum (" ^ Integer.makestring fixnum ^ ") in decode_fix_env\n")
a975 2
	      handle NewMap.Undefined => Crash.impossible
		("Undefined valnum (" ^ Integer.makestring valnum ^ ") in decode_val_env\n")
d1201 1
a1201 7
	(
(*
	 strnames := !strnames + 1;
	 diagnose_calls("encode_strname done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_strname_id (output_byte 3 :: done, s)
	 )
a1202 10
(*
      fun eq_assoc([], []) = true
      | eq_assoc([], _) = false
      | eq_assoc(_, []) = false
      | eq_assoc((x, _) :: xs, (y, _) :: ys) = x = y andalso eq_assoc(xs, ys)
      fun eq_domain(l1, l2) =
	Lists.length l1 = Lists.length l2 andalso
	eq_assoc(l1, l2)
*)

a1230 14
(*
	      fun ev'(h::t) = if h = r then Lists.length t + 1
			      else ev' t
	      | ev' [] =
		(tyname_valenvs_encoded := (r::(!tyname_valenvs_encoded)); 0)
	      val pos = ev'(!tyname_valenvs_encoded)
	      val done = optimised_output_int pos :: output_byte 2 :: done
	    in
	      if pos = 0 then
		encode_map done encode_valid encode_fun_or_cons M
	      else
		done
	    end
*)
a1236 4
(*
	  val _ = diagnose_calls("encode_valenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = valenvs := !valenvs + 1
*)
a1359 15
(*
	let
	  fun et'(h::t) = if Enc_Sub.type_same(h, arg) then Lists.length t + 1
			  else et' t
	  | et' [] =
	    (rectype_types_encoded := (arg::(!rectype_types_encoded)); 0)
	  val pos = et'(!rectype_types_encoded)
	  val done = optimised_output_int pos :: output_byte 5 :: done
	in
	  if pos = 0 then
	    encode_map done encode_lab encode_type M
	  else
	    done
	end
*)
a1377 17
(*
	let
	  fun et'((t1', t2')::t) =
	    if Enc_Sub.type_same(t1, t1') andalso Enc_Sub.type_same(t2, t2')
	      then Lists.length t + 1
	    else et' t
	  | et' [] =
	    (funtype_types_encoded := (arg::(!funtype_types_encoded)); 0)
	  val pos = et'(!funtype_types_encoded)
	  val done = optimised_output_int pos :: output_byte 6 :: done
	in
	  if pos = 0 then
	    encode_type(encode_type(done, t1), t2)
	  else
	    done
	end
*)
a1395 16
(*
	let
	  fun et'(h::t) =
	    if Enc_Sub.type_same(h, arg) then Lists.length t + 1
	    else et' t
	  | et' [] =
	    (constype_types_encoded := (arg::(!constype_types_encoded)); 0)
	  val pos = et'(!constype_types_encoded)
	  val done = optimised_output_int pos :: output_byte 7 :: done
	in
	  if pos = 0 then
	    encode_tyname(encode_list done encode_type l, t)
	  else
	    done
	end
*)
a1863 1
		  handle Lists.Nth => raise CorruptFile
a1957 1
		  handle Lists.Nth => raise CorruptFile
a1981 1
		  handle Lists.Nth => raise CorruptFile
a1998 1
		  handle Lists.Nth => raise CorruptFile
a2025 1
		  handle Lists.Nth => raise CorruptFile
a2049 1
		  handle Lists.Nth => raise CorruptFile
a2067 1
		  handle Enc_Sub.DecFuntypeHashTable.Lookup _ => raise CorruptFile
a2090 1
		  handle Lists.Nth => raise CorruptFile
a2111 1
		  handle Lists.Nth => raise CorruptFile
a2133 1
	    handle Lists.Nth => raise CorruptFile
d2201 1
a2201 2
		  ((Lists.nth(!tynames_so_far - n, !tynames_decoded), ptr)
		   handle Lists.Nth => raise CorruptFile)
a2227 1
		  handle NewMap.Undefined => raise CorruptFile
a2912 2
	handle Io m => raise BadInput m

d2920 7
a2926 1
    end
d2952 7
a2958 1
    end
@


1.55
log
@Did a bit more tidying up.
@
text
@d4 3
d319 1
a319 1
  val version = 2
d323 3
a325 4
      fun add_together_ords'(x,acc) =
        if x<0
          then acc
        else add_together_ords'(x-1,acc + ord(String.substring(s,x,1)))
d327 1
a327 1
      add_together_ords'(size(s)-1,x)
d419 2
a420 38
  datatype environment =
    PARSER_ENV of string |
    TYPE_ENV of string |
    CODE_ENV of string

  datatype section =
    CODE |
    ENV |
    DEBUG |
    CONSISTENCY

  datatype total_input =
    TOTAL_INPUT of
    {code : string, env : string list, 
     debug : string, consistency : string}

  exception bad_input
  exception bad_input1
  exception bad_input2
  exception bad_input3
  exception bad_input4
  exception bad_input5
  exception bad_input6
  exception bad_input7
  exception bad_input8
  exception bad_input9
  exception bad_input10
  exception bad_input11
  exception bad_input12
  exception bad_input13
  exception bad_input14
  exception bad_input15
  exception bad_input16
  exception bad_input17
  exception bad_input18
  exception bad_input19
  exception bad_input20
  exception bad_input21
a425 5
  fun print_debug x =
    if print_stats
      then output(std_out,x)
    else ()

a455 2
  fun output_int i = STRING(normal_output_int i)

d460 1
a460 2
      val two_word_max = exp(16) - 1
  in
a463 12
    fun optimised_output_int(x) =
      if x < two_words
        then (print_debug "1"; 
              STRING(chr x))
      else if x < two_word_max
             then (print_debug "2";
                   STRING( two_word_tag ^ chr(x div 256) ^ chr(x mod 256)))
           else (print_debug "4";
                 STRING(implode(four_word_tag::make_list([], 4, x))))
  end

  local
d468 9
d496 8
a503 2
  fun input_string(s, ptr, length, len) =
    String.substring(s, ptr, length)
d662 1
a662 1
  fun decode_lambda_env(s, from, len) =
a675 10
      val len =
	let
	  val total = size s
	  val len = from + len : int
	in
	  if total >= len then
	    len
	  else
	    Crash.impossible"Bad input for decode_cons"
	end
d677 1
a677 1
      val (total_size, ptr) = input_opt_int(s, from)
d681 1
a681 2
	  val (sy_size, ptr) = input_opt_int(s, ptr)
	  val sy = Symbol.find_symbol(input_string(s, ptr, sy_size, len))
d683 1
a683 1
	  (sy, ptr + sy_size)
d748 2
a749 4
		 handle Undefined =>
		   (Print.print("Undefined of " ^ Integer.makestring valnum ^
				" in decode_val_env\n");
		    raise Undefined))
d768 2
a769 4
		  handle Undefined =>
		    (Print.print("Undefined of " ^ Integer.makestring exnnum ^
				 " in decode_exn_env\n");
		     raise Undefined)
d795 2
a796 4
	      handle Undefined =>
		(Print.print("Undefined of " ^ Integer.makestring valnum ^
			     " in read_interface\n");
		 raise Undefined)
d810 2
a811 4
	      handle Undefined =>
		(Print.print("Undefined of " ^ Integer.makestring exnnum ^
			     " in read_interface\n");
		 raise Undefined)
d837 1
a837 1
  fun decode_parser_env(s, from, len) =
a844 10
      val len =
	let
	  val total = size s
	  val len = from + len : int
	in
	  if total >= len then
	    len
	  else
	    Crash.impossible"Bad input for decode_cons"
	end
d862 1
a862 1
	  | _ => raise bad_input4
d906 1
a906 1
	  | _ => raise bad_input5
d954 2
a955 4
	      handle Undefined =>
		(Print.print("Undefined of " ^ Integer.makestring fixnum ^
			     " in decode_fix_env\n");
		 raise Undefined)
d981 2
a982 4
	      handle Undefined =>
		(Print.print("Undefined of " ^ Integer.makestring valnum ^
			     " in decode_val_env\n");
		 raise Undefined)
d1004 1
a1004 6
	decode_map
	decode_funid
	read_parse_env
	from
	Ident.funid_eq
	Ident.funid_order
d1006 3
a1008 8
	decode_map
	decode_sigid
	read_parse_env
	ptr
	Ident.sigid_eq
	Ident.sigid_order
      val (parse_env, _) = read_parse_env ptr

a1612 6
      (*
         val length1 = if print_stats
                      then find_total_length result
                    else 0
       *)

d1617 2
a1618 65
        (*
      val _ = if print_stats
                then 
                  let
                    val length1' = find_total_length result
                  in
                    output(std_out,"Length of debug information is " ^ Integer.makestring(length1' - length1) ^ 
                           " (" ^ (Integer.makestring(((length1' - length1) * 100) div length1')) ^ "%)\n")
                  end
              else ()
                *)
(*
      val _ = diagnose_counts
	("tyname_ids encoded : " ^ Integer.makestring(!tyname_ids) ^ "\n" ^
	 "strname_ids encoded : " ^ Integer.makestring(!strname_ids) ^ "\n" ^
	 "strnames encoded : " ^ Integer.makestring(!strnames) ^ "\n" ^
	 "in list length : " ^ Integer.makestring(Lists.length(!strnames_encoded)) ^ "\n" ^
	 "valenvs encoded : " ^ Integer.makestring(!valenvs) ^ "\n" ^
	 "tynames encoded : " ^ Integer.makestring(!tynames) ^ "\n" ^
	 "in list length : " ^ Integer.makestring(Lists.length(NewMap.domain(!tynames_encoded_in_map))) ^ "\n" ^
	 "meta_tynames encoded : " ^ Integer.makestring(!meta_tynames) ^ "\n" ^
	 "types encoded : " ^ Integer.makestring(!types) ^ "\n" ^
	 "typeschemes encoded : " ^ Integer.makestring(!typeschemes) ^ "\n" ^
	 "tyfuns encoded : " ^ Integer.makestring(!tyfuns) ^ "\n" ^
	 "tystrs encoded : " ^ Integer.makestring(!tystrs) ^ "\n" ^
	 "tyenvs encoded : " ^ Integer.makestring(!tyenvs) ^ "\n" ^
	 "strs encoded : " ^ Integer.makestring(!strs) ^ "\n" ^
	 "strenvs encoded : " ^ Integer.makestring(!strenvs) ^ "\n" ^
	 "envs encoded : " ^ Integer.makestring(!envs) ^ "\n" ^
	 "sigmas encoded : " ^ Integer.makestring(!sigmas) ^ "\n" ^
	 "sigenvs encoded : " ^ Integer.makestring(!sigenvs) ^ "\n" ^
	 "phis encoded : " ^ Integer.makestring(!phis) ^ "\n" ^
	 "funenvs encoded : " ^ Integer.makestring(!funenvs) ^ "\n" ^
	 "namesets encoded : " ^ Integer.makestring(!namesets) ^ "\n" ^
	 "extra for out of module tynames : " ^
	 Integer.makestring(!tyname_extra) ^ "\n" ^
	 "in " ^ Integer.makestring(!extra_tynames) ^
	 " out of module tynames\n")
*)
(*
      val _ = Print.print
	("metatyvar_types_encoded = " ^
	 Integer.makestring(Lists.length(!metatyvar_types_encoded)) ^ " \n" ^
	 "meta_overloaded_types_encoded = " ^
	 Integer.makestring(Lists.length(!meta_overloaded_types_encoded)) ^
	 " \n" ^
	 "tyvar_types_encoded = " ^
	 Integer.makestring(Lists.length(!tyvar_types_encoded)) ^ " \n" ^
	 "metarectype_types_encoded = " ^
	 Integer.makestring(Lists.length(!metarectype_types_encoded)) ^ " \n" ^
	 "rectype_types_encoded = " ^
	 Integer.makestring(Lists.length(!rectype_types_encoded)) ^ " \n" ^
	 "funtype_types_encoded = " ^
	 Integer.makestring(Lists.length(!funtype_types_encoded)) ^ " \n" ^
	 "constype_types_encoded = " ^
	 Integer.makestring(Lists.length(!constype_types_encoded)) ^ " \n" ^
	 "debruijn_types_encoded = " ^
	 Integer.makestring(Lists.length(!debruijn_types_encoded)) ^ " \n" ^
	 "tynames encoded = " ^
	 Integer.makestring(!tyname_count) ^ "\n" ^
	 "different tynames encoded = " ^
	 Integer.makestring(Lists.length(!tynames_encoded)) ^ "\n" ^
	 "tyname_valenvs_encoded = " ^
	 Integer.makestring(!valenv_tyname_count) ^ "\n")
*)
a1619 2
        val result =
          delayed_extend_string_list result
d1621 12
a1632 14

        val _ = if !print_hash_table_stats
          then
            (output(std_out,"Tynamehashtable in _encapsulate: " ^
                    Enc_Sub.TynameHashTable.string_hash_table_stats(tynamehashtable) ^ "\n");
             output(std_out,"FunTypehashtable in _encapsulate: " ^
                    Enc_Sub.FuntypeHashTable.string_hash_table_stats(funtypehashtable) ^ "\n");
             output(std_out,"ConsTypehashtable in _encapsulate: " ^
                    Enc_Sub.ConstypeHashTable.string_hash_table_stats(constypehashtable) ^ "\n");
             output(std_out,"RecTypehashtable in _encapsulate: " ^
                    Enc_Sub.RectypeHashTable.string_hash_table_stats(rectypehashtable) ^ "\n");
             output(std_out,"Valenvhashtable in _encapsulate: " ^
                    Enc_Sub.ValenvHashTable.string_hash_table_stats(valenvhashtable) ^ "\n"))
                else ()
d1637 1
a1637 1
  fun decode_type_basis ((s, from, len),sub_modules) =
a1638 1

a1640 11
      val len =
	let
	  val total = size s
	  val len = from + len : int
	in
	  if total >= len then
	    len
	  else
	    Crash.impossible"Bad input for decode_cons"
	end

d1665 1
a1665 1
	| _ => raise bad_input6
d1668 1
a1668 6
	let
	  val (sy_size, ptr) = input_opt_int(s, ptr)
	  val sy = (String.substring(s, ptr, sy_size))
	in
	  (sy, ptr + sy_size)
	end
d1672 1
a1672 1
	  val (sy, ptr) = decode_string ptr
d1685 1
a1685 1
	  | _ => raise bad_input7
d1772 1
a1772 1
	  | _ => raise bad_input17
a1792 3
(*
		val _ = diagnose_calls("Decoding local tyfun_id as " ^ Integer.makestring(tyfun_count+n) ^ "\n")
*)
a1802 3
(*
		val _ = diagnose_calls("Decoding external tyfun_id in module '" ^ module ^ "' as " ^ Integer.makestring(tyfun_count+n) ^ "\n")
*)
d1807 1
a1807 9
	  | _ => raise bad_input17
	end

(*
      fun decode_tyfun_id ptr =
	let
	  val (n ,ptr) = input_opt_int(s, ptr)
	in
	  (Tyfun_id.make_tyfun_n n, ptr)
a1808 1
*)
d1842 1
a1842 1
	  | _ => raise bad_input18
d1854 1
a1854 1
	  | _ => raise bad_input9
d1881 1
a1881 1
      val tyname_valenvs_decoded = ref [] : Datatypes.Valenv ref list ref
d1953 1
a1953 3
(*
		  handle Lists.Nth => raise bad_input14
*)
d1961 1
a1961 1
	  | _ => raise bad_input8
d1989 1
a1989 1
	  | _ => raise bad_input10
d2016 1
a2016 1
	  | _ => raise bad_input11
d2048 1
a2048 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 1\n";
		     raise bad_input19)
*)
d2073 1
a2073 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 2\n";
		     raise bad_input19)
*)
d2090 2
a2091 7
		  ((Lists.nth(!tyvar_types_so_far - i, !tyvar_types_decoded)),
		   ptr)
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 3\n";
		     raise bad_input19)
*)
d2119 1
a2119 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 4\n";
		     raise bad_input19)
*)
d2144 1
a2144 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 5\n";
		     raise bad_input19)
*)
a2161 8
(*
		  (!(Lists.nth(!funtype_types_so_far - i, 
			       !funtype_types_decoded)),
		   ptr)
(*
		  handle Lists.Nth => raise bad_input19
*)
*)
d2163 1
a2163 9
(*
		  handle Enc_Sub.DecFuntypeHashTable.Lookup _ =>
		    (Print.print("Decode_type case 6\nIndex " ^
				 Integer.makestring i ^
				 "\nTotal so far " ^
				 Integer.makestring(!funtype_types_so_far) ^
				 "\n");
		     raise bad_input19)
*)
d2187 1
a2187 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 7\n";
		     raise bad_input19)
*)
d2209 1
a2209 5
(*
		  handle Lists.Nth =>
		    (Print.print"Decode_type case 8\n";
		     raise bad_input19)
*)
d2212 1
a2212 1
	  | _ => raise bad_input12
d2232 1
a2232 4
(*
	    handle Lists.Nth => (Print.print"decode_refvalenv\n";
				 raise bad_input13)
*)
d2242 1
a2242 2
	  | _ => (Print.print"decode_dummy_scheme\n";
		  raise bad_input13)
d2250 6
a2255 1
	    1 => decode_refvalenv ptr
a2264 4
		    val r = ref valenv
		    val _ =
		      tyname_valenvs_decoded := r :: (!tyname_valenvs_decoded)
		    val _ = tyname_valenvs_so_far := (!tyname_valenvs_so_far)+1
d2266 3
a2268 1
		    (r, ptr)
d2271 1
a2271 14
		  (Lists.nth(!tyname_valenvs_so_far-n,
			     !tyname_valenvs_decoded), ptr)
(*
		  handle Lists.Nth => (Print.print
				       ("decode_tyname_valenv(1)\nn = " ^
					Integer.makestring n ^ "\nso_far = " ^
					Integer.makestring
					(!tyname_valenvs_so_far) ^
					"list length = " ^
					Integer.makestring
					(Lists.length
					 (!tyname_valenvs_decoded)) ^ "\n");
				       raise bad_input13)
*)
d2273 1
a2273 2
	  | _ => (Print.print"decode_tyname_valenv(2)\n";
		  raise bad_input13)
d2301 1
a2301 4
(*
		   handle Lists.Nth => raise bad_input14
*)
)
d2328 1
a2328 3
(*
		  handle NewMap.Undefined => raise bad_input14
*)
d2330 1
a2330 1
	  | _ => raise bad_input15
d2501 1
a2501 2
      val (nameset, ptr) = decode_nameset from

a2502 1

a2503 1

a2504 1

d2507 1
a2507 2
      val result =
        (Basis.BASIS(nameset, funenv, sigenv, env),debug_information)
d2509 5
a2513 5
        val _ = if !print_hash_table_stats
                  then
                    output(std_out,"DecFuntypeHashTable in _encapsulate: " ^
                           Enc_Sub.DecFuntypeHashTable.string_hash_table_stats(decfuntypehashtable) ^ "\n")
                else ()
a2626 29
  fun decode_env s =
    let
      val s_size = size s
      val (p_size, ptr) = input_int(s, 0)
      val (t_size, ptr) = input_int(s, ptr)
      val (l_size, ptr) = input_int(s, ptr)
      val (tnames, ptr) = input_opt_int(s, ptr)
      val (snames, ptr) = input_opt_int(s, ptr)
      val (tyfuns, ptr) = input_opt_int(s, ptr)
    in
      {parser_env = (s, ptr, p_size),
       ty_env = (s, ptr + p_size, t_size),
       lambda_env = (s, ptr + p_size + t_size, l_size),
       tynames = tnames, strnames = snames, tyfuns = tyfuns}
    end

  fun decode_counts s =
    let
      val s_size = size s
      val (_, ptr) = input_int(s, 0)
      val (_, ptr) = input_int(s, ptr)
      val (_, ptr) = input_int(s, ptr)
      val (tnames, ptr) = input_opt_int(s, ptr)
      val (snames, ptr) = input_opt_int(s, ptr)
      val (tyfuns, ptr) = input_opt_int(s, ptr)
    in
      {tynames = tnames, strnames = snames, tyfuns = tyfuns}
    end

a2628 10
      val len = size s

      fun decode_string ptr =
	let
	  val (sy_size, ptr) = input_opt_int(s, ptr)
	  val sy = (input_string(s, ptr, sy_size, len))
	in
	  (sy, ptr + sy_size)
	end

d2630 1
d2638 3
a2640 1
  fun output_file {filename, code, tynames, strnames, tyfuns, parser_env, lambda_env, ty_env, consistency} =
d2952 1
a2952 1
	(write_int ObjectFile.GOOD_MAGIC; write_int version)
d2954 4
a2957 8
	(!fpos, write_dummies 8, !fpos)
      val (code_start, _, code_end) =
	(!fpos, write_code code, !fpos)
      val (eheader_start, _, eheader_end) =
	(!fpos, (write_dummies 3; write_opt_int tynames; write_opt_int strnames; write_opt_int tyfuns),	!fpos)
      val (parser_start, _, parser_end) =
	(!fpos, write_parser_env parser_env, !fpos)
      val the_ty_env = encode_type_basis ty_env
d2964 1
a2964 1
      val (cons_start, _, cons_end) = (!fpos, write_cons consistency, !fpos)
d2967 2
a2968 5
      write_int (code_end   -    code_start); write_int code_start;
      write_int (lambda_end - eheader_start); write_int eheader_start;
      write_int (debug_end  -   debug_start); write_int debug_start;
      write_int (cons_end   -    cons_start); write_int cons_start;
      seek eheader_start;
d2972 1
d2976 1
a2976 1
  val header_size = 40
d2980 2
a2981 5
      (* Later this may want to deal with opposite endian data *)
      val _ = if size header <> header_size then raise bad_input16 else ()
      val (magic, ptr) = input_int(header, 0)
      val (version, ptr) = input_int(header, ptr)
      val (code_size, ptr) = input_int(header, ptr)
d2983 36
a3018 6
      val (env_size, ptr) = input_int(header, ptr)
      val (env_offset, ptr) = input_int(header, ptr)
      val (debug_size, ptr) = input_int(header, ptr)
      val (debug_offset, ptr) = input_int(header, ptr)
      val (cons_size, ptr) = input_int(header, ptr)
      val (cons_offset, ptr) = input_int(header, ptr)
d3020 3
a3022 2
      (code_size, env_size, debug_size, cons_size, code_offset, env_offset,
       debug_offset, cons_offset)
d3025 9
a3033 1
  fun input_file filename =
d3036 10
a3045 11
      val header = input(file_handle, header_size)
      val (code_size, env_size, debug_size, cons_size, code_offset, env_offset,
       debug_offset, cons_offset) = decode_header header
      val _ = input(file_handle, code_offset - header_size)
      val code = input(file_handle, code_size)
      val _ = input(file_handle, env_offset - code_size - code_offset)
      val env = input(file_handle, env_size)
      val _ = input(file_handle, debug_offset - env_size - env_offset)
      val debug = input(file_handle, debug_size)
      val _ = input(file_handle, cons_offset - debug_size - debug_offset)
      val cons = input(file_handle, cons_size)
d3047 2
a3048 3
      (close_in file_handle;
       TOTAL_INPUT{code = code, env = [env], debug = debug,
		    consistency = cons})
@


1.54
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d518 1
a518 1
    fun input_int(s, ptr) =
d522 2
a523 2
    fun input_int_and_strip(s, ptr, len) =
      (input_int(s, ptr), ptr + 4)
d532 1
a532 1
	  (input_int(s, ptr + 1), ptr + 5)
a535 3

    fun optimised_input_int_and_strip(s, ptr, len) =
      input_opt_int(s, ptr)
d538 2
a539 3
  fun input_byte(s, ptr, len) =
    if ptr >= len then raise bad_input
    else (String.ordof(s, ptr), ptr + 1)
d552 15
d726 1
a726 1
      val (total_size, ptr) = optimised_input_int_and_strip(s, from, size s)
d730 1
a730 1
	  val (sy_size, ptr) = optimised_input_int_and_strip(s, ptr, len)
a763 14
      fun decode_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (rev done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = optimised_input_int_and_strip(s, ptr, len)
	in
	  dec_sub(count, ptr, [])
	end

d805 1
a805 1
	      val (exnnum, ptr) = optimised_input_int_and_strip(s, ptr, len)
d836 1
a836 1
	  val (valnum, ptr) = optimised_input_int_and_strip(s, ptr, len)
d840 1
a840 4
		val (v_int, ptr) =
		  decode_list
		  decode_var
		  ptr
d853 1
a853 7
(*
	  val (v_int, ptr) =
	    decode_list
	    decode_var
	    ptr
*)
	  val (exnnum, ptr) = optimised_input_int_and_strip(s, ptr, len)
d857 1
a857 4
		val (e_int, ptr) =
		  decode_list
		  decode_excon
		  ptr
d878 1
a878 1
	  val (offset, ptr) = optimised_input_int_and_strip(s, ptr, len)
a913 6
      val optimised_input_int_and_strip =
        fn ptr => optimised_input_int_and_strip(s,ptr,len)

      fun input_byte ptr =
	(String.ordof(s, ptr), ptr + 1)

d916 1
a916 1
	  val (sy_size, ptr) = optimised_input_int_and_strip ptr
d924 1
a924 1
	  val (sy_type, ptr) = input_byte ptr
d958 1
a958 1
	  val (fixity, ptr) = input_byte ptr
d963 1
a963 1
		val (prec, ptr) = input_byte ptr
d969 1
a969 1
		val (prec, ptr) = input_byte ptr
d986 1
a986 1
	  val (count, ptr) = optimised_input_int_and_strip ptr
d1002 1
a1002 1
	  val (fixnum, ptr) = optimised_input_int_and_strip ptr
d1030 1
a1030 1
	  val (valnum, ptr) = optimised_input_int_and_strip ptr
a1807 7
      val optimised_input_int_and_strip = 
        fn ptr => optimised_input_int_and_strip(s,ptr,len)


      fun input_byte ptr =
	(String.ordof(s, ptr), ptr + 1)

d1836 1
a1836 1
	  val (sy_size, ptr) = optimised_input_int_and_strip ptr
d1851 1
a1851 1
	  val (sy_type, ptr) = input_byte ptr
d1908 1
a1908 1
	  val (i, ptr) = input_byte ptr
d1915 1
a1915 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1923 1
a1923 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1935 1
a1935 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1949 1
a1949 1
	  val (i, ptr) = input_byte ptr
d1956 1
a1956 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1964 1
a1964 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1976 1
a1976 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d1991 1
a1991 1
	  val (n ,ptr) = optimised_input_int_and_strip ptr
d1999 1
a1999 1
	  val (i, ptr) = input_byte ptr
d2006 1
a2006 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2014 1
a2014 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2023 1
a2023 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2035 1
a2035 1
	  val (i, ptr) = input_byte ptr
a2043 14
      fun decode_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (rev done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = optimised_input_int_and_strip ptr
	in
	  dec_sub(count, ptr, [])
	end

d2053 1
a2053 1
	  val (count, ptr) = optimised_input_int_and_strip ptr
d2115 1
a2115 1
	  val (i, ptr) = input_byte ptr
d2126 1
a2126 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2156 1
a2156 1
	  val (i, ptr) = input_byte ptr
d2162 1
a2162 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2183 1
a2183 1
	  val (i, ptr) = input_byte ptr
d2188 1
a2188 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2210 1
a2210 1
	  val (i, ptr) = input_byte ptr
d2215 1
a2215 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2224 1
a2224 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2245 1
a2245 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2274 1
a2274 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2278 1
a2278 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2297 1
a2297 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2307 1
a2307 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2329 1
a2329 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2358 1
a2358 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2393 1
a2393 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2402 1
a2402 1
		    val (the_list, ptr) = decode_list decode_type ptr
d2421 1
a2421 1
		val (i, ptr) = optimised_input_int_and_strip ptr
d2425 1
a2425 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2451 1
a2451 1
	  val (n, ptr) = optimised_input_int_and_strip ptr
d2474 1
a2474 1
	  val (n, ptr) = input_byte ptr
d2485 1
a2485 1
	  val (n, ptr) = input_byte ptr
d2491 1
a2491 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2527 1
a2527 1
	  val (i, ptr) = input_byte ptr
d2532 1
a2532 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2538 1
a2538 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2557 1
a2557 1
		val (n, ptr) = optimised_input_int_and_strip ptr
d2569 1
a2569 1
		    val (i, ptr) = optimised_input_int_and_strip ptr
d2671 1
a2671 1
        optimised_input_int_and_strip ptr
d2675 1
a2675 1
          val (i, ptr) = input_byte ptr
d2681 1
a2681 1
                val  (arg,ptr) = input_pair decode_int decode_recipe ptr
d2687 1
a2687 1
                val (args,ptr) = decode_list (input_pair decode_string decode_recipe) ptr
d2717 1
a2717 1
                val (arg,ptr) = input_pair (decode_list decode_recipe) decode_tyname ptr
d2734 1
a2734 1
	  val (count, ptr) = optimised_input_int_and_strip ptr
d2743 1
a2743 1
            (input_pair decode_type (decode_list (input_pair decode_int decode_recipe))),
d2889 6
a2894 6
      val (p_size, ptr) = input_int_and_strip(s, 0, s_size)
      val (t_size, ptr) = input_int_and_strip(s, ptr, s_size)
      val (l_size, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tnames, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (snames, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (tyfuns, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
d2896 3
a2898 3
      {parser_env= (s, ptr, p_size),
       ty_env= (s, ptr + p_size, t_size),
       lambda_env= (s, ptr + p_size + t_size, l_size),
d2905 6
a2910 6
      val (_, ptr) = input_int_and_strip(s, 0, s_size)
      val (_, ptr) = input_int_and_strip(s, ptr, s_size)
      val (_, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tnames, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (snames, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (tyfuns, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
d2921 1
a2921 1
	  val (sy_size, ptr) = optimised_input_int_and_strip(s, ptr, len)
d2927 1
a2927 20
      fun decode_int ptr = optimised_input_int_and_strip(s, ptr, len)

      fun decode_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (rev done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = optimised_input_int_and_strip(s, ptr, len)
	in
	  dec_sub(count, ptr, [])
	end

      val result =
        #1 (decode_list
            (input_pair decode_string (input_pair decode_int decode_int))
            0)
d2929 2
d3283 10
a3292 10
      val (magic, ptr) = input_int_and_strip(header, 0, header_size)
      val (version, ptr) = input_int_and_strip(header, ptr, header_size)
      val (code_size, ptr) = input_int_and_strip(header, ptr, header_size)
      val (code_offset, ptr) = input_int_and_strip(header, ptr, header_size)
      val (env_size, ptr) = input_int_and_strip(header, ptr, header_size)
      val (env_offset, ptr) = input_int_and_strip(header, ptr, header_size)
      val (debug_size, ptr) = input_int_and_strip(header, ptr, header_size)
      val (debug_offset, ptr) = input_int_and_strip(header, ptr, header_size)
      val (cons_size, ptr) = input_int_and_strip(header, ptr, header_size)
      val (cons_offset, ptr) = input_int_and_strip(header, ptr, header_size)
@


1.53
log
@Started optimisations, removing Map.to_list etc.
@
text
@d4 3
d280 7
a286 5
  sharing ParserEnv.Map = Basis.Datatypes.Mapping
  sharing ParserEnv.Ident = Environ.Interface.Ident
  sharing Environ.EnvironTypes.Ident = ParserEnv.Ident = Basis.Datatypes.Ident
  sharing Basis.Datatypes = Valenv.Datatypes = Types.Datatypes = Enc_Sub.DataTypes = Debugger_Types.Datatypes
  sharing Debugger_Types.Map = Environ.EnvironTypes.NewMap = Environ.Interface.NewMap = Basis.Datatypes.NewMap
d292 1
a292 1
  structure Datatypes = Basis.Datatypes
d294 1
a294 2
  structure Sigma = Basis.Sigma
  structure Phi = Basis.Phi
d296 1
d302 1
a302 1
  structure Nameset = Basis.Nameset
@


1.52
log
@Fixed nasty bug in encapsulation of strname counts.
@
text
@d4 3
d508 30
a537 9
  fun input_int(s, ptr, len,size_to_get) =
    if len < ptr+size_to_get then
      raise bad_input
    else
      if size_to_get = 2
        then 256 * ord(String.substring(s,ptr,1)) + ord(String.substring(s,ptr+1,1))
      else ord(String.substring(s,ptr+3,1)) +
        256*(ord(String.substring(s,ptr+2,1)) +
             256*(ord(String.substring(s,ptr+1,1)) + 256 * ord(String.substring(s,ptr,1))))
d539 1
a539 1
  fun input_int_and_strip(s, ptr, len) =
d541 2
a542 1
      val answer = input_int(s, ptr, len,4)
d544 1
a544 1
      (answer, ptr+4)
d546 4
d551 8
a558 3
  fun optimised_input_int_and_strip(s, ptr, len) =
    let
      val tag = String.substring(s,ptr,1)
d560 1
a560 5
      if tag = two_word_tag
        then (input_int(s, ptr+1, len,2),ptr+3)
      else if tag = four_word_tag
             then (input_int(s, ptr+1, len,4),ptr+5)
           else (ord tag,ptr+1)
d562 1
a562 15

  fun input_byte(s, ptr, len) =
    if ptr >= len then
      raise bad_input
    else
      (String.ordof(s, ptr), ptr + 1)

  fun input_string(s, ptr, length, len) =
(*
    if ptr+length > len then
      raise bad_input3
    else
*)
      String.substring(s, ptr, length)

d758 1
a758 1
      fun decode_pair f g ptr =
d760 1
a760 5
	  val (fval, ptr) = f ptr
	  val (gval, ptr) = g ptr
	in
	  ((fval, gval), ptr)
	end
a761 33
      fun decode_rev_list f ptr =
        let
          fun dec_sub(0, ptr, done) = (done, ptr)
            | dec_sub(n, ptr, done) =
              let
                val (d, ptr) = f ptr
              in
                dec_sub(n-1, ptr, d :: done)
              end
          val (count, ptr) = optimised_input_int_and_strip(s, ptr, len)
        in
          dec_sub(count, ptr, [])
        end
      
      fun decode_newmap f g ptr orderfn =
        let
          val (list, ptr) = decode_rev_list (decode_pair f g) ptr
        in
          (NewMap.from_list orderfn list, ptr)
        end
      
      fun decode_map f g ptr eqfn orderfn =
	let
	  val (assoc_list, ptr) = decode_rev_list  (decode_pair f g) ptr
	in
	  (Lists.reducel
	   (fn (m, x) => Map.add(x, m, orderfn))
	   (Map.empty_eqfunmap eqfn, assoc_list), ptr)
	end
      
      fun read_env ptr =
	let
	  val (env_size, ptr) = optimised_input_int_and_strip(s, ptr, len)
d763 14
a776 18
	    let
	      val (offset, ptr) = optimised_input_int_and_strip(s, ptr, len)
	    in
              (case offset of
                 0 => 
                   let
                     val (offset, ptr) = optimised_input_int_and_strip(s, ptr, len)
                   in
                     (EnvironTypes.FIELD{index=offset, size=env_size}, ptr)
                   end
               | 1 => 
                   let
                     val (offset, ptr) = optimised_input_int_and_strip(s, ptr, len)
                   in
                     (EnvironTypes.PRIM (Pervasives.decode offset), ptr)
                   end
                 | _ => Crash.impossible "Decoding a field - got neither 1 nor 0 ")
	    end
d779 17
a795 25
	    let
	      val (valnum, ptr) = optimised_input_int_and_strip(s, ptr, len)
	    in
	      case valnum of
		0 =>
		  let
		    val (val_env, ptr) =
		      decode_newmap 
		      decode_var
		      read_field
		      ptr
		      Environ.valid_order
		    val new_num = !val_size + 1
		  in
		    (val_size := new_num;
		     val_map := NewMap.define(!val_map, new_num, val_env);
		     (val_env, ptr))
		  end
	      | _ =>
		  (NewMap.apply'(!val_map, valnum), ptr)
		  handle Undefined =>
		    (Print.print("Undefined of " ^ Integer.makestring valnum ^
				 " in decode_val_env\n");
		     raise Undefined)
	    end
d805 1
a805 5
		      decode_newmap 
		      decode_excon
		      read_field
		      ptr
		      Environ.valid_order
d819 1
a819 1

d823 1
a823 3
	    decode_newmap decode_strid
	    (decode_pair read_env read_field)
	    ptr Environ.strid_order
d877 1
a877 1
	    decode_newmap decode_strid read_interface ptr Environ.strid_order
d893 1
a893 1
	decode_newmap decode_funid read_ftr_range ptr Environ.funid_order
a988 8
      fun decode_pair f g ptr =
	let
	  val (fval, ptr) = f ptr
	  val (gval, ptr) = g ptr
	in
	  ((fval, gval), ptr)
	end

d1005 1
a1005 1
	  val (assoc_list, ptr) = decode_rev_list (decode_pair f g) ptr
a2076 8
      fun decode_pair f g ptr =
	let
	  val (fval, ptr) = f ptr
	  val (gval, ptr) = g ptr
	in
	  ((fval, gval), ptr)
	end

d2093 1
a2093 1
	  val (assoc_list, ptr) = decode_rev_list (decode_pair f g) ptr
a2098 7
      fun decode_newmap f g ptr orderfn =
	let
	  val (list, ptr) = decode_rev_list (decode_pair f g) ptr
	in
	  (NewMap.from_list orderfn list, ptr)
	end
      
d2492 1
a2492 1
		decode_newmap decode_valid decode_typescheme ptr Environ.valid_order
d2529 1
a2529 1
		      decode_newmap decode_valid decode_dummy_scheme ptr Environ.valid_order
d2631 1
a2631 1
	    decode_newmap decode_tycon decode_tystr ptr Datatypes.tycon_order
d2657 1
a2657 1
	    decode_newmap decode_strid decode_str ptr Environ.strid_order
d2681 1
a2681 1
	    decode_newmap decode_sigid decode_sigma ptr Sigenv.sigid_order
d2698 1
a2698 1
	    decode_newmap decode_funid decode_phi ptr Funenv.funid_order
d2714 1
a2714 1
                val  (arg,ptr) = decode_pair decode_int decode_recipe ptr
d2720 1
a2720 1
                val (args,ptr) = decode_list (decode_pair decode_string decode_recipe) ptr
d2738 1
a2738 1
                val (arg,ptr) = decode_pair decode_recipe decode_recipe ptr
d2744 1
a2744 1
                val (arg,ptr) = decode_pair decode_int decode_recipe ptr
d2750 1
a2750 1
                val (arg,ptr) = decode_pair (decode_list decode_recipe) decode_tyname ptr
a2771 7
      fun decode_newmap f g ptr orderfn =
        let
          val (list, ptr) = decode_rev_list (decode_pair f g) ptr
        in
          (NewMap.from_list orderfn list, ptr)
        end

d2775 3
a2777 6
            decode_newmap 
            decode_string 
            (decode_pair 
             decode_type
             (decode_list (decode_pair decode_int decode_recipe)))
            ptr
d2783 1
a2783 1
                  else NewMap.GREATER)
a2975 8
      fun decode_pair f g ptr =
	let
	  val (fval, ptr) = f ptr
	  val (gval, ptr) = g ptr
	in
	  ((fval, gval), ptr)
	end

d2978 1
a2978 1
            (decode_pair decode_string (decode_pair decode_int decode_int))
@


1.51
log
@Changed MLworks to MLWorks.
@
text
@d4 3
d3010 3
a3012 3
      val (_, ptr) = optimised_input_int_and_strip(s, 0, s_size)
      val (_, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (_, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
@


1.50
log
@Deleted various redundant structure arguments. Changed some
of the output routines to output stuff directly to the
mo file, instead of building intermediate lists etc.
@
text
@d4 5
d3064 4
a3067 4
      val file_handle = MLworks.FileIO.openf filename
      val close = MLworks.FileIO.closef
      val write = MLworks.FileIO.writef
      fun seek pos = MLworks.FileIO.seekf(file_handle, pos, MLworks.FileIO.BEG)
@


1.49
log
@Anel's changes to use NewMap instead of Map
@
text
@a3 3
Revision 1.49  1992/08/06  16:55:33  jont
Anel's changes to use NewMap instead of Map

a227 2
require "../utils/map";
require "../utils/string";
a232 2
require "../basics/ident";
require "../basics/symbol";
a233 1
require "../typechecker/interface";
a234 1
require "../typechecker/datatypes";
a236 5
require "../typechecker/sigenv";
require "../typechecker/sigma";
require "../typechecker/funenv";
require "../typechecker/phi";
require "../typechecker/nameset";
a238 1
require "../lambda/environtypes";
a250 2
  structure Map : MAP
  structure String : STRING
a253 2
  structure Ident : IDENT
  structure Symbol : SYMBOL
a254 1
  structure Interface : INTERFACE
a255 1
  structure DataTypes : DATATYPES
a256 8
  structure Strname_id : STRNAME_ID
  structure Tyfun_id : TYFUN_ID
  structure Tyname_id : TYNAME_ID
  structure Sigenv : SIGENV
  structure Sigma : SIGMA
  structure Funenv : FUNENV
  structure Phi : PHI
  structure Nameset : NAMESET
a258 1
  structure EnvironTypes : ENVIRONTYPES
d266 6
a271 22
  sharing Map = ParserEnv.Map =
    DataTypes.Mapping
  sharing EnvironTypes = Environ.EnvironTypes
  sharing Symbol = Ident.Symbol = ParserEnv.Symbol
  sharing Ident = EnvironTypes.Ident = Interface.Ident = ParserEnv.Ident =
    DataTypes.Ident
  sharing Interface = EnvironTypes.Interface
  sharing DataTypes = Basis.Datatypes = Sigenv.Datatypes = Funenv.Datatypes =
    Nameset.Datatypes = Valenv.Datatypes = Types.Datatypes = Enc_Sub.DataTypes =
    Debugger_Types.Datatypes
  sharing Debugger_Types.Map = EnvironTypes.NewMap = Interface.NewMap =
    DataTypes.NewMap
  sharing Tyfun_id = DataTypes.Tyfun_id
  sharing Tyname_id = DataTypes.Tyname_id
  sharing Strname_id = DataTypes.Strname_id
  sharing Sigenv = Basis.Sigenv
  sharing Sigma = Basis.Sigma = Phi.Sigma
  sharing Sigma.Nameset = Basis.Nameset
  sharing Funenv = Basis.Funenv
  sharing Phi = Basis.Phi
  sharing Nameset = Basis.Nameset
  sharing type Pervasives.pervasive = EnvironTypes.LambdaTypes.Primitive
d275 12
a286 1

a287 1
  structure EnvironTypes = EnvironTypes
d292 2
d296 2
d305 1
a305 1
      add_together_ords'(String.length(s)-1,x)
a407 5
  datatype total_output =
    TOTAL_OUTPUT of
    {code : DelayedEvaluation, env : DelayedEvaluation list, 
     debug : DelayedEvaluation, consistency : DelayedEvaluation}

a571 52
  fun encode_code(MachTypes.MODULE element_list) =
    let
      fun output_module_element(MachTypes.REAL(i, r)) =
	make_implode
	[output_int ObjectFile.opcode_real, output_int i,
	 output_int(size r div 4), STRING r]
      | output_module_element(MachTypes.STRING(i, s)) =
	make_implode
	[output_int ObjectFile.opcode_string, output_int i,
	 output_int(size s + 1), STRING(extend_string s)]
      | output_module_element(MachTypes.WORDSET(MachTypes.WORD_SET w_list)) =
	let
	  val wordset_len = Lists.length w_list
	  val wordset_size =
	    Lists.reducel op +  (* CT added the four for each non_gc_spill count *)
	    (0, map (fn (i,spill,s) => (4 + size s)) w_list)
	in
	  make_implode
	  (output_int ObjectFile.opcode_codeset :: output_int wordset_len ::
	   output_int wordset_size ::
	   map
	   (fn (i, spills, w) => make_concat((normal_output_int i) ^ normal_output_int(4+size w) ^
                                             (normal_output_int(spills)),w))
	   w_list)
	end
      | output_module_element(MachTypes.EXTERNAL(i, s)) =
	make_implode
	[output_int ObjectFile.opcode_external, output_int i,
	 output_int(size s + 1), delayed_extend_string s]
	| output_module_element(MachTypes.VAR _) =
	  Crash.impossible"Encapsulating interpretive code"
	| output_module_element(MachTypes.EXN _) =
	  Crash.impossible"Encapsulating interpretive code"
	| output_module_element(MachTypes.STRUCT _) =
	  Crash.impossible"Encapsulating interpretive code"
	| output_module_element(MachTypes.FUNCT _) =
	  Crash.impossible"Encapsulating interpretive code"
      val object_count = count_real_objects(0, element_list)
(*
      val _ = Print.print("Producing module with " ^
			  Integer.makestring(Lists.length element_list) ^
			  " elements and " ^
			  Integer.makestring object_count ^
			  " objects\n")
*)
    in
      make_implode
      (output_int (Lists.length element_list) ::
       output_int object_count ::
       map output_module_element element_list)
    end

d636 3
a638 3
  fun encode_over_loaded DataTypes.UNARY = output_byte 1
  | encode_over_loaded DataTypes.BINARY = output_byte 2
  | encode_over_loaded DataTypes.PREDICATE = output_byte 3
a650 2
  val count_len = NewMap.fold (fn (n, _, _) => n+1)

d652 1
a652 4
    NewMap.fold
    (fn (done, dom, ran) =>
     g(f(done, dom), ran))
    (optimised_output_int(count_len(0, x)) :: done, x)
d655 1
a655 169
    encode_list
    done
    (fn (done, (x, y)) => encode_pair f g (done, (x, y)))
    (Map.assoc x)

  fun encode_lambda_env(EnvironTypes.TOP_ENV(env as EnvironTypes.ENV(v, e, s),
					     EnvironTypes.FUN_ENV fun_env)) =
    let
      val lambdavalhashtable = LambdaValHashTable.new()
      val valsize = ref 0
      val lambdaexnhashtable = LambdaValHashTable.new()
      val exnsize = ref 0
      val intvalhashtable = IntHashTable.new()
      val intvalsize = ref 0
      val intexnhashtable = IntHashTable.new()
      val intexnsize = ref 0
      val f_map = NewMap.to_list fun_env
      val f_len = Lists.length f_map
      val v_len = Lists.length(NewMap.to_list v)
      val e_len = Lists.length(NewMap.to_list e)
      val s_len = Lists.length(NewMap.to_list s)
      val env_len = v_len + e_len + s_len

      fun encode_sub extra (done, EnvironTypes.ENV(v_map, e_map, s_map)) =
	let
	  val v_list = NewMap.to_list_ordered v_map
	  val e_list = NewMap.to_list_ordered e_map
	  val s_list = NewMap.to_list s_map
	  val v_len = Lists.length v_list
	  val e_len = Lists.length e_list
	  val s_len = Lists.length s_list
	  val env_len = v_len + e_len + s_len + extra

(**)
	  val vnum =
	    LambdaValHashTable.lookup(lambdavalhashtable, v_list)
	    handle LambdaValHashTable.Lookup _ =>
	      let
		val newsize = !valsize + 1
		val _ = valsize := newsize
		val _ = LambdaValHashTable.update(lambdavalhashtable,
						  v_list, newsize)
	      in
		0
	      end
	  val done = optimised_output_int vnum :: optimised_output_int env_len :: done
	  val encoded_v_list = case vnum of
	    0 =>
	      encode_list
	      done
	      (encode_pair encode_valid' encode_index')
	      v_list
(*
	      encode_newmap
	      done
	      encode_valid'
	      encode_index'
	      v_map
*)
	  | n => done
(**)
(**)
	  val enum =
	    LambdaValHashTable.lookup(lambdaexnhashtable, e_list)
	    handle LambdaValHashTable.Lookup _ =>
	      let
		val newsize = !exnsize + 1
		val _ = exnsize := newsize
		val _ = LambdaValHashTable.update(lambdaexnhashtable,
						  e_list, newsize)
	      in
		0
	      end
	  val done = optimised_output_int enum :: encoded_v_list
	  val encoded_e_list = case enum of
	    0 =>
	      encode_list
	      done
	      (encode_pair encode_valid' encode_index')
	      e_list
(*
	      encode_newmap
	      done
	      encode_valid'
	      encode_index'
	      e_map
*)
	  | n => done
(**)
	in
	  encode_newmap
(*
	  (encode_newmap
	   (encode_newmap
	    (output_int env_len :: done)
	    encode_valid'
	    encode_index'
	    v_map)
	   encoded_v_list
	   encode_valid'
	   encode_index'
	   e_map)
*)
(**)
	  encoded_e_list
(**)
	  encode_strid
	  (encode_pair (encode_sub 0) encode_index')
	  s_map
	end

      fun encode_interface(done, Interface.INT(Interface.INTENV s_map,
					       v_list, e_list)) =
	let
	  val vnum = IntHashTable.lookup(intvalhashtable, v_list)
	    handle IntHashTable.Lookup _ =>
	      let
		val newsize = !intvalsize + 1
		val _ = intvalsize := newsize
		val _ = IntHashTable.update(intvalhashtable,
					    v_list, newsize)
	      in
		0
	      end
	  val done = optimised_output_int vnum :: done
	  val done = case vnum of
	    0 => encode_list done encode_valid' v_list
	  | n => done
	  val enum = IntHashTable.lookup(intexnhashtable, e_list)
	    handle IntHashTable.Lookup _ =>
	      let
		val newsize = !intexnsize + 1
		val _ = intexnsize := newsize
		val _ = IntHashTable.update(intexnhashtable,
					    e_list, newsize)
	      in
		0
	      end
	  val done = optimised_output_int enum :: done
	  val done = case enum of
	    0 => encode_list done encode_valid' e_list
	  | n => done
	in
	  encode_newmap
	  done
	  encode_strid
	  encode_interface
	  s_map
	end

      fun do_ftr_range(done, (field, interface, env)) =
	encode_sub 0
	(encode_interface(encode_index(done, field), interface), env)

      val result = 
        delayed_extend_string_list
         (encode_sub f_len
          (encode_newmap [optimised_output_int(f_len + env_len)] encode_funid
           do_ftr_range fun_env, env))

      val _ = if !print_hash_table_stats
        then (output(std_out,"lambdavalhashtable in _encapsulate: "^
                     LambdaValHashTable.string_hash_table_stats(lambdavalhashtable) ^ "\n");
              output(std_out,"lambdaexnhashtable in _encapsulate: "^
                     LambdaValHashTable.string_hash_table_stats(lambdaexnhashtable) ^ "\n"))
              else ()
    in
      result
    end
d849 2
a850 20
	  val (v_env, ptr) =
	    decode_val_env ptr
(*
	    decode_newmap 
	    decode_var
	    read_field
	    ptr
	    Environ.valid_order
*)
	  val (e_env, ptr) =
(**)
	    decode_exn_env ptr
(**)
(*
	    decode_newmap 
	    decode_excon
	    read_field
	    ptr
	    Environ.valid_order
*)
d852 1
a852 2
	    decode_newmap
	    decode_strid
d854 1
a854 2
	    ptr
	    Environ.strid_order
a906 6
(*
	  val (e_int, ptr) =
	    decode_list
	    decode_excon
	    ptr
*)
d908 1
a908 5
	    decode_newmap
	    decode_strid
	    read_interface
	    ptr
	    Environ.strid_order
d924 1
a924 5
	decode_newmap
	decode_funid
	read_ftr_range
	ptr
	Environ.funid_order
a930 128
  fun encode_parser_env(ParserEnv.B(ParserEnv.F fun_map, ParserEnv.G sig_map,
				    parse_env)) =
    let
(*
      val fun_len = Lists.length(Map.assoc fun_map)
      val _ = Print.print("Encapsulating parser functor env of length " ^
			  Integer.makestring fun_len ^ "\n")
      val sig_len = Lists.length(Map.assoc sig_map)
      val _ = Print.print("Encapsulating parser signature env of length " ^
			  Integer.makestring sig_len ^ "\n")
      val val_maps =
	ref(NewMap.empty' Symbol.symbol_order) :
	(Symbol.Symbol, int * ((Symbol.Symbol * Ident.ValId) list)) NewMap.T ref
      val val_map_size = ref 0
*)
      val valhashtable = ValHashTable.new()
      val fixhashtable = FixHashTable.new()
      val valsize = ref 0
      val fixsize = ref 0

      fun encode_fixity(done, ParserEnv.LEFT i) =
	output_byte i :: output_byte 0 :: done
      | encode_fixity(done, ParserEnv.RIGHT i) =
	output_byte i :: output_byte 1 :: done
      | encode_fixity(done, ParserEnv.NONFIX) =
	output_byte 2 :: done

      fun encode_pe(done, ParserEnv.E(ParserEnv.FE fix_map,
				      ParserEnv.VE val_map,
				      ParserEnv.SE struct_map)) =
	let
(*
	  val val_len = Lists.length(Map.assoc val_map)
	  val _ = Print.print("Encoding val map of length " ^
			      Integer.makestring val_len ^ "\n")
	  val str_len = Lists.length(Map.assoc struct_map)
	  val _ = Print.print("Encoding str map of length " ^
			      Integer.makestring str_len ^ "\n")
	  val the_code =
	    case Map.assoc val_map of
	      [] => ~1
	    | the_list as ((sy, _) :: _) =>
		(let
		   val (im, o_list) = NewMap.apply'(!val_maps, sy)
		 in
		   if o_list = the_list then
		     im
		   else
		     (val_map_size := !val_map_size + 1;
		     ~1)
		 end) handle NewMap.Undefined =>
		   (val_map_size := !val_map_size + 1;
		    val_maps := NewMap.define(!val_maps, sy, (!val_map_size,
							      the_list));
		    0)
*)
	  val fix_list = Map.assoc fix_map
	  val fixnum =
	    FixHashTable.lookup(fixhashtable, fix_list)
	    handle FixHashTable.Lookup _ =>
	      let
		val newsize = !fixsize + 1
		val _ = fixsize := newsize
		val _ = FixHashTable.update(fixhashtable, fix_list, newsize)
	      in
		0
	      end
	  val encoded_fixity = case fixnum of
	    0 =>
	      encode_map
	      (optimised_output_int 0 :: done)
	      encode_symbol
	      encode_fixity
	      fix_map
	  | n => optimised_output_int n :: done
	  val val_list = Map.assoc val_map
	  val valnum =
	    ValHashTable.lookup(valhashtable, val_list)
	    handle ValHashTable.Lookup _ =>
	      let
		val newsize = !valsize + 1
		val _ = valsize := newsize
		val _ = ValHashTable.update(valhashtable, val_list, newsize)
	      in
		0
	      end
	  val encoded_vals = case valnum of
	    0 =>
	      encode_list
	      (optimised_output_int 0 :: encoded_fixity)
	      (fn (done, (_, x)) => encode_valid(done, x))
	      val_list
	  | n => optimised_output_int n :: encoded_fixity
	in
	encode_map
	encoded_vals

	encode_strid
	encode_pe
	struct_map
	end

	val result =
	  Timer.xtime
	  ("building parser env list", !do_timings,
	   fn () =>
	   delayed_extend_string_list
	   (encode_pe
	    ((encode_map
	      (encode_map
	       []
	       encode_funid
	       encode_pe
	       fun_map)
	      encode_sigid
	      encode_pe
	      sig_map),
	     parse_env)))

        val _ = if !print_hash_table_stats
                  then (output(std_out,"Valhashtable in _encapsulate:" ^
                               ValHashTable.string_hash_table_stats(valhashtable) ^ "\n");
                        output(std_out,"Fixhashtable in _encapsulate:" ^
                               FixHashTable.string_hash_table_stats(fixhashtable) ^ "\n"))
                else ()
    in
      result
    end
d1233 1
a1233 1
      val strnames_encoded = ref [] : DataTypes.Strname ref list ref
d1236 2
a1237 2
	ref [] : ((int * DataTypes.Type) ref * bool * bool) list ref
      val meta_overloaded_types_encoded = ref [] : DataTypes.Type ref list ref
d1240 1
a1240 1
	ref [] : (int * bool * DataTypes.Type * bool * bool) ref list ref
d1242 1
a1242 1
	ref [] : DataTypes.Type list ref
d1244 2
a1245 2
	ref [] : (DataTypes.Type * DataTypes.Type) list ref
      val constype_types_encoded = ref [] : DataTypes.Type list ref
d1247 1
a1247 1
      val meta_tynames_encoded = ref [] : DataTypes.Tyname list ref
a1255 18
(*
      fun tyname_order((r1, i1:int, s1), (r2, i2, s2)) =
	if r1 = r2 then NewMap.EQUAL
	else
	  if i1 = i2 then
	    (
(*
	     diagnose_calls("Beware: Equal tyname_ids " ^ Integer.makestring i1 ^ ", " ^ Integer.makestring i2 ^ " on distinct tynames '" ^ s1 ^ "', '" ^ s2 ^ "'");
*)
	     NewMap.EQUAL
)
	  else
	    if i1 < i2 then NewMap.LESS else NewMap.GREATER

      val tynames_encoded_in_map =
	ref (NewMap.empty tyname_order) : ((bool ref * int * string), int) NewMap.T ref
      val tyname_count = ref 1
*)
a1258 4
(*
	  val _ = diagnose_calls("encode_tyname_id done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = tyname_ids := !tyname_ids + 1
*)
d1263 1
a1263 6
	      (
(*
	       diagnose_calls("Encoding tyname_id in pervasives, value " ^ Integer.makestring id ^ "\n");
*)
	       optimised_output_int id :: output_byte 0 :: done
)
a1266 3
(*
	      val _ = diagnose_calls("Encoding tyname_id in module '" ^ module ^ "', with offset " ^ Integer.makestring id' ^ "\n")
*)
a1277 4
(*
	  val _ = diagnose_calls("encode_strname_id done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = strname_ids := !strname_ids + 1
*)
a1296 4
(*
	  val _ = diagnose_calls("encode_tyfun_id done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = tyfun_ids := !tyfun_ids + 1
*)
d1301 1
a1301 6
	      (
(*
	       diagnose_calls("Encoding tyfun_id in pervasives, value " ^ Integer.makestring id ^ "\n");
*)
	       optimised_output_int id :: output_byte 0 :: done
)
a1304 3
(*
	      val _ = diagnose_calls("Encoding tyfun_id in module '" ^ module ^ "', with offset " ^ Integer.makestring id' ^ "\n")
*)
d1306 2
a1307 3
	      if module = "" 
		then
		  optimised_output_int id' :: output_byte 1 :: done
d1313 1
a1313 1
      fun encode_strname(done, DataTypes.STRNAME s) =
d1321 1
a1321 1
      | encode_strname(done, DataTypes.METASTRNAME s) =
d1340 1
a1340 1
      | encode_strname(done, DataTypes.NULLNAME s) =
d1361 2
a1362 2
	  DataTypes.CONSTYPE _ => output_byte 1 :: done
	| DataTypes.FUNTYPE _ => output_byte 2 :: done
d1365 1
a1365 1
      fun encode_tyname_valenv(done, valenv as DataTypes.VE(r, M)) =
d1387 14
d1405 1
a1405 1
      fun encode_valenv(done, DataTypes.VE(r, M)) =
d1407 4
d1420 1
a1420 2
	       encode_newmap done encode_valid encode_typescheme M
	       )
d1425 1
a1425 1
      and encode_tyname(done, DataTypes.TYNAME(ti, s, n, ref b, ref ve)) =
d1444 1
a1444 1
		      tyn as DataTypes.METATYNAME(ref tf, s, n, ref b,
d1467 1
a1467 1
		      DataTypes.METATYVAR(arg as (ref(n, t), b1, b2))) =
d1482 1
a1482 1
      | encode_type(done, DataTypes.META_OVERLOADED(arg as ref t)) =
d1497 1
a1497 1
      | encode_type(done, DataTypes.TYVAR(ref n, t)) =
d1517 1
a1517 1
		    DataTypes.METARECTYPE(arg as ref(n, b1, t, b2, b3))) =
d1533 1
a1533 1
      | encode_type(done, arg as DataTypes.RECTYPE M) =
d1566 1
a1566 1
      | encode_type(done, full_arg as DataTypes.FUNTYPE(arg as (t1, t2))) =
d1601 1
a1601 1
      | encode_type(done, arg as DataTypes.CONSTYPE(l, t)) =
d1635 1
a1635 1
      | encode_type(done, DataTypes.DEBRUIJN(arg as (n, b1, b2))) =
d1649 1
a1649 1
      | encode_type(done, DataTypes.NULLTYPE) = output_byte 9 ::
d1653 1
a1653 1
      and encode_typescheme(done, DataTypes.SCHEME(n, t)) =
d1655 1
a1655 1
      | encode_typescheme(done, DataTypes.UNBOUND_SCHEME t) =
d1657 1
a1657 1
      | encode_typescheme(done, DataTypes.OVERLOADED_SCHEME ov) =
d1660 1
a1660 1
      and encode_tyfun(done, tyfun as DataTypes.TYFUN(t, n)) =
d1662 1
a1662 1
      | encode_tyfun(done, DataTypes.ETA_TYFUN tn) =
d1664 1
a1664 1
      | encode_tyfun(done, DataTypes.NULL_TYFUN tfi) =
d1667 2
a1668 8
      fun encode_tystr(done, DataTypes.TYSTR(tf, ve)) =
	(
(*
	 tystrs := !tystrs + 1;
	 diagnose_calls("encode_tystr done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_valenv(encode_tyfun(done, tf), ve)
	 )
d1670 2
a1671 8
      fun encode_tyenv(done, DataTypes.TE M) =
	(
(*
	 tyenvs := !tyenvs + 1;
	 diagnose_calls("encode_tyenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_newmap done encode_tycon encode_tystr M
	 )
d1673 2
a1674 8
      fun encode_str(done, DataTypes.STR(sn, e)) =
	(
(*
	 strs := !strs + 1;
	 diagnose_calls("encode_str done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_env(encode_strname(done, sn), e)
	 )
d1676 2
a1677 8
      and encode_strenv(done, DataTypes.SE M) =
	(
(*
	 strenvs := !strenvs + 1;
	 diagnose_calls("encode_strenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_newmap done encode_strid encode_str M
	 )
d1679 2
a1680 9
      and encode_env(done, DataTypes.ENV(se, te, ve, ece)) =
	(
(*
	 envs := !envs + 1;
	 diagnose_calls("encode_env done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_valenv(encode_valenv(encode_tyenv(encode_strenv(done, se), te),
				    ve), ece)
	 )
d1683 2
a1684 10
	(
(*
	 namesets := !namesets + 1;
	 diagnose_calls("encode_nameset done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_list
	 (encode_list done encode_tyname (Nameset.tynames_of_nameset ns))
	 encode_strname
	 (Nameset.strnames_of_nameset ns)
	)
d1687 1
a1687 7
	(
(*
	 sigmas := !sigmas + 1;
	 diagnose_calls("encode_sigma done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_str(encode_nameset(done, ns), s)
	 )
d1690 1
a1690 7
	(
(*
	 sigenvs := !sigenvs + 1;
	 diagnose_calls("encode_sigenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_newmap done encode_sigid encode_sigma M
	 )
d1693 1
a1693 7
	(
(*
	 phis := !phis + 1;
	 diagnose_calls("encode_phi done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_sigma(encode_str(encode_nameset(done, ns), s), sg)
	 )
d1696 1
a1696 7
	(
(*
	 funenvs := !funenvs + 1;
	 diagnose_calls("encode_funenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
*)
	 encode_newmap done encode_funid encode_phi M
	 )
d2096 3
a2098 3
	    1 => (DataTypes.UNARY, ptr)
	  | 2 => (DataTypes.BINARY, ptr)
	  | 3 => (DataTypes.PREDICATE, ptr)
d2142 1
a2142 2
	  (Lists.reducel
	   (fn (m, x) => Map.add(x, m, orderfn))
d2147 5
a2151 5
        let
          val (list, ptr) = decode_rev_list (decode_pair f g) ptr
        in
          (NewMap.from_list orderfn list, ptr)
        end
d2153 1
a2153 1
      val valenvs_decoded = ref [] : DataTypes.Valenv ref list ref
d2155 1
a2155 1
      val tyname_valenvs_decoded = ref [] : DataTypes.Valenv ref list ref
d2157 2
a2158 2
      val dummy_valenv = DataTypes.empty_valenv
      val tynames_decoded = ref [] : DataTypes.Tyname list ref
d2160 1
a2160 1
      val meta_tynames_decoded = ref [] : DataTypes.Tyname ref list ref
d2167 1
a2167 1
	ref (NewMap.empty decode_order) : (int, DataTypes.Tyname ref)NewMap.T ref
d2170 3
a2172 7
	DataTypes.METATYNAME(ref(DataTypes.TYFUN(DataTypes.NULLTYPE, 0)), "",
			     0, ref false, ref DataTypes.empty_valenv)
(*
      val types_decoded = ref [] : DataTypes.Type ref list ref
      val types_so_far = ref 0
*)
      val metatyvar_types_decoded = ref [] : DataTypes.Type ref list ref
d2174 1
a2174 1
      val meta_overloaded_types_decoded = ref [] : DataTypes.Type ref list ref
d2176 1
a2176 1
      val tyvar_types_decoded = ref [] : DataTypes.Type list ref
d2178 1
a2178 1
      val metarectype_types_decoded = ref [] : DataTypes.Type ref list ref
d2180 1
a2180 1
      val rectype_types_decoded = ref [] : DataTypes.Type ref list ref
d2182 1
a2182 1
      val funtype_types_decoded = ref [] : DataTypes.Type ref list ref
d2184 1
a2184 1
      val constype_types_decoded = ref [] : DataTypes.Type ref list ref
d2186 1
a2186 1
      val debruijn_types_decoded = ref [] : DataTypes.Type list ref
d2188 2
a2189 2
      val dummy_type = DataTypes.NULLTYPE
      val dummy_typescheme = DataTypes.UNBOUND_SCHEME DataTypes.NULLTYPE
d2191 3
a2193 3
	DataTypes.UNBOUND_SCHEME(DataTypes.FUNTYPE(DataTypes.NULLTYPE,
						   DataTypes.NULLTYPE))
      val dummy_constypescheme = DataTypes.UNBOUND_SCHEME(Types.int_type)
d2195 1
a2195 1
      val strnames_decoded = ref [] : DataTypes.Strname ref list ref
d2198 1
a2198 1
	DataTypes.NULLNAME (Strname_id.make_strname_n 0)
d2209 1
a2209 1
		(DataTypes.STRNAME id, ptr)
d2221 1
a2221 1
		    val _ = r := DataTypes.METASTRNAME (ref name)
d2235 1
a2235 1
		(DataTypes.NULLNAME id, ptr)
d2251 1
a2251 1
		(DataTypes.TYFUN(ty, i), ptr)
d2257 1
a2257 1
		(DataTypes.ETA_TYFUN tyname, ptr)
d2263 1
a2263 1
		(DataTypes.NULL_TYFUN tyfunid, ptr)
d2278 1
a2278 1
		(DataTypes.SCHEME(i, ty), ptr)
d2284 1
a2284 1
		(DataTypes.UNBOUND_SCHEME ty, ptr)
d2290 1
a2290 1
		(DataTypes.OVERLOADED_SCHEME over, ptr)
d2315 1
a2315 1
		    val ty = DataTypes.METATYVAR(ref(i, ty), b1, b2)
d2344 1
a2344 1
		    val ty = DataTypes.META_OVERLOADED(ref ty)
d2367 1
a2367 1
		    val ty = DataTypes.TYVAR(ref i, tyvar)
d2399 1
a2399 1
		    val ty = DataTypes.METARECTYPE(ref(i, b1, ty, b2, b3))
d2428 1
a2428 1
		    val ty = DataTypes.RECTYPE lab_map
d2453 1
a2453 1
		    val ty = DataTypes.FUNTYPE(ty1, ty2)
d2491 1
a2491 1
		    val ty = DataTypes.CONSTYPE(the_list, tyname)
d2515 1
a2515 1
		    val ty = DataTypes.DEBRUIJN(i, b1, b2)
d2532 1
a2532 1
	  | 9 => (DataTypes.NULLTYPE, ptr)
d2546 2
a2547 5
		decode_newmap decode_valid
		decode_typescheme
		ptr
		Environ.valid_order
	      val _ = r := DataTypes.VE(ref 0, valenv)
d2583 2
a2584 6
		      decode_newmap
		      decode_valid
		      decode_dummy_scheme
		      ptr
		      Environ.valid_order
		    val valenv = DataTypes.VE(ref 0, mapping)
d2628 1
a2628 1
		    val ty = DataTypes.TYNAME(tyname_id, st, i, ref b,
d2660 1
a2660 1
		      DataTypes.METATYNAME(ref tyfun, st, i, ref b, valenv)
d2679 1
a2679 1
	  (DataTypes.TYSTR(tyfun, !valenv), ptr)
d2685 1
a2685 1
	    decode_newmap decode_tycon decode_tystr ptr DataTypes.tycon_order
d2687 1
a2687 1
	  (DataTypes.TE tyenv, ptr)
d2697 1
a2697 1
	  (DataTypes.ENV(strenv, tyenv, !valenv, !exnenv), ptr)
d2705 1
a2705 1
	  (DataTypes.STR(strname, env), ptr)
d2713 1
a2713 1
	  (DataTypes.SE strenv, ptr)
d2879 1
a2879 2
	(NewMap.fold (fn (_, _, b) => (fun2 b)) ((), m);
	 ())
d2882 3
a2884 3
      fun reset_strname(DataTypes.STRNAME s) = reset_strname_id s
      | reset_strname(DataTypes.METASTRNAME s) = ()
      | reset_strname(DataTypes.NULLNAME s) = reset_strname_id s
d2886 1
a2886 1
      fun reset_valenv(DataTypes.VE(r, M)) =
d2897 1
a2897 1
      and reset_tyname(DataTypes.TYNAME(ti, s, n, r as ref b, ref ve)) =
d2900 1
a2900 1
      | reset_tyname(DataTypes.METATYNAME(ref tf, s, n, ref b, ref ve)) =
d2904 1
a2904 1
      and reset_type(DataTypes.METATYVAR(ref(n, t), b1, b2)) =
d2906 1
a2906 1
      | reset_type(DataTypes.META_OVERLOADED(ref t)) =
d2908 2
a2909 2
      | reset_type(DataTypes.TYVAR(ref n, t)) = ()
      | reset_type(DataTypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
d2911 1
a2911 1
      | reset_type(DataTypes.RECTYPE M) =
d2913 1
a2913 1
      | reset_type(DataTypes.FUNTYPE(t1, t2)) =
d2916 1
a2916 1
      | reset_type(DataTypes.CONSTYPE(l, t)) =
d2919 2
a2920 2
      | reset_type(DataTypes.DEBRUIJN(n, b1, b2)) = ()
      | reset_type(DataTypes.NULLTYPE) = ()
d2922 1
a2922 1
      and reset_typescheme(DataTypes.SCHEME(n, t)) =
d2924 1
a2924 1
      | reset_typescheme(DataTypes.UNBOUND_SCHEME t) =
d2926 1
a2926 1
      | reset_typescheme(DataTypes.OVERLOADED_SCHEME ov) = ()
d2928 1
a2928 1
      and reset_tyfun(DataTypes.TYFUN(t, n)) =
d2930 1
a2930 1
      | reset_tyfun(DataTypes.ETA_TYFUN tn) =
d2932 1
a2932 1
      | reset_tyfun(DataTypes.NULL_TYFUN tfi) = ()
d2934 1
a2934 1
      and reset_tystr(DataTypes.TYSTR(tf, ve)) =
d2938 1
a2938 1
      and reset_tyenv(DataTypes.TE M) =
d2941 1
a2941 1
      and reset_str(DataTypes.STR(sn, e)) =
d2945 1
a2945 1
      and reset_strenv(DataTypes.SE M) =
d2948 1
a2948 1
      and reset_env(DataTypes.ENV(se, te, ve, ece)) =
a2982 12
  fun encode_env {parser_env=p_env, ty_env=t_env, lambda_env=l_env,
		  tynames=tnames, strnames=snames, tyfuns=tyfuns} =
    let
      val p_size = delayed_string_list_size (p_env,0)
      val t_size = delayed_string_list_size (t_env,0)
      val l_size = delayed_string_list_size (l_env,0)
    in
      [optimised_output_int p_size, optimised_output_int t_size, optimised_output_int l_size,
       optimised_output_int tnames, optimised_output_int snames, optimised_output_int tyfuns, 
       p_env, t_env, l_env]
    end

d2986 3
a2988 3
      val (p_size, ptr) = optimised_input_int_and_strip(s, 0, s_size)
      val (t_size, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
      val (l_size, ptr) = optimised_input_int_and_strip(s, ptr, s_size)
a3011 10
  fun encode_cons x =
    delayed_extend_string_list
      (encode_list
       []
       (encode_pair
	encode_string
	(fn (done, (i, j)) =>
	 optimised_output_int j :: optimised_output_int i :: done))
       x)

a3013 1

d3057 287
a3343 1
  val header_size = 10*4
d3345 52
a3396 9
  fun do_output(file_handle,object) =
    let
      fun out([],[]) = ()
        | out([],h::t) = out(h,t)
        | out(STRING(x)::rest,rest') = 
          (output(file_handle,x); out(rest,rest'))
        | out(IMPLODE(_,x)::rest,rest') = out(x,rest::rest')
    in
      out([object],[])
d3399 1
a3399 31
  fun output_file
    (filename,
     TOTAL_OUTPUT{code = code, env = env_list, debug = debug,
		  consistency = cons}) =
    let
      val version = 2
      val file_handle = open_out filename
      val code_size = delayed_string_list_size (code,0)
      val env_size = Lists.reducel (fn (x, s) => x + delayed_string_list_size(s,0)) (0, env_list)
      val debug_size = delayed_string_list_size (debug,0)
      val cons_size = delayed_string_list_size (cons,0)
      val code_offset = header_size
      val env_offset = code_offset + code_size
      val debug_offset = env_offset + env_size
      val cons_offset = debug_offset + debug_size
      val header =
	make_implode
	[output_int ObjectFile.GOOD_MAGIC, output_int version,
	 (* Magic word plus version *)
	 output_int code_size, output_int code_offset,
	 output_int env_size, output_int env_offset,
	 output_int debug_size, output_int debug_offset,
	 output_int cons_size, output_int cons_offset]
      val _ = do_output(file_handle, header)
      val _ = do_output(file_handle, code)
      val _ = Lists.iterate (fn env => do_output(file_handle, env)) env_list
      val _ = do_output(file_handle, debug)
      val _ = do_output(file_handle, cons)
    in
      close_out file_handle
    end
@


1.48
log
@Better version of the output function for the delayed structure
@
text
@d4 6
d296 1
a296 1
  sharing Map = Interface.Map = ParserEnv.Map =
d306 2
a307 1
  sharing Debugger_Types.Map = EnvironTypes.NewMap
d740 2
d743 4
a746 4
    encode_list
    done
    (encode_pair f g)
    (NewMap.to_list x)
d892 1
a892 1
	  encode_map
a893 5
(*
	  (encode_list
	   (encode_list done encode_valid' v_list)
	   encode_valid' e_list)
*)
d1196 1
a1196 1
	    decode_map
d1200 1
a1200 2
	    Ident.strid_eq
	    Ident.strid_order
d1853 1
a1853 1
		  encode_map done encode_valid encode_fun_or_cons M
a1857 14
(*
	      fun ev'(h::t) = if h = r then Lists.length t + 1
			      else ev' t
	      | ev' [] =
		(tyname_valenvs_encoded := (r::(!tyname_valenvs_encoded)); 0)
	      val pos = ev'(!tyname_valenvs_encoded)
	      val done = optimised_output_int pos :: output_byte 2 :: done
	    in
	      if pos = 0 then
		encode_map done encode_valid encode_fun_or_cons M
	      else
		done
	    end
*)
a1863 4
(*
	  val _ = diagnose_calls("encode_valenv done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = valenvs := !valenvs + 1
*)
d1873 1
a1873 1
	       encode_map done encode_valid encode_typescheme M
d2136 1
a2136 1
	 encode_map done encode_tycon encode_tystr M
d2154 1
a2154 1
	 encode_map done encode_strid encode_str M
d2194 1
a2194 1
	 encode_map done encode_sigid encode_sigma M
d2212 1
a2212 1
	 encode_map done encode_funid encode_phi M
d2664 7
d2675 1
a2675 1
      val dummy_valenv = Valenv.empty_valenv
d2689 1
a2689 1
			     0, ref false, ref Valenv.empty_valenv)
d3068 1
a3068 1
		decode_map decode_valid
d3071 1
a3071 2
		Ident.valid_eq
		Ident.valid_order
d3108 1
a3108 1
		      decode_map
d3112 1
a3112 10
		      Ident.valid_eq
		      Ident.valid_order
(*
		    val mapping =
		      Lists.reducel
		      (fn (valenv, valid) =>
		       Map.add((valid, dummy_typescheme), valenv,
			       Ident.valid_order))
		      (Map.empty_eqfunmap Ident.valid_eq, dom)
*)
a3113 7
(*
		    val _ =
		      Print.print
		      ("Decoded map with domain\n" ^
		       Map.print_map(mapping, DataTypes.IdentPrint.printValId,
				     fn _ => "", "\n"))
*)
d3214 1
a3214 2
	    decode_map decode_tycon decode_tystr ptr Ident.tycon_eq
	    Ident.tycon_order
d3240 1
a3240 2
	    decode_map decode_strid decode_str ptr Ident.strid_eq
	    Ident.strid_order
d3264 1
a3264 2
	    decode_map decode_sigid decode_sigma ptr Ident.sigid_eq
	    Ident.sigid_order
d3281 1
a3281 2
	    decode_map decode_funid decode_phi ptr Ident.funid_eq
	    Ident.funid_order
d3407 3
d3424 1
a3424 1
	     reset_map_range reset_typescheme M)
d3469 1
a3469 1
	reset_map_range reset_tystr M
d3476 1
a3476 1
	reset_map_range reset_str M
d3489 1
a3489 1
	reset_map_range reset_sigma M
d3497 1
a3497 1
	reset_map_range reset_phi M
@


1.47
log
@Use of new hash tables, removed some concatenation and compression of integers in encapsulator
@
text
@d4 3
d406 1
a406 2
    CONCAT of int * DelayedEvaluation * DelayedEvaluation
  | IMPLODE of int * DelayedEvaluation list
a407 1
  | IMPLODE_REVERSE of int * DelayedEvaluation list
a410 2
    | get_length(CONCAT(x,_,_)) = x
    | get_length(IMPLODE_REVERSE(x,_)) = x
d412 2
a413 1
  fun make_concat(x,y) = CONCAT(get_length x + get_length y,x,y)
d499 1
a499 1
  fun output_int i =
d503 3
a505 1
      STRING(implode(make_list([], 4, i)))
d581 1
a581 1
  fun delayed_extend_string s = make_concat(STRING s,STRING(extra_string(size s)))
a583 1
    | delayed_string_list_size(CONCAT(len,a,b),acc) = len + acc
a584 1
    | delayed_string_list_size(IMPLODE_REVERSE (len,x),acc) = len + acc
d593 1
a593 1
      IMPLODE_REVERSE(size extra + s,STRING(extra) :: l)
d623 2
a624 2
	   (fn (i, spills, w) => make_concat(make_concat(output_int i,output_int(4+size w)),
                                             make_concat(output_int(spills),STRING w)))
d3640 5
a3644 12
      fun do_output_elem(STRING x) = output(file_handle,x)
        | do_output_elem(CONCAT(_,a,b)) = (do_output_elem a;
                                         do_output_elem b)
        | do_output_elem(IMPLODE (_,x)) =
          (map do_output_elem x ; ())
        | do_output_elem(IMPLODE_REVERSE (_,x)) = 
          let
            fun rev([],acc) = (map do_output_elem acc;())
              | rev (h::t,acc) = rev(t,h::acc)
          in
            rev(x,[])
          end
d3646 1
a3646 1
      do_output_elem object
@


1.46
log
@Added three : int annotations required by our compiler
@
text
@d4 3
a227 1
require "../utils/hashtable";
d311 1
d319 11
d341 1
a341 3
	  Lists.reducel
	  (fn (x, y) => x + ord y)
	  (size str, explode str)
d357 1
a357 3
	  Lists.reducel
	  (fn (x, y) => x + ord y)
	  (size str, explode str)
d377 1
a377 3
	  Lists.reducel
	  (fn (x, y) => x + ord y)
	  (size str, explode str)
d397 1
a397 3
	  Lists.reducel
	  (fn (x, y) => x + ord y)
	  (size str, explode str)
d402 20
d435 2
a436 1
    {code : string, env : string list, debug : string, consistency : string}
d438 5
d467 2
a468 1
  val print_stats = true
d470 4
a474 8
  fun find_total_length x=
    let
      fun find_length(acc,[]) = acc
        | find_length(acc,h::t) = find_length(acc + size h,t)
    in
      find_length(0,x)
    end

d492 1
a492 1
      chr i
d503 1
a503 21
      implode(make_list([], 4, i))
      
  fun undo_list[a,b,c,d] =
    256*(256*(256*ord a + ord b) + ord c) + ord d
    | undo_list _ = raise bad_input
(*
  fun undo_list(value, []) = value
  | undo_list(value, x :: xs) = undo_list(value * 256 + ord x, xs)
*)
(*
    handle
    Sum =>
      (diagnose_consistency("Sum overflow on " ^
			    Integer.makestring value ^ " * 256 + " ^
			    Integer.makestring(ord x));
       raise bad_input1)
  | Prod => (diagnose_consistency("Product overflow on " ^
				  Integer.makestring value ^ " * 256 + " ^
				  Integer.makestring(ord x));
	     raise bad_input2)
*)
d505 22
a526 2
  fun input_int(s, ptr, len) =
    if len < ptr+4 then
d529 5
a533 5
      let
	val x = explode(String.substring(s, ptr, 4))
      in
	undo_list x
      end
d537 1
a537 1
      val answer = input_int(s, ptr, len)
d542 11
d579 17
d605 1
a605 1
	implode
d607 1
a607 1
	 output_int(size r div 4), r]
d609 1
a609 1
	implode
d611 1
a611 1
	 output_int(size s + 1), extend_string s]
d619 1
a619 1
	  implode
d623 2
a624 1
	   (fn (i, spills, w) => output_int i ^ output_int(4+size w) ^ output_int(spills) ^ w)
d628 1
a628 1
	implode
d630 1
a630 1
	 output_int(size s + 1), extend_string s]
d648 1
a648 1
      implode
d662 2
a663 2
  fun encode_bool false = chr 0
  | encode_bool true = chr 1
d666 1
a666 10
    (
(*
     diagnose_sizes("Encode_string size : " ^ Integer.makestring(size s) ^ "\n");
     if size s > 100 then
       diagnose_sizes("Big string : '" ^ String.substring(s, 0, 100) ^ "\n")
     else
       ();
*)
    s :: output_int(size s) :: done
    )
d668 1
d677 1
a677 1
    output_int index :: output_int 0 :: done
d679 1
a679 1
      output_int (Pervasives.encode x) :: output_int 1 :: done
d683 1
a683 1
    output_int index :: done
d723 1
a723 1
  fun encode_tyfun_id n = output_int(Tyfun_id.tyfun_id n)
d728 1
a728 1
     rev_map (output_int(Lists.length x) :: done) f x
d785 1
a785 1
	  val done = output_int vnum :: output_int env_len :: done
d813 1
a813 1
	  val done = output_int enum :: encoded_v_list
d864 1
a864 1
	  val done = output_int vnum :: done
d878 1
a878 1
	  val done = output_int enum :: done
d898 13
d912 1
a912 7
      implode
      (rev
       (extend_string_list
	(encode_sub f_len
	 (encode_newmap [output_int(f_len + env_len)] encode_funid
	  do_ftr_range fun_env, env
	  ))))
d940 1
a940 1
      val (total_size, ptr) = input_int_and_strip(s, from, size s)
d944 1
a944 1
	  val (sy_size, ptr) = input_int_and_strip(s, ptr, len)
d987 1
a987 1
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
d1009 1
a1009 1
          val (count, ptr) = input_int_and_strip(s, ptr, len)
d1032 1
a1032 1
	  val (env_size, ptr) = input_int_and_strip(s, ptr, len)
d1035 1
a1035 1
	      val (offset, ptr) = input_int_and_strip(s, ptr, len)
d1040 1
a1040 1
                     val (offset, ptr) = input_int_and_strip(s, ptr, len)
d1046 1
a1046 1
                     val (offset, ptr) = input_int_and_strip(s, ptr, len)
d1055 1
a1055 1
	      val (valnum, ptr) = input_int_and_strip(s, ptr, len)
d1082 1
a1082 1
	      val (exnnum, ptr) = input_int_and_strip(s, ptr, len)
d1139 1
a1139 1
	  val (valnum, ptr) = input_int_and_strip(s, ptr, len)
d1165 1
a1165 1
	  val (exnnum, ptr) = input_int_and_strip(s, ptr, len)
d1204 1
a1204 1
	  val (offset, ptr) = input_int_and_strip(s, ptr, len)
d1294 1
a1294 1
	      (output_int 0 :: done)
d1298 1
a1298 1
	  | n => output_int n :: done
d1313 1
a1313 1
	      (output_int 0 :: encoded_fixity)
d1316 1
a1316 1
	  | n => output_int n :: encoded_fixity
d1320 1
a1320 13
(*
	(encode_list
	 (
	 encoded_fixity
	  encode_map
	  done
	  encode_symbol
	  encode_fixity
	  fix_map
	  )
	 (fn (done, (_, x)) => encode_valid(done, x))
	 (Map.assoc val_map))
*)
d1326 1
a1326 1
	val str_list =
d1330 1
a1330 1
	   extend_string_list
d1342 7
a1348 8
	val rev_list =
	  Timer.xtime
	  ("reversing list", !do_timings, fn () => rev str_list)
(*
	val _ =
	  Print.print("Number of distinct value environments = " ^
		      Integer.makestring(!val_map_size) ^ "\n")
*)
d1350 1
a1350 1
      Timer.xtime("imploding list", !do_timings, fn () => implode rev_list)
d1372 2
a1373 2
      fun input_int_and_strip ptr =
	(undo_list(explode(String.substring(s, ptr, 4))), ptr+4)
d1380 1
a1380 1
	  val (sy_size, ptr) = input_int_and_strip ptr
d1458 1
a1458 1
	  val (count, ptr) = input_int_and_strip ptr
d1474 1
a1474 1
	  val (fixnum, ptr) = input_int_and_strip ptr
d1502 1
a1502 1
	  val (valnum, ptr) = input_int_and_strip ptr
d1532 1
a1532 8
(*
	    decode_map
	    decode_symbol
	    decode_fixity
	    ptr
	    Symbol.eq_symbol
	    Symbol.symbol_order
*)
d1534 1
a1534 9
(*
	    decode_rev_list
	    decode_valid
	    ptr
	  val val_env =
	    Lists.reducel
	    (fn (pve, valid) => ParserEnv.addValId(valid, pve))
	    (ParserEnv.empty_pVE, val_env)
*)
d1562 1
d1571 5
a1575 28
      val _ = Enc_Sub.TynameHashTable.clear()
      val _ = Enc_Sub.FuntypeHashTable.clear()
      val _ = Enc_Sub.ConstypeHashTable.clear()
      val _ = Enc_Sub.RectypeHashTable.clear()
      val _ = Enc_Sub.ValenvHashTable.clear()
(*
      val tyname_ids = ref 0
      val strname_ids = ref 0
      val strnames = ref 0
      val valenvs = ref 0
      and tynames = ref 0
      and meta_tynames = ref 0
      and types = ref 0
      and typeschemes = ref 0
      and tyfuns = ref 0
      and tystrs = ref 0
      and tyenvs = ref 0
      and strs = ref 0
      and strenvs = ref 0
      and envs = ref 0
      and sigmas = ref 0
      and sigenvs = ref 0
      and phis = ref 0
      and funenvs = ref 0
      and namesets = ref 0
      and tyname_extra = ref 0
      and extra_tynames = ref 0
*)
a1576 13
(*
      fun search_tyname(n:int) =
	let
	  fun search nil = Crash.impossible ("tyname_module")
	    | search ((module,tyname_count,_)::rest) = 
	      if n < tyname_count 
		then
		  search rest
	      else
		(module,tyname_count,rest)
	in
	  search
	end
a1577 14
      fun search_strname(n : int) =
	let
	  fun search nil = Crash.impossible ("strname_module")
	    | search ((module,_,strname_count)::rest) = 
	      if n < strname_count 
		then
		  search rest
	      else
		(module,strname_count,rest)
	in
	  search
	end
*)

d1710 1
a1710 1
	       output_int id :: output_byte 0 :: done
d1721 1
a1721 1
		  output_int id' :: output_byte 1 :: done
d1723 1
a1723 1
		output_int id' :: encode_string (output_byte 2 :: done, module)
d1737 1
a1737 1
	      output_int id :: output_byte 0 :: done
d1744 1
a1744 1
		  output_int id' :: output_byte 1 :: done
d1746 1
a1746 1
		output_int id' :: encode_string (output_byte 2 :: done, module)
d1764 1
a1764 1
	       output_int id :: output_byte 0 :: done
d1775 1
a1775 1
		  output_int id' :: output_byte 1 :: done
d1777 1
a1777 1
		output_int id' :: encode_string (output_byte 2 :: done, module)
d1801 1
a1801 1
	  val done = output_int n :: output_byte 2 :: done
d1840 1
a1840 1
		(Enc_Sub.ValenvHashTable.lookup valenv)
d1842 1
a1842 1
	      val done = output_int pos :: output_byte 2 :: done
d1848 1
a1848 1
		  val _ = Enc_Sub.ValenvHashTable.update(valenv, c)
d1861 1
a1861 1
	      val done = output_int pos :: output_byte 2 :: done
d1870 1
a1870 1
	    output_int n :: output_byte 1 :: done
d1880 1
a1880 1
	  val done = output_int n :: done
d1902 1
a1902 1
	  val done = output_int pos :: output_byte 1 :: done
d1905 1
a1905 1
	    encode_tyname_valenv(encode_bool b :: output_int n ::
d1917 1
a1917 1
	    (Enc_Sub.TynameHashTable.lookup tyn)
d1919 1
a1919 1
	  val done = output_int pos :: output_byte 2 :: done
d1925 1
a1925 1
	      val _ = Enc_Sub.TynameHashTable.update(tyn, c)
d1927 1
a1927 1
	      encode_tyname_valenv(encode_bool b :: output_int n ::
d1943 1
a1943 1
	  val done = output_int pos :: output_byte 1 :: done
d1947 1
a1947 1
	    encode_type(output_int n :: done, t)
d1959 1
a1959 1
	  val done = output_int pos :: output_byte 2 :: done
d1978 1
a1978 1
	  val done = output_int pos :: output_byte 3 :: done
d1981 1
a1981 1
	    encode_tyvar(output_int n :: done, t)
d1994 1
a1994 1
	  val done = output_int pos :: output_byte 4 :: done
d1998 1
a1998 1
	    encode_type(encode_bool b1 :: output_int n :: done, t)
d2010 1
a2010 1
	  val done = output_int pos :: output_byte 5 :: done
d2020 1
a2020 1
	    Enc_Sub.RectypeHashTable.lookup arg
d2022 1
a2022 1
	  val done = output_int pos :: output_byte 5 :: done
d2028 1
a2028 1
	      val _ = Enc_Sub.RectypeHashTable.update(arg, c)
d2045 1
a2045 1
	  val done = output_int pos :: output_byte 6 :: done
d2055 1
a2055 1
	    Enc_Sub.FuntypeHashTable.lookup full_arg
d2057 1
a2057 1
	  val done = output_int pos :: output_byte 6 :: done
d2063 1
a2063 1
	      val _ = Enc_Sub.FuntypeHashTable.update(full_arg, c)
d2079 1
a2079 1
	  val done = output_int pos :: output_byte 7 :: done
d2089 1
a2089 1
	    Enc_Sub.ConstypeHashTable.lookup arg
d2091 1
a2091 1
	  val done = output_int pos :: output_byte 7 :: done
d2097 1
a2097 1
	      val _ = Enc_Sub.ConstypeHashTable.update(arg, c)
d2111 1
a2111 1
	  val done = output_int pos :: output_byte 8 :: done
d2114 1
a2114 1
	    encode_bool b2 :: encode_bool b1 :: output_int n :: done
d2123 1
a2123 1
	encode_type(output_int n :: output_byte 1 :: done, t)
d2130 1
a2130 1
	output_int n :: encode_type(output_byte 1 :: done, t)
d2230 1
a2230 1
      fun encode_int(done,i) = output_int i :: done
d2353 18
a2370 3
      val rev_result =
	Timer.xtime("reversing list", !do_timings,
		    fn () => rev(extend_string_list result))
d2372 1
a2372 2
      Timer.xtime
      ("imploding rev_result", !do_timings, fn () => implode rev_result)
d2377 3
a2379 7
(*
      val _ = Enc_Sub.DecRectypeHashTable.clear()
*)
      val _ = Enc_Sub.DecFuntypeHashTable.clear()
(*
      val _ = Enc_Sub.DecConstypeHashTable.clear()
*)
d2391 2
a2392 2
      fun input_int_and_strip ptr =
	(undo_list(explode(String.substring(s, ptr, 4))), ptr+4)
d2394 1
d2426 1
a2426 1
	  val (sy_size, ptr) = input_int_and_strip ptr
d2505 1
a2505 1
		val (n, ptr) = input_int_and_strip ptr
d2513 1
a2513 1
		val (n, ptr) = input_int_and_strip ptr
d2525 1
a2525 1
		val (n, ptr) = input_int_and_strip ptr
d2546 1
a2546 1
		val (n, ptr) = input_int_and_strip ptr
d2554 1
a2554 1
		val (n, ptr) = input_int_and_strip ptr
d2566 1
a2566 1
		val (n, ptr) = input_int_and_strip ptr
d2581 1
a2581 1
	  val (n ,ptr) = input_int_and_strip ptr
d2596 1
a2596 1
		val (n, ptr) = input_int_and_strip ptr
d2604 1
a2604 1
		val (n, ptr) = input_int_and_strip ptr
d2613 1
a2613 1
		val (n, ptr) = input_int_and_strip ptr
d2643 1
a2643 1
	  val (count, ptr) = input_int_and_strip ptr
d2665 1
a2665 1
	  val (count, ptr) = input_int_and_strip ptr
d2743 1
a2743 1
		val (n, ptr) = input_int_and_strip ptr
d2779 1
a2779 1
		val (i, ptr) = input_int_and_strip ptr
d2805 1
a2805 1
		val (i, ptr) = input_int_and_strip ptr
d2832 1
a2832 1
		val (i, ptr) = input_int_and_strip ptr
d2841 1
a2841 1
		    val (i, ptr) = input_int_and_strip ptr
d2862 1
a2862 1
		val (i, ptr) = input_int_and_strip ptr
d2891 1
a2891 1
		val (i, ptr) = input_int_and_strip ptr
d2895 1
a2895 1
		    val (i, ptr) = input_int_and_strip ptr
d2914 1
a2914 1
		val (i, ptr) = input_int_and_strip ptr
d2924 1
a2924 1
		    val (i, ptr) = input_int_and_strip ptr
d2946 1
a2946 1
		val (i, ptr) = input_int_and_strip ptr
d2975 1
a2975 1
		val (i, ptr) = input_int_and_strip ptr
d2984 1
a2984 1
		    val _ = Enc_Sub.DecFuntypeHashTable.update(c, ty)
d2997 1
a2997 1
		  (Enc_Sub.DecFuntypeHashTable.lookup i, ptr)
d3010 1
a3010 1
		val (i, ptr) = input_int_and_strip ptr
d3038 1
a3038 1
		val (i, ptr) = input_int_and_strip ptr
d3042 1
a3042 1
		    val (i, ptr) = input_int_and_strip ptr
d3068 1
a3068 1
	  val (n, ptr) = input_int_and_strip ptr
d3112 1
a3112 1
		val (n, ptr) = input_int_and_strip ptr
d3173 1
a3173 1
		val (n, ptr) = input_int_and_strip ptr
d3179 1
a3179 1
		    val (i, ptr) = input_int_and_strip ptr
d3198 1
a3198 1
		val (n, ptr) = input_int_and_strip ptr
d3210 1
a3210 1
		    val (i, ptr) = input_int_and_strip ptr
d3316 1
a3316 1
        input_int_and_strip ptr
d3379 1
a3379 1
	  val (count, ptr) = input_int_and_strip ptr
d3392 12
a3403 10
        decode_newmap 
        decode_string 
        (decode_pair 
         decode_type
         (decode_list (decode_pair decode_int decode_recipe)))
        ptr
        (fn (x,y) => 
         if x=y
           then NewMap.EQUAL
         else if String.<(x,y)
d3405 5
a3409 2
              else NewMap.GREATER)
        
d3411 1
d3413 1
d3415 1
d3417 1
d3419 9
d3429 1
a3429 1
      (Basis.BASIS(nameset, funenv, sigenv, env),debug_information)
d3542 3
a3544 6
      val p_size = size p_env
      val t_size = size t_env
      val l_size = size l_env
      val p_offset = 24
      val t_offset = p_offset + p_size
      val l_offset = t_offset + t_size
d3546 3
a3548 3
      [output_int p_offset, output_int t_offset, output_int l_offset,
       output_int tnames, output_int snames, output_int tyfuns, p_env, t_env,
       l_env]
d3554 6
a3559 9
      val (p_offset, ptr) = input_int_and_strip(s, 0, s_size)
      val (t_offset, ptr) = input_int_and_strip(s, ptr, s_size)
      val (l_offset, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tnames, ptr) = input_int_and_strip(s, ptr, s_size)
      val (snames, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tyfuns, ptr) = input_int_and_strip(s, ptr, s_size)
      val p_size = t_offset - p_offset
      val t_size = l_offset - t_offset
      val l_size = s_size - l_offset
d3561 3
a3563 3
      {parser_env= (s, p_offset, p_size),
       ty_env= (s, t_offset, t_size),
       lambda_env= (s, l_offset, l_size),
d3570 6
a3575 6
      val (_, ptr) = input_int_and_strip(s, 0, s_size)
      val (_, ptr) = input_int_and_strip(s, ptr, s_size)
      val (_, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tnames, ptr) = input_int_and_strip(s, ptr, s_size)
      val (snames, ptr) = input_int_and_strip(s, ptr, s_size)
      val (tyfuns, ptr) = input_int_and_strip(s, ptr, s_size)
d3581 1
a3581 3
    implode
    (rev
     (extend_string_list
d3587 2
a3588 2
	 output_int j :: output_int i :: done))
       x)))
d3592 1
d3597 1
a3597 1
	  val (sy_size, ptr) = input_int_and_strip(s, ptr, len)
d3603 1
a3603 1
      fun decode_int ptr = input_int_and_strip(s, ptr, len)
d3614 1
a3614 1
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
d3627 5
d3633 1
a3633 3
      #1 (decode_list
	  (decode_pair decode_string (decode_pair decode_int decode_int))
	  0)
d3638 18
d3663 4
a3666 4
      val code_size = size code
      val env_size = Lists.reducel (fn (x, s) => x + size s) (0, env_list)
      val debug_size = size debug
      val cons_size = size cons
d3672 1
a3672 1
	implode
d3679 5
a3683 5
      val _ = output(file_handle, header)
      val _ = output(file_handle, code)
      val _ = Lists.iterate (fn env => output(file_handle, env)) env_list
      val _ = output(file_handle, debug)
      val _ = output(file_handle, cons)
d3723 1
a3723 1
       TOTAL_OUTPUT{code = code, env = [env], debug = debug,
@


1.45
log
@Modified to observe commonality within parser environments and
code generation environments in order to reduce encoding/decoding time
and size of encoded objects
@
text
@d4 5
d875 1
a875 1
	  val len = from + len
d1320 1
a1320 1
	  val len = from + len
d2393 1
a2393 1
	  val len = from + len
@


1.44
log
@Change in sharing constraint to reflect change in debugger_types
@
text
@d4 3
d221 1
d311 17
d329 62
d404 1
a404 1
    {code : string, env : string, debug : string, consistency : string}
d429 1
a429 1
  val do_timings = false
d693 8
d710 2
a711 2
	  val v_list = NewMap.to_list v_map
	  val e_list = NewMap.to_list e_map
d718 56
d776 1
d783 1
d787 4
d798 41
a838 7
	encode_map
	(encode_list
	 (encode_list done encode_valid' v_list)
	 encode_valid' e_list)
	encode_strid
	encode_interface
	s_map
d853 1
a853 1
  fun decode_lambda_env s =
d855 25
a879 2
      val len = size s
      val (total_size, ptr) = input_int_and_strip(s, 0, size s)
d991 54
d1046 2
d1053 1
d1055 4
d1064 1
d1077 21
d1102 22
d1128 1
d1165 17
d1192 64
d1257 2
d1260 3
a1262 1
	 (encode_map
d1266 5
a1270 3
	  fix_map)
	 encode_valid
	 (Map.range val_map))
d1274 2
d1278 1
a1278 1
	  ("building parser env list", do_timings,
d1294 6
a1299 1
	  ("reversing list", do_timings, fn () => rev str_list)
d1301 1
a1301 1
      Timer.xtime("imploding list", do_timings, fn () => implode rev_list)
d1304 1
a1304 1
  fun decode_parser_env s =
d1306 16
a1321 1
      val len = size s
d1423 57
d1482 2
a1483 1
	  val (fix_env, ptr) =
d1490 3
a1492 1
	  val (val_env, ptr) =
d1500 1
d1517 1
a1517 1
	0
d2279 1
a2279 1
	("encode_nameset", do_timings, fn () => encode_nameset([], nameset))
d2283 1
a2283 1
	("encode_funenv", do_timings, fn () => encode_funenv(result, funenv))
d2287 1
a2287 1
	("encode_sigenv", do_timings, fn () => encode_sigenv(result, sigenv))
d2291 1
a2291 1
	("encode_env", do_timings, fn () => encode_env(result, env))
d2301 1
a2301 1
	("encode debug info", do_timings, fn () => encode_debug(result, debug_information))
d2369 1
a2369 1
	Timer.xtime("reversing list", do_timings,
d2373 1
a2373 1
      ("imploding rev_result", do_timings, fn () => implode rev_result)
d2376 1
a2376 1
  fun decode_type_basis (s,sub_modules) =
d2385 10
a2394 1
      val len = size s
d3409 1
a3409 1
      val (nameset, ptr) = decode_nameset 0
a3534 1
      implode
d3553 3
a3555 3
      {parser_env=String.substring(s, p_offset, p_size),
       ty_env=String.substring(s, t_offset, t_size),
       lambda_env=String.substring(s, l_offset, l_size),
d3587 1
d3630 2
a3631 1
     TOTAL_OUTPUT{code = code, env = env, debug = debug, consistency = cons}) =
d3636 1
a3636 1
      val env_size = size env
d3653 1
a3653 1
      val _ = output(file_handle, env)
d3695 2
a3696 1
       TOTAL_OUTPUT{code = code, env = env, debug = debug, consistency = cons})
@


1.43
log
@Added an element to the recipe type so needed to change encapsulator
@
text
@d4 3
d285 1
a285 1
    Debugger_Types.Types.Datatypes
d1807 2
a1808 1
      val length1 = if print_stats
d1811 1
d1817 1
d1827 1
a1827 1

@


1.42
log
@Added call point information recording
@
text
@d4 3
d176 1
a176 1
way, using their ref bool)) to save volume of output (a 3-fold saving
d344 1
d346 9
d1764 1
a1764 1
             encode_list (output_byte 2::done) encode_recipe args
d1777 2
a1778 1
            (output_byte 7::done,arg))
d1803 5
d1811 11
d2835 1
a2835 1
                val (args,ptr) = decode_list decode_recipe ptr
d2869 1
@


1.41
log
@Added furhter constructors to the module element type to express
interpretive stuff
@
text
@d4 4
d232 1
a244 1
  structure NewMap : NEWMAP
d268 1
a272 1
  sharing EnvironTypes.NewMap = NewMap
d278 3
a280 1
    Nameset.Datatypes = Valenv.Datatypes = Types.Datatypes = Enc_Sub.DataTypes
d299 2
d713 20
a732 13
	let
	  fun dec_sub(0, ptr, done) = (done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
	in
	  dec_sub(count, ptr, [])
	end

d735 1
a735 1
	  val (assoc_list, ptr) = decode_rev_list (decode_pair f g) ptr
a741 7
      fun decode_newmap f g ptr orderfn =
	let
	  val (list, ptr) = decode_rev_list (decode_pair f g) ptr
	in
	  (NewMap.from_list orderfn list, ptr)
	end

d766 1
a766 1
	    decode_newmap
d772 1
a772 1
	    decode_newmap
d1743 23
d1767 5
a1771 2
        encode_list done
        (encode_pair encode_string encode_type)
a1772 1
 
d1774 1
a1774 1
      val result =
d2788 2
a2789 1
       val decode_debug = decode_list (decode_pair decode_string decode_type)
d2791 86
@


1.40
log
@Added decode_counts functions to speed up subrequiresd
@
text
@d4 3
d461 8
@


1.39
log
@Added the encapsulation of function debugging information
@
text
@d4 3
d2895 13
@


1.38
log
@changed to use newmap
@
text
@d4 3
d1009 1
d1721 6
d1742 3
d2741 2
d2746 2
a2747 1
      val (env, _) = decode_env ptr
d2749 1
a2749 1
      Basis.BASIS(nameset, funenv, sigenv, env)
@


1.37
log
@Changed version number to two for update of magic number
@
text
@d4 3
d215 1
d250 1
d256 1
a256 1
  sharing Map = EnvironTypes.Map = Interface.Map = ParserEnv.Map =
d258 2
a548 3
(*
     diagnose_sizes("Encoding list length : " ^ Integer.makestring(length x) ^ "\n");
*)
d554 6
d569 1
a569 1
      val f_map = Map.assoc fun_env
d571 3
a573 3
      val v_len = Lists.length(Map.assoc v)
      val e_len = Lists.length(Map.assoc e)
      val s_len = Lists.length(Map.assoc s)
d578 3
a580 3
	  val v_list = Map.assoc v_map
	  val e_list = Map.assoc e_map
	  val s_list = Map.assoc s_map
d587 3
a589 3
	  encode_map
	  (encode_map
	   (encode_map
d620 1
a620 1
	 (encode_map [output_int(f_len + env_len)] encode_funid
d710 7
d741 1
a741 1
	    decode_map
d745 1
a745 2
	    Ident.valid_eq
	    Ident.valid_order
d747 1
a747 1
	    decode_map
d751 1
a751 2
	    Ident.valid_eq
	    Ident.valid_order
d753 1
a753 1
	    decode_map
d757 1
a757 2
	    Ident.strid_eq
	    Ident.strid_order
d794 1
a794 1
	decode_map
d798 1
a798 2
	Ident.funid_eq
	Ident.funid_order
@


1.36
log
@Some minor improvements and revisions. Fixity is now a byte
@
text
@d4 3
d2924 1
d2936 1
a2936 1
	[output_int ObjectFile.GOOD_MAGIC, output_int 1,
@


1.35
log
@Add integer parameter to functor. Removed references to pervasive length.
Added type specifier to resolve some +
@
text
@d4 4
d184 1
d216 1
d313 2
d345 4
d351 2
d363 1
d372 1
a372 1
	undo_list(0, x)
d386 1
a386 1
      (ord(String.substring(s, ptr, 1)), ptr + 1)
d389 1
d393 1
d465 2
a466 2
  fun encode_bool false = "f"
  | encode_bool true = "t"
d793 1
a793 1
	output_int i :: output_byte 0 :: done
d795 1
a795 1
	output_int i :: output_byte 1 :: done
d814 19
d834 1
a834 14
      implode
      (rev
       (extend_string_list
	(encode_pe
	 ((encode_map
	   (encode_map
	    []
	    encode_funid
	    encode_pe
	    fun_map)
	   encode_sigid
	   encode_pe
	   sig_map),
	  parse_env))))
d840 7
d849 2
a850 2
	  val (sy_size, ptr) = input_int_and_strip(s, ptr, len)
	  val sy = Symbol.find_symbol(input_string(s, ptr, sy_size, len))
d857 1
a857 1
	  val (sy_type, ptr) = input_byte(s, ptr, len)
d891 1
a891 1
	  val (fixity, ptr) = input_byte(s, ptr, len)
d896 1
a896 1
		val (prec, ptr) = input_int_and_strip(s, ptr, len)
d902 1
a902 1
		val (prec, ptr) = input_int_and_strip(s, ptr, len)
a909 14
      fun decode_list f ptr =
	let
	  fun dec_sub(0, ptr, done) = (rev done, ptr)
	  | dec_sub(n, ptr, done) =
	    let
	      val (d, ptr) = f ptr
	    in
	      dec_sub(n-1, ptr, d :: done)
	    end
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
	in
	  dec_sub(count, ptr, [])
	end

d927 1
a927 1
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
d951 1
a951 1
	    decode_list
d1701 3
a1703 1
      val result = encode_nameset([], nameset)
d1705 3
a1707 1
      val result = encode_funenv(result, funenv)
d1709 3
a1711 1
      val result = encode_sigenv(result, sigenv)
d1713 3
a1715 1
      val result = encode_env(result, env)
d1770 3
d1774 2
a1775 1
      implode(rev(extend_string_list result))
d1789 6
d1816 4
a1819 7
	if ptr >= len then
	  raise bad_input20
	else
	  case String.substring(s,ptr, 1) of
	    "f" => (false, ptr+1) 
	  | "t" => (true, ptr+1) 
	  | _ => raise bad_input6
d1823 2
a1824 2
	  val (sy_size, ptr) = input_int_and_strip(s, ptr, len)
	  val sy = (input_string(s, ptr, sy_size, len))
d1838 1
a1838 1
	  val (sy_type, ptr) = input_byte(s, ptr, len)
d1895 1
a1895 1
	  val (i, ptr) = input_byte(s, ptr, len)
d1902 1
a1902 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1910 1
a1910 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1922 1
a1922 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1936 1
a1936 1
	  val (i, ptr) = input_byte(s, ptr, len)
d1943 1
a1943 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1951 1
a1951 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1963 1
a1963 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d1978 1
a1978 1
	  val (n ,ptr) = input_int_and_strip(s, ptr, len)
d1986 1
a1986 1
	  val (i, ptr) = input_byte(s, ptr, len)
d1993 1
a1993 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d2001 1
a2001 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d2010 1
a2010 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d2022 1
a2022 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2040 1
a2040 1
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
d2062 1
a2062 1
	  val (count, ptr) = input_int_and_strip(s, ptr, len)
d2129 1
a2129 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2140 1
a2140 1
		val (n, ptr) = input_int_and_strip (s, ptr, len)
d2154 1
d2156 1
d2170 1
a2170 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2176 1
a2176 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2197 1
a2197 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2202 1
a2202 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2224 1
a2224 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2229 1
a2229 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2238 1
a2238 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2251 1
d2255 1
d2259 1
a2259 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2280 1
d2284 1
d2288 1
a2288 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2292 1
a2292 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2303 1
d2307 1
d2311 1
a2311 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2321 1
a2321 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2335 1
d2339 1
d2343 1
a2343 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2364 1
d2368 1
d2372 1
a2372 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2390 1
d2393 1
d2395 1
d2403 1
d2407 1
a2407 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2427 1
d2431 1
d2435 1
a2435 1
		val (i, ptr) = input_int_and_strip(s, ptr, len)
d2439 1
a2439 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2453 1
d2457 1
d2465 1
a2465 1
	  val (n, ptr) = input_int_and_strip(s, ptr, len)
d2484 1
d2487 1
d2492 1
a2492 1
	  val (n, ptr) = input_byte(s, ptr, len)
d2503 1
a2503 1
	  val (n, ptr) = input_byte(s, ptr, len)
d2509 1
a2509 1
		val (n, ptr) = input_int_and_strip(s, ptr, len)
d2546 1
d2557 1
d2565 1
a2565 1
	  val (i, ptr) = input_byte(s, ptr, len)
d2570 1
a2570 1
		val (n, ptr) = input_int_and_strip(s, ptr, len)
d2576 1
a2576 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2588 4
a2591 1
		   handle Lists.Nth => raise bad_input14)
d2595 1
a2595 1
		val (n, ptr) = input_int_and_strip(s, ptr, len)
d2607 1
a2607 1
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
d2618 1
d2620 1
d2671 2
a2672 2
	  val (tynames, ptr) = decode_list decode_tyname ptr
	  val (strnames, ptr) = decode_list decode_strname ptr
@


1.34
log
@Changed to use has tables in various places. Altered the encoding
of valenvs in tynames to give only the domain plus whether the range
is a fun or cons type. This is all the code generator needs, and the
typechecker doesn't look at this stuff. This breaks the circularity for
metatynames so we now encode them as well. Also fixed the code output
to give both the number of module elements and the number of top level
tags (both are need by the runtime system when sets of mutually
recursive procedures are around). Changed the version number to reflect
this.
@
text
@d4 11
d184 1
d194 1
d216 1
d525 1
a525 1
     rev_map (output_int(length x) :: done) f x
d540 4
a543 4
      val f_len = length f_map
      val v_len = length(Map.assoc v)
      val e_len = length(Map.assoc e)
      val s_len = length(Map.assoc s)
d551 3
a553 3
	  val v_len = length v_list
	  val e_len = length e_list
	  val s_len = length s_list
d1033 1
a1033 1
      fun gaps (tyname_id,_,nil) = tyname_id
d1058 1
a1058 1
      fun gaps (strname_id,_,nil) = strname_id
d1083 1
a1083 1
      fun gaps (tyfun_id,_,nil) = tyfun_id
d1251 1
a1251 1
	    if h = s then length t + 1
d1311 1
a1311 1
	      fun ev'(h::t) = if h = r then length t + 1
d1352 1
a1352 1
	  fun et'(h::t) = if h = ti then length t + 1
d1393 1
a1393 1
	  fun et'(h::t) = if h = arg then length t + 1
d1408 1
a1408 1
	  fun et'(h::t) = if h = arg then length t + 1
d1428 1
a1428 1
	      length tl + 1
d1443 1
a1443 1
	  fun et'(h::t) = if h = arg then length t + 1
d1460 1
a1460 1
	  fun et'(h::t) = if Enc_Sub.type_same(h, arg) then length t + 1
d1495 1
a1495 1
	      then length t + 1
d1529 1
a1529 1
	    if Enc_Sub.type_same(h, arg) then length t + 1
d1561 1
a1561 1
	  fun et'(h::t) = if h = arg then length t + 1
d1697 1
a1697 1
	 "in list length : " ^ Integer.makestring(length(!strnames_encoded)) ^ "\n" ^
d1700 1
a1700 1
	 "in list length : " ^ Integer.makestring(length(NewMap.domain(!tynames_encoded_in_map))) ^ "\n" ^
@


1.33
log
@Added use of hastable for encoding comon types and tynames
@
text
@d4 3
d377 6
d395 1
a395 1
	  val wordset_len = length w_list
d411 8
d421 2
a422 1
      (output_int (length element_list) ::
d643 14
d659 1
a659 1
	  val (assoc_list, ptr) = decode_list (decode_pair f g) ptr
d888 14
d904 1
a904 1
	  val (assoc_list, ptr) = decode_list (decode_pair f g) ptr
d966 1
d1094 1
a1094 3
(*
      val tynames_encoded = ref [] : (*bool ref*)int list ref
*)
d1110 2
d1113 2
d1258 56
a1335 8
	encode_valenv(encode_bool b :: output_int n ::
		      encode_string(encode_tyname_id(output_byte 1 :: done,
						     ti),
				    s), ve)

      | encode_tyname(done,
		      tyn as DataTypes.METATYNAME(ref tf, s, n, ref b, _)) =
(*
d1337 2
a1338 1
	  fun et'(h::t) = if h = tyn then length t + 1
d1341 3
a1343 3
	    (meta_tynames_encoded := (tyn::(!meta_tynames_encoded)); 0)
	  val pos = et'(!meta_tynames_encoded)
	  val done = output_int pos :: output_byte 2 :: done
d1346 3
a1348 2
	    encode_bool b :: output_int n ::
	    encode_string(encode_tyfun(done, tf), s)
d1352 4
a1355 1
*)
d1368 3
a1370 2
	      encode_bool b :: output_int n ::
	      encode_string(encode_tyfun(done, tf), s)
d1705 2
d1724 7
a1730 1
	 Integer.makestring(Lists.length(!debruijn_types_encoded)) ^ " \n")
d2008 14
d2024 1
a2024 1
	  val (assoc_list, ptr) = decode_list (decode_pair f g) ptr
d2033 2
d2036 1
a2036 2
(*
      val tynames_decoded = ref [] : DataTypes.Tyname ref list ref
a2037 1
*)
d2070 6
a2075 1
      val dummy_type = (*DataTypes.NULLTYPE*)Types.int_type
d2204 3
a2206 1
		  handle Lists.Nth => raise bad_input19
d2231 3
a2233 1
		  handle Lists.Nth => raise bad_input19
d2252 3
a2254 1
		  handle Lists.Nth => raise bad_input19
d2282 3
a2284 1
		  handle Lists.Nth => raise bad_input19
d2309 3
a2311 1
		  handle Lists.Nth => raise bad_input19
d2337 6
a2342 1
		    raise bad_input19
d2366 3
a2368 1
		  handle Lists.Nth => raise bad_input19
d2390 3
a2392 1
		  handle Lists.Nth => raise bad_input19
d2419 2
a2420 1
	    handle Lists.Nth => raise bad_input13
d2423 71
a2500 12
		val (tyname_id, ptr) = decode_tyname_id ptr
		val (st, ptr) = decode_string ptr
		val (i, ptr) = input_int_and_strip(s, ptr, len)
		val (b, ptr) = decode_bool ptr
		val (valenv, ptr) = decode_refvalenv ptr
		val ty = DataTypes.TYNAME(tyname_id, st, i, ref b,
					  valenv)
	      in
		(ty, ptr)
	      end
	  | 2 =>
	      let
a2502 1
(*
d2505 1
a2505 5
		    val r = ref dummy_tyname
		    val _ =
		      meta_tynames_decoded := r :: (!meta_tynames_decoded)
		    val _ = meta_tynames_so_far := (!meta_tynames_so_far)+1
		    val (tyfun, ptr) = decode_tyfun ptr
d2509 5
a2513 1
		    val ty = DataTypes.METATYNAME(ref tyfun, st, i, ref b)
d2515 1
a2515 2
		    (r := ty;
		     (ty, ptr))
d2518 2
a2519 4
		  (!(Lists.nth(!meta_tynames_so_far - n,
			       !meta_tynames_decoded)),
		   ptr)
		  handle Lists.Nth => raise bad_input14
d2521 4
a2524 1
*)
d2537 1
a2537 3
(*
		    val (valenv, ptr) = decode_refvalenv ptr
*)
d2539 1
a2539 2
		      DataTypes.METATYNAME(ref tyfun, st, i, ref b,
					   ref Valenv.empty_valenv)
d2648 2
a2649 2
      fun reset_map fun1 fun2 m =
	Lists.iterate (fn (x, y) => (fun1 x; fun2 y)) (Map.assoc m)
d2664 1
a2664 1
	     reset_map (fn x => ()) reset_typescheme M)
d2682 1
a2682 1
	reset_map (fn x => ()) reset_type M
d2709 1
a2709 1
	reset_map (fn x => ()) reset_tystr M
d2716 1
a2716 1
	reset_map (fn x => ()) reset_str M
d2729 1
a2729 1
	reset_map (fn x => ()) reset_sigma M
d2737 1
a2737 1
	reset_map (fn x => ()) reset_phi M
d2858 1
a2858 1
	[output_int ObjectFile.GOOD_MAGIC, output_int 0,
@


1.32
log
@Changed names of functions in Pervasives.
@
text
@d4 7
d172 1
d916 4
d1065 4
a1068 2
      val tyfuns_encoded = ref [] : DataTypes.Tyfun list ref

d1230 8
a1237 1
      and encode_tyname(done, DataTypes.TYNAME(ti, s, n, r as ref b, ref ve)) =
d1240 1
a1240 4
	  val _ = diagnose_calls("encode_tyname case 1 done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = tynames := !tynames + 1
	  val id = Tyname_id.tyname_id ti
	  fun et'(h::t) = if h = id then length t + 1
d1243 3
a1245 3
	    (tynames_encoded := (id::(!tynames_encoded)); 0)
	  val pos = (*et'(!tynames_encoded)*)0
	  val done = output_int pos :: output_byte 1 :: done
d1248 2
a1249 3
	    encode_valenv(encode_bool b :: output_int n ::
			  encode_string(encode_tyname_id(done, ti),
					s), ve)
a1253 7
	encode_valenv(encode_bool b :: output_int n ::
		      encode_string(encode_tyname_id(output_byte 1 :: done, ti),
				    s), ve)

      | encode_tyname(done,
		      tyn as DataTypes.METATYNAME(ref tf, s, n, ref b,
						  (*ref ve*)_)) =
d1255 3
a1257 12
(*
	  val _ = tynames := !tynames + 1;
	  val _ = meta_tynames := !meta_tynames + 1;
	  val _ = diagnose_calls("encode_tyname case 2 done size : " ^
				 Integer.makestring(string_list_size done) ^
				 "\n");
*)
	  fun et'(h::t) = if h = tyn then length t + 1
			  else et' t
	  | et' [] =
	    (meta_tynames_encoded := (tyn::(!meta_tynames_encoded)); 0)
	  val pos = et'(!meta_tynames_encoded)
d1261 8
a1268 2
	    (*encode_valenv( *)encode_bool b :: output_int n ::
			  encode_string(encode_tyfun(done, tf), s)(*, ve)*)
a1272 1

d1341 1
a1342 3
(*
	  val M' = Map.assoc M
*)
d1355 1
a1355 1
      | encode_type(done, DataTypes.FUNTYPE(arg as (t1, t2))) =
d1357 19
d1390 18
d1409 1
d1424 18
d1467 1
a1467 1
      and encode_tyfun(done, DataTypes.TYFUN(t, n)) =
d1602 18
d1627 7
d2179 2
a2180 5
		    val r = ref dummy_type
		    val _ =
		      funtype_types_decoded := r :: !funtype_types_decoded
		    val _ =
		      funtype_types_so_far := !funtype_types_so_far + 1
d2184 1
d2186 1
a2186 2
		    (r := ty;
		     (ty, ptr))
d2189 1
d2194 4
@


1.31
log
@Changed such that all maps are created with equality functions
@
text
@d4 3
d433 1
a433 1
      output_int (Pervasives.sort x) :: output_int 1 :: done
d644 1
a644 1
                     (EnvironTypes.PRIM (Pervasives.de_sort offset), ptr)
@


1.30
log
@New pervasive library code - cut some things out of the initial type basis
@
text
@d4 3
d651 1
a651 1
	    (op =)
d658 1
a658 1
	    (op =)
d665 1
a665 1
	    (op =)
d686 1
a686 1
	    (op =)
d707 1
a707 1
	(op =)
d861 1
a861 1
	    (op =)
d876 1
a876 1
	    (op =)
d888 1
a888 1
	(op =)
d895 1
a895 1
	(op =)
d2072 1
a2072 1
		      decode_map decode_lab decode_type ptr (op =)
d2267 2
a2268 1
	    decode_map decode_tycon decode_tystr ptr (op =) Ident.tycon_order
d2294 2
a2295 1
	    decode_map decode_strid decode_str ptr (op =) Ident.strid_order
d2319 2
a2320 1
	    decode_map decode_sigid decode_sigma ptr (op =) Ident.sigid_order
d2337 2
a2338 1
	    decode_map decode_funid decode_phi ptr (op =) Ident.funid_order
@


1.29
log
@Fixed bug in decode_refvalenv whereby valenv maps were created
with op=, should be done with Ident.valid_eq
@
text
@d4 4
d174 1
d206 1
d228 1
d424 6
d432 1
a432 1
  | encode_index _ = Crash.impossible"encode_index not FIELD"
d516 1
a516 1
	    encode_index
d519 1
a519 1
	   encode_index
d522 1
a522 1
	  (encode_pair (encode_sub 0) encode_index)
d627 14
a640 1
	      (EnvironTypes.FIELD{index=offset, size=env_size}, ptr)
@


1.28
log
@Modified to allow valenv field in METATYNAMEs. These are not encoded
or decoded to avoid the circularity problem. They are recalculated
by the cor rules typechecking phase as necessary
@
text
@d4 5
d2143 1
a2143 1
		(op=)
@


1.27
log
@Changed to encode tyfun_ids similarly to tyname_ids
@
text
@d4 3
d1204 3
a1206 1
      | encode_tyname(done, tyn as DataTypes.METATYNAME(ref tf, s, n, ref b)) =
d1223 2
a1224 2
	    encode_bool b :: output_int n ::
	    encode_string(encode_tyfun(done, tf), s)
d1792 7
d1802 1
a1802 1
			     0, ref false)
d2170 1
d2192 27
d2337 3
a2339 2
      | reset_tyname(DataTypes.METATYNAME(ref tf, s, n, ref b)) =
	reset_tyfun tf
@


1.26
log
@Changed encoding of Tyname slightly since we don't spot repeats any
more for TYNAME
@
text
@d4 4
d259 1
d449 1
d451 1
d921 1
a921 1
      | gaps (tyname_id,last,("",tyname_count,_)::rest) =
d923 1
a923 1
      | gaps (tyname_id,_,(_,tyname_count,_)::rest) =
d929 1
a929 1
	  | search ((module,tyname_count,_)::rest) = 
d946 1
a946 1
      | gaps (strname_id,last,("",_,strname_count)::rest) =
d948 1
a948 1
      | gaps (strname_id,_,(_,_,strname_count)::rest) =
d954 1
a954 1
	  | search ((module,_,strname_count)::rest) = 
d970 25
d1088 31
d1370 1
a1370 1
	encode_tyfun_id tfi :: output_byte 3 :: done
d1509 1
a1509 1
      val (tyname_count,strname_count) =
d1511 2
a1512 1
	  (_,tyname_count,strname_count)::rest => (tyname_count,strname_count)
d1519 1
a1519 1
	    | search ((name',tyname_count,strname_count)::rest) =
d1522 1
a1522 1
		  (tyname_count,strname_count)
d1640 1
a1640 1
		val (tyname_count,_) = name_offsets module
d1653 42
d1699 1
d1728 1
a1728 1
		val (_,strname_count) = name_offsets module
d2380 1
a2380 1
		  tynames=tnames, strnames=snames} =
d2385 1
a2385 1
      val p_offset = 20
d2391 2
a2392 1
       output_int tnames, output_int snames, p_env, t_env, l_env]
d2403 1
d2411 1
a2411 1
       tynames = tnames, strnames = snames}
@


1.25
log
@Used new type_same from Enc_Sub to do equality on Type (not equality
types themselves)/ Pointer eq would probably be nicer
@
text
@d4 4
d963 1
d965 1
d1114 1
a1115 1
(*
a1117 2
*)
(*
a1122 1
*)
d1133 4
d1675 1
d1678 1
a2032 1
	  val (n, ptr) = input_int_and_strip(s, ptr, len)
d2036 11
a2046 18
	      (if n=0 then
		 let
		   val r = ref dummy_tyname
		   val _ = tynames_decoded := r :: (!tynames_decoded)
		   val _ = tynames_so_far := (!tynames_so_far)+1
		   val (tyname_id, ptr) = decode_tyname_id ptr
		   val (st, ptr) = decode_string ptr
		   val (i, ptr) = input_int_and_strip(s, ptr, len)
		   val (b, ptr) = decode_bool ptr
		   val (valenv, ptr) = decode_refvalenv ptr
		   val _ = r := DataTypes.TYNAME(tyname_id, st, i, ref b,
						 valenv)
		 in
		   (!r, ptr)
		 end
	       else
		 (!(Lists.nth(!tynames_so_far - n, !tynames_decoded)), ptr)
		 handle Lists.Nth => raise bad_input14)
d2048 24
a2071 18
	      (if n = 0 then
		 let
		   val r = ref dummy_tyname
		   val _ = meta_tynames_decoded := r :: (!meta_tynames_decoded)
		   val _ = meta_tynames_so_far := (!meta_tynames_so_far)+1
		   val (tyfun, ptr) = decode_tyfun ptr
		   val (st, ptr) = decode_string ptr
		   val (i, ptr) = input_int_and_strip(s, ptr, len)
		   val (b, ptr) = decode_bool ptr
		   val _ = r := DataTypes.METATYNAME(ref tyfun, st, i, ref b)
		 in
		   (!r, ptr)
		 end
	       else
		 (!(Lists.nth(!meta_tynames_so_far - n,
			      !meta_tynames_decoded)),
		  ptr)
		 handle Lists.Nth => raise bad_input14)
@


1.24
log
@Split type encoding into all constituent parts, for improved speed.
There is a lurking problem here, Type is not an equality type,
although NJ believes it is.
@
text
@d4 5
d156 1
d187 1
d196 1
a196 1
    Nameset.Datatypes = Valenv.Datatypes = Types.Datatypes
d969 1
a969 1
	ref [] : ((Ident.Lab * DataTypes.Type) list) list ref
d972 1
a972 2
      val constype_types_encoded =
	ref [] : (DataTypes.Type list * DataTypes.Tyname) list ref
d1188 1
d1190 5
a1194 2
	  fun et'(h::t) = if h = arg then length t + 1
			  else et' t
d1196 1
a1196 1
	    (tyvar_types_encoded := (arg::(!tyvar_types_encoded)); 0)
d1222 1
a1222 1
      | encode_type(done, DataTypes.RECTYPE M) =
d1224 1
d1226 2
a1227 1
	  fun et'(h::t) = if h = M' then length t + 1
d1230 1
a1230 1
	    (rectype_types_encoded := (M'::(!rectype_types_encoded)); 0)
d1241 4
a1244 2
	  fun et'(h::t) = if h = arg then length t + 1
			  else et' t
d1255 1
a1255 1
      | encode_type(done, DataTypes.CONSTYPE(arg as (l, t))) =
d1257 3
a1259 2
	  fun et'(h::t) = if h = arg then length t + 1
			  else et' t
@


1.23
log
@Removed diagnostic stuff. Improved speed by a further factor of six or so
@
text
@d4 3
a951 1
      val valenvs_encoded = ref [] : int ref list ref
d955 13
a967 1
      val types_encoded = ref [] : DataTypes.Type list ref
a970 5
      fun etype'(the_type, (h::t)) = if h = the_type then length t + 1
				     else etype'(the_type, t)
      | etype'(the_type, []) =
	(types_encoded := (the_type::(!types_encoded)); 0)

a1085 8
(*
	  fun ev' (h::t) =
	    if h = r then length t + 1
	    else ev' t
	  | ev' [] = 
	    (valenvs_encoded := (r::(!valenvs_encoded)); 0)
	  val n = ev'(!valenvs_encoded)
*)
a1147 25
      and encode_type_sub(done,
			  DataTypes.METATYVAR(ref(n, t), b1, b2)) =
	encode_bool b2 :: encode_bool b1 ::
	encode_type(output_int n :: output_byte 1 :: done, t)
      | encode_type_sub(done, DataTypes.META_OVERLOADED(ref t)) =
	encode_type(output_byte 2 :: done, t)
      | encode_type_sub(done, DataTypes.TYVAR(ref n, t)) =
	encode_tyvar(output_int n :: output_byte 3 :: done, t)
      | encode_type_sub(done,
			DataTypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
	encode_bool b3 :: encode_bool b2 ::
	encode_type(encode_bool b1 :: output_int n :: output_byte 4 ::
		    done, t)
      | encode_type_sub(done, DataTypes.RECTYPE M) =
	encode_map (output_byte 5 :: done) encode_lab encode_type M
      | encode_type_sub(done, DataTypes.FUNTYPE(t1, t2)) =
	encode_type(encode_type(output_byte 6 :: done, t1), t2)
      | encode_type_sub(done, DataTypes.CONSTYPE(l, t)) =
	encode_tyname(encode_list (output_byte 7 :: done) encode_type l,
		      t)
      | encode_type_sub(done, DataTypes.DEBRUIJN(n, b1, b2)) =
	encode_bool b2 :: encode_bool b1 :: output_int n ::
	output_byte 8 :: done
      | encode_type_sub(done, DataTypes.NULLTYPE) = output_byte 9 ::
	done
d1149 2
a1150 1
      and encode_type(done, the_type) =
d1152 1
a1152 6
(*
	  val _ = diagnose_calls("encode_type done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = types := !types + 1
*)
(*
	  fun et'(h::t) = if h = the_type then length t + 1
d1155 3
a1157 8
	    (types_encoded := (the_type::(!types_encoded)); 0)
*)
	  val pos = etype'(the_type, !types_encoded)
	  val number = if pos = 0 then length(!types_encoded) else pos
(*
	  val _ = Print.print("Encoding type '" ^ Types.print_type the_type ^ "' number " ^ Integer.makestring number ^ " position " ^ Integer.makestring pos ^ "\n")
*)
	  val done = output_int pos :: done
d1160 2
a1161 1
	    encode_type_sub(done, the_type)
d1165 107
d1660 2
d1663 17
a1679 1
      val types_decoded = ref [] : DataTypes.Type ref list ref
a1700 5
(*
		fun ds' (h::t) 0 = !h
		  | ds' (h::t) n = ds' t (n-1)
		  | ds' [] _ = raise bad_input14
*)
d1713 2
a1714 2
		  (!(Lists.nth(!strnames_so_far - n, !strnames_decoded))
		   handle Lists.Nth => raise bad_input14, ptr)
a1781 19
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
	in
	  if i = 0 then
	    let
	      val r = ref dummy_type
	      val _ = types_decoded := r :: (!types_decoded)
	      val _ = types_so_far := (!types_so_far)+1
	      val res as (ty, _) = decode_type_sub ptr
	    in
	      (r := ty;
	       res)
	    end
	  else
	    (!(Lists.nth(!types_so_far - i, !types_decoded)), ptr)
	    handle Lists.Nth => raise raise bad_input19
	end

      and decode_type_sub ptr =
	let
a1787 3
		val (ty, ptr) = decode_type ptr
		val (b1, ptr) = decode_bool ptr
		val (b2, ptr) = decode_bool ptr
d1789 21
a1809 1
		(DataTypes.METATYVAR(ref(i, ty), b1, b2), ptr)
d1813 1
a1813 1
		val (ty, ptr) = decode_type ptr
d1815 20
a1834 1
		(DataTypes.META_OVERLOADED(ref ty), ptr)
a1838 1
		  val (tyvar, ptr) = decode_tyvar ptr
d1840 14
a1853 1
		(DataTypes.TYVAR(ref i, tyvar), ptr)
a1857 4
		val (b1, ptr) = decode_bool ptr
		val (ty, ptr) = decode_type ptr
		val (b2, ptr) = decode_bool ptr
		val (b3, ptr) = decode_bool ptr
d1859 23
a1881 1
		(DataTypes.METARECTYPE(ref(i, b1, ty, b2, b3)), ptr)
d1885 1
a1885 2
		val (lab_map, ptr) =
		  decode_map decode_lab decode_type ptr (op =) Ident.lab_order
d1887 20
a1906 1
		(DataTypes.RECTYPE lab_map, ptr)
d1910 1
a1910 2
		val (ty1, ptr) = decode_type ptr
		val (ty2, ptr) = decode_type ptr
d1912 19
a1930 1
		(DataTypes.FUNTYPE(ty1, ty2), ptr)
d1934 1
a1934 2
		val (the_list, ptr) = decode_list decode_type ptr
		val (tyname, ptr) = decode_tyname ptr
d1936 19
a1954 1
		(DataTypes.CONSTYPE(the_list, tyname), ptr)
d1956 1
a1956 1
	  | 8 =>
a1958 2
		val (b1, ptr) = decode_bool ptr
		val (b2, ptr) = decode_bool ptr
d1960 17
a1976 1
		(DataTypes.DEBRUIJN(i, b1, b2), ptr)
a1984 5
(*
	  fun dv' (h::t) 0 = h
	  | dv'(h::t) n = dv' t (n-1)
	  | dv' [] _ = raise bad_input13
*)
d2002 1
a2002 1
	    (Lists.nth(!valenvs_so_far -n, !valenvs_decoded), ptr)
a2009 5
(*
	  fun dt' (h::t) 0 = !h
	  | dt' (h::t) n = dt' t (n-1)
	  | dt' [] _ = raise bad_input14
*)
d2013 18
a2030 18
	      if n=0 then
		let
		  val r = ref dummy_tyname
		  val _ = tynames_decoded := r :: (!tynames_decoded)
		  val _ = tynames_so_far := (!tynames_so_far)+1
		  val (tyname_id, ptr) = decode_tyname_id ptr
		  val (st, ptr) = decode_string ptr
		  val (i, ptr) = input_int_and_strip(s, ptr, len)
		  val (b, ptr) = decode_bool ptr
		  val (valenv, ptr) = decode_refvalenv ptr
		  val _ = r := DataTypes.TYNAME(tyname_id, st, i, ref b,
						valenv)
		in
		  (!r, ptr)
		end
	      else
		(!(Lists.nth(!tynames_so_far - n, !tynames_decoded))
		   handle Lists.Nth => raise bad_input14, ptr)
d2032 18
a2049 17
	      if n = 0 then
		let
		  val r = ref dummy_tyname
		  val _ = meta_tynames_decoded := r :: (!meta_tynames_decoded)
		  val _ = meta_tynames_so_far := (!meta_tynames_so_far)+1
		  val (tyfun, ptr) = decode_tyfun ptr
		  val (st, ptr) = decode_string ptr
		  val (i, ptr) = input_int_and_strip(s, ptr, len)
		  val (b, ptr) = decode_bool ptr
		  val _ = r := DataTypes.METATYNAME(ref tyfun, st, i, ref b)
		in
		  (!r, ptr)
		end
	      else
		(!(Lists.nth((!meta_tynames_so_far - n),
			     (!meta_tynames_decoded)))
		 handle Lists.Nth => raise bad_input14, ptr)
@


1.22
log
@Fixed problem with encoding types, caused by Tyname -> Valenv -> Typescheme
-> Type -> Tyname circularity, such that the second instance of tyname
was incorrectly read as an existing Tyname, even though it hadn't been
fully decoded. Ugh!
@
text
@d4 6
d250 2
a251 7
  fun string_list_size str =
    let
      fun string_list_sub(n, []) = n
      | string_list_sub(n, str :: rest) = string_list_sub(n + size str, rest)
    in
      string_list_sub(0, str)
    end
d253 2
d261 5
d270 1
a270 8
      let
	fun make_list(done, bytes, value) =
	  if bytes <= 0 then done
	  else
	    make_list(chr(value mod 256) :: done, bytes-1, value div 256)
      in
	implode(make_list([], 4, i))
      end
d272 13
a290 10
	fun undo_list(value, []) = value
	| undo_list(value, x :: xs) = undo_list(value * 256 + ord x, xs)
	  handle Sum => (diagnose_consistency("Sum overflow on " ^
			       Integer.makestring value ^ " * 256 + " ^
			       Integer.makestring(ord x));
			 raise bad_input1)
	       | Prod => (diagnose_consistency("Product overflow on " ^
			       Integer.makestring value ^ " * 256 + " ^
			       Integer.makestring(ord x));
			 raise bad_input2)
d302 6
d372 3
a374 1
    (diagnose_sizes("Encode_string size : " ^ Integer.makestring(size s) ^ "\n");
d379 3
a381 1
       s :: output_int(size s) :: done)
d395 1
a395 1
    encode_symbol(output_int 0 :: done, sy)
d397 1
a397 1
    encode_symbol(output_int 1 :: done, sy)
d399 1
a399 1
    encode_symbol(output_int 2 :: done, sy)
d426 3
a428 3
  fun encode_over_loaded DataTypes.UNARY = output_int 1
  | encode_over_loaded DataTypes.BINARY = output_int 2
  | encode_over_loaded DataTypes.PREDICATE = output_int 3
d433 6
a438 2
    (diagnose_sizes("Encoding list length : " ^ Integer.makestring(length x) ^ "\n");
     rev_map (output_int(length x) :: done) f x)
d661 1
a661 1
	output_int i :: output_int 0 :: done
d663 1
a663 1
	output_int i :: output_int 1 :: done
d665 1
a665 1
	output_int 2 :: done
a669 2
	let
	in
a681 1
	end
d712 1
a712 1
	  val (sy_type, ptr) = input_int_and_strip(s, ptr, len)
d746 1
a746 1
	  val (fixity, ptr) = input_int_and_strip(s, ptr, len)
d847 1
d869 1
d871 1
d897 1
d899 6
d908 6
a913 7
	    | search ((module,tyname_count,_)::rest) = 
	      if n < tyname_count 
		then
		  search rest
	      else
		(module,tyname_count,rest)

a914 8

	  fun gaps (tyname_id,_,nil) = tyname_id
	    | gaps (tyname_id,last,(module,tyname_count,_)::rest) =
	      if module = ""
		then
		  gaps (tyname_id + last - tyname_count,tyname_count,rest)
	      else
		gaps (tyname_id,tyname_count,rest)
d917 2
a918 2
	   if module = "" 
	     then 
d920 2
a921 2
	   else
	     n - tyname_count)
d924 6
d933 6
a938 7
	    | search ((module,_,strname_count)::rest) = 
	      if n < strname_count 
		then
		  search rest
	      else
		(module,strname_count,rest)

a939 8

	  fun gaps (strname_id,_,nil) = strname_id
	    | gaps (strname_id,last,(module,_,strname_count)::rest) =
	      if module = ""
		then
		  gaps (strname_id + last - strname_count,strname_count,rest)
	      else
		gaps (strname_id,strname_count,rest)
d942 2
a943 2
	   if module = "" 
	     then 
d945 2
a946 2
	   else
	     n - strname_count)
d957 6
d967 6
a972 2
	    (diagnose_calls("Beware: Equal tyname_ids " ^ Integer.makestring i1 ^ ", " ^ Integer.makestring i2 ^ " on distinct tynames '" ^ s1 ^ "', '" ^ s2 ^ "'");
	     NewMap.EQUAL)
d979 1
d983 1
d986 1
d991 6
a996 2
	      (diagnose_calls("Encoding tyname_id in pervasives, value " ^ Integer.makestring id ^ "\n");
	       output_int id :: output_int 0 :: done)
d1000 1
d1002 1
d1006 1
a1006 1
		  output_int id' :: output_int 1 :: done
d1008 1
a1008 1
		output_int id' :: encode_string (output_int 2 :: done, module)
d1014 1
d1017 1
d1022 1
a1022 1
	      output_int id :: output_int 0 :: done
d1029 1
a1029 1
		  output_int id' :: output_int 1 :: done
d1031 1
a1031 1
		output_int id' :: encode_string (output_int 2 :: done, module)
d1036 3
a1038 1
	(strnames := !strnames + 1;
d1040 3
a1042 1
	 encode_strname_id (output_int 1 :: done, s))
d1045 1
d1048 1
d1055 1
a1055 1
	  val done = output_int n :: output_int 2 :: done
d1063 3
a1065 1
	(strnames := !strnames + 1;
d1067 3
a1069 1
	encode_strname_id (output_int 3 :: done, s))
d1073 1
d1076 1
d1102 1
d1105 2
d1112 1
d1114 1
a1114 1
	  val done = output_int pos :: output_int 1 :: done
d1126 1
d1132 1
d1138 1
a1138 1
	  val done = output_int pos :: output_int 2 :: done
d1150 1
a1150 1
	encode_type(output_int n :: output_int 1 :: done, t)
d1152 1
a1152 1
	encode_type(output_int 2 :: done, t)
d1154 1
a1154 1
	encode_tyvar(output_int n :: output_int 3 :: done, t)
d1158 1
a1158 1
	encode_type(encode_bool b1 :: output_int n :: output_int 4 ::
d1161 1
a1161 1
	encode_map (output_int 5 :: done) encode_lab encode_type M
d1163 1
a1163 1
	encode_type(encode_type(output_int 6 :: done, t1), t2)
d1165 1
a1165 1
	encode_tyname(encode_list (output_int 7 :: done) encode_type l,
d1169 2
a1170 2
	output_int 8 :: done
      | encode_type_sub(done, DataTypes.NULLTYPE) = output_int 9 ::
d1175 1
d1178 2
d1184 2
a1185 1
	  val pos = et'(!types_encoded)
d1198 6
a1203 13
      and encode_typescheme(done, the_typescheme) =
	let
	  val _ = diagnose_calls("encode_typescheme done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = typeschemes := !typeschemes + 1
      fun encode_typescheme_sub(done, DataTypes.SCHEME(n, t)) =
	encode_type(output_int n :: output_int 1 :: done, t)
      | encode_typescheme_sub(done, DataTypes.UNBOUND_SCHEME t) =
	encode_type(output_int 2 :: done, t)
      | encode_typescheme_sub(done, DataTypes.OVERLOADED_SCHEME ov) =
	encode_over_loaded ov :: output_int 3 :: done
	in
	  encode_typescheme_sub(done, the_typescheme)
	end
d1205 6
a1210 15
      and encode_tyfun(done, the_tyfun) =
	let
	  val _ = diagnose_calls("encode_tyfun done size : " ^
				 Integer.makestring(string_list_size done) ^
				 "\n")
	  val _ = tyfuns := !tyfuns + 1
	  fun encode_tyfun_sub(done, DataTypes.TYFUN(t, n)) =
	    output_int n :: encode_type(output_int 1 :: done, t)
	  | encode_tyfun_sub(done, DataTypes.ETA_TYFUN tn) =
	    encode_tyname(output_int 2 :: done, tn)
	  | encode_tyfun_sub(done, DataTypes.NULL_TYFUN tfi) =
	    encode_tyfun_id tfi :: output_int 3 :: done
	in
	  encode_tyfun_sub(done, the_tyfun)
	end
d1213 3
a1215 1
	(tystrs := !tystrs + 1;
d1217 3
a1219 1
	 encode_valenv(encode_tyfun(done, tf), ve))
d1222 3
a1224 1
	(tyenvs := !tyenvs + 1;
d1226 3
a1228 1
	encode_map done encode_tycon encode_tystr M)
d1231 3
a1233 1
	(strs := !strs + 1;
d1235 3
a1237 1
	encode_env(encode_strname(done, sn), e))
d1240 3
a1242 1
	(strenvs := !strenvs + 1;
d1244 3
a1246 1
	 encode_map done encode_strid encode_str M)
d1249 3
a1251 1
	(envs := !envs + 1;
d1253 4
a1256 2
	encode_valenv(encode_valenv(encode_tyenv(encode_strenv(done, se), te),
				    ve), ece))
d1259 3
a1261 1
	(namesets := !namesets + 1;
d1263 6
a1268 4
	encode_list
	(encode_list done encode_tyname (Nameset.tynames_of_nameset ns))
	encode_strname
	(Nameset.strnames_of_nameset ns))
d1271 3
a1273 1
	(sigmas := !sigmas + 1;
d1275 3
a1277 1
	encode_str(encode_nameset(done, ns), s))
d1280 3
a1282 1
	(sigenvs := !sigenvs + 1;
d1284 3
a1286 1
	encode_map done encode_sigid encode_sigma M)
d1289 3
a1291 1
	(phis := !phis + 1;
d1293 3
a1295 1
	encode_sigma(encode_str(encode_nameset(done, ns), s), sg))
d1298 3
a1300 1
	(funenvs := !funenvs + 1;
d1302 3
a1304 1
	encode_map done encode_funid encode_phi M)
d1313 1
d1340 1
d1394 1
a1394 1
	  val (sy_type, ptr) = input_int_and_strip(s, ptr, len)
d1451 1
a1451 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1467 1
d1469 1
d1480 1
d1482 1
d1499 1
a1499 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1535 1
a1535 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1596 1
a1596 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1608 1
d1612 1
d1625 2
a1626 1
		  (ds' (!strnames_decoded) (!strnames_so_far - n), ptr)
d1640 1
a1640 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1667 1
a1667 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1713 1
a1713 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1784 1
d1788 1
d1812 1
a1812 1
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
d1814 1
d1818 1
d1838 2
a1839 1
		(dt' (!tynames_decoded) (!tynames_so_far - n), ptr)
@


1.21
log
@Modified to output only one instance of each METATYNAME and Type,
for improved efficiency
@
text
@d4 4
d234 1
d252 6
d304 6
a309 6
  fun extend_string s =
    case (size s) mod 4 of
      0 => s ^ "\000   "
    | 1 => s ^ "\000  "
    | 2 => s ^ "\000 "
    | 3 => s ^ "\000"
d312 4
d358 2
a359 2
  fun encode_bool false = output_int 0
  | encode_bool true = output_int 1
d480 7
a486 7
      extend_string(implode(rev(encode_sub f_len (
						  encode_map
						  [output_int(f_len + env_len)]
						  encode_funid
						  do_ftr_range
						  fun_env, env
						  ))))
a652 6
(*
	  val _ = Print.print("fix_map size = " ^ Integer.makestring(length(Map.assoc fix_map)))
	  val _ = Print.print("val_map size = " ^ Integer.makestring(length(Map.assoc val_map)))
	  val _ = Print.print("val_map_range size = " ^ Integer.makestring(length(Map.range val_map)))
	  val _ = Print.print("struct_map size = " ^ Integer.makestring(length(Map.assoc struct_map)))
*)
d668 14
a681 11
      extend_string(implode(rev(encode_pe
				((encode_map
				  (encode_map
				   []
				   encode_funid
				   encode_pe
				   fun_map)
				  encode_sigid
				  encode_pe
				  sig_map),
				 parse_env))))
a782 3
(*
	  val _ = Print.print"Decoding fix_env"
*)
a789 4
(*
	  val _ = Print.print("fix_env size = " ^ Integer.makestring(length(Map.assoc fix_env)))
	  val _ = Print.print"Decoding val_env"
*)
a793 3
(*
	  val _ = Print.print("val_env size = " ^ Integer.makestring(length(val_env)))
*)
a797 3
(*
	  val _ = Print.print"Decoding struct_env"
*)
a804 3
(*
	  val _ = Print.print("struct_env size = " ^ Integer.makestring(length(Map.assoc struct_env)))
*)
a809 3
(*
      val _ = Print.print"Decoding fun_env"
*)
a816 4
(*
      val _ = Print.print("fun_env size = " ^ Integer.makestring(length(Map.assoc fun_env)))
      val _ = Print.print"Decoding sig_env"
*)
a823 4
(*
      val _ = Print.print("sig_env size = " ^ Integer.makestring(length(Map.assoc sig_env)))
      val _ = Print.print"Decoding parse_env"
*)
a956 12
      fun diagnose_type ty =
	let
	  fun diag_sub i =
	    if Lists.member(ty, !types_encoded) then
	      ["Re-encoding existing type\n"]
	    else
	      (types_encoded := ty :: !types_encoded;
	       ["Encoding new type\n"])
	in
	  Diagnostic.output 4 diag_sub
	end

a1038 1
(**)
a1039 4
(**)
(*
	  val _ = Print.print("Encoding valenv with index " ^ Integer.makestring(!r) ^ "\n")
*)
a1042 1
(**)
a1047 4
(*
	       Print.print("Updating reference to " ^ Integer.makestring m ^ "\n");
*)
(**)
a1048 1
(**)
a1050 1
(**)
d1063 1
a1063 1
	  val pos = et'(!tynames_encoded)
a1092 4
(*
	    encode_bool b :: output_int n ::
	    encode_string(encode_tyfun(output_int 2 :: done, tf), s))
*)
a1120 7
(*
      and encode_type(done, DataTypes.DEBRUIJN(n, b1, b2)) =
	encode_bool b2 :: encode_bool b1 :: output_int n ::
	output_int 8 :: done
      | encode_type(done, DataTypes.NULLTYPE) = output_int 9 ::
	done
*)
a1124 1
	  val _ = diagnose_type the_type
d1130 4
d1162 6
a1167 7
(*
	  fun et'(h::t) = if h = the_tyfun then length t + 1
			  else et' t
	  | et' [] =
	    (tyfuns_encoded := (the_tyfun::(!tyfuns_encoded)); 0)
	  val pos = et'(!tyfuns_encoded)
	  val done = output_int pos :: done
d1169 1
a1169 15
	  if pos = 0 then
	    let
*)
	      fun encode_tyfun_sub(done, DataTypes.TYFUN(t, n)) =
		output_int n :: encode_type(output_int 1 :: done, t)
	      | encode_tyfun_sub(done, DataTypes.ETA_TYFUN tn) =
		encode_tyname(output_int 2 :: done, tn)
	      | encode_tyfun_sub(done, DataTypes.NULL_TYFUN tfi) =
		encode_tyfun_id tfi :: output_int 3 :: done
	    in
	      encode_tyfun_sub(done, the_tyfun)
	    end
(*
	  else
	    done
a1170 1
*)
d1260 1
a1260 1
      extend_string(implode(rev result))
d1287 6
a1292 6
	let
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
	in
	  case i of
	    0 => (false, ptr)
	  | 1 => (true, ptr)
a1293 1
	end
d1501 1
a1501 1
      val dummy_type = Types.int_type
a1605 3
	  fun dt' (h::t) 0 = !h
	  | dt' (h::t) n = dt' t (n-1)
	  | dt' [] _ = raise bad_input19
d1612 1
a1612 2
	      val res as (ty, ptr) = decode_type_sub ptr
	      val _ = r := ty
d1614 2
a1615 1
	      res
d1618 2
a1619 1
	    (dt' (!types_decoded) (!types_so_far - i), ptr)
d1621 1
a1621 1
      
d1715 2
a1716 1
	    (dv' (!valenvs_decoded) (!valenvs_so_far -n), ptr)
d1761 3
a1763 1
		(dt' (!meta_tynames_decoded) (!meta_tynames_so_far - n), ptr)
d1998 10
a2007 8
    extend_string(implode(rev(
			      encode_list
			      []
			      (encode_pair
			       encode_string
			       (fn (done, (i, j)) =>
				output_int j :: output_int i :: done))
			      x)))
@


1.20
log
@Changed to use the ref int in the valenv as the encoding number
@
text
@d4 3
d176 1
a176 1
    Nameset.Datatypes = Valenv.Datatypes
d229 1
d252 2
a253 2
	fun make_list(bytes, value) =
	  if bytes <= 0 then []
d255 1
a255 1
	    chr(value mod 256) :: make_list(bytes-1, value div 256)
d257 1
a257 1
	implode(rev(make_list(4, i)))
d852 1
d956 2
d1100 2
a1101 1
	  | et' [] = (tynames_encoded := (id::(!tynames_encoded)); 0)
d1104 7
a1110 6
	 in
	   if pos = 0 then
	     encode_valenv(encode_bool b :: output_int n ::
			   encode_string(encode_tyname_id(done, ti), s), ve)
	   else
	     done
a1111 5
      | encode_tyname(done, DataTypes.METATYNAME(ref tf, s, n, ref b)) =
	(tynames := !tynames + 1;
	 diagnose_calls("encode_tyname case 2 done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
	 encode_bool b :: output_int n ::
	 encode_string(encode_tyfun(output_int 2 :: done, tf), s))
d1113 1
a1113 1
      and encode_type(done, the_type) =
d1115 25
a1139 4
	  val _ = diagnose_calls("encode_type done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
	  val _ = types := !types + 1
	  val _ = diagnose_type the_type
	  fun encode_type_sub(done, DataTypes.METATYVAR(ref(n, t), b1, b2)) =
d1146 2
a1147 1
      | encode_type_sub(done, DataTypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
d1149 2
a1150 1
	encode_type(encode_bool b1 :: output_int n :: output_int 4 :: done, t)
d1156 2
a1157 1
	encode_tyname(encode_list (output_int 7 :: done) encode_type l, t)
d1159 3
a1161 1
	encode_bool b2 :: encode_bool b1 :: output_int n :: output_int 8 ::
d1163 19
a1181 1
      | encode_type_sub(done, DataTypes.NULLTYPE) = output_int 9 :: done
d1183 4
a1186 1
	  encode_type_sub(done, the_type)
d1205 3
a1207 1
	  val _ = diagnose_calls("encode_tyfun done size : " ^ Integer.makestring(string_list_size done) ^ "\n")
d1209 7
a1215 6
      fun encode_tyfun_sub(done, DataTypes.TYFUN(t, n)) =
	output_int n :: encode_type(output_int 1 :: done, t)
      | encode_tyfun_sub(done, DataTypes.ETA_TYFUN tn) =
	encode_tyname(output_int 2 :: done, tn)
      | encode_tyfun_sub(done, DataTypes.NULL_TYFUN tfi) =
	encode_tyfun_id tfi :: output_int 3 :: done
d1217 15
a1231 1
	  encode_tyfun_sub(done, the_tyfun)
d1233 1
d1235 1
a1235 1
      and encode_tystr(done, DataTypes.TYSTR(tf, ve)) =
d1240 1
a1240 1
      and encode_tyenv(done, DataTypes.TE M) =
d1245 1
a1245 1
      and encode_str(done, DataTypes.STR(sn, e)) =
d1261 9
a1269 1
      and encode_sigma(done, Sigma.SIGMA(ns, s)) =
d1274 1
a1274 1
      and encode_sigenv(done, Sigenv.SIGENV M) =
d1279 1
a1279 1
      and encode_phi(done, Phi.PHI(ns, (s, sg))) =
d1284 1
a1284 1
      and encode_funenv(done, Funenv.FUNENV M) =
d1289 7
a1295 11
      and encode_nameset(done, ns) =
	(namesets := !namesets + 1;
	 diagnose_calls("encode_nameset done size : " ^ Integer.makestring(string_list_size done) ^ "\n");
	encode_list
	(encode_list done encode_tyname (Nameset.tynames_of_nameset ns))
	encode_strname
	(Nameset.strnames_of_nameset ns))
      val result =
	(encode_env(encode_sigenv(encode_funenv(encode_nameset([], 
							       nameset),
						funenv), sigenv), env))
d1304 1
d1558 2
d1563 4
d1613 1
a1613 1
      fun decode_nameset ptr =
a1614 24
	  val (tynames, ptr) = decode_list decode_tyname ptr
	  val (strnames, ptr) = decode_list decode_strname ptr
	in
	  (Nameset.nameset_of_name_lists(tynames, strnames), ptr)
	end

      and decode_str ptr =
	let
	  val (strname, ptr) = decode_strname ptr
	  val (env, ptr) = decode_env ptr
	in
	  (DataTypes.STR(strname, env), ptr)
	end

      and decode_tystr ptr =
	let
	  val (tyfun, ptr) = decode_tyfun ptr
	  val (valenv, ptr) = decode_refvalenv ptr
	in
	  (DataTypes.TYSTR(tyfun, !valenv), ptr)
	end

      and decode_tyfun ptr =
	let
d1670 3
d1674 18
d1787 4
d1794 17
a1810 24
	      let
		val (n, ptr) = input_int_and_strip(s, ptr, len)
		fun dt' (h::t) 0 = !h
		| dt' (h::t) n = dt' t (n-1)
		| dt' [] _ = raise bad_input14
	      in
		if n=0 then
		  let
		    val r = ref dummy_tyname
		    val _ = tynames_decoded := r :: (!tynames_decoded)
		    val _ = tynames_so_far := (!tynames_so_far)+1
		    val (tyname_id, ptr) = decode_tyname_id ptr
		    val (st, ptr) = decode_string ptr
		    val (i, ptr) = input_int_and_strip(s, ptr, len)
		    val (b, ptr) = decode_bool ptr
		    val (valenv, ptr) = decode_refvalenv ptr
		    val _ = r := DataTypes.TYNAME(tyname_id, st, i, ref b,
						  valenv)
		  in
		    (!r, ptr)
		  end
		else
		  (dt' (!tynames_decoded) (!tynames_so_far - n), ptr)
	      end
d1812 15
a1826 8
	      let
		val (tyfun, ptr) = decode_tyfun ptr
		val (st, ptr) = decode_string ptr
		val (i, ptr) = input_int_and_strip(s, ptr, len)
		val (b, ptr) = decode_bool ptr
	      in
		(DataTypes.METATYNAME(ref tyfun, st, i, ref b), ptr)
	      end
d1830 1
a1830 1
      and decode_phi ptr =
d1832 2
a1833 3
	  val (nameset, ptr) = decode_nameset ptr
	  val (str, ptr) = decode_str ptr
	  val (sigma, ptr) = decode_sigma ptr
d1835 1
a1835 1
	  (Phi.PHI(nameset, (str, sigma)), ptr)
d1838 1
a1838 1
      and decode_sigma ptr =
d1840 2
a1841 2
	  val (nameset, ptr) = decode_nameset ptr
	  val (str, ptr) = decode_str ptr
d1843 1
a1843 1
	  (Sigma.SIGMA(nameset, str), ptr)
d1846 1
a1846 1
      and decode_funenv ptr =
d1848 4
a1851 2
	  val (funenv, ptr) =
	    decode_map decode_funid decode_phi ptr (op =) Ident.funid_order
d1853 1
a1853 1
	  (Funenv.FUNENV funenv, ptr)
d1856 1
a1856 1
      and decode_sigenv ptr =
d1858 2
a1859 2
	  val (sigenv, ptr) =
	    decode_map decode_sigid decode_sigma ptr (op =) Ident.sigid_order
d1861 1
a1861 1
	  (Sigenv.SIGENV sigenv, ptr)
d1872 1
a1872 1
      and decode_tyenv ptr =
d1874 2
a1875 2
	  val (tyenv, ptr) =
	    decode_map decode_tycon decode_tystr ptr (op =) Ident.tycon_order
d1877 1
a1877 1
	  (DataTypes.TE tyenv, ptr)
d1880 1
a1880 1
      and decode_env ptr =
d1882 2
a1883 4
	  val (strenv, ptr) = decode_strenv ptr
	  val (tyenv, ptr) = decode_tyenv ptr
	  val (valenv, ptr) = decode_refvalenv ptr
	  val (exnenv, ptr) = decode_refvalenv ptr
d1885 26
a1910 1
	  (DataTypes.ENV(strenv, tyenv, !valenv, !exnenv), ptr)
@


1.19
log
@Added code for non_gc spills number in front of code objects in a closure
by changing encode_code to propogate it through
@
text
@d4 4
d861 2
d864 26
d946 1
a946 1
      val valenvs_encoded = ref [] : unit ref list ref
d949 1
a949 1

d1051 1
d1058 7
d1068 15
a1082 1
	    encode_map done encode_valid encode_typescheme M
a1094 16
(*
	  fun et'(h::t) = if h = r then length t + 1
			  else et' t
	  | et' [] = (tynames_encoded := (r::(!tynames_encoded)); 0)
	  val pos = et'(!tynames_encoded)
*)
(*
	  val id = (r, Tyname_id.tyname_id ti, s)
	  val pos =
	    (NewMap.apply (!tynames_encoded_in_map) id)
	    handle NewMap.Undefined =>
	      (tynames_encoded_in_map :=
	       NewMap.define(!tynames_encoded_in_map, id, !tyname_count);
	       tyname_count := !tyname_count + 1;
	       0)
*)
d1223 1
a1223 1
      val _ = diagnose_calls
d1243 5
a1247 1
	 "namesets encoded : " ^ Integer.makestring(!namesets) ^ "\n")
d1699 1
a1699 1
	      val _ = r := DataTypes.VE(ref (), valenv)
d1815 106
@


1.18
log
@Added more diagnostics. Tried to improve output of type environments
by using balanced trees instead of association lists. Not very successful
@
text
@d4 4
d307 2
a308 2
	    Lists.reducel op +
	    (0, map (fn (i, s) => size s) w_list)
d314 1
a314 1
	   (fn (i, w) => output_int i ^ output_int(size w) ^ w)
@


1.17
log
@Fixed fault in decode_tyname whereby entire string was being inserted
rather than the relevant substring.
@
text
@d4 4
d109 1
d136 1
d225 2
d335 1
a335 1
    (diagnose_calls("Encode_string size : " ^ Integer.makestring(size s) ^ "\n");
d337 1
a337 1
       diagnose_calls("Big string : '" ^ String.substring(s, 0, 100) ^ "\n")
d392 1
a392 1
    (diagnose_calls("Encoding list length : " ^ Integer.makestring(length x) ^ "\n");
d911 1
a911 1
      val tynames_encoded = ref [] : bool ref list ref
d914 27
d949 2
a950 1
	      output_int id :: output_int 0 :: done
d954 1
d1032 6
d1042 11
d1071 1
d1185 1
d1188 1
d1329 1
d1340 1
@


1.16
log
@Added code to maintain unique tyname and strname_ids across modules.
@
text
@d4 3
d78 1
d80 19
d103 2
d129 2
d172 1
d213 1
d215 12
d248 1
a248 1
	  handle Sum => (print("Sum overflow on " ^
d252 1
a252 1
	       | Prod => (print("Product overflow on " ^
d327 6
a332 1
    s :: output_int(size s) :: done
d383 3
a385 1
  fun encode_list done f x = rev_map (output_int(length x) :: done) f x
d619 4
a622 4
	  val _ = print("fix_map size = " ^ Integer.makestring(length(Map.assoc fix_map)))
	  val _ = print("val_map size = " ^ Integer.makestring(length(Map.assoc val_map)))
	  val _ = print("val_map_range size = " ^ Integer.makestring(length(Map.range val_map)))
	  val _ = print("struct_map size = " ^ Integer.makestring(length(Map.assoc struct_map)))
d752 1
a752 1
	  val _ = print"Decoding fix_env"
d762 2
a763 2
	  val _ = print("fix_env size = " ^ Integer.makestring(length(Map.assoc fix_env)))
	  val _ = print"Decoding val_env"
d770 1
a770 1
	  val _ = print("val_env size = " ^ Integer.makestring(length(val_env)))
d777 1
a777 1
	  val _ = print"Decoding struct_env"
d787 1
a787 1
	  val _ = print("struct_env size = " ^ Integer.makestring(length(Map.assoc struct_env)))
d795 1
a795 1
      val _ = print"Decoding fun_env"
d805 2
a806 2
      val _ = print("fun_env size = " ^ Integer.makestring(length(Map.assoc fun_env)))
      val _ = print"Decoding sig_env"
d816 2
a817 2
      val _ = print("sig_env size = " ^ Integer.makestring(length(Map.assoc sig_env)))
      val _ = print"Decoding parse_env"
d827 18
a905 1

d908 2
d929 2
d949 3
a951 1
	encode_strname_id (output_int 1 :: done, s)
d954 2
d970 3
a972 1
	encode_strname_id (output_int 3 :: done, s)
d976 2
d987 1
a987 1
	    encode_map done  encode_valid encode_typescheme M
d993 2
d1008 4
a1011 2
	encode_bool b :: output_int n ::
	encode_string(encode_tyfun(output_int 2 :: done, tf), s)
d1013 5
a1017 1
      and encode_type(done, DataTypes.METATYVAR(ref(n, t), b1, b2)) =
d1020 1
a1020 1
      | encode_type(done, DataTypes.META_OVERLOADED(ref t)) =
d1022 1
a1022 1
      | encode_type(done, DataTypes.TYVAR(ref n, t)) =
d1024 1
a1024 1
      | encode_type(done, DataTypes.METARECTYPE(ref(n, b1, t, b2, b3))) =
d1027 1
a1027 1
      | encode_type(done, DataTypes.RECTYPE M) =
d1029 1
a1029 1
      | encode_type(done, DataTypes.FUNTYPE(t1, t2)) =
d1031 1
a1031 1
      | encode_type(done, DataTypes.CONSTYPE(l, t)) =
d1033 1
a1033 1
      | encode_type(done, DataTypes.DEBRUIJN(n, b1, b2)) =
d1036 4
a1039 1
      | encode_type(done, DataTypes.NULLTYPE) = output_int 9 :: done
d1041 5
a1045 1
      and encode_typescheme(done, DataTypes.SCHEME(n, t)) =
d1047 1
a1047 1
      | encode_typescheme(done, DataTypes.UNBOUND_SCHEME t) =
d1049 1
a1049 1
      | encode_typescheme(done, DataTypes.OVERLOADED_SCHEME ov) =
d1051 3
d1055 5
a1059 1
      and encode_tyfun(done, DataTypes.TYFUN(t, n)) =
d1061 1
a1061 1
      | encode_tyfun(done, DataTypes.ETA_TYFUN tn) =
d1063 1
a1063 1
      | encode_tyfun(done, DataTypes.NULL_TYFUN tfi) =
d1065 3
d1070 3
a1072 1
	encode_valenv(encode_tyfun(done, tf), ve)
d1075 3
a1077 1
	encode_map done encode_tycon encode_tystr M
d1080 3
a1082 1
	encode_env(encode_strname(done, sn), e)
d1085 3
a1087 1
	encode_map done encode_strid encode_str M
d1090 2
d1093 1
a1093 1
				    ve), ece)
d1096 3
a1098 1
	encode_str(encode_nameset(done, ns), s)
d1101 3
a1103 1
	encode_map done encode_sigid encode_sigma M
d1106 3
a1108 1
	encode_sigma(encode_str(encode_nameset(done, ns), s), sg)
d1111 3
a1113 1
	encode_map done encode_funid encode_phi M
d1116 2
d1121 24
a1144 2
	(Nameset.strnames_of_nameset ns)

d1146 1
a1146 5
      extend_string
      (implode
       (rev
	(encode_env(encode_sigenv(encode_funenv(encode_nameset([], 
			nameset),funenv), sigenv), env))))
d1639 1
a1639 1
		(DataTypes.METATYNAME(ref tyfun, s, i, ref b), ptr)
@


1.15
log
@changed encode and decode tyname_id to work with new tyname_id (ie no
number of constructor field)
@
text
@d4 4
d92 2
d119 2
d182 2
d185 1
a336 5
  fun encode_tyname_id(done, n) =
    output_int(Tyname_id.tyname_id n) :: done

  fun encode_strname_id n = output_int(Strname_id.strname_id n)

d776 2
a777 1
  fun encode_type_basis(Basis.BASIS(nameset, funenv, sigenv, env)) =
d779 57
d840 39
d880 1
a880 1
	encode_strname_id s :: output_int 1 :: done
d897 1
a897 1
	encode_strname_id s :: output_int 3 :: done
d1005 2
a1006 2
	(encode_env(encode_sigenv(encode_funenv(encode_nameset([], nameset),
					     funenv), sigenv), env))))
d1009 1
a1009 1
  fun decode_type_basis s =
d1012 20
d1116 1
a1116 1
	  val (n ,ptr) = input_int_and_strip(s, ptr, len)
d1118 29
a1146 1
	  (Tyname_id.make_tyname_n n, ptr)
d1158 1
a1158 1
	  val (n ,ptr) = input_int_and_strip(s, ptr, len)
d1160 29
a1188 1
	  (Strname_id.make_strname_n n, ptr)
d1191 1
a1246 2


d1571 2
a1572 1
  fun encode_env{parser_env=p_env, ty_env=t_env, lambda_env=l_env} =
d1577 1
a1577 1
      val p_offset = 12
d1583 1
a1583 1
       p_env, t_env, l_env]
d1592 2
d1600 2
a1601 1
       lambda_env=String.substring(s, l_offset, l_size)}
@


1.14
log
@Changed encoding for meta strnames to mainting sharing of identical
refs on decoding of type environments.
@
text
@d4 4
d327 1
a327 2
    output_int(Tyname_id.no_of_cons n) :: output_int(Tyname_id.tyname_id n) ::
    done
a992 1
	  val (m ,ptr) = input_int_and_strip(s, ptr, len)
d995 1
a995 1
	  (Tyname_id.make_tyname_mn(m, n), ptr)
@


1.13
log
@Fixed bug whereby decoded lists arrived backwards
@
text
@d3 4
a6 1
$Log:	_encapsulate.sml,v $
d771 1
d776 14
a789 1
	encode_strname(output_int 2 :: done, !s)
a1009 26
      fun decode_strname ptr =
	let
	  val (i, ptr) = input_int_and_strip(s, ptr, len)
	in
	  case i of
	    1 =>
	      let
		val (id, ptr) = decode_strname_id ptr
	      in
		(DataTypes.STRNAME id, ptr)
	      end
	  | 2 =>
	      let
		val (name, ptr) = decode_strname ptr
	      in
		(DataTypes.METASTRNAME(ref name), ptr)
	      end
	  | 3 =>
	      let
		val (id, ptr) = decode_strname_id ptr
	      in
		(DataTypes.NULLNAME id, ptr)
	      end
	  | _ => raise bad_input8
	end

d1060 47
@


1.12
log
@Changed the header ordering to a more readily extensible system
@
text
@d4 3
d436 1
a436 1
	  fun dec_sub(0, ptr, done) = (done, ptr)
d660 1
a660 1
	  fun dec_sub(0, ptr, done) = (done, ptr)
d1032 1
a1032 1
	  fun dec_sub(0, ptr, done) = (done, ptr)
d1407 1
a1407 1
	  fun dec_sub(0, ptr, done) = (done, ptr)
@


1.11
log
@Fixed problem in decoding parser envs where the pointer was being reset
to 0
@
text
@d4 4
d1449 4
a1452 4
	output_int code_size, output_int env_size,
	output_int debug_size, output_int cons_size,
	output_int code_offset, output_int env_offset,
	output_int debug_offset, output_int cons_offset]
d1469 1
d1471 1
d1473 1
a1474 3
      val (code_offset, ptr) = input_int_and_strip(header, ptr, header_size)
      val (env_offset, ptr) = input_int_and_strip(header, ptr, header_size)
      val (debug_offset, ptr) = input_int_and_strip(header, ptr, header_size)
@


1.10
log
@Tidied up to use map and list and pair encodings and decodings. Should
improve consistency between encode and decode
@
text
@d4 4
d144 16
d185 1
a185 1
			 raise bad_input)
d189 1
a189 1
			 raise bad_input)
d203 1
a203 1
      raise bad_input
d275 1
a275 1
    output_int 0 :: encode_symbol(done, sy)
d277 1
a277 1
    output_int 1 :: encode_symbol(done, sy)
d279 1
a279 1
    output_int 2 :: encode_symbol(done, sy)
d313 1
a313 1
    output_int(Tyname_id.tyname_id n) :: output_int(Tyname_id.no_of_cons n) ::
d550 8
d570 1
a570 1

d598 1
a599 1
	  val (sy_type, ptr) = input_int_and_strip(s, ptr, len)
d604 1
a604 1
	  | _ => raise bad_input
d648 1
a648 1
	  | _ => raise bad_input
d684 3
d694 4
d702 3
d709 3
d719 3
d727 3
d737 4
d745 1
a745 1
	0
d748 4
d849 1
a849 1
      and encode_env(done, DataTypes.ENV(se,te,ve,ece)) =
d889 1
a889 1
	  | _ => raise bad_input
d909 1
a910 1
	  val (sy_type, ptr) = input_int_and_strip(s, ptr, len)
d915 1
a915 1
	  | _ => raise bad_input
d1009 1
a1009 1
	  | _ => raise bad_input
d1020 1
a1020 1
	  | _ => raise bad_input
d1111 1
a1111 1
	  | _ => raise bad_input
d1138 1
a1138 1
	  | _ => raise bad_input
d1208 1
a1208 1
	  | _ => raise bad_input
d1216 1
a1216 1
	  | dv' [] _ = raise bad_input
d1247 1
a1247 1
		| dt' [] _ = raise bad_input
d1276 1
a1276 1
	  | _ => raise bad_input
d1461 1
a1461 1
      val _ = if size header <> header_size then raise bad_input else ()
@


1.9
log
@Added encdoing and decoding of typechecker bases
@
text
@d4 3
a70 1
require "../lambda/environ";
d72 1
a72 1
require "objectfile";
a95 1
  structure Environ : ENVIRON
a104 1
  sharing EnvironTypes = Environ.EnvironTypes
a231 8
      | rev_sub(done, x :: xs) = rev_sub(f x :: done, xs)
    in
      rev_sub(done, x)
    end

  fun rev_map' done f x =
    let
      fun rev_sub(done, []) = done
d250 4
d255 1
a255 1
    output_int 0 :: encode_symbol(done, sy )
d257 1
a257 1
    output_int 1 :: encode_symbol(done, sy )
d259 1
a259 1
    output_int 2 :: encode_symbol(done, sy )
d261 7
d298 1
a298 1
  fun encode_list done f x = rev_map' (output_int(length x) :: done) f x
d300 1
a300 1
  fun encode_pair done f g (a, b) = g(f(done, a), b)
d305 1
a305 1
    (fn (done, (x, y)) => encode_pair done f g (x, y))
d318 1
a318 1
      fun encode_sub(extra, done, EnvironTypes.ENV(v_map, e_map, s_map)) =
d320 6
a325 6
	  val v_map = Map.assoc v_map
	  val e_map = Map.assoc e_map
	  val s_map = Map.assoc s_map
	  val v_len = length v_map
	  val e_len = length e_map
	  val s_len = length s_map
a326 4
	  fun do_var(done,
		     (Ident.VAR x, EnvironTypes.FIELD{index=index, ...})) =
	    output_int index :: encode_symbol(done, x)
	  | do_var _ = Crash.impossible"encode_lambda_env bad v_map"
a327 20
	  fun do_exn(done,
		     (Ident.EXCON x, EnvironTypes.FIELD{index=index, ...})) =
	    output_int index :: encode_symbol(done, x)
	  | do_exn _ = Crash.impossible"encode_lambda_env bad e_map"

	  fun do_str(done, (strid,
			    (env, EnvironTypes.FIELD{index=index, ...}))) =
	    encode_sub(0, output_int index :: encode_strid(done, strid), env)
	  | do_str _ = Crash.impossible"encode_lambda_env bad s_map"

	  val result =
	    rev_map'
	    (output_int s_len ::
	     rev_map'
	     (output_int e_len ::
	      rev_map'
	      (output_int v_len :: output_int env_len :: done)
	      do_var v_map)
	     do_exn e_map)
	    do_str s_map
d329 13
a341 1
	  result
d346 7
a352 12
	let
	  val s_map = Map.assoc s_map
	  val v_len = length v_list
	  val e_len = length e_list
	  val s_len = length s_map
	  fun do_var(Ident.VAR x) =
	    let
	      val s = Symbol.symbol_name x
	    in
	      implode[output_int(size s), s]
	    end
	  | do_var _ = Crash.impossible"encode_lambda_env bad v_list"
d354 3
a356 33
	  fun do_exn(Ident.EXCON x) =
	    let
	      val s = Symbol.symbol_name x
	    in
	      implode[output_int(size s), s]
	    end
	  | do_exn _ = Crash.impossible"encode_lambda_env bad e_list"

	  fun do_str(done, (strid, interface)) =
	    encode_interface(encode_strid(done, strid), interface)

	  val result =
	    rev_map'
	    (output_int s_len ::
	     rev_map
	     (output_int e_len ::
	      rev_map
	      (output_int v_len :: done)
	      do_var v_list)
	     do_exn e_list)
	    do_str s_map
	in
	  result
	end

      fun do_ftr(done, (funid,
			(EnvironTypes.FIELD{index=index, ...}, interface,
			 env))) =
	encode_sub(0, encode_interface(output_int index ::
				       encode_funid(done, funid),
				       interface),
		   env)
      | do_ftr _ = Crash.impossible"encode_lambda_env bad f_map"
d358 7
a364 5
      extend_string(implode(rev(encode_sub(f_len, rev_map'
					   [output_int f_len,
					    output_int(f_len + env_len)]
					   do_ftr
					   f_map, env))))
d379 1
a379 1
      fun read_env ptr =
d381 4
a384 13
	  val (env_size, ptr) = input_int_and_strip(s, ptr, len)
	  fun read_v_env(0, ptr, done) = (done, ptr)
	  | read_v_env(v_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.VAR sy
	      val (offset, ptr) = input_int_and_strip(s, ptr, len)
	    in
	      read_v_env(v_len-1, ptr,
			 Environ.add_valid_env
			 ((id, EnvironTypes.FIELD{index=offset,
						  size=env_size}), done))
	    end
d386 6
a391 12
	  fun read_e_env(0, ptr, done) = (done, ptr)
	  | read_e_env(e_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.EXCON sy
	      val (offset, ptr) = input_int_and_strip(s, ptr, len)
	    in
	      read_e_env(e_len-1, ptr,
			 Environ.add_exn_env
			 ((id, EnvironTypes.FIELD{index=offset,
						  size=env_size}), done))
	    end
d393 6
a398 14
	  fun read_s_env(0, ptr, done) = (done, ptr)
	  | read_s_env(s_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.STRID sy
	      val (offset, ptr) = input_int_and_strip(s, ptr, len)
	      val (env, ptr) = read_env ptr
	    in
	      read_s_env(s_len-1, ptr,
			 Environ.add_strid_env
			 ((id, (env, EnvironTypes.FIELD{index=offset,
							size=env_size})),
			  done))
	    end
d400 3
a402 6
	  val (v_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (env, ptr) = read_v_env(v_len, ptr, Environ.empty_env)
	  val (e_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (env, ptr) = read_e_env(e_len, ptr, env)
	  val (s_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (env, ptr) = read_s_env(s_len, ptr, env)
d404 1
a404 1
	  (env, ptr)
d407 1
a407 1
      fun read_interface ptr =
d409 2
a410 2
	  fun read_v_interface(0, ptr, done) = (done, ptr)
	  | read_v_interface(v_len, ptr, done) =
d412 1
a412 2
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.VAR sy
d414 1
a414 1
	      read_v_interface(v_len-1, ptr, id :: done)
d416 4
d421 7
a427 8
	  fun read_e_interface(0, ptr, done) = (done, ptr)
	  | read_e_interface(e_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.EXCON sy
	    in
	      read_e_interface(e_len-1, ptr, id :: done)
	    end
d429 13
a441 2
	  fun read_s_interface(0, ptr, done) = (done, ptr)
	  | read_s_interface(s_len, ptr, done) =
d443 1
a443 3
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.STRID sy
	      val (interface, ptr) = read_interface ptr
d445 1
a445 3
	      read_s_interface(s_len-1, ptr,
			       Map.add((id, interface), done,
				       Ident.strid_order))
d448 21
a468 6
	  val (v_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (v_int, ptr) = read_v_interface(v_len, ptr, [])
	  val (e_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (e_int, ptr) = read_e_interface(e_len, ptr, [])
	  val (s_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (s_int, ptr) = read_s_interface(s_len, ptr, Map.empty_map)
d470 21
d494 1
a494 1
      fun read_fun_env ptr =
d496 3
a498 17
	  val (ftr_size, ptr) = input_int_and_strip(s, ptr, size s)
	  fun read_f_env(0, ptr, done) = (done, ptr)
	  | read_f_env(f_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val id = Ident.FUNID sy
	      val (offset, ptr) = input_int_and_strip(s, ptr, len)
	      val (interface, ptr) = read_interface ptr
	      val (env, ptr) = read_env ptr
	    in
	      read_f_env(f_len-1, ptr,
			 Environ.add_funid_env
			 ((id, (EnvironTypes.FIELD{index=offset,
						   size=total_size},
				interface, env)),
			  done))
	    end
d500 2
a501 1
	  read_f_env(ftr_size, ptr, EnvironTypes.FUN_ENV(Map.empty_map))
d503 8
a510 1
      val (fun_env, ptr) = read_fun_env ptr
d512 1
d514 1
a514 1
      EnvironTypes.TOP_ENV(env, fun_env)
a519 4
      val fun_map = Map.assoc fun_map
      val sig_map = Map.assoc sig_map
      val fun_len = length fun_map
      val sig_len = length sig_map
d530 12
a541 26
	let
	  val fix_map = Map.assoc fix_map
	  val val_map = Map.assoc val_map
	  val fix_len = length fix_map
	  val val_len = length val_map
	  val struct_map = Map.assoc struct_map
	  val struct_len = length struct_map
	  fun do_fix(done, (sy, fixity)) =
	    encode_fixity(encode_symbol(done, sy), fixity)
	  fun do_val(done, (_, valid)) = encode_valid(done, valid)
	  fun do_struct(done, (strid, env)) =
	    encode_pe(encode_strid(done, strid), env)
	in
	  rev_map'
	  (output_int struct_len ::
	   (rev_map'
	    (output_int val_len ::
	     (rev_map'
	      (output_int fix_len :: done)
	      do_fix
	      fix_map))
	    do_val
	    val_map))
	  do_struct
	  struct_map
	end
a542 6
      fun encode_pf(done, (funid, pe)) =
	encode_pe(encode_funid(done, funid), pe)

      fun encode_pg(done, (sigid, pe)) =
	encode_pe(encode_sigid(done, sigid), pe)

d545 9
a553 6
				((rev_map'
				  (output_int sig_len ::
				   (rev_map'
				    [output_int fun_len]
				    encode_pf fun_map))
				  encode_pg sig_map),
d581 21
d623 1
a623 1
      fun read_parse_env ptr =
d625 2
a626 2
	  fun read_fix_env(0, ptr, done) = (done, ptr)
	  | read_fix_env(fix_len, ptr, done) =
d628 1
a628 2
	      val (sy, ptr) = decode_symbol ptr
	      val (fixity, ptr) = decode_fixity ptr
d630 1
a630 2
	      read_fix_env(fix_len - 1, ptr,
			   ParserEnv.addFixity((sy, fixity), done))
d632 1
a632 26

	  fun read_val_env(0, ptr, done) = (done, ptr)
	  | read_val_env(val_len, ptr, done) =
	    let
	      val (valid, ptr) = decode_valid ptr
	    in
	      read_val_env(val_len - 1, ptr, ParserEnv.addValId(valid, done))
	    end

	  fun read_struct_env(0, ptr, done) = (done, ptr)
	  | read_struct_env(struct_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val (env, ptr) = read_parse_env ptr
	    in
	      read_struct_env(struct_len - 1, ptr,
			   ParserEnv.addStrId((Ident.STRID sy, env), done))
	    end

	  val (fix_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (fix_env, ptr) = read_fix_env(fix_len, ptr, ParserEnv.empty_pFE)
	  val (val_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (val_env, ptr) = read_val_env(val_len, ptr, ParserEnv.empty_pVE)
	  val (struct_len, ptr) = input_int_and_strip(s, ptr, len)
	  val (struct_env, ptr) =
	    read_struct_env(struct_len, ptr, ParserEnv.empty_pSE)
d634 1
a634 1
	  (ParserEnv.E(fix_env, val_env, struct_env), ptr)
d637 1
a637 1
      fun read_fun_env ptr =
d639 2
a640 10
	  val (fun_size, ptr) = input_int_and_strip(s, ptr, len)
	  fun read_f_env(0, ptr, done) = (done, ptr)
	  | read_f_env(f_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val (env, ptr) = read_parse_env ptr
	    in
	      read_f_env(f_len - 1, ptr,
			 ParserEnv.addFunId((Ident.FUNID sy, env), done))
	    end
d642 1
a642 1
	  read_f_env(fun_size, ptr, ParserEnv.empty_pF)
d645 1
a645 1
      fun read_sig_env ptr =
d647 1
a647 10
	  val (sig_size, ptr) = input_int_and_strip(s, ptr, len)
	  fun read_g_env(0, ptr, done) = (done, ptr)
	  | read_g_env(g_len, ptr, done) =
	    let
	      val (sy, ptr) = decode_symbol ptr
	      val (env, ptr) = read_parse_env ptr
	    in
	      read_g_env(g_len - 1, ptr,
			 ParserEnv.addSigId((Ident.SIGID sy, env), done))
	    end
d649 3
a651 1
	  read_g_env(sig_size, ptr, ParserEnv.empty_pG)
d653 29
d683 14
a696 2
      val (fun_env, ptr) = read_fun_env 0
      val (sig_env, ptr) = read_sig_env ptr
d699 1
a699 1
      ParserEnv.B(fun_env, sig_env, parse_env)
d1318 51
@


1.8
log
@Finished parser environment encapsulation. Began typechecker basis work.
@
text
@d4 3
d32 19
d60 7
d81 1
d83 10
a92 1
  structure Interface : INTERFACE
d98 2
a99 1
  sharing Map = EnvironTypes.Map = Interface.Map = ParserEnv.Map
d101 2
a102 1
  sharing Ident = EnvironTypes.Ident = Interface.Ident = ParserEnv.Ident
d105 11
d248 3
d255 1
a255 1
      sy :: output_int(size sy) :: done
d283 12
d297 8
a304 2
  fun encode_map done f x = encode_list done f (Map.assoc x)
    
d732 3
a734 1
    Crash.unimplemented"encode_type_basis"
d736 117
d866 1
a866 1
      fun decode_symbol ptr =
d869 1
a869 1
	  val sy = Symbol.find_symbol(input_string(s, ptr, sy_size, len))
d874 7
d938 59
d1002 1
a1002 1
	      val (done, ptr) = f ptr
d1004 1
a1004 1
	      dec_sub(n-1, ptr, done)
d1011 1
a1011 1
      fun decode_map f ptr (eqfn, orderfn) =
d1013 2
a1014 1
	  val (assoc_list, ptr) = decode_list f ptr
d1016 7
d1027 17
d1045 271
d1317 1
a1317 1
      Crash.unimplemented"encode_type_basis"
@


1.7
log
@Wrote input_file, and added temporary versions for encoding and decoding
parser environments
@
text
@d4 4
d37 1
d52 1
d59 3
a61 3
  sharing Map = EnvironTypes.Map = Interface.Map
  sharing Symbol = Ident.Symbol
  sharing Ident = EnvironTypes.Ident = Interface.Ident
d70 1
d177 55
a234 16
      fun rev_map done f x =
	let
	  fun rev_sub(done, []) = done
	  | rev_sub(done, x :: xs) = rev_sub(f x :: done, xs)
	in
	  rev_sub(done, x)
	end

      fun rev_map' done f x =
	let
	  fun rev_sub(done, []) = done
	  | rev_sub(done, x :: xs) = rev_sub(f(done, x), xs)
	in
	  rev_sub(done, x)
	end

d251 3
a253 6
	  fun do_var(Ident.VAR x, EnvironTypes.FIELD{index=index, ...}) =
	    let
	      val s = Symbol.symbol_name x
	    in
	      implode[output_int(size s), s, output_int index]
	    end
d256 3
a258 6
	  fun do_exn(Ident.EXCON x, EnvironTypes.FIELD{index=index, ...}) =
	    let
	      val s = Symbol.symbol_name x
	    in
	      implode[output_int(size s), s, output_int index]
	    end
d261 1
a261 1
	  fun do_str(done, (Ident.STRID x,
d263 1
a263 6
	    let
	      val s = Symbol.symbol_name x
	    in
	      encode_sub(0, output_int index :: s :: output_int(size s) ::
			 done, env)
	    end
d269 1
a269 1
	     rev_map
d271 1
a271 1
	      rev_map
d303 2
a304 6
	  fun do_str(done, (Ident.STRID x, interface)) =
	    let
	      val s = Symbol.symbol_name x
	    in
	      encode_interface(s :: output_int(size s) :: done, interface)
	    end
d320 1
a320 1
      fun do_ftr(done, (Ident.FUNID x,
d323 4
a326 8
	let
	  val s = Symbol.symbol_name x
	in
	  encode_sub(0, encode_interface(output_int index :: s ::
					 output_int(size s) :: done,
					 interface),
		     env)
	end
d339 2
a340 2
      val (total_size , ptr) = input_int_and_strip(s, 0, size s)
      fun read_env(s, ptr) =
d342 8
d351 12
a362 14
	  fun read_v_env(v_len, s, ptr, done) =
	    if v_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.VAR
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
		val (offset, ptr) = input_int_and_strip(s, ptr + id_size, len)
	      in
		read_v_env(v_len-1, s, ptr,
			   Environ.add_valid_env
			   ((id, EnvironTypes.FIELD{index=offset,
						    size=env_size}), done))
	      end
d364 12
a375 14
	  fun read_e_env(e_len, s, ptr, done) =
	    if e_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.EXCON
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
		val (offset, ptr) = input_int_and_strip(s, ptr + id_size, len)
	      in
		read_e_env(e_len-1, s, ptr,
			   Environ.add_exn_env
			   ((id, EnvironTypes.FIELD{index=offset,
						    size=env_size}), done))
	      end
d377 14
a390 16
	  fun read_s_env(s_len, s, ptr, done) =
	    if s_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.STRID
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
		val (offset, ptr) = input_int_and_strip(s, ptr + id_size, len)
		val (env, ptr) = read_env(s, ptr)
	      in
		read_s_env(s_len-1, s, ptr,
			   Environ.add_strid_env
			   ((id, (env, EnvironTypes.FIELD{index=offset,
							  size=env_size})),
			     done))
	      end
d393 1
a393 1
	  val (env, ptr) = read_v_env(v_len, s, ptr, Environ.empty_env)
d395 1
a395 1
	  val (env, ptr) = read_e_env(e_len, s, ptr, env)
d397 1
a397 1
	  val (env, ptr) = read_s_env(s_len, s, ptr, env)
d402 1
a402 1
      fun read_interface(s, ptr) =
d404 8
a411 10
	  fun read_v_interface(v_len, s, ptr, done) =
	    if v_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.VAR
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
	      in
		read_v_interface(v_len-1, s, ptr, id :: done)
	      end
d413 8
a420 10
	  fun read_e_interface(e_len, s, ptr, done) =
	    if e_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.EXCON
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
	      in
		read_e_interface(e_len-1, s, ptr, id :: done)
	      end
d422 11
a432 13
	  fun read_s_interface(s_len, s, ptr, done) =
	    if s_len = 0 then (done, ptr)
	    else
	      let
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val id = Ident.STRID
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
		val (interface, ptr) = read_interface(s, ptr)
	      in
		read_s_interface(s_len-1, s, ptr,
				 Map.add((id, interface), done,
					 Ident.strid_order))
	      end
d435 1
a435 1
	  val (v_int, ptr) = read_v_interface(v_len, s, ptr, [])
d437 1
a437 1
	  val (e_int, ptr) = read_e_interface(e_len, s, ptr, [])
d439 1
a439 1
	  val (s_int, ptr) = read_s_interface(s_len, s, ptr, Map.empty_map)
d444 1
a444 1
      fun read_fun_env(s, ptr) =
d447 116
a562 3
	  fun read_f_env(f_len, s, ptr, done) =
	    if f_len = 0 then (done, ptr)
	    else
d564 1
a564 6
		val (id_size, ptr) = input_int_and_strip(s, ptr, len)
		val sy = input_string(s, ptr, id_size, len)
		val id = Ident.FUNID(Symbol.find_symbol sy)
		val (offset, ptr) = input_int_and_strip(s, ptr + id_size, len)
		val (interface, ptr) = read_interface(s, ptr)
		val (env, ptr) = read_env(s, ptr)
d566 1
a566 6
		read_f_env(f_len-1, s, ptr,
			   Environ.add_funid_env
			   ((id, (EnvironTypes.FIELD{index=offset,
						     size=total_size},
				  interface, env)),
			     done))
d568 47
d616 1
a616 1
	  read_f_env(ftr_size, s, ptr, EnvironTypes.FUN_ENV(Map.empty_map))
d618 36
a653 2
      val (fun_env, ptr) = read_fun_env(s, ptr)
      val (env, _) = read_env(s, ptr)
d655 1
a655 1
      EnvironTypes.TOP_ENV(env, fun_env)
d658 2
a659 1
  fun encode_parser_env basis = Crash.unimplemented"encode_parser_env"
d661 104
a764 1
  fun decode_parser_env s = Crash.unimplemented"decode_parser_env"
@


1.6
log
@Completed decoding of lambda environments
@
text
@d4 3
d31 1
d46 1
d63 1
d451 4
d484 2
d495 1
a495 1
      val code_offset = 10*4
d516 37
a552 1
  fun input_file s = Crash.unimplemented"input_file"
@


1.5
log
@Added encoding and decoding of lambda environments
@
text
@d4 3
d97 8
a368 1
	  val (interface_size, ptr) = input_int_and_strip(s, ptr, len)
d423 2
a424 2
		val id = Ident.FUNID
		  (Symbol.find_symbol(input_string(s, ptr, id_size, len)))
d437 1
a437 2
	  (EnvironTypes.FUN_ENV(Map.empty_map), ptr)
	  (* Temporary solution *)
@


1.4
log
@Output of real numbers added
@
text
@d4 3
d21 7
d35 7
d44 6
d53 1
d71 2
d86 25
a118 2
  val code_external = 3

d153 312
d494 2
a496 2


@


1.3
log
@Put zero termination on strings
@
text
@d4 3
d73 3
a75 1
	Crash.unimplemented"Output real"
@


1.2
log
@Acquired opcodes and magic number from ObjectFile
@
text
@d4 3
d59 4
a62 4
      0 => s
    | 1 => s ^ "   "
    | 2 => s ^ "  "
    | 3 => s ^ " "
d73 2
a74 2
	[output_int ObjectFile.opcode_string, output_int i, output_int(size s),
	extend_string s]
d90 3
a92 2
	implode [output_int ObjectFile.opcode_external, output_int i,
		 output_int(size s), extend_string s]
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d13 1
d20 1
a61 3
  val code_wordset = 0
  val code_real = 1
  val code_string = 2
d66 7
a72 2
      fun output_module_element_list(offset, [], result) = (offset, result)
      | output_module_element_list(offset, element :: rest_list, result) =
d74 4
a77 24
	  val element_code =
	    case element of
	      MachTypes.REAL(i, r) => Crash.unimplemented"Output real"
	    | MachTypes.STRING(i, s) =>
		output_int code_string ^ output_int i ^ output_int(size s) ^
		extend_string s
	    | MachTypes.WORDSET(MachTypes.WORD_SET w_list) =>
		let
		  val wordset_len = length w_list
		  val wordset_size =
		    Lists.reducel op +
		    (0, map (fn (i, s) => size s) w_list)
		in
		  Lists.reducel
		  op ^
		  (output_int code_wordset ^ output_int wordset_len ^
		   output_int wordset_size,
		   map
		   (fn (i, w) => output_int i ^ output_int(size w) ^ w)
		   w_list)
		end
	    | MachTypes.EXTERNAL(i, s) =>
		output_int code_external ^ output_int i ^ extend_string s
	  val element_size = size element_code
d79 6
a84 2
	  output_module_element_list(offset + element_size, rest_list,
				     result ^ element_code)
d86 3
a88 3

      val (module_size, code) =
	output_module_element_list(0, element_list, "")
d90 3
a92 1
      code ^ output_int module_size
d109 7
a115 5
	output_int 0 ^ output_int 0 ^ (* Magic word plus version *)
	output_int code_size ^ output_int env_size ^
	output_int debug_size ^ output_int cons_size ^
	output_int code_offset ^ output_int env_offset ^
	output_int debug_offset ^ output_int cons_offset
d125 2
@
