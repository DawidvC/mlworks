head	1.47;
access;
symbols
	MLW_daveb_inline_1_4_99:1.47.1
	MLWorks_21c0_1999_03_25:1.47
	MLWorks_20c1_1998_08_20:1.47
	MLWorks_20c0_1998_08_04:1.47
	MLWorks_20b2c2_1998_06_19:1.47
	MLWorks_20b2_Windows_1998_06_12:1.47
	MLWorks_20b1c1_1998_05_07:1.47
	MLWorks_20b0_1998_04_07:1.47
	MLWorks_20b0_1998_03_20:1.47
	MLWorks_20m2_1998_02_16:1.46
	MLWorks_20m1_1997_10_23:1.46
	MLWorks_11r1:1.45.8.1.1.1.1
	MLWorks_workspace_97:1.46.2
	MLWorks_dt_wizard:1.46.1
	MLWorks_11c0_1997_09_09:1.45.8.1.1.1
	MLWorks_10r3:1.45.8.1.3
	MLWorks_10r2_551:1.45.8.1.2
	MLWorks_11:1.45.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.45.8.1
	MLWorks_20m0_1997_06_20:1.46
	MLWorks_1_0_r2c2_1997_06_14:1.45.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.45.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.45.8
	MLWorks_BugFix_1997_04_24:1.45
	MLWorks_1_0_r2_Win32_1997_04_11:1.45
	MLWorks_1_0_r2_Unix_1997_04_04:1.45
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.45.6.1.1
	MLWorks_gui_1996_12_18:1.45.7
	MLWorks_1_0_Win32_1996_12_17:1.45.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.45.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.45.4.1
	MLWorks_1_0_Irix_1996_11_28:1.45.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.45.5
	MLWorks_1_0_Unix_1996_11_14:1.45.4
	MLWorks_Open_Beta2_1996_10_11:1.45.3
	MLWorks_License_dev:1.45.2
	MLWorks_1_open_beta_1996_09_13:1.45.1
	MLWorks_Open_Beta_1996_08_22:1.45
	MLWorks_Beta_1996_07_02:1.45
	MLWorks_Beta_1996_06_07:1.45
	MLWorks_Beta_1996_06_06:1.45
	MLWorks_Beta_1996_06_05:1.45
	MLWorks_Beta_1996_06_03:1.45
	MLWorks_Beta_1996_05_31:1.45
	MLWorks_Beta_1996_05_30:1.45
	ML_beta_release_12/08/94:1.36
	ML_beta_release_03/08/94:1.36
	ML_revised_beta_release_25/05/94:1.36
	ML_final_beta_release_02/03/94:1.36
	mlworks-28-01-1994:1.35
	Release:1.35
	mlworks-beta-01-09-1993:1.35
	MLWorks-1-0-4-29/01/1993:1.32
	MLWorks-1-0-3-21/12/1992:1.32
	MLWorks-1-0-2-15/12/1992:1.32
	MLWorks-1-0-1-04/12/1992:1.32
	checkpoint_17_08_92:1.30
	Ten15_release_19-08-91:1.10
	ten15_release:1.7
	ten15:1.7;
locks; strict;
comment	@ * @;


1.47
date	98.02.19.16.45.36;	author mitchell;	state Exp;
branches
	1.47.1.1;
next	1.46;

1.46
date	97.05.01.13.15.25;	author jont;	state Exp;
branches
	1.46.1.1
	1.46.2.1;
next	1.45;

1.45
date	95.09.13.18.52.39;	author daveb;	state Exp;
branches
	1.45.1.1
	1.45.2.1
	1.45.3.1
	1.45.4.1
	1.45.5.1
	1.45.6.1
	1.45.7.1
	1.45.8.1;
next	1.44;

1.44
date	95.09.13.15.05.05;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	95.08.31.10.49.04;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	95.08.01.10.03.52;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	95.07.28.16.55.09;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	95.07.26.15.01.58;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	95.07.20.16.00.47;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	95.07.14.10.03.56;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.05.26.10.09.12;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	94.02.02.14.52.48;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.07.07.17.59.29;	author daveb;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	93.03.10.15.48.19;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.03.05.12.50.50;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.08.26.12.14.56;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.08.17.14.18.59;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.06.18.16.55.18;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.06.10.14.14.39;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.05.15.16.23.22;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.05.13.10.58.41;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.03.23.11.42.42;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.03.03.11.16.30;	author richard;	state Exp;
branches;
next	1.24;

1.24
date	92.03.02.16.03.14;	author richard;	state Exp;
branches;
next	1.23;

1.23
date	92.02.12.15.22.13;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.01.31.11.11.09;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.01.16.16.44.33;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.01.10.14.30.42;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	92.01.09.17.55.17;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.11.28.17.07.49;	author richard;	state Exp;
branches;
next	1.17;

1.17
date	91.11.14.14.10.00;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.10.22.15.09.47;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	91.10.16.16.13.15;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.09.16.16.55.42;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.09.16.16.37.20;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.08.23.11.39.49;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.08.22.13.52.52;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.08.09.14.27.05;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.08.07.14.25.07;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.08.02.14.47.34;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.07.24.12.15.10;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.07.22.13.41.04;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.07.19.16.52.57;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.07.15.13.05.27;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.12.16.27.36;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.11.17.06.34;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.10.12.00.11;	author jont;	state Exp;
branches;
next	;

1.35.1.1
date	93.07.07.17.59.29;	author jont;	state Exp;
branches;
next	;

1.45.1.1
date	96.09.13.11.18.37;	author hope;	state Exp;
branches;
next	;

1.45.2.1
date	96.10.07.16.08.30;	author hope;	state Exp;
branches;
next	;

1.45.3.1
date	96.10.17.11.26.45;	author hope;	state Exp;
branches;
next	;

1.45.4.1
date	96.11.14.12.52.07;	author hope;	state Exp;
branches
	1.45.4.1.1.1;
next	;

1.45.4.1.1.1
date	96.11.28.15.03.07;	author hope;	state Exp;
branches;
next	;

1.45.5.1
date	96.11.22.18.11.18;	author hope;	state Exp;
branches;
next	;

1.45.6.1
date	96.12.17.17.49.50;	author hope;	state Exp;
branches
	1.45.6.1.1.1;
next	;

1.45.6.1.1.1
date	97.02.24.11.40.02;	author hope;	state Exp;
branches;
next	;

1.45.7.1
date	96.12.18.09.43.55;	author hope;	state Exp;
branches;
next	;

1.45.8.1
date	97.05.12.10.36.24;	author hope;	state Exp;
branches
	1.45.8.1.1.1
	1.45.8.1.2.1
	1.45.8.1.3.1;
next	;

1.45.8.1.1.1
date	97.07.28.18.21.07;	author daveb;	state Exp;
branches
	1.45.8.1.1.1.1.1;
next	;

1.45.8.1.1.1.1.1
date	97.10.07.11.46.35;	author jkbrook;	state Exp;
branches;
next	;

1.45.8.1.2.1
date	97.09.08.17.14.33;	author daveb;	state Exp;
branches;
next	;

1.45.8.1.3.1
date	97.09.09.14.10.26;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	97.09.10.19.26.23;	author brucem;	state Exp;
branches;
next	;

1.46.2.1
date	97.09.11.20.56.24;	author daveb;	state Exp;
branches;
next	;

1.47.1.1
date	99.04.01.17.58.01;	author daveb;	state Exp;
branches;
next	;


desc
@Setting up initial environment
@


1.47
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(* _primitives.sml the functor *)
(*
$Log: _primitives.sml,v $
 * Revision 1.46  1997/05/01  13:15:25  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
Revision 1.44  1995/09/13  15:05:05  daveb
Added int32 operations.

Revision 1.43  1995/08/31  10:49:04  daveb
Added eq and ne operators for new numeric types to the list
of overloaded operators found here.

Revision 1.42  1995/08/01  10:03:52  jont
Change setup of overloaded names

Revision 1.41  1995/07/28  16:55:09  jont
Add overloading for div and mod on ints and words

Revision 1.40  1995/07/26  15:01:58  jont
Fix problems with overloaded operator table

Revision 1.39  1995/07/20  16:00:47  jont
Add word functions

Revision 1.38  1995/07/14  10:03:56  jont
Add overloaded char relations

Revision 1.37  1995/05/26  10:09:12  matthew
Extended set of builtins available for compiling the builtin library

Revision 1.36  1994/02/02  14:52:48  nosa
generate_moduler compiler option in strenvs and funenvs for compatibility purposes.

Revision 1.35  1993/07/07  17:59:29  daveb
Removed exception environments.

Revision 1.34  1993/03/10  15:48:19  matthew
Signature revisions

Revision 1.33  1993/03/05  12:50:50  jont
Added builtin string relationals

Revision 1.32  1992/08/26  12:14:56  jont
Removed some redundant structures and sharing

Revision 1.31  1992/08/17  14:18:59  jont
Added inline ordof

Revision 1.30  1992/06/18  16:55:18  jont
Added call_ml_value to list of imperative builtins

Revision 1.29  1992/06/10  14:14:39  jont
changed to use newmap

Revision 1.28  1992/05/15  16:23:22  clive
Tried to neaten

Revision 1.27  1992/05/13  10:58:41  clive
Added the Bits structure

Revision 1.26  1992/03/23  11:42:42  jont
Added require for crash

Revision 1.25  1992/03/03  11:16:30  richard
Added EQFUN to initial valenv.

Revision 1.24  1992/03/02  16:03:14  richard
Changed pervasive EQ to EQFUN.  EQ is the inline version.  See Mir_Cg.

Revision 1.23  1992/02/12  15:22:13  clive
New pervasive library

Revision 1.22  1992/01/31  11:11:09  clive
Array-problems - the structure was missing

Revision 1.21  1992/01/16  16:44:33  clive
Added arrays to the initial basis - needed to mark them as imperative

Revision 1.20  1992/01/10  14:30:42  richard
Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.

Revision 1.19  1992/01/09  17:55:17  jont
Updated to use Lists.foldl and new stuff from environ

Revision 1.18  1991/11/28  17:07:49  richard
Removed MAKE_NEW_UNIQUE from the list of primitives.

Revision 1.17  91/11/14  14:10:00  richard
Added System structure containing call_c value to the initial
environment.

Revision 1.16  91/10/22  15:09:47  davidt
Now uses the Crash.impossible function instead of raising an exception.

Revision 1.15  91/10/16  16:13:15  jont
Added _call_c to initial value environment

Revision 1.14  91/09/16  16:55:42  davida
Completed spelling corrections properly.

Revision 1.12  91/08/23  11:39:49  jont
Changed to use pervasives

Revision 1.11  91/08/22  13:52:52  jont
Added associative_primitives and made abs overloaded

Revision 1.10  91/08/09  14:27:05  jont
Added primitive for ~, plus overloaded versions

Revision 1.9  91/08/07  14:25:07  jont
Added int, real and string equality and inequality primitives

Revision 1.8  91/08/02  14:47:34  jont
Added the i/o primitives

Revision 1.7  91/07/24  12:15:10  jont
Added commutative primitives to assist in lambda expression optimisation

Revision 1.6  91/07/22  13:41:04  jont
Added ! to list of imperative primitives

Revision 1.5  91/07/19  16:52:57  jont
First attempt at abstracting out external arguments

Revision 1.4  91/07/15  13:05:27  jont
Placed builtin exceptions in the exception environment

Revision 1.3  91/07/12  16:27:36  jont
Added _make_unique for generating exceptions

Revision 1.2  91/07/11  17:06:34  jont
Added = to list of builtins

Revision 1.1  91/07/10  12:00:11  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/crash";
require "../lambda/environ";
require "pervasives";
require "primitives";

functor Primitives
  (structure Crash : CRASH
   structure Lists : LISTS
   structure Environ : ENVIRON
   structure Pervasives : PERVASIVES

   sharing type Pervasives.pervasive = Environ.EnvironTypes.LambdaTypes.Primitive
     ) : PRIMITIVES =
struct
  structure EnvironTypes = Environ.EnvironTypes
  structure LambdaTypes = EnvironTypes.LambdaTypes
  structure Ident = LambdaTypes.Ident
  structure Set = LambdaTypes.Set
  structure Symbol = Ident.Symbol
  structure NewMap = EnvironTypes.NewMap

  (* This is a (hopefully) complete list of the builtins that can be used in compiling *)
  (* the builtin library -- only inline builtins that do not raise builtin exceptions *)
  (* are allowed *)

  (* This list could be compiled using is_inline and _implicit_references from machperv *)
  (* but I didn't want to make it machine dependent *)

  val values_for_builtin_library =
    [("call_c",Pervasives.CALL_C),
     ("length", Pervasives.LENGTH),
     ("unsafe_sub", Pervasives.UNSAFE_SUB),
     ("unsafe_update", Pervasives.UNSAFE_UPDATE),
     ("real", Pervasives.REAL),
     ("int_equal", Pervasives.INTEQ),
     ("int_greater", Pervasives.INTGREATER),
     ("int_greater_or_equal", Pervasives.INTGREATEREQ),
     ("int_less", Pervasives.INTLESS),
     ("int_less_or_equal", Pervasives.INTLESSEQ),
     ("int_not_equal", Pervasives.INTNE),
     ("char_equal", Pervasives.CHAREQ),
     ("char_greater", Pervasives.CHARGT),
     ("char_greater_or_equal", Pervasives.CHARGE),
     ("char_less", Pervasives.CHARLT),
     ("char_less_or_equal", Pervasives.CHARLE),
     ("char_not_equal", Pervasives.CHARNE),
     ("word_equal", Pervasives.WORDEQ),
     ("word_greater", Pervasives.WORDGT),
     ("word_greater_or_equal", Pervasives.WORDGE),
     ("word_less", Pervasives.WORDLT),
     ("word_less_or_equal", Pervasives.WORDLE),
     ("word_not_equal", Pervasives.WORDNE),
     ("unsafe_int_plus", Pervasives.UNSAFEINTPLUS),
     ("unsafe_int_minus", Pervasives.UNSAFEINTMINUS),
     ("!", Pervasives.DEREF),
     (":=", Pervasives.BECOMES),
     ("size", Pervasives.SIZE),
     ("bytearray_unsafe_sub", Pervasives.BYTEARRAY_UNSAFE_SUB),
     ("bytearray_unsafe_update", Pervasives.BYTEARRAY_UNSAFE_UPDATE),
     ("vector_length", Pervasives.VECTOR_LENGTH),
     ("andb", Pervasives.ANDB),
     ("lshift", Pervasives.LSHIFT),
     ("notb", Pervasives.NOTB),
     ("orb", Pervasives.ORB),
     ("rshift", Pervasives.RSHIFT),
     ("arshift", Pervasives.ARSHIFT),
     ("xorb", Pervasives.XORB),
     ("cast", Pervasives.CAST),
     ("alloc_string", Pervasives.ALLOC_STRING),
     ("alloc_vector", Pervasives.ALLOC_VECTOR),
     ("alloc_pair", Pervasives.ALLOC_PAIR),
     ("record_unsafe_sub", Pervasives.RECORD_UNSAFE_SUB),
     ("record_unsafe_update", Pervasives.RECORD_UNSAFE_UPDATE),
     ("string_unsafe_sub", Pervasives.STRING_UNSAFE_SUB),
     ("string_unsafe_update", Pervasives.STRING_UNSAFE_UPDATE),
     ("get_implicit", Pervasives.GET_IMPLICIT)]
    
  val overload_table_for_lambda =
    [("_real+", Pervasives.REALPLUS),
     ("_int+", Pervasives.INTPLUS),
     ("_int32+", Pervasives.INT32PLUS),
     ("_word+", Pervasives.WORDPLUS),
     ("_word32+", Pervasives.WORD32PLUS),
     ("_real*", Pervasives.REALSTAR),
     ("_int*", Pervasives.INTSTAR),
     ("_int32*", Pervasives.INT32STAR),
     ("_word*", Pervasives.WORDSTAR),
     ("_word32*", Pervasives.WORD32STAR),
     ("_real-", Pervasives.REALMINUS),
     ("_int-", Pervasives.INTMINUS),
     ("_int32-", Pervasives.INT32MINUS),
     ("_word-", Pervasives.WORDMINUS),
     ("_word32-", Pervasives.WORD32MINUS),
     ("_real~", Pervasives.REALUMINUS),
     ("_int~", Pervasives.INTUMINUS),
     ("_int32~", Pervasives.INT32UMINUS),
     ("_int<", Pervasives.INTLESS),
     ("_real<", Pervasives.REALLESS),
     ("_int>", Pervasives.INTGREATER),
     ("_real>", Pervasives.REALGREATER),
     ("_int<=", Pervasives.INTLESSEQ),
     ("_real<=", Pervasives.REALLESSEQ),
     ("_int>=", Pervasives.INTGREATEREQ),
     ("_real>=", Pervasives.REALGREATEREQ),
     ("_int=", Pervasives.INTEQ),
     ("_int<>", Pervasives.INTNE),
     ("_real=", Pervasives.REALEQ),
     ("_real<>", Pervasives.REALNE),
     ("_string=", Pervasives.STRINGEQ),
     ("_string<>", Pervasives.STRINGNE),
     ("_string<", Pervasives.STRINGLT),
     ("_string>", Pervasives.STRINGGT),
     ("_string<=", Pervasives.STRINGLE),
     ("_string>=", Pervasives.STRINGGE),
     ("_char=", Pervasives.CHAREQ),
     ("_char<>", Pervasives.CHARNE),
     ("_char<", Pervasives.CHARLT),
     ("_char>", Pervasives.CHARGT),
     ("_char<=", Pervasives.CHARLE),
     ("_char>=", Pervasives.CHARGE),
     ("_word=", Pervasives.WORDEQ),
     ("_word<>", Pervasives.WORDNE),
     ("_word<", Pervasives.WORDLT),
     ("_word>", Pervasives.WORDGT),
     ("_word<=", Pervasives.WORDLE),
     ("_word>=", Pervasives.WORDGE),
     ("_word32=", Pervasives.WORD32EQ),
     ("_word32<>", Pervasives.WORD32NE),
     ("_word32<", Pervasives.WORD32LT),
     ("_word32>", Pervasives.WORD32GT),
     ("_word32<=", Pervasives.WORD32LE),
     ("_word32>=", Pervasives.WORD32GE),
     ("_int32=", Pervasives.INT32EQ),
     ("_int32<>", Pervasives.INT32NE),
     ("_int32<", Pervasives.INT32LESS),
     ("_int32>", Pervasives.INT32GREATER),
     ("_int32<=", Pervasives.INT32LESSEQ),
     ("_int32>=", Pervasives.INT32GREATEREQ),
     ("_intabs", Pervasives.INTABS),
     ("_int32abs", Pervasives.INT32ABS),
     ("_realabs", Pervasives.REALABS),
     ("_intmod", Pervasives.INTMOD),
     ("_intdiv", Pervasives.INTDIV),
     ("_int32mod", Pervasives.INT32MOD),
     ("_int32div", Pervasives.INT32DIV),
     ("_wordmod", Pervasives.WORDMOD),
     ("_worddiv", Pervasives.WORDDIV),
     ("_word32mod", Pervasives.WORD32MOD),
     ("_word32div", Pervasives.WORD32DIV)
     ]    
    
  fun add_cons(env, names) =
    Lists.reducel
    (fn (env, (name, prim)) =>
     Environ.add_valid_env(env, (Ident.CON(Symbol.find_symbol name),
                                 EnvironTypes.PRIM prim)))
    (env, names)

  fun add_exns(env, names) =
    Lists.reducel
    (fn (env, (name, prim)) =>
     Environ.add_valid_env(env, (Ident.EXCON(Symbol.find_symbol name),
                                 EnvironTypes.PRIM prim)))
    (env, names)

  fun add_strs(env, names) =
    Lists.reducel
    (fn (env, (name, prim, inner_env)) =>
     Environ.add_strid_env(env, (Ident.STRID(Symbol.find_symbol name),
                                 (inner_env, prim, false))))
    (env, names)

  fun add_vals(env, names) =
    Lists.reducel
    (fn (env, (name, prim)) =>
     Environ.add_valid_env(env, (Ident.VAR(Symbol.find_symbol name),
                                 EnvironTypes.PRIM prim)))
    (env, names)

  fun add_overloads env ov_list =
    let
      val _ = Environ.define_overloaded_ops ov_list
    in
      add_vals(env, ov_list)
    end

  val initial_env =
    add_vals
    (add_exns
     (add_cons (Environ.empty_env, map (fn (x,y) => (y,x)) Pervasives.constructor_name_list), 
      map (fn (x,y) => (y,x)) Pervasives.exception_name_list), 
     map (fn (x,y) => (y,x)) Pervasives.value_name_list)

  (* make an env of the valid ids for compiling __builtin_library *)
  val initial_env_for_builtin_library =
    add_vals
     (add_exns
       (add_cons (Environ.empty_env, []), []), values_for_builtin_library)

  val builtin_library_strname =
    Ident.STRID(Symbol.find_symbol "BuiltinLibrary_")

  val env_after_builtin =
    Environ.add_strid_env
      (Environ.empty_env,
       (builtin_library_strname,
        (initial_env, EnvironTypes.FIELD {index=0,size=1}, false)))

  (* This checks that the argument (which should be the environment returned
     from the compilation of the builtin library) matches the internal
     builtins.  *)

  fun check_builtin_env {error_fn, topenv = EnvironTypes.TOP_ENV (env, _)} =
    let
      val EnvironTypes.ENV (top_ve, top_se) = env

      val flag =
        if NewMap.size top_ve <> 0 then
	  (ignore(error_fn "builtin library defines values at top_level");
	   false)
        else
	  true
    in
      case NewMap.tryApply' (top_se, builtin_library_strname)
      of SOME (EnvironTypes.ENV (ve, se), _, _) =>
	if NewMap.size top_se <> 1 orelse NewMap.size se <> 0 then
	  (ignore(error_fn "builtin library defines extra structures");
	   false)
        else
	  let
	    val EnvironTypes.ENV (initial_ve, _) = initial_env

	    fun check_new (flag, valId as Ident.VAR sym, _) =
	      (case NewMap.tryApply' (ve, valId)
	       of SOME _ => flag
	       |  NONE =>
	         (ignore(error_fn
	            ("can't find value " ^ Ident.Symbol.symbol_name sym
		     ^ " in builtin library"));
	          false))
	    |   check_new (flag, valId as Ident.EXCON sym, _) =
	      (case NewMap.tryApply' (ve, valId)
	       of SOME _ => flag
	       |  NONE =>
	         (ignore(error_fn
	            ("can't find exception " ^ Ident.Symbol.symbol_name sym
		     ^ " in builtin library"));
	          false))
	    |  check_new (flag, _, _) = flag    (* ignore constructors *)

	    fun check_internal (flag, valId as Ident.VAR sym, _) =
	      (case NewMap.tryApply' (initial_ve, valId)
	       of SOME _ => flag
	       |  NONE =>
	         (ignore(error_fn
	 	    ("builtin library defines unknown value " ^
		     Ident.Symbol.symbol_name sym
		     ^ " - see main._primitives"));
	          false))
	    |   check_internal (flag, valId as Ident.EXCON sym, _) =
	      (case NewMap.tryApply' (initial_ve, valId)
	       of SOME _ => flag
	       |  NONE =>
	         (ignore(error_fn
	 	    ("builtin library defines unknown exception " ^
		     Ident.Symbol.symbol_name sym
		     ^ " - see main._primitives"));
	          false))
	    |  check_internal (flag, _, _) = flag    (* ignore constructors *)
	     
	    val flag = NewMap.fold check_new (flag, initial_ve)
          in
	    NewMap.fold check_internal (flag, ve)
          end
      |  NONE => 
	(ignore(error_fn
	   "builtin library does not define structure BuiltinLibrary_!");
         false)
    end


  local
    val ml_non_definable_values =
      [("=", Pervasives.EQ)]
    val ml_non_definable_overloads =
      [("~", Pervasives.UMINUS),
       ("abs", Pervasives.ABS),
       ("+", Pervasives.PLUS),
       ("*", Pervasives.STAR),
       ("-", Pervasives.MINUS),
       ("mod", Pervasives.MOD),
       ("div", Pervasives.DIV),
       ("<", Pervasives.LESS),
       (">", Pervasives.GREATER),
       ("<=", Pervasives.LESSEQ),
       (">=", Pervasives.GREATEREQ)]
  in
    val env_for_not_ml_definable_builtins =
      add_cons
      ((add_overloads
        (add_vals
         (add_exns
          (add_cons (Environ.empty_env, []), []), 
           ml_non_definable_values))
(* 
        ["~", "+", "-", "*", "mod", "div", "<", ">", "<=", ">=", "abs"]
*)
        ml_non_definable_overloads), 
      map (fn (x,y) => (y,x)) Pervasives.constructor_name_list)
  end
    
  val env_for_lookup_in_lambda =
    add_vals(Environ.empty_env,overload_table_for_lambda)

end
@


1.47.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.47  1998/02/19  16:45:36  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.46
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d365 1
a365 1
	  (error_fn "builtin library defines values at top_level";
d373 1
a373 1
	  (error_fn "builtin library defines extra structures";
d383 1
a383 1
	         (error_fn
d385 1
a385 1
		     ^ " in builtin library");
d391 1
a391 1
	         (error_fn
d393 1
a393 1
		     ^ " in builtin library");
d401 1
a401 1
	         (error_fn
d404 1
a404 1
		     ^ " - see main._primitives");
d410 1
a410 1
	         (error_fn
d413 1
a413 1
		     ^ " - see main._primitives");
d422 2
a423 2
	(error_fn
	   "builtin library does not define structure BuiltinLibrary_!";
@


1.46.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.46  1997/05/01  13:15:25  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.46.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.46  1997/05/01  13:15:25  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.45
log
@Corrected the last change.
@
text
@d4 3
d367 1
a367 1
      of MLWorks.Option.SOME (EnvironTypes.ENV (ve, se), _, _) =>
d377 2
a378 2
	       of MLWorks.Option.SOME _ => flag
	       |  MLWorks.Option.NONE =>
d385 2
a386 2
	       of MLWorks.Option.SOME _ => flag
	       |  MLWorks.Option.NONE =>
d395 2
a396 2
	       of MLWorks.Option.SOME _ => flag
	       |  MLWorks.Option.NONE =>
d404 2
a405 2
	       of MLWorks.Option.SOME _ => flag
	       |  MLWorks.Option.NONE =>
d417 1
a417 1
      |  MLWorks.Option.NONE => 
@


1.45.8.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.45.8.1  1997/05/12  10:36:24  hope
 * branched from 1.45
 *
@


1.45.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.45.8.1  1997/05/12  10:36:24  hope
 * branched from 1.45
 *
@


1.45.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.45.8.1  1997/05/12  10:36:24  hope
 * branched from 1.45
 *
@


1.45.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.45.8.1.1.1  1997/07/28  18:21:07  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.45.7.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.6.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.6.1.1.1
log
@branched from 1.45.6.1
@
text
@a3 3
 * Revision 1.45.6.1  1996/12/17  17:49:50  hope
 * branched from 1.45
 *
@


1.45.5.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.4.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.4.1.1.1
log
@branched from 1.45.4.1
@
text
@a3 3
 * Revision 1.45.4.1  1996/11/14  12:52:07  hope
 * branched from 1.45
 *
@


1.45.3.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.2.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1995/09/13  18:52:39  daveb
 * Corrected the last change.
 *
@


1.44
log
@Added int32 operations.
@
text
@d4 3
d220 1
a220 1
     ("_int32+", Pervasives.INTPLUS),
d225 1
a225 1
     ("_int32*", Pervasives.INTSTAR),
d230 1
a230 1
     ("_int32-", Pervasives.INTMINUS),
d235 1
a235 1
     ("_int32~", Pervasives.INTUMINUS),
d272 6
a277 6
     ("_int32=", Pervasives.WORD32EQ),
     ("_int32<>", Pervasives.WORD32NE),
     ("_int32<", Pervasives.WORD32LT),
     ("_int32>", Pervasives.WORD32GT),
     ("_int32<=", Pervasives.WORD32LE),
     ("_int32>=", Pervasives.WORD32GE),
d279 1
a279 1
     ("_int32abs", Pervasives.INTABS),
d283 2
a284 2
     ("_int32mod", Pervasives.INTMOD),
     ("_int32div", Pervasives.INTDIV),
@


1.43
log
@Added eq and ne operators for new numeric types to the list
of overloaded operators found here.
@
text
@d4 4
a188 8
     (*
     ("word32_equal", Pervasives.WORD32EQ),
     ("word32_greater", Pervasives.WORD32GT),
     ("word32_greater_or_equal", Pervasives.WORD32GE),
     ("word32_less", Pervasives.WORD32LT),
     ("word32_less_or_equal", Pervasives.WORD32LE),
     ("word32_not_equal", Pervasives.WORD32NE),
     *)
d217 1
d222 1
d227 1
d232 1
d269 6
d276 1
d280 2
@


1.42
log
@Change setup of overloaded names
@
text
@d4 3
d152 1
d185 8
d222 1
d226 1
d230 1
d263 6
d274 3
a276 1
     ("_worddiv", Pervasives.WORDDIV)
d327 14
a340 1
  fun prims_from_names names env = 
d342 8
a349 2
      fun f (EnvironTypes.PRIM x) = x
	| f _ = Crash.impossible "prims_from_names"
d351 55
a405 2
      Set.list_to_set
      (map f (map (fn name => Environ.lookup_valid(name, env)) names))
a407 4
  val env_after_builtin =
    Environ.add_strid_env (Environ.empty_env,
                           (Ident.STRID(Symbol.find_symbol "BuiltinLibrary_"), 
                            (initial_env,EnvironTypes.FIELD {index=0,size=1}, false)))
@


1.41
log
@Add overloading for div and mod on ints and words
@
text
@d4 3
d284 3
a286 2
  fun add_overloads env ov_names ov=
    let val _ = Environ.define_overloaded_ops ov_names
d288 1
a288 1
      add_vals(env, ov)
d340 2
a341 1
           ml_non_definable_values)) 
d343 1
@


1.40
log
@Fix problems with overloaded operator table
@
text
@d4 3
d246 5
a250 1
     ("_realabs", Pervasives.REALABS)
d323 2
d337 1
a337 1
        ["~", "+", "-", "*", "<", ">", "<=", ">=", "abs"]
@


1.39
log
@Add word functions
@
text
@d4 3
d209 1
d236 6
a241 6
     ("_WORD=", Pervasives.WORDEQ),
     ("_WORD<>", Pervasives.WORDNE),
     ("_WORD<", Pervasives.WORDLT),
     ("_WORD>", Pervasives.WORDGT),
     ("_WORD<=", Pervasives.WORDLE),
     ("_WORD>=", Pervasives.WORDGE),
@


1.38
log
@Add overloaded char relations
@
text
@d4 3
d166 6
d200 1
d203 1
d232 6
@


1.37
log
@Extended set of builtins available for compiling the builtin library
@
text
@d4 3
d157 6
d215 6
@


1.36
log
@generate_moduler compiler option in strenvs and funenvs for compatibility purposes.
@
text
@d4 3
d135 7
d143 35
a177 1
    [("call_c",Pervasives.CALL_C)]
d184 26
a209 72
      ("_real-", Pervasives.REALMINUS),
      ("_int-", Pervasives.INTMINUS),
      ("_real~", Pervasives.REALUMINUS),
      ("_int~", Pervasives.INTUMINUS),
      ("_int<", Pervasives.INTLESS),
      ("_real<", Pervasives.REALLESS),
      ("_int>", Pervasives.INTGREATER),
      ("_real>", Pervasives.REALGREATER),
      ("_int<=", Pervasives.INTLESSEQ),
      ("_real<=", Pervasives.REALLESSEQ),
      ("_int>=", Pervasives.INTGREATEREQ),
      ("_real>=", Pervasives.REALGREATEREQ),
      ("_int=", Pervasives.INTEQ),
      ("_int<>", Pervasives.INTNE),
      ("_real=", Pervasives.REALEQ),
      ("_real<>", Pervasives.REALNE),
      ("_string=", Pervasives.STRINGEQ),
      ("_string<>", Pervasives.STRINGNE),
      ("_string<", Pervasives.STRINGLT),
      ("_string>", Pervasives.STRINGGT),
      ("_string<=", Pervasives.STRINGLE),
      ("_string>=", Pervasives.STRINGGE),
      ("_intabs", Pervasives.INTABS),
      ("_realabs", Pervasives.REALABS)
      ]    

  val imperatives =
    ["array",
     "update",
     ":=",
     "!",
     "load_string",
     "call_ml_value",
     "sub",
     "floor",
     "/",
     "div",
     "load_string",
     "chr",
     "exp",
     "int_abs",
     "int_negate",
     "int_multiply",
     "ln",
     "map", (* Shouldn't be here really, but ... *)
     "mod",
     "ord",
     "ordof",
     "real_abs",
     "real_negate",
     "real_multiply",
     "real_minus",
     "real_plus",
     "sin",
     "cos",
     "sqrt",
     "make_ml_value",
     "ml_value_from_offset",
     "make_ml_value_tuple",
     "call_ml_value",
     "ml_require",
     "load_var",
     "load_exn",
     "load_struct",
     "load_funct"
     ]


  val commutatives = ["real_plus", "int_plus", "real_multiply", "int_multiply", "<>"]

  val associatives = ["real_plus", "int_plus", "real_multiply", "int_multiply", "^", "@@"]

d213 2
a214 2
      Environ.add_valid_env(env, (Ident.CON(Symbol.find_symbol name),
	EnvironTypes.PRIM prim)))
d220 2
a221 2
      Environ.add_valid_env(env, (Ident.EXCON(Symbol.find_symbol name),
	EnvironTypes.PRIM prim)))
d228 1
a228 1
			    (inner_env, prim, false))))
d234 2
a235 2
      Environ.add_valid_env(env, (Ident.VAR(Symbol.find_symbol name),
	EnvironTypes.PRIM prim)))
a243 7
  val strs = []

  val initial_env_for_builtin_library =
    add_vals
     (add_exns
       (add_cons(Environ.empty_env, []), []), values_for_builtin_library)

d247 1
a247 1
     (add_cons(Environ.empty_env, map (fn (x,y) => (y,x)) Pervasives.constructor_name_list), 
d251 6
d266 30
a295 39
  val imperative_primitives = 
    (prims_from_names 
     (Ident.CON (Symbol.find_symbol"ref") ::
      (map (Ident.VAR o Symbol.find_symbol) imperatives)) initial_env)
    
  val commutative_primitives =
    (prims_from_names(map (Ident.VAR o Symbol.find_symbol) commutatives) initial_env)

  val associative_primitives =
    (prims_from_names(map (Ident.VAR o Symbol.find_symbol) associatives) initial_env)

    val env_after_builtin =
      Environ.add_strid_env(Environ.empty_env,
                            (Ident.STRID(Symbol.find_symbol "BuiltinLibrary_"), 
                             (initial_env,EnvironTypes.FIELD {index=0,size=1}, false)))

      local
        val ml_non_definable_values =
          [("=", Pervasives.EQ)]
        val ml_non_definable_overloads =
          [("~", Pervasives.UMINUS),
           ("abs", Pervasives.ABS),
           ("+", Pervasives.PLUS),
           ("*", Pervasives.STAR),
           ("-", Pervasives.MINUS),
           ("<", Pervasives.LESS),
           (">", Pervasives.GREATER),
           ("<=", Pervasives.LESSEQ),
           (">=", Pervasives.GREATEREQ)]
      in
        val env_for_not_ml_definable_builtins =
          add_cons
          ((add_overloads
           (add_vals
            (add_exns
             (add_cons(Environ.empty_env, []), []), ml_non_definable_values)) 
           ["~", "+", "-", "*", "<", ">", "<=", ">=", "abs"]
           ml_non_definable_overloads), map (fn (x,y) => (y,x)) Pervasives.constructor_name_list)
      end
d297 2
a298 2
    val env_for_lookup_in_lambda =
      add_vals(Environ.empty_env,overload_table_for_lambda)
@


1.35
log
@Removed exception environments.
@
text
@d4 3
d230 1
a230 1
			    (inner_env, prim))))
d283 1
a283 1
                             (initial_env,EnvironTypes.FIELD {index=0,size=1} )))
@


1.35.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.35  1993/07/07  17:59:29  daveb
Removed exception environments.

@


1.34
log
@Signature revisions
@
text
@d4 3
d219 1
a219 1
      Environ.add_exn_env(env, (Ident.EXCON(Symbol.find_symbol name),
d247 1
a247 1
      (add_exns
d268 1
a268 1
     (Ident.CON(Symbol.find_symbol"ref") ::
@


1.33
log
@Added builtin string relationals
@
text
@d4 3
d122 1
a122 1
  structure Ident = LambdaTypes.Datatypes.Ident
@


1.32
log
@Removed some redundant structures and sharing
@
text
@d4 3
d149 4
@


1.31
log
@Added inline ordof
@
text
@d4 3
a99 1
require "../utils/set";
a100 4
require "../basics/ident";
require "../basics/symbol";
require "../lambda/environtypes";
require "../lambda/lambdatypes";
a107 5
   structure Set : SET
   structure Symbol : SYMBOL
   structure Ident : IDENT
   structure EnvironTypes : ENVIRONTYPES
   structure LambdaTypes : LAMBDATYPES
d111 1
a111 5
   sharing Ident.Symbol = Symbol
   sharing Ident = EnvironTypes.Ident = LambdaTypes.Ident
   sharing Environ.EnvironTypes = EnvironTypes
   sharing EnvironTypes.LambdaTypes = LambdaTypes
   sharing type Pervasives.pervasive = LambdaTypes.Primitive
d114 5
a118 3
  structure EnvironTypes = EnvironTypes
  structure LambdaTypes = LambdaTypes
  structure Set = Set
@


1.30
log
@Added call_ml_value to list of imperative builtins
@
text
@d4 3
d159 41
a199 1
  val imperatives = ["array","update",":=","!","load_string", "call_ml_value"]
@


1.29
log
@changed to use newmap
@
text
@d4 3
d156 1
a156 1
  val imperatives = ["array","update",":=","!","load_string"]
@


1.28
log
@Tried to neaten
@
text
@d4 3
a115 1
   sharing Environ.Set = Set
@


1.27
log
@Added the Bits structure
@
text
@d4 3
a120 24
  val constructors = [("ref", Pervasives.REF)]

  val exceptions =
    [("Size",Pervasives.EXSIZE),
     ("Subscript",Pervasives.EXSUBSCRIPT),
     ("Abs", Pervasives.EXABS),
      ("Ord", Pervasives.EXORD),
      ("Chr", Pervasives.EXCHR),
      ("Div", Pervasives.EXDIV),
      ("Mod", Pervasives.EXMOD),
      ("Quot", Pervasives.EXQUOT),
      ("Prod", Pervasives.EXPROD),
      ("Neg", Pervasives.EXNEG),
      ("Sum", Pervasives.EXSUM),
      ("Diff", Pervasives.EXDIFF),
      ("Floor", Pervasives.EXFLOOR),
      ("Sqrt", Pervasives.EXSQRT),
      ("Exp", Pervasives.EXEXP),
      ("Ln", Pervasives.EXLN),
      ("Io", Pervasives.EXIO),
      ("Match", Pervasives.EXMATCH),
      ("Bind", Pervasives.EXBIND),
      ("Interrupt", Pervasives.EXINTERRUPT)]

d123 1
a123 96

  val values =
    values_for_builtin_library @@
    [
     ("inline_equality", Pervasives.EQ),
     ("external_equality", Pervasives.EQFUN),
     ("<>", Pervasives.NE),
     ("array",Pervasives.ARRAY_FN),
     ("length",Pervasives.LENGTH),
     ("sub",Pervasives.SUB),
     ("update",Pervasives.UPDATE),
     ("Size",Pervasives.EXSIZEVAL),
     ("Subscript",Pervasives.EXSUBSCRIPTVAL),
     ("map", Pervasives.MAP),
     ("rev", Pervasives.REV),
     ("not", Pervasives.NOT),
     ("floor", Pervasives.FLOOR),
     ("real", Pervasives.REAL),
     ("sqrt", Pervasives.SQRT),
     ("sin", Pervasives.SIN),
     ("cos", Pervasives.COS),
     ("arctan", Pervasives.ARCTAN),
     ("exp", Pervasives.EXP),
     ("ln", Pervasives.LN),
     ("size", Pervasives.SIZE),
     ("chr", Pervasives.CHR),
     ("ord", Pervasives.ORD),
     ("explode", Pervasives.EXPLODE),
     ("implode", Pervasives.IMPLODE),
     ("!", Pervasives.DEREF),
     ("/", Pervasives.FDIV),
     ("div", Pervasives.DIV),
     ("mod", Pervasives.MOD),
     ("^", Pervasives.HAT),
     ("@@", Pervasives.AT),
     (":=", Pervasives.BECOMES),
     ("o", Pervasives.O),
     (* Now the internal ones *)
     ("load_string", Pervasives.LOAD_STRING),
      ( "Abs",Pervasives.EXABSVAL),  
       ( "Bind",Pervasives.EXBINDVAL),
       ( "Chr",Pervasives.EXCHRVAL),
       ( "Diff",Pervasives.EXDIFFVAL),
       ( "Div",Pervasives.EXDIVVAL),
       ( "Exp",Pervasives.EXEXPVAL),
       ( "Floor",Pervasives.EXFLOORVAL),
       ( "Interrupt",Pervasives.EXINTERRUPTVAL),
       ( "Io",Pervasives.EXIOVAL),
       ( "Ln",Pervasives.EXLNVAL),
       ( "Match",Pervasives.EXMATCHVAL),
       ( "Mod",Pervasives.EXMODVAL),
       ( "Neg",Pervasives.EXNEGVAL),
       ( "Ord",Pervasives.EXORDVAL),
       ( "Prod",Pervasives.EXPRODVAL),
       ( "Quot",Pervasives.EXQUOTVAL),
       ( "Sqrt",Pervasives.EXSQRTVAL),
       ( "Sum",Pervasives.EXSUMVAL),
       ("andb",Pervasives.ANDB),
       ("lshift",Pervasives.LSHIFT),
       ("notb",Pervasives.NOTB),
       ("orb",Pervasives.ORB),
       ("rshift",Pervasives.RSHIFT),
       ("xorb",Pervasives.XORB)
]
    @@ (* These were down as overloads, but they aren't *)
    [("real_plus", Pervasives.REALPLUS),
      ("int_plus", Pervasives.INTPLUS),
      ("real_multiply", Pervasives.REALSTAR),
      ("int_multiply", Pervasives.INTSTAR),
      ("real_minus", Pervasives.REALMINUS),
      ("int_minus", Pervasives.INTMINUS),
      ("real_negate", Pervasives.REALUMINUS),
      ("int_negate", Pervasives.INTUMINUS),
      ("int_less", Pervasives.INTLESS),
      ("real_less", Pervasives.REALLESS),
      ("int_greater", Pervasives.INTGREATER),
      ("real_greater", Pervasives.REALGREATER),
      ("int_less_or_equal", Pervasives.INTLESSEQ),
      ("real_less_or_equal", Pervasives.REALLESSEQ),
      ("int_greater_or_equal", Pervasives.INTGREATEREQ),
      ("real_greater_or_equal", Pervasives.REALGREATEREQ),
      ("int_equal", Pervasives.INTEQ),
      ("int_not_equal", Pervasives.INTNE),
      ("real_equal", Pervasives.REALEQ),
      ("real_not_equal", Pervasives.REALNE),
      ("string_equal", Pervasives.STRINGEQ),
      ("string_not_equal", Pervasives.STRINGNE),
      ("int_abs", Pervasives.INTABS),
      ("real_abs", Pervasives.REALABS)
      ]

  val overloads_for_builtin_library = []

  val overloads = []


d126 3
a128 3
      ("_int+", Pervasives.INTPLUS),
      ("_real*", Pervasives.REALSTAR),
      ("_int*", Pervasives.INTSTAR),
a150 31
    (* Do some consistency checks *)
  local
    fun reverse [] = []
      | reverse ((x,y)::t) = (y,x)::reverse t
    val a = reverse(values @@ overloads)
    val b = reverse exceptions
    val c = reverse constructors
    fun bad_difference (a,b) = 
      Lists.difference(a,b)<>[] orelse Lists.difference(b,a) <> []
  in
    val _ = 
      if bad_difference(a,Pervasives.value_name_list)
        then Crash.impossible "Problem with value_name_list in _primitives"
      else ()

    val _ = 
      if bad_difference(b,Pervasives.exception_name_list)
        then Crash.impossible "Problem with exception_name_list in _primitives"
      else ()

    val _ = 
      if bad_difference(c,Pervasives.constructor_name_list)
        then Crash.impossible "Problem with constructor_name_list in _primitives"
      else ()
  end


  val overload_names_for_builtin_library =[]
  val overload_names = overload_names_for_builtin_library 


d194 1
a194 2
    add_overloads
     (add_vals
d196 1
a196 3
       (add_cons(Environ.empty_env, []), []), values_for_builtin_library)) 
     overload_names_for_builtin_library
     overloads_for_builtin_library
d199 5
a203 6
    add_overloads
     (add_vals
      (add_exns
       (add_cons(Environ.empty_env, constructors), exceptions), values)) 
     overload_names
     overloads
d251 1
a251 1
           ml_non_definable_overloads), constructors)
@


1.26
log
@Added require for crash
@
text
@d4 3
d200 8
a207 1
       ( "Sum",Pervasives.EXSUMVAL)]
@


1.25
log
@Added EQFUN to initial valenv.
@
text
@d4 3
d83 1
@


1.24
log
@Changed pervasive EQ to EQFUN.  EQ is the inline version.  See Mir_Cg.
@
text
@d4 3
d141 2
a142 1
     ("equality", Pervasives.EQFUN),
@


1.23
log
@New pervasive library
@
text
@d4 3
d138 1
a138 1
     ("equality",Pervasives.EQ),
@


1.22
log
@Array-problems - the structure was missing
@
text
@d4 3
d108 3
a110 1
    [("Abs", Pervasives.EXABS),
d129 3
d133 11
a143 1
    [("map", Pervasives.MAP),
a145 1
     ("abs", Pervasives.ABS),
a162 3
     ("+", Pervasives.PLUS),
     ("*", Pervasives.STAR),
     ("-", Pervasives.MINUS),
a164 5
     ("<>", Pervasives.NE),
     ("<", Pervasives.LESS),
     (">", Pervasives.GREATER),
     ("<=", Pervasives.LESSEQ),
     (">=", Pervasives.GREATEREQ),
a166 14
     ("~", Pervasives.UMINUS),
     ("=", Pervasives.EQ),
     (* Now the i/o *)
     ("std_in", Pervasives.STD_IN),
     ("std_out", Pervasives.STD_OUT),
     ("open_in", Pervasives.OPEN_IN),
     ("open_out", Pervasives.OPEN_OUT),
     ("input", Pervasives.INPUT),
     ("lookahead", Pervasives.LOOKAHEAD),
     ("close_in", Pervasives.CLOSE_IN),
     ("end_of_stream", Pervasives.END_OF_STREAM),
     ("output", Pervasives.OUTPUT),
     ("close_out", Pervasives.CLOSE_OUT),
     ("substring", Pervasives.SUBSTRING), (* temporary *)
d168 45
a212 1
     ("_load_string", Pervasives.LOAD_STRING)]
d214 6
a219 1
  val overloads =
d244 1
a244 1
      ]
d246 14
a259 1
  val overload_names = ["~", "+", "-", "*", "<", ">", "<=", ">=", "abs"]
d261 4
a264 1
  val inline_primitives = ["o", "not"]
d266 5
a270 16
  val imperatives =
    [Ident.CON(Symbol.find_symbol"ref"),
     Ident.VAR(Symbol.find_symbol":="),
     Ident.VAR(Symbol.find_symbol"!"),
     Ident.VAR(Symbol.find_symbol"std_in"),
     Ident.VAR(Symbol.find_symbol"std_out"),
     Ident.VAR(Symbol.find_symbol"open_in"),
     Ident.VAR(Symbol.find_symbol"open_out"),
     Ident.VAR(Symbol.find_symbol"input"),
     Ident.VAR(Symbol.find_symbol"lookahead"),
     Ident.VAR(Symbol.find_symbol"close_in"),
     Ident.VAR(Symbol.find_symbol"end_of_stream"),
     Ident.VAR(Symbol.find_symbol"output"),
     Ident.VAR(Symbol.find_symbol"close_out"),
     Ident.VAR(Symbol.find_symbol"_load_string")
     ]
a271 5
val array_imperatives =
  [Ident.VAR(Symbol.find_symbol"array"),
   Ident.VAR(Symbol.find_symbol"update"),
   Ident.VAR(Symbol.find_symbol"arrayoflist"),
   Ident.VAR(Symbol.find_symbol"tabulate")]
d273 2
a274 1
  val commutatives = ["_real+", "_int+", "_real*", "_int*", "=", "<>"]
a275 1
  val associatives = ["_real+", "_int+", "_real*", "_int*", "^", "@@"]
d277 6
d311 2
a312 2
  fun add_overloads env =
    let val _ = Environ.define_overloaded_ops overload_names
d314 1
a314 1
      add_vals(env, overloads)
d317 1
a317 1
  (* System is set up here *)
d319 7
a325 2
  val system_structure_env =
    add_vals (Environ.empty_env, [("call_c", Pervasives.CALL_C)])
a326 25
  (* Array environment is set up here *)
    local
      val vals = [("array",Pervasives.ARRAY_FN),
		  ("arrayoflist",Pervasives.ARRAY_OF_LIST),
		  ("length",Pervasives.LENGTH),
		  ("sub",Pervasives.SUB),
		  ("tabulate",Pervasives.TABULATE),
		  ("update",Pervasives.UPDATE),
                  ("Size",Pervasives.EXSIZEVAL),
                  ("Subscript",Pervasives.EXSUBSCRIPTVAL)]
      val exns = [("Size",Pervasives.EXSIZE),
		  ("Subscript",Pervasives.EXSUBSCRIPT)]
    in
      val array_structure_environment =
	add_exns(add_vals (Environ.empty_env,vals),exns)
    end


  val strs = [("Array",
	       EnvironTypes.PRIM Pervasives.ARRAY,
	       array_structure_environment),
	      ("System",
	       EnvironTypes.PRIM Pervasives.SYSTEM,
	       system_structure_env)]

d328 1
a328 2
    add_strs
    (add_overloads
d331 3
a333 2
       (add_cons(Environ.empty_env, constructors), exceptions), values)),
     strs)
a343 5
  val array_imperatives = 
    [Ident.VAR(Symbol.find_symbol "array"),
     Ident.VAR(Symbol.find_symbol "update"),
     Ident.VAR(Symbol.find_symbol "sub")]

d345 4
a348 5
    Set.union
    (prims_from_names imperatives initial_env,
     prims_from_names array_imperatives
     (#1 (Environ.lookup_strid (Ident.STRID (Symbol.find_symbol "Array"), initial_env))))

d350 1
a350 1
    prims_from_names(map (Ident.VAR o Symbol.find_symbol) commutatives) initial_env
d353 34
a386 1
    prims_from_names(map (Ident.VAR o Symbol.find_symbol) associatives) initial_env
@


1.21
log
@Added arrays to the initial basis - needed to mark them as imperative
@
text
@d4 3
d279 3
a281 1
		  ("update",Pervasives.UPDATE)]
@


1.20
log
@Added a SUBSTRING pervasive as a temporary measure so that the same code
can be compiled under under both New Jersey and MLWorks.
@
text
@d4 4
d119 1
a119 2
      ("Interrupt", Pervasives.EXINTERRUPT)
      ]
d170 1
a170 2
     ("_load_string", Pervasives.LOAD_STRING)
     ]
d220 6
d264 2
d269 20
a288 1
  val strs = [("System",
d300 1
a300 1
  fun prims_from_names names = 
d306 1
a306 1
      (map f (map (fn name => Environ.lookup_valid(name, initial_env)) names))
d309 4
a312 1
  val imperative_primitives = prims_from_names imperatives
d314 6
d321 1
a321 1
    prims_from_names(map (Ident.VAR o Symbol.find_symbol) commutatives)
d324 1
a324 1
    prims_from_names(map (Ident.VAR o Symbol.find_symbol) associatives)
@


1.19
log
@Updated to use Lists.foldl and new stuff from environ
@
text
@d4 3
d165 1
d167 1
a167 2
     ("_load_string", Pervasives.LOAD_STRING),
     ("_call_c", Pervasives.CALL_C)
@


1.18
log
@Removed MAKE_NEW_UNIQUE from the list of primitives.
@
text
@d3 4
a6 1
$Log:	_primitives.sml,v $
a218 2
  fun foldleft f (e, xs) = Lists.foldl (fn x => (fn y => f(x, y))) e xs

d220 4
a223 4
    foldleft
    (fn ((name, prim), env) =>
      Environ.add_valid_env((Ident.CON(Symbol.find_symbol name),
	EnvironTypes.PRIM prim), env))
d227 4
a230 4
    foldleft
    (fn ((name, prim), env) =>
      Environ.add_exn_env((Ident.EXCON(Symbol.find_symbol name),
	EnvironTypes.PRIM prim), env))
d234 4
a237 5
    foldleft
    (fn ((name, prim, inner_env), env) =>
     Environ.add_strid_env((Ident.STRID(Symbol.find_symbol name),
			    (inner_env, prim)),
			   env))
d241 4
a244 4
    foldleft
    (fn ((name, prim), env) =>
      Environ.add_valid_env((Ident.VAR(Symbol.find_symbol name),
	EnvironTypes.PRIM prim), env))
@


1.17
log
@Added System structure containing call_c value to the initial
environment.
@
text
@d4 4
a159 1
     ("_make_new_unique", Pervasives.MAKE_NEW_UNIQUE),
a208 1
     Ident.VAR(Symbol.find_symbol"_make_new_unique"),
@


1.16
log
@Now uses the Crash.impossible function instead of raising an exception.
@
text
@d4 3
d230 8
d251 2
a252 5
  fun initialVarEnv() =
    add_overloads
      (add_vals
        (add_exns
	  (add_cons(Environ.empty_env, constructors), exceptions), values))
d254 11
a264 1
  val initial_env = initialVarEnv()
@


1.15
log
@Added _call_c to initial value environment
@
text
@d4 3
d59 10
a68 9
functor Primitives(
  structure Lists : LISTS
  structure Set : SET
  structure Symbol : SYMBOL
  structure Ident : IDENT
  structure EnvironTypes : ENVIRONTYPES
  structure LambdaTypes : LAMBDATYPES
  structure Environ : ENVIRON
  structure Pervasives : PERVASIVES
d70 7
a76 7
  sharing Ident.Symbol = Symbol
  sharing Ident = EnvironTypes.Ident = LambdaTypes.Ident
  sharing Environ.EnvironTypes = EnvironTypes
  sharing EnvironTypes.LambdaTypes = LambdaTypes
  sharing Environ.Set = Set
  sharing type Pervasives.pervasive = LambdaTypes.Primitive
) : PRIMITIVES =
d249 7
a255 4
    Set.list_to_set(map
      (fn (EnvironTypes.PRIM x) => x
      | _ => raise(LambdaTypes.impossible"prims_from_names"))
      (map (fn name => Environ.lookup_valid(name, initial_env)) names))
@


1.14
log
@Completed spelling corrections properly.
@
text
@d4 3
d150 2
a151 1
     ("_load_string", Pervasives.LOAD_STRING)
@


1.13
log
@ >Corrected spelling of UNIQUE (!)
@
text
@d146 1
a146 1
     ("_make_new_unqiue", Pervasives.MAKE_NEW_UNIQUE),
@


1.12
log
@Changed to use pervasives
@
text
@d4 3
d146 1
a146 1
     ("_make_new_unqiue", Pervasives.MAKE_NEW_UNQIUE),
d195 1
a195 1
     Ident.VAR(Symbol.find_symbol"_make_new_unqiue"),
@


1.11
log
@Added associative_primitives and made abs overloaded
@
text
@d4 3
d47 1
d58 1
d65 1
d72 1
a72 1
  val constructors = ["ref"]
d74 20
a93 3
  val exceptions = ["Abs", "Ord", "Chr", "Div", "Mod", "Quot", "Prod",
    "Neg", "Sum", "Diff", "Floor", "Sqrt", "Exp", "Ln", "Io",
    "Match", "Bind", "Interrupt"]
d95 51
a145 4
  val values = ["map", "rev", "not", "abs",
    "floor", "real", "sqrt", "sin", "cos",
    "arctan", "exp", "ln", "size", "chr",
    "ord", "explode", "implode", "!",
a146 11
    "/", "div", "mod", "+", "*", "-",
    "^", "@@", "<>", "<", ">",
    "<=", ">=", ":=", "o",
    "~",
    "=",
    (* Now the i/o *)
    "std_in", "std_out", "open_in", "open_out", "input", "lookahead",
    "close_in", "end_of_stream", "output", "close_out",
    (* Now the internal ones *)
    "_make_new_unqiue", "_load_string"]

d148 25
a172 13
    ["_real+", "_int+",
    "_real*", "_int*",
    "_real-", "_int-",
    "_real~", "_int~",
    "_int<", "_real<",
    "_int>", "_real>",
    "_int<=", "_real<=",
    "_int>=", "_real>=",
    "_int=", "_int<>",
    "_real=", "_real<>",
    "_string=", "_string<>",
    "_intabs", "_realabs"
    ]
d204 1
a204 1
    (fn (name, env) =>
d206 1
a206 1
	EnvironTypes.PRIM(LambdaTypes.new_Prim())), env))
d211 1
a211 1
    (fn (name, env) =>
d213 1
a213 1
	EnvironTypes.PRIM(LambdaTypes.new_Prim())), env))
d218 1
a218 1
    (fn (name, env) =>
d220 1
a220 1
	EnvironTypes.PRIM(LambdaTypes.new_Prim())), env))
@


1.10
log
@Added primitive for ~, plus overloaded versions
@
text
@d4 3
d99 3
a101 1
    "_string=", "_string<>"]
d103 1
a103 1
  val overload_names = ["~", "+", "-", "*", "<", ">", "<=", ">="]
d127 2
d176 3
@


1.9
log
@Added int, real and string equality and inequality primitives
@
text
@d4 3
d77 1
d86 2
a87 1
    ["_real+", "_int+", "_real*", "_int*",
d89 1
d98 3
a100 1
  val overload_names = ["+", "-", "*", "<", ">", "<=", ">="]
@


1.8
log
@Added the i/o primitives
@
text
@d4 3
d87 4
a90 1
    "_int>=", "_real>="]
@


1.7
log
@Added commutative primitives to assist in lambda expression optimisation
@
text
@d4 3
d72 3
d92 10
@


1.6
log
@Added ! to list of imperative primitives
@
text
@d4 3
a21 1

d90 2
d129 10
a138 3
  val imperative_primitives =
    Set.list_to_set(map (fn (EnvironTypes.PRIM x) => x)
      (map (fn name => Environ.lookup_valid(name, initial_env)) imperatives))
@


1.5
log
@First attempt at abstracting out external arguments
@
text
@d4 3
d83 1
@


1.4
log
@Placed builtin exceptions in the exception environment
@
text
@d4 3
d63 3
a65 1
    "=", "_make_new_unqiue"]
d80 3
a82 1
     Ident.VAR(Symbol.find_symbol"_make_new_unqiue")]
@


1.3
log
@Added _make_unique for generating exceptions
@
text
@d4 3
d89 1
a89 1
      Environ.add_valid_env((Ident.EXCON(Symbol.find_symbol name),
@


1.2
log
@Added = to list of builtins
@
text
@d4 3
d57 1
a57 1
    "="]
d70 3
a72 1
    [Ident.CON(Symbol.find_symbol"ref"), Ident.VAR(Symbol.find_symbol":=")]
@


1.1
log
@Initial revision
@
text
@d3 3
a5 1
$Log$
d7 1
d53 2
a54 1
    "<=", ">=", ":=", "o"]
@
