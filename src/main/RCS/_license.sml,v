head	1.18;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.1
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.16
	MLWorks_20b2_Windows_1998_06_12:1.16
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.13
	MLWorks_20m1_1997_10_23:1.12
	MLWorks_11r1:1.5.1.1.1.8.1
	MLWorks_workspace_97:1.12.2
	MLWorks_dt_wizard:1.12.1
	MLWorks_11c0_1997_09_09:1.5.1.1.1.8
	MLWorks_10r3:1.5.1.1.3
	MLWorks_10r2_551:1.5.1.1.2
	MLWorks_11:1.5.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.1.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.1
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.2.1.1
	MLWorks_gui_1996_12_18:1.4.3
	MLWorks_1_0_Win32_1996_12_17:1.4.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.1.1.1.2
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.1.2
	MLWorks_1_0_Irix_1996_11_28:1.3.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.1
	MLWorks_1_0_Unix_1996_11_14:1.3.1;
locks; strict;
comment	@ *  @;


1.18
date	99.05.13.09.49.16;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	98.07.14.09.27.54;	author jkbrook;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	98.06.02.13.16.22;	author jkbrook;	state Exp;
branches;
next	1.15;

1.15
date	98.03.17.15.43.21;	author jkbrook;	state Exp;
branches;
next	1.14;

1.14
date	98.03.12.13.56.01;	author jkbrook;	state Exp;
branches;
next	1.13;

1.13
date	98.02.05.16.49.59;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	97.08.05.18.50.00;	author jkbrook;	state Exp;
branches
	1.12.1.1
	1.12.2.1;
next	1.11;

1.11
date	97.08.01.16.47.03;	author jkbrook;	state Exp;
branches;
next	1.10;

1.10
date	97.08.01.14.24.47;	author jkbrook;	state Exp;
branches;
next	1.9;

1.9
date	97.07.25.15.17.44;	author johnh;	state Exp;
branches;
next	1.8;

1.8
date	97.07.24.16.43.24;	author jkbrook;	state Exp;
branches;
next	1.7;

1.7
date	97.07.22.16.21.38;	author jkbrook;	state Exp;
branches;
next	1.6;

1.6
date	97.07.18.13.27.43;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	97.01.07.14.00.09;	author jont;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	96.11.15.16.25.45;	author daveb;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1;
next	1.3;

1.3
date	96.11.13.13.59.03;	author daveb;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	96.11.12.16.11.17;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	96.11.11.20.09.40;	author daveb;	state Exp;
branches;
next	;

1.3.1.1
date	96.11.14.12.51.19;	author hope;	state Exp;
branches
	1.3.1.1.1.1;
next	1.3.1.2;

1.3.1.2
date	96.12.05.18.00.58;	author daveb;	state Exp;
branches;
next	;

1.3.1.1.1.1
date	96.11.28.15.02.23;	author hope;	state Exp;
branches;
next	1.3.1.1.1.2;

1.3.1.1.1.2
date	96.12.05.18.03.15;	author daveb;	state Exp;
branches;
next	;

1.4.1.1
date	96.11.22.18.10.32;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.12.17.17.49.09;	author hope;	state Exp;
branches
	1.4.2.1.1.1;
next	;

1.4.2.1.1.1
date	97.02.24.11.39.13;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.12.18.09.43.13;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	97.05.12.10.35.42;	author hope;	state Exp;
branches
	1.5.1.1.1.1
	1.5.1.1.2.1
	1.5.1.1.3.1;
next	;

1.5.1.1.1.1
date	97.07.28.18.21.25;	author daveb;	state Exp;
branches;
next	1.5.1.1.1.2;

1.5.1.1.1.2
date	97.08.05.09.26.22;	author johnh;	state Exp;
branches;
next	1.5.1.1.1.3;

1.5.1.1.1.3
date	97.08.08.18.52.40;	author jkbrook;	state Exp;
branches;
next	1.5.1.1.1.4;

1.5.1.1.1.4
date	97.08.11.09.16.12;	author jkbrook;	state Exp;
branches;
next	1.5.1.1.1.5;

1.5.1.1.1.5
date	97.08.11.15.02.27;	author jkbrook;	state Exp;
branches;
next	1.5.1.1.1.6;

1.5.1.1.1.6
date	97.08.11.15.29.21;	author jkbrook;	state Exp;
branches;
next	1.5.1.1.1.7;

1.5.1.1.1.7
date	97.08.11.16.41.31;	author jkbrook;	state Exp;
branches;
next	1.5.1.1.1.8;

1.5.1.1.1.8
date	97.08.11.17.35.14;	author jkbrook;	state Exp;
branches
	1.5.1.1.1.8.1.1;
next	;

1.5.1.1.1.8.1.1
date	97.10.07.11.46.57;	author jkbrook;	state Exp;
branches;
next	;

1.5.1.1.2.1
date	97.09.08.17.14.48;	author daveb;	state Exp;
branches;
next	;

1.5.1.1.3.1
date	97.09.09.14.10.41;	author daveb;	state Exp;
branches;
next	;

1.12.1.1
date	97.09.10.19.26.42;	author brucem;	state Exp;
branches;
next	;

1.12.2.1
date	97.09.11.20.56.40;	author daveb;	state Exp;
branches;
next	;

1.17.1.1
date	99.04.01.17.58.06;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Interface to the licensing code in the runtime.
@


1.18
log
@[Bug #190553]
Replaced use of basis/exit with utils/mlworks_exit.
@
text
@(* License server implementation.
 *
 * Copyright (c) Harlequin Ltd. 1996.
 *
 * $Log: _license.sml,v $
 *  Revision 1.17  1998/07/14  09:27:54  jkbrook
 *  [Bug #30435]
 *  Remove user-prompting code
 *
 *  Revision 1.16  1998/06/02  13:16:22  jkbrook
 *  [Bug #30411]
 *  Handle free copies of MLWorks
 *
 *  Revision 1.15  1998/03/17  15:43:21  jkbrook
 *  [Bug #50044]
 *  Fix problem with mixed-case licence names
 *
 *  Revision 1.14  1998/03/12  13:56:01  jkbrook
 *  [Bug #50044]
 *  Licence codes should not contain 0 or 1
 *  or lower case letters on input
 *
 *  Revision 1.13  1998/02/05  16:49:59  jont
 *  [Bug #30090]
 *  Replace uses of MLWorks.IO with print and TextIO
 *
 *  Revision 1.12  1997/08/05  18:50:00  jkbrook
 *  [Bug #30223]
 *  Shortening license codes by using base 36 for date elements and
 *  reducing CHECK_CHARS from 10 to 8
 *
 *  Revision 1.11  1997/08/01  16:47:03  jkbrook
 *  [Bug #20072]
 *  Adding edition info (e.g., student, personal) to licensing
 *
 *  Revision 1.10  1997/08/01  14:24:47  jkbrook
 *  [Bug #20073]
 *  Added datatype license_check_result for more flexible reporting
 *  of license-checking/validation results.
 *
 *  Revision 1.9  1997/07/25  15:17:44  johnh
 *  [Bug #30212]
 *  Allow user to type in license when one expires.
 *
 *  Revision 1.8  1997/07/24  16:43:24  jkbrook
 *  [Bug #20077]
 *  Adding an install-by date
 *
 *  Revision 1.7  1997/07/22  16:21:38  jkbrook
 *  [Bug #20077]
 *  License expiry should be to the nearest day
 *
 *  Revision 1.6  1997/07/18  13:27:43  johnh
 *  [Bug #20074]
 *  Improve license dialog - allow user to retry.
 *
 *  Revision 1.5  1997/01/07  14:00:09  jont
 *  [Bug #1884]
 *  Distinguish invalid licenses from expired licenses
 *
 *  Revision 1.4  1996/11/15  16:25:45  daveb
 *  Ensured that the code from promptUser is > 3 chars long before calling
 *  substring.
 *  Also mapped name to lower case before encoding, and stripped leading and
 *  trailing whitespace.
 *
 *  Revision 1.3  1996/11/13  13:59:03  daveb
 *  Made ttyComplain append a newline to the error message, as the literal
 *  no longer ends with a newline <URI://MLWrts/src/OS/Unix/license.c>.
 *
 *  Revision 1.2  1996/11/12  16:11:17  daveb
 *  Added date to the license to be stored.
 *
 *  Revision 1.1  1996/11/11  20:09:40  daveb
 *  new unit
 *  Interface to the licensing code in the runtime.
 *
 *
 *)

require "__os";
require "^.basis.__substring";
require "^.basis.__char";
require "^.basis.__text_io";
require "version";

require "license";

functor License (
  structure Version: VERSION
): LICENSE =
struct
  fun env s = MLWorks.Internal.Value.cast
	        (MLWorks.Internal.Runtime.environment s)

  (* this datatype must be kept consistent with that in rts/src/license.h *)

  datatype license_check_result = EXPIRED
                                | ILLEGAL_CHARS
	                        | INSTALLDATE   
			        | INTERNAL_ERROR
                                | INVALID       
			        | NOT_FOUND
                                | OK            
                                | WRONG_EDITION            


  val license_check = env "license check": unit -> license_check_result
  val license_error_invalid = env "license error invalid": unit -> string
  val license_error_expired = env "license error expired": unit -> string
  val license_error_installdate = env "license error install date": unit -> string
  val license_error_version = env "license error wrong version": unit -> string
  val license_error_chars = env "license error illegal chars": unit -> string

  fun ttyComplain st =
    (print st;
     print "You need to reinstall your license information.\n";
     print "\nContinue anyway with a restricted session (y/n)? ";
     let 
      fun massageString s =
        let
          val ss = Substring.all s
          val dl = Substring.dropl Char.isSpace ss 
          val dr = Substring.dropr Char.isSpace dl
        in
          Substring.translate str dr
        end

       val reply_line = massageString (TextIO.inputLine TextIO.stdIn)
       val reply_char = 
       if size reply_line > 0 then
         substring (reply_line, 0, 1)
       else "n"
       fun default_to_free () = env "license set edition"
     in
       if reply_char = "y" then 
       (ignore(default_to_free ());
       SOME false)
       else
         (ignore(OS.Process.terminate OS.Process.failure);
	  NONE)
     end)

  (* license_complain returns SOME _ whenever we want to startup a session.
     SOME true  == license is valid -- get edition from license
     SOME false == license is missing (default straight to free version), 
                   or license is corrupt but the user has chosen to start 
                   a free session
     NONE       == license is corrupt and user has chosen to exit
  *)

  fun license complain = 
      (* 
       * OK              == stored license is valid and has not expired
       * EXPIRED         == stored license has expired
       * ILLEGAL_CHARS   == input contains zero or one 
       * INVALID         == stored license is invalid
       * NOT_FOUND       == start session as Free version
       * INTERNAL_ERROR  == internal errors (e.g., malloc failures)
       * WRONG_EDITION   == license is for a different edition  
       *)

      case license_check() of
        OK             => (SOME true)
      | NOT_FOUND      => (SOME true)
      | EXPIRED        => complain(license_error_expired())
      | INVALID        => complain(license_error_invalid())
      | INTERNAL_ERROR => complain(license_error_invalid())
      | INSTALLDATE    => complain(license_error_invalid()) 
      | WRONG_EDITION  => complain(license_error_version())
      | ILLEGAL_CHARS  => complain(license_error_chars())
      
end
@


1.17
log
@[Bug #30435]
Remove user-prompting code
@
text
@d6 4
d81 1
a81 1
require "^.basis.exit";
a89 1
  structure Exit: EXIT
d140 1
a140 1
         (ignore(Exit.terminate Exit.failure);
@


1.17.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 *  Revision 1.17  1998/07/14  09:27:54  jkbrook
 *  [Bug #30435]
 *  Remove user-prompting code
 *
@


1.16
log
@[Bug #30411]
Handle free copies of MLWorks
@
text
@d6 4
d104 1
a104 1
  val license_validate = env "license validate": string * string -> license_check_result
a105 1
  val license_store = env "license store": string -> bool
d112 4
a115 33
  fun ttyPromptUser () =
    let
      val _ = 
        print"You must register your copy of MLWorks.\n"

      fun strip_newline s =
	if size s < 2 then s else substring (s, 0, size s - 1)

      val name =
        (print"Input your license name:";
         strip_newline (TextIO.inputLine TextIO.stdIn))

      val checkCode =
        (print"Input your license code:";
         strip_newline (TextIO.inputLine TextIO.stdIn))
    in
      (name, checkCode)
    end

  (* massageString converts all letters to lower case, and strips leading
     and trailing spaces.  This makes the data entry much more pleasant. *)
  fun massageString s =
    let
      val ss = Substring.all s
      val dl = Substring.dropl Char.isSpace ss 
      val dr = Substring.dropr Char.isSpace dl
    in
      Substring.translate str dr
    end

  fun ttyComplain str =
    (print str;
     print"\n\nType in new license (y/n)?  ";
d117 9
d128 4
a131 3
	 if size reply_line > 0 then
	   substring (reply_line, 0, 1)
	 else "n"
d134 2
a135 1
	 true 
d137 2
a138 1
         Exit.terminate Exit.failure
d141 7
a147 43
  fun license{promptUser, complain} = 
    let 
      fun complain_retry complain_str = 
	if complain complain_str then 
	  user_input_license()
	else
	  false
      and user_input_license () = 
	let
	  val (name, code) = promptUser ()
          val name = let
                        val ss = Substring.all (massageString name)
                     in
                        Substring.translate (str o Char.toLower) ss
                     end
	  val code = massageString code
	in
	  if size code > 3 then 
             (case (license_validate(name, code)) of
                ILLEGAL_CHARS => complain_retry(license_error_chars())
              |	INVALID => complain_retry(license_error_invalid())
	      | INSTALLDATE => complain_retry(license_error_installdate())
	      | EXPIRED => complain_retry(license_error_expired())
              | WRONG_EDITION => complain_retry(license_error_version())
              | OK => 
	    let
              (* date chars are in dmy format (base 36), hence 3 chars *)
              val exp_date_chars = substring(code, size code - 3, 3)
              (* edition number is before the two dates *)
              val edition_chars = substring(code, size code - 7, 1)
	    in
	      if license_store(exp_date_chars ^ edition_chars ^ name) then
		true
	      else
		complain_retry ("MLWorks was unable to store the encoded license." ^ 
			license_error_invalid())
	    end
             | _ => complain_retry(license_error_invalid())
             )
	  else
	    complain_retry(license_error_invalid())
	end
    in
d149 1
d161 9
a169 9
        OK => true	
      | NOT_FOUND => true
      | EXPIRED => complain_retry(license_error_expired())
      | INVALID => complain_retry(license_error_invalid())
      | INTERNAL_ERROR => complain_retry(license_error_invalid()) 
      | INSTALLDATE => complain_retry(license_error_invalid()) (* possible? *)
      | WRONG_EDITION => complain_retry(license_error_version())
      | ILLEGAL_CHARS => complain_retry(license_error_chars())
    end
@


1.15
log
@[Bug #50044]
Fix problem with mixed-case licence names
@
text
@d6 4
d77 1
d83 1
d89 1
a89 1
  (* this datatype must be kept consistent with that in sha/register.h *)
d204 1
a204 1
       * NOT_FOUND       == need to ask user to type in the license
d211 1
a215 1
      | NOT_FOUND => user_input_license()
@


1.14
log
@[Bug #50044]
Licence codes should not contain 0 or 1
or lower case letters on input
@
text
@d6 5
d159 5
a163 1
	  val name = massageString name
@


1.13
log
@[Bug #30090]
Replace uses of MLWorks.IO with print and TextIO
@
text
@d6 4
d81 1
d96 1
d125 1
a125 1
      Substring.translate (str o Char.toLower) dr
d159 2
a160 1
		INVALID => complain_retry(license_error_invalid())
d187 1
d202 1
@


1.12
log
@[Bug #30223]
Shortening license codes by using base 36 for date elements and
reducing CHECK_CHARS from 10 to 8
@
text
@d6 5
d63 1
d95 1
a95 2
        MLWorks.IO.output
	  (MLWorks.IO.std_out, "You must register your copy of MLWorks.\n")
d101 2
a102 3
        (MLWorks.IO.output (MLWorks.IO.std_out, "Input your license name:");
         MLWorks.IO.flush_out MLWorks.IO.std_out;
         strip_newline (MLWorks.IO.input_line MLWorks.IO.std_in))
d105 2
a106 3
        (MLWorks.IO.output (MLWorks.IO.std_out, "Input your license code:");
         MLWorks.IO.flush_out MLWorks.IO.std_out;
         strip_newline (MLWorks.IO.input_line MLWorks.IO.std_in))
d123 2
a124 3
    (MLWorks.IO.output (MLWorks.IO.std_out, str);
     MLWorks.IO.output (MLWorks.IO.std_out, "\n\nType in new license (y/n)?  ");
     MLWorks.IO.flush_out MLWorks.IO.std_out;
d126 1
a126 1
       val reply_line = massageString (MLWorks.IO.input_line MLWorks.IO.std_in)
@


1.12.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 5
 *  Revision 1.12  1997/08/05  18:50:00  jkbrook
 *  [Bug #30223]
 *  Shortening license codes by using base 36 for date elements and
 *  reducing CHECK_CHARS from 10 to 8
 *
@


1.12.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 5
 *  Revision 1.12  1997/08/05  18:50:00  jkbrook
 *  [Bug #30223]
 *  Shortening license codes by using base 36 for date elements and
 *  reducing CHECK_CHARS from 10 to 8
 *
@


1.11
log
@[Bug #20072]
Adding edition info (e.g., student, personal) to licensing
@
text
@d6 4
d157 2
a158 2
              (* date chars are in ddmmyy format, hence 6 chars *)
              val exp_date_chars = substring(code, size code - 6, 6)
d160 1
a160 1
              val edition_chars = substring(code, size code - 13, 1)
@


1.10
log
@[Bug #20073]
Added datatype license_check_result for more flexible reporting
of license-checking/validation results.
@
text
@d6 5
d80 1
d150 1
d155 2
d158 1
a158 1
	      if license_store(exp_date_chars ^ name) then
d177 1
d187 1
a187 1
      | _ => complain_retry(license_error_invalid())
@


1.9
log
@[Bug #30212]
Allow user to type in license when one expires.
@
text
@d6 4
d59 12
a70 2
  val license_validate = env "license validate": string * string -> bool option
  val license_check = env "license check": unit -> bool option option
d141 4
a144 3
		NONE => complain_retry(license_error_invalid())
	      | SOME false => complain_retry(license_error_installdate())
              | SOME true => 
d154 3
a156 1
	    end)
d163 5
a167 4
       * SOME (SOME true)  == stored license is valid and has not expired
       * SOME (SOME false) == stored license has expired
       * SOME NONE 	   == stored license is invalid
       * NONE              == need to ask user to type in the license
d171 7
a177 4
        SOME(SOME true) => true	
      | SOME(SOME false) => complain_retry(license_error_expired())
      | SOME NONE => complain_retry(license_error_invalid())
      | NONE => user_input_license()
@


1.8
log
@[Bug #20077]
Adding an install-by date
@
text
@d6 4
a83 6
  fun ttyComplain str =
    (MLWorks.IO.output (MLWorks.IO.std_out, str);
     MLWorks.IO.output (MLWorks.IO.std_out, "\n");
     MLWorks.IO.flush_out MLWorks.IO.std_out;
     Exit.terminate Exit.failure)

d95 17
d116 1
a116 1
	  license{promptUser=promptUser, complain=complain}
d119 24
d144 8
d153 1
a153 1
        SOME(SOME true) => true
d156 1
a156 24
      | NONE => 
	  let
	    val (name, code) = promptUser ()
	    val name = massageString name
	    val code = massageString code
	  in
	    if size code > 3 then 
               (case (license_validate(name, code)) of
		  NONE => complain_retry(license_error_invalid())
		| SOME false => complain_retry(license_error_installdate())
                | SOME true => 
	      let
                (* date chars are in ddmmyy format, hence 6 chars *)
                val exp_date_chars = substring(code, size code - 6, 6)
	      in
	        if license_store(exp_date_chars ^ name) then
		  true
	        else
		  complain_retry ("MLWorks was unable to store the encoded license." ^ 
			license_error_invalid())
	      end)
	    else
	      complain_retry(license_error_invalid())
	  end
@


1.7
log
@[Bug #20077]
License expiry should be to the nearest day
@
text
@d6 4
d51 1
a51 1
  val license_validate = env "license validate": string * string -> bool
d56 1
d115 5
a119 1
	    if size code > 3 andalso license_validate(name, code) then
d122 1
a122 1
                val date_chars = substring(code, size code - 6, 6)
d124 1
a124 1
	        if license_store(date_chars ^ name) then
d129 1
a129 1
	      end
@


1.6
log
@[Bug #20074]
Improve license dialog - allow user to retry.
@
text
@d6 4
d112 2
a113 1
	        val date_chars = substring(code, size code - 4, 4)
@


1.5
log
@[Bug #1884]
Distinguish invalid licenses from expired licenses
@
text
@d6 4
d88 32
a119 25
  fun license{promptUser, complain} =
    case license_check() of
      SOME(SOME true) => true
    | SOME(SOME false) => (complain(license_error_expired()); false)
    | SOME NONE => (complain(license_error_invalid()); false)
    | NONE => 
	let
	  val (name, code) = promptUser ()
	  val name = massageString name
	  val code = massageString code
	in
	  if size code > 3 andalso license_validate(name, code) then
	    let
	      val date_chars = substring(code, size code - 4, 4)
	    in
	      if license_store(date_chars ^ name) then
		true
	      else
		(complain ("MLWorks was unable to store the encoded license.");
		 complain (license_error_invalid());
		 false)
	    end
	  else
	    (complain(license_error_invalid()); false)
	end
@


1.5.1.1
log
@branched from 1.5
@
text
@a5 4
 *  Revision 1.5  1997/01/07  14:00:09  jont
 *  [Bug #1884]
 *  Distinguish invalid licenses from expired licenses
 *
@


1.5.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 *  Revision 1.5.1.1  1997/05/12  10:35:42  hope
 *  branched from 1.5
 *
@


1.5.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 *  Revision 1.5.1.1  1997/05/12  10:35:42  hope
 *  branched from 1.5
 *
@


1.5.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 *  Revision 1.5.1.1  1997/05/12  10:35:42  hope
 *  branched from 1.5
 *
@


1.5.1.1.1.2
log
@[Bug #20074]
Merging - improving license dialog.
@
text
@a5 4
 *
 *  Revision 1.5.1.1.1.1  1997/07/28  18:21:25  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d91 25
a115 32
  fun license{promptUser, complain} = 
    let 
      fun complain_retry complain_str = 
	if complain complain_str then 
	  license{promptUser=promptUser, complain=complain}
	else
	  false
    in
      case license_check() of
        SOME(SOME true) => true
      | SOME(SOME false) => complain_retry(license_error_expired())
      | SOME NONE => complain_retry(license_error_invalid())
      | NONE => 
	  let
	    val (name, code) = promptUser ()
	    val name = massageString name
	    val code = massageString code
	  in
	    if size code > 3 andalso license_validate(name, code) then
	      let
	        val date_chars = substring(code, size code - 4, 4)
	      in
	        if license_store(date_chars ^ name) then
		  true
	        else
		  complain_retry ("MLWorks was unable to store the encoded license." ^ 
			license_error_invalid())
	      end
	    else
	      complain_retry(license_error_invalid())
	  end
    end
@


1.5.1.1.1.3
log
@[Bug #20077]
Merging into 1.1:
License expiry should be to the nearest day
@
text
@a5 4
 *  Revision 1.5.1.1.1.2  1997/08/05  09:26:22  johnh
 *  [Bug #20074]
 *  Merging - improving license dialog.
 *
d115 1
a115 2
                (* date chars are in ddmmyy format, hence 6 chars *)
                val date_chars = substring(code, size code - 6, 6)
@


1.5.1.1.1.4
log
@[Bug #20077]
Merging into 1.1
Adding install-by date
@
text
@a5 5
 *  Revision 1.5.1.1.1.3  1997/08/08  18:52:40  jkbrook
 *  [Bug #20077]
 *  Merging into 1.1:
 *  License expiry should be to the nearest day
 *
d54 1
a54 1
  val license_validate = env "license validate": string * string -> bool option
a58 1
  val license_error_installdate = env "license error install date": unit -> string
d117 1
a117 5
	    if size code > 3 then 
               (case (license_validate(name, code)) of
		  NONE => complain_retry(license_error_invalid())
		| SOME false => complain_retry(license_error_installdate())
                | SOME true => 
d120 1
a120 1
                val exp_date_chars = substring(code, size code - 6, 6)
d122 1
a122 1
	        if license_store(exp_date_chars ^ name) then
d127 1
a127 1
	      end)
@


1.5.1.1.1.5
log
@[Bug #30212]
Merging into 1.1:
Allow user to type in license when one expires
@
text
@a5 5
 *  Revision 1.5.1.1.1.4  1997/08/11  09:16:12  jkbrook
 *  [Bug #20077]
 *  Merging into 1.1
 *  Adding install-by date
 *
d88 6
a104 17
  fun ttyComplain str =
    (MLWorks.IO.output (MLWorks.IO.std_out, str);
     MLWorks.IO.output (MLWorks.IO.std_out, "\n\nType in new license (y/n)?  ");
     MLWorks.IO.flush_out MLWorks.IO.std_out;
     let 
       val reply_line = massageString (MLWorks.IO.input_line MLWorks.IO.std_in)
       val reply_char = 
	 if size reply_line > 0 then
	   substring (reply_line, 0, 1)
	 else "n"
     in
       if reply_char = "y" then 
	 true 
       else
         Exit.terminate Exit.failure
     end)

d109 1
a109 1
	  user_input_license()
a111 24
      and user_input_license () = 
	let
	  val (name, code) = promptUser ()
	  val name = massageString name
	  val code = massageString code
	in
	  if size code > 3 then 
             (case (license_validate(name, code)) of
		NONE => complain_retry(license_error_invalid())
	      | SOME false => complain_retry(license_error_installdate())
              | SOME true => 
	    let
              (* date chars are in ddmmyy format, hence 6 chars *)
              val exp_date_chars = substring(code, size code - 6, 6)
	    in
	      if license_store(exp_date_chars ^ name) then
		true
	      else
		complain_retry ("MLWorks was unable to store the encoded license." ^ 
			license_error_invalid())
	    end)
	  else
	    complain_retry(license_error_invalid())
	end
a112 8

      (* 
       * SOME (SOME true)  == stored license is valid and has not expired
       * SOME (SOME false) == stored license has expired
       * SOME NONE 	   == stored license is invalid
       * NONE              == need to ask user to type in the license
       *)

d114 1
a114 1
        SOME(SOME true) => true	
d117 24
a140 1
      | NONE => user_input_license()
@


1.5.1.1.1.6
log
@[Bug #20073]
Merging into 1.1:
Adding license_check_result datatype/enum
@
text
@a5 5
 *  Revision 1.5.1.1.1.5  1997/08/11  15:02:27  jkbrook
 *  [Bug #30212]
 *  Merging into 1.1:
 *  Allow user to type in license when one expires
 *
d64 2
a65 12
  (* this datatype must be kept consistent with that in sha/register.h *)

  datatype license_check_result = EXPIRED
	                        | INSTALLDATE   
			        | INTERNAL_ERROR
                                | INVALID       
			        | NOT_FOUND
                                | OK            
                                | WRONG_EDITION            

  val license_validate = env "license validate": string * string -> license_check_result
  val license_check = env "license check": unit -> license_check_result
d136 3
a138 4
		INVALID => complain_retry(license_error_invalid())
	      | INSTALLDATE => complain_retry(license_error_installdate())
	      | EXPIRED => complain_retry(license_error_expired())
              | OK => 
d148 1
a148 3
	    end
             | _ => complain_retry(license_error_invalid())
             )
d155 4
a158 5
       * OK              == stored license is valid and has not expired
       * EXPIRED         == stored license has expired
       * INVALID         == stored license is invalid
       * NOT_FOUND       == need to ask user to type in the license
       * INTERNAL_ERROR  == internal errors (e.g., malloc failures)
d162 4
a165 7
        OK => true	
      | EXPIRED => complain_retry(license_error_expired())
      | INVALID => complain_retry(license_error_invalid())
      | INTERNAL_ERROR => complain_retry(license_error_invalid()) 
      | INSTALLDATE => complain_retry(license_error_invalid()) (* possible? *)
      | NOT_FOUND => user_input_license()
      | _ => complain_retry(license_error_invalid())
@


1.5.1.1.1.7
log
@[Bug #20072]
Merging into 1.1:
Adding edition info
@
text
@a5 5
 *  Revision 1.5.1.1.1.6  1997/08/11  15:29:21  jkbrook
 *  [Bug #20073]
 *  Merging into 1.1:
 *  Adding license_check_result datatype/enum
 *
a84 1
  val license_error_version = env "license error wrong version": unit -> string
a153 1
              | WRONG_EDITION => complain_retry(license_error_version())
a157 2
              (* edition number is before the two dates *)
              val edition_chars = substring(code, size code - 13, 1)
d159 1
a159 1
	      if license_store(exp_date_chars ^ edition_chars ^ name) then
a177 1
       * WRONG_EDITION   == license is for a different edition  
d187 1
a187 1
      | WRONG_EDITION => complain_retry(license_error_version())
@


1.5.1.1.1.8
log
@[Bug #30223]
Merging into 1.1:
Shortening codes by using base 36 dates and 8 CHECK_CHARS
@
text
@a5 5
 *  Revision 1.5.1.1.1.7  1997/08/11  16:41:31  jkbrook
 *  [Bug #20072]
 *  Merging into 1.1:
 *  Adding edition info
 *
d163 2
a164 2
              (* date chars are in dmy format (base 36), hence 3 chars *)
              val exp_date_chars = substring(code, size code - 3, 3)
d166 1
a166 1
              val edition_chars = substring(code, size code - 7, 1)
@


1.5.1.1.1.8.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 5
 *  Revision 1.5.1.1.1.8  1997/08/11  17:35:14  jkbrook
 *  [Bug #30223]
 *  Merging into 1.1:
 *  Shortening codes by using base 36 dates and 8 CHECK_CHARS
 *
@


1.4
log
@Ensured that the code from promptUser is > 3 chars long before calling
substring.
Also mapped name to lower case before encoding, and stripped leading and
trailing whitespace.
@
text
@d6 6
d40 1
a40 1
  val license_check = env "license check": unit -> bool option
d42 2
a43 1
  val license_error_string = env "license error string": unit -> string
d84 25
a108 28
  fun license {promptUser, complain} =
    case license_check () 
    of SOME true => 
      true
    |  SOME false =>
      (complain (license_error_string ());
       false)
    |  NONE => 
      let
        val (name, code) = promptUser ()
        val name = massageString name
        val code = massageString code
      in
	if size code > 3 andalso license_validate (name, code) then
	  let
	    val date_chars = substring (code, size code - 4, 4)
	  in
	    if license_store (date_chars ^ name) then
	      true
            else
              (complain ("MLWorks was unable to store the encoded license.");
               complain (license_error_string ());
	       false)
	  end
        else
          (complain (license_error_string ());
	   false)
      end
a109 1

@


1.4.3.1
log
@branched from 1.4
@
text
@a5 6
 *  Revision 1.4  1996/11/15  16:25:45  daveb
 *  Ensured that the code from promptUser is > 3 chars long before calling
 *  substring.
 *  Also mapped name to lower case before encoding, and stripped leading and
 *  trailing whitespace.
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a5 6
 *  Revision 1.4  1996/11/15  16:25:45  daveb
 *  Ensured that the code from promptUser is > 3 chars long before calling
 *  substring.
 *  Also mapped name to lower case before encoding, and stripped leading and
 *  trailing whitespace.
 *
@


1.4.2.1.1.1
log
@branched from 1.4.2.1
@
text
@a5 3
 *  Revision 1.4.2.1  1996/12/17  17:49:09  hope
 *  branched from 1.4
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a5 6
 *  Revision 1.4  1996/11/15  16:25:45  daveb
 *  Ensured that the code from promptUser is > 3 chars long before calling
 *  substring.
 *  Also mapped name to lower case before encoding, and stripped leading and
 *  trailing whitespace.
 *
@


1.3
log
@AddMade ttyComplain addppend a newline to the error message, as the literal
no longer ends with a newline (s<URIL://MTLWrts/src/OS/Unix/license.c>.
@
text
@d6 4
d21 2
d66 11
d87 2
a88 1
	val date_chars = substring (code, size code - 4, 4)
d90 11
a100 3
        if license_validate (name, code) andalso
	   license_store (date_chars ^ name) then
	  true
@


1.3.1.1
log
@branched from 1.3
@
text
@a5 4
 *  Revision 1.3  1996/11/13  13:59:03  daveb
 *  AddMade ttyComplain addppend a newline to the error message, as the literal
 *  no longer ends with a newline (s<URIL://MTLWrts/src/OS/Unix/license.c>.
 *
@


1.3.1.2
log
@Ensured that the code from promptUser is > 3 chars long before calling
substring.
Also mapped name to lower case before encoding, and stripped leading and
trailing whitespace.
@
text
@a5 3
 *  Revision 1.3.1.1  1996/11/14  12:51:19  hope
 *  branched from 1.3
 *
d7 2
a8 2
 *  Made ttyComplain append a newline to the error message, as the literal
 *  no longer ends with a newline <URI://MLWrts/src/OS/Unix/license.c>.
a20 2
require "^.basis.__substring";
require "^.basis.__char";
a63 11
  (* massageString converts all letters to lower case, and strips leading
     and trailing spaces.  This makes the data entry much more pleasant. *)
  fun massageString s =
    let
      val ss = Substring.all s
      val dl = Substring.dropl Char.isSpace ss 
      val dr = Substring.dropr Char.isSpace dl
    in
      Substring.translate (str o Char.toLower) dr
    end

d74 1
a74 2
        val name = massageString name
        val code = massageString code
d76 3
a78 11
	if size code > 3 andalso license_validate (name, code) then
	  let
	    val date_chars = substring (code, size code - 4, 4)
	  in
	    if license_store (date_chars ^ name) then
	      true
            else
              (complain ("MLWorks was unable to store the encoded license.");
               complain (license_error_string ());
	       false)
	  end
@


1.3.1.1.1.1
log
@branched from 1.3.1.1
@
text
@a5 3
 *  Revision 1.3.1.1  1996/11/14  12:51:19  hope
 *  branched from 1.3
 *
@


1.3.1.1.1.2
log
@Ensured that the code from promptUser is > 3 chars long before calling
substring.
Also mapped name to lower case before encoding, and stripped leading and
trailing whitespace.
@
text
@a5 3
 *  Revision 1.3.1.1.1.1  1996/11/28  15:02:23  hope
 *  branched from 1.3.1.1
 *
d10 2
a11 2
 *  Made ttyComplain append a newline to the error message, as the literal
 *  no longer ends with a newline <URI://MLWrts/src/OS/Unix/license.c>.
a23 2
require "^.basis.__substring";
require "^.basis.__char";
a66 11
  (* massageString converts all letters to lower case, and strips leading
     and trailing spaces.  This makes the data entry much more pleasant. *)
  fun massageString s =
    let
      val ss = Substring.all s
      val dl = Substring.dropl Char.isSpace ss 
      val dr = Substring.dropr Char.isSpace dl
    in
      Substring.translate (str o Char.toLower) dr
    end

d77 1
a77 2
        val name = massageString name
        val code = massageString code
d79 3
a81 11
	if size code > 3 andalso license_validate (name, code) then
	  let
	    val date_chars = substring (code, size code - 4, 4)
	  in
	    if license_store (date_chars ^ name) then
	      true
            else
              (complain ("MLWorks was unable to store the encoded license.");
               complain (license_error_string ());
	       false)
	  end
@


1.2
log
@Added date to the license to be stored.
@
text
@d6 3
d56 1
@


1.1
log
@new unit
Interface to the licensing code in the runtime.
@
text
@d5 5
a9 1
 * $Log$
d66 1
d68 2
a69 2
        if license_validate (name, code)
           andalso license_store name then
a75 2

 
@
