head	1.58;
access;
symbols
	MLW_daveb_inline_1_4_99:1.58.1
	MLWorks_21c0_1999_03_25:1.58
	MLWorks_20c1_1998_08_20:1.58
	MLWorks_20c0_1998_08_04:1.58
	MLWorks_20b2c2_1998_06_19:1.58
	MLWorks_20b2_Windows_1998_06_12:1.58
	MLWorks_20b1c1_1998_05_07:1.58
	MLWorks_20b0_1998_04_07:1.58
	MLWorks_20b0_1998_03_20:1.58
	MLWorks_20m2_1998_02_16:1.58
	MLWorks_20m1_1997_10_23:1.57
	MLWorks_11r1:1.56.1.1.1.1.1
	MLWorks_workspace_97:1.57.2
	MLWorks_dt_wizard:1.57.1
	MLWorks_11c0_1997_09_09:1.56.1.1.1.1
	MLWorks_10r3:1.56.1.1.3
	MLWorks_10r2_551:1.56.1.1.2
	MLWorks_11:1.56.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.56.1.1
	MLWorks_20m0_1997_06_20:1.57
	MLWorks_1_0_r2c2_1997_06_14:1.56.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.56.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.56.1
	MLWorks_BugFix_1997_04_24:1.56
	MLWorks_1_0_r2_Win32_1997_04_11:1.56
	MLWorks_1_0_r2_Unix_1997_04_04:1.56
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.54.3.1.1
	MLWorks_gui_1996_12_18:1.54.4
	MLWorks_1_0_Win32_1996_12_17:1.54.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.54.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.54.1.1
	MLWorks_1_0_Irix_1996_11_28:1.54.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.54.2
	MLWorks_1_0_Unix_1996_11_14:1.54.1
	MLWorks_Open_Beta2_1996_10_11:1.53.3
	MLWorks_License_dev:1.53.2
	MLWorks_1_open_beta_1996_09_13:1.53.1
	MLWorks_Open_Beta_1996_08_22:1.53
	MLWorks_Beta_1996_07_02:1.53
	MLWorks_Beta_1996_06_07:1.53
	MLWorks_Beta_1996_06_06:1.53
	MLWorks_Beta_1996_06_05:1.53
	MLWorks_Beta_1996_06_03:1.53
	MLWorks_Beta_1996_05_31:1.53
	MLWorks_Beta_1996_05_30:1.53
	ML_beta_release_12/08/94:1.47
	ML_beta_release_03/08/94:1.47
	ML_revised_beta_release_25/05/94:1.46
	ML_final_beta_release_02/03/94:1.46
	mlworks-28-01-1994:1.46
	Release:1.44
	mlworks-beta-01-09-1993:1.44
	MLWorks-1-0-4-29/01/1993:1.41
	MLWorks-1-0-3-21/12/1992:1.40
	MLWorks-1-0-2-15/12/1992:1.40
	MLWorks-1-0-1-04/12/1992:1.40
	checkpoint_17_08_92:1.34;
locks; strict;
comment	@ * @;


1.58
date	98.01.30.09.45.02;	author johnh;	state Exp;
branches
	1.58.1.1;
next	1.57;

1.57
date	97.05.12.16.01.27;	author jont;	state Exp;
branches
	1.57.1.1
	1.57.2.1;
next	1.56;

1.56
date	97.01.21.11.52.38;	author matthew;	state Exp;
branches
	1.56.1.1;
next	1.55;

1.55
date	96.12.04.16.56.18;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	96.10.10.02.42.17;	author io;	state Exp;
branches
	1.54.1.1
	1.54.2.1
	1.54.3.1
	1.54.4.1;
next	1.53;

1.53
date	96.02.23.16.19.00;	author jont;	state Exp;
branches
	1.53.1.1
	1.53.2.1
	1.53.3.1;
next	1.52;

1.52
date	95.08.11.17.09.05;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.02.28.14.08.59;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	94.10.10.10.13.39;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	94.09.19.13.43.24;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.09.09.17.11.58;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	94.07.19.15.10.38;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	93.12.17.15.23.12;	author io;	state Exp;
branches;
next	1.45;

1.45
date	93.08.12.12.14.01;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	93.07.29.16.27.44;	author nosa;	state Exp;
branches
	1.44.1.1;
next	1.43;

1.43
date	93.03.10.17.07.03;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	93.03.01.15.11.35;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	93.01.14.14.43.20;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	92.11.21.19.21.51;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.10.26.18.20.23;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	92.09.24.11.48.19;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.09.03.16.40.02;	author richard;	state Exp;
branches;
next	1.36;

1.36
date	92.08.26.13.46.53;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.08.19.18.37.21;	author davidt;	state Exp;
branches;
next	1.34;

1.34
date	92.08.03.13.07.57;	author davidt;	state Exp;
branches;
next	1.33;

1.33
date	92.07.17.14.38.30;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.07.01.13.42.12;	author davida;	state Exp;
branches;
next	1.31;

1.31
date	92.06.29.09.33.43;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.06.23.10.10.34;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.06.11.09.46.29;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.06.08.12.57.52;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.05.06.11.45.51;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.04.13.15.28.33;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.02.11.11.07.19;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.02.03.20.09.39;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.01.09.14.50.02;	author richard;	state Exp;
branches;
next	1.22;

1.22
date	91.12.10.13.49.41;	author richard;	state Exp;
branches;
next	1.21;

1.21
date	91.12.09.12.17.28;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.12.04.15.00.04;	author richard;	state Exp;
branches;
next	1.19;

1.19
date	91.11.28.16.33.37;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	91.11.18.15.08.03;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.11.15.14.13.57;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.11.14.17.08.10;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.11.12.16.57.09;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.10.29.14.57.35;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.10.22.18.27.34;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	91.10.22.16.53.23;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	91.10.16.16.19.01;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.10.15.13.59.29;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.10.09.15.20.30;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	91.10.08.11.50.01;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.09.24.15.41.14;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.09.24.13.01.33;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.09.23.12.30.08;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.09.18.11.29.30;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.09.16.16.43.40;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.09.09.13.34.15;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.05.11.00.38;	author jont;	state Exp;
branches;
next	;

1.44.1.1
date	93.07.29.16.27.44;	author jont;	state Exp;
branches;
next	;

1.53.1.1
date	96.09.13.11.18.14;	author hope;	state Exp;
branches;
next	;

1.53.2.1
date	96.10.07.16.08.06;	author hope;	state Exp;
branches;
next	;

1.53.3.1
date	96.10.17.11.26.20;	author hope;	state Exp;
branches;
next	;

1.54.1.1
date	96.11.14.12.51.37;	author hope;	state Exp;
branches
	1.54.1.1.1.1;
next	;

1.54.1.1.1.1
date	96.11.28.15.02.40;	author hope;	state Exp;
branches;
next	;

1.54.2.1
date	96.11.22.18.10.50;	author hope;	state Exp;
branches;
next	;

1.54.3.1
date	96.12.17.17.49.25;	author hope;	state Exp;
branches
	1.54.3.1.1.1;
next	;

1.54.3.1.1.1
date	97.02.24.11.39.33;	author hope;	state Exp;
branches;
next	;

1.54.4.1
date	96.12.18.09.43.29;	author hope;	state Exp;
branches;
next	;

1.56.1.1
date	97.05.12.10.35.58;	author hope;	state Exp;
branches
	1.56.1.1.1.1
	1.56.1.1.2.1
	1.56.1.1.3.1;
next	;

1.56.1.1.1.1
date	97.07.28.18.21.39;	author daveb;	state Exp;
branches
	1.56.1.1.1.1.1.1;
next	;

1.56.1.1.1.1.1.1
date	97.10.07.11.47.20;	author jkbrook;	state Exp;
branches;
next	;

1.56.1.1.2.1
date	97.09.08.17.15.04;	author daveb;	state Exp;
branches;
next	;

1.56.1.1.3.1
date	97.09.09.14.10.56;	author daveb;	state Exp;
branches;
next	;

1.57.1.1
date	97.09.10.19.26.58;	author brucem;	state Exp;
branches;
next	;

1.57.2.1
date	97.09.11.20.56.58;	author daveb;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	97.11.20.17.01.13;	author daveb;	state Exp;
branches;
next	;

1.58.1.1
date	99.04.01.17.58.10;	author daveb;	state Exp;
branches;
next	;


desc
@Handle the translation of BUILTINs to selections from /library
@


1.58
log
@[Bug #30326]
Merge in change from branch MLWorks_workspace_97
@
text
@(*  ==== PERVASIVE LIBRARY UTILITIES ====
 *                FUNCTOR
 *
 *  Copyright (C) 1991 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  See individual function comments for documentation.
 *
 *  Revision Log
 *  ------------
 *  $Log: _library.sml,v $
 * Revision 1.57.2.2  1997/11/20  17:01:13  daveb
 * [Bug #30326]
 *
 * Revision 1.57.2.1  1997/09/11  20:56:58  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.57  1997/05/12  16:01:27  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
 * Revision 1.56  1997/01/21  11:52:38  matthew
 * Adding Options
 *
 * Revision 1.55  1996/12/04  16:56:18  matthew
 * Simplifications
 *
 * Revision 1.54  1996/10/10  02:42:17  io
 * moving String from toplevel
 *
 * Revision 1.53  1996/02/23  16:19:00  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.52  1995/08/11  17:09:05  daveb
 * Added new types for different sizes of ints, words, and reals.
 *
 *  Revision 1.51  1995/02/28  14:08:59  matthew
 *  Changes to DebuggerTypes.
 *
 *  Revision 1.50  1994/10/10  10:13:39  matthew
 *  Adding module annotations to lambda syntax.
 *
 *  Revision 1.49  1994/09/19  13:43:24  matthew
 *  Changes to lambdatypes
 *
 *  Revision 1.48  1994/09/09  17:11:58  jont
 *  Machine specific functions is_fun and implicit_references moved to machperv
 *
 *  Revision 1.47  1994/07/19  15:10:38  matthew
 *  Multiple args for functions and applications
 *
 *  Revision 1.46  1993/12/17  15:23:12  io
 *  Changed some require paths
 *
 *  Revision 1.45  1993/08/12  12:14:01  nosa
 *  FNs now passed closed-over type variables and
 *  stack frame-offset for runtime-instance for polymorphic debugger.
 *
 *  Revision 1.44  1993/07/29  16:27:44  nosa
 *  structure Option.
 *
 *  Revision 1.43  1993/03/10  17:07:03  matthew
 *  Signature revisions
 *
 *  Revision 1.42  1993/03/01  15:11:35  matthew
 *  Added MLVALUE lambda exp
 *
 *  Revision 1.41  1993/01/14  14:43:20  daveb
 *  Changed explicit manipulation of list representation to use new format.
 *
 *  Revision 1.40  1992/11/21  19:21:51  jont
 *  Replaced MachSpec with MachPerv
 *
 *  Revision 1.39  1992/10/26  18:20:23  daveb
 *  Minor changes to support the new type of SWITCHes.
 *
 *  Revision 1.38  1992/09/24  11:48:19  jont
 *  removed some redundant bindings
 *
 *  Revision 1.37  1992/09/03  16:40:02  richard
 *  Moved the special names out of the compiler as a whole.
 *
 *  Revision 1.36  1992/08/26  13:46:53  jont
 *  Removed some redundant structures and sharing
 *
 *  Revision 1.35  1992/08/19  18:37:21  davidt
 *  Now uses NewMap instead of Map.
 *
 *  Revision 1.34  1992/08/03  13:07:57  davidt
 *  Type of BUILTIN changed a little.
 *
 *  Revision 1.33  1992/07/17  14:38:30  clive
 *  null_type_annotation no longer a function
 *
 *  Revision 1.32  1992/07/01  13:42:12  davida
 *  Added LET constructor and new slot to APP.
 *
 *  Revision 1.31  1992/06/29  09:33:43  clive
 *  Added type annotation information at application points
 *
 *  Revision 1.30  1992/06/23  10:10:34  clive
 *  Added an annotation slot to HANDLE
 *
 *  Revision 1.29  1992/06/11  09:46:29  clive
 *  Made changes as LET now has a string annotation
 *
 *  Revision 1.28  1992/06/08  12:57:52  jont
 *  changed to produce lists as compilation units instead of tuples
 *
 *  Revision 1.27  1992/05/06  11:45:51  jont
 *  Modified to use augmented lambda calculus
 *
 *  Revision 1.26  1992/04/13  15:28:33  clive
 *  First version of the profiler
 *
 *  Revision 1.25  1992/02/11  11:07:19  clive
 *  New pervasive library code
 *
 *  Revision 1.24  1992/02/03  20:09:39  jont
 *  Made sure eta abstraction on builtins occurs even when there are
 *  no external references
 *
 *  Revision 1.23  1992/01/09  14:50:02  richard
 *  Removed extra set of lambda bindings wrapped around expression in
 *  build_external_environment.
 *
 *  Revision 1.22  1991/12/10  13:49:41  richard
 *  Fixed bug whereby the switch expression was not analysed for
 *  external references.
 *
 *  Revision 1.21  91/12/09  12:17:28  richard
 *  Removed redundant `.mo' extension from the name of the pervasive
 *  library.
 *  
 *  Revision 1.20  91/12/04  15:00:04  richard
 *  Added an extra SELECT operation on the pervasive library so
 *  that this can be a structure rather than a set of top-level
 *  declarations.  This means it gets sorted correctly by the
 *  compiler.
 *  
 *  Revision 1.19  91/11/28  16:33:37  richard
 *  Completely reimplemented this module, tidied it up, and documented it.
 *  The functions provided have changed quite a bit.
 *  
 *  Revision 1.18  91/11/18  15:08:03  jont
 *  Fixed builtin_implicit_set so as to know about builtins which will be
 *  eta_abstracted. Also tidied up remnants of old CALL_C stuff.
 *  
 *  Revision 1.17  91/11/15  14:13:57  richard
 *  Changed the ordering on pervasive symbols to work on the library names
 *  rather than on the printing names.
 *  
 *  Revision 1.16  91/11/14  17:08:10  jont
 *  Eta abstracted builtin functions where they aren't applied so they
 *  can be inline generated. Required by Pervasives
 *  
 *  Revision 1.15  91/11/12  16:57:09  jont
 *  Moved is_inline function out into MachPerv, which knows the real answers
 *  
 *  Revision 1.14  91/10/29  14:57:35  jont
 *  Added reference to existence of machine level div, mod, * for determining
 *  whether to inline various primitives
 *  
 *  Revision 1.13  91/10/22  18:27:34  davidt
 *  The structure LambdaSub.LambdaTypes is now called LambdaSub.LT
 *  
 *  Revision 1.12  91/10/22  16:53:23  davidt
 *  Replaced impossible exception with call to Crash.impossible.
 *  
 *  Revision 1.11  91/10/16  16:19:01  jont
 *  Added CALL_C to result of prims_in_le
 *  
 *  Revision 1.10  91/10/15  13:59:29  jont
 *  Added stuff to do with CALL_C required for garbage collection.
 *  
 *  Revision 1.9  91/10/09  15:20:30  davidt
 *  Made changes due to record selection now requiring both the total
 *  size of the record as well as the index.
 *  
 *  Revision 1.8  91/10/08  11:50:01  jont
 *  Changed use of lambdasub.number_from to lists.number_from_by_one
 *  
 *  Revision 1.7  91/09/24  15:41:14  jont
 *  Fixed bug whereby chr -> Chr and ord -> Ord correspondences were left
 *  out. Alos corrected exception raised by mod
 *  
 *  Revision 1.6  91/09/24  13:01:33  davida
 *  Fixed bug in add_pervasive_refs function.
 *  
 *  Revision 1.5  91/09/23  12:30:08  jont
 *  Added stuff to deal with implicit exceptions (eg from ADDV)
 *  
 *  Revision 1.4  91/09/18  11:29:30  jont
 *  Fixed bug whereby builtin exceptions weren't visible
 *  
 *  Revision 1.3  91/09/16  16:43:40  jont
 *  Corrected spelling of _make_new_unique
 *  
 *  Revision 1.2  91/09/09  13:34:15  davida
 *  Changed to use reduce_left from Lists, not LambdaSub.
 *  
 *  Revision 1.1  91/09/05  11:00:38  jont
 *  Initial revision
 *)

require "../utils/diagnostic";
require "../utils/lists";
require "../utils/crash";
require "../utils/map";
require "../lambda/auglambda";
require "../lambda/lambdaprint";
require "machperv";
require "mlworks_io";

require "library";

functor Library(
  structure Diagnostic  : DIAGNOSTIC
  structure Lists       : LISTS
  structure Crash       : CRASH
  structure NewMap      : MAP
  structure AugLambda   : AUGLAMBDA
  structure LambdaPrint	: LAMBDAPRINT
  structure MachPerv    : MACHPERV
  structure Io		: MLWORKS_IO

  sharing LambdaPrint.LambdaTypes = AugLambda.LambdaTypes
  sharing type MachPerv.Pervasives.pervasive = LambdaPrint.LambdaTypes.Primitive
    ) : LIBRARY =
  struct
    structure Pervasives = MachPerv.Pervasives
    structure LambdaTypes = LambdaPrint.LambdaTypes
    structure NewMap = NewMap
    structure Set = LambdaTypes.Set
    structure AugLambda = AugLambda
    structure Ident = LambdaTypes.Ident

    type CompilerOptions = MachPerv.CompilerOptions

    (*  == Change references to BUILTINs to lambda variables ==
     *
     *  Given a lambda expression and a map from pervasives to lambda
     *  variables, this function generates a new lambda expression with all
     *  references to pervasives in the map converted to lambda variables,
     *  EXCEPT if the pervasive is in line and not applied, in which case an
     *  eta-abstraction is built around it.
     *
     *  For example, BUILTIN _int+  --->  \x.APP(BUILTIN _int+, x)
     *)

    (* This shouldn't really be needed *)
    (*  Eta-abstraction over some expression. *)
    (*  Generates a new lambda-variable. *)

    fun eta_abstract (le,annotation,ty) =
      let
        val lvar = LambdaTypes.new_LVar()
      in
        LambdaTypes.FN (([lvar],[]),
                        LambdaTypes.APP (le, ([LambdaTypes.VAR lvar],[]), SOME(ty)), 
                        LambdaTypes.BODY, 
                        annotation,
                        LambdaTypes.null_type_annotation,
                        LambdaTypes.internal_funinfo)
      end

    (* Moved here from lambdasub as this was its only use *)
    (* could certainly be simplified somewhat *)
  fun apply_one_level appsub = 
    let 
      fun apopt f (SOME x) = SOME (f x)
        | apopt _ NONE     = NONE
      fun apply_tagval (LambdaTypes.EXP_TAG tagexp, value) =
        (LambdaTypes.EXP_TAG (appsub tagexp), appsub value)
        | apply_tagval (tagexp, value) =
          (tagexp, appsub value)

      fun apply (le as LambdaTypes.VAR _) = le
        | apply (LambdaTypes.FN(args, le, status, x,ty,instance)) =
        LambdaTypes.FN (args, appsub le,status, x,ty,instance) 
        | apply (LambdaTypes.LET((lv,info,lb),le)) =
        LambdaTypes.LET((lv,info,appsub lb),appsub le)
        | apply (LambdaTypes.LETREC(lvl, lel, le)) =
          LambdaTypes.LETREC (lvl, map appsub lel, appsub le)
        | apply (LambdaTypes.APP(p, (q,r), annotation)) = 
          LambdaTypes.APP(appsub p, (map appsub q, map appsub r), annotation)
        | apply (le as LambdaTypes.SCON _) = le
        | apply (le as LambdaTypes.MLVALUE _) = le
        | apply (le as LambdaTypes.INT _) = le
        | apply (LambdaTypes.SWITCH(le, info, clel, leo)) = 
          LambdaTypes.SWITCH
          (appsub le,
           info,
           map apply_tagval clel,
           apopt appsub leo)
        | apply (LambdaTypes.STRUCT (lel,ty)) = LambdaTypes.STRUCT (map appsub lel,ty)
        | apply (LambdaTypes.SELECT (fld, le)) = LambdaTypes.SELECT (fld, appsub le)
        | apply (LambdaTypes.RAISE (le)) = LambdaTypes.RAISE (appsub le)
        | apply (LambdaTypes.HANDLE (le1, le2,annotation)) = LambdaTypes.HANDLE (appsub le1, 
                                                                                 appsub le2,
                                                                                 annotation)
        | apply (le as LambdaTypes.BUILTIN _) = le
    in
      apply
    end

   fun externalise (options,expression, extern_map) =
      let
	open LambdaTypes

	fun externalise' (APP (BUILTIN pervasive, (el,fpel), ty)) =
          if MachPerv.is_inline (options,pervasive) then
            APP (BUILTIN pervasive, (map externalise' el, map externalise' fpel), ty)
          else
            APP (VAR (NewMap.apply'(extern_map, pervasive)), 
                 (map externalise' el, map externalise' fpel),
                 ty)

	  | externalise' (expression as BUILTIN pervasive) =
	    if (MachPerv.is_inline (options, pervasive) andalso 
                MachPerv.is_fun pervasive) then
	      externalise' (eta_abstract 
                            (expression,"Builtin function " ^ Pervasives.print_pervasive pervasive,
                             ref null_type_annotation))
	    else
	      VAR (NewMap.apply'(extern_map, pervasive))
	  | externalise' expression =
	    apply_one_level externalise' expression
      in
	externalise' expression
      end

    (*  === EXTRACT ALL EXTERNAL REFERENCES ===
     *
     *  The following rules are applied:
     *
     *    APP(BUILTIN pervasive, ...)  -->  pervasive if not inline
     *                                      implicits if inline
     *    BUILTIN pervasive  -->  pervasive if not inline
     *                            pervasive if not a function
     *                            implicits if inline and a function
     *    SWITCH on string  -->  STRING_EQ pervasive and its implicits
     *
     *  In the first case the pervasive is known to be a function, so the
     *  function test is not required.  Non-functions cannot make implicit
     *  references.
     *)

    fun external_references (options, expression) =
      let
	open LambdaTypes

	fun find (done, APP (BUILTIN pervasive, (el,fpel), ty)) =
	    if MachPerv.is_inline (options,pervasive) then
	      Lists.reducel find ((MachPerv.implicit_references pervasive) @@ done,
                                  (fpel @@ el))
	    else
	      Lists.reducel find (pervasive :: done, fpel @@ el)

	  | find (done, BUILTIN pervasive) =
	    if (MachPerv.is_inline (options, pervasive) andalso
		MachPerv.is_fun pervasive) then
	      (MachPerv.implicit_references pervasive) @@ done
	    else
	      pervasive :: done

	  | find (done, SWITCH (expression, info, cases, default)) =
	    let

	      fun find_case (done, (EXP_TAG expression, expression')) =
		  find (find (done, expression), expression')

		| find_case (done, (SCON_TAG (Ident.STRING _, _), expression')) =
		  let
		    val references =
		      Pervasives.STRINGEQ ::
		      (MachPerv.implicit_references Pervasives.STRINGEQ)
		  in
		    find (references @@ done, expression')
		  end

		| find_case (done, (_, expression')) =
		  find (done, expression')

	      fun find_option (done, SOME expression) =
		  find (done, expression)

		| find_option (done, NONE) = done
	    in
	      Lists.reducel find_case
	      (find_option (find (done, expression), default), cases)
	    end

	  | find (done, VAR _) = done
	  | find (done, FN (_, expression,_,_,_,_)) = find (done, expression)
	  | find (done, LET ((_,_, binding),expression)) = 
	    find (find (done,binding), expression)
	  | find (done, APP (expression, (el,fpel), _)) =
	    Lists.reducel find (find (done, expression), fpel @@ el)
	  | find (done, SCON _) = done
	  | find (done, MLVALUE _) = done
	  | find (done, INT _) = done
	  | find (done, SELECT (_, expression)) = find (done, expression)
	  | find (done, STRUCT (expressions,_)) =
	    Lists.reducel find (done, expressions)
	  | find (done, RAISE (expression)) = find (done, expression)
	  | find (done, HANDLE (expression, expression',_)) =
	    find (find (done, expression), expression')
	  | find (done, LETREC (_, expressions, expression')) =
	    Lists.reducel find (find (done, expression'), expressions)

      in
	Set.list_to_set (find ([], expression))
      end



    (*  === EXTRACT IMPLICIT EXTERNAL REFERENCES ===
     *
     *  The following rules are applied:
     *
     *    APP (BUILTIN pervasive, ...)  -->  implicits of the pervasive
     *    SWITCH on string  -->  implicits of STRINGEQ
     *)


    fun implicit_external_references expression =
      let
	open AugLambda

	fun find (done,
		  {lexp=APP ({lexp=BUILTIN(pervasive,_), ...}, (el,fpel),_),
		   size=_}) =
	    Lists.reducel find ((MachPerv.implicit_references pervasive) @@ done,
                                fpel @@ el)

	  | find (done, {lexp=SWITCH (expression, info, cases, default),
			 ...}) =
	    let

	      fun find_case (done, (EXP_TAG expression, expression')) =
		  find (find (done, expression), expression')

		| find_case (done, (SCON_TAG (Ident.STRING _, _), expression')) =
		  let
		    val references =
		      MachPerv.implicit_references Pervasives.STRINGEQ
		  in
		    find (references @@ done, expression')
		  end

		| find_case (done, (_, expression')) =
		  find (done, expression')

	      fun find_option (done, SOME expression) =
		  find (done, expression)

		| find_option (done, NONE) = done
	    in
	      Lists.reducel find_case
	      (find_option (find (done, expression), default), cases)
	    end

	  (* The rest of the cases are uninteresting, except LETREC which is *)
	  (* just cute. *)

	  | find (done, {lexp=BUILTIN pervasive, ...}) = done
	  | find (done, {lexp=VAR _, ...}) = done
	  | find (done, {lexp=FN (_, expression,_,_), ...}) =
	    find (done, expression)
	  | find (done, {lexp=LET ((_,_, binding), expression),...}) =
	    find (find (done, binding), expression)
	  | find (done, {lexp=APP (expression, (el,fpel),_), ...}) =
	    Lists.reducel find (find (done, expression), fpel @@ el)
	  | find (done, {lexp=SCON _, ...}) = done
	  | find (done, {lexp=MLVALUE _, ...}) = done
	  | find (done, {lexp=INT _, ...}) = done
	  | find (done, {lexp=SELECT (_, expression), ...}) =
	    find (done, expression)
	  | find (done, {lexp=STRUCT expressions, ...}) =
	    Lists.reducel find (done, expressions)
	  | find (done, {lexp=RAISE (expression), ...}) = find (done, expression)
	  | find (done, {lexp=HANDLE (expression, expression'), ...}) =
	    find (find (done, expression), expression')
	  | find (done, {lexp=LETREC (_, expressions, expression'), ...}) =
	    Lists.reducel find (find (done, expression'), expressions)

      in
	Set.list_to_set (find ([], {lexp=expression, size=0}))
      end

    (*  === BUILD EXTERNAL ENVIRONMENT ===
     *
     *  This function calls `external_references' to find out which external
     *  pervasives are actually needed by the expression.  If there are any,
     *  then it makes a new lambda variable which is the pervasive library
     *  structure (obtained by applying LOAD_LIBRARY to its name), then makes
     *  a new lambda variable for each pervasive needed by SELECTing from the
     *  first variable.
     *
     *  The original lambda expression is then transformed by converting the
     *  external pervasives into their equivalent lambda variables, and this
     *  is then wrapped in a LET expression containing the variable
     *  definitions.
     *)

    fun build_external_environment (options, expression) =
      let
	val external_pervasives = external_references (options,expression)

	val _ = Diagnostic.output 1
	  (fn _ =>
	   "Library: External pervasives:" ::
	   (map (fn p => " " ^ Pervasives.print_pervasive p)
	    (Set.set_to_list external_pervasives)))
      in

	(* If there are no external references then there is no need to *)
	(* reference the library at all. *)

	if Set.empty_setp external_pervasives then
	  (NewMap.empty (Pervasives.order,Pervasives.eq),
	   externalise(options, expression, NewMap.empty (Pervasives.order,Pervasives.eq)))
	else

	  let
	    val library_lvar = LambdaTypes.new_LVar()
	    val library_binding =
              let
                open LambdaTypes
              in
                (library_lvar,
		 SELECT
		 ({index = 0, size = 2,selecttype=TUPLE},
		   APP (BUILTIN Pervasives.LOAD_STRING,
			([SCON (Ident.STRING Io.builtin_library_name, NONE)],[]),
			NONE)))
              end

	    fun make_bindings (bindings, map, []) =
	        (bindings, map)
	      | make_bindings (bindings, map, pervasive::pervasives) =
		let
		  val lvar = LambdaTypes.new_LVar()
		  val select =
		    LambdaTypes.SELECT
		    ({index = Pervasives.field_number pervasive,
		      size = Pervasives.nr_fields,
                      selecttype = LambdaTypes.STRUCTURE},
		     LambdaTypes.VAR library_lvar)
(*
                  (* REMOVE BEFORE CHECKING IN *)
                  val select =
                    LambdaTypes.SELECT
                    ({index=0,
                      size=2,
                      selecttype=LambdaTypes.TUPLE},
                     select)
*)
		  val map' =
		    NewMap.define(map, pervasive, lvar)
		in
		  make_bindings ((lvar, select)::bindings,
				 map',
				 pervasives)
		end

	    val (bindings, map) =
	      make_bindings ([], NewMap.empty (Pervasives.order,Pervasives.eq),
			     Set.set_to_list external_pervasives)


            fun wrap_lets (expression, vas) = 
              let
                fun nest ((var,arg),body) = LambdaTypes.LET((var, NONE, arg),body)
              in
                foldl nest expression (rev vas)
              end

	    val expression' =
	      wrap_lets
	      (externalise (options, expression, map), library_binding::bindings)

	    val _ = Diagnostic.output 3
	      (fn _ =>
	       ["Library: Externalised lambda expression:\n",
		LambdaPrint.string_of_lambda expression'])

	  in
	    (map, expression')
	  end

      end

  end

@


1.58.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.58  1998/01/30  09:45:02  johnh
 * [Bug #30326]
 * Merge in change from branch MLWorks_workspace_97
 *
@


1.57
log
@[Bug #20050]
main/io now exports MLWORKS_IO
@
text
@d13 10
d214 1
a214 1
require "io";
@


1.57.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 * Revision 1.57  1997/05/12  16:01:27  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
@


1.57.2.2
log
@[Bug #30326]
@
text
@a12 3
 * Revision 1.57.2.1  1997/09/11  20:56:58  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d208 1
a208 1
require "mlworks_io";
@


1.57.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 4
 * Revision 1.57  1997/05/12  16:01:27  jont
 * [Bug #20050]
 * main/io now exports MLWORKS_IO
 *
@


1.56
log
@Adding Options
@
text
@d13 3
d216 1
a216 1
  structure Io		: IO
@


1.56.1.1
log
@branched from 1.56
@
text
@a12 3
 * Revision 1.56  1997/01/21  11:52:38  matthew
 * Adding Options
 *
@


1.56.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.56.1.1  1997/05/12  10:35:58  hope
 * branched from 1.56
 *
@


1.56.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.56.1.1  1997/05/12  10:35:58  hope
 * branched from 1.56
 *
@


1.56.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.56.1.1  1997/05/12  10:35:58  hope
 * branched from 1.56
 *
@


1.56.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.56.1.1.1.1  1997/07/28  18:21:39  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.55
log
@Simplifications
@
text
@d13 3
d226 2
d295 1
a295 1
   fun externalise (expression, extern_map) =
d300 1
a300 1
          if MachPerv.is_inline pervasive then
d308 2
a309 1
	    if (MachPerv.is_inline pervasive andalso MachPerv.is_fun pervasive) then
d337 1
a337 1
    fun external_references expression =
d342 1
a342 1
	    if MachPerv.is_inline pervasive then
d349 1
a349 1
	    if (MachPerv.is_inline pervasive andalso
d495 1
a495 1
    fun build_external_environment expression =
d497 1
a497 1
	val external_pervasives = external_references expression
d511 1
a511 1
	   externalise(expression, NewMap.empty (Pervasives.order,Pervasives.eq)))
d570 1
a570 1
	      (externalise (expression, map), library_binding::bindings)
@


1.54
log
@moving String from toplevel
@
text
@d13 3
a195 1
require "../lambda/lambdasub";
a207 1
  structure LambdaSub   : LAMBDASUB
d212 2
a213 2
  sharing LambdaSub.LT = LambdaPrint.LambdaTypes = AugLambda.LambdaTypes
  sharing type MachPerv.Pervasives.pervasive = LambdaSub.LT.Primitive
d217 1
a217 1
    structure LambdaTypes = LambdaSub.LT
d234 57
a290 1
    fun externalise (expression, extern_map) =
d294 7
a300 5
	fun externalise' (APP (BUILTIN pervasive, expl, ty)) =
	    if MachPerv.is_inline pervasive then
	      APP (BUILTIN pervasive, map externalise' expl, ty)
	    else
	      APP (VAR (NewMap.apply'(extern_map, pervasive)), map externalise' expl, ty)
d304 1
a304 1
	      externalise' (LambdaSub.eta_abstract 
d310 1
a310 1
	    LambdaSub.apply_one_level externalise' expression
d335 1
a335 1
	fun find (done, APP (BUILTIN pervasive, expl, ty)) =
d338 1
a338 1
                                  expl)
d340 1
a340 1
	      Lists.reducel find (pervasive :: done, expl)
a375 3
	  (* The rest of the cases are uninteresting, except LETREC which is *)
	  (* just cute. *)

d377 1
a377 1
	  | find (done, FN (_, expression,_,_,_)) = find (done, expression)
d380 2
a381 2
	  | find (done, APP (expression, expl, _)) =
	    Lists.reducel find (find (done, expression), expl)
d414 1
a414 1
		  {lexp=APP ({lexp=BUILTIN(pervasive,_), ...}, expl,_),
d417 1
a417 1
                                expl)
d455 2
a456 2
	  | find (done, {lexp=APP (expression, expl,_), ...}) =
	    Lists.reducel find (find (done, expression), expl)
d504 1
a504 1
	  (NewMap.empty (Pervasives.order,Pervasives.eq), Set.empty_set,
d518 1
a518 1
			[SCON (Ident.STRING Io.builtin_library_name, NONE)],
d522 3
a524 3
	    fun make_bindings (bindings, map, lvars, []) =
	        (bindings, map, lvars)
	      | make_bindings (bindings, map, lvars, pervasive::pervasives) =
a546 1
				 lvar::lvars,
d550 2
a551 2
	    val (bindings, map, lvars) =
	      make_bindings ([], NewMap.empty (Pervasives.order,Pervasives.eq), [],
d554 8
d563 1
a563 1
	      LambdaSub.wrap_lets
d572 1
a572 1
	    (map, Set.list_to_set lvars, expression')
@


1.54.4.1
log
@branched from 1.54
@
text
@a12 3
 * Revision 1.54  1996/10/10  02:42:17  io
 * moving String from toplevel
 *
@


1.54.3.1
log
@branched from 1.54
@
text
@a12 3
 * Revision 1.54  1996/10/10  02:42:17  io
 * moving String from toplevel
 *
@


1.54.3.1.1.1
log
@branched from 1.54.3.1
@
text
@a12 3
 * Revision 1.54.3.1  1996/12/17  17:49:25  hope
 * branched from 1.54
 *
@


1.54.2.1
log
@branched from 1.54
@
text
@a12 3
 * Revision 1.54  1996/10/10  02:42:17  io
 * moving String from toplevel
 *
@


1.54.1.1
log
@branched from 1.54
@
text
@a12 3
 * Revision 1.54  1996/10/10  02:42:17  io
 * moving String from toplevel
 *
@


1.54.1.1.1.1
log
@branched from 1.54.1.1
@
text
@a12 3
 * Revision 1.54.1.1  1996/11/14  12:51:37  hope
 * branched from 1.54
 *
@


1.53
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d13 3
a220 2

    open MLWorks.Option
@


1.53.3.1
log
@branched from 1.53
@
text
@a12 3
 * Revision 1.53  1996/02/23  16:19:00  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.53.2.1
log
@branched from 1.53
@
text
@a12 3
 * Revision 1.53  1996/02/23  16:19:00  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.53.1.1
log
@branched from 1.53
@
text
@a12 3
 * Revision 1.53  1996/02/23  16:19:00  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
@


1.52
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d13 3
d188 1
a188 1
require "../utils/newmap";
d201 1
a201 1
  structure NewMap      : NEWMAP
@


1.51
log
@Changes to DebuggerTypes.
@
text
@d13 3
d216 1
d292 1
a292 1
		| find_case (done, (SCON_TAG (Ident.STRING _), expression')) =
d304 1
a304 1
	      fun find_option (done, Option.PRESENT expression) =
d307 1
a307 1
		| find_option (done, Option.ABSENT) = done
d366 1
a366 1
		| find_case (done, (SCON_TAG (Ident.STRING _), expression')) =
d377 1
a377 1
	      fun find_option (done, LambdaTypes.Option.PRESENT expression) =
d380 1
a380 1
		| find_option (done, LambdaTypes.Option.ABSENT) = done
d458 2
a459 2
			[SCON (Ident.STRING Io.builtin_library_name)],
			LambdaTypes.Option.ABSENT)))
@


1.50
log
@Adding module annotations to lambda syntax.
@
text
@d13 3
d182 2
a186 1
require "../lambda/auglambda";
d188 1
d192 1
a192 1
  structure AugLambda   : AUGLAMBDA
d195 2
a199 1
  structure Diagnostic  : DIAGNOSTIC
d208 1
a208 1
    structure NewMap = AugLambda.Debugger_Types.NewMap
a210 1
    structure Diagnostic = Diagnostic
d239 1
a239 1
                             ref(null_type_annotation)))
a241 1

@


1.49
log
@Changes to lambdatypes
@
text
@d13 3
d310 1
a310 1
	  | find (done, LET (_,_, binding,expression)) = 
d318 1
a318 1
	  | find (done, STRUCT expressions) =
d385 1
a385 1
	  | find (done, {lexp=LET (_,_, binding, expression),...}) =
a405 1

d436 2
a437 2
	  (NewMap.empty' Pervasives.order, Set.empty_set,
	   externalise(expression, NewMap.empty' Pervasives.order))
d448 1
a448 1
		 ({index = 0, size = 2},
d462 2
a463 1
		      size = Pervasives.nr_fields},
d465 9
d484 1
a484 1
	      make_bindings ([], NewMap.empty' Pervasives.order, [],
@


1.48
log
@Machine specific functions is_fun and implicit_references moved to machperv
@
text
@d13 3
d307 1
a307 1
	  | find (done, LET (_, binding,expression)) = 
d382 1
a382 1
	  | find (done, {lexp=LET (_, binding, expression),...}) =
@


1.47
log
@Multiple args for functions and applications
@
text
@d13 3
d225 1
a225 1
	    if (MachPerv.is_inline pervasive andalso Pervasives.is_fun pervasive) then
d260 1
a260 1
	      Lists.reducel find ((Pervasives.implicit_references pervasive) @@ done,
d267 2
a268 2
		Pervasives.is_fun pervasive) then
	      (Pervasives.implicit_references pervasive) @@ done
d282 1
a282 1
		      (Pervasives.implicit_references Pervasives.STRINGEQ)
d342 1
a342 1
	    Lists.reducel find ((Pervasives.implicit_references pervasive) @@ done,
d355 1
a355 1
		      Pervasives.implicit_references Pervasives.STRINGEQ
@


1.46
log
@Changed some require paths
@
text
@d13 3
d211 1
a211 1
    fun externalise (expression, map) =
d215 1
a215 1
	fun externalise' (APP (BUILTIN pervasive, expression, ty)) =
d217 1
a217 1
	      APP (BUILTIN pervasive, externalise' expression, ty)
d219 1
a219 1
	      APP (VAR (NewMap.apply'(map, pervasive)), externalise' expression, ty)
d227 1
a227 1
	      VAR (NewMap.apply'(map, pervasive))
d255 1
a255 1
	fun find (done, APP (BUILTIN pervasive, expression, ty)) =
d257 2
a258 2
	      find ((Pervasives.implicit_references pervasive) @@ done,
		    expression)
d260 1
a260 1
	      find (pervasive :: done, expression)
d303 2
a304 2
	  | find (done, APP (expression, expression', _)) =
	    find (find (done, expression), expression')
d337 1
a337 1
		  {lexp=APP ({lexp=BUILTIN(pervasive,_), ...}, expression,_),
d339 2
a340 2
	    find ((Pervasives.implicit_references pervasive) @@ done,
		  expression)
d378 2
a379 2
	  | find (done, {lexp=APP (expression, expression',_), ...}) =
	    find (find (done, expression), expression')
d442 1
a442 1
			SCON (Ident.STRING Io.builtin_library_name),
@


1.45
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d13 4
d169 1
a169 1
require "../machine/machperv";
@


1.44
log
@structure Option.
@
text
@d13 3
d293 1
a293 1
	  | find (done, FN (_, expression,_,_)) = find (done, expression)
d367 1
a367 1
	  | find (done, {lexp=FN (_, expression,_), ...}) =
@


1.44.1.1
log
@Fork for bug fixing
@
text
@a12 3
 *  Revision 1.44  1993/07/29  16:27:44  nosa
 *  structure Option.
 *
@


1.43
log
@Signature revisions
@
text
@d13 3
d215 1
a215 1
                             null_type_annotation))
d277 1
a277 1
	      fun find_option (done, PRESENT expression) =
d280 1
a280 1
		| find_option (done, ABSENT) = done
d301 1
a301 1
	  | find (done, RAISE expression) = find (done, expression)
d350 1
a350 1
	      fun find_option (done, LambdaTypes.PRESENT expression) =
d353 1
a353 1
		| find_option (done, LambdaTypes.ABSENT) = done
d377 1
a377 1
	  | find (done, {lexp=RAISE expression, ...}) = find (done, expression)
d433 1
a433 1
			null_type_annotation)))
@


1.42
log
@Added MLVALUE lambda exp
@
text
@d13 3
d180 1
a180 1
    structure NewMap = LambdaTypes.Datatypes.NewMap
d184 1
a184 1
    structure Ident = LambdaTypes.Datatypes.Ident
@


1.41
log
@Changed explicit manipulation of list representation to use new format.
@
text
@d13 3
d290 1
d365 1
@


1.40
log
@Replaced MachSpec with MachPerv
@
text
@d13 3
d303 1
a303 1
    (*  === EXTRACT IMPLCIT EXTERNAL REFERENCES ===
a419 2
		  SELECT
		  ({index = 1, size = 2},
d422 1
a422 1
			null_type_annotation))))
@


1.39
log
@Minor changes to support the new type of SWITCHes.
@
text
@d13 3
d97 1
a97 1
 *  Moved is_inline function out into MachSpec, which knows the real answers
d150 1
a150 1
require "../machine/machspec";
d161 1
a161 1
  structure MachSpec    : MACHSPEC
d166 1
a166 1
  sharing type MachSpec.Pervasives.pervasive = LambdaSub.LT.Primitive
d169 1
a169 1
    structure Pervasives = MachSpec.Pervasives
d194 1
a194 1
	    if MachSpec.is_inline pervasive then
d200 1
a200 1
	    if (MachSpec.is_inline pervasive andalso Pervasives.is_fun pervasive) then
d234 1
a234 1
	    if MachSpec.is_inline pervasive then
d241 1
a241 1
	    if (MachSpec.is_inline pervasive andalso
@


1.38
log
@removed some redundant bindings
@
text
@d13 3
d244 1
a244 1
	  | find (done, SWITCH (expression, cases, default1, default2)) =
d268 1
a268 4
	      (find_option (find_option (find (done, expression),
                                         default1),
                            default2),
               cases)
d316 1
a316 1
	  | find (done, {lexp=SWITCH (expression, cases, default1, default2),
d340 1
a340 4
	      (find_option (find_option (find (done, expression),
                                         default1),
                            default2),
               cases)
@


1.37
log
@Moved the special names out of the compiler as a whole.
@
text
@d13 3
a141 1
require "../basics/identprint";
a152 1
  structure IdentPrint  : IDENTPRINT
a159 1
  sharing IdentPrint.Ident = LambdaSub.LT.Datatypes.Ident
d169 1
a169 1
    structure Ident = IdentPrint.Ident
a414 14
                 SELECT
                 ({index = 0, size = 1},
                  APP (BUILTIN Pervasives.LOAD_STRING,
                       SCON (Ident.STRING Io.builtin_library_name),
		       null_type_annotation)),
                 "library binding in _library",
                 LambdaTypes.null_type_annotation)
              end

	    val library_binding' =
              let
                open LambdaTypes
              in
                (library_lvar,
d449 1
a449 1
	      (externalise (expression, map), library_binding'::bindings)
@


1.36
log
@Removed some redundant structures and sharing
@
text
@d13 3
d144 1
d156 1
a388 2
    val library_name = "__builtin_library"

d418 1
a418 1
                       SCON (Ident.STRING library_name),
d434 1
a434 1
			SCON (Ident.STRING library_name),
@


1.35
log
@Now uses NewMap instead of Map.
@
text
@d13 3
a133 1
require "../utils/newmap";
a144 1
  structure NewMap      : NEWMAP
d154 1
a154 1
  sharing IdentPrint.Ident = LambdaSub.LT.Ident
a158 1
    structure NewMap = NewMap
d160 1
@


1.34
log
@Type of BUILTIN changed a little.
@
text
@d13 3
a129 1

d131 1
a131 2
require "../utils/map";
require "../utils/set";
a133 1
require "../basics/ident";
a134 2
require "../main/pervasives";
require "../lambda/lambdatypes";
a140 1

d143 1
a143 2
  structure Map         : MAP
  structure Set         : SET
a145 1
  structure Ident       : IDENT
a146 2
  structure Pervasives  : PERVASIVES
  structure LambdaTypes : LAMBDATYPES
d152 4
a155 12
  sharing Set = LambdaTypes.Set

  sharing LambdaTypes = LambdaSub.LT = LambdaPrint.LambdaTypes = AugLambda.LambdaTypes

  sharing Ident = IdentPrint.Ident = LambdaTypes.Ident

  sharing Pervasives = MachSpec.Pervasives

  sharing type Pervasives.pervasive = LambdaTypes.Primitive

) : LIBRARY =

d157 4
a160 4

    structure Map = Map
    structure Set = Set
    structure LambdaTypes = LambdaTypes
d163 1
d185 1
a185 7
	      (APP (VAR (Map.lookup (pervasive, map)), 
		    externalise' expression, ty)
	       handle Map.Lookup =>
		 Crash.impossible
		 ("Library: The pervasive " ^
		  Pervasives.print_pervasive pervasive ^ " is neither " ^
		  "external not in line."))
d188 1
a188 2
	    if (MachSpec.is_inline pervasive andalso
		Pervasives.is_fun pervasive) then
d193 1
a193 6
	      (VAR (Map.lookup (pervasive, map))
	       handle Map.Lookup =>
		 Crash.impossible
		 ("Library: The pervasive " ^
		  Pervasives.print_pervasive pervasive ^ " is neither " ^
		  "external not in line."))
a196 1

a197 1

a198 1

a200 2


d400 2
a401 3
	  (Map.empty_map,
	   Set.empty_set,
	   externalise(expression, Map.empty_map))
d445 1
a445 1
		    Map.add ((pervasive, lvar), map, Pervasives.order)
d454 1
a454 1
	      make_bindings ([], Map.empty_map, [],
@


1.33
log
@null_type_annotation no longer a function
@
text
@d13 3
d336 1
a336 1
		  {lexp=APP ({lexp=BUILTIN pervasive, ...}, expression,_),
@


1.32
log
@Added LET constructor and new slot to APP.
@
text
@d13 3
d208 2
a209 1
                            (expression,"Builtin function " ^ Pervasives.print_pervasive pervasive))
d444 1
a444 1
		       null_type_annotation())),
d446 1
a446 1
                 LambdaTypes.null_type_annotation())
d460 1
a460 1
			null_type_annotation()))))
@


1.31
log
@Added type annotation information at application points
@
text
@d13 3
d189 1
a189 1
	fun externalise' (APP (BUILTIN pervasive, expression)) =
d191 1
a191 1
	      APP (BUILTIN pervasive, externalise' expression)
d193 2
a194 1
	      (APP (VAR (Map.lookup (pervasive, map)), externalise' expression)
d245 1
a245 1
	fun find (done, APP (BUILTIN pervasive, expression)) =
d294 3
a296 1
	  | find (done, APP (expression, expression')) =
d371 2
d439 2
a440 1
                       SCON (Ident.STRING library_name))),
d455 2
a456 3
			SCON (Ident.STRING library_name)))),
                 "library binding in _library",
                 LambdaTypes.null_type_annotation())
d472 1
a472 2
		  make_bindings ((lvar, select,"make_bindings in _library",
                                  LambdaTypes.null_type_annotation())::bindings,
d498 1
@


1.30
log
@Added an annotation slot to HANDLE
@
text
@d13 3
d323 1
a323 1
		  {lexp=APP ({lexp=BUILTIN pervasive, ...}, expression),
d365 1
a365 1
	  | find (done, {lexp=APP (expression, expression'), ...}) =
@


1.29
log
@Made changes as LET now has a string annotation
@
text
@d13 3
d295 1
a295 1
	  | find (done, HANDLE (expression, expression')) =
@


1.28
log
@changed to produce lists as compilation units instead of tuples
@
text
@d13 3
d283 1
a283 1
	  | find (done, FN (_, expression,_)) = find (done, expression)
d426 2
a427 1
                 "library binding in _library")
d441 2
a442 1
                 "library binding in _library")
d458 2
a459 1
		  make_bindings ((lvar, select,"make_bindings in _library")::bindings,
@


1.27
log
@Modified to use augmented lambda calculus
@
text
@d13 3
d426 14
d465 1
a465 1
	      (externalise (expression, map), library_binding::bindings)
@


1.26
log
@First version of the profiler
@
text
@d13 3
d119 1
d124 1
a124 1

d140 1
a140 1
  sharing LambdaTypes = LambdaSub.LT = LambdaPrint.LambdaTypes
d155 1
d305 1
d308 1
a308 1
	open LambdaTypes
d310 3
a312 1
	fun find (done, APP (BUILTIN pervasive, expression)) =
d316 2
a317 1
	  | find (done, SWITCH (expression, cases, default1, default2)) =
d334 1
a334 1
	      fun find_option (done, PRESENT expression) =
d337 1
a337 1
		| find_option (done, ABSENT) = done
d349 5
a353 4
	  | find (done, BUILTIN pervasive) = done
	  | find (done, VAR _) = done
	  | find (done, FN (_, expression,_)) = find (done, expression)
	  | find (done, APP (expression, expression')) =
d355 5
a359 4
	  | find (done, SCON _) = done
	  | find (done, INT _) = done
	  | find (done, SELECT (_, expression)) = find (done, expression)
	  | find (done, STRUCT expressions) =
d361 2
a362 2
	  | find (done, RAISE expression) = find (done, expression)
	  | find (done, HANDLE (expression, expression')) =
d364 1
a364 1
	  | find (done, LETREC (_, expressions, expression')) =
d368 1
a368 1
	Set.list_to_set (find ([], expression))
a369 1

@


1.25
log
@New pervasive library code
@
text
@d13 3
d183 2
a184 1
	      externalise' (LambdaSub.eta_abstract expression)
d272 1
a272 1
	  | find (done, FN (_, expression)) = find (done, expression)
d342 1
a342 1
	  | find (done, FN (_, expression)) = find (done, expression)
d409 2
a410 1
                       SCON (Ident.STRING library_name))))
d426 1
a426 1
		  make_bindings ((lvar, select)::bindings,
@


1.24
log
@Made sure eta abstraction on builtins occurs even when there are
no external references
@
text
@d13 4
d373 1
a373 1
    val library_name = "__pervasive_library"
@


1.23
log
@Removed extra set of lambda bindings wrapped around expression in
build_external_environment.
@
text
@d13 4
d388 1
a388 1
	   expression)
@


1.22
log
@Fixed bug whereby the switch expression was not analysed for
external references.
@
text
@d12 5
a16 1
 *  $Log:	_library.sml,v $
d433 1
a433 3
	    (map,
	     Set.list_to_set lvars,
	     LambdaSub.wrap_lets (expression', library_binding::bindings))
@


1.21
log
@Removed redundant `.mo' extension from the name of the pervasive
library.
@
text
@d13 4
d161 1
a161 1
		 ("Lambda: The pervasive " ^
d173 1
a173 1
		 ("Lambda: The pervasive " ^
d246 4
a249 1
	      (find_option (find_option (done, default1), default2), cases)
d315 4
a318 1
	      (find_option (find_option (done, default1), default2), cases)
@


1.20
log
@Added an extra SELECT operation on the pervasive library so
that this can be a structure rather than a set of top-level
declarations.  This means it gets sorted correctly by the
compiler.
@
text
@d13 6
d351 1
a351 1
    val library_name = "__pervasive_library.mo"
@


1.19
log
@Completely reimplemented this module, tidied it up, and documented it.
The functions provided have changed quite a bit.
@
text
@d13 4
d345 1
a345 1
    val library_name = "__pervasive_library"
d370 9
a378 3
	      (library_lvar,
	       LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.LOAD_STRING,
				LambdaTypes.SCON (Ident.STRING library_name)))
@


1.18
log
@Fixed builtin_implicit_set so as to know about builtins which will be
eta_abstracted. Also tidied up remnants of old CALL_C stuff.
@
text
@d1 72
a72 6
(* _library.sml the functor *)
(*
$Log:	_library.sml,v $
Revision 1.17  91/11/15  14:13:57  richard
Changed the ordering on pervasive symbols to work on the library names
rather than on the printing names.
a73 3
Revision 1.16  91/11/14  17:08:10  jont
Eta abstracted builtin functions where they aren't applied so they
can be inline generated. Required by Pervasives
d75 13
a87 2
Revision 1.15  91/11/12  16:57:09  jont
Moved is_inline function out into MachSpec, which knows the real answers
a88 3
Revision 1.14  91/10/29  14:57:35  jont
Added reference to existence of machine level div, mod, * for determining
whether to inline various primitives
d90 1
a90 2
Revision 1.13  91/10/22  18:27:34  davidt
The structure LambdaSub.LambdaTypes is now called LambdaSub.LT
d92 12
a103 2
Revision 1.12  91/10/22  16:53:23  davidt
Replaced impossible exception with call to Crash.impossible.
d105 1
a105 2
Revision 1.11  91/10/16  16:19:01  jont
Added CALL_C to result of prims_in_le
d107 1
a107 2
Revision 1.10  91/10/15  13:59:29  jont
Added stuff to do with CALL_C required for garbage collection.
d109 1
a109 3
Revision 1.9  91/10/09  15:20:30  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.
d111 1
a111 2
Revision 1.8  91/10/08  11:50:01  jont
Changed use of lambdasub.number_from to lists.number_from_by_one
d113 1
a113 3
Revision 1.7  91/09/24  15:41:14  jont
Fixed bug whereby chr -> Chr and ord -> Ord correspondences were left
out. Alos corrected exception raised by mod
d115 1
a115 2
Revision 1.6  91/09/24  13:01:33  davida
Fixed bug in add_pervasive_refs function.
d117 1
a117 2
Revision 1.5  91/09/23  12:30:08  jont
Added stuff to deal with implicit exceptions (eg from ADDV)
d119 4
a122 2
Revision 1.4  91/09/18  11:29:30  jont
Fixed bug whereby builtin exceptions weren't visible
a123 2
Revision 1.3  91/09/16  16:43:40  jont
Corrected spelling of _make_new_unique
d125 10
a134 2
Revision 1.2  91/09/09  13:34:15  davida
Changed to use reduce_left from Lists, not LambdaSub.
d136 3
a138 2
Revision 1.1  91/09/05  11:00:38  jont
Initial revision
d140 10
a149 2
Copyright (c) 1991 Harlequin Ltd.
*)
d151 11
a161 14
require "../utils/map";
require "../utils/set";
require "../utils/lists";
require "../utils/crash";
require "../basics/symbol";
require "../basics/ident";
require "../main/primitives";
require "../main/pervasives";
require "../lambda/lambdatypes";
require "../lambda/environtypes";
require "../lambda/environ";
require "../lambda/lambdasub";
require "../machine/machspec";
require "library";
d163 2
a164 14
functor Library(
  structure Map : MAP
  structure Set : SET
  structure Lists : LISTS
  structure Crash : CRASH
  structure Symbol : SYMBOL
  structure Ident : IDENT
  structure Primitives : PRIMITIVES
  structure Pervasives : PERVASIVES
  structure LambdaTypes : LAMBDATYPES
  structure EnvironTypes : ENVIRONTYPES
  structure Environ : ENVIRON
  structure LambdaSub : LAMBDASUB
  structure MachSpec : MACHSPEC
d166 1
a166 19
  sharing LambdaTypes = EnvironTypes.LambdaTypes = LambdaSub.LT =
    Environ.LambdaTypes = Primitives.LambdaTypes
  sharing EnvironTypes = Environ.EnvironTypes = Primitives.EnvironTypes
  sharing Map = EnvironTypes.Map = Environ.Map
  sharing Set = LambdaSub.Set = Environ.Set = Primitives.Set
  sharing Ident = LambdaTypes.Ident = Environ.Ident = EnvironTypes.Ident
  sharing Symbol = Ident.Symbol
  sharing Pervasives = MachSpec.Pervasives
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
) : LIBRARY =
struct
  structure Map = Map
  structure Set = Set
  structure LambdaTypes = LambdaTypes
  val load_string =
    case Environ.lookup_valid(Ident.VAR(Symbol.find_symbol"_load_string"),
					Primitives.initial_env) of
      EnvironTypes.PRIM prim => prim
    | _ => Crash.impossible "_load_string not prim"
d168 1
a168 19
  val prims_to_exns =
    [(Pervasives.INTPLUS, Pervasives.EXSUM),
      (Pervasives.INTSTAR, Pervasives.EXPROD),
      (Pervasives.INTMINUS, Pervasives.EXDIFF),
      (Pervasives.INTUMINUS, Pervasives.EXNEG),
      (Pervasives.INTABS, Pervasives.EXABS),
      (Pervasives.REALPLUS, Pervasives.EXSUM),
      (Pervasives.REALSTAR, Pervasives.EXPROD),
      (Pervasives.REALMINUS, Pervasives.EXDIFF),
      (Pervasives.REALUMINUS, Pervasives.EXNEG),
      (Pervasives.DIV, Pervasives.EXQUOT),
      (Pervasives.MOD, Pervasives.EXMOD),
      (Pervasives.REALABS, Pervasives.EXABS),
      (Pervasives.FLOOR, Pervasives.EXFLOOR),
      (Pervasives.SQRT, Pervasives.EXSQRT),
      (Pervasives.EXP, Pervasives.EXEXP),
      (Pervasives.LN, Pervasives.EXLN),
      (Pervasives.ORD, Pervasives.EXORD),
      (Pervasives.CHR, Pervasives.EXCHR)]
d170 1
a170 1
  val prims_with_exn = map #1 prims_to_exns
a171 3
  fun prim_order(a, b) =
    Symbol.symbol_order(Symbol.find_symbol(Pervasives.library_name a),
			Symbol.find_symbol(Pervasives.library_name b))
a172 19
  fun add_pervasive_refs(lambda_exp, prim_to_lambda, bindings) =
    let
      fun subst_ext_prims(le as
			  LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
	if MachSpec.is_inline prim
	  then
	    LambdaTypes.APP(LambdaTypes.BUILTIN prim, subst_ext_prims le')
	else
	  LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda)),
			  subst_ext_prims le')
      | subst_ext_prims(le as LambdaTypes.BUILTIN prim) =
	if Pervasives.is_fun prim then
	  subst_ext_prims(LambdaSub.eta_abstract le)
	else
	  LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda))
      | subst_ext_prims le = LambdaSub.apply_one_level subst_ext_prims le
    in
      LambdaSub.wrap_lets(subst_ext_prims lambda_exp, bindings)
    end
d174 15
a188 1
  fun prim_to_exn prim = Lists.assoc(prim, prims_to_exns)
d190 62
a251 68
  fun builtin_implicit prim =
    if MachSpec.is_inline prim andalso Lists.member(prim, prims_with_exn) then
      Set.singleton(Lists.assoc(prim, prims_to_exns))
    else
      Set.empty_set
    
  fun builtin_external_set(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
    let
      val simple_externals =
		  if MachSpec.is_inline prim then
		    builtin_implicit prim
		  else
		    Set.singleton prim
(*
	Set.union(
		  if MachSpec.is_inline prim
		    then Set.empty_set
		  else
		    Set.singleton prim,
		    builtin_implicit prim)
      val call_c_externals = case le of
	LambdaTypes.STRUCT le_list =>
	  Lists.reducel
	  Set.union
	  (Set.empty_set, map builtin_external_set le_list)
      | _ => builtin_external_set le
*)
    in
      Set.union(simple_externals, builtin_external_set le)
    end
    (* Ensure exception names are also included where needed *)
  | builtin_external_set(LambdaTypes.BUILTIN prim) =
    if Pervasives.is_fun prim andalso MachSpec.is_inline prim then
      builtin_implicit prim
    else
      Set.singleton prim
  | builtin_external_set(LambdaTypes.APP(le, le')) =
    Set.union(builtin_external_set le, builtin_external_set le')
  | builtin_external_set(LambdaTypes.FN(_, le)) = builtin_external_set le
  | builtin_external_set(LambdaTypes.SELECT(_, le)) = builtin_external_set le
  | builtin_external_set(LambdaTypes.RAISE le) = builtin_external_set le
  | builtin_external_set(LambdaTypes.HANDLE(le, le')) =
    Set.union(builtin_external_set le, builtin_external_set le')
  | builtin_external_set(LambdaTypes.STRUCT le_list) =
    Lists.reducel
    Set.union
    (Set.empty_set, map builtin_external_set le_list)
  | builtin_external_set(LambdaTypes.SWITCH(le, tag_le_list, opt1, opt2)) =
    let
      fun b_e_sub(LambdaTypes.EXP_TAG le, le') =
	Set.union(builtin_external_set le, builtin_external_set le')
      | b_e_sub(LambdaTypes.SCON_TAG(Ident.STRING _), le) =
	Set.add_member(Pervasives.STRINGEQ, builtin_external_set le)
      | b_e_sub(_, le) = builtin_external_set le
      fun b_e_opt(LambdaTypes.PRESENT le) = builtin_external_set le
      | b_e_opt LambdaTypes.ABSENT = Set.empty_set
    in
      Lists.reducel
      Set.union
      (Set.union(builtin_external_set le,
	Set.union(b_e_opt opt1, b_e_opt opt2)), map b_e_sub tag_le_list)
    end
  | builtin_external_set(LambdaTypes.LETREC(_, le_list, le)) =
    Lists.reducel Set.union
    (builtin_external_set le, map builtin_external_set le_list)
  | builtin_external_set(LambdaTypes.SCON _) = Set.empty_set
  | builtin_external_set(LambdaTypes.INT _) = Set.empty_set
  | builtin_external_set(LambdaTypes.VAR _) = Set.empty_set
d253 66
a318 33
  fun builtin_implicit_set(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
    Set.union(builtin_implicit prim, builtin_implicit_set le)
  | builtin_implicit_set(LambdaTypes.BUILTIN prim) = Set.empty_set
  | builtin_implicit_set(LambdaTypes.APP(le, le')) =
    Set.union(builtin_implicit_set le, builtin_implicit_set le')
  | builtin_implicit_set(LambdaTypes.FN(_, le)) = builtin_implicit_set le
  | builtin_implicit_set(LambdaTypes.SELECT(_, le)) = builtin_implicit_set le
  | builtin_implicit_set(LambdaTypes.RAISE le) = builtin_implicit_set le
  | builtin_implicit_set(LambdaTypes.HANDLE(le, le')) =
    Set.union(builtin_implicit_set le, builtin_implicit_set le')
  | builtin_implicit_set(LambdaTypes.STRUCT le_list) =
    Lists.reducel
    Set.union
    (Set.empty_set, map builtin_implicit_set le_list)
  | builtin_implicit_set(LambdaTypes.SWITCH(le, tag_le_list, opt1, opt2)) =
    let
      fun b_e_sub(LambdaTypes.EXP_TAG le, le') =
	Set.union(builtin_implicit_set le, builtin_implicit_set le')
      | b_e_sub(_, le) = builtin_implicit_set le
      fun b_e_opt(LambdaTypes.PRESENT le) = builtin_implicit_set le
      | b_e_opt LambdaTypes.ABSENT = Set.empty_set
    in
      Lists.reducel
      Set.union
      (Set.union(builtin_implicit_set le,
	Set.union(b_e_opt opt1, b_e_opt opt2)), map b_e_sub tag_le_list)
    end
  | builtin_implicit_set(LambdaTypes.LETREC(_, le_list, le)) =
    Lists.reducel Set.union
    (builtin_implicit_set le, map builtin_implicit_set le_list)
  | builtin_implicit_set(LambdaTypes.SCON _) = Set.empty_set
  | builtin_implicit_set(LambdaTypes.INT _) = Set.empty_set
  | builtin_implicit_set(LambdaTypes.VAR _) = Set.empty_set
d320 3
a322 2
  fun prims_in_le le =
    Set.setdiff(builtin_external_set le, Set.singleton load_string)
d324 86
a409 95
  fun get_env_and_bindings le =
  let
    val prims = prims_in_le le
(*
    val _ = print"Builtin external"
    val _ = map (print o Pervasives.print_pervasive) (Set.set_to_list prims)
*)
    val prims' = Set.list_to_set(map EnvironTypes.PRIM (Set.set_to_list prims))
    val EnvironTypes.ENV(initial_val_env, initial_excon_env, _) =
      Primitives.initial_env
    val initial_val_domain = Map.domain initial_val_env
    val initial_excon_domain = Map.domain initial_excon_env
(*
    val initial_domain = initial_val_domain @@ initial_excon_domain
*)
    fun new_domain(lookup, initial) =
      Set.set_to_list(
      Lists.reducel
      Set.union
      (Set.empty_set,
        map
	(fn x =>
	  if Set.is_member(lookup(x, Primitives.initial_env),
			   prims') then
	    Set.singleton x
	  else Set.empty_set)
	initial))
    val new_val_domain = new_domain(Environ.lookup_valid, initial_val_domain)
    val new_excon_domain = new_domain(Environ.lookup_exn, initial_excon_domain)
(*
    val _ = print("new val domain size " ^ Integer.makestring(length new_val_domain))
    val _ = print("new excon domain size " ^ Integer.makestring(length new_excon_domain))
*)
    val (numbered_val_env_fn, next) =
      Lists.number_with_size(initial_val_domain, 0, EnvironTypes.FIELD)
    val (numbered_excon_env_fn, size) =
      Lists.number_with_size(initial_excon_domain, next, EnvironTypes.FIELD)
    val numbered_val_env = numbered_val_env_fn size
    val numbered_excon_env = numbered_excon_env_fn size
    val field_val_map =
      Lists.reducel
      (fn (x, y) => Environ.add_valid_env(y, x))
      (Environ.empty_env, numbered_val_env)
    val field_excon_map =
      Lists.reducel
      (fn (x, y) => Environ.add_exn_env(y, x))
      (Environ.empty_env, numbered_excon_env)
    val prim_field_list =
      (map
      (fn x => (Environ.lookup_valid(x, Primitives.initial_env),
		Environ.lookup_valid(x, field_val_map)))
      new_val_domain) @@
      (map
      (fn x => (Environ.lookup_exn(x, Primitives.initial_env),
		Environ.lookup_exn(x, field_excon_map)))
      new_excon_domain)
(*
    val _ = print("prim field list size " ^ Integer.makestring(length prim_field_list))
*)
    val fields_to_lambdas =
      map (fn (_, x) => (x, LambdaTypes.new_LVar()))
      prim_field_list
(*
    val _ = print("fields to lambdas size " ^ Integer.makestring(length fields_to_lambdas))
*)
    val prims_to_lambdas =
      map (fn ((x, y), (z, t)) => if (y = z) then (x, t)
	   else Crash.impossible "prims_to_lambdas")
      (Lists.zip(prim_field_list, fields_to_lambdas))
    val outer_lambda = LambdaTypes.new_LVar()
    val selects =
      map
      (fn (EnvironTypes.FIELD x, y) =>
        (y,
	  LambdaTypes.SELECT(x, LambdaTypes.VAR outer_lambda))
      | _ => Crash.impossible "non_field in fields_to_lambdas")
      fields_to_lambdas
    val prim_env =
      Lists.reducel 
      (fn (x, (EnvironTypes.PRIM y, z)) =>
        Map.add((y, z), x, prim_order)
      | _ => Crash.impossible "Non-prim in initial_field_env")
      (Map.empty_map, prims_to_lambdas)
    val lambda_env =
      Lists.reducel 
      (fn (x, (EnvironTypes.PRIM y, z)) =>
        Map.add((z, y), x, LambdaTypes.LVar_order)
      | _ => Crash.impossible "Non-prim in initial_field_env")
      (Map.empty_map, prims_to_lambdas)
  in
    (prim_env,
     lambda_env,
     (outer_lambda,
      LambdaTypes.APP(LambdaTypes.BUILTIN load_string,
		      LambdaTypes.SCON(Ident.STRING"/library"))) :: selects)
a410 2

end
@


1.17
log
@Changed the ordering on pervasive symbols to work on the library names
rather than on the printing names.
@
text
@d4 4
a138 94
(*
  fun is_inline Pervasives.REF = true
  | is_inline Pervasives.EXABS = false
  | is_inline Pervasives.EXORD = false
  | is_inline Pervasives.EXCHR = false
  | is_inline Pervasives.EXDIV = false
  | is_inline Pervasives.EXMOD = false
  | is_inline Pervasives.EXQUOT = false
  | is_inline Pervasives.EXPROD = false
  | is_inline Pervasives.EXNEG = false
  | is_inline Pervasives.EXSUM = false
  | is_inline Pervasives.EXDIFF = false
  | is_inline Pervasives.EXFLOOR = false
  | is_inline Pervasives.EXSQRT = false
  | is_inline Pervasives.EXEXP = false
  | is_inline Pervasives.EXLN = false
  | is_inline Pervasives.EXIO = false
  | is_inline Pervasives.EXMATCH = false
  | is_inline Pervasives.EXBIND = false
  | is_inline Pervasives.EXINTERRUPT = false
  | is_inline Pervasives.MAP = false
  | is_inline Pervasives.REV = false
  | is_inline Pervasives.NOT = true
  | is_inline Pervasives.ABS = true
  | is_inline Pervasives.FLOOR = true
  | is_inline Pervasives.REAL = true
  | is_inline Pervasives.SQRT = true
  | is_inline Pervasives.SIN = true
  | is_inline Pervasives.COS = true
  | is_inline Pervasives.ARCTAN = true
  | is_inline Pervasives.EXP = true
  | is_inline Pervasives.LN = true
  | is_inline Pervasives.SIZE = true
  | is_inline Pervasives.CHR = true
  | is_inline Pervasives.ORD = true
  | is_inline Pervasives.EXPLODE = false
  | is_inline Pervasives.IMPLODE = false
  | is_inline Pervasives.DEREF = true
  | is_inline Pervasives.FDIV = true
  | is_inline Pervasives.DIV = MachSpec.has_div
  | is_inline Pervasives.MOD = MachSpec.has_mod
  | is_inline Pervasives.PLUS = false
  | is_inline Pervasives.STAR = false
  | is_inline Pervasives.MINUS = false
  | is_inline Pervasives.HAT = false
  | is_inline Pervasives.AT = false
  | is_inline Pervasives.NE = false
  | is_inline Pervasives.LESS = false
  | is_inline Pervasives.GREATER = false
  | is_inline Pervasives.LESSEQ = false
  | is_inline Pervasives.GREATEREQ = false
  | is_inline Pervasives.BECOMES = true
  | is_inline Pervasives.O = true
  | is_inline Pervasives.UMINUS = false
  | is_inline Pervasives.EQ = false
  | is_inline Pervasives.STD_IN = true
  | is_inline Pervasives.STD_OUT = true
  | is_inline Pervasives.OPEN_IN = false
  | is_inline Pervasives.OPEN_OUT = false
  | is_inline Pervasives.INPUT = false
  | is_inline Pervasives.LOOKAHEAD = false
  | is_inline Pervasives.CLOSE_IN = false
  | is_inline Pervasives.END_OF_STREAM = false
  | is_inline Pervasives.OUTPUT = false
  | is_inline Pervasives.CLOSE_OUT = false
  | is_inline Pervasives.MAKE_NEW_UNIQUE = false
  | is_inline Pervasives.LOAD_STRING = true
  | is_inline Pervasives.REALPLUS = true
  | is_inline Pervasives.INTPLUS = true
  | is_inline Pervasives.REALSTAR = true
  | is_inline Pervasives.INTSTAR = MachSpec.has_mul
  | is_inline Pervasives.REALMINUS = true
  | is_inline Pervasives.INTMINUS = true
  | is_inline Pervasives.REALUMINUS = true
  | is_inline Pervasives.INTUMINUS = true
  | is_inline Pervasives.INTLESS = true
  | is_inline Pervasives.REALLESS = true
  | is_inline Pervasives.INTGREATER = true
  | is_inline Pervasives.REALGREATER = true
  | is_inline Pervasives.INTLESSEQ = true
  | is_inline Pervasives.REALLESSEQ = true
  | is_inline Pervasives.INTGREATEREQ = true
  | is_inline Pervasives.REALGREATEREQ = true
  | is_inline Pervasives.INTEQ = true
  | is_inline Pervasives.INTNE = true
  | is_inline Pervasives.REALEQ = true
  | is_inline Pervasives.REALNE = true
  | is_inline Pervasives.STRINGEQ = false
  | is_inline Pervasives.STRINGNE = false
  | is_inline Pervasives.INTABS = true
  | is_inline Pervasives.REALABS = true
  | is_inline Pervasives.CALL_C = false
*)

d140 18
a157 20
    if length bindings <= 1 then lambda_exp
    else
      let
	fun subst_ext_prims(le as
			    LambdaTypes.APP(LambdaTypes.BUILTIN prim, le')) =
	  if MachSpec.is_inline prim
	    then
	      LambdaTypes.APP(LambdaTypes.BUILTIN prim, subst_ext_prims le')
	  else
	    LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda)),
			    subst_ext_prims le')
	| subst_ext_prims(le as LambdaTypes.BUILTIN prim) =
	  if Pervasives.is_fun prim then
	    subst_ext_prims(LambdaSub.eta_abstract le)
	  else
	    LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda))
	| subst_ext_prims le = LambdaSub.apply_one_level subst_ext_prims le
      in
	LambdaSub.wrap_lets(subst_ext_prims lambda_exp, bindings)
      end
d170 5
d187 1
d189 1
a189 1
      Set.union(simple_externals, call_c_externals)
d192 5
a196 1
  | builtin_external_set(LambdaTypes.BUILTIN prim) = Set.singleton prim
d199 1
a199 2
  | builtin_external_set(LambdaTypes.FN(_, le)) =
    Set.add_member(Pervasives.CALL_C, builtin_external_set le)
d207 1
a207 1
    (Set.singleton Pervasives.CALL_C, map builtin_external_set le_list)
d224 2
a225 3
    Set.add_member(Pervasives.CALL_C,
		   Lists.reducel Set.union
		   (builtin_external_set le, map builtin_external_set le_list))
d265 1
a265 2
    Set.setdiff(Set.add_member(Pervasives.CALL_C, builtin_external_set le),
		Set.singleton load_string)
@


1.16
log
@Eta abstracted builtin functions where they aren't applied so they
can be inline generated. Required by Pervasives
@
text
@d4 4
d132 2
a133 2
    Symbol.symbol_order(Symbol.find_symbol(Pervasives.print_pervasive a),
			Symbol.find_symbol(Pervasives.print_pervasive b))
@


1.15
log
@Moved is_inline function out into MachSpec, which knows the real answers
@
text
@d4 3
d237 5
a241 2
	| subst_ext_prims(LambdaTypes.BUILTIN prim) =
	  LambdaTypes.VAR(Map.lookup(prim, prim_to_lambda))
@


1.14
log
@Added reference to existence of machine level div, mod, * for determining
whether to inline various primitives
@
text
@d4 4
d89 1
d128 1
d220 1
d228 1
a228 1
	  if is_inline prim
d244 1
a244 1
    if is_inline prim andalso Lists.member(prim, prims_with_exn) then
d253 1
a253 1
		  if is_inline prim
@


1.13
log
@The structure LambdaSub.LambdaTypes is now called LambdaSub.LT
@
text
@d4 3
d60 1
d76 1
d161 2
a162 2
  | is_inline Pervasives.DIV = true
  | is_inline Pervasives.MOD = true
d192 1
a192 1
  | is_inline Pervasives.INTSTAR = true
d237 1
a237 1
    if Lists.member(prim, prims_with_exn) then
d412 2
a413 2
  in
    (Lists.reducel 
d417 11
a427 2
      (Map.empty_map, prims_to_lambdas),
    (outer_lambda,
@


1.12
log
@Replaced impossible exception with call to Crash.impossible.
@
text
@d4 3
d73 1
a73 1
  sharing LambdaTypes = EnvironTypes.LambdaTypes = LambdaSub.LambdaTypes =
@


1.11
log
@Added CALL_C to result of prims_in_le
@
text
@d4 3
d45 1
d60 1
d87 1
a87 1
    | _ => raise(LambdaTypes.impossible"_load_string not prim")
d394 1
a394 1
	   else raise(LambdaTypes.impossible"prims_to_lambdas"))
d402 1
a402 1
      | _ => raise(LambdaTypes.impossible"non_field in fields_to_lambdas"))
d408 1
a408 1
      | _ => raise(LambdaTypes.impossible"Non-prim in initial_field_env"))
@


1.10
log
@Added stuff to do with CALL_C required for garbage collection.
@
text
@d4 3
d319 2
a320 1
    Set.setdiff(builtin_external_set le, Set.singleton load_string)
@


1.9
log
@Made changes due to record selection now requiring both the total
size of the record as well as the index.
@
text
@d4 4
d197 1
d207 1
a207 1
	      LambdaTypes.APP(LambdaTypes.BUILTIN prim,subst_ext_prims le')
d209 1
a209 1
	    LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim,prim_to_lambda)),
d227 17
a243 6
    Set.union(
	      Set.union(if is_inline prim
			  then Set.empty_set
			else
			  Set.singleton prim, builtin_external_set le),
	      builtin_implicit prim)
d248 2
a249 1
  | builtin_external_set(LambdaTypes.FN(_, le)) = builtin_external_set le
d257 1
a257 1
    (Set.empty_set, map builtin_external_set le_list)
d274 3
a276 2
    Lists.reducel Set.union
    (builtin_external_set le, map builtin_external_set le_list)
d282 1
a282 1
    builtin_implicit prim
@


1.8
log
@Changed use of lambdasub.number_from to lists.number_from_by_one
@
text
@d4 3
d333 6
a338 6
    val (numbered_val_env, next) =
      Lists.number_from_by_one(initial_val_domain, 0,
			    EnvironTypes.FIELD o LambdaTypes.toField)
    val (numbered_excon_env, _) =
      Lists.number_from_by_one(initial_excon_domain, next,
			    EnvironTypes.FIELD o LambdaTypes.toField)
@


1.7
log
@Fixed bug whereby chr -> Chr and ord -> Ord correspondences were left
out. Alos corrected exception raised by mod
@
text
@d4 4
d331 1
a331 1
      LambdaSub.number_from(initial_val_domain, 0,
d334 1
a334 1
      LambdaSub.number_from(initial_excon_domain, next,
@


1.6
log
@Fixed bug in add_pervasive_refs function.
@
text
@d4 3
a74 2
      (Pervasives.DIV, Pervasives.EXQUOT),
      (Pervasives.MOD, Pervasives.EXPROD),
d81 1
a81 1
      (Pervasives.MOD, Pervasives.EXPROD),
d86 3
a88 1
      (Pervasives.LN, Pervasives.EXLN )]
@


1.5
log
@Added stuff to deal with implicit exceptions (eg from ADDV)
@
text
@d4 3
d192 1
a192 2
	      LambdaTypes.APP(LambdaTypes.BUILTIN prim,
			      LambdaSub.apply_one_level subst_ext_prims le')
d194 2
a195 3
	    LambdaTypes.APP(LambdaTypes.VAR(Map.lookup(prim,
						       prim_to_lambda)),
			    LambdaSub.apply_one_level subst_ext_prims le')
@


1.4
log
@Fixed bug whereby builtin exceptions weren't visible
@
text
@d4 3
d64 22
d202 8
d211 7
a217 4
    Set.union(if is_inline prim
		then Set.empty_set
	      else
		Set.singleton prim, builtin_external_set le)
d251 34
@


1.3
log
@Corrected spelling of _make_new_unique
@
text
@d4 3
d66 18
a83 18
  | is_inline Pervasives.EXABS = true
  | is_inline Pervasives.EXORD = true
  | is_inline Pervasives.EXCHR = true
  | is_inline Pervasives.EXDIV = true
  | is_inline Pervasives.EXMOD = true
  | is_inline Pervasives.EXQUOT = true
  | is_inline Pervasives.EXPROD = true
  | is_inline Pervasives.EXNEG = true
  | is_inline Pervasives.EXSUM = true
  | is_inline Pervasives.EXDIFF = true
  | is_inline Pervasives.EXFLOOR = true
  | is_inline Pervasives.EXSQRT = true
  | is_inline Pervasives.EXEXP = true
  | is_inline Pervasives.EXLN = true
  | is_inline Pervasives.EXIO = true
  | is_inline Pervasives.EXMATCH = true
  | is_inline Pervasives.EXBIND = true
  | is_inline Pervasives.EXINTERRUPT = true
d172 1
a172 1
	  | subst_ext_prims le = LambdaSub.apply_one_level subst_ext_prims le
d222 4
d227 8
a234 3
    val EnvironTypes.ENV(initial_env_map, _, _) = Primitives.initial_env
    val initial_domain = Map.domain initial_env_map
    val new_domain =
d241 1
a241 1
	  if Set.is_member(Environ.lookup_valid(x, Primitives.initial_env),
d245 9
a253 3
	initial_domain))
    val (numbered_env, _) =
      LambdaSub.number_from(initial_domain, 0,
d255 4
a258 1
    val field_map =
d261 5
a265 1
      (Environ.empty_env, numbered_env)
d267 1
a267 1
      map
d269 9
a277 2
		Environ.lookup_valid(x, field_map)))
      new_domain
d281 3
@


1.2
log
@Changed to use reduce_left from Lists, not LambdaSub.
@
text
@d4 3
d126 1
a126 1
  | is_inline Pervasives.MAKE_NEW_UNQIUE = false
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d185 1
a185 1
    LambdaSub.reduce_left
d198 1
a198 1
      LambdaSub.reduce_left
d204 1
a204 1
    LambdaSub.reduce_left Set.union
d221 1
a221 1
      LambdaSub.reduce_left
d235 1
a235 1
      LambdaSub.reduce_left
d259 1
a259 1
    (LambdaSub.reduce_left
@
