head	1.59;
access;
symbols
	MLW_daveb_inline_1_4_99:1.59.1
	MLWorks_21c0_1999_03_25:1.59
	MLWorks_20c1_1998_08_20:1.58
	MLWorks_20c0_1998_08_04:1.58
	MLWorks_20b2c2_1998_06_19:1.58
	MLWorks_20b2_Windows_1998_06_12:1.58
	MLWorks_20b1c1_1998_05_07:1.58
	MLWorks_20b0_1998_04_07:1.58
	MLWorks_20b0_1998_03_20:1.58
	MLWorks_20m2_1998_02_16:1.58
	MLWorks_20m1_1997_10_23:1.58
	MLWorks_11r1:1.58.1.1.1.1.1
	MLWorks_workspace_97:1.58.3
	MLWorks_dt_wizard:1.58.2
	MLWorks_11c0_1997_09_09:1.58.1.1.1.1
	MLWorks_10r3:1.58.1.1.3
	MLWorks_10r2_551:1.58.1.1.2
	MLWorks_11:1.58.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.58.1.1
	MLWorks_20m0_1997_06_20:1.58
	MLWorks_1_0_r2c2_1997_06_14:1.58.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.58.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.58.1
	MLWorks_BugFix_1997_04_24:1.58
	MLWorks_1_0_r2_Win32_1997_04_11:1.58
	MLWorks_1_0_r2_Unix_1997_04_04:1.58
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.57.3.1.1
	MLWorks_gui_1996_12_18:1.57.4
	MLWorks_1_0_Win32_1996_12_17:1.57.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.57.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.57.1.1
	MLWorks_1_0_Irix_1996_11_28:1.57.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.57.2
	MLWorks_1_0_Unix_1996_11_14:1.57.1
	MLWorks_Open_Beta2_1996_10_11:1.56.3
	MLWorks_License_dev:1.56.2
	MLWorks_1_open_beta_1996_09_13:1.56.1
	MLWorks_Open_Beta_1996_08_22:1.56
	MLWorks_Beta_1996_07_02:1.56
	MLWorks_Beta_1996_06_07:1.56
	MLWorks_Beta_1996_06_06:1.56
	MLWorks_Beta_1996_06_05:1.56
	MLWorks_Beta_1996_06_03:1.56
	MLWorks_Beta_1996_05_31:1.56
	MLWorks_Beta_1996_05_30:1.56
	ML_beta_release_12/08/94:1.46
	ML_beta_release_03/08/94:1.46
	ML_revised_beta_release_25/05/94:1.45
	ML_final_beta_release_02/03/94:1.45
	mlworks-28-01-1994:1.44
	Release:1.43
	mlworks-beta-01-09-1993:1.43
	MLWorks-1-0-4-29/01/1993:1.38
	MLWorks-1-0-3-21/12/1992:1.38
	MLWorks-1-0-2-15/12/1992:1.38
	MLWorks-1-0-1-04/12/1992:1.38
	checkpoint_17_08_92:1.30
	Ten15_release_21-08-91:1.11
	Ten15_release_19-08-91:1.11
	ten15_release:1.10;
locks; strict;
comment	@ * @;


1.59
date	99.02.09.09.50.00;	author mitchell;	state Exp;
branches
	1.59.1.1;
next	1.58;

1.58
date	96.12.02.13.37.16;	author matthew;	state Exp;
branches
	1.58.1.1
	1.58.2.1
	1.58.3.1;
next	1.57;

1.57
date	96.11.06.11.02.25;	author matthew;	state Exp;
branches
	1.57.1.1
	1.57.2.1
	1.57.3.1
	1.57.4.1;
next	1.56;

1.56
date	96.04.29.13.45.22;	author matthew;	state Exp;
branches
	1.56.1.1
	1.56.2.1
	1.56.3.1;
next	1.55;

1.55
date	95.12.22.16.52.39;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	95.12.13.14.00.20;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.12.04.13.36.53;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	95.08.10.17.17.09;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	95.03.22.14.07.19;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	95.02.28.11.44.54;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.01.17.11.18.10;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.10.10.09.33.24;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.09.22.09.31.17;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	94.07.20.14.39.23;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	93.12.08.16.31.28;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	93.08.13.15.43.44;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	93.07.12.10.00.35;	author nosa;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	93.05.18.15.52.05;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	93.03.10.14.29.12;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.03.04.11.59.51;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.03.01.14.35.27;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	92.11.07.11.39.19;	author richard;	state Exp;
branches;
next	1.37;

1.37
date	92.11.04.16.32.20;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	92.11.03.11.49.14;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	92.10.29.18.03.23;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.10.02.16.14.34;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.09.21.10.41.54;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.08.26.11.53.05;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.08.19.16.35.53;	author davidt;	state Exp;
branches;
next	1.30;

1.30
date	92.07.29.09.55.41;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.07.17.10.44.23;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.07.01.12.41.56;	author davida;	state Exp;
branches;
next	1.27;

1.27
date	92.06.23.09.24.31;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.06.22.16.08.29;	author davida;	state Exp;
branches;
next	1.25;

1.25
date	92.06.11.08.36.48;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.04.22.13.24.14;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.04.13.14.18.00;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.03.21.14.17.53;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.02.26.11.56.07;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.01.29.11.14.41;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.01.28.14.11.58;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.01.06.11.51.59;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.11.28.11.50.14;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	91.10.22.14.57.25;	author davidt;	state Exp;
branches;
next	1.15;

1.15
date	91.10.08.18.54.52;	author davidt;	state Exp;
branches;
next	1.14;

1.14
date	91.09.06.10.21.53;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.08.23.11.04.51;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.08.23.10.29.22;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.08.14.12.41.17;	author davida;	state Exp;
branches;
next	1.10;

1.10
date	91.07.25.10.04.57;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.07.16.14.34.51;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.07.11.11.03.01;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.07.09.12.10.27;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.06.27.09.51.30;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.06.26.18.35.56;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.26.16.13.53;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.18.19.06.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.18.13.38.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.16.14.00;	author jont;	state Exp;
branches;
next	;

1.43.1.1
date	93.07.12.10.00.35;	author jont;	state Exp;
branches;
next	;

1.56.1.1
date	96.09.13.11.17.24;	author hope;	state Exp;
branches;
next	;

1.56.2.1
date	96.10.07.16.07.10;	author hope;	state Exp;
branches;
next	;

1.56.3.1
date	96.10.17.11.25.27;	author hope;	state Exp;
branches;
next	;

1.57.1.1
date	96.11.14.12.50.28;	author hope;	state Exp;
branches
	1.57.1.1.1.1;
next	;

1.57.1.1.1.1
date	96.11.28.15.01.34;	author hope;	state Exp;
branches;
next	;

1.57.2.1
date	96.11.22.18.09.54;	author hope;	state Exp;
branches;
next	;

1.57.3.1
date	96.12.17.17.48.32;	author hope;	state Exp;
branches
	1.57.3.1.1.1;
next	;

1.57.3.1.1.1
date	97.02.24.11.38.29;	author hope;	state Exp;
branches;
next	;

1.57.4.1
date	96.12.18.09.42.33;	author hope;	state Exp;
branches;
next	;

1.58.1.1
date	97.05.12.10.35.02;	author hope;	state Exp;
branches
	1.58.1.1.1.1
	1.58.1.1.2.1
	1.58.1.1.3.1;
next	;

1.58.1.1.1.1
date	97.07.28.18.20.24;	author daveb;	state Exp;
branches
	1.58.1.1.1.1.1.1;
next	;

1.58.1.1.1.1.1.1
date	97.10.07.11.45.37;	author jkbrook;	state Exp;
branches;
next	;

1.58.1.1.2.1
date	97.09.08.17.13.54;	author daveb;	state Exp;
branches;
next	;

1.58.1.1.3.1
date	97.09.09.14.09.38;	author daveb;	state Exp;
branches;
next	;

1.58.2.1
date	97.09.10.19.25.33;	author brucem;	state Exp;
branches;
next	;

1.58.3.1
date	97.09.11.20.55.45;	author daveb;	state Exp;
branches;
next	;

1.59.1.1
date	99.04.01.17.57.18;	author daveb;	state Exp;
branches;
next	;


desc
@Split out the types from the rest of lambda
@


1.59
log
@[Bug #190505]
Support for precompilation of subprojects
@
text
@(* _lambdatypes.sml the functor *)
(*
$Log: _lambdatypes.sml,v $
 * Revision 1.58  1996/12/02  13:37:16  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.57  1996/11/06  11:02:25  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.56  1996/04/29  13:45:22  matthew
 * Integer changes
 *
 * Revision 1.55  1995/12/22  16:52:39  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
Revision 1.54  1995/12/13  14:00:20  jont
Add lvar_to_int function for using lvars with int hash tables

Revision 1.53  1995/12/04  13:36:53  matthew
Simplifying

Revision 1.52  1995/08/10  17:17:09  daveb
Added types for different lengths of words, ints and reals.

Revision 1.51  1995/03/22  14:07:19  daveb
Removed redundant requires, and unused Crash and Lists parameters.

Revision 1.50  1995/02/28  11:44:54  matthew
More information in FunInfo types

Revision 1.49  1995/01/17  11:18:10  matthew
Renaming debugger_env to runtime_env

Revision 1.48  1994/10/10  09:33:24  matthew
Various simplifications
Added module annotations to lambda syntax.

Revision 1.47  1994/09/22  09:31:17  matthew
Abstraction of debug information

Revision 1.46  1994/07/20  14:39:23  matthew
Functions and applications take a list of parameters

Revision 1.45  1993/12/08  16:31:28  nosa
Type function spills for Modules Debugger.

Revision 1.44  1993/08/13  15:43:44  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.43  1993/07/12  10:00:35  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.42  1993/05/18  15:52:05  jont
Removed integer parameter

Revision 1.41  1993/03/10  14:29:12  matthew
Signature revisions

Revision 1.40  1993/03/04  11:59:51  jont
Removed LVar_eq in favour of polymorphic equality, which work rather better
on MLWorks.

Revision 1.39  1993/03/01  14:35:27  matthew
Added MLVALUE lambda exp

Revision 1.38  1992/11/07  11:39:19  richard
Added a missing require.

Revision 1.37  1992/11/04  16:32:20  daveb
Fixed typo: mononewmap -> intnewmap

Revision 1.36  1992/11/03  11:49:14  daveb
Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.

Revision 1.35  1992/10/29  18:03:23  jont
Added IntNewMap parameter for constructing more efficient maps

Revision 1.34  1992/10/02  16:14:34  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.33  1992/09/21  10:41:54  clive
Changed hashtables to a single structure implementation

Revision 1.32  1992/08/26  11:53:05  jont
Removed some redundant structures and sharing

Revision 1.31  1992/08/19  16:35:53  davidt
Added LVar_ordering function.

Revision 1.30  1992/07/29  09:55:41  clive
Changed the bindingtable to be a hashtable

Revision 1.29  1992/07/17  10:44:23  clive
null_type_annotation is no longer a function

Revision 1.28  1992/07/01  12:41:56  davida
Added LET constructor and new slot to APP.

Revision 1.27  1992/06/23  09:24:31  clive
Added an annotation slot to HANDLE

Revision 1.26  1992/06/22  16:08:29  davida
Made string of field select a bit shorter.

Revision 1.25  1992/06/11  08:36:48  clive
Added datatype recording to the FNexp for the debugger and annotated LETs with
a string to be used as the annotation when they are converted into Fnexps

Revision 1.24  1992/04/22  13:24:14  clive
Speed improvements

Revision 1.23  1992/04/13  14:18:00  clive
First version of the profiler

Revision 1.22  1992/03/21  14:17:53  jont
Added require "../utils/set"

Revision 1.21  1992/02/26  11:56:07  jont
Added an lvar equality function, since polymorphic equality is so slow

Revision 1.20  1992/01/29  11:14:41  clive
Added the routines for calculating the next and previous Lvar after
a given lvar

Revision 1.19  1992/01/28  14:11:58  clive
Added a function to give the previous lambda variable

Revision 1.18  1992/01/06  11:51:59  jont
Added datatype binding to allow lets and recursive lets

Revision 1.17  1991/11/28  11:50:14  richard
Removed an unnecessary constraint on the Ident structure.

Revision 1.16  91/10/22  14:57:25  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.15  91/10/08  18:54:52  davidt
Changed the type LambdaExp so that record selection now retains the total
size of the record as well as just the index.

Revision 1.14  91/09/06  10:21:53  davida
Added LambdaInfo type for optimisations,
info for code-generator, etc.

Revision 1.13  91/08/23  11:04:51  jont
Changed to use pervasives

Revision 1.12  91/08/23  10:29:22  davida
Added ordering on lambda-expressions.

Revision 1.11  91/08/14  12:41:17  davida
Added int_of_LVar function to help hashing on
lambda-expressions.

Revision 1.10  91/07/25  10:04:57  jont
Added ordering on LVars and Primitives to allow them to be domains in maps

Revision 1.9  91/07/16  14:34:51  jont
Added EXP_TAG type to Construc and changed its name to Tag,
in order to code generate dynamic switches for exception matching

Revision 1.8  91/07/11  11:03:01  jont
New style LETREC

Revision 1.7  91/07/09  12:10:27  jont
Added fromField to get ints back from Fields

Revision 1.6  91/06/27  09:51:30  jont
Changed use multiple counter instances

Revision 1.5  91/06/26  18:35:56  jont
Added primitive generation for unique ids

Revision 1.4  91/06/26  16:13:53  jont
Changed LETERC to reflect declarative nature of ML ie no "in" expression

Revision 1.3  91/06/18  19:06:00  jont
Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor

Revision 1.2  91/06/18  13:38:00  jont
Added INT to lambda calculus for nullary constructors in expressions

Revision 1.1  91/06/11  16:14:00  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";

require "../utils/set";
require "../utils/counter";
require "../main/pervasives";
require "../typechecker/datatypes" ;
require "../debugger/runtime_env";
require "lambdatypes";

functor LambdaTypes(
  structure Set : SET
  structure Counter: COUNTER
  structure Pervasives: PERVASIVES
  structure Datatypes : DATATYPES
  structure RuntimeEnv : RUNTIMEENV
) : LAMBDATYPES =
struct
  structure Set = Set
  structure Ident = Datatypes.Ident
  structure Datatypes = Datatypes

  type Type = Datatypes.Type
  type Tyfun = Datatypes.Tyfun
  type Instance = Datatypes.Instance
  type Structure = Datatypes.Structure
  type DebuggerStr = Datatypes.DebuggerStr
  type FunInfo = RuntimeEnv.FunInfo
  type VarInfo = RuntimeEnv.VarInfo

  type LVar = int
  type Field = int
  type Primitive = Pervasives.pervasive

  datatype StructType = STRUCTURE | TUPLE | CONSTRUCTOR

  datatype Status = ENTRY | BODY | FUNC

  datatype Tag =
    VCC_TAG of string * int           (* value carrying constructor *)
  | IMM_TAG of string * int           (* constant constructor *)
  | SCON_TAG of Ident.SCon * int option   (* simple int, real, string ... *)
				      (* The int option gives the size of numeric types *)
  | EXP_TAG of LambdaExp     (* more complex tag, for dynamic switching *)

  and LambdaExp =
    VAR of LVar                       (* variable lookup *)
                                      (* function definition *)
  | FN of ((LVar list * LVar list) * LambdaExp * Status * string * Type * FunInfo)
  | LET of (LVar * VarInfo ref option * LambdaExp) * LambdaExp
  | LETREC of ((LVar * VarInfo ref option) list * LambdaExp list * LambdaExp)
  | APP of (LambdaExp * (LambdaExp list * LambdaExp list) * Type ref option)  (* function application *)
  | SCON of Ident.SCon * int option      (* int, real, string as strings *)
				      (* The int option gives the size of numeric types *)
  | MLVALUE of MLWorks.Internal.Value.ml_value (* immediate constants *)
  | INT of int                        (* int as int (for tags) *)
  | SWITCH of                         (* like a case statement *)
      LambdaExp *
      {num_vccs: int, num_imms: int} option *
      (Tag * LambdaExp) list *
      LambdaExp option
  (* The second argument contains enough information about the type being
     matched for the code generator to choose an appropriate representation.
     The LVar is bound to the argument of a value carrying constructor.
  *)
  | STRUCT of LambdaExp list * StructType         (* structure definition *)
  | SELECT of {index : int, size : int, selecttype : StructType} * LambdaExp     (* field selector *)
  | RAISE of LambdaExp              (* Exceptions --- throw ... *)
  | HANDLE of (LambdaExp * LambdaExp * string) (*            ... and catch *)
  | BUILTIN of Primitive              (* built-in functions --
				         These functions are
				         primitive to the abstract
				         machine. *)
  datatype binding =
    LETB of (LVar * VarInfo ref option * LambdaExp) |
    RECLETB of ((LVar * VarInfo ref option) list * LambdaExp list)

  fun do_binding(LETB(lv,info,le), exp) = LET((lv,info,le),exp)
    | do_binding(RECLETB(lv_list, le_list), exp)= LETREC(lv_list, le_list, exp)

  fun new_LVar () = Counter.counter () (* : unit -> LVar *)
  fun init_LVar () = Counter.reset_counter 0
  fun lvar_to_int x = x
  fun printLVar lvar = Int.toString lvar
  val read_counter = Counter.read_counter
  val reset_counter = Counter.reset_counter

  fun printPrim prim = Pervasives.print_pervasive prim
  fun printField {index : int, size : int,selecttype : StructType} =
	(*"index : " ^*) Int.toString index ^ "/" ^
        (*" size : " ^*) Int.toString size;
    

  val null_type_annotation = Datatypes.NULLTYPE

  val user_funinfo = RuntimeEnv.USER_FUNCTION
  val internal_funinfo = RuntimeEnv.INTERNAL_FUNCTION
  fun isLocalFn (RuntimeEnv.LOCAL_FUNCTION) = true
    | isLocalFn _ = false

  (* New stuff from simple*** *)
    datatype Dec = 
      VAL of LambdaExp |
      FUNCTOR of LVar * string * ((LVar * VarInfo ref option * Dec) list * LambdaExp)
      
    datatype program =
      PROGRAM of (LVar * VarInfo ref option * Dec) list * LambdaExp

    fun telfun f (EXP_TAG e, e') = (EXP_TAG (f e), f e')
      | telfun f (t,e) = (t,f e)

    (* Dispensers of unique ids *)
    val new_valid = new_LVar

end
@


1.59.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.59  1999/02/09  09:50:00  mitchell
 * [Bug #190505]
 * Support for precompilation of subprojects
 *
@


1.58
log
@Simplifications and rationalizations
@
text
@d4 3
d279 2
@


1.58.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.58  1996/12/02  13:37:16  matthew
 * Simplifications and rationalizations
 *
@


1.58.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.58  1996/12/02  13:37:16  matthew
 * Simplifications and rationalizations
 *
@


1.58.1.1
log
@branched from 1.58
@
text
@a3 3
 * Revision 1.58  1996/12/02  13:37:16  matthew
 * Simplifications and rationalizations
 *
@


1.58.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.58.1.1  1997/05/12  10:35:02  hope
 * branched from 1.58
 *
@


1.58.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.58.1.1  1997/05/12  10:35:02  hope
 * branched from 1.58
 *
@


1.58.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.58.1.1  1997/05/12  10:35:02  hope
 * branched from 1.58
 *
@


1.58.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.58.1.1.1.1  1997/07/28  18:20:24  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.57
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d228 2
d233 1
a233 1
  | SCON_TAG of Ident.SCon * int MLWorks.Option.option   (* simple int, real, string ... *)
d240 5
a244 5
  | FN of (LVar list * LambdaExp * string * Type * FunInfo)
  | LET of (LVar * VarInfo ref MLWorks.Option.option * LambdaExp) * LambdaExp
  | LETREC of ((LVar * VarInfo ref MLWorks.Option.option) list * LambdaExp list * LambdaExp)
  | APP of (LambdaExp * LambdaExp list * Type ref MLWorks.Option.option)  (* function application *)
  | SCON of Ident.SCon * int MLWorks.Option.option      (* int, real, string as strings *)
d250 1
a250 1
      {num_vccs: int, num_imms: int} MLWorks.Option.option *
d252 1
a252 1
      LambdaExp MLWorks.Option.option
d266 2
a267 2
    LETB of (LVar * VarInfo ref MLWorks.Option.option * LambdaExp) |
    RECLETB of ((LVar * VarInfo ref MLWorks.Option.option) list * LambdaExp list)
d287 17
a303 1
    
@


1.57.4.1
log
@branched from 1.57
@
text
@a3 4
 * Revision 1.57  1996/11/06  11:02:25  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.57.3.1
log
@branched from 1.57
@
text
@a3 4
 * Revision 1.57  1996/11/06  11:02:25  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.57.3.1.1.1
log
@branched from 1.57.3.1
@
text
@a3 3
 * Revision 1.57.3.1  1996/12/17  17:48:32  hope
 * branched from 1.57
 *
@


1.57.2.1
log
@branched from 1.57
@
text
@a3 4
 * Revision 1.57  1996/11/06  11:02:25  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.57.1.1
log
@branched from 1.57
@
text
@a3 4
 * Revision 1.57  1996/11/06  11:02:25  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.57.1.1.1.1
log
@branched from 1.57.1.1
@
text
@a3 3
 * Revision 1.57.1.1  1996/11/14  12:50:28  hope
 * branched from 1.57
 *
@


1.56
log
@Integer changes
@
text
@d4 3
d189 1
a189 1
require "../basis/__integer";
@


1.56.3.1
log
@branched from 1.56
@
text
@a3 3
 * Revision 1.56  1996/04/29  13:45:22  matthew
 * Integer changes
 *
@


1.56.2.1
log
@branched from 1.56
@
text
@a3 3
 * Revision 1.56  1996/04/29  13:45:22  matthew
 * Integer changes
 *
@


1.56.1.1
log
@branched from 1.56
@
text
@a3 3
 * Revision 1.56  1996/04/29  13:45:22  matthew
 * Integer changes
 *
@


1.55
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
d186 2
d266 1
a266 1
  fun printLVar lvar = MLWorks.Integer.makestring lvar
d270 2
a271 2
	(*"index : " ^*) MLWorks.Integer.makestring index ^ "/" ^
        (*" size : " ^*) MLWorks.Integer.makestring size;
@


1.54
log
@Add lvar_to_int function for using lvars with int hash tables
@
text
@d4 3
a183 1
require "../utils/option";
a193 1
  structure Option : OPTION
a199 1
  structure Option = Option
@


1.53
log
@Simplifying
@
text
@d4 3
d259 1
a273 1

@


1.52
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a177 2
require "../utils/intnewmap";
require "../utils/newhashtable";
a186 1
  structure Map: INTNEWMAP
a188 1
  structure NewHashTable : NEWHASHTABLE
a193 1
  structure Map = Map
a195 1
  structure NewHashTable = NewHashTable
d255 1
a255 7
  val dummy_lvar = 0
  val doprint = false 
  fun P s = if doprint then output (std_out,s ^ "\n") else ()
  fun alter_LVar_count i = 
    (P "Resetting in alter_LVar_count"; 
     Counter.reset_counter i (* : LVar -> unit *))
  fun init_LVar () = (P "Initializing LVar_count"; Counter.reset_counter 0)
a256 4
  fun LVar_order(l1:LVar, l2) = l1 < l2
  fun int_of_LVar (lvar : LVar) = lvar : int
  fun LVar_previous x = Counter.previous_count x
  fun LVar_next x = Counter.next_count x
a262 113

  (* ordering on lambda-expressions, by outermost constructor. *)

  (* order is SCON, MLVALUE, INT, BUILTIN, VAR, FN/LET/LETREC,     *)
  (*          STRUCT/SELECT, SWITCH, APP, HANDLE, RAISE.  *)

  (*  This function could be expression more succinctly recursively,    *)
  (*  but since it doesn't require recursion, I've written it in full.  *)

  fun expr_order (SCON _,     _        ) = true
    | expr_order (MLVALUE _,  SCON _   ) = false
    | expr_order (MLVALUE _,  _        ) = true
    | expr_order (INT _,      SCON _   ) = false
    | expr_order (INT _,      MLVALUE _) = false
    | expr_order (INT _ ,     _        ) = true
    | expr_order (BUILTIN _,  SCON _   ) = false
    | expr_order (BUILTIN _,  MLVALUE _) = false
    | expr_order (BUILTIN _,  INT _    ) = false
    | expr_order (BUILTIN _,  _        ) = true
    | expr_order (VAR _,      SCON _   ) = false
    | expr_order (VAR _,      MLVALUE _) = false
    | expr_order (VAR _,      INT _    ) = false
    | expr_order (VAR _,      BUILTIN _) = false
    | expr_order (VAR _,      _        ) = true
    | expr_order (LET _,      SCON _   ) = false
    | expr_order (LET _,      MLVALUE _) = false
    | expr_order (LET _,      INT _    ) = false
    | expr_order (LET _,      BUILTIN _) = false
    | expr_order (LET _,      VAR _    ) = false
    | expr_order (LET _,      _        ) = true
    | expr_order (FN _,       SCON _   ) = false
    | expr_order (FN _,       MLVALUE _) = false
    | expr_order (FN _,       INT _    ) = false
    | expr_order (FN _,       BUILTIN _) = false
    | expr_order (FN _,       VAR _    ) = false
    | expr_order (FN _,       _        ) = true
    | expr_order (LETREC _,   SCON _   ) = false
    | expr_order (LETREC _,   MLVALUE _) = false
    | expr_order (LETREC _,   INT _    ) = false
    | expr_order (LETREC _,   BUILTIN _) = false
    | expr_order (LETREC _,   VAR _    ) = false
    | expr_order (LETREC _,   _        ) = true
    | expr_order (STRUCT _,   SCON _   ) = false
    | expr_order (STRUCT _,   MLVALUE _) = false
    | expr_order (STRUCT _,   INT _    ) = false
    | expr_order (STRUCT _,   BUILTIN _) = false
    | expr_order (STRUCT _,   VAR _    ) = false
    | expr_order (STRUCT _,   FN _     ) = false
    | expr_order (STRUCT _,   LETREC _ ) = false
    | expr_order (STRUCT _,   _        ) = true
    | expr_order (SELECT _,   SCON _   ) = false
    | expr_order (SELECT _,   MLVALUE _) = false
    | expr_order (SELECT _,   INT _    ) = false
    | expr_order (SELECT _,   BUILTIN _) = false
    | expr_order (SELECT _,   VAR _    ) = false
    | expr_order (SELECT _,   FN _     ) = false
    | expr_order (SELECT _,   LETREC _ ) = false
    | expr_order (SELECT _,   _        ) = true
    | expr_order (SWITCH _,   SCON _   ) = false
    | expr_order (SWITCH _,   MLVALUE _) = false
    | expr_order (SWITCH _,   INT _    ) = false
    | expr_order (SWITCH _,   BUILTIN _) = false
    | expr_order (SWITCH _,   VAR _    ) = false
    | expr_order (SWITCH _,   FN _     ) = false
    | expr_order (SWITCH _,   LETREC _ ) = false
    | expr_order (SWITCH _,   STRUCT _ ) = false
    | expr_order (SWITCH _,   SELECT _ ) = false
    | expr_order (SWITCH _,   _        ) = true
    | expr_order (APP _,      SCON _   ) = false
    | expr_order (APP _,      MLVALUE _) = false
    | expr_order (APP _,      INT _    ) = false
    | expr_order (APP _,      BUILTIN _) = false
    | expr_order (APP _,      VAR _    ) = false
    | expr_order (APP _,      FN _     ) = false
    | expr_order (APP _,      LETREC _ ) = false
    | expr_order (APP _,      STRUCT _ ) = false
    | expr_order (APP _,      SELECT _ ) = false
    | expr_order (APP _,      SWITCH _ ) = false
    | expr_order (APP _,      _        ) = true
    | expr_order (HANDLE _,   SCON _   ) = false
    | expr_order (HANDLE _,   MLVALUE _) = false
    | expr_order (HANDLE _,   INT _    ) = false
    | expr_order (HANDLE _,   BUILTIN _) = false
    | expr_order (HANDLE _,   VAR _    ) = false
    | expr_order (HANDLE _,   FN _     ) = false
    | expr_order (HANDLE _,   LETREC _ ) = false
    | expr_order (HANDLE _,   STRUCT _ ) = false
    | expr_order (HANDLE _,   SELECT _ ) = false
    | expr_order (HANDLE _,   SWITCH _ ) = false
    | expr_order (HANDLE _,   APP _    ) = false
    | expr_order (HANDLE _,   _        ) = true
    | expr_order (RAISE _,    SCON _   ) = false
    | expr_order (RAISE _,    MLVALUE _) = false
    | expr_order (RAISE _,    INT _    ) = false
    | expr_order (RAISE _,    BUILTIN _) = false
    | expr_order (RAISE _,    VAR _    ) = false
    | expr_order (RAISE _,    FN _     ) = false
    | expr_order (RAISE _,    LETREC _ ) = false
    | expr_order (RAISE _,    STRUCT _ ) = false
    | expr_order (RAISE _,    SELECT _ ) = false
    | expr_order (RAISE _,    SWITCH _ ) = false
    | expr_order (RAISE _,    APP _    ) = false
    | expr_order (RAISE _,    HANDLE _ ) = false
    | expr_order (RAISE _,    _        ) = true

  (*  A Type Used in Optimisation  *)

  datatype LambdaInfo = Info of {bindings : (LVar,LambdaExp) NewHashTable.HashTable,
				 known_fns : LVar Set.Set,
				 non_escaping_fns : LVar Set.Set,
				 is_shiftable : LambdaExp -> bool,
				 is_commutative : LambdaExp -> bool,
				 is_associative : LambdaExp -> bool}
@


1.51
log
@Removed redundant requires, and unused Crash and Lists parameters.
@
text
@d4 3
d218 2
a219 1
  | SCON_TAG of Ident.SCon   (* simple int, real, string ... *)
d226 5
a230 4
  | LET of (LVar * VarInfo ref Option.opt * LambdaExp) * LambdaExp
  | LETREC of ((LVar * VarInfo ref Option.opt) list * LambdaExp list * LambdaExp)
  | APP of (LambdaExp * LambdaExp list * Type ref Option.opt)  (* function application *)
  | SCON of Ident.SCon      (* int, real, string as strings *)
d235 1
a235 1
      {num_vccs: int, num_imms: int} Option.opt *
d237 1
a237 1
      LambdaExp Option.opt
d251 2
a252 2
    LETB of (LVar * VarInfo ref Option.opt * LambdaExp) |
    RECLETB of ((LVar * VarInfo ref Option.opt) list * LambdaExp list)
@


1.50
log
@More information in FunInfo types
@
text
@d4 3
d171 1
a172 4
require "../utils/set";
require "../utils/counter";
require "../utils/lists";
require "../utils/crash";
a173 1
require "../utils/intnewmap";
d183 1
a183 1
  structure Map : INTNEWMAP
a185 2
  structure Lists : LISTS
  structure Crash : CRASH
d192 1
a194 1
  structure NewMap = Datatypes.NewMap
a195 1
  structure Map = Map
@


1.49
log
@Renaming debugger_env to runtime_env
@
text
@d4 3
d225 1
a225 1
  | FN of (LVar list * LambdaExp * string * Type * FunInfo Option.opt)
d390 3
@


1.48
log
@Various simplifications
Added module annotations to lambda syntax.
@
text
@d4 4
d175 1
a175 1
require "../debugger/debugger_env";
@


1.47
log
@Abstraction of debug information
@
text
@d4 3
d207 2
d219 1
a219 1
  | LET of (LVar * VarInfo ref Option.opt * LambdaExp * LambdaExp)
d234 2
a235 2
  | STRUCT of LambdaExp list          (* structure definition *)
  | SELECT of {index : int, size : int} * LambdaExp     (* field selector *)
d243 1
a243 2
    (* this string redundant now. *)
    LETB of (LVar * VarInfo ref Option.opt * LambdaExp * string) |
d246 1
a246 1
  fun do_binding(LETB(lv,info,le,annotation), exp) = LET(lv,info,le,exp)
d264 1
a264 1
  fun printField {index : int, size : int} =
@


1.46
log
@Functions and applications take a list of parameters
@
text
@d4 3
d168 1
d181 1
d197 2
d213 3
a215 12
  | FN of (LVar list * LambdaExp * string * Type * 
           ((int * Type * Instance) ref list * (int,int) Option.option ref Option.opt) Option.opt)
  | LET of ((LVar,(LVar * (string * (Type * Instance ref Option.opt
                                     * (Tyfun ref * (int,int) Option.option ref) list) ref 
                       * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
            * LambdaExp * LambdaExp)
    (* non-rec defs *)
  | LETREC of                        (* allows recursive definitions *)
    ((LVar,(LVar * (string * (Type * Instance ref Option.opt
                              * (Tyfun ref * (int,int) Option.option ref) list) ref 
                   * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
     * LambdaExp list * LambdaExp)
d222 1
a222 1
      {lv: LVar, num_vccs: int, num_imms: int} Option.opt *
d238 3
a240 8
    LETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt
                                     * (Tyfun ref * (int,int) Option.option ref) list) ref 
                        * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
    * LambdaExp * string |   (* this string redundant now. *)
    RECLETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt
                                        * (Tyfun ref * (int,int) Option.option ref) list) ref 
                  * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
    * LambdaExp list
d242 1
a242 1
  fun do_binding(LETB(lv, le,annotation), exp) = LET(lv,le,exp)
a244 4
  fun fetch_var var = 
    case var of
      Option.SOME1(var)=>var
    | Option.SOME2(ref(var,_))=>var
d246 7
a252 2
  fun alter_LVar_count i = Counter.reset_counter i (* : LVar -> unit *)
  fun init_LVar () = Counter.reset_counter 0
@


1.45
log
@Type function spills for Modules Debugger.
@
text
@d4 3
d206 1
a206 1
  | FN of (LVar * LambdaExp * string * Type * 
d218 1
a218 1
  | APP of (LambdaExp * LambdaExp * Type ref Option.opt)  (* function application *)
@


1.44
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d185 4
a188 1
  type Instance = Datatypes.instance
d205 3
a207 2
  | LET of ((LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                           * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
d211 3
a213 2
    ((LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                    * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
d237 3
a239 2
    LETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                           * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
d241 3
a243 2
    RECLETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                              * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
@


1.43
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d4 4
d181 1
d196 4
a199 2
  | FN of (LVar * LambdaExp * string * Type)
  | LET of ((LVar,(LVar * (string * Type ref) Option.opt)ref) Option.option 
d203 2
a204 1
    ((LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option list 
d228 2
a229 1
    LETB of (LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option 
d231 2
a232 1
    RECLETB of (LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option list 
@


1.43.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.43  1993/07/12  10:00:35  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.42
log
@Removed integer parameter
@
text
@d4 3
d151 1
d165 1
d174 1
a181 1
  datatype 'a Opt = PRESENT of 'a | ABSENT
d183 2
a184 2
    VCC_TAG of int           (* value carrying constructor *)
  | IMM_TAG of int           (* constant constructor *)
d187 2
a188 1
    and LambdaExp =
d191 9
a199 6
  | FN of (LVar * LambdaExp * string * Datatypes.Type)
  | LET of (LVar * LambdaExp * LambdaExp)
  | LETREC of                         (* allows recursive definitions *)
    (LVar list * LambdaExp list * LambdaExp)
  | APP of (LambdaExp * LambdaExp * Datatypes.Type)  (* function application *)
  | SCON of Ident.SCon                (* int, real, string ... *)
d204 1
a204 1
      {lv: LVar, num_vccs: int, num_imms: int} Opt *
d206 1
a206 1
      LambdaExp Opt
a210 1

d213 1
a213 1
  | RAISE of LambdaExp                (* Exceptions --- throw ... *)
d220 4
a223 2
    LETB of LVar * LambdaExp * string |
    RECLETB of LVar list * LambdaExp list
d228 4
@


1.41
log
@Signature revisions
@
text
@d4 3
a142 1
require "../utils/integer";
a154 1
  structure Integer: INTEGER
d221 1
a221 1
  fun printLVar lvar = Integer.makestring lvar
d229 2
a230 2
	(*"index : " ^*) Integer.makestring index ^ "/" ^
        (*" size : " ^*) Integer.makestring size;
@


1.40
log
@Removed LVar_eq in favour of polymorphic equality, which work rather better
on MLWorks.
@
text
@d4 4
d168 2
@


1.39
log
@Added MLVALUE lambda exp
@
text
@d4 3
a214 1
  fun LVar_eq(l1:LVar, l2) = l1 = l2
@


1.38
log
@Added a missing require.
@
text
@d4 3
d181 1
d226 1
a226 1
  (* order is SCON, INT, BUILTIN, VAR, FN/LET/LETREC,     *)
d233 2
d236 1
d239 1
d243 1
d248 1
d254 1
d260 1
d266 1
d274 1
d282 1
d292 1
d303 1
d315 1
@


1.37
log
@Fixed typo: mononewmap -> intnewmap
@
text
@d4 3
d135 1
@


1.36
log
@Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.
@
text
@d4 4
d125 1
a125 1
require "../utils/mononewmap";
@


1.35
log
@Added IntNewMap parameter for constructing more efficient maps
@
text
@d4 3
d154 1
d157 2
a158 1
    CON_TAG of int           (* basic datatype tagging type *)
d172 9
a180 5
    (LambdaExp * (Tag * LambdaExp) list * LambdaExp Opt * LambdaExp Opt)
                                      (* First default for constructor not in
				         in list, second for not a constructor
					 so we can efficiently check for
					 non-nullary constructors *)
@


1.34
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d118 2
d133 1
d146 1
a192 3

  fun LVar_ordering(l1:LVar, l2) = (l1 < l2)

@


1.33
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d187 1
a187 2
  fun LVar_ordering(l1:LVar, l2) =
    if l1 < l2 then NewMap.LESS else if l1 > l2 then NewMap.GREATER else NewMap.EQUAL
@


1.32
log
@Removed some redundant structures and sharing
@
text
@d4 3
d116 1
a116 1
require "../utils/_newhashtable";
d129 1
d136 1
a286 14
(* Given a NewMap structure of type NEWMAP, this gives a functional
   binding lookup table    *)

  structure BindingTable = 
    NewHashTable(
      structure Crash = Crash
      structure Lists = Lists
      type Key = LVar
      type Value = LambdaExp
      val eq = LVar_eq
      val size = 32
      val hash = int_of_LVar
                 )

d289 1
a289 1
  datatype LambdaInfo = Info of {bindings : BindingTable.HashTable,
@


1.31
log
@Added LVar_ordering function.
@
text
@d4 3
a107 1
require "../basics/ident";
a118 1
  structure Ident: IDENT
d129 1
a129 1
  structure Ident = Ident
@


1.30
log
@Changed the bindingtable to be a hashtable
@
text
@d4 3
a112 1
require "../utils/newmap";
a121 1
  structure NewMap : NEWMAP
d130 1
d177 4
@


1.29
log
@null_type_annotation is no longer a function
@
text
@d4 3
d106 3
d122 2
d279 9
a287 16
    struct
      open NewMap
      fun compare(x,y) =
        let
          val a = int_of_LVar x
          val b = int_of_LVar y
        in
          if a<b
            then LESS
          else if x=y
                 then EQUAL
               else GREATER
        end
      type Table = (LVar,LambdaExp) T
      val empty = fn () => empty compare
    end
a288 1

d291 1
a291 1
  datatype LambdaInfo = Info of {bindings : BindingTable.Table,
@


1.28
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d298 1
a298 1
  fun null_type_annotation() = Datatypes.NULLTYPE
@


1.27
log
@Added an annotation slot to HANDLE
@
text
@d4 3
d130 2
a131 1
  | FN of (LVar * LambdaExp * string * Datatypes.Type)          
d134 1
a134 1
  | APP of (LambdaExp * LambdaExp)    (* function application *)
d152 2
a153 4
    LET of LVar * LambdaExp * string |
    RECLET of LVar list * LambdaExp list
  fun do_binding(LET(lv, le,annotation), exp) = APP(FN(lv, exp,annotation,Datatypes.NULLTYPE), le)
  | do_binding(RECLET(lv_list, le_list), exp) = LETREC(lv_list, le_list, exp)
d155 3
d171 2
a172 1
	(*" size : " ^*) Integer.makestring size
d176 1
a176 1
  (* order is SCON, INT, BUILTIN, VAR, FN/LETREC,         *)
d192 5
@


1.26
log
@Made string of field select a bit shorter.
@
text
@d4 3
d142 1
a142 1
  | HANDLE of (LambdaExp * LambdaExp) (*            ... and catch *)
@


1.25
log
@Added datatype recording to the FNexp for the debugger and annotated LETs with
a string to be used as the annotation when they are converted into Fnexps
@
text
@d4 4
d162 2
a163 2
	"index : " ^ Integer.makestring index ^
	" size : " ^ Integer.makestring size
@


1.24
log
@Speed improvements
@
text
@d4 3
d92 1
d102 1
d107 1
d119 2
a120 1
  | FN of (LVar * LambdaExp * string)          (* function definition *)
d141 1
a141 1
    LET of LVar * LambdaExp |
d143 1
a143 1
  fun do_binding(LET(lv, le), exp) = APP(FN(lv, exp,"do_binding"), le)
d145 1
d155 1
d277 2
@


1.23
log
@First version of the profiler
@
text
@d4 3
d88 1
d97 1
d102 1
d237 2
d240 19
d261 1
a261 1
  datatype LambdaInfo = Info of {bindings : (LVar * LambdaExp) list,
d269 1
@


1.22
log
@Added require "../utils/set"
@
text
@d4 3
d107 1
a107 1
  | FN of (LVar * LambdaExp)          (* function definition *)
d130 1
a130 1
  fun do_binding(LET(lv, le), exp) = APP(FN(lv, exp), le)
@


1.21
log
@Added an lvar equality function, since polymorphic equality is so slow
@
text
@d4 3
d78 2
a79 1
require "../utils/integer.sml";
@


1.20
log
@Added the routines for calculating the next and previous Lvar after
a given lvar
@
text
@d4 4
d129 1
@


1.19
log
@Added a function to give the previous lambda variable
@
text
@d4 3
d128 1
@


1.18
log
@Added datatype binding to allow lets and recursive lets
@
text
@d4 3
d124 1
@


1.17
log
@Removed an unnecessary constraint on the Ident structure.
@
text
@d3 4
a6 1
$Log:	_lambdatypes.sml,v $
d11 1
a11 1
> Changed the type LambdaExp so that record selection now retains the total
d110 5
@


1.16
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d4 3
d68 1
a68 1
  structure Ident: IDENTCLASS
@


1.15
log
@> Changed the type LambdaExp so that record selection now retains the total
size of the record as well as just the index.
@
text
@d4 4
a73 2
  exception impossible of string
  exception not_done_yet of string
@


1.14
log
@Added LambdaInfo type for optimisations,
info for code-generator, etc.
@
text
@d4 4
d95 1
a95 1
  | SELECT of (Field * LambdaExp)     (* field selector *)
d109 3
a111 3
  fun printField field = Integer.makestring field
  fun toField x = x
  fun fromField x = x
@


1.13
log
@Changed to use pervasives
@
text
@d4 3
d58 1
d64 1
d193 10
@


1.12
log
@Added ordering on lambda-expressions.
@
text
@d4 3
d50 1
d53 6
a58 4
functor LambdaTypes(structure Ident: IDENTCLASS
  structure Counter1: COUNTER
  structure Counter2: COUNTER
  structure Integer: INTEGER) : LAMBDATYPES =
d65 1
a65 1
  type Primitive = int
d93 3
a95 3
  fun new_LVar () = Counter1.counter () (* : unit -> LVar *)
  fun alter_LVar_count i = Counter1.reset_counter i (* : LVar -> unit *)
  fun init_LVar () = Counter1.reset_counter 0
d99 1
a99 4
  fun new_Prim () = Counter2.counter () (* : unit -> Primitive *)
  fun init_Prim () = Counter2.reset_counter 0
  fun printPrim prim = Integer.makestring prim
  fun Prim_order(p1: Primitive, p2) = p1 < p2
@


1.11
log
@Added int_of_LVar function to help hashing on
lambda-expressions.
@
text
@d4 4
d100 86
@


1.10
log
@Added ordering on LVars and Primitives to allow them to be domains in maps
@
text
@d4 3
d88 1
@


1.9
log
@Added EXP_TAG type to Construc and changed its name to Tag,
in order to code generate dynamic switches for exception matching
@
text
@d4 4
d84 1
d88 1
@


1.8
log
@New style LETREC
@
text
@d4 3
d50 1
a50 1
  datatype Construc =
d53 2
a54 1
  datatype LambdaExp =
d63 1
a63 1
    (LambdaExp * (Construc * LambdaExp) list * LambdaExp Opt * LambdaExp Opt)
@


1.7
log
@Added fromField to get ints back from Fields
@
text
@d4 3
d54 1
a54 2
    (LVar list * LambdaExp list (** LambdaExp*))
                                      (* Extra LambdaExp not required *)
@


1.6
log
@Changed use multiple counter instances
@
text
@d4 3
d79 1
@


1.5
log
@Added primitive generation for unique ids
@
text
@d4 3
d30 2
a31 1
  structure Counter: COUNTER
d67 3
a69 3
  fun new_LVar () = Counter.counter () (* : unit -> LVar *)
  fun alter_LVar_count i = Counter.reset_counter i (* : LVar -> unit *)
  fun init_LVar () = Counter.reset_counter 0
d71 2
a72 2
  fun new_Prim () = Counter.counter () (* : unit -> Primitive *)
  fun init_Prim () = Counter.reset_counter 0
@


1.4
log
@Changed LETERC to reflect declarative nature of ML ie no "in" expression
@
text
@d4 3
d67 2
@


1.3
log
@Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor
@
text
@d4 5
d41 2
a42 1
    (LVar list * LambdaExp list * LambdaExp)
@


1.2
log
@Added INT to lambda calculus for nullary constructors in expressions
@
text
@d4 3
d41 5
a45 1
    (LambdaExp * (Construc * LambdaExp) list * LambdaExp Opt)
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d36 1
@
