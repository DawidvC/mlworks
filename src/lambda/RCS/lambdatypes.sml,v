head	1.56;
access;
symbols
	MLW_daveb_inline_1_4_99:1.56.1
	MLWorks_21c0_1999_03_25:1.56
	MLWorks_20c1_1998_08_20:1.55
	MLWorks_20c0_1998_08_04:1.55
	MLWorks_20b2c2_1998_06_19:1.55
	MLWorks_20b2_Windows_1998_06_12:1.55
	MLWorks_20b1c1_1998_05_07:1.55
	MLWorks_20b0_1998_04_07:1.55
	MLWorks_20b0_1998_03_20:1.55
	MLWorks_20m2_1998_02_16:1.55
	MLWorks_20m1_1997_10_23:1.55
	MLWorks_11r1:1.55.1.1.1.1.1
	MLWorks_workspace_97:1.55.3
	MLWorks_dt_wizard:1.55.2
	MLWorks_11c0_1997_09_09:1.55.1.1.1.1
	MLWorks_10r3:1.55.1.1.3
	MLWorks_10r2_551:1.55.1.1.2
	MLWorks_11:1.55.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.55.1.1
	MLWorks_20m0_1997_06_20:1.55
	MLWorks_1_0_r2c2_1997_06_14:1.55.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.55.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.55.1
	MLWorks_BugFix_1997_04_24:1.55
	MLWorks_1_0_r2_Win32_1997_04_11:1.55
	MLWorks_1_0_r2_Unix_1997_04_04:1.55
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.54.5.1.1
	MLWorks_gui_1996_12_18:1.54.6
	MLWorks_1_0_Win32_1996_12_17:1.54.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.54.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.54.3.1
	MLWorks_1_0_Irix_1996_11_28:1.54.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.54.4
	MLWorks_1_0_Unix_1996_11_14:1.54.3
	MLWorks_Open_Beta2_1996_10_11:1.54.2
	MLWorks_License_dev:1.54.1
	MLWorks_1_open_beta_1996_09_13:1.53.1
	MLWorks_Open_Beta_1996_08_22:1.53
	MLWorks_Beta_1996_07_02:1.53
	MLWorks_Beta_1996_06_07:1.53
	MLWorks_Beta_1996_06_06:1.53
	MLWorks_Beta_1996_06_05:1.53
	MLWorks_Beta_1996_06_03:1.53
	MLWorks_Beta_1996_05_31:1.53
	MLWorks_Beta_1996_05_30:1.53
	ML_beta_release_12/08/94:1.45
	ML_beta_release_03/08/94:1.45
	ML_revised_beta_release_25/05/94:1.44
	ML_final_beta_release_02/03/94:1.44
	mlworks-28-01-1994:1.43
	Release:1.42
	mlworks-beta-01-09-1993:1.42
	MLWorks-1-0-4-29/01/1993:1.38
	MLWorks-1-0-3-21/12/1992:1.38
	MLWorks-1-0-2-15/12/1992:1.38
	MLWorks-1-0-1-04/12/1992:1.38
	checkpoint_17_08_92:1.32
	Ten15_release_21-08-91:1.15
	Ten15_release_19-08-91:1.15
	ten15_release:1.12;
locks; strict;
comment	@ * @;


1.56
date	99.02.09.09.50.01;	author mitchell;	state Exp;
branches
	1.56.1.1;
next	1.55;

1.55
date	96.12.02.13.36.44;	author matthew;	state Exp;
branches
	1.55.1.1
	1.55.2.1
	1.55.3.1;
next	1.54;

1.54
date	96.10.04.13.47.06;	author matthew;	state Exp;
branches
	1.54.1.1
	1.54.2.1
	1.54.3.1
	1.54.4.1
	1.54.5.1
	1.54.6.1;
next	1.53;

1.53
date	96.02.26.11.20.26;	author jont;	state Exp;
branches
	1.53.1.1;
next	1.52;

1.52
date	95.12.22.16.52.16;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	95.12.13.13.59.56;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	95.12.04.13.36.45;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	95.08.21.11.36.23;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	95.02.28.11.40.55;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.10.10.09.31.35;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	94.09.22.09.32.25;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	94.07.20.14.39.02;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	93.12.08.16.31.17;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	93.08.13.15.42.29;	author nosa;	state Exp;
branches;
next	1.42;

1.42
date	93.07.12.09.57.02;	author nosa;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	93.03.10.16.01.16;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.03.04.11.58.26;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.03.01.14.01.03;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	92.11.03.11.47.59;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	92.10.29.18.01.47;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.10.02.16.14.10;	author clive;	state Exp;
branches;
next	1.35;

1.35
date	92.09.21.10.39.20;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.08.26.11.45.43;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.08.19.16.26.28;	author davidt;	state Exp;
branches;
next	1.32;

1.32
date	92.07.29.09.54.34;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.07.17.10.44.08;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.07.01.12.42.06;	author davida;	state Exp;
branches;
next	1.29;

1.29
date	92.06.23.09.24.17;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.06.11.08.34.18;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.04.22.13.24.24;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.04.14.16.07.03;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.02.26.11.54.24;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.01.29.11.15.03;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.01.28.12.32.28;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.01.06.11.49.38;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.11.28.10.59.01;	author richard;	state Exp;
branches;
next	1.20;

1.20
date	91.10.22.14.57.08;	author davidt;	state Exp;
branches;
next	1.19;

1.19
date	91.10.08.18.54.44;	author davidt;	state Exp;
branches;
next	1.18;

1.18
date	91.09.06.10.21.44;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.08.23.11.04.02;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.08.23.09.36.39;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	91.08.15.10.33.22;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	91.08.14.12.40.44;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.08.13.10.15.59;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.07.25.09.56.20;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.07.16.14.32.59;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.07.11.11.02.34;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.07.10.11.15.07;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.07.09.12.10.06;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.06.26.18.35.03;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.06.26.16.12.26;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.06.19.11.41.00;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.18.19.05.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.18.13.37.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.11.16.56.12;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.11.40.18;	author jont;	state Exp;
branches;
next	;

1.42.1.1
date	93.07.12.09.57.02;	author jont;	state Exp;
branches;
next	;

1.53.1.1
date	96.09.13.11.17.29;	author hope;	state Exp;
branches;
next	;

1.54.1.1
date	96.10.07.16.07.14;	author hope;	state Exp;
branches;
next	;

1.54.2.1
date	96.10.17.11.25.31;	author hope;	state Exp;
branches;
next	;

1.54.3.1
date	96.11.14.12.50.33;	author hope;	state Exp;
branches
	1.54.3.1.1.1;
next	;

1.54.3.1.1.1
date	96.11.28.15.01.38;	author hope;	state Exp;
branches;
next	;

1.54.4.1
date	96.11.22.18.09.58;	author hope;	state Exp;
branches;
next	;

1.54.5.1
date	96.12.17.17.48.35;	author hope;	state Exp;
branches
	1.54.5.1.1.1;
next	;

1.54.5.1.1.1
date	97.02.24.11.38.34;	author hope;	state Exp;
branches;
next	;

1.54.6.1
date	96.12.18.09.42.37;	author hope;	state Exp;
branches;
next	;

1.55.1.1
date	97.05.12.10.35.04;	author hope;	state Exp;
branches
	1.55.1.1.1.1
	1.55.1.1.2.1
	1.55.1.1.3.1;
next	;

1.55.1.1.1.1
date	97.07.28.18.20.26;	author daveb;	state Exp;
branches
	1.55.1.1.1.1.1.1;
next	;

1.55.1.1.1.1.1.1
date	97.10.07.11.45.41;	author jkbrook;	state Exp;
branches;
next	;

1.55.1.1.2.1
date	97.09.08.17.13.56;	author daveb;	state Exp;
branches;
next	;

1.55.1.1.3.1
date	97.09.09.14.09.40;	author daveb;	state Exp;
branches;
next	;

1.55.2.1
date	97.09.10.19.25.36;	author brucem;	state Exp;
branches;
next	;

1.55.3.1
date	97.09.11.20.55.47;	author daveb;	state Exp;
branches;
next	;

1.56.1.1
date	99.04.01.17.57.19;	author daveb;	state Exp;
branches;
next	;


desc
@Types for lambda calculus
@


1.56
log
@[Bug #190505]
Support for precompilation of subprojects
@
text
@(* lambdatypes.sml the signature *)
(*
$Log: lambdatypes.sml,v $
 * Revision 1.55  1996/12/02  13:36:44  matthew
 * Adding isLocalFn function
 *
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
 * Revision 1.53  1996/02/26  11:20:26  jont
 * Change newhashtable to hashtable
 *
 * Revision 1.52  1995/12/22  16:52:16  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
Revision 1.51  1995/12/13  13:59:56  jont
Add lvar_to_int function for using lvars with int hash tables

Revision 1.50  1995/12/04  13:36:45  matthew
Simplifying

Revision 1.49  1995/08/21  11:36:23  daveb
Added types for different lengths of words, ints and reals.

Revision 1.48  1995/02/28  11:40:55  matthew
More information in FunInfo types

Revision 1.47  1994/10/10  09:31:35  matthew
Simplifications of lambda expressions

Revision 1.46  1994/09/22  09:32:25  matthew
Abstraction of debug information

Revision 1.45  1994/07/20  14:39:02  matthew
Functions and applications take a list of parameters

Revision 1.44  1993/12/08  16:31:17  nosa
Type function spills for Modules Debugger.

Revision 1.43  1993/08/13  15:42:29  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.42  1993/07/12  09:57:02  nosa
Changed Tags and LETs for local and closure variable inspection
in the debugger.

Revision 1.41  1993/03/10  16:01:16  matthew
Signature revisions

Revision 1.40  1993/03/04  11:58:26  jont
Removed LVar_eq in favour of polymorphic equality, which work rather better
on MLWorks.

Revision 1.39  1993/03/01  14:01:03  matthew
Added MLVALUE lambda exp

Revision 1.38  1992/11/03  11:47:59  daveb
Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.

Revision 1.37  1992/10/29  18:01:47  jont
Added IntNewMap parameter for constructing more efficient maps

Revision 1.36  1992/10/02  16:14:10  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.35  1992/09/21  10:39:20  clive
Changed hashtables to a single structure implementation

Revision 1.34  1992/08/26  11:45:43  jont
Removed some redundant structures and sharing

Revision 1.33  1992/08/19  16:26:28  davidt
Added LVar_ordering function.

Revision 1.32  1992/07/29  09:54:34  clive
Changed the bindingtable to be a hashtable

Revision 1.31  1992/07/17  10:44:08  clive
null_type_annotation is no longer a function

Revision 1.30  1992/07/01  12:42:06  davida
Added LET constructor and new slot to APP.

Revision 1.29  1992/06/23  09:24:17  clive
Added an annotation slot to HANDLE

Revision 1.28  1992/06/11  08:34:18  clive
Added datatype recording to the FNexp for the debugger and annotated LETs with
a string to be used as the annotation when they are converted into Fnexps

Revision 1.27  1992/04/22  13:24:24  clive
Speed improvement

Revision 1.26  1992/04/14  16:07:03  clive
First version of the profiler

Revision 1.25  1992/02/26  11:54:24  jont
Added an lvar equality function, since polymorphic equality is so slow

Revision 1.24  1992/01/29  11:15:03  clive
Added the routines for calculating the next and previous Lvar after
a given lvar

Revision 1.23  1992/01/28  12:32:28  clive
Added a function to give the previous lambda variable

Revision 1.22  1992/01/06  11:49:38  jont
Added datatype binding to allow lets and recursive lets

Revision 1.21  1991/11/28  10:59:01  richard
Removed an unnecessary constraint on the Ident structure.

Revision 1.20  91/10/22  14:57:08  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.19  91/10/08  18:54:44  davidt
Changed the type LambdaExp so that record selection now retains the total
size of the record as well as just the index.

Revision 1.18  91/09/06  10:21:44  davida
Added LambdaInfo type for optimiser
and code-generator.

Revision 1.17  91/08/23  11:04:02  jont
Changed to use pervasives
Removed init_prim

Revision 1.16  91/08/23  09:36:39  davida
Added ordering on lambda-expressions.

Revision 1.15  91/08/15  10:33:22  davida
Added a comment to int_of_LVar to indicate the
assumptions made elsewhere about the values it
will return; namely that they will be positive
integers, increasing in order of calling new_LVar

Revision 1.14  91/08/14  12:40:44  davida
Added int_of_LVar function to help hashing on
lambda-expressions.

Revision 1.13  91/08/13  10:15:59  davida
Added comment to LVar_order ordering function to make
explicit the assumption made elsewhere about the
ordering  (i.e. older lambda variables order before
newer ones).

Revision 1.12  91/07/25  09:56:20  jont
Added ordering on LVars and Primitives to allow them to be domains in maps

Revision 1.11  91/07/16  14:32:59  jont
> Added EXP_TAG type to Construc and changed its name to Tag,
in order to code generate dynamic switches for exception matching

Revision 1.10  91/07/11  11:02:34  jont
New LETREC with expression in it again.

Revision 1.9  91/07/10  11:15:07  jont
Corrected definition of new_Prim to return Primitive rather than LVar

Revision 1.8  91/07/09  12:10:06  jont
Added fromField to get ints back from Fields

Revision 1.7  91/06/26  18:35:03  jont
Added primitive generation for unique ids

Revision 1.6  91/06/26  16:12:26  jont
Changed LETERC to reflect declarative nature of ML ie no "in" expression

Revision 1.5  91/06/19  11:41:00  jont
Made LVar, Field, Primitive eqtypes to allow comparison in _lambda

Revision 1.4  91/06/18  19:05:00  jont
Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor

Revision 1.3  91/06/18  13:37:00  jont
Added INT to lambda calculus for nullary constructors in expressions

Revision 1.2  91/06/11  16:56:12  jont
Abstracted out the types from the functions

Revision 1.1  91/06/11  11:40:18  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/set";
require "../basics/ident";

signature LAMBDATYPES = sig
  structure Set : SET
  structure Ident : IDENT

  type Type
  type Tyfun
  type Instance
  type Structure
  type DebuggerStr
  type FunInfo
  type VarInfo

  eqtype LVar
  eqtype Field
  eqtype Primitive

  datatype StructType = STRUCTURE | TUPLE | CONSTRUCTOR

  datatype Status = ENTRY | BODY | FUNC

  datatype Tag =
    VCC_TAG of string * int     (* value carrying constructor *)
  | IMM_TAG of string * int     (* constant constructor *)
  | SCON_TAG of Ident.SCon * int option
			(* simple int, real, string ... *)
			(* The int option gives the size of numeric types *)
  | EXP_TAG of LambdaExp(* more complex tag, for dynamic switching *)

  and LambdaExp =
    VAR of LVar         (* variable lookup *)
  | FN of ((LVar list * LVar list) * LambdaExp * Status * string * Type * FunInfo)
                        (* Function definition *)
  | LET of (LVar * VarInfo ref option * LambdaExp) * LambdaExp
  | LETREC of (LVar * VarInfo ref option) list * LambdaExp list * LambdaExp
  | APP of (LambdaExp * (LambdaExp list * LambdaExp list) * Type ref option)
    			(* Function application.  Input to the optimiser should
			   have a single argument (make a struct for functions
			   that take multiple arguments). *)
  | SCON of Ident.SCon * int option     
			(* int, real, string as strings *)
			(* The int option gives the size of numeric types *)
  | MLVALUE of MLWorks.Internal.Value.ml_value (* immediate constants *)
  | INT of int          (* int as int (for tags) *)
  | SWITCH of LambdaExp * {num_vccs: int, num_imms: int} option *
		(Tag * LambdaExp) list * LambdaExp option
  			(* The second argument contains enough information
			   about the type being matched for the code generator
			   to choose an appropriate representation.  *)
  | STRUCT of LambdaExp list * StructType 
			(* structure definition *)
  | SELECT of {index : int, size : int, selecttype : StructType} * LambdaExp
			(* field selector *)
  | RAISE of LambdaExp  (* Exceptions --- throw ... *)
  | HANDLE of (LambdaExp * LambdaExp * string)
			(* ... and catch *)
  | BUILTIN of Primitive(* built-in functions -- These functions are
			   primitive to the abstract machine. *)

  datatype binding =
    LETB of (LVar * VarInfo ref option * LambdaExp) |
    RECLETB of (LVar * VarInfo ref option) list * LambdaExp list

  datatype Dec = 
    VAL of LambdaExp |
    FUNCTOR of LVar * string * ((LVar * VarInfo ref option * Dec) list * LambdaExp)
      
  datatype program =
    PROGRAM of (LVar * VarInfo ref option * Dec) list * LambdaExp
      
  val do_binding : binding * LambdaExp -> LambdaExp

  val new_LVar: unit -> LVar
  val init_LVar: unit -> unit
  val reset_counter: int -> unit
  val read_counter: unit -> int

  val lvar_to_int : LVar -> int

  val printLVar: LVar -> string
  val printPrim: Primitive -> string
  val printField: {index : int, size : int,selecttype : StructType} -> string

  val null_type_annotation : Type 
  val user_funinfo : FunInfo
  val internal_funinfo : FunInfo
  val isLocalFn : FunInfo -> bool

  val telfun : (LambdaExp -> LambdaExp) -> (Tag * LambdaExp) -> (Tag * LambdaExp)

end
@


1.56.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.56  1999/02/09  09:50:01  mitchell
 * [Bug #190505]
 * Support for precompilation of subprojects
 *
@


1.55
log
@Adding isLocalFn function
@
text
@d4 3
d270 2
@


1.55.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.55  1996/12/02  13:36:44  matthew
 * Adding isLocalFn function
 *
@


1.55.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.55  1996/12/02  13:36:44  matthew
 * Adding isLocalFn function
 *
@


1.55.1.1
log
@branched from 1.55
@
text
@a3 3
 * Revision 1.55  1996/12/02  13:36:44  matthew
 * Adding isLocalFn function
 *
@


1.55.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:35:04  hope
 * branched from 1.55
 *
@


1.55.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:35:04  hope
 * branched from 1.55
 *
@


1.55.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:35:04  hope
 * branched from 1.55
 *
@


1.55.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.55.1.1.1.1  1997/07/28  18:20:26  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.54
log
@[Bug #1634]

Tidying up
@
text
@d4 5
d212 2
d217 1
a217 1
  | SCON_TAG of Ident.SCon * int MLWorks.Option.option
d224 1
a224 1
  | FN of (LVar list * LambdaExp * string * Type * FunInfo)
d226 3
a228 4
  | LET of (LVar * VarInfo ref MLWorks.Option.option * LambdaExp) * LambdaExp
  | LETREC of (LVar * VarInfo ref MLWorks.Option.option) list *
		LambdaExp list * LambdaExp
  | APP of (LambdaExp * LambdaExp list * Type ref MLWorks.Option.option)
d232 1
a232 1
  | SCON of Ident.SCon * int MLWorks.Option.option     
d237 2
a238 2
  | SWITCH of LambdaExp * {num_vccs: int, num_imms: int} MLWorks.Option.option *
		(Tag * LambdaExp) list * LambdaExp MLWorks.Option.option
d253 2
a254 2
    LETB of (LVar * VarInfo ref MLWorks.Option.option * LambdaExp) |
    RECLETB of (LVar * VarInfo ref MLWorks.Option.option) list * LambdaExp list
d256 7
d277 3
@


1.54.6.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.54.5.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.54.5.1.1.1
log
@branched from 1.54.5.1
@
text
@a3 3
 * Revision 1.54.5.1  1996/12/17  17:48:35  hope
 * branched from 1.54
 *
@


1.54.4.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.54.3.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.54.3.1.1.1
log
@branched from 1.54.3.1
@
text
@a3 3
 * Revision 1.54.3.1  1996/11/14  12:50:33  hope
 * branched from 1.54
 *
@


1.54.2.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.54.1.1
log
@branched from 1.54
@
text
@a3 5
 * Revision 1.54  1996/10/04  13:47:06  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.53
log
@Change newhashtable to hashtable
@
text
@d4 3
a186 1
require "../utils/hashtable";
@


1.53.1.1
log
@branched from 1.53
@
text
@a3 3
 * Revision 1.53  1996/02/26  11:20:26  jont
 * Change newhashtable to hashtable
 *
@


1.52
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
d184 1
a184 1
require "../utils/newhashtable";
@


1.51
log
@Add lvar_to_int function for using lvars with int hash tables
@
text
@d4 3
a180 1
require "../utils/option";
a185 1
  structure Option : OPTION
@


1.50
log
@Simplifying
@
text
@d4 3
d247 2
@


1.49
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
a173 1
require "../utils/mononewmap";
a179 1
  structure Map : MONONEWMAP
a191 1
  sharing type LVar = Map.object
a194 1
    
a242 1
  val dummy_lvar : LVar
d244 1
a245 4
  val LVar_order: LVar * LVar -> bool      (* older order before newer    *)
  val int_of_LVar : LVar -> int            (* non-negative value, old=low *)
  val LVar_previous : LVar -> LVar
  val LVar_next : LVar -> LVar
a247 15

  val expr_order : LambdaExp * LambdaExp -> bool


  (*  A Type Used in Optimisation  *)

  structure NewHashTable : NEWHASHTABLE

  datatype LambdaInfo = Info of {bindings : (LVar,LambdaExp) NewHashTable.HashTable,
				 known_fns : LVar Set.Set,
				 non_escaping_fns : LVar Set.Set,
				 is_shiftable : LambdaExp -> bool,
				 is_commutative : LambdaExp -> bool,
				 is_associative : LambdaExp -> bool}

@


1.48
log
@More information in FunInfo types
@
text
@d4 3
d199 6
a204 4
    VCC_TAG of string * int           (* value carrying constructor *)
  | IMM_TAG of string * int	     (* constant constructor *)
  | SCON_TAG of Ident.SCon  (* simple int, real, string ... *)
  | EXP_TAG of LambdaExp     (* more complex tag, for dynamic switching *)
d207 1
a207 2
    VAR of LVar                       (* variable lookup *)
                                      (* function definition *)
d209 11
a219 4
  | LET of (LVar * VarInfo ref Option.opt * LambdaExp) * LambdaExp
  | LETREC of (LVar * VarInfo ref Option.opt) list * LambdaExp list * LambdaExp
  | APP of (LambdaExp * LambdaExp list * Type ref Option.opt)  (* function application *)
  | SCON of Ident.SCon      (* int, real, string as strings *)
d221 16
a236 14
  | INT of int                        (* int as int (for tags) *)
    (* like a case statement *)
  | SWITCH of LambdaExp * {num_vccs: int, num_imms: int} Option.opt * (Tag * LambdaExp) list * LambdaExp Option.opt
  (* The second argument contains enough information about the type being
     matched for the code generator to choose an appropriate representation.
  *)
  | STRUCT of LambdaExp list * StructType         (* structure definition *)
  | SELECT of {index : int, size : int, selecttype : StructType} * LambdaExp     (* field selector *)
  | RAISE of LambdaExp              (* Exceptions --- throw ... *)
  | HANDLE of (LambdaExp * LambdaExp * string) (*            ... and catch *)
  | BUILTIN of Primitive              (* built-in functions --
				         These functions are
				         primitive to the abstract
				         machine. *)
d238 2
a239 2
    LETB of (LVar * VarInfo ref Option.opt * LambdaExp) |
    RECLETB of (LVar * VarInfo ref Option.opt) list * LambdaExp list
@


1.47
log
@Simplifications of lambda expressions
@
text
@d4 3
d204 1
a204 1
  | FN of (LVar list * LambdaExp * string * Type * FunInfo Option.opt)
d257 2
@


1.46
log
@Abstraction of debug information
@
text
@d4 3
d189 3
d202 1
a202 1
  | LET of (LVar * VarInfo ref Option.opt * LambdaExp * LambdaExp)
d213 2
a214 2
  | STRUCT of LambdaExp list          (* structure definition *)
  | SELECT of {index : int, size : int} * LambdaExp     (* field selector *)
d222 1
a222 2
    (* this string redundant now. *)
    LETB of (LVar * VarInfo ref Option.opt * LambdaExp * string) |
d236 1
a236 1
  val printField: {index : int, size : int} -> string
@


1.45
log
@Functions and applications take a list of parameters
@
text
@d4 3
d178 2
d195 3
a197 12
  | FN of (LVar list * LambdaExp * string * Type * 
          ((int * Type * Instance) ref list * (int,int) Option.option ref Option.opt) Option.opt)
  | LET of ((LVar,(LVar * (string * (Type * Instance ref Option.opt 
                                     * (Tyfun ref * (int,int) Option.option ref) list) ref 
                        * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
            * LambdaExp * LambdaExp)
    (* non-rec defs *)
  | LETREC of                        (* allows recursive definitions *)
    ((LVar,(LVar * (string * (Type * Instance ref Option.opt 
                              * (Tyfun ref * (int,int) Option.option ref) list) ref 
                  * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
     * LambdaExp list * LambdaExp)
d202 2
a203 5
  | SWITCH of                         (* like a case statement *)
      LambdaExp *
      {lv: LVar, num_vccs: int, num_imms: int} Option.opt *
      (Tag * LambdaExp) list *
      LambdaExp Option.opt
a205 1
     The LVar is bound to the argument of a value carrying constructor.
d216 3
a218 8
    LETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt 
                                     * (Tyfun ref * (int,int) Option.option ref) list) ref 
                        * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
    * LambdaExp * string |   (* this string redundant now. *)
    RECLETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt
                                        * (Tyfun ref * (int,int) Option.option ref) list) ref 
                  * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
    * LambdaExp list
a221 4
  val fetch_var : (LVar,(LVar * (string * (Type * Instance ref Option.opt
                                        * (Tyfun ref * (int,int) Option.option ref) list) ref 
                                 * (int,int) Option.option ref Option.opt) 
    Option.opt) ref) Option.option -> LVar
d223 1
@


1.44
log
@Type function spills for Modules Debugger.
@
text
@d4 3
d190 1
a190 1
  | FN of (LVar * LambdaExp * string * Type * 
d202 1
a202 1
  | APP of (LambdaExp * LambdaExp * Type ref Option.opt)  (* function application *)
@


1.43
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d168 1
d170 2
d188 4
a191 3
           ((int * Type * Instance) ref list * (int,int) Option.option ref Option.opt) Option.opt)
  | LET of ((LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                           * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
d195 3
a197 2
    ((LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                    * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
d221 3
a223 2
    LETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                           * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option 
d225 3
a227 2
    RECLETB of (LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                              * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option list 
d232 4
a235 2
  val fetch_var : (LVar,(LVar * (string * (Type * Instance ref Option.opt) ref 
                                 * (int,int) Option.option ref Option.opt) Option.opt) ref) Option.option -> LVar
@


1.42
log
@Changed Tags and LETs for local and closure variable inspection
in the debugger.
@
text
@d4 4
d164 1
d180 4
a183 2
  | FN of (LVar * LambdaExp * string * Type)
  | LET of ((LVar,(LVar * (string * Type ref) Option.opt)ref) Option.option 
d187 2
a188 1
    ((LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option list 
d212 2
a213 1
    LETB of (LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option 
d215 2
a216 1
    RECLETB of (LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option list 
d221 2
a222 1
  val fetch_var : (LVar,(LVar * (string * Type ref) Option.opt) ref) Option.option -> LVar
@


1.42.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.42  1993/07/12  09:57:02  nosa
Changed Tags and LETs for local and closure variable inspection
in the debugger.

@


1.41
log
@Signature revisions
@
text
@d4 3
d150 1
d157 1
a164 1
  datatype 'a Opt = PRESENT of 'a | ABSENT
d167 2
a168 2
    VCC_TAG of int           (* value carrying constructor *)
  | IMM_TAG of int	     (* constant constructor *)
d176 7
a182 4
  | LET of (LVar * LambdaExp * LambdaExp)   (* non-rec defs *)
  | LETREC of                         (* allows recursive definitions *)
    (LVar list * LambdaExp list * LambdaExp)
  | APP of (LambdaExp * LambdaExp * Type)  (* function application *)
d188 1
a188 1
      {lv: LVar, num_vccs: int, num_imms: int} Opt *
d190 1
a190 1
      LambdaExp Opt
d197 1
a197 1
  | RAISE of LambdaExp                (* Exceptions --- throw ... *)
d204 4
a207 2
    LETB of LVar * LambdaExp * string |     (* this string redundant now. *)
    RECLETB of LVar list * LambdaExp list
d211 1
d237 1
a237 1
  val null_type_annotation : Type
@


1.40
log
@Removed LVar_eq in favour of polymorphic equality, which work rather better
on MLWorks.
@
text
@d4 4
a145 1
require "../typechecker/datatypes" ;
d147 1
a150 1
  structure Datatypes : DATATYPES
d152 3
d165 1
a165 1
  | SCON_TAG of Datatypes.Ident.SCon  (* simple int, real, string ... *)
d171 1
a171 1
  | FN of (LVar * LambdaExp * string * Datatypes.Type)
d175 2
a176 2
  | APP of (LambdaExp * LambdaExp * Datatypes.Type)  (* function application *)
  | SCON of Datatypes.Ident.SCon      (* int, real, string as strings *)
d227 1
a227 1
  val null_type_annotation : Datatypes.Type
@


1.39
log
@Added MLVALUE lambda exp
@
text
@d4 3
a198 1
  val LVar_eq: LVar * LVar -> bool
@


1.38
log
@Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.
@
text
@d4 4
d168 1
@


1.37
log
@Added IntNewMap parameter for constructing more efficient maps
@
text
@d4 3
d148 1
d150 3
a152 2
    CON_TAG of int           (* basic datatype tagging type *)
  | SCON_TAG of Datatypes.Ident.SCon   (* simple int, real, string ... *)
d154 1
d163 1
a163 1
  | SCON of Datatypes.Ident.SCon                (* int, real, string as strings *)
d166 8
a173 5
    (LambdaExp * (Tag * LambdaExp) list * LambdaExp Opt * LambdaExp Opt)
                                      (* First default for constructor not in
				         in list, second for not a constructor
					 so we can efficiently check for
					 non-nullary constructors *)
@


1.36
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d131 1
d138 2
d141 1
a183 1
  val LVar_ordering: LVar * LVar -> bool   (* older order before newer    *)
@


1.35
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d177 1
a177 1
  val LVar_ordering: LVar * LVar -> Datatypes.NewMap.relation (* older order before newer    *)
@


1.34
log
@Removed some redundant structures and sharing
@
text
@d4 3
d186 1
a186 1
  structure BindingTable : NEWHASHTABLE
d188 1
a188 1
  datatype LambdaInfo = Info of {bindings : BindingTable.HashTable,
@


1.33
log
@Added LVar_ordering function.
@
text
@d4 3
a121 1
require "../basics/ident";
a126 1
  structure Ident: IDENT
d134 1
a134 1
  | SCON_TAG of Ident.SCon   (* simple int, real, string ... *)
d144 1
a144 1
  | SCON of Ident.SCon                (* int, real, string as strings *)
@


1.32
log
@Changed the bindingtable to be a hashtable
@
text
@d4 3
d170 1
@


1.31
log
@null_type_annotation is no longer a function
@
text
@d4 3
d118 1
d178 3
a180 11
  structure BindingTable : 
    sig
      type Table
      exception Undefined
      val empty : unit -> Table
      val define : Table * LVar * LambdaExp -> Table
      val apply : Table -> LVar -> LambdaExp
      val to_list : Table -> (LVar * LambdaExp) list
    end
    
  datatype LambdaInfo = Info of {bindings : BindingTable.Table,
@


1.30
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d192 1
a192 1
  val null_type_annotation : unit -> Datatypes.Type
@


1.29
log
@Added an annotation slot to HANDLE
@
text
@d4 3
d128 2
a129 1
  | FN of (LVar * LambdaExp * string * Datatypes.Type) 
d132 1
a132 1
  | APP of (LambdaExp * LambdaExp)    (* function application *)
d150 3
a152 2
    LET of LVar * LambdaExp * string |
    RECLET of LVar list * LambdaExp list
d154 1
@


1.28
log
@Added datatype recording to the FNexp for the debugger and annotated LETs with
a string to be used as the annotation when they are converted into Fnexps
@
text
@d4 4
d140 1
a140 1
  | HANDLE of (LambdaExp * LambdaExp) (*            ... and catch *)
@


1.27
log
@Speed improvement
@
text
@d4 3
d104 1
d109 1
d120 2
a121 1
  | FN of (LVar * LambdaExp * string) (* function definition *)
d142 1
a142 1
    LET of LVar * LambdaExp |
d155 1
d177 3
@


1.26
log
@First version of the profiler
@
text
@d4 3
d154 11
a164 1
  datatype LambdaInfo = Info of {bindings : (LVar * LambdaExp) list,
d170 1
@


1.25
log
@Added an lvar equality function, since polymorphic equality is so slow
@
text
@d4 3
d112 1
a112 1
  | FN of (LVar * LambdaExp)          (* function definition *)
@


1.24
log
@Added the routines for calculating the next and previous Lvar after
a given lvar
@
text
@d4 4
d136 1
@


1.23
log
@Added a function to give the previous lambda variable
@
text
@d4 3
d135 1
@


1.22
log
@Added datatype binding to allow lets and recursive lets
@
text
@d4 3
d131 1
@


1.21
log
@Removed an unnecessary constraint on the Ident structure.
@
text
@d3 4
a6 1
$Log:	lambdatypes.sml,v $
d119 4
@


1.20
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d4 3
d85 1
a85 1
  structure Ident: IDENTCLASS
@


1.19
log
@Changed the type LambdaExp so that record selection now retains the total
size of the record as well as just the index.
@
text
@d4 4
a85 2
  exception impossible of string
  exception not_done_yet of string
@


1.18
log
@Added LambdaInfo type for optimiser
and code-generator.
@
text
@d4 4
d104 1
a104 1
  | SELECT of (Field * LambdaExp)     (* field selector *)
d117 1
a117 3
  val printField: Field -> string
  val toField: int -> Field
  val fromField: Field -> int
@


1.17
log
@Changed to use pervasives
Removed init_prim
@
text
@d4 4
d69 1
d73 1
d117 10
@


1.16
log
@Added ordering on lambda-expressions.
@
text
@d4 3
a101 3
(*
  val alter_LVar_count: LVar -> unit
*)
a105 2
  val new_Prim: unit -> Primitive
  val init_Prim: unit -> unit
a106 1
  val Prim_order: Primitive * Primitive -> bool
@


1.15
log
@Added a comment to int_of_LVar to indicate the
assumptions made elsewhere about the values it
will return; namely that they will be positive
integers, increasing in order of calling new_LVar
@
text
@d4 6
d113 1
@


1.14
log
@Added int_of_LVar function to help hashing on
lambda-expressions.
@
text
@d4 4
d98 2
a99 2
  val LVar_order: LVar * LVar -> bool      (* older order before newer *)
  val int_of_LVar : LVar -> int            (* handy for hash functions *)
@


1.13
log
@Added comment to LVar_order ordering function to make
explicit the assumption made elsewhere about the
ordering  (i.e. older lambda variables order before
newer ones).
@
text
@d4 6
d95 1
@


1.12
log
@Added ordering on LVars and Primitives to allow them to be domains in maps
@
text
@d4 3
d88 1
a88 1
  val LVar_order: LVar * LVar -> bool
@


1.11
log
@> Added EXP_TAG type to Construc and changed its name to Tag,
in order to code generate dynamic switches for exception matching
@
text
@d4 4
d80 1
d82 1
d85 1
d89 1
@


1.10
log
@New LETREC with expression in it again.
@
text
@d4 3
d49 1
a49 1
  datatype Construc =
d52 2
a53 1
  datatype LambdaExp =
d62 1
a62 1
    (LambdaExp * (Construc * LambdaExp) list * LambdaExp Opt * LambdaExp Opt)
@


1.9
log
@Corrected definition of new_Prim to return Primitive rather than LVar
@
text
@d4 3
d53 1
a53 2
    (LVar list * LambdaExp list (** LambdaExp*))
                                      (* Extra LambdaExp not required *)
@


1.8
log
@Added fromField to get ints back from Fields
@
text
@d4 3
d73 1
a73 1
  val new_Prim: unit -> LVar
@


1.7
log
@Added primitive generation for unique ids
@
text
@d4 3
d75 1
@


1.6
log
@Changed LETERC to reflect declarative nature of ML ie no "in" expression
@
text
@d4 3
d67 2
@


1.5
log
@Made LVar, Field, Primitive eqtypes to allow comparison in _lambda
@
text
@d4 3
d41 2
a42 1
    (LVar list * LambdaExp list * LambdaExp)
@


1.4
log
@Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor
@
text
@d4 5
d25 3
a27 3
  type LVar
  type Field
  type Primitive
@


1.3
log
@Added INT to lambda calculus for nullary constructors in expressions
@
text
@d4 3
d38 5
a42 1
    (LambdaExp * (Construc * LambdaExp) list * LambdaExp Opt)
@


1.2
log
@Abstracted out the types from the functions
@
text
@d4 3
d32 2
a33 1
  | SCON of Ident.SCon                (* int, real, string ... *)
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d46 1
@
