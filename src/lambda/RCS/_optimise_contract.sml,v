head	1.60;
access;
symbols
	ML_beta_release_12/08/94:1.58
	ML_beta_release_03/08/94:1.58
	ML_revised_beta_release_25/05/94:1.57
	ML_final_beta_release_02/03/94:1.57
	mlworks-28-01-1994:1.57
	Release:1.56
	mlworks-beta-01-09-1993:1.56
	MLWorks-1-0-4-29/01/1993:1.49
	MLWorks-1-0-3-21/12/1992:1.49
	MLWorks-1-0-2-15/12/1992:1.49
	MLWorks-1-0-1-04/12/1992:1.49
	checkpoint_17_08_92:1.39;
locks; strict;
comment	@ * @;


1.60
date	94.10.10.09.45.50;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	94.09.19.14.19.20;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	94.07.19.14.14.03;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	93.09.03.10.16.59;	author nosa;	state Exp;
branches;
next	1.56;

1.56
date	93.07.14.15.28.54;	author nosa;	state Exp;
branches
	1.56.1.1;
next	1.55;

1.55
date	93.05.19.16.51.30;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	93.05.18.15.54.35;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	93.05.18.12.15.36;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	93.03.10.16.24.17;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	93.03.03.17.44.38;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	93.03.01.15.14.04;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	92.12.03.12.19.55;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	92.11.20.12.35.19;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	92.11.19.16.30.50;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	92.11.09.16.11.12;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.10.28.12.31.52;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	92.09.23.14.08.05;	author clive;	state Exp;
branches;
next	1.43;

1.43
date	92.09.22.13.25.09;	author clive;	state Exp;
branches;
next	1.42;

1.42
date	92.09.21.12.06.03;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.09.16.10.01.09;	author clive;	state Exp;
branches;
next	1.40;

1.40
date	92.08.26.13.05.51;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.08.06.16.44.31;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.07.29.10.15.12;	author clive;	state Exp;
branches;
next	1.37;

1.37
date	92.07.24.13.34.32;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.07.22.12.31.37;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.07.17.14.04.33;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.07.15.14.07.09;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.07.14.11.18.07;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.07.10.15.42.55;	author davida;	state Exp;
branches;
next	1.31;

1.31
date	92.07.09.18.13.31;	author davida;	state Exp;
branches;
next	1.30;

1.30
date	92.07.08.16.14.13;	author davida;	state Exp;
branches;
next	1.29;

1.29
date	92.07.06.12.29.16;	author davida;	state Exp;
branches;
next	1.28;

1.28
date	92.06.29.10.11.17;	author davida;	state Exp;
branches;
next	1.27;

1.27
date	92.06.23.09.47.16;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.06.15.17.12.28;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.06.03.15.08.57;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.05.22.16.53.50;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.05.14.09.24.37;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.04.30.09.19.35;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.04.23.15.04.37;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.04.13.14.25.04;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.03.27.10.45.49;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.03.06.14.38.08;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.02.27.17.55.40;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.02.05.16.43.39;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.01.03.15.45.55;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.11.28.17.37.03;	author richard;	state Exp;
branches;
next	1.13;

1.13
date	91.11.08.19.04.03;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.10.28.15.39.18;	author davidt;	state Exp;
branches;
next	1.11;

1.11
date	91.10.24.10.36.40;	author davidt;	state Exp;
branches;
next	1.10;

1.10
date	91.10.22.18.07.33;	author davidt;	state Exp;
branches;
next	1.9;

1.9
date	91.10.22.14.38.45;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	91.10.09.14.59.20;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	91.09.24.15.00.52;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	91.09.23.16.06.11;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.09.16.16.45.11;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.09.12.14.40.27;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.09.11.11.23.28;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.09.10.17.25.09;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.06.14.03.48;	author davida;	state Exp;
branches;
next	;

1.56.1.1
date	93.07.14.15.28.54;	author jont;	state Exp;
branches;
next	;


desc
@Strictly contracting optimisations
@


1.60
log
@Lambdatypes changes
@
text
@
(*
 * Lambda-Calculus Optimisation: _optimise_contract
 *
 * Contraction-phase Optimisations:
 * simple beta-reduction/eta-reduction,
 * select-elimination, struct-elimination,
 * switch-elmination, application reorder.
 *
 * Copyright (c) 1991 Harlequin Ltd.
 *)

(*
$Log: _optimise_contract.sml,v $
Revision 1.59  1994/09/19  14:19:20  matthew
Abstraction of debug information in lambdatypes

Revision 1.58  1994/07/19  14:14:03  matthew
Lists of arguments for APP

Revision 1.57  1993/09/03  10:16:59  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.56  1993/07/14  15:28:54  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.55  1993/05/19  16:51:30  jont
Improved pattern match in switch_elim

Revision 1.54  1993/05/18  15:54:35  jont
Removed integer parameter

Revision 1.53  1993/05/18  12:15:36  jont
Fixed switch_elim to optimise switches on manifest lists

Revision 1.52  1993/03/10  16:24:17  matthew
Signature revisions

Revision 1.51  1993/03/03  17:44:38  jont
Removed LVar_eq in favour of polymorphic equality

Revision 1.50  1993/03/01  15:14:04  matthew
Added MLVALUE lambda exp

Revision 1.49  1992/12/03  12:19:55  matthew
Commented out calls to print_deletion_message.
,.

Revision 1.48  1992/11/20  12:35:19  jont
Modified switch_elim to move LETs in the switch expression outside

Revision 1.47  1992/11/19  16:30:50  daveb
Fixed bug in eliminate_simple_nested_cons, exposed by improvements in
letrec elimination and switch nesting.  Also allowed more optimisations
on SCON switches.

Revision 1.46  1992/11/09  16:11:12  clive
Added some LETREC optimisation

Revision 1.45  1992/10/28  12:31:52  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.44  1992/09/23  14:08:05  clive
Added optimisations in switch_weed and switch_elim

Revision 1.43  1992/09/22  13:25:09  clive
Changes for the newhashtables

Revision 1.42  1992/09/21  12:06:03  clive
Changed hashtables to a single structure implementation

Revision 1.41  1992/09/16  10:01:09  clive
Got rid of handles involving hash tables

Revision 1.40  1992/08/26  13:05:51  jont
Removed some redundant structures and sharing

Revision 1.39  1992/08/06  16:44:31  clive
Fix to let case of raise_cut

Revision 1.38  1992/07/29  10:15:12  clive
Changed the bindingtable to be a hashtable

Revision 1.37  1992/07/24  13:34:32  clive
Modified to use the new hashtables

Revision 1.36  1992/07/22  12:31:37  jont
Removed references to Lists.foldl and Lists.foldr

Revision 1.35  1992/07/17  14:04:33  clive
More work on type propogation

Revision 1.34  1992/07/15  14:07:09  clive
Another fix to switch_weed - if an expr gave us default or pointer case before,
this cannot be used to weed things later

Revision 1.33  1992/07/14  11:18:07  clive
Problem in the switch_weeding code fixed

Revision 1.32  1992/07/10  15:42:55  davida
Fix in switch_weed for case that I didn't think occurred,
triming of beta reduction.

Revision 1.31  1992/07/09  18:13:31  davida
Tidied things up, added switch_weed optimisation.

Revision 1.30  1992/07/08  16:14:13  davida
General tidying up.

Revision 1.29  1992/07/06  12:29:16  davida
Added LET constructor and new slot to APP.
Fixed bug in raise_cut where the body of
a LETREC was ignored, so HANDLES were being lost.

Revision 1.28  1992/06/29  10:11:17  davida
Eta-reduction now combined with beta-reduction.  Switch elimination
on exceptions re-added.  Removed backwards elim from struct elim.
Improved efficiency of letrec elim.
Other miscellaneous tidying.

Revision 1.27  1992/06/23  09:47:16  clive
Added an annotation slot to HANDLE

Revision 1.26  1992/06/15  17:12:28  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.26  1992/06/15  13:52:58  davida
Changed lambda_print.

Revision 1.25  1992/06/03  15:08:57  clive
Added type annotations to FNexp

Revision 1.24  1992/05/22  16:53:50  jont
Only allowed structure elimination for structures of the same size,
rather than leading substructures. This is because allowing a
structure to be replaced by a larger one of which it is a leading
substructure breaks polymorphic equality, as firstly the tags may be
inconsistent, and secondly the size requires more working out.

Revision 1.23  1992/05/14  09:24:37  clive
Added delayed substitution to beta-reduce to speed up the constant list case by a factor of
5+

 *)

require "../utils/crash";
require "../utils/lists";
require "../utils/print";
require "../main/pervasives";
require "../debugger/debugger_types";
require "lambdasub";
require "lambdaprint";
require "optimise_contract";

functor OptimiseContract(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Print : PRINT
  structure Pervasives : PERVASIVES
  structure LambdaSub : LAMBDASUB
  structure LambdaPrint : LAMBDAPRINT
  structure Debugger_Types : DEBUGGER_TYPES

  sharing LambdaSub.LT = LambdaPrint.LambdaTypes

  sharing type Pervasives.pervasive = LambdaPrint.LambdaTypes.Primitive 
  sharing type LambdaPrint.LambdaTypes.Type = Debugger_Types.Type
  sharing type LambdaPrint.LambdaTypes.LVar = int
    ) : OPTIMISE_CONTRACT =
struct

  (* preamble *)

  structure LS = LambdaSub
  structure LT = LS.LT
  structure Set = LT.Set
  structure Ident = LT.Ident
  structure NewHashTable = LT.NewHashTable
  structure Option = LT.Option

  val print_hash_table_stats = LS.print_hash_table_stats

  fun fst(x,_)=x and snd(_,y)=y
  fun swap f (x,y) = f (y,x)
  fun curry f x y = f (x,y)
  and uncurry f (x,y) = f x y
  fun apfst f (x,y) = (f x, y)
  and apsnd f (x,y) = (x, f y)


  val mem = Set.is_member
  val ==  = Set.seteq
  val ++  = swap Set.add_member
  fun -- (S,a) = Set.setdiff (S, Set.singleton a)
  infix ++ -- == mem

  val show_debug_info = ref true;
  fun info message = if !show_debug_info then Print.print message else ()


  (*-----------------------------------------------------------*)
  (*  Strictly contracting optimisations.		       *)
  (*  Transformations are non-recursive: they are applied to   *)
  (*  the outermost lambda-expression only.                    *)
  (*-----------------------------------------------------------*)

  (********************************************************)
  (* Beta and Eta reduction -- eliminate lambda-variables *)
  (********************************************************)

  (* occurrence counts are calculated from the inside out *)


        (* 
           Important note: I hope this is right - we may delay the substitutions even 
           though we test things for shiftability because the things that we substitute 
           in are always shiftables... i.e the variable that represents them is is_shiftable
           and this correctly reflects the value that would occur if the substitution had
           been made.
             *)

        fun beta_reduce expression =
	  let 
            val occcounthashtable = NewHashTable.new(256,op = : int * int -> bool,fn x => x)
            val substtable = NewHashTable.new(256,op = : int * int -> bool,fn x => x)

            fun adjuster_function (v:int) =
              (fn (copy as LT.VAR(var)) =>
               let
                 val x = NewHashTable.lookup(occcounthashtable,var)
               in
                 (NewHashTable.update(occcounthashtable,var,x+v);
                  copy)
               end
            | expression => expression)
              
            fun get_count var =
              NewHashTable.lookup_default(occcounthashtable,0,var) 
                
            fun increment_count (var,n) =
              NewHashTable.update(occcounthashtable,var,n + get_count var)
              
            fun adjust_counts (times,body) =
              LS.apply_innermost (adjuster_function times) body
              
            (* Instead of doing lots of single substitutions, it is better to do one walk *)
              
            fun do_substitutions exp =
              (let
                fun subst (exp as LT.VAR x) = 
                  (case NewHashTable.tryLookup(substtable,x) of
                     NewHashTable.NO => exp 
                   | NewHashTable.YES res => subst res)
                  | subst (LT.FN(lv,le,name,ty,instance)) = LT.FN(lv,subst le,name,ty,instance)
                  | subst (LT.LET((lv,info,lb),le)) = LT.LET((lv,info,subst lb),subst le)
                  | subst (LT.LETREC(lvl,lel,le)) =
                    LT.LETREC(lvl,map subst lel,subst le)
                  | subst (LT.APP(x,x',ty)) = LT.APP(subst x,map subst x',ty)
                  | subst (x as LT.SCON _) = x
                  | subst (x as LT.MLVALUE _) = x
                  | subst (x as LT.INT _) = x
                  | subst (LT.SWITCH(le,info,cle1,leo)) =
                    let
                      fun do_opt (LT.Option.PRESENT x) = LT.Option.PRESENT(subst x)
                        | do_opt (LT.Option.ABSENT) = LT.Option.ABSENT
                      fun do_tag (LT.EXP_TAG exp) = LT.EXP_TAG (subst exp)
                        | do_tag exp = exp
                    in
                      LT.SWITCH(subst le, 
				info,
                                map (fn (x,y) => (do_tag x,subst y)) cle1,
                                do_opt leo)
                    end
                  | subst (LT.STRUCT (els,ty)) = LT.STRUCT(map subst els,ty)
                  | subst (LT.SELECT(fld,exp)) = LT.SELECT(fld,subst exp)
                  | subst (LT.RAISE (le)) = LT.RAISE(subst le)
                  | subst (LT.HANDLE(le1,le2,annotation)) = 
                    LT.HANDLE(subst le1,subst le2,annotation)
                  | subst (x as LT.BUILTIN _) = x

            val result = subst exp
          in
            result
          end)
          
        fun add_substitution(x,y,z) =
          (NewHashTable.update(substtable,x,y); 
           z)
          
          fun really_is_a_var(x as LT.VAR x') =
            (case NewHashTable.tryLookup(substtable,x') of
               NewHashTable.NO => (true,x)
             | NewHashTable.YES res => really_is_a_var res)
            | really_is_a_var(x) = (false,x)

	    fun reduce (copy as LT.VAR(var)) = (increment_count(var,1) ; copy)

(*let/beta*)  | reduce (expr as LT.LET((var,info,arg),body)) =
                  (case really_is_a_var(arg) of
                     (true,LT.VAR var') => 
                       let
                         val count = get_count var
                       in
                         case count of
                           0 => (increment_count(var',~1); 
                                 (* LS.print_deletion_message arg; *)
                                 body)
                         | 1 => add_substitution(var,arg,body)
                         | _ => (increment_count(var',count - 1);
                                 add_substitution (var,arg,body))
                       end
                   | (_,arg) =>
                       let
                         val hashcount = get_count var

                       in
                         case hashcount of
                           0 => (if LS.is_shiftable arg
                                   then 
                                     (adjust_counts (~1,do_substitutions arg) ; 
                                      (* LS.print_deletion_message arg; *)
                                      body)
                                 else expr)
                         | 1 => if LS.is_shiftable arg
                                  then
                                    add_substitution(var,arg,body)
                                else expr
                         | _ => expr
                       end)

	      | reduce expr = expr

            val result =
              do_substitutions
              (LS.apply_innermost reduce expression)

	  in
            (if !print_hash_table_stats
               then (output(std_out,"OccCountHashTable in _optimise_contract: " ^
                            NewHashTable.string_hash_table_stats(occcounthashtable) ^ "\n");
                     output(std_out,"SubstTable in _optimise_contract: " ^
                            NewHashTable.string_hash_table_stats(substtable) ^ "\n"))
                 else ();
                   result)
	  end
        

  (***************************************************)
  (* Select-elimination -- removes redundant SELECTs *)
  (***************************************************)

  fun select_elim (LT.Info{bindings,is_shiftable,...}) expression =
    let
      fun select_and_drop_fields (fieldlist, index, size) =
	let
	  fun get_field (0, f::rest, unshifts) =
	      (rev unshifts, f, Lists.filter_outp is_shiftable rest)
	    | get_field (n, f::fs, unshifts) =
	      if is_shiftable f then get_field(n-1,fs,unshifts)
	      else get_field(n-1,fs,f::unshifts)
	    | get_field(n, _, _) =
	      Crash.impossible("select_elim: bad SELECT field number!" ^
			       "\nCalled with n = " ^
			       MLWorks.Integer.makestring index ^ " and list length " ^
			       MLWorks.Integer.makestring(Lists.length fieldlist) ^
			       "\n")

	  val (befores,f,afters) = get_field (index, fieldlist,[])

	  val (result,resultbinds) =
	    if is_shiftable f then (f,[]) else 
	      let 
		val resvar = LT.new_LVar()
	      in 
		(LT.VAR resvar, [(resvar, f)])
	      end
	   
	  fun pair_new expr = (LT.new_LVar(), expr)
	in
	  LS.wrap_lets(result, (map pair_new befores) @@  resultbinds @@
		       (map pair_new afters))
	end

      fun select_field (fieldlist,index,size) =
	(Lists.nth (index, fieldlist)
	 handle Lists.Nth => 
	   Crash.impossible
	   ("select_elim: bad SELECT field number!" ^
	    "\nCalled with n = " ^
	    MLWorks.Integer.makestring index ^ " and list length " ^
	    MLWorks.Integer.makestring(Lists.length fieldlist) ^
	    "\n"))

    in
      case expression of
	LT.SELECT({index,size,...},LT.STRUCT (field_list,_)) =>
	  select_and_drop_fields (field_list,index,size)

      | LT.SELECT({index,size,...}, LT.VAR var) =>
	  (case LT.NewHashTable.tryLookup(bindings,var) of
             LT.NewHashTable.YES res => 
               (case res of
                  LT.STRUCT (fieldlist,_) => 
                    let
                      val result = select_field (fieldlist,index,size)
                    in
                      if (is_shiftable result) then result
                      else expression
                    end
                | _ => expression)
           | LT.NewHashTable.NO => expression)
	      
      | _ => expression
    end


  (**************************************************)
  (*  Switch-Weeding.  Aimed at improving the code  *)
  (*  produced by the match compiler; may also      *)
  (*  be applicable after other optimisations.      *)
  (**************************************************)

  (* Some optimisations can only be done on constant tags, i.e. not EXP_TAGs. *)
  fun is_const_tag (LT.IMM_TAG _) = true
  |   is_const_tag (LT.VCC_TAG _) = true
  |   is_const_tag (LT.SCON_TAG _) = true
  |   is_const_tag _ = false


  local 
    exception NotSeen

    datatype path = CASE_DEF | TAG of LT.Tag

    fun find_path (wanted,paths) =
      let 
	fun f [] = raise NotSeen
	  | f ((expr,result)::cases) = if LS.lambda_equality(expr,wanted)
					 then result
				       else f cases
      in
	f paths
      end

    exception NotPresent of LT.Tag

    (* We can't find the tag in the list of cases, so see if we can return
       the default case *)

    fun return_default_if_possible(cases, tag, LT.Option.PRESENT default) =
      let fun first (a, _) = a
      in
        if is_const_tag tag andalso
	   Lists.forall (is_const_tag o first) cases
          then default
        else raise NotPresent tag
      end
    |   return_default_if_possible (_,tag,_) = raise NotPresent tag

    fun find_case (cases,tag,cdef) =
      let
	fun f [] = return_default_if_possible(cases,tag,cdef)
	  | f ((tag',expr)::cases) = if LS.tag_equality(tag,tag')
				       then expr
				     else f cases
      in
	f cases
      end

  in
  fun switch_weed _ expression =
    let
      (* We accumulate matches as an association list because  *)
      (* we don't expect excessively deep nestings of switches.*)
            
      fun weed (matches, switch as LT.SWITCH (expr, info, cases, cdef)) =
        if LS.is_shiftable expr   (* ignore expr's whose value might change *)
          then 
            (let
              val path_taken = find_path (expr,matches)
            in
               case path_taken of
                 CASE_DEF => 
                   (case (cases,cdef) of
                      ([],LT.Option.PRESENT x) => weed(matches,x)
                    | _ => raise NotSeen) (* CT We can't use the previous path *)
               | TAG(tag) => weed(matches, find_case (cases,tag,cdef))
            end 
          handle NotPresent tag => switch

(* can happen, in fact:  could new opt to switch_elim to coalesce *)
(* immediately nested switches like this, by merging constructor lists 
   together.
  I did say: impossible("tag "^(LambdaPrint.string_of_tag tag), expr) *)

               | NotSeen => 
                   let
                     val cases' = weed_cases (expr,matches,cases)
                     val cdef' = case cdef of
                       LT.Option.ABSENT => cdef
                     | LT.Option.PRESENT path => 
                         LT.Option.PRESENT(weed((expr,CASE_DEF)::matches, path))
                   in
                     LT.SWITCH(expr, info, cases', cdef')
                   end)
        else switch
          
	| weed (matches, expression) = 
	  LS.apply_one_level (curry weed matches) expression

      and weed_cases (switch_expr,matches,cases) =
	let 
	  fun wc(acc, []) = rev acc
	    | wc(acc, (tag,expr)::cases) =
	      wc((tag, (weed((switch_expr,TAG tag)::matches, expr)))::acc, 
		 cases)
	in
	  wc([],cases)
	end

    in
      weed ([],expression)
    end
  end (* of local *)

   

  (****************************************************)
  (* Switch-elimination - removes redundant SWITCHes  *)
  (*                      and optimises a few others. *)
  (****************************************************)

  fun switch_elim (LT.Info{is_shiftable,bindings,...}) =
    let
      fun impossible s =
	Crash.impossible ("LambdaOptimiser.switch_elim: " ^ s)

      fun makeK (eval,result) =
	if (is_shiftable eval) then result
	else LT.LET((LT.new_LVar(),Option.ABSENT,eval),result)

      fun elim1 (switch_expr as LT.SWITCH switch) =
	(case switch of
	   (* no branches is completely screwy *)
	   (_, _, [], LT.Option.ABSENT) =>
	     impossible "No switch branches"

	   (* single branches *)
	 | (expr,_,[],LT.Option.PRESENT default) => makeK (expr,default)
	 | (expr,_,[(_,item)],LT.Option.ABSENT)  => makeK (expr,item)

	 | (LT.LET((lv, info, le), le'), bi, cases, case_default) =>
	     LT.LET((lv, info,le), elim1(LT.SWITCH(le', bi, cases, case_default)))

	   (* switch on atomic constants *)
	 | (LT.INT n, _, cases, case_default) =>
             let
               fun do_assoc [] = 
                 (case case_default of
                    LT.Option.PRESENT expr => expr
                  | LT.Option.ABSENT => 
                      impossible "no constructor match or default")
	       |   do_assoc((h,res)::t) =
		 if LS.tag_equality(LT.IMM_TAG ("",n),h) then
		   res
		 else do_assoc(t)
             in
               do_assoc(cases)
             end

	 | (LT.SCON scon, _, cases, case_default) => 
	     let 
	       fun find [] = 
		 (case scon of 
		    Ident.REAL _ => elim2 switch_expr  (* do at runtime *)
		      
		  | _ => (case case_default of
			    (LT.Option.PRESENT expr) => expr
			  |  LT.Option.ABSENT => 
			       impossible "no scon match or default"))

		 | find ((LT.SCON_TAG tag,expr)::cs)= 
		   if Ident.scon_eqrep(tag,scon) then expr
		   else find cs

		 | find _ = impossible "mismatched SWITCH-scon expression"
	     in
	       find cases
	     end

         | (LT.MLVALUE _,_,cases,case_default) =>
             impossible "Can't cope with switches on MLValues just yet"

	   (* switch on constant structures *)
	 | (LT.STRUCT (LT.INT n :: _,_), _, cases, case_default) =>
             let
               fun do_assoc [] = 
                 (case case_default of
                    LT.Option.PRESENT expr => expr
                  | LT.Option.ABSENT => 
                      impossible "no constructor match or default"
		 )
	       |   do_assoc((h,res)::t) =
		 if LS.tag_equality(LT.IMM_TAG ("",n), h)
		    orelse LS.tag_equality(LT.VCC_TAG ("",n), h) then
		   res
		 else
		   do_assoc(t)
             in
               do_assoc cases
             end

	 | (expr as LT.STRUCT _, _, cases, case_default) =>
	     (* This is a tricky one, logically *)
	     (* We are switching on a data structure *)
	     (* This is normally a constructed datatype, *)
	     (* which would be caught in the case above *)
	     (* But it isn't, which means it must be a list *)
	     (* Hence this is the VCC case *)
	     let
	       fun do_assoc [] =
                 (case case_default of
                    LT.Option.PRESENT expr => expr
                  | LT.Option.ABSENT => 
                      impossible "no constructor match or default")
		 | do_assoc((LT.VCC_TAG (_,0), res) :: _) = res
		 | do_assoc(_ :: t) = do_assoc t
	     in
	       makeK(expr, do_assoc cases)
	     end

	 | (LT.VAR var, _, _, _) =>
	     (* (case LT.NewHashTable.tryLookup(bindings,var) of
                LT.NewHashTable.YES res => 
                  (case res of
                     LT.STRUCT _ => ptr_def
                   | _ => elim2 switch_expr)
              | LT.NewHashTable.NO => *) elim2 switch_expr (* ) *)
		 
	   (*  nested switches with constant results  *)
	 | (LT.SWITCH(innerexpr, info, case_list, case_def1),
	    _, case_list2, case_def2) =>
	   let
	     fun is_constant (LT.INT _) = true
	       | is_constant (LT.SCON _) = true
	       | is_constant (LT.MLVALUE _) = true
	       | is_constant _ = false
	     and is_constant_opt (LT.Option.PRESENT x) = is_constant x
	       | is_constant_opt LT.Option.ABSENT = true
		 
	     fun new_result constant =
	       let 
		 fun find_it (x,[]) = 
		   (case case_def2 of
		      LT.Option.PRESENT expr => expr
		    | LT.Option.ABSENT => impossible "screwy nesting")
		   | find_it (x, (h,res)::t) = 
		     if LS.tag_equality(x,h)
		       then res
		     else find_it(x,t)
	       in
		 (case constant of
		    LT.INT i => find_it (LT.IMM_TAG ("",i),case_list2)
		  | LT.SCON s => find_it (LT.SCON_TAG s,case_list2)
		  | LT.MLVALUE s => impossible "MLValue in switch_elim"
		  | _ => impossible "never say never")
	       end

	     fun apopt f LT.Option.ABSENT = LT.Option.ABSENT
	       | apopt f (LT.Option.PRESENT expr) = LT.Option.PRESENT (f expr)
	   in
	     if
	       (Lists.forall is_constant (map snd case_list))
	       andalso (is_constant_opt case_def1)
	       then 
		 elim1 (LT.SWITCH(innerexpr, 
				  info,
				  Lists.zip 
				    (map fst case_list,
				     map new_result (map snd case_list)),
				  apopt new_result case_def1
				  ))
	     else elim2 switch_expr
	   end

	  | _ => elim2 switch_expr)

	| elim1 expression = expression


      (* <--second set of cases--> *)


      (* assume exception switch *)

      and elim2 (switch_expr as (LT.SWITCH switch)) =
	
	(case switch of
	   (exnvalue, _, cases, case_default) => 
	     let
	       val exntag = LT.EXP_TAG exnvalue

	       fun known_exn var = 
                 (case LT.NewHashTable.tryLookup(bindings,var) of
                    LT.NewHashTable.YES res => 
                      (case res of
                         LT.APP(LT.BUILTIN Pervasives.REF,[LT.STRUCT ([],_)],_) => true
                       | _ => false)
                  | LT.NewHashTable.NO => false)

	       val known_exn_expr =
		 case exnvalue of 
		   LT.VAR var => known_exn var
		 | LT.BUILTIN _ => true
		 | _ => false

	       fun next_determinable ((tag,result)::cases) = 
		   if LS.tag_equality(tag,exntag) then result
		   else
		     (case tag of
			LT.EXP_TAG (LT.BUILTIN _) => 
			  if known_exn_expr then next_determinable cases
			  else shorten switch
		      | LT.EXP_TAG (LT.VAR exn_name) => 
			  if known_exn_expr andalso (known_exn exn_name)
			    then next_determinable cases
			  else shorten switch
		      | _ => shorten switch)

		 | next_determinable [] =
		   (case case_default of
		      LT.Option.PRESENT default => default
		    | LT.Option.ABSENT => impossible "no exn def!")
	     in
	       next_determinable cases
	     end)

	| elim2 expression = expression


      (* <--third set of cases--> *)

    (* shortening: identical valued branches, and adding default cases *)

      and shorten (expr, info, case_list, case_def) =
	let
	  fun identical [] = true
	    | identical (x::xs) = Lists.forall (curry LS.lambda_equality x) xs

	  fun listopt LT.Option.ABSENT = []
	    | listopt (LT.Option.PRESENT e) = [e]

	  val branch_values =
	    (listopt case_def) @@ (map snd case_list)

	  fun hd [] = Crash.impossible "hd empty list"
	    | hd (x :: _) = x
	in
	  if identical branch_values then
	    makeK (expr, hd branch_values)
	  else 
	    case case_def of
	      (LT.Option.PRESENT default) =>  (* remove duplicated default values *)
		let
		  fun remove_def (tag,value) = 
		       LS.lambda_equality(value,default)
		in
		  LT.SWITCH(expr,
			    info,
			    Lists.filter_outp remove_def case_list,
			    case_def)
		end

	    | LT.Option.ABSENT =>  (* assume absent default means constructor tags *)
		let
		  fun tagof (LT.IMM_TAG (_,tag),_) = tag
		    | tagof (LT.VCC_TAG (_,tag),_) = tag
		    | tagof _ = impossible "unexpected tag kind"

		  fun tag_order (t1, t2) = tagof t1 >= tagof t2

		  val sortedcases = Lists.qsort tag_order case_list
			
		  fun valof (_, expr) = expr

		  fun noncontig ([],[x]) = ([], LT.Option.PRESENT (valof x))
		    | noncontig ([],[x1,x2]) = ([x2], LT.Option.PRESENT (valof x1))
		    | noncontig ([],x1::x2::xs) = 
		      if (tagof x1)<>(tagof x2)+1 then
			(rev (x2::xs), LT.Option.PRESENT (valof x1))
		      else noncontig ([x1],x2::xs)
		    | noncontig (a::acc,x1::x2::xs) = 
		      if
			(tagof a)<>(tagof x1)+1 andalso
			(tagof x1)<>(tagof x2)+1
		      then ((rev xs)@@(x2::a::acc), LT.Option.PRESENT (valof x1))
		      else noncontig (x1::a::acc,x2::xs)
		    | noncontig (a::acc,[x]) =
		      if (tagof a)<>(tagof x)+1 then
			(a::acc, LT.Option.PRESENT (valof x))
		      else (x::a::acc, LT.Option.ABSENT)
		    | noncontig (acc,[]) = (acc,LT.Option.ABSENT)

		  val (newcases,newdefault) = noncontig ([],sortedcases)
		in 
		  LT.SWITCH(expr,info,newcases,newdefault)
		end
	end

      (* Eliminate nested switches that are on the same variable *)

      and eliminate_simple_nested_cons(original as
	LT.SWITCH(
	   expr,
	   info,
	   args,
           LT.Option.PRESENT(LT.SWITCH(expr', info', args', default'))
        )) =
        let
          val applicable = 
            LS.is_shiftable(expr) 
            andalso LS.lambda_equality(expr, expr')
            andalso Lists.forall (is_const_tag o #1) args'

	  val new_args' =
	    Lists.filter_outp
	      (fn (tag, _) => (Lists.exists
				 (fn (tag', _) => LS.tag_equality(tag', tag))
				 args
			      )
	      )
	      args'
        in
          if applicable
            then
              eliminate_simple_nested_cons(
		LT.SWITCH(expr,
			  info,
			  args @@ new_args',
			  default'
	      ))
          else 
            eliminate_only_default original
        end
        | eliminate_simple_nested_cons x = eliminate_only_default x

      and eliminate_only_default(
	    original as LT.SWITCH(expr,_,[],LT.Option.PRESENT x)
	  ) =
            if LS.is_shiftable expr then
	      elim1 x
            else elim1 original
        | eliminate_only_default x = 
            elim1 x
    in
      eliminate_simple_nested_cons  (* start at the top! *)
    end

  (**************************************************************)
  (*  Structure-elimination - removes redundant re-structuring  *)
  (**************************************************************)

  fun struct_elim (LT.Info{bindings,is_shiftable,...}) context =
    let
      (* restructuring now tests that all selects are on a *)
      (* structure of the same size - otherwise we break   *)
      (* polymorphic equality.				   *)

      fun is_restruct (expr,selects) =
	let
	  val len = Lists.length selects
	  fun i(n,LT.SELECT({index, size,...},e)::ss) = size = len andalso 
	    				            LS.lambda_equality(e,expr)
						    andalso index=n
						    andalso i(n+1,ss)
	    | i(n,(LT.VAR v)::ss) = 
	      (case LT.NewHashTable.tryLookup(bindings,v) of
                 LT.NewHashTable.YES res => 
                   (case res of
                      LT.SELECT({index, size,...},e) => size = len andalso 
                        LS.lambda_equality(e,expr) 
                        andalso index=n 
                        andalso i(n+1,ss)
                    | _ => false)
                  | LT.NewHashTable.NO => false)
	    | i(n,[]) = true
	    | i _ = false
	in 
	  i(0,selects)
	end

      fun elim(str as LT.STRUCT(sels as (LT.SELECT(_,str'))::_,_)) =
	if is_restruct (str',sels) then str'
	else str
      | elim (str as LT.STRUCT(sels as ((LT.VAR var)::_),_)) =
	(case LT.NewHashTable.tryLookup(bindings,var) of
           LT.NewHashTable.YES res => 
             (case res of
                LT.SELECT(f,str') =>
                  if is_restruct (str',sels) then str'
                  else str
              | _ => str) 
         | LT.NewHashTable.NO => str)
        | elim expr = expr

    in
      fn expr => 
      (case context of
	 LT.Option.PRESENT(LT.APP(LT.BUILTIN _, _, _)) => expr
       | _ => elim expr)
    end


  (*****************************************************)
  (*  LETREC elimination - removes redundant LETREC's  *)
  (*  and does dependency analysis to reduce scopes.   *)
  (*****************************************************)

  val eq = op=

  (* move a lambda-variable from in to out, if it's a member of in *)

  fun member_shift(lvar,(ins,out)) =
    let
      fun mem_sub([],_) = (ins,out)
	| mem_sub(v :: vs,acc) = if eq(lvar, v) 
				   then (vs@@acc,v::out)
				 else mem_sub(vs,v::acc)
    in
      mem_sub(ins,[])
    end

  (* get the variables from a given list that are referenced *)
  (* an expression, and those that aren't.		     *)

  fun occurs_list(res as ([], done), _) = res
    | occurs_list(res, le) = case le of
    (LT.VAR lvar) => member_shift(lvar,res)
  | (LT.FN(_, le,_,_,_)) => occurs_list(res, le)
  | (LT.LET((_, _,lb),le)) => 
      occurs_list(occurs_list(res,lb),le)
  | (LT.LETREC(lv_list, le_list, le)) =>
	Lists.reducel occurs_list (res, le :: le_list)
  | (LT.APP(le, lel,_)) =>
      Lists.reducel occurs_list( occurs_list(res, le), lel)
  | (LT.SCON _) => res
  | (LT.MLVALUE _) => res
  | (LT.INT _) => res
  | (LT.SWITCH(le, info, tag_le_list, leo)) =>
      Lists.reducel
      occurs_tag
      (occurs_list(occurs_opt(res, leo), le),
       tag_le_list)
  | (LT.STRUCT (le_list,_)) => Lists.reducel occurs_list (res, le_list)
  | (LT.SELECT(_, le)) => occurs_list(res, le)
  | (LT.RAISE (le)) => occurs_list(res, le)
  | (LT.HANDLE(le, le',_)) => occurs_list(occurs_list(res, le), le')
  | (LT.BUILTIN _) => res

  and occurs_opt(res, LT.Option.ABSENT) = res
    | occurs_opt(res, LT.Option.PRESENT le) = occurs_list(res, le)

  and occurs_tag(res, (tag, le)) =
    occurs_list((case tag of
	     LT.EXP_TAG le => occurs_list(res, le)
	   | _ => res), le)

  fun cards_of_set_eq(s1, s2) =
    Lists.length(Set.set_to_list s1) = Lists.length(Set.set_to_list s2)

  fun letrec_elim _ (LT.LETREC arg) = 
    let
      fun reduce_letrec(arg as (lv_list, le_list, lambda_exp)) =
	let 
          val lv_list' = map #1 lv_list
	  fun refs le =
	    let
	      val (_, done) = (occurs_list((lv_list', []), le))
	    in
	      Set.list_to_set done
	    end

	  fun lv_refs_from_lv([], _, _) = Crash.impossible "lv_refs_from_lv"
	    | lv_refs_from_lv(_, [], _) = Crash.impossible "lv_refs_from_lv"
	    | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
	    if lv = lv' then lv_refs 
	    else lv_refs_from_lv(lv_tl, lv_refs_tl, lv)

	  val lv_refs = map refs le_list  (* fn vars ref'd in each le *)

	  fun trans_refs lvar_set = (* trans closure of vars ref'd *)
	    let		            (* better done with an array? *)
	      val lv_refs_list =
		map (fn lv => lv_refs_from_lv(lv_list', lv_refs, lv))
		(Set.set_to_list lvar_set)
	      val new_lvar_set =
		Lists.reducel Set.union (lvar_set, lv_refs_list)
	    in
	      if cards_of_set_eq(lvar_set, new_lvar_set) then lvar_set
	      else trans_refs new_lvar_set
	    end

	  val refs_list = map (trans_refs o Set.singleton) lv_list'
	      
	  fun finish_letrec(lv_list, le_list, lambda_exp) =
	    (* Remove recursion where possible *)
	    case (lv_list, le_list) of
	      ([lv], [le]) =>
		if LS.occurs(#1 lv, le) then
		  LT.LETREC(lv_list, le_list, lambda_exp)
		else
		  LS.wrap_lets(lambda_exp,[(#1 lv, le)])
	    | _ => LT.LETREC(lv_list, le_list, lambda_exp)
		    
	  val lv_set = Set.list_to_set lv_list'
 
	  fun reduce [] = finish_letrec arg
	    | reduce (ref_hd :: ref_tl) =
	  if cards_of_set_eq(ref_hd, lv_set) then reduce ref_tl
	    else
	      let 
		fun new_lists lv_le_list = 
		  Lists.partition (fn ((lv,_), _) => 
				  Set.is_member(lv, ref_hd)) lv_le_list
		val (in_list, out_list) =
		  new_lists(Lists.zip(lv_list, le_list))
		val (in_list_lvs, in_list_les) = Lists.unzip in_list
		val (out_list_lvs, out_list_les) = Lists.unzip out_list
	      in
		reduce_letrec(in_list_lvs, in_list_les,
			      reduce_letrec(out_list_lvs,
					    out_list_les,
					    lambda_exp))
	      end
	in
	  reduce refs_list
	end
    in
      reduce_letrec arg
    end
  | letrec_elim _ expr = expr

      

  (********************************************************)
  (*  RAISE-cut.  Removes redundant code appearing after  *)
  (*  explicit RAISEs in evaluation sequence, and after   *)
  (*  HANDLE's. 	      				  *)
  (********************************************************)

  fun raise_cut (LT.Info {is_shiftable, bindings, ...}) =
    let
      (* Conservative test to see if an expression could raise an  *)
      (* exception on evaluation.  This asserts a smaller set than *)
      (* not(is_shiftable) would.				   *)
      (* Even more smart(!) would be to return a list of exn's     *)
      (* that could possibly be raised, as far as could be told.   *)
      (* (external functions would have to return conceptually     *)
      (*  every exception)					   *)
      (* We don't try and determine if a handler catches all       *)
      (* exceptions raised in the body                             *)

      (*
       * Exception Draise indicates a definite raise. The argument to
       * Draise is the exception value to be raised.
       *)

      exception Draise of LT.LambdaExp 

      fun cut lambdaexp =
	case lambdaexp of
	  LT.SCON _ =>
	    (lambdaexp, false)
        | LT.MLVALUE _ =>
	    (lambdaexp, false)
	| LT.INT _ =>
	    (lambdaexp, false)
	| LT.BUILTIN _ =>
	    (lambdaexp, false)
	| LT.VAR _ =>
	    (lambdaexp, false)
	| LT.FN(lvar, body,name,ty,instance) =>
	    let
	      val body' =
		(#1 (cut body)) handle Draise exn_val =>
		LT.RAISE exn_val
	    in
	      (LT.FN(lvar, body',name,ty,instance), false)
	    end
	| LT.LET((lvar,info,bind),body) => 
	    let
	      val (bind',must_eval) = cut bind
	      val (body',must_eval') = cut body 
                handle Draise exn_val => (LT.RAISE exn_val,false) 
	    in
	      (LT.LET((lvar,info,bind'),body),
	       must_eval orelse must_eval')
	    end
	| LT.LETREC(lvl,binds,body) =>
	    let
	      val (body',must_eval) = cut body
	    in
	      (LT.LETREC(lvl,binds,body'),
	       must_eval)
	    end
	| LT.SELECT(f, le) =>
	    let val (le', must_eval) = cut le
	    in (LT.SELECT(f, le'), must_eval) end
	| LT.RAISE (exn) =>
	    (*
	     * We ignore must_eval because (cut exn_val) is
	     * guaranteed to be evaluated.
	     *)
	    raise Draise(#1(cut exn))
	| LT.STRUCT (lel,ty) =>
	    let
	      fun f ((lel, must_eval), le) =
		let
		  val (le', must_eval') =
		    (cut le) handle Draise exn =>
		      if must_eval then (LT.RAISE exn, true)
		      else raise Draise exn
		in
		  (le' :: lel, must_eval orelse must_eval')
		end

	      val (lel', must_eval_lel) =
		Lists.reducel f (([],false), lel)
	    in
	      (LT.STRUCT (rev lel',ty), must_eval_lel)
	    end
	| LT.HANDLE(le, h,annotation) =>
	    (let
	       val (le', must_eval) = cut le
	     in
	       if must_eval then (LT.HANDLE(le', h,annotation), true)
	       else (le', false)
	     end
	     handle Draise exn_val => 
               (LT.APP(h, [exn_val],LT.Option.PRESENT(ref(Debugger_Types.exn_type))),true))
	| LT.SWITCH(e, info, cs, cd) =>
	    let
	      val (e', must_eval_e) = cut e

	      fun f ((tag, le), (lel, must_eval)) =
		let
		  val (le', must_eval') =
		    (cut le) handle Draise exn_val => (LT.RAISE exn_val, true)
		in
		  ((tag, le') :: lel, must_eval orelse must_eval')
		end

	      val (cs', must_eval_cs) =
		Lists.reducer f (cs, ([], false))

	      fun f_opt LT.Option.ABSENT =
		  (LT.Option.ABSENT, false)
		| f_opt	(LT.Option.PRESENT le) =
		  let
		    val (le', must_eval) =
		      (cut le) handle Draise exn_val =>
			(LT.RAISE exn_val, true)
		  in
		    (LT.Option.PRESENT le', must_eval)
		  end

	      val (cd', must_eval_cd) = f_opt cd
	    in
	      (LT.SWITCH(e', info, cs', cd'),
	       must_eval_e orelse must_eval_cs orelse must_eval_cd)
	    end
	| LT.APP(f,[arg], ty) =>
	    let
	      val (f', must_eval) =
		cut f
	      val (arg', _) =
		(cut arg) handle Draise exn_val =>
		  if must_eval then (LT.RAISE exn_val, true)
		  else raise Draise exn_val
	    in
	      (LT.APP(f',[arg'], ty), true)   (* could do better by  *)
					     (* testing the app for *)
					     (* shiftability.       *)
	    end
	| LT.APP(f,argl, ty) => Crash.impossible "Arglist in raise_cut"
    in
      fn lambdaexp =>
      ((#1(cut lambdaexp)) handle Draise exn_val => LT.RAISE exn_val)
    end
end;
@


1.59
log
@Abstraction of debug information in lambdatypes
@
text
@d15 3
d257 1
a257 1
                  | subst (LT.LET(lv,info,lb,le)) = LT.LET(lv,info,subst lb,subst le)
d276 1
a276 1
                  | subst (LT.STRUCT els) = LT.STRUCT(map subst els)
d300 1
a300 1
(*let/beta*)  | reduce (expr as LT.LET(var,info,arg,body)) =
d356 1
a356 1
      fun select_and_drop_fields (fieldlist, {index, size}) =
d386 1
a386 1
      fun select_field (fieldlist,{index,size}) =
d398 2
a399 2
	LT.SELECT(field,LT.STRUCT field_list) =>
	  select_and_drop_fields (field_list, field)
d401 1
a401 1
      | LT.SELECT(field, LT.VAR var) =>
d405 1
a405 1
                  LT.STRUCT fieldlist => 
d407 1
a407 1
                      val result = select_field (fieldlist,field)
d542 1
a542 1
	else LT.LET(LT.new_LVar(),Option.ABSENT,eval,result)
d554 2
a555 2
	 | (LT.LET(lv, info, le, le'), bi, cases, case_default) =>
	     LT.LET(lv, info,le, elim1(LT.SWITCH(le', bi, cases, case_default)))
d597 1
a597 1
	 | (LT.STRUCT (LT.INT n :: _), _, cases, case_default) =>
d709 1
a709 1
                         LT.APP(LT.BUILTIN Pervasives.REF,[LT.STRUCT []],_) => true
d874 1
a874 1
	  fun i(n,LT.SELECT({index, size},e)::ss) = size = len andalso 
d882 1
a882 1
                      LT.SELECT({index, size},e) => size = len andalso 
d894 1
a894 1
      fun elim(str as LT.STRUCT(sels as (LT.SELECT(_,str'))::_)) =
d897 1
a897 1
      | elim (str as LT.STRUCT(sels as ((LT.VAR var)::_))) =
d942 1
a942 1
  | (LT.LET(_, _,lb,le)) => 
d956 1
a956 1
  | (LT.STRUCT le_list) => Lists.reducel occurs_list (res, le_list)
d1092 1
a1092 1
	| LT.LET(lvar,info,bind,body) => 
d1098 1
a1098 1
	      (LT.LET(lvar,info,bind',body),
d1117 1
a1117 1
	| LT.STRUCT lel =>
d1132 1
a1132 1
	      (LT.STRUCT (rev lel'), must_eval_lel)
@


1.58
log
@Lists of arguments for APP
@
text
@d15 3
d178 1
d254 1
a254 1
                  | subst (LT.LET(lv,lb,le)) = LT.LET(lv,subst lb,subst le)
d297 1
a297 3
(*let/beta*)  | reduce (expr as LT.LET(var,arg,body)) =
              let val var = LT.fetch_var var
              in
a328 1
              end
d539 1
a539 1
	else LT.LET(LT.Option.SOME1(LT.new_LVar()),eval,result)
d551 2
a552 2
	 | (LT.LET(lv, le, le'), bi, cases, case_default) =>
	     LT.LET(lv, le, elim1(LT.SWITCH(le', bi, cases, case_default)))
d939 1
a939 1
  | (LT.LET(_, lb,le)) => 
d974 1
a974 1
          val lv_list' = map LT.fetch_var lv_list
d1008 1
a1008 1
		if LS.occurs(LT.fetch_var lv, le) then
d1011 1
a1011 1
		  LS.wrap_lets(lambda_exp,[(LT.fetch_var lv, le)])
d1022 2
a1023 2
		  Lists.partition (fn (lv, _) => 
				  Set.is_member(LT.fetch_var lv, ref_hd)) lv_le_list
d1089 1
a1089 1
	| LT.LET(lvar,bind,body) => 
d1095 1
a1095 1
	      (LT.LET(lvar,bind',body),
@


1.57
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d15 4
d253 1
a253 1
                  | subst (LT.APP(x,x',ty)) = LT.APP(subst x,subst x',ty)
d705 1
a705 1
                         LT.APP(LT.BUILTIN Pervasives.REF,LT.STRUCT [],_) => true
d942 2
a943 2
  | (LT.APP(le, le',_)) =>
	occurs_list(occurs_list(res, le), le')
d1138 1
a1138 1
               (LT.APP(h, exn_val,LT.Option.PRESENT(ref(Debugger_Types.exn_type))),true))
d1170 1
a1170 1
	| LT.APP(f, arg, ty) =>
d1179 1
a1179 1
	      (LT.APP(f', arg', ty), true)   (* could do better by  *)
d1183 1
@


1.56
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d15 4
d245 1
a245 1
                  | subst (LT.FN(lv,le,name,ty)) = LT.FN(lv,subst le,name,ty)
d650 1
a650 2
		    | LT.Option.ABSENT => 
                        (LambdaPrint.print_lambda LambdaPrint.Options.default_print_options switch_expr;impossible "screwy nesting"))
d933 1
a933 1
  | (LT.FN(_, le,_,_)) => occurs_list(res, le)
d1076 1
a1076 1
	| LT.FN(lvar, body,name,ty) =>
d1082 1
a1082 1
	      (LT.FN(lvar, body',name,ty), false)
@


1.56.1.1
log
@Fork for bug fixing
@
text
@a14 4
Revision 1.56  1993/07/14  15:28:54  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.55
log
@Improved pattern match in switch_elim
@
text
@d15 3
d251 2
a252 2
                      fun do_opt (LT.PRESENT x) = LT.PRESENT(subst x)
                        | do_opt (LT.ABSENT) = LT.ABSENT
d263 3
a265 2
                  | subst (LT.RAISE le) = LT.RAISE(subst le)
                  | subst (LT.HANDLE(le1,le2,annotation)) = LT.HANDLE(subst le1,subst le2,annotation)
d286 2
d319 1
d440 1
a440 1
    fun return_default_if_possible(cases, tag, LT.PRESENT default) =
d475 1
a475 1
                      ([],LT.PRESENT x) => weed(matches,x)
d490 3
a492 3
                       LT.ABSENT => cdef
                     | LT.PRESENT path => 
                         LT.PRESENT(weed((expr,CASE_DEF)::matches, path))
d530 1
a530 1
	else LT.LET(LT.new_LVar(),eval,result)
d535 1
a535 1
	   (_, _, [], LT.ABSENT) =>
d539 2
a540 2
	 | (expr,_,[],LT.PRESENT default) => makeK (expr,default)
	 | (expr,_,[(_,item)],LT.ABSENT)  => makeK (expr,item)
d550 2
a551 2
                    LT.PRESENT expr => expr
                  | LT.ABSENT => 
d554 1
a554 1
		 if LS.tag_equality(LT.IMM_TAG n,h) then
d568 2
a569 2
			    (LT.PRESENT expr) => expr
			  |  LT.ABSENT => 
d589 2
a590 2
                    LT.PRESENT expr => expr
                  | LT.ABSENT => 
d594 2
a595 2
		 if LS.tag_equality(LT.IMM_TAG n, h)
		    orelse LS.tag_equality(LT.VCC_TAG n, h) then
d613 2
a614 2
                    LT.PRESENT expr => expr
                  | LT.ABSENT => 
d616 1
a616 1
		 | do_assoc((LT.VCC_TAG 0, res) :: _) = res
d638 2
a639 2
	     and is_constant_opt (LT.PRESENT x) = is_constant x
	       | is_constant_opt LT.ABSENT = true
d645 3
a647 2
		      LT.PRESENT expr => expr
		    | LT.ABSENT => impossible "screwy nesting")
d654 1
a654 1
		    LT.INT i => find_it (LT.IMM_TAG i,case_list2)
d660 2
a661 2
	     fun apopt f LT.ABSENT = LT.ABSENT
	       | apopt f (LT.PRESENT expr) = LT.PRESENT (f expr)
d723 2
a724 2
		      LT.PRESENT default => default
		    | LT.ABSENT => impossible "no exn def!")
d741 2
a742 2
	  fun listopt LT.ABSENT = []
	    | listopt (LT.PRESENT e) = [e]
d754 1
a754 1
	      (LT.PRESENT default) =>  (* remove duplicated default values *)
d765 1
a765 1
	    | LT.ABSENT =>  (* assume absent default means constructor tags *)
d767 2
a768 2
		  fun tagof (LT.IMM_TAG tag,_) = tag
		    | tagof (LT.VCC_TAG tag,_) = tag
d777 2
a778 2
		  fun noncontig ([],[x]) = ([], LT.PRESENT (valof x))
		    | noncontig ([],[x1,x2]) = ([x2], LT.PRESENT (valof x1))
d781 1
a781 1
			(rev (x2::xs), LT.PRESENT (valof x1))
d787 1
a787 1
		      then ((rev xs)@@(x2::a::acc), LT.PRESENT (valof x1))
d791 3
a793 3
			(a::acc, LT.PRESENT (valof x))
		      else (x::a::acc, LT.ABSENT)
		    | noncontig (acc,[]) = (acc,LT.ABSENT)
d808 1
a808 1
           LT.PRESENT(LT.SWITCH(expr', info', args', default'))
d839 1
a839 1
	    original as LT.SWITCH(expr,_,[],LT.PRESENT x)
d900 1
a900 1
	 LT.PRESENT(LT.APP(LT.BUILTIN _, _, _)) => expr
d947 1
a947 1
  | (LT.RAISE le) => occurs_list(res, le)
d951 2
a952 2
  and occurs_opt(res, LT.ABSENT) = res
    | occurs_opt(res, LT.PRESENT le) = occurs_list(res, le)
d966 1
d969 1
a969 1
	      val (_, done) = (occurs_list((lv_list, []), le))
d985 1
a985 1
		map (fn lv => lv_refs_from_lv(lv_list, lv_refs, lv))
d994 1
a994 1
	  val refs_list = map (trans_refs o Set.singleton) lv_list
d1000 1
a1000 1
		if LS.occurs(lv, le) then
d1003 1
a1003 1
		  LS.wrap_lets(lambda_exp,[(lv, le)])
d1006 1
a1006 1
	  val lv_set = Set.list_to_set lv_list
d1015 1
a1015 1
				  Set.is_member(lv, ref_hd)) lv_le_list
d1059 1
a1059 1
      exception Draise of LT.LambdaExp
d1100 1
a1100 1
	| LT.RAISE exn_val =>
d1105 1
a1105 1
	    raise Draise(#1 (cut exn_val))
d1111 3
a1113 3
		    (cut le) handle Draise exn_val =>
		      if must_eval then (LT.RAISE exn_val, true)
		      else raise Draise exn_val
d1130 2
a1131 2
	     handle Draise exn_val => (LT.APP(h, exn_val,
					      Debugger_Types.exn_type),true))
d1147 3
a1149 3
	      fun f_opt LT.ABSENT =
		  (LT.ABSENT, false)
		| f_opt	(LT.PRESENT le) =
d1155 1
a1155 1
		    (LT.PRESENT le', must_eval)
@


1.54
log
@Removed integer parameter
@
text
@d15 3
d596 1
a596 1
	 | (expr as LT.STRUCT[a, b], _, cases, case_default) =>
d598 1
a598 1
	     (* We are switching on a two element data structure *)
@


1.53
log
@Fixed switch_elim to optimise switches on manifest lists
@
text
@d15 3
a129 1
require "../utils/integer";
a139 1
  structure Integer : INTEGER
d344 2
a345 2
			       Integer.makestring index ^ " and list length " ^
			       Integer.makestring(Lists.length fieldlist) ^
d370 2
a371 2
	    Integer.makestring index ^ " and list length " ^
	    Integer.makestring(Lists.length fieldlist) ^
@


1.52
log
@Signature revisions
@
text
@d13 112
d589 1
a589 1
               do_assoc(cases)
d592 19
a1167 108

(* $Log: _optimise_contract.sml,v $
Revision 1.51  1993/03/03  17:44:38  jont
Removed LVar_eq in favour of polymorphic equality

Revision 1.50  1993/03/01  15:14:04  matthew
Added MLVALUE lambda exp

Revision 1.49  1992/12/03  12:19:55  matthew
Commented out calls to print_deletion_message.
,.

Revision 1.48  1992/11/20  12:35:19  jont
Modified switch_elim to move LETs in the switch expression outside

Revision 1.47  1992/11/19  16:30:50  daveb
Fixed bug in eliminate_simple_nested_cons, exposed by improvements in
letrec elimination and switch nesting.  Also allowed more optimisations
on SCON switches.

Revision 1.46  1992/11/09  16:11:12  clive
Added some LETREC optimisation

Revision 1.45  1992/10/28  12:31:52  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.44  1992/09/23  14:08:05  clive
Added optimisations in switch_weed and switch_elim

Revision 1.43  1992/09/22  13:25:09  clive
Changes for the newhashtables

Revision 1.42  1992/09/21  12:06:03  clive
Changed hashtables to a single structure implementation

Revision 1.41  1992/09/16  10:01:09  clive
Got rid of handles involving hash tables

Revision 1.40  1992/08/26  13:05:51  jont
Removed some redundant structures and sharing

Revision 1.39  1992/08/06  16:44:31  clive
Fix to let case of raise_cut

Revision 1.38  1992/07/29  10:15:12  clive
Changed the bindingtable to be a hashtable

Revision 1.37  1992/07/24  13:34:32  clive
Modified to use the new hashtables

Revision 1.36  1992/07/22  12:31:37  jont
Removed references to Lists.foldl and Lists.foldr

Revision 1.35  1992/07/17  14:04:33  clive
More work on type propogation

Revision 1.34  1992/07/15  14:07:09  clive
Another fix to switch_weed - if an expr gave us default or pointer case before,
this cannot be used to weed things later

Revision 1.33  1992/07/14  11:18:07  clive
Problem in the switch_weeding code fixed

Revision 1.32  1992/07/10  15:42:55  davida
Fix in switch_weed for case that I didn't think occurred,
triming of beta reduction.

Revision 1.31  1992/07/09  18:13:31  davida
Tidied things up, added switch_weed optimisation.

Revision 1.30  1992/07/08  16:14:13  davida
General tidying up.

Revision 1.29  1992/07/06  12:29:16  davida
Added LET constructor and new slot to APP.
Fixed bug in raise_cut where the body of
a LETREC was ignored, so HANDLES were being lost.

Revision 1.28  1992/06/29  10:11:17  davida
Eta-reduction now combined with beta-reduction.  Switch elimination
on exceptions re-added.  Removed backwards elim from struct elim.
Improved efficiency of letrec elim.
Other miscellaneous tidying.

Revision 1.27  1992/06/23  09:47:16  clive
Added an annotation slot to HANDLE

Revision 1.26  1992/06/15  17:12:28  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.26  1992/06/15  13:52:58  davida
Changed lambda_print.

Revision 1.25  1992/06/03  15:08:57  clive
Added type annotations to FNexp

Revision 1.24  1992/05/22  16:53:50  jont
Only allowed structure elimination for structures of the same size,
rather than leading substructures. This is because allowing a
structure to be replaced by a larger one of which it is a leading
substructure breaks polymorphic equality, as firstly the tags may be
inconsistent, and secondly the size requires more working out.

Revision 1.23  1992/05/14  09:24:37  clive
Added delayed substitution to beta-reduce to speed up the constant list case by a factor of
5+

 *)
@


1.51
log
@Removed LVar_eq in favour of polymorphic equality
@
text
@a32 2
  sharing LambdaPrint.LambdaTypes.Datatypes = Debugger_Types.Datatypes
  sharing type LambdaPrint.LambdaTypes.LVar = int
d34 1
d36 3
a38 1
) : OPTIMISE_CONTRACT =
d46 1
a46 1
  structure Ident = LT.Datatypes.Ident
d1039 3
@


1.50
log
@Added MLVALUE lambda exp
@
text
@d766 1
a766 1
  val eq = LT.LVar_eq
d773 1
a773 1
	| mem_sub(v :: vs,acc) = if LT.LVar_eq(lvar, v) 
d1038 3
@


1.49
log
@Commented out calls to print_deletion_message.
,.
@
text
@d127 1
d457 3
d493 1
d512 1
d794 1
d920 2
d1038 4
@


1.48
log
@Modified switch_elim to move LETs in the switch expression outside
@
text
@d171 1
a171 1
                                 LS.print_deletion_message arg;
d186 1
a186 1
                                      LS.print_deletion_message arg;
d1029 3
@


1.47
log
@Fixed bug in eliminate_simple_nested_cons, exposed by improvements in
letrec elimination and switch nesting.  Also allowed more optimisations
on SCON switches.
@
text
@d417 3
d1029 5
@


1.46
log
@Added some LETREC optimisation
@
text
@d288 5
a292 3
  fun is_con_tag (LT.IMM_TAG _) = true
  |   is_con_tag (LT.VCC_TAG _) = true
  |   is_con_tag _ = false
d318 2
a319 2
        if is_con_tag tag andalso
	   Lists.forall (is_con_tag o first) cases
d661 1
a661 1
            andalso Lists.forall (is_con_tag o #1) args'
d663 8
a670 7
          fun sieve_con_tag([], args, args') = (rev args, rev args')
            | sieve_con_tag((a as (t,_))::rest, args, args') =
		if is_con_tag t then
                  sieve_con_tag(rest, a::args, args')
		else
		  sieve_con_tag(rest, args, a::args')

d674 6
a679 20
              let
                val (new_args,new_args') = sieve_con_tag(args',[],[])
              in
                eliminate_only_default(
		  LT.SWITCH(expr,
			    info,
			    args @@ new_args,
			    case default' of
			      LT.ABSENT => LT.ABSENT
			    | LT.PRESENT x =>
                                LT.PRESENT(
			          eliminate_simple_nested_cons(
				    LT.SWITCH(expr',
					      info',
					      new_args',
					      default'
					     )
			        ))
		))
              end
d1026 3
@


1.45
log
@Minor changes to support the new type of SWITCHes.
@
text
@a162 10
(*  the following cases are covered in heuristic beta reduce.
(*eta*)	      | reduce (expr as LT.FN(var,LT.APP(result,LT.VAR var',_),_,_)) =
	      if var=var' andalso 
		get_count(var)=1 andalso 
		LS.is_shiftable(result)
		then result
	      else expr   (* should make count for var 0, but it shouldn't appear elsewhere, so it don't much matter *)

	      | reduce (LT.APP(LT.FN(var,body,_,_),arg,_)) = reduce(LT.LET(var,arg,body))
*)
d170 3
a172 1
                           0 => (increment_count(var',~1); body)
d185 3
a187 2
                                          (adjust_counts (~1,do_substitutions arg) ; 
                                           body)
d1037 3
@


1.44
log
@Added optimisations in switch_weed and switch_elim
@
text
@d128 1
a128 1
                  | subst (LT.SWITCH(le,cle1,leo1,leo2)) =
d136 1
d138 1
a138 2
                                do_opt leo1,
                                do_opt leo2)
d295 5
d303 1
a303 1
    datatype path = PTR_DEF | CASE_DEF | TAG of LT.Tag
d317 2
a318 1
    (* We can't find the tag in the list of cases, so see if we can return the default case *)
d320 9
a328 4
    fun return_default_if_possible(cases,tag as LT.CON_TAG _,LT.PRESENT default) =
      if Lists.forall (fn (LT.CON_TAG _,_) => true | _ => false) cases
        then default
      else raise NotPresent tag
a329 2
      | return_default_if_possible (_,tag,_) = raise NotPresent tag

d346 1
a346 1
      fun weed (matches, switch as LT.SWITCH (expr, cases, cdef, pdef)) =
a356 4
               | PTR_DEF =>  
                   (case (cases,pdef) of
                      ([],LT.PRESENT x) => weed(matches,x)
                    | _ => raise NotSeen) (* to prune anything in these cases *)
a372 4
                     val pdef' = case pdef of
                       LT.ABSENT => pdef
                     | LT.PRESENT path => 
                         LT.PRESENT(weed((expr,PTR_DEF)::matches, path))
d374 1
a374 1
                     LT.SWITCH(expr, cases', cdef', pdef')
d415 1
a415 1
	   (_,[],LT.ABSENT,LT.ABSENT) =>
d419 2
a420 3
	 | (expr,[],LT.ABSENT,LT.PRESENT default) => makeK (expr,default)
	 | (expr,[],LT.PRESENT default,LT.ABSENT) => makeK (expr,default)
	 | (expr,[(_,item)],LT.ABSENT,LT.ABSENT)  => makeK (expr,item)
d423 1
a423 1
	 | (LT.INT n, cases, case_default, _) =>
d430 4
a433 4
		 | do_assoc((h,res)::t) =
		   if LS.tag_equality(LT.CON_TAG n,h)
		     then res
		   else do_assoc(t)
d438 1
a438 1
	 | (LT.SCON scon, cases, case_default, LT.ABSENT) => 
a457 2
	 | (LT.SCON _, _, _, _) => impossible "screwy SWITCH-scon expression!"

d459 17
a475 4
	 | (LT.STRUCT _, _, _, ptr_default) =>
	     (case ptr_default of
		(LT.PRESENT expr') => expr'
	      |  LT.ABSENT => impossible "no pointer-default")
d477 2
a478 2
	 | (LT.VAR var, _, _, LT.PRESENT ptr_def) =>
	     (case LT.NewHashTable.tryLookup(bindings,var) of
d483 1
a483 1
              | LT.NewHashTable.NO => elim2 switch_expr)
d486 2
a487 2
	 | (LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
	    case_list2, case_def2, LT.ABSENT) =>
d500 2
a501 2
		    | LT.ABSENT => impossible"screwy nesting")
		   | find_it (x,(h,res)::t) = 
d507 1
a507 1
		    LT.INT i => find_it (LT.CON_TAG i,case_list2)
a517 1
	       andalso (is_constant_opt ptr_def1)
d520 1
d524 2
a525 2
				  apopt new_result case_def1,
				  apopt new_result ptr_def1))
d542 1
a542 1
	   (exnvalue, cases, case_default, LT.ABSENT) => 
d579 1
a579 4
	     end

	 | (LT.BUILTIN _, _, _, _) => 
			impossible "screwy SWITCH-exn expression!"
a580 2
	 | _ => shorten switch)

d588 1
a588 1
      and shorten (expr,case_list,case_def,ptr_def) =
d591 1
a591 1
	    | identical (x::xs) = Lists.forall (curry (*op=*) LS.lambda_equality x) xs
d597 1
a597 1
	    (listopt case_def) @@ (listopt ptr_def) @@ (map snd case_list)
d599 1
a599 1
	  fun hd [] = Crash.impossible"hd empty list"
d611 4
a614 2
		  LT.SWITCH(expr,Lists.filter_outp remove_def case_list,
			    case_def,ptr_def)
d617 1
a617 1
	    | LT.ABSENT =>  (* assume absent default means CON_TAG's *)
d619 5
a623 2
		  fun tag_order ((LT.CON_TAG i,_), (LT.CON_TAG j,_)) = i>=j
		    | tag_order _ = impossible "tag mismatch in switch"
a626 3
		  fun tagof (LT.CON_TAG tag,_) = tag
		    | tagof _ = impossible "unexpected tag kind"

d649 1
a649 1
		  LT.SWITCH(expr,newcases,newdefault,ptr_def)
d655 7
a661 4
      and eliminate_simple_nested_cons
        (original as LT.SWITCH(expr,args,
                               LT.PRESENT(LT.SWITCH(expr',args',default',pointer')),
                               pointer)) =
d665 2
a666 2
            andalso LS.lambda_equality(expr,expr')
            andalso Lists.forall (fn (LT.CON_TAG _,_) => true | _ => false) args'
d668 6
a673 4
          fun sieve_con_tag([],args,args') = (rev args,rev args')
            | sieve_con_tag((a as (LT.CON_TAG _,_))::rest,args,args') =
              sieve_con_tag(rest,a::args,args')
            | sieve_con_tag(a::rest,args,args') = sieve_con_tag(rest,args,a::args')
d681 16
a696 4
                eliminate_only_default(LT.SWITCH(expr,args @@ new_args,
                                                 LT.PRESENT
                                                 (eliminate_simple_nested_cons(LT.SWITCH(expr',new_args',default',pointer'))),
                                                 pointer))
d703 6
a708 5
      and eliminate_only_default(original as LT.SWITCH(expr,[],LT.PRESENT x,LT.ABSENT)) =
          if LS.is_shiftable expr
            then elim1 x
          else elim1 original

a710 1

d804 1
a804 1
  | (LT.SWITCH(le, tag_le_list, leo1, leo2)) =>
d807 1
a807 1
      (occurs_list(occurs_opt(occurs_opt(res, leo1), leo2), le),
d993 1
a993 1
	| LT.SWITCH(e, cs, cd, pd) =>
a1019 1
	      val (pd', must_eval_pd) = f_opt pd
d1021 2
a1022 3
	      (LT.SWITCH(e', cs', cd', pd'),
	       must_eval_e orelse must_eval_cs orelse
	       must_eval_cd orelse must_eval_pd)
d1044 3
@


1.43
log
@Changes for the newhashtables
@
text
@d311 11
a321 1
    fun find_case (cases,tag) =
d323 1
a323 1
	fun f [] = raise NotPresent tag
d338 17
a354 11
	if LS.is_shiftable expr   (* ignore expr's whose value might change *)
	then 
	(let
	   val path_taken = find_path (expr,matches)
	 in
	   case path_taken of
	     CASE_DEF => raise NotSeen (* CT We can't use the previous path *)
	   | PTR_DEF =>  raise NotSeen (* to prune anything in these cases *)
	   | TAG(tag) => weed(matches, find_case (cases,tag))
	 end 
       handle NotPresent tag => switch
d361 16
a376 16
	    | NotSeen => 
	  let
	    val cases' = weed_cases (expr,matches,cases)
	    val cdef' = case cdef of
	      		 LT.ABSENT => cdef
		       | LT.PRESENT path => 
			   LT.PRESENT(weed((expr,CASE_DEF)::matches, path))
	    val pdef' = case pdef of
	      		 LT.ABSENT => pdef
		       | LT.PRESENT path => 
			   LT.PRESENT(weed((expr,PTR_DEF)::matches, path))
	  in
	    LT.SWITCH(expr, cases', cdef', pdef')
	  end)
      else switch

d389 1
d644 42
d687 1
a687 1
      elim1  (* start at the top! *)
d1021 3
@


1.42
log
@Changed hashtables to a single structure implementation
@
text
@d94 1
a94 1
            fun adjuster_function v =
d962 3
@


1.41
log
@Got rid of handles involving hash tables
@
text
@a12 1
require "../utils/_newhashtable";
d34 1
a36 2
  sharing type LambdaPrint.LambdaTypes.BindingTable.Key = LambdaPrint.LambdaTypes.LVar
  sharing type LambdaPrint.LambdaTypes.BindingTable.Value = LambdaPrint.LambdaTypes.LambdaExp
d46 1
a79 19
 structure OccCountHashTable =
   NewHashTable(
     structure Crash = Crash
     structure Lists = Lists
     type Key    = LT.LVar
     type Value  = int
     val size    = 300
     val hash = LT.int_of_LVar
     val eq = LT.LVar_eq)
    
 structure SubstTable = 
     NewHashTable(
     structure Crash = Crash
     structure Lists = Lists
     type Key    = LT.LVar
     type Value  = LT.LambdaExp
     val size    = 300
     val hash = LT.int_of_LVar
     val eq = LT.LVar_eq)
a80 1

d91 2
a92 2
            val occcounthashtable = OccCountHashTable.new()
            val substtable = SubstTable.new()
d97 1
a97 1
                 val x = OccCountHashTable.lookup(occcounthashtable,var)
d99 1
a99 1
                 (OccCountHashTable.update(occcounthashtable,var,x+v);
d105 1
a105 1
              OccCountHashTable.lookup_default(occcounthashtable,0,var) 
d108 1
a108 1
              OccCountHashTable.update(occcounthashtable,var,n + get_count var)
d118 3
a120 3
                  (case SubstTable.tryLookup(substtable,x) of
                     SubstTable.NO => exp 
                   | SubstTable.YES res => subst res)
d152 1
a152 1
          (SubstTable.update(substtable,x,y); 
d156 3
a158 3
            (case SubstTable.tryLookup(substtable,x') of
               SubstTable.NO => (true,x)
             | SubstTable.YES res => really_is_a_var res)
d212 1
a212 1
                            OccCountHashTable.string_hash_table_stats(occcounthashtable) ^ "\n");
d214 1
a214 1
                            SubstTable.string_hash_table_stats(substtable) ^ "\n"))
d272 2
a273 2
	  (case LT.BindingTable.tryLookup(bindings,var) of
             LT.BindingTable.YES res => 
d283 1
a283 1
           | LT.BindingTable.NO => expression)
d450 2
a451 2
	     (case LT.BindingTable.tryLookup(bindings,var) of
                LT.BindingTable.YES res => 
d455 1
a455 1
              | LT.BindingTable.NO => elim2 switch_expr)
d519 2
a520 2
                 (case LT.BindingTable.tryLookup(bindings,var) of
                    LT.BindingTable.YES res => 
d524 1
a524 1
                  | LT.BindingTable.NO => false)
d649 2
a650 2
	      (case LT.BindingTable.tryLookup(bindings,v) of
                 LT.BindingTable.YES res => 
d657 1
a657 1
                  | LT.BindingTable.NO => false)
d668 2
a669 2
	(case LT.BindingTable.tryLookup(bindings,var) of
           LT.BindingTable.YES res => 
d675 1
a675 1
         | LT.BindingTable.NO => str)
d962 3
@


1.40
log
@Removed some redundant structures and sharing
@
text
@d126 1
a126 2
              OccCountHashTable.lookup(occcounthashtable,var) 
              handle OccCountHashTable.Lookup _ => 0
d139 3
a141 1
                  ((subst (SubstTable.lookup(substtable,x))) handle _ => exp)
d177 3
a179 1
            (really_is_a_var(SubstTable.lookup(substtable,x')) handle _ => (true,x))
d293 12
a304 9
	  ((case LT.BindingTable.lookup(bindings,var) of
	      LT.STRUCT fieldlist => 
		let
		  val result = select_field (fieldlist,field)
		in
		  if (is_shiftable result) then result
		  else expression
		end
	    | _ => expression) handle LT.BindingTable.Lookup _ => expression)
d471 6
a476 5
	     ((case LT.BindingTable.lookup(bindings,var) of
		 LT.STRUCT _ => ptr_def
	       | _ => elim2 switch_expr)
		 handle LT.BindingTable.Lookup _ => 
		   elim2 switch_expr)
d540 6
a545 5
		 (case 
		    (LT.BindingTable.lookup(bindings,var)) of
		    LT.APP(LT.BUILTIN Pervasives.REF,LT.STRUCT [],_) => true
		    | _ => false)
		 handle LT.BindingTable.Lookup _ => false
d670 9
a678 6
	      ((case LT.BindingTable.lookup(bindings,v) of
		  LT.SELECT({index, size},e) => size = len andalso 
		                 		LS.lambda_equality(e,expr) 
						andalso index=n 
						andalso i(n+1,ss)
		| _ => false) handle LT.BindingTable.Lookup _ => false)
d689 9
a697 6
	((case LT.BindingTable.lookup(bindings,var) of
	    LT.SELECT(f,str') =>
	      if is_restruct (str',sels) then str'
	      else str
	  | _ => str) handle LT.BindingTable.Lookup _ => str)
      | elim expr = expr
d983 3
@


1.39
log
@Fix to let case of raise_cut
@
text
@a18 1
require "../basics/ident";
a28 1
  structure Ident : IDENT
d39 1
a39 1
  sharing Ident = LambdaPrint.LambdaTypes.Ident) : OPTIMISE_CONTRACT =
d46 2
a47 1
  structure Set = LambdaSub.Set
d969 3
@


1.38
log
@Changed the bindingtable to be a hashtable
@
text
@d869 2
a870 1
	      val (body',must_eval') = cut body
d970 3
@


1.37
log
@Modified to use the new hashtables
@
text
@d39 2
d291 1
a291 1
	  ((case LT.BindingTable.apply bindings var of
d299 1
a299 1
	    | _ => expression) handle LT.BindingTable.Undefined => expression)
d466 1
a466 1
	     ((case LT.BindingTable.apply bindings var of
d469 1
a469 1
		 handle LT.BindingTable.Undefined => 
d535 1
a535 1
		    (LT.BindingTable.apply bindings var) of
d538 1
a538 1
		 handle LT.BindingTable.Undefined => false
d663 1
a663 1
	      ((case LT.BindingTable.apply bindings v of
d668 1
a668 1
		| _ => false) handle LT.BindingTable.Undefined => false)
d679 1
a679 1
	((case LT.BindingTable.apply bindings var of
d683 1
a683 1
	  | _ => str) handle LT.BindingTable.Undefined => str)
d969 3
@


1.36
log
@Removed references to Lists.foldl and Lists.foldr
@
text
@d13 1
a13 2
require "../utils/hashtable";
require "../utils/_hashtable";
d48 2
d80 4
a83 2
 structure OccCountSpec : HASHSPEC =
   struct
d88 1
a88 4
     val eq = LT.LVar_eq
   end

 structure OccCountHashTable = HashTable(OccCountSpec)
d90 9
a98 9
  fun adjuster_function v =
    (fn (copy as LT.VAR(var)) =>
     let
       val x = OccCountHashTable.lookup(var)
     in
       (OccCountHashTable.update(var,x+v);
        copy)
     end
      | expression => expression)
a99 2
      fun get_count var =
        OccCountHashTable.lookup(var) handle OccCountHashTable.Lookup _ => 0
d101 7
a107 2
      fun increment_count (var,n) =
        OccCountHashTable.update(var,n + get_count var)
d109 4
a112 2
        fun adjust_counts (times,body) =
          LS.apply_innermost (adjuster_function times) body
d114 51
a164 40
        (* Instead of doing lots of single substitutions, it is better to do one walk *)
        structure SubstTableSpec : HASHSPEC =
          struct
            type Key    = LT.LVar
            type Value  = LT.LambdaExp
            val size    = 300
            val hash = LT.int_of_LVar
            val eq = LT.LVar_eq
          end
        
        structure SubstTable = HashTable(SubstTableSpec)
          
        fun do_substitutions exp =
          (let
            fun subst (exp as LT.VAR x) = 
              ((subst (SubstTable.lookup(x))) handle _ => exp)
              | subst (LT.FN(lv,le,name,ty)) = LT.FN(lv,subst le,name,ty)
	      | subst (LT.LET(lv,lb,le)) = LT.LET(lv,subst lb,subst le)
              | subst (LT.LETREC(lvl,lel,le)) =
		LT.LETREC(lvl,map subst lel,subst le)
              | subst (LT.APP(x,x',ty)) = LT.APP(subst x,subst x',ty)
              | subst (x as LT.SCON _) = x
              | subst (x as LT.INT _) = x
              | subst (LT.SWITCH(le,cle1,leo1,leo2)) =
                let
                  fun do_opt (LT.PRESENT x) = LT.PRESENT(subst x)
                    | do_opt (LT.ABSENT) = LT.ABSENT
                  fun do_tag (LT.EXP_TAG exp) = LT.EXP_TAG (subst exp)
                    | do_tag exp = exp
                in
                  LT.SWITCH(subst le, 
                            map (fn (x,y) => (do_tag x,subst y)) cle1,
                            do_opt leo1,
                            do_opt leo2)
                end
              | subst (LT.STRUCT els) = LT.STRUCT(map subst els)
              | subst (LT.SELECT(fld,exp)) = LT.SELECT(fld,subst exp)
              | subst (LT.RAISE le) = LT.RAISE(subst le)
              | subst (LT.HANDLE(le1,le2,annotation)) = LT.HANDLE(subst le1,subst le2,annotation)
              | subst (x as LT.BUILTIN _) = x
d171 1
a171 1
          (SubstTable.update(x,y); 
d175 1
a175 1
            (really_is_a_var(SubstTable.lookup(x')) handle _ => (true,x))
a177 10
        (* 
           Important note: I hope this is right - we may delay the substitutions even 
           though we test things for shiftability because the things that we substitute 
           in are always shiftables... i.e the variable that represents them is is_shiftable
           and this correctly reflects the value that would occur if the substitution had
           been made.
             *)

        fun beta_reduce expression =
	  let 
a204 2
(* 
   Code to check that the hashtable optimisation is correct
a205 11

val occs = LS.occurrences(var,do_substitutions body)
             val _ = 
               if occs = hashcount
                 then
                   ()
               else
                 (output(std_out,"***** Hash and occs dont agree\n" ^ LT.printLVar var ^ 
                        " " ^ Integer.makestring(occs) ^ " " ^ Integer.makestring(hashcount) ^ "\n");
                  LambdaPrint.print_lambda expr)
*)
d221 5
d227 7
a233 4
	    (OccCountHashTable.clear();
	     SubstTable.clear();
	     do_substitutions
	     (LS.apply_innermost reduce expression))
d967 3
@


1.35
log
@More work on type propogation
@
text
@d889 1
a889 1
	      fun f le (lel, must_eval) =
d899 2
a900 1
	      val (lel', must_eval_lel) = Lists.foldl f ([],false) lel
d917 1
a917 1
	      fun f (tag, le) (lel, must_eval) =
d925 2
a926 1
	      val (cs', must_eval_cs) = Lists.foldr f ([], false) cs
d966 3
@


1.34
log
@Another fix to switch_weed - if an expr gave us default or pointer case before,
this cannot be used to weed things later
@
text
@d21 1
d35 1
d37 1
d911 1
a911 1
					      LT.null_type_annotation()),true))
d964 4
@


1.33
log
@Problem in the switch_weeding code fixed
@
text
@d344 2
a345 6
	     CASE_DEF => (case cdef of
			    LT.ABSENT => raise NotSeen
			  | LT.PRESENT path => weed(matches, path))
	   | PTR_DEF => (case pdef of
			   LT.ABSENT => raise NotSeen
			 | LT.PRESENT path => weed(matches, path))
d961 3
@


1.32
log
@Fix in switch_weed for case that I didn't think occurred,
triming of beta reduction.
@
text
@a336 4
      fun impossible (s,expr) = 
	Crash.impossible ("switch_weed: inconsistent paths for "^s^
			  ", switching on\n"^
			  (LambdaPrint.string_of_lambda expr)^"\n")
d345 1
a345 1
			    LT.ABSENT => impossible ("case-default", expr)
d348 1
a348 1
			   LT.ABSENT => impossible ("ptr-default", expr)
d965 4
@


1.31
log
@Tidied things up, added switch_weed optimisation.
@
text
@d171 1
d180 1
a180 1

d320 1
a320 1
    exception NotPresent
d323 1
a323 1
	fun f [] = raise NotPresent
d337 7
a343 1
      fun weed (matches, LT.SWITCH (expr, cases, cdef, pdef)) =
a346 1
	   (* NB:- should re-evaluate expr if it isn't shiftable *)
d349 1
a349 2
			    LT.ABSENT => Crash.impossible 
				 	 "switch_weed:inconsistent paths"
d352 1
a352 2
			   LT.ABSENT => Crash.impossible 
				 	 "switch_weed:inconsistent paths"
d356 7
a362 1
       handle NotPresent => Crash.impossible "switch_weed:inconsistent paths"
d377 2
d380 1
a380 1
	     LS.apply_one_level (curry weed matches) expression
d969 3
@


1.30
log
@General tidying up.
@
text
@d21 1
a21 1
require "optimise_lib";
a29 1
  structure Lib   : OPTIMISE_LIB
d32 1
d35 3
a37 3
  sharing Lib.LT = LambdaPrint.LambdaTypes
  sharing type Pervasives.pervasive = Lib.LT.Primitive 
	  sharing Ident = Lib.LT.Ident) : OPTIMISE_CONTRACT =
a38 1
  open Lib  
d40 1
a40 1
  fun fst(x,_)=x and snd(_,y)=y   (* use these rather than from Lib *)
d42 18
a59 2
  infix mem == ++ --
   
d63 1
d167 1
a167 1
        fun beta_reduce (LT.Info{is_shiftable,...}) expression =
d174 1
a174 1
		is_shiftable(result)
d178 2
d211 1
a211 1
                           0 => (if is_shiftable arg
d216 1
a216 1
                         | 1 => if is_shiftable arg
a231 17
  (************************************************)
  (* Eta-reduction -- eliminates lambda-variables *)
  (************************************************)

  (* obselete: included in beta-reduction above *)

  fun eta_reduce (LT.Info{is_shiftable,...}) expression =
    case expression of
      LT.FN(var,LT.APP(result,LT.VAR var',_),_,_) =>
	if
	  (var=var') andalso not(var' mem (snd (LS.bounds_and_frees result)))
	  andalso (is_shiftable result)
	then result
	else expression
    | _ => expression


d298 88
d957 3
@


1.29
log
@Added LET constructor and new slot to APP.
Fixed bug in raise_cut where the body of
a LETREC was ignored, so HANDLES were being lost.
@
text
@d105 1
a105 8
             (* ((subst (SubstTable.lookup(x))) handle _ => exp) *)
	      let
		val (found,exp) = ((true,(SubstTable.lookup(x))) handle _ => (false,exp))
	      in
		if found
		  then subst exp
		else exp
	      end
a154 1
(*
a160 1
*)
a161 5
(*
(*beta*)      | reduce (LT.APP(LT.FN(var,body,_,_),arg,_)) =
                                             reduce(LT.LET(var,arg,body))
*)

d294 1
a294 1
    end (* of local *)
d373 1
a373 1
	         (*  nested switches with constant results  *)
d550 1
a550 1
  fun struct_elim (LT.Info{bindings,is_shiftable,is_commutative,...}) context =
d868 5
@


1.28
log
@Eta-reduction now combined with beta-reduction.  Switch elimination
on exceptions re-added.  Removed backwards elim from struct elim.
Improved efficiency of letrec elim.
Other miscellaneous tidying.
@
text
@d105 8
a112 8
              let
                val (found,exp) = ((true,(SubstTable.lookup(x))) handle _ => (false,exp))
              in
                if found 
                  then
                    subst exp
                else exp
              end
d114 1
d116 2
a117 2
                LT.LETREC(lvl,map subst lel,subst le)
              | subst (LT.APP(x,x')) = LT.APP(subst x,subst x')
d158 3
a160 9
        fun beta_reduce (LT.Info{is_shiftable,...}) expression' =
          (OccCountHashTable.clear();
           SubstTable.clear();
           do_substitutions
           (LS.apply_innermost
            (fn expression =>
             (case expression of
                copy as LT.VAR(var) =>
                  (increment_count(var,1) ; copy)
d162 8
a169 6
(*eta*)	      | LT.FN(var,LT.APP(result,LT.VAR var'),_,_) => 
		  if var=var' andalso 
		     get_count(var)=1 andalso 
		     is_shiftable(result)
		       then result
		  else expression
d171 4
d176 1
a176 1
(*beta*)         | LT.APP(LT.FN(var,body,_,_),arg) => 
d193 3
a195 3
*)
(*
             val occs = LS.occurrences(var,body)
d199 1
a199 1
                   output(std_out,"Hash and occs agree\n")
d203 1
a203 1
                  LambdaPrint.print_lambda (std_out,expression))
d211 1
a211 1
                                 else expression)
d215 2
a216 2
                                else expression
                         | _ => expression
d218 8
a225 1
              | _ => expression)) expression'))
d236 1
a236 1
      LT.FN(var,LT.APP(result,LT.VAR var'),_,_) =>
d272 1
a272 3
		(LT.VAR resvar, 
                 [(resvar, f,"shifting a function in _optimise_contract",
		   LT.null_type_annotation())]) 
d275 1
a275 3
	  fun pair_new expr = (LT.new_LVar(), expr,
                               "shifting a function in _optimise_contract",
                               LT.null_type_annotation())
d323 1
a323 3
	else LT.APP(LT.FN(LT.new_LVar(),result,
			  "_makeK in _optimise_contract",
			  LT.null_type_annotation()),eval)
d451 1
a451 1
		    LT.APP(LT.BUILTIN Pervasives.REF,LT.STRUCT []) => true
a600 21
      (* backwards elimination is not used at present...

      fun backwards_elim (expr as LT.APP(func, LT.STRUCT
            [LT.SELECT({index = 1, size = _},str1),
	     LT.SELECT({index = 0, size = _},str0)])) =
	(case func of
	   LT.BUILTIN _ => expr
	 | _ =>  (* at present this bit never called as we don't *)
		 (* assign commutativity to any other func's.    *)
	     if LS.lambda_equality(str1,str0) andalso (is_commutative func)
	       andalso (is_shiftable str1) then
	       (info "One in a million! backwards commutative strelim";
		LT.APP(func,str1))
	     else expr)
      | backwards_elim expr =
	(case context of
	   LT.PRESENT(LT.APP(LT.BUILTIN _, _)) => expr
	 | _ => elim expr)

      *)

d604 1
a604 1
	 LT.PRESENT(LT.APP(LT.BUILTIN _, _)) => expr
d608 1
d635 2
d639 1
a639 1
  | (LT.APP(le, le')) =>
d705 1
a705 3
		  LS.wrap_lets(lambda_exp, 
			       [(lv, le,"finish letrec in _optimise_contract",
				 LT.null_type_annotation())])
d757 1
a757 3
       * Exception Draise indicates a definate raise. Exception MustEval
       * indicates that an expression must be evaluated because it may
       * either have side effects or raise and exception. The argument to
d781 15
a795 2
	| LT.LETREC _ =>
	    (lambdaexp, false)
d828 2
a829 1
	     handle Draise exn_val => (LT.APP(h, exn_val), true))
d862 1
a862 1
	| LT.APP(f, arg) =>
d871 3
a873 1
	      (LT.APP(f', arg'), true)
d882 6
a910 64
Revision 1.22  1992/04/30  09:19:35  jont
Added require "hashtable"

Revision 1.21  1992/04/23  15:04:37  clive
Modified to use the new form of binding table as part of general speed improvements

Revision 1.20  1992/04/13  14:25:04  clive
First version of the profiler

Revision 1.19  1992/03/27  10:45:49  jont
Added Print parameter to functor. Removed use of pervasive hd

Revision 1.18  1992/03/06  14:38:08  jont
Fixed simple beat reduction to throw away unreferenced shiftable
values

Revision 1.17  1992/02/27  17:55:40  jont
modified the letrec elimination algorithms to avoid the use of sets.

Revision 1.17  1992/02/26  19:33:59  jont
Modified letre_elim to use special lv eq and to check for occurrences
of lambda variables by searching the expression rather than using
set intersection on bounds and frees

Revision 1.16  1992/02/05  16:43:39  jont
Added integer parameter

Revision 1.15  1992/01/03  15:45:55  jont
Changed struct_elim to be usable with apply_innermost_with_context
This allows us to avoid restructuring for builtin operators

Revision 1.14  1991/11/28  17:37:03  richard
Removed a reference to MAKE_NEW_UNIQUE.  The optimisation that was
being done using this pervasive is not currently understood, and has
been switched off.  Further work is required here.

Revision 1.13  91/11/08  19:04:03  jont
Changed switch optimisation for if then else to push true case into
default

Revision 1.12  91/10/28  15:39:18  davidt
Reimplemented raise_cut function.

Revision 1.11  91/10/24  10:36:40  davidt
Fixed bug in optimise contract which gave a Crash.impossible
when doing raise/handle elimination.

Revision 1.10  91/10/22  18:07:33  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.9  91/10/22  14:38:45  davidt
Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception). Fixed a bug in switch_elim which
caused Crash.impossible to be called when folding a switch
containing a pointer default.

Revision 1.8  91/10/09  14:59:20  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.

Revision 1.7  91/09/24  15:00:52  davida
Changes to raise_cut and switch shortening.
@


1.27
log
@Added an annotation slot to HANDLE
@
text
@d6 1
a6 1
 * simple beta-reduction, eta-reduction,
d54 3
a56 3
  (*************************************************)
  (* Beta-reduction -- eliminates lambda-variables *)
  (*************************************************)
d58 1
a58 2
(* Instead of calling occurrences a large number of times, we maintain
   a hashtable - we scan from the inside        *)
d60 8
a67 8
structure OccCountSpec : HASHSPEC =
  struct
    type Key    = LT.LVar
    type Value  = int
    val size    = 300
    val hash = LT.int_of_LVar
    val eq = LT.LVar_eq
  end
d69 1
a69 1
  structure OccCountHashTable = HashTable(OccCountSpec)
d166 10
a175 1
              | LT.APP(LT.FN(var,body,_,_),arg) => 
d219 1
d224 2
d236 1
d243 1
a243 1
      fun select_field (fieldlist, {index, size}) =
d246 1
a246 1
	      (rev unshifts, f, Lists.filterp (not o is_shiftable) rest)
d250 1
a250 1
	    | get_field(n, x, y) =
d265 2
a266 1
                 [(resvar, f,"shifting a function in _optimise_contract",LT.null_type_annotation())]) 
d276 11
d289 2
a290 2
	LT.SELECT(field,LT.STRUCT expr_list) =>
	  select_field (expr_list, field)
d292 1
a292 4
      | LT.SELECT(field,LT.LETREC(lvl,lel,LT.STRUCT expr_list)) =>
	  LT.LETREC(lvl,lel,select_field (expr_list, field))

      | LT.SELECT({index, size}, LT.VAR var) =>
d296 1
a296 9
		  val result =
		    (Lists.nth (index, fieldlist)
		     handle Lists.Nth => 
		       Crash.impossible
		       ("select_elim: bad SELECT field number!" ^
			"\nCalled with n = " ^
			Integer.makestring index ^ " and list length " ^
			Integer.makestring(Lists.length fieldlist) ^
			"\n"))
d306 1
d319 3
a321 1
	else LT.APP(LT.FN(LT.new_LVar(),result,"_makeK in _optimise_contract",LT.null_type_annotation()),eval)
d342 4
a345 4
                    | do_assoc((h,res)::t) =
                      if LS.tag_equality(LT.CON_TAG n,h)
                        then res
                      else do_assoc(t)
a372 1

d386 25
a410 25
	       | (LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
		  case_list2, case_def2, LT.ABSENT) =>
		 let
		   fun is_constant (LT.INT _) = true
		     | is_constant (LT.SCON _) = true
		     | is_constant _ = false
		   and is_constant_opt (LT.PRESENT x) = is_constant x
		     | is_constant_opt LT.ABSENT = true
	    
		   fun new_result constant =
		     let 
		       fun find_it (x,[]) = 
                         (case case_def2 of
                            LT.PRESENT expr => expr
                          | LT.ABSENT => impossible"screwy nesting")
                         | find_it (x,(h,res)::t) = 
                           if LS.tag_equality(x,h)
                             then res
                           else find_it(x,t)
		     in
		       (case constant of
			  LT.INT i => find_it (LT.CON_TAG i,case_list2)
			| LT.SCON s => find_it (LT.SCON_TAG s,case_list2)
			| _ => impossible "never say never")
		     end
d412 16
a427 15
		   fun apopt f LT.ABSENT = LT.ABSENT
		     | apopt f (LT.PRESENT expr) = LT.PRESENT (f expr)
		 in
		   if
		     (Lists.forall is_constant (map snd case_list))
		     andalso (is_constant_opt case_def1)
		     andalso (is_constant_opt ptr_def1)
		   then 
		     elim1 (LT.SWITCH(innerexpr, 
				      Lists.zip (map fst case_list,
					   map new_result (map snd case_list)),
				      apopt new_result case_def1,
				      apopt new_result ptr_def1))
		   else elim2 switch_expr
		 end
d429 1
a429 1
		| _ => elim2 switch_expr)
a432 1
      (* <second set of cases possibly overlapped above> *)
d434 5
a445 1
(*  I'm not sure what this is doing, so I'll assume the worst.  Richard.
d447 5
a451 5
		 (case Lists.assoc(var,bindings) of
		    LT.APP(LT.BUILTIN Pervasives.MAKE_NEW_UNIQUE,_) => true
		  | _ => false) handle Lists.Assoc => false
*)
	       fun known_exn var = false
d465 1
a465 1
			  else shorten switch_expr
d469 2
a470 2
			  else shorten switch_expr
		      | _ => shorten switch_expr)
d480 2
a481 1
	 | (LT.BUILTIN _, _, _, _) => impossible "screwy SWITCH-exn expression!"
d483 1
a483 1
	 | _ => shorten switch_expr)
d487 3
a489 1
    (*******************************************************************)
a490 1
    (*******************************************************************)
d492 1
a492 2
      and shorten (switch_expr as
		   LT.SWITCH (expr,case_list,case_def,ptr_def)) =
d501 2
a502 2
	    (map snd case_list) @@ (listopt case_def) @@
	    (listopt ptr_def)
d504 1
a504 1
	  | hd (x :: _) = x
d512 2
a513 1
		  fun remove_def (tag,value) = not(LS.lambda_equality(value,default))
d515 2
a516 1
		  LT.SWITCH(expr,Lists.filterp remove_def case_list,case_def,ptr_def)
a553 2
      
	| shorten expression = expression
d555 1
a555 1
      elim1
d564 4
d571 4
a574 4
	  fun i(n,LT.SELECT({index, size},e)::ss) =
	    size = len andalso LS.lambda_equality(e,expr) andalso index=n andalso i(n+1,ss)
	    (* Check using all of structure *)
	    (* We must do this, else we break polymorphic equality *)
d577 4
a580 4
		  LT.SELECT({index, size},e) =>
		    size = len andalso LS.lambda_equality(e,expr) andalso index=n andalso i(n+1,ss)
		(* Check using all of structure *)
		(* We must do this, else we break polymorphic equality *)
d599 2
d606 2
a607 1
	 | _ =>
d617 3
d621 4
a624 1
      backwards_elim
d634 1
a634 17
  fun lvar_occurs(lv, le) =
    let
      fun occurs(LT.VAR lvar) = LT.LVar_eq(lv, lvar)
      | occurs(LT.FN(_, le,_,_)) = occurs le
      | occurs(LT.LETREC(lv_list, le_list, le)) =
	Lists.exists occurs (le :: le_list)
      | occurs(LT.APP(le, le')) = occurs le orelse occurs le'
      | occurs(LT.SCON _) = false
      | occurs(LT.INT _) = false
      | occurs(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	occurs le orelse occurs_opt leo1 orelse occurs_opt leo2 orelse
	(Lists.exists occurs_tag tag_le_list)
      | occurs(LT.STRUCT le_list) = Lists.exists occurs le_list
      | occurs(LT.SELECT(_, le)) = occurs le
      | occurs(LT.RAISE le) = occurs le
      | occurs(LT.HANDLE(le, le',_)) = occurs le orelse occurs le'
      | occurs(LT.BUILTIN _) = false
d636 1
a636 12
      and occurs_opt LT.ABSENT = false
      | occurs_opt(LT.PRESENT le) = occurs le

      and occurs_tag(tag, le) =
	occurs le orelse case tag of
	LT.EXP_TAG le => occurs le
      | _ => false
    in
      occurs le
    end

  fun member eqfn =
d638 4
a641 2
      fun mem_sub(_, []) = false
      | mem_sub(x, y :: ys) = eqfn(x, y) orelse mem_sub(x, ys)
d643 1
a643 1
      mem_sub
d646 3
d650 4
a653 7
  | occurs_list(res as (in_list, out_list), le) = case le of
    (LT.VAR lvar) =>
      if member LT.LVar_eq (lvar, in_list) then
	(Lists.filterp (fn l => not(eq(l, lvar))) in_list, lvar :: out_list)
      else res
    | (LT.FN(_, le,_,_)) => occurs_list(res, le)
    | (LT.LETREC(lv_list, le_list, le)) =>
d655 1
a655 1
    | (LT.APP(le, le')) =>
d657 12
a668 12
    | (LT.SCON _) => res
    | (LT.INT _) => res
    | (LT.SWITCH(le, tag_le_list, leo1, leo2)) =>
	Lists.reducel
	occurs_tag
	(occurs_list(occurs_opt(occurs_opt(res, leo1), leo2), le),
	 tag_le_list)
    | (LT.STRUCT le_list) => Lists.reducel occurs_list (res, le_list)
    | (LT.SELECT(_, le)) => occurs_list(res, le)
    | (LT.RAISE le) => occurs_list(res, le)
    | (LT.HANDLE(le, le',_)) => occurs_list(occurs_list(res, le), le')
    | (LT.BUILTIN _) => res
d671 1
a671 1
  | occurs_opt(res, LT.PRESENT le) = occurs_list(res, le)
d678 1
a678 1
  fun simple_set_eq(s1, s2) =
a684 2
	  val lv_set = Set.list_to_set lv_list

d693 2
a694 2
	  | lv_refs_from_lv(_, [], _) = Crash.impossible "lv_refs_from_lv"
	  | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
d698 1
a698 1
	  val lv_refs = map refs le_list
d700 2
a701 2
	  fun trans_refs lvar_set =
	    let
d708 1
a708 1
	      if simple_set_eq(lvar_set, new_lvar_set) then lvar_set
d718 1
a718 2
		if (*Set.is_member(lv, #2 (LS.bounds_and_frees le))*)
		  lvar_occurs(lv, le) then
d721 3
a723 2
		  LS.wrap_lets(lambda_exp, [(lv, le,"finish letrec in _optimise_contract",
                                             LT.null_type_annotation())])
d726 2
d729 2
a730 2
	  | reduce (ref_hd :: ref_tl) =
	    if simple_set_eq(ref_hd, lv_set) then reduce ref_tl
d734 2
a735 11
		  let 
		    val in_lv_le_list =
		      Lists.filterp (fn (lv, _) =>
				     Set.is_member(lv, ref_hd)) lv_le_list
		    val out_lv_le_list =
		      Lists.filterp (fn (lv, _) => not(Set.is_member(lv, 
								     ref_hd)))
		      lv_le_list
		  in
		    (in_lv_le_list, out_lv_le_list)
		  end
d741 3
a743 3
		reduce_letrec((*map #1*) in_list_lvs, (*map #2*) in_list_les,
			      reduce_letrec((*map #1*) out_list_lvs,
					    (*map #2*) out_list_les,
d755 1
d886 3
@


1.26
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d135 1
a135 1
              | subst (LT.HANDLE(le1,le2)) = LT.HANDLE(subst le1,subst le2)
d616 1
a616 1
      | occurs(LT.HANDLE(le, le')) = occurs le orelse occurs le'
d659 1
a659 1
    | (LT.HANDLE(le, le')) => occurs_list(occurs_list(res, le), le')
d828 1
a828 1
	| LT.HANDLE(le, h) =>
d832 1
a832 1
	       if must_eval then (LT.HANDLE(le', h), true)
d886 3
@


1.25
log
@Added type annotations to FNexp
@
text
@d34 1
d40 3
d194 1
a194 1
                  LambdaPrint.print_lambda expression)
d320 13
a332 6
	     ((Lists.assoc (LT.CON_TAG n,cases))
	      handle Lists.Assoc =>
		(case case_default of
		   LT.PRESENT expr => expr
		 | LT.ABSENT => 
		     impossible "no constructor match or default"))
d382 8
a389 6
		       fun find_it x = 
			 (Lists.assoc (x, case_list2))
			 handle Lists.Assoc =>
			   (case case_def2 of
			      LT.PRESENT expr => expr
			    | LT.ABSENT => impossible"screwy nesting")
d392 2
a393 2
			  LT.INT i => find_it (LT.CON_TAG i)
			| LT.SCON s => find_it (LT.SCON_TAG s)
d441 1
a441 1
		   if tag=exntag then result
d475 1
a475 1
	    | identical (x::xs) = Lists.forall (curry op= x) xs
d492 1
a492 1
		  fun remove_def (tag,value) = value<>default
d548 1
a548 1
	    size = len andalso e=expr andalso index=n andalso i(n+1,ss)
d554 1
a554 1
		    size = len andalso e=expr andalso index=n andalso i(n+1,ss)
d581 1
a581 1
	     if str1=str0 andalso (is_commutative func)
d886 6
@


1.24
log
@Only allowed structure elimination for structures of the same size,
rather than leading substructures. This is because allowing a
structure to be replaced by a larger one of which it is a leading
substructure breaks polymorphic equality, as firstly the tags may be
inconsistent, and secondly the size requires more working out.
@
text
@d63 1
a63 1
    val eq = (op =)
d94 1
a94 1
            val eq = (op =)
d110 1
a110 1
              | subst (LT.FN(lv,le,name)) = LT.FN(lv,subst le,name)
d163 1
a163 1
              | LT.APP(LT.FN(var,body,_),arg) => 
d213 1
a213 1
      LT.FN(var,LT.APP(result,LT.VAR var'),_) =>
d248 2
a249 1
		(LT.VAR resvar, [(resvar, f,"shifting a function in _optimise_contract")]) 
d252 3
a254 1
	  fun pair_new expr = (LT.new_LVar(), expr,"shifting a function in _optimise_contract")
d301 1
a301 1
	else LT.APP(LT.FN(LT.new_LVar(),result,"_makeK in _optimise_contract"),eval)
d591 1
a591 1
      | occurs(LT.FN(_, le,_)) = occurs le
d631 1
a631 1
    | (LT.FN(_, le,_)) => occurs_list(res, le)
d703 2
a704 1
		  LS.wrap_lets(lambda_exp, [(lv, le,"finish letrec in _optimise_contract")])
d780 1
a780 1
	| LT.FN(lvar, body,name) =>
d786 1
a786 1
	      (LT.FN(lvar, body',name), false)
d873 7
@


1.23
log
@Added delayed substitution to beta-reduce to speed up the constant list case by a factor of
5+
@
text
@d529 6
a534 3
	let 
	  fun i(n,LT.SELECT({index, size},e)::ss) = 
	      e=expr andalso index=n andalso i(n+1,ss)
d538 3
a540 1
		    e=expr andalso index=n andalso i(n+1,ss)
d542 1
a542 1
	    | i(_,[]) = true
d869 4
@


1.22
log
@Added require "hashtable"
@
text
@d87 91
a177 17
  fun beta_reduce (LT.Info{is_shiftable,...}) =
    LS.apply_innermost
    (OccCountHashTable.clear();
     fn expression =>
     (case expression of
        copy as LT.VAR(var) =>
          (increment_count(var,1) ; copy)
      | LT.APP(LT.FN(var,body,_),copy as LT.VAR var') =>
           let
             val count = get_count var
           in
             increment_count(var',count - 1);
             LS.substitute_for_at_most_n_occurrences (var,copy,body,count)
           end
      | LT.APP(LT.FN(var,body,_),arg) => 
          let
            val hashcount = get_count var
d192 14
a205 12
          in
            case hashcount of
              0 => if is_shiftable arg
                      then (adjust_counts (~1,arg) ; body)
                   else expression
            | 1 => if is_shiftable arg
                     then
                        LS.substitute_for_at_most_one_occurrence (var,arg,body)
                   else expression
            | _ => expression
          end
      | _ => expression))
d864 3
@


1.21
log
@Modified to use the new form of binding table as part of general speed improvements
@
text
@d13 1
d788 3
@


1.20
log
@First version of the profiler
@
text
@d13 1
d21 1
d32 3
a34 1
  sharing type Pervasives.pervasive = Lib.LT.Primitive
d53 2
a54 17
  fun beta_reduce (LT.Info{is_shiftable,...}) expression =
    case expression of
      LT.APP(LT.FN(var,body,_),copy as LT.VAR _) =>
	LS.substitute (var,copy,body)
    | LT.APP(LT.FN(var,body,_),arg) => 
	if (is_shiftable arg) then
	  let
	    val occs = LS.occurrences(var,body)
	  in
	    case occs of
	      0 => body
	    | 1 => LS.substitute (var,arg,body)
	    | _ => expression
	  end
	else
	  expression
    | _ => expression
d56 74
d188 1
a188 1
	  ((case Lists.assoc(var,bindings) of
d204 1
a204 1
	    | _ => expression) handle Lists.Assoc => expression)
d273 1
a273 1
	     ((case Lists.assoc(var,bindings) of
d276 1
a276 1
		 handle Lists.Assoc => 
d456 1
a456 1
	      ((case Lists.assoc(v,bindings) of
d459 1
a459 1
		| _ => false) handle Lists.Assoc => false)
d470 1
a470 1
	((case Lists.assoc(var,bindings) of
d474 1
a474 1
	  | _ => str) handle Lists.Assoc => str)
a576 2
      (*  Jon's code moved here from _lambda.sml  *)

a586 5
(*
	  fun refs le =
	    Set.list_to_set
	    (Lists.filterp (fn lv => lvar_occurs(lv, le)) lv_list)
*)
d787 3
@


1.19
log
@Added Print parameter to functor. Removed use of pervasive hd
@
text
@d51 1
a51 1
      LT.APP(LT.FN(var,body),copy as LT.VAR _) =>
d53 1
a53 1
    | LT.APP(LT.FN(var,body),arg) => 
d73 1
a73 1
      LT.FN(var,LT.APP(result,LT.VAR var')) =>
d108 1
a108 1
		(LT.VAR resvar, [(resvar, f)]) 
d111 1
a111 1
	  fun pair_new expr = (LT.new_LVar(), expr)
d158 1
a158 1
	else LT.APP(LT.FN(LT.new_LVar(),result),eval)
d443 1
a443 1
      | occurs(LT.FN(_, le)) = occurs le
d483 1
a483 1
    | (LT.FN(_, le)) => occurs_list(res, le)
d562 1
a562 1
		  LS.wrap_lets(lambda_exp, [(lv, le)])
d638 1
a638 1
	| LT.FN(lvar, body) =>
d644 1
a644 1
	      (LT.FN(lvar, body'), false)
d731 3
@


1.18
log
@Fixed simple beat reduction to throw away unreferenced shiftable
values
@
text
@d16 1
d26 1
d37 1
a37 1
  fun info message = if !show_debug_info then print message else ()
d327 2
d731 4
@


1.17
log
@modified the letrec elimination algorithms to avoid the use of sets.
@
text
@d52 9
a60 2
	if (is_shiftable arg) andalso (LS.occurrences(var,body)=1) then
	  LS.substitute (var,arg,body)
d727 3
@


1.16
log
@Added integer parameter
@
text
@d427 1
a427 3
  fun letrec_elim _ (LT.LETREC arg) = 
      let
	(*  Jon's code moved here from _lambda.sml  *)
d429 17
a445 3
	fun reduce_letrec(arg as (lv_list, le_list, lambda_exp)) =
	  let 
	    val lv_set = Set.list_to_set lv_list
d447 2
a448 8
	    fun refs le =
	    Set.intersection(#2 (LS.bounds_and_frees le), lv_set)
	    
	    fun lv_refs_from_lv([], _, _) = Crash.impossible "lv_refs_from_lv"
	      | lv_refs_from_lv(_, [], _) = Crash.impossible "lv_refs_from_lv"
	      | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
		if lv = lv' then lv_refs 
		else lv_refs_from_lv(lv_tl, lv_refs_tl, lv)
d450 7
a456 1
	    val lv_refs = map refs le_list
d458 31
a488 11
	    fun trans_refs lvar_set =
	      let
		val lv_refs_list =
		  map (fn lv => lv_refs_from_lv(lv_list, lv_refs, lv))
		  (Set.set_to_list lvar_set)
		val new_lvar_set =
		  Lists.reducel Set.union (lvar_set, lv_refs_list)
	      in
		if Set.seteq(lvar_set, new_lvar_set) then lvar_set
		else trans_refs new_lvar_set
	      end
d490 52
a541 1
	    val refs_list = map (trans_refs o Set.singleton) lv_list
d543 10
a552 9
	    fun finish_letrec(lv_list, le_list, lambda_exp) =
	        (* Remove recursion where possible *)
	        case (lv_list, le_list) of
		  ([lv], [le]) =>
		    if Set.is_member(lv, #2 (LS.bounds_and_frees le)) then
		      LT.LETREC(lv_list, le_list, lambda_exp)
		    else
		      LS.wrap_lets(lambda_exp, [(lv, le)])
		| _ => LT.LETREC(lv_list, le_list, lambda_exp)
d554 6
a559 4
	    fun reduce [] = finish_letrec arg
	      | reduce (ref_hd :: ref_tl) =
		if Set.seteq(ref_hd, lv_set) then reduce ref_tl
		else
d561 7
a567 12
		    fun new_lists lv_le_list = 
		      let 
			val in_lv_le_list =
			  Lists.filterp (fn (lv, _) =>
				   Set.is_member(lv, ref_hd)) lv_le_list
			val out_lv_le_list =
			  Lists.filterp (fn (lv, _) => not(Set.is_member(lv, 
								   ref_hd)))
			  lv_le_list
		      in
			(in_lv_le_list, out_lv_le_list)
		      end
d569 1
a569 9
		    let 
		      val (in_list, out_list) =
			new_lists(Lists.zip(lv_list, le_list))
		    in
		      reduce_letrec(map #1 in_list, map #2 in_list,
				    reduce_letrec(map #1 out_list, 
						  map #2 out_list,
						  lambda_exp))
		    end
d571 17
a587 7
	  in
	    reduce refs_list
	  end
      in
	reduce_letrec arg
      end
    | letrec_elim _ expr = expr
d720 8
@


1.15
log
@Changed struct_elim to be usable with apply_innermost_with_context
This allows us to avoid restructuring for builtin operators
@
text
@d15 1
d21 9
a29 8
functor OptimiseContract
  (structure Crash : CRASH
   structure Lists : LISTS
   structure Lib   : OPTIMISE_LIB
   structure Ident : IDENT
   structure Pervasives : PERVASIVES
   sharing type Pervasives.pervasive = Lib.LT.Primitive
	   sharing Ident = Lib.LT.Ident) : OPTIMISE_CONTRACT =
d85 6
a90 1
	    | get_field _ = Crash.impossible "select_elim: bad SELECT field number!"
d122 6
a127 1
		       Crash.impossible "select_elim: bad SELECT field number!")
d637 4
@


1.14
log
@Removed a reference to MAKE_NEW_UNIQUE.  The optimisation that was
being done using this pervasive is not currently understood, and has
been switched off.  Further work is required here.
@
text
@d363 1
a363 1
  fun struct_elim (LT.Info{bindings,is_shiftable,is_commutative,...}) =
d380 10
a389 10
      fun elim (str as LT.STRUCT(sels as (LT.SELECT(_,str'))::_)) = 
	  if is_restruct (str',sels) then str'
	  else str
	| elim (str as LT.STRUCT(sels as ((LT.VAR var)::_))) =
	  ((case Lists.assoc(var,bindings) of
	      LT.SELECT(f,str') =>
		if is_restruct (str',sels) then str'
		else str
	    | _ => str) handle Lists.Assoc => str)
	| elim expr = expr
d391 15
a405 12
      and backwards_elim (expr as LT.APP(func, LT.STRUCT
            [LT.SELECT({index = index1, size = _},str1),
	     LT.SELECT({index = index0, size = _},str0)])) =
	  if
	    index1=1 andalso index0=0
	    andalso str1=str0 andalso (is_commutative func)
	    andalso (is_shiftable str1)
	  then
	    (info "One in a million! backwards commutative strelim";
	     LT.APP(func,str1))
	  else expr
	| backwards_elim expr = elim expr
d624 6
a629 1
(* $Log:	_optimise_contract.sml,v $
@


1.13
log
@Changed switch optimisation for if then else to push true case into
default
@
text
@d249 1
d254 2
d622 4
@


1.12
log
@Reimplemented raise_cut function.
@
text
@d328 1
a328 1
		    | noncontig ([],[x1,x2]) = ([x1], LT.PRESENT (valof x2))
d619 3
@


1.11
log
@Fixed bug in optimise contract which gave a Crash.impossible
when doing raise/handle elimination.
@
text
@d495 1
a495 1
  fun raise_cut (LT.Info{is_shiftable,bindings,...}) =
d500 6
a505 4
      (* Even more smart(!) would be to return a list of exn's    *)
      (* that could possibly be raised, as far as could be told.  *)
      (* (external functions would have to return conceptually    *)
      (*  every exception)					  *)
d507 6
a512 1
      datatype effects = DEFINATEraise | POSSIBLEraise | NOraise
d514 6
a519 7
      fun could_raise_exn in_app_lhs testexpr =
	case testexpr of
	  LT.RAISE _ =>
	    true
	| LT.SCON _ =>
	    in_app_lhs andalso
	    Crash.impossible "Impossible lambda application"
d521 1
a521 2
	    in_app_lhs andalso
	    Crash.impossible "Impossible lambda application"
d523 22
a544 1
	    in_app_lhs
d546 34
a579 21
	    exists (could_raise_exn in_app_lhs) lel
	| LT.SELECT(f,le) =>
	    could_raise_exn in_app_lhs le
	| LT.HANDLE(e,h) =>
	    (could_raise_exn in_app_lhs e) andalso
	    (could_raise_exn false h)
	| LT.VAR fnvar =>
	    (not in_app_lhs) orelse
	    ((could_raise_exn in_app_lhs (Lists.assoc(fnvar,bindings)))
	     handle Lists.Assoc => true)
	| LT.FN(_,body) =>
	    (not in_app_lhs) orelse (could_raise_exn false body)
	| LT.LETREC _ =>
	    (not in_app_lhs) orelse true
	| LT.SWITCH(e,cs,cd,pd) =>
	    (could_raise_exn in_app_lhs e) orelse 
	    (exists (fn (_,le) => could_raise_exn in_app_lhs le) cs) orelse
	    (could_raise_exn_opt in_app_lhs cd) orelse
	    (could_raise_exn_opt in_app_lhs pd)
	| LT.APP(p,q) =>
	    (could_raise_exn true p) orelse (could_raise_exn false q)
d581 1
a581 3
      and could_raise_exn_opt _ LT.ABSENT = false
	| could_raise_exn_opt in_app_lhs (LT.PRESENT expr) =
	  could_raise_exn in_app_lhs expr
d583 10
a592 1
      (* The Optimisation *)
d594 18
a611 9
      fun cut (LT.APP(raise_expr as LT.RAISE _, _)) = raise_expr
	| cut (app_expr as LT.APP(func, raise_expr as LT.RAISE _)) = 
	  if could_raise_exn true func then app_expr else raise_expr
	| cut (LT.RAISE(raise_expr as LT.RAISE _)) = raise_expr
	| cut (LT.HANDLE(LT.RAISE exn_value, handler)) =
	  LT.APP(handler, exn_value)
	| cut (expr as LT.HANDLE(expr', handler)) =
	  if could_raise_exn false expr' then expr else expr'
	| cut expr = expr
d613 2
a614 1
      cut
d616 1
d618 4
a621 1
end (* of functor *);
a622 1
(* $Log:	_optimise_contract.sml,v $
@


1.10
log
@Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.
@
text
@d505 3
a507 1
      fun could_raise_exn testexpr =
d509 25
a533 10
	  LT.RAISE _   => true
	| LT.SCON _    => false
	| LT.INT _     => false
	| LT.VAR _     => false
	| LT.FN _      => false
	| LT.LETREC _  => false
	| LT.BUILTIN _ => false
	| LT.STRUCT lel => exists could_raise_exn lel
	| LT.SELECT(f,le) => could_raise_exn le
	| LT.HANDLE(e,h)  => (could_raise_exn e) andalso (could_raise_exn h)
d535 6
a540 5
	    (could_raise_exn e) orelse 
	    (exists could_raise_exn (map snd cs)) orelse
	    (could_raise_exn_opt cd) orelse
	    (could_raise_exn_opt pd)
	| LT.APP(p,q) => (could_raise_exn_app p) orelse (could_raise_exn q)
d542 3
a544 2
      and could_raise_exn_opt LT.ABSENT = false
	| could_raise_exn_opt (LT.PRESENT expr) = could_raise_exn expr
a545 6
      and could_raise_exn_app (LT.FN(_,body)) = could_raise_exn body
	| could_raise_exn_app (LT.VAR fnvar) =
	  ((could_raise_exn_app (Lists.assoc(fnvar,bindings))) handle Lists.Assoc => true)
	| could_raise_exn_app (LT.BUILTIN _) = true
	| could_raise_exn_app _ = Crash.impossible "screwy lambda application"

d550 1
a550 1
	  if could_raise_exn func then app_expr else raise_expr
d555 1
a555 1
	  if could_raise_exn expr' then expr else expr'
d564 4
@


1.9
log
@Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception). Fixed a bug in switch_elim which
caused Crash.impossible to be called when folding a switch
containing a pointer default.
@
text
@d2 10
a11 1
(*  Lambda-Calculus Optimisation:  _optimise_contract  *)
a12 7
    (*  Contraction-phase Optimisations:        *)
    (*  simple beta-reduction, eta-reduction,   *)
    (*  select-elimination, struct-elimination, *)
    (*  switch-elmination, application reorder. *)

       (*  Copyright (c) 1991 Harlequin Ltd. *)

d14 1
a19 1

d22 1
a28 1

d30 1
a30 1
  infix mem == ++ -- (* !!! *)
d79 1
a79 1
	      (rev unshifts, f, filterp (not o is_shiftable) rest)
d109 1
a109 1
	  ((case assoc(var,bindings) of
d113 2
a114 2
		    (nth (index, fieldlist)
		     handle Nth => 
d120 1
a120 1
	    | _ => expression) handle Assoc => expression)
d152 2
a153 2
	     ((assoc (LT.CON_TAG n,cases))
	      handle Assoc =>
d189 1
a189 1
	     ((case assoc(var,bindings) of
d192 1
a192 1
		 handle Assoc => 
d208 2
a209 2
			 (assoc (x, case_list2))
			 handle Assoc =>
d224 1
a224 1
		     (forall is_constant (map snd case_list))
d229 1
a229 1
				      zip (map fst case_list,
d250 1
a250 1
		 (case assoc(var,bindings) of
d252 1
a252 1
		  | _ => false) handle Assoc => false
d295 1
a295 1
	    | identical (x::xs) = forall (curry op= x) xs
d312 1
a312 1
		  LT.SWITCH(expr,filterp remove_def case_list,case_def,ptr_def)
d320 1
a320 1
		  val sortedcases = qsort tag_order case_list
d367 1
a367 1
	      ((case assoc(v,bindings) of
d370 1
a370 1
		| _ => false) handle Assoc => false)
d381 1
a381 1
	  ((case assoc(var,bindings) of
d385 1
a385 1
	    | _ => str) handle Assoc => str)
d434 1
a434 1
		  reducel Set.union (lvar_set, lv_refs_list)
d460 1
a460 1
			  filterp (fn (lv, _) =>
d463 1
a463 1
			  filterp (fn (lv, _) => not(Set.is_member(lv, 
d472 1
a472 1
			new_lists(zip(lv_list, le_list))
d529 1
a529 1
	  ((could_raise_exn_app (assoc(fnvar,bindings))) handle Assoc => true)
d551 7
@


1.8
log
@Made changes due to record selection now requiring both the total
size of the record as well as the index.
@
text
@d11 1
a11 1

d18 7
a24 5
functor OptimiseContract(structure Lib   : OPTIMISE_LIB
			 structure Ident : IDENT
			 structure Pervasives : PERVASIVES
			 sharing type Pervasives.pervasive = Lib.LT.Primitive
			 sharing Ident = Lib.LT.Ident) : OPTIMISE_CONTRACT =
a32 3
  exception impossible of string
  fun imposs message = raise impossible message

d81 1
a81 1
	    | get_field _ = imposs "select_elim: bad SELECT field number!"
d113 1
a113 1
		       imposs "select_elim: bad SELECT field number!")
d130 2
a131 1
      val imposs = fn s => imposs ("LambdaOptimiser.switch_elim: "^s)
d140 2
a141 1
	   (_,[],LT.ABSENT,LT.ABSENT) => imposs "well screwy SWITCH!"
d149 1
a149 1
	 | (LT.INT n, cases, case_default, LT.ABSENT) =>
d155 1
a155 1
		     imposs "no constructor match or default"))
a156 2
	 | (LT.INT _, _, _, _) => imposs "screwy SWITCH-tag expression!"

d166 1
a166 1
			       imposs "no scon match or default"))
d172 1
a172 1
		 | find _ = imposs "mismatched SWITCH-scon expression"
d177 1
a177 1
	 | (LT.SCON _, _, _, _) => imposs "screwy SWITCH-scon expression!"
d184 1
a184 1
	      |  LT.ABSENT => imposs "no pointer-default")
d210 1
a210 1
			    | LT.ABSENT => imposs"screwy nesting")
d215 1
a215 1
			| _ => imposs "never say never")
d274 1
a274 1
		    | LT.ABSENT => imposs "no exn def!")
d279 1
a279 1
	 | (LT.BUILTIN _, _, _, _) => imposs "screwy SWITCH-exn expression!"
d316 1
a316 1
		    | tag_order _ = imposs "tag mismatch in switch"
d321 1
a321 1
		    | tagof _ = imposs "unexpected tag kind"
d418 2
a419 2
	    fun lv_refs_from_lv([], _, _) = imposs "lv_refs_from_lv"
	      | lv_refs_from_lv(_, [], _) = imposs "lv_refs_from_lv"
d529 1
a529 1
	| could_raise_exn_app _ = imposs "screwy lambda application"
d549 4
@


1.7
log
@Changes to raise_cut and switch shortening.
@
text
@d23 1
a23 1
 struct
d25 2
a26 1
  open Lib  infix mem == ++ -- (* !!! *)
a33 1

a39 1

d45 3
a47 2
   case expression of
      LT.APP(LT.FN(var,body),copy as LT.VAR _) => LS.substitute (var,copy,body)
d49 4
a52 3
	 if (is_shiftable arg) andalso (LS.occurrences(var,body)=1)
	    then LS.substitute (var,arg,body)
	 else expression
a54 1

d60 8
a67 8
     case expression of
	LT.FN(var,LT.APP(result,LT.VAR var')) =>
	   if (var=var') andalso 
	      not(var' mem (snd (LS.bounds_and_frees result))) andalso
	      (is_shiftable result)
	      	then result
	   else expression
       | _ => expression
a68 2


d73 10
a82 7
 fun select_elim (LT.Info{bindings,is_shiftable,...}) expression =
  let
     fun select_field (fieldlist, field) =
      let
        fun get_field (0, f::rest, unshifts) = (rev unshifts, f,
					       filterp 
						(not o is_shiftable) rest)
d84 1
a84 3
	  | get_field (n, f::fs, unshifts) = if is_shiftable f
						then get_field(n-1,fs,unshifts)
					     else get_field(n-1,fs,f::unshifts)
d86 7
a92 13
	  | get_field _ = imposs "select_elim: bad SELECT field number!"


	val (befores,f,afters) = get_field (LT.fromField field, fieldlist,[])

	val (result,resultbinds) = if is_shiftable f
				      then (f,[])
				   else 
				      let 
					 val resvar = LT.new_LVar()
				      in 
					 (LT.VAR resvar, [(resvar, f)]) 
				      end
d94 9
a102 5
	fun pair_new expr = (LT.new_LVar(), expr)
      in
	 LS.wrap_lets(result, (map pair_new befores) @@  resultbinds @@
		      	      (map pair_new afters))
      end
a103 6
  in

     case expression of

	LT.SELECT(field,LT.STRUCT expr_list) => select_field (expr_list, field)

d105 1
a105 1
	   		     LT.LETREC(lvl,lel,select_field (expr_list, field))
d107 2
a108 2
      | LT.SELECT(field, LT.VAR var) =>
	   ((case assoc(var,bindings) of
d110 7
a116 7
	       let
		  val result = (nth (LT.fromField field, fieldlist)
				handle Nth => 
			        imposs "select_elim: bad SELECT field number!")
	       in
		  if (is_shiftable result)
		     then result
d118 1
a118 1
	       end
d120 1
a120 1
		
d122 1
a123 6
 end (* of local *)


	  


d129 3
a131 3
 fun switch_elim (LT.Info{is_shiftable,bindings,...}) =
  let
     val imposs = fn s => imposs ("LambdaOptimiser.switch_elim: "^s)
d133 3
a135 3
     fun makeK (eval,result) = if (is_shiftable eval)
				  then result
			       else LT.APP(LT.FN(LT.new_LVar(),result),eval)
d137 1
a137 3

     fun elim1 (switch_expr as LT.SWITCH switch) =

d139 2
d142 4
a145 1
    (* no branches is completely screwy *)
d147 7
a153 18
     (_,[],LT.ABSENT,LT.ABSENT) => imposs "well screwy SWITCH!"


    (* single branches *)
    
   | (expr,[],LT.ABSENT,LT.PRESENT default) => makeK (expr,default)
   | (expr,[],LT.PRESENT default,LT.ABSENT) => makeK (expr,default)
   | (expr,[(_,item)],LT.ABSENT,LT.ABSENT)  => makeK (expr,item)


    (* switch on atomic constants *)

   | (LT.INT n, cases, case_default, LT.ABSENT) =>
	 ((assoc (LT.CON_TAG n,cases))
	  handle Assoc =>
	     (case case_default of
		 LT.PRESENT expr => expr
	       | LT.ABSENT => 
d156 1
a156 1
   | (LT.INT _, _, _, _) => imposs "screwy SWITCH-tag expression!"
d158 10
a167 5
   | (LT.SCON scon, cases, case_default, LT.ABSENT) => 
	 let 
	     fun find [] = 
		(case scon of 
		     Ident.REAL _ => elim2 switch_expr  (* do at runtime *)
d169 3
a171 4
		   	      | _ => (case case_default of
					  (LT.PRESENT expr) => expr
					|  LT.ABSENT => 
 				     imposs "no scon match or default"))
d173 4
a176 4
	       | find ((LT.SCON_TAG tag,expr)::cs)= 
		 			if Ident.scon_eqrep(tag,scon) 
					    then expr
					else find cs
d178 1
a178 4
	       | find _ = imposs "mismatched SWITCH-scon expression"
	 in
	     find cases
	 end
d180 1
a180 1
   | (LT.SCON _, _, _, _) => imposs "screwy SWITCH-scon expression!"
d182 4
d187 16
a202 23
   (* switch on constant structures *)

   | (LT.STRUCT _, _, _, ptr_default) =>
	 (case ptr_default of
	      (LT.PRESENT expr') => expr'
	    |  LT.ABSENT => imposs "no pointer-default")

   | (LT.VAR var, _, _, LT.PRESENT ptr_def) => ((case assoc(var,bindings) of
						    LT.STRUCT _ => ptr_def
						  | _ => elim2 switch_expr)
						handle Assoc => 
						   elim2 switch_expr)

   (*  nested switches with constant results  *)

   | (LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
      case_list2, case_def2, LT.ABSENT) =>
     let
	fun is_constant (LT.INT _) = true
	  | is_constant (LT.SCON _) = true
	  | is_constant _ = false
	and is_constant_opt (LT.PRESENT x) = is_constant x
	  | is_constant_opt LT.ABSENT = true
d204 14
a217 13
	fun new_result constant =
	   let 
	      fun find_it x = 
		 (assoc (x, case_list2))
		 handle Assoc => (case case_def2 of
				     LT.PRESENT expr => expr
				   | LT.ABSENT => imposs"screwy nesting")
	   in
	      (case constant of
		  LT.INT i => find_it (LT.CON_TAG i)
		| LT.SCON s => find_it (LT.SCON_TAG s)
		| _ => imposs "never say never")
	   end
d219 15
a233 14
	fun apopt f LT.ABSENT = LT.ABSENT
	  | apopt f (LT.PRESENT expr) = LT.PRESENT (f expr)
     in
	if (forall is_constant (map snd case_list))
	   andalso (is_constant_opt case_def1)
	   andalso (is_constant_opt ptr_def1)
	   then 
	      elim1 (LT.SWITCH(innerexpr, 
			       zip (map fst case_list,
				    map new_result (map snd case_list)),
			       apopt new_result case_def1,
			       apopt new_result ptr_def1))
	else elim2 switch_expr
     end
d235 1
a235 1
    | _ => elim2 switch_expr)
d237 1
a237 1
       | elim1 expression = expression
d239 1
d241 1
a241 4

     (* <second set of cases possibly overlapped above> *)

     and elim2 (switch_expr as (LT.SWITCH switch)) =
d244 3
a246 4
  
     (exnvalue, cases, case_default, LT.ABSENT) => 
	let
	   val exntag = LT.EXP_TAG exnvalue
d248 4
a251 4
	   fun known_exn var = 
	      (case assoc(var,bindings) of
		  LT.APP(LT.BUILTIN Pervasives.MAKE_NEW_UNIQUE,_) => true
		| _ => false) handle Assoc => false
d253 5
a257 4
	   val known_exn_expr = case exnvalue of 
	      			  LT.VAR var => known_exn var
				| LT.BUILTIN _ => true
				| _ => false
d259 6
a264 7
	   fun next_determinable ((tag,result)::cases) = 
	      if tag=exntag
		 then result
	      else (case tag of
		       LT.EXP_TAG (LT.BUILTIN _) => 
			  if known_exn_expr 
			     then next_determinable cases
d266 1
a266 1
		     | LT.EXP_TAG (LT.VAR exn_name) => 
d268 1
a268 1
			     then next_determinable cases
d270 1
a270 1
		     | _ => shorten switch_expr)
d272 7
a278 6
	     | next_determinable [] = (case case_default of
					  LT.PRESENT default => default
					| LT.ABSENT => imposs "no exn def!")
	in
	   next_determinable cases
	end
d280 1
a280 1
   | (LT.BUILTIN _, _, _, _) => imposs "screwy SWITCH-exn expression!"
d282 1
a282 1
   | _ => shorten switch_expr)
d284 1
a284 1
       | elim2 expression = expression
d290 5
a294 4
     and shorten (switch_expr as LT.SWITCH (expr,case_list,case_def,ptr_def)) =
      let
	 fun identical [] = true
	   | identical (x::xs) = forall (curry op= x) xs
d296 2
a297 2
	 fun listopt LT.ABSENT = []
	   | listopt (LT.PRESENT e) = [e]
d299 10
a308 9
	 val branch_values = (map snd case_list) @@ (listopt case_def) @@
	    		     (listopt ptr_def)
      in
       if identical branch_values
	  then makeK (expr, hd branch_values)
       else 
	 case case_def of
	    (LT.PRESENT default) =>  (* remove duplicated default values *)
	       let
d310 1
a310 1
	       in
d312 1
a312 1
	       end
d314 4
a317 4
	  | LT.ABSENT =>  (* assume absent default means CON_TAG's *)
	     let
		fun tag_order ((LT.CON_TAG i,_), (LT.CON_TAG j,_)) = i>=j
		  | tag_order _ = imposs "tag mismatch in switch"
d319 1
a319 1
		val sortedcases = qsort tag_order case_list
d321 2
a322 2
		fun tagof (LT.CON_TAG tag,_) = tag
		  | tagof _ = imposs "unexpected tag kind"
d324 1
a324 1
		fun valof (_, expr) = expr
d326 17
a342 1
		fun noncontig ([],[x]) = ([], LT.PRESENT (valof x))
d344 10
a353 1
		  | noncontig ([],[x1,x2]) = ([x1], LT.PRESENT (valof x2))
a354 32
		  | noncontig ([],x1::x2::xs) = 
		    if (tagof x1)<>(tagof x2)+1
		       then (rev (x2::xs), LT.PRESENT (valof x1))
		    else noncontig ([x1],x2::xs)

		  | noncontig (a::acc,x1::x2::xs) = 
		    if (tagof a)<>(tagof x1)+1 andalso (tagof x1)<>(tagof x2)+1
		       then ((rev xs)@@(x2::a::acc), LT.PRESENT (valof x1))
		    else noncontig (x1::a::acc,x2::xs)

		  | noncontig (a::acc,[x]) =
		    if (tagof a)<>(tagof x)+1
		       then (a::acc, LT.PRESENT (valof x))
		    else (x::a::acc, LT.ABSENT)

		  | noncontig (acc,[]) = (acc,LT.ABSENT)

		val (newcases,newdefault) = noncontig ([],sortedcases)
	     in 
		LT.SWITCH(expr,newcases,newdefault,ptr_def)
	     end
      end
   
       | shorten expression = expression

  in
     elim1
  end;
 



d360 15
a374 16
     let
	fun is_restruct (expr,selects) =
	   let 
	      fun i(n,LT.SELECT(f,e)::ss) = 
		 e=expr andalso (LT.fromField f)=n andalso i(n+1,ss)
		| i(n,(LT.VAR v)::ss) = 
		  ((case assoc(v,bindings) of
		       LT.SELECT(f,e) => e=expr andalso
			  		  (LT.fromField f)=n andalso
					    i(n+1,ss)
		     | _ => false) handle Assoc => false)
		| i(_,[]) = true
		| i _ = false
	   in 
	      i(0,selects)
	   end
d376 10
a385 12
	fun elim (str as LT.STRUCT(sels as (LT.SELECT(_,str'))::_)) = 
	   if is_restruct (str',sels)
	      then str'
	   else 
	      str
	  | elim (str as LT.STRUCT(sels as ((LT.VAR var)::_))) =
	    ((case assoc(var,bindings) of
		 LT.SELECT(f,str') => if is_restruct (str',sels)
					 then str'
				      else str
	       | _ => str) handle Assoc => str)
	  | elim expr = expr
d387 15
a401 13
	and backwards_elim (expr as LT.APP(func, 
			    LT.STRUCT[LT.SELECT(f1,str1),LT.SELECT(f0,str0)]))=
	   if (LT.fromField(f1)=1) andalso (LT.fromField(f0)=0)
	      andalso str1=str0
	      andalso (is_commutative func)
	      andalso (is_shiftable str1)
	        then (info "One in a million! backwards commutative strelim";
		      LT.APP(func,str1))
	   else expr
	  | backwards_elim expr = elim expr
     in
	backwards_elim
     end;
d403 4
a407 7

     (*****************************************************)
     (*  LETREC elimination - removes redundant LETREC's  *)
     (*  and does dependency analysis to reduce scopes.   *)
     (*****************************************************)


d409 2
a410 2
   let
      (*  Jon's code moved here from _lambda.sml  *)
d412 3
a414 3
      fun reduce_letrec(arg as (lv_list, le_list, lambda_exp)) =
	let 
	   val lv_set = Set.list_to_set lv_list
d416 8
a423 2
	   fun refs le =
	      Set.intersection(#2 (LS.bounds_and_frees le), lv_set)
d425 1
a425 6
	   fun lv_refs_from_lv([], _, _) = imposs "lv_refs_from_lv"
	     | lv_refs_from_lv(_, [], _) = imposs "lv_refs_from_lv"
	     | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
	       if lv = lv' 
		  then lv_refs 
	       else lv_refs_from_lv(lv_tl, lv_refs_tl, lv)
d427 1
a427 3
	   val lv_refs = map refs le_list

	   fun trans_refs lvar_set =
d429 5
a433 5
		 val lv_refs_list =
		    map (fn lv => lv_refs_from_lv(lv_list, lv_refs, lv))
		    (Set.set_to_list lvar_set)
		 val new_lvar_set =
		    reducel Set.union (lvar_set, lv_refs_list)
d435 2
a436 3
		 if Set.seteq(lvar_set, new_lvar_set) 
		    then lvar_set
		 else trans_refs new_lvar_set
d439 1
a439 1
	   val refs_list = map (trans_refs o Set.singleton) lv_list
d441 6
a446 7
	   fun finish_letrec(lv_list, le_list, lambda_exp) =
	      (* Remove recursion where possible *)
	      case (lv_list, le_list) of
		 ([lv], [le]) =>
		    if Set.is_member(lv, #2 (LS.bounds_and_frees le))
		       then
			  LT.LETREC(lv_list, le_list, lambda_exp)
d448 2
a449 2
		       LS.wrap_lets(lambda_exp, [(lv, le)])
	       | _ => LT.LETREC(lv_list, le_list, lambda_exp)
d451 4
a454 5
	   fun reduce [] = finish_letrec arg
	     | reduce (ref_hd :: ref_tl) =
	       if Set.seteq(ref_hd, lv_set) 
		  then reduce ref_tl
	       else
d456 12
a467 12
		     fun new_lists lv_le_list = 
			let 
			   val in_lv_le_list =
			      filterp (fn (lv, _) =>
				       Set.is_member(lv, ref_hd)) lv_le_list
			   val out_lv_le_list =
			      filterp (fn (lv, _) =>not(Set.is_member(lv, 
								      ref_hd)))
			      lv_le_list
			in
			   (in_lv_le_list, out_lv_le_list)
			end
d469 9
a477 9
		     let 
			val (in_list, out_list) =
			   new_lists(zip(lv_list, le_list))
		     in
			reduce_letrec(map #1 in_list, map #2 in_list,
				      reduce_letrec(map #1 out_list, 
						    map #2 out_list,
						    lambda_exp))
		     end
d479 6
a484 6
	in
	   reduce refs_list
	end
   in
      reduce_letrec arg
   end
d488 5
a492 5
      (********************************************************)
      (*  RAISE-cut.  Removes redundant code appearing after  *)
      (*  explicit RAISEs in evaluation sequence, and after   *)
      (*  HANDLE's. 	      				      *)
      (********************************************************)
d495 1
a495 1
   let
a498 1

d505 17
a521 1
	 case testexpr of
a522 16
	    LT.RAISE _   => true
	  | LT.SCON _    => false
	  | LT.INT _     => false
	  | LT.VAR _     => false
	  | LT.FN _      => false
	  | LT.LETREC _  => false
	  | LT.BUILTIN _ => false
	  | LT.STRUCT lel => exists could_raise_exn lel
	  | LT.SELECT(f,le) => could_raise_exn le
	  | LT.HANDLE(e,h)  => (could_raise_exn e) andalso (could_raise_exn h)
	  | LT.SWITCH(e,cs,cd,pd) => (could_raise_exn e) orelse 
	       	                     (exists could_raise_exn (map snd cs))
				     orelse (could_raise_exn_opt cd)
				     orelse (could_raise_exn_opt pd)
	  | LT.APP(p,q) => (could_raise_exn_app p) orelse (could_raise_exn q)

d527 2
a528 3
	| could_raise_exn_app (LT.VAR fnvar) = ((could_raise_exn_app 
						 (assoc(fnvar,bindings)))
						handle Assoc => true)
a531 1
      
a534 1

d536 1
a536 4
	 if could_raise_exn func
	    then app_expr
	 else raise_expr

d538 4
a541 7

	| cut (LT.HANDLE(LT.RAISE exn_value, handler)) = LT.APP(handler,
								exn_value)

	| cut (expr as LT.HANDLE(expr', handler)) = if could_raise_exn expr'
						       then expr
						    else expr'
d543 1
a543 1
   in
d545 1
a545 1
   end
a546 2


a547 1
	 
d549 4
a552 2

(* $Log$ *)
@


1.6
log
@Major renovation of switch_elimination, to add in shortening,
identical branches, and duplicated defaults.  Also fixed
preliminary version of exception-switch folding...
@
text
@d527 2
a528 1
      (*  explicit RAISEs in evaluation sequence. 	      *)
d531 1
a531 1
  fun raise_cut _ =
d533 48
a580 1
      fun cut (LT.APP(LT.FN _, raise_expr as LT.RAISE _)) = raise_expr
d582 1
d585 4
d594 3
a596 1
end;
d598 3
@


1.5
log
@Added raise_cut optimisation, switch elimination on
exceptions, copy propagations in beta_reduce.
@
text
@d13 1
a13 1
require "../ident";
d139 2
a140 1
  (* Switch-elimination -- removes redundant SWITCHes *)
d143 1
a143 2
 fun switch_elim (LT.Info{is_shiftable,bindings,...}) 
			(switch_expr as (LT.SWITCH switch)) =
a149 2
  in
     case switch of
d151 10
d163 1
a163 1
     (expr,[],LT.ABSENT,LT.PRESENT default) => makeK (expr,default)
d165 1
a165 1
   | (expr,[(_,item)],LT.ABSENT,LT.ABSENT) => makeK (expr,item)
d184 1
a184 1
		     Ident.REAL _ => switch_expr  (*dynamic equality instead*)
d211 5
a215 8
   | (LT.VAR var, _, _, ptr_default) => 
	(case ptr_default of
	    LT.ABSENT => switch_expr
	  | (LT.PRESENT expr') => ((case assoc(var,bindings) of
				       LT.STRUCT _ => expr'
				     | _ => switch_expr)
				   handle Assoc => switch_expr))
				  	   
d221 20
a240 6
     (let
	  fun is_constant (LT.INT _) = true
	    | is_constant (LT.SCON _) = true
	    | is_constant _ = false
	  and is_constant_opt (LT.PRESENT x) = is_constant x
	    | is_constant_opt LT.ABSENT = true
d242 14
a255 13
	  fun new_result constant =
	      let 
		  fun find_it x = 
		     (assoc (x, case_list2))
		     handle Assoc => (case case_def2 of
					 LT.PRESENT expr => expr
				       | LT.ABSENT => imposs"screwy nesting")
	      in
		 (case constant of
		     LT.INT i => find_it (LT.CON_TAG i)
		   | LT.SCON s => find_it (LT.SCON_TAG s)
		   | _ => imposs "never say never")
	      end
d257 1
a257 2
	  fun apopt f LT.ABSENT = LT.ABSENT
	    | apopt f (LT.PRESENT expr) = LT.PRESENT (f expr)
d259 9
a267 12
      in
	  if (forall is_constant (map snd case_list))
	      andalso (is_constant_opt case_def1)
	      andalso (is_constant_opt ptr_def1)
	      then 
		  LT.SWITCH(innerexpr, 
			    zip (map fst case_list,
				 map new_result (map snd case_list)),
			    apopt new_result case_def1,
			    apopt new_result ptr_def1)
	  else switch_expr
      end)
d269 1
a269 1
   | (exnvalue, cases, case_default, LT.ABSENT) => 
d276 1
a276 1
		| _ => false)
d280 1
d287 4
a290 1
		       LT.EXP_TAG (LT.BUILTIN _) => next_determinable cases
d294 2
a295 2
			  else switch_expr
		     | _ => switch_expr)
d299 1
a299 1
					| LT.ABSENT => imposs "can't find exn")
d306 1
a306 3
   | _ => switch_expr  (* none of the above *)
  end
   | switch_elim _ expression = expression
d308 1
d310 3
d314 70
d496 2
a497 2
			      LS.filter(lv_le_list, fn (lv, _) =>
					Set.is_member(lv, ref_hd))
d499 3
a501 2
			      LS.filter(lv_le_list, fn (lv, _) =>
					not(Set.is_member(lv, ref_hd)))
@


1.4
log
@Added shiftable tests into select_elim, and completed
select_elim properly so that it works with variable
bindings to STRUCT's.
@
text
@d12 1
d20 2
d35 3
a37 4
  (*  All optimisation functions in this module either reduce  *)
  (*  or don't alter the size of the lambda-expression they    *)
  (*  are applied to.  Transformations are non-recursive:      *)
  (*  they are applied to the outermost lambda-expression only.*)
a40 1

d46 7
a52 6
     case expression of
	LT.APP(LT.FN(var,body),arg) => 
	   if (is_shiftable arg) andalso (LS.occurrences(var,body)=1)
	      then LS.substitute (var,arg,body)
	   else expression
      | _ => expression
d79 3
a81 3
        fun get_field (0, f::rest, unshifts) =(f, (rev unshifts) @@ 
					          (filterp (not o is_shiftable)
						   rest))
d88 14
d103 2
a104 4
	 case get_field (LT.fromField field, fieldlist, []) of
	    (expr, []) => expr
	  | (expr, [u]) => LS.wrap_lets (expr, [(LT.new_LVar(),u)])
	  | (expr, us) => LS.wrap_lets (expr, [(LT.new_LVar(),LT.STRUCT us)])
d106 1
d108 1
d125 1
a125 2
		     then (info "shiftable selection from struct-var";
			   result)
d142 2
a143 1
 fun switch_elim (LT.Info{is_shiftable,bindings,...}) expr =
d151 1
a151 1
     case expr of
d155 3
a157 3
     LT.SWITCH(expr,[],LT.ABSENT,LT.PRESENT default) => makeK (expr,default)
   | LT.SWITCH(expr,[],LT.PRESENT default,LT.ABSENT) => makeK (expr,default)
   | LT.SWITCH(expr,[(_,item)],LT.ABSENT,LT.ABSENT) => makeK (expr,item)
d162 1
a162 1
   | LT.SWITCH(LT.INT n, cases, case_default, LT.ABSENT) =>
d170 1
a170 1
   | LT.SWITCH(LT.INT _, _, _, _) => imposs "screwy SWITCH-tag expression!"
d172 1
a172 1
   | LT.SWITCH(LT.SCON scon, cases, case_default, LT.ABSENT) => 
d176 1
a176 1
		     Ident.REAL _ => expr  (* use dynamic equality instead *)
a191 2
		            
   | LT.SWITCH(LT.SCON _, _, _, _) => imposs "screwy SWITCH-scon expression!"
d193 1
d195 1
d198 1
a198 1
   | LT.SWITCH(LT.STRUCT _, _, _, ptr_default) =>
d203 1
a203 3
   (* constant unshiftable structures *)

   | LT.SWITCH(LT.VAR var, _, _, ptr_default) => 
d205 1
a205 1
	    LT.ABSENT => expr
d208 2
a209 2
				     | _ => expr)
				   handle Assoc => expr))
d211 1
d214 2
a215 2
   | LT.SWITCH(LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
	       case_list2, case_def2, LT.ABSENT) =>
d250 1
a250 1
	  else expr
d253 3
a255 1
   | _ => expr
d257 4
a260 1
  end;
d262 3
d266 10
d277 15
d342 1
d345 1
a347 4
  (* NB:- it isn't likely that this will apply often, as the       *)
  (*      translator does a more complex dependency analysis       *)
  (*      to break up val rec's.  However, sometimes optimisation  *)
  (*      may expose a supposedly recursive LETREC to be a FN...   *)
d351 2
d431 16
@


1.3
log
@Added LETREC dependency analysis from lambda translator, as optimisation
can introduce redundant LETREC's.  Code by jont.
@
text
@d73 7
a79 6
 local
    fun select_field (fieldlist, field) =
       (nth (LT.fromField field, fieldlist)
	handle Nth => 
	   imposs "select_field: bad SELECT field number!")
 in
d81 12
a92 1
  fun select_elim (LT.Info{bindings,is_shiftable,...}) expression =
d95 1
a95 1
      LT.SELECT(field,LT.STRUCT expr_list) => select_field (expr_list, field)
d97 2
a98 2
    | LT.SELECT(field,LT.LETREC(lvl,lel,LT.STRUCT expr_list)) =>
	    		     LT.LETREC(lvl,lel,select_field (expr_list, field))
d100 16
a115 12
    | LT.SELECT(field, LT.VAR var) =>
      ((case assoc(var,bindings) of
	   LT.STRUCT expr_list => 
	      let
		 val result = select_field(expr_list,field)
	      in
		 if (is_shiftable result)
		    then (info "shiftable selection from unshiftable struct";
			  result)
		 else expression
	      end
	 | _ => expression) handle Assoc => expression)
a116 2
    | _ => expression

d271 6
@


1.2
log
@Begun work on letrec-elimination, altered form of
calls to substitute in lambdasub.
@
text
@d283 5
a287 4
  fun letrec_elim _ expr = expr
(*
     let
	fun elim (LT.LETREC 
d289 13
a301 25
	val new_lv_pat_list =  map
	      (fn (pat, _) => (LambdaTypes.new_LVar(), pat)) rec_list
	    val new_env = env_from_list(map #1
	      (map (fn (lv, pat) => trans_individual_dec(pat, lv))
	        new_lv_pat_list))
	    val _ = map
	      (fn (_, []) => ()
	      | (_, _) =>
		raise(impossible"non-trivial lhs in letrec"))
	      env_le_list
	    val letrec_lambda = LambdaTypes.new_LVar()
	    val (lv_le_list, _) =
	      LambdaSub.number_from(map #1 new_lv_pat_list, 0,
		fn x => LambdaTypes.SELECT(LambdaTypes.toField x,
		  LambdaTypes.VAR letrec_lambda))
	    fun reduce_letrec(arg as (lv_list, le_list, lambda_exp)) =
	    let val lv_set = Set.list_to_set lv_list
	      fun refs le =
		Set.intersection(#2 (LambdaSub.bounds_and_frees le), lv_set)
	      fun lv_refs_from_lv([], _, _) = raise(impossible"lv_refs_from_lv")
	      | lv_refs_from_lv(_, [], _) = raise(impossible"lv_refs_from_lv")
	      | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
		if lv = lv' then lv_refs else lv_refs_from_lv(lv_tl, lv_refs_tl, lv)
	      val lv_refs = map refs le_list
	      fun trans_refs lvar_set =
d303 2
a304 2
		val lv_refs_list =
		  map (fn lv => lv_refs_from_lv(lv_list, lv_refs, lv))
d306 2
a307 2
		val new_lvar_set =
		  foldleft Set.union (lvar_set, lv_refs_list)
d309 3
a311 2
		if Set.seteq(lvar_set, new_lvar_set) then lvar_set
		else trans_refs new_lvar_set
d313 10
a322 8
	      val refs_list = map (trans_refs o Set.singleton) lv_list
	      fun finish_letrec(lv_list, le_list, lambda_exp) =
		(* Remove recursion where possible *)
		case (lv_list, le_list) of
		  ([lv], [le]) =>
		    if Set.is_member(lv, #2 (LambdaSub.bounds_and_frees le))
		      then
			LambdaTypes.LETREC(lv_list, le_list, lambda_exp)
d324 20
a343 17
		      let_lambdas_in_exp([(lv, le)], lambda_exp)
		| _ => LambdaTypes.LETREC(lv_list, le_list, lambda_exp)
	      fun reduce [] = finish_letrec arg
	      | reduce (ref_hd :: ref_tl) =
		if Set.seteq(ref_hd, lv_set) then
		  reduce ref_tl
		else
		  let fun new_lists lv_le_list = 
		    let val in_lv_le_list =
		      LambdaSub.filter(lv_le_list, fn (lv, _) =>
			Set.is_member(lv, ref_hd))
		      val out_lv_le_list =
			LambdaSub.filter(lv_le_list, fn (lv, _) =>
			  not(Set.is_member(lv, ref_hd)))
		    in
		      (in_lv_le_list, out_lv_le_list)
		    end
d345 9
a353 7
		    let val (in_list, out_list) =
		      new_lists(Lists.zip(lv_list, le_list))
		    in
		      reduce_letrec(map #1 in_list, map #2 in_list,
			reduce_letrec(map #1 out_list, map #2 out_list,
			  lambda_exp))
		    end
d355 7
a361 8
	    in
	      reduce refs_list
	    end
	  in
	    (new_env, (letrec_lambda,
	      reduce_letrec(map #1 lv_pat_exp_list, exp_list,
		LambdaTypes.STRUCT(map (LambdaTypes.VAR o #1) lv_pat_exp_list))
		       )
a362 5
	fun elim (LT.LETREC (lvl,lel,le)) =

letrec_;
     l
*)
@


1.1
log
@Initial revision
@
text
@d48 1
a48 1
	      then LS.substitute [(var,arg)] body
d163 1
a163 1
   | (LT.SWITCH(LT.SCON _, _, _, _)) => imposs "screwy SWITCH-scon expression!"
d168 1
a168 1
   | (LT.SWITCH(LT.STRUCT _, _, _, ptr_default)) =>
d175 1
a175 1
   | (LT.SWITCH(LT.VAR var, _, _, ptr_default)) => 
d185 2
a186 2
   | (LT.SWITCH(LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
		case_list2, case_def2, LT.ABSENT)) =>
d274 98
@
