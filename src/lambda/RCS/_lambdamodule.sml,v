head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.4
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.17.1.1.1.1.1
	MLWorks_workspace_97:1.17.3
	MLWorks_dt_wizard:1.17.2
	MLWorks_11c0_1997_09_09:1.17.1.1.1.1
	MLWorks_10r3:1.17.1.1.3
	MLWorks_10r2_551:1.17.1.1.2
	MLWorks_11:1.17.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.1.1
	MLWorks_20m0_1997_06_20:1.17
	MLWorks_1_0_r2c2_1997_06_14:1.17.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.1
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.16.5.1.1
	MLWorks_gui_1996_12_18:1.16.6
	MLWorks_1_0_Win32_1996_12_17:1.16.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.16.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.16.3.1
	MLWorks_1_0_Irix_1996_11_28:1.16.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.16.4
	MLWorks_1_0_Unix_1996_11_14:1.16.3
	MLWorks_Open_Beta2_1996_10_11:1.16.2
	MLWorks_License_dev:1.16.1
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.14
	MLWorks_Beta_1996_06_07:1.14
	MLWorks_Beta_1996_06_06:1.14
	MLWorks_Beta_1996_06_05:1.14
	MLWorks_Beta_1996_06_03:1.14
	MLWorks_Beta_1996_05_31:1.14
	MLWorks_Beta_1996_05_30:1.14
	ML_beta_release_12/08/94:1.9
	ML_beta_release_03/08/94:1.9
	ML_revised_beta_release_25/05/94:1.9
	ML_final_beta_release_02/03/94:1.9
	mlworks-28-01-1994:1.8
	Release:1.7
	mlworks-beta-01-09-1993:1.7
	MLWorks-1-0-4-29/01/1993:1.4
	MLWorks-1-0-3-21/12/1992:1.3
	MLWorks-1-0-2-15/12/1992:1.3
	MLWorks-1-0-1-04/12/1992:1.3;
locks; strict;
comment	@ * @;


1.17
date	96.11.22.11.50.18;	author matthew;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1;
next	1.16;

1.16
date	96.09.20.14.43.18;	author andreww;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1
	1.16.4.1
	1.16.5.1
	1.16.6.1;
next	1.15;

1.15
date	96.09.17.10.32.47;	author andreww;	state Exp;
branches;
next	1.14;

1.14
date	96.03.28.10.32.40;	author matthew;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	95.08.11.17.01.30;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.01.11.13.32.03;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.10.10.09.18.38;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.09.19.13.27.13;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	94.02.28.07.54.27;	author nosa;	state Exp;
branches;
next	1.8;

1.8
date	94.01.19.12.41.40;	author nosa;	state Exp;
branches;
next	1.7;

1.7
date	93.07.08.13.46.36;	author nosa;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	93.07.06.13.15.14;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	93.03.10.15.40.10;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	93.01.14.14.34.26;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	92.10.28.10.19.13;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.10.05.08.22.36;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.10.01.13.50.47;	author richard;	state Exp;
branches;
next	;

1.7.1.1
date	93.07.08.13.46.36;	author jont;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.17.15;	author hope;	state Exp;
branches;
next	;

1.16.1.1
date	96.10.07.16.07.01;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.17.11.25.17;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.11.14.12.50.17;	author hope;	state Exp;
branches
	1.16.3.1.1.1;
next	;

1.16.3.1.1.1
date	96.11.28.15.01.25;	author hope;	state Exp;
branches;
next	;

1.16.4.1
date	96.11.22.18.09.43;	author hope;	state Exp;
branches;
next	;

1.16.5.1
date	96.12.17.17.48.23;	author hope;	state Exp;
branches
	1.16.5.1.1.1;
next	;

1.16.5.1.1.1
date	97.02.24.11.38.18;	author hope;	state Exp;
branches;
next	;

1.16.6.1
date	96.12.18.09.42.23;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	97.05.12.10.34.53;	author hope;	state Exp;
branches
	1.17.1.1.1.1
	1.17.1.1.2.1
	1.17.1.1.3.1;
next	;

1.17.1.1.1.1
date	97.07.28.18.20.15;	author daveb;	state Exp;
branches
	1.17.1.1.1.1.1.1;
next	;

1.17.1.1.1.1.1.1
date	97.10.07.11.45.23;	author jkbrook;	state Exp;
branches;
next	;

1.17.1.1.2.1
date	97.09.08.17.13.45;	author daveb;	state Exp;
branches;
next	;

1.17.1.1.3.1
date	97.09.09.14.09.27;	author daveb;	state Exp;
branches;
next	;

1.17.2.1
date	97.09.10.19.25.11;	author brucem;	state Exp;
branches;
next	;

1.17.3.1
date	97.09.11.20.55.34;	author daveb;	state Exp;
branches;
next	;

1.17.4.1
date	99.04.01.17.57.14;	author daveb;	state Exp;
branches;
next	;


desc
@Lambda environment to module expression translation.
Functor.
@


1.17
log
@Tidying
@
text
@(*  ==== LAMBDA ENVIRONMENT/MODULE TRANSLATION ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Notes
 *  -----
 *  This code was move here from the compiler top level.
 *
 *  Revision Log
 *  ------------
 *  $Log: _lambdamodule.sml,v $
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
 * Revision 1.14  1996/03/28  10:32:40  matthew
 * Adding where type clause
 *
 * Revision 1.13  1995/08/11  17:01:30  daveb
 * Replaced uses of LamdaTypes.Option.opt with MLWorks.Option.option.
 *
 *  Revision 1.12  1995/01/11  13:32:03  matthew
 *  Debugger changes
 *
 *  Revision 1.11  1994/10/10  09:18:38  matthew
 *  Lambdatypes changes
 *
 *  Revision 1.10  1994/09/19  13:27:13  matthew
 *  Abstraction of debug information in lambdatypes
 *
 *  Revision 1.9  1994/02/28  07:54:27  nosa
 *  generate_moduler compiler option in strenvs and funenvs for compatibility purposes.
 *
 *  Revision 1.8  1994/01/19  12:41:40  nosa
 *  Paths in LAMBs for dynamic pattern-redundancy reporting
 *
 *  Revision 1.7  1993/07/08  13:46:36  nosa
 *  Type of constructor LETB has changed for local and closure
 *  variable inspection in the debugger.
 *
 *  Revision 1.6  1993/07/06  13:15:14  daveb
 *  Removed exception environments and interfaces.
 *
 *  Revision 1.5  1993/03/10  15:40:10  matthew
 *  Signature revisions
 *
 *  Revision 1.4  1993/01/14  14:34:26  daveb
 *  Changed explicit manipulation of list representations to use new format.
 *
 *  Revision 1.3  1992/10/28  10:19:13  jont
 *  Changed to use less than functions for maps. Fixed a bug whereby funid_order
 *  was used as an equality function
 *
 *  Revision 1.2  1992/10/05  08:22:36  clive
 *  Change to NewMap.empty which now takes < and = functions instead of the single-function
 *
 *  Revision 1.1  1992/10/01  13:50:47  richard
 *  Initial revision
 *
 *)

require "../utils/crash";
require "../utils/lists";

require "environ";
require "lambdamodule";

functor LambdaModule (structure Environ	: ENVIRON
                      structure Lists	: LISTS
                      structure Crash	: CRASH

) : LAMBDAMODULE =
  struct
    structure EnvironTypes = Environ.EnvironTypes
    structure LambdaTypes = EnvironTypes.LambdaTypes
    structure Map = EnvironTypes.NewMap
    structure Ident = LambdaTypes.Ident

    fun ident(x as EnvironTypes.FIELD {index, ...}) = (true,x)
      | ident(x as EnvironTypes.PRIM _) = (false,x)
      | ident _ = Crash.impossible"External env not field"

    fun replace_ident(x, lvar) = lvar

    fun get_field_from_funenv(comp, (* _, *) _, _) = ident comp

    fun replace_field_in_funenv((_, env, gm), lvar) =
      (lvar, env, gm)

    fun get_field_from_strenv(_, comp, _) = ident comp

    fun replace_field_in_strenv((env, _, gm), lvar) = (env, lvar, gm)

    fun let_lambdas_in_exp(lv_le_list, lambda_exp) =
      Lists.reducer LambdaTypes.do_binding (lv_le_list, lambda_exp)

    fun extract_op (EnvironTypes.LAMB (x,_)) = LambdaTypes.VAR x
      | extract_op (EnvironTypes.PRIM x) = LambdaTypes.BUILTIN x
      | extract_op _ = Crash.impossible "extract_op problem"

    fun do_env([], _, le) = le
      | do_env(x :: xs, extract_fn, le) =
        let
          val lexp = extract_op(extract_fn x)
        in
          LambdaTypes.STRUCT([lexp, do_env(xs, extract_fn, le)],LambdaTypes.TUPLE)
        end


    val generate_moduler_debug = true


    fun pack (topenv as EnvironTypes.TOP_ENV
              (EnvironTypes.ENV(mv, ms),
               EnvironTypes.FUN_ENV m), decls_list) =
      let
        val valids = Map.to_list_ordered mv
        val strids = Map.to_list_ordered ms
        val funids = Map.to_list_ordered m
      in
        (Environ.assign_fields topenv,     (* allocate fields of an imaginary
                                              record for the various non-primitive
                                              ids *)
        (let_lambdas_in_exp                (* convert bindings in decls_list
                                              into a lambda expression which
                                              binds them explicitly using
                                              LETs and LETRECs *)
         (decls_list,
          do_env(valids, fn (_, x) => x,
                 do_env(strids, fn (_, (_, x, _)) => x,
                        do_env(funids, fn (_, (x, (* _, *) _, _)) => x,
                               LambdaTypes.INT 1))))))
                                        (* initial lambda expression for
                                           recursive construction of the
                                           nested LETs is INT 1. *)
      end



    fun unpack (EnvironTypes.TOP_ENV (EnvironTypes.ENV (val_map,struct_map),
                                      EnvironTypes.FUN_ENV fun_env),
                lambda_expression) =
      let
        val fun_list = Map.to_list_ordered fun_env
        val val_list = Map.to_list_ordered val_map
        val struct_list = Map.to_list_ordered struct_map
        val main_lvar = LambdaTypes.new_LVar()
        val var_main_lvar = LambdaTypes.VAR main_lvar

        fun get_new_binding_and_env(bindings, env, get_field, replace_field,
                                    x, start_lvar) =
          let
            fun sub_fun(bindings, env, [], finish_lvar) = (bindings, env, finish_lvar)
              | sub_fun(bindings, env, (x, y) :: rest, entry_lvar) =
                let
                  val (really_is_a_field, field) = get_field y
                  val lvar = LambdaTypes.new_LVar()
                  val lvar'' = LambdaTypes.new_LVar()
                in
                  sub_fun
                  (let
                    val bindings =
                      LambdaTypes.LETB(lvar'', NONE,LambdaTypes.SELECT
                                       ({index=1, size=2,selecttype=LambdaTypes.TUPLE}, entry_lvar)) ::
                      bindings
                    (* Note reverse order, we'll reverse it later *)
                   in
                     if really_is_a_field then
                       LambdaTypes.LETB
                       (lvar, NONE,
                        LambdaTypes.SELECT({index=0, size=2,selecttype=LambdaTypes.TUPLE},
                                           entry_lvar)) ::
                       bindings
                     else
                       (* No need to bind for a builtin *)
                       bindings
                   end,
                   Map.define
                   (env, x,
                    if really_is_a_field then
                      replace_field(y, EnvironTypes.LAMB(lvar,EnvironTypes.NOSPEC))
                    else y),
                   rest, LambdaTypes.VAR lvar'')
                end
          in
            sub_fun(bindings, env, x, start_lvar)
          end

        val main_binding =
          LambdaTypes.LETB(main_lvar, NONE, lambda_expression)

        val (bindings, val_env, finish_lvar) =
          get_new_binding_and_env([], Map.empty(Ident.valid_lt,Ident.valid_eq),
                                  ident, replace_ident, val_list,
                                  var_main_lvar)
        val (bindings, struct_env,finish_lvar) =
          get_new_binding_and_env(bindings,
                                   Map.empty(Ident.strid_lt,Ident.strid_eq),
                                   get_field_from_strenv,
                                   replace_field_in_strenv, struct_list,
                                   finish_lvar)
        val (bindings, fun_env,finish_lvar) =
          get_new_binding_and_env(bindings,
                                   Map.empty(Ident.funid_lt,Ident.funid_eq),
                                   get_field_from_funenv,
                                   replace_field_in_funenv, fun_list,
                                   finish_lvar)

        val new_fun_env =
          EnvironTypes.FUN_ENV fun_env

        val new_val_env =
          EnvironTypes.ENV(val_env, struct_env)
      in
        (EnvironTypes.TOP_ENV(new_val_env, new_fun_env),
         main_binding :: rev bindings)
      end

  end;
@


1.17.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 3
 * Revision 1.17  1996/11/22  11:50:18  matthew
 * Tidying
 *
@


1.17.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 3
 * Revision 1.17  1996/11/22  11:50:18  matthew
 * Tidying
 *
@


1.17.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 3
 * Revision 1.17  1996/11/22  11:50:18  matthew
 * Tidying
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a11 3
 * Revision 1.17  1996/11/22  11:50:18  matthew
 * Tidying
 *
@


1.17.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.17.1.1  1997/05/12  10:34:53  hope
 * branched from 1.17
 *
@


1.17.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.17.1.1  1997/05/12  10:34:53  hope
 * branched from 1.17
 *
@


1.17.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.17.1.1  1997/05/12  10:34:53  hope
 * branched from 1.17
 *
@


1.17.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.17.1.1.1.1  1997/07/28  18:20:15  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.16
log
@[Bug #1577]
Removing TE from environment ENV : it is redundant now!
@
text
@d12 4
d163 1
a163 1
                      LambdaTypes.LETB(lvar'',MLWorks.Option.NONE,LambdaTypes.SELECT
d170 1
a170 1
                       (lvar, MLWorks.Option.NONE,
d190 1
a190 1
          LambdaTypes.LETB(main_lvar, MLWorks.Option.NONE, lambda_expression)
@


1.16.6.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.16.5.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.16.5.1.1.1
log
@branched from 1.16.5.1
@
text
@a11 3
 * Revision 1.16.5.1  1996/12/17  17:48:23  hope
 * branched from 1.16
 *
@


1.16.4.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.16.3.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.16.3.1.1.1
log
@branched from 1.16.3.1
@
text
@a11 3
 * Revision 1.16.3.1  1996/11/14  12:50:17  hope
 * branched from 1.16
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a11 4
 * Revision 1.16  1996/09/20  14:43:18  andreww
 * [Bug #1577]
 * Removing TE from environment ENV : it is redundant now!
 *
@


1.15
log
@[Bug #1577]
Adding type constructor environment TE to environ.Env
@
text
@d105 1
d108 1
d133 2
@


1.14
log
@Adding where type clause
@
text
@d12 3
d115 7
a121 2
        (Environ.assign_fields topenv,
         (let_lambdas_in_exp
d124 6
a129 3
                        do_env(strids, fn (_, (_, x, _)) => x,
                               do_env(funids, fn (_, (x, (* _, *) _, _)) => x,
                                      LambdaTypes.INT 1))))))
d132 1
a132 1
    fun unpack (EnvironTypes.TOP_ENV (EnvironTypes.ENV (val_map, struct_map),
@


1.14.1.1
log
@branched from 1.14
@
text
@a11 3
 * Revision 1.14  1996/03/28  10:32:40  matthew
 * Adding where type clause
 *
@


1.13
log
@Replaced uses of LamdaTypes.Option.opt with MLWorks.Option.option.
@
text
@d12 3
a63 1
  sharing type Environ.EnvironTypes.LambdaTypes.LVar = int
@


1.12
log
@Debugger changes
@
text
@d12 3
d142 1
a142 1
                      LambdaTypes.LETB(lvar'',LambdaTypes.Option.ABSENT,LambdaTypes.SELECT
d149 1
a149 1
                       (lvar,LambdaTypes.Option.ABSENT,
d169 1
a169 1
          LambdaTypes.LETB(main_lvar,LambdaTypes.Option.ABSENT,lambda_expression)
@


1.11
log
@Lambdatypes changes
@
text
@d12 3
d157 1
a157 1
                      replace_field(y, EnvironTypes.LAMB(lvar,LambdaTypes.Option.ABSENT))
@


1.10
log
@Abstraction of debug information in lambdatypes
@
text
@d12 3
d91 1
a91 1
          LambdaTypes.STRUCT([lexp, do_env(xs, extract_fn, le)])
d137 1
a137 1
                                       ({index=1, size=2}, entry_lvar),"") ::
d144 2
a145 2
                        LambdaTypes.SELECT({index=0, size=2},
                                           entry_lvar),"") ::
d163 1
a163 1
          LambdaTypes.LETB(main_lvar,LambdaTypes.Option.ABSENT,lambda_expression, "")
@


1.9
log
@generate_moduler compiler option in strenvs and funenvs for compatibility purposes.
@
text
@d12 3
d133 1
a133 1
                      LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar''),LambdaTypes.SELECT
d140 1
a140 1
                       (LambdaTypes.Option.SOME1(lvar),
d160 1
a160 1
          LambdaTypes.LETB(LambdaTypes.Option.SOME1(main_lvar),lambda_expression, "")
@


1.8
log
@Paths in LAMBs for dynamic pattern-redundancy reporting
@
text
@d12 3
d48 4
a51 1
                      structure Crash	: CRASH) : LAMBDAMODULE =
d58 1
a58 1
    fun ident(x as EnvironTypes.FIELD _) = (true,x)
d64 1
a64 1
    fun get_field_from_funenv(comp, (* _, *) _) = ident comp
d66 2
a67 2
    fun replace_field_in_funenv((_, env), lvar) =
      (lvar, env)
d69 1
a69 1
    fun get_field_from_strenv(_, comp) = ident comp
d71 1
a71 1
    fun replace_field_in_strenv((env, _), lvar) = (env, lvar)
d88 2
d99 1
a99 1
         let_lambdas_in_exp
d102 3
a104 3
                        do_env(strids, fn (_, (_, x)) => x,
                               do_env(funids, fn (_, (x, (* _, *) _)) => x,
                                      LambdaTypes.INT 1)))))
@


1.7
log
@Type of constructor LETB has changed for local and closure
variable inspection in the debugger.
@
text
@d12 4
d70 1
a70 1
    fun extract_op (EnvironTypes.LAMB x) = LambdaTypes.VAR x
d140 1
a140 1
                      replace_field(y, EnvironTypes.LAMB lvar)
@


1.7.1.1
log
@Fork for bug fixing
@
text
@a11 4
 *  Revision 1.7  1993/07/08  13:46:36  nosa
 *  Type of constructor LETB has changed for local and closure
 *  variable inspection in the debugger.
 *
@


1.6
log
@Removed exception environments and interfaces.
@
text
@d12 3
d118 1
a118 1
                      LambdaTypes.LETB(lvar'', LambdaTypes.SELECT
d125 1
a125 1
                       (lvar,
d145 1
a145 1
          LambdaTypes.LETB(main_lvar, lambda_expression, "")
@


1.5
log
@Signature revisions
@
text
@d12 3
d51 1
a51 1
    fun get_field_from_funenv(comp, _, _) = ident comp
d53 2
a54 2
    fun replace_field_in_funenv((_, interface, env), lvar) =
      (lvar, interface, env)
d76 1
a76 1
              (EnvironTypes.ENV(mv, me, ms),
a79 1
        val exns = Map.to_list_ordered me
a86 1
                 do_env(exns, fn (_, x) => x,
d88 2
a89 2
                               do_env(funids, fn (_, (x, _, _)) => x,
                                      LambdaTypes.INT 1))))))
d92 1
a92 1
    fun unpack (EnvironTypes.TOP_ENV (EnvironTypes.ENV (val_map, exn_map, struct_map),
a97 1
        val exn_list = Map.to_list_ordered exn_map
a147 4
        val (bindings, exn_env,finish_lvar) =
          get_new_binding_and_env(bindings,
                                  Map.empty(Ident.valid_lt,Ident.valid_eq), ident,
                                  replace_ident, exn_list,finish_lvar)
d165 1
a165 1
          EnvironTypes.ENV(val_env, exn_env, struct_env)
@


1.4
log
@Changed explicit manipulation of list representations to use new format.
@
text
@d12 3
d29 1
d39 2
a40 3
    structure Datatypes = LambdaTypes.Datatypes
    structure Map = Datatypes.NewMap
    structure Ident = Datatypes.Ident
@


1.3
log
@Changed to use less than functions for maps. Fixed a bug whereby funid_order
was used as an equality function
@
text
@d12 4
d66 1
a66 4
          LambdaTypes.STRUCT[LambdaTypes.INT 0,
                             LambdaTypes.STRUCT([lexp,
                                                 do_env(xs, extract_fn,
                                                        le)])]
a106 1
                  val lvar' = LambdaTypes.new_LVar()
a110 1
                    val var_lvar' = LambdaTypes.VAR lvar'
a112 2
                                       ({index=1, size=2}, var_lvar'),"") ::
                      LambdaTypes.LETB(lvar', LambdaTypes.SELECT
d121 1
a121 1
                                           var_lvar'),"") ::
@


1.2
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d12 3
d31 3
a33 1
    structure Map = LambdaTypes.Datatypes.NewMap
d145 1
a145 1
          get_new_binding_and_env([], Map.empty(Environ.valid_order,Environ.valid_equal),
d150 1
a150 1
                                  Map.empty(Environ.valid_order,Environ.valid_equal), ident,
d154 1
a154 1
                                   Map.empty(Environ.strid_order,Environ.strid_equal),
d160 1
a160 1
                                   Map.empty(Environ.funid_order,Environ.funid_order),
@


1.1
log
@Initial revision
@
text
@d11 4
a14 1
 *  $Log$
d140 1
a140 1
          get_new_binding_and_env([], Map.empty Environ.valid_order,
d145 1
a145 1
                                  Map.empty Environ.valid_order, ident,
d149 1
a149 1
                                   Map.empty Environ.strid_order,
d155 1
a155 1
                                   Map.empty Environ.funid_order,
@
