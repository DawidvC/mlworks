head	1.21;
access;
symbols
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.3.1.1
	MLWorks_gui_1996_12_18:1.21.4
	MLWorks_1_0_Win32_1996_12_17:1.21.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.1.1
	MLWorks_1_0_Irix_1996_11_28:1.21.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.21.2
	MLWorks_1_0_Unix_1996_11_14:1.21.1
	MLWorks_Open_Beta2_1996_10_11:1.20.3
	MLWorks_License_dev:1.20.2
	MLWorks_1_open_beta_1996_09_13:1.20.1
	MLWorks_Open_Beta_1996_08_22:1.20
	MLWorks_Beta_1996_07_02:1.20
	MLWorks_Beta_1996_06_07:1.20
	MLWorks_Beta_1996_06_06:1.20
	MLWorks_Beta_1996_06_05:1.20
	MLWorks_Beta_1996_06_03:1.20
	MLWorks_Beta_1996_05_31:1.20
	MLWorks_Beta_1996_05_30:1.20
	ML_beta_release_12/08/94:1.15
	ML_beta_release_03/08/94:1.15
	ML_revised_beta_release_25/05/94:1.14
	ML_final_beta_release_02/03/94:1.14
	mlworks-28-01-1994:1.14
	Release:1.13
	mlworks-beta-01-09-1993:1.13
	MLWorks-1-0-4-29/01/1993:1.11
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.11
	MLWorks-1-0-1-04/12/1992:1.11
	checkpoint_17_08_92:1.10;
locks; strict;
comment	@ * @;


1.21
date	96.10.31.16.04.32;	author io;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1;
next	1.20;

1.20
date	95.12.22.17.23.44;	author jont;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1;
next	1.19;

1.19
date	95.08.11.17.18.40;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.01.09.14.30.55;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	94.10.10.10.15.18;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	94.09.19.13.49.22;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	94.07.22.09.09.58;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.08.12.12.18.48;	author nosa;	state Exp;
branches;
next	1.13;

1.13
date	93.07.30.09.01.31;	author nosa;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	93.03.01.15.03.35;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	92.10.26.14.47.36;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	92.07.22.10.44.00;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.07.01.12.36.43;	author davida;	state Exp;
branches;
next	1.8;

1.8
date	92.06.29.09.35.19;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.05.06.14.21.57;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.05.06.14.18.51;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.28.17.19.21;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.01.27.11.25.29;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.12.09.14.04.30;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.12.03.18.11.59;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.11.29.18.09.55;	author jont;	state Exp;
branches;
next	;

1.13.1.1
date	93.07.30.09.01.31;	author jont;	state Exp;
branches;
next	;

1.20.1.1
date	96.09.13.11.16.52;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.10.07.16.06.41;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.10.17.11.24.57;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	96.11.14.12.49.52;	author hope;	state Exp;
branches
	1.21.1.1.1.1;
next	;

1.21.1.1.1.1
date	96.11.28.15.01.04;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.11.22.18.09.24;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.12.17.17.48.03;	author hope;	state Exp;
branches
	1.21.3.1.1.1;
next	;

1.21.3.1.1.1
date	97.02.24.11.37.51;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.12.18.09.42.03;	author hope;	state Exp;
branches;
next	;


desc
@Elementary tail continuation spotting
@


1.21
log
@moving String from toplevel
@
text
@(* _tail.sml the functor *)
(*
$Log: _tail.sml,v $
 * Revision 1.20  1995/12/22  17:23:44  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
Revision 1.19  1995/08/11  17:18:40  daveb
Replaced uses of LambdaTypes.Option.opt with MLWorks.Option.option.

Revision 1.18  1995/01/09  14:30:55  matthew
Fixing APP-FN message

Revision 1.17  1994/10/10  10:15:18  matthew
Lambdatypes changes

Revision 1.16  1994/09/19  13:49:22  matthew
Abstraction of debug information in lambdatypes

Revision 1.15  1994/07/22  09:09:58  matthew
Functions and applications take a list of parameters

Revision 1.14  1993/08/12  12:18:48  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.13  1993/07/30  09:01:31  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.12  1993/03/01  15:03:35  matthew
Added MLVALUE lambda exp

Revision 1.11  1992/10/26  14:47:36  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.10  1992/07/22  10:44:00  jont
Added case to unwrap_lets to handle new LET constructor

Revision 1.9  1992/07/01  12:36:43  davida
Added LET constructor and new slot to APP.

Revision 1.8  1992/06/29  09:35:19  clive
Added type annotation information at applications

Revision 1.7  1992/05/06  14:21:57  jont
Modified to use augmented lambda calculus

Revision 1.6  1992/05/06  14:18:51  jont
Reversed order of indexes for selects off arguments

Revision 1.5  1992/01/28  17:19:21  jont
Added handlers for Lists.Assoc just in case

Revision 1.4  1992/01/27  11:25:29  jont
Removed diagnostic about non-tail recursive functions

Revision 1.3  1991/12/09  14:04:30  jont
Moved some functionality from _mir_cg to here to do with multi-argument
functions and select lifting

Revision 1.2  91/12/03  18:11:59  jont
Added function to remove simple select bindings

Revision 1.1  91/11/29  18:09:55  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__list";
require "../utils/crash";
require "lambdatypes";
require "../lambda/auglambda";
require "tail";

functor Tail(
  structure Crash : CRASH
  structure LambdaTypes : LAMBDATYPES
  structure AugLambda : AUGLAMBDA

  sharing LambdaTypes = AugLambda.LambdaTypes
) : TAIL =
struct
  structure LambdaTypes = LambdaTypes
  structure AugLambda = AugLambda

  fun unwrap_lets(acc, AugLambda.LET((lv,_,{lexp=le', ...}), {lexp=lexp, ...})) =
      unwrap_lets((lv, le') :: acc, lexp)
    | unwrap_lets(acc, le) = (rev acc, le)

  fun get_simple_selects([lvar], arg as {lexp=lexp, size=_}) =
    let
      val (bindings, _) = unwrap_lets([], lexp)
      fun check_for_select [] = NONE
        | check_for_select((_, le) :: xs) =
          (case le of
             AugLambda.SELECT(_, {lexp=AugLambda.VAR lv, ...}) =>
               if lv = lvar then SOME le
               else check_for_select xs
           | _ => check_for_select xs)
    in
      case check_for_select bindings of
	NONE => ([], lexp)
      | SOME le =>
	  let
	    val select_size = case le of
	      AugLambda.SELECT({size=size, ...}, _) => size
	    | _ => Crash.impossible"Binding not select"
	    fun make_indexes(acc, n) =
	      if n = 0 then acc
	      else
		if n < 0 then Crash.impossible"Listof negative"
		else
		  make_indexes((LambdaTypes.new_LVar(),
				{lexp=AugLambda.SELECT({index=n-1,
							size=select_size},
						       {lexp=AugLambda.VAR
							lvar,
							size=0}), size=0}) ::
			       acc, n-1)
	    val indexes = make_indexes([], select_size)
	    (* Note that these indexes come out in order *)
	    (* This is very important for build_args_for_tail in _mir_utils *)
	    fun subst_selects({lexp=lexp, size=size}) =
	      let
		val new_lexp =
		  case lexp of
		    AugLambda.SELECT({index=index, ...},
				     {lexp=AugLambda.VAR lv, ...}) =>
		    if lvar = lv then
		      AugLambda.VAR(#1(List.nth(indexes,index))) handle
		      Subscript => Crash.impossible"get_simple_selects"
		    else
		      lexp
		    | AugLambda.SELECT(field, le) =>
			AugLambda.SELECT(field, subst_selects le)
		    | AugLambda.VAR _ => lexp
		    | AugLambda.FN(lvl, le, name,instances) =>
			AugLambda.FN(lvl, subst_selects le, name,instances)
		    | AugLambda.LET((lv,info,lb),le) => 
			AugLambda.LET((lv,info, subst_selects lb), subst_selects le)
		    | AugLambda.LETREC(lv_list, le_list, le) =>
			AugLambda.LETREC(lv_list, map subst_selects le_list,
					 subst_selects le)
		    | AugLambda.APP(le,lel,debug) =>
			AugLambda.APP(subst_selects le, map subst_selects lel,debug)
		    | AugLambda.SCON _ => lexp
		    | AugLambda.MLVALUE _ => lexp
		    | AugLambda.INT _ => lexp
		    | AugLambda.SWITCH(le, info, tag_le_list, le_opt) =>
			AugLambda.SWITCH(subst_selects le,
					 info,
					 map subst_selects_tag tag_le_list,
					 subst_selects_opt le_opt)
		    | AugLambda.STRUCT le_list =>
			AugLambda.STRUCT(map subst_selects le_list)
		    | AugLambda.RAISE (le) => AugLambda.RAISE(subst_selects le)
		    | AugLambda.HANDLE(le, le') =>
			AugLambda.HANDLE(subst_selects le, subst_selects le')
		    | AugLambda.BUILTIN _ => lexp
	      in
		{lexp=new_lexp, size=size}
	      end
	    and subst_selects_opt(SOME le) =
	      SOME(subst_selects le)
	    | subst_selects_opt NONE = NONE
	    and subst_selects_tag(tag, le) =
	      let
		val new_tag = case tag of
		  AugLambda.EXP_TAG le => AugLambda.EXP_TAG(subst_selects le)
		| _ => tag
	      in
		(new_tag, subst_selects le)
	      end
	    fun occurs{lexp=lexp, size=_} =
	      case lexp of
		AugLambda.SELECT(_, {lexp=AugLambda.VAR _, ...}) => false
	      | AugLambda.SELECT(_, le) => occurs le
	      | AugLambda.VAR lv => lv = lvar
	      | AugLambda.FN(_, le, _,_) => occurs le
	      | AugLambda.LET((_, _,lb), le) => occurs lb orelse occurs le
	      | AugLambda.LETREC(_, le_list, le) =>
		  List.exists occurs (le :: le_list)
	      | AugLambda.APP(le, lel,_) => occurs le orelse List.exists occurs lel
	      | AugLambda.SCON _ => false
	      | AugLambda.MLVALUE _ => false
	      | AugLambda.INT _ => false
	      | AugLambda.SWITCH(le, info, tag_le_list, le_opt) =>
		  occurs le orelse occurs_opt le_opt orelse
		  List.exists occurs_tag tag_le_list
	      | AugLambda.STRUCT le_list => List.exists occurs le_list
	      | AugLambda.RAISE (le) => occurs le
	      | AugLambda.HANDLE(le, le') => occurs le orelse occurs le'
	      | AugLambda.BUILTIN _ => false
	    and occurs_opt(SOME le) = occurs le
	    | occurs_opt NONE = false
	    and occurs_tag(tag, le) =
	      occurs le orelse
	      (case tag of
		 AugLambda.EXP_TAG le => occurs le
	       | _ => false)
	  (* The occurs check could be done before the transformation, thus *)
	  (* preventing the transformation from being done unnecessarily *)
	  in
	    if occurs arg then
	      ([], lexp)
	    else
	      (indexes, #lexp(subst_selects arg))
	  end
    end
  | get_simple_selects(lvl, arg as {lexp=lexp, size=_}) =
    ([],lexp)

end
@


1.21.4.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/31  16:04:32  io
 * moving String from toplevel
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/31  16:04:32  io
 * moving String from toplevel
 *
@


1.21.3.1.1.1
log
@branched from 1.21.3.1
@
text
@a3 3
 * Revision 1.21.3.1  1996/12/17  17:48:03  hope
 * branched from 1.21
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/31  16:04:32  io
 * moving String from toplevel
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/10/31  16:04:32  io
 * moving String from toplevel
 *
@


1.21.1.1.1.1
log
@branched from 1.21.1.1
@
text
@a3 3
 * Revision 1.21.1.1  1996/11/14  12:49:52  hope
 * branched from 1.21
 *
@


1.20
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
d71 1
a72 1
require "../utils/lists";
a78 1
  structure Lists : LISTS
a87 2
  open MLWorks.Option

d95 1
a95 1
      fun check_for_select [] = MLWorks.Option.NONE
d99 1
a99 1
               if lv = lvar then MLWorks.Option.SOME le
d104 2
a105 2
	MLWorks.Option.NONE => ([], lexp)
      | MLWorks.Option.SOME le =>
d132 2
a133 2
		      AugLambda.VAR(#1(Lists.nth(index, indexes))) handle
		      Lists.Nth => Crash.impossible"get_simple_selects"
d184 2
a185 2
		  Lists.exists occurs (le :: le_list)
	      | AugLambda.APP(le, lel,_) => occurs le orelse Lists.exists occurs lel
d191 2
a192 2
		  Lists.exists occurs_tag tag_le_list
	      | AugLambda.STRUCT le_list => Lists.exists occurs le_list
@


1.20.3.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  17:23:44  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  17:23:44  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1995/12/22  17:23:44  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.19
log
@Replaced uses of LambdaTypes.Option.opt with MLWorks.Option.option.
@
text
@d4 3
a83 1
  structure Option = LambdaTypes.Option
d94 1
a94 1
      fun check_for_select [] = Option.ABSENT
d98 1
a98 1
               if lv = lvar then Option.PRESENT le
d103 2
a104 2
	Option.ABSENT => ([], lexp)
      | Option.PRESENT le =>
@


1.18
log
@Fixing APP-FN message
@
text
@d4 3
d83 2
d162 3
a164 3
	    and subst_selects_opt(Option.PRESENT le) =
	      Option.PRESENT(subst_selects le)
	    | subst_selects_opt Option.ABSENT = Option.ABSENT
d193 2
a194 2
	    and occurs_opt(Option.PRESENT le) = occurs le
	    | occurs_opt Option.ABSENT = false
@


1.17
log
@Lambdatypes changes
@
text
@d4 3
d80 1
a80 3
  fun unwrap_lets(acc, AugLambda.APP ({lexp=AugLambda.FN _,...},_,_)) =
      Crash.impossible "APP-FN in unwrap-lets"
    | unwrap_lets(acc, AugLambda.LET((lv,_,{lexp=le', ...}), {lexp=lexp, ...})) =
@


1.16
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d79 1
a79 1
    | unwrap_lets(acc, AugLambda.LET(lv,_,{lexp=le', ...}, {lexp=lexp, ...})) =
d132 2
a133 2
		    | AugLambda.LET(lv,info,lb,le) => 
			AugLambda.LET(lv,info, subst_selects lb, subst_selects le)
d173 1
a173 1
	      | AugLambda.LET(_, _,lb, le) => occurs lb orelse occurs le
@


1.15
log
@Functions and applications take a list of parameters
@
text
@d4 3
d72 1
d76 2
a77 2
    | unwrap_lets(acc, AugLambda.LET(lv,{lexp=le', ...}, {lexp=lexp, ...})) =
      unwrap_lets((LambdaTypes.fetch_var lv, le') :: acc, lexp)
d83 1
a83 1
      fun check_for_select [] = LambdaTypes.Option.ABSENT
d87 1
a87 1
               if lv = lvar then LambdaTypes.Option.PRESENT le
d92 2
a93 2
	LambdaTypes.Option.ABSENT => ([], lexp)
      | LambdaTypes.Option.PRESENT le =>
d129 2
a130 2
		    | AugLambda.LET(lv,lb,le) => 
			AugLambda.LET(lv, subst_selects lb, subst_selects le)
d153 3
a155 3
	    and subst_selects_opt(LambdaTypes.Option.PRESENT le) =
	      LambdaTypes.Option.PRESENT(subst_selects le)
	    | subst_selects_opt LambdaTypes.Option.ABSENT = LambdaTypes.Option.ABSENT
d170 1
a170 1
	      | AugLambda.LET(_, lb, le) => occurs lb orelse occurs le
d184 2
a185 2
	    and occurs_opt(LambdaTypes.Option.PRESENT le) = occurs le
	    | occurs_opt LambdaTypes.Option.ABSENT = false
@


1.14
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d70 2
a71 4
  fun unwrap_lets(acc, AugLambda.APP
		  ({lexp=AugLambda.FN(lv, {lexp=lexp, ...}, _,_), ...},
		   {lexp=le', ...},_)) =
    unwrap_lets((lv, le') :: acc, lexp)
d76 1
a76 1
  fun get_simple_selects(lvar, arg as {lexp=lexp, size=_}) =
d80 6
a85 6
      | check_for_select((_, le) :: xs) =
	(case le of
	  AugLambda.SELECT(_, {lexp=AugLambda.VAR lv, ...}) =>
	    if lv = lvar then LambdaTypes.Option.PRESENT le
	    else check_for_select xs
	| _ => check_for_select xs)
d123 2
a124 2
		    | AugLambda.FN(lv, le, name,instances) =>
			AugLambda.FN(lv, subst_selects le, name,instances)
d130 2
a131 2
		    | AugLambda.APP(le, le',debug) =>
			AugLambda.APP(subst_selects le, subst_selects le',debug)
d169 1
a169 1
	      | AugLambda.APP(le, le',_) => occurs le orelse occurs le'
d196 3
@


1.13
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d4 4
d67 1
a67 1
		  ({lexp=AugLambda.FN(lv, {lexp=lexp, ...}, _), ...},
d121 2
a122 2
		    | AugLambda.FN(lv, le, name) =>
			AugLambda.FN(lv, subst_selects le, name)
d163 1
a163 1
	      | AugLambda.FN(_, le, _) => occurs le
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.13  1993/07/30  09:01:31  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.12
log
@Added MLVALUE lambda exp
@
text
@d4 3
d66 2
a67 2
    | unwrap_lets(acc, AugLambda.LET(lv, {lexp=le', ...}, {lexp=lexp, ...})) =
      unwrap_lets((lv, le') :: acc, lexp)
d73 1
a73 1
      fun check_for_select [] = LambdaTypes.ABSENT
d77 1
a77 1
	    if lv = lvar then LambdaTypes.PRESENT le
d82 2
a83 2
	LambdaTypes.ABSENT => ([], lexp)
      | LambdaTypes.PRESENT le =>
d136 1
a136 1
		    | AugLambda.RAISE le => AugLambda.RAISE(subst_selects le)
d143 3
a145 3
	    and subst_selects_opt(LambdaTypes.PRESENT le) =
	      LambdaTypes.PRESENT(subst_selects le)
	    | subst_selects_opt LambdaTypes.ABSENT = LambdaTypes.ABSENT
d171 1
a171 1
	      | AugLambda.RAISE le => occurs le
d174 2
a175 2
	    and occurs_opt(LambdaTypes.PRESENT le) = occurs le
	    | occurs_opt LambdaTypes.ABSENT = false
@


1.11
log
@Minor changes to support the new type of SWITCHes.
@
text
@d4 3
d124 1
d162 1
@


1.10
log
@Added case to unwrap_lets to handle new LET constructor
@
text
@d4 3
d122 1
a122 1
		    | AugLambda.SWITCH(le, tag_le_list, le1_opt, le2_opt) =>
d124 1
d126 1
a126 2
					 subst_selects_opt le1_opt,
					 subst_selects_opt le2_opt)
d159 2
a160 3
	      | AugLambda.SWITCH(le, tag_le_list, le1_opt, le2_opt) =>
		  occurs le orelse occurs_opt le1_opt orelse
		  occurs_opt le2_opt orelse
@


1.9
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d57 2
@


1.8
log
@Added type annotation information at applications
@
text
@d4 3
d105 2
d145 1
@


1.7
log
@Modified to use augmented lambda calculus
@
text
@d4 3
d49 1
a49 1
		   {lexp=le', ...})) =
d105 2
a106 2
		    | AugLambda.APP(le, le') =>
			AugLambda.APP(subst_selects le, subst_selects le')
d142 1
a142 1
	      | AugLambda.APP(le, le') => occurs le orelse occurs le'
@


1.6
log
@Reversed order of indexes for selects off arguments
@
text
@d1 1
a1 1
(* tail.sml the functor *)
d4 3
d29 1
a29 1
require "lambdasub";
d36 1
a36 1
  structure LambdaSub : LAMBDASUB
d38 1
a38 1
  sharing LambdaTypes = LambdaSub.LT
d42 1
d44 5
a48 21
  fun is_tail(lvar, lexp) =
    let
      val (lets, unwrapped) = LambdaSub.unwrap_lets lexp
    in
      case unwrapped of
	LambdaTypes.APP(LambdaTypes.VAR _, _) => true
      (* Continues tailwise <=> APP to another function *)
      | LambdaTypes.SWITCH(_, tag_le_list, le1, le2) =>
	  let
	    fun is_tail_opt LambdaTypes.ABSENT = false
	    | is_tail_opt(LambdaTypes.PRESENT le) = is_tail(lvar, le)
	    val le_list = map #2 tag_le_list
	    fun is_tail_list [] = false
	    | is_tail_list(le :: rest) =
	      is_tail(lvar, le) orelse is_tail_list rest
	  in
	    is_tail_opt le1 orelse is_tail_opt le2 orelse
	    is_tail_list le_list
	  end
      | _ => false
    end
d50 1
a50 1
  fun get_simple_selects(lvar, lexp) =
d52 1
a52 1
      val (bindings, _) = LambdaSub.unwrap_lets lexp
d56 1
a56 1
	  LambdaTypes.SELECT(_, LambdaTypes.VAR lv) =>
d66 1
a66 1
	      LambdaTypes.SELECT({size=size, ...}, _) => size
d68 2
a69 16
	    fun listof 0 = []
	    | listof n = if n < 0 then Crash.impossible"Listof negative"
			  else (n-1) :: listof(n-1)
	    val indexes =
	      map
	      (fn x =>
	       (x, (LambdaTypes.new_LVar(),
		    LambdaTypes.SELECT({index=x, size=select_size},
				       LambdaTypes.VAR lvar))))
	      (rev(listof select_size))
	    fun sub_fun(exp as LambdaTypes.SELECT({index=index, ...},
						  LambdaTypes.VAR lv)) =
	      if lvar = lv then
		LambdaTypes.VAR(#1(Lists.assoc(index, indexes)))
		handle Lists.Assoc =>
		  Crash.impossible"get_simple_selects"
d71 88
a158 4
		exp
	    | sub_fun exp = exp
	    val new_exp = LambdaSub.apply_outermost sub_fun lexp
	    val arg_refs = LambdaSub.occurrences(lvar, new_exp)
d160 2
a161 2
	    if arg_refs = 0 then
	      (map #2 indexes, new_exp)
d163 1
a163 1
	       ([], lexp)
a166 1

@


1.5
log
@Added handlers for Lists.Assoc just in case
@
text
@d4 3
d89 1
a89 1
	      (listof select_size)
@


1.4
log
@Removed diagnostic about non-tail recursive functions
@
text
@d4 3
d91 2
@


1.3
log
@Moved some functionality from _mir_cg to here to do with multi-argument
functions and select lifting
@
text
@d3 5
a7 1
$Log:	_tail.sml,v $
d97 1
a97 2
	      (print"More argument references, not tail recursing";
	       ([], lexp))
@


1.2
log
@Added function to remove simple select bindings
@
text
@d4 3
d54 12
a65 2
      fun sub_fun(exp as LambdaTypes.SELECT(_, LambdaTypes.VAR lv)) =
	if lvar = lv then
d67 22
a88 1
	    val new_lv = LambdaTypes.new_LVar()
d90 5
a94 1
	    ([(new_lv, exp)], LambdaTypes.VAR new_lv)
a95 90
	else
	  ([], exp)
      | sub_fun(LambdaTypes.SELECT(index, lexp)) =
	let
	  val (bindings, exp) = sub_fun lexp
	in
	  (bindings, LambdaTypes.SELECT(index, exp))
	end  
      | sub_fun(LambdaTypes.FN(lv, lexp)) =
	let
	  val (bindings, exp) = sub_fun lexp
	in
	  (bindings, LambdaTypes.FN(lv, exp))
	end
      | sub_fun(LambdaTypes.LETREC(lv_list, le_list, le)) =
	let
	  val bind_exp_list = map sub_fun(le :: le_list)
	  val bindings = map #1 bind_exp_list
	  val exps = map #2 bind_exp_list
	in
	  (Lists.reducel op @@ ([], bindings),
	   LambdaTypes.LETREC(lv_list, tl exps, hd exps))
	end
      | sub_fun(LambdaTypes.APP(le1, le2)) =
	let
	  val (bind1, le1) = sub_fun le1
	  val (bind2, le2) = sub_fun le2
	in
	  (bind1 @@ bind2, LambdaTypes.APP(le1, le2))
	end
      | sub_fun(LambdaTypes.RAISE le) =
	let
	  val (bindings, exp) = sub_fun le
	in
	  (bindings, LambdaTypes.RAISE exp)
	end
      | sub_fun(LambdaTypes.STRUCT le_list) =
	let
	  val bind_exp_list = map sub_fun le_list
	in
	  (Lists.reducel op @@ ([], map #1 bind_exp_list),
	   LambdaTypes.STRUCT(map #2 bind_exp_list))
	end
      | sub_fun(LambdaTypes.HANDLE(le1, le2)) =
	let
	  val (bind1, le1) = sub_fun le1
	  val (bind2, le2) = sub_fun le2
	in
	  (bind1 @@ bind2, LambdaTypes.HANDLE(le1, le2))
	end
      | sub_fun(LambdaTypes.SWITCH(le, tag_le_list, le_opt1, le_opt2)) =
	let
	  fun do_opt LambdaTypes.ABSENT = ([], LambdaTypes.ABSENT)
	  | do_opt(LambdaTypes.PRESENT le) =
	    let
	      val (bindings, exp) = sub_fun le
	    in
	      (bindings, LambdaTypes.PRESENT exp)
	    end
	  val (b, le) = sub_fun le
	  val (b1, opt1) = do_opt le_opt1
	  val (b2, opt2) = do_opt le_opt2
	  val bind_tag_le_list =
	    map
	    (fn (tag, le) =>
	     let
	       val (b1, le1) = sub_fun le
	       val (b2, tag) = case tag of
		 LambdaTypes.EXP_TAG le =>
		   let
		     val (binding, le) = sub_fun le
		   in
		     (binding, LambdaTypes.EXP_TAG le)
		   end
	       | _ => ([], tag)
	     in
	       (b1 @@ b2, (tag, le1))
	     end)
	    tag_le_list
	  val bindings =
	    Lists.reducel
	    op @@
	    (b @@ b1 @@ b2, map #1 bind_tag_le_list)
	in
	  (bindings,
	   LambdaTypes.SWITCH(le, map #2 bind_tag_le_list, opt1, opt2))
	end
      | sub_fun exp = ([], exp)
    in
      sub_fun lexp
d98 1
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d11 1
d18 1
d47 101
@
