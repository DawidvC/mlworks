head	1.55;
access;
symbols
	MLW_daveb_inline_1_4_99:1.55.4
	MLWorks_21c0_1999_03_25:1.55
	MLWorks_20c1_1998_08_20:1.55
	MLWorks_20c0_1998_08_04:1.55
	MLWorks_20b2c2_1998_06_19:1.55
	MLWorks_20b2_Windows_1998_06_12:1.55
	MLWorks_20b1c1_1998_05_07:1.55
	MLWorks_20b0_1998_04_07:1.55
	MLWorks_20b0_1998_03_20:1.55
	MLWorks_20m2_1998_02_16:1.55
	MLWorks_20m1_1997_10_23:1.55
	MLWorks_11r1:1.55.1.1.1.1.1
	MLWorks_workspace_97:1.55.3
	MLWorks_dt_wizard:1.55.2
	MLWorks_11c0_1997_09_09:1.55.1.1.1.1
	MLWorks_10r3:1.55.1.1.3
	MLWorks_10r2_551:1.55.1.1.2
	MLWorks_11:1.55.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.55.1.1
	MLWorks_20m0_1997_06_20:1.55
	MLWorks_1_0_r2c2_1997_06_14:1.55.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.55.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.55.1
	MLWorks_BugFix_1997_04_24:1.55
	MLWorks_1_0_r2_Win32_1997_04_11:1.55
	MLWorks_1_0_r2_Unix_1997_04_04:1.55
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.54.6.1.1
	MLWorks_gui_1996_12_18:1.54.7
	MLWorks_1_0_Win32_1996_12_17:1.54.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.54.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.54.4.1
	MLWorks_1_0_Irix_1996_11_28:1.54.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.54.5
	MLWorks_1_0_Unix_1996_11_14:1.54.4
	MLWorks_Open_Beta2_1996_10_11:1.54.3
	MLWorks_License_dev:1.54.2
	MLWorks_1_open_beta_1996_09_13:1.54.1
	MLWorks_Open_Beta_1996_08_22:1.54
	MLWorks_Beta_1996_07_02:1.54
	MLWorks_Beta_1996_06_07:1.54
	MLWorks_Beta_1996_06_06:1.54
	MLWorks_Beta_1996_06_05:1.54
	MLWorks_Beta_1996_06_03:1.54
	MLWorks_Beta_1996_05_31:1.54
	MLWorks_Beta_1996_05_30:1.54
	ML_beta_release_12/08/94:1.41
	ML_beta_release_03/08/94:1.41
	ML_revised_beta_release_25/05/94:1.41
	ML_final_beta_release_02/03/94:1.41
	mlworks-28-01-1994:1.40
	Release:1.39
	mlworks-beta-01-09-1993:1.39
	MLWorks-1-0-4-29/01/1993:1.34
	MLWorks-1-0-3-21/12/1992:1.34
	MLWorks-1-0-2-15/12/1992:1.34
	MLWorks-1-0-1-04/12/1992:1.34
	checkpoint_17_08_92:1.27
	Ten15_release_21-08-91:1.16
	Ten15_release_19-08-91:1.16
	ten15_release:1.16;
locks; strict;
comment	@ * @;


1.55
date	96.11.22.11.40.19;	author matthew;	state Exp;
branches
	1.55.1.1
	1.55.2.1
	1.55.3.1
	1.55.4.1;
next	1.54;

1.54
date	96.05.07.10.42.11;	author jont;	state Exp;
branches
	1.54.1.1
	1.54.2.1
	1.54.3.1
	1.54.4.1
	1.54.5.1
	1.54.6.1
	1.54.7.1;
next	1.53;

1.53
date	96.04.15.15.40.10;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	96.03.27.17.04.46;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	96.03.20.12.24.24;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	96.02.23.17.01.53;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	95.12.27.11.34.40;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	95.08.10.18.49.36;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	95.08.01.15.33.49;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	95.08.01.11.38.38;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.03.27.17.00.29;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	95.01.19.12.38.54;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.12.06.17.19.42;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.10.13.11.08.58;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	94.02.28.05.35.40;	author nosa;	state Exp;
branches;
next	1.40;

1.40
date	93.10.28.14.40.21;	author nickh;	state Exp;
branches;
next	1.39;

1.39
date	93.07.08.15.49.43;	author nosa;	state Exp;
branches
	1.39.1.1;
next	1.38;

1.38
date	93.07.05.14.20.30;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	93.05.18.18.48.08;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	93.03.10.15.46.22;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	93.02.03.09.31.24;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	92.11.30.12.53.01;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.10.28.11.46.26;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.10.02.16.21.05;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.09.28.09.01.33;	author richard;	state Exp;
branches;
next	1.30;

1.30
date	92.09.25.11.50.19;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.08.26.11.49.58;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	92.08.18.19.49.52;	author davidt;	state Exp;
branches;
next	1.27;

1.27
date	92.08.12.11.43.59;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	92.08.06.14.13.30;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.08.04.19.11.42;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.06.17.16.10.15;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.06.10.17.47.09;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.06.03.17.38.01;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.02.27.17.38.08;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.01.09.17.36.10;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	91.11.21.19.20.47;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.10.22.15.05.59;	author davidt;	state Exp;
branches;
next	1.17;

1.17
date	91.10.08.18.43.18;	author davidt;	state Exp;
branches;
next	1.16;

1.16
date	91.07.23.11.57.11;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.07.12.18.00.42;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.07.11.09.44.42;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.07.10.12.58.16;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.07.09.17.04.03;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.07.08.17.56.09;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.07.08.15.41.41;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.07.05.15.12.55;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.06.27.12.55.17;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.06.24.11.40.56;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.06.21.10.31.31;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.06.20.18.16.26;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.19.17.51.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.17.14.51.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.16.07.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.10.04.36;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	93.07.08.15.49.43;	author jont;	state Exp;
branches;
next	1.39.1.2;

1.39.1.2
date	93.10.27.16.37.25;	author nickh;	state Exp;
branches;
next	;

1.54.1.1
date	96.09.13.11.17.11;	author hope;	state Exp;
branches;
next	;

1.54.2.1
date	96.10.07.16.06.58;	author hope;	state Exp;
branches;
next	;

1.54.3.1
date	96.10.17.11.25.14;	author hope;	state Exp;
branches;
next	;

1.54.4.1
date	96.11.14.12.50.13;	author hope;	state Exp;
branches
	1.54.4.1.1.1;
next	;

1.54.4.1.1.1
date	96.11.28.15.01.21;	author hope;	state Exp;
branches;
next	;

1.54.5.1
date	96.11.22.18.09.40;	author hope;	state Exp;
branches;
next	;

1.54.6.1
date	96.12.17.17.48.19;	author hope;	state Exp;
branches
	1.54.6.1.1.1;
next	;

1.54.6.1.1.1
date	97.02.24.11.38.13;	author hope;	state Exp;
branches;
next	;

1.54.7.1
date	96.12.18.09.42.20;	author hope;	state Exp;
branches;
next	;

1.55.1.1
date	97.05.12.10.34.49;	author hope;	state Exp;
branches
	1.55.1.1.1.1
	1.55.1.1.2.1
	1.55.1.1.3.1;
next	;

1.55.1.1.1.1
date	97.07.28.18.20.09;	author daveb;	state Exp;
branches
	1.55.1.1.1.1.1.1;
next	;

1.55.1.1.1.1.1.1
date	97.10.07.11.45.18;	author jkbrook;	state Exp;
branches;
next	;

1.55.1.1.2.1
date	97.09.08.17.13.41;	author daveb;	state Exp;
branches;
next	;

1.55.1.1.3.1
date	97.09.09.14.09.23;	author daveb;	state Exp;
branches;
next	;

1.55.2.1
date	97.09.10.19.25.01;	author brucem;	state Exp;
branches;
next	;

1.55.3.1
date	97.09.11.20.55.30;	author daveb;	state Exp;
branches;
next	;

1.55.4.1
date	99.04.01.17.57.12;	author daveb;	state Exp;
branches;
next	;


desc
@Abstract syntax to lambda calculus environment
@


1.55
log
@Tidying
@
text
@(* _environ.sml the functor *)
(*
$Log: _environ.sml,v $
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.53  1996/04/15  15:40:10  jont
 * Improve abs_eval when getting switches
 *
 * Revision 1.52  1996/03/27  17:04:46  matthew
 * Changes for new language\.
 *
 * Revision 1.51  1996/03/20  12:24:24  matthew
 * Changes for value polymorphism
 *
 * Revision 1.50  1996/02/23  17:01:53  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.49  1995/12/27  11:34:40  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.48  1995/08/10  18:49:36  daveb
Added new types for different sizes of ints, words and reals.

Revision 1.47  1995/08/01  15:33:49  jont
Modification to the detection of overloaded valids

Revision 1.46  1995/08/01  11:38:38  matthew
Adding environment simplifier

Revision 1.45  1995/03/27  17:00:29  jont
Remove Builtin_p and modify FindBuiltin

Revision 1.44  1995/01/19  12:38:54  matthew
Tidying up

Revision 1.43  1994/12/06  17:19:42  matthew
Changing uses of cast

Revision 1.42  1994/10/13  11:08:58  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.41  1994/02/28  05:35:40  nosa
Debugger environments for Modules Debugger.

Revision 1.40  1993/10/28  14:40:21  nickh
Merging in code change.

Revision 1.39.1.2  1993/10/27  16:37:25  nickh
Added and used a new function, number_envs, to replace all uses of
Lists.number_with_size, a function which was too inefficient (and ugly).
/

Revision 1.39.1.1  1993/07/08  15:49:43  jont
Fork for bug fixing

Revision 1.39  1993/07/08  15:49:43  nosa
structure Option.

Revision 1.38  1993/07/05  14:20:30  daveb
Removed exception environments and interfaces.

Revision 1.37  1993/05/18  18:48:08  jont
Removed integer parameter

Revision 1.36  1993/03/10  15:46:22  matthew
Signature revisions

Revision 1.35  1993/02/03  09:31:24  matthew
Rationalised functions for converting from structures to interfaces to environments.
Added a cached environment field to interfaces
Moved make_interface_from_str from typechecker/interface

Revision 1.34  1992/11/30  12:53:01  jont
Took out a number of unnecessary map operations

Revision 1.33  1992/10/28  11:46:26  jont
Changed maps to use strict less than functions

Revision 1.32  1992/10/02  16:21:05  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.31  1992/09/28  09:01:33  richard
Added make_str_env.

Revision 1.30  1992/09/25  11:50:19  jont
Removed counter parameter, unused

Revision 1.29  1992/08/26  11:49:58  jont
Removed some redundant structures and sharing

Revision 1.28  1992/08/18  19:49:52  davidt
Added sigid_order and symbol_order functions.

Revision 1.27  1992/08/12  11:43:59  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.26  1992/08/06  14:13:30  jont
Anel's changes to use NewMap instead of Map

Revision 1.26  1992/08/06  14:13:30  jont
Anel's changes to use NewMap instead of Map

Revision 1.25  1992/08/04  19:11:42  jont
Removed various uses of NewMap.to_list in favour of fold and union

Revision 1.24  1992/06/17  16:10:15  jont
Added make_external for benefit of interpreter

Revision 1.23  1992/06/10  17:47:09  jont
Changed to use newmap

Revision 1.22  1992/06/03  17:38:01  jont
Moved assign_fields function from _lambda

Revision 1.21  1992/02/27  17:38:08  jont
Changed to use eqaulity function maps

Revision 1.20  1992/01/09  17:36:10  jont
Changed paramter ordering in environment update to allow use with
Lists.foldl

Revision 1.19  1991/11/21  19:20:47  jont
Added type to overloads in order to keep njml 0.75 happy

Revision 1.18  91/10/22  15:05:59  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.17  91/10/08  18:43:18  davidt
General tidy up, removed local copy of number_from (now in Lists
structure), Made changes due to record selection now requiring
the total size of the record to be present as well as the index.

Revision 1.16  91/07/23  11:57:11  jont
Fixed bug in make_env_from_interface to do with exception numbering

Revision 1.15  91/07/12  18:00:42  jont
Added exception environment to env

Revision 1.14  91/07/11  09:44:42  jont
Added empty_fun_env, add_funid_env, changed Fun_Env to use comp

Revision 1.13  91/07/10  12:58:16  jont
Reorganised

Revision 1.12  91/07/09  17:04:03  jont
Added empty_top_env and lookup_funid

Revision 1.11  91/07/08  17:56:09  jont
Added augment_top_env

Revision 1.10  91/07/08  15:41:41  jont
Added function to find imperative primitives

Revision 1.9  91/07/05  15:12:55  jont
Added overload environment to handle overloaded primitives such as +

Revision 1.8  91/06/27  12:55:17  jont
Removed Findconst as it's not used. Changed Builtin_p so it doesn't
need to catch exceptions

Revision 1.7  91/06/24  11:40:56  jont
Removed match support, as this is internal to _lambda

Revision 1.6  91/06/21  10:31:31  jont
Modified match environment functions for use with fold. Changed
names to be consistent with value environment

Revision 1.5  91/06/20  18:16:26  jont
Implemented match environment update and lookup functions

Revision 1.4  91/06/19  17:51:00  jont
Added match environment type, and changed the types of matchvar
lookup and generate

Revision 1.3  91/06/17  14:51:00  jont
Change add_valid_env and add_strid_env to have type 'a * Env -> Env
to allow use with foldleft or foldright

Revision 1.2  91/06/12  16:07:00  jont
Split off types from rest of environ

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__vector";
require "../utils/crash";
require "../utils/lists";
require "../basics/identprint";
require "../typechecker/datatypes";
require "environ";
require "environtypes";

(**
    The functor for handling the environment produced during the
    translation from abstract syntax to extended
    lambda calculus.  And for defining the datatypes used.
**)

functor Environ (
  structure Crash: CRASH
  structure Lists: LISTS
  structure Datatypes : DATATYPES
  structure IdentPrint : IDENTPRINT
  structure EnvironTypes : ENVIRONTYPES where type LambdaTypes.LVar = int

  sharing EnvironTypes.NewMap = Datatypes.NewMap
  sharing IdentPrint.Ident = EnvironTypes.LambdaTypes.Ident = Datatypes.Ident
  sharing type Datatypes.Type = EnvironTypes.LambdaTypes.Type
) : ENVIRON =
struct
  structure Ident = IdentPrint.Ident
  structure Symbol = Ident.Symbol
  structure EnvironTypes = EnvironTypes
  structure LambdaTypes = EnvironTypes.LambdaTypes
  structure NewMap = EnvironTypes.NewMap
  structure Set = LambdaTypes.Set
  structure Datatypes = Datatypes

  type Structure = Datatypes.Structure

  val cast = MLWorks.Internal.Value.cast

  val empty_env =
    EnvironTypes.ENV(NewMap.empty (Ident.valid_lt,Ident.valid_eq),
		     NewMap.empty (Ident.strid_lt,Ident.strid_eq))
  val empty_fun_env = EnvironTypes.FUN_ENV(NewMap.empty (Ident.funid_lt,Ident.funid_eq))
  val empty_top_env = EnvironTypes.TOP_ENV(empty_env, empty_fun_env)

  val empty_denv =
    EnvironTypes.DENV(NewMap.empty (Ident.valid_lt,Ident.valid_eq),
                      NewMap.empty (Ident.strid_lt,Ident.strid_eq))

  fun add_valid_env(EnvironTypes.ENV(mv, ms), (valid, lvar)) =
    EnvironTypes.ENV(NewMap.define(mv, valid, lvar), ms)
    (* Add one valid -> comp translation to an existing environment *)

  fun add_strid_env(EnvironTypes.ENV(mv, ms), (strid, e_c)) =
    EnvironTypes.ENV(mv, NewMap.define(ms, strid, e_c))
  (* Add one strid -> env, comp translation to an existing environment *)

  fun add_valid_denv(EnvironTypes.DENV(mv, ms), (valid, lvar)) =
    EnvironTypes.DENV(NewMap.define(mv, valid, lvar), ms)
    (* Add one valid -> exp translation to an existing environment *)

  fun add_strid_denv(EnvironTypes.DENV(mv, ms), (strid, se)) =
    EnvironTypes.DENV(mv, NewMap.define(ms, strid, se))
  (* Add one strid -> strexp, comp translation to an existing environment *)

  fun add_list(map, list) =
    Lists.reducel
    (fn (map, (d, r)) => NewMap.define(map, d, r))
    (map, list)

  fun augment_env(EnvironTypes.ENV(mv, ms), EnvironTypes.ENV(nv, ns)) =
    EnvironTypes.ENV
    (NewMap.union(mv, nv),
     NewMap.union(ms, ns))

  fun augment_denv(EnvironTypes.DENV(mv, ms), EnvironTypes.DENV(nv, ns)) =
    EnvironTypes.DENV
    (NewMap.union(mv, nv),
     NewMap.union(ms, ns))

  fun lookup_valid(valid, EnvironTypes.ENV(mv, _)) =
    NewMap.apply'(mv, valid)

  fun lookup_strid(strid, EnvironTypes.ENV(_, ms)) =
    NewMap.apply'(ms, strid)

  fun lookup_valid'(valid, EnvironTypes.DENV(mv, _)) =
    NewMap.apply'(mv, valid)

  fun lookup_strid'(strid, EnvironTypes.DENV(_, ms)) =
    NewMap.apply'(ms, strid)

  fun FindBuiltin(Ident.LONGVALID(Ident.NOPATH, valid),
		   env as EnvironTypes.ENV(mv, _)) =
    (case NewMap.tryApply'(mv, valid) of
       SOME(EnvironTypes.PRIM prim) => SOME prim
     | _ => NONE)
    | FindBuiltin _ = NONE

  local
    val overloads = ref(NewMap.empty' Ident.valid_lt:
			(Ident.ValId, LambdaTypes.Primitive)NewMap.map)
  in
    fun define_overloaded_ops ops =
      overloads :=
      let
	val env = !overloads
      in
	Lists.reducel
	(fn (map, (s, p)) => NewMap.define(map, Ident.VAR(Symbol.find_symbol s), p))
	(env, ops)
      end

    fun overloaded_op(arg as Ident.VAR _) =
      (case NewMap.tryApply'(!overloads, arg) of
	 x as SOME _ => x
       | _ => NONE)
      | overloaded_op _ = 
	Crash.impossible "Environ.is_overloaded_op"
  end

  fun add_funid_env(EnvironTypes.FUN_ENV m, (funid, c_i_e)) =
    EnvironTypes.FUN_ENV(NewMap.define(m, funid, c_i_e))
  (* Add one funid -> env, comp translation to an existing environment *)
  fun augment_top_env(EnvironTypes.TOP_ENV(e1, EnvironTypes.FUN_ENV fun_e1),
    EnvironTypes.TOP_ENV(e2, EnvironTypes.FUN_ENV fun_e2)) =
    EnvironTypes.TOP_ENV(augment_env(e1, e2),
      EnvironTypes.FUN_ENV(NewMap.union(fun_e1, fun_e2)))

  fun lookup_funid(funid, EnvironTypes.FUN_ENV fun_env) =
    NewMap.apply'(fun_env, funid)

  fun number_envs (vl,sl,fl) =
    let
      val length_v = Lists.length vl
      val length_s = Lists.length sl
      val total_length = length_v + length_s + (Lists.length fl)
      fun number n = EnvironTypes.FIELD {index=n, size=total_length}
      val (new_vl,_) = Lists.number_from_by_one (vl, 0, number)
      val (new_sl,_) = Lists.number_from_by_one (sl, length_v, number)
      val (new_fl,_) = Lists.number_from_by_one (fl, length_v+length_s, number)
    in
      (new_vl,new_sl,new_fl)
    end

  fun make_str_env (Datatypes.COPYSTR (_, str),generate_moduler) = make_str_env (str,generate_moduler)
  |   make_str_env (Datatypes.STR (_, ref (SOME env), _),generate_moduler) =
      cast env: EnvironTypes.Env
  |   make_str_env
	(Datatypes.STR
	   (_,
	    env_ref as ref NONE,
	    Datatypes.ENV
	      (Datatypes.SE strenv, Datatypes.TE tyenv, Datatypes.VE (_, valenv))),generate_moduler) =
    let
      val valenv =
        if generate_moduler then
          let
            val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,NONE)
          in
            NewMap.fold (fn (map,Ident.TYCON(sym),_)=>NewMap.define(map,Ident.TYCON'(sym),dummy_scheme))
            (valenv,tyenv)
          end
        else valenv
      val (ve,se,_) = number_envs(NewMap.domain_ordered valenv,
				  NewMap.to_list_ordered strenv, [])
      
      val result =
	Lists.reducel
	  add_valid_env
	  (Lists.reducel
	     (fn (env, ((ident, str), field)) =>
	 	add_strid_env(env, (ident, (make_str_env (str,generate_moduler), field, generate_moduler))))
             (empty_env, se),
           ve)
    in
      env_ref := SOME (cast result);
      result
    end

  fun sort_fn f =
    fn ((x, _), (x', _)) => f (x, x')

  fun assign_fields(EnvironTypes.TOP_ENV(
    EnvironTypes.ENV(mv, ms), EnvironTypes.FUN_ENV m)) =
  let
    val (ve,se,fe) = number_envs (NewMap.to_list_ordered mv,
				  NewMap.to_list_ordered ms,
				  NewMap.to_list_ordered m)

    fun passing_on_prim (b as EnvironTypes.PRIM _) _ = b
      | passing_on_prim _ x = x
  in
    EnvironTypes.TOP_ENV
    (Lists.reducel
     (fn (env, ((sid, (e, var, generate_moduler)), f)) =>
      add_strid_env(env, (sid,(e, passing_on_prim var f, generate_moduler))))
     (Lists.reducel
      (fn (env, ((vid, var as EnvironTypes.LAMB lv), f as EnvironTypes.FIELD {index, ...})) =>
       (add_valid_env(env, (vid, passing_on_prim var f)))
        | (env, ((vid, var), f)) =>add_valid_env(env, (vid, passing_on_prim var f)))
      (empty_env, ve), se),
     Lists.reducel
     (fn (fun_env, ((fid, (_, e, generate_moduler)), f)) =>
      add_funid_env(fun_env, (fid,(f, e, generate_moduler))))
     (empty_fun_env, fe))
  end

  fun make_external(EnvironTypes.TOP_ENV
		    (EnvironTypes.ENV(mv, ms), EnvironTypes.FUN_ENV m)) =
    let
      fun do_valid(tree, v, comp as EnvironTypes.PRIM _) =
	NewMap.define(tree, v, comp)
	| do_valid(tree, v, _) =
	  NewMap.define(tree, v, EnvironTypes.EXTERNAL)
      fun do_strid(tree, v, comp as (_, EnvironTypes.PRIM _, _)) =
	NewMap.define(tree, v, comp)
	| do_strid(tree, v, (e, _, generate_moduler)) =
	  NewMap.define(tree, v, (e, EnvironTypes.EXTERNAL, generate_moduler))
      fun do_funid(tree, v, comp as (EnvironTypes.PRIM _, _, _)) =
	NewMap.define(tree, v, comp)
	| do_funid(tree, v, comp as (_, e, generate_moduler)) =
	  NewMap.define(tree, v, (EnvironTypes.EXTERNAL, e, generate_moduler))

      val valids =
	NewMap.fold
	do_valid
	(NewMap.empty (Ident.valid_lt,Ident.valid_eq), mv)
      val strids =
	NewMap.fold
	do_strid
	(NewMap.empty (Ident.strid_lt,Ident.strid_eq), ms)
      val funids =
	NewMap.fold
	do_funid
	(NewMap.empty (Ident.funid_lt,Ident.funid_eq), m)
    in
      EnvironTypes.TOP_ENV
      (EnvironTypes.ENV(valids, strids),
       EnvironTypes.FUN_ENV funids)
    end

  fun make_str_dexp(Datatypes.COPYSTR (_, str)) = make_str_dexp str
    | make_str_dexp(Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(strmap),Datatypes.TE(tyconmap),
                                                    Datatypes.VE(_,valmap)))) =
      EnvironTypes.DENVEXP (EnvironTypes.DENV(NewMap.fold (fn (map,Ident.TYCON(tc),_) => 
                                                           NewMap.define (map,Ident.CON(tc),
                                                                          EnvironTypes.NULLEXP))
                                              (NewMap.map (fn _ => EnvironTypes.NULLEXP) valmap,tyconmap),
                                              NewMap.map (fn (_,str) => make_str_dexp str) strmap))
            

   (* Environment simplification function *)
      local
        open LambdaTypes
      in

        datatype result = 
          INTVAL of int |
          SCONVAL of Ident.SCon * int option |
          BUILTINVAL of LambdaTypes.Primitive |
          TUPLEVAL of result Vector.vector |
          DYNAMIC

        fun abs_eval (env,exp) =
          let
            fun lookup (x,[]) = DYNAMIC
              | lookup (x,(x',a)::rest) =
                if x = x' then a else lookup (x,rest)
          in
            case exp of
              VAR var => lookup (var,env)
            | FN _ => DYNAMIC
            | LET ((var,_, exp1),exp2) =>
                (case abs_eval (env,exp1) of
                   DYNAMIC => abs_eval (env,exp2)
                 | a => abs_eval ((var,a) :: env,exp2))
            | LETREC (_,_,e) => abs_eval (env,e)
            | APP _ => DYNAMIC
            | SCON scon => SCONVAL scon
            | INT i => INTVAL i
            | SWITCH(le, nums_opt, tag_le_list, le_op) =>
		let
		  fun filter_raises(acc, []) = acc
		    | filter_raises(acc, (tag, RAISE _) :: rest) =
		      filter_raises(acc, rest)
		    | filter_raises(acc, tag_le :: rest) =
		      filter_raises(tag_le :: acc, rest)
		  val tag_le_list = filter_raises([], tag_le_list)
		in
		  case tag_le_list of
		    [] =>
		      (case le_op of
			 SOME le => abs_eval(env, le)
		       | _ => Crash.impossible"abs_eval: empty switch")
		  | [(_, le)] =>
		      (case le_op of
			 NONE => abs_eval(env, le)
		       | _ => DYNAMIC)
		  | _ =>
		      DYNAMIC
		end
            | STRUCT (el,_) => 
                let
                  val values = map (fn e => abs_eval (env,e)) el
                in
                  if Lists.forall (fn DYNAMIC => true | _ => false) values
                    then DYNAMIC
                  else TUPLEVAL (Vector.fromList values)
                end
            | SELECT _ => DYNAMIC
            | RAISE _ => DYNAMIC
            | HANDLE _ => DYNAMIC
            | BUILTIN prim => BUILTINVAL prim
            | MLVALUE _ => DYNAMIC
          end

	exception BadList

        fun convert_list (INTVAL 1,acc) = TUPLEVAL (Vector.fromList (rev acc))
          | convert_list (TUPLEVAL elements,acc) =
            if Vector.length elements = 2
              then convert_list (Vector.sub (elements,1),Vector.sub (elements,0) :: acc)
            else
	      raise BadList
          | convert_list(DYNAMIC, _) = raise BadList
          | convert_list(SCONVAL _, _) = raise BadList
          | convert_list(BUILTINVAL _, _) = raise BadList
          | convert_list(INTVAL _, _) = raise BadList

        fun lookup (i,TUPLEVAL values) =
          if i >= Vector.length values
            then Crash.impossible "bad index for lookup"
          else Vector.sub (values,i)
          | lookup (i,_) = Crash.impossible "simplify_topenv:lookup"

        fun simplify_env (DYNAMIC,env) = env
          | simplify_env (values,EnvironTypes.ENV (valid_map,strid_map)) =
          let
            fun do_valid (valid,comp) =
              case comp of 
                EnvironTypes.FIELD {index,...} =>
                  (case lookup (index,values) of
                     BUILTINVAL b => EnvironTypes.PRIM b
                   | _ => comp)
              | _ => comp
            fun do_strid (strid,entry as (env,comp,b)) =
              case comp of
                EnvironTypes.FIELD {index,...} =>
                  (simplify_env (lookup (index,values), env),
                   comp,
                   b)
              | _ => entry
          in
            EnvironTypes.ENV (NewMap.map do_valid valid_map,NewMap.map do_strid strid_map)
          end
                      
        fun simplify_topenv(t_env as EnvironTypes.TOP_ENV (env,fun_env),exp) =
          let
            val values = convert_list (abs_eval ([],exp),[])
          in
            EnvironTypes.TOP_ENV (simplify_env (values,env),fun_env)
          end
	handle BadList => t_env
      end
end
@


1.55.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 3
 * Revision 1.55  1996/11/22  11:40:19  matthew
 * Tidying
 *
@


1.55.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.55  1996/11/22  11:40:19  matthew
 * Tidying
 *
@


1.55.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.55  1996/11/22  11:40:19  matthew
 * Tidying
 *
@


1.55.1.1
log
@branched from 1.55
@
text
@a3 3
 * Revision 1.55  1996/11/22  11:40:19  matthew
 * Tidying
 *
@


1.55.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:34:49  hope
 * branched from 1.55
 *
@


1.55.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:34:49  hope
 * branched from 1.55
 *
@


1.55.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.55.1.1  1997/05/12  10:34:49  hope
 * branched from 1.55
 *
@


1.55.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.55.1.1.1.1  1997/07/28  18:20:09  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.54
log
@Array moving to MLWorks.Array
@
text
@d4 3
d187 1
d281 3
a283 3
       MLWorks.Option.SOME(EnvironTypes.PRIM prim) => MLWorks.Option.SOME prim
     | _ => MLWorks.Option.NONE)
    | FindBuiltin _ = MLWorks.Option.NONE
d301 2
a302 2
	 x as MLWorks.Option.SOME _ => x
       | _ => MLWorks.Option.NONE)
d332 1
a332 1
  |   make_str_env (Datatypes.STR (_, ref (MLWorks.Option.SOME env), _),generate_moduler) =
d337 1
a337 1
	    env_ref as ref MLWorks.Option.NONE,
d344 1
a344 1
            val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,MLWorks.Option.NONE)
d362 1
a362 1
      env_ref := MLWorks.Option.SOME (cast result);
d445 1
a445 1
          SCONVAL of Ident.SCon * int MLWorks.Option.option |
d447 1
a447 1
          TUPLEVAL of result MLWorks.Internal.Vector.vector |
d479 1
a479 1
			 MLWorks.Option.SOME le => abs_eval(env, le)
d483 1
a483 1
			 MLWorks.Option.NONE => abs_eval(env, le)
d494 1
a494 1
                  else TUPLEVAL (MLWorks.Internal.Vector.vector values)
d505 1
a505 1
        fun convert_list (INTVAL 1,acc) = TUPLEVAL (MLWorks.Internal.Vector.vector (rev acc))
d507 2
a508 2
            if MLWorks.Internal.Vector.length elements = 2
              then convert_list (MLWorks.Internal.Vector.sub (elements,1),MLWorks.Internal.Vector.sub (elements,0) :: acc)
d517 1
a517 1
          if i >= MLWorks.Internal.Vector.length values
d519 1
a519 1
          else MLWorks.Internal.Vector.sub (values,i)
@


1.54.7.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.6.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.6.1.1.1
log
@branched from 1.54.6.1
@
text
@a3 3
 * Revision 1.54.6.1  1996/12/17  17:48:19  hope
 * branched from 1.54
 *
@


1.54.5.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.4.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.4.1.1.1
log
@branched from 1.54.4.1
@
text
@a3 3
 * Revision 1.54.4.1  1996/11/14  12:50:13  hope
 * branched from 1.54
 *
@


1.54.3.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.2.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.54.1.1
log
@branched from 1.54
@
text
@a3 3
 * Revision 1.54  1996/05/07  10:42:11  jont
 * Array moving to MLWorks.Array
 *
@


1.53
log
@Improve abs_eval when getting switches
@
text
@d4 3
d443 1
a443 1
          TUPLEVAL of result Vector.vector |
d490 1
a490 1
                  else TUPLEVAL (Vector.vector values)
d501 1
a501 1
        fun convert_list (INTVAL 1,acc) = TUPLEVAL (Vector.vector (rev acc))
d503 2
a504 2
            if Vector.length elements = 2
              then convert_list (Vector.sub (elements,1),Vector.sub (elements,0) :: acc)
d513 1
a513 1
          if i >= Vector.length values
d515 1
a515 1
          else Vector.sub (values,i)
@


1.52
log
@Changes for new language\.
@
text
@d4 3
d460 21
a480 1
            | SWITCH _ => DYNAMIC
d496 2
d502 6
a507 2
            else Crash.impossible "Invalid list in convert_list"
          | convert_list _ =  Crash.impossible "Invalid list in convert_list"
d536 1
a536 1
        fun simplify_topenv (EnvironTypes.TOP_ENV (env,fun_env),exp) =
d542 1
@


1.51
log
@Changes for value polymorphism
@
text
@d4 3
d196 1
a196 1
  structure EnvironTypes : ENVIRONTYPES
a200 2
  sharing type EnvironTypes.LambdaTypes.LVar = int

@


1.50
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d4 3
d212 1
a212 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d322 1
a322 1
      castit env: EnvironTypes.Env
d351 1
a351 1
      env_ref := MLWorks.Option.SOME (castit result);
@


1.49
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d273 1
a273 1
			(Ident.ValId, LambdaTypes.Primitive)NewMap.T)
@


1.48
log
@Added new types for different sizes of ints, words and reals.
@
text
@d4 3
d315 1
a315 1
  |   make_str_env (Datatypes.STR (_, ref (Datatypes.Option.PRESENT env), _),generate_moduler) =
d320 1
a320 1
	    env_ref as ref Datatypes.Option.ABSENT,
d327 1
a327 1
            val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,Datatypes.Option.ABSENT)
d345 1
a345 1
      env_ref := Datatypes.Option.PRESENT (castit result);
@


1.47
log
@Modification to the detection of overloaded valids
@
text
@d4 3
d425 1
a425 1
          SCONVAL of Ident.SCon |
@


1.46
log
@Adding environment simplifier
@
text
@d4 3
d263 2
a264 1
    val overloads = ref (Set.empty_set : string Set.Set)
d266 16
a281 7
    fun define_overloaded_ops (ops: string list) =
      overloads := Set.list_to_set ops

    fun is_overloaded_op (Ident.VAR v) =
      Set.is_member(Symbol.symbol_name v, !overloads)
    |   is_overloaded_op _ = 
      Crash.impossible "Environ.is_overloaded_op"
@


1.45
log
@Remove Builtin_p and modify FindBuiltin
@
text
@d4 3
d402 86
@


1.44
log
@Tidying up
@
text
@d4 3
d249 2
a250 2
  fun Builtin_p(Ident.LONGVALID(Ident.NOPATH, valid),
    env as EnvironTypes.ENV(mv, _)) =
d252 3
a254 9
       MLWorks.Option.SOME(EnvironTypes.PRIM _) => true
     | _ => false)
  | Builtin_p _ = false

  fun FindBuiltin (Ident.LONGVALID(Ident.NOPATH, valid), env) =
    (case lookup_valid(valid, env) of
       EnvironTypes.PRIM prim => prim
     | _ => Crash.impossible "FindBuiltin fails to find prim")
    | FindBuiltin _ = Crash.impossible "FindBuiltin gets non-empty path"
@


1.43
log
@Changing uses of cast
@
text
@d4 3
d395 5
a399 5
      EnvironTypes.DENV'(EnvironTypes.DENV(NewMap.fold (fn (map,Ident.TYCON(tc),_) => 
                                                        NewMap.define (map,Ident.CON(tc),
                                                                       EnvironTypes.NULLEXP))
                                           (NewMap.map (fn _ => EnvironTypes.NULLEXP) valmap,tyconmap),
                                           NewMap.map (fn (_,str) => make_str_dexp str) strmap))
@


1.42
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d188 2
d294 1
a294 1
    MLWorks.Internal.Value.cast env: EnvironTypes.Env
d323 1
a323 1
      env_ref := Datatypes.Option.PRESENT (MLWorks.Internal.Value.cast result);
@


1.41
log
@Debugger environments for Modules Debugger.
@
text
@d4 3
d241 1
a241 1
       NewMap.YES(EnvironTypes.PRIM _) => true
@


1.40
log
@Merging in code change.
@
text
@d4 3
d168 1
d188 4
d200 8
d218 5
d229 6
d284 2
a285 2
  fun make_str_env (Datatypes.COPYSTR (_, str)) = make_str_env str
  |   make_str_env (Datatypes.STR (_, ref (Datatypes.Option.PRESENT env), _)) =
d292 1
a292 1
	      (Datatypes.SE strenv, _, Datatypes.VE (_, valenv)))) =
d294 9
d311 1
a311 1
	 	add_strid_env(env, (ident, (make_str_env str, field))))
d334 2
a335 2
     (fn (env, ((sid, (e, var)), f)) =>
      add_strid_env(env, (sid,(e, passing_on_prim var f))))
d337 3
a339 2
      (fn (env, ((vid, var), f)) =>
       add_valid_env(env, (vid, passing_on_prim var f)))
d342 2
a343 2
     (fn (fun_env, ((fid, (_, e)), f)) =>
      add_funid_env(fun_env, (fid,(f, e))))
d354 1
a354 1
      fun do_strid(tree, v, comp as (_, EnvironTypes.PRIM _)) =
d356 3
a358 3
	| do_strid(tree, v, (e, _)) =
	  NewMap.define(tree, v, (e, EnvironTypes.EXTERNAL))
      fun do_funid(tree, v, comp as (EnvironTypes.PRIM _, _)) =
d360 2
a361 2
	| do_funid(tree, v, comp as (_, e)) =
	  NewMap.define(tree, v, (EnvironTypes.EXTERNAL, e))
d380 10
@


1.39
log
@structure Option.
@
text
@d4 11
d244 13
d267 2
a268 9
      val (val_field_fn, size) =
        Lists.number_with_size
	  (NewMap.domain_ordered valenv,
	   0,
	   EnvironTypes.FIELD)

      val (str_field_fn, size) =
        Lists.number_with_size
	  (NewMap.to_list_ordered strenv, size, EnvironTypes.FIELD)
d276 2
a277 2
             (empty_env, str_field_fn size),
           val_field_fn size)
d289 4
a292 9
    val valids = NewMap.to_list_ordered mv
    val strids = NewMap.to_list_ordered ms
    val funids = NewMap.to_list_ordered m
    val (v_field_fn, next1) =
      Lists.number_with_size(valids, 0, EnvironTypes.FIELD)
    val (s_field_fn, next2) =
      Lists.number_with_size(strids, next1, EnvironTypes.FIELD)
    val (f_field_fn, size) =
      Lists.number_with_size(funids, next2, EnvironTypes.FIELD)
a294 23
(*
    val v_field =
      map (fn ((vid, var), f) => (vid, passing_on_prim var f)) (v_field_fn size)
    val s_field =
      map (fn ((sid, (e, var)), f) => (sid,(e, passing_on_prim var f))) (s_field_fn size)
    val f_field =
      map (fn ((fid, (_, i, e)), f) => (fid,(f, i, e)))
      (f_field_fn size)
*)

      val result =
        EnvironTypes.TOP_ENV
        (Lists.reducel
         (fn (env, ((sid, (e, var)), f)) =>
	  add_strid_env(env, (sid,(e, passing_on_prim var f))))
         (Lists.reducel
           (fn (env, ((vid, var), f)) =>
	    add_valid_env(env, (vid, passing_on_prim var f)))
           (empty_env, v_field_fn size), s_field_fn size),
         Lists.reducel
         (fn (fun_env, ((fid, (_, e)), f)) =>
	  add_funid_env(fun_env, (fid,(f, e))))
         (empty_fun_env, f_field_fn size))
d296 12
a307 1
    result
@


1.39.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.39  1993/07/08  15:49:43  nosa
structure Option.

@


1.39.1.2
log
@Added and used a new function, number_envs, to replace all uses of
Lists.number_with_size, a function which was too inefficient (and ugly).
/
@
text
@a3 3
Revision 1.39.1.1  1993/07/08  15:49:43  jont
Fork for bug fixing

a235 13
  fun number_envs (vl,sl,fl) =
    let
      val length_v = Lists.length vl
      val length_s = Lists.length sl
      val total_length = length_v + length_s + (Lists.length fl)
      fun number n = EnvironTypes.FIELD {index=n, size=total_length}
      val (new_vl,_) = Lists.number_from_by_one (vl, 0, number)
      val (new_sl,_) = Lists.number_from_by_one (sl, length_v, number)
      val (new_fl,_) = Lists.number_from_by_one (fl, length_v+length_s, number)
    in
      (new_vl,new_sl,new_fl)
    end

d246 9
a254 2
      val (ve,se,_) = number_envs(NewMap.domain_ordered valenv,
				  NewMap.to_list_ordered strenv, [])
d262 2
a263 2
             (empty_env, se),
           ve)
d275 9
a283 4
    val (ve,se,fe) = number_envs (NewMap.to_list_ordered mv,
				  NewMap.to_list_ordered ms,
				  NewMap.to_list_ordered m)

d286 23
d310 1
a310 12
    EnvironTypes.TOP_ENV
    (Lists.reducel
     (fn (env, ((sid, (e, var)), f)) =>
      add_strid_env(env, (sid,(e, passing_on_prim var f))))
     (Lists.reducel
      (fn (env, ((vid, var), f)) =>
       add_valid_env(env, (vid, passing_on_prim var f)))
      (empty_env, ve), se),
     Lists.reducel
     (fn (fun_env, ((fid, (_, e)), f)) =>
      add_funid_env(fun_env, (fid,(f, e))))
     (empty_fun_env, fe))
@


1.38
log
@Removed exception environments and interfaces.
@
text
@d4 3
d234 1
a234 1
  |   make_str_env (Datatypes.STR (_, ref (Datatypes.PRESENT env), _)) =
d239 1
a239 1
	    env_ref as ref Datatypes.ABSENT,
d262 1
a262 1
      env_ref := Datatypes.PRESENT (MLWorks.Internal.Value.cast result);
@


1.37
log
@Removed integer parameter
@
text
@d4 3
a151 1
  sharing type Datatypes.Interface.Int = EnvironTypes.Interface
a160 1
  structure Interface = Datatypes.Interface
a165 1
		     NewMap.empty (Ident.valid_lt,Ident.valid_eq),
d170 2
a171 2
  fun add_valid_env(EnvironTypes.ENV(mv, me, ms), (valid, lvar)) =
    EnvironTypes.ENV(NewMap.define(mv, valid, lvar), me, ms)
d173 3
a175 5
  fun add_exn_env(EnvironTypes.ENV(mv, me, ms), (valid, lvar)) =
    EnvironTypes.ENV(mv, NewMap.define(me, valid, lvar), ms)
    (* Add one exn -> comp translation to an existing environment *)
  fun add_strid_env(EnvironTypes.ENV(mv, me, ms), (strid, e_c)) =
    EnvironTypes.ENV(mv, me, NewMap.define(ms, strid, e_c))
d183 1
a183 1
  fun augment_env(EnvironTypes.ENV(mv, me, ms), EnvironTypes.ENV(nv, ne, ns)) =
a185 1
     NewMap.union(me, ne),
d188 1
a188 1
  fun lookup_valid(valid, EnvironTypes.ENV(mv, _, _)) =
d190 2
a191 3
  fun lookup_exn(valid, EnvironTypes.ENV(_, me, _)) =
    NewMap.apply'(me, valid)
  fun lookup_strid(strid, EnvironTypes.ENV(_, _, ms)) =
d193 1
d195 1
a195 1
    env as EnvironTypes.ENV(mv, _, _)) =
d215 2
a216 2
      | is_overloaded_op _ =
	Crash.impossible "Environ.is_overloaded_op"
d230 9
a238 13
  (* converts from a static environment to an interface. Note we ignore TE 
   because type constructors are not visible in the dynamic semantics *)

  fun make_interface_from_str (Datatypes.COPYSTR (_,str)) = make_interface_from_str str
    | make_interface_from_str (Datatypes.STR (_,ref (Datatypes.PRESENT interface),_)) = interface
    | make_interface_from_str (Datatypes.STR (_,refint,env)) =
      let val interface = inter_env env
      in
        refint := Datatypes.PRESENT interface;
        interface
      end

  and inter_env (Datatypes.ENV (Datatypes.SE se_map, _,Datatypes.VE (_,ve_map),Datatypes.VE (_,ee_map))) =
d240 5
a244 21
      fun make_intenv (intenv, strid, _) =
        let
          val str = NewMap.apply'(se_map, strid)
          val interface = make_interface_from_str str
        in
          NewMap.define(intenv,strid,interface)
        end

      val vars = 
        (* we change cons to valids as this is how they're put in the *)
        (* code generator's variable environment *)
        map (fn Ident.CON sym => Ident.VAR sym
      | Ident.EXCON sym => Ident.VAR sym
      | var as (Ident.VAR sym) => var) (NewMap.domain_ordered ve_map)
        
      val excons = NewMap.domain_ordered ee_map
    in
      Interface.INT (Interface.INTENV (NewMap.fold make_intenv
                                       (NewMap.empty (Ident.strid_lt,Ident.strid_eq), se_map)),
                     vars,excons,ref Interface.ABSENT)
    end
a245 45
  fun make_env_from_interface
    (interface as Interface.INT
     (intenv as Interface.INTENV strid_map, valid_list, exid_list, envref)) =
    case envref of
      ref (Interface.PRESENT x) => (MLWorks.Internal.Value.cast x)
    | ref Interface.ABSENT =>
        let
          val (v_f_list_fn, next1) =
            Lists.number_with_size(valid_list, 0, EnvironTypes.FIELD)
          val (e_f_list_fn, next2) =
            Lists.number_with_size(exid_list, next1, EnvironTypes.FIELD)
          val (s_f_list_fn, size) =
            Lists.number_with_size(NewMap.to_list_ordered strid_map, next2,
                                   EnvironTypes.FIELD)
        (*
          val s_f_e_list =
          map (fn ((s, i), f) => (s, (make_env_from_interface i, f)))
          (s_f_list_fn size)
          *)
          val result =
            Lists.reducel
            (fn (env, ((s, i), f)) =>
             add_strid_env(env, (s, (make_env_from_interface i, f))))
            (Lists.reducel
             add_exn_env
             (Lists.reducel add_valid_env
              (empty_env, v_f_list_fn size), e_f_list_fn size), s_f_list_fn size)
        in
          envref := Interface.PRESENT ((MLWorks.Internal.Value.cast result): MLWorks.Internal.Value.ml_value);
          result
        end

  fun make_str_env str =
    make_env_from_interface (make_interface_from_str str)

(*
  fun make_str_env (Datatypes.STR (_,_,Datatypes.ENV (Datatypes.SE strenv,
                                                      _, (* types are irrelevant here *)
                                                      Datatypes.VE (_, valenv),
                                                      Datatypes.VE (_, exconenv)))) =
    let
      val (val_field_fn, size) =
        Lists.number_with_size (NewMap.domain_ordered valenv, 0, EnvironTypes.FIELD)
      val (excon_field_fn, size) =
        Lists.number_with_size (NewMap.domain_ordered exconenv, size, EnvironTypes.FIELD)
d247 11
a257 1
        Lists.number_with_size (NewMap.to_list_ordered strenv, size, EnvironTypes.FIELD)
d259 2
a260 9
      Lists.reducel add_valid_env
      (Lists.reducel add_exn_env
       (Lists.reducel
	(fn (env, ((ident, str), field)) =>
	 add_strid_env(env, (ident, (make_str_env str, field))))
        (empty_env,
	 (str_field_fn size)),
        excon_field_fn size),
       val_field_fn size)
a261 2
    | make_str_env (Datatypes.COPYSTR (_,str)) = make_str_env str
*)
d267 1
a267 1
    EnvironTypes.ENV(mv, me, ms), EnvironTypes.FUN_ENV m)) =
a269 1
    val exns = NewMap.to_list_ordered me
d274 2
a275 4
    val (e_field_fn, next2) =
      Lists.number_with_size(exns, next1, EnvironTypes.FIELD)
    val (s_field_fn, next3) =
      Lists.number_with_size(strids, next2, EnvironTypes.FIELD)
d277 1
a277 1
      Lists.number_with_size(funids, next3, EnvironTypes.FIELD)
a282 2
    val e_field =
      map (fn ((eid, var), f) => (eid, passing_on_prim var f)) (e_field_fn size)
a295 3
          (fn (env, ((eid, var), f)) =>
	   add_exn_env(env, (eid, passing_on_prim var f)))
          (Lists.reducel
d298 1
a298 2
           (empty_env, v_field_fn size),
           e_field_fn size), s_field_fn size),
d300 2
a301 2
         (fn (fun_env, ((fid, (_, i, e)), f)) =>
	  add_funid_env(fun_env, (fid,(f, i, e))))
d308 1
a308 1
		    (EnvironTypes.ENV(mv, me, ms), EnvironTypes.FUN_ENV m)) =
d318 1
a318 1
      fun do_funid(tree, v, comp as (EnvironTypes.PRIM _, _, _)) =
d320 2
a321 2
	| do_funid(tree, v, comp as (_, i, e)) =
	  NewMap.define(tree, v, (EnvironTypes.EXTERNAL, i, e))
a326 4
      val exns =
	NewMap.fold
	do_valid
	(NewMap.empty (Ident.valid_lt,Ident.valid_eq), me)
d337 1
a337 1
      (EnvironTypes.ENV(valids, exns, strids),
@


1.36
log
@Signature revisions
@
text
@d4 3
a125 1
require "../utils/integer";
a140 1
  structure Integer : INTEGER
@


1.35
log
@Rationalised functions for converting from structures to interfaces to environments.
Added a cached environment field to interfaces
Moved make_interface_from_str from typechecker/interface
@
text
@d4 5
d140 1
d143 6
a148 1
  sharing IdentPrint.Ident = EnvironTypes.LambdaTypes.Datatypes.Ident
d155 1
a155 1
  structure NewMap = LambdaTypes.Datatypes.NewMap
d157 1
a157 1
  structure Datatypes = LambdaTypes.Datatypes
d159 2
@


1.34
log
@Took out a number of unnecessary map operations
@
text
@d4 3
d121 1
a121 1
require "../typechecker/interface";
d137 1
a137 4
  structure Interface : INTERFACE
  sharing EnvironTypes.LambdaTypes.Datatypes = Interface.Datatypes
  sharing EnvironTypes.Interface = Interface
  sharing IdentPrint.Ident = Interface.Datatypes.Ident
a139 1
  structure Interface = Interface
d147 1
d219 36
d257 33
a289 9
     (intenv as Interface.INTENV strid_map, valid_list, exid_list)) =
  let
    val (v_f_list_fn, next1) =
      Lists.number_with_size(valid_list, 0, EnvironTypes.FIELD)
    val (e_f_list_fn, next2) =
      Lists.number_with_size(exid_list, next1, EnvironTypes.FIELD)
    val (s_f_list_fn, size) =
      Lists.number_with_size(NewMap.to_list_ordered strid_map, next2,
			     EnvironTypes.FIELD)
d291 23
a313 3
    val s_f_e_list =
      map (fn ((s, i), f) => (s, (make_env_from_interface i, f)))
      (s_f_list_fn size)
a314 9
  in
    Lists.reducel
    (fn (env, ((s, i), f)) =>
     add_strid_env(env, (s, (make_env_from_interface i, f))))
    (Lists.reducel
     add_exn_env
     (Lists.reducel add_valid_env
      (empty_env, v_f_list_fn size), e_f_list_fn size), s_f_list_fn size)
  end
a404 23
    end

  fun make_str_env (Datatypes.STR (_, Datatypes.ENV (Datatypes.SE strenv,
                                                     _, (* types are irrelevant here *)
                                                     Datatypes.VE (_, valenv),
                                                     Datatypes.VE (_, exconenv)))) =
    let
      val (val_field_fn, size) =
        Lists.number_with_size (NewMap.domain_ordered valenv, 0, EnvironTypes.FIELD)
      val (excon_field_fn, size) =
        Lists.number_with_size (NewMap.domain_ordered exconenv, size, EnvironTypes.FIELD)
      val (str_field_fn, size) =
        Lists.number_with_size (NewMap.to_list_ordered strenv, size, EnvironTypes.FIELD)
    in
      Lists.reducel add_valid_env
      (Lists.reducel add_exn_env
       (Lists.reducel
	(fn (env, ((ident, str), field)) =>
	 add_strid_env(env, (ident, (make_str_env str, field))))
        (empty_env,
	 (str_field_fn size)),
        excon_field_fn size),
       val_field_fn size)
@


1.33
log
@Changed maps to use strict less than functions
@
text
@d4 3
d185 3
a187 3
    ((case NewMap.apply mv valid of
	EnvironTypes.PRIM _ => true
      | _ => false) handle NewMap.Undefined => false)
d230 1
d234 1
d237 2
a238 1
    add_strid_env
d242 1
a242 1
      (empty_env, v_f_list_fn size), e_f_list_fn size), s_f_e_list)
d265 1
d275 1
d280 2
a281 1
         add_strid_env
d283 2
a284 1
          add_exn_env
d286 4
a289 3
           add_valid_env
           (empty_env, v_field),
           e_field), s_field),
d291 3
a293 2
         add_funid_env
         (empty_fun_env, f_field))
d350 3
a352 1
       (Lists.reducel add_strid_env
d354 1
a354 1
         map (fn ((ident, str), field) => (ident, (make_str_env str, field))) (str_field_fn size)),
@


1.32
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
a145 12
  val valid_order = Ident.valid_order
  val strid_order = Ident.strid_order
  val funid_order = Ident.funid_order
  val sigid_order = Ident.sigid_order
  val valid_equal = Ident.valid_eq
  val strid_equal = Ident.strid_eq
  val funid_equal = Ident.funid_eq
  val sigid_equal = Ident.sigid_eq

  val symbol_order = Ident.Symbol.symbol_order
  val symbol_equal = Ident.Symbol.eq_symbol

d147 4
a150 4
    EnvironTypes.ENV(NewMap.empty (valid_order,valid_equal),
		     NewMap.empty (valid_order,valid_equal),
		     NewMap.empty (strid_order,strid_equal))
  val empty_fun_env = EnvironTypes.FUN_ENV(NewMap.empty (funid_order,funid_equal))
d305 1
a305 1
	(NewMap.empty (valid_order,valid_equal), mv)
d309 1
a309 1
	(NewMap.empty (valid_order,valid_equal), me)
d313 1
a313 1
	(NewMap.empty (strid_order,strid_equal), ms)
d317 1
a317 1
	(NewMap.empty (funid_order,funid_equal), m)
@


1.31
log
@Added make_str_env.
@
text
@d4 3
d143 8
a150 11
  local
    fun convert eq ord x =
    if eq x then NewMap.EQUAL
    else if ord x then NewMap.LESS else NewMap.GREATER
  in
    val valid_order = convert Ident.valid_eq Ident.valid_order
    val strid_order = convert Ident.strid_eq Ident.strid_order
    val funid_order = convert Ident.funid_eq Ident.funid_order
    val sigid_order = convert Ident.sigid_eq Ident.sigid_order
    val symbol_order = convert Ident.Symbol.eq_symbol Ident.Symbol.symbol_order
  end
d152 3
d156 4
a159 4
    EnvironTypes.ENV(NewMap.empty valid_order,
		     NewMap.empty valid_order,
		     NewMap.empty strid_order)
  val empty_fun_env = EnvironTypes.FUN_ENV(NewMap.empty funid_order)
d314 1
a314 1
	(NewMap.empty valid_order, mv)
d318 1
a318 1
	(NewMap.empty valid_order, me)
d322 1
a322 1
	(NewMap.empty strid_order, ms)
d326 1
a326 1
	(NewMap.empty funid_order, m)
@


1.30
log
@Removed counter parameter, unused
@
text
@d4 3
d138 1
d328 21
@


1.29
log
@Removed some redundant structures and sharing
@
text
@d4 3
a103 1
require "../utils/counter";
a119 1
  structure Counter : COUNTER
@


1.28
log
@Added sigid_order and symbol_order functions.
@
text
@d4 3
a98 1
require "../utils/set";
a114 1
  structure Set: SET
d122 1
d124 1
a124 2
  sharing EnvironTypes.Ident = IdentPrint.Ident = Interface.Datatypes.Ident
  sharing EnvironTypes.NewMap = Interface.Datatypes.NewMap
d132 2
a133 1
  structure NewMap = EnvironTypes.NewMap
d201 1
a201 1
        Set.is_member(Symbol.symbol_name v, !overloads)
@


1.27
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d133 11
a143 26
  fun valid_order x =
    if Ident.valid_eq x then
      NewMap.EQUAL
    else
      if Ident.valid_order x then
	NewMap.LESS
      else
	NewMap.GREATER

  fun strid_order x =
    if Ident.strid_eq x then
      NewMap.EQUAL
    else
      if Ident.strid_order x then
	NewMap.LESS
      else
	NewMap.GREATER

  fun funid_order x =
    if Ident.funid_eq x then
      NewMap.EQUAL
    else
      if Ident.funid_order x then
	NewMap.LESS
      else
	NewMap.GREATER
@


1.26
log
@Anel's changes to use NewMap instead of Map
@
text
@d7 3
a91 2
require "../utils/map";
require "../utils/newmap";
a96 1
require "../basics/ident";
a97 1
require "../basics/symbol";
a100 1
require "lambdatypes";
a108 2
  structure NewMap : NEWMAP
  structure Map : MAP
a113 1
  structure Ident : IDENT
a114 1
  structure Symbol : SYMBOL
d116 1
a116 7
  structure LambdaTypes : LAMBDATYPES
  structure Interface: INTERFACE

  sharing EnvironTypes.LambdaTypes = LambdaTypes
  sharing EnvironTypes.Ident = Ident = IdentPrint.Ident = Interface.Ident
  sharing EnvironTypes.NewMap = NewMap = Interface.NewMap
  sharing Ident.Symbol = Symbol
d118 2
d122 3
a124 1
  structure Ident = Ident
d126 2
a127 2
  structure LambdaTypes = LambdaTypes
  structure Interface = Interface
a182 5
(*
    add_list(mv, NewMap.to_list nv),
     add_list(me, NewMap.to_list ne),
     add_list(ms, NewMap.to_list ns))
*)
a189 4
(*
  fun is_empty(EnvironTypes.ENV(mv, me, ms)) =
    Map.emptymap_p(mv) andalso Map.emptymap_p(me) andalso Map.emptymap_p(ms)
*)
a221 3
(*
			   add_list(fun_e1, NewMap.to_list fun_e2))
*)
@


1.25
log
@Removed various uses of NewMap.to_list in favour of fold and union
@
text
@d4 6
d127 1
a127 2
  sharing EnvironTypes.NewMap = NewMap
  sharing Map = Interface.Map
d255 2
a256 1
      Lists.number_with_size(Map.assoc strid_map, next2, EnvironTypes.FIELD)
@


1.24
log
@Added make_external for benefit of interpreter
@
text
@d4 3
d175 1
d183 5
a187 1
    (add_list(mv, NewMap.to_list nv),
d190 1
d233 4
a236 1
      EnvironTypes.FUN_ENV(add_list(fun_e1, NewMap.to_list fun_e2)))
d313 13
a325 4
      val valids = NewMap.to_list mv
      val exns = NewMap.to_list me
      val strids = NewMap.to_list ms
      val funids = NewMap.to_list m
d327 3
a329 4
	map
	(fn arg as (v, EnvironTypes.PRIM _) => arg
	  | (v, _) => (v, EnvironTypes.EXTERNAL))
	valids
d331 3
a333 4
	map
	(fn arg as (v, EnvironTypes.PRIM _) => arg
	  | (v, _) => (v, EnvironTypes.EXTERNAL))
	exns
d335 3
a337 4
	map
	(fn arg as (v, (_, EnvironTypes.PRIM _)) => arg
	  | (v, (e, _)) => (v, (e, EnvironTypes.EXTERNAL)))
	strids
d339 3
a341 5
	map
	(fn arg as (v, (EnvironTypes.PRIM _, _, _)) => arg
	  | (v, (_, i, e)) => (v, (EnvironTypes.EXTERNAL, i, e)))
	funids

d344 2
a345 5
      (EnvironTypes.ENV
       (NewMap.from_list valid_order valids,
	NewMap.from_list valid_order exns,
	NewMap.from_list strid_order strids),
       EnvironTypes.FUN_ENV(NewMap.from_list funid_order funids))
@


1.23
log
@Changed to use newmap
@
text
@d4 3
d297 37
@


1.22
log
@Moved assign_fields function from _lambda
@
text
@d4 3
d78 1
d99 1
d115 2
a116 1
  sharing EnvironTypes.Map = Map = Interface.Map
a121 2
  structure Map = Map
  structure Set = Set
d126 27
d154 4
a157 4
    EnvironTypes.ENV(Map.empty_eqfunmap Ident.valid_eq,
		     Map.empty_eqfunmap Ident.valid_eq,
		     Map.empty_eqfunmap Ident.strid_eq)
  val empty_fun_env = EnvironTypes.FUN_ENV(Map.empty_eqfunmap Ident.funid_eq)
d161 1
a161 1
    EnvironTypes.ENV(Map.add((valid, lvar), mv, Ident.valid_order), me, ms)
d164 1
a164 1
    EnvironTypes.ENV(mv, Map.add((valid, lvar), me, Ident.valid_order), ms)
d167 1
a167 1
    EnvironTypes.ENV(mv, me, Map.add((strid, e_c), ms, Ident.strid_order))
d169 5
d175 12
a186 6
    EnvironTypes.ENV(Map.plus(mv, nv, Ident.valid_order),
      Map.plus(me, ne, Ident.valid_order),
        Map.plus(ms, ns, Ident.strid_order))
  fun lookup_valid(valid, EnvironTypes.ENV(mv, _, _)) = Map.lookup(valid, mv)
  fun lookup_exn(valid, EnvironTypes.ENV(_, me, _)) = Map.lookup(valid, me)
  fun lookup_strid(strid, EnvironTypes.ENV(_, _, ms)) = Map.lookup(strid, ms)
d189 1
d192 1
a192 2
    if Map.domain_member(valid, mv) then
      (case lookup_valid(valid, env) of
d194 1
a194 2
      | _ => false)
    else false
d214 1
d216 1
a216 1
    EnvironTypes.FUN_ENV(Map.add((funid, c_i_e), m, Ident.funid_order))
d221 2
a222 1
      EnvironTypes.FUN_ENV(Map.plus(fun_e1, fun_e2, Ident.funid_order)))
d224 1
a224 1
    Map.lookup(funid, fun_env)
d248 3
d254 4
a257 4
    val valids = Map.assoc mv
    val exns = Map.assoc me
    val strids = Map.assoc ms
    val funids = Map.assoc m
@


1.21
log
@Changed to use eqaulity function maps
@
text
@d4 3
d204 45
@


1.20
log
@Changed paramter ordering in environment update to allow use with
Lists.foldl
@
text
@d4 4
d119 5
a123 15
  fun filter(f_list, filter_fun) = 
  let
    fun filter_sub([]) = []
    | filter_sub(h :: t) =
    if filter_fun h then h :: (filter_sub t)
    else filter_sub t
  in
    filter_sub f_list
  end

  fun drop(x, n) = if n <= 0 orelse x = [] then x
		   else drop(tl x, n-1)

  val empty_env = EnvironTypes.ENV(Map.empty_map, Map.empty_map, Map.empty_map)
  val empty_fun_env = EnvironTypes.FUN_ENV Map.empty_map
@


1.19
log
@Added type to overloads in order to keep njml 0.75 happy
@
text
@d3 4
a6 1
$Log:	_environ.sml,v $
a124 2
  fun foldleft f (e, xs) = Lists.foldl (fn x => (fn y => f(x, y))) e xs

d132 1
a132 1
  fun add_valid_env((valid, lvar), EnvironTypes.ENV(mv, me, ms)) =
d135 1
a135 1
  fun add_exn_env((valid, lvar), EnvironTypes.ENV(mv, me, ms)) =
d138 1
a138 1
  fun add_strid_env((strid, e_c), EnvironTypes.ENV(mv, me, ms)) =
d176 1
a176 1
  fun add_funid_env((funid, c_i_e), EnvironTypes.FUN_ENV m) =
d200 6
a205 4
    foldleft add_strid_env(
      foldleft add_exn_env(
        foldleft add_valid_env(empty_env, v_f_list_fn size),
			   e_f_list_fn size), s_f_e_list)
@


1.18
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d4 3
d165 1
a165 1
    val overloads = ref Set.empty_set
@


1.17
log
@General tidy up, removed local copy of number_from (now in Lists
structure), Made changes due to record selection now requiring
the total size of the record to be present as well as the index.
@
text
@d4 5
d157 3
a159 3
      EnvironTypes.PRIM prim => prim
    | _ => raise(LambdaTypes.impossible "FindBuiltin fails to find prim"))
  | FindBuiltin _ = raise(LambdaTypes.impossible "FindBuiltin gets non-empty path")
@


1.16
log
@Fixed bug in make_env_from_interface to do with exception numbering
@
text
@d4 3
d58 1
d79 1
d162 4
a165 2
    fun is_overloaded_op(Ident.VAR v) =
      Set.is_member(Symbol.symbol_name v, !overloads)
a175 6
  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end
d177 10
a186 9
  fun make_env_from_interface(interface as
    Interface.INT(intenv as Interface.INTENV strid_map, valid_list, exid_list)) =
  let val (v_f_list, next) =
      number_from(valid_list, 0, EnvironTypes.FIELD o LambdaTypes.toField)
    val (e_f_list, next) =
      number_from(exid_list, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val (s_f_list, _) =
      number_from(Map.assoc strid_map, next,
	EnvironTypes.FIELD o LambdaTypes.toField)
d188 2
a189 1
      map (fn ((s, i), f) => (s, (make_env_from_interface i, f))) s_f_list
d193 2
a194 1
        foldleft add_valid_env(empty_env, v_f_list), e_f_list), s_f_e_list)
a195 1

@


1.15
log
@Added exception environment to env
@
text
@d4 3
d181 1
a181 1
      number_from(exid_list, 0, EnvironTypes.FIELD o LambdaTypes.toField)
@


1.14
log
@Added empty_fun_env, add_funid_env, changed Fun_Env to use comp
@
text
@d4 3
d83 2
a84 3
  sharing EnvironTypes.Ident = Ident
  sharing EnvironTypes.Map = Map
  sharing IdentPrint.Ident = Ident
d111 1
a111 1
  val empty_env = EnvironTypes.ENV(Map.empty_map, Map.empty_map)
d115 2
a116 2
  fun add_valid_env((valid, lvar), EnvironTypes.ENV(m1, m2)) =
    EnvironTypes.ENV(Map.add((valid, lvar), m1, Ident.valid_order), m2)
d118 5
a122 2
  fun add_strid_env((strid, e_c), EnvironTypes.ENV(m1, m2)) =
    EnvironTypes.ENV(m1, Map.add((strid, e_c), m2, Ident.strid_order))
d124 12
a135 10
  fun augment_env(EnvironTypes.ENV(m1, m2), EnvironTypes.ENV(n1, n2)) =
    EnvironTypes.ENV(Map.plus(m1, n1, Ident.valid_order),
      Map.plus(m2, n2, Ident.strid_order))
  fun lookup_valid(valid, EnvironTypes.ENV(m1, _)) = Map.lookup(valid, m1)
  fun lookup_strid(strid, EnvironTypes.ENV(_, m2)) = Map.lookup(strid, m2)
  fun is_empty(EnvironTypes.ENV(m1, m2)) =
    Map.emptymap_p(m1) andalso Map.emptymap_p(m2)
  fun Builtin_p (Ident.LONGVALID(Ident.NOPATH, valid),
    env as EnvironTypes.ENV(map1, map2)) =
    if Map.domain_member(valid, map1) then
d159 1
a159 1
  (* Add one strid -> env, comp translation to an existing environment *)
d166 24
@


1.13
log
@Reorganised
@
text
@d4 3
d110 2
a111 2
  val empty_top_env =
    EnvironTypes.TOP_ENV(empty_env, EnvironTypes.FUN_ENV Map.empty_map)
d118 1
a118 1
  (* Add one valid -> env, comp translation to an existing environment *)
d150 3
@


1.12
log
@Added empty_top_env and lookup_funid
@
text
@d4 3
d141 2
a142 21
    fun define_overloaded_ops(EnvironTypes.ENV(v_map, s_map)) =
    let
      val val_domain =
	filter(Map.assoc v_map,
	  fn(_, c) => case c of EnvironTypes.PRIM _ => true | _ => false)
      val overload_ext_names =
	filter(val_domain,
	  fn (Ident.VAR x, _) => hd(explode(Symbol.symbol_name x)) = "'"
	  | _ => false)
      val overload_names = map
	(fn (Ident.VAR x, _) =>
	  let val exploded = explode(Symbol.symbol_name x)
	  in
	    implode(drop(exploded, (length exploded)-1))
	  end)
	overload_ext_names
      val overloaded_name_set = foldleft Set.add_member
	(Set.empty_set, overload_names)
    in
      overloads := overloaded_name_set
    end
a145 8
  end
  fun make_imperative_primitives env =
  let val EnvironTypes.PRIM ref_prim =
      lookup_valid(Ident.CON(Symbol.find_symbol"ref"), env)
    val EnvironTypes.PRIM bec_prim =
      lookup_valid(Ident.VAR(Symbol.find_symbol":="), env)
  in
    Set.list_to_set([ref_prim, bec_prim])
@


1.11
log
@Added augment_top_env
@
text
@d4 3
d49 1
d71 2
d78 1
d86 1
d103 3
a105 1
  val empty_env = EnvironTypes.ENV (Map.empty_map, Map.empty_map)
d175 2
@


1.10
log
@Added function to find imperative primitives
@
text
@d4 3
d161 4
@


1.9
log
@Added overload environment to handle overloaded primitives such as +
@
text
@d4 3
d73 1
d103 2
a104 12
  fun lookup_valid(valid, EnvironTypes.ENV(m1, _)) = (* let
    val _ = print("Looking up ")
    val _ = print(IdentPrint.printValId(valid))
  in *)
    Map.lookup(valid, m1)
(*  end *)
  fun lookup_strid(strid, EnvironTypes.ENV(_, m2)) = (* let
    val _ = print("Looking up ")
    val _ = print(IdentPrint.printStrId(strid))
  in *)
    Map.lookup(strid, m2)
(*  end *)
d149 8
@


1.8
log
@Removed Findconst as it's not used. Changed Builtin_p so it doesn't
need to catch exceptions
@
text
@d4 4
d33 4
d39 1
a39 2
require "../utils/integer";
require "../utils/counter";
a50 1
  structure Ident : IDENT
d52 2
d56 1
d58 1
d64 3
a66 1
  sharing IdentPrint.Ident = Ident) : ENVIRON =
d73 15
d127 29
@


1.7
log
@Removed match support, as this is internal to _lambda
@
text
@d4 3
d86 7
a92 5
  fun Builtin_p (Ident.LONGVALID(Ident.NOPATH, valid), env) = (case
      lookup_valid(valid, env) of
      EnvironTypes.PRIM(prim) => true
    | _ => false
    handle Map.Lookup => false)
d94 1
a94 1
  (* Ident.LongValId * Env -> bool *)
d97 1
a97 1
      EnvironTypes.PRIM(prim) => prim
a99 3
  (* : Ident.LongValId * Env -> primitive *)
  fun FindConst s = raise(LambdaTypes.not_done_yet"FindConst")
    (* : string -> primitive *)
@


1.6
log
@Modified match environment functions for use with fold. Changed
names to be consistent with value environment
@
text
@d4 4
a24 1
require "../match/match";
a41 1
  structure Match : MATCH
a53 1
  structure Match = Match
a57 2
  datatype MatchEnv = ME of (Match.Matchvar, LambdaTypes.LVar) Map.Map

a58 1
  val empty_match_env = ME Map.empty_map
a97 12
  fun add_match_env((mv, lv), ME me) =
    ME(Map.add((mv, lv), me, (fn (x, y) =>
      (Match.from_Matchvar x) < (Match.from_Matchvar y))))
    (* raise(LambdaTypes.not_done_yet"MVtoLVar") *)
    (*: Match.Matchvar * LambdaTypes.LVar * MatchEnv -> MatchEnv
    (* Bind LVar to MV *) *)
  fun lookup_match(mv, ME me) = Map.lookup(mv, me)
    (* raise(LambdaTypes.not_done_yet"LVarFromMV") *)
    (*: Match.Matchvar * MatchEnv -> LambdaTypes.LVar
    (* Lookup LVar from MV *) *)
  fun LabeltoLVar l = raise(LambdaTypes.not_done_yet"LabeltoLVar")
    (* : Match.Label -> LVar *)
@


1.5
log
@Implemented match environment update and lookup functions
@
text
@d4 3
d100 1
a100 1
  fun MVtoLVar(mv, lv, ME me) =
d106 1
a106 1
  fun LVarFromMV(mv, ME me) = Map.lookup(mv, me)
@


1.4
log
@Added match environment type, and changed the types of matchvar
lookup and generate
@
text
@d4 4
a36 1
  structure Absyn : ABSYN
d41 2
a42 2
  structure EnvironTypes: ENVIRONTYPES
  structure LambdaTypes: LAMBDATYPES
d46 1
a46 3
  sharing IdentPrint.Ident = Ident
  sharing Match.Absyn = Absyn
  sharing Absyn.IdentClass = Ident) : ENVIRON =
d97 4
a100 1
  fun MVtoLVar(mv, lv, me) = raise(LambdaTypes.not_done_yet"MVtoLVar")
d103 2
a104 1
  fun LVarFromMV(mv, me) = raise(LambdaTypes.not_done_yet"LVarFromMV")
@


1.3
log
@Change add_valid_env and add_strid_env to have type 'a * Env -> Env
to allow use with foldleft or foldright
,
@
text
@d4 4
d53 5
a78 1
  val empty_env = EnvironTypes.ENV (Map.empty_map, Map.empty_map)
d96 6
a101 4
  fun MVtoLVar mv = raise(LambdaTypes.not_done_yet"MVtoLVar")
    (*: Match.Matchvar -> LVar (* Bind a LVar to a MV *) *)
  fun LVarFromMV mv = raise(LambdaTypes.not_done_yet"LVarFromMV")
    (*: Match.Matchvar -> LVar (* Lookup a LVar from a MV *) *)
@


1.2
log
@Split off types from rest of environ
@
text
@d3 4
a6 1
$Log$
d49 1
a49 1
  fun add_valid_env(valid, lvar, EnvironTypes.ENV(m1, m2)) =
d52 1
a52 1
  fun add_strid_env(strid, e_c, EnvironTypes.ENV(m1, m2)) =
@


1.1
log
@Initial revision
@
text
@d2 5
d14 2
d23 1
a23 1
functor Handle_Env (
d31 5
a39 2
  type primitive = int
  type LVar = int
d43 2
a44 4
  datatype comp =
      LAMB of LVar | (* Lambda variables names *)
      FIELD of int | (* Field selectors in structures *)
      PRIM of int    (* Primitive functions, numbers on the wall *)
d46 2
a47 7
  datatype Env =
      ENV of (Ident.ValId, comp) Map.Map * (Ident.StrId, Env * comp) Map.Map

  exception impossible of string
  exception not_done_yet of string
  fun add_valid_env(valid, lvar, ENV(m1, m2)) =
    ENV(Map.add((valid, lvar), m1, Ident.valid_order), m2)
d49 2
a50 2
  fun add_strid_env(strid, e_c, ENV(m1, m2)) =
    ENV(m1, Map.add((strid, e_c), m2, Ident.strid_order))
d52 2
a53 2
  fun augment_env(ENV(m1, m2), ENV(n1, n2)) =
    ENV(Map.plus(m1, n1, Ident.valid_order),
d55 1
a55 1
  fun lookup_valid(valid, ENV(m1, _)) = let
d58 1
a58 1
  in
d60 2
a61 2
  end
  fun lookup_strid(strid, ENV(_, m2)) = let
d64 1
a64 1
  in
d66 4
a69 2
  end
  val empty_env = ENV (Map.empty_map, Map.empty_map)
d72 1
a72 1
      PRIM(prim) => true
d78 4
a81 3
    case lookup_valid(valid, env) of
      PRIM(prim) => prim
    | _ => raise(impossible "FindBuiltin fails to find prim")
d83 8
a90 10
  fun FindConst s = 0 (* : string -> primitive *)
  fun MVtoLVar mv = 0 (*: Match.Matchvar -> LVar (* Bind a LVar to a MV *) *)
  fun LVarFromMV mv = 0 (*: Match.Matchvar -> LVar (* Lookup a LVar *)
			(*from a MV *) *)
  fun LabeltoLVar l = 0 (* : Match.Label -> LVar *)
  fun new_LVar () = Counter.counter () (* : unit -> LVar *)
  fun alter_LVar_count i = Counter.reset_counter i (* : LVar -> unit *)
  fun init_LVar () = Counter.reset_counter 0
  fun printLVar lvar = Integer.makestring lvar
  fun printprim prim = Integer.makestring prim
@
