head	1.22;
access;
symbols
	MLW_daveb_inline_1_4_99:1.22.3
	MLWorks_21c0_1999_03_25:1.22
	MLWorks_20c1_1998_08_20:1.22
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.22
	MLWorks_20b2_Windows_1998_06_12:1.22
	MLWorks_20b1c1_1998_05_07:1.22
	MLWorks_20b0_1998_04_07:1.22
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.22
	MLWorks_20m1_1997_10_23:1.22
	MLWorks_11r1:1.21.8.1.1.1.1
	MLWorks_workspace_97:1.22.2
	MLWorks_dt_wizard:1.22.1
	MLWorks_11c0_1997_09_09:1.21.8.1.1.1
	MLWorks_10r3:1.21.8.1.3
	MLWorks_10r2_551:1.21.8.1.2
	MLWorks_11:1.21.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.8.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.21.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.8
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.6.1.1
	MLWorks_gui_1996_12_18:1.21.7
	MLWorks_1_0_Win32_1996_12_17:1.21.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.4.1
	MLWorks_1_0_Irix_1996_11_28:1.21.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.21.5
	MLWorks_1_0_Unix_1996_11_14:1.21.4
	MLWorks_Open_Beta2_1996_10_11:1.21.3
	MLWorks_License_dev:1.21.2
	MLWorks_1_open_beta_1996_09_13:1.21.1
	MLWorks_Open_Beta_1996_08_22:1.21
	MLWorks_Beta_1996_07_02:1.21
	MLWorks_Beta_1996_06_07:1.21
	MLWorks_Beta_1996_06_06:1.21
	MLWorks_Beta_1996_06_05:1.21
	MLWorks_Beta_1996_06_03:1.21
	MLWorks_Beta_1996_05_31:1.21
	MLWorks_Beta_1996_05_30:1.21
	ML_beta_release_12/08/94:1.18
	ML_beta_release_03/08/94:1.18
	ML_revised_beta_release_25/05/94:1.18
	ML_final_beta_release_02/03/94:1.18
	mlworks-28-01-1994:1.17
	Release:1.16
	mlworks-beta-01-09-1993:1.16
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.12
	MLWorks-1-0-2-15/12/1992:1.12
	MLWorks-1-0-1-04/12/1992:1.12
	checkpoint_17_08_92:1.10
	Ten15_release_21-08-91:1.5
	Ten15_release_19-08-91:1.5
	ten15_release:1.5;
locks; strict;
comment	@ * @;


1.22
date	97.05.22.13.12.07;	author jont;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1;
next	1.21;

1.21
date	96.04.30.16.15.03;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1
	1.21.5.1
	1.21.6.1
	1.21.7.1
	1.21.8.1;
next	1.20;

1.20
date	95.03.22.13.52.50;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	94.10.03.13.43.55;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	94.02.21.18.42.16;	author nosa;	state Exp;
branches;
next	1.17;

1.17
date	94.01.19.12.38.20;	author nosa;	state Exp;
branches;
next	1.16;

1.16
date	93.07.07.16.51.59;	author daveb;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	93.03.10.16.41.34;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	93.03.04.12.37.35;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	93.01.05.16.31.44;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.11.26.14.05.21;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	92.08.26.12.06.22;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.08.12.11.49.45;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	92.08.05.17.45.39;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	92.06.15.16.58.16;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.06.10.17.47.47;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.02.11.10.29.49;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	91.07.19.16.44.31;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.07.12.17.47.11;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.27.13.17.42;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.19.33.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.10.06.47;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	93.07.07.16.51.59;	author jont;	state Exp;
branches;
next	;

1.21.1.1
date	96.09.13.11.17.00;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.10.07.16.06.47;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.10.17.11.25.04;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.11.14.12.50.00;	author hope;	state Exp;
branches
	1.21.4.1.1.1;
next	;

1.21.4.1.1.1
date	96.11.28.15.01.10;	author hope;	state Exp;
branches;
next	;

1.21.5.1
date	96.11.22.18.09.30;	author hope;	state Exp;
branches;
next	;

1.21.6.1
date	96.12.17.17.48.08;	author hope;	state Exp;
branches
	1.21.6.1.1.1;
next	;

1.21.6.1.1.1
date	97.02.24.11.37.58;	author hope;	state Exp;
branches;
next	;

1.21.7.1
date	96.12.18.09.42.10;	author hope;	state Exp;
branches;
next	;

1.21.8.1
date	97.05.12.10.34.38;	author hope;	state Exp;
branches
	1.21.8.1.1.1
	1.21.8.1.2.1
	1.21.8.1.3.1;
next	;

1.21.8.1.1.1
date	97.07.28.18.19.56;	author daveb;	state Exp;
branches
	1.21.8.1.1.1.1.1;
next	;

1.21.8.1.1.1.1.1
date	97.10.07.11.45.04;	author jkbrook;	state Exp;
branches;
next	;

1.21.8.1.2.1
date	97.09.08.17.13.30;	author daveb;	state Exp;
branches;
next	;

1.21.8.1.3.1
date	97.09.09.14.09.11;	author daveb;	state Exp;
branches;
next	;

1.22.1.1
date	97.09.10.19.24.43;	author brucem;	state Exp;
branches;
next	;

1.22.2.1
date	97.09.11.20.55.19;	author daveb;	state Exp;
branches;
next	;

1.22.3.1
date	99.04.01.17.57.05;	author daveb;	state Exp;
branches;
next	;


desc
@Environment printing
@


1.22
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@(* _environprint.sml the functor *)
(*
$Log: _environprint.sml,v $
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.20  1995/03/22  13:52:50  daveb
 * Removed unused parameter Types.
 *
Revision 1.19  1994/10/03  13:43:55  matthew
Lambdatypes changes

Revision 1.18  1994/02/21  18:42:16  nosa
generate_moduler compiler option in strenvs and funenvs for compatibility purposes.

Revision 1.17  1994/01/19  12:38:20  nosa
Paths in LAMBs for dynamic pattern-redundancy reporting

Revision 1.16  1993/07/07  16:51:59  daveb
Funenvs no longer have interface components.

Revision 1.15  1993/03/10  16:41:34  matthew
Signature revisions

Revision 1.14  1993/03/04  12:37:35  matthew
Options & Info changes

Revision 1.13  1993/01/05  16:31:44  jont
Added functions to print directly to a supplied stream

Revision 1.12  1992/11/26  14:05:21  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.11  1992/08/26  12:06:22  jont
Removed some redundant structures and sharing

Revision 1.10  1992/08/12  11:49:45  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.9  1992/08/05  17:45:39  jont
Removed some structures and sharing

Revision 1.8  1992/06/15  16:58:16  jont
Added EXTERNAL constructor to COMP

Revision 1.7  1992/06/10  17:47:47  jont
Changed to use newmap

Revision 1.6  1992/02/11  10:29:49  clive
New pervasive library

Revision 1.5  1991/07/19  16:44:31  davida
New version using custom pretty-printer

Revision 1.4  91/07/12  17:47:11  jont
Updated to print top level environments

Revision 1.3  91/06/27  13:17:42  jont
Improved output format to get names and values on the same line

Revision 1.2  91/06/12  19:33:00  jont
Split environtypes from environ

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__text_io";

require "pretty";
require "environ";
require "environprint";
require "../basics/identprint";

functor EnvironPrint(
  structure Pretty : PRETTY
  structure IdentPrint : IDENTPRINT
  structure Environ: ENVIRON

  sharing IdentPrint.Ident = Environ.EnvironTypes.LambdaTypes.Ident
) : ENVIRONPRINT =
struct

  structure P = Pretty
  structure IP = IdentPrint
  structure EnvironTypes = Environ.EnvironTypes
  structure LambdaTypes = EnvironTypes.LambdaTypes
  structure NewMap = EnvironTypes.NewMap
  structure Options = IdentPrint.Options

  fun decodecomp x = 
      P.blk(0,
	    case x of
		EnvironTypes.LAMB (lvar,_) => 
		    [P.str "LAMB ",
		     P.str (LambdaTypes.printLVar lvar)]

	      | EnvironTypes.FIELD {size,index} => 
		    [P.str "FIELD ",
		     P.str (LambdaTypes.printField {size=size,index=index,selecttype=LambdaTypes.TUPLE})]

	      | EnvironTypes.PRIM prim => 
		    [P.str "PRIM ",
		     P.str (LambdaTypes.printPrim prim)]
	      | EnvironTypes.EXTERNAL => [P.str"EXTERNAL"])
		    
  fun envir_block l =  P.blk(1,
			     [P.str "{"] @@ 
			     (P.lst("", [P.str ",", P.brk 1], "") l) @@
			     [P.str " }"]);

  fun decodeenv options (x as EnvironTypes.ENV(valids, strids)) = 
      let
	  fun decode_valid_list l = 
	     let 
		 fun tof (valid,comp) = P.blk(2, 
					      [P.str " ",
					       P.str (IP.printValId options valid), 
					       P.str " --> ",
					       decodecomp comp])
	     in 
		 envir_block (map tof l)
	     end

	  fun decode_strid_list l =
	      let
		  fun tof (strid, (env, comp, _)) =
		      P.blk(0, 
			    [P.str " ",
			     P.str (IP.printStrId strid),
			     P.str " --> ",
			     decodecomp comp,
			     P.blk(0,[P.str " ",
				      decodeenv options env])])
	      in
		  P.blk(1, [P.str "{"] @@ 
			    (P.lst("", [P.brk 2], "") (map tof l)) @@
			    [P.str " }"])
	      end;

      in
	  P.blk(0,
		[P.str " VE: ",
		 P.blk(0, [decode_valid_list (NewMap.to_list_ordered valids)]),
		 P.nl,
		 P.str " SE: ",
		 P.blk(0, [decode_strid_list (NewMap.to_list_ordered strids)])])
      end;

  fun stringenv options env = P.string_of_T (decodeenv options env);

  fun printenv options env stream =
    P.print_T (fn x => TextIO.output(stream, x)) (decodeenv options env)

  fun decodetopenv options (EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)) =
      let 
	  fun decode_functor_list l = 
	    let 
	      fun tof (funid, (c, e, _)) = 
		  P.blk(2, [P.str (IP.printFunId funid),
			    P.str " --> ",
			    P.blk(0, 
				  [decodecomp c,
				   P.nl,
				   P.str "ResEnv: ",
				   P.blk(0, [decodeenv options e])])])
	    in 
		envir_block (map tof l)
	    end;
      in
	  P.blk(0,
		[P.str " Ftr: ",
		 P.blk(0, [decode_functor_list (NewMap.to_list_ordered fun_env)]),
		 P.nl,
		 P.str " Top:",
		 P.blk(0, [decodeenv options env])])
      end;
      
  fun stringtopenv options env = P.string_of_T (decodetopenv options env);

  fun printtopenv options env stream =
    P.print_T (fn x => TextIO.output(stream, x)) (decodetopenv options env)

end
@


1.22.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.22  1997/05/22  13:12:07  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.22.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.22  1997/05/22  13:12:07  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.22.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.22  1997/05/22  13:12:07  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.21
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d72 2
d157 1
a157 1
    P.print_T (fn x => MLWorks.IO.output(stream, x)) (decodeenv options env)
d186 1
a186 1
    P.print_T (fn x => MLWorks.IO.output(stream, x)) (decodetopenv options env)
@


1.21.8.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:34:38  hope
 * branched from 1.21
 *
@


1.21.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:34:38  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.21.8.1  1997/05/12  10:34:38  hope
 * branched from 1.21
 *
@


1.21.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.21.8.1.1.1  1997/07/28  18:19:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21.7.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.6.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.6.1.1.1
log
@branched from 1.21.6.1
@
text
@a3 3
 * Revision 1.21.6.1  1996/12/17  17:48:08  hope
 * branched from 1.21
 *
@


1.21.5.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.4.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.4.1.1.1
log
@branched from 1.21.4.1
@
text
@a3 3
 * Revision 1.21.4.1  1996/11/14  12:50:00  hope
 * branched from 1.21
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 6
 * Revision 1.21  1996/04/30  16:15:03  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.20
log
@Removed unused parameter Types.
@
text
@d4 3
d149 1
a149 1
    P.print_T (fn x => output(stream, x)) (decodeenv options env)
d178 1
a178 1
    P.print_T (fn x => output(stream, x)) (decodetopenv options env)
@


1.19
log
@Lambdatypes changes
@
text
@d4 3
a66 1
require "../typechecker/types" ;
a69 1
  structure Types : TYPES
d73 1
a73 1
  sharing Types.Datatypes.Ident = IdentPrint.Ident = Environ.EnvironTypes.LambdaTypes.Ident
@


1.18
log
@generate_moduler compiler option in strenvs and funenvs for compatibility purposes.
@
text
@d4 3
d90 1
a90 1
	      | EnvironTypes.FIELD field => 
d92 1
a92 1
		     P.str (LambdaTypes.printField field)]
@


1.17
log
@Paths in LAMBs for dynamic pattern-redundancy reporting
@
text
@d4 3
d116 1
a116 1
		  fun tof (strid, (env, comp)) =
d148 1
a148 1
	      fun tof (funid, (c, e)) = 
@


1.16
log
@Funenvs no longer have interface components.
@
text
@d4 3
d80 1
a80 1
		EnvironTypes.LAMB lvar => 
@


1.16.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.16  1993/07/07  16:51:59  daveb
Funenvs no longer have interface components.

@


1.15
log
@Signature revisions
@
text
@d4 3
d95 1
a95 1
  fun decodeenv options (x as EnvironTypes.ENV(valids, exns, strids)) = 
a128 3
		 P.str " EE: ",
		 P.blk(0, [decode_valid_list (NewMap.to_list_ordered exns)]),
		 P.nl,
d142 1
a142 1
	      fun tof (funid, (c, i, e)) = 
a146 6
				   P.nl,
				   P.str "ArgEnv: ",
				   P.blk(0, 
				     [decodeenv 
				      options
				      (Environ.make_env_from_interface i)]),
@


1.14
log
@Options & Info changes
@
text
@d4 3
d59 2
a60 2
  sharing Types.Datatypes = Environ.EnvironTypes.LambdaTypes.Datatypes
  sharing Types.Datatypes.Ident = IdentPrint.Ident
d68 1
a68 4
  structure Datatypes = Types.Datatypes
  structure NewMap = Datatypes.NewMap
  structure Ident = Datatypes.Ident
  structure Symbol = Ident.Symbol
@


1.13
log
@Added functions to print directly to a supplied stream
@
text
@d4 3
d69 1
a69 1
  structure Info = IdentPrint.Info
@


1.12
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d130 1
a130 1
  fun printenv options env = P.string_of_T (decodeenv options env);
d132 2
d165 4
a168 2
  fun printtopenv options env = P.string_of_T (decodetopenv options env);
      
@


1.11
log
@Removed some redundant structures and sharing
@
text
@d4 3
d62 1
d85 1
a85 1
  fun decodeenv (x as EnvironTypes.ENV(valids, exns, strids)) = 
d91 1
a91 1
					       P.str (IP.printValId valid), 
d107 1
a107 1
				      decodeenv env])])
d126 1
a126 1
  val printenv = P.string_of_T o decodeenv;
d129 1
a129 1
  fun decodetopenv (EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)) =
d142 1
d146 1
a146 1
				   P.blk(0, [decodeenv e])])])
d156 1
a156 1
		 P.blk(0, [decodeenv env])])
d159 1
a159 1
  val printtopenv = P.string_of_T o decodetopenv;
@


1.10
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
d46 2
a47 2

  sharing Types.Datatypes.Ident = Environ.Ident = IdentPrint.Ident
d55 3
a57 2
  structure NewMap = EnvironTypes.NewMap
  structure Ident = LambdaTypes.Ident
@


1.9
log
@Removed some structures and sharing
@
text
@d4 3
d34 1
d40 1
d43 1
a43 1
  sharing Types.Datatypes.IdentPrint.Ident =  Environ.Ident
d48 1
a48 1
  structure IP = Types.Datatypes.IdentPrint
@


1.8
log
@Added EXTERNAL constructor to COMP
@
text
@d4 3
a27 3
require "../utils/newmap";
require "../basics/identprint";
require "../basics/ident";
a28 2
require "lambdatypes";
require "environtypes";
a34 2
  structure IdentPrint : IDENTPRINT
  structure Ident : IDENT
a35 2
  structure LambdaTypes: LAMBDATYPES
  structure EnvironTypes: ENVIRONTYPES
a36 1
  structure NewMap: NEWMAP
d38 1
a38 6
  sharing NewMap = EnvironTypes.NewMap
  sharing Ident = LambdaTypes.Ident = EnvironTypes.Ident = IdentPrint.Ident =
    Environ.Ident
  sharing EnvironTypes.LambdaTypes = LambdaTypes = Environ.LambdaTypes
  sharing Environ.EnvironTypes = EnvironTypes
  sharing Environ.Interface = EnvironTypes.Interface
d43 5
a47 2
  structure IP = IdentPrint
  structure Ident = Ident
a48 3
  structure LambdaTypes = LambdaTypes
  structure EnvironTypes = EnvironTypes

@


1.7
log
@Changed to use newmap
@
text
@d4 3
d75 2
a76 1
		     P.str (LambdaTypes.printPrim prim)]);
@


1.6
log
@New pervasive library
@
text
@d4 3
d22 1
a22 1
require "../utils/map";
d40 1
a40 1
  structure Map: MAP
d42 1
a42 1
  sharing Map = EnvironTypes.Map = Environ.Map
d111 1
a111 1
		 P.blk(0, [decode_valid_list (Map.assoc valids)]),
d114 1
a114 1
		 P.blk(0, [decode_valid_list (Map.assoc exns)]),
d117 1
a117 1
		 P.blk(0, [decode_strid_list (Map.assoc strids)])])
d146 1
a146 1
		 P.blk(0, [decode_functor_list (Map.assoc fun_env)]),
@


1.5
log
@New version using custom pretty-printer
@
text
@d3 4
a6 1
$Log:	_environprint.sml,v $
d27 1
@


1.4
log
@Updated to print top level environments
@
text
@d4 3
a15 1
require "../utils/sexpr";
d19 1
d26 1
a26 1
  structure Sexpr : SEXPR
d44 1
a44 1
  structure S = Sexpr
a50 2
  type 'a Sexpr = 'a Sexpr.Sexpr
  exception not_done_yet (*of string*) = LambdaTypes.not_done_yet
d52 6
a57 1
  val printSexpr = S.pprintSexpr (fn x => x)
d59 3
a61 7
  fun decodecomp x = case x of
    EnvironTypes.LAMB lvar => [S.ATOM"LAMB",
    S.ATOM(LambdaTypes.printLVar lvar), S.ATOM"\n"]
  | EnvironTypes.FIELD field => [S.ATOM"FIELD",
    S.ATOM(LambdaTypes.printField field), S.ATOM"\n"]
  | EnvironTypes.PRIM prim => [S.ATOM"PRIM",
    S.ATOM(LambdaTypes.printPrim prim), S.ATOM"\n"]
d63 8
a70 15
  fun decodeenv (x as EnvironTypes.ENV(valids, exns, strids)) = let
    fun decode_valid_list [] = S.NIL
    | decode_valid_list((valid, comp) :: tl) =
      S.append(S.list(S.ATOM (IP.printValId valid) :: (decodecomp comp)),
	decode_valid_list tl)
    fun decode_strid_list [] = S.NIL
    | decode_strid_list((strid, (env, comp)) :: tl) =
      S.append(S.list[S.ATOM(IP.printStrId strid), S.ATOM("subenv("),
        decodeenv(env), S.ATOM(")"), S.list(decodecomp comp)],
        decode_strid_list tl)
  in
    S.list[S.ATOM"The value list", decode_valid_list(Map.assoc valids),
      S.ATOM"The exception list", decode_valid_list(Map.assoc exns),
        S.ATOM("The structure list"), decode_strid_list(Map.assoc strids)]
  end
d72 12
a83 1
  fun printenv x = printSexpr (decodeenv x)
d85 15
a99 9
  fun decode_functor_list [] = S.NIL
  | decode_functor_list((funid, (c, i, e)) :: tail) =
  let
    val this = S.list[S.ATOM"functor ", S.ATOM(IP.printFunId funid),
      S.ATOM" arg env ", decodeenv(Environ.make_env_from_interface i),
	S.ATOM" result env", decodeenv e, S.list(decodecomp c)]
  in
    S.append(this, decode_functor_list tail)
  end
d101 11
a111 3
  fun decodetopenv(EnvironTypes.TOP_ENV(env, EnvironTypes.FUN_ENV fun_env)) =
    S.list[S.ATOM"The functor list", decode_functor_list(Map.assoc fun_env),
      S.ATOM"The value environment", decodeenv env]
d113 35
a147 1
  val printtopenv = printSexpr o decodetopenv
@


1.3
log
@Improved output format to get names and values on the same line
@
text
@d4 3
d19 1
d29 1
d32 7
a38 5
  sharing Map = EnvironTypes.Map
  sharing Ident = LambdaTypes.Ident
  sharing Ident = EnvironTypes.Ident
  sharing EnvironTypes.LambdaTypes = LambdaTypes
  sharing Ident = IdentPrint.Ident) : ENVIRONPRINT =
d60 4
a63 3
  fun decodeenv (x as EnvironTypes.ENV(left, right)) = let
    fun decode_left_list [] = S.NIL
    | decode_left_list((valid, comp) :: tl) =
d65 4
a68 4
	decode_left_list tl)
    fun decode_right_list [] = S.NIL
    | decode_right_list((strid, (env, comp)) :: tl) =
      S.append(S.list[S.ATOM (IP.printStrId strid), S.ATOM("subenv("),
d70 1
a70 1
        decode_right_list tl)
d72 3
a74 2
    S.list[S.ATOM("The left list"), decode_left_list(Map.assoc left),
      S.ATOM("The right list"), decode_right_list(Map.assoc right)]
d76 1
d78 16
@


1.2
log
@Split environtypes from environ
@
text
@d3 4
a6 1
$Log$
d18 14
a31 12
functor EnvironPrint (structure Sexpr : SEXPR
		    structure IdentPrint : IDENTPRINT
		    structure Ident : IDENT
                    structure Types : TYPES
		    structure LambdaTypes: LAMBDATYPES
		    structure EnvironTypes: ENVIRONTYPES
		    structure Map: MAP
		    sharing Map = EnvironTypes.Map
		    sharing Ident = LambdaTypes.Ident
		    sharing Ident = EnvironTypes.Ident
		    sharing EnvironTypes.LambdaTypes = LambdaTypes
		    sharing Ident = IdentPrint.Ident) : ENVIRONPRINT =
d47 6
a52 6
    EnvironTypes.LAMB(lvar) => S.list[S.ATOM("(LAMB"),
    S.ATOM(LambdaTypes.printLVar lvar), S.ATOM(")")]
  | EnvironTypes.FIELD(field) => S.list[S.ATOM("(FIELD"),
    S.ATOM(LambdaTypes.printField field), S.ATOM(")")]
  | EnvironTypes.PRIM(prim) => S.list[S.ATOM("(PRIM"),
    S.ATOM(LambdaTypes.printPrim prim), S.ATOM(")")]
d56 1
a56 1
      S.append(S.list[S.ATOM (IP.printValId valid), decodecomp comp],
d61 1
a61 1
        decodeenv(env), S.ATOM(")"), decodecomp comp],
@


1.1
log
@Initial revision
@
text
@d2 5
d11 2
a12 2
require "lambda";
require "environ";
d19 2
a20 2
		    structure Lambda: LAMBDA
		    structure Environ: ENVIRON
d22 4
a25 4
		    sharing Map = Environ.Map
		    sharing Ident = Lambda.Ident
		    sharing Ident = Environ.Ident
		    sharing type Environ.LVar = Lambda.LVar
d27 1
a27 1
  struct
d29 6
a34 6
    structure S = Sexpr
    structure IP = IdentPrint
    structure Ident = Ident
    structure Symbol = Ident.Symbol
    structure Lambda = Lambda
    structure Environ = Environ
d36 2
a37 2
    type 'a Sexpr = 'a Sexpr.Sexpr
    exception not_done_yet (*of string*) = Environ.not_done_yet
d39 1
a39 1
    val printSexpr = S.pprintSexpr (fn x => x)
d41 20
a60 68
    fun decodecomp x = case x of
      Environ.LAMB(lvar) => S.list[S.ATOM("(LAMB"),
        S.ATOM(Environ.printLVar lvar),	S.ATOM(")")]
    | Environ.FIELD(field) => S.list[S.ATOM("(FIELD"),
        S.ATOM(Integer.makestring field), S.ATOM(")")]
    | Environ.PRIM(prim) => S.list[S.ATOM("(PRIM"),
      S.ATOM(Environ.printprim prim), S.ATOM(")")]
    fun decodeenv (x as Environ.ENV(left, right)) = let
      fun decode_left_list [] = S.NIL
      | decode_left_list((valid, comp) :: tl) =
	S.append(S.list[S.ATOM (IP.printValId valid), decodecomp comp],
	  decode_left_list tl)
      fun decode_right_list [] = S.NIL
      | decode_right_list((strid, (env, comp)) :: tl) =
	S.append(S.list[S.ATOM (IP.printStrId strid), S.ATOM("subenv("),
          decodeenv(env), S.ATOM(")"), decodecomp comp],
	  decode_right_list tl)
    in
      S.list[S.ATOM("The left list"), decode_left_list(Map.assoc left),
        S.ATOM("The right list"), decode_right_list(Map.assoc right)]
    end
(* let
      fun decodeconstruc(construc) =
	case construc of
	  Lambda.CON_TAG(i) => S.list[S.ATOM("CON_TAG("), S.ATOM (Integer.makestring i), S.ATOM(")")]
	| Lambda.SCON_TAG(scon) => S.list[S.ATOM("SCON_TAG("), S.ATOM (IP.printSCon scon), S.ATOM(")")]
      fun decode_construc_lambda_list [] = S.NIL
      | decode_construc_lambda_list ((construc, lambda) :: tl) =
	S.append(S.list[decodeconstruc construc, decodelambda lambda], decode_construc_lambda_list tl)
    in
      case x of
	Lambda.VAR (lvar)              (* variable lookup *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.VAR"))
      | Lambda.FN (lvar, lambda)       (* function definition *)
	=> S.list[S.ATOM("(lambda"), S.ATOM(Environ.printLVar lvar),
		  S.ATOM("."), decodelambda lambda, S.ATOM(")")]
      | Lambda.LETREC                  (* allows recursive definitions *)
	(lvar_list, lambda_list, lambda)
	=> raise(not_done_yet("Dunno how to deal with Lambda.LETREC"))
      | Lambda.APP (lambda_fn, lambda_arg) (* function application *)
	=> S.list[S.ATOM("("), decodelambda lambda_fn,
		  decodelambda lambda_arg, S.ATOM(")")]
      | Lambda.SCON (scon)             (* int, real, string ... *)
	=> S.list[S.ATOM("SCON("), S.ATOM (IP.printSCon scon), S.ATOM(")")]
      | Lambda.SWITCH                  (* like a case statement *)
	(lambda, c_lambda_list, lambda_opt) =>
	S.list[S.ATOM("SWITCH("), decodelambda lambda,

	  case lambda_opt of Lambda.ABSENT => S.NIL
	  | Lambda.PRESENT(lam) => decodelambda lam,
	    S.ATOM(")")]

      | Lambda.STRUCT (lambda_list)    (* structure definition *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.STRUCT"))
      | Lambda.SELECT (inti, lambda)   (* field selector *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.SELECT"))
      | Lambda.RAISE (lambda)          (* Exceptions --- throw ... *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.RAISE"))
      | Lambda.HANDLE (lambda1, lambda2)(*            ... and catch *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.HANDLE"))
      | Lambda.BUILTIN (primitive)     (* built-in functions --
					These functions are
					primitive to the abstract
					machine. *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.BUILTIN"))
    end
*)
    fun printenv x = printSexpr (decodeenv x)
d62 2
@
