head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.3
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.23
	MLWorks_20b2_Windows_1998_06_12:1.23
	MLWorks_20b1c1_1998_05_07:1.23
	MLWorks_20b0_1998_04_07:1.23
	MLWorks_20b0_1998_03_20:1.23
	MLWorks_20m2_1998_02_16:1.23
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.22.1.1.1.1.1
	MLWorks_workspace_97:1.23.2
	MLWorks_dt_wizard:1.23.1
	MLWorks_11c0_1997_09_09:1.22.1.1.1.1
	MLWorks_10r3:1.22.1.1.3
	MLWorks_10r2_551:1.22.1.1.2
	MLWorks_11:1.22.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.22.1.1
	MLWorks_20m0_1997_06_20:1.23
	MLWorks_1_0_r2c2_1997_06_14:1.22.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.22.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.22.1
	MLWorks_BugFix_1997_04_24:1.22
	MLWorks_1_0_r2_Win32_1997_04_11:1.22
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.3.1.1
	MLWorks_gui_1996_12_18:1.17.4
	MLWorks_1_0_Win32_1996_12_17:1.17.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.1.1
	MLWorks_1_0_Irix_1996_11_28:1.17.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.2
	MLWorks_1_0_Unix_1996_11_14:1.17.1
	MLWorks_Open_Beta2_1996_10_11:1.15.3
	MLWorks_License_dev:1.15.2
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15;
locks; strict;
comment	@ * @;


1.23
date	97.05.19.10.59.37;	author jont;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1;
next	1.22;

1.22
date	97.02.13.11.41.57;	author matthew;	state Exp;
branches
	1.22.1.1;
next	1.21;

1.21
date	97.02.12.13.55.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	97.01.10.17.18.08;	author andreww;	state Exp;
branches;
next	1.19;

1.19
date	97.01.06.16.39.33;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	96.12.18.16.10.49;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	96.10.31.16.31.05;	author io;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1;
next	1.16;

1.16
date	96.10.31.16.08.45;	author io;	state Exp;
branches;
next	1.15;

1.15
date	96.05.07.10.51.38;	author jont;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1;
next	1.14;

1.14
date	96.04.30.16.34.08;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.09.21.12.13.43;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.09.13.14.43.38;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.09.11.10.52.41;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.09.01.15.00.32;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	95.05.10.14.23.42;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.04.28.14.23.53;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.04.27.15.35.00;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.02.28.13.10.08;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.01.18.15.42.55;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.01.10.10.54.20;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.10.12.10.59.58;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	94.10.10.16.24.53;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	94.09.23.14.54.53;	author matthew;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.17.01;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.10.07.16.06.48;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.10.17.11.25.05;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.11.14.12.50.01;	author hope;	state Exp;
branches
	1.17.1.1.1.1;
next	;

1.17.1.1.1.1
date	96.11.28.15.01.11;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.11.22.18.09.30;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.12.17.17.48.09;	author hope;	state Exp;
branches
	1.17.3.1.1.1;
next	;

1.17.3.1.1.1
date	97.02.24.11.38.00;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.12.18.09.42.11;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	97.05.12.10.34.39;	author hope;	state Exp;
branches
	1.22.1.1.1.1
	1.22.1.1.2.1
	1.22.1.1.3.1;
next	;

1.22.1.1.1.1
date	97.07.28.18.19.57;	author daveb;	state Exp;
branches
	1.22.1.1.1.1.1.1;
next	;

1.22.1.1.1.1.1.1
date	97.10.07.11.45.06;	author jkbrook;	state Exp;
branches;
next	;

1.22.1.1.2.1
date	97.09.08.17.13.31;	author daveb;	state Exp;
branches;
next	;

1.22.1.1.3.1
date	97.09.09.14.09.12;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	97.09.10.19.24.45;	author brucem;	state Exp;
branches;
next	;

1.23.2.1
date	97.09.11.20.55.20;	author daveb;	state Exp;
branches;
next	;

1.23.3.1
date	99.04.01.17.57.05;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.23
log
@[Bug #30090]
Translate output std_out to print
@
text
@(*
 * $Log: _transsimple.sml,v $
 * Revision 1.22  1997/02/13  11:41:57  matthew
 * Fixing bungle with nulltype in last change
 *
 * Revision 1.21  1997/02/12  13:55:17  matthew
 * Removing trans_lamb
 *
 * Revision 1.20  1997/01/10  17:18:08  andreww
 * [Bug #1818]
 * Copying optimizations for bytearray builtins to make
 * optimizations for floatarray builtins.
 *
 * Revision 1.19  1997/01/06  16:39:33  jont
 * [Bug #1633]
 * Add copyright message
 *
 * Revision 1.18  1996/12/18  16:10:49  matthew
 * Removing BUILTINAPP
 *
 * Revision 1.17  1996/10/31  16:31:05  io
 * [Bug #1614]
 * remove ListPair
 *
 * Revision 1.16  1996/10/31  16:08:45  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.15  1996/05/07  10:51:38  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.14  1996/04/30  16:34:08  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.13  1995/09/21  12:13:43  matthew
 * Possibly improving partitioning of mutually recursive function sets.
 *
 * Revision 1.12  1995/09/13  14:43:38  matthew
 * Reducing the size of shared closures.
 *
 * Revision 1.11  1995/09/11  10:52:41  daveb
 * Replaced use of utils.option with MLWorks.Option in lamdatypes.
 *
 * Revision 1.10  1995/09/01  15:00:32  jont
 * Improve bounds checking for array sub and update
 *
 * Revision 1.9  1995/05/10  14:23:42  matthew
 * Change <Builtin O> to <Builtin o>
 *
 * Revision 1.8  1995/04/28  14:23:53  matthew
 * Adding map f l => umap (f,l) transform
 *
 * Revision 1.7  1995/04/27  15:35:00  jont
 * Fix require statements and comments
 *
 * Revision 1.6  1995/02/28  13:10:08  matthew
 * Changes to RuntimeEnv.FunInfo
 *
 * Revision 1.5  1995/01/18  15:42:55  matthew
 * Added some extra transformations to cope with the situation where
 * no optimization is done.
 *
 * Revision 1.4  1995/01/10  10:54:20  matthew
 * Adding strings to VCC_TAG and IMM_TAG
 * Adding MLVALUE
 *
 * Revision 1.3  1994/10/12  10:59:58  matthew
 * Renamed simpletypes to simplelambdatypes
 *
 * Copyright (c) 1997 Harlequin Ltd.
 *)

require "../utils/lists";
require "../utils/crash";
require "../main/pervasives";
require "simpleutils";
require "transsimple";

functor TransSimple ( structure Lists : LISTS
		      structure Crash : CRASH
                      structure SimpleUtils : SIMPLEUTILS
                      structure Pervasives : PERVASIVES

                      sharing type SimpleUtils.LambdaTypes.Primitive = Pervasives.pervasive
                     ) : TRANSSIMPLE =

  struct
    structure LambdaTypes = SimpleUtils.LambdaTypes

    structure Ident = LambdaTypes.Ident
    structure Location = Ident.Location

    structure Array = MLWorks.Internal.Array

    open LambdaTypes

    val do_diag = true
    val diag_level = 1

    fun diag (level,f) = 
      if do_diag andalso level < diag_level then print(f()) else ()

    (* The transformation back from program to expression *)

    fun make_app (e1,e2,ty) =
      APP (e1,([e2],[]),ty)

    fun make_closure_ty ty = NONE

    fun make_builtin_call (b,e,ty) =
      APP (BUILTIN b,([e],[]),ty)

    fun trans_back exp =
      case exp of
        VAR n => VAR n
      | FN stuff => trans_fun stuff
      | LET ((n,info,e1),e2) => LET ((n,info,trans_back e1),trans_back e2)
      | LETREC (fl,el,e) => LETREC (fl,map trans_back el,trans_back e)
      | APP (BUILTIN Pervasives.CALL_C,([e],[]),ty) =>
          APP (BUILTIN Pervasives.CALL_C,([trans_back e],[]),ty)
      | APP (BUILTIN b,([e],[]),ty) => make_builtin_call (b,trans_back e,ty)
      (* back end can only cope with applications of builtins to single arguments *)
      | APP (BUILTIN b,(el,[]),ty) => make_builtin_call (b,STRUCT (map trans_back el,TUPLE),ty)
      | APP (BUILTIN b, (el,_),ty) => Crash.impossible "fp regs in app builtin"
      | APP (f,(el,fpel),ty) => 
          APP (trans_back f,(map trans_back el, map trans_back fpel), ty)
      | SCON scon => SCON scon
      | MLVALUE mlvalue => MLVALUE mlvalue
      | INT i => INT i
      (* The poor wee mir translator can't cope with switches on literals *)
      | SWITCH (INT i,info,tel,opte) =>
          let
            fun find_case ([],NONE) = Crash.impossible "trans_simple: No application case in switch"
              | find_case ([],SOME e) = e
              | find_case ((IMM_TAG (_,j),e)::rest,opte) =
                if i = j then e else find_case (rest,opte)
              | find_case ((tag,e)::rest,opte) =
                find_case (rest,opte)
          in
            trans_back (find_case (tel,opte))
          end
      | SWITCH (e,info,tel,opte) => 
          let
            fun trans_choice (tag,e) =
              let 
                val tag' = 
                  case tag of
                    VCC_TAG i => VCC_TAG i
                  | IMM_TAG i => IMM_TAG i
                  | SCON_TAG scon => SCON_TAG scon
                  | EXP_TAG exp => EXP_TAG (trans_back exp)
              in
                (tag',trans_back e)
              end
            fun trans_opte NONE = NONE
              | trans_opte (SOME e) = SOME (trans_back e)
          in
            SWITCH (trans_back e,
                    info,
                    map trans_choice tel,
                    trans_opte opte)
          end
      | STRUCT (expl,ty) =>
          STRUCT (map trans_back expl, ty)
      | SELECT ({index,size,selecttype},exp) => 
          SELECT ({index = index,
                   size = size,
                   selecttype = selecttype},
                  trans_back exp)
      | RAISE exp => RAISE (trans_back exp)
      | HANDLE (exp1,exp2,s) => HANDLE (trans_back exp1,trans_back exp2,s)
      | BUILTIN b => BUILTIN b
    and trans_fun (args,body,status,name,ty,info) =
      FN (args,trans_back body,status, name,ty,info)
      
    fun make_functor (arg,name,body) = 
      FN (([arg],[]),body,FUNC, name,null_type_annotation,user_funinfo)
    
    fun stuff_body (args,body,status,name,ty,info) = body

    fun trans_decs ([],e) = trans_back e
      | trans_decs ((i,info,VAL (FN stuff)) :: decs,body) =
        trans_fndecs (decs,body,[(i,info,stuff)])
      | trans_decs ((v,info,(VAL e)) :: decs,body) =
        LET ((v,info,trans_back e),trans_decs (decs,body))
      | trans_decs ((v,info,FUNCTOR (x,name,prog)) :: rest, body) =
        LET ((v,info,make_functor (x,name,trans_decs prog)),
                         trans_decs (rest,body))

(* do_funs is the function that converts a list of declarations of functions into a *)
(* suitable LETREC form *)
(* Three versions are offered for your delectation *)
(*
    and do_funs (body,acc) =
      let
        val acc = rev acc
        val ids = map #1 acc
        val infos = map #2 acc
        val bodies = map (trans_fun o #3) acc
      in
        LETREC (Lists.zip (ids,infos),bodies,body)
      end
*)

(*
    (* This needs to partition the functions in acc into mutually recursive sets *)
    (* or if not, use the above *)
    (* or do something really clever *)
    and do_funs (body,funs) =
      let
        (* funs is (id,info,stuff) list and is in reverse order *)
        val ids = map #1 funs
        fun find_forward_references (ids,[],acc) = acc
          | find_forward_references (ids,((id,info,stuff) :: rest),acc) =
            find_forward_references (id::ids,rest,
                                     (id,info,stuff,
                                      SimpleUtils.freevars (stuff_body stuff,id::ids)) :: acc)
        val augfuns = find_forward_references ([],funs,[])
        (* Now augfuns is in the correct order *)
        (* Each function needs to be in the same recursive set as any function that refers to it *)
        (* and is earlier in the ordering *)
        datatype 'a fnset = NONREC of 'a | REC of 'a list
        (* set auxiliaries *)
        fun add (item,list) = if Lists.member (item,list) then list else item :: list
        fun remove (item,list) =
          let
            fun aux ([],acc) = acc
              | aux (a::b,acc) =
                if a = item then aux (b,acc)
                else aux (b,a::acc)
          in
            aux (list,[])
          end
        fun union (list1,list2) =
          Lists.reducel (fn (l,x) => add (x,l)) (list1,list2)
        fun split (needed,current_set,[],acc) =
          (case current_set of
             [] => acc
           | _ => REC (rev current_set) :: acc)
          | split ([],current_set,(id,info,stuff,frefs) :: rest,acc) =
            (case current_set of
               [] =>
                 (case frefs of
                    [] => split ([],[],rest,NONREC (id,info,stuff) :: acc)
                  | _ => split (remove (id,frefs),[(id,info,stuff)],rest,acc))
             | _ =>
                 (* No more ids required for current set, so add it to acc *)
                 split ([],[],(id,info,stuff,frefs) :: rest, REC (rev current_set) :: acc))
          | split (needed,current_set,(id,info,stuff,frefs) :: rest,acc) =
            split (union (remove (id,needed),frefs),(id,info,stuff) :: current_set,rest,acc)

        (* fnsets are now in order of definition *)
        val fnsets = rev (split ([],[],augfuns,[]))

        fun make_decs [] = body
          | make_decs (NONREC (id,info,stuff) :: rest) =
            LET ((id,info,trans_fun stuff),
                             make_decs rest)
          | make_decs (REC l :: rest) =
            let
              val ids = map #1 l
              val infos = map #2 l
              val bodies = map trans_fun (map #3 l)
            in
              LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
            end
      in
        make_decs fnsets
      end
*)

    and do_funs (body,funs) =
      let
        (* funs is (id,info,stuff) list and is in reverse order *)
        val funs = rev funs
        val ids = map #1 funs
        val augfuns = map (fn (id,info,stuff) => (id,info,stuff,SimpleUtils.freevars (stuff_body stuff,ids))) funs
        fun partition sets =
          let
            (* sets is augfuns *)
            (* wish to partition into connected components *)
            val setarray = Array.arrayoflist sets
            val num_items = Array.length setarray
            (* This should be a binary search *)
            (* Returns the index of the item in the list *)
            fun find item =
              let
                fun aux n = 
                  if n >= num_items
                    then Crash.impossible "find item"
                  else if item = #1 (Array.sub (setarray,n))
                         then n
                       else aux (n+1)
              in
                aux 0
              end
            val leaders = Array.tabulate (num_items,fn n => n)
            fun leader i = Array.sub (leaders,i)
            val partitions = Array.tabulate (num_items,fn n => [n])
            fun partition i = Array.sub (partitions,i)
            (* leaders is the "representative" for each partition *)
            (* partitions contain the partition for each of the current leaders *)
            val canonical_sets =
              map (fn (item,a,b,itemlist) => (find item,map find itemlist)) sets
            (* merge two ordered sets, maintaining the order *)
            fun revapp (a::b) acc = revapp b (a::acc)
              | revapp [] acc = acc
            fun merge ([],rest,acc) = revapp acc rest
              | merge (rest,[],acc) = revapp acc rest
              | merge ((a::b),(c::d),acc) =
                if a < c then merge (b,c::d,a::acc)
                else merge (a::b,d,c::acc)
            fun doone (item1,itemlist) =
              app
              (fn item2 =>
               let
                 val l1 = leader item1
                 val l2 = leader item2
               in
                 if l1 = l2 then ()
                 else
                   let
                     val set = merge (partition l1, partition l2,[])
                   in
                     Array.update (partitions,l1,set);
                     app
                     (fn i => Array.update (leaders,i,l1))
                     set
                   end
               end)
              itemlist
            val set_them = app doone canonical_sets;
            val done = Array.array (num_items,false)
            fun foo (n,done,acc) =
              if n >= num_items then rev acc
              else
                let
                  val l = leader n
                in
                  if Lists.member (l,done)
                    then foo (n+1,done,acc)
                  else
                    foo (n+1,l::done,map (fn i => (Array.sub (setarray,i))) (partition l) :: acc)
                end
          in
            foo (0,[],[])
          end
        val partitions = partition augfuns
        datatype 'a fnset = NONREC of 'a | REC of 'a list
        val decsets = 
          map 
          (fn [(id,info,stuff,[])] => NONREC (id,info,stuff)
             | l => REC (map (fn (id,info,stuff,_) => (id,info,stuff)) l))
          partitions
        fun make_decs [] = body
          | make_decs (NONREC (id,info,stuff) :: rest) =
            LET ((id,info,trans_fun stuff),
                             make_decs rest)
          | make_decs (REC l :: rest) =
            let
              val ids = map #1 l
              val infos = map #2 l
              val bodies = map trans_fun (map #3 l)
            in
              LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
            end
      in
        make_decs decsets
      end

    and trans_fndecs ([],body,acc) = do_funs (trans_back body,acc)
      | trans_fndecs ((v,info,VAL (FN stuff)) :: decs,body,acc) =
        trans_fndecs (decs,body,(v,info,stuff) :: acc)
      | trans_fndecs (decs,body,acc) =
        do_funs (trans_decs (decs,body),acc)

    (* And finally *)
    fun trans_program (PROGRAM p) = trans_decs p

  end
@


1.23.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.23  1997/05/19  10:59:37  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.23.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.23  1997/05/19  10:59:37  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.23.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.23  1997/05/19  10:59:37  jont
 * [Bug #30090]
 * Translate output std_out to print
 *
@


1.22
log
@Fixing bungle with nulltype in last change
@
text
@d3 3
d104 1
a104 3
      if do_diag andalso level < diag_level  
        then MLWorks.IO.output(MLWorks.IO.std_out,f()) 
      else ()
@


1.22.1.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1997/02/13  11:41:57  matthew
 * Fixing bungle with nulltype in last change
 *
@


1.22.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.22.1.1  1997/05/12  10:34:39  hope
 * branched from 1.22
 *
@


1.22.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.22.1.1  1997/05/12  10:34:39  hope
 * branched from 1.22
 *
@


1.22.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.22.1.1  1997/05/12  10:34:39  hope
 * branched from 1.22
 *
@


1.22.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.22.1.1.1.1  1997/07/28  18:19:57  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21
log
@Removing trans_lamb
@
text
@d3 3
d110 1
a110 1
    fun make_closure_ty ty = nulltype
@


1.20
log
@[Bug #1818]
Copying optimizations for bytearray builtins to make
optimizations for floatarray builtins.
@
text
@d3 5
a83 1
  (* Preliminary and postliminary transformation before and after lambda optimization *)
a93 1
    val do_arrays = false
d102 1
a102 283
    val nulltype = NONE

    fun mkraiseexp e = RAISE (STRUCT ([BUILTIN e,STRUCT ([],TUPLE)],
                                      CONSTRUCTOR))

    fun lengthexp e = APP (BUILTIN Pervasives.LENGTH,([e],[]),nulltype)

    fun bytearray_lengthexp e =
      APP (BUILTIN Pervasives.BYTEARRAY_LENGTH,([e],[]),nulltype)

    fun floatarray_lengthexp e =
      APP (BUILTIN Pervasives.FLOATARRAY_LENGTH,([e],[]),nulltype)

    fun mkif (test,e1,e2) =
      SWITCH (test,SOME {num_vccs = 0,num_imms= 2},
              [((IMM_TAG ("true",1)),e1),
               ((IMM_TAG ("false",0)),e2)],
              NONE)

    val zeroexp = SCON (Ident.INT ("0",Location.UNKNOWN), NONE)

    fun compexp (comp,e1,e2) = 
      APP (BUILTIN comp,([STRUCT ([e1,e2],TUPLE)],[]),nulltype)

    fun tuple_select (index,size,e) = 
      SELECT ({index=index,size=size,selecttype=TUPLE},e)

    fun mk_fn (args,name,body) =
      FN ((args,[]),body,BODY,name,null_type_annotation,internal_funinfo)

    fun mk_let (var,exp,body) =
      LET ((var,NONE,exp),body)

    (* Expand the compose pervasive *)
    fun do_builtin Pervasives.O =
      let
        val _ = diag (2, fn() => "Doing compose\n")
        val fg = new_LVar ()
        val f = new_LVar ()
        val g = new_LVar ()
        val x = new_LVar ()
      in
        mk_fn ([fg],"<Builtin o>[]",
                mk_let (f,tuple_select (0,2,VAR fg),
                        mk_let (g, tuple_select(1,2,VAR fg),
                                mk_fn ([x],"<Builtin o>[]",
                                       APP (VAR f,([APP(VAR g,([VAR x],[]),nulltype)],[]),nulltype)))))
      end

      | do_builtin b = BUILTIN b

    (* Would it not be better to combine all this in do_builtin and
       allow inlining to do the rest *)

    (* Expand an application of various primitives *)
      
    (* subs and updates have explicit range checks put in *)
    (* These generally use unsigned comparisons, which is faster
       without other optimizations, but may make further analysis harder *)

    fun do_builtin_app (x,arg,ty) =
      if not do_arrays
        then APP (do_builtin x,([arg],[]),ty)
      else
        case x
          of Pervasives.SUB =>
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let
              (x, arg,
               mk_let (a,tuple_select(0,2,VAR x),
                       mk_let (i,tuple_select(1,2,VAR x),
                               mkif (compexp (Pervasives.WORDGE,VAR i,
                                              lengthexp (VAR a)),
                                     raiseexp,
                                     APP (BUILTIN Pervasives.UNSAFE_SUB,
                                          ([STRUCT ([VAR a,VAR i],TUPLE)],[]),
                                          ty)))))
            end
           | Pervasives.BYTEARRAY_SUB =>
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let 
              (x, arg,
               mk_let
                (a,tuple_select (0,2,VAR x),
                 mk_let (i,tuple_select (1,2,VAR x),
                         mkif (compexp (Pervasives.WORDGE,VAR i,
                                        bytearray_lengthexp (VAR a)),
                               raiseexp,
                               APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_SUB,
                                    ([STRUCT ([VAR a,VAR i],TUPLE)],[]),
                                    ty)))))
            end
           |  Pervasives.FLOATARRAY_SUB =>
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let 
              (x, arg,
               mk_let 
                (a,tuple_select (0,2,VAR x),
                 mk_let (i,tuple_select (1,2,VAR x),
                         mkif (compexp (Pervasives.WORDGE,VAR i,
                                        floatarray_lengthexp (VAR a)),
                               raiseexp,
                               APP (BUILTIN Pervasives.FLOATARRAY_UNSAFE_SUB,
                                    ([STRUCT ([VAR a,VAR i],TUPLE)],[]),
                                    ty)))))
            end
      | Pervasives.UPDATE => 
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val y = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let
              (x, arg,
               mk_let
                (i,tuple_select(1,3,VAR x),
                 mk_let (a,tuple_select (0,3,VAR x),
                         mk_let (y,tuple_select (2,3,VAR x),
                                 mkif (compexp (Pervasives.WORDGE,VAR i,
                                                lengthexp (VAR a)),
                                       raiseexp,
                                       APP (BUILTIN Pervasives.UNSAFE_UPDATE,
                                            ([STRUCT ([VAR a,VAR i,VAR y],
                                                      TUPLE)],[]),
                                            ty))))))
            end
        | Pervasives.BYTEARRAY_UPDATE =>
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val y = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let
              (x, arg,
               mk_let
               (i,tuple_select (1,3,VAR x),
                mk_let
                (a,tuple_select (0,3,VAR x),
                 mk_let (y,tuple_select (2,3,VAR x),
                         mkif (compexp (Pervasives.WORDGE,VAR i,
                                        bytearray_lengthexp (VAR a)),
                               raiseexp,
                               APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_UPDATE,
                                    ([STRUCT ([VAR a,VAR i,VAR y],TUPLE)],[]),
                                    ty))))))
            end
        | Pervasives.FLOATARRAY_UPDATE =>
            let
              val x = new_LVar ()
              val a = new_LVar ()
              val i = new_LVar ()
              val y = new_LVar ()
              val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
            in
              mk_let
              (x, arg,
               mk_let
               (i,tuple_select (1,3,VAR x),
                mk_let
                (a,tuple_select (0,3,VAR x),
                 mk_let
                   (y,tuple_select (2,3,VAR x),
                    mkif (compexp (Pervasives.WORDGE,VAR i,
                                   floatarray_lengthexp (VAR a)),
                          raiseexp,
                          APP (BUILTIN Pervasives.FLOATARRAY_UNSAFE_UPDATE,
                               ([STRUCT ([VAR a,VAR i,VAR y],TUPLE)],[]),
                               ty))))))
            end
        | b => APP (do_builtin b,([arg],[]),ty)
            


    fun trans_lamb exp =
      case exp of
        VAR lvar => VAR lvar
      (* The type_info is the type of the function *)
      | FN (args,exp,status,name,type_info,debug) => 
          FN (args,trans_lamb exp,status,name,type_info,debug)
      | LET ((lvar,info,exp1),exp2) => 
          LET ((lvar,info,trans_lamb exp1),trans_lamb exp2)

      (* type info is in the FNs in the explist *)
      | LETREC (varinfol,explist,exp) =>
          LETREC (varinfol,
                  map trans_lamb explist,
                  trans_lamb exp)
      (* Maybe we should do this later *)
      | APP (APP (BUILTIN Pervasives.MAP,
                  ([exp1],[]),
                  type_info1),
             ([exp2],[]),type_info2) =>
          (* and we should try and get the type information correct *)
          trans_lamb (APP (BUILTIN Pervasives.UMAP,
                           ([STRUCT([exp1,exp2],TUPLE)],[]),
                           type_info2))

      (* The type info is the type of the argument *)
      | APP (BUILTIN b,([exp2],[]),type_info) =>
          do_builtin_app (b,trans_lamb exp2,type_info)

      (* This should be done elsewhere now *)
(*
      (* Inline non-debugging APP funs *)
      (* Perhaps this should propagate type information *)
      | APP (FN (([x],[]),body,name,ty,_),
                         ([exp],[]),
                         type_info) =>
        trans_lamb (LET ((x,NONE,exp),body))
*)
      | APP (exp1,(el,fpel),type_info) =>
          APP (trans_lamb exp1,(map trans_lamb el,map trans_lamb fpel),type_info)
      | SCON scon => SCON scon
      | MLVALUE mlvalue => MLVALUE mlvalue
      | INT i => INT i
      | SWITCH (exp,info,tagexpl,elseexp) =>
          (* This is a nasty HACK put here because the variable debugger *)
          (* switches off lambda optimization and mir_cg can't cope with the *)
          (* incomplete switches produced by the match translator *)
          (case (tagexpl,elseexp) of
             ([(tag,tagexp)],NONE) =>
               let
                 val new_var = new_LVar ()
                 val new_exp = LET ((new_var,NONE,exp),tagexp)
               in
                 trans_lamb (new_exp)
               end
           | _ =>
               SWITCH (trans_lamb exp,
                       info,
                       map (fn (tag,exp) => (trans_tag tag,trans_lamb exp)) tagexpl,
                       case elseexp of 
                         SOME e => SOME (trans_lamb e)
                       | NONE => NONE))

(* This is left over from experiment with intermodule optimizations *)
(*
      | STRUCT (expl,STRUCTURE) => STRUCT (map (fn e => STRUCT ([e,INT 0],TUPLE)) (map trans_lamb expl),STRUCTURE)
*)
      | STRUCT (expl,ty) => STRUCT (map trans_lamb expl,ty)

(* This is left over from experiment with intermodule optimizations *)
(*
      | SELECT ({index,size,selecttype=STRUCTURE},exp) => tuple_select (0,2,SELECT (index,size,STRUCTURE,trans_lamb exp))
*)
      | SELECT ({index,size,selecttype},exp) => 
             SELECT ({index=index,
                      size = size,
                      selecttype = selecttype},
                     trans_lamb exp)
      | RAISE exp => RAISE (trans_lamb exp)
      | HANDLE (exp1,exp2,s) => HANDLE (trans_lamb exp1,trans_lamb exp2,s)
      | BUILTIN b => do_builtin b
          
    and trans_tag tag =
      case tag of
        VCC_TAG i => VCC_TAG i
      | IMM_TAG i => IMM_TAG i
      | SCON_TAG scon => SCON_TAG scon
      | EXP_TAG exp => EXP_TAG (trans_lamb exp)

    (* end of preliminary transformation *)

    (* And the postliminary transformation back *)
@


1.19
log
@[Bug #1633]
Add copyright message
@
text
@d3 4
d90 1
d101 2
a102 1
    fun mkraiseexp e = RAISE (STRUCT ([BUILTIN e,STRUCT ([],TUPLE)],CONSTRUCTOR))
d106 5
a110 1
    fun bytearray_lengthexp e = APP (BUILTIN Pervasives.BYTEARRAY_LENGTH,([e],[]),nulltype)
d123 2
a124 1
    fun tuple_select (index,size,e) = SELECT ({index=index,size=size,selecttype=TUPLE},e)
d150 2
a151 2
    (* Would it not be better to combine all this in do_builtin and allow inlining *)
    (* to do the rest *)
d156 134
a289 72
    (* These generally use unsigned comparisons, which is faster without other *)
    (* optimizations, but may make further analysis harder *)
    fun do_builtin_app (Pervasives.SUB,arg,ty) =
      let
        val x = new_LVar ()
        val a = new_LVar ()
        val i = new_LVar ()
        val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
      in
        mk_let (x, arg,
                mk_let (a,tuple_select(0,2,VAR x),
                        mk_let (i,tuple_select(1,2,VAR x),
                                mkif (compexp (Pervasives.WORDGE,VAR i,lengthexp (VAR a)),
                                      raiseexp,
				      APP (BUILTIN Pervasives.UNSAFE_SUB,
					   ([STRUCT ([VAR a,VAR i],TUPLE)],[]),
					   ty)))))
      end
      |  do_builtin_app (Pervasives.BYTEARRAY_SUB,arg,ty) =
      let
        val x = new_LVar ()
        val a = new_LVar ()
        val i = new_LVar ()
        val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
      in
        mk_let (x, arg,
                mk_let (a,tuple_select (0,2,VAR x),
                        mk_let (i,tuple_select (1,2,VAR x),
                                mkif (compexp (Pervasives.WORDGE,VAR i,bytearray_lengthexp (VAR a)),
                                      raiseexp,
				      APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_SUB,
					   ([STRUCT ([VAR a,VAR i],TUPLE)],[]),
					   ty)))))
      end
      | do_builtin_app (Pervasives.UPDATE,arg,ty) =
      let
        val x = new_LVar ()
        val a = new_LVar ()
        val i = new_LVar ()
        val y = new_LVar ()
        val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
      in
        mk_let (x, arg,
                mk_let (i,tuple_select(1,3,VAR x),
                        mk_let (a,tuple_select (0,3,VAR x),
                                mk_let (y,tuple_select (2,3,VAR x),
                                        mkif (compexp (Pervasives.WORDGE,VAR i,lengthexp (VAR a)),
					      raiseexp,
					      APP (BUILTIN Pervasives.UNSAFE_UPDATE,
						   ([STRUCT ([VAR a,VAR i,VAR y],TUPLE)],[]),
						   ty))))))
      end
      | do_builtin_app (Pervasives.BYTEARRAY_UPDATE,arg,ty) =
      let
        val x = new_LVar ()
        val a = new_LVar ()
        val i = new_LVar ()
        val y = new_LVar ()
        val raiseexp = mkraiseexp Pervasives.EXSUBSCRIPT
      in
        mk_let (x, arg,
                mk_let (i,tuple_select (1,3,VAR x),
                        mk_let (a,tuple_select (0,3,VAR x),
                                mk_let (y,tuple_select (2,3,VAR x),
                                        mkif (compexp (Pervasives.WORDGE,VAR i,bytearray_lengthexp (VAR a)),
                                              raiseexp,
					      APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_UPDATE,
						   ([STRUCT ([VAR a,VAR i,VAR y],TUPLE)],[]),
						   ty))))))
      end
       | do_builtin_app (b,arg,ty) =
        APP (do_builtin b,([arg],[]),ty)
@


1.18
log
@Removing BUILTINAPP
@
text
@d2 4
a5 1
$Log: _transsimple.sml,v $
d58 3
a60 1
*)
@


1.17
log
@[Bug #1614]
remove ListPair
@
text
@d3 4
a55 1
require "^.basis.__string";
d67 1
a67 2
                      sharing type SimpleUtils.SimpleTypes.LambdaTypes.LVar = SimpleUtils.SimpleTypes.var
                      sharing type SimpleUtils.SimpleTypes.LambdaTypes.Primitive = Pervasives.pervasive
d70 1
a70 1
  (* Translation to simple lambda calculus *)
d72 1
a72 2
    structure SimpleTypes = SimpleUtils.SimpleTypes
    structure LambdaTypes = SimpleTypes.LambdaTypes
d77 1
a77 1
    val do_tupling = true
d79 1
a79 1
    val max_no_args = 5
d81 2
a82 2
    open SimpleTypes
    open MLWorks.Option
d84 4
a87 1
    val diag_level = 0
a88 9
    fun diag (level,f) = if level < diag_level  then MLWorks.IO.output(MLWorks.IO.std_out,f()) else ()

    fun is_functor name =
      if String.isPrefix "Functor " name
        then
          FUNC
      else
        BODY
        
d93 1
a93 1
    fun lengthexp e = APP (BUILTIN Pervasives.LENGTH,[e],nulltype)
d95 1
a95 1
    fun bytearray_lengthexp e = APP (BUILTIN Pervasives.BYTEARRAY_LENGTH,[e],nulltype)
d106 1
a106 1
      APP (BUILTIN comp,[STRUCT ([e1,e2],TUPLE)],nulltype)
d111 1
a111 1
      FN (args,body,BODY,name,LambdaTypes.null_type_annotation,LambdaTypes.internal_funinfo)
d116 1
d120 4
a123 4
        val fg = new_valid ()
        val f = new_valid ()
        val g = new_valid ()
        val x = new_valid ()
d128 2
a129 1
                                mk_fn ([x],"<Builtin o>[]",APP (VAR f,[APP(VAR g,[VAR x],nulltype)],nulltype)))))
d134 8
d144 3
a146 3
        val x = new_valid ()
        val a = new_valid ()
        val i = new_valid ()
d155 1
a155 1
					   [STRUCT ([VAR a,VAR i],TUPLE)],
d160 3
a162 3
        val x = new_valid ()
        val a = new_valid ()
        val i = new_valid ()
d171 1
a171 1
					   [STRUCT ([VAR a,VAR i],TUPLE)],
d176 4
a179 4
        val x = new_valid ()
        val a = new_valid ()
        val i = new_valid ()
        val y = new_valid ()
d189 1
a189 1
						   [STRUCT ([VAR a,VAR i,VAR y],TUPLE)],
d194 4
a197 4
        val x = new_valid ()
        val a = new_valid ()
        val i = new_valid ()
        val y = new_valid ()
d207 1
a207 1
						   [STRUCT ([VAR a,VAR i,VAR y],TUPLE)],
d211 1
a211 8
        APP (do_builtin b,[arg],ty)

    fun trans_info NONE = NONE
      | trans_info (SOME i) = SOME i

    fun trans_structtype LambdaTypes.TUPLE = TUPLE
      | trans_structtype LambdaTypes.CONSTRUCTOR = CONSTRUCTOR
      | trans_structtype LambdaTypes.STRUCTURE = STRUCTURE
d213 1
a213 1
    and trans_lamb exp =
d215 1
a215 1
        LambdaTypes.VAR lvar => VAR lvar
d217 3
a219 3
      | LambdaTypes.FN (lvarlist,exp,name,type_info,debug) => 
          FN (lvarlist,trans_lamb exp,is_functor name,name,type_info,debug)
      | LambdaTypes.LET ((lvar,info,exp1),exp2) => 
d221 1
d223 1
a223 1
      | LambdaTypes.LETREC (varinfol,explist,exp) =>
d228 8
a235 8
      | LambdaTypes.APP (LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.MAP,
                                          [exp1],
                                          type_info1),
                         [exp2],type_info2) =>
        (* and we should try and get the type information correct *)
        trans_lamb (LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.UMAP,
                                     [LambdaTypes.STRUCT([exp1,exp2],LambdaTypes.TUPLE)],
                                     type_info2))
d238 2
a239 2
      | LambdaTypes.APP (LambdaTypes.BUILTIN b,[exp2],type_info) =>
          do_builtin_app (b,trans_lamb exp2,trans_info type_info)
d245 2
a246 2
      | LambdaTypes.APP (LambdaTypes.FN ([x],body,name,ty,NONE),
                         [exp],
d248 1
a248 1
        trans_lamb (LambdaTypes.LET ((x,NONE,exp),body))
d250 6
a255 6
      | LambdaTypes.APP (exp1,el,type_info) =>
          APP (trans_lamb exp1,map trans_lamb el,trans_info type_info)
      | LambdaTypes.SCON scon => SCON scon
      | LambdaTypes.MLVALUE mlvalue => MLVALUE mlvalue
      | LambdaTypes.INT i => INT i
      | LambdaTypes.SWITCH (exp,info,tagexpl,elseexp) =>
d258 1
a258 1
          (* simplified switches produced by the match translator *)
d262 2
a263 2
                 val new_var = LambdaTypes.new_LVar ()
                 val new_exp = LambdaTypes.LET ((new_var,NONE,exp),tagexp)
d269 1
a269 1
                       trans_info info,
d274 2
d277 1
a277 1
      | LambdaTypes.STRUCT (expl,LambdaTypes.STRUCTURE) => STRUCT (map (fn e => STRUCT ([e,INT 0],TUPLE)) (map trans_lamb expl),STRUCTURE)
d279 3
a281 1
      | LambdaTypes.STRUCT (expl,ty) => STRUCT (map trans_lamb expl,trans_structtype ty)
d283 1
a283 1
      | LambdaTypes.SELECT ({index,size,selecttype=LambdaTypes.STRUCTURE},exp) => tuple_select (0,2,SELECT (index,size,STRUCTURE,trans_lamb exp))
d285 8
a292 5
      | LambdaTypes.SELECT ({index,size,selecttype},exp) => 
          SELECT ({index=index,size=size,selecttype=trans_structtype selecttype},trans_lamb exp)
      | LambdaTypes.RAISE exp => RAISE (trans_lamb exp)
      | LambdaTypes.HANDLE (exp1,exp2,s) => HANDLE (trans_lamb exp1,trans_lamb exp2,s)
      | LambdaTypes.BUILTIN b => do_builtin b
d296 4
a299 4
        LambdaTypes.VCC_TAG i => VCC_TAG i
      | LambdaTypes.IMM_TAG i => IMM_TAG i
      | LambdaTypes.SCON_TAG scon => SCON_TAG scon
      | LambdaTypes.EXP_TAG exp => EXP_TAG (trans_lamb exp)
d301 1
a301 4
    (* And the translation back *)
          
    fun make_app (e1,e2,ty) =
      LambdaTypes.APP (e1,[e2],ty)
d303 1
a303 2
    fun trans_type_back NONE = NONE
      | trans_type_back (SOME t) = SOME t
d305 2
a306 6
    fun trans_back_info NONE = NONE
      | trans_back_info (SOME i) = SOME i

    fun trans_back_structtype TUPLE = LambdaTypes.TUPLE
      | trans_back_structtype CONSTRUCTOR = LambdaTypes.CONSTRUCTOR
      | trans_back_structtype STRUCTURE = LambdaTypes.STRUCTURE
d311 1
a311 22
      LambdaTypes.APP (LambdaTypes.BUILTIN b,[e],trans_type_back ty)

    fun wrap_selects (e,var,varlist) =
      let
        val len = length varlist
        fun doit (i,[]) = e
          | doit (i,x::xl) =
            LambdaTypes.LET ((x, NONE,
                              LambdaTypes.SELECT ({index=i,size=len,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR var)),
                             doit (i+1,xl))
      in
        doit (0,varlist)
      end

    fun ensure_fun (e as FN _) = e
      | ensure_fun e =
        let
          val lvar = LambdaTypes.new_LVar ()
        in
          FN([lvar], APP(e, [VAR lvar], NONE),
	    BODY,"",LambdaTypes.null_type_annotation,LambdaTypes.internal_funinfo)
        end
d315 1
a315 1
        VAR n => LambdaTypes.VAR n
d317 13
a329 12
      | LET ((n,info,e1),e2) => LambdaTypes.LET ((n,info,trans_back e1),trans_back e2)
      (* Check for expressions that need eta-abstraction here *)
      | LETREC (fl,el,e) => LambdaTypes.LETREC (fl,map (trans_back o ensure_fun) el,trans_back e)
      | APP (f,[e],ty) => 
          LambdaTypes.APP (trans_back f,[trans_back e],trans_type_back ty)
      | APP (f,el,ty) => 
          if do_tupling
            then LambdaTypes.APP (trans_back f,map trans_back el,trans_type_back ty)
          else LambdaTypes.APP (trans_back f,[LambdaTypes.STRUCT (map trans_back el,LambdaTypes.TUPLE)],trans_type_back ty)
      | SCON scon => LambdaTypes.SCON scon
      | MLVALUE mlvalue => LambdaTypes.MLVALUE mlvalue
      | INT i => LambdaTypes.INT i
d348 4
a351 4
                    VCC_TAG i => LambdaTypes.VCC_TAG i
                  | IMM_TAG i => LambdaTypes.IMM_TAG i
                  | SCON_TAG scon => LambdaTypes.SCON_TAG scon
                  | EXP_TAG exp => LambdaTypes.EXP_TAG (trans_back exp)
d358 4
a361 4
            LambdaTypes.SWITCH (trans_back e,
                       trans_back_info info,
                       map trans_choice tel,
                       trans_opte opte)
d364 1
a364 1
          LambdaTypes.STRUCT (map trans_back expl,trans_back_structtype ty)
d366 7
a372 9
          LambdaTypes.SELECT ({index=index,size=size,selecttype=trans_back_structtype selecttype},trans_back exp)
      | RAISE exp => LambdaTypes.RAISE (trans_back exp)
      | HANDLE (exp1,exp2,s) => LambdaTypes.HANDLE (trans_back exp1,trans_back exp2,s)
      | BUILTIN b => LambdaTypes.BUILTIN b
      | BUILTINAPP (Pervasives.CALL_C,[e],ty) =>
          LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.CALL_C,[trans_back e],trans_type_back ty)
      | BUILTINAPP (b,[e],ty) => make_builtin_call (b,trans_back e,ty)
      | BUILTINAPP (b,el,ty) => make_builtin_call (b,LambdaTypes.STRUCT (map trans_back el,LambdaTypes.TUPLE),ty)

d374 1
a374 17
      (case args of
         (* Is this case really needed? No *)
(*
        [] => LambdaTypes.FN ([new_valid ()],trans_back body,name,ty,info)
      | 
*)
         [arg] => LambdaTypes.FN ([arg],trans_back body,name,ty,info)
      | _ =>
          if do_tupling
            then 
              LambdaTypes.FN (args,trans_back body,name,ty,info)
          else
            let
              val v = new_valid ()
            in
              LambdaTypes.FN ([v],wrap_selects (trans_back body,v,args),name,ty,info)
            end)
d377 1
a377 1
      LambdaTypes.FN ([arg],body,name,LambdaTypes.null_type_annotation,LambdaTypes.user_funinfo)
d385 1
a385 1
        LambdaTypes.LET ((v,info,trans_back e),trans_decs (decs,body))
d387 1
a387 1
        LambdaTypes.LET ((v,info,make_functor (x,name,trans_decs prog)),
d390 3
d401 1
a401 1
        LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,body)
d457 1
a457 1
            LambdaTypes.LET ((id,info,trans_fun stuff),
d465 1
a465 1
              LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
d482 2
a483 2
            val setarray = MLWorks.Internal.Array.arrayoflist sets
            val num_items = MLWorks.Internal.Array.length setarray
d491 1
a491 1
                  else if item = #1 (MLWorks.Internal.Array.sub (setarray,n))
d497 4
a500 4
            val leaders = MLWorks.Internal.Array.tabulate (num_items,fn n => n)
            fun leader i = MLWorks.Internal.Array.sub (leaders,i)
            val partitions = MLWorks.Internal.Array.tabulate (num_items,fn n => [n])
            fun partition i = MLWorks.Internal.Array.sub (partitions,i)
d525 1
a525 1
                     MLWorks.Internal.Array.update (partitions,l1,set);
d527 1
a527 1
                     (fn i => MLWorks.Internal.Array.update (leaders,i,l1))
d533 1
a533 1
            val done = MLWorks.Internal.Array.array (num_items,false)
d543 1
a543 1
                    foo (n+1,l::done,map (fn i => (MLWorks.Internal.Array.sub (setarray,i))) (partition l) :: acc)
d557 1
a557 1
            LambdaTypes.LET ((id,info,trans_fun stuff),
d565 1
a565 1
              LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
d577 1
@


1.17.4.1
log
@branched from 1.17
@
text
@a2 4
 * Revision 1.17  1996/10/31  16:31:05  io
 * [Bug #1614]
 * remove ListPair
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a2 4
 * Revision 1.17  1996/10/31  16:31:05  io
 * [Bug #1614]
 * remove ListPair
 *
@


1.17.3.1.1.1
log
@branched from 1.17.3.1
@
text
@a2 3
 * Revision 1.17.3.1  1996/12/17  17:48:09  hope
 * branched from 1.17
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a2 4
 * Revision 1.17  1996/10/31  16:31:05  io
 * [Bug #1614]
 * remove ListPair
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a2 4
 * Revision 1.17  1996/10/31  16:31:05  io
 * [Bug #1614]
 * remove ListPair
 *
@


1.17.1.1.1.1
log
@branched from 1.17.1.1
@
text
@a2 3
 * Revision 1.17.1.1  1996/11/14  12:50:01  hope
 * branched from 1.17
 *
@


1.16
log
@[Bug #1614]
basifying String
@
text
@d3 4
a52 1
require "^.basis.__list_pair";
d438 1
a438 1
        LambdaTypes.LETREC (ListPair.zip (ids,infos),bodies,body)
d502 1
a502 1
              LambdaTypes.LETREC (ListPair.zip (ids,infos),bodies,make_decs rest)
d602 1
a602 1
              LambdaTypes.LETREC (ListPair.zip (ids,infos),bodies,make_decs rest)
@


1.15
log
@Array moving to MLWorks.Array
@
text
@d3 3
d48 2
d57 1
a57 1
                      structure Crash : CRASH
a83 11
    fun check_prefix prefix name =
      if size name >= size prefix
        then
          if String.substring (name,0,size prefix) = prefix
            then
              true
          else
            false
      else
        false
        
d85 1
a85 1
      if check_prefix "Functor " name
d314 1
a314 1
        val len = Lists.length varlist
d435 1
a435 1
        LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,body)
d499 1
a499 1
              LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
d548 1
a548 1
              Lists.iterate
d560 1
a560 1
                     Lists.iterate
d566 1
a566 1
            val set_them = Lists.iterate doone canonical_sets;
d599 1
a599 1
              LambdaTypes.LETREC (Lists.zip (ids,infos),bodies,make_decs rest)
@


1.15.3.1
log
@branched from 1.15
@
text
@a2 3
 * Revision 1.15  1996/05/07  10:51:38  jont
 * Array moving to MLWorks.Array
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a2 3
 * Revision 1.15  1996/05/07  10:51:38  jont
 * Array moving to MLWorks.Array
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a2 3
 * Revision 1.15  1996/05/07  10:51:38  jont
 * Array moving to MLWorks.Array
 *
@


1.14
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d522 2
a523 2
            val setarray = Array.arrayoflist sets
            val num_items = Array.length setarray
d531 1
a531 1
                  else if item = #1 (Array.sub (setarray,n))
d537 4
a540 4
            val leaders = Array.tabulate (num_items,fn n => n)
            fun leader i = Array.sub (leaders,i)
            val partitions = Array.tabulate (num_items,fn n => [n])
            fun partition i = Array.sub (partitions,i)
d565 1
a565 1
                     Array.update (partitions,l1,set);
d567 1
a567 1
                     (fn i => Array.update (leaders,i,l1))
d573 1
a573 1
            val done = Array.array (num_items,false)
d583 1
a583 1
                    foo (n+1,l::done,map (fn i => (Array.sub (setarray,i))) (partition l) :: acc)
@


1.13
log
@Possibly improving partitioning of mutually recursive function sets.
@
text
@d3 3
d71 1
a71 1
    fun diag (level,f) = if level < diag_level  then output(std_out,f()) else ()
@


1.12
log
@Reducing the size of shared closures.
@
text
@d3 3
d430 1
a430 1
        val bodies = map #3 acc
d436 1
d500 100
@


1.11
log
@Replaced use of utils.option with MLWorks.Option in lamdatypes.
@
text
@d3 3
d410 2
d414 1
a414 1
        trans_fndecs (decs,body,[(i,info,trans_fun stuff)])
d421 1
d431 67
a497 1
    
d500 1
a500 1
        trans_fndecs (decs,body,(v,info,trans_fun stuff) :: acc)
@


1.10
log
@Improve bounds checking for array sub and update
@
text
@d3 3
a49 1
    structure Option = LambdaTypes.Option
d96 1
a96 1
    val zeroexp = SCON (Ident.INT ("0",Location.UNKNOWN))
d107 1
a107 1
      LET ((var,LambdaTypes.Option.ABSENT,exp),body)
d196 2
a197 5
    fun trans_info Option.ABSENT = NONE
      | trans_info (Option.PRESENT i) = SOME i

    fun trans_option (Option.SOME1 lvar) = lvar
      | trans_option (Option.SOME2 (lvar,_)) = lvar
d234 1
a234 1
      | LambdaTypes.APP (LambdaTypes.FN ([x],body,name,ty,Option.ABSENT),
d237 1
a237 1
        trans_lamb (LambdaTypes.LET ((x,Option.ABSENT,exp),body))
d249 1
a249 1
             ([(tag,tagexp)],Option.ABSENT) =>
d252 1
a252 1
                 val new_exp = LambdaTypes.LET ((new_var,Option.ABSENT,exp),tagexp)
d261 2
a262 2
                         Option.PRESENT e => SOME (trans_lamb e)
                       | Option.ABSENT => NONE))
d288 2
a289 2
    fun trans_type_back NONE = Option.ABSENT
      | trans_type_back (SOME t) = Option.PRESENT t
d291 2
a292 2
    fun trans_back_info NONE = Option.ABSENT
      | trans_back_info (SOME i) = Option.PRESENT i
d308 1
a308 1
            LambdaTypes.LET ((x, Option.ABSENT,
d365 2
a366 2
            fun trans_opte NONE = Option.ABSENT
              | trans_opte (SOME e) = Option.PRESENT (trans_back e)
@


1.9
log
@Change <Builtin O> to <Builtin o>
@
text
@d3 3
d133 1
a133 1
                                mkif (compexp (Pervasives.INTGREATEREQ,VAR i,lengthexp (VAR a)),
d135 3
a137 5
                                      mkif (compexp (Pervasives.INTLESS,VAR i,zeroexp),
                                            raiseexp,
                                            APP (BUILTIN Pervasives.UNSAFE_SUB,
                                                 [STRUCT ([VAR a,VAR i],TUPLE)],
                                                 ty))))))
d149 1
a149 1
                                mkif (compexp (Pervasives.INTGREATEREQ,VAR i,bytearray_lengthexp (VAR a)),
d151 3
a153 5
                                      mkif (compexp (Pervasives.INTLESS,VAR i,zeroexp),
                                            raiseexp,
                                            APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_SUB,
                                                 [STRUCT ([VAR a,VAR i],TUPLE)],
                                                 ty))))))
d167 5
a171 7
                                        mkif (compexp (Pervasives.INTGREATEREQ,VAR i,lengthexp (VAR a)),
                                              raiseexp,
                                              mkif (compexp (Pervasives.INTLESS,VAR i,zeroexp),
                                                    raiseexp,
                                                    APP (BUILTIN Pervasives.UNSAFE_UPDATE,
                                                         [STRUCT ([VAR a,VAR i,VAR y],TUPLE)],
                                                         ty)))))))
d185 1
a185 1
                                        mkif (compexp (Pervasives.INTGREATEREQ,VAR i,bytearray_lengthexp (VAR a)),
d187 3
a189 5
                                              mkif (compexp (Pervasives.INTLESS,VAR i,zeroexp),
                                                    raiseexp,
                                                    APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_UPDATE,
                                                         [STRUCT ([VAR a,VAR i,VAR y],TUPLE)],
                                                         ty)))))))
@


1.8
log
@Adding map f l => umap (f,l) transform
@
text
@d3 3
d112 1
a112 1
        mk_fn ([fg],"<Builtin O>[]",
d115 1
a115 1
                                mk_fn ([x],"<Builtin O>[]",APP (VAR f,[APP(VAR g,[VAR x],nulltype)],nulltype)))))
@


1.7
log
@Fix require statements and comments
@
text
@d3 3
d219 10
@


1.6
log
@Changes to RuntimeEnv.FunInfo
@
text
@d3 14
a16 11
# Revision 1.5  1995/01/18  15:42:55  matthew
# Added some extra transformations to cope with the situation where
# no optimization is done.
#
# Revision 1.4  1995/01/10  10:54:20  matthew
# Adding strings to VCC_TAG and IMM_TAG
# Adding MLVALUE
#
# Revision 1.3  1994/10/12  10:59:58  matthew
# Renamed simpletypes to simplelambdatypes
#
d18 3
a20 3
require "utils/lists";
require "utils/crash";
require "main/pervasives";
@


1.5
log
@Added some extra transformations to cope with the situation where
no optimization is done.
@
text
@d3 4
d90 1
a90 1
      FN (args,body,BODY,name,LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT)
d216 3
d225 1
d301 10
a310 1
    
d316 2
a317 1
      | LETREC (fl,el,e) => LambdaTypes.LETREC (fl,map trans_back el,trans_back e)
d391 2
a392 1
    fun make_functor (arg,name,body) = LambdaTypes.FN ([arg],body,name,LambdaTypes.null_type_annotation,Option.ABSENT)
@


1.4
log
@Adding strings to VCC_TAG and IMM_TAG
Adding MLVALUE
@
text
@d3 4
d12 1
d18 1
d99 1
a99 1
        mk_fn ([fg],"<Builtin O>",
d102 1
a102 1
                                mk_fn ([x],"<Builtin O>",APP (VAR f,[APP(VAR g,[VAR x],nulltype)],nulltype)))))
d212 6
d309 12
@


1.3
log
@Renamed simpletypes to simplelambdatypes
@
text
@d3 3
a39 4
    exception Error of string

    fun crash s = raise Error s

d68 2
a69 2
              [((IMM_TAG 1),e1),
               ((IMM_TAG 0),e2)],
d209 1
a209 1
      | LambdaTypes.MLVALUE _ => crash "Can't translate MLVALUE"
d212 18
a229 6
          SWITCH (trans_lamb exp,
                  trans_info info,
                  map (fn (tag,exp) => (trans_tag tag,trans_lamb exp)) tagexpl,
                  case elseexp of 
                    Option.PRESENT e => SOME (trans_lamb e)
                  | Option.ABSENT => NONE)
d245 2
a246 2
        LambdaTypes.VCC_TAG (_,i) => VCC_TAG i
      | LambdaTypes.IMM_TAG (_,i) => IMM_TAG i
d295 1
d303 2
a304 2
                    VCC_TAG i => LambdaTypes.VCC_TAG ("",i)
                  | IMM_TAG i => LambdaTypes.IMM_TAG ("",i)
@


1.2
log
@Lambdatypes changes
@
text
@d1 3
@


1.1
log
@new file
@
text
@d2 1
a3 1
require "lambdatypes";
d8 1
a8 1
                      structure LT : LAMBDATYPES
d10 2
a11 4
                      sharing type SimpleUtils.SimpleTypes.Type = LT.Type
                      sharing type LT.LVar = SimpleUtils.SimpleTypes.var = int
                      sharing type LT.Primitive = SimpleUtils.SimpleTypes.Pervasives.pervasive
                      sharing SimpleUtils.SimpleTypes.Ident = LT.Ident
d17 4
a20 3
    structure Option = LT.Option
    structure Pervasives = SimpleTypes.Pervasives
    structure Ident = LT.Ident
a22 2
    structure LambdaTypes = LT

a29 7
    fun ok_arglist el =
      let
        val len = Lists.length el
      in
        len <= max_no_args
      end

a37 5
    exception Zip4
    fun zip4 ([],[],[],[],acc) = rev acc
      | zip4 ((a::b),(c::d),(e::f),(g::h),acc) = zip4 (b,d,f,h,(a,c,e,g)::acc)
      | zip4 _ = raise Zip4
        
d58 1
a58 1
    fun mkraiseexp e = RAISE (STRUCT [BOP e,STRUCT []])
d60 1
a60 1
    fun lengthexp e = APP (BOP Pervasives.LENGTH,[e],nulltype)
d62 1
a62 1
    fun bytearray_lengthexp e = APP (BOP Pervasives.BYTEARRAY_LENGTH,[e],nulltype)
d70 1
a70 1
    val zeroexp = SCONEXP (Ident.INT ("0",Location.UNKNOWN))
d73 3
a75 1
      APP (BOP comp,[STRUCT [e1,e2]],nulltype)
d77 7
a83 1
    fun do_bop Pervasives.O =
d91 4
a94 4
        FN ([fg],BODY,"<Builtin O>",
            LET (f,SELECT (0,2,VAREXP fg),
                 LET (g, SELECT (1,2,VAREXP fg),
                      FN([x],BODY,"<Builtin O>",APP (VAREXP f,[APP(VAREXP g,[VAREXP x],nulltype)],nulltype)))))
d97 1
a97 1
      | do_bop b = BOP b
d99 1
a99 1
    fun do_bop_app (Pervasives.SUB,arg,ty) =
d106 10
a115 10
        LET (x, arg,
             LET (a,SELECT (0,2,VAREXP x),
                  LET (i,SELECT (1,2,VAREXP x),
                       mkif (compexp (Pervasives.INTGREATEREQ,VAREXP i,lengthexp (VAREXP a)),
                             raiseexp,
                             mkif (compexp (Pervasives.INTLESS,VAREXP i,zeroexp),
                                   raiseexp,
                                   APP (BOP Pervasives.UNSAFE_SUB,
                                        [STRUCT [VAREXP a,VAREXP i]],
                                        ty))))))
d117 1
a117 1
      |  do_bop_app (Pervasives.BYTEARRAY_SUB,arg,ty) =
d124 10
a133 10
        LET (x, arg,
             LET (a,SELECT (0,2,VAREXP x),
                  LET (i,SELECT (1,2,VAREXP x),
                       mkif (compexp (Pervasives.INTGREATEREQ,VAREXP i,bytearray_lengthexp (VAREXP a)),
                             raiseexp,
                             mkif (compexp (Pervasives.INTLESS,VAREXP i,zeroexp),
                                   raiseexp,
                                   APP (BOP Pervasives.BYTEARRAY_UNSAFE_SUB,
                                        [STRUCT [VAREXP a,VAREXP i]],
                                        ty))))))
d135 1
a135 1
      | do_bop_app (Pervasives.UPDATE,arg,ty) =
d143 11
a153 11
        LET (x, arg,
             LET (i,SELECT (1,3,VAREXP x),
                  LET (a,SELECT (0,3,VAREXP x),
                       LET (y,SELECT (2,3,VAREXP x),
                            mkif (compexp (Pervasives.INTGREATEREQ,VAREXP i,lengthexp (VAREXP a)),
                                  raiseexp,
                                  mkif (compexp (Pervasives.INTLESS,VAREXP i,zeroexp),
                                        raiseexp,
                                        APP (BOP Pervasives.UNSAFE_UPDATE,
                                             [STRUCT [VAREXP a,VAREXP i,VAREXP y]],
                                             ty)))))))
d155 1
a155 1
      | do_bop_app (Pervasives.BYTEARRAY_UPDATE,arg,ty) =
d163 11
a173 11
        LET (x, arg,
             LET (i,SELECT (1,3,VAREXP x),
                  LET (a,SELECT (0,3,VAREXP x),
                       LET (y,SELECT (2,3,VAREXP x),
                            mkif (compexp (Pervasives.INTGREATEREQ,VAREXP i,bytearray_lengthexp (VAREXP a)),
                                  raiseexp,
                                  mkif (compexp (Pervasives.INTLESS,VAREXP i,zeroexp),
                                        raiseexp,
                                        APP (BOP Pervasives.BYTEARRAY_UNSAFE_UPDATE,
                                             [STRUCT [VAREXP a,VAREXP i,VAREXP y]],
                                             ty)))))))
d175 2
a176 2
       | do_bop_app (b,arg,ty) =
        APP (do_bop b,[arg],ty)
d183 5
a187 1
        
d190 1
a190 1
        LT.VAR lvar => VAREXP lvar
d192 4
a195 4
      | LT.FN (lvarlist,exp,name,type_info,_) => 
          FN (lvarlist, is_functor name,name,trans_lamb exp)
      | LT.LET (lvar,_,exp1,exp2) => 
          LET (lvar,trans_lamb exp1,trans_lamb exp2)
d197 4
a200 17
      | LT.LETREC (varinfol,explist,exp) =>
          let
            exception BadLetRec
            fun get_vars (LT.FN {1=lvarlist,...}) = lvarlist
              | get_vars _ = raise BadLetRec
            fun get_body (LT.FN {2=exp,...}) = exp
              | get_body _ = raise BadLetRec
            fun get_name (LT.FN {3=name,...}) = name
              | get_name _ = raise BadLetRec
          in
            LETREC (zip4 (map #1 varinfol,
                          map get_vars explist,
                          map get_name explist,
                          map trans_lamb (map get_body explist),
                          []),
                    trans_lamb exp)
          end
d202 3
a204 3
      | LT.APP (LT.BUILTIN b,[exp2],type_info) =>
          do_bop_app (b,trans_lamb exp2,trans_info type_info)
      | LT.APP (exp1,el,type_info) =>
d206 4
a209 4
      | LT.SCON scon => SCONEXP scon
      | LT.MLVALUE _ => crash "Can't translate MLVALUE"
      | LT.INT i => INT i
      | LT.SWITCH (exp,info,tagexpl,elseexp) =>
d216 12
a227 5
      | LT.STRUCT expl => STRUCT (map trans_lamb expl)
      | LT.SELECT ({index,size,...},exp) => SELECT (index,size,trans_lamb exp)
      | LT.RAISE exp => RAISE (trans_lamb exp)
      | LT.HANDLE (exp1,exp2,_) => HANDLE (trans_lamb exp1,trans_lamb exp2)
      | LT.BUILTIN b => do_bop b
d231 4
a234 4
        LT.VCC_TAG (_,i) => VCC_TAG i
      | LT.IMM_TAG (_,i) => IMM_TAG i
      | LT.SCON_TAG scon => SCON_TAG scon
      | LT.EXP_TAG exp => EXP_TAG (trans_lamb exp)
d239 1
a239 1
      LT.APP (e1,[e2],ty)
a240 7
    fun make_fun (args,name,body) =
      LT.FN (args, 
             body,
             name,
             LT.null_type_annotation,
             Option.ABSENT)
      
d247 4
d253 2
a254 2
    fun make_bop_call (b,e,ty) =
      LT.APP (LT.BUILTIN b,[e],trans_type_back ty)
d261 3
a263 3
            LT.LET (x, Option.ABSENT,
                    LT.SELECT ({index=i,size=len},LT.VAR var),
                    doit (i+1,xl))
d270 1
a270 1
        VAREXP n => LT.VAR n
d272 2
a273 2
      | LET (n,e1,e2) => LT.LET (n,Option.ABSENT,trans_back e1,trans_back e2)
      | LETREC _ => crash "FN in trans_back"
d275 1
a275 1
          LT.APP (trans_back f,[trans_back e],trans_type_back ty)
d277 5
a281 9
          let
            val tuple_args = do_tupling andalso ok_arglist el
          in
            if tuple_args
              then LT.APP (trans_back f,map trans_back el,trans_type_back ty)
            else LT.APP (trans_back f,[LT.STRUCT (map trans_back el)],trans_type_back ty)
          end
      | SCONEXP scon => LT.SCON scon
      | INT i => LT.INT i
d288 4
a291 4
                    VCC_TAG i => LT.VCC_TAG ("",i)
                  | IMM_TAG i => LT.IMM_TAG ("",i)
                  | SCON_TAG scon => LT.SCON_TAG scon
                  | EXP_TAG exp => LT.EXP_TAG (trans_back exp)
d298 1
a298 1
            LT.SWITCH (trans_back e,
d303 20
a322 29
      | STRUCT expl =>
          LT.STRUCT (map trans_back expl)
      | SELECT (index,size,exp) => LT.SELECT ({index=index,size=size},trans_back exp)
      | RAISE exp => LT.RAISE (trans_back exp)
      | HANDLE (exp1,exp2) => LT.HANDLE (trans_back exp1,
                                         trans_back exp2,
                                         "Handle")
      | BOP b => LT.BUILTIN b
      | BOPAPP (Pervasives.CALL_C,[e],ty) =>
          LT.APP (LT.BUILTIN Pervasives.CALL_C,[trans_back e],trans_type_back ty)
      | BOPAPP (b,[e],ty) => make_bop_call (b,trans_back e,ty)
      | BOPAPP (b,el,ty) => make_bop_call (b,LT.STRUCT (map trans_back el),ty)

    and trans_fun (args,status,name,body) =
      (case body of
         APP (VAREXP _,el,_) =>
           if (map VAREXP args) = el
             then output (std_out,"Unexpected Eta fun\n")
           else ()
       | _ => ();
       case args of
        [] =>
          let
            val v = new_valid ()
          in
            make_fun ([v],name,trans_back body)
          end
      | [arg] =>
          make_fun ([arg],name,trans_back body)
d324 9
a332 13
          let
            val tuple_args = do_tupling andalso ok_arglist args
          in
            if tuple_args
              then 
                make_fun (args,name,trans_back body)
            else
              let
                val v = new_valid ()
              in
                make_fun ([v], name,wrap_selects (trans_back body,v,args))
              end
          end)
d334 1
a334 1
    fun make_functor (arg,name,body) = LT.FN ([arg],body,name,LT.null_type_annotation,Option.ABSENT)
d337 7
a343 8
      | trans_decs ((i, VAL (FN stuff)) :: decs,body) =
        trans_fndecs (decs,body,[(i,trans_fun stuff)])
      | trans_decs ((i, (VAL e)) :: decs,body) =
        LT.LET (i, Option.ABSENT,trans_back e,trans_decs (decs,body))
      | trans_decs ((i, FUNCTOR (x,name,prog)) :: rest, body) =
        LT.LET (i,Option.ABSENT,
                make_functor (x,name,trans_decs prog),
                trans_decs (rest,body))
d349 2
a350 1
        val bodies = map #2 acc
d352 1
a352 1
        LT.LETREC (map (fn n => (n,Option.ABSENT)) ids, bodies,body)
d356 2
a357 2
      | trans_fndecs ((i, VAL (FN stuff)) :: decs,body,acc) =
        trans_fndecs (decs,body,(i,trans_fun stuff) :: acc)
@
