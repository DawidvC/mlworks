head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.8
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.15.5.1.1.1.1
	MLWorks_workspace_97:1.15.7
	MLWorks_dt_wizard:1.15.6
	MLWorks_11c0_1997_09_09:1.15.5.1.1.1
	MLWorks_10r3:1.15.5.1.3
	MLWorks_10r2_551:1.15.5.1.2
	MLWorks_11:1.15.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.15.5.1
	MLWorks_20m0_1997_06_20:1.15
	MLWorks_1_0_r2c2_1997_06_14:1.15.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.15.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.15.5
	MLWorks_BugFix_1997_04_24:1.15
	MLWorks_1_0_r2_Win32_1997_04_11:1.15
	MLWorks_1_0_r2_Unix_1997_04_04:1.15
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.15.3.1.1
	MLWorks_gui_1996_12_18:1.15.4
	MLWorks_1_0_Win32_1996_12_17:1.15.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.15.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.15.1.1
	MLWorks_1_0_Irix_1996_11_28:1.15.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.15.2
	MLWorks_1_0_Unix_1996_11_14:1.15.1
	MLWorks_Open_Beta2_1996_10_11:1.14.3
	MLWorks_License_dev:1.14.2
	MLWorks_1_open_beta_1996_09_13:1.14.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.14
	MLWorks_Beta_1996_06_07:1.14
	MLWorks_Beta_1996_06_06:1.14
	MLWorks_Beta_1996_06_05:1.14
	MLWorks_Beta_1996_06_03:1.14
	MLWorks_Beta_1996_05_31:1.14
	MLWorks_Beta_1996_05_30:1.14
	ML_beta_release_12/08/94:1.13
	ML_beta_release_03/08/94:1.13
	ML_revised_beta_release_25/05/94:1.13
	ML_final_beta_release_02/03/94:1.13
	mlworks-28-01-1994:1.13
	Release:1.13
	mlworks-beta-01-09-1993:1.13
	MLWorks-1-0-4-29/01/1993:1.13
	MLWorks-1-0-3-21/12/1992:1.11
	MLWorks-1-0-2-15/12/1992:1.11
	MLWorks-1-0-1-04/12/1992:1.10
	checkpoint_17_08_92:1.8
	Ten15_release_21-08-91:1.4
	Ten15_release_19-08-91:1.4
	ten15_release:1.2;
locks; strict;
comment	@ * @;


1.15
date	96.10.10.04.38.08;	author io;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1
	1.15.4.1
	1.15.5.1
	1.15.6.1
	1.15.7.1
	1.15.8.1;
next	1.14;

1.14
date	96.04.30.16.12.11;	author jont;	state Exp;
branches
	1.14.1.1
	1.14.2.1
	1.14.3.1;
next	1.13;

1.13
date	93.01.06.13.10.12;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	93.01.05.19.02.57;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.12.10.13.11.18;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.12.03.10.24.51;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	92.09.24.14.22.27;	author richard;	state Exp;
branches;
next	1.8;

1.8
date	92.06.16.10.39.50;	author davida;	state Exp;
branches;
next	1.7;

1.7
date	92.02.14.13.37.15;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.11.21.19.28.21;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.10.22.12.48.58;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.08.06.13.57.21;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.08.06.12.20.12;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.07.22.15.02.40;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.07.19.13.54.51;	author davida;	state Exp;
branches;
next	;

1.13.1.1
date	93.01.06.13.10.12;	author jont;	state Exp;
branches;
next	;

1.14.1.1
date	96.09.13.11.16.47;	author hope;	state Exp;
branches;
next	;

1.14.2.1
date	96.10.07.16.06.38;	author hope;	state Exp;
branches;
next	;

1.14.3.1
date	96.10.17.11.24.53;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.11.14.12.49.48;	author hope;	state Exp;
branches
	1.15.1.1.1.1;
next	;

1.15.1.1.1.1
date	96.11.28.15.01.01;	author hope;	state Exp;
branches;
next	;

1.15.2.1
date	96.11.22.18.09.21;	author hope;	state Exp;
branches;
next	;

1.15.3.1
date	96.12.17.17.47.59;	author hope;	state Exp;
branches
	1.15.3.1.1.1;
next	;

1.15.3.1.1.1
date	97.02.24.11.37.47;	author hope;	state Exp;
branches;
next	;

1.15.4.1
date	96.12.18.09.42.00;	author hope;	state Exp;
branches;
next	;

1.15.5.1
date	97.05.12.10.34.30;	author hope;	state Exp;
branches
	1.15.5.1.1.1
	1.15.5.1.2.1
	1.15.5.1.3.1;
next	;

1.15.5.1.1.1
date	97.07.28.18.19.47;	author daveb;	state Exp;
branches
	1.15.5.1.1.1.1.1;
next	;

1.15.5.1.1.1.1.1
date	97.10.07.11.44.56;	author jkbrook;	state Exp;
branches;
next	;

1.15.5.1.2.1
date	97.09.08.17.13.22;	author daveb;	state Exp;
branches;
next	;

1.15.5.1.3.1
date	97.09.09.14.09.03;	author daveb;	state Exp;
branches;
next	;

1.15.6.1
date	97.09.10.19.24.32;	author brucem;	state Exp;
branches;
next	;

1.15.7.1
date	97.09.11.20.55.12;	author daveb;	state Exp;
branches;
next	;

1.15.8.1
date	99.04.01.17.57.01;	author daveb;	state Exp;
branches;
next	;


desc
@Pretty-printer for printing during code development.
@


1.15
log
@[Bug #1614]
basifying String
@
text
@(*****************************************)
(* _pretty.sml - A Simple Pretty-Printer *)
(*****************************************)

(* $Log: _pretty.sml,v $
 * Revision 1.14  1996/04/30  16:12:11  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.13  1993/01/06  13:10:12  jont
 * Removed string_of_T and recoded in terms of simplified reduce
 *
Revision 1.12  1993/01/05  19:02:57  jont
 Added functions to print directly to a supplied stream

Revision 1.11  1992/12/10  13:11:18  jont
Rewrote reduce in a more functional and simpler style. It now prints
signatures sensibly at last.

Revision 1.10  1992/12/03  10:24:51  matthew
Fixed bug in reduce

Revision 1.9  1992/09/24  14:22:27  richard
Added reduce.

Revision 1.8  1992/06/16  10:39:50  davida
Faster printing scheme.

Revision 1.7  1992/02/14  13:37:15  jont
Added a type specifier to disambiguate overloaded operation

Revision 1.6  1991/11/21  19:28:21  jont
Added some brackets to keep njml 0.75 happy

Revision 1.5  91/10/22  12:48:58  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.4  91/08/06  13:57:21  davida
Removed line-spill prefix 'cos it was a mess.

Revision 1.3  91/08/06  12:20:12  davida
Added hack to produce an immediate printing from
pretty-print trees.  This could do with tidying up
a bit...

Revision 1.2  91/07/22  15:02:40  davida
Tidied up newline behaviour, and added a hack to cope
with lines that are too long.  Not really satisfactory,
but this is only intended for development purposes...

Revision 1.1  91/07/19  13:54:51  davida
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "pretty";

functor PrettyFun (structure Crash : CRASH) : PRETTY =
 struct

  (* Print Items *)

  datatype T = Block of T list * int * int	(* indentation, length *)
    	     | String of string
             | Break of int			(* length *)
    	     | Newline;
      
  val margin = ref 78;

  fun list_of(n, char) =
    let
      fun sub_fun(n, acc) =
	if n <= 0 then acc
	else sub_fun(n-1, char :: acc)
    in
      sub_fun(n, [])
    end

  fun spaces n = implode(list_of(n, #" "))

  fun reduce f (result, indent, T) =
    let 
      val prefix = spaces indent
      val result = f (result, prefix)
      val end_of_line = !margin

      fun string(result, [], used, empty, prefix) = (result, empty, used)
	| string(result, T :: TS, used, empty, prefix) =
	  let
	    val (result, empty, used) = case T of
	      String s =>
		(f(result, s), false, used + size s)
	    | Break len =>
		if len + used > end_of_line then
		  (f(result, "\n" ^ prefix), true, size prefix)
		else
		  let
		    val space = spaces len
		  in
		    (f(result, space), empty, used + len)
		  end
	    | Newline =>
		(f(result, "\n" ^ prefix), true, size prefix)
	    | Block(TS, indent, _) =>
		let
		  val space = spaces indent
		  val prefix' = prefix ^ space
		in
		  string(if empty then f(result, space) else result,
			   TS, used, empty, prefix')
		end
	  in
	    string(result, TS, used, empty, prefix)
	  end
    in
      #1(string(result, [T], indent, true, prefix))
    end


  fun string_of_T T = reduce (op^) ("", 0, T)

  fun print_T print_fn T = reduce (fn ((), s) => print_fn s) ((), 0, T)

  val str = String
  and brk = Break
  and nl = Newline;

  fun blk (indent,Ts) =
    let 
        fun max (m,[]) = m
          | max (m:int, i::is) = if i>m then max(i,is) else max(m,is)
	  
        fun length ([],k::ks) = max (k,ks)
          | length (Block(_,_,len)::Ts,k::ks) = length(Ts,(k+len)::ks)
          | length ((String s)::Ts,k::ks) = length(Ts,((size s)+k)::ks)
          | length ((Break len)::Ts,k::ks) = length(Ts,(len+k)::ks)
          | length (Newline::Ts,ks) = length(Ts, 0::ks)
          | length _ = Crash.impossible "Pretty.blk";
    in  
      Block(Ts,indent, length(Ts,[0]) )
    end

  fun lst(lp,sep,rp) ts =
    let 
      fun list [] = []
        | list [T] = [T]
        | list (T::Ts) = T :: (sep @@ (list Ts))
    in 
      (str lp) :: ((list ts) @@ [str rp])
    end

 end;
@


1.15.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.5.1
log
@branched from 1.15
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.15.5.1  1997/05/12  10:34:30  hope
 * branched from 1.15
 *
@


1.15.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.15.5.1  1997/05/12  10:34:30  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.15.5.1  1997/05/12  10:34:30  hope
 * branched from 1.15
 *
@


1.15.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.15.5.1.1.1  1997/07/28  18:19:47  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.15.4.1
log
@branched from 1.15
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.3.1
log
@branched from 1.15
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.3.1.1.1
log
@branched from 1.15.3.1
@
text
@a5 3
 * Revision 1.15.3.1  1996/12/17  17:47:59  hope
 * branched from 1.15
 *
@


1.15.2.1
log
@branched from 1.15
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.1.1
log
@branched from 1.15
@
text
@a5 4
 * Revision 1.15  1996/10/10  04:38:08  io
 * [Bug #1614]
 * basifying String
 *
@


1.15.1.1.1.1
log
@branched from 1.15.1.1
@
text
@a5 3
 * Revision 1.15.1.1  1996/11/14  12:49:48  hope
 * branched from 1.15
 *
@


1.14
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d83 1
a83 1
  fun spaces n = String.implode(list_of(n, " "))
@


1.14.3.1
log
@branched from 1.14
@
text
@a5 6
 * Revision 1.14  1996/04/30  16:12:11  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.14.2.1
log
@branched from 1.14
@
text
@a5 6
 * Revision 1.14  1996/04/30  16:12:11  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.14.1.1
log
@branched from 1.14
@
text
@a5 6
 * Revision 1.14  1996/04/30  16:12:11  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.13
log
@Removed string_of_T and recoded in terms of simplified reduce
@
text
@d6 3
d77 1
a77 1
  fun spaces n = implode(list_of(n, " "))
@


1.13.1.1
log
@Fork for bug fixing
@
text
@a5 3
Revision 1.13  1993/01/06  13:10:12  jont
Removed string_of_T and recoded in terms of simplified reduce

@


1.12
log
@ Added functions to print directly to a supplied stream
@
text
@d6 3
a62 11

  (* Add the lengths of the expressions until the next Break; if no *)
  (* Break then include "after", to account for text following this *)
  (* block. 							    *)

  fun breakdist (Block(_,_,len)::Ts, after) = len + breakdist(Ts, after)
    | breakdist (String s :: Ts, after) = size s + breakdist (Ts, after)
    | breakdist (Break _ :: Ts, after) = 0
    | breakdist (Newline :: Ts, after) = 0
    | breakdist ([], after) = after;

a63 1
  val overflow = "";			(* indent for overflowed lines    *)
a64 76
  fun string_of_T T =
    let 
      val fillfactor = !margin div 12;	(* minimum no of chars per line   *)
      val minspace = !margin div 5;	(* minimum width of indented blks *)

      val space = ref(!margin);
      val empty = ref true;
      val nonwhite = ref 0;
      val prefix = ref "";

      fun blanks 0 = ""
        | blanks n = 
          let 
            fun blanks' (0, acc) = acc
              | blanks' (n, acc) = blanks' (n-1, " "::acc)
          in	
            if n < !margin then
              (space := !space - n;
               implode (blanks' (n,[])))
            else
              " "
          end
        

      fun newline () =
        (space := !margin - (size (!prefix)); 
         empty := true;
         "\n" ^ !prefix)

      fun string ([], _, _, result) = result
        | string (T::Ts, blockspace, after, result) =
          string (Ts, blockspace, after, 
                  case T of
                    Block (Ts',indent,len) =>
                      if (!space-indent)>minspace orelse !empty then
                        string(Ts', 
                               !space-indent-(size (!prefix)),
                               breakdist(Ts,after), 
                               result)
                      else 
                        let
                          val oldprefix = !prefix;
                          val _ = prefix:= oldprefix ^ overflow;
                          val s = string(Ts', 
                                         !margin-(size (!prefix)),
                                         breakdist(Ts,after),
                                         result)
                        in
                          prefix:=oldprefix; 
                          s
                        end

                  | String s => 
                      (space := !space - size s; 
                       empty := false;
                       nonwhite := !nonwhite + size s;
                       result ^ s)

                  | Break len =>
                      result ^
                      (if (len + breakdist(Ts,after) <= !space) orelse
                         (!nonwhite < fillfactor) then
                         blanks len
                       else 
                         (if !empty  orelse (blockspace = !space) then
                            ""
                          else
                            (newline() ^
                             blanks(!margin-blockspace))))

                  | Newline =>
                      implode [result, newline(), blanks(!margin-blockspace)])
    in  
      string([T], !margin, 0, "") 
    end

a77 2
      val fillfactor = !margin div 12	(* minimum no of chars per line   *)
      val minspace = !margin div 5	(* minimum width of indented blks *)
a113 7
  val string_of_T =
    fn T =>
    let
      fun print_fn(stream, s) = (output(stream, s); stream)
    in
      string_of_T T
    end
d115 2
a147 2


@


1.11
log
@Rewrote reduce in a more functional and simpler style. It now prints
signatures sensibly at last.
@
text
@d6 4
a205 1
      reduce print_fn (std_out, 2, T);
a207 82
(*
      val space = ref(!margin)
      val empty = ref true
      val nonwhite = ref 0
      val prefix =
        let
          fun spaces 0 = ""
            | spaces n = " " ^ spaces (n-1)
        in
          ref (spaces indent)
        end

      val result = f (result, !prefix)

      fun blanks (result, 0) = result
        | blanks (result, n) = 
          let
            fun pbs (result, 0) = result
              | pbs (result, n) = pbs (f (result, " "), n-1)
          in
            if n < !margin then
              (space := !space - n; pbs (result, n))
            else
              result
          end

      fun newline result =
        (space := !margin-(size (!prefix)); 
         empty := true; 
         f (result, "\n" ^ !prefix))

      fun string (result, [], _, _) = result
        | string (result, T::Ts, blockspace, after) =
          let
            val result =
              case T of
                Block (Ts', indent, len) =>
                  if !space-indent > minspace orelse !empty then 
                    string (result, Ts',
                            !space-indent(*-(size (!prefix))*),
                            breakdist (Ts, after))
                  else 
                    let
                      val oldprefix = !prefix
                    in
                      prefix := oldprefix ^ overflow;
                      let
                        val result =
                          string (result, Ts',
                                  !margin(*-(size (!prefix))*),
                                  breakdist (Ts, after))
                      in
                        prefix := oldprefix;
                        result
                      end
                    end

              | String s => 
                  (space := !space - size s; 
                   empty := false;
                   nonwhite := !nonwhite + size s;
                   f (result, s))

               | Break len => 
                   if len + breakdist(Ts, after) <= !space orelse
                     !nonwhite < fillfactor then
                     blanks (result, len)
                   else 
                     if !empty  orelse (blockspace = !space) then
                       result
                     else
                       blanks(newline result, !margin-blockspace)

               | Newline =>
                   blanks (newline result, !margin-blockspace)
          in
            string (result, Ts, blockspace, after)
          end
    in  
      string(result, [T], (!margin)-indent, 0)
    end
*)
@


1.10
log
@Fixed bug in reduce
@
text
@d6 3
d146 8
d155 2
d161 45
d286 1
@


1.9
log
@Added reduce.
@
text
@d6 3
d186 1
a186 1
                            !space-indent-(size (!prefix)),
d196 1
a196 1
                                  !margin-(size (!prefix)),
d226 1
a226 1
      string(result, [T], !margin, 0)
@


1.8
log
@Faster printing scheme.
@
text
@d6 3
d62 1
a62 1

d64 161
d226 1
a226 141
  local
	  val fillfactor = !margin div 12; (* minimum no of chars per line   *)
	  val minspace = !margin div 5;    (* minimum width of indented blks *)
	  val overflow = "";              (* indent for overflowed lines    *)


  in
      fun string_of_T T =
       let 
	val space = ref(!margin);
	val empty = ref true;
	val nonwhite = ref 0;
	val prefix = ref "";

	fun blanks 0 = ""
	  | blanks n = 
	    let 
		fun blanks (0,acc) = acc
		  | blanks (n,acc) = blanks(n-1," "::acc)
	    in	
		if n<(!margin)
		  then (space := !space - n;
			implode (blanks(n,[])))
		else " "
	    end


	fun newline () = (space := !margin-(size (!prefix)); 
			  empty := true; 
			  "\n"^(!prefix))

	fun string ([], _, _, result) = result
	  | string (T::Ts, blockspace, after, result) =
	    string (Ts, blockspace, after, 
		    case T of
			Block (Ts',indent,len) =>
			    if (!space-indent)>minspace orelse !empty
				then string(Ts', 
					    !space-indent-(size (!prefix)),
					    breakdist(Ts,after), 
					    result)
			    else 
				let val oldprefix = !prefix;
				    val _ = prefix:= oldprefix ^ overflow;
				    val s = string(Ts', 
						   !margin-(size (!prefix)),
						   breakdist(Ts,after),
						   result)
				in (prefix:=oldprefix; s) end

		      | String s => 
			    (space := !space - size s; 
			     empty := false;
			     nonwhite := !nonwhite + size s;
			     result ^ s)
		       
		      | Break len => result ^
			    (if (len + breakdist(Ts,after) <= !space)
				orelse (!nonwhite < fillfactor)
				then blanks len
			    else 
				(if !empty  orelse (blockspace = !space)  
				     then ""
				 else (newline() ^
				       blanks(!margin-blockspace))))

		      | Newline => (result ^ (newline() ^ 
				    blanks(!margin-blockspace))))
       in  
	   string([T], !margin, 0, "") 
       end;



      fun print_T print_fn T =
       let 
	val space = ref(!margin);
	val empty = ref true;
	val nonwhite = ref 0;
	val prefix = ref "";

	fun blanks 0 = ()
	  | blanks n = 
	    let
	      fun pbs 0 = ()
                | pbs n = (print_fn " "; pbs (n-1))
	    in
	      if n<(!margin)
		then (space := !space - n; pbs n)
	      else ()
	    end
	  
	fun newline () = (space := !margin-(size (!prefix)); 
			  empty := true; 
			  print_fn ("\n"^(!prefix)))
	  
	fun string ([], _, _) = ()
	  | string (T::Ts, blockspace, after) =
	    (case T of
	       Block (Ts',indent,len) =>
		 if (!space-indent)>minspace orelse !empty
		   then 
		     (string(Ts', 
			     !space-indent-(size (!prefix)),
			     breakdist(Ts,after)))
		 else 
		   let val oldprefix = !prefix;
		     val _ = prefix:= oldprefix ^ overflow;
		     val _ = (string(Ts', 
				     !margin-(size (!prefix)),
				     breakdist(Ts,after)))
		     val _ = prefix := oldprefix;
		   in () end
		 
	     | String s => 
		 (space := !space - size s; 
		  empty := false;
		  nonwhite := !nonwhite + size s;
		  print_fn s)
		 
	     | Break len => 
		 if (len + breakdist(Ts,after) <= !space)
		   orelse (!nonwhite < fillfactor)
		   then blanks len
		 else 
		   if !empty  orelse (blockspace = !space)  
		     then ()
		   else (newline();
			 blanks(!margin-blockspace))
		      
	     | Newline => (newline();
			   blanks(!margin-blockspace));

	    string(Ts, blockspace, after))
		 

	       
       in  
	 string([T], !margin, 0)
       end
  end;
d233 3
a235 3
      let 
	  fun max (m,[]) = m
	    | max (m:int, i::is) = if i>m then max(i,is) else max(m,is)
d237 9
a245 9
	  fun length ([],k::ks) = max (k,ks)
	    | length (Block(_,_,len)::Ts,k::ks) = length(Ts,(k+len)::ks)
	    | length ((String s)::Ts,k::ks) = length(Ts,((size s)+k)::ks)
	    | length ((Break len)::Ts,k::ks) = length(Ts,(len+k)::ks)
	    | length (Newline::Ts,ks) = length(Ts, 0::ks)
	    | length _ = Crash.impossible "Pretty.blk";
      in  
	  Block(Ts,indent, length(Ts,[0]) )
      end;
d248 7
a254 7
      let 
	  fun list [] = []
	    | list [T] = [T]
	    | list (T::Ts) = T :: (sep @@ (list Ts))
      in 
	  (str lp) :: ((list ts) @@ [str rp])
      end;
d256 1
a256 1
end;
@


1.7
log
@Added a type specifier to disambiguate overloaded operation
@
text
@d6 3
a67 4
	  infix ^^;
	  fun s ^^ t = fn () => (s()) ^ t; (* delayed concat *)
	      

d76 2
a77 1
	fun blanks n =
d80 6
a85 16
		  | blanks (1,acc) = " "^acc
		  | blanks (2,acc) = "  "^acc
		  | blanks (3,acc) = "   "^acc
		  | blanks (4,acc) = "    "^acc
		  | blanks (n,acc) = if n>0 andalso n<(!margin)
					 then 
					     let val b = blanks(n div 2,acc)
					     in
						 if (n mod 2) = 1
						  then " "^b^b
						 else b^b
					     end 
				     else acc
	    in 
		(space := !space - n;
		 blanks(n,""))
d116 1
a116 1
			     result ^^ s)
d118 1
a118 1
		      | Break len => result ^^
d128 1
a128 1
		      | Newline => (result ^^ (newline() ^ 
d131 1
a131 1
	   (string([T], !margin, 0, fn()=>"")) ()
d143 9
a151 19
	fun blanks n =
	    let 
		fun blanks (0,acc) = acc
		  | blanks (1,acc) = " "^acc
		  | blanks (2,acc) = "  "^acc
		  | blanks (3,acc) = "   "^acc
		  | blanks (4,acc) = "    "^acc
		  | blanks (n,acc) = if n>0 andalso n<(!margin)
					 then 
					     let val b = blanks(n div 2,acc)
					     in
						 if (n mod 2) = 1
						  then " "^b^b
						 else b^b
					     end 
				     else acc
	    in 
		(space := !space - n;
		 blanks(n,""))
d153 1
a153 2


d156 2
a157 2
			  "\n"^(!prefix))

d161 11
a171 5
		 Block (Ts',indent,len) =>
		     if (!space-indent)>minspace orelse !empty
			 then 
			     (string(Ts', 
				     !space-indent-(size (!prefix)),
d173 21
a193 8
		     else 
			 let val oldprefix = !prefix;
			     val _ = prefix:= oldprefix ^ overflow;
			     val _ = (string(Ts', 
					     !margin-(size (!prefix)),
					     breakdist(Ts,after)))
			     val _ = prefix := oldprefix;
			 in () end
d195 2
a196 15
	       | String s => 
		     (space := !space - size s; 
		      empty := false;
		      nonwhite := !nonwhite + size s;
		      print_fn s)
		       
	       | Break len => 
		     if (len + breakdist(Ts,after) <= !space)
			 orelse (!nonwhite < fillfactor)
			 then print_fn (blanks len)
		     else 
			 (if !empty  orelse (blockspace = !space)  
			      then ()
			  else print_fn(newline() ^
					blanks(!margin-blockspace)))
d198 1
a198 4
	       | Newline => print_fn (newline() ^ 
				      blanks(!margin-blockspace));
		     string(Ts, blockspace, after))
		 
d200 1
a200 1
	   string([T], !margin, 0)
@


1.6
log
@Added some brackets to keep njml 0.75 happy
@
text
@d5 4
a8 1
(* $Log:	_pretty.sml,v $
d229 1
a229 1
	    | max (m, i::is) = if i>m then max(i,is) else max(m,is)
@


1.5
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d6 3
a23 1
 *)
d25 3
d126 1
a126 1
			    if (len + breakdist(Ts,after) <= !space)
d133 1
a133 1
				       blanks(!margin-blockspace)))
@


1.4
log
@Removed line-spill prefix 'cos it was a mess.
@
text
@d6 3
d23 1
a23 1

d26 1
a26 1
functor PrettyFun () : PRETTY =
a217 2
  exception impossible;

d228 1
a228 1
	    | length _ = raise impossible;
@


1.3
log
@Added hack to produce an immediate printing from
pretty-print trees.  This could do with tidying up
a bit...
@
text
@d6 5
d51 1
a51 1
	  val overflow = "!";              (* indent for overflowed lines    *)
@


1.2
log
@Tidied up newline behaviour, and added a hack to cope
with lines that are too long.  Not really satisfactory,
but this is only intended for development purposes...
@
text
@d6 5
d41 2
d48 5
d61 20
a80 3
	fun blanks 0 = ""
	  | blanks n = (space := !space - 1; 
			" "^blanks(n-1))
d82 1
d110 1
a110 1
			     result ^ s)
d112 1
a112 1
		      | Break len => result ^ 
d122 2
a123 2
		      | Newline => (result ^ newline() ^ 
				    blanks(!margin-blockspace)))
d125 78
a202 1
	   string([T], !margin, 0, "")  
@


1.1
log
@Initial revision
@
text
@d5 4
a8 1
(* $Log$ *)
d16 1
a16 7
  fun reduce_right (f: 'a * 'b -> 'b) : 'a list * 'b -> 'b =
      let 
	  fun itl ([ ],  e) = e
	    | itl (a::l, e) = itl (l, f(a,e))
      in  
	  fn (l,e) => itl (rev l, e)    (* rev!! *)
      end;
a17 2
  (* Printing items: compound phrases, strings, and breaks *)

d36 4
a39 3
  fun string_of_T T =
      let 
	  val space = ref(!margin);
d41 7
a47 2
	  fun blanks 0 = ""
	    | blanks n = (space := !space - 1; " "^blanks(n-1))
d49 3
a51 1
	  fun newline () = (space := !margin; "\n")
d53 3
a55 6
	  fun string ([], _, _, result) = result
	    | string (T::Ts, blockspace, after, result) =
	      string (Ts, blockspace, after,
	       case T of
		Block (Ts',indent,len) =>
		      string(Ts', !space-indent, breakdist(Ts,after), result)
d57 24
a80 2
	      | String s => 
		      (space := !space - size s; result ^ s)
d82 9
a90 4
	      | Break len => result ^ 
		    if (len + breakdist(Ts,after) <= !space) 
			then blanks len
		    else (newline() ^ blanks(!margin-blockspace))
d92 6
a97 4
	      | Newline => (result ^ newline() ^ blanks(!margin-blockspace)))
      in  
	  string([T], !margin, 0, "")  
      end;
d117 1
a117 1
	  Block(Ts,indent, length(Ts,[0])  )
@
