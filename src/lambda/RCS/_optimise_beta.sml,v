head	1.49;
access;
symbols
	ML_beta_release_12/08/94:1.46
	ML_beta_release_03/08/94:1.46
	ML_revised_beta_release_25/05/94:1.45
	ML_final_beta_release_02/03/94:1.45
	mlworks-28-01-1994:1.45
	Release:1.41
	mlworks-beta-01-09-1993:1.41
	MLWorks-1-0-4-29/01/1993:1.38
	MLWorks-1-0-3-21/12/1992:1.38
	MLWorks-1-0-2-15/12/1992:1.38
	MLWorks-1-0-1-04/12/1992:1.38
	checkpoint_17_08_92:1.30;
locks; strict;


1.49
date	94.10.10.09.55.02;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.09.19.14.31.06;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.08.30.12.04.09;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	94.07.19.14.32.53;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	93.12.07.16.01.05;	author nosa;	state Exp;
branches;
next	1.44;

1.44
date	93.11.25.15.05.50;	author nosa;	state Exp;
branches;
next	1.43;

1.43
date	93.11.23.20.09.49;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.08.12.09.40.45;	author nosa;	state Exp;
branches;
next	1.41;

1.41
date	93.07.30.14.42.26;	author nosa;	state Exp;
branches
	1.41.1.1;
next	1.40;

1.40
date	93.05.18.18.51.32;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	93.03.10.16.01.48;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	92.12.03.12.16.22;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	92.11.09.16.09.38;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.09.22.13.30.02;	author clive;	state Exp;
branches;
next	1.35;

1.35
date	92.09.21.12.16.59;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.09.16.10.01.36;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.09.15.09.30.31;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.09.09.14.44.14;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	92.08.26.13.14.07;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.07.29.10.26.41;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.07.24.16.44.23;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.07.23.13.08.57;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.07.17.14.28.38;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.07.13.11.12.58;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.07.10.14.46.08;	author davida;	state Exp;
branches;
next	1.24;

1.24
date	92.07.09.18.31.21;	author davida;	state Exp;
branches;
next	1.23;

1.23
date	92.07.08.14.29.36;	author davida;	state Exp;
branches;
next	1.22;

1.22
date	92.07.02.16.10.53;	author davida;	state Exp;
branches;
next	1.21;

1.21
date	92.06.30.10.51.39;	author davida;	state Exp;
branches;
next	1.20;

1.20
date	92.06.16.14.58.45;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.06.03.16.05.10;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.05.05.08.16.30;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.04.30.16.04.16;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.04.28.11.24.51;	author clive;	state Exp;
branches;
next	1.15;

1.15
date	92.04.13.14.21.12;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.04.02.12.46.41;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.03.27.13.05.41;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.03.05.13.12.21;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.01.30.16.11.32;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	91.11.22.18.38.42;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.10.22.18.14.48;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	91.10.22.14.12.22;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	91.10.09.15.12.33;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	91.09.26.13.35.31;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.09.25.15.22.51;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.09.16.15.04.51;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.09.12.16.01.19;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.09.10.17.05.48;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.09.17.23.23;	author davida;	state Exp;
branches;
next	;

1.41.1.1
date	93.07.30.14.42.26;	author jont;	state Exp;
branches;
next	;


desc
@  Heuristic-controlled beta-reduction
@


1.49
log
@Lambdatypes changes
@
text
@(* _optimise_beta the functor *)
(*
$Log: _optimise_beta.sml,v $
Revision 1.48  1994/09/19  14:31:06  matthew
Abstraction of debug information in lambdatypes

Revision 1.47  1994/08/30  12:04:09  matthew
Removed some debugging stuff

Revision 1.46  1994/07/19  14:32:53  matthew
Functions and applications take a list of parameters

Revision 1.45  1993/12/07  16:01:05  nosa
Added handles for cases of incorrect type information.

Revision 1.44  1993/11/25  15:05:50  nosa
Type Information Preservation in beta reduction for recipe generation by type
unification and substitution in lambda expressions.

Revision 1.43  1993/11/23  20:09:49  jont
Changed eta reduction to be valid only when reducing to a function,
thus preserving names etc.

Revision 1.42  1993/08/12  09:40:45  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.41  1993/07/30  14:42:26  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.40  1993/05/18  18:51:32  jont
Removed integer parameter

Revision 1.39  1993/03/10  16:01:48  matthew
Signature revisions

Revision 1.38  1992/12/03  12:16:22  matthew
Commented out calls to print_deletion_message.
,.

Revision 1.37  1992/11/09  16:09:38  clive
Added some LETREC optimisation

Revision 1.36  1992/09/22  13:30:02  clive
Changes for the newhashtables

Revision 1.35  1992/09/21  12:16:59  clive
Changed hashtables to a single structure implementation

Revision 1.34  1992/09/16  10:01:36  clive
Curry optimisation and removal of handles of hash table lookup exceptions

Revision 1.33  1992/09/15  09:30:31  clive
Do inlining of curried function applications

Revision 1.32  1992/09/09  14:44:14  jont
Changed the heuristic parameters for function inlining to make it
less aggressive

Revision 1.31  1992/08/26  13:14:07  jont
Removed some redundant structures and sharing

Revision 1.30  1992/07/29  10:26:41  clive
Changed the bindingtable to be a hashtable

Revision 1.29  1992/07/24  16:44:23  clive
Modified to use the new hashtables

Revision 1.28  1992/07/23  13:08:57  clive
Adjusted so that it doesn't substitute into letrecs and fn's

Revision 1.27  1992/07/17  14:28:38  clive
null_type_annotation is no longer a function

Revision 1.26  1992/07/13  11:12:58  clive
Switched off time printouts

Revision 1.25  1992/07/10  14:46:08  davida
Added some transformations in beta reduction.

Revision 1.24  1992/07/09  18:31:21  davida
Tidy up, removed Optimise Lib parameter.

Revision 1.23  1992/07/08  14:29:36  davida
General tidying up.

Revision 1.22  1992/07/02  16:10:53  davida
Added LET constructor and new slot to APP,
general improvements.

Revision 1.21  1992/06/30  10:51:39  davida
Altered inlining to be depth limiting and work outermost
(transitory form as improvement is needed).  Removed
commutative re-ordering on beta-reduction, most possible
redexes will be caught by initial rearrangement function.
Other general improvements.

Revision 1.20  1992/06/16  14:58:45  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.19  1992/06/03  16:05:10  clive
A few speed improvements including specialising the hash equality function

Revision 1.18  1992/05/05  08:16:30  clive
Cache the failure case in function_inline

Copyright (c) 1991 Harlequin Ltd.
*)

(*
 * Lambda-Calculus Optimisation:  _optimise_beta
 * Advanced beta-reduction and function in-lining
 *
 *)

require "../utils/crash";
require "../utils/lists";
require "../utils/print";
require "../utils/_newhashtable" ;
require "../utils/timer";
require "../typechecker/types";
require "../typechecker/unify";
require "lambdasub";
require "lambdaprint";
require "optimise_beta";

functor OptimiseBeta(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Print : PRINT
  structure Timer : TIMER
  structure LambdaPrint : LAMBDAPRINT
  structure LambdaSub : LAMBDASUB
  structure Types : TYPES
  structure Unify : UNIFY

  sharing LambdaPrint.LambdaTypes = LambdaSub.LT
  sharing type LambdaPrint.LambdaTypes.LVar = int
  sharing type Unify.Datatypes.Type = LambdaSub.LT.Type = Types.Datatypes.Type
  sharing type Unify.options = Types.Options.options
  val int_size       : int
  and real_size      : int
  and string_size_fn : string -> int
) : OPTIMISE_BETA =
struct

  (* preamble *)

  structure LS = LambdaSub
  structure LT = LS.LT
  structure Set = LT.Set
  structure Ident = LT.Ident
  structure NewHashTable = LT.NewHashTable
  structure Option = LT.Option

  val print_hash_table_stats = LS.print_hash_table_stats

  fun fst(x,_)=x and snd(_,y)=y
  fun swap f (x,y) = f (y,x)
  fun curry f x y = f (x,y)
  and uncurry f (x,y) = f x y
  fun apfst f (x,y) = (f x, y)
  and apsnd f (x,y) = (x, f y)

  fun fixpoint eq (f,x) = 
    let
      fun iter x = 
	let
	  val x' = f x
	in
	  if eq(x,x') then x else iter x'
	end
    in
      iter x
    end

  infix upto
  fun a upto b = if a>b then [] else a::(a+1 upto b)

  val mem = Set.is_member
  val ==  = Set.seteq
  val ++  = swap Set.add_member
  fun -- (S,a) = Set.setdiff (S, Set.singleton a)
  infix ++ -- ==

  val do_debug = false

  val show_debug_info = ref true;
  fun info message =
    if !show_debug_info then Print.print message else ()


  (******************************************)
  (*  Pre-processing of Lambda Expressions  *)
  (******************************************)

  val basic_info = LT.Info{bindings = LT.NewHashTable.new (32,op = : int * int -> bool,fn x => x),
			   known_fns = Set.empty_set,
			   non_escaping_fns = Set.empty_set,
			   is_shiftable = LS.is_shiftable ,
			   is_commutative = LS.is_commutative Set.empty_set,
			   is_associative = LS.is_associative Set.empty_set}

  local
      (*  Add bindings for variables to an association list, based on  *)
      (*  the translated form of LET expressions, and LETRECs.         *)

      fun get_bindings expr =
	 let
	    fun aug((bindings,bindings_as_list), LT.LET((var,_,arg),_)) =
              ((LT.NewHashTable.update(bindings,var,arg);bindings),(var,arg)::bindings_as_list)
	      | aug((bindings,bindings_as_list), LT.LETREC(lvl,lel,_)) = (* flag val rec's *)
                 let 
                   val lvl = map #1 lvl
                 in
                   Lists.reducel
                   (fn ((current_bindings,list_of_bindings),(lvl,exp)) =>
                    ((LT.NewHashTable.update(current_bindings,lvl,exp);
                      current_bindings),
                     (lvl,exp)::list_of_bindings))
                   ((bindings,bindings_as_list),
                    Lists.zip(lvl,
                              lel (* map (fn exp=>LT.LETREC([],[],exp)) lel *)))
                 end

	      | aug(bindings, _) = bindings
	 in
	    LS.reduce_outermost aug ((LT.NewHashTable.new(32,op = : int * int -> bool, fn x => x),[]),expr)
	 end
								 
      (*  Determine which variables are bound to functions  *)
      (*  (NB:- functions are identified by the lambda-     *)
      (*   variables they bind)				    *)

      fun get_knowns bindings =
	 let
	    fun getk (knowns, (_, LT.FN([var],_,_,_,_))) = knowns ++ (var)
              | getk (knowns, (_, LT.FN(varlist,_,_,_,_))) =
                Crash.impossible "Varlist in get_knowns"
	      | getk (knowns, _) = knowns
	 in
	    Lists.reducel getk (Set.empty_set, bindings)
	 end

      (*  Determine which functions can be guaranteed not to escape,  *)
      (*  i.e. can never be seen from or passed outside.  Functions   *)
      (*  are identified by the lambda-variables they bind.           *)

      fun get_non_escapings (expression, known_fns, bindings) =
	 let
	    fun remove (nes, LT.FN([var], _,_,_,_)) = nes -- (var)
              | remove (nes, LT.FN(varlist, _,_,_,_)) =
                Crash.impossible "Varlist in get_non_escapings"
	      | remove (nes, LT.STRUCT (lel,_)) = Lists.reducel remove (nes,lel)
	      | remove _ = Crash.impossible "get_non_escapings(remove)"
	 in
	   Set.empty_set
	 end



      (*  Deduce a set of variables corresponding to functions which are  *)
      (*  shiftable when applied to some argument.  Maximal fixed point   *)
      (*  of a monotonic operator job.  Perhaps later add a simple class  *)
      (*  of recursive functions which can be guaranteed to terminate.    *)

    (* No longer used

      fun get_shiftables bindings =
	  let
	      (* fun get_letrecs x = x *)

	      fun shift_bodies(acc, (var, LT.FN([var'],body,_,_,_))) =
		  if LS.is_shiftable acc body
		      then acc ++ var
		  else acc
                | shift_bodies(acc, (var, LT.FN(varlist,body,_,_,_))) =
                  Crash.impossible "Varlist in get_shiftables"
		| shift_bodies(acc, _) = acc
	  in
	     fixpoint
	     op ==
	     (fn s=>Lists.reducel shift_bodies (s,bindings),Set.empty_set)
	  end
*)
      fun get_commutatives bindings = Set.empty_set
      fun get_associatives bindings = Set.empty_set
  in
   fun process_expr expression =
    let
     val (bindings,bindings_as_list) = get_bindings expression
     val known_fns = get_knowns bindings_as_list
     val non_escaping_fns = get_non_escapings (expression, known_fns, bindings_as_list)
    in
       LT.Info{bindings = bindings,
	       known_fns = known_fns,
	       non_escaping_fns = non_escaping_fns,
	       is_shiftable = LS.is_shiftable (* (get_shiftables bindings_as_list) *),
	       is_commutative = LS.is_commutative (get_commutatives bindings),
	       is_associative = LS.is_associative (get_associatives bindings)}
    end

  end (* of local *)



  (*  Beta-reduction is possible when the function argument is            *)
  (*  shiftable (i.e. can be guaranteed not to reference state, raise an  *)
  (*  exception, or loop forever when evaluated), or when substitution    *)
  (*  will not change the evaluation order or number of times a 	  *)
  (*  non-shiftable argument will be evaluated.  This ensures semantic    *)
  (*  equivalence.   Beta-reductions might be valuable optimisations, so  *)
  (*  some effort is made to analyse user-defined functions to attempt    *)
  (*  to classify them as shiftable.					  *)

  (*  Since beta-redexes are generated mostly from the equivalent of       *)
  (*  let-constructs during translation, and are spotted as such in code-  *)
  (*  generation, the final savings from performing beta-reduction as far  *)
  (*  as possible at this stage may not justify the computational cost of  *)
  (*  doing it.  We will find out if this is the case by experience.       *)


(* Heuristic Measures *)

  val max_struct_dup   = ref 500;      (*  space from duplicating structs   *)
  val max_scon_space   = ref 500;      (*  space from duplicating SCON's    *)
  val max_func_dup     = ref 50;       (*  space from duplicating fn's      *)
  val code_node_factor = ref 4;        (*  for wintertime, wear balaclavas  *)
				      
    
  fun cost_scon (Ident.INT _) = int_size
    | cost_scon (Ident.REAL _) = real_size
    | cost_scon (Ident.STRING s) = string_size_fn s

  fun cost_all_scons expr =
    let
      fun count(cost, LT.SCON s) = cost + cost_scon s
	| count(cost, _) = cost
    in
      LS.reduce_outermost count (0,expr)
    end

  fun cost_expr expr =
    (LS.size_of_expr expr) * (!code_node_factor) + cost_all_scons expr

       fun substitute_types S lexp =
         let
           fun substitute_types(LT.FN([lv],lexp,name,ty,i)) =
             LT.FN([lv],substitute_types lexp,name,Unify.apply(S,ty),i)
             | substitute_types(LT.FN(lvl,lexp,name,ty,i)) =
               Crash.impossible "Varlist in substitute_types"
             | substitute_types(LT.LET((lv,info,lexp1),lexp2)) =
               LT.LET((lv,info,substitute_types lexp1),substitute_types lexp2)
             | substitute_types(LT.LETREC(lvs,lexps,lexp)) =
               LT.LETREC(lvs,map substitute_types lexps,substitute_types lexp)
             | substitute_types(LT.APP(lexp1,lexpl,Option.PRESENT(ref(ty)))) =
               LT.APP(substitute_types lexp1,map substitute_types lexpl,Option.PRESENT(ref(Unify.apply(S,ty))))
             | substitute_types(LT.APP(lexp1,lexpl,_)) =
               LT.APP(substitute_types lexp1,map substitute_types lexpl,Option.ABSENT)
             | substitute_types(LT.SWITCH(lexp,opt,tags,lexpopt)) =
               LT.SWITCH(substitute_types lexp,opt,
                         map (fn (tag,lexp) => (tag,substitute_types lexp)) tags,
                         case lexpopt of
                           Option.ABSENT => lexpopt
                         | Option.PRESENT(lexp) => Option.PRESENT(substitute_types lexp))
             | substitute_types(LT.STRUCT(lexps,ty)) = LT.STRUCT(map substitute_types lexps,ty)
             | substitute_types(LT.SELECT(index,lexp)) = LT.SELECT(index,substitute_types lexp)
             | substitute_types(LT.RAISE(lexp)) = LT.RAISE(substitute_types lexp)
             | substitute_types(LT.HANDLE(lexp1,lexp2,str)) =
               LT.HANDLE(substitute_types lexp1,substitute_types lexp2,str)
             | substitute_types lexp = lexp
         in
           substitute_types lexp
         end

  local
     fun scon_heuristic(scon,no_of_times) = 
	(cost_scon scon * no_of_times) < (!max_scon_space)

     fun struct_heuristic(strct,no_of_times) = 
	(cost_expr strct * no_of_times) < (!max_struct_dup)

    (*   should_reduce : expr * int -> bool				*)
    (* 								        *)
    (*  A heuristic function to decide if beta-reduction should be      *)
    (*  performed in the case that the bound-variable appears in the    *)
    (*  body more than once.  In general, this is a compromise between  *)
    (*  the cost of function application at run-time, and the cost of   *)
    (*  evaluating the argument.  Simple cases are when the arg is:     *)
    (*  VAR, SCON, INT, BUILTIN.                                        *)
    (*  (only called with a shiftable argument)			  *)
       
    fun should_reduce(arg,times,(var,body)) = 
       (case arg of
	   LT.VAR _  => true

	 | LT.BUILTIN _ => true
	      
	 | LT.INT i  => true
	      
	 | LT.SCON sc => scon_heuristic(sc,times)
	      
	 | _ => false)
	   
    (*  Abstract out a new lambda-variable over each component of a     *)
    (*  structure, producing new let-bindings.				*)
    (*  Code is a lot more concise to do curried form of this, but      *)
    (*  ensuring nested app's means beta-reduction can be done in one   *)
    (*  go.  Typically this will introduce new beta-redexes, and        *)
    (*  usefully splits apart a structure with a mixture of shiftable   *)
    (*  non-shiftable components.  					*)
	   
       fun select_field (fieldlist,index, size) =
	  (Lists.nth (index, fieldlist)
	   handle Lists.Nth => 
	     Crash.impossible "select_field: bad SELECT field number!")

 in
    fun heuristic_beta_reduce generate_recipes
      (LT.Info{bindings,is_shiftable,
               is_commutative,...}, expression) =
    let
	  
      (* Do the occurrence count using a hashtable and not by repeatedly calling a function *)
      
      val occ_count_hash_table = NewHashTable.new(128,op = : int * int -> bool,fn x => x)
        
      fun adjuster_function (v:int) =
        (fn (copy as LT.VAR(var)) =>
         let
           val x = NewHashTable.lookup(occ_count_hash_table,var)
         in
           (NewHashTable.update(occ_count_hash_table,var,x+v);
            copy)
         end
      | expression => expression)
        
      fun get_count var =
        NewHashTable.lookup_default(occ_count_hash_table,0,var) 
          
      fun increment_count (var,n) =
        NewHashTable.update(occ_count_hash_table,var,n + get_count var)
        
      fun adjust_counts (times,body) =
        LS.reduce_innermost (fn (exp,arg) => (adjuster_function times exp; arg)) (body,())  
          
       fun breakup_struct(is_shiftable,var, body, fields) =
	  let
	    fun abs_app(expr,subx::rest,arg::rest',vars) = 
	       let 
		  val (var',count,expr') = 
                    LS.abstract_with_count(expr,subx)
                  val _ =
                    if count=0
                      then 
                        ()
                    else 
                      (increment_count(var',count);
                       increment_count(var,~count))
	       in
                 abs_app(LT.LET((var',LT.Option.ABSENT,arg),expr'), rest, rest', var'::vars)
               end
	      | abs_app(expr,[],[],vars) = (expr,vars)
              | abs_app _ = Crash.impossible "unbalanced list in abs_app"
		
	    val size_of_struct = Lists.length fields
	    fun mkField i = {index = i, size = size_of_struct,selecttype=LT.TUPLE}
	    val selects = map mkField (0 upto (size_of_struct-1))
	    val args = map (fn {index,size,...} => select_field (fields,index,size)) selects
	    val evar = LT.VAR var
	    val sub_exprs =
	      (map (fn field => LT.SELECT(field,evar)) selects)
	    val (newexpr,newvars) = abs_app (body,rev sub_exprs,rev args,[])
	    val newstruct = LT.STRUCT(map LT.VAR newvars,LT.TUPLE)

            val occurrences_of_var = get_count var
            val _ =
              if occurrences_of_var=0
                then []
              else
                (NewHashTable.update(occ_count_hash_table,var,0);
                 map (fn x => increment_count(x,occurrences_of_var)) newvars)


	  in
            LS.substitute (var,newstruct,newexpr)
	  end
  

    (*  Beta-reduction when the argument is a structure.  This considers  *)
    (*  whether to break up the structure into separate lambda variables. *)
    (*  If the structure is always SELECT'd on in the body, it will be    *)
    (*  broken up.  Otherwise, a heuristic is used to decide based on     *)
    (*  the size of the struct and the number of times it appears in the  *)
    (*  body without an immediate SELECT.				    *)

      (* The first argument tells us if we are walking this part of the tree *)
      (* for the first time                                                  *)

    fun beta true (original as LT.VAR var) = (increment_count(var,1); 
					      original)


      (* eta reduction (but not to vars) *)

      | beta _ (expression as LT.FN([var],LT.APP(result as LT.FN _,[LT.VAR var'],_),_,_,_)) =
	if var=var' andalso 
	  get_count(var)=1 andalso 
	  is_shiftable(result)
	  then result  (* redexes inside result dealt with already *)
	else expression

      | beta _ (LT.APP(LT.FN([var],body,_,ty,_),[arg],Option.PRESENT(ref(ty')))) =
        if generate_recipes then
          let
            val (ty,_) = Types.argres(ty)
          in
            substitute_types (Unify.unified(Types.Options.default_options,ty,ty',true))
            (beta false (LT.LET((var,LT.Option.ABSENT,arg),body)))
          end
        handle Types.ArgRes => beta false (LT.LET((var,LT.Option.ABSENT,arg),body))
        else beta false (LT.LET((var,LT.Option.ABSENT,arg),body))

      | beta _ (lexp as LT.APP(LT.FN([var],body,_,_,_),[arg],_)) =
         beta false (LT.LET((var,LT.Option.ABSENT,arg),body))

      | beta _ (lexp as LT.APP(LT.FN(varlist,body,_,_,_),[arg],_)) =
        Crash.impossible "Varlist in beta"

      | beta _ (LT.APP(LT.LET((var1,info,bind),LT.FN([var2],body,_,ty,_)),[arg],Option.PRESENT(ref(ty')))) =
        if generate_recipes then
          let
            val (ty,_) = Types.argres(ty)
            val inner_let = substitute_types (Unify.unified(Types.Options.default_options,ty,ty',true))
              (beta false (LT.LET((var2,LT.Option.ABSENT,arg),body)))
          in
            beta false (LT.LET((var1,info,bind),inner_let))
          end
        handle Types.ArgRes =>
          let
            val inner_let = beta false (LT.LET((var2,LT.Option.ABSENT,arg),body))
          in
            beta false (LT.LET((var1,info,bind),inner_let))
          end
        else
          let
            val inner_let = beta false (LT.LET((var2,LT.Option.ABSENT,arg),body))
          in
            beta false (LT.LET((var1,info,bind),inner_let))
          end

      | beta _ (lexp as LT.APP(LT.LET((var1,info,bind),LT.FN([var2],body,_,_,_)),[arg],_)) =
	let
	  val inner_let = beta false (LT.LET((var2,LT.Option.ABSENT,arg),body))
	in
	  beta false (LT.LET((var1,info,bind),inner_let))
	end

      | beta _ (lexp as LT.APP(LT.LET((var1,info,bind),LT.FN(varlist,body,_,_,_)),[arg],_)) =
        Crash.impossible "Varlist in beta"

      (* move bindings outwards, above applications *)

      | beta _ (original as LT.APP(func, [LT.LET((var,info,bind),body)], ty)) =
	if is_shiftable func
	  then LT.LET((var,info,bind),LT.APP(func,[body],ty)) (* can't reduce it *)
	else original

      | beta _ (LT.APP(sub_let as LT.LET _,[arg],ty)) =
        let
          fun push_down_lets(LT.LET((var,info,bind),body)) = 
            LT.LET((var,info,bind),push_down_lets(body))
            | push_down_lets other =
              let
                val new_var = LT.new_LVar()
                val new_var' = LT.new_LVar()
              in
                LT.LET((new_var',LT.Option.ABSENT,other),
                       LT.LET((new_var,LT.Option.ABSENT,arg),
                              LT.APP(LT.VAR new_var',[LT.VAR new_var],ty)))
              end
        in
          beta false (push_down_lets sub_let)
        end

      | beta _ (original as LT.LET((var,info,s as LT.STRUCT (fields,_)),body)) =
        if get_count var > 1
            then 
              let 
                val noselects = LS.count_noselects (body,var)
              in 
                if noselects = 0 orelse 
                  (struct_heuristic(s,noselects))
                  then 
                    beta false (breakup_struct (is_shiftable,var,body,fields))
                else 
                  beta2 original
              end
          else beta2 original

      | beta _ e = beta2 e

    (*  Beta-reduction in the more general case.  Recurses to reduce   *)
    (*  the outermost redexes, when the argument is shiftable, or      *)
    (*  substituting it will definitely evaluate it, and do so before  *)
    (*  any other un-shiftable expression is evaluated.		  *)
	
    and beta2 (original as (LT.LETREC(vars,args,body))) =
      let
        val vars = map #1 vars
        (* fun print_deletion_messages x = Lists.iterate LS.print_deletion_message x *)
      in
        if Lists.forall (fn var => get_count var = 0) vars
          then 
            ((* print_deletion_messages args; *)
             body)
        else 
          if (Lists.forall 
              (fn var => 
               let
                 fun all_adjusted_counts_for_body_are_zero (n,[]) = (n=0)
                   | all_adjusted_counts_for_body_are_zero (n,h::t) =
                     let
                       val n' = n - LS.occurrences(var,h)
                     in
                       if n' > 0
                         then false
                       else all_adjusted_counts_for_body_are_zero (n',t)
                     end
               in
                 all_adjusted_counts_for_body_are_zero (get_count var,args)
               end)
              vars)
            then
              ((* print_deletion_messages args; *)
               body)
          else
            original
      end

      | beta2 (original as (LT.LET((var,info,arg),body))) =
        let
          val occurs = get_count var 
        val shiftable = is_shiftable arg
        fun reduce (actions,arg,body,count) = 
          (let
            val xx = (LS.substitute_for_exactly_n_occurrences_not_in_functions (var,arg,body,count))
            val _ = actions()
          in
            beta false xx
          end)
             handle LS.DidntFindCorrectNumber => original

        fun reduce_for_one_occurrence (actions,arg,body) = 
          (let
            val xx = (LS.substitute_for_at_most_one_occurrence(var,arg,body))
            val _ = actions()
          in
            beta false xx
          end)
             handle LS.DidntFindCorrectNumber => original
          
      in 
        if shiftable then
          (case occurs of
             0 => (adjust_counts (~1,arg) ; 
                   (* LS.print_deletion_message arg; *)
                   body)
		    
           | 1 =>  (reduce_for_one_occurrence (fn () => increment_count(var,~1),
                                               arg,body))
		    
           | more => if should_reduce(arg,more,(var,body)) 
                       then 
                         let
                           val fresh = LS.rename_fresh arg
                         in
                           reduce (fn () =>
                                   (increment_count(var,~more);
                                    adjust_counts(~1,arg);
                                    adjust_counts(more,fresh)),
                                   fresh, body,more)
                         end
                     else 
                       original)
	  else
	     (case occurs of
                0 => original
		       
	       | 1 => 
		    let
		       datatype action = Reduce | Give_Up | Re_Order

		       fun reduce_non_shiftables body =
			  let
			     fun find_var_nonshift (LT.VAR v, _) = 
				if v=var then (true,true)
				else (false,false)
			       | find_var_nonshift (expr,_) = 
				 if not(is_shiftable expr) then (false,true)
				 else (false,false)

			     val before_nonshifts =  LS.reduce_inner_until
							find_var_nonshift 
			  in 
			     if LS.is_in_evaluation_set (LT.VAR var) body
			       then if before_nonshifts (body,false)
				      then Reduce
				    else Re_Order
			     else Give_Up
			  end
		    in
		       case reduce_non_shiftables body of
			 Reduce => (reduce_for_one_occurrence (fn () => increment_count(var,~1),arg,body))
		       | _ => original

		    end
		 
	       | more => original) (* could test for a subset which _can_ *)
       				     (* appear more than once, given eval'd *)
       				     (* first: eg, RAISE.		   *)
       end
    
      | beta2 expr = expr

    val result =
      LS.apply_innermost (beta true) expression

    val _ =
      if !print_hash_table_stats
        then output(std_out,"OccCountHashTable in _optimise_beta: " ^
                    NewHashTable.string_hash_table_stats(occ_count_hash_table) ^ "\n")
      else ()

    in
         result
    end  

 end (* of local *)  





  (****************************************************)
  (*  Function-Inlining - Duplicates Function bodies  *)
  (****************************************************)

(* Use a hash table to record failures of expanding in some cases *)


  fun all_lambda_equal ([],[]) = true
    | all_lambda_equal ([],_) = false
    | all_lambda_equal (_,[]) = false
    | all_lambda_equal(h::t,a::b) =  LS.lambda_equality(h,a) andalso all_lambda_equal(t,b)

  datatype 'a my_option = NO | YES of 'a

  val inline_depth = ref 3
  val debug_inlineability = ref(false)
  val test_for_inlineability_threshold = ref(100)
  val cache_hit = ref(0)
    
  fun function_inline generate_recipes optimisesub 
    (optimiseinfo as LT.Info{bindings,is_shiftable,...},input_expression) =
    let
      val heuristic_disallowed = ref(0)
      val attempted = ref(0)
      val success = ref(0)
      val _ = cache_hit := 0

      val inlinetable = NewHashTable.new(32,
                                        fn ((var,exp),(var',exp')) => 
                                        (var = var') andalso all_lambda_equal(exp,exp'),
                                        (fn (x,y) => x ))
      val exprsizetable = NewHashTable.new(32, op = : int * int -> bool, fn x => x)
      val correctformtable = NewHashTable.new(32,op = : int * int -> bool,fn x => x)

      val dummy_form = LT.VAR(LT.new_LVar())

      fun expression_smaller_than(var,funvalue,threshold) =
        case NewHashTable.tryLookup(exprsizetable,var) of
          NewHashTable.YES res => res
        | NewHashTable.NO => 
            let
              val flag = LS.size_of_expr_is_smaller_than(funvalue,threshold)
            in
              NewHashTable.update(exprsizetable,var,flag);
              flag
            end
    
      fun try_to_inline(var,arg,funvalue) = 
        case NewHashTable.tryLookup (inlinetable,(var,arg)) of
          NewHashTable.YES result => 
            (cache_hit := !cache_hit + 1;
             result)
        | NewHashTable.NO => 
            let 
              (* Pre-heuristic for testing inlineability - if false, we don't bother to try *)
              (* another idea is to look at the arg - *)
              (* if it isn't a variable or is a variable with no binding, *)
              (* then inlining is more likely to be worth while *)
              val bother_to_test = expression_smaller_than(var,funvalue,! test_for_inlineability_threshold)
            in
              (bother_to_test orelse !debug_inlineability,
               false,dummy_form,bother_to_test)
            end


      fun has_correct_form fnvar =
        (case NewHashTable.tryLookup(correctformtable,fnvar) of
           NewHashTable.YES res => res
         | NewHashTable.NO  =>
             case LT.NewHashTable.tryLookup(bindings,fnvar) of
               LT.NewHashTable.YES funvalue => 
                 let
                   val correct_form = 
                     case funvalue of
                       LT.LETREC _ => NO
                     | _ => (if is_shiftable funvalue
                               then
                                 (
                                  YES funvalue)
                             else
                               (
                                NO))
                 in
                   NewHashTable.update(correctformtable,fnvar,correct_form);
                   correct_form
                 end
             | LT.NewHashTable.NO => NO)
        
      fun deal_with_inlining (fnvar,construct_arg,default_expr,tys) =
        let
	in
          case has_correct_form fnvar of
            YES funvalue =>
              let
                val _ = attempted := !attempted + 1
                val (applicable,arg,inline_attempt,make_result) = construct_arg (funvalue,tys)
              in
                if applicable
                  then
                    let
                      val (try,done_before,expansion,bother_to_test) =  
                        try_to_inline (fnvar,arg,funvalue)
                    in
                      if try
                        then
                          if done_before
                            then
                               LS.rename_fresh (make_result expansion)
                          else 
                            let
                              val inlined = 
                                optimisesub (optimiseinfo,
                                             inline_attempt)
                            in
                              if cost_expr inlined < (!max_func_dup 
                                                      + Lists.reducel(fn (x,y) => x + cost_expr y) (0,arg))
                                then (if !debug_inlineability andalso not(bother_to_test)
                                        then output(std_out,"*** Test heuristic failed\n")
                                      else ();
                                        success := !success + 1;
                                        NewHashTable.update(inlinetable,(fnvar,arg),(true,true,inlined,true));
                                        make_result inlined)
                              else (NewHashTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                                    default_expr)
                            end
                      else
                        (heuristic_disallowed := !heuristic_disallowed + 1 ; 
                         NewHashTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                         default_expr)
                    end
                else default_expr
              end
          | NO => default_expr
	end 

      fun inline generate_recipes (expr as LT.APP(LT.VAR fnvar,[arg], ty)) = 
        deal_with_inlining (fnvar,
                            fn (funvalue,[ty]) => 
                            (true,
                             [arg],
                             case funvalue of
                               LT.FN([var],body,_,ty',_) =>
                                 (if generate_recipes then
                                    case ty of
                                      Option.PRESENT(ref(ty))=>
                                       (let
                                          val (ty',_) = Types.argres(ty')
                                        in
                                          substitute_types (Unify.unified(Types.Options.default_options,
                                                                          ty,ty',true))
                                        end
                                        handle Types.ArgRes => fn lexp=>lexp)
                                    | _ => fn lexp=>lexp
                                  else
                                    fn lexp=>lexp)
                                      (LS.rename_fresh
                                       (LT.LET((var,LT.Option.ABSENT,arg),body)))
                               | LT.FN(varlist,body,_,ty',_) =>
                                 Crash.impossible "Varlist in inline"
                               | _ => LT.APP(LS.rename_fresh funvalue,[arg], ty), fn x => x)
                             | _ => (false,[arg],arg,fn x => x),
                            expr,
                            [ty])

        | inline generate_recipes (expr as LT.APP _) =
          let
            fun get_fn_var_and_apps(LT.APP(x,[y],ty),acc) = get_fn_var_and_apps(x,(y,ty)::acc)
              | get_fn_var_and_apps(LT.APP(x,y,ty),acc) = Crash.impossible "Arglist in get_fn_var_and_apps"
              | get_fn_var_and_apps(body,acc) = (body,acc)
            fun get_fns(LT.FN([x],y,_,ty,_),acc) = get_fns(y,(x,ty)::acc)
              | get_fns(LT.FN(_,y,_,ty,_),acc) = Crash.impossible "Varlist in get_fns"
              | get_fns(body,acc) = (body,acc)
          in
            case get_fn_var_and_apps(expr,[]) of
              (LT.VAR fnvar,args) =>
                let
                  fun construct_arg (body as LT.FN _,_) =
                    let
                      val (body',fn_bindings) = get_fns(body,[])
                      fun construct(body,[],[]) = body
                        | construct(body,(h,ty')::t,(a,ty)::b) =
                          construct((if generate_recipes then
                                       case ty of
                                         Option.PRESENT(ref(ty))=>
                                          (let
                                             val (ty',_) = Types.argres(ty')
                                           in
                                             substitute_types (Unify.unified(Types.Options.default_options,
                                                                             ty,ty',true))
                                           end
                                           handle Types.ArgRes => fn lexp=>lexp)
                                       | _ => fn lexp=>lexp
                                     else
                                       fn lexp=>lexp) (LT.LET((h,LT.Option.ABSENT,a),body)),t,b)
                        | construct _ = 
                          Crash.impossible "In inlining code in _optimise-beta"
                    in
                      if Lists.length(fn_bindings) = Lists.length(args)
                        then
                          (true,
                           map (fn (arg,_)=>arg) args,
                           LS.rename_fresh(construct(body',rev fn_bindings,args)),
                           fn x => x)
                      else 
                        (false,[body],body,fn x => x)
                    end
                    | construct_arg (body,_) = (false,[body],body,fn x => x)
                in
                  deal_with_inlining (fnvar,
                                      construct_arg,
                                      expr,
                                      [LT.null_type_annotation])           
                end
            | _ => expr
          end

        | inline _ expr = expr

    in
      (let
        val result = LS.apply_innermost (inline generate_recipes) input_expression
      in
         (if !print_hash_table_stats
            then (output(std_out,"InLineTable in _optimise_beta: " ^
                         NewHashTable.string_hash_table_stats(inlinetable) ^ "\n");
                  output(std_out,"ExprSizeTable in _optimise_beta: " ^
                         NewHashTable.string_hash_table_stats(exprsizetable) ^ "\n");
                  output(std_out,"CorrectFormTable in _optimise_beta: " ^
                         NewHashTable.string_hash_table_stats(correctformtable) ^ "\n"))
              else ();
                result)
      end)
    end
  
  
end (* of functor *)


@


1.48
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d211 1
a211 1
	    fun aug((bindings,bindings_as_list), LT.LET(var,_,arg,_)) =
d255 1
a255 1
	      | remove (nes, LT.STRUCT lel) = Lists.reducel remove (nes,lel)
d353 2
a354 2
             | substitute_types(LT.LET(lv,info,lexp1,lexp2)) =
               LT.LET(lv,info,substitute_types lexp1,substitute_types lexp2)
d367 1
a367 1
             | substitute_types(LT.STRUCT(lexps)) = LT.STRUCT(map substitute_types lexps)
d414 1
a414 1
       fun select_field fieldlist {index, size} =
d462 1
a462 1
                 abs_app(LT.LET(var',LT.Option.ABSENT,arg,expr'), rest, rest', var'::vars)
d468 1
a468 1
	    fun mkField i = {index = i, size = size_of_struct}
d470 1
a470 1
	    val args = map (select_field fields) selects
d475 1
a475 1
	    val newstruct = LT.STRUCT(map LT.VAR newvars)
d520 1
a520 1
            (beta false (LT.LET(var,LT.Option.ABSENT,arg,body)))
d522 2
a523 2
        handle Types.ArgRes => beta false (LT.LET(var,LT.Option.ABSENT,arg,body))
        else beta false (LT.LET(var,LT.Option.ABSENT,arg,body))
d526 1
a526 1
         beta false (LT.LET(var,LT.Option.ABSENT,arg,body))
d531 1
a531 1
      | beta _ (LT.APP(LT.LET(var1,info,bind,LT.FN([var2],body,_,ty,_)),[arg],Option.PRESENT(ref(ty')))) =
d536 1
a536 1
              (beta false (LT.LET(var2,LT.Option.ABSENT,arg,body)))
d538 1
a538 1
            beta false (LT.LET(var1,info,bind,inner_let))
d542 1
a542 1
            val inner_let = beta false (LT.LET(var2,LT.Option.ABSENT,arg,body))
d544 1
a544 1
            beta false (LT.LET(var1,info,bind,inner_let))
d548 1
a548 1
            val inner_let = beta false (LT.LET(var2,LT.Option.ABSENT,arg,body))
d550 1
a550 1
            beta false (LT.LET(var1,info,bind,inner_let))
d553 1
a553 1
      | beta _ (lexp as LT.APP(LT.LET(var1,info,bind,LT.FN([var2],body,_,_,_)),[arg],_)) =
d555 1
a555 1
	  val inner_let = beta false (LT.LET(var2,LT.Option.ABSENT,arg,body))
d557 1
a557 1
	  beta false (LT.LET(var1,info,bind,inner_let))
d560 1
a560 1
      | beta _ (lexp as LT.APP(LT.LET(var1,info,bind,LT.FN(varlist,body,_,_,_)),[arg],_)) =
d565 1
a565 1
      | beta _ (original as LT.APP(func, [LT.LET(var,info,bind,body)], ty)) =
d567 1
a567 1
	  then LT.LET(var,info,bind,LT.APP(func,[body],ty)) (* can't reduce it *)
d572 2
a573 2
          fun push_down_lets(LT.LET(var,info,bind,body)) = 
            LT.LET(var,info,bind,push_down_lets(body))
d579 2
a580 2
                LT.LET(new_var',LT.Option.ABSENT,other,
                       LT.LET(new_var,LT.Option.ABSENT,arg,
d587 1
a587 1
      | beta _ (original as LT.LET(var,info,s as LT.STRUCT fields,body)) =
d642 1
a642 1
      | beta2 (original as (LT.LET(var,info,arg,body))) =
d902 1
a902 1
                                       (LT.LET(var,LT.Option.ABSENT,arg,body)))
d939 1
a939 1
                                       fn lexp=>lexp) (LT.LET(h,LT.Option.ABSENT,a,body)),t,b)
@


1.47
log
@Removed some debugging stuff
@
text
@d4 3
d208 1
a208 3
	    fun aug((bindings,bindings_as_list), LT.LET(var,arg,_)) =
              let val var = LT.fetch_var var
              in
a209 1
              end
d212 1
a212 1
                   val lvl = map LT.fetch_var lvl
d350 2
a351 2
             | substitute_types(LT.LET(lv,lexp1,lexp2)) =
               LT.LET(lv,substitute_types lexp1,substitute_types lexp2)
d459 1
a459 1
                 abs_app(LT.LET(LT.Option.SOME1(var'),arg,expr'), rest, rest', var'::vars)
d517 1
a517 1
            (beta false (LT.LET(LT.Option.SOME1(var),arg,body)))
d519 2
a520 2
        handle Types.ArgRes => beta false (LT.LET(LT.Option.SOME1(var),arg,body))
        else beta false (LT.LET(LT.Option.SOME1(var),arg,body))
d523 1
a523 1
         beta false (LT.LET(LT.Option.SOME1(var),arg,body))
d528 1
a528 1
      | beta _ (LT.APP(LT.LET(var1,bind,LT.FN([var2],body,_,ty,_)),[arg],Option.PRESENT(ref(ty')))) =
d533 1
a533 1
              (beta false (LT.LET(LT.Option.SOME1(var2),arg,body)))
d535 1
a535 1
            beta false (LT.LET(var1,bind,inner_let))
d539 1
a539 1
            val inner_let = beta false (LT.LET(LT.Option.SOME1(var2),arg,body))
d541 1
a541 1
            beta false (LT.LET(var1,bind,inner_let))
d545 1
a545 1
            val inner_let = beta false (LT.LET(LT.Option.SOME1(var2),arg,body))
d547 1
a547 1
            beta false (LT.LET(var1,bind,inner_let))
d550 1
a550 1
      | beta _ (lexp as LT.APP(LT.LET(var1,bind,LT.FN([var2],body,_,_,_)),[arg],_)) =
d552 1
a552 1
	  val inner_let = beta false (LT.LET(LT.Option.SOME1(var2),arg,body))
d554 1
a554 1
	  beta false (LT.LET(var1,bind,inner_let))
d557 1
a557 1
      | beta _ (lexp as LT.APP(LT.LET(var1,bind,LT.FN(varlist,body,_,_,_)),[arg],_)) =
d562 1
a562 1
      | beta _ (original as LT.APP(func, [LT.LET(var,bind,body)], ty)) =
d564 1
a564 1
	  then LT.LET(var,bind,LT.APP(func,[body],ty)) (* can't reduce it *)
d569 2
a570 2
          fun push_down_lets(LT.LET(var,bind,body)) = 
            LT.LET(var,bind,push_down_lets(body))
d576 2
a577 2
                LT.LET(LT.Option.SOME1(new_var'),other,
                       LT.LET(LT.Option.SOME1(new_var),arg,
d584 2
a585 4
      | beta _ (original as LT.LET(var,s as LT.STRUCT fields,body)) =
        let val var = LT.fetch_var var
        in
          if get_count var > 1
a597 1
        end
d608 1
a608 1
        val vars = map LT.fetch_var vars
d639 1
a639 1
      | beta2 (original as (LT.LET(var,arg,body))) =
a640 1
          val var = LT.fetch_var var
d899 1
a899 1
                                       (LT.LET(LT.Option.SOME1(var),arg,body)))
d936 1
a936 1
                                       fn lexp=>lexp) (LT.LET(LT.Option.SOME1(h),a,body)),t,b)
@


1.46
log
@Functions and applications take a list of parameters
@
text
@d4 3
d180 3
a182 1
    
d690 1
a690 5
		 0 => (info ("non-shiftable isn't in body -"^
			     "can't reduce away v"^
			     (LT.printLVar var));
                       (* LS.print_deletion_message arg; *)
		       original)
a693 3
		       val _ = info ("non-shiftable occurs once: v"^
				     (LT.printLVar var))

d716 2
a717 4
			 Reduce => (info "<reduced it>";
				    reduce_for_one_occurrence (fn () => increment_count(var,~1),arg,body))
		       | _ => 	   (info "<given up>";
				    original)
d721 1
a721 4
	       | more => (info ("non-shiftable appears more than once: "^
				(LT.printLVar var));

			  original)) (* could test for a subset which _can_ *)
d813 1
a813 2
        (info "into correctform\n";
         case NewHashTable.tryLookup(correctformtable,fnvar) of
d821 1
a821 3
                       LT.LETREC _ => 
                         (info "correct form returns false\n";
                          NO)
d824 1
a824 1
                                 (info "correct form returns true\n";
d827 1
a827 1
                               (info "correct form returns false\n";
a836 1
          val _ = info ("deal_with_inlining for " ^ LT.printLVar fnvar ^ "\n")
a840 1
                val _ = info "has the correct form\n"
a846 1
                      val _ = info "applicable\n"
d854 1
a854 3
                              (info("inlined function for v"^
                                    (LT.printLVar fnvar) ^ " cached from once before");
                               LS.rename_fresh (make_result expansion))
a856 1
                              val _ = info "try and not done_before\n"
d863 1
a863 3
                                then (info("inlined function for v"^
                                           (LT.printLVar fnvar));
                                      if !debug_inlineability andalso not(bother_to_test)
a912 1
            val _ = info "Trying a curry inline\n"
a922 1
                  val _ = info "entering \n"
d960 1
a960 2
            | _ => (info "not entering\n";
                    expr)
@


1.45
log
@Added handles for cases of incorrect type information.
@
text
@d4 3
d230 3
a232 1
	    fun getk (knowns, (_, LT.FN(var,_,_,_,_))) = knowns ++ (var)
d244 3
a246 1
	    fun remove (nes, LT.FN(var, _,_,_,_)) = nes -- (var)
d266 1
a266 1
	      fun shift_bodies(acc, (var, LT.FN(var',body,_,_,_))) =
d270 2
d341 4
a344 2
           fun substitute_types(LT.FN(lv,lexp,name,ty,i)) =
             LT.FN(lv,substitute_types lexp,name,Unify.apply(S,ty),i)
d349 4
a352 4
             | substitute_types(LT.APP(lexp1,lexp2,Option.PRESENT(ref(ty)))) =
               LT.APP(substitute_types lexp1,substitute_types lexp2,Option.PRESENT(ref(Unify.apply(S,ty))))
             | substitute_types(LT.APP(lexp1,lexp2,_)) =
               LT.APP(substitute_types lexp1,substitute_types lexp2,Option.ABSENT)
d499 1
a499 1
      | beta _ (expression as LT.FN(var,LT.APP(result as LT.FN _,LT.VAR var',_),_,_,_)) =
d506 1
a506 1
      | beta _ (LT.APP(LT.FN(var,body,_,ty,_),arg,Option.PRESENT(ref(ty')))) =
d517 1
a517 1
      | beta _ (lexp as LT.APP(LT.FN(var,body,_,_,_),arg,_)) =
d520 4
a523 1
      | beta _ (LT.APP(LT.LET(var1,bind,LT.FN(var2,body,_,ty,_)),arg,Option.PRESENT(ref(ty')))) =
d545 1
a545 1
      | beta _ (lexp as LT.APP(LT.LET(var1,bind,LT.FN(var2,body,_,_,_)),arg,_)) =
d552 3
d557 1
a557 1
      | beta _ (original as LT.APP(func, LT.LET(var,bind,body), ty)) =
d559 1
a559 1
	  then LT.LET(var,bind,LT.APP(func,body,ty)) (* can't reduce it *)
d562 1
a562 1
      | beta _ (LT.APP(sub_let as LT.LET _,arg,ty)) =
d573 1
a573 1
                              LT.APP(LT.VAR new_var',LT.VAR new_var,ty)))
d900 1
a900 1
      fun inline generate_recipes (expr as LT.APP(LT.VAR fnvar, arg, ty)) = 
d906 1
a906 1
                               LT.FN(var,body,_,ty',_) =>
d922 3
a924 4
                             | _ => LT.APP(LS.rename_fresh
                                           funvalue, arg,
                                           ty),
                                 fn x => x)
d926 2
a927 2
                               expr,
                               [ty]) 
d932 2
a933 1
            fun get_fn_var_and_apps(LT.APP(x,y,ty),acc) = get_fn_var_and_apps(x,(y,ty)::acc)
d935 2
a936 1
            fun get_fns(LT.FN(x,y,_,ty,_),acc) = get_fns(y,(x,ty)::acc)
@


1.44
log
@Type Information Preservation in beta reduction for recipe generation by type
unification and substitution in lambda expressions.
@
text
@d4 4
d503 1
d518 6
d893 1
a893 1
                                        let
d899 1
d933 1
a933 1
                                           let
d939 1
@


1.43
log
@Changed eta reduction to be valid only when reducing to a function,
thus preserving names etc.
@
text
@d4 4
d106 2
d119 2
d124 2
d139 1
d326 28
d397 3
a399 2
    fun heuristic_beta_reduce (LT.Info{bindings,is_shiftable,
				       is_commutative,...}, expression) =
d491 28
a518 2
      | beta _ (LT.APP(LT.FN(var,body,_,_,_),arg,_)) =
	beta false (LT.LET(LT.Option.SOME1(var),arg,body))
d520 1
a520 1
      | beta _ (LT.APP(LT.LET(var1,bind,LT.FN(var2,body,_,_,_)),arg,_)) =
d745 1
a745 1
  fun function_inline optimisesub 
d872 1
a872 1
      fun inline (expr as LT.APP(LT.VAR fnvar, arg,ty)) = 
d878 15
a892 3
                               LT.FN(var,body,_,_,_) =>
                                 LS.rename_fresh
                                 (LT.LET(LT.Option.SOME1(var),arg,body))
d901 1
a901 1
        | inline (expr as LT.APP _) =
d904 1
a904 1
            fun get_fn_var_and_apps(LT.APP(x,y,_),acc) = get_fn_var_and_apps(x,y::acc)
d906 1
a906 1
            fun get_fns(LT.FN(x,y,_,_,_),acc) = get_fns(y,x::acc)
d917 13
a929 2
                        | construct(body,h::t,a::b) =
                          construct(LT.LET(LT.Option.SOME1(h),a,body),t,b)
d936 1
a936 1
                           args,
d953 1
a953 1
        | inline expr = expr
d957 1
a957 1
        val result = LS.apply_innermost inline input_expression
@


1.42
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d442 1
a442 1
      (* eta reduction *)
d444 1
a444 1
      | beta _ (expression as LT.FN(var,LT.APP(result,LT.VAR var',_),_,_,_)) =
@


1.41
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d4 4
d208 1
a208 1
	    fun getk (knowns, (_, LT.FN(var,_,_,_))) = knowns ++ (var)
d220 1
a220 1
	    fun remove (nes, LT.FN(var, _,_,_)) = nes -- (var)
d240 1
a240 1
	      fun shift_bodies(acc, (var, LT.FN(var',body,_,_))) =
d440 1
a440 1
      | beta _ (expression as LT.FN(var,LT.APP(result,LT.VAR var',_),_,_)) =
d447 1
a447 1
      | beta _ (LT.APP(LT.FN(var,body,_,_),arg,_)) =
d450 1
a450 1
      | beta _ (LT.APP(LT.LET(var1,bind,LT.FN(var2,body,_,_)),arg,_)) =
d808 1
a808 1
                               LT.FN(var,body,_,_) =>
d824 1
a824 1
            fun get_fns(LT.FN(x,y,_,_),acc) = get_fns(y,x::acc)
@


1.41.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.41  1993/07/30  14:42:26  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.40
log
@Removed integer parameter
@
text
@d4 3
d175 2
d178 1
d180 12
a191 7
                Lists.reducel
                (fn ((current_bindings,list_of_bindings),(lvl,exp)) =>
                 ((LT.NewHashTable.update(current_bindings,lvl,exp);current_bindings),
                  (lvl,exp)::list_of_bindings))
		((bindings,bindings_as_list),
                 Lists.zip(lvl,
                           lel (* map (fn exp=>LT.LETREC([],[],exp)) lel *)))
d204 1
a204 1
	    fun getk (knowns, (_, LT.FN(var,_,_,_))) = knowns ++ var
d216 1
a216 1
	    fun remove (nes, LT.FN(var, _,_,_)) = nes -- var
d391 1
a391 1
                 abs_app(LT.LET(var',arg,expr'), rest, rest', var'::vars)
a436 1
	
d444 1
a444 1
	beta false (LT.LET(var,arg,body))
d448 1
a448 1
	  val inner_let = beta false (LT.LET(var2,arg,body))
d469 2
a470 2
                LT.LET(new_var',other,
                       LT.LET(new_var,arg,
d478 2
d493 1
d504 1
d537 1
a537 1

d800 11
a810 10
                            fn (funvalue,[ty]) => (true,
                                                   [arg],
                                                   case funvalue of
                                                     LT.FN(var,body,_,_) =>
                                                       LS.rename_fresh
                                                       (LT.LET(var,arg,body))
                                                   | _ => LT.APP(LS.rename_fresh
                                                                 funvalue, arg,
                                                                 ty),
                                                       fn x => x)
d832 1
a832 1
                          construct(LT.LET(h,a,body),t,b)
d850 1
a850 1
                                      [LT.null_type_annotation])
@


1.39
log
@Signature revisions
@
text
@d4 3
a88 1
require "../utils/integer";
a97 1
  structure Integer : INTEGER
@


1.38
log
@Commented out calls to print_deletion_message.
,.
@
text
@d4 4
d115 1
a115 1
  structure Ident = LT.Datatypes.Ident
d834 1
a834 1
                                      [LT.Datatypes.NULLTYPE])           
@


1.37
log
@Added some LETREC optimisation
@
text
@d4 3
d486 1
a486 1
        fun print_deletion_messages x = Lists.iterate LS.print_deletion_message x
d490 1
a490 1
            (print_deletion_messages args;
d510 1
a510 1
              (print_deletion_messages args;
d543 1
a543 1
                   LS.print_deletion_message arg;
d567 1
a567 1
                       LS.print_deletion_message arg;
@


1.36
log
@Changes for the newhashtables
@
text
@d4 3
a424 3

      (* convert APP(FN _,_) and APP(LET .. FN _ , _) into LETs *)

d481 1
a481 1
    and beta2 (original as (LT.LET(var,arg,body))) =
d483 32
d516 1
a516 1
        val occurs = get_count var 
a528 1
(*            val xx = (LS.substitute_for_exactly_one_occurrence_not_in_functions (var,arg,body)) *)
d539 3
a541 1
             0 => (adjust_counts (~1,arg) ; body)
d564 1
@


1.35
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d336 1
a336 1
      fun adjuster_function v =
@


1.34
log
@Curry optimisation and removal of handles of hash table lookup exceptions
@
text
@d4 3
d90 1
a90 2
  sharing type LambdaPrint.LambdaTypes.BindingTable.Key = LambdaPrint.LambdaTypes.LVar
  sharing type LambdaPrint.LambdaTypes.BindingTable.Value = LambdaPrint.LambdaTypes.LambdaExp
d103 1
d144 1
a144 1
  val basic_info = LT.Info{bindings = LT.BindingTable.new (),
d158 1
a158 1
              ((LT.BindingTable.update(bindings,var,arg);bindings),(var,arg)::bindings_as_list)
d162 1
a162 1
                 ((LT.BindingTable.update(current_bindings,lvl,exp);current_bindings),
d170 1
a170 1
	    LS.reduce_outermost aug ((LT.BindingTable.new(),[]),expr)
a323 10
       structure OccCountHashTable =
         NewHashTable(
           structure Crash = Crash
           structure Lists = Lists
           type Key    = LambdaSub.LT.LVar
           type Value  = int
           val size    = 100
           val hash = LambdaSub.LT.int_of_LVar
           val eq = LambdaSub.LT.LVar_eq)

d331 1
a331 1
      val occ_count_hash_table = OccCountHashTable.new()
d336 1
a336 1
           val x = OccCountHashTable.lookup(occ_count_hash_table,var)
d338 1
a338 1
           (OccCountHashTable.update(occ_count_hash_table,var,x+v);
d344 1
a344 1
        OccCountHashTable.lookup_default(occ_count_hash_table,0,var) 
d347 1
a347 1
        OccCountHashTable.update(occ_count_hash_table,var,n + get_count var)
d386 1
a386 1
                (OccCountHashTable.update(occ_count_hash_table,var,0);
d580 1
a580 1
                    OccCountHashTable.string_hash_table_stats(occ_count_hash_table) ^ "\n")
a604 22
  structure InlineTable = 
    NewHashTable(
           structure Crash = Crash
           structure Lists = Lists
           type Key    = LT.LVar * LT.LambdaExp list
           type Value  = bool * bool * LT.LambdaExp * bool
           val size    = 32
           val hash = (fn (x,y) => LT.int_of_LVar x )
           val eq = fn ((var,exp),(var',exp')) => LT.LVar_eq(var,var') 
             andalso all_lambda_equal(exp,exp'))


  structure ExprSizeTable = 
    NewHashTable(
           structure Crash = Crash
           structure Lists = Lists
           type Key    = LT.LVar 
           type Value  = bool
           val size    = 32
           val hash = LT.int_of_LVar
           val eq = LT.LVar_eq)
             
a606 10
  structure CorrectFormTable = 
    NewHashTable(
           structure Crash = Crash
           structure Lists = Lists
           type Key    = LT.LVar 
           type Value  = LT.LambdaExp my_option
           val size    = 32
           val hash = LT.int_of_LVar
           val eq = LT.LVar_eq)
    
d620 6
a625 3
      val inlinetable = InlineTable.new()
      val exprsizetable = ExprSizeTable.new()
      val correctformtable = CorrectFormTable.new()
d630 3
a632 3
        case ExprSizeTable.tryLookup(exprsizetable,var) of
          ExprSizeTable.YES res => res
        | ExprSizeTable.NO => 
d636 1
a636 1
              ExprSizeTable.update(exprsizetable,var,flag);
d641 2
a642 2
        case InlineTable.tryLookup (inlinetable,(var,arg)) of
          InlineTable.YES result => 
d645 1
a645 1
        | InlineTable.NO => 
d660 5
a664 5
         case CorrectFormTable.tryLookup(correctformtable,fnvar) of
           CorrectFormTable.YES res => res
         | CorrectFormTable.NO  =>
             case LT.BindingTable.tryLookup(bindings,fnvar) of
               LT.BindingTable.YES funvalue => 
d679 1
a679 1
                   CorrectFormTable.update(correctformtable,fnvar,correct_form);
d682 1
a682 1
             | LT.BindingTable.NO => NO)
d724 1
a724 1
                                        InlineTable.update(inlinetable,(fnvar,arg),(true,true,inlined,true));
d726 1
a726 1
                              else (InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
d731 1
a731 1
                         InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
d804 1
a804 1
                         InlineTable.string_hash_table_stats(inlinetable) ^ "\n");
d806 1
a806 1
                         ExprSizeTable.string_hash_table_stats(exprsizetable) ^ "\n");
d808 1
a808 1
                         CorrectFormTable.string_hash_table_stats(correctformtable) ^ "\n"))
@


1.33
log
@Do inlining of curried function applications
@
text
@d4 3
d351 1
a351 1
        OccCountHashTable.lookup(occ_count_hash_table,var) handle OccCountHashTable.Lookup _ => 0
d634 2
d641 1
a641 1
           type Value  = bool * LT.LambdaExp
d666 9
a674 8
        ExprSizeTable.lookup(exprsizetable,var) handle 
        ExprSizeTable.Lookup _ => 
          let
            val flag = LS.size_of_expr_is_smaller_than(funvalue,threshold)
          in
            ExprSizeTable.update(exprsizetable,var,flag);
            flag
          end
d677 15
a691 16
        (let
          val result = InlineTable.lookup (inlinetable,(var,arg))
        in
           cache_hit := !cache_hit + 1;
           result
        end)
           handle InlineTable.Lookup _ => 
             let 
               (* Pre-heuristic for testing inlineability - if false, we don't bother to try *)
               (* another idea is to look at the arg - *)
               (* if it isn't a variable or is a variable with no binding, then inlining is more likely to be worth while *)
               val bother_to_test = expression_smaller_than(var,funvalue,! test_for_inlineability_threshold)
             in
               (bother_to_test orelse !debug_inlineability,
                false,dummy_form,bother_to_test)
             end
d696 23
a718 22
        CorrectFormTable.lookup(correctformtable,fnvar) 
        handle _ =>
          let
            val _ = info "failed to find\n"
            val funvalue = LT.BindingTable.lookup(bindings,fnvar)
            val correct_form = 
              case funvalue of
                LT.LETREC _ => 
                  (info "correct form returns false\n";
                   false)
              | _ => (if is_shiftable funvalue
                        then
                          (info "correct form returns true\n";
                           true)
                      else
                        (info "correct form returns false\n";
                         false))
            val pair = (correct_form,funvalue)
          in
            CorrectFormTable.update(correctformtable,fnvar,pair);
            pair
          end)
d721 1
a721 1
        (let
a722 1
          val (correct_form,funvalue) = has_correct_form fnvar
d724 50
a773 53
           if correct_form
             then
               let
                 val _ = info "has the correct form\n"
                 val _ = attempted := !attempted + 1
                 val (applicable,arg,inline_attempt,make_result) = construct_arg (funvalue,tys)
               in
                 if applicable
                   then
                     let
                       val _ = info "applicable\n"
                       val (try,done_before,expansion,bother_to_test) =  
                         try_to_inline (fnvar,arg,funvalue)
                     in
                       if try
                         then
                           if done_before
                             then
                               (info("inlined function for v"^
                                     (LT.printLVar fnvar) ^ " cached from once before");
                                LS.rename_fresh (make_result expansion))
                           else 
                             let
                               val _ = info "try and not done_before\n"
                               val inlined = 
                                 optimisesub (optimiseinfo,
                                              inline_attempt)
                             in
                               if cost_expr inlined < (!max_func_dup 
                                                       + Lists.reducel(fn (x,y) => x + cost_expr y) (0,arg))
                                 then (info("inlined function for v"^
                                            (LT.printLVar fnvar));
                                       if !debug_inlineability andalso not(bother_to_test)
                                         then output(std_out,"*** Test heuristic failed\n")
                                       else ();
                                         success := !success + 1;
                                         InlineTable.update(inlinetable,(fnvar,arg),(true,true,inlined,true));
                                         make_result inlined)
                               else (InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                                     default_expr)
                             end
                       else
                         (heuristic_disallowed := !heuristic_disallowed + 1 ; 
                          InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                          default_expr)
                     end
                 else default_expr
               end
          else
            default_expr
	end handle LT.BindingTable.Lookup _ => default_expr)        

           
@


1.32
log
@Changed the heuristic parameters for function inlining to make it
less aggressive
@
text
@d4 4
d160 1
a160 1
                           map (fn exp=>LT.LETREC([],[],exp)) lel))
d443 17
d498 2
a499 1
            val xx = (LS.substitute_for_exactly_one_occurrence_not_in_functions (var,arg,body))
d603 6
d613 1
a613 1
           type Key    = LT.LVar * LT.LambdaExp
d617 2
a618 1
           val eq = fn ((var,exp),(var',exp')) => LT.LVar_eq(var,var') andalso LS.lambda_equality(exp,exp'))
d688 27
a714 1
      fun inline (expr as LT.APP(LT.VAR fnvar, arg,ty)) = 
d716 5
a720 3
           val (correct_form,funvalue) =
             CorrectFormTable.lookup(correctformtable,fnvar) 
             handle _ =>
d722 3
a724 6
                 val funvalue = LT.BindingTable.lookup(bindings,fnvar)
                 val correct_form = 
                   case funvalue of
                     LT.LETREC _ => false
                   | _ => is_shiftable funvalue
                 val pair = (correct_form,funvalue)
d726 40
a765 2
                 CorrectFormTable.update(correctformtable,fnvar,pair);
                 pair
a766 45
	in
          if correct_form
            then
              let
                val _ = attempted := !attempted + 1
                val (try,done_before,expansion,bother_to_test) =  
                  try_to_inline (fnvar,arg,funvalue)
              in
                if try
                  then
                    if done_before
                      then
                        (info("inlined function for v"^
                              (LT.printLVar fnvar) ^ " cached from once before");
                         LS.rename_fresh expansion)
                    else 
                      let
                      val inlined = 
		       optimisesub (optimiseinfo,
				    case funvalue of
				      LT.FN(var,body,_,_) =>
					LS.rename_fresh
					 (LT.LET(var,arg,body))
				    | _ => LT.APP(LS.rename_fresh
						  funvalue, arg,
						  ty))
                      in
                        if cost_expr inlined < (!max_func_dup 
                                                + cost_expr arg)
                          then (info("inlined function for v"^
                                     (LT.printLVar fnvar));
                                if !debug_inlineability andalso not(bother_to_test)
                                  then output(std_out,"*** Test heuristic failed\n")
                                else ();
                                  success := !success + 1;
                                  InlineTable.update(inlinetable,(fnvar,arg),(true,true,inlined,true));
                                  inlined)
                        else (InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                              expr)
                      end
                else
                  (heuristic_disallowed := !heuristic_disallowed + 1 ; 
                   InlineTable.update(inlinetable,(fnvar,arg),(false,false,dummy_form,true));
                   expr)
              end
d768 62
a829 2
            expr
	end handle LT.BindingTable.Lookup _ => expr)
@


1.31
log
@Removed some redundant structures and sharing
@
text
@d4 3
d253 1
a253 1
  val max_func_dup     = ref 500;      (*  space from duplicating fn's      *)
d614 1
a614 1
  val test_for_inlineability_threshold = ref(200)
@


1.30
log
@Changed the bindingtable to be a hashtable
@
text
@d4 3
a62 1
require "../basics/ident";
a72 1
  structure Ident : IDENT
a76 1
  sharing Ident = LambdaPrint.LambdaTypes.Ident
d89 2
a90 1
  structure Set = LambdaSub.Set
@


1.29
log
@Modified to use the new hashtables
@
text
@d4 3
d77 2
d130 1
a130 1
  val basic_info = LT.Info{bindings = LT.BindingTable.empty (),
d144 1
a144 1
              (LT.BindingTable.define(bindings,var,arg),(var,arg)::bindings_as_list)
d148 1
a148 1
                 (LT.BindingTable.define(current_bindings,lvl,exp),
a153 3
(*	      | aug((bindings,bindings_as_list), LT.APP(LT.FN(var,_,_,_),arg,_)) = 
              (LT.BindingTable.define(bindings,var,arg),(var,arg)::bindings_as_list)*)

d156 1
a156 1
	    LS.reduce_outermost aug ((LT.BindingTable.empty(),[]),expr)
d661 1
a661 1
                 val funvalue = LT.BindingTable.apply bindings fnvar
d718 1
a718 1
	end handle LT.BindingTable.Undefined => expr)
@


1.28
log
@Adjusted so that it doesn't substitute into letrecs and fn's
@
text
@d4 3
d55 1
a55 2
require "../utils/hashtable" ;
require "../utils/_hashtable" ;
d71 1
d86 2
a294 32
(* Do the occurrence count using a hashtable and not by repeatedly calling a function *)

    structure OccCountSpec : HASHSPEC =
      struct
        type Key    = LT.LVar
        type Value  = int
        val size    = 300
        val hash = LT.int_of_LVar
        val eq = (op =)
      end

    structure OccCountHashTable = HashTable(OccCountSpec)
      
    fun adjuster_function v =
      (fn (copy as LT.VAR(var)) =>
       let
         val x = OccCountHashTable.lookup(var)
       in
         (OccCountHashTable.update(var,x+v);
          copy)
       end
      | expression => expression)

      fun get_count var =
        OccCountHashTable.lookup(var) handle OccCountHashTable.Lookup _ => 0

      fun increment_count (var,n) =
        OccCountHashTable.update(var,n + get_count var)

        fun adjust_counts (times,body) =
          LS.reduce_innermost (fn (exp,arg) => (adjuster_function times exp; arg)) (body,())  
          
a302 1
    local 
a306 1
    in
d308 38
d380 1
a380 1
                (OccCountHashTable.update(var,0);
a382 1
            val result = LS.substitute (var,newstruct,newexpr)
d385 1
a385 1
            result
d387 1
a387 1
    end (* of local *)
a388 8

 in
    fun heuristic_beta_reduce (LT.Info{bindings,is_shiftable,
				       is_commutative,...}, expression) =
    let
	  

    
a433 13
        let
          
(*  Test code for the hashing of occurrence counts    
        val _ = 
          if LS.occurrences(var,body) = get_count var
            then
              ()
          else
            output(std_out,"***** Hash and occs dont agree (1)\n" ^ LT.printLVar var ^ 
                    " " ^ Integer.makestring(LS.occurrences(var,body)) ^ " " ^ 
                    Integer.makestring(get_count var) ^ "\n")
*)
        in
a446 1
        end
a457 11
(* Test code for the hashtable optimisation   
        val _ = 
          if LS.occurrences(var,body) = get_count var
            then
              ()
          else
            (output(std_out,"***** Hash and occs dont agree\n" ^ LT.printLVar var ^ 
                    " " ^ Integer.makestring(LS.occurrences(var,body)) ^ " " ^ 
                    Integer.makestring(get_count var) ^ "\n");
            LambdaPrint.print_lambda original)
*)
d550 9
d560 1
a560 2
      (OccCountHashTable.clear();
       LS.apply_innermost (beta true) expression)
d575 9
a583 10
  structure InlineTableSpec : HASHSPEC =
    struct
      type Key    = LT.LVar * LT.LambdaExp
      type Value  = bool * bool * LT.LambdaExp * bool
      val size    = 32
      val hash = (fn (x,y) => LT.int_of_LVar x )
      val eq = fn ((var,exp),(var',exp')) => LT.LVar_eq(var,var') andalso LS.lambda_equality(exp,exp')
    end
  
  structure InlineTable = HashTable(InlineTableSpec)
a584 10
  structure ExprSizeTableSpec : HASHSPEC =
    struct
      type Key    = LT.LVar 
      type Value  = bool
      val size    = 32
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq
    end
  
  structure ExprSizeTable = HashTable(ExprSizeTableSpec)
d586 19
a604 10
  structure CorrectFormTableSpec : HASHSPEC =
    struct
      type Key    = LT.LVar 
      type Value  = bool * LT.LambdaExp
      val size    = 32
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq
    end
  
  structure CorrectFormTable = HashTable(CorrectFormTableSpec)
a605 2
  val dummy_form = LT.VAR(LT.new_LVar())

d609 1
a609 10

  fun expression_smaller_than(var,funvalue,threshold) =
    ExprSizeTable.lookup(var) handle 
    ExprSizeTable.Lookup _ => 
      let
        val flag = LS.size_of_expr_is_smaller_than(funvalue,threshold)
      in
        ExprSizeTable.update(var,flag);
        flag
      end
a610 21
  val cache_hit = ref(0)

  fun try_to_inline(var,arg,funvalue) = 
    (let
       val result = InlineTable.lookup (var,arg)
    in
       cache_hit := !cache_hit + 1;
       result
    end)
    handle InlineTable.Lookup _ => 
      let 
        (* Pre-heuristic for testing inlineability - if false, we don't bother to try *)
        (* another idea is to look at the arg - if it isn't a variable or is a variable with no binding, then inlining is more likely to be worth while *)
        val bother_to_test = expression_smaller_than(var,funvalue,! test_for_inlineability_threshold)
      in
        (bother_to_test orelse !debug_inlineability,
         false,dummy_form,bother_to_test)
      end

(* old one *)

d619 34
d656 1
a656 1
             CorrectFormTable.lookup(fnvar) 
d666 1
a666 1
                 CorrectFormTable.update(fnvar,pair);
d704 1
a704 1
                                  InlineTable.update((fnvar,arg),(true,true,inlined,true));
d706 1
a706 1
                        else (InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
d711 1
a711 1
                   InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
a718 4
      val _ = InlineTable.clear()
      val _ = ExprSizeTable.clear()
      val _ = CorrectFormTable.clear()

a721 5
        (* val _ = if !success = 0
                  then ()
                else output(std_out,"Heuristic disallowed " ^ Integer.makestring(!heuristic_disallowed) ^
                            " of the " ^ Integer.makestring(!attempted) ^ " attempts to inline - success in " ^
                            Integer.makestring(!success) ^ " cases (cache hit " ^ Integer.makestring(!cache_hit) ^ ")\n") *)
d723 9
a731 1
        result
a734 104
(*
  fun function_inline optimisesub (optinfo as 
				   LT.Info{bindings,is_shiftable,...},
				   expression) =
   let
     val heuristic_disallowed = ref(0)
     val attempted = ref(0)
     val success = ref(0)
     val _ = cache_hit := 0

     fun do_inline (depth,expression) =
       let fun inline (expr as LT.APP(LT.VAR fnvar, arg, _)) =
	 (let
	    val funvalopt = CorrectFormTable.lookup(fnvar) 
	      handle _ =>
	       let
                 val funvalue = LT.BindingTable.apply bindings fnvar
                 val correct_form = 
                   case funvalue of
                     LT.LETREC _ => LT.ABSENT
                   | _ => if is_shiftable funvalue
			    then LT.PRESENT funvalue
			  else LT.ABSENT
               in
                 CorrectFormTable.update(fnvar,correct_form);
                 correct_form
               end
	in
          case funvalopt of
	    LT.PRESENT funvalue  =>
              let
                val _ = attempted := !attempted + 1
                val (try,done_before,expansion,bother_to_test) =  
                  try_to_inline (fnvar,arg,funvalue)
              in
                if try
                  then
                    if done_before
                      then
                        (info("inlined function for v"^
                              (LT.printLVar fnvar) ^ 
			      " cached from once before");
                         LS.rename_fresh expansion)
                    else 
                      let
 			val new_form = LT.APP(LS.rename_fresh funvalue,arg,
					      LT.null_type_annotation())

(*			val new_form = 
			  case (LS.rename_fresh funvalue) of
			    LT.FN(var,body,_,_) => LT.LET (var,arg,body)
			  | newfun => LT.APP(newfun,arg,
					     LT.null_type_annotation())
*)
			val new_info = optinfo (*augment with new bindings?*)
			val optimised_form = optimisesub (new_info,new_form)
                        val inlined_form = if depth<(!inline_depth)
					    then do_inline(depth+1,optimised_form)
					   else optimised_form
                      in
                        if (cost_expr inlined_form)*depth < 
			   (!max_func_dup + cost_expr arg)
                          then (info("inlined function for v"^
                                     (LT.printLVar fnvar)^" cost inline:"^
				     Integer.makestring((cost_expr inlined_form)*depth)^" limit: "^Integer.makestring(!max_func_dup + cost_expr arg));
                                if !debug_inlineability andalso not(bother_to_test)
                                  then output(std_out,"*** Test heuristic failed\n")
                                else ();
                                  success := !success + 1;
                                  InlineTable.update((fnvar,arg),(true,true,inlined_form,true));
                                  inlined_form)
                        else (InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
                              expr)
                      end
		else
                  (heuristic_disallowed := !heuristic_disallowed + 1 ; 
                   InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
                   expr)
              end
	  | LT.ABSENT => expr
	 end handle LT.BindingTable.Undefined => (CorrectFormTable.update(fnvar,LT.ABSENT);
						  expr))
	    | inline expr = LS.apply_one_level inline expr
      in
	inline expression
      end

      val _ = InlineTable.clear()
      val _ = ExprSizeTable.clear()
      val _ = CorrectFormTable.clear()

    in
      (let
        val result = Timer.time_it("carrying out inlining", fn () => do_inline (1,expression))
        val _ = if !success = 0
                  then ()
                else output(std_out,"Heuristic disallowed " ^ Integer.makestring(!heuristic_disallowed) ^
                            " of the " ^ Integer.makestring(!attempted) ^ " attempts to inline - success in " ^
                            Integer.makestring(!success) ^ " cases (cache hit " ^ Integer.makestring(!cache_hit) ^ ")\n")          
      in
        result
      end)
    end
*)
@


1.27
log
@null_type_annotation is no longer a function
@
text
@d4 3
d396 3
d485 17
a501 4
        fun reduce (arg,body,count) = 
          beta false (LS.substitute_for_at_most_n_occurrences (var,arg,body,count))
        fun reduce_for_one_occurrence (arg,body) = 
          beta false (LS.substitute_for_at_most_one_occurrence (var,arg,body))
d508 2
a509 2
           | 1 =>  (increment_count(var,~1);
                    reduce_for_one_occurrence (arg,body))
d516 5
a520 4
                           increment_count(var,~more);
                           adjust_counts(~1,arg);
                           adjust_counts(more,fresh);
                           reduce (fresh, body,more)
d559 1
a559 2
				    increment_count(var,~1);
				    reduce_for_one_occurrence (arg,body))
@


1.26
log
@Switched off time printouts
@
text
@d4 3
d651 1
a651 1
      fun inline (expr as LT.APP(LT.VAR fnvar, arg,_)) = 
d692 1
a692 1
						  LT.null_type_annotation()))
@


1.25
log
@Added some transformations in beta reduction.
@
text
@d4 3
d720 2
a721 2
        val result = Timer.time_it("carrying out inlining", fn () => LS.apply_innermost inline input_expression)
        val _ = if !success = 0
d725 1
a725 1
                            Integer.makestring(!success) ^ " cases (cache hit " ^ Integer.makestring(!cache_hit) ^ ")\n")          
@


1.24
log
@Tidy up, removed Optimise Lib parameter.
@
text
@d4 3
d12 1
a12 2
general improvements.  WARNING! Still has
problem in heuristic_beta_reduce.
d398 1
a398 3
	  then (info ("eta-redex removed for v"^
		      (LT.printLVar var));
		result  (* redexes inside result dealt with already *))
a400 2
     (* when re-order apps is rationalised, we might switch case order or *)
     (* remove next case.  For now, it converts APP(FN's into LET's.      *)
d402 1
a402 2
      | beta x (LT.APP(LT.FN(var,body,_,_),arg,_)) =
	beta x (LT.LET(var,arg,body))
d404 2
d407 14
d452 1
a452 1
    (*  BETA-reduction in the more general case.  Recurses to reduce   *)
d678 9
a686 5
                        val inlined = 
                          optimisesub (optimiseinfo,
				       LT.APP(LS.rename_fresh
                                              funvalue, arg,
					      LT.null_type_annotation()))
a832 24
  (*************************************************************************)
  (*  Application-Reordering - Transforms Curried Applications into LET's  *)
  (*************************************************************************)

  (* NB:- could look up bindings here too?  Sort it out! *)
  val reorder_apps = fn x=>x
(*     let
	fun apply_app (expr as LT.APP _) = 
	   let 
	      fun wrap (body,(var,arg,annotation,ty)) = (*LT.LET(var,arg,body)*)
LT.APP(LT.FN(var,body,
 if annotation="" 
 then "reorder_apps in _optimise_beta" 
  else annotation,
 ty),arg,LT.null_type_annotation())
	   in
	      Lists.reducel wrap (LS.unwrap_apps expr)
	   end
	  | apply_app expr = expr
     in
	LS.apply_outermost apply_app
     end;
*)

@


1.23
log
@General tidying up.
@
text
@d4 3
d45 1
a46 1
require "optimise_lib";
a55 1
  structure Lib   : OPTIMISE_LIB
d57 3
a59 2
  sharing LambdaPrint.LambdaTypes = Lib.LT
  sharing Ident = Lib.LT.Ident
a64 5
  structure LT = Lib.LT
  structure LS = Lib.LS
  infix ++ -- 
  val op++ = Lib.++
  val op-- = Lib.--
d66 1
a66 3
  val show_debug_info = ref true;
  fun info message =
    if !show_debug_info then Print.print (message ^ "\n") else ()
d68 23
d94 9
d104 1
d110 2
a111 2
			   known_fns = Lib.nullset,
			   non_escaping_fns = Lib.nullset,
d113 2
a114 2
			   is_commutative = LS.is_commutative Lib.nullset,
			   is_associative = LS.is_associative Lib.nullset}
d150 1
a150 1
	    Lists.reducel getk (Lib.nullset, bindings)
d163 1
a163 1
	   Lib.nullset
d185 1
a185 1
	     Lib.fixpoint
d187 1
a187 1
	     (fn s=>Lists.reducel shift_bodies (s,bindings),Lib.nullset)
d190 2
a191 2
      fun get_commutatives bindings = Lib.nullset
      fun get_associatives bindings = Lib.nullset
a575 10
(*
  structure CorrectFormTableSpec : HASHSPEC =
    struct
      type Key    = LT.LVar 
      type Value  = LT.LambdaExp LT.Opt
      val size    = 32
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq
    end
*)  
@


1.22
log
@Added LET constructor and new slot to APP,
general improvements.  WARNING! Still has
problem in heuristic_beta_reduce.
@
text
@d4 5
@


1.21
log
@Altered inlining to be depth limiting and work outermost
(transitory form as improvement is needed).  Removed
commutative re-ordering on beta-reduction, most possible
redexes will be caught by initial rearrangement function.
Other general improvements.
@
text
@d4 7
d70 107
d277 2
a278 4
    (* breakup_struct: expr * expr * expr list -> expr  	          *)
    (* 								  *)
    (*  Abstracts out a new lambda-variable over each component of a    *)
    (*  structure, producing a nested app-fn expression (like let's).   *)
d283 1
a283 1
    (*  non-shiftable components.  					  *)
a285 2


a289 1

d297 1
a297 2
                    LS.beta_abstract_with_count(expr,subx)
		  val expr'' = LT.APP(expr',arg)
d306 1
a306 1
                 abs_app(expr'', rest, rest', var'::vars)
d318 1
a318 1
	    val (expr,newvars) = abs_app (body,rev sub_exprs,rev args,[])
d329 1
a329 1
            val result = LS.substitute (var,newstruct,expr)
a353 8
      | beta _ (expression as LT.FN(var,LT.APP(result,LT.VAR var'),_,_)) =
		if var=var' andalso 
		  get_count(var)=1 andalso 
		     is_shiftable(result)
		       then (info ("eta-redex removed for v"^
				   (LT.printLVar var));
			     result  (* redexes inside result dealt with already *))
		  else expression
d355 20
a374 2
      | beta _ (original as LT.APP(LT.FN(var,body,_,_),
                                   s as LT.STRUCT fields)) =
d410 1
a410 1
    and beta2 (original as (LT.APP(LT.FN(var,body,_,_),arg))) = 
d413 1
a413 1
(* Test code for the hashtable optimisation    
d463 1
a463 1
		       datatype action = Reduce | Give_Up 
a466 2
			     exception Stop of bool
			     
d478 3
a480 2
			     andalso before_nonshifts (body,false)
			       then Reduce
d485 6
a490 5
			  Give_Up => (info "<given up>";
				      original)
			| Reduce => (info "<reduced it>";
                                     increment_count(var,~1);
				     reduce_for_one_occurrence (arg,body))
a511 3
  (******************************************)
  (*  Pre-processing of Lambda Expressions  *)
  (******************************************)
a512 6
  val basic_info = LT.Info{bindings = LT.BindingTable.empty (),
			   known_fns = Lib.nullset,
			   non_escaping_fns = Lib.nullset,
			   is_shiftable = LS.is_shiftable ,
			   is_commutative = LS.is_commutative Lib.nullset,
			   is_associative = LS.is_associative Lib.nullset}
a513 96
  local
      (*  Add bindings for variables to an association list, based on  *)
      (*  the translated form of LET expressions, and LETRECs.         *)

      fun get_bindings expr =
	 let
	    fun aug((bindings,bindings_as_list), LT.APP(LT.FN(var,_,_,_),arg)) = 
              (LT.BindingTable.define(bindings,var,arg),(var,arg)::bindings_as_list)

	      | aug((bindings,bindings_as_list), LT.LETREC(lvl,lel,_)) = (* flag val rec's *)
                Lists.reducel
                (fn ((current_bindings,list_of_bindings),(lvl,exp)) =>
                 (LT.BindingTable.define(current_bindings,lvl,exp),
                  (lvl,exp)::list_of_bindings))
		((bindings,bindings_as_list),
                 Lists.zip(lvl,
                           map (fn exp=>LT.LETREC([],[],exp)) lel))

	      | aug(bindings, _) = bindings
	 in
	    LS.reduce_outermost aug ((LT.BindingTable.empty(),[]),expr)
	 end
								 
      (*  Determine which variables are bound to functions  *)
      (*  (NB:- functions are identified by the lambda-     *)
      (*   variables they bind)				    *)

      fun get_knowns bindings =
	 let
	    fun getk (knowns, (_, LT.FN(var,_,_,_))) = knowns ++ var
	      | getk (knowns, _) = knowns
	 in
	    Lists.reducel getk (Lib.nullset, bindings)
	 end

      (*  Determine which functions can be guaranteed not to escape,  *)
      (*  i.e. can never be seen from or passed outside.  Functions   *)
      (*  are identified by the lambda-variables they bind.           *)

      fun get_non_escapings (expression, known_fns, bindings) =
	 let
	    fun remove (nes, LT.FN(var, _,_,_)) = nes -- var
	      | remove (nes, LT.STRUCT lel) = Lists.reducel remove (nes,lel)
	      | remove _ = Crash.impossible "get_non_escapings(remove)"
	 in
	   Lib.nullset
	 end



      (*  Deduce a set of variables corresponding to functions which are  *)
      (*  shiftable when applied to some argument.  Maximal fixed point   *)
      (*  of a monotonic operator job.  Perhaps later add a simple class  *)
      (*  of recursive functions which can be guaranteed to terminate.    *)

    (* No longer used

      fun get_shiftables bindings =
	  let
	      (* fun get_letrecs x = x *)

	      fun shift_bodies(acc, (var, LT.FN(var',body,_,_))) =
		  if LS.is_shiftable acc body
		      then acc ++ var
		  else acc
		| shift_bodies(acc, _) = acc
	  in
	     Lib.fixpoint
	     op ==
	     (fn s=>Lists.reducel shift_bodies (s,bindings),Lib.nullset)
	  end
*)
      fun get_commutatives bindings = Lib.nullset
      fun get_associatives bindings = Lib.nullset
  in
   fun process_expr expression =
    let
     val (bindings,bindings_as_list) = get_bindings expression
     val known_fns = get_knowns bindings_as_list
     val non_escaping_fns = get_non_escapings (expression, known_fns, bindings_as_list)
    in
       LT.Info{bindings = bindings,
	       known_fns = known_fns,
	       non_escaping_fns = non_escaping_fns,
	       is_shiftable = LS.is_shiftable (* (get_shiftables bindings_as_list) *),
	       is_commutative = LS.is_commutative (get_commutatives bindings),
	       is_associative = LS.is_associative (get_associatives bindings)}
    end

  end (* of local *)






d542 1
d551 9
d598 90
d698 1
a698 1
       let fun inline (expr as LT.APP(LT.VAR fnvar, arg)) =
d727 2
a728 1
                              (LT.printLVar fnvar) ^ " cached from once before");
d732 9
a740 1
			val new_form = LT.APP(LS.rename_fresh funvalue,arg)
d750 2
a751 1
                                     (LT.printLVar fnvar));
d790 1
d796 3
a798 2
  val reorder_apps =
     let
d801 6
a806 6
	      fun wrap (body,(var,arg,annotation,ty)) = 
                LT.APP(LT.FN(var,body,
                             if annotation="" 
                               then "reorder_apps in _optimise_beta" 
                             else annotation,
                               ty),arg)
d814 1
a814 1

@


1.20
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d4 3
a12 54
Revision 1.17  1992/04/30  16:04:16  clive
More work on speeding up function inlining

Revision 1.16  1992/04/28  11:24:51  clive
Used hash tables for caching in beta-reduction and heuristic-beta-reduction

Revision 1.15  1992/04/13  14:21:12  clive
First version of the profiler

Revision 1.14  1992/04/02  12:46:41  jont
Removed second call to get_knowns in process_expr, as it's the same
as the first

Revision 1.13  1992/03/27  13:05:41  jont
Added require Integer. Removed references to pervasive length and
makestring

Revision 1.12  1992/03/05  13:12:21  jont
Used our Print rather than pervasive NJ print

Revision 1.11  1992/01/30  16:11:32  clive
Modified to use is-in_evaluation-set instead of computing this set and then
testing for membership - this gave a small increase in speed

Revision 1.10  1991/11/22  18:38:42  jont
Removed opens

Revision 1.9  91/10/22  18:14:48  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.8  91/10/22  14:12:22  davidt
Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception).

Revision 1.7  91/10/09  15:12:33  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.

Revision 1.6  91/09/26  13:35:31  davida
Made function inlining a little less general:
removed substitution of recursive forms.

Revision 1.5  91/09/25  15:22:51  davida
Made function inlining a bit more general.

Revision 1.4  91/09/16  15:04:51  davida
beta reduction was wrongly being applied outermost
instead of innermost - corrected.

Revision 1.3  91/09/12  16:01:19  davida
No changes.

d125 2
a128 2
	 | LT.INT i  => scon_heuristic(Ident.INT (Integer.makestring i), times)
	      
d231 1
a231 1
				       is_commutative,...}) expression =
a233 18
    (*  Do some judicious fiddling of commutative operators, etc, etc.   *)
    (*  in order to place all shiftable expressions as early as poss in  *)
    (*  the evaluation order to maximise the chance of being able to     *)
    (*  substitute.  If this seems like a bit of a hack...		 *)
	
    val fiddle_order =
       let
	  fun rearrange (app as LT.APP(func,LT.STRUCT [arg1,arg2])) =
	     if is_commutative func
		andalso is_shiftable arg2
		andalso not(is_shiftable arg1)
		    then LT.APP(func,LT.STRUCT [arg2,arg1])
	     else app
	    | rearrange expr = expr
       in 
	  LS.apply_outermost rearrange
       end
       
d243 12
a254 1
    fun beta true (original as LT.VAR var) = (increment_count(var,1) ; original)
d345 1
a345 1
		       datatype action = Reduce | Give_Up | Fiddle_It
d362 2
a363 3
				then if before_nonshifts (body,false)
					then Reduce
				     else Fiddle_It
a372 14
			| Fiddle_It => 
			     let 
				val newbody = fiddle_order body
				val _ = info 
				   "attempted fiddle on commutative order"
			     in 
				case reduce_non_shiftables newbody of
				   Reduce => 
				      (info "-- it worked!!";
                                         increment_count(var,~1);
                                         reduce_for_one_occurrence (arg,newbody))
				 | _ => (info "-- it failed. boo hoo";
					 original)
			     end
d532 1
a532 1
      type Value  = bool * LT.LambdaExp
d542 1
d568 1
d575 8
a582 6
  fun function_inline optimisesub (LT.Info{bindings,is_shiftable,...}) =
    let
      val heuristic_disallowed = ref(0)
      val attempted = ref(0)
      val success = ref(0)
      val _ = cache_hit := 0
d584 6
a589 6
      fun inline (expr as LT.APP(LT.VAR fnvar, arg)) = 
        (let
           val (correct_form,funvalue) =
             CorrectFormTable.lookup(fnvar) 
             handle _ =>
               let
d593 4
a596 3
                     LT.LETREC _ => false
                   | _ => is_shiftable funvalue
                 val pair = (correct_form,funvalue)
d598 2
a599 2
                 CorrectFormTable.update(fnvar,pair);
                 pair
d602 2
a603 2
          if correct_form
            then
d618 6
a623 3
                        val inlined = 
                          optimisesub (LT.APP(LS.rename_fresh
                                              funvalue, arg))
d625 2
a626 2
                        if cost_expr inlined < (!max_func_dup 
                                                + cost_expr arg)
d633 2
a634 2
                                  InlineTable.update((fnvar,arg),(true,true,inlined,true));
                                  inlined)
d638 1
a638 1
                else
d643 7
a649 4
          else
            expr
	end handle LT.BindingTable.Undefined => expr)
        | inline expr = expr
a655 1
      fn expr =>
d657 1
a657 1
        val result = Timer.time_it("carrying out inlining", fn () => LS.apply_innermost inline expr)
@


1.19
log
@A few speed improvements including specialising the hash equality function
@
text
@d4 3
d103 1
a103 3
  infix mem == ++ -- (* !!! *)
  val op== = Lib.==
  val op mem = Lib.mem
d106 1
d586 1
a586 1
      val eq = fn ((var,exp),(var',exp')) => LT.LVar_eq(var,var') andalso exp=exp'
@


1.18
log
@Cache the failure case in function_inline
@
text
@d4 3
d76 1
d87 1
d311 1
a311 1
      | beta _ (original as LT.APP(LT.FN(var,body,_),
d348 1
a348 1
    and beta2 (original as (LT.APP(LT.FN(var,body,_),arg))) = 
d482 1
a482 1
	    fun aug((bindings,bindings_as_list), LT.APP(LT.FN(var,_,_),arg)) = 
d505 1
a505 1
	    fun getk (knowns, (_, LT.FN(var,_,_))) = knowns ++ var
d517 1
a517 1
	    fun remove (nes, LT.FN(var, _,_)) = nes -- var
d537 1
a537 1
	      fun shift_bodies(acc, (var, LT.FN(var',body,_))) =
d584 1
a584 1
      val eq = (op =)
d595 1
a595 1
      val eq = (op =)
d599 11
d653 14
a666 1
	   val funvalue = LT.BindingTable.apply bindings fnvar
d668 8
a675 4
	   case funvalue of 
	      (LT.LETREC _) => expr  (* don't inline recursive forms! *)
	    | _ => 
                if is_shiftable funvalue
d677 24
a700 36
                    let
                      val _ = attempted := !attempted + 1
                      val (try,done_before,expansion,bother_to_test) =  
                        try_to_inline (fnvar,arg,funvalue)
                    in
                      if try
                        then
                          if done_before
                            then
                              (info("inlined function for v"^
                                    (LT.printLVar fnvar) ^ " cached from once before");
                               LS.rename_fresh expansion)
                          else 
                            let
                              val inlined = 
                                optimisesub (LT.APP(LS.rename_fresh
                                                    funvalue, arg))
                            in
                              if cost_expr inlined < (!max_func_dup 
                                                      + cost_expr arg)
                                then (info("inlined function for v"^
                                           (LT.printLVar fnvar));
                                      if !debug_inlineability andalso not(bother_to_test)
                                        then output(std_out,"*** Test heuristic failed\n")
                                      else ();
                                      success := !success + 1;
                                      InlineTable.update((fnvar,arg),(true,true,inlined,true));
                                      inlined)
                              else (InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
                                    expr)
                            end
                      else
                        (heuristic_disallowed := !heuristic_disallowed + 1 ; 
                         InlineTable.update((fnvar,arg),(false,false,dummy_form,true));
                         expr)
                    end
d702 6
a707 1
                  expr
d709 1
a709 1
      | inline expr = expr
d713 1
d718 1
a718 1
        val result = LS.apply_innermost inline expr
d737 1
a737 1
	      fun wrap (body,(var,arg,annotation)) = 
d741 2
a742 1
                             else annotation),arg)
@


1.17
log
@More work on speeding up function inlining
@
text
@d4 3
d677 1
@


1.16
log
@Used hash tables for caching in beta-reduction and heuristic-beta-reduction
@
text
@d4 3
d69 1
d573 1
a573 1
      type Value  = bool * bool * LT.LambdaExp
a592 1
  val test_for_inlineability_threshold = ref(1500)
d594 3
d606 3
a608 1
        
d610 14
a623 3
    InlineTable.lookup (var,arg)
    handle InlineTable.Lookup _ => (expression_smaller_than(var,funvalue,! test_for_inlineability_threshold),
                                    false,dummy_form)
d627 5
d639 8
a646 6
                let
                  val (try,done_before,expansion) =  try_to_inline (fnvar,arg,funvalue)
                in
                  if is_shiftable funvalue
                    then
                      if try 
d663 5
a667 1
                                      InlineTable.update((fnvar,arg),(true,true,inlined));
d669 1
a669 1
                              else (InlineTable.update((fnvar,arg),(false,false,dummy_form));
d672 6
a677 5
                      else 
                        expr
                  else
                    expr
                end
a679 5
  in
    (InlineTable.clear();
     ExprSizeTable.clear();
     LS.apply_innermost inline)
  end
d681 17
@


1.15
log
@First version of the profiler
@
text
@d4 3
d65 1
d67 1
d78 2
d168 32
a199 1
	   
d211 2
d217 1
d219 2
a220 1
       fun breakup_struct(var, body, fields) =
d222 1
a222 1
	    fun abs_app(expr,(subx,arg)::sas,vars) = 
d224 2
a225 1
		  val (var,expr') = LS.beta_abstract(expr,subx)
d227 7
d235 4
a238 3
		  abs_app(expr'', sas, var::vars)
		end
	      | abs_app(expr,[],vars) = (expr,vars)
d247 1
a247 1
	    val (expr,newvars) = abs_app (body,Lists.zip(rev sub_exprs,rev args),[])
d249 11
d261 1
a261 1
	     LS.substitute (var,newstruct,expr)
d298 30
a327 17
    fun beta (original as LT.APP(LT.FN(var,body,_),
				     s as LT.STRUCT fields)) =
       if LS.occurrences(var,body)>1
	  then 
	     let 
		val noselects = LS.count_noselects (body,var) 
	     in 
		if noselects = 0 orelse 
		   (struct_heuristic(s,noselects))
		   then 
		      beta (breakup_struct (var,body,fields))
		else 
		   beta2 original
	     end
       else beta2 original
	      
      | beta e = beta2 e
d329 1
d337 24
a360 8
       let
	  val occurs = LS.occurrences(var,body)
	  val shiftable = is_shiftable arg
	  fun reduce (arg,body) = beta (LS.substitute (var,arg,body))
       in 
	  if shiftable then
	     (case occurs of
		 0 => body
d362 2
a363 1
	       | 1 =>  reduce (arg,body)
d365 12
a376 4
	       | more => if should_reduce(arg,more,(var,body)) 
			    then reduce (LS.rename_fresh arg, body)
			 else 
			    original)
d416 2
a417 1
				     reduce (arg,body))
d427 2
a428 1
				       reduce (arg,newbody))
d445 2
a446 1
       LS.apply_innermost beta expression
d457 1
a457 1
  val basic_info = LT.Info{bindings = [],
d460 1
a460 1
			   is_shiftable = LS.is_shiftable Lib.nullset,
d470 2
a471 1
	    fun aug(bindings, LT.APP(LT.FN(var,_,_),arg)) = (var,arg)::bindings
d473 8
a480 3
	      | aug(bindings, LT.LETREC(lvl,lel,_)) = (* flag val rec's *)
		Lists.zip(lvl,
		    map (fn exp=>LT.LETREC([],[],exp)) lel) @@ bindings
d484 1
a484 1
	    LS.reduce_outermost aug ([],expr)
d519 2
d535 1
a535 1

d541 3
a543 3
     val bindings = get_bindings expression
     val known_fns = get_knowns bindings
     val non_escaping_fns = get_non_escapings (expression, known_fns, bindings)
d546 1
a546 1
	       known_fns = (*get_knowns bindings*)known_fns,
d548 1
a548 1
	       is_shiftable = LS.is_shiftable (get_shiftables bindings),
d564 47
a610 5
 fun function_inline optimisesub (LT.Info{bindings,is_shiftable,...}) =
  let
    fun inline (expr as LT.APP(LT.VAR fnvar, arg)) = 
       (let
	   val funvalue = Lists.assoc(fnvar,bindings)
d614 34
a647 15
	    | _ => if (is_shiftable funvalue)
		      then
			 let
			    val inlined = optimisesub (LT.APP(LS.rename_fresh
							      funvalue, arg))
			 in
			    if cost_expr inlined < (!max_func_dup 
						    + cost_expr arg)
			       then (info("inlined function for v"^
					  (LT.printLVar fnvar));
				     inlined)
			    else expr
			 end
		   else expr
	end handle Lists.Assoc => expr)
d650 3
a652 1
     LS.apply_innermost inline
a653 2


@


1.14
log
@Removed second call to get_knowns in process_expr, as it's the same
as the first
@
text
@d4 4
d236 1
a236 1
    fun beta (original as LT.APP(LT.FN(var,body),
d260 1
a260 1
    and beta2 (original as (LT.APP(LT.FN(var,body),arg))) = 
d366 1
a366 1
	    fun aug(bindings, LT.APP(LT.FN(var,_),arg)) = (var,arg)::bindings
d383 1
a383 1
	    fun getk (knowns, (_, LT.FN(var,_))) = knowns ++ var
d395 1
a395 1
	    fun remove (nes, LT.FN(var, _)) = nes -- var
d413 1
a413 1
	      fun shift_bodies(acc, (var, LT.FN(var',body))) =
d490 5
a494 1
	      fun wrap (body,(var,arg)) = LT.APP(LT.FN(var,body),arg)
@


1.13
log
@Added require Integer. Removed references to pervasive length and
makestring
@
text
@d4 4
d430 1
a430 1
	       known_fns = get_knowns bindings,
@


1.12
log
@Used our Print rather than pervasive NJ print
@
text
@d4 3
d53 1
d61 1
d149 1
a149 1
	 | LT.INT i  => scon_heuristic(Ident.INT (makestring i), times)
d181 1
a181 1
	    val size_of_struct = length fields
@


1.11
log
@Modified to use is-in_evaluation-set instead of computing this set and then
testing for membership - this gave a small increase in speed
@
text
@d4 4
d49 1
d54 11
a64 9
functor OptimiseBeta
  (structure Lib   : OPTIMISE_LIB
   structure Ident : IDENT
   structure Crash : CRASH
   structure Lists : LISTS
   sharing Ident = Lib.LT.Ident
   val int_size       : int
   and real_size      : int
   and string_size_fn : string -> int) : OPTIMISE_BETA =
d74 2
a75 1
  fun info message = if !show_debug_info then print message else ()
@


1.10
log
@Removed opens
@
text
@d3 4
a6 1
$Log:	_optimise_beta.sml,v $
a279 1
			     val evset = LS.evaluation_set body
d283 1
a283 1
			     if (LT.VAR var) mem evset
@


1.9
log
@Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.
@
text
@d1 6
d8 26
a37 1
 * Copyright (c) 1991 Harlequin Ltd.
d56 2
a57 1
  open Lib
d59 4
a62 1
  
d98 6
a103 6
     let
	fun count(cost, LT.SCON s) = cost + cost_scon s
	  | count(cost, _) = cost
     in
	LS.reduce_outermost count (0,expr)
     end
d105 2
a106 2
  fun cost_expr expr = (LS.size_of_expr expr) * (!code_node_factor)
     			 + cost_all_scons expr
d170 2
a171 1
	    val sub_exprs = (map (fn field => LT.SELECT(field,evar)) selects)
d212 2
a213 1
    fun beta (original as LT.APP(LT.FN(var,body),s as LT.STRUCT fields)) =
d331 5
a335 5
			   known_fns = nullset,
			   non_escaping_fns = nullset,
			   is_shiftable = LS.is_shiftable nullset,
			   is_commutative = LS.is_commutative nullset,
			   is_associative = LS.is_associative nullset}
d363 1
a363 1
	    Lists.reducel getk (nullset, bindings)
d372 1
a372 1
	    fun remove (nes, LT.FN(var, _)) = nes--var
d376 1
a376 1
	   nullset
d392 1
a392 1
		      then acc++var
d396 3
a398 1
	     fixpoint op== (fn s=>Lists.reducel shift_bodies (s,bindings),nullset)
d401 2
a402 2
      fun get_commutatives bindings = nullset
      fun get_associatives bindings = nullset
a479 24
(* $Log:	_optimise_beta.sml,v $
Revision 1.8  91/10/22  14:12:22  davidt
Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception).

Revision 1.7  91/10/09  15:12:33  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.

Revision 1.6  91/09/26  13:35:31  davida
Made function inlining a little less general:
removed substitution of recursive forms.

Revision 1.5  91/09/25  15:22:51  davida
Made function inlining a bit more general.

Revision 1.4  91/09/16  15:04:51  davida
beta reduction was wrongly being applied outermost
instead of innermost - corrected.

Revision 1.3  91/09/12  16:01:19  davida
No changes.
 *)
@


1.8
log
@Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception).
@
text
@d10 1
d19 1
d25 2
a26 1
  open Lib  infix mem == ++ -- (* !!! *)
d115 2
a116 2
	  (nth (index, fieldlist)
	   handle Nth => 
d136 1
a136 1
	    val (expr,newvars) = abs_app (body,zip(rev sub_exprs,rev args),[])
d309 1
a309 1
		zip(lvl,
d326 1
a326 1
	    reducel getk (nullset, bindings)
d336 1
a336 1
	      | remove (nes, LT.STRUCT lel) = reducel remove (nes,lel)
d359 1
a359 1
	     fixpoint op== (fn s=>reducel shift_bodies (s,bindings),nullset)
d394 1
a394 1
	   val funvalue = assoc(fnvar,bindings)
d412 1
a412 1
	end handle Assoc => expr)
d430 1
a430 1
	      reducel wrap (LS.unwrap_apps expr)
d442 5
@


1.7
log
@Made changes due to record selection now requiring both the total
size of the record as well as the index.
@
text
@d2 6
a7 1
   (*  Lambda-Calculus Optimisation:  _optimise_beta *)
d9 1
a9 5
  (*  Advanced beta-reduction and function in-lining  *)


(*  Copyright (c) 1991 Harlequin Ltd. *)

a10 1
require "../utils/crash";
d14 9
a22 9
functor OptimiseBeta(structure Lib   : OPTIMISE_LIB
		     structure Ident : IDENT
		     structure Crash : CRASH
		     sharing Ident = Lib.LT.Ident
		     val int_size       : int
		     and real_size      : int
		     and string_size_fn : string -> int) : OPTIMISE_BETA =
 struct

a27 3
  exception impossible of string
  fun imposs message = raise impossible message

a30 2


d114 1
a114 1
	      imposs "select_field: bad SELECT field number!")
d439 4
@


1.6
log
@Made function inlining a little less general:
removed substitution of recursive forms.
@
text
@a8 1

d10 1
a13 1

d16 1
d116 2
a117 2
       fun select_field fieldlist field =
	  (nth (LT.fromField field, fieldlist)
d133 2
a134 1
	    val selects = map LT.toField (0 upto (size_of_struct-1))
d137 1
a137 1
	    val sub_exprs = (map (fn field=> LT.SELECT(field,evar)) selects)
d339 1
d341 1
a341 1
	    nullset
d444 4
@


1.5
log
@Made function inlining a bit more general.
@
text
@d396 16
a411 13
	   if (is_shiftable funvalue)
	      then
		 let
		    val inlined = optimisesub (LT.APP(LS.rename_fresh
						      funvalue, arg))
		 in
		    if cost_expr inlined < (!max_func_dup + cost_expr arg)
		       then (info("inlined function for v"^
				  (LT.printLVar fnvar));
			     inlined)
		    else expr
		 end
	   else expr
d442 3
@


1.4
log
@beta reduction was wrongly being applied outermost
instead of innermost - corrected.
@
text
@d95 1
d393 17
a409 14
       if (is_shiftable expr)
	  then 
	   (case assoc(fnvar,bindings) of
	       LT.FN(var,body) => 
		let
		   val redex = optimisesub (LS.substitute (var,arg,body))
		in
		   if cost_expr redex < (!max_func_dup)
		     then (info("inlined function for v"^(LT.printLVar fnvar));
			   redex)
		   else expr
		end
	     | _ => expr) handle Assoc => expr
       else expr
d439 4
@


1.3
log
@No changes.
@
text
@d282 1
a282 1
       LS.apply_outermost beta expression
d434 4
a437 1
(* $Log$ *)
@


1.2
log
@Removed curry regeneration and multiple substitution
of FN's, as they were unsafe.  Begun work on
new inlining optimisation which replaces them.
@
text
@d282 1
a282 1
       LS.apply_innermost beta expression
d432 3
@


1.1
log
@Initial revision
@
text
@d36 253
d307 5
a311 1
	      | aug(bindings, LT.LETREC(lvl,lel,_)) = zip(lvl,lel) @@ bindings
d352 1
a352 1
	      fun shift_bodies(acc, (var, LT.FN(_,body))) =
d385 3
a387 8
  (*  Beta-reduction is possible when the function argument is            *)
  (*  shiftable (i.e. can be guaranteed not to reference state, raise an  *)
  (*  exception, or loop forever when evaluated), or when substitution    *)
  (*  will not change the evaluation order or number of times a 	  *)
  (*  non-shiftable argument will be evaluated.  This ensures semantic    *)
  (*  equivalence.   Beta-reductions might be valuable optimisations, so  *)
  (*  some effort is made to analyse user-defined functions to attempt    *)
  (*  to classify them as shiftable.					  *)
d389 7
a395 202
  (*  Since beta-redexes are generated mostly from the equivalent of       *)
  (*  let-constructs during translation, and are spotted as such in code-  *)
  (*  generation, the final savings from performing beta-reduction as far  *)
  (*  as possible at this stage may not justify the computational cost of  *)
  (*  doing it.  We will find out if this is the case by experience.       *)


(* Heuristic Measures *)

val max_struct_dup   = ref 500;      (*  space from duplicating structs   *)
val max_scon_space   = ref 500;	     (*  space from duplicating SCON's    *)
val max_func_dup     = ref 500;	     (*  space from duplicating fn's      *)
val max_curry_body   = ref 50;       (*  size of dup'd curry fun bodies   *)
val code_node_factor = ref 4;        (*  for wintertime, wear balaclavas  *)
				      
    

local 

      fun cost_scon (Ident.INT _) = int_size
	| cost_scon (Ident.REAL _) = real_size
	| cost_scon (Ident.STRING s) = string_size_fn s

      fun cost_all_scons expr =
	  let
	      fun count(cost, LT.SCON s) = cost + cost_scon s
		| count(cost, _) = cost
	  in
	      LS.reduce_outermost count (0,expr)
	  end

      fun cost_expr expr = (LS.size_of_expr expr) * (!code_node_factor)
	  			+ cost_all_scons expr

      fun scon_heuristic(scon,no_of_times) = 
	  (cost_scon scon * no_of_times) < (!max_scon_space)

      fun struct_heuristic(strct,no_of_times) = 
	  (cost_expr strct * no_of_times) < (!max_struct_dup)

      fun fn_heuristic(body,no_of_times) = false   (* ##### *)
	  (* (cost_expr body * no_of_times) < (!max_func_dup) *)



      (*   should_reduce : expr * int -> bool				  *)
      (* 								  *)
      (*  A heuristic function to decide if beta-reduction should be      *)
      (*  performed in the case that the bound-variable appears in the    *)
      (*  body more than once.  In general, this is a compromise between  *)
      (*  the cost of function application at run-time, and the cost of   *)
      (*  evaluating the argument.  Simple cases are when the arg is:     *)
      (*  VAR, SCON, INT, BUILTIN.                                        *)
      (*  (only called with a shiftable argument)			  *)
       
      fun should_reduce(arg,times,(var,body)) = 
	 (case arg of
	      LT.VAR _  => true
	    | LT.BUILTIN _ => true

	    | LT.SCON sc => scon_heuristic(sc,times)

	    | LT.INT i  => scon_heuristic(Ident.INT (makestring i), times)

	    | LT.SELECT _ => true    (* only if abstracted out again later!  *)
				     (* leads to duplication of selects, but *)
				     (* possible elimination of superfluous  *)
				     (* restructuring... THIS IS THE ONLY    *)
				     (* PLACE WHERE BETA-REDUCTION LEADS TO  *)
				     (* COSTLY DUPLICATION & instability with*)
				     (* common-subexpression-elimination.... *)
				     (* It would be better to realise struct *)
				     (* elim in a different way.	     *)

(*	    | LT.FN(_,fnbody) =>  fn_heuristic(fnbody,times)
				     (* could perhaps check for constant *)
				     (* functions instead, currently may *)
				     (* duplicate LETREC's if we're not  *)
				     (* careful.  !!!!!!!		 *)
*)
	    | _ => false)


      (* breakup_struct: expr * expr * expr list -> expr  	          *)
      (* 								  *)
      (*  Abstracts out a new lambda-variable over each component of a    *)
      (*  structure, producing a nested app-fn expression (like let's).   *)
      (*  Code is a lot more concise to do curried form of this, but      *)
      (*  ensuring nested app's means beta-reduction can be done in one   *)
      (*  go.  Typically this will introduce new beta-redexes, and        *)
      (*  usefully splits apart a structure with a mixture of shiftable   *)
      (*  non-shiftable components.  					  *)
	     
      local 
	 fun select_field fieldlist field =
	    (nth (LT.fromField field, fieldlist)
	     handle Nth => 
		imposs "select_field: bad SELECT field number!")
      in
      fun breakup_struct(var, body, fields) =
	  let
	    fun abs_app(expr,(subx,arg)::sas,vars) = 
		let 
		    val (var,expr') = LS.beta_abstract(expr,subx)
		    val expr'' = LT.APP(expr',arg)
		in
		    abs_app(expr'', sas, var::vars)
		end
	      | abs_app(expr,[],vars) = (expr,vars)

	    val size_of_struct = length fields
	    val selects = map LT.toField (0 upto (size_of_struct-1))
	    val args = map (select_field fields) selects
	    val evar = LT.VAR var
	    val sub_exprs = (map (fn field=> LT.SELECT(field,evar)) selects)
	    val (expr,newvars) = abs_app (body,zip(rev sub_exprs,rev args),[])
	    val newstruct = LT.STRUCT(map LT.VAR newvars)
	  in
	       LS.substitute [(var,newstruct)] expr
	  end
      end (* of local *)


in
  fun heuristic_beta_reduce (LT.Info{bindings,is_shiftable,
				     is_commutative,...}) expression =
   let

    (*  Do some judicious fiddling of commutative operators, etc, etc.   *)
    (*  in order to place all shiftable expressions as early as poss in  *)
    (*  the evaluation order to maximise the chance of being able to     *)
    (*  substitute.  If this seems like a bit of a hack...		 *)
	
    val fiddle_order =
	let
	    fun rearrange (app as LT.APP(func,LT.STRUCT [arg1,arg2])) =
		if is_commutative func
		    andalso is_shiftable arg2
		    andalso not(is_shiftable arg1)
		      then LT.APP(func,LT.STRUCT [arg2,arg1])
		else app
	      | rearrange expr = expr
	in 
	    LS.apply_outermost rearrange
	end
       


      (*  Beta-reduction when the argument is a structure.  This considers  *)
      (*  whether to break up the structure into separate lambda variables. *)
      (*  If the structure is always SELECT'd on in the body, it will be    *)
      (*  broken up.  Otherwise, a heuristic is used to decide based on     *)
      (*  the size of the struct and the number of times it appears in the  *)
      (*  body without an immediate SELECT.				    *)

       fun beta (original as LT.APP(LT.FN(var,body),s as LT.STRUCT fields)) =
	   if LS.occurrences(var,body)>1
	       then 
		   let 
		       val noselects = LS.count_noselects (body,var) 
		   in 
		       if noselects = 0 orelse 
			   (struct_heuristic(s,noselects))
			   then 
			       beta (breakup_struct (var,body,fields))
		       else 
			   beta2 original
		   end
	   else beta2 original
	       
	 | beta e = beta2 e


       (*  BETA-reduction in the more general case.  Recurses to reduce   *)
       (*  the outermost redexes, when the argument is shiftable, or      *)
       (*  substituting it will definitely evaluate it, and do so before  *)
       (*  any other un-shiftable expression is evaluated.		  *)

       and beta2 (original as (LT.APP(LT.FN(var,body),arg))) = 
	   let
	       val occurs = LS.occurrences(var,body)
	       val shiftable = is_shiftable arg
	       fun reduce (arg,body) = beta (LS.substitute [(var,arg)] body)
	   in 
	    if shiftable then
		(case occurs of
		   0 => body

		 | 1 =>  reduce (arg,body)

		 | more => if should_reduce(arg,more,(var,body)) 
			       then reduce (LS.rename_fresh arg, body)
			   else 
			       curry_optimise original)
	    else
	      (case occurs of
		   0 => (info ("non-shiftable isn't in body -"^
			       "can't reduce away v"^
			       (LT.printLVar var));
			 original)
		       
	      | 1 => 
d397 1
a397 26
		    val _ = info ("non-shiftable occurs once: v"^
				  (LT.printLVar var))

		    datatype action = Reduce | Give_Up | Fiddle_It

		    fun reduce_non_shiftables body =
			let
			   exception Stop of bool

			   fun find_var_nonshift (LT.VAR v, _) = 
			      if v=var then (true,true)
			      else (false,false)
			     | find_var_nonshift (expr,_) = 
			       if not(is_shiftable expr) then (false,true)
			       else (false,false)

			   val evset = LS.evaluation_set body
			   val before_nonshifts =  LS.reduce_inner_until
			      			   find_var_nonshift 
			in 
			   if (LT.VAR var) mem evset
			      then if before_nonshifts (body,false)
				      then Reduce
				   else Fiddle_It
			   else Give_Up
			end
d399 4
a402 18
		    case reduce_non_shiftables body of
		        Give_Up => (info "<given up>";
				    original)
		      | Reduce => (info "<reduced it>";
				   reduce (arg,body))
		      | Fiddle_It => 
			    let 
				val newbody = fiddle_order body
				val _ = info 
				    "attempted fiddle on commutative order"
			    in 
				case reduce_non_shiftables newbody of
				    Reduce => 
					(info "-- it worked!!";
					 reduce (arg,newbody))
				  | _ => (info "-- it failed. boo hoo";
					  original)
			    end
d404 6
a410 2
	      | more => (info ("non-shiftable appears more than once: "^
			       (LT.printLVar var));
a411 43
			 original)) (* could test for a subset which _can_ *)
				    (* appear more than once, given eval'd *)
		                    (* first: eg, RAISE.		   *)
	   end

	 | beta2 expr = expr


       (*  This optimisation  is intended to generate new instances of  *)
       (*  partially applied curried functions, to save the run-time    *)
       (*  costs of closures.  It would typically create new functions  *)
       (*  when using functionals like "pair", "fold" etc.  There is a  *)
       (*  maximal size of function which will be duplicated like this, *)
       (*  to prevent code-generating huge functions multiply.		*)

       and curry_optimise (original as LT.APP(LT.FN(var,body),
					      arg as LT.FN(v1,LT.FN(v2,b2)))) =

	   if (cost_expr b2 < (!max_curry_body))
	       then 
		   let
		       fun curry_reduce (expr as LT.APP(LT.VAR v, operand)) =
			   if v=var 
			       then LS.rename_fresh(LT.FN(v2,
					     LS.substitute [(v1,operand)] b2))
			   else expr
			 | curry_reduce expr = expr

		       val _ = info ("curry-generation applied to v"^
				     (LT.printLVar var))
		   in
		       LT.APP(LT.FN(var,LS.apply_outermost curry_reduce body),
			      arg)
		   end
	   else original

	 | curry_optimise expr = expr
			   
   in
       LS.apply_innermost beta expression
   end  

  end (* of local *)  
@
