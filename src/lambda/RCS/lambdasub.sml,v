head	1.39;
access;
symbols
	MLW_daveb_inline_1_4_99:1.39.11
	MLWorks_21c0_1999_03_25:1.39
	MLWorks_20c1_1998_08_20:1.39
	MLWorks_20c0_1998_08_04:1.39
	MLWorks_20b2c2_1998_06_19:1.39
	MLWorks_20b2_Windows_1998_06_12:1.39
	MLWorks_20b1c1_1998_05_07:1.39
	MLWorks_20b0_1998_04_07:1.39
	MLWorks_20b0_1998_03_20:1.39
	MLWorks_20m2_1998_02_16:1.39
	MLWorks_20m1_1997_10_23:1.39
	MLWorks_11r1:1.39.8.1.1.1.1
	MLWorks_workspace_97:1.39.10
	MLWorks_dt_wizard:1.39.9
	MLWorks_11c0_1997_09_09:1.39.8.1.1.1
	MLWorks_10r3:1.39.8.1.3
	MLWorks_10r2_551:1.39.8.1.2
	MLWorks_11:1.39.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.39.8.1
	MLWorks_20m0_1997_06_20:1.39
	MLWorks_1_0_r2c2_1997_06_14:1.39.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.39.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.39.8
	MLWorks_BugFix_1997_04_24:1.39
	MLWorks_1_0_r2_Win32_1997_04_11:1.39
	MLWorks_1_0_r2_Unix_1997_04_04:1.39
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.39.6.1.1
	MLWorks_gui_1996_12_18:1.39.7
	MLWorks_1_0_Win32_1996_12_17:1.39.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.39.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.39.4.1
	MLWorks_1_0_Irix_1996_11_28:1.39.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.39.5
	MLWorks_1_0_Unix_1996_11_14:1.39.4
	MLWorks_Open_Beta2_1996_10_11:1.39.3
	MLWorks_License_dev:1.39.2
	MLWorks_1_open_beta_1996_09_13:1.39.1
	MLWorks_Open_Beta_1996_08_22:1.39
	MLWorks_Beta_1996_07_02:1.39
	MLWorks_Beta_1996_06_07:1.39
	MLWorks_Beta_1996_06_06:1.39
	MLWorks_Beta_1996_06_05:1.39
	MLWorks_Beta_1996_06_03:1.39
	MLWorks_Beta_1996_05_31:1.39
	MLWorks_Beta_1996_05_30:1.39
	ML_beta_release_12/08/94:1.37
	ML_beta_release_03/08/94:1.37
	ML_revised_beta_release_25/05/94:1.37
	ML_final_beta_release_02/03/94:1.37
	mlworks-28-01-1994:1.37
	Release:1.37
	mlworks-beta-01-09-1993:1.37
	MLWorks-1-0-4-29/01/1993:1.35
	MLWorks-1-0-3-21/12/1992:1.35
	MLWorks-1-0-2-15/12/1992:1.35
	MLWorks-1-0-1-04/12/1992:1.35
	checkpoint_17_08_92:1.33
	Ten15_release_21-08-91:1.15
	Ten15_release_19-08-91:1.14
	ten15_release:1.8;
locks; strict;
comment	@ * @;


1.39
date	95.12.04.12.26.32;	author matthew;	state Exp;
branches
	1.39.1.1
	1.39.2.1
	1.39.3.1
	1.39.4.1
	1.39.5.1
	1.39.6.1
	1.39.7.1
	1.39.8.1
	1.39.9.1
	1.39.10.1
	1.39.11.1;
next	1.38;

1.38
date	95.02.28.14.07.22;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.05.28.10.28.01;	author nosa;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	93.03.10.15.59.24;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	92.11.09.15.47.41;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.08.26.12.30.26;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.07.24.13.24.32;	author clive;	state Exp;
branches;
next	1.32;

1.32
date	92.07.22.12.04.32;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.07.17.13.47.37;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	92.07.03.07.41.58;	author davida;	state Exp;
branches;
next	1.29;

1.29
date	92.06.25.09.44.11;	author davida;	state Exp;
branches;
next	1.28;

1.28
date	92.06.15.16.12.09;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.06.11.09.08.03;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.04.23.12.10.58;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.04.13.14.28.22;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.02.12.11.08.38;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	92.01.29.17.49.00;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	91.11.14.17.00.59;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.10.23.11.55.29;	author davidt;	state Exp;
branches;
next	1.20;

1.20
date	91.10.22.17.40.07;	author davidt;	state Exp;
branches;
next	1.19;

1.19
date	91.10.22.16.09.15;	author davidt;	state Exp;
branches;
next	1.18;

1.18
date	91.10.09.10.30.57;	author davidt;	state Exp;
branches;
next	1.17;

1.17
date	91.09.10.13.43.09;	author davida;	state Exp;
branches;
next	1.16;

1.16
date	91.09.06.13.05.03;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	91.08.15.14.05.34;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	91.08.14.13.05.54;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.08.13.16.04.04;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.08.09.14.03.21;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.08.06.14.20.09;	author davida;	state Exp;
branches;
next	1.10;

1.10
date	91.08.02.15.55.03;	author davida;	state Exp;
branches;
next	1.9;

1.9
date	91.07.31.14.43.05;	author davida;	state Exp;
branches;
next	1.8;

1.8
date	91.07.30.16.45.29;	author davida;	state Exp;
branches;
next	1.7;

1.7
date	91.07.29.16.00.18;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	91.07.25.17.57.18;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.07.25.13.07.30;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.07.24.13.00.16;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.07.22.12.54.15;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.16.17.23.48;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.07.15.16.11.56;	author davida;	state Exp;
branches;
next	;

1.37.1.1
date	93.05.28.10.28.01;	author jont;	state Exp;
branches;
next	;

1.39.1.1
date	96.09.13.11.17.20;	author hope;	state Exp;
branches;
next	;

1.39.2.1
date	96.10.07.16.07.06;	author hope;	state Exp;
branches;
next	;

1.39.3.1
date	96.10.17.11.25.22;	author hope;	state Exp;
branches;
next	;

1.39.4.1
date	96.11.14.12.50.23;	author hope;	state Exp;
branches
	1.39.4.1.1.1;
next	;

1.39.4.1.1.1
date	96.11.28.15.01.30;	author hope;	state Exp;
branches;
next	;

1.39.5.1
date	96.11.22.18.09.49;	author hope;	state Exp;
branches;
next	;

1.39.6.1
date	96.12.17.17.48.28;	author hope;	state Exp;
branches
	1.39.6.1.1.1;
next	;

1.39.6.1.1.1
date	97.02.24.11.38.23;	author hope;	state Exp;
branches;
next	;

1.39.7.1
date	96.12.18.09.42.28;	author hope;	state Exp;
branches;
next	;

1.39.8.1
date	97.05.12.10.34.57;	author hope;	state Exp;
branches
	1.39.8.1.1.1
	1.39.8.1.2.1
	1.39.8.1.3.1;
next	;

1.39.8.1.1.1
date	97.07.28.18.20.19;	author daveb;	state Exp;
branches
	1.39.8.1.1.1.1.1;
next	;

1.39.8.1.1.1.1.1
date	97.10.07.11.45.29;	author jkbrook;	state Exp;
branches;
next	;

1.39.8.1.2.1
date	97.09.08.17.13.49;	author daveb;	state Exp;
branches;
next	;

1.39.8.1.3.1
date	97.09.09.14.09.33;	author daveb;	state Exp;
branches;
next	;

1.39.9.1
date	97.09.10.19.25.21;	author brucem;	state Exp;
branches;
next	;

1.39.10.1
date	97.09.11.20.55.39;	author daveb;	state Exp;
branches;
next	;

1.39.11.1
date	99.04.01.17.57.16;	author daveb;	state Exp;
branches;
next	;


desc
@Subfunctions for manipulating lambda-expressions.
@


1.39
log
@Simplifying
@
text
@(* lambdasub.sml  - sub-functions for lambda modules *)

(*  Copyright (c) 1991 Harlequin Ltd.  *)

require "lambdatypes";

signature LAMBDASUB =
  sig 
    structure LT  : LAMBDATYPES

    val wrap_lets :
      LT.LambdaExp * (LT.LVar * LT.LambdaExp) list -> LT.LambdaExp
    val unwrap_lets :
      LT.LambdaExp -> (LT.LVar * LT.LambdaExp) list * LT.LambdaExp
    val apply_one_level :
      (LT.LambdaExp -> LT.LambdaExp) -> LT.LambdaExp -> LT.LambdaExp
    val occurs               : LT.LVar * LT.LambdaExp -> bool      
    val eta_abstract :
      LT.LambdaExp * string * LT.Type ref  -> LT.LambdaExp
  end;

(*
$Log: lambdasub.sml,v $
Revision 1.38  1995/02/28  14:07:22  matthew
Removing old lambda optimizer stuff

Revision 1.37  1993/05/28  10:28:01  nosa
structure Option.

Revision 1.36  1993/03/10  15:59:24  matthew
Signature revisions

Revision 1.35  1992/11/09  15:47:41  clive
Added some LETREC optimisation

Revision 1.34  1992/08/26  12:30:26  jont
Removed some redundant structures and sharing

Revision 1.33  1992/07/24  13:24:32  clive
Modified to use the new hashtables

Revision 1.32  1992/07/22  12:04:32  clive
Wrote routines to try to substitute exactly n times without going inside letrec and fn

Revision 1.31  1992/07/17  13:47:37  clive
Changed eta_abstract to take an annotation

Revision 1.30  1992/07/03  07:41:58  davida
Simplified the types of a few functions.

Revision 1.29  1992/06/25  09:44:11  davida
Added occurs function.

Revision 1.28  1992/06/15  16:12:09  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.27  1992/06/11  09:08:03  clive
Added type annotations to FNexp

Revision 1.26  1992/04/23  12:10:58  clive
Speed improvement

Revision 1.25  1992/04/13  14:28:22  clive
First version of the profiler

Revision 1.24  1992/02/12  11:08:38  jont
Added substitute_list function, used by both _curry and _optimise_cse

Revision 1.23  1992/01/29  17:49:00  clive
Added a function is_in_evaluation_set so that we don't have to
generate the evaluation_set and then test to see if something is in it
which proved to be a very expensive operation

Revision 1.22  1991/11/14  17:00:59  jont
Added eta_abstract function for general use

Revision 1.21  91/10/23  11:55:29  davidt
Added new functions apply_innermost_with_context
and apply_outermost_with_context.

Revision 1.20  91/10/22  17:40:07  davidt
Took out the crappy inclusion of Lists.

Revision 1.19  91/10/22  16:09:15  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.18  91/10/09  10:30:57  davidt
Took out most of Jon's utility functions (they are now in the
List structure).

Revision 1.17  91/09/10  13:43:09  davida
Changed type of substitute, added substitute_fresh

Revision 1.16  91/09/06  13:05:03  davida
List utility functions removed.

Revision 1.15  91/08/15  14:05:34  davida
New / altered functions.

Revision 1.14  91/08/14  13:05:54  davida
removed set_of_lvars, changed bounds_and_frees to include
variables bound by LETREC's.

Revision 1.13  91/08/13  16:04:04  davida
Added sub-expression substitution function "replace_subexpr"

Revision 1.12  91/08/09  14:03:21  davida
New functions added

Revision 1.11  91/08/06  14:20:09  davida
Altered selects_on_var for 2nd phase, temporarily.

Revision 1.10  91/08/02  15:55:03  davida
Added function size_of_expr to count number
sub expressions in an expression.

Revision 1.9  91/07/31  14:43:05  davida
Added whnf

Revision 1.8  91/07/30  16:45:29  davida
Added some more functions, fiddled with some old ones.

Revision 1.7  91/07/29  16:00:18  davida
Changed is_expansive to is_shiftable, added unwrap_apps.

Revision 1.6  91/07/25  17:57:18  jont
Added require for set to prevent future grief

Revision 1.5  91/07/25  13:07:30  davida
Added new functions.

Revision 1.4  91/07/24  13:00:16  davida
Altered form of is_expansive and added set_of_selects

Revision 1.3  91/07/22  12:54:15  jont
Moved some general purpose functions in from _lambda

Revision 1.2  91/07/16  17:23:48  davida
Added new functions set_of_lvars and is_expansive.

Revision 1.1  91/07/15  16:11:56  davida
Initial revision

*)
@


1.39.11.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.8.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a23 3
 * Revision 1.39.8.1  1997/05/12  10:34:57  hope
 * branched from 1.39
 *
@


1.39.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a23 3
 * Revision 1.39.8.1  1997/05/12  10:34:57  hope
 * branched from 1.39
 *
@


1.39.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a23 3
 * Revision 1.39.8.1  1997/05/12  10:34:57  hope
 * branched from 1.39
 *
@


1.39.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a23 3
 * Revision 1.39.8.1.1.1  1997/07/28  18:20:19  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.39.7.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.6.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.6.1.1.1
log
@branched from 1.39.6.1
@
text
@a23 3
 * Revision 1.39.6.1  1996/12/17  17:48:28  hope
 * branched from 1.39
 *
@


1.39.5.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.4.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.4.1.1.1
log
@branched from 1.39.4.1
@
text
@a23 3
 * Revision 1.39.4.1  1996/11/14  12:50:23  hope
 * branched from 1.39
 *
@


1.39.3.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.2.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.39.1.1
log
@branched from 1.39
@
text
@a23 3
 * Revision 1.39  1995/12/04  12:26:32  matthew
 * Simplifying
 *
@


1.38
log
@Removing old lambda optimizer stuff
@
text
@a19 80
(*
    val print_hash_table_stats : bool ref

    val lambda_equality : LT.LambdaExp * LT.LambdaExp -> bool
    val tag_equality : LT.Tag * LT.Tag -> bool

    val whnf : LT.LambdaExp -> bool

    val apply_innermost :
      (LT.LambdaExp -> LT.LambdaExp) -> LT.LambdaExp -> LT.LambdaExp
    val apply_outermost :
      (LT.LambdaExp -> LT.LambdaExp) -> LT.LambdaExp -> LT.LambdaExp
						     
    val apply_innermost_with_context :
      (LT.LambdaExp LT.Option.opt -> LT.LambdaExp -> LT.LambdaExp) ->
      LT.LambdaExp -> LT.LambdaExp
    val apply_outermost_with_context :
      (LT.LambdaExp LT.Option.opt -> LT.LambdaExp -> LT.LambdaExp) ->
      LT.LambdaExp -> LT.LambdaExp

    val reduce_innermost :
      (LT.LambdaExp * 'a -> 'a) -> (LT.LambdaExp * 'a) -> 'a
    val reduce_outermost :
      ('a * LT.LambdaExp -> 'a) -> ('a * LT.LambdaExp) -> 'a
    val reduce_inner_until :
      (LT.LambdaExp * '_a -> '_a * bool) -> (LT.LambdaExp * '_a) -> '_a

    val size_of_expr         : LT.LambdaExp -> int
    val size_of_expr_is_smaller_than : LT.LambdaExp * int -> bool
    val occurrences          : LT.LVar * LT.LambdaExp -> int
    val occurrences_0_1_more : LT.LVar * LT.LambdaExp -> int
    val count_noselects      : LT.LambdaExp * LT.LVar -> int

    val alpha_convertible : LT.LambdaExp * LT.LambdaExp -> bool
      
    val bounds_and_frees :
      LT.LambdaExp -> (LT.LVar LT.Set.Set * LT.LVar LT.Set.Set)
    val rename_fresh :
      LT.LambdaExp -> LT.LambdaExp
    val substitute :
      LT.LVar * LT.LambdaExp * LT.LambdaExp -> LT.LambdaExp
    val substitute_for_at_most_one_occurrence :
      LT.LVar * LT.LambdaExp * LT.LambdaExp -> LT.LambdaExp
    val substitute_for_at_most_n_occurrences :
      LT.LVar * LT.LambdaExp * LT.LambdaExp * int -> LT.LambdaExp
    exception DidntFindCorrectNumber
    val substitute_for_exactly_one_occurrence_not_in_functions :
      LT.LVar * LT.LambdaExp * LT.LambdaExp -> LT.LambdaExp
    val substitute_for_exactly_n_occurrences_not_in_functions :
      LT.LVar * LT.LambdaExp * LT.LambdaExp * int -> LT.LambdaExp
    val substitute_fresh :
      LT.LVar * LT.LambdaExp * LT.LambdaExp -> LT.LambdaExp
    val substitute_list: (LT.LVar * LT.LVar) list * LT.LambdaExp ->
      LT.LambdaExp
    val eval_sequence         : LT.LambdaExp -> LT.LambdaExp list
    val certain_eval_sequence : LT.LambdaExp -> LT.LambdaExp list
 (* val evaluation_set        : LT.LambdaExp -> LT.LambdaExp LT.Set.Set *)
    val is_in_evaluation_set  : LT.LambdaExp -> LT.LambdaExp -> bool

    val is_shiftable   : LT.LambdaExp -> bool
    val is_commutative : LT.LVar LT.Set.Set -> LT.LambdaExp -> bool
    val is_associative : LT.LVar LT.Set.Set -> LT.LambdaExp -> bool

    val beta_abstract :
      LT.LambdaExp * LT.LambdaExp  -> LT.LVar * LT.LambdaExp
    val abstract_with_count :
      LT.LambdaExp * LT.LambdaExp -> LT.LVar * int * LT.LambdaExp
    val replace_subexpr :
      LT.LambdaExp * LT.LambdaExp -> LT.LambdaExp -> LT.LambdaExp

    val strip_abs :
      LT.LambdaExp -> LT.LVar list
    val unwrap_apps :
      LT.LambdaExp ->  LT.LambdaExp * (LT.LVar * LT.LambdaExp * string * LT.Type) list


    val check_validity : LT.LambdaExp * exn -> unit

    val print_deletion_message : LT.LambdaExp -> unit
*)
d24 3
@


1.37
log
@structure Option.
@
text
@d11 10
a31 2
    val apply_one_level :
      (LT.LambdaExp -> LT.LambdaExp) -> LT.LambdaExp -> LT.LambdaExp
a50 1
    val occurs               : LT.LVar * LT.LambdaExp -> bool      
a86 2
    val eta_abstract :
      LT.LambdaExp * string * LT.Type ref  -> LT.LambdaExp
a93 4
    val unwrap_lets :
      LT.LambdaExp -> (LT.LVar * LT.LambdaExp) list * LT.LambdaExp
    val wrap_lets :
      LT.LambdaExp * (LT.LVar * LT.LambdaExp) list -> LT.LambdaExp
d99 1
a99 1

d104 3
@


1.37.1.1
log
@Fork for bug fixing
@
text
@a102 3
Revision 1.37  1993/05/28  10:28:01  nosa
structure Option.

@


1.36
log
@Signature revisions
@
text
@d26 1
a26 1
      (LT.LambdaExp LT.Opt -> LT.LambdaExp -> LT.LambdaExp) ->
d29 1
a29 1
      (LT.LambdaExp LT.Opt -> LT.LambdaExp -> LT.LambdaExp) ->
d81 1
a81 1
      LT.LambdaExp * string * LT.Type -> LT.LambdaExp
d103 3
@


1.35
log
@Added some LETREC optimisation
@
text
@d81 1
a81 1
      LT.LambdaExp * string * LT.Datatypes.Type -> LT.LambdaExp
d88 1
a88 1
      LT.LambdaExp ->  LT.LambdaExp * (LT.LVar * LT.LambdaExp * string * LT.Datatypes.Type) list
d103 3
@


1.34
log
@Removed some redundant structures and sharing
@
text
@d97 2
a98 2
(*    val match : (LT.LVar * LT.LambdaExp) list * (LT.LambdaExp * LT.LambdaExp)
      -> (LT.LVar * LT.LambdaExp) list  *)
d103 3
@


1.33
log
@Modified to use the new hashtables
@
text
@a4 1
require "../utils/set";
a8 1
    structure Set : SET
a9 1
    sharing LT.Set = Set
d49 1
a49 1
      LT.LambdaExp -> (LT.LVar Set.Set * LT.LVar Set.Set)
d69 1
a69 1
 (* val evaluation_set        : LT.LambdaExp -> LT.LambdaExp Set.Set *)
d73 2
a74 2
    val is_commutative : LT.LVar Set.Set -> LT.LambdaExp -> bool
    val is_associative : LT.LVar Set.Set -> LT.LambdaExp -> bool
d103 3
@


1.32
log
@Wrote routines to try to substitute exactly n times without going inside letrec and fn
@
text
@d14 2
d106 3
@


1.31
log
@Changed eta_abstract to take an annotation
@
text
@d59 5
d104 3
@


1.30
log
@Simplified the types of a few functions.
@
text
@d73 1
a73 1
      LT.LambdaExp * LT.LambdaExp -> LT.LVar * LT.LambdaExp
d77 1
a77 1
      LT.LambdaExp * string -> LT.LambdaExp
d99 3
@


1.29
log
@Added occurs function.
@
text
@a71 2
    val beta_reduce :
      LT.LambdaExp -> LT.LambdaExp
d74 1
a74 1
    val beta_abstract_with_count :
d88 1
a88 1
      LT.LambdaExp * (LT.LVar * LT.LambdaExp * string * LT.Datatypes.Type) list -> LT.LambdaExp
d90 5
a94 2
    val match : (LT.LVar * LT.LambdaExp) list * (LT.LambdaExp * LT.LambdaExp)
      -> (LT.LVar * LT.LambdaExp) list
d99 3
@


1.28
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d44 1
d98 3
@


1.27
log
@Added type annotations to FNexp
@
text
@d14 3
d64 1
a64 1
    val evaluation_set        : LT.LambdaExp -> LT.LambdaExp Set.Set
d97 3
@


1.26
log
@Speed improvement
@
text
@d82 1
a82 1
      LT.LambdaExp ->  LT.LambdaExp * (LT.LVar * LT.LambdaExp * string) list
d86 1
a86 1
      LT.LambdaExp * (LT.LVar * LT.LambdaExp * string) list -> LT.LambdaExp
d94 3
@


1.25
log
@First version of the profiler
@
text
@d37 5
a41 3
    val size_of_expr    : LT.LambdaExp -> int
    val occurrences     : LT.LVar * LT.LambdaExp -> int
    val count_noselects : LT.LambdaExp * LT.LVar -> int
d51 4
d64 1
a64 1
    val is_shiftable   : LT.LVar Set.Set -> LT.LambdaExp -> bool
d72 2
d94 3
@


1.24
log
@Added substitute_list function, used by both _curry and _optimise_cse
@
text
@d67 1
a67 1
      LT.LambdaExp -> LT.LambdaExp
d74 1
a74 1
      LT.LambdaExp ->  LT.LambdaExp * (LT.LVar * LT.LambdaExp) list
d78 1
a78 1
      LT.LambdaExp * (LT.LVar * LT.LambdaExp) list -> LT.LambdaExp
d86 3
@


1.23
log
@Added a function is_in_evaluation_set so that we don't have to
generate the evaluation_set and then test to see if something is in it
which proved to be a very expensive operation
@
text
@d51 2
a52 1

d86 5
@


1.22
log
@Added eta_abstract function for general use
@
text
@d55 1
d84 4
a87 1
$Log:	lambdasub.sml,v $
@


1.21
log
@Added new functions apply_innermost_with_context
and apply_outermost_with_context.
@
text
@d64 2
d84 4
@


1.20
log
@Took out the crappy inclusion of Lists.
@
text
@d23 7
d82 3
@


1.19
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d9 4
a12 4
 sig 
  structure Set         : SET
  structure LambdaTypes : LAMBDATYPES
  sharing Set = LambdaTypes.Set
d14 1
a14 2
  (*     Lambda-Expression Manipulation    *)
  (* -- Please see functor for comments!!  *)
d16 6
a21 9
  local 
    open LambdaTypes 
    (*  type ''a Set sharing type Set = Set.Set  nj can't hack this... *)
  in
    val whnf : LambdaExp -> bool

    val apply_innermost : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
    val apply_outermost : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
    val apply_one_level : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
d23 4
a26 2
    val reduce_innermost : (LambdaExp * 'a -> 'a) -> (LambdaExp * 'a) -> 'a
    val reduce_outermost : ('a * LambdaExp -> 'a) -> ('a * LambdaExp) -> 'a
d28 1
a28 1
      (LambdaExp * '_a -> '_a * bool) -> (LambdaExp * '_a) -> '_a
d30 3
a32 3
    val size_of_expr    : LambdaExp -> int
    val occurrences     : LVar * LambdaExp -> int
    val count_noselects : LambdaExp * LVar -> int
d34 1
a34 1
    val alpha_convertible : LambdaExp * LambdaExp -> bool
d36 8
a43 4
    val bounds_and_frees : LambdaExp -> (LVar Set.Set * LVar Set.Set)
    val rename_fresh     : LambdaExp -> LambdaExp
    val substitute       : LVar * LambdaExp * LambdaExp -> LambdaExp
    val substitute_fresh : LVar * LambdaExp * LambdaExp -> LambdaExp
d45 3
a47 3
    val eval_sequence         : LambdaExp -> LambdaExp list
    val certain_eval_sequence : LambdaExp -> LambdaExp list
    val evaluation_set        : LambdaExp -> LambdaExp Set.Set
d49 3
a51 3
    val is_shiftable   : LVar Set.Set -> LambdaExp -> bool
    val is_commutative : LVar Set.Set -> LambdaExp -> bool
    val is_associative : LVar Set.Set -> LambdaExp -> bool
d53 6
a58 3
    val beta_reduce     : LambdaExp -> LambdaExp
    val beta_abstract   : LambdaExp * LambdaExp -> LVar * LambdaExp
    val replace_subexpr : LambdaExp * LambdaExp -> LambdaExp -> LambdaExp
d60 8
a67 4
    val strip_abs   : LambdaExp -> LVar list
    val unwrap_apps : LambdaExp ->  LambdaExp * (LVar * LambdaExp) list
    val unwrap_lets : LambdaExp -> (LVar * LambdaExp) list * LambdaExp
    val wrap_lets   : LambdaExp * (LVar * LambdaExp) list -> LambdaExp
d69 3
a71 4
    val match : (LVar * LambdaExp) list * (LambdaExp * LambdaExp)
      -> (LVar * LambdaExp) list
  end
end
d75 3
@


1.18
log
@Took out most of Jon's utility functions (they are now in the
List structure).
@
text
@d14 2
a15 1
  (* Jon's Utility Function *)
d17 5
a21 1
  val filter_ordered_map : (''a * 'b) list * ''a list -> (''a * 'b) list
d23 3
a25 13
 (*     Lambda-Expression Manipulation    *)
 (* -- Please see functor for comments!!  *)

local 
   open LambdaTypes 
(*  type ''a Set
       sharing type Set = Set.Set  nj can't hack this... *)
in
   val whnf : LambdaExp -> bool

   val apply_innermost : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
   val apply_outermost : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
   val apply_one_level : (LambdaExp -> LambdaExp) -> LambdaExp -> LambdaExp
d27 4
a30 4
   val reduce_innermost : (LambdaExp * 'a -> 'a) -> (LambdaExp * 'a) -> 'a
   val reduce_outermost : ('a * LambdaExp -> 'a) -> ('a * LambdaExp) -> 'a
   val reduce_inner_until : (LambdaExp * '_a -> '_a * bool) -> 
						(LambdaExp * '_a) -> '_a
d32 3
a34 3
   val size_of_expr    : LambdaExp -> int
   val occurrences     : LVar * LambdaExp -> int
   val count_noselects : LambdaExp * LVar -> int
d36 1
a36 1
   val alpha_convertible : LambdaExp * LambdaExp -> bool
d38 4
a41 4
   val bounds_and_frees : LambdaExp -> (LVar Set.Set * LVar Set.Set)
   val rename_fresh     : LambdaExp -> LambdaExp
   val substitute       : LVar * LambdaExp * LambdaExp -> LambdaExp
   val substitute_fresh : LVar * LambdaExp * LambdaExp -> LambdaExp
d43 3
a45 3
   val eval_sequence         : LambdaExp -> LambdaExp list
   val certain_eval_sequence : LambdaExp -> LambdaExp list
   val evaluation_set        : LambdaExp -> LambdaExp Set.Set
d47 3
a49 3
   val is_shiftable   : LVar Set.Set -> LambdaExp -> bool
   val is_commutative : LVar Set.Set -> LambdaExp -> bool
   val is_associative : LVar Set.Set -> LambdaExp -> bool
d51 3
a53 3
   val beta_reduce     : LambdaExp -> LambdaExp
   val beta_abstract   : LambdaExp * LambdaExp -> LVar * LambdaExp
   val replace_subexpr : LambdaExp * LambdaExp -> LambdaExp -> LambdaExp
d55 4
a58 4
   val strip_abs   : LambdaExp -> LVar list
   val unwrap_apps : LambdaExp ->  LambdaExp * (LVar * LambdaExp) list
   val unwrap_lets : LambdaExp -> (LVar * LambdaExp) list * LambdaExp
   val wrap_lets   : LambdaExp * (LVar * LambdaExp) list -> LambdaExp
d60 4
a63 3
   val match : (LVar * LambdaExp) list * (LambdaExp * LambdaExp)
						  -> (LVar * LambdaExp) list
end (* of local *)
a64 3
 end;


d67 4
@


1.17
log
@Changed type of substitute, added substitute_fresh
@
text
@d14 1
a14 1
  (* Utility Functions - should go elsewhere! *)
a15 3
  val filter : 'a list * ('a -> bool) -> 'a list
  val filter_length : 'a list * ('a -> bool) -> int
  val number_from : 'a list * int * (int -> 'b) -> ('a * 'b) list * int
a17 1

d74 3
@


1.16
log
@List utility functions removed.
@
text
@d49 2
a50 1
   val substitute       : (LVar * LambdaExp) list -> LambdaExp -> LambdaExp
d78 3
@


1.15
log
@New / altered functions.
@
text
@d3 72
d77 3
a123 1
Copyright (c) 1991 Harlequin Ltd.
a124 94

require "../utils/set";
require "lambdatypes";

signature LAMBDASUB =
    sig 
	structure Set         : SET
	structure LambdaTypes : LAMBDATYPES


        (* "Standard" Utility Functions *)

	exception LambdaSubNth
	val nth : int * 'a list -> 'a
	val apfst : ('a -> 'b) -> 'a * 'c -> 'b * 'c
	val apopt : ('a -> 'b) -> 'a LambdaTypes.Opt -> 'b LambdaTypes.Opt
	val apsnd : ('a -> 'b) -> 'c * 'a -> 'c * 'b
	val assoc : ''a -> (''a * 'b) list -> 'b LambdaTypes.Opt
	val reduce_left : ('a * 'b -> 'a) -> 'a * 'b list -> 'a
	val filter : 'a list * ('a -> bool) -> 'a list
	val filter_length : 'a list * ('a -> bool) -> int
	val number_from : 'a list * int * (int -> 'b) -> ('a * 'b) list * int
	val filter_ordered_map : (''a * 'b) list * ''a list -> (''a * 'b) list

        (*     Lambda-Expression Manipulation    *)
        (* -- Please see functor for comments!!  *)

	local 
	    open LambdaTypes 
	   (*  type ''a Set
	       sharing type Set = Set.Set  nj can't hack this... *)
	in
	    val whnf : LambdaExp -> bool

	    val apply_innermost :  (LambdaExp -> LambdaExp) -> 
	        				     LambdaExp -> LambdaExp
	    val apply_outermost : (LambdaExp -> LambdaExp) -> 
	        				     LambdaExp -> LambdaExp
	    val apply_one_level : (LambdaExp -> LambdaExp) ->
	        				     LambdaExp -> LambdaExp

	    val reduce_innermost : (LambdaExp * 'a -> 'a) ->
	      					    (LambdaExp * 'a) -> 'a

	    val reduce_outermost : ('a * LambdaExp -> 'a) ->
	      					    ('a * LambdaExp) -> 'a

	    val reduce_inner_until : (LambdaExp * '_a -> '_a * bool) -> 
	      					    (LambdaExp * '_a) -> '_a

	    val occurrences : LVar * LambdaExp -> int

	    val count_noselects  : LambdaExp * LVar -> int

	    val bounds_and_frees : LambdaExp -> (LVar Set.Set * LVar Set.Set)

	    val substitute : (LVar * LambdaExp) list -> LambdaExp -> LambdaExp
	    val rec_substitute:(LVar * LambdaExp) list -> LambdaExp ->LambdaExp

	    val eval_sequence : LambdaExp -> LambdaExp list
	    val certain_eval_sequence : LambdaExp -> LambdaExp list
	    val evaluation_set : LambdaExp -> LambdaExp Set.Set

	    val is_shiftable : LVar Set.Set -> LambdaExp -> bool

	    val is_commutative : LambdaExp -> bool

	    val beta_reduce : LambdaExp -> LambdaExp

	    val beta_abstract : LambdaExp * LambdaExp -> LVar * LambdaExp

	    val replace_subexpr : LambdaExp * LambdaExp -> 
						   LambdaExp -> LambdaExp

	    val strip_abs : LambdaExp -> LVar list

	    val unwrap_apps : LambdaExp ->  LambdaExp * (LVar * LambdaExp) list

	    val unwrap_lets : LambdaExp -> (LVar * LambdaExp) list * LambdaExp

	    val wrap_lets : LambdaExp * (LVar * LambdaExp) list -> LambdaExp

	    val size_of_expr : LambdaExp -> int
		
	    val rename_fresh : LambdaExp -> LambdaExp


	    val match : (LVar * LambdaExp) list * (LambdaExp * LambdaExp)
						  -> (LVar * LambdaExp) list

	    val alpha_convertible : LambdaExp * LambdaExp -> bool

	end
    end
@


1.14
log
@removed set_of_lvars, changed bounds_and_frees to include
variables bound by LETREC's.
@
text
@d5 4
d80 2
d98 3
d110 3
a112 3
	    val evaluated_sequence : LambdaExp -> LambdaExp list

	    val strictly_evaluated_sequence : LambdaExp -> LambdaExp list
@


1.13
log
@Added sub-expression substitution function "replace_subexpr"
@
text
@d5 3
d133 1
a133 3
	    
	    (* obselete *)
	    val set_of_lvars : LambdaExp -> LVar Set.Set
@


1.12
log
@New functions added
@
text
@d5 3
d68 2
a69 1
        (* Lambda-Expression Manipulation *)
d109 3
@


1.11
log
@Altered selects_on_var for 2nd phase, temporarily.
@
text
@d5 3
d67 4
a70 1
	val whnf : LambdaTypes.LambdaExp -> bool
d72 6
a77 3
	val apply_innermost : 
	    (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) -> 
	        LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp
d79 2
a80 3
	val apply_outermost : 
	    (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) -> 
	        LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp
d82 2
a83 3
	val reduce_innermost :
	    (LambdaTypes.LambdaExp * 'a -> 'a) ->
	      (LambdaTypes.LambdaExp * 'a) -> 'a
d85 1
a85 3
	val reduce_outermost :
	    ('b * LambdaTypes.LambdaExp -> 'b) ->
	      ('b * LambdaTypes.LambdaExp) -> 'b
d87 1
a87 1
	val occurrences : LambdaTypes.LVar * LambdaTypes.LambdaExp -> int
d89 1
a89 2
	val selects_on_var : LambdaTypes.LambdaExp * LambdaTypes.LVar 
					  -> (LambdaTypes.Field list) Set.Set
d91 2
a92 1
	val count_noselects  : LambdaTypes.LambdaExp * LambdaTypes.LVar -> int
d94 1
a94 3
	val bounds_and_frees : LambdaTypes.LambdaExp -> 
	    		        (LambdaTypes.LVar Set.Set * 
				 LambdaTypes.LVar Set.Set)
d96 1
a96 2
	val substitute : (LambdaTypes.LVar * LambdaTypes.LambdaExp) list 
	                  -> LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp
d98 1
a98 2
	val evaluated_sequence : LambdaTypes.LambdaExp ->
	    				LambdaTypes.LambdaExp list
d100 1
a100 2
	val strictly_evaluated_sequence : LambdaTypes.LambdaExp ->
	    					LambdaTypes.LambdaExp list
d102 1
a102 2
	val is_shiftable : LambdaTypes.LVar Set.Set ->
	    				LambdaTypes.LambdaExp -> bool
d104 1
a104 1
	val is_commutative : LambdaTypes.LambdaExp -> bool
d106 1
a106 1
	val beta_reduce : LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp
d108 1
a108 2
	val beta_abstract : LambdaTypes.LambdaExp * LambdaTypes.LambdaExp ->
				LambdaTypes.LVar * LambdaTypes.LambdaExp
d110 1
a110 1
	val strip_abs : LambdaTypes.LambdaExp -> LambdaTypes.LVar list
d112 1
a112 3
	val unwrap_apps : LambdaTypes.LambdaExp ->  
	                    LambdaTypes.LambdaExp *
	    		      (LambdaTypes.LVar * LambdaTypes.LambdaExp) list
d114 3
a116 3
	val nested_apply : LambdaTypes.LambdaExp * 
	    		   (LambdaTypes.LVar * LambdaTypes.LambdaExp) list ->
			        LambdaTypes.LambdaExp
a117 1
	val size_of_expr : LambdaTypes.LambdaExp -> int
d119 2
a120 1
	val rename_fresh : LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp
d122 5
a126 2
        (* obselete *)
	val set_of_lvars : LambdaTypes.LambdaExp -> LambdaTypes.LVar Set.Set
@


1.10
log
@Added function size_of_expr to count number
sub expressions in an expression.
@
text
@d5 4
d85 1
a85 1
								-> int Set.Set
d123 2
@


1.9
log
@Added whnf
@
text
@d5 3
d117 2
@


1.8
log
@Added some more functions, fiddled with some old ones.
@
text
@d5 3
d57 2
d97 2
@


1.7
log
@Changed is_expansive to is_shiftable, added unwrap_apps.
@
text
@d5 3
d84 1
a84 1
	val evaluation_sequence : LambdaTypes.LambdaExp ->
d87 3
d96 1
a96 1
				LambdaTypes.LambdaExp
d103 4
@


1.6
log
@Added require for set to prevent future grief
@
text
@d5 3
d69 2
a70 2
	val selects_on_var : (LambdaTypes.LambdaExp * LambdaTypes.LVar) -> 
	                       					  int Set.Set
d72 2
d84 1
a84 1
	val is_expansive : LambdaTypes.LVar Set.Set ->
d91 6
@


1.5
log
@Added new functions.
@
text
@d5 3
d23 1
@


1.4
log
@Altered form of is_expansive and added set_of_selects
@
text
@d5 3
a41 1

d44 1
a44 1
	val apply_innermost_lexprs : 
d48 1
a48 1
	val apply_outermost_lexprs : 
d52 3
a54 4
	val lvar_occurrences : LambdaTypes.LVar -> LambdaTypes.LambdaExp -> int
	val set_of_lvars : LambdaTypes.LambdaExp -> LambdaTypes.LVar Set.Set
	val set_of_selects : (LambdaTypes.LambdaExp * LambdaTypes.LVar) -> 
	    		         			      int Set.Set
d56 13
d72 3
d77 8
@


1.3
log
@Moved some general purpose functions in from _lambda
@
text
@d5 3
d21 1
a21 2
	structure Set : SET

d24 1
d28 1
a32 1
	val nth : int * 'a list -> 'a
d34 4
a49 1

d52 2
d58 2
a59 6
	val is_expansive : LambdaTypes.Primitive Set.Set -> 
	    				     LambdaTypes.LambdaExp -> bool
	val filter : 'a list * ('a -> bool) -> 'a list
	val filter_length : 'a list * ('a -> bool) -> int
	val number_from : 'a list * int * (int -> 'b) -> ('a * 'b) list * int
	val filter_ordered_map : (''a * 'b) list * ''a list -> (''a * 'b) list
@


1.2
log
@Added new functions set_of_lvars and is_expansive.
@
text
@d5 3
a10 1

d52 5
a56 1
    end;
@


1.1
log
@Initial revision
@
text
@d4 3
a6 1
$Log:$
d8 1
d16 2
d37 5
d43 1
d47 3
@
