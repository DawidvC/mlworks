head	1.5;
access;
symbols
	ML_beta_release_12/08/94:1.5
	ML_beta_release_03/08/94:1.5
	ML_revised_beta_release_25/05/94:1.5
	ML_final_beta_release_02/03/94:1.5
	mlworks-28-01-1994:1.5
	Release:1.5
	mlworks-beta-01-09-1993:1.5
	MLWorks-1-0-4-29/01/1993:1.5
	MLWorks-1-0-3-21/12/1992:1.5
	MLWorks-1-0-2-15/12/1992:1.5
	MLWorks-1-0-1-04/12/1992:1.5
	checkpoint_17_08_92:1.5;
locks; strict;
comment	@ * @;


1.5
date	92.08.05.16.51.55;	author jont;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	92.02.05.18.23.50;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.22.17.56.06;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.09.09.13.18.42;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.05.14.48.39;	author davida;	state Exp;
branches;
next	;

1.5.1.1
date	92.08.05.16.51.55;	author jont;	state Exp;
branches;
next	;


desc
@Library for lambda-optimiser modules.
@


1.5
log
@Removed some structures and sharing
@
text
@
(*
 * Lambda Optimiser : optimise_lib
 * Library Functions
 *
 * Copyright (c) 1991 Harlequin Ltd.
 *)

require "../utils/set";

signature OPTIMISE_LIB =
  sig

    (* functionals *)

    val fst     : 'a * 'b -> 'a
    val snd     : 'a * 'b -> 'b
    val swap    : ('a * 'b -> 'c) -> ('b * 'a) -> 'c
    val curry   : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
    val uncurry : ('a -> 'b -> 'c) -> ('a * 'b) -> 'c
    val apfst   : ('a -> 'c) -> ('a * 'b) -> ('c * 'b)
    val apsnd   : ('b -> 'c) -> ('a * 'b) -> ('a * 'c)
    val fixpoint: ('a * 'a -> bool) -> ('a -> 'a) * 'a -> 'a

    (* set functions *)

    structure Set : SET

    val nullset : ''a Set.Set
    val ++      : ''a Set.Set * ''a -> ''a Set.Set
    val --      : ''a Set.Set * ''a -> ''a Set.Set
    val ==      : ''a Set.Set * ''a Set.Set -> bool
    val mem     : ''a * ''a Set.Set -> bool
  end;

(* $Log: optimise_lib.sml,v $
Revision 1.4  1992/02/05  18:23:50  jont
Removed lists from require list

Revision 1.3  1991/10/22  17:56:06  davidt
The structure LambdaSub.LambdaTypes is now called LambdaSub.LT

Revision 1.2  91/09/09  13:18:42  davida
Library for lambda-optimiser

Revision 1.1  91/09/05  14:48:39  davida
Initial revision
 *)
@


1.5.1.1
log
@Fork for bug fixing
@
text
@a36 3
Revision 1.5  1992/08/05  16:51:55  jont
Removed some structures and sharing

@


1.4
log
@Removed lists from require list
@
text
@a9 2
require "lambdasub";
require "lambdatypes";
a12 3
    structure LS : LAMBDASUB
    structure LT : LAMBDATYPES
    sharing LS.LT = LT
a27 1
    sharing LS.Set = Set
d37 3
@


1.3
log
@The structure LambdaSub.LambdaTypes is now called LambdaSub.LT
@
text
@a8 1
require "../utils/lists";
d42 4
a45 1
(* $Log:	optimise_lib.sml,v $
@


1.2
log
@Library for lambda-optimiser
@
text
@d2 6
a7 1
  (*  Lambda Optimiser :  optimise_lib   *)
a8 5
         (*  Library Functions  *)

  (*  Copyright (c) 1991 Harlequin Ltd.  *)


a13 1

d15 4
a18 3
   sig
      structure LS  : LAMBDASUB
	    and LT  : LAMBDATYPES
d20 1
a20 1
      sharing LS.LambdaTypes = LT
d22 8
a29 1
      (* functionals *)
d31 1
a31 8
      val fst     : 'a * 'b -> 'a
      val snd     : 'a * 'b -> 'b
      val swap    : ('a * 'b -> 'c) -> ('b * 'a) -> 'c
      val curry   : ('a * 'b -> 'c) -> 'a -> 'b -> 'c
      val uncurry : ('a -> 'b -> 'c) -> ('a * 'b) -> 'c
      val apfst   : ('a -> 'c) -> ('a * 'b) -> ('c * 'b)
      val apsnd   : ('b -> 'c) -> ('a * 'b) -> ('a * 'c)
      val fixpoint: ('a * 'a -> bool) -> ('a -> 'a) * 'a -> 'a
d33 2
d36 6
a41 1
      (* set functions *)
d43 3
a45 2
      structure Set : SET
      sharing LS.Set = Set
a46 14
      val nullset : ''a Set.Set
      val ++      : ''a Set.Set * ''a -> ''a Set.Set
      val --      : ''a Set.Set * ''a -> ''a Set.Set
      val ==      : ''a Set.Set * ''a Set.Set -> bool
      val mem     : ''a * ''a Set.Set -> bool


      (* list functions *)

      include LISTS
   end;
   

(* $Log:	optimise_lib.sml,v $
a49 7



	
	 


@


1.1
log
@Initial revision
@
text
@d31 1
d40 2
a41 1
      val ++      : (''a * ''a Set.Set) -> ''a Set.Set
d43 1
a43 1
      val mem     :  (''a * ''a Set.Set) -> bool
d52 4
a55 1
(* $Log$ *)
@
