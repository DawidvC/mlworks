head	1.221;
access;
symbols
	MLW_daveb_inline_1_4_99:1.221.1
	MLWorks_21c0_1999_03_25:1.221
	MLWorks_20c1_1998_08_20:1.219
	MLWorks_20c0_1998_08_04:1.218
	MLWorks_20b2c2_1998_06_19:1.218
	MLWorks_20b2_Windows_1998_06_12:1.218
	MLWorks_20b1c1_1998_05_07:1.218
	MLWorks_20b0_1998_04_07:1.218
	MLWorks_20b0_1998_03_20:1.218
	MLWorks_20m2_1998_02_16:1.214
	MLWorks_20m1_1997_10_23:1.213
	MLWorks_11r1:1.209.1.1.1.1.1
	MLWorks_workspace_97:1.212.2
	MLWorks_dt_wizard:1.212.1
	MLWorks_11c0_1997_09_09:1.209.1.1.1.1
	MLWorks_10r3:1.209.1.1.3
	MLWorks_10r2_551:1.209.1.1.2
	MLWorks_11:1.209.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.209.1.1
	MLWorks_20m0_1997_06_20:1.212
	MLWorks_1_0_r2c2_1997_06_14:1.209.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.209.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.209.1
	MLWorks_BugFix_1997_04_24:1.209
	MLWorks_1_0_r2_Win32_1997_04_11:1.209
	MLWorks_1_0_r2_Unix_1997_04_04:1.209
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.207.3.1.1
	MLWorks_gui_1996_12_18:1.207.4
	MLWorks_1_0_Win32_1996_12_17:1.207.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.207.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.207.1.1
	MLWorks_1_0_Irix_1996_11_28:1.207.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.207.2
	MLWorks_1_0_Unix_1996_11_14:1.207.1
	MLWorks_Open_Beta2_1996_10_11:1.204.1
	MLWorks_License_dev:1.203.1
	MLWorks_1_open_beta_1996_09_13:1.201.1
	MLWorks_Open_Beta_1996_08_22:1.201
	MLWorks_Beta_1996_07_02:1.199
	MLWorks_Beta_1996_06_07:1.199
	MLWorks_Beta_1996_06_06:1.199
	MLWorks_Beta_1996_06_05:1.199
	MLWorks_Beta_1996_06_03:1.199
	MLWorks_Beta_1996_05_31:1.199
	MLWorks_Beta_1996_05_30:1.199
	ML_beta_release_12/08/94:1.159
	ML_beta_release_03/08/94:1.159
	ML_revised_beta_release_25/05/94:1.151
	ML_final_beta_release_02/03/94:1.148
	mlworks-28-01-1994:1.145
	Release:1.137
	mlworks-beta-01-09-1993:1.137
	MLWorks-1-0-4-29/01/1993:1.118
	MLWorks-1-0-3-21/12/1992:1.114
	MLWorks-1-0-2-15/12/1992:1.113
	MLWorks-1-0-1-04/12/1992:1.112
	checkpoint_17_08_92:1.92
	Ten15_release_21-08-91:1.30
	Ten15_release_19-08-91:1.30
	ten15_release:1.27;
locks; strict;
comment	@ * @;


1.221
date	99.02.02.16.00.44;	author mitchell;	state Exp;
branches
	1.221.1.1;
next	1.220;

1.220
date	98.08.24.12.24.51;	author jont;	state Exp;
branches;
next	1.219;

1.219
date	98.08.18.14.41.06;	author jont;	state Exp;
branches;
next	1.218;

1.218
date	98.02.24.12.18.13;	author jont;	state Exp;
branches;
next	1.217;

1.217
date	98.02.20.14.25.28;	author mitchell;	state Exp;
branches;
next	1.216;

1.216
date	98.02.19.18.08.30;	author jont;	state Exp;
branches;
next	1.215;

1.215
date	98.02.17.14.01.33;	author mitchell;	state Exp;
branches;
next	1.214;

1.214
date	98.01.29.10.46.06;	author johnh;	state Exp;
branches;
next	1.213;

1.213
date	97.09.18.15.50.24;	author brucem;	state Exp;
branches;
next	1.212;

1.212
date	97.06.12.10.19.24;	author matthew;	state Exp;
branches
	1.212.1.1
	1.212.2.1;
next	1.211;

1.211
date	97.05.02.14.05.53;	author jont;	state Exp;
branches;
next	1.210;

1.210
date	97.04.25.16.29.55;	author jont;	state Exp;
branches;
next	1.209;

1.209
date	97.02.05.13.34.23;	author matthew;	state Exp;
branches
	1.209.1.1;
next	1.208;

1.208
date	97.01.02.12.40.49;	author matthew;	state Exp;
branches;
next	1.207;

1.207
date	96.11.06.11.02.11;	author matthew;	state Exp;
branches
	1.207.1.1
	1.207.2.1
	1.207.3.1
	1.207.4.1;
next	1.206;

1.206
date	96.11.01.13.48.00;	author io;	state Exp;
branches;
next	1.205;

1.205
date	96.10.28.17.52.50;	author andreww;	state Exp;
branches;
next	1.204;

1.204
date	96.10.02.15.14.06;	author andreww;	state Exp;
branches
	1.204.1.1;
next	1.203;

1.203
date	96.09.23.12.08.01;	author andreww;	state Exp;
branches
	1.203.1.1;
next	1.202;

1.202
date	96.09.20.10.37.47;	author andreww;	state Exp;
branches;
next	1.201;

1.201
date	96.08.05.17.59.38;	author andreww;	state Exp;
branches
	1.201.1.1;
next	1.200;

1.200
date	96.08.01.12.04.49;	author jont;	state Exp;
branches;
next	1.199;

1.199
date	96.04.30.16.41.08;	author jont;	state Exp;
branches;
next	1.198;

1.198
date	96.04.29.14.21.18;	author matthew;	state Exp;
branches;
next	1.197;

1.197
date	96.04.17.10.55.59;	author jont;	state Exp;
branches;
next	1.196;

1.196
date	96.04.16.15.49.15;	author jont;	state Exp;
branches;
next	1.195;

1.195
date	96.04.12.15.56.46;	author jont;	state Exp;
branches;
next	1.194;

1.194
date	96.04.09.15.41.23;	author matthew;	state Exp;
branches;
next	1.193;

1.193
date	96.04.09.13.51.20;	author stephenb;	state Exp;
branches;
next	1.192;

1.192
date	96.04.02.11.55.17;	author stephenb;	state Exp;
branches;
next	1.191;

1.191
date	96.04.01.12.54.29;	author stephenb;	state Exp;
branches;
next	1.190;

1.190
date	96.03.26.16.34.38;	author matthew;	state Exp;
branches;
next	1.189;

1.189
date	96.03.20.12.39.12;	author matthew;	state Exp;
branches;
next	1.188;

1.188
date	96.03.13.10.45.31;	author jont;	state Exp;
branches;
next	1.187;

1.187
date	96.02.22.13.37.53;	author jont;	state Exp;
branches;
next	1.186;

1.186
date	96.02.21.12.01.17;	author jont;	state Exp;
branches;
next	1.185;

1.185
date	96.02.09.17.12.54;	author jont;	state Exp;
branches;
next	1.184;

1.184
date	95.12.27.12.47.00;	author jont;	state Exp;
branches;
next	1.183;

1.183
date	95.12.22.17.21.02;	author jont;	state Exp;
branches;
next	1.182;

1.182
date	95.12.14.14.36.21;	author jont;	state Exp;
branches;
next	1.181;

1.181
date	95.11.03.16.26.16;	author jont;	state Exp;
branches;
next	1.180;

1.180
date	95.10.09.15.03.39;	author daveb;	state Exp;
branches;
next	1.179;

1.179
date	95.09.15.12.53.03;	author daveb;	state Exp;
branches;
next	1.178;

1.178
date	95.09.06.08.54.11;	author daveb;	state Exp;
branches;
next	1.177;

1.177
date	95.08.31.14.11.03;	author jont;	state Exp;
branches;
next	1.176;

1.176
date	95.08.22.16.07.57;	author jont;	state Exp;
branches;
next	1.175;

1.175
date	95.08.10.10.31.13;	author jont;	state Exp;
branches;
next	1.174;

1.174
date	95.08.03.15.36.42;	author jont;	state Exp;
branches;
next	1.173;

1.173
date	95.08.01.10.47.07;	author jont;	state Exp;
branches;
next	1.172;

1.172
date	95.05.02.14.05.47;	author matthew;	state Exp;
branches;
next	1.171;

1.171
date	95.04.07.13.07.25;	author jont;	state Exp;
branches;
next	1.170;

1.170
date	95.03.28.13.06.21;	author matthew;	state Exp;
branches;
next	1.169;

1.169
date	95.03.27.16.52.15;	author jont;	state Exp;
branches;
next	1.168;

1.168
date	95.03.01.13.03.31;	author matthew;	state Exp;
branches;
next	1.167;

1.167
date	95.02.07.17.21.33;	author matthew;	state Exp;
branches;
next	1.166;

1.166
date	95.01.19.16.00.39;	author matthew;	state Exp;
branches;
next	1.165;

1.165
date	94.12.06.10.40.53;	author matthew;	state Exp;
branches;
next	1.164;

1.164
date	94.10.13.11.11.58;	author matthew;	state Exp;
branches;
next	1.163;

1.163
date	94.10.10.09.40.10;	author matthew;	state Exp;
branches;
next	1.162;

1.162
date	94.09.23.12.19.04;	author matthew;	state Exp;
branches;
next	1.161;

1.161
date	94.09.13.14.09.18;	author jont;	state Exp;
branches;
next	1.160;

1.160
date	94.08.18.12.52.38;	author matthew;	state Exp;
branches;
next	1.159;

1.159
date	94.07.20.14.58.25;	author matthew;	state Exp;
branches;
next	1.158;

1.158
date	94.07.08.14.51.00;	author daveb;	state Exp;
branches;
next	1.157;

1.157
date	94.06.27.16.45.08;	author nosa;	state Exp;
branches;
next	1.156;

1.156
date	94.06.27.09.51.17;	author nosa;	state Exp;
branches;
next	1.155;

1.155
date	94.06.22.12.32.16;	author jont;	state Exp;
branches;
next	1.154;

1.154
date	94.06.14.15.59.24;	author daveb;	state Exp;
branches;
next	1.153;

1.153
date	94.06.09.11.47.08;	author nosa;	state Exp;
branches;
next	1.152;

1.152
date	94.06.03.14.38.17;	author matthew;	state Exp;
branches;
next	1.151;

1.151
date	94.05.11.15.01.51;	author daveb;	state Exp;
branches;
next	1.150;

1.150
date	94.04.25.16.39.50;	author jont;	state Exp;
branches;
next	1.149;

1.149
date	94.03.18.17.55.34;	author matthew;	state Exp;
branches;
next	1.148;

1.148
date	94.03.01.10.11.42;	author nosa;	state Exp;
branches;
next	1.147;

1.147
date	94.02.28.07.49.45;	author nosa;	state Exp;
branches;
next	1.146;

1.146
date	94.02.25.15.12.34;	author daveb;	state Exp;
branches;
next	1.145;

1.145
date	94.01.20.12.31.03;	author nosa;	state Exp;
branches;
next	1.144;

1.144
date	93.12.17.15.19.32;	author matthew;	state Exp;
branches;
next	1.143;

1.143
date	93.12.10.11.39.25;	author jont;	state Exp;
branches;
next	1.142;

1.142
date	93.12.03.16.39.03;	author nickh;	state Exp;
branches;
next	1.141;

1.141
date	93.11.29.18.10.31;	author daveb;	state Exp;
branches;
next	1.140;

1.140
date	93.11.25.09.32.52;	author matthew;	state Exp;
branches;
next	1.139;

1.139
date	93.10.28.15.23.56;	author nickh;	state Exp;
branches;
next	1.138;

1.138
date	93.09.22.13.31.32;	author nosa;	state Exp;
branches;
next	1.137;

1.137
date	93.08.24.12.12.39;	author matthew;	state Exp;
branches
	1.137.1.1;
next	1.136;

1.136
date	93.08.20.15.44.32;	author jont;	state Exp;
branches;
next	1.135;

1.135
date	93.08.06.14.44.16;	author matthew;	state Exp;
branches;
next	1.134;

1.134
date	93.07.30.10.34.24;	author nosa;	state Exp;
branches;
next	1.133;

1.133
date	93.07.26.13.43.58;	author jont;	state Exp;
branches;
next	1.132;

1.132
date	93.07.21.15.59.45;	author nosa;	state Exp;
branches;
next	1.131;

1.131
date	93.07.07.16.42.14;	author daveb;	state Exp;
branches;
next	1.130;

1.130
date	93.05.20.12.42.12;	author matthew;	state Exp;
branches;
next	1.129;

1.129
date	93.05.18.18.52.59;	author jont;	state Exp;
branches;
next	1.128;

1.128
date	93.05.04.12.09.10;	author matthew;	state Exp;
branches;
next	1.127;

1.127
date	93.04.07.17.16.57;	author matthew;	state Exp;
branches;
next	1.126;

1.126
date	93.04.06.16.39.21;	author jont;	state Exp;
branches;
next	1.125;

1.125
date	93.03.12.18.46.47;	author matthew;	state Exp;
branches;
next	1.124;

1.124
date	93.03.10.16.34.24;	author matthew;	state Exp;
branches;
next	1.123;

1.123
date	93.03.09.12.34.42;	author matthew;	state Exp;
branches;
next	1.122;

1.122
date	93.03.01.14.17.15;	author matthew;	state Exp;
branches;
next	1.121;

1.121
date	93.02.18.16.48.26;	author matthew;	state Exp;
branches;
next	1.120;

1.120
date	93.02.08.15.30.12;	author matthew;	state Exp;
branches;
next	1.119;

1.119
date	93.02.02.10.14.52;	author matthew;	state Exp;
branches;
next	1.118;

1.118
date	93.01.20.17.57.27;	author daveb;	state Exp;
branches;
next	1.117;

1.117
date	93.01.14.16.39.34;	author nosa;	state Exp;
branches;
next	1.116;

1.116
date	93.01.08.11.36.11;	author daveb;	state Exp;
branches;
next	1.115;

1.115
date	92.12.22.14.59.19;	author jont;	state Exp;
branches;
next	1.114;

1.114
date	92.12.17.17.03.20;	author matthew;	state Exp;
branches;
next	1.113;

1.113
date	92.12.08.18.54.59;	author jont;	state Exp;
branches;
next	1.112;

1.112
date	92.12.01.14.24.56;	author matthew;	state Exp;
branches;
next	1.111;

1.111
date	92.11.30.13.23.52;	author daveb;	state Exp;
branches;
next	1.110;

1.110
date	92.11.26.13.15.09;	author daveb;	state Exp;
branches;
next	1.109;

1.109
date	92.11.06.12.25.38;	author matthew;	state Exp;
branches;
next	1.108;

1.108
date	92.11.04.15.44.53;	author jont;	state Exp;
branches;
next	1.107;

1.107
date	92.11.03.11.28.23;	author daveb;	state Exp;
branches;
next	1.106;

1.106
date	92.10.12.10.02.19;	author clive;	state Exp;
branches;
next	1.105;

1.105
date	92.09.30.12.42.25;	author clive;	state Exp;
branches;
next	1.104;

1.104
date	92.09.25.11.57.15;	author jont;	state Exp;
branches;
next	1.103;

1.103
date	92.09.22.15.19.21;	author clive;	state Exp;
branches;
next	1.102;

1.102
date	92.09.11.16.50.34;	author jont;	state Exp;
branches;
next	1.101;

1.101
date	92.09.10.10.03.34;	author richard;	state Exp;
branches;
next	1.100;

1.100
date	92.09.08.17.52.40;	author matthew;	state Exp;
branches;
next	1.99;

1.99
date	92.09.07.08.14.18;	author clive;	state Exp;
branches;
next	1.98;

1.98
date	92.09.04.10.16.12;	author richard;	state Exp;
branches;
next	1.97;

1.97
date	92.08.26.12.50.22;	author jont;	state Exp;
branches;
next	1.96;

1.96
date	92.08.26.09.07.14;	author clive;	state Exp;
branches;
next	1.95;

1.95
date	92.08.25.17.32.30;	author jont;	state Exp;
branches;
next	1.94;

1.94
date	92.08.20.17.47.00;	author jont;	state Exp;
branches;
next	1.93;

1.93
date	92.08.17.09.27.42;	author clive;	state Exp;
branches;
next	1.92;

1.92
date	92.08.13.13.15.54;	author davidt;	state Exp;
branches;
next	1.91;

1.91
date	92.08.12.12.02.59;	author jont;	state Exp;
branches;
next	1.90;

1.90
date	92.08.06.16.07.14;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	92.08.05.17.36.59;	author jont;	state Exp;
branches;
next	1.88;

1.88
date	92.08.04.10.22.57;	author davidt;	state Exp;
branches;
next	1.87;

1.87
date	92.07.22.11.06.16;	author matthew;	state Exp;
branches;
next	1.86;

1.86
date	92.07.17.13.39.21;	author clive;	state Exp;
branches;
next	1.85;

1.85
date	92.07.06.13.17.31;	author clive;	state Exp;
branches;
next	1.84;

1.84
date	92.07.01.16.20.02;	author davida;	state Exp;
branches;
next	1.83;

1.83
date	92.06.24.10.09.55;	author clive;	state Exp;
branches;
next	1.82;

1.82
date	92.06.23.11.19.25;	author clive;	state Exp;
branches;
next	1.81;

1.81
date	92.06.22.15.07.55;	author clive;	state Exp;
branches;
next	1.80;

1.80
date	92.06.17.16.35.41;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	92.06.15.12.59.14;	author clive;	state Exp;
branches;
next	1.78;

1.78
date	92.06.12.19.33.40;	author jont;	state Exp;
branches;
next	1.77;

1.77
date	92.06.11.19.11.45;	author jont;	state Exp;
branches;
next	1.76;

1.76
date	92.06.11.10.40.09;	author clive;	state Exp;
branches;
next	1.75;

1.75
date	92.06.10.19.40.29;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	92.06.03.17.39.31;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	92.05.26.10.30.43;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	92.05.19.15.42.09;	author clive;	state Exp;
branches;
next	1.71;

1.71
date	92.05.15.16.12.07;	author clive;	state Exp;
branches;
next	1.70;

1.70
date	92.05.12.19.40.42;	author jont;	state Exp;
branches;
next	1.69;

1.69
date	92.05.05.13.34.16;	author clive;	state Exp;
branches;
next	1.68;

1.68
date	92.04.22.14.42.53;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	92.04.13.17.00.43;	author clive;	state Exp;
branches;
next	1.66;

1.66
date	92.03.23.13.50.39;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	92.03.17.18.32.32;	author jont;	state Exp;
branches;
next	1.64;

1.64
date	92.03.17.14.53.24;	author jont;	state Exp;
branches;
next	1.63;

1.63
date	92.03.12.14.20.56;	author clive;	state Exp;
branches;
next	1.62;

1.62
date	92.03.05.12.29.28;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	92.02.20.13.27.37;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	92.02.11.17.19.12;	author clive;	state Exp;
branches;
next	1.59;

1.59
date	92.02.05.18.10.58;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	92.02.03.16.13.04;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	92.01.24.23.29.54;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	92.01.23.18.22.29;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	92.01.09.18.57.56;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	92.01.06.13.42.34;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	92.01.06.13.12.55;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	92.01.02.13.27.05;	author jont;	state Exp;
branches;
next	1.51;

1.51
date	91.12.19.17.27.11;	author jont;	state Exp;
branches;
next	1.50;

1.50
date	91.11.28.17.04.40;	author richard;	state Exp;
branches;
next	1.49;

1.49
date	91.11.27.13.00.29;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	91.11.26.15.12.39;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	91.11.18.15.36.51;	author richard;	state Exp;
branches;
next	1.46;

1.46
date	91.11.14.14.41.53;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	91.11.14.14.01.25;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	91.10.22.17.42.50;	author davidt;	state Exp;
branches;
next	1.43;

1.43
date	91.10.22.16.13.35;	author davidt;	state Exp;
branches;
next	1.42;

1.42
date	91.10.22.10.45.30;	author davidt;	state Exp;
branches;
next	1.41;

1.41
date	91.10.21.14.35.43;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	91.10.09.10.20.49;	author davidt;	state Exp;
branches;
next	1.39;

1.39
date	91.10.08.11.32.54;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	91.10.01.15.52.23;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	91.09.24.11.42.38;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	91.09.16.16.54.15;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.09.11.12.25.22;	author davida;	state Exp;
branches;
next	1.34;

1.34
date	91.09.11.11.37.41;	author davida;	state Exp;
branches;
next	1.33;

1.33
date	91.09.11.09.44.02;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	91.09.04.14.34.05;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	91.08.23.11.51.56;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	91.08.13.16.28.04;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.08.09.14.47.57;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.08.07.16.58.55;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.07.29.12.24.18;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	91.07.24.09.57.50;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	91.07.23.12.40.42;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	91.07.22.13.27.16;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	91.07.17.10.28.18;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	91.07.16.14.50.17;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	91.07.15.14.18.22;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	91.07.12.18.12.26;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	91.07.12.13.32.26;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	91.07.12.10.19.15;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	91.07.11.19.50.42;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	91.07.11.11.46.07;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	91.07.10.11.46.05;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	91.07.09.15.43.26;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	91.07.09.14.42.04;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	91.07.08.17.58.43;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	91.07.05.17.03.20;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.06.27.12.47.13;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.06.26.20.38.31;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.06.25.17.29.53;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.06.25.12.46.14;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.06.21.18.59.58;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.06.21.13.45.31;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.19.18.01.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.17.15.00.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.19.06.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.10.02.54;	author jont;	state Exp;
branches;
next	;

1.137.1.1
date	93.08.24.12.12.39;	author jont;	state Exp;
branches;
next	1.137.1.2;

1.137.1.2
date	93.10.27.16.36.11;	author nickh;	state Exp;
branches;
next	;

1.201.1.1
date	96.09.13.11.17.37;	author hope;	state Exp;
branches;
next	;

1.203.1.1
date	96.10.07.16.07.24;	author hope;	state Exp;
branches;
next	;

1.204.1.1
date	96.10.17.11.25.40;	author hope;	state Exp;
branches;
next	;

1.207.1.1
date	96.11.14.12.50.44;	author hope;	state Exp;
branches
	1.207.1.1.1.1;
next	;

1.207.1.1.1.1
date	96.11.28.15.01.51;	author hope;	state Exp;
branches;
next	;

1.207.2.1
date	96.11.22.18.10.07;	author hope;	state Exp;
branches;
next	;

1.207.3.1
date	96.12.17.17.48.44;	author hope;	state Exp;
branches
	1.207.3.1.1.1;
next	;

1.207.3.1.1.1
date	97.02.24.11.38.47;	author hope;	state Exp;
branches;
next	;

1.207.4.1
date	96.12.18.09.42.46;	author hope;	state Exp;
branches;
next	;

1.209.1.1
date	97.05.12.10.35.13;	author hope;	state Exp;
branches
	1.209.1.1.1.1
	1.209.1.1.2.1
	1.209.1.1.3.1;
next	;

1.209.1.1.1.1
date	97.07.28.18.20.38;	author daveb;	state Exp;
branches
	1.209.1.1.1.1.1.1;
next	;

1.209.1.1.1.1.1.1
date	97.10.07.11.45.54;	author jkbrook;	state Exp;
branches;
next	;

1.209.1.1.2.1
date	97.09.08.17.14.06;	author daveb;	state Exp;
branches;
next	;

1.209.1.1.3.1
date	97.09.09.14.09.49;	author daveb;	state Exp;
branches;
next	;

1.212.1.1
date	97.09.10.19.25.47;	author brucem;	state Exp;
branches;
next	;

1.212.2.1
date	97.09.11.20.55.56;	author daveb;	state Exp;
branches;
next	1.212.2.2;

1.212.2.2
date	97.11.26.17.35.10;	author daveb;	state Exp;
branches;
next	;

1.221.1.1
date	99.04.01.17.57.24;	author daveb;	state Exp;
branches;
next	;


desc
@Abstract syntax to lambda calculus translation. Also definesd types.
@


1.221
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* _lambda.sml the functor *)
(*
$Log: _lambda.sml,v $
 * Revision 1.220  1998/08/24  12:24:51  jont
 * [Bug #70167]
 * Ensure that overloading is resolved for polymorphic equality
 * in order to allow optimisation into monomorphic equality if possible
 *
 * Revision 1.219  1998/08/18  14:41:06  jont
 * [Bug #70068]
 * Only use resolve_ty when we have a potential overloaded operator
 *
 * Revision 1.218  1998/02/24  12:18:13  jont
 * [Bug #70075]
 * Ensure full location info given with exceptions
 *
 * Revision 1.217  1998/02/20  14:25:28  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.216  1998/02/19  18:08:30  jont
 * [Bug #70075]
 * Get exception name back into exceptions
 *
 * Revision 1.215  1998/02/17  14:01:33  mitchell
 * [Bug #30349]
 * Warn when lhs of semicolon does not have type unit
 *
 * Revision 1.214  1998/01/29  10:46:06  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.213  1997/09/18  15:50:24  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.212.2.2  1997/11/26  17:35:10  daveb
 * [Bug #30071]
 *
 * Revision 1.212.2.1  1997/09/11  20:55:56  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.212  1997/06/12  10:19:24  matthew
 * Use StandardIO instead of MLWorks.IO for dynamic redundancy messages
 *
 * Revision 1.211  1997/05/02  14:05:53  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.210  1997/04/25  16:29:55  jont
 * [Bug #20017]
 * Improve polymorphic equality on types with one vcc and no nullaries
 * Also ensure poly eq which turns out to be int32 or word32 eq is coded accordingly
 *
 * Revision 1.209  1997/02/05  13:34:23  matthew
 * Moving inline expansion of ident and not to optimizer
 *
 * Revision 1.208  1997/01/02  12:40:49  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.207  1996/11/06  11:02:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.206  1996/11/01  13:48:00  io
 * [Bug #1614]
 * remove toplevel String.
 *
 * Revision 1.205  1996/10/28  17:52:50  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
 * Revision 1.204  1996/10/02  15:14:06  andreww
 * [Bug #1592]
 * threading locations into Absyn.LOCALexp.
 *
 * Revision 1.203  1996/09/23  12:08:01  andreww
 * [Bug #1605]
 * removing default_overloads flag.  Now subsumed by old_definition.
 *
 * Revision 1.201  1996/08/05  17:59:38  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
 * Revision 1.200  1996/08/01  12:04:49  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
 * Revision 1.199  1996/04/30  16:41:08  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.198  1996/04/29  14:21:18  matthew
 * Integer changes
 *
 * Revision 1.197  1996/04/17  10:55:59  jont
 * Remove references to environprint
 *
 * Revision 1.196  1996/04/16  15:49:15  jont
 * Limit size of default functions inlined when debugging
 *
 * Revision 1.195  1996/04/12  15:56:46  jont
 * Modifying add_binding to add beta reduced versions of the bindings
 * to reduce the amount of store used
 *
 * Revision 1.194  1996/04/09  15:41:23  matthew
 * Change to WHEREsigexp
 *
 * Revision 1.193  1996/04/09  13:51:20  stephenb
 * trans_dec.make_exbind_info: remove Io and Os.SysErr exception handlers
 * The former because it is no longer necessary to support bootstrapping
 * from SML/NJ.  The latter because Module.find_file catches it and
 * converts it into Module.NoSuchFile.
 *
 * Revision 1.192  1996/04/02  11:55:17  stephenb
 * Put Io exception back so that it is possible to bootstrap with SML/NJ.
 *
 * Revision 1.191  1996/04/01  12:54:29  stephenb
 * make_exbind_info: change Io exception to OS.SysErr
 *
 * Revision 1.190  1996/03/26  16:34:38  matthew
 * Changes to VALdec
 *
 * Revision 1.189  1996/03/20  12:39:12  matthew
 * Changed interface to typerep_utils functions
 * ,
 *
 * Revision 1.188  1996/03/13  10:45:31  jont
 * Modify make_exbind_info to handle Io exceptions that may come from failed
 * realpath operations on Win95
 *
 * Revision 1.187  1996/02/22  13:37:53  jont
 * Replacing Map with NewMap
 *
 * Revision 1.186  1996/02/21  12:01:17  jont
 * Add stuff to build more sensible exception names without
 * full pathname info.
 *
 * Revision 1.185  1996/02/09  17:12:54  jont
 * Modify range checking to cope correctly with 16 bit integers and words
 *
Revision 1.184  1995/12/27  12:47:00  jont
Removing Option in favour of MLWorks.Option

Revision 1.183  1995/12/22  17:21:02  jont
Remove references to option structure
in favour of MLWorks.Option

Revision 1.182  1995/12/14  14:36:21  jont
Remove Default type constructor and its value constructors PRESENT and ABSENT
Use MLWorks.Option.option instead

Revision 1.181  1995/11/03  16:26:16  jont
Improvements to local variable debugging mechanism

Revision 1.180  1995/10/09  15:03:39  daveb
Corrected the types given to the derived operations on small integer and
word types.  (This bug only manifested when generating debug info).

Revision 1.179  1995/09/15  12:53:03  daveb
Changed the implementation of short word and int operations to be
functions, to ensure that new LVars are created for each operation.

Revision 1.178  1995/09/06  08:54:11  daveb
Added types for different lengths of words, ints and reals.

Revision 1.177  1995/08/31  14:11:03  jont
Changes to printing of redundancy information

Revision 1.176  1995/08/22  16:07:57  jont
Fix code generation problems for equality on types with
same names as builtin types

Revision 1.175  1995/08/10  10:31:13  jont
Modifications to allow defaults to be optional in special constant matches

Revision 1.174  1995/08/03  15:36:42  jont
Change to use MLWorks.Option

Revision 1.173  1995/08/01  10:47:07  jont
Change test for overloaded name to be robust against
redefinition as another primitive
Improvements to give inline equality on arrays, bytearrays, words and chars.

Revision 1.172  1995/05/02  14:05:47  matthew
Signal an error for an unresolved record label
Remove polyvariable debugging
Remove stepping stuff

Revision 1.171  1995/04/07  13:07:25  jont
Fix over enthusiastic assumptions about META_OVERLOADED types

Revision 1.170  1995/03/28  13:06:21  matthew
Problem with match translator returning incomplete match default functions.

Revision 1.169  1995/03/27  16:52:15  jont
Remove Builtin_p and modify FindBuiltin

Revision 1.168  1995/03/01  13:03:31  matthew
Simplified Stepper and Breakpoint code

Revision 1.167  1995/02/07  17:21:33  matthew
Debugger work

Revision 1.166  1995/01/19  16:00:39  matthew
Attempting to sort out the debugger code

Revision 1.165  1994/12/06  10:40:53  matthew
Changing uses of cast

Revision 1.164  1994/10/13  11:11:58  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.163  1994/10/10  09:40:10  matthew
Lambdatypes changes

Revision 1.162  1994/09/23  12:19:04  matthew
Abstraction of debug information in lambdatypes
Various bits of tidying up

Revision 1.161  1994/09/13  14:09:18  jont
Fix constructor names so that -delivery can deal with them

Revision 1.160  1994/08/18  12:52:38  matthew
Change name of default functions

Revision 1.159  1994/07/20  14:58:25  matthew
Functions and applications take a list of parameters

Revision 1.158  1994/07/08  14:51:00  daveb
Simplified selection of overloaded primitives.

Revision 1.157  1994/06/27  16:45:08  nosa
Bindings in Match DEFAULT trees.

Revision 1.156  1994/06/27  09:51:17  nosa
Match trees alteration : nodes can now disintegrate into default trees.

Revision 1.155  1994/06/22  12:32:16  jont
Update debugger information production

Revision 1.154  1994/06/14  15:59:24  daveb
Modified resolution of overloading - some cases weren't getting caught.
Now calls Types.resolve_overloading for all variables.

Revision 1.153  1994/06/09  11:47:08  nosa
Breakpoint settings on function exits;
FUNCTION RETURN value bindings for stepper;
Tidied up a little bit.

Revision 1.152  1994/06/03  14:38:17  matthew
Added call to resolve_overloading in translation of dynamic expression

Revision 1.151  1994/05/11  15:01:51  daveb
New overloading scheme.

Revision 1.150  1994/04/25  16:39:50  jont
Fix non-generative exception problems

Revision 1.149  1994/03/18  17:55:34  matthew
Always generated debug information for exceptions.

Revision 1.148  1994/03/01  10:11:42  nosa
nongeneric weak type variable in functor_refs.

Revision 1.147  1994/02/28  07:49:45  nosa
Step and Breakpoints Debugger;
Modules Debugger : Dynamic Type Name Instantiation.

Revision 1.146  1994/02/25  15:12:34  daveb
Removed old parameter to trans_top_dec,
Made generation of debug info for setup functions obey flag.

Revision 1.145  1994/01/20  12:31:03  nosa
Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching

Revision 1.144  1993/12/17  15:19:32  matthew
 Changed so inexhaustive bindings are only reported if not at top level.

Revision 1.143  1993/12/10  11:39:25  jont
Fixed layered patterns to generate binding inexhaustive warnings when necessary

Revision 1.142  1993/12/03  16:39:03  nickh
Added location information to COERCEexp.

Revision 1.141  1993/11/29  18:10:31  daveb
Added the symbol name to the "Unresolved overloading" error message.

Revision 1.140  1993/11/25  09:32:52  matthew
Added fixity annotations to absyn.

Revision 1.139  1993/10/28  15:23:56  nickh
Merging in code change.

Revision 1.138  1993/09/22  13:31:32  nosa
Polymorphic debugger;
instances of polymorphic functions are passed round at runtime.

Revision 1.137  1993/08/24  12:12:39  matthew
Tidied up debug information stuff
Debug information for exceptions is now always generated.

Revision 1.136  1993/08/20  15:44:32  jont
Added further error message for inexhaustive binding without variables

Revision 1.135  1993/08/06  14:44:16  matthew
Added location information to matches

Revision 1.134  1993/07/30  10:34:24  nosa
Local and closure variable inspection in the debugger;
new compiler option debug_variables; changed types of constructors
LET, LETREC, LETB, and Tags.

Revision 1.133  1993/07/26  13:43:58  jont
Tidied up inexhaustive match output to remove excessive new lines

Revision 1.132  1993/07/21  15:59:45  nosa
More informative inexhaustiveness reporting

Revision 1.131  1993/07/07  16:42:14  daveb
Removed exception environments and interfaces.
Funenvs no longer have interface components.  Instead, info about functor
arguments is found in the type basis.
Exceptions are always stored in the value environment.  Matching of
exceptions against value specifications requires some extra work.

Revision 1.130  1993/05/20  12:42:12  matthew
Added code for abstractions.

Revision 1.129  1993/05/18  18:52:59  jont
Removed integer parameter

Revision 1.128  1993/05/04  12:09:10  matthew
Added case for TYPEDpat's in pat_name function.

Revision 1.127  1993/04/07  17:16:57  matthew
Renamed Typerep_Utils to TyperepUtils
Added call to TyperepUtils.convert_dynamic_type

Revision 1.126  1993/04/06  16:39:21  jont
Added code to deal with inexhaustive bindings and bindings without variables
Fixed a bug in value bindings of nullary exception constructors

Revision 1.125  1993/03/12  18:46:47  matthew
Generate error for unresolved overloaded operators

Revision 1.124  1993/03/10  16:34:24  matthew
Options changes
Signature revisions

Revision 1.123  1993/03/09  12:34:42  matthew
Options & Info changes

Revision 1.122  1993/03/01  14:17:15  matthew
Added MLVALUE lambda exp
Dynamic expressions get translated into a pair of the expression and the MLVALUE of its type

Revision 1.121  1993/02/18  16:48:26  matthew
Added TypeRep_Utils parameter and translations of dynamic and coerce expressions

Revision 1.120  1993/02/08  15:30:12  matthew
Removed ref nameset in Absyn.FunBind

Revision 1.119  1993/02/02  10:14:52  matthew
Modifications for COPYSTR.
Added caching of interfaces in structures and environments in interfaces.

Revision 1.118  1993/01/20  17:57:27  daveb
Fixed bug in matching lists in value declarations.

Revision 1.117  1993/01/14  16:39:34  nosa
Deleted label handling in lambda translator.

Revision 1.116  1993/01/08  11:36:11  daveb
Changes to support new representation of lists.

Revision 1.115  1992/12/22  14:59:19  jont
Anel's last changes

Revision 1.114  1992/12/17  17:03:20  matthew
Changed int and real scons to carry a location around

Revision 1.113  1992/12/08  18:54:59  jont
Removed a number of duplicated signatures and structures

Revision 1.112  1992/12/01  14:24:56  matthew
Changed an error message.

Revision 1.111  1992/11/30  13:23:52  daveb
Deleted some list optimisation code that crept in prematurely.

Revision 1.110  1992/11/26  13:15:09  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.109  1992/11/06  12:25:38  matthew
Changed Error structure to Info

Revision 1.108  1992/11/04  15:44:53  jont
Changes to allow IntNewMap to be used on MatchVar

Revision 1.107  1992/11/03  11:28:23  daveb
Switches now have both value-carrying and immediate constructors in the
same switch.  They also contain information about the number of each
sort of constructor in the datatype.

Revision 1.106  1992/10/12  10:02:19  clive
Tynames now have a slot recording their definition point so constructor functions can have
more information in them

Revision 1.105  1992/09/30  12:42:25  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.104  1992/09/25  11:57:15  jont
Removed and tidied up lots of instances of map, replaced various
Lists.length o NewMap.to_list with NewMap.size, generally tidied up

Revision 1.103  1992/09/22  15:19:21  clive
Better annotations

Revision 1.102  1992/09/11  16:50:34  jont
Some minor improvements in determining whether or not constructors
of various types exist

Revision 1.101  1992/09/10  10:03:34  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.100  1992/09/08  17:52:40  matthew
Changes to absyn

Revision 1.99  1992/09/07  08:14:18  clive
Datatype fred = Abs of int | ... -> val Abs <VAR> = Abs<CON> which was code-generated in the current
environment instead of the empty environment - since Abs was builtin this did not work

Revision 1.98  1992/09/04  10:16:12  richard
Installed central error reporting mechanism.

Revision 1.97  1992/08/26  12:50:22  jont
Removed some redundant structures and sharing

Revision 1.96  1992/08/26  09:07:14  clive
Added the recording of information about exceptions

Revision 1.95  1992/08/25  17:32:30  jont
Did tail recursive versions for translations of sequences of decs
and sequences of strdecs

Revision 1.94  1992/08/20  17:47:00  jont
Preserved builtin-ness across rebindings

Revision 1.93  1992/08/17  09:27:42  clive
The actual application of the functor was missed out

Revision 1.92  1992/08/13  13:15:54  davidt
Removed NewMap.domain_ordered and replaced with NewMap.rank'
which doesn't build an intermediate list.

Revision 1.91  1992/08/12  12:02:59  jont
Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}

Revision 1.90  1992/08/06  16:07:14  jont
Anel's changes to use NewMap instead of Map

Revision 1.90  1992/08/06  16:07:14  jont
Anel's changes to use NewMap instead of Map

Revision 1.89  1992/08/05  17:36:59  jont
Removed some structures and sharing

Revision 1.88  1992/08/04  10:22:57  davidt
Put in correct type annotations for UPDATE and BECOMES optimisations.

Revision 1.87  1992/07/22  11:06:16  matthew
Changed interface to match compiler to for passing back of redundancy and exhaustiveness information

Revision 1.86  1992/07/17  13:39:21  clive
null_type_annotation is no longer a function

Revision 1.85  1992/07/06  13:17:31  clive
Generation of function call point debug information

Revision 1.84  1992/07/01  16:20:02  davida
Added LET constructor and new slot to APP.

Revision 1.83  1992/06/24  10:09:55  clive
Added an annotation for excaptions

Revision 1.82  1992/06/23  11:19:25  clive
Added an annotation slot to HANDLE

Revision 1.81  1992/06/22  15:07:55  clive
More data put into the debug slot of exceptions

Revision 1.80  1992/06/17  16:35:41  jont
Fixed problem whereby structures were being taken apart only to be rebuilt
exactly as before

Revision 1.79  1992/06/15  12:59:14  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.78  1992/06/12  19:33:40  jont
Added ident function for type casting required by interpreter

Revision 1.77  1992/06/11  19:11:45  jont
Sorted out compare_names stuff

Revision 1.76  1992/06/11  10:40:09  clive
Added type annotations to FNexp

Revision 1.75  1992/06/10  19:40:29  jont
changed to use newmap

Revision 1.74  1992/06/03  17:39:31  jont
Moved assign_fields into environ

Revision 1.73  1992/05/26  10:30:43  jont
Added some optimisation of polymorphic equality tests, on refs
and datatypes with no value carrying constructors

Revision 1.72  1992/05/19  15:42:09  clive
Added marks to some of the abstract syntax

Revision 1.71  1992/05/15  16:12:07  clive
Added more documentation to fn's

Revision 1.70  1992/05/12  19:40:42  jont
Changed signature comparison test to check for equal before sorting,
as the implementation tends to deliver the data in order anyway

Revision 1.69  1992/05/05  13:34:16  clive
Added more useful diagnostic info

Revision 1.68  1992/04/22  14:42:53  jont
Modified APPexp translation so beta reduction is only called
when equality is being applied to a pair of values from a datatype,
one of which may be constant

Revision 1.67  1992/04/13  17:00:43  clive
First version of the profiler

Revision 1.66  1992/03/23  13:50:39  jont
Changed length for Lists.length in various places. Removed word require
from trans_top_dec since this confuses the parser

Revision 1.65  1992/03/17  18:32:32  jont
Added bool ref for add_fn_names to control addition of function names

Revision 1.64  1992/03/17  14:53:24  jont
Added function name propagation to the lambda translation

Revision 1.63  1992/03/12  14:20:56  clive
val (ref ...) = exp wasn't introducing an extra DEREF operation

Revision 1.62  1992/03/05  12:29:28  jont
Fixed problem whereby lambda expressions were being duplicated for
the two defaults in a CONS switch pair

Revision 1.61  1992/02/20  13:27:37  jont
Added show_match to control printing of match trees

Revision 1.60  1992/02/11  17:19:12  clive
New pervasive library - tried to neaten code

Revision 1.59  1992/02/05  18:10:58  jont
Fixed bug in complete_struct_with_sig whereby recursive calls
were binding variables to the result expression in what they
should have been bound to (ie it said let lv = le' in le when it
should have said let lv = le in le')

Revision 1.58  1992/02/03  16:13:04  jont
Fixed bug in open whereby exception environment and bindings weren't made

Revision 1.57  1992/01/24  23:29:54  jont
Extracted out type fiddling functions into match/type_utils

Revision 1.56  1992/01/23  18:22:29  jont
Removed some small type structure manipulation functions into
a separate file match/type_utils. Other should follow some time,
eg record_tag and constructor_tag

Revision 1.55  1992/01/09  18:57:56  jont
Fixed bug in determination of overloading from the evnironment,
instead of looking up the last part of the name in the known overloads,
we must check the path is empty, and it produces a primitive, and
then see if it's in the overloaded set

Revision 1.54  1992/01/06  13:42:34  jont
Changed LETREC to use new RECLET binding (much simpler)

Revision 1.53  1992/01/06  13:12:55  jont
Changed trans_topdec and complete_struct_from_topenv to use new
binding type

Revision 1.52  1992/01/02  13:27:05  jont
Altered exception form to be STRUCT[unique, string name]

Revision 1.51  1991/12/19  17:27:11  jont
Removed processing of REQUIRE, it should never get this far

Revision 1.50  91/11/28  17:04:40  richard
Changed the way that exception uniques are generated to be an
application of REF to unit rather than a special pervasive.  This
allows us to compile the pervasive library itself, but may need
further work.

Revision 1.49  91/11/27  13:00:29  jont
Changed Match_Utils.Qsort to Lists.qsort

Revision 1.48  91/11/26  15:12:39  jont
Improved cg_longexid and cg_longstrid to allow generation to primitives

Revision 1.47  91/11/18  15:36:51  richard
Caused the Bind and Match exceptions to use the pervasived directly
rather than trying to look up the current definitions in the environment.

Revision 1.46  91/11/14  14:41:53  jont
Fixed get_lamb_env to allow Primitive structure heads for library

Revision 1.45  91/11/14  14:01:25  jont
Allowed translation of final component of a longvalid to a primitive,
to allow creation of library

Revision 1.44  91/10/22  17:42:50  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.43  91/10/22  16:13:35  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.42  91/10/22  10:45:30  davidt
Changed is_overloaded so that it works properly (this function will
probably change quite soon but this is just to get the code generator
up and running again).

Revision 1.41  91/10/21  14:35:43  jont
Modified overloaded operator detection

Revision 1.40  91/10/09  10:20:49  davidt
General tidy up, Made changes due to record selection now requiring
the total size of the record to be present as well as the index.

Revision 1.39  91/10/08  11:32:54  jont
Changed use of lambdasub.number_from to lists.number_from_by_one

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basis/__int";
require "^.basis.__string";
require "^.system.__os";

require "../utils/lists";
require "../utils/intnewmap";
require "../utils/crash";
require "../utils/print";
require "../utils/diagnostic";
require "../utils/inthashtable";
require "../typechecker/types";
require "../typechecker/typerep_utils";
require "../typechecker/basis";
require "../basics/absynprint";
require "../basics/identprint";
require "../basics/module_id";
require "../match/type_utils";
require "../main/primitives";
require "../main/pervasives";
require "../main/machspec";
require "../rts/gen/implicit";
require "../main/info";
require "../debugger/debugger_types";
require "../match/match";
require "environ";
require "lambdaprint";
require "lambdaoptimiser";

require "lambda";

(**
    The functor for translating from abstract syntax to extended
    lambda calculus.  And for defining the datatypes used.

    Last updated : Fri Mar 15 17:11:12 1991
**)

functor Lambda (
  structure Diagnostic : DIAGNOSTIC
  structure Lists : LISTS
  structure IntHashTable : INTHASHTABLE
  structure IntNewMap : INTNEWMAP
  structure Crash : CRASH
  structure Print: PRINT
  structure AbsynPrint : ABSYNPRINT
  structure IdentPrint : IDENTPRINT
  structure Types : TYPES
  structure TypeUtils : TYPE_UTILS
  structure Basis: BASIS
  structure Primitives : PRIMITIVES
  structure Pervasives : PERVASIVES
  structure MachSpec : MACHSPEC
  structure ImplicitVector : IMPLICIT_VECTOR
  structure TyperepUtils : TYPEREP_UTILS
  structure Info : INFO
  structure Debugger_Types : DEBUGGER_TYPES
  structure Match : MATCH where type Matchvar = int
  structure Environ : ENVIRON
  structure LambdaPrint: LAMBDAPRINT
  structure LambdaOptimiser: LAMBDAOPTIMISER

  sharing LambdaOptimiser.LambdaTypes =
    Environ.EnvironTypes.LambdaTypes = LambdaPrint.LambdaTypes
  sharing Types.Datatypes = TypeUtils.Datatypes = TyperepUtils.Datatypes =
	  Basis.BasisTypes.Datatypes = AbsynPrint.Absyn.Datatypes
  sharing LambdaPrint.LambdaTypes.Ident = AbsynPrint.Absyn.Ident = IdentPrint.Ident = Types.Datatypes.Ident
  sharing Match.Absyn = AbsynPrint.Absyn = TyperepUtils.Absyn
  sharing Environ.EnvironTypes = Primitives.EnvironTypes
  sharing Info.Location = AbsynPrint.Absyn.Ident.Location
  sharing Match.Options = Types.Options = AbsynPrint.Options =
    IdentPrint.Options = LambdaPrint.Options
  sharing Environ.EnvironTypes.NewMap = Types.Datatypes.NewMap
  sharing LambdaPrint.LambdaTypes.Set = AbsynPrint.Absyn.Set

  sharing type LambdaPrint.LambdaTypes.FunInfo = Debugger_Types.RuntimeEnv.FunInfo
  sharing type LambdaPrint.LambdaTypes.VarInfo = Debugger_Types.RuntimeEnv.VarInfo
  sharing type Debugger_Types.RuntimeEnv.RuntimeInfo = AbsynPrint.Absyn.RuntimeInfo
  sharing type Environ.EnvironTypes.LambdaTypes.LVar = Match.lvar
  sharing type LambdaPrint.LambdaTypes.Primitive = Pervasives.pervasive
  sharing type Environ.Structure = Types.Datatypes.Structure = AbsynPrint.Absyn.Structure
  sharing type Debugger_Types.Type = LambdaPrint.LambdaTypes.Type
    = Types.Datatypes.Type = AbsynPrint.Absyn.Type = Debugger_Types.RuntimeEnv.Type
  sharing type Types.Datatypes.InstanceInfo = AbsynPrint.Absyn.InstanceInfo
  sharing type Types.Datatypes.Instance = AbsynPrint.Absyn.Instance =
    Debugger_Types.RuntimeEnv.Instance
  sharing type LambdaPrint.LambdaTypes.Tyfun = Types.Datatypes.Tyfun
    = AbsynPrint.Absyn.Tyfun = Debugger_Types.RuntimeEnv.Tyfun
  sharing type LambdaPrint.LambdaTypes.DebuggerStr = Types.Datatypes.DebuggerStr
    = AbsynPrint.Absyn.DebuggerStr
  sharing type LambdaPrint.LambdaTypes.Structure = AbsynPrint.Absyn.Structure
) : LAMBDA =
struct
  structure Diagnostic = Diagnostic
  structure Absyn = AbsynPrint.Absyn
  structure Datatypes = Types.Datatypes
  structure BasisTypes = Basis.BasisTypes
  structure EnvironTypes = Environ.EnvironTypes
  structure LambdaTypes = EnvironTypes.LambdaTypes
  structure Ident = IdentPrint.Ident
  structure Location = Ident.Location
  structure Symbol = Ident.Symbol
  structure NewMap = Datatypes.NewMap
  structure Set = LambdaTypes.Set
  structure Debugger_Types = Debugger_Types
  structure Info = Info
  structure Options = Types.Options
  structure RuntimeEnv = Debugger_Types.RuntimeEnv

  type DebugInformation = Debugger_Types.information

(*
  datatype union = datatype Match.union
*)

  (* Some controls *)

  val do_exit_stuff = false
  val generate_moduler_debug = false
  (* Controls whether polyvariable and module debugging code is generated at all *)
  (* Switch this off for the moment -- options are disabled anyway *)
  val do_fancy_stuff = false

  val show_match = false

  (* General utils *)

  val cast : 'a -> 'b = MLWorks.Internal.Value.cast

  val unit_exp = LambdaTypes.STRUCT ([],LambdaTypes.TUPLE)

(*  fun substring (str1,str2) =
    let
      val str1 = explode str1
      val str2 = explode str2
      fun tl [] = []
        | tl (a::l) = l
      fun substring (nil,_,_) = true
        | substring (_,nil,_) = false
        | substring (x::xs,y::ys,yys) =
          if x = y then substring (xs,ys,yys)
          else substring(str1,yys,tl yys)
    in
      substring (str1,str2,tl str2)
    end
*)

  fun valid_symbol (Ident.VAR sy) = sy
    | valid_symbol (Ident.CON sy) = sy
    | valid_symbol (Ident.EXCON sy) = sy
    | valid_symbol (Ident.TYCON' sy) = sy

  (* Some utilities *)

  val function_return_string = "<function return>"

  val overload_function_string = "<overload function>"

  local
    val functor_app_string = "functor app"
  in
    val is_functor_app = String.isPrefix functor_app_string
    val new_LVar = LambdaTypes.new_LVar

    fun make_functor_app n =
      Symbol.find_symbol ("<" ^ functor_app_string ^ Int.toString n ^ ">")
  end (* local *)

  fun funny_name_p name  =
    ((substring(name,0,4) = "<if>" orelse
      substring(name,0,5) = "<seq>" orelse
      substring(name,0,6) = "<case>" orelse
      substring(name,0,8) = "<handle>")
    handle Subscript => false)

  fun valid_name valid = Symbol.symbol_name (valid_symbol valid)

  fun make_short_id name = Ident.VAR (Symbol.find_symbol name)

  fun make_longid (path,name) =
    let
      fun make_path [] = Ident.NOPATH
        | make_path (a::l) = Ident.PATH (Symbol.find_symbol a,make_path l)
    in
      Ident.LONGVALID (make_path path,make_short_id name)
    end

  fun combine_paths (Ident.NOPATH,p) = p
    | combine_paths (Ident.PATH(s,p), p') = Ident.PATH(s,combine_paths (p,p'))

  fun select_exn_unique(LambdaTypes.STRUCT([unique, _],_)) = unique
    | select_exn_unique lexp =
      LambdaTypes.SELECT({index=0, size=2,selecttype = LambdaTypes.CONSTRUCTOR}, lexp)

  fun v_order((v1, _), (v2, _)) = Ident.valid_order(v1, v2)

  fun s_order((s1, _), (s2, _)) = Ident.strid_order(s1, s2)

  fun known_order ((lab1, _, _), (lab2, _, _)) = Ident.lab_order (lab1, lab2)
(** search for a value in a list of such objects, returning it's
    position if found, or raising an exception **)

    (* Should this take account of TYFUNs? *)
  fun is_list_type (Datatypes.CONSTYPE(_, tyname)) =
    Types.tyname_eq(tyname, Types.list_tyname)
  |   is_list_type _ = false

  val dummy_var = new_LVar()
  val dummy_varexp = LambdaTypes.VAR dummy_var

  val env_reduce =
    Lists.reducel
    (fn (env, (env', _, _)) => Environ.augment_env(env, env'))

  val denv_reduce =
    Lists.reducel
    (fn (env, (_, env',_)) => Environ.augment_denv(env, env'))

  fun env_from_list env_le_list =
    env_reduce(Environ.empty_env, env_le_list)

  fun denv_from_list env_le_list =
    denv_reduce(Environ.empty_denv, env_le_list)

  fun constructor_tag (valid,ty) =
    (let
      val (location,valenv) = TypeUtils.get_valenv(TypeUtils.get_cons_type ty)
    in
       (location, NewMap.rank'(valenv, valid))
    end
       handle NewMap.Undefined =>
         Crash.impossible("constructor_tag(3): " ^ 
                          Types.debug_print_type 
                             Types.Options.default_options ty ^ "," ^
                          IdentPrint.debug_printValId valid))

        (* any old options should do when printing out the results of
           the impossible case *)


  fun record_label_offset(lab, the_type,error_info,loc) =
    let
      fun record_domain(Datatypes.RECTYPE map) = map
        | record_domain(Datatypes.METARECTYPE(ref (_,flex,
                                                   ty as Datatypes.METARECTYPE _,
                                                   _,_))) =
          if flex then
	    record_domain ty
          else
            Crash.impossible
            "contradiction between boolean and type in METARECTYPE 1"
        | record_domain(Datatypes.METARECTYPE(ref (_,flex,
                                                   ty as Datatypes.RECTYPE _,
                                                   _,_))) =
          if flex then
	    let
	      val Ident.LAB sym = lab
	      val sym_name = Symbol.symbol_name sym
	    in
	      Info.error
	      error_info
	      (Info.RECOVERABLE, loc,
	       "Unresolved record type for label: #" ^ sym_name);
	      record_domain ty
	    end
          else record_domain ty
        | record_domain _ = Crash.impossible ("record_tag(2)")

      val record_domain = record_domain the_type

(*
      fun position (head::tail, n) =
        if lab = head then n
	else position (tail, n+1)
	| position ([], _) =
	  Crash.impossible("record_tag(1)")
*)
    in
      {index = NewMap.rank record_domain lab,
       size = NewMap.size record_domain,
       selecttype = LambdaTypes.TUPLE}
    end

(*
    Representations of types.
    All nullary constructors are represented as small integers.
    All types involving precisely one constructor, which is itself value
    carrying are represented as the type of the value carried.
    All types involving more than one constructor
    have the value carrying constructors represented as pairs, of
    which field zero is the tag and field one the value.

    datatype t = a | b                Small integers
    datatype int list = [] | cons of (int * int list)
                                      One vcc
    datatype u = A | B(t)             One vcc
    datatype v = x(t) | y(u) | z      More than one vcc
*)

  (* A function to find the name of the type to which an overloaded type
     variable has been instantiated.
  *)
  fun overloaded_name (Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
    (case NewMap.range record_map of
       ty as Datatypes.META_OVERLOADED (r, tv, valid, loc) :: _ =>
	 (case Types.the_type (!r) of
	    Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => s
	  | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => s
	  | _ => Crash.impossible "overloaded_name (1)")
(*
     | Datatypes.METATYVAR _ :: _ => Crash.impossible "overloaded_name (2) METATYVAR"
     | Datatypes.TYVAR _ :: _ => Crash.impossible "overloaded_name (2) TYVAR"
     | Datatypes.METARECTYPE _ :: _ => Crash.impossible "overloaded_name (2) METARECTYPE"
     | Datatypes.RECTYPE _ :: _ => Crash.impossible "overloaded_name (2) RECTYPE"
     | Datatypes.FUNTYPE _ :: _ => Crash.impossible "overloaded_name (2) FUNTYPE"
     | Datatypes.DEBRUIJN _ :: _ => Crash.impossible "overloaded_name (2) DEBRUIJN"
*)
     | Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) :: _ => s
     | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) :: _ => s
     | _ => Crash.impossible "overloaded_name (2)")
  | overloaded_name
      (Datatypes.FUNTYPE
         (ty as Datatypes.META_OVERLOADED (r, tv, valid, loc), _)) =
    (case Types.the_type (!r) of
       Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => s
     | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => s
     | _ => Crash.impossible "overloaded_name (3)")
  | overloaded_name(Datatypes.FUNTYPE(Datatypes.CONSTYPE(_, tyname), _)) =
      (case tyname of
	 Datatypes.TYNAME{2=s,...} => s
       | Datatypes.METATYNAME{2=s,...} => s)
  | overloaded_name _ = Crash.impossible "overloaded_name (4)"

  (* The overloaded operations for particular sizes of numeric types are
   * defined in terms of the built-in operations.  This avoids increasing the
   * size of the rest of the compiler with unnecessary built-in operations.
   *
   * The integer operations for sizes less than the size of the default
   * check for overflow by adding the largest negative integer of that size
   * to bring the value in to the range 0 - 2^n, and then using an unsigned
   * comparison to test for overflow.
   *)

  fun mk_binop_type t =
    Datatypes.FUNTYPE
    (Datatypes.RECTYPE
     (NewMap.define'
      (NewMap.define'(NewMap.empty' Ident.lab_lt, (Ident.LAB(Symbol.find_symbol"1"), t)),
       (Ident.LAB(Symbol.find_symbol"2"), t))),
     t)

  local
    fun check_range (abs_min_int, max_word) x =
      let
        val addition =
          LambdaTypes.APP
            (LambdaTypes.BUILTIN Pervasives.UNSAFEINTPLUS,
             ([LambdaTypes.STRUCT ([LambdaTypes.VAR x,
                                    LambdaTypes.SCON
                                    (Ident.INT (abs_min_int, Location.UNKNOWN), NONE)],
                                   LambdaTypes.TUPLE)],
              []),
             NONE)

        val comparison =
	  LambdaTypes.APP
	    (LambdaTypes.BUILTIN Pervasives.WORDGT,
             ([LambdaTypes.STRUCT ([addition,
                                    LambdaTypes.SCON
                                    (Ident.INT (max_word, Location.UNKNOWN), NONE)],
                                   LambdaTypes.TUPLE)],
              []),
             NONE)
      in
        LambdaTypes.SWITCH
	  (comparison,
	   SOME {num_vccs = 0, num_imms = 2},
	   [(LambdaTypes.IMM_TAG ("", 1),
             LambdaTypes.RAISE
	       (LambdaTypes.STRUCT
	          ([LambdaTypes.BUILTIN Pervasives.EXOVERFLOW, unit_exp],
	        LambdaTypes.CONSTRUCTOR)))],
	   SOME (LambdaTypes.VAR x))
      end

    val check_range_8 = check_range ("128", "255")
    val check_range_16 = check_range ("32768", "65535")

    fun overloaded_int_op (check_range, result_type) opcode () =
      let
        val arg = LambdaTypes.new_LVar ()
        val tmp = LambdaTypes.new_LVar ()
      in
        LambdaTypes.FN
          (([arg],[]),
	   LambdaTypes.LET
	     ((tmp,
	       NONE,
               LambdaTypes.APP
                 (LambdaTypes.BUILTIN opcode,
	          ([LambdaTypes.VAR arg],[]),
		  NONE)),
	      check_range (tmp)),
           LambdaTypes.BODY,
	   "<Built in fixed size int operation>",
	   result_type,
	   RuntimeEnv.INTERNAL_FUNCTION)
    end
  in
    val int8_op =
      overloaded_int_op (check_range_8, mk_binop_type Types.int8_type)
    val int16_op =
      overloaded_int_op (check_range_16, mk_binop_type Types.int16_type)
  end

  local
    fun clamp_word mask var =
      LambdaTypes.APP
        (LambdaTypes.BUILTIN Pervasives.WORDANDB,
         ([LambdaTypes.STRUCT ([LambdaTypes.VAR var,
                                LambdaTypes.SCON
                                (Ident.WORD (mask, Location.UNKNOWN), NONE)],
                               LambdaTypes.TUPLE)],
          []),
         NONE)

    val clamp_word_8 = clamp_word "0wxff"
    val clamp_word_16 = clamp_word "0wxffff"

    fun overloaded_word_op (clamp_word, result_type) opcode () =
      let
        val arg = LambdaTypes.new_LVar ()
        val tmp = LambdaTypes.new_LVar ()
      in
        LambdaTypes.FN
          (([arg],[]),
	   LambdaTypes.LET
	     ((tmp,
	       NONE,
               LambdaTypes.APP
                 (LambdaTypes.BUILTIN opcode,
	          ([LambdaTypes.VAR arg],[]),
		  NONE)),
	      clamp_word (tmp)),
           LambdaTypes.BODY,
	   "<Built in fixed size word operation>",
	   result_type,
	   RuntimeEnv.INTERNAL_FUNCTION)
      end
  in
    val word8_op =
      overloaded_word_op (clamp_word_8, mk_binop_type Types.word8_type)
    val word16_op =
      overloaded_word_op (clamp_word_16, mk_binop_type Types.word16_type)
  end

  val derived_overload_table =
    [("_int8+", int8_op Pervasives.UNSAFEINTPLUS),
     ("_int8-", int8_op Pervasives.UNSAFEINTMINUS),
     ("_int8*", int8_op Pervasives.INTSTAR),
     ("_int8div", int8_op Pervasives.INTDIV),
     ("_int8mod", int8_op Pervasives.INTMOD),
     ("_int8~", int8_op Pervasives.INTUMINUS),
     ("_int8abs", int8_op Pervasives.INTABS),
     ("_int8<", fn () => LambdaTypes.BUILTIN Pervasives.INTLESS),
     ("_int8<=", fn () => LambdaTypes.BUILTIN Pervasives.INTLESSEQ),
     ("_int8>", fn () => LambdaTypes.BUILTIN Pervasives.INTGREATER),
     ("_int8>=", fn () => LambdaTypes.BUILTIN Pervasives.INTGREATEREQ),
     ("_word8+", word8_op Pervasives.WORDPLUS),
     ("_word8-", word8_op Pervasives.WORDMINUS),
     ("_word8*", word8_op Pervasives.WORDSTAR),
     ("_word8div", word8_op Pervasives.WORDDIV),
     ("_word8mod", word8_op Pervasives.WORDMOD),
     ("_word8<", fn () => LambdaTypes.BUILTIN Pervasives.WORDLT),
     ("_word8<=", fn () => LambdaTypes.BUILTIN Pervasives.WORDLE),
     ("_word8>", fn () => LambdaTypes.BUILTIN Pervasives.WORDGT),
     ("_word8>=", fn () => LambdaTypes.BUILTIN Pervasives.WORDGE),
     ("_int16+", int16_op Pervasives.UNSAFEINTPLUS),
     ("_int16-", int16_op Pervasives.UNSAFEINTMINUS),
     ("_int16*", int16_op Pervasives.INTSTAR),
     ("_int16div", int16_op Pervasives.INTDIV),
     ("_int16mod", int16_op Pervasives.INTMOD),
     ("_int16~", int16_op Pervasives.INTUMINUS),
     ("_int16abs", int16_op Pervasives.INTABS),
     ("_int16<", fn () => LambdaTypes.BUILTIN Pervasives.INTLESS),
     ("_int16<=", fn () => LambdaTypes.BUILTIN Pervasives.INTLESSEQ),
     ("_int16>", fn () => LambdaTypes.BUILTIN Pervasives.INTGREATER),
     ("_int16>=", fn () => LambdaTypes.BUILTIN Pervasives.INTGREATEREQ),
     ("_word16+", word16_op Pervasives.WORDPLUS),
     ("_word16-", word16_op Pervasives.WORDMINUS),
     ("_word16*", word16_op Pervasives.WORDSTAR),
     ("_word16div", word16_op Pervasives.WORDDIV),
     ("_word16mod", word16_op Pervasives.WORDMOD),
     ("_word16<", fn () => LambdaTypes.BUILTIN Pervasives.WORDLT),
     ("_word16<=", fn () => LambdaTypes.BUILTIN Pervasives.WORDLE),
     ("_word16>", fn () => LambdaTypes.BUILTIN Pervasives.WORDGT),
     ("_word16>=", fn () => LambdaTypes.BUILTIN Pervasives.WORDGE)]

  fun lookup_derived_overload s =
    SOME (Lists.assoc (s, derived_overload_table))
    handle
      Lists.Assoc => NONE

  fun domain_type_name(Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
    (case NewMap.range record_map of
       h :: _ => (true, Types.the_type h)
     | _ => (false, Types.int_type))
    | domain_type_name _ = (false, Types.int_type)

  fun domain_tyname(Datatypes.CONSTYPE(_, tyname)) = (true, tyname)
    | domain_tyname _ = (false, Types.int_tyname)

  fun check_no_vcc_for_eq(h as Datatypes.CONSTYPE _) =
    TypeUtils.has_null_cons h andalso not(TypeUtils.has_value_cons h)
    | check_no_vcc_for_eq _ = (*Crash.impossible"poly_eq type wrong"*)false

  fun check_one_vcc_and_no_nullaries(h as Datatypes.CONSTYPE _) =
    not(TypeUtils.has_null_cons h) andalso TypeUtils.get_no_vcc_cons h = 1
    | check_one_vcc_and_no_nullaries _ = false

  (* Get the tag part of the constructed value resulting from lexp *)

  fun GetConTag lexp =
    LambdaTypes.SELECT({index = 0, size = 2,selecttype=LambdaTypes.CONSTRUCTOR}, lexp)

  (* Get the value part of the constructed value resulting from lexp *)

  fun GetConVal lexp =
    LambdaTypes.SELECT ({index = 1, size = 2,selecttype=LambdaTypes.CONSTRUCTOR}, lexp)

  fun get_lamb_env(strid as Ident.STRID sy, env) =
    let
      val (env', comp, _) = Environ.lookup_strid(strid, env)
    in
      case comp of
	EnvironTypes.LAMB(lvar,_) => (env', LambdaTypes.VAR lvar)
      | EnvironTypes.PRIM prim => (env', LambdaTypes.BUILTIN prim)
      | EnvironTypes.EXTERNAL =>
	  (env',
	   LambdaTypes.APP
	     (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	      ([LambdaTypes.SCON (Ident.STRING (Symbol.symbol_name sy), NONE)],[]),
	      NONE))
      | EnvironTypes.FIELD{index, size} =>
(*
	  Crash.impossible("get_lamb_env gives field looking up " ^ Symbol.symbol_name sy ^ " at " ^ Int.toString index ^ "/" ^ Int.toString size ^ " in env :-\n" ^ EnvironPrint.stringenv Options.default_print_options env ^ "\n")
*)
	  Crash.impossible "get_lamb_env gives field"
    end

  fun get_lamb_env'(strid as Ident.STRID sy, env) =
    let
      (* moduler_generated indicates if the structure was compiled with module debugging on *)
      val (env', comp, moduler_generated) = Environ.lookup_strid(strid, env)
    in
      case comp of
	EnvironTypes.LAMB (lvar,longstrid) => (env', LambdaTypes.VAR lvar, longstrid, moduler_generated)
      | EnvironTypes.PRIM prim => (env', LambdaTypes.BUILTIN prim, EnvironTypes.NOSPEC, moduler_generated)
      | EnvironTypes.EXTERNAL =>
	  (env',
	   LambdaTypes.APP
	     (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	      ([LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],[]),
	      NONE),
	   EnvironTypes.NOSPEC, moduler_generated)
      | EnvironTypes.FIELD _ =>
	  Crash.impossible "get_lamb_env gives field"
    end

  fun make_struct_select {index,size} =
    {index = index,size = size, selecttype = LambdaTypes.STRUCTURE}

  fun get_field_env(strid, (env, lambda)) =
    let
      val (env', field) =
        case Environ.lookup_strid(strid, env) of
          (env'', EnvironTypes.FIELD field, _) => (env'', field)
        | _ => Crash.impossible "get_field_env fails to get field"
    in
      (env', LambdaTypes.SELECT(make_struct_select field, lambda))
    end

  fun get_field_env'(strid, (env, lambda, longstrid, moduler_generated)) =
    let
      val (env', field, _) =
        case Environ.lookup_strid(strid, env) of
          (env'', EnvironTypes.FIELD field, moduler_generated) => (env'', field, moduler_generated)
        | _ => Crash.impossible "get_field_env fails to get field"
    in
      (env', LambdaTypes.SELECT(make_struct_select field, lambda), longstrid, moduler_generated)
    end

  fun cg_longvalid (longvalid, env) =
    case longvalid of
      Ident.LONGVALID(Ident.NOPATH, valid) =>
        ((case Environ.lookup_valid(valid, env) of
           EnvironTypes.LAMB(lvar,_) => LambdaTypes.VAR lvar
         | EnvironTypes.PRIM prim =>
             LambdaTypes.BUILTIN prim
         | EnvironTypes.EXTERNAL =>
             LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_VAR,
                             ([LambdaTypes.SCON(Ident.STRING(valid_name valid), NONE)],[]),
                             NONE)
         | EnvironTypes.FIELD _ => Crash.impossible "cg_longvalid gives field")
	handle NewMap.Undefined =>
	  Crash.impossible
	    (IdentPrint.debug_printValId valid ^ " undefined in cg_longvalid"))
    | Ident.LONGVALID(path, valid) =>
        let
          val (env', lambda) =
            Ident.followPath'(get_lamb_env, get_field_env) (path, env)
        in
          (case Environ.lookup_valid(valid, env') of
            EnvironTypes.FIELD field => LambdaTypes.SELECT(make_struct_select field, lambda)
          | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
          | EnvironTypes.LAMB _ =>
              Crash.impossible "cg_longvalid gets lambda var at end of longvalid"
          | EnvironTypes.EXTERNAL =>
              Crash.impossible "cg_longvalid gets external at end of longvalid")
	  handle NewMap.Undefined =>
	    Crash.impossible
	      (IdentPrint.debug_printValId valid
	       ^ " undefined in cg_longvalid")
        end

  fun cg_longexid (longvalid, env) =
    case longvalid of
      Ident.LONGVALID(Ident.NOPATH, valid) =>
        (case Environ.lookup_valid(valid, env) of
           EnvironTypes.LAMB (lvar,longstrid) => (LambdaTypes.VAR lvar,longstrid)
         | EnvironTypes.PRIM prim =>
             (LambdaTypes.BUILTIN prim,
              EnvironTypes.NOSPEC)
         | EnvironTypes.EXTERNAL =>
            (LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_VAR,
                             ([LambdaTypes.SCON(Ident.STRING(valid_name valid), NONE)],[]),
                             NONE),
             EnvironTypes.NOSPEC)
         | EnvironTypes.FIELD _ => Crash.impossible "cg_longexid gives field")
    | Ident.LONGVALID(path, valid) =>
        let
          val (env', lambda, longstrid, _) =
            Ident.followPath'(get_lamb_env', get_field_env') (path, env)
        in
         (case Environ.lookup_valid(valid, env') of
            EnvironTypes.FIELD field => LambdaTypes.SELECT(make_struct_select field, lambda)
          | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
          | EnvironTypes.LAMB _ =>
              Crash.impossible "cg_longexid gets lambda var at end of longvalid"
          | EnvironTypes.EXTERNAL =>
              Crash.impossible "cg_longexid gets external at end of longvalid",
          longstrid)
        end

  fun cg_longstrid (longstrid, environment) =
    case longstrid of
      Ident.LONGSTRID(Ident.NOPATH, strid as Ident.STRID sy) =>
        (case Environ.lookup_strid(strid, environment) of
           (env, EnvironTypes.LAMB (lvar,longstrid), moduler_generated) =>
             (env, LambdaTypes.VAR lvar, longstrid, moduler_generated)
         | (env, EnvironTypes.PRIM prim, moduler_generated) =>
             (env, LambdaTypes.BUILTIN prim, EnvironTypes.NOSPEC, moduler_generated)
         | (env, EnvironTypes.EXTERNAL, moduler_generated) =>
             (env,
              LambdaTypes.APP
	        (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	         ([LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],[]),
                 NONE),
              EnvironTypes.NOSPEC,
              moduler_generated)
         | (_, EnvironTypes.FIELD _, _) =>
             Crash.impossible "cg_longstrid gives field")
    | Ident.LONGSTRID(path, strid) =>
        let
          val (env, lambda, longstrid, moduler_generated) =
            Ident.followPath'(get_lamb_env', get_field_env') (path, environment)
        in
          case Environ.lookup_strid(strid, env) of
            (env', EnvironTypes.FIELD field, _) =>
              (env', LambdaTypes.SELECT(make_struct_select field, lambda), longstrid, moduler_generated)
          | (env', EnvironTypes.PRIM prim, _) =>
              (env', LambdaTypes.BUILTIN prim, longstrid, moduler_generated)
          | (_, EnvironTypes.LAMB _, _) =>
              Crash.impossible "cg_longstrid gets lambda var at end of longstrid"
          | (_, EnvironTypes.EXTERNAL, _) =>
              Crash.impossible "cg_longstrid gets external at end of longstrid"
        end

  val eq_prim = LambdaTypes.BUILTIN Pervasives.EQ

  fun is_eq_prim(LambdaTypes.BUILTIN Pervasives.EQ) = true
    | is_eq_prim _ = false

  fun isnt_eq_prim(LambdaTypes.BUILTIN Pervasives.EQ) = false
    | isnt_eq_prim _ = true

  val neq_prim = LambdaTypes.BUILTIN Pervasives.NE

  fun isnt_neq_prim(LambdaTypes.BUILTIN Pervasives.NE) = false
    | isnt_neq_prim _ = true

  fun let_lambdas_in_exp (bindings, lambda_exp) =
    Lists.reducer LambdaTypes.do_binding (bindings,lambda_exp)

  fun unordered_let_lambdas_in_exp (bindings, lambda_exp) =
    Lists.reducel (fn (exp, bind) => LambdaTypes.do_binding(bind, exp))
    (lambda_exp, bindings)

  (* Redundancy information *)

  fun print_redundancy_info (print_options,[], _) = Crash.impossible "print_redundancy_info:lambda"
    | print_redundancy_info (print_options,clauses, pat_exp_list) =
      let
        (* print list of patterns with indication next to them of redundant ones *)
        fun dynamic_member (_,nil) = false
          | dynamic_member (n,(n',_)::_) = n=n'
        fun static_member (_,nil) = false
          | static_member (n,(n',Match.TRUE)::_) = n=n'
          | static_member _ = false
        fun new_clauses nil = Crash.impossible "new_clauses:print_redundancy_info:lambda"
          | new_clauses (_::clauses) = clauses
        fun fetch_clause  nil = Crash.impossible "fetch_clause:print_redundancy_info:lambda"
          | fetch_clause (clause::_) = clause
        fun to_string(n, [], _, ((b,static_str),(b',dynamic_str))) =
            ((b,rev static_str), (b',rev dynamic_str))
          | to_string(n, (p,_,_)::l,clauses,((static,static_str),(dynamic,dynamic_str))) =
            let
              val pat_str = AbsynPrint.unparsePat true print_options p ^ " => ..."
            in
              if static_member (n, clauses) then
                to_string(n+1, l, new_clauses clauses,
                          ((true,"\n  " ^ pat_str::static_str),
                           (dynamic,(fetch_clause clauses,"\n      " ^ pat_str)::dynamic_str)))
              else
                if dynamic_member (n, clauses) then
                  to_string(n+1, l, new_clauses clauses,
                            ((static,(*("\n      " ^ pat_str)::*)static_str),
                             (true,(fetch_clause clauses,"\n      " ^ pat_str)::dynamic_str)))
                else
                  to_string(n+1, l, clauses,
                            ((static,(*("\n      " ^ pat_str)::*)static_str),
                             (dynamic,((n,Match.FALSE),"\n      " ^ pat_str)::dynamic_str)))
            end
      in
        to_string(1, pat_exp_list, clauses, ((false,[]), (false,[])))
      end

  fun compare_sig_env generate_moduler (Datatypes.COPYSTR (_, str), env) =
    compare_sig_env generate_moduler (str, env)
    | compare_sig_env generate_moduler (Datatypes.STR (_, _, Datatypes.ENV
                                                       (Datatypes.SE sm,
                                                        Datatypes.TE tm,
                                                        Datatypes.VE (_, vm))),
                                        EnvironTypes.ENV(v_map, s_map)) =
    NewMap.size vm + (if generate_moduler then NewMap.size tm else 0) = NewMap.size v_map andalso
    NewMap.size sm = NewMap.size s_map andalso
    (* recurse down the structure map *)
    Lists.forall
    (compare_sig_env generate_moduler)
    (Lists.zip(NewMap.range_ordered sm,
               map #1 (NewMap.range_ordered s_map)))

  fun complete_struct_with_sig (Datatypes.COPYSTR (_, str), env, lv, coerce, generate_moduler) =
    complete_struct_with_sig (str, env, lv, coerce, generate_moduler)
    | complete_struct_with_sig
      (interface as Datatypes.STR (_, _,
                                   Datatypes.ENV (Datatypes.SE sm,
                                                  Datatypes.TE tm,
                                                  Datatypes.VE (_, vm))),
       env as EnvironTypes.ENV(v_map, s_map),
       lambda_var,
       coerce,
       generate_moduler) =

   (if not coerce andalso compare_sig_env generate_moduler (interface, env)
      then (env, LambdaTypes.VAR lambda_var)
    else
      let
        (* This function matches a structure against a signature.  It produces a
         new structure consisting of lambda variables bound to selections of
	 the old structure.  It returns a lambda environment and a lambda
	 expression.*)

        val v_list = NewMap.to_list_ordered v_map
        val s_list = NewMap.to_list_ordered s_map
        val ordered_int_map = NewMap.to_list_ordered sm
        val vm =
          if generate_moduler then
            (* Augment the value environment with type constructor values *)
            let
              val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,NONE)
            in
              NewMap.fold
              (fn (map,Ident.TYCON sym,_) =>
               NewMap.define (map,Ident.TYCON' sym, dummy_scheme))
              (vm,tm)
            end
          else vm

        (* Throw out unwanted elements and assign new field numbers *)
        (* v_list is the structure being filtered *)
        (* vm is the map corresponding to the constraining signature *)
        val (v_f_list,s_f_list,_) =
          let
            fun val_filter_map (v_list, [], done) = rev done
              | val_filter_map ([], z :: _, done) =
                Crash.impossible(IdentPrint.debug_printValId z ^ " missing in val_filter_map")
              | val_filter_map((x, y)::xs, second as (z :: zs), done) =
                if Ident.valid_eq (x, z)
                  then val_filter_map(xs, zs, (x, y) :: done)
                else val_filter_map(xs, second, done)

            fun str_filter_map (a_list, [], done) = rev done
              | str_filter_map ([], x :: _, done) =
                Crash.impossible(IdentPrint.printStrId x ^ " missing in str_filter_map")
              | str_filter_map((x, y)::xs, second as (z :: zs), done) =
                if Ident.strid_eq (x, z)
                  then str_filter_map(xs, zs, (x, y) :: done)
                else str_filter_map(xs, second, done)
            val domain = NewMap.domain_ordered vm
          (* For debugging *)
          (*
            fun print_list l =
              (Lists.iterate
               (fn id => print (IdentPrint.debug_printValId id ^ " "))
               l;
               print "\n")
            val _ = (print "Domain:\n";
                     print_list domain;
                     print "V_list:\n";
                     print_list (map #1 v_list))
              *)
          in
            Environ.number_envs
            (val_filter_map (v_list, domain,[]),
             str_filter_map (s_list, map #1 ordered_int_map,[]),
             [])
          end

        (* Now add lvs to be bound to the component in the old structure. *)
        val v_f_l_list =
          map (fn x => (x, new_LVar())) v_f_list
        val s_f_l_list =
          map (fn x => (x, new_LVar(), new_LVar()))
          s_f_list

        (* First lv is to be the constraint result *)
        (* Second lv is to be bound to the old structure *)

        (* make a list of the lvs in the new structure *)
        val the_structure_list =
          map (fn (_, x) => LambdaTypes.VAR x) v_f_l_list @@
          map (fn (_, x, _) => LambdaTypes.VAR x) s_f_l_list

        (* Recursively restrict all remaining substructures *)
        val env_le_list =
          map complete_struct_with_sig
          (map (fn ((((_, (env, _, _)), _), _, l2), (_, inte)) =>
                (inte, env, l2, coerce, generate_moduler))
           (Lists.zip(s_f_l_list, ordered_int_map)))

        (* Generate a lambda environment that binds the remaining identifiers
	 to the new field offsets. *)
        fun keep_prims (x as EnvironTypes.PRIM _) _ = x
          | keep_prims _ x = x

        val env =
          Lists.reducel
	  (fn (env, ((v, x), f_new)) =>
           Environ.add_valid_env(env, (v, keep_prims x f_new)))
	  (Lists.reducel
           (fn (env, (((strid, _), field), (env', _))) =>
            Environ.add_strid_env(env, (strid, (env', field, generate_moduler))))
           (Environ.empty_env, (Lists.zip(s_f_list, env_le_list))),
	   v_f_list)

        fun coerce (valid as Ident.EXCON _, lexp) =
          (* If this valid is a constructor, and the corresponding valid in
	   vm is not, then we must build a value from the exception. *)
          let
            val res = NewMap.tryApply'Eq (vm, valid)
	    val (need_coerce, res') =
	      case res of
		SOME ty => (false, res)
	      | _ => (true, NewMap.tryApply' (vm, valid))
          in
            if need_coerce then
              let
                val _ = Diagnostic.output 2 (fn _ => ["coercing ",IdentPrint.debug_printValId valid])
                val is_vcc =
                  case res' of
                    SOME ty =>
                      TypeUtils.is_vcc (TypeUtils.type_from_scheme ty)
                  | _ => Crash.impossible "coerce:_lambda"
              in
                if is_vcc then
                  let
                    val lv = new_LVar()
                  in
                    LambdaTypes.FN(([lv],[]),
                                   LambdaTypes.STRUCT([lexp, LambdaTypes.VAR lv],LambdaTypes.CONSTRUCTOR),
                                   LambdaTypes.BODY,
                                   "Builtin code to construct an exception",
                                   LambdaTypes.null_type_annotation,
                                   RuntimeEnv.INTERNAL_FUNCTION)
                  end
                else LambdaTypes.STRUCT([lexp, unit_exp],LambdaTypes.CONSTRUCTOR)
              end
            else lexp
          end
          | coerce (_, lexp) = lexp

        (* Now bind the new lambda variables to the corresponding old
	 field offsets. *)
        val l1 =
          map
          (fn (((valid, EnvironTypes.FIELD f_old), _), lv) =>
           LambdaTypes.LETB
           (lv,NONE,
            coerce (valid, LambdaTypes.SELECT
                    (make_struct_select f_old, LambdaTypes.VAR lambda_var)))
            | (((valid, EnvironTypes.PRIM prim), _), lv) =>
                LambdaTypes.LETB(lv,NONE,coerce (valid,LambdaTypes.BUILTIN prim))
            |  (((_, EnvironTypes.LAMB _), _), _) =>
                 Crash.impossible "c_s_w_i(1)"
            |  (((_, EnvironTypes.EXTERNAL), _), _) =>
                 Crash.impossible "c_s_w_i(2)")
          v_f_l_list

        val l2 =
          map
          (fn ((((_, (env, EnvironTypes.FIELD f_old, _)), _), lv, lv'), le) =>
           LambdaTypes.LETB
           (lv,NONE,
            LambdaTypes.do_binding
            (LambdaTypes.LETB
             (lv',NONE,
              LambdaTypes.SELECT(make_struct_select f_old, LambdaTypes.VAR lambda_var)),
             le))
            | ((((_, (_, EnvironTypes.LAMB _, _)), _), _, _), _) =>
	        Crash.impossible "c_s_w_i (3) LAMB"
            |  ((((_, (_, EnvironTypes.PRIM _, _)), _), _, _), _) =>
                 Crash.impossible "c_s_w_i (4) PRIM"
            |  ((((_, (_, EnvironTypes.EXTERNAL, _)), _), _, _), _) =>
                 Crash.impossible "c_s_w_i (5) EXTERNAL")
          (Lists.zip(s_f_l_list, map #2 env_le_list))

        val lambdas = let_lambdas_in_exp(l1 @@ l2,
                                         LambdaTypes.STRUCT (the_structure_list,LambdaTypes.STRUCTURE))
      in
        (* Return the environment (binding ids to fields in the new structure) *)
        (* and the lambda expression representing the structure itself. *)
        (env, lambdas)
      end) (* of complete_struct_with_sig *)

  fun complete_struct_from_topenv(topenv as EnvironTypes.TOP_ENV(
    EnvironTypes.ENV(mv, ms), EnvironTypes.FUN_ENV m), lv_le_list) =
  let
    val valids = NewMap.to_list_ordered mv
    val strids = NewMap.to_list_ordered ms
    val funids = NewMap.to_list_ordered m
    fun extract_op (EnvironTypes.LAMB (x,_)) = LambdaTypes.VAR x
      | extract_op (EnvironTypes.PRIM x) = LambdaTypes.BUILTIN x
      | extract_op (EnvironTypes.FIELD _) =
	Crash.impossible "extract_op problem (1)"
      | extract_op EnvironTypes.EXTERNAL =
	Crash.impossible "extract_op problem (2)"
  in
    (Environ.assign_fields topenv,
      let_lambdas_in_exp(lv_le_list,
      LambdaTypes.STRUCT((map (fn (_, x) => extract_op x) valids) @@
                         (map (fn (_, (_, x, _)) => extract_op x) strids) @@
			 (map (fn (_,(x, (* _, *) _, _)) => extract_op x) funids),
                         LambdaTypes.STRUCTURE)))
  end

  fun make_top_env env = EnvironTypes.TOP_ENV(env, Environ.empty_fun_env)

  fun complete_struct((env, lambda_exp: LambdaTypes.LambdaExp),
		      interface_opt,
		      coerce, generate_moduler) =
  let
    val EnvironTypes.TOP_ENV(new_env, new_fun_env) =
      Environ.assign_fields(make_top_env env)
    val result = (new_env, lambda_exp)
  in
    case interface_opt of
      NONE => result
    | SOME interface =>
        if not coerce andalso compare_sig_env generate_moduler (interface, new_env)
          then result
        else
	  let
	    val new_lv = new_LVar()
	    val (new_env', new_lambda') =
	      complete_struct_with_sig(interface, new_env, new_lv, coerce, generate_moduler)
	  in
	    (new_env',
	     LambdaTypes.do_binding(LambdaTypes.LETB(new_lv,NONE,
                                                     lambda_exp),
                                    new_lambda'))
	  end
  end

  fun interface_from_sigexp (Absyn.NEWsigexp(_, ref (SOME str))) = str
    | interface_from_sigexp (Absyn.OLDsigexp(_, ref (SOME str),_)) = str
    | interface_from_sigexp (Absyn.WHEREsigexp (sigexp,_)) = interface_from_sigexp sigexp
    | interface_from_sigexp _ = Crash.impossible "No interface structure for signature"

  (* Match utilities -- moved here from LambdaUtils *)

  type MatchEnv = (LambdaTypes.LVar * LambdaTypes.VarInfo ref option) IntNewMap.T

  val empty_match_env = IntNewMap.empty

  fun add_match_env(pair, me) = IntNewMap.define'(me, pair)
  fun lookup_match(mv, me) = IntNewMap.apply'(me, mv)

  (* These global refs will cause real trouble one of these days *)
  val functor_refs_ct : int ref = ref 0
  val functor_refs : (EnvironTypes.Foo ref * Datatypes.Structure) list ref = ref []

  fun trans_top_dec
    error_info
    (options as Options.OPTIONS
       {print_options,
        (* generate_debug_info not used here !!! *)
        compiler_options = Options.COMPILEROPTIONS
                           {generate_debug_info,
                            debug_variables,
                            generate_moduler, ...},
	compat_options = Types.Options.COMPATOPTIONS {old_definition,...},
	...},
     topdec,
     top_env as EnvironTypes.TOP_ENV(env, _),
     top_denv,
     initial_debugger_env,
     basis,batch_compiler) =
    let
      val use_value_polymorphism = not old_definition
      val generate_moduler = do_fancy_stuff andalso generate_moduler

      (* Candidates for redundant exception patterns, and dynamic redundancy code generator *)
      val redundant_exceptions_ref : (LambdaTypes.LVar * string) list ref = ref []
      val dynamic_redundancy_report_ref : (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) ref = ref(fn exp => exp)

      (* Any of the complex optimization steps? *)
      val variable_debug = debug_variables orelse generate_moduler

      val null_runtimeinfo = RuntimeEnv.RUNTIMEINFO (NONE,nil)

      fun dummy_instance () = (ref Datatypes.NULLTYPE, ref null_runtimeinfo)

      fun mklongvalid valid = Ident.LONGVALID (Ident.NOPATH,valid)

      fun new_tyvar_slot () = ref (RuntimeEnv.OFFSET1 0)

      (* BEGIN{MODULES DEBUGGER} *)

      fun do_moduler_debug message =
        if generate_moduler_debug then
          print ("  # " ^ message() ^ "\n")
        else
          ()

      (** lookup functions for polymorphic function determining;
          look for longvalid in the debugger environment
       **)

      fun lookup f =
        let
          fun aux (Ident.NOPATH,result) = f result
            | aux (Ident.PATH(sym,path), EnvironTypes.DENVEXP(EnvironTypes.DENV(_,strmap))) =
              aux (path, NewMap.apply strmap (Ident.STRID sym)
                   handle NewMap.Undefined =>
                     (do_moduler_debug (fn () =>"UNDEFINED 14:" ^ Symbol.symbol_name sym);
                      raise NewMap.Undefined))
            | aux (Ident.PATH(sym,path),
                   EnvironTypes.LAMBDASTREXP(selects,lv,
                                             Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE stridmap,
                                                                             Datatypes.TE tyconmap,
                                                                             Datatypes.VE(_,validmap))))) =
              (* Build up a list of selections into a structure to get to the right value *)
              let
                val offset = NewMap.size tyconmap + NewMap.size validmap
              in
                aux(path,
                    EnvironTypes.LAMBDASTREXP({index= NewMap.rank' (stridmap,Ident.STRID sym) + offset,
                                               size= NewMap.size stridmap + offset}
                                              ::selects,lv,
                    NewMap.apply stridmap (Ident.STRID sym)))
                handle NewMap.Undefined =>
                  (do_moduler_debug(fn () =>"UNDEFINED 3:" ^ Symbol.symbol_name sym);
                   raise NewMap.Undefined)
              end
            | aux (path,EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) =
              aux (path, EnvironTypes.LAMBDASTREXP(selects,lv,str))
            (* Same as for LAMBDASTREXP *)
            | aux (Ident.PATH(sym,path),
                   EnvironTypes.LAMBDASTREXP'(selects,lv,
                                              Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE stridmap,
                                                                              Datatypes.TE tyconmap,
                                                                              Datatypes.VE(_,validmap))))) =
              let
                val offset = NewMap.size tyconmap + NewMap.size validmap
              in
                aux(path,
                    EnvironTypes.LAMBDASTREXP'({index=
                                                NewMap.rank' (stridmap,Ident.STRID sym) + offset,
                                                size= NewMap.size stridmap + offset}
                    ::selects,lv,
                    NewMap.apply stridmap (Ident.STRID sym)))
                handle NewMap.Undefined =>
                  (do_moduler_debug(fn () =>"UNDEFINED 3:" ^ Symbol.symbol_name sym);
                   raise NewMap.Undefined)
              end
            | aux(path,EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) =
              aux(path, EnvironTypes.LAMBDASTREXP'(selects,lv,str))
        in
          aux
        end

      (* Lookup a symbol in a debugger structure *)
      fun lookup_sym sym =
        let
          fun aux (EnvironTypes.DENVEXP(EnvironTypes.DENV(validmap,_))) =
            (NewMap.apply validmap (Ident.VAR sym)
             handle NewMap.Undefined =>
               (do_moduler_debug(fn () =>"UNDEFINED 5:" ^ Symbol.symbol_name sym);
                raise NewMap.Undefined))
            (* Generate a lambda expression spec for selecting the value *)
            | aux (EnvironTypes.LAMBDASTREXP(selects,lv,
                                             Datatypes.STR(_,_,
                                                           Datatypes.ENV(Datatypes.SE stridmap,
                                                                         Datatypes.TE tyconmap,
                                                                         Datatypes.VE(_,validmap))))) =
              let
                val offset = NewMap.size tyconmap
              in
                EnvironTypes.LAMBDAEXP({index= NewMap.rank' (validmap,Ident.VAR sym) + offset,
                                        size=NewMap.size validmap + NewMap.size stridmap + offset} ::
                selects,
                lv,NONE)
              end
            | aux (EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) =
              aux (EnvironTypes.LAMBDASTREXP(selects,lv,str))
            (* Same as for LAMBDASTREXP *)
            | aux (EnvironTypes.LAMBDASTREXP'(selects,lv,
                                              Datatypes.STR(_,_,
                                                            Datatypes.ENV(Datatypes.SE stridmap,
                                                                          Datatypes.TE tyconmap,
                                                                          Datatypes.VE(_,validmap))))) =
              let
                val offset = NewMap.size tyconmap
              in
                EnvironTypes.LAMBDAEXP'({index= NewMap.rank' (validmap,Ident.VAR sym) + offset,
                                         size=NewMap.size validmap + NewMap.size stridmap + offset}
                                        ::selects,lv,NONE)
              end
            | aux(EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) =
              aux(EnvironTypes.LAMBDASTREXP'(selects,lv,str))
        in
          aux
        end

      (* Look up a long valid in a debugger environment *)
      fun dlookup_longvalid (longvalid, denv) =
        case longvalid of
          (* Short ids are just looked up in the map *)
          Ident.LONGVALID(Ident.NOPATH, valid as Ident.VAR sym) =>
            (Environ.lookup_valid'(valid, denv)
             handle NewMap.Undefined =>
               (* This seems to happen for all builtin functions *)
               (do_moduler_debug(fn () =>"UNDEFINED 13:" ^ Symbol.symbol_name sym);
                raise NewMap.Undefined))
        | Ident.LONGVALID(Ident.PATH(sym,path), valid as Ident.VAR sym') =>
            (case denv of
               (* For long ids, call the functions above *)
               EnvironTypes.DENV(_,strmap) =>
                 lookup (lookup_sym sym')
                 (path, NewMap.apply strmap (Ident.STRID sym)
                  handle NewMap.Undefined =>
                    (do_moduler_debug
                     (fn () =>
                      (* This also seems to happen for builtin/pervasive functions *)
                      "UNDEFINED 4:" ^ Symbol.symbol_name sym ^ ".." ^ Symbol.symbol_name sym' ^ "..."
                      ^ NewMap.fold (fn (str,Ident.STRID sym,_) => str ^ "," ^ Symbol.symbol_name sym) ("",strmap));
                     raise NewMap.Undefined)))
        | _ => Crash.impossible "dlookup_longvalid:lambda"

      local
        val dummy_tf = ref(Datatypes.TYFUN(Datatypes.NULLTYPE,0))
        fun fetch_nulltyfun (Datatypes.METATYNAME{1=tf as ref(Datatypes.NULL_TYFUN _), ...}) = tf
          | fetch_nulltyfun (Datatypes.METATYNAME{1=ref(Datatypes.ETA_TYFUN m), ...}) =
            fetch_nulltyfun m
          | fetch_nulltyfun _ = Crash.impossible "fetch_nulltyfun:lambda"
      in
        fun fetch_ntf (Datatypes.TYSTR(tf,_)) =
            if Types.null_tyfunp tf then
              fetch_nulltyfun(Types.meta_tyname tf)
            else
              dummy_tf
      end

      (** lookup function for dynamic type function instantiations;
          lookup the debugger environment for appropriate debugger spill
       **)

     (* Try and find the tyfun in the debugger environment *)
      (* Returns an Environ.DebuggerExp *)

      fun dlookup_tycon (tyfun,denv) =
        let
          exception Lookup

          fun denv_lookup (EnvironTypes.DENV(id_map, str_map)) =
            let
              fun lookup_id map =
                let
                  fun aux nil = NONE
                    | aux ((_,lexp as EnvironTypes.LAMBDAEXP(_,_,SOME(tyfun')))::rest) =
                      if tyfun = tyfun'
                        then SOME lexp
                      else aux rest
                    | aux (_::rest) = aux rest
                in
                  aux (NewMap.to_list map)
                end
            in
              case lookup_id id_map of
                SOME lexp => lexp
              | _ =>
                  let
                    fun strexp_lookup (EnvironTypes.DENVEXP  denv) = denv_lookup denv
                      | strexp_lookup (EnvironTypes.LAMBDASTREXP (selects,lv,str)) =
                        EnvironTypes.LAMBDAEXP(rev (str_lookup str) @@ selects,lv,NONE)
                      | strexp_lookup (EnvironTypes.LAMBDASTREXP'(selects,lv,str)) =
                        EnvironTypes.LAMBDAEXP' (rev (str_lookup str) @@ selects,lv,NONE)
                    fun aux nil = raise Lookup
                      | aux ((_,strexp)::rest) =
                        (strexp_lookup strexp
                         handle Lookup => aux rest)
                  in
                    aux (NewMap.to_list str_map)
                  end
            end

          and str_lookup(Datatypes.COPYSTR(_,str)) = str_lookup str
            | str_lookup(Datatypes.STR(_,_,
                                    Datatypes.ENV(Datatypes.SE se_map,
                                                  Datatypes.TE te_map,
                                                  Datatypes.VE(_,ve_map)))) =
              let
                val size' = NewMap.size te_map + NewMap.size ve_map
                val size = NewMap.size se_map + size'

                (* see if the tyfun is in the te map *)
                fun find_tyfun nil _ = NONE
                  | find_tyfun ((_,tystr)::rest) n =
                    if tyfun = fetch_ntf tystr then SOME n
                    else find_tyfun rest (n+1)
              in
                case find_tyfun (NewMap.to_list_ordered te_map) 0 of
                  (* Return required select parameters *)
                  SOME n =>
                    [{index = n, size = size}]
                | _ =>
                    let
                      (* Else lookup in the structure environment *)
                      val se_list = NewMap.to_list_ordered se_map
                      fun find_str (nil, _) = raise Lookup
                        | find_str ((_,str)::rest, n) =
                          {index = n + size', size = size} :: str_lookup str
                          handle Lookup => find_str (rest,n+1)
                    in
                      find_str (se_list, 0)
                    end
              end
        in
          denv_lookup denv
        end

      (** lookup a debugger structure **)
      fun cg_longstrid' (longstrid, denv) =
        case longstrid of
          Ident.LONGSTRID(Ident.NOPATH, strid as Ident.STRID sym) =>
            (Environ.lookup_strid'(strid, denv)
             handle NewMap.Undefined =>
               (do_moduler_debug(fn () =>"UNDEFINED 12:" ^ Symbol.symbol_name sym);
                raise NewMap.Undefined))
        | Ident.LONGSTRID(Ident.PATH(sym,path), strid as Ident.STRID sy) =>
            let
              fun insert_strid Ident.NOPATH = Ident.PATH (sy,Ident.NOPATH)
                | insert_strid (Ident.PATH (sym,path)) = Ident.PATH (sym,insert_strid path)
            in
              case denv of
                EnvironTypes.DENV(_,strmap) =>
                  lookup (fn result => result) (insert_strid path, NewMap.apply strmap (Ident.STRID sym))
                  handle NewMap.Undefined =>
                    (do_moduler_debug(fn () =>"UNDEFINED 11:" ^ Symbol.symbol_name sym);
                     raise NewMap.Undefined)
            end



      (** open a debugger environment **)
      fun open_debugger_env (debugger_strexp, denv) =
        let
          fun open_lambdastrexp LAMBDAEXP LAMBDASTREXP
            (selects,lv,
             Datatypes.STR(_,_,
                           Datatypes.ENV(Datatypes.SE stridmap,
                                         Datatypes.TE tyconmap,
                                         Datatypes.VE(_,validmap)))) =
            let
              val size_validmap = NewMap.size validmap
              val size_tyconmap = NewMap.size tyconmap
              val size = NewMap.size stridmap + size_validmap + size_tyconmap
            in
              NewMap.fold
              (fn (env, tc' as Ident.TYCON tc, tystr) =>
               Environ.add_valid_denv
               (env, (Ident.TYCON' tc, LAMBDAEXP({index=NewMap.rank' (tyconmap,tc'),
                                                   size=size}
                                                  ::selects,lv,
               SOME(fetch_ntf tystr)))))
              (NewMap.fold
               (fn (env, s, str) =>
                Environ.add_strid_denv
                 (env, (s, LAMBDASTREXP({index=NewMap.rank' (stridmap,s) + size_validmap + size_tyconmap,
                                         size=size}
                                        ::selects,lv,
                                        str))))
               ((NewMap.fold
                 (fn (env, v, _) =>
                  Environ.add_valid_denv
                  (env, (v, LAMBDAEXP({index=NewMap.rank' (validmap,v) + size_tyconmap,
                                       size=size}
                                      ::selects,lv,NONE))))
                 (denv, validmap)), stridmap), tyconmap)
            end
            | open_lambdastrexp _ LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str)) =
              open_debugger_env (LAMBDASTREXP(selects,lv,str), denv)
        in
          case debugger_strexp of
            EnvironTypes.DENVEXP(denv') => Environ.augment_denv(denv, denv')
          | EnvironTypes.LAMBDASTREXP args =>
              open_lambdastrexp EnvironTypes.LAMBDAEXP EnvironTypes.LAMBDASTREXP args
          | EnvironTypes.LAMBDASTREXP' args =>
              open_lambdastrexp EnvironTypes.LAMBDAEXP' EnvironTypes.LAMBDASTREXP' args
        end

      val dlookup_longvalid =
        if generate_moduler then
          fn denv => dlookup_longvalid denv
          handle NewMap.Undefined => EnvironTypes.NULLEXP
        else
          fn _ => EnvironTypes.NULLEXP

      val empty_denv = Environ.empty_denv
      val empty_dstrexp = EnvironTypes.DENVEXP empty_denv

      val cg_longstrid' =
        if generate_moduler then
          fn denv =>
          cg_longstrid' denv
          handle NewMap.Undefined => empty_dstrexp
        else
          fn _ => empty_dstrexp

      val add_valid_denv =
        if generate_moduler then
          fn arg => Environ.add_valid_denv arg
        else
          fn _ => empty_denv

      val add_strid_denv =
        if generate_moduler then
          fn arg => Environ.add_strid_denv arg
        else
          fn _ => empty_denv

      val augment_denv =
        if generate_moduler then
          fn arg => Environ.augment_denv arg
        else
          fn _ => empty_denv

      val new_dLVar =
        if generate_moduler then fn _ => new_LVar()
        else
          fn lvar => lvar

      (** accumulation of functor application refs from subrequires **)
      fun sub_functor_refs (EnvironTypes.TOP_ENV (env',fun_env)) =
        let
          val env_list =
            case env of (* presumably the parameter to trans_top_dec *)
              EnvironTypes.ENV (env,_) => NewMap.to_list env

          fun sub_functor_refs ([], env) = EnvironTypes.TOP_ENV (env,fun_env)
            | sub_functor_refs ((entry as (Ident.VAR sym,comp))::rest, env) =
              let
                val name_string = Symbol.symbol_name sym
                val new_env =
                  if is_functor_app name_string
                    then
                      case comp of
                        EnvironTypes.LAMB(lvar,_) =>
                          Environ.add_valid_env (env,entry)
                      | _ => env
                  else
                    env
              in
                sub_functor_refs (rest,new_env)
              end
            | sub_functor_refs (_::rest, env) = sub_functor_refs (rest, env)
        in
          sub_functor_refs (env_list,env')
        end

      (* Definition of overloading function *)
      val (overload_exp,overload_binding,make_env) =
        if generate_moduler then
          (cg_longvalid (mklongvalid (Ident.VAR (Symbol.find_symbol overload_function_string)),env),[],
           fn env => env)
          handle NewMap.Undefined =>
            (do_moduler_debug(fn () =>"WARNING : redefining overload function");
             let
               val lvar = new_LVar()
               val lv = new_LVar()
               val args = new_LVar()
               val new_cg = new_LVar()
               val dexp' = new_LVar()
               val instance_var = new_LVar()
               val lexp =
                 (* This is whatever the overload function is meant to do *)
                 LambdaTypes.FN
                 (([args],[]),
                  LambdaTypes.LET((new_cg,NONE,
                                   LambdaTypes.SELECT({index=0,size=3,selecttype=LambdaTypes.TUPLE},
                                                      LambdaTypes.VAR args)),
                   LambdaTypes.LET((dexp',NONE,
                                    LambdaTypes.SELECT({index=1,size=3,selecttype=LambdaTypes.TUPLE},
                                                       LambdaTypes.VAR args)),
                     LambdaTypes.LET((instance_var,NONE,
                                      LambdaTypes.SELECT({index=2,size=3,selecttype=LambdaTypes.TUPLE},
                                                         LambdaTypes.VAR args)),
                       LambdaTypes.LET((lvar,NONE,LambdaTypes.VAR dexp'),
                          LambdaTypes.SWITCH
			    (LambdaTypes.VAR lvar,
                             SOME {num_vccs=1,num_imms=1},
                             [(LambdaTypes.IMM_TAG ("ABSENT",0),
                               LambdaTypes.VAR new_cg),
                              (LambdaTypes.VCC_TAG("PRESENT",1),
                               LambdaTypes.APP
                                 (LambdaTypes.VAR new_cg,
                                  ([let
                                     val lexp = LambdaTypes.SELECT
						  ({index=1,
                                                    size=2,
                                                    selecttype=LambdaTypes.CONSTRUCTOR},
                                                   LambdaTypes.VAR lvar)
                                   in
                                     (* What is this doing? *)
                                     LambdaTypes.SWITCH
				       (LambdaTypes.VAR instance_var,
                                        NONE,
                                        [(LambdaTypes.SCON_TAG
					    (Ident.INT ("~1", Location.UNKNOWN),
					     NONE),
                                          LambdaTypes.STRUCT
					    ([LambdaTypes.INT 0, lexp],
                                          LambdaTypes.CONSTRUCTOR))],
                                        SOME
					  (LambdaTypes.STRUCT
					     ([LambdaTypes.INT 1,
                                               LambdaTypes.STRUCT
						 ([lexp,
                                                   LambdaTypes.VAR instance_var],
                                               LambdaTypes.TUPLE)],
                                               LambdaTypes.CONSTRUCTOR)))
                                    end],[]),
                                    NONE))],
				NONE))))),
                  LambdaTypes.BODY,
                  overload_function_string,Datatypes.NULLTYPE,
                  RuntimeEnv.INTERNAL_FUNCTION)
             in
               (LambdaTypes.VAR lv,
                [LambdaTypes.LETB(lv,NONE,lexp)],
                fn env =>
                Environ.add_valid_env(env,
                                      (Ident.VAR (Symbol.find_symbol overload_function_string),
                                       EnvironTypes.LAMB(lv, EnvironTypes.NOSPEC))))
             end)
        else (dummy_varexp,[],fn env => env)

      (** selects over a lambda expression **)
      fun wrap_selects (selects,lexp) =
        let
          fun aux [] = lexp
            | aux ({index,size}::rest) =
              LambdaTypes.SELECT({index = index,size = size, selecttype = LambdaTypes.TUPLE},
                                 aux rest)
        in
          aux selects
        end

      (** lambda expression for dynamic overloading determination **)
      fun dexp_to_lambda EnvironTypes.NULLEXP = LambdaTypes.INT 0
        | dexp_to_lambda (EnvironTypes.INT i) =
          LambdaTypes.STRUCT([LambdaTypes.INT 1,LambdaTypes.INT i],
                             LambdaTypes.CONSTRUCTOR)
        | dexp_to_lambda (EnvironTypes.LAMBDAEXP(selects,(lv,_),_)) =
          wrap_selects (selects,LambdaTypes.VAR lv)
        (* functor_lv is either an lvar or an int *)
        | dexp_to_lambda( EnvironTypes.LAMBDAEXP'(selects,functorlv,_)) =
          wrap_selects (selects,
                        LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                        ([case !functorlv of
                                           EnvironTypes.LVARFOO functorlv => LambdaTypes.VAR functorlv
                                         | EnvironTypes.INTFOO ct =>
                                             cg_longvalid(mklongvalid (Ident.VAR(make_functor_app ct)),env)],
                                         []),
                                        NONE))

      (** lambda expression for dynamic type function instantiations **)
      fun dexp_to_lambda' EnvironTypes.NULLEXP = LambdaTypes.INT (~6)(* functors without constraints *)
        | dexp_to_lambda' (EnvironTypes.INT i) = LambdaTypes.INT i
        | dexp_to_lambda' (EnvironTypes.LAMBDAEXP (selects,(lv,_),_)) =
          wrap_selects (selects,LambdaTypes.VAR lv)
        (* functor_lv is either an lvar or an int *)
        | dexp_to_lambda' (EnvironTypes.LAMBDAEXP' (selects,functorlv,_)) =
          wrap_selects
	    (selects,
             LambdaTypes.APP
	       (LambdaTypes.BUILTIN Pervasives.DEREF,
                ([case !functorlv of
                    EnvironTypes.LVARFOO functorlv => LambdaTypes.VAR functorlv
                 | EnvironTypes.INTFOO ct =>
                    cg_longvalid(mklongvalid (Ident.VAR (make_functor_app ct)),env)],[]),
                NONE))

      (* global overloading-expressions for economy of lambda code *)
      val dexps_ref :
        ({index : int, size : int} list *
         (LambdaTypes.LVar * LambdaTypes.LambdaExp)) list ref = ref []

      (** overloading determination and formation **)
      fun longvalid_dexp_to_lambda(longValId as Ident.LONGVALID(_, Ident.VAR sy),
                                   denv,new_cg,instance,instance_info) =
        let
(*
          (* make runtime instance for polymorphic debugger *)
          (* ZERO | ONE of int | TWO of int * int *)
          (* Make a lambda expression for the instanceinfo object *)
          fun instance_to_lambda Datatypes.ZERO = LambdaTypes.INT 2
            | instance_to_lambda (Datatypes.ONE i) =
              LambdaTypes.STRUCT([LambdaTypes.INT 0,LambdaTypes.INT i],LambdaTypes.CONSTRUCTOR)
            | instance_to_lambda (Datatypes.TWO (i,i')) =
              LambdaTypes.STRUCT([LambdaTypes.INT 1,
                                  LambdaTypes.STRUCT([LambdaTypes.INT i,
                                                      LambdaTypes.INT i'],
                                                     LambdaTypes.CONSTRUCTOR)],
                                 LambdaTypes.CONSTRUCTOR)
*)
          fun make_instance () =
            (case instance of
               NONE => new_cg
                 | _ => Crash.impossible "polyvariable 1")
(*
             | SOME (ref Datatypes.NO_INSTANCE) => new_cg
             | SOME _ =>
                 (LambdaTypes.APP(new_cg,
                 ([instance_to_lambda instance_info],[]),
                                  NONE)))
*)
          fun fetch_instance' () =
            case instance_info of
              Datatypes.ZERO => NONE
            | Datatypes.ONE i => SOME i
            | _ => Crash.impossible "fetch_instance':longvalid_dexp_to_lambda:lambda"

          val dexp = dlookup_longvalid (longValId,denv)
          val dexp' = dexp_to_lambda  dexp
        in
          case dexp of
            EnvironTypes.NULLEXP => make_instance()
          | EnvironTypes.INT i =>
            LambdaTypes.APP
              (new_cg,
               ([let
                 val lexp = LambdaTypes.INT i
               in
                  case fetch_instance'() of
                    NONE =>
                      LambdaTypes.STRUCT([LambdaTypes.INT 0, lexp],LambdaTypes.CONSTRUCTOR)
                  | SOME i =>
                      LambdaTypes.STRUCT([LambdaTypes.INT 1,
                                          LambdaTypes.STRUCT([lexp,
                                                              LambdaTypes.INT i],
                                                             LambdaTypes.TUPLE)],
                      LambdaTypes.CONSTRUCTOR)
               end],[]),
               NONE)
          | EnvironTypes.LAMBDAEXP' _ =>
              LambdaTypes.APP(overload_exp,
                              ([LambdaTypes.STRUCT([new_cg,dexp',
                                                    case fetch_instance'() of
                                                      NONE => LambdaTypes.INT ~1
                                                    | SOME i => LambdaTypes.INT i],
                                                   LambdaTypes.TUPLE)],
                               []),
                              NONE)
          | _ =>
              let
                fun selects(EnvironTypes.LAMBDAEXP(selects,(_,lv),_)) = (selects,lv)
                  | selects _ = Crash.impossible "selects:longvalid_dexp_to_lambda:lambda"
                val (selects,root_lv) = selects dexp
              in
                (case Lists.assoc (selects,!dexps_ref) of
                   (lv,_) =>
                     case fetch_instance'() of
                       NONE => LambdaTypes.VAR lv
                     | SOME i =>
                         LambdaTypes.APP(LambdaTypes.VAR lv,
                                         ([LambdaTypes.INT i],[]),
                                         NONE))
                   handle Lists.Assoc =>
                     let
                       val (lexp,instance') =
                         case fetch_instance'() of
                           NONE =>
                             (LambdaTypes.APP(overload_exp,
                                              ([LambdaTypes.STRUCT([wrap_selects(selects,LambdaTypes.VAR root_lv),
                                                                   dexp',LambdaTypes.INT ~1],
                                                                  LambdaTypes.TUPLE)],
                                               []),
                                              NONE),
                              NONE)
                         | instance' =>
                             (let
                               val lv = new_LVar()
                             in
                               LambdaTypes.FN
				 (([lv],[]),
                                  LambdaTypes.APP
				    (overload_exp,
                                     ([LambdaTypes.STRUCT
                                        ([wrap_selects(selects,LambdaTypes.VAR root_lv),
                                          dexp', LambdaTypes.VAR lv],
                                         LambdaTypes.TUPLE)],[]),
                                     NONE),
                                    LambdaTypes.BODY,
                                  "overload for " ^ Symbol.symbol_name sy,
                                  Datatypes.NULLTYPE,
                                  RuntimeEnv.INTERNAL_FUNCTION)
                             end,
                             instance')

                       val lv = new_LVar()
                     in
                       (dexps_ref := (selects,(lv,lexp))::(!dexps_ref); (* Update global ref *)
                        case instance' of
                          NONE => LambdaTypes.VAR lv
                        | SOME i =>
                            LambdaTypes.APP(LambdaTypes.VAR lv,
                                            ([LambdaTypes.INT i],[]),
                                            NONE))
                     end
              end
        end
        | longvalid_dexp_to_lambda _ = Crash.impossible "longvalid_dexp_to_lambda:lambda"

      (** spill formation for type function instantiation;
          essentially two components, an integer formed from the argument debugger structure to
          the functor and a type-function data structure(see _debugger_print) formed by calling the
          type function function for that uninstantiated null tyfun which is accessed via the
          corresponding argument structure to the functor
       **)

      (* This where DebuggerPrint.TYFUN objects get made *)

      fun make_type_function (EnvironTypes.LAMBDAEXP (selects, (lv,lv'),_)) =
          LambdaTypes.STRUCT ([wrap_selects (selects, LambdaTypes.VAR lv),
                               LambdaTypes.APP(wrap_selects (selects,LambdaTypes.VAR lv'),
                                               ([unit_exp],[]),
                                               NONE)],
                              LambdaTypes.TUPLE)
        | make_type_function _ =
          Crash.impossible "make_type_function:lambda"

      (* convert a debugger-structure expression to lambda code for finding it at runtime *)
      fun dstrexp_to_lambda dstrexp =
        case dstrexp of
          EnvironTypes.LAMBDASTREXP (selects, lv, Datatypes.COPYSTR(_,str)) =>
            dstrexp_to_lambda (EnvironTypes.LAMBDASTREXP(selects, lv, str))
        | EnvironTypes.LAMBDASTREXP(selects, (lv,_), str as Datatypes.STR(_,_,
                                                       Datatypes.ENV(Datatypes.SE stridmap,
                                                                     Datatypes.TE tyconmap,
                                                                     Datatypes.VE(_,validmap)))) =>
          wrap_selects(selects, LambdaTypes.VAR lv) (* the lv will be bound to structure at runtime *)
        | EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str)) =>
            dstrexp_to_lambda (EnvironTypes.LAMBDASTREXP'(selects,lv,str))
        (* functor_lv is either an lvar or an int *)
        | EnvironTypes.LAMBDASTREXP'(selects,functorlv,_) =>
            (wrap_selects
             (selects,
              LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.DEREF,
                               ([case !functorlv of
                                   EnvironTypes.LVARFOO functorlv => LambdaTypes.VAR functorlv
                                 | EnvironTypes.INTFOO ct =>
                                     cg_longvalid (mklongvalid (Ident.VAR (make_functor_app ct)),env)],
                                []),
                               NONE)))
        | EnvironTypes.DENVEXP(EnvironTypes.DENV(validmap,stridmap)) =>
            let
              val validmap = NewMap.to_list_ordered validmap
            in
              LambdaTypes.STRUCT(Lists.reducer (fn ((Ident.TYCON' _,dexp),tycons) =>
                                                dexp_to_lambda' dexp::tycons
                                                | (_,tycons) => tycons)
                                 (validmap,nil) @@
                                 Lists.reducer (fn ((Ident.TYCON' _,_),vars) => vars
                                                | ((_,dexp),vars) => dexp_to_lambda dexp::vars)
                                 (validmap,nil) @@
                                 map (fn (_,dstrexp) => dstrexp_to_lambda dstrexp)
                                 (NewMap.to_list_ordered stridmap),
                                 LambdaTypes.TUPLE)
            end

      (** dummy lambda code for a debugger structure **)
      fun str_to_lambda(Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE stridmap,
                                                        Datatypes.TE tyconmap,
                                                        Datatypes.VE(_,validmap)))) =
        LambdaTypes.STRUCT(map (fn _ => LambdaTypes.INT(~4))
                           (NewMap.to_list_ordered tyconmap) @@
                           map (fn _ => LambdaTypes.INT 0)
                           (NewMap.to_list_ordered validmap) @@
                           map (fn (_,str) => str_to_lambda str)
                           (NewMap.to_list_ordered stridmap),
                           LambdaTypes.TUPLE)
        | str_to_lambda(Datatypes.COPYSTR(_,str)) = str_to_lambda str

      (** compare strs and use the result for lambda code economy **)
      fun compare_strs(Datatypes.COPYSTR (_, str), str') =
        compare_strs (str, str')
        | compare_strs(str, Datatypes.COPYSTR (_, str')) =
          compare_strs (str, str')
        | compare_strs(Datatypes.STR (_, _,Datatypes.ENV
                                      (Datatypes.SE sm,
                                       Datatypes.TE tm,
                                       Datatypes.VE (_, vm))),
                       Datatypes.STR (_, _, Datatypes.ENV
                                      (Datatypes.SE sm',
                                       Datatypes.TE tm',
                                       Datatypes.VE (_, vm')))) =
          NewMap.size vm + NewMap.size tm = NewMap.size vm' + NewMap.size tm' andalso
          NewMap.size sm = NewMap.size sm' andalso
          (* recurse down the structure map *)
          Lists.forall
          compare_strs
          (Lists.zip(NewMap.range_ordered sm,NewMap.range_ordered sm'))

      (** propagate functor-signature to functor-body type function instantiations
          and polymorphic function overloading **)
      fun merge_dexps (dint,EnvironTypes.NULLEXP,_,location) = dint
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,SOME _),SOME tystr,_) =
          EnvironTypes.LAMBDAEXP(selects,lv,SOME(fetch_ntf tystr))
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,SOME _),SOME tystr,_) =
          EnvironTypes.LAMBDAEXP'(selects,lv,SOME(fetch_ntf tystr))
        | merge_dexps(_,dexp,_,_) = dexp

      (** merge two debugger-structure expressions **)
      fun merge_dstrexps(dstr,SOME(Datatypes.COPYSTR(_,str)), dstrexp, location) =
          merge_dstrexps(dstr,SOME str,dstrexp, location)
        | merge_dstrexps(debugger_str,
                         SOME(str as
                                Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap''),
                                                                Datatypes.TE(tyconmap''),
                                                                Datatypes.VE(_,validmap'')))),
                         dstrexp, location) =
          let
            fun merge_lambdastrexps LAMBDAEXP LAMBDASTREXP(selects,lv,str' as
                                Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE stridmap,
                                                                Datatypes.TE tyconmap,
                                                                Datatypes.VE(_,validmap)))) =
             if compare_strs(str',str) then
               LAMBDASTREXP(selects,lv,str)
             else
               EnvironTypes.DENVEXP(
               let
                 val size_validmap = NewMap.size validmap
                 val size_tyconmap = NewMap.size tyconmap
                 val size = NewMap.size stridmap + size_validmap + size_tyconmap
               in
                 NewMap.fold
                 (fn (env, tc' as Ident.TYCON tc, tystr) =>
                  Environ.add_valid_denv
                  (env, (Ident.TYCON' tc, LAMBDAEXP({index=NewMap.rank' (tyconmap,tc'),
                                                                    size=size}
                                                                   ::selects,lv,
                  SOME(fetch_ntf tystr)))))
                 (NewMap.fold
                  (fn (env, s, str) =>
                   Environ.add_strid_denv
                   (env, (s,
                          merge_dstrexps(debugger_str,SOME str,
                          LAMBDASTREXP({index=NewMap.rank' (stridmap,s) + size_validmap + size_tyconmap,
                                        size=size}
                   ::selects,lv,
                   NewMap.apply' (stridmap,s)), location))))
                  ((NewMap.fold
                    (fn (env, v, _) =>
                     Environ.add_valid_denv
                     (env, (v, LAMBDAEXP({index=NewMap.rank' (validmap,v) + size_tyconmap,
                                                        size=size}
                                                       ::selects,lv,NONE))))
                    (Environ.empty_denv, validmap'')), stridmap''), tyconmap'')
               end)
              | merge_lambdastrexps _ LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str')) =
                merge_dstrexps (debugger_str,SOME str,LAMBDASTREXP(selects,lv,str'), location)
          in
          (case dstrexp of
             EnvironTypes.LAMBDASTREXP args =>
               merge_lambdastrexps EnvironTypes.LAMBDAEXP EnvironTypes.LAMBDASTREXP args
           | EnvironTypes.LAMBDASTREXP' args =>
               merge_lambdastrexps EnvironTypes.LAMBDAEXP' EnvironTypes.LAMBDASTREXP' args
           | EnvironTypes.DENVEXP(EnvironTypes.DENV(validmap',stridmap')) =>
              (case !debugger_str of
                 Datatypes.DSTR(stridmap,tyconmap,validmap) =>
                  EnvironTypes.DENVEXP(
                   EnvironTypes.DENV(NewMap.fold
                     (fn (map,tc' as Ident.TYCON tc,i) =>
                      NewMap.define(map,Ident.TYCON' tc,
                        merge_dexps(EnvironTypes.INT i,
                                        NewMap.apply validmap' (Ident.TYCON' tc),
                                        SOME(NewMap.apply'(tyconmap'',tc')), location)))
                     (NewMap.map (fn (v,NONE) => merge_dexps (EnvironTypes.NULLEXP,
                                             (NewMap.apply' (validmap',v)),NONE, location)
                                  | (v,SOME i) =>
                                      merge_dexps(EnvironTypes.INT i,
                                                  NewMap.apply' (validmap',v),NONE, location))
                     validmap,tyconmap),
                     NewMap.map (fn (strid,dstr) =>
                                 merge_dstrexps(ref dstr,
                                                SOME(NewMap.apply' (stridmap'',strid)),
                                                NewMap.apply' (stridmap',strid), location))
                     stridmap))
               | Datatypes.EMPTY_DSTR =>
                   EnvironTypes.DENVEXP(EnvironTypes.DENV(
                     NewMap.map (fn (Ident.TYCON' tc,dexp) =>
                                 merge_dexps(EnvironTypes.NULLEXP,dexp,
                                  SOME(NewMap.apply'(tyconmap'',Ident.TYCON tc)), location)
                                 | (_,dexp) => dexp) validmap',
                     NewMap.map (fn (strid,dstrexp) =>
                                 merge_dstrexps(debugger_str,
                                                SOME(NewMap.apply' (stridmap'',strid)),
                                                dstrexp, location))
                     stridmap'))))
          end
        | merge_dstrexps(ref Datatypes.EMPTY_DSTR, NONE, dstrexp, _) = dstrexp
        | merge_dstrexps _ = Crash.impossible "merge_dstrexps:lambda"

      (** strip type functions in structures compiled with generate_moduler for
          compatibility purposes **)
      fun strip_tyfuns(lexp,env as EnvironTypes.ENV(valid_env, strid_env)) =
        let
          val lvar = new_LVar()
          val valid_map = NewMap.to_list_ordered valid_env
          val strid_map = NewMap.to_list_ordered strid_env
          val size1 = NewMap.size valid_env
          val size2 = size1 + NewMap.size strid_env
          fun filter_vars [] _ = []
            | filter_vars ((Ident.TYCON' _,_)::vars) index = filter_vars vars (index+1)
            | filter_vars (_::vars) index =
              LambdaTypes.SELECT({index=index, size=size2,selecttype=LambdaTypes.STRUCTURE},
                                 LambdaTypes.VAR lvar)::filter_vars vars (index+1)
          fun strip_strs [] _ = []
            | strip_strs ((_,(env,_,_))::strs) index =
              strip_tyfuns(LambdaTypes.SELECT({index=size1 + index, size=size2,selecttype=LambdaTypes.STRUCTURE},
                                              LambdaTypes.VAR lvar),
                           env)::strip_strs strs (index+1)
          val vars = filter_vars valid_map 0
          val strs = strip_strs strid_map 0
          val size3 = length valid_map - length vars
          val size4 = size2 - size3
        in
          (LambdaTypes.LET((lvar,NONE,lexp),
                           LambdaTypes.STRUCT(vars @@ map #1 strs,LambdaTypes.TUPLE)),
           Lists.reducel (fn (env,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env')) =>
                             Environ.add_strid_env(env,(strid,(env',
                                               EnvironTypes.FIELD{index=index-size3,size=size4},false)))
                           | (env,((strid,(_,comp,_)),env')) =>
                             Environ.add_strid_env(env,(strid,(env',comp,false))))
           (Lists.reducel (fn (env,(Ident.TYCON' _,_)) => env
                            | (env,(valid,EnvironTypes.FIELD{index, ...})) =>
                                Environ.add_valid_env(env,(valid,
                                                        EnvironTypes.FIELD{index=index-size3,size=size4}))
                            | (env,valid) => Environ.add_valid_env(env,valid))
            (Environ.empty_env,valid_map),
            Lists.zip(strid_map,map #2 strs)))
        end

      (** include type functions in structures compiled without generate_moduler for
          compatibility purposes **)
      fun include_tyfuns(lexp,Datatypes.COPYSTR(_,str),env) = include_tyfuns(lexp,str,env)
        | include_tyfuns(lexp,str as Datatypes.STR(_,_,
                                            Datatypes.ENV(Datatypes.SE stridmap,
                                                          Datatypes.TE tyconmap,
                                                          Datatypes.VE(_,validmap))),
                         env as EnvironTypes.ENV(valid_env, strid_env)) =


          let
            val lvar = new_LVar()
            val size1 = NewMap.size tyconmap
            val size2 = NewMap.size validmap
            val size3 = size2 + NewMap.size stridmap
            val size4 = size3 + size1
            val tyconmap = NewMap.to_list_ordered tyconmap
            val strid_env = NewMap.to_list_ordered strid_env
            fun new_vars [] _ = []
              | new_vars (_::vars) index =
                LambdaTypes.SELECT({index=index, size=size3,selecttype=LambdaTypes.STRUCTURE},
                                   LambdaTypes.VAR lvar)::new_vars vars (index+1)
            fun prepend_tycons [] = new_vars (NewMap.to_list_ordered validmap) 0
              | prepend_tycons (_::tycons) =
                LambdaTypes.FN(([new_LVar()],[]),
                               LambdaTypes.INT 1,
                               LambdaTypes.BODY,
                               "dummy tyfun tyfun",
                               LambdaTypes.null_type_annotation,
                               RuntimeEnv.INTERNAL_FUNCTION) ::
                prepend_tycons tycons
            fun include_strs [] _ = []
              | include_strs (((_,str),(env,_,_))::strs) index =
                include_tyfuns(LambdaTypes.SELECT({index=size2 + index, size=size3,selecttype=LambdaTypes.STRUCTURE},
                                                  LambdaTypes.VAR lvar),
                               str,env)::include_strs strs (index+1)
            val strs = include_strs (Lists.zip(NewMap.to_list_ordered stridmap,map #2 strid_env)) 0
          in
            (LambdaTypes.LET((lvar,NONE,lexp),
                             LambdaTypes.STRUCT(prepend_tycons tyconmap @@
                                                map #1 strs,
                                                LambdaTypes.TUPLE)),
	     Lists.reducel (fn (map,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env)) =>
                              Environ.add_strid_env(map,(strid,(env,
                                           EnvironTypes.FIELD{index=index+size1,size=size4},true)))
                            | (map,((strid,(_,comp,_)),env)) =>
                              Environ.add_strid_env(map,(strid,(env,comp,true))))
            (#1(Lists.reducel (fn ((map,index),(Ident.TYCON tc,_)) =>
                            (Environ.add_valid_env(map,(Ident.TYCON' tc,
                                                 EnvironTypes.FIELD{index=index,size=size4})),index+1))
             ((EnvironTypes.ENV(NewMap.map (fn (_,EnvironTypes.FIELD{index, ...}) =>
                                               EnvironTypes.FIELD{index=index+size1,size=size4}
                                            | (_,comp) => comp) valid_env,
               NewMap.empty (Ident.strid_lt,Ident.strid_eq)),0),tyconmap)),
             Lists.zip(strid_env,map #2 strs)))
          end

      (** Dummy debugger environment **)
      fun make_dstrexp(Datatypes.COPYSTR(_,str)) = make_dstrexp str
        | make_dstrexp(str as Datatypes.STR(_,_,
                                            Datatypes.ENV(Datatypes.SE stridmap,
                                                          Datatypes.TE tyconmap,
                                                          Datatypes.VE(_,validmap)))) =
          EnvironTypes.DENVEXP(
            EnvironTypes.DENV(
                  NewMap.union
                  (NewMap.fold (fn (map,Ident.TYCON tc,_) =>
                                NewMap.define(map,Ident.TYCON' tc,EnvironTypes.INT(~5)))
                   (NewMap.empty (Ident.valid_lt,Ident.valid_eq),tyconmap),
                   NewMap.map (fn _ => EnvironTypes.NULLEXP) validmap),
                  NewMap.map (fn (_,str) => make_dstrexp str) stridmap))

      fun fetch_interface(SOME(ref(SOME interface))) = interface
        | fetch_interface(SOME _) =
          Crash.impossible "1:NONE:fetch_interface:lambda"
        | fetch_interface _ =
          Crash.impossible "2:NONE:fetch_interface:lambda"

      local
        val empty_dstr = ref Datatypes.EMPTY_DSTR
      in
        fun fetch_debugger_str (SOME debugger_str) = debugger_str
          | fetch_debugger_str NONE = empty_dstr
      end

      fun fetch_tyfun (SOME tyfun) = tyfun
        | fetch_tyfun NONE =
          Crash.impossible "NONE:fetch_tyfun:lambda"

      (* Loads of refs *)
      (** spills generation for all uninstantiated type names in a functor **)
      val tyfun_refs_ref : Datatypes.Tyfun ref list ref = ref []
      val valenv_refs_ref : Datatypes.Valenv ref list ref = ref []
      val tyfun_spills_ref : (Datatypes.Tyfun ref * RuntimeEnv.Offset ref * LambdaTypes.LambdaExp) list ref = ref []
      val tyfun_lvars_ref : (Datatypes.Tyfun ref * (LambdaTypes.LVar * LambdaTypes.LambdaExp)) list ref = ref []

      fun type_spills (denv,ty) =
	let
	  fun type_spills (Datatypes.CONSTYPE(tys,tyn)) =
	    Lists.reducel (fn (spills,ty) => spills@@type_spills ty)
	    (tyname_spills (denv,tyn),
	     tys)
	    | type_spills (Datatypes.FUNTYPE(ty1,ty2)) =
	      type_spills ty1 @@ type_spills ty2
	    | type_spills (Datatypes.RECTYPE map) =
	      NewMap.fold (fn (spills,_, ty) => spills@@type_spills ty) (nil,map)
	    | type_spills (Datatypes.METATYVAR(ref(_,ty,_),_,_)) = type_spills ty
	    | type_spills (Datatypes.META_OVERLOADED {1=ref ty,...}) =
	      type_spills ty
	    | type_spills (Datatypes.TYVAR(ref(_,ty,_),_)) = type_spills ty
	    | type_spills (Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = type_spills ty
	    | type_spills _ = nil
          in
            type_spills ty
          end
        and typescheme_spills (denv,Datatypes.SCHEME(_,(ty,_))) = type_spills (denv,ty)
          | typescheme_spills (denv,Datatypes.UNBOUND_SCHEME(ty,_)) = type_spills (denv,ty)
          | typescheme_spills _ = nil
        and tyname_spills (denv,tyname) =
            let
              fun tyname_spills
                (Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN _),name,_,_,
                                      ve' as ref(Datatypes.VE(_,ve)),_)) =
                if Datatypes.NewMap.is_empty ve then
                  if Lists.member(tf,!tyfun_refs_ref) then nil
                  else
                    (tyfun_refs_ref := tf::(!tyfun_refs_ref);
                     (* do_moduler_debug (fn () => "spill for " ^ name); *)
                     [(tf,
                      (case Lists.assoc(tf,!tyfun_lvars_ref) of
                         (lv,_) => LambdaTypes.VAR lv)
                         handle Lists.Assoc =>
                           let
                             val lv = new_LVar()
                             val lexp = make_type_function (dlookup_tycon(tf,denv))
                           in
                             (tyfun_lvars_ref := (tf,(lv,lexp))::(!tyfun_lvars_ref);
                              lexp)
                           end)]
                     handle exn =>
                       (ignore(fn () =>  (* This looks suspicious.... *)
                        do_moduler_debug
                        (fn () =>
                         "WARNING dlookup_tycon:" ^
                         IdentPrint.printLongValId print_options (mklongvalid (Ident.VAR(Symbol.find_symbol name)))));
                        []))
                else
                  if Lists.member(ve',!valenv_refs_ref) then nil
                  else
                    (valenv_refs_ref := ve'::(!valenv_refs_ref);
                     NewMap.fold (fn (spills,_,tysch) => spills@@typescheme_spills (denv,tysch)) (nil,ve))
                | tyname_spills (Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN tyn),_,_,_,
                                                      ve' as ref(Datatypes.VE(_,ve)),_)) =
                  tyname_spills tyn @@
                  (if Lists.member(ve',!valenv_refs_ref) then nil
                   else
                     (valenv_refs_ref := ve'::(!valenv_refs_ref);
                      NewMap.fold (fn (spills,_,tysch) =>
                                   spills@@typescheme_spills (denv,tysch)) (nil,ve)))
                | tyname_spills (Datatypes.METATYNAME(ref(Datatypes.TYFUN(ty,_)),_,_,_,
                                                      ve' as ref(Datatypes.VE(_,ve)),_)) =
                  type_spills (denv,ty)@@
                  (if Lists.member(ve',!valenv_refs_ref) then nil
                   else
                     (valenv_refs_ref := ve'::(!valenv_refs_ref);
                      NewMap.fold (fn (spills,_,tysch) =>
                                   spills@@typescheme_spills (denv,tysch)) (nil,ve)))
                | tyname_spills (Datatypes.TYNAME
                                   (_,_,_,_,
                                    ve1 as ref(Datatypes.VE(_,ve2)),_,_,
                                    ve3 as ref(Datatypes.VE(_,ve4)),_)) =
                  let
                    val (ve',ve) =
                      (*if Datatypes.NewMap.is_empty ve4 then
                      else (ve1,ve2)*) (ve3,ve4)
                  in
                    if Lists.member(ve',!valenv_refs_ref) then nil
                    else
                      (valenv_refs_ref := ve'::(!valenv_refs_ref);
                       NewMap.fold (fn (spills,_,tysch) =>
                                    spills@@typescheme_spills (denv,tysch)) (nil,ve))
                  end
            in
              tyname_spills tyname
            end
      (** accumulation of spill information for a lambda
       **)
      fun null_tyfun_spills (denv,
                             (RuntimeEnv.VARINFO(name,
                                                 (ref ty,inforef as ref (RuntimeEnv.RUNTIMEINFO (i,_))),_))) =
        if Types.isFunType ty then ()
        else
          let
            val spills =
              map (fn (tf,dexp) =>(tf, ref (RuntimeEnv.OFFSET1 0),dexp))
              (type_spills (denv,ty))
          in
            (* Update the RuntimeInfo ref in the VarInfo *)
            (inforef := (RuntimeEnv.RUNTIMEINFO (i,map (fn (tf,spill,_) =>(tf,spill)) spills));
             tyfun_spills_ref := spills@@(!tyfun_spills_ref))
          end
        | null_tyfun_spills _ = ()

      val null_tyfun_spills =
        if generate_moduler then null_tyfun_spills
        else
          fn _ => ()

      (** generation of spill information for a lambda
       **)
      fun make_null_tyfun_spills lexp =
	let_lambdas_in_exp(
          map (fn (_,spill,tyfun) =>
               LambdaTypes.LETB(new_LVar(),
                                SOME(ref (RuntimeEnv.VARINFO
                                                    ("null_tyfun_spill",
                                                     dummy_instance (),
                                                     SOME spill))),
                                tyfun))
	  (!tyfun_spills_ref),
	  lexp)

      (** absolute spill generation of type function data structures for lexps involving evaluation
          orders that cannot possibly be determined at compile-time
       **)
      val store_null_tyfun_spills =
        if generate_moduler then
          fn () => (!tyfun_refs_ref, !valenv_refs_ref, !tyfun_spills_ref)
        else
          fn () => ([], [], [])

      fun init_null_tyfun_spills () =
        (tyfun_refs_ref := []; valenv_refs_ref := []; tyfun_spills_ref := [])

      val restore_null_tyfun_spills =
        if generate_moduler then
          fn (old_tyfun_refs_ref,old_valenv_refs_ref,old_tyfun_spills) =>
          (tyfun_refs_ref := old_tyfun_refs_ref;
           valenv_refs_ref := old_valenv_refs_ref;
           tyfun_spills_ref := old_tyfun_spills)
        else
          fn _ => ()

      fun make_lambdalist lambdas =
        Lists.reducer
        (fn (lambda,lambdalist) => LambdaTypes.STRUCT([lambda,lambdalist],LambdaTypes.TUPLE)) (lambdas,LambdaTypes.INT(1))

      val dummy_false = ref false
      val dummy_ve = ref Datatypes.empty_valenv
      (** Need type function functions which return a full set of spills for type function
          instantiation;
          absolute spill generation because these are typically invoked from modules foreign to that
          in which it is defined
       **)
      val TYPEdec_spills =
        if generate_moduler then
          fn denvir =>
          let
            fun TYPEdec_spills nil bindings = bindings
              | TYPEdec_spills ((_,tycon as Ident.TYCON sym,_,tyf)::rest) (env,denv,bindings) =
                TYPEdec_spills rest
                let
                  val tyfun_lvar = new_LVar()
                in
                  (Environ.add_valid_env(env, (Ident.TYCON' sym,
                                               EnvironTypes.LAMB(tyfun_lvar, EnvironTypes.NOSPEC))),
                   add_valid_denv(denv, (Ident.TYCON' sym,EnvironTypes.NULLEXP)),
                   LambdaTypes.LETB(tyfun_lvar,NONE,
                                    LambdaTypes.FN(([new_LVar()],[]),
                                                   make_lambdalist
                                                   (map (fn (_,spill) => spill)
                                                    (tyname_spills (denvir,
                                                       Datatypes.METATYNAME(fetch_tyfun tyf,"",0,
                                                                  dummy_false,dummy_ve,dummy_false)))),
                                                   LambdaTypes.BODY,
                                                   (init_null_tyfun_spills();
                                                    "spills for tycon " ^ IdentPrint.printTyCon tycon),
                                                   Datatypes.NULLTYPE,
                                                   RuntimeEnv.INTERNAL_FUNCTION))::bindings)
                end
          in
            TYPEdec_spills
          end
        else
          fn _ => fn _ => fn bindings => bindings
      (** Need type function functions which return a full set of spills for type function
          instantiation;
          absolute spill generation because these are typically invoked from modules foreign to that
          in which it is defined
       **)
      val DATATYPEdec_spills =
        if generate_moduler then
          let
            fun DATATYPEdec_spills (denvir,nil,bindings) = bindings
              | DATATYPEdec_spills (denvir,(_,tycon as Ident.TYCON sym,_,tyf,_)::rest,(env,denv,bindings)) =
                let
                  val tyfun_lvar = new_LVar()
                  val new_env = Environ.add_valid_env(env, (Ident.TYCON' sym,
                                                            EnvironTypes.LAMB(tyfun_lvar, EnvironTypes.NOSPEC)))
                  val new_denv = add_valid_denv(denv, (Ident.TYCON' sym,EnvironTypes.NULLEXP))
                  val new_binding =
                    LambdaTypes.LETB(tyfun_lvar,NONE,
                                     LambdaTypes.FN
                                     (([new_LVar()],[]),
                                      make_lambdalist
                                      (map (fn (_,spill) => spill)
                                       (tyname_spills (denvir,
                                                       Datatypes.METATYNAME(fetch_tyfun tyf,"",0,
                                                                            dummy_false,dummy_ve,dummy_false)))),
                                      LambdaTypes.BODY,
                                      (init_null_tyfun_spills();
                                       "spills for tycon " ^ IdentPrint.printTyCon tycon),
                                      Datatypes.NULLTYPE,
                                      RuntimeEnv.INTERNAL_FUNCTION))
                in
                  DATATYPEdec_spills (denvir,rest,(new_env,new_denv,new_binding::bindings))
                end
          in
            DATATYPEdec_spills
          end
        else
          fn (_,_,bindings) => bindings

      (* END{MODULES DEBUGGER} *)

      fun make_binding (lv,debug_info,instance,lexp,comment,location) =
        if variable_debug
          then [LambdaTypes.LETB(lv,SOME(ref debug_info),lexp)]
        else
          (* Just bind the expression to the variable *)
          [LambdaTypes.LETB (lv,NONE,lexp)]

      val debugger_env_ref = ref initial_debugger_env

      (** Now we need a function that will translate from abstract syntax to
       lambda expressions.  This is done on the way to translating to the
       machine description directly.
       Take an Absyn.Exp and a list of substitutions, and for each type
      of expression translate into the relevant piece of lambda
        calculus.  **)


       fun trans_exp(name, x, env, denv, fnname) =

          case x of
            (** Special constants are easy! **)
            Absyn.SCONexp (sc, ref ty) => LambdaTypes.SCON (sc, Types.sizeof ty)

          (** Lambda variable lookup, except for built-in values for which we
           extract the primitive value that the Environ has for this
           built-in. What's the Type ref for? **)
          (*  This may be more than just variable lookup.
           The longValId may be a nullary type constructor,
           or an exception constructor. We must eliminate these cases first,
           before attempting code generation of a lambda variable from the
           environment.
           *)
          | Absyn.VALexp(longValId, ref ty, location, ref(instance_info,instance)) =>
              (case longValId of
                 Ident.LONGVALID(p, valid as Ident.VAR sy) =>
                   let
                     val sy_name = Symbol.symbol_name sy

		     (* Explanation *)
		     (* Overloaded names are resolved here *)
		     (* An unresolved overloaded name binds to a primitive *)
		     (* Assuming this is the correct primitive for this name *)
		     (* then the name cannot have been rebound *)
		     (* So we check firstly for a primitive *)
		     (* in the current environment, and then in *)
		     (* a special initial environment of overloaded names only *)
		     (* to ensure that we have the correct one *)
		     (* This check is probably overly conservative *)
		     (* A simple check that the primitive produced is one of the *)
		     (* overloaded primitives might well suffice *)
                     val env_ol =
                       case p of
                         Ident.NOPATH =>
                           (case Environ.lookup_valid(valid, env) of
                              EnvironTypes.PRIM prim =>
				(case Environ.overloaded_op valid of
				   SOME prim' => prim = prim'
				 | _ => false)
                            | _ => false)
                       | _ => false

		     fun error_fn (valid, loc) =
		       Info.error'
		       error_info
		       (Info.FATAL, loc,
			"Unresolved overloading for "
			^ IdentPrint.printValId print_options valid)
                     val cg =
                       if env_ol then
			 let
			   val _ = Types.resolve_overloading
			       (not old_definition, ty, error_fn)

			   val sy_name' =
			     "_" ^ (overloaded_name ty) ^ sy_name

			   (* If we're dealing with a numeric type that
			      fits in one machine word, then we use the
			      derived lambda expressions in this file.
			      Otherwise we use built-in pervasives. *)
			   (* At present, derived operations exist only
			      for 8-bit and 16-bit values, and built-in
			      operations for 32-bit and default size values. *)
			   val small_type =
			     case Types.sizeof ty
			     of NONE => true
			     |  SOME sz =>
			       sz <= MachSpec.bits_per_word

			   val cg_opt =
			     if small_type then
			       lookup_derived_overload sy_name'
			     else
			       NONE
			 in
			   case cg_opt
			   of SOME cg => cg ()
			   |  NONE =>
                             (Diagnostic.output 2
                              (fn _ =>
                               ["Overloaded operator ",sy_name,
                                " instantiated to  ",sy_name',"\n"]);
                               cg_longvalid
                                 (mklongvalid
				    (Ident.VAR (Symbol.find_symbol sy_name')),
                                  Primitives.env_for_lookup_in_lambda))
			 end
                       else
                         cg_longvalid(longValId,env)

                     val (new_cg,built_in) =
                       case cg of
                         LambdaTypes.BUILTIN prim =>
                          (if isnt_eq_prim cg andalso isnt_neq_prim cg then
			     cg
                           else
                             let
			       (* Make sure we get the optimisations of poly eq *)
			       val _ = Types.resolve_overloading
				 (not old_definition, ty, error_fn)
                               val sy_name = if is_eq_prim cg then "=" else "<>"
			       val (ok, ty') = domain_type_name ty
			       val (ok, tyname) =
				 if ok then
				   domain_tyname ty'
				 else
				   (false, Types.int_tyname)
			     in
			       if ok then
				 let
				   fun ty_to_check(arg as (_, ty')) =
				     if check_one_vcc_and_no_nullaries ty' then
				       let
(*
					 val _ = print("Found one_vcc_and_no_nullaries for " ^ Types.extra_debug_print_type ty' ^ "\n")
*)
					 val (_, map) = TypeUtils.get_valenv ty'
				       in
					 case NewMap.to_list map of
					   (_, scheme) :: _ =>
					     let
					       val ty = TypeUtils.type_from_scheme scheme
					       val ty = case ty of
						 Datatypes.FUNTYPE(ty, _) => ty (* Get type contructed over *)
					       | _ => ty
(*
					       val _ = print("Converted to " ^ Types.extra_debug_print_type ty ^ "\n")
*)
					       val (ok, tyname) = domain_tyname ty
(*
					       val _ = print((if ok then "ok" else "not ok") ^ " and tyname " ^ Types.debug_print_name tyname ^ "\n")
*)
					     in
					       if ok then
						 ty_to_check(tyname, ty)
					       else
						 arg
					     end
					 | _ => Crash.impossible"ty_to_check: bad map"
				       end
				     else
				       arg
				   val (tyname, ty') = ty_to_check(tyname, ty')
				   val (ident, changed) =
				     if Types.has_int_equality tyname orelse
				       Types.has_ref_equality tyname orelse
				       check_no_vcc_for_eq ty' then
				       (mklongvalid(Ident.VAR(Symbol.find_symbol("_int" ^ sy_name))), true)
				     else
				     if Types.has_real_equality tyname then
				       (mklongvalid(Ident.VAR(Symbol.find_symbol("_real" ^ sy_name))), true)
				     else
				     if Types.has_string_equality tyname then
				       (mklongvalid(Ident.VAR(Symbol.find_symbol("_string" ^ sy_name))), true)
				     else
				     if Types.has_int32_equality tyname then
				       (mklongvalid(Ident.VAR(Symbol.find_symbol("_int32" ^ sy_name))), true)
				     else
				       (longValId, false)
				 in
				   if changed then
				     cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
				   else
				     cg
				 end
			       else
				 cg
			     end
,true)
                       | _ => (cg,false)
                   in
                     if built_in then
                       new_cg
                     else
                       (* pass instance around at runtime *)
                       (* This is where the instance function is applied *)
                       (* The instance and instance info are defined in the typechecker *)
                       (longvalid_dexp_to_lambda (longValId,denv,new_cg,instance,instance_info))
                   end
               | Ident.LONGVALID(_, valid as Ident.CON symbol) =>
                   let
                     val (location,tag) = constructor_tag(valid, ty)
                     val lexp = LambdaTypes.INT tag
                   in
                     case Environ.FindBuiltin(longValId, env) of
		       SOME prim => LambdaTypes.BUILTIN prim
                     | _ =>
			 if TypeUtils.is_vcc ty then
			   let
			     val new_lv = new_LVar()
			   in
			     LambdaTypes.FN
			     (([new_lv],[]),
			      if TypeUtils.get_no_cons ty > 1  andalso
				not (is_list_type (TypeUtils.get_cons_type ty))
				then
				  LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv],LambdaTypes.CONSTRUCTOR)
			      else
				LambdaTypes.VAR new_lv,
                              LambdaTypes.BODY,
                              let
				  val cons_type = TypeUtils.get_cons_type ty
				  val typename =
				    case cons_type of
				      Datatypes.CONSTYPE(_, tyname) =>
					Types.print_name options tyname
				    | _ => Crash.impossible"lambda:bad cons type"
				  val con_name =
				    "constructor " ^ Symbol.symbol_name symbol ^
				    " of " ^ typename
				in
				  if location = "" then
				    con_name
				  else
				    con_name ^ " [" ^ location ^ "]"
				end,
			      LambdaTypes.null_type_annotation,
                              RuntimeEnv.INTERNAL_FUNCTION)
			   end
			 else
			   lexp
                   end
               | Ident.LONGVALID(_, valid as Ident.EXCON _) =>
                   let val (le,_) = cg_longexid(longValId, env)
                   in
                     if TypeUtils.is_vcc ty then
                       let
                         val lv = new_LVar()
                       in
                         LambdaTypes.FN(([lv],[]),
                                        LambdaTypes.STRUCT([le, LambdaTypes.VAR lv],LambdaTypes.CONSTRUCTOR),
                                        LambdaTypes.BODY,
                                        "Builtin code to construct an exception",
                                        LambdaTypes.null_type_annotation,
                                        RuntimeEnv.INTERNAL_FUNCTION)
                       end
                     else
                       LambdaTypes.STRUCT([le, unit_exp],LambdaTypes.CONSTRUCTOR)
                   end
               | _ => Crash.impossible "TYCON':trans_exp:lambda")

          (** Translate each record element, and bundle them up as a STRUCT.
           The ordering is done based on the names of the labels in the
           record, but these are not placed into the STRUCT.  **)
          | Absyn.RECORDexp label_exp_list  =>
             let
                (** This is a known ordering for the labels of a record.  This will
                 always result in records with the same named fields being
                 represented by a STRUCT with the same field ordering.
                 This is in fact mildly bogus. We need to translate the set of
                 expressions in the order in which they were input (ie beware of
                 side effects), bind each to lambda variables
                 **)
                val lvar_lab_lexp_list =
                  map (fn (lab, exp) =>
                       (lab, new_LVar(),
                        trans_exp (" no_name", exp, env, denv, fnname)))
                  label_exp_list
              in
                let_lambdas_in_exp(map (fn (_, lv, le) =>
                                        LambdaTypes.LETB(lv,NONE, le))
                lvar_lab_lexp_list,
                LambdaTypes.STRUCT(map (fn (_, lvar, _) =>
                                        LambdaTypes.VAR lvar)
                                   (Lists.qsort known_order lvar_lab_lexp_list),
                                   LambdaTypes.TUPLE))
              end

    | Absyn.LOCALexp (decl, exp, _) =>
        let
          val (env', denv', lambda_list) = trans_dec (decl, env, false, denv, fnname)
        in
          let_lambdas_in_exp(lambda_list,
            trans_exp(" no_name", exp, Environ.augment_env(env, env'),
                      augment_denv(denv, denv'),
                      fnname))
        end

    (** Perform the application of the result of translation **)
    | Absyn.APPexp(fun_exp, val_exp,_,annotation,_) =>
       let
          val fcn =
            trans_exp(" inline_app", fun_exp, env, denv, fnname)
          val (is_poly, is_eq) =
            case fcn of
              LambdaTypes.BUILTIN Pervasives.EQ =>
                (true, true)
            | LambdaTypes.BUILTIN Pervasives.NE =>
                (true, false)
            | _ => (false, false)

          val arg =
            let
              val arg =
                trans_exp(" no_name", val_exp, env, denv, fnname)
            in
              if is_poly then
                LambdaOptimiser.simple_beta_reduce arg
              else
                arg
            end
          val (good_arg, new_arg, absyn) =
            if is_poly then
              (case (arg, val_exp) of
                 (LambdaTypes.STRUCT([le, le' as LambdaTypes.INT _],_),
                  Absyn.RECORDexp[_, (_, valexp as Absyn.VALexp _)]) =>
                 (true, LambdaTypes.STRUCT([le', le],LambdaTypes.TUPLE), valexp)
               | (LambdaTypes.STRUCT([le' as LambdaTypes.INT _, le],_),
                  Absyn.RECORDexp[(_, valexp as Absyn.VALexp _), _]) =>
                 (true, LambdaTypes.STRUCT([le', le],LambdaTypes.TUPLE), valexp)
                | _ => (false, arg, val_exp))
            else
              (false, arg, val_exp)
          val (true_val, false_val) =
            if is_eq then (LambdaTypes.INT 1, LambdaTypes.INT 0)
            else (LambdaTypes.INT 0, LambdaTypes.INT 1)
        in
          if is_poly andalso good_arg then
            let
              val (exp_arg, tag) = case new_arg of
                LambdaTypes.STRUCT([LambdaTypes.INT tag, le],_) => (le, tag)
              | _ => Crash.impossible "Bad polyeq arg"
              val ty = case absyn of
                Absyn.VALexp(_, ref ty,_,_) => ty
              | _ => Crash.impossible "Non-val generates poly eq"
              val def1 =
                if TypeUtils.get_no_cons ty > 1 then
                  SOME false_val
                else
                  NONE
            in
              LambdaTypes.SWITCH
              (exp_arg,
               SOME {num_imms = 1,num_vccs = 0},
               [(LambdaTypes.IMM_TAG (Int.toString tag,tag), true_val)],
               def1)
            end
          else
            LambdaTypes.APP(fcn, ([arg],[]),SOME annotation)
        end

    (** Throw away the type information (for now), and just transform the
     expression. This is in fact all we need to do, the type is irrelevant **)
    | Absyn.TYPEDexp (expression, _,_) =>
        trans_exp(" no_name", expression, env, denv, fnname)
    (** Code to cope with 'catch' and 'throw' of exceptions **)
    | Absyn.RAISEexp (exp,_) =>
        LambdaTypes.RAISE(trans_exp(" no_name", exp, env, denv, fnname))
    (* Later this might want to do something with the list *)
    (* of marks, but for now we ignore them *)

    | Absyn.HANDLEexp (exp, ty, pat_exp_list,location,annotation) =>
        let
          val old_null_tyfun_spills = store_null_tyfun_spills()
          val handle_exp =
            (init_null_tyfun_spills();
             make_null_tyfun_spills(
           LambdaTypes.HANDLE(
                           trans_exp(annotation, exp, env, denv, fnname),
                           let
                             val (root, tree,redundant_clauses,not_exhaustive) =
                               Match.compile_match pat_exp_list
                           in
                             if show_match then
                               (print"Exception match tree is\n";
                                Lists.iterate
                                print 
                                (Match.unparseTree print_options tree "");
                                print "\n";
                                ())
                             else ();
            let
              val ((static_report_required,static_str),
                   (dynamic_report_required,dynamic_str)) =
                case redundant_clauses of
                  [] => ((false,nil),(false,nil))
                | _ => print_redundancy_info (print_options,
                                              redundant_clauses,
                                              pat_exp_list)
            in
              if static_report_required then
                Info.error error_info (Info.WARNING, location,
                                       Lists.reducel op ^
                                       ("Redundant patterns in match:",static_str))
              else ();
              trans_match((root, tree), env, denv, true,
                          annotation,
              	          LambdaTypes.null_type_annotation,fnname,
                	  if dynamic_report_required then
                               (length pat_exp_list,dynamic_str,location)
                          else (0,[],location))
             end
end,
                         annotation)))
          val _ = restore_null_tyfun_spills old_null_tyfun_spills
        in
          handle_exp
        end

    (** This is a function definition, so perform the pattern matching,
      and return the appropriate Lambda. **)
    | Absyn.FNexp (pat_exp_list, ty, name_string,location) =>
        let
          val (root, tree,redundant_clauses,not_exhaustive) =
            Match.compile_match pat_exp_list
          fun print_list print_fn (list, sep, start, finish) =
            case list of
              [] => start ^ finish
            | (x :: xs) =>
                Lists.reducel
                (fn (str, elem) => str ^ sep ^ print_fn elem)
                (start ^ print_fn x, xs) ^ finish
        in
           if name_string = "Sequence expression"
           then
             let val lhs_ty = #1(Types.argres(!ty))
              in if (Types.type_eq(lhs_ty, Types.empty_rectype, true, true))
                 then
                   ()
                 else
                   Info.error error_info (Info.WARNING, location,
                     "Non-final expression in a sequence has type "
                     ^ Types.print_type options lhs_ty ^ "." )
             end
           else ();

           if show_match then
             (print "Match tree is\n";
              Lists.iterate print (Match.unparseTree print_options tree "");
              print "\n";
              ())
           else
             ();
  
           (case not_exhaustive of
              SOME missing_constructors =>
                Info.error error_info
                (Info.WARNING, location,
                 print_list
                 (fn (ty, valid_list) =>
                  case valid_list of
                    [] => ("missing values of type " ^ Types.print_type options ty)
                  | _ => 
                      print_list
                      (IdentPrint.printValId print_options)
                      (valid_list, ", ",
                       "missing constructors of type " ^
                       Types.print_type options ty ^
                       " : ",
                       ""))
                 (missing_constructors, "\n", "Match not exhaustive\n", ""))
             | _ => ());

               let
                 val ((static_report_required,static_str),
                      (dynamic_report_required,dynamic_str)) =
                   case redundant_clauses of
                     [] => ((false,nil),(false,nil))
                   | _ => print_redundancy_info (print_options,
                                                 redundant_clauses,
                                                 pat_exp_list)
               in
                 if static_report_required then
                   Info.error error_info (Info.WARNING, location,
                                          Lists.reducel op ^
                                          ("Redundant patterns in match:",static_str))
                 else ();
                   trans_match((root, tree), env, denv, false,name_string,!ty,fnname,
                             if dynamic_report_required then
                               (length pat_exp_list,dynamic_str,location)
                             else (0,[],location))
               end
        end

      | Absyn.MLVALUEexp value => LambdaTypes.MLVALUE value

      (* Dynamic expressions *)
      (* info = (<a type>,<tyvar level>,<explicit tyvars>) *)
      (* the type is closed over using the level and tyvar information *)

      | Absyn.DYNAMICexp (exp,_,ref (ty,level,tyvars))=>
          (let
            (* Sort out overloadings within the type *)
            val _ =
              let
                fun error_fn (valid, loc) =
                  Info.error' error_info
                  (Info.FATAL, loc,
                   "Unresolved overloading for "
                   ^ IdentPrint.printValId print_options valid)
              in
                Types.resolve_overloading (not old_definition,ty,error_fn)
              end

            (* Translate the dynamic expression *)

            val lexpr = trans_exp (name,exp,env, denv, fnname)

            (* The type is inserted into the lambda code as a literal MLValue *)
            (* Note that this won't work with cross compilation and separate compilation *)
            val tyexpr = LambdaTypes.MLVALUE
                         (cast
                          (TyperepUtils.convert_dynamic_type (use_value_polymorphism,ty,level,tyvars)))
          in
            (* And make a pair (which will be of type Dynamic)  *)
            LambdaTypes.STRUCT([lexpr,tyexpr],LambdaTypes.TUPLE)
          end
          handle TyperepUtils.ConvertDynamicType =>
            Info.error' error_info (Info.FATAL,Location.UNKNOWN,"Free variables in dynamic type"))
      | Absyn.COERCEexp (exp,_,ref atype, _) =>
          trans_exp (name, TyperepUtils.make_coerce_expression (exp,atype),
                     env, denv, fnname)

       (* End of trans_exp *)

       (* The match translator.
         For a definition of the input supplied, see match.sml
         The match tree has six variants, handled as follows:-
         ERROR - raise match
         LEAF - bind the valids to the lambda variables associated with the match
         vars (thus updating the value environment, but not generating any code)
         and translate the expression within this new value environment
         RECORD - for each label, matchvar pair, produce a lambdavar, lambdaexp pair
                 where the lambdaexp expresses the selection of the labelled item from the
                 record, and the lambdavar is bound to it and also to the matchvar.
                 Translate the tree in this new match environment, and let_lambdas_in_exp
                 of the lambdavar, lambdaexp list and the translation of the tree.
         SCON - switch on the value of the lambda variable associated with the matchvar
                into the labelled cases or the default.
         CONSTRUCTOR - only matchvars corresponding to value carrying constructors
                   are relevant here. For each of these, the associated value is
                   SELECT(1, VAR lambda of original matchvar) (though the type of this may
                   vary, the way of acquiring it doesn't), or if the type has precisely one
                   constructor, and this is value carrying, then the value is
                   VAR lambda of original matchvar. The result is basically a switch, with
                   various possibilities according to how many constructors the type has,
                   whether all are mentioned here, whether all nullary constrcutors are
                   mentioned etc.
        *)

        and trans_match((root, tree), env, denv, is_exn, name_string, ty, fnname_info,
                        (number_of_clauses,redundant_clauses,location)) =
          let
            local
              val match_trans_count_ref : int ref = ref ~1
            in
              fun new_match_trans() =
                (match_trans_count_ref := (!match_trans_count_ref)+1;
                 !match_trans_count_ref)
            end

	    local
	      open LambdaTypes
	      fun telfun f (EXP_TAG e, e') = (EXP_TAG (f e), f e')
		| telfun f (t,e) = (t,f e)

	      fun optfun f (SOME x) = SOME (f x)
		| optfun f NONE = NONE

	      fun hashmap_find (v,env) = IntHashTable.tryLookup (env,lvar_to_int v)
	      val new_valid = new_LVar

	      fun alpha (binds,e) =
		let
		  fun aux (e as INT _) = e
		    | aux (e as SCON _) = e
		    | aux (e as MLVALUE _) = e
		    | aux (e as BUILTIN _) = e
		    | aux (e as VAR v) =
		      (case hashmap_find (v,binds) of
			 SOME e' => e'
		       | NONE => e)
		    | aux (APP (e,(el,fpel),ty)) = APP (aux e,(map aux el,map aux fpel),ty)
		    | aux (STRUCT (el,ty)) = STRUCT (map aux el,ty)
		    | aux (SWITCH (e,info,tel,opte)) =
		      SWITCH (aux e, 
			      info,
			      map (telfun aux) tel,
			      optfun aux opte)
		    | aux (HANDLE (e1,e2,s)) = HANDLE(aux e1,aux e2,s)
		    | aux (RAISE e) = RAISE (aux e)
		    | aux (SELECT (info,e)) = SELECT (info,aux e)
		    | aux (LET ((v,i,e1),e2)) =
		      let
			val v' = new_valid ()
			val e1' = aux e1
			val _ = IntHashTable.update (binds,lvar_to_int v,VAR v')
		      in
			LET((v',i,e1'),aux e2)
		      end
		    | aux (FN ((vl,fpvl),body,status,name,ty,info)) =
		      let
			val new_vl = map (fn v => (v,new_valid ())) vl
			val new_fpvl = map (fn v => (v,new_valid ())) fpvl
			val _ =
			  Lists.iterate
			  (fn (v,v') => IntHashTable.update (binds,lvar_to_int v,VAR v'))
			  (new_vl @@ new_fpvl)
		      in
			FN ((map #2 new_vl,map #2 new_fpvl),aux body,status,name,ty,info)
		      end
		    | aux (LETREC (fl,el,e)) =
		      let
			val fl' = map (fn (v,info) => (new_valid(),info)) fl
			val _ =
			  Lists.iterate
			  (fn ((v,_),(v',_)) => IntHashTable.update (binds,lvar_to_int v,VAR v'))
			  (Lists.zip (fl,fl'))
		      in
			LETREC (fl',map aux el,aux e)
		      end
		in
		  aux e
		end

	      fun empty_hashmap () =
		IntHashTable.new 16

	    in
	      fun rename e = alpha (empty_hashmap () ,e)
	    end

	    local
	      open LambdaTypes
	    in
	      fun has_bounds(INT _) = false
		| has_bounds(SCON _) = false
		| has_bounds(MLVALUE _) = false
		| has_bounds(BUILTIN _) = false
		| has_bounds(VAR _) = false
		| has_bounds(APP(e,(el,fpel), _)) =
		  has_bounds e orelse Lists.exists has_bounds (el@@fpel)
		| has_bounds(STRUCT(el,_)) = Lists.exists has_bounds el
		| has_bounds(SWITCH(e,info,tel,opte)) =
		  has_bounds e orelse Lists.exists has_bounds_tag_exp tel orelse
		  has_bounds_opt opte
		| has_bounds(HANDLE (e1,e2,_)) = has_bounds e1 orelse has_bounds e2
		| has_bounds(RAISE e) = has_bounds e
		| has_bounds(SELECT (_,e)) = has_bounds e
		| has_bounds(LET _) = true
		| has_bounds(FN _) = true
		| has_bounds(LETREC _) = true

	      and has_bounds_opt(SOME e) = has_bounds e
		| has_bounds_opt _ = false

	      and has_bounds_tag_exp(t, e) = has_bounds e orelse has_bounds_tag t

	      and has_bounds_tag(VCC_TAG _) = false
		| has_bounds_tag(IMM_TAG _) = false
		| has_bounds_tag(SCON_TAG _) = false
		| has_bounds_tag(EXP_TAG e) = has_bounds e

(*
	      val rename = fn e =>
		if has_bounds e then
		  (output(std_out, "Renaming because of bound variables\n");
		   rename e)
		else
		  (output(std_out, "Not renaming because no bound variables\n");
		   e)
*)

	      fun size(n, INT _) = n+1
		| size(n, SCON _) = n+1
		| size(n, MLVALUE _) = n+1
		| size(n, BUILTIN _) = n+1
		| size(n, VAR _) = n+1
		| size(n, APP(e, (el,fpel), _)) =
		  size(Lists.reducel size (n+1, (fpel @@ el)), e)
		| size(n, STRUCT(el,_)) = Lists.reducel size (n+1, el)
		| size(n, SWITCH(e,info,tel,opte)) =
		  Lists.reducel size_tag_exp (size_opt(size(n+1, e), opte), tel)
		| size(n, HANDLE(e1,e2,_)) = size(size(n+1, e1), e2)
		| size(n, RAISE e) = size(n+1, e)
		| size(n, SELECT(_,e)) = size(n+1, e)
		| size(n, LET((_, _, le), le')) = size(size(n+1, le), le')
		| size(n, FN(_, le, _, _, _, _)) = size(n+1, le)
		| size(n, LETREC(_, lel, le)) = Lists.reducel size (size(n+1, le), lel)

	      and size_opt(n, SOME e) = size(n, e)
		| size_opt(n, _) = n

	      and size_tag_exp(n, (t, e)) = size(size_tag(n, t), e)

	      and size_tag(n, VCC_TAG _) = n+1
		| size_tag(n, IMM_TAG _) = n+1
		| size_tag(n, SCON_TAG _) = n+1
		| size_tag(n, EXP_TAG e) = size(n+1, e)

	    end

	    val debugging = generate_debug_info orelse generate_moduler orelse debug_variables

(*
	    val _ = output(std_out, "Debugging = " ^
			   (if debugging then "true\n" else "false\n"))
*)

	    val binding_list = ref ([] : (LambdaTypes.LVar * LambdaTypes.LambdaExp) list)
	    fun find_binding lv =
	      if debugging then
		SOME(Lists.assoc(lv, !binding_list))
		handle Lists.Assoc => NONE
	      else
		NONE

	    fun report_binding(lv, opt_e) =
(*
	      output(std_out,
		     (case opt_e of
			SOME e => "Found binding for " ^ LambdaTypes.printLVar lv ^
			  " as : " ^ LambdaPrint.string_of_lambda e
		      | NONE => "Missed binding for " ^ LambdaTypes.printLVar lv) ^
			"\n")
*)
	      ()

	    fun add_binding(lv, le) =
	      if debugging then
		let
		  val arg as (_, e) = (lv, LambdaOptimiser.simple_beta_reduce le)
(*
		  val _ =
		    output(std_out,
			   "Adding binding for " ^ LambdaTypes.printLVar lv ^
			  " as : " ^ LambdaPrint.string_of_lambda e ^ "\n")
*)
		in
		  if size(0, e) <= 200 then
		    binding_list := arg :: !binding_list
		  else
(*
		    output(std_out, "Not adding because lambda expression too large\n")
*)
		    ()
		end
	      else
		()

            val root_lambda = new_LVar()
            val excp =
              if is_exn then
                LambdaTypes.RAISE(LambdaTypes.VAR root_lambda)
              else
                LambdaTypes.RAISE(LambdaTypes.STRUCT([LambdaTypes.BUILTIN Pervasives.EXMATCH, unit_exp],LambdaTypes.CONSTRUCTOR))
            val match_env =
              add_match_env((root,(root_lambda,NONE)),empty_match_env)

            (* This crap is a relic from stepping, I think *)
	    (* the function funny_name_p has moved to the top *)

            (* Retain user name of functions where possible ... *)
            fun filter_name (name_string,fnname) =
              if funny_name_p name_string then fnname else name_string

            val fnname =
              let
                val name =
                  case fnname_info of
                    SOME (s,_) => s
                  | _ => ""
              in
                filter_name (name_string,name)
              end

            val fnname_lv = new_LVar ()

            (* Accumulate Dynamic redundancy checker for this strdec dec by SWITCHing on
               boolean expressions provided by the Match Compiler
             *)
            fun redundancy_code () =
              case redundant_clauses of
                nil => ()
              | _ =>
              let
                val redundant_clauses_lambda = new_LVar()
                val MLWorks_Internal_StandardIO_printError =
                      cg_longvalid(make_longid (["MLWorks","Internal","StandardIO"],"printError"),env)
                fun redundant_clauses_lambdas nil = nil
                  | redundant_clauses_lambdas (((_,exns),rc)::rcs) =
                    let
                      val lvar = new_LVar()
                    in
                      (lvar,exns,rc,
                       LambdaTypes.LETB
			 (lvar,
			  NONE,
                          LambdaTypes.APP
			    (LambdaTypes.BUILTIN Pervasives.REF,
                             ([LambdaTypes.SCON(Ident.STRING rc, NONE)],[]),
                             NONE)))
                      ::redundant_clauses_lambdas rcs
                    end
                val redundant_clauses = redundant_clauses_lambdas redundant_clauses
                val bindings = map (fn (_,_,_,bd) => bd) redundant_clauses
                fun make_dynamic_redundancy_report() =
                  let
                    fun report nil = LambdaTypes.SCON(Ident.STRING("\n"), NONE)
                      | report ((lvar,_,_,_)::rcs) =
                        LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.HAT,
                                        ([LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                              ([LambdaTypes.VAR lvar],[]),
                                                                              NONE),
                                                              report rcs],
                                                             LambdaTypes.TUPLE)],
                                         []),
                                        NONE)
                  in
                    LambdaTypes.SWITCH(
                            LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.INTEQ,
                                            ([LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                                  ([LambdaTypes.VAR redundant_clauses_lambda],[]),
                                                                                NONE),
                                                                LambdaTypes.SCON(Ident.INT("0",Location.UNKNOWN), NONE)],
                                                                LambdaTypes.TUPLE)],
                                             []),
                                            NONE),
                            SOME {num_imms = 2,num_vccs = 0},
                            [(LambdaTypes.IMM_TAG ("",1),unit_exp),
                             (LambdaTypes.IMM_TAG ("",0),
                               LambdaTypes.APP(MLWorks_Internal_StandardIO_printError,
                                ([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.HAT,
                                  ([LambdaTypes.STRUCT([LambdaTypes.SCON(Ident.STRING(
                                                      Location.to_string location ^ ": " ^ "warning" ^ ": " ^
                                                                     "Redundant patterns in match:\n"), NONE),
                                                      report redundant_clauses],
                                                      LambdaTypes.TUPLE)],
                                   []),
                                  NONE)],
                                 []),
                                NONE))],
                            NONE)
                  end
                fun redundancy_code nil = make_dynamic_redundancy_report()
                  | redundancy_code ((lvar,exns,rc,_)::rcs) =
                    let
                      (* code for an exception constructor must be free of *)
                      (* all lambda variables bound in this strdec dec *)
                      fun exn_code (exn as Ident.LONGVALID(p,s)) =
                        let
                          val (exp,longstrid) = cg_longexid(exn,env)
                          (* longstrid : (Ident.longstrid,int/lvar) option opt *)
                          val select_exp =
                            case (longstrid,exn) of
                              (EnvironTypes.STRIDSPEC (Ident.LONGSTRID(p,Ident.STRID s)),
                               Ident.LONGVALID(p',s')) =>
                              let
                                val newlongstrid =
                                  Ident.LONGVALID (combine_paths (p, combine_paths (Ident.PATH(s,Ident.NOPATH),p')),s')
                              in
                                #1(cg_longexid (newlongstrid,env))
                              end
                            | (EnvironTypes.VARSPEC lvar, _) =>
                              LambdaTypes.VAR lvar
                            | (EnvironTypes.NOSPEC, _) => exp
                        in
                          LambdaTypes.SELECT({index = 0, size = 2,selecttype=LambdaTypes.CONSTRUCTOR},
                                             select_exp)
                        end
                      fun switches (Match.==(exn1,exn2)) =
                          LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.INTEQ,
                                          ([LambdaTypes.STRUCT([exn_code exn1,exn_code exn2],
                                                               LambdaTypes.TUPLE)],
                                           []),
                                          NONE)
                        | switches (Match.&&(exn1,exn2)) =
                          LambdaTypes.SWITCH(switches exn1,
                                             SOME {num_imms = 2,num_vccs = 0},
                                             [(LambdaTypes.IMM_TAG ("",1),switches exn2),
                                              (LambdaTypes.IMM_TAG ("",0),LambdaTypes.INT 0)],
                                             NONE)
                        | switches (Match.||(exn1,exn2)) =
                          LambdaTypes.SWITCH(switches exn1,
                                             SOME {num_imms = 2,num_vccs = 0},
                                             [(LambdaTypes.IMM_TAG ("",1),LambdaTypes.INT 1),
                                              (LambdaTypes.IMM_TAG ("",0),switches exn2)],
                                             NONE)
                        | switches Match.TRUE = LambdaTypes.INT 1
                        | switches Match.FALSE = LambdaTypes.INT 0
                    in
                      LambdaTypes.LET((new_LVar(),NONE,
                       LambdaTypes.SWITCH(switches exns,
                        SOME {num_imms = 2,num_vccs = 0},
                        [(LambdaTypes.IMM_TAG ("",1),
                          LambdaTypes.STRUCT([
                           LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.BECOMES,
                           ([LambdaTypes.STRUCT([LambdaTypes.VAR lvar,
						LambdaTypes.SCON (Ident.STRING("\n  ->" ^ (String.extract (rc, 5, NONE))), NONE)],
					       (* tl(tl(tl(tl(tl(explode rc))))))), NONE)], *)
                             LambdaTypes.TUPLE)],
                            []),
                            NONE),LambdaTypes.INT 1],
                          LambdaTypes.TUPLE)),
                        (LambdaTypes.IMM_TAG ("",0),
                           LambdaTypes.STRUCT([
                            LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.BECOMES,
                             ([LambdaTypes.STRUCT([LambdaTypes.VAR redundant_clauses_lambda,
                              LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.INTMINUS,
                                ([LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                      ([LambdaTypes.VAR redundant_clauses_lambda],[]),
                                                                    NONE),
                                               LambdaTypes.SCON(Ident.INT("1",Location.UNKNOWN), NONE)],
                                LambdaTypes.TUPLE)],
                                 []),
                                NONE)],
                            LambdaTypes.TUPLE)],[]),
                            NONE), LambdaTypes.INT 1],
                           LambdaTypes.TUPLE))],
                        NONE)),
                       redundancy_code rcs)
                    end
              in
                (dynamic_redundancy_report_ref :=
                 let
                   val dynamic_report = !dynamic_redundancy_report_ref
                 in
                   fn exp =>
                   dynamic_report
                   (LambdaTypes.LET
                    ((new_LVar(),NONE,
                     let_lambdas_in_exp
                     (LambdaTypes.LETB
                      (redundant_clauses_lambda,NONE,
                       LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                       ([LambdaTypes.SCON(Ident.INT(Int.toString number_of_clauses,
                                                                   Location.UNKNOWN), NONE)],
                                        []),
                                       NONE)) ::
                      bindings,redundancy_code redundant_clauses)),
                     exp))
                 end)
              end

            (* Tree matching function *)
            fun tr_match(tree, match_env, val_env) =
             let
               (* Sometimes the match translator returns an incomplete match *)
               (* This function ensures that all such matches have a default case *)
               fun ensure_default (LambdaTypes.SWITCH (exp,info,tel,NONE)) =
                 let
                   fun last ([],_) = Crash.impossible "ensure_default"
                     | last ([a],acc) = (rev acc,a)
                     | last (a::rest,acc) = last (rest,a::acc)
                   val (tel',(t,e)) = last (tel,[])
                 in
                   LambdaTypes.SWITCH (exp,info,tel',SOME e)
                 end
		 | ensure_default exp = exp
	       fun lvar_let_lambdas_in_exp (lambda_exp,bindings,lvar_info) =
                 let
                   (* Very horrid indeed *)
                   fun add_match_string (name, match_string) =
                     let
                       val match_string' = explode match_string
                       fun aux (#"[" ::rest,acc) =
                         (implode (rev acc)) ^ match_string ^
                         (implode( #"[" :: rest))
                         | aux (c::rest,acc) = aux (rest,c::acc)
                         | aux ([],acc) = name ^ match_string
                     in
                       aux (explode name,[])
                     end
                   val (this_lvar,this_lexp) =
                     case lvar_info of
                       SOME lvar => lvar
                     | NONE => (new_LVar(), LambdaTypes.INT 1)
                   fun do_binding nil = nil
                     | do_binding (Match.INL (ref NONE)::bindings) =
                       do_binding bindings
                     | do_binding (Match.INL (ref (SOME (lvar as ref(Match.INL(_,tree)))))::bindings) =
                       let
                         val lv =  new_LVar()
                         val match_fnname =
                             if fnname = name_string then
                               add_match_string (name_string,"<Match" ^ Int.toString(new_match_trans()) ^ ">")
                             else
                               add_match_string (name_string,
                                                 "<Match" ^ Int.toString(new_match_trans()) ^ ">")
			 val _ = lvar := Match.INR lv
			 (* Something to do with match compilation *)
			 val fnbody =
			   let
			     val old_null_tyfun_spills = store_null_tyfun_spills()
			     val tr_match =
			       (init_null_tyfun_spills();
				make_null_tyfun_spills(tr_match(tree,match_env,val_env)))
			     val _ = restore_null_tyfun_spills old_null_tyfun_spills
			   in
			     ensure_default tr_match
			   end
			 val fnexp =
			   LambdaTypes.FN(([new_LVar()],[]),
			   fnbody,
                           LambdaTypes.BODY,
			   match_fnname,
			   LambdaTypes.null_type_annotation, (* Or we could pass in the free variables and get a type *)
                           RuntimeEnv.INTERNAL_FUNCTION)
			 val _ = add_binding(lv, fnbody)
		       in
			 LambdaTypes.LETB
			 (lv, NONE,
                           (* This where default functions are created *)
                           (* It would be nice to have these take all their free variables as parameters *)
			  fnexp) :: do_binding bindings
		       end
                     | do_binding (Match.INL _::_) =
                       Crash.impossible "1:do_binding:lvar_let_lambdas_in_exp:Match_translator:_lambda.sml"
                     | do_binding (Match.INR(lvar' as ref (Match.INL (_,tree)),matchvar)::bindings) =
                       let
                         val lv =  new_LVar()
                         val match_fnname =
                           add_match_string (name_string,"<Match" ^ Int.toString(new_match_trans()) ^ ">")
			 val _ = lvar' := Match.INR lv
			 (* Something to do with match compilation *)
			 val fnbody =
			   let
			     val old_null_tyfun_spills = store_null_tyfun_spills()
			     val tr_match =
			       (init_null_tyfun_spills();
				make_null_tyfun_spills
				(case matchvar of
				   ~1 => tr_match(tree, match_env, val_env)
				 | _ =>
				     LambdaTypes.LET
				     ((this_lvar,NONE,this_lexp),
				      tr_match
				      (tree,
				       add_match_env
				       ((matchvar,(this_lvar,NONE)),
					match_env),
				       val_env))))
			     val _ = restore_null_tyfun_spills old_null_tyfun_spills
			   in
			     ensure_default tr_match
			   end
			 val fnexp =
			   LambdaTypes.FN
			   (([new_LVar()],[]),
			    fnbody,
                            LambdaTypes.BODY,
			    match_fnname,
			    LambdaTypes.null_type_annotation, (* Or we could pass in the free variables and get a type *)
			    RuntimeEnv.INTERNAL_FUNCTION)
			 val _ = add_binding(lv, fnbody)
                       in
			 LambdaTypes.LETB
			 (lv,NONE,
			  (* This where default functions are created *)
			  fnexp) :: do_binding bindings
		       end
                     | do_binding (Match.INR _::_) =
                       Crash.impossible "2:do_binding:lvar_let_lambdas_in_exp:Match_translator:_lambda.sml"
                 in
                   let_lambdas_in_exp (do_binding bindings,lambda_exp())
                 end
	       fun Tr_Default default =
		 let
		   fun Tr_Default (ref(Match.BUILT(ref(Match.INR lvar)))) =
		     let
		       val opt_e = find_binding lvar
		       val _ = report_binding(lvar, opt_e)
		     in
		       case opt_e of
			 SOME y => SOME(rename y)
		       | _ =>
			   SOME(LambdaTypes.APP(LambdaTypes.VAR lvar, ([unit_exp],[]), NONE))
		     end
		     | Tr_Default (ref(Match.BUILT(ref(Match.INL(0,tree))))) =
		       SOME
		       (init_null_tyfun_spills();
			make_null_tyfun_spills
			(tr_match(tree, match_env, val_env)))
		     | Tr_Default (ref(Match.ERROR _)) =
		       SOME excp
		     |  Tr_Default _ = Crash.impossible "1:Tr_Default:tr_match:_lambda.sml"
		 in
		   case default of
		     Match.INL (SOME default) => Tr_Default default
		   | Match.INL NONE => NONE
		   | Match.INR (ref (Match.INR lvar)) =>
		     let
		       val opt_e = find_binding lvar
		       val _ = report_binding(lvar, opt_e)
		     in
		       case opt_e of
			 SOME y => SOME(rename y)
		       | _ =>
			   SOME (LambdaTypes.APP
				 (LambdaTypes.VAR lvar, ([unit_exp],[]), NONE))
		     end
		   | Match.INR _ =>
		       Crash.impossible "2:Tr_Default:tr_match:_lambda.sml"
		 end
	     in
              case tree of
                Match.LEAF(exp, n, mv_valid_ty_list) =>
                  let
                    fun do_leaf([], env, denv) =
                      trans_exp(" match_leaf", exp, env, denv, SOME (fnname,fnname_lv))
                      | do_leaf((mv, valid, ty) :: tl, env, denv) =
                          case lookup_match(mv, match_env) of
                            (lv, NONE) =>
                             if variable_debug then
                              (* include typing and identifier information for debugger *)
                              (case valid of
                                 Ident.VAR symbol =>
                                   let
(*
				     val _ =
				       output(std_out, "Doing do_leaf for (lv, NONE) case, valid = " ^ IdentPrint.printValId print_options valid ^ "\n")
*)
                                     val dummylv = new_LVar()
                                     val debug_info =
				       RuntimeEnv.VARINFO
					 (Symbol.symbol_name symbol,
					  ty,
					  NONE)
                                   in
                                     (null_tyfun_spills (denv,debug_info);
                                      LambdaTypes.LET
                                      ((dummylv,SOME (ref debug_info),
                                        LambdaTypes.VAR lv),
                                       do_leaf(tl,
                                               Environ.add_valid_env(env,
                                                                     (valid,
                                                                      EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),
                                               add_valid_denv(denv, (valid,EnvironTypes.NULLEXP)))))
                                   end
                               | _ =>
                                   do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                           EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),
                                           add_valid_denv(denv, (valid,EnvironTypes.NULLEXP))))
                             else (* no variable debug *)
                               do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                       EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),
                                       add_valid_denv(denv, (valid,EnvironTypes.NULLEXP)))
                          | (lv, SOME varinforef) =>
                              (* include typing and identifier information for debugger *)
			      (* This case should no longer happen *)
			      Crash.impossible("debug info already set for " ^
					       IdentPrint.printValId print_options valid)
                  in
                    do_leaf(rev mv_valid_ty_list, val_env, denv)
                  end

              | Match.SCON(mv, scon_tree_list, default, binding, opt_size) =>
	         let
                   fun lambda_exp() =
                     let
                       val old_null_tyfun_spills = store_null_tyfun_spills()
                     in
                        LambdaTypes.SWITCH(
	                 LambdaTypes.VAR(#1(lookup_match(mv, match_env))),
	                 NONE,
                         map (fn (scon,tree) =>
                              (LambdaTypes.SCON_TAG (scon, opt_size),
                               (init_null_tyfun_spills();
                                make_null_tyfun_spills(tr_match(tree, match_env, val_env)))))
                         scon_tree_list,
                       let
                         val default =
			   case default of
			     SOME default =>
			       Tr_Default (Match.INL(SOME default))
			   | _ => NONE
                         val _ = restore_null_tyfun_spills old_null_tyfun_spills
                       in
                         default
                       end)
                     end
	         in
		   lvar_let_lambdas_in_exp (lambda_exp,
					    case binding of
					      NONE => []
					    | SOME bd =>[Match.INL bd],
						NONE)
                 end
              | Match.CONSTRUCTOR(ty, mv, longvalid_mv_tree_list, default, binding, exception_tree) =>
                  let
                    val ORIG_LV = lookup_match(mv, match_env)
                    val orig_lv = #1 ORIG_LV
                    val lv_e = LambdaTypes.VAR orig_lv

                    val (_,type_val_env) =
                      TypeUtils.get_valenv(TypeUtils.get_cons_type ty)

                    val is_exn =
                      case longvalid_mv_tree_list of
                        {1=Ident.LONGVALID(_, Ident.EXCON _), ...} :: _ => true
                      | {1=Ident.LONGVALID(_, Ident.CON _), ...} :: _ => false
                      | _ => Crash.impossible "Match.CONS bad arg"

                    fun has_value(Ident.LONGVALID(_, valid as Ident.CON _)) =
                      (case TypeUtils.type_from_scheme(
                                                        NewMap.apply'(type_val_env, valid)) of
                         Datatypes.FUNTYPE _ => true
                       | _ => false
                           )
                      |   has_value(Ident.LONGVALID(_, Ident.VAR _)) =
                          Crash.impossible"VAR in match CONS"
                      |   has_value(Ident.LONGVALID(_, Ident.TYCON' _)) =
                          Crash.impossible"TYCON' in match CONS"
                      |   has_value(Ident.LONGVALID(_, Ident.EXCON excon)) = true
                    (* Pretend all exceptions carry values, even if only unit *)

                    val new_lv = new_LVar()
                    val new_le = GetConVal lv_e
                    val con_field = GetConTag lv_e
                    val vcc_lv_list =
                      Lists.filterp (has_value o #1) longvalid_mv_tree_list
                    (* Note we're using the same lambda variable for all the
                     vcc matchvars, since they're all going to be the same
                     expression, viz SELECT(1, original matchvar) (aka new_le) *)

                    fun tr_match'(Match.INL tree,match_env, val_env) =
                      tr_match(tree, match_env, val_env)
                      | tr_match'(Match.INR(ref(Match.INR lvar)),_, _) =
			let
			  val opt_e = find_binding lvar
			  val _ = report_binding(lvar, opt_e)
			in
			  case opt_e of
			    SOME x => rename x
			  | _ =>
			      LambdaTypes.APP(LambdaTypes.VAR lvar,
					      ([unit_exp],[]),
					      NONE)
			end
                      | tr_match'(Match.INR _, _, _) =
                        Crash.impossible "tr_match':trans_match:lambda"

                    (* mk_branch produces a (tag, code) pair, for a branch of the SWITCH. *)

                    fun mk_branch (id as Ident.LONGVALID(_, valid), mv, tree) =
                      if has_value id then
                        (LambdaTypes.VCC_TAG(valid_name valid,#2(constructor_tag(valid, ty))),
                        (* VCC_TAG isn't really accurate - will break when we
                         automatically dereference the constructor value.
                         But IMM_TAG isn't right either, as we have to know
                         where to branch from the test of the run-time tag. *)

                        if is_list_type ty then
	                  (* Now we do some bizarre stuff.  The match compiler
			     still produces a match variable for the argument
			     of cons, so we have to bind it to the expression
			     being matched.*)
	                   tr_match'(tree,
                                     add_match_env((mv, ORIG_LV), match_env),
                                     val_env)
                        else
                          LambdaTypes.do_binding
                          (* Assign lambda variable to value carried by constructor *)
                          let
                            val info = NONE
                          in
                            (LambdaTypes.LETB(new_lv, info, new_le),
                             tr_match'(tree,
                                       add_match_env((mv, (new_lv,info)), match_env),
                                       val_env))
                          end)
                      else
                        (LambdaTypes.IMM_TAG(valid_name valid,#2(constructor_tag(valid, ty))),
                         tr_match'(tree, match_env, val_env))
                    fun lambda_exp1() =
                      if TypeUtils.get_no_cons ty = 1 then
                        (* Use this instead of TypeUtils.has_value_cons ty, because
                         we want to know about explicitly mentioned constructors
		         and we want to treat all EXCONS as VCCs. *)
                        (* And at this point I give up formatting *)
                  if length vcc_lv_list <> 0 then
	            (* Handle case of only one constructor, carrying a value *)
	            (* This relies on constructor nodes only arising when *)
	            (* some constructor is actually quoted, not bad I suppose *)
	            let val (name, mv, tree) =
		          case vcc_lv_list of
	                    [x] => x
	                  | _ => Crash.impossible "list size"
	            in
		      (* Check to see if its ref (handled specially) *)
		      case Environ.FindBuiltin(name, val_env)  of
			SOME Pervasives.REF =>
			  let
			    val new_lv = new_LVar ()
			    val info = NONE
			  in
			    LambdaTypes.do_binding
			    (LambdaTypes.LETB
			     (new_lv,info,
			      LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
					      ([LambdaTypes.VAR orig_lv],[]),
					      NONE)),
			     tr_match'(tree,
				       add_match_env((mv, (new_lv,info)),
						     match_env),
				       val_env)
			     )
			  end
		      | _ =>
	                (* Ensure we pass through the value by assigning the
	                   same lambda variable to the new matchvar as we had
                           passed through in the first place. This works since
		           the constructor has no effect on the representation
		           of the value (only one constructor case) *)
			  tr_match'(tree,
				    add_match_env((mv, ORIG_LV),match_env),
				    val_env)
	            end
	          else
	            (* Only one constructor, with no value *)
	            let val tree = case longvalid_mv_tree_list of
		                     [(_, _, tree)] => tree
	                           | _ => Crash.impossible "list size"
	            in
		      (* No value to be passed through here *)
		      tr_match'(tree, match_env, val_env)
	            end
	        else
	          (* More than one constructor in this type. Must switch *)
                  let
                    val old_null_tyfun_spills = store_null_tyfun_spills()
                  in
	          LambdaTypes.SWITCH(
	            lv_e,
		    SOME{
	              num_vccs = TypeUtils.get_no_vcc_cons ty,
		      num_imms = TypeUtils.get_no_null_cons ty
		    },
                    map (fn tree=>
                             let
                               val (tag,tree) =
                                 (init_null_tyfun_spills();
                                  mk_branch tree)
                             in
                               (tag,make_null_tyfun_spills tree)
                             end) longvalid_mv_tree_list,
                  let
                    val default =
                      if length longvalid_mv_tree_list =
                        TypeUtils.get_no_cons ty then
                        NONE (* No default here if all cases ok *)
                      else Tr_Default default
                    val _ = restore_null_tyfun_spills old_null_tyfun_spills
                  in
                    default
                  end) (* end of LambdaTypes.SWITCH *)
                  end
          fun lambda_exp2() =
            let
              val info = NONE
            in
	      let_lambdas_in_exp
              ([LambdaTypes.LETB(new_lv,info,new_le)],
               let
                 val old_null_tyfun_spills = store_null_tyfun_spills()
               in
                 LambdaTypes.SWITCH
                 (select_exn_unique con_field,
		  SOME{num_vccs = 0,num_imms = 0},
                  map (fn (longvalid, mv, tree) =>
                       (LambdaTypes.EXP_TAG
                        (select_exn_unique(#1(cg_longexid(longvalid, val_env)))),
                        (init_null_tyfun_spills();
                         make_null_tyfun_spills
                         (tr_match'(tree,
                                    add_match_env((mv, (new_lv,info)),match_env),
                                    val_env)))))
                  vcc_lv_list,
                  let
                    val default = Tr_Default default
                    val _ = restore_null_tyfun_spills old_null_tyfun_spills
                  in
                    default
                  end)
               end)
            end
          fun lambda_exp3() =
            let
              val old_null_tyfun_spills = store_null_tyfun_spills()
            in
	      LambdaTypes.SWITCH(
		  select_exn_unique con_field,
                  SOME{num_vccs = 0,num_imms = 0},
                  map (fn (longvalid, _, tree) =>
                       (LambdaTypes.EXP_TAG(select_exn_unique(#1(cg_longexid(longvalid, val_env)))),
                        (init_null_tyfun_spills();
                             make_null_tyfun_spills(tr_match'(tree,match_env,val_env)))))
                  vcc_lv_list,
                  let
                    val default = Tr_Default default
                    val _ = restore_null_tyfun_spills old_null_tyfun_spills
                  in
                    default
                  end)
            end
	in
          if exception_tree then
            lvar_let_lambdas_in_exp (lambda_exp3, binding, NONE)
          else
            case is_exn of
              false => (* Not an exception constructor *)
                lvar_let_lambdas_in_exp (lambda_exp1, binding, NONE)
            | true =>
                (* Is an exception constructor *)
                lvar_let_lambdas_in_exp (lambda_exp2, binding, SOME(new_lv,new_le))
	end
      | Match.RECORD(ty, mv, lab_mv_list, tree) =>
	let
          val lab_mv_lv_list =
            if variable_debug then
              map (fn (x,y) => (x, y,
				(new_LVar(), NONE)))
              lab_mv_list
            else
              map
              (fn (x,y) => (x, y,(new_LVar(), NONE)))
              lab_mv_list
	  val le = LambdaTypes.VAR (#1(lookup_match(mv, match_env)))
	  val new_env = Lists.reducel
	    (fn (env, (_, x, y)) => add_match_env((x, y), env))
            (match_env, lab_mv_lv_list)
	  val lv_le_list =
	    map (fn (lab,_, (lv,info)) =>
		 LambdaTypes.LETB(lv,info,
                                  LambdaTypes.SELECT(record_label_offset(lab,ty,error_info,location),le)))
	    lab_mv_lv_list
	in
	  unordered_let_lambdas_in_exp
	  (lv_le_list, tr_match(tree, new_env, val_env))
	  (* Binding lambdas to selects off a record is side effect free *)
	end
      | Match.DEFAULT(default,binding) =>
          let
            fun lambda_exp() =
              case Tr_Default (Match.INL(SOME default)) of
                NONE => Crash.impossible "Match.DEFAULT:trans_match:lambda"
              | SOME lexp => lexp
          in
            lvar_let_lambdas_in_exp (lambda_exp,
                                     case binding of
                                       NONE => []
                                     | SOME bd => [Match.INL bd],
                                     NONE)
          end
     end

   (* Construct the debug_info for the function return value *)
   val debug_info = RuntimeEnv.NOVARINFO
  in
    (redundancy_code();
     LambdaTypes.FN(([root_lambda],[]),
                    let
                      val old_null_tyfun_spills = store_null_tyfun_spills()
                      val tr_match =
                        (init_null_tyfun_spills();
                         make_null_tyfun_spills
                         (null_tyfun_spills (denv,debug_info);
                          tr_match (tree, match_env,env)))
                      val _ = restore_null_tyfun_spills old_null_tyfun_spills
                    in
                      tr_match
                    end,
                    LambdaTypes.BODY,
                    name_string,ty,RuntimeEnv.INTERNAL_FUNCTION))
  end (* end of trans_match *)


  (* trans_dec should return the incremental environment from translating *)
  (* the declarations, not the overall environment from the original and the *)
  (* translation. Thus trans_dec should accumulate the increment until it *)
  (* runs out of things to do, and then return it. *)

  and trans_dec(some_dec, envir, is_toplevel, denvir, fnname) =
  let
    val excp = SOME
      (LambdaTypes.RAISE
       (LambdaTypes.STRUCT
        ([LambdaTypes.BUILTIN Pervasives.EXBIND, unit_exp],
         LambdaTypes.CONSTRUCTOR)))

    fun do_datatypeinfo_list datatypeinfo_list =
      let
        fun trans_single_datatype(_, _, _, _, v_tref_topt_list) =
          let
            (* Translate one constructor binding of a datatype into an ordinary
               VAL declaration *)
            fun munge((valid as Ident.CON sy, ref ty), _) =
              (Absyn.VALpat ((mklongvalid (Ident.VAR sy),(ref ty,ref null_runtimeinfo)),
                             Location.UNKNOWN),
               Absyn.VALexp (mklongvalid valid,ref ty,
                             Location.UNKNOWN, ref (Datatypes.ZERO, NONE)),
               Location.UNKNOWN)
              | munge _ = Crash.impossible"Absyn.DATATYPE"

                (* now translate all the bindings of a datatype into VAL decs*)
            val valdec_list = map munge v_tref_topt_list
          in
                (* translate list of VALdecs into lambda code *)
            trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set,[]),
                      Environ.empty_env, false, denvir, fnname)
          end

             (* lambda translate each datatype binding *)
        val e_l_list = map trans_single_datatype datatypeinfo_list
        val old_null_tyfun_spills = store_null_tyfun_spills()
        val _ = init_null_tyfun_spills()
        val (env, denv, spills) =
          DATATYPEdec_spills
          (denvir,datatypeinfo_list,
           (env_from_list e_l_list, denv_from_list e_l_list, nil))
        val _ = restore_null_tyfun_spills old_null_tyfun_spills
        val new_spills = Lists.reducel (fn (l1, (_, _, l2)) => l1 @@ l2) ([], e_l_list)

            (*now extract the names of each datatype from datatypeinfo_list
              together with the corresponding environment from e_l_list
              and add it to env*)
      in
        (env,denv,spills @@ new_spills)
      end

  in
    case some_dec of
      Absyn.VALdec (non_rec_list, rec_list, _,_) =>
      let
        fun trans_valdec(non_rec_list, rec_list) =
          let
            fun trans_individual_dec(pattern, lambda_var, location) =
            case pattern of
              Absyn.WILDpat _ => (true, true, Environ.empty_env, empty_denv, [],
                                RuntimeEnv.NOVARINFO,
                                NONE)
            | Absyn.SCONpat (scon, ref ty) =>
                let
                  val dummy_lv = new_LVar()
                in
                  (false, false, Environ.empty_env, empty_denv,
                   [LambdaTypes.LETB
		      (dummy_lv,NONE,
                       LambdaTypes.SWITCH
			 (LambdaTypes.VAR lambda_var,
                          NONE,
                          [(LambdaTypes.SCON_TAG (scon, Types.sizeof ty),
                            LambdaTypes.VAR lambda_var)],
                          excp))],
                   RuntimeEnv.NOVARINFO,NONE)
                end
            | Absyn.VALpat ((longvalid as Ident.LONGVALID(path, valid),
                             stuff as (ref ty,ref (RuntimeEnv.RUNTIMEINFO (instance,_)))),_) =>
                (case valid of
                   Ident.VAR symbol =>
                     (case path of
                        Ident.NOPATH =>
                          ((true, true, Environ.add_valid_env(Environ.empty_env, (valid,
                              EnvironTypes.LAMB(lambda_var, EnvironTypes.NOSPEC))),
                            add_valid_denv(empty_denv, (valid,
                              EnvironTypes.NULLEXP)), [],
                            RuntimeEnv.VARINFO(Symbol.symbol_name symbol,
                                               stuff,NONE),
                            instance))
                      | Ident.PATH _ => Crash.impossible
                          "Long valid with non-empty path to trans_dec")
                 | Ident.CON _ =>
                     let
                       val dummy_lv = new_LVar()
                       val tag = #2(constructor_tag(valid, ty))
                       val one_con = TypeUtils.get_no_cons ty = 1
                     in
                       (false, one_con, Environ.empty_env, empty_denv,
                        [LambdaTypes.LETB(
                            dummy_lv,NONE,
                             LambdaTypes.SWITCH(
                                  LambdaTypes.VAR lambda_var,
                                   SOME{
                                    num_imms = TypeUtils.get_no_null_cons ty,
                                    num_vccs = TypeUtils.get_no_vcc_cons ty},
                                    [(LambdaTypes.IMM_TAG (valid_name valid,tag),
                                      LambdaTypes.VAR lambda_var)],
                                    if one_con then NONE else excp
                                      ))
                        ], RuntimeEnv.NOVARINFO, NONE)
                     end
                 | Ident.EXCON excon =>
                     let
                       val lexp = LambdaTypes.VAR lambda_var
                       val dummy_lv = new_LVar()
                     in
                       (false, false, Environ.empty_env, empty_denv,
                        [LambdaTypes.LETB(dummy_lv,NONE,
                                          LambdaTypes.SWITCH(
                                                             GetConTag lexp,
                                                             SOME{num_imms = 0,
                                                                            num_vccs = 0
                                                                            },
                                           [(LambdaTypes.EXP_TAG(#1(cg_longexid (longvalid, envir))),
                                                               GetConVal lexp)],
                                                             excp
                                                             ))],
                        RuntimeEnv.NOVARINFO,
                        NONE)
                     end
                 | _ => Crash.impossible "TYCON':VALpat:trans_individual_dec:lambda"
                   )
            | Absyn.RECORDpat(lab_pat_list, flex, ref ty) =>
                let
                  val big_list =
                    map (fn (lab, pat) =>
                         (pat, new_LVar(),
                          LambdaTypes.SELECT(record_label_offset(lab,ty,error_info,location),
                                             LambdaTypes.VAR lambda_var)))
                    lab_pat_list
                  val env_list_lambda_list_list =
                    map
                    (fn (pat, lv, le) =>
                     let
                       val (has_vars, exhaustive, env, denv, lambda_list,debug_info,instance) =
                         trans_individual_dec(pat,lv, location)
                     in
                       (has_vars, exhaustive, env, denv,
                        make_binding (lv,debug_info,instance,le,"",location)
                        @@ lambda_list)
                     end)
                    big_list
                in
                  (Lists.exists (fn (has_vars, _, _, _, _) => has_vars)
                   env_list_lambda_list_list,
                   Lists.forall (fn (_, exhaustive, _, _, _) => exhaustive)
                   env_list_lambda_list_list,
                   Lists.reducel (fn (env, (_, _, env', _, _)) =>
                                  Environ.augment_env(env, env'))
                   (Environ.empty_env, env_list_lambda_list_list),
                   Lists.reducel (fn (env, (_, _, _, env', _)) =>
                                  augment_denv(env, env'))
                   (empty_denv, env_list_lambda_list_list),
                   Lists.reducel
                   (fn (l1, (_, _, _, _, l2)) => l1 @@ l2)
                   ([], env_list_lambda_list_list),RuntimeEnv.NOVARINFO,
                   NONE)
                end
            | Absyn.APPpat((longvalid, ref ty), pat,_,_) =>
                (case longvalid of
                   Ident.LONGVALID(_, Ident.VAR _) =>
                     Crash.impossible"APPpat of Ident.VAR"
                 | Ident.LONGVALID(_, valid as Ident.CON con) =>
                     (case Environ.FindBuiltin(longvalid, envir) of
			SOME Pervasives.REF =>
			  let
			    val new_lv = new_LVar()
			    val (has_vars, exhaustive, new_env, new_denv, new_lambda_exp,
				 debug_info,instance) =
			      trans_individual_dec(pat, new_lv, location)
			    val lexp = LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
						       ([LambdaTypes.VAR lambda_var],[]),
						       NONE)
			  in
			    (has_vars, exhaustive, new_env, new_denv,
			     make_binding(new_lv,debug_info,instance,lexp,
					  "Dereferencing a pattern",location)
			     @@ new_lambda_exp,RuntimeEnv.NOVARINFO,
			     NONE)
			  end
		      | _ =>
			  if TypeUtils.get_no_cons ty = 1 then
			    trans_individual_dec(pat, lambda_var, location)
			  else
			    let
			      val new_lv = new_LVar()
			      val (has_vars, _, new_env, new_denv, new_lambda_exp,
				   debug_info,instance) =
				trans_individual_dec(pat, new_lv,location)
			      val lexp = LambdaTypes.VAR lambda_var
			      val tag = #2(constructor_tag(valid, ty))
			      val lexp =
				LambdaTypes.SWITCH
				(lexp,
				 SOME
				 {num_vccs = TypeUtils.get_no_vcc_cons ty,
				  num_imms = TypeUtils.get_no_null_cons ty
				  },
				 [(LambdaTypes.VCC_TAG (valid_name valid,tag),
				   if is_list_type (TypeUtils.get_cons_type ty) then
				     lexp
				   else
				     GetConVal lexp
				     )],
				 if TypeUtils.get_no_cons ty <> 1 then
				   excp (* is a tag, but not the right one *)
				 else
				   NONE)
			    in
			      (has_vars, false, new_env, new_denv,
			       make_binding(new_lv, debug_info,
					    instance,lexp,"", location)
			       @@ new_lambda_exp,RuntimeEnv.NOVARINFO,
			       NONE)
			    end)

                 | Ident.LONGVALID(_, Ident.EXCON excon) =>
                     let
                       val new_lv = new_LVar()
                       val (has_vars, _, new_env, new_denv, new_lambda_exp,
                            debug_info,instance) =
                         trans_individual_dec(pat, new_lv,location)
                       val lexp = LambdaTypes.VAR lambda_var
                       val lexp = LambdaTypes.SWITCH(
                                                     GetConTag lexp,
                                                     SOME
						       {num_imms = 0,
                                                        num_vccs = 0},
                                           [(LambdaTypes.EXP_TAG(#1(cg_longexid(longvalid, envir))),
                                                              GetConVal lexp)],
                                                            excp
                                                            )
                     in
                       (has_vars, false, new_env, new_denv, (* Never exhaustive *)
                        make_binding(new_lv,debug_info,instance,lexp,"",
                                     location)
                           @@ new_lambda_exp,
                        RuntimeEnv.NOVARINFO,
                        NONE)
                     end
                 | _ => Crash.impossible "TYCON':APPpat:trans_individual_dec:lambda"
                   ) (* end of case longvalid *)
            | Absyn.TYPEDpat(typed, _,_) =>
                    trans_individual_dec(typed, lambda_var, location)
            (* Just ignore the type here *)
            | Absyn.LAYEREDpat((valid, stuff as (ref ty,ref (RuntimeEnv.RUNTIMEINFO (instance,_)))), pat) =>
                (case valid of
                   Ident.VAR vid =>
                     let
                       val (_, exhaustive, env, denv, lambda,_,_) =
                         trans_individual_dec(pat, lambda_var, location)
                     in
                       (true, exhaustive, Environ.add_valid_env(env,
                                                   (valid, EnvironTypes.LAMB(lambda_var, EnvironTypes.NOSPEC))),
                        add_valid_denv(denv, (valid, EnvironTypes.NULLEXP)),
                        lambda,RuntimeEnv.VARINFO (Symbol.symbol_name vid,stuff,NONE),
                        instance)
                     end
                 | _ => Crash.impossible "LAYEREDpat with non-VAR valid")
          in
            (* This stuff needs redoing to be tail recursive over the first list *)
            case (non_rec_list, rec_list) of
              ((pat, exp, location) :: tl, _) =>
                let
                  val lvar = new_LVar()
                  val (has_vars, exhaustive, more_env, more_denv, more_lambda,debug_info,instance) =
                    trans_individual_dec(pat,lvar, location)
                  val _ =
                    if exhaustive orelse is_toplevel then ()
                    else
                      Info.error error_info (Info.WARNING, location, "Binding not exhaustive")
                  val _ =
                    if has_vars orelse is_toplevel then ()
                    else
                      (Info.error error_info (Info.WARNING, location, "Binding has no variables");
		       (if exhaustive then ()
			else
			  Info.error error_info (Info.WARNING, location,
                                                 "Possible attempt to rebind constructor name")))

                  val _ = null_tyfun_spills (denvir,debug_info)
                  val lambda = trans_exp(" pattern", exp, envir, denvir, fnname)
                  val (more_env, more_denv, updated) =
                    case (pat, lambda) of
                      (* What is this clause about ? *)
                      (* Patthern is x = builtin *)
                      (Absyn.VALpat((Ident.LONGVALID(Ident.NOPATH,valid as Ident.VAR _), _),_),
                       LambdaTypes.BUILTIN prim) =>
                      (Environ.add_valid_env(more_env, (valid,EnvironTypes.PRIM prim)),
                       add_valid_denv(more_denv, (valid,EnvironTypes.NULLEXP)),
                       true)
                     | _ => (more_env, more_denv, false)

                  val _ = map
                    (fn LambdaTypes.LETB(_,SOME(ref debug_info),_) =>
                     null_tyfun_spills (denvir,debug_info)
                  | _ => ()) more_lambda

                  val (rest_env, rest_denv, rest_lambda) = trans_valdec(tl,rec_list)

                  val new_bindings = more_lambda @@ rest_lambda
                in
                 (Environ.augment_env(more_env, rest_env),
                  augment_denv(more_denv, rest_denv),
                   (if updated then
                      new_bindings
                    else
                      make_binding(lvar,debug_info,instance,lambda,"",
                                   location)
                      @@ new_bindings))
                end
            | ([], []) => (Environ.empty_env, empty_denv, [])
            | ([], rec_list) =>
                let
                  val lv_pat_exp_list =
                    if variable_debug
                      then
                        map
                        (fn (pat, exp, location) =>
                         let
                           val new_lv = new_LVar()
                         in
                           ((new_lv,SOME (ref RuntimeEnv.NOVARINFO)),pat, exp, location)
                         end)
                        rec_list
                    else
                      map
                      (fn (pat, exp, location) =>  ((new_LVar(),NONE), pat, exp, location))
                      rec_list
                  (* Assign lambda_var to each expression, pattern pair *)
                  val env_le_list = map
                    (fn ((lv,SOME varinfo_ref), pat, _, location) =>
                     let
                       val (has_vars, exhaustive, env, denv, le, debug_info,instance) =
                         trans_individual_dec(pat,lv,location)
                       val _ =
                         (* Update the varinfo for this variable *)
                         (varinfo_ref := debug_info;
                          if exhaustive then ()
                          else
                            Info.error error_info (Info.WARNING, location,
                                                   "Binding not exhaustive"))
                       val _ =
                         if has_vars then ()
                         else
                           Info.error error_info (Info.WARNING, location,
                                                  "Binding has no variables")
                     in
                       (env,denv,lv,debug_info,instance,location)
                     end
                  | ((lv,NONE), pat, _, location) =>
                     let
                       val (has_vars, exhaustive, env, denv, le, debug_info,instance) =
                         trans_individual_dec(pat,lv,location)
                       val _ =
                          if exhaustive then ()
                          else
                            Info.error error_info (Info.WARNING, location,
                                                   "Binding not exhaustive")
                       val _ =
                         if has_vars then ()
                         else
                           Info.error error_info (Info.WARNING, location,
                                                  "Binding has no variables")
                     in
                       (env,denv,lv,debug_info,instance,location)
                     end)
                    lv_pat_exp_list
                  (* The exp parts resulting from this should be null *)
                  val all_env =
                    Lists.reducel Environ.augment_env (Environ.empty_env, map #1 env_le_list)
                  val all_denv =
                    Lists.reducel augment_denv (empty_denv, map #2 env_le_list)
                  (* Produce the environment including the new functions *)
                  val trans_env = Environ.augment_env(envir, all_env)
                  val trans_denv = augment_denv(denvir, all_denv)
                  fun pat_name (Absyn.VALpat ((Ident.LONGVALID (_, valid), _),_)) = valid_name valid
                    | pat_name (Absyn.WILDpat _) = "<wild>"
                    | pat_name (Absyn.LAYEREDpat ((valid, _), pat)) =
                      (case pat_name pat of
                         "<wild>" => valid_name valid
                       | name => name)
                    | pat_name (Absyn.TYPEDpat (pat,_,_)) = pat_name pat
                    | pat_name _ = Crash.impossible"Bad pat name in val rec"
                  val recletb =
                    [LambdaTypes.RECLETB(map #1 lv_pat_exp_list,
                                         map
                                         (fn (pat,exp,_) =>
                                          trans_exp(pat_name pat, exp, trans_env,
                                                    trans_denv, fnname))
                                         rec_list)]
                in
                  (all_env, all_denv, recletb)
                end
          end
      in
        trans_valdec(non_rec_list, rec_list)
      end

    | Absyn.TYPEdec typeinfo_list =>
        let
          val old_null_tyfun_spills = store_null_tyfun_spills()
          val (env, denv, spills) =
            (init_null_tyfun_spills();
             TYPEdec_spills denvir typeinfo_list (Environ.empty_env, empty_denv, nil))
          val _ = restore_null_tyfun_spills old_null_tyfun_spills
        in
          (env, denv, spills)
        end

    | Absyn.DATATYPEdec (_,datatypeinfo_list) =>
        do_datatypeinfo_list datatypeinfo_list

        (* the typechecker should have set the "constructors" field of
           the DATATYPErepl abstract syntax to point to the type environment
           of the original datatype replication. The following code simply
           uses this information to reconstruct a list of constructor bindings
           which will then be passed directly to the datatype handling routine
           "do_datatypeinfo_list". *)

    | Absyn.DATATYPErepl (location,(tycon,longtycon),constructors) =>
        let val Datatypes.VE(intRef,nameToTypeMap) = valOf (!constructors)
              handle Option => Crash.impossible 
                                  "replicating datatype with no constructors"

            fun makeConbinds nameToTypeMap =
              (* map lists of (Ident.ValId * Datatypes.Typescheme)
                 to lists of ((Ident.ValId * Absyn.Type ref) * Absyn.Ty option)
                 (Absyn.Ty option never seems to be used here.) *)
              
              map (fn (valid,Datatypes.SCHEME(_,(ty,_))) => 
                                                        ((valid,ref ty),NONE)
                    | (valid,Datatypes.UNBOUND_SCHEME(ty,_)) =>
                                                        ((valid, ref ty),NONE)
                    | _ => Crash.impossible 
                                    "constructors with overloaded typescheme")
                  (NewMap.to_list_ordered nameToTypeMap)
              
         in
           (* give empty tyvar list: they're ignored by the function anyway.*)

           do_datatypeinfo_list [([],tycon,ref Absyn.nullType,NONE,
                                  makeConbinds nameToTypeMap)]
        end



    | Absyn.ABSTYPEdec (_,datatypeinfo_list, dec) =>
        let
          val (env,denv,spills) = do_datatypeinfo_list datatypeinfo_list
          val (env',denv',spills') = trans_dec(dec, envir, false, denvir, fnname)
        in
          (Environ.augment_env (env,env'),
           augment_denv (denv,denv'),
           spills @@ spills')
        end

    | Absyn.EXCEPTIONdec except_list =>
      (* Generate a lambda lv bound to (APP(ref, unit), name), and put it in
	 the value environment.  Uses of ths identifier in expressions will
         be replaced by either FN(l', STRUCT(lv, VAR(l'))) or
	 STRUCT(lv, STRUCT()) according to whether or not the exception
	 carries a value. *)
      let
	fun make_exbind_info(loc, old_name, Ident.EXCON sym) =
	  let
	    val sym_string = Symbol.symbol_name sym
	  in
	    case loc of
	        Location.UNKNOWN => old_name
	    | _ =>
		let
		  val file_loc = OS.Path.file (Location.to_string loc)
		in
		  concat [sym_string, "[", file_loc, "]"]
		end
		
	  end
	  | make_exbind_info _ = Crash.impossible "Not an excon in an exbind"

	fun do_exns([], env, denv, lambdas) =
	  (env, denv, Lists.reducel (fn (x, y) => y @@ x) ([], lambdas))
	  | do_exns(ex :: exns, env, denv, lambdas) =
	  let
	    val lv = new_LVar()

	    val (v, ty, loc, exception_name) = case ex of
	      Absyn.NEWexbind((v, ref ty), _,loc,n) => (v, ty, loc, n)
	    | Absyn.OLDexbind((v, ref ty), longv,loc,n) => (v, ty, loc, n)

	    val exn_string = make_exbind_info(loc, exception_name, v)

	    val (this_lambda,longstrid) =
	      let
		val _ =
                  (* Please,please, always generate debug info for exceptions *)
                  (* Add exception info to global debugger_env *)
                  debugger_env_ref :=
                    Debugger_Types.add_debug_info
                    (!debugger_env_ref,
                     exn_string,
                     Debugger_Types.FUNINFO {ty = ty,
                                             is_leaf = false,
					     has_saved_arg=false,
                                             annotations = [],
                                             runtime_env = Debugger_Types.empty_runtime_env,
                                             is_exn = true})

		val (lambda_exp,longstrid) =
		  let
		  in
		    case ex of
		      Absyn.NEWexbind _ =>
                      (* nosa 02/94
                         Bind new exception to strdec dec-exception locally bound to redundancy-checker;
                         Possibly redundant exception in LAMB for absolute exception constructor code
                         in dynamic redundancy checker
                       *)
                        let
                          val lvar = new_LVar()
                        in
                          (redundant_exceptions_ref := (lvar,exn_string)::(!redundant_exceptions_ref);
                           (LambdaTypes.STRUCT
                            ([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                              ([unit_exp],[]),
                                              NONE),
                            LambdaTypes.SCON(Ident.STRING exn_string, NONE)],
                            LambdaTypes.CONSTRUCTOR),
                            EnvironTypes.VARSPEC lvar))
                        end
		    | Absyn.OLDexbind(_, longv,_,_) =>
                        let
                          val (exp, longstrid) = cg_longexid(longv, envir)
                        in
                          (LambdaTypes.STRUCT
                           ([select_exn_unique exp,
                             LambdaTypes.SCON(Ident.STRING exn_string, NONE)],
                            LambdaTypes.CONSTRUCTOR),
                           longstrid)
                        end
		  end
	      in
		([LambdaTypes.LETB(lv, NONE,lambda_exp)],
                 longstrid)
	      end

	    val this_env =
	      Environ.add_valid_env (Environ.empty_env,
				     (v, EnvironTypes.LAMB(lv,longstrid)))
	    val this_denv =
	      add_valid_denv (empty_denv,(v, EnvironTypes.NULLEXP))

	  in
	    do_exns(exns, Environ.augment_env(env, this_env),
                    augment_denv(denv, this_denv),
	    	    this_lambda :: lambdas)
	  end
      in
	do_exns(except_list, Environ.empty_env, empty_denv, [])
      end

(** Find the translation for the first DEC in the environment passed,
    and then, the translation of the second in the environment after
    the first.  Since the trans_dec function takes an environment in
    which to perfom the translation, this is trivial.
    The preceding comment is crap unfortunately. We must translate dec2
    in the original environment augmented by the environment generated
    by translating dec1, but must return
    the environment produced only by the translation of dec2 (ie the
    environment from translating dec1 must not be visible externally.)
**)
    | Absyn.LOCALdec (dec1, dec2) =>
      let
	val (local_env, local_denv, local_lambda) = trans_dec(dec1, envir, false, denvir, fnname)
	val (main_env, main_denv, main_lambda) =
	  trans_dec(dec2, Environ.augment_env(envir, local_env), false,
                    augment_denv(denvir, local_denv), fnname)
      in
	(main_env, main_denv, local_lambda @@ main_lambda)
      end
    | Absyn.OPENdec (longStrId_list,_) =>
      (* Lookup each LongStrId in the env, bind a set of new lambda variables,
         one per valid in the new env, to expressions SELECT(field, lexp),
	 where lexp is the lambda expression corresponding to the LongStrId,
	 (which may have some field selection if the LongStrId goes more
	 than one level down) and return an environment of the valids and
	 these lambda variables, and a lvar, lexp list of the lambda
	 variables and the field selections.
       *)
       let
	 fun trans_open([], new_env, new_denv, new_lambdas) = (new_env, new_denv, new_lambdas)
	 | trans_open(longstrid :: tl, new_env, new_denv, new_lambdas) =
	   let
	     val (env as EnvironTypes.ENV(valid_env, strid_env),
		  lambda_exp, longstrid', _) =
	       cg_longstrid(longstrid, envir)
             val new_denv =
               if generate_moduler then
                 open_debugger_env (cg_longstrid'(longstrid, denvir), new_denv)
               else new_denv
	     val valid_map' = NewMap.to_list valid_env
	     val valid_map = map (fn (v, c) => (v, c, new_LVar())) valid_map'
             val strid_map' = NewMap.to_list strid_env
	     val strid_map = map
	       (fn (s, ec) => (s, ec, new_LVar())) strid_map'
             (* Full paths in LAMBs for absolute exception constructor code *)
             (* in dynamic redundancy checker *)

             val longstrid' =
               case (longstrid',longstrid) of
                 (EnvironTypes.STRIDSPEC (Ident.LONGSTRID(p,Ident.STRID s)), Ident.LONGSTRID(p',s')) =>
                   EnvironTypes.STRIDSPEC (Ident.LONGSTRID(combine_paths (p,combine_paths (Ident.PATH(s,Ident.NOPATH),p')),s'))
                | (EnvironTypes.NOSPEC,longstrid) => EnvironTypes.STRIDSPEC  longstrid
                | _ => Crash.impossible "longstrid':trans_open:lambda"

             fun identity_if_builtin (x as EnvironTypes.PRIM _,_) = x
               | identity_if_builtin (_,y) = EnvironTypes.LAMB(y,longstrid')
	     val new_v_env = Lists.reducel
	       (fn (env, (v, x, l)) =>
		Environ.add_valid_env(env, (v, identity_if_builtin(x,l))))
	       (new_env, valid_map)
	     val new_s_env = Lists.reducel
	       (fn (env, (s, (e, c, generate_moduler), l)) =>
		Environ.add_strid_env(env, (s, (e, EnvironTypes.LAMB(l,longstrid'), generate_moduler))))
	       (new_v_env, strid_map)

	     val new_v_lambdas =
               map
	       (fn (_, EnvironTypes.FIELD field, l) =>
		LambdaTypes.LETB (l, NONE,LambdaTypes.SELECT(make_struct_select field, lambda_exp))
                 | (_, EnvironTypes.PRIM prim, l) =>
                     LambdaTypes.LETB (l,NONE,LambdaTypes.BUILTIN prim)
                 | _ => Crash.impossible "Absyn.OPENdec(1)")
               valid_map
	     val new_s_lambdas = map
	       (fn (_, (_, EnvironTypes.FIELD field, _), l) =>
		LambdaTypes.LETB(l,NONE, LambdaTypes.SELECT(make_struct_select field, lambda_exp))
             | (_, (_, EnvironTypes.PRIM prim, _), l) =>
                 LambdaTypes.LETB(l, NONE,LambdaTypes.BUILTIN prim)
	       | _ => Crash.impossible "Absyn.OPENdec(2)"
		   ) strid_map
	   in
	     trans_open(tl, new_s_env, new_denv,
			new_v_lambdas @@ new_s_lambdas @@ new_lambdas)
	   end
       in
	 trans_open(longStrId_list, Environ.empty_env, empty_denv, [])
       end

(** Using trans_dec translate each declaration given into the proper
    form, in the environment of all the names being passed to it.
    Each declaration is translated with the environment of all
    previous declarations done to date.  At the end we return this
    full environment.  **)
    | Absyn.SEQUENCEdec dec_list =>
	trans_sequence_dec(envir, Environ.empty_env, denvir, empty_denv,
                           [], dec_list, is_toplevel, fnname)
  end

  and trans_sequence_dec(_, new_env, _, new_denv, bindings, [], _, _) =
      (new_env, new_denv, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
    | trans_sequence_dec(old_env, new_env, old_denv, new_denv,
                         bindings, dec :: dec_list, is_toplevel, fnname) =
      let
	val (env, denv, lambda) = trans_dec (dec, old_env, is_toplevel, old_denv, fnname)
      in
	trans_sequence_dec(Environ.augment_env(old_env, env),
			   Environ.augment_env(new_env, env),
                           augment_denv(old_denv, denv),
			   augment_denv(new_denv, denv),
			   lambda :: bindings, dec_list, is_toplevel, fnname)
      end

  fun wrapped_trans_dec (dec, env, is_toplevel, denv, fnname) =
      (* Bind new exception locally to Dynamic redundancy checker for toplevel struct;
         Generate Dynamic redundancy checker.
         Also for the Modules Debugger bind any global lambda variables formed from
         functor parameters
       *)
    (tyfun_lvars_ref := []; (* Reset global ref *)
     dexps_ref := []; (* Reset global ref *)
     redundant_exceptions_ref := []; (* Reset global ref *)
     let
       val (env, denv, dec_bindings) = trans_dec(dec, env, is_toplevel, denv, fnname)
       val tfs_bindings =
         map (fn (_,(lvar,lexp)) =>
              LambdaTypes.LETB(lvar,NONE, lexp))
         (!tyfun_lvars_ref)
       val dexp_bindings =
         map (fn (_,(lvar,lexp)) =>
              LambdaTypes.LETB(lvar,NONE, lexp))
         (!dexps_ref)
       val redundant_exn_bindings =
         map (fn (lvar,exn_string) =>
              LambdaTypes.LETB(lvar,NONE,
                               LambdaTypes.STRUCT
                               ([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                 ([unit_exp],[]),
                                                 NONE),
                               LambdaTypes.SCON(Ident.STRING exn_string, NONE)],
                               LambdaTypes.CONSTRUCTOR)))
         (!redundant_exceptions_ref)
       val bindings =
         let
           val exp = (!dynamic_redundancy_report_ref) unit_exp
           val _ = dynamic_redundancy_report_ref := (fn exp => exp)
         in
           case exp of
             LambdaTypes.STRUCT([],_) => dec_bindings
           | dynamic_report =>
               LambdaTypes.LETB(new_LVar(),NONE,
                                dynamic_report) :: dec_bindings
         end
     in
       (env, denv,
        tfs_bindings @@
        dexp_bindings @@
        redundant_exn_bindings @@
        bindings)
     end)

  fun trans_str_exp (strexp, top_env as EnvironTypes.TOP_ENV(env, fun_env),denv, fnname) =
    case strexp of
      Absyn.NEWstrexp strdec =>
        let
          val (env, denv, lv_le_list) = trans_str_dec(strdec, top_env, denv, false, fnname)
          val (EnvironTypes.TOP_ENV(env, _), lambda_exp) =
            complete_struct_from_topenv(make_top_env env, lv_le_list)
        in
          (env, lambda_exp, EnvironTypes.DENVEXP denv)
        end
    | Absyn.OLDstrexp (longstrid,_,interface) =>
        let
          val (env, lexp, _, moduler_generated) = cg_longstrid(longstrid, env)
          val ((strexp, env), dstrexp) =
            case (moduler_generated,generate_moduler) of
              (true,false) =>
                (strip_tyfuns (lexp,env),
                 empty_dstrexp)
            | (false,true) =>
                let
                  val interface = fetch_interface interface
                in
                  (include_tyfuns (lexp,interface,env),
                   make_dstrexp interface)
                end
            | (true,true) =>
                ((lexp, env),
                 cg_longstrid'(longstrid, denv))
            | (false,false) => ((lexp, env), empty_dstrexp)
        in
          (env, strexp, dstrexp)
        end

    | Absyn.APPstrexp(funid as Ident.FUNID sy, strexp, coerce, location, debugger_str) =>
        let
          val (lv, result_env as EnvironTypes.ENV(valid_env, strid_env), moduler_generated) =
            Environ.lookup_funid(funid, fun_env)
          val old_functor_refs = !functor_refs
          val _ = functor_refs := []
          val (env, arg, dstrexp) = trans_str_exp(strexp, top_env, denv, fnname)
          val Basis.BasisTypes.PHI (_, (interface, Basis.BasisTypes.SIGMA(_,interface'))) =
            Basis.lookup_funid (funid, basis)
            handle NewMap.Undefined =>
              Crash.impossible "Undefined functor id in trans_str_exp"

          val (new_env, new_arg) =
            complete_struct((env, arg), SOME interface, !coerce, generate_moduler)

          val dlvar = new_LVar()
          val new_arg =
            if generate_moduler then
              (** create unique functor application refs for debugger structure returns
               for modules debugger **)
              let_lambdas_in_exp
              (map (fn (ref (EnvironTypes.LVARFOO lv),interface) =>
                    LambdaTypes.LETB(lv,NONE,
                                     LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                     ([str_to_lambda interface],[]),
                                                     NONE))
            | _ => Crash.impossible "1:INTFOO:functor_refs:lambda")
              (!functor_refs),
              (functor_refs := old_functor_refs;
               LambdaTypes.STRUCT([new_arg,
                                   dstrexp_to_lambda(merge_dstrexps (fetch_debugger_str debugger_str,
                                                                     SOME interface,dstrexp,
                                                                     location)),
                                   LambdaTypes.VAR dlvar],
               LambdaTypes.TUPLE)))
            else
              new_arg
          val functorexp =
            LambdaTypes.APP(
                            case lv of
                              EnvironTypes.LAMB (lv,_) => LambdaTypes.VAR lv
                            | EnvironTypes.EXTERNAL =>
                                LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_FUNCT,
                                                ([LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],[]),
                                                NONE)
                            | EnvironTypes.PRIM _ => Crash.impossible "APPstrexp(1)"
                            | EnvironTypes.FIELD _ => Crash.impossible "APPstrexp(2)",
                           ([new_arg],[]),
                            NONE)
          (* Should this be binding result_env? *)
          val ((functorexp, env), dfunctorexp) =
            case (moduler_generated,generate_moduler) of
              (** compatibility considerations for modules debugger **)
              (true,false) =>
                (strip_tyfuns (functorexp,result_env),
                 empty_dstrexp)
            | (false,true) =>
                (functor_refs := (ref (EnvironTypes.LVARFOO dlvar),interface')::(!functor_refs);
                 (include_tyfuns (functorexp,interface',result_env),
                  make_dstrexp interface'))
            | (true,true) =>
                let
                  val dlvar = ref (EnvironTypes.LVARFOO dlvar)
                in
                  (functor_refs := (dlvar,interface')::(!functor_refs);
                   (* Making a LAMBDASTREXP' *)
                   ((functorexp, env),
                    EnvironTypes.LAMBDASTREXP' ([],dlvar,interface')))
                end
            | (false,false) => ((functorexp, env), empty_dstrexp)
        in
          (result_env, functorexp, dfunctorexp)
        end
    | Absyn.LOCALstrexp(strdec, strexp) =>
        let
          val (local_env, local_denv, local_lambdas) =
            trans_str_dec(strdec, top_env, denv, false, fnname)
          val (new_env, new_lambda, new_dexp) =
            trans_str_exp(strexp,
                          Environ.augment_top_env(top_env, make_top_env local_env),
                          augment_denv (denv, local_denv),
                          fnname)
        in
          (new_env,
           let_lambdas_in_exp(local_lambdas, new_lambda),
           new_dexp)
        end
    | Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,coerce,location) =>
        let
          val inte_opt = SOME (interface_from_sigexp sigexp)
          val (str_env, lambda_exp, dstrexp) =
            trans_str_exp(strexp, top_env, denv, fnname)
          val (str_env, lambda_exp) =
            complete_struct((str_env, lambda_exp),
			    inte_opt,
			    !coerce, generate_moduler)
        in
          (str_env,lambda_exp,dstrexp)
        end

  and trans_str_dec(strdec, top_env as EnvironTypes.TOP_ENV(env, _),
                    denv, is_toplevel, fnname) =
  case strdec of
    Absyn.DECstrdec dec => wrapped_trans_dec (dec, env, is_toplevel, denv, fnname)
  | Absyn.STRUCTUREstrdec struct_dec_list =>
    (case struct_dec_list of
      [] => (Environ.empty_env, empty_denv, [])
    | _ =>
    let
      fun trans_structs(aug_env, aug_denv, bindings, []) = (aug_env, aug_denv, rev bindings)
      | trans_structs(aug_env, aug_denv, bindings,
		      (strid, sigexp_opt, strexp, coerce, location, debugger_str, interface') :: rest) =
        let
          val inte_opt = case sigexp_opt of
	    NONE => NONE
          | SOME (sigexp,_) =>
	      SOME (interface_from_sigexp sigexp)
          val (str_env, lambda_exp, dstrexp) =
            trans_str_exp(strexp, top_env, denv, fnname)
          val (str_env, lambda_exp) =
            complete_struct((str_env, lambda_exp),
			    inte_opt,
			    !coerce, generate_moduler)
          val lambda_var = new_LVar()
        in
	  trans_structs
          (Environ.add_strid_env(aug_env,
				 (strid, (str_env,
					  EnvironTypes.LAMB (lambda_var,EnvironTypes.NOSPEC),generate_moduler))),
           if generate_moduler then
             add_strid_denv(aug_denv,
              (strid, merge_dstrexps (fetch_debugger_str debugger_str,
                                      SOME(fetch_interface interface'),dstrexp, location)))
           else aug_denv,
            LambdaTypes.LETB(lambda_var,NONE,lambda_exp)
            :: bindings, rest)
        end
    in
      trans_structs(Environ.empty_env, empty_denv, [], struct_dec_list)
    end)
  | Absyn.ABSTRACTIONstrdec struct_dec_list =>
    (* cut and paste from above *)
    (* so that's what they mean by "reusability" *)
    (case struct_dec_list of
      [] => (Environ.empty_env, empty_denv, [])
    | _ =>
    let
      fun trans_structs(aug_env, aug_denv, bindings, []) = (aug_env, aug_denv, rev bindings)
      | trans_structs(aug_env, aug_denv, bindings,
		      (strid, sigexp_opt, strexp, coerce, location, debugger_str, interface') :: rest) =
        let
          val inte_opt = case sigexp_opt of
	    NONE => NONE
          | SOME (sigexp,_) =>
	      SOME (interface_from_sigexp sigexp)
          val (str_env, lambda_exp, dstrexp) =
            trans_str_exp(strexp, top_env, denv, fnname)
          val (str_env, lambda_exp) =
            complete_struct((str_env, lambda_exp),
			    inte_opt,
			    !coerce, generate_moduler)
          val lambda_var = new_LVar()
        in
	  trans_structs
          (Environ.add_strid_env(aug_env,
				 (strid, (str_env,
					  EnvironTypes.LAMB(lambda_var,EnvironTypes.NOSPEC),generate_moduler))),
           if generate_moduler then
             add_strid_denv(aug_denv,
              (strid, merge_dstrexps (fetch_debugger_str debugger_str,
                                      SOME(fetch_interface interface'),dstrexp, location)))
           else aug_denv,
            LambdaTypes.LETB(lambda_var, NONE,lambda_exp)
            :: bindings, rest)
        end
    in
      trans_structs(Environ.empty_env, empty_denv, [], struct_dec_list)
    end)
  | Absyn.LOCALstrdec(strdec1, strdec2) =>
    let
      val (local_env, local_denv, local_lambda) =
        trans_str_dec(strdec1, top_env, denv, false, fnname)
      val (main_env, main_denv, main_lambda) =
	trans_str_dec
	  (strdec2,
	   Environ.augment_top_env(top_env, make_top_env local_env),
	   augment_denv(denv, local_denv), false,
	   fnname)
    in
      (main_env, main_denv, local_lambda @@ main_lambda)
    end

  | Absyn.SEQUENCEstrdec strdec_list =>
      trans_sequence_strdec(top_env, Environ.empty_env,
                            denv, empty_denv, [], strdec_list, is_toplevel, fnname)

  and trans_sequence_strdec(_, new_env, _, new_denv, bindings, [], _, _) =
      (new_env, new_denv, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
    | trans_sequence_strdec
	(old_env, new_env, old_denv, new_denv, bindings, decs :: dec_list, is_toplevel, fnname) =
      let
	val (env, denv, new_bindings) = trans_str_dec(decs, old_env, old_denv, is_toplevel, fnname)
      in
	trans_sequence_strdec(Environ.augment_top_env
			        (old_env, make_top_env env),
			      Environ.augment_env(new_env, env),
                              augment_denv(old_denv, denv),
                              augment_denv(new_denv, denv),
			      new_bindings :: bindings, dec_list,
			      is_toplevel, fnname)
      end

  fun trans_individual_funbind
        (funbind as
	   (funid, strid, sigexp, strexp, sigexp_opt,
            annotation_string, coerce, location, debugger_str, str),
         top_env as EnvironTypes.TOP_ENV(env, fun_env),
         top_denv) =
    let
      val interface = interface_from_sigexp sigexp
      val env = Environ.make_str_env (interface,generate_moduler)
      val lvar' = new_LVar()
      val lvar = new_dLVar lvar'
      val lvar'' = new_dLVar lvar'
      val lvar''' = new_dLVar lvar'
      val inte_opt = case sigexp_opt of
	NONE => NONE
      | SOME (sigexp,_) =>
	  SOME (interface_from_sigexp sigexp)

      val old_functor_refs = !functor_refs
      val _ = functor_refs := []
      val (str_env, lambda_exp, dstrexp) =
        trans_str_exp
	 (strexp,
	  Environ.augment_top_env
	  (top_env,
	   make_top_env(Environ.add_strid_env(Environ.empty_env,
					      (strid,
					       (env,
						EnvironTypes.LAMB(lvar',EnvironTypes.NOSPEC),
                                                generate_moduler))))),
          augment_denv
          (top_denv,
           if generate_moduler then
             let
               val str = fetch_interface str
             in
             add_strid_denv(empty_denv,
                            (strid,
                             EnvironTypes.LAMBDASTREXP([],(lvar'',lvar'),str)))
             end
           else empty_denv),
          NONE)

      val (str_env, lambda_exp) =
	complete_struct	((str_env, lambda_exp),
                         inte_opt,
                         !coerce, generate_moduler)
      val lambda_var = new_LVar()
      val lambda_var' = new_dLVar lambda_var
      val dstrexp =
        if generate_moduler then
          merge_dstrexps (fetch_debugger_str debugger_str,inte_opt,dstrexp, location)
        else empty_dstrexp

      val lambda_exp =
        if generate_moduler then
         LambdaTypes.LET((lvar',NONE,
          LambdaTypes.SELECT({index=0,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR lvar)),
            LambdaTypes.LET((lvar'',NONE,
               LambdaTypes.SELECT({index=1,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR lvar)),
            LambdaTypes.LET((lvar''',NONE,
               LambdaTypes.SELECT({index=2,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR lvar)),
            (** create unique functor application refs for debugger structure returns **)
            let_lambdas_in_exp(map (fn (ref (EnvironTypes.LVARFOO lv),interface) =>
                                    LambdaTypes.LETB(lv,NONE,
                                                     LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                                     ([str_to_lambda interface],[]),
                                                                     NONE))
                                     | _ => Crash.impossible "2:INTFOO:functor_refs:lambda")
            (!functor_refs),
                             (functor_refs := old_functor_refs;
                              LambdaTypes.LET((lambda_var',NONE,lambda_exp),
                               LambdaTypes.LET((new_LVar(),NONE,
                                                LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.BECOMES,
                                                                ([LambdaTypes.STRUCT([LambdaTypes.VAR lvar''',
                                                                                     dstrexp_to_lambda dstrexp],
                                                                LambdaTypes.TUPLE)],
                                                                 []),
                                                                NONE)),
                                              LambdaTypes.VAR lambda_var')))))))
        else
          lambda_exp
    in
     (EnvironTypes.TOP_ENV
       (Environ.empty_env,
	Environ.add_funid_env
	(Environ.empty_fun_env,
	 (funid,
	  (EnvironTypes.LAMB(lambda_var,EnvironTypes.NOSPEC),  str_env, generate_moduler)))),
       empty_denv,
       [LambdaTypes.LETB(lambda_var,NONE,
                         LambdaTypes.FN(([lvar],[]), lambda_exp, LambdaTypes.FUNC,annotation_string,
                                        LambdaTypes.null_type_annotation,RuntimeEnv.USER_FUNCTION))])
    end

  fun trans_fun_dec([], _, _) = (make_top_env Environ.empty_env,
                                 empty_denv, [])
    | trans_fun_dec(funbind :: rest, top_env, top_denv) =
      let
        val (new_env, new_denv, new_lambda) =
	  trans_individual_funbind(funbind, top_env, top_denv)
        val (rest_env, rest_denv, rest_lambda) = trans_fun_dec(rest, top_env, top_denv)
      in
        (Environ.augment_top_env(new_env, rest_env),
         augment_denv(new_denv, rest_denv), new_lambda @@ rest_lambda)
      end

  fun trans_fun_dec_list([], _, _) = (make_top_env Environ.empty_env,
                                      empty_denv, [])
    | trans_fun_dec_list((Absyn.FUNBIND funbind):: rest, top_env, top_denv) =
      let
        val (new_env, new_denv, new_lambda) = trans_fun_dec(funbind, top_env, top_denv)
        val (rest_env, rest_denv, rest_lambda) =
          trans_fun_dec_list(rest, Environ.augment_top_env(top_env, new_env),
                             augment_denv(top_denv, new_denv))
      (* The rest of the functors in the following topdecs
       can reference those defined earlier *)
      in
        (Environ.augment_top_env(new_env, rest_env),
         augment_denv(new_denv, rest_denv), new_lambda @@ rest_lambda)
      end

  val old_functor_refs = !functor_refs
  val _ = functor_refs := []

  val (a,b,c) =
    case topdec of
      Absyn.STRDECtopdec (strdec,_) =>
        let
          val (new_env, new_denv, lambdas) =
            trans_str_dec(strdec, top_env, top_denv, true, NONE)
        in
          (make_top_env new_env, new_denv, lambdas)
        end
    | Absyn.SIGNATUREtopdec _ =>
        (make_top_env Environ.empty_env, empty_denv, [])
    | Absyn.FUNCTORtopdec (funbind_list,_) =>
        trans_fun_dec_list(funbind_list, top_env, top_denv)
    | Absyn.REQUIREtopdec _ =>
        Crash.impossible"trans_topdec REQUIREtopdec"

  val a = if generate_moduler then sub_functor_refs a else a

  (** create unique functor application refs for debugger structure returns for modules debugger **)
  val c = overload_binding @@
    map
    (fn (ref(EnvironTypes.LVARFOO lv),interface) =>
     LambdaTypes.LETB(lv,NONE,
                      LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                      ([str_to_lambda interface],[]),
                                      NONE))
  | _ => Crash.impossible "3:INTFOO:functor_refs:lambda") (!functor_refs) @@ c

  (** add unique functor application refs to lambda environment for modules debugger **)
  val a =
    let
      val (env,ct) =
        Lists.reducel
        (fn ((env,ct),(lv' as ref (EnvironTypes.LVARFOO lv),_)) =>
         (lv' := EnvironTypes.INTFOO ct;
          (Environ.add_valid_env(env,
                                 (Ident.VAR(make_functor_app ct),
                                  EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),ct+1))
      | _ => Crash.impossible "4:INTFOO:functor_refs:lambda")
        ((Environ.empty_env,!functor_refs_ct),!functor_refs)
    in
      (functor_refs_ct := ct;
       Environ.augment_top_env(a, make_top_env (make_env env)))
    end

  val _ = functor_refs := (!functor_refs) @@ old_functor_refs

  val result_debug_info = ! debugger_env_ref
    in
      (a, b, c, result_debug_info)
    end
end;
@


1.221.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.221  1999/02/02  16:00:44  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.220
log
@[Bug #70167]
Ensure that overloading is resolved for polymorphic equality
in order to allow optimisation into monomorphic equality if possible
@
text
@d4 5
d656 1
a656 1
require "^.system.__os_path";
d4855 1
a4855 1
		  val file_loc = OSPath_.file (Location.to_string loc)
@


1.219
log
@[Bug #70068]
Only use resolve_ty when we have a potential overloaded operator
@
text
@d4 4
d2939 6
d2948 2
a2949 11
			   local
			     fun error_fn (valid, loc) =
			       Info.error'
			       error_info
			       (Info.FATAL, loc,
				"Unresolved overloading for "
				^ IdentPrint.printValId print_options valid)
			   in
			     val _ = Types.resolve_overloading
			       (not old_definition, ty, error_fn);
			   end
d2995 3
@


1.218
log
@[Bug #70075]
Ensure full location info given with exceptions
@
text
@d4 4
a2909 12
                     local
                       fun error_fn (valid, loc) =
                         Info.error'
                           error_info
                           (Info.FATAL, loc,
                            "Unresolved overloading for "
                            ^ IdentPrint.printValId print_options valid)
                     in
                       val _ = Types.resolve_overloading
                                 (not old_definition, ty, error_fn);
                     end

d2938 12
@


1.217
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d4842 1
a4842 1
		  val file_loc = OSPath_.file (Location.file_of_location loc)
@


1.216
log
@[Bug #70075]
Get exception name back into exceptions
@
text
@d4 4
d2681 1
a2681 1
                       (fn () =>
d2685 1
a2685 1
                         IdentPrint.printLongValId print_options (mklongvalid (Ident.VAR(Symbol.find_symbol name))));
@


1.215
log
@[Bug #30349]
Warn when lhs of semicolon does not have type unit
@
text
@d4 4
d4833 6
a4838 1
		OSPath_.file (Location.file_of_location loc)
@


1.214
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d3291 14
a3304 1
          (if show_match then
d3310 2
a3311 1
             ());
d3330 1
@


1.213
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 10
d627 2
a639 1
require "../basics/module";
a670 2
  structure Module : MODULE
  structure ModuleId : MODULE_ID
a714 2
  sharing type Module.Location = Info.Location.T
  sharing type ModuleId.ModuleId = Module.ModuleId
d4810 1
a4810 8
		let
		  val (on_path, module) = Module.find_file(Location.file_of_location loc, loc)
		in
		  concat [sym_string, "[",
			  ModuleId.string(Module.module_id module), "]"]
		end
                handle Module.NoSuchFile _ => old_name
                (* XXX: should also handle BadHomeName *)
d4813 1
@


1.212
log
@Use StandardIO instead of MLWorks.IO for dynamic redundancy messages
@
text
@d4 3
a616 1
require "^.basis.__old";
d3804 1
a3804 1
                   fun add_match_string (name,match_string) =
d3806 4
a3809 2
                       fun aux ("[" ::rest,acc) =
                         concat (rev acc @@ (match_string :: "[" :: rest))
d3813 1
a3813 1
                       aux (Old.explode name,[])
@


1.212.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.212  1997/06/12  10:19:24  matthew
 * Use StandardIO instead of MLWorks.IO for dynamic redundancy messages
 *
@


1.212.2.2
log
@[Bug #30071]
@
text
@a3 3
 * Revision 1.212.2.1  1997/09/11  20:55:56  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
a617 2
require "^.system.__os_path";

d629 1
d661 2
d707 2
d4802 8
a4809 1
		OSPath_.file (Location.file_of_location loc)
a4811 1

@


1.212.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.212  1997/06/12  10:19:24  matthew
 * Use StandardIO instead of MLWorks.IO for dynamic redundancy messages
 *
@


1.211
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d3627 2
a3628 4
                val MLWorks_IO_output =
                      cg_longvalid(make_longid (["MLWorks","IO"],"output"),env)
                val MLWorks_IO_std_out =
                      cg_longvalid(make_longid (["MLWorks","IO"],"std_out"),env)
d3671 2
a3672 3
                               LambdaTypes.APP(MLWorks_IO_output,
                                ([LambdaTypes.STRUCT([MLWorks_IO_std_out,
                                 LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.HAT,
a3679 1
                                LambdaTypes.TUPLE)],
@


1.210
log
@[Bug #20017]
Improve polymorphic equality on types with one vcc and no nullaries
Also ensure poly eq which turns out to be int32 or word32 eq is coded accordingly
@
text
@d4 5
d720 1
a720 1
  structure Option = MLWorks.Option
d722 3
a724 1
  type DebugInformation = Debugger_Types.information
d3816 1
a3816 1
                     | do_binding (Option.INL (ref NONE)::bindings) =
d3818 1
a3818 1
                     | do_binding (Option.INL (ref (SOME (lvar as ref(Option.INL(_,tree)))))::bindings) =
d3827 1
a3827 1
			 val _ = lvar := Option.INR lv
d3854 1
a3854 1
                     | do_binding (Option.INL _::_) =
d3856 1
a3856 1
                     | do_binding (Option.INR(lvar' as ref (Option.INL (_,tree)),matchvar)::bindings) =
d3861 1
a3861 1
			 val _ = lvar' := Option.INR lv
d3899 1
a3899 1
                     | do_binding (Option.INR _::_) =
d3906 1
a3906 1
		   fun Tr_Default (ref(Match.BUILT(ref(Option.INR lvar)))) =
d3916 1
a3916 1
		     | Tr_Default (ref(Match.BUILT(ref(Option.INL(0,tree))))) =
d3926 3
a3928 3
		     Option.INL (SOME default) => Tr_Default default
		   | Option.INL NONE => NONE
		   | Option.INR (ref (Option.INR lvar)) =>
d3939 1
a3939 1
		   | Option.INR _ =>
d4012 1
a4012 1
			       Tr_Default (Option.INL(SOME default))
d4023 1
a4023 1
					    | SOME bd =>[Option.INL bd],
d4063 1
a4063 1
                    fun tr_match'(Option.INL tree,match_env, val_env) =
d4065 1
a4065 1
                      | tr_match'(Option.INR(ref(Option.INR lvar)),_, _) =
d4077 1
a4077 1
                      | tr_match'(Option.INR _, _, _) =
d4282 1
a4282 1
              case Tr_Default (Option.INL(SOME default)) of
d4289 1
a4289 1
                                     | SOME bd => [Option.INL bd],
@


1.209
log
@Moving inline expansion of ident and not to optimizer
@
text
@d4 3
d907 2
a908 2
    (case NewMap.to_list record_map of
       (_, ty as Datatypes.META_OVERLOADED (r, tv, valid, loc)) :: _ =>
d913 10
a922 8
     | (_, Datatypes.METATYVAR _) :: _ => Crash.impossible "overloaded_name (2) METATYVAR"
     | (_, Datatypes.TYVAR _) :: _ => Crash.impossible "overloaded_name (2) TYVAR"
     | (_, Datatypes.METARECTYPE _) :: _ => Crash.impossible "overloaded_name (2) METARECTYPE"
     | (_, Datatypes.RECTYPE _) :: _ => Crash.impossible "overloaded_name (2) RECTYPE"
     | (_, Datatypes.FUNTYPE _) :: _ => Crash.impossible "overloaded_name (2) FUNTYPE"
     | (_, Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...})) :: _ => s
     | (_, Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...})) :: _ => s
     | (_, Datatypes.DEBRUIJN _) :: _ => Crash.impossible "overloaded_name (2) DEBRUIJN"
a1115 21
(*
  local
    (* domain_type_name is used when optimising = and <> to produce
       type-specific versions.  Since these are the same (at present)
       for smaller versions of these types, we can just massage the
       type name here.  This will probably have to change. *)
    fun massage_name "int8" = "int"
    |   massage_name "word8" = "word"
    |   massage_name "int16" = "int"
    |   massage_name "word16" = "word"
    |   massage_name "float32" = "real"
    |   massage_name x = x
  in
    fun domain_type_name ty =
      case domain_tyname ty of
        (true, Datatypes.TYNAME{2=s,...}) => (true, massage_name s)
      | (true, Datatypes.METATYNAME{2=s,...}) => (true, massage_name s)
      | _ => (false, "Not fun(rec)")
  end
*)

d1120 4
d2964 33
d3003 10
a3012 7
				       if Types.has_real_equality tyname then
					 (mklongvalid(Ident.VAR(Symbol.find_symbol("_real" ^ sy_name))), true)
				       else
					 if Types.has_string_equality tyname then
					 (mklongvalid(Ident.VAR(Symbol.find_symbol("_string" ^ sy_name))), true)
					 else
					   (longValId, false)
@


1.209.1.1
log
@branched from 1.209
@
text
@a3 3
 * Revision 1.209  1997/02/05  13:34:23  matthew
 * Moving inline expansion of ident and not to optimizer
 *
@


1.209.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.209.1.1  1997/05/12  10:35:13  hope
 * branched from 1.209
 *
@


1.209.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.209.1.1  1997/05/12  10:35:13  hope
 * branched from 1.209
 *
@


1.209.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.209.1.1  1997/05/12  10:35:13  hope
 * branched from 1.209
 *
@


1.209.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.209.1.1.1.1  1997/07/28  18:20:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.208
log
@Simplifications and rationalizations
@
text
@d4 3
a810 25
  fun notcode() =
  let
    val l = new_LVar()
  in
    LambdaTypes.FN(([l],[]),
      LambdaTypes.SWITCH(
	LambdaTypes.VAR l,
	SOME {num_imms = 2, num_vccs = 0},
	[(LambdaTypes.IMM_TAG ("false",1), LambdaTypes.INT 0),
	  (LambdaTypes.IMM_TAG ("true",0), LambdaTypes.INT 1)],
	NONE),LambdaTypes.BODY,
      "Builtin not",
      LambdaTypes.null_type_annotation,
      RuntimeEnv.INTERNAL_FUNCTION)
  end


  fun ident_code() =
    let
      val l = new_LVar()
    in
      LambdaTypes.FN(([l], []), LambdaTypes.VAR l, LambdaTypes.BODY, "identity",
		     LambdaTypes.null_type_annotation,RuntimeEnv.INTERNAL_FUNCTION)
    end

d1214 1
a1214 3
             (case prim of
                Pervasives.NOT => notcode()
              | _ => LambdaTypes.BUILTIN prim)
d2961 1
a2961 2
                         LambdaTypes.BUILTIN Pervasives.IDENT_FN => (ident_code(),true)
                       | LambdaTypes.BUILTIN prim =>
d4929 1
a4929 4
                     LambdaTypes.LETB (l,NONE,
                                       case prim of
                                         Pervasives.IDENT_FN => ident_code()
                                       | _ => LambdaTypes.BUILTIN prim)
@


1.207
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d617 1
a617 1
require "../rts/gen/implicit.sml";
d709 2
d812 1
a812 1
    LambdaTypes.FN([l],
d818 1
a818 1
	NONE),
d820 2
a821 1
      LambdaTypes.null_type_annotation,RuntimeEnv.INTERNAL_FUNCTION)
d829 1
a829 1
      LambdaTypes.FN([l], LambdaTypes.VAR l, "identity",
d978 5
a982 5
               [LambdaTypes.STRUCT
	          ([LambdaTypes.VAR x,
		    LambdaTypes.SCON
		      (Ident.INT (abs_min_int, Location.UNKNOWN), NONE)],
		   LambdaTypes.TUPLE)],
d988 5
a992 5
               [LambdaTypes.STRUCT
	          ([addition,
		    LambdaTypes.SCON
		      (Ident.INT (max_word, Location.UNKNOWN), NONE)],
		   LambdaTypes.TUPLE)],
d1015 1
a1015 1
          ([arg],
d1021 1
a1021 1
	          [LambdaTypes.VAR arg],
d1024 1
d1040 5
a1044 5
         [LambdaTypes.STRUCT
	   ([LambdaTypes.VAR var,
	     LambdaTypes.SCON
	       (Ident.WORD (mask, Location.UNKNOWN), NONE)],
	    LambdaTypes.TUPLE)],
d1056 1
a1056 1
          ([arg],
d1062 1
a1062 1
	          [LambdaTypes.VAR arg],
d1065 1
d1179 1
a1179 1
	      [LambdaTypes.SCON (Ident.STRING (Symbol.symbol_name sy), NONE)],
d1200 1
a1200 1
	      [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],
d1241 1
a1241 1
                             [LambdaTypes.SCON(Ident.STRING(valid_name valid), NONE)],
d1275 1
a1275 1
                             [LambdaTypes.SCON(Ident.STRING(valid_name valid), NONE)],
d1306 1
a1306 1
	         [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],
d1464 1
a1464 1
               (fn id => MLWorks.IO.output (MLWorks.IO.std_out,IdentPrint.debug_printValId id ^ " "))
d1466 2
a1467 2
               MLWorks.IO.output (MLWorks.IO.std_out,"\n"))
            val _ = (MLWorks.IO.output (std_out, "Domain:\n");
d1469 1
a1469 1
                     MLWorks.IO.output (std_out,"V_list:\n");
d1539 1
a1539 1
                    LambdaTypes.FN([lv],
d1541 1
d1543 2
a1544 1
                                   LambdaTypes.null_type_annotation,RuntimeEnv.INTERNAL_FUNCTION)
d1701 1
a1701 1
          MLWorks.IO.output(MLWorks.IO.std_out,"  # " ^ message() ^ "\n")
d2078 1
a2078 1
                 ([args],
d2097 1
a2097 1
                                  [let
d2122 1
a2122 1
                                    end],
d2125 3
a2127 1
                  overload_function_string,Datatypes.NULLTYPE,RuntimeEnv.INTERNAL_FUNCTION)
d2160 1
a2160 1
                                        [case !functorlv of
d2164 1
d2178 1
a2178 1
                [case !functorlv of
d2181 1
a2181 1
                    cg_longvalid(mklongvalid (Ident.VAR (make_functor_app ct)),env)],
d2215 1
a2215 1
                                  [instance_to_lambda instance_info],
d2232 1
a2232 1
               [let
d2244 1
a2244 1
               end],
d2248 6
a2253 5
                              [LambdaTypes.STRUCT([new_cg,dexp',
                                                   case fetch_instance'() of
                                                     NONE => LambdaTypes.INT ~1
                                                   | SOME i => LambdaTypes.INT i],
                              LambdaTypes.TUPLE)],
d2267 1
a2267 1
                                         [LambdaTypes.INT i],
d2275 1
a2275 1
                                              [LambdaTypes.STRUCT([wrap_selects(selects,LambdaTypes.VAR root_lv),
d2278 1
d2286 1
a2286 1
				 ([lv],
d2289 1
a2289 1
                                     [LambdaTypes.STRUCT
d2292 1
a2292 1
                                         LambdaTypes.TUPLE)],
d2294 1
d2308 1
a2308 1
                                            [LambdaTypes.INT i],
d2327 1
a2327 1
                                               [unit_exp],
d2350 5
a2354 4
                               [case !functorlv of
                                  EnvironTypes.LVARFOO functorlv => LambdaTypes.VAR functorlv
                                | EnvironTypes.INTFOO ct =>
                                    cg_longvalid (mklongvalid (Ident.VAR (make_functor_app ct)),env)],
d2569 7
a2575 2
                LambdaTypes.FN([new_LVar()],LambdaTypes.INT 1,"dummy tyfun tyfun",LambdaTypes.null_type_annotation,
                               RuntimeEnv.INTERNAL_FUNCTION)::prepend_tycons tycons
d2813 1
a2813 1
                                    LambdaTypes.FN([new_LVar()],
d2819 1
d2848 1
a2848 1
                                     ([new_LVar()],
d2854 1
d3047 1
a3047 1
			     ([new_lv],
d3054 2
a3055 1
				let
d3071 2
a3072 1
			      LambdaTypes.null_type_annotation,RuntimeEnv.INTERNAL_FUNCTION)
d3084 1
a3084 1
                         LambdaTypes.FN([lv],
d3086 1
d3193 1
a3193 1
            LambdaTypes.APP(fcn, [arg],SOME annotation)
d3219 1
a3219 1
                               (Print.print"Exception match tree is\n";
d3221 3
a3223 2
                                (fn x => MLWorks.IO.output (MLWorks.IO.std_out,x)) (Match.unparseTree print_options tree "");
                                Print.print"\n";
d3269 3
a3271 4
             (Print.print"Match tree is\n";
              Lists.iterate
              (fn x => MLWorks.IO.output (MLWorks.IO.std_out,x)) (Match.unparseTree print_options tree "");
              Print.print"\n";
d3275 17
a3291 19
            (case not_exhaustive of
               SOME missing_constructors =>
               Info.error error_info
               (Info.WARNING, location,
		print_list
		(fn (ty, valid_list) =>
		 print_list
		 (fn (Ident.CON con) => Symbol.symbol_name con
		  | _ => Crash.impossible"missing_constructors:trans_exp:lambda")
		 (valid_list, ", ",
		  "missing constructors of type " ^
		  Types.print_type options ty ^
                  (case valid_list of
                     nil => ""
                   | _ => " : "),
		  "")
		 )
		(missing_constructors, "\n", "Match not exhaustive\n", "")
		)
d3412 1
a3412 4
		    | aux (APP (e,el,ty)) = APP (aux e,map aux el,ty)
(*
		    | aux (BUILTINAPP(b,el,ty)) = BUILTINAPP(b,map aux el,ty)
*)
d3430 1
a3430 1
		    | aux (FN (vl,body,name,ty,info)) =
d3433 1
d3437 1
a3437 1
			  new_vl
d3439 1
a3439 1
			FN (map #2 new_vl,aux body,name,ty,info)
d3470 2
a3471 2
		| has_bounds(APP(e, el, _)) =
		  has_bounds e orelse Lists.exists has_bounds el
d3508 2
a3509 2
		| size(n, APP(e, el, _)) =
		  size(Lists.reducel size (n+1, el), e)
d3517 1
a3517 1
		| size(n, FN(_, le, _, _, _)) = size(n+1, le)
d3632 1
a3632 1
                             [LambdaTypes.SCON(Ident.STRING rc, NONE)],
d3643 6
a3648 5
                                        [LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                            [LambdaTypes.VAR lvar],
                                                                            NONE),
                                                            report rcs],
                                                            LambdaTypes.TUPLE)],
d3653 2
a3654 2
                                            [LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                                [LambdaTypes.VAR redundant_clauses_lambda],
d3658 1
d3664 1
a3664 1
                                [LambdaTypes.STRUCT([MLWorks_IO_std_out,
d3666 1
a3666 1
                                  [LambdaTypes.STRUCT([LambdaTypes.SCON(Ident.STRING(
d3671 1
d3674 1
d3706 3
a3708 1
                                          [LambdaTypes.STRUCT([exn_code exn1,exn_code exn2],LambdaTypes.TUPLE)],
d3731 1
a3731 1
                           [LambdaTypes.STRUCT([LambdaTypes.VAR lvar,
d3735 1
d3741 1
a3741 1
                            [LambdaTypes.STRUCT([LambdaTypes.VAR redundant_clauses_lambda,
d3743 2
a3744 2
                                [LambdaTypes.STRUCT([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                    [LambdaTypes.VAR redundant_clauses_lambda],
d3748 1
d3750 1
a3750 1
                            LambdaTypes.TUPLE)],
d3769 1
a3769 1
                                       [LambdaTypes.SCON(Ident.INT(Int.toString number_of_clauses,
d3771 1
d3810 1
a3810 1
                     | do_binding (MLWorks.Option.INL (ref NONE)::bindings) =
d3812 1
a3812 1
                     | do_binding (MLWorks.Option.INL (ref (SOME (lvar as ref(MLWorks.Option.INL(_,tree)))))::bindings) =
d3821 1
a3821 1
			 val _ = lvar := MLWorks.Option.INR lv
d3834 1
a3834 1
			   LambdaTypes.FN([new_LVar()],
d3836 1
d3839 1
a3839 1
			   RuntimeEnv.INTERNAL_FUNCTION)
d3848 1
a3848 1
                     | do_binding (MLWorks.Option.INL _::_) =
d3850 1
a3850 1
                     | do_binding (MLWorks.Option.INR(lvar' as ref (MLWorks.Option.INL (_,tree)),matchvar)::bindings) =
d3855 1
a3855 1
			 val _ = lvar' := MLWorks.Option.INR lv
d3880 1
a3880 1
			   ([new_LVar()],
d3882 1
d3893 1
a3893 1
                     | do_binding (MLWorks.Option.INR _::_) =
d3900 1
a3900 1
		   fun Tr_Default (ref(Match.BUILT(ref(MLWorks.Option.INR lvar)))) =
d3908 1
a3908 1
			   SOME(LambdaTypes.APP(LambdaTypes.VAR lvar, [unit_exp], NONE))
d3910 1
a3910 1
		     | Tr_Default (ref(Match.BUILT(ref(MLWorks.Option.INL(0,tree))))) =
d3920 3
a3922 3
		     MLWorks.Option.INL (SOME default) => Tr_Default default
		   | MLWorks.Option.INL NONE => NONE
		   | MLWorks.Option.INR (ref (MLWorks.Option.INR lvar)) =>
d3931 1
a3931 1
				 (LambdaTypes.VAR lvar, [unit_exp], NONE))
d3933 1
a3933 1
		   | MLWorks.Option.INR _ =>
d4006 1
a4006 1
			       Tr_Default (MLWorks.Option.INL(SOME default))
d4017 1
a4017 1
					    | SOME bd =>[MLWorks.Option.INL bd],
d4057 1
a4057 1
                    fun tr_match'(MLWorks.Option.INL tree,match_env, val_env) =
d4059 1
a4059 1
                      | tr_match'(MLWorks.Option.INR(ref(MLWorks.Option.INR lvar)),_, _) =
d4068 1
a4068 1
					      [unit_exp],
d4071 1
a4071 1
                      | tr_match'(MLWorks.Option.INR _, _, _) =
d4132 1
a4132 1
					      [LambdaTypes.VAR orig_lv],
d4276 1
a4276 1
              case Tr_Default (MLWorks.Option.INL(SOME default)) of
d4283 1
a4283 1
                                     | SOME bd => [MLWorks.Option.INL bd],
d4292 1
a4292 1
     LambdaTypes.FN([root_lambda],
d4304 1
d4493 1
a4493 1
						       [LambdaTypes.VAR lambda_var],
d4847 1
a4847 1
                                              [unit_exp],
d5023 1
a5023 1
                                                 [unit_exp],
d5104 1
a5104 1
                                                     [str_to_lambda interface],
d5123 1
a5123 1
                                                [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy), NONE)],
d5127 2
a5128 2
                                [new_arg],
                                NONE)
d5358 1
a5358 1
                                                                     [str_to_lambda interface],
d5366 1
a5366 1
                                                                [LambdaTypes.STRUCT([LambdaTypes.VAR lvar''',
d5369 1
d5383 1
a5383 1
                         LambdaTypes.FN([lvar], lambda_exp, annotation_string,
d5441 1
a5441 1
                                      [str_to_lambda interface],
d5462 1
a5462 1
  val _ = functor_refs := (!functor_refs)@@old_functor_refs
@


1.207.4.1
log
@branched from 1.207
@
text
@a3 4
 * Revision 1.207  1996/11/06  11:02:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.207.3.1
log
@branched from 1.207
@
text
@a3 4
 * Revision 1.207  1996/11/06  11:02:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.207.3.1.1.1
log
@branched from 1.207.3.1
@
text
@a3 3
 * Revision 1.207.3.1  1996/12/17  17:48:44  hope
 * branched from 1.207
 *
@


1.207.2.1
log
@branched from 1.207
@
text
@a3 4
 * Revision 1.207  1996/11/06  11:02:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.207.1.1
log
@branched from 1.207
@
text
@a3 4
 * Revision 1.207  1996/11/06  11:02:11  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.207.1.1.1.1
log
@branched from 1.207.1.1
@
text
@a3 3
 * Revision 1.207.1.1  1996/11/14  12:50:44  hope
 * branched from 1.207
 *
@


1.206
log
@[Bug #1614]
remove toplevel String.
@
text
@d4 4
d593 1
a593 1
require "../basis/__integer";
@


1.205
log
@[Bug #1708]
changing syntax of datatype replication.
@
text
@d4 4
d590 2
a591 1

a700 2
  structure Option = MLWorks.Option

a714 2
  open MLWorks.Option

d719 1
a719 1
  fun reducel f =
d721 2
a722 10
      fun red (acc, []) = acc
        | red (acc, x::xs) = red (f(acc,x), xs)
    in
      red
    end

  fun substring (str1,str2) =
    let
      val str1 = String.explode str1
      val str2 = String.explode str2
d733 1
a733 2

  val makestring = Int.toString
d749 2
a750 8
  fun is_functor_app s =
    let
      val prefix = functor_app_string
      val prefix_size = size prefix
    in
      size s >= prefix_size andalso
      String.substring (s,0,prefix_size) = prefix
    end
d752 3
a754 5
  val new_LVar = LambdaTypes.new_LVar

  fun make_functor_app n =
    Symbol.find_symbol ("<" ^ functor_app_string ^ makestring n ^ ">")
  end
d757 5
a761 5
    ((String.substring(name,0,4) = "<if>" orelse
      String.substring(name,0,5) = "<seq>" orelse
      String.substring(name,0,6) = "<case>" orelse
      String.substring(name,0,8) = "<handle>")
    handle String.Substring => false)
d823 1
a823 1
    reducel
d827 1
a827 1
    reducel
d1332 1
a1332 1
    reducel (fn (exp, bind) => LambdaTypes.do_binding(bind, exp))
d1417 1
a1417 1
              val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,Option.NONE)
d1494 1
a1494 1
          reducel
d1497 1
a1497 1
	  (reducel
d1612 2
a1613 2
      Option.NONE => result
    | Option.SOME interface =>
d1629 2
a1630 2
  fun interface_from_sigexp (Absyn.NEWsigexp(_, ref (Option.SOME str))) = str
    | interface_from_sigexp (Absyn.OLDsigexp(_, ref (Option.SOME str),_)) = str
d1636 1
a1636 1
  type MatchEnv = (LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.option) IntNewMap.T
d1674 1
a1674 1
      val null_runtimeinfo = RuntimeEnv.RUNTIMEINFO (Option.NONE,nil)
d1767 1
a1767 1
                lv,Option.NONE)
d1782 1
a1782 1
                                        ::selects,lv,Option.NONE)
d1844 2
a1845 2
                  fun aux nil = Option.NONE
                    | aux ((_,lexp as EnvironTypes.LAMBDAEXP(_,_,Option.SOME(tyfun')))::rest) =
d1847 1
a1847 1
                        then Option.SOME lexp
d1855 1
a1855 1
                Option.SOME lexp => lexp
d1860 1
a1860 1
                        EnvironTypes.LAMBDAEXP(rev (str_lookup str) @@ selects,lv,Option.NONE)
d1862 1
a1862 1
                        EnvironTypes.LAMBDAEXP' (rev (str_lookup str) @@ selects,lv,Option.NONE)
d1882 1
a1882 1
                fun find_tyfun nil _ = Option.NONE
d1884 1
a1884 1
                    if tyfun = fetch_ntf tystr then Option.SOME n
d1889 1
a1889 1
                  Option.SOME n =>
d1950 1
a1950 1
               Option.SOME(fetch_ntf tystr)))))
d1963 1
a1963 1
                                      ::selects,lv,Option.NONE))))
d2191 1
a2191 1
               Option.NONE => new_cg
d2194 2
a2195 2
             | Option.SOME (ref Datatypes.NO_INSTANCE) => new_cg
             | Option.SOME _ =>
d2198 1
a2198 1
                                  Option.NONE)))
d2202 2
a2203 2
              Datatypes.ZERO => Option.NONE
            | Datatypes.ONE i => Option.SOME i
d2218 1
a2218 1
                    Option.NONE =>
d2220 1
a2220 1
                  | Option.SOME i =>
d2232 2
a2233 2
                                                     Option.NONE => LambdaTypes.INT ~1
                                                   | Option.SOME i => LambdaTypes.INT i],
d2245 2
a2246 2
                       Option.NONE => LambdaTypes.VAR lv
                     | Option.SOME i =>
d2254 1
a2254 1
                           Option.NONE =>
d2260 1
a2260 1
                              Option.NONE)
d2284 2
a2285 2
                          Option.NONE => LambdaTypes.VAR lv
                        | Option.SOME i =>
d2386 4
a2389 4
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,Option.SOME _),Option.SOME tystr,_) =
          EnvironTypes.LAMBDAEXP(selects,lv,Option.SOME(fetch_ntf tystr))
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,Option.SOME _),Option.SOME tystr,_) =
          EnvironTypes.LAMBDAEXP'(selects,lv,Option.SOME(fetch_ntf tystr))
d2393 2
a2394 2
      fun merge_dstrexps(dstr,Option.SOME(Datatypes.COPYSTR(_,str)), dstrexp, location) =
          merge_dstrexps(dstr,Option.SOME str,dstrexp, location)
d2396 1
a2396 1
                         Option.SOME(str as
d2421 1
a2421 1
                  Option.SOME(fetch_ntf tystr)))))
d2426 1
a2426 1
                          merge_dstrexps(debugger_str,Option.SOME str,
d2436 1
a2436 1
                                                       ::selects,lv,Option.NONE))))
d2440 1
a2440 1
                merge_dstrexps (debugger_str,Option.SOME str,LAMBDASTREXP(selects,lv,str'), location)
d2456 4
a2459 4
                                        Option.SOME(NewMap.apply'(tyconmap'',tc')), location)))
                     (NewMap.map (fn (v,Option.NONE) => merge_dexps (EnvironTypes.NULLEXP,
                                             (NewMap.apply' (validmap',v)),Option.NONE, location)
                                  | (v,Option.SOME i) =>
d2461 1
a2461 1
                                                  NewMap.apply' (validmap',v),Option.NONE, location))
d2465 1
a2465 1
                                                Option.SOME(NewMap.apply' (stridmap'',strid)),
d2472 1
a2472 1
                                  Option.SOME(NewMap.apply'(tyconmap'',Ident.TYCON tc)), location)
d2476 1
a2476 1
                                                Option.SOME(NewMap.apply' (stridmap'',strid)),
d2480 1
a2480 1
        | merge_dstrexps(ref Datatypes.EMPTY_DSTR, Option.NONE, dstrexp, _) = dstrexp
d2504 1
a2504 1
          val size3 = Lists.length valid_map - Lists.length vars
d2509 1
a2509 1
           reducel (fn (env,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env')) =>
d2514 1
a2514 1
           (reducel (fn (env,(Ident.TYCON' _,_)) => env
d2560 1
a2560 1
            reducel (fn (map,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env)) =>
d2565 1
a2565 1
            (#1(reducel (fn ((map,index),(Ident.TYCON tc,_)) =>
d2590 3
a2592 3
      fun fetch_interface(Option.SOME(ref(Option.SOME interface))) = interface
        | fetch_interface(Option.SOME _) =
          Crash.impossible "1:Option.NONE:fetch_interface:lambda"
d2594 1
a2594 1
          Crash.impossible "2:Option.NONE:fetch_interface:lambda"
d2599 2
a2600 2
        fun fetch_debugger_str (Option.SOME debugger_str) = debugger_str
          | fetch_debugger_str Option.NONE = empty_dstr
d2603 3
a2605 3
      fun fetch_tyfun (Option.SOME tyfun) = tyfun
        | fetch_tyfun Option.NONE =
          Crash.impossible "Option.NONE:fetch_tyfun:lambda"
d2617 1
a2617 1
	    reducel (fn (spills,ty) => spills@@type_spills ty)
d2735 1
a2735 1
                                                     Option.SOME spill))),
d3157 1
a3157 1
               [(LambdaTypes.IMM_TAG (makestring tag,tag), true_val)],
d3204 1
a3204 1
                                       reducel op ^
d3211 1
a3211 1
                               (Lists.length pat_exp_list,dynamic_str,location)
d3231 1
a3231 1
                reducel
d3274 1
a3274 1
                                          reducel op ^
d3279 1
a3279 1
                               (Lists.length pat_exp_list,dynamic_str,location)
d3455 1
a3455 1
	      and has_bounds_opt(MLWorks.Option.SOME e) = has_bounds e
d3492 1
a3492 1
	      and size_opt(n, MLWorks.Option.SOME e) = size(n, e)
d3562 1
a3562 6
            fun funny_name_p name  =
              ((String.substring(name,0,4) = "<if>" orelse
                String.substring(name,0,5) = "<seq>" orelse
                String.substring(name,0,6) = "<case>" orelse
                String.substring(name,0,8) = "<handle>")
              handle String.Substring => false)
d3572 1
a3572 1
                    Option.SOME (s,_) => s
d3698 2
a3699 2
                             LambdaTypes.SCON(Ident.STRING(String.implode("\n  ->" ::
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(String.explode rc))))))), NONE)],
d3733 1
a3733 1
                                       [LambdaTypes.SCON(Ident.INT(makestring number_of_clauses,
d3761 2
a3762 2
                       fun aux ("["::rest,acc) =
                         String.implode (rev acc @@ (match_string :: "[" :: rest))
d3766 1
a3766 1
                       aux (String.explode name,[])
d3770 2
a3771 2
                       Option.SOME lvar => lvar
                     | Option.NONE => (new_LVar(), LambdaTypes.INT 1)
d3773 1
a3773 1
                     | do_binding (INL (ref NONE)::bindings) =
d3775 1
a3775 1
                     | do_binding (INL (ref (SOME (lvar as ref(INL(_,tree)))))::bindings) =
d3780 1
a3780 1
                               add_match_string (name_string,"<Match" ^ makestring(new_match_trans()) ^ ">")
d3783 2
a3784 2
                                                 "<Match" ^ makestring(new_match_trans()) ^ ">")
			 val _ = lvar := INR lv
d3810 1
a3810 1
                     | do_binding (INL _::_) =
d3812 1
a3812 1
                     | do_binding (INR(lvar' as ref (INL (_,tree)),matchvar)::bindings) =
d3816 2
a3817 2
                           add_match_string (name_string,"<Match" ^ makestring(new_match_trans()) ^ ">")
			 val _ = lvar' := INR lv
d3854 1
a3854 1
                     | do_binding (INR _::_) =
d3861 1
a3861 1
		   fun Tr_Default (ref(Match.BUILT(ref(INR lvar)))) =
d3871 1
a3871 1
		     | Tr_Default (ref(Match.BUILT(ref(INL(0,tree))))) =
d3881 3
a3883 3
		     INL (SOME default) => Tr_Default default
		   | INL NONE => NONE
		   | INR (ref (INR lvar)) =>
d3894 1
a3894 1
		   | INR _ =>
d3902 1
a3902 1
                      trans_exp(" match_leaf", exp, env, denv, Option.SOME (fnname,fnname_lv))
d3920 1
a3920 1
					  Option.NONE)
d3967 1
a3967 1
			       Tr_Default (INL(SOME default))
d3978 2
a3979 2
					    | SOME bd =>[INL bd],
						Option.NONE)
d4018 1
a4018 1
                    fun tr_match'(INL tree,match_env, val_env) =
d4020 1
a4020 1
                      | tr_match'(INR(ref(INR lvar)),_, _) =
d4032 1
a4032 1
                      | tr_match'(INR _, _, _) =
d4073 1
a4073 1
                  if Lists.length vcc_lv_list <> 0 then
d4141 1
a4141 1
                      if Lists.length longvalid_mv_tree_list =
d4200 1
a4200 1
            lvar_let_lambdas_in_exp (lambda_exp3, binding, Option.NONE)
d4204 1
a4204 1
                lvar_let_lambdas_in_exp (lambda_exp1, binding, Option.NONE)
d4207 1
a4207 1
                lvar_let_lambdas_in_exp (lambda_exp2, binding, Option.SOME(new_lv,new_le))
d4221 1
a4221 1
	  val new_env = reducel
d4237 1
a4237 1
              case Tr_Default (INL(SOME default)) of
d4244 2
a4245 2
                                     | SOME bd => [INL bd],
                                     Option.NONE)
d4292 1
a4292 1
                             Location.UNKNOWN, ref (Datatypes.ZERO, Option.NONE)),
d4313 1
a4313 1
        val new_spills = reducel (fn (l1, (_, _, l2)) => l1 @@ l2) ([], e_l_list)
d4332 1
a4332 1
                                Option.NONE)
d4346 1
a4346 1
                   RuntimeEnv.NOVARINFO,Option.NONE)
d4359 1
a4359 1
                                               stuff,Option.NONE),
d4381 1
a4381 1
                        ], RuntimeEnv.NOVARINFO, Option.NONE)
d4400 1
a4400 1
                        Option.NONE)
d4429 1
a4429 1
                   reducel (fn (env, (_, _, env', _, _)) =>
d4432 1
a4432 1
                   reducel (fn (env, (_, _, _, env', _)) =>
d4435 1
a4435 1
                   reducel
d4438 1
a4438 1
                   Option.NONE)
d4460 1
a4460 1
			     Option.NONE)
d4495 1
a4495 1
			       Option.NONE)
d4520 1
a4520 1
                        Option.NONE)
d4537 1
a4537 1
                        lambda,RuntimeEnv.VARINFO (Symbol.symbol_name vid,stuff,Option.NONE),
d4652 1
a4652 1
                    reducel Environ.augment_env (Environ.empty_env, map #1 env_le_list)
d4654 1
a4654 1
                    reducel augment_denv (empty_denv, map #2 env_le_list)
d4756 1
a4756 1
		  String.implode[sym_string, "[",
d4764 1
a4764 1
	  (env, denv, reducel (fn (x, y) => y @@ x) ([], lambdas))
d4900 1
a4900 1
	     val new_v_env = reducel
d4904 1
a4904 1
	     val new_s_env = reducel
d4946 1
a4946 1
      (new_env, new_denv, reducel (fn (x, y) => y @@ x) ([], bindings))
d5053 1
a5053 1
            complete_struct((env, arg), Option.SOME interface, !coerce, generate_moduler)
d5071 1
a5071 1
                                                                     Option.SOME interface,dstrexp,
d5129 1
a5129 1
          val inte_opt = Option.SOME (interface_from_sigexp sigexp)
d5154 3
a5156 3
	    Option.NONE => Option.NONE
          | Option.SOME (sigexp,_) =>
	      Option.SOME (interface_from_sigexp sigexp)
d5172 1
a5172 1
                                      Option.SOME(fetch_interface interface'),dstrexp, location)))
d5192 3
a5194 3
	    Option.NONE => Option.NONE
          | Option.SOME (sigexp,_) =>
	      Option.SOME (interface_from_sigexp sigexp)
d5210 1
a5210 1
                                      Option.SOME(fetch_interface interface'),dstrexp, location)))
d5237 1
a5237 1
      (new_env, new_denv, reducel (fn (x, y) => y @@ x) ([], bindings))
d5266 3
a5268 3
	Option.NONE => Option.NONE
      | Option.SOME (sigexp,_) =>
	  Option.SOME (interface_from_sigexp sigexp)
d5293 1
a5293 1
          Option.NONE)
d5381 1
a5381 1
            trans_str_dec(strdec, top_env, top_denv, true, Option.NONE)
d5408 1
a5408 1
        reducel
@


1.204
log
@[Bug #1592]
threading locations into Absyn.LOCALexp.
@
text
@d4 4
d4723 1
a4723 1
    | Absyn.DATATYPErepl (location,(tyvars,tycon,longtycon),constructors) =>
d4742 3
a4744 1
           do_datatypeinfo_list [(tyvars,tycon,ref Absyn.nullType,NONE,
@


1.204.1.1
log
@branched from 1.204
@
text
@a3 4
 * Revision 1.204  1996/10/02  15:14:06  andreww
 * [Bug #1592]
 * threading locations into Absyn.LOCALexp.
 *
@


1.203
log
@[Bug #1605]
removing default_overloads flag.  Now subsumed by old_definition.
@
text
@d4 4
d2697 4
a2700 2
                | tyname_spills (Datatypes.TYNAME(_,_,_,_,ve1 as ref(Datatypes.VE(_,ve2)),_,_,
                                                  ve3 as ref(Datatypes.VE(_,ve4)))) =
d3103 1
a3103 1
    | Absyn.LOCALexp (decl, exp) =>
d4712 6
a4717 6
                     (* the typechecker should have set the "constructors" field of
                        the DATATYPErepl abstract syntax to point to the type environment
                        of the original datatype replication. The following code simply
                        uses this information to reconstruct a list of constructor bindings
                        which will then be passed directly to the datatype handling routine
                        "do_datatypeinfo_list". *)
@


1.203.1.1
log
@branched from 1.203
@
text
@a3 4
 * Revision 1.203  1996/09/23  12:08:01  andreww
 * [Bug #1605]
 * removing default_overloads flag.  Now subsumed by old_definition.
 *
@


1.202
log
@[Bug #1577]
Adding lambda code for datatype replication.
@
text
@d1664 1
a1664 1
	compat_options = Types.Options.COMPATOPTIONS {default_overloads, old_definition,...},
d2892 1
a2892 1
                                 (default_overloads, ty, error_fn);
d3307 1
a3307 1
                Types.resolve_overloading (default_overloads,ty,error_fn)
@


1.201
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml (essentially
just passing options rather than print_options).
@
text
@d4 5
d642 1
a642 1
	  Basis.BasisTypes.Datatypes
d2539 2
d2820 2
a2821 3
                  val new_env =
                    Environ.add_valid_env(env, (Ident.TYCON' sym,
                                                EnvironTypes.LAMB(tyfun_lvar, EnvironTypes.NOSPEC)))
d4297 2
a4298 1
            (* Create some bindings for the new types introduced here *)
d4306 2
d4310 1
d4314 2
d4325 4
d4705 32
@


1.201.1.1
log
@branched from 1.201
@
text
@a3 5
 * Revision 1.201  1996/08/05  17:59:38  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.200
log
@[Bug #1503]
Add field to FUNINFO to say if arg actually saved
@
text
@d4 4
d846 3
a848 1
         Crash.impossible("constructor_tag(3): " ^ Types.debug_print_type ty ^ "," ^
d851 4
d1652 1
a1652 1
    (Options.OPTIONS
d3030 1
a3030 1
					Types.print_name print_options tyname
d3254 1
a3254 1
		  Types.print_type print_options ty ^
@


1.199
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d4737 1
@


1.198
log
@Integer changes
@
text
@d4 3
d705 2
a706 2
      val str1 = explode str1
      val str2 = explode str2
d1438 1
a1438 1
               (fn id => output (std_out,IdentPrint.debug_printValId id ^ " "))
d1440 2
a1441 2
               output (std_out,"\n"))
            val _ = (output (std_out, "Domain:\n");
d1443 1
a1443 1
                     output (std_out,"V_list:\n");
d1673 1
a1673 1
          output(std_out,"  # " ^ message() ^ "\n")
d3173 1
a3173 1
                                (fn x => output (std_out,x)) (Match.unparseTree print_options tree "");
d3222 1
a3222 1
              (fn x => output (std_out,x)) (Match.unparseTree print_options tree "");
d3687 2
a3688 2
                             LambdaTypes.SCON(Ident.STRING(implode("\n  ->" ::
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(explode rc))))))), NONE)],
d3751 1
a3751 1
                         implode (rev acc @@ (match_string :: "[" :: rest))
d3755 1
a3755 1
                       aux (explode name,[])
a3933 13
(*
                              (case valid of
                                 Ident.VAR symbol =>
                                   (* Update the debug information for this variable *)
				   (output(std_out, "Doing do_leaf for (lv, SOME) case, valid = " ^ IdentPrint.printValId print_options valid ^ "\n");
				
				    varinforef := RuntimeEnv.VARINFO (Symbol.symbol_name symbol,ty,Option.NONE);
                                    do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                            EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),
                                            add_valid_denv(denv, (valid,EnvironTypes.NULLEXP))))
                               | _ => do_leaf(tl, Environ.add_valid_env(env, (valid,EnvironTypes.LAMB(lv,EnvironTypes.NOSPEC))),
                                             add_valid_denv(denv, (valid,EnvironTypes.NULLEXP))))
*)
d4701 1
a4701 1
		  implode[sym_string, "[",
@


1.197
log
@Remove references to environprint
@
text
@d4 3
d559 2
d715 1
a715 1
  val makestring = MLWorks.Integer.makestring
d1154 1
a1154 1
	  Crash.impossible("get_lamb_env gives field looking up " ^ Symbol.symbol_name sy ^ " at " ^ MLWorks.Integer.makestring index ^ "/" ^ MLWorks.Integer.makestring size ^ " in env :-\n" ^ EnvironPrint.stringenv Options.default_print_options env ^ "\n")
@


1.196
log
@Limit size of default functions inlined when debugging
@
text
@d4 3
a577 1
require "environprint";
a612 1
  structure EnvironPrint : ENVIRONPRINT
d622 1
a622 1
  sharing Environ.EnvironTypes = Primitives.EnvironTypes = EnvironPrint.EnvironTypes
d625 1
a625 1
    IdentPrint.Options = LambdaPrint.Options = EnvironPrint.Options
@


1.195
log
@Modifying add_binding to add beta reduced versions of the bindings
to reduce the amount of store used
@
text
@d4 4
d575 1
d611 1
d621 1
a621 1
  sharing Environ.EnvironTypes = Primitives.EnvironTypes
d624 1
a624 1
    IdentPrint.Options = LambdaPrint.Options
d1146 4
a1149 1
      | EnvironTypes.FIELD _ =>
d3409 70
d3508 7
a3514 1
		  val arg = (lv, LambdaOptimiser.simple_beta_reduce le)
d3516 7
a3522 1
		  binding_list := arg :: !binding_list
@


1.194
log
@Change to WHEREsigexp
@
text
@d4 3
a569 1
require "../initbasis/os";
a607 1
  structure Os : OS
d3415 1
a3415 1
	    fun report_binding lv =
d3418 3
a3420 2
		     (case find_binding lv of
			SOME _ => "Found binding for " ^ LambdaTypes.printLVar lv
d3426 9
a3434 2
	    fun add_binding arg =
	      if debugging then binding_list := arg :: !binding_list else ()
d3752 2
a3753 1
		       val _ = report_binding lvar
d3755 1
a3755 1
		       case find_binding lvar of
d3774 2
a3775 1
		       val _ = report_binding lvar
d3777 1
a3777 1
		       case find_binding lvar of
d3924 2
a3925 1
			  val _ = report_binding lvar
d3927 1
a3927 1
			  case find_binding lvar of
@


1.193
log
@trans_dec.make_exbind_info: remove Io and Os.SysErr exception handlers
The former because it is no longer necessary to support bootstrapping
from SML/NJ.  The latter because Module.find_file catches it and
converts it into Module.NoSuchFile.
@
text
@d4 6
d602 1
a602 1
  structure Match : MATCH
a636 1
  sharing type Match.Matchvar = int
d1599 1
a1599 1
    | interface_from_sigexp (Absyn.WHEREsigexp sigexp) = interface_from_sigexp sigexp
d4972 1
a4972 1
    | Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,coerce) =>
@


1.192
log
@Put Io exception back so that it is possible to bootstrap with SML/NJ.
@
text
@d4 3
d4592 1
a4592 2
	      Location.UNKNOWN =>
		old_name
d4599 3
a4601 3
		end handle Module.NoSuchFile _ => old_name
		  | Io _ => old_name (* Support SML/NJ bootstrapping *)
		  | Os.SysErr _ => old_name
@


1.191
log
@make_exbind_info: change Io exception to OS.SysErr
@
text
@d4 3
d4598 1
@


1.190
log
@Changes to VALdec
@
text
@d4 3
d555 1
d594 1
d4595 1
a4595 1
		  | Io _ => old_name
@


1.189
log
@Changed interface to typerep_utils functions
,
@
text
@d4 4
d641 2
d1369 1
a1369 1
              val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,MLWorks.Option.NONE)
d1564 2
a1565 2
      MLWorks.Option.NONE => result
    | MLWorks.Option.SOME interface =>
d1581 3
a1583 2
  fun interface_from_sigexp (Absyn.NEWsigexp(_, ref (MLWorks.Option.SOME str))) = str
    | interface_from_sigexp (Absyn.OLDsigexp(_, ref (MLWorks.Option.SOME str),_)) = str
d1588 1
a1588 1
  type MatchEnv = (LambdaTypes.LVar * LambdaTypes.VarInfo ref MLWorks.Option.option) IntNewMap.T
d1626 1
a1626 1
      val null_runtimeinfo = RuntimeEnv.RUNTIMEINFO (MLWorks.Option.NONE,nil)
d1719 1
a1719 1
                lv,MLWorks.Option.NONE)
d1734 1
a1734 1
                                        ::selects,lv,MLWorks.Option.NONE)
d1796 2
a1797 2
                  fun aux nil = MLWorks.Option.NONE
                    | aux ((_,lexp as EnvironTypes.LAMBDAEXP(_,_,MLWorks.Option.SOME(tyfun')))::rest) =
d1799 1
a1799 1
                        then MLWorks.Option.SOME lexp
d1807 1
a1807 1
                MLWorks.Option.SOME lexp => lexp
d1812 1
a1812 1
                        EnvironTypes.LAMBDAEXP(rev (str_lookup str) @@ selects,lv,MLWorks.Option.NONE)
d1814 1
a1814 1
                        EnvironTypes.LAMBDAEXP' (rev (str_lookup str) @@ selects,lv,MLWorks.Option.NONE)
d1834 1
a1834 1
                fun find_tyfun nil _ = MLWorks.Option.NONE
d1836 1
a1836 1
                    if tyfun = fetch_ntf tystr then MLWorks.Option.SOME n
d1841 1
a1841 1
                  MLWorks.Option.SOME n =>
d1902 1
a1902 1
               MLWorks.Option.SOME(fetch_ntf tystr)))))
d1915 1
a1915 1
                                      ::selects,lv,MLWorks.Option.NONE))))
d2143 1
a2143 1
               MLWorks.Option.NONE => new_cg
d2146 2
a2147 2
             | MLWorks.Option.SOME (ref Datatypes.NO_INSTANCE) => new_cg
             | MLWorks.Option.SOME _ =>
d2150 1
a2150 1
                                  MLWorks.Option.NONE)))
d2154 2
a2155 2
              Datatypes.ZERO => MLWorks.Option.NONE
            | Datatypes.ONE i => MLWorks.Option.SOME i
d2170 1
a2170 1
                    MLWorks.Option.NONE =>
d2172 1
a2172 1
                  | MLWorks.Option.SOME i =>
d2184 2
a2185 2
                                                     MLWorks.Option.NONE => LambdaTypes.INT ~1
                                                   | MLWorks.Option.SOME i => LambdaTypes.INT i],
d2197 2
a2198 2
                       MLWorks.Option.NONE => LambdaTypes.VAR lv
                     | MLWorks.Option.SOME i =>
d2206 1
a2206 1
                           MLWorks.Option.NONE =>
d2212 1
a2212 1
                              MLWorks.Option.NONE)
d2236 2
a2237 2
                          MLWorks.Option.NONE => LambdaTypes.VAR lv
                        | MLWorks.Option.SOME i =>
d2338 4
a2341 4
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,MLWorks.Option.SOME _),MLWorks.Option.SOME tystr,_) =
          EnvironTypes.LAMBDAEXP(selects,lv,MLWorks.Option.SOME(fetch_ntf tystr))
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,MLWorks.Option.SOME _),MLWorks.Option.SOME tystr,_) =
          EnvironTypes.LAMBDAEXP'(selects,lv,MLWorks.Option.SOME(fetch_ntf tystr))
d2345 2
a2346 2
      fun merge_dstrexps(dstr,MLWorks.Option.SOME(Datatypes.COPYSTR(_,str)), dstrexp, location) =
          merge_dstrexps(dstr,MLWorks.Option.SOME str,dstrexp, location)
d2348 1
a2348 1
                         MLWorks.Option.SOME(str as
d2373 1
a2373 1
                  MLWorks.Option.SOME(fetch_ntf tystr)))))
d2378 1
a2378 1
                          merge_dstrexps(debugger_str,MLWorks.Option.SOME str,
d2388 1
a2388 1
                                                       ::selects,lv,MLWorks.Option.NONE))))
d2392 1
a2392 1
                merge_dstrexps (debugger_str,MLWorks.Option.SOME str,LAMBDASTREXP(selects,lv,str'), location)
d2408 4
a2411 4
                                        MLWorks.Option.SOME(NewMap.apply'(tyconmap'',tc')), location)))
                     (NewMap.map (fn (v,MLWorks.Option.NONE) => merge_dexps (EnvironTypes.NULLEXP,
                                             (NewMap.apply' (validmap',v)),MLWorks.Option.NONE, location)
                                  | (v,MLWorks.Option.SOME i) =>
d2413 1
a2413 1
                                                  NewMap.apply' (validmap',v),MLWorks.Option.NONE, location))
d2417 1
a2417 1
                                                MLWorks.Option.SOME(NewMap.apply' (stridmap'',strid)),
d2424 1
a2424 1
                                  MLWorks.Option.SOME(NewMap.apply'(tyconmap'',Ident.TYCON tc)), location)
d2428 1
a2428 1
                                                MLWorks.Option.SOME(NewMap.apply' (stridmap'',strid)),
d2432 1
a2432 1
        | merge_dstrexps(ref Datatypes.EMPTY_DSTR, MLWorks.Option.NONE, dstrexp, _) = dstrexp
d2540 3
a2542 3
      fun fetch_interface(MLWorks.Option.SOME(ref(MLWorks.Option.SOME interface))) = interface
        | fetch_interface(MLWorks.Option.SOME _) =
          Crash.impossible "1:MLWorks.Option.NONE:fetch_interface:lambda"
d2544 1
a2544 1
          Crash.impossible "2:MLWorks.Option.NONE:fetch_interface:lambda"
d2549 2
a2550 2
        fun fetch_debugger_str (MLWorks.Option.SOME debugger_str) = debugger_str
          | fetch_debugger_str MLWorks.Option.NONE = empty_dstr
d2553 3
a2555 3
      fun fetch_tyfun (MLWorks.Option.SOME tyfun) = tyfun
        | fetch_tyfun MLWorks.Option.NONE =
          Crash.impossible "MLWorks.Option.NONE:fetch_tyfun:lambda"
d2683 1
a2683 1
                                                     MLWorks.Option.SOME spill))),
d3436 1
a3436 1
                    MLWorks.Option.SOME (s,_) => s
d3634 2
a3635 2
                       MLWorks.Option.SOME lvar => lvar
                     | MLWorks.Option.NONE => (new_LVar(), LambdaTypes.INT 1)
d3764 1
a3764 1
                      trans_exp(" match_leaf", exp, env, denv, MLWorks.Option.SOME (fnname,fnname_lv))
d3782 1
a3782 1
					  MLWorks.Option.NONE)
d3813 1
a3813 1
				    varinforef := RuntimeEnv.VARINFO (Symbol.symbol_name symbol,ty,MLWorks.Option.NONE);
d3854 1
a3854 1
						MLWorks.Option.NONE)
d4074 1
a4074 1
            lvar_let_lambdas_in_exp (lambda_exp3, binding, MLWorks.Option.NONE)
d4078 1
a4078 1
                lvar_let_lambdas_in_exp (lambda_exp1, binding, MLWorks.Option.NONE)
d4081 1
a4081 1
                lvar_let_lambdas_in_exp (lambda_exp2, binding, MLWorks.Option.SOME(new_lv,new_le))
d4119 1
a4119 1
                                     MLWorks.Option.NONE)
d4165 1
a4165 1
                             Location.UNKNOWN, ref (Datatypes.ZERO, MLWorks.Option.NONE)),
d4170 1
a4170 1
            trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set),
d4188 1
a4188 1
      Absyn.VALdec (non_rec_list, rec_list, _) =>
d4196 1
a4196 1
                                MLWorks.Option.NONE)
d4210 1
a4210 1
                   RuntimeEnv.NOVARINFO,MLWorks.Option.NONE)
d4223 1
a4223 1
                                               stuff,MLWorks.Option.NONE),
d4245 1
a4245 1
                        ], RuntimeEnv.NOVARINFO, MLWorks.Option.NONE)
d4264 1
a4264 1
                        MLWorks.Option.NONE)
d4302 1
a4302 1
                   MLWorks.Option.NONE)
d4324 1
a4324 1
			     MLWorks.Option.NONE)
d4359 1
a4359 1
			       MLWorks.Option.NONE)
d4384 1
a4384 1
                        MLWorks.Option.NONE)
d4401 1
a4401 1
                        lambda,RuntimeEnv.VARINFO (Symbol.symbol_name vid,stuff,MLWorks.Option.NONE),
d4882 1
a4882 1
            complete_struct((env, arg), MLWorks.Option.SOME interface, !coerce, generate_moduler)
d4900 1
a4900 1
                                                                     MLWorks.Option.SOME interface,dstrexp,
d4956 12
d4983 3
a4985 3
	    MLWorks.Option.NONE => MLWorks.Option.NONE
          | MLWorks.Option.SOME sigexp =>
	      MLWorks.Option.SOME (interface_from_sigexp sigexp)
d5001 1
a5001 1
                                      MLWorks.Option.SOME(fetch_interface interface'),dstrexp, location)))
d5021 3
a5023 3
	    MLWorks.Option.NONE => MLWorks.Option.NONE
          | MLWorks.Option.SOME sigexp =>
	      MLWorks.Option.SOME (interface_from_sigexp sigexp)
d5039 1
a5039 1
                                      MLWorks.Option.SOME(fetch_interface interface'),dstrexp, location)))
d5095 3
a5097 3
	MLWorks.Option.NONE => MLWorks.Option.NONE
      | MLWorks.Option.SOME sigexp =>
	  MLWorks.Option.SOME (interface_from_sigexp sigexp)
d5122 1
a5122 1
          MLWorks.Option.NONE)
d5210 1
a5210 1
            trans_str_dec(strdec, top_env, top_denv, true, MLWorks.Option.NONE)
@


1.188
log
@Modify make_exbind_info to handle Io exceptions that may come from failed
realpath operations on Win95
@
text
@d4 4
d1601 1
a1601 1
	compat_options = Types.Options.COMPATOPTIONS {default_overloads, ...},
d1609 1
d2648 1
a2648 2
                                                 (ref ty,inforef as ref (RuntimeEnv.RUNTIMEINFO (i,_))),_)),
                             location) =
d3232 1
a3232 1
      | Absyn.DYNAMICexp (exp,_,ref (info as (ty,_,_))) =>
d3254 1
a3254 1
                          (TyperepUtils.convert_dynamic_type info))
d3777 1
a3777 1
                                     (null_tyfun_spills (denv,debug_info,"");
d4126 1
a4126 1
                         (null_tyfun_spills (denv,debug_info,Location.to_string location);
d4419 1
a4419 1
                  val _ = null_tyfun_spills (denvir,debug_info,location)
d4434 1
a4434 1
                     null_tyfun_spills (denvir,debug_info,location)
@


1.187
log
@Replacing Map with NewMap
@
text
@d4 3
d4579 1
@


1.186
log
@Add stuff to build more sensible exception names without
full pathname info.
@
text
@d4 4
a619 1
  structure Map = Datatypes.Mapping
d796 1
a796 1
      fun record_domain (Datatypes.RECTYPE map) = Map.domain map
d800 2
a801 2
          if flex
            then record_domain ty
d808 11
a818 12
          if flex
            then
              let
                val Ident.LAB sym = lab
                val sym_name = Symbol.symbol_name sym
              in
                Info.error
                error_info
                (Info.RECOVERABLE, loc,
                 "Unresolved record type for label: #" ^ sym_name);
                record_domain ty
              end
d822 1
a822 1
    val record_domain = record_domain the_type
d824 2
a825 1
    fun position (head::tail, n) =
d828 8
a835 7
      | position ([], _) =
	Crash.impossible("record_tag(1)")
  in
    {index = position(record_domain, 0),
     size = Lists.length record_domain,
     selecttype = LambdaTypes.TUPLE}
  end
d857 1
a857 1
    (case Map.assoc record_map of
d897 5
a901 9
      (Datatypes.RECTYPE
         (Map.add
            ((Ident.LAB (Symbol.find_symbol "1"), t),
             Map.add
               ((Ident.LAB (Symbol.find_symbol "2"), t),
                Map.empty_map,
                Ident.lab_lt),
             Ident.lab_lt)),
       t)
d1054 2
a1055 2
    (case Map.assoc record_map of
       (_, h) :: _ => (true, Types.the_type h)
d1059 2
a1060 2
    fun domain_tyname(Datatypes.CONSTYPE(_, tyname)) = (true, tyname)
    |   domain_tyname _ = (false, Types.int_tyname)
d2550 15
a2564 15
          let
            fun type_spills (Datatypes.CONSTYPE(tys,tyn)) =
              reducel (fn (spills,ty) => spills@@type_spills ty)
              (tyname_spills (denv,tyn),
               tys)
              | type_spills (Datatypes.FUNTYPE(ty1,ty2)) =
                type_spills ty1 @@ type_spills ty2
              | type_spills (Datatypes.RECTYPE map) =
                Datatypes.Mapping.fold (fn (spills,ty) => spills@@type_spills ty) (nil,map)
              | type_spills (Datatypes.METATYVAR(ref(_,ty,_),_,_)) = type_spills ty
              | type_spills (Datatypes.META_OVERLOADED {1=ref ty,...}) =
		type_spills ty
              | type_spills (Datatypes.TYVAR(ref(_,ty,_),_)) = type_spills ty
              | type_spills (Datatypes.METARECTYPE(ref(_,_,ty,_,_))) = type_spills ty
              | type_spills _ = nil
@


1.185
log
@Modify range checking to cope correctly with 16 bit integers and words
@
text
@d4 3
d527 2
d559 2
d606 2
d4562 16
d4584 5
a4588 11
	    val (v, ty,exception_name) = case ex of
	      Absyn.NEWexbind((v, ref ty), _,_,n) => (v, ty,n)
	    | Absyn.OLDexbind((v, ref ty), longv,_,n) => (v, ty,n)

	    val exn_string =
	      if exception_name = "" then
		case v of
		  Ident.EXCON x => Symbol.symbol_name x
		| _ => Crash.impossible "ExId is not EXCON"
	      else
		exception_name
@


1.184
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d903 1
a903 1
		      (Ident.INT ("128", Location.UNKNOWN), NONE)],
d913 1
a913 1
		      (Ident.INT ("255", Location.UNKNOWN), NONE)],
d929 1
a929 1
    val check_range_16 = check_range ("128", "255")
@


1.183
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
a576 2
  sharing Types.Datatypes.Option = AbsynPrint.Absyn.Option =
    Debugger_Types.RuntimeEnv.Option
a612 1
  structure Option = Datatypes.Option
d1344 1
a1344 1
              val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,Option.ABSENT)
d1539 2
a1540 2
      Option.ABSENT => result
    | Option.PRESENT interface =>
d1556 2
a1557 2
  fun interface_from_sigexp (Absyn.NEWsigexp(_, ref (Absyn.Option.PRESENT str))) = str
    | interface_from_sigexp (Absyn.OLDsigexp(_, ref (Absyn.Option.PRESENT str),_)) = str
d1599 1
a1599 1
      val null_runtimeinfo = RuntimeEnv.RUNTIMEINFO (Option.ABSENT,nil)
d1769 1
a1769 1
                  fun aux nil = Option.ABSENT
d1772 1
a1772 1
                        then Option.PRESENT lexp
d1780 1
a1780 1
                Option.PRESENT lexp => lexp
d2116 1
a2116 1
               Option.ABSENT => new_cg
d2119 2
a2120 2
             | Option.PRESENT (ref Datatypes.NO_INSTANCE) => new_cg
             | Option.PRESENT _ =>
d2123 1
a2123 1
                                  Option.ABSENT)))
d2127 2
a2128 2
              Datatypes.ZERO => Option.ABSENT
            | Datatypes.ONE i => Option.PRESENT i
d2143 1
a2143 1
                    Option.ABSENT =>
d2145 1
a2145 1
                  | Option.PRESENT i =>
d2157 2
a2158 2
                                                     Option.ABSENT => LambdaTypes.INT ~1
                                                   | Option.PRESENT i => LambdaTypes.INT i],
d2170 2
a2171 2
                       Option.ABSENT => LambdaTypes.VAR lv
                     | Option.PRESENT i =>
d2179 1
a2179 1
                           Option.ABSENT =>
d2185 1
a2185 1
                              Option.ABSENT)
d2209 2
a2210 2
                          Option.ABSENT => LambdaTypes.VAR lv
                        | Option.PRESENT i =>
d2311 1
a2311 1
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,MLWorks.Option.SOME _),Option.PRESENT tystr,_) =
d2313 1
a2313 1
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,MLWorks.Option.SOME _),Option.PRESENT tystr,_) =
d2318 2
a2319 2
      fun merge_dstrexps(dstr,Option.PRESENT(Datatypes.COPYSTR(_,str)), dstrexp, location) =
          merge_dstrexps(dstr,Option.PRESENT str,dstrexp, location)
d2321 1
a2321 1
                         Option.PRESENT(str as
d2351 1
a2351 1
                          merge_dstrexps(debugger_str,Option.PRESENT str,
d2365 1
a2365 1
                merge_dstrexps (debugger_str,Option.PRESENT str,LAMBDASTREXP(selects,lv,str'), location)
d2381 4
a2384 4
                                        Option.PRESENT(NewMap.apply'(tyconmap'',tc')), location)))
                     (NewMap.map (fn (v,Option.ABSENT) => merge_dexps (EnvironTypes.NULLEXP,
                                             (NewMap.apply' (validmap',v)),Option.ABSENT, location)
                                  | (v,Option.PRESENT i) =>
d2386 1
a2386 1
                                                  NewMap.apply' (validmap',v),Option.ABSENT, location))
d2390 1
a2390 1
                                                Option.PRESENT(NewMap.apply' (stridmap'',strid)),
d2397 1
a2397 1
                                  Option.PRESENT(NewMap.apply'(tyconmap'',Ident.TYCON tc)), location)
d2401 1
a2401 1
                                                Option.PRESENT(NewMap.apply' (stridmap'',strid)),
d2405 1
a2405 1
        | merge_dstrexps(ref Datatypes.EMPTY_DSTR, Option.ABSENT, dstrexp, _) = dstrexp
d2513 3
a2515 3
      fun fetch_interface(Option.PRESENT(ref(Option.PRESENT interface))) = interface
        | fetch_interface(Option.PRESENT _) =
          Crash.impossible "1:Option.ABSENT:fetch_interface:lambda"
d2517 1
a2517 1
          Crash.impossible "2:Option.ABSENT:fetch_interface:lambda"
d2522 2
a2523 2
        fun fetch_debugger_str (Option.PRESENT debugger_str) = debugger_str
          | fetch_debugger_str Option.ABSENT = empty_dstr
d2526 3
a2528 3
      fun fetch_tyfun (Option.PRESENT tyfun) = tyfun
        | fetch_tyfun Option.ABSENT =
          Crash.impossible "Option.ABSENT:fetch_tyfun:lambda"
d2657 1
a2657 1
                                                     Option.PRESENT spill))),
d3410 1
a3410 1
                    Option.PRESENT (s,_) => s
d3608 2
a3609 2
                       Option.PRESENT lvar => lvar
                     | Option.ABSENT => (new_LVar(), LambdaTypes.INT 1)
d3738 1
a3738 1
                      trans_exp(" match_leaf", exp, env, denv, Option.PRESENT (fnname,fnname_lv))
d3756 1
a3756 1
					  Option.ABSENT)
d3787 1
a3787 1
				    varinforef := RuntimeEnv.VARINFO (Symbol.symbol_name symbol,ty,Option.ABSENT);
d3828 1
a3828 1
						Option.ABSENT)
d4048 1
a4048 1
            lvar_let_lambdas_in_exp (lambda_exp3, binding, Option.ABSENT)
d4052 1
a4052 1
                lvar_let_lambdas_in_exp (lambda_exp1, binding, Option.ABSENT)
d4055 1
a4055 1
                lvar_let_lambdas_in_exp (lambda_exp2, binding, Option.PRESENT(new_lv,new_le))
d4093 1
a4093 1
                                     Option.ABSENT)
d4139 1
a4139 1
                             Location.UNKNOWN, ref (Datatypes.ZERO, Absyn.Option.ABSENT)),
d4170 1
a4170 1
                                Option.ABSENT)
d4184 1
a4184 1
                   RuntimeEnv.NOVARINFO,Option.ABSENT)
d4197 1
a4197 1
                                               stuff,Option.ABSENT),
d4219 1
a4219 1
                        ], RuntimeEnv.NOVARINFO, Option.ABSENT)
d4238 1
a4238 1
                        Option.ABSENT)
d4276 1
a4276 1
                   Option.ABSENT)
d4298 1
a4298 1
			     Option.ABSENT)
d4333 1
a4333 1
			       Option.ABSENT)
d4358 1
a4358 1
                        Option.ABSENT)
d4375 1
a4375 1
                        lambda,RuntimeEnv.VARINFO (Symbol.symbol_name vid,stuff,Option.ABSENT),
d4845 1
a4845 1
            complete_struct((env, arg), Option.PRESENT interface, !coerce, generate_moduler)
d4863 1
a4863 1
                                                                     Option.PRESENT interface,dstrexp,
d4934 3
a4936 3
	    Absyn.Option.ABSENT => Option.ABSENT
          | Absyn.Option.PRESENT sigexp =>
	      Option.PRESENT (interface_from_sigexp sigexp)
d4952 1
a4952 1
                                      Option.PRESENT(fetch_interface interface'),dstrexp, location)))
d4972 3
a4974 3
	    Absyn.Option.ABSENT => Option.ABSENT
          | Absyn.Option.PRESENT sigexp =>
	      Option.PRESENT (interface_from_sigexp sigexp)
d4990 1
a4990 1
                                      Option.PRESENT(fetch_interface interface'),dstrexp, location)))
d5046 3
a5048 3
	Absyn.Option.ABSENT => Option.ABSENT
      | Absyn.Option.PRESENT sigexp =>
	  Option.PRESENT (interface_from_sigexp sigexp)
d5073 1
a5073 1
          Option.ABSENT)
d5161 1
a5161 1
            trans_str_dec(strdec, top_env, top_denv, true, Option.ABSENT)
@


1.182
log
@Remove Default type constructor and its value constructors PRESENT and ABSENT
Use MLWorks.Option.option instead
@
text
@d4 4
a573 1
    Environ.EnvironTypes.LambdaTypes.Option =
d1561 1
a1561 1
  type MatchEnv = (LambdaTypes.LVar * LambdaTypes.VarInfo ref LambdaTypes.Option.opt) IntNewMap.T
d1691 1
a1691 1
                lv,Option.ABSENT)
d1706 1
a1706 1
                                        ::selects,lv,Option.ABSENT)
d1769 1
a1769 1
                    | aux ((_,lexp as EnvironTypes.LAMBDAEXP(_,_,Option.PRESENT(tyfun')))::rest) =
d1784 1
a1784 1
                        EnvironTypes.LAMBDAEXP(rev (str_lookup str) @@ selects,lv,Option.ABSENT)
d1786 1
a1786 1
                        EnvironTypes.LAMBDAEXP' (rev (str_lookup str) @@ selects,lv,Option.ABSENT)
d1806 1
a1806 1
                fun find_tyfun nil _ = Option.ABSENT
d1808 1
a1808 1
                    if tyfun = fetch_ntf tystr then Option.PRESENT n
d1813 1
a1813 1
                  Option.PRESENT n =>
d1874 1
a1874 1
               Option.PRESENT(fetch_ntf tystr)))))
d1887 1
a1887 1
                                      ::selects,lv,Option.ABSENT))))
d2310 4
a2313 4
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,Option.PRESENT _),Option.PRESENT tystr,_) =
          EnvironTypes.LAMBDAEXP(selects,lv,Option.PRESENT(fetch_ntf tystr))
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,Option.PRESENT _),Option.PRESENT tystr,_) =
          EnvironTypes.LAMBDAEXP'(selects,lv,Option.PRESENT(fetch_ntf tystr))
d2345 1
a2345 1
                  Option.PRESENT(fetch_ntf tystr)))))
d2360 1
a2360 1
                                                       ::selects,lv,Option.ABSENT))))
@


1.181
log
@Improvements to local variable debugging mechanism
@
text
@d4 3
d507 1
d537 1
d933 1
a933 1
	       MLWorks.Option.NONE,
d973 1
a973 1
	       MLWorks.Option.NONE,
d1033 1
a1033 1
    MLWorks.Option.SOME (Lists.assoc (s, derived_overload_table))
d1035 1
a1035 1
      Lists.Assoc => MLWorks.Option.NONE
d1433 1
a1433 1
		MLWorks.Option.SOME ty => (false, res)
d1441 1
a1441 1
                    MLWorks.Option.SOME ty =>
d2647 2
a2648 2
          let_lambdas_in_exp(
           map (fn (_,spill,tyfun) =>
d2655 2
a2656 2
           (!tyfun_spills_ref),
           lexp)
d2828 1
a2828 1
				   MLWorks.Option.SOME prim' => prim = prim'
d2848 2
a2849 2
			     of MLWorks.Option.NONE => true
			     |  MLWorks.Option.SOME sz =>
d2856 1
a2856 1
			       MLWorks.Option.NONE
d2859 2
a2860 2
			   of MLWorks.Option.SOME cg => cg ()
			   |  MLWorks.Option.NONE =>
d2930 1
a2930 1
		       MLWorks.Option.SOME prim => LambdaTypes.BUILTIN prim
d3163 1
a3163 1
               MLWorks.Option.SOME missing_constructors =>
d3279 102
d3589 2
a3590 2
               | ensure_default exp = exp
                fun lvar_let_lambdas_in_exp (lambda_exp,bindings,lvar_info) =
d3607 1
a3607 1
                     | do_binding (MLWorks.Option.INL (ref MLWorks.Option.NONE)::bindings) =
d3609 1
a3609 1
                     | do_binding (MLWorks.Option.INL (ref (MLWorks.Option.SOME (lvar as ref(MLWorks.Option.INL(_,tree)))))::bindings) =
d3618 22
a3639 4
                       in
                         (lvar := MLWorks.Option.INR lv; (* Something to do with match compilation *)
                          LambdaTypes.LETB
                          (lv,NONE,
d3642 3
a3644 16
                            LambdaTypes.FN([new_LVar()],
                              let
                                val old_null_tyfun_spills = store_null_tyfun_spills()
                                val tr_match =
                                   (init_null_tyfun_spills();
                                    make_null_tyfun_spills(tr_match(tree,match_env,val_env)))
                                val _ = restore_null_tyfun_spills old_null_tyfun_spills
                              in
                                ensure_default tr_match
                              end,
                            match_fnname,
                            LambdaTypes.null_type_annotation, (* Or we could pass in the free variables and get a type *)
                            RuntimeEnv.INTERNAL_FUNCTION)))
                          end ::
                        do_binding bindings
                     | do_binding (MLWorks.Option.INL _::_) =
d3646 1
a3646 1
                     | do_binding (MLWorks.Option.INR(lvar' as ref (MLWorks.Option.INL (_,tree)),matchvar)::bindings) =
d3651 31
d3683 6
a3688 30
                         (lvar' := MLWorks.Option.INR lv; (* Something to do with match compilation *)
                          LambdaTypes.LETB
                          (lv,NONE,
                           (* This where default functions are created *)
                            LambdaTypes.FN([new_LVar()],
                              let
                                val old_null_tyfun_spills = store_null_tyfun_spills()
                                val tr_match =
                                   (init_null_tyfun_spills();
                                    make_null_tyfun_spills
                                    (case matchvar of
                                        ~1 => tr_match(tree, match_env, val_env)
                                      | _ =>
                                          LambdaTypes.LET
					    ((this_lvar,NONE,this_lexp),
                                             tr_match
					       (tree,
                                                add_match_env
                                                  ((matchvar,(this_lvar,NONE)),
                                                   match_env),
                                                val_env))))
                                val _ = restore_null_tyfun_spills old_null_tyfun_spills
                              in
                                ensure_default tr_match
                              end,
                            match_fnname,
                            LambdaTypes.null_type_annotation, (* Or we could pass in the free variables and get a type *)
                            RuntimeEnv.INTERNAL_FUNCTION)))
                          end::do_binding bindings
                     | do_binding (MLWorks.Option.INR _::_) =
d3693 37
a3729 23
                fun Tr_Default default =
		  let
		    fun Tr_Default (ref(Match.BUILT(ref(MLWorks.Option.INR lvar)))) =
		      SOME(LambdaTypes.APP(LambdaTypes.VAR lvar, [unit_exp], NONE))
		      | Tr_Default (ref(Match.BUILT(ref(MLWorks.Option.INL(0,tree))))) =
			SOME
			  (init_null_tyfun_spills();
			   make_null_tyfun_spills
			     (tr_match(tree, match_env, val_env)))
		      | Tr_Default (ref(Match.ERROR _)) =
			SOME excp
		      |  Tr_Default _ = Crash.impossible "1:Tr_Default:tr_match:_lambda.sml"
                  in
		    case default of
		      MLWorks.Option.INL (Match.PRESENT default) => Tr_Default default
		    | MLWorks.Option.INL Match.ABSENT => NONE
		    | MLWorks.Option.INR (ref (MLWorks.Option.INR lvar)) =>
			SOME (LambdaTypes.APP
				(LambdaTypes.VAR lvar, [unit_exp], NONE))
		    | MLWorks.Option.INR _ =>
			Crash.impossible "2:Tr_Default:tr_match:_lambda.sml"
                  end
            in
d3812 1
a3812 1
			       Tr_Default (MLWorks.Option.INL(Match.PRESENT default))
d3820 5
a3824 5
                    lvar_let_lambdas_in_exp (lambda_exp,
                                             case binding of
                                               MLWorks.Option.NONE => []
                                             | MLWorks.Option.SOME bd =>[MLWorks.Option.INL bd],
                                             Option.ABSENT)
d3863 1
a3863 1
                    fun tr_match'(MLWorks.Option.INL tree,match_env, val_env) =
d3865 12
a3876 5
                      | tr_match'(MLWorks.Option.INR(ref(MLWorks.Option.INR lvar)),_, _) =
                        LambdaTypes.APP(LambdaTypes.VAR lvar,
                                        [unit_exp],
                                        NONE)
                      | tr_match'(MLWorks.Option.INR _, _, _) =
d3928 1
a3928 1
			MLWorks.Option.SOME Pervasives.REF =>
d4027 1
a4027 1
	        LambdaTypes.SWITCH(
d4081 1
a4081 1
              case Tr_Default (MLWorks.Option.INL(Match.PRESENT default)) of
d4087 2
a4088 2
                                       MLWorks.Option.NONE => []
                                     | MLWorks.Option.SOME bd => [MLWorks.Option.INL bd],
d4110 1
a4110 1
  end (* end of trans_match? *)
d4280 1
a4280 1
			MLWorks.Option.SOME Pervasives.REF =>
@


1.180
log
@Corrected the types given to the derived operations on small integer and
word types.  (This bug only manifested when generating debug info).
@
text
@d4 4
d526 1
a526 1
    
d553 1
a553 1
  sharing LambdaOptimiser.LambdaTypes = 
d561 1
a561 1
  sharing Match.Options = Types.Options = AbsynPrint.Options = 
d564 2
a565 2
  sharing Types.Datatypes.Option = AbsynPrint.Absyn.Option = 
    Environ.EnvironTypes.LambdaTypes.Option = 
d575 1
a575 1
  sharing type Debugger_Types.Type = LambdaPrint.LambdaTypes.Type 
d582 1
a582 1
  sharing type LambdaPrint.LambdaTypes.DebuggerStr = Types.Datatypes.DebuggerStr 
d626 1
a626 1
  fun reducel f = 
d630 1
a630 1
    in 
d686 1
a686 1
                   
d691 1
a691 1
  fun make_longid (path,name) = 
d703 1
a703 1
    | select_exn_unique lexp = 
d728 1
a728 1
	LambdaTypes.VAR l, 
d776 4
a779 4
          if flex 
            then record_domain ty 
          else 
            Crash.impossible 
d784 1
a784 1
          if flex 
d864 1
a864 1
   * The integer operations for sizes less than the size of the default 
d888 1
a888 1
               [LambdaTypes.STRUCT 
d894 1
a894 1
  
d898 1
a898 1
               [LambdaTypes.STRUCT 
d928 1
a928 1
	       MLWorks.Option.NONE, 
d950 1
a950 1
	   ([LambdaTypes.VAR var, 
d955 1
a955 1
  
d968 1
a968 1
	       MLWorks.Option.NONE, 
d1117 1
a1117 1
      val (env', field) = 
d1127 1
a1127 1
      val (env', field, _) = 
d1135 1
a1135 1
  fun cg_longvalid (longvalid, env) = 
d1176 1
a1176 1
             (LambdaTypes.BUILTIN prim, 
d1200 1
a1200 1
    case longstrid of 
d1203 1
a1203 1
           (env, EnvironTypes.LAMB (lvar,longstrid), moduler_generated) => 
d1212 2
a1213 2
                 NONE), 
              EnvironTypes.NOSPEC, 
d1235 1
a1235 1
  fun is_eq_prim(LambdaTypes.BUILTIN Pervasives.EQ) = true 
d1310 1
a1310 1
      (interface as Datatypes.STR (_, _, 
d1318 2
a1319 2
    
   (if not coerce andalso compare_sig_env generate_moduler (interface, env) 
d1323 1
a1323 1
        (* This function matches a structure against a signature.  It produces a 
d1331 1
a1331 1
        val vm = 
d1337 1
a1337 1
              NewMap.fold 
d1353 1
a1353 1
                if Ident.valid_eq (x, z) 
d1356 1
a1356 1
            
d1361 1
a1361 1
                if Ident.strid_eq (x, z) 
d1366 1
a1366 1
          (* 
d1424 1
a1424 1
          let 
d1441 1
a1441 1
                  let 
d1473 1
a1473 1
          map 
d1476 1
a1476 1
           (lv,NONE, 
d1542 1
a1542 1
                                                     lambda_exp), 
d1564 1
a1564 1
  fun trans_top_dec 
d1570 1
a1570 1
                           {generate_debug_info, 
d1607 1
a1607 1
          look for longvalid in the debugger environment 
d1636 1
a1636 1
            | aux (path,EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) = 
d1657 1
a1657 1
            | aux(path,EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) = 
d1685 1
a1685 1
            | aux (EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) = 
d1700 1
a1700 1
            | aux(EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) = 
d1707 1
a1707 1
      fun dlookup_longvalid (longvalid, denv) = 
d1719 1
a1719 1
               EnvironTypes.DENV(_,strmap) => 
d1724 1
a1724 1
                     (fn () => 
d1730 1
a1730 1
            
d1762 1
a1762 1
                      if tyfun = tyfun' 
d1772 2
a1773 2
              | _ => 
                  let 
d1807 1
a1807 1
                | _ => 
d1822 1
a1822 1
      
d1837 1
a1837 1
                EnvironTypes.DENV(_,strmap) => 
d1945 1
a1945 1
                val new_env = 
d1949 1
a1949 1
                        EnvironTypes.LAMB(lvar,_) => 
d2041 1
a2041 1
            | aux ({index,size}::rest) = 
d2050 1
a2050 1
        | dexp_to_lambda (EnvironTypes.INT i) = 
d2083 2
a2084 2
      val dexps_ref : 
        ({index : int, size : int} list * 
d2096 1
a2096 1
            | instance_to_lambda (Datatypes.ONE i) = 
d2098 1
a2098 1
            | instance_to_lambda (Datatypes.TWO (i,i')) = 
d2105 1
a2105 1
          fun make_instance () = 
d2134 1
a2134 1
                    Option.ABSENT => 
d2136 1
a2136 1
                  | Option.PRESENT i => 
d2144 1
a2144 1
          | EnvironTypes.LAMBDAEXP' _ => 
d2170 1
a2170 1
                           Option.ABSENT => 
d2227 1
a2227 1
                             
d2312 1
a2312 1
                         Option.PRESENT(str as 
d2318 1
a2318 1
            fun merge_lambdastrexps LAMBDAEXP LAMBDASTREXP(selects,lv,str' as 
d2365 1
a2365 1
                 Datatypes.DSTR(stridmap,tyconmap,validmap) => 
d2398 1
a2398 1
          
d2438 1
a2438 1
        
d2488 1
a2488 1
 
d2530 1
a2530 1
            fun type_spills (Datatypes.CONSTYPE(tys,tyn)) = 
d2552 1
a2552 1
              fun tyname_spills 
d2590 1
a2590 1
                                   spills@@typescheme_spills (denv,tysch)) (nil,ve)))                  
d2598 1
a2598 1
                                   spills@@typescheme_spills (denv,tysch)) (nil,ve)))                  
d2602 2
a2603 2
                    val (ve',ve) = 
                      (*if Datatypes.NewMap.is_empty ve4 then 
d2611 1
a2611 1
                  end 
d2620 1
a2620 1
                             location) = 
d2622 1
a2622 1
        else 
d2643 1
a2643 1
           map (fn (_,spill,tyfun) => 
d2687 1
a2687 1
          fn denvir => 
d2705 1
a2705 1
                                                   (init_null_tyfun_spills(); 
d2727 1
a2727 1
                  val new_env = 
d2731 1
a2731 1
                  val new_binding = 
d2740 1
a2740 1
                                      (init_null_tyfun_spills(); 
d2755 2
a2756 2
      fun make_binding (lv,debug_info,instance,lexp,comment,location) = 
        if variable_debug 
d2828 2
a2829 2
                     val cg = 
                       if env_ol then 
d2911 1
a2911 1
                     if built_in then 
d2967 1
a2967 1
                         LambdaTypes.FN([lv], 
d2977 1
a2977 1
                 
d3004 1
a3004 1
            
d3010 2
a3011 2
            trans_exp(" no_name", exp, Environ.augment_env(env, env'), 
                      augment_denv(denv, denv'), 
d3014 1
a3014 1
      
d3018 1
a3018 1
          val fcn = 
d3027 1
a3027 1
              
d3030 1
a3030 1
              val arg = 
d3074 1
a3074 1
          else 
d3080 1
a3080 1
    | Absyn.TYPEDexp (expression, _,_) => 
d3083 1
a3083 1
    | Absyn.RAISEexp (exp,_) => 
d3087 1
a3087 1
        
d3109 1
a3109 1
                   (dynamic_report_required,dynamic_str)) = 
d3134 1
a3134 1
        
d3179 1
a3179 1
                      (dynamic_report_required,dynamic_str)) = 
d3207 1
a3207 1
            val _ = 
d3221 1
a3221 1
            
d3231 1
a3231 1
          handle TyperepUtils.ConvertDynamicType => 
a3232 1
      
d3234 1
a3234 1
          trans_exp (name, TyperepUtils.make_coerce_expression (exp,atype), 
d3252 1
a3252 1
                into the labelled cases or the default. 
d3261 1
a3261 1
                   mentioned etc. 
d3263 1
a3263 1
                   
d3266 1
a3266 1
          let 
d3270 1
a3270 1
              fun new_match_trans() = 
d3295 3
a3297 3
            val fnname = 
              let 
                val name = 
d3386 2
a3387 2
                              let 
                                val newlongstrid = 
d3503 1
a3503 1
                       let 
d3505 1
a3505 1
                         val match_fnname = 
d3517 1
a3517 1
                            LambdaTypes.FN([new_LVar()], 
d3530 1
a3530 1
                          end :: 
d3535 1
a3535 1
                       let 
d3537 1
a3537 1
                         val match_fnname = 
d3544 1
a3544 1
                            LambdaTypes.FN([new_LVar()], 
d3574 1
a3574 1
                fun Tr_Default default = 
d3576 1
a3576 1
		    fun Tr_Default (ref(Match.BUILT(ref(MLWorks.Option.INR lvar)))) = 
d3583 1
a3583 1
		      | Tr_Default (ref(Match.ERROR _)) = 
d3590 1
a3590 1
		    | MLWorks.Option.INR (ref (MLWorks.Option.INR lvar)) => 
d3604 1
a3604 1
                            (lv, NONE) => 
d3608 1
a3608 1
                                 Ident.VAR symbol =>  
d3610 4
d3625 2
a3626 2
                                       do_leaf(tl, 
                                               Environ.add_valid_env(env, 
d3631 1
a3631 1
                               | _ => 
d3639 1
a3639 1
                          | (lv, SOME varinforef) => 
d3641 4
d3646 1
a3646 1
                                 Ident.VAR symbol => 
d3648 3
a3650 1
                                   (varinforef := RuntimeEnv.VARINFO (Symbol.symbol_name symbol,ty,Option.ABSENT);
d3656 1
d3660 1
a3660 1
                
d3663 1
a3663 1
                   fun lambda_exp() = 
d3760 2
a3761 6
                          let 
                            val info = 
                              if variable_debug andalso not generate_moduler
                                (* Huh? *)
                                then SOME (ref RuntimeEnv.NOVARINFO)
                              else NONE
d3771 1
a3771 1
                    fun lambda_exp1() = 
d3789 1
a3789 1
			  let 
d3791 1
a3791 5
			    val info = 
			      if variable_debug andalso not generate_moduler 
				(* Huh? *)
				then SOME (ref RuntimeEnv.NOVARINFO)
			      else NONE
d3844 1
a3844 1
                    val default = 
d3854 3
a3856 7
          fun lambda_exp2() = 
            let 
              val info = 
                if variable_debug andalso not generate_moduler 
                  (* Huh? *)
                  then SOME (ref RuntimeEnv.NOVARINFO)
                else NONE
d3883 1
a3883 1
          fun lambda_exp3() = 
d3907 1
a3907 1
              false => (* Not an exception constructor *) 
d3914 1
a3914 1
	let 
d3916 1
a3916 1
            if variable_debug then 
d3918 1
a3918 4
                if generate_moduler then
                   (new_LVar(), NONE)
                else
                   (new_LVar(), SOME (ref RuntimeEnv.NOVARINFO))))
d3920 2
a3921 2
            else 
              map 
d3989 1
a3989 1
          let 
d3994 1
a3994 1
               Absyn.VALexp (mklongvalid valid,ref ty, 
d4000 1
a4000 1
            trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set), 
d4007 1
a4007 1
          DATATYPEdec_spills 
d4015 1
a4015 1
    
d4019 1
a4019 2
      let 
            
d4021 1
a4021 1
          let 
d4037 1
a4037 1
                          [(LambdaTypes.SCON_TAG (scon, Types.sizeof ty), 
d4042 1
a4042 1
            | Absyn.VALpat ((longvalid as Ident.LONGVALID(path, valid), 
d4045 1
a4045 1
                   Ident.VAR symbol => 
d4047 1
a4047 1
                        Ident.NOPATH => 
d4049 1
a4049 1
                              EnvironTypes.LAMB(lambda_var, EnvironTypes.NOSPEC))), 
d4051 1
a4051 1
                              EnvironTypes.NULLEXP)), [], 
d4071 1
a4071 1
                                    [(LambdaTypes.IMM_TAG (valid_name valid,tag), 
d4077 1
a4077 1
                 | Ident.EXCON excon => 
d4108 2
a4109 2
                    (fn (pat, lv, le) => 
                     let 
d4119 1
a4119 1
                  (Lists.exists (fn (has_vars, _, _, _, _) => has_vars) 
d4121 1
a4121 1
                   Lists.forall (fn (_, exhaustive, _, _, _) => exhaustive) 
d4123 1
a4123 1
                   reducel (fn (env, (_, _, env', _, _)) => 
d4126 1
a4126 1
                   reducel (fn (env, (_, _, _, env', _)) => 
d4134 1
a4134 1
            | Absyn.APPpat((longvalid, ref ty), pat,_,_) => 
d4141 1
a4141 1
			  let 
d4143 1
a4143 1
			    val (has_vars, exhaustive, new_env, new_denv, new_lambda_exp, 
d4160 1
a4160 1
			    let 
d4193 1
a4193 1
                     let 
d4209 1
a4209 1
                       (has_vars, false, new_env, new_denv, (* Never exhaustive *) 
d4218 1
a4218 1
            | Absyn.TYPEDpat(typed, _,_) => 
d4225 1
a4225 1
                       val (_, exhaustive, env, denv, lambda,_,_) = 
d4227 1
a4227 1
                     in 
d4241 1
a4241 1
                  val (has_vars, exhaustive, more_env, more_denv, more_lambda,debug_info,instance) = 
d4258 1
a4258 1
                  val (more_env, more_denv, updated) = 
d4269 1
a4269 1
                  val _ = map 
d4282 1
a4282 1
                    else 
d4290 3
a4292 3
                  val lv_pat_exp_list = 
                    if variable_debug 
                      then 
d4294 1
a4294 1
                        (fn (pat, exp, location) => 
d4301 1
a4301 1
                    else 
d4309 1
a4309 1
                       val (has_vars, exhaustive, env, denv, le, debug_info,instance) = 
d4316 1
a4316 1
                            Info.error error_info (Info.WARNING, location, 
d4321 1
a4321 1
                           Info.error error_info (Info.WARNING, location, 
d4328 1
a4328 1
                       val (has_vars, exhaustive, env, denv, le, debug_info,instance) = 
d4333 1
a4333 1
                            Info.error error_info (Info.WARNING, location, 
d4338 1
a4338 1
                           Info.error error_info (Info.WARNING, location, 
d4345 1
a4345 1
                  val all_env = 
d4347 1
a4347 1
                  val all_denv = 
d4360 1
a4360 1
                  val recletb = 
d4364 1
a4364 1
                                          trans_exp(pat_name pat, exp, trans_env, 
d4389 1
a4389 1
    | Absyn.ABSTYPEdec (_,datatypeinfo_list, dec) => 
d4436 1
a4436 1
                                             runtime_env = Debugger_Types.empty_runtime_env, 
d4484 1
a4484 1
	    do_exns(exns, Environ.augment_env(env, this_env), 
d4506 1
a4506 1
	  trans_dec(dec2, Environ.augment_env(envir, local_env), false, 
d4557 1
a4557 1
	     val new_v_lambdas = 
d4561 1
a4561 1
                 | (_, EnvironTypes.PRIM prim, l) => 
d4571 1
a4571 1
             | (_, (_, EnvironTypes.PRIM prim, _), l) => 
d4589 1
a4589 1
	trans_sequence_dec(envir, Environ.empty_env, denvir, empty_denv, 
d4595 1
a4595 1
    | trans_sequence_dec(old_env, new_env, old_denv, new_denv, 
d4607 1
a4607 1
  fun wrapped_trans_dec (dec, env, is_toplevel, denv, fnname) = 
d4621 1
a4621 1
         (!tyfun_lvars_ref) 
d4624 1
a4624 1
              LambdaTypes.LETB(lvar,NONE, lexp)) 
d4635 1
a4635 1
         (!redundant_exceptions_ref) 
d4643 1
a4643 1
           | dynamic_report => 
d4658 1
a4658 1
        let 
d4665 1
a4665 1
    | Absyn.OLDstrexp (longstrid,_,interface) => 
d4687 1
a4687 1
      
d4690 1
a4690 1
          val (lv, result_env as EnvironTypes.ENV(valid_env, strid_env), moduler_generated) = 
d4762 2
a4763 2
        let 
          val (local_env, local_denv, local_lambdas) = 
d4771 2
a4772 2
          (new_env, 
           let_lambdas_in_exp(local_lambdas, new_lambda), 
d4776 1
a4776 1
  and trans_str_dec(strdec, top_env as EnvironTypes.TOP_ENV(env, _), 
d4793 1
a4793 1
          val (str_env, lambda_exp, dstrexp) = 
d4805 1
a4805 1
           if generate_moduler then 
d4810 1
a4810 1
            LambdaTypes.LETB(lambda_var,NONE,lambda_exp) 
d4831 1
a4831 1
          val (str_env, lambda_exp, dstrexp) = 
d4848 1
a4848 1
            LambdaTypes.LETB(lambda_var, NONE,lambda_exp) 
d4856 1
a4856 1
      val (local_env, local_denv, local_lambda) = 
d4869 1
a4869 1
      trans_sequence_strdec(top_env, Environ.empty_env, 
d4874 1
a4874 1
    | trans_sequence_strdec 
d4881 1
a4881 1
			      Environ.augment_env(new_env, env), 
d4890 1
a4890 1
	   (funid, strid, sigexp, strexp, sigexp_opt, 
d4981 2
a4982 2
 
  fun trans_fun_dec([], _, _) = (make_top_env Environ.empty_env, 
d4994 1
a4994 1
  fun trans_fun_dec_list([], _, _) = (make_top_env Environ.empty_env, 
d5012 1
a5012 1
  val (a,b,c) = 
d5016 1
a5016 1
          val (new_env, new_denv, lambdas) = 
d5032 2
a5033 2
    map 
    (fn (ref(EnvironTypes.LVARFOO lv),interface) => 
d5044 1
a5044 1
        reducel 
d5058 1
a5058 1
        
@


1.179
log
@Changed the implementation of short word and int operations to be
functions, to ensure that new LVars are created for each operation.
@
text
@d4 4
d866 12
d935 4
a938 2
    val int8_op = overloaded_int_op (check_range_8, Types.int8_type)
    val int16_op = overloaded_int_op (check_range_16, Types.int16_type)
d975 4
a978 2
    val word8_op = overloaded_word_op (clamp_word_8, Types.word8_type)
    val word16_op = overloaded_word_op (clamp_word_16, Types.word16_type)
@


1.178
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d899 1
a899 1
    fun overloaded_int_op (check_range, result_type) opcode =
d937 1
a937 1
    fun overloaded_word_op (clamp_word, result_type) opcode =
d969 4
a972 4
     ("_int8<", LambdaTypes.BUILTIN Pervasives.INTLESS),
     ("_int8<=", LambdaTypes.BUILTIN Pervasives.INTLESSEQ),
     ("_int8>", LambdaTypes.BUILTIN Pervasives.INTGREATER),
     ("_int8>=", LambdaTypes.BUILTIN Pervasives.INTGREATEREQ),
d978 4
a981 4
     ("_word8<", LambdaTypes.BUILTIN Pervasives.WORDLT),
     ("_word8<=", LambdaTypes.BUILTIN Pervasives.WORDLE),
     ("_word8>", LambdaTypes.BUILTIN Pervasives.WORDGT),
     ("_word8>=", LambdaTypes.BUILTIN Pervasives.WORDGE),
d989 4
a992 4
     ("_int16<", LambdaTypes.BUILTIN Pervasives.INTLESS),
     ("_int16<=", LambdaTypes.BUILTIN Pervasives.INTLESSEQ),
     ("_int16>", LambdaTypes.BUILTIN Pervasives.INTGREATER),
     ("_int16>=", LambdaTypes.BUILTIN Pervasives.INTGREATEREQ),
d998 4
a1001 4
     ("_word16<", LambdaTypes.BUILTIN Pervasives.WORDLT),
     ("_word16<=", LambdaTypes.BUILTIN Pervasives.WORDLE),
     ("_word16>", LambdaTypes.BUILTIN Pervasives.WORDGT),
     ("_word16>=", LambdaTypes.BUILTIN Pervasives.WORDGE)]
d2830 1
a2830 1
			   of MLWorks.Option.SOME cg => cg
@


1.177
log
@Changes to printing of redundancy information
@
text
@d4 3
d501 1
d532 1
d609 2
d718 1
a718 1
	Option.PRESENT {num_imms = 2, num_vccs = 0},
d721 1
a721 1
	Option.ABSENT),
d849 156
d1011 2
a1012 2
  fun domain_tyname(Datatypes.CONSTYPE(_, tyname)) = (true, tyname)
    | domain_tyname _ = (false, Types.int_tyname)
d1015 18
a1032 5
  fun domain_type_name ty =
    case domain_tyname ty of
      (true, Datatypes.TYNAME{2=s,...}) => (true, s)
    | (true, Datatypes.METATYNAME{2=s,...}) => (true, s)
    | _ => (false, "Not fun(rec)")
d1057 5
a1061 4
	  (env', LambdaTypes.APP
	   (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	    [LambdaTypes.SCON (Ident.STRING (Symbol.symbol_name sy))],
	    Option.ABSENT))
d1075 6
a1080 4
	  (env', LambdaTypes.APP
	   (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	    [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))],
	    Option.ABSENT), EnvironTypes.NOSPEC, moduler_generated)
d1111 1
a1111 1
        (case Environ.lookup_valid(valid, env) of
d1119 2
a1120 2
                             [LambdaTypes.SCON(Ident.STRING(valid_name valid))],
                             Option.ABSENT)
d1122 3
d1130 1
a1130 1
          case Environ.lookup_valid(valid, env') of
d1136 5
a1140 1
              Crash.impossible "cg_longvalid gets external at end of longvalid"
d1153 2
a1154 2
                             [LambdaTypes.SCON(Ident.STRING(valid_name valid))],
                             Option.ABSENT),
d1183 3
a1185 3
	      (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	       [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))],
               Option.ABSENT), 
d1434 1
a1434 1
           (lv,Option.ABSENT,
d1438 1
a1438 1
                LambdaTypes.LETB(lv,Option.ABSENT,coerce (valid,LambdaTypes.BUILTIN prim))
d1449 1
a1449 1
           (lv,Option.ABSENT, 
d1452 1
a1452 1
             (lv',Option.ABSENT,
d1514 1
a1514 1
	     LambdaTypes.do_binding(LambdaTypes.LETB(new_lv,Option.ABSENT,
d1953 1
a1953 1
                  LambdaTypes.LET((new_cg,Option.ABSENT,
d1956 1
a1956 1
                   LambdaTypes.LET((dexp',Option.ABSENT,
d1959 1
a1959 1
                     LambdaTypes.LET((instance_var,Option.ABSENT,
d1962 37
a1998 27
                       LambdaTypes.LET((lvar,Option.ABSENT,LambdaTypes.VAR dexp'),
                          LambdaTypes.SWITCH(LambdaTypes.VAR lvar,
                                             Option.PRESENT {num_vccs=1,num_imms=1},
                                             [(LambdaTypes.IMM_TAG ("ABSENT",0),
                                               LambdaTypes.VAR new_cg),
                                              (LambdaTypes.VCC_TAG("PRESENT",1),
                                               LambdaTypes.APP
                                               (LambdaTypes.VAR new_cg,
                                                [let
                                                  val lexp = LambdaTypes.SELECT({index=1,
                                                                                 size=2,
                                                                                 selecttype=LambdaTypes.CONSTRUCTOR},
                                                    LambdaTypes.VAR lvar)
                                                in
                                                  (* What is this doing? *)
                                                  LambdaTypes.SWITCH(LambdaTypes.VAR instance_var,
                                                                     Option.ABSENT,
                                                                     [(LambdaTypes.SCON_TAG (Ident.INT ("~1", Location.UNKNOWN)),
                                                                       LambdaTypes.STRUCT([LambdaTypes.INT 0, lexp],
                                                                                          LambdaTypes.CONSTRUCTOR))],
                                                                     Option.PRESENT(LambdaTypes.STRUCT([LambdaTypes.INT 1,
                                                                                                        LambdaTypes.STRUCT([lexp,
                                                                                                                            LambdaTypes.VAR instance_var],
                                                                                                        LambdaTypes.TUPLE)],
                                                                     LambdaTypes.CONSTRUCTOR)))
                                                end],
                                                Option.ABSENT))],Option.ABSENT))))),
d2002 1
a2002 1
                [LambdaTypes.LETB(lv,Option.ABSENT,lexp)],
d2036 1
a2036 1
                                        Option.ABSENT))
d2045 5
a2049 3
          wrap_selects (selects,
                  LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                 [case !functorlv of
d2051 3
a2053 3
                  | EnvironTypes.INTFOO ct =>
                      cg_longvalid(mklongvalid (Ident.VAR (make_functor_app ct)),env)],
                    Option.ABSENT))
d2101 1
a2101 1
              LambdaTypes.APP
d2116 1
a2116 1
               Option.ABSENT)
d2124 1
a2124 1
                              Option.ABSENT)
d2138 1
a2138 1
                                         Option.ABSENT))
d2148 1
a2148 1
                                              Option.ABSENT),
d2154 12
a2165 11
                                LambdaTypes.FN([lv],
                                               LambdaTypes.APP(overload_exp,
                                                               [LambdaTypes.STRUCT
                                                                ([wrap_selects(selects,LambdaTypes.VAR root_lv),
                                                                  dexp',
                                                                  LambdaTypes.VAR lv],
                                                                LambdaTypes.TUPLE)],
                                                               Option.ABSENT),
                                               "overload for " ^ Symbol.symbol_name sy,
                                               Datatypes.NULLTYPE,
                                               RuntimeEnv.INTERNAL_FUNCTION)
d2177 1
a2177 1
                                            Option.ABSENT))
d2196 1
a2196 1
                                               Option.ABSENT)],
d2222 1
a2222 1
                               Option.ABSENT)))
d2396 1
a2396 1
          (LambdaTypes.LET((lvar,Option.ABSENT,lexp),
d2443 1
a2443 1
            (LambdaTypes.LET((lvar,Option.ABSENT,lexp),
d2618 1
a2618 1
                                Option.PRESENT(ref (RuntimeEnv.VARINFO
d2671 1
a2671 1
                   LambdaTypes.LETB(tyfun_lvar,Option.ABSENT,
d2705 1
a2705 1
                    LambdaTypes.LETB(tyfun_lvar,Option.ABSENT,
d2730 1
a2730 1
          then [LambdaTypes.LETB(lv,Option.PRESENT(ref debug_info),lexp)]
d2733 1
a2733 1
          [LambdaTypes.LETB (lv,Option.ABSENT,lexp)]
d2749 1
a2749 1
            Absyn.SCONexp sc => LambdaTypes.SCON sc
d2805 20
a2824 1
			     "_" ^ overloaded_name  ty ^ sy_name
d2826 11
a2836 7
                           Diagnostic.output 2
                           (fn _ =>
                            ["Overloaded operator ",sy_name,
                             " instantiated to  ",sy_name',"\n"]);
                           cg_longvalid
                           (mklongvalid (Ident.VAR (Symbol.find_symbol sy_name')),
                            Primitives.env_for_lookup_in_lambda)
d2970 1
a2970 1
                                        LambdaTypes.LETB(lv,Option.ABSENT, le))
d3037 1
a3037 1
                  Option.PRESENT false_val
d3039 1
a3039 1
                  Option.ABSENT
d3043 1
a3043 1
               Option.PRESENT {num_imms = 1,num_vccs = 0},
d3048 1
a3048 1
            LambdaTypes.APP(fcn, [arg],Option.PRESENT annotation)
d3255 1
a3255 1
              add_match_env((root,(root_lambda,Option.ABSENT)),empty_match_env)
d3300 7
a3306 4
                       LambdaTypes.LETB(lvar,Option.ABSENT,
                                        LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                        [LambdaTypes.SCON(Ident.STRING rc)],
                                                        Option.ABSENT)))
d3313 1
a3313 1
                    fun report nil = LambdaTypes.SCON(Ident.STRING("\n"))
d3318 1
a3318 1
                                                                            Option.ABSENT),
d3321 1
a3321 1
                                        Option.ABSENT)
d3327 2
a3328 2
                                                                                Option.ABSENT),
                                                                LambdaTypes.SCON(Ident.INT("0",Location.UNKNOWN))],
d3330 2
a3331 2
                                            Option.ABSENT),
                            Option.PRESENT {num_imms = 2,num_vccs = 0},
d3339 1
a3339 1
                                                                     "Redundant patterns in match:\n")),
d3342 1
a3342 1
                                  Option.ABSENT)],
d3344 2
a3345 2
                                Option.ABSENT))],
                            Option.ABSENT)
d3376 1
a3376 1
                                          Option.ABSENT)
d3379 1
a3379 1
                                             Option.PRESENT {num_imms = 2,num_vccs = 0},
d3382 1
a3382 1
                                             Option.ABSENT)
d3385 1
a3385 1
                                             Option.PRESENT {num_imms = 2,num_vccs = 0},
d3388 1
a3388 1
                                             Option.ABSENT)
d3392 1
a3392 1
                      LambdaTypes.LET((new_LVar(),Option.ABSENT,
d3394 1
a3394 1
                        Option.PRESENT {num_imms = 2,num_vccs = 0},
d3399 2
a3400 2
                             LambdaTypes.SCON(Ident.STRING(implode("\n"::" "::" "::"-"::">":: (* Words fail me *)
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(explode rc))))))))],
d3402 1
a3402 1
                            Option.ABSENT),LambdaTypes.INT 1],
d3411 2
a3412 2
                                                                    Option.ABSENT),
                                               LambdaTypes.SCON(Ident.INT("1",Location.UNKNOWN))],
d3414 1
a3414 1
                                Option.ABSENT)],
d3416 1
a3416 1
                            Option.ABSENT), LambdaTypes.INT 1],
d3418 1
a3418 1
                        Option.ABSENT)),
d3429 1
a3429 1
                    ((new_LVar(),Option.ABSENT,
d3432 1
a3432 1
                      (redundant_clauses_lambda,Option.ABSENT,
d3435 2
a3436 2
                                                                   Location.UNKNOWN))],
                                       Option.ABSENT)) ::
d3447 1
a3447 1
               fun ensure_default (LambdaTypes.SWITCH (exp,info,tel,Option.ABSENT)) =
d3454 1
a3454 1
                   LambdaTypes.SWITCH (exp,info,tel',Option.PRESENT e)
d3488 1
a3488 1
                          (lv,Option.ABSENT,
d3516 1
a3516 1
                          (lv,Option.ABSENT,
d3527 8
a3534 6
                                          LambdaTypes.LET((this_lvar,Option.ABSENT,this_lexp),
                                                          tr_match(tree,
                                                                   add_match_env
                                                                   ((matchvar,(this_lvar,Option.ABSENT)),
                                                                    match_env),
                                                                   val_env))))
d3551 1
a3551 4
		      Option.PRESENT(
				     LambdaTypes.APP(LambdaTypes.VAR lvar,
						     [unit_exp],
						     Option.ABSENT))
d3553 4
a3556 2
			Option.PRESENT(init_null_tyfun_spills();
				       make_null_tyfun_spills(tr_match(tree, match_env, val_env)))
d3558 1
a3558 1
			Option.PRESENT excp
d3563 1
a3563 1
		    | MLWorks.Option.INL Match.ABSENT => Option.ABSENT
d3565 2
a3566 3
			Option.PRESENT(LambdaTypes.APP(LambdaTypes.VAR lvar,
						       [unit_exp],
						       Option.ABSENT))
d3578 1
a3578 1
                            (lv,Option.ABSENT) => 
d3585 5
a3589 1
                                     val debug_info = RuntimeEnv.VARINFO (Symbol.symbol_name symbol,ty,Option.ABSENT)
d3593 1
a3593 1
                                      ((dummylv,Option.PRESENT (ref debug_info),
d3609 1
a3609 1
                          | (lv,Option.PRESENT varinforef) => 
d3624 1
a3624 1
              | Match.SCON(mv, scon_tree_list, default, binding) =>
d3632 1
a3632 1
	                 Option.ABSENT,
d3634 1
a3634 1
                              (LambdaTypes.SCON_TAG scon,
d3641 1
a3641 1
			     MLWorks.Option.SOME default =>
d3643 1
a3643 1
			   | _ => Option.ABSENT
d3698 1
a3698 1
                                        Option.ABSENT)
d3727 2
a3728 2
                                then Option.PRESENT (ref RuntimeEnv.NOVARINFO)
                              else Option.ABSENT
d3761 2
a3762 2
				then Option.PRESENT (ref RuntimeEnv.NOVARINFO)
			      else Option.ABSENT
d3769 1
a3769 1
					      Option.ABSENT)),
d3802 1
a3802 1
		    Option.PRESENT{
d3818 1
a3818 1
                        Option.ABSENT (* No default here if all cases ok *)
d3830 2
a3831 2
                  then Option.PRESENT (ref RuntimeEnv.NOVARINFO)
                else Option.ABSENT
d3840 1
a3840 1
		  Option.PRESENT{num_vccs = 0,num_imms = 0},
d3864 1
a3864 1
                  Option.PRESENT{num_vccs = 0,num_imms = 0},
d3894 1
a3894 1
                   (new_LVar(),Option.ABSENT)
d3896 1
a3896 1
                   (new_LVar(),Option.PRESENT (ref RuntimeEnv.NOVARINFO))))
d3900 1
a3900 1
              (fn (x,y) => (x, y,(new_LVar(),Option.ABSENT)))
d3920 2
a3921 2
                Option.ABSENT => Crash.impossible "Match.DEFAULT:trans_match:lambda"
              | Option.PRESENT lexp => lexp
d3958 1
a3958 1
    val excp = Option.PRESENT
d4006 1
a4006 1
            | Absyn.SCONpat scon =>
d4011 8
a4018 7
                   [LambdaTypes.LETB(dummy_lv,Option.ABSENT,
                                     LambdaTypes.SWITCH(LambdaTypes.VAR lambda_var,
                                                        Option.ABSENT,
                                                        [(LambdaTypes.SCON_TAG scon, 
                                                          LambdaTypes.VAR lambda_var)],
                                                        excp
                                                        ))],
d4044 1
a4044 1
                            dummy_lv,Option.ABSENT,
d4047 1
a4047 1
                                   Option.PRESENT{
d4052 1
a4052 1
                                    if one_con then Option.ABSENT else excp
d4062 1
a4062 1
                        [LambdaTypes.LETB(dummy_lv,Option.ABSENT,
d4065 1
a4065 1
                                                             Option.PRESENT{num_imms = 0,
d4127 1
a4127 1
						       Option.ABSENT)
d4149 1
a4149 1
				 Option.PRESENT
d4162 1
a4162 2
				   Option.ABSENT
				   )
d4180 3
a4182 3
                                                     Option.PRESENT{num_imms = 0,
                                                                    num_vccs = 0
                                                                    },
d4249 1
a4249 1
                    (fn LambdaTypes.LETB(_,Option.PRESENT(ref debug_info),_) =>
d4277 1
a4277 1
                           ((new_lv,Option.PRESENT (ref RuntimeEnv.NOVARINFO)),pat, exp, location)
d4282 1
a4282 1
                      (fn (pat, exp, location) =>  ((new_LVar(),Option.ABSENT), pat, exp, location))
d4286 1
a4286 1
                    (fn ((lv,Option.PRESENT varinfo_ref), pat, _, location) =>
d4305 1
a4305 1
                  | ((lv,Option.ABSENT), pat, _, location) =>
d4435 2
a4436 2
                                              Option.ABSENT),
                            LambdaTypes.SCON(Ident.STRING exn_string)],
d4446 1
a4446 1
                             LambdaTypes.SCON(Ident.STRING exn_string)],
d4452 1
a4452 1
		([LambdaTypes.LETB(lv, Option.ABSENT,lambda_exp)],
d4539 1
a4539 1
		LambdaTypes.LETB (l, Option.ABSENT,LambdaTypes.SELECT(make_struct_select field, lambda_exp))
d4541 1
a4541 1
                     LambdaTypes.LETB (l,Option.ABSENT,
d4549 1
a4549 1
		LambdaTypes.LETB(l,Option.ABSENT, LambdaTypes.SELECT(make_struct_select field, lambda_exp))
d4551 1
a4551 1
                 LambdaTypes.LETB(l, Option.ABSENT,LambdaTypes.BUILTIN prim)
d4599 1
a4599 2
              LambdaTypes.LETB(lvar,Option.ABSENT,
                               lexp))
d4603 1
a4603 2
              LambdaTypes.LETB(lvar,Option.ABSENT,
                               lexp)) 
d4607 1
a4607 1
              LambdaTypes.LETB(lvar,Option.ABSENT,
d4611 2
a4612 2
                                                 Option.ABSENT),
                               LambdaTypes.SCON(Ident.STRING exn_string)],
d4623 1
a4623 1
               LambdaTypes.LETB(new_LVar(),Option.ABSENT,
d4689 1
a4689 1
                    LambdaTypes.LETB(lv,Option.ABSENT,
d4692 1
a4692 1
                                                     Option.ABSENT))
d4710 2
a4711 2
                                                [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))],
                                                Option.ABSENT)
d4715 1
a4715 1
                                Option.ABSENT)
d4789 1
a4789 1
            LambdaTypes.LETB(lambda_var,Option.ABSENT,lambda_exp) 
d4827 1
a4827 1
            LambdaTypes.LETB(lambda_var, Option.ABSENT,lambda_exp) 
d4923 1
a4923 1
         LambdaTypes.LET((lvar',Option.ABSENT,
d4925 1
a4925 1
            LambdaTypes.LET((lvar'',Option.ABSENT,
d4927 1
a4927 1
            LambdaTypes.LET((lvar''',Option.ABSENT,
d4931 1
a4931 1
                                    LambdaTypes.LETB(lv,Option.ABSENT,
d4934 1
a4934 1
                                                                     Option.ABSENT))
d4938 2
a4939 2
                              LambdaTypes.LET((lambda_var',Option.ABSENT,lambda_exp),
                               LambdaTypes.LET((new_LVar(),Option.ABSENT,
d4944 1
a4944 1
                                                                Option.ABSENT)),
d4956 1
a4956 1
       [LambdaTypes.LETB(lambda_var,Option.ABSENT,
d5013 1
a5013 1
     LambdaTypes.LETB(lv,Option.ABSENT,
d5016 1
a5016 1
                                      Option.ABSENT))
@


1.176
log
@Fix code generation problems for equality on types with
same names as builtin types
@
text
@d4 4
d1059 1
a1059 1
              val pat_str = AbsynPrint.unparsePat print_options p ^ " => ..."
d1063 1
a1063 1
                          ((true,"\n  ->  " ^ pat_str::static_str),
d1068 1
a1068 1
                            ((static,("\n      " ^ pat_str)::static_str),
d1072 1
a1072 1
                            ((static,("\n      " ^ pat_str)::static_str),
d2870 1
a2870 1
                                       ("Redundant patterns in match:\n",static_str))
d2940 1
a2940 1
                                          ("Redundant patterns in match:\n",static_str))
d3774 1
a3774 1
              Absyn.WILDpat => (true, true, Environ.empty_env, empty_denv, [],
d4103 1
a4103 1
                    | pat_name Absyn.WILDpat = "<wild>"
@


1.175
log
@Modifications to allow defaults to be optional in special constant matches
@
text
@d4 3
d838 1
a838 1
  fun domain_tyname(Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
d840 5
a844 5
       (_, h) :: _ =>
	 (case Types.the_type h of
	    Datatypes.CONSTYPE(_, tyname) => (true, tyname)
	  | _ => (false, Types.int_tyname)(* Dummy *))
     | _ => (false, Types.int_tyname))
d847 1
d853 1
d855 3
a857 14
  fun check_no_vcc_for_eq(Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
    (case Map.assoc record_map of
       (_, h) :: _ =>
	 let
	   val h = Types.the_type h
	 in
	   (case h of
	      Datatypes.CONSTYPE _ =>
		TypeUtils.has_null_cons h andalso
		not(TypeUtils.has_value_cons h)
	    | _ => false)
	 end
     | _ => false)
    | check_no_vcc_for_eq _ = Crash.impossible"poly_eq type wrong"
d2624 8
a2631 8
                               val simple_and_name as (is_simple, name) = 
                                 domain_type_name ty
                               val ident =
                                 mklongvalid(Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name)))
                               val has_no_vcc =
                                 is_simple andalso check_no_vcc_for_eq ty
                               val has_no_vcc =
                                 has_no_vcc orelse
d2633 13
a2645 1
				   val (good, tyname) = domain_tyname ty
d2647 4
a2650 1
				   good andalso Types.has_ref_equality tyname
d2652 4
a2655 25
                               val simple_and_name =
                                 if has_no_vcc then
                                   (true, "int")
                                 else
                                   simple_and_name
                               val ident =
                                 if has_no_vcc then
                                   mklongvalid(Ident.VAR(Symbol.find_symbol("_int" ^ sy_name)))
                                 else
                                   ident
                             in
                               case simple_and_name of
                                 (false, _) => cg
                               | (_, "int") =>
                                   cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
                               | (_, "real") =>
                                   cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
                               | (_, "char") =>
                                   cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
                               | (_, "word") =>
                                   cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
                               | (_, "string") =>
                                   cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
                               | _ => cg
                             end,true)
@


1.174
log
@Change to use MLWorks.Option
@
text
@d4 3
d3418 5
a3422 1
                         val default = Tr_Default (MLWorks.Option.INL(Match.PRESENT default))
@


1.173
log
@Change test for overloaded name to be robust against
redefinition as another primitive
Improvements to give inline equality on arrays, bytearrays, words and chars.
@
text
@d4 5
d539 1
a539 1
    Environ.EnvironTypes.LambdaTypes.Option = Match.Option = 
d2914 1
a2914 1
               Option.PRESENT missing_constructors =>
d2932 1
a2932 1
             | Option.ABSENT => ());
d3254 1
a3254 1
                     | do_binding (Option.SOME1 (ref Option.ABSENT)::bindings) =
d3256 1
a3256 1
                     | do_binding (Option.SOME1 (ref (Option.PRESENT (lvar as ref(Option.SOME1(_,tree)))))::bindings) =
d3266 1
a3266 1
                         (lvar := Option.SOME2 lv; (* Something to do with match compilation *)
d3286 1
a3286 1
                     | do_binding (Option.SOME1 _::_) =
d3288 1
a3288 1
                     | do_binding (Option.SOME2(lvar' as ref (Option.SOME1 (_,tree)),matchvar)::bindings) =
d3294 1
a3294 1
                         (lvar' := Option.SOME2 lv; (* Something to do with match compilation *)
d3321 1
a3321 1
                     | do_binding (Option.SOME2 _::_) =
d3327 12
a3338 11
                 let fun Tr_Default (ref(Match.BUILT(ref(Option.SOME2 lvar)))) = 
                           Option.PRESENT(
	                    LambdaTypes.APP(LambdaTypes.VAR lvar,
                                            [unit_exp],
                                            Option.ABSENT))
                     |   Tr_Default (ref(Match.BUILT(ref(Option.SOME1(0,tree))))) =
                            Option.PRESENT(init_null_tyfun_spills();
                                    make_null_tyfun_spills(tr_match(tree, match_env, val_env)))
                     |   Tr_Default (ref(Match.ERROR _)) = 
                            Option.PRESENT excp
                     |   Tr_Default _ = Crash.impossible "1:Tr_Default:tr_match:_lambda.sml"
d3340 9
a3348 9
                      case default of
                        Option.SOME1 (Match.PRESENT default) => Tr_Default default
                      | Option.SOME1 Match.ABSENT => Option.ABSENT
                      | Option.SOME2 (ref (Option.SOME2 lvar)) => 
                           Option.PRESENT(
	                    LambdaTypes.APP(LambdaTypes.VAR lvar,
                                            [unit_exp],
                                            Option.ABSENT))
                      | Option.SOME2 _ => Crash.impossible "2:Tr_Default:tr_match:_lambda.sml"
d3415 1
a3415 1
                         val default = Tr_Default (Option.SOME1(Match.PRESENT default))
d3424 2
a3425 2
                                               Option.ABSENT => []
                                             | Option.PRESENT bd =>[Option.SOME1 bd],
d3465 1
a3465 1
                    fun tr_match'(Option.SOME1 tree,match_env, val_env) =
d3467 1
a3467 1
                      | tr_match'(Option.SOME2(ref(Option.SOME2 lvar)),_, _) =
d3471 1
a3471 1
                      | tr_match'(Option.SOME2 _, _, _) =
d3691 1
a3691 1
              case Tr_Default (Option.SOME1(Match.PRESENT default)) of
d3697 2
a3698 2
                                       Option.ABSENT => []
                                     | Option.PRESENT bd => [Option.SOME1 bd],
@


1.172
log
@Signal an error for an unresolved record label
Remove polyvariable debugging
Remove stepping stuff
@
text
@d4 5
d2573 12
d2589 4
a2592 2
                              EnvironTypes.PRIM _ =>
				Environ.is_overloaded_op  valid
d2617 2
a2618 3
                          (if (* cg <> eq_prim *) isnt_eq_prim cg
                             andalso (* cg <> neq_prim *) isnt_neq_prim cg
                             then cg
d2621 1
a2621 2
                               val sy_name = if is_eq_prim cg (* cg = eq_prim *)
                                               then "=" else "<>"
d2630 5
a2634 5
                                 (if Types.tyname_eq(Types.ref_tyname, #2(domain_tyname ty))
                                    then
                                      true
                                  else
                                    false)
d2642 1
a2642 1
                                   mklongvalid (Ident.VAR(Symbol.find_symbol("_int" ^ sy_name)))
d2651 4
@


1.171
log
@Fix over enthusiastic assumptions about META_OVERLOADED types
@
text
@d4 3
a573 1
  val do_step_handler = false
d575 4
d584 1
a584 1
  val castit : 'a -> 'b = MLWorks.Internal.Value.cast (fn x => x)
d718 1
d732 30
a761 4
  fun record_label_offset(lab, the_type) =
  let
    (** extract the domain map for a record type **)
    val record_domain = TypeUtils.record_domain the_type
d952 2
a953 1
             (LambdaTypes.BUILTIN prim, EnvironTypes.NOSPEC)
d957 2
a958 1
                             Option.ABSENT), EnvironTypes.NOSPEC)
a1339 1
  (* For the moment, have removed generate_stepper_specific *)
d1346 3
a1348 2
	    	             {generate_debug_info, debug_variables, debug_polyvariables,
			      generate_stepper, generate_moduler, ...},
d1357 2
d1364 1
a1364 1
      val variable_debug = debug_variables orelse debug_polyvariables orelse generate_moduler
a1365 6
      (* Need pairs of bindings when doing polyvariable debugging *)
      val new_poly_lvar = 
        if debug_polyvariables 
          then fn _ => new_LVar()
        else fn lv => lv

a1373 151
      (* Pass instances around at runtime by creating a suitable 'frontend' to 
         the polymorphic function;
         record these in the stack frame;
         propagate to all curried versions of function *)

      fun make_poly_binding (debug_info,instance,lexp,location) = 
        case instance of
          Option.PRESENT (ref (Datatypes.INSTANCE instance)) => 
            let
              (* Expect debug info if instance is defined *)
              val (instance_name,location,ty) = 
                case debug_info of
                  RuntimeEnv.VARINFO (name,(ref ty,_),_) => 
                    ("instance of " ^ name, "[" ^ location ^ "]", ty)
                | _ => Crash.impossible "1:make_poly_binding:trans_dec"
              val tyvar = new_LVar()
              (* Allocate a new tyvar slot *)
              val tyvar_slot = new_tyvar_slot ()

              (* This seems to make bindings for curried polymorphic functions? *)
              fun debugger_application (Datatypes.FUNTYPE(_,ty),app,level) = 
                let
                  val tyvar_slot = new_tyvar_slot ()
                  val arg = new_LVar()
                  val result = new_LVar()
                in
                  LambdaTypes.FN([arg],
                                 LambdaTypes.LET
                                 ((new_LVar(),
                                   Option.PRESENT
                                   (ref (RuntimeEnv.VARINFO
                                         ("tyvar for " ^ instance_name,
                                          dummy_instance (),
                                          Option.PRESENT tyvar_slot))),
                                   LambdaTypes.VAR tyvar),
                                 LambdaTypes.LET ((result,Option.ABSENT,
                                                   LambdaTypes.APP(app,[LambdaTypes.VAR arg],
                                                                  Option.ABSENT)),
                                                  debugger_application (Types.the_type ty,
                                                                        LambdaTypes.VAR result,
                                                                        level+1))), 
                                 instance_name ^ " argument " ^ makestring level ^ location,
                                 Datatypes.NULLTYPE,
                                 RuntimeEnv.FUNINFO (instance,tyvar_slot))
                end
                | debugger_application (_,app,_) = app
            in
              LambdaTypes.FN
              ([tyvar],
               LambdaTypes.LET((new_LVar(),
                                Option.PRESENT(ref (RuntimeEnv.VARINFO
                                                    ("tyvar for " ^ instance_name,
                                                     dummy_instance(),
                                                     Option.PRESENT tyvar_slot))),
                                LambdaTypes.VAR tyvar),
                                debugger_application (Types.the_type ty, lexp, 1)),
               instance_name ^ location,Datatypes.NULLTYPE,
               RuntimeEnv.FUNINFO (instance,tyvar_slot))
            end
        (* If there is no instance, then just return the expression *)
        | _ => lexp

      (* BEGIN{STEP DEBUGGER} *)

      (* New definition for step exp *)
      val step_exp = 
        LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.GET_IMPLICIT,
                         [LambdaTypes.INT ImplicitVector.stepper_fn],
                         Option.ABSENT)
                          
      val breakpoint_exp =
        LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.GET_IMPLICIT,
                         [LambdaTypes.INT ImplicitVector.breakpoint_fn],
                         Option.ABSENT)

      val exit_breakpoint_exp =
        LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.GET_IMPLICIT,
                         [LambdaTypes.INT ImplicitVector.exit_breakpoint_fn],
                         Option.ABSENT)

      val step_handler_exp =
        LambdaTypes.APP (LambdaTypes.BUILTIN Pervasives.GET_IMPLICIT,
                         [LambdaTypes.INT ImplicitVector.stepper_handler_fn],
                         Option.ABSENT)

      (* make_step_call gets some info about what function we are in, if any *)
      fun make_step_call Option.ABSENT = []
        | make_step_call (Option.PRESENT (fnname,fnname_lvar)) =
          (* Make call to stepper *)
        if generate_stepper then
          [LambdaTypes.LETB(new_LVar(),Option.ABSENT,
                            LambdaTypes.APP(step_exp,
                                            [LambdaTypes.STRUCT([LambdaTypes.VAR fnname_lvar,
                                                                 LambdaTypes.INT(0)],
                                                                LambdaTypes.TUPLE)],
                                            Option.ABSENT))]
        else []

      (* Switch this out for now *)
      fun make_step_handler (lexp,(name,fnname,fnname_lv)) =
        if do_step_handler andalso generate_stepper andalso not (funny_name_p name)
          then
            LambdaTypes.HANDLE(lexp,
                               LambdaTypes.APP(step_handler_exp,[LambdaTypes.VAR fnname_lv],
                                               Option.ABSENT),"step handler")
        else
          lexp

      fun make_breakpoint (name,fnname,fnname_lvar,lexp) =
        if generate_stepper andalso not (funny_name_p name)
          then
            LambdaTypes.LET((new_LVar(),Option.ABSENT,
                             LambdaTypes.APP(breakpoint_exp,
                                             [LambdaTypes.VAR fnname_lvar],
                                             Option.ABSENT)),
                            lexp)
        else
          lexp

      fun make_breakpoint_on_exit (fnname,fnname_lvar,lexp) =
        if generate_stepper
          then
            LambdaTypes.LET((new_LVar(),Option.ABSENT,
                             LambdaTypes.APP(exit_breakpoint_exp,
                                             [LambdaTypes.VAR fnname_lvar],
                                             Option.ABSENT)),
                            lexp)
        else
          lexp

      (* Add a binding of the function name for use by the stepper *)
      fun make_name_binding (lexp,(fnname,fnname_lv)) =
        if generate_stepper
          then
            LambdaTypes.LET((fnname_lv,Option.ABSENT,
                             LambdaTypes.SCON(LambdaTypes.Ident.STRING fnname)),
                            lexp)
        else
          lexp

      (* Retain user name of functions where possible ... *)
      fun filter_name (name_string,fnname) =
        if funny_name_p name_string then fnname else name_string

      val append_name =
        if generate_stepper then
          fn (name_string,fnname) => name_string ^ "{" ^ fnname ^ "}"
        else
          fn (name_string,_) => name_string
      (* END{STEP DEBUGGER} *)

a1375 2
      val generate_moduler_debug = true

d1855 1
d1868 1
d1872 2
d1879 1
d2518 3
a2520 10
      fun make_binding ((lv,lv'),debug_info,instance,lexp,comment,location) = 
        if variable_debug then 
          if debug_polyvariables then 
            (* lv is bound to the lexp *)
            (* lv' is bound to the polymorphic function binding *)
            [LambdaTypes.LETB(lv,Option.PRESENT(ref debug_info),lexp),
             LambdaTypes.LETB(lv',Option.ABSENT,
                              make_poly_binding(debug_info,instance,LambdaTypes.VAR lv,location))]
          else
            [LambdaTypes.LETB(lv,Option.PRESENT(ref debug_info),lexp)]
d2523 1
a2523 20
          [LambdaTypes.LETB(lv,Option.ABSENT,lexp)]

      fun make_return_binding_for_stepper (lexp,
                                           debug_info as RuntimeEnv.VARINFO (_,(ref ty,_),_),
                                           (name,fnname,fnname_lv)) =
        if do_exit_stuff andalso generate_stepper andalso 
          not (Types.isFunType ty) andalso not (funny_name_p name)
          then
            let
              val lvar = new_LVar()
            in
              (* Note: instance is absent in this case *)
              let_lambdas_in_exp(make_binding((lvar,lvar), debug_info,
                                              Option.ABSENT,lexp,function_return_string,"") (* @@
                                 make_step_call (Option.PRESENT (fnname,fnname_lv)) *),
                                 make_breakpoint_on_exit (fnname,fnname_lv,LambdaTypes.VAR lvar))
            end
        else
          lexp
        | make_return_binding_for_stepper (lexp,_,_) = lexp
d2856 1
a2856 1
                          else (0,[],Location.UNKNOWN))
d2924 1
a2924 1
                             else (0,[],Location.UNKNOWN))
d2955 1
a2955 1
                         (castit
d3014 12
d3112 2
a3113 1
                              (EnvironTypes.STRIDSPEC (Ident.LONGSTRID(p,Ident.STRID s)),Ident.LONGVALID(p',s')) =>
d3115 2
a3116 1
                                val newlongstrid = Ident.LONGVALID(combine_paths (p,combine_paths (Ident.PATH(s,Ident.NOPATH),p')),s')
d3237 1
a3237 1
                               add_match_string (append_name(name_string,fnname),
d3250 1
a3250 3
                                    make_step_handler (* Wrap a break on exn handler round *)
                                    (make_null_tyfun_spills(tr_match(tree,match_env,val_env)),
                                     (name_string,fnname,fnname_lv)))
d3266 1
a3266 5
                             if fnname = name_string then
                               add_match_string (name_string,"<Match" ^ makestring(new_match_trans()) ^ ">")
                             else
                               add_match_string (append_name(name_string,fnname),
                                                 "<Match" ^ makestring(new_match_trans()) ^ ">")
d3277 2
a3278 3
                                    make_step_handler (* Wrap step handler round evaluation *)
                                    (make_null_tyfun_spills
                                     (case matchvar of
d3286 1
a3286 2
                                                                   val_env))),
                                     (name_string,fnname,fnname_lv)))
d3328 1
a3328 2
                        make_breakpoint (name_string,fnname,fnname_lv,
                                         trans_exp(" match_leaf", exp, env, denv, Option.PRESENT (fnname,fnname_lv)))
d3654 1
a3654 1
                                  LambdaTypes.SELECT(record_label_offset(lab,ty),le)))
d3677 1
a3677 12
   val debug_info = 
     if generate_stepper then
       let
         val res_ty = #2(Types.argres ty)
           handle Types.ArgRes => LambdaTypes.null_type_annotation
       in
         case res_ty of
           Datatypes.NULLTYPE => RuntimeEnv.NOVARINFO
         | ty => RuntimeEnv.VARINFO (function_return_string,(ref ty,ref null_runtimeinfo),Option.ABSENT)
       end
     else
       RuntimeEnv.NOVARINFO
d3685 3
a3687 9
                         make_name_binding (* Wrap around a binding of the function name *)
                         (make_step_handler (* Wrap step handler round whole match *)
                          (make_null_tyfun_spills
                           (null_tyfun_spills (denv,debug_info,Location.to_string location);
                            make_return_binding_for_stepper
                            (tr_match (tree, match_env,env),
                             debug_info,
                             (name_string,fnname,fnname_lv))),
                           (name_string,fnname,fnname_lv)),(fnname,fnname_lv)))
d3746 1
a3746 3
            (* lambda_var' is the polymorphic debugger entry point, if one is needed,
             else it is meaningless *)
            fun trans_individual_dec(pattern, (lambda_var,lambda_var'), location) =
d3772 1
a3772 1
                              EnvironTypes.LAMB(lambda_var', EnvironTypes.NOSPEC))), 
d3826 1
a3826 1
                          LambdaTypes.SELECT(record_label_offset(lab, ty),
a3832 1
                       val lv' = new_poly_lvar lv
d3834 1
a3834 1
                         trans_individual_dec(pat, (lv,lv'), location)
d3837 1
a3837 1
                        make_binding ((lv,lv'),debug_info,instance,le,"",location)
a3865 1
			    val new_lv' = new_poly_lvar new_lv
d3868 1
a3868 1
			      trans_individual_dec(pat, (new_lv,new_lv'), location)
d3874 1
a3874 1
			     make_binding((new_lv,new_lv'),debug_info,instance,lexp,
d3881 1
a3881 1
			    trans_individual_dec(pat, (lambda_var,lambda_var'), location)
a3884 1
			      val new_lv' = new_poly_lvar new_lv
d3887 1
a3887 1
				trans_individual_dec(pat, (new_lv,new_lv'),location)
d3910 1
a3910 1
			       make_binding((new_lv,new_lv'), debug_info,
a3918 1
                       val new_lv' = new_poly_lvar new_lv
d3921 1
a3921 1
                         trans_individual_dec(pat, (new_lv,new_lv'),location)
d3934 1
a3934 1
                        make_binding((new_lv,new_lv'),debug_info,instance,lexp,"",
d3943 1
a3943 1
                    trans_individual_dec(typed, (lambda_var,lambda_var'), location)
d3950 1
a3950 1
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location)
d3953 1
a3953 1
                                                   (valid, EnvironTypes.LAMB(lambda_var', EnvironTypes.NOSPEC))),
a3964 2
                  val lvar' = new_poly_lvar lvar
                  val location' = Ident.Location.to_string location
d3966 1
a3966 1
                    trans_individual_dec(pat, (lvar,lvar'), location')
d3980 1
a3980 1
                  val _ = null_tyfun_spills (denvir,debug_info,location')
d3995 1
a3995 1
                     null_tyfun_spills (denvir,debug_info,location')
d4007 3
a4009 3
                      make_binding((lvar,lvar'),debug_info,instance,lambda,"",
                                   location')
                      @@ new_bindings @@ make_step_call fnname))
d4022 1
a4022 2
                           ((new_lv,Option.PRESENT (ref RuntimeEnv.NOVARINFO)),
                            (new_poly_lvar new_lv,Option.ABSENT), pat, exp, location)
d4027 1
a4027 6
                      (fn (pat, exp, location) =>  
                       let
                         val new_lv = (new_LVar(),Option.ABSENT)
                       in
                         (new_lv, new_lv, pat, exp, location)
                       end)
d4031 1
a4031 2
                    (fn ((lv,Option.PRESENT varinfo_ref), 
                         (lv'',Option.ABSENT), pat, _, location) =>
a4032 1
                       val location' = Ident.Location.to_string location
d4034 1
a4034 1
                         trans_individual_dec(pat, (lv,lv''),location')
d4048 1
a4048 1
                       (env,denv,lv,debug_info,instance,location')
d4050 1
a4050 1
                  | ((lv,Option.ABSENT), _, pat, _, location) =>
d4053 1
a4053 1
                         trans_individual_dec(pat, (lv,lv),"")
d4065 2
a4066 3
                       (env,denv,lv,debug_info,instance,"")
                     end
                  | _ => Crash.impossible "env_le_list:trans_dec:lambda")
d4085 6
a4090 37
                    if debug_polyvariables then
                      (* make frontends for polymorphic debugger *)
                      [LambdaTypes.RECLETB
                       (Lists.reducer
                        (fn ((((pat,exp,_),(_,_,lv'',debug_info,instance,location)),
                              (lv,lv',_,_,_)),
                             (bds,exp_list)) =>
                         let
                           val lexp = trans_exp(pat_name pat, exp, trans_env, trans_denv, fnname)
                           val binding =
                             (case lexp of
                                LambdaTypes.FN(_,_,name,_,_) => 
                                  make_poly_binding (debug_info,instance,LambdaTypes.VAR(lv''),location)
                              | _ => Crash.impossible "debug_polyvariables:recletb:trans_dec:lambda")
                         in
                           case binding of
                             lexp' as LambdaTypes.FN _ => 
                               (lv :: lv' :: bds, lexp :: lexp' :: exp_list)
                           | _ => 
                               (* If the binding wasn't a function, we need to pretend that we 
                                didn't really give it an extra binding *)
                               (* This is obscure *)
                               ((case (lv,lv') of
                                   ((_,Option.PRESENT (ref info)),
                                    (lv',Option.ABSENT)) => 
                                   ((lv',Option.PRESENT (ref info)) :: bds,lexp :: exp_list)
                                  | _ => Crash.impossible 
                                      "debug_polyvariables:recletb:trans_dec:lambda"))
                         end)
                        (Lists.zip(Lists.zip(rec_list,env_le_list),lv_pat_exp_list),(nil,nil)))]
                    else
                      [LambdaTypes.RECLETB(map #1 lv_pat_exp_list,
                                           map
                                           (fn (pat,exp,_) =>
                                            trans_exp(pat_name pat, exp, trans_env, 
                                                      trans_denv, fnname))
                                           rec_list)]
@


1.170
log
@Problem with match translator returning incomplete match default functions.
@
text
@d4 3
d762 14
a775 6
      (_, ty as Datatypes.META_OVERLOADED (r, tv, valid, loc)) :: _ =>
	(case Types.the_type (!r) of
	   Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => s
	 | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => s
	 | _ => Crash.impossible "overloaded_name (1)")
    | _ => Crash.impossible "overloaded_name (2)")
d783 4
@


1.169
log
@Remove Builtin_p and modify FindBuiltin
@
text
@d4 3
d3313 12
d3369 1
a3369 1
                                tr_match
d3411 1
a3411 1
                                tr_match
@


1.168
log
@Simplified Stepper and Breakpoint code
@
text
@d4 3
d2779 35
a2813 35
                     if Environ.Builtin_p(longValId, env) then
                       LambdaTypes.BUILTIN(Environ.FindBuiltin(longValId, env))
                     else
                       if TypeUtils.is_vcc ty then
                         let
                           val new_lv = new_LVar()
                         in
                           LambdaTypes.FN
                           ([new_lv],
                            if TypeUtils.get_no_cons ty > 1  andalso
                               not (is_list_type (TypeUtils.get_cons_type ty))
		            then
                              LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv],LambdaTypes.CONSTRUCTOR)
                            else
                              LambdaTypes.VAR new_lv,
			      let
				val cons_type = TypeUtils.get_cons_type ty
				val typename =
				  case cons_type of
				    Datatypes.CONSTYPE(_, tyname) =>
				      Types.print_name print_options tyname
				  | _ => Crash.impossible"lambda:bad cons type"
				val con_name =
				  "constructor " ^ Symbol.symbol_name symbol ^
				  " of " ^ typename
			      in
				if location = "" then
				  con_name
				else
				  con_name ^ " [" ^ location ^ "]"
			      end,
			    LambdaTypes.null_type_annotation,RuntimeEnv.INTERNAL_FUNCTION)
                         end
                       else
                         lexp
d3607 23
a3629 25
		      if Environ.Builtin_p(name, val_env) 
                         andalso (case cg_longvalid(name,val_env) of
                                    LambdaTypes.BUILTIN Pervasives.REF => true 
                                  | _ => false) then
		        (* Must be ref *)
			let 
                          val new_lv = new_LVar ()
                          val info = 
                            if variable_debug andalso not generate_moduler 
                              (* Huh? *)
                              then Option.PRESENT (ref RuntimeEnv.NOVARINFO)
                            else Option.ABSENT
			in
                          LambdaTypes.do_binding(
                            LambdaTypes.LETB(new_lv,info,
                              LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                              [LambdaTypes.VAR orig_lv],
                                              Option.ABSENT)),
		            tr_match'(tree,
			              add_match_env((mv, (new_lv,info)),
                                                    match_env),
                                      val_env)
		          )
			end
		      else
d3635 3
a3637 3
		        tr_match'(tree,
			          add_match_env((mv, ORIG_LV),match_env),
                                  val_env)
d3990 55
a4044 57
                     if Environ.Builtin_p(longvalid, envir) 
                       andalso (case cg_longvalid(longvalid,envir) of
                                  LambdaTypes.BUILTIN Pervasives.REF => true
                                | _ => false) then
                       (* Must be ref *)
                       let 
                         val new_lv = new_LVar()
                         val new_lv' = new_poly_lvar new_lv
                         val (has_vars, exhaustive, new_env, new_denv, new_lambda_exp, 
                              debug_info,instance) =
                           trans_individual_dec(pat, (new_lv,new_lv'), location)
                         val lexp = LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                    [LambdaTypes.VAR lambda_var],
                                                    Option.ABSENT)
                       in
                         (has_vars, exhaustive, new_env, new_denv,
                          make_binding((new_lv,new_lv'),debug_info,instance,lexp,
                                       "Dereferencing a pattern",location)
                          @@ new_lambda_exp,RuntimeEnv.NOVARINFO,
                          Option.ABSENT)
                       end
                     else
                       if TypeUtils.get_no_cons ty = 1 then
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location)
                       else
                         let 
                           val new_lv = new_LVar()
                           val new_lv' = new_poly_lvar new_lv
                           val (has_vars, _, new_env, new_denv, new_lambda_exp,
                                debug_info,instance) =
                             trans_individual_dec(pat, (new_lv,new_lv'),location)
                           val lexp = LambdaTypes.VAR lambda_var
                           val tag = #2(constructor_tag(valid, ty))
                           val lexp = LambdaTypes.SWITCH(
                                                lexp,
                                                Option.PRESENT{
                                                  num_vccs = TypeUtils.get_no_vcc_cons ty,
                                                  num_imms = TypeUtils.get_no_null_cons ty
                                                                                    },
                                   [(LambdaTypes.VCC_TAG (valid_name valid,tag),
                                     if is_list_type (TypeUtils.get_cons_type ty) then
                                                                    lexp
                                                                  else
                                                                    GetConVal lexp
                                                                    )],
                                   if TypeUtils.get_no_cons ty <> 1 then
                                     excp (* is a tag, but not the right one *)
                                   else
                                     Option.ABSENT
                                     )
                         in
                           (has_vars, false, new_env, new_denv,
                            make_binding((new_lv,new_lv'),debug_info,instance,lexp,"",
                                         location)
                            @@ new_lambda_exp,RuntimeEnv.NOVARINFO,
                            Option.ABSENT)
                         end
@


1.167
log
@Debugger work
@
text
@d4 3
d454 1
d466 1
d469 1
a470 1
require "lambda";
a471 1
require "lambdautils";
d474 2
d486 1
a493 4
  structure Environ : ENVIRON
  structure LambdaUtils: LAMBDAUTILS
  structure LambdaPrint: LAMBDAPRINT
  structure LambdaOptimiser: LAMBDAOPTIMISER
d496 1
a496 1
  structure Debugger_Types : DEBUGGER_TYPES
d499 5
d505 1
a505 1
  sharing LambdaUtils.LambdaTypes = LambdaOptimiser.LambdaTypes = 
d509 2
a510 2
  sharing AbsynPrint.Absyn.Ident = IdentPrint.Ident = Types.Datatypes.Ident
  sharing LambdaUtils.Match.Absyn = AbsynPrint.Absyn = TyperepUtils.Absyn
d513 3
a515 4
  sharing LambdaUtils.Match.Options = Types.Options = AbsynPrint.Options =
    Debugger_Types.Options = IdentPrint.Options = LambdaPrint.Options
  sharing LambdaUtils.LambdaTypes.Ident = Types.Datatypes.Ident
  sharing Environ.EnvironTypes.NewMap = Types.Datatypes.NewMap = Debugger_Types.NewMap
d517 1
a517 1
    Environ.EnvironTypes.LambdaTypes.Option = LambdaUtils.Match.Option = 
d521 2
a522 2
  sharing type LambdaUtils.LambdaTypes.FunInfo = Debugger_Types.RuntimeEnv.FunInfo
  sharing type LambdaUtils.LambdaTypes.VarInfo = Debugger_Types.RuntimeEnv.VarInfo
d524 2
a525 2
  sharing type Environ.EnvironTypes.LambdaTypes.LVar = LambdaUtils.Match.lvar
  sharing type LambdaUtils.LambdaTypes.Primitive = Pervasives.pervasive
d527 1
a527 1
  sharing type Debugger_Types.Type = LambdaUtils.LambdaTypes.Type 
d532 1
a532 1
  sharing type LambdaUtils.LambdaTypes.Tyfun = Types.Datatypes.Tyfun
d534 1
a534 1
  sharing type LambdaUtils.LambdaTypes.DebuggerStr = Types.Datatypes.DebuggerStr 
d536 2
a537 2
  sharing type LambdaUtils.LambdaTypes.Structure = AbsynPrint.Absyn.Structure
  sharing type LambdaUtils.Match.Matchvar = int
a554 1
  structure Match = LambdaUtils.Match
d558 7
d681 1
a681 1
      LambdaTypes.null_type_annotation,Option.ABSENT)
d690 1
a690 1
		     LambdaTypes.null_type_annotation,Option.ABSENT)
d771 1
a771 1
	 (case Types.the_type(h) of
d846 4
a849 3
      val (env', field) = case Environ.lookup_strid(strid, env) of
	(env'', EnvironTypes.FIELD(field), _) => (env'', field)
      | _ => Crash.impossible "get_field_env fails to get field"
d856 4
a859 3
      val (env', field, _) = case Environ.lookup_strid(strid, env) of
	(env'', EnvironTypes.FIELD(field), moduler_generated) => (env'', field, moduler_generated)
      | _ => Crash.impossible "get_field_env fails to get field"
d1001 1
a1001 1
                            ((static,("\n      " ^pat_str)::static_str),
d1005 2
a1006 2
                            ((static,("\n      " ^pat_str)::static_str),
                             (dynamic,((n,Match.FALSE),"\n      " ^pat_str)::dynamic_str)))
d1167 1
a1167 1
                                   LambdaTypes.null_type_annotation,Option.ABSENT)
d1224 1
a1224 1
    fun extract_op (EnvironTypes.LAMB(x,_)) = LambdaTypes.VAR x
d1228 1
a1228 1
      | extract_op (EnvironTypes.EXTERNAL) =
d1252 1
a1252 1
        if not(coerce) andalso compare_sig_env generate_moduler (interface, new_env)
d1271 9
d1289 1
d1291 1
a1291 1
	    	             {debug, debug_variables, debug_polyvariables,
d1302 2
a1303 2
      val redundant_exceptions_ref : (LambdaTypes.LVar * string) list ref = ref (nil)
      val dynamic_redundancy_report_ref : (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) ref = ref(fn exp=>exp)
d1305 2
a1306 2
      val variable_debug =
        debug_variables orelse debug_polyvariables orelse generate_moduler
a1307 2
      val do_stepper = generate_stepper

d1335 1
a1335 1
                    ("instance of " ^ name, "[" ^location ^ "]", ty)
d1353 1
a1353 1
                                         ("tyvar for "^instance_name,
d1365 1
a1365 1
                                 Option.PRESENT (RuntimeEnv.FUNINFO (instance,tyvar_slot)))
d1373 1
a1373 1
                                                    ("tyvar for "^instance_name,
d1376 1
a1376 1
                                LambdaTypes.VAR(tyvar)),
d1378 2
a1379 2
               instance_name^location,Datatypes.NULLTYPE,
               Option.PRESENT(RuntimeEnv.FUNINFO(instance,tyvar_slot)))
d1386 20
a1405 121
      (* Definition of stepper functions *)
      val (step_exp,breakpoint_exp,breakpoint_on_exit_exp,step_handler_exp,stepper_binding,stepper_env) =
        (* Try finding the relevant id's *)
       if do_stepper then 
         (cg_longvalid(make_longid ([],"step function"),env),
          cg_longvalid(make_longid ([],"breakpoint function"),env),
          cg_longvalid(make_longid ([],"breakpoint_on_exit function"),env),
          cg_longvalid(make_longid ([],"step handler function"),env),
          [],
          fn env => env)
         (* Else make new definitions *)
          handle NewMap.Undefined =>
            let
              (* Hack in a call to the debugger stepper *)
              val MLWorks_Debugger_step = 
                cg_longvalid (make_longid (["MLWorks","Debugger"],"step"),env)

              val (step_lvar,step_fn) =
                (* The stepper function just calls MLWorks.Debugger.step *)
                (new_LVar(),
                 let
                   val param = new_LVar()
                 in
                   LambdaTypes.FN([param],
                                  LambdaTypes.APP(MLWorks_Debugger_step,
                                                  [LambdaTypes.VAR param],
                                                  Option.ABSENT),
                                  "step function",
                                  Datatypes.NULLTYPE,
                                  Option.ABSENT)
                 end)

              (* enter debugger if raised exn and re-raise exn in continuing *)
              val (step_handler_lvar,step_handler_fn) =
                (new_LVar(),
                 let
                   val fnname = new_LVar()
                   val exn = new_LVar()
                 in
                   (* Build a handler that applies the step function, but with a appropriately *)
                   (* constructed exception object (type exn option) *)
                   LambdaTypes.FN
                   ([fnname],
                    LambdaTypes.FN
                    ([exn],
                     LambdaTypes.LET
                     ((new_LVar(),Option.ABSENT, (* Bind dummy *)
                       LambdaTypes.APP(LambdaTypes.VAR step_lvar,
                                       [LambdaTypes.STRUCT([LambdaTypes.VAR(fnname),
                                                            LambdaTypes.STRUCT([LambdaTypes.INT 1, (* PRESENT *)
                                                                                LambdaTypes.VAR(exn)],
                                                            LambdaTypes.CONSTRUCTOR)],
                                       LambdaTypes.TUPLE)],
                                       Option.ABSENT)),
                     LambdaTypes.RAISE(LambdaTypes.VAR exn)), (* And reraise exception *)
                     "Debugger exception handler",
                     Datatypes.NULLTYPE,
                     Option.ABSENT),
                    "step handler",
                    Datatypes.NULLTYPE,
                    Option.ABSENT)
                 end)

              (* Hack in a call to the debugger breakpoint-checker *)
              val MLWorks_Debugger_breakpoint = 
                cg_longvalid (make_longid (["MLWorks","Debugger"],"breakpoint"),env)
              val MLWorks_Debugger_breakpoint_on_exit = 
                cg_longvalid (make_longid (["MLWorks","Debugger"],"breakpoint_on_exit"),env)

              val (breakpoint_lvar,breakpoint_fun) =
                (new_LVar(),
                 let
                   val fnname = new_LVar()
                 in
                   LambdaTypes.FN([fnname],
                                  LambdaTypes.APP(MLWorks_Debugger_breakpoint,
                                                  [LambdaTypes.VAR fnname],
                                                  Option.ABSENT),"breakpoint function",
                                  Datatypes.NULLTYPE,
                                  Option.ABSENT)
                 end)
              val (breakpoint_on_exit_lvar,breakpoint_on_exit_fun) =
                (new_LVar(),
                 let
                   val fnname = new_LVar()
                 in
                   LambdaTypes.FN([fnname],
                                  LambdaTypes.APP(MLWorks_Debugger_breakpoint_on_exit,
                                                  [LambdaTypes.VAR fnname],
                                                  Option.ABSENT),"breakpoint function_on_exit",
                                  Datatypes.NULLTYPE,
                                  Option.ABSENT)
                 end)
            in
              (LambdaTypes.VAR step_lvar,
               LambdaTypes.VAR breakpoint_lvar,
               LambdaTypes.VAR breakpoint_on_exit_lvar,
               LambdaTypes.VAR step_handler_lvar,
               [LambdaTypes.LETB(step_lvar,Option.ABSENT,step_fn),
                LambdaTypes.LETB(breakpoint_lvar,Option.ABSENT,breakpoint_fun),
                LambdaTypes.LETB(breakpoint_on_exit_lvar,Option.ABSENT,breakpoint_on_exit_fun),
                LambdaTypes.LETB(step_handler_lvar,Option.ABSENT,step_handler_fn)],
               if batch_compiler then fn env => env
               else
                 fn env =>
                 Environ.add_valid_env
                 (Environ.add_valid_env
                  (Environ.add_valid_env
                   (Environ.add_valid_env
                    (env,
                     (make_short_id "step function",
                      EnvironTypes.LAMB(step_lvar, EnvironTypes.NOSPEC))),
                    (make_short_id "breakpoint function",
                     EnvironTypes.LAMB(breakpoint_lvar, EnvironTypes.NOSPEC))),
                   (make_short_id "breakpoint_on_exit function",
                    EnvironTypes.LAMB(breakpoint_on_exit_lvar, EnvironTypes.NOSPEC))),
                  (make_short_id "step handler function",
                   EnvironTypes.LAMB(step_handler_lvar, EnvironTypes.NOSPEC))))
            end
       else
         (dummy_varexp,dummy_varexp,dummy_varexp,dummy_varexp,[],fn env => env)
d1411 1
a1411 1
        if do_stepper then
d1420 3
a1422 2
      fun make_handle_for_stepper (lexp,(name,fnname,fnname_lv)) =
        if do_stepper andalso not (funny_name_p name)
d1431 1
a1431 1
        if do_stepper andalso not (funny_name_p name)
d1442 1
a1442 1
        if do_stepper
d1445 1
a1445 1
                             LambdaTypes.APP(breakpoint_on_exit_exp,
d1454 1
a1454 1
        if do_stepper
d1457 1
a1457 1
                             LambdaTypes.SCON(LambdaTypes.Ident.STRING(fnname))),
d1467 2
a1468 2
        if do_stepper then
          fn (name_string,fnname) => name_string^"{"^fnname^"}"
d1479 1
a1479 1
          output(std_out,"  # " ^ message()^"\n")
d1491 1
a1491 1
              aux (path, NewMap.apply strmap (Ident.STRID(sym))
d1493 1
a1493 1
                     (do_moduler_debug (fn ()=>"UNDEFINED 14:"^Symbol.symbol_name sym);
d1497 2
a1498 2
                                             Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                                             Datatypes.TE(tyconmap),
d1508 1
a1508 1
                    NewMap.apply stridmap (Ident.STRID(sym))))
d1510 1
a1510 1
                  (do_moduler_debug(fn ()=>"UNDEFINED 3:"^Symbol.symbol_name sym);
d1518 2
a1519 2
                                              Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                                              Datatypes.TE(tyconmap),
d1526 1
a1526 1
                                                NewMap.rank' (stridmap,Ident.STRID(sym)) + offset,
d1529 1
a1529 1
                    NewMap.apply stridmap (Ident.STRID(sym))))
d1531 1
a1531 1
                  (do_moduler_debug(fn ()=>"UNDEFINED 3:"^Symbol.symbol_name sym);
d1546 1
a1546 1
               (do_moduler_debug(fn ()=>"UNDEFINED 5:"^Symbol.symbol_name sym);
d1551 2
a1552 2
                                                           Datatypes.ENV(Datatypes.SE(stridmap),
                                                                         Datatypes.TE(tyconmap),
d1557 1
a1557 1
                EnvironTypes.LAMBDAEXP({index= NewMap.rank' (validmap,Ident.VAR(sym)) + offset,
d1567 2
a1568 2
                                                            Datatypes.ENV(Datatypes.SE(stridmap),
                                                                          Datatypes.TE(tyconmap),
d1573 1
a1573 1
                EnvironTypes.LAMBDAEXP'({index= NewMap.rank' (validmap,Ident.VAR(sym)) + offset,
d1591 1
a1591 1
               (do_moduler_debug(fn ()=>"UNDEFINED 13:"^Symbol.symbol_name sym);
d1598 1
a1598 1
                 (path, NewMap.apply strmap (Ident.STRID(sym))
d1603 2
a1604 4
                      "UNDEFINED 4:"^Symbol.symbol_name sym^".."
                      ^Symbol.symbol_name sym'^"..."
                      ^NewMap.fold (fn (str,Ident.STRID(sym),_)=>str^","
                                    ^Symbol.symbol_name sym) ("",strmap));
d1610 1
a1610 1
        fun fetch_nulltyfun (Datatypes.METATYNAME{1=tf as ref(Datatypes.NULL_TYFUN(_)), ...}) = tf
d1651 1
a1651 1
                    fun strexp_lookup (EnvironTypes.DENVEXP (denv)) = denv_lookup denv
d1667 2
a1668 2
                                    Datatypes.ENV(Datatypes.SE(se_map),
                                                  Datatypes.TE(te_map),
d1690 1
a1690 1
                          {index = n + size', size = size} :: str_lookup(str)
d1706 1
a1706 1
               (do_moduler_debug(fn ()=>"UNDEFINED 12:"^Symbol.symbol_name sym);
d1710 2
a1711 2
              fun insert_strid(Ident.NOPATH) = Ident.PATH(sy,Ident.NOPATH)
                | insert_strid(Ident.PATH(sym,path)) = Ident.PATH(sym,insert_strid path)
d1715 1
a1715 1
                  lookup (fn result=>result) (insert_strid path, NewMap.apply strmap (Ident.STRID(sym)))
d1717 1
a1717 1
                    (do_moduler_debug(fn ()=>"UNDEFINED 11:"^Symbol.symbol_name sym);
d1729 2
a1730 2
                           Datatypes.ENV(Datatypes.SE(stridmap),
                                         Datatypes.TE(tyconmap),
d1738 1
a1738 1
              (fn (env, tc' as Ident.TYCON(tc), tystr) =>
d1740 1
a1740 1
               (env, (Ident.TYCON'(tc), LAMBDAEXP({index=NewMap.rank' (tyconmap,tc'),
d1764 1
a1764 1
          | EnvironTypes.LAMBDASTREXP(args) =>
d1766 1
a1766 1
          | EnvironTypes.LAMBDASTREXP'(args) =>
d1778 1
a1778 1
      val empty_dstrexp = EnvironTypes.DENVEXP(empty_denv)
d1839 1
a1839 1
      (** Definition of overloading function **)
d1842 1
a1842 1
          (cg_longvalid (mklongvalid (Ident.VAR(Symbol.find_symbol overload_function_string)),env),[],
d1845 1
a1845 1
            (do_moduler_debug(fn ()=>"WARNING : redefining overload function");
d1854 1
d1859 1
a1859 1
                                                      LambdaTypes.VAR(args))),
d1862 1
a1862 1
                                                       LambdaTypes.VAR(args))),
d1865 6
a1870 6
                                                         LambdaTypes.VAR(args))),
                       LambdaTypes.LET((lvar,Option.ABSENT,LambdaTypes.VAR(dexp')),
                          LambdaTypes.SWITCH(LambdaTypes.VAR(lvar),
                                             Option.PRESENT{num_vccs=1,num_imms=1},
                                             [(LambdaTypes.IMM_TAG("ABSENT",0),
                                               LambdaTypes.VAR(new_cg)),
d1873 1
a1873 1
                                               (LambdaTypes.VAR(new_cg),
d1878 1
a1878 1
                                                    LambdaTypes.VAR(lvar))
d1881 1
a1881 1
                                                  LambdaTypes.SWITCH(LambdaTypes.VAR(instance_var),
d1883 1
a1883 1
                                                                     [(LambdaTypes.SCON_TAG(Ident.INT("~1",Location.UNKNOWN)),
d1888 1
a1888 1
                                                                                                                            LambdaTypes.VAR(instance_var)],
d1893 1
a1893 1
                  overload_function_string,Datatypes.NULLTYPE,Option.ABSENT)
d1899 1
a1899 1
                                      (Ident.VAR(Symbol.find_symbol(overload_function_string)),
d1916 2
a1917 2
      fun dexp_to_lambda(EnvironTypes.NULLEXP) = LambdaTypes.INT 0
        | dexp_to_lambda(EnvironTypes.INT(i)) = 
d1920 1
a1920 1
        | dexp_to_lambda(EnvironTypes.LAMBDAEXP(selects,(lv,_),_)) =
d1923 1
a1923 1
        | dexp_to_lambda(EnvironTypes.LAMBDAEXP'(selects,functorlv,_)) =
d1933 3
a1935 3
      fun dexp_to_lambda'(EnvironTypes.NULLEXP) = LambdaTypes.INT (~6)(* functors without constraints *)
        | dexp_to_lambda'(EnvironTypes.INT(i)) = LambdaTypes.INT (i)
        | dexp_to_lambda'(EnvironTypes.LAMBDAEXP(selects,(lv,_),_)) =
d1938 1
a1938 1
        | dexp_to_lambda'(EnvironTypes.LAMBDAEXP'(selects,functorlv,_)) =
d1958 1
d1971 2
a1972 2
             | Option.PRESENT(ref(Datatypes.NO_INSTANCE)) => new_cg
             | Option.PRESENT(_) =>
d1983 1
a1983 1
          val dexp' = dexp_to_lambda (dexp)
d1987 1
a1987 1
          | EnvironTypes.INT(i) =>
d2009 1
a2009 1
                                                   | Option.PRESENT(i) => LambdaTypes.INT i],
d2022 1
a2022 1
                     | Option.PRESENT(i) =>
d2051 1
a2051 1
                                               Option.ABSENT)
d2060 1
a2060 1
                        | Option.PRESENT(i) =>
d2093 2
a2094 2
                                                       Datatypes.ENV(Datatypes.SE(stridmap),
                                                                     Datatypes.TE(tyconmap),
d2113 1
a2113 1
              LambdaTypes.STRUCT(Lists.reducer (fn ((Ident.TYCON'(_),dexp),tycons) =>
d2117 1
a2117 1
                                 Lists.reducer (fn ((Ident.TYCON'(_),_),vars) => vars
d2120 1
a2120 1
                                 map (fn (_,dstrexp)=>dstrexp_to_lambda dstrexp)
d2126 2
a2127 2
      fun str_to_lambda(Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                        Datatypes.TE(tyconmap),
d2131 1
a2131 1
                           map (fn _ =>LambdaTypes.INT 0)
d2133 1
a2133 1
                           map (fn (_,str)=> str_to_lambda str)
d2161 1
a2161 1
        | merge_dexps (_,EnvironTypes.LAMBDAEXP(selects,lv,Option.PRESENT(_)),Option.PRESENT(tystr),_) =
d2163 1
a2163 1
        | merge_dexps(_,EnvironTypes.LAMBDAEXP'(selects,lv,Option.PRESENT(_)),Option.PRESENT(tystr),_) =
d2169 1
a2169 1
          merge_dstrexps(dstr,Option.PRESENT(str),dstrexp, location)
d2178 2
a2179 2
                                Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                                Datatypes.TE(tyconmap),
d2191 1
a2191 1
                 (fn (env, tc' as Ident.TYCON(tc), tystr) =>
d2193 1
a2193 1
                  (env, (Ident.TYCON'(tc), LAMBDAEXP({index=NewMap.rank' (tyconmap,tc'),
d2201 1
a2201 1
                          merge_dstrexps(debugger_str,Option.PRESENT(str),
d2215 1
a2215 1
                merge_dstrexps (debugger_str,Option.PRESENT(str),LAMBDASTREXP(selects,lv,str'), location)
d2218 1
a2218 1
             EnvironTypes.LAMBDASTREXP(args) =>
d2220 1
a2220 1
           | EnvironTypes.LAMBDASTREXP'(args) =>
d2227 4
a2230 4
                     (fn (map,tc' as Ident.TYCON(tc),i)=>
                      NewMap.define(map,Ident.TYCON'(tc),
                        merge_dexps(EnvironTypes.INT(i),
                                        NewMap.apply validmap' (Ident.TYCON'(tc)),
d2234 2
a2235 2
                                  | (v,Option.PRESENT(i)) =>
                                      merge_dexps(EnvironTypes.INT(i),
d2238 2
a2239 2
                     NewMap.map (fn (strid,dstr)=>
                                 merge_dstrexps(ref(dstr),
d2245 1
a2245 1
                     NewMap.map (fn (Ident.TYCON'(tc),dexp)=>
d2247 1
a2247 1
                                  Option.PRESENT(NewMap.apply'(tyconmap'',Ident.TYCON(tc))), location)
d2249 1
a2249 1
                     NewMap.map (fn (strid,dstrexp)=>
d2255 1
a2255 1
        | merge_dstrexps(ref(Datatypes.EMPTY_DSTR), Option.ABSENT, dstrexp, _) = dstrexp
d2268 1
a2268 1
            | filter_vars ((Ident.TYCON'(_),_)::vars) index = filter_vars vars (index+1)
d2284 1
a2284 1
           reducel (fn (env,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env'))=>
d2287 1
a2287 1
                           | (env,((strid,(_,comp,_)),env'))=>
d2289 2
a2290 2
           (reducel (fn (env,(Ident.TYCON'(_),_))=>env
                            | (env,(valid,EnvironTypes.FIELD{index, ...}))=>
d2293 1
a2293 1
                            | (env,valid)=>Environ.add_valid_env(env,valid))
d2302 2
a2303 2
                                            Datatypes.ENV(Datatypes.SE(stridmap),
                                                          Datatypes.TE(tyconmap),
d2321 1
a2321 1
                               Option.ABSENT)::prepend_tycons tycons
d2333 1
a2333 1
            reducel (fn (map,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env))=>
d2336 1
a2336 1
                            | (map,((strid,(_,comp,_)),env))=>
d2338 2
a2339 2
            (#1(reducel (fn ((map,index),(Ident.TYCON(tc),_))=>
                            (Environ.add_valid_env(map,(Ident.TYCON'(tc),
d2341 1
a2341 1
             ((EnvironTypes.ENV(NewMap.map (fn (_,EnvironTypes.FIELD{index, ...})=>
d2351 2
a2352 2
                                            Datatypes.ENV(Datatypes.SE(stridmap),
                                                          Datatypes.TE(tyconmap),
d2357 2
a2358 2
                  (NewMap.fold (fn (map,Ident.TYCON(tc),_) =>
                                NewMap.define(map,Ident.TYCON'(tc),EnvironTypes.INT(~5)))
d2361 1
a2361 1
                  NewMap.map (fn (_,str)=> make_dstrexp str) stridmap))
d2363 2
a2364 2
      fun fetch_interface(Option.PRESENT(ref(Option.PRESENT(interface)))) = interface
        | fetch_interface(Option.PRESENT(_)) =
d2370 1
a2370 1
        val empty_dstr = ref(Datatypes.EMPTY_DSTR)
d2372 2
a2373 2
        fun fetch_debugger_str(Option.PRESENT(debugger_str)) = debugger_str
          | fetch_debugger_str(Option.ABSENT) = empty_dstr
d2376 2
a2377 2
      fun fetch_tyfun(Option.PRESENT(tyfun)) = tyfun
        | fetch_tyfun (Option.ABSENT) =
d2390 1
a2390 1
              reducel (fn (spills,ty)=>spills@@type_spills ty)
d2395 2
a2396 2
              | type_spills (Datatypes.RECTYPE(map)) =
                Datatypes.Mapping.fold (fn (spills,ty)=>spills@@type_spills ty) (nil,map)
d2412 1
a2412 1
                (Datatypes.METATYNAME(tf as ref(Datatypes.NULL_TYFUN(_)),name,_,_,
d2418 1
a2418 1
                     (* do_moduler_debug (fn () => "spill for "^name); *)
d2441 2
a2442 2
                     NewMap.fold (fn (spills,_,tysch)=>spills@@typescheme_spills (denv,tysch)) (nil,ve))
                | tyname_spills (Datatypes.METATYNAME(ref(Datatypes.ETA_TYFUN(tyn)),_,_,_,
d2448 1
a2448 1
                      NewMap.fold (fn (spills,_,tysch)=>
d2456 1
a2456 1
                      NewMap.fold (fn (spills,_,tysch)=>
d2468 1
a2468 1
                       NewMap.fold (fn (spills,_,tysch)=>
d2480 1
a2480 1
        if Types.isFunType(ty) then ()
d2484 1
a2484 1
              map (fn (tf,dexp)=>(tf, ref (RuntimeEnv.OFFSET1 0),dexp))
d2488 1
a2488 1
            (inforef := (RuntimeEnv.RUNTIMEINFO (i,map (fn (tf,spill,_)=>(tf,spill)) spills));
d2535 1
a2535 1
        (fn (lambda,lambdalist)=>LambdaTypes.STRUCT([lambda,lambdalist],LambdaTypes.TUPLE)) (lambdas,LambdaTypes.INT(1))
d2537 2
a2538 2
      val dummy_false = ref(false)
      val dummy_ve = ref(Datatypes.empty_valenv)
d2549 1
a2549 1
              | TYPEdec_spills ((_,tycon as Ident.TYCON(sym),_,tyf)::rest) (env,denv,bindings) =
d2554 1
a2554 1
                  (Environ.add_valid_env(env, (Ident.TYCON'(sym),
d2556 1
a2556 1
                   add_valid_denv(denv, (Ident.TYCON'(sym),EnvironTypes.NULLEXP)),
d2560 1
a2560 1
                                                   (map (fn (_,spill)=>spill)
d2564 2
a2565 2
                                                   (init_null_tyfun_spills(); "spills for tycon "
                                                    ^IdentPrint.printTyCon tycon),
d2567 1
a2567 1
                                                   Option.ABSENT))::bindings)
d2587 1
a2587 1
                    Environ.add_valid_env(env, (Ident.TYCON'(sym),
d2589 1
a2589 1
                  val new_denv = add_valid_denv(denv, (Ident.TYCON'(sym),EnvironTypes.NULLEXP))
d2595 1
a2595 1
                                      (map (fn (_,spill)=>spill)
d2599 2
a2600 2
                                      (init_null_tyfun_spills(); "spills for tycon "
                                       ^IdentPrint.printTyCon tycon),
d2602 1
a2602 1
                                      Option.ABSENT))
d2617 2
a2618 3
            (* lv = lexp;
               lv' = make_poly_binding lv
             *)
d2621 1
a2621 1
                              make_poly_binding(debug_info,instance,LambdaTypes.VAR(lv),location))]
d2625 1
d2631 2
a2632 1
        if do_stepper andalso not (Types.isFunType ty) andalso not (funny_name_p name)
d2672 1
a2672 1
          | Absyn.VALexp(longValId, ref ty,location,ref(instance_info,instance)) =>
d2695 1
a2695 1
				Environ.is_overloaded_op (valid)
d2703 1
a2703 1
			     "_" ^ overloaded_name (ty) ^ sy_name
d2766 4
a2769 2
                     (* pass instance around at runtime *)
                       (longvalid_dexp_to_lambda(longValId,denv,new_cg,instance,instance_info))
d2774 1
a2774 1
                     val lexp = LambdaTypes.INT(tag)
d2807 1
a2807 1
			    LambdaTypes.null_type_annotation,Option.ABSENT)
d2823 1
a2823 1
                                        Option.ABSENT)
d2874 1
a2874 1
              LambdaTypes.BUILTIN(Pervasives.EQ) =>
d2876 1
a2876 1
            | LambdaTypes.BUILTIN(Pervasives.NE) =>
d2927 1
a2927 1
            LambdaTypes.APP(fcn, [arg],Option.PRESENT(annotation))
d2982 1
a2982 1
          val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
a3093 1
         For a definition of the support routines used, see lambdautils.sml
d3121 1
a3121 1
              val match_trans_count_ref : int ref = ref(~1)
d3134 1
a3134 1
              LambdaUtils.add_match_env((root,(root_lambda,Option.ABSENT)),LambdaUtils.empty_match_env)
d3174 1
a3174 1
                val bindings = map (fn (_,_,_,bd)=>bd) redundant_clauses
d3202 1
a3202 1
                                                      Location.to_string location^": "^"warning"^": "^
d3262 1
a3262 1
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(explode(rc)))))))))],
d3324 1
a3324 1
                     | do_binding (Option.SOME1 (ref(Option.ABSENT))::bindings) =
d3326 1
a3326 1
                     | do_binding (Option.SOME1 (ref(Option.PRESENT(lvar as ref(Option.SOME1(_,tree)))))::bindings) =
d3329 1
a3329 1
                         val fnname' = 
d3336 1
a3336 1
                         (lvar := Option.SOME2(lv); (* Something to do with match compilation *)
d3339 2
d3346 1
a3346 1
                                    make_handle_for_stepper (* Wrap a break on exn handler round *)
d3349 1
a3349 1
                                val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3353 3
a3355 2
                                fnname',
                                LambdaTypes.null_type_annotation,Option.ABSENT)))
d3358 1
a3358 1
                     | do_binding (Option.SOME1(_)::_) =
d3360 1
a3360 1
                     | do_binding (Option.SOME2(lvar' as ref(Option.SOME1(_,tree)),matchvar)::bindings) =
d3363 1
a3363 1
                         val fnname' = 
d3365 1
a3365 1
                               add_match_string (name_string,"<Match"^ makestring(new_match_trans()) ^ ">")
d3368 1
a3368 1
                                                 "<Match"^ makestring(new_match_trans()) ^ ">")
d3370 1
a3370 1
                         (lvar' := Option.SOME2(lv); (* Something to do with match compilation *)
d3373 1
d3379 1
a3379 1
                                    make_handle_for_stepper (* Wrap step handler round evaluation *)
d3386 1
a3386 1
                                                                   LambdaUtils.add_match_env
d3391 1
a3391 1
                                val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3395 3
a3397 2
                                fnname',
                                LambdaTypes.null_type_annotation,Option.ABSENT)))
d3399 1
a3399 1
                     | do_binding (Option.SOME2(_)::_) =
d3405 1
a3405 1
                 let fun Tr_Default (ref(Match.BUILT(ref(Option.SOME2(lvar))))) = 
d3407 1
a3407 1
	                    LambdaTypes.APP(LambdaTypes.VAR(lvar),
d3413 2
a3414 2
                     |   Tr_Default (ref(Match.ERROR(_))) = 
                            Option.PRESENT(excp)
d3418 3
a3420 3
                        Option.SOME1(Match.PRESENT(default)) => Tr_Default default
                      | Option.SOME1(Match.ABSENT) => Option.ABSENT
                      | Option.SOME2(ref(Option.SOME2(lvar))) => 
d3422 1
a3422 1
	                    LambdaTypes.APP(LambdaTypes.VAR(lvar),
d3425 1
a3425 1
                      | Option.SOME2(_) => Crash.impossible "2:Tr_Default:tr_match:_lambda.sml"
d3435 1
a3435 1
                          case LambdaUtils.lookup_match(mv, match_env) of
d3448 1
a3448 1
                                        LambdaTypes.VAR(lv)),
d3459 1
a3459 1
                             else 
d3485 1
a3485 1
	                 LambdaTypes.VAR(#1(LambdaUtils.lookup_match(mv, match_env))),
d3493 2
a3494 2
                         val default = Tr_Default (Option.SOME1(Match.PRESENT(default)))
                         val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3503 1
a3503 1
                                             | Option.PRESENT(bd) =>[Option.SOME1(bd)],
d3508 1
a3508 1
                    val ORIG_LV = LambdaUtils.lookup_match(mv, match_env)
d3543 1
a3543 1
                    fun tr_match'(Option.SOME1(tree),match_env, val_env) =
d3545 2
a3546 2
                      | tr_match'(Option.SOME2(ref(Option.SOME2(lvar))),_, _) =
                        LambdaTypes.APP(LambdaTypes.VAR(lvar),
d3549 1
a3549 1
                      | tr_match'(Option.SOME2(_), _, _) =
d3568 1
a3568 1
                                     LambdaUtils.add_match_env((mv, ORIG_LV), match_env),
d3576 2
a3577 1
                                then Option.PRESENT (ref (RuntimeEnv.NOVARINFO))
d3582 1
a3582 1
                                       LambdaUtils.add_match_env((mv, (new_lv,info)), match_env),
d3606 1
a3606 1
                                    LambdaTypes.BUILTIN(Pervasives.REF) => true 
d3613 2
a3614 1
                              then Option.PRESENT (ref (RuntimeEnv.NOVARINFO))
d3623 2
a3624 2
			              LambdaUtils.add_match_env((mv, (new_lv,info)),
                                                                match_env),
d3635 1
a3635 2
			          LambdaUtils.add_match_env((mv, ORIG_LV),
				 			   match_env),
d3672 1
a3672 1
                    val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3681 2
a3682 1
                  then Option.PRESENT (ref (RuntimeEnv.NOVARINFO))
d3699 1
a3699 2
                                    LambdaUtils.add_match_env((mv, (new_lv,info)),
                                                              match_env),
d3704 1
a3704 1
                    val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3724 1
a3724 1
                    val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3748 1
a3748 1
                   (new_LVar(),Option.PRESENT (ref (RuntimeEnv.NOVARINFO)))))
d3754 1
a3754 1
	  val le = LambdaTypes.VAR (#1(LambdaUtils.lookup_match(mv, match_env)))
d3756 1
a3756 1
	    (fn (env, (_, x, y)) => LambdaUtils.add_match_env((x, y), env))
d3771 1
a3771 1
              case Tr_Default (Option.SOME1(Match.PRESENT(default))) of
d3773 1
a3773 1
              | Option.PRESENT(lexp) => lexp
d3778 1
a3778 1
                                     | Option.PRESENT(bd) => [Option.SOME1(bd)],
d3785 1
a3785 1
     if do_stepper then
d3787 1
a3787 1
         val res_ty = #2(Types.argres(ty))
d3804 1
a3804 1
                         (make_handle_for_stepper (* Wrap step handler round whole match *)
d3812 1
a3812 1
                      val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d3816 1
a3816 1
                    name_string,ty,Option.ABSENT))
d3885 1
a3885 1
                                                        [(LambdaTypes.SCON_TAG(scon), 
d3904 1
a3904 1
                      | Ident.PATH(_) => Crash.impossible
d3906 1
a3906 1
                 | Ident.CON(_) =>
d3938 1
a3938 1
                                           [(LambdaTypes.EXP_TAG(#1(cg_longexid(longvalid, envir))),
d3972 1
a3972 1
                   (env_list_lambda_list_list),
d3991 1
a3991 1
                                  LambdaTypes.BUILTIN(Pervasives.REF) => true
d4079 1
a4079 1
                   Ident.VAR(vid) =>
d4143 1
a4143 1
                      @@ new_bindings @@ make_step_call (fnname)))
d4156 1
a4156 1
                           ((new_lv,Option.PRESENT (ref (RuntimeEnv.NOVARINFO))),
d4219 3
a4221 3
                  fun pat_name(Absyn.VALpat((Ident.LONGVALID(_, valid), _),_)) = valid_name valid
                    | pat_name(Absyn.WILDpat) = "<wild>"
                    | pat_name(Absyn.LAYEREDpat((valid, _), pat)) =
d4225 1
a4225 1
                    | pat_name(Absyn.TYPEDpat (pat,_,_)) = pat_name pat
d4241 1
a4241 2
                              | _ => Crash.impossible 
                                  "debug_polyvariables:recletb:trans_dec:lambda")
d4279 1
a4279 1
          val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
d4326 10
a4335 15
                  let
                    val Debugger_Types.INFO i = !debugger_env_ref
                  in
                    (* Add exception info to global debugger_env *)
                    debugger_env_ref :=
                    Debugger_Types.INFO
                    (NewMap.define
                     (i, exn_string,
                      Debugger_Types.FUNINFO
                      {ty = ty,
                       is_leaf = false,
                       annotations = [],
                       runtime_env = Debugger_Types.empty_runtime_env, 
                       is_exn = true}))
                  end
d4364 1
a4364 1
                           ([select_exn_unique(exp),
d4441 1
a4441 1
                | (EnvironTypes.NOSPEC,longstrid) => EnvironTypes.STRIDSPEC (longstrid)
d4467 1
a4467 1
	       (fn (_, (_, EnvironTypes.FIELD(field), _), l) =>
d4539 1
a4539 1
           val _ = dynamic_redundancy_report_ref := (fn exp=>exp)
d4563 1
a4563 1
          (env, lambda_exp, EnvironTypes.DENVEXP(denv))
d4845 1
a4845 1
          LambdaTypes.SELECT({index=0,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(lvar))),
d4847 1
a4847 1
               LambdaTypes.SELECT({index=1,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(lvar))),
d4849 1
a4849 1
               LambdaTypes.SELECT({index=2,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(lvar))),
d4879 1
a4879 1
                                        LambdaTypes.null_type_annotation,Option.ABSENT))])
d4931 1
a4931 1
  val c = overload_binding@@stepper_binding@@
d4954 1
a4954 1
       Environ.augment_top_env(a,make_top_env (stepper_env(make_env env))))
@


1.166
log
@Attempting to sort out the debugger code
@
text
@d4 3
a467 1
require "lambdasub";
d485 1
a485 1
  structure Type_Utils : TYPE_UTILS
a489 1
  structure LambdaSub: LAMBDASUB
d497 3
a499 3
  sharing LambdaUtils.LambdaTypes = LambdaSub.LT =
    LambdaOptimiser.LambdaTypes = Environ.EnvironTypes.LambdaTypes = LambdaPrint.LambdaTypes
  sharing Types.Datatypes = Type_Utils.DataTypes = TyperepUtils.Datatypes =
a501 1
  sharing LambdaSub.LT.Set = AbsynPrint.Absyn.Set
d512 1
d523 1
a523 1
  sharing type LambdaSub.LT.Instance = Types.Datatypes.Instance = AbsynPrint.Absyn.Instance =
d695 1
a695 1
      val (location,valenv) = Type_Utils.get_valenv(Type_Utils.get_cons_type ty)
d706 1
a706 1
    val record_domain = Type_Utils.record_domain the_type
d778 2
a779 2
		Type_Utils.has_null_cons h andalso
		not(Type_Utils.has_value_cons h)
d1142 1
a1142 1
                      Type_Utils.is_vcc (Type_Utils.type_from_scheme ty)
d1260 1
d1267 1
a1267 2
			      generate_stepper, generate_moduler,
			      generate_stepper_specific, ...},
d1283 1
a1283 1
      val do_stepper = generate_stepper orelse generate_stepper_specific <> "" 
d1297 1
a1297 1
      fun new_tyvar_slot () = Option.PRESENT(ref (RuntimeEnv.OFFSET1 0))
d1304 1
a1304 1
      fun make_binding (debug_info,instance,lexp,location) = 
d1313 1
a1313 1
                | _ => Crash.impossible "1:make_binding:trans_dec"
d1331 2
a1332 2
                                          dummy_instance(),
                                          tyvar_slot))),
d1342 1
a1342 1
                                 Option.PRESENT(RuntimeEnv.FUNINFO (instance,tyvar_slot)))
d1352 1
a1352 1
                                                     tyvar_slot))),
d1489 1
a1489 1
        if do_stepper andalso substring(generate_stepper_specific,fnname) then
d1499 1
a1499 1
        if do_stepper andalso substring(generate_stepper_specific, fnname) andalso not (funny_name_p name)
d1508 1
a1508 1
        if do_stepper andalso substring(generate_stepper_specific,fnname) andalso not (funny_name_p name)
d1519 1
a1519 1
        if do_stepper andalso substring(generate_stepper_specific,fnname) 
d1531 1
a1531 1
        if do_stepper andalso substring(generate_stepper_specific,fnname) 
d2691 1
a2691 1
      fun make_binding' ((lv,lv'),debug_info,instance,lexp,comment,location) = 
d2695 1
a2695 1
               lv' = make_binding lv
d2699 1
a2699 1
                              make_binding(debug_info,instance,LambdaTypes.VAR(lv),location))]
d2708 1
a2708 2
        if do_stepper andalso not (Types.isFunType ty) andalso 
          substring(generate_stepper_specific,fnname) andalso not (funny_name_p name)
d2714 3
a2716 3
              let_lambdas_in_exp(make_binding'((lvar,lvar), debug_info,
                                               Option.ABSENT,lexp,function_return_string,"") @@
                                 make_step_call (Option.PRESENT (fnname,fnname_lv)),
d2853 1
a2853 1
                       if Type_Utils.is_vcc ty then
d2859 2
a2860 2
                            if Type_Utils.get_no_cons ty > 1  andalso
                               not (is_list_type (Type_Utils.get_cons_type ty))
d2866 1
a2866 1
				val cons_type = Type_Utils.get_cons_type ty
d2889 1
a2889 1
                     if Type_Utils.is_vcc ty then
d2989 1
a2989 1
                if Type_Utils.get_no_cons ty > 1 then
d3583 1
a3583 1
                      Type_Utils.get_valenv(Type_Utils.get_cons_type ty)
d3592 1
a3592 1
                      (case Type_Utils.type_from_scheme(
d3658 2
a3659 2
                      if Type_Utils.get_no_cons ty = 1 then
                        (* Use this instead of Type_Utils.has_value_cons ty, because
d3724 2
a3725 2
	              num_vccs = Type_Utils.get_no_vcc_cons ty,
		      num_imms = Type_Utils.get_no_null_cons ty
d3738 1
a3738 1
                        Type_Utils.get_no_cons ty then
d3979 1
a3979 1
                       val one_con = Type_Utils.get_no_cons ty = 1
d3987 2
a3988 2
                                    num_imms = Type_Utils.get_no_null_cons ty,
                                    num_vccs = Type_Utils.get_no_vcc_cons ty},
d4033 1
a4033 1
                        make_binding'((lv,lv'),debug_info,instance,le,"",location)
d4074 2
a4075 2
                          make_binding'((new_lv,new_lv'),debug_info,instance,lexp,
                                           "Dereferencing a pattern",location)
d4080 1
a4080 1
                       if Type_Utils.get_no_cons ty = 1 then
d4094 2
a4095 2
                                                  num_vccs = Type_Utils.get_no_vcc_cons ty,
                                                  num_imms = Type_Utils.get_no_null_cons ty
d4098 1
a4098 1
                                     if is_list_type (Type_Utils.get_cons_type ty) then
d4103 1
a4103 1
                                   if Type_Utils.get_no_cons ty <> 1 then
d4110 2
a4111 2
                            make_binding'((new_lv,new_lv'),debug_info,instance,lexp,"",
                                          location)
d4135 2
a4136 2
                        make_binding'((new_lv,new_lv'),debug_info,instance,lexp,"",
                                      location)
d4210 2
a4211 2
                      make_binding'((lvar,lvar'),debug_info,instance,lambda,"",
                                    location')
d4309 1
a4309 1
                                  make_binding(debug_info,instance,LambdaTypes.VAR(lv''),location)
@


1.165
log
@Changing uses of cast
@
text
@d4 3
a459 1
require "../debugger/debugger_env";
d521 1
a528 1
  sharing type LambdaUtils.LambdaTypes.LVar = int
d589 31
d632 3
a638 30
  fun str_filter_ordered_map (eq, a_list, f_list, print_fn) =
    let
      fun str_filter_map (eq, a_list, [], _, done) = rev done
        | str_filter_map (eq, [], x :: _, print_fn, done) =
          Crash.impossible("member '" ^ print_fn x ^
                           "' missing in str_filter_map")
        | str_filter_map(eq, (x, y)::xs, second as (z :: zs), print_fn, done) =
          if eq (x, z) then
            str_filter_map(eq, xs, zs, print_fn, (x, y) :: done)
          else
            str_filter_map(eq, xs, second, print_fn, done)
    in
      str_filter_map(eq, a_list, f_list, print_fn, [])
    end

  fun val_filter_ordered_map (a_list, f_list, a_print_fn, f_print_fn) =
    let
      fun val_filter_map (a_list, [], _, done) = rev done
        | val_filter_map ([], z :: _, print_fn, done) =
          Crash.impossible("member '" ^ print_fn z ^
                           "' missing in val_filter_map")
        | val_filter_map((x, y)::xs, second as (z :: zs), print_fn, done) =
          if Ident.valid_eq (x, z) then
            val_filter_map(xs, zs, print_fn, (x, y) :: done)
          else
            val_filter_map(xs, second, print_fn, done)
    in
      val_filter_map(a_list, f_list, f_print_fn, [])
    end

d652 3
d657 1
a657 1
    val l = LambdaTypes.new_LVar()
d673 1
a673 1
      val l = LambdaTypes.new_LVar()
d682 1
d792 1
a792 1
    LambdaTypes.SELECT({index = 1, size = 2,selecttype=LambdaTypes.CONSTRUCTOR}, lexp)
d812 2
a813 2
      (* generate_moduler indicates if the structure was compiled with module debugging on *)
      val (env', comp, generate_moduler) = Environ.lookup_strid(strid, env)
d816 2
a817 2
	EnvironTypes.LAMB (lvar,longstrid) => (env', LambdaTypes.VAR lvar, longstrid, generate_moduler)
      | EnvironTypes.PRIM prim => (env', LambdaTypes.BUILTIN prim, Option.ABSENT, generate_moduler)
d822 1
a822 1
	    Option.ABSENT), Option.ABSENT, generate_moduler)
a829 3
  fun make_tuple_select {index,size} =
    {index = index,size = size, selecttype = LambdaTypes.TUPLE}

d839 1
a839 1
  fun get_field_env'(strid, (env, lambda, longstrid, generate_moduler)) =
d842 1
a842 1
	(env'', EnvironTypes.FIELD(field), generate_moduler) => (env'', field, generate_moduler)
d845 1
a845 1
      (env', LambdaTypes.SELECT(make_struct_select field, lambda), longstrid, generate_moduler)
d848 27
a874 26
  fun cg_longvalid (longvalid, env) = case longvalid of
    Ident.LONGVALID(Ident.NOPATH, valid) =>
      (case Environ.lookup_valid(valid, env) of
	 EnvironTypes.LAMB(lvar,_) => LambdaTypes.VAR lvar
       | EnvironTypes.PRIM prim =>
	   (case prim of
              Pervasives.NOT => notcode()
            | _ => LambdaTypes.BUILTIN prim)
       | EnvironTypes.EXTERNAL =>
	   LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_VAR,
			   [LambdaTypes.SCON(Ident.STRING(valid_name valid))],
			   Option.ABSENT)
       | EnvironTypes.FIELD _ => Crash.impossible "cg_longvalid gives field")
  | Ident.LONGVALID(path, valid) =>
    let
      val (env', lambda) =
	Ident.followPath'(get_lamb_env, get_field_env) (path, env)
    in
      case Environ.lookup_valid(valid, env') of
	EnvironTypes.FIELD field => LambdaTypes.SELECT(make_struct_select field, lambda)
      | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
      | EnvironTypes.LAMB _ =>
	  Crash.impossible "cg_longvalid gets lambda var at end of longvalid"
      | EnvironTypes.EXTERNAL =>
	  Crash.impossible "cg_longvalid gets external at end of longvalid"
    end
d882 1
a882 1
             (LambdaTypes.BUILTIN prim, Option.ABSENT)
d886 1
a886 1
                             Option.ABSENT), Option.ABSENT)
d903 11
a913 10
  fun cg_longstrid (longstrid, env) =
    case longstrid of Ident.LONGSTRID(Ident.NOPATH, strid as Ident.STRID sy) =>
      (case Environ.lookup_strid(strid, env) of
	 (env, EnvironTypes.LAMB (lvar,longstrid), generate_moduler) => 
           (env, LambdaTypes.VAR lvar, longstrid, generate_moduler)
       | (env, EnvironTypes.PRIM prim, generate_moduler) =>
           (env, LambdaTypes.BUILTIN prim, Option.ABSENT, generate_moduler)
       | (env, EnvironTypes.EXTERNAL, generate_moduler) =>
	   (env,
	    LambdaTypes.APP
d917 19
a935 20
              Option.ABSENT, 
              generate_moduler)
       | (_, EnvironTypes.FIELD _, _) =>
	   Crash.impossible "cg_longstrid gives field")
  | Ident.LONGSTRID(path, strid) =>
    let
      val (env', lambda, longstrid, generate_moduler) =
	Ident.followPath'(get_lamb_env', get_field_env') (path, env)
    in
      case Environ.lookup_strid(strid, env') of
	(env''', EnvironTypes.FIELD field, _) =>
            (env''', LambdaTypes.SELECT(make_struct_select field, lambda), longstrid, generate_moduler)
      | (env''', EnvironTypes.PRIM prim, _) =>
	  (env''', LambdaTypes.BUILTIN prim, longstrid, generate_moduler)
      | (_, EnvironTypes.LAMB _, _) =>
	  Crash.impossible "cg_longstrid gets lambda var at end of longstrid"
      | (_, EnvironTypes.EXTERNAL, _) =>
	  Crash.impossible "cg_longstrid gets external at end of longstrid"
    end

d950 1
a950 1
  fun let_lambdas_in_exp(bindings, lambda_exp) =
d953 1
a953 1
  fun unordered_let_lambdas_in_exp(bindings, lambda_exp) =
d957 2
a962 1

d998 6
a1003 7
  |   compare_sig_env generate_moduler (Datatypes.STR (_, _, Datatypes.ENV
					     (Datatypes.SE sm,
				              Datatypes.TE tm,
				              Datatypes.VE (_, vm))),
    		      EnvironTypes.ENV(v_map, s_map)) =
    NewMap.size vm + (if generate_moduler then NewMap.size tm
                      else 0) = NewMap.size v_map andalso
d1007 3
a1009 3
      (compare_sig_env generate_moduler)
      (Lists.zip(NewMap.range_ordered sm,
	         map #1 (NewMap.range_ordered s_map)))
d1013 9
a1021 9
  |   complete_struct_with_sig
	(interface as Datatypes.STR (_, _, Datatypes.ENV
					     (Datatypes.SE sm,
					      Datatypes.TE tm,
					      Datatypes.VE (_, vm))),
         env as EnvironTypes.ENV(v_map, s_map),
	 lambda_var,
	 coerce,
         generate_moduler) =
d1023 2
a1024 2
   (if not(coerce) andalso compare_sig_env generate_moduler (interface, env) then
      (env, LambdaTypes.VAR lambda_var)
d1026 3
a1028 3
    let
      (* This function matches a structure against a signature.  It produces a 
         new strucutre consisting of lambda variables bound to selections of
d1032 20
a1051 5
      val v_list = NewMap.to_list_ordered v_map
      val s_list = NewMap.to_list_ordered s_map
      val ordered_int_map = NewMap.to_list_ordered sm
      val vm = 
        if generate_moduler then
d1053 28
a1080 1
            val dummy_scheme = Datatypes.UNBOUND_SCHEME(Datatypes.NULLTYPE,Option.ABSENT)
d1082 4
a1085 2
            NewMap.fold (fn (map,Ident.TYCON(sym),_)=>NewMap.define(map,Ident.TYCON'(sym),dummy_scheme))
            (vm,tm)
a1086 2
        else
          vm
d1088 21
a1108 31
      (* Throw out unwanted elements and assign new field numbers *)
      val (v_f_list,s_f_list,_) =
	Environ.number_envs
	(val_filter_ordered_map
	 (v_list, NewMap.domain_ordered vm,
	  IdentPrint.debug_printValId, IdentPrint.debug_printValId),
         str_filter_ordered_map
	 (Ident.strid_eq, s_list, map #1 ordered_int_map,
	  IdentPrint.printStrId),
         [])

      (* Now add lvs to be bound to the component in the old structure. *)
      val v_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar())) v_f_list
      val s_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar(), LambdaTypes.new_LVar()))
	    s_f_list
      (* First lv is to be the constraint result *)
      (* Second lv is to be bound to the old structure *)

      (* make a list of the lvs in the new structure *)
      val the_structure_list =
	map (fn (_, x) => LambdaTypes.VAR x) v_f_l_list @@
	map (fn (_, x, _) => LambdaTypes.VAR x) s_f_l_list

      (* Recursively restrict all remaining substructures *)
      val env_le_list =
	map complete_struct_with_sig
	    (map (fn ((((_, (env, _, _)), _), _, l2), (_, inte)) =>
		    (inte, env, l2, coerce, generate_moduler))
	         (Lists.zip(s_f_l_list, ordered_int_map)))
d1110 1
a1110 1
      (* Generate a lambda environment that binds the remaining identifiers
d1112 2
a1113 2
      fun keep_prims (x as EnvironTypes.PRIM _) _ = x
        | keep_prims _ x = x
d1115 2
a1116 2
      val env =
	reducel
d1118 1
a1118 1
	     Environ.add_valid_env(env, (v, keep_prims x f_new)))
d1120 3
a1122 3
	     (fn (env, (((strid, _), field), (env', _))) =>
	        Environ.add_strid_env(env, (strid, (env', field, generate_moduler))))
	     (Environ.empty_env, (Lists.zip(s_f_list, env_le_list))),
d1125 2
a1126 2
      fun coerce (valid as Ident.EXCON _, lexp) =
	(* If this valid is a constructor, and the corresponding valid in
d1128 2
a1129 1
 	let val res = NewMap.tryApply'Eq (vm, valid)
d1134 24
a1157 26
        in
	  if need_coerce then
	    let
	      val _ = Diagnostic.output 2 (fn _ => ["coercing ",IdentPrint.debug_printValId valid])
	      val is_vcc =
	        case res' of
	          MLWorks.Option.SOME ty =>
		    Type_Utils.is_vcc (Type_Utils.type_from_scheme ty)
	        | _ =>
		    Crash.impossible "coerce"
	    in
	      if is_vcc then
                let val lv = LambdaTypes.new_LVar()
                in
                  LambdaTypes.FN([lv],
				 LambdaTypes.STRUCT([lexp, LambdaTypes.VAR lv],LambdaTypes.CONSTRUCTOR),
                                 "Builtin code to construct an exception",
                                 LambdaTypes.null_type_annotation,Option.ABSENT)
                end
	      else
                LambdaTypes.STRUCT([lexp, unit_exp],LambdaTypes.CONSTRUCTOR)
	    end
	  else
	    lexp
	end
      | coerce (_, lexp) = lexp
d1159 1
a1159 1
      (* Now bind the new lambda variables to the corresponding old
d1161 8
a1168 7
      val l1 =
	(map (fn (((valid, EnvironTypes.FIELD f_old), _), lv) =>
                LambdaTypes.LETB
		  (lv,Option.ABSENT,
		   coerce (valid, LambdaTypes.SELECT
				    (make_struct_select f_old, LambdaTypes.VAR lambda_var)))
              |  (((valid, EnvironTypes.PRIM prim), _), lv) =>
d1170 17
a1186 16
	      |  (((_, EnvironTypes.LAMB _), _), _) =>
		Crash.impossible "c_s_w_i(1)"
	      |  (((_, EnvironTypes.EXTERNAL), _), _) =>
		Crash.impossible "c_s_w_i(2)")
	     v_f_l_list)

      val l2 =
	(map (fn ((((_, (env, EnvironTypes.FIELD f_old, _)), _), lv, lv'), le) =>
                LambdaTypes.LETB
                (lv,Option.ABSENT, 
                   LambdaTypes.do_binding
                     (LambdaTypes.LETB
			(lv',Option.ABSENT,
			 LambdaTypes.SELECT(make_struct_select f_old, LambdaTypes.VAR lambda_var)),
		      le))
	      |  ((((_, (_, EnvironTypes.LAMB _, _)), _), _, _), _) =>
d1188 5
a1192 5
	      |  ((((_, (_, EnvironTypes.PRIM _, _)), _), _, _), _) =>
	        Crash.impossible "c_s_w_i (4) PRIM"
	      |  ((((_, (_, EnvironTypes.EXTERNAL, _)), _), _, _), _) =>
	        Crash.impossible "c_s_w_i (5) EXTERNAL")
	     (Lists.zip(s_f_l_list, map #2 env_le_list)))
d1194 7
a1200 7
      val lambdas = let_lambdas_in_exp(l1 @@ l2,
        			       LambdaTypes.STRUCT (the_structure_list,LambdaTypes.STRUCTURE))
    in
      (* Return the environment (binding ids to fields in the new structure)
	 and the lambda expression representing the structure itself. *)
      (env, lambdas)
    end) (* of complete_struct_with_sig *)
d1235 3
a1237 2
    | Option.PRESENT inte =>
        if not(coerce) andalso compare_sig_env generate_moduler (inte, new_env) then result
d1240 1
a1240 1
	    val new_lv = LambdaTypes.new_LVar()
d1242 1
a1242 1
	      complete_struct_with_sig(inte, new_env, new_lv, coerce, generate_moduler)
d1251 3
a1253 6
  fun interface_from_sigexp
        (Absyn.NEWsigexp(_, ref (Absyn.Option.PRESENT str))) = str
    | interface_from_sigexp
        (Absyn.OLDsigexp(_, ref (Absyn.Option.PRESENT str),_)) = str
    | interface_from_sigexp _ =
	Crash.impossible "No interface structure for signature"
d1257 1
a1257 2
  val functor_refs
    : ((LambdaTypes.LVar,int) Option.option ref * LambdaTypes.Structure) list ref = ref []
d1272 1
a1272 1
     initial_debug_info,
d1276 3
a1278 11
      val redundant_exceptions : (int * string) list ref = ref(nil)
      val dynamic_redundancy_report : (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) ref =
        ref(fn exp=>exp)
      fun Dynamic_redundancy_report() =
          let
            val exp = (!dynamic_redundancy_report) unit_exp
          in
            (dynamic_redundancy_report := (fn exp=>exp);
             exp)
          end
           
d1287 6
a1292 2
          then fn _ => LambdaTypes.new_LVar()
        else fn new_lv => new_lv
d1294 1
a1294 2
      fun dummy_instance () = 
        (ref Datatypes.NULLTYPE, ref (RuntimeEnv.RUNTIMEINFO (Option.ABSENT,nil)))
d1296 2
d1302 1
d1305 1
a1305 1
          Option.PRESENT(ref(Datatypes.INSTANCE(instance))) => 
d1307 2
a1308 1
              val (name,location,ty) = 
d1310 2
a1311 2
                  Option.PRESENT(name,(ref ty,_),_) => 
                    ("instance of "^name,"["^location^"]",ty)
d1313 31
a1343 3
              val tyvar = LambdaTypes.new_LVar()
              val tyvar_slot = 
                Option.PRESENT(ref (RuntimeEnv.OFFSET1(0)))
d1347 9
a1355 38
               let
                 fun debugger_application (Datatypes.FUNTYPE(_,ty)) app ct = 
                   let
                     val tyvar_slot = 
                       Option.PRESENT(ref (RuntimeEnv.OFFSET1(0)))
                     val arg = LambdaTypes.new_LVar()
                     val result = LambdaTypes.new_LVar()
                   in
                     LambdaTypes.FN([arg],
                                    LambdaTypes.LET
                                    ((0,
                                      Option.PRESENT
                                      (ref (RuntimeEnv.VARINFO
                                            (Option.PRESENT("tyvar for "^name,
                                                            dummy_instance(),
                                                            tyvar_slot)))),
                                      LambdaTypes.VAR(tyvar)),
                                    LambdaTypes.LET((result,Option.ABSENT,
                                                     LambdaTypes.APP(app,[LambdaTypes.VAR(arg)],
                                                                     Option.ABSENT)),
                                                     debugger_application (Types.the_type(ty))
                                                     (LambdaTypes.VAR(result)) (ct+1))), 
                                    name^" argument " ^ makestring(ct)^location,
                                    Datatypes.NULLTYPE,
                                    Option.PRESENT(RuntimeEnv.FUNINFO (instance,tyvar_slot)))
                   end
                   | debugger_application _ app _ = app
               in
                 LambdaTypes.LET((0,
                                  Option.PRESENT(ref (RuntimeEnv.VARINFO
                                                      (Option.PRESENT("tyvar for "^name,
                                                                      dummy_instance(),
                                                                      tyvar_slot)))),
                                  LambdaTypes.VAR(tyvar)),
                                 debugger_application (Types.the_type(ty)) lexp 1)
               end,
             name^location,Datatypes.NULLTYPE,
             Option.PRESENT(RuntimeEnv.FUNINFO(instance,tyvar_slot)))
d1357 1
d1364 1
d1372 1
d1380 2
a1381 1
                (LambdaTypes.new_LVar(),
d1383 1
a1383 1
                   val fnname = LambdaTypes.new_LVar()
d1385 1
a1385 1
                   LambdaTypes.FN([fnname],
d1387 1
a1387 1
                                                  [LambdaTypes.VAR fnname],
d1396 1
a1396 1
                (LambdaTypes.new_LVar(),
d1398 2
a1399 2
                   val fnname = LambdaTypes.new_LVar()
                   val exn = LambdaTypes.new_LVar()
d1401 2
d1408 1
a1408 1
                     ((LambdaTypes.new_LVar(),Option.ABSENT,
d1411 1
a1411 1
                                                            LambdaTypes.STRUCT([LambdaTypes.INT(1),
d1416 1
a1416 1
                     LambdaTypes.RAISE(LambdaTypes.VAR(exn))),
d1432 1
a1432 1
                (LambdaTypes.new_LVar(),
d1434 1
a1434 1
                   val fnname = LambdaTypes.new_LVar()
d1444 1
a1444 1
                (LambdaTypes.new_LVar(),
d1446 1
a1446 1
                   val fnname = LambdaTypes.new_LVar()
d1473 1
a1473 1
                      EnvironTypes.LAMB(step_lvar,Option.ABSENT))),
d1475 1
a1475 1
                     EnvironTypes.LAMB(breakpoint_lvar,Option.ABSENT))),
d1477 1
a1477 1
                    EnvironTypes.LAMB(breakpoint_on_exit_lvar,Option.ABSENT))),
d1479 1
a1479 1
                   EnvironTypes.LAMB(step_handler_lvar,Option.ABSENT))))
d1482 1
a1482 1
         (LambdaTypes.VAR 0,LambdaTypes.VAR 0,LambdaTypes.VAR 0,LambdaTypes.VAR 0,[],fn env => env)
d1484 12
a1495 15
      val make_step =
        if do_stepper then
          (* This pattern match means we can't remove lvar = int sharing constraint *)
          fn (_,~1) => []
           | (fnname,fnname_lvar) => 
               if substring(generate_stepper_specific,fnname) then
                 [LambdaTypes.LETB(LambdaTypes.new_LVar(),Option.ABSENT,
                                   LambdaTypes.APP(step_exp,
                                                   [LambdaTypes.STRUCT([LambdaTypes.VAR fnname_lvar,
                                                                        LambdaTypes.INT(0)],
                                                                       LambdaTypes.TUPLE)],
                                                   Option.ABSENT))]
               else []
        else
          fn _ => nil
d1497 6
a1502 33
      fun funny_name_p name  =
        ((String.substring(name,0,4) = "<if>" orelse
          String.substring(name,0,5) = "<seq>" orelse
          String.substring(name,0,6) = "<case>" orelse
          String.substring(name,0,8) = "<handle>")
         handle String.Substring => false)
                   
      val make_handle_for_stepper =
        if do_stepper then
          fn (lexp,(name,fnname,fnname_lv)) => 
            if substring(generate_stepper_specific, fnname) andalso not (funny_name_p name)
              then
                LambdaTypes.HANDLE(lexp,
                                   LambdaTypes.APP(step_handler_exp,[LambdaTypes.VAR fnname_lv],
                                                   Option.ABSENT),"step handler")
              else
                lexp
        else
            fn (lexp,_) => lexp

      val make_breakpoint = 
        if do_stepper then
          fn (name,fnname,fnname_lvar) =>
            if substring(generate_stepper_specific,fnname) andalso not (funny_name_p name)
              then
                fn lexp =>
                LambdaTypes.LET((LambdaTypes.new_LVar(),Option.ABSENT,
                                 LambdaTypes.APP(breakpoint_exp,
                                                 [LambdaTypes.VAR fnname_lvar],
                                                 Option.ABSENT)),
                                 lexp)
            else
              fn lexp => lexp
d1504 1
a1504 1
            fn _ => fn lexp => lexp
d1506 8
a1513 12
      val make_breakpoint_on_exit = 
        if do_stepper then
          fn (fnname,fnname_lvar) =>
            if substring(generate_stepper_specific,fnname) then
              fn lexp =>
              LambdaTypes.LET((LambdaTypes.new_LVar(),Option.ABSENT,
                               LambdaTypes.APP(breakpoint_on_exit_exp,
                                               [LambdaTypes.VAR fnname_lvar],
                                               Option.ABSENT)),
                              lexp)
            else
              fn lexp => lexp
d1515 1
a1515 1
            fn _ => fn lexp => lexp
d1517 8
a1524 9
      val make_binding_for_stepper =
        if do_stepper then
          fn (lexp,(fnname,fnname_lv)) => 
            if substring(generate_stepper_specific,fnname) then
              LambdaTypes.LET((fnname_lv,Option.ABSENT,
                               LambdaTypes.SCON(LambdaTypes.Ident.STRING(fnname))),
                              lexp)
            else
              lexp
d1526 1
a1526 1
          fn (lexp,_) => lexp
d1528 7
a1534 5
      val function_return_debug_info =
        if do_stepper then
          fn Datatypes.NULLTYPE => Option.ABSENT
           | ty => Option.PRESENT("FUNCTION RETURN",
                                   (ref ty,ref (RuntimeEnv.RUNTIMEINFO (Option.ABSENT,[]))),Option.ABSENT)
d1536 1
a1536 1
          fn _ => Option.ABSENT
d1551 3
a1553 2
      val generate_moduler_debug = false
      fun do_moduler_debug(message) =
d1555 1
a1555 1
          output(std_out,"\n"^message()^"\n")
d1562 2
a1563 1
      fun lookup lookup' =
d1565 12
a1576 12
          fun lookup(Ident.NOPATH,result) = lookup' result
            | lookup(Ident.PATH(sym,path),
                     EnvironTypes.DENV'(EnvironTypes.DENV(_,strmap))) =
              lookup(path, NewMap.apply strmap (Ident.STRID(sym))
                     handle NewMap.Undefined =>
                       (do_moduler_debug(fn ()=>"UNDEFINED 14:"^Ident.Symbol.symbol_name sym);
                        raise NewMap.Undefined))
            | lookup(Ident.PATH(sym,path),
                     EnvironTypes.LAMBDASTREXP(selects,lv,
                                               Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                                        Datatypes.TE(tyconmap),
                                                                        Datatypes.VE(_,validmap))))) =
d1580 8
a1587 8
                lookup(path,
                       EnvironTypes.LAMBDASTREXP({index= NewMap.rank' (stridmap,Ident.STRID(sym)) + offset,
                       size= NewMap.size stridmap + offset}
                       ::selects,lv,
                       NewMap.apply stridmap (Ident.STRID(sym))))
                       handle NewMap.Undefined =>
                         (do_moduler_debug(fn ()=>"UNDEFINED 3:"^Ident.Symbol.symbol_name sym);
                          raise NewMap.Undefined)
d1589 8
a1596 8
            | lookup(path,
                     EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) = 
              lookup(path, EnvironTypes.LAMBDASTREXP(selects,lv,str))
            | lookup(Ident.PATH(sym,path),
                     EnvironTypes.LAMBDASTREXP'(selects,lv,
                                                Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(stridmap),
                                                                        Datatypes.TE(tyconmap),
                                                                        Datatypes.VE(_,validmap))))) =
d1600 9
a1608 9
                lookup(path,
                       EnvironTypes.LAMBDASTREXP'({index=
                                                   NewMap.rank' (stridmap,Ident.STRID(sym)) + offset,
                       size= NewMap.size stridmap + offset}
                       ::selects,lv,
                       NewMap.apply stridmap (Ident.STRID(sym))))
                       handle NewMap.Undefined =>
                         (do_moduler_debug(fn ()=>"UNDEFINED 3:"^Ident.Symbol.symbol_name sym);
                          raise NewMap.Undefined)
d1610 2
a1611 3
            | lookup(path,
                     EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) = 
              lookup(path, EnvironTypes.LAMBDASTREXP'(selects,lv,str))
d1613 1
a1613 1
          lookup
d1616 39
a1654 60
      local
        fun cg_longvalid'' lookup' (longvalid, denv) = 
          case longvalid of
            Ident.LONGVALID(Ident.NOPATH, valid as Ident.VAR sym) =>
              (Environ.lookup_valid'(valid, denv)
               handle NewMap.Undefined =>
                 (do_moduler_debug(fn ()=>"UNDEFINED 13:"^Ident.Symbol.symbol_name sym);
                  raise NewMap.Undefined))
          | Ident.LONGVALID(Ident.PATH(sym,path), valid as Ident.VAR sym') =>
              (case denv of
                 EnvironTypes.DENV(_,strmap) => 
                   lookup (lookup' sym')
                   (path, NewMap.apply strmap (Ident.STRID(sym))
                    handle NewMap.Undefined =>
                      (do_moduler_debug(fn ()=>"UNDEFINED 4:"^Ident.Symbol.symbol_name sym^".."
                                        ^Ident.Symbol.symbol_name sym'^"..."
                                        ^NewMap.fold (fn (str,Ident.STRID(sym),_)=>str^","
                                                      ^Ident.Symbol.symbol_name sym) ("",strmap));
                      raise NewMap.Undefined)))
          | _ => Crash.impossible "cg_longvalid'':lambda"
      in
        local
          fun lookup sym =
            let
              fun lookup(EnvironTypes.DENV'(EnvironTypes.DENV(validmap,_))) =
                (NewMap.apply validmap (Ident.VAR(sym))
                 handle NewMap.Undefined =>
                   (do_moduler_debug(fn ()=>"UNDEFINED 5:"^Ident.Symbol.symbol_name sym);
                    raise NewMap.Undefined))
                | lookup(EnvironTypes.LAMBDASTREXP(selects,lv,
                                                   Datatypes.STR(_,_,
                                                      Datatypes.ENV(Datatypes.SE(stridmap),
                                                                    Datatypes.TE(tyconmap),
                                                                    Datatypes.VE(_,validmap))))) =
                  let
                    val offset = NewMap.size tyconmap
                  in
                    EnvironTypes.LAMBDAEXP({index= NewMap.rank' (validmap,Ident.VAR(sym)) + offset,
                                            size=NewMap.size validmap + NewMap.size stridmap + offset}
                    ::selects,lv,Option.ABSENT)
                  end
                | lookup(EnvironTypes.LAMBDASTREXP(selects,lv,Datatypes.COPYSTR(_,str))) = 
                  lookup(EnvironTypes.LAMBDASTREXP(selects,lv,str))
                | lookup(EnvironTypes.LAMBDASTREXP'(selects,lv,
                                                    Datatypes.STR(_,_,
                                                         Datatypes.ENV(Datatypes.SE(stridmap),
                                                                       Datatypes.TE(tyconmap),
                                                                       Datatypes.VE(_,validmap))))) =
                  let
                    val offset = NewMap.size tyconmap
                  in
                    EnvironTypes.LAMBDAEXP'({index= NewMap.rank' (validmap,Ident.VAR(sym)) + offset,
                                             size=NewMap.size validmap + NewMap.size stridmap + offset}
                    ::selects,lv,Option.ABSENT)
                  end
                | lookup(EnvironTypes.LAMBDASTREXP'(selects,lv,Datatypes.COPYSTR(_,str))) = 
                  lookup(EnvironTypes.LAMBDASTREXP'(selects,lv,str))
            in
              lookup
            end
d1656 1
a1656 1
          val cg_longvalid' = cg_longvalid'' lookup
a1657 1
      end
d1659 27
d1688 2
a1689 3
      in
        fun fetch_nulltyfun(Datatypes.METATYNAME{1=tf as ref(Datatypes.NULL_TYFUN(_)), ...}) = tf
          | fetch_nulltyfun(Datatypes.METATYNAME{1=ref(Datatypes.ETA_TYFUN(m)), ...}) =
d1692 1
d1703 5
a1707 1
      fun cg_longtycon' (tf,denv) =
a1708 1
          fun ntf_eq(tf,tf'') = tf = tf''
d1710 2
a1711 4
          fun lookup0(EnvironTypes.DENV(map1,map2)) =
            (lookup1 map1
             handle Lookup => lookup2 map2)
          and lookup1 map =
d1713 11
a1723 5
              fun lookup nil = raise Lookup
                | lookup((_,lexp as EnvironTypes.LAMBDAEXP(_,_,Option.PRESENT(tf')))::rest) =
                  if ntf_eq(tf,tf') then lexp
                  else lookup rest
                | lookup (_::rest) = lookup rest
d1725 16
a1740 1
              lookup (NewMap.to_list map)
d1742 6
a1747 12
          and lookup2 map =
            let 
              fun lookup' nil = raise Lookup
                | lookup'((_,str)::rest) =
                  (lookup str
                   handle Lookup => lookup' rest)
            in
              lookup' (NewMap.to_list map)
            end
          and lookup3(Datatypes.COPYSTR(_,str)) = lookup3 str
            | lookup3(Datatypes.STR(_,_,Datatypes.ENV(Datatypes.SE(map1),Datatypes.TE(map2),
                                                      Datatypes.VE(_,map3)))) =
d1749 8
a1756 16
                val size' = NewMap.size map2 + NewMap.size map3
                val size = NewMap.size map1 + size'
                fun lookup nil _ = raise Lookup
                  | lookup ((_,tystr)::rest) n =
                    if ntf_eq(tf,fetch_ntf tystr) then n
                    else lookup rest (n+1)
                fun lookup' () =
                  let
                    val map = NewMap.to_list_ordered map1
                    fun lookup nil _ = raise Lookup
                      | lookup ((_,str)::rest) n =
                        {index = n + size', size = size}::lookup3(str)
                        handle Lookup => lookup rest (n+1)
                  in
                    lookup map 0
                  end
d1758 15
a1772 2
                [{index = lookup (NewMap.to_list_ordered map2) 0, size = size}]
                handle Lookup => lookup' ()
a1773 5
          and lookup(EnvironTypes.DENV'(denv)) = lookup0 denv
            | lookup(EnvironTypes.LAMBDASTREXP(selects,lv,str)) =
              EnvironTypes.LAMBDAEXP(rev(lookup3(str))@@selects,lv,Option.ABSENT)
            | lookup(EnvironTypes.LAMBDASTREXP'(selects,lv,str)) =
              EnvironTypes.LAMBDAEXP'(rev(lookup3(str))@@selects,lv,Option.ABSENT)
d1775 1
a1775 1
          lookup0 denv
d1784 1
a1784 1
               (do_moduler_debug(fn ()=>"UNDEFINED 12:"^Ident.Symbol.symbol_name sym);
d1795 1
a1795 1
                    (do_moduler_debug(fn ()=>"UNDEFINED 11:"^Ident.Symbol.symbol_name sym);
d1799 2
d1841 1
a1841 1
            EnvironTypes.DENV'(denv') => Environ.augment_denv(denv, denv')
d1848 1
a1848 1
      val cg_longvalid' =
d1850 1
a1850 2
          fn denv =>
          cg_longvalid' denv
d1854 1
d1856 2
a1857 1
      val empty_dstrexp = EnvironTypes.DENV'(empty_denv)
d1865 1
d1871 1
d1877 1
d1883 1
d1885 1
a1885 1
        if generate_moduler then fn _ => LambdaTypes.new_LVar()
d1890 26
a1915 28
      val sub_functor_refs =
        if generate_moduler then
          fn EnvironTypes.TOP_ENV(env',fun_env) =>
          let
            val env =
              case env of
                EnvironTypes.ENV(env,_) => NewMap.to_list env
            fun sub_functor_refs [] env = EnvironTypes.TOP_ENV(env,fun_env)
              | sub_functor_refs((entry as (v as Ident.VAR(sym),comp))::rest) env =
                let
                  val v_string = Symbol.symbol_name sym
                in
                  sub_functor_refs rest 
                  ((if String.substring(v_string,0,15) = "functor app ref" then
                        case comp of
                          EnvironTypes.LAMB(lvar,_) => 
                            Environ.add_valid_env(env,entry)
                        | _ => env
                    else
                      env)
                      handle String.Substring => env)
                end
              | sub_functor_refs (_::rest) env = sub_functor_refs rest env
          in
            sub_functor_refs env env'
          end
        else
          fn arg => arg
d1920 1
a1920 2
          (cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                       Ident.VAR(Symbol.find_symbol("overload function"))),env),[],
d1925 6
a1930 6
               val lvar = LambdaTypes.new_LVar()
               val lv = LambdaTypes.new_LVar()
               val args = LambdaTypes.new_LVar()
               val new_cg = LambdaTypes.new_LVar()
               val dexp' = LambdaTypes.new_LVar()
               val instance' = LambdaTypes.new_LVar()
d1935 8
a1942 3
                                   LambdaTypes.SELECT({index=0,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(args))),
                   LambdaTypes.LET((dexp',Option.ABSENT,LambdaTypes.SELECT({index=1,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(args))),
                     LambdaTypes.LET((instance',Option.ABSENT,LambdaTypes.SELECT({index=2,size=3,selecttype=LambdaTypes.TUPLE},LambdaTypes.VAR(args))),
d1949 22
a1970 18
                                               LambdaTypes.APP(LambdaTypes.VAR(new_cg),
                                                               [let
                                                                 val lexp = LambdaTypes.SELECT({index=1,size=2,selecttype=LambdaTypes.CONSTRUCTOR},
                                                                                               LambdaTypes.VAR(lvar))
                                                               in
                                                                 LambdaTypes.SWITCH(LambdaTypes.VAR(instance'),
                                                                                    Option.ABSENT,
                                                                                    [(LambdaTypes.SCON_TAG(Ident.INT("~1",Location.UNKNOWN)),
                                                                                      LambdaTypes.STRUCT([LambdaTypes.INT 0, lexp],
                                                                                                         LambdaTypes.CONSTRUCTOR))],
                                                                                    Option.PRESENT(LambdaTypes.STRUCT([LambdaTypes.INT 1,
                                                                                                                      LambdaTypes.STRUCT([lexp,
                                                                                                                                          LambdaTypes.VAR(instance')],
                                                                                                                                         LambdaTypes.TUPLE)],
                                                                                                                      LambdaTypes.CONSTRUCTOR)))
                                                               end],
                                                               Option.ABSENT))],Option.ABSENT))))),
                 "overload function",Datatypes.NULLTYPE,Option.ABSENT)
d1976 2
a1977 2
                                      (Ident.VAR(Ident.Symbol.find_symbol("overload function")),
                                       EnvironTypes.LAMB(lv,Option.ABSENT))))
d1979 1
a1979 1
        else (LambdaTypes.VAR 0,[],fn env => env)
d1982 1
a1982 1
      fun select(selects,lexp) =
d1984 4
a1987 2
          fun select nil = lexp
            | select (s::ss) = LambdaTypes.SELECT(make_tuple_select s,select ss)
d1989 1
a1989 1
          select selects
d1998 2
a1999 1
          select (selects,LambdaTypes.VAR lv)
d2001 7
a2007 9
          select (selects,
                  LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                  [case !functorlv of
                                     Option.SOME1 functorlv => LambdaTypes.VAR functorlv
                                   | Option.SOME2 ct =>
                                       cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                                                    Ident.VAR(Symbol.find_symbol("functor app ref "^
                                                                                                 makestring ct))),env)],
                                       Option.ABSENT))
d2013 2
a2014 1
          select (selects,LambdaTypes.VAR lv)
d2016 1
a2016 1
          select (selects,
d2019 3
a2021 5
                    Option.SOME1(functorlv) => LambdaTypes.VAR functorlv
                  | Option.SOME2(ct) =>
                    cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                   Ident.VAR(Symbol.find_symbol("functor app ref "
                                                                ^ makestring ct))),env)],
d2024 4
a2027 3
      (** global overloading-expressions for economy of lambda code **)
      val dexps :
        ({index : int, size : int} list * (LambdaTypes.LVar * LambdaTypes.LambdaExp)) list ref = ref []
d2031 1
a2031 1
                                   denv,new_cg,instance,instance') =
d2034 3
a2036 2
          fun instance_to_lambda(nil) = LambdaTypes.INT 2
            | instance_to_lambda([i]) = 
d2038 1
a2038 1
            | instance_to_lambda([i,i']) = 
a2043 1
            | instance_to_lambda _ = Crash.impossible "instance_to_lambda:lambda"
d2050 1
a2050 1
                                  [instance_to_lambda instance'],
d2053 3
a2055 3
            case instance' of
              nil => Option.ABSENT
            | [i] => Option.PRESENT(i)
d2057 2
a2058 1
          val dexp = cg_longvalid'(longValId,denv)
d2064 24
a2087 26
              LambdaTypes.APP(new_cg,
                             [let
                                val lexp = LambdaTypes.INT i
                              in
                                case fetch_instance'() of
                                  Option.ABSENT => LambdaTypes.STRUCT([LambdaTypes.INT 0, lexp],LambdaTypes.CONSTRUCTOR)
                                | Option.PRESENT(i) => LambdaTypes.STRUCT([LambdaTypes.INT 1,
                                                                          LambdaTypes.STRUCT([lexp,
                                                                                              LambdaTypes.INT i],
                                                                                             LambdaTypes.TUPLE)],
                                                                          LambdaTypes.CONSTRUCTOR)
                              end],
                            Option.ABSENT)
          | EnvironTypes.LAMBDAEXP'(_) => 
              let
                fun make_app lexp =
                  LambdaTypes.APP(lexp,
                  [LambdaTypes.STRUCT([new_cg,dexp',
                                       case fetch_instance'() of
                                         Option.ABSENT => LambdaTypes.INT ~1
                                       | Option.PRESENT(i) => LambdaTypes.INT i],
                                      LambdaTypes.TUPLE)],
                  Option.ABSENT)
              in
                make_app overload_exp
              end
a2092 24
                fun make_app lexp =
                  case fetch_instance'() of
                    instance' as Option.ABSENT => 
                     (LambdaTypes.APP(lexp,
                                      [LambdaTypes.STRUCT([select(selects,LambdaTypes.VAR root_lv),
                                                           dexp',LambdaTypes.INT ~1],
                                                          LambdaTypes.TUPLE)],
                                      Option.ABSENT),
                      instance')
                  | instance' as Option.PRESENT(_) =>
                      (let
                        val lv = LambdaTypes.new_LVar()
                       in
                         LambdaTypes.FN([lv],
                           LambdaTypes.APP(lexp,
                                           [LambdaTypes.STRUCT([select(selects,LambdaTypes.VAR root_lv),dexp',
                                                                LambdaTypes.VAR lv],
                                                               LambdaTypes.TUPLE)],
                                           Option.ABSENT),
                                        "overload for "^Symbol.symbol_name sy,
                                        Datatypes.NULLTYPE,
                                        Option.ABSENT)
                       end,
                       instance')
d2094 1
a2094 1
                (case Lists.assoc(selects,!dexps) of
d2104 28
a2131 2
                       val (lexp,instance') = make_app overload_exp
                       val lv = LambdaTypes.new_LVar()
d2133 1
a2133 1
                       (dexps := (selects,(lv,lexp))::(!dexps);
d2151 11
a2161 12
      fun make_type_function(EnvironTypes.NULLEXP) = 
        Crash.impossible "NULLEXP:make_type_function:null_tyfun_spills:lambda"
        | make_type_function(EnvironTypes.INT(i)) =
          Crash.impossible "INT:make_type_function:null_tyfun_spills:lambda"
        | make_type_function(EnvironTypes.LAMBDAEXP(selects,(lv,lv'),_)) =
          LambdaTypes.STRUCT([select (selects,LambdaTypes.VAR lv),
                             LambdaTypes.APP(select (selects,LambdaTypes.VAR lv'),
                                             [unit_exp],
                                             Option.ABSENT)],
                             LambdaTypes.TUPLE)
        | make_type_function(EnvironTypes.LAMBDAEXP'(selects,functorlv,_)) =
          Crash.impossible "LAMBDAEXP':make_type_function:null_tyfun_spills:lambda"
d2163 1
a2163 1
      (** convert a debugger-structure expression to lambda code **)
d2166 2
a2167 2
          EnvironTypes.LAMBDASTREXP(selects, lv, Datatypes.COPYSTR(_,str)) =>
            dstrexp_to_lambda(EnvironTypes.LAMBDASTREXP(selects, lv, str))
d2172 1
a2172 1
          select(selects,LambdaTypes.VAR lv)
d2174 2
a2175 1
            dstrexp_to_lambda(EnvironTypes.LAMBDASTREXP'(selects,lv,str))
d2177 9
a2185 9
            (select(selects,
             LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
              [case !functorlv of
                 Option.SOME1(functorlv) => LambdaTypes.VAR functorlv
               | Option.SOME2(ct) =>
                  cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                    Ident.VAR(Symbol.find_symbol("functor app ref " ^ makestring ct))),env)],
                  Option.ABSENT)))
        | EnvironTypes.DENV'(EnvironTypes.DENV(validmap,stridmap)) =>
d2236 2
a2237 2
      fun merge_dexps(dint,EnvironTypes.NULLEXP,_,location) = dint
        | merge_dexps(_,EnvironTypes.LAMBDAEXP(selects,lv,Option.PRESENT(_)),Option.PRESENT(tystr),_) =
d2260 1
a2260 1
               EnvironTypes.DENV'(
d2298 1
a2298 1
           | EnvironTypes.DENV'(EnvironTypes.DENV(validmap',stridmap')) =>
d2301 1
a2301 1
                  EnvironTypes.DENV'(
d2308 1
a2308 1
                     (NewMap.map (fn (v,Option.ABSENT)=>merge_dexps(EnvironTypes.NULLEXP,
d2320 1
a2320 1
                   EnvironTypes.DENV'(EnvironTypes.DENV(
d2338 1
a2338 1
          val lvar = LambdaTypes.new_LVar()
d2383 1
a2383 1
            val lvar = LambdaTypes.new_LVar()
d2396 1
a2396 1
                LambdaTypes.FN([0],LambdaTypes.INT 1,"dummy tyfun tyfun",LambdaTypes.null_type_annotation,
d2430 1
a2430 1
          EnvironTypes.DENV'(
d2456 1
d2458 5
a2462 5
      val tfs : Datatypes.Tyfun ref list ref = ref []
      val ves : Datatypes.Valenv ref list ref = ref []
      val tyfun_spills
        : (Datatypes.Tyfun ref * RuntimeEnv.Offset ref * LambdaTypes.LambdaExp) list ref = ref []
      val tfs_lvs : (Datatypes.Tyfun ref * (LambdaTypes.LVar * LambdaTypes.LambdaExp)) list ref = ref []
d2491 1
a2491 1
                  if Lists.member(tf,!tfs) then nil
d2493 2
a2494 2
                    (tfs := tf::(!tfs);
                     do_moduler_debug(fn ()=>"spill for "^name); 
d2496 1
a2496 1
                      (case Lists.assoc(tf,!tfs_lvs) of
d2500 2
a2501 2
                             val lv = LambdaTypes.new_LVar()
                             val lexp = make_type_function(cg_longtycon'(tf,denv))
d2503 1
a2503 1
                             (tfs_lvs := (tf,(lv,lexp))::(!tfs_lvs);
d2507 6
a2512 3
                       (fn ()=>do_moduler_debug(fn ()=>"WARNING cg_longtycon':"
                                ^IdentPrint.printLongValId print_options (Ident.LONGVALID(Ident.NOPATH,
                                          Ident.VAR(Ident.Symbol.find_symbol name)))); []))
d2514 1
a2514 1
                  if Lists.member(ve',!ves) then nil
d2516 1
a2516 1
                    (ves := ve'::(!ves);
d2521 1
a2521 1
                  (if Lists.member(ve',!ves) then nil
d2523 1
a2523 1
                     (ves := ve'::(!ves);
d2529 1
a2529 1
                  (if Lists.member(ve',!ves) then nil
d2531 1
a2531 1
                     (ves := ve'::(!ves);
d2541 1
a2541 1
                    if Lists.member(ve',!ves) then nil
d2543 1
a2543 1
                      (ves := ve'::(!ves);
d2552 4
a2555 1
      fun null_tyfun_spills denv (Option.PRESENT(name,(ref ty,inforef as ref (RuntimeEnv.RUNTIMEINFO (i,_))),_)) location = 
d2558 11
a2568 9
        let
          val spills =
            map (fn (tf,dexp)=>(tf,ref(RuntimeEnv.OFFSET1(0)),dexp))
            (type_spills (denv,ty))
        in
          (inforef := (RuntimeEnv.RUNTIMEINFO (i,map (fn (tf,spill,_)=>(tf,spill)) spills));
           tyfun_spills := spills@@(!tyfun_spills))
        end
        | null_tyfun_spills _ Option.ABSENT _ = ()
d2572 1
a2572 1
          fn _ => fn _ => fn _ => ()
d2579 1
a2579 1
               LambdaTypes.LETB(0,
d2581 3
a2583 3
                                                    (Option.PRESENT("null_tyfun_spill",
                                                                    dummy_instance (),
                                                                    Option.PRESENT(spill))))),
d2585 1
a2585 1
           (!tyfun_spills),
d2593 1
a2593 1
          fn () => (!tfs, !ves, !tyfun_spills)
d2597 2
a2598 5
      val init_null_tyfun_spills =
        if generate_moduler then
          fn () => (tfs := []; ves := []; tyfun_spills := [])
        else
          fn () => ()
d2602 4
a2605 4
          fn (old_tfs,old_ves,old_tyfun_spills) =>
          (tfs := old_tfs;
           ves := old_ves;
           tyfun_spills := old_tyfun_spills)
d2628 1
a2628 1
                  val tyfun_lvar = LambdaTypes.new_LVar()
d2631 1
a2631 1
                                               EnvironTypes.LAMB(tyfun_lvar,Option.ABSENT))),
d2634 1
a2634 1
                                    LambdaTypes.FN([LambdaTypes.new_LVar()],
a2656 1
          fn denvir => 
d2658 2
a2659 3
            fun DATATYPEdec_spills nil bindings = bindings
              | DATATYPEdec_spills ((_,tycon as Ident.TYCON(sym),_,tyf,_)::rest) (env,denv,bindings) =
                DATATYPEdec_spills rest
d2661 18
a2678 1
                  val tyfun_lvar = LambdaTypes.new_LVar()
d2680 1
a2680 14
                  (Environ.add_valid_env(env, (Ident.TYCON'(sym),
                                               EnvironTypes.LAMB(tyfun_lvar,Option.ABSENT))),
                   add_valid_denv(denv, (Ident.TYCON'(sym),EnvironTypes.NULLEXP)),
                   LambdaTypes.LETB(tyfun_lvar,Option.ABSENT,
                                    LambdaTypes.FN([LambdaTypes.new_LVar()],
                                                   make_lambdalist
                                                   (map (fn (_,spill)=>spill)
                                                    (tyname_spills (denvir,
                                                       Datatypes.METATYNAME(fetch_tyfun tyf,"",0,
                                                                dummy_false,dummy_ve,dummy_false)))),
                                                   (init_null_tyfun_spills(); "spills for tycon "
                                                    ^IdentPrint.printTyCon tycon),
                                                   Datatypes.NULLTYPE,
                                                   Option.ABSENT))::bindings)
d2686 1
a2686 1
          fn _ => fn _ => fn bindings => bindings
d2690 1
a2690 1
      val make_binding' = 
d2693 4
a2696 3
            fn ((lv,lv'),debug_info,instance,lexp,comment,location) =>
            [LambdaTypes.LETB(lv,Option.PRESENT(ref (RuntimeEnv.VARINFO debug_info)),
                              lexp),
d2698 1
a2698 2
                              make_binding(debug_info,instance,
                                           LambdaTypes.VAR(lv),location))]
d2700 1
a2700 3
            fn ((lv,_),debug_info,_,lexp,comment,location) =>
            [LambdaTypes.LETB(lv,Option.PRESENT(ref (RuntimeEnv.VARINFO debug_info)),
                              lexp)]
d2702 1
a2702 3
          fn ((lv,_),_,_,lexp,comment,_) =>
          [LambdaTypes.LETB(lv,Option.ABSENT,
                            lexp)]
d2704 15
a2718 19
      val make_return_binding_for_stepper =
        if do_stepper then
          fn (lexp,debug_info as Option.PRESENT(_,(ref ty,_),_),(name,fnname,fnname_lv)) =>
            if Types.isFunType(ty) then
              lexp
            else
              if substring(generate_stepper_specific,fnname) andalso not (funny_name_p name)
                then
                  let
                    val lvar = LambdaTypes.new_LVar()
                  in
                    let_lambdas_in_exp(make_binding'((lvar,lvar), debug_info,
                                                     Option.ABSENT,lexp,"FUNCTION RETURN","") @@
                                       make_step(fnname,fnname_lv),
                                       make_breakpoint_on_exit (fnname,fnname_lv) (LambdaTypes.VAR lvar))
                  end
              else
                lexp
            | (lexp,_,_) => lexp
d2720 2
a2721 1
          fn (lexp,_,_) => lexp
d2723 1
a2723 1
      val debug_info_ref = ref initial_debug_info
d2738 1
d2748 1
a2748 1
          | Absyn.VALexp(longValId, ref ty,location,ref(instance',instance)) =>
d2786 2
a2787 4
			     (Ident.LONGVALID
			        (Ident.NOPATH, 
                                 Ident.VAR (Symbol.find_symbol sy_name')),
                              Primitives.env_for_lookup_in_lambda)
d2806 1
a2806 3
                                 Ident.LONGVALID
                                 (Ident.NOPATH, Ident.VAR(Symbol.find_symbol("_" ^ name ^
                                                                             sy_name)))
d2823 1
a2823 3
                                   Ident.LONGVALID
                                   (Ident.NOPATH, Ident.VAR(Symbol.find_symbol("_int" ^
                                                                               sy_name)))
d2843 1
a2843 1
                       (longvalid_dexp_to_lambda(longValId,denv,new_cg,instance,instance'))
d2855 1
a2855 1
                           val new_lv = LambdaTypes.new_LVar()
d2891 1
a2891 1
                         val lv = LambdaTypes.new_LVar()
d2918 1
a2918 1
                       (lab, LambdaTypes.new_LVar(),
d3001 1
a3001 6
           (case fcn of
              LambdaTypes.FN([var],body,_,_,_) =>
                LambdaTypes.LET((var,Option.ABSENT,arg),body)
            | LambdaTypes.FN(varlist,body,_,_,_) => Crash.impossible "varlist in APPexp"
            | _ => LambdaTypes.APP(fcn, [arg], 
                                   Option.PRESENT(annotation)))  (***)
d3003 1
d3084 1
a3084 1
               Match.Option.PRESENT missing_constructors =>
d3090 1
a3090 1
		 (fn (Ident.CON con) => Ident.Symbol.symbol_name con
d3102 1
a3102 1
             | Match.Option.ABSENT => ());
d3164 3
a3166 1
        (* The match translator.
d3192 1
a3192 1
        and trans_match((root, tree), env, denv, is_exn, name_string, ty, (fnname,_),
d3195 8
a3202 5
            val match_trans_ct : int ref = ref(~1)
            fun new_match_trans() = 
              (match_trans_ct := (!match_trans_ct)+1;
               !match_trans_ct)
            val root_lambda = LambdaTypes.new_LVar()
d3211 11
a3221 3
            val fnname = filter_name (name_string,fnname)
            val fnname_lv = 
              if do_stepper then LambdaTypes.new_LVar() else 0
d3231 1
a3231 1
                val redundant_clauses_lambda = LambdaTypes.new_LVar()
d3239 1
a3239 1
                      val lvar = LambdaTypes.new_LVar()
d3250 1
a3250 1
                fun Dynamic_redundancy_report () =
d3286 1
a3286 1
                fun redundancy_code nil = Dynamic_redundancy_report()
d3289 2
a3290 3
                      (* code for an exception constructor must be free of all lambda variables
                         bound in this strdec dec
                       *)
d3293 13
a3305 14
                          infix ^^
                          local
                            infix ^^^
                            fun Ident.NOPATH ^^^ p = p
                              | (Ident.PATH(s,p)) ^^^ p' = Ident.PATH(s,p^^^p')
                          in
                            fun (Option.PRESENT(Option.SOME1(Ident.LONGSTRID(p,Ident.STRID s))))^^
                                (Ident.LONGVALID(p',s')) =
                                Option.PRESENT(Option.SOME1(Ident.LONGVALID(p^^^Ident.PATH(s,
                                                                              Ident.NOPATH)^^^p',s')))
                              | (Option.PRESENT(Option.SOME2(lvar))) ^^ _ =
                                Option.PRESENT(Option.SOME2(LambdaTypes.VAR lvar))
                              | Option.ABSENT ^^ _ = Option.ABSENT
                          end
d3308 1
a3308 7
                                             case cg_longexid(exn,env) of
                                               (exp,longstrid) =>
                                                 case longstrid^^exn of
                                                   Option.PRESENT(Option.SOME2(lvar)) => lvar
                                                 | Option.PRESENT(Option.SOME1(longstrid)) => 
                                                     #1(cg_longexid(longstrid,env))
                                                 | Option.ABSENT => exp)
d3329 1
a3329 1
                      LambdaTypes.LET((LambdaTypes.new_LVar(),Option.ABSENT,
d3359 1
a3359 1
                (dynamic_redundancy_report :=
d3361 1
a3361 1
                   val dynamic_report = !dynamic_redundancy_report
d3366 1
a3366 1
                    ((LambdaTypes.new_LVar(),Option.ABSENT,
d3379 1
d3382 1
a3382 1
                fun Let_Lambdas_In_Exp lambda_exp bindings lvar =
d3384 14
a3397 4
                   val (lvar,lexp) =
                     case lvar of
                       Option.PRESENT(lvar) => lvar
                     | Option.ABSENT => (0, LambdaTypes.INT 1)
d3399 1
a3399 1
                     | do_binding (Option.SOME1(ref(Option.ABSENT))::bindings) =
d3401 1
a3401 2
                     | do_binding (Option.SOME1(ref(Option.PRESENT(
                                                    lvar as ref(Option.SOME1(_,tree)))))::bindings) =
d3403 1
a3403 1
                         val lv =  LambdaTypes.new_LVar()
d3406 1
a3406 1
                               name_string ^ "<Match" ^ makestring(new_match_trans()) ^ ">"
d3408 2
a3409 3
                               append_name(name_string,fnname) ^ 
                               "<Match" ^
                               makestring(new_match_trans()) ^ ">"
d3411 1
a3411 1
                         (lvar := Match.Option.SOME2(lv);
d3414 1
a3414 1
                            LambdaTypes.FN([LambdaTypes.new_LVar()], 
d3419 3
a3421 3
                                    make_handle_for_stepper(
                                     make_null_tyfun_spills(tr_match(tree,match_env,val_env)),
                                                            (name_string,fnname,fnname_lv)))
d3431 1
a3431 1
                       Crash.impossible "1:do_binding:Let_Lambdas_In_Exp:Match_translator:_lambda.sml"
d3434 1
a3434 1
                         val lv =  LambdaTypes.new_LVar()
d3437 1
a3437 1
                               name_string ^ "<Match"^ makestring(new_match_trans()) ^ ">"
d3439 2
a3440 1
                               append_name(name_string,fnname) ^ "<Match"^ makestring(new_match_trans()) ^ ">"
d3442 1
a3442 1
                         (lvar' := Match.Option.SOME2(lv);
d3445 1
a3445 1
                            LambdaTypes.FN([LambdaTypes.new_LVar()], 
d3450 12
a3461 12
                                    make_handle_for_stepper(
                                    make_null_tyfun_spills(
                                       case matchvar of
                                         ~1 => tr_match(tree, match_env, val_env)
                                       | _ =>
                                        LambdaTypes.LET((lvar,Option.ABSENT,lexp),
                                        tr_match(tree,
                                                 LambdaUtils.add_match_env
                                                 ((matchvar,(lvar,Option.ABSENT)),
                                                  match_env),
                                         val_env))),
                                                            (name_string,fnname,fnname_lv)))
d3470 1
a3470 1
                       Crash.impossible "2:do_binding:Let_Lambdas_In_Exp:Match_translator:_lambda.sml"
d3475 1
a3475 1
                 let fun Tr_Default (ref(Match.BUILT(ref(Match.Option.SOME2(lvar))))) = 
d3480 1
a3480 1
                     |   Tr_Default (ref(Match.BUILT(ref(Match.Option.SOME1(0,tree))))) =
d3502 2
a3503 2
                        make_breakpoint (name_string,fnname,fnname_lv)
                        (trans_exp(" match_leaf", exp, env, denv, (fnname,fnname_lv)))
d3512 2
a3513 4
                                     val dummylv = LambdaTypes.new_LVar()
                                     val debug_info = 
                                       Option.PRESENT
                                       (Symbol.symbol_name symbol,ty,Option.ABSENT)
d3515 9
a3523 7
                                     (null_tyfun_spills denv debug_info "";
                                      LambdaTypes.LET((dummylv,Option.PRESENT (ref (RuntimeEnv.VARINFO debug_info)),
                                      LambdaTypes.VAR(lv)),
                                      do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))),
                                              add_valid_denv(denv, (valid,
                                                                EnvironTypes.NULLEXP)))))
d3525 4
a3528 4
                               | _ => do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))),
                                             add_valid_denv(denv, (valid,
                                                                EnvironTypes.NULLEXP))))
d3531 3
a3533 4
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))),
                                             add_valid_denv(denv, (valid,
                                                                EnvironTypes.NULLEXP)))
                          | (lv,Option.PRESENT inforef) => 
d3537 2
a3538 1
                                   (inforef := RuntimeEnv.VARINFO (Option.PRESENT (Symbol.symbol_name symbol,ty,Option.ABSENT));
d3540 1
a3540 1
                                                                            EnvironTypes.LAMB(lv,Option.ABSENT))),
d3542 1
a3542 1
                               | _ => do_leaf(tl, Environ.add_valid_env(env, (valid,EnvironTypes.LAMB(lv,Option.ABSENT))),
d3548 1
a3548 1
      | Match.SCON(mv, scon_tree_list, default, binding) =>
d3570 5
a3574 4
                    Let_Lambdas_In_Exp lambda_exp
                    (case binding of
                       Option.ABSENT => []
                     | Option.PRESENT(bd) =>[Option.SOME1(bd)]) Option.ABSENT
d3576 55
a3630 45
      | Match.CONSTRUCTOR(ty, mv, longvalid_mv_tree_list, default, binding, exception_tree) =>
	let
	  val ORIG_LV = LambdaUtils.lookup_match(mv, match_env)
	  val orig_lv = #1 ORIG_LV
	  val lv_e = LambdaTypes.VAR orig_lv

	  val (_,type_val_env) =
	    Type_Utils.get_valenv(Type_Utils.get_cons_type ty)

	  val is_exn =
	    case longvalid_mv_tree_list of
	      {1=Ident.LONGVALID(_, Ident.EXCON _), ...} :: _ => true
	    | {1=Ident.LONGVALID(_, Ident.CON _), ...} :: _ => false
	    | _ => Crash.impossible "Match.CONS bad arg"

	  fun has_value(Ident.LONGVALID(_, valid as Ident.CON _)) =
	    (case Type_Utils.type_from_scheme(
		    NewMap.apply'(type_val_env, valid)) of
	       Datatypes.FUNTYPE _ => true
	     | _ => false
	    )
	  |   has_value(Ident.LONGVALID(_, Ident.VAR _)) =
	    Crash.impossible"VAR in match CONS"
	  |   has_value(Ident.LONGVALID(_, Ident.TYCON' _)) =
	    Crash.impossible"TYCON' in match CONS"
	  |   has_value(Ident.LONGVALID(_, Ident.EXCON excon)) = true
	      (* Pretend all exceptions carry values, even if only unit *)

	  val new_lv = LambdaTypes.new_LVar()
	  val new_le = GetConVal lv_e
	  val con_field = GetConTag lv_e
	  val vcc_lv_list =
	    Lists.filterp (has_value o #1) longvalid_mv_tree_list
	      (* Note we're using the same lambda variable for all the
	         vcc matchvars, since they're all going to be the same
	         expression, viz SELECT(1, original matchvar) (aka new_le) *)

          fun tr_match'(Option.SOME1(tree),match_env, val_env) =
              tr_match(tree, match_env, val_env)
            | tr_match'(Option.SOME2(ref(Option.SOME2(lvar))),_, _) =
              LambdaTypes.APP(LambdaTypes.VAR(lvar),
                              [unit_exp],
                              Option.ABSENT)
            | tr_match'(Option.SOME2(_), _, _) =
              Crash.impossible "tr_match':trans_match:lambda"
d3632 1
a3632 11
	  (* mk_branch produces a (tag, code) pair, for a branch of the
	     SWITCH. *)
	  fun mk_branch (id as Ident.LONGVALID(_, valid), mv, tree) =
	    if has_value id then
	      (LambdaTypes.VCC_TAG(valid_name valid,#2(constructor_tag(valid, ty))),
	                 (* VCC_TAG isn't really accurate - will break when we
	                    automatically dereference the constructor value.
	                    But IMM_TAG isn't right either, as we have to know
	                    where to branch from the test of the run-time tag.
	                  *)
	                 if is_list_type ty then
d3636 27
a3662 29
			     being matched.
	                  *)
	                   tr_match'(
	                     tree,
	                     LambdaUtils.add_match_env((mv, ORIG_LV), match_env),
	                     val_env)
	                 else
	       LambdaTypes.do_binding
	         (* Assign lambda variable to value carried by constructor *)
                let 
                  val info = 
                    if variable_debug andalso not generate_moduler
                      then Option.PRESENT (ref (RuntimeEnv.VARINFO Option.ABSENT))
                    else Option.ABSENT
                in
	         (LambdaTypes.LETB(new_lv, info, new_le),
                  tr_match'(tree,
		            LambdaUtils.add_match_env((mv, (new_lv,info)), match_env),
                            val_env))
                end)
	    else
	      (LambdaTypes.IMM_TAG(valid_name valid,#2(constructor_tag(valid, ty))),
               tr_match'(tree, match_env, val_env)
	    )
          fun lambda_exp1() = 
	        if Type_Utils.get_no_cons ty = 1 then
		  (* Use this instead of Type_Utils.has_value_cons ty, because
		     we want to know about explicitly mentioned constructors
		     and we want to treat all EXCONS as VCCs. *)
d3679 1
a3679 1
                          val new_lv = LambdaTypes.new_LVar ()
d3682 1
a3682 1
                              then Option.PRESENT (ref (RuntimeEnv.VARINFO Option.ABSENT))
d3750 1
a3750 1
                  then Option.PRESENT (ref (RuntimeEnv.VARINFO Option.ABSENT))
d3800 1
a3800 1
            Let_Lambdas_In_Exp lambda_exp3 binding Option.ABSENT
d3804 1
a3804 1
                Let_Lambdas_In_Exp lambda_exp1 binding Option.ABSENT
d3807 1
a3807 1
                Let_Lambdas_In_Exp lambda_exp2 binding (Option.PRESENT(new_lv,new_le))
d3815 1
a3815 1
                   (LambdaTypes.new_LVar(),Option.ABSENT)
d3817 1
a3817 1
                   (LambdaTypes.new_LVar(),Option.PRESENT (ref (RuntimeEnv.VARINFO Option.ABSENT)))))
d3821 1
a3821 1
              (fn (x,y) => (x, y,(LambdaTypes.new_LVar(),Option.ABSENT)))
d3844 5
a3848 4
            Let_Lambdas_In_Exp lambda_exp
            (case binding of
               Option.ABSENT => []
             | Option.PRESENT(bd) =>[Option.SOME1(bd)]) Option.ABSENT
d3851 14
a3864 3
   val res_ty = #2(Types.argres(ty))
     handle Types.ArgRes => LambdaTypes.null_type_annotation
   val debug_info = function_return_debug_info(res_ty)
d3868 26
a3893 29
                   let
                     val old_null_tyfun_spills = store_null_tyfun_spills()
                     val tr_match =
                       (init_null_tyfun_spills();
                        make_binding_for_stepper(
                         make_handle_for_stepper(
                          make_null_tyfun_spills(
                           null_tyfun_spills denv debug_info (Location.to_string location);
                           make_return_binding_for_stepper(
                                     (tr_match(tree, match_env,env),debug_info,(name_string,fnname,fnname_lv)))),
                          (name_string,fnname,fnname_lv)),(fnname,fnname_lv)))
                     val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
                   in
                     tr_match
                   end,
                 name_string,ty,Option.ABSENT))
  end
	(*
	 * some_dec is a pair of lists of declarations, being split
	 * according to whether the dec occurs before or after the
	 * first instance of rec
	 * envir is the environment for handling the entire declaration.
	 *)
	(* trans_dec should return
	   the incremental environment from translating the declarations,
	   not the overall environment from the original and the translation.
	   Thus trans_dec should accumulate the increment until it runs
	   out of things to do, and then return it.
	*)
d3901 31
d3944 1
a3944 1
                                Option.ABSENT,
d3948 1
a3948 1
                  val dummy_lv = LambdaTypes.new_LVar()
d3958 1
a3958 1
                   Option.ABSENT,Option.ABSENT)
d3967 1
a3967 1
                              EnvironTypes.LAMB(lambda_var',Option.ABSENT))), 
d3970 3
a3972 3
                             Option.PRESENT(Symbol.symbol_name symbol,
                                            stuff,Option.ABSENT),
                             instance))
d3977 1
a3977 1
                       val dummy_lv = LambdaTypes.new_LVar()
d3993 1
a3993 1
                        ], Option.ABSENT, Option.ABSENT)
d3998 1
a3998 1
                       val dummy_lv = LambdaTypes.new_LVar()
d4011 1
a4011 1
                        Option.ABSENT,
d4020 1
a4020 1
                         (pat, LambdaTypes.new_LVar(),
d4029 1
a4029 2
                       val (has_vars, exhaustive, env, denv, lambda_list, 
                            debug_info,instance) =
d4050 1
a4050 1
                   ([], env_list_lambda_list_list),Option.ABSENT,
d4064 1
a4064 1
                         val new_lv = LambdaTypes.new_LVar()
d4076 1
a4076 1
                          @@ new_lambda_exp,Option.ABSENT,
d4084 1
a4084 1
                           val new_lv = LambdaTypes.new_LVar()
d4112 1
a4112 1
                            @@ new_lambda_exp,Option.ABSENT,
d4118 1
a4118 1
                       val new_lv = LambdaTypes.new_LVar()
d4138 1
a4138 1
                        Option.ABSENT,
d4154 1
a4154 1
                                                   (valid, EnvironTypes.LAMB(lambda_var',Option.ABSENT))),
d4156 1
a4156 1
                        lambda,Option.PRESENT(Symbol.symbol_name vid,stuff,Option.ABSENT),
d4165 1
a4165 1
                  val lvar = LambdaTypes.new_LVar()
d4168 1
a4168 2
                  val (has_vars, exhaustive, more_env, more_denv, more_lambda,
                       debug_info,instance) = 
d4183 1
a4183 1
                  val _ = null_tyfun_spills denvir debug_info location'
d4187 2
d4196 4
a4199 3
                  val _ = map (fn LambdaTypes.LETB(_,Option.PRESENT(ref (RuntimeEnv.VARINFO debug_info)),_) =>
                                 null_tyfun_spills denvir debug_info location'
                               | _ => ()) more_lambda
d4212 1
a4212 1
                      @@ new_bindings @@ make_step(fnname)))
d4223 1
a4223 1
                           val new_lv = LambdaTypes.new_LVar()
d4225 1
a4225 1
                           ((new_lv,Option.PRESENT (ref (RuntimeEnv.VARINFO Option.ABSENT))),
d4233 1
a4233 1
                         val new_lv = (LambdaTypes.new_LVar(),Option.ABSENT)
d4240 1
a4240 1
                    (fn ((lv,Option.PRESENT info_ref), 
d4247 2
a4248 1
                         (info_ref := (RuntimeEnv.VARINFO debug_info);
d4342 1
d4355 12
a4366 31
        let 
          fun trans_single_datatype(_, _, _, _, v_tref_topt_list) =
            let 
              fun munge((valid as Ident.CON sy, ref ty), _) =
                (Absyn.VALpat ((Ident.LONGVALID (Ident.NOPATH, Ident.VAR sy), 
                                (ref ty,ref (RuntimeEnv.RUNTIMEINFO (Option.ABSENT,nil)))),Location.UNKNOWN),
                 Absyn.VALexp(Ident.LONGVALID(Ident.NOPATH, valid), 
                              ref ty, Location.UNKNOWN,ref(nil,Absyn.Option.ABSENT)),
                 Location.UNKNOWN)
                | munge _ = Crash.impossible"Absyn.DATATYPE"
              val valdec_list = map munge v_tref_topt_list
            in
              trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set), 
                        Environ.empty_env, false, denvir, fnname)
            end
          val e_l_list = map trans_single_datatype datatypeinfo_list
          val old_null_tyfun_spills = store_null_tyfun_spills()
          val (env, denv, spills) =
            (init_null_tyfun_spills();
             DATATYPEdec_spills denvir datatypeinfo_list
             (env_from_list e_l_list, denv_from_list e_l_list, nil))
          val _ = restore_null_tyfun_spills(old_null_tyfun_spills)
      in
	(env,
         denv,
         reducel
         (fn (l1, (_, _, l2)) => l1 @@ l2)
         ([], e_l_list)@@spills)
      end
    | Absyn.ABSTYPEdec (_, _, dec) => 
        trans_dec(dec, envir, false, denvir, fnname)
d4378 1
a4378 1
	    val lv = LambdaTypes.new_LVar()
d4397 1
a4397 1
                    val Debugger_Types.INFO i = !debug_info_ref
d4399 2
a4400 1
                    debug_info_ref :=
d4404 6
a4409 1
                      ((ty,false,[]),Debugger_Types.empty_debugger_env, true)))
d4423 1
a4423 1
                          val lvar = LambdaTypes.new_LVar()
d4425 1
a4425 1
                          (redundant_exceptions := (lvar,exn_string)::(!redundant_exceptions);
d4432 1
a4432 1
                            Option.PRESENT(Option.SOME2(lvar))))
d4454 1
a4454 2
	      add_valid_denv (empty_denv,
				     (v, EnvironTypes.NULLEXP))
d4505 1
a4505 1
	     val valid_map = map (fn (v, c) => (v, c, LambdaTypes.new_LVar())) valid_map'
d4508 11
a4518 18
	       (fn (s, ec) => (s, ec, LambdaTypes.new_LVar())) strid_map'
             (* nosa 02/94
                Full paths in LAMBs for absolute exception constructor code in
                dynamic redundancy checker
              *)
             infix ^^
             local
               infix ^^^
               fun Ident.NOPATH ^^^ p = p
                 | (Ident.PATH(s,p)) ^^^ p' = Ident.PATH(s,p^^^p')
             in
               fun (Option.PRESENT(Option.SOME1(Ident.LONGSTRID(p,Ident.STRID s))))^^
                   (Ident.LONGSTRID(p',s')) =
                 Option.PRESENT(Option.SOME1(Ident.LONGSTRID(p^^^Ident.PATH(s,Ident.NOPATH)^^^p',s')))
                 | Option.ABSENT ^^ longstrid = Option.PRESENT(Option.SOME1(longstrid))
                 | _ ^^ _ = Crash.impossible "^^:trans_open:lambda"
             end
             val longstrid' = longstrid'^^longstrid
d4530 2
a4531 1
	     val new_v_lambdas = map
d4533 8
a4540 8
		LambdaTypes.LETB(l, Option.ABSENT,LambdaTypes.SELECT(make_struct_select field, lambda_exp))
             | (_, EnvironTypes.PRIM prim, l) => 
                 LambdaTypes.LETB(l,Option.ABSENT,
				 case prim of
				   Pervasives.IDENT_FN => ident_code()
				 | _ => LambdaTypes.BUILTIN prim)
             | _ => Crash.impossible "Absyn.OPENdec(1)"
		   ) valid_map
d4580 5
a4584 6
  fun initialise trans_dec = 
      (* nosa 02/94
            Bind new exception locally to Dynamic redundancy checker for toplevel struct;
            Generate Dynamic redundancy checker.
            Also for the Modules Debugger bind any global lambda variables formed from
            functor parameters
d4586 37
a4622 6
      (redundant_exceptions := nil;
       tfs_lvs := [];
       dexps := [];
       let
         val (env, denv, bindings) = trans_dec()
       in
d4624 38
a4661 58
        map (fn (_,(lvar,lexp)) =>
               LambdaTypes.LETB(lvar,Option.ABSENT,
                                lexp))
        (!tfs_lvs) @@
        map (fn (_,(lvar,lexp)) =>
               LambdaTypes.LETB(lvar,Option.ABSENT,
                                lexp)) 
        (!dexps) @@
        map (fn (lvar,exn_string) =>
                    LambdaTypes.LETB(lvar,Option.ABSENT,
                                     LambdaTypes.STRUCT
                                     ([LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                       [unit_exp],
                                                       Option.ABSENT),
                                     LambdaTypes.SCON(Ident.STRING exn_string)],
                                     LambdaTypes.CONSTRUCTOR)))
                   (!redundant_exceptions) @@
         (case Dynamic_redundancy_report() of
            lexp as LambdaTypes.STRUCT([],_) => bindings
          | dynamic_report => 
            LambdaTypes.LETB(LambdaTypes.new_LVar(),Option.ABSENT,
                             dynamic_report)::bindings))
       end)

  fun trans_str_exp
	(strexp, top_env as EnvironTypes.TOP_ENV(env, fun_env), 
         denv, fnname) =
  case strexp of
    Absyn.NEWstrexp strdec =>
    let 
      val (env, denv, lv_le_list) = trans_str_dec(strdec, top_env, denv, false, fnname)
      val (EnvironTypes.TOP_ENV(env, _), lambda_exp) =
	complete_struct_from_topenv(make_top_env env, lv_le_list)
    in
      (env, lambda_exp, EnvironTypes.DENV'(denv))
    end
  | Absyn.OLDstrexp (longstrid,_,interface) => 
      let
        val (env, lexp, _, moduler_generated) = cg_longstrid(longstrid, env)
        val ((strexp, env), dstrexp) =
        case (moduler_generated,generate_moduler) of
          (true,false) =>
            (strip_tyfuns (lexp,env),
            empty_dstrexp)
        | (false,true) =>
            let
              val interface = fetch_interface interface
            in
              (include_tyfuns (lexp,interface,env),
               make_dstrexp interface)
            end
        | (true,true) =>
             ((lexp, env),
              cg_longstrid'(longstrid, denv))
        | (false,false) => ((lexp, env), empty_dstrexp)
      in
        (env, strexp, dstrexp)
      end
d4663 87
a4749 85
  | Absyn.APPstrexp(funid as Ident.FUNID sy, strexp, coerce, location, debugger_str) =>
    let
      val (lv, result_env as EnvironTypes.ENV(valid_env, strid_env), moduler_generated) = 
        Environ.lookup_funid(funid, fun_env)
      val old_functor_refs = !functor_refs
      val _ = functor_refs := []
      val (env, arg, dstrexp) = trans_str_exp(strexp, top_env, denv, fnname)
      val Basis.BasisTypes.PHI (_, (interface, Basis.BasisTypes.SIGMA(_,interface'))) =
        Basis.lookup_funid (funid, basis)
	handle NewMap.Undefined =>
	  Crash.impossible "Undefined functor id in trans_str_exp"

      val (new_env, new_arg) =
	complete_struct((env, arg), Option.PRESENT interface, !coerce, generate_moduler)

      val dlvar = if generate_moduler then LambdaTypes.new_LVar()
                  else 0
      val new_arg =
        if generate_moduler then
            (** create unique functor application refs for debugger structure returns
                for modules debugger **)
            let_lambdas_in_exp(map (fn (ref(Option.SOME1(lv)),interface) =>
                                    LambdaTypes.LETB(lv,Option.ABSENT,
                                                     LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                                     [str_to_lambda interface],
                                                                     Option.ABSENT))
                                     | _ => Crash.impossible "1:SOME2:functor_refs:lambda")
            (!functor_refs),
          (functor_refs := old_functor_refs;
           LambdaTypes.STRUCT([new_arg,
                               dstrexp_to_lambda(merge_dstrexps (fetch_debugger_str debugger_str,
                                                                 Option.PRESENT interface,dstrexp,
                                                                 location)),
                               LambdaTypes.VAR dlvar],
                               LambdaTypes.TUPLE)))
        else
          new_arg
      val functorexp =
        LambdaTypes.APP(
        case lv of
	  EnvironTypes.LAMB (lv,_) => LambdaTypes.VAR lv
	| EnvironTypes.EXTERNAL =>
	    LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_FUNCT,
                            [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))],
                            Option.ABSENT)
	| EnvironTypes.PRIM _ => Crash.impossible "APPstrexp(1)"
	| EnvironTypes.FIELD _ => Crash.impossible "APPstrexp(2)",
            [new_arg],
            Option.ABSENT)
      val ((functorexp, env), dfunctorexp) =
        case (moduler_generated,generate_moduler) of
        (** compatibility considerations for modules debugger **)
          (true,false) =>
            (strip_tyfuns (functorexp,result_env),
            empty_dstrexp)
        | (false,true) =>
            (functor_refs := (ref(Option.SOME1(dlvar)),interface')::(!functor_refs);
             (include_tyfuns (functorexp,interface',result_env),
              make_dstrexp interface'))
        | (true,true) =>
            let
              val dlvar = ref(Option.SOME1(dlvar))
            in
              (functor_refs := (dlvar,interface')::(!functor_refs);
               ((functorexp, env),
                EnvironTypes.LAMBDASTREXP'([],dlvar,interface')))
            end
        | (false,false) => ((functorexp, env), empty_dstrexp)
    in
     (result_env, functorexp, dfunctorexp)
    end
  | Absyn.LOCALstrexp(strdec, strexp) =>
    let 
      val (local_env, local_denv, local_lambdas) = 
        trans_str_dec(strdec, top_env, denv, false, fnname)
      val (new_env, new_lambda, new_dexp) =
	trans_str_exp(strexp,
	  	      Environ.augment_top_env(top_env, make_top_env local_env),
                      augment_denv (denv, local_denv),
		      fnname)
    in
      (new_env, 
       let_lambdas_in_exp(local_lambdas, new_lambda), 
       new_dexp)
    end
d4754 1
a4754 1
    Absyn.DECstrdec dec => initialise (fn ()=>trans_dec(dec, env, is_toplevel, denv, fnname))
d4774 1
a4774 1
          val lambda_var = LambdaTypes.new_LVar()
d4779 1
a4779 1
					  EnvironTypes.LAMB (lambda_var,Option.ABSENT),generate_moduler))),
d4812 1
a4812 1
          val lambda_var = LambdaTypes.new_LVar()
d4817 1
a4817 1
					  EnvironTypes.LAMB(lambda_var,Option.ABSENT),generate_moduler))),
d4864 1
a4864 1
	(funbind as
a4869 1
      val _ = do_moduler_debug(fn ()=>Ident.Location.to_string location)
d4872 1
a4872 1
      val lvar' = LambdaTypes.new_LVar()
d4891 1
a4891 1
						EnvironTypes.LAMB(lvar',Option.ABSENT),
d4903 3
a4905 5
           else empty_denv), ("",~1))
      val _ =
          case funid of Ident.FUNID(funid) =>
            do_moduler_debug(fn ()=>(LambdaPrint.print_lambda print_options lambda_exp;
                                     Ident.Symbol.symbol_name funid^"  code:\n"))
d4907 4
a4910 5
	complete_struct
	((str_env, lambda_exp),
	 inte_opt,
	 !coerce, generate_moduler)
      val lambda_var = LambdaTypes.new_LVar()
d4916 1
d4926 1
a4926 1
            let_lambdas_in_exp(map (fn (ref(Option.SOME1(lv)),interface) =>
d4931 1
a4931 1
                                     | _ => Crash.impossible "2:SOME2:functor_refs:lambda")
d4935 1
a4935 1
                               LambdaTypes.LET((LambdaTypes.new_LVar(),Option.ABSENT,
d4950 1
a4950 1
	  (EnvironTypes.LAMB(lambda_var,Option.ABSENT),  str_env, generate_moduler)))),
d4992 1
a4992 1
            trans_str_dec(strdec, top_env, top_denv, true, ("",~1))
d5003 2
a5004 1
  val a = sub_functor_refs a
d5008 1
a5008 1
    (fn (ref(Option.SOME1(lv)),interface) => 
d5013 2
a5014 1
  | _ => Crash.impossible "3:SOME2:functor_refs:lambda") (!functor_refs) @@ c
d5019 7
a5025 6
        reducel (fn ((env,ct),(lv' as ref(Option.SOME1(lv)),_))=>
                       (lv' := Option.SOME2(ct);
                       (Environ.add_valid_env(env,
                         (Ident.VAR(Symbol.find_symbol("functor app ref " ^ makestring ct)),
                          EnvironTypes.LAMB(lv,Option.ABSENT))),ct+1))
                        | _ => Crash.impossible "4:SOME2:functor_refs:lambda")
d5034 1
a5034 1
  val result_debug_info = ! debug_info_ref
@


1.164
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d551 3
a553 1
  (* General utils foo *)
d3113 1
a3113 1
                         (MLWorks.Internal.Value.cast
@


1.163
log
@Lambdatypes changes
@
text
@d4 3
d1086 2
a1087 2
		NewMap.YES ty => (false, res)
	      | NewMap.NO => (true, NewMap.tryApply' (vm, valid))
d1094 1
a1094 1
	          NewMap.YES ty =>
d1096 1
a1096 1
	        | NewMap.NO =>
@


1.162
log
@Abstraction of debug information in lambdatypes
Various bits of tidying up
@
text
@d4 4
d547 10
d591 3
a593 2
  fun select_exn_unique(LambdaTypes.STRUCT[unique, _]) = unique
  | select_exn_unique lexp = LambdaTypes.SELECT({index=0, size=2}, lexp)
d663 1
a663 1
    Lists.reducel
d666 1
a666 1
    Lists.reducel
d696 2
a697 1
     size = Lists.length record_domain}
d769 1
a769 1
    LambdaTypes.SELECT({index = 0, size = 2}, lexp)
d774 1
a774 1
    LambdaTypes.SELECT({index = 1, size = 2}, lexp)
d809 6
d821 1
a821 1
      (env', LambdaTypes.SELECT(field, lambda))
d830 1
a830 1
      (env', LambdaTypes.SELECT(field, lambda), longstrid, generate_moduler)
d852 1
a852 1
	EnvironTypes.FIELD field => LambdaTypes.SELECT(field, lambda)
d878 1
a878 1
            EnvironTypes.FIELD field => LambdaTypes.SELECT(field, lambda)
d911 1
a911 1
            (env''', LambdaTypes.SELECT(field, lambda), longstrid, generate_moduler)
d938 1
a938 1
    Lists.reducel (fn (exp, bind) => LambdaTypes.do_binding(bind, exp))
d1068 1
a1068 1
	Lists.reducel
d1071 1
a1071 1
	  (Lists.reducel
d1100 1
a1100 1
				 LambdaTypes.STRUCT[lexp, LambdaTypes.VAR lv],
d1105 1
a1105 1
                LambdaTypes.STRUCT[lexp, LambdaTypes.STRUCT[]]
d1119 1
a1119 2
				    (f_old, LambdaTypes.VAR lambda_var)),
		   "")
d1121 1
a1121 1
                LambdaTypes.LETB(lv,Option.ABSENT,coerce (valid,LambdaTypes.BUILTIN prim),"")
d1131 1
a1131 1
		  (lv,Option.ABSENT, 
d1135 2
a1136 4
			 LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),
			 ""),
		      le),
                   "")
d1146 1
a1146 1
        			       LambdaTypes.STRUCT the_structure_list)
d1170 2
a1171 1
			 (map (fn (_,(x, (* _, *) _, _)) => extract_op x) funids))))
d1196 1
a1196 1
                                                     lambda_exp,""), 
d1235 1
a1235 1
            val exp = (!dynamic_redundancy_report) (LambdaTypes.STRUCT[])
d1284 8
a1291 7
                                    (0,
                                     Option.PRESENT(ref (RuntimeEnv.VARINFO
                                                         (Option.PRESENT("tyvar for "^name,
                                                                         dummy_instance(),
                                                                         tyvar_slot)))),
                                     LambdaTypes.VAR(tyvar),
                                     LambdaTypes.LET(result,Option.ABSENT,
d1293 1
a1293 1
                                                                     Option.ABSENT),
d1302 7
a1308 7
                 LambdaTypes.LET(0,
                                 Option.PRESENT(ref (RuntimeEnv.VARINFO
                                                     (Option.PRESENT("tyvar for "^name,
                                                                     dummy_instance(),
                                                                     tyvar_slot)))),
                 LambdaTypes.VAR(tyvar),
                 debugger_application (Types.the_type(ty)) lexp 1)
d1358 9
a1366 7
                     (LambdaTypes.new_LVar(),Option.ABSENT,
                      LambdaTypes.APP(LambdaTypes.VAR step_lvar,
                                      [LambdaTypes.STRUCT[LambdaTypes.VAR(fnname),
                                                          LambdaTypes.STRUCT[LambdaTypes.INT(1),
                                                                             LambdaTypes.VAR(exn)]]],
                                      Option.ABSENT),
                      LambdaTypes.RAISE(LambdaTypes.VAR(exn))),
d1410 4
a1413 7
               [LambdaTypes.LETB(step_lvar,Option.ABSENT,step_fn,"step function"),
                LambdaTypes.LETB(breakpoint_lvar,Option.ABSENT,breakpoint_fun,
                                 "breakpoint function"),
                LambdaTypes.LETB(breakpoint_on_exit_lvar,Option.ABSENT,breakpoint_on_exit_fun,
                                 "breakpoint_on_exit function"),
                LambdaTypes.LETB(step_handler_lvar,Option.ABSENT,step_handler_fn,
                                 "step handler")],
d1442 4
a1445 3
                                                   [LambdaTypes.STRUCT[LambdaTypes.VAR fnname_lvar,
                                                                       LambdaTypes.INT(0)]],
                                                   Option.ABSENT),"make step")]
d1476 5
a1480 4
                LambdaTypes.LET(LambdaTypes.new_LVar(),Option.ABSENT,
                                LambdaTypes.APP(breakpoint_exp,
                                                [LambdaTypes.VAR fnname_lvar],
                                                Option.ABSENT),lexp)
d1491 5
a1495 4
              LambdaTypes.LET(LambdaTypes.new_LVar(),Option.ABSENT,
                              LambdaTypes.APP(breakpoint_on_exit_exp,
                                              [LambdaTypes.VAR fnname_lvar],
                                              Option.ABSENT),lexp)
d1505 2
a1506 2
              LambdaTypes.LET(fnname_lv,Option.ABSENT,
                              LambdaTypes.SCON(LambdaTypes.Ident.STRING(fnname)),
d1891 5
a1895 4
                  LambdaTypes.LET(new_cg,Option.ABSENT,LambdaTypes.SELECT({index=0,size=3},LambdaTypes.VAR(args)),
                   LambdaTypes.LET(dexp',Option.ABSENT,LambdaTypes.SELECT({index=1,size=3},LambdaTypes.VAR(args)),
                     LambdaTypes.LET(instance',Option.ABSENT,LambdaTypes.SELECT({index=2,size=3},LambdaTypes.VAR(args)),
                       LambdaTypes.LET(lvar,Option.ABSENT,LambdaTypes.VAR(dexp'),
d1903 1
a1903 1
                                                                 val lexp = LambdaTypes.SELECT({index=1,size=2},
d1909 7
a1915 4
                                                                                      LambdaTypes.STRUCT[LambdaTypes.INT 0, lexp])],
                                                                                    Option.PRESENT(LambdaTypes.STRUCT[LambdaTypes.INT 1,
                                                                                                                      LambdaTypes.STRUCT[lexp,
                                                                                                                                         LambdaTypes.VAR(instance')]]))
d1921 1
a1921 1
                [LambdaTypes.LETB(lv,Option.ABSENT,lexp,"overload function binding")],
d1933 1
a1933 1
            | select (s::ss) = LambdaTypes.SELECT(s,select ss)
d1941 2
a1942 2
          LambdaTypes.STRUCT[LambdaTypes.INT 1,
                             LambdaTypes.INT i]
d1983 1
a1983 1
              LambdaTypes.STRUCT[LambdaTypes.INT 0,LambdaTypes.INT i]
d1985 5
a1989 3
              LambdaTypes.STRUCT[LambdaTypes.INT 1,
                                 LambdaTypes.STRUCT[LambdaTypes.INT i,
                                                    LambdaTypes.INT i']]
d2015 6
a2020 4
                                  Option.ABSENT => LambdaTypes.STRUCT[LambdaTypes.INT 0, lexp]
                                | Option.PRESENT(i) => LambdaTypes.STRUCT[LambdaTypes.INT 1,
                                                            LambdaTypes.STRUCT[lexp,
                                                                               LambdaTypes.INT i]]
d2027 6
a2032 5
                  [LambdaTypes.STRUCT[new_cg,dexp',
                          case fetch_instance'() of
                                      Option.ABSENT => LambdaTypes.INT ~1
                                    | Option.PRESENT(i) => LambdaTypes.INT i]],
                                  Option.ABSENT)
d2045 3
a2047 2
                                      [LambdaTypes.STRUCT[select(selects,LambdaTypes.VAR root_lv),
                                                          dexp',LambdaTypes.INT ~1]],
d2056 3
a2058 2
                                           [LambdaTypes.STRUCT[select(selects,LambdaTypes.VAR root_lv),dexp',
                                                               LambdaTypes.VAR lv]],
d2102 1
a2102 1
          LambdaTypes.STRUCT[select (selects,LambdaTypes.VAR lv),
d2104 3
a2106 2
                                             [LambdaTypes.STRUCT[]],
                                             Option.ABSENT)]
d2143 2
a2144 1
                                 (NewMap.to_list_ordered stridmap))
d2156 2
a2157 1
                           (NewMap.to_list_ordered stridmap))
d2292 1
a2292 1
              LambdaTypes.SELECT({index=index, size=size2},
d2296 1
a2296 1
              strip_tyfuns(LambdaTypes.SELECT({index=size1 + index, size=size2},
d2304 3
a2306 4
          (LambdaTypes.LET(lvar,Option.ABSENT,
                           lexp,
                           LambdaTypes.STRUCT(vars @@ map #1 strs)),
           Lists.reducel (fn (env,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env'))=>
d2311 1
a2311 1
           (Lists.reducel (fn (env,(Ident.TYCON'(_),_))=>env
d2338 1
a2338 1
                LambdaTypes.SELECT({index=index, size=size3},
d2346 1
a2346 1
                include_tyfuns(LambdaTypes.SELECT({index=size2 + index, size=size3},
d2351 1
a2351 2
            (LambdaTypes.LET(lvar,Option.ABSENT,
                             lexp,
d2353 3
a2355 2
                                                map #1 strs)),
            Lists.reducel (fn (map,((strid,(_,EnvironTypes.FIELD{index, ...},_)),env))=>
d2360 1
a2360 1
            (#1(Lists.reducel (fn ((map,index),(Ident.TYCON(tc),_))=>
d2411 1
a2411 1
              Lists.reducel (fn (spills,ty)=>spills@@type_spills ty)
d2516 7
a2522 5
               LambdaTypes.LETB(0,Option.PRESENT(ref (RuntimeEnv.VARINFO
                                                      (Option.PRESENT("null_tyfun_spill",
                                                                      dummy_instance(),Option.PRESENT(spill))))),
               tyfun,
               "null_tyfun_spill")) (!tyfun_spills),
d2551 1
a2551 1
        (fn (lambda,lambdalist)=>LambdaTypes.STRUCT[lambda,lambdalist]) (lambdas,LambdaTypes.INT(1))
d2583 1
a2583 2
                                                   Option.ABSENT),
                                    "type function function for "^IdentPrint.printTyCon tycon)::bindings)
d2618 1
a2618 2
                                                   Option.ABSENT),
                                    "type function function for "^IdentPrint.printTyCon tycon)::bindings)
d2633 1
a2633 2
                              lexp,
                              comment),
d2636 1
a2636 2
                                           LambdaTypes.VAR(lv),location),
                              comment)]
d2640 1
a2640 2
                              lexp,
                              comment)]
d2644 1
a2644 2
                            lexp,
                            comment)]
d2812 1
a2812 1
                              LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv])
d2844 1
a2844 1
                                        LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],
d2850 1
a2850 1
                       LambdaTypes.STRUCT[le, LambdaTypes.STRUCT[]]
d2873 1
a2873 2
                                        LambdaTypes.LETB(lv,Option.ABSENT, le,
                                                         "Used in the generation of a record expression"))
d2877 2
a2878 1
                                   (Lists.qsort known_order lvar_lab_lexp_list)))
d2917 1
a2917 1
                 (LambdaTypes.STRUCT[le, le' as LambdaTypes.INT _],
d2919 2
a2920 2
                 (true, LambdaTypes.STRUCT[le', le], valexp)
               | (LambdaTypes.STRUCT[le' as LambdaTypes.INT _, le],
d2922 1
a2922 1
                 (true, LambdaTypes.STRUCT[le', le], valexp)
d2933 1
a2933 1
                LambdaTypes.STRUCT[LambdaTypes.INT tag, le] => (le, tag)
d2953 1
a2953 1
                LambdaTypes.LET(var,Option.ABSENT,arg,body)
d2998 1
a2998 1
                                       Lists.reducel op ^
d3025 1
a3025 1
                Lists.reducel
d3068 1
a3068 1
                                          Lists.reducel op ^
d3109 1
a3109 1
            LambdaTypes.STRUCT[lexpr,tyexpr]
d3156 1
a3156 2
                LambdaTypes.RAISE(LambdaTypes.STRUCT(
                      [LambdaTypes.BUILTIN Pervasives.EXMATCH, LambdaTypes.STRUCT []]))
d3186 1
a3186 2
                                                        Option.ABSENT),
                                        "dynamic redundancy reporting for "^rc))
d3196 1
a3196 1
                                        [LambdaTypes.STRUCT[LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
d3199 2
a3200 1
                                                            report rcs]],
d3205 1
a3205 1
                                            [LambdaTypes.STRUCT[LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
d3208 2
a3209 1
                                                                LambdaTypes.SCON(Ident.INT("0",Location.UNKNOWN))]],
d3212 1
a3212 1
                            [(LambdaTypes.IMM_TAG ("",1),LambdaTypes.STRUCT[]),
d3215 1
a3215 1
                                [LambdaTypes.STRUCT[MLWorks_IO_std_out,
d3217 1
a3217 1
                                  [LambdaTypes.STRUCT[LambdaTypes.SCON(Ident.STRING(
d3220 4
a3223 2
                                                      report redundant_clauses]],
                                  Option.ABSENT)]],
d3250 1
a3250 1
                          LambdaTypes.SELECT({index = 0, size = 2},
d3261 1
a3261 1
                                          [LambdaTypes.STRUCT[exn_code exn1,exn_code exn2]],
d3278 1
a3278 1
                      LambdaTypes.LET(LambdaTypes.new_LVar(),Option.ABSENT,
d3282 1
a3282 1
                          LambdaTypes.STRUCT[
d3284 1
a3284 1
                           [LambdaTypes.STRUCT[LambdaTypes.VAR lvar,
d3286 4
a3289 2
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(explode(rc)))))))))]],
                            Option.ABSENT),LambdaTypes.INT 1]),
d3291 1
a3291 1
                           LambdaTypes.STRUCT[
d3293 1
a3293 1
                            [LambdaTypes.STRUCT[LambdaTypes.VAR redundant_clauses_lambda,
d3295 1
a3295 1
                                [LambdaTypes.STRUCT[LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
d3298 7
a3304 4
                                               LambdaTypes.SCON(Ident.INT("1",Location.UNKNOWN))]],
                                Option.ABSENT)]],
                            Option.ABSENT), LambdaTypes.INT 1])],
                        Option.ABSENT),
d3314 10
a3323 9
                   (LambdaTypes.LET(LambdaTypes.new_LVar(),Option.ABSENT,
                     let_lambdas_in_exp(LambdaTypes.LETB(
                                       redundant_clauses_lambda,Option.ABSENT,
                                        LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                        [LambdaTypes.SCON(Ident.INT(makestring number_of_clauses,
                                                                                    Location.UNKNOWN))],
                                                        Option.ABSENT),
                                        "redundancy count") ::
                                        bindings,redundancy_code redundant_clauses),
d3353 1
a3353 1
                           (lv,Option.ABSENT,
d3367 3
a3369 3
                                LambdaTypes.null_type_annotation,Option.ABSENT),
                            "Translation of match trees"))
                          end::do_binding bindings
d3383 1
a3383 1
                           (lv,Option.ABSENT,
d3394 1
a3394 1
                                        LambdaTypes.LET(lvar,Option.ABSENT,lexp,
d3406 1
a3406 2
                                LambdaTypes.null_type_annotation,Option.ABSENT),
                            "Translation of match trees"))
d3417 1
a3417 1
                                            [LambdaTypes.STRUCT []],
d3432 1
a3432 1
                                            [LambdaTypes.STRUCT []],
d3457 2
a3458 2
                                      LambdaTypes.LET(dummylv,Option.PRESENT (ref (RuntimeEnv.VARINFO debug_info)),
                                      LambdaTypes.VAR(lv),
d3555 1
a3555 1
                              [LambdaTypes.STRUCT []],
d3589 1
a3589 1
	         (LambdaTypes.LETB(new_lv, info, new_le, "match translation"),
d3629 1
a3629 2
                                              Option.ABSENT),
                              "match translation (iv)"),
d3694 1
a3694 1
              ([LambdaTypes.LETB(new_lv,info,new_le, "")],
d3764 1
a3764 1
	  val new_env = Lists.reducel
d3770 1
a3770 3
				 LambdaTypes.SELECT(record_label_offset(lab,
									ty),
						    le),""))
d3827 5
a3831 3
    val excp = Option.PRESENT(
      LambdaTypes.RAISE(LambdaTypes.STRUCT(
	[LambdaTypes.BUILTIN Pervasives.EXBIND, LambdaTypes.STRUCT []])))
d3857 2
a3858 3
                                                        ),
                                     "")
                   ],Option.ABSENT,Option.ABSENT)
d3892 1
a3892 2
                                      ),
                                          "")
d3901 1
a3901 2
                        [LambdaTypes.LETB(
                                          dummy_lv,Option.ABSENT,
d3910 2
a3911 2
                                                             ),
                                          "")],Option.ABSENT,
d3943 1
a3943 1
                   Lists.reducel (fn (env, (_, _, env', _, _)) => 
d3946 1
a3946 1
                   Lists.reducel (fn (env, (_, _, _, env', _)) => 
d3949 1
a3949 1
                   Lists.reducel
d4096 1
a4096 1
                  val _ = map (fn LambdaTypes.LETB(_,Option.PRESENT(ref (RuntimeEnv.VARINFO debug_info)),_,_) =>
d4180 1
a4180 1
                    Lists.reducel Environ.augment_env (Environ.empty_env, map #1 env_le_list)
d4182 1
a4182 1
                    Lists.reducel augment_denv (empty_denv, map #2 env_le_list)
d4277 1
a4277 1
         Lists.reducel
d4291 1
a4291 1
	  (env, denv, Lists.reducel (fn (x, y) => y @@ x) ([], lambdas))
d4337 5
a4341 4
                                     [LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                      [LambdaTypes.STRUCT[]],
                                                      Option.ABSENT),
                                     LambdaTypes.SCON(Ident.STRING exn_string)],
d4349 3
a4351 2
                           [select_exn_unique(exp),
                            LambdaTypes.SCON(Ident.STRING exn_string)],
d4356 1
a4356 2
		([LambdaTypes.LETB(lv, Option.ABSENT,lambda_exp,
				   "Bound to a handler wrapped thing")],
d4439 1
a4439 1
	     val new_v_env = Lists.reducel
d4443 1
a4443 1
	     val new_s_env = Lists.reducel
d4450 1
a4450 1
		LambdaTypes.LETB(l, Option.ABSENT,LambdaTypes.SELECT(field, lambda_exp),"")
d4455 1
a4455 2
				 | _ => LambdaTypes.BUILTIN prim,
				 "")
d4460 1
a4460 1
		LambdaTypes.LETB(l,Option.ABSENT, LambdaTypes.SELECT(field, lambda_exp),"")
d4462 1
a4462 1
                 LambdaTypes.LETB(l, Option.ABSENT,LambdaTypes.BUILTIN prim,"")
d4484 1
a4484 1
      (new_env, new_denv, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
d4513 2
a4514 2
                                lexp,
                                "global type-function binding")) (!tfs_lvs) @@
d4517 2
a4518 2
                                lexp,
                                "global debugger-exp binding")) (!dexps) @@
d4522 3
a4524 3
                                     [LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                      [LambdaTypes.STRUCT[]],
                                                      Option.ABSENT),
d4526 1
a4526 1
                                     "redundant exception binding "^exn_string))
d4529 1
a4529 1
            lexp as LambdaTypes.STRUCT[] => bindings
d4532 1
a4532 2
                             dynamic_report,
                             "dynamic redundancy report")::bindings))
d4593 3
a4595 4
                                                   LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                                   [str_to_lambda interface],
                                                                   Option.ABSENT),
                                                   "functor app ref")
d4599 6
a4604 5
           LambdaTypes.STRUCT[new_arg,
                              dstrexp_to_lambda(merge_dstrexps (fetch_debugger_str debugger_str,
                                                          Option.PRESENT interface,dstrexp,
                                                                location)),
                              LambdaTypes.VAR dlvar]))
d4690 1
a4690 1
            LambdaTypes.LETB(lambda_var,Option.ABSENT,lambda_exp,"") 
d4728 1
a4728 1
            LambdaTypes.LETB(lambda_var, Option.ABSENT,lambda_exp,"") 
d4753 1
a4753 1
      (new_env, new_denv, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
d4827 6
a4832 9
         LambdaTypes.LET(lvar',Option.ABSENT,
          LambdaTypes.SELECT({index=0,size=3},
                             LambdaTypes.VAR(lvar)),
            LambdaTypes.LET(lvar'',Option.ABSENT,
               LambdaTypes.SELECT({index=1,size=3},
                                  LambdaTypes.VAR(lvar)),
            LambdaTypes.LET(lvar''',Option.ABSENT,
               LambdaTypes.SELECT({index=2,size=3},
                                  LambdaTypes.VAR(lvar)),
d4836 3
a4838 4
                                                   LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                                   [str_to_lambda interface],
                                                                   Option.ABSENT),
                                                   "functor app ref")
d4842 7
a4848 7
                              LambdaTypes.LET(lambda_var',Option.ABSENT,
                                              lambda_exp,
                              LambdaTypes.LET(LambdaTypes.new_LVar(),Option.ABSENT,
                                              LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.BECOMES,
                                                              [LambdaTypes.STRUCT[LambdaTypes.VAR lvar''',
                                                                                  dstrexp_to_lambda dstrexp]],
                                                              Option.ABSENT),
d4862 1
a4862 2
                                        LambdaTypes.null_type_annotation,Option.ABSENT),
                           "")])
d4919 1
a4919 2
                                      Option.ABSENT),
                      "functor app ref")
d4925 1
a4925 1
        Lists.reducel (fn ((env,ct),(lv' as ref(Option.SOME1(lv)),_))=>
@


1.161
log
@Fix constructor names so that -delivery can deal with them
@
text
@d4 3
d498 2
a499 1
    Environ.EnvironTypes.LambdaTypes.Option = LambdaUtils.Match.Option
d501 3
d508 3
a510 2
    = Types.Datatypes.Type = AbsynPrint.Absyn.Type
  sharing type LambdaSub.LT.Instance = Types.Datatypes.Instance = AbsynPrint.Absyn.Instance
d512 1
a512 1
    = AbsynPrint.Absyn.Tyfun
d537 22
d560 4
a563 1
  val show_match = ref false
d565 1
a565 1
  fun diagnose str = Diagnostic.output 2 (fn i => [str])
d567 10
a579 10
  fun str_filter_map (eq, a_list, [], _, done) = rev done
    | str_filter_map (eq, [], x :: _, print_fn, done) =
        Crash.impossible("member '" ^ print_fn x ^
		         "' missing in str_filter_map")
    | str_filter_map(eq, (x, y)::xs, second as (z :: zs), print_fn, done) =
        if eq (x, z) then
	  str_filter_map(eq, xs, zs, print_fn, (x, y) :: done)
        else
	  str_filter_map(eq, xs, second, print_fn, done)

d581 13
a593 19
    (str_filter_map(eq, a_list, f_list, print_fn, [])
     handle _ =>
       (output(std_out,"Problem in the ordered maps in _lambda\n");
        output(std_out,"First argument\n");
        map (fn (x,_) => (output(std_out,(print_fn x) ^ " "))) a_list;
        output(std_out,"\nSecond argument\n");
        map (fn x => (output(std_out,print_fn x ^ " "))) f_list;
        output(std_out,"\n\n");
        Crash.impossible "Filter map errored out"))

  fun val_filter_map (a_list, [], _, done) = rev done
    | val_filter_map ([], z :: _, print_fn, done) =
        Crash.impossible("member '" ^ print_fn z ^
		         "' missing in val_filter_map")
    | val_filter_map((x, y)::xs, second as (z :: zs), print_fn, done) =
        if Ident.valid_eq (x, z) then
	  val_filter_map(xs, zs, print_fn, (x, y) :: done)
        else
	  val_filter_map(xs, second, print_fn, done)
d596 13
a608 9
    (val_filter_map(a_list, f_list, f_print_fn, [])
     handle _ =>
       (output(std_out,"Problem in the ordered maps in _lambda\n");
        output(std_out,"First argument\n");
        map (fn (x,_) => (output(std_out,(a_print_fn x) ^ " "))) a_list;
        output(std_out,"\nSecond argument\n");
        map (fn x => (output(std_out,f_print_fn x ^ " "))) f_list;
        output(std_out,"\n\n");
        Crash.impossible "Filter map errored out"))
d618 1
d630 1
a630 3
	Option.PRESENT {lv = l (* dummy_value *),
			     num_imms = 2,
			     num_vccs = 0},
a658 7
(** This is just a modified version of the one from the Ten_15
    code-generator.  This returns a unique tag for a constructor,
    which can later be used to identify it.  All constructed values
    will consist of a pair of objects, the first being the tag, and
    the second being the value held in the object.  Nullary
    constructors can however be represented just by the tag alone.
**)
a668 5
(** Likewise this is also taken from the Ten_15 code-generator, and
    then modified a bit.  It extracts for a label and a type, the
    offset into the canonical ordering for a structure of that type,
    to obtain the label named.
**)
d770 1
a770 1
	    [LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))],
d778 1
a810 5
  fun str_from_valid(Ident.VAR sy) = Symbol.symbol_name sy
  | str_from_valid(Ident.CON sy) = Crash.impossible"str_from_valid of con"
  | str_from_valid(Ident.TYCON' _) = Crash.impossible"str_from_valid of tycon"
  | str_from_valid(Ident.EXCON sy) = Symbol.symbol_name sy

d821 1
a821 1
			   [LambdaTypes.SCON(Ident.STRING(str_from_valid valid))],
d844 1
a844 3
             (case prim of
                Pervasives.NOT => notcode()
              | _ => LambdaTypes.BUILTIN prim, Option.ABSENT)
d847 1
a847 1
                             [LambdaTypes.SCON(Ident.STRING(str_from_valid valid))],
a911 6
  (* This function applies lambda abstraction to the situation of
     let value-names = expressions in exp end, for example in the
     translation of let .. in .. end, and also in structure
     completion. There are arguments for having a bit of lambda calculus
     explicitly for this situation (see Peyton-Jones 3.2.4) *)

d984 2
a985 3
    (if coerce then diagnose("coercing") else ();
    (* this should be replaced with a call to diagnose *)
    if not(coerce) andalso compare_sig_env generate_moduler (interface, env) then
d1066 1
a1066 2
	      val _ = diagnose
			("coercing " ^ IdentPrint.debug_printValId valid)
d1095 1
a1095 1
		  (Option.SOME1 lv,
d1100 1
a1100 1
                LambdaTypes.LETB(Option.SOME1(lv),coerce (valid,LambdaTypes.BUILTIN prim),"")
d1110 1
a1110 1
		  (Option.SOME1(lv), 
d1113 1
a1113 1
			(Option.SOME1(lv'),
d1132 1
a1132 1
    end)
d1175 1
a1175 1
	     LambdaTypes.do_binding(LambdaTypes.LETB(Option.SOME1(new_lv),
d1188 1
d1209 1
a1209 2
      (* nosa 02/94
         Candidates for redundant exception patterns, and Dynamic redundancy code generator *)
d1221 1
a1221 1
      val debug_somevariables =
d1224 6
a1229 17
      fun substring (str1,str2) =
        let
          val str1 = explode str1
          val str2 = explode str2
          fun tl xs = 
            Lists.tl xs
            handle Lists.Tl => nil
          fun substring (nil,_,_) = true
            | substring (_,nil,_) = false
            | substring (x::xs,y::ys,yys) =
              if x = y then substring (xs,ys,yys)
              else substring(str1,yys,tl yys)
        in
          substring (str1,str2,tl str2)
        end
      val new_lvar = 
        if debug_polyvariables then fn _ => LambdaTypes.new_LVar()
d1231 4
a1234 1
      val dummy_instance = ref(Datatypes.NULLTYPE,Datatypes.Option.ABSENT,nil)
d1240 53
a1292 47
              case instance of
                Datatypes.Option.PRESENT(ref(Datatypes.INSTANCE(instance))) => 
                  let
                    val (name,location,ty) = 
                      case debug_info of
                        Option.PRESENT(name,ref(ty,_,_),_) => 
                          ("instance of "^name,"["^location^"]",ty)
                      | _ => Crash.impossible "1:make_binding:trans_dec"
                    val tyvar = LambdaTypes.new_LVar()
                    val new_bound_tyvar_slot = 
                      Option.PRESENT(ref (Option.SOME1(0)))
                  in
                    LambdaTypes.FN([tyvar],
                      let
                        fun debugger_application (Datatypes.FUNTYPE(_,ty)) app ct = 
                          let
                            val new_bound_tyvar_slot = 
                               Option.PRESENT(ref (Option.SOME1(0)))
                            val arg = LambdaTypes.new_LVar()
                            val result = LambdaTypes.new_LVar()
                          in
                            LambdaTypes.FN([arg],
                             LambdaTypes.LET(Option.SOME2(ref(0,
                               Option.PRESENT("tyvar for "^name,
                               dummy_instance,new_bound_tyvar_slot))),
                             LambdaTypes.VAR(tyvar),
                             LambdaTypes.LET(Option.SOME1(result),
                                             LambdaTypes.APP(app,[LambdaTypes.VAR(arg)],
                                                             Option.ABSENT),
                                             debugger_application (Types.the_type(ty))
                                             (LambdaTypes.VAR(result)) (ct+1))), 
                             name^" argument "^MLWorks.Integer.makestring(ct)^location,
                             Datatypes.NULLTYPE,
                             Option.PRESENT(instance,new_bound_tyvar_slot))
                          end
                          | debugger_application _ app _ = app
                      in
                        LambdaTypes.LET(Option.SOME2(ref(0,
                               Option.PRESENT("tyvar for "^name,
                               dummy_instance,new_bound_tyvar_slot))),
                             LambdaTypes.VAR(tyvar),
                        debugger_application (Types.the_type(ty)) lexp 1)
                      end,
                    name^location,Datatypes.NULLTYPE,
                             Option.PRESENT(instance,new_bound_tyvar_slot))
                  end
              | _ => lexp
d1295 1
a1295 4
      val stepper_lvar =
        if generate_stepper orelse generate_stepper_specific <> "" then LambdaTypes.new_LVar
        else fn _ => 0
   
d1298 5
a1302 9
       if generate_stepper orelse generate_stepper_specific <> "" then 
         (cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                       Ident.VAR(Symbol.find_symbol("step function"))),env),
          cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                       Ident.VAR(Symbol.find_symbol("breakpoint function"))),env),
          cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                       Ident.VAR(Symbol.find_symbol("breakpoint_on_exit function"))),env),
          cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                                       Ident.VAR(Symbol.find_symbol("step handler function"))),env),
d1309 1
a1309 3
                cg_longvalid(Ident.LONGVALID(Ident.PATH(Symbol.find_symbol "MLWorks",
                      Ident.PATH(Symbol.find_symbol "Debugger",Ident.NOPATH)),
                                     Ident.VAR(Symbol.find_symbol "step")),env)
d1319 2
a1320 1
                                                  Option.ABSENT),"step function",
d1332 18
a1349 15
                   LambdaTypes.FN([fnname],
                                  LambdaTypes.FN([exn],
                                   LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
                                   LambdaTypes.APP(LambdaTypes.VAR step_lvar,
                                                   [LambdaTypes.STRUCT[LambdaTypes.VAR(fnname),
                                                                       LambdaTypes.STRUCT[LambdaTypes.INT(1),
                                                                                          LambdaTypes.VAR(exn)]]],
                                                   Option.ABSENT),
                                  LambdaTypes.RAISE(LambdaTypes.VAR(exn))),
                                   "Debugger exception handler",
                                   Datatypes.NULLTYPE,
                                   Option.ABSENT),
                                  "step handler",
                                  Datatypes.NULLTYPE,
                                  Option.ABSENT)
d1354 1
a1354 3
                cg_longvalid(Ident.LONGVALID(Ident.PATH(Symbol.find_symbol "MLWorks",
                             Ident.PATH(Symbol.find_symbol "Debugger",Ident.NOPATH)),
                                     Ident.VAR(Symbol.find_symbol "breakpoint")),env)
d1356 1
a1356 3
                cg_longvalid(Ident.LONGVALID(Ident.PATH(Symbol.find_symbol "MLWorks",
                             Ident.PATH(Symbol.find_symbol "Debugger",Ident.NOPATH)),
                                     Ident.VAR(Symbol.find_symbol "breakpoint_on_exit")),env)
d1387 2
a1388 2
               [LambdaTypes.LETB(Option.SOME1(step_lvar),step_fn,"step function"),
                LambdaTypes.LETB(Option.SOME1(breakpoint_lvar),breakpoint_fun,
d1390 1
a1390 1
                LambdaTypes.LETB(Option.SOME1(breakpoint_on_exit_lvar),breakpoint_on_exit_fun,
d1392 1
a1392 1
                LambdaTypes.LETB(Option.SOME1(step_handler_lvar),step_handler_fn,
d1397 13
a1409 9
                 Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(env,
                                            (Ident.VAR(Ident.Symbol.find_symbol("step function")),
                                             EnvironTypes.LAMB(step_lvar,Option.ABSENT))),
                                            (Ident.VAR(Ident.Symbol.find_symbol("breakpoint function")),
                                             EnvironTypes.LAMB(breakpoint_lvar,Option.ABSENT))),
                                            (Ident.VAR(Ident.Symbol.find_symbol("breakpoint_on_exit function")),
                                             EnvironTypes.LAMB(breakpoint_on_exit_lvar,Option.ABSENT))),
                                            (Ident.VAR(Ident.Symbol.find_symbol("step handler function")),
                                             EnvironTypes.LAMB(step_handler_lvar,Option.ABSENT))))
d1415 2
a1416 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1420 1
a1420 1
                 [LambdaTypes.LETB(Option.SOME1(LambdaTypes.new_LVar()),
d1428 7
d1437 1
a1437 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1439 2
a1440 5
            if substring(generate_stepper_specific,fnname) then
              if ((String.substring(name,0,4) <> "<if>" andalso
                   String.substring(name,0,5) <> "<seq>" andalso
                   String.substring(name,0,6) <> "<case>")
                  handle String.Substring => true) then
a1445 2
            else
              lexp
d1450 1
a1450 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1452 2
a1453 5
            if substring(generate_stepper_specific,fnname) then
              if ((String.substring(name,0,4) <> "<if>" andalso
                   String.substring(name,0,5) <> "<seq>" andalso
                   String.substring(name,0,6) <> "<case>")
                  handle String.Substring => true) then
d1455 1
a1455 1
                LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
a1458 2
              else
                fn lexp => lexp
d1465 1
a1465 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1469 1
a1469 1
              LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
d1479 1
a1479 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1482 1
a1482 1
              LambdaTypes.LET(Option.SOME1(fnname_lv),
d1491 1
a1491 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1494 1
a1494 1
                                   ref(ty,Option.ABSENT,[]),Option.ABSENT)
d1499 2
a1500 11
      val filter_name =
        if generate_stepper orelse generate_stepper_specific <> "" then
          fn (name_string,fnname) => 
          if ((String.substring(name_string,0,4) = "<if>" orelse
               String.substring(name_string,0,5) = "<seq>" orelse
               String.substring(name_string,0,6) = "<case>" orelse
               String.substring(name_string,0,8) = "<handle>")
            handle String.Substring => false) then fnname
          else name_string
        else
          fn (name_string,_) => name_string
d1503 1
a1503 1
        if generate_stepper orelse generate_stepper_specific <> "" then
d1866 26
a1891 30
                 LambdaTypes.FN([args],
                         LambdaTypes.LET(Option.SOME1(new_cg),LambdaTypes.SELECT({index=0,size=3},
                                                                                 LambdaTypes.VAR(args)),
                          LambdaTypes.LET(Option.SOME1(dexp'),
                                          LambdaTypes.SELECT({index=1,size=3},LambdaTypes.VAR(args)),
                           LambdaTypes.LET(Option.SOME1(instance'),
                                           LambdaTypes.SELECT({index=2,size=3},LambdaTypes.VAR(args)),
                            LambdaTypes.LET(Option.SOME1(lvar),
                              LambdaTypes.VAR(dexp'),
                              LambdaTypes.SWITCH(LambdaTypes.VAR(lvar),
                                            Option.PRESENT{lv=LambdaTypes.new_LVar(),
                                                                       num_vccs=1,num_imms=1},
                                            [(LambdaTypes.IMM_TAG("ABSENT",0), 
                                              LambdaTypes.VAR(new_cg)),
                                             (LambdaTypes.VCC_TAG("PRESENT",1),
                                              LambdaTypes.APP(LambdaTypes.VAR(new_cg),
                                               [let
                                                  val lexp = LambdaTypes.SELECT({index=1,size=2},
                                                                                 LambdaTypes.VAR(lvar))
                                                in
                                                  LambdaTypes.SWITCH(LambdaTypes.VAR(instance'),
                                                  Option.ABSENT,
                                                  [(LambdaTypes.SCON_TAG(Ident.INT("~1",Location.UNKNOWN)),
                                                     LambdaTypes.STRUCT[LambdaTypes.INT 0, lexp])],
                                                   Option.PRESENT(LambdaTypes.STRUCT[LambdaTypes.INT 1,
                                                         LambdaTypes.STRUCT[lexp,
                                                                            LambdaTypes.VAR(instance')]]))
                                                end],
                                              Option.ABSENT))],Option.ABSENT))))),
                         "overload function",Datatypes.NULLTYPE,Option.ABSENT)
d1894 1
a1894 1
                [LambdaTypes.LETB(Option.SOME1(lv),lexp,"overload function binding")],
d1926 1
a1926 1
                                                                                                 MLWorks.Integer.makestring ct))),env)],
d1942 1
a1942 1
                                                                ^MLWorks.Integer.makestring ct))),env)],
d1964 3
a1966 3
               Datatypes.Option.ABSENT => new_cg
             | Datatypes.Option.PRESENT(ref(Datatypes.NO_INSTANCE)) => new_cg
             | Datatypes.Option.PRESENT(_) =>
d2094 1
a2094 1
                    Ident.VAR(Symbol.find_symbol("functor app ref "^MLWorks.Integer.makestring ct))),env)],
d2267 1
a2267 1
          (LambdaTypes.LET(Option.SOME1(lvar),
d2315 1
a2315 1
            (LambdaTypes.LET(Option.SOME1(lvar),
d2370 1
a2370 1
        : (Datatypes.Tyfun ref * (int,int) Option.option ref * LambdaTypes.LambdaExp) list ref = ref []
d2458 1
a2458 1
      fun null_tyfun_spills denv (Datatypes.Option.PRESENT(name,Ty as ref(ty,i,_),_)) location = 
d2463 1
a2463 1
            map (fn (tf,dexp)=>(tf,ref(Datatypes.Option.SOME1(0)),dexp))
d2466 1
a2466 1
          (Ty := (ty,i,map (fn (tf,spill,_)=>(tf,spill)) spills);
d2469 1
a2469 1
        | null_tyfun_spills _ Datatypes.Option.ABSENT _ = ()
d2480 3
a2482 3
               LambdaTypes.LETB(Option.SOME2(ref(0,
                                  Option.PRESENT("null_tyfun_spill",
                                                  dummy_instance,Option.PRESENT(spill)))),
d2535 1
a2535 1
                   LambdaTypes.LETB(Option.SOME1(tyfun_lvar),
d2571 1
a2571 1
                   LambdaTypes.LETB(Option.SOME1(tyfun_lvar),
d2593 1
a2593 1
        if debug_somevariables then 
d2596 1
a2596 1
            [LambdaTypes.LETB(Option.SOME2(ref(lv,debug_info)),
d2599 1
a2599 1
             LambdaTypes.LETB(Option.SOME1(lv'),
d2605 1
a2605 1
            [LambdaTypes.LETB(Option.SOME2(ref(lv,debug_info)),
d2610 1
a2610 1
          [LambdaTypes.LETB(Option.SOME1(lv),
d2615 2
a2616 2
        if generate_stepper orelse generate_stepper_specific <> "" then
          fn (lexp,debug_info as Option.PRESENT(_,ref(ty,_,_),_),(name,fnname,fnname_lv)) =>
d2620 2
a2621 5
              if substring(generate_stepper_specific,fnname) then
                if ((String.substring(name,0,4) <> "<if>" andalso
                     String.substring(name,0,5) <> "<seq>" andalso
                     String.substring(name,0,6) <> "<case>")
                    handle String.Substring => true) then 
a2629 2
                else
                  lexp
a2635 5
      fun valid_to_string (Ident.VAR(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.CON(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.EXCON(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string _ = Crash.impossible "TYCON':valid_to_string:lambda"

d2693 4
a2696 3
                           diagnose
			     ("Overloaded operator " ^ sy_name ^
                                " instantiated to  " ^ sy_name' ^ "\n");
d2778 1
a2778 1
                               not(is_list_type (Type_Utils.get_cons_type ty))
d2841 1
a2841 1
                                        LambdaTypes.LETB(Option.SOME1(lv), le,
a2848 4
          (** Local expressions are tough, so we code up the declaration, and
              then use a series of FN APPs to bind names the the pieces
                returned, and then generate for the exp passed. *)

a2851 2
        (** generate Lambda code to bind the names to the values, and then
         call the code generated by transforming the expression.  **)
d2914 2
a2915 4
               Option.PRESENT {lv = LambdaTypes.new_LVar(),
                                    num_imms = 1,
                                    num_vccs = 0},
               [(LambdaTypes.IMM_TAG (MLWorks.Integer.makestring tag,tag), true_val)],
d2921 1
a2921 2
                LambdaTypes.LET(Option.SOME1(var),
                                arg,body)
d2948 1
a2948 1
                             if !show_match then
d2997 1
a2997 1
          (if !show_match then
d3127 1
a3127 2
              LambdaUtils.add_match_env((root, Option.SOME1(root_lambda)),
                                        LambdaUtils.empty_match_env)
d3130 2
a3131 1
            val fnname_lv = stepper_lvar()
d3143 1
a3143 4
                      cg_longvalid(Ident.LONGVALID(Ident.PATH(Symbol.find_symbol "MLWorks",
                                                              Ident.PATH(Symbol.find_symbol "IO",
                                                                         Ident.NOPATH)),
                      Ident.VAR(Symbol.find_symbol "output")),env)
d3145 1
a3145 4
                      cg_longvalid(Ident.LONGVALID(Ident.PATH(Symbol.find_symbol "MLWorks",
                                                              Ident.PATH(Symbol.find_symbol "IO",
                                                                         Ident.NOPATH)),
                      Ident.VAR(Symbol.find_symbol "std_out")),env)
d3152 1
a3152 1
                       LambdaTypes.LETB(Option.SOME1(lvar),
d3179 1
a3179 3
                            Option.PRESENT {lv = LambdaTypes.new_LVar(),
                                                        num_imms = 2,
                                                        num_vccs = 0},
d3231 1
a3231 3
                                             Option.PRESENT {lv = LambdaTypes.new_LVar(),
                                                                         num_imms = 2,
                                                                         num_vccs = 0},
d3237 1
a3237 3
                                             Option.PRESENT {lv = LambdaTypes.new_LVar(),
                                                                         num_imms = 2,
                                                                         num_vccs = 0},
d3244 1
a3244 1
                      LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
d3246 1
a3246 3
                        Option.PRESENT {lv = LambdaTypes.new_LVar(),
                                                    num_imms = 2,
                                                    num_vccs = 0},
d3251 1
a3251 1
                             LambdaTypes.SCON(Ident.STRING(implode("\n"::" "::" "::"-"::">"::
d3275 1
a3275 1
                   (LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
d3277 1
a3277 1
                                       Option.SOME1(redundant_clauses_lambda),
d3279 1
a3279 1
                                                        [LambdaTypes.SCON(Ident.INT(MLWorks.Integer.makestring number_of_clauses,
d3305 1
a3305 1
                               name_string ^ "<Match"^ MLWorks.Integer.makestring(new_match_trans()) ^ ">"
d3307 3
a3309 1
                               append_name(name_string,fnname) ^ "<Match"^ MLWorks.Integer.makestring(new_match_trans()) ^ ">"
d3313 1
a3313 1
                           (Option.SOME1(lv),
d3337 1
a3337 1
                               name_string ^ "<Match"^ MLWorks.Integer.makestring(new_match_trans()) ^ ">"
d3339 1
a3339 1
                               append_name(name_string,fnname) ^ "<Match"^ MLWorks.Integer.makestring(new_match_trans()) ^ ">"
d3343 1
a3343 1
                           (Option.SOME1(lv),
d3354 1
a3354 1
                                        LambdaTypes.LET(Option.SOME1(lvar),lexp,
d3356 3
a3358 2
                                                 LambdaUtils.add_match_env((matchvar,Option.SOME1(lvar)),
                                                                           match_env),
d3404 1
a3404 1
                      | do_leaf((mv, valid, ty as ref ty') :: tl, env, denv) =
d3406 2
a3407 2
                            Option.SOME1(lv) => 
                             if debug_somevariables then
d3418 1
a3418 2
                                      LambdaTypes.LET(Option.SOME2(ref(dummylv,
                                                                                   debug_info)),
d3434 1
a3434 1
                          | Option.SOME2(lvar as ref(lv,_)) => 
d3438 1
a3438 2
                                   (lvar := (lv,Option.PRESENT
                                         (Symbol.symbol_name symbol,ty,Option.ABSENT));
d3440 4
a3443 7
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))),
                                             add_valid_denv(denv, (valid,
                                                                EnvironTypes.NULLEXP))))
                               | _ => do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))),
                                             add_valid_denv(denv, (valid,
                                                                EnvironTypes.NULLEXP))))
d3455 1
a3455 2
	                 LambdaTypes.VAR(LambdaTypes.fetch_var(
                                         LambdaUtils.lookup_match(mv, match_env))),
d3478 1
a3478 1
	  val orig_lv = LambdaTypes.fetch_var ORIG_LV
d3525 1
a3525 1
	      (LambdaTypes.VCC_TAG(valid_to_string valid,#2(constructor_tag(valid, ty))),
d3545 4
a3548 8
                  val new_lv = 
                    if debug_somevariables then 
                      if generate_moduler then
                        Option.SOME1(new_lv)
                      else
                        Option.SOME2(ref(new_lv,Option.ABSENT))
                    else 
                      Option.SOME1(new_lv)
d3550 1
a3550 1
	         (LambdaTypes.LETB(new_lv, new_le, "match translation"),
d3552 1
a3552 1
		            LambdaUtils.add_match_env((mv, new_lv), match_env),
d3556 1
a3556 1
	      (LambdaTypes.IMM_TAG(valid_to_string valid,#2(constructor_tag(valid, ty))),
d3580 5
a3584 9
                          val ref_lv = 
                            if debug_somevariables then  
                              if generate_moduler then
                                Option.SOME1(LambdaTypes.new_LVar ())
                              else
                                Option.SOME2(ref(LambdaTypes.new_LVar (),
                                                             Option.ABSENT))
                            else
                              Option.SOME1(LambdaTypes.new_LVar ())
d3587 1
a3587 1
                            LambdaTypes.LETB(ref_lv,
d3593 2
a3594 2
			              LambdaUtils.add_match_env((mv, ref_lv),
			                                       match_env),
a3625 1
		      lv = LambdaTypes.new_LVar(),
d3650 4
a3653 8
              val new_lv = 
                if debug_somevariables then
                  if generate_moduler then
                    Option.SOME1(new_lv)
                  else
                    Option.SOME2(ref(new_lv,Option.ABSENT))
                else
                  Option.SOME1(new_lv)
d3655 18
a3672 19
	      let_lambdas_in_exp(
		[LambdaTypes.LETB(new_lv, new_le, "")],
                 let
                   val old_null_tyfun_spills = store_null_tyfun_spills()
                 in
	        LambdaTypes.SWITCH(
		  select_exn_unique con_field,
		  Option.PRESENT{lv = LambdaTypes.new_LVar(),
				      num_vccs = 0,
				      num_imms = 0},
                      map (fn (longvalid, mv, tree) =>
		         (LambdaTypes.EXP_TAG(
			    select_exn_unique(#1(cg_longexid(longvalid, val_env)))),
		            (init_null_tyfun_spills();
                             make_null_tyfun_spills(tr_match'(tree,
			             LambdaUtils.add_match_env((mv, new_lv),
		                                               match_env),
                                      val_env)))))
		       vcc_lv_list,
d3679 1
a3679 1
            end)
d3687 1
a3687 3
                  Option.PRESENT{lv = LambdaTypes.new_LVar(),
                                             num_vccs = 0,
                                             num_imms = 0},
d3714 1
a3714 1
            if debug_somevariables then 
d3717 1
a3717 1
                   Option.SOME1(LambdaTypes.new_LVar())
d3719 1
a3719 3
                   Option.SOME2(ref(LambdaTypes.new_LVar(),
                                             Option.ABSENT))
                                ))
d3722 2
a3723 2
              map (fn (x,y) => (x, y,
                                Option.SOME1(LambdaTypes.new_LVar())))
d3725 1
a3725 7
	  val le = LambdaTypes.VAR(LambdaTypes.fetch_var(
                                    LambdaUtils.lookup_match(mv, match_env)))
(*
	  val new_env = Lists.reducer LambdaUtils.add_match_env
            (map (fn (_, x, y) => (x, y)) lab_mv_lv_list, match_env)
	    There seems to be no reason for using reducer here
*)
d3730 2
a3731 2
	    map (fn (lab, _, lv) =>
		 LambdaTypes.LETB(lv,
d3801 3
a3803 8
              
            fun trans_individual_dec(pattern, (lambda_var,lambda_var'), location):
             bool * bool * EnvironTypes.Env * EnvironTypes.DebuggerEnv * LambdaTypes.binding list
              * (string * (LambdaTypes.Type * LambdaTypes.Instance ref Datatypes.Option.opt
                   * (LambdaTypes.Tyfun ref * (int,int) Option.option ref) list) ref 
                 * (int,int) Option.option ref 
             Option.opt) Option.opt 
              * Datatypes.Instance ref Datatypes.Option.opt =
a3807 2
	    (* The above lambda is a dummy, and will not be referenced *)
	    (* in this case. No additional environment generated *)
a3808 11
                (* This comes about for instance in cases like val (1,x) = y *)
                (* or even val 1 = 1 (rather stupid!) *)
                (* We translate it effectively to *)
                (* dummy_lambda = if scon = exp then exp else raise(bind) *)
                (* We further abstract out exp in order to avoid *)
                (* recalculating it, vis *)
                (* dummy_lambda = let dummy_lambda' = exp *)
                (* in if scon = dummy_lambda' then dummy_lambda' *)
                (* else raise(bind) end *)
                (* We also cheat slightly, treating it as two *)
                (* separate declarations *)
d3813 2
a3814 4
                   [LambdaTypes.LETB(
                                     Option.SOME1(dummy_lv),
                                     LambdaTypes.SWITCH(
                                                        LambdaTypes.VAR lambda_var,
d3824 1
a3824 1
                             Ty as ref (ty,instance,_)),_) =>
d3834 1
a3834 1
                                                        Ty,Option.ABSENT),
d3846 1
a3846 1
                            Option.SOME1(dummy_lv),
a3849 1
                                    lv = lambda_var,	(* dummy_value *)
d3852 1
a3852 1
                                    [(LambdaTypes.IMM_TAG (valid_to_string valid,tag), 
d3866 1
a3866 1
                                          Option.SOME1(dummy_lv),
d3869 3
a3871 5
                                                             Option.PRESENT{
                                                              lv = LambdaTypes.new_LVar(),
                                                                                 num_imms = 0,
                                                                                 num_vccs = 0
                                                                                 },
d3893 1
a3893 1
                       val lv' = new_lvar lv
d3931 1
a3931 1
                         val new_lv' = new_lvar new_lv
d3951 1
a3951 1
                           val new_lv' = new_lvar new_lv
a3959 1
                                                lv = LambdaTypes.new_LVar(),
d3963 1
a3963 1
                                   [(LambdaTypes.VCC_TAG (valid_to_string valid,tag),
d3985 1
a3985 1
                       val new_lv' = new_lvar new_lv
d3992 3
a3994 5
                                                     Option.PRESENT{
                                                                  lv = LambdaTypes.new_LVar(),
                                                                                num_imms = 0,
                                                                                num_vccs = 0
                                                                                },
d4012 1
a4012 1
            | Absyn.LAYEREDpat((valid, Ty as ref (ty,instance,_)), pat) =>
d4022 1
a4022 2
                        lambda,Option.PRESENT(Symbol.symbol_name vid,
                                                          Ty,Option.ABSENT),
d4032 1
a4032 1
                  val lvar' = new_lvar lvar
d4052 8
a4059 9
                  val (more_env, more_denv, updated) = case (pat, lambda) of
                    (Absyn.VALpat((Ident.LONGVALID(Ident.NOPATH,valid as Ident.VAR _), _),_),
                     LambdaTypes.BUILTIN prim) =>
                    (Environ.add_valid_env(more_env, (valid,
                                                      EnvironTypes.PRIM prim)),
                     add_valid_denv(more_denv, (valid,
                                                      EnvironTypes.NULLEXP)),
                     true)
                   | _ => (more_env, more_denv, false)
d4061 1
a4061 1
                  val _ = map (fn LambdaTypes.LETB(Option.SOME2(ref(_,debug_info)),_,_) =>
d4082 11
a4092 11
                    if debug_somevariables then 
                      map
                    (fn (pat, exp, location) => 
                     let
                       val new_lv = LambdaTypes.new_LVar()
                     in
                       (Option.SOME2(ref(new_lv,
                                                     Option.ABSENT)),
                        Option.SOME1(new_lvar new_lv), pat, exp, location)
                     end)
                    rec_list
d4095 7
a4101 7
                    (fn (pat, exp, location) =>  
                     let
                       val new_lv = Option.SOME1(LambdaTypes.new_LVar())
                     in
                     (new_lv, new_lv, pat, exp, location)
                     end)
                    rec_list
d4104 2
a4105 2
                    (fn (Option.SOME2(lv' as ref(lv,_)), 
                         Option.SOME1(lv''), pat, _, location) =>
d4111 1
a4111 1
                         (lv' := (lv,debug_info);
d4124 1
a4124 1
                  | (Option.SOME1(lv), _, pat, _, location) =>
d4151 2
a4152 7
                  fun valid_name(Ident.VAR sy) = sy
                    | valid_name(Ident.CON sy) = sy
                    | valid_name(Ident.EXCON sy) = sy
                    | valid_name _ = Crash.impossible "TYCON':valid_name:lambda"
                  fun pat_name(Absyn.VALpat((Ident.LONGVALID(_, valid), _),_)) =
                    Symbol.symbol_name(valid_name valid)
                    | pat_name(Absyn.WILDpat) = " WILD"
d4155 2
a4156 2
                         " WILD" => Symbol.symbol_name(valid_name valid)
                       | x => x)
d4162 29
a4190 28
                      [LambdaTypes.RECLETB(
                      Lists.reducer
                      (fn ((((pat,exp,_),(_,_,lv'',debug_info,instance,location)),
                            (lv,lv',_,_,_)),
                           (bds,exp_list)) =>
                       let
                         val lexp = trans_exp(pat_name pat, exp, trans_env, trans_denv, fnname)
                       in
                           case
                            (case lexp of
                               LambdaTypes.FN(_,_,name,_,_) => 
                                 make_binding(debug_info,instance,LambdaTypes.VAR(lv''),location)
                             | _ => Crash.impossible 
                                      "debug_polyvariables:recletb:trans_dec:lambda") of
                               lexp' as LambdaTypes.FN(_) => 
                                 (lv :: lv' :: bds,
                                  lexp :: lexp' :: exp_list)
                             | _ => 
                                ((case (lv,lv') of
                                    (Option.SOME2(lv as ref(_,info)),
                                     Option.SOME1(lv')) => 
                                      lv := (lv',info)
                                   | _ => Crash.impossible 
                                           "debug_polyvariables:recletb:trans_dec:lambda");
                                 (lv :: bds,
                                  lexp :: exp_list))
                       end)
                      (Lists.zip(Lists.zip(rec_list,env_le_list),lv_pat_exp_list),(nil,nil)))]
d4222 3
a4224 3
                              ref (ty,Option.ABSENT,nil)),Location.UNKNOWN),
                 Absyn.VALexp(Ident.LONGVALID(Ident.NOPATH, valid), ref
                              ty, Location.UNKNOWN,ref(nil,Absyn.Option.ABSENT)),
d4319 1
a4319 1
		([LambdaTypes.LETB(Option.SOME1(lv), lambda_exp,
d4414 1
a4414 1
		LambdaTypes.LETB(Option.SOME1(l), LambdaTypes.SELECT(field, lambda_exp),"")
d4416 1
a4416 1
                 LambdaTypes.LETB(Option.SOME1(l),
d4425 1
a4425 1
		LambdaTypes.LETB(Option.SOME1(l), LambdaTypes.SELECT(field, lambda_exp),"")
d4427 1
a4427 1
                 LambdaTypes.LETB(Option.SOME1(l), LambdaTypes.BUILTIN prim,"")
d4477 1
a4477 1
               LambdaTypes.LETB(Option.SOME1(lvar),
d4481 1
a4481 1
               LambdaTypes.LETB(Option.SOME1(lvar),
d4485 1
a4485 1
                    LambdaTypes.LETB(Option.SOME1(lvar),
d4496 1
a4496 1
            LambdaTypes.LETB(Option.SOME1(LambdaTypes.new_LVar()),
d4558 1
a4558 1
                                    LambdaTypes.LETB(Option.SOME1(lv),
d4656 1
a4656 1
            LambdaTypes.LETB(Option.SOME1(lambda_var), lambda_exp,"") 
d4694 1
a4694 1
            LambdaTypes.LETB(Option.SOME1(lambda_var), lambda_exp,"") 
d4793 1
a4793 1
         LambdaTypes.LET(Option.SOME1(lvar'),
d4796 1
a4796 1
            LambdaTypes.LET(Option.SOME1(lvar''),
d4799 1
a4799 1
            LambdaTypes.LET(Option.SOME1(lvar'''),
d4804 1
a4804 1
                                    LambdaTypes.LETB(Option.SOME1(lv),
d4812 1
a4812 1
                              LambdaTypes.LET(Option.SOME1(lambda_var'),
d4814 1
a4814 1
                              LambdaTypes.LET(Option.SOME1(LambdaTypes.new_LVar()),
d4830 1
a4830 1
       [LambdaTypes.LETB(Option.SOME1(lambda_var),
d4885 8
a4892 6
    map (fn (ref(Option.SOME1(lv)),interface) => LambdaTypes.LETB(Option.SOME1(lv),
                                                   LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                                   [str_to_lambda interface],
                                                                   Option.ABSENT),
                                                   "functor app ref")
          | _ => Crash.impossible "3:SOME2:functor_refs:lambda") (!functor_refs) @@ c
d4900 1
a4900 1
                         (Ident.VAR(Symbol.find_symbol("functor app ref "^MLWorks.Integer.makestring ct)),
@


1.160
log
@Change name of default functions
@
text
@d4 3
d2810 17
a2826 6
                              if location = "" then
			        ("constructor " ^ Symbol.symbol_name symbol)
                              else
				("constructor " ^ Symbol.symbol_name symbol ^
				 " from datatype in " ^ location),
                                LambdaTypes.null_type_annotation,Option.ABSENT)
@


1.159
log
@Functions and applications take a list of parameters
@
text
@d4 3
d3341 1
a3341 3
                               "Part of match translation ("
                               ^MLWorks.Integer.makestring(new_match_trans())
                               ^") " ^ name_string
d3343 1
a3343 3
                               append_name("Part of match translation ("
                                           ^MLWorks.Integer.makestring(new_match_trans())
                                           ^") " ^ name_string,fnname)
d3371 1
a3371 3
                               "Part of match translation ("
                               ^MLWorks.Integer.makestring(new_match_trans())
                               ^") " ^ name_string
d3373 1
a3373 3
                               append_name("Part of match translation ("
                                           ^MLWorks.Integer.makestring(new_match_trans())
                                           ^") " ^ name_string,fnname)
@


1.158
log
@Simplified selection of overloaded primitives.
@
text
@d4 3
d589 1
a589 1
    LambdaTypes.FN(l,
d592 1
a592 1
	LambdaTypes.Option.PRESENT {lv = l (* dummy_value *),
d597 1
a597 1
	LambdaTypes.Option.ABSENT),
d599 1
a599 1
      LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT)
d607 2
a608 2
      LambdaTypes.FN(l, LambdaTypes.VAR l, "identity",
		     LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT)
d746 2
a747 2
	    LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
	    LambdaTypes.Option.ABSENT))
d762 2
a763 2
	    LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
	    LambdaTypes.Option.ABSENT), Option.ABSENT, generate_moduler)
d801 2
a802 3
			   LambdaTypes.SCON(Ident.STRING(str_from_valid
							 valid)),
			   LambdaTypes.Option.ABSENT)
d829 2
a830 3
                             LambdaTypes.SCON(Ident.STRING(str_from_valid
                                                           valid)),
                             LambdaTypes.Option.ABSENT), Option.ABSENT)
d858 4
a861 2
	       LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
	     LambdaTypes.Option.ABSENT), Option.ABSENT, generate_moduler)
d1067 1
a1067 1
                  LambdaTypes.FN(lv,
d1070 1
a1070 1
                                 LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT)
d1085 1
a1085 1
		  (LambdaTypes.Option.SOME1(lv),
d1090 1
a1090 1
                LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),coerce (valid,LambdaTypes.BUILTIN prim),"")
d1100 1
a1100 1
		  (LambdaTypes.Option.SOME1(lv), 
d1103 1
a1103 1
			(LambdaTypes.Option.SOME1(lv'),
d1155 2
a1156 2
      LambdaTypes.Option.ABSENT => result
    | LambdaTypes.Option.PRESENT inte =>
d1165 1
a1165 1
	     LambdaTypes.do_binding(LambdaTypes.LETB(LambdaTypes.Option.SOME1(new_lv),
d1180 1
a1180 1
    : ((LambdaTypes.LVar,int) LambdaTypes.Option.option ref * LambdaTypes.Structure) list ref = ref []
d1243 1
a1243 1
                        LambdaTypes.Option.PRESENT(name,ref(ty,_,_),_) => 
d1248 1
a1248 1
                      LambdaTypes.Option.PRESENT(ref (LambdaTypes.Option.SOME1(0)))
d1250 1
a1250 1
                    LambdaTypes.FN(tyvar,
d1255 1
a1255 1
                               LambdaTypes.Option.PRESENT(ref (LambdaTypes.Option.SOME1(0)))
d1259 3
a1261 3
                            LambdaTypes.FN(arg,
                             LambdaTypes.LET(LambdaTypes.Option.SOME2(ref(0,
                               LambdaTypes.Option.PRESENT("tyvar for "^name,
d1264 3
a1266 3
                             LambdaTypes.LET(LambdaTypes.Option.SOME1(result),
                                             LambdaTypes.APP(app,LambdaTypes.VAR(arg),
                                                             LambdaTypes.Option.ABSENT),
d1271 1
a1271 1
                             LambdaTypes.Option.PRESENT(instance,new_bound_tyvar_slot))
d1275 2
a1276 2
                        LambdaTypes.LET(LambdaTypes.Option.SOME2(ref(0,
                               LambdaTypes.Option.PRESENT("tyvar for "^name,
d1282 1
a1282 1
                             LambdaTypes.Option.PRESENT(instance,new_bound_tyvar_slot))
d1317 1
a1317 1
                   LambdaTypes.FN(fnname,
d1319 2
a1320 2
                                                  LambdaTypes.VAR(fnname),
                                                  LambdaTypes.Option.ABSENT),"step function",
d1322 1
a1322 1
                                  LambdaTypes.Option.ABSENT)
d1332 8
a1339 8
                   LambdaTypes.FN(fnname,
                                  LambdaTypes.FN(exn,
                                   LambdaTypes.LET(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
                                   LambdaTypes.APP(LambdaTypes.VAR(step_lvar),
                                    LambdaTypes.STRUCT[LambdaTypes.VAR(fnname),
                                       LambdaTypes.STRUCT[LambdaTypes.INT(1),
                                                          LambdaTypes.VAR(exn)]],
                                                  LambdaTypes.Option.ABSENT),
d1343 1
a1343 1
                                   LambdaTypes.Option.ABSENT),
d1346 1
a1346 1
                                  LambdaTypes.Option.ABSENT)
d1364 1
a1364 1
                   LambdaTypes.FN(fnname,
d1366 2
a1367 2
                                                  LambdaTypes.VAR(fnname),
                                                  LambdaTypes.Option.ABSENT),"breakpoint function",
d1369 1
a1369 1
                                  LambdaTypes.Option.ABSENT)
d1376 1
a1376 1
                   LambdaTypes.FN(fnname,
d1378 2
a1379 2
                                                  LambdaTypes.VAR(fnname),
                                                  LambdaTypes.Option.ABSENT),"breakpoint function_on_exit",
d1381 1
a1381 1
                                  LambdaTypes.Option.ABSENT)
d1388 2
a1389 2
               [LambdaTypes.LETB(LambdaTypes.Option.SOME1(step_lvar),step_fn,"step function"),
                LambdaTypes.LETB(LambdaTypes.Option.SOME1(breakpoint_lvar),breakpoint_fun,
d1391 1
a1391 1
                LambdaTypes.LETB(LambdaTypes.Option.SOME1(breakpoint_on_exit_lvar),breakpoint_on_exit_fun,
d1393 1
a1393 1
                LambdaTypes.LETB(LambdaTypes.Option.SOME1(step_handler_lvar),step_handler_fn,
d1416 1
a1416 1
                 [LambdaTypes.LETB(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d1418 3
a1420 3
                                                   LambdaTypes.STRUCT[LambdaTypes.VAR fnname_lvar,
                                                                      LambdaTypes.INT(0)],
                                                   LambdaTypes.Option.ABSENT),"make step")]
d1434 2
a1435 2
                                   LambdaTypes.APP(step_handler_exp,LambdaTypes.VAR fnname_lv,
                                                   LambdaTypes.Option.ABSENT),"step handler")
d1452 1
a1452 1
                LambdaTypes.LET(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d1454 2
a1455 2
                                                LambdaTypes.VAR fnname_lvar,
                                                LambdaTypes.Option.ABSENT),lexp)
d1468 1
a1468 1
              LambdaTypes.LET(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d1470 2
a1471 2
                                              LambdaTypes.VAR fnname_lvar,
                                              LambdaTypes.Option.ABSENT),lexp)
d1874 1
a1874 1
                 LambdaTypes.FN(args,
d1877 1
a1877 1
                          LambdaTypes.LET(LambdaTypes.Option.SOME1(dexp'),
d1879 1
a1879 1
                           LambdaTypes.LET(LambdaTypes.Option.SOME1(instance'),
d1881 1
a1881 1
                            LambdaTypes.LET(LambdaTypes.Option.SOME1(lvar),
d1884 1
a1884 1
                                            LambdaTypes.Option.PRESENT{lv=LambdaTypes.new_LVar(),
d1890 1
a1890 1
                                                let
d1901 2
a1902 2
                                                end,
                                              LambdaTypes.Option.ABSENT))],LambdaTypes.Option.ABSENT))))),
d1933 7
a1939 7
                  case !functorlv of
                    Option.SOME1(functorlv) => LambdaTypes.VAR functorlv
                  | Option.SOME2(ct) =>
                      cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
                             Ident.VAR(Symbol.find_symbol("functor app ref "^
                                                          MLWorks.Integer.makestring ct))),env),
                      LambdaTypes.Option.ABSENT))
d1949 1
a1949 1
                  case !functorlv of
d1954 2
a1955 2
                                                                ^MLWorks.Integer.makestring ct))),env),
                    LambdaTypes.Option.ABSENT))
d1980 2
a1981 2
                                  instance_to_lambda instance',
                                  LambdaTypes.Option.ABSENT)))
d1994 1
a1994 1
                              let
d2002 2
a2003 2
                              end,
                            LambdaTypes.Option.ABSENT)
d2008 1
a2008 1
                   LambdaTypes.STRUCT[new_cg,dexp',
d2011 1
a2011 1
                                    | Option.PRESENT(i) => LambdaTypes.INT i],
d2025 3
a2027 3
                                  LambdaTypes.STRUCT[select(selects,LambdaTypes.VAR root_lv),
                                                     dexp',LambdaTypes.INT ~1],
                                  Option.ABSENT),
d2033 1
a2033 1
                         LambdaTypes.FN(lv,
d2035 3
a2037 3
                                          LambdaTypes.STRUCT[select(selects,LambdaTypes.VAR root_lv),dexp',
                                                              LambdaTypes.VAR lv],
                                                        Option.ABSENT),
d2040 1
a2040 1
                                        LambdaTypes.Option.ABSENT)
d2050 1
a2050 1
                                         LambdaTypes.INT i,
d2062 1
a2062 1
                                            LambdaTypes.INT i,
d2082 1
a2082 1
                                             LambdaTypes.STRUCT[],
d2102 1
a2102 1
               case !functorlv of
d2106 2
a2107 2
                    Ident.VAR(Symbol.find_symbol("functor app ref "^MLWorks.Integer.makestring ct))),env),
                  LambdaTypes.Option.ABSENT)))
d2318 1
a2318 1
                LambdaTypes.FN(0,LambdaTypes.INT 1,"dummy tyfun tyfun",LambdaTypes.null_type_annotation,
d2492 3
a2494 3
               LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(0,
                                  LambdaTypes.Option.PRESENT("null_tyfun_spill",
                                                  dummy_instance,LambdaTypes.Option.PRESENT(spill)))),
d2547 2
a2548 2
                   LambdaTypes.LETB(LambdaTypes.Option.SOME1(tyfun_lvar),
                                    LambdaTypes.FN(LambdaTypes.new_LVar(),
d2583 2
a2584 2
                   LambdaTypes.LETB(LambdaTypes.Option.SOME1(tyfun_lvar),
                                    LambdaTypes.FN(LambdaTypes.new_LVar(),
d2608 1
a2608 1
            [LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
d2611 1
a2611 1
             LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv'),
d2617 1
a2617 1
            [LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
d2622 1
a2622 1
          [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),
d2797 1
a2797 1
                           (new_lv,
d2809 1
a2809 1
                                LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT)
d2821 1
a2821 1
                         LambdaTypes.FN(lv, 
d2825 1
a2825 1
                                        LambdaTypes.Option.ABSENT)
d2851 1
a2851 1
                                        LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv), le,
d2924 1
a2924 1
                  LambdaTypes.Option.PRESENT false_val
d2926 1
a2926 1
                  LambdaTypes.Option.ABSENT
d2930 1
a2930 1
               LambdaTypes.Option.PRESENT {lv = LambdaTypes.new_LVar(),
d2938 2
a2939 2
              LambdaTypes.FN(var,body,_,_,_) =>
                LambdaTypes.LET(LambdaTypes.Option.SOME1(var),
d2941 3
a2943 2
            | _ => LambdaTypes.APP(fcn, arg, 
                                   LambdaTypes.Option.PRESENT(annotation)))  (***)
d3146 1
a3146 1
              LambdaUtils.add_match_env((root, LambdaTypes.Option.SOME1(root_lambda)),
d3177 1
a3177 1
                       LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
d3179 1
a3179 1
                                                        LambdaTypes.SCON(Ident.STRING(rc)),
d3191 5
a3195 5
                                LambdaTypes.STRUCT[LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                   LambdaTypes.VAR lvar,
                                                                   Option.ABSENT),
                                                   report rcs],
                                Option.ABSENT)
d3199 6
a3204 7
                                LambdaTypes.STRUCT[
                                               LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                               LambdaTypes.VAR redundant_clauses_lambda,
                                                               Option.ABSENT),
                                               LambdaTypes.SCON(Ident.INT("0",Location.UNKNOWN))],
                                Option.ABSENT),
                            LambdaTypes.Option.PRESENT {lv = LambdaTypes.new_LVar(),
d3210 1
a3210 1
                                LambdaTypes.STRUCT[MLWorks_IO_std_out,
d3212 1
a3212 1
                                  LambdaTypes.STRUCT[LambdaTypes.SCON(Ident.STRING(
d3215 4
a3218 4
                                  report redundant_clauses],
                                  LambdaTypes.Option.ABSENT)],
                                  LambdaTypes.Option.ABSENT))],
                            LambdaTypes.Option.ABSENT)
d3254 2
a3255 3
                                          LambdaTypes.STRUCT[exn_code exn1,
                                                             exn_code exn2],
                                          LambdaTypes.Option.ABSENT)
d3258 1
a3258 1
                                             LambdaTypes.Option.PRESENT {lv = LambdaTypes.new_LVar(),
d3263 1
a3263 1
                                             LambdaTypes.Option.ABSENT)
d3266 1
a3266 1
                                             LambdaTypes.Option.PRESENT {lv = LambdaTypes.new_LVar(),
d3271 1
a3271 1
                                             LambdaTypes.Option.ABSENT)
d3275 1
a3275 1
                      LambdaTypes.LET(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d3277 1
a3277 1
                        LambdaTypes.Option.PRESENT {lv = LambdaTypes.new_LVar(),
d3283 1
a3283 1
                            LambdaTypes.STRUCT[LambdaTypes.VAR lvar,
d3285 1
a3285 1
                                     Lists.tl(Lists.tl(Lists.tl(Lists.tl(Lists.tl(explode(rc)))))))))],
d3290 1
a3290 1
                            LambdaTypes.STRUCT[LambdaTypes.VAR redundant_clauses_lambda,
d3292 5
a3296 6
                                LambdaTypes.STRUCT[
                                               LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                               LambdaTypes.VAR redundant_clauses_lambda,
                                                               Option.ABSENT),
                                               LambdaTypes.SCON(Ident.INT("1",Location.UNKNOWN))],
                                Option.ABSENT)],
d3298 1
a3298 1
                        LambdaTypes.Option.ABSENT),
d3310 1
a3310 1
                                       LambdaTypes.Option.SOME1(redundant_clauses_lambda),
d3312 5
a3316 4
                                         LambdaTypes.SCON(Ident.INT(MLWorks.Integer.makestring(
                                           number_of_clauses),Location.UNKNOWN)),
                                         Option.ABSENT), "redundancy count")::
                              bindings,redundancy_code redundant_clauses),
d3348 2
a3349 2
                           (LambdaTypes.Option.SOME1(lv),
                            LambdaTypes.FN(LambdaTypes.new_LVar(), 
d3362 1
a3362 1
                                LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
d3382 2
a3383 2
                           (LambdaTypes.Option.SOME1(lv),
                            LambdaTypes.FN(LambdaTypes.new_LVar(), 
d3404 1
a3404 1
                                LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
d3414 1
a3414 1
                           LambdaTypes.Option.PRESENT(
d3416 2
a3417 2
                                            LambdaTypes.STRUCT [],
                                            LambdaTypes.Option.ABSENT))
d3419 1
a3419 1
                            LambdaTypes.Option.PRESENT(init_null_tyfun_spills();
d3422 1
a3422 1
                            LambdaTypes.Option.PRESENT(excp)
d3427 1
a3427 1
                      | Option.SOME1(Match.ABSENT) => LambdaTypes.Option.ABSENT
d3429 1
a3429 1
                           LambdaTypes.Option.PRESENT(
d3431 2
a3432 2
                                            LambdaTypes.STRUCT [],
                                            LambdaTypes.Option.ABSENT))
d3444 1
a3444 1
                            LambdaTypes.Option.SOME1(lv) => 
d3452 2
a3453 2
                                       LambdaTypes.Option.PRESENT
                                       (Symbol.symbol_name symbol,ty,LambdaTypes.Option.ABSENT)
d3456 1
a3456 1
                                      LambdaTypes.LET(LambdaTypes.Option.SOME2(ref(dummylv,
d3473 1
a3473 1
                          | LambdaTypes.Option.SOME2(lvar as ref(lv,_)) => 
d3477 2
a3478 2
                                   (lvar := (lv,LambdaTypes.Option.PRESENT
                                         (Symbol.symbol_name symbol,ty,LambdaTypes.Option.ABSENT));
d3500 1
a3500 1
	                 LambdaTypes.Option.ABSENT,
d3560 2
a3561 2
                              LambdaTypes.STRUCT [],
                              LambdaTypes.Option.ABSENT)
d3592 1
a3592 1
                        LambdaTypes.Option.SOME1(new_lv)
d3594 1
a3594 1
                        LambdaTypes.Option.SOME2(ref(new_lv,LambdaTypes.Option.ABSENT))
d3596 1
a3596 1
                      LambdaTypes.Option.SOME1(new_lv)
d3631 1
a3631 1
                                LambdaTypes.Option.SOME1(LambdaTypes.new_LVar ())
d3633 2
a3634 2
                                LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar (),
                                                             LambdaTypes.Option.ABSENT))
d3636 1
a3636 1
                              LambdaTypes.Option.SOME1(LambdaTypes.new_LVar ())
d3640 3
a3642 4
                              LambdaTypes.APP(
				LambdaTypes.BUILTIN Pervasives.DEREF,
                                LambdaTypes.VAR orig_lv,
                                            LambdaTypes.Option.ABSENT),
d3677 1
a3677 1
		    LambdaTypes.Option.PRESENT{
d3694 1
a3694 1
                        LambdaTypes.Option.ABSENT (* No default here if all cases ok *)
d3706 1
a3706 1
                    LambdaTypes.Option.SOME1(new_lv)
d3708 1
a3708 1
                    LambdaTypes.Option.SOME2(ref(new_lv,LambdaTypes.Option.ABSENT))
d3710 1
a3710 1
                  LambdaTypes.Option.SOME1(new_lv)
d3719 1
a3719 1
		  LambdaTypes.Option.PRESENT{lv = LambdaTypes.new_LVar(),
d3745 1
a3745 1
                  LambdaTypes.Option.PRESENT{lv = LambdaTypes.new_LVar(),
d3777 1
a3777 1
                   LambdaTypes.Option.SOME1(LambdaTypes.new_LVar())
d3779 2
a3780 2
                   LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar(),
                                             LambdaTypes.Option.ABSENT))
d3785 1
a3785 1
                                LambdaTypes.Option.SOME1(LambdaTypes.new_LVar())))
d3827 1
a3827 1
     LambdaTypes.FN(root_lambda,
d3843 1
a3843 1
                 name_string,ty,LambdaTypes.Option.ABSENT))
d3859 1
a3859 1
    val excp = LambdaTypes.Option.PRESENT(
d3873 3
a3875 3
                   * (LambdaTypes.Tyfun ref * (int,int) LambdaTypes.Option.option ref) list) ref 
                 * (int,int) LambdaTypes.Option.option ref 
             LambdaTypes.Option.opt) LambdaTypes.Option.opt 
d3879 2
a3880 2
                                LambdaTypes.Option.ABSENT,
                                LambdaTypes.Option.ABSENT)
d3900 1
a3900 1
                                     LambdaTypes.Option.SOME1(dummy_lv),
d3903 1
a3903 1
                                                        LambdaTypes.Option.ABSENT,
d3909 1
a3909 1
                   ],LambdaTypes.Option.ABSENT,LambdaTypes.Option.ABSENT)
d3921 2
a3922 2
                             LambdaTypes.Option.PRESENT(Symbol.symbol_name symbol,
                                                        Ty,LambdaTypes.Option.ABSENT),
d3934 1
a3934 1
                            LambdaTypes.Option.SOME1(dummy_lv),
d3937 1
a3937 1
                                   LambdaTypes.Option.PRESENT{
d3943 1
a3943 1
                                    if one_con then LambdaTypes.Option.ABSENT else excp
d3946 1
a3946 1
                        ], LambdaTypes.Option.ABSENT, LambdaTypes.Option.ABSENT)
d3955 1
a3955 1
                                          LambdaTypes.Option.SOME1(dummy_lv),
d3958 1
a3958 1
                                                             LambdaTypes.Option.PRESENT{
d3967 2
a3968 2
                                          "")],LambdaTypes.Option.ABSENT,
                        LambdaTypes.Option.ABSENT)
d4007 2
a4008 2
                   ([], env_list_lambda_list_list),LambdaTypes.Option.ABSENT,
                   LambdaTypes.Option.ABSENT)
d4027 2
a4028 2
                                                    LambdaTypes.VAR lambda_var,
                                                    LambdaTypes.Option.ABSENT)
d4033 2
a4034 2
                          @@ new_lambda_exp,LambdaTypes.Option.ABSENT,
                          LambdaTypes.Option.ABSENT)
d4050 1
a4050 1
                                                LambdaTypes.Option.PRESENT{
d4064 1
a4064 1
                                     LambdaTypes.Option.ABSENT
d4070 2
a4071 2
                            @@ new_lambda_exp,LambdaTypes.Option.ABSENT,
                            LambdaTypes.Option.ABSENT)
d4084 1
a4084 1
                                                     LambdaTypes.Option.PRESENT{
d4098 2
a4099 2
                        LambdaTypes.Option.ABSENT,
                        LambdaTypes.Option.ABSENT)
d4116 2
a4117 2
                        lambda,LambdaTypes.Option.PRESENT(Symbol.symbol_name vid,
                                                          Ty,LambdaTypes.Option.ABSENT),
d4157 1
a4157 1
                  val _ = map (fn LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(_,debug_info)),_,_) =>
d4184 3
a4186 3
                       (LambdaTypes.Option.SOME2(ref(new_lv,
                                                     LambdaTypes.Option.ABSENT)),
                        LambdaTypes.Option.SOME1(new_lvar new_lv), pat, exp, location)
d4193 1
a4193 1
                       val new_lv = LambdaTypes.Option.SOME1(LambdaTypes.new_LVar())
d4200 2
a4201 2
                    (fn (LambdaTypes.Option.SOME2(lv' as ref(lv,_)), 
                         LambdaTypes.Option.SOME1(lv''), pat, _, location) =>
d4220 1
a4220 1
                  | (LambdaTypes.Option.SOME1(lv), _, pat, _, location) =>
d4282 2
a4283 2
                                    (LambdaTypes.Option.SOME2(lv as ref(_,info)),
                                     LambdaTypes.Option.SOME1(lv')) => 
d4322 1
a4322 1
                              ref (ty,LambdaTypes.Option.ABSENT,nil)),Location.UNKNOWN),
d4403 2
a4404 2
                                                      LambdaTypes.STRUCT[],
                                                      LambdaTypes.Option.ABSENT),
d4419 1
a4419 1
		([LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv), lambda_exp,
d4514 1
a4514 1
		LambdaTypes.LETB(LambdaTypes.Option.SOME1(l), LambdaTypes.SELECT(field, lambda_exp),"")
d4516 1
a4516 1
                 LambdaTypes.LETB(LambdaTypes.Option.SOME1(l),
d4525 1
a4525 1
		LambdaTypes.LETB(LambdaTypes.Option.SOME1(l), LambdaTypes.SELECT(field, lambda_exp),"")
d4527 1
a4527 1
                 LambdaTypes.LETB(LambdaTypes.Option.SOME1(l), LambdaTypes.BUILTIN prim,"")
d4577 1
a4577 1
               LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
d4581 1
a4581 1
               LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
d4585 1
a4585 1
                    LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
d4588 2
a4589 2
                                                      LambdaTypes.STRUCT[],
                                                      LambdaTypes.Option.ABSENT),
d4596 1
a4596 1
            LambdaTypes.LETB(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d4649 1
a4649 1
	complete_struct((env, arg), LambdaTypes.Option.PRESENT interface, !coerce, generate_moduler)
d4658 1
a4658 1
                                    LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),
d4660 2
a4661 2
                                                                   str_to_lambda interface,
                                                                   LambdaTypes.Option.ABSENT),
d4668 1
a4668 1
                                                          LambdaTypes.Option.PRESENT interface,dstrexp,
d4679 2
a4680 2
                             LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
                             LambdaTypes.Option.ABSENT)
d4683 2
a4684 2
            new_arg,
            LambdaTypes.Option.ABSENT)
d4736 1
a4736 1
	    Absyn.Option.ABSENT => LambdaTypes.Option.ABSENT
d4738 1
a4738 1
	      LambdaTypes.Option.PRESENT (interface_from_sigexp sigexp)
d4756 1
a4756 1
            LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), lambda_exp,"") 
d4774 1
a4774 1
	    Absyn.Option.ABSENT => LambdaTypes.Option.ABSENT
d4776 1
a4776 1
	      LambdaTypes.Option.PRESENT (interface_from_sigexp sigexp)
d4794 1
a4794 1
            LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), lambda_exp,"") 
d4849 1
a4849 1
	Absyn.Option.ABSENT => LambdaTypes.Option.ABSENT
d4851 1
a4851 1
	  LambdaTypes.Option.PRESENT (interface_from_sigexp sigexp)
d4893 1
a4893 1
         LambdaTypes.LET(LambdaTypes.Option.SOME1(lvar'),
d4896 1
a4896 1
            LambdaTypes.LET(LambdaTypes.Option.SOME1(lvar''),
d4899 1
a4899 1
            LambdaTypes.LET(LambdaTypes.Option.SOME1(lvar'''),
d4904 1
a4904 1
                                    LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),
d4906 2
a4907 2
                                                                   str_to_lambda interface,
                                                                   LambdaTypes.Option.ABSENT),
d4912 1
a4912 1
                              LambdaTypes.LET(LambdaTypes.Option.SOME1(lambda_var'),
d4914 1
a4914 1
                              LambdaTypes.LET(LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()),
d4916 3
a4918 3
                                                           LambdaTypes.STRUCT[LambdaTypes.VAR lvar''',
                                                                              dstrexp_to_lambda dstrexp],
                                                           LambdaTypes.Option.ABSENT),
d4930 3
a4932 3
       [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var),
                         LambdaTypes.FN(lvar, lambda_exp, annotation_string,
                                        LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
d4985 1
a4985 1
    map (fn (ref(Option.SOME1(lv)),interface) => LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),
d4987 2
a4988 2
                                                                   str_to_lambda interface,
                                                                   LambdaTypes.Option.ABSENT),
@


1.157
log
@Bindings in Match DEFAULT trees.
@
text
@d4 3
d673 2
a674 2
  (* A function to determine if the given type is a function application,
     and if so, is it an overloaded primitive operation
d676 1
a676 5

  fun is_overloaded
	error_info
	(print_options,
	 Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
d680 6
a685 8
	   Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
	 | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
	 | _ => (false, ""))
    | _ => (false, ""))
  | is_overloaded
      error_info
      (print_options,
       Datatypes.FUNTYPE
d688 4
a691 4
       Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
     | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
     | _ => (false, ""))
  | is_overloaded _ _ = (false, "")
a2682 4
                     val nopath = case p of
                       Ident.NOPATH => true
                     | _ => false

d2695 1
a2695 2
                     val (is_ol, name) =
		       is_overloaded error_info (print_options, ty)
a2696 5
                     val sy_name = Symbol.symbol_name sy
                     val _ = if is_ol then
                       diagnose("Overloaded operator " ^ sy_name ^
                                " with type " ^ name ^ "\n")
                             else ()
d2705 1
a2705 6
                     val _ = if env_ol andalso not is_ol
                               then
                                 Info.error' error_info 
                                 (Info.FATAL, location,
				  "Unresolved overloading for " ^ sy_name)
                             else ()
d2708 13
a2720 3
                         cg_longvalid(Ident.LONGVALID(Ident.NOPATH, 
                                      Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name))),
                                      Primitives.env_for_lookup_in_lambda)
d2723 1
@


1.156
log
@Match trees alteration : nodes can now disintegrate into default trees.
@
text
@d4 3
d3815 12
a3826 4
      | Match.DEFAULT(default) =>
          case Tr_Default (Option.SOME1(Match.PRESENT(default))) of
            Option.ABSENT => Crash.impossible "Match.DEFAULT:trans_match:lambda"
          | Option.PRESENT(lexp) => lexp
@


1.155
log
@Update debugger information production
@
text
@d4 3
d3812 4
@


1.154
log
@Modified resolution of overloading - some cases weren't getting caught.
Now calls Types.resolve_overloading for all variables.
@
text
@d4 4
d4372 1
a4372 1
                      ((ty,false,[]),Debugger_Types.empty_debugger_env)))
@


1.153
log
@Breakpoint settings on function exits;
FUNCTION RETURN value bindings for stepper;
Tidied up a little bit.
@
text
@d4 5
d666 1
a666 1
	(print_options, default_overloads,
d670 4
a673 12
	let fun error_fn (valid, loc) =
	      Info.error' error_info
	      (Info.FATAL, loc,
	       "Unresolved overloading for "
	       ^ IdentPrint.printValId print_options valid)
	in
	  Types.resolve_overloading (default_overloads, ty, error_fn);
	  case Types.the_type (!r) of
	    Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
	  | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
	  | _ => (false, "")
	end
d677 1
a677 1
      (print_options, default_overloads,
d680 4
a683 12
	let fun error_fn (valid, loc) =
	      Info.error' error_info
	      (Info.FATAL, loc,
	       "Unresolved overloading for "
	       ^ IdentPrint.printValId print_options valid)
	in
	  Types.resolve_overloading (default_overloads, ty, error_fn);
          case Types.the_type (!r) of
            Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
          | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
          | _ => (false, "")
	end
d2679 13
d2693 2
a2694 3
		       is_overloaded
		         error_info
			 (print_options, default_overloads, ty)
@


1.152
log
@Added call to resolve_overloading in translation of dynamic expression
@
text
@d4 3
a1233 2
      val breakpoint_fn : (LambdaTypes.LambdaExp->LambdaTypes.LambdaExp) ref = 
        ref(fn lexp => lexp)
d1293 1
a1293 1
      val (step_exp,breakpoint_exp,step_handler_exp,stepper_binding,stepper_env) =
d1300 2
d1355 4
d1372 12
d1387 1
d1392 2
d1399 1
a1399 1
                 Environ.add_valid_env(Environ.add_valid_env(Environ.add_valid_env(env,
d1404 2
d1410 1
a1410 1
         (LambdaTypes.VAR 0,LambdaTypes.VAR 0,LambdaTypes.VAR 0,[],fn env => env)
d1428 1
a1428 1
          fn (lexp,(fnname,fnname_lv)) => 
d1430 9
a1438 3
              LambdaTypes.HANDLE(lexp,
                                 LambdaTypes.APP(step_handler_exp,LambdaTypes.VAR fnname_lv,
                                                 LambdaTypes.Option.ABSENT),"step handler")
d1443 2
a1444 2
 
      val make_binding_for_stepper =
d1446 1
a1446 1
          fn (lexp,(fnname,fnname_lv)) => 
d1448 11
a1458 3
              LambdaTypes.LET(Option.SOME1(fnname_lv),
                              LambdaTypes.SCON(LambdaTypes.Ident.STRING(fnname)),
                              lexp)
d1460 1
a1460 1
              lexp
d1462 1
a1462 1
          fn (lexp,_) => lexp
d1464 1
a1464 1
      val make_breakpoint = 
d1470 1
a1470 1
                              LambdaTypes.APP(breakpoint_exp,
d1478 20
d1527 3
a1529 3
        (** lookup functions for polymorphic function determining;
            look for longvalid in the debugger environment 
         **)
d2070 6
a2075 1
      (** spill formation for type function instantiation **)
d2469 2
d2487 3
d2499 25
d2531 4
a2534 1
          instantiation **)
d2555 1
a2555 1
                                                   (tfs := nil;ves := nil; "spills for tycon "
d2567 4
a2570 1
          instantiation **)
d2591 1
a2591 1
                                                   (tfs := nil;ves := nil; "spills for tycon "
d2608 8
a2615 12
            fn ((lv,lv'),debug_info,instance,lexp,comment,location,fnname,denv,
                generate_spills) =>
            (if generate_spills then
               null_tyfun_spills denv debug_info location
             else ();
               [LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
                                 lexp,
                                 comment),
                LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv'),
                                 make_binding(debug_info,instance,
                                              LambdaTypes.VAR(lv),location),
                                 comment)])
d2617 4
a2620 7
            fn ((lv,_),debug_info,_,lexp,comment,location,fnname,denv,generate_spills) =>
            (if generate_spills then
               null_tyfun_spills denv debug_info location
             else ();
               [LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
                                 lexp,
                                 comment)])
d2622 1
a2622 1
          fn ((lv,_),_,_,lexp,comment,_,fnname,_,_) =>
d2627 27
a2872 1
          (*val breakpoint_fn = !breakpoint_fn*)
d2949 1
a2949 3
          val old_tfs = !tfs
          val old_ves = !ves
          val old_tyfun_spills = !tyfun_spills
d2951 1
a2951 1
            (tfs := nil;ves := nil;tyfun_spills := [];
d2989 1
a2989 3
          val _ = tfs := old_tfs
          val _ = ves := old_ves
          val _ = tyfun_spills := old_tyfun_spills
d3345 1
a3345 3
                                val old_tfs = !tfs
                                val old_ves = !ves
                                val old_tyfun_spills = !tyfun_spills
d3347 1
a3347 1
                                   (tfs := nil;ves := nil;tyfun_spills := [];
d3350 2
a3351 4
                                                            (fnname,fnname_lv)))
                                val _ = tfs := old_tfs
                                val _ = ves := old_ves
                                val _ = tyfun_spills := old_tyfun_spills
d3379 1
a3379 3
                                val old_tfs = !tfs
                                val old_ves = !ves
                                val old_tyfun_spills = !tyfun_spills
d3381 1
a3381 1
                                   (tfs := nil;ves := nil;tyfun_spills := [];
d3392 2
a3393 4
                                                            (fnname,fnname_lv)))
                                val _ = tfs := old_tfs
                                val _ = ves := old_ves
                                val _ = tyfun_spills := old_tyfun_spills
d3413 1
a3413 1
                            LambdaTypes.Option.PRESENT(tfs := nil;ves := nil;tyfun_spills := [];
d3434 1
a3434 1
                        make_breakpoint (fnname,fnname_lv)
d3489 1
a3489 3
                       val old_tfs = !tfs
                       val old_ves = !ves
                       val old_tyfun_spills = !tyfun_spills
d3497 1
a3497 1
                               (tfs := nil;ves := nil;tyfun_spills := [];
d3502 1
a3502 3
                         val _ = tfs := old_tfs
                         val _ = ves := old_ves
                         val _ = tyfun_spills := old_tyfun_spills
d3668 1
a3668 3
                    val old_tfs = !tfs
                    val old_ves = !ves
                    val old_tyfun_spills = !tyfun_spills
d3680 1
a3680 1
                                 (tfs := nil;ves := nil;tyfun_spills := [];
d3691 1
a3691 3
                    val _ = tfs := old_tfs
                    val _ = ves := old_ves
                    val _ = tyfun_spills := old_tyfun_spills
d3710 1
a3710 3
                   val old_tfs = !tfs
                   val old_ves = !ves
                   val old_tyfun_spills = !tyfun_spills
d3720 1
a3720 1
		            (tfs := nil;ves := nil;tyfun_spills := [];
d3728 1
a3728 3
                    val _ = tfs := old_tfs
                    val _ = ves := old_ves
                    val _ = tyfun_spills := old_tyfun_spills
d3736 1
a3736 3
              val old_tfs = !tfs
              val old_ves = !ves
              val old_tyfun_spills = !tyfun_spills
d3745 1
a3745 1
                        (tfs := nil;ves := nil;tyfun_spills := [];
d3750 1
a3750 3
                    val _ = tfs := old_tfs
                    val _ = ves := old_ves
                    val _ = tyfun_spills := old_tyfun_spills
d3805 3
d3812 1
a3812 3
                     val old_tfs = !tfs
                     val old_ves = !ves
                     val old_tyfun_spills = !tyfun_spills
d3814 1
a3814 1
                       (tfs := nil;ves := nil;tyfun_spills := [];
d3816 7
a3822 5
                        make_handle_for_stepper(make_null_tyfun_spills(
                                     tr_match(tree, match_env,env)),(fnname,fnname_lv)),(fnname,fnname_lv)))
                     val _ = tfs := old_tfs
                     val _ = ves := old_ves
                     val _ = tyfun_spills := old_tyfun_spills
d3853 1
a3853 1
            fun trans_individual_dec(pattern, (lambda_var,lambda_var'), location, toplevel):
d3970 1
a3970 1
                         trans_individual_dec(pat, (lv,lv'), location, toplevel)
d3973 1
a3973 2
                        make_binding'((lv,lv'),debug_info,instance,le,"",location,fnname,denvir,
                                      toplevel)
d4008 1
a4008 1
                           trans_individual_dec(pat, (new_lv,new_lv'), location, toplevel)
d4015 1
a4015 1
                                           "Dereferencing a pattern",location,fnname,denvir,toplevel)
d4021 1
a4021 1
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location, toplevel)
d4028 1
a4028 1
                             trans_individual_dec(pat, (new_lv,new_lv'),location,toplevel)
d4052 1
a4052 1
                                          location,fnname,denvir,toplevel)
d4063 1
a4063 1
                         trans_individual_dec(pat, (new_lv,new_lv'),location,toplevel)
d4079 1
a4079 1
                                      location,fnname,denvir,toplevel)
d4087 1
a4087 1
                    trans_individual_dec(typed, (lambda_var,lambda_var'), location, toplevel)
d4094 1
a4094 1
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location, false)
a4111 1
                  val lambda = trans_exp(" pattern", exp, envir, denvir, fnname)
d4114 1
a4114 1
                    trans_individual_dec(pat, (lvar,lvar'), location', true)
d4127 3
d4139 5
d4154 1
a4154 1
                                    location',fnname,denvir,true)
d4188 1
a4188 1
                         trans_individual_dec(pat, (lv,lv''),location',true)
d4206 1
a4206 1
                         trans_individual_dec(pat, (lv,lv),"",true)
d4290 1
a4290 2
          val old_tfs = !tfs
          val old_ves = !ves
d4292 1
a4292 1
            (tfs := nil;ves := nil;
d4294 1
a4294 2
          val _ = tfs := old_tfs
          val _ = ves := old_ves
d4316 1
a4316 2
          val old_tfs = !tfs
          val old_ves = !ves
d4318 1
a4318 1
            (tfs := nil;ves := nil;
d4321 1
a4321 2
          val _ = tfs := old_tfs
          val _ = ves := old_ves
@


1.151
log
@New overloading scheme.
@
text
@d4 3
d2945 5
a2949 1
      | Absyn.DYNAMICexp (exp,_,ref info) =>
d2951 14
d2966 3
d2973 1
@


1.150
log
@Fix non-generative exception problems
@
text
@d4 3
d653 4
a656 1
  fun is_overloaded(Datatypes.FUNTYPE(Datatypes.RECTYPE record_map, _)) =
d658 13
a670 5
      (_, Datatypes.META_OVERLOADED(ref ty,_)) :: _ =>
	(case Types.the_type ty of
	   Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
	 | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
	 | _ => (false, ""))
d672 18
a689 6
  | is_overloaded(Datatypes.FUNTYPE(Datatypes.META_OVERLOADED (ref ty,_), _)) =
    (case Types.the_type ty of
      Datatypes.CONSTYPE(_, Datatypes.TYNAME{2=s,...}) => (true, s)
    | Datatypes.CONSTYPE(_, Datatypes.METATYNAME{2=s,...}) => (true, s)
    | _ => (false, ""))
  | is_overloaded _ = (false, "")
d1179 8
a1186 7
    (Options.OPTIONS{print_options,
                     compiler_options = Options.COMPILEROPTIONS{debug,
                                                                debug_variables,
                                                                debug_polyvariables,
                                                                generate_stepper,
                                                                generate_moduler,
                                                                generate_stepper_specific, ...}, ...},
d2330 2
a2331 1
              | type_spills (Datatypes.META_OVERLOADED(ref(ty),_)) = type_spills ty
d2561 1
a2561 1
          | Absyn.VALexp(longValId, ty' as ref ty,location,ref(instance',instance)) =>
d2568 4
a2571 1
                     val (is_ol, name) = is_overloaded ty
@


1.149
log
@Always generated debug information for exceptions.
@
text
@d4 3
d1166 3
a1168 2
      (* Global exceptions and Dynamic redundancy code generator *)
      val global_exceptions : (int * string) list ref = ref(nil)
d1383 12
d2479 1
a2479 1
                generate_spills,generate_step) =>
d2483 1
a2483 1
               (LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
d2485 1
a2485 1
                                 comment)::
d2489 1
a2489 4
                                 comment)::
                (if generate_step then
                   make_step(fnname)
                 else [])))
d2491 1
a2491 2
            fn ((lv,_),debug_info,_,lexp,comment,location,fnname,denv,generate_spills,
                generate_step) =>
d2495 1
a2495 1
               (LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
d2497 1
a2497 4
                                 comment)::
                (if generate_step then
                   make_step(fnname)
                 else [])))
d2499 4
a2502 7
          fn ((lv,_),_,_,lexp,comment,_,fnname,_,_,generate_step) =>
          LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),
                           lexp,
                           comment)::
          (if generate_step then
             make_step(fnname)
           else [])
d3099 1
a3099 1
                      LambdaTypes.LET(LambdaTypes.Option.SOME1(0),
d3133 1
a3133 1
                   (LambdaTypes.LET(Option.SOME1(0),
d3668 1
a3668 2
                        LambdaTypes.LET(Option.SOME1(fnname_lv),
                                     LambdaTypes.SCON(LambdaTypes.Ident.STRING(fnname)),
d3670 1
a3670 1
                                     tr_match(tree, match_env,env)),(fnname,fnname_lv))))
d3825 1
a3825 1
                                      toplevel,false)
d3867 1
a3867 1
                                           "Dereferencing a pattern",location,fnname,denvir,toplevel,false)
d3904 1
a3904 1
                                          location,fnname,denvir,toplevel,false)
d3931 1
a3931 1
                                      location,fnname,denvir,toplevel,false)
d3999 2
a4000 2
                                    location',fnname,denvir,true,true)
                      @@ new_bindings))
d4224 3
a4226 2
                      (* Bind new exception to strdec dec-globally bound exception;
                         Globally bound exception in LAMB for absolute exception constructor code
d4232 6
a4237 2
                          (global_exceptions := (lvar,exn_string)::(!global_exceptions);
                           (LambdaTypes.VAR(lvar),
d4316 2
a4317 1
             (* Full paths in LAMBs for absolute exception constructor code in
d4394 39
d4557 1
a4557 37
    Absyn.DECstrdec dec => 
      (global_exceptions := nil;
       tfs_lvs := [];
       dexps := [];
       let
         val (env,denv,bindings) = trans_dec(dec, env, is_toplevel, denv, fnname)
       in
         (* Bind new exception globally to strdec dec for Dynamic redundancy checker;
            Generate Dynamic redundancy checker.
            Also for the Modules Debugger bind any global lambda variables formed from
            functor parameters
          *)
         (env, denv,
          map (fn (lvar,exn_string) =>
                    LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
                                     LambdaTypes.STRUCT
                                     [LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
                                                      LambdaTypes.STRUCT[],
                                                      LambdaTypes.Option.ABSENT),
                                     LambdaTypes.SCON(Ident.STRING exn_string)],
                                     "global exception binding "^exn_string))
         (!global_exceptions)@@
          map (fn (_,(lvar,lexp)) =>
               LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
                                lexp,
                                "global type-function binding")) (!tfs_lvs) @@
          map (fn (_,(lvar,lexp)) =>
               LambdaTypes.LETB(LambdaTypes.Option.SOME1(lvar),
                                lexp,
                                "global debugger-exp binding")) (!dexps) @@
         (case Dynamic_redundancy_report() of
            LambdaTypes.STRUCT[] => bindings
          | dynamic_report => 
              LambdaTypes.LETB(LambdaTypes.Option.SOME1(0),
                               dynamic_report,
                               "dynamic redundancy report")::bindings))
       end)
d4745 2
a4746 2
                                            lambda_exp,
                              LambdaTypes.LET(LambdaTypes.Option.SOME1(0),
d4763 1
a4763 1
                         LambdaTypes.FN(lvar, lambda_exp,annotation_string,
@


1.148
log
@nongeneric weak type variable in functor_refs.
@
text
@d4 3
d4203 10
a4212 11
		  if debug then
		    let
                      val Debugger_Types.INFO i = !debug_info_ref
		    in
                      debug_info_ref :=
                        Debugger_Types.INFO
		          (NewMap.define
			     (i, exn_string,
			      ((ty,false,[]),Debugger_Types.empty_debugger_env)))
		    end
		  else ()
@


1.147
log
@Step and Breakpoints Debugger;
Modules Debugger : Dynamic Type Name Instantiation.
@
text
@d4 4
d1142 2
a1143 1
  val functor_refs = ref []
@


1.146
log
@Removed old parameter to trans_top_dec,
Made generation of debug info for setup functions obey flag.
@
text
@d4 4
d402 1
d426 1
d436 1
a436 1
    LambdaOptimiser.LambdaTypes = Environ.EnvironTypes.LambdaTypes
d444 2
a445 1
  sharing LambdaUtils.Match.Options = Types.Options = AbsynPrint.Options = Debugger_Types.Options
d456 6
a461 1
  sharing type LambdaSub.LT.Instance = Types.Datatypes.instance = AbsynPrint.Absyn.Instance
d482 1
a482 1
  structure Option = Match.Option
d513 2
a514 2
    | val_filter_map ([], x :: _, print_fn, done) =
        Crash.impossible("member '" ^ print_fn x ^
d573 4
a576 1
    (fn (env, (env', _)) => Environ.augment_env(env, env'))
d580 2
d697 1
a697 1
      val (env', comp) = Environ.lookup_strid(strid, env)
d713 1
a713 1
      val (env', comp) = Environ.lookup_strid(strid, env)
d716 2
a717 2
	EnvironTypes.LAMB (lvar,longstrid) => (env', LambdaTypes.VAR lvar, longstrid)
      | EnvironTypes.PRIM prim => (env', LambdaTypes.BUILTIN prim, Option.ABSENT)
d722 1
a722 1
	    LambdaTypes.Option.ABSENT), Option.ABSENT)
d730 1
a730 1
	(env'', EnvironTypes.FIELD(field)) => (env'', field)
d736 1
a736 1
  fun get_field_env'(strid, (env, lambda, longstrid)) =
d738 2
a739 2
      val (env', field) = case Environ.lookup_strid(strid, env) of
	(env'', EnvironTypes.FIELD(field)) => (env'', field)
d742 1
a742 1
      (env', LambdaTypes.SELECT(field, lambda), longstrid)
d747 1
d795 1
a795 1
          val (env', lambda, longstrid) =
d811 6
a816 4
	 (env, EnvironTypes.LAMB (lvar,longstrid)) => ((env, LambdaTypes.VAR lvar), longstrid)
       | (env, EnvironTypes.PRIM prim) => ((env, LambdaTypes.BUILTIN prim), Option.ABSENT)
       | (env, EnvironTypes.EXTERNAL) =>
	  ((env,
d820 2
a821 2
	     LambdaTypes.Option.ABSENT)), Option.ABSENT)
       | (_, EnvironTypes.FIELD _) =>
d825 1
a825 1
      val (env', lambda, longstrid) =
d828 6
a833 6
     (case Environ.lookup_strid(strid, env') of
	(env''', EnvironTypes.FIELD field) =>
	  (env''', LambdaTypes.SELECT(field, lambda))
      | (env''', EnvironTypes.PRIM prim) =>
	  (env''', LambdaTypes.BUILTIN prim)
      | (_, EnvironTypes.LAMB _) =>
d835 2
a836 3
      | (_, EnvironTypes.EXTERNAL) =>
	  Crash.impossible "cg_longstrid gets external at end of longstrid",
      longstrid)
d839 1
d904 3
a906 3
  fun compare_sig_env(Datatypes.COPYSTR (_, str), env) =
    compare_sig_env (str, env)
  |   compare_sig_env(Datatypes.STR (_, _, Datatypes.ENV
d908 1
a908 1
				              _,
d911 2
a912 1
    NewMap.size vm = NewMap.size v_map andalso
d916 1
a916 1
      compare_sig_env
d920 2
a921 2
  fun complete_struct_with_sig (Datatypes.COPYSTR (_, str), env, lv, coerce) =
    complete_struct_with_sig (str, env, lv, coerce)
d925 1
a925 1
					      _,
d929 2
a930 1
	 coerce) =
d933 1
a933 1
    if not(coerce) andalso compare_sig_env(interface, env) then
d945 10
d962 1
a962 1
	 str_filter_ordered_map
d964 2
a965 1
	  IdentPrint.printStrId), [])
d978 2
a979 2
	(map (fn (_, x) => LambdaTypes.VAR x) v_f_l_list) @@
	(map (fn (_, x, _) => LambdaTypes.VAR x) s_f_l_list)
d984 2
a985 2
	    (map (fn ((((_, (env, _)), _), _, l2), (_, inte)) =>
		    (inte, env, l2, coerce))
d999 1
a999 1
	        Environ.add_strid_env(env, (strid, (env', field))))
d1057 1
a1057 1
	(map (fn ((((_, (env, EnvironTypes.FIELD f_old)), _), lv, lv'), le) =>
d1067 1
a1067 1
	      |  ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) =>
d1069 1
a1069 1
	      |  ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) =>
d1071 1
a1071 1
	      |  ((((_, (_, EnvironTypes.EXTERNAL)), _), _, _), _) =>
d1099 2
a1100 2
                         (map (fn (_, (_, x)) => extract_op x) strids) @@
			 (map (fn (_,(x, (* _, *) _)) => extract_op x) funids))))
d1107 1
a1107 1
		      coerce) =
d1116 1
a1116 1
        if not(coerce) andalso compare_sig_env(inte, new_env) then result
d1121 1
a1121 1
	      complete_struct_with_sig(inte, new_env, new_lv, coerce)
d1124 3
a1126 2
	     LambdaTypes.do_binding(LambdaTypes.LETB(LambdaTypes.Option.SOME1(new_lv), lambda_exp,""),
				    new_lambda'))
d1137 3
d1142 7
a1148 6
    (Options.OPTIONS
       {print_options,
        compiler_options = Options.COMPILEROPTIONS
			     {debug,
			      debug_variables,
                              debug_polyvariables,...}, ...},
d1150 2
a1151 1
     top_env as EnvironTypes.TOP_ENV(env, top_map),
d1153 1
a1153 1
     basis) =
d1157 2
a1158 1
      val dynamic_redundancy_report : (LambdaTypes.LambdaExp -> LambdaTypes.LambdaExp) ref = ref(fn exp=>exp)
d1167 18
a1184 1
      val debug_somevariables = debug_variables orelse debug_polyvariables
d1188 3
a1190 1
      val dummy_instance = ref(Datatypes.NULLTYPE,Datatypes.Option.ABSENT)
d1201 1
a1201 1
                        LambdaTypes.Option.PRESENT(name,ref(ty,_),_) => 
a1241 2
              | Datatypes.Option.PRESENT(ref(Datatypes.SIGNATURE_INSTANCE(_))) => 
                  Crash.impossible "2:make_binding:trans_dec"
d1244 1207
d2452 38
a2489 17
              if debug_somevariables then 
                if debug_polyvariables then 
                  fn ((lv,lv'),debug_info,instance,lexp,comment,location) =>
                  LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
                                   lexp,
                                   comment)::
                  [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv'),
                                    make_binding(debug_info,instance,
                                                 LambdaTypes.VAR(lv),location),comment)]
                else
                  fn ((lv,_),debug_info,_,lexp,comment,_) =>
                  [LambdaTypes.LETB(LambdaTypes.Option.SOME2(ref(lv,debug_info)),
                                    lexp,
                                   comment)]
              else
                  fn ((lv,_),_,_,lexp,comment,_) =>
                [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv),lexp,comment)]
d2493 1
d2505 1
a2505 1
       fun trans_exp(name, x, env) =
d2519 1
a2519 1
          | Absyn.VALexp(longValId, ty' as ref ty,location,instance) =>
a2602 11
                     (* make runtime instance for polymorphic debugger *)
                     fun instance_to_lambda(nil) = LambdaTypes.INT 2
                       | instance_to_lambda([i]) = 
                         (LambdaTypes.STRUCT[LambdaTypes.INT 0,
                                             LambdaTypes.INT i])
                       | instance_to_lambda([i,i']) = 
                         (LambdaTypes.STRUCT[LambdaTypes.INT 1,
                                            LambdaTypes.STRUCT[LambdaTypes.INT i,
                                                               LambdaTypes.INT i']])
                       | instance_to_lambda _ = Crash.impossible "instance_to_lambda:lambda"
                     exception MultipleInstantiation of string
d2604 1
a2604 1
                    (if built_in then 
d2608 1
a2608 12
                     case instance of 
                       Datatypes.Option.ABSENT => new_cg
                     | Datatypes.Option.PRESENT(ref(instance',instance)) => 
                       case instance of
                         Datatypes.Option.ABSENT => new_cg
                       | Datatypes.Option.PRESENT(ref(Datatypes.NO_INSTANCE)) => new_cg
                       | Datatypes.Option.PRESENT(ref(Datatypes.SIGNATURE_INSTANCE(_::_::_))) =>
                           raise MultipleInstantiation(sy_name)
                       | Datatypes.Option.PRESENT(_) =>
                             (LambdaTypes.APP(new_cg,
                                              instance_to_lambda instance',
                                              LambdaTypes.Option.ABSENT)))
d2655 2
a2656 1
                   end)
d2673 1
a2673 1
                        trans_exp (" no_name", exp, env)))
d2691 1
a2691 1
          val (env', lambda_list) = trans_dec (decl, env,false)
d2696 3
a2698 1
            trans_exp(" no_name", exp, Environ.augment_env(env, env')))
d2705 2
a2706 1
            trans_exp(" inline_app", fun_exp, env)
d2718 1
a2718 1
                trans_exp(" no_name", val_exp, env)
d2739 1
a2739 1
            else (LambdaTypes.INT 0, LambdaTypes.INT 1)              
d2764 1
a2764 1
            case fcn of
d2769 1
a2769 1
                                   LambdaTypes.Option.PRESENT(annotation))  (***)
d2774 1
a2774 1
        trans_exp(" no_name", expression, env)
d2777 1
a2777 1
        LambdaTypes.RAISE(trans_exp(" no_name", exp, env))
d2782 20
a2801 14
        (
        LambdaTypes.HANDLE(
          trans_exp(annotation, exp, env),
          let
            val (root, tree,redundant_clauses,not_exhaustive) =
                           Match.compile_match pat_exp_list
          in
            if !show_match then
              (Print.print"Exception match tree is\n";
               Lists.iterate
               (fn x => output (std_out,x)) (Match.unparseTree print_options tree "");
               Print.print"\n";
               ())
            else ();
d2816 4
a2819 2
                trans_match((root, tree), env, true,annotation,LambdaTypes.null_type_annotation,
                             if dynamic_report_required then
d2821 10
a2830 4
                             else (0,[],Location.UNKNOWN))
            end
          end,
        annotation))
d2888 1
a2888 2
                 (
                 trans_match((root, tree), env, false,name_string,!ty,
d2891 1
a2891 1
                             else (0,[],Location.UNKNOWN)))
d2899 1
a2899 1
            val lexpr = trans_exp (name,exp,env)
d2911 1
a2911 1
                     env)
d2939 1
a2939 1
        and trans_match((root, tree), env, is_exn, name_string,ty,
d2957 3
d3133 1
a3133 1
               fun Let_Lambdas_In_Exp lambda_exp bindings lvar =
d3138 1
a3138 1
                     | Option.ABSENT => (Option.SOME1(0), LambdaTypes.INT 1)
d3146 9
d3158 21
a3178 9
                          (LambdaTypes.Option.SOME1(lv),
                           LambdaTypes.FN(LambdaTypes.new_LVar(),
                                          tr_match(tree,match_env, val_env),
                                          "Part of match translation ("
                                          ^MLWorks.Integer.makestring(new_match_trans())
                                          ^") " ^ name_string,
                                          LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
                           "Translation of match trees"))
                         end::do_binding bindings
d3184 9
d3196 29
a3224 14
                          (LambdaTypes.Option.SOME1(lv),
                           LambdaTypes.FN(LambdaTypes.new_LVar(),
                            case matchvar of
                              ~1 => tr_match(tree, match_env, val_env)
                            | _ =>
                              LambdaTypes.LET(lvar,lexp,
                               tr_match(tree, LambdaUtils.add_match_env((matchvar,lvar),match_env),
                                         val_env)),
                            "Part of match translation ("
                            ^MLWorks.Integer.makestring(new_match_trans())
                            ^") " ^ name_string,
                            LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
                           "Translation of match trees"))
                         end::do_binding bindings
d3237 2
a3238 2
                            LambdaTypes.Option.PRESENT(tr_match(tree, match_env, 
                                                                val_env))
d3257 4
a3260 3
                    fun do_leaf([], env) = 
                      trans_exp(" match_leaf", exp, env)
                      | do_leaf((mv, valid, ty as ref ty') :: tl, env) =
d3269 3
d3273 8
a3280 6
                                     LambdaTypes.LET(LambdaTypes.Option.SOME2(ref(dummylv,
                                           LambdaTypes.Option.PRESENT
                                         (Symbol.symbol_name symbol,ty,LambdaTypes.Option.ABSENT))),
                                     LambdaTypes.VAR(lv),
                                     do_leaf(tl, Environ.add_valid_env(env, (valid,
                                                                EnvironTypes.LAMB(lv,Option.ABSENT)))))
d3283 3
a3285 1
                                                                EnvironTypes.LAMB(lv,Option.ABSENT)))))
d3288 3
a3290 1
                                                                EnvironTypes.LAMB(lv,Option.ABSENT))))
d3298 3
a3300 1
                                                                EnvironTypes.LAMB(lv,Option.ABSENT)))))
d3302 3
a3304 1
                                                                EnvironTypes.LAMB(lv,Option.ABSENT)))))
d3306 1
a3306 1
                    do_leaf(mv_valid_ty_list, val_env)
d3312 5
d3321 14
a3334 4
	                 map (fn(scon,tree) =>
		             (LambdaTypes.SCON_TAG scon,
                              tr_match(tree, match_env, val_env)))
	                   scon_tree_list,Tr_Default (Option.SOME1(Match.PRESENT(default))))
d3364 2
d3369 1
a3369 5
	  val new_lv = 
                if debug_somevariables then 
                  LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar(),LambdaTypes.Option.ABSENT))
                else
                  LambdaTypes.Option.SOME1(LambdaTypes.new_LVar())
d3410 10
d3422 3
a3424 2
                            LambdaUtils.add_match_env((mv, new_lv), match_env),
                            val_env)))
d3451 6
a3456 3
                            if debug_somevariables then 
                              LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar (),
                                                         LambdaTypes.Option.ABSENT))
d3468 2
a3469 2
                                      LambdaUtils.add_match_env((mv, ref_lv),
                                                                match_env),
d3480 2
a3481 2
                                  LambdaUtils.add_match_env((mv, ORIG_LV),
                                                            match_env),
d3495 5
d3507 21
a3527 6
		    map mk_branch longvalid_mv_tree_list,
	            if Lists.length longvalid_mv_tree_list =
			 Type_Utils.get_no_cons ty then
		      LambdaTypes.Option.ABSENT (* No default here if all cases ok *)
	            else Tr_Default default
		  ) (* end of LambdaTypes.SWITCH *)
d3529 10
d3541 5
d3551 1
a3551 1
		  map (fn (longvalid, mv, tree) =>
d3554 5
a3558 5
		            tr_match'(tree,
                                      LambdaUtils.add_match_env((mv, new_lv),
                                                                match_env),
                                      val_env))
		       )
d3560 10
a3569 1
		  Tr_Default default))
d3571 5
d3583 2
a3584 1
                        tr_match'(tree,match_env,val_env)))
d3586 9
a3594 1
                  Tr_Default default)
d3610 7
a3616 3
              map (fn (x,y) => (x, y, 
                LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar(),
                                             LambdaTypes.Option.ABSENT))))
d3648 17
a3664 2
                    tr_match(tree, match_env, env),
                    name_string,ty,LambdaTypes.Option.ABSENT))
d3678 1
a3678 1
  and trans_dec(some_dec, envir,is_toplevel) =
d3691 7
a3697 5
            fun trans_individual_dec(pattern, (lambda_var,lambda_var'), location):
              bool * bool * EnvironTypes.Env * LambdaTypes.binding list 
              * (string * (LambdaTypes.Type * LambdaTypes.Instance ref Datatypes.Option.opt) ref 
                 * (int,int) LambdaTypes.Option.option ref LambdaTypes.Option.opt) LambdaTypes.Option.opt 
              * Datatypes.instance ref Datatypes.Option.opt =
d3699 1
a3699 1
              Absyn.WILDpat => (true, true, Environ.empty_env, [],
d3719 1
a3719 1
                  (false, false, Environ.empty_env,
d3733 1
a3733 1
                             Ty as ref (ty,instance)),_) =>
d3739 3
a3741 1
                              EnvironTypes.LAMB(lambda_var',Option.ABSENT))), [], 
d3753 1
a3753 1
                       (false, one_con, Environ.empty_env,
d3774 1
a3774 1
                       (false, false, Environ.empty_env,
d3791 1
d3806 1
a3806 1
                       val (has_vars, exhaustive, env, lambda_list, 
d3808 1
a3808 1
                         trans_individual_dec(pat, (lv,lv'), location)
d3810 3
a3812 2
                       (has_vars, exhaustive, env, 
                        make_binding'((lv,lv'),debug_info,instance,le,"",location)
d3817 1
a3817 1
                  (Lists.exists (fn (has_vars, _, _, _) => has_vars) 
d3819 1
a3819 1
                   Lists.forall (fn (_, exhaustive, _, _) => exhaustive) 
d3821 1
a3821 1
                   Lists.reducel (fn (env, (_, _, env', _)) => 
d3824 3
d3828 1
a3828 1
                   (fn (l1, (_, _, _, l2)) => l1 @@ l2)
d3845 1
a3845 1
                         val (has_vars, exhaustive, new_env, new_lambda_exp, 
d3847 1
a3847 1
                           trans_individual_dec(pat, (new_lv,new_lv'), location)
d3852 1
a3852 1
                         (has_vars, exhaustive, new_env, 
d3854 1
a3854 1
                                           "Dereferencing a pattern",location)
d3860 1
a3860 1
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location)
d3865 1
a3865 1
                           val (has_vars, _, new_env, new_lambda_exp,
d3867 1
a3867 1
                             trans_individual_dec(pat, (new_lv,new_lv'),location)
d3889 1
a3889 1
                           (has_vars, false, new_env, 
d3891 1
a3891 1
                                          location)
d3900 1
a3900 1
                       val (has_vars, _, new_env, new_lambda_exp,
d3902 1
a3902 1
                         trans_individual_dec(pat, (new_lv,new_lv'),location)
d3916 1
a3916 1
                       (has_vars, false, new_env, (* Never exhaustive *) 
d3918 1
a3918 1
                                      location)
d3923 1
d3926 1
a3926 1
                    trans_individual_dec(typed, (lambda_var,lambda_var'), location)
d3928 1
a3928 1
            | Absyn.LAYEREDpat((valid, Ty as ref (ty,instance)), pat) =>
d3932 2
a3933 2
                       val (_, exhaustive, env, lambda,_,_) = 
                         trans_individual_dec(pat, (lambda_var,lambda_var'), location)
d3937 1
d3951 2
a3952 1
                  val (has_vars, exhaustive, more_env, more_lambda,
d3954 1
a3954 1
                    trans_individual_dec(pat, (lvar,lvar'), location')
d3965 3
a3967 3
			  Info.error error_info (Info.WARNING, location, "Possible attempt to rebind constructor name")))
                  val lambda = trans_exp(" pattern", exp, envir)
                  val (more_env, updated) = case (pat, lambda) of
d3972 2
d3975 2
a3976 2
                   | _ => (more_env, false)
                  val (rest_env, rest_lambda) = trans_valdec(tl,rec_list)
d3980 2
a3981 1
                  (Environ.augment_env(more_env, rest_env),
d3985 2
a3986 1
                      make_binding'((lvar,lvar'),debug_info,instance,lambda,"",location')
d3989 1
a3989 1
            | ([], []) => (Environ.empty_env, [])
d4019 2
a4020 2
                       val (has_vars, exhaustive, env, le, debug_info,instance) = 
                         trans_individual_dec(pat, (lv,lv''),location')
d4033 1
a4033 1
                       (env,lv,debug_info,instance,location')
d4037 2
a4038 2
                       val (has_vars, exhaustive, env, le, debug_info,instance) = 
                         trans_individual_dec(pat, (lv,lv),"")
d4050 1
a4050 1
                       (env,lv,debug_info,instance,"")
d4057 2
d4061 1
d4065 1
d4080 2
a4081 1
                      (fn ((((pat,exp,_),(_,lv'',debug_info,instance,location)),(lv,lv',_,_,_)),
d4084 1
a4084 1
                         val lexp = trans_exp(pat_name pat, exp, trans_env)
d4110 2
a4111 1
                                            trans_exp(pat_name pat, exp, trans_env))
d4114 1
a4114 1
                  (all_env,recletb)
d4120 13
a4132 1
    | Absyn.TYPEdec typeinfo_list => (Environ.empty_env, [])
d4134 24
a4157 16
      let fun trans_single_datatype(_, _, _, v_tref_topt_list) =
	let 
          fun munge((valid as Ident.CON sy, ref ty), _) =
            (Absyn.VALpat ((Ident.LONGVALID (Ident.NOPATH, Ident.VAR sy), 
                            ref (ty,LambdaTypes.Option.ABSENT)),Location.UNKNOWN),
             Absyn.VALexp(Ident.LONGVALID(Ident.NOPATH, valid), ref
                          ty, Location.UNKNOWN,LambdaTypes.Option.ABSENT),
             Location.UNKNOWN)
            | munge _ = Crash.impossible"Absyn.DATATYPE"
	  val valdec_list = map munge v_tref_topt_list
	in
	  trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set), 
                    Environ.empty_env,
                    false)
	end
	val e_l_list = map trans_single_datatype datatypeinfo_list
d4159 5
a4163 4
	(env_from_list e_l_list,
	 Lists.reducel
	 (fn (l1, (_, l2)) => l1 @@ l2)
	 ([], e_l_list))
d4166 1
a4166 1
        trans_dec(dec, envir,false)
d4174 3
a4176 3
	fun do_exns([], env, lambdas) =
	  (env, Lists.reducel (fn (x, y) => y @@ x) ([], lambdas))
	  | do_exns(ex :: exns, env, lambdas) =
d4197 1
a4197 1
                      val Debugger_Types.INFO (i,_) = !debug_info_ref
d4203 1
a4203 2
			      ((ty,false,[]),Debugger_Types.empty_debugger_env)),
		           false)
d4235 1
a4235 1
                                   "Bound to a handler wrapped thing")],
d4242 3
d4247 2
a4248 1
	    do_exns(exns, Environ.augment_env(env, this_env),
d4252 1
a4252 1
	do_exns(except_list, Environ.empty_env, [])
d4267 4
a4270 3
	val (local_env, local_lambda) = trans_dec(dec1, envir,false)
	val (main_env, main_lambda) =
	  trans_dec(dec2, Environ.augment_env(envir, local_env),false)
d4272 1
a4272 1
	(main_env, local_lambda @@ main_lambda)
d4284 2
a4285 2
	 fun trans_open([], new_env, new_lambdas) = (new_env, new_lambdas)
	 | trans_open(longstrid :: tl, new_env, new_lambdas) =
d4287 2
a4288 2
	     val ((EnvironTypes.ENV(valid_env, strid_env),
                   lambda_exp), longstrid') =
d4290 7
a4296 2
	     val valid_map = map (fn (v, c) => (v, c, LambdaTypes.new_LVar()))
	       (NewMap.to_list valid_env)
d4298 1
a4298 2
	       (fn (s, ec) => (s, ec, LambdaTypes.new_LVar()))
	       (NewMap.to_list strid_env)
d4322 2
a4323 2
	       (fn (env, (s, (e, c), l)) =>
		Environ.add_strid_env(env, (s, (e, EnvironTypes.LAMB(l,longstrid')))))
d4338 1
a4338 1
	       (fn (_, (_, EnvironTypes.FIELD(field)), l) =>
d4340 1
a4340 1
             | (_, (_, EnvironTypes.PRIM prim ), l) => 
d4345 1
a4345 1
	     trans_open(tl, new_s_env,
d4349 1
a4349 1
	 trans_open(longStrId_list, Environ.empty_env, [])
d4358 2
a4359 1
	trans_sequence_dec(envir, Environ.empty_env, [], dec_list,is_toplevel)
d4362 4
a4365 3
  and trans_sequence_dec(_, new_env, bindings, [],_) =
    (new_env, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
    | trans_sequence_dec(old_env, new_env, bindings, dec :: dec_list,is_toplevel) =
d4367 1
a4367 1
	val (env, lambda) = trans_dec (dec, old_env,is_toplevel)
d4371 3
a4373 1
			   lambda :: bindings, dec_list,is_toplevel)
d4377 2
a4378 1
	(strexp, top_env as EnvironTypes.TOP_ENV(env, fun_env), basis) =
d4381 2
a4382 1
    let val (env, lv_le_list) = trans_str_dec(strdec, top_env, basis,false)
d4386 1
a4386 1
      (env, lambda_exp)
d4388 24
a4411 3
  | Absyn.OLDstrexp (longstrid,_) =>
      #1(cg_longstrid(longstrid, env))
  | Absyn.APPstrexp(funid as Ident.FUNID sy, strexp, coerce, _) =>
d4413 7
a4419 4
      val (lv, result_env) = Environ.lookup_funid(funid, fun_env)
      val argument as (env, arg) = trans_str_exp(strexp, top_env, basis)
      val Basis.BasisTypes.PHI (_, (interface, _)) =
	Basis.lookup_funid (funid, basis)
d4424 28
a4451 8
	complete_struct(argument, LambdaTypes.Option.PRESENT interface, !coerce)
    in
      (result_env,
       LambdaTypes.APP
       (case lv of
	  EnvironTypes.LAMB (lv,_) => 
            (LambdaTypes.VAR lv, new_arg,
             LambdaTypes.Option.ABSENT)
d4453 1
a4453 1
	    (LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_FUNCT,
d4455 3
a4457 1
                             LambdaTypes.Option.ABSENT),
d4460 21
a4480 2
	| EnvironTypes.PRIM _ => Crash.impossible "APPstrexp(1)"
	| EnvironTypes.FIELD _ => Crash.impossible "APPstrexp(2)"))
d4483 4
a4486 2
    let val (local_env, local_lambdas) = trans_str_dec(strdec, top_env, basis,false)
      val (new_env, new_lambda) =
d4489 2
a4490 1
		      basis)
d4492 3
a4494 1
      (new_env, let_lambdas_in_exp(local_lambdas, new_lambda))
d4497 2
a4498 1
  and trans_str_dec(strdec, top_env as EnvironTypes.TOP_ENV(env, fun_env), basis,is_toplevel) =
d4500 1
a4500 1
    Absyn.DECstrdec dec =>
d4502 2
d4505 1
a4505 1
         val (env,bindings) = trans_dec(dec, env,is_toplevel)
d4509 2
d4512 2
a4513 1
         (env, map (fn (lvar,exn_string) =>
d4522 8
d4539 1
a4539 1
      [] => (Environ.empty_env, [])
d4542 3
a4544 3
      fun trans_structs(aug_env, bindings, []) = (aug_env, rev bindings)
      | trans_structs(aug_env, bindings,
		      (strid, sigexp_opt, strexp, coerce, _) :: rest) =
d4550 2
d4553 1
a4553 1
            complete_struct(trans_str_exp(strexp, top_env, basis),
d4555 1
a4555 1
			    !coerce)
d4561 8
a4568 3
					  EnvironTypes.LAMB (lambda_var,Option.ABSENT)))),
           LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), lambda_exp,"") 
           :: bindings, rest)
d4571 1
a4571 1
      trans_structs(Environ.empty_env, [], struct_dec_list)
d4577 1
a4577 1
      [] => (Environ.empty_env, [])
d4580 3
a4582 3
      fun trans_structs(aug_env, bindings, []) = (aug_env, rev bindings)
      | trans_structs(aug_env, bindings,
		      (strid, sigexp_opt, strexp, coerce, _) :: rest) =
d4588 2
d4591 3
a4593 2
            complete_struct(trans_str_exp(strexp, top_env, basis),
			    inte_opt, !coerce)
d4599 8
a4606 2
					  EnvironTypes.LAMB(lambda_var,Option.ABSENT)))),
           LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), lambda_exp,"") :: bindings, rest)
d4609 1
a4609 1
      trans_structs(Environ.empty_env, [], struct_dec_list)
d4613 3
a4615 2
      val (local_env, local_lambda) = trans_str_dec(strdec1, top_env, basis,false)
      val (main_env, main_lambda) =
d4619 2
a4620 2
	   basis,
           false)
d4622 1
a4622 1
      (main_env, local_lambda @@ main_lambda)
d4626 2
a4627 1
      trans_sequence_strdec(top_env, Environ.empty_env, [], strdec_list, basis,is_toplevel)
d4629 2
a4630 2
  and trans_sequence_strdec(old_env, new_env, bindings, [], basis,is_toplevel) =
    (new_env, Lists.reducel (fn (x, y) => y @@ x) ([], bindings))
d4632 1
a4632 1
	(old_env, new_env, bindings, decs :: dec_list, basis,is_toplevel) =
d4634 1
a4634 1
	val (env, new_bindings) = trans_str_dec(decs, old_env, basis,is_toplevel)
d4638 3
a4640 1
			      Environ.augment_env(new_env, env),
d4642 1
a4642 2
			      basis,
                              is_toplevel)
d4647 2
a4648 1
	   (funid, strid, sigexp, strexp, sigexp_opt, annotation_string, coerce, _),
d4650 1
a4650 1
	 basis) =
d4652 1
d4654 5
a4658 2
      val env = Environ.make_str_env interface
      val lvar = LambdaTypes.new_LVar()
d4664 4
a4667 3
      val (str_env, lambda_exp) =
	complete_struct
	(trans_str_exp
d4674 20
a4693 2
						EnvironTypes.LAMB(lvar,Option.ABSENT)))))),
	   basis),
d4695 1
a4695 1
	 !coerce)
d4697 36
d4734 1
a4734 1
      (EnvironTypes.TOP_ENV
d4739 6
a4744 3
	  (EnvironTypes.LAMB(lambda_var,Option.ABSENT),  str_env)))),
       [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), LambdaTypes.FN(lvar, lambda_exp,annotation_string,LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
                        "")])
d4746 4
a4749 3

  fun trans_fun_dec([], _, _) = (make_top_env Environ.empty_env, [])
    | trans_fun_dec(funbind :: rest, top_env, basis) =
d4751 3
a4753 3
        val (new_env, new_lambda) =
	  trans_individual_funbind(funbind, top_env, basis)
        val (rest_env, rest_lambda) = trans_fun_dec(rest, top_env, basis)
d4755 2
a4756 1
        (Environ.augment_top_env(new_env, rest_env), new_lambda @@ rest_lambda)
d4759 3
a4761 2
  fun trans_fun_dec_list([], _, _) = (make_top_env Environ.empty_env, [])
    | trans_fun_dec_list((Absyn.FUNBIND funbind):: rest, top_env, basis) =
d4763 4
a4766 3
        val (new_env, new_lambda) = trans_fun_dec(funbind, top_env, basis)
        val (rest_env, rest_lambda) =
          trans_fun_dec_list(rest, Environ.augment_top_env(top_env, new_env), basis)
d4770 2
a4771 1
        (Environ.augment_top_env(new_env, rest_env), new_lambda @@ rest_lambda)
d4774 4
a4777 1
  val (a,b) = 
d4781 2
a4782 1
          val (new_env, lambdas) = trans_str_dec(strdec, top_env, basis,true)
d4784 1
a4784 1
          (make_top_env new_env, lambdas)
d4787 1
a4787 1
        (make_top_env Environ.empty_env, [])
d4789 1
a4789 1
        trans_fun_dec_list(funbind_list, top_env, basis)
d4792 27
d4822 1
a4822 1
      (a,b,result_debug_info)
@


1.145
log
@Dynamic pattern-redundancy reporting;
Correct Exception Pattern Matching
@
text
@d4 4
d1105 6
a1110 3
    (Options.OPTIONS{print_options,
                     compiler_options = Options.COMPILEROPTIONS{debug_variables,
                                                                debug_polyvariables,...}, ...},
a1112 1
     generate_debug,
d2704 14
a2719 11
                    val _ =
                      (* try always generating debug info for exceptions *)
                      if true (* generate_debug *) then
                        let
                          val Debugger_Types.INFO (i,_) = !debug_info_ref
                        in
                          debug_info_ref :=
                            Debugger_Types.INFO
			      (NewMap.define(i, exn_string, ((ty,false,[]),Debugger_Types.empty_debugger_env)),false)
                        end
                      else ()
@


1.144
log
@ Changed so inexhaustive bindings are only reported if not at top level.
@
text
@d4 3
d447 1
d466 1
d679 1
a679 1
	EnvironTypes.LAMB lvar => (env', LambdaTypes.VAR lvar)
d690 16
d715 9
d731 1
a731 1
	 EnvironTypes.LAMB lvar => LambdaTypes.VAR lvar
d756 29
a784 1
  val cg_longexid = cg_longvalid
d789 2
a790 2
	 (env, EnvironTypes.LAMB lvar) => (env, LambdaTypes.VAR lvar)
       | (env, EnvironTypes.PRIM prim) => (env, LambdaTypes.BUILTIN prim)
d792 1
a792 1
	   (env,
d796 1
a796 1
	     LambdaTypes.Option.ABSENT))
d801 2
a802 2
      val (env', lambda) =
	Ident.followPath'(get_lamb_env, get_field_env) (path, env)
d804 1
a804 1
      case Environ.lookup_strid(strid, env') of
d812 2
a813 1
	  Crash.impossible "cg_longstrid gets external at end of longstrid"
d842 2
a843 2
  fun print_redundancy_info (error_info,print_options,[], _, _) = ()
    | print_redundancy_info (error_info,print_options,clauses, pat_exp_list, location) =
a845 1
        (* assume to_show is unordered *)
d847 29
a875 15
        fun to_string (to_mark, patterns) =
          let
            fun show(n, to_mark, [], string) = string
              | show(n, to_mark, p::l, string) =
                show(n+1, to_mark, l,
                     string ^ "\n" ^
                     (if Lists.member (n, to_mark) then
                        "  ->  "
                      else
                        "      ") ^
                     AbsynPrint.unparsePat print_options p ^
                     " => ...")
          in
            show(1, to_mark, patterns, "Redundant patterns in match:")
          end
d877 2
a878 2
        Info.error error_info (Info.WARNING, location,to_string (clauses, map (fn (x,_,_) => x) pat_exp_list))
      end   
d1052 1
a1052 1
    fun extract_op (EnvironTypes.LAMB x) = LambdaTypes.VAR x
d1110 11
d1371 1
a1371 1
                   let val le = cg_longexid(longValId, env)
d1508 1
d1510 33
a1542 19
                           trans_exp(annotation, exp, env),
                           let
                             val (root, tree,redundant_clauses,not_exhaustive) =
                               Match.compile_match pat_exp_list
                           in
                             if !show_match then
                               (Print.print"Exception match tree is\n";
                                Lists.iterate
                                (fn x => output (std_out,x)) (Match.unparseTree print_options tree "");
                                Print.print"\n";
                                ())
                             else ();
                               case redundant_clauses of
                                 [] => ()
                               | r => print_redundancy_info (error_info,print_options,r,pat_exp_list,location);
                                   trans_match((root, tree), env, true,
                                               annotation,LambdaTypes.null_type_annotation)
                           end,
                         annotation)
d1577 4
a1580 1
		  Types.print_type print_options ty ^ " : ",
d1586 20
a1605 4
               case redundant_clauses of
                 [] => ()
               | r => print_redundancy_info (error_info,print_options,r,pat_exp_list,location);
                   trans_match((root, tree), env, false,name_string,!ty)
d1652 2
a1653 1
        and trans_match((root, tree), env, is_exn, name_string,ty) =
d1670 171
d1842 15
a1856 9
             let fun Let_Lambdas_In_Exp lambda_exp binding =
                    case binding of
                     ref(Match.Option.ABSENT) => lambda_exp()
                    |ref(Match.Option.PRESENT(binding)) => 
                   let_lambdas_in_exp 
                      ([(fn lvar as ref(Match.Option.SOME1(_,tree)) => 
                         let 
                           val lv =  LambdaTypes.new_LVar()
                         in
d1859 4
a1862 4
                           (LambdaTypes.Option.SOME1(lv),
                            LambdaTypes.FN(LambdaTypes.new_LVar(), 
	                      tr_match(tree,match_env, val_env),
                                "Part of match translation ("
d1864 31
a1894 8
                                ^") " ^ name_string,
                                LambdaTypes.null_type_annotation,LambdaTypes.Option.ABSENT),
                            "Translation of match trees"))
                          end
                            |   _ => 
                             Crash.impossible "Let_Lambdas_In_Exp:Match_translator:_lambda.sml")
                                      binding],
                       lambda_exp())
d1898 1
a1898 2
	                    LambdaTypes.APP(
                                            LambdaTypes.VAR(lvar),
d1906 1
a1906 1
                     |   Tr_Default _ = Crash.impossible "Tr_Default:tr_match:_lambda.sml"
d1909 8
a1916 2
                       Match.PRESENT(default) => Tr_Default default
                      |Match.ABSENT => LambdaTypes.Option.ABSENT
d1939 1
a1939 1
                                                                EnvironTypes.LAMB(lv)))))
d1942 1
a1942 1
                                                                EnvironTypes.LAMB(lv)))))
d1945 1
a1945 1
                                                                EnvironTypes.LAMB(lv))))
d1953 1
a1953 1
                                                                EnvironTypes.LAMB(lv)))))
d1955 1
a1955 1
                                                                EnvironTypes.LAMB(lv)))))
d1970 1
a1970 1
	                   scon_tree_list,Tr_Default (Match.PRESENT(default)))
d1972 4
a1975 1
                    Let_Lambdas_In_Exp lambda_exp binding
d1977 1
a1977 1
      | Match.CONSTRUCTOR(ty, mv, longvalid_mv_tree_list, default, binding) =>
d2003 5
a2007 1
	  val new_lv = LambdaTypes.new_LVar()
d2016 9
d2041 1
a2041 1
	                   tr_match(
a2047 7
                let 
                  val new_lv = 
                    if debug_somevariables then 
                      LambdaTypes.Option.SOME2(ref(new_lv,LambdaTypes.Option.ABSENT))
                    else 
                      LambdaTypes.Option.SOME1(new_lv)
                in
d2049 3
a2051 5
                  tr_match(
		   tree,
		   LambdaUtils.add_match_env((mv, new_lv), match_env),
		   val_env))
                end)
d2054 1
a2054 1
               tr_match(tree, match_env, val_env)
d2091 4
a2094 4
		            tr_match(tree,
			             LambdaUtils.add_match_env((mv, ref_lv),
			                                       match_env),
			             val_env)
d2103 4
a2106 4
		        tr_match(tree,
			         LambdaUtils.add_match_env((mv, ORIG_LV),
				 			   match_env),
		                 val_env)
d2115 1
a2115 1
		      tr_match(tree, match_env, val_env)
a2132 7
            let 
              val new_lv = 
                if debug_somevariables then 
                  LambdaTypes.Option.SOME2(ref(new_lv,LambdaTypes.Option.ABSENT))
                else
                  LambdaTypes.Option.SOME1(new_lv)
            in
d2142 5
a2146 5
			    select_exn_unique(cg_longexid(longvalid, val_env))),
		            tr_match(tree,
			             LambdaUtils.add_match_env((mv, new_lv),
		                                               match_env),
		  	             val_env))
d2150 11
a2160 1
            end
d2162 9
a2170 6
	  case is_exn of
	    false => (* Not an exception constructor *) 
              Let_Lambdas_In_Exp lambda_exp1 binding
	  | true =>
	      (* Is an exception constructor *)
                Let_Lambdas_In_Exp lambda_exp2 binding
d2208 4
a2211 3
    LambdaTypes.FN(root_lambda,
      tr_match(tree, match_env, env),
                    name_string,ty,LambdaTypes.Option.ABSENT)
d2284 1
a2284 1
                              EnvironTypes.LAMB(lambda_var'))), [], 
d2327 1
a2327 1
                                           [(LambdaTypes.EXP_TAG(cg_longexid(longvalid, envir)),
d2449 1
a2449 1
                                           [(LambdaTypes.EXP_TAG(cg_longexid(longvalid, envir)),
d2473 1
a2473 1
                                                   (valid, EnvironTypes.LAMB(lambda_var'))),
d2696 1
a2696 5
	    val this_env =
	      Environ.add_valid_env (Environ.empty_env,
				     (v, EnvironTypes.LAMB lv))

	    val this_lambda =
d2698 1
a2698 1
		val lambda_exp =
a2699 1
		    val string_exp = LambdaTypes.SCON(Ident.STRING exn_string)
d2714 11
a2724 5
			LambdaTypes.STRUCT
			[LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
					 LambdaTypes.STRUCT[],
                                         LambdaTypes.Option.ABSENT),
			 string_exp]
d2726 8
a2733 3
			LambdaTypes.STRUCT
			[select_exn_unique(cg_longexid(longv, envir)),
			 string_exp]
d2736 3
a2738 2
		[LambdaTypes.LETB(LambdaTypes.Option.SOME1(lv), lambda_exp,
				  "Bound to a handler wrapped thing")]
d2740 5
d2784 2
a2785 2
	     val (EnvironTypes.ENV(valid_env, strid_env),
		  lambda_exp) =
d2792 16
d2809 1
a2809 1
               | identity_if_builtin (_,y) = EnvironTypes.LAMB y
d2816 1
a2816 1
		Environ.add_strid_env(env, (s, (e, EnvironTypes.LAMB(l)))))
d2875 2
a2876 1
  | Absyn.OLDstrexp (longstrid,_) => cg_longstrid(longstrid, env)
d2892 1
a2892 1
	  EnvironTypes.LAMB lv => 
d2916 24
a2939 1
    Absyn.DECstrdec dec => trans_dec(dec, env,is_toplevel)
d2962 1
a2962 1
					  EnvironTypes.LAMB lambda_var))),
d2992 1
a2992 1
					  EnvironTypes.LAMB lambda_var))),
d3052 1
a3052 1
						EnvironTypes.LAMB lvar))))),
d3063 1
a3063 1
	  (EnvironTypes.LAMB lambda_var,  str_env)))),
@


1.143
log
@Fixed layered patterns to generate binding inexhaustive warnings when necessary
@
text
@d4 3
d1337 1
a1337 1
          val (env', lambda_list) = trans_dec (decl, env)
d1888 1
a1888 1
  and trans_dec(some_dec, envir) =
d2154 1
a2154 1
                    if exhaustive then ()
d2158 1
a2158 1
                    if has_vars then ()
d2322 2
a2323 1
                    Environ.empty_env)
d2333 1
a2333 1
        trans_dec(dec, envir)
d2416 1
a2416 1
	val (local_env, local_lambda) = trans_dec(dec1, envir)
d2418 1
a2418 1
	  trans_dec(dec2, Environ.augment_env(envir, local_env))
d2486 1
a2486 1
	trans_sequence_dec(envir, Environ.empty_env, [], dec_list)
d2489 1
a2489 1
  and trans_sequence_dec(_, new_env, bindings, []) =
d2491 1
a2491 1
    | trans_sequence_dec(old_env, new_env, bindings, dec :: dec_list) =
d2493 1
a2493 1
	val (env, lambda) = trans_dec (dec, old_env)
d2497 1
a2497 1
			   lambda :: bindings, dec_list)
d2504 1
a2504 1
    let val (env, lv_le_list) = trans_str_dec(strdec, top_env, basis)
d2539 1
a2539 1
    let val (local_env, local_lambdas) = trans_str_dec(strdec, top_env, basis)
d2548 1
a2548 1
  and trans_str_dec(strdec, top_env as EnvironTypes.TOP_ENV(env, fun_env), basis) =
d2550 1
a2550 1
    Absyn.DECstrdec dec => trans_dec(dec, env)
d2611 1
a2611 1
      val (local_env, local_lambda) = trans_str_dec(strdec1, top_env, basis)
d2616 2
a2617 1
	   basis)
d2623 1
a2623 1
      trans_sequence_strdec(top_env, Environ.empty_env, [], strdec_list, basis)
d2625 1
a2625 1
  and trans_sequence_strdec(old_env, new_env, bindings, [], basis) =
d2628 1
a2628 1
	(old_env, new_env, bindings, decs :: dec_list, basis) =
d2630 1
a2630 1
	val (env, new_bindings) = trans_str_dec(decs, old_env, basis)
d2636 2
a2637 1
			      basis)
d2705 1
a2705 1
          val (new_env, lambdas) = trans_str_dec(strdec, top_env, basis)
@


1.142
log
@Added location information to COERCEexp.
@
text
@d4 3
d2129 1
a2129 1
                       val (_, _, env, lambda,_,_) = 
d2132 1
a2132 1
                       (true, true, Environ.add_valid_env(env,
@


1.141
log
@Added the symbol name to the "Unresolved overloading" error message.
@
text
@d4 3
d1499 1
a1499 1
      | Absyn.COERCEexp (exp,_,ref atype) =>
@


1.140
log
@Added fixity annotations to absyn.
@
text
@d4 3
d1159 2
a1160 1
                                 (Info.FATAL, location, "Unresolved overloading")
@


1.139
log
@Merging in code change.
@
text
@d4 3
d1333 1
a1333 1
    | Absyn.APPexp(fun_exp, val_exp,_,annotation) =>
d2020 1
a2020 1
            | Absyn.APPpat((longvalid, ref ty), pat,_) => 
@


1.138
log
@Polymorphic debugger;
instances of polymorphic functions are passed round at runtime.
@
text
@d4 4
d834 2
a835 2
      val (v_f_list_fn, next) =
	Lists.number_with_size
d837 3
a839 8
	   (v_list, NewMap.domain_ordered vm,
	    IdentPrint.debug_printValId, IdentPrint.debug_printValId),
	 0,
	 EnvironTypes.FIELD)

      val (s_f_list_fn, size) =
	Lists.number_with_size
	(str_filter_ordered_map
d841 1
a841 3
	  IdentPrint.printStrId), next, EnvironTypes.FIELD)
      val v_f_list = v_f_list_fn size
      val s_f_list = s_f_list_fn size
@


1.137
log
@Tidied up debug information stuff
Debug information for exceptions is now always generated.
@
text
@d4 4
d423 2
d519 1
a519 1
      LambdaTypes.null_type_annotation)
d528 1
a528 1
		     LambdaTypes.null_type_annotation)
d787 1
a787 2
      end
   
d908 1
a908 1
                                 LambdaTypes.null_type_annotation)
d1018 2
a1019 1
                     compiler_options = Options.COMPILEROPTIONS{debug_variables,...}, ...},
d1026 82
a1109 1

a1116 4
      fun valid_to_string (Ident.VAR(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.CON(sym)) = Ident.Symbol.symbol_name(sym)
        | valid_to_string (Ident.EXCON(sym)) = Ident.Symbol.symbol_name(sym)

d1132 1
a1132 1
          | Absyn.VALexp(longValId, ty' as ref ty,location) =>
d1165 1
a1165 1
                     val new_cg =
d1167 1
a1167 1
                         LambdaTypes.BUILTIN Pervasives.IDENT_FN => ident_code()
d1213 13
a1225 2
                             end)
                       | _ => cg
d1227 16
a1242 1
                     new_cg
d1269 1
a1269 1
                                LambdaTypes.null_type_annotation)
d1284 2
a1285 1
                                        LambdaTypes.null_type_annotation)
d1377 1
a1377 1
                Absyn.VALexp(_, ref ty,_) => ty
d1395 1
a1395 1
              LambdaTypes.FN(var,body,_,_) =>
d1524 4
d1554 4
a1557 2
                                "Part of match translation (i) " ^ name_string,
                                LambdaTypes.null_type_annotation),
a1575 1
                     (*|   Tr_Default (ref(Match.UNBUILT'(_))) = LambdaTypes.Option.PRESENT(excp)*)
d1591 2
a1592 1
                             if debug_variables then
d1600 1
a1600 1
                                             (Symbol.symbol_name symbol,ty))),
d1611 1
d1615 1
a1615 1
                                             (Symbol.symbol_name symbol,ty));
d1698 1
a1698 1
                    if debug_variables then 
d1735 1
a1735 1
                            if debug_variables then 
d1792 1
a1792 1
                if debug_variables then 
d1826 1
a1826 1
            if debug_variables then 
d1861 1
a1861 1
                    name_string,ty)
d1884 1
d1887 2
a1888 1
            fun trans_individual_dec(pattern, lambda_var):
d1890 3
a1892 1
              * (string * LambdaTypes.Type ref) LambdaTypes.Option.opt =
d1895 1
d1925 1
a1925 1
                   ],LambdaTypes.Option.ABSENT)
d1928 1
a1928 1
                             Ty as ref ty),_) =>
d1933 2
a1934 2
                          (true, true, Environ.add_valid_env(Environ.empty_env, (valid,
                              EnvironTypes.LAMB(lambda_var))), [], 
d1936 2
a1937 1
                                                        Ty))
d1960 1
a1960 1
                        ], LambdaTypes.Option.ABSENT)
d1981 2
a1982 1
                                          "")],LambdaTypes.Option.ABSENT)
d1997 4
a2000 2
                       val (has_vars, exhaustive, env, lambda_list, debug_info) =
                         trans_individual_dec(pat, lv)
d2003 2
a2004 6
                        LambdaTypes.LETB(if debug_variables then 
                                           LambdaTypes.Option.SOME2(ref(lv,debug_info))
                                         else
                                           LambdaTypes.Option.SOME1(lv),
                                           le,"")
                        :: lambda_list)
d2017 2
a2018 1
                   ([], env_list_lambda_list_list),LambdaTypes.Option.ABSENT)
d2030 3
a2032 1
                       let val new_lv = LambdaTypes.new_LVar()
d2034 5
a2038 2
                              debug_info) =
                           trans_individual_dec(pat, new_lv)
d2040 5
a2044 10
                         (has_vars, exhaustive, new_env,
                          LambdaTypes.LETB(if debug_variables then 
                                             LambdaTypes.Option.SOME2(ref(new_lv,debug_info))
                                           else
                                             LambdaTypes.Option.SOME1(new_lv),
                                            LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                            LambdaTypes.VAR lambda_var,
                                                            LambdaTypes.Option.ABSENT),
                                           "Dereferencing a pattern")
                          :: new_lambda_exp,LambdaTypes.Option.ABSENT)
d2048 1
a2048 1
                         trans_individual_dec(pat, lambda_var)
d2052 4
a2055 2
                           val (has_vars, _, new_env, new_lambda_exp,debug_info) =
                             trans_individual_dec(pat, new_lv)
d2058 1
a2058 7
                         in
                           (has_vars, false, new_env,
                            LambdaTypes.LETB(if debug_variables then 
                                               LambdaTypes.Option.SOME2(ref(new_lv,debug_info))
                                             else
                                               LambdaTypes.Option.SOME1(new_lv),
                                             LambdaTypes.SWITCH(
d2075 7
a2081 3
                                     ),
                                             "")
                            :: new_lambda_exp,LambdaTypes.Option.ABSENT)
d2085 6
a2090 3
                     let val new_lv = LambdaTypes.new_LVar()
                       val (has_vars, _, new_env, new_lambda_exp,debug_info) =
                         trans_individual_dec(pat, new_lv)
d2092 3
a2094 9
                     in
                       (has_vars, false, new_env, (* Never exhaustive *)
                        LambdaTypes.LETB(if debug_variables then 
                                           LambdaTypes.Option.SOME2(ref(new_lv,debug_info))
                                         else
                                           LambdaTypes.Option.SOME1(new_lv),
                                         LambdaTypes.SWITCH(
                                                            GetConTag lexp,
                                                            LambdaTypes.Option.PRESENT{
d2102 7
a2108 1
                                                            ), "") :: new_lambda_exp,
d2112 2
a2113 1
            | Absyn.TYPEDpat(typed, _,_) => trans_individual_dec(typed, lambda_var)
d2115 1
a2115 1
            | Absyn.LAYEREDpat((valid, Ty as ref ty), pat) =>
d2119 2
a2120 2
                       val (_, _, env, lambda,_) = 
                         trans_individual_dec(pat, lambda_var)
d2123 1
a2123 1
                                                   (valid, EnvironTypes.LAMB(lambda_var))),
d2125 2
a2126 1
                                                          Ty))
d2135 5
a2139 2
                  val (has_vars, exhaustive, more_env, more_lambda,debug_info) = 
                    trans_individual_dec(pat, lvar)
d2166 3
a2168 6
                    else
                      LambdaTypes.LETB(if debug_variables then 
                                         LambdaTypes.Option.SOME2(ref(lvar,debug_info))
                                       else
                                         LambdaTypes.Option.SOME1(lvar),lambda,"")
                      :: new_bindings))
d2174 1
a2174 1
                    if debug_variables then 
d2177 7
a2183 3
                     (LambdaTypes.Option.SOME2(ref(LambdaTypes.new_LVar(),
                                                   LambdaTypes.Option.ABSENT)), 
                      pat, exp, location))
d2187 6
a2192 3
                    (fn (pat, exp, location) => 
                     (LambdaTypes.Option.SOME1(LambdaTypes.new_LVar()), 
                      pat, exp, location))
d2196 2
a2197 1
                    (fn (LambdaTypes.Option.SOME2(lv' as ref(lv,_)), pat, _, location) =>
d2199 3
a2201 2
                       val (has_vars, exhaustive, env, le, debug_info) = 
                         trans_individual_dec(pat, lv)
d2214 1
a2214 1
                       (env,debug_info)
d2216 1
a2216 1
                  | (LambdaTypes.Option.SOME1(lv), pat, _, location) =>
d2218 2
a2219 2
                       val (has_vars, exhaustive, env, le, debug_info) = 
                         trans_individual_dec(pat, lv)
d2231 3
a2233 2
                       (env,debug_info)
                     end)
d2252 36
a2287 4
                  val exp_list = map
                    (fn (pat,exp,_) => 
                                  trans_exp(pat_name pat, exp, trans_env))
                    rec_list
d2289 1
a2289 2
                  (all_env,
                   [LambdaTypes.RECLETB(map #1 lv_pat_exp_list, exp_list)])
d2301 1
a2301 1
                            ref ty),Location.UNKNOWN),
d2303 1
a2303 1
                          ty, Location.UNKNOWN),
d2358 1
a2358 1
                          val Debugger_Types.INFO i = !debug_info_ref
d2362 1
a2362 1
			      (NewMap.define(i, exn_string, ((ty,false,[]),Debugger_Types.empty_debugger_env)))
d2659 1
a2659 1
       [LambdaTypes.LETB(LambdaTypes.Option.SOME1(lambda_var), LambdaTypes.FN(lvar, lambda_exp,annotation_string,LambdaTypes.null_type_annotation),
@


1.137.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.137  1993/08/24  12:12:39  matthew
Tidied up debug information stuff
Debug information for exceptions is now always generated.

@


1.137.1.2
log
@Added and used a new function, number_envs, to replace all uses of
Lists.number_with_size, a function which was too inefficient (and ugly).
/
@
text
@a3 3
Revision 1.137.1.1  1993/08/24  12:12:39  jont
Fork for bug fixing

d829 15
a843 8
       val (v_f_list,s_f_list,_) =
	 Environ.number_envs
	 (val_filter_ordered_map
	  (v_list, NewMap.domain_ordered vm,
	   IdentPrint.debug_printValId, IdentPrint.debug_printValId),
	  str_filter_ordered_map
	  (Ident.strid_eq, s_list, map #1 ordered_int_map,
	   IdentPrint.printStrId), [])
@


1.136
log
@Added further error message for inexhaustive binding without variables
@
text
@d4 3
a439 4
  val generate_debug_info = ref false
  val empty_debug_information = Debugger_Types.INFO (NewMap.empty' String.<)
  val debug_information = ref empty_debug_information

d1017 1
a1017 1
     debug_info,
d1020 2
d2186 2
a2187 1
                      if ! generate_debug_info then
d2189 1
a2189 1
                          val Debugger_Types.INFO i = !debug_information
d2191 1
a2191 1
                          debug_information :=
a2515 4
  val _ = generate_debug_info := generate_debug
  val _ = if generate_debug
            then debug_information := debug_info
          else ()
d2531 1
a2531 2
  val result_debug_info = ! debug_information
  val _ = debug_information := empty_debug_information
@


1.135
log
@Added location information to matches
@
text
@d4 3
d2015 4
a2018 1
                      Info.error error_info (Info.WARNING, location, "Binding has no variables")
@


1.134
log
@Local and closure variable inspection in the debugger;
new compiler option debug_variables; changed types of constructors
LET, LETREC, LETB, and Tags.
@
text
@d4 5
d778 1
a778 1
        Info.error error_info (Info.WARNING, location,to_string (clauses, map (fn (x,_) => x) pat_exp_list))
@


1.133
log
@Tidied up inexhaustive match output to remove excessive new lines
@
text
@d4 3
d8 1
a8 1
 More informative inexhaustiveness reporting
d353 1
d400 2
d406 2
a407 1
  sharing type Debugger_Types.Type = LambdaUtils.LambdaTypes.Type = Types.Datatypes.Type
d432 1
a432 1
 
d496 1
a496 2
    LambdaTypes.FN(
      l,
d499 1
a499 1
	LambdaTypes.PRESENT {lv = l (* dummy_value *),
d502 3
a504 3
	[(LambdaTypes.IMM_TAG 1, LambdaTypes.INT 0),
	  (LambdaTypes.IMM_TAG 0, LambdaTypes.INT 1)],
	LambdaTypes.ABSENT),
a581 8
  fun print_list print_fn (list, sep, start, finish) =
    case list of
      [] => start ^ finish
    | (x :: xs) =>
	Lists.reducel
	(fn (str, elem) => str ^ sep ^ print_fn elem)
	(start ^ print_fn x, xs) ^ finish

d648 1
a648 1
	    LambdaTypes.null_type_annotation))
d678 1
a678 1
			   LambdaTypes.null_type_annotation)
d706 1
a706 1
	       LambdaTypes.null_type_annotation))
d911 1
a911 1
		  (lv,
d916 1
a916 1
                LambdaTypes.LETB(lv,coerce (valid,LambdaTypes.BUILTIN prim),"")
d926 1
a926 1
		  (lv, 
d929 1
a929 1
			(lv',
d981 2
a982 2
      LambdaTypes.ABSENT => result
    | LambdaTypes.PRESENT inte =>
d991 1
a991 1
	     LambdaTypes.do_binding(LambdaTypes.LETB(new_lv, lambda_exp,""),
d997 1
a997 1
        (Absyn.NEWsigexp(_, ref (Absyn.PRESENT str))) = str
d999 1
a999 1
        (Absyn.OLDsigexp(_, ref (Absyn.PRESENT str),_)) = str
d1005 2
a1006 1
    (Options.OPTIONS{print_options,...},
d1021 7
a1027 1
        fun trans_exp(name, x, env) =
d1040 1
a1040 1
          | Absyn.VALexp(longValId, ref ty,location) =>
d1063 2
a1064 1
                                 Info.error' error_info (Info.FATAL, location, "Unresolved overloading")
d1069 1
a1069 1
                                                      Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name))),
d1077 1
a1077 1
                           if (* cg <> eq_prim *) isnt_eq_prim cg
d1121 1
a1121 1
                             end
d1151 1
a1151 1
                            LambdaTypes.null_type_annotation)
d1163 2
a1164 1
                         LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],
d1176 1
a1176 1
              let
d1187 2
a1188 1
                        trans_exp (" no_name", exp, env))) label_exp_list
d1191 1
a1191 1
                                        LambdaTypes.LETB(lv, le,
a1205 1
            
d1210 1
a1210 1
                             trans_exp(" no_name", exp, Environ.augment_env(env, env')))
d1214 4
a1217 3
    | Absyn.APPexp(fun_exp, val_exp,_,ref annotation) =>
        let
          val fcn = trans_exp(" inline_app", fun_exp, env)
d1225 1
d1228 2
a1229 1
              val arg = trans_exp(" no_name", val_exp, env)
d1250 1
a1250 1
            else (LambdaTypes.INT 0, LambdaTypes.INT 1)
d1262 1
a1262 1
                  LambdaTypes.PRESENT false_val
d1264 1
a1264 1
                  LambdaTypes.ABSENT
d1268 1
a1268 1
               LambdaTypes.PRESENT {lv = LambdaTypes.new_LVar(),
d1271 1
a1271 1
               [(LambdaTypes.IMM_TAG tag, true_val)],
d1277 2
a1278 1
                LambdaTypes.LET(var,arg,body)
d1280 1
a1280 1
                                   annotation)  (***)
d1284 2
a1285 1
    | Absyn.TYPEDexp (expression, _,_) => trans_exp(" no_name", expression, env)
d1287 2
a1288 1
    | Absyn.RAISEexp (exp,_) => LambdaTypes.RAISE(trans_exp(" no_name", exp, env))
d1292 1
a1292 1
    | Absyn.HANDLEexp (exp, _, pat_exp_list,location,annotation) =>
d1320 7
d1337 1
a1337 1
               Match.SOME missing_constructors =>
d1352 1
a1352 1
             | Match.NONE => ());
d1356 1
a1356 1
                   trans_match((root, tree), env, false,name_string,! ty)
d1374 2
a1375 1
          trans_exp (name, TyperepUtils.make_coerce_expression (exp,atype), env)
d1404 2
a1405 1
          let val root_lambda = LambdaTypes.new_LVar()
d1413 1
a1413 1
              LambdaUtils.add_match_env((root, root_lambda),
d1419 2
a1420 2
                     ref(Match.NONE) => lambda_exp()
                    |ref(Match.SOME(binding)) => 
d1422 3
a1424 2
                      ([(fn lvar as ref(Match.SOME1(_,tree)) => 
                         let val lv =  LambdaTypes.new_LVar()
d1426 1
a1426 1
                         (lvar := Match.SOME2(lv);
d1428 1
a1428 1
                           (lv,
d1432 2
a1433 1
                                LambdaTypes.null_type_annotation),"Translation of match trees"))
d1440 2
a1441 2
                 let fun Tr_Default (ref(Match.BUILT(ref(Match.SOME2(lvar))))) = 
                           LambdaTypes.PRESENT(
d1443 6
a1448 5
	                LambdaTypes.VAR(lvar),
	                LambdaTypes.STRUCT [],
	                LambdaTypes.null_type_annotation))
                     |   Tr_Default (ref(Match.BUILT(ref(Match.SOME1(0,tree))))) =
                            LambdaTypes.PRESENT(tr_match(tree, match_env, val_env))
d1450 2
a1451 1
                            LambdaTypes.PRESENT(excp)
d1456 1
a1456 1
                      |Match.ABSENT => LambdaTypes.ABSENT
d1462 32
a1493 3
                    fun do_leaf([], env) = trans_exp(" match_leaf", exp, env)
                      | do_leaf((mv, valid, _) :: tl, env) =
                        do_leaf(tl, Environ.add_valid_env(env, (valid, EnvironTypes.LAMB(LambdaUtils.lookup_match(mv, match_env)))))
d1502 3
a1504 2
	                 LambdaTypes.VAR(LambdaUtils.lookup_match(mv, match_env)),
	                 LambdaTypes.ABSENT,
d1506 2
a1507 1
		             (LambdaTypes.SCON_TAG scon,tr_match(tree, match_env, val_env)))
d1514 2
a1515 1
	  val orig_lv = LambdaUtils.lookup_match(mv, match_env)
d1551 1
a1551 1
	      (LambdaTypes.VCC_TAG(#2(constructor_tag(valid, ty))),
d1565 1
a1565 1
	                     LambdaUtils.add_match_env((mv, orig_lv), match_env),
d1568 1
a1568 1
	       LambdaTypes.do_binding(
d1570 9
a1578 2
	         LambdaTypes.LETB(new_lv, new_le, "match translation"),
		 tr_match(
d1581 2
a1582 2
		   val_env)
	      ))
d1584 1
a1584 1
	      (LambdaTypes.IMM_TAG(#2(constructor_tag(valid, ty))),
d1607 7
a1613 1
			let val ref_lv = LambdaTypes.new_LVar ();
d1616 1
a1616 2
                            LambdaTypes.LETB(
			      ref_lv,
d1620 1
a1620 1
				LambdaTypes.null_type_annotation),
d1635 1
a1635 1
			         LambdaUtils.add_match_env((mv, orig_lv),
d1652 1
a1652 1
		    LambdaTypes.PRESENT{
d1660 1
a1660 1
		      LambdaTypes.ABSENT (* No default here if all cases ok *)
d1664 7
d1675 1
a1675 1
		  LambdaTypes.PRESENT{lv = LambdaTypes.new_LVar(),
d1684 1
a1684 2
		  	             val_env)
			 )
d1688 1
d1700 11
a1710 2
          map (fn (x,y) => (x, y, LambdaTypes.new_LVar())) lab_mv_list
	  val le = LambdaTypes.VAR(LambdaUtils.lookup_match(mv, match_env))
d1734 2
a1735 1
      tr_match(tree, match_env, env),name_string,ty)
d1751 1
a1751 1
    val excp = LambdaTypes.PRESENT(
d1757 9
a1765 5
      let
	fun trans_individual_dec(pattern, lambda_var) (*:
	  EnvironTypes.Env * LambdaTypes.binding list*)
	  = case pattern of
	  Absyn.WILDpat => (true, true, Environ.empty_env, [])
d1768 95
a1862 133
	| Absyn.SCONpat scon =>
	    (* This comes about for instance in cases like val (1,x) = y *)
	    (* or even val 1 = 1 (rather stupid!) *)
	    (* We translate it effectively to *)
	    (* dummy_lambda = if scon = exp then exp else raise(bind) *)
	    (* We further abstract out exp in order to avoid *)
	    (* recalculating it, vis *)
	    (* dummy_lambda = let dummy_lambda' = exp *)
	    (* in if scon = dummy_lambda' then dummy_lambda' *)
	    (* else raise(bind) end *)
	    (* We also cheat slightly, treating it as two *)
	    (* separate declarations *)
	  let
	    val dummy_lv = LambdaTypes.new_LVar()
	  in
	    (false, false, Environ.empty_env,
	      [LambdaTypes.LETB(
		dummy_lv,
		LambdaTypes.SWITCH(
		  LambdaTypes.VAR lambda_var,
		  LambdaTypes.ABSENT,
                  [(LambdaTypes.SCON_TAG(scon), LambdaTypes.VAR lambda_var)],
                  excp
		),
	        "")
	      ])
	  end
	| Absyn.VALpat ((longvalid as Ident.LONGVALID(path, valid), ref ty),_) =>
	  (case valid of
	    Ident.VAR symbol => (case path of
	      Ident.NOPATH => (true, true, Environ.add_valid_env(Environ.empty_env, (valid, EnvironTypes.LAMB(lambda_var))), [])
	    | Ident.PATH(_) => Crash.impossible
	      "Long valid with non-empty path to trans_dec")
	  | Ident.CON(_) =>
	    let
	      val dummy_lv = LambdaTypes.new_LVar()
	      val tag = #2(constructor_tag(valid, ty))
	      val one_con = Type_Utils.get_no_cons ty = 1
	    in
	      (false, one_con, Environ.empty_env,
	       [LambdaTypes.LETB(
		  dummy_lv,
		  LambdaTypes.SWITCH(
		    LambdaTypes.VAR lambda_var,
		    LambdaTypes.PRESENT{
		      lv = lambda_var,	(* dummy_value *)
		      num_imms = Type_Utils.get_no_null_cons ty,
		      num_vccs = Type_Utils.get_no_vcc_cons ty
		    },
		    [(LambdaTypes.IMM_TAG tag, LambdaTypes.VAR lambda_var)],
                    if one_con then LambdaTypes.ABSENT else excp
		  ),
		  "")
	       ])
	    end
	  | Ident.EXCON excon => 
	      let
		val lexp = LambdaTypes.VAR lambda_var
		val dummy_lv = LambdaTypes.new_LVar()
	      in
		(false, false, Environ.empty_env,
		 [LambdaTypes.LETB(
		    dummy_lv,
		    LambdaTypes.SWITCH(
		      GetConTag lexp,
		      LambdaTypes.PRESENT{
		        lv = LambdaTypes.new_LVar(),
		        num_imms = 0,
		        num_vccs = 0
		    },
		    [(LambdaTypes.EXP_TAG(cg_longexid(longvalid, envir)),
		      GetConVal lexp)],
		    excp
		    ),
		   "")]
		 )
	      end
	    )
	| Absyn.RECORDpat(lab_pat_list, flex, ref ty) =>
	  let
	    val big_list =
	      map (fn (lab, pat) =>
		   (pat, LambdaTypes.new_LVar(),
		    LambdaTypes.SELECT(record_label_offset(lab, ty),
				       LambdaTypes.VAR lambda_var)))
	      lab_pat_list
	    val env_list_lambda_list_list =
	      map
	      (fn (pat, lv, le) =>
	       let
		 val (has_vars, exhaustive, env, lambda_list) =
		   trans_individual_dec(pat, lv)
	       in
		 (has_vars, exhaustive, env, LambdaTypes.LETB(lv, le,"") :: lambda_list)
	       end)
	      big_list
	  in
	    (Lists.exists (fn (has_vars, _, _, _) => has_vars) env_list_lambda_list_list,
	     Lists.forall (fn (_, exhaustive, _, _) => exhaustive) env_list_lambda_list_list,
	     Lists.reducel (fn (env, (_, _, env', _)) => Environ.augment_env(env, env'))
	     (Environ.empty_env, env_list_lambda_list_list),
	     Lists.reducel
	     (fn (l1, (_, _, _, l2)) => l1 @@ l2)
	     ([], env_list_lambda_list_list))
	  end
	| Absyn.APPpat((longvalid, ref ty), pat,_) => 
            (case longvalid of
               Ident.LONGVALID(_, Ident.VAR _) =>
                 Crash.impossible"APPpat of Ident.VAR"
             | Ident.LONGVALID(_, valid as Ident.CON con) =>
                 if Environ.Builtin_p(longvalid, envir) 
                    andalso (case cg_longvalid(longvalid,envir) of
                               LambdaTypes.BUILTIN(Pervasives.REF) => true
                             | _ => false) then
		   (* Must be ref *)
                   let
		     val new_lv = LambdaTypes.new_LVar()
		     val (has_vars, exhaustive, new_env, new_lambda_exp) =
		       trans_individual_dec(pat, new_lv)
                   in
                     (has_vars, exhaustive, new_env,
                      (LambdaTypes.LETB(
					new_lv,
					LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
							LambdaTypes.VAR lambda_var,
							LambdaTypes.null_type_annotation),
					"Dereferencing a pattern")
		      :: new_lambda_exp))
                   end
                 else
                   if Type_Utils.get_no_cons ty = 1 then
                     trans_individual_dec(pat, lambda_var)
                   else
d1864 91
a1954 2
                       val new_lv = LambdaTypes.new_LVar()
                       val (has_vars, _, new_env, new_lambda_exp) =
d1957 60
a2016 26
                       val tag = #2(constructor_tag(valid, ty))
	             in
		       (has_vars, false, new_env,
		        LambdaTypes.LETB(
			  new_lv,
		          LambdaTypes.SWITCH(
			    lexp,
			    LambdaTypes.PRESENT{
			      lv = LambdaTypes.new_LVar(),
			      num_vccs = Type_Utils.get_no_vcc_cons ty,
			      num_imms = Type_Utils.get_no_null_cons ty
			    },
			    [(LambdaTypes.VCC_TAG tag,
			      if is_list_type (Type_Utils.get_cons_type ty) then
				lexp
			      else
				GetConVal lexp
			    )],
		            if Type_Utils.get_no_cons ty <> 1 then
			      excp (* is a tag, but not the right one *)
		            else
			      LambdaTypes.ABSENT
			  ),
			  "")
			:: new_lambda_exp)
	      end
d2018 93
a2110 38
	  | Ident.LONGVALID(_, Ident.EXCON excon) =>
	    let
	      val new_lv = LambdaTypes.new_LVar()
	      val (has_vars, _, new_env, new_lambda_exp) =
		trans_individual_dec(pat, new_lv)
	      val lexp = LambdaTypes.VAR lambda_var
	    in
	      (has_vars, false, new_env, (* Never exhaustive *)
	       LambdaTypes.LETB(
		 new_lv,
		 LambdaTypes.SWITCH(
		   GetConTag lexp,
		   LambdaTypes.PRESENT{
		     lv = LambdaTypes.new_LVar(),
		     num_imms = 0,
		     num_vccs = 0
		   },
		   [(LambdaTypes.EXP_TAG(cg_longexid(longvalid, envir)),
		     GetConVal lexp)],
		   excp
		 ),
		 "")
	       :: new_lambda_exp)
	    end
	  ) (* end of case longvalid *)
	| Absyn.TYPEDpat(typed, _,_) => trans_individual_dec(typed, lambda_var)
	  (* Just ignore the type here *)
	| Absyn.LAYEREDpat((valid, ty), pat) =>
	  (case valid of
	    Ident.VAR(vid) =>
	    let
	      val (_, _, env, lambda) = trans_individual_dec(pat, lambda_var)
	    in
	      (true, true, Environ.add_valid_env(env,
				     (valid, EnvironTypes.LAMB(lambda_var))),
	       lambda)
	    end
	  | _ => Crash.impossible "LAYEREDpat with non-VAR valid")
d2112 1
a2112 79
	(* This stuff needs redoing to be tail recursive over the first list *)
	case (non_rec_list, rec_list) of
	  ((pat, exp, location) :: tl, _) =>
	  let
	    val lvar = LambdaTypes.new_LVar()
	    val (has_vars, exhaustive, more_env, more_lambda) =
	      trans_individual_dec(pat, lvar)
	    val _ =
	      if exhaustive then ()
	      else
		Info.error error_info (Info.WARNING, location, "Binding not exhaustive")
	    val _ =
	      if has_vars then ()
	      else
		Info.error error_info (Info.WARNING, location, "Binding has no variables")
	    val lambda = trans_exp(" pattern", exp, envir)
	    val (more_env, updated) = case (pat, lambda) of
	      (Absyn.VALpat((Ident.LONGVALID(Ident.NOPATH,valid as Ident.VAR _), _),_),
	       LambdaTypes.BUILTIN prim) =>
	      (Environ.add_valid_env(more_env, (valid,
						EnvironTypes.PRIM prim)),
		true)
	    | _ => (more_env, false)
	    val (rest_env, rest_lambda) =
	      trans_dec(Absyn.VALdec(tl,rec_list, Set.empty_set), envir)
	    val new_bindings = more_lambda @@ rest_lambda
	  in
	    (Environ.augment_env(more_env, rest_env),
	     (if updated then
		new_bindings
	      else
		LambdaTypes.LETB(lvar, lambda,"") :: new_bindings))
	  end
	| ([], []) => (Environ.empty_env, [])
	| ([], rec_list) =>
          let
	    val lv_pat_exp_list = map
	      (fn (pat, exp, location) => (LambdaTypes.new_LVar(), pat, exp, location))
	      rec_list
	    (* Assign lambda_var to each expression, pattern pair *)
	    val env_le_list = map
	      (fn (lv, pat, _, location) =>
	       let
		 val (has_vars, exhaustive, env, le) = trans_individual_dec(pat, lv)
		 val _ =
		   if exhaustive then ()
		   else
		     Info.error error_info (Info.WARNING, location, "Binding not exhaustive")
		 val _ =
		   if has_vars then ()
		   else
		     Info.error error_info (Info.WARNING, location, "Binding has no variables")
	       in
		 env
	       end)
	      lv_pat_exp_list
	    (* The exp parts resulting from this should be null *)
	    val all_env = Lists.reducel Environ.augment_env (Environ.empty_env, env_le_list)
	    (* Produce the environment including the new functions *)
	    val trans_env = Environ.augment_env(envir, all_env)
	    fun valid_name(Ident.VAR sy) = sy
	      | valid_name(Ident.CON sy) = sy
	      | valid_name(Ident.EXCON sy) = sy
	    fun pat_name(Absyn.VALpat((Ident.LONGVALID(_, valid), _),_)) =
	      Symbol.symbol_name(valid_name valid)
	      | pat_name(Absyn.WILDpat) = " WILD"
	      | pat_name(Absyn.LAYEREDpat((valid, _), pat)) =
		(case pat_name pat of
		   " WILD" => Symbol.symbol_name(valid_name valid)
		 | x => x)
              | pat_name(Absyn.TYPEDpat (pat,_,_)) = pat_name pat
	      | pat_name _ = Crash.impossible"Bad pat name in val rec"
	    val exp_list = map
	      (fn (pat, exp,_) => trans_exp(pat_name pat, exp, trans_env))
	      rec_list
	  in
	    (all_env,
	     [LambdaTypes.RECLETB(map #1 lv_pat_exp_list, exp_list)])
	  end
d2119 2
a2120 1
            (Absyn.VALpat ((Ident.LONGVALID (Ident.NOPATH, Ident.VAR sy), ref ty),Location.UNKNOWN),
d2137 2
a2138 1
    | Absyn.ABSTYPEdec (_, _, dec) => trans_dec(dec, envir)
d2180 1
a2180 1
			      (NewMap.define(i, exn_string, (ty,false,[])))
d2189 1
a2189 1
					 LambdaTypes.null_type_annotation),
d2197 1
a2197 1
		[LambdaTypes.LETB(lv, lambda_exp,
d2260 1
a2260 1
		LambdaTypes.LETB(l, LambdaTypes.SELECT(field, lambda_exp),"")
d2262 1
a2262 1
                 LambdaTypes.LETB(l,
a2268 1

d2271 1
a2271 1
		LambdaTypes.LETB(l, LambdaTypes.SELECT(field, lambda_exp),"")
d2273 1
a2273 1
                 LambdaTypes.LETB(l, LambdaTypes.BUILTIN prim,"")
d2325 1
a2325 1
	complete_struct(argument, LambdaTypes.PRESENT interface, !coerce)
d2330 3
a2332 1
	  EnvironTypes.LAMB lv => (LambdaTypes.VAR lv, new_arg, LambdaTypes.null_type_annotation)
d2336 1
a2336 1
                             LambdaTypes.null_type_annotation),
d2338 1
a2338 1
            LambdaTypes.null_type_annotation)
d2365 3
a2367 3
	    Absyn.ABSENT => LambdaTypes.ABSENT
          | Absyn.PRESENT sigexp =>
	      LambdaTypes.PRESENT (interface_from_sigexp sigexp)
d2378 2
a2379 1
           LambdaTypes.LETB(lambda_var, lambda_exp,"") :: bindings, rest)
d2396 3
a2398 3
	    Absyn.ABSENT => LambdaTypes.ABSENT
          | Absyn.PRESENT sigexp =>
	      LambdaTypes.PRESENT (interface_from_sigexp sigexp)
d2408 1
a2408 1
           LambdaTypes.LETB(lambda_var, lambda_exp,"") :: bindings, rest)
d2452 3
a2454 3
	Absyn.ABSENT => LambdaTypes.ABSENT
      | Absyn.PRESENT sigexp =>
	  LambdaTypes.PRESENT (interface_from_sigexp sigexp)
d2477 1
a2477 1
       [LambdaTypes.LETB(lambda_var, LambdaTypes.FN(lvar, lambda_exp,annotation_string,LambdaTypes.null_type_annotation),
a2527 1
                                                                  @


1.132
log
@ More informative inexhaustiveness reporting
@
text
@d4 3
d576 8
d1317 15
a1331 17
               Match.SOME(missing_constructors) => 
               Info.error error_info 
               (Info.WARNING, location, 
                "Match not exhaustive\n"^
                (Lists.reducel (fn (str,(ty,cons))=> str ^
                 "missing constructors of type " ^ Types.print_type print_options ty ^
                  (case cons of 
                     nil => ""
                   | _ => 
                       " : "^(#1(Lists.reducel 
                              (fn ((str,cons),Ident.CON(con))=> 
                                (case cons of 
                                   nil => Crash.impossible "lists.reducel:trans_exp:lambda"
                                 | [_] => (str^Ident.Symbol.symbol_name con,nil)
                                 | _::cons => (str^Ident.Symbol.symbol_name con^",",cons))
                               | _ => Crash.impossible "missing_constructors:trans_exp:lambda")
                                    (("",cons),cons)))^"\n")) ("",missing_constructors))^"\n")
@


1.131
log
@Removed exception environments and interfaces.
Funenvs no longer have interface components.  Instead, info about functor
arguments is found in the type basis.
Exceptions are always stored in the value environment.  Matching of
exceptions against value specifications requires some extra work.
@
text
@d4 7
d1305 19
a1323 4
             if not_exhaustive then
               Info.error error_info (Info.WARNING, location, "Match not exhaustive")
             else
               ();
d1415 2
a1416 1
                     |   Tr_Default (ref(Match.UNBUILT'(_))) = LambdaTypes.PRESENT(excp)
d1425 1
a1425 2
                Match.ERROR => excp
              | Match.LEAF(exp, n, mv_valid_ty_list) =>
@


1.130
log
@Added code for abstractions.
@
text
@d4 3
d332 2
a345 1
require "../typechecker/typerep_utils";
d363 1
d376 2
a377 1
  sharing Types.Datatypes = Type_Utils.DataTypes = TyperepUtils.Datatypes
a386 1
  sharing type Types.Datatypes.Interface.Int = Environ.EnvironTypes.Interface
d396 1
a396 1
  structure Interface = Datatypes.Interface
d421 9
a429 9
  fun filter_map (a_list, [], _, done) = rev done
    | filter_map ([], x :: _, print_fn, done) =
      Crash.impossible("member '" ^ print_fn x ^
		       "' missing in filter_map")
    | filter_map((x, y)::xs, second as (z :: zs), print_fn, done) =
      if x = z then
	filter_map(xs, zs, print_fn, (x, y) :: done)
      else
	filter_map(xs, second, print_fn, done)
d431 2
a432 2
  fun filter_ordered_map (a_list, f_list, print_fn) =
    (filter_map(a_list, f_list, print_fn, [])
d442 21
a492 2
  (* This ought to use the ref interface information *)
  fun make_interface str = Environ.make_interface_from_str str
d678 1
a678 24
  fun cg_longexid(longexid, env) = case longexid of
    Ident.LONGVALID(Ident.NOPATH, exid) =>
      (case Environ.lookup_exn(exid, env) of
	 EnvironTypes.LAMB lvar => LambdaTypes.VAR lvar
       | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
       | EnvironTypes.EXTERNAL =>
	   LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.LOAD_EXN,
			   LambdaTypes.SCON(Ident.STRING(str_from_valid
							 exid)),
			   LambdaTypes.null_type_annotation)
       | EnvironTypes.FIELD _ => Crash.impossible "cg_longvalid gives field")
  | Ident.LONGVALID(path, exid) =>
    let
      val (env', lambda) =
	Ident.followPath'(get_lamb_env, get_field_env) (path, env)
    in
      case Environ.lookup_exn(exid, env') of
	EnvironTypes.FIELD field => LambdaTypes.SELECT(field, lambda)
      | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
      | EnvironTypes.LAMB _ =>
	  Crash.impossible "cg_longexid gets lambda var at end of longvalid"
      | EnvironTypes.EXTERNAL =>
	  Crash.impossible "cg_longexid gets external at end of longvalid"
    end
d680 2
a681 2
  fun cg_longstrid (longstrid, env) = case longstrid of
    Ident.LONGSTRID(Ident.NOPATH, strid as Ident.STRID sy) =>
d686 5
a690 4
	   (env, LambdaTypes.APP
	    (LambdaTypes.BUILTIN Pervasives.LOAD_STRUCT,
	     LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
	     LambdaTypes.null_type_annotation))
d761 10
a770 24
  (* Compare an interface and an environment for equality.
   The interface should always be a subset of the environment,
   the question is merely whether it is proper or not. *)

  fun compare_name_lists(list1, list2, order) =
    list1 = list2 orelse
    (Lists.qsort order list1) = (Lists.qsort order list2)

  fun compare_sig_env(Interface.INT(Interface.INTENV intenv, v_list, e_list,_),
    EnvironTypes.ENV(v_map, e_map, s_map)) =
    Lists.length v_list = NewMap.size v_map andalso
    Lists.length e_list = NewMap.size e_map andalso
    NewMap.size intenv = NewMap.size s_map andalso
    (* Check the names and then recurse down the structure map *)
    (* Name checking shouldn't really be necessary, but ... *)
(*  So I've removed it!
    compare_name_lists(v_list, NewMap.domain_ordered v_map,
		       Ident.valid_order) andalso
    compare_name_lists(e_list, NewMap.domain_ordered e_map,
		       Ident.valid_order) andalso
    compare_name_lists(NewMap.domain_ordered intenv,
		       NewMap.domain_ordered s_map,
		       Ident.strid_order) andalso
*)
d772 19
a790 9
    compare_sig_env
    (Lists.zip(NewMap.range_ordered intenv,
	       map #1 (NewMap.range_ordered s_map)))
  fun complete_struct_with_sig(inte as Interface.INT(
    intenv as Interface.INTENV s_int_map, v_list, e_list,_),
      env as EnvironTypes.ENV(v_map, e_map, s_map), lambda_var) =
  if compare_sig_env(inte, env) then
    (env, LambdaTypes.VAR lambda_var)
  else
d792 9
a800 22
      val v_a_list = NewMap.to_list_ordered v_map
	(* Throw out unwanted elements and assign new field numbers *)
(*
      val _ = Print.print"Filtering valids\n"
*)
      val (v_a_f_list_fn, next1) =
	Lists.number_with_size
	(filter_ordered_map
	 (v_a_list, Lists.qsort Ident.valid_order v_list,
	  IdentPrint.debug_printValId), 0,
	 EnvironTypes.FIELD)
      val e_a_list = NewMap.to_list_ordered e_map
(*
      val _ = Print.print"Filtering excons list:-\n"
      val _ = Lists.iterate
	(fn (x, _) => Print.print(IdentPrint.debug_printValId x ^ "\n"))
	e_a_list
      val _ = Print.print"In:-\n"
      val _ = Lists.iterate
	(fn x => Print.print(IdentPrint.debug_printValId x ^ "\n"))
	e_list
*)
d802 1
a802 1
      val (e_a_f_list_fn, next2) =
d804 4
a807 3
	(filter_ordered_map
	 (e_a_list, Lists.qsort Ident.valid_order e_list,
	  IdentPrint.debug_printValId), next1,
d809 2
a810 7
(*
      val _ = Print.print"Filtering strids\n"
*)
      val s_a_list = NewMap.to_list_ordered s_map
	(* Throw out unwanted elements and assign new field numbers *)
      val ordered_int_map = NewMap.to_list_ordered s_int_map
      val (s_a_f_list_fn, size) =
d812 10
a821 11
	(filter_ordered_map
	 (s_a_list, map #1 ordered_int_map,
	  IdentPrint.printStrId), next2, EnvironTypes.FIELD)
      val v_a_f_list = v_a_f_list_fn size
      val e_a_f_list = e_a_f_list_fn size
      val s_a_f_list = s_a_f_list_fn size
      val v_a_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar())) v_a_f_list
      val e_a_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar())) e_a_f_list
      val s_a_f_l_list =
d823 1
a823 1
	s_a_f_list
d826 2
a827 3
      val e_le_list = map complete_struct_with_sig
	(map (fn ((((_, (env, _)), _), _, lv), (_, inte)) => (inte, env, lv))
	  (Lists.zip(s_a_f_l_list, ordered_int_map)))
d829 99
a927 55
	(map (fn (_, x) => LambdaTypes.VAR x) v_a_f_l_list) @@
	(map (fn (_, x) => LambdaTypes.VAR x) e_a_f_l_list) @@
	(map (fn (_, x, _) => LambdaTypes.VAR x) s_a_f_l_list)
        fun keep_prims (x as EnvironTypes.PRIM _) _ = x
          | keep_prims _ x = x
      val env = Lists.reducel
	(fn (env, ((e, x), f_new)) =>
	 Environ.add_exn_env(env, (e, keep_prims x f_new)))
	(Lists.reducel
	 (fn (env, ((v, x), f_new)) =>
	  Environ.add_valid_env(env, (v, keep_prims x f_new)))
	 (Lists.reducel
	  (fn (env, (((strid, _), field), (env', _))) =>
	   Environ.add_strid_env(env, (strid, (env', field))))
	  (Environ.empty_env,
	   (Lists.zip(s_a_f_list, e_le_list))),
	  v_a_f_list),
	 e_a_f_list)
      val l1 = (map (fn (((_, EnvironTypes.FIELD f_old), _), lv) =>
        LambdaTypes.LETB(lv,
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),
                        "")
                     | (((_, EnvironTypes.PRIM prim), _), lv) =>
                         LambdaTypes.LETB(lv,LambdaTypes.BUILTIN prim,"")
		     | (((_, EnvironTypes.LAMB _), _), _) =>
			 Crash.impossible "c_s_w_i(1)"
		     | (((_, EnvironTypes.EXTERNAL), _), _) =>
			 Crash.impossible "c_s_w_i(1)")
	  v_a_f_l_list)
      val l2 = (map (fn (((_, EnvironTypes.FIELD f_old), _), lv) =>
        LambdaTypes.LETB(lv,
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),"")
                     | (((_, EnvironTypes.PRIM prim), _), lv) =>
                         LambdaTypes.LETB(lv,LambdaTypes.BUILTIN prim,"")
		     | (((_, EnvironTypes.LAMB _), _), _) =>
			 Crash.impossible "c_s_w_i(2)"
		     | (((_, EnvironTypes.EXTERNAL), _), _) =>
			 Crash.impossible "c_s_w_i(2)")
	  e_a_f_l_list)
      val l3 = (map
	  (fn ((((_, (env, EnvironTypes.FIELD f_old)), _), lv, lv'), le) =>
          LambdaTypes.LETB(lv, 
                          LambdaTypes.do_binding
                          (LambdaTypes.LETB(lv',
                                           LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),""), le),
                          "")
	  | ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (3) LAMB"
	  | ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (4) PRIM"
	  | ((((_, (_, EnvironTypes.EXTERNAL)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (5) PRIM")
	  (Lists.zip(s_a_f_l_list, map #2 e_le_list)))
      val lambdas = let_lambdas_in_exp(l1 @@ l2 @@ l3,
        LambdaTypes.STRUCT the_structure_list)
d929 2
d932 1
a932 1
    end
d935 1
a935 1
    EnvironTypes.ENV(mv, me, ms), EnvironTypes.FUN_ENV m), lv_le_list) =
a937 1
    val exns = NewMap.to_list_ordered me
d943 1
a943 1
	Crash.impossible "extract_op problem"
d945 1
a945 1
	Crash.impossible "extract_op problem"
d949 3
a951 8
      LambdaTypes.STRUCT((map
                          (fn (_, x) => extract_op x) valids) @@
                         (map
                          (fn (_, x) => extract_op x) exns) @@
                         (map
                          (fn (_, (_, x)) => extract_op x) strids) @@
                         (map
                          (fn (_,(x, _, _)) => extract_op x) funids))))
d956 3
a958 1
  fun complete_struct((env, lambda_exp: LambdaTypes.LambdaExp), interface_opt) =
d967 11
a977 11
      if compare_sig_env(inte, new_env) then result
      else
	let
	  val new_lv = LambdaTypes.new_LVar()
	  val (new_env', new_lambda') =
	    complete_struct_with_sig(inte, new_env, new_lv)
	in
	  (new_env',
	   LambdaTypes.do_binding(LambdaTypes.LETB(new_lv, lambda_exp,""),
				  new_lambda'))
	end
d980 7
d993 2
a994 1
     debug_info) =
d1034 2
a1035 1
                              EnvironTypes.PRIM _ => Environ.is_overloaded_op valid
d1407 1
a1407 2
                        do_leaf(tl, Environ.add_valid_env(env, (valid,
                          EnvironTypes.LAMB(LambdaUtils.lookup_match(mv, match_env)))))
d1676 1
a1676 2
	      Ident.NOPATH => (true, true, Environ.add_valid_env(Environ.empty_env, (valid,
		EnvironTypes.LAMB(lambda_var))), [])
d1954 5
a1958 5
      (* Generate a lambda l1 bound to (APP(ref, unit), name). This goes in the
       exception environment. Generate a second lambda l2 bound to either
       FN(l3, STRUCT(l1,VAR(l3)))  or STRUCT(l1,STRUCT()) according to
       whether or not the exception carries a value, and place this in the
       ordinary value environment *)
d1964 2
a1965 2
	    val l1 = LambdaTypes.new_LVar()
	    val l2 = LambdaTypes.new_LVar()
d1969 9
a1977 8
	    val (new_v, exn_string) =
	      let
		val sym = case v of
		  Ident.EXCON x => x
		| _ => Crash.impossible"ExId is not EXCON"
	      in
		(Ident.VAR sym, Symbol.symbol_name sym)
	      end
d1979 3
a1981 4
	      Environ.add_exn_env(Environ.add_valid_env
				  (Environ.empty_env, (new_v,
						       EnvironTypes.LAMB l2)),
				  (v, EnvironTypes.LAMB l1))
d1986 1
a1986 4
                    val string_to_use = (if exception_name=""
                                           then exn_string
                                         else exception_name)
		    val string_exp = LambdaTypes.SCON(Ident.STRING string_to_use)
d1993 2
a1994 1
                          Debugger_Types.INFO (NewMap.define(i, string_to_use, (ty,false,[])))
d2011 2
a2012 16
		[LambdaTypes.LETB(l1, lambda_exp,"Bound to a handler wrapped thing"),
		 LambdaTypes.LETB(l2, if Type_Utils.is_vcc ty then
		  let
		    val l3 = LambdaTypes.new_LVar()
		  in
		    LambdaTypes.FN(l3,
				   LambdaTypes.STRUCT
				   ([LambdaTypes.VAR l1, LambdaTypes.VAR l3]),
                                   if exception_name=""
                                     then exn_string
                                   else exception_name,
                                   LambdaTypes.null_type_annotation)
		  end
		      else
			LambdaTypes.STRUCT([LambdaTypes.VAR l1,
					    LambdaTypes.STRUCT []]),"Exception")]
d2015 2
a2016 2
	    do_exns(exns, Environ.augment_env(env, this_env), this_lambda :: 
		    lambdas)
d2053 1
a2053 1
	     val (EnvironTypes.ENV(valid_env, exn_env, strid_env),
a2057 2
	     val exn_map = map (fn (e, c) => (e, c, LambdaTypes.new_LVar()))
	       (NewMap.to_list exn_env)
a2066 4
	     val new_e_env = Lists.reducel
	       (fn (env, (e, x, l)) =>
		Environ.add_exn_env(env, (e, identity_if_builtin(x,l))))
	       (new_v_env, exn_map)
d2070 2
a2071 1
	       (new_e_env, strid_map)
d2083 1
a2083 7
	     val new_e_lambdas = map
	       (fn (_, EnvironTypes.FIELD field, l) =>
		LambdaTypes.LETB(l, LambdaTypes.SELECT(field, lambda_exp),"")
             | (_, EnvironTypes.PRIM prim, l) => 
		LambdaTypes.LETB(l, LambdaTypes.BUILTIN prim,"")
             | _ => Crash.impossible "Absyn.OPENdec(1)"
		   ) exn_map
d2093 1
a2093 2
			new_v_lambdas @@ new_e_lambdas @@ new_s_lambdas @@
			new_lambdas)
d2119 2
a2120 1
  fun trans_str_exp(strexp, top_env as EnvironTypes.TOP_ENV(env, fun_env)) =
d2123 1
a2123 1
    let val (env, lv_le_list) = trans_str_dec(strdec, top_env)
d2130 1
a2130 1
  | Absyn.APPstrexp(funid as Ident.FUNID sy, strexp,_) =>
d2132 9
a2140 4
      val (lv, interface, result_env) = Environ.lookup_funid(funid, fun_env)
      val argument as (env, arg) = trans_str_exp(strexp, top_env)
      val (new_env, new_arg) = complete_struct(argument,
	LambdaTypes.PRESENT interface)
d2156 1
a2156 1
    let val (local_env, local_lambdas) = trans_str_dec(strdec, top_env)
d2159 2
a2160 1
	  Environ.augment_top_env(top_env, make_top_env local_env))
d2165 1
a2165 1
  and trans_str_dec(strdec, top_env as EnvironTypes.TOP_ENV(env, fun_env)) =
d2175 1
a2175 1
		      (strid, sigexp_opt, strexp, _) :: rest) =
d2178 3
a2180 6
            Absyn.ABSENT => LambdaTypes.ABSENT
          | Absyn.PRESENT(Absyn.NEWsigexp(_, ref (Absyn.PRESENT str))) =>
              LambdaTypes.PRESENT (make_interface str)
          | Absyn.PRESENT(Absyn.OLDsigexp(_, ref (Absyn.PRESENT str),_)) =>
              LambdaTypes.PRESENT (make_interface str)
          | _ => Crash.impossible "No interface structure in trans_str_dec"
d2182 3
a2184 1
            complete_struct(trans_str_exp(strexp, top_env), inte_opt)
d2198 1
d2205 1
a2205 1
		      (strid, sigexp_opt, strexp, _) :: rest) =
d2208 3
a2210 6
            Absyn.ABSENT => LambdaTypes.ABSENT
          | Absyn.PRESENT(Absyn.NEWsigexp(_, ref (Absyn.PRESENT str))) =>
              LambdaTypes.PRESENT (make_interface str)
          | Absyn.PRESENT(Absyn.OLDsigexp(_, ref (Absyn.PRESENT str),_)) =>
              LambdaTypes.PRESENT (make_interface str)
          | _ => Crash.impossible "No interface structure in trans_str_dec"
d2212 2
a2213 1
            complete_struct(trans_str_exp(strexp, top_env), inte_opt)
d2227 1
a2227 1
      val (local_env, local_lambda) = trans_str_dec(strdec1, top_env)
d2229 4
a2232 2
	trans_str_dec(strdec2,
	  Environ.augment_top_env(top_env, make_top_env local_env))
d2238 1
a2238 13
      trans_sequence_strdec(top_env, Environ.empty_env, [], strdec_list)
(*
    (case strdec_list of
      [] => (Environ.empty_env, [])
    | strdec :: tl =>
    let
      val (env', lambda) = trans_str_dec(strdec, top_env)
      val (env'', lambda') = trans_str_dec(Absyn.SEQUENCEstrdec tl,
	Environ.augment_top_env(top_env, env'))
    in
      (Environ.augment_env(env', env''), lambda @@ lambda')
    end)
*)
d2240 1
a2240 1
  and trans_sequence_strdec(old_env, new_env, bindings, []) =
d2242 2
a2243 1
    | trans_sequence_strdec(old_env, new_env, bindings, decs :: dec_list) =
d2245 1
a2245 1
	val (env, new_bindings) = trans_str_dec(decs, old_env)
d2248 1
a2248 1
			      (old_env, make_top_env env),
d2250 2
a2251 1
			      new_bindings :: bindings, dec_list)
d2254 5
a2258 7
  fun interface_from_sigexp(Absyn.NEWsigexp(_, ref (Absyn.PRESENT str))) = make_interface str
    | interface_from_sigexp(Absyn.OLDsigexp(_, ref (Absyn.PRESENT str),_)) = make_interface str
    | interface_from_sigexp _ = Crash.impossible "No interface structure for signature"

  fun trans_individual_funbind(
      funbind as (funid, strid, sigexp, strexp, sigexp_opt,annotation_string,_),
      top_env as EnvironTypes.TOP_ENV(env, fun_env)) =
d2261 1
a2261 1
      val env = Environ.make_env_from_interface interface
d2265 3
a2267 5
      | Absyn.PRESENT(Absyn.NEWsigexp(_, ref (Absyn.PRESENT str))) =>
	  LambdaTypes.PRESENT (make_interface str)
      | Absyn.PRESENT(Absyn.OLDsigexp(_, ref (Absyn.PRESENT str),_)) =>
	  LambdaTypes.PRESENT (make_interface str)
      | _ => Crash.impossible"No interface structure in trans_individual_funbind"
d2277 4
a2280 2
						EnvironTypes.LAMB lvar)))))),
	 inte_opt)
d2288 1
a2288 1
	  (EnvironTypes.LAMB lambda_var, interface, str_env)))),
d2293 2
a2294 2
  fun trans_fun_dec([], _) = (make_top_env Environ.empty_env, [])
    | trans_fun_dec(funbind :: rest, top_env) =
d2296 3
a2298 2
        val (new_env, new_lambda) = trans_individual_funbind(funbind, top_env)
        val (rest_env, rest_lambda) = trans_fun_dec(rest, top_env)
d2303 2
a2304 2
  fun trans_fun_dec_list([], _) = (make_top_env Environ.empty_env, [])
    | trans_fun_dec_list((Absyn.FUNBIND funbind):: rest, top_env) =
d2306 1
a2306 1
        val (new_env, new_lambda) = trans_fun_dec(funbind, top_env)
d2308 1
a2308 1
          trans_fun_dec_list(rest, Environ.augment_top_env(top_env, new_env))
d2323 1
a2323 1
          val (new_env, lambdas) = trans_str_dec(strdec, top_env)
d2330 1
a2330 1
        trans_fun_dec_list(funbind_list, top_env)
@


1.129
log
@Removed integer parameter
@
text
@d4 3
d2162 30
@


1.128
log
@Added case for TYPEDpat's in pat_name function.
@
text
@d4 3
a320 1
require "../utils/integer";
a350 1
  structure Integer : INTEGER
@


1.127
log
@Renamed Typerep_Utils to TyperepUtils
Added call to TyperepUtils.convert_dynamic_type
@
text
@d4 4
d1888 1
@


1.126
log
@Added code to deal with inexhaustive bindings and bindings without variables
Fixed a bug in value bindings of nullary exception constructors
@
text
@d4 4
d358 1
a358 1
  structure Typerep_Utils : TYPEREP_UTILS
d363 1
a363 1
  sharing Types.Datatypes = Type_Utils.DataTypes = Typerep_Utils.Datatypes
d366 1
a366 1
  sharing LambdaUtils.Match.Absyn = AbsynPrint.Absyn = Typerep_Utils.Absyn
d1270 4
a1273 5
      | Absyn.DYNAMICexp (exp,ref atype) =>
(*
          trans_exp (name, Typerep_Utils.make_typerep_expression (exp,atype), env)
*)
          let
d1275 3
a1277 1
            val tyexpr = LambdaTypes.MLVALUE (MLWorks.Internal.Value.cast atype)
d1281 2
d1285 1
a1285 1
          trans_exp (name, Typerep_Utils.make_coerce_expression (exp,atype), env)
@


1.125
log
@Generate error for unresolved overloaded operators
@
text
@d4 3
d1596 2
a1597 2
	fun trans_individual_dec(pattern, lambda_var) :
	  EnvironTypes.Env * LambdaTypes.binding list
d1599 1
a1599 1
	  Absyn.WILDpat => (Environ.empty_env, [])
d1614 2
a1615 1
	  let val dummy_lv = LambdaTypes.new_LVar()
d1617 1
a1617 1
	    (Environ.empty_env,
d1629 1
a1629 1
	| Absyn.VALpat ((Ident.LONGVALID(path, valid), ref ty),_) =>
d1632 1
a1632 1
	      Ident.NOPATH => (Environ.add_valid_env(Environ.empty_env, (valid,
d1637 4
a1640 2
	    let val dummy_lv = LambdaTypes.new_LVar()
	        val tag = #2(constructor_tag(valid, ty))
d1642 1
a1642 1
	      (Environ.empty_env,
d1653 1
a1653 3
                    if Type_Utils.get_no_cons ty = 1 then
		      LambdaTypes.ABSENT
		    else excp
d1659 22
a1680 2
	      Crash.impossible "VALpat(Ident.EXCON)")

d1693 1
a1693 1
		 val (env, lambda_list) =
d1696 1
a1696 1
		 (env, LambdaTypes.LETB(lv, le,"") :: lambda_list)
d1700 4
a1703 1
	    (env_from_list env_list_lambda_list_list,
d1705 1
a1705 1
	     (fn (l1, (_, l2)) => l1 @@ l2)
d1718 4
a1721 3
                   let val new_lv = LambdaTypes.new_LVar()
                       val (new_env, new_lambda_exp) =
                         trans_individual_dec(pat, new_lv)
d1723 1
a1723 1
                     (new_env,
d1725 5
a1729 5
			 new_lv,
                         LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                         LambdaTypes.VAR lambda_var,
					 LambdaTypes.null_type_annotation),
                         "Dereferencing a pattern")
d1738 1
a1738 1
                       val (new_env, new_lambda_exp) =
d1743 1
a1743 1
		       (new_env,
d1769 5
a1773 4
	    let val new_lv = LambdaTypes.new_LVar()
	        val (new_env, new_lambda_exp) =
		  trans_individual_dec(pat, new_lv)
	        val lexp = LambdaTypes.VAR lambda_var
d1775 1
a1775 1
	      (new_env,
d1799 1
a1799 1
	      val (env, lambda) = trans_individual_dec(pat, lambda_var)
d1801 1
a1801 1
	      (Environ.add_valid_env(env,
d1809 1
a1809 1
	  ((pat, exp,_) :: tl, _) =>
d1812 10
a1821 1
	    val (more_env, more_lambda) = trans_individual_dec(pat, lvar)
d1844 2
a1845 1
	      (fn (pat, exp,_) => (LambdaTypes.new_LVar(), pat, exp)) rec_list
d1848 15
a1862 2
	      (fn (lv, pat, _) => trans_individual_dec(pat, lv))
	        lv_pat_exp_list
d1864 1
a1864 1
	    val all_env = env_from_list env_le_list
d1867 3
d1871 7
a1877 11
	      let
		val sy = case valid of
		  Ident.VAR sy => sy
		| Ident.CON sy => sy
		| Ident.EXCON sy => sy
	      in
		Symbol.symbol_name sy
	      end
	    | pat_name(Absyn.WILDpat) = " WILD"
	    | pat_name(Absyn.LAYEREDpat(_, pat)) = pat_name pat
	    | pat_name _ = Crash.impossible"Bad pat name in val rec"
@


1.124
log
@Options changes
Signature revisions
@
text
@d4 4
d973 1
a973 1
          | Absyn.VALexp(longValId, ref ty,_) =>
d993 3
a995 4
                     val _ = if is_ol <> env_ol then
                       Diagnostic.output 0
                       (fn _ => ["Overload clash on " ^ sy_name ^ "\nis_ol = " ^
                                 (if is_ol then "true\n" else "false\n")])
d998 1
a998 1
                       if is_ol then 
@


1.123
log
@Options & Info changes
@
text
@d4 3
d352 1
a352 3
  sharing type Environ.EnvironTypes.LambdaTypes.LVar = LambdaUtils.Match.lvar
  sharing Environ.EnvironTypes.LambdaTypes.Datatypes = Types.Datatypes =
    Type_Utils.DataTypes = Debugger_Types.Datatypes = Typerep_Utils.Datatypes
a356 1
  sharing type LambdaUtils.LambdaTypes.Primitive = Pervasives.pervasive
d359 8
d942 5
a946 1
    (print_options,topdec, top_env as EnvironTypes.TOP_ENV(env, top_map),generate_debug,debug_info) =
@


1.122
log
@Added MLVALUE lambda exp
Dynamic expressions get translated into a pair of the expression and the MLVALUE of its type
@
text
@d4 4
a314 1
require "environprint";
a342 1
  structure EnvironPrint: ENVIRONPRINT
d345 1
d350 1
a350 2
  sharing Environ.EnvironTypes.LambdaTypes.Datatypes =
    LambdaUtils.Match.Absyn.Datatypes = Types.Datatypes =
d352 1
a352 1
  sharing AbsynPrint.Absyn.Datatypes.Ident = IdentPrint.Ident
d355 1
a355 2
  sharing Environ.EnvironTypes = Primitives.EnvironTypes =
    EnvironPrint.EnvironTypes
d357 2
a358 1
  sharing LambdaUtils.Match.Info = Types.Info = AbsynPrint.Info = Debugger_Types.Info
d363 1
a363 1
  structure Datatypes = Absyn.Datatypes
d374 2
a375 1
  structure Info = Types.Info
d706 2
a707 2
  fun print_redundancy_info (options,[], _, _) = ()
    | print_redundancy_info (options,clauses, pat_exp_list, location) =
d722 1
a722 1
                     AbsynPrint.unparsePat options p ^
d728 1
a728 1
        Info.error options (Info.WARNING, location,to_string (clauses, map (fn (x,_) => x) pat_exp_list))
d932 4
a935 2
  fun trans_top_dec options args =
      let
d937 6
a942 6
        (** Now we need a function that will translate from abstract syntax to
         lambda expressions.  This is done on the way to translating to the
         machine description directly.
         Take an Absyn.Exp and a list of substitutions, and for each type
        of expression translate into the relevant piece of lambda
          calculus.  **)
d1211 1
a1211 1
                                (fn x => output (std_out,x)) (Match.unparseTree options tree "");
d1217 1
a1217 1
                               | r => print_redundancy_info (options,r,pat_exp_list,location);
d1233 1
a1233 1
              (fn x => output (std_out,x)) (Match.unparseTree options tree "");
d1239 1
a1239 1
               Info.error options (Info.WARNING, location, "Match not exhaustive")
d1244 1
a1244 1
               | r => print_redundancy_info (options,r,pat_exp_list,location);
d1825 1
a1825 1
            (Absyn.VALpat ((Ident.LONGVALID (Ident.NOPATH, Ident.VAR sy), ref ty),Absyn.Location.UNKNOWN),
d1827 2
a1828 2
                          ty, Absyn.Location.UNKNOWN),
             Absyn.Location.UNKNOWN)
d2187 7
a2193 7
  | trans_fun_dec(funbind :: rest, top_env) =
    let
      val (new_env, new_lambda) = trans_individual_funbind(funbind, top_env)
      val (rest_env, rest_lambda) = trans_fun_dec(rest, top_env)
    in
      (Environ.augment_top_env(new_env, rest_env), new_lambda @@ rest_lambda)
    end
d2196 10
a2205 10
  | trans_fun_dec_list((Absyn.FUNBIND funbind):: rest, top_env) =
  let
    val (new_env, new_lambda) = trans_fun_dec(funbind, top_env)
    val (rest_env, rest_lambda) =
      trans_fun_dec_list(rest, Environ.augment_top_env(top_env, new_env))
    (* The rest of the functors in the following topdecs
     can reference those defined earlier *)
  in
    (Environ.augment_top_env(new_env, rest_env), new_lambda @@ rest_lambda)
  end
d2207 21
a2227 23
  fun trans_top_dec1(topdec, top_env as EnvironTypes.TOP_ENV(env, top_map),generate_debug,debug_info) =
    let
      val _ = generate_debug_info := generate_debug
      val _ = if generate_debug
                then debug_information := debug_info
              else ()
      val (a,b) = 
        case topdec of
          Absyn.STRDECtopdec (strdec,_) =>
            let
              val (new_env, lambdas) = trans_str_dec(strdec, top_env)
            in
              (make_top_env new_env, lambdas)
            end
        | Absyn.SIGNATUREtopdec _ =>
            (make_top_env Environ.empty_env, [])
        | Absyn.FUNCTORtopdec (funbind_list,_) =>
            trans_fun_dec_list(funbind_list, top_env)
        | Absyn.REQUIREtopdec _ =>
            Crash.impossible"trans_topdec REQUIREtopdec"

      val result_debug_info = ! debug_information
      val _ = debug_information := empty_debug_information
a2230 3
      in
        trans_top_dec1 args
      end
@


1.121
log
@Added TypeRep_Utils parameter and translations of dynamic and coerce expressions
@
text
@d4 3
d1244 1
d1246 7
@


1.120
log
@Removed ref nameset in Absyn.FunBind
@
text
@d4 3
d312 1
d339 1
d346 1
a346 2
    Type_Utils.DataTypes =
    Debugger_Types.Datatypes
d349 1
a349 1
  sharing LambdaUtils.Match.Absyn = AbsynPrint.Absyn
d1239 3
d1243 3
@


1.119
log
@Modifications for COPYSTR.
Added caching of interfaces in structures and environments in interfaces.
@
text
@d4 4
d2124 1
a2124 1
      funbind as (funid, strid, sigexp, _, strexp, sigexp_opt,annotation_string,_),
@


1.118
log
@Fixed bug in matching lists in value declarations.
@
text
@d4 3
a331 1
  sharing Environ.Interface = AbsynPrint.Absyn.Interface
d345 1
a345 1
  sharing LambdaUtils.Match.Info = Types.Info = AbsynPrint.Info
d350 2
a351 1
  structure DataTypes = Absyn.Datatypes
d354 1
a354 1
  structure Map = DataTypes.Mapping
d358 1
a358 1
  structure NewMap = DataTypes.NewMap
a359 1
  structure Interface = Environ.Interface
d404 1
a404 1
  fun is_list_type (DataTypes.CONSTYPE(_, tyname)) =
d426 3
d501 1
a501 1
  fun is_overloaded(DataTypes.FUNTYPE(DataTypes.RECTYPE record_map, _)) =
d503 1
a503 1
      (_, DataTypes.META_OVERLOADED(ref ty,_)) :: _ =>
d505 2
a506 2
	   DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
	 | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
d509 1
a509 1
  | is_overloaded(DataTypes.FUNTYPE(DataTypes.META_OVERLOADED (ref ty,_), _)) =
d511 2
a512 2
      DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
    | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
d516 1
a516 1
  fun domain_tyname(DataTypes.FUNTYPE(DataTypes.RECTYPE record_map, _)) =
d520 1
a520 1
	    DataTypes.CONSTYPE(_, tyname) => (true, tyname)
d527 2
a528 2
      (true, DataTypes.TYNAME{2=s,...}) => (true, s)
    | (true, DataTypes.METATYNAME{2=s,...}) => (true, s)
d531 1
a531 1
  fun check_no_vcc_for_eq(DataTypes.FUNTYPE(DataTypes.RECTYPE record_map, _)) =
d538 1
a538 1
	      DataTypes.CONSTYPE _ =>
d726 1
a726 1
  fun compare_sig_env(Interface.INT(Interface.INTENV intenv, v_list, e_list),
d747 1
a747 1
    intenv as Interface.INTENV s_int_map, v_list, e_list),
d1349 1
a1349 1
	       DataTypes.FUNTYPE _ => true
d2060 5
a2064 4
          | Absyn.PRESENT(Absyn.NEWsigexp(_, ref inte)) =>
              LambdaTypes.PRESENT inte
          | Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte,_)) =>
              LambdaTypes.PRESENT inte
d2115 3
a2117 2
  fun interface_from_sigexp(Absyn.NEWsigexp(_, ref interface)) = interface
  | interface_from_sigexp(Absyn.OLDsigexp(_, ref interface,_)) = interface
d2128 5
a2132 4
      | Absyn.PRESENT(Absyn.NEWsigexp(_, ref inte)) =>
	  LambdaTypes.PRESENT inte
      | Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte,_)) =>
	  LambdaTypes.PRESENT inte
@


1.117
log
@Deleted label handling in lambda translator.
@
text
@d4 3
d1676 4
a1679 1
			      if is_list_type ty then lexp else GetConVal lexp
@


1.116
log
@Changes to support new representation of lists.
@
text
@d4 3
d329 1
d358 1
d1182 1
a1182 1
                               Match.compile_match options pat_exp_list
d1204 1
a1204 1
            Match.compile_match options pat_exp_list
d1224 25
a1248 52
(* The match translator.
   For a definition of the input supplied, see match.sml
   For a definition of the support routines used, see lambdautils.sml
   The match tree has seven variants, handled as follows:-
   ERROR - raise match
   LEAF - bind the valids to the lambda variables associated with the match
   vars (thus updating the value environment, but not generating any code)
   and translate the expression within this new value environment
   RECORD - for each label, matchvar pair, produce a lambdavar, lambdaexp pair
   where the lambdaexp expresses the selection of the labelled item from the
   record, and the lambdavar is bound to it and also to the matchvar.
   Translate the tree in this new match environment, and let_lambdas_in_exp
   of the lambdavar, lambdaexp list and the translation of the tree.
   SCON - switch on the value of the lambda variable associated with the
   matchvars into the labelled cases or the default. See also LABEL and GOTO
   CONSTRUCTOR - only matchvars corresponding to value carrying constructors
   are relevant here. For each of these, the associated value is
   SELECT(1, VAR lambda of original matchvar) (though the type of this may
   vary, the way of acquiring it doesn't), or if the type has precisely one
   constructor, and this is value carrying, then the value is
   VAR lambda of original matchvar. The result is basically a switch, with
   various possibilities according to how many constructors the type has,
   whether all are mentioned here, whether all nullary constrcutors are
   mentioned etc. See also LABEL and GOTO
   LABEL and GOTO - These pose more of a problem. They are an attempt to avoid
   re-evaluating large expressions by commoning up the evaluation and
   binding it to a lambda variable which will then be referenced at the
   relevant points. There are two problems here. Firstly, there may be label
   definitions which are not referenced. Any default case can give rise to
   such an occurrence. These must be translated as the though the label was
   not present at all. This would be easy, were it not for the more difficult
   case of labels which are referred to. For such a label, we need to find
   the point furthest down the tree such that all occurrences of the label
   are below this point and there is no lower point with this property.
   Clearly such a point is either a CONSTRUCTOR or an SCON node, as these
   are the only ones at which branching takes place. We find these points
   by scanning down all arms of a branch looking for all definitions and
   references, remvoing all labels already know about (found by the same
   process at a higher point of the tree), then finding precisely those
   labels mentioned down more than one arm of the tree. For each of these,
   we should have found a definition and some references, and the definition
   will contain a tree to be evaluated there. The point now is that the
   tree cannot refer to any match variables definied at or below the
   current point, since these would be invalid in any reference to it.
   Hence the definition can be translated at the current node, and a lambda
   variable associated with it. The resulting code for the current node is
   let_lambdas_in_exp(translations of all relevant label definitions,
   translation of the current node). The LABEL and GOTO nodes are simply
   translated as VAR(lambda of label), or in the case of a label
   definition which is never referenced, the label is ignored and the tree
   translated as normal.
  *)
d1257 1
a1257 1
                                                     [LambdaTypes.BUILTIN Pervasives.EXMATCH, LambdaTypes.STRUCT []]))
d1261 39
a1299 39
            val all_labels as LambdaUtils.LABELS labels =
              LambdaUtils.scan_tree(tree, LambdaUtils.empty_label_env)
            val ref_labels =
              Lists.filterp (fn (LambdaUtils.LABEL _, _) => false | _ => true)
              (NewMap.to_list labels)
            fun remove_both(LambdaUtils.LABELS labels, (label, _)) =
              let val real_label = case label of LambdaUtils.LABEL lab => lab
            | LambdaUtils.GOTO lab => lab
              in
                LambdaUtils.LABELS (NewMap.undefine(
                                                    NewMap.undefine(labels, LambdaUtils.GOTO real_label),
                                                    LambdaUtils.LABEL real_label))
              end
            val LambdaUtils.LABELS def_only_labels =
              Lists.reducel remove_both (all_labels, ref_labels)
	    (* In theory, we don't need this, we could simply assume
	     that any label not found in the label_env at the relevant
	     point is an unreferenced label, but belt and braces for the
	     moment *)
            fun handle_default_trees(lab_tree_list, match_env, val_env, label_env) =
              let	val lab_lv_le_list = map (fn (lab, LambdaTypes.PRESENT tree') =>
                                                  (lab, LambdaTypes.new_LVar(),
                                                   LambdaTypes.FN(LambdaTypes.new_LVar(), 
                                                                  tr_match(tree', match_env, val_env, label_env),
                                                                  "Part of match translation (i) " ^ name_string,
                                                                  LambdaTypes.null_type_annotation))
	    (* Translate the tree to a function definition (not depending
	     on its parameter), which will be applied if we arrive at
	     that point of the tree
	     *)
            | _ => Crash.impossible "trans_node(1)") lab_tree_list
              in
                (map (fn (_, lv, le) => LambdaTypes.LETB(lv, le,"Translation of match trees")) lab_lv_le_list,
                 Lists.reducel
                 (fn (x, (lab, lv, _)) => LambdaUtils.add_label_env((lab, lv), x))
                 (label_env, lab_lv_le_list))
              end
            
            and tr_match(tree, match_env, val_env, lab_env) =
d1307 1
a1307 1
                                                                EnvironTypes.LAMB(LambdaUtils.lookup_match(mv, match_env)))))
d1312 51
a1362 91
              | Match.SCON(mv, scon_tree_list, default) =>
                  let
                    val (lv_le_list, lab_env') =
                      trans_node(tree, match_env, val_env, lab_env)
                    val new_lab_env = LambdaUtils.augment_label_env(lab_env, lab_env')
                  in
                    let_lambdas_in_exp(
                                       lv_le_list,
                                       LambdaTypes.SWITCH(
                                                          LambdaTypes.VAR(LambdaUtils.lookup_match(mv, match_env)),
                                                          LambdaTypes.ABSENT,
                                                          map (fn(scon, tree) =>
                                                               (LambdaTypes.SCON_TAG scon,
                                                                tr_match(tree, match_env, val_env, new_lab_env)))
                                                          scon_tree_list,
                                                          case default of
                                                            Match.PRESENT tree =>
                                                              LambdaTypes.PRESENT(
                                                                                  tr_match(tree, match_env, val_env, new_lab_env))
                                                          | Match.ABSENT => LambdaTypes.ABSENT
                                                              )
                                       )
                  end
              | Match.CONSTRUCTOR(ty, mv, longvalid_mv_tree_list, default) =>
                  let
                    val (lv_le_list, lab_env') =
                      trans_node(tree, match_env, val_env, lab_env)
                    val new_lab_env = LambdaUtils.augment_label_env(lab_env, lab_env')
                    val orig_lv = LambdaUtils.lookup_match(mv, match_env)
                    val lv_e = LambdaTypes.VAR orig_lv
                    val (def_lambda, lv_le_list) =
                      let
                        val new_lv = LambdaTypes.new_LVar()
                      in
                        case default of
                          Match.PRESENT tree =>
                            let
                              val le = tr_match(tree, match_env, val_env, new_lab_env)
                            in
                              (LambdaTypes.PRESENT(
                                                   LambdaTypes.APP(LambdaTypes.VAR new_lv,
                                                                   LambdaTypes.STRUCT [],
                                                                   LambdaTypes.null_type_annotation)),
                              lv_le_list @@ 
                              [LambdaTypes.LETB(
                                                new_lv,
                                                LambdaTypes.FN(LambdaTypes.new_LVar(),
                                                               le,
                                                               "Part of match translation (ii) " ^
                                                               name_string,
                                                               LambdaTypes.null_type_annotation),
                                                "")
                              ]
                              )
                            end
                        | _ => (LambdaTypes.ABSENT, lv_le_list)
                      end
                    
                    val (_,type_val_env) =
                      Type_Utils.get_valenv(Type_Utils.get_cons_type ty)
                      
                    val is_exn =
                      case longvalid_mv_tree_list of
                        {1=Ident.LONGVALID(_, Ident.EXCON _), ...} :: _ => true
                      | {1=Ident.LONGVALID(_, Ident.CON _), ...} :: _ => false
                      | _ => Crash.impossible "Match.CONS bad arg"
                          
                    fun has_value(Ident.LONGVALID(_, valid as Ident.CON _)) =
                      (case Type_Utils.type_from_scheme(
                                                        NewMap.apply'(type_val_env, valid)) of
                         DataTypes.FUNTYPE _ => true
                       | _ => false
                           )
                      |   has_value(Ident.LONGVALID(_, Ident.VAR _)) =
                          Crash.impossible"VAR in match CONS"
                      |   has_value(Ident.LONGVALID(_, Ident.EXCON excon)) = true
                    (* Pretend all exceptions carry values, even if only unit *)
                    val new_lv = LambdaTypes.new_LVar()
                    val new_le = GetConVal lv_e
                    val con_field = GetConTag lv_e
                    val vcc_lv_list =
                      Lists.filterp (has_value o #1) longvalid_mv_tree_list
                    (* Note we're using the same lambda variable for all the
                     vcc matchvars, since they're all going to be the same
                     expression, viz SELECT(1, original matchvar) (aka new_le) *)
                      
                    (* mk_branch produces a (tag, code) pair, for a branch of the
                     SWITCH. *)
                    fun mk_branch (id as Ident.LONGVALID(_, valid), mv, tree) =
                      if has_value id then
                        (LambdaTypes.VCC_TAG(#2(constructor_tag(valid, ty))),
d1377 1
a1377 2
	                     val_env,
	                     new_lab_env)
d1379 84
a1462 104
                           LambdaTypes.do_binding(
                             (* Assign lambda variable to value carried by
                                constructor.
			      *)
			     LambdaTypes.LETB(new_lv,
					      new_le,
					      "match translation"),
                             tr_match(
                               tree,
                               LambdaUtils.add_match_env((mv, new_lv), match_env),
                               val_env,
                               new_lab_env)
                             ))
                      else
                        (LambdaTypes.IMM_TAG(#2(constructor_tag(valid, ty))),
                         tr_match(tree, match_env, val_env, new_lab_env)
                         )
                  in
                    case is_exn of
                      false =>
                        (* Not an exception constructor *)
                        let_lambdas_in_exp(
                                           lv_le_list,
                                           if Type_Utils.get_no_cons ty = 1 then
                                             (* Use this instead of Type_Utils.has_value_cons ty, because
                                              we want to know about explicitly mentioned constructors
and we want to treat all EXCONS as VCCs. *)
                                             if Lists.length vcc_lv_list <> 0 then
                                               (* Handle case of only one constructor, carrying a value *)
                                               (* This relies on constructor nodes only arising when *)
                                               (* some constructor is actually quoted, not bad I suppose *)
                                               let val (name, mv, tree) =
                                                 case vcc_lv_list of
                                                   [x] => x
                                                 | _ => Crash.impossible "list size"
                                               (*
val name =
                                                case longvalid_mv_tree_list of
                                                  {1=longvalid, ...} :: _ => longvalid
                                                 | _ => Crash.impossible "list size"
                                                     *)
                                               in
                                                 (* Check to see if its ref (handled specially) *)
                                                 if Environ.Builtin_p(name, val_env) 
                                                   andalso (case cg_longvalid(name,val_env) of
                                                              LambdaTypes.BUILTIN(Pervasives.REF) => true 
                                                            | _ => false) then
                                                   (* Must be ref *)
                                                   let val ref_lv = LambdaTypes.new_LVar ();
                                                   in
                                                     LambdaTypes.do_binding(
                                                                            LambdaTypes.LETB(
                                                                                             ref_lv,
                                                                                             LambdaTypes.APP(
                                                                                                             LambdaTypes.BUILTIN Pervasives.DEREF,
                                                                                                             LambdaTypes.VAR orig_lv,
                                                                                                             LambdaTypes.null_type_annotation),
                                                                                             "match translation (iv)"),
                                                                            tr_match(tree,
                                                                                     LambdaUtils.add_match_env((mv, ref_lv),
                                                                                                               match_env),
                                                                                     val_env,
                                                                                     new_lab_env)
                                                                            )
                                                   end
                                                 else
                                                   (* Ensure we pass through the value by assigning the
                                                    same lambda variable to the new matchvar as we had
                                                    passed through in the first place. This works since
                                                    the constructor has no effect on the representation
                                                              of the value (only one constructor case) *)
                                                   tr_match(tree,
                                                            LambdaUtils.add_match_env((mv, orig_lv),
                                                                                      match_env),
                                                            val_env,
                                                            new_lab_env)
                                               end
                                             else
                                               (* Only one constructor, with no value *)
                                               let val tree = case longvalid_mv_tree_list of
                                                 [(_, _, tree)] => tree
                                               | _ => Crash.impossible "list size"
                                               in
                                                 (* No value to be passed through here *)
                                                 tr_match(tree, match_env, val_env, new_lab_env)
                                               end
                                           else
                                             (* More than one constructor in this type. Must switch *)
                                             LambdaTypes.SWITCH(
                                                                lv_e,
                                                                LambdaTypes.PRESENT{
                                                                                    lv = LambdaTypes.new_LVar(),
                                                                                    num_vccs = Type_Utils.get_no_vcc_cons ty,
                                                                                    num_imms = Type_Utils.get_no_null_cons ty
                                                                                    },
                                                                map mk_branch longvalid_mv_tree_list,
                                                                if Lists.length longvalid_mv_tree_list =
                                                                  Type_Utils.get_no_cons ty then
                                                                  LambdaTypes.ABSENT (* No default here if all cases ok *)
                                                                else def_lambda
                                                                  ) (* end of LambdaTypes.SWITCH *)
                                             ) (* end of let_lambdas_in_exp *)
	  | true =>
	      (* Is an exception constructor *)
d1464 1
a1464 1
		LambdaTypes.LETB(new_lv, new_le, "") :: lv_le_list,
d1476 1
a1476 2
		  	             val_env,
			             new_lab_env)
d1480 8
a1487 3
		  def_lambda
		)
	      )
d1490 2
a1491 1
	let val lab_mv_lv_list =
d1511 2
a1512 2
	  (lv_le_list, tr_match(tree, new_env, val_env, lab_env))
	(* Binding lambdas to selects off a record is side effect free *)
d1514 1
a1514 49

      | Match.LABEL(label, tree) =>
	(* Treat like a GOTO, except where the label is never referenced *)
	  (case NewMap.tryApply'(def_only_labels, LambdaUtils.LABEL label) of
	     NewMap.NO =>
	       LambdaTypes.APP
	       (LambdaTypes.VAR(LambdaUtils.lookup_label(label, lab_env)),
		LambdaTypes.STRUCT [],
		LambdaTypes.null_type_annotation)
	   | _ =>
	       tr_match(tree, match_env, val_env, lab_env))
      | Match.GOTO label =>
	LambdaTypes.APP(
	  LambdaTypes.VAR(LambdaUtils.lookup_label(label, lab_env)),
	  LambdaTypes.STRUCT [],
	  LambdaTypes.null_type_annotation)
      (* We apply the lambda var to unit to evaluate it at this point
       rather than at the common point higher up the tree *)

    and trans_node(tree, match_env, val_env, label_env) = case tree of
      Match.ERROR => ([], LambdaUtils.empty_label_env)
    | Match.LEAF _ => ([], LambdaUtils.empty_label_env)
    | Match.LABEL _ => ([], LambdaUtils.empty_label_env)
    | Match.GOTO _ => ([], LambdaUtils.empty_label_env)
    | Match.RECORD _ => ([], LambdaUtils.empty_label_env)
      (* The above five have no branching, so can't produce any new labels *)
    | Match.SCON(_, scon_tree_list, default) =>
      let
	val main_list = scon_tree_list
	val final_list = case default of Match.ABSENT => main_list
	  | Match.PRESENT tree' => (Ident.INT("",Absyn.Location.UNKNOWN), tree') :: main_list
	val new_list = LambdaUtils.find_repeats(
          map (fn (_, x) => LambdaUtils.scan_tree(x, label_env)) final_list)
      in
	handle_default_trees(new_list, match_env, val_env, label_env)
      end
    | Match.CONSTRUCTOR(_, _, valid_mv_tree_list, default) =>
      let
	val main_list = valid_mv_tree_list
	val final_list =
	  case default of Match.ABSENT => main_list
	| Match.PRESENT tree' =>
	    (Ident.LONGVALID(Ident.NOPATH, Ident.VAR(Symbol.find_symbol "")),
	     Match.to_Matchvar 0, tree') :: main_list
	val new_list = LambdaUtils.find_repeats(
          map (fn (_, _, x) => LambdaUtils.scan_tree(x, label_env)) final_list)
      in
	handle_default_trees(new_list, match_env, val_env, label_env)
      end
d1517 1
a1517 1
      tr_match(tree, match_env, env, LambdaUtils.empty_label_env),name_string,ty)
@


1.115
log
@Anel's last changes
@
text
@d4 3
d394 4
d1027 2
a1028 1
                            if Type_Utils.get_no_cons ty > 1
d1033 5
a1037 5
                            if location = "" then
			      ("constructor " ^ Symbol.symbol_name symbol)
                            else
			      ("constructor " ^ Symbol.symbol_name symbol ^
			       " from datatype in " ^ location),
d1430 25
a1454 13
                         LambdaTypes.do_binding(
                           (* Assign lambda variable to value carried by
                              constructor.
			    *)
			   LambdaTypes.LETB(new_lv,
					    new_le,
					    "match translation"),
                           tr_match(
                             tree,
                             LambdaUtils.add_match_env((mv, new_lv), match_env),
                             val_env,
                             new_lab_env)
                           ))
d1798 3
a1800 1
			    [(LambdaTypes.VCC_TAG tag, GetConVal lexp)],
@


1.114
log
@Changed int and real scons to carry a location around
@
text
@d4 3
d483 1
a483 1
      (_, DataTypes.META_OVERLOADED(ref ty)) :: _ =>
d489 1
a489 1
  | is_overloaded(DataTypes.FUNTYPE(DataTypes.META_OVERLOADED (ref ty), _)) =
@


1.113
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d340 1
d1599 1
a1599 1
	  | Match.PRESENT tree' => (Ident.INT"", tree') :: main_list
@


1.112
log
@Changed an error message.
@
text
@d4 3
a275 1
require "../match/match";
a303 1
  structure Match : MATCH
d318 1
a318 2
    AbsynPrint.Absyn.Interface.Datatypes =
    Match.Absyn.Datatypes = Types.Datatypes =
d323 1
a323 1
  sharing Match.Absyn = AbsynPrint.Absyn
a325 1
  sharing LambdaUtils.Match = Match
d327 1
a327 1
  sharing Match.Info = Types.Info = AbsynPrint.Info
d343 1
a343 1

@


1.111
log
@Deleted some list optimisation code that crept in prematurely.
@
text
@d4 3
d685 1
a685 1
            show(1, to_mark, patterns, "Redundant patterns:")
@


1.110
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
a381 4
  fun is_list_type (DataTypes.CONSTYPE(_, tyname)) =
    Types.tyname_eq(tyname, Types.list_tyname)
  |   is_list_type _ = false

d1011 1
a1011 2
                            if Type_Utils.get_no_cons ty > 1  andalso
                               not(is_list_type (Type_Utils.get_cons_type ty))
d1016 5
a1020 5
                              if location = "" then
			        ("constructor " ^ Symbol.symbol_name symbol)
                              else
				("constructor " ^ Symbol.symbol_name symbol ^
				 " from datatype in " ^ location),
d1413 13
a1425 25
	                 if is_list_type ty then
	                  (* Now we do some bizarre stuff.  The match compiler
			     still produces a match variable for the argument
			     of cons, so we have to bind it to the expression
			     being matched.
	                  *)
	                   tr_match(
	                     tree,
	                     LambdaUtils.add_match_env((mv, orig_lv), match_env),
	                     val_env,
	                     new_lab_env)
	                 else
                           LambdaTypes.do_binding(
                             (* Assign lambda variable to value carried by
                                constructor.
			      *)
			     LambdaTypes.LETB(new_lv,
					      new_le,
					      "match translation"),
                             tr_match(
                               tree,
                               LambdaUtils.add_match_env((mv, new_lv), match_env),
                               val_env,
                               new_lab_env)
                             ))
d1769 1
a1769 3
			    [(LambdaTypes.VCC_TAG tag,
			      if is_list_type ty then lexp else GetConVal lexp
			    )],
@


1.109
log
@Changed Error structure to Info
@
text
@d4 3
a304 1
  structure Info : INFO
d321 1
a321 1
  sharing AbsynPrint.Absyn.Location = Info.Location
d336 1
a336 1
  structure Info = Info
d378 4
d429 2
a430 2
         Crash.impossible("constructor_tag(3): " ^ Types.print_type ty ^ "," ^
                          IdentPrint.printValId valid))
d508 1
a508 2
	   ((*Print.print("Checking type of " ^ Types.print_type h ^ "\n");*)
	    case h of
d679 1
a679 1
                     AbsynPrint.unparsePat p ^
d733 1
a733 1
	  IdentPrint.printValId), 0,
d739 1
a739 1
	(fn (x, _) => Print.print(IdentPrint.printValId x ^ "\n"))
d743 1
a743 1
	(fn x => Print.print(IdentPrint.printValId x ^ "\n"))
d751 1
a751 1
	  IdentPrint.printValId), next1,
d1011 3
a1013 1
                            if Type_Utils.get_no_cons ty > 1 then
d1017 6
a1022 4
                              if location = ""
                                then ("constructor " ^ Symbol.symbol_name symbol)
                              else ("constructor " ^ Symbol.symbol_name symbol ^ " from datatype in " ^ location) ,
                                LambdaTypes.null_type_annotation)
d1161 1
a1161 1
                               Match.compile_match pat_exp_list
d1166 1
a1166 1
                                (fn x => output (std_out,x)) (Match.unparseTree tree "");
d1183 1
a1183 1
            Match.compile_match pat_exp_list
d1188 1
a1188 1
              (fn x => output (std_out,x)) (Match.unparseTree tree "");
d1203 52
a1254 52
        (* The match translator.
         For a definition of the input supplied, see match.sml
         For a definition of the support routines used, see lambdautils.sml
         The match tree has seven variants, handled as follows:-
         ERROR - raise match
         LEAF - bind the valids to the lambda variables associated with the match
         vars (thus updating the value environment, but not generating any code)
and translate the expression within this new value environment
  RECORD - for each label, matchvar pair, produce a lambdavar, lambdaexp pair
  where the lambdaexp expresses the selection of the labelled item from the
  record, and the lambdavar is bound to it and also to the matchvar.
  Translate the tree in this new match environment, and let_lambdas_in_exp
                 of the lambdavar, lambdaexp list and the translation of the tree.
                   SCON - switch on the value of the lambda variable associated with the matchvar
                   into the labelled cases or the default. See also LABEL and GOTO
                   CONSTRUCTOR - only matchvars corresponding to value carrying constructors
                   are relevant here. For each of these, the associated value is
                   SELECT(1, VAR lambda of original matchvar) (though the type of this may
                   vary, the way of acquiring it doesn't), or if the type has precisely one
                   constructor, and this is value carrying, then the value is
                   VAR lambda of original matchvar. The result is basically a switch, with
                   various possibilities according to how many constructors the type has,
                   whether all are mentioned here, whether all nullary constrcutors are
                   mentioned etc. See also LABEL and GOTO
                   LABEL and GOTO - These pose more of a problem. They are an attempt to avoid
                   re-evaluating large expressions by commoning up the evaluation and
                   binding it to a lambda variable which will then be referenced at the
                   relevant points. There are two problems here. Firstly, there may be label
                   definitions which are not referenced. Any default case can give rise to
                   such an occurrence. These must be translated as the though the label was
                   not present at all. This would be easy, were it not for the more difficult
                   case of labels which are referred to. For such a label, we need to find
                     the point furthest down the tree such that all occurrences of the label
                     are below this point and there is no lower point with this property.
                     Clearly such a point is either a CONSTRUCTOR or an SCON node, as these
                     are the only ones at which branching takes place. We find these points
                     by scanning down all arms of a branch looking for all definitions and
                     references, remvoing all labels already know about (found by the same
                     process at a higher point of the tree), then finding precisely those
                     labels mentioned down more than one arm of the tree. For each of these,
                     we should have found a definition and some references, and the definition
                     will contain a tree to be evaluated there. The point now is that the
                     tree cannot refer to any match variables definied at or below the
                     current point, since these would be invalid in any reference to it.
                     Hence the definition can be translated at the current node, and a lambda
                     variable associated with it. The resulting code for the current node is
                     let_lambdas_in_exp(translations of all relevant label definitions,
                     translation of the current node). The LABEL and GOTO nodes are simply
                     translated as VAR(lambda of label), or in the case of a label
                     definition which is never referenced, the label is ignored and the tree
                     translated as normal.
                     *)
a1394 5
                    (*
val nullary_list =
                     Lists.filterp (fn(v, _, _) => not(has_value v))
                     longvalid_mv_tree_list
                     *)
d1397 1
a1397 1
                    val get_con_field = GetConTag lv_e
d1409 30
a1438 9
                         LambdaTypes.do_binding(
                                                (* Assign lambda variable to value carried by constructor *)
                                                LambdaTypes.LETB(new_lv, new_le, "match translation"),
                                                tr_match(
                                                         tree,
                                                         LambdaUtils.add_match_env((mv, new_lv), match_env),
                                                         val_env,
                                                         new_lab_env)
                                                ))
a1446 3
                        (*
                         <<<<<<< _lambda.sml
                         *)
a1527 84
              (*
               =======
               let_lambdas_in_exp(lv_le_list,
               if Type_Utils.get_no_cons ty = 1 then
                 if Lists.length nullary_list = 0 then
                   (* Handle case of only one constructor, carrying a value *)
                   (* This relies on constructor nodes only arising when *)
                   (* some constructor is actually quoted, not bad I suppose *)
                   let val (mv', lv, tree) = case vcc_lv_list of
                     [(_, mv, tree)] => (mv, new_lv, tree)
                   | _ => Crash.impossible"list size"
                       val name = case longvalid_mv_tree_list of
                         {1=longvalid, ...} :: _ => longvalid
                       | _ => Crash.impossible"list size"
                   (* Check to see if it's ref (handled specially) *)
                   in
                     if Environ.Builtin_p(name, val_env) 
                       andalso (case cg_longvalid(name,val_env) of
                                  LambdaTypes.BUILTIN(Pervasives.REF) => true 
                                | _ => false)
                       then
                         (* Must be ref *)
                         LambdaTypes.do_binding
                         (LambdaTypes.LETB(new_lv,
                                           LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                           LambdaTypes.VAR orig_lv,
                                                           LambdaTypes.null_type_annotation),
                                           "match translation (iv)"),
                         tr_match(tree, LambdaUtils.add_match_env(
                                                                  (mv', new_lv), match_env), val_env, new_lab_env))
                     else
                       tr_match(tree, LambdaUtils.add_match_env(
                                                                (mv', orig_lv), match_env), val_env, new_lab_env)
                   (* Ensure we pass through the value by assigning the same
                    lambda variable to the new matchvar as we had passed through
                    in the first place. This works since the constructor has no
                    effect on the representation of the value (only one
                    constructor case) *)
                   end
	    else
	      (* Only one constructor, with no value *)
	      let val tree = case nullary_list of
		[(_, _, tree)] => tree
	      | _ => Crash.impossible"list size"
	      in
		tr_match(tree, match_env, val_env, new_lab_env)
		(* No value to be passed through here *)
	      end
	  else
	    (* More than one constructor in this type. Must switch *)
	    LambdaTypes.SWITCH(lv_e, map (fn (Ident.LONGVALID(_, valid), _,
              tree) => (LambdaTypes.CON_TAG(#2(constructor_tag(valid, ty))),
                tr_match(tree, match_env, val_env, new_lab_env))) nullary_list,
		  if Lists.length nullary_list = Type_Utils.get_no_null_cons ty then
		    LambdaTypes.ABSENT (* No default here if all cases ok *)
		  else def_lambda, if not(Type_Utils.has_value_cons ty) then
		    LambdaTypes.ABSENT (* No code if no vcc *)
		    else LambdaTypes.PRESENT(
		  (* Got some vcc to match with *)
	    if Lists.length vcc_lv_list = 1 andalso Type_Utils.get_no_vcc_cons ty = 1 then
	      (* Only one vcc, and we've got it, so no SWITCH *)
	      let val (valid, mv', tree, lv) = case vcc_lv_list of
		[(v, m, t)] => (v, m, t, new_lv)
	      | _ => Crash.impossible"list length"
	      in
		LambdaTypes.do_binding(LambdaTypes.LETB(lv, new_le,"match translation (v)"),
		tr_match(tree, LambdaUtils.add_match_env((mv', lv),
                  match_env), val_env, new_lab_env))
		(* Still need to pass on the value though *)
	      end			     
	    else
	      (* More than one vcc to match against *)
	    LambdaTypes.do_binding(LambdaTypes.LETB(new_lv, new_le,""),
	    (* Assign lambda variable to value carried by constructor *)
	    LambdaTypes.SWITCH(get_con_field,
              map (fn (Ident.LONGVALID(_, valid), mv, tree) =>
	    (LambdaTypes.CON_TAG(#2(constructor_tag(valid, ty))),
              tr_match(tree, LambdaUtils.add_match_env((mv, new_lv),
                match_env), val_env, new_lab_env))) vcc_lv_list,
	      if Lists.length vcc_lv_list = Type_Utils.get_no_vcc_cons ty then
		LambdaTypes.ABSENT (* No default here if all cases ok *)
	      else def_lambda, LambdaTypes.ABSENT)))))
>>>>>>> 1.106
*)
d1531 1
a1531 1
		LambdaTypes.LETB(new_lv, new_le,"") :: lv_le_list,
d1533 1
a1533 1
		  select_exn_unique get_con_field,
d1783 2
a1784 1
			      GetConVal lexp)],
@


1.108
log
@Changes to allow IntNewMap to be used on MatchVar
@
text
@d4 3
d267 1
a267 1
require "../main/error";
d302 1
a302 1
  structure Error : ERROR
d319 1
a319 1
  sharing AbsynPrint.Absyn.Location = Error.Location
d334 1
a334 1
  structure Error = Error
d658 2
a659 2
  fun print_redundancy_info ([], _, _) = ()
    | print_redundancy_info (clauses, pat_exp_list, location) =
d680 1
a680 3
        Error.report
        (Error.ERROR (Error.WARNING, location,
                      to_string (clauses, map (fn (x,_) => x) pat_exp_list)))
a682 6
(** Now we need a function that will translate from abstract syntax to
    lambda expressions.  This is done on the way to translating to the
    machine description directly.
    Take an Absyn.Exp and a list of substitutions, and for each type
    of expression translate into the relevant piece of lambda
    calculus.  **)
d684 23
a706 12
  fun trans_exp(name, x, env) =
    case x of
(** Special constants are easy! **)
      Absyn.SCONexp sc => LambdaTypes.SCON sc
(** Lambda variable lookup, except for built-in values for which we
    extract the primitive value that the Environ has for this
    built-in. What's the Type ref for? **)
(*  This may be more than just variable lookup.
    The longValId may be a nullary type constructor,
    or an exception constructor. We must eliminate these cases first,
    before attempting code generation of a lambda variable from the
    environment.
d708 175
a882 124
    | Absyn.VALexp(longValId, ref ty,_) => (case longValId of
      Ident.LONGVALID(p, valid as Ident.VAR sy) =>
      let
	val nopath = case p of
	  Ident.NOPATH => true
	| _ => false
	val (is_ol, name) = is_overloaded ty
	val sy_name = Symbol.symbol_name sy
	val _ = if is_ol then
          diagnose("Overloaded operator " ^ sy_name ^
		" with type " ^ name ^ "\n")
		else ()
	val env_ol =
	  case p of
	    Ident.NOPATH =>
	      (case Environ.lookup_valid(valid, env) of
		 EnvironTypes.PRIM _ => Environ.is_overloaded_op valid
	       | _ => false)
	  | _ => false
	val _ = if is_ol <> env_ol then
	  Diagnostic.output 0
          (fn _ => ["Overload clash on " ^ sy_name ^ "\nis_ol = " ^
		      (if is_ol then "true\n" else "false\n")])
		else ()
	val cg = 
          if is_ol then 
	    cg_longvalid(Ident.LONGVALID(Ident.NOPATH, 
					 Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name))),
			 Primitives.env_for_lookup_in_lambda)
	  else
	    cg_longvalid(longValId,env)
	val new_cg =
	  case cg of
	    LambdaTypes.BUILTIN Pervasives.IDENT_FN => ident_code()
	  | LambdaTypes.BUILTIN prim =>
	      if (* cg <> eq_prim *) isnt_eq_prim cg
                andalso (* cg <> neq_prim *) isnt_neq_prim cg
                then cg
	      else
		let
		  val sy_name = if is_eq_prim cg (* cg = eq_prim *)
                                  then "=" else "<>"
		  val simple_and_name as (is_simple, name) = 
		    domain_type_name ty
		  val ident =
		    Ident.LONGVALID
		    (Ident.NOPATH, Ident.VAR(Symbol.find_symbol("_" ^ name ^
								sy_name)))
		  val has_no_vcc =
		    is_simple andalso check_no_vcc_for_eq ty
		  val has_no_vcc =
		    has_no_vcc orelse
		    (if Types.tyname_eq(Types.ref_tyname, #2(domain_tyname ty))
		       then
			 true
		     else
		       false)
		  val simple_and_name =
		    if has_no_vcc then
		      (true, "int")
		    else
		      simple_and_name
		  val ident =
		    if has_no_vcc then
		      Ident.LONGVALID
		      (Ident.NOPATH, Ident.VAR(Symbol.find_symbol("_int" ^
								  sy_name)))
		    else
		      ident
		in
		  case simple_and_name of
		    (false, _) => cg
		  | (_, "int") =>
		      cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		  | (_, "real") =>
		      cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		  | (_, "string") =>
		      cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		  | _ => cg
		end
	  | _ => cg
      in
	new_cg
      end
    | Ident.LONGVALID(_, valid as Ident.CON symbol) =>
      let
        val (location,tag) = constructor_tag(valid, ty)
	val lexp = LambdaTypes.INT(tag)
      in
	if Environ.Builtin_p(longValId, env) then
	  LambdaTypes.BUILTIN(Environ.FindBuiltin(longValId, env))
	else
	  if Type_Utils.is_vcc ty then
	    let
	      val new_lv = LambdaTypes.new_LVar()
	    in
	      LambdaTypes.FN
	      (new_lv,
	       if Type_Utils.get_no_cons ty > 1 then
		 LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv])
	       else
		 LambdaTypes.VAR new_lv,
                 if location = ""
                   then ("constructor " ^ Symbol.symbol_name symbol)
                 else ("constructor " ^ Symbol.symbol_name symbol ^ " from datatype in " ^ location) ,
		 LambdaTypes.null_type_annotation)
	    end
	  else
	    lexp
      end
    | Ident.LONGVALID(_, valid as Ident.EXCON _) =>
      let val le = cg_longexid(longValId, env)
      in
	if Type_Utils.is_vcc ty then
	  let
	    val lv = LambdaTypes.new_LVar()
	  in
	    LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],
			   "Builtin code to construct an exception",
			   LambdaTypes.null_type_annotation)
	  end
	else
	  LambdaTypes.STRUCT[le, LambdaTypes.STRUCT[]]
      end)
d884 1
a884 4
(** Translate each record element, and bundle them up as a STRUCT.
    The ordering is done based on the names of the labels in the
    record, but these are not placed into the STRUCT.  **)
    | Absyn.RECORDexp label_exp_list  =>
d886 176
a1061 20
(** This is a known ordering for the labels of a record.  This will
    always result in records with the same named fields being
    represented by a STRUCT with the same field ordering.
    This is in fact mildly bogus. We need to translate the set of
    expressions in the order in which they were input (ie beware of
    side effects), bind each to lambda variables
 **)
	val lvar_lab_lexp_list =
	  map (fn (lab, exp) =>
	       (lab, LambdaTypes.new_LVar(),
		trans_exp (" no_name", exp, env))) label_exp_list
      in
	let_lambdas_in_exp(map (fn (_, lv, le) =>
				LambdaTypes.LETB(lv, le,
						 "Used in the generation of a record expression"))
			   lvar_lab_lexp_list,
			   LambdaTypes.STRUCT(map (fn (_, lvar, _) =>
						   LambdaTypes.VAR lvar)
					      (Lists.qsort known_order lvar_lab_lexp_list)))
      end
a1062 4
(** Local expressions are tough, so we code up the declaration, and
    then use a series of FN APPs to bind names the the pieces
    returned, and then generate for the exp passed. *)

d1064 11
a1074 11
      let
	val (env', lambda_list) = trans_dec (decl, env)

(** generate Lambda code to bind the names to the values, and then
    call the code generated by transforming the expression.  **)
      in
	let_lambdas_in_exp(lambda_list,
          trans_exp(" no_name", exp, Environ.augment_env(env, env')))
      end

(** Perform the application of the result of translation **)
d1076 65
a1140 65
      let
	val fcn = trans_exp(" inline_app", fun_exp, env)
	val (is_poly, is_eq) =
	  case fcn of
	    LambdaTypes.BUILTIN(Pervasives.EQ) =>
	      (true, true)
	  | LambdaTypes.BUILTIN(Pervasives.NE) =>
	      (true, false)
	  | _ => (false, false)
	val arg =
	  let
	    val arg = trans_exp(" no_name", val_exp, env)
	  in
	    if is_poly then
	      LambdaOptimiser.simple_beta_reduce arg
	    else
	      arg
	  end
	val (good_arg, new_arg, absyn) =
	  if is_poly then
	    (case (arg, val_exp) of
	       (LambdaTypes.STRUCT[le, le' as LambdaTypes.INT _],
		Absyn.RECORDexp[_, (_, valexp as Absyn.VALexp _)]) =>
	       (true, LambdaTypes.STRUCT[le', le], valexp)
	     | (LambdaTypes.STRUCT[le' as LambdaTypes.INT _, le],
		Absyn.RECORDexp[(_, valexp as Absyn.VALexp _), _]) =>
	       (true, LambdaTypes.STRUCT[le', le], valexp)
	     | _ => (false, arg, val_exp))
	  else
	    (false, arg, val_exp)
	val (true_val, false_val) =
	  if is_eq then (LambdaTypes.INT 1, LambdaTypes.INT 0)
	  else (LambdaTypes.INT 0, LambdaTypes.INT 1)
      in
	if is_poly andalso good_arg then
	  let
	    val (exp_arg, tag) = case new_arg of
	      LambdaTypes.STRUCT[LambdaTypes.INT tag, le] => (le, tag)
	    | _ => Crash.impossible "Bad polyeq arg"
	    val ty = case absyn of
	      Absyn.VALexp(_, ref ty,_) => ty
	    | _ => Crash.impossible "Non-val generates poly eq"
	    val def1 =
	      if Type_Utils.get_no_cons ty > 1 then
		LambdaTypes.PRESENT false_val
	      else
		LambdaTypes.ABSENT
	  in
	    LambdaTypes.SWITCH
	    (exp_arg,
	     LambdaTypes.PRESENT {lv = LambdaTypes.new_LVar(),
				  num_imms = 1,
				  num_vccs = 0},
	     [(LambdaTypes.IMM_TAG tag, true_val)],
	     def1)
	  end
	else 
	  case fcn of
	    LambdaTypes.FN(var,body,_,_) =>
	      LambdaTypes.LET(var,arg,body)
	  | _ => LambdaTypes.APP(fcn, arg, 
				 annotation)  (***)
      end
(** Throw away the type information (for now), and just transform the
    expression. This is in fact all we need to do, the type is irrelevant **)
d1142 1
a1142 1
(** Code to cope with 'catch' and 'throw' of exceptions **)
d1146 1
a1146 1

d1149 22
a1170 22
	  trans_exp(annotation, exp, env),
          let
	    val (root, tree,redundant_clauses,not_exhaustive) =
	      Match.compile_match pat_exp_list
          in
	    if !show_match then
	      (Print.print"Exception match tree is\n";
	       Lists.iterate
	       (fn x => output (std_out,x)) (Match.unparseTree tree "");
	       Print.print"\n";
	       ())
	    else ();
            case redundant_clauses of
              [] => ()
            | r => print_redundancy_info (r,pat_exp_list,location);
	    trans_match((root, tree), env, true,
		        annotation,LambdaTypes.null_type_annotation)
          end,
          annotation)

(** This is a function definition, so perform the pattern matching,
    and return the appropriate Lambda. **)
d1172 101
a1272 102
      let
	val (root, tree,redundant_clauses,not_exhaustive) =
	  Match.compile_match pat_exp_list
      in
	(if !show_match then
	   (Print.print"Match tree is\n";
	    Lists.iterate
	    (fn x => output (std_out,x)) (Match.unparseTree tree "");
	    Print.print"\n";
	    ())
	 else
	   ());
        if not_exhaustive then
          Error.report
          (Error.ERROR (Error.WARNING, location, "Match not exhaustive"))
        else
          ();
        case redundant_clauses of
          [] => ()
        | r => print_redundancy_info (r,pat_exp_list,location);
	    trans_match((root, tree), env, false,name_string,! ty)
      end

(* The match translator.
 For a definition of the input supplied, see match.sml
 For a definition of the support routines used, see lambdautils.sml
 The match tree has seven variants, handled as follows:-
 ERROR - raise match
 LEAF - bind the valids to the lambda variables associated with the match
   vars (thus updating the value environment, but not generating any code)
   and translate the expression within this new value environment
 RECORD - for each label, matchvar pair, produce a lambdavar, lambdaexp pair
   where the lambdaexp expresses the selection of the labelled item from the
   record, and the lambdavar is bound to it and also to the matchvar.
   Translate the tree in this new match environment, and let_lambdas_in_exp
   of the lambdavar, lambdaexp list and the translation of the tree.
 SCON - switch on the value of the lambda variable associated with the matchvar
   into the labelled cases or the default. See also LABEL and GOTO
 CONSTRUCTOR - only matchvars corresponding to value carrying constructors
   are relevant here. For each of these, the associated value is
   SELECT(1, VAR lambda of original matchvar) (though the type of this may
   vary, the way of acquiring it doesn't), or if the type has precisely one
   constructor, and this is value carrying, then the value is
   VAR lambda of original matchvar. The result is basically a switch, with
   various possibilities according to how many constructors the type has,
   whether all are mentioned here, whether all nullary constrcutors are
   mentioned etc. See also LABEL and GOTO
LABEL and GOTO - These pose more of a problem. They are an attempt to avoid
   re-evaluating large expressions by commoning up the evaluation and
   binding it to a lambda variable which will then be referenced at the
   relevant points. There are two problems here. Firstly, there may be label
   definitions which are not referenced. Any default case can give rise to
   such an occurrence. These must be translated as the though the label was
   not present at all. This would be easy, were it not for the more difficult
   case of labels which are referred to. For such a label, we need to find
   the point furthest down the tree such that all occurrences of the label
   are below this point and there is no lower point with this property.
   Clearly such a point is either a CONSTRUCTOR or an SCON node, as these
   are the only ones at which branching takes place. We find these points
   by scanning down all arms of a branch looking for all definitions and
   references, remvoing all labels already know about (found by the same
   process at a higher point of the tree), then finding precisely those
   labels mentioned down more than one arm of the tree. For each of these,
   we should have found a definition and some references, and the definition
   will contain a tree to be evaluated there. The point now is that the
   tree cannot refer to any match variables definied at or below the
   current point, since these would be invalid in any reference to it.
   Hence the definition can be translated at the current node, and a lambda
   variable associated with it. The resulting code for the current node is
   let_lambdas_in_exp(translations of all relevant label definitions,
   translation of the current node). The LABEL and GOTO nodes are simply
   translated as VAR(lambda of label), or in the case of a label
   definition which is never referenced, the label is ignored and the tree
   translated as normal.
*)

  and trans_match((root, tree), env, is_exn, name_string,ty) =
  let val root_lambda = LambdaTypes.new_LVar()
    val excp =
      if is_exn then
	LambdaTypes.RAISE(LambdaTypes.VAR root_lambda)
      else
	LambdaTypes.RAISE(LambdaTypes.STRUCT(
	  [LambdaTypes.BUILTIN Pervasives.EXMATCH, LambdaTypes.STRUCT []]))
    val match_env =
      LambdaUtils.add_match_env((root, root_lambda),
        LambdaUtils.empty_match_env)
    val all_labels as LambdaUtils.LABELS labels =
      LambdaUtils.scan_tree(tree, LambdaUtils.empty_label_env)
    val ref_labels =
      Lists.filterp (fn (LambdaUtils.LABEL _, _) => false | _ => true)
      (NewMap.to_list labels)
    fun remove_both(LambdaUtils.LABELS labels, (label, _)) =
    let val real_label = case label of LambdaUtils.LABEL lab => lab
      | LambdaUtils.GOTO lab => lab
    in
      LambdaUtils.LABELS (NewMap.undefine(
        NewMap.undefine(labels, LambdaUtils.GOTO real_label),
					  LambdaUtils.LABEL real_label))
    end
    val LambdaUtils.LABELS def_only_labels =
      Lists.reducel remove_both (all_labels, ref_labels)
d1277 7
a1283 7
    fun handle_default_trees(lab_tree_list, match_env, val_env, label_env) =
    let	val lab_lv_le_list = map (fn (lab, LambdaTypes.PRESENT tree') =>
      (lab, LambdaTypes.new_LVar(),
        LambdaTypes.FN(LambdaTypes.new_LVar(), 
	  tr_match(tree', match_env, val_env, label_env),
                       "Part of match translation (i) " ^ name_string,
                       LambdaTypes.null_type_annotation))
d1288 257
a1544 257
      | _ => Crash.impossible "trans_node(1)") lab_tree_list
    in
      (map (fn (_, lv, le) => LambdaTypes.LETB(lv, le,"Translation of match trees")) lab_lv_le_list,
        Lists.reducel
	(fn (x, (lab, lv, _)) => LambdaUtils.add_label_env((lab, lv), x))
          (label_env, lab_lv_le_list))
    end

    and tr_match(tree, match_env, val_env, lab_env) =
      case tree of
	Match.ERROR => excp
      | Match.LEAF(exp, n, mv_valid_ty_list) =>
	let
	  fun do_leaf([], env) = trans_exp(" match_leaf", exp, env)
	  | do_leaf((mv, valid, _) :: tl, env) =
	    do_leaf(tl, Environ.add_valid_env(env, (valid,
              EnvironTypes.LAMB(LambdaUtils.lookup_match(mv, match_env)))))
	in
	  do_leaf(mv_valid_ty_list, val_env)
	end

      | Match.SCON(mv, scon_tree_list, default) =>
	let
	  val (lv_le_list, lab_env') =
	    trans_node(tree, match_env, val_env, lab_env)
	  val new_lab_env = LambdaUtils.augment_label_env(lab_env, lab_env')
	in
	  let_lambdas_in_exp(
	    lv_le_list,
	    LambdaTypes.SWITCH(
	      LambdaTypes.VAR(LambdaUtils.lookup_match(mv, match_env)),
	      LambdaTypes.ABSENT,
	      map (fn(scon, tree) =>
		    (LambdaTypes.SCON_TAG scon,
                     tr_match(tree, match_env, val_env, new_lab_env)))
	          scon_tree_list,
	      case default of
		Match.PRESENT tree =>
                    LambdaTypes.PRESENT(
		      tr_match(tree, match_env, val_env, new_lab_env))
	      | Match.ABSENT => LambdaTypes.ABSENT
	    )
	  )
	end
      | Match.CONSTRUCTOR(ty, mv, longvalid_mv_tree_list, default) =>
	let
	  val (lv_le_list, lab_env') =
	    trans_node(tree, match_env, val_env, lab_env)
	  val new_lab_env = LambdaUtils.augment_label_env(lab_env, lab_env')
	  val orig_lv = LambdaUtils.lookup_match(mv, match_env)
	  val lv_e = LambdaTypes.VAR orig_lv
	  val (def_lambda, lv_le_list) =
	    let
	      val new_lv = LambdaTypes.new_LVar()
	    in
	      case default of
		Match.PRESENT tree =>
		  let
		    val le = tr_match(tree, match_env, val_env, new_lab_env)
		  in
		    (LambdaTypes.PRESENT(
		       LambdaTypes.APP(LambdaTypes.VAR new_lv,
				       LambdaTypes.STRUCT [],
				       LambdaTypes.null_type_annotation)),
		     lv_le_list @@ 
                       [LambdaTypes.LETB(
			  new_lv,
                          LambdaTypes.FN(LambdaTypes.new_LVar(),
                                         le,
                                         "Part of match translation (ii) " ^
					   name_string,
                                         LambdaTypes.null_type_annotation),
			  "")
		       ]
		    )
		  end
	      | _ => (LambdaTypes.ABSENT, lv_le_list)
	    end

	  val (_,type_val_env) =
	    Type_Utils.get_valenv(Type_Utils.get_cons_type ty)

	  val is_exn =
	    case longvalid_mv_tree_list of
	      {1=Ident.LONGVALID(_, Ident.EXCON _), ...} :: _ => true
	    | {1=Ident.LONGVALID(_, Ident.CON _), ...} :: _ => false
	    | _ => Crash.impossible "Match.CONS bad arg"

	  fun has_value(Ident.LONGVALID(_, valid as Ident.CON _)) =
	    (case Type_Utils.type_from_scheme(
		    NewMap.apply'(type_val_env, valid)) of
	       DataTypes.FUNTYPE _ => true
	     | _ => false
	    )
	  |   has_value(Ident.LONGVALID(_, Ident.VAR _)) =
	    Crash.impossible"VAR in match CONS"
	  |   has_value(Ident.LONGVALID(_, Ident.EXCON excon)) = true
	      (* Pretend all exceptions carry values, even if only unit *)
	  (*
	  val nullary_list =
	    Lists.filterp (fn(v, _, _) => not(has_value v))
	      longvalid_mv_tree_list
	  *)
	  val new_lv = LambdaTypes.new_LVar()
	  val new_le = GetConVal lv_e
	  val get_con_field = GetConTag lv_e
	  val vcc_lv_list =
	    Lists.filterp (has_value o #1) longvalid_mv_tree_list
	      (* Note we're using the same lambda variable for all the
	         vcc matchvars, since they're all going to be the same
	         expression, viz SELECT(1, original matchvar) (aka new_le) *)

	  (* mk_branch produces a (tag, code) pair, for a branch of the
	     SWITCH. *)
	  fun mk_branch (id as Ident.LONGVALID(_, valid), mv, tree) =
	    if has_value id then
	      (LambdaTypes.VCC_TAG(#2(constructor_tag(valid, ty))),
	       LambdaTypes.do_binding(
	         (* Assign lambda variable to value carried by constructor *)
	         LambdaTypes.LETB(new_lv, new_le, "match translation"),
		 tr_match(
		   tree,
		   LambdaUtils.add_match_env((mv, new_lv), match_env),
		   val_env,
		   new_lab_env)
	      ))
	    else
	      (LambdaTypes.IMM_TAG(#2(constructor_tag(valid, ty))),
               tr_match(tree, match_env, val_env, new_lab_env)
	    )
	in
	  case is_exn of
	    false =>
	      (* Not an exception constructor *)
(*
<<<<<<< _lambda.sml
*)
	      let_lambdas_in_exp(
		lv_le_list,
	        if Type_Utils.get_no_cons ty = 1 then
		  (* Use this instead of Type_Utils.has_value_cons ty, because
		     we want to know about explicitly mentioned constructors
		     and we want to treat all EXCONS as VCCs. *)
                  if Lists.length vcc_lv_list <> 0 then
	            (* Handle case of only one constructor, carrying a value *)
	            (* This relies on constructor nodes only arising when *)
	            (* some constructor is actually quoted, not bad I suppose *)
	            let val (name, mv, tree) =
		          case vcc_lv_list of
	                    [x] => x
	                  | _ => Crash.impossible "list size"
			(*
		        val name =
			      case longvalid_mv_tree_list of
		                {1=longvalid, ...} :: _ => longvalid
		              | _ => Crash.impossible "list size"
			*)
	            in
		      (* Check to see if its ref (handled specially) *)
		      if Environ.Builtin_p(name, val_env) 
                         andalso (case cg_longvalid(name,val_env) of
                                    LambdaTypes.BUILTIN(Pervasives.REF) => true 
                                  | _ => false) then
		        (* Must be ref *)
			let val ref_lv = LambdaTypes.new_LVar ();
			in
                          LambdaTypes.do_binding(
                            LambdaTypes.LETB(
			      ref_lv,
                              LambdaTypes.APP(
				LambdaTypes.BUILTIN Pervasives.DEREF,
                                LambdaTypes.VAR orig_lv,
				LambdaTypes.null_type_annotation),
                              "match translation (iv)"),
		            tr_match(tree,
			             LambdaUtils.add_match_env((mv, ref_lv),
			                                       match_env),
			             val_env,
			             new_lab_env)
		          )
			end
		      else
	                (* Ensure we pass through the value by assigning the
	                   same lambda variable to the new matchvar as we had
                           passed through in the first place. This works since
		           the constructor has no effect on the representation
		           of the value (only one constructor case) *)
		        tr_match(tree,
			         LambdaUtils.add_match_env((mv, orig_lv),
				 			   match_env),
		                 val_env,
			         new_lab_env)
	            end
	          else
	            (* Only one constructor, with no value *)
	            let val tree = case longvalid_mv_tree_list of
		                     [(_, _, tree)] => tree
	                           | _ => Crash.impossible "list size"
	            in
		      (* No value to be passed through here *)
		      tr_match(tree, match_env, val_env, new_lab_env)
	            end
	        else
	          (* More than one constructor in this type. Must switch *)
	          LambdaTypes.SWITCH(
	            lv_e,
		    LambdaTypes.PRESENT{
		      lv = LambdaTypes.new_LVar(),
	              num_vccs = Type_Utils.get_no_vcc_cons ty,
		      num_imms = Type_Utils.get_no_null_cons ty
		    },
		    map mk_branch longvalid_mv_tree_list,
	            if Lists.length longvalid_mv_tree_list =
			 Type_Utils.get_no_cons ty then
		      LambdaTypes.ABSENT (* No default here if all cases ok *)
	            else def_lambda
		  ) (* end of LambdaTypes.SWITCH *)
	     ) (* end of let_lambdas_in_exp *)
(*
=======
	  let_lambdas_in_exp(lv_le_list,
	  if Type_Utils.get_no_cons ty = 1 then
            if Lists.length nullary_list = 0 then
	      (* Handle case of only one constructor, carrying a value *)
	      (* This relies on constructor nodes only arising when *)
	      (* some constructor is actually quoted, not bad I suppose *)
	      let val (mv', lv, tree) = case vcc_lv_list of
	        [(_, mv, tree)] => (mv, new_lv, tree)
	      | _ => Crash.impossible"list size"
		val name = case longvalid_mv_tree_list of
		  {1=longvalid, ...} :: _ => longvalid
		| _ => Crash.impossible"list size"
		    (* Check to see if it's ref (handled specially) *)
	      in
		if Environ.Builtin_p(name, val_env) 
                  andalso (case cg_longvalid(name,val_env) of
                             LambdaTypes.BUILTIN(Pervasives.REF) => true 
                           | _ => false)
                  then
		  (* Must be ref *)
                    LambdaTypes.do_binding
                    (LambdaTypes.LETB(new_lv,
                                     LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                     LambdaTypes.VAR orig_lv,
						     LambdaTypes.null_type_annotation),
                                     "match translation (iv)"),
		tr_match(tree, LambdaUtils.add_match_env(
                  (mv', new_lv), match_env), val_env, new_lab_env))
		else
		tr_match(tree, LambdaUtils.add_match_env(
                  (mv', orig_lv), match_env), val_env, new_lab_env)
	      (* Ensure we pass through the value by assigning the same
	         lambda variable to the new matchvar as we had passed through
                 in the first place. This works since the constructor has no
	         effect on the representation of the value (only one
		 constructor case) *)
	      end
a2166 201
  (* Compare an interface and an environment for equality.
   The interface should always be a subset of the environment,
   the question is merely whether it is proper or not. *)

  fun compare_name_lists(list1, list2, order) =
    list1 = list2 orelse
    (Lists.qsort order list1) = (Lists.qsort order list2)

  fun compare_sig_env(Interface.INT(Interface.INTENV intenv, v_list, e_list),
    EnvironTypes.ENV(v_map, e_map, s_map)) =
    Lists.length v_list = NewMap.size v_map andalso
    Lists.length e_list = NewMap.size e_map andalso
    NewMap.size intenv = NewMap.size s_map andalso
    (* Check the names and then recurse down the structure map *)
    (* Name checking shouldn't really be necessary, but ... *)
(*  So I've removed it!
    compare_name_lists(v_list, NewMap.domain_ordered v_map,
		       Ident.valid_order) andalso
    compare_name_lists(e_list, NewMap.domain_ordered e_map,
		       Ident.valid_order) andalso
    compare_name_lists(NewMap.domain_ordered intenv,
		       NewMap.domain_ordered s_map,
		       Ident.strid_order) andalso
*)
    Lists.forall
    compare_sig_env
    (Lists.zip(NewMap.range_ordered intenv,
	       map #1 (NewMap.range_ordered s_map)))
  fun complete_struct_with_sig(inte as Interface.INT(
    intenv as Interface.INTENV s_int_map, v_list, e_list),
      env as EnvironTypes.ENV(v_map, e_map, s_map), lambda_var) =
  if compare_sig_env(inte, env) then
    (env, LambdaTypes.VAR lambda_var)
  else
    let
      val v_a_list = NewMap.to_list_ordered v_map
	(* Throw out unwanted elements and assign new field numbers *)
(*
      val _ = Print.print"Filtering valids\n"
*)
      val (v_a_f_list_fn, next1) =
	Lists.number_with_size
	(filter_ordered_map
	 (v_a_list, Lists.qsort Ident.valid_order v_list,
	  IdentPrint.printValId), 0,
	 EnvironTypes.FIELD)
      val e_a_list = NewMap.to_list_ordered e_map
(*
      val _ = Print.print"Filtering excons list:-\n"
      val _ = Lists.iterate
	(fn (x, _) => Print.print(IdentPrint.printValId x ^ "\n"))
	e_a_list
      val _ = Print.print"In:-\n"
      val _ = Lists.iterate
	(fn x => Print.print(IdentPrint.printValId x ^ "\n"))
	e_list
*)
      (* Throw out unwanted elements and assign new field numbers *)
      val (e_a_f_list_fn, next2) =
	Lists.number_with_size
	(filter_ordered_map
	 (e_a_list, Lists.qsort Ident.valid_order e_list,
	  IdentPrint.printValId), next1,
	 EnvironTypes.FIELD)
(*
      val _ = Print.print"Filtering strids\n"
*)
      val s_a_list = NewMap.to_list_ordered s_map
	(* Throw out unwanted elements and assign new field numbers *)
      val ordered_int_map = NewMap.to_list_ordered s_int_map
      val (s_a_f_list_fn, size) =
	Lists.number_with_size
	(filter_ordered_map
	 (s_a_list, map #1 ordered_int_map,
	  IdentPrint.printStrId), next2, EnvironTypes.FIELD)
      val v_a_f_list = v_a_f_list_fn size
      val e_a_f_list = e_a_f_list_fn size
      val s_a_f_list = s_a_f_list_fn size
      val v_a_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar())) v_a_f_list
      val e_a_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar())) e_a_f_list
      val s_a_f_l_list =
	map (fn x => (x, LambdaTypes.new_LVar(), LambdaTypes.new_LVar()))
	s_a_f_list
      (* First lv is to be the constraint result *)
      (* Second lv is to be bound to the old structure *)
      val e_le_list = map complete_struct_with_sig
	(map (fn ((((_, (env, _)), _), _, lv), (_, inte)) => (inte, env, lv))
	  (Lists.zip(s_a_f_l_list, ordered_int_map)))
      val the_structure_list =
	(map (fn (_, x) => LambdaTypes.VAR x) v_a_f_l_list) @@
	(map (fn (_, x) => LambdaTypes.VAR x) e_a_f_l_list) @@
	(map (fn (_, x, _) => LambdaTypes.VAR x) s_a_f_l_list)
        fun keep_prims (x as EnvironTypes.PRIM _) _ = x
          | keep_prims _ x = x
      val env = Lists.reducel
	(fn (env, ((e, x), f_new)) =>
	 Environ.add_exn_env(env, (e, keep_prims x f_new)))
	(Lists.reducel
	 (fn (env, ((v, x), f_new)) =>
	  Environ.add_valid_env(env, (v, keep_prims x f_new)))
	 (Lists.reducel
	  (fn (env, (((strid, _), field), (env', _))) =>
	   Environ.add_strid_env(env, (strid, (env', field))))
	  (Environ.empty_env,
	   (Lists.zip(s_a_f_list, e_le_list))),
	  v_a_f_list),
	 e_a_f_list)
      val l1 = (map (fn (((_, EnvironTypes.FIELD f_old), _), lv) =>
        LambdaTypes.LETB(lv,
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),
                        "")
                     | (((_, EnvironTypes.PRIM prim), _), lv) =>
                         LambdaTypes.LETB(lv,LambdaTypes.BUILTIN prim,"")
		     | (((_, EnvironTypes.LAMB _), _), _) =>
			 Crash.impossible "c_s_w_i(1)"
		     | (((_, EnvironTypes.EXTERNAL), _), _) =>
			 Crash.impossible "c_s_w_i(1)")
	  v_a_f_l_list)
      val l2 = (map (fn (((_, EnvironTypes.FIELD f_old), _), lv) =>
        LambdaTypes.LETB(lv,
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),"")
                     | (((_, EnvironTypes.PRIM prim), _), lv) =>
                         LambdaTypes.LETB(lv,LambdaTypes.BUILTIN prim,"")
		     | (((_, EnvironTypes.LAMB _), _), _) =>
			 Crash.impossible "c_s_w_i(2)"
		     | (((_, EnvironTypes.EXTERNAL), _), _) =>
			 Crash.impossible "c_s_w_i(2)")
	  e_a_f_l_list)
      val l3 = (map
	  (fn ((((_, (env, EnvironTypes.FIELD f_old)), _), lv, lv'), le) =>
          LambdaTypes.LETB(lv, 
                          LambdaTypes.do_binding
                          (LambdaTypes.LETB(lv',
                                           LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var),""), le),
                          "")
	  | ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (3) LAMB"
	  | ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (4) PRIM"
	  | ((((_, (_, EnvironTypes.EXTERNAL)), _), _, _), _) =>
	      Crash.impossible "c_s_w_i (5) PRIM")
	  (Lists.zip(s_a_f_l_list, map #2 e_le_list)))
      val lambdas = let_lambdas_in_exp(l1 @@ l2 @@ l3,
        LambdaTypes.STRUCT the_structure_list)
    in
      (env, lambdas)
    end

  fun complete_struct_from_topenv(topenv as EnvironTypes.TOP_ENV(
    EnvironTypes.ENV(mv, me, ms), EnvironTypes.FUN_ENV m), lv_le_list) =
  let
    val valids = NewMap.to_list_ordered mv
    val exns = NewMap.to_list_ordered me
    val strids = NewMap.to_list_ordered ms
    val funids = NewMap.to_list_ordered m
    fun extract_op (EnvironTypes.LAMB x) = LambdaTypes.VAR x
      | extract_op (EnvironTypes.PRIM x) = LambdaTypes.BUILTIN x
      | extract_op (EnvironTypes.FIELD _) =
	Crash.impossible "extract_op problem"
      | extract_op (EnvironTypes.EXTERNAL) =
	Crash.impossible "extract_op problem"
  in
    (Environ.assign_fields topenv,
      let_lambdas_in_exp(lv_le_list,
      LambdaTypes.STRUCT(
                                           (map
                                            (fn (_, x) => extract_op x) valids) @@
                                           (map
                                            (fn (_, x) => extract_op x) exns) @@
                                           (map
                                            (fn (_, (_, x)) => extract_op x) strids) @@
                                           (map
                                            (fn (_,(x, _, _)) => extract_op x) funids))))
  end

  fun make_top_env env = EnvironTypes.TOP_ENV(env, Environ.empty_fun_env)

  fun complete_struct((env, lambda_exp: LambdaTypes.LambdaExp), interface_opt) =
  let
    val EnvironTypes.TOP_ENV(new_env, new_fun_env) =
      Environ.assign_fields(make_top_env env)
    val result = (new_env, lambda_exp)
  in
    case interface_opt of
      LambdaTypes.ABSENT => result
    | LambdaTypes.PRESENT inte =>
      if compare_sig_env(inte, new_env) then result
      else
	let
	  val new_lv = LambdaTypes.new_LVar()
	  val (new_env', new_lambda') =
	    complete_struct_with_sig(inte, new_env, new_lv)
	in
	  (new_env',
	   LambdaTypes.do_binding(LambdaTypes.LETB(new_lv, lambda_exp,""),
				  new_lambda'))
	end
  end

d2334 1
a2334 1
  fun trans_top_dec(topdec, top_env as EnvironTypes.TOP_ENV(env, top_map),generate_debug,debug_info) =
d2360 3
a2362 1

@


1.107
log
@Switches now have both value-carrying and immediate constructors in the
same switch.  They also contain information about the number of each
sort of constructor in the datatype.
@
text
@d4 5
d306 2
a307 2
    Match.DataTypes = Types.Datatypes =
    Type_Utils.DataTypes = AbsynPrint.Absyn.Datatypes =
@


1.106
log
@Tynames now have a slot recording their definition point so constructor functions can have
more information in them
@
text
@d4 4
d372 11
a382 5
    LambdaTypes.FN(l,
      LambdaTypes.SWITCH(LambdaTypes.VAR l,
	[(LambdaTypes.CON_TAG 1, LambdaTypes.INT 0),
	  (LambdaTypes.CON_TAG 0, LambdaTypes.INT 1)],
	   LambdaTypes.ABSENT, LambdaTypes.ABSENT),"Builtin not",
d412 1
a412 1
       (location,NewMap.rank'(valenv, valid))
d908 1
a908 6
	      if Type_Utils.get_no_null_cons ty > 1 then
		LambdaTypes.PRESENT false_val
	      else
		LambdaTypes.ABSENT
	    val def2 =
	      if Type_Utils.has_value_cons ty then
d915 5
a919 2
	     [(LambdaTypes.CON_TAG tag, true_val)],
	     def1, def2)
d937 20
a956 19
      LambdaTypes.HANDLE(trans_exp(annotation, exp, env),
      let
	val (root, tree,redundant_clauses,not_exhaustive) =
			 Match.compile_match pat_exp_list
      in
	(if !show_match then
	   (Print.print"Exception match tree is\n";
	    Lists.iterate
	    (fn x => output (std_out,x)) (Match.unparseTree tree "");
	    Print.print"\n";
	    ())
	 else
	   ());
           case redundant_clauses of
             [] => ()
           | r => print_redundancy_info (r,pat_exp_list,location);
	   trans_match((root, tree), env, true,annotation,LambdaTypes.null_type_annotation)
      end,
    annotation)
d962 2
a963 12
	val update_lambda = LambdaTypes.new_LVar()
	val update_exp =
	  LambdaTypes.APP
	  (LambdaTypes.BUILTIN Pervasives.BECOMES,
	   LambdaTypes.STRUCT
	   [LambdaTypes.APP
	    (LambdaTypes.BUILTIN Pervasives.REF,
	     LambdaTypes.SCON(Ident.STRING""),
	     LambdaTypes.null_type_annotation),
	    LambdaTypes.SCON(Ident.STRING name)],
	   Types.string_type)
	val (root, tree,redundant_clauses,not_exhaustive) = Match.compile_match pat_exp_list
d1105 8
a1112 5
	  let_lambdas_in_exp(lv_le_list,
	  LambdaTypes.SWITCH(LambdaTypes.VAR(
            LambdaUtils.lookup_match(mv, match_env)), map (fn(scon, tree) =>
              (LambdaTypes.SCON_TAG scon,
                tr_match(tree, match_env, val_env, new_lab_env)))
d1114 7
a1120 5
	          case default of Match.PRESENT tree =>
                    LambdaTypes.PRESENT(tr_match(tree, match_env, val_env,
                      new_lab_env))
		  | Match.ABSENT => LambdaTypes.ABSENT,
		    LambdaTypes.ABSENT))
d1138 4
a1141 4
		    (LambdaTypes.PRESENT
		     (LambdaTypes.APP(LambdaTypes.VAR new_lv,
				      LambdaTypes.STRUCT [],
				      LambdaTypes.null_type_annotation)),
d1143 10
a1152 5
                     [LambdaTypes.LETB(new_lv,
                                       LambdaTypes.FN(LambdaTypes.new_LVar(),
                                                      le,
                                                      "Part of match translation (ii) " ^ name_string,
                                                      LambdaTypes.null_type_annotation),"")])
d1156 10
a1165 5
	  val (_,type_val_env) = Type_Utils.get_valenv(Type_Utils.get_cons_type ty)
	  val is_exn = case longvalid_mv_tree_list of
	    {1=Ident.LONGVALID(_, Ident.EXCON _), ...} :: _ => true
	  | {1=Ident.LONGVALID(_, Ident.CON _), ...} :: _ => false
	  | _ => Crash.impossible"Match.CONS bad arg"
d1167 2
a1168 2
	    (case Type_Utils.type_from_scheme(NewMap.apply'(type_val_env,
							    valid)) of
d1170 5
a1174 4
	     | _ => false)
	    | has_value(Ident.LONGVALID(_, Ident.VAR _)) =
	      Crash.impossible"VAR in match CONS"
	    | has_value(Ident.LONGVALID(_, Ident.EXCON excon)) = true
d1176 1
d1179 2
a1180 1
	    longvalid_mv_tree_list
d1188 20
a1207 1
	         expression, viz SELECT(1, original matchvar) (as above) *)
d1212 86
d1378 2
d1382 7
a1388 2
	    let_lambdas_in_exp(LambdaTypes.LETB(new_lv, new_le,"") :: lv_le_list,
	      LambdaTypes.SWITCH(select_exn_unique get_con_field,
d1390 13
a1402 7
		    (LambdaTypes.EXP_TAG(select_exn_unique
					 (cg_longexid(longvalid, val_env))),
		      tr_match(tree, LambdaUtils.add_match_env((mv, new_lv),
		        match_env), val_env, new_lab_env)))
		  vcc_lv_list,
		    def_lambda,
		    LambdaTypes.ABSENT))
d1506 2
a1507 2
	(* The above lambda is a dummy, and will not be referenced *)
	(* in this case. No additional environment generated *)
d1523 10
a1532 4
	      [LambdaTypes.LETB(dummy_lv,
			       LambdaTypes.SWITCH(LambdaTypes.VAR lambda_var,
                [(LambdaTypes.SCON_TAG(scon), LambdaTypes.VAR lambda_var)],
                  excp, LambdaTypes.ABSENT),"")])
d1543 1
a1543 1
	      val tag = #2(constructor_tag(valid, ty))
d1546 16
a1561 11
		[LambdaTypes.LETB(dummy_lv,
		  LambdaTypes.SWITCH(LambdaTypes.VAR lambda_var,
		  (* Switch the expression, since all nullary
		     constructors are represented unboxed *)
		    [(LambdaTypes.CON_TAG tag, LambdaTypes.VAR lambda_var)],
                      if Type_Utils.get_no_null_cons ty = 1 then
			LambdaTypes.ABSENT
		      else excp,
			if not(Type_Utils.has_value_cons ty) then
			  LambdaTypes.ABSENT
			else excp(* Fault if not a tag *)),"")])
d1596 5
a1600 6
                   andalso (case cg_longvalid(longvalid,envir) of
                              LambdaTypes.BUILTIN(Pervasives.REF) => true
                            | _ => false)
                   then (* Must be ref *)
                     let
                       val new_lv = LambdaTypes.new_LVar()
d1603 1
a1603 2

                     in
d1605 8
a1612 7
                      (LambdaTypes.LETB(new_lv,
                                       LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                                       LambdaTypes.VAR lambda_var,
						       LambdaTypes.null_type_annotation),
                                       "Dereferencing a pattern")
                       :: new_lambda_exp))
                     end
d1623 12
a1634 10
	      in
		(new_env, LambdaTypes.LETB(new_lv,
		  LambdaTypes.SWITCH(lexp,
                    [(* No nullary constructors *)],
		    if not(Type_Utils.has_null_cons ty) then
				     LambdaTypes.ABSENT
		    else excp (* is a tag, but not the right one *),
		      LambdaTypes.PRESENT((* isn't a tag *)
			LambdaTypes.SWITCH(GetConTag lexp,
			    [(LambdaTypes.CON_TAG(#2(constructor_tag(valid, ty))),
d1636 7
a1642 4
			    if Type_Utils.get_no_vcc_cons ty <> 1 then
			      excp
			    else LambdaTypes.ABSENT,
			      LambdaTypes.ABSENT))),"") :: new_lambda_exp)
d1647 3
a1649 3
	      val (new_env, new_lambda_exp) =
		trans_individual_dec(pat, new_lv)
	      val lexp = LambdaTypes.VAR lambda_var
d1651 18
a1668 6
	      (new_env, LambdaTypes.LETB(new_lv,
		LambdaTypes.SWITCH(GetConTag lexp,
		    [(LambdaTypes.EXP_TAG(cg_longexid(longvalid, envir)),
		      GetConVal lexp)],
			excp, LambdaTypes.ABSENT),"") :: new_lambda_exp)
	    end)
d1670 1
a1670 1
	(* Just ignore the type here *)
@


1.105
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d399 8
a406 4
    NewMap.rank'(Type_Utils.get_valenv(Type_Utils.get_cons_type ty), valid)
    handle NewMap.Undefined =>
      Crash.impossible("constructor_tag(3): " ^ Types.print_type ty ^ "," ^
		       IdentPrint.printValId valid)
d773 2
a774 1
	val lexp = LambdaTypes.INT(constructor_tag(valid, ty))
d788 4
a791 2
		 LambdaTypes.VAR new_lv,"constructor " ^
		 Symbol.symbol_name symbol,
d1147 1
a1147 1
	  val type_val_env = Type_Utils.get_valenv(Type_Utils.get_cons_type ty)
d1225 1
a1225 1
              tree) => (LambdaTypes.CON_TAG(constructor_tag(valid, ty)),
d1250 1
a1250 1
	    (LambdaTypes.CON_TAG(constructor_tag(valid, ty)),
d1402 1
a1402 1
	      val tag = constructor_tag(valid, ty)
d1477 1
a1477 1
                       val tag = constructor_tag(valid, ty)
d1487 1
a1487 2
			    [(LambdaTypes.CON_TAG(
			      constructor_tag(valid, ty)),
d1579 1
a1579 1
    | Absyn.DATATYPEdec datatypeinfo_list =>
d1600 1
a1600 1
    | Absyn.ABSTYPEdec (_, dec) => trans_dec(dec, envir)
@


1.104
log
@Removed and tidied up lots of instances of map, replaced various
Lists.length o NewMap.to_list with NewMap.size, generally tidied up
@
text
@d4 4
a360 17
  fun ocode() =
  let
    val l1 = LambdaTypes.new_LVar()
    val l2 = LambdaTypes.new_LVar()
  in
    LambdaTypes.FN(l1, LambdaTypes.FN(l2,
      LambdaTypes.APP(
        LambdaTypes.SELECT({index = 0, size = 2}, LambdaTypes.VAR l1),
	LambdaTypes.APP(
	  LambdaTypes.SELECT({index = 1, size = 2}, LambdaTypes.VAR l1),
	  LambdaTypes.VAR l2,
	  LambdaTypes.null_type_annotation),
	LambdaTypes.null_type_annotation),
      "Builtin o",LambdaTypes.null_type_annotation),
    "Builtin o argument 1",LambdaTypes.null_type_annotation)
  end

d532 2
a533 3
	     Pervasives.O => ocode()
	   | Pervasives.NOT => notcode()
	   | _ => LambdaTypes.BUILTIN prim)
@


1.103
log
@Better annotations
@
text
@d4 3
a255 1
require "../typechecker/valenv";
a264 1
  structure Valenv : VALENV
d289 1
a289 1
    AbsynPrint.Absyn.Interface.Datatypes = Valenv.Datatypes =
a317 1
  val add_fn_names = ref false
d319 3
a321 3
   val generate_debug_info = ref false
   val empty_debug_information = Debugger_Types.INFO (NewMap.empty' String.<)
   val debug_information = ref empty_debug_information
d353 1
a353 1
  fun known_order ((lab1, _), (lab2, _)) = Ident.lab_order (lab1, lab2)
d394 3
a396 2
  fun env_from_list env_list = Lists.reducel Environ.augment_env
    (Environ.empty_env, env_list)
d398 3
d455 6
a460 9
    (case Map.range record_map of
      (h :: t) =>
	(case h of
	  DataTypes.META_OVERLOADED(ref ty)=>
	    (case Types.the_type ty of
	      DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
	    | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
	    | _ => (false, ""))
	| _ => (false, ""))
d471 1
a471 1
       ((_, h) :: t) =>
d486 1
a486 1
       ((_, h) :: t) =>
d623 2
a624 4
  fun is_eq_prim x = 
    case x of
      LambdaTypes.BUILTIN Pervasives.EQ => true 
    | _ => false
d626 2
a627 4
  fun isnt_eq_prim x = 
    case x of
      LambdaTypes.BUILTIN Pervasives.EQ => false
    | _ => true
d631 2
a632 4
  fun isnt_neq_prim x =
    case x of
      LambdaTypes.BUILTIN Pervasives.NE => false
    | _ => true
d643 4
d707 6
a712 5
	  nopath andalso
	  (case Environ.lookup_valid(valid, env) of
	     EnvironTypes.PRIM _ => true
	   | _ => false)
	     andalso Environ.is_overloaded_op valid
d719 6
a724 7
          if is_ol
            then 
              cg_longvalid(Ident.LONGVALID(Ident.NOPATH, 
                                           Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name))),
                           Primitives.env_for_lookup_in_lambda)
              else
                cg_longvalid(longValId,env)
a743 8
(*
		  val _ =
		    if has_no_vcc then
		      Print.print(Types.print_type  ty ^ " has_no_vcc\n")
		    else
		      Print.print(Types.print_type  ty ^
				  "has_vcc or unsuitable type\n")
*)
d748 1
a748 5
			 (
(*
			  Print.print"Converting poly_eq for ref to int eq\n";
*)
			  true)
d786 12
a797 10
	  let
	    val new_lv = LambdaTypes.new_LVar()
	  in
	    LambdaTypes.FN(new_lv,
	      if Type_Utils.get_no_cons ty > 1 then
		LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv])
	      else
		LambdaTypes.VAR new_lv,"constructor " ^ Symbol.symbol_name symbol,
                LambdaTypes.null_type_annotation)
	  end
d805 7
a811 7
	let
	  val lv = LambdaTypes.new_LVar()
	in
	  LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],
                         "Builtin code to construct an exception",
                         LambdaTypes.null_type_annotation)
	end
d828 4
a831 4
	val lexp_list =
	  map (fn (_, exp) => trans_exp (" no_name", exp, env)) label_exp_list
	val lvar_lab_list =
	  map (fn (lab, _) => (lab, LambdaTypes.new_LVar())) label_exp_list
d833 7
a839 5
	let_lambdas_in_exp(map (fn x => LambdaTypes.LETB(#2(#1 x), #2 x,
                                                        "Used in the generation of a record expression"))
	  (Lists.zip(lvar_lab_list, lexp_list)),
            LambdaTypes.STRUCT(map (fn (_, lvar) => LambdaTypes.VAR lvar)
	      (Lists.qsort known_order lvar_lab_list)))
d861 1
a861 1
	val (chars, is_poly, is_eq) =
d864 1
a864 1
	      ("Is poly eq", true, true)
d866 2
a867 2
	      ("Is poly ne", true, false)
	  | _ => ("Isn't poly eq or ne", false, false)
d935 2
a936 1
	val (root, tree,redundant_clauses,not_exhaustive) = Match.compile_match pat_exp_list
d939 4
a942 2
	   (Print.print"Exception match tree is";
	    map (fn x => output (std_out,x)) (Match.unparseTree tree "");
d971 4
a974 2
	   (Print.print"Match tree is";
	    map (fn x => output (std_out,x)) (Match.unparseTree tree "");
d986 1
a986 5
	let_lambdas_in_exp
	(if !add_fn_names then [LambdaTypes.LETB(update_lambda, update_exp,
                                                "Introduced by add fn_names")]
	 else [],
	 trans_match((root, tree), env, false,name_string,! ty))
d1087 2
a1088 2
	(fn (x, y) => LambdaUtils.add_label_env(y, x))
          (label_env, map (fn (lab, lv, _) => (lab, lv)) lab_lv_le_list))
d1156 8
a1163 19
	  fun has_value(longvalid as Ident.LONGVALID(_, valid)) =
	    case valid of
	      Ident.CON _ =>
	      ((case Type_Utils.type_from_scheme(NewMap.apply'(type_val_env,
							       valid)) of
	        DataTypes.FUNTYPE _ => true
	      | _ => false) 
(*                  handle NewMap.Lookup =>
		  (Print.print("Lookup from '" ^
			       IdentPrint.printLongValId longvalid ^
			       "\nType =\n" ^ Types.print_type ty ^ "\n");
		   Print.print("Valenv =\n" ^
			       Valenv.string_valenv(0, DataTypes.VE
						     (ref 0, type_val_env)) ^
			       "\n");
		   raise NewMap.Lookup)*)
                  )
	    | Ident.VAR _ => Crash.impossible"VAR in match CONS"
	    | Ident.EXCON excon => true
d1184 2
d1277 1
d1280 5
d1293 3
a1295 2
	  let_lambdas_in_exp(lv_le_list, tr_match(tree, new_env, val_env,
            lab_env))
d1300 8
a1307 10
	if
	  ((NewMap.apply'(def_only_labels, LambdaUtils.LABEL label);
	    true) handle NewMap.Undefined => false)
	  then
	    tr_match(tree, match_env, val_env, lab_env)
	else
	  LambdaTypes.APP(
	    LambdaTypes.VAR(LambdaUtils.lookup_label(label, lab_env)),
	    LambdaTypes.STRUCT [],
	    LambdaTypes.null_type_annotation)
d1324 2
a1325 1
      let val main_list = map #2 scon_tree_list
d1327 1
a1327 1
	  | Match.PRESENT tree' => tree' :: main_list
d1329 1
a1329 1
          map (fn x => LambdaUtils.scan_tree(x, label_env)) final_list)
d1334 7
a1340 3
      let val main_list = map #3 valid_mv_tree_list
	val final_list = case default of Match.ABSENT => main_list
	  | Match.PRESENT tree' => tree' :: main_list
d1342 1
a1342 1
          map (fn x => LambdaUtils.scan_tree(x, label_env)) final_list)
d1369 1
a1369 1
      Absyn.VALdec (non_rec_list, rec_list, tyvar) =>
d1397 1
a1397 1
	| Absyn.VALpat ((Ident.LONGVALID(path, valid), ty),_) =>
d1406 1
a1406 1
	      val tag = constructor_tag(valid, !ty)
d1414 1
a1414 1
                      if Type_Utils.get_no_null_cons(!ty) = 1 then
d1417 2
a1418 1
			if not(Type_Utils.has_value_cons(!ty)) then LambdaTypes.ABSENT
d1424 1
a1424 1
	| Absyn.RECORDpat(lab_pat_list, flex, ty) =>
d1429 1
a1429 1
		    LambdaTypes.SELECT(record_label_offset(lab, !ty),
d1432 10
a1441 13
	    val (env_list, lambda_list_list) =
	    let
	      val env_list_lambda_list_list = map
		(trans_individual_dec o (fn (pat, lv, le) => (pat, lv)))
		big_list
	    in
	      (map #1 env_list_lambda_list_list,
	        map #2 env_list_lambda_list_list)
	    end
	    val lambda_list_list' = map (fn (x, y) => x :: y)
	      (Lists.zip(map (fn (_, lv, le) =>
			      LambdaTypes.LETB(lv, le,"")) big_list,
		lambda_list_list))
d1443 4
a1446 2
	    (env_from_list env_list,
	     Lists.reducel op @@ ([], lambda_list_list'))
d1526 1
d1541 1
a1541 1
	      trans_dec(Absyn.VALdec(tl,rec_list, tyvar), envir)
d1560 1
a1560 1
	    val all_env = env_from_list(map #1 env_le_list)
a1577 17
(*
	    val new_lv_pat_list =  map
	      (fn (pat, _) => (LambdaTypes.new_LVar(), pat)) rec_list
	    val new_env = env_from_list(map #1
	      (map (fn (lv, pat) => trans_individual_dec(pat, lv))
	        new_lv_pat_list))
	    val _ = map
	      (fn (_, []) => ()
	      | (_, _) =>
		Crash.impossible"non-trivial lhs in letrec")
	      env_le_list
	    val letrec_lambda = LambdaTypes.new_LVar()
	    val (lv_le_list_fn, size) =
	      Lists.number_with_size(map #1 new_lv_pat_list, 0,
                fn f => LambdaTypes.SELECT(f, LambdaTypes.VAR letrec_lambda))
	    val lv_le_list = map (fn (x,y) => LambdaTypes.LETB(x,y,"")) (lv_le_list_fn size)
*)
a1580 9
(*
 LambdaTypes.LETB(letrec_lambda,
	      (*reduce_letrec*)
		       LambdaTypes.LETREC
		       (map #1 lv_pat_exp_list, exp_list,
			LambdaTypes.STRUCT(map (LambdaTypes.VAR o #1) 
					   lv_pat_exp_list)))
	    :: lv_le_list)
*)
d1600 4
a1603 2
	(env_from_list (map #1 e_l_list),
	 Lists.reducel op @@ ([], map #2 e_l_list))
d1613 3
a1615 2
	fun do_exn [] = (Environ.empty_env, [])
	| do_exn(ex :: rest) =
a1618 1
	    val (rest_env, rest_lambda) = do_exn rest
d1684 2
a1685 2
	    (Environ.augment_env(this_env, rest_env),
	     this_lambda @@ rest_lambda)
d1688 1
a1688 1
	do_exn except_list
a1786 13
(*
      let
	fun trans ([], full_env) = (Environ.empty_env, [])
	| trans (head::tail, full_env) =
	let val (env, lambda) = trans_dec (head, full_env)
	  val(env', lambda') = trans(tail, Environ.augment_env(full_env, env))
	in
	  (Environ.augment_env(env, env'), lambda @@ lambda')
	end
      in
	trans (dec_list, envir)
      end
*)
d1789 1
a1789 1
  and trans_sequence_dec(old_env, new_env, bindings, []) =
d1810 6
a1815 7
  if Lists.length v_list <> Lists.length(NewMap.to_list v_map) orelse
    Lists.length e_list <>  Lists.length(NewMap.to_list e_map) orelse
    Lists.length(NewMap.to_list intenv) <> Lists.length(NewMap.to_list s_map) then
    false
  else
  (* Check the names and then recurse down the structure map *)
  (* Name checking shouldn't really be necessary, but ... *)
d1823 1
a1827 1

d1888 2
a1889 2
	(map (fn ((((_, (env, _)), _), _, lv), inte) => (inte, env, lv))
	  (Lists.zip(s_a_f_l_list, map #2 ordered_int_map)))
d1897 12
a1908 8
	Environ.add_exn_env
	 (Lists.reducel Environ.add_valid_env
	  (Lists.reducel Environ.add_strid_env
	   (Environ.empty_env,
	    map (fn(((strid, _), field), env) => (strid, (env, field)))
	      (Lists.zip(s_a_f_list, map #1 e_le_list))),
	        map (fn ((v, x), f_new) => (v, keep_prims x f_new)) v_a_f_list),
	          map (fn ((e, x), f_new) => (e, keep_prims x f_new)) e_a_f_list)
a1948 46

(*
  fun assign_fields(EnvironTypes.TOP_ENV(
    EnvironTypes.ENV(mv, me, ms), EnvironTypes.FUN_ENV m)) =
  let
    val valids = Map.assoc mv
    val exns = Map.assoc me
    val strids = Map.assoc ms
    val funids = Map.assoc m
    val (v_field_fn, next1) =
      Lists.number_with_size(valids, 0, EnvironTypes.FIELD)
    val (e_field_fn, next2) =
      Lists.number_with_size(exns, next1, EnvironTypes.FIELD)
    val (s_field_fn, next3) =
      Lists.number_with_size(strids, next2, EnvironTypes.FIELD)
    val (f_field_fn, size) =
      Lists.number_with_size(funids, next3, EnvironTypes.FIELD)
    fun passing_on_prim (b as EnvironTypes.PRIM _) _ = b
      | passing_on_prim _ x = x
    val v_field =
      map (fn ((vid, var), f) => (vid, passing_on_prim var f)) (v_field_fn size)
    val e_field =
      map (fn ((eid, var), f) => (eid, passing_on_prim var f)) (e_field_fn size)
    val s_field =
      map (fn ((sid, (e, var)), f) => (sid,(e, passing_on_prim var f))) (s_field_fn size)
    val f_field =
      map (fn ((fid, (_, i, e)), f) => (fid,(f, i, e)))
      (f_field_fn size)

      val result =
        EnvironTypes.TOP_ENV
        (Lists.reducel
         Environ.add_strid_env
         (Lists.reducel
          Environ.add_exn_env
          (Lists.reducel
           Environ.add_valid_env
           (Environ.empty_env, v_field),
           e_field), s_field),
         Lists.reducel
         Environ.add_funid_env
         (Environ.empty_fun_env, f_field))
  in
    result
  end
*)
@


1.102
log
@Some minor improvements in determining whether or not constructors
of various types exist
@
text
@d4 4
d1085 1
a1085 3
                       if name_string="" 
                         then "Part of match translation (i)" 
                       else name_string,
d1137 1
a1137 1
	  val (def_lambda, binding) =
d1150 6
a1155 7
		     LambdaTypes.LETB(new_lv,
				     LambdaTypes.FN(LambdaTypes.new_LVar(),
						    le,
                                                    if name_string="" 
                                                      then "Part of match translation (ii)" 
                                                    else name_string,
                                                    LambdaTypes.null_type_annotation),""))
d1157 1
a1157 8
	      | _ => (LambdaTypes.ABSENT,
		      LambdaTypes.LETB(new_lv,
				      LambdaTypes.FN(LambdaTypes.new_LVar(),
						     LambdaTypes.STRUCT[],
                                                     if name_string=""
                                                       then "Part of match translation (iii)" 
                                                     else name_string,
                                                     LambdaTypes.null_type_annotation),""))
a1158 1
	  val lv_le_list = lv_le_list @@ [binding]
d1170 2
a1171 1
	      | _ => false) handle Map.Lookup =>
d1179 2
a1180 1
		   raise Map.Lookup))
@


1.101
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
d488 2
a489 2
		Type_Utils.get_no_cons h <> 0 andalso
		Type_Utils.get_no_vcc_cons h = 0
d912 1
a912 1
	      if Type_Utils.get_no_vcc_cons ty > 0 then
d1255 1
a1255 1
		  else def_lambda, if Type_Utils.get_no_vcc_cons ty = 0 then
d1429 1
a1429 1
			if Type_Utils.get_no_vcc_cons(!ty) = 0 then LambdaTypes.ABSENT
d1498 1
a1498 1
		    if Type_Utils.get_no_null_cons(ty) = 0 then
@


1.100
log
@Changes to absyn
@
text
@d4 3
d312 2
a313 4
   val empty_debug_information = NewMap.empty' String.< 
     : ((string,EnvironTypes.LambdaTypes.Datatypes.Type * bool *
         (int * Debugger_Types.Backend_Annotation) list) NewMap.T)
   val debug_information = ref(empty_debug_information)
d1674 9
a1682 5
                    val _ = if ! generate_debug_info
                              then
                                debug_information := 
                                NewMap.define(!debug_information,string_to_use,(ty,false,[]))
                            else ()
@


1.99
log
@Datatype fred = Abs of int | ... -> val Abs <VAR> = Abs<CON> which was code-generated in the current
environment instead of the empty environment - since Abs was builtin this did not work
@
text
@d4 4
d1404 1
a1404 1
	| Absyn.VALpat(Ident.LONGVALID(path, valid), ty) =>
d1455 1
a1455 1
	| Absyn.APPpat((longvalid, ref ty), pat) => 
d1519 1
a1519 1
	| Absyn.TYPEDpat(typed, _) => trans_individual_dec(typed, lambda_var)
d1540 1
a1540 2
	      (Absyn.VALpat(Ident.LONGVALID(Ident.NOPATH,
					    valid as Ident.VAR _), _),
d1569 1
a1569 1
	    fun pat_name(Absyn.VALpat(Ident.LONGVALID(_, valid), _)) =
d1620 1
a1620 1
            (Absyn.VALpat(Ident.LONGVALID(Ident.NOPATH, Ident.VAR sy), ref ty),
d2092 1
a2092 1
  | Absyn.OLDstrexp longstrid => cg_longstrid(longstrid, env)
d2138 1
a2138 1
          | Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte)) =>
d2191 1
a2191 1
  | interface_from_sigexp(Absyn.OLDsigexp(_, ref interface)) = interface
d2204 1
a2204 1
      | Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte)) =>
@


1.98
log
@Installed central error reporting mechanism.
@
text
@d4 3
d1624 2
a1625 1
	  trans_dec(Absyn.VALdec(valdec_list, [], Set.empty_set), envir)
@


1.97
log
@Removed some redundant structures and sharing
@
text
@d4 3
d227 1
d264 1
d281 1
d296 1
d632 5
a636 1
  fun print_not_exhaustive(marks) = output(std_out,"Match not exhaustive at "^ Absyn.Source_marks_to_string marks ^ "\n")
d638 1
a638 10
  fun print_redundancy_info ([],_,_) = ()
    | print_redundancy_info (clauses,pat_exp_list,marks) =
      let
        (* this should be a library function *)
        fun print_strings[] = ()
          | print_strings(s::l) =
            (output(std_out,s);print_strings l)
        fun redundant_patterns_to_strings (to_mark,patterns) =
          (* print list of patterns with indication next to them of redundant ones *)
          (* assume to_show is unordered *)
d640 10
a649 10
            fun show(n,to_mark,[],rest) = rev rest
              | show(n,to_mark,p::l,rest) =
                let val prefix =
                  if Lists.member(n,to_mark)
                    then "  -> "
                  else "     "
                in
                  (* AbsynPrint.unparsePat isn't quite friendly enough here *)
                  show(n+1,to_mark,l," => ...\n"::(AbsynPrint.unparsePat p)::prefix::rest)
                end
d651 1
a651 1
            show(1,to_mark,patterns,[])
a652 1
        val strings = redundant_patterns_to_strings(clauses,(map (fn (x,_)=> x) pat_exp_list))
d654 3
a656 2
        print_strings ["Redundant Patterns at ",Absyn.Source_marks_to_string marks,"in: \n"];
        print_strings strings
d925 1
a925 1
    | Absyn.HANDLEexp (exp, _, pat_exp_list,marks,annotation) =>
d938 1
a938 1
           | r => print_redundancy_info (r,pat_exp_list,marks);
d945 1
a945 1
    | Absyn.FNexp (pat_exp_list, ty, name_string,marks) =>
d966 5
a970 1
        if not_exhaustive then print_not_exhaustive marks else ();
d973 1
a973 1
        | r => print_redundancy_info (r,pat_exp_list,marks);
d1616 2
a1617 2
                          ty,Absyn.dummy_marks),
             Absyn.dummy_marks)
@


1.96
log
@Added the recording of information about exceptions
@
text
@d4 3
d262 9
a270 7
  sharing LambdaUtils.NewMap = Environ.EnvironTypes.NewMap =
    Environ.Interface.Datatypes.NewMap = Valenv.Datatypes.NewMap
  sharing Environ.Ident = AbsynPrint.Absyn.Datatypes.Ident = IdentPrint.Ident
  sharing LambdaSub.Set = Primitives.Set = AbsynPrint.Absyn.Set
  sharing Match.DataTypes = Types.Datatypes = Environ.Interface.Datatypes =
    Type_Utils.DataTypes = AbsynPrint.Absyn.Datatypes = Valenv.Datatypes =
    LambdaSub.LT.Datatypes
a273 2
  sharing LambdaUtils.LambdaTypes = LambdaSub.LT =
    Primitives.LambdaTypes = LambdaOptimiser.LambdaTypes
d286 2
a287 2
  structure NewMap = LambdaUtils.NewMap
  structure Set = LambdaSub.Set
d295 1
a295 1
   val empty_debug_information = Debugger_Types.Map.empty' String.< 
d297 1
a297 1
         (int * Debugger_Types.Backend_Annotation) list) Debugger_Types.Map.T)
d1663 1
a1663 1
                                Debugger_Types.Map.define(!debug_information,string_to_use,(ty,false,[]))
@


1.95
log
@Did tail recursive versions for translations of sequences of decs
and sequences of strdecs
@
text
@d4 4
d221 1
d256 1
d286 1
d291 6
d1653 9
a1661 3
		    val string_exp = LambdaTypes.SCON(Ident.STRING (if exception_name=""
                                                                      then exn_string
                                                                        else exception_name))
d2234 27
a2260 14
  fun trans_top_dec(topdec, top_env as EnvironTypes.TOP_ENV(env, top_map)) =
    case topdec of
      Absyn.STRDECtopdec (strdec,_) =>
	let
	  val (new_env, lambdas) = trans_str_dec(strdec, top_env)
	in
	  (make_top_env new_env, lambdas)
	end
    | Absyn.SIGNATUREtopdec _ =>
	(make_top_env Environ.empty_env, [])
    | Absyn.FUNCTORtopdec (funbind_list,_) =>
	trans_fun_dec_list(funbind_list, top_env)
    | Absyn.REQUIREtopdec _ =>
	Crash.impossible"trans_topdec REQUIREtopdec"
@


1.94
log
@Preserved builtin-ness across rebindings
@
text
@d4 3
d1777 2
d1790 1
d1793 11
d2093 6
a2098 4
    | (strid, sigexp_opt, strexp,_) :: tl =>
    let 
      fun trans_single_struct(strid, sigexp_opt, strexp) =
        let 
d2109 5
a2113 3
          (Environ.add_strid_env(Environ.empty_env, (strid,
                                                     (str_env, EnvironTypes.LAMB lambda_var))),
           [LambdaTypes.LETB(lambda_var, lambda_exp,"")])
a2114 3
      val (env', lv_le_list) = trans_single_struct(strid, sigexp_opt, strexp)
      val (env'', lv_le_list') = trans_str_dec(Absyn.STRUCTUREstrdec tl,
                                               Environ.augment_top_env(top_env, make_top_env env'))
d2116 1
a2116 1
      (Environ.augment_env(env', env''), lv_le_list @@ lv_le_list')
d2129 2
d2137 1
a2137 1
	Environ.augment_top_env(top_env, make_top_env env'))
d2141 13
@


1.93
log
@The actual application of the functor was missed out
@
text
@d4 3
d1506 9
a1514 1
	    val lambda = trans_exp(" layered_pat", exp, envir)
d1517 1
d1520 4
a1523 1
	      LambdaTypes.LETB(lvar, lambda,"") :: more_lambda @@ rest_lambda)
@


1.92
log
@Removed NewMap.domain_ordered and replaced with NewMap.rank'
which doesn't build an intermediate list.
@
text
@d4 4
d2038 5
a2042 3
	    (LambdaTypes.BUILTIN Pervasives.LOAD_FUNCT,
	     LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)),
	     LambdaTypes.null_type_annotation)
@


1.91
log
@Removed some redundant structure arguments and sharing
Converted where relevant to use NewMap.{forall,exists,iterate}
@
text
@d4 4
a347 12
  fun position (target, domain, error_message) =
  let
    fun position' (head::tail, n) =
        if target = head then n
	else position' (tail, n+1)
      | position' ([], _) =
	Crash.impossible(error_message())
  in
    position' (domain, 0)
  end
	  

d356 4
a359 16
  let

(** Extract the correct type (nullary constructors give correct type
    straight off, others give a FUNTYPE, we want the result type of
    this.) **)
    val constype = Type_Utils.get_cons_type ty
		    
(** Find the domain map of a constructor type **)
    fun domain ty =
      NewMap.domain_ordered(Type_Utils.get_valenv ty)
  in
    position
    (valid, domain constype,
     fn () => "constructor_tag(3): " ^ Types.print_type ty ^ "," ^
     IdentPrint.printValId valid)
  end
d370 6
d377 1
a377 1
    {index = position (lab, record_domain, fn () => "record_tag(1)"),
@


1.90
log
@Anel's changes to use NewMap instead of Map
@
text
@d7 3
d198 1
d226 1
d240 2
a241 3
    Environ.Interface.NewMap = Valenv.Datatypes.NewMap
  sharing Environ.Ident = Environ.Interface.Ident =
    AbsynPrint.Absyn.Datatypes.Ident
a260 1
  structure IdentPrint = DataTypes.IdentPrint
d378 1
a378 1
     DataTypes.IdentPrint.printValId valid)
d1827 1
a1827 1
	  DataTypes.IdentPrint.printValId), 0,
d1833 1
a1833 1
	(fn (x, _) => Print.print(DataTypes.IdentPrint.printValId x ^ "\n"))
d1837 1
a1837 1
	(fn x => Print.print(DataTypes.IdentPrint.printValId x ^ "\n"))
d1845 1
a1845 1
	  DataTypes.IdentPrint.printValId), next1,
d1857 1
a1857 1
	  DataTypes.IdentPrint.printStrId), next2, EnvironTypes.FIELD)
@


1.89
log
@Removed some structures and sharing
@
text
@d4 6
d205 1
d215 1
d234 3
a236 2
  sharing LambdaUtils.NewMap = Environ.EnvironTypes.NewMap
  sharing Environ.Ident = Environ.Interface.Ident = Type_Utils.Ident =
d240 1
a240 1
    Type_Utils.DataTypes = AbsynPrint.Absyn.Datatypes =
a244 1
  sharing Environ.Interface.Map = Type_Utils.Map = AbsynPrint.Absyn.Datatypes.Mapping
d370 1
a370 1
      Map.domain(Type_Utils.get_valenv ty)
d1141 2
a1142 2
	      (case Type_Utils.type_from_scheme(Map.lookup(valid,
							   type_val_env)) of
d1144 9
a1152 1
	      | _ => false)
d1791 1
a1791 1
    Lists.length(Map.assoc intenv) <> Lists.length(NewMap.to_list s_map) then
d1800 2
a1801 1
    compare_name_lists(Map.domain intenv, NewMap.domain_ordered s_map,
d1805 2
a1806 1
    (Lists.zip(Map.range intenv, map #1 (NewMap.range_ordered s_map)))
d1849 1
a1849 1
      val ordered_int_map = Lists.qsort s_order (Map.assoc s_int_map)
@


1.88
log
@Put in correct type annotations for UPDATE and BECOMES optimisations.
@
text
@d4 3
a184 3
require "../utils/map";
require "../utils/newmap";
require "../utils/set";
a186 1
require "../typechecker/datatypes";
a187 2
require "../typechecker/interface";
require "../basics/absyn";
a188 3
require "../basics/ident";
require "../basics/identprint";
require "../basics/symbol";
a192 2
require "environtypes";
require "lambdatypes";
a211 3
  structure Map: MAP
  structure NewMap: NEWMAP
  structure Set: SET
a212 3
  structure Ident : IDENT
  structure IdentPrint : IDENTPRINT
  structure Absyn : ABSYN
d214 1
a214 4
  structure Symbol: SYMBOL
  structure DataTypes : DATATYPES
  structure Types : TYPES
  structure Interface: INTERFACE
a216 2
  structure LambdaTypes: LAMBDATYPES
  structure EnvironTypes: ENVIRONTYPES
a222 1

a223 1
  sharing EnvironPrint.EnvironTypes = EnvironTypes
d225 14
a238 14
  sharing EnvironTypes.NewMap = LambdaUtils.NewMap = NewMap
  sharing DataTypes.Ident = Ident = Absyn.IdentClass = Environ.Ident =
    Interface.Ident = Type_Utils.Ident = IdentPrint.Ident
  sharing Absyn.Set = Set = LambdaSub.Set = Primitives.Set
  sharing Absyn.Interface = Interface = EnvironTypes.Interface
  sharing Match.DataTypes = DataTypes = Absyn.Datatypes = Types.Datatypes =
    Interface.Datatypes = Type_Utils.DataTypes = LambdaTypes.Datatypes 
  sharing Match.Absyn = Absyn
  sharing Ident.Symbol = Symbol
  sharing Environ.EnvironTypes = EnvironTypes = Primitives.EnvironTypes
  sharing DataTypes.Mapping = Map =
    Interface.Map = Type_Utils.Map
  sharing LambdaUtils.LambdaTypes = LambdaTypes = LambdaSub.LT =
    Environ.LambdaTypes = Primitives.LambdaTypes = LambdaOptimiser.LambdaTypes
d240 1
a240 2
  sharing AbsynPrint.Absyn = Absyn
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
d244 11
a254 3
  structure Absyn = Absyn
  structure EnvironTypes = EnvironTypes
  structure LambdaTypes = LambdaTypes
@


1.87
log
@Changed interface to match compiler to for passing back of redundancy and exhaustiveness information
@
text
@d4 3
d332 1
a332 1
			 LambdaTypes.ABSENT, LambdaTypes.ABSENT),"Builtin not",
d340 2
a341 1
      LambdaTypes.FN(l, LambdaTypes.VAR l, "identity", DataTypes.NULLTYPE)
d946 1
a946 1
	   LambdaTypes.null_type_annotation)
@


1.86
log
@null_type_annotation is no longer a function
@
text
@d4 3
d188 1
d224 1
d258 1
d611 32
d910 1
a910 1
    | Absyn.HANDLEexp (exp, _, pat_exp_list,_,annotation) =>
d913 1
a913 1
	val (root, tree) = Match.compile_match pat_exp_list
d921 3
d930 1
a930 1
    | Absyn.FNexp (pat_exp_list, ty, name_string,_) =>
d943 1
a943 1
	val (root, tree) = Match.compile_match pat_exp_list
d951 4
d1069 1
a1069 1
      | Match.LEAF(exp, mv_valid_ty_list) =>
@


1.85
log
@Generation of function call point debug information
@
text
@d4 3
d309 4
a312 4
	  LambdaTypes.null_type_annotation()),
	LambdaTypes.null_type_annotation()),
      "Builtin o",LambdaTypes.null_type_annotation()),
    "Builtin o argument 1",LambdaTypes.null_type_annotation())
d324 1
a324 1
      LambdaTypes.null_type_annotation())
d478 1
a478 1
	    LambdaTypes.null_type_annotation()))
d509 1
a509 1
			   LambdaTypes.null_type_annotation())
d534 1
a534 1
			   LambdaTypes.null_type_annotation())
d559 1
a559 1
	     LambdaTypes.null_type_annotation()))
d738 1
a738 1
                LambdaTypes.null_type_annotation())
d752 1
a752 1
                         LambdaTypes.null_type_annotation())
d883 1
a883 1
	   trans_match((root, tree), env, true,annotation,LambdaTypes.null_type_annotation())
d899 1
a899 1
	     LambdaTypes.null_type_annotation()),
d901 1
a901 1
	   LambdaTypes.null_type_annotation())
d1008 1
a1008 1
                       LambdaTypes.null_type_annotation()))
d1071 1
a1071 1
				      LambdaTypes.null_type_annotation())),
d1078 1
a1078 1
                                                    LambdaTypes.null_type_annotation()),""))
d1087 1
a1087 1
                                                     LambdaTypes.null_type_annotation()),""))
d1142 1
a1142 1
						     LambdaTypes.null_type_annotation()),
d1240 1
a1240 1
	    LambdaTypes.null_type_annotation())
d1245 1
a1245 1
	  LambdaTypes.null_type_annotation())
d1396 1
a1396 1
						       LambdaTypes.null_type_annotation()),
d1587 1
a1587 1
					 LambdaTypes.null_type_annotation()),
d1606 1
a1606 1
                                   LambdaTypes.null_type_annotation())
d1990 1
a1990 1
	  EnvironTypes.LAMB lv => (LambdaTypes.VAR lv, new_arg, LambdaTypes.null_type_annotation())
d1994 1
a1994 1
	     LambdaTypes.null_type_annotation())
d2094 1
a2094 1
       [LambdaTypes.LETB(lambda_var, LambdaTypes.FN(lvar, lambda_exp,annotation_string,LambdaTypes.null_type_annotation()),
@


1.84
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d795 1
a795 1
    | Absyn.APPexp(fun_exp, val_exp,_) =>
d859 1
a859 1
				 LambdaTypes.null_type_annotation())  (***)
@


1.83
log
@Added an annotation for excaptions
@
text
@d4 3
d299 7
a305 4
	LambdaTypes.SELECT({index = 0, size = 2}, LambdaTypes.VAR l1),
	  LambdaTypes.APP(
	    LambdaTypes.SELECT({index = 1, size = 2}, LambdaTypes.VAR l1),
	      LambdaTypes.VAR l2)),"Builtin o",LambdaTypes.null_type_annotation()),
d471 2
a472 1
	    LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))))
d502 2
a503 1
							 valid)))
d527 2
a528 1
							 exid)))
d552 2
a553 1
	     LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy))))
d596 3
a598 2
  fun let_lambdas_in_exp(lv_le_list, lambda_exp) =
    Lists.reducer LambdaTypes.do_binding (lv_le_list, lambda_exp)
d769 1
a769 1
	let_lambdas_in_exp(map (fn x => LambdaTypes.LET(#2(#1 x), #2 x,
d851 6
a856 1
	else LambdaTypes.APP(fcn, arg)
d892 4
a895 2
	     LambdaTypes.SCON(Ident.STRING"")),
	    LambdaTypes.SCON(Ident.STRING name)])
d905 1
a905 1
	(if !add_fn_names then [LambdaTypes.LET(update_lambda, update_exp,
d1009 1
a1009 1
      (map (fn (_, lv, le) => LambdaTypes.LET(lv, le,"Translation of match trees")) lab_lv_le_list,
d1062 5
a1066 5
		    (LambdaTypes.PRESENT(LambdaTypes.APP(LambdaTypes.VAR
							 new_lv,
							 LambdaTypes.STRUCT [])
					 ),
		     LambdaTypes.LET(new_lv,
d1075 1
a1075 1
		      LambdaTypes.LET(new_lv,
d1133 1
a1133 1
                    (LambdaTypes.LET(new_lv,
d1135 2
a1136 1
                                                     LambdaTypes.VAR orig_lv),
d1175 1
a1175 1
		LambdaTypes.do_binding(LambdaTypes.LET(lv, new_le,"match translation (v)"),
d1182 1
a1182 1
	    LambdaTypes.do_binding(LambdaTypes.LET(new_lv, new_le,""),
d1194 1
a1194 1
	    let_lambdas_in_exp(LambdaTypes.LET(new_lv, new_le,"") :: lv_le_list,
d1213 1
a1213 1
		 LambdaTypes.LET(lv,
d1233 2
a1234 1
	      LambdaTypes.STRUCT [])
d1238 2
a1239 1
	    LambdaTypes.STRUCT [])
d1314 1
a1314 1
	      [LambdaTypes.LET(dummy_lv,
d1331 1
a1331 1
		[LambdaTypes.LET(dummy_lv,
d1364 1
a1364 1
			      LambdaTypes.LET(lv, le,"")) big_list,
d1387 1
a1387 1
                      (LambdaTypes.LET(new_lv,
d1389 2
a1390 1
                                                       LambdaTypes.VAR lambda_var),
d1405 1
a1405 1
		(new_env, LambdaTypes.LET(new_lv,
d1428 1
a1428 1
	      (new_env, LambdaTypes.LET(new_lv,
d1458 1
a1458 1
	      LambdaTypes.LET(lvar, lambda,"") :: more_lambda @@ rest_lambda)
d1503 1
a1503 1
	    val lv_le_list = map (fn (x,y) => LambdaTypes.LET(x,y,"")) (lv_le_list_fn size)
d1507 1
a1507 1
	     [LambdaTypes.RECLET(map #1 lv_pat_exp_list, exp_list)])
d1509 1
a1509 1
 LambdaTypes.LET(letrec_lambda,
d1580 2
a1581 1
					 LambdaTypes.STRUCT[]),
d1589 2
a1590 2
		[LambdaTypes.LET(l1, lambda_exp,"Bound to a handler wrapped thing"),
		 LambdaTypes.LET(l2, if Type_Utils.is_vcc ty then
d1671 1
a1671 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp),"")
d1673 1
a1673 1
                 LambdaTypes.LET(l,
d1682 1
a1682 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp),"")
d1684 1
a1684 1
		LambdaTypes.LET(l, LambdaTypes.BUILTIN prim,"")
d1689 1
a1689 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp),"")
d1691 1
a1691 1
                 LambdaTypes.LET(l, LambdaTypes.BUILTIN prim,"")
d1827 1
a1827 1
        LambdaTypes.LET(lv,
d1831 1
a1831 1
                         LambdaTypes.LET(lv,LambdaTypes.BUILTIN prim,"")
d1838 1
a1838 1
        LambdaTypes.LET(lv,
d1841 1
a1841 1
                         LambdaTypes.LET(lv,LambdaTypes.BUILTIN prim,"")
d1849 1
a1849 1
          LambdaTypes.LET(lv, 
d1851 1
a1851 1
                          (LambdaTypes.LET(lv',
d1959 1
a1959 1
	   LambdaTypes.do_binding(LambdaTypes.LET(new_lv, lambda_exp,""),
d1984 1
a1984 1
	  EnvironTypes.LAMB lv => (LambdaTypes.VAR lv, new_arg)
d1987 2
a1988 1
	     LambdaTypes.SCON(Ident.STRING(Symbol.symbol_name sy)))
d2023 1
a2023 1
           [LambdaTypes.LET(lambda_var, lambda_exp,"")])
d2088 1
a2088 1
       [LambdaTypes.LET(lambda_var, LambdaTypes.FN(lvar, lambda_exp,annotation_string,LambdaTypes.null_type_annotation()),
@


1.82
log
@Added an annotation slot to HANDLE
@
text
@d4 3
d1574 3
a1576 1
                                   "Exception in _lambda",
@


1.81
log
@More data put into the debug slot of exceptions
@
text
@d4 3
d859 2
a860 1
      end)
d978 3
a980 1
                       "Part of match translation (i)" ^ name_string,
d1047 4
a1050 1
						    le,"Part of match translation (ii)" ^ name_string,
d1057 3
a1059 1
                                                     "Part of match translation (iii)" ^ name_string,
@


1.80
log
@Fixed problem whereby structures were being taken apart only to be rebuilt
exactly as before
@
text
@d4 4
d1536 3
a1538 1
		    val string_exp = LambdaTypes.SCON(Ident.STRING exception_name (* exn_string *))
@


1.79
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d4 3
d445 14
a458 9
  fun get_lamb_env(strid, env) =
  let
    val (env', comp) = Environ.lookup_strid(strid, env)
  in
    case comp of
      EnvironTypes.LAMB lvar => (env', LambdaTypes.VAR lvar)
    | EnvironTypes.PRIM prim => (env', LambdaTypes.BUILTIN prim)
    | _ => Crash.impossible "get_lamb_env does not give LVar or Primitive"
  end
d461 7
a467 6
  let val (env', field) = case Environ.lookup_strid(strid, env) of
    (env'', EnvironTypes.FIELD(field)) => (env'', field)
  | _ => Crash.impossible "get_field_env fails to get field"
  in
    (env', LambdaTypes.SELECT(field, lambda))
  end
d469 4
d482 5
a486 1
       | _ => Crash.impossible "cg_longvalid gives field")
d495 4
a498 1
      | _ => Crash.impossible "cg_longvalid fails to get field or prim"
d506 5
a510 1
       | _ => Crash.impossible "cg_longvalid gives field")
d519 4
a522 1
      | _ => Crash.impossible "cg_longexid fails to get field or prim"
d526 1
a526 1
    Ident.LONGSTRID(Ident.NOPATH, strid) =>
d530 6
a535 1
       | _ => Crash.impossible "cg_longstrid gives field")
d546 4
a549 1
      | _ => Crash.impossible "cg_longstrid fails to get field or prim"
d1628 5
a1632 1
                 LambdaTypes.LET(l, LambdaTypes.BUILTIN prim,"")
d1700 3
a1702 3
    (Lists.reducel (fn(x, y) => x andalso y)
     (true, map compare_sig_env (Lists.zip(Map.range intenv,
					   map #1 (NewMap.range s_map)))))
d1787 4
a1790 1
		      | _ => Crash.impossible "c_s_w_i(1)")
d1797 4
a1800 1
		      | _ => Crash.impossible "c_s_w_i(2)")
d1812 3
a1814 1
	      Crash.impossible "c_s_w_i (4) PRIM")
d1877 4
a1880 1
      | extract_op _ = Crash.impossible "extract_op problem"
d1908 2
a1909 1
	let val new_lv = LambdaTypes.new_LVar()
d1929 3
a1931 2
  | Absyn.APPstrexp(funid, strexp,_) =>
    let val (lv, interface, result_env) = Environ.lookup_funid(funid, fun_env)
a1934 4
      val f_lv = case lv of
	EnvironTypes.LAMB lv => lv
      | EnvironTypes.PRIM _ => Crash.impossible "APPstrexp(1)"
      | EnvironTypes.FIELD _ => Crash.impossible "APPstrexp(2)"
d1936 9
a1944 1
      (result_env, LambdaTypes.APP(LambdaTypes.VAR f_lv, new_arg))
@


1.78
log
@Added ident function for type casting required by interpreter
@
text
@d4 3
d519 10
d531 5
d599 3
a601 2
	      if cg <> eq_prim andalso cg <> neq_prim then
		cg
d604 2
a605 1
		  val sy_name = if cg = eq_prim then "=" else "<>"
d1056 3
a1058 1
                  andalso cg_longvalid(name,val_env) = LambdaTypes.BUILTIN(Pervasives.REF)
d1302 3
a1304 1
                   andalso cg_longvalid(longvalid,envir) = LambdaTypes.BUILTIN(Pervasives.REF)
d1477 3
a1479 3
	    val (v, ty) = case ex of
	      Absyn.NEWexbind((v, ref ty), _,_) => (v, ty)
	    | Absyn.OLDexbind((v, ref ty), longv,_) => (v, ty)
d1497 1
a1497 1
		    val string_exp = LambdaTypes.SCON(Ident.STRING exn_string)
d1505 1
a1505 1
		    | Absyn.OLDexbind(_, longv,_) =>
@


1.77
log
@Sorted out compare_names stuff
@
text
@d4 3
d299 7
d579 2
a580 1
	    LambdaTypes.BUILTIN prim =>
@


1.76
log
@Added type annotations to FNexp
@
text
@d4 3
d1607 1
a1607 1
  fun compare_name_lists(list1, list2) =
d1609 1
a1609 1
    (Lists.qsort op = list1) = (Lists.qsort op = list2)
d1620 6
a1625 2
    compare_name_lists(v_list, NewMap.domain v_map) andalso
    compare_name_lists(Map.domain intenv, NewMap.domain s_map) andalso
@


1.75
log
@changed to use newmap
@
text
@d4 3
d213 1
a213 1
    Interface.Datatypes = Type_Utils.DataTypes
d277 2
a278 1
	      LambdaTypes.VAR l2)),"Builtin o"),"Builtin o argument 1")
d289 2
a290 1
			 LambdaTypes.ABSENT, LambdaTypes.ABSENT),"Builtin not")
d641 2
a642 1
		LambdaTypes.VAR new_lv,"constructor " ^ Symbol.symbol_name symbol)
d654 3
a656 1
	  LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],"Builtin code to construct an exception")
d679 2
a680 1
	let_lambdas_in_exp(map (fn x => LambdaTypes.LET(#2(#1 x), #2 x))
d771 2
a772 2
    | Absyn.HANDLEexp (exp, _, pat_exp_list,_) =>
      LambdaTypes.HANDLE(trans_exp(" handler", exp, env),
d782 1
a782 1
	   trans_match((root, tree), env, true,"A handler")
d787 1
a787 1
    | Absyn.FNexp (pat_exp_list, _, name_string) =>
d807 2
a808 1
	(if !add_fn_names then [LambdaTypes.LET(update_lambda, update_exp)]
d810 1
a810 1
	 trans_match((root, tree), env, false,name_string))
d866 1
a866 1
  and trans_match((root, tree), env, is_exn, name_string) =
d901 2
a902 1
                       "Part of match translation (i)" ^ name_string))
d909 1
a909 1
      (map (fn (_, lv, le) => LambdaTypes.LET(lv, le)) lab_lv_le_list,
d968 2
a969 1
						    le,"Part of match translation (ii)" ^ name_string)))
d975 2
a976 1
                                                     "Part of match translation (iii)" ^ name_string)))
d1025 5
a1029 3
		  LambdaTypes.do_binding(LambdaTypes.LET(new_lv,
		    LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.DEREF,
                                    LambdaTypes.VAR orig_lv)),
d1067 1
a1067 1
		LambdaTypes.do_binding(LambdaTypes.LET(lv, new_le),
d1074 1
a1074 1
	    LambdaTypes.do_binding(LambdaTypes.LET(new_lv, new_le),
d1086 1
a1086 1
	    let_lambdas_in_exp(LambdaTypes.LET(new_lv, new_le) :: lv_le_list,
d1108 1
a1108 1
						    le)))
d1160 1
a1160 1
      tr_match(tree, match_env, env, LambdaUtils.empty_label_env),name_string)
d1207 1
a1207 1
                  excp, LambdaTypes.ABSENT))])
d1230 1
a1230 1
			else excp(* Fault if not a tag *)))])
d1254 1
a1254 1
			      LambdaTypes.LET(lv, le)) big_list,
d1277 2
a1278 1
                                                       LambdaTypes.VAR lambda_var))
d1306 1
a1306 1
			      LambdaTypes.ABSENT)))) :: new_lambda_exp)
d1319 1
a1319 1
			excp, LambdaTypes.ABSENT)) :: new_lambda_exp)
d1345 1
a1345 1
	      LambdaTypes.LET(lvar, lambda) :: more_lambda @@ rest_lambda)
d1390 1
a1390 1
	    val lv_le_list = map LambdaTypes.LET (lv_le_list_fn size)
d1473 1
a1473 1
		[LambdaTypes.LET(l1, lambda_exp),
d1481 2
a1482 1
                                   "Exception in _lambda")
d1486 1
a1486 1
					    LambdaTypes.STRUCT []]))]
d1553 1
a1553 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp))
d1555 1
a1555 1
                 LambdaTypes.LET(l, LambdaTypes.BUILTIN prim)
d1560 1
a1560 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp))
d1562 1
a1562 1
		LambdaTypes.LET(l, LambdaTypes.BUILTIN prim)
d1567 1
a1567 1
		LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp))
d1569 1
a1569 1
                 LambdaTypes.LET(l, LambdaTypes.BUILTIN prim)
d1702 2
a1703 1
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var))
d1705 1
a1705 1
                         LambdaTypes.LET(lv,LambdaTypes.BUILTIN prim)
d1710 1
a1710 1
			LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var))
d1712 1
a1712 1
                         LambdaTypes.LET(lv,LambdaTypes.BUILTIN prim)
d1717 5
a1721 2
          LambdaTypes.LET(lv, LambdaTypes.do_binding(LambdaTypes.LET(lv',
	  LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var)), le))
d1821 1
a1821 1
	   LambdaTypes.do_binding(LambdaTypes.LET(new_lv, lambda_exp),
d1879 1
a1879 1
           [LambdaTypes.LET(lambda_var, lambda_exp)])
d1944 2
a1945 1
       [LambdaTypes.LET(lambda_var, LambdaTypes.FN(lvar, lambda_exp,annotation_string))])
@


1.74
log
@Moved assign_fields into environ
@
text
@d4 3
d143 1
d180 1
d204 1
d214 1
a214 1
  sharing DataTypes.Mapping = Map = EnvironTypes.Map = LambdaUtils.Map =
d871 1
a871 1
      (Map.assoc labels)
d876 3
a878 2
      LambdaUtils.LABELS (Map.remove(LambdaUtils.LABEL real_label,
        Map.remove(LambdaUtils.GOTO real_label, labels)))
d1102 5
a1106 2
	if Map.domain_member(LambdaUtils.LABEL label, def_only_labels) then
	  tr_match(tree, match_env, val_env, lab_env)
d1514 1
a1514 1
	       (Map.assoc valid_env)
d1516 1
a1516 1
	       (Map.assoc exn_env)
d1519 1
a1519 1
	       (Map.assoc strid_env)
d1593 4
a1596 3
  if Lists.length v_list <> Lists.length(Map.assoc v_map) orelse
    Lists.length e_list <>  Lists.length(Map.assoc e_map) orelse
    Lists.length(Map.assoc intenv) <> Lists.length(Map.assoc s_map) then false
d1600 2
a1601 2
    compare_name_lists(v_list, Map.domain v_map) andalso
    compare_name_lists(Map.domain intenv, Map.domain s_map) andalso
d1604 1
a1604 1
					   map #1 (Map.range s_map)))))
d1613 1
a1613 1
      val v_a_list = Lists.qsort v_order (Map.assoc v_map)
d1624 1
a1624 1
      val e_a_list = Lists.qsort v_order (Map.assoc e_map)
d1645 1
a1645 1
      val s_a_list = Lists.qsort s_order (Map.assoc s_map)
d1761 4
a1764 4
    val valids = Map.assoc mv
    val exns = Map.assoc me
    val strids = Map.assoc ms
    val funids = Map.assoc m
d1782 1
a1782 2
  fun make_top_env env = EnvironTypes.TOP_ENV(env,
    EnvironTypes.FUN_ENV Map.empty_map)
@


1.73
log
@Added some optimisation of polymorphic equality tests, on refs
and datatypes with no value carrying constructors
@
text
@d4 4
d291 1
a291 1
	Crash.impossible error_message
d318 1
a318 1
     "constructor_tag(3): " ^ Types.print_type ty ^ "," ^
d332 1
a332 1
    {index = position (lab, record_domain, "record_tag(1)"),
d395 1
a395 1
	   (Print.print("Checking type of " ^ Types.print_type h ^ "\n");
d1701 1
d1745 1
d1758 1
a1758 1
    (assign_fields topenv,
d1777 1
a1777 1
      assign_fields(make_top_env env)
@


1.72
log
@Added marks to some of the abstract syntax
@
text
@d4 3
d370 3
a372 3
  fun domain_type_name(DataTypes.FUNTYPE(DataTypes.RECTYPE record_map, _)) =
    (case Map.range record_map of
       (h :: t) =>
d374 4
a377 5
	    DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
	  | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
	  | _ => (false, ""))
     | _ => (false, ""))
    | domain_type_name _ = (false, "Not fun(rec)")
d379 22
d552 55
a606 20
	      let
	      in
		if cg <> eq_prim andalso cg <> neq_prim then
		  cg
		else
		  let
		    val sy_name = if cg = eq_prim then "=" else "<>"
		    val (is_simple, name) = domain_type_name ty
		    val ident =
		      Ident.LONGVALID(Ident.NOPATH,
			Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name)))
		  in
		    case (is_simple, name) of
		      (false, _) => cg
		    | (_, "int") => cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		    | (_, "real") => cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		    | (_, "string") => cg_longvalid(ident, Primitives.env_for_lookup_in_lambda)
		    | _ => cg
		  end
	      end
@


1.71
log
@Added more documentation to fn's
@
text
@d4 3
d494 1
a494 1
    | Absyn.VALexp(longValId, ref ty) => (case longValId of
d624 1
a624 1
    | Absyn.APPexp(fun_exp, val_exp) =>
d665 1
a665 1
	      Absyn.VALexp(_, ref ty) => ty
d687 1
a687 1
    | Absyn.TYPEDexp (expression, _) => trans_exp(" no_name", expression, env)
d689 1
a689 1
    | Absyn.RAISEexp (exp) => LambdaTypes.RAISE(trans_exp(" no_name", exp, env))
d693 1
a693 1
    | Absyn.HANDLEexp (exp, _, pat_exp_list) =>
a732 2
    | Absyn.TEN15exp _ =>
	Crash.impossible "TEN15exp found"
d1247 1
a1247 1
	  ((pat, exp) :: tl, _) =>
d1253 1
a1253 1
	      trans_dec(Absyn.VALdec(tl, rec_list, tyvar), envir)
d1262 1
a1262 1
	      (fn (pat, exp) => (LambdaTypes.new_LVar(), pat, exp)) rec_list
d1284 1
a1284 1
	      (fn (pat, exp) => trans_exp(pat_name pat, exp, trans_env))
d1320 7
a1326 4
	let fun munge((valid as Ident.CON sy, ref ty), _) =
	  (Absyn.VALpat(Ident.LONGVALID(Ident.NOPATH, Ident.VAR sy), ref ty),
	    Absyn.VALexp(Ident.LONGVALID(Ident.NOPATH, valid), ref ty))
	  | munge _ = Crash.impossible"Absyn.DATATYPE"
d1351 2
a1352 2
	      Absyn.NEWexbind((v, ref ty), _) => (v, ty)
	    | Absyn.OLDexbind((v, ref ty), longv) => (v, ty)
d1378 1
a1378 1
		    | Absyn.OLDexbind(_, longv) =>
d1424 1
a1424 1
    | Absyn.OPENdec longStrId_list =>
d1740 1
a1740 1
  | Absyn.APPstrexp(funid, strexp) =>
d1767 21
a1787 19
    | (strid, sigexp_opt, strexp) :: tl =>
    let fun trans_single_struct(strid, sigexp_opt, strexp) =
      let val inte_opt = case sigexp_opt of
	  Absyn.ABSENT => LambdaTypes.ABSENT
	| Absyn.PRESENT(Absyn.NEWsigexp(_, ref inte)) =>
	    LambdaTypes.PRESENT inte
	| Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte)) =>
	    LambdaTypes.PRESENT inte
	val (str_env, lambda_exp) =
	  complete_struct(trans_str_exp(strexp, top_env), inte_opt)
	val lambda_var = LambdaTypes.new_LVar()
      in
	(Environ.add_strid_env(Environ.empty_env, (strid,
	  (str_env, EnvironTypes.LAMB lambda_var))),
	    [LambdaTypes.LET(lambda_var, lambda_exp)])
      end
	val (env', lv_le_list) = trans_single_struct(strid, sigexp_opt, strexp)
	val (env'', lv_le_list') = trans_str_dec(Absyn.STRUCTUREstrdec tl,
	  Environ.augment_top_env(top_env, make_top_env env'))
d1817 1
a1817 1
      funbind as (funid, strid, sigexp, _, strexp, sigexp_opt,annotation_string),
d1874 1
a1874 1
      Absyn.STRDECtopdec strdec =>
d1882 1
a1882 1
    | Absyn.FUNCTORtopdec funbind_list =>
@


1.70
log
@Changed signature comparison test to check for equal before sorting,
as the implementation tends to deliver the data in order anyway
@
text
@d4 4
d820 1
a820 1
                       "_lambda 6"))
d886 1
a886 1
						    le,"_lambda 7")))
d891 2
a892 1
						     LambdaTypes.STRUCT[],"_lambda 8")))
d1387 2
a1388 1
				   ([LambdaTypes.VAR l1, LambdaTypes.VAR l3]),"_lambda 9")
@


1.69
log
@Added more useful diagnostic info
@
text
@d4 3
d1504 4
d1516 5
a1520 9
    let fun compare_name_lists(list1, list2) =
      (Lists.qsort op = list1) = (Lists.qsort op = list2)
    in
      compare_name_lists(v_list, Map.domain v_map) andalso
      compare_name_lists(Map.domain intenv, Map.domain s_map) andalso
      (Lists.reducel (fn(x, y) => x andalso y)
        (true, map compare_sig_env (Lists.zip(Map.range intenv,
	  map #1 (Map.range s_map)))))
    end
@


1.68
log
@Modified APPexp translation so beta reduction is only called
when equality is being applied to a pair of values from a datatype,
one of which may be constant
@
text
@d4 5
d251 1
a251 1
	      LambdaTypes.VAR l2)),"_lambda 1"),"_lambda 2")
d262 1
a262 1
			 LambdaTypes.ABSENT, LambdaTypes.ABSENT),"_lambda 3")
d569 1
a569 1
	  LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv],"_lambda 5")
@


1.67
log
@First version of the profiler
@
text
@d4 3
a611 9
	val arg = LambdaOptimiser.simple_beta_reduce(trans_exp(" no_name", val_exp, env))
	val (good_arg, new_arg, absyn) = case (arg, val_exp) of
	  (LambdaTypes.STRUCT[le, le' as LambdaTypes.INT _],
	    Absyn.RECORDexp[_, (_, valexp as Absyn.VALexp _)]) =>
	    (true, LambdaTypes.STRUCT[le', le], valexp)
	| (LambdaTypes.STRUCT[le' as LambdaTypes.INT _, le],
	    Absyn.RECORDexp[(_, valexp as Absyn.VALexp _), _]) =>
	    (true, LambdaTypes.STRUCT[le', le], valexp)
	| _ => (false, arg, val_exp)
d619 21
@


1.66
log
@Changed length for Lists.length in various places. Removed word require
from trans_top_dec since this confuses the parser
@
text
@d4 4
d123 1
d154 1
d175 1
a175 1
    Interface.Ident = Type_Utils.Ident
d243 1
a243 1
	      LambdaTypes.VAR l2))))
d254 1
a254 1
			 LambdaTypes.ABSENT, LambdaTypes.ABSENT))
d534 1
a534 1
    | Ident.LONGVALID(_, valid as Ident.CON _) =>
d549 1
a549 1
		LambdaTypes.VAR new_lv)
d561 1
a561 1
	  LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv])
d659 1
a659 1
    | Absyn.RAISEexp (exp, _) => LambdaTypes.RAISE(trans_exp(" no_name", exp, env))
d674 1
a674 1
	   trans_match((root, tree), env, true)
d679 1
a679 1
    | Absyn.FNexp (pat_exp_list, _, _) =>
d701 1
a701 1
	 trans_match((root, tree), env, false))
d759 1
a759 1
  and trans_match((root, tree), env, is_exn) =
d792 2
a793 1
	  tr_match(tree', match_env, val_env, label_env)))
d859 1
a859 1
						    le)))
d864 1
a864 1
						     LambdaTypes.STRUCT[])))
d1043 1
a1043 1
      tr_match(tree, match_env, env, LambdaUtils.empty_label_env))
d1359 1
a1359 1
				   ([LambdaTypes.VAR l1, LambdaTypes.VAR l3]))
d1782 1
a1782 1
      funbind as (funid, strid, sigexp, _, strexp, sigexp_opt),
d1813 1
a1813 1
       [LambdaTypes.LET(lambda_var, LambdaTypes.FN(lvar, lambda_exp))])
@


1.65
log
@Added bool ref for add_fn_names to control addition of function names
@
text
@d4 3
d892 1
a892 1
            if length nullary_list = 0 then
d934 1
a934 1
		  if length nullary_list = Type_Utils.get_no_null_cons ty then
d940 1
a940 1
	    if length vcc_lv_list = 1 andalso Type_Utils.get_no_vcc_cons ty = 1 then
d960 1
a960 1
	      if length vcc_lv_list = Type_Utils.get_no_vcc_cons ty then
d1476 3
a1478 3
  if length v_list <> length(Map.assoc v_map) orelse
    length e_list <>  length(Map.assoc e_map) orelse
    length(Map.assoc intenv) <> length(Map.assoc s_map) then false
d1774 1
a1774 6
  fun trans_fun_dec_list([], _) = (make_top_env Environ.empty_env, [])
  | trans_fun_dec_list((Absyn.FUNBIND funbind):: rest, top_env) =
  let
    fun trans_fun_dec([], _) = (make_top_env Environ.empty_env, [])
    | trans_fun_dec(funbind :: rest, top_env) =
    let fun trans_individual_funbind(
d1777 35
a1811 23
      let
	val interface = interface_from_sigexp sigexp
	val env = Environ.make_env_from_interface interface
	val lvar = LambdaTypes.new_LVar()
	val inte_opt = case sigexp_opt of
	  Absyn.ABSENT => LambdaTypes.ABSENT
	| Absyn.PRESENT(Absyn.NEWsigexp(_, ref inte)) =>
	    LambdaTypes.PRESENT inte
	| Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte)) =>
	    LambdaTypes.PRESENT inte
	val (str_env, lambda_exp) =
	  complete_struct(trans_str_exp(strexp,
	    Environ.augment_top_env(top_env,
	      make_top_env(Environ.add_strid_env(Environ.empty_env, (strid,
		(env, EnvironTypes.LAMB lvar)))))),
		  inte_opt)
	val lambda_var = LambdaTypes.new_LVar()
      in
	(EnvironTypes.TOP_ENV(Environ.empty_env,
          Environ.add_funid_env(Environ.empty_fun_env, (funid,
	    (EnvironTypes.LAMB lambda_var, interface, str_env)))),
	  [LambdaTypes.LET(lambda_var, LambdaTypes.FN(lvar, lambda_exp))])
      end
d1817 4
d1842 1
a1842 1
    | Absyn.REQUIREtopdec require =>
@


1.64
log
@Added function name propagation to the lambda translation
@
text
@d4 3
d188 1
d690 2
a691 1
	([LambdaTypes.LET(update_lambda, update_exp)],
@


1.63
log
@val (ref ...) = exp wasn't introducing an extra DEREF operation
@
text
@d4 3
d450 1
a450 1
  fun trans_exp(x, env) =
d567 1
a567 1
	  map (fn (_, exp) => trans_exp (exp, env)) label_exp_list
d589 1
a589 1
          trans_exp(exp, Environ.augment_env(env, env')))
d595 2
a596 2
	val fcn = trans_exp(fun_exp, env)
	val arg = LambdaOptimiser.simple_beta_reduce(trans_exp(val_exp, env))
d644 1
a644 1
    | Absyn.TYPEDexp (expression, _) => trans_exp (expression, env)
d646 1
a646 1
    | Absyn.RAISEexp (exp, _) => LambdaTypes.RAISE(trans_exp(exp, env))
d651 1
a651 1
      LambdaTypes.HANDLE(trans_exp(exp, env),
d668 9
d685 3
a687 1
	trans_match((root, tree), env, false)
d796 1
a796 1
	  fun do_leaf([], env) = trans_exp(exp, env)
d1207 1
a1207 1
	    val lambda = trans_exp(exp, envir)
d1227 12
d1240 2
a1241 2
	      ((fn exp => trans_exp(exp, trans_env))
	        o #2) rec_list
@


1.62
log
@Fixed problem whereby lambda expressions were being duplicated for
the two defaults in a CONS switch pair
@
text
@d4 4
d880 3
a882 1
		if Environ.Builtin_p(name, val_env) then
d885 2
a886 4
		    LambdaTypes.APP(cg_longvalid(
		      Ident.LONGVALID(Ident.NOPATH,
			Ident.VAR(Symbol.find_symbol"!")), val_env),
			  LambdaTypes.VAR orig_lv)),
d1114 30
a1143 12
	| Absyn.APPpat((longvalid, ref ty), pat) => (case longvalid of
	    Ident.LONGVALID(_, Ident.VAR _) =>
	    Crash.impossible"APPpat of Ident.VAR"
	  | Ident.LONGVALID(_, valid as Ident.CON con) =>
	    if Type_Utils.get_no_cons ty = 1 then
	      trans_individual_dec(pat, lambda_var)
	    else
	      let val new_lv = LambdaTypes.new_LVar()
		val (new_env, new_lambda_exp) =
		  trans_individual_dec(pat, new_lv)
		val lexp = LambdaTypes.VAR lambda_var
		val tag = constructor_tag(valid, ty)
d1161 1
@


1.61
log
@Added show_match to control printing of match trees
@
text
@d4 3
a777 21
(*
	  val LambdaUtils.ME match_map = match_env
	  val _ =
	    Print.print
	    (implode
	     ("\ndo_leaf with match_env\n" ::
	      map
	      (fn (mv, lv) => "mv : " ^
	       Integer.makestring(Match.from_Matchvar mv) ^ ", lv : " ^
	       LambdaTypes.printLVar lv ^ "\n")
	      (Map.assoc match_map)))
	  val _ =
	    Print.print
	    (implode
	     ("match variables and valids\n" ::
	      map
	      (fn (mv, valid, _) =>
	       Integer.makestring(Match.from_Matchvar mv) ^ ", " ^
	       DataTypes.IdentPrint.printValId valid ^ "\n")
	      mv_valid_ty_list))
*)
d811 23
a833 5
	  val def_lambda = case default of
            Match.PRESENT tree =>
	      LambdaTypes.PRESENT(tr_match(tree, match_env, val_env,
		new_lab_env))
          | Match.ABSENT => LambdaTypes.ABSENT
@


1.60
log
@New pervasive library - tried to neaten code
@
text
@d4 3
d174 2
d642 2
a643 5
      let val (root, tree) = Match.compile_match pat_exp_list
(*
	val _ = Print.print"Exception match tree is"
	val _ = map (fn x => output (std_out,x)) (Match.unparseTree tree "")
*)
d645 7
a651 1
	trans_match((root, tree), env, true)
d657 2
a658 5
      let val (root, tree) = Match.compile_match pat_exp_list
(*
	val _ = Print.print"Match tree is"
	val _ = map (fn x => output (std_out,x)) (Match.unparseTree tree "")
*)
d660 6
d774 23
a796 1
	let fun do_leaf([], env) = trans_exp(exp, env)
@


1.59
log
@Fixed bug in complete_struct_with_sig whereby recursive calls
were binding variables to the result expression in what they
should have been bound to (ie it said let lv = le' in le when it
should have said let lv = le in le')
@
text
@d4 6
d187 9
a195 1
    filter_map(a_list, f_list, print_fn, [])
d416 1
a416 6
  val eq_prim =
    cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
      Ident.VAR(Symbol.find_symbol("="))), Primitives.initial_env)
  val neq_prim =
    cg_longvalid(Ident.LONGVALID(Ident.NOPATH,
      Ident.VAR(Symbol.find_symbol("<>"))), Primitives.initial_env)
d418 2
d467 3
a469 2
	  Print.print("Overload clash on " ^ sy_name ^ "\nis_ol = " ^
		      (if is_ol then "true\n" else "false\n"))
d471 8
a478 6
	val cg = cg_longvalid(
	  if is_ol then
	    Ident.LONGVALID(Ident.NOPATH, 
	      Ident.VAR(Symbol.find_symbol("_" ^ name ^ sy_name)))
	  else longValId,
		     env)
d496 3
a498 3
		    | (_, "int") => cg_longvalid(ident, env)
		    | (_, "real") => cg_longvalid(ident, env)
		    | (_, "string") => cg_longvalid(ident, env)
d1317 2
d1320 2
a1321 2
	       (fn (env, (v, _, l)) =>
		Environ.add_valid_env(env, (v, EnvironTypes.LAMB(l))))
d1324 2
a1325 2
	       (fn (env, (e, _, l)) =>
		Environ.add_exn_env(env, (e, EnvironTypes.LAMB(l))))
d1334 3
a1336 1
	       | _ => Crash.impossible "Absyn.OPENdec(1)"
d1341 3
a1343 1
	       | _ => Crash.impossible "Absyn.OPENdec(1)"
d1348 2
d1468 2
d1477 2
a1478 2
	        map (fn ((v, _), f_new) => (v, f_new)) v_a_f_list),
	          map (fn ((e, _), f_new) => (e, f_new)) e_a_f_list)
d1482 2
d1489 2
d1523 2
d1526 1
a1526 1
      map (fn ((vid, _), f) => (vid, f)) (v_field_fn size)
d1528 1
a1528 1
      map (fn ((eid, _), f) => (eid, f)) (e_field_fn size)
d1530 1
a1530 1
      map (fn ((sid, (e, _)), f) => (sid,(e, f))) (s_field_fn size)
d1534 14
d1549 1
a1549 12
    EnvironTypes.TOP_ENV
    (Lists.reducel
     Environ.add_strid_env
     (Lists.reducel
      Environ.add_exn_env
      (Lists.reducel
       Environ.add_valid_env
       (Environ.empty_env, v_field),
       e_field), s_field),
     Lists.reducel
     Environ.add_funid_env
     (Environ.empty_fun_env, f_field))
d1559 3
d1566 8
a1573 9
      (map (fn (_, EnvironTypes.LAMB lv) => LambdaTypes.VAR lv
            | _ => Crash.impossible "comp_st(1)") valids) @@
      (map (fn (_, EnvironTypes.LAMB lv) => LambdaTypes.VAR lv
            | _ => Crash.impossible "comp_st(1)") exns) @@
      (map (fn (_, (_, EnvironTypes.LAMB lv)) => LambdaTypes.VAR lv
            | _ => Crash.impossible "comp_st(1)") strids) @@
      (map (fn (_, (EnvironTypes.LAMB lv, _, _)) => LambdaTypes.VAR lv
            | _ => Crash.impossible "comp_st(1)") funids)
      )))
@


1.58
log
@Fixed bug in open whereby exception environment and bindings weren't made
@
text
@d4 3
d1437 2
d1467 2
a1468 2
          LambdaTypes.LET(lv, LambdaTypes.do_binding(LambdaTypes.LET(lv', le),
	  LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var)))
@


1.57
log
@Extracted out type fiddling functions into match/type_utils
@
text
@d4 3
d167 5
a171 4
  fun filter_ordered_map (a_list, []) = []
    | filter_ordered_map ([], _) =
      Crash.impossible "member missing in filter_ordered_map"
    | filter_ordered_map((x, y)::xs, z :: zs) =
d173 1
a173 1
	(x, y) :: (filter_ordered_map(xs, zs))
d175 1
a175 1
	filter_ordered_map(xs, z :: zs)
d177 3
d1286 46
a1331 40
       let fun trans_open([], _) = (Environ.empty_env, [])
       | trans_open(longstrid :: tl, env) =
	 let
	   val (EnvironTypes.ENV(valid_env, exn_env, strid_env), lambda_exp) =
	     cg_longstrid(longstrid, env)
	   val valid_map = map (fn (v, c) => (v, c, LambdaTypes.new_LVar()))
	     (Map.assoc valid_env)
	   val exn_map = map (fn (e, c) => (e, c, LambdaTypes.new_LVar()))
	     (Map.assoc exn_env)
	   val strid_map = map (fn (s, ec) => (s, ec, LambdaTypes.new_LVar()))
	     (Map.assoc strid_env)
	   val new_v_env = Lists.reducel
	     (fn (env, (v, _, l)) =>
	       Environ.add_valid_env(env, (v, EnvironTypes.LAMB(l))))
	         (Environ.empty_env, valid_map)
	   val new_e_env = Lists.reducel
	     (fn (env, (e, _, l)) =>
	       Environ.add_exn_env(env, (e, EnvironTypes.LAMB(l))))
	         (Environ.empty_env, exn_map)
	   val new_s_env = Lists.reducel
	     (fn (env, (s, (e, c), l)) =>
	       Environ.add_strid_env(env, (s, (e, EnvironTypes.LAMB(l)))))
	         (Environ.empty_env, strid_map)
	   val new_v_lambdas = map
	     (fn (_, EnvironTypes.FIELD field, l) =>
	       LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp))
	     | _ => Crash.impossible "Absyn.OPENdec(1)"
               ) valid_map
	   val new_s_lambdas = map
	     (fn (_, (_, EnvironTypes.FIELD(field)), l) =>
	       LambdaTypes.LET(l, LambdaTypes.SELECT(field, lambda_exp))
	     | _ => Crash.impossible "Absyn.OPENdec(2)"
               ) strid_map
	   val overall_env = Environ.augment_env(new_v_env, new_s_env)
	   val (next_env, next_lambdas) =
	     trans_open(tl, Environ.augment_env(env, overall_env))
	 in
	   (Environ.augment_env(overall_env, next_env),
	     new_v_lambdas @@ new_s_lambdas @@ next_lambdas)
	 end
d1333 1
a1333 1
	 trans_open(longStrId_list, envir)
d1386 3
d1392 2
a1393 1
	 (v_a_list, Lists.qsort Ident.valid_order v_list), 0,
d1396 11
a1406 1
	(* Throw out unwanted elements and assign new field numbers *)
d1410 2
a1411 1
	 (e_a_list, Lists.qsort Ident.valid_order e_list), next1,
d1413 3
d1422 2
a1423 1
	 (s_a_list, map #1 ordered_int_map), next2, EnvironTypes.FIELD)
@


1.56
log
@Removed some small type structure manipulation functions into
a separate file match/type_utils. Other should follow some time,
eg record_tag and constructor_tag
@
text
@d4 5
d138 1
a138 1
    Interface.Ident
d147 1
a147 1
    Interface.Map
a218 4
  fun get_valenv(DataTypes.CONSTYPE(_,
      DataTypes.TYNAME(_, _, _, _, ref (DataTypes.VE(_, valenv))))) = valenv
    | get_valenv _ =
      Crash.impossible "bad ty in get_valenv"
d233 1
a233 6
    val constype =
      case ty of
	DataTypes.FUNTYPE (_,ty') => ty'
      | DataTypes.CONSTYPE _      => ty
      | _                         =>
	Crash.impossible "constructor_tag(1)"
d236 2
a237 4
    fun domain (DataTypes.CONSTYPE (_, DataTypes.TYNAME {5 = ref (DataTypes.VE(_, map)),...})) =
      Map.domain map
    | domain _ = Crash.impossible "constructor_tag(2)"

d250 1
a250 1
  fun record_label_offset (lab, the_type) =
d253 1
a253 17
    fun domain (DataTypes.RECTYPE map) = Map.domain map
      | domain (DataTypes.METARECTYPE(ref(_, _, ty, _, _))) = domain(ty)
      | domain (the_type) =
	let
	  val type_string = case the_type of
	    DataTypes.METATYVAR(_) => "METATYVAR"
	  | DataTypes.META_OVERLOADED(_) => "META_OVERLOADED"
	  | DataTypes.TYVAR(_) => "TYVAR"
	  | DataTypes.FUNTYPE(_) => "FUNTYPE"
	  | DataTypes.CONSTYPE(_) => "CONSTYPE"
	  | DataTypes.DEBRUIJN(_) => "DEBRUIJN"
	  | DataTypes.NULLTYPE => "NULLTYPE"
	  | _ => "Completely impossible"
	in
	  Crash.impossible ("record_tag(2)" ^ type_string)
	end
    val record_domain = domain the_type
a273 4
  fun get_cons_type ty = case ty of
    DataTypes.FUNTYPE(_, ty2) => ty2
  | DataTypes.CONSTYPE _ => ty
  | _ => Crash.impossible"get_cons_type on non-constructed type"
d777 1
a777 1
	  val type_val_env = get_valenv(get_cons_type ty)
@


1.55
log
@Fixed bug in determination of overloading from the evnironment,
instead of looking up the last part of the name in the known overloads,
we must check the path is empty, and it produces a primitive, and
then see if it's in the overloaded set
@
text
@d4 6
d85 1
d112 3
a117 3
  structure Ident : IDENT
  structure Absyn : ABSYN
  structure Symbol: SYMBOL
d119 1
d136 2
a137 2
  sharing Match.Datatypes = DataTypes = Absyn.Datatypes = Types.Datatypes =
    Interface.Datatypes
a300 20
  fun is_vcc ty = case ty of
    DataTypes.FUNTYPE _ => true
  | DataTypes.CONSTYPE _ => false
  | _ => Crash.impossible"is_vcc on non-constructed type"

  fun type_from_scheme scheme = case scheme of
    DataTypes.SCHEME(_, the_type) => the_type
  | DataTypes.UNBOUND_SCHEME the_type => the_type
  | _ => Crash.impossible"OVERLOADED_SCHEME"

  fun get_no_cons ty = length(Map.domain(get_valenv(get_cons_type ty)))

  fun get_no_vcc_cons ty =
    Lists.filter_length (is_vcc o type_from_scheme)
    (Map.range(get_valenv(get_cons_type ty)))

  fun get_no_null_cons ty =
    Lists.filter_length (not o is_vcc o type_from_scheme)
    (Map.range(get_valenv(get_cons_type ty)))

d515 3
a517 2
	  if is_vcc ty then
	  let val new_lv = LambdaTypes.new_LVar()
d520 1
a520 1
	      if get_no_cons ty > 1 then
d531 3
a533 2
	if is_vcc ty then
	let val lv = LambdaTypes.new_LVar()
d612 1
a612 1
	      if get_no_null_cons ty > 1 then
d617 1
a617 1
	      if get_no_vcc_cons ty > 0 then
d811 2
a812 1
	      (case type_from_scheme(Map.lookup(valid, type_val_env)) of
d834 1
a834 1
	  if get_no_cons ty = 1 then
d877 1
a877 1
		  if length nullary_list = get_no_null_cons ty then
d879 1
a879 1
		  else def_lambda, if get_no_vcc_cons ty = 0 then
d883 1
a883 1
	    if length vcc_lv_list = 1 andalso get_no_vcc_cons ty = 1 then
d903 1
a903 1
	      if length vcc_lv_list = get_no_vcc_cons ty then
d1045 2
a1046 1
                      if get_no_null_cons(!ty) = 1 then LambdaTypes.ABSENT
d1048 1
a1048 1
			if get_no_vcc_cons(!ty) = 0 then LambdaTypes.ABSENT
d1083 1
a1083 1
	    if get_no_cons ty = 1 then
d1095 2
a1096 1
		    if get_no_null_cons(ty) = 0 then LambdaTypes.ABSENT
d1103 1
a1103 1
			    if get_no_vcc_cons ty <> 1 then
d1258 1
a1258 1
		 LambdaTypes.LET(l2, if is_vcc ty then
@


1.54
log
@Changed LETREC to use new RECLET binding (much simpler)
@
text
@d4 3
d65 7
a77 5
require "../utils/integer";
require "../utils/lists";
require "../utils/crash";
require "../utils/map";
require "../utils/set";
d98 7
a111 5
  structure Lists : LISTS
  structure Crash : CRASH
  structure Integer : INTEGER
  structure Map: MAP
  structure Set: SET
d141 1
d146 2
a167 4
  fun foldleft f (e, xs) = Lists.foldl (fn x => (fn y => f(x, y))) e xs

  fun foldright f (xs, e) = Lists.foldr	(fn x => (fn y => f(x, y))) e xs

d192 1
a192 1
  fun env_from_list env_list = foldleft Environ.augment_env
d466 1
a466 1
      Ident.LONGVALID(_, valid as Ident.VAR sy) =>
d468 3
d473 3
a475 6
(*	val _ = if is_ol then
          print("Overloaded operator " ^ sy_name ^
		" with type " ^ name)
		else () *)
	val _ = if (is_ol <> Environ.is_overloaded_op valid) then
	  print("Overload clash on " ^ sy_name)
d477 10
d651 1
a651 1
	val _ = print"Exception match tree is"
d663 1
a663 1
	val _ = print"Match tree is"
d741 1
a741 1
    fun remove_both((label, _), LambdaUtils.LABELS labels) =
d749 1
a749 1
      foldleft remove_both (all_labels, ref_labels)
d766 2
a767 1
        foldleft LambdaUtils.add_label_env
d777 2
a778 3
	    do_leaf(tl, Environ.add_valid_env((valid,
              EnvironTypes.LAMB(LambdaUtils.lookup_match(mv, match_env))),
                env))
d932 1
a932 1
	  val new_env = foldright LambdaUtils.add_match_env
d1040 2
a1041 2
	      Ident.NOPATH => (Environ.add_valid_env((valid,
		EnvironTypes.LAMB(lambda_var)), Environ.empty_env), [])
d1084 2
a1085 1
	    (env_from_list env_list, foldleft op @@ ([], lambda_list_list'))
d1135 3
a1137 2
	      (Environ.add_valid_env((valid, EnvironTypes.LAMB(lambda_var)),
		 env), lambda)
d1213 2
a1214 1
	(env_from_list (map #1 e_l_list), foldleft op @@ ([], map #2 e_l_list))
d1242 4
a1245 5
	      Environ.add_exn_env((v, EnvironTypes.LAMB l1),
				  Environ.add_valid_env
				  ((new_v,
				    EnvironTypes.LAMB l2),
				   Environ.empty_env))
d1323 3
a1325 3
	   val new_v_env = foldleft
	     (fn ((v, _, l), env) =>
	       Environ.add_valid_env((v, EnvironTypes.LAMB(l)), env))
d1327 3
a1329 3
	   val new_e_env = foldleft
	     (fn ((e, _, l), env) =>
	       Environ.add_exn_env((e, EnvironTypes.LAMB(l)), env))
d1331 3
a1333 3
	   val new_s_env = foldleft
	     (fn ((s, (e, c), l), env) =>
	       Environ.add_strid_env((s, (e, EnvironTypes.LAMB(l))), env))
d1392 1
a1392 1
      (foldleft (fn(x, y) => x andalso y)
d1442 5
a1446 3
      val env = foldleft Environ.add_exn_env(
	foldleft Environ.add_valid_env(
	  foldleft Environ.add_strid_env(Environ.empty_env,
d1501 12
a1512 6
    EnvironTypes.TOP_ENV(
      foldleft Environ.add_strid_env
        (foldleft Environ.add_exn_env
	  (foldleft Environ.add_valid_env (Environ.empty_env, v_field),
	    e_field), s_field),
      foldleft Environ.add_funid_env (Environ.empty_fun_env, f_field))
d1610 2
a1611 2
	(Environ.add_strid_env((strid,
	  (str_env, EnvironTypes.LAMB lambda_var)), Environ.empty_env),
d1666 2
a1667 2
	      make_top_env(Environ.add_strid_env((strid,
		(env, EnvironTypes.LAMB lvar)), Environ.empty_env)))),
d1672 2
a1673 3
          Environ.add_funid_env((funid,
	    (EnvironTypes.LAMB lambda_var, interface, str_env)),
	      Environ.empty_fun_env)),
@


1.53
log
@Changed trans_topdec and complete_struct_from_topenv to use new
binding type
@
text
@d4 4
d1144 1
a1144 1
	    (* The exps parts resulting from this should be null *)
d1146 2
d1149 1
a1149 1
	      ((fn exp => trans_exp(exp, Environ.augment_env(envir, all_env)))
d1151 1
a1166 63

(* Done in Lambda Optimiser Now!

	    fun reduce_letrec(arg as (lv_list, le_list, lambda_exp)) =
	    let val lv_set = Set.list_to_set lv_list
	      fun refs le =
		Set.intersection(#2 (LambdaSub.bounds_and_frees le), lv_set)
	      fun lv_refs_from_lv([], _, _) = Crash.impossible"lv_refs_from_lv"
	      | lv_refs_from_lv(_, [], _) = Crash.impossible"lv_refs_from_lv"
	      | lv_refs_from_lv(lv' :: lv_tl, lv_refs :: lv_refs_tl, lv) =
		if lv = lv' then lv_refs else lv_refs_from_lv(lv_tl, lv_refs_tl, lv)
	      val lv_refs = map refs le_list
	      fun trans_refs lvar_set =
	      let
		val lv_refs_list =
		  map (fn lv => lv_refs_from_lv(lv_list, lv_refs, lv))
		    (Set.set_to_list lvar_set)
		val new_lvar_set =
		  foldleft Set.union (lvar_set, lv_refs_list)
	      in
		if Set.seteq(lvar_set, new_lvar_set) then lvar_set
		else trans_refs new_lvar_set
	      end
	      val refs_list = map (trans_refs o Set.singleton) lv_list
	      fun finish_letrec(lv_list, le_list, lambda_exp) =
		(* Remove recursion where possible *)
		case (lv_list, le_list) of
		  ([lv], [le]) =>
		    if Set.is_member(lv, #2 (LambdaSub.bounds_and_frees le))
		      then
			LambdaTypes.LETREC(lv_list, le_list, lambda_exp)
		    else
		      LambdaTypes.do_binding((lv, le), lambda_exp)
		| _ => LambdaTypes.LETREC(lv_list, le_list, lambda_exp)
	      fun reduce [] = finish_letrec arg
	      | reduce (ref_hd :: ref_tl) =
		if Set.seteq(ref_hd, lv_set) then
		  reduce ref_tl
		else
		  let fun new_lists lv_le_list = 
		    let
		      val in_lv_le_list =
			Lists.filterp (fn (lv, _) => Set.is_member(lv, ref_hd))
			lv_le_list
		      val out_lv_le_list =
			Lists.filterp
			(fn (lv, _) => not(Set.is_member(lv, ref_hd)))
			lv_le_list
		    in
		      (in_lv_le_list, out_lv_le_list)
		    end
		  in
		    let val (in_list, out_list) =
		      new_lists(Lists.zip(lv_list, le_list))
		    in
		      reduce_letrec(map #1 in_list, map #2 in_list,
			reduce_letrec(map #1 out_list, map #2 out_list,
			  lambda_exp))
		    end
		  end
	    in
	      reduce refs_list
	    end 
a1167 1

d1169 4
a1172 1
	    (new_env, LambdaTypes.LET(letrec_lambda,
d1179 1
@


1.52
log
@Altered exception form to be STRUCT[unique, string name]
@
text
@d4 3
d432 2
a433 3
  fun let_lambdas_in_exp(lv_le_list, lambda_exp) = foldright
    (fn ((lv, le), lexp) => LambdaTypes.APP(LambdaTypes.FN(lv, lexp), le))
       (lv_le_list, lambda_exp)
d548 1
a548 1
	let_lambdas_in_exp(map (fn x => (#2(#1 x), #2 x))
d559 2
a560 1
      let val (env', lambda_list) = trans_dec (decl, env)
d745 1
a745 1
      (map (fn (_, lv, le) => (lv, le)) lab_lv_le_list,
d836 1
a836 1
		  let_lambdas_in_exp([(new_lv,
d840 1
a840 1
			  LambdaTypes.VAR orig_lv))],
d878 1
a878 1
		let_lambdas_in_exp([(lv, new_le)],
d885 1
a885 1
	    let_lambdas_in_exp([(new_lv, new_le)],
d897 1
a897 1
	    let_lambdas_in_exp((new_lv, new_le) :: lv_le_list,
d916 4
a919 1
		 (lv, LambdaTypes.SELECT(record_label_offset(lab, ty), le)))
d991 3
a993 1
	fun trans_individual_dec(pattern, lambda_var) = case pattern of
d1012 2
a1013 1
	      [(dummy_lv, LambdaTypes.SWITCH(LambdaTypes.VAR lambda_var,
d1029 1
a1029 1
		[(dummy_lv,
d1060 2
a1061 1
	      (Lists.zip(map (fn (_, lv, le) => (lv, le)) big_list,
d1079 1
a1079 1
		(new_env, (new_lv,
d1100 1
a1100 1
	      (new_env, (new_lv,
d1111 2
a1112 1
	    let val (env, lambda) = trans_individual_dec(pat, lambda_var)
d1121 2
a1122 1
	  let val lvar = LambdaTypes.new_LVar()
d1129 1
a1129 1
	      (lvar, lambda) :: more_lambda @@ rest_lambda)
d1133 2
a1134 1
          let val lv_pat_exp_list = map
d1159 1
a1159 1
	    val lv_le_list = lv_le_list_fn size
d1192 1
a1192 1
		      let_lambdas_in_exp([(lv, le)], lambda_exp)
d1226 1
a1226 1
	    (new_env, (letrec_lambda,
d1299 2
a1300 2
		[(l1, lambda_exp),
		 (l2, if is_vcc ty then
d1349 3
a1351 2
	 let val (EnvironTypes.ENV(valid_env, exn_env, strid_env), lambda_exp) =
	   cg_longstrid(longstrid, env)
d1372 1
a1372 1
	       (l, LambdaTypes.SELECT(field, lambda_exp))
d1377 1
a1377 1
	       (l, LambdaTypes.SELECT(field, lambda_exp))
d1485 2
a1486 1
        (lv, LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var))
d1490 2
a1491 1
        (lv, LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var))
d1496 1
a1496 1
          (lv, let_lambdas_in_exp([(lv', le)],
d1582 3
a1584 1
	  (new_env', let_lambdas_in_exp([(new_lv, lambda_exp)], new_lambda'))
d1639 1
a1639 1
	    [(lambda_var, lambda_exp)])
d1702 1
a1702 1
	  [(lambda_var, LambdaTypes.FN(lvar, lambda_exp))])
@


1.51
log
@Removed processing of REQUIRE, it should never get this far
@
text
@d3 4
a6 1
$Log:	_lambda.sml,v $
d131 3
a178 15
(*
  fun cg_prim chars =
    case Environ.lookup_valid(Ident.VAR(Symbol.find_symbol chars),
      Primitives.initial_env) of
      EnvironTypes.PRIM prim => prim
| _ => Crash.impossible ("cg_prim fails to find " ^ chars

  val prims = [("o", ocode), ("not", notcode)]

  val inline_map =
    foldleft (fn (x, y) => Map.add(x, y, LambdaTypes.Prim_order))
    (Map.empty_map,
      map (fn (x, y) => (cg_prim x, y)) prims)
*)

a829 5
(*
		val _ = if Environ.Builtin_p(name, env) then
		  print("Builtin " ^ DataTypes.IdentPrint.printLongValId name)
		  else ()
*)
d895 1
a895 1
	      LambdaTypes.SWITCH(get_con_field,
d897 2
a898 1
		    (LambdaTypes.EXP_TAG(cg_longexid(longvalid, val_env)),
d903 1
a903 4
(*
		    LambdaTypes.PRESENT excp,
*)
	    LambdaTypes.ABSENT))
d1239 1
a1239 1
      (* Generate a lambda l1 bound to APP(ref, unit). This goes in the
d1244 2
a1245 1
      let fun do_exn [] = (Environ.empty_env, [])
d1247 56
a1302 46
	let val l1 = LambdaTypes.new_LVar()
	  val l2 = LambdaTypes.new_LVar()
	  val (rest_env, rest_lambda) = do_exn rest
	  val (v, ty) = case ex of
	    Absyn.NEWexbind((v, ref ty), _) => (v, ty)
	  | Absyn.OLDexbind((v, ref ty), longv) => (v, ty)
	  val new_v =
	    Ident.VAR(case v of
	      Ident.EXCON x => x
	    | _ => Crash.impossible"ExId is not EXCON")
	  val (this_env, this_lambda) =
	    (Environ.add_exn_env((v, EnvironTypes.LAMB l1),
	      Environ.add_valid_env((new_v, EnvironTypes.LAMB l2),
		Environ.empty_env)),
	    let val lambda_exp =
	      case ex of
		Absyn.NEWexbind _ =>
(*		let val unique_fn =
		  case Environ.lookup_valid
		    (Ident.VAR(Symbol.find_symbol"_make_new_unique"), envir) of
		    EnvironTypes.PRIM unique_fn => unique_fn
		  | _ => Crash.impossible"cg_longexid"
		in
		  LambdaTypes.APP(LambdaTypes.BUILTIN unique_fn,
				  LambdaTypes.STRUCT[])
		end
*)
		  LambdaTypes.APP(LambdaTypes.BUILTIN Pervasives.REF,
				  LambdaTypes.STRUCT[])

	      | Absyn.OLDexbind(_, longv) => cg_longexid(longv, envir)
	    in
	      [(l1, lambda_exp), (l2, if is_vcc ty then
		let val l3 = LambdaTypes.new_LVar()
		in
		  LambdaTypes.FN(l3,
		    LambdaTypes.STRUCT(
		      [LambdaTypes.VAR l1, LambdaTypes.VAR l3]))
		end
	      else
		LambdaTypes.STRUCT([LambdaTypes.VAR l1,
				    LambdaTypes.STRUCT []]))]
	    end)
	in
	  (Environ.augment_env(this_env, rest_env), this_lambda @@ rest_lambda)
	end
@


1.50
log
@Changed the way that exception uniques are generated to be an
application of REF to unit rather than a special pervasive.  This
allows us to compile the pervasive library itself, but may need
further work.
@
text
@d4 6
d1718 1
a1718 1
	Crash.unimplemented "REQUIREtopdec"
@


1.49
log
@Changed Match_Utils.Qsort to Lists.qsort
@
text
@d4 3
d1249 1
a1249 1
      (* Generate a lambda l1 bound to APP(_make_new_unique). This goes in the
d1273 1
a1273 1
		let val unique_fn =
d1282 4
@


1.48
log
@Improved cg_longexid and cg_longstrid to allow generation to primitives
@
text
@d4 3
a53 1
require "../match/match_utils";
a85 1
  structure Match_Utils : MATCH_UTILS
d549 1
a549 1
	      (Match_Utils.Qsort known_order lvar_lab_list)))
d1401 1
a1401 1
      (Match_Utils.Qsort op = list1) = (Match_Utils.Qsort op = list2)
d1417 1
a1417 1
      val v_a_list = Match_Utils.Qsort v_order (Map.assoc v_map)
d1422 1
a1422 1
	 (v_a_list, Match_Utils.Qsort Ident.valid_order v_list), 0,
d1424 1
a1424 1
      val e_a_list = Match_Utils.Qsort v_order (Map.assoc e_map)
d1429 1
a1429 1
	 (e_a_list, Match_Utils.Qsort Ident.valid_order e_list), next1,
d1431 1
a1431 1
      val s_a_list = Match_Utils.Qsort s_order (Map.assoc s_map)
d1433 1
a1433 1
      val ordered_int_map = Match_Utils.Qsort s_order (Map.assoc s_int_map)
@


1.47
log
@Caused the Bind and Match exceptions to use the pervasived directly
rather than trying to look up the current definitions in the environment.
@
text
@d4 4
d368 1
a368 1
       | _ => Crash.impossible "cg_longvalid does not give LVar")
d385 1
a385 1
       | _ => Crash.impossible "cg_longexid does not give LVar")
a389 3
      val field = case Environ.lookup_exn(exid, env') of
	EnvironTypes.FIELD field => field
      | _ => Crash.impossible "cg_longexid fails to get field"
d391 4
a394 1
      LambdaTypes.SELECT(field, lambda)
d401 2
a402 1
       | _ => Crash.impossible "cg_longstrid does not give LVar")
a406 3
      val (env'', field) = case Environ.lookup_strid(strid, env') of
	(env''', EnvironTypes.FIELD field) => (env''', field)
      | _ => Crash.impossible "cg_longstrid fails to get field"
d408 6
a413 1
      (env'', LambdaTypes.SELECT(field, lambda))
@


1.46
log
@Fixed get_lamb_env to allow Primitive structure heads for library
@
text
@d4 3
d700 2
a701 10
	let
	  val exprim =
	    case Environ.lookup_exn(Ident.EXCON(Symbol.find_symbol "Match"),
				    env) of
	      EnvironTypes.PRIM prim => prim
	    | _ => Crash.impossible "Failed to lookup match"
	in
	  LambdaTypes.RAISE(LambdaTypes.STRUCT(
	    [LambdaTypes.BUILTIN exprim, LambdaTypes.STRUCT []]))
	end
d976 1
a976 4
  let val exprim = case Environ.lookup_exn(
    Ident.EXCON(Symbol.find_symbol "Bind"), envir) of
      EnvironTypes.PRIM prim => prim
    | _ => Crash.impossible "Failed to lookup bind"
d979 1
a979 1
	[LambdaTypes.BUILTIN exprim, LambdaTypes.STRUCT []])))
@


1.45
log
@Allowed translation of final component of a longvalid to a primitive,
to allow creation of library
@
text
@d4 4
d335 2
a336 3
  let val (env', lvar) = case Environ.lookup_strid(strid, env) of
    (env'', EnvironTypes.LAMB lvar) => (env'', lvar)
  | _ => Crash.impossible "get_lamb_env does not give LVar"
d338 4
a341 1
    (env', LambdaTypes.VAR lvar)
@


1.44
log
@Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.
@
text
@d4 4
a359 3
      val field = case Environ.lookup_valid(valid, env') of
	EnvironTypes.FIELD field => field
      | _ => Crash.impossible "cg_longvalid fails to get field"
d361 4
a364 1
      LambdaTypes.SELECT(field, lambda)
@


1.43
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d4 3
a21 134
Revision 1.38  91/10/01  15:52:23  jont
Allowed multiple META_OVERLOADED when determining the types of
overloaded operators

Revision 1.37  91/09/24  11:42:38  jont
Fixed bug whereby defaults when matching exceptions automatically
raised Match rather than using the given default from the tree.

Revision 1.36  91/09/16  16:54:15  jont
Corrected spelling of _make_new_unique

Revision 1.35  91/09/11  12:25:22  davida
Removed printing of overloaded operator messages, as
big compilations can produce loads.

Revision 1.34  91/09/11  11:37:41  davida
Commented out code to do dependency analysis & recursion
removal on LETREC's.  The lambda-optimiser does it instead
now, since optimisation can introduce removable LETREC's.

Revision 1.33  91/09/11  09:44:02  jont
Fixed bug whereby all binary functions were considered commutative

Revision 1.32  91/09/04  14:34:05  jont
Added special cases for equality where one argument is a constructor
tag, to avoid code generating polymorphic equality, and to ensure
no redundant code is generated in the special cases of no value
carrying constructors and only one nullary constructor

Revision 1.31  91/08/23  11:51:56  jont
Changed to use pervasives

Revision 1.30  91/08/13  16:28:04  jont
Changed set_of_lvars for bounds_and_frees

Revision 1.29  91/08/09  14:47:57  jont
Added code for inline functions (currently only not and o)

Revision 1.28  91/08/07  16:58:55  jont
Added recognition of equality on special constants for ease of production
of code in these cases.

Revision 1.27  91/07/29  12:24:18  jont
Improved handling of LETRECs to quadratic algorithm by only evaluating
the free lambdas in the bodies once per body.
Fixed a bug in ref pattern matching, so that fun foo(ref x)
applies ! to its arg to yield x. This is a nasty special case,
is there a better (general purpose) way of getting this right.

Revision 1.26  91/07/24  09:57:50  jont
Stopped using IdentPrint inside overloaded operators

Revision 1.25  91/07/23  12:40:42  jont
Fixed bug in exceptiondec whereby exception's were entered in the value
environment as EXCONs rather than as VARs

Revision 1.24  91/07/22  13:27:16  jont
Moved some general purpose functions out into lambdasub
Fixed bug in cg_longexid on builtin exceptions

Revision 1.23  91/07/17  10:28:18  jont
Added dependency analysis for LETRECs

Revision 1.22  91/07/16  14:50:17  jont
Added HANDLE for exceptions

Revision 1.21  91/07/15  14:18:22  jont
Added exception and raise

Revision 1.20  91/07/12  18:12:26  jont
Completed functors. Redid trans_str_exp to return packaged structure
Redid to use exception environment as well

Revision 1.19  91/07/12  13:32:26  jont
Completed functor application. Changed trans_str_exp to return
tupled up structs

Revision 1.18  91/07/12  10:19:15  jont
Fixed bug in match compilation to ensure trees at lebale are translated
into function applications.
Almost finished functor application, but about to rearrange things so
that trans_str_exp returns an env and an expression

Revision 1.17  91/07/11  19:50:42  jont
More work on functor application

Revision 1.16  91/07/11  11:46:07  jont
Updated LETREC stuff

Revision 1.15  91/07/10  11:46:05  jont
Updated for new top level

Revision 1.14  91/07/09  15:43:26  jont
Started on functor application

Revision 1.13  91/07/09  14:42:04  jont
Added functor definition compilation

Revision 1.12  91/07/08  17:58:43  jont
Added trans_fun_dec to translate functors. No body as yet.

Revision 1.11  91/07/05  17:03:20  jont
Added structure thinning and overloaded primitives

Revision 1.10  91/06/27  12:47:13  jont
Handled datatype declarations correctly as in 2.7 of the commentary

Revision 1.9  91/06/26  20:38:31  jont
Added recursive function handling, as far as LETREC

Revision 1.8  91/06/25  17:29:53  jont
Completed trans_str_dec, and all of trans_str_exp barring functor
application. Added trans_top_dec as the only external interface.
Now about to split the functor, as NJML won't currently compile it

Revision 1.7  91/06/25  12:46:14  jont
completed match translator barring exception constructors

Revision 1.6  91/06/21  18:59:58  jont
Started on match compiler. Did all but Labels and Gotos

Revision 1.5  91/06/21  13:45:31  jont
Completed all value patterns. Started on match compilation

Revision 1.4  91/06/19  18:01:00  jont
Finished patterns in VALdec. Did some work on module stuff,
translating structures. Started on match compilation

Revision 1.3  91/06/17  15:00:00  jont
Added some structure handling (trans_str_dec, trans_str_exp)

Revision 1.2  91/06/12  19:06:00  jont
Reorganised patterns in value declarations. Handled RECORDpats

d93 1
a93 1
  sharing LambdaUtils.LambdaTypes = LambdaTypes = LambdaSub.LambdaTypes =
a1406 4
(*
      val _ = print("Env = " ^ EnvironPrint.printenv env)
      val _ = print("Interface = " ^ EnvironPrint.printenv(Environ.make_env_from_interface inte))
*)
a1408 7
(*
      val _ = print"v_a_list = "
      val _ = map (fn (x, _) => print(DataTypes.IdentPrint.printValId x ^ "\n")) v_a_list
      val _ = print"v_list = "
      val _ = map (fn x => print(DataTypes.IdentPrint.printValId x ^ "\n")) (Match_Utils.Qsort Ident.valid_order v_list)
      val _ = print"Filtering value env"
*)
@


1.42
log
@Changed is_overloaded so that it works properly (this function will
probably change quite soon but this is just to get the code generator
up and running again).
@
text
@d4 5
d164 1
d196 1
d234 8
a241 1
  exception impossible = LambdaTypes.impossible
d282 1
a282 1
			      Primitives.initial_env) of
d284 1
a284 1
    | _ => raise(impossible ("cg_prim fails to find " ^ chars))
d297 1
a297 1
  fun position (target, domain, error_to_raise) =
d300 4
a303 6
      if target = head then
	n
      else
	position' (tail, n+1)
    | position' ([], _) =
      raise error_to_raise
d309 3
a311 3
    DataTypes.TYNAME(_, _, _, _, ref (DataTypes.VE(_, valenv))))) = valenv
  | get_valenv(_) =
    raise(impossible"bad ty in get_valenv")
d331 1
a331 1
	raise (impossible "constructor_tag(1)")
d336 1
a336 1
    | domain _ = raise (impossible "constructor_tag(2)")
d339 4
a342 4
    position (valid, domain constype,
      (impossible ("constructor_tag(3): "
      ^ Types.print_type ty ^ "," 
      ^ DataTypes.IdentPrint.printValId valid)))
d367 1
a367 1
	  raise (impossible ("record_tag(2)" ^ type_string))
d371 1
a371 1
    {index = position (lab, record_domain, impossible "record_tag(1)"),
d393 1
a393 1
  | _ => raise(impossible"get_cons_type on non-constructed type")
d398 1
a398 1
  | _ => raise(impossible"is_vcc on non-constructed type")
d403 1
a403 1
  | _ => raise(impossible"OVERLOADED_SCHEME")
d460 1
a460 1
  | _ => raise(impossible "get_lamb_env does not give LVar")
d468 1
a468 1
  | _ => raise(impossible "get_field_env fails to get field")
d482 1
a482 1
       | _ => raise(impossible "cg_longvalid does not give LVar"))
d489 1
a489 1
      | _ => raise(impossible "cg_longvalid fails to get field")
d499 1
a499 1
       | _ => raise(impossible "cg_longexid does not give LVar"))
d506 1
a506 1
      | _ => raise(impossible "cg_longexid fails to get field")
d515 1
a515 1
       | _ => raise(impossible "cg_longstrid does not give LVar"))
d522 1
a522 1
      | _ => raise(impossible "cg_longstrid fails to get field")
d700 10
a709 10
	if is_poly andalso good_arg
	  then
	    let
	      val (exp_arg, tag) = case new_arg of
		LambdaTypes.STRUCT[LambdaTypes.INT tag, le] => (le, tag)
	      | _ => raise(LambdaTypes.impossible"Bad polyeq arg")   
	      val ty = case absyn of
		Absyn.VALexp(_, ref ty) => ty
	      | _ => raise(LambdaTypes.impossible"Non-val generates poly eq")
	      val def1 = if get_no_null_cons ty > 1 then
d711 4
a714 3
		else
		  LambdaTypes.ABSENT
	      val def2 = if get_no_vcc_cons ty > 0 then
d716 8
a723 7
		else
		  LambdaTypes.ABSENT
	    in
	      LambdaTypes.SWITCH(exp_arg,
				 [(LambdaTypes.CON_TAG tag, true_val)],
				 def1, def2)
	    end
d756 2
a757 2
    | Absyn.TEN15exp (_) =>
      raise(impossible("TEN15exp found"))
d823 1
a823 1
	    | _ => raise(impossible("Failed to lookup match"))
d858 1
a858 1
      | _ => raise(impossible"trans_node(1)")) lab_tree_list
d912 1
a912 1
	  | _ => raise(impossible"Match.CONS bad arg")
d919 1
a919 1
	    | Ident.VAR _ => raise(impossible"VAR in match CONS")
d943 1
a943 1
	      | _ => raise(impossible"list size")
d946 1
a946 1
		| _ => raise(impossible"list size")
d976 1
a976 1
	      | _ => raise(impossible"list size")
d996 1
a996 1
	      | _ => raise(impossible"list length")
d1105 1
a1105 1
    | _ => raise(impossible("Failed to lookup bind"))
d1141 2
a1142 2
	    | Ident.PATH(_) => raise(impossible
	      "Long valid with non-empty path to trans_dec"))
d1158 2
a1159 2
	  | Ident.EXCON excon => raise(
	    impossible"VALpat(Ident.EXCON)"))
d1186 1
a1186 1
	    raise(impossible"APPpat of Ident.VAR")
d1234 1
a1234 2
	  | _ => raise(
	    impossible"LAYEREDpat with non-VAR valid"))
d1268 1
a1268 1
		raise(impossible"non-trivial lhs in letrec"))
d1282 2
a1283 2
	      fun lv_refs_from_lv([], _, _) = raise(impossible"lv_refs_from_lv")
	      | lv_refs_from_lv(_, [], _) = raise(impossible"lv_refs_from_lv")
d1356 1
a1356 1
	  | munge _ = raise(impossible"Absyn.DATATYPE")
d1383 1
a1383 1
	    | _ => raise(impossible"ExId is not EXCON"))
d1395 1
a1395 1
		  | _ => raise(impossible"cg_longexid")
d1472 1
a1472 1
	     | _ => raise(impossible"Absyn.OPENdec(1)")
d1477 1
a1477 1
	     | _ => raise(impossible"Absyn.OPENdec(2)")
d1553 1
a1553 1
	(LambdaSub.filter_ordered_map
d1560 1
a1560 1
	(LambdaSub.filter_ordered_map
d1568 1
a1568 1
	(LambdaSub.filter_ordered_map
d1596 1
a1596 1
		      | _ => raise(impossible"c_s_w_i(1)"))
d1600 1
a1600 1
		      | _ => raise(impossible"c_s_w_i(2)"))
d1606 4
a1609 2
	  | ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) => raise(impossible"c_s_w_i (3) LAMB")
	  | ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) => raise(impossible"c_s_w_i (4) PRIM"))
d1662 1
a1662 1
            | _ => raise(impossible"comp_st(1)")) valids) @@
d1664 1
a1664 1
            | _ => raise(impossible"comp_st(1)")) exns) @@
d1666 1
a1666 1
            | _ => raise(impossible"comp_st(1)")) strids) @@
d1668 1
a1668 1
            | _ => raise(impossible"comp_st(1)")) funids)
d1711 2
a1712 2
      | EnvironTypes.PRIM _ => raise(impossible"APPstrexp(1)")
      | EnvironTypes.FIELD _ => raise(impossible"APPstrexp(2)")
d1825 14
a1838 13
  case topdec of
    Absyn.STRDECtopdec strdec =>
    let val (new_env, lambdas) = trans_str_dec(strdec, top_env)
    in
      (make_top_env new_env, lambdas)
    end
  | Absyn.SIGNATUREtopdec _ => (make_top_env Environ.empty_env, [])
  | Absyn.FUNCTORtopdec funbind_list =>
    trans_fun_dec_list(funbind_list, top_env)
  | Absyn.REQUIREtopdec require =>
    raise(LambdaTypes.not_done_yet "REQUIREtopdec")

end   (* of functor Lambda *)
@


1.41
log
@Modified overloaded operator detection
@
text
@d4 3
d410 1
a410 1
	(case Types.the_type h of
@


1.40
log
@General tidy up, Made changes due to record selection now requiring
the total size of the record to be present as well as the index.
@
text
@d4 4
d405 9
a413 6
    (case hd(Map.range record_map) of
      DataTypes.META_OVERLOADED(ref ty) =>
      (case Types.the_type ty of
	DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
      | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
      | _ => (false, ""))
d423 8
a430 6
    (case Types.the_type(hd(Map.range record_map)) of
      DataTypes.CONSTYPE(_, DataTypes.TYNAME{2=s,...}) => (true, s)
    | DataTypes.CONSTYPE(_, DataTypes.METATYNAME{2=s,...}) => (true, s)
    | _ => (false, "")
)
  | domain_type_name _ = (false, "Not fun(rec)")
@


1.39
log
@Changed use of lambdasub.number_from to lists.number_from_by_one
@
text
@d4 3
d241 1
a241 1
	LambdaTypes.SELECT(LambdaTypes.toField 0, LambdaTypes.VAR l1),
d243 1
a243 1
	    LambdaTypes.SELECT(LambdaTypes.toField 1, LambdaTypes.VAR l1),
d333 1
a333 2

(** extract the domain map for a record type **)
d335 16
a350 13
    | domain (DataTypes.METARECTYPE(ref(_, _, ty, _, _))) = domain(ty)
    | domain (the_type) = let val type_string = case the_type of
        DataTypes.METATYVAR(_) => "METATYVAR"
      | DataTypes.META_OVERLOADED(_) => "META_OVERLOADED"
      | DataTypes.TYVAR(_) => "TYVAR"
      | DataTypes.FUNTYPE(_) => "FUNTYPE"
      | DataTypes.CONSTYPE(_) => "CONSTYPE"
      | DataTypes.DEBRUIJN(_) => "DEBRUIJN"
      | DataTypes.NULLTYPE => "NULLTYPE"
      | _ => "Completely impossible"
    in
      raise (impossible ("record_tag(2)" ^ type_string))
    end
d352 2
a353 1
    position (lab, domain the_type, impossible "record_tag(1)")
d389 2
a390 2
    LambdaSub.filter_length(Map.range(get_valenv(get_cons_type ty)),
    is_vcc o type_from_scheme)
d393 2
a394 2
    LambdaSub.filter_length(Map.range(get_valenv(get_cons_type ty)),
    not o is_vcc o type_from_scheme)
d423 10
d807 3
a809 2
    val ref_labels = LambdaSub.filter(Map.assoc(labels),
      fn (LambdaUtils.LABEL _, _) => false | _ => true)
d896 3
a898 2
	  val nullary_list = LambdaSub.filter(longvalid_mv_tree_list,
	    fn(v, _, _) => not(has_value v))
d900 2
a901 1
	  val new_le = LambdaTypes.SELECT(LambdaTypes.toField 1, lv_e)
d903 1
a903 1
	    LambdaSub.filter(longvalid_mv_tree_list, has_value o #1)
d981 1
a981 1
	    LambdaTypes.SWITCH(LambdaTypes.SELECT(LambdaTypes.toField 0, lv_e),
d992 1
a992 2
	      LambdaTypes.SWITCH(
	        LambdaTypes.SELECT(LambdaTypes.toField 0, lv_e),
d1010 4
a1013 3
	  val lv_le_list = map (fn (lab, _, lv) =>
            (lv, LambdaTypes.SELECT(LambdaTypes.toField(
              record_label_offset(lab, ty)), le))) lab_mv_lv_list
d1136 7
a1142 4
	  let val big_list = map (fn (lab, pat) => (pat,
	    LambdaTypes.new_LVar(), LambdaTypes.SELECT(
              LambdaTypes.toField(record_label_offset(lab, !ty)),
		LambdaTypes.VAR lambda_var))) lab_pat_list
d1177 1
a1177 2
			LambdaTypes.SWITCH(LambdaTypes.SELECT(
			  LambdaTypes.toField 0(*Tag position*), lexp),
d1180 1
a1180 3
			        LambdaTypes.SELECT(
				  LambdaTypes.toField 1(*Val position*),
				    lexp))],
d1193 1
a1193 2
		LambdaTypes.SWITCH(LambdaTypes.SELECT(
		  LambdaTypes.toField 0(*Tag*), lexp),
d1195 1
a1195 1
		      LambdaTypes.SELECT(LambdaTypes.toField 1(*Val*), lexp))],
d1246 4
a1249 4
	    val (lv_le_list, _) =
	      Lists.number_from_by_one(map #1 new_lv_pat_list, 0,
		fn x => LambdaTypes.SELECT(LambdaTypes.toField x,
		  LambdaTypes.VAR letrec_lambda))
a1250 1

d1290 4
a1293 3
		    let val in_lv_le_list =
		      LambdaSub.filter(lv_le_list, fn (lv, _) =>
			Set.is_member(lv, ref_hd))
d1295 3
a1297 2
			LambdaSub.filter(lv_le_list, fn (lv, _) =>
			  not(Set.is_member(lv, ref_hd)))
d1526 5
a1530 4
      val (v_a_f_list, next) = Lists.number_from_by_one(
	LambdaSub.filter_ordered_map(v_a_list, Match_Utils.Qsort Ident.valid_order
          v_list), 0, EnvironTypes.FIELD o LambdaTypes.toField)
      val v_a_f_l_list = map (fn x => (x, LambdaTypes.new_LVar())) v_a_f_list
d1533 5
a1537 7
(*
      val _ = print"Filtering exception env"
*)
      val (e_a_f_list, next) = Lists.number_from_by_one(
	LambdaSub.filter_ordered_map(e_a_list, Match_Utils.Qsort Ident.valid_order
          e_list), next, EnvironTypes.FIELD o LambdaTypes.toField)
      val e_a_f_l_list = map (fn x => (x, LambdaTypes.new_LVar())) e_a_f_list
d1541 14
a1554 8
(*
      val _ = print"Filtering structure env"
*)
      val (s_a_f_list, _) = Lists.number_from_by_one(
	LambdaSub.filter_ordered_map(s_a_list, map #1 ordered_int_map), next,
	  EnvironTypes.FIELD o LambdaTypes.toField)
      val s_a_f_l_list = map (fn x => (x, LambdaTypes.new_LVar(),
        LambdaTypes.new_LVar())) s_a_f_list
d1558 4
a1561 4
      val the_structure_list = (map (fn (_, x) => LambdaTypes.VAR x)
	  v_a_f_l_list) @@ (map (fn (_, x) => LambdaTypes.VAR x)
	  e_a_f_l_list) @@ (map (fn (_, x, _) => LambdaTypes.VAR x)
	  s_a_f_l_list)
d1597 17
a1613 12
    val (v_field', next) =
      Lists.number_from_by_one(valids, 0, EnvironTypes.FIELD o LambdaTypes.toField)
    val (e_field', next) =
      Lists.number_from_by_one(exns, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val (s_field', next) =
      Lists.number_from_by_one(strids, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val (f_field', _) =
      Lists.number_from_by_one(funids, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val v_field = map (fn ((vid, _), f) => (vid, f)) v_field'
    val e_field = map (fn ((eid, _), f) => (eid, f)) e_field'
    val s_field = map (fn ((sid, (e, _)), f) => (sid,(e, f))) s_field'
    val f_field = map (fn ((fid, (_, i, e)), f) => (fid,(f, i, e))) f_field'
@


1.38
log
@Allowed multiple META_OVERLOADED when determining the types of
overloaded operators
@
text
@d4 4
d1229 1
a1229 1
	      LambdaSub.number_from(map #1 new_lv_pat_list, 0,
d1507 1
a1507 1
      val (v_a_f_list, next) = LambdaSub.number_from(
d1516 1
a1516 1
      val (e_a_f_list, next) = LambdaSub.number_from(
d1526 1
a1526 1
      val (s_a_f_list, _) = LambdaSub.number_from(
d1574 1
a1574 1
      LambdaSub.number_from(valids, 0, EnvironTypes.FIELD o LambdaTypes.toField)
d1576 1
a1576 1
      LambdaSub.number_from(exns, next, EnvironTypes.FIELD o LambdaTypes.toField)
d1578 1
a1578 1
      LambdaSub.number_from(strids, next, EnvironTypes.FIELD o LambdaTypes.toField)
d1580 1
a1580 1
      LambdaSub.number_from(funids, next, EnvironTypes.FIELD o LambdaTypes.toField)
@


1.37
log
@Fixed bug whereby defaults when matching exceptions automatically
raised Match rather than using the given default from the tree.
@
text
@d4 4
d393 1
a393 1
      (case ty of
d399 1
a399 1
    (case ty of
@


1.36
log
@Corrected spelling of _make_new_unique
@
text
@d4 3
d768 6
a773 4
	let val exprim = case Environ.lookup_exn(
	  Ident.EXCON(Symbol.find_symbol "Match"), env) of
	  EnvironTypes.PRIM prim => prim
	| _ => raise(impossible("Failed to lookup match"))
d775 2
a776 2
	    LambdaTypes.RAISE(LambdaTypes.STRUCT(
	      [LambdaTypes.BUILTIN exprim, LambdaTypes.STRUCT []]))
d972 5
a976 1
		    LambdaTypes.PRESENT excp, LambdaTypes.ABSENT))
@


1.35
log
@Removed printing of overloaded operator messages, as
big compilations can produce loads.
@
text
@d4 4
d143 1
d1332 1
a1332 1
		    (Ident.VAR(Symbol.find_symbol"_make_new_unqiue"), envir) of
@


1.34
log
@Commented out code to do dependency analysis & recursion
removal on LETREC's.  The lambda-optimiser does it instead
now, since optimisation can introduce removable LETREC's.
@
text
@d4 5
d512 1
a512 1
	val _ = if is_ol then
d515 1
a515 1
		else ()
@


1.33
log
@Fixed bug whereby all binary functions were considered commutative
@
text
@d4 3
d1205 4
d1266 3
a1268 1
	    end
d1271 6
a1276 8
	      reduce_letrec(map #1 lv_pat_exp_list, exp_list,
		LambdaTypes.STRUCT(map (LambdaTypes.VAR o #1) lv_pat_exp_list))
		       )
(*
	      LambdaTypes.LETREC(map #1 lv_pat_exp_list, exp_list,
		LambdaTypes.STRUCT(map (LambdaTypes.VAR o #1) lv_pat_exp_list))
*)
		  :: lv_le_list)
@


1.32
log
@Added special cases for equality where one argument is a constructor
tag, to avoid code generating polymorphic equality, and to ensure
no redundant code is generated in the special cases of no value
carrying constructors and only one nullary constructor
@
text
@d4 6
d658 1
a658 1
	else LambdaTypes.APP(fcn, new_arg)
@


1.31
log
@Changed to use pervasives
@
text
@d4 3
d132 1
d159 1
d178 1
a178 1
    Environ.LambdaTypes = Primitives.LambdaTypes
d360 1
a360 1
  (* A function to determine if the given valid is a function application,
a382 11
(*
    | DataTypes.METATYVAR _ => (false, "METATYVAR")
    | DataTypes.META_OVERLOADED _ => (false, "META_OVERLOADED")
    | DataTypes.TYVAR _ => (false, "TYVAR")
    | DataTypes.METARECTYPE _ => (false, "METARECTYPE")
    | DataTypes.RECTYPE _ => (false, "RECTYPE")
    | DataTypes.FUNTYPE _ => (false, "FUNTYPE")
    | DataTypes.CONSTYPE _ => (false, "CONSTYPE")
    | DataTypes.DEBRUIJN _ => (false, "DEBRUIJN")
    | DataTypes.NULLTYPE => (false, "NULLTYPE")
*)
d607 47
a653 3
    | Absyn.APPexp (fun_exp, val_exp) =>
      LambdaTypes.APP (trans_exp (fun_exp, env),
	trans_exp (val_exp, env))
@


1.30
log
@Changed set_of_lvars for bounds_and_frees
@
text
@d4 3
d156 1
d175 1
d220 1
d233 1
d414 4
a417 4
	 if Map.domain_member(prim, inline_map) then
	   (Map.lookup(prim, inline_map)) ()
	 else
	   LambdaTypes.BUILTIN prim
@


1.29
log
@Added code for inline functions (currently only not and o)
@
text
@d4 3
d1153 2
a1154 1
	      fun refs le = Set.intersection(LambdaSub.set_of_lvars le, lv_set)
d1176 3
a1178 2
		    if Set.is_member(lv, LambdaSub.set_of_lvars le) then
		      LambdaTypes.LETREC(lv_list, le_list, lambda_exp)
@


1.28
log
@Added recognition of equality on special constants for ease of production
of code in these cases.
@
text
@d4 4
d188 37
d357 5
d403 5
a407 1
       | EnvironTypes.PRIM prim => LambdaTypes.BUILTIN prim
@


1.27
log
@Improved handling of LETRECs to quadratic algorithm by only evaluating
the free lambdas in the bodies once per body.
Fixed a bug in ref pattern matching, so that fun foo(ref x)
applies ! to its arg to yield x. This is a nasty special case,
is there a better (general purpose) way of getting this right.
@
text
@d4 7
d100 2
d111 1
a111 2
require "../typechecker/types";
require "../typechecker/interface";
d127 4
a130 1
functor Lambda (structure DataTypes : DATATYPES
d133 1
a134 1
  structure Environ : ENVIRON
a139 3
  structure Types: TYPES
  structure Interface: INTERFACE
  structure Symbol: SYMBOL
d142 1
d145 1
d152 1
a152 1
  sharing Absyn.Set = Set = LambdaSub.Set
d158 1
a158 1
  sharing Environ.EnvironTypes = EnvironTypes
d162 1
a162 1
    Environ.LambdaTypes
d318 19
d403 7
d451 1
a451 2
      in
	cg_longvalid(
d457 26
d1183 1
a1183 1
      (* Generate a lambda l1 bound to _make_new_unique. This goes in the
d1213 2
a1214 1
		  LambdaTypes.BUILTIN unique_fn
@


1.26
log
@Stopped using IdentPrint inside overloaded operators
@
text
@d4 3
d708 9
d718 7
d726 3
d733 2
a734 1
	         effect on the representation of the value *)
d1040 5
a1044 4
	      fun le_from_lv([], _, _) = raise(impossible"le_from_lv")
	      | le_from_lv(_, [], _) = raise(impossible"le_from_lv")
	      | le_from_lv(lv' :: lv_tl, le' :: le_tl, lv) =
		if lv = lv' then le' else le_from_lv(lv_tl, le_tl, lv)
d1047 2
a1048 2
		val lexp_list =
		  map (fn lv => le_from_lv(lv_list, le_list, lv))
d1051 1
a1051 1
		  foldleft Set.union (lvar_set, map refs lexp_list)
@


1.25
log
@Fixed bug in exceptiondec whereby exception's were entered in the value
environment as EXCONs rather than as VARs
@
text
@d4 4
d401 1
a401 1
      Ident.LONGVALID(_, valid as Ident.VAR _) =>
d404 1
d406 1
a406 1
          print("Overloaded operator " ^ (DataTypes.IdentPrint.printValId valid) ^
d410 1
a410 1
	  print("Overload clash on " ^ (DataTypes.IdentPrint.printValId valid))
d416 1
a416 2
	      Ident.VAR(Symbol.find_symbol(
		"_" ^ name ^ (DataTypes.IdentPrint.printValId valid))))
@


1.24
log
@Moved some general purpose functions out into lambdasub
Fixed bug in cg_longexid on builtin exceptions
@
text
@d4 4
d1107 4
d1113 1
a1113 1
	      Environ.add_valid_env((v, EnvironTypes.LAMB l2),
d1261 1
a1261 1
     (env, LambdaTypes.VAR lambda_var)
d1264 4
d1270 7
d1283 3
d1288 1
a1288 1
          e_list), 0, EnvironTypes.FIELD o LambdaTypes.toField)
d1293 3
@


1.23
log
@Added dependency analysis for LETRECs
@
text
@d4 3
a162 21
  fun filter(f_list, filter_fun) = 
  let
    fun filter_sub([]) = []
    | filter_sub(h :: t) =
    if filter_fun h then h :: (filter_sub t)
    else filter_sub t
  in
    filter_sub f_list
  end

  fun filter_length(filter_list, filter_fun) =
  let fun filter_sub([], n) = n
    | filter_sub(h :: t, n) = filter_sub(t, if filter_fun h then n+1 else n)
  in
    filter_sub(filter_list, 0)
  end

  fun eqset(set1, set2) =
    Set.subset(set1, set2) andalso
      length(Set.set_to_list set1) = length(Set.set_to_list set2)

d276 1
a276 1
    filter_length(Map.range(get_valenv(get_cons_type ty)),
d280 1
a280 1
    filter_length(Map.range(get_valenv(get_cons_type ty)),
d299 1
a299 1
    (env'', EnvironTypes.LAMB(lvar)) => (env'', lvar)
d302 1
a302 1
    (env', LambdaTypes.VAR(lvar))
d316 2
a317 1
	 EnvironTypes.LAMB(lvar) => LambdaTypes.VAR(lvar)
d324 1
a324 1
	EnvironTypes.FIELD(field) => field
d334 1
d350 1
a350 1
	 (env, EnvironTypes.LAMB(lvar)) => (env, LambdaTypes.VAR(lvar))
a371 7
  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end

d393 26
a418 29
        Ident.LONGVALID(_, valid as Ident.VAR _) =>
	let
	  val (is_ol, name) = is_overloaded ty
	  val _ = if is_ol then
	    print("Overloaded operator " ^ (DataTypes.IdentPrint.printValId valid) ^
	      " with type " ^ name)
		  else ()
	  val _ = if (is_ol <> Environ.is_overloaded_op valid) then
	    print("Overload clash on " ^ (DataTypes.IdentPrint.printValId valid))
		  else ()
	  val new_lvalid =
	    if is_ol then
	      Ident.LONGVALID(Ident.NOPATH, 
		Ident.VAR(Symbol.find_symbol(
		  "_" ^ name ^ (DataTypes.IdentPrint.printValId valid))))
	    else longValId
	in
	  if Environ.Builtin_p(new_lvalid, env) then
	    LambdaTypes.BUILTIN(Environ.FindBuiltin(new_lvalid, env))
	  else
	    cg_longvalid(new_lvalid, env)
	end
      | Ident.LONGVALID(_, valid as Ident.CON _) =>
	let
	  val lexp = LambdaTypes.INT(constructor_tag(valid, ty))
	in
	  if Environ.Builtin_p(longValId, env) then
	    LambdaTypes.BUILTIN(Environ.FindBuiltin(longValId, env))
	  else
d420 8
a427 8
	    let val new_lv = LambdaTypes.new_LVar()
	    in
	      LambdaTypes.FN(new_lv,
		if get_no_cons(ty) > 1 then
		  LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv])
		else
		  LambdaTypes.VAR new_lv)
	    end
d430 8
d439 3
a441 11
      | Ident.LONGVALID(_, valid as Ident.EXCON _) =>
	let val le = cg_longexid(longValId, env)
	in
	  if is_vcc ty then
	    let val lv = LambdaTypes.new_LVar()
	    in
	      LambdaTypes.FN(lv, LambdaTypes.STRUCT[le, LambdaTypes.VAR lv])
	    end
	  else
	    LambdaTypes.STRUCT[le, LambdaTypes.STRUCT[]]
	end)
d589 1
a589 1
    val ref_labels = filter(Map.assoc(labels),
d677 1
a677 1
	  val nullary_list = filter(longvalid_mv_tree_list,
d682 1
a682 1
	    filter(longvalid_mv_tree_list, has_value o #1)
d1003 1
a1003 1
	      number_from(map #1 new_lv_pat_list, 0,
d1021 1
a1021 1
		if eqset(lvar_set, new_lvar_set) then lvar_set
d1036 1
a1036 1
		if eqset(ref_hd, lv_set) then
d1041 1
a1041 1
		      filter(lv_le_list, fn (lv, _) =>
d1044 1
a1044 1
			filter(lv_le_list, fn (lv, _) =>
a1248 9
  fun filter_ordered_map(a_list, []) = []
  | filter_ordered_map([], _) =
    raise(impossible"member missing in filter_ordered_map")
  | filter_ordered_map((x, y)::xs, z :: zs) =
    if x = z then
      (x, y) :: (filter_ordered_map(xs, zs))
    else
      filter_ordered_map(xs, z :: zs)

d1258 2
a1259 2
      val (v_a_f_list, next) = number_from(
	filter_ordered_map(v_a_list, Match_Utils.Qsort Ident.valid_order
d1264 2
a1265 2
      val (e_a_f_list, next) = number_from(
	filter_ordered_map(e_a_list, Match_Utils.Qsort Ident.valid_order
d1271 2
a1272 2
      val (s_a_f_list, _) = number_from(
	filter_ordered_map(s_a_list, map #1 ordered_int_map), next,
d1319 1
a1319 1
      number_from(valids, 0, EnvironTypes.FIELD o LambdaTypes.toField)
d1321 1
a1321 1
      number_from(exns, next, EnvironTypes.FIELD o LambdaTypes.toField)
d1323 1
a1323 1
      number_from(strids, next, EnvironTypes.FIELD o LambdaTypes.toField)
d1325 1
a1325 1
      number_from(funids, next, EnvironTypes.FIELD o LambdaTypes.toField)
@


1.22
log
@Added HANDLE for exceptions
@
text
@d4 3
d96 1
d121 1
d126 6
a131 7
  sharing DataTypes.Ident = Ident
  sharing Absyn.IdentClass = Ident
  sharing Absyn.Set = Set
  sharing Absyn.Interface = Interface
  sharing Match.Datatypes = DataTypes
  sharing Absyn.Datatypes = DataTypes
  sharing Types.Datatypes = DataTypes
a132 1
  sharing Environ.Ident = Ident
a133 1
  sharing Environ.LambdaTypes = LambdaTypes
d135 4
a138 4
  sharing DataTypes.Mapping = Map
  sharing EnvironTypes.Map = Map
  sharing LambdaUtils.Map = Map
  sharing LambdaUtils.LambdaTypes = LambdaTypes
a139 4
  sharing Interface.Map = Map
  sharing Interface.Ident = Ident
  sharing Interface.Datatypes = DataTypes
  sharing EnvironTypes.Interface = Interface
d146 1
a146 5
(*
(** define a few list functions that are common **)
  val fold = Lists.foldr (* this may not be the right fold *)
  (* function. ******* Sort out later *)
*)
d177 4
d200 1
a200 1
    raise(LambdaTypes.impossible"bad ty in get_valenv")
d220 1
a220 1
	raise (LambdaTypes.impossible "constructor_tag(1)")
d225 1
a225 1
    | domain _ = raise (LambdaTypes.impossible "constructor_tag(2)")
d229 1
a229 1
      (LambdaTypes.impossible ("constructor_tag(3): "
d255 1
a255 1
      raise (LambdaTypes.impossible ("record_tag(2)" ^ type_string))
d258 1
a258 1
    position (lab, domain the_type, LambdaTypes.impossible "record_tag(1)")
d279 1
a279 1
  | _ => raise(LambdaTypes.impossible"get_cons_type on non-constructed type")
d284 1
a284 1
  | _ => raise(LambdaTypes.impossible"is_vcc on non-constructed type")
d289 1
a289 1
  | _ => raise(LambdaTypes.impossible"OVERLOADED_SCHEME")
a314 18
(** a function which given a longvalid, and an association list of
    pairs of longvalid and LVar searches for the first occurence of
    the longvalid in the list, and returns the LVar associated with
    it.  If no match is found we raise an exception, as this should
    not be possible. **)
  fun lookup_lvar longvalid =
  let
    fun search ((lvi, lvar)::rest) =
      if lvi = longvalid then
	(lvar: LambdaTypes.LVar)
      else
	search rest
    | search [] =   (* Woops it isn't in the list *)
      raise (LambdaTypes.impossible "LVar lookup failed")
  in
    search
  end

d318 1
a318 1
  | _ => raise(LambdaTypes.impossible "get_lamb_env does not give LVar")
d326 1
a326 1
  | _ => raise(LambdaTypes.impossible "get_field_env fails to get field")
d335 1
a335 1
       | _ => raise(LambdaTypes.impossible "cg_longvalid does not give LVar"))
d342 1
a342 1
      | _ => raise(LambdaTypes.impossible "cg_longvalid fails to get field")
d351 1
a351 1
       | _ => raise(LambdaTypes.impossible "cg_longexid does not give LVar"))
d358 1
a358 1
      | _ => raise(LambdaTypes.impossible "cg_longexid fails to get field")
d367 1
a367 1
       | _ => raise(LambdaTypes.impossible "cg_longstrid does not give LVar"))
d374 1
a374 1
      | _ => raise(LambdaTypes.impossible "cg_longstrid fails to get field")
d402 1
a402 1
  fun trans_exp (x(*:Absyn.Exp*), env) (*: LambdaTypes.LambdaExp*) =
d521 1
d524 1
d541 1
a541 1
      raise(LambdaTypes.impossible("TEN15exp found"))
d605 1
a605 1
	| _ => raise(LambdaTypes.impossible("Failed to lookup match"))
d639 1
a639 1
      | _ => raise(LambdaTypes.impossible"trans_node(1)")) lab_tree_list
d693 1
a693 1
	  | _ => raise(LambdaTypes.impossible"Match.CONS bad arg")
d700 1
a700 1
	    | Ident.VAR _ => raise(LambdaTypes.impossible"VAR in match CONS")
d715 1
d722 1
a722 1
	      | _ => raise(LambdaTypes.impossible"list size")
d735 1
a735 1
	      | _ => raise(LambdaTypes.impossible"list size")
d755 1
a755 1
	      | _ => raise(LambdaTypes.impossible"list length")
d775 1
d848 1
a848 5
	 * subs is a parameter for accumulating the environments produced
	 * from these decs. (No longer used)
	 * envir is the environment for handling the entire declaration,
	 * and is only updated after the entire declaration has been
	 * compiled.
d850 1
a850 2
	(* Further thoughts. We shouldn't really need two parameters
	   expressing environments to trans_dec. trans_dec should return
d856 1
a856 1
  and trans_dec (some_dec, envir) =
d860 1
a860 1
    | _ => raise(LambdaTypes.impossible("Failed to lookup bind"))
d872 1
a872 1
	| Absyn.SCONpat(scon) =>
d893 1
a893 1
	    Ident.VAR(symbol) => (case path of
d896 1
a896 1
	    | Ident.PATH(_) => raise(LambdaTypes.impossible
d913 2
a914 2
	  | Ident.EXCON(excon) => raise(
	    LambdaTypes.impossible"VALpat(Ident.EXCON)"))
d938 1
a938 1
	    raise(LambdaTypes.impossible"APPpat of Ident.VAR")
d951 1
a951 1
                    [(*Check for nullary constructors here*)],
d968 12
a979 3
	    raise(LambdaTypes.not_done_yet"APPpat of Ident.EXCON")

)
d991 1
a991 1
	    LambdaTypes.impossible"LAYEREDpat with non-VAR valid"))
d1025 1
a1025 1
		raise(LambdaTypes.impossible"non-trivial lhs in letrec"))
d1032 55
d1089 4
d1094 2
a1095 1
		LambdaTypes.STRUCT(map (LambdaTypes.VAR o #1) lv_pat_exp_list)))
a1098 45
(** just deal with non-rec bits and return...
    OK we can call Match.compile_match on each pat_exp and transform
    the resulting tree into lambda code, but this isn't useful, we
    want to end up with an Environ.LVar which is the name of the thing
    being defined and a piece of code to run to evaluate to it.  What
    we will get will be a piece of code which binds the names and then
    evaluates some code, which should be applied with the expression
    as input...  Basically I think that trans_dec needs some more
    thought!

    Ok how about, trans_dec taking a dec, a list of subs, and a lambda
    expression which is to be called in the environment created by the
    declaration.  This changes the interface so that all we return in
    total is a lambda expression which sets up the environment and
    calls the expression passed.  This means that it is only suitable
    for dealing with a LOCALdec expression not with TOPdecs but is
    this a problem for the expression translator?

    Take the patterns, and concat them together into a record
    constructor, doing the same with the expressions.  Code up the
    patterns as a single match tree, with the lambda code passed as
    the expression to be evaluated, with the expression_list record as
    the argument to this function.

    However how do I deal with the rec part?
    The LETREC expects a list of Environ.LVar * Lambda to bind the
    values to the code, however in general the patterns will not be so
    simple so something else must be done first to get the required
    format.
    Clearly all these bindings also need to be made at the same time
    as the non-rec parts too, further complicating the positioning of
    the binding code!  <wahhh>

    Colin has pointed out that we need to keep an environment thing,
    showing the current association between names and lambda
    variables.  This means that the bindings don't actually have to be
    done at the same time, just using the same environment.  However I
    will have to alter lots of this code to deal with the environment
    etc...                    
**)

(** From what colin said, and my reading of the Ten_15 code-generator,
    these type-declatations don't need to generate any code at all.
    This includes, TYPEdec, DATATYPEdec, and EXCEPTIONdecs.
**)
d1105 1
a1105 1
	  | munge _ = raise(LambdaTypes.impossible"Absyn.DATATYPE")
d1118 1
a1118 1
       STRUCT(l1,STRUCT()) or FN(l3, STRUCT(l1,VAR(l3))) according to
d1140 1
a1140 1
		  | _ => raise(LambdaTypes.impossible"cg_longexid")
d1216 1
a1216 1
	     | _ => raise(LambdaTypes.impossible"Absyn.OPENdec(1)")
d1221 1
a1221 1
	     | _ => raise(LambdaTypes.impossible"Absyn.OPENdec(2)")
d1277 1
a1277 1
    raise(LambdaTypes.impossible"member missing in filter_ordered_map")
d1327 1
a1327 1
		      | _ => raise(LambdaTypes.impossible"c_s_w_i(1)"))
d1331 1
a1331 1
		      | _ => raise(LambdaTypes.impossible"c_s_w_i(2)"))
d1337 2
a1338 2
	  | ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) => raise(LambdaTypes.impossible"c_s_w_i (3) LAMB")
	  | ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) => raise(LambdaTypes.impossible"c_s_w_i (4) PRIM"))
d1356 1
a1356 1
      number_from(exns, 0, EnvironTypes.FIELD o LambdaTypes.toField)
d1386 1
a1386 1
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) valids) @@
d1388 1
a1388 1
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) exns) @@
d1390 1
a1390 1
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) strids) @@
d1392 1
a1392 1
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) funids)
a1429 4
(*
      val _ = print("Result env\n" ^ EnvironPrint.printenv result_env)
      val _ = print("Required arg env\n" ^ EnvironPrint.printenv(make_env_from_interface interface))
*)
a1430 3
(*
      val _ = print("Actual arg env\n" ^ EnvironPrint.printenv env)
*)
a1432 3
(*
      val _ = print("Completed env\n" ^ EnvironPrint.printenv new_env)
*)
d1435 2
a1436 2
      | EnvironTypes.PRIM _ => raise(LambdaTypes.impossible"APPstrexp(1)")
      | EnvironTypes.FIELD _ => raise(LambdaTypes.impossible"APPstrexp(2)")
a1466 1
	(print"signature constraint not done yet??";
a1469 1
	 )
d1471 3
a1473 3
      val (env', lv_le_list) = trans_single_struct(strid, sigexp_opt, strexp)
      val (env'', lv_le_list') = trans_str_dec(Absyn.STRUCTUREstrdec tl,
        Environ.augment_top_env(top_env, make_top_env env'))
d1510 1
a1510 2
      let (*val _ = print("Funid = " ^ (DataTypes.IdentPrint.printFunId funid))
	val _ = print("Strid = " ^ (DataTypes.IdentPrint.printStrId strid))*)
@


1.21
log
@Added exception and raise
@
text
@d4 3
d280 1
a280 1
  | DataTypes.CONSTYPE(_) => ty
d284 2
a285 2
    DataTypes.FUNTYPE(_) => true
  | DataTypes.CONSTYPE(_) => false
d293 1
a293 1
  fun get_no_cons(ty) = length(Map.domain(get_valenv(get_cons_type ty)))
d318 1
a318 1
    pairs of longvalid and LVar searches for the first occurance of
a534 3
(*
      raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.RAISEexp"))
*)
d539 8
a546 4
	raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.HANDLEexp"))
(*	  HANDLE (trans_exp (exp, env),
	    trans_match (Match.compile_match pat_exp_list, env))
*)
d556 1
a556 1
	trans_match((root, tree), env)
d614 1
a614 1
  and trans_match((root, tree), env) =
a615 4
    val exprim = case Environ.lookup_exn(
      Ident.EXCON(Symbol.find_symbol "Match"), env) of
        EnvironTypes.PRIM prim => prim
      | _ => raise(LambdaTypes.impossible("Failed to lookup match"))
d617 11
a627 2
      LambdaTypes.RAISE(LambdaTypes.STRUCT(
	[LambdaTypes.BUILTIN exprim, LambdaTypes.STRUCT []]))
d708 4
d716 1
a716 1
	        DataTypes.FUNTYPE(_) => true
d719 2
a720 1
	    | _ => raise(LambdaTypes.not_done_yet"EXCONs in matches")
d722 1
a722 1
	    fn(v, _, _) => not (has_value v))
d726 1
a726 2
	    map (fn (v, m, t) => (v, m, t, (*LambdaTypes.new_LVar()*)new_lv))
              (filter(longvalid_mv_tree_list, fn(v, _, _) => has_value v))
d731 2
d738 1
a738 1
	        [(valid, mv, tree, lv)] => (mv, lv, tree)
d771 2
a772 1
		[x] => x | _ => raise(LambdaTypes.impossible"list length")
d784 1
a784 1
              map (fn (Ident.LONGVALID(_, valid), mv, tree, lv) =>
d786 1
a786 1
              tr_match(tree, LambdaUtils.add_match_env((mv, lv),
d791 10
d908 2
a909 2
	      [(dummy_lv, LambdaTypes.SWITCH(LambdaTypes.VAR(lambda_var),
                [(LambdaTypes.SCON_TAG(scon), LambdaTypes.VAR(lambda_var))],
d913 1
a913 1
	  (case (valid) of
d957 2
a958 2
	| Absyn.APPpat((longvalid, ty), pat) => (case longvalid of
	    Ident.LONGVALID(_, Ident.VAR(_)) =>
d960 33
a992 36
	  | Ident.LONGVALID(_, valid as Ident.CON(con)) =>
	    let
	      val _ = ()
	    in
	      if get_no_cons(!ty) = 1 then
		trans_individual_dec(pat, lambda_var)
	      else
		let val new_lv = LambdaTypes.new_LVar()
		  val (new_env, new_lambda_exp) =
		    trans_individual_dec(pat, new_lv)
		  val lexp = LambdaTypes.VAR lambda_var
		  val tag = constructor_tag(valid, !ty)
		in
		  (new_env, [(new_lv,
		    LambdaTypes.SWITCH(lexp,
                      [(*Check for nullary constructors here*)],
			if get_no_null_cons(!ty) = 0 then LambdaTypes.ABSENT
			else excp (* is a tag, but not the right one *),
                          LambdaTypes.PRESENT((* isn't a tag *)
			    LambdaTypes.SWITCH(LambdaTypes.SELECT(
			      LambdaTypes.toField 0(*Tag position*), lexp),
			        [(LambdaTypes.CON_TAG(
				  constructor_tag(valid, !ty)),
				    LambdaTypes.SELECT(
				      LambdaTypes.toField 1(*Val position*),
					lexp))],
				          if get_no_vcc_cons(!ty) <> 1 then
					    excp
					  else LambdaTypes.ABSENT,
					    LambdaTypes.ABSENT))))])
		end
	    end
	  | Ident.LONGVALID(_, Ident.EXCON(excon)) =>
	    raise(LambdaTypes.not_done_yet"APPpat of Ident.EXCON"))
	| Absyn.TYPEDpat(typed, _) =>
	  trans_individual_dec(typed, lambda_var)
a1255 4
(*
  (if length(Map.assoc e_map) <> 0 then raise(LambdaTypes.not_done_yet"e_map")
   else ();
*)
@


1.20
log
@Completed functors. Redid trans_str_exp to return packaged structure
Redid to use exception environment as well
@
text
@d4 4
d265 1
a265 1
    All types involving more than one value carrying constructor
d335 1
a335 1
  | _ => raise(LambdaTypes.impossible "cg_longvalid does not give LVar")
d364 16
d432 2
a433 2
    | Absyn.VALexp (longValId, ref ty) => (case longValId of
        Ident.LONGVALID(_, valid as Ident.VAR(_)) =>
d455 1
a455 1
      | Ident.LONGVALID(_, valid as Ident.CON(_)) =>
d474 11
a484 2
      | Ident.LONGVALID(_, valid as Ident.EXCON(_)) =>
        raise(LambdaTypes.not_done_yet"VALexp of Ident.EXCON"))
d612 1
a612 1
    val exprim = case Environ.lookup_valid(
d616 3
a618 1
    val excp = LambdaTypes.RAISE(LambdaTypes.BUILTIN exprim)
d852 1
a852 1
  let val exprim = case Environ.lookup_valid(
d856 3
a858 1
    val excp = LambdaTypes.PRESENT(LambdaTypes.RAISE(LambdaTypes.BUILTIN exprim))
d1090 47
a1136 1
      raise(LambdaTypes.not_done_yet"Dunno how to deal with Absyn.EXCEPTIONdec")
@


1.19
log
@Completed functor application. Changed trans_str_exp to return
tupled up structs
@
text
@d4 4
d502 2
a503 1
    | Absyn.RAISEexp (exp, _) => (*RAISE (trans_exp (exp, env))*)
d505 1
d1088 1
a1088 1
	 let val (EnvironTypes.ENV(valid_env, strid_env), lambda_exp) =
d1092 2
d1100 4
d1109 1
a1109 1
	     (fn (_, EnvironTypes.FIELD(field), l) =>
d1148 1
a1148 47
(* Removed, this is just a special case of beta reduction (lambda x.x)y => y
  fun convert_lambda([], _, _) = []
  | convert_lambda((lv, le) :: tl, lv_replace, lv_replace_by) =
  let fun transform_exp(lambda_exp) =
    case lambda_exp of
      LambdaTypes.VAR lv =>
	if lv = lv_replace then LambdaTypes.VAR lv_replace_by else lambda_exp
    | LambdaTypes.FN(lv, le) => LambdaTypes.FN(lv, transform_exp le)
    | LambdaTypes.LETREC(lv_list, le_list, le) =>
      LambdaTypes.LETREC(lv_list, map transform_exp le_list,
	transform_exp le)
    | LambdaTypes.APP(le1, le2) =>
      LambdaTypes.APP(transform_exp le1, transform_exp le2)
    | LambdaTypes.SWITCH(le, c_le_list, le_opt1, le_opt2) =>
      LambdaTypes.SWITCH(transform_exp le,
       map (fn (c, le) => (c, transform_exp le)) c_le_list,
	 case le_opt1 of LambdaTypes.ABSENT => le_opt1
	 | LambdaTypes.PRESENT le => LambdaTypes.PRESENT(transform_exp le),
	   case le_opt2 of LambdaTypes.ABSENT => le_opt2
	   | LambdaTypes.PRESENT le => LambdaTypes.PRESENT(transform_exp le))
    | LambdaTypes.STRUCT(le_list) =>
      LambdaTypes.STRUCT(map transform_exp le_list)
    | LambdaTypes.SELECT(field, le) =>
      LambdaTypes.SELECT(field, transform_exp le)
    | LambdaTypes.RAISE le => LambdaTypes.RAISE(transform_exp le)
    | LambdaTypes.HANDLE(le1, le2) =>
      LambdaTypes.HANDLE(transform_exp le1, transform_exp le2)
    | _ => lambda_exp (* Default for cases not involving lambda variables *)
  in
    (lv, transform_exp le) :: convert_lambda(tl, lv_replace, lv_replace_by)
  end

  fun remove_redundant_lambdas [] = []
  | remove_redundant_lambdas ((lv, le as LambdaTypes.VAR lv') :: tl) =
    convert_lambda(tl, lv, lv') (* Replace all occurences of lv by lv' *)
  | remove_redundant_lambdas ((lv, le) :: tl) =
    (lv, le) :: (remove_redundant_lambdas tl)
*)

  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end

  (* Compare an interface and an environment for equality.
d1152 6
a1157 2
  fun compare_sig_env(Interface.INT(Interface.INTENV intenv, v_list),
    EnvironTypes.ENV(v_map, s_map)) =
d1159 1
d1184 2
a1185 2
    intenv as Interface.INTENV s_int_map, v_list),
      env as EnvironTypes.ENV(v_map, s_map), lambda_var) =
d1196 6
a1204 3
(*
      val _ = print"numbering strids"
*)
a1207 3
(*
      val _ = print"getting new lvars for strids"
*)
a1209 3
(*
      val _ = print"getting complete structs"
*)
a1212 3
(*
      val _ = print"getting the_structure_list"
*)
d1214 2
a1215 1
	  v_a_f_l_list) @@ (map (fn (_, x, _) => LambdaTypes.VAR x)
d1217 7
a1223 5
      val env = foldleft Environ.add_valid_env(
	foldleft Environ.add_strid_env(Environ.empty_env,
	  map (fn(((strid, _), field), env) => (strid, (env, field)))
	    (Lists.zip(s_a_f_list, map #1 e_le_list))),
	      map (fn ((v, _), f_new) => (v, f_new)) v_a_f_list)
d1228 5
a1232 1
      val l2 = (map
d1236 2
a1237 2
	  | ((((_, (_, EnvironTypes.LAMB _)), _), _, _), _) => raise(LambdaTypes.impossible"c_s_w_i (2) LAMB")
	  | ((((_, (_, EnvironTypes.PRIM _)), _), _, _), _) => raise(LambdaTypes.impossible"c_s_w_i (3) PRIM"))
d1239 1
a1239 1
      val lambdas = let_lambdas_in_exp(l1 @@ l2,
d1246 1
a1246 1
    EnvironTypes.ENV(m1, m2), EnvironTypes.FUN_ENV m)) =
d1248 3
a1250 2
    val valids = Map.assoc m1
    val strids = Map.assoc m2
d1254 2
d1261 1
d1266 4
a1269 3
      foldleft Environ.add_strid_env(
        (foldleft Environ.add_valid_env (Environ.empty_env, v_field)),
          s_field),
d1274 1
a1274 1
    EnvironTypes.ENV(m1, m2), EnvironTypes.FUN_ENV m), lv_le_list) =
d1276 3
a1278 2
    val valids = Map.assoc m1
    val strids = Map.assoc m2
a1279 11
(*
    val (v_field', next) =
      number_from(valids, 0, EnvironTypes.FIELD o LambdaTypes.toField)
    val (s_field', next) =
      number_from(strids, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val (f_field', _) =
      number_from(funids, next, EnvironTypes.FIELD o LambdaTypes.toField)
    val v_field = map (fn ((vid, _), f) => (vid, f)) v_field'
    val s_field = map (fn ((sid, (e, _)), f) => (sid,(e, f))) s_field'
    val f_field = map (fn ((fid, (_, i, e)), f) => (fid,(f, i, e))) f_field'
*)
a1280 7
(*
    (EnvironTypes.TOP_ENV(
      foldleft Environ.add_strid_env(
        (foldleft Environ.add_valid_env (Environ.empty_env, v_field)),
          s_field),
      foldleft Environ.add_funid_env (Environ.empty_fun_env, f_field)),
*)
d1286 2
a1316 14
  fun make_env_from_interface(interface as
    Interface.INT(intenv as Interface.INTENV strid_map, valid_list)) =
  let val (v_f_list, next) =
      number_from(valid_list, 0, EnvironTypes.FIELD o LambdaTypes.toField)
    val (s_f_list, _) =
      number_from(Map.assoc strid_map, next,
	EnvironTypes.FIELD o LambdaTypes.toField)
    val s_f_e_list =
      map (fn ((s, i), f) => (s, (make_env_from_interface i, f))) s_f_list
  in
    foldleft Environ.add_strid_env(
      foldleft Environ.add_valid_env(Environ.empty_env, v_f_list), s_f_e_list)
  end

a1326 30
(*
    let val (EnvironTypes.ENV(valid_env, strid_env), lambda_exp) =
      cg_longstrid(longstrid, env)
      val valid_map = map (fn (v, c) => (v, c, LambdaTypes.new_LVar()))
	(Map.assoc valid_env)
      val strid_map = map (fn (s, ec) => (s, ec, LambdaTypes.new_LVar()))
	(Map.assoc strid_env)
      val new_v_env = foldleft
	(fn ((v, _, l), env) =>
	  Environ.add_valid_env((v, EnvironTypes.LAMB l), env))
	    (Environ.empty_env, valid_map)
      val new_s_env = foldleft
	(fn ((s, (e, c), l), env) =>
	  Environ.add_strid_env((s, (e, EnvironTypes.LAMB l)), env))
	    (Environ.empty_env, strid_map)
      val new_v_lambdas = map
	(fn (_, EnvironTypes.FIELD field, l) =>
	  (l, LambdaTypes.SELECT(field, lambda_exp))
        | _ => raise(LambdaTypes.impossible"Absyn.OLDstrexp(1)")
	    ) valid_map
      val new_s_lambdas = map
	(fn (_, (_, EnvironTypes.FIELD field), l) =>
	  (l, LambdaTypes.SELECT(field, lambda_exp))
        | _ => raise(LambdaTypes.impossible"Absyn.OLDstrexp(2)")
	    ) strid_map
    in
      (Environ.augment_env(new_v_env, new_s_env),
       new_v_lambdas @@ new_s_lambdas)
    end
*)
d1329 1
d1332 1
d1334 1
a1335 2
(*
      val (new_env, new_arg) = (env, arg) (*Temporary*)
d1339 1
d1341 1
d1424 1
a1424 1
	val env = make_env_from_interface interface
@


1.18
log
@Fixed bug in match compilation to ensure trees at lebale are translated
into function applications.
Almost finished functor application, but about to rearrange things so
that trans_str_exp returns an env and an expression
@
text
@d4 6
d366 1
a366 1
	(env''', EnvironTypes.FIELD(field)) => (env''', field)
d1273 24
a1296 1
  fun complete_struct_from_topenv(EnvironTypes.TOP_ENV(
d1302 1
d1312 1
d1314 1
d1320 2
d1336 1
a1336 1
  fun complete_struct((env, lv_le_list), interface_opt) =
d1338 3
a1340 3
    val (EnvironTypes.TOP_ENV(new_env, new_fun_env), new_lambda) =
      complete_struct_from_topenv(make_top_env env, lv_le_list)
    val result = (new_env, new_lambda)
d1351 1
a1351 1
	  (new_env', let_lambdas_in_exp([(new_lv, new_lambda)], new_lambda'))
d1371 9
a1379 2
    Absyn.NEWstrexp strdec => trans_str_dec(strdec, top_env)
  | Absyn.OLDstrexp longstrid => (* Bit like open *)
d1408 1
d1415 3
a1420 1
      val new_lv = LambdaTypes.new_LVar()
d1426 1
a1426 1
      (result_env, [(new_lv, LambdaTypes.APP(LambdaTypes.VAR f_lv, new_arg))])
d1430 1
a1430 1
      val (new_env, new_lambdas) =
d1434 1
a1434 1
      (new_env, local_lambdas @@ new_lambdas)
d1452 1
a1452 14
	case (sigexp_opt, strexp) of
	  (Absyn.ABSENT, Absyn.OLDstrexp longstrid) =>
	    cg_longstrid(longstrid, env)
	| (_, Absyn.APPstrexp _) =>
	  let val (env, lv_le_list) = trans_str_exp(strexp, top_env)
	    val (lv, le) = case lv_le_list of
	      [(lv, le)] => (lv, le)
	    | _ => raise(LambdaTypes.impossible"APPstrexp multiple exps")
	  in
	    (print"signature constraint not done yet";
	    (env, le)
	     )
	  end
	| _ => complete_struct(trans_str_exp(strexp, top_env), inte_opt)
d1455 1
d1459 1
@


1.17
log
@More work on functor application
@
text
@d4 3
d599 6
a604 1
        tr_match(tree', match_env, val_env, label_env))
d752 3
a754 1
	  LambdaTypes.VAR(LambdaUtils.lookup_label(label, lab_env))
d756 5
a760 1
        LambdaTypes.VAR(LambdaUtils.lookup_label(label, lab_env))
a1244 3
(*
      val _ = print"env"
*)
a1249 4

(*
      val _ = print"lambdas, l1"
*)
a1253 3
(*
      val _ = print"l2"
*)
a1260 3
(*
      val _ = print"let_lambdas"
*)
a1262 3
(*
      val _ = print"IN"
*)
a1264 17
(*
      (foldleft Environ.add_valid_env(
	foldleft Environ.add_strid_env(Environ.empty_env,
	  map (fn(((strid, _), field), env) => (strid, (env, field)))
	    (Lists.zip(s_a_f_list, map #1 e_le_list))),
	      map (fn ((v, _), f_new) => (v, f_new)) v_a_f_list),

      let_lambdas_in_exp((map (fn (((_, EnvironTypes.FIELD f_old), _), lv) =>
        (lv, LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var)))
	  v_a_f_l_list) @@ (map
	  (fn ((((_, (env, EnvironTypes.FIELD f_old)), _), lv, lv'), le) =>
          (lv, let_lambdas_in_exp([(lv', le)],
	  LambdaTypes.SELECT(f_old, LambdaTypes.VAR lambda_var))))
	  (Lists.zip(s_a_f_l_list, map #2 e_le_list))),

        LambdaTypes.STRUCT the_structure_list))
*)
d1288 1
a1288 1
      let_lambdas_in_exp((*remove_redundant_lambdas *) lv_le_list,
d1411 10
d1444 1
a1444 1
  | Absyn.SEQUENCEstrdec(strdec_list) =>
@


1.16
log
@Updated LETREC stuff
@
text
@d4 3
d1020 1
d1196 1
a1196 1
    (env, LambdaTypes.VAR lambda_var)
d1198 2
a1199 1
    let val v_a_list = Match_Utils.Qsort v_order (Map.assoc v_map)
d1208 3
d1214 3
d1219 3
d1225 3
d1231 34
d1266 2
d1283 1
d1321 1
a1321 1
  fun complete_struct((env, lv_le_list), sigexp_opt) =
a1322 3
    val inte_opt = case sigexp_opt of Absyn.ABSENT => Absyn.ABSENT
      | Absyn.PRESENT(Absyn.NEWsigexp(_, ref inte)) => Absyn.PRESENT inte
      | Absyn.PRESENT(Absyn.OLDsigexp(_, ref inte)) => Absyn.PRESENT inte
d1327 3
a1329 3
    case inte_opt of
      Absyn.ABSENT => result
    | Absyn.PRESENT inte =>
d1388 12
a1399 4
      val _ = print"Result env"
      val _ = print(EnvironPrint.printenv result_env)
      val _ = print"Arg env"
      val _ = print(EnvironPrint.printenv(make_env_from_interface interface))
d1401 1
a1401 1
      raise(LambdaTypes.not_done_yet "APPstrexp")
a1402 2
(*
*)
d1420 7
a1426 1
      let val (str_env, lambda_exp) =
d1430 1
a1430 1
	| _ => complete_struct(trans_str_exp(strexp, top_env), sigexp_opt)
d1481 6
d1492 1
a1492 1
		  sigexp_opt)
@


1.15
log
@Updated for new top level
@
text
@d4 3
d369 7
d935 1
d937 3
a939 2
	      (fn (lv, pat, _) => trans_individual_dec(pat, lv)) 
	        lv_pat_exp_list (* The exps parts here should be null *)
d944 5
d954 5
d960 4
a963 2
	    (all_env, [(LambdaTypes.new_LVar(), (* A dummy lvar *)
	      LambdaTypes.LETREC(map #1 lv_pat_exp_list, exp_list))])
a1195 5
(*
      val _ = print"Different sig"
      val _ = print("v_list has size " ^ Integer.makestring(length v_list))
      val _ = print("v_map has size " ^ Integer.makestring(length v_a_list))
*)
a1198 3
(*
      val _ = print("v_a_f_list has size " ^ Integer.makestring(length v_a_f_list))
*)
a1199 3
(*
      val _ = print("v_a_f_l_list has size " ^ Integer.makestring(length v_a_f_l_list))
*)
a1201 3
(*
      val _ = print("s_map has size " ^ Integer.makestring(length s_a_list))
*)
a1205 3
(*
      val _ = print("s_a_f_list has size " ^ Integer.makestring(length s_a_f_list))
*)
a1207 3
(*
      val _ = print("s_a_f_l_list has size " ^ Integer.makestring(length s_a_f_l_list))
*)
a1213 4
(*
      val _ = print("the_structure_list has size " ^
	Integer.makestring(length the_structure_list))
*)
d1229 1
a1229 1
        LambdaTypes.STRUCT(the_structure_list)))
d1232 2
a1233 1
  fun complete_struct_from_lists(valid_list, strid_list, lv_le_list) =
d1235 12
a1246 12
    fun v_list_to_fields([], i) = ([], i)
    | v_list_to_fields((v, comp) :: tl, i) =
    let val (li, i') = v_list_to_fields(tl, i+1)
    in
      ((v, EnvironTypes.FIELD(LambdaTypes.toField(i))) :: li, i')
    end

    fun s_list_to_fields([], _) = []
    | s_list_to_fields((s, (e, comp)) :: tl, i) =
      (s, (e, EnvironTypes.FIELD(LambdaTypes.toField(i)))) ::
        (s_list_to_fields(tl, i+1))
    val (v_field, nexti) = v_list_to_fields(valid_list, 0)
d1248 5
a1252 3
    (foldleft Environ.add_strid_env (
      (foldleft Environ.add_valid_env (Environ.empty_env, v_field)),
      s_list_to_fields(strid_list, nexti)),
d1255 7
a1261 4
      (map (fn (_, EnvironTypes.LAMB(lv)) => LambdaTypes.VAR(lv)
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) valid_list) @@
      (map (fn (_, (_, EnvironTypes.LAMB(lv))) => LambdaTypes.VAR(lv)
            | _ => raise(LambdaTypes.impossible"comp_st(1)")) strid_list))))
d1264 5
a1268 3
  fun complete_struct((EnvironTypes.ENV(map1, map2), lv_le_list), sigexp_opt) =
  let val valid_list = Match_Utils.Qsort v_order (Map.assoc map1)
    val strid_list = Match_Utils.Qsort s_order (Map.assoc map2)
d1272 3
a1274 2
    val result as (new_env, new_lambda) =
      complete_struct_from_lists(valid_list, strid_list, lv_le_list)
d1289 13
a1301 2
  fun make_top_env env = EnvironTypes.TOP_ENV(env,
    EnvironTypes.FUN_ENV Map.empty_map)
d1339 2
a1404 14
  fun make_env_from_interface(interface as
    Interface.INT(intenv as Interface.INTENV strid_map, valid_list)) =
  let val (v_f_list, next) =
      number_from(valid_list, 0, EnvironTypes.FIELD o LambdaTypes.toField)
    val (s_f_list, _) =
      number_from(Map.assoc strid_map, next,
	EnvironTypes.FIELD o LambdaTypes.toField)
    val s_f_e_list =
      map (fn ((s, i), f) => (s, (make_env_from_interface i, f))) s_f_list
  in
    foldleft Environ.add_strid_env(
      foldleft Environ.add_valid_env(Environ.empty_env, v_f_list), s_f_e_list)
  end

d1426 4
a1429 3
	(EnvironTypes.TOP_ENV(Environ.empty_env, EnvironTypes.FUN_ENV(
	  Map.add((funid, (lambda_var, interface, str_env)), Map.empty_map,
	    Ident.funid_order))),
@


1.14
log
@Started on functor application
@
text
@d4 3
d401 1
a401 1
		  "'" ^ name ^ (DataTypes.IdentPrint.printValId valid))))
@


1.13
log
@Added functor definition compilation
@
text
@d4 3
d1313 8
a1320 1
    raise(LambdaTypes.not_done_yet "APPstrexp")
@


1.12
log
@Added trans_fun_dec to translate functors. No body as yet.
@
text
@d4 3
d109 1
d1161 2
a1162 1
  if compare_sig_env(inte, env) then (env, LambdaTypes.VAR lambda_var)
d1166 5
d1174 3
d1178 3
d1183 3
d1190 3
d1195 3
d1201 7
d1223 1
a1223 4
        LambdaTypes.STRUCT((map (fn (_, x) => LambdaTypes.VAR x)
	  v_a_f_l_list) @@ (map (fn (_, x, _) => LambdaTypes.VAR x)
	  s_a_f_l_list)
          )))
d1274 6
a1279 2
  fun trans_str_exp(strexp, env) = case strexp of
    Absyn.NEWstrexp strdec => trans_str_dec(strdec, env)
d1312 1
a1312 1
    let val (local_env, local_lambdas) = trans_str_dec(strdec, env)
d1314 2
a1315 1
	trans_str_exp(strexp, Environ.augment_env(env, local_env))
d1320 2
a1321 1
  and trans_str_dec(strdec, env) = case strdec of
d1329 4
a1332 1
	complete_struct(trans_str_exp(strexp, env), sigexp_opt)
d1341 1
a1341 1
        Environ.augment_env(env, env'))
d1347 1
a1347 1
      val (local_env, local_lambda) = trans_str_dec(strdec1, env)
d1349 2
a1350 1
	trans_str_dec(strdec2, Environ.augment_env(env, local_env))
d1360 1
a1360 1
      val (env', lambda) = trans_str_dec(strdec, env)
d1362 1
a1362 1
	Environ.augment_env(env, env'))
d1367 21
a1387 3
  fun trans_fun_dec([], _) =
    (EnvironTypes.TOP_ENV(Environ.empty_env,
      EnvironTypes.FUN_ENV Map.empty_map), [])
d1389 21
a1409 2
    let fun trans_individual_funbind(funbind, top_env) =
      raise(LambdaTypes.not_done_yet"trans_individual_funbind")
d1415 8
a1423 3
  fun make_top_env env = EnvironTypes.TOP_ENV(env,
    EnvironTypes.FUN_ENV Map.empty_map)

d1427 1
a1427 1
    let val (new_env, lambdas) = trans_str_dec(strdec, env)
d1432 2
a1433 1
  | Absyn.FUNCTORtopdec funbind_list => trans_fun_dec(funbind_list, top_env)
@


1.11
log
@Added structure thinning and overloaded primitives
@
text
@d4 3
d387 1
a387 1
	  val new_valid =
d394 2
a395 2
	  if (Environ.Builtin_p (new_valid, env)) then
	    LambdaTypes.BUILTIN (Environ.FindBuiltin (new_valid, env))
d397 1
a397 1
	    cg_longvalid(new_valid, env)
d400 1
a400 2
	let (* val _ = print"VALexp Ident.CON"
	  val _ = print (case ty of DataTypes.FUNTYPE(_) => "FUNTYPE" | DataTypes.CONSTYPE(_) => "CONSTYPE" | _ => "Something else") *)
d403 3
d411 1
a411 1
                  LambdaTypes.STRUCT([lexp, LambdaTypes.VAR new_lv])
a914 1
	    val _ = print"Handling rec_list"
d1328 24
a1351 5
  fun trans_top_dec(topdec, env) = case topdec of
    Absyn.STRDECtopdec strdec => trans_str_dec(strdec, env)
  | Absyn.SIGNATUREtopdec _ => (Environ.empty_env, [])
  | Absyn.FUNCTORtopdec funbind_list =>
    raise(LambdaTypes.not_done_yet "FUNCTORtopdec")
a1355 1

@


1.10
log
@Handled datatype declarations correctly as in 2.7 of the commentary
@
text
@d4 3
d48 1
d74 1
d86 1
d100 3
d109 1
d113 1
d115 4
d264 14
d374 19
a392 3
        Ident.LONGVALID(_, Ident.VAR(_)) =>
	  if (Environ.Builtin_p (longValId, env)) then
	    LambdaTypes.BUILTIN (Environ.FindBuiltin (longValId, env))
d394 2
a395 1
	    cg_longvalid(longValId, env)
a412 4
	(* This isn't right yet. We need to determine if the valid we've
	   got is a value carrying constructor, and if so, is it the only
	   one. Then we can generate accordingly.
	*)
d475 1
d478 1
a769 1
    (* This should be looking up as a primitive *)
a773 3
(*
      Absyn.VALdec ([], [], _) => (Environ.empty_env, [])
*)
d1113 80
d1220 7
a1226 8
  let val valid_list = Match_Utils.Qsort
      (fn ((valid1, _), (valid2, _)) => Ident.valid_order(valid1, valid2))
	(Map.assoc map1)
    val strid_list = Match_Utils.Qsort
      (fn ((strid1, _), (strid2, _)) => Ident.strid_order(strid1, strid2))
	(Map.assoc map2)
    val _ = case sigexp_opt of Absyn.ABSENT => ()
      | Absyn.PRESENT(sigexp) => print"Signature constraint NYI "
d1228 11
a1238 1
    complete_struct_from_lists(valid_list, strid_list, lv_le_list)
a1291 2
	val _ = case sigexp_opt of Absyn.ABSENT => ()
	  | Absyn.PRESENT sigexp => raise(LambdaTypes.not_done_yet"SigExp")
d1329 2
@


1.9
log
@Added recursive function handling, as far as LETREC
@
text
@d4 3
d40 2
a44 1
require "../utils/map";
d66 2
a72 1
  structure Map: MAP
d80 1
d497 1
a497 1
      Ident.EXCON(Symbol.find_symbol "Match" ), env) of
a498 1

d724 1
a724 1
    Ident.EXCON(Symbol.find_symbol "Bind" ), envir) of
d731 1
a732 4
    (* No more to do. Just return the additional environment *)
(*
    | Absyn.VALdec ([], x, _) =>
      raise(LambdaTypes.not_done_yet("Absyn.VALdec ([], recursive_decs, _)"))
d734 1
a734 1
    | Absyn.VALdec (non_rec_list, rec_list, tyvar) =>
d931 1
a931 1
    This includes, TYPEdec, DATATYPEdec, ABSTYPEdec, and EXCEPTIONdecs.
d934 13
a946 1
    | Absyn.DATATYPEdec datatypeinfo_list => (Environ.empty_env, [])
d949 1
a949 1
      raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.EXCEPTIONdec"))
@


1.8
log
@Completed trans_str_dec, and all of trans_str_exp barring functor
application. Added trans_top_dec as the only external interface.
Now about to split the functor, as NJML won't currently compile it
@
text
@d4 5
d309 5
d490 4
a493 4
    val exlvar = case Environ.lookup_valid(
      Ident.EXCON(Symbol.find_symbol "match" ), env) of
        EnvironTypes.LAMB lv => lv
      (* This should be looking up as a primitive *)
d495 1
a495 1
    val excp = LambdaTypes.RAISE(LambdaTypes.VAR exlvar)
d718 3
a720 3
  let val exlvar = case Environ.lookup_valid(
    Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
      EnvironTypes.LAMB(lv) => lv
d723 1
a723 1
    val excp = LambdaTypes.PRESENT(LambdaTypes.RAISE(LambdaTypes.VAR exlvar))
d728 1
d731 3
a733 3
    | Absyn.VALdec ((pat, exp) :: tl, rec_list, tyvar) =>
      let val lvar = LambdaTypes.new_LVar()
	val lambda = trans_exp(exp, envir)
d759 1
a759 4
	    Ident.VAR(symbol) =>
	    let val _ = () (*print"Handling Ident.VAR"*)
	    in
 (case path of
a763 1
	    end
a851 3
	val (more_env, more_lambda) = trans_individual_dec(pat, lvar)
	val (rest_env, rest_lambda) =
	  trans_dec(Absyn.VALdec(tl, rec_list, tyvar), envir)
d853 32
a884 2
	(Environ.augment_env(more_env, rest_env),
	  (lvar, lambda) :: more_lambda @@ rest_lambda)
@


1.7
log
@completed match translator barring exception constructors
@
text
@d4 3
a86 1
  structure Match = Match
a87 1
  structure Ident = Ident
a110 5
(*
  fun is_nil [] = true
  | is_nil _ = false
*)

d385 2
a386 11
    | Absyn.LOCALexp (decl, exp) => (* Was LOCALdec *)
(* There is something seriously wrong with this code.
   exp in this context is a Absyn.Exp, not a Absyn.Dec *)
(* A sugggested fix is that the label should have been LOCALexp *)
(* Commented out for the moment, there's something wrong here anyway *)
(* Now reinstated, hopefully better *)
      let
(** get the list of declarations, should return a
    (Environ.Env now) * (LVar * LambdaExp) list **)
	val (env', lambda_list) =
	  trans_dec (decl, env)
a739 9
(*
	    val exlvar = case Environ.lookup_valid(
	      Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
		EnvironTypes.LAMB(lv) => lv
	      (* This should be looking up as a primitive *)
	    | _ => raise(LambdaTypes.impossible("Failed to lookup bind"))
	    val excp = LambdaTypes.PRESENT(LambdaTypes.RAISE(
              LambdaTypes.VAR exlvar))
*)
a1013 5
(*
  LambdaTypes.SCON of Ident.SCon
| LambdaTypes.INT of int
| LambdaTypes.BUILTIN of Primitive
*)
d1064 31
a1094 4
  fun trans_str_exp(strexp, sigexp_opt, env) = case strexp of
    Absyn.NEWstrexp(strdec) =>
      complete_struct(trans_str_dec(strdec, env), sigexp_opt)
  | Absyn.OLDstrexp(longstrid) => raise(LambdaTypes.not_done_yet "OLDstrexp")
d1098 6
a1103 1
    raise(LambdaTypes.not_done_yet "LOCALstrexp")
d1106 2
a1107 2
    Absyn.DECstrdec(dec) => trans_dec(dec, env)
  | Absyn.STRUCTUREstrdec(struct_dec_list) =>
d1112 2
a1113 1
      let val (str_env, lambda_exp) = trans_str_exp(strexp, sigexp_opt, env)
d1129 8
a1136 1
    raise(LambdaTypes.not_done_yet("Can't translate LOCALstrdec yet"))
d1149 6
d1156 1
@


1.6
log
@Started on match compiler. Did all but Labels and Gotos
@
text
@d4 3
d38 1
d60 1
a70 1
  sharing Environ.Match = Match
d76 5
a80 1
  sharing EnvironTypes.Map = Map) : LAMBDA =
a209 8
    The difficult case of that of some nullary constructors, and
    precisely one value carrying constructor. This could be done
    in the same way as for more than one value carrying constructor,
    however, this would mean that cons cells each occupied two pair
    cells, one for the tag and value (pointer), and one for the
    actual value and tail of list.
    So, for a datatype with some value carrying constructors, we need
    to know whether there is precisely one or not.
a231 4
(*
  fun get_schemes(ty) = Map.range(get_valenv ty)
*)

a240 4
(*
  fun has_some_vcc(ty) =
    (length(filter(map type_from_scheme (get_schemes ty),
      (fn x => case x of DataTypes.FUNTYPE(_) => true | _ => false)))) <> 0
a241 5
  fun has_one_vcc(ty) =
    (length(filter(map type_from_scheme (get_schemes ty),
      (fn x => case x of DataTypes.FUNTYPE(_) => true | _ => false)))) = 1
*)

a436 5
(** Transform the match tree into EL, this is not as easy as it looks
    since we have to worry about GOTOs and LABELs in the match tree,
    see code.tex for details about what we do here. **)
	  
(** let your pointers do the walking **)
d438 52
a489 17
(** Currently this is not fully implemented - exceptions will go
    away as more of the code gets written. **)
(** Deal with any floats that can be dealt with at this level.  We
    check if we have moved up to the point where the largest
    MatchVar in a lambda is greater than or equal to the one that
    has most recently been used.  **)
  and float_up ((lambda, []), _, more) = (lambda, more)
  | float_up ((lambda,
    (head as (float_lab, float_lam, matchvar))::rest), n, more) =
    if (Match.from_Matchvar matchvar >= Match.from_Matchvar n) then
    let
      val (lamb, fl) = float_up ((lambda, rest), n, more)
    in
      (LambdaTypes.APP (LambdaTypes.FN (float_lab, lamb), float_lam), fl)
    end
    else
      float_up ((lambda, rest), n, head::more)
d495 1
a495 1
        EnvironTypes.LAMB(lv) => lv
d500 31
a530 3
      Environ.add_match_env((root, root_lambda), Environ.empty_match_env)
    fun tr_match(root, tree, match_env, val_env) =
      (* Not clear if we need root *)
a532 3
(*
 raise(LambdaTypes.not_done_yet"Match.ERROR ")
*)
d537 2
a538 1
              EnvironTypes.LAMB(Environ.lookup_match(mv, match_env))), env))
d545 3
d549 1
d551 1
a551 1
            Environ.lookup_match(mv, match_env)), map (fn(scon, tree) =>
d553 2
a554 1
                tr_match(root, tree, match_env, val_env))) scon_tree_list,
d556 2
a557 1
                    LambdaTypes.PRESENT(tr_match(root, tree, match_env, val_env))
d559 1
a559 1
		    LambdaTypes.ABSENT)
d561 1
a561 6
(*
        raise(LambdaTypes.not_done_yet"Match.SCON")
*)
(* of Matchvar * (Ident.SCon * Tree) list * Default | *)

      | Match.CONSTRUCTOR(ty, mv, valid_mv_tree_list, default) =>
d563 5
a567 1
	  val lv = LambdaTypes.VAR(Environ.lookup_match(mv, match_env))
d570 2
a571 1
	      LambdaTypes.PRESENT(tr_match(root, tree, match_env, val_env))
d574 9
a582 5
	  fun has_value valid =
	    case type_from_scheme(Map.lookup(valid, type_val_env)) of
	      DataTypes.FUNTYPE(_) => true
	    | _ => false
	  val nullary_list = filter(valid_mv_tree_list,
d584 2
d587 5
a591 2
	    map (fn (v, m, t) => (v, m, t, LambdaTypes.new_LVar()))
              (filter(valid_mv_tree_list, fn(v, _, _) => has_value v))
d593 1
d597 1
a597 1
	      let val (mv, lv, tree) = case vcc_lv_list of
d601 6
a606 2
		tr_match(root, tree,
		  Environ.add_match_env((mv, lv), match_env), val_env)
d609 1
d614 2
a615 1
		tr_match(root, tree, match_env, val_env)
d618 4
a621 3
	    LambdaTypes.SWITCH(lv, map (fn (valid, _, tree) =>
	      (LambdaTypes.CON_TAG(constructor_tag(valid, ty)),
                tr_match(root, tree, match_env, val_env))) nullary_list,
d627 17
a643 2
	    LambdaTypes.SWITCH(LambdaTypes.SELECT(LambdaTypes.toField 0, lv),
	      map (fn (valid, mv, tree, lv) =>
d645 2
a646 2
              tr_match(root, tree, Environ.add_match_env((mv, lv), match_env),
		val_env))) vcc_lv_list,
d649 1
a649 1
	      else def_lambda, LambdaTypes.ABSENT)))
a650 5
(*
        raise(LambdaTypes.not_done_yet"Match.CONSTRUCTOR")
*)
(* of Type * Matchvar * (Ident.ValId * Matchvar * Tree) list * Default | *)

d654 2
a655 2
	  val le = LambdaTypes.VAR(Environ.lookup_match(mv, match_env))
	  val new_env = foldright Environ.add_match_env
d661 2
a662 2
	  let_lambdas_in_exp(lv_le_list,
	    tr_match(root, tree, new_env, val_env))
d666 7
a672 30
	let val _ = print"Match.LABEL incomplete"
	in
	  tr_match(root, tree, match_env, val_env)
	end
(*
        raise(LambdaTypes.not_done_yet"Match.LABEL")
*)
(* of Label * Tree | *)
      | Match.GOTO(label) =>
        raise(LambdaTypes.not_done_yet"Match.GOTO")
(* of Label *)
  in
    LambdaTypes.FN(root_lambda, tr_match(root, tree, match_env, env))
  end
(*
  and trans_match ((root, tree), env, match_env) =
  let
    fun tr_match ((root, tree), subs, match_env) =
    let
(** defaults are either trees that need translating into lambda
    expressions, or are absent.  We need to return a lambda opt so for
    the present defaults we return the result of translating the match
    while for absent ones we return ABSENT.   **)
      fun trans_default (Match.PRESENT tree, root) =
      let
	val (lambda, floats) = tr_match ((root, tree), subs, match_env)
      in
	(LambdaTypes.PRESENT lambda, floats)
      end
      | trans_default (Match.ABSENT, _) = (LambdaTypes.ABSENT, [])
d674 13
a686 33
(** Deal with any floats that can be dealt with at this level.  We
    check if we have moved up to the point where the largest
    MatchVar in a lambda is greater than or equal to the one that
    has most recently been used.  **)
(** This function finds the smallest positive matchvar in a match
    tree.  We only look at positive matchvars since a dummy negative
    value is used in some places where no matchvar is applicable.
    Search is by a simple recursive scan of the relevant parts of the
    tree.  **)
      fun smallest_matchvar (tree, best_so_far) =
      let

(** Ignore negative values in the second argument, and return smaller
    of the two **)
	fun my_min current test =
	  if (Match.from_Matchvar test) < 0 orelse
	    (Match.from_Matchvar test) > (Match.from_Matchvar current) then
	    current
	  else
	    test

(** Make a call to smallest_matchvar if there was a default tree
    present.  Otherwise just find the minimum of best_so_far and the
    matchvar we were passed.  **)
	fun default_min (def, matchvar) =
	let
	  val better = my_min best_so_far matchvar
	in
	  case def of
	  Match.ABSENT => better
	| Match.PRESENT tree => smallest_matchvar (tree, better)
	end

d688 1
a688 29
	case tree of
(** Must be the best_so_far. **)
	  Match.ERROR => best_so_far
(** Look down the matchvars given in substitutions, finding the
    minimum of these and the best so far. **)
	| Match.LEAF (_, sublist) =>
	  fold my_min best_so_far (map #1 sublist)
(** Take the minimum of those matchvars mentioned in any subtree, the
 best_so_far, and any from the default tree if one is present. **)
	| Match.SCON (matchvar, it_list, def) =>
	  (fold my_min
	     (default_min (def, matchvar))
		(map (fn (scon, tree) => smallest_matchvar(tree, best_so_far))
		  it_list))
(** Just like the SCON case above. **)
	| Match.CONSTRUCTOR (_, matchvar, vmt_list, def) =>
	  (fold my_min (default_min (def, matchvar))
	    (map (fn(valid, mvar, tree) => smallest_matchvar(tree,
	      best_so_far)) vmt_list))
(** Also very similar to the SCON case, but we have a tree each time
    not like the default-tree above.  **)
	| Match.RECORD (_, matchvar, im_list, tree) =>
	  (fold my_min
	    (smallest_matchvar (tree, my_min best_so_far matchvar))
	    (map #2 im_list))
(** Trivially this is just a recursive call ignoring the label.  **)
	| Match.LABEL (_, tree) => smallest_matchvar (tree, best_so_far)
(** Must be best_so_far. **)
	| Match.GOTO _ => best_so_far
d690 6
a695 35

    in
      case tree of
(** If we get to an Error node then cause an exception MATCH to be
    raised ... **)
      Match.ERROR =>
      (LambdaTypes.RAISE (LambdaTypes.BUILTIN (Environ.FindConst "MATCH")), [])

(** We reached a leaf of the match tree, so all we need to do is use
    trans_exp to generate the required lambda expression. **)
    | Match.LEAF (exp, sublist)  =>
      let   (* get things into right form *)
	fun trans ([], env) = env
	| trans ((mv, vid, _) :: tail, env) =
	  trans(tail, Environ.add_valid_env((vid,
	  EnvironTypes.LAMB(Environ.lookup_match(mv, match_env))), env))
      in   (* tanslate the exp taking new subs into account *)
	(trans_exp (exp, trans (sublist, subs)), [])
      end
	      
(** switch on scon, translate directly into a SWITCH.  our EL is handy
    for this, having a SWITCH just like we need!  Remember to keep
    floating out any floats we get passed from lower levels. **)
    | Match.SCON (matchvar, scon_tree_list, default) =>
      let  (* convert from scon*tree to Construc*lambda *)
	fun trans ([], l_list, rest) = (rev l_list, rest)
	| trans ((scon, tree)::tail, l_list, rest) =
	let
	  val (lambda, floats) = tr_match ((matchvar, tree), subs, match_env)
	in
	  trans (tail, (LambdaTypes.SCON_TAG scon, lambda)::l_list,
            floats @@ rest)
	end
	val (ll, floats) = trans (scon_tree_list, [], [])
	val (def, dfloats) = trans_default (default, matchvar)
d697 1
a697 3
	float_up ((LambdaTypes.SWITCH (LambdaTypes.VAR(
          Environ.lookup_match(matchvar, match_env)), ll, def, def), floats @@ dfloats),
	    matchvar, [])
a698 75

(** switch on constructor, just like SCONs but have matchvars and need
    the ValIds translating into Environ.datacons . **)
    | Match.CONSTRUCTOR (ty, matchvar, valid_tree_list, default) =>
      let (* convert from ValId*MatchVar*Tree to Construc*Lambda *)
	    
	fun trans ([], l_list, rest) = (rev l_list, rest)
	| trans ((valid, match_var, tree)::tail, l_list, rest) =
	let
	  val (lambda, floats) = tr_match ((match_var, tree), subs, match_env)
(** Calculate the constructor tag value for each constructor present,
    from it's name (valid), and type.  **)
	  val the_tag = constructor_tag (valid, ty)
	in
	  trans (tail, (LambdaTypes.CON_TAG the_tag, lambda)::l_list,
            floats @@ rest)
	end

	val (ll, floats) = trans (valid_tree_list, [], [])
	val (def, dfloats) = trans_default (default, matchvar)
      in
	float_up ((LambdaTypes.SWITCH (LambdaTypes.VAR(
          Environ.lookup_match(matchvar, match_env)), ll, def, def), floats @@ dfloats),
	    matchvar, [])
      end

(** We break open the record, one piece at a time using FN application
    and SELECTs to extract the fields from the structure passed.  This
    assigns the extracted fields to the matchvars (well the
    Environ.Lvar in fact but this is a minor point), so that in the
    code generated from the tree they can be accessed properly.  **)
    | Match.RECORD (ty, matchvar, lab_match_list, tree) =>
      let
	fun trans [] = tr_match ((matchvar, tree), subs, match_env)
	| trans ((lab, match_var)::tail) =
	let
	  val (lambda, floats) = trans tail
	  val lv = LambdaTypes.new_LVar()
	  val new_me = Environ.add_match_env((match_var, lv), match_env)
	in
	  (LambdaTypes.APP (LambdaTypes.FN (lv,
            lambda), LambdaTypes.SELECT (LambdaTypes.toField(record_label_offset (lab, ty)),
	    LambdaTypes.VAR (Environ.lookup_match(matchvar, new_me)))), floats)
	end
      in
	float_up (trans lab_match_list, matchvar, [])
      end
	      
(** Remember label, compile tree. float section back to point of
    common ancestry of all references to this label.
    First check is only one reference to the label; if so we can just
    ignore the label and generate the tree here.  Otherwise we must
    arrange for a binding higher up the tree, and just make a call to
    the tree via some lambda variable... **)
    | Match.LABEL (label, subtree)  =>
      if Match.referenced_only_once label then
	tr_match ((root, subtree), subs, match_env)  (* simple way *)
      else
	let     (* hard way -- as above *)
	  val (lambda, floats) = tr_match ((root, subtree), subs, match_env)
	  val small_match = smallest_matchvar (subtree, root)
	  val lname = Environ.LabeltoLVar label
	in
	  float_up ((LambdaTypes.APP (LambdaTypes.VAR lname,
            LambdaTypes.STRUCT []),
	    (lname, lambda, small_match)::floats), root, [])
	end
		      
(** force a jump to the right piece of tree code.  See above. **)
    | Match.GOTO label =>
      (LambdaTypes.APP (LambdaTypes.VAR (Environ.LabeltoLVar label),
        LambdaTypes.STRUCT []),[])

    end

d700 2
a701 8
(** take the lambda field of the result of floating all the pieces
    back up to the top level.  The second field had better be [], or a
    serious error must have occured, since this should deal with
    anything.  **)
    case float_up (tr_match((root, tree), env, match_env), Match.to_Matchvar ~1, []) of
      (lambda, []) => lambda
    | _ => raise (LambdaTypes.impossible
      "trans_match failed: Floating labels present at top level")
a702 10
(* Deal with declarations. I'm not sure what to do with them in fact,
    as they seem to be fairly complex beasts.

    Return type is (Environ.Env * (comp * LambdaExp) list
    Requirement from above is that we return a list of all the
    results.  These are represented as a pair of Lambda and
    Environ.LVar.  These are used to bind the names to the Lambdas so
    that they can be accessed where needed.
*)
*)
a735 4
(*
	    val _ = print(if Environ.is_empty envir then "Empty env" else "Non-empty env")
	    val _ = print(EnvironPrint.printenv envir)
*)
d1136 1
a1136 1
end   (* of functor Translate *)
@


1.5
log
@Completed all value patterns. Started on match compilation
@
text
@d4 3
d102 12
d130 5
d217 5
a226 1
(*
d232 2
a233 5
  fun get_schemes(ty as
    DataTypes.FUNTYPE(_, DataTypes.CONSTYPE(_,
      DataTypes.TYNAME(_, _, _, _, ref(DataTypes.VE(_, val_env)))))) =
      Map.range val_env
  | get_schemes _ = raise(LambdaTypes.impossible "get_schemes bad type")
d236 1
a236 10
  fun get_no_cons(ty) =
  let val DataTypes.CONSTYPE(_,
      DataTypes.TYNAME(_, _, _, _, ref(DataTypes.VE(_, val_env)))) =
    case ty of
      DataTypes.FUNTYPE(_, ty') => ty'
    | DataTypes.CONSTYPE(_) => ty
    | _ => raise(LambdaTypes.impossible"get_no_cons bad type")
  in
    length(Map.domain val_env)
  end
d238 7
a446 3
(*
	raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.FNexp"))
*)
a447 3
(*	  trans_match (Match.compile_match pat_exp_list, env,
            Environ.empty_match_env)
*)
d476 6
d487 4
a490 1
	Match.ERROR => raise(LambdaTypes.not_done_yet"Match.ERROR ")
d519 15
d535 34
a608 1

a901 6
(*	      val _ = print"Handling Ident.CON"*)
	      val exlvar = case Environ.lookup_valid(
		Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
		  EnvironTypes.LAMB(lv) => lv
		(* This should be looking up as a primitive *)
		| _ => raise(LambdaTypes.impossible("Failed to lookup bind"))
a902 2
	      val excp = LambdaTypes.PRESENT(LambdaTypes.RAISE(
                LambdaTypes.VAR exlvar))
d910 4
a913 1
                      excp, LambdaTypes.ABSENT))])
a951 10
(*
		  val exlvar = case Environ.lookup_valid(
		    Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
		      EnvironTypes.LAMB(lv) => lv
		    (* This should be looking up as a primitive *)
		    | _ =>
		      raise(LambdaTypes.impossible("Failed to lookup bind"))
		  val excp = LambdaTypes.PRESENT(LambdaTypes.RAISE(
                    LambdaTypes.VAR exlvar))
*)
d957 2
a958 1
			excp, (* is a tag, but not the right one *)
d966 5
a970 1
					lexp))], excp, LambdaTypes.ABSENT))))])
d1091 3
a1093 1
	       (l, LambdaTypes.SELECT(field, lambda_exp))) valid_map
d1096 3
a1098 1
	       (l, LambdaTypes.SELECT(field, lambda_exp))) strid_map
d1193 4
a1196 2
      (map (fn (_, EnvironTypes.LAMB(lv)) => LambdaTypes.VAR(lv)) valid_list) @@
      (map (fn (_, (_, EnvironTypes.LAMB(lv))) => LambdaTypes.VAR(lv)) strid_list))))
@


1.4
log
@Finished patterns in VALdec. Did some work on module stuff,
translating structures. Started on match compilation
@
text
@d4 4
d313 1
a313 1
  fun trans_exp (x(*:Absyn.Exp*), sublist) (*: LambdaTypes.LambdaExp*) =
d328 2
a329 2
	  if (Environ.Builtin_p (longValId, sublist)) then
	    LambdaTypes.BUILTIN (Environ.FindBuiltin (longValId, sublist))
d331 1
a331 1
	    cg_longvalid(longValId, sublist)
d369 1
a369 1
	  map (fn (_, exp) => trans_exp (exp, sublist)) label_exp_list
d392 2
a393 2
	val (env, lambda_list) =
	  trans_dec (decl, sublist)
d399 1
a399 1
          trans_exp(exp, Environ.augment_env(sublist, env)))
d404 2
a405 2
      LambdaTypes.APP (trans_exp (fun_exp, sublist),
	trans_exp (val_exp, sublist))
d408 1
a408 1
    | Absyn.TYPEDexp (expression, _) => trans_exp (expression, sublist)
d410 1
a410 1
    | Absyn.RAISEexp (exp, _) => (*RAISE (trans_exp (exp, sublist))*)
d415 1
a415 1
    | Absyn.HANDLEexp (exp, pat_exp_list) =>
d417 2
a418 2
(*	  HANDLE (trans_exp (exp, sublist),
	    trans_match (Match.compile_match pat_exp_list, sublist))
d423 1
a423 1
      let val (m, tree) = Match.compile_match pat_exp_list
d427 2
d430 1
d432 1
a432 1
(*	  trans_match (Match.compile_match pat_exp_list, sublist,
d461 73
d630 1
a630 1
	  EnvironTypes.LAMB(Environ.LVarFromMV(mv, match_env))), env))
d652 1
a652 1
          Environ.LVarFromMV(matchvar, match_env)), ll, def, def), floats @@ dfloats),
d677 1
a677 1
          Environ.LVarFromMV(matchvar, match_env)), ll, def, def), floats @@ dfloats),
d693 1
a693 1
	  val new_me = Environ.MVtoLVar(match_var, lv, match_env)
d697 1
a697 1
	    LambdaTypes.VAR (Environ.LVarFromMV(matchvar, new_me)))), floats)
d740 1
a740 1
(** Deal with declarations. I'm not sure what to do with them in fact,
d748 2
a749 2
**)
  and trans_dec (some_dec, envir) =
d767 8
d804 1
d812 1
d817 1
a817 1
                  excp, excp))])
d848 1
a848 1
                      excp, excp))])
d887 1
d896 1
d910 1
a910 1
					lexp))], excp, excp))))])
d1063 1
@


1.3
log
@Added some structure handling (trans_str_dec, trans_str_exp)
@
text
@d4 3
d85 10
d132 1
a132 1
    fun domain (DataTypes.CONSTYPE (_, DataTypes.TYNAME {5 = ref (DataTypes.VE map),...})) =
a157 1

d162 1
d170 62
a231 2
(** a function, which takes an int, and returns a counter which starts
    at that point, and a function for altering the hidden counter.  **)
d308 1
d316 35
a350 5
    | Absyn.VALexp (longValId, _) =>
      if (Environ.Builtin_p (longValId, sublist)) then
	LambdaTypes.BUILTIN (Environ.FindBuiltin (longValId, sublist))
      else
	cg_longvalid(longValId, sublist)
d419 8
a426 2
      raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.FNexp"))
(*	  trans_match (Match.compile_match pat_exp_list, sublist)
d454 1
a454 1
  and trans_match any =
d456 1
a456 1
    fun tr_match ((root, tree), subs) =
d465 1
a465 1
	val (lambda, floats) = tr_match ((root, tree), subs)
d550 1
a550 1
	  EnvironTypes.LAMB(Environ.LVarFromMV mv)), env))
d563 1
a563 1
	  val (lambda, floats) = tr_match ((matchvar, tree), subs)
d572 1
a572 1
          Environ.LVarFromMV matchvar), ll, def), floats @@ dfloats),
d584 1
a584 1
	  val (lambda, floats) = tr_match ((match_var, tree), subs)
d597 1
a597 1
          Environ.LVarFromMV matchvar), ll, def), floats @@ dfloats),
d608 1
a608 1
	fun trans [] = tr_match ((matchvar, tree), subs)
d612 2
d615 1
a615 1
	  (LambdaTypes.APP (LambdaTypes.FN (Environ.MVtoLVar match_var,
d617 1
a617 1
	    LambdaTypes.VAR (Environ.LVarFromMV matchvar))), floats)
d631 1
a631 1
	tr_match ((root, subtree), subs)  (* simple way *)
d634 1
a634 1
	  val (lambda, floats) = tr_match ((root, subtree), subs)
d655 1
a655 1
    case float_up (tr_match any, Match.to_Matchvar ~1, []) of
a659 43
(*
    Determine the representation of a type. This is needed in order to
    ensure that lists are done efficiently, whereas other types require
    more complex encoding. The basic algorithm is that types with no
    value constructors are represented as small integers, types with
    more than one value constructor are represented as pointers, types
    with precisely one value constructor and no nullary constructors
    are represented in the same way as the type constructed over, and
    other types are represented in the inverse way from the type
    constructed over. E.g
    datatype t = a | b                Not a pointer (no value constructors)
    datatype int list = [] | cons of (int * int list)
                                      Not a pointer since int * int list
				      is a pointer
    datatype u = A | B(t)             Is a pointer (t is not a pointer)
    datatype v = x(t) | y(u) | z      Is a pointer (more than one value cons)
*)
  and is_pointer(ty) =
    case ty of
      DataTypes.METATYVAR(_) => raise(LambdaTypes.not_done_yet "is_pointer(METATYVAR)")
        (* of ((int * Type) ref * bool * bool) | *)
    | DataTypes.META_OVERLOADED(_) => raise(LambdaTypes.not_done_yet "is_pointer(META_OVERLOADED)")
        (* of Type ref | *)
    | DataTypes.TYVAR(_) => raise(LambdaTypes.not_done_yet "is_pointer(TYVAR)")
        (* of (int ref * Ident.TyVar) | *)
    | DataTypes.METARECTYPE(ref(_, _, ty', _, _)) => is_pointer(ty')
      (* of ((int * bool * Type * bool * bool) ref) | *)
      (* bool1 == this is an uninstantiated flex rectype,
       Type is a rectype giving flex contents if bool1 true 
       If bool1 is false, Type is a rectype giving rigid rectype 
       or a metarectype if instance of metarectype is another metarectype,
       bool2 == eq , bool3 == imp *)
    | DataTypes.RECTYPE(_) => true
        (* of (Ident.Lab,Type) Mapping.Map | *)
    | DataTypes.FUNTYPE(_) => raise(LambdaTypes.not_done_yet "is_pointer(FUNTYPE)")
        (* of (Type * Type) | *)
    | DataTypes.CONSTYPE(_) => raise(LambdaTypes.not_done_yet "is_pointer(CONSTYPE)")
        (* of ((Type list) * Tyname) | *)
    | DataTypes.DEBRUIJN(_) => raise(LambdaTypes.not_done_yet "is_pointer(DEBRUIJN)")
        (* of (int * bool * bool) | *)
    | DataTypes.NULLTYPE => raise(LambdaTypes.impossible "NULLTYPE passed to is_pointer")


d721 2
d727 1
a727 2
                  LambdaTypes.PRESENT(LambdaTypes.RAISE(
                    LambdaTypes.VAR(exlvar)))))])
d731 4
a734 1
	    Ident.VAR(symbol) => (case path of
d739 1
d742 1
a747 1
	      val is_ptr = is_pointer(!ty)
d749 2
d753 4
a756 7
		[(dummy_lv, LambdaTypes.SWITCH(if is_ptr
                  then LambdaTypes.SELECT(
		    LambdaTypes.toField 0, LambdaTypes.VAR lambda_var)
		      (* Switch on field 0 of the expression if it's
		        a pointer type, this is where the tag will be *)
		  else LambdaTypes.VAR lambda_var,
		      (* Otherwise switch on the expression itself *)
d758 1
a758 2
                      LambdaTypes.PRESENT(LambdaTypes.RAISE(
                        LambdaTypes.VAR exlvar ))))])
d783 40
a822 2
	| Absyn.APPpat((longvalid, ty), pat) =>
	  raise(LambdaTypes.not_done_yet("Absyn.VALdec APPpat"))
d972 46
a1017 7
  fun complete_struct(EnvironTypes.ENV(map1, map2), lv_le_list) =
  let val valid_list = Match_Utils.Qsort
      (fn ((valid1, _), (valid2, _)) => Ident.valid_order(valid1, valid2))
	(Map.assoc map1)
    val strid_list = Match_Utils.Qsort
      (fn ((strid1, _), (strid2, _)) => Ident.strid_order(strid1, strid2))
	(Map.assoc map2)
d1034 2
a1035 1
      let_lambdas_in_exp(lv_le_list, LambdaTypes.STRUCT(
d1040 16
a1055 2
  fun trans_str_exp(strexp, env) = case strexp of
    Absyn.NEWstrexp(strdec) => complete_struct(trans_str_dec(strdec, env))
d1064 20
a1083 2
  | Absyn.STRUCTUREstrdec(struc_dec_list) =>
    raise(LambdaTypes.not_done_yet("Can't translate STRUCTUREstrdec yet"))
@


1.2
log
@Reorganised patterns in value declarations. Handled RECORDpats
@
text
@d3 4
a6 1
$Log$
d34 12
a45 12
		   structure Ident : IDENT
		   structure Absyn : ABSYN
		   structure Match : MATCH
		   structure Environ : ENVIRON
		   structure Lists : LISTS
		   structure Integer : INTEGER
		   structure Match_Utils : MATCH_UTILS
		   structure Types: TYPES
		   structure Symbol: SYMBOL
		   structure LambdaTypes: LAMBDATYPES
		   structure EnvironTypes: ENVIRONTYPES
		   structure Map: MAP
d47 2
a48 2
		   structure EnvironPrint: ENVIRONPRINT
		   sharing EnvironPrint.EnvironTypes = EnvironTypes
d50 13
a62 14
		   sharing DataTypes.Ident = Ident
		   sharing Absyn.IdentClass = Ident
		   sharing Match.Datatypes = DataTypes
		   sharing Absyn.Datatypes = DataTypes
		   sharing Types.Datatypes = DataTypes
		   sharing Match.Absyn = Absyn
		   sharing Environ.Match = Match
		   sharing Environ.Ident = Ident
		   sharing Ident.Symbol = Symbol
		   sharing Environ.LambdaTypes = LambdaTypes
		   sharing Environ.EnvironTypes = EnvironTypes
		   sharing DataTypes.Mapping = Map
		   sharing EnvironTypes.Map = Map
		     ) : LAMBDA =
d64 5
a68 5
      structure Absyn = Absyn
      structure EnvironTypes = EnvironTypes
      structure Match = Match
      structure LambdaTypes = LambdaTypes
      structure Ident = Ident
d71 2
a72 3
      val length = Lists.length
      val fold = Lists.foldr (* this may not be the right fold *)
			     (* function. ******* Sort out later *)
d74 3
d78 1
a78 10
(** This exception is raised from places in the code that should not
    be reachable normally.  The string it returns says what was wrong,
    and should give some hints (to me at least), as to what should be
    done to fix it.
    
    Currently any part which is not implemented will also raise an
    'impossible' saying which part of the code wasn't present that was
    attempted to be used, causing the error.
    
**)
d80 1
a80 4
(** Define the extended lambda calculus that we will use to represent
    the intermediate code during translation.  This piece of code
    takes parsed, type-checked SML and generates EL.  Some time later
    this EL will get translated into code for the real machine.
d82 2
a83 3
    Environ is a structure defining Lvar lookup, primitive operations,
    data constructors and destructors, and other general environmental
    functions.
d85 12
a96 68
    Environ.MVtoLVar binds a lambda variable to a matchvar.

    Environ.LVarFromMV just looks up from a MatchVar (int), to a lambda
    variable (which is also a number... (but needs to check that it is
    unique etc...))

    Environ.LabeltoLVar just transforms a label number to a lambda variable

    Colin has explained to me that in order to work properly with the
    modules stuff I have to maintain a fairly complex environment.

    Env : SE x VE
    SE  : StrID -> Env
    VE  : valid -> (LVar | field-offset)

    where ENV is the environment, SE is the Structure Environment, and
    a VE is a Value Environment.  The point of VE mapping valids to
    field-offsets is to allow the following of longvalids though the
    structures to arrive at the final LVar which it represents.

**)

	  fun known_order ((lab1, _), (lab2, _)) =
	    Ident.lab_order (lab1, lab2)
(*
      type LVar = Environ.LVar           (* The type of lambda variables *)

  datatype 'a Opt = PRESENT of 'a | ABSENT
  datatype Construc =
    CON_TAG of int           (* basic datatype tagging type *)
  | SCON_TAG of Ident.SCon   (* simple int, real, string ... *)
  datatype Lambda =
    VAR of LVar                    (* variable lookup *)
  | FN of (LVar * Lambda)          (* function definition *)
  | LETREC of                      (* allows recursive definitions *)
    (LVar list * Lambda list * Lambda)
  | APP of (Lambda * Lambda)       (* function application *)
  | SCON of Ident.SCon             (* int, real, string ... *)
  | SWITCH of                      (* like a case statement *)
    (Lambda * (Construc * Lambda) list * Lambda Opt)
  | STRUCT of Lambda list          (* structure definition *)
  | SELECT of (int * Lambda)       (* field selector *)
  | RAISE of Lambda                (* Exceptions --- throw ... *)
  | HANDLE of (Lambda * Lambda)    (*            ... and catch *)
  | BUILTIN of Environ.primitive   (* built-in functions --
				    These functions are
				    primitive to the abstract
				    machine. *)
(* For some stupid reason we have to repeat this information both *)
(* within the signature and the functor. IMHO, this is really stupid! *)
*)

      fun known_order ((lab1, _), (lab2, _)) = Ident.lab_order (lab1, lab2)
(** search for a value in a list of such objects, returning it's
    position if found, or raising an exception **)

      fun position (target, domain, error_to_raise) =
      let
	fun position' (head::tail, n) =
	  if target = head then
	    n
	  else
	    position' (tail, n+1)
        | position' ([], _) =
	  raise error_to_raise
      in
	position' (domain, 0)
      end
d105 2
a106 2
      fun constructor_tag (valid,ty) =
      let
d111 6
a116 6
	val constype =
	  case ty of
	    DataTypes.FUNTYPE (_,ty') => ty'
	  | DataTypes.CONSTYPE _      => ty
	  | _                         =>
            raise (LambdaTypes.impossible "constructor_tag(1)")
d119 3
a121 3
	fun domain (DataTypes.CONSTYPE (_, DataTypes.TYNAME {5 = ref (DataTypes.VE map),...})) =
	  Map.domain map
	| domain _ = raise (LambdaTypes.impossible "constructor_tag(2)")
d123 6
a128 6
      in
	position (valid, domain constype,
	  (LambdaTypes.impossible ("constructor_tag(3): "
	  ^ Types.print_type ty ^ "," 
	  ^ DataTypes.IdentPrint.printValId valid)))
      end
d135 2
a136 2
      fun record_label_offset (lab, the_type) =
      let
d139 6
a144 5
	fun domain (DataTypes.RECTYPE map) = Map.domain map
	| domain _ = raise (LambdaTypes.impossible "record_tag(2)")
      in
        position (lab, domain the_type, LambdaTypes.impossible "record_tag(1)")
      end
d146 11
a158 22
(* Abstracted out
      fun make_counter n =
      let
	val foo = ref n
      in
	((fn () =>
        let
	  val bar = !foo
	  val _ = (foo := bar + 1)
        in
	  bar
	end),
	(fn x => (foo := x)))
      end
*)

(** a function, which generates Lambda variables starting at 0, and
    one for adjusting where we count for. **)
(*      val (new_LVar : (unit -> LVar),
	alter_LVar_count : (LVar -> unit))  = make_counter 0
abstracted out *)

d164 12
a175 12
      fun lookup_lvar longvalid =
      let
	fun search ((lvi, lvar)::rest) =
	  if lvi = longvalid then
	    (lvar: LambdaTypes.LVar)
	  else
	    search rest
        | search [] =   (* Woops it isn't in the list *)
	  raise (LambdaTypes.impossible "LVar lookup failed")
      in
        search
      end
d177 52
d235 2
a236 30
      fun cg_longvalid (longvalid, env) = case longvalid of
	Ident.LONGVALID(Ident.NOPATH, valid) =>
          (case Environ.lookup_valid(valid, env) of
	    EnvironTypes.LAMB(lvar) => LambdaTypes.VAR(lvar)
	  | _ => raise(LambdaTypes.impossible "cg_longvalid does not give LVar"))
      | Ident.LONGVALID(path, valid) => let
        fun get_lamb_env(strid, env) = let
	  val (env', lvar) = case Environ.lookup_strid(strid, env) of
	    (env'', EnvironTypes.LAMB(lvar)) => (env'', lvar)
	  | _ => raise(LambdaTypes.impossible "cg_longvalid does not give LVar")
        in
	  (env', LambdaTypes.VAR(lvar))
        end
	fun get_field_env(strid, (env, lambda)) = let
	  val (env', field) = case Environ.lookup_strid(strid, env) of
	    (env'', EnvironTypes.FIELD(field)) => (env'', field)
	  | _ => raise(LambdaTypes.impossible "get_field_env fails to get field")
	in
	  (env', LambdaTypes.SELECT(field, lambda))
	end
        val (env', lambda) =
          Ident.followPath'(get_lamb_env, get_field_env) (path, env)
	val field = case Environ.lookup_valid(valid, env') of
	  EnvironTypes.FIELD(field) => field
	| _ => raise(LambdaTypes.impossible "cg_longvalid fails to get field")
      in
	LambdaTypes.SELECT(field, lambda)
      end
      fun trans_exp (x(*:Absyn.Exp*), sublist) (*: LambdaTypes.LambdaExp*) =
	case x of
d238 1
a238 1
	  Absyn.SCONexp sc => LambdaTypes.SCON sc
d242 5
a246 5
	| Absyn.VALexp (longValId, _) =>
	  if (Environ.Builtin_p (longValId, sublist)) then
	    LambdaTypes.BUILTIN (Environ.FindBuiltin (longValId, sublist))
	  else
	    cg_longvalid(longValId, sublist)
d251 2
a252 2
	| Absyn.RECORDexp label_exp_list  =>
	  let
d255 15
a269 7
    represented by a STRUCT with the same field ordering. **)
	  fun known_order ((lab1, _), (lab2, _)) =
	    Ident.lab_order (lab1, lab2)
	  in
	    LambdaTypes.STRUCT (map(fn (_, exp) => trans_exp (exp, sublist))
	      (Match_Utils.Qsort known_order label_exp_list))
	  end
d271 1
a271 1
(** Local declarations are tough, so we code up the declaration, and
d275 1
a275 1
	| Absyn.LOCALexp (decl, exp) => (* Was LOCALdec *)
d279 3
a281 2
(* Commented out for the moment, there's something wrong here anyway
	  let
d283 3
a285 2
    (Lambda * Environ.LVar) list (Environ.Env now) **)
	    val dec_code = trans_dec (decl, sublist, Environ.empty_env)
d289 4
a292 7
	    fun trans [] = trans_exp (exp, sublist)
	    | trans ((name, lambda)::tail) =
	      APP (FN (name, trans tail), lambda)
	  in
	    trans dec_code
*)
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.LOCALexp"))
d295 3
a297 6
	| Absyn.APPexp (fun_exp, val_exp) =>
(*
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.APPexp"))
*)
	  LambdaTypes.APP (trans_exp (fun_exp, sublist),
	    trans_exp (val_exp, sublist))
d299 2
a300 4
    expression **)
	| Absyn.TYPEDexp (expression, _) => (*trans_exp (expression, sublist)*)
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.TYPEDexp"))

d302 4
a305 4
	| Absyn.RAISEexp (exp, _) => (*RAISE (trans_exp (exp, sublist))*)
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.RAISEexp"))
		(* Later this might want to do something with the list *)
		(* of marks, but for now we ignore them *)
d307 2
a308 2
	| Absyn.HANDLEexp (exp, pat_exp_list) =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.HANDLEexp"))
d314 2
a315 2
	| Absyn.FNexp (pat_exp_list, _, _) =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.FNexp"))
d318 2
a319 2
	| Absyn.TEN15exp (_) =>
	      raise(LambdaTypes.impossible("TEN15exp found"))
d332 11
a342 11
      and float_up ((lambda, []), _, more) = (lambda, more)
      | float_up ((lambda,
	(head as (float_lab, float_lam, matchvar))::rest), n, more) =
	if (Match.from_Matchvar matchvar >= Match.from_Matchvar n) then
	  let
	    val (lamb, fl) = float_up ((lambda, rest), n, more)
	  in
	    (LambdaTypes.APP (LambdaTypes.FN (float_lab, lamb), float_lam), fl)
	  end
	else
          float_up ((lambda, rest), n, head::more)
d344 4
a347 4
      and trans_match any =
      let
	fun tr_match ((root, tree), subs) =
	let
d353 7
a359 7
	  fun trans_default (Match.PRESENT tree, root) =
	    let
	      val (lambda, floats) = tr_match ((root, tree), subs)
	    in
	      (LambdaTypes.PRESENT lambda, floats)
	    end
	  | trans_default (Match.ABSENT, _) = (LambdaTypes.ABSENT, [])
a364 18
(* This version seems to be in the wrong place
		  fun float_up ((lambda, []), _, more) = (lambda, more)
		    | float_up ((lambda,
				 (head as (float_lab,
					   float_lam,
					   matchvar))::rest),
				n, more) =
		      if (Match.from_Matchvar matchvar >=
			  Match.from_Matchvar n) then
			let
			  val (lamb, fl) = float_up ((lambda, rest), n, more)
			in
			  (APP (FN (float_lab, lamb), float_lam), fl)
			end
		      else
			float_up ((lambda, rest), n, head::more)
so we ignore it for the moment. *)

d370 2
a371 2
	  fun smallest_matchvar (tree, best_so_far) =
	  let
d375 6
a380 6
	    fun my_min current test =
	      if (Match.from_Matchvar test) < 0 orelse
		(Match.from_Matchvar test) > (Match.from_Matchvar current) then
		current
	      else
		test
d385 8
a392 8
	    fun default_min (def, matchvar) =
	    let
	      val better = my_min best_so_far matchvar
	    in
	      case def of
		Match.ABSENT => better
	      | Match.PRESENT tree => smallest_matchvar (tree, better)
	    end
d394 2
a395 2
	  in
	    case tree of
d397 1
a397 1
	      Match.ERROR => best_so_far
d400 2
a401 2
	    | Match.LEAF (_, sublist) =>
	      fold my_min best_so_far (map #1 sublist)
d404 3
a406 6
	    | Match.SCON (matchvar, it_list, def) =>
	      (fold my_min
		(default_min (def, matchvar))
(* This line is wrong
			     (map (smallest_matchvar o #2) it_list)
Replace it by*)
d410 4
a413 9
	    | Match.CONSTRUCTOR (_, matchvar, vmt_list, def) =>
	      (fold my_min
	        (default_min (def, matchvar))
(* This line is wrong
                  (map (smallest_matchvar o #3) vmt_list)
Replace it by*)
		(map (fn(valid, mvar, tree) => smallest_matchvar(tree,
		  best_so_far))
		  vmt_list))
d416 4
a419 4
	    | Match.RECORD (_, matchvar, im_list, tree) =>
	      (fold my_min
	        (smallest_matchvar (tree, my_min best_so_far matchvar))
		(map #2 im_list))
d421 1
a421 1
	    | Match.LABEL (_, tree) => smallest_matchvar (tree, best_so_far)
d423 2
a424 2
	    | Match.GOTO _ => best_so_far
	  end
d426 2
a427 2
	in
	  case tree of
d430 2
a431 2
	    Match.ERROR =>
	      (LambdaTypes.RAISE (LambdaTypes.BUILTIN (Environ.FindConst "MATCH")), [])
d435 9
a443 12
	  | Match.LEAF (exp, sublist)  =>
	  let   (* get things into right form *)
(* No longer correct
	    fun trans (mv, vid, _) = (mv, vid)
Replace by *)
	    fun trans ([], env) = env
	    | trans ((mv, vid, _) :: tail, env) =
	      trans(tail, Environ.add_valid_env(vid,
                EnvironTypes.LAMB(Environ.LVarFromMV mv), env))
	  in   (* tanslate the exp taking new subs into account *)
	    (trans_exp (exp, trans (sublist, subs)), [])
	  end
d448 17
a464 17
	  | Match.SCON (matchvar, scon_tree_list, default) =>
	  let  (* convert from scon*tree to Construc*lambda *)
	    fun trans ([], l_list, rest) = (rev l_list, rest)
	    | trans ((scon, tree)::tail, l_list, rest) =
	    let
	      val (lambda, floats) = tr_match ((matchvar, tree), subs)
	    in
	      trans (tail, (LambdaTypes.SCON_TAG scon, lambda)::l_list,
                floats @@ rest)
	    end
	    val (ll, floats) = trans (scon_tree_list, [], [])
	    val (def, dfloats) = trans_default (default, matchvar)
	  in
	    float_up ((LambdaTypes.SWITCH (LambdaTypes.VAR(
              Environ.LVarFromMV matchvar), ll, def), floats @@ dfloats),
                matchvar, [])
	  end
d468 7
a474 7
	  | Match.CONSTRUCTOR (ty, matchvar, valid_tree_list, default) =>
	  let (* convert from ValId*MatchVar*Tree to Construc*Lambda *)

	    fun trans ([], l_list, rest) = (rev l_list, rest)
	    | trans ((valid, match_var, tree)::tail, l_list, rest) =
	    let
	      val (lambda, floats) = tr_match ((match_var, tree), subs)
d477 5
a481 5
	      val the_tag = constructor_tag (valid, ty)
	    in
	      trans (tail, (LambdaTypes.CON_TAG the_tag, lambda)::l_list,
                floats @@ rest)
	    end
d483 8
a490 8
	    val (ll, floats) = trans (valid_tree_list, [], [])
	    val (def, dfloats) = trans_default (default, matchvar)
	  in
	    float_up ((LambdaTypes.SWITCH (LambdaTypes.VAR(
              Environ.LVarFromMV matchvar), ll, def), floats @@ dfloats),
		matchvar, [])
	  end
	      
d496 14
a509 14
	  | Match.RECORD (ty, matchvar, lab_match_list, tree) =>
	  let
	    fun trans [] = tr_match ((matchvar, tree), subs)
	    | trans ((lab, match_var)::tail) =
	    let
	      val (lambda, floats) = trans tail
	    in
	      (LambdaTypes.APP (LambdaTypes.FN (Environ.MVtoLVar match_var,
                lambda), LambdaTypes.SELECT (LambdaTypes.toField(record_label_offset (lab, ty)),
		  LambdaTypes.VAR (Environ.LVarFromMV matchvar))), floats)
	    end
	  in
	    float_up (trans lab_match_list, matchvar, [])
	  end
d517 13
a529 13
	  | Match.LABEL (label, subtree)  =>
	    if Match.referenced_only_once label then
	      tr_match ((root, subtree), subs)  (* simple way *)
	    else
	      let     (* hard way -- as above *)
		val (lambda, floats) = tr_match ((root, subtree), subs)
		val small_match = smallest_matchvar (subtree, root)
		val lname = Environ.LabeltoLVar label
	      in
		float_up ((LambdaTypes.APP (LambdaTypes.VAR lname,
                  LambdaTypes.STRUCT []),
		  (lname, lambda, small_match)::floats), root, [])
	      end
d532 3
a534 3
	  | Match.GOTO label =>
	    (LambdaTypes.APP (LambdaTypes.VAR (Environ.LabeltoLVar label),
              LambdaTypes.STRUCT []),[])
d536 1
a536 1
	end
d538 1
a538 1
      in
d543 5
a547 5
	case float_up (tr_match any, Match.to_Matchvar ~1, []) of
	  (lambda, []) => lambda
	| _ => raise (LambdaTypes.impossible
	  "trans_match failed: Floating labels present at top level")
      end
d565 3
a567 3
    and is_pointer(ty) =
      case ty of
	DataTypes.METATYVAR(_) => raise(LambdaTypes.not_done_yet "is_pointer(METATYVAR)")
d569 1
a569 1
      | DataTypes.META_OVERLOADED(_) => raise(LambdaTypes.not_done_yet "is_pointer(META_OVERLOADED)")
d571 1
a571 1
      | DataTypes.TYVAR(_) => raise(LambdaTypes.not_done_yet "is_pointer(TYVAR)")
d573 1
a573 1
      | DataTypes.METARECTYPE(ref(_, _, ty', _, _)) => is_pointer(ty')
d580 1
a580 1
      | DataTypes.RECTYPE(_) => true
d582 1
a582 1
      | DataTypes.FUNTYPE(_) => raise(LambdaTypes.not_done_yet "is_pointer(FUNTYPE)")
d584 1
a584 1
      | DataTypes.CONSTYPE(_) => raise(LambdaTypes.not_done_yet "is_pointer(CONSTYPE)")
d586 1
a586 1
      | DataTypes.DEBRUIJN(_) => raise(LambdaTypes.not_done_yet "is_pointer(DEBRUIJN)")
d588 1
a588 1
      | DataTypes.NULLTYPE => raise(LambdaTypes.impossible "NULLTYPE passed to is_pointer")
d600 1
a600 1
      and trans_dec (some_dec, subs, envir) =
d606 1
a606 2
	 * from these decs, in order to update the overall dec when they
	 * have all been handled.
d611 15
a625 8
	case some_dec of
	  Absyn.VALdec ([], [], _) => (Environ.augment_env(envir, subs), [])
	  (* No more to do *)
	| Absyn.VALdec ([], x, _) =>
	  raise(LambdaTypes.not_done_yet("Absyn.VALdec ([], recursive_decs, _)"))
	| Absyn.VALdec ((pat, exp) :: tl, rec_list, tyvar) =>
	  let val lvar = LambdaTypes.new_LVar()
	    val lambda = trans_exp(exp, envir)
d630 40
a669 19
	    fun trans_individual_dec(pattern, lambda_var) = case pattern of
	      Absyn.WILDpat => (Environ.empty_env, [])
	      (* The above lambda is a dummy, and will not be referenced *)
	      (* in this case. No additional environment generated *)
	    | Absyn.SCONpat(scon) =>
	      (* This comes about for instance in cases like val (1,x) = y *)
	      (* or even val 1 = 1 (rather stupid!) *)
	      (* We translate it effectively to *)
	      (* dummy_lambda = if scon = exp then exp else raise(bind) *)
	      (* We further abstract out exp in order to avoid *)
	      (* recalculating it, vis *)
	      (* dummy_lambda = let dummy_lambda' = exp *)
	      (* in if scon = dummy_lambda' then dummy_lambda' *)
              (* else raise(bind) end *)
	      (* We also cheat slightly, treating it as two *)
	      (* separate declarations *)
	      let val dummy_lv = LambdaTypes.new_LVar()
		val exlvar = case Environ.lookup_valid(
		  Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
d671 1
a671 1
		  (* This should be looking up as a primitive *)
d673 12
a684 4
	      in
		(Environ.empty_env,
		  [(dummy_lv, LambdaTypes.SWITCH(LambdaTypes.VAR(lambda_var),
                    [(LambdaTypes.SCON_TAG(scon), LambdaTypes.VAR(lambda_var))],
a685 24
                        LambdaTypes.VAR(exlvar)))))])
	      end
	    | Absyn.VALpat(Ident.LONGVALID(path, valid), ty) =>
	      (case (valid) of
		Ident.VAR(symbol) => (case path of
		  Ident.NOPATH => (Environ.add_valid_env(valid,
		    EnvironTypes.LAMB(lambda_var), Environ.empty_env), [])
		| Ident.PATH(_) => raise(LambdaTypes.impossible
                  "Long valid with non-empty path to trans_dec"))
	      | Ident.CON(con) =>
	        let val dummy_lv = LambdaTypes.new_LVar()
		  val exlvar = case Environ.lookup_valid(
		  Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
		  EnvironTypes.LAMB(lv) => lv
		  (* This should be looking up as a primitive *)
		| _ => raise(LambdaTypes.impossible("Failed to lookup bind"))
		in
		  (Environ.empty_env,
		    [(dummy_lv, LambdaTypes.SWITCH(if is_pointer(!ty)
                      then LambdaTypes.SELECT(LambdaTypes.toField 1,
                        LambdaTypes.VAR(lambda_var))
                      else LambdaTypes.VAR(lambda_var),
		      [(LambdaTypes.CON_TAG(1), LambdaTypes.VAR(lambda_var))],
                      LambdaTypes.PRESENT(LambdaTypes.RAISE(
d687 21
a707 38
		end
	      | Ident.EXCON(excon) => (Environ.empty_env, []))
	      (* Last two just like WILDpat for the present. Should *)
	      (* actually destructure the result and raise bind if necessary *)
	    | Absyn.RECORDpat(lab_pat_list, flex, ty) =>
	      if flex
		then raise(LambdaTypes.not_done_yet"Absyn.VALdec RECORDpat (flex)")
	      else
		let val ordered_list =
		  Match_Utils.Qsort known_order lab_pat_list
		  fun handle_record_list([], lambda_exp, _) =
		    (Environ.empty_env, [])
		  | handle_record_list((_, pat) :: tl, lambda_exp, i) =
		    let val lv = LambdaTypes.new_LVar()
		      val le = LambdaTypes.SELECT(LambdaTypes.toField i,
			lambda_exp)
		      val (env, lam) = trans_individual_dec(pat, lv)
		      val (rest_env, rest_lam) =
			handle_record_list(tl, lambda_exp, i+1)
		    in
		      (Environ.augment_env(env, rest_env),
		        (lv, le) :: lam @@ rest_lam)
		    end
		in
		  handle_record_list(ordered_list, LambdaTypes.VAR(lambda_var),
		    1)
		end
	    | Absyn.APPpat(app) =>
	      raise(LambdaTypes.not_done_yet("Absyn.VALdec APPpat"))
	    | Absyn.TYPEDpat(typed, _) =>
	      trans_individual_dec(typed, lambda_var)
	      (* Just ignore the type here *)
	    | Absyn.LAYEREDpat(layered) =>
	      raise(LambdaTypes.not_done_yet("Absyn.VALdec LAYEREDpat"))
	    val (more_env, more_lambda) = trans_individual_dec(pat, lvar)
	    val (rest_env, rest_lambda) =
              trans_dec(Absyn.VALdec(tl, rec_list, tyvar),
                Environ.augment_env(subs, more_env), envir)
d709 1
a709 1
	    (rest_env, (lvar, lambda) :: more_lambda @@ rest_lambda)
d711 22
a732 7
(*
	  val (tl_env, tl_lambda) =
	    trans_dec(Absyn.VALdec(tl, rec_list, tyvar), new_sub, envir)
	  in
	    (tl_env, new_lambda @@ tl_lambda)
	  end
*)
d778 5
a782 2
	| Absyn.TYPEdec typeinfo_list =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.TYPEdec"))
a783 10
	| Absyn.DATATYPEdec datatypeinfo_list =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.DATATYPEdec"))

	| Absyn.ABSTYPEdec (abstypeinfo_list, dec) =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.ABSTYPEdec"))

	| Absyn.EXCEPTIONdec except_list =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.EXCEPTIONdec"))


d787 56
a842 7
    which to perfom the translation, this is trivial. **)
	| Absyn.LOCALdec (dec1, dec2) =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.LOCALdec"))
(*	  trans_dec (dec2, subs, trans_dec (dec1, subs, envir))
*)
	| Absyn.OPENdec longStrId_list =>
	  raise(LambdaTypes.not_done_yet("Dunno how to deal with Absyn.OPENdec"))
d849 6
a854 12
	| Absyn.SEQUENCEdec dec_list =>
	let
	  fun trans ([], full_env) = (full_env, [])
	  | trans (head::tail, full_env) =
	  let val (env, lambda) = trans_dec (head, Environ.empty_env, full_env)
	    val (env', lambda') = trans (tail, env)
	    val _ = if not (Environ.is_empty subs) then
	      raise(LambdaTypes.impossible "Absyn.SEQUENCEdec passed non-empty set of subs")
	      else ()
	  in
	    (env', lambda @@ lambda')
	  end
d856 1
a856 1
	  trans (dec_list, envir)
d858 58
a916 1
  
@


1.1
log
@Initial revision
@
text
@d2 5
d16 3
a18 1

d21 1
d30 1
a30 1
functor Translate (structure Datatypes : DATATYPES
d40 3
d44 4
a47 1
		   sharing Datatypes.Ident = Ident
d49 3
a51 3
		   sharing Match.Datatypes = Datatypes
		   sharing Absyn.Datatypes = Datatypes
		   sharing Types.Datatypes = Datatypes
d56 4
d61 1
a61 2
    struct
      structure Datatypes = Datatypes
d63 1
a63 1
      structure Environ = Environ
d65 2
a66 1
      open Datatypes
a83 2
      exception impossible = Environ.impossible
      exception not_done_yet = Environ.not_done_yet
d116 3
d144 1
d146 1
d178 4
a181 3
	    FUNTYPE (_,ty') => ty'
	  | CONSTYPE _      => ty
	  | _               => raise (impossible "constructor_tag(1)")
d184 3
a186 3
	fun domain (CONSTYPE (_, TYNAME {5 = ref (VE map),...})) =
	  Mapping.domain map
	| domain _ = raise (impossible "constructor_tag(2)")
d190 1
a190 1
	  (impossible ("constructor_tag(3): "
d192 1
a192 1
	  ^ IdentPrint.printValId valid)))
d204 2
a205 2
	fun domain (RECTYPE map) = Mapping.domain map
	| domain _ = raise (impossible "record_tag(2)")
d207 1
a207 1
        position (lab, domain the_type, impossible "record_tag(1)")
d243 1
a243 1
	    (lvar: LVar)
d247 1
a247 1
	  raise (impossible "LVar lookup failed")
d261 2
a262 2
	    Environ.LAMB(lvar) => VAR(lvar)
	  | _ => raise(impossible "cg_longvalid does not give LVar"))
d266 2
a267 2
	    (env'', Environ.LAMB(lvar)) => (env'', lvar)
	  | _ => raise(impossible "cg_longvalid does not give LVar")
d269 1
a269 1
	  (env', VAR(lvar))
d273 2
a274 2
	    (env'', Environ.FIELD(field)) => (env'', field)
	  | _ => raise(impossible "get_field_env fails to get field")
d276 1
a276 1
	  (env', SELECT(field, lambda))
d281 2
a282 2
	  Environ.FIELD(field) => field
	| _ => raise(impossible "cg_longvalid fails to get field")
d284 1
a284 1
	SELECT(field, lambda)
d286 1
a286 1
      fun trans_exp (x:Absyn.Exp, sublist) : Lambda =
d289 1
a289 1
	  Absyn.SCONexp sc => SCON sc
a293 3
(*
	  raise(not_done_yet("Dunno how to deal with Absyn.VALexp"))
*)
d295 1
a295 1
	    BUILTIN (Environ.FindBuiltin (longValId, sublist))
d303 1
a303 3
	  raise(not_done_yet("Dunno how to deal with Absyn.RECORDexp"))
(*	  let

d306 1
a306 1
    represented by a STRUCT with the same field odering. **)
d310 1
a310 1
	    STRUCT (map	(fn (_, exp) => trans_exp (exp, sublist))
d313 1
a313 1
*)
d336 1
a336 1
	  raise(not_done_yet("Dunno how to deal with Absyn.LOCALexp"))
d341 1
a341 1
	  raise(not_done_yet("Dunno how to deal with Absyn.APPexp"))
d343 1
a343 1
	  APP (trans_exp (fun_exp, sublist),
d348 1
a348 1
	  raise(not_done_yet("Dunno how to deal with Absyn.TYPEDexp"))
d352 1
a352 1
	  raise(not_done_yet("Dunno how to deal with Absyn.RAISEexp"))
d357 1
a357 1
	  raise(not_done_yet("Dunno how to deal with Absyn.HANDLEexp"))
d364 1
a364 1
	  raise(not_done_yet("Dunno how to deal with Absyn.FNexp"))
d368 1
a368 1
	      raise(impossible("TEN15exp found"))
d388 1
a388 1
	    (APP (FN (float_lab, lamb), float_lam), fl)
d406 1
a406 1
	      (PRESENT lambda, floats)
d408 1
a408 1
	  | trans_default (Match.ABSENT, _) = (ABSENT, [])
d506 1
a506 1
	      (RAISE (BUILTIN (Environ.FindConst "MATCH")), [])
d518 1
a518 1
                Environ.LAMB(Environ.LVarFromMV mv), env))
d533 2
a534 1
	      trans (tail, (SCON_TAG scon, lambda)::l_list, floats @@ rest)
d539 3
a541 2
	    float_up ((SWITCH (VAR (Environ.LVarFromMV matchvar), ll, def),
	      floats @@ dfloats), matchvar, [])
d557 2
a558 1
	      trans (tail, (CON_TAG the_tag, lambda)::l_list, floats @@ rest)
d564 3
a566 2
	    float_up ((SWITCH (VAR (Environ.LVarFromMV matchvar), ll, def),
	      floats @@ dfloats), matchvar, [])
d581 3
a583 3
	      (APP (FN (Environ.MVtoLVar match_var, lambda),
		SELECT (record_label_offset (lab, ty),
		VAR (Environ.LVarFromMV matchvar))), floats)
d604 2
a605 1
		float_up ((APP (VAR lname, STRUCT []),
d611 2
a612 1
	    (APP (VAR (Environ.LabeltoLVar label), STRUCT []),[])
d623 1
a623 1
	| _ => raise (impossible
d626 41
d668 1
d672 2
a673 2
    Return type is (Environ.Env) list
    Requrement from above is that we return a list of all the
d694 1
a694 1
	  raise(not_done_yet("Absyn.VALdec ([], recursive_decs, _)"))
d696 100
a795 44
	  let val (new_sub, new_lambda) = case pat of
	    Absyn.WILDpat => (subs,
              [(Environ.new_LVar(), trans_exp(exp, envir))])
	    (* The above lambda is a dummy, it will not be referenced *)
	    (* No additional environment generated *)
	  | Absyn.SCONpat(scon) =>
	    (* This comes about for instance in cases like val (1,x) = y *)
	    (* We translate it effectively to *)
	    (* dummy_lambda = if scon = exp then exp else raise(bind) *)
	    (* We further abstract out exp in order to avoid *)
	    (* recalculating it, vis *)
	    (* dummy_lambda = let dummy_lambda' = exp *)
	    (* in if scon = exp then exp else raise(bind) end *)
	    (* We also cheat slightly, treating it as two *)
	    (* separate declarations *)
	    let val l1 = Environ.new_LVar()
	      val l2 = Environ.new_LVar() (* The two dummy lambdas *)
	      val comp = case Environ.lookup_valid(
		Ident.EXCON(Symbol.find_symbol "bind" ), envir) of
		Environ.LAMB(lvar) => lvar
	      | _ => raise(impossible("Failed to lookup bind"))
	    in
	      (subs, [(l1, trans_exp (exp, envir)),
		(l2, SWITCH(VAR(l1), [(SCON_TAG(scon), VAR(l2))],
		  PRESENT(RAISE(VAR(comp)))))])
	    end
	  | Absyn.VALpat(Ident.LONGVALID(_, valid), ty) => let
	      val l1 = Environ.new_LVar()
	      val var_env = Environ.add_valid_env(valid,
		Environ.LAMB(l1), subs)
	    in
	      (var_env, [(l1, trans_exp (exp, envir))]) (* Temporary fudge *)
	    end
	  | Absyn.RECORDpat(record) =>
	    raise(not_done_yet("Absyn.VALdec ([RECORDpat, exp], [], something)"))
	  | Absyn.APPpat(app) =>
	    raise(not_done_yet("Absyn.VALdec ([APPpat, exp], [], something)"))
	  | Absyn.TYPEDpat(typed, _) =>
	    trans_dec(Absyn.VALdec((typed, exp) :: tl, rec_list, tyvar),
              subs, envir)
	    (* This just produces an environment which is too big, *)
	    (* but it doesn't matter *)
	  | Absyn.LAYEREDpat(layered) =>
	    raise(not_done_yet("Absyn.VALdec ([LAYEREDpat, exp], [], something)"))
d801 1
d848 1
a848 1
	  raise(not_done_yet("Dunno how to deal with Absyn.TYPEdec"))
d851 1
a851 1
	  raise(not_done_yet("Dunno how to deal with Absyn.DATATYPEdec"))
d854 1
a854 1
	  raise(not_done_yet("Dunno how to deal with Absyn.ABSTYPEdec"))
d857 1
a857 1
	  raise(not_done_yet("Dunno how to deal with Absyn.EXCEPTIONdec"))
d865 1
a865 1
	  raise(not_done_yet("Dunno how to deal with Absyn.LOCALdec"))
d869 1
a869 1
	  raise(not_done_yet("Dunno how to deal with Absyn.OPENdec"))
d877 2
a878 3
	  raise(not_done_yet("Dunno how to deal with Absyn.SEQUENCEdec"))
(*	let
	  fun trans ([], full_env) = full_env
d880 8
a887 1
	    trans (tail, trans_dec (head, subs, full_env))
d891 1
a891 2
*)
    end   (* of functor Translate *)
@
