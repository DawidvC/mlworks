head	1.83;
access;
symbols
	MLW_daveb_inline_1_4_99:1.83.8
	MLWorks_21c0_1999_03_25:1.83
	MLWorks_20c1_1998_08_20:1.83
	MLWorks_20c0_1998_08_04:1.83
	MLWorks_20b2c2_1998_06_19:1.83
	MLWorks_20b2_Windows_1998_06_12:1.83
	MLWorks_20b1c1_1998_05_07:1.83
	MLWorks_20b0_1998_04_07:1.83
	MLWorks_20b0_1998_03_20:1.83
	MLWorks_20m2_1998_02_16:1.83
	MLWorks_20m1_1997_10_23:1.83
	MLWorks_11r1:1.83.5.1.1.1.1
	MLWorks_workspace_97:1.83.7
	MLWorks_dt_wizard:1.83.6
	MLWorks_11c0_1997_09_09:1.83.5.1.1.1
	MLWorks_10r3:1.83.5.1.3
	MLWorks_10r2_551:1.83.5.1.2
	MLWorks_11:1.83.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.83.5.1
	MLWorks_20m0_1997_06_20:1.83
	MLWorks_1_0_r2c2_1997_06_14:1.83.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.83.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.83.5
	MLWorks_BugFix_1997_04_24:1.83
	MLWorks_1_0_r2_Win32_1997_04_11:1.83
	MLWorks_1_0_r2_Unix_1997_04_04:1.83
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.83.3.1.1
	MLWorks_gui_1996_12_18:1.83.4
	MLWorks_1_0_Win32_1996_12_17:1.83.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.83.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.83.1.1
	MLWorks_1_0_Irix_1996_11_28:1.83.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.83.2
	MLWorks_1_0_Unix_1996_11_14:1.83.1
	MLWorks_Open_Beta2_1996_10_11:1.82.3
	MLWorks_License_dev:1.82.2
	MLWorks_1_open_beta_1996_09_13:1.82.1
	MLWorks_Open_Beta_1996_08_22:1.82
	MLWorks_Beta_1996_07_02:1.82
	MLWorks_Beta_1996_06_07:1.82
	MLWorks_Beta_1996_06_06:1.82
	MLWorks_Beta_1996_06_05:1.82
	MLWorks_Beta_1996_06_03:1.82
	MLWorks_Beta_1996_05_31:1.82
	MLWorks_Beta_1996_05_30:1.82
	ML_beta_release_12/08/94:1.74
	ML_beta_release_03/08/94:1.74
	ML_revised_beta_release_25/05/94:1.73
	ML_final_beta_release_02/03/94:1.73
	mlworks-28-01-1994:1.72
	Release:1.69
	mlworks-beta-01-09-1993:1.69
	MLWorks-1-0-4-29/01/1993:1.64
	MLWorks-1-0-3-21/12/1992:1.63
	MLWorks-1-0-2-15/12/1992:1.61
	MLWorks-1-0-1-04/12/1992:1.60
	checkpoint_17_08_92:1.53
	Ten15_release_21-08-91:1.18
	Ten15_release_19-08-91:1.17
	ten15_release:1.8;
locks; strict;
comment	@ * @;


1.83
date	96.10.31.15.36.18;	author io;	state Exp;
branches
	1.83.1.1
	1.83.2.1
	1.83.3.1
	1.83.4.1
	1.83.5.1
	1.83.6.1
	1.83.7.1
	1.83.8.1;
next	1.82;

1.82
date	95.12.22.17.20.13;	author jont;	state Exp;
branches
	1.82.1.1
	1.82.2.1
	1.82.3.1;
next	1.81;

1.81
date	95.12.04.12.23.16;	author matthew;	state Exp;
branches;
next	1.80;

1.80
date	95.08.11.16.50.48;	author daveb;	state Exp;
branches;
next	1.79;

1.79
date	95.03.01.13.05.23;	author matthew;	state Exp;
branches;
next	1.78;

1.78
date	94.10.13.11.14.11;	author matthew;	state Exp;
branches;
next	1.77;

1.77
date	94.10.10.09.43.00;	author matthew;	state Exp;
branches;
next	1.76;

1.76
date	94.09.19.12.43.02;	author matthew;	state Exp;
branches;
next	1.75;

1.75
date	94.08.19.12.53.11;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	94.07.19.13.51.02;	author matthew;	state Exp;
branches;
next	1.73;

1.73
date	94.02.16.14.22.31;	author jont;	state Exp;
branches;
next	1.72;

1.72
date	93.10.11.18.10.29;	author jont;	state Exp;
branches;
next	1.71;

1.71
date	93.10.05.12.35.22;	author jont;	state Exp;
branches;
next	1.70;

1.70
date	93.09.22.13.38.50;	author nosa;	state Exp;
branches;
next	1.69;

1.69
date	93.07.15.09.14.18;	author nosa;	state Exp;
branches
	1.69.1.1;
next	1.68;

1.68
date	93.05.13.11.38.30;	author jont;	state Exp;
branches;
next	1.67;

1.67
date	93.03.10.15.59.49;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	93.03.03.17.27.07;	author jont;	state Exp;
branches;
next	1.65;

1.65
date	93.03.01.14.46.49;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	92.12.24.12.15.45;	author clive;	state Exp;
branches;
next	1.63;

1.63
date	92.12.22.10.14.40;	author matthew;	state Exp;
branches;
next	1.62;

1.62
date	92.12.18.16.51.41;	author clive;	state Exp;
branches;
next	1.61;

1.61
date	92.12.10.17.29.14;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	92.11.09.15.43.44;	author clive;	state Exp;
branches;
next	1.59;

1.59
date	92.11.05.15.04.42;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	92.10.26.17.32.21;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	92.09.22.13.18.17;	author clive;	state Exp;
branches;
next	1.56;

1.56
date	92.09.21.11.58.26;	author clive;	state Exp;
branches;
next	1.55;

1.55
date	92.09.15.15.22.07;	author clive;	state Exp;
branches;
next	1.54;

1.54
date	92.08.26.12.59.18;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	92.07.28.08.54.41;	author clive;	state Exp;
branches;
next	1.52;

1.52
date	92.07.22.12.24.26;	author clive;	state Exp;
branches;
next	1.51;

1.51
date	92.07.17.13.44.41;	author clive;	state Exp;
branches;
next	1.50;

1.50
date	92.07.06.17.39.50;	author davida;	state Exp;
branches;
next	1.49;

1.49
date	92.07.03.14.42.48;	author davida;	state Exp;
branches;
next	1.48;

1.48
date	92.07.02.09.59.20;	author davida;	state Exp;
branches;
next	1.47;

1.47
date	92.06.25.10.47.37;	author davida;	state Exp;
branches;
next	1.46;

1.46
date	92.06.23.09.40.55;	author clive;	state Exp;
branches;
next	1.45;

1.45
date	92.06.22.14.17.10;	author davida;	state Exp;
branches;
next	1.44;

1.44
date	92.06.18.14.18.21;	author davida;	state Exp;
branches;
next	1.43;

1.43
date	92.06.17.15.37.04;	author davida;	state Exp;
branches;
next	1.42;

1.42
date	92.06.16.16.03.09;	author clive;	state Exp;
branches;
next	1.41;

1.41
date	92.06.03.14.33.14;	author clive;	state Exp;
branches;
next	1.40;

1.40
date	92.04.28.18.36.39;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	92.04.23.12.12.01;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.04.13.14.16.44;	author clive;	state Exp;
branches;
next	1.37;

1.37
date	92.03.06.11.51.07;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.02.28.18.54.58;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.02.17.15.07.22;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	92.02.12.13.52.20;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	92.02.11.17.55.20;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	92.02.06.09.52.50;	author clive;	state Exp;
branches;
next	1.31;

1.31
date	92.01.30.13.17.15;	author clive;	state Exp;
branches;
next	1.30;

1.30
date	91.11.22.17.27.26;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	91.11.21.19.37.39;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	91.11.14.17.03.37;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	91.10.23.12.58.36;	author davidt;	state Exp;
branches;
next	1.26;

1.26
date	91.10.22.16.09.39;	author davidt;	state Exp;
branches;
next	1.25;

1.25
date	91.10.09.10.24.17;	author davidt;	state Exp;
branches;
next	1.24;

1.24
date	91.09.25.15.31.45;	author davida;	state Exp;
branches;
next	1.23;

1.23
date	91.09.23.15.45.06;	author davida;	state Exp;
branches;
next	1.22;

1.22
date	91.09.10.16.42.58;	author davida;	state Exp;
branches;
next	1.21;

1.21
date	91.09.06.14.06.43;	author davida;	state Exp;
branches;
next	1.20;

1.20
date	91.09.04.10.43.54;	author davida;	state Exp;
branches;
next	1.19;

1.19
date	91.08.23.16.20.37;	author davida;	state Exp;
branches;
next	1.18;

1.18
date	91.08.15.14.50.56;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.08.14.13.23.00;	author davida;	state Exp;
branches;
next	1.16;

1.16
date	91.08.13.16.05.42;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	91.08.13.13.50.01;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	91.08.09.14.40.05;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.08.06.15.18.45;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.08.02.17.07.52;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.08.02.16.05.09;	author davida;	state Exp;
branches;
next	1.10;

1.10
date	91.08.01.19.44.17;	author davida;	state Exp;
branches;
next	1.9;

1.9
date	91.07.31.14.44.18;	author davida;	state Exp;
branches;
next	1.8;

1.8
date	91.07.30.16.45.55;	author davida;	state Exp;
branches;
next	1.7;

1.7
date	91.07.29.16.45.37;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	91.07.25.13.38.27;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.07.24.13.18.54;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.07.22.12.52.42;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.17.13.20.47;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.07.16.18.00.51;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.07.15.16.12.31;	author davida;	state Exp;
branches;
next	;

1.69.1.1
date	93.07.15.09.14.18;	author jont;	state Exp;
branches;
next	;

1.82.1.1
date	96.09.13.11.17.18;	author hope;	state Exp;
branches;
next	;

1.82.2.1
date	96.10.07.16.07.04;	author hope;	state Exp;
branches;
next	;

1.82.3.1
date	96.10.17.11.25.20;	author hope;	state Exp;
branches;
next	;

1.83.1.1
date	96.11.14.12.50.21;	author hope;	state Exp;
branches
	1.83.1.1.1.1;
next	;

1.83.1.1.1.1
date	96.11.28.15.01.28;	author hope;	state Exp;
branches;
next	;

1.83.2.1
date	96.11.22.18.09.47;	author hope;	state Exp;
branches;
next	;

1.83.3.1
date	96.12.17.17.48.26;	author hope;	state Exp;
branches
	1.83.3.1.1.1;
next	;

1.83.3.1.1.1
date	97.02.24.11.38.22;	author hope;	state Exp;
branches;
next	;

1.83.4.1
date	96.12.18.09.42.27;	author hope;	state Exp;
branches;
next	;

1.83.5.1
date	97.05.12.10.34.56;	author hope;	state Exp;
branches
	1.83.5.1.1.1
	1.83.5.1.2.1
	1.83.5.1.3.1;
next	;

1.83.5.1.1.1
date	97.07.28.18.20.18;	author daveb;	state Exp;
branches
	1.83.5.1.1.1.1.1;
next	;

1.83.5.1.1.1.1.1
date	97.10.07.11.45.27;	author jkbrook;	state Exp;
branches;
next	;

1.83.5.1.2.1
date	97.09.08.17.13.48;	author daveb;	state Exp;
branches;
next	;

1.83.5.1.3.1
date	97.09.09.14.09.31;	author daveb;	state Exp;
branches;
next	;

1.83.6.1
date	97.09.10.19.25.18;	author brucem;	state Exp;
branches;
next	;

1.83.7.1
date	97.09.11.20.55.37;	author daveb;	state Exp;
branches;
next	;

1.83.8.1
date	99.04.01.17.57.16;	author daveb;	state Exp;
branches;
next	;


desc
@Subfunctions for manipulating lambda-expressions.
@


1.83
log
@moving String from toplevel
@
text
@(* _lambdasub.sml the functor *)
(*
 * Lambda Optimiser: _lambdasub.sml
 * sub-functions for lambda modules.
 *
 * $Log: _lambdasub.sml,v $
 * Revision 1.82  1995/12/22  17:20:13  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
 * Revision 1.81  1995/12/04  12:23:16  matthew
 * Simplifying
 *
 * Revision 1.80  1995/08/11  16:50:48  daveb
 * Replaced uses of LambdaTypes.Option with MLWorks.Option.
 *
 * Revision 1.79  1995/03/01  13:05:23  matthew
 * cout -s lambda/lambdasub.sml
 * Removing old lambda optimizer stuff
 *
 * Revision 1.78  1994/10/13  11:14:11  matthew
 * Use pervasive Option.option for return values in NewMap
 *
 * Revision 1.77  1994/10/10  09:43:00  matthew
 * Lambdatypes changes
 *
 * Revision 1.76  1994/09/19  12:43:02  matthew
 * Abstraction of debug information in lambdatypes
 *
 * Revision 1.75  1994/08/19  12:53:11  jont
 * Improve shiftable by adition of shiftable_list
 *
 * Revision 1.74  1994/07/19  13:51:02  matthew
 * Functions and applications take a list of parameters
 *
 * Revision 1.73  1994/02/16  14:22:31  jont
 * Removed all raises of BadCallToNoCheckSub, making result equal to original
 * I think there is some longstanding optimiser bug still here somewhere,\nto do with not finding the right number of occurrences of a var for\nsubstitution, but finding that will have to wait.
 *
 * Revision 1.72  1993/10/11  18:10:29  jont
 * Improved occurs by expanding out the Lists.exists calls.
 *
 * Revision 1.71  1993/10/05  12:35:22  jont
 * Improved substitute_once to avoid checking before starting, it wouldn't
 * have been called if nothing was to be done.
 *
 *Revision 1.70  1993/09/22  13:38:50  nosa
 *FNs now passed closed-over type variables and
 *stack frame-offset for runtime-instance for polymorphic debugger.
 *
Revision 1.69  1993/07/15  09:14:18  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.68  1993/05/13  11:38:30  jont
Modified substitute_once to look before copying except when
a substitution is known to be in a particular expression.
produce a 20% speed up in lambda optimisation on _actionfunctions

Revision 1.67  1993/03/10  15:59:49  matthew
Signature revisions

Revision 1.66  1993/03/03  17:27:07  jont
Removed LVar_eq in favour of polymorphic equality

Revision 1.65  1993/03/01  14:46:49  matthew
Added MLVALUE lambda exp

Revision 1.64  1992/12/24  12:15:45  clive
Stopped optimising switch info inconsistently

Revision 1.63  1992/12/22  10:14:40  matthew
Removed polymorphic equality on SCONs

Revision 1.62  1992/12/18  16:51:41  clive
In rename the substitution forced a new variable for the bindings
causing problems later in the substitution

Revision 1.61  1992/12/10  17:29:14  jont
Minor improvements in sub in subsititute_at_most_once or whatever it is.

Revision 1.60  1992/11/09  15:43:44  clive
Added some LETREC optimisation

Revision 1.59  1992/11/05  15:04:42  jont
Reworked substitute_n_occurences to be a bit more efficient

Revision 1.58  1992/10/26  17:32:21  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.57  1992/09/22  13:18:17  clive
Changes for the newhashtables

Revision 1.56  1992/09/21  11:58:26  clive
Changed hashtables to a single structure implementation

Revision 1.55  1992/09/15  15:22:07  clive
Got rid of handles involving hash tables

Revision 1.54  1992/08/26  12:59:18  jont
Removed some redundant structures and sharing

Revision 1.53  1992/07/28  08:54:41  clive
Modified to use the new hashtables

Revision 1.52  1992/07/22  12:24:26  clive
Wrote routines to try to substitute exactly n times without going inside letrec and fn

Revision 1.51  1992/07/17  13:44:41  clive
Changed eta_abstract to take an extra type annotation

Revision 1.50  1992/07/06  17:39:50  davida
Restored functionality of is_in_evaluation_set.

Revision 1.49  1992/07/03  14:42:48  davida
Added LET constructor and new slot to APP.

Revision 1.48  1992/07/02  09:59:20  davida
Fixed accidental use of NJ "List" structure instead
of our "Lists".

Revision 1.46  1992/06/23  09:40:55  clive
Added an annotation slot to HANDLE

Revision 1.45  1992/06/22  14:17:10  davida
Missing case and improvements for alpha_convertible.

Revision 1.44  1992/06/18  14:18:21  davida
Fixed fault in previous rev, more code tweaking.

Revision 1.43  1992/06/17  15:37:04  davida
Various efficiency improvements.

Revision 1.42  1992/06/16  16:03:09  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.41  1992/06/03  14:33:14  clive
Added type annotations to FNexp

Revision 1.40  1992/04/28  18:36:39  jont
Added require _hashtable

Revision 1.39  1992/04/23  12:12:01  clive
Added some more customised utility functions

Revision 1.38  1992/04/13  14:16:44  clive
First version of the profiler


 * Copyright (c) 1991 Harlequin Ltd.
 *)

require "^.basis.__list";
require "lambdatypes";
require "lambdasub";

functor LambdaSub(
  structure LambdaTypes : LAMBDATYPES
) : LAMBDASUB =
struct
  structure Set = LambdaTypes.Set;
      
  structure LT = LambdaTypes;        (* A short name for clarity! *)
  structure Ident = LT.Ident

  (* Unwrap Lets -- NB! Only removes real lets. *)

  fun unwrap_lets expr =
   let 
     fun unwl(acc, LT.LET((var,info,bind),body)) = 
       unwl((var,bind)::acc,body)
       | unwl(acc, expr) = (rev acc, expr)
   in
     unwl([],expr)
   end

  (* Wrap Lets *)  

  fun wrap_lets (expression, vas) = 
    let
      fun nest ((var,arg),body) = LT.LET((var, NONE, arg),body)
    in
      foldl nest expression (rev vas)
    end

  (* This shouldn't really be needed *)
  (*  Eta-abstraction over some expression. *)
  (*  Generates a new lambda-variable. *)

  fun eta_abstract (le,annotation,ty) =
    let
      val lvar = LT.new_LVar()
    in
      LT.FN([lvar], LT.APP(le, [LT.VAR lvar], SOME(ty)),
	    annotation,LT.null_type_annotation,LT.internal_funinfo)
    end

  val LVar_eq = op=

  (* Optionally apply a function to an optional argument *)

  fun apopt f (SOME x) = SOME (f x)
    | apopt _ NONE     = NONE

  (* quick occurrence check: does the variable occur or not? *)

  fun occurs (lvar, expression) =
    let
      fun occurs(LT.VAR lv) = LVar_eq (lv, lvar)
	| occurs(LT.FN(_, le,_,_,_)) = occurs le
	| occurs(LT.LET((lv,_,lb),le)) = occurs lb orelse occurs le
	| occurs(LT.LETREC(lv_list, le_list, le)) =
	  (occurs le orelse List.exists occurs le_list)
	| occurs(LT.APP(le, lel,_)) = (occurs le orelse List.exists occurs lel)
	| occurs(LT.SCON _) = false
	| occurs(LT.MLVALUE _) = false
	| occurs(LT.INT _) = false
	| occurs(LT.SWITCH(le, info, tag_le_list, leo)) =
	  (occurs le orelse
	   occurs_opt leo orelse
	   List.exists occurs_tag tag_le_list)
	| occurs(LT.STRUCT (le_list,_)) = List.exists occurs (le_list)
	| occurs(LT.SELECT(_, le)) = occurs le
	| occurs(LT.RAISE (le)) = occurs le
	| occurs(LT.HANDLE(le, le',_)) = (occurs le orelse occurs le')
	| occurs(LT.BUILTIN _) = false

      and occurs_opt(NONE) = false
	| occurs_opt(SOME le) = occurs le

      and occurs_tag (tag, le) =
	(case tag of
	   LT.EXP_TAG le' => occurs le' orelse occurs le
	 | _ => occurs le)
    in
      occurs expression
    end

  (*         - - - - Generalised Recursion Schemes - - - -         *)

  (*
   * Recursively apply a function to a lambda-expression and its
   * sub-expressions, either innermost or outermost terms first, building
   * an isomorphic lambda-expression.  Innermost is AOR, outermost is like
   * AOR but applies the  function to the largest term first. The
   * with_context functions also pass the enclosing lambda expression as
   * an argument to the function.
   *)

  fun apply_one_level appsub = 
    let 
      fun apply_tagval (LT.EXP_TAG tagexp, value) =
        (LT.EXP_TAG (appsub tagexp), appsub value)
        | apply_tagval (tagexp, value) =
          (tagexp, appsub value)

      fun apply (le as LT.VAR _) = le
        | apply (LT.FN(lvl, le,x,ty,instance)) = LT.FN (lvl, appsub le,x,ty,instance) 
        | apply (LT.LET((lv,info,lb),le)) = LT.LET((lv,info,appsub lb),appsub le)
        | apply (LT.LETREC(lvl, lel, le)) =
          LT.LETREC (lvl, map appsub lel, appsub le)
        | apply (LT.APP(p, q, annotation)) = 
          LT.APP(appsub p, map appsub q, annotation)
        | apply (le as LT.SCON _) = le
        | apply (le as LT.MLVALUE _) = le
        | apply (le as LT.INT _) = le
        | apply (LT.SWITCH(le, info, clel, leo)) = 
          LT.SWITCH
          (appsub le,
           info,
           map apply_tagval clel,
           apopt appsub leo)
        | apply (LT.STRUCT (lel,ty)) = LT.STRUCT (map appsub lel,ty)
        | apply (LT.SELECT (fld, le)) = LT.SELECT (fld, appsub le)
        | apply (LT.RAISE (le)) = LT.RAISE (appsub le)
        | apply (LT.HANDLE (le1, le2,annotation)) = LT.HANDLE (appsub le1, 
                                                               appsub le2,
                                                               annotation)
        | apply (le as LT.BUILTIN _) = le
    in
      apply
    end

end (* of functor *)


@


1.83.8.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.5.1
log
@branched from 1.83
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.83.5.1  1997/05/12  10:34:56  hope
 * branched from 1.83
 *
@


1.83.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.83.5.1  1997/05/12  10:34:56  hope
 * branched from 1.83
 *
@


1.83.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.83.5.1  1997/05/12  10:34:56  hope
 * branched from 1.83
 *
@


1.83.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.83.5.1.1.1  1997/07/28  18:20:18  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.83.4.1
log
@branched from 1.83
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.3.1
log
@branched from 1.83
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.3.1.1.1
log
@branched from 1.83.3.1
@
text
@a6 3
 * Revision 1.83.3.1  1996/12/17  17:48:26  hope
 * branched from 1.83
 *
@


1.83.2.1
log
@branched from 1.83
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.1.1
log
@branched from 1.83
@
text
@a6 3
 * Revision 1.83  1996/10/31  15:36:18  io
 * moving String from toplevel
 *
@


1.83.1.1.1.1
log
@branched from 1.83.1.1
@
text
@a6 3
 * Revision 1.83.1.1  1996/11/14  12:50:21  hope
 * branched from 1.83
 *
@


1.82
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d7 4
d153 1
a153 1
require "../utils/lists";
a157 1
  structure Lists : LISTS
a165 2
  open MLWorks.Option

d181 1
a181 1
      fun nest (body,(var,arg)) = LT.LET((var, NONE, arg),body)
d183 1
a183 1
      Lists.reducel nest (expression, rev vas)
d213 2
a214 2
	  (occurs le orelse Lists.exists occurs le_list)
	| occurs(LT.APP(le, lel,_)) = (occurs le orelse Lists.exists occurs lel)
d221 2
a222 2
	   Lists.exists occurs_tag tag_le_list)
	| occurs(LT.STRUCT (le_list,_)) = Lists.exists occurs (le_list)
@


1.82.3.1
log
@branched from 1.82
@
text
@a6 4
 * Revision 1.82  1995/12/22  17:20:13  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.82.2.1
log
@branched from 1.82
@
text
@a6 4
 * Revision 1.82  1995/12/22  17:20:13  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.82.1.1
log
@branched from 1.82
@
text
@a6 4
 * Revision 1.82  1995/12/22  17:20:13  jont
 * Remove references to option structure
 * in favour of MLWorks.Option
 *
@


1.81
log
@Simplifying
@
text
@d7 3
a160 1
  structure Option = LT.Option
@


1.80
log
@Replaced uses of LambdaTypes.Option with MLWorks.Option.
@
text
@d7 3
a145 7
(*
require "../utils/crash";
require "../utils/delayed_newhashtable";
require "../utils/print";
require "../main/primitives";
*)

a150 7
(*
  structure Crash : CRASH
  structure Print : PRINT
  structure Primitives : PRIMITIVES
  structure DelayedNewHashTable : DELAYED_NEWHASHTABLE
  sharing type Primitives.EnvironTypes.LambdaTypes.LVar = int
*)
a154 3
(*
  structure LambdaTypes = Primitives.EnvironTypes.LambdaTypes;
*)
a280 1279
(* Don't need this lot with new optimizer *)
(*
  val print_hash_table_stats = ref(false)

  (**************)
  (* Miscellany *)
  (**************)

  (* aliases for set functions *)

  val nullset = Set.empty_set;
  val mem = Set.is_member;
  val ++ = fn (x,y) => Set.add_member (y,x);
  val == = Set.seteq;
  val U = Set.union;
  infix mem;
  infix ++;
  infix ==;
  infix U;
    
  (* Pair destructors *)

  fun fst (x,_) = x;
  fun snd (_,y) = y;
     
  (* Apply a function to first or second component of a pair *)

  fun apfst f (x,y) = (f x, y);
  fun apsnd f (x,y) = (x, f y);

  fun is_var (LT.VAR _) = true
    | is_var _ = false;

  fun LVarlist_eq ([],[]) = true
    | LVarlist_eq (lvar::rest,lvar'::rest') =
      LVar_eq (lvar,lvar') andalso LVarlist_eq (rest,rest')
    | LVarlist_eq _ = false
 
  (*******************************)
  (* Lambda-Expression Utilities *)
  (*******************************)


  fun apply_innermost f = 
    let 
      fun appsub le =
        f (apply_one_level appsub le)
    in
      appsub 
    end

  fun apply_outermost f =
    let
      fun appsub le =
        apply_one_level appsub (f le)
    in
      appsub
    end

  local
    fun apply_lexprs_with_context appsub = 
      let 
	fun apply_tagval context (LT.EXP_TAG tagexp, value) =
	      (LT.EXP_TAG (appsub context tagexp), appsub context value)
	  | apply_tagval context (tagexp as LT.IMM_TAG _, value) =
	      (tagexp, appsub context value)
	  | apply_tagval context (tagexp as LT.VCC_TAG _, value) =
	      (tagexp, appsub context value)
	  | apply_tagval context (tagexp as LT.SCON_TAG _, value) =
	      (tagexp, appsub context value)

	fun apply (le as LT.VAR _) = le
	  | apply (context as LT.FN(lvl, le,x,ty,instance)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.FN (lvl, appsub ctxt le,x,ty,instance) end
	  | apply (context as LT.LET((lv,info,lb),le)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in 
              LT.LET((lv,info,appsub ctxt lb), appsub ctxt le) 
            end
	  | apply (context as LT.LETREC(lvl, lel, le)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in
              LT.LETREC (lvl, map (appsub ctxt) lel, appsub ctxt le) 
            end
	  | apply (context as LT.APP(p, q, ty)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in 
              LT.APP(appsub ctxt p, map (appsub ctxt) q, ty) 
            end
	  | apply (le as LT.SCON _) = le
	  | apply (le as LT.MLVALUE _) = le
	  | apply (le as LT.INT _) = le
	  | apply (context as LT.SWITCH(le, info, clel, leo)) = 
	    let
	      val ctxt = LT.Option.PRESENT context
	    in
	      LT.SWITCH
	      (appsub ctxt le,
	       info,
	       map (apply_tagval ctxt) clel,
	       apopt (appsub ctxt) leo)
	    end
	  | apply (context as LT.STRUCT (lel,ty)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.STRUCT (map (appsub ctxt) lel,ty) end
	  | apply (context as LT.SELECT (fld, le)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.SELECT (fld, appsub ctxt le) end
	  | apply (context as LT.RAISE (le)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.RAISE (appsub ctxt le) end
	  | apply (context as LT.HANDLE (le1, le2,annotation)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.HANDLE (appsub ctxt le1, appsub ctxt le2,annotation) end
	  | apply (le as LT.BUILTIN _) = le
      in
	apply
      end
  in
    fun apply_innermost_with_context f = 
      let 
	fun appsub context le =
	  f context (apply_lexprs_with_context appsub le)
      in
	appsub NONE
      end

    fun apply_outermost_with_context f =
      let
	fun appsub context le =
	  apply_lexprs_with_context appsub (f context le)
      in
	appsub NONE
      end

  end


  (* Check for the equality of two lambda expressions *)

  fun lvl_eq ([],[]) = true
    | lvl_eq (h::t,a::b) = LVar_eq(h,a) andalso lvl_eq(t,b)
    | lvl_eq _ = false

  fun tag_equality(LT.VCC_TAG (_,x),LT.VCC_TAG (_,y)) = (x=y)
    | tag_equality(LT.IMM_TAG (_,x),LT.IMM_TAG (_,y)) = (x=y)
    | tag_equality(LT.SCON_TAG x,LT.SCON_TAG y) = Ident.scon_eqrep(x,y)
    | tag_equality(LT.EXP_TAG x,LT.EXP_TAG y) = lambda_equality(x,y)
    | tag_equality _ = false

  and lambda_equality (expression_pair as (e1,e2)) =
    (case (e1,e2) of 
       (LT.VAR v, LT.VAR v') => LVar_eq(v, v') 
        
    | (LT.FN(varlist,body,_,_,_), LT.FN(varlist',body',_,_,_)) =>
        LVarlist_eq(varlist,varlist') andalso lambda_equality(body,body')

    | (LT.LET((var,_,bind),expr), LT.LET((var',_,bind'),expr')) =>
	LVar_eq(var,var') andalso
	lambda_equality(bind,bind') andalso
	lambda_equality(expr,expr')

    | (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =>
        (* This really should check for a rearrangement of *)
        (* the recursive definitions matching . But this *)
        (* would probably be a lot of work to no avail *)
        lvl_eq (map #1 lvl,map #1 lvl')
        andalso lambda_list_equality(le::lel, le'::lel')
      
    | (LT.APP(f,g,_), LT.APP(f',g',_)) =>
	lambda_equality(f,f') andalso lambda_list_equality(g,g')

    | (LT.SCON x, LT.SCON y) => Ident.scon_eqrep(x,y)
        
    | (LT.MLVALUE x, LT.MLVALUE y) => false (* I guess pointer equality really *)
        
    | (LT.INT x, LT.INT y) => (x=y)

    | (LT.SWITCH(le, info, clel, leo),
       LT.SWITCH(le', info', clel', leo')) =>
      let
        fun check_opt (SOME x, SOME x') = lambda_equality(x,x')
          | check_opt (NONE, NONE) = true
          | check_opt _ = false

        fun check_tags([],[]) = true
          | check_tags((h,le)::t,(a,le')::b) =
	      tag_equality(h,a) andalso
		lambda_equality(le,le') andalso
		check_tags(t,b)
          | check_tags _ = false

	fun check_info (NONE, NONE) = true
	  | check_info (SOME{num_imms=i, num_vccs=v},
			SOME{num_imms=i', num_vccs=v'}) =
            (i:int) = i' andalso (v:int) = v'
          | check_info _ = false
      in
        lambda_equality(le,le')
	andalso check_info(info, info')
        andalso check_opt(leo, leo')
        andalso check_tags (clel, clel')
      end

    | (LT.STRUCT(x,_),LT.STRUCT(y,_)) => 
	lambda_list_equality(x, y)

    | (LT.SELECT(f,le), LT.SELECT(f',le')) => (f=f') andalso lambda_equality(le,le')

    | (LT.RAISE (e), LT.RAISE (e')) => lambda_equality (e,e')

    | (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_))=> 
        lambda_equality(e,e') andalso lambda_equality(h,h')

    | (LT.BUILTIN x,LT.BUILTIN y) => x=y
        
    | _ => false)

  and lambda_list_equality([], []) = true
    | lambda_list_equality(h :: t, a :: b) =
      lambda_equality(h, a) andalso lambda_list_equality(t, b)
    | lambda_list_equality _ = false
    
  (* An extended notion of weak head normal form that really says *)
  (* "I have no sub-expressions which can be evaluated now"       *)
  (* (nb: all whnf expressions are shiftable)			  *)

  fun whnf (LT.VAR _)     = true
    | whnf (LT.FN _)      = true
    | whnf (LT.LETREC _)  = false
    | whnf (LT.LET _)     = false
    | whnf (LT.APP _)     = false
    | whnf (LT.SCON _)    = true
    | whnf (LT.MLVALUE _)    = true
    | whnf (LT.INT _)     = true
    | whnf (LT.SWITCH _)  = false
    | whnf (LT.STRUCT _)  = false
    | whnf (LT.SELECT _)  = false
    | whnf (LT.RAISE _)   = false
    | whnf (LT.HANDLE _)  = false
    | whnf (LT.BUILTIN _) = true

  (*  Recursively apply a function to a lambda-expression and its   *)
  (*  sub-expressions, either innermost or outermost terms first,   *)
  (*  accumulating an argument along the way.  Like `reduce'/`fold' *)
  (*  Order is left to right within constructors.		    *)

  local
    fun reduce_lexprs reducesub =
        let
	  fun caseexprs_of ((LT.EXP_TAG tag, value)::tvs,acc) =
	      caseexprs_of (tvs,value :: tag :: acc)
	    | caseexprs_of ((_,value)::tvs,acc)= caseexprs_of (tvs,value::acc)
	    | caseexprs_of ([],acc) = rev acc

	  fun listit NONE = []
	    | listit (SOME item) = [item]

	  fun reduce (acc,LT.FN(_,le,_,_,_)) = reducesub (acc,le)

	    | reduce (acc,LT.LET((lv,_,lb),le)) = reducesub (reducesub(acc,lb),le)

	    | reduce (acc,LT.LETREC(_,lel,le)) = reducesub
	      					  (reduce_list (acc,lel),le)


	    | reduce (acc,LT.APP(p,q,_)) = reduce_list (reducesub (acc,p),q) 

	    | reduce (acc,LT.SWITCH(le, info, clel, leo)) = 
	      reduce_list (reducesub (acc,le),  (* le :: *)
			   (caseexprs_of (clel, [])) @@
			   (listit leo))

	    | reduce (acc,LT.STRUCT (lel,_)) = reduce_list (acc,lel)

	    | reduce (acc,LT.SELECT(_,le)) = reducesub (acc,le)

	    | reduce (acc,LT.RAISE (le)) = reducesub (acc,le)

	    | reduce (acc,LT.HANDLE (le1,le2,_))= 
	      reducesub (reducesub(acc,le1),le2) 

	    | reduce (acc,_) = acc

	  and reduce_list (acc,[]) = acc
	    | reduce_list (acc,expr::exprs) = let val acc'=reducesub (acc,expr)
					      in reduce_list(acc',exprs) end
	in
	  reduce
	end
  in 
    fun reduce_innermost f (expression,ident) =
      let
	fun reducesub (acc,expr) =
	  f(expr, reduce_lexprs reducesub (acc, expr))
      in
	reducesub (ident,expression)
      end

    fun reduce_outermost f (ident,expression) =
      let
	fun reducesub (acc,expr) = 
	  reduce_lexprs reducesub (f(acc,expr),expr)
      in
	reducesub (ident,expression)
      end

    fun reduce_inner_until f (expression,ident) =
      let
	exception Stop of '_a
	
	fun reducesub (acc,expr) =
	  (let
	     val ival = reduce_lexprs reducesub (acc,expr)
	     val (fval,finish) = f (expr, ival)
	   in
	     if finish then raise Stop fval
	     else fval
	   end)
      in
	reducesub (ident,expression) handle Stop x => x
      end
  end


  (*  Rename all bound variables with new ones 

     - this hash table often ends up empty, so we do something special with it *)

    fun rename_fresh expression =
      let
        val renamehashtable = DelayedNewHashTable.new(32,op = : int * int -> bool,fn x => x)

        fun add_var(var) = 
            DelayedNewHashTable.update(renamehashtable,var, LT.new_LVar())

        fun add_var_and_return(var) =
          let
            val new_var = LT.new_LVar()
            val _ = DelayedNewHashTable.update(renamehashtable,var,new_var)
          in
            new_var
          end

        fun get_new(var) = 
          (DelayedNewHashTable.lookup_default (renamehashtable,var,var))

        fun rename(LT.VAR lvar) = LT.VAR(get_new(lvar))
	  | rename(LT.FN([var], le,n,ty,instance)) =
	    let
	      val new_var = add_var_and_return(var)
	    in
	      LT.FN([new_var], rename(le),n,ty,instance)
	    end
	  | rename(LT.FN(varlist, le,n,ty,instance)) =
            Crash.impossible "varlist in rename"
	  | rename(LT.LET((lv,info,lb),le)) =
	    let
	      val rename_lb = rename lb
	      val new_var = add_var_and_return lv
	    in
	      LT.LET((new_var,info,rename_lb), rename le)
	    end
	  | rename(LT.LETREC(lv_list, le_list, le)) =
	    let
	      val _ = map (add_var o #1) lv_list
              val new_lv_list = 
                map (fn (var,info) => (get_new var,info)) lv_list
	    in
	      LT.LETREC(new_lv_list, map rename le_list, rename le)
	    end
	  | rename(LT.APP(le, lel,ty)) = LT.APP(rename le, map rename lel, ty)
	  | rename(le as LT.SCON _) = le
	  | rename(le as LT.MLVALUE _) = le
	  | rename(le as LT.INT _) = le
	  | rename(LT.SWITCH(le, info, tag_le_list, leo)) =
	      LT.SWITCH(rename le,
		        info,
		        map rename_tag tag_le_list,
		        rename_opt leo)
	  | rename(LT.STRUCT (le_list,ty)) = LT.STRUCT(map rename le_list,ty)
	  | rename(LT.SELECT(field, le)) =LT.SELECT(field, rename(le))
	  | rename(LT.RAISE (le)) = LT.RAISE(rename(le))
	  | rename(LT.HANDLE(le, le',annotation)) =
	      LT.HANDLE(rename(le), rename(le'),annotation)
	  | rename(le as LT.BUILTIN _) = le

	and rename_opt(NONE) = NONE
	  | rename_opt(SOME le) = SOME(rename(le))

	and rename_tag(tag, le) =
	  (case tag of
	     LT.EXP_TAG le => LT.EXP_TAG(rename(le))
	   | _ => tag,
	   rename le
	  )

        val result = rename(expression)
      in
        (if !print_hash_table_stats
           then 
             output(std_out,"Rename hash table in _lambdasub" ^ 
                    DelayedNewHashTable.string_hash_table_stats(renamehashtable) ^ "\n")
         else ();
           result)
      end

 (*  Single substitution of a variable for an expression  *)

    exception DidntFindCorrectNumber

    val hit = ref(false)
    val count = ref(0)

    fun add_to_front(x, []) = x
      | add_to_front(x, h::t) = add_to_front(h::x, t)

    fun map_until_hit(f,x) = 
      let
	fun map_sub([],res) = rev res
	  | map_sub(arg as ((h::t),res)) =
	    if !hit
	      then add_to_front arg
	    else map_sub(t,f(h)::res)
      in
	map_sub(x,[])
      end

  fun substitute_n_occurrences inside_functions (var, subexpr, expr, n) =
    (* This substitutes up to n occurences of var within expr with subexpr, *)
    (* and cuts afterwards, returning whether or not all were done. It is *)
    (* not expected that expr will contain more than n occurrences of var *)
    let
      val _ = hit := false
      val _ = count := n

      fun sub(le as LT.VAR lv) =
	if LVar_eq(lv, var) then 
	  (let
	     val c = !count
	   in
	     if c=1 then hit:=true
	     else if c>0 then count := c-1
		  else ()
	   end;
	     subexpr)
	else le
        | sub(arg as LT.FN(lvl,le,n,ty,instance)) = 
          if inside_functions andalso not(!hit)
            then LT.FN(lvl,sub le,n,ty,instance)
          else arg
	| sub(arg as LT.LET((lv,info,lb),le)) =
	  if !hit then
	    arg
	  else
	    LT.LET((lv, info, sub lb), if !hit then le else sub le)
        | sub(arg as LT.LETREC(lv_list, le_list, le)) =
          if inside_functions andalso not(!hit)
            then LT.LETREC(lv_list, map_until_hit(sub,le_list),
			   if !hit then le else sub le)
          else arg
        | sub(arg as LT.APP(le, lel,ty)) =
	  if !hit then
	    arg
	  else
	    LT.APP(sub le, if !hit then lel else map_until_hit (sub,lel),ty)
	| sub(le as LT.SCON _) = le
	| sub(le as LT.MLVALUE _) = le
	| sub(le as LT.INT _) = le
	| sub(arg as LT.SWITCH(le, info, tag_le_list, leo)) =
	  if !hit then
	    arg
	  else
	    LT.SWITCH(sub le, info, map_until_hit(sub_tag,tag_le_list), 
		      sub_opt leo)
	| sub(arg as LT.STRUCT (le_list,ty)) =
	  if !hit then
	    arg
	  else
	    LT.STRUCT(map_until_hit(sub,le_list),ty)
	| sub(arg as LT.SELECT(field, le)) =
	  if !hit then
	    arg
	  else
	    LT.SELECT(field, sub(le))
	| sub(arg as LT.RAISE (le)) =
	  if !hit then
	    arg
	  else
	    LT.RAISE(sub(le))
	| sub(arg as LT.HANDLE(le, le',annotation)) =
	  if !hit then
	    arg
	  else
	    LT.HANDLE(sub(le), if !hit then le' else sub le',annotation)
	| sub(le as LT.BUILTIN _) = le

      and sub_opt(NONE) = NONE
	| sub_opt(arg as (SOME le)) = 
	  if !hit 
	    then arg
	  else SOME(sub(le))

      and sub_tag((tag, le)) =
	(case tag of
	   (LT.EXP_TAG le) => 
             if !hit 
               then tag
             else LT.EXP_TAG(sub(le))
	 | _ => tag, if !hit then le else sub le)
    in
      (sub expr,!hit)
    end

  fun substitute_once inside_functions (var, subexpr, expr) =
    let
      fun occurs(le as LT.VAR lv) = LVar_eq(lv, var) 
        | occurs(arg as LT.FN(lvl, le, _, _,_)) = inside_functions andalso occurs le
	| occurs(LT.LET((lv,_,lb),le)) = occurs lb orelse occurs le
        | occurs(arg as LT.LETREC(lv_list, le_list, le)) =
	  occurs le orelse
          (inside_functions andalso (*Lists.exists*) occurs_list le_list)
        | occurs(LT.APP(le, lel, _)) = occurs le orelse occurs_list lel
	| occurs(LT.SCON _) = false
	| occurs(LT.MLVALUE _) = false
	| occurs(LT.INT _) = false
	| occurs(LT.SWITCH(le, _, tag_le_list, leo)) =
	  occurs le orelse occurs_opt leo orelse (*Lists.exists*) occurs_tag_list tag_le_list
	| occurs(LT.STRUCT (le_list,_)) = (*Lists.exists*) occurs_list le_list
	| occurs(LT.SELECT(field, le)) = occurs le
	| occurs(LT.RAISE le) = occurs le
	| occurs(LT.HANDLE(le, le', _)) = occurs le orelse occurs le'
	| occurs(LT.BUILTIN _) = false

      and occurs_opt NONE = false
	| occurs_opt(SOME le) = occurs le

(*
      and occurs_tag((tag, le)) =
	(case tag of
	   LT.EXP_TAG le => occurs le
	 | _ => false) orelse occurs le
*)

      and occurs_list [] = false
	| occurs_list(x :: xs) = occurs x orelse occurs_list xs

      and occurs_tag_list [] = false
	| occurs_tag_list((tag, le) :: xs) =
	  (case tag of
	     LT.EXP_TAG le => occurs le
	   | _ => false) orelse occurs le orelse occurs_tag_list xs
	  
      val _ = hit := false

      exception BadCallToNoCheckSub of string

      fun sub le =
	if (not (!hit)) andalso occurs le then no_check_sub le else le

      and no_check_sub le =
	case le of
	  (le as LT.VAR lv) =>
	    if LVar_eq(lv, var) 
	      then  (hit := true;
		     subexpr)
	    else le
	| (arg as LT.FN(lvl, le,n,ty,instance)) =>
	    if inside_functions
	      then LT.FN(lvl, no_check_sub(le),n,ty,instance)
	    else arg
	| (LT.LET((lv,info,lb),le)) => 
            LT.LET((lv,info,sub lb),if !hit then le else no_check_sub le)
	| (arg as LT.LETREC(lv_list, le_list, le)) =>
	    if inside_functions then
	      LT.LETREC(lv_list, map_until_hit(sub, le_list),
			if !hit then le else no_check_sub le)
	    else arg
	| (LT.APP(le, lel,ty)) =>
	    LT.APP(sub le, if !hit then lel else map_until_hit (sub,lel),ty)
	| (le as LT.SCON _) => le (* raise BadCallToNoCheckSub "LT.SCON"*)
	| (le as LT.MLVALUE _) => le(*raise BadCallToNoCheckSub "LT.MLVALUE"*)
	| (le as LT.INT _) => le(*raise BadCallToNoCheckSub "LT.INT"*)
	| (LT.SWITCH(le, info, tag_le_list, leo)) =>
	    LT.SWITCH(sub le,
		      info,
		      map_until_hit(sub_tag,tag_le_list),
		      sub_opt leo)
	| (LT.STRUCT (le_list,ty)) => LT.STRUCT(map_until_hit(sub, le_list),ty)
	| (LT.SELECT(field, le)) => LT.SELECT(field, no_check_sub(le))
	| (LT.RAISE le) => LT.RAISE(no_check_sub(le))
	| (LT.HANDLE(le, le',annotation)) =>
	       LT.HANDLE(sub(le), if !hit then le' else no_check_sub le',annotation)
	| (le as LT.BUILTIN _) => le (*raise BadCallToNoCheckSub "LT.BUILTIN"*)

      and sub_opt(NONE) = NONE
	| sub_opt(arg as (SOME le)) =
	  if !hit then arg else SOME(no_check_sub(le))

      and sub_tag((tag, le)) =
	(case tag of
	   (LT.EXP_TAG le) => 
             if !hit then tag
             else LT.EXP_TAG(sub(le))
	 | _ => tag, if !hit then le else sub le)
    in
(*
      (((if occurs expr then () else output(std_out, "Substitute_once called with no substitution to do\n"));
	  no_check_sub expr),!hit)
*)
      (no_check_sub expr, !hit)
    end

val substitute_for_at_most_one_occurrence = #1 o (substitute_once true)
val substitute_for_at_most_n_occurrences = #1 o (substitute_n_occurrences true)

fun substitute_for_exactly_one_occurrence_not_in_functions x =
  let
    val (new,found) = substitute_once false x
  in
    if found
      then new
    else raise DidntFindCorrectNumber
  end

fun substitute_for_exactly_n_occurrences_not_in_functions x =
  let
    val (new,found) = substitute_n_occurrences false x
  in
    if found
      then new
    else raise DidntFindCorrectNumber
  end

  fun substitute (var, subexpr, expr) =
    let
      fun sub(le as LT.VAR lv) =
	if LVar_eq(lv, var) then subexpr else le
	| sub(LT.LET((lv,info,lb),le)) = LT.LET((lv,info,sub lb),sub le)
	| sub(LT.FN(lvl, le,n,ty,instance)) = LT.FN(lvl, sub(le),n,ty,instance)
	| sub(LT.LETREC(lv_list, le_list, le)) =
	  LT.LETREC(lv_list, map sub le_list, sub le)
	| sub(LT.APP(le, lel,ty)) =
	  LT.APP(sub le, map sub lel,ty)
	| sub(le as LT.SCON _) = le
	| sub(le as LT.MLVALUE _) = le
	| sub(le as LT.INT _) = le
	| sub(LT.SWITCH(le, info, tag_le_list, leo)) =
	  LT.SWITCH(sub le,
		    info,
		    map sub_tag tag_le_list, 
		    sub_opt leo)
	| sub(LT.STRUCT (le_list,ty)) =  LT.STRUCT(map sub le_list,ty)
	| sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
	| sub(LT.RAISE (le)) = LT.RAISE(sub(le))
	| sub(LT.HANDLE(le, le',annotation)) = 
	  LT.HANDLE(sub(le), sub le',annotation)
	| sub(le as LT.BUILTIN _) = le

      and sub_opt(NONE) = NONE
	| sub_opt(SOME le) = SOME(sub(le))

      and sub_tag((tag, le)) =
	(case tag of
	   LT.EXP_TAG le => LT.EXP_TAG(sub(le))
	 | _ => tag, sub le)
    in
      sub expr
    end

 (*  Substitution, with a new instance of the subexpression each time  *)

 fun substitute_fresh (var,subexpr,expr) =
   let
     fun subs (v as LT.VAR lvar) =
       if LVar_eq(var, lvar) then rename_fresh subexpr else v
     | subs expr = expr
   in
     apply_outermost subs expr
   end

  fun substitute_list(var_list, expr) =
    let
     val var_map = LT.Map.from_list var_list
      fun subs (v as LT.VAR lvar) =
	(case LT.Map.tryApply'(var_map, lvar) of
	   MLWorks.Option.SOME lv => LT.VAR lv
	 | _ => v)
        | subs expr = expr
    in
      apply_outermost subs expr
    end


 (*  Calculate the number of occurrences of a (free) lambda-variable *)
 (*  in a lambda-expression, assuming unique naming, i.e. ignoring   *)
 (*  bound occurrences / LETREC lists.		 		      *)

(* This implementation removed, cos it's way too slow
  fun occurrences (lvar,expression) =
    let
      fun count (LT.VAR lvar', sofar) =
	if LVar_eq(lvar, lvar') then sofar+1 else sofar
      | count (_, sofar) = sofar
    in 
      reduce_innermost count (expression,0)
    end
*)

  fun occurrences(lvar, expression) =
    let
      fun occurs(count, LT.VAR lv) =
	   if LVar_eq(lv, lvar) then count+1 else count
	| occurs(count, LT.FN(_, le,_,_,_)) = occurs(count, le)
	| occurs(count, LT.LET((lv,_,lb),le)) = occurs(occurs(count,lb),le)
	| occurs(count, LT.LETREC(_, le_list, le)) =
	  occurs(Lists.reducel occurs (count,le_list),le)
	| occurs(count, LT.APP(le, lel,_)) =
	  Lists.reducel occurs (occurs(count, le), lel)
	| occurs(count, LT.SCON _) = count
	| occurs(count, LT.MLVALUE _) = count
	| occurs(count, LT.INT _) = count
	| occurs(count, LT.SWITCH(le, info, tag_le_list, leo)) =
	  Lists.reducel
	  occurs_tag
	  (occurs(occurs_opt(count, leo), le),
	   tag_le_list)
	| occurs(count, LT.STRUCT (le_list,_)) =
	  Lists.reducel occurs (count, le_list)
	| occurs(count, LT.SELECT(_, le)) = occurs(count, le)
	| occurs(count, LT.RAISE (le)) = occurs(count, le)
	| occurs(count, LT.HANDLE(le, le',_)) = occurs(occurs(count, le), le')
	| occurs(count, LT.BUILTIN _) = count

      and occurs_opt(count, NONE) = count
	| occurs_opt(count, SOME le) = occurs(count, le)

      and occurs_tag(count, (tag, le)) =
	occurs((case tag of
		  LT.EXP_TAG le => occurs(count, le)
		| _ => count), le)
    in
      occurs(0, expression)
    end



  fun occurrences_0_1_more (lvar, expression) =
    let
      exception Stop
      fun occurs(count, LT.VAR lv) =
	if LVar_eq(lv, lvar) 
          then if count=1
                 then raise Stop
               else count+1 
        else count
	| occurs(count, LT.FN(_, le,_,_,_)) = occurs(count, le)
	| occurs(count, LT.LET((lv,_,lb),le)) = occurs(occurs(count,lb),le)
	| occurs(count, LT.LETREC(lv_list, le_list, le)) =
	  Lists.reducel occurs (count, le :: le_list)
	| occurs(count, LT.APP(le, lel,_)) = Lists.reducel occurs (occurs(count, le), lel)
	| occurs(count, LT.SCON _) = count
	| occurs(count, LT.MLVALUE _) = count
	| occurs(count, LT.INT _) = count
	| occurs(count, LT.SWITCH(le, info, tag_le_list, leo)) =
	  Lists.reducel
	  occurs_tag
	  (occurs(occurs_opt(count, leo), le),
	   tag_le_list)
	| occurs(count, LT.STRUCT (le_list,_)) =
	  Lists.reducel occurs (count, le_list)
	| occurs(count, LT.SELECT(_, le)) = occurs(count, le)
	| occurs(count, LT.RAISE (le)) = occurs(count, le)
	| occurs(count, LT.HANDLE(le, le',_)) = occurs(occurs(count, le), le')
	| occurs(count, LT.BUILTIN _) = count

      and occurs_opt(count, NONE) = count
	| occurs_opt(count, SOME le) = occurs(count, le)

      and occurs_tag(count, (tag, le)) =
	occurs((case tag of
		  LT.EXP_TAG le => occurs(count, le)
		| _ => count), le)
    in
      occurs(0, expression) handle Stop => 2
    end

 (*  Construct the set of bound variables and the set of free variables  *)
 (*  in a lambda-expression.  						 *)

 fun bounds_and_frees expression =
   let
     fun build(vars as (bs,fs),  LT.VAR var) = if var mem bs then vars
					       else (bs, fs++var)
       | build((bs,fs),  LT.FN([var],_,_,_,_)) = (bs++var, fs)
       | build((bs,fs),  LT.FN(varlist,_,_,_,_)) = Crash.impossible "Varlist in bounds_and_frees"
       | build((bs,fs),  LT.LET((lv,_,_),_)) = (bs++lv,fs)
       | build((bs,fs),  LT.LETREC(lvs,_,_)) =
	 (Lists.reducel (op++) (bs,map #1 lvs), fs)
       | build(vars, _) = vars
   in
     reduce_outermost build ((nullset,nullset), expression)
   end




  (*  Count the number of times a lambda-variable occurs in a lambda  *)
  (*  expression without an immediate surrounding SELECT.	      *)

  fun count_noselects (expression, record_variable) = 
    let 
      fun build (LT.VAR lvar, number) =
	if LVar_eq(lvar, record_variable) then number+1 else number

	| build (LT.SELECT (_,LT.VAR var), number) =
	  if LVar_eq(var, record_variable) then number-1 else number
	| build (_, number) = number
    in 
      reduce_innermost build (expression,0)
    end


  (*  Construct a list of the irreducible sub-expressions of an expression   *)
  (*  in the order that they will be evaluated.  Note that for the extended  *)
  (*  conditional constructs (i.e. SWITCH, HANDLE) this is liberal and       *)
  (*  returns all of the sub-expressions.  Same for LETREC's.		     *)

  fun eval_sequence expression =
     let
	fun sequence (expr,  list) = if whnf expr
					then expr::list
				     else list
     in
	rev (reduce_innermost sequence (expression,[]))
     end


  (*  Construct a list of the sub-expressions of an expression in the order  *)
  (*  that they will be evaluated, returning only those sub-expressions      *)
  (*  that we can ensure will definitely be evaluated; the sequence ends at  *)
  (*  the first non-certain sub-expression.  Again, only exprs in whnf.      *)

  fun certain_eval_sequence expression =
    let
      fun flatten [] = []
	| flatten (l::ls) = l @@ (flatten ls)

      exception Stop of LT.LambdaExp list

      fun sequence (seq,expr) =  
	if (whnf expr) then seq @@ [expr]
	else case expr of
	  LT.LETREC _ => seq @@ [expr]
	| LT.LET _ => seq @@ [expr]
	| LT.APP(p,q,_) => Lists.reducel sequence (sequence (seq,p), q)
	| LT.SWITCH(e,_,_,_) => raise Stop (sequence(seq,e))
	| LT.STRUCT (lel,_) => Lists.reducel sequence (seq,lel)
	| LT.SELECT(_,e) => sequence(seq,e)
	| LT.RAISE (e) => sequence(seq,e)
	| LT.HANDLE(p,_,_) => raise Stop (sequence(seq,p))
	| _ => Crash.impossible "erk seq/whnf!"
    in
      (sequence([],expression)) handle Stop seq => seq
    end


  (*  See if an expression is in the set of expressions that we can ensure  *)
  (*  will definitely be evaluated.This returns a larger set of expressions *)
  (*  than certain_eval_sequence above, because when we aren't interested   *)
  (*  in the order of evaluation, we can examine SWITCH's to find exprs     *)
  (*  which are common to every branch, ignoring the order in the branches  *)

  fun is_in_evaluation_set element =
    let
      fun evaled(expr) = 
        lambda_equality(element,expr) orelse
	(if (whnf expr) then false
	 else case expr of
	   LT.LETREC(_,_,le) => false(*evaled(le)  (* changed this from "false"*)*)
	 | LT.LET((_,_,lb),le) => evaled(lb)(*evaled(lb) orelse evaled(le)*)
	 | LT.APP(p,q,_) => evaled p orelse Lists.exists evaled q
	 | LT.SWITCH x => switch_evaled x
	 | LT.STRUCT (lel,_) => Lists.exists evaled lel
	 | LT.SELECT(_,e) => evaled(e)
	 | LT.RAISE (e) => evaled(e)
	 | LT.HANDLE(p,_,_) => evaled(p)
	 | _ => Crash.impossible "problems in in_evaluation_set_p")

      and switch_evaled (e,info,cases,cdef) =
        evaled e orelse
	(let 
	   val opt = fn (NONE,xs) => xs | (SOME x,xs) => x::xs
	 in
	   (case cases of
	       (LT.EXP_TAG le, _) :: _ =>
		 (Lists.exists 
		  (fn (LT.EXP_TAG le, _) => evaled le
	  	                     | _ => Crash.impossible"Mixed tag type") 
		  cases)
	     | _ => false) orelse
	   (let
	      val results = opt (cdef, (map snd cases))
	    in
	      case results of
		[] => false
	      | _ => Lists.forall evaled results
	    end)
	 end)
    in
      (*fn _ => true*) evaled
    end



 (*  Beta-abstraction over a sub-expression of some expression. *)
 (*  Generates a new lambda-variable.    			*)

  fun beta_abstract (expression, sub_expression) = 
     let
	val new_variable = LT.new_LVar()
	val new_sub_expression = LT.VAR new_variable

	fun abstract expr = if lambda_equality(expr,sub_expression )
			       then new_sub_expression
			    else expr
     in
	(new_variable,
	 LT.FN([new_variable], 
               apply_outermost abstract expression,"_lambdasub beta abstract",
               LT.null_type_annotation,LT.internal_funinfo))
     end


  (* reverse substitution: result doesn't bind new variable *)

  fun abstract_with_count (expression, sub_expression) = 
     let
       val count = ref(0)
       val new_variable = LT.new_LVar()
       val new_sub_expression = LT.VAR new_variable
         
       fun abstract expr = if lambda_equality(expr,sub_expression )
                             then (count := !count + 1; new_sub_expression)
                           else expr

       (* Side effect so need to bind this here *)
       val new_exp = apply_outermost abstract expression

     in
	(new_variable, !count, new_exp)
     end


  (*  Substitute a subexpression for a new subexpression  *)

  fun replace_subexpr (subexpr,newsubexpr) =
     let
	fun abstract expr = if lambda_equality(expr,subexpr )
			       then newsubexpr
			    else expr
     in
	apply_outermost abstract
     end;



  (*  Strip leading abstractions from a lambda-expression  *)

  fun strip_abs expr =
     let 
	fun strip (vars,LT.FN([var],body,_,_,_)) = strip(var::vars,body)
          | strip (vars,LT.FN(varlist,body,_,_,_)) = Crash.impossible "varlist in strip_abs"
	  | strip (vars,_) = rev vars
     in
	strip ([],expr)
     end



  (* Strip arguments and lambda-variables as far as possible, building *)
  (* an association list in the evaluation order.   Expression may be  *)
  (* an arbitrary nest of function applications and abstractions.      *)

  fun unwrap_apps expression = (expression,[])
(*
     let
       fun reduce_APP (le,(le',ty)) = LT.APP(le,le',ty)

	fun getargs (LT.APP(func,arg,ty), args) = getargs(func, (arg,ty,ty')::args)
	  | getargs (func,args) = getfun (func,args,[])

	and getfun (LT.FN(var,body,annotation,ty,_), arg::args, result) = 
	                    getfun(body, args, (var,arg,annotation,ty)::result)

	  | getfun (expr as LT.APP _, args, result) =
	    let
	       val (expr',pairs) = getargs (expr,[])
	    in 
	       case pairs of
		 [] => (Lists.reducel reduce_APP (expr,args), result)
	       | _ => getfun (expr', args, pairs@@result)
	    end

	  | getfun (expr, args, result) =
	    (Lists.reducel reduce_APP (expr,args), result)
     in
	getfun (expression, [], [])
     end
*)

  (* See if the given expression is a commutative function *)
 
  fun is_commutative _ (LT.BUILTIN p) = p mem Primitives.commutative_primitives
    | is_commutative comvars (LT.VAR v) = v mem comvars
    | is_commutative _ _ = false


  (* See if the given expression is an associative function *)
  
  fun is_associative _ (LT.BUILTIN p) = p mem Primitives.associative_primitives
    | is_associative assvars (LT.VAR v) = v mem assvars
    | is_associative _ _ = false


  (*  See if an expression is shiftable, in the sense that dynamic     *)
  (*  evaluation of it doesn't refer to state, raise an exception, or  *)
  (*  loop forever.  We can only approximate the full set!		*)

  local 
    (* We have to be careful about PRIM's as most of them raise exceptions, and we would
     therefore need to use in_evaluation_set fairly frequently *)
      fun shiftable_prim p = false (*not(p mem Primitives.imperative_primitives)*)
  in
      fun shiftable(LT.VAR _) = true
	| shiftable(LT.FN _) = true
	| shiftable(LT.LET((_,_,lb),le)) = (shiftable lb) andalso (shiftable le)
	| shiftable(LT.LETREC(_,_,x)) = shiftable x
	| shiftable(LT.APP (p,q,_)) =
	  (Lists.forall shiftable q) andalso 
	  (case p of
	     LT.VAR var => false
	   | LT.BUILTIN prim => shiftable_prim prim
	   | LT.FN (var,body,_,_,_) =>  shiftable body
	   | _ => false)  
	| shiftable(LT.SCON _) = true
	| shiftable(LT.MLVALUE _) = true
	| shiftable(LT.INT _)  = true
	| shiftable(LT.SWITCH (le,info,clel,leo)) =
	  let 
	    fun shiftable_opt (SOME e) = shiftable e 
	      | shiftable_opt  NONE = true
	  in
	    (shiftable le) andalso
	    (shiftable_opt leo) andalso
	    (Lists.forall (fn(_,e)=>shiftable e) clel)
	  end
	| shiftable(LT.STRUCT (lel,_)) = shiftable_list lel
	| shiftable(LT.SELECT (f,le)) = shiftable le
	| shiftable(LT.RAISE _) = false
	| shiftable(LT.HANDLE (expr,pats,_)) = shiftable expr
	| shiftable(LT.BUILTIN prim) = true

      and shiftable_list [] = true
	| shiftable_list [x] = shiftable x
	| shiftable_list(x :: xs) = shiftable x andalso shiftable_list xs

  end

  val is_shiftable = shiftable;


 (*  Return the size of a lambda-expression, as the number of nodes  *)
 (*  in the tree, but counting APP(FN _,_) as just one node.         *)  

  fun size_of_expr expression = reduce_outermost (fn(c,_)=>c+1) (0,expression);

  fun size_of_expr_is_smaller_than (expression,bound) = 
    let
      exception Stop
      fun doit expression =
        (reduce_outermost (fn(c,_)=> if c>bound then raise Stop else c+1) (0,expression);
         true)
        handle Stop => false
    in
      doit expression
    end


  (*  Test whether two lambda-expressions are alpha-convertible.  *)
  (*  This could do with being fast: we could do with pointer     *)
  (*  equality.  (ditto for lambda_equality)			  *)

  fun alpha_convertible (expression_pair as (e1,e2)) =
   let
    fun match(envir, e1,e2) = 
     let 
       fun tag_eq (LT.EXP_TAG le,LT.EXP_TAG le') = subm(le,le')
	 | tag_eq (LT.IMM_TAG (_,tag),LT.IMM_TAG (_,tag')) = tag=tag'
	 | tag_eq (LT.VCC_TAG (_,tag),LT.VCC_TAG (_,tag')) = tag=tag'
	 | tag_eq (LT.SCON_TAG tag,LT.SCON_TAG tag') = 
	   Ident.scon_eqrep(tag,tag')
	 | tag_eq  _ = Crash.impossible"Mixed tag types in switch"

       and all_tags ((x,_)::xs,(y,_)::ys) = tag_eq(x,y) andalso all_tags(xs,ys)
	 | all_tags ([],[]) = true
	 | all_tags _ = false

       and all_vals (envir, (_,x)::xs,(_,y)::ys) =
	     match(envir, x, y) andalso all_vals(envir, xs, ys)
	 | all_vals (_, [], []) = true
	 | all_vals _ = false

       and subm (e1,e2) = 
       case (e1,e2) of 
	 (LT.VAR v, LT.VAR v') =>
	   LVar_eq(v, v') orelse LVar_eq(Lists.assoc(v,envir), v')

       | (LT.LET((lv,_,lb),le), LT.LET((lv',_,lb'),le')) => 
	   subm(lb,lb') andalso match((lv,lv')::envir, le,le')

       | (LT.FN([var],body,_,_,_), LT.FN([var'],body',_,_,_)) =>
	   match((var,var')::envir, body, body')

       | (LT.FN(varlist,body,_,_,_), LT.FN(varlist',body',_,_,_)) =>
           Crash.impossible "varlist in alpha_convertible"

       | (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =>
	   (* This really should check for a rearrangement of *)
	   (* the recursive definitions matching . But this *)
	   (* would probably be a lot of work to no avail *)
	   (*Lists.length lvl = Lists.length lvl' andalso*)
	   let
	     val envir' = Lists.zip (map #1 lvl,map #1 lvl') @@ envir
	   in
	     match(envir', LT.STRUCT (le::lel,LT.TUPLE), LT.STRUCT (le'::lel',LT.TUPLE))
	   end
	 
       | (LT.APP(f,g,_), LT.APP(f',g',_)) => subm(f,f') andalso Lists.forall subm (Lists.zip (g,g'))
	   
       | (LT.SCON x, LT.SCON y) => Ident.scon_eqrep(x,y)
	   
       | (LT.MLVALUE x, LT.MLVALUE y) => false (* pointer equality really *)
	   
       | (LT.INT x, LT.INT y) => (x=y)
	   
       | (LT.SWITCH(le,info,clel,leo),
	  LT.SWITCH(le',info',clel',leo')) =>
	 (* This really should check for a rearrangement of *)
	 (* the tags matching . This could relatively easily *)
	 (* be done for SCON_TAG and constructor tags *)
	 let
	     fun subo (SOME le, SOME le') = subm (le,le')
	       | subo (NONE, NONE) = true
	       | subo _ = false
		 
	     datatype tag_kind = SAME | DIFFERENT | NONE

	     fun tag_kind ((LT.EXP_TAG _, _) :: _, (LT.EXP_TAG _, _) :: _)=SAME
	       | tag_kind ((LT.IMM_TAG _, _) :: _, (LT.IMM_TAG _, _) :: _)=SAME
	       | tag_kind ((LT.VCC_TAG _, _) :: _, (LT.VCC_TAG _, _) :: _)=SAME
	       | tag_kind ((LT.SCON_TAG _, _) ::_, (LT.SCON_TAG _, _) ::_)=SAME
	       | tag_kind ([],[]) = NONE
	       | tag_kind _ = DIFFERENT

	   in
	     (*Lists.length clel = Lists.length clel' andalso*)
	       (case tag_kind(clel,clel') of 
		  DIFFERENT => false
	        | NONE => match(envir, le, le')
	        | SAME => match(envir, le ,le') andalso
		          all_tags(clel, clel') andalso 
		          all_vals(envir, clel, clel'))
	        andalso subo (leo, leo')
	   end

	| (LT.STRUCT (les,_), LT.STRUCT (les',_)) =>
	      (*Lists.length les = Lists.length les' andalso*)
	      Lists.forall subm (Lists.zip (les,les'))

	| (LT.SELECT(f,le), LT.SELECT(f',le')) => f=f' andalso subm (le,le')

	| (LT.RAISE (e), LT.RAISE (e')) => subm (e,e')

	| (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_))=> subm(e,e') andalso subm(h,h')

	| (LT.BUILTIN x,LT.BUILTIN y) => x=y

	| _ => false
     in
       (*lambda_equality(e1,e2) orelse !! *) subm(e1,e2)
     end
   in
     (match ([], e1, e2)) handle Lists.Zip => false | Lists.Assoc => false
   end

 (* Check that an expression obeys the scope rules, *)
 (* and binds all variables exactly once.	    *)

  fun check_validity (expression, in_case_of_error) =
    let
      val all_binds = ref ([] : (LT.LVar * LT.LambdaExp) list)
      val bound_var = LT.VAR (LT.new_LVar())
      
      val unbounds = ref ([] : LT.LVar list)
      val multiply_bounds = ref ([] : LT.LVar list)

      val bad = ref false
	
      fun add((var,bind),binds) =
	((Lists.assoc(var,!all_binds);
	  multiply_bounds:= var :: (!multiply_bounds);
	  (var,bind)::binds)
	 handle Lists.Assoc => (all_binds := (var,bind)::(!all_binds);
				(var,bind)::binds))
	
      fun check (binds,LT.VAR v) = 
	((Lists.assoc(v,binds); ())
	 handle Lists.Assoc => 
	   (unbounds := v :: (!unbounds)))
	| check (binds,LT.FN([bv],le,_,_,_)) = check(add((bv,bound_var),binds),le)
	| check (binds,LT.FN(bvl,le,_,_,_)) = Crash.impossible "varlist in check_validity"
	| check (binds,LT.LET((v,_,lb),le)) =
	  (check(binds,lb); check(add((v,lb),binds),le))
	| check (binds,LT.LETREC(lvl,lel,le)) =
	  let
	    val binds' = (Lists.reducer add (Lists.zip(map #1 lvl,lel),binds))
	         handle Lists.Zip =>
		   (Print.print("!!! LETREC has different number of lambda-vars"^
				" and lambda-exps.\n"); bad:=true;
		    binds)
	  in
	    (map (fn le=>check(binds',le)) lel;
	     check(binds',le))
	  end
	| check (binds,LT.APP(p,lel,_)) = (check(binds,p); Lists.iterate (fn le => check(binds,le)) lel)
	| check (_,LT.SCON _) = ()
	| check (_,LT.MLVALUE _) = ()
	| check (_,LT.INT _) = ()
	| check (binds,LT.SWITCH(le, info, tlel, leo)) =
	  (check(binds,le);
	   map (check_tag binds) tlel;
	   map (fn (_,le) => check(binds, le)) tlel;
	   check_opt (binds, leo))
        | check (binds,LT.STRUCT (lel,_)) = (Lists.iterate (fn le=>check(binds,le)) lel)
	| check (binds,LT.SELECT(_,le)) = check(binds,le)
	| check (binds,LT.RAISE (le)) = check(binds,le)
	| check (binds,LT.HANDLE(p,q,_)) = (check(binds,p); check(binds,q))
	| check (binds,LT.BUILTIN _) = ()

      and check_tag binds (LT.EXP_TAG le,_) = check(binds,le)
	| check_tag _ _ = ()

      and check_opt (binds,LT.Option.PRESENT le) = check(binds,le)
	| check_opt _ = ()
    in
      (check([],expression);
	case !unbounds of 
	  [] => ()
	| _ => Print.print ("!!! Lambda expression contains unbound variables: "^(Set.set_print (Set.list_to_set (!unbounds),LT.printLVar))^"\n");
	case !multiply_bounds of
	  [] => ()
	| _ => Print.print ("!!! Lambda expression contains multiply bound variables: "^(Set.set_print (Set.list_to_set (!multiply_bounds),LT.printLVar))^"\n");
       if (!unbounds<>[]) orelse (!multiply_bounds<>[]) orelse !bad
	 then raise in_case_of_error 
       else ())
    end

  fun print_deletion_message (LT.FN (_,_,st,_,_)) =
    (output(std_out,"*** Throwing away function (unused or inlined in all calls) ");
     output(std_out,st);
     output(std_out,"\n"))
    | print_deletion_message _ = ()
      
*)
@


1.79
log
@cout -s lambda/lambdasub.sml
Removing old lambda optimizer stuff
@
text
@d7 4
d175 2
d192 1
a192 1
      fun nest (body,(var,arg)) = LT.LET((var,Option.ABSENT,arg),body)
d205 1
a205 1
      LT.FN([lvar], LT.APP(le, [LT.VAR lvar], LT.Option.PRESENT(ty)),
d213 2
a214 2
  fun apopt f (LT.Option.PRESENT x) = LT.Option.PRESENT (f x)
    | apopt _ LT.Option.ABSENT      = LT.Option.ABSENT;
d239 2
a240 2
      and occurs_opt(LT.Option.ABSENT) = false
	| occurs_opt(LT.Option.PRESENT le) = occurs le
d423 1
a423 1
	appsub LT.Option.ABSENT
d431 1
a431 1
	appsub LT.Option.ABSENT
d480 2
a481 2
        fun check_opt (LT.Option.PRESENT x, LT.Option.PRESENT x') = lambda_equality(x,x')
          | check_opt (LT.Option.ABSENT, LT.Option.ABSENT) = true
d491 3
a493 3
	fun check_info (LT.Option.ABSENT, LT.Option.ABSENT) = true
	  | check_info (LT.Option.PRESENT{num_imms=i, num_vccs=v},
			LT.Option.PRESENT{num_imms=i', num_vccs=v'}) =
d554 2
a555 2
	  fun listit LT.Option.ABSENT = []
	    | listit (LT.Option.PRESENT item) = [item]
d686 2
a687 2
	and rename_opt(LT.Option.ABSENT) = LT.Option.ABSENT
	  | rename_opt(LT.Option.PRESENT le) = LT.Option.PRESENT(rename(le))
d796 2
a797 2
      and sub_opt(LT.Option.ABSENT) = LT.Option.ABSENT
	| sub_opt(arg as (LT.Option.PRESENT le)) = 
d800 1
a800 1
	  else LT.Option.PRESENT(sub(le))
d833 2
a834 2
      and occurs_opt LT.Option.ABSENT = false
	| occurs_opt(LT.Option.PRESENT le) = occurs le
d894 3
a896 3
      and sub_opt(LT.Option.ABSENT) = LT.Option.ABSENT
	| sub_opt(arg as (LT.Option.PRESENT le)) =
	  if !hit then arg else LT.Option.PRESENT(no_check_sub(le))
d958 2
a959 2
      and sub_opt(LT.Option.ABSENT) = LT.Option.ABSENT
	| sub_opt(LT.Option.PRESENT le) = LT.Option.PRESENT(sub(le))
d1033 2
a1034 2
      and occurs_opt(count, LT.Option.ABSENT) = count
	| occurs_opt(count, LT.Option.PRESENT le) = occurs(count, le)
d1075 2
a1076 2
      and occurs_opt(count, LT.Option.ABSENT) = count
	| occurs_opt(count, LT.Option.PRESENT le) = occurs(count, le)
d1191 1
a1191 1
	   val opt = fn (LT.Option.ABSENT,xs) => xs | (LT.Option.PRESENT x,xs) => x::xs
d1349 2
a1350 2
	    fun shiftable_opt (LT.Option.PRESENT e) = shiftable e 
	      | shiftable_opt  LT.Option.ABSENT = true
d1451 2
a1452 2
	     fun subo (LT.Option.PRESENT le, LT.Option.PRESENT le') = subm (le,le')
	       | subo (LT.Option.ABSENT, LT.Option.ABSENT) = true
@


1.78
log
@Use pervasive Option.option for return values in NewMap
@
text
@d7 3
d139 1
a140 1
require "../utils/lists";
d144 4
d151 1
a153 1
  structure Lists : LISTS
d157 3
d162 1
d164 1
d171 120
a318 5
  (* Optionally apply a function to an optional argument *)

  fun apopt f (LT.Option.PRESENT x) = LT.Option.PRESENT (f x)
    | apopt _ LT.Option.ABSENT      = LT.Option.ABSENT;

a321 2
  val LVar_eq = op=

d331 100
a534 153
  (*         - - - - Generalised Recursion Schemes - - - -         *)

  (*
   * Recursively apply a function to a lambda-expression and its
   * sub-expressions, either innermost or outermost terms first, building
   * an isomorphic lambda-expression.  Innermost is AOR, outermost is like
   * AOR but applies the  function to the largest term first. The
   * with_context functions also pass the enclosing lambda expression as
   * an argument to the function.
   *)

  local 
    fun apply_lexprs appsub = 
      let 
	fun apply_tagval (LT.EXP_TAG tagexp, value) =
	      (LT.EXP_TAG (appsub tagexp), appsub value)
	  | apply_tagval (tagexp as LT.IMM_TAG _, value) =
	      (tagexp, appsub value)
	  | apply_tagval (tagexp as LT.VCC_TAG _, value) =
	      (tagexp, appsub value)
	  | apply_tagval (tagexp as LT.SCON_TAG _, value) =
	      (tagexp, appsub value)

	fun apply (le as LT.VAR _) = le
	  | apply (LT.FN(lvl, le,x,ty,instance)) = LT.FN (lvl, appsub le,x,ty,instance) 
	  | apply (LT.LET((lv,info,lb),le)) = LT.LET((lv,info,appsub lb),appsub le)
	  | apply (LT.LETREC(lvl, lel, le)) =
	     LT.LETREC (lvl, map appsub lel, appsub le)
	  | apply (LT.APP(p, q, annotation)) = 
            LT.APP(appsub p, map appsub q, annotation)
	  | apply (le as LT.SCON _) = le
	  | apply (le as LT.MLVALUE _) = le
	  | apply (le as LT.INT _) = le
	  | apply (LT.SWITCH(le, info, clel, leo)) = 
	      LT.SWITCH
	      (appsub le,
	       info,
	       map apply_tagval clel,
	       apopt appsub leo)
	  | apply (LT.STRUCT (lel,ty)) = LT.STRUCT (map appsub lel,ty)
	  | apply (LT.SELECT (fld, le)) = LT.SELECT (fld, appsub le)
	  | apply (LT.RAISE (le)) = LT.RAISE (appsub le)
	  | apply (LT.HANDLE (le1, le2,annotation)) = LT.HANDLE (appsub le1, 
                                                                 appsub le2,
                                                                 annotation)
	  | apply (le as LT.BUILTIN _) = le
      in
	apply
      end


    fun apply_lexprs_with_context appsub = 
      let 
	fun apply_tagval context (LT.EXP_TAG tagexp, value) =
	      (LT.EXP_TAG (appsub context tagexp), appsub context value)
	  | apply_tagval context (tagexp as LT.IMM_TAG _, value) =
	      (tagexp, appsub context value)
	  | apply_tagval context (tagexp as LT.VCC_TAG _, value) =
	      (tagexp, appsub context value)
	  | apply_tagval context (tagexp as LT.SCON_TAG _, value) =
	      (tagexp, appsub context value)

	fun apply (le as LT.VAR _) = le
	  | apply (context as LT.FN(lvl, le,x,ty,instance)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.FN (lvl, appsub ctxt le,x,ty,instance) end
	  | apply (context as LT.LET((lv,info,lb),le)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in 
              LT.LET((lv,info,appsub ctxt lb), appsub ctxt le) 
            end
	  | apply (context as LT.LETREC(lvl, lel, le)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in
              LT.LETREC (lvl, map (appsub ctxt) lel, appsub ctxt le) 
            end
	  | apply (context as LT.APP(p, q, ty)) =
	    let 
              val ctxt = LT.Option.PRESENT context
	    in 
              LT.APP(appsub ctxt p, map (appsub ctxt) q, ty) 
            end
	  | apply (le as LT.SCON _) = le
	  | apply (le as LT.MLVALUE _) = le
	  | apply (le as LT.INT _) = le
	  | apply (context as LT.SWITCH(le, info, clel, leo)) = 
	    let
	      val ctxt = LT.Option.PRESENT context
	    in
	      LT.SWITCH
	      (appsub ctxt le,
	       info,
	       map (apply_tagval ctxt) clel,
	       apopt (appsub ctxt) leo)
	    end
	  | apply (context as LT.STRUCT (lel,ty)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.STRUCT (map (appsub ctxt) lel,ty) end
	  | apply (context as LT.SELECT (fld, le)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.SELECT (fld, appsub ctxt le) end
	  | apply (context as LT.RAISE (le)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.RAISE (appsub ctxt le) end
	  | apply (context as LT.HANDLE (le1, le2,annotation)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.HANDLE (appsub ctxt le1, appsub ctxt le2,annotation) end
	  | apply (le as LT.BUILTIN _) = le
      in
	apply
      end
  in



    fun apply_innermost f = 
      let 
	fun appsub le =
	  f (apply_lexprs appsub le)
      in
	appsub 
      end

    fun apply_innermost_with_context f = 
      let 
	fun appsub context le =
	  f context (apply_lexprs_with_context appsub le)
      in
	appsub LT.Option.ABSENT
      end

    fun apply_outermost f =
      let
	fun appsub le =
	  apply_lexprs appsub (f le)
      in
	appsub
      end

    fun apply_outermost_with_context f =
      let
	fun appsub context le =
	  apply_lexprs_with_context appsub (f context le)
      in
	appsub LT.Option.ABSENT
      end

    val apply_one_level = apply_lexprs
  end


a617 20
  (* Unwrap Lets -- NB! Only removes real lets. *)

  fun unwrap_lets expr =
   let 
     fun unwl(acc, LT.LET((var,info,bind),body)) = 
       unwl((var,bind)::acc,body)
       | unwl(acc, expr) = (rev acc, expr)
   in
     unwl([],expr)
   end

  (* Wrap Lets *)  

  fun wrap_lets (expression, vas) = 
    let
      fun nest (body,(var,arg)) = LT.LET((var,Option.ABSENT,arg),body)
    in
      Lists.reducel nest (expression, rev vas)
    end

a1079 38

  (* quick occurrence check: does the variable occur or not? *)

  fun occurs (lvar, expression) =
    let
      exception Stop
      fun occurs(LT.VAR lv) = if LVar_eq(lv, lvar) then raise Stop else false
	| occurs(LT.FN(_, le,_,_,_)) = occurs(le)
	| occurs(LT.LET((lv,_,lb),le)) = (occurs lb; occurs le)
	| occurs(LT.LETREC(lv_list, le_list, le)) =
	  (occurs le; Lists.exists occurs le_list)
	| occurs(LT.APP(le, lel,_)) = (occurs le; Lists.exists occurs lel)
	| occurs(LT.SCON _) = false
	| occurs(LT.MLVALUE _) = false
	| occurs(LT.INT _) = false
	| occurs(LT.SWITCH(le, info, tag_le_list, leo)) =
	  (occurs le;
	   occurs_opt leo;
	   Lists.exists occurs_tag tag_le_list)
	| occurs(LT.STRUCT (le_list,_)) = Lists.exists occurs (le_list)
	| occurs(LT.SELECT(_, le)) = occurs(le)
	| occurs(LT.RAISE (le)) = occurs(le)
	| occurs(LT.HANDLE(le, le',_)) = (occurs le; occurs le')
	| occurs(LT.BUILTIN _) = false

      and occurs_opt(LT.Option.ABSENT) = false
	| occurs_opt(LT.Option.PRESENT le) = occurs(le)

      and occurs_tag(tag, le) =
	(case tag of
	   LT.EXP_TAG le' => (occurs(le'); occurs(le))
	 | _ => occurs le)
    in
      occurs(expression) handle Stop => true
    end



d1223 1
a1223 1
               LT.null_type_annotation,LT.Option.ABSENT))
a1246 12
 (*  Eta-abstraction over some expression. *)
 (*  Generates a new lambda-variable.				*)

  fun eta_abstract (le,annotation,ty) =
    let
      val lvar = LT.new_LVar()
    in
      LT.FN([lvar], LT.APP(le, [LT.VAR lvar], LT.Option.PRESENT(ty)),
	    annotation,LT.null_type_annotation,LT.Option.ABSENT)
    end


d1567 1
@


1.77
log
@Lambdatypes changes
@
text
@d7 3
d927 1
a927 1
	   LT.Map.YES lv => LT.VAR lv
@


1.76
log
@Abstraction of debug information in lambdatypes
@
text
@d7 3
d222 1
a222 1
    | (LT.LET(var,_,bind,expr), LT.LET(var',_,bind',expr')) =>
d269 1
a269 1
    | (LT.STRUCT(x),LT.STRUCT(y)) => 
d332 1
a332 1
	  | apply (LT.LET(lv,info,lb,le)) = LT.LET(lv,info,appsub lb,appsub le)
d346 1
a346 1
	  | apply (LT.STRUCT lel) = LT.STRUCT (map appsub lel)
d373 1
a373 1
	  | apply (context as LT.LET(lv,info,lb,le)) =
d377 1
a377 1
              LT.LET(lv,info,appsub ctxt lb, appsub ctxt le) 
d404 1
a404 1
	  | apply (context as LT.STRUCT lel) =
d406 1
a406 1
	    in LT.STRUCT (map (appsub ctxt) lel) end
d478 1
a478 1
	    | reduce (acc,LT.LET(lv,_,lb,le)) = reducesub (reducesub(acc,lb),le)
d491 1
a491 1
	    | reduce (acc,LT.STRUCT lel) = reduce_list (acc,lel)
d547 1
a547 1
     fun unwl(acc, LT.LET(var,info,bind,body)) = 
d558 1
a558 1
      fun nest (body,(var,arg)) = LT.LET(var,Option.ABSENT,arg,body)
d594 1
a594 1
	  | rename(LT.LET(lv,info,lb,le)) =
d599 1
a599 1
	      LT.LET(new_var,info,rename_lb, rename le)
d618 1
a618 1
	  | rename(LT.STRUCT le_list) = LT.STRUCT(map rename le_list)
d689 1
a689 1
	| sub(arg as LT.LET(lv,info,lb,le)) =
d693 1
a693 1
	    LT.LET(lv, info,sub lb, if !hit then le else sub le)
d713 1
a713 1
	| sub(arg as LT.STRUCT le_list) =
d717 1
a717 1
	    LT.STRUCT(map_until_hit(sub,le_list))
d756 1
a756 1
	| occurs(LT.LET(lv,_,lb,le)) = occurs lb orelse occurs le
d766 1
a766 1
	| occurs(LT.STRUCT le_list) = (*Lists.exists*) occurs_list le_list
d809 2
a810 2
	| (LT.LET(lv,info,lb,le)) => LT.LET(lv,info,sub lb, 
                                            if !hit then le else no_check_sub le)
d826 1
a826 1
	| (LT.STRUCT le_list) => LT.STRUCT(map_until_hit(sub, le_list))
d876 1
a876 1
	| sub(LT.LET(lv,info,lb,le)) = LT.LET(lv,info,sub lb,sub le)
d890 1
a890 1
	| sub(LT.STRUCT le_list) =  LT.STRUCT(map sub le_list)
d952 1
a952 1
	| occurs(count, LT.LET(lv,_,lb,le)) = occurs(occurs(count,lb),le)
d965 1
a965 1
	| occurs(count, LT.STRUCT le_list) =
d995 1
a995 1
	| occurs(count, LT.LET(lv,_,lb,le)) = occurs(occurs(count,lb),le)
d1007 1
a1007 1
	| occurs(count, LT.STRUCT le_list) =
d1033 1
a1033 1
	| occurs(LT.LET(lv,_,lb,le)) = (occurs lb; occurs le)
d1044 1
a1044 1
	| occurs(LT.STRUCT le_list) = Lists.exists occurs (le_list)
d1072 1
a1072 1
       | build((bs,fs),  LT.LET(lv,_,_,_)) = (bs++lv,fs)
d1133 1
a1133 1
	| LT.STRUCT lel => Lists.reducel sequence (seq,lel)
d1156 1
a1156 1
	 | LT.LET(_,_,lb,le) => evaled(lb)(*evaled(lb) orelse evaled(le)*)
d1159 1
a1159 1
	 | LT.STRUCT lel => Lists.exists evaled lel
d1324 1
a1324 1
	| shiftable(LT.LET(_,_,lb,le)) = (shiftable lb) andalso (shiftable le)
d1345 1
a1345 1
	| shiftable(LT.STRUCT lel) = shiftable_list lel
d1406 1
a1406 1
       | (LT.LET(lv,_,lb,le), LT.LET(lv',_,lb',le')) => 
d1423 1
a1423 1
	     match(envir', LT.STRUCT (le::lel), LT.STRUCT (le'::lel'))
d1464 1
a1464 1
	| (LT.STRUCT les, LT.STRUCT les') =>
d1510 1
a1510 1
	| check (binds,LT.LET(v,_,lb,le)) =
d1532 1
a1532 1
        | check (binds,LT.STRUCT lel) = (Lists.iterate (fn le=>check(binds,le)) lel)
@


1.75
log
@Improve shiftable by adition of shiftable_list
@
text
@d7 3
d150 1
d202 4
a205 10
  fun map2 ([],[]) = true
    | map2 (h::t,a::b) = LVar_eq(h,a) andalso map2(t,b)
    | map2 _ = false

  fun fetch_var' var = 
    case var of
      LT.Option.SOME1(var)=>(var,LT.Option.SOME1)
    | LT.Option.SOME2(ref(var',opt))=>
        (var',fn var''=>LT.Option.SOME2(ref(var'',opt)))
    
d219 2
a220 2
    | (LT.LET(var,bind,expr), LT.LET(var',bind',expr')) =>
	LVar_eq(LT.fetch_var var,LT.fetch_var var') andalso
d228 1
a228 1
        map2 (map LT.fetch_var lvl,map LT.fetch_var lvl')
d255 3
a257 3
	  | check_info (LT.Option.PRESENT{lv=var, num_imms=i, num_vccs=v},
			LT.Option.PRESENT{lv=var', num_imms=i', num_vccs=v'}) =
              LVar_eq(var, var') andalso (i:int) = i' andalso (v:int) = v'
d329 1
a329 1
	  | apply (LT.LET(lv,lb,le)) = LT.LET(lv,appsub lb,appsub le)
d370 6
a375 3
	  | apply (context as LT.LET(lv,lb,le)) =
	    let val ctxt = LT.Option.PRESENT context
	    in LT.LET(lv, appsub ctxt lb, appsub ctxt le) end
d377 5
a381 2
	    let val ctxt = LT.Option.PRESENT context
	    in LT.LETREC (lvl, map (appsub ctxt) lel, appsub ctxt le) end
d475 1
a475 1
	    | reduce (acc,LT.LET(lv,lb,le)) = reducesub (reducesub(acc,lb),le)
d544 2
a545 1
     fun unwl(acc, LT.LET(var,bind,body)) = unwl((LT.fetch_var var,bind)::acc,body)
d555 1
a555 1
      fun nest (body,(var,arg)) = LT.LET(LT.Option.SOME1(var),arg,body)
a581 9
        fun get_new'(var) =
          case var of
            LT.Option.SOME1(var) => 
              LT.Option.SOME1(DelayedNewHashTable.lookup_default (renamehashtable,var,var))
          | LT.Option.SOME2(var' as ref(var'',name)) => 
               LT.Option.SOME2(ref(DelayedNewHashTable.lookup_default (renamehashtable,var'',var''),name))(*
              (var' := (DelayedNewHashTable.lookup_default (renamehashtable,var'',var''),name);
               var)*)
          
d591 1
a591 1
	  | rename(LT.LET(lv,lb,le)) =
a592 1
              val (lv,debug) = fetch_var' lv
d594 1
a594 1
	      val new_var = add_var_and_return(lv)
d596 1
a596 1
	      LT.LET(debug new_var, rename_lb, rename le)
d600 3
a602 1
	      val _ = map (add_var o LT.fetch_var) lv_list
d604 1
a604 1
	      LT.LETREC(map get_new' lv_list, map rename le_list, rename le)
d612 1
a612 1
		        rename_info info,
a621 6
	and rename_info(LT.Option.ABSENT) = LT.Option.ABSENT
	  | rename_info(LT.Option.PRESENT{lv,num_imms,num_vccs}) =
	      LT.Option.PRESENT{lv= get_new lv,
			 num_imms = num_imms,
			 num_vccs = num_vccs}

d686 1
a686 1
	| sub(arg as LT.LET(lv,lb,le)) =
d690 1
a690 1
	    LT.LET(lv, sub lb, if !hit then le else sub le)
d753 1
a753 1
	| occurs(LT.LET(lv,lb,le)) = occurs lb orelse occurs le
d806 2
a807 2
	| (LT.LET(lv,lb,le)) => LT.LET(lv, sub lb, 
				       if !hit then le else no_check_sub le)
d873 1
a873 1
	| sub(LT.LET(lv,lb,le)) = LT.LET(lv,sub lb,sub le)
d949 1
a949 1
	| occurs(count, LT.LET(lv,lb,le)) = occurs(occurs(count,lb),le)
d992 1
a992 1
	| occurs(count, LT.LET(lv,lb,le)) = occurs(occurs(count,lb),le)
d1030 1
a1030 1
	| occurs(LT.LET(lv,lb,le)) = (occurs lb; occurs le)
d1069 1
a1069 1
       | build((bs,fs),  LT.LET(lv,_,_)) = (bs++(LT.fetch_var lv),fs)
d1071 1
a1071 1
	 (Lists.reducel (op++) (bs,map LT.fetch_var lvs), fs)
d1153 1
a1153 1
	 | LT.LET(_,lb,le) => evaled(lb)(*evaled(lb) orelse evaled(le)*)
d1321 1
a1321 1
	| shiftable(LT.LET(_,lb,le)) = (shiftable lb) andalso (shiftable le)
d1403 2
a1404 2
       | (LT.LET(lv,lb,le), LT.LET(lv',lb',le')) => 
	   subm(lb,lb') andalso match((LT.fetch_var lv,LT.fetch_var lv')::envir, le,le')
d1418 1
a1418 1
	     val envir' = Lists.zip (map LT.fetch_var lvl,map LT.fetch_var lvl') @@ envir
d1507 2
a1508 2
	| check (binds,LT.LET(v,lb,le)) =
	  (check(binds,lb); check(add((LT.fetch_var v,lb),binds),le))
d1511 1
a1511 1
	    val binds' = (Lists.reducer add (Lists.zip(map LT.fetch_var lvl,lel),binds))
@


1.74
log
@Functions and applications take a list of parameters
@
text
@d7 3
d1351 1
a1351 1
	| shiftable(LT.STRUCT lel) = Lists.forall shiftable lel
d1356 5
@


1.73
log
@Removed all raises of BadCallToNoCheckSub, making result equal to original
I think there is some longstanding optimiser bug still here somewhere,\nto do with not finding the right number of occurrences of a var for\nsubstitution, but finding that will have to wait.
@
text
@d7 4
d184 5
d215 2
a216 2
    | (LT.FN(var,body,_,_,_), LT.FN(var',body',_,_,_)) =>
        LVar_eq(var,var') andalso lambda_equality(body,body')
d231 1
a231 1
	lambda_equality(f,f') andalso lambda_equality(g,g')
d327 1
a327 1
	  | apply (LT.FN(lv, le,x,ty,instance)) = LT.FN (lv, appsub le,x,ty,instance) 
d331 2
a332 3
	  | apply (LT.APP(p, q, annotation)) = LT.APP(appsub p, 
						      appsub q, 
						      annotation)
d366 1
a366 1
	  | apply (context as LT.FN(lv, le,x,ty,instance)) =
d368 1
a368 1
	    in LT.FN (lv, appsub ctxt le,x,ty,instance) end
d376 5
a380 2
	    let val ctxt = LT.Option.PRESENT context
	    in LT.APP(appsub ctxt p, appsub ctxt q, ty) end
d474 1
a474 1
	    | reduce (acc,LT.APP(p,q,_)) = reducesub (reducesub(acc,p),q) 
a542 11
(*
  fun unwrap_lets expr =
    let 
      fun unwl(acc, LT.APP(LT.FN(var,body,_,_,_),arg,_)) = 
        unwl((var,arg)::acc,body)
	| unwl(acc, expr) = (rev acc, expr)
    in
      unwl([],expr)
    end
*)

a551 11
(*
  fun wrap_lets (expression, vas) = 
    let
      fun nest (body,(var,arg,comment_string,ty)) = 
        LT.APP(LT.FN(var,body,comment_string,ty),arg,_)
    in
      Lists.reducel nest (expression, rev vas)
    end
*)


d584 1
a584 1
	  | rename(LT.FN(var, le,n,ty,instance)) =
d588 1
a588 1
	      LT.FN(new_var, rename(le),n,ty,instance)
d590 2
d606 1
a606 1
	  | rename(LT.APP(le, le',ty)) = LT.APP(rename(le), rename(le'),ty)
d688 1
a688 1
        | sub(arg as LT.FN(lv, le,n,ty,instance)) = 
d690 1
a690 1
            then LT.FN(lv, sub(le),n,ty,instance)
d702 1
a702 1
        | sub(arg as LT.APP(le, le',ty)) =
d706 1
a706 1
	    LT.APP(sub le, if !hit then le' else sub le',ty)
d758 1
a758 1
        | occurs(arg as LT.FN(lv, le, _, _,_)) = inside_functions andalso occurs le
d763 1
a763 1
        | occurs(LT.APP(le, le', _)) = occurs le orelse occurs le'
d808 1
a808 1
	| (arg as LT.FN(lv, le,n,ty,instance)) =>
d810 1
a810 1
	      then LT.FN(lv, no_check_sub(le),n,ty,instance)
d819 3
a821 3
	| (LT.APP(le, le',ty)) =>
	    LT.APP(sub le, if !hit then le' else no_check_sub le',ty)
	| (le as LT.SCON _) => le(*raise BadCallToNoCheckSub "LT.SCON"*)
d880 1
a880 1
	| sub(LT.FN(lv, le,n,ty,instance)) = LT.FN(lv, sub(le),n,ty,instance)
d883 2
a884 2
	| sub(LT.APP(le, le',ty)) =
	  LT.APP(sub le, sub le',ty)
d958 2
a959 2
	| occurs(count, LT.APP(le, le',_)) =
	  occurs(occurs(count, le), le')
d1001 1
a1001 1
	| occurs(count, LT.APP(le, le',_)) = occurs(occurs(count, le), le')
d1039 1
a1039 1
	| occurs(LT.APP(le, le',_)) = (occurs le; occurs le')
d1073 2
a1074 3

       | build((bs,fs),  LT.FN(var,_,_,_,_)) = (bs++var, fs)

a1075 1

a1077 1

d1134 1
a1134 1
	| LT.APP(p,q,_) => sequence(sequence(seq,p),q)
d1160 1
a1160 1
	 | LT.APP(p,q,_) => evaled(p) orelse evaled(q)
d1207 1
a1207 1
	 LT.FN(new_variable, 
d1240 1
a1240 1
      LT.FN(lvar, LT.APP(le, LT.VAR lvar, LT.Option.PRESENT(ty)),
d1262 2
a1263 1
	fun strip (vars,LT.FN(var,body,_,_,_)) = strip(var::vars,body)
d1330 1
a1330 1
	  (shiftable q) andalso 
d1407 1
a1407 1
       | (LT.FN(var,body,_,_,_), LT.FN(var',body',_,_,_)) =>
d1410 3
d1424 1
a1424 1
       | (LT.APP(f,g,_), LT.APP(f',g',_)) => subm(f,f') andalso subm(g,g')
d1506 2
a1507 1
	| check (binds,LT.FN(bv,le,_,_,_)) = check(add((bv,bound_var),binds),le)
d1521 1
a1521 1
	| check (binds,LT.APP(p,q,_)) = (check(binds,p); check(binds,q))
d1530 1
a1530 1
        | check (binds,LT.STRUCT lel) = (map (fn le=>check(binds,le)) lel; ())
@


1.72
log
@Improved occurs by expanding out the Lists.exists calls.
@
text
@d7 3
d830 3
a832 3
	| (le as LT.SCON _) => raise BadCallToNoCheckSub "LT.SCON"
	| (le as LT.MLVALUE _) => raise BadCallToNoCheckSub "LT.MLVALUE"
	| (le as LT.INT _) => raise BadCallToNoCheckSub "LT.INT"
d843 1
a843 1
	| (le as LT.BUILTIN _) => raise BadCallToNoCheckSub "LT.BUILTIN"
@


1.71
log
@Improved substitute_once to avoid checking before starting, it wouldn't
have been called if nothing was to be done.
@
text
@d7 4
d768 1
a768 1
          (inside_functions andalso Lists.exists occurs le_list)
d774 2
a775 2
	  occurs le orelse occurs_opt leo orelse Lists.exists occurs_tag tag_le_list
	| occurs(LT.STRUCT le_list) = Lists.exists occurs le_list
d784 1
d789 1
d794 6
@


1.70
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d7 4
d785 3
d841 5
a845 1
      (sub expr,!hit)
@


1.69
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d7 4
d195 1
a195 1
    | (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =>
d207 1
a207 1
        map2 (lvl,lvl')
a263 1

d307 1
a307 1
	  | apply (LT.FN(lv, le,x,ty)) = LT.FN (lv, appsub le,x,ty) 
d347 1
a347 1
	  | apply (context as LT.FN(lv, le,x,ty)) =
d349 1
a349 1
	    in LT.FN (lv, appsub ctxt le,x,ty) end
d444 1
a444 1
	  fun reduce (acc,LT.FN(_,le,_,_)) = reducesub (acc,le)
d524 1
a524 1
      fun unwl(acc, LT.APP(LT.FN(var,body,_,_),arg,_)) = 
d584 1
a584 1
	  | rename(LT.FN(var, le,n,ty)) =
d588 1
a588 1
	      LT.FN(new_var, rename(le),n,ty)
d686 1
a686 1
        | sub(arg as LT.FN(lv, le,n,ty)) = 
d688 1
a688 1
            then LT.FN(lv, sub(le),n,ty)
d756 1
a756 1
        | occurs(arg as LT.FN(lv, le, _, _)) = inside_functions andalso occurs le
d795 1
a795 1
	| (arg as LT.FN(lv, le,n,ty)) =>
d797 1
a797 1
	      then LT.FN(lv, no_check_sub(le),n,ty)
d863 1
a863 1
	| sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
d937 1
a937 1
	| occurs(count, LT.FN(_, le,_,_)) = occurs(count, le)
d980 1
a980 1
	| occurs(count, LT.FN(_, le,_,_)) = occurs(count, le)
d1018 1
a1018 1
	| occurs(LT.FN(_, le,_,_)) = occurs(le)
d1057 1
a1057 1
       | build((bs,fs),  LT.FN(var,_,_,_)) = (bs++var, fs)
d1195 1
a1195 1
               LT.null_type_annotation))
d1227 1
a1227 1
	    annotation,LT.null_type_annotation)
d1248 1
a1248 1
	fun strip (vars,LT.FN(var,body,_,_)) = strip(var::vars,body)
d1268 1
a1268 1
	and getfun (LT.FN(var,body,annotation,ty), arg::args, result) = 
d1319 1
a1319 1
	   | LT.FN (var,body,_,_) =>  shiftable body
d1392 1
a1392 1
       | (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =>
d1488 1
a1488 1
	| check (binds,LT.FN(bv,le,_,_)) = check(add((bv,bound_var),binds),le)
d1535 1
a1535 1
  fun print_deletion_message (LT.FN (_,_,st,_)) =
@


1.69.1.1
log
@Fork for bug fixing
@
text
@a6 4
Revision 1.69  1993/07/15  09:14:18  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.68
log
@Modified substitute_once to look before copying except when
a substitution is known to be in a particular expression.
produce a 20% speed up in lambda optimisation on _actionfunctions
@
text
@d7 5
d157 2
a158 2
  fun apopt f (LT.PRESENT x) = LT.PRESENT (f x)
    | apopt _ LT.ABSENT      = LT.ABSENT;
d175 8
a182 2
  fun tag_equality(LT.VCC_TAG x,LT.VCC_TAG y) = (x=y)
    | tag_equality(LT.IMM_TAG x,LT.IMM_TAG y) = (x=y)
d195 1
a195 1
	LVar_eq(var,var') andalso
d203 2
a204 2
	map2 (lvl,lvl')
	andalso lambda_list_equality(le::lel, le'::lel')
d218 2
a219 2
        fun check_opt (LT.PRESENT x, LT.PRESENT x') = lambda_equality(x,x')
          | check_opt (LT.ABSENT, LT.ABSENT) = true
d229 3
a231 3
	fun check_info (LT.ABSENT, LT.ABSENT) = true
	  | check_info (LT.PRESENT{lv=var, num_imms=i, num_vccs=v},
			LT.PRESENT{lv=var', num_imms=i', num_vccs=v'}) =
d246 1
a246 1
    | (LT.RAISE e, LT.RAISE e') => lambda_equality (e,e')
d248 2
a249 1
    | (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_))=> lambda_equality(e,e') andalso lambda_equality(h,h')
d322 1
a322 1
	  | apply (LT.RAISE le) = LT.RAISE (appsub le)
d345 1
a345 1
	    let val ctxt = LT.PRESENT context
d348 1
a348 1
	    let val ctxt = LT.PRESENT context
d351 1
a351 1
	    let val ctxt = LT.PRESENT context
d354 1
a354 1
	    let val ctxt = LT.PRESENT context
d361 1
a361 1
	      val ctxt = LT.PRESENT context
d370 1
a370 1
	    let val ctxt = LT.PRESENT context
d373 1
a373 1
	    let val ctxt = LT.PRESENT context
d375 2
a376 2
	  | apply (context as LT.RAISE le) =
	    let val ctxt = LT.PRESENT context
d379 1
a379 1
	    let val ctxt = LT.PRESENT context
d402 1
a402 1
	appsub LT.ABSENT
d418 1
a418 1
	appsub LT.ABSENT
d438 2
a439 2
	  fun listit LT.ABSENT = []
	    | listit (LT.PRESENT item) = [item]
d460 1
a460 1
	    | reduce (acc,LT.RAISE le) = reducesub (acc,le)
d512 1
a512 1
     fun unwl(acc, LT.LET(var,bind,body)) = unwl((var,bind)::acc,body)
d521 2
a522 1
      fun unwl(acc, LT.APP(LT.FN(var,body,_,_),arg)) = unwl((var,arg)::acc,body)
d533 1
a533 1
      fun nest (body,(var,arg)) = LT.LET(var,arg,body)
d542 1
a542 1
        LT.APP(LT.FN(var,body,comment_string,ty),arg)
d568 11
a578 2
        fun get_new(var) =
          DelayedNewHashTable.lookup_default (renamehashtable,var,var)
d589 1
d593 1
a593 1
	      LT.LET(new_var, rename_lb, rename le)
d597 1
a597 1
	      val _ = map add_var lv_list
d599 1
a599 1
	      LT.LETREC(map get_new lv_list, map rename le_list, rename le)
d612 1
a612 1
	  | rename(LT.RAISE le) = LT.RAISE(rename(le))
d617 3
a619 3
	and rename_info(LT.ABSENT) = LT.ABSENT
	  | rename_info(LT.PRESENT{lv,num_imms,num_vccs}) =
	      LT.PRESENT{lv= get_new lv,
d623 2
a624 2
	and rename_opt(LT.ABSENT) = LT.ABSENT
	  | rename_opt(LT.PRESENT le) = LT.PRESENT(rename(le))
d721 1
a721 1
	| sub(arg as LT.RAISE le) =
d733 2
a734 2
      and sub_opt(LT.ABSENT) = LT.ABSENT
	| sub_opt(arg as (LT.PRESENT le)) = 
d737 1
a737 1
	  else LT.PRESENT(sub(le))
d770 2
a771 2
      and occurs_opt LT.ABSENT = false
	| occurs_opt(LT.PRESENT le) = occurs le
d820 3
a822 3
      and sub_opt(LT.ABSENT) = LT.ABSENT
	| sub_opt(arg as (LT.PRESENT le)) =
	  if !hit then arg else LT.PRESENT(no_check_sub(le))
d875 1
a875 1
	| sub(LT.RAISE le) = LT.RAISE(sub(le))
d880 2
a881 2
      and sub_opt(LT.ABSENT) = LT.ABSENT
	| sub_opt(LT.PRESENT le) = LT.PRESENT(sub(le))
d904 4
a907 4
     val var_map = LambdaTypes.Map.from_list var_list
      fun subs (v as LambdaTypes.VAR lvar) =
	(case LambdaTypes.Map.tryApply'(var_map, lvar) of
	   LambdaTypes.Map.YES lv => LambdaTypes.VAR lv
d951 1
a951 1
	| occurs(count, LT.RAISE le) = occurs(count, le)
d955 2
a956 2
      and occurs_opt(count, LT.ABSENT) = count
	| occurs_opt(count, LT.PRESENT le) = occurs(count, le)
d993 1
a993 1
	| occurs(count, LT.RAISE le) = occurs(count, le)
d997 2
a998 2
      and occurs_opt(count, LT.ABSENT) = count
	| occurs_opt(count, LT.PRESENT le) = occurs(count, le)
d1029 1
a1029 1
	| occurs(LT.RAISE le) = occurs(le)
d1033 2
a1034 2
      and occurs_opt(LT.ABSENT) = false
	| occurs_opt(LT.PRESENT le) = occurs(le)
d1056 1
a1056 1
       | build((bs,fs),  LT.LET(lv,_,_)) = (bs++lv,fs)
d1059 1
a1059 1
	 (Lists.reducel (op++) (bs,lvs), fs)
d1121 1
a1121 1
	| LT.RAISE e => sequence(seq,e)
d1147 1
a1147 1
	 | LT.RAISE e => evaled(e)
d1154 1
a1154 1
	   val opt = fn (LT.ABSENT,xs) => xs | (LT.PRESENT x,xs) => x::xs
d1190 3
a1192 1
	 LT.FN(new_variable, apply_outermost abstract expression,"_lambdasub beta abstract",LT.null_type_annotation))
d1223 1
a1223 1
      LT.FN(lvar, LT.APP(le, LT.VAR lvar, ty),
d1262 1
a1262 1
	fun getargs (LT.APP(func,arg,ty), args) = getargs(func, (arg,ty)::args)
d1323 2
a1324 2
	    fun shiftable_opt (LT.PRESENT e) = shiftable e 
	      | shiftable_opt  LT.ABSENT = true
d1366 2
a1367 2
	 | tag_eq (LT.IMM_TAG tag,LT.IMM_TAG tag') = tag=tag'
	 | tag_eq (LT.VCC_TAG tag,LT.VCC_TAG tag') = tag=tag'
d1387 1
a1387 1
	   subm(lb,lb') andalso match((lv,lv')::envir, le,le')
d1398 1
a1398 1
	     val envir' = Lists.zip (lvl,lvl') @@ envir
d1417 2
a1418 2
	     fun subo (LT.PRESENT le, LT.PRESENT le') = subm (le,le')
	       | subo (LT.ABSENT, LT.ABSENT) = true
d1447 1
a1447 1
	| (LT.RAISE e, LT.RAISE e') => subm (e,e')
d1487 1
a1487 1
	  (check(binds,lb); check(add((v,lb),binds),le))
d1490 1
a1490 1
	    val binds' = (Lists.reducer add (Lists.zip(lvl,lel),binds))
d1510 1
a1510 1
	| check (binds,LT.RAISE le) = check(binds,le)
d1517 1
a1517 1
      and check_opt (binds,LT.PRESENT le) = check(binds,le)
@


1.67
log
@Signature revisions
@
text
@d7 3
d727 1
a727 1
fun substitute_once inside_functions (var, subexpr, expr) =
d729 26
a755 32
      fun sub(le as LT.VAR lv) =
          if LVar_eq(lv, var) 
            then  (hit := true;
                   subexpr)
          else le
        | sub(arg as LT.FN(lv, le,n,ty)) = 
          if inside_functions
            then LT.FN(lv, sub(le),n,ty)
          else arg
	| sub(LT.LET(lv,lb,le)) = LT.LET(lv, sub lb, 
					 if !hit then le else sub le)
        | sub(arg as LT.LETREC(lv_list, le_list, le)) =
          if inside_functions
            then LT.LETREC(lv_list, map_until_hit(sub,le_list),
			   if !hit then le else sub le)
          else arg
        | sub(LT.APP(le, le',ty)) =
          LT.APP(sub le, if !hit then le' else sub le',ty)
	| sub(le as LT.SCON _) = le
	| sub(le as LT.MLVALUE _) = le
	| sub(le as LT.INT _) = le
	| sub(LT.SWITCH(le, info, tag_le_list, leo)) =
	LT.SWITCH(sub le,
		  info,
		  map_until_hit(sub_tag,tag_le_list), 
		  sub_opt leo)
	| sub(LT.STRUCT le_list) =  LT.STRUCT(map_until_hit(sub,le_list))
	| sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
	| sub(LT.RAISE le) = LT.RAISE(sub(le))
	| sub(LT.HANDLE(le, le',annotation)) = 
	  LT.HANDLE(sub(le), if !hit then le' else sub le',annotation)
	| sub(le as LT.BUILTIN _) = le
d757 40
d798 2
a799 4
	| sub_opt(arg as (LT.PRESENT le)) = 
	  if !hit 
	    then arg
	  else LT.PRESENT(sub(le))
d804 1
a804 2
             if !hit 
               then tag
@


1.66
log
@Removed LVar_eq in favour of polymorphic equality
@
text
@d7 3
d117 1
a117 1
  structure Ident = LT.Datatypes.Ident
@


1.65
log
@Added MLVALUE lambda exp
@
text
@d7 3
d152 1
a152 1
  val LVar_eq = LT.LVar_eq
d160 4
d186 2
a187 8
        let
          fun map2 ([],[]) = true
            | map2 (h::t,a::b) = LVar_eq(h,a) andalso map2(t,b)
            | map2 _ = false
        in
          map2 (lvl,lvl')
          andalso lambda_equality(LT.STRUCT (le::lel), LT.STRUCT (le'::lel'))
        end
d225 1
a225 9
        let
          fun map2([],[]) = true
            | map2(h::t,a::b) = if lambda_equality(h,a)
                                  then map2(t,b)
                                else false
            | map2 _ = false
        in
          map2(x,y)
        end
d237 5
@


1.64
log
@Stopped optimising switch info inconsistently
@
text
@d7 3
d193 2
d255 1
d296 1
d341 1
d576 1
d676 1
d745 1
d808 1
d883 1
d925 1
d963 1
d1259 1
d1347 2
d1441 1
@


1.63
log
@Removed polymorphic equality on SCONs
@
text
@d7 3
a1351 7
	     val (envir', info_match) =
	       case (info, info') of
	         (LambdaTypes.ABSENT, LambdaTypes.ABSENT) => (envir, true)
	       | (LambdaTypes.PRESENT{lv=var, ...},
		  LambdaTypes.PRESENT{lv=var', ...}) =>
		    ((var,var')::envir, true)
	       | _ => (envir, false)
a1353 1
	     if info_match then
d1356 2
a1357 2
	        | NONE => match(envir', le, le')
	        | SAME => match(envir', le ,le') andalso
d1359 1
a1359 1
		          all_vals(envir', clel, clel'))
a1360 1
	     else false
@


1.62
log
@In rename the substitution forced a new variable for the bindings
causing problems later in the substitution
@
text
@d7 4
d153 1
a153 1
    | tag_equality(LT.SCON_TAG x,LT.SCON_TAG y) = (x=y)
d185 1
a185 1
    | (LT.SCON x, LT.SCON y) => (x=y)
d1326 1
a1326 1
       | (LT.SCON x, LT.SCON y) => (x=y)
@


1.61
log
@Minor improvements in sub in subsititute_at_most_once or whatever it is.
@
text
@d7 3
d576 1
a576 1
	      LT.PRESENT{lv=add_var_and_return lv,
@


1.60
log
@Added some LETREC optimisation
@
text
@d7 3
d719 2
a720 1
            then LT.LETREC(lv_list, map_until_hit(sub,le_list), sub le)
@


1.59
log
@Reworked substitute_n_occurences to be a bit more efficient
@
text
@d7 3
d1448 6
@


1.58
log
@Minor changes to support the new type of SWITCHes.
@
text
@d7 3
d591 1
d593 1
d595 2
a596 1
 (*  Single substitution of a variable for an expression  *)
d598 2
a599 9
(* old version:
 fun substitute (var,subexpr,expr) =
   let
     fun subs (v as LT.VAR lvar) = if LVar_eq(var, lvar) then subexpr else v
     | subs expr = expr
   in
     apply_outermost subs expr
   end
*)
d601 10
a610 1
    exception DidntFindCorrectNumber
d612 4
a615 1
  fun substitute_n_occurrences inside_functions (var, subexpr, expr,n) =
d617 2
a618 2
      val hit = ref(false)
      val count = ref(n)
a619 13
      fun map_until_hit(f,x) = 
        let
          fun add_to_front([],x) = x
            | add_to_front(h::t,x) = add_to_front(t,h::x)
          fun map_sub(f,[],res) = rev res
            | map_sub(f,arg as (h::t),res) = 
              if !hit
                then add_to_front(res,arg)
              else map_sub(f,t,f(h)::res)
        in
          map_sub(f,x,[])
        end

d621 10
a630 11
          if LVar_eq(lv, var) 
            then 
	      (let 
		 val c = !count
	       in
		 if c=1 then hit:=true
		 else if c>0 then count := c-1
		      else ()
	       end;
	       subexpr)
          else le
d632 1
a632 1
          if inside_functions
d635 5
a639 2
	| sub(LT.LET(lv,lb,le)) = LT.LET(lv, sub lb, 
					 if !hit then le else sub le)
d641 3
a643 2
          if inside_functions
            then LT.LETREC(lv_list, map_until_hit(sub,le_list), sub le)
d645 5
a649 2
        | sub(LT.APP(le, le',ty)) =
          LT.APP(sub le, if !hit then le' else sub le',ty)
d652 26
a677 8
	| sub(LT.SWITCH(le, info, tag_le_list, leo)) =
	  LT.SWITCH(sub le, info, map_until_hit(sub_tag,tag_le_list), 
		    sub_opt leo)
	| sub(LT.STRUCT le_list) =
	  LT.STRUCT(map_until_hit(sub,le_list))
	| sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
	| sub(LT.RAISE le) = LT.RAISE(sub(le))
	| sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), if !hit then le' else sub le',annotation)
d699 1
a699 15
      val hit = ref(false)

      fun map_until_hit(f,x) = 
        let
          fun add_to_front([],x) = x
            | add_to_front(h::t,x) = add_to_front(t,h::x)
          fun map_sub(f,[],res) = rev res
            | map_sub(f,arg as (h::t),res) = 
              if !hit
                then add_to_front(res,arg)
              else map_sub(f,t,f(h)::res)
        in
          map_sub(f,x,[])
        end

a814 36
(* 
  fun substitute_fresh (var, subexpr, expr) =
    let
      fun sub(le as LT.VAR lv) =
	if LVar_eq(lv, var) then rename_fresh subexpr else le
	| sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
	| sub(LT.LET(lv,lb,le)) = LT.LET(lv, sub lb, sub le)
	| sub(LT.LETREC(lv_list, le_list, le)) =
	  LT.LETREC(lv_list, map sub le_list, sub le)
	| sub(LT.APP(le, le')) = LT.APP(sub le, sub le')
	| sub(le as LT.SCON _) = le
	| sub(le as LT.INT _) = le
	| sub(LT.SWITCH(le, info, tag_le_list, leo)) =
	  LT.SWITCH(sub le,
		    info,
		    map sub_tag tag_le_list, 
		    sub_opt leo)
	| sub(LT.STRUCT le_list) = LT.STRUCT(map sub le_list)
	| sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
	| sub(LT.RAISE le) = LT.RAISE(sub(le))
	| sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), sub le',
							 annotation)
	| sub(le as LT.BUILTIN _) = le

      and sub_opt(LT.ABSENT) = LT.ABSENT
	| sub_opt(LT.PRESENT le) = LT.PRESENT(sub(le))

      and sub_tag((tag, le)) =
	(case tag of
	   LT.EXP_TAG le => LT.EXP_TAG(sub(le))
	 | _ => tag, sub le)
    in
      sub expr
    end
*)

d817 1
a817 1
      val var_domain = map #1 var_list
d819 3
a821 5
	if Lists.member(lvar, var_domain) then
	  LambdaTypes.VAR(Lists.assoc(lvar, var_list))
	  handle Lists.Assoc => Crash.impossible("substitute_list of " ^ 
						 LambdaTypes.printLVar lvar)
	else v
@


1.57
log
@Changes for the newhashtables
@
text
@d7 3
d135 7
a141 1
  fun lambda_equality (expression_pair as (e1,e2)) =
d166 2
a167 1
    | (LT.APP(f,g,_), LT.APP(f',g',_)) => lambda_equality(f,f') andalso lambda_equality(g,g')
d173 2
a174 2
    | (LT.SWITCH(le,clel,leo1,leo2),
       LT.SWITCH(le',clel',leo1',leo2')) =>
d176 2
a177 2
        fun check_opt (LT.PRESENT x,LT.PRESENT x') = lambda_equality(x,x')
          | check_opt (LT.ABSENT,LT.ABSENT) = true
d179 1
a179 4
        fun check_tag (LT.CON_TAG x,LT.CON_TAG y) = (x=y)
          | check_tag (LT.SCON_TAG x,LT.SCON_TAG y) = (x=y)
          | check_tag (LT.EXP_TAG x,LT.EXP_TAG y) = lambda_equality(x,y)
          | check_tag _ = false
d181 4
a184 1
          | check_tags((h,le)::t,(a,le')::b) = check_tag(h,a) andalso lambda_equality(le,le') andalso check_tags(t,b)
d186 6
d194 3
a196 3
        andalso check_opt(leo1,leo1')
        andalso check_opt(leo2,leo2')
        andalso check_tags (clel,clel')
a220 5
  fun tag_equality(LT.CON_TAG x,LT.CON_TAG y) = (x=y)
    | tag_equality(LT.SCON_TAG x,LT.SCON_TAG y) = (x=y)
    | tag_equality(LT.EXP_TAG x,LT.EXP_TAG y) = lambda_equality(x,y)
    | tag_equality _ = false

d254 5
a258 3
	    (LT.EXP_TAG (appsub tagexp), appsub value)
	  | apply_tagval (tagexp as LT.CON_TAG _, value) =
	    (tagexp, appsub value)
d260 1
a260 1
	    (tagexp, appsub value)
d272 1
a272 1
	  | apply (LT.SWITCH(le, clel, leo1, leo2)) = 
d275 1
d277 1
a277 1
	       apopt appsub leo1, apopt appsub leo2)
d293 5
a297 3
	    (LT.EXP_TAG (appsub context tagexp), appsub context value)
	  | apply_tagval context (tagexp as LT.CON_TAG _, value) =
	    (tagexp, appsub context value)
d299 1
a299 1
	    (tagexp, appsub context value)
d316 1
a316 1
	  | apply (context as LT.SWITCH(le, clel, leo1, leo2)) = 
d322 1
d324 1
a324 1
	       apopt (appsub ctxt) leo1, apopt (appsub ctxt) leo2)
d408 1
a408 1
	    | reduce (acc,LT.SWITCH(le,clel,leo1,leo2)) = 
d410 2
a411 3
			   (caseexprs_of (clel,[]))@@
			   (listit leo1)@@
			   (listit leo2))
d550 5
a554 5
	  | rename(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	    LT.SWITCH(rename(le),
		      map rename_tag tag_le_list,
		      rename_opt(leo1),
		      rename_opt(leo2))
d558 2
a559 1
	  | rename(LT.HANDLE(le, le',annotation)) = LT.HANDLE(rename(le), rename(le'),annotation)
d562 6
d574 3
a576 2
	 | _ => tag,
	     rename(le))
d631 2
a632 1
	       end; subexpr)
d648 3
a650 3
	| sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	  LT.SWITCH(sub le, map_until_hit(sub_tag,tag_le_list), 
		    sub_opt leo1, sub_opt leo2)
d711 5
a715 3
	| sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(sub le, map_until_hit(sub_tag,tag_le_list), 
		  sub_opt leo1, sub_opt leo2)
d773 5
a777 3
	| sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	  LT.SWITCH(sub le, map sub_tag tag_le_list, 
		    sub_opt leo1, sub_opt leo2)
d819 5
a823 3
	| sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	  LT.SWITCH(sub le, map sub_tag tag_le_list, 
		    sub_opt leo1, sub_opt leo2)
d885 1
a885 1
	| occurs(count, LT.SWITCH(le, tag_le_list, leo1, leo2)) =
d888 1
a888 1
	  (occurs(occurs_opt(occurs_opt(count, leo1), leo2), le),
d926 1
a926 1
	| occurs(count, LT.SWITCH(le, tag_le_list, leo1, leo2)) =
d929 1
a929 1
	  (occurs(occurs_opt(occurs_opt(count, leo1), leo2), le),
d963 3
a965 2
	| occurs(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	  (occurs le; occurs_opt leo1; occurs_opt leo2;
d1091 1
a1091 1
      and switch_evaled (e,cases,cdef,pdef) =
d1104 1
a1104 1
	      val results = opt (cdef, opt (pdef, (map snd cases)))
d1258 1
a1258 1
	| shiftable(LT.SWITCH (le,clel,leo1,leo2)) =
d1264 1
a1264 2
	    (shiftable_opt leo1) andalso
	    (shiftable_opt leo2) andalso
d1296 1
a1296 2
  (*  equality.  (ditto for lambada_equality)			  *)

d1303 2
a1304 1
	 | tag_eq (LT.CON_TAG tag,LT.CON_TAG tag') = tag=tag'
d1313 3
a1315 2
       and all_vals ((_,x)::xs,(_,y)::ys) = subm(x,y) andalso all_vals(xs,ys)
	 | all_vals ([],[]) = true
d1346 2
a1347 2
       | (LT.SWITCH(le,clel,leo1,leo2),
	  LT.SWITCH(le',clel',leo1',leo2')) =>
d1350 1
a1350 1
	 (* be done for SCON_TAG and CON_TAG *)
d1359 2
a1360 1
	       | tag_kind ((LT.CON_TAG _, _) :: _, (LT.CON_TAG _, _) :: _)=SAME
d1364 8
d1374 9
a1382 7
	     (case tag_kind(clel,clel') of 
		DIFFERENT => false
	     | NONE => subm(le,le')
	     | SAME => subm(le,le') andalso
		       all_tags(clel,clel') andalso 
		       all_vals(clel,clel'))
	      andalso subo (leo1,leo1') andalso subo (leo2,leo2')
d1446 1
a1446 1
	| check (binds,LT.SWITCH(le,tlel,leo1,leo2)) =
d1449 2
a1450 3
	   map (fn(_,le)=> check(binds,le)) tlel;
	   check_opt (binds,leo1);
	   check_opt (binds,leo2))
@


1.56
log
@Changed hashtables to a single structure implementation
@
text
@d7 3
d68 1
a68 1
require "../utils/__delayed_newhashtable";
@


1.55
log
@Got rid of handles involving hash tables
@
text
@d7 3
d65 1
a65 2
require "../utils/_newhashtable";
require "../utils/_delayed_newhashtable";
d75 2
a489 10
    structure RenameHashTable = 
      DelayedNewHashTable(
        structure Crash = Crash
        structure Lists = Lists
        type Key    = LT.LVar
        type Value  = LT.LVar
        val size    = 32
        val hash = LT.int_of_LVar
        val eq = LT.LVar_eq)
      
d492 1
a492 1
        val renamehashtable = RenameHashTable.new()
d495 1
a495 1
            RenameHashTable.update(renamehashtable,var, LT.new_LVar())
d500 1
a500 1
            val _ = RenameHashTable.update(renamehashtable,var,new_var)
d506 1
a506 1
          RenameHashTable.lookup_default (renamehashtable,var,var)
d556 1
a556 1
                    RenameHashTable.string_hash_table_stats(renamehashtable) ^ "\n")
@


1.54
log
@Removed some redundant structures and sharing
@
text
@d7 3
d63 1
d487 1
a487 1
      NewHashTable(
a495 2
   datatype LazyMake = Instantiated of RenameHashTable.HashTable | NotInstantiated

d498 1
a498 13
        val renamehashtable = ref(NotInstantiated)

        fun gethashtable() =
          case !renamehashtable of
            Instantiated(x) => x
          | NotInstantiated =>
              let
                val x = RenameHashTable.new()
                val _ =
                  renamehashtable := Instantiated x
              in
                x
              end
d501 1
a501 1
            RenameHashTable.update(gethashtable(),var, LT.new_LVar())
d506 1
a506 1
            val _ = RenameHashTable.update(gethashtable(),var,new_var)
d512 2
a513 6
          case !renamehashtable of
            Instantiated table =>
              (RenameHashTable.lookup (table,var)
               handle RenameHashTable.Lookup _ => var)
          | NotInstantiated => var

d561 2
a562 5
             case !renamehashtable of
               Instantiated x => 
                 output(std_out,"Rename hash table in _lambdasub" ^ 
                        RenameHashTable.string_hash_table_stats(x) ^ "\n")
             | _ => ()
a1434 72
				    





(* not used.

  (*  First order matching.  Assumes bound variables in each    *)
  (*  expression are unique.  Extends the mapping of variables  *)
  (*  in the first expr to sub-exprs in the second.		*)
  
  exception FailedMatch;

  fun match(envir, exprs as (e1,e2)) = 
   let 
    fun submatch(LT.VAR v1, _) = (match(envir, (e2,Lists.assoc(v1,envir)))
				  handle Lists.Assoc => (v1,e2)::envir)

      | submatch (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =
      	  match((var,LT.VAR var')::envir, (body, body'))

      | submatch (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =
        let
       	    val envir1 = (Lists.zip (lvl, map LT.VAR lvl')) @@ envir
	    val envir2 = Lists.reducel match (envir1, Lists.zip (lel, lel'))
	in
	    match (envir2, (le,le'))
	end

      | submatch (LT.APP(f,g), LT.APP(f',g')) =
          match((match (envir,(f,f'))), (g,g'))

      | submatch (LT.SWITCH(le,clel,leo1,leo2),
		  LT.SWITCH(le',clel',leo1',leo2')) =
	let
	    val envir1 = match(envir, (le,le'))
	    val envir2 = Lists.reducel match (envir1, 
					      Lists.zip (map snd clel, 
							 map snd clel'))
	    val envir3 = Lists.reducel match_opt (envir,
						  [(leo1,leo1'),(leo2,leo2')])
	in
	    envir3
	end

     | submatch (LT.STRUCT les, LT.STRUCT les') =
       Lists.reducel match (envir, Lists.zip (les,les'))

     | submatch (LT.SELECT(f,le), LT.SELECT(f',le')) = 
       if f=f' then match(envir, (le,le'))
       else raise FailedMatch

     | submatch (LT.RAISE e, LT.RAISE e') = match(envir, (e,e'))

     | submatch (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_)) = 
         match(match(envir, (e,e')), (h,h'))

      | submatch _ = raise FailedMatch

   and match_opt (envir, (LT.ABSENT, LT.ABSENT)) = envir
     | match_opt (envir, (LT.PRESENT e1, LT.PRESENT e2)) = match(envir,(e1,e2))
     | match_opt _ = raise FailedMatch

   in
       if lambda_equality(e1,e2) then envir
	   else submatch(e1,e2)  handle Lists.Zip => raise FailedMatch
   end;

*)


@


1.53
log
@Modified to use the new hashtables
@
text
@d7 3
a61 1
require "lambdatypes";
a68 3
  structure LambdaTypes : LAMBDATYPES
  sharing Primitives.Set = LambdaTypes.Set
  sharing Primitives.LambdaTypes = LambdaTypes
d71 1
a71 1
  structure LambdaTypes = LambdaTypes;
d75 1
d1295 1
a1295 1
	   LT.Ident.scon_eqrep(tag,tag')
@


1.52
log
@Wrote routines to try to substitute exactly n times without going inside letrec and fn
@
text
@d7 3
d56 1
a56 2
require "../utils/hashtable";
require "../utils/_hashtable";
d77 2
d478 1
a478 1
  (*  Rename all bound variables with new ones  *)
d480 6
a485 2
    structure RenameHashTableSpec : HASHSPEC =
      struct
d488 1
a488 1
        val size    = 16
d490 1
a490 4
        val eq = LT.LVar_eq
      end

    structure RenameHashTable = HashTable(RenameHashTableSpec)
d492 1
a492 1
    fun add_var(var) = RenameHashTable.update(var, LT.new_LVar())
d494 1
a494 1
    fun add_var_and_return(var) =
d496 1
a496 5
	val new_var = LT.new_LVar()
	val _ = RenameHashTable.update(var,new_var)
      in
	new_var
      end
d498 11
a508 2
    fun get_new(var) =
      RenameHashTable.lookup var handle RenameHashTable.Lookup _ => var
d510 19
a528 3
    fun rename_fresh expression =
      let
	fun rename(LT.VAR lvar) = LT.VAR(get_new(lvar))
d570 2
d573 9
a581 2
	(RenameHashTable.clear();
	 rename(expression))
@


1.51
log
@Changed eta_abstract to take an extra type annotation
@
text
@d7 3
d563 3
a565 1
  fun substitute_for_at_most_n_occurrences (var, subexpr, expr,n) =
d594 4
a597 1
        | sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
d600 4
a603 2
        | sub(LT.LETREC(lv_list, le_list, le)) =
          LT.LETREC(lv_list, map_until_hit(sub,le_list), sub le)
d632 1
a632 1
      sub expr
d635 1
a635 1
fun substitute_for_at_most_one_occurrence (var, subexpr, expr) =
d657 4
a660 1
        | sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
d663 4
a666 2
        | sub(LT.LETREC(lv_list, le_list, le)) =
          LT.LETREC(lv_list, map_until_hit(sub,le_list), sub le)
d695 1
a695 1
      sub expr
d698 21
d1194 3
a1196 1
      fun shiftable_prim p = not(p mem Primitives.imperative_primitives)
@


1.50
log
@Restored functionality of is_in_evaluation_set.
@
text
@d7 3
d1047 1
a1047 1
	 LT.FN(new_variable, apply_outermost abstract expression,"_lambdasub beta abstract",LT.null_type_annotation()))
d1074 1
a1074 1
  fun eta_abstract (le,annotation) =
d1078 2
a1079 2
      LT.FN(lvar, LT.APP(le, LT.VAR lvar, LT.null_type_annotation()),
	    annotation,LT.null_type_annotation())
@


1.49
log
@Added LET constructor and new slot to APP.
@
text
@d7 3
d1026 1
a1026 1
      fn _ => true (*evaled*)
@


1.48
log
@Fixed accidental use of NJ "List" structure instead
of our "Lists".
@
text
@d7 3
a9 2
Revision 1.47  1992/06/25  10:47:37  davida
Added occurs function.
d46 1
d53 1
d115 5
d133 1
a133 1
    | (LT.APP(f,g), LT.APP(f',g')) => lambda_equality(f,f') andalso lambda_equality(g,g')
d193 1
d227 1
d230 3
a232 1
	  | apply (LT.APP(p, q)) = LT.APP(appsub p, appsub q)
d265 3
d271 1
a271 1
	  | apply (context as LT.APP(p, q)) =
d273 1
a273 1
	    in LT.APP(appsub ctxt p, appsub ctxt q) end
d359 2
a363 3
(*is this case really needed?  (sizes etc. will be different) *)
	    | reduce (acc,LT.APP(LT.FN(v,e1,_,_),e2)) = 
	      reducesub (reducesub(acc,e2),e1) 
d365 1
a365 2
	    | reduce (acc,LT.APP(p,q)) = 
	      reducesub (reducesub(acc,p),q) 
d425 1
a425 1
  (* Unwrap Lets *)
d428 9
d443 1
d445 1
a445 1
  (* Wrap Lets *)
d449 8
d462 1
d500 7
d510 16
a525 16
	in
	  LT.LETREC(map get_new lv_list, map rename le_list, rename le)
	end
      | rename(LT.APP(le, le')) = LT.APP(rename(le), rename(le'))
      | rename(le as LT.SCON _) = le
      | rename(le as LT.INT _) = le
      | rename(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(rename(le),
		  map rename_tag tag_le_list,
		  rename_opt(leo1),
		  rename_opt(leo2))
      | rename(LT.STRUCT le_list) = LT.STRUCT(map rename le_list)
      | rename(LT.SELECT(field, le)) =LT.SELECT(field, rename(le))
      | rename(LT.RAISE le) = LT.RAISE(rename(le))
      | rename(LT.HANDLE(le, le',annotation)) = LT.HANDLE(rename(le), rename(le'),annotation)
      | rename(le as LT.BUILTIN _) = le
d527 2
a528 2
      and rename_opt(LT.ABSENT) = LT.ABSENT
      | rename_opt(LT.PRESENT le) = LT.PRESENT(rename(le))
d530 3
a532 3
      and rename_tag(tag, le) =
	(case tag of
	   LT.EXP_TAG le => LT.EXP_TAG(rename(le))
d535 4
a538 4
    in
      (RenameHashTable.clear();
       rename(expression))
    end
a552 1
  (* Added the f argument which is a normalising function to allow aliasing within the tree *)
d584 2
d588 13
a600 12
        | sub(LT.APP(le, le')) =
          LT.APP(sub le, if !hit then le' else sub le')
      | sub(le as LT.SCON _) = le
      | sub(le as LT.INT _) = le
      | sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(sub le, map_until_hit(sub_tag,tag_le_list), sub_opt leo1, sub_opt leo2)
      | sub(LT.STRUCT le_list) =
	LT.STRUCT(map_until_hit(sub,le_list))
      | sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
      | sub(LT.RAISE le) = LT.RAISE(sub(le))
      | sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), if !hit then le' else sub le',annotation)
      | sub(le as LT.BUILTIN _) = le
d603 4
a606 4
      | sub_opt(arg as (LT.PRESENT le)) = 
        if !hit 
          then arg
        else LT.PRESENT(sub(le))
d642 2
d646 13
a658 12
        | sub(LT.APP(le, le')) =
          LT.APP(sub le, if !hit then le' else sub le')
      | sub(le as LT.SCON _) = le
      | sub(le as LT.INT _) = le
      | sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(sub le, map_until_hit(sub_tag,tag_le_list), sub_opt leo1, sub_opt leo2)
      | sub(LT.STRUCT le_list) =
	LT.STRUCT(map_until_hit(sub,le_list))
      | sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
      | sub(LT.RAISE le) = LT.RAISE(sub(le))
      | sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), if !hit then le' else sub le',annotation)
      | sub(le as LT.BUILTIN _) = le
d661 4
a664 4
      | sub_opt(arg as (LT.PRESENT le)) = 
        if !hit 
          then arg
        else LT.PRESENT(sub(le))
d681 17
a697 15
      | sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
      | sub(LT.LETREC(lv_list, le_list, le)) =
	LT.LETREC(lv_list, map sub le_list, sub le)
      | sub(LT.APP(le, le')) =
	LT.APP(sub le, sub le')
      | sub(le as LT.SCON _) = le
      | sub(le as LT.INT _) = le
      | sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(sub le, map sub_tag tag_le_list, sub_opt leo1, sub_opt leo2)
      | sub(LT.STRUCT le_list) =
	LT.STRUCT(map sub le_list)
      | sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
      | sub(LT.RAISE le) = LT.RAISE(sub(le))
      | sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), sub le',annotation)
      | sub(le as LT.BUILTIN _) = le
d700 1
a700 1
      | sub_opt(LT.PRESENT le) = LT.PRESENT(sub(le))
d721 1
a721 1
(*
d726 16
a741 15
      | sub(LT.FN(lv, le,n,ty)) = LT.FN(lv, sub(le),n,ty)
      | sub(LT.LETREC(lv_list, le_list, le)) =
	LT.LETREC(lv_list, map sub le_list, sub le)
      | sub(LT.APP(le, le')) =
	LT.APP(sub le, sub le')
      | sub(le as LT.SCON _) = le
      | sub(le as LT.INT _) = le
      | sub(LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(sub le, map sub_tag tag_le_list, sub_opt leo1, sub_opt leo2)
      | sub(LT.STRUCT le_list) =
	LT.STRUCT(map sub le_list)
      | sub(LT.SELECT(field, le)) = LT.SELECT(field, sub(le))
      | sub(LT.RAISE le) = LT.RAISE(sub(le))
      | sub(LT.HANDLE(le, le',annotation)) = LT.HANDLE(sub(le), sub le',annotation)
      | sub(le as LT.BUILTIN _) = le
d744 1
a744 1
      | sub_opt(LT.PRESENT le) = LT.PRESENT(sub(le))
d761 2
a762 1
	  handle Lists.Assoc => Crash.impossible("substitute_list of " ^ LambdaTypes.printLVar lvar)
d764 1
a764 1
      | subs expr = expr
d788 20
a807 19
	if LVar_eq(lv, lvar) then count+1 else count
      | occurs(count, LT.FN(_, le,_,_)) = occurs(count, le)
      | occurs(count, LT.LETREC(lv_list, le_list, le)) =
	Lists.reducel occurs (count, le :: le_list)
      | occurs(count, LT.APP(le, le')) =
	occurs(occurs(count, le), le')
      | occurs(count, LT.SCON _) = count
      | occurs(count, LT.INT _) = count
      | occurs(count, LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	Lists.reducel
	occurs_tag
	(occurs(occurs_opt(occurs_opt(count, leo1), leo2), le),
	 tag_le_list)
      | occurs(count, LT.STRUCT le_list) =
	Lists.reducel occurs (count, le_list)
      | occurs(count, LT.SELECT(_, le)) = occurs(count, le)
      | occurs(count, LT.RAISE le) = occurs(count, le)
      | occurs(count, LT.HANDLE(le, le',_)) = occurs(occurs(count, le), le')
      | occurs(count, LT.BUILTIN _) = count
d810 1
a810 1
      | occurs_opt(count, LT.PRESENT le) = occurs(count, le)
d831 18
a848 18
      | occurs(count, LT.FN(_, le,_,_)) = occurs(count, le)
      | occurs(count, LT.LETREC(lv_list, le_list, le)) =
	Lists.reducel occurs (count, le :: le_list)
      | occurs(count, LT.APP(le, le')) =
	occurs(occurs(count, le), le')
      | occurs(count, LT.SCON _) = count
      | occurs(count, LT.INT _) = count
      | occurs(count, LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	Lists.reducel
	occurs_tag
	(occurs(occurs_opt(occurs_opt(count, leo1), leo2), le),
	 tag_le_list)
      | occurs(count, LT.STRUCT le_list) =
	Lists.reducel occurs (count, le_list)
      | occurs(count, LT.SELECT(_, le)) = occurs(count, le)
      | occurs(count, LT.RAISE le) = occurs(count, le)
      | occurs(count, LT.HANDLE(le, le',_)) = occurs(occurs(count, le), le')
      | occurs(count, LT.BUILTIN _) = count
d851 1
a851 1
      | occurs_opt(count, LT.PRESENT le) = occurs(count, le)
d869 1
d871 2
a872 2
	  Lists.exists occurs (le :: le_list)
	| occurs(LT.APP(le, le')) = (occurs le; occurs le')
d898 1
a898 1
 (*  in a lambda-expression.  						  *)
d905 1
a905 1
     | build((bs,fs),  LT.FN(var,_,_,_)) = (bs++var, fs)
d907 1
a907 1
     | build((bs,fs),  LT.APP(LT.FN(var,_,_,_),_)) = (bs++var, fs)
d909 2
a910 2
     | build((bs,fs),  LT.LETREC(lvs,_,_)) =
       (Lists.reducel (op++) (bs,lvs), fs)
d912 1
a912 1
     | build(vars, _) = vars
d928 3
a930 3
      | build (LT.SELECT (_,LT.VAR var), number) =
	if LVar_eq(var, record_variable) then number-1 else number
      | build (_, number) = number
d967 2
a968 1
	| LT.APP(p,q) => sequence(sequence(seq,p),q)
d980 2
a981 3
  (*  Construct a list of the sub-expressions of an expression  	    *)
  (*  returning only those sub-expressions that we can ensure will 	    *)
  (*  definitely be evaluated.	 This returns a larger set of expressions   *)
a985 39
(*  LambdaTypes are not equality types anymore, and we don't need this function

  val evaluation_set =
    let
      fun evaled(expr) = (Set.singleton expr) U
	(if (whnf expr) then nullset
	 else case expr of
	   LT.LETREC _ => nullset
	 | LT.APP(p,q) => evaled(p) U evaled(q)
	 | LT.SWITCH x => switch_evaled x
	 | LT.STRUCT lel => Lists.reducel (op U) (nullset, map
					    evaled lel)
	 | LT.SELECT(_,e) => evaled(e)
	 | LT.RAISE e => evaled(e)
	 | LT.HANDLE(p,_,_) => evaled(p)
	 | _ => Crash.impossible "erk ev_set/whnf!")

      and switch_evaled (e,cases,cdef,pdef) = 
	let 
	  val opt = fn (LT.ABSENT,xs) => xs | (LT.PRESENT x,xs) => x::xs
	  val results = opt (cdef, opt (pdef, (map snd cases)))
	  val result_sets = map evaled results
	in
	  (evaled e) U (case result_sets of 
			  [] => nullset
			| (r::rs) => Lists.reducel 
			    Set.intersection (r,rs))
	end
    in
      evaled
    end
*)

  fun any f [] = false
  | any f (h::t) = f(h) orelse (any f t)

  fun all f [] = true
  | all f (h::t) = f(h) andalso (all f t)

d992 3
a994 2
	   LT.LETREC _ => false
	 | LT.APP(p,q) => evaled(p) orelse evaled(q)
d996 1
a996 1
	 | LT.STRUCT lel => any evaled lel
d1008 13
a1020 10
	      (LT.EXP_TAG le, _) :: _ =>
		any evaled (map (fn (LT.EXP_TAG le, _) => le | _ => Crash.impossible"Mixed tag type") cases)
	    | _ => false) orelse
	      (let
		 val results = opt (cdef, opt (pdef, (map snd cases)))
	       in
		 case results of
		   [] => false
		 | _ => all evaled results
	       end)
d1023 1
a1023 1
      evaled
a1026 2
  (*  Beta-reduction when the argument is a beta-redex.          *)
  (*  No checks are performed to see if the reduction is valid!  *)
a1027 5
  fun beta_reduce (LT.APP(LT.FN(var,body,_,_),arg)) = substitute (var,arg,body)
  | beta_reduce expr = expr
      


d1029 1
a1029 1
 (*  Generates a new lambda-variable.				*)
d1044 4
a1047 1
  fun beta_abstract_with_count (expression, sub_expression) = 
d1061 1
a1061 3
	(new_variable,
         !count,
	 LT.FN(new_variable, new_exp ,"_lambdasub beta abstract",LT.null_type_annotation()))
d1064 1
d1072 2
a1073 1
      LT.FN(lvar, LT.APP(le, LT.VAR lvar),annotation,LT.null_type_annotation())
d1076 1
d1106 2
a1107 1
  fun unwrap_apps expression =
d1109 3
a1111 1
	fun getargs (LT.APP(func,arg), args) = getargs(func, arg::args)
d1122 1
a1122 1
		 [] => (Lists.reducel LT.APP (expr,args), result)
d1127 1
a1127 1
	    (Lists.reducel LT.APP (expr,args), result)
d1131 1
a1132 1

d1156 1
d1158 1
a1158 1
	| shiftable(LT.APP (p,q)) =
a1203 62
  (*  First order matching.  Assumes bound variables in each    *)
  (*  expression are unique.  Extends the mapping of variables  *)
  (*  in the first expr to sub-exprs in the second.		*)
  
  exception FailedMatch;

  fun match(envir, exprs as (e1,e2)) = 
   let 
    fun submatch(LT.VAR v1, _) = (match(envir, (e2,Lists.assoc(v1,envir)))
				  handle Lists.Assoc => (v1,e2)::envir)

      | submatch (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =
      	  match((var,LT.VAR var')::envir, (body, body'))

      | submatch (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =
        let
       	    val envir1 = (Lists.zip (lvl, map LT.VAR lvl')) @@ envir
	    val envir2 = Lists.reducel match (envir1, Lists.zip (lel, lel'))
	in
	    match (envir2, (le,le'))
	end

      | submatch (LT.APP(f,g), LT.APP(f',g')) =
          match((match (envir,(f,f'))), (g,g'))

      | submatch (LT.SWITCH(le,clel,leo1,leo2),
		  LT.SWITCH(le',clel',leo1',leo2')) =
	let
	    val envir1 = match(envir, (le,le'))
	    val envir2 = Lists.reducel match (envir1, 
					      Lists.zip (map snd clel, 
							 map snd clel'))
	    val envir3 = Lists.reducel match_opt (envir,
						  [(leo1,leo1'),(leo2,leo2')])
	in
	    envir3
	end

     | submatch (LT.STRUCT les, LT.STRUCT les') =
       Lists.reducel match (envir, Lists.zip (les,les'))

     | submatch (LT.SELECT(f,le), LT.SELECT(f',le')) = 
       if f=f' then match(envir, (le,le'))
       else raise FailedMatch

     | submatch (LT.RAISE e, LT.RAISE e') = match(envir, (e,e'))

     | submatch (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_)) = 
         match(match(envir, (e,e')), (h,h'))

      | submatch _ = raise FailedMatch

   and match_opt (envir, (LT.ABSENT, LT.ABSENT)) = envir
     | match_opt (envir, (LT.PRESENT e1, LT.PRESENT e2)) = match(envir,(e1,e2))
     | match_opt _ = raise FailedMatch

   in
       if lambda_equality(e1,e2) then envir
	   else submatch(e1,e2)  handle Lists.Zip => raise FailedMatch
   end;


d1232 3
d1249 1
a1249 1
       | (LT.APP(f,g), LT.APP(f',g')) => subm(f,f') andalso subm(g,g')
d1303 2
a1304 1
(* old one:
d1306 7
a1312 8
  fun alpha_convertible (expression_pair as (e1,e2)) =
   let
    fun match(envir, e1,e2) = 
       let 
	 fun subm (e1,e2) = 
	    case (e1,e2) of 
	       (LT.VAR v, LT.VAR v') =>
		 LVar_eq(v, v') orelse LVar_eq(Lists.assoc(v,envir), v')
d1314 41
a1354 2
	     | (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =>
	     				match((var,var')::envir, body, body')
d1356 2
a1357 10
	     | (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =>
		 (* This really should check for a rearrangement of *)
		 (* the recursive definitions matching . But this *)
		 (* would probably be a lot of work to no avail *)
		 Lists.length lvl = Lists.length lvl' andalso
		 let
		   val envir' = Lists.zip (lvl,lvl') @@ envir
		 in
		   match(envir', LT.STRUCT (le::lel), LT.STRUCT (le'::lel'))
		 end
d1359 15
a1373 1
	     | (LT.APP(f,g), LT.APP(f',g')) => subm(f,f') andalso subm(g,g')
a1374 1
             | (LT.SCON x, LT.SCON y) => (x=y)
a1375 1
             | (LT.INT x, LT.INT y) => (x=y)
d1377 41
a1417 55
  	     | (LT.SWITCH(le,clel,leo1,leo2),
		LT.SWITCH(le',clel',leo1',leo2')) =>
	       (* This really should check for a rearrangement of *)
	       (* the tags matching . This could relatively easily *)
	       (* be done for SCON_TAG and CON_TAG *)
	     let
	       fun subo (LT.PRESENT le, LT.PRESENT le') = subm (le,le')
	       | subo (LT.ABSENT, LT.ABSENT) = true
	       | subo _ = false
	     in
	       Lists.length clel = Lists.length clel' andalso
	       subm (le,le') andalso
	       Lists.forall subm (Lists.zip (map snd clel, map snd clel')) andalso
	       (case (clel, clel') of
		  ((LT.EXP_TAG _, _) :: _, (LT.EXP_TAG _, _) :: _) =>
		    let
		      fun get_exp_from_tag(LT.EXP_TAG le) = le
		      | get_exp_from_tag _ =
			Crash.impossible"Mixed tag types in switch"
		    in
		      Lists.forall
		      subm
		      (Lists.zip(map(get_exp_from_tag o fst) clel,
				 map(get_exp_from_tag o fst) clel'))
		    end
		| ((LT.CON_TAG _, _) :: _, (LT.CON_TAG _, _) :: _) =>
		    let
		      fun detag(LT.CON_TAG tag) = tag
		      | detag _ = Crash.impossible"Mixed tag type"
		      val fst = detag o fst
		      val result =
			Lists.forall
			(op= : int * int -> bool)
			(Lists.zip(map fst clel, map fst clel'))
		    in
		      result
		    end
		| ((LT.SCON_TAG _, _) :: _, (LT.SCON_TAG _, _) :: _) =>
		    let
		      fun detag(LT.SCON_TAG tag) = tag
		      | detag _ = Crash.impossible"Mixed tag type"
		      val fst = detag o fst
		      val result =
			Lists.forall
			LT.Ident.scon_eqrep
			(Lists.zip(map fst clel, map fst clel'))
		    in
		      result
		    end
		| ([], []) => true
		(* May be nothing in the lists *)
		| _ => false) andalso
		  subo (leo1,leo1') andalso
		  subo (leo2,leo2')
	     end
d1419 2
a1420 3
	   | (LT.STRUCT les, LT.STRUCT les') =>
	       Lists.length les = Lists.length les' andalso
	       Lists.forall subm (Lists.zip (les,les'))
d1422 3
a1424 1
	   | (LT.SELECT(f,le), LT.SELECT(f',le')) => f=f' andalso subm (le,le')
d1426 1
a1426 1
	   | (LT.RAISE e, LT.RAISE e') => subm (e,e')
d1428 2
a1429 1
	   | (LT.HANDLE(e,h,_), LT.HANDLE(e',h',_))=> subm(e,e') andalso subm(h,h')
d1431 1
a1431 1
	   | (LT.BUILTIN x,LT.BUILTIN y) => x=y
d1433 4
a1436 4
           | _ => false
       in
	  lambda_equality(e1,e2) orelse subm(e1,e2)
       end
d1438 4
a1441 2
      (match ([], e1, e2)) handle Lists.Zip => false | Lists.Assoc => false
   end
d1444 2
d1447 1
@


1.47
log
@Added occurs function.
@
text
@d7 3
d827 1
a827 1
	   List.exists occurs_tag tag_le_list)
@


1.46
log
@Added an annotation slot to HANDLE
@
text
@d7 3
d718 1
d808 34
@


1.45
log
@Missing case and improvements for alpha_convertible.
@
text
@d7 3
d160 1
a160 1
    | (LT.HANDLE(e,h), LT.HANDLE(e',h'))=> lambda_equality(e,e') andalso lambda_equality(h,h')
d225 3
a227 2
	  | apply (LT.HANDLE (le1, le2)) = LT.HANDLE (appsub le1, 
						      appsub le2)
d273 1
a273 1
	  | apply (context as LT.HANDLE (le1, le2)) =
d275 1
a275 1
	    in LT.HANDLE (appsub ctxt le1, appsub ctxt le2) end
d360 1
a360 1
	    | reduce (acc,LT.HANDLE (le1,le2))= 
d479 1
a479 1
      | rename(LT.HANDLE(le, le')) = LT.HANDLE(rename(le), rename(le'))
d552 1
a552 1
      | sub(LT.HANDLE(le, le')) = LT.HANDLE(sub(le), if !hit then le' else sub le')
d607 1
a607 1
      | sub(LT.HANDLE(le, le')) = LT.HANDLE(sub(le), if !hit then le' else sub le')
d644 1
a644 1
      | sub(LT.HANDLE(le, le')) = LT.HANDLE(sub(le), sub le')
d687 1
a687 1
      | sub(LT.HANDLE(le, le')) = LT.HANDLE(sub(le), sub le')
d750 1
a750 1
      | occurs(count, LT.HANDLE(le, le')) = occurs(occurs(count, le), le')
d791 1
a791 1
      | occurs(count, LT.HANDLE(le, le')) = occurs(occurs(count, le), le')
d881 1
a881 1
	| LT.HANDLE(p,_) => raise Stop (sequence(seq,p))
d909 1
a909 1
	 | LT.HANDLE(p,_) => evaled(p)
d946 1
a946 1
	 | LT.HANDLE(p,_) => evaled(p)
d1123 1
a1123 1
	| shiftable(LT.HANDLE (expr,pats)) = shiftable expr
d1194 1
a1194 1
     | submatch (LT.HANDLE(e,h), LT.HANDLE(e',h')) = 
d1293 1
a1293 1
	| (LT.HANDLE(e,h), LT.HANDLE(e',h'))=> subm(e,e') andalso subm(h,h')
d1400 1
a1400 1
	   | (LT.HANDLE(e,h), LT.HANDLE(e',h'))=> subm(e,e') andalso subm(h,h')
@


1.44
log
@Fixed fault in previous rev, more code tweaking.
@
text
@d7 3
a27 2
Revision 1.37  1992/03/06  11:51:07  jont
Numerous efficiency improvements
a28 30
Revision 1.36  1992/02/28  18:54:58  jont
Used a balanced tree for accumulating substitutions in substitute_fresh

Revision 1.35  1992/02/17  15:07:22  jont
Fixed bug in switch_evaled (both cases) whereby expression tags weren't
considered

Revision 1.34  1992/02/12  13:52:20  jont
Added substitute_list function, used by both _curry and _optimise_cse
Modified is_shiftable to disallow only applications of imperative
primitives (functions are always shiftable)

Revision 1.33  1992/02/11  17:55:20  jont
Fixed alpha_convertible to check that the TAGs match within
a switch as well as the expressions

Revision 1.32  1992/02/06  09:52:50  clive
Fixed another bug in in_evaluation_set

Revision 1.31  1992/01/30  13:17:15  clive
Added a function is_in_extension_set so that we don't have to
generate the evaluation_set and then test to see if something is in it
which proved to be a very expensive operation

Revision 1.30  1991/11/22  17:27:26  jont
Removed opens

Revision 1.29  91/11/21  19:37:39  jont
Added some brackets to keep njml 0.75 happy

d526 8
a533 11
            then (if ! count = 1
                    then hit := true
                  else 
                    let
                      val c = !count
                    in
                      if c>0 
                        then count := c-1
                      else ()
                    end;
                    subexpr)
d1209 1
d1214 15
a1228 1
       fun subm (e1,e2) = 
d1240 1
a1240 1
	   Lists.length lvl = Lists.length lvl' andalso
d1253 6
a1258 6
	 | (LT.SWITCH(le,clel,leo1,leo2),
	    LT.SWITCH(le',clel',leo1',leo2')) =>
	   (* This really should check for a rearrangement of *)
	   (* the tags matching . This could relatively easily *)
	   (* be done for SCON_TAG and CON_TAG *)
	   let
d1263 1
a1263 1
	     datatype tag_kind = EXP | CON | SCON | DIFFERENT | NONE
d1265 4
a1268 3
	     fun tag_kind ((LT.EXP_TAG _, _) :: _, (LT.EXP_TAG _, _) :: _)=EXP
	       | tag_kind ((LT.CON_TAG _, _) :: _, (LT.CON_TAG _, _) :: _)=CON
	       | tag_kind ((LT.SCON_TAG _, _) ::_, (LT.SCON_TAG _, _) ::_)=SCON
d1271 8
a1278 40
	     Lists.length clel = Lists.length clel' andalso
	   (case tag_kind(clel,clel') of 
           DIFFERENT => false
	 | NONE => true
	 | EXP =>  let
		     fun get_exp_from_tag(LT.EXP_TAG le,_) = le
		       | get_exp_from_tag _ =
			 Crash.impossible"Mixed tag types in switch"
		   in
		     Lists.forall
		     subm
			(Lists.zip(map get_exp_from_tag clel,
				   map get_exp_from_tag clel')) andalso
		     subm (le,le') andalso
		     Lists.forall subm 
			(Lists.zip (map snd clel, map snd clel'))
		   end
	  | CON => let
		      fun detag(LT.CON_TAG tag,_) = tag
			| detag _ = Crash.impossible"Mixed tag type"
		    in
		     Lists.forall
		      (op= : int * int -> bool)
		      (Lists.zip(map detag clel, map detag clel')) andalso
		     subm (le,le') andalso
		     Lists.forall subm 
			(Lists.zip (map snd clel, map snd clel'))
		    end
       | SCON =>   let
		      fun detag(LT.SCON_TAG tag,_) = tag
			| detag _ = Crash.impossible"Mixed tag type"
		    in
		     Lists.forall
		      LT.Ident.scon_eqrep
		      (Lists.zip(map detag clel, map detag clel')) andalso
		     subm (le,le') andalso
		     Lists.forall subm 
			(Lists.zip (map snd clel, map snd clel'))
		    end) 
		      andalso subo (leo1,leo1') andalso subo (leo2,leo2')
d1281 2
a1282 2
	  | (LT.STRUCT les, LT.STRUCT les') =>
	      Lists.length les = Lists.length les' andalso
d1285 1
a1285 1
	  | (LT.SELECT(f,le), LT.SELECT(f',le')) => f=f' andalso subm (le,le')
d1287 1
a1287 1
	  | (LT.RAISE e, LT.RAISE e') => subm (e,e')
d1289 1
a1289 1
	  | (LT.HANDLE(e,h), LT.HANDLE(e',h'))=> subm(e,e') andalso subm(h,h')
d1291 3
a1293 3
	  | (LT.BUILTIN x,LT.BUILTIN y) => x=y
	      
	  | _ => false
d1301 1
a1301 1
end (* of functor *)
d1303 8
d1312 2
a1313 4
(*
$Log: _lambdasub.sml,v $
Revision 1.43  1992/06/17  15:37:04  davida
Various efficiency improvements.
d1315 10
a1324 2
Revision 1.42  1992/06/16  16:03:09  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
d1326 1
a1326 2
Revision 1.41  1992/06/03  14:33:14  clive
Added type annotations to FNexp
d1328 1
a1328 2
Revision 1.40  1992/04/28  18:36:39  jont
Added require _hashtable
d1330 1
a1330 2
Revision 1.39  1992/04/23  12:12:01  clive
Added some more customised utility functions
d1332 55
a1386 2
Revision 1.38  1992/04/13  14:16:44  clive
First version of the profiler
d1388 3
a1390 2
Revision 1.37  1992/03/06  11:51:07  jont
Numerous efficiency improvements
d1392 1
a1392 2
Revision 1.36  1992/02/28  18:54:58  jont
Used a balanced tree for accumulating substitutions in substitute_fresh
d1394 1
a1394 3
Revision 1.35  1992/02/17  15:07:22  jont
Fixed bug in switch_evaled (both cases) whereby expression tags weren't
considered
d1396 1
a1396 4
Revision 1.34  1992/02/12  13:52:20  jont
Added substitute_list function, used by both _curry and _optimise_cse
Modified is_shiftable to disallow only applications of imperative
primitives (functions are always shiftable)
d1398 1
a1398 3
Revision 1.33  1992/02/11  17:55:20  jont
Fixed alpha_convertible to check that the TAGs match within
a switch as well as the expressions
d1400 8
a1407 2
Revision 1.32  1992/02/06  09:52:50  clive
Fixed another bug in in_evaluation_set
d1409 1
a1409 4
Revision 1.31  1992/01/30  13:17:15  clive
Added a function is_in_extension_set so that we don't have to
generate the evaluation_set and then test to see if something is in it
which proved to be a very expensive operation
a1410 105
Revision 1.30  1991/11/22  17:27:26  jont
Removed opens

Revision 1.29  91/11/21  19:37:39  jont
Added some brackets to keep njml 0.75 happy

Revision 1.28  91/11/14  17:03:37  jont
Added eta_abstract function for general use

Revision 1.27  91/10/23  12:58:36  davidt
Added new functions apply_innermost_with_context
and apply_outermost_with_context.

Revision 1.26  91/10/22  16:09:39  davidt
Replaced impossible exception with Crash.impossible calls.

Revision 1.25  91/10/09  10:24:17  davidt
General tidy up, Made changes due to record selection now requiring
the total size of the record to be present as well as the index.
Took out utility functions and put them in List structure.

Revision 1.24  91/09/25  15:31:45  davida
Added VAR clause to substitution in rename_fresh.
(whoops!)

Revision 1.23  91/09/23  15:45:06  davida
reduce and apply functions now recurse over expression-valued
tags in SWITCH expressions.

Revision 1.22  91/09/10  16:42:58  davida
Changed type of substitute, added substitute_fresh,
improved and corrected alpha_convertible test.

Revision 1.21  91/09/06  14:06:43  davida
Some list-like functions and others removed.

Revision 1.20  91/09/04  10:43:54  davida
Made rename_fresh generate new lambda-variables in LETREC's
too.

Revision 1.19  91/08/23  16:20:37  davida
Made usual substitute function non-recursive,
corrected evaluation_set

Revision 1.18  91/08/15  14:50:56  davida
Miscellaneous changes, new functions.

Revision 1.17  91/08/14  13:23:00  davida
removed set_of_lvars, changed bounds_and_frees to include
variables bound by LETREC's.

Revision 1.16  91/08/13  16:05:42  davida
Added sub-expression substitution function "replace_subexpr"

Revision 1.15  91/08/13  13:50:01  davida
No change.

Revision 1.14  91/08/09  14:40:05  davida
New functions added

Revision 1.13  91/08/06  15:18:45  davida
Altered selects_on_var for 2nd phase, temporarily.

Revision 1.12  91/08/02  17:07:52  davida
LETREC's are now classed as shiftable expressions,
if their resulting tuples are.  (And why not?)

Revision 1.11  91/08/02  16:05:09  davida
Added function size_of_expr to count number
of sub expressions in an expression.

Revision 1.10  91/08/01  19:44:17  davida
Reverted back to _correct_ semantics for
evaluating APP's --- evaluate function-valued
object first, then argument.  Then do
application.

Revision 1.9  91/07/31  14:44:18  davida
forall conversion from exists improved.

Revision 1.8  91/07/30  16:45:55  davida
Added some more functions, fiddled with some old ones.

Revision 1.7  91/07/29  16:45:37  davida
Changed is_expansive to is_shiftable, added unwrap_apps.

Revision 1.6  91/07/25  13:38:27  davida
Added new functions, restructured and improved existing ones.

Revision 1.5  91/07/24  13:18:54  davida
A couple of fixes, altered form of is_expansive and added set_of_selects

Revision 1.4  91/07/22  12:52:42  jont
Moved some general purpose functions in from _lambda

Revision 1.3  91/07/17  13:20:47  davida
is_expansive becomes stricter...

Revision 1.2  91/07/16  18:00:51  davida
Added new functions set_of_lvars and is_expansive.

Revision 1.1  91/07/15  16:12:31  davida
Initial revision

*)
@


1.43
log
@Various efficiency improvements.
@
text
@d7 3
d123 1
a123 1
    (* Check for the equality of two lambda expressions *)
d127 1
a127 1
      (LT.VAR v, LT.VAR v') => LVar_eq(v, v') 
a344 1

d355 1
a355 1
	    | caseexprs_of ((_,value)::tvs,acc)=(caseexprs_of (tvs,value::acc))
d363 2
a364 1
	    | reduce (acc,LT.LETREC(_,lel,le)) = reduce_list (acc,(lel@@[le]))
d366 1
d368 1
a368 1
	      reduce (reducesub(acc,e2),e1)
d371 1
a371 1
	      reduce (reducesub(acc,p),q)
d374 1
a374 1
	      reduce_list (reducesub (acc,le),
d385 2
a386 2
	    | reduce (acc,LT.HANDLE (le1,le2)) = 
	      reduce (reducesub(acc,le1),le2)
a430 1

d1238 2
a1239 4
  (*  This could do with being fast: it may be better to actually *)
  (*  remove the initial equality test (if we could test pointer  *)
  (*  equality, that would be fine, but we want to avoid the      *)
  (*  recursive constructor eq test and use our own)		  *)
d1244 5
a1248 5
       let 
	 fun subm (e1,e2) = 
	    case (e1,e2) of 
	       (LT.VAR v, LT.VAR v') =>
		 LVar_eq(v, v') orelse LVar_eq(Lists.assoc(v,envir), v')
d1250 2
a1251 2
	     | (LT.FN(var,body,_,_), LT.FN(var',body',_,_)) =>
	     				match((var,var')::envir, body, body')
d1253 24
a1276 24
	     | (LT.LETREC(lvl,lel,le), LT.LETREC(lvl',lel',le')) =>
		 (* This really should check for a rearrangement of *)
		 (* the recursive definitions matching . But this *)
		 (* would probably be a lot of work to no avail *)
		 Lists.length lvl = Lists.length lvl' andalso
		 let
		   val envir' = Lists.zip (lvl,lvl') @@ envir
		 in
		   match(envir', LT.STRUCT (le::lel), LT.STRUCT (le'::lel'))
		 end

	     | (LT.APP(f,g), LT.APP(f',g')) => subm(f,f') andalso subm(g,g')

             | (LT.SCON x, LT.SCON y) => (x=y)

             | (LT.INT x, LT.INT y) => (x=y)

  	     | (LT.SWITCH(le,clel,leo1,leo2),
		LT.SWITCH(le',clel',leo1',leo2')) =>
	       (* This really should check for a rearrangement of *)
	       (* the tags matching . This could relatively easily *)
	       (* be done for SCON_TAG and CON_TAG *)
	     let
	       fun subo (LT.PRESENT le, LT.PRESENT le') = subm (le,le')
d1279 28
a1306 10
	     in
	       Lists.length clel = Lists.length clel' andalso
	       subm (le,le') andalso
	       Lists.forall subm (Lists.zip (map snd clel, map snd clel')) andalso
	       (case (clel, clel') of
		  ((LT.EXP_TAG _, _) :: _, (LT.EXP_TAG _, _) :: _) =>
		    let
		      fun get_exp_from_tag(LT.EXP_TAG le) = le
		      | get_exp_from_tag _ =
			Crash.impossible"Mixed tag types in switch"
d1308 6
a1313 4
		      Lists.forall
		      subm
		      (Lists.zip(map(get_exp_from_tag o fst) clel,
				 map(get_exp_from_tag o fst) clel'))
d1315 3
a1317 9
		| ((LT.CON_TAG _, _) :: _, (LT.CON_TAG _, _) :: _) =>
		    let
		      fun detag(LT.CON_TAG tag) = tag
		      | detag _ = Crash.impossible"Mixed tag type"
		      val fst = detag o fst
		      val result =
			Lists.forall
			(op= : int * int -> bool)
			(Lists.zip(map fst clel, map fst clel'))
d1319 9
a1327 20
		      result
		    end
		| ((LT.SCON_TAG _, _) :: _, (LT.SCON_TAG _, _) :: _) =>
		    let
		      fun detag(LT.SCON_TAG tag) = tag
		      | detag _ = Crash.impossible"Mixed tag type"
		      val fst = detag o fst
		      val result =
			Lists.forall
			LT.Ident.scon_eqrep
			(Lists.zip(map fst clel, map fst clel'))
		    in
		      result
		    end
		| ([], []) => true
		(* May be nothing in the lists *)
		| _ => false) andalso
		  subo (leo1,leo1') andalso
		  subo (leo2,leo2')
	     end
d1329 3
a1331 3
	   | (LT.STRUCT les, LT.STRUCT les') =>
	       Lists.length les = Lists.length les' andalso
	       Lists.forall subm (Lists.zip (les,les'))
d1333 1
a1333 1
	   | (LT.SELECT(f,le), LT.SELECT(f',le')) => f=f' andalso subm (le,le')
d1335 1
a1335 1
	   | (LT.RAISE e, LT.RAISE e') => subm (e,e')
d1337 1
a1337 1
	   | (LT.HANDLE(e,h), LT.HANDLE(e',h'))=> subm(e,e') andalso subm(h,h')
d1339 6
a1344 6
	   | (LT.BUILTIN x,LT.BUILTIN y) => x=y

           | _ => false
       in
	  lambda_equality(e1,e2) orelse subm(e1,e2)
       end
d1346 1
a1346 1
      (match ([], e1, e2)) handle Lists.Zip => false | Lists.Assoc => false
d1354 3
@


1.42
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d7 3
d220 1
a220 1
   * an arguement to the function.
d226 32
d303 3
d308 1
a308 1
	fun appsub context le =
d311 1
a311 1
	appsub LT.ABSENT
d317 1
a317 1
	  f context (apply_lexprs appsub le)
d324 1
a324 1
	fun appsub context le =
d327 1
a327 1
	appsub LT.ABSENT
d333 1
a333 1
	  apply_lexprs appsub (f context le)
d338 1
a338 1
    fun apply_one_level f = apply_lexprs (fn context => f)
d341 2
d346 1
d351 4
a354 4
	  fun caseexprs_of ((LT.EXP_TAG tag, value)::tvs) =
	      tag :: value :: (caseexprs_of tvs)
	    | caseexprs_of ((_,value)::tvs) = value :: (caseexprs_of tvs)
	    | caseexprs_of [] = []
d360 1
d362 7
a368 2
	    | reduce (acc,LT.APP(LT.FN(v,e1,_,_),e2)) = reduce_list (acc,[e2,e1])
	    | reduce (acc,LT.APP(p,q)) = reduce_list (acc,[p,q])
d370 5
a374 2
	      reduce_list (acc,(le :: (caseexprs_of clel) @@ (listit leo1) @@
				(listit leo2)))
d376 1
d378 1
d380 4
a383 1
	    | reduce (acc,LT.HANDLE (le1,le2)) = reduce_list (acc,[le1,le2])
d387 2
a388 3
	    | reduce_list (acc,expr::exprs) =
	      let val acc'=reducesub (acc,expr)
	      in reduce_list(acc',exprs) end
d426 2
a447 1
  (*  Rename all bound variables with new ones in a lambda-expression.  *)
d449 1
a449 1
(* Do the occurrence count using a hashtable and not by repeatedly calling a function *)
d462 1
a462 1
  fun add_var(var) = RenameHashTable.update(var, LT.new_LVar())
d464 7
a470 7
  fun add_var_and_return(var) =
    let
      val new_var = LT.new_LVar()
      val _ = RenameHashTable.update(var,new_var)
    in
      new_var
    end
d472 15
a486 9
  fun get_new(var) =
    RenameHashTable.lookup var handle RenameHashTable.Lookup _ => var

  fun rename_fresh expression =
    let
      fun rename(LT.VAR lvar) = LT.VAR(get_new(lvar))
      | rename(LT.FN(var, le,n,ty)) =
	let
	  val new_var = add_var_and_return(var)
d488 1
a488 1
	  LT.FN(new_var, rename(le),n,ty)
d490 1
a490 13
      | rename(LT.LETREC(lv_list, le_list, le)) =
	let
	  val _ =
	    map
	    add_var
	    (lv_list)
	in
	  LT.LETREC(map (fn lv => get_new(lv)) lv_list,
		    map (fn le => (rename(le))) le_list,
		    rename(le))
	end
      | rename(LT.APP(le, le')) =
	LT.APP(rename(le), rename(le'))
d495 1
a495 1
		  map (fn tag_le => rename_tag(tag_le)) tag_le_list,
d498 2
a499 4
      | rename(LT.STRUCT le_list) =
	LT.STRUCT(map (fn le => rename(le)) le_list)
      | rename(LT.SELECT(field, le)) =
	LT.SELECT(field, rename(le))
d501 1
a501 2
      | rename(LT.HANDLE(le, le')) =
	LT.HANDLE(rename(le), rename(le'))
d517 2
d521 1
a521 1
(*
d1120 1
a1120 5
      (* The second argument is not used at present - if it ever is, a better data-structure
         than an associations list ought to be used *)

  val is_shiftable =
    let
d1122 1
a1122 1

d1124 27
a1150 29
      | shiftable(LT.FN _) = true
      | shiftable(LT.LETREC(_,_,x)) = shiftable x
      | shiftable(LT.APP (p,q)) =
	(shiftable q) andalso 
	(case p of
	   LT.VAR var => false
	 | LT.BUILTIN prim => shiftable_prim prim
	 | LT.FN (var,body,_,_) => 
             shiftable body
	 | _ => false)  
      | shiftable(LT.SCON _) = true
      | shiftable(LT.INT _)  = true
      | shiftable(LT.SWITCH (le,clel,leo1,leo2)) =
	let 
	  val app = fn (LT.PRESENT e) => [e] | LT.ABSENT => []
	  val lexprs = le :: ((app leo1) @@ (app leo2) @@ (map snd clel))
	in 
	  Lists.forall shiftable lexprs
	end
	(* This needs to cope with EXP_TAGs*)
      | shiftable(LT.STRUCT lel) = Lists.forall shiftable lel
      | shiftable(LT.SELECT (f,le)) = shiftable le
      | shiftable(LT.RAISE _) = false
      | shiftable(LT.HANDLE (expr,pats)) = shiftable expr
      | shiftable(LT.BUILTIN prim) = true
    (* prims are only unshiftable when applied *)
    in
      shiftable
    end
d1152 3
d1171 1
d1350 3
@


1.41
log
@Added type annotations to FNexp
@
text
@d7 3
d117 75
d872 2
d903 1
a904 1

d913 2
a914 1
      fun evaled(expr) = (element = expr) orelse
d964 1
a964 1
	fun abstract expr = if expr=sub_expression 
d978 1
a978 1
       fun abstract expr = if expr=sub_expression 
d1005 1
a1005 1
	fun abstract expr = if expr = subexpr 
d1183 1
a1183 1
       if e1=e2 then envir
d1219 4
d1289 3
a1291 1
	   | (x,y) => x=y
d1293 1
a1293 1
	  (e1=e2) orelse subm(e1,e2)
d1304 3
@


1.40
log
@Added require _hashtable
@
text
@d7 3
d153 1
a153 1
	  | apply (context as LT.FN(lv, le,x)) =
d155 1
a155 1
	    in LT.FN (lv, appsub ctxt le,x) end
d240 1
a240 1
	  fun reduce (acc,LT.FN(_,le,_)) = reducesub (acc,le)
d242 1
a242 1
	    | reduce (acc,LT.APP(LT.FN(v,e1,_),e2)) = reduce_list (acc,[e2,e1])
d298 1
a298 1
      fun unwl(acc, LT.APP(LT.FN(var,body,_),arg)) = unwl((var,arg)::acc,body)
d308 2
a309 2
      fun nest (body,(var,arg,comment_string)) = 
        LT.APP(LT.FN(var,body,comment_string),arg)
d324 1
a324 1
        val eq = (op =)
d345 1
a345 1
      | rename(LT.FN(var, le,n)) =
d349 1
a349 1
	  LT.FN(new_var, rename(le),n)
d438 1
a438 1
        | sub(LT.FN(lv, le,n)) = LT.FN(lv, sub(le),n)
d493 1
a493 1
        | sub(LT.FN(lv, le,n)) = LT.FN(lv, sub(le),n)
d530 1
a530 1
      | sub(LT.FN(lv, le,n)) = LT.FN(lv, sub(le),n)
d573 1
a573 1
      | sub(LT.FN(lv, le,n)) = LT.FN(lv, sub(le),n)
d633 1
a633 1
      | occurs(count, LT.FN(_, le,_)) = occurs(count, le)
d674 1
a674 1
      | occurs(count, LT.FN(_, le,_)) = occurs(count, le)
d713 1
a713 1
     | build((bs,fs),  LT.FN(var,_,_)) = (bs++var, fs)
d715 1
a715 1
     | build((bs,fs),  LT.APP(LT.FN(var,_,_),_)) = (bs++var, fs)
d870 1
a870 1
  fun beta_reduce (LT.APP(LT.FN(var,body,_),arg)) = substitute (var,arg,body)
d888 1
a888 1
	 LT.FN(new_variable, apply_outermost abstract expression,"_lambdasub beta abstract"))
d907 1
a907 1
	 LT.FN(new_variable, new_exp ,"_lambdasub beta abstract"))
d917 1
a917 1
      LT.FN(lvar, LT.APP(le, LT.VAR lvar),annotation)
d937 1
a937 1
	fun strip (vars,LT.FN(var,body,_)) = strip(var::vars,body)
d954 2
a955 2
	and getfun (LT.FN(var,body,annotation), arg::args, result) = 
	                    getfun(body, args, (var,arg,annotation)::result)
d1006 1
a1006 1
	 | LT.FN (var,body,_) => 
d1056 1
a1056 1
      | submatch (LT.FN(var,body,_), LT.FN(var',body',_)) =
d1122 1
a1122 1
	     | (LT.FN(var,body,_), LT.FN(var',body',_)) =>
d1217 3
@


1.39
log
@Added some more customised utility functions
@
text
@d7 3
d52 1
d1214 3
@


1.38
log
@First version of the profiler
@
text
@d7 3
d48 1
a48 1
require "../utils/balancedtree";
a55 1
  structure BalancedTree : BALANCEDTREE
d309 1
a309 4
(*
  fun rename_fresh expression =
    let
      fun pair_new var = (var, LT.new_LVar())
d311 8
a318 5
      fun order(lv1, lv2) =
	if LT.LVar_eq(lv1, lv2) then BalancedTree.EQ
	else
	  if LT.LVar_order(lv1, lv2) then BalancedTree.LT
	  else BalancedTree.GT
d320 3
a322 17
(*
      fun acc_subst (vars, LT.FN(var,_)) = (pair_new var)::vars
	| acc_subst (vars, LT.APP(LT.FN(var,_),_)) = (pair_new var)::vars
	| acc_subst (vars, LT.LETREC(lvl,_,_)) = (map pair_new lvl) @@ vars
	| acc_subst (vars, _) = vars
	   
      val newvars = reduce_outermost acc_subst ([],expression)
*)
      fun acc_subst (tree, LT.FN(var,_,_)) =
	BalancedTree.insert(tree, var, LT.new_LVar())
      | acc_subst (tree, LT.APP(LT.FN(var,_,_),_)) =
	BalancedTree.insert(tree, var, LT.new_LVar())
      | acc_subst (tree, LT.LETREC(lvl,_,_)) =
	Lists.reducel
	(fn (tree, old) => BalancedTree.insert(tree, old, LT.new_LVar()))
	(tree, lvl)
      | acc_subst (tree, _) = tree
d324 1
a324 34
      val newvars =
	reduce_outermost acc_subst (BalancedTree.empty order, expression)
      (* It may be worth doing reduce_outermost long hand. No! *)

(*
      fun get_new var = (Lists.assoc (var,newvars)) handle Lists.Assoc => var
*)
      fun get_new var =
	case BalancedTree.lookup(newvars, var) of
	  BalancedTree.YES newvar => newvar
	| _ => var

      fun mk_subst (LT.FN(v,b,x)) = LT.FN(get_new v,b,x)
	| mk_subst (LT.APP(LT.FN(v,b,z),a)) = LT.APP(LT.FN(get_new v,b,z),a)
	| mk_subst (LT.LETREC(lvl,lel,le)) =
	  LT.LETREC(map get_new lvl, lel, le)
	| mk_subst (LT.VAR v) = LT.VAR(get_new v)
	| mk_subst expr = expr
    (* This algorithm still seems slightly silly *)
    (* It probably should accumulate the substitutions as it descends *)
    in
      apply_outermost mk_subst expression
    end
*)

  fun order(lv1, lv2) =
    if LT.LVar_eq(lv1, lv2) then BalancedTree.EQ
    else
      if LT.LVar_order(lv1, lv2) then BalancedTree.LT
      else BalancedTree.GT

  fun add_var(tree, var) = BalancedTree.insert(tree, var, LT.new_LVar())

  fun add_var_and_return(tree, var) =
d327 1
d329 1
a329 1
      (BalancedTree.insert(tree, var, new_var), new_var)
d332 2
a333 4
  fun get_new(tree, var) =
    case BalancedTree.lookup(tree, var) of
      BalancedTree.YES newvar => newvar
    | _ => var
d337 2
a338 2
      fun rename(tree, LT.VAR lvar) = LT.VAR(get_new(tree, lvar))
      | rename(tree, LT.FN(var, le,n)) =
d340 1
a340 1
	  val (tree, new_var) = add_var_and_return(tree, var)
d342 1
a342 1
	  LT.FN(new_var, rename(tree, le),n)
d344 1
a344 1
      | rename(tree, LT.LETREC(lv_list, le_list, le)) =
d346 2
a347 2
	  val tree =
	    Lists.reducel
d349 1
a349 1
	    (tree, lv_list)
d351 3
a353 3
	  LT.LETREC(map (fn lv => get_new(tree, lv)) lv_list,
		    map (fn le => (rename(tree, le))) le_list,
		    rename(tree, le))
d355 17
a371 17
      | rename(tree, LT.APP(le, le')) =
	LT.APP(rename(tree, le), rename(tree, le'))
      | rename(_, le as LT.SCON _) = le
      | rename(_, le as LT.INT _) = le
      | rename(tree, LT.SWITCH(le, tag_le_list, leo1, leo2)) =
	LT.SWITCH(rename(tree, le),
		  map (fn tag_le => rename_tag(tree, tag_le)) tag_le_list,
		  rename_opt(tree, leo1),
		  rename_opt(tree, leo2))
      | rename(tree, LT.STRUCT le_list) =
	LT.STRUCT(map (fn le => rename(tree, le)) le_list)
      | rename(tree, LT.SELECT(field, le)) =
	LT.SELECT(field, rename(tree, le))
      | rename(tree, LT.RAISE le) = LT.RAISE(rename(tree,  le))
      | rename(tree, LT.HANDLE(le, le')) =
	LT.HANDLE(rename(tree, le), rename(tree, le'))
      | rename(tree, le as LT.BUILTIN _) = le
d373 2
a374 2
      and rename_opt(tree, LT.ABSENT) = LT.ABSENT
      | rename_opt(tree, LT.PRESENT le) = LT.PRESENT(rename(tree, le))
d376 1
a376 1
      and rename_tag(tree, (tag, le)) =
d378 1
a378 1
	   LT.EXP_TAG le => LT.EXP_TAG(rename(tree, le))
d380 1
a380 1
	     rename(tree, le))
d382 2
a383 1
      rename(BalancedTree.empty order, expression)
d397 122
d657 41
d884 19
d984 4
a987 1
  fun is_shiftable shiftable_fnvars =
a990 2
      fun shiftable_fnvar l = (*l mem shiftable_fnvars*)false

d997 1
a997 1
	   LT.VAR var => shiftable_fnvar var
d999 2
a1000 2
	 | LT.FN (var,body,_) => (*shiftable (substitute (var,q,body))*)
	     is_shiftable (shiftable_fnvars ++ var) body
d1027 10
a1037 1

a1204 1

d1210 3
@


1.37
log
@Numerous efficiency improvements
@
text
@d7 3
d144 1
a144 1
	  | apply (context as LT.FN(lv, le)) =
d146 1
a146 1
	    in LT.FN (lv, appsub ctxt le) end
d231 1
a231 1
	  fun reduce (acc,LT.FN(_,le)) = reducesub (acc,le)
d233 1
a233 1
	    | reduce (acc,LT.APP(LT.FN(v,e1),e2)) = reduce_list (acc,[e2,e1])
d289 1
a289 1
      fun unwl(acc, LT.APP(LT.FN(var,body),arg)) = unwl((var,arg)::acc,body)
d299 2
a300 1
      fun nest (body,(var,arg)) = LT.APP(LT.FN(var,body),arg)
d326 1
a326 1
      fun acc_subst (tree, LT.FN(var,_)) =
d328 1
a328 1
      | acc_subst (tree, LT.APP(LT.FN(var,_),_)) =
d348 2
a349 2
      fun mk_subst (LT.FN(v,b)) = LT.FN(get_new v,b)
	| mk_subst (LT.APP(LT.FN(v,b),a)) = LT.APP(LT.FN(get_new v,b),a)
d384 1
a384 1
      | rename(tree, LT.FN(var, le)) =
d388 1
a388 1
	  LT.FN(new_var, rename(tree, le))
d446 1
a446 1
      | sub(LT.FN(lv, le)) = LT.FN(lv, sub(le))
d489 1
a489 1
      | sub(LT.FN(lv, le)) = LT.FN(lv, sub(le))
d549 1
a549 1
      | occurs(count, LT.FN(_, le)) = occurs(count, le)
d588 1
a588 1
     | build((bs,fs),  LT.FN(var,_)) = (bs++var, fs)
d590 1
a590 1
     | build((bs,fs),  LT.APP(LT.FN(var,_),_)) = (bs++var, fs)
d745 1
a745 1
  fun beta_reduce (LT.APP(LT.FN(var,body),arg)) = substitute (var,arg,body)
d763 1
a763 1
	 LT.FN(new_variable, apply_outermost abstract expression))
d769 1
a769 1
  fun eta_abstract le =
d773 1
a773 1
      LT.FN(lvar, LT.APP(le, LT.VAR lvar))
d793 1
a793 1
	fun strip (vars,LT.FN(var,body)) = strip(var::vars,body)
d810 2
a811 2
	and getfun (LT.FN(var,body), arg::args, result) = 
	                    getfun(body, args, (var,arg)::result)
d861 1
a861 1
	 | LT.FN (var,body) => (*shiftable (substitute (var,q,body))*)
d902 1
a902 1
      | submatch (LT.FN(var,body), LT.FN(var',body')) =
d968 1
a968 1
	     | (LT.FN(var,body), LT.FN(var',body')) =>
d1064 3
@


1.36
log
@Used a balanced tree for accumulating substitutions in substitute_fresh
@
text
@d7 3
d303 1
d308 7
d321 10
a331 6
      fun order(lv1, lv2) =
	if LT.LVar_eq(lv1, lv2) then BalancedTree.EQ
	else
	  if LT.LVar_order(lv1, lv2) then BalancedTree.LT
	  else BalancedTree.GT

d333 2
a334 3
	Lists.reducel
	(fn (tree, (old, new)) => BalancedTree.insert(tree, old, new))
	(BalancedTree.empty order, newvars)
d350 2
d355 1
d357 5
d363 64
d429 1
d437 20
d458 11
d480 33
d544 1
a544 1
	if LT.LVar_eq(lv, lvar) then count+1 else count
d847 1
a847 1
      fun shiftable_fnvar l = l mem shiftable_fnvars
d857 2
a858 1
	 | LT.FN (var,body) => shiftable (substitute (var,q,body))
d865 1
a865 1
	  val lexprs = le :: ((map snd clel) @@ (app leo1) @@ (app leo2))
d869 1
d1060 3
@


1.35
log
@Fixed bug in switch_evaled (both cases) whereby expression tags weren't
considered
@
text
@d7 4
d39 1
d44 9
a52 7
functor LambdaSub
  (structure Crash : CRASH
   structure Lists : LISTS
   structure Primitives : PRIMITIVES
   structure LambdaTypes : LAMBDATYPES
   sharing Primitives.Set = LambdaTypes.Set
   sharing Primitives.LambdaTypes = LambdaTypes) : LAMBDASUB =
a62 4
(*
  open Lists
*)

d93 2
d310 13
a322 1
	  
d324 5
d344 6
a349 6
     let 
	 fun subs (v as LT.VAR lvar) = if var=lvar then subexpr else v
	   | subs expr = expr
     in
	 apply_outermost subs expr
     end;
a350 1

d354 7
a360 8
     let 
	 fun subs (v as LT.VAR lvar) = if var=lvar 
					  then rename_fresh subexpr 
				       else v
	   | subs expr = expr
     in
	apply_outermost subs expr
     end;
d379 6
a384 6
 fun occurrences (lvar,expression) =
    let 
       fun count (LT.VAR lvar', sofar) = if lvar=lvar' 
					    then (sofar+1)
					 else sofar
	 | count (_, sofar) = sofar
d386 3
a388 2
       reduce_innermost count (expression,0)
    end;
d390 22
d413 2
d416 9
d429 3
a431 3
    let
       fun build(vars as (bs,fs),  LT.VAR var) = if var mem bs then vars
						 else (bs, fs++var)
d433 1
a433 1
	 | build((bs,fs),  LT.FN(var,_)) = (bs++var, fs)
d435 1
a435 1
	 | build((bs,fs),  LT.APP(LT.FN(var,_),_)) = (bs++var, fs)
d437 2
a438 2
	 | build((bs,fs),  LT.LETREC(lvs,_,_)) =
	   (Lists.reducel (op++) (bs,lvs), fs)
d440 4
a443 4
	 | build(vars, _) = vars
      in
	  reduce_outermost build ((nullset,nullset), expression)
      end;
d452 3
a454 4
   let 
      fun build (LT.VAR lvar, number) = if lvar = record_variable 
					   then number+1
					else number
d456 4
a459 5
	| build (LT.SELECT (_,LT.VAR var), number) = if var = record_variable
							then number-1
						     else number
	| build (_, number) = number
   in 
d461 1
a461 1
   end;
d591 1
a591 1
    | beta_reduce expr = expr;
d693 2
a694 4
     let 
	fun shiftable_prim p = not(p mem Primitives.imperative_primitives)
      
	fun shiftable_fnvar l = l mem shiftable_fnvars
d696 1
a696 3
	fun shiftable expr =
	   case expr of
	      LT.VAR _ => true
d698 28
a725 1
	    | LT.FN _  => true
a726 37
	    | LT.LETREC(_,_,x) => shiftable x

	    | LT.APP (p,q) => 
		 (shiftable q) andalso 
		 (case p of
		     LT.VAR var => shiftable_fnvar var
		   | LT.BUILTIN prim => shiftable_prim prim
		   | LT.FN (var,body) => shiftable (substitute (var,q,body))
		   | _ => false)  

	    | LT.SCON _ => true

	    | LT.INT _  => true

	    | LT.SWITCH (le,clel,leo1,leo2) => 
		let 
		  val app = fn (LT.PRESENT e) => [e] | LT.ABSENT => []
		  val lexprs = le :: ((map snd clel) @@ (app leo1) @@ (app leo2))
		in 
		   Lists.forall shiftable lexprs
		end

	    | LT.STRUCT lel => Lists.forall shiftable lel

	    | LT.SELECT (f,le) => shiftable le

	    | LT.RAISE _ => false

	    | LT.HANDLE (expr,pats) => shiftable expr

	    | LT.BUILTIN prim => (*shiftable_prim prim*)true
     (* prims are only unshiftable when applied *)
     in
	shiftable
     end;


d808 2
a809 1
	       (LT.VAR v, LT.VAR v') => v=v' orelse Lists.assoc(v,envir)=v'
d854 3
d859 1
a859 1
			(op=)
d866 3
d871 1
a871 1
			(op=)
d907 4
@


1.34
log
@Added substitute_list function, used by both _curry and _optimise_cse
Modified is_shiftable to disallow only applications of imperative
primitives (functions are always shiftable)
@
text
@d7 5
d462 3
d486 8
a493 4
	  (evaled e) U (case result_sets of 
			  [] => nullset
			| (r::rs) => Lists.reducel 
			    Set.intersection (r,rs))
d500 6
a507 6
      fun any f [] = false
        | any f (h::t) = f(h) orelse (any f t)

      fun all f [] = true
        | all f (h::t) = f(h) andalso (all f t)

d520 1
a520 1
      and switch_evaled (e,cases,cdef,pdef) = 
d523 14
a536 7
	  val opt = fn (LT.ABSENT,xs) => xs | (LT.PRESENT x,xs) => x::xs
	  val results = opt (cdef, opt (pdef, (map snd cases)))
	in
           case results of
             [] => false
           | _ => all evaled results
	end)
d869 5
@


1.33
log
@Fixed alpha_convertible to check that the TAGs match within
a switch as well as the expressions
@
text
@d7 4
d337 12
d670 2
a671 1
	    | LT.BUILTIN prim => shiftable_prim prim
d850 4
@


1.32
log
@Fixed another bug in in_evaluation_set
@
text
@d7 3
d747 9
a755 5
		  let
		     val envir' = Lists.zip (lvl,lvl') @@ envir
		  in
		     match(envir', LT.STRUCT (le::lel), LT.STRUCT (le'::lel'))
		   end
d761 3
d765 3
a767 3
		fun subo (LT.PRESENT le, LT.PRESENT le') = subm (le,le')
		  | subo (LT.ABSENT, LT.ABSENT) = true
		  | subo _ = false
d769 38
a806 4
		subm (le,le') andalso
		Lists.forall subm (Lists.zip (map snd clel, map snd clel')) andalso
		subo (leo1,leo1') andalso
		subo (leo2,leo2')
d810 1
d833 3
@


1.31
log
@Added a function is_in_extension_set so that we don't have to
generate the evaluation_set and then test to see if something is in it
which proved to be a very expensive operation
@
text
@d7 5
d495 3
a497 1
           all evaled results
d788 5
@


1.30
log
@Removed opens
@
text
@d6 4
a9 1
 * $Log:	_lambdasub.sml,v $
d464 33
d780 4
a783 1
$Log:	_lambdasub.sml,v $
@


1.29
log
@Added some brackets to keep njml 0.75 happy
@
text
@d6 4
a9 1
 * $Log$
d36 1
d38 1
d78 12
a89 16
  local 
    open LT 
  in
    fun whnf (VAR _)     = true
      | whnf (FN _)      = true
      | whnf (LETREC _)  = false
      | whnf (APP _)     = false
      | whnf (SCON _)    = true
      | whnf (INT _)     = true
      | whnf (SWITCH _)  = false
      | whnf (STRUCT _)  = false
      | whnf (SELECT _)  = false
      | whnf (RAISE _)   = false
      | whnf (HANDLE _)  = false
      | whnf (BUILTIN _) = true
  end
d270 1
a270 1
      reducel nest (expression, rev vas)
d286 1
a286 1
      fun get_new var = (assoc (var,newvars))  handle Assoc => var
d351 2
a352 1
	 | build((bs,fs),  LT.LETREC(lvs,_,_)) =(reducel (op++) (bs,lvs), fs)
d401 3
a403 2
     let
	open LT
d405 1
a405 2
	fun flatten [] = []
	  | flatten (l::ls) = l @@ (flatten ls)
d407 14
a420 1
	exception Stop of LambdaExp list
a421 14
	fun sequence (seq,expr) =  
	   if (whnf expr) then seq @@ [expr]
	   else case expr of
	      LETREC _ => seq @@ [expr]
	    | APP(p,q) => sequence(sequence(seq,p),q)
	    | SWITCH(e,_,_,_) => raise Stop (sequence(seq,e))
	    | STRUCT lel => reducel sequence (seq,lel)
	    | SELECT(_,e) => sequence(seq,e)
	    | RAISE e => sequence(seq,e)
	    | HANDLE(p,_) => raise Stop (sequence(seq,p))
	    | _ => Crash.impossible "erk seq/whnf!"
     in
	(sequence([],expression)) handle Stop seq => seq
     end
a422 1

d431 13
a443 2
     let
	open LT
d445 14
a458 12
	fun evaled(expr) = (Set.singleton expr) U
	   		    (if (whnf expr) then nullset
			     else case expr of
				LETREC _ => nullset
			      | APP(p,q) => evaled(p) U evaled(q)
			      | SWITCH x => switch_evaled x
			      | STRUCT lel => reducel (op U) (nullset, map
								  evaled lel)
			      | SELECT(_,e) => evaled(e)
			      | RAISE e => evaled(e)
			      | HANDLE(p,_) => evaled(p)
			      | _ => Crash.impossible "erk ev_set/whnf!")
a459 14
	and switch_evaled (e,cases,cdef,pdef) = 
	   let 
	      val opt = fn (ABSENT,xs) => xs | (PRESENT x,xs) => x::xs
	      val results = opt (cdef, opt (pdef, (map snd cases)))
	      val result_sets = map evaled results
	   in
	      (evaled e) U (case result_sets of 
	      			[] => nullset
			      | (r::rs) => reducel 
				            Set.intersection (r,rs))
	   end
     in
	evaled
     end
a460 2


d536 3
a538 4
	       if pairs=[]
		  then (reducel LT.APP (expr,args),
			result)
	       else getfun (expr', args, pairs@@result)
d541 2
a542 2
	  | getfun (expr, args, result) = (reducel LT.APP (expr,args),
					   result)
d597 1
a597 1
		   forall shiftable lexprs
d600 1
a600 1
	    | LT.STRUCT lel => forall shiftable lel
d629 2
a630 2
    fun submatch(LT.VAR v1, _) = (match(envir, (e2,assoc(v1,envir)))
				  handle Assoc => (v1,e2)::envir)
d637 2
a638 2
       	    val envir1 = (zip (lvl, map LT.VAR lvl')) @@ envir
	    val envir2 = reducel match (envir1, zip (lel, lel'))
d650 5
a654 5
	    val envir2 = reducel match (envir1, 
					    zip (map snd clel, 
						 map snd clel'))
	    val envir3 = reducel match_opt (envir,
						[(leo1,leo1'),(leo2,leo2')])
d660 1
a660 1
          reducel match (envir, zip (les,les'))
d663 2
a664 2
         if f=f' then match(envir, (le,le'))
	 else raise FailedMatch
d679 1
a679 1
	   else submatch(e1,e2)  handle Zip => raise FailedMatch
d695 1
a695 1
	       (LT.VAR v, LT.VAR v') => v=v' orelse assoc(v,envir)=v'
d702 1
a702 1
		     val envir' = zip (lvl,lvl') @@ envir
d717 1
a717 1
		forall subm (zip (map snd clel, map snd clel')) andalso
d722 2
a723 1
	   | (LT.STRUCT les, LT.STRUCT les') => forall subm (zip (les,les'))
d736 1
a736 1
      (match ([], e1, e2)) handle Zip => false | Assoc => false
d745 3
@


1.28
log
@Added eta_abstract function for general use
@
text
@d1 1
a1 1

d6 1
d453 1
a453 1
	      (evaled e) U case result_sets of 
d456 1
a456 1
				            Set.intersection (r,rs)
d748 3
@


1.27
log
@Added new functions apply_innermost_with_context
and apply_outermost_with_context.
@
text
@d487 2
d490 6
d747 4
@


1.26
log
@Replaced impossible exception with Crash.impossible calls.
@
text
@d91 8
a98 5
  (*  Recursively apply a function to a lambda-expression and its  *)
  (*  sub-expressions, either innermost or outermost terms first,  *)
  (*  building an isomorphic lambda-expression.  Innermost is AOR, *)
  (*  outermost is like AOR but applies the  function to the       *)
  (*  largest term first.    Like 'map'               		   *)
d103 6
a108 4
	fun apply_tagval (LT.EXP_TAG tag, value) =
	    (LT.EXP_TAG (appsub tag), appsub value)
	  | apply_tagval (tag', value) =
	    (tag', appsub value)
d110 37
a146 17
	fun apply (LT.FN(lv,le)) = LT.FN (lv, appsub le)
	  | apply (LT.LETREC(lvl,lel,le)) =
	    LT.LETREC (lvl, map appsub lel, appsub le)
	  | apply (LT.APP(LT.FN(v,e2),e1)) =
	    LT.APP(LT.FN(v,appsub e2), appsub e1)
	  | apply (LT.APP (p,q)) = LT.APP(appsub p, appsub q)
	  | apply (LT.SWITCH(le,clel,leo1,leo2)) = 
	    LT.SWITCH(appsub le, map apply_tagval clel,
		      apopt appsub leo1, apopt appsub leo2)
	  | apply (LT.STRUCT lel) = LT.STRUCT (map appsub lel)
	  | apply (LT.SELECT (fld,le)) = LT.SELECT (fld, appsub le)
	  | apply (LT.RAISE le) = LT.RAISE (appsub le)
	  | apply (LT.HANDLE (le1,le2)) = LT.HANDLE (appsub le1, appsub le2)
	  | apply expr = expr
    in 
      apply
    end
d150 4
a153 3
	fun appsub x = f (apply_lexprs appsub x)
      in 
	appsub
d156 8
d166 2
a167 1
	fun appsub x = apply_lexprs appsub (f x)
d169 1
a169 1
	appsub
d172 9
a180 1
    val apply_one_level = apply_lexprs
d739 3
@


1.25
log
@General tidy up, Made changes due to record selection now requiring
the total size of the record to be present as well as the index.
Took out utility functions and put them in List structure.
@
text
@d2 6
a7 1
   (*  Lambda Optimiser:  _lambdasub.sml *)
d9 1
a9 5
   (*  sub-functions for lambda modules. *)

  (*  Copyright (c) 1991 Harlequin Ltd.   *)


d15 10
a24 10

functor LambdaSub(structure Lists : LISTS
		  structure Primitives : PRIMITIVES
		  structure LambdaTypes : LAMBDATYPES
		  sharing Primitives.Set = LambdaTypes.Set
		  sharing Primitives.LambdaTypes = LambdaTypes) : LAMBDASUB =
 struct

 structure LambdaTypes = LambdaTypes;
 structure Set = LambdaTypes.Set;
d26 1
a26 2
 structure LT = LambdaTypes;        (* A short name for clarity! *)
  
d28 3
a30 3
 (**************)
 (* Miscellany *)
 (**************)
d32 1
a32 1
 open Lists
d34 1
a34 1
 (* aliases for set functions *)
d36 9
a44 9
 val nullset = Set.empty_set;
 val mem = Set.is_member;
 val ++ = fn (x,y) => Set.add_member (y,x);
 val == = Set.seteq;
 val U = Set.union;
 infix mem;
 infix ++;
 infix ==;
 infix U;
d46 1
a46 1
 (* Pair destructors *)
d48 2
a49 2
 fun fst (x,_) = x;
 fun snd (_,y) = y;
d51 1
d53 2
a54 1
 (* Apply a function to first or second component of a pair *)
d56 1
a56 2
 fun apfst f (x,y) = (f x, y);
 fun apsnd f (x,y) = (x, f y);
d58 2
a59 2
        
 (* Optionally apply a function to an optional argument *)
d61 2
a62 2
 fun apopt f (LT.PRESENT x) = LT.PRESENT (f x)
   | apopt _ LT.ABSENT      = LT.ABSENT;
d64 3
a67 21
 fun is_var (LT.VAR _) = true
   | is_var _ = false;


 (*  Jon's utilities  *)

  fun filter_ordered_map(a_list, []) = []
  | filter_ordered_map([], _) =
    raise(LT.impossible"member missing in filter_ordered_map")
  | filter_ordered_map((x, y)::xs, z :: zs) =
    if x = z then
      (x, y) :: (filter_ordered_map(xs, zs))
    else
      filter_ordered_map(xs, z :: zs)


 (*******************************)
 (* Lambda-Expression Utilities *)
 (*******************************)


d73 1
a73 1
      open LT 
d75 12
a86 12
      fun whnf (VAR _)     = true
	| whnf (FN _)      = true
	| whnf (LETREC _)  = false
	| whnf (APP _)     = false
	| whnf (SCON _)    = true
	| whnf (INT _)     = true
	| whnf (SWITCH _)  = false
	| whnf (STRUCT _)  = false
	| whnf (SELECT _)  = false
	| whnf (RAISE _)   = false
	| whnf (HANDLE _)  = false
	| whnf (BUILTIN _) = true
a88 1

a90 1

d98 6
a103 5
   fun apply_lexprs appsub = 
    let 
       fun apply_tagval (LT.EXP_TAG tag, value) = (LT.EXP_TAG (appsub tag),
						   appsub value)
	 | apply_tagval (tag', value) = (tag', appsub value)
d106 4
a109 8

	  | apply (LT.LETREC(lvl,lel,le)) = LT.LETREC (lvl, 
						       map appsub lel, 
						       appsub le)

	  | apply (LT.APP(LT.FN(v,e2),e1)) = LT.APP(LT.FN(v,appsub e2),
						    appsub e1)

a110 1

d112 2
a113 5
	    		LT.SWITCH(appsub le, 
				  map apply_tagval clel,
				  apopt appsub leo1,
				  apopt appsub leo2)

a114 1

a115 1

a116 1

a117 1

d120 1
a120 1
	apply
d123 6
a128 6
      fun apply_innermost f = 
	  let 
	      fun appsub x = f (apply_lexprs appsub x)
	  in 
	      appsub
	  end
d130 6
a135 6
      fun apply_outermost f =
	  let
	      fun appsub x = apply_lexprs appsub (f x)
	  in
	      appsub
	  end
d137 1
a137 2
      val apply_one_level = apply_lexprs

a139 1

d144 1
a144 1
 local
d146 5
a150 5
	let
	   fun caseexprs_of ((LT.EXP_TAG tag, value)::tvs) = tag::value::
							     (caseexprs_of tvs)
	     | caseexprs_of ((_,value)::tvs) = value :: (caseexprs_of tvs)
	     | caseexprs_of [] = []
d152 2
a153 2
	    fun listit LT.ABSENT = []
	      | listit (LT.PRESENT item) = [item]
d155 12
a166 1
	    fun reduce (acc,LT.FN(_,le)) = reducesub (acc,le)
d168 4
a171 26
	      | reduce (acc,LT.LETREC(_,lel,le)) = reduce_list (acc,(lel@@[le]))

	      | reduce (acc,LT.APP(LT.FN(v,e1),e2)) = reduce_list (acc,[e2,e1])

	      | reduce (acc,LT.APP(p,q)) = reduce_list (acc,[p,q])

	      | reduce (acc,LT.SWITCH(le,clel,leo1,leo2)) = 
		reduce_list (acc,(le :: (caseexprs_of clel) @@ (listit leo1) @@
				  (listit leo2)))

	      | reduce (acc,LT.STRUCT lel) = reduce_list (acc,lel)

	      | reduce (acc,LT.SELECT(_,le)) = reducesub (acc,le)

	      | reduce (acc,LT.RAISE le) = reducesub (acc,le)

	      | reduce (acc,LT.HANDLE (le1,le2)) = reduce_list (acc,[le1,le2])

	      | reduce (acc,_) = acc

	    and reduce_list (acc,[]) = acc
	      | reduce_list (acc,expr::exprs) = let 
						  val acc'=reducesub (acc,expr)
						in 
						    reduce_list(acc',exprs)
						end
d173 1
a173 1
	    reduce
d175 8
a182 8
 in 
     fun reduce_innermost f (expression,ident) =
	 let
	     fun reducesub (acc,expr) =
		     f(expr, reduce_lexprs reducesub (acc, expr))
	 in
	     reducesub (ident,expression)
	 end
d184 7
a190 7
     fun reduce_outermost f (ident,expression) =
	 let
	     fun reducesub (acc,expr) = 
		     reduce_lexprs reducesub (f(acc,expr),expr)
	 in
	     reducesub (ident,expression)
	 end
d192 16
a207 3
     fun reduce_inner_until f (expression,ident) =
	let
	   exception Stop of '_a
d209 1
a209 12
	   fun reducesub (acc,expr) =
	      (let
		  val ival = reduce_lexprs reducesub (acc,expr)
		  val (fval,finish) = f (expr, ival)
	       in
		  if finish then raise Stop fval
		  else fval
	       end)
	in
	   reducesub (ident,expression) handle Stop x => x
	end
 end
d211 7
d219 1
a219 1
 (* Unwrap Lets *)
d221 6
a226 7
 fun unwrap_lets expr =
     let 
	 fun unwl(acc, LT.APP(LT.FN(var,body),arg)) = unwl((var,arg)::acc,body)
	   | unwl(acc, expr) = (rev acc, expr)
     in
	 unwl([],expr)
     end;
d228 1
d230 1
a230 13
(* Wrap Lets *)

 fun wrap_lets (expression, vas) = 
     let
	 fun nest (body,(var,arg)) = LT.APP(LT.FN(var,body),arg)
     in
	 reducel nest (expression, rev vas)
     end;


 (*  Rename all bound variables with new ones in a lambda-expression.  *)

 fun rename_fresh expression =
d232 1
a232 1
       fun pair_new var = (var, LT.new_LVar())
d234 4
a237 4
       fun acc_subst (vars, LT.FN(var,_)) = (pair_new var)::vars
	 | acc_subst (vars, LT.APP(LT.FN(var,_),_)) = (pair_new var)::vars
	 | acc_subst (vars, LT.LETREC(lvl,_,_)) = (map pair_new lvl) @@ vars
	 | acc_subst (vars, _) = vars
d239 1
a239 1
       val newvars = reduce_outermost acc_subst ([],expression)
d241 1
a241 1
       fun get_new var = (assoc (var,newvars))  handle Assoc => var
d243 6
a248 6
       fun mk_subst (LT.FN(v,b)) = LT.FN(get_new v,b)
	 | mk_subst (LT.APP(LT.FN(v,b),a)) = LT.APP(LT.FN(get_new v,b),a)
	 | mk_subst (LT.LETREC(lvl,lel,le)) = LT.LETREC(map get_new lvl,
							lel, le)
	 | mk_subst (LT.VAR v) = LT.VAR(get_new v)
	 | mk_subst expr = expr
d250 2
a251 2
       apply_outermost mk_subst expression
    end;
d373 1
a373 1
	    | _ => raise LT.impossible "erk seq/whnf!"
d401 1
a401 1
			      | _ => raise LT.impossible "erk ev_set/whnf!")
d696 5
@


1.24
log
@Added VAR clause to substitution in rename_fresh.
(whoops!)
@
text
@a69 24
  fun filter(f_list, filter_fun) = 
  let
    fun filter_sub([]) = []
    | filter_sub(h :: t) =
    if filter_fun h then h :: (filter_sub t)
    else filter_sub t
  in
    filter_sub f_list
  end

  fun filter_length(filter_list, filter_fun) =
  let fun filter_sub([], n) = n
    | filter_sub(h :: t, n) = filter_sub(t, if filter_fun h then n+1 else n)
  in
    filter_sub(filter_list, 0)
  end

  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end

a79 1

d742 4
@


1.23
log
@reduce and apply functions now recurse over expression-valued
tags in SWITCH expressions.
@
text
@d318 1
d767 4
@


1.22
log
@Changed type of substitute, added substitute_fresh,
improved and corrected alpha_convertible test.
@
text
@d144 4
d161 1
a161 1
				  map (apsnd appsub) clel,
d204 5
d221 1
a221 1
		reduce_list (acc,(le :: (map snd clel) @@ (listit leo1) @@
d766 4
@


1.21
log
@Some list-like functions and others removed.
@
text
@d290 1
d292 3
a294 2
 (*  Simultaneous substitution, given association list of LVar's => exprs  *)
 (*  NB!  Substitutes recursively for non-atomic bindings.                 *)
d296 22
a317 1
 fun substitute subslist =
d319 1
a319 2
	 fun subs (v as LT.VAR lvar) = ((assoc (lvar,subslist))
	    				handle Assoc => v)
d322 1
a322 1
	 (apply_outermost subs) 
d326 1
a326 3
  (*  Calculate the number of occurrences of a (free) lambda-variable *)
  (*  in a lambda-expression, assuming unique naming, i.e. ignoring   *)
  (*  bound occurrences / LETREC lists.		 		      *)
d328 16
a343 1
  fun occurrences (lvar,expression) =
d345 4
a348 4
	fun count (LT.VAR lvar', sofar) = if lvar=lvar' 
					      then (sofar+1)
					  else sofar
	  | count (_, sofar) = sofar
d350 1
a350 1
	reduce_innermost count (expression,0)
d355 2
a356 2
  (*  Construct the set of bound variables and the set of free variables  *)
  (*  in a lambda-expression.  						  *)
d358 4
a361 6
  fun bounds_and_frees expression =
      let
	  fun build(vars as (bounds,frees),  LT.VAR var) = if var mem bounds
							       then vars
							   else (bounds, 
								 frees++var)
d363 1
a363 1
	    | build((bounds,frees),  LT.FN(var,_)) = (bounds++var, frees)
d365 1
a365 2
	    | build((bounds,frees),  LT.APP(LT.FN(var,_),_)) = (bounds++var,
								frees)
d367 1
a367 2
	    | build((bounds,frees),  LT.LETREC(lvs,_,_)) =(reducel (op++) 
							   (bounds,lvs), frees)
d369 1
a369 1
	    | build(vars, _) = vars
d382 3
a384 3
    fun build (LT.VAR lvar, number) = if lvar = record_variable 
					  then number+1
				      else number
d386 4
a389 4
      | build (LT.SELECT (_,LT.VAR var), number) = if var = record_variable
						       then number-1
						   else number
      | build (_, number) = number
d391 1
a391 1
       reduce_innermost build (expression,0)
d401 7
a407 7
      let
	  fun sequence (expr,  list) = if whnf expr
					   then expr::list
				       else list
      in
	  rev (reduce_innermost sequence (expression,[]))
      end
d409 1
d416 2
a417 2
      let
	  open LT
d419 2
a420 2
	  fun flatten [] = []
	    | flatten (l::ls) = l @@ (flatten ls)
d422 1
a422 1
	  exception Stop of LambdaExp list
d424 14
a437 14
	  fun sequence (seq,expr) =  
	     if (whnf expr) then seq @@ [expr]
	     else case expr of
		LETREC _ => seq @@ [expr]
	      | APP(p,q) => sequence(sequence(seq,p),q)
	      | SWITCH(e,_,_,_) => raise Stop (sequence(seq,e))
	      | STRUCT lel => reducel sequence (seq,lel)
	      | SELECT(_,e) => sequence(seq,e)
	      | RAISE e => sequence(seq,e)
	      | HANDLE(p,_) => raise Stop (sequence(seq,p))
	      | _ => raise LT.impossible "erk seq/whnf!"
      in
	 (sequence([],expression)) handle Stop seq => seq
      end
d484 1
a484 1
  fun beta_reduce (LT.APP(LT.FN(var,body),arg)) = substitute [(var,arg)] body
d493 3
a495 3
      let
	  val new_variable = LT.new_LVar()
	  val new_sub_expression = LT.VAR new_variable
d497 7
a503 7
	  fun abstract expr = if expr=sub_expression 
				  then new_sub_expression
			      else expr
      in
	  (new_variable,
	   LT.FN(new_variable, apply_outermost abstract expression))
      end
d523 6
a528 6
      let 
	  fun strip (vars,LT.FN(var,body)) = strip(var::vars,body)
	    | strip (vars,_) = rev vars
      in
	  strip ([],expr)
      end
d537 3
a539 3
      let
	  fun getargs (LT.APP(func,arg), args) = getargs(func, arg::args)
	    | getargs (func,args) = getfun (func,args,[])
d541 2
a542 2
	  and getfun (LT.FN(var,body), arg::args, result) = 
	      		getfun(body, args, (var,arg)::result)
d544 9
a552 9
	    | getfun (expr as LT.APP _, args, result) =
	            let
			val (expr',pairs) = getargs (expr,[])
		    in 
			if pairs=[]
			    then (reducel LT.APP (expr,args),
				  result)
			else getfun (expr', args, pairs@@result)
		    end
d554 5
a558 5
	    | getfun (expr, args, result) = (reducel LT.APP (expr,args),
					     result)
      in
	  getfun (expression, [], [])
      end
d575 3
a577 3
   (*  See if an expression is shiftable, in the sense that dynamic     *)
   (*  evaluation of it doesn't refer to state, raise an exception, or  *)
   (*  loop forever.  We can only approximate the full set!		*)
d579 3
a581 3
 fun is_shiftable shiftable_fnvars =
  let 
      fun shiftable_prim p = not(p mem Primitives.imperative_primitives)
d583 1
a583 1
      fun shiftable_fnvar l = l mem shiftable_fnvars
d585 3
a587 3
      fun shiftable expr =
      case expr of
	 (LT.VAR _) => true
d589 1
a589 1
       | (LT.FN _)  => true
d591 1
a591 1
       | (LT.LETREC(_,_,x)) => shiftable x
d593 7
a599 7
       | (LT.APP (p,q)) => 
	     (shiftable q) andalso 
	     (case p of
		  (LT.VAR var) => shiftable_fnvar var
		| (LT.BUILTIN prim) => shiftable_prim prim
		| (LT.FN (var,body)) => shiftable (substitute [(var,q)] body)
		| _ => false)  
d601 1
a601 1
       | (LT.SCON _) => true
d603 1
a603 1
       | (LT.INT _)  => true
d605 7
a611 7
       | (LT.SWITCH (le,clel,leo1,leo2)) => 
	     let 
		 val app = fn (LT.PRESENT e) => [e] | LT.ABSENT => []
		 val lexprs = le :: ((map snd clel) @@ (app leo1) @@ (app leo2))
	     in 
		 forall shiftable lexprs
	     end
d613 1
a613 1
       | (LT.STRUCT lel) => forall shiftable lel
d615 1
a615 1
       | (LT.SELECT (f,le)) => shiftable le
d617 1
a617 1
       | (LT.RAISE _) => false
d619 1
a619 1
       | (LT.HANDLE (expr,pats)) => shiftable expr
d621 4
a624 4
       | (LT.BUILTIN prim) => shiftable_prim prim
  in
      shiftable
  end;
d630 1
a630 1
 fun size_of_expr expression = reduce_outermost (fn(c,_)=>c+1) (0,expression);
a632 1
 (*  Rename all bound variables with new ones in a lambda-expression.  *)
a633 23
 fun rename_fresh expression =
     let
	fun pair_new var = (var, LT.new_LVar())

	fun acc_subst (vars, LT.FN(var,_)) = (pair_new var)::vars
	   | acc_subst (vars, LT.APP(LT.FN(var,_),_)) = (pair_new var)::vars
	   | acc_subst (vars, LT.LETREC(lvl,_,_)) = (map pair_new lvl) @@ vars
	   | acc_subst (vars, _) = vars
	     
	val newvars = reduce_outermost acc_subst ([],expression)

	fun get_new var = (assoc (var,newvars))  handle Assoc => var

	fun mk_subst (LT.FN(v,b)) = LT.FN(get_new v,b)
	  | mk_subst (LT.APP(LT.FN(v,b),a)) = LT.APP(LT.FN(get_new v,b),a)
	  | mk_subst (LT.LETREC(lvl,lel,le)) = LT.LETREC(map get_new lvl,
							 lel, le)
	  | mk_subst expr = expr
     in
	apply_outermost mk_subst expression
     end;


d696 5
a700 2
  (*  Test whether two lambda-expressions are alpha-convertible.	     *)
  (* could be more efficient with own function instead of more general match *)
d703 6
a708 9
      e1=e2
      orelse (let
		  val varmap = match ([],expression_pair)
		  val (bound_vars,_) = bounds_and_frees e1
	      in
		  (forall is_var (map snd varmap))
		  andalso (Set.list_to_set (map fst varmap)) == bound_vars
	      end
			  handle FailedMatch => false);
d710 2
a711 1
end
d713 6
d720 35
d757 3
@


1.20
log
@Made rename_fresh generate new lambda-variables in LETREC's
too.
@
text
@a0 1
(* _lambdasub.sml  - sub-functions for lambda modules *)
d2 1
a2 5
(*
$Log:	_lambdasub.sml,v $
Revision 1.19  91/08/23  16:20:37  davida
Made usual substitute function non-recursive,
corrected evaluation_set
d4 1
a4 2
Revision 1.18  91/08/15  14:50:56  davida
Miscellaneous changes, new functions.
d6 1
a6 3
Revision 1.17  91/08/14  13:23:00  davida
removed set_of_lvars, changed bounds_and_frees to include
variables bound by LETREC's.
a7 2
Revision 1.16  91/08/13  16:05:42  davida
Added sub-expression substitution function "replace_subexpr"
d9 1
a9 55
Revision 1.15  91/08/13  13:50:01  davida
No change.

Revision 1.14  91/08/09  14:40:05  davida
New functions added

Revision 1.13  91/08/06  15:18:45  davida
Altered selects_on_var for 2nd phase, temporarily.

Revision 1.12  91/08/02  17:07:52  davida
LETREC's are now classed as shiftable expressions,
if their resulting tuples are.  (And why not?)

Revision 1.11  91/08/02  16:05:09  davida
Added function size_of_expr to count number
of sub expressions in an expression.

Revision 1.10  91/08/01  19:44:17  davida
Reverted back to _correct_ semantics for
evaluating APP's --- evaluate function-valued
object first, then argument.  Then do
application.

Revision 1.9  91/07/31  14:44:18  davida
forall conversion from exists improved.

Revision 1.8  91/07/30  16:45:55  davida
Added some more functions, fiddled with some old ones.

Revision 1.7  91/07/29  16:45:37  davida
Changed is_expansive to is_shiftable, added unwrap_apps.

Revision 1.6  91/07/25  13:38:27  davida
Added new functions, restructured and improved existing ones.

Revision 1.5  91/07/24  13:18:54  davida
A couple of fixes, altered form of is_expansive and added set_of_selects

Revision 1.4  91/07/22  12:52:42  jont
Moved some general purpose functions in from _lambda

Revision 1.3  91/07/17  13:20:47  davida
is_expansive becomes stricter...

Revision 1.2  91/07/16  18:00:51  davida
Added new functions set_of_lvars and is_expansive.

Revision 1.1  91/07/15  16:12:31  davida
Initial revision


Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/set";
d15 1
a15 1
functor LambdaSub(structure Set : SET
d18 1
a18 1
		  sharing Primitives.Set = Set
d23 2
a24 2
 structure Set = Set;
     
d26 1
d28 3
d32 1
a32 3
 (********************************)
 (* "Standard" Utility Functions *)
 (********************************)
d34 2
d38 1
a38 1
 val ++ = Set.add_member;
a45 12

 (* reduce_left:  left-associative function compose down a list *)

 fun reduce_left f =
     let 
	 fun itl (i,[]) = i
	   | itl (i,x::xs) = itl(f(i,x),xs)
     in 
	 itl
     end;


d64 2
a65 1
 (* Return the nth element in a list, starting from 0 *)
a66 4
 exception LambdaSubNth;
 fun nth (0,x::_) = x
   | nth (n,_::xs) = nth (n-1, xs)
   | nth (_,[]) = raise LambdaSubNth;
d68 1
a69 44
 (* Look-up in an association list, using Opt type from LambdaTypes *)

 fun assoc key =
     let 
	 fun ass ((k,v)::kvs) = if k=key 
				    then (LT.PRESENT v)
				else 
				    ass kvs
	   | ass [] = LT.ABSENT
     in 
	 ass 
     end;


 (* Test if a predicate holds for any element of a list *)

 fun exists P =
     let 
	 fun test [] = false
	   | test (x::xs) = (P x) orelse test xs
     in
	 test
     end;
     

 (* Test if a predicate holds for all elements of a list *)

 fun forall P =
     let 
	 fun test [] = true
	   | test (x::xs) = (P x) andalso test xs
     in
	 test
     end;
     

 exception Zip;
 fun zip ([],[]) = []
   | zip (x::xs,y::ys) = (x,y)::(zip (xs,ys))
   | zip _ = raise Zip;

 fun is_var (LT.VAR _) = true
   | is_var _ = false;

d286 1
a286 1
	 reduce_left nest (expression, rev vas)
d291 2
a292 1
 (* Simultaneous substitution, given association list of LVar's => exprs *)
d296 2
a297 3
	 fun subs (v as LT.VAR lvar) = (case (assoc lvar subslist) of
					    (LT.PRESENT sub_expr) => sub_expr
					  |  LT.ABSENT            => v)
a303 17

 (* Simultaneous recursive substitution,      *)
 (* given association list of LVar's => exprs *)
 (* NB! Infinite loops for Vx=>Vx             *)

 fun rec_substitute subslist =
     let 
	 fun subs (v as LT.VAR lvar) = (case (assoc lvar subslist) of
					 (LT.PRESENT sub_expr) => 
					     apply_innermost subs sub_expr
				       |  LT.ABSENT            => v)
	   | subs expr = expr
     in
	 apply_innermost subs
     end;


d328 1
a328 1
								 var++frees)
d330 1
a330 1
	    | build((bounds,frees),  LT.FN(var,_)) = (var++bounds, frees)
d332 1
a332 1
	    | build((bounds,frees),  LT.APP(LT.FN(var,_),_)) = (var++bounds,
d335 1
a335 2
	    | build((bounds,frees),  LT.LETREC(lvs,_,_)) =(reduce_left 
							   (fn(x,y)=>y++x)
d398 1
a398 1
	      | STRUCT lel => reduce_left sequence (seq,lel)
d425 1
a425 1
			      | STRUCT lel => reduce_left (op U) (nullset, map
d440 1
a440 1
			      | (r::rs) => reduce_left 
d517 1
a517 1
			    then (reduce_left LT.APP (expr,args),
d522 1
a522 1
	    | getfun (expr, args, result) = (reduce_left LT.APP (expr,args),
d531 3
a533 2
  fun is_commutative (LT.BUILTIN p) = p mem Primitives.commutative_primitives
    | is_commutative _ = false;
d536 7
d614 1
a614 3
	fun get_new var = (case assoc var newvars of
			      LT.PRESENT var' => var'
			    | LT.ABSENT => var)
d634 2
a635 3
    fun submatch(LT.VAR v1, _) = (case assoc v1 envir
				      of LT.PRESENT e3 => match(envir, (e2,e3))
				    | LT.ABSENT => (v1,e2)::envir)
d643 1
a643 1
	    val envir2 = reduce_left match (envir1, zip (lel, lel'))
d655 1
a655 1
	    val envir2 = reduce_left match (envir1, 
d658 1
a658 1
	    val envir3 = reduce_left match_opt (envir,
d665 1
a665 1
          reduce_left match (envir, zip (les,les'))
d703 73
@


1.19
log
@Made usual substitute function non-recursive,
corrected evaluation_set
@
text
@d5 4
d722 4
d728 3
d733 6
a738 4
	 fun acc_subst(vars, LT.FN(var,_)) = (var, LT.new_LVar())::vars
	   | acc_subst(vars, LT.APP(LT.FN(var,_),_)) = 
					     (var, LT.new_LVar())::vars
	   | acc_subst(vars, _) = vars
d740 1
a740 1
	 val newvars = reduce_outermost acc_subst ([],expression)
d742 3
a744 4
	 fun mk_subst (expr as LT.FN(var,body)) = 
	     (case assoc var newvars of
		  LT.PRESENT var' => LT.FN(var',body)
       	        | LT.ABSENT => expr)
d746 5
a750 11
	   | mk_subst (expr as LT.APP(LT.FN(var,body),arg)) =
	     (case assoc var newvars of
		  LT.PRESENT var' => LT.APP(LT.FN(var',body),arg)
       	        | LT.ABSENT => expr)

	   | mk_subst (expr as LT.VAR var) = 
	     (case assoc var newvars of
		  LT.PRESENT var' => LT.VAR var'
       	        | LT.ABSENT => expr)

	   | mk_subst expr = expr
d752 1
a752 1
	 apply_outermost mk_subst expression
d754 1
@


1.18
log
@Miscellaneous changes, new functions.
@
text
@d5 3
d414 1
a414 1
	 (apply_innermost subs) 
d552 1
a552 1
	   		    (if (whnf expr) then (Set.singleton expr)
d555 1
a555 1
			      | APP(p,q) => evaled(q) U evaled(p)
d562 1
a562 1
			      | _ => raise LT.impossible "erk seq/whnf!")
d570 4
a573 3
	      case result_sets of
		 [] => nullset
	       | (r::rs) => reduce_left Set.intersection (r,rs)
@


1.17
log
@removed set_of_lvars, changed bounds_and_frees to include
variables bound by LETREC's.
@
text
@d5 4
d93 1
d97 2
a99 1

d300 1
d361 16
d498 1
a498 1
  fun evaluated_sequence expression =
d507 4
d512 1
a512 5
  (*  Construct a list of the irreducible sub-expressions of an expression   *)
  (*  in the order that they will be evaluated, returning only those         *)
  (*  sub-expressions that will definitely be evaluated.		     *)

  val strictly_evaluated_sequence =
d519 13
a531 10
	  fun sequence expr =  if (whnf expr) then [expr]
			       else case expr of
				   LETREC _ => []
				 | APP(p,q) => sequence(q) @@ sequence(p)
				 | SWITCH(e,_,_,_) => sequence(e)
				 | STRUCT lel => flatten (map sequence lel)
				 | SELECT(_,e) => sequence(e)
				 | RAISE e => sequence(e)
				 | HANDLE(p,_) => sequence(p)
				 | _ => raise LT.impossible "erk seq/whnf!"
d533 1
a533 1
	  sequence
d535 39
@


1.16
log
@Added sub-expression substitution function "replace_subexpr"
@
text
@d5 3
d440 4
a448 16

(* obselete *)

  (*  Build the set of lambda-variables in an expression.        *)
  (*  Construct as a list first and then use Set.list_to_set...  *)

  fun set_of_lvars expression =
      let 
	  fun build( LT.VAR lvar,        lvars) = lvar::lvars
	    | build( LT.FN(lvar,_),      lvars) = lvar::lvars
	    | build( LT.APP(LT.FN(lvar, _),_), lvars) = lvar::lvars
	    | build( LT.LETREC(lvs,_,_), lvars) = lvs@@lvars
	    | build( _,                  lvars) = lvars
      in
	  Set.list_to_set (reduce_innermost build (expression,[]))
      end
@


1.15
log
@No change.
@
text
@d5 3
d544 13
@


1.14
log
@New functions added
@
text
@d5 3
d287 1
a287 1
      fun apply_one_level f = apply_lexprs f
@


1.13
log
@Altered selects_on_var for 2nd phase, temporarily.
@
text
@d5 3
d76 1
d79 1
a79 1
 val nullset = Set.empty_set;
d82 1
d158 8
d241 1
d245 4
d250 1
d256 1
d258 1
d260 1
d262 1
d264 1
d283 2
d299 1
d301 3
d305 1
d309 1
d311 1
d313 1
d315 1
d317 1
d348 1
d350 7
d358 12
d383 17
d428 3
d446 1
a454 20
  (*  Build the set of immediate SELECT fields that are applied to a  *)
  (*  given lambda-variable.  					      *)

  fun selects_on_var (expression, record_variable) = 
   let 
    fun build (LT.SELECT (field,LT.VAR var), (fields,set)) =
				if var = record_variable
				    then (field::fields) ++ set
				else set
      | build (LT.SELECT (field,expr), (fields,set)) = 
				build(expr, (field::fields, set))
      | build (_, (_,set)) = set

    and build1 (set, expr as LT.SELECT _) = build(expr, ([],set))
      | build1 (set, _) = set
   in 
       reduce_outermost build1 (nullset, expression)
   end;


a551 1
  (* Make a load of nested function applications, like nested LET's *)
a552 9
  fun nested_apply (expression, vas) = 
      let
	  fun nest (body,(var,arg)) = LT.APP(LT.FN(var,body),arg)
      in
	  reduce_left nest (expression, rev vas)
      end;



d639 1
a640 8
 fun size_of_expr expression =
     let
	 fun add_up_size (count,_) = count+1
     in
	 reduce_outermost add_up_size (0,expression)
     end;


d644 2
d654 6
d664 1
a668 1
     
d670 76
@


1.12
log
@LETREC's are now classed as shiftable expressions,
if their resulting tuples are.  (And why not?)
@
text
@d5 4
d358 1
a358 1
      end
d377 1
d379 1
a379 2
  (*  given lambda-variable.  If the lambda-variable ever appears     *)
  (*  _unadorned_ by a select, then the bogus field ~1 is included.   *)
d383 7
a389 3
    fun build (LT.VAR lvar, fields) = if lvar = record_variable 
					  then ~1 :: fields
				      else fields
d391 2
a392 5
      | build (LT.SELECT (field,LT.VAR var), fields as _::fs) = 
					  if var = record_variable
					      then (LT.fromField field)::fs
					  else fields
      | build (_, fields) = fields
d394 1
a394 1
       Set.list_to_set(reduce_innermost build (expression,[]))
d554 1
d556 1
d558 1
d565 2
a566 1
		| _ => false)   (* assume the worst.  APP's ??! *)
d568 1
d570 1
d578 1
d580 1
d582 1
d584 1
d586 1
d599 21
d621 2
@


1.11
log
@Added function size_of_expr to count number
> sub expressions in an expression.
@
text
@d5 4
d550 1
a550 1
       | (LT.LETREC _) => false
@


1.10
log
@Reverted back to _correct_ semantics for
evaluating APP's --- evaluate function-valued
object first, then argument.  Then do
application.
@
text
@d5 6
d571 8
@


1.9
log
@forall conversion from exists improved.
@
text
@d5 3
d217 1
a217 6
	  | apply (LT.APP (p,q)) = 
	    let 
		val reduced_arg = appsub q         (* argument first! *)
	    in 
		LT.APP (appsub p, reduced_arg)
	    end
d260 1
a260 1
	      | reduce (acc,LT.APP(p,q)) = reduce_list (acc,[q,p])
@


1.8
log
@Added some more functions, fiddled with some old ones.
@
text
@d5 3
d129 1
a129 1
	 fun test [] = false
d178 1
d522 6
a527 1
     
@


1.7
log
@Changed is_expansive to is_shiftable, added unwrap_apps.
@
text
@d5 3
d401 1
a401 1
  (*  conditional constructs (i.e. SWITCH, HANDLE) this is conservative and  *)
d404 1
a404 1
  fun evaluation_sequence expression =
d414 3
d418 23
d461 2
a462 1
	  LT.FN(new_variable, apply_outermost abstract expression)
d466 1
d478 11
d496 1
a496 1
	    | getargs (func,args) = getfun (func,rev args,[])
d508 1
a508 1
			else getfun (expr', args, result@@pairs)
@


1.6
log
@Added new functions, restructured and improved existing ones.
@
text
@d5 3
d107 1
d118 12
d378 18
d436 40
d477 3
a479 5
   (*  See if an expression is expansive, in the sense that dynamic     *)
   (*  evaluation of it could have a side effect or raise an exception. *)
   (*  The notion of expansive expressions used here is stricter than   *)
   (*  that given in the Definition, in that we test some cases of APP  *)
   (*  that might be non-expansive.  	        			*)
d481 1
a481 1
 fun is_expansive non_expansive_fnvars =
d483 1
a483 1
      fun expansive_prim p = Set.is_member(p, Primitives.imperative_primitives)
d485 1
a485 1
      fun expansive_fnvar l = not(Set.is_member(l, non_expansive_fnvars))
d487 1
a487 1
      fun expansive expr =
d489 3
a491 3
	 (LT.VAR _) => false
       | (LT.FN _)  => false
       | (LT.LETREC _) => true    (* never substitute LETREC's *)
d493 1
a493 1
	     (expansive q) orelse 
d495 6
a500 6
		  (LT.VAR var) => expansive_fnvar var
		| (LT.BUILTIN prim) => expansive_prim prim
		| (LT.FN (var,body)) => expansive (substitute [(var,q)] body)
		| _ => true)   (* assume the worst.  APP's ??! *)
       | (LT.SCON _) => false
       | (LT.INT _)  => false
d506 1
a506 1
		 exists expansive lexprs
d508 5
a512 5
       | (LT.STRUCT lel) => exists expansive lel
       | (LT.SELECT (f,le)) => expansive le
       | (LT.RAISE _) => true
       | (LT.HANDLE (expr,pats)) => expansive expr
       | (LT.BUILTIN prim) => expansive_prim prim
d514 1
a514 1
      expansive
@


1.5
log
@A couple of fixes, altered form of is_expansive and added set_of_selects
@
text
@d5 3
d47 5
d53 1
d154 2
a155 4
  (*  Calculate the number of occurrences of a lambda-variable  *)
  (*  in a lambda-expression, assuming unique naming. Could     *)
  (*  be more efficient, especially when the exact number of    *)
  (*  occurrences is not needed.				*)
d157 16
a172 24
  fun lvar_occurrences lvar =
    let 
	fun count (LT.VAR lvar') = if lvar=lvar' then 1 else 0
	  | count (LT.FN (_,le)) = count le 
	  | count (LT.LETREC (_,les,le)) = reduce_left (op +) 
						(0, map count (le::les))
	  | count (LT.APP (le1,le2)) = (count le1) + (count le2)
	  | count (LT.SWITCH (le,clel,leo1,leo2)) = 
	    	let 
		    fun count_opt (LT.PRESENT lexpr) = count lexpr
		      | count_opt LT.ABSENT = 0
		in 
		    reduce_left (op +) 
		    (0, (count_opt leo1) :: (count_opt leo2) :: (count le) ::
		        (map (fn(_,x)=>count x) clel))
		end
	  | count (LT.STRUCT lel) = reduce_left (op +) (0, map count lel)
	  | count (LT.SELECT (_,le)) = count le 
	  | count (LT.RAISE le) = count le
	  | count (LT.HANDLE (le1,le2)) = (count le1) + (count le2)
	  | count _ = 0
    in 
	count 
    end;
d175 1
a175 2
  (*  Build the set of lambda-variables in an expression.        *)
  (*  Construct as a list first and then use Set.list_to_set...  *)
a176 10
  fun set_of_lvars expression = 
   let 
    fun build (lvars, LT.VAR lvar) = lvar::lvars
      | build (lvars, LT.FN (lvar,le)) = build (lvar::lvars, le)
      | build (lvars, LT.LETREC (lvs,les,le)) = build_list (lvars@@lvs, le::les)
      | build (lvars, LT.APP (le1,le2)) = build (build(lvars, le1), le2)
      | build (lvars, LT.SWITCH (le,clel,leo1,leo2)) = 
	let 
	    fun buildo (LT.PRESENT lexpr) = build([], lexpr)
	      | buildo LT.ABSENT = []
a177 54
	    val lvars' = (buildo leo1) @@ (buildo leo2) @@ lvars
	in 
	    build_list (lvars', le :: (map snd clel))
	end
      | build (lvars, LT.STRUCT lel) = build_list (lvars, lel)
      | build (lvars, LT.SELECT (_,le)) = build(lvars, le)
      | build (lvars, LT.RAISE le) = build(lvars, le)
      | build (lvars, LT.HANDLE (le1,le2)) = build (build(lvars, le1), le2)
      | build (lvars, _) = lvars

    and build_list x = reduce_left build x
   in 
       Set.list_to_set(build ([],expression))
   end;


  (*  Build the set of immediate SELECT fields that are applied to a  *)
  (*  given lambda-variable.  If the lambda-variable ever appears     *)
  (*  _unadorned_ by a select, then the bogus field ~1 is included.   *)

  fun set_of_selects (expression, record_variable) = 
   let 
    fun build (fields, LT.VAR lvar) = if lvar=record_variable 
					  then ~1 :: fields
				      else fields
      | build (fields, LT.FN (_,le)) = build (fields, le)
      | build (fields, LT.LETREC (_,les,le)) = build_list (fields, le::les)
      | build (fields, LT.APP (le1,le2)) = build (build(fields, le1), le2)
      | build (fields, LT.SWITCH (le,clel,leo1,leo2)) = 
	let 
	    fun buildo (LT.PRESENT lexpr) = build([], lexpr)
	      | buildo LT.ABSENT = []

	    val fields' = (buildo leo1) @@ (buildo leo2) @@ fields
	in 
	    build_list (fields', le :: (map snd clel))
	end
      | build (fields, LT.STRUCT lel) = build_list (fields, lel)
      | build (fields, LT.SELECT (field,LT.VAR var)) = 
					  if var = record_variable
					      then (LT.fromField field)::fields
					  else fields

      | build (fields, LT.SELECT (_, le)) = build(fields,le)
      | build (fields, LT.RAISE le) = build(fields, le)
      | build (fields, LT.HANDLE (le1,le2)) = build (build(fields, le1), le2)
      | build (fields, _) = fields

    and build_list x = reduce_left build x
   in 
       Set.list_to_set(build ([],expression))
   end;


d179 4
a182 3
  (*  sub-expressions, either innermost or outermost terms first.  *)
  (*  Innermost is AOR, outermost is like AOR but applies the      *)
  (*  function to the largest term first.                          *)
d211 1
a211 1
      fun apply_innermost_lexprs f = 
d218 1
a218 1
      fun apply_outermost_lexprs f =
d227 3
d231 48
d288 1
a288 1
	 (apply_innermost_lexprs subs) 
d290 111
@


1.4
log
@Moved some general purpose functions in from _lambda
@
text
@d5 3
d22 1
d28 4
a31 1
		  structure LambdaTypes : LAMBDATYPES) : LAMBDASUB =
d105 9
d115 6
d122 18
d145 4
a148 4
  (* Calculate the number of occurrences of a lambda-variable *)
  (* in a lambda-expression, assuming unique naming. Could    *)
  (* be more efficient, especially when the exact number of   *)
  (* occurrences is not needed.				      *)
d163 1
a163 1
		    (0, (count_opt leo1) :: (count_opt leo2) ::
d176 2
a177 2
  (* Build the set of lambda-variables in an expression.     *)
  (* Build as a list first and then use Set.list_to_set      *)
d194 4
a197 4
      | build (lvars,LT.STRUCT lel) = build_list (lvars, lel)
      | build (lvars,LT.SELECT (_,le)) = build(lvars, le)
      | build (lvars,LT.RAISE le) = build(lvars, le)
      | build (lvars,LT.HANDLE (le1,le2)) = build (build(lvars, le1), le2)
a203 1
   
d206 3
d210 12
a221 4
  (* Recursively apply a function to a lambda-expression and its *)
  (* sub-expressions, either innermost or outermost terms first. *)
  (* Innermost is AOR, outermost is like AOR but applies the     *)
  (* function to the largest term first.                         *)
d223 26
d306 5
a310 5
   (* See if an expression is expansive, in the sense that dynamic    *)
   (* evaluation of it might have a side effect or raise an exception *)
   (* The notion of expansive expressions used here is a little more  *)
   (* strict than that given in the Definition, in that we test some  *)
   (* simple cases of APP that might be non-expansive.  	      *)
d312 7
a318 2
 fun is_expansive primitives =
  let fun expansive expr =
d322 8
a329 7
       | (LT.LETREC _) => true  (* for safety; should never be eval'd *)
       | (LT.APP (p,q)) => (expansive q) orelse 
	     		   (case p of
			    (LT.BUILTIN prim) => Set.is_member(prim,primitives)
			  | (LT.FN (var,body)) => 
					 expansive (substitute [(var,q)] body)
			    | _ => true)
d339 1
a339 6
       | (LT.STRUCT lel) => 
		if (exists expansive lel)
		    then ((print ("lambdasub.is_expansive: diagnostic -"^
			   " expansive structure expression found!\n"));
			  true)   (**####**)
		else false
d343 1
a343 1
       | (LT.BUILTIN prim) => false
a347 33
  fun filter(f_list, filter_fun) = 
  let
    fun filter_sub([]) = []
    | filter_sub(h :: t) =
    if filter_fun h then h :: (filter_sub t)
    else filter_sub t
  in
    filter_sub f_list
  end

  fun filter_length(filter_list, filter_fun) =
  let fun filter_sub([], n) = n
    | filter_sub(h :: t, n) = filter_sub(t, if filter_fun h then n+1 else n)
  in
    filter_sub(filter_list, 0)
  end

  fun number_from([], i, _) = ([], i)
  | number_from(x :: xs, i, num_fun) =
    let val (rest, i') = number_from(xs, i+1, num_fun)
    in
      ((x, num_fun i) :: rest, i')
    end

  fun filter_ordered_map(a_list, []) = []
  | filter_ordered_map([], _) =
    raise(LT.impossible"member missing in filter_ordered_map")
  | filter_ordered_map((x, y)::xs, z :: zs) =
    if x = z then
      (x, y) :: (filter_ordered_map(xs, zs))
    else
      filter_ordered_map(xs, z :: zs)

@


1.3
log
@is_expansive becomes stricter...
@
text
@d5 3
d271 9
d281 6
a286 2
 end;
    
d288 17
@


1.2
log
@Added new functions set_of_lvars and is_expansive.
@
text
@d5 3
d72 1
a72 1
 (* Look-up in an association list, using Opt type from Lambdatypes *)
d85 1
d87 10
d229 3
d234 33
a266 15
     let 
	 fun expansive (LT.VAR _) = false
	   | expansive (LT.FN _) = false
	   | expansive (LT.LETREC _) = false
	   | expansive (LT.SCON _) = false
	   | expansive (LT.INT _) = false
	   | expansive (LT.SWITCH _) = true        (* conservative! *)
	   | expansive (LT.STRUCT lel) = true      (* conservative! *)
	   | expansive (LT.SELECT (f,le)) = expansive le
	   | expansive (LT.RAISE _) = true
	   | expansive (LT.HANDLE (expr,pats)) = true (* conservative! *)
	   | expansive (LT.BUILTIN prim) = false
     in
	 expansive 
     end;
@


1.1
log
@Initial revision
@
text
@d4 3
a6 1
$Log:$
d8 1
d12 1
d17 2
a18 1
functor LambdaSub(structure LambdaTypes : LAMBDATYPES) : LAMBDASUB =
d22 2
a23 1
	 
d43 6
d119 2
a120 3
  (* Recursively apply a function to the sub-expressions in a   *)
  (* lambda-expression, innermost expressions first, left-right *)
  (* within the datatype components.  				*)
d122 36
a157 1
  fun apply_innermost_lexprs f = 
d161 8
a168 3
						   map appsub lel, 
						   appsub le)
	  | apply (LT.APP (p,q)) = LT.APP (appsub p, appsub q)
d170 4
a173 4
			LT.SWITCH(appsub le, 
				 map (apsnd appsub) clel,
				 apopt appsub leo1,
				 apopt appsub leo2)
a178 2

	and appsub x = apply (f x)
d180 9
a188 2
	apply 
    end;
d190 7
d198 2
d212 21
@
