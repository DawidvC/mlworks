head	1.56;
access;
symbols
	ML_beta_release_12/08/94:1.54
	ML_beta_release_03/08/94:1.54
	ML_revised_beta_release_25/05/94:1.53
	ML_final_beta_release_02/03/94:1.53
	mlworks-28-01-1994:1.53
	Release:1.51
	mlworks-beta-01-09-1993:1.51
	MLWorks-1-0-4-29/01/1993:1.45
	MLWorks-1-0-3-21/12/1992:1.44
	MLWorks-1-0-2-15/12/1992:1.43
	MLWorks-1-0-1-04/12/1992:1.43
	checkpoint_17_08_92:1.34;
locks; strict;
comment	@ * @;


1.56
date	94.10.10.09.57.39;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	94.09.19.14.39.19;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	94.07.19.14.36.16;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	93.10.05.16.21.28;	author jont;	state Exp;
branches;
next	1.52;

1.52
date	93.08.12.09.43.03;	author nosa;	state Exp;
branches;
next	1.51;

1.51
date	93.07.12.10.16.13;	author nosa;	state Exp;
branches
	1.51.1.1;
next	1.50;

1.50
date	93.05.18.15.56.27;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	93.04.15.17.36.16;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	93.03.10.16.10.18;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	93.03.03.16.51.12;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	93.03.01.15.13.09;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	92.12.24.12.24.30;	author clive;	state Exp;
branches;
next	1.44;

1.44
date	92.12.17.17.15.27;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	92.11.09.15.09.48;	author clive;	state Exp;
branches;
next	1.42;

1.42
date	92.11.05.15.03.07;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	92.10.26.18.01.58;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	92.09.29.16.51.42;	author clive;	state Exp;
branches;
next	1.39;

1.39
date	92.09.21.12.36.04;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.09.16.10.02.45;	author clive;	state Exp;
branches;
next	1.37;

1.37
date	92.09.02.12.45.42;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	92.08.26.13.17.31;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.08.21.14.02.57;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.08.14.13.55.52;	author davidt;	state Exp;
branches;
next	1.33;

1.33
date	92.08.10.17.03.44;	author davidt;	state Exp;
branches;
next	1.32;

1.32
date	92.08.07.16.36.43;	author davidt;	state Exp;
branches;
next	1.31;

1.31
date	92.08.05.18.01.58;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.07.28.10.06.45;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.07.13.10.59.47;	author clive;	state Exp;
branches;
next	1.28;

1.28
date	92.07.09.15.29.13;	author davida;	state Exp;
branches;
next	1.27;

1.27
date	92.07.09.08.38.05;	author davida;	state Exp;
branches;
next	1.26;

1.26
date	92.07.08.16.24.39;	author davida;	state Exp;
branches;
next	1.25;

1.25
date	92.07.07.14.18.25;	author davida;	state Exp;
branches;
next	1.24;

1.24
date	92.07.06.11.21.42;	author davida;	state Exp;
branches;
next	1.23;

1.23
date	92.06.23.09.56.04;	author clive;	state Exp;
branches;
next	1.22;

1.22
date	92.06.05.12.25.19;	author clive;	state Exp;
branches;
next	1.21;

1.21
date	92.06.05.12.25.19;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.05.01.14.22.44;	author clive;	state Exp;
branches;
next	1.19;

1.19
date	92.04.30.11.29.45;	author clive;	state Exp;
branches;
next	1.18;

1.18
date	92.04.28.15.13.26;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.04.13.16.55.32;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.03.16.17.42.57;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.03.06.11.52.58;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.02.18.15.55.05;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	92.02.17.15.08.10;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.02.03.10.52.12;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.01.31.09.15.17;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.01.30.16.35.35;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.01.28.16.57.38;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	91.10.23.12.55.01;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	91.10.22.18.19.06;	author davidt;	state Exp;
branches;
next	1.6;

1.6
date	91.10.22.14.13.24;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	91.10.09.15.11.10;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	91.09.25.14.03.08;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.09.11.15.59.56;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.09.10.14.01.17;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.09.15.48.23;	author davida;	state Exp;
branches;
next	;

1.51.1.1
date	93.07.12.10.16.13;	author jont;	state Exp;
branches;
next	;


desc
@Common-subexpression elimination
@


1.56
log
@Lambdatypes changes
@
text
@(* _optimise_cse.sml the functor *)
(*
 * Lambda-Calculus Optimisation: _optimise_cse
 * Common-subexpression Elimination
 *
 * Copyright (c) 1991 Harlequin Ltd.
 *
$Log: _optimise_cse.sml,v $
Revision 1.55  1994/09/19  14:39:19  matthew
Abstraction of debug information in lambdatypes

Revision 1.54  1994/07/19  14:36:16  matthew
Functions and applications take a list of parameters

Revision 1.53  1993/10/05  16:21:28  jont
Improved h function to remove some calls to **

Revision 1.52  1993/08/12  09:43:03  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.51  1993/07/12  10:16:13  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.50  1993/05/18  15:56:27  jont
Removed integer parameter

Revision 1.49  1993/04/15  17:36:16  jont
Some minor mods to improve timings slightly

Revision 1.48  1993/03/10  16:10:18  matthew
Signature revisions

Revision 1.47  1993/03/03  16:51:12  jont
Various changes in locate and deal_with to improve speed, mainly by avoiding
unnecessary calls, and avoiding making function calls only to return a known
result following a simple equality test

Revision 1.46  1993/03/01  15:13:09  matthew
Added MLVALUE lambda exp

Revision 1.45  1992/12/24  12:24:30  clive
Stopped optimising switch info inconsistently

Revision 1.44  1992/12/17  17:15:27  matthew
Changed int and real scons to carry a location around

Revision 1.43  1992/11/09  15:09:48  clive
Added some LETREC optimisation

Revision 1.42  1992/11/05  15:03:07  jont
Reworked quick_multiply' to test the low cases first. Should be quicker

Revision 1.41  1992/10/26  18:01:58  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.40  1992/09/29  16:51:42  clive
Switched off result info details

Revision 1.39  1992/09/21  12:36:04  clive
Changed hashtables to a single structure implementation

Revision 1.38  1992/09/16  10:02:45  clive
Got rid of handles involving hash tables

Revision 1.37  1992/09/02  12:45:42  jont
Removed the uses of Lists.zip

Revision 1.36  1992/08/26  13:17:31  jont
Removed some redundant structures and sharing

Revision 1.35  1992/08/21  14:02:57  clive
Tried to optimise the multiplies into shifts and adds

Revision 1.34  1992/08/14  13:55:52  davidt
Changed ord(substring ...) to ordof.

Revision 1.33  1992/08/10  17:03:44  davidt
Changed MLworks to MLWorks.

Revision 1.32  1992/08/07  16:36:43  davidt
String structure is now pervasive, changed code to
use MLworks structure instead of NewJersey structure.

Revision 1.31  1992/08/05  18:01:58  jont
Removed some structures and sharing

Revision 1.30  1992/07/28  10:06:45  clive
Modified to use the new hashtables

Revision 1.29  1992/07/13  10:59:47  clive
Switched off time printouts

Revision 1.28  1992/07/09  15:29:13  davida
Reverted to checking is_in_evaluation_set before
lifting: without doing this we lift invalid selects
across switches!

Revision 1.27  1992/07/09  08:38:05  davida
Removed spurious control character from the
end of the file  (don't know how it got there!?)

Revision 1.26  1992/07/08  16:24:39  davida
Minor changes, new flag for printing results.

Revision 1.25  1992/07/07  14:18:25  davida
Removed some of the debugging tests and printing.

Revision 1.24  1992/07/06  11:21:42  davida
Added LET constructor and new slot to APP.
Attempted fix of scope-escape problem -
still needs work.

Revision 1.23  1992/06/23  09:56:04  clive
Added an annotation slot to HANDLE

Revision 1.22  1992/06/05  12:25:19  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.21  1992/06/05  12:25:19  clive
A few speed improvements including specialising the hash equality function

Revision 1.20  1992/05/01  14:22:44  clive
Print out more useful information on bucket overflow

Revision 1.19  1992/04/30  11:29:45  clive
Added a measure of size to the hash function to help with some awkward cases JonT came up with

Revision 1.18  1992/04/28  15:13:26  clive
Another factor of 3 improvement due to making the substitution by demand rather than eager -
locate walks the tree and does the substitution when it hits something that need expanding

Revision 1.17  1992/04/13  16:55:32  clive
First version of the profiler

Revision 1.16  1992/03/16  17:42:57  jont
Removed pervasive print. Added Integer parameter to functor

Revision 1.15  1992/03/06  11:52:58  jont
Fixed problem whereby bindings could get duplicated by renaming
entire expression using new rename_fresh from lambdasub

Revision 1.14  1992/02/18  15:55:05  jont
Fixed bug whereby common subexprs were being lifted outside LETRECs
defining some of their free variables

Revision 1.13  1992/02/17  15:08:10  jont
Fixed bugs in cse whereby expression tags were being ignored,
and functions were becoming alpha-convertible when LETRECs weren't
abstacted

Revision 1.12  1992/02/03  10:52:12  clive
Used the zip from the Lists module instead of my own

Revision 1.11  1992/01/31  09:15:17  clive
Took out check that the top level form after varification is a variable - this is not
true in the case of a signature definition

Revision 1.10  1992/01/30  16:35:35  clive
Optimised the original functional form of this code, which carried out
a lot of recomputation - considered every function call and tried to
implement it using something that had been computed before
  (1) used a hash table instead of the original table - things were added
 to the table incrementally so that it basically simulated an association list
  (2) instead of calling a function to calculate occurrences, a used a table to
compute them incrementally
  (3) expand_subexpr (to expand expressions) was called unnecessarily and used
apply_outermost instead of apply_innermost plus previously calculated values
stored in a hash table
  (4) added ReverseLambdaHashTable to calculate the inverses to the LambdaHashTable
  (5) optimised the substitutions of many small expressions into a large one, by batching
them together, and applying the small expressions to each other before doing one
substitution into the large expression
  (6) used is_in_evaluation_set (a predicate) instead of the function and a membership test

Revision 1.9  1992/01/28  16:57:38  clive
Reduced the run time of the optimiser by 50% by
 (1) Hashing the varcount_table
 (2) Using the occurrence counts (defined but not used in the existing code), to
     allow us to omit some calls to LS.occurrences

Revision 1.8  1991/10/23  12:55:01  davidt
Fixed bug where structures which are arguments to builtins are
considered as possible subexpressions for lifting. This is a
bad idea because we never really build a structure when we
are applying a builtin but if we put the structure in a let
then we do build a structure!

Revision 1.7  91/10/22  18:19:06  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.6  91/10/22  14:13:24  davidt
Took out imposs function and exception impossible.

Revision 1.5  91/10/09  15:11:10  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.

Revision 1.4  91/09/25  14:03:08  davida
Removed a misleading comment.

Revision 1.3  91/09/11  15:59:56  davida
No changes

Revision 1.2  91/09/10  14:01:17  davida
Changed substitute calls for it's new type.

Revision 1.1  91/09/09  15:48:23  davida
Initial revision
*)

(* 
   In order to speed this module up, first by a factor of 70 and then by a factor of 6-7, a number
   of hash table are now used - the way this works is to walk up the tree starting at the roots
   using the function varify to notice common sub-expressions, and then forms the result expression
   using unvarify. The hash tables can accumulate the results of functions that used to be repeatedly
   called - the classic example being the function to return the number of occurrences of a variable
   in the tree, after we have just walked the tree.
*)
require "../utils/lists";
require "../utils/crash";
require "../utils/print";
require "../utils/timer";
require "lambdaprint";
require "lambdasub";
require "optimise_lib";
require "optimise_cse";

functor OptimiseCSE(
  val hash_function_depth : int
  val maximum_bucket_size : int
  structure Timer : TIMER
  structure Lists : LISTS
  structure Crash : CRASH
  structure Print : PRINT
  structure LambdaPrint : LAMBDAPRINT
  structure Lib   : OPTIMISE_LIB
  structure LS : LAMBDASUB
  sharing LS.LT = LambdaPrint.LambdaTypes
  sharing type LS.LT.LVar = int
  sharing Lib.Set = LS.LT.Set
  ) : OPTIMISE_CSE =
struct
  structure LambdaTypes = LambdaPrint.LambdaTypes
  structure LT = LambdaTypes
  structure NewHashTable = LT.NewHashTable
  structure Ident = LT.Ident
  open Lib

  fun fst(x,y) = x  and snd(x,y) = y  (* instead of ones from Lib *)
  infix mem == ++ --

  val show_debug_info = ref false;
  fun info message =
    if !show_debug_info then
      (Print.print (message());
       Print.print"\n")
    else ()
  val show_result_info = ref false;

  val print_hash_table_stats = LS.print_hash_table_stats

  fun hash_info message =
    if !print_hash_table_stats then
      (Print.print message;
       Print.print"\n")
    else ()

  (**************************************)
  (*  Common-Subexpression Elimination  *)
  (**************************************)
  
  (* table mapping variables to subexpressions *)

  val cse_marker = ref (LT.new_LVar())
  val found_a_variable_more_than_once = ref(false)

  val tried_to_locate = ref(0)
  val succeeded_in_locate = ref(0)

  fun represents_cse var = LT.LVar_order(!cse_marker,var)


  (* construct a hashtable for hashing on subexpressions *)
  val the_var_count_hash_table = ref(NewHashTable.new(2000,op = : int * int -> bool, fn x => x) 
                                     : (LT.LVar,LT.LambdaExp * int) NewHashTable.HashTable)
  
  (*  Hash function - must hash alpha-convertible terms to  *)
  (*  the same place, yet we'd like free variables to be    *)
  (*  distinguished...  unless of course they represent     *)
  (*  replaced expressions.				 *)
  local
    open LT
    infix isin
    fun a isin ([],n) = ~1
      | a isin (b::bs,n) = 
	if a = b then n
	else (a isin (bs,n+1))
            
    fun ug a = MLWorks.Bits.andb(a,1048575) + 1

    (* Quickly multiply where the first is an integer < 128 *)
    (* really need unsafe addition to be used *)
    fun **(x,y) =
      let
	fun quick_multiply'(0,acc) = acc 
	  | quick_multiply'(1,acc) = acc + y
	  | quick_multiply'(2,acc) = acc + MLWorks.Bits.lshift(y,1)
	  | quick_multiply'(3,acc) = acc + y + MLWorks.Bits.lshift(y,1)
	  | quick_multiply'(x,acc) =
	    if x < 8 then
	      quick_multiply'(MLWorks.Bits.andb(x, 3),
			      acc + MLWorks.Bits.lshift(y, 2))
	    else
	      if x < 16 then
		quick_multiply'(MLWorks.Bits.andb(x, 7),
				acc + MLWorks.Bits.lshift(y, 3))
	      else
		if x < 32 then
		  quick_multiply'(MLWorks.Bits.andb(x, 15),
				  acc + MLWorks.Bits.lshift(y, 4))
		else
		  if x < 64 then
		    quick_multiply'(MLWorks.Bits.andb(x, 31),
				    acc + MLWorks.Bits.lshift(y, 5))
		  else
		    quick_multiply'(MLWorks.Bits.andb(x, 63),
				    acc + MLWorks.Bits.lshift(y, 6))
      in
	quick_multiply'(x,0)
      end

      infix 7 **
        
      fun h (0,_,_) = 1
        | h (_,bvs, SCON (Ident.STRING st)) = 
          (case st of
	     "" => 2
	   | _ => 2 ** String.ordof(st,size(st) div 2))
	| h (_,bvs,SCON (Ident.INT(st,_))) =
          let
            fun convert(0,acc) = acc
              | convert(n,acc) = convert(n-1, ug(10 ** acc + String.ordof(st,n-1) - 48))
          in
            convert(size st,0)
          end
        | h (_,bvs,SCON _) = 2
        | h (_,bvs, INT x)  =
(*
	  ug(3 ** x)
*)
	  ug(MLWorks.Bits.lshift(x, 1) + x)
        | h (_,bvs, BUILTIN _) = 5
        | h (depth,bvs, VAR v)  =
          let
            val count = (v isin (bvs,0))
          in
            if  count>=0
              then 7 ** count
            else 
              if represents_cse v
                then 
                  let
                    val looked_up = 
                      NewHashTable.lookup(!the_var_count_hash_table,v)
                  in
                    h (depth-1,bvs, fst(looked_up))
                  end
              else ug(11 ** (int_of_LVar v))
          end
        | h (depth,bvs, LET ((bv,info,b),e)) = 
          let
	    val depth' = depth-1
	    val h1 = h (depth',bv::bvs,e)
	    val h2 = h (depth',bvs,b)
          in
(*
            ug (13 ** h (depth-1,bv::bvs,e) + 15 ** h (depth-1,bv::bvs,b))
*)
	    ug(13 ** (h1+h2) + MLWorks.Bits.lshift(h2, 1))
          end
        | h (depth,bvs, FN ([bv],e,_,_,_)) = ug(13 ** (h (depth-1,bv::bvs, e)))
        | h (depth,bvs, FN (bvl,e,_,_,_)) = Crash.impossible "Varlist in h"
        | h (depth,bvs, APP (e1,[e2],_)) = 
	  let
	    val depth' = depth-1
	    val h1 = h(depth',bvs,e1)
	    val h2 = h(depth',bvs,e2)
	  in
	    ug(15 ** (h1+h2) + MLWorks.Bits.lshift(h2, 1))
	  end
(*
          ug (15 ** h(depth-1,bvs,e1) + 17 ** h(depth-1,bvs,e2)) 
*)
        | h (depth,bvs, APP (e1,e2,_)) = Crash.impossible "Arglist in h"
        | h (depth,bvs, SWITCH(e,_,cases,a)) = 
          let
	    val depth' = depth-1
            val first = case a of
              LT.Option.ABSENT => 0
            | LT.Option.PRESENT x => h(depth',bvs,x)

            val second = case cases of
              ((_,e1)::_) => h(depth',bvs,e1)
            | _ => 0

            val third = case cases of
              ((_,_)::(_,e2)::_) => h(depth',bvs,e2)
            | _ => 0
          in
            ug(21 ** first + ug(23 ** second + ug (19 ** third)))
          end
        | h (depth,bvs, STRUCT ([e],_)) = ug(23 ** h (depth-1,bvs,e))
        | h (depth,bvs, STRUCT (e1::e2::_,_)) =
	  let
	    val depth' = depth-1
	    val h1 = h (depth',bvs,e1)
	    val h2 = h (depth',bvs,e2)
	  in
	    ug(29 ** (h1+h2) + MLWorks.Bits.lshift(h2, 1))
	  end
(*
          ug(29 ** h (depth-1,bvs,e1)+ 31 ** h (depth-1,bvs,e2))
*)
        | h (depth,bvs, SELECT ({index,size,...},e)) =
	  let
	    val h1 = h(depth-1,bvs,e)
	  in
	    ug(37 + 41 ** (index + h1) + MLWorks.Bits.lshift(h1, 1))
	  end
(*
          ug(37 + 41 ** index + 43 ** h(depth-1,bvs,e))
*)
        | h (depth,bvs, RAISE (e)) = ug(47 ** h(depth-1,bvs,e))
        | h (depth,bvs, HANDLE (e1,_,_)) = ug(53 ** h(depth-1,bvs,e1))
        | h (depth,bvs, LETREC ([bv],[e],_)) = ug(59 ** h(depth-1,#1 bv::bvs,e))
        | h (depth,bvs, LETREC (bvs',e1::e2::_,_)) =
          let 
            val bvs' = map #1 bvs'
	    val bvs'' = bvs' @@ bvs
	    val depth' = depth-1
	    val h1 = h(depth',bvs'',e1)
	    val h2 = h(depth',bvs'',e2)
          in
	    ug(61 ** (h1+h2) + MLWorks.Bits.lshift(MLWorks.Bits.lshift(h2, 1) + h2, 1))
(*
            ug(61 ** h(depth-1,bvs' @@bvs,e1) + 67 ** h(depth-1,bvs' @@bvs,e2))
*)
          end
        | h _ = 1
          
  in
    fun hash (x,sz) = ug(h (hash_function_depth,[],x) + 71 ** sz)

  end

  fun eq((x,size:int),(y,size')) = size=size' andalso LS.alpha_convertible (x, y)

(* letrec stuff *)

  fun is_ok_letrec(LT.LETREC(_, _, le)) =
    (case le of
       LT.VAR _ => true
     | LT.LETREC _ => is_ok_letrec le
     | LT.STRUCT (le_list,_) =>
	 Lists.forall
	 (fn (LT.VAR _) => true
             | x => is_ok_letrec x)
	 le_list
       | _ => false)
    | is_ok_letrec _ = false

  fun transform_letrecs(le as LT.LETREC(lv_list, le_list, le')) =
    if is_ok_letrec le then LS.apply_one_level transform_letrecs le
    else
      let
        val lv_list'' = map #1 lv_list
	val new_lv = LT.new_LVar()
	val (one_lv, the_lv) = case lv_list'' of
	  			[lv] => (true, lv)
			      | _ => (false, new_lv)
        fun filter_for_used_variables [] = []
          | filter_for_used_variables(h::t) =
            if LS.occurs(h,le')
              then h::filter_for_used_variables t
            else filter_for_used_variables t
        val lv_list' = filter_for_used_variables lv_list''
	val lv_assoc = if one_lv 
			 then [(the_lv,new_lv)]
		       else
			 map (fn x => (x, LT.new_LVar())) lv_list'
	val var_new_lv = LT.VAR new_lv
	(* For the LETREC itself *)
	val le' =
	  transform_letrecs(LS.substitute_list(lv_assoc, le'))
	val le'' =
	  if one_lv then
	    LT.VAR the_lv
	  else
            case lv_list' of
              [x] => LT.VAR x
            | _ => LT.STRUCT(map LT.VAR lv_list',LT.TUPLE)
	val le_list = map transform_letrecs le_list
	val new_letrec = LT.LETREC(lv_list, le_list, le'')
	val len = Lists.length lv_list'
	val bindings =
	  if one_lv then []
	  else
            case lv_assoc of
              [(_,y)] => [(y,var_new_lv)]
            | _ => 
                #1 (Lists.number_from_by_one
                    (map #2 lv_assoc, 0,
                     fn x => LT.SELECT({index=x, size=len,selecttype=LT.TUPLE}, var_new_lv)))
      in
	LS.wrap_lets(le', (new_lv, new_letrec) :: bindings)
      end
    | transform_letrecs le = LS.apply_one_level transform_letrecs le
      


(* heuristic for safe lifting *)

(* NB!! Must be careful not to lift selects out of *)
(* switch statements that test whether the select  *)
(* is applicable or not.			   *)

  fun cheap_to_evaluate (LT.APP _) = false
    | cheap_to_evaluate (LT.VAR _) = true
    | cheap_to_evaluate (LT.FN _) = true   (* always lift fn's *)
    | cheap_to_evaluate expr = is_ok_letrec expr

  fun will_be_evaluated (expr,inexpr) =
    LS.is_in_evaluation_set expr inexpr

   (* Make a list of all of the marking variables in an expression *)

  fun find_all_marking_variables_in_expression(expression) =
    let
      fun test(expr as LT.VAR x,l) =
	if represents_cse(x)
	  then x::l
	else l
      | test (expr,l) = l
    in
      LS.reduce_innermost test (expression,[])
    end 

  fun eliminate_common_subexprs (LT.Info{is_shiftable,...}) expression =
    let

      val lambdahashtable = NewHashTable.new(2000,eq,hash)
      val varcounthashtable = NewHashTable.new(2000,op = : int * int -> bool, fn x => x)
      val _ = the_var_count_hash_table := varcounthashtable
      val occcounthashtable = NewHashTable.new(2000,op = : int * int -> bool,fn x => x)
      val blocksubsthashtable = NewHashTable.new(2000,op = : int * int -> bool, fn x => x)
      val reverselambdahashtable = NewHashTable.new(2000, op = : int * int -> bool,fn x => x)
      val _ = tried_to_locate := 0;
      val _ = succeeded_in_locate := 0
      val _ = found_a_variable_more_than_once := false
      
      val count = ref 0

      fun expand_subexprs key =
	let
	  val _ = count := 0

	  fun expand (expr as LT.VAR v) =
	    if represents_cse v then 
	      let
		val (code,size) = NewHashTable.lookup(reverselambdahashtable,v)
	      in
		(count := !count + size ; code)
	      end
	    else (count := !count + 1 ; expr)
	    | expand expr = (count := !count + 1 ; expr)
                
	  val result = LS.apply_innermost expand key
              
	in
	  (result,!count)
	end

      fun adjust_occurrence_counts(expr_count,expr) =
	let
	  val occlist = find_all_marking_variables_in_expression(expr)
	in
	  Lists.iterate
	  (fn x =>
	   let
	     val current = 
	       NewHashTable.lookup_default(occcounthashtable,0,x)
	   in
	     NewHashTable.update(occcounthashtable,x,current + expr_count)
	   end)
	  occlist
	end

      fun deal_with_block(base,to_be_substituted,expr) =
	if LT.LVar_order(base,to_be_substituted) then 
	  let
	    fun update(expr as LT.VAR v) =
	      if LT.LVar_order(base,v) then
		NewHashTable.lookup(blocksubsthashtable,v) 
	      else expr
	      | update expr = expr

	    fun update_hash_table count =
	      if LT.LVar_order(to_be_substituted,count)
		then ()
	      else
		(NewHashTable.update
		 (blocksubsthashtable,
		  count, LS.apply_innermost update (fst(NewHashTable.lookup(varcounthashtable,count))));
		 update_hash_table(LT.LVar_next count))
                    
	  in 
	    (info(fn () => ("Deal with a block from " ^ 
			    LT.printLVar (base) ^
			    " upto " ^ LT.printLVar to_be_substituted)) ;
	     update_hash_table (LT.LVar_next base);
	     expr)
	  end
	else expr

            
      fun get_var key =
	let
	  val expanded as (full_expr,size_of_full_expr) = expand_subexprs key
	in
	  case NewHashTable.tryLookup(lambdahashtable,expanded) of 
	    NewHashTable.YES var => 
	      let
		val (expr,count) = NewHashTable.lookup(varcounthashtable,var)
		val _ = 
		  NewHashTable.update(varcounthashtable,var,(expr,count+1))
		val _ = found_a_variable_more_than_once := true
	      in
		LT.VAR var
	      end
	  | NewHashTable.NO  => 
	      let
		val newvar = LT.new_LVar()
	      in
		NewHashTable.update (lambdahashtable,expanded,newvar);
		NewHashTable.update(reverselambdahashtable,newvar,expanded);
		NewHashTable.update(varcounthashtable,newvar,(key,0));
		LT.VAR newvar
	      end
	end

      fun print_stats () = 
	(output(std_out,"LambdaHashTable" ^ 
		NewHashTable.string_hash_table_stats(lambdahashtable) ^ "\n");
	 output(std_out,"ReverseLambdaHashTable" ^ 
		NewHashTable.string_hash_table_stats(reverselambdahashtable) ^ "\n");
	 output(std_out,"OccCountHashTable" ^ 
		NewHashTable.string_hash_table_stats(occcounthashtable) ^ "\n");
	 output(std_out,"BlockSubstHashTable" ^ 
		NewHashTable.string_hash_table_stats(blocksubsthashtable) ^ "\n"))

      (*  Convert sub-expressions into lambda-variables. *)
              
      fun varify context_opt lambda_exp =
	case lambda_exp of
	  LT.VAR _ => lambda_exp
	| LT.FN _ => get_var lambda_exp
	| LT.LET _ => get_var lambda_exp
	| LT.LETREC _ => get_var lambda_exp
	| LT.APP _ => get_var lambda_exp
	| LT.SCON _ => lambda_exp
	| LT.MLVALUE _ => lambda_exp
	| LT.INT _ => lambda_exp
	| LT.SWITCH _ => get_var lambda_exp
	| LT.STRUCT ([],_) => lambda_exp
	| LT.STRUCT _ => 
	    (case context_opt of
	       LT.Option.PRESENT(LT.APP(LT.BUILTIN _,_,_)) => lambda_exp
	     | _ => get_var lambda_exp)
	| LT.SELECT _ => get_var lambda_exp
	| LT.RAISE _ => get_var lambda_exp
	| LT.HANDLE _ => get_var lambda_exp
	| LT.BUILTIN _ => lambda_exp

      fun add_up([],x:int) = x
	| add_up((_, h)::t,x) = add_up(t,h+x)

      fun remove_var ([], _) = []
	| remove_var (arg as (x :: xs), var) =
	  if LT.LVar_order(var, x) then arg
	  else
	    if x = var then xs
	    else x :: remove_var(xs, var)

      fun remove_ordered_var_list([], _) = []
	| remove_ordered_var_list(varlist, []) = varlist
	| remove_ordered_var_list(varlist as (v :: vs), remlist as (r :: rs)) =
	  if LT.LVar_order(r, v) then
	    remove_ordered_var_list(varlist, rs)
	  else
	    if r = v then
	      remove_ordered_var_list(vs, rs)
	    else
	      v :: remove_ordered_var_list(vs, remlist)

      fun remove_var_list(varlist, remlist) =
	remove_ordered_var_list(varlist, Lists.qsort LT.LVar_order remlist)

      fun make_exp_tag(tag, _) = LT.EXP_TAG tag

      fun check([], _) = false
	| check(x::xs, frees) = Lists.member(x,frees) orelse check(xs, frees)

      fun bad_abstr _ = "Abstracting would violate scope\n"

      exception BombOut

      fun elim_subexprs expression =
	let
	  val _ = info (fn () => "Converting sub-expressions to lambda-variables...");
	  val _ = info (fn () => ("Lowest value for a marker variable is " ^ 
				  MLWorks.Integer.makestring(LT.int_of_LVar (! cse_marker))))
              
	  (*  Common expressions are put into a LET enclosing the      *)
	  (*  smallest possible lambda-expression.  An alternative     *)
	  (*  would be to put them as far out as possible, cf selects  *)

	  fun unvarify expr1 =
	    let
	      val _ = info (fn () => "Abstracting out CSE's")

	      (* Expression is now represented by a single variable *)
	      val _ =
		case expr1 of
		  LT.VAR x => (NewHashTable.update(occcounthashtable,x,1))
		| _ => ()

	      fun abs_smallest (expr2, (var,subexpr),to_be_substituted) =
		let
		  val occns = 
		    NewHashTable.lookup_default(occcounthashtable,0,var) 
		in
		  if occns>1 then 
		    let
		      val expr2 =
			deal_with_block(var,to_be_substituted,expr2)  
		      val real_expr = #1 (NewHashTable.lookup (reverselambdahashtable,var))
(* validity of lifting: all free variables in the lifted expression must *)
(* either be CSE variables yet to be considered, or bound above the      *)
(* lifting point. *)
		      val frees = #2 (LS.bounds_and_frees real_expr)

		      val non_cse_frees = Lists.qsort LT.LVar_order (Set.set_to_list frees)

		      val cheap = cheap_to_evaluate real_expr

		      val occns' = occns+1

		    in
		      if (info(fn () =>  ("subexpr appears more than once: v"^
					  (LT.printLVar var) ^ "\n" ^
					  LambdaPrint.string_of_lambda subexpr));
			  is_shiftable real_expr) then
			(* locate smallest sub-expression  *)
			(* containing all instances of var *)
			let

			  fun deal_with inexpr =
			    if cheap orelse
			      (will_be_evaluated (LT.VAR var,inexpr)) then
			      (info(fn () =>  ("abstracting for v"^
					       (LT.printLVar var)));
			       adjust_occurrence_counts(1,subexpr);
			       let
				 val new_code =
				   LT.LET((var,LT.Option.ABSENT,subexpr),inexpr) 
			       in
				 (new_code, occns')
			       end)
			    else
			      raise BombOut

			  fun locate (le as LT.VAR v,frees) = 
			    (
			     if LT.LVar_order(var,v) then
			      case NewHashTable.tryLookup(blocksubsthashtable,v) of
				NewHashTable.YES res => locate(res,frees)
			      | NewHashTable.NO => (le, 0)
			     (* deal_with effectively inlined here *)
			    else
			      (le, if v=var then 1 else 0)
			      (* deal_with effectively inlined here *)
)
			    | locate (LT.FN([lv], le,name,ty,instance),frees) =
			      let 
				val (body,count) = locate (le,remove_var (frees,lv))
				val inexpr = LT.FN([lv],body,name,ty,instance)
			      in
				if count = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, count)
			      end
			    | locate (LT.FN(lvl, le,name,ty,instance),frees) =
                              Crash.impossible "Varlist in locate"
			    | locate (LT.LET((lv,debug_info,lb),le),frees) = 
			      let
				val frees' = remove_var(frees, lv)
				val (lb',count) = locate (lb,frees')
				val (le',count') = locate (le,frees')
				val inexpr = LT.LET((lv,debug_info,lb'),le')
				val num = count+count'
			      in
				if num = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, num)
                              end
			    | locate (LT.LETREC(lvl, lel, le),frees) =
			      let 
                                val lvl' = map #1 lvl
				val checked = check(lvl', frees)
				val frees' =
				  if checked then
				    remove_var_list(frees, lvl')
				  else frees
				val loc_vals = map (fn le=>locate(le,frees')) lel
				val (body,count) = locate (le,frees')
				val new_count = add_up(loc_vals, count)
			      in
				if new_count=occns then
				  if checked then
				    (* can't lift out a letrec binding *)
				    raise BombOut
				  else
				    case frees of
				      [] => deal_with(LT.LETREC(lvl,map #1 loc_vals,body))
				    | _ => (info bad_abstr;
					    raise BombOut)
				else
				  (LT.LETREC(lvl,map #1 loc_vals,body), new_count)
			      end
			    | locate (LT.APP(p, [q], ty),frees) =
			      let
				val (body,count) = locate (p,frees)
				val (body',count') = locate (q,frees)
				val inexpr = LT.APP(body,[body'],ty)
				val num = count + count'
			      in
				if num = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, num)
			      end
			    | locate (LT.APP(p, q, ty),frees) =
                              Crash.impossible "Arglist in locate"

			    | locate (le as LT.SCON _,frees) = 
			      (
			      (le, 0)
)
			    | locate (le as LT.MLVALUE _,frees) = 
			      (le, 0)

			    | locate (le as LT.INT _,frees) = 
			      (
			       (le, 0)
)
			    | locate (context as LT.SWITCH(le, info', clel, leo),frees) = 
			      let
				val (body, count) = locate (le,frees)
				val (tags, counts') = case clel of
				  (LT.EXP_TAG _, _) :: _ =>
				    let
				      val tags_counts =
					map
					(fn (LT.EXP_TAG le, _) => locate(le, frees)
				      | _ => Crash.impossible"Mixed tag type")
					clel
				    in
				      (map make_exp_tag tags_counts,
				       add_up(tags_counts, 0))
				    end
				| _ => (map #1 clel, 0)
				val (body',count') =
				  (case leo of
				     LT.Option.PRESENT f =>
				       let
					 val (a,b) = locate (f,frees)
				       in
					 (LT.Option.PRESENT a,b)
				       end
				   | LT.Option.ABSENT => (LT.Option.ABSENT,0))
				val bodies_counts =
				  (map (fn (_, le) => locate(le,frees))
				   clel)
				val inexpr = LT.SWITCH
				  (body,
				   info',
				   Lists.zip(tags,map #1 bodies_counts),
				   body')
				val num = add_up(bodies_counts, count + count' + counts')
			      in
				if num = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, num)
			      end

			    | locate (LT.STRUCT (lel,ty),frees) =
			      let
				val bodies_counts =
				  (map (fn le=>locate(le,frees)) lel)
				val count = add_up(bodies_counts, 0)
			      in
				if count = occns then
				  case frees of
				    [] => deal_with(LT.STRUCT(map #1 bodies_counts,ty))
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (LT.STRUCT(map #1 bodies_counts,ty), count)
			      end

			    | locate (context as LT.SELECT (fld, le),frees) =
			      let
				val (body,count) = locate (le,frees)
				val inexpr = LT.SELECT(fld, body)
			      in
				if count = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, count)
			      end

			    | locate (context as LT.RAISE (le),frees) =
			      let
				val (body,count) = locate (le,frees)
				val inexpr = LT.RAISE (body)
			      in
				if count = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, count)
			      end

			    | locate (LT.HANDLE (le1, le2,annotation),frees) =
			      let
				val (body,count) = locate (le1,frees)
				val (body',count') = locate (le2,frees)
				val inexpr = LT.HANDLE(body,body',annotation)
				val num = count + count'
			      in
				if num = occns then
				  case frees of
				    [] => deal_with inexpr
				  | _ => (info bad_abstr;
					  raise BombOut)
				else
				  (inexpr, num)
			      end

			    | locate (le as LT.BUILTIN _,frees) = 
			      (le, 0)

			in
			  (let
			     val _ = tried_to_locate := !tried_to_locate + 1;
			     val (res, count) = locate (expr2,non_cse_frees)
			     val _ =
			       if count <> occns' then
				 Crash.impossible
				 ("Failed to locate all occurrences of " ^
				  LT.printLVar var)
			       else
				 ()
			     val _ = succeeded_in_locate := !succeeded_in_locate + 1
			   in
			     info (fn () => (Print.print "after abstract:\n";
					     (*	LambdaPrint.print_lambda res; *)
					     "Size is now " ^
					     MLWorks.Integer.makestring(LS.size_of_expr res)));
			     (res,LT.LVar_previous var)
			   end)
			     handle BombOut => 
			       (adjust_occurrence_counts(occns,subexpr) ;
				(expr2,var))  (* (LS.substitute(var,subexpr,expr2),LT.LVar_previous var))  *)
			end

		      else
			(adjust_occurrence_counts(occns,subexpr) ;
			 (* NB:- when expanding later, duplication might occur *)
			 (* debug code... *)
			 case subexpr of
			   LT.LETREC _ => Print.print
			     "Warning: possible bad substitution for LETREC\n"
			 | _ => ();

			     (expr2,var))
		    end

		  else (adjust_occurrence_counts(occns,subexpr);
			(expr2,to_be_substituted))
		end
		  
              (* The lambda variables that we have introduced *)
              (* had better be contiguous *)
              val highest = LT.new_LVar()
	      val lowest = !cse_marker

	      fun loop_through (count,(expr,to_be_substituted)) =
		if LT.LVar_order(lowest,count) then
		  let
		    val (expr',count') = NewHashTable.lookup(varcounthashtable,count)
		    val arg = (count,expr')
		  in
		    loop_through(LT.LVar_previous count,abs_smallest(expr,arg,to_be_substituted))
		  end
		else 
		  (deal_with_block(count,to_be_substituted,expr);
		   LS.apply_outermost
		   (fn (le as (LT.VAR v)) =>
		    if LT.LVar_order(count,v) then
		      NewHashTable.lookup_default(blocksubsthashtable,le,v)
		    else
		      le
		    | expr => expr)
		   expr)
                       
	      val prev_highest = LT.LVar_previous highest

	      val absd_exp = 
		loop_through (prev_highest,(expr1,prev_highest))

	      val _ =
		if !print_hash_table_stats
		  then print_stats()   (* #### to see stats *)
		else ()
	    in
	      absd_exp
	    end
	in
	  let
	    val exp = if !show_debug_info
			then Timer.time_it("Varifying", 
					   fn () => (LS.apply_innermost_with_context varify expression))
		      else LS.apply_innermost_with_context varify expression
	  in
	    if !found_a_variable_more_than_once then
	      (true,if !show_debug_info
		      then Timer.time_it("Unvarifying",fn () => unvarify (exp))
		    else unvarify exp)
	    else
	      (false,exp)
	  end
	end

    in
      let
	val transformed = transform_letrecs expression
	val _ = cse_marker := LT.new_LVar()
	val (modified,result) = elim_subexprs transformed
	val _ = if !show_result_info andalso !tried_to_locate > 0
		  then output(std_out,
			      "Tried to abstract in " ^ MLWorks.Integer.makestring(! tried_to_locate) ^
			      " cases with success in " ^ MLWorks.Integer.makestring(! succeeded_in_locate) ^
			      "\n")
		else ()
      in
	if modified then 
	  LS.rename_fresh result
	else transformed
      end
    end
end
@


1.55
log
@Abstraction of debug information in lambdatypes
@
text
@d9 3
d373 1
a373 1
        | h (depth,bvs, LET (bv,info,b,e)) = 
d415 2
a416 2
        | h (depth,bvs, STRUCT [e]) = ug(23 ** h (depth-1,bvs,e))
        | h (depth,bvs, STRUCT (e1::e2::_)) =
d427 1
a427 1
        | h (depth,bvs, SELECT ({index,size},e)) =
d467 1
a467 1
     | LT.STRUCT le_list =>
d504 1
a504 1
            | _ => LT.STRUCT(map LT.VAR lv_list')
d516 1
a516 1
                     fn x => LT.SELECT({index=x, size=len}, var_new_lv)))
d677 1
a677 1
	| LT.STRUCT [] => lambda_exp
d778 1
a778 1
				   LT.LET(var,LT.Option.ABSENT,subexpr,inexpr) 
d811 1
a811 1
			    | locate (LT.LET(lv,debug_info,lb,le),frees) = 
d816 1
a816 1
				val inexpr = LT.LET(lv,debug_info,lb',le')
d924 1
a924 1
			    | locate (LT.STRUCT lel,frees) =
d932 1
a932 1
				    [] => deal_with(LT.STRUCT(map #1 bodies_counts))
d936 1
a936 1
				  (LT.STRUCT(map #1 bodies_counts), count)
@


1.54
log
@Functions and applications take a list of parameters
@
text
@d9 3
d370 1
a370 1
        | h (depth,bvs, LET (bv,b,e)) = 
a371 1
	    val bv = LT.fetch_var bv
d435 1
a435 1
        | h (depth,bvs, LETREC ([bv],[e],_)) = ug(59 ** h(depth-1,fetch_var bv::bvs,e))
d438 1
a438 1
            val bvs' = map fetch_var bvs'
d476 1
a476 1
        val lv_list'' = map LT.fetch_var lv_list
d775 1
a775 1
				   LT.LET(LT.Option.SOME1(var),subexpr,inexpr) 
d808 1
a808 1
			    | locate (LT.LET(LV,lb,le),frees) = 
a809 1
                                val lv = LT.fetch_var LV
d813 1
a813 1
				val inexpr = LT.LET(LV,lb',le')
d823 1
a823 1
			      end
d826 1
a826 1
                                val lvl' = map LT.fetch_var lvl
a879 4
				val frees' = case info' of
				  LT.Option.ABSENT => frees
				| LT.Option.PRESENT{lv, ...} =>
				    remove_var(frees, lv)
d885 1
a885 1
					(fn (LT.EXP_TAG le, _) => locate(le, frees')
d897 1
a897 1
					 val (a,b) = locate (f,frees')
d903 1
a903 1
				  (map (fn (_, le) => locate(le,frees'))
@


1.53
log
@Improved h function to remove some calls to **
@
text
@d9 3
d379 3
a381 2
        | h (depth,bvs, FN (bv,e,_,_,_)) = ug(13 ** (h (depth-1,bv::bvs, e)))
        | h (depth,bvs, APP (e1,e2,_)) = 
d392 1
d791 1
a791 1
			    | locate (LT.FN(lv, le,name,ty,instance),frees) =
d794 1
a794 1
				val inexpr = LT.FN(lv,body,name,ty,instance)
d804 2
d847 1
a847 1
			    | locate (LT.APP(p, q, ty),frees) =
d851 1
a851 1
				val inexpr = LT.APP(body,body',ty)
d862 2
@


1.52
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d9 4
d341 5
a345 1
        | h (_,bvs, INT x)  = ug(3 ** x)
d365 5
a369 1
          let val bv = LT.fetch_var bv
d371 1
d373 2
d378 8
d387 1
d390 1
a390 1

d393 1
a393 1
            | LT.Option.PRESENT x => h(depth-1,bvs,x)
d396 1
a396 1
              ((_,e1)::_) => h(depth-1,bvs,e1)
d400 1
a400 1
              ((_,_)::(_,e2)::_) => h(depth-1,bvs,e2)
d406 9
a414 1
        | h (depth,bvs, STRUCT (e1::e2::_)) = 
d416 1
d418 6
d425 1
d432 4
d437 2
d440 1
@


1.51
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d9 4
d361 1
a361 1
        | h (depth,bvs, FN (bv,e,_,_)) = ug(13 ** (h (depth-1,bv::bvs, e)))
d739 1
a739 1
			    | locate (LT.FN(lv, le,name,ty),frees) =
d742 1
a742 1
				val inexpr = LT.FN(lv,body,name,ty)
@


1.51.1.1
log
@Fork for bug fixing
@
text
@a8 4
Revision 1.51  1993/07/12  10:16:13  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.50
log
@Removed integer parameter
@
text
@d9 3
d352 5
a356 2
        | h (depth,bvs, LET (bv,b,e)) = ug (13 ** h (depth-1,bv::bvs,e) 
                                            + 15 ** h (depth-1,bv::bvs,b))  
d358 2
a359 1
        | h (depth,bvs, APP (e1,e2,_)) = ug (15 ** h(depth-1,bvs,e1) + 17 ** h(depth-1,bvs,e2)) 
d364 2
a365 2
              LambdaTypes.ABSENT => 0
            | LambdaTypes.PRESENT x => h(depth-1,bvs,x)
d382 1
a382 1
        | h (depth,bvs, RAISE e) = ug(47 ** h(depth-1,bvs,e))
d384 1
a384 1
        | h (depth,bvs, LETREC ([bv],[e],_)) = ug(59 ** h(depth-1,bv::bvs,e))
d386 5
a390 1
          ug(61 ** h(depth-1,bvs' @@bvs,e1) + 67 ** h(depth-1,bvs' @@bvs,e2))
d418 3
a420 2
	val new_lv = LambdaTypes.new_LVar()
	val (one_lv, the_lv) = case lv_list of
d428 1
a428 1
        val lv_list' = filter_for_used_variables lv_list
d439 1
a439 1
	    LambdaTypes.VAR the_lv
d619 1
a619 1
	       LT.PRESENT(LT.APP(LT.BUILTIN _,_,_)) => lambda_exp
d717 1
a717 1
				   LT.LET(var,subexpr,inexpr) 
d737 1
a737 1
				val (body,count) = locate (le,remove_var (frees, lv))
d748 1
a748 1
			    | locate (LT.LET(lv,lb,le),frees) = 
d750 1
d754 1
a754 1
				val inexpr = LT.LET(lv,lb',le')
d767 2
a768 1
				val checked = check(lvl, frees)
d771 1
a771 1
				    remove_var_list(frees, lvl)
d820 2
a821 2
				  LambdaTypes.ABSENT => frees
				| LambdaTypes.PRESENT{lv, ...} =>
d838 1
a838 1
				     LT.PRESENT f =>
d842 1
a842 1
					 (LT.PRESENT a,b)
d844 1
a844 1
				   | LT.ABSENT => (LT.ABSENT,0))
d893 1
a893 1
			    | locate (context as LT.RAISE le,frees) =
d896 1
a896 1
				val inexpr = LT.RAISE body
@


1.49
log
@Some minor mods to improve timings slightly
@
text
@d9 3
a204 1
require "../utils/integer";
a217 1
  structure Integer : INTEGER
d651 1
a651 1
				  Integer.makestring(LT.int_of_LVar (! cse_marker))))
d928 1
a928 1
					     Integer.makestring(LS.size_of_expr res)));
d1011 2
a1012 2
			      "Tried to abstract in " ^ Integer.makestring(! tried_to_locate) ^
			      " cases with success in " ^ Integer.makestring(! succeeded_in_locate) ^
@


1.48
log
@Signature revisions
@
text
@d7 4
a10 1
 *)
d12 179
d490 2
d494 2
a495 2
	  val count = ref(0)
              
d516 9
a524 8
	  (map (fn x =>
		((let
                    val current = 
                      NewHashTable.lookup_default(occcounthashtable,0,x)
                  in
		    NewHashTable.update(occcounthashtable,x,current + expr_count)
                  end)))
	  occlist)
d531 2
a532 2
	      if LT.LVar_order(base,v)
		then NewHashTable.lookup(blocksubsthashtable,v) 
d536 1
a536 1
	    fun update_hash_table(count) =
d559 19
a577 20
	  case NewHashTable.tryLookup(lambdahashtable,expanded)
	    of 
	      NewHashTable.YES var => 
		let
		  val (expr,count) = NewHashTable.lookup(varcounthashtable,var)
		  val _ = 
		    NewHashTable.update(varcounthashtable,var,(expr,count+1))
		  val _ = found_a_variable_more_than_once := true
		in
		  LT.VAR var
		end
	    | NewHashTable.NO  => 
		let
		  val newvar = LT.new_LVar()
		in
		  NewHashTable.update (lambdahashtable,expanded,newvar);
		  NewHashTable.update(reverselambdahashtable,newvar,expanded);
		  NewHashTable.update(varcounthashtable,newvar,(key,0));
		  LT.VAR newvar
		end
d616 6
a621 2
      fun remove_var (varlist, var) =
	Lists.filter_outp (fn v => v = var) varlist
d623 14
d644 2
d662 3
a664 3
		(case expr1 of
		   LT.VAR x => (NewHashTable.update(occcounthashtable,x,1))
		 | _ => ())
d681 1
a681 1
		      val non_cse_frees = Set.set_to_list frees
d683 4
a695 2
			  exception BombOut

d697 11
a707 11
			    if (cheap_to_evaluate real_expr) orelse
			      (will_be_evaluated (LT.VAR var,inexpr))
			      then (info(fn () =>  ("abstracting for v"^
						    (LT.printLVar var)));
				    adjust_occurrence_counts(1,subexpr) ;
				    let
				      val new_code =
					LT.LET(var,subexpr,inexpr) 
				    in
				      (new_code,occns+1)
				    end)
d756 1
a756 1
				    Lists.reducel remove_var (frees, lvl)
d763 1
a763 1
				  if  checked then
d831 1
a831 1
				  (map (fn (_, le) => locate(le,frees))
a853 1
				val inexpr = LT.STRUCT(map #1 bodies_counts)
d857 1
a857 1
				    [] => deal_with inexpr
d861 1
a861 1
				  (inexpr, count)
d916 1
a916 1
			       if count <> occns + 1 then
a1020 180
    
(* $Log: _optimise_cse.sml,v $
Revision 1.47  1993/03/03  16:51:12  jont
Various changes in locate and deal_with to improve speed, mainly by avoiding
unnecessary calls, and avoiding making function calls only to return a known
result following a simple equality test

Revision 1.46  1993/03/01  15:13:09  matthew
Added MLVALUE lambda exp

Revision 1.45  1992/12/24  12:24:30  clive
Stopped optimising switch info inconsistently

Revision 1.44  1992/12/17  17:15:27  matthew
Changed int and real scons to carry a location around

Revision 1.43  1992/11/09  15:09:48  clive
Added some LETREC optimisation

Revision 1.42  1992/11/05  15:03:07  jont
Reworked quick_multiply' to test the low cases first. Should be quicker

Revision 1.41  1992/10/26  18:01:58  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.40  1992/09/29  16:51:42  clive
Switched off result info details

Revision 1.39  1992/09/21  12:36:04  clive
Changed hashtables to a single structure implementation

Revision 1.38  1992/09/16  10:02:45  clive
Got rid of handles involving hash tables

Revision 1.37  1992/09/02  12:45:42  jont
Removed the uses of Lists.zip

Revision 1.36  1992/08/26  13:17:31  jont
Removed some redundant structures and sharing

Revision 1.35  1992/08/21  14:02:57  clive
Tried to optimise the multiplies into shifts and adds

Revision 1.34  1992/08/14  13:55:52  davidt
Changed ord(substring ...) to ordof.

Revision 1.33  1992/08/10  17:03:44  davidt
Changed MLworks to MLWorks.

Revision 1.32  1992/08/07  16:36:43  davidt
String structure is now pervasive, changed code to
use MLworks structure instead of NewJersey structure.

Revision 1.31  1992/08/05  18:01:58  jont
Removed some structures and sharing

Revision 1.30  1992/07/28  10:06:45  clive
Modified to use the new hashtables

Revision 1.29  1992/07/13  10:59:47  clive
Switched off time printouts

Revision 1.28  1992/07/09  15:29:13  davida
Reverted to checking is_in_evaluation_set before
lifting: without doing this we lift invalid selects
across switches!

Revision 1.27  1992/07/09  08:38:05  davida
Removed spurious control character from the
end of the file  (don't know how it got there!?)

Revision 1.26  1992/07/08  16:24:39  davida
Minor changes, new flag for printing results.

Revision 1.25  1992/07/07  14:18:25  davida
Removed some of the debugging tests and printing.

Revision 1.24  1992/07/06  11:21:42  davida
Added LET constructor and new slot to APP.
Attempted fix of scope-escape problem -
still needs work.

Revision 1.23  1992/06/23  09:56:04  clive
Added an annotation slot to HANDLE

Revision 1.22  1992/06/05  12:25:19  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.21  1992/06/05  12:25:19  clive
A few speed improvements including specialising the hash equality function

Revision 1.20  1992/05/01  14:22:44  clive
Print out more useful information on bucket overflow

Revision 1.19  1992/04/30  11:29:45  clive
Added a measure of size to the hash function to help with some awkward cases JonT came up with

Revision 1.18  1992/04/28  15:13:26  clive
Another factor of 3 improvement due to making the substitution by demand rather than eager -
locate walks the tree and does the substitution when it hits something that need expanding

Revision 1.17  1992/04/13  16:55:32  clive
First version of the profiler

Revision 1.16  1992/03/16  17:42:57  jont
Removed pervasive print. Added Integer parameter to functor

Revision 1.15  1992/03/06  11:52:58  jont
Fixed problem whereby bindings could get duplicated by renaming
entire expression using new rename_fresh from lambdasub

Revision 1.14  1992/02/18  15:55:05  jont
Fixed bug whereby common subexprs were being lifted outside LETRECs
defining some of their free variables

Revision 1.13  1992/02/17  15:08:10  jont
Fixed bugs in cse whereby expression tags were being ignored,
and functions were becoming alpha-convertible when LETRECs weren't
abstacted

Revision 1.12  1992/02/03  10:52:12  clive
Used the zip from the Lists module instead of my own

Revision 1.11  1992/01/31  09:15:17  clive
Took out check that the top level form after varification is a variable - this is not
true in the case of a signature definition

Revision 1.10  1992/01/30  16:35:35  clive
Optimised the original functional form of this code, which carried out
a lot of recomputation - considered every function call and tried to
implement it using something that had been computed before
  (1) used a hash table instead of the original table - things were added
 to the table incrementally so that it basically simulated an association list
  (2) instead of calling a function to calculate occurrences, a used a table to
compute them incrementally
  (3) expand_subexpr (to expand expressions) was called unnecessarily and used
apply_outermost instead of apply_innermost plus previously calculated values
stored in a hash table
  (4) added ReverseLambdaHashTable to calculate the inverses to the LambdaHashTable
  (5) optimised the substitutions of many small expressions into a large one, by batching
them together, and applying the small expressions to each other before doing one
substitution into the large expression
  (6) used is_in_evaluation_set (a predicate) instead of the function and a membership test

Revision 1.9  1992/01/28  16:57:38  clive
Reduced the run time of the optimiser by 50% by
 (1) Hashing the varcount_table
 (2) Using the occurrence counts (defined but not used in the existing code), to
     allow us to omit some calls to LS.occurrences

Revision 1.8  1991/10/23  12:55:01  davidt
Fixed bug where structures which are arguments to builtins are
considered as possible subexpressions for lifting. This is a
bad idea because we never really build a structure when we
are applying a builtin but if we put the structure in a let
then we do build a structure!

Revision 1.7  91/10/22  18:19:06  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.6  91/10/22  14:13:24  davidt
Took out imposs function and exception impossible.

Revision 1.5  91/10/09  15:11:10  davidt
Made changes due to record selection now requiring both the total
size of the record as well as the index.

Revision 1.4  91/09/25  14:03:08  davida
Removed a misleading comment.

Revision 1.3  91/09/11  15:59:56  davida
No changes

Revision 1.2  91/09/10  14:01:17  davida
Changed substitute calls for it's new type.

Revision 1.1  91/09/09  15:48:23  davida
Initial revision
*)
@


1.47
log
@Various changes in locate and deal_with to improve speed, mainly by avoiding
unnecessary calls, and avoiding making function calls only to return a known
result following a simple equality test
@
text
@d46 1
a46 1
  structure Ident = LT.Datatypes.Ident
d818 5
@


1.46
log
@Added MLVALUE lambda exp
@
text
@d93 11
a103 2
  in
    fun hash (x,sz) = 
d105 9
a113 22
        infix isin
        fun a isin ([],n) = ~1
          | a isin (b::bs,n) = 
            if LT.LVar_eq(a, b)
            then n
          else (a isin (bs,n+1))
            
            
      fun ug a = MLWorks.Bits.andb(a,1048575) + 1
        
      (* Quickly multiply where the first is an integer < 128 - really need unsafe addition to be used *)
      fun **(x,y) =
        let
          fun quick_multiply'(0,acc) = acc 
            | quick_multiply'(1,acc) = acc + y
            | quick_multiply'(2,acc) = acc + MLWorks.Bits.lshift(y,1)
            | quick_multiply'(3,acc) = acc + y + MLWorks.Bits.lshift(y,1)
            | quick_multiply'(x,acc) =
	      if x < 8 then
		quick_multiply'(MLWorks.Bits.andb(x, 3),
				acc + MLWorks.Bits.lshift(y, 2))
	      else
d118 14
a131 14
	      if x < 32 then
		quick_multiply'(MLWorks.Bits.andb(x, 15),
				acc + MLWorks.Bits.lshift(y, 4))
	      else
	      if x < 64 then
		quick_multiply'(MLWorks.Bits.andb(x, 31),
				acc + MLWorks.Bits.lshift(y, 5))
	      else
		quick_multiply'(MLWorks.Bits.andb(x, 63),
				acc + MLWorks.Bits.lshift(y, 6))
        in
          quick_multiply'(x,0)
        end
      
d136 4
a139 2
          if st="" then 2 else 2 ** String.ordof(st,size(st) div 2)
        | h (_,bvs,SCON (Ident.INT(st,_))) = 
d199 3
a201 5
      val result = ug(h (hash_function_depth,[],x) + 71 ** sz)
        
    in
      result
    end
d204 1
a204 1
  fun eq((x,size),(y,size')) = size=size' andalso LS.alpha_convertible (x, y)
a205 1

d295 2
a296 2
    fun eliminate_common_subexprs (LT.Info{is_shiftable,...}) expression =
      let
d298 9
a306 9
        val lambdahashtable = NewHashTable.new(2000,eq,hash)
        val varcounthashtable = NewHashTable.new(2000,op = : int * int -> bool, fn x => x)
        val _ = the_var_count_hash_table := varcounthashtable
        val occcounthashtable = NewHashTable.new(2000,op = : int * int -> bool,fn x => x)
        val blocksubsthashtable = NewHashTable.new(2000,op = : int * int -> bool, fn x => x)
        val reverselambdahashtable = NewHashTable.new(2000, op = : int * int -> bool,fn x => x)
        val _ = tried_to_locate := 0;
        val _ = succeeded_in_locate := 0
        val _ = found_a_variable_more_than_once := false
d308 3
a310 3
        fun expand_subexprs key =
          let
            val count = ref(0)
d312 9
a320 9
            fun expand (expr as LT.VAR v) =
              if represents_cse v then 
                let
                  val (code,size) = NewHashTable.lookup(reverselambdahashtable,v)
                in
                  (count := !count + size ; code)
                end
              else (count := !count + 1 ; expr)
              | expand expr = (count := !count + 1 ; expr)
d322 1
a322 1
            val result = LS.apply_innermost expand key
d324 3
a326 3
          in
            (result,!count)
          end
d328 6
a333 6
        fun adjust_occurrence_counts(expr_count,expr) =
          let
            val occlist = find_all_marking_variables_in_expression(expr)
          in
            (map (fn x =>
                  ((let
d337 1
a337 1
                      NewHashTable.update(occcounthashtable,x,current + expr_count)
d339 2
a340 2
            occlist)
          end
d342 17
a358 9
        fun deal_with_block(base,to_be_substituted,expr) =
          if LT.LVar_order(base,to_be_substituted)
            then 
              let
                fun update(expr as LT.VAR v) =
                  if LT.LVar_order(base,v)
                    then NewHashTable.lookup(blocksubsthashtable,v) 
                  else expr
                  | update expr = expr
d360 8
a367 17
                fun update_hash_table(count) =
                  if LT.LVar_order(to_be_substituted,count)
                    then ()
                  else
                    (NewHashTable.update
                     (blocksubsthashtable,
                      count, LS.apply_innermost update (fst(NewHashTable.lookup(varcounthashtable,count))));
                     update_hash_table(LT.LVar_next count))
                    
              in 
                (info(fn () => ("Deal with a block from " ^ 
                                LT.printLVar (base) ^
                                " upto " ^ LT.printLVar to_be_substituted)) ;
                 update_hash_table (LT.LVar_next base);
                 expr)
              end
          else expr
d370 25
a394 25
        fun get_var key =
          let
            val expanded as (full_expr,size_of_full_expr) = expand_subexprs key
          in
            case NewHashTable.tryLookup(lambdahashtable,expanded)
              of 
                NewHashTable.YES var => 
                  let
                    val (expr,count) = NewHashTable.lookup(varcounthashtable,var)
                    val _ = 
                      NewHashTable.update(varcounthashtable,var,(expr,count+1))
                    val _ = found_a_variable_more_than_once := true
                  in
                    LT.VAR var
                  end
              | NewHashTable.NO  => 
                  let
                    val newvar = LT.new_LVar()
                  in
                    NewHashTable.update (lambdahashtable,expanded,newvar);
                    NewHashTable.update(reverselambdahashtable,newvar,expanded);
                    NewHashTable.update(varcounthashtable,newvar,(key,0));
                    LT.VAR newvar
                  end
          end
d396 9
a404 10
        fun print_stats () = 
          (output(std_out,"LambdaHashTable" ^ 
                  NewHashTable.string_hash_table_stats(lambdahashtable) ^ "\n");
           output(std_out,"ReverseLambdaHashTable" ^ 
                  NewHashTable.string_hash_table_stats(reverselambdahashtable) ^ "\n");
           output(std_out,"OccCountHashTable" ^ 
                  NewHashTable.string_hash_table_stats(occcounthashtable) ^ "\n");
           output(std_out,"BlockSubstHashTable" ^ 
                  NewHashTable.string_hash_table_stats(blocksubsthashtable) ^ "\n"))
      
d406 1
a406 7
	fun elim_subexprs expression =
	  let
            
            
            val _ = info (fn () => "Converting sub-expressions to lambda-variables...");
            val _ = info (fn () => ("Lowest value for a marker variable is " ^ 
                                    Integer.makestring(LT.int_of_LVar (! cse_marker))))
d408 39
a446 1
            (*  Convert sub-expressions into lambda-variables. *)
d448 3
a450 20
            fun varify context_opt lambda_exp =
	     case lambda_exp of
	       LT.VAR _ => lambda_exp
	     | LT.FN _ => get_var lambda_exp
	     | LT.LET _ => get_var lambda_exp
	     | LT.LETREC _ => get_var lambda_exp
	     | LT.APP _ => get_var lambda_exp
	     | LT.SCON _ => lambda_exp
	     | LT.MLVALUE _ => lambda_exp
	     | LT.INT _ => lambda_exp
	     | LT.SWITCH _ => get_var lambda_exp
	     | LT.STRUCT [] => lambda_exp
	     | LT.STRUCT _ => 
		 (case context_opt of
		    LT.PRESENT(LT.APP(LT.BUILTIN _,_,_)) => lambda_exp
		  | _ => get_var lambda_exp)
	     | LT.SELECT _ => get_var lambda_exp
	     | LT.RAISE _ => get_var lambda_exp
	     | LT.HANDLE _ => get_var lambda_exp
	     | LT.BUILTIN _ => lambda_exp
d452 3
a454 3
	   (*  Common expressions are put into a LET enclosing the      *)
	   (*  smallest possible lambda-expression.  An alternative     *)
	   (*  would be to put them as far out as possible, cf selects  *)
d456 5
a460 3
	   fun unvarify expr1 =
	     let
	       val _ = info (fn () => "Abstracting out CSE's")
d462 10
a471 18
	       (* Expression is now represented by a single variable *)
	       val _ =
		 (case expr1 of
		    LT.VAR x => (NewHashTable.update(occcounthashtable,x,1))
		  | _ => ())

	       fun abs_smallest (expr2, (var,subexpr),to_be_substituted) =
		 let
		   val occns = 
		     NewHashTable.lookup_default(occcounthashtable,0,var) 
		 in
		   if occns>1 
                   then 
		     let
		       val expr2 =
			 deal_with_block(var,to_be_substituted,expr2)  
		       val real_expr = #1 (NewHashTable.lookup (reverselambdahashtable,var))
		     
d475 1
a475 1
		       val frees = #2 (LS.bounds_and_frees real_expr)
d477 1
a477 2
		       fun remove_var (var,varlist) =
			 Lists.filter_outp (fn v=>LT.LVar_eq(v,var)) varlist
d479 8
a486 1
		       val non_cse_frees = Set.set_to_list frees
d488 1
a488 4
(*		       val _ = LambdaPrint.print_lambda real_expr
		       val _ = Print.print ("Free vars in sub-expr:"^
					    (Lists.to_string LT.printLVar non_cse_frees)^"\n")
*)
d490 14
a503 13
(*			 ref (Lists.filterp                 (* actually, no effect since no cses in real_expr *)
			      (fn v => LT.LVar_order(v, var)) 
			      (Set.set_to_list frees))
*)
		     in
		       if (info(fn () =>  ("subexpr appears more than once: v"^
                                           (LT.printLVar var) ^ "\n" ^
                                           LambdaPrint.string_of_lambda subexpr));
			 is_shiftable real_expr)
			 then
			   (* locate smallest sub-expression  *)
			   (* containing all instances of var *)
			   let
d505 78
a582 1
			     exception BombOut
d584 6
a589 56
			     local
                                   
			       fun add_up x =
				 let 
				   fun add1([],x:int) = x
				     | add1((_, h)::t,x) = add1(t,h+x)
				 in
				   add1(x,0)
				 end
			     in
			       fun deal_with (inexpr,num,frees) =
				 if num=occns then
				   if (frees = []) then
				   if (cheap_to_evaluate real_expr) orelse
				      (will_be_evaluated (LT.VAR var,inexpr))
				     then (info(fn () =>  ("abstracting for v"^
                                                           (LT.printLVar var)));
                                           adjust_occurrence_counts(1,subexpr) ;
					    let
					      val new_code =
						LT.LET(var,subexpr,inexpr) 
					    in
					      (new_code,occns+1)
					    end)
				   else
				      raise BombOut
				   else (info (fn()=>"Abstracting would violate scope\n");
					 raise BombOut)
				 else (inexpr,num)
                                       
			       fun locate (le as LT.VAR v,frees) = 
                                  if LT.LVar_order(var,v)
                                    then
                                      case NewHashTable.tryLookup(blocksubsthashtable,v) of
                                        NewHashTable.YES res => locate(res,frees)
                                      | NewHashTable.NO => deal_with (le,if v=var then 1 else 0,frees)
                                  else
                                    deal_with (le,if v=var then 1 else 0,frees)
				 | locate (LT.FN(lv, le,name,ty),frees) =
				 let 
				   val (body,count) = locate (le,remove_var (lv,frees))
				 in
				   deal_with (LT.FN(lv,body,name,ty),count,frees)
				 end
				 | locate (LT.LET(lv,lb,le),frees) = 
				   let
				     val frees' = remove_var(lv,frees)
				     val (lb',count) = locate (lb,frees')
				     val (le',count') = locate (le,frees')
				   in
				     deal_with(LT.LET(lv,lb',le'),count+count',frees)
				   end
				 | locate (LT.LETREC(lvl, lel, le),frees) =
				 let 
				   val frees' = Lists.reducer remove_var (lvl,frees)
				   val loc_vals = map (fn le=>locate(le,frees')) lel
d591 51
a641 38
				   val (body,count) = locate (le,frees')
				   val new_count = (count + add_up loc_vals)
				   fun check [] = false
				     | check (x::xs) = Lists.member(x,frees) orelse (check xs)
				 in
				   if new_count=occns andalso check lvl
				     then (* can't lift out a letrec binding *)
				       raise BombOut
				   else deal_with(LT.LETREC (lvl,map #1 loc_vals,body),
						  new_count, frees)
				 end
                                 | locate (LT.APP(p, q, ty),frees) =
                                   let
                                     val (body,count) = locate (p,frees)
                                     val (body',count') = locate (q,frees)
                                   in 
                                     deal_with(LT.APP(body,body',ty),count + count',frees)
                                   end
                                 
                                 | locate (le as LT.SCON _,frees) = 
                                   deal_with(le,0,frees)
                                   
                                 | locate (le as LT.MLVALUE _,frees) = 
                                   deal_with(le,0,frees)
                                   
                                 | locate (le as LT.INT _,frees) = 
                                   deal_with(le,0,frees)
                                   
                                 | locate (context as LT.SWITCH(le, info, clel, leo),frees) = 
                                   let
                                     val (body, count) = locate (le,frees)
(*
                                     val (tags,_) = Lists.unzip clel
*)
				     val frees' = case info of
				       LambdaTypes.ABSENT => frees
				     | LambdaTypes.PRESENT{lv, ...} =>
					 remove_var(lv, frees)
d643 15
a657 82
                                     val (tags, counts') = case clel of
                                       (LT.EXP_TAG _, _) :: _ =>
                                         let
					   val tags_counts =
                                             (map
                                              locate
                                              (map
                                               (fn (LT.EXP_TAG le, _) => (le,frees')
                                             | _ => Crash.impossible"Mixed tag type")
                                               clel))
                                         in
                                           (map (fn (tag, _) =>
						 LT.EXP_TAG tag) tags_counts,
					    add_up tags_counts)
                                         end
                                     | _ => (map #1 clel, 0)
                                     val (body',count') =
                                       (case leo of
                                          LT.PRESENT f =>
                                            let
                                              val (a,b) = locate (f,frees')
                                            in
                                              (LT.PRESENT a,b)
                                            end
                                        | LT.ABSENT => (LT.ABSENT,0))
(*
                                     val (bodies,counts) =
				       Lists.unzip
*)
				     val bodies_counts =
				       (map (fn (_, le) => locate(le,frees))
					clel)
                                   in
                                     deal_with(LT.SWITCH
                                               (body,
						info,
                                                Lists.zip(tags,map #1 bodies_counts),
					      body'), 
					     count + count' +
					     counts' + add_up bodies_counts,
					     frees)
				 end
                                     
			       | locate (LT.STRUCT lel,frees) =
				 let
(*
				   val (bodies,counts) =
				     Lists.unzip
*)
				   val bodies_counts =
				     (map (fn le=>locate(le,frees)) lel)
				   val count = add_up bodies_counts
				 in 
				   deal_with(LT.STRUCT (map #1 bodies_counts) , count,frees)
				 end
                                     
			       | locate (context as LT.SELECT (fld, le),frees) =
				 let
				   val (body,count) = locate (le,frees)
				 in 
				   deal_with(LT.SELECT (fld, body) ,count,frees)
				 end
                                     
			       | locate (context as LT.RAISE le,frees) =
				 let
				   val (body,count) = locate (le,frees)
				 in 
				   deal_with(LT.RAISE (body) ,count,frees)
				 end
                                     
			       | locate (LT.HANDLE (le1, le2,annotation),frees) =
				 let
				   val (body,count) = locate (le1,frees)
				   val (body',count') = locate (le2,frees)
				 in
				   deal_with(LT.HANDLE(body,body',annotation), count + count',frees)
				 end
                                     
			       | locate (le as LT.BUILTIN _,frees) = 
				 deal_with(le,0,frees)
                                       
			     end
d659 4
a662 12
			   in
			     (let
                                val _ = tried_to_locate := !tried_to_locate + 1;
				val (res, count) = locate (expr2,non_cse_frees)
				val _ =
				  if count <> occns + 1 then
				    Crash.impossible
				    ("Failed to locate all occurrences of " ^
				     LT.printLVar var)
				  else
				    ()
                                val _ = succeeded_in_locate := !succeeded_in_locate + 1
d664 8
a671 19
				info (fn () => (Print.print "after abstract:\n";
					(*	LambdaPrint.print_lambda res; *)
						"Size is now " ^
				      Integer.makestring(LS.size_of_expr res)));
				(res,LT.LVar_previous var)
			      end)
				handle BombOut => 
				  (adjust_occurrence_counts(occns,subexpr) ;
				   (expr2,var))  (* (LS.substitute(var,subexpr,expr2),LT.LVar_previous var))  *)
			   end
                             
		       else
			 (adjust_occurrence_counts(occns,subexpr) ;
			  (* NB:- when expanding later, duplication might occur *)
			  (* debug code... *)
			  case subexpr of
			    LT.LETREC _ => Print.print
			      "Warning: possible bad substitution for LETREC\n"
			  | _ => ();
d673 13
a685 6
			      (expr2,var)) (*(LS.substitute(var,subexpr,expr2),LT.LVar_previous var))   *)
		     end
                       
		   else (adjust_occurrence_counts(occns,subexpr);
			 (expr2,to_be_substituted))
			 (* LS.substitute(var,subexpr,expr2),LT.LVar_previous var (*to_be_substituted*))) *)
d687 58
a744 1
		 end
d746 4
a749 4
                   (* The lambda variables that we have introduced 
                    had better be contiguous *)
	       val highest = (LT.new_LVar())
	       val lowest = (! cse_marker)
d751 18
a768 21
	       fun loop_through (count,(expr,to_be_substituted)) =
		 if LT.LVar_order(lowest,count) then
		   let
		     val (expr',count') = NewHashTable.lookup(varcounthashtable,count)
		     val arg = (count,expr')
		   in
		     loop_through(LT.LVar_previous count,abs_smallest(expr,arg,to_be_substituted))
		   end
		 else 
		   (deal_with_block(count,to_be_substituted,expr);
                    LS.apply_outermost
                      (fn (le as (LT.VAR v)) =>
                       if LT.LVar_order(count,v)
                         then
                           NewHashTable.lookup_default(blocksubsthashtable,le,v)
                       else
                         le
                         | expr => expr)
                      expr)

                    
d770 1
a770 1
	       val prev_highest = LT.LVar_previous highest
d772 2
a773 2
	       val absd_exp = 
		 loop_through (prev_highest,(expr1,prev_highest))
d775 22
a796 23
	       val _ = 
                 if !print_hash_table_stats
                   then print_stats()   (* #### to see stats *)
                 else ()
	     in
	       absd_exp
	     end
	 in
	   let
	     val exp = if !show_debug_info
			 then Timer.time_it("Varifying", 
                                            fn () => (LS.apply_innermost_with_context varify expression))
		       else LS.apply_innermost_with_context varify expression
	   in
             if !found_a_variable_more_than_once
               then
                 (true,if !show_debug_info
			 then Timer.time_it("Unvarifying",fn () => unvarify (exp))
		       else unvarify exp)
             else
               (false,exp)
	   end
	 end
d798 11
d810 3
a812 16
        let
          val transformed = transform_letrecs expression
          val _ = cse_marker := LT.new_LVar()
          val (modified,result) = elim_subexprs transformed
          val _ = if !show_result_info andalso !tried_to_locate > 0
                    then output(std_out,
                                "Tried to abstract in " ^ Integer.makestring(! tried_to_locate) ^
                                " cases with success in " ^ Integer.makestring(! succeeded_in_locate) ^
                                "\n")
                  else ()
        in
          if modified
            then 
              LS.rename_fresh result
          else transformed
        end
d814 1
d818 3
@


1.45
log
@Stopped optimising switch info inconsistently
@
text
@d431 1
d580 3
d799 3
@


1.44
log
@Changed int and real scons to carry a location around
@
text
@d172 1
a172 1
        | h (depth,bvs, SWITCH(e,info,cases,a)) = 
a173 3
	    val bvs' = case info of
	      LambdaTypes.ABSENT => bvs
	    | LambdaTypes.PRESENT{lv, ...} => lv::bvs
d177 1
a177 1
            | LambdaTypes.PRESENT x => h(depth-1,bvs',x)
d180 1
a180 1
              ((_,e1)::_) => h(depth-1,bvs',e1)
d184 1
a184 1
              ((_,_)::(_,e2)::_) => h(depth-1,bvs',e2)
d795 3
@


1.43
log
@Added some LETREC optimisation
@
text
@d141 1
a141 1
        | h (_,bvs,SCON (Ident.INT st)) = 
d798 3
@


1.42
log
@Reworked quick_multiply' to test the low cases first. Should be quicker
@
text
@d236 6
d245 1
a245 1
			 map (fn x => (x, LT.new_LVar())) lv_list
d254 3
a256 1
	    LT.STRUCT(map LT.VAR lv_list)
d259 1
a259 1
	val len = Lists.length le_list
d263 6
a268 3
	    #1 (Lists.number_from_by_one
		(map #2 lv_assoc, 0,
		 fn x => LT.SELECT({index=x, size=len}, var_new_lv)))
d798 3
@


1.41
log
@Minor changes to support the new type of SWITCHes.
@
text
@d111 2
d114 18
a131 11
              if x > 64
                then quick_multiply'(x-64,acc + MLWorks.Bits.lshift(y,6))
              else if x > 32
                     then quick_multiply'(x-32,acc + MLWorks.Bits.lshift(y,5))
              else if x > 16
                     then quick_multiply'(x-16,acc + MLWorks.Bits.lshift(y,4))
              else if x > 8
                     then quick_multiply'(x-8,acc + MLWorks.Bits.lshift(y,3))
              else if x > 4
                     then quick_multiply'(x-4,acc + MLWorks.Bits.lshift(y,2))
                   else quick_multiply'(x-2,acc + MLWorks.Bits.lshift(y,1))
d787 3
@


1.40
log
@Switched off result info details
@
text
@d163 1
a163 1
        | h (depth,bvs, SWITCH(e,cases,a,b)) = 
d165 4
d171 6
a176 4
            | LambdaTypes.PRESENT x => h(depth-1,bvs,x)
            val second = case b of
              LambdaTypes.ABSENT => 0
            | LambdaTypes.PRESENT x => h(depth-1,bvs,x)
d178 1
a178 4
              ((_,e1)::_) => h(depth-1,bvs,e1)
            | _ => 0
            val fourth = case cases of
              ((_,_)::(_,e2)::_) => h(depth-1,bvs,e2)
d181 1
a181 1
            ug(21 ** first + ug(23 ** second + ug (19 ** third + ug(27 ** fourth))))
d565 1
a565 1
                                 | locate (context as LT.SWITCH(le, clel, leo1, leo2),frees) = 
d567 1
a567 1
                                     val (body,count) = locate (le,frees)
d571 5
d583 1
a583 1
                                               (fn (LT.EXP_TAG le, _) => (le,frees)
d593 1
a593 1
                                       (case leo1 of
d596 1
a596 1
                                              val (a,b) = locate (f,frees)
a600 9
                                     val (body'',count'') =
                                       (case leo2 of
                                          LT.PRESENT f =>
                                            let
                                              val (a,b) = locate (f,frees)
                                            in
                                              (LT.PRESENT a,b)
                                            end
                                        | LT.ABSENT => (LT.ABSENT,0))
d611 1
d613 2
a614 2
					      body',body''), 
					     count + count' + count'' +
d778 3
@


1.39
log
@Changed hashtables to a single structure implementation
@
text
@d58 1
a58 1
  val show_result_info = ref true;
d778 3
@


1.38
log
@Got rid of handles involving hash tables
@
text
@a16 1
require "../utils/_newhashtable";
d39 1
d45 1
a81 1
  (* Rather than a table, we ought to use a hash table *)
a82 49
  structure VarCountHashTable = 
    NewHashTable(
      structure Crash = Crash
      structure Lists = Lists
      type Key    = LT.LVar
      type Value  = LT.LambdaExp * int
      val size    = 2000
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq)

(* Simulate the occurrence counts as we go along *)

  structure OccCountHashTable = 
    NewHashTable(
      structure Crash = Crash
      structure Lists = Lists
      type Key    = LT.LVar
      type Value  = int
      val size    = 2000
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq)

(* Block substitution table *)

  structure BlockSubstHashTable = 
    NewHashTable(
      structure Crash = Crash
      structure Lists = Lists
      type Key    = LT.LVar
      type Value  = LT.LambdaExp
      val size    = 2000
      val hash = LT.int_of_LVar
      val eq = LT.LVar_eq)

  structure ReverseLambdaHashTable = 
    NewHashTable(
      local
        open LT 
      in  
        structure Crash = Crash
        structure Lists = Lists
        type Key    = LVar
        type Value  = LambdaExp * int
        val size    = 2000
        val hash = LT.int_of_LVar
        val eq = LT.LVar_eq
      end)


d84 2
a85 1
  val the_var_count_hash_table = ref(VarCountHashTable.new())
d87 77
a163 15
  structure LambdaHashTable = 
    NewHashTable(
      local
        open LT 
      in
        structure Crash = Crash
        structure Lists = Lists
        type Key    = LambdaExp * int
        type Value  = LVar

       (*  Hash function - must hash alpha-convertible terms to  *)
       (*  the same place, yet we'd like free variables to be    *)
       (*  distinguished...  unless of course they represent     *)
       (*  replaced expressions.				 *)
        fun hash (x,sz) = 
d165 33
a197 103
            infix isin
            fun a isin ([],n) = ~1
              | a isin (b::bs,n) = 
                if LT.LVar_eq(a, b)
                  then n
                else (a isin (bs,n+1))
                  

	   fun ug a = MLWorks.Bits.andb(a,1048575) + 1

           (* Quickly multiply where the first is an integer < 128 - really need unsafe addition to be used *)
           fun **(x,y) =
             let
               fun quick_multiply'(0,acc) = acc 
                 | quick_multiply'(1,acc) = acc + y
                 | quick_multiply'(x,acc) =
                   if x > 64
                     then quick_multiply'(x-64,acc + MLWorks.Bits.lshift(y,6))
                   else if x > 32
                         then quick_multiply'(x-32,acc + MLWorks.Bits.lshift(y,5))
                       else if x > 16
                              then quick_multiply'(x-16,acc + MLWorks.Bits.lshift(y,4))
                       else if x > 8
                              then quick_multiply'(x-8,acc + MLWorks.Bits.lshift(y,3))
                       else if x > 4
                              then quick_multiply'(x-4,acc + MLWorks.Bits.lshift(y,2))
                            else quick_multiply'(x-2,acc + MLWorks.Bits.lshift(y,1))
             in
               quick_multiply'(x,0)
             end
           
           infix 7 **

	   fun h (0,_,_) = 1
             | h (_,bvs, SCON (Ident.STRING st)) = 
               if st="" then 2 else 2 ** String.ordof(st,size(st) div 2)
             | h (_,bvs,SCON (Ident.INT st)) = 
               let
                 fun convert(0,acc) = acc
                   | convert(n,acc) = convert(n-1, ug(10 ** acc + String.ordof(st,n-1) - 48))
               in
                 convert(size st,0)
               end
             | h (_,bvs,SCON _) = 2
             | h (_,bvs, INT x)  = ug(3 ** x)
             | h (_,bvs, BUILTIN _) = 5
             | h (depth,bvs, VAR v)  =
               let
                 val count = (v isin (bvs,0))
               in
                 if  count>=0
                   then 7 ** count
                 else 
                   if represents_cse v
                     then 
                       let
                         val looked_up = 
                           VarCountHashTable.lookup(!the_var_count_hash_table,v)
                       in
                         h (depth-1,bvs, fst(looked_up))
                       end
                   else ug(11 ** (int_of_LVar v))
               end
	   | h (depth,bvs, LET (bv,b,e)) = ug (13 ** h (depth-1,bv::bvs,e) 
                                               + 15 ** h (depth-1,bv::bvs,b))  
	   | h (depth,bvs, FN (bv,e,_,_)) = ug(13 ** (h (depth-1,bv::bvs, e)))
	   | h (depth,bvs, APP (e1,e2,_)) = ug (15 ** h(depth-1,bvs,e1) + 17 ** h(depth-1,bvs,e2)) 
	   | h (depth,bvs, SWITCH(e,cases,a,b)) = 
             let
               val first = case a of
                 LambdaTypes.ABSENT => 0
               | LambdaTypes.PRESENT x => h(depth-1,bvs,x)
               val second = case b of
                 LambdaTypes.ABSENT => 0
               | LambdaTypes.PRESENT x => h(depth-1,bvs,x)
               val third = case cases of
                 ((_,e1)::_) => h(depth-1,bvs,e1)
               | _ => 0
               val fourth = case cases of
                 ((_,_)::(_,e2)::_) => h(depth-1,bvs,e2)
               | _ => 0
             in
               ug(21 ** first + ug(23 ** second + ug (19 ** third + ug(27 ** fourth))))
             end
             | h (depth,bvs, STRUCT [e]) = ug(23 ** h (depth-1,bvs,e))
             | h (depth,bvs, STRUCT (e1::e2::_)) = 
               ug(29 ** h (depth-1,bvs,e1)+ 31 ** h (depth-1,bvs,e2))
             | h (depth,bvs, SELECT ({index,size},e)) =
               ug(37 + 41 ** index + 43 ** h(depth-1,bvs,e))
             | h (depth,bvs, RAISE e) = ug(47 ** h(depth-1,bvs,e))
             | h (depth,bvs, HANDLE (e1,_,_)) = ug(53 ** h(depth-1,bvs,e1))
             | h (depth,bvs, LETREC ([bv],[e],_)) = ug(59 ** h(depth-1,bv::bvs,e))
             | h (depth,bvs, LETREC (bvs',e1::e2::_,_)) =
               ug(61 ** h(depth-1,bvs' @@bvs,e1) + 67 ** h(depth-1,bvs' @@bvs,e2))
             | h _ = 1

           val result = ug(h (hash_function_depth,[],x) + 71 ** sz)

	 in
           result
	 end

       fun eq((x,size),(y,size')) = size=size' andalso LS.alpha_convertible (x, y)
d199 1
a199 2
       val size = 2000
    end)
d283 2
a284 2
        val lambdahashtable = LambdaHashTable.new()
        val varcounthashtable = VarCountHashTable.new()
d286 3
a288 3
        val occcounthashtable = OccCountHashTable.new()
        val blocksubsthashtable = BlockSubstHashTable.new()
        val reverselambdahashtable = ReverseLambdaHashTable.new()
d300 1
a300 1
                  val (code,size) = ReverseLambdaHashTable.lookup(reverselambdahashtable,v)
d320 1
a320 1
                      OccCountHashTable.lookup_default(occcounthashtable,0,x)
d322 1
a322 1
                      OccCountHashTable.update(occcounthashtable,x,current + expr_count)
d333 1
a333 1
                    then BlockSubstHashTable.lookup(blocksubsthashtable,v) 
d341 1
a341 1
                    (BlockSubstHashTable.update
d343 1
a343 1
                      count, LS.apply_innermost update (fst(VarCountHashTable.lookup(varcounthashtable,count))));
d360 1
a360 1
            case LambdaHashTable.tryLookup(lambdahashtable,expanded)
d362 1
a362 1
                LambdaHashTable.YES var => 
d364 1
a364 1
                    val (expr,count) = VarCountHashTable.lookup(varcounthashtable,var)
d366 1
a366 1
                      VarCountHashTable.update(varcounthashtable,var,(expr,count+1))
d371 1
a371 1
              | LambdaHashTable.NO  => 
d375 3
a377 3
                    LambdaHashTable.update (lambdahashtable,expanded,newvar);
                    ReverseLambdaHashTable.update(reverselambdahashtable,newvar,expanded);
                    VarCountHashTable.update(varcounthashtable,newvar,(key,0));
d384 1
a384 1
                  LambdaHashTable.string_hash_table_stats(lambdahashtable) ^ "\n");
d386 1
a386 1
                  ReverseLambdaHashTable.string_hash_table_stats(reverselambdahashtable) ^ "\n");
d388 1
a388 1
                  OccCountHashTable.string_hash_table_stats(occcounthashtable) ^ "\n");
d390 1
a390 1
                  BlockSubstHashTable.string_hash_table_stats(blocksubsthashtable) ^ "\n"))
d434 1
a434 1
		    LT.VAR x => (OccCountHashTable.update(occcounthashtable,x,1))
d440 1
a440 1
		     OccCountHashTable.lookup_default(occcounthashtable,0,var) 
d447 1
a447 1
		       val real_expr = #1 (ReverseLambdaHashTable.lookup (reverselambdahashtable,var))
d513 3
a515 3
                                      case BlockSubstHashTable.tryLookup(blocksubsthashtable,v) of
                                        BlockSubstHashTable.YES res => locate(res,frees)
                                      | BlockSubstHashTable.NO => deal_with (le,if v=var then 1 else 0,frees)
d709 1
a709 1
		     val (expr',count') = VarCountHashTable.lookup(varcounthashtable,count)
d720 1
a720 1
                           BlockSubstHashTable.lookup_default(blocksubsthashtable,le,v)
d778 3
@


1.37
log
@Removed the uses of Lists.zip
@
text
@d377 1
a377 2
                      (OccCountHashTable.lookup(occcounthashtable,x)
                       handle OccCountHashTable.Lookup _ => 0)
d417 20
a436 21
            let
              val var = LambdaHashTable.lookup (lambdahashtable,expanded)
              val (expr,count) = VarCountHashTable.lookup(varcounthashtable,var)
              val _ = 
                VarCountHashTable.update(varcounthashtable,var,(expr,count+1))
              val _ = found_a_variable_more_than_once := true
            in
              LT.VAR var
            end
          handle LambdaHashTable.Lookup _ => 
            let
              val newvar = LT.new_LVar()
              val _ = 
                LambdaHashTable.update (lambdahashtable,expanded,newvar)
              val _ =
                ReverseLambdaHashTable.update(reverselambdahashtable,newvar,expanded)
              val _ = 
                VarCountHashTable.update(varcounthashtable,newvar,(key,0))
            in
              LT.VAR newvar
            end
d497 1
a497 2
		     (OccCountHashTable.lookup(occcounthashtable,var) 
		      handle OccCountHashTable.Lookup _ => 0)
d570 3
a572 9
                                      let
                                        val (found,res) = (true,BlockSubstHashTable.lookup(blocksubsthashtable,v))
                                          handle BlockSubstHashTable.Lookup _ => (false,le)
                                      in
                                        if found 
                                          then
                                            locate (res,frees)
                                        else deal_with (le,if v=var then 1 else 0,frees)
                                      end
d593 1
a593 4
(*
				   val bodies = map #1 loc_vals
				   val counts = map #2 loc_vals
*)
d777 1
a777 2
                           ((BlockSubstHashTable.lookup (blocksubsthashtable,v)) 
                            handle BlockSubstHashTable.Lookup _ => le)
d835 3
@


1.36
log
@Removed some redundant structures and sharing
@
text
@d545 1
a545 1
				     | add1(h::t,x) = add1(t,h+x)
d602 1
d605 1
d607 1
a607 1
				   val new_count = (count + add_up counts)
d614 1
a614 1
				   else deal_with(LT.LETREC (lvl,bodies,body),
d634 5
a638 3
                                     val (tags,codes) = Lists.unzip clel
                                     val (tags, counts') = case tags of
                                       LT.EXP_TAG _ :: _ =>
d640 1
a640 2
                                           val (tags, counts) =
                                             Lists.unzip
d644 1
a644 1
                                               (fn (LT.EXP_TAG le) => (le,frees)
d646 1
a646 1
                                               tags))
d648 3
a650 1
                                           (map LT.EXP_TAG tags, add_up counts)
d652 1
a652 1
                                     | _ => (tags, 0)
d671 7
a677 1
                                     val (bodies,counts) = Lists.unzip (map (fn le=>locate(le,frees)) codes)
d681 1
a681 1
                                                Lists.zip(tags,bodies),
d684 1
a684 1
					     counts' + add_up counts,
d689 8
a696 3
				 let 
				   val (bodies,counts) = Lists.unzip (map (fn le=>locate(le,frees)) lel)
				   val count = add_up counts
d698 1
a698 1
				   deal_with(LT.STRUCT (bodies) , count,frees)
d848 3
@


1.35
log
@Tried to optimise the multiplies into shifts and adds
@
text
@a40 1
(*  sharing type LambdaPrint.LambdaTypes.LVar = int  ### *)
d45 1
d832 3
@


1.34
log
@Changed ord(substring ...) to ordof.
@
text
@d161 23
d186 1
a186 1
               if st="" then 2 else 2 * String.ordof(st,size(st) div 2)
d190 1
a190 1
                   | convert(n,acc) = convert(n-1, ug(acc * 10 + String.ordof(st,n-1) - 48))
d195 1
a195 1
             | h (_,bvs, INT x)  = ug(3 * x)
d202 1
a202 1
                   then 7 * count
d212 1
a212 1
                   else ug(11 * (int_of_LVar v))
d214 4
a217 3
	   | h (depth,bvs, LET (bv,b,e)) = ug (13 * h (depth-1,bv::bvs,e) + 15 * h (depth-1,bv::bvs,b))   (* !! *)
	   | h (depth,bvs, FN (bv,e,_,_)) = ug(13 * (h (depth-1,bv::bvs, e)))
	   | h (depth,bvs, APP (e1,e2,_)) = ug (15 * h(depth-1,bvs,e1) + 17 * h(depth-1,bvs,e2)) 
d233 1
a233 1
               ug(21 * first + ug(23 * second + ug (19 * third + ug(27 * fourth))))
d235 1
a235 1
             | h (depth,bvs, STRUCT [e]) = ug(23 * h (depth-1,bvs,e))
d237 1
a237 1
               ug(29 * h (depth-1,bvs,e1)+ 31 * h (depth-1,bvs,e2))
d239 4
a242 4
               ug(37 + 41 * index + 43 * h(depth-1,bvs,e))
             | h (depth,bvs, RAISE e) = ug(47 * h(depth-1,bvs,e))
             | h (depth,bvs, HANDLE (e1,_,_)) = ug(53 * h(depth-1,bvs,e1))
             | h (depth,bvs, LETREC ([bv],[e],_)) = ug(59 * h(depth-1,bv::bvs,e))
d244 1
a244 1
               ug(61 * h(depth-1,bvs' @@bvs,e1) + 67 * h(depth-1,bvs' @@bvs,e2))
d247 1
a247 1
           val result = ug(h (hash_function_depth,[],x) + 71 * sz)
d832 3
@


1.33
log
@Changed MLworks to MLWorks.
@
text
@a144 4
	(* fix unfortunate name clash *)
	val str_size = size
        val size    = 2000

d163 1
a163 3
               if st="" 
                 then 2 
               else 2 * ord(String.substring(st,str_size(st) div 2,1))
d167 1
a167 1
                   | convert(n,acc) = convert(n-1,ug(acc * 10 + ord(String.substring(st,n-1,1)) - 48))
d169 1
a169 1
                 convert(str_size st,0)
d230 2
d808 3
@


1.32
log
@String structure is now pervasive, changed code to
use MLworks structure instead of NewJersey structure.
@
text
@d163 1
a163 1
	   fun ug a = MLworks.Bits.andb(a,1048575) + 1
d812 4
@


1.31
log
@Removed some structures and sharing
@
text
@a21 1
require "../utils/string";
a38 1
  structure String : STRING
d144 3
d153 1
a153 1
        fun hash (x,size) = 
d163 1
a163 1
	   fun ug a = NewJersey.Bits.andb(a,1048575) + 1
d169 1
a169 1
               else 2 * String.ord(String.substring(st,String.size(st) div 2,1))
d175 1
a175 1
                 convert(String.size st,0)
d229 1
a229 1
           val result = ug(h (hash_function_depth,[],x) + 71 * size)
d812 3
@


1.30
log
@Modified to use the new hashtables
@
text
@d25 1
d39 1
d41 2
d44 1
a44 1
  sharing LambdaPrint.LambdaTypes = Lib.LT) : OPTIMISE_CSE =
d46 2
a47 1
  structure LambdaTypes = Lib.LT
d61 1
a61 1
  val print_hash_table_stats = Lib.LS.print_hash_table_stats
d811 3
@


1.29
log
@Switched off time printouts
@
text
@d17 1
a17 4
require "../utils/hashtable";
require "../utils/_hashtable";
require "../utils/hashtable-with-extras";
require "../utils/_hashtable-with-extras";
d56 2
a57 1
  val print_hash_table_stats = ref false
d80 9
a88 8
structure VarCountSpec : HASHSPEC =
  struct
    type Key    = LT.LVar
    type Value  = LT.LambdaExp * int
    val size    = 2000
    val hash = LT.int_of_LVar
    val eq = LT.LVar_eq
  end
a89 2
  structure VarCountHashTable = HashTable(VarCountSpec)

a90 8
structure OccCountSpec : HASHSPEC =
  struct
    type Key    = LT.LVar
    type Value  = int
    val size    = 2000
    val hash = LT.int_of_LVar
    val eq = LT.LVar_eq
  end
d92 9
a100 1
  structure OccCountHashTable = HashTable(OccCountSpec)
a102 8
structure BlockSubstSpec : HASHSPEC =
  struct
    type Key    = LT.LVar
    type Value  = LT.LambdaExp
    val size    = 2000
    val hash = LT.int_of_LVar
    val eq = LT.LVar_eq
  end
d104 9
a112 1
  structure BlockSubstHashTable = HashTable(BlockSubstSpec)
d114 13
a126 12
  structure ReverseLambdaHashSpec : HASHSPEC = 
   struct
    local
       open LT 
    in
       type Key    = LVar
       type Value  = LambdaExp * int
       val size    = 2000
       val hash = LT.int_of_LVar
       val eq = LT.LVar_eq
    end
   end
a127 1
  structure ReverseLambdaHashTable = HashTable(ReverseLambdaHashSpec)
a128 21
  fun expand_subexprs key =
    let
      val count = ref(0)

      fun expand (expr as LT.VAR v) =
	if represents_cse v then 
          let
            val (code,size) = ReverseLambdaHashTable.lookup(v)
          in
            (count := !count + size ; code)
          end
	else (count := !count + 1 ; expr)
      | expand expr = (count := !count + 1 ; expr)

      val result = LS.apply_innermost expand key

   in
       (result,!count)
     end


d130 1
d132 10
a141 8
  structure HashSpec : HASHSPEC' = 
   struct
    local
       open LT 
    in
       type Key    = LambdaExp * int
       type Value  = LVar
       val size    = 2000
d147 9
a155 8
       fun hash depth (x,size) = 
	 let
	   infix isin
	   fun a isin ([],n) = ~1
	   | a isin (b::bs,n) = 
             if LT.LVar_eq(a, b)
               then n
             else (a isin (bs,n+1))
a156 5
(*
           val modval = 1048576
	   fun ug a = a mod modval + 1
*)

d174 1
a174 1
             | h (dept_,bvs, VAR v)  =
d183 6
a188 1
                       h (depth-1,bvs, fst(VarCountHashTable.lookup(v)))
d223 1
a223 1
           val result = ug(h (depth,[],x) + 71 * size)
d229 2
a232 50



       fun hash_generator(0,_) = (hash hash_function_depth,true)
         | hash_generator(1,bucket_contents) = 
           (output(std_out,"Adjusting the hash function due to bucket overflow\n");
            if !print_hash_table_stats
              then
                (output(std_out,"\n\nA dump of the contents of the over-flowing bucket follows \n\n");
                 map (fn (x,_) => output(std_out,LambdaPrint.string_of_lambda x ^ "\n")) (bucket_contents());
                 ())
            else
              ();
            (hash ~1,false))
         | hash_generator _ = Crash.impossible "hash_generator called too many times"

       val maximum_bucket_size = maximum_bucket_size

       fun eq((x,size),(y,size')) = size=size' andalso LS.alpha_convertible (x, y);
    end
   end;

  structure LambdaHashTable = HashTable'(HashSpec);



  local
    fun print_hash_table_stats(name,stats) =
      let
	val {size : int ,count : int ,smallest : int ,largest : int ,used : int, largest_row_contents} = stats
      in
	if count>0 then
	  (hash_info (name ^ " statistics: "^
                      "size = "^(Integer.makestring size)^
                      " count = "^(Integer.makestring count)^
                      "\n                              smallest = "^
                      (Integer.makestring smallest)^
                      " largest = "^(Integer.makestring largest)^
                      " used = "^(Integer.makestring used)))
	else ()
      end
  in
    fun print_stats () = 
      (print_hash_table_stats("LambdaHashTable",LambdaHashTable.stats());
       print_hash_table_stats("ReverseLambdaHashTable",ReverseLambdaHashTable.stats());
       print_hash_table_stats("OccCountHashTable",OccCountHashTable.stats());
       print_hash_table_stats("BlockSubstHashTable",BlockSubstHashTable.stats()))
  end


a297 3



d311 2
a312 14
   fun adjust_occurrence_counts(expr_count,expr) =
     let
       val occlist = find_all_marking_variables_in_expression(expr)
     in
       (map (fn x =>
            ((let
                val current = 
                  (OccCountHashTable.lookup(x)
                   handle OccCountHashTable.Lookup _ => 0)
            in
               OccCountHashTable.update(x,current + expr_count)
            end)))
       occlist)
     end
d314 29
a342 17
   fun deal_with_block(base,to_be_substituted,expr) =
     if LT.LVar_order(base,to_be_substituted)
       then 
         let
           fun update(expr as LT.VAR v) =
             if LT.LVar_order(base,v)
               then BlockSubstHashTable.lookup(v) 
             else expr
             | update expr = expr

           fun update_hash_table(count) =
             if LT.LVar_order(to_be_substituted,count)
               then ()
             else
               (BlockSubstHashTable.update
                (count, LS.apply_innermost update (fst(VarCountHashTable.lookup(count))));
                update_hash_table(LT.LVar_next count))
d344 14
a357 8
         in 
           (info(fn () => ("Deal with a block from " ^ 
                           LT.printLVar (base) ^
                           " upto " ^ LT.printLVar to_be_substituted)) ;
            update_hash_table (LT.LVar_next base);
            expr)
         end
     else expr
d359 27
d387 37
a423 10
  local
    fun clear_tables () = (LambdaHashTable.clear(); 
			   VarCountHashTable.clear();
			   OccCountHashTable.clear();
			   BlockSubstHashTable.clear();
			   ReverseLambdaHashTable.clear() ;
                           tried_to_locate := 0;
                           succeeded_in_locate := 0;
                           found_a_variable_more_than_once := false;
			   cse_marker := LT.new_LVar())
a424 26
    fun get_var key =
      let
	val expanded as (full_expr,size_of_full_expr) = expand_subexprs key
      in
	let
	  val var = LambdaHashTable.lookup expanded
	  val (expr,count) = VarCountHashTable.lookup(var)
	  val _ = 
	    VarCountHashTable.update((var,(expr,count+1)))
          val _ = found_a_variable_more_than_once := true
	in
	  LT.VAR var
	end
      handle LambdaHashTable.Lookup _ => 
	let
	  val newvar = LT.new_LVar()
	  val _ = 
	    LambdaHashTable.update (expanded,newvar)
	  val _ =
	    ReverseLambdaHashTable.update(newvar,expanded)
	  val _ = 
	    VarCountHashTable.update((newvar,(key,0)))
	in
	  LT.VAR newvar
	end
      end
a425 3
  in
    fun eliminate_common_subexprs (LT.Info{is_shiftable,...}) =
      let
d428 9
a436 9

	   val _ = clear_tables()

	   val _ = info (fn () => "Converting sub-expressions to lambda-variables...");
	   val _ = info (fn () => ("Lowest value for a marker variable is " ^ Integer.makestring(LT.int_of_LVar (! cse_marker))))

	   (*  Convert sub-expressions into lambda-variables. *)

	   fun varify context_opt lambda_exp =
d467 1
a467 1
		    LT.VAR x => (OccCountHashTable.update(x,1))
d473 1
a473 1
		     (OccCountHashTable.lookup(var) 
d481 1
a481 1
		       val real_expr = #1 (ReverseLambdaHashTable.lookup var)
d548 1
a548 1
                                        val (found,res) = (true,BlockSubstHashTable.lookup(v))
d718 1
a718 16
(*			      let
				fun bindings_in le =
				  let
				    fun f (LT.FN (v,_,_,_),vs) = v::vs
				      | f (LT.LET(v,_,_),vs) = v::vs
				      | f (LT.LETREC(lvl,_,_),vs) = lvl@@vs
				      | f (_,x) = x
				  in
				    LS.reduce_innermost f (le,[])
				  end
				in
				  case bindings_in subexpr of
				    (vs as _::_) => Print.print ("Warning: likely duplication of lambda-variable bindings, for CSE v"^(LT.printLVar var)^"\n"^
 						        "         variables: "^(Set.set_print (Set.list_to_set vs,LT.printLVar))^"\n")
				  | _ => ()
			      end;   *)
d736 1
a736 1
		     val (expr',count') = VarCountHashTable.lookup( count)
d747 2
a748 1
                           ((BlockSubstHashTable.lookup v) handle BlockSubstHashTable.Lookup _ => le)
d761 4
a764 2
	       val _ = print_stats();   (* #### to see stats *)
                     
d771 2
a772 1
			 then Timer.time_it("Varifying", fn () => (LS.apply_innermost_with_context varify expression))
d785 17
a801 22
     in
       fn expression =>
       let
	 val transformed = transform_letrecs expression
         val (modified,result) = elim_subexprs transformed
         val _ = if !show_result_info andalso !tried_to_locate > 0
                   then output(std_out,
                               "Tried to abstract in " ^ Integer.makestring(! tried_to_locate) ^
                               " cases with success in " ^ Integer.makestring(! succeeded_in_locate) ^
                               "\n")
                 else ()
       in
         if modified
           then 
	     (*let exception X in
	       ((LS.check_validity (result,X); result)
		handle X => (Print.print "!!! renaming after CSE...\n";
			     LS.rename_fresh result))
	     end*)
	     LS.rename_fresh result
         else transformed
       end
d803 5
a807 1
  end;  (* of local *)
a808 6

end (* of functor *)



(* $Log: _optimise_cse.sml,v $
@


1.28
log
@Reverted to checking is_in_evaluation_set before
lifting: without doing this we lift invalid selects
across switches!
@
text
@d51 1
a51 1
  val show_debug_info = ref true;
d867 5
@


1.27
log
@Removed spurious control character from the
end of the file  (don't know how it got there!?)
@
text
@d352 1
a352 1
(* heuristic for lifting *)
d354 4
d359 2
d363 2
a364 2
  fun will_be_evaluated (expr,inexpr) = true    (* always lift! *)
  (*LS.is_in_evaluation_set expr inexpr*)
d867 4
@


1.26
log
@Minor changes, new flag for printing results.
@
text
@d861 3
a969 1

@


1.25
log
@Removed some of the debugging tests and printing.
@
text
@d57 1
d309 2
a310 1
	 (fn x => LS.whnf x orelse LS.is_shiftable x orelse is_ok_letrec x)
d321 6
a326 7
	  [lv] => (true, lv)
	| _ => (false, new_lv)
	val lv_assoc =
	  if one_lv then
	    map (fn x => (x, new_lv)) lv_list
	  else
	    map (fn x => (x, LT.new_LVar())) lv_list
d352 1
a352 1
(* heuristics for lifting *)
a457 4
    fun check_intersection([], _) = false
    | check_intersection(x :: xs, set) =
      Set.is_member(x, set) orelse check_intersection(xs, set)

d614 2
d617 5
a621 15
				   if new_count = occns then
				     let
				       val (_, frees_set) =
					 LS.bounds_and_frees real_expr
				     in
				       if check_intersection(lvl, frees_set)
                                         then
                                           raise BombOut
				       else
					 deal_with(LT.LETREC (lvl,bodies,body),
						   new_count, frees)
				     end
				   else
				     deal_with(LT.LETREC (lvl,bodies,body),
					       new_count, frees)
d816 3
a818 1
	     val exp = Timer.time_it("Varifying", fn () => (LS.apply_innermost_with_context varify expression))
d822 3
a824 1
                 (true,Timer.time_it("Unvarifying",fn () => unvarify (exp)))
d833 1
a833 1
	 val transformed = Timer.time_it("Transforming the letrecs",fn () => transform_letrecs expression)
d835 1
a835 1
         val _ = if !tried_to_locate > 0
d844 1
a844 1
	     let exception X in
d848 2
a849 1
	     end
d861 3
@


1.24
log
@Added LET constructor and new slot to APP.
Attempted fix of scope-escape problem -
still needs work.
@
text
@d248 5
d275 1
d299 63
a462 47
	fun is_ok_letrec(LT.LETREC(_, _, le)) =
	  (case le of
	     LT.VAR _ => true
	   | LT.LETREC _ => is_ok_letrec le
	   | LT.STRUCT le_list =>
	       Lists.forall
	       (fn x => LS.whnf x orelse is_shiftable x orelse is_ok_letrec x)
	       le_list
	     | _ => false)
	| is_ok_letrec _ = false

	fun transform_letrecs(le as LT.LETREC(lv_list, le_list, le')) =
	  if is_ok_letrec le then LS.apply_one_level transform_letrecs le
	  else
	    let
	      val new_lv = LambdaTypes.new_LVar()
	      val (one_lv, the_lv) = case lv_list of
		[lv] => (true, lv)
	      | _ => (false, new_lv)
	      val lv_assoc =
		if one_lv then
		  map (fn x => (x, new_lv)) lv_list
		else
		  map (fn x => (x, LT.new_LVar())) lv_list
	      val var_new_lv = LT.VAR new_lv
	      (* For the LETREC itself *)
	      val le' =
		transform_letrecs(LS.substitute_list(lv_assoc, le'))
	      val le'' =
		if one_lv then
		  LambdaTypes.VAR the_lv
		else
		  LT.STRUCT(map LT.VAR lv_list)
	      val le_list = map transform_letrecs le_list
	      val new_letrec = LT.LETREC(lv_list, le_list, le'')
	      val len = Lists.length le_list
	      val bindings =
		if one_lv then []
		else
		  #1 (Lists.number_from_by_one
		      (map #2 lv_assoc, 0,
		       fn x => LT.SELECT({index=x, size=len}, var_new_lv)))
	    in
	      LS.wrap_lets(le', (new_lv, new_letrec) :: bindings)
	    end
	| transform_letrecs le = LS.apply_one_level transform_letrecs le

d516 2
a517 2
(*		       val expr2 =
			 deal_with_block(var,to_be_substituted,expr2)  *)
d523 1
a523 1
		       val frees = #1 (LS.bounds_and_frees real_expr)
d525 2
a526 1
		       fun eqvar v x = LT.LVar_eq(v,x)
d528 8
a535 2
		       val non_cse_frees = 
			 ref (Lists.filterp                 (* actually, no effect since no cses in real_expr *)
d538 1
a538 1

d542 1
a542 2
                                           LambdaPrint.string_of_lambda subexpr ^
                                           "\n"));
d561 1
a561 1
			       fun deal_with (inexpr,num) =
d563 3
a565 5
				   if (!non_cse_frees = []) then
				   if LS.whnf subexpr orelse
				     LS.is_in_evaluation_set (LT.VAR var) inexpr
				     orelse
				     is_ok_letrec subexpr
d571 1
a571 3
(*						LT.LET(var,subexpr,inexpr) *)
						LT.APP(LT.FN(var,inexpr,"Introdued in _optimise_cse",
                                                             LT.null_type_annotation()),subexpr,LT.null_type_annotation())
d577 1
a577 1
				   else (Print.print "couldn't lift because of free var problem\n";
d581 1
a581 1
			       fun locate (le as LT.VAR v) = 
d590 2
a591 2
                                            locate res
                                        else deal_with (le,if v=var then 1 else 0)
d594 2
a595 2
                                    deal_with (le,if v=var then 1 else 0)
				 | locate (LT.FN(lv, le,name,ty)) =
d597 1
a597 4
				   val (body,count) = locate le
				   val _ = if count<=occns
					     then non_cse_frees := Lists.filter_outp (eqvar lv) (!non_cse_frees)
					   else ()
d599 1
a599 1
				   deal_with (LT.FN(lv,body,name,ty),count)
d601 1
a601 1
				 | locate (LT.LET(lv,lb,le)) = 
d603 3
a605 6
				     val (lb',count) = locate lb
				     val (le',count') = locate le
				     val count = count+count'
				   val _ = if count<=occns
					     then non_cse_frees := Lists.filter_outp (eqvar lv) (!non_cse_frees)
					   else ()
d607 1
a607 1
				     deal_with(LT.LET(lv,lb',le'),count)
d609 1
a609 1
				 | locate (LT.LETREC(lvl, lel, le)) =
d611 5
a615 2
				   val (bodies,counts) = Lists.unzip(map locate lel)
				   val (body,count) = locate le
d620 1
a620 1
				       val (_, frees) =
d623 1
a623 1
				       if check_intersection(lvl, frees)
d628 1
a628 1
						   new_count)
d632 1
a632 1
					       new_count)
d634 1
a634 1
                                 | locate (LT.APP(p, q, ty)) =
d636 2
a637 2
                                     val (body,count) = locate p
                                     val (body',count') = locate q
d639 1
a639 1
                                     deal_with(LT.APP(body,body',ty),count + count')
d642 2
a643 2
                                 | locate (le as LT.SCON _) = 
                                   deal_with(le,0)
d645 2
a646 2
                                 | locate (le as LT.INT _) = 
                                   deal_with(le,0)
d648 1
a648 1
                                 | locate (context as LT.SWITCH(le, clel, leo1, leo2)) = 
d650 1
a650 1
                                     val (body,count) = locate le
d660 1
a660 1
                                               (fn (LT.EXP_TAG le) => le
d671 1
a671 1
                                              val (a,b) = locate f
d680 1
a680 1
                                              val (a,b) = locate f
d685 1
a685 1
                                     val (bodies,counts) = Lists.unzip (map locate codes)
d692 2
a693 1
					     counts' + add_up counts)
d696 1
a696 1
			       | locate (LT.STRUCT lel) =
d698 1
a698 1
				   val (bodies,counts) = Lists.unzip (map locate lel)
d701 1
a701 1
				   deal_with(LT.STRUCT (bodies) , count)
d704 1
a704 1
			       | locate (context as LT.SELECT (fld, le)) =
d706 1
a706 1
				   val (body,count) = locate le
d708 1
a708 1
				   deal_with(LT.SELECT (fld, body) ,count)
d711 1
a711 1
			       | locate (context as LT.RAISE le) =
d713 1
a713 1
				   val (body,count) = locate le
d715 1
a715 1
				   deal_with(LT.RAISE (body) ,count)
d718 1
a718 1
			       | locate (LT.HANDLE (le1, le2,annotation)) =
d720 2
a721 2
				   val (body,count) = locate le1
				   val (body',count') = locate le2
d723 1
a723 1
				   deal_with(LT.HANDLE(body,body',annotation), count + count')
d726 2
a727 2
			       | locate (le as LT.BUILTIN _) = 
				 deal_with(le,0)
d734 1
a734 1
				val (res, count) = locate expr2
d752 1
a752 1
				   (LS.substitute(var,subexpr,expr2),LT.LVar_previous var))   (****)
d763 1
a763 1
			      let
d778 2
a779 2
			      end;
			      (LS.substitute(var,subexpr,expr2),LT.LVar_previous var))   (*****)
d783 2
a784 1
			 (LS.substitute(var,subexpr,expr2),LT.LVar_previous var (*to_be_substituted*)))
d867 5
@


1.23
log
@Added an annotation slot to HANDLE
@
text
@a20 1
require "../utils/table";
a36 1
  structure Table : TABLE
d42 1
d47 2
d193 1
a193 3
                 if st=""
                   then 2
                 else convert(String.size st,0)
d210 1
d212 1
a212 1
	   | h (depth,bvs, APP (e1,e2)) = ug (15 * h(depth-1,bvs,e1) + 17 * h(depth-1,bvs,e2)) 
d437 1
a437 3
	      LS.wrap_lets(le', 
                           (new_lv, new_letrec,"wrap_let in _optimise_cse",LT.null_type_annotation()) :: 
                           (map (fn (a,b) => (a,b,"wrap_let in _optimise_cse",LT.null_type_annotation())) bindings))
d455 1
d464 1
a464 1
		    LT.PRESENT(LT.APP(LT.BUILTIN _,_)) => lambda_exp
d492 18
a509 5
                     then 
                       let
                         val expr2 =
                           deal_with_block(var,to_be_substituted,expr2)
                         val real_expr = #1 (ReverseLambdaHashTable.lookup var)
d515 1
a515 1
			     is_shiftable real_expr)
d535 1
d545 1
d547 1
a547 1
                                                             LT.null_type_annotation()),subexpr)
d553 2
d571 1
a571 1
                       | locate (LT.FN(lv, le,name,ty)) =
d574 3
d580 12
a591 1
			       | locate (context as LT.LETREC(lvl, lel, le)) =
d613 1
a613 1
                                 | locate (LT.APP(p, q)) =
d618 1
a618 1
                                     deal_with(LT.APP(body,body'),count + count')
d722 3
a724 1
				info (fn () => ("Size is now " ^
d730 1
a730 1
				   (expr2,var))
d735 2
d741 17
a757 1
			      (expr2,var))
d761 1
a761 1
			 (expr2,to_be_substituted))
d827 6
a832 1
           then LS.rename_fresh result
d844 3
@


1.22
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d236 1
a236 1
             | h (depth,bvs, HANDLE (e1,_)) = ug(53 * h(depth-1,bvs,e1))
d666 1
a666 1
			       | locate (LT.HANDLE (le1, le2)) =
d671 1
a671 1
				   deal_with(LT.HANDLE(body,body'), count + count')
d789 3
@


1.21
log
@A few speed improvements including specialising the hash equality function
@
text
@d789 3
@


1.20
log
@Print out more useful information on bucket overflow
@
text
@d86 1
a86 1
    val eq = (op =)
d98 1
a98 1
    val eq = (op =)
d110 1
a110 1
    val eq = (op =)
d124 1
a124 1
       val eq = (op =)
d197 1
a197 1
             | h (_,bvs, INT _)  = 3
d211 1
a211 1
	   | h (depth,bvs, FN (bv,e,_)) = ug(13 * (h (depth-1,bv::bvs, e)))
d213 17
a229 3
	   | h (depth,bvs, SWITCH(e,cases as ((_,e1)::_),_,_)) = 
             ug(29 * h (depth-1,bvs,e1)+ 19 * Lists.length cases)
	   | h (depth,bvs, SWITCH(e,_,_,_)) = ug (19 * h (depth-1,bvs,e))
d438 2
a439 2
                           (new_lv, new_letrec,"wrap_let in _optimise_cse") :: 
                           (map (fn (a,b) => (a,b,"wrap_let in _optimise_cse")) bindings))
d532 2
a533 1
						LT.APP(LT.FN(var,inexpr,"Introdued in _optimise_cse"),subexpr)
d555 1
a555 1
                       | locate (LT.FN(lv, le,name)) =
d559 1
a559 1
				   deal_with (LT.FN(lv,body,name),count)
d763 1
a763 1
	  
d789 3
@


1.19
log
@Added a measure of size to the hash function to help with some awkward cases JonT came up with
@
text
@d234 11
a244 3
       fun hash_generator(0) = (hash hash_function_depth,true)
         | hash_generator(1) = (output(std_out,"Adjusting the hash function due to bucket overflow\n");
                                (hash ~1,false))
d774 3
@


1.18
log
@Another factor of 3 improvement due to making the substitution by demand rather than eager -
locate walks the tree and does the substitution when it hits something that need expanding
@
text
@d121 1
a121 1
       type Value  = LambdaExp
d130 1
a130 1
  val expand_subexprs =
d132 2
d136 12
a147 5
	  ReverseLambdaHashTable.lookup(v)
	else expr
      | expand expr = expr
     in
	LS.apply_innermost expand
d158 1
a158 1
       type Key    = LambdaExp
d166 1
a166 1
       fun hash depth x = 
d187 9
d198 2
a199 2
             | h (depth,bvs, BUILTIN _) = 5
             | h (depth,bvs, VAR v)  =
d228 2
a229 1
           val result = h (depth,[],x)
d235 2
a236 1
         | hash_generator(1) = (hash ~1,false)
d241 1
a241 1
       fun eq(x,y) = LS.alpha_convertible (x, y);
d340 1
a340 1
	val full_expr = expand_subexprs key
d343 1
a343 1
	  val var = LambdaHashTable.lookup full_expr
d355 1
a355 1
	    LambdaHashTable.update (full_expr,newvar)
d357 1
a357 1
	    ReverseLambdaHashTable.update(newvar,full_expr)
d475 1
a475 1
                         val real_expr = ReverseLambdaHashTable.lookup var
d746 6
a751 4
         val _ = output(std_out,
                        "Tried to abstract in " ^ Integer.makestring(! tried_to_locate) ^
                        " cases with success in " ^ Integer.makestring(! succeeded_in_locate) ^
                        "\n")
d766 4
@


1.17
log
@First version of the profiler
@
text
@d9 8
d19 2
d26 2
d33 3
d43 1
d53 7
d71 1
d73 3
a84 1
    val modval  = 32768
a96 1
    val modval  = 32768
a108 1
    val modval  = 32768
a122 1
       val modval  = 32768
d144 1
a144 1
  structure HashSpec : HASHSPEC = 
a151 1
       val modval  = 32768
d157 1
a157 2
   
       fun hash x = 
d160 8
a167 3
	   fun a isin [] = false
	   | a isin (b::bs) = LT.LVar_eq(a, b) orelse (a isin bs)
 
d169 1
d171 1
a171 23
	   fun h (bvs, SCON _) = 2
	   | h (bvs, INT _)  = 3
	   | h (bvs, BUILTIN _) = 5
	   | h (bvs, VAR v)  =
	     if (v isin bvs) then 7
	     else 
	       if represents_cse v
		 then 
		   h (bvs, fst(VarCountHashTable.lookup(v)))
	       else (11 + (int_of_LVar v))
	   | h (bvs, FN (bv,e,_)) = 13 + (h (bv::bvs, e))
	   | h (bvs, APP (e1,e2)) = ug (15 * h(bvs,e1) + 17 * h(bvs,e2)) 
	   | h (bvs, SWITCH(e,_,_,_)) = ug (19 * h (bvs,e))
	   | h (bvs, STRUCT [e]) = 23 + h (bvs,e)
	   | h (bvs, STRUCT (e1::e2::_)) = ug(29 * h (bvs,e1)+ 31 * h (bvs,e2))
	   | h (bvs, SELECT ({index,size},e)) =
	     ug(37 + 41 * index + 43 * h(bvs,e))
	   | h (bvs, RAISE e) = ug(47 * h(bvs,e))
	   | h (bvs, HANDLE (e1,_)) = ug(53 * h(bvs,e1))
	   | h (bvs, LETREC ([bv],[e],_)) = ug(59 * h(bv::bvs,e))
	   | h (bvs, LETREC (bvs',e1::e2::_,_)) =
	     ug(61 * h(bvs' @@bvs,e1) + 67 * h(bvs' @@bvs,e2))
	   | h _ = 1
d173 38
d212 1
a212 1
	   h ([],x)
d215 6
d225 1
a225 1
  structure LambdaHashTable = HashTable(HashSpec);
d231 1
a231 1
	val {size : int ,count : int ,smallest : int ,largest : int ,used : int } = stats
d234 7
a240 7
	  info (name ^ " statistics: "^
		"size = "^(Integer.makestring size)^
		" count = "^(Integer.makestring count)^
		"\n                              smallest = "^
		(Integer.makestring smallest)^
		" largest = "^(Integer.makestring largest)^
		" used = "^(Integer.makestring used))
a251 13
(* fun find_all_marking_variables_in_expression(expression) =
     let
       val l = ref([] : LT.LVar list)
       fun test(expr as LT.VAR x) =
         if represents_cse(x)
           then ( l := x :: (! l) ;
                 expr)
         else expr
           | test expr = expr
     in
       (LS.apply_innermost test expression;
        ! l)
     end *)
d285 1
a285 1
               then BlockSubstHashTable.lookup(v)
d298 3
a300 3
           (info("Deal with a block from " ^ 
                   LT.printLVar (base) ^
                   " upto " ^ LT.printLVar to_be_substituted) ;
d302 1
a302 4
            let val x = LS.apply_innermost update expr
              in 
                (info ("... finished") ; x)
            end)
d313 3
a323 7
(*
	  val _ = Print.print("Lookup full expr\n" ^
			      LambdaPrint.string_of_lambda full_expr ^
			      "\nPartial expr\n" ^
			      LambdaPrint.string_of_lambda key ^
			      "\ngives " ^ LT.printLVar var ^ "\n")
*)
d327 1
a335 7
(*
	  val _ = Print.print("Lookup of full expr\n" ^
			      LambdaPrint.string_of_lambda full_expr ^
			      "\nPartial expr\n" ^
			      LambdaPrint.string_of_lambda key ^
			      "\ngives " ^ LT.printLVar newvar ^ "\n")
*)
d406 2
a407 2
	   val _ = info "Converting sub-expressions to lambda-variables...";
	   val _ = info ("Lowest value for a marker variable is " ^ Integer.makestring(LT.int_of_LVar (! cse_marker)))
a411 4
(*
	     (Print.print("Varifying\n" ^ LambdaPrint.string_of_lambda lambda_exp ^
		    "\n");
*)
a428 3
(*
)
*)
d436 1
a436 1
	       val _ = info "Abstracting out CSE's"
d450 6
a455 5
		   if occns>1 then 
		     let
		       val expr2 =
			 deal_with_block(var,to_be_substituted,expr2)
		       val real_expr = ReverseLambdaHashTable.lookup var
d457 5
a461 13
		       if (info ("subexpr appears more than once: v"^
				 (LT.printLVar var) ^ "\n" ^
				 LambdaPrint.string_of_lambda subexpr ^
				 "\n");
			   let
(*
			     val _ = Print.print("Real expr =\n" ^
						 LambdaPrint.string_of_lambda
						 real_expr ^ "\n")
*)
			   in
			     is_shiftable real_expr
			   end)
d466 1
a466 5
(*
			     val _ =
			       Print.print("Finding smallest subexpression for "
			       ^ (LT.printLVar var) ^ "\n")
*)
a481 7
(*
				     (Print.print("Checking is_in_eval_set of\nv" ^
					    LT.printLVar var ^
					    "\nin\n" ^
					    LambdaPrint.string_of_lambda
					    inexpr ^ "\n");
*)
a482 3
(*
)
*)
d485 3
a487 3
				     then (info ("abstracting for v"^
						 (LT.printLVar var));
					    adjust_occurrence_counts(1,subexpr) ;
a494 4
(*
				     (Print.print("Bombing out on " ^
						  LT.printLVar var ^ "\n");
*)
a495 3
(*
					)
*)
d499 14
a512 2
				 deal_with (le,if v=var then 1 else 0)
			       | locate (LT.FN(lv, le,name)) =
a522 8
(*
				   val _ =
				     Print.print("LETREC context with " ^
						 (if new_count = occns then
						    "new_count = occns\n"
						  else
						    "new_count <> occns\n"))
*)
d529 3
a531 8
				       if check_intersection(lvl, frees) then
(*
					 (Print.print("Bombing out trying to abstract outside binding LETREC\n");
*)
					  raise BombOut
(*
					    )
*)
d540 56
a595 56
			       | locate (LT.APP(p, q)) =
				 let
				   val (body,count) = locate p
				   val (body',count') = locate q
				 in 
				   deal_with(LT.APP(body,body'),count + count')
				 end
                                     
			       | locate (le as LT.SCON _) = 
				 deal_with(le,0)
                                       
			       | locate (le as LT.INT _) = 
				 deal_with(le,0)
                                       
			       | locate (context as LT.SWITCH(le, clel, leo1, leo2)) = 
				 let
				   val (body,count) = locate le
				   val (tags,codes) = Lists.unzip clel
				   val (tags, counts') = case tags of
				     LT.EXP_TAG _ :: _ =>
				       let
					 val (tags, counts) =
					   Lists.unzip
					   (map
					    locate
					    (map
					     (fn (LT.EXP_TAG le) => le
					   | _ => Crash.impossible"Mixed tag type")
					     tags))
				       in
					 (map LT.EXP_TAG tags, add_up counts)
				       end
				   | _ => (tags, 0)
				   val (body',count') =
				     (case leo1 of
					LT.PRESENT f =>
					  let
					    val (a,b) = locate f
					  in
					    (LT.PRESENT a,b)
					  end
				      | LT.ABSENT => (LT.ABSENT,0))
				   val (body'',count'') =
				     (case leo2 of
					LT.PRESENT f =>
					  let
					    val (a,b) = locate f
					  in
					    (LT.PRESENT a,b)
					  end
				      | LT.ABSENT => (LT.ABSENT,0))
				   val (bodies,counts) = Lists.unzip (map locate codes)
				 in
				   deal_with(LT.SWITCH
					     (body,
					      Lists.zip(tags,bodies),
d638 1
d647 1
a647 2
				val _ =
				  BlockSubstHashTable.update(var,LT.VAR var)
d649 2
a650 2
				info ("Size is now " ^
				      Integer.makestring(LS.size_of_expr res));
d667 1
a667 1
		   else (adjust_occurrence_counts(occns,subexpr) ;
d686 12
a697 1
		   deal_with_block(count,to_be_substituted,expr)
d711 1
a711 5
(*
	     val _ = print("Varifying\n" ^ LambdaPrint.string_of_lambda expression)
	     val exp = (LS.apply_innermost_with_context varify expression)
	     val _ = print("Unvarifying\n" ^ LambdaPrint.string_of_lambda exp)
*)
d713 5
a717 1
	     unvarify (LS.apply_innermost_with_context varify expression)
d722 1
a722 1
       fn x =>
d724 6
a729 5
	 val y = transform_letrecs x
(*
	 val _ = Print.print("Applying CSE to\n" ^
			     LambdaPrint.string_of_lambda y ^ "\n")
*)
d731 3
a733 1
	 LS.rename_fresh(elim_subexprs y)
d735 1
a735 4
(*
       elim_subexprs o transform_letrecs
*)
     end
d744 3
d785 1
a785 1
  (6) used is_in_evaluation_set (a predicate0 instead of the function and a membership test
@


1.16
log
@Removed pervasive print. Added Integer parameter to functor
@
text
@d154 1
a154 1
	   | h (bvs, FN (bv,e)) = 13 + (h (bv::bvs, e))
d372 3
a374 1
	      LS.wrap_lets(le', (new_lv, new_letrec) :: bindings)
d495 1
a495 1
						LT.APP(LT.FN(var,inexpr),subexpr)
d512 1
a512 1
			       | locate (LT.FN(lv, le)) =
d516 1
a516 1
				   deal_with (LT.FN(lv,body),count)
d746 3
@


1.15
log
@Fixed problem whereby bindings could get duplicated by renaming
entire expression using new rename_fresh from lambdasub
@
text
@d9 1
d15 1
d25 1
d35 5
a39 1
  fun info message = if !show_debug_info then print message else ()
d140 1
a140 1
	   | a isin (b::bs) = (a=b) orelse (a isin bs)
d186 2
a187 2
		"size = "^(makestring size)^
		" count = "^(makestring count)^
d189 3
a191 3
		(makestring smallest)^
		" largest = "^(makestring largest)^
		" used = "^(makestring used))
d382 1
a382 1
	   val _ = info ("Lowest value for a marker variable is " ^ makestring(LT.int_of_LVar (! cse_marker)))
d466 1
a466 1
				   fun add1([],x) = x
d661 1
a661 1
				      makestring(LS.size_of_expr res));
d744 4
@


1.14
log
@Fixed bug whereby common subexprs were being lifted outside LETRECs
defining some of their free variables
@
text
@d723 1
a723 1
	 elim_subexprs y
d737 4
@


1.13
log
@Fixed bugs in cse whereby expression tags were being ignored,
and functions were becoming alpha-convertible when LETRECs weren't
abstacted
@
text
@d210 6
a215 6
fun find_all_marking_variables_in_expression(expression) =
  let
    fun test(expr as LT.VAR x,l) =
      if represents_cse(x)
        then x::l
      else l
d217 3
a219 3
  in
    LS.reduce_innermost test (expression,[])
  end 
d316 4
a319 1
      
d429 1
a435 1
			     val real_expr = ReverseLambdaHashTable.lookup var
d514 29
a542 2
				 in 
				   deal_with(LT.LETREC (lvl,bodies,body),new_count)
d737 5
@


1.12
log
@Used the zip from the Lists module instead of my own
@
text
@d1 1
a1 1

d13 1
d18 8
a25 7
functor OptimiseCSE
  (structure Lib   : OPTIMISE_LIB
   structure Crash : CRASH
   structure Table : TABLE
   structure LambdaPrint : LAMBDAPRINT
   structure Lists : LISTS
   sharing LambdaPrint.LambdaTypes = Lib.LT) : OPTIMISE_CSE =
d27 1
d101 6
a106 6
     let
	fun expand (expr as LT.VAR v) = if represents_cse v 
					   then 
                                             ReverseLambdaHashTable.lookup(v)
					else expr
	  | expand expr = expr
d130 1
a130 1
	let
d133 1
a133 1
	     | a isin (b::bs) = (a=b) orelse (a isin bs)
d138 28
a165 32
	     | h (bvs, INT _)  = 3
	     | h (bvs, BUILTIN _) = 5
	     | h (bvs, VAR v)  = if (v isin bvs) then 7
				 else 
				    if represents_cse v
				       then 
					  h (bvs,
					     fst(VarCountHashTable.lookup(v)))
				    else (11 + (int_of_LVar v))
	     | h (bvs, FN (bv,e)) = 13 + (h (bv::bvs, e))
	     | h (bvs, APP (e1,e2)) = ug (15 * h(bvs,e1) + 
					  17 * h(bvs,e2)) 
	     | h (bvs, SWITCH(e,_,_,_)) = ug (19 * h (bvs,e))
	     | h (bvs, STRUCT [e]) = 23 + h (bvs,e)
	     | h (bvs, STRUCT (e1::e2::_)) = ug(29 * h (bvs,e1)+
						31 * h (bvs,e2))
	     | h (bvs, SELECT ({index,size},e)) = ug(37 + 41 * index
					  + 43 * h(bvs,e))
	     | h (bvs, RAISE e) = ug(47 * h(bvs,e))
	     | h (bvs, HANDLE (e1,_)) = ug(53 * h(bvs,e1))
	     | h (bvs, LETREC ([bv],[e],_)) = ug(59 * h(bv::bvs,e))
	     | h (bvs, LETREC (bvs',e1::e2::_,_)) = ug(61 * 
						       h(bvs' @@bvs,e1) +
						       67 *
						       h(bvs' @@bvs,e1))
	     | h _ = 1
	in
	    h ([],x)
	end
		     
       fun eq(x,y) = LS.alpha_convertible ((*expand_subexprs*) x,
					   (*expand_subexprs*) y);
d168 1
a168 1
    
d172 22
a193 20
local
  fun print_hash_table_stats(name,stats) =
    let val {size : int ,count : int ,smallest : int ,largest : int ,used : int } = stats
    in if count>0
         then info (name ^ " statistics: "^
                    "size = "^(makestring size)^
                    " count = "^(makestring count)^
                    "\n                              smallest = "^
                    (makestring smallest)^
                    " largest = "^(makestring largest)^
                    " used = "^(makestring used))
       else ()
    end
in
  fun print_stats () = 
    (print_hash_table_stats("LambdaHashTable",LambdaHashTable.stats());
     print_hash_table_stats("ReverseLambdaHashTable",ReverseLambdaHashTable.stats());
     print_hash_table_stats("OccCountHashTable",OccCountHashTable.stats());
     print_hash_table_stats("BlockSubstHashTable",BlockSubstHashTable.stats()))
end
d268 6
a273 6
   fun clear_tables () = (LambdaHashTable.clear(); 
                          VarCountHashTable.clear();
                          OccCountHashTable.clear();
                          BlockSubstHashTable.clear();
                          ReverseLambdaHashTable.clear() ;
			  cse_marker := LT.new_LVar())
d275 1
a275 1
   fun get_var key = 
d277 1
a277 1
	 val full_expr = expand_subexprs key
d279 34
a312 20
	 (let
	     val var = LambdaHashTable.lookup full_expr
	     val (expr,count) = VarCountHashTable.lookup(var)
	     val _ = 
               VarCountHashTable.update((var,(expr,count+1)))
	  in
	     LT.VAR var
	  end)
	     handle LambdaHashTable.Lookup _ => 
		(let
		    val newvar = LT.new_LVar()
		    val _ = 
                      LambdaHashTable.update (full_expr,newvar)
                    val _ =
                      ReverseLambdaHashTable.update(newvar,full_expr)
		    val _ = 
                      VarCountHashTable.update((newvar,(key,0)))
		 in
		    LT.VAR newvar
		 end)
a314 1
	
d317 50
a366 3
   fun eliminate_common_subexprs (LT.Info{is_shiftable,...}) =
    let
       fun elim_subexprs expression =
d369 1
a369 1
	     val _ = clear_tables()
d371 2
a372 2
	     val _ = info "Converting sub-expressions to lambda-variables...";
             val _ = info ("Lowest value for a marker variable is " ^ makestring(LT.int_of_LVar (! cse_marker)))
d374 1
a374 1
	     (*  Convert sub-expressions into lambda-variables. *)
d376 25
a400 18
	     fun varify context_opt lambda_exp =
	       case lambda_exp of
		 LT.VAR _ => lambda_exp
	       | LT.FN _ => get_var lambda_exp
	       | LT.LETREC _ => get_var lambda_exp
	       | LT.APP _ => get_var lambda_exp
	       | LT.SCON _ => lambda_exp
	       | LT.INT _ => lambda_exp
	       | LT.SWITCH _ => get_var lambda_exp
	       | LT.STRUCT [] => lambda_exp
	       | LT.STRUCT _ => 
		   (case context_opt of
		      LT.PRESENT(LT.APP(LT.BUILTIN _,_)) => lambda_exp
		    | _ => get_var lambda_exp)
	       | LT.SELECT _ => get_var lambda_exp
	       | LT.RAISE _ => get_var lambda_exp
	       | LT.HANDLE _ => get_var lambda_exp
	       | LT.BUILTIN _ => lambda_exp
d402 3
a404 3
	     (*  Common expressions are put into a LET enclosing the      *)
 	     (*  smallest possible lambda-expression.  An alternative     *)
	     (*  would be to put them as far out as possible, cf selects  *)
d406 3
a408 3
	     fun unvarify expr1 =
	      let
		 val _ = info "Abstracting out CSE's"
d410 5
a414 5
                 (* Expression is now represented by a single variable *)
                 val _ =
                   (case expr1 of
                      LT.VAR x => (OccCountHashTable.update(x,1))
                        | _ => ())
d417 36
a452 21
		  let
                    val occns = 
                      (OccCountHashTable.lookup(var) 
                       handle OccCountHashTable.Lookup _ => 0)
		  in
		     if occns>1
                       then 
                         let
                           val expr2 =
                             deal_with_block(var,to_be_substituted,expr2)
                         in
                           if (info ("subexpr appears more than once: v"^
                                     (LT.printLVar var));
                               (is_shiftable (ReverseLambdaHashTable.lookup(var))))
                             then
                               (* locate smallest sub-expression  *)
                               (* containing all instances of var *)
                               let
                                 exception BombOut
                                 
                                 local
d454 43
a496 24
                                   fun add_up x =
                                     let 
                                       fun add1([],x) = x
                                         | add1(h::t,x) = add1(t,h+x)
                                     in
                                       add1(x,0)
                                     end
                                 in
                                   fun deal_with (inexpr,num) =
                                     if num=occns
                                       then
                                         (if (LS.whnf subexpr) orelse
                                            (LS.is_in_evaluation_set (LT.VAR var) inexpr)
                                            then (info ("abstracting for v"^
                                                        (LT.printLVar var));
                                                  adjust_occurrence_counts(1,subexpr) ;
                                                  let
                                                    val new_code =
                                                      LT.APP(LT.FN(var,inexpr),subexpr)
                                                  in
                                                    (new_code,occns+1)
                                                  end)
                                          else raise BombOut)
                                     else (inexpr,num)
d498 23
a520 23
                                   fun locate (le as LT.VAR v) = 
                                     deal_with (le,if v=var then 1 else 0)
                                     | locate (LT.FN(lv, le)) =
                                       let 
                                         val (body,count) = locate le
                                       in
                                         deal_with (LT.FN(lv,body),count)
                                       end
                                     | locate (context as LT.LETREC(lvl, lel, le)) =
                                       let 
                                         val (bodies,counts) = Lists.unzip(map locate lel)
                                         val (body,count) = locate le
                                         val new_count = (count + add_up counts)
                                       in 
                                         deal_with(LT.LETREC (lvl,bodies,body),new_count)
                                       end
                                     | locate (LT.APP(p, q)) =
                                       let
                                         val (body,count) = locate p
                                         val (body',count') = locate q
                                       in 
                                         deal_with(LT.APP(body,body'),count + count')
                                       end
d522 2
a523 2
                                     | locate (le as LT.SCON _) = 
                                       deal_with(le,0)
d525 2
a526 2
                                     | locate (le as LT.INT _) = 
                                       deal_with(le,0)
d528 46
a573 28
                                     | locate (context as LT.SWITCH(le, clel, leo1, leo2)) = 
                                       let
                                         val (body,count) = locate le
                                         val (body',count') =
                                           (case leo1 of
                                              LT.PRESENT f =>
                                                let val (a,b) = locate f
                                                in
                                                  (LT.PRESENT a,b)
                                                end
                                            | LT.ABSENT => (LT.ABSENT,0))
                                         val (body'',count'') =
                                           (case leo2 of
                                              LT.PRESENT f =>
                                                let val (a,b) = locate f
                                                in
                                                  (LT.PRESENT a,b)
                                                end
                                            | LT.ABSENT => (LT.ABSENT,0))
                                         val (tags,codes) = Lists.unzip (clel)
                                         val (bodies,counts) = Lists.unzip (map locate codes)
                                       in
                                         deal_with(LT.SWITCH
                                                   (body,
                                                    Lists.zip(tags,bodies),
                                                    body',body''), 
                                                   count + count' + count'' + add_up counts)
                                       end
d575 7
a581 7
                                     | locate (LT.STRUCT lel) =
                                       let 
                                         val (bodies,counts) = Lists.unzip (map locate lel)
                                         val count = add_up counts
                                       in 
                                         deal_with(LT.STRUCT (bodies) , count)
                                       end
d583 6
a588 6
                                     | locate (context as LT.SELECT (fld, le)) =
                                       let
                                         val (body,count) = locate le
                                       in 
                                         deal_with(LT.SELECT (fld, body) ,count)
                                       end
d590 6
a595 6
                                     | locate (context as LT.RAISE le) =
                                       let
                                         val (body,count) = locate le
                                       in 
                                         deal_with(LT.RAISE (body) ,count)
                                       end
d597 7
a603 7
                                     | locate (LT.HANDLE (le1, le2)) =
                                       let
                                         val (body,count) = locate le1
                                         val (body',count') = locate le2
                                       in
                                         deal_with(LT.HANDLE(body,body'), count + count')
                                       end
d605 2
a606 2
                                     | locate (le as LT.BUILTIN _) = 
                                       deal_with(le,0)
d608 1
a608 1
                                 end
d610 21
a630 14
                               in
                                 (let
                                   val res = #1(locate expr2 )
                                   val _ =
                                      BlockSubstHashTable.update(var,LT.VAR var)
                                 in
                                   info ("Size is now " ^
                                         makestring(LS.size_of_expr res));
                                    (res,LT.LVar_previous var)
                                 end)
                                 handle BombOut => 
                                   (adjust_occurrence_counts(occns,subexpr) ;
                                    (expr2,var))
                               end
d632 8
a639 3
                           else (adjust_occurrence_counts(occns,subexpr) ;
                                 (expr2,var))
                         end
d641 2
a642 2
                     else (adjust_occurrence_counts(occns,subexpr) ;
                           (expr2,to_be_substituted))
d644 1
a644 1
		  end
d648 2
a649 2
                   val highest = (LT.new_LVar())
                   val lowest = (! cse_marker)
d651 10
a660 11
                   fun loop_through (count,(expr,to_be_substituted)) =
                     if LT.LVar_order(lowest,count)
                       then
                         let
                           val (expr',count') = VarCountHashTable.lookup( count)
                           val arg = (count,expr')
                         in
                           loop_through(LT.LVar_previous count,abs_smallest(expr,arg,to_be_substituted))
                         end
                     else 
                       deal_with_block(count,to_be_substituted,expr)
d662 1
a662 1
                   val prev_highest = LT.LVar_previous highest
d664 2
a665 2
                     val absd_exp = 
                       loop_through (prev_highest,(expr1,prev_highest))
d667 1
a667 1
                     val _ = print_stats();   (* #### to see stats *)
d669 11
a679 4
	      in
		 absd_exp
	      end
	  in
d681 2
a682 1
	  end
d684 15
a698 3
    in
       elim_subexprs 
    end
d707 3
d766 1
a766 1
 *)
@


1.11
log
@Took out check that the top level form after varification is a variable - this is not
true in the case of a signature definition
@
text
@a377 9

                                   fun unzip([],a,b) = (rev a,rev b)
                                     | unzip((x,y)::rest,a,b) = unzip (rest,x::a,y::b)
                                       
                                   fun zip ([],[],x) = x
                                     | zip (a::b,h::t,x) = zip(b,t,(a,h)::x)
                                     | zip (_,_,_) = raise Crash.impossible
                                       "zip problem in the lambda optimiser "

d406 1
a406 1
                                         val (bodies,counts) = unzip(map locate lel,[],[])
d445 2
a446 2
                                         val (tags,codes) = unzip (clel,[],[])
                                         val (bodies,counts) = unzip (map locate codes,[],[])
d450 1
a450 1
                                                    zip(tags,bodies,[]),
d457 1
a457 1
                                         val (bodies,counts) = unzip (map locate lel,[],[])
d556 4
@


1.10
log
@Optimised the original functional form of this code, which carried out
a lot of recomputation - considered every function call and tried to
implement it using something that had been computed before
  (1) used a hash table instead of the original table - things were added
 to the table incrementally so that it basically simulated an association list
  (2) instead of calling a function to calculate occurrences, a used a table to
compute them incrementally
  (3) expand_subexpr (to expand expressions) was called unnecessarily and used
apply_outermost instead of apply_innermost plus previously calculated values
stored in a hash table
  (4) added ReverseLambdaHashTable to calculate the inverses to the LambdaHashTable
  (5) optimised the substitutions of many small expressions into a large one, by batching
them together, and applying the small expressions to each other before doing one
substitution into the large expression
  (6) used is_in_evaluation_set (a predicate0 instead of the function and a membership test
@
text
@d343 1
a343 1
                 val x =
d345 2
a346 4
                      LT.VAR x => x
                      | _ => raise Crash.impossible 
                          "Someone has changed the lambda optimiser - what a shame ...")
                 val _ = OccCountHashTable.update(x,1)
d565 17
@


1.9
log
@Reduced the run time of the optimiser by 50% by
 (1) Hashing the varcount_table
 (2) Using the occurrence counts (defined but not used in the existing code), to
     allow us to omit some calls to LS.occurrences
@
text
@d12 1
d19 1
d55 10
d66 31
d101 1
a101 1
                                             fst(VarCountHashTable.lookup(v))
d105 1
a105 1
	LS.apply_outermost expand
a106 1
      
d108 1
d165 2
a166 2
       fun eq(x,y) = LS.alpha_convertible (expand_subexprs x,
					   expand_subexprs y);
d172 61
a232 11
  fun print_stats () =
     let val {size,count,smallest,largest,used} = LambdaHashTable.stats()
     in if count>0
	   then info ("Lambda Hashtable statistics: "^
		       "size = "^(makestring size)^
		       " count = "^(makestring count)^
		       "\n                              smallest = "^
		       (makestring smallest)^
		       " largest = "^(makestring largest)^
		       " used = "^(makestring used))
	else ()
d234 32
a265 2
   
      
d269 3
d291 2
d307 1
d311 1
d342 9
a350 1
	       fun abs_smallest (expr2, (var,subexpr)) =
d352 3
a354 1
		     val occns = LS.occurrences (var,expr2)
d356 24
a379 4
		     if occns>1 
			andalso (info ("subexpr appears more than once: v"^
				       (LT.printLVar var));
				 (is_shiftable (expand_subexprs subexpr)))
d381 7
a387 6
			then
			    (* locate smallest sub-expression  *)
			    (* containing all instances of var *)
			 let
			  val done = ref false 
			  exception BombOut
d389 111
a499 18
			  fun locate inexpr = 
			     if (!done) then inexpr  
			     else 
			      if (LS.occurrences (var,inexpr) = occns)
			       then 
				  (if (LS.whnf subexpr) orelse
				   (LT.VAR var) mem (LS.evaluation_set inexpr)
				      then (done:=true;
					    info ("abstracting for v"^
						  (LT.printLVar var));
					    LT.APP(LT.FN(var,inexpr),subexpr))
				   else raise BombOut)
			      else inexpr
			 in
			    (LS.apply_innermost locate expr2)
			     handle BombOut => 
				LS.substitute (var,subexpr,expr2)
			 end
d501 21
a521 1
		     else LS.substitute (var,subexpr,expr2)
a524 2
		   val _ = print_stats();   (* #### to see stats *)

d530 1
a530 4
              (* While the occurrence counts are small, there is no need
               to do a count of occurrences etc - better still would be a 
               function that only tries to do the one substitution *)
                   fun loop_to_end_of_single_counts(count,expr) =
a534 16
                         in
                           if count'= 0
                             then 
                               loop_to_end_of_single_counts(LT.LVar_previous(count),
                                                            LS.substitute(count,expr',expr))
                           else
                             (count,expr)
                         end
                       else
                         (count,expr)

                     fun loop_through (count,expr) =
                       if LT.LVar_order(lowest,count)
                       then
                         let
                           val (expr',count') = VarCountHashTable.lookup( count)
d537 1
a537 1
                           loop_through(LT.LVar_previous count,abs_smallest(expr,arg))
d539 4
a542 1
                       else expr
d544 2
a545 2
                     val (count,expr1) = 
                       loop_to_end_of_single_counts(LT.LVar_previous highest,expr1)
d547 2
a548 2
                     val absd_exp = loop_through (count,expr1)

d567 6
@


1.8
log
@Fixed bug where structures which are arguments to builtins are
considered as possible subexpressions for lifting. This is a
bad idea because we never really build a structure when we
are applying a builtin but if we put the structure in a let
then we do build a structure!
@
text
@a34 7
  type varcount_table = (LT.LVar, LT.LambdaExp * int) Table.table
	
  val empty_table : varcount_table = 
     Table.empty_table (Table.TableSpec{eq = (op =),
					order = LT.LVar_order})
	
  val subs_table = ref empty_table
d39 15
d58 1
a58 1
					      fst(Table.lookup(v,!subs_table))
d99 1
a99 1
					     fst(Table.lookup(v,!subs_table)))
d145 1
a145 1
			  subs_table := empty_table;
d154 3
a156 3
	     val (expr,count) = Table.lookup(var,!subs_table)
	     val _ = subs_table := 
		Table.overwrite((var,(expr,count+1)),!subs_table)
d163 4
a166 3
		    val _ = LambdaHashTable.update (full_expr,newvar)
		    val _ = subs_table :=
		       Table.add_new((newvar,(key,0)),!subs_table)
a250 2
		   val subexprs = Table.alist_of_table (!subs_table)

d253 40
a292 3
		   val abslist = map (fn(v,(e,_))=>(v,e)) subexprs
		   val absd_exp =
		     Lists.reducel abs_smallest (expr1,rev abslist)
d310 8
a317 1
(* $Log:	_optimise_cse.sml,v $
@


1.7
log
@Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.
@
text
@d174 1
a174 1
	     (*  sub-expressions to ignore  *)
d176 18
a193 5
	     fun atomic (e as LT.VAR _) = true
	       | atomic (e as LT.SCON _) = true
	       | atomic (e as LT.INT _) = true
	       | atomic (e as LT.BUILTIN _) = true
	       | atomic _ = false
a194 13
	     fun dontdoit (LT.STRUCT []) = true
	       | dontdoit _ = false


	     (*  Convert all sub-expressions into lambda-variables. *)

	     fun varify expr =
		 if (atomic expr) orelse (dontdoit expr)
		    then expr
		 else
		    get_var expr

   
d253 1
a253 1
	     unvarify (LS.apply_innermost varify expression)
d267 4
@


1.6
log
@Took out imposs function and exception impossible.
@
text
@d2 6
a7 1
 (*  Lambda-Calculus Optimisation:  _optimise_cse  *)
a8 6
      (*  Common-subexpression Elimination  *)


(*  Copyright (c) 1991 Harlequin Ltd. *)


d11 1
d16 6
a21 5

functor OptimiseCSE(structure Lib   : OPTIMISE_LIB
		    structure Table : TABLE
		    structure LambdaPrint : LAMBDAPRINT
		    sharing LambdaPrint.LambdaTypes = Lib.LT) : OPTIMISE_CSE =
d23 2
a25 2
  open Lib  infix mem == ++ -- (* !!! *)

d247 2
a248 1
		   val absd_exp = reducel abs_smallest (expr1,rev abslist)
d267 3
@


1.5
log
@Made changes due to record selection now requiring both the total
size of the record as well as the index.
@
text
@a27 4
  exception impossible of string
  fun imposs message = raise impossible message


a31 1

d265 4
@


1.4
log
@Removed a misleading comment.
@
text
@d104 1
a104 1
	     | h (bvs, SELECT (f,e)) = ug(37 + 41 * fromField(f)
d270 3
@


1.3
log
@No changes
@
text
@a215 3
			(* or moving it wouldn't cause it to be eval'd *)
			(* before any other shiftable expr's           *)

d270 3
@


1.2
log
@Changed substitute calls for it's new type.
@
text
@d12 1
a16 1

d128 1
a128 1
	   then print ("Lambda Hashtable statistics: "^
a222 2
			  val _ = info ("attempting to abstract v"^
					(LT.printLVar var))
d237 1
a237 2
				   else (info "can't abstract it!";
					 raise BombOut))
a249 4
		   val (left,removed) = partition (fn(_,(_,c))=>c=0) subexprs
		   val subslist = map (fn(v,(e,_))=>(v,e)) left
		   val abslist = map (fn(v,(e,_))=>(v,e)) removed  
		    
d252 6
a257 27
		      
		   val _ = if (length(subexprs))>0 then 
     let
	val _ = print ("Abstracting "^(makestring(length abslist))^
		       " shiftable subexpressions.  Leaving "^
		       (makestring(length subslist))^" alone.")
	val _ =	if (length(abslist))>0 then 
      let
	 
	 val _ = print ("Varified expression: ")
	 val _ = LambdaPrint.print_lambda expr1
	 val _ = print ("Sub-expressions :\n"^
			(implode 
			 (map (fn (v,(e,c))=>
			       (LambdaPrint.string_of_lambda 
				(LT.VAR v))^" =====> "^
			       (LambdaPrint.string_of_lambda e)^
			       " occurrences: "^
			       (makestring (c+1))^"\n") subexprs)))
      in () end else ()
     in () end else ()
							 
	val abslist = map (fn(v,(e,_))=>(v,e)) subexprs
	val absd_exp = reducel abs_smallest (expr1,rev abslist)
		in
		   absd_exp
		end
d273 3
@


1.1
log
@Initial revision
@
text
@d245 1
a245 1
				LS.substitute [(var,subexpr)] expr2
d248 1
a248 1
		     else LS.substitute [(var,subexpr)] expr2
d300 4
a303 1
(* $Log$ *)
@
