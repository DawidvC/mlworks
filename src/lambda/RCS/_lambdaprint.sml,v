head	1.64;
access;
symbols
	MLW_daveb_inline_1_4_99:1.64.3
	MLWorks_21c0_1999_03_25:1.64
	MLWorks_20c1_1998_08_20:1.64
	MLWorks_20c0_1998_08_04:1.64
	MLWorks_20b2c2_1998_06_19:1.64
	MLWorks_20b2_Windows_1998_06_12:1.64
	MLWorks_20b1c1_1998_05_07:1.64
	MLWorks_20b0_1998_04_07:1.64
	MLWorks_20b0_1998_03_20:1.64
	MLWorks_20m2_1998_02_16:1.64
	MLWorks_20m1_1997_10_23:1.64
	MLWorks_11r1:1.63.1.1.1.1.1
	MLWorks_workspace_97:1.64.2
	MLWorks_dt_wizard:1.64.1
	MLWorks_11c0_1997_09_09:1.63.1.1.1.1
	MLWorks_10r3:1.63.1.1.3
	MLWorks_10r2_551:1.63.1.1.2
	MLWorks_11:1.63.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.63.1.1
	MLWorks_20m0_1997_06_20:1.64
	MLWorks_1_0_r2c2_1997_06_14:1.63.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.63.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.63.1
	MLWorks_BugFix_1997_04_24:1.63
	MLWorks_1_0_r2_Win32_1997_04_11:1.63
	MLWorks_1_0_r2_Unix_1997_04_04:1.63
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.62.3.1.1
	MLWorks_gui_1996_12_18:1.62.4
	MLWorks_1_0_Win32_1996_12_17:1.62.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.62.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.62.1.1
	MLWorks_1_0_Irix_1996_11_28:1.62.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.62.2
	MLWorks_1_0_Unix_1996_11_14:1.62.1
	MLWorks_Open_Beta2_1996_10_11:1.60.3
	MLWorks_License_dev:1.60.2
	MLWorks_1_open_beta_1996_09_13:1.60.1
	MLWorks_Open_Beta_1996_08_22:1.60
	MLWorks_Beta_1996_07_02:1.59
	MLWorks_Beta_1996_06_07:1.59
	MLWorks_Beta_1996_06_06:1.59
	MLWorks_Beta_1996_06_05:1.59
	MLWorks_Beta_1996_06_03:1.59
	MLWorks_Beta_1996_05_31:1.59
	MLWorks_Beta_1996_05_30:1.59
	ML_beta_release_12/08/94:1.47
	ML_beta_release_03/08/94:1.47
	ML_revised_beta_release_25/05/94:1.46
	ML_final_beta_release_02/03/94:1.46
	mlworks-28-01-1994:1.46
	Release:1.45
	mlworks-beta-01-09-1993:1.45
	MLWorks-1-0-4-29/01/1993:1.39
	MLWorks-1-0-3-21/12/1992:1.39
	MLWorks-1-0-2-15/12/1992:1.39
	MLWorks-1-0-1-04/12/1992:1.39
	checkpoint_17_08_92:1.35
	Ten15_release_21-08-91:1.18
	Ten15_release_19-08-91:1.18
	ten15_release:1.14;
locks; strict;
comment	@ * @;


1.64
date	97.05.22.12.51.37;	author jont;	state Exp;
branches
	1.64.1.1
	1.64.2.1
	1.64.3.1;
next	1.63;

1.63
date	96.12.03.13.55.26;	author matthew;	state Exp;
branches
	1.63.1.1;
next	1.62;

1.62
date	96.11.06.11.02.20;	author matthew;	state Exp;
branches
	1.62.1.1
	1.62.2.1
	1.62.3.1
	1.62.4.1;
next	1.61;

1.61
date	96.10.31.11.09.52;	author io;	state Exp;
branches;
next	1.60;

1.60
date	96.08.06.11.40.49;	author andreww;	state Exp;
branches
	1.60.1.1
	1.60.2.1
	1.60.3.1;
next	1.59;

1.59
date	96.04.30.16.09.14;	author jont;	state Exp;
branches;
next	1.58;

1.58
date	96.04.29.14.31.07;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	95.12.27.12.44.35;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	95.12.22.17.06.19;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	95.12.04.12.17.28;	author matthew;	state Exp;
branches;
next	1.54;

1.54
date	95.11.20.16.57.01;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	95.08.11.11.36.42;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	95.02.13.12.34.10;	author matthew;	state Exp;
branches;
next	1.51;

1.51
date	95.01.20.12.11.22;	author matthew;	state Exp;
branches;
next	1.50;

1.50
date	94.11.14.13.34.31;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	94.10.11.10.03.48;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	94.09.19.12.06.49;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	94.07.20.14.40.15;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	93.08.11.16.09.17;	author nosa;	state Exp;
branches;
next	1.45;

1.45
date	93.07.29.13.12.43;	author nosa;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	93.05.28.15.43.44;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	93.05.18.15.49.40;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	93.03.10.16.22.49;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	93.03.04.12.40.38;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	93.03.01.14.37.58;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	92.11.26.15.57.43;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	92.10.26.16.53.43;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	92.09.21.11.43.37;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.08.26.11.59.26;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	92.07.29.10.05.15;	author clive;	state Exp;
branches;
next	1.34;

1.34
date	92.07.20.14.32.35;	author clive;	state Exp;
branches;
next	1.33;

1.33
date	92.07.10.15.28.44;	author davida;	state Exp;
branches;
next	1.32;

1.32
date	92.07.09.15.34.06;	author davida;	state Exp;
branches;
next	1.31;

1.31
date	92.07.01.15.44.59;	author davida;	state Exp;
branches;
next	1.30;

1.30
date	92.06.23.09.31.48;	author clive;	state Exp;
branches;
next	1.29;

1.29
date	92.06.16.11.21.45;	author davida;	state Exp;
branches;
next	1.28;

1.28
date	92.06.11.08.41.08;	author clive;	state Exp;
branches;
next	1.27;

1.27
date	92.04.16.08.31.56;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.04.13.13.56.02;	author clive;	state Exp;
branches;
next	1.25;

1.25
date	92.03.23.11.06.05;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	92.02.11.17.16.48;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	91.09.24.13.27.00;	author davida;	state Exp;
branches;
next	1.22;

1.22
date	91.09.11.15.58.34;	author davida;	state Exp;
branches;
next	1.21;

1.21
date	91.09.10.17.10.40;	author davida;	state Exp;
branches;
next	1.20;

1.20
date	91.08.23.17.07.21;	author davida;	state Exp;
branches;
next	1.19;

1.19
date	91.08.22.15.35.46;	author davida;	state Exp;
branches;
next	1.18;

1.18
date	91.08.07.15.29.42;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.08.06.13.46.56;	author davida;	state Exp;
branches;
next	1.16;

1.16
date	91.08.05.14.54.15;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	91.07.31.12.42.51;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	91.07.24.10.16.48;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.07.22.13.53.35;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.07.19.16.45.12;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.07.16.14.54.32;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	91.07.11.11.53.32;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.06.26.17.43.29;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.06.26.16.35.33;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.06.24.17.04.10;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	91.06.18.19.10.00;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	91.06.18.13.40.00;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.06.14.17.25.00;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.06.13.19.55.00;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.06.12.19.36.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.06.11.10.06.57;	author jont;	state Exp;
branches;
next	;

1.45.1.1
date	93.07.29.13.12.43;	author jont;	state Exp;
branches;
next	;

1.60.1.1
date	96.09.13.11.17.20;	author hope;	state Exp;
branches;
next	;

1.60.2.1
date	96.10.07.16.07.07;	author hope;	state Exp;
branches;
next	;

1.60.3.1
date	96.10.17.11.25.23;	author hope;	state Exp;
branches;
next	;

1.62.1.1
date	96.11.14.12.50.24;	author hope;	state Exp;
branches
	1.62.1.1.1.1;
next	;

1.62.1.1.1.1
date	96.11.28.15.01.31;	author hope;	state Exp;
branches;
next	;

1.62.2.1
date	96.11.22.18.09.50;	author hope;	state Exp;
branches;
next	;

1.62.3.1
date	96.12.17.17.48.28;	author hope;	state Exp;
branches
	1.62.3.1.1.1;
next	;

1.62.3.1.1.1
date	97.02.24.11.38.25;	author hope;	state Exp;
branches;
next	;

1.62.4.1
date	96.12.18.09.42.29;	author hope;	state Exp;
branches;
next	;

1.63.1.1
date	97.05.12.10.34.58;	author hope;	state Exp;
branches
	1.63.1.1.1.1
	1.63.1.1.2.1
	1.63.1.1.3.1;
next	;

1.63.1.1.1.1
date	97.07.28.18.20.20;	author daveb;	state Exp;
branches
	1.63.1.1.1.1.1.1;
next	;

1.63.1.1.1.1.1.1
date	97.10.07.11.45.31;	author jkbrook;	state Exp;
branches;
next	;

1.63.1.1.2.1
date	97.09.08.17.13.50;	author daveb;	state Exp;
branches;
next	;

1.63.1.1.3.1
date	97.09.09.14.09.34;	author daveb;	state Exp;
branches;
next	;

1.64.1.1
date	97.09.10.19.25.23;	author brucem;	state Exp;
branches;
next	;

1.64.2.1
date	97.09.11.20.55.40;	author daveb;	state Exp;
branches;
next	;

1.64.3.1
date	99.04.01.17.57.17;	author daveb;	state Exp;
branches;
next	;


desc
@Lambda calculus printing structure
@


1.64
log
@[Bug #30090]
Replace MLWorks.IO with TextIO where applicable
@
text
@(* _lambdaprint.sml the functor *)
(*
$Log: _lambdaprint.sml,v $
 * Revision 1.63  1996/12/03  13:55:26  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.62  1996/11/06  11:02:20  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.61  1996/10/31  11:09:52  io
 * moving String from toplevel
 *
 * Revision 1.60  1996/08/06  11:40:49  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
 * Revision 1.59  1996/04/30  16:09:14  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.58  1996/04/29  14:31:07  matthew
 * Integer changes
 *
 * Revision 1.57  1995/12/27  12:44:35  jont
 * Removing Option in favour of MLWorks.Option
 *
Revision 1.56  1995/12/22  17:06:19  jont
Remove references to option structure
in favour of MLWorks.Option

Revision 1.55  1995/12/04  12:17:28  matthew
Simplifying

Revision 1.54  1995/11/20  16:57:01  jont
Modifications to runtime environments for spills

Revision 1.53  1995/08/11  11:36:42  daveb
Added new types for different sizes of ints, words, and reals.

Revision 1.52  1995/02/13  12:34:10  matthew
Removed Options structure from Debugger_Types

Revision 1.51  1995/01/20  12:11:22  matthew
Change to VARINFO
Improved printing of variable debug information

Revision 1.50  1994/11/14  13:34:31  matthew
Better function name printing

Revision 1.49  1994/10/11  10:03:48  matthew
Changes to lambdatypes.
Improved printing

Revision 1.48  1994/09/19  12:06:49  matthew
Abstraction of debug information in lambdatypes

Revision 1.47  1994/07/20  14:40:15  matthew
Functions and applications take a list of parameters

Revision 1.46  1993/08/11  16:09:17  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.45  1993/07/29  13:12:43  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.44  1993/05/28  15:43:44  matthew
Diddling about a little.
Suppress location information

Revision 1.43  1993/05/18  15:49:40  jont
Removed integer parameter

Revision 1.42  1993/03/10  16:22:49  matthew
Signature revisions

Revision 1.41  1993/03/04  12:40:38  matthew
Options & Info changes

Revision 1.40  1993/03/01  14:37:58  matthew
Added MLVALUE lambda exp

Revision 1.39  1992/11/26  15:57:43  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.38  1992/10/26  16:53:43  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.37  1992/09/21  11:43:37  clive
Changed hashtables to a single structure implementation

Revision 1.36  1992/08/26  11:59:26  jont
Removed some redundant structures and sharing

Revision 1.35  1992/07/29  10:05:15  clive
Changed the bindingtable to be a hashtable

Revision 1.34  1992/07/20  14:32:35  clive
Changed to depend on debugger_types and not types ;
Changed the lambda printing to show type dependencies between functions and sub-functions

Revision 1.33  1992/07/10  15:28:44  davida
Added string_of_tag for printing tags.

Revision 1.32  1992/07/09  15:34:06  davida
Added print_types flag.

Revision 1.31  1992/07/01  15:44:59  davida
Added LET constructor and new slot to APP.

Revision 1.30  1992/06/23  09:31:48  clive
Added an annotation slot to HANDLE

Revision 1.29  1992/06/16  11:21:45  davida
Faster printing scheme.

Copyright (c) 1991 Harlequin Ltd.
*)

require "^.basis.__int";
require "^.basis.__text_io";

require "../utils/lists";
require "../basics/identprint";
require "../debugger/debugger_types";
require "pretty";
require "lambdatypes";
require "lambdaprint";

functor LambdaPrint (
  structure Lists : LISTS
  structure Pretty : PRETTY
  structure IdentPrint : IDENTPRINT
  structure LambdaTypes : LAMBDATYPES where type LVar = int
  structure DebuggerTypes : DEBUGGER_TYPES

  sharing LambdaTypes.Ident = IdentPrint.Ident
  sharing DebuggerTypes.Options = IdentPrint.Options
  sharing type LambdaTypes.Type = DebuggerTypes.Type
  sharing type DebuggerTypes.RuntimeEnv.VarInfo = LambdaTypes.VarInfo
    ) : LAMBDAPRINT =
 struct

  structure P = Pretty
  structure IP = IdentPrint
  structure Ident = IdentPrint.Ident
  structure Symbol = Ident.Symbol
  structure LambdaTypes = LambdaTypes
  structure Options = IdentPrint.Options
  structure RuntimeEnv = DebuggerTypes.RuntimeEnv

  val show_types = true

  exception Crash of string
  fun crash s = raise Crash s

  fun string_var var = 
    "v" ^ LambdaTypes.printLVar var

  fun string_info_var (var,info) =
    let
      fun print_spill_type RuntimeEnv.GC = "(GC spill)"
	| print_spill_type RuntimeEnv.NONGC = "(NONGC spill)"
	| print_spill_type RuntimeEnv.FP = "(FP spill)"

      fun print_spill NONE = "<no spill>"
        | print_spill (SOME (ref (RuntimeEnv.OFFSET1 i))) =
          "Virtual spill " ^ Int.toString i
        | print_spill (SOME (ref (RuntimeEnv.OFFSET2(spill_ty, i)))) =
          "Real spill " ^ print_spill_type spill_ty ^ Int.toString i

      val info_name =
        case info of
          SOME (ref (RuntimeEnv.VARINFO (name,_,spill))) =>
            ": " ^ name ^ ": " ^ print_spill spill
        | _ => ""
    in
      "v" ^ LambdaTypes.printLVar var ^ info_name
    end

  local
      fun is_app (LambdaTypes.APP _) = true
	| is_app _ = false

      fun compound (LambdaTypes.APP _)    = true
	| compound (LambdaTypes.FN _)     = true
	| compound (LambdaTypes.HANDLE _) = true
	| compound _ = false

      fun bracket t x =
        if t
          then [P.brk 0, P.str "("] @@ x @@ [P.str ")"]
        else x

      (* NB: unwrap_lets is duplicated in LambdaSub *)
      (* this version used for APP(FN _,_) form.    *)

      fun unwrap_lets expr =
	let 
	  fun unwl(acc, LambdaTypes.LET((var,info,bind),body)) = unwl((var,info,bind)::acc,body)
	    | unwl(acc, expr) = (rev acc, expr)
	in
	  unwl([],expr)
	end

      fun map_passing_on_env (f,[],env,acc) = (rev acc,env)
        | map_passing_on_env (f,h::t,env,acc) = 
          let
            val (res,env') = f (h,env)
          in
            map_passing_on_env(f,t,env',res::acc)
          end

        fun short_name name =
          let fun aux ([],acc) = acc
                | aux (#"[" ::rest,acc) = aux2 (rest,acc)
                | aux (a::l,acc) = aux (l,a::acc)
              and aux2 ([],acc) = acc
                | aux2 (#"]" ::rest,acc) = aux (rest,acc)
                | aux2 (_::rest,acc) = aux2 (rest,acc)
          in
            "[" ^ implode (rev (aux (explode name,[]))) ^ "]"
          end

        fun printvarlist lvl =
            let 
              fun f ([],acc) = acc
                | f ([lvar],acc) = string_var lvar :: acc
                | f (lvar::rest,acc) = f (rest,", " :: string_var lvar :: acc)
            in
              concat (rev (f (lvl,[])))
            end
        fun printarglist (lvl,fplvl) =
          case fplvl of
            [] => printvarlist lvl
          | _ => printvarlist lvl ^ "; " ^ printvarlist fplvl
  in
     fun decodetag options (tag,env) =
	 case tag of
	     LambdaTypes.VCC_TAG (_,i) => 
               (P.blk(0,[P.str("vcc "),
			   P.str(Int.toString i)]),env)
	   | LambdaTypes.IMM_TAG (_,i) => 
               (P.blk(0,[P.str("imm "),
			   P.str(Int.toString i)]),env)
	   | LambdaTypes.SCON_TAG (scon, _) => 
               (P.blk(0,[P.str("scon "),
			   P.str(IP.printSCon scon)]),env)
	   | LambdaTypes.EXP_TAG exp => 
               decodelambda options (exp,env)

     and decodelambda options (expression,env) = 
       case expression of
         LambdaTypes.VAR lvar => (P.blk(0,[P.str(string_var lvar)]),env)
       | LambdaTypes.FN (args, lambda,_,name,ty,_) => 
           let
             val (ty,env') =
               if not show_types then ([],env)
               else
                 let
                   val (str,env') =  DebuggerTypes.string_types options (ty,env)
                 in
                   ([P.brk 1, P.str ": ",P.str(str)],
                    env')
                 end
             val (lambda',env'') = decodelambda options (lambda,env')
           in
             (P.blk(0,[P.str "fn ",P.str (short_name name)] @@
                    ty @@
                    [P.str " ",
                     P.blk(0,[P.str("["),
                              P.str(printarglist args),
                              P.str("]"),
                              P.str(" => "), 
                              P.blk (2,[lambda'])])]),env'')
           end

       | LambdaTypes.LETREC(lvar_list, lambda_list, lambda_exp) => 
           let
             val (decoded_lambda_list,env') = 
               map_passing_on_env (decodelambda options,lambda_list,env,[])
             val (lambda_exp',env'') = decodelambda options (lambda_exp,env')
           in
             (P.blk(0,
                    [P.str "letrec ",P.nl,
                     P.blk(0, P.lst ("",[P.nl],"")
                           (map (fn (lv, le) =>
                                 P.blk(2,[P.str(string_var lv),
                                          P.str " = ",
                                          P.blk(0,[le])])) 
                           (Lists.zip(map #1 lvar_list,
                                      decoded_lambda_list)))),
                     P.nl,
                     P.str "in",
                     P.blk (2,[lambda_exp']),
                     P.nl,P.str"end "]),
             env'')
           end
       | LambdaTypes.LET _ =>
	   let
	     val (lets,expr) = unwrap_lets expression
             val (decoded_lets,env') = 
               map_passing_on_env 
               ((fn ((x,info,y),env) =>
                 let
                   val (exp,env') = decodelambda options (y,env)
                 in
                   ((x,info,exp),env')
                 end),
                lets,env,[])
             val (expr',env'') = decodelambda options (expr,env')
	   in
	     (P.blk(0,[P.nl,P.str "let ",P.nl,
                       P.blk(2, 
                             P.lst ("",[P.nl],"")
                             (map (fn (var,info,arg) =>
                                   P.blk(0,[P.str (string_info_var (var,info)),
                                            P.str " = ",
                                            P.blk(0,[arg])])) decoded_lets)),
                       P.nl,
                       P.str "in "] @@
	     [P.blk (2,[expr'])] @@ [P.nl,P.str"end "]),
             env'')
	   end
         
       | LambdaTypes.APP(lambda_fn, (lambda_args, fp_args), ty) =>
           let
             val (decoded_lambda_fn,env') = decodelambda options (lambda_fn,env)
             val (exp,env'') = map_passing_on_env(decodelambda options ,lambda_args,env,[])
             val (exp',env'') = map_passing_on_env(decodelambda options ,fp_args,env,[])
             val (str,env''') =
               if not show_types then ([],env'')
               else
                 let
                   val (tystr,env''') = 
                     case ty of 
                       NONE => ("Nulltype",env'')
                     | SOME (ty) => 
                         DebuggerTypes.string_types options (!ty,env'')
                 in
                   ([P.brk 1, P.str ":", P.brk 1,
                     P.str(tystr)],
                    env''')
                 end
             val argstuff = P.blk(0,[P.blk(1,
                                           case exp' of
                                             [] => P.lst ("[", [P.str ",", P.brk 1], "]") exp
                                           | _ => 
                                               (P.lst ("[", [P.str ",", P.brk 1], "") exp @@
                                                P.lst (";", [P.str ",", P.brk 1], "]") exp'))])
           in
             (P.blk(0,[P.blk(0,(bracket ((compound lambda_fn) 
                                         andalso (not(is_app lambda_fn)))
                                [decoded_lambda_fn])),
                       P.blk(1,argstuff :: str)]),
             env)
           end

       | LambdaTypes.SCON (scon, _) => 
           (P.blk(0,[P.str (IP.printSCon scon)]),env)

       | LambdaTypes.MLVALUE scon =>
           (P.blk(0,[P.str("mlvalue "),P.str ("_")]),env)

       | LambdaTypes.INT i => 
           (P.blk(0,[P.str("INT "),P.str (Int.toString i)]),env)

       | LambdaTypes.SWITCH(lambda, info_opt, c_lambda_list, lambda_opt) =>
           let
             val (pt1, env) = decodelambda options (lambda,env)
             val (pt3, env) = map_passing_on_env 
               (fn ((tag, x), env) => 
                let
                  val (tag', env) = decodetag options (tag, env)
                  val (lambda', env) = decodelambda options (x, env)
                in 
                  ((tag', lambda'), env)
                end,
               c_lambda_list, env, [])
               val (pt4, env) = 
                 case lambda_opt of 
                   NONE => ([], env)
                 | SOME lam => 
                     let
                       val (pt5,env) = decodelambda options (lam, env)
                     in
                       ([P.blk(3,[P.str"_ ",P.str"=> ",pt5])],env)
                     end
           in
	     (P.blk(0,
                    [P.nl, P.str "switch ", pt1, P.nl,
                     P.blk(0,
                           (P.lst ("  ",[P.nl, P.str"| "],"")
                            ((map (fn (c, l) => 
                                   (P.blk(3, [c,P.str" => ",l])))
                              pt3) @@ pt4)))]),
             env)
           end
         
       | LambdaTypes.STRUCT (lambda_list,_)
	 => 
           let
             val (exp,env') = map_passing_on_env(decodelambda options ,lambda_list,env,[])
           in
             (P.blk(0,[P.blk(1,P.lst ("(", [P.str ",", P.brk 1], ")")
                             exp)]),env')
           end

       | LambdaTypes.SELECT(field, lambda)
	 => 
           let
             val (expr,env') = decodelambda options (lambda,env)
           in
             (P.blk(0,bracket(compound lambda) [expr,
                                                P.str "[",
                                                P.str(LambdaTypes.printField(field)),
                                                P.str "]"]),env')
           end
             
       | LambdaTypes.RAISE (lambda)
	 => 
           let
             val (expr,env') = decodelambda options (lambda,env)
           in
             (P.blk(0,[P.str "raise ",expr]),env')
           end

       | LambdaTypes.HANDLE(lambda1, lambda2,_)
	 => 
           let
             val (expr,env') = decodelambda options (lambda1,env)
             val (expr',env'') = decodelambda options (lambda2,env')
           in
             (P.blk(0,(bracket (compound lambda1) [expr]) @@
                    [P.str(" handle"), P.brk 1] @@
                    (bracket (compound lambda2) [expr'])),env'')
           end

       | LambdaTypes.BUILTIN prim
	 => (P.blk(0,[P.str"builtin ", P.str(LambdaTypes.printPrim prim)]),env)
  end

  fun string_of_lambda e =
	P.string_of_T (P.blk(1,[P.brk 1, #1(decodelambda Options.default_options (e,[]))]));

  (*  NB:- there is a problem with NJ (at least) trying to create  *)
  (*  very large strings before printing them.  This is way the    *)
  (*  following functions are iterative and print out strings as   *)
  (*  they are calculated, rather than attempting to concatenate   *)
  (*  them.  An alternative solution would be to return a list of  *)
  (*  strings.  (Which wouldn't require the contiguous heap-space  *)
  (*  that a single string presumably does)			   *)


  fun output_lambda options (stm,e) = 
    let
      val pt = (P.blk(0,[P.brk 0, #1(decodelambda options (e,[]))]));
    in
      (P.print_T (fn s=>TextIO.output(stm,s)) pt;
       TextIO.output(stm,"\n"))
    end

  fun print_lambda options lam = output_lambda options (TextIO.stdOut,lam)

(* Printing *)

exception PrintExp

val N = Int.toString

fun print_var v = "v" ^ N v

fun print_vars vl =
  let
    fun aux []  = ""
      | aux [a] = print_var a
      | aux (a::l) = print_var a ^ "," ^ aux l
  in
    aux vl
  end

fun print_args (vl,fpvl) =
  case fpvl of
    [] => "(" ^ print_vars vl ^ ")"
  | _ => "(" ^ print_vars vl ^ "; " ^ print_vars fpvl ^ ")"

fun indent level =
  let
    fun aux (0,acc) = acc
      | aux (n,acc) = aux (n-1, #" " :: #" "::acc)
  in
    implode (#"\n" :: aux (level,[]))
  end

exception ExpTag

fun print_builtin b = "<" ^ LambdaTypes.printPrim b ^ ">"

local
  open LambdaTypes
in
fun iprint_exp (e,level,acc) =
  case e of 
    (* Simple expressions *)
    INT n => N n :: acc
  | SCON (s, _) => IdentPrint.printSCon s :: acc
  | BUILTIN b => print_builtin b :: acc
  | VAR var => print_var var :: acc
  | APP (e,(el,_),_) => print_explist (el,level,iprint_exp (e,level,acc))
  | STRUCT ([],_) => "1" :: acc
  | STRUCT (el,STRUCTURE) => print_explist (el,level,"structure " :: acc)
  | STRUCT (el,TUPLE) => print_explist (el,level,"tuple " :: acc)
  | STRUCT (el,CONSTRUCTOR) => print_explist (el,level,"cons " :: acc)
  | SWITCH (e,info,tel,oe) => print_opte (oe, level+1,
                                     print_tel (tel,level+1,indent (level+1)::" of ":: iprint_exp (e,level+1,"case " :: acc)))
  | HANDLE (e1,e2,_) => iprint_exp (e2,level," handle ":: indent (level+1) :: iprint_exp (e1,level+1,acc))
  | RAISE e => iprint_exp (e,level+1,"raise " :: acc)
  | FN (args,e,functorp,name,_,_) => 
      iprint_exp (e,level+1," => "::
                  "]" :: name :: "[" ::
                  print_args args ::"fn "::indent level :: acc)
  | LETREC (fl, vel,e) =>
      "end" :: indent level :: iprint_exp (e,level+1, indent (level+1) :: "in" :: indent level :: print_flist (Lists.zip (fl,vel),level+1,"let rec "::acc))
  | SELECT ({index,selecttype=STRUCTURE,...},e) =>
      ")" :: iprint_exp (e,level, ", " :: N index :: "sselect(" :: acc)
  | SELECT ({index,...},e) => 
      ")" :: iprint_exp (e,level, ", " :: N index :: "select(" :: acc)
  | LET _ => print_let (e,level,acc)
  | MLVALUE _ => "<mlvalue>" :: acc

and print_opte (NONE,level,acc) = acc
  | print_opte (SOME e,level,acc) = iprint_exp (e,level,"_ => " :: indent level :: " |":: acc)

and print_tel (l,level,acc) =
    let fun print_one ((t,e),acc) =
      iprint_exp (e, level+1," => " :: print_tag (t,level+1,acc))
    in
      case l of
        [] => acc
      | [x] => print_one (x,acc)
      | (x::y) => print_tel (y,level, indent level :: " |" :: print_one (x,acc))
    end

and print_tag (VCC_TAG (_,i),level,acc) = N i :: "vcc " :: acc
  | print_tag (IMM_TAG (_,i),level,acc) = N i :: "imm " :: acc
  | print_tag (SCON_TAG (s, _),level,acc) = IdentPrint.printSCon s :: "scon " :: acc
  | print_tag (EXP_TAG e,level,acc) = iprint_exp (e,level, "exp " :: acc)

and print_flist ([],level,acc) = acc
  | print_flist (((f,_),(FN (args,e,_,name,_,_)))::l,level,acc) =
    print_flist (l,level," " :: iprint_exp (e,level," = "::"]"::name::"["::print_args args ::print_var f::acc))
  | print_flist ((f,_)::l,level,acc) = crash "Bad exp in letrec"

and print_explist (el,level,acc) =
  let
    fun aux ([],acc) = ")"::acc
      | aux ([e],acc) = ")"::iprint_exp (e,level,acc)
      | aux (e::el,acc) = aux(el,","::iprint_exp(e,level,acc))
  in
    aux (el,"("::acc)
  end

and print_let (e,level,acc) =
  let
    fun aux (e,acc) =
      case e of
        LET ((v,_,FN (args,body,status,name,_,_)),e2) =>
          aux (e2," " :: 
               iprint_exp (body,
                           level+2,
                           " = "::"]"::
                           name::"["::print_args args::" "::print_var v::(case status of FUNC => "functor " | _ => "fun ")
                                     ::indent(level+1)::acc))
      | LET ((v,_,e1),e2) =>
          aux (e2," " :: iprint_exp (e1,level+2," = "::print_var v::"val "::indent(level+1)::acc))
      | e => "end " :: indent level :: iprint_exp (e,level+2,indent (level+1)::"in"::indent level :: acc)
  in
    case e of
      LET _ => aux (e,"let "::indent level :: acc)
    | _ => iprint_exp (e,level,acc)
  end

fun print_exp e = concat (rev (iprint_exp (e,0,[])))

fun to_expression ([],exp) = exp
  | to_expression ((v,i,dec)::rest,exp) =
    LET ((v,i,dec_to_expression dec),
         to_expression (rest,exp))
and dec_to_expression (VAL e) = e
  | dec_to_expression (FUNCTOR (arg,name,body)) =
    FN (([arg],[]),to_expression body,FUNC,name,null_type_annotation,user_funinfo)
  
fun pds (PROGRAM p) = concat (rev (print_let (to_expression p,0,[])))
fun pde e = concat (rev (print_let (e,0,[])))
end

(* End of printing *)


end
@


1.64.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.64  1997/05/22  12:51:37  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.64.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.64  1997/05/22  12:51:37  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.64.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.64  1997/05/22  12:51:37  jont
 * [Bug #30090]
 * Replace MLWorks.IO with TextIO where applicable
 *
@


1.63
log
@Simplifications and rationalizations
@
text
@d4 3
d127 2
d465 2
a466 2
      (P.print_T (fn s=>MLWorks.IO.output(stm,s)) pt;
       MLWorks.IO.output(stm,"\n"))
d469 1
a469 1
  fun print_lambda options lam = output_lambda options (MLWorks.IO.std_out,lam)
@


1.63.1.1
log
@branched from 1.63
@
text
@a3 3
 * Revision 1.63  1996/12/03  13:55:26  matthew
 * Simplifications and rationalizations
 *
@


1.63.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.63.1.1  1997/05/12  10:34:58  hope
 * branched from 1.63
 *
@


1.63.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.63.1.1  1997/05/12  10:34:58  hope
 * branched from 1.63
 *
@


1.63.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.63.1.1  1997/05/12  10:34:58  hope
 * branched from 1.63
 *
@


1.63.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.63.1.1.1.1  1997/07/28  18:20:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.62
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d135 1
a135 1
  structure LambdaTypes : LAMBDATYPES
d155 3
d226 1
a226 3
        fun printlvarlist [] = "[]"
          | printlvarlist [lvar] = string_var lvar
          | printlvarlist lvl =
d232 1
a232 1
              concat (rev ("]"::f (lvl,["["])))
d234 4
d256 1
a256 1
       | LambdaTypes.FN (lvarlist, lambda,name,ty,_) => 
d272 3
a274 1
                     P.blk(0,[P.str(printlvarlist lvarlist),
d327 1
a327 1
       | LambdaTypes.APP(lambda_fn, lambda_args, ty) =>
d331 1
d346 6
a351 1
             val argstuff = P.blk(0,[P.blk(1,P.lst ("[", [P.str ",", P.brk 1], "]") exp)])
d465 135
@


1.62.4.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/11/06  11:02:20  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.62.3.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/11/06  11:02:20  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.62.3.1.1.1
log
@branched from 1.62.3.1
@
text
@a3 3
 * Revision 1.62.3.1  1996/12/17  17:48:28  hope
 * branched from 1.62
 *
@


1.62.2.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/11/06  11:02:20  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.62.1.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/11/06  11:02:20  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.62.1.1.1.1
log
@branched from 1.62.1.1
@
text
@a3 3
 * Revision 1.62.1.1  1996/11/14  12:50:24  hope
 * branched from 1.62
 *
@


1.61
log
@moving String from toplevel
@
text
@d4 3
d119 1
a119 1
require "^.basis.__integer";
@


1.60
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml (essentially
just passing options rather than print_options).
@
text
@d4 5
d116 1
a116 2
require "../basis/__integer";

a147 2
  val makestring = Int.toString

d157 5
a161 5
      fun print_spill MLWorks.Option.NONE = "<no spill>"
        | print_spill (MLWorks.Option.SOME (ref (RuntimeEnv.OFFSET1 i))) =
          "Virtual spill " ^ makestring i
        | print_spill (MLWorks.Option.SOME (ref (RuntimeEnv.OFFSET2(spill_ty, i)))) =
          "Real spill " ^ print_spill_type spill_ty ^ makestring i
d165 1
a165 1
          MLWorks.Option.SOME (ref (RuntimeEnv.VARINFO (name,_,spill))) =>
d207 1
a207 1
                | aux ("["::rest,acc) = aux2 (rest,acc)
d210 1
a210 1
                | aux2 ("]"::rest,acc) = aux (rest,acc)
d213 1
a213 1
            "[" ^ String.implode(rev (aux (String.explode name,[]))) ^ "]"
d224 1
a224 1
              String.implode (rev ("]"::f (lvl,["["])))
d323 2
a324 2
                       MLWorks.Option.NONE => ("Nulltype",env'')
                     | MLWorks.Option.SOME(ty) => 
d363 2
a364 2
                   MLWorks.Option.NONE => ([], env)
                 | MLWorks.Option.SOME lam => 
@


1.60.3.1
log
@branched from 1.60
@
text
@a3 5
 * Revision 1.60  1996/08/06  11:40:49  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.60.2.1
log
@branched from 1.60
@
text
@a3 5
 * Revision 1.60  1996/08/06  11:40:49  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.60.1.1
log
@branched from 1.60
@
text
@a3 5
 * Revision 1.60  1996/08/06  11:40:49  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.59
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d128 1
a128 1
  sharing type DebuggerTypes.printOptions = IdentPrint.Options.print_options
d423 1
a423 1
	P.string_of_T (P.blk(1,[P.brk 1, #1(decodelambda Options.default_print_options (e,[]))]));
@


1.58
log
@Integer changes
@
text
@d4 3
d205 1
a205 1
            "[" ^ implode(rev (aux (explode name,[]))) ^ "]"
d216 1
a216 1
              implode (rev ("]"::f (lvl,["["])))
d432 2
a433 2
      (P.print_T (fn s=>output(stm,s)) pt;
       output(stm,"\n"))
d436 1
a436 1
  fun print_lambda options lam = output_lambda options (std_out,lam)
@


1.57
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d102 2
d135 1
a135 1
  val makestring = MLWorks.Integer.makestring
d220 1
a220 1
			   P.str(MLWorks.Integer.makestring i)]),env)
d223 1
a223 1
			   P.str(MLWorks.Integer.makestring i)]),env)
d336 1
a336 1
           (P.blk(0,[P.str("INT "),P.str (MLWorks.Integer.makestring i)]),env)
@


1.56
log
@Remove references to option structure
in favour of MLWorks.Option
@
text
@d4 4
d141 2
a142 2
      fun print_spill RuntimeEnv.Option.ABSENT = "<no spill>"
        | print_spill (RuntimeEnv.Option.PRESENT (ref (RuntimeEnv.OFFSET1 i))) =
d144 1
a144 1
        | print_spill (RuntimeEnv.Option.PRESENT (ref (RuntimeEnv.OFFSET2(spill_ty, i)))) =
@


1.55
log
@Simplifying
@
text
@d4 3
a108 1
  sharing LambdaTypes.Option = DebuggerTypes.RuntimeEnv.Option
@


1.54
log
@Modifications to runtime environments for spills
@
text
@d4 3
a422 44
    
      
  fun output_info options
		  (stm,
		   LambdaTypes.Info{bindings,known_fns,non_escaping_fns,
				    is_shiftable,...}) = 
     let
       val myprint = fn s => output(stm, s);
 
       fun print_lvar_set lvs = 
	 myprint ("{" ^ 
		  (LambdaTypes.Set.set_print (lvs,string_var))
		  ^ "}")

       fun print_bindings [] = ()
	 | print_bindings ((var,expr)::bs) = 
	   (myprint (string_var var ^	" =====>");
	    output_lambda options (stm,expr);
	    print_bindings bs)
	   
       val shiftable_appvars = 
	 Lists.reducel (fn (acc,(var,_)) => 
			if is_shiftable 
			  (LambdaTypes.APP(LambdaTypes.VAR var, 
					   [LambdaTypes.INT ~1],
                                           MLWorks.Option.NONE))
			  then LambdaTypes.Set.add_member (var,acc)
			else acc) (LambdaTypes.Set.empty_set,LambdaTypes.NewHashTable.to_list bindings)
	 
       fun iter f [] = ()
	 | iter f (x::xs) = (f x; iter f xs)
     in
       (myprint "Bindings: \n";
	print_bindings (LambdaTypes.NewHashTable.to_list bindings);
	myprint "Shiftable app var's: ";
	print_lvar_set shiftable_appvars;
	myprint "\nKnown functions: ";
	print_lvar_set known_fns;
	myprint "\nNon-escaping functions: ";
	print_lvar_set non_escaping_fns;
	myprint "\n")
     end

  fun print_info options lam = output_info options (std_out,lam)
@


1.53
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d4 3
d128 4
d135 2
a136 2
        | print_spill (RuntimeEnv.Option.PRESENT (ref (RuntimeEnv.OFFSET2 i))) =
          "Real spill " ^ makestring i
@


1.52
log
@Removed Options structure from Debugger_Types
@
text
@d4 3
a113 1
  structure Option = LambdaTypes.Option
d125 2
a126 2
      fun print_spill Option.ABSENT = "<no spill>"
        | print_spill (Option.PRESENT (ref (RuntimeEnv.OFFSET1 i))) =
d128 1
a128 1
        | print_spill (Option.PRESENT (ref (RuntimeEnv.OFFSET2 i))) =
d133 1
a133 1
          Option.PRESENT (ref (RuntimeEnv.VARINFO (name,_,spill))) =>
d203 1
a203 1
	   | LambdaTypes.SCON_TAG scon => 
d291 2
a292 2
                       Option.ABSENT => ("Nulltype",env'')
                     | Option.PRESENT(ty) => 
d308 1
a308 1
       | LambdaTypes.SCON scon => 
d331 2
a332 2
                   Option.ABSENT => ([], env)
                 | Option.PRESENT lam => 
d438 1
a438 1
                                           Option.ABSENT))
@


1.51
log
@Change to VARINFO
Improved printing of variable debug information
@
text
@d4 4
d95 1
a95 1
  structure Debugger_Types : DEBUGGER_TYPES
d97 1
a97 1
  sharing LambdaTypes.Option = Debugger_Types.RuntimeEnv.Option
d99 3
a101 2
  sharing type LambdaTypes.Type = Debugger_Types.Type
  sharing type Debugger_Types.RuntimeEnv.VarInfo = LambdaTypes.VarInfo
d110 1
a110 1
  structure Options = Debugger_Types.Options
d112 1
a112 1
  structure RuntimeEnv = Debugger_Types.RuntimeEnv
d216 1
a216 1
                   val (str,env') =  Debugger_Types.string_types options (ty,env)
d291 1
a291 1
                         Debugger_Types.string_types options (!ty,env'')
@


1.50
log
@Better function name printing
@
text
@d4 3
d109 3
a111 1
  val show_types = false
d118 6
d126 2
a127 2
          Option.PRESENT(ref (RuntimeEnv.VARINFO (Option.PRESENT(name,_,_)))) =>
            ":" ^ name
d247 1
a247 1
       | LambdaTypes.LET((var,info,bind),body) =>
d256 1
a256 1
                   ((x,exp),env')
d264 1
a264 1
                             (map (fn (var,arg) =>
@


1.49
log
@Changes to lambdatypes.
Improved printing
@
text
@d4 4
d157 1
a157 1
                | aux ("["::_,acc) = acc
d159 3
@


1.48
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d102 16
a131 1

d137 1
a137 1
	  fun unwl(acc, LambdaTypes.LET(var,info,bind,body)) = unwl((var,info,bind)::acc,body)
d156 1
a156 1
            implode(rev (aux (explode name,[])))
d160 1
a160 1
          | printlvarlist [lvar] = LambdaTypes.printLVar lvar
d164 2
a165 2
                | f ([lvar],acc) = LambdaTypes.printLVar lvar :: acc
                | f (lvar::rest,acc) = f (rest,", " :: LambdaTypes.printLVar lvar :: acc)
d173 1
a173 1
               (P.blk(2,[P.str("VCC_TAG "),
d176 1
a176 1
               (P.blk(2,[P.str("IMM_TAG "),
d179 1
a179 1
               (P.blk(2,[P.str("SCON_TAG "),
d185 3
a187 6
	case expression of
	     LambdaTypes.VAR lvar
	     => (P.blk(0,[P.str("v" ^ LambdaTypes.printLVar lvar)]),env)

       | LambdaTypes.FN (lvarlist, lambda,name,ty,_)
	 => 
d190 8
a197 6
                    let
                      val (str,env') =  Debugger_Types.string_types options (ty,env)
                    in
                      ([P.brk 1, P.str ": ",
                        P.str(str)],env')
                    end
d200 1
a200 1
             (P.blk(0,[P.str (short_name name)] @@
d202 4
a205 6
                       [P.brk 1,
                        P.str "\\",
                        P.blk(0,[P.str(printlvarlist lvarlist),
                                 P.str(". "), 
                                 (* P.brk 0,  gives too many nl's *)
                                 lambda'])]),env'')
d208 1
a208 2
       | LambdaTypes.LETREC(lvar_list, lambda_list, lambda_exp)
	 => 
d211 1
a211 1
               map_passing_on_env (decodelambda options ,lambda_list,env,[])
d215 1
a215 1
                    [P.str "LETREC ",
d218 3
a220 4
                                 P.blk(2,[P.str(LambdaTypes.printLVar lv),
                                          P.str ", ",
                                          P.blk(0,[le]),
                                          P.str " >"])) 
d224 4
a227 3
                     P.str "IN "]@@
                    (bracket (compound lambda_exp) [lambda_exp']) @@
                    [P.str" END "]),env'')
d229 1
a229 1
       | LambdaTypes.LET(var,info,bind,body) =>
d233 8
a240 6
               map_passing_on_env ((fn ((x,info,y),env) =>
                                    let
                                      val (exp,env') = decodelambda options (y,env)
                                    in
                                      ((x,exp),env')
                                    end),lets,env,[])
a241 5
             val info_name =
               case info of
                 Option.PRESENT(ref (RuntimeEnv.VARINFO (Option.PRESENT(name,_,_)))) =>
                   ":" ^ name
               | _ => ""
d243 3
a245 2
	     (P.blk(0,[P.str "LET ",
                       P.blk(0, P.lst ("",[P.nl],"")
d247 3
a249 3
                                 P.blk(2,[P.str ("v" ^ LambdaTypes.printLVar var ^ info_name),
                                          P.str " = ",
                                          P.blk(0,[arg])])) decoded_lets)),
d251 2
a252 2
                       P.str "IN "] @@
	     (bracket (compound expr) [expr']) @@ [P.str" END "]),
a255 27
       | LambdaTypes.APP(lambda_fn, [lambda_arg], ty) =>
              let
                val (decoded_lambda_fn,env') = decodelambda options (lambda_fn,env)
                val (decoded_lambda_arg,env'') = decodelambda options (lambda_arg,env')
                val (str,env''') =
                  let
                    val (tystr,env''') = 
                      case ty of 
                        Option.ABSENT => ("Nulltype",env'')
                      | Option.PRESENT(ty) => 
                          Debugger_Types.string_types options (!ty,env'')
                  in
                    ([P.brk 1, P.str ":", P.brk 1,
                      P.str(tystr)],
                     env''')
                  end
              in
                (P.blk(0,[P.blk(0,(bracket ((compound lambda_fn) 
                                          andalso (not(is_app lambda_fn)))
                                 [decoded_lambda_fn])),
                        P.brk 1,
                        P.blk(1,(bracket (compound lambda_arg) 
                                 [decoded_lambda_arg]) @@
                              str)]),
              env)
              end

d261 14
a274 12
               let
                 val (tystr,env''') = 
                   case ty of 
                     Option.ABSENT => ("Nulltype",env'')
                   | Option.PRESENT(ty) => 
                       Debugger_Types.string_types options (!ty,env'')
               in
                 ([P.brk 1, P.str ":", P.brk 1,
                   P.str(tystr)],
                  env''')
               end
             val argstuff = P.blk(0,[P.blk(1,P.lst ("[[", [P.str ",", P.brk 1], "]]") exp)])
d276 5
a280 6
                (P.blk(0,[P.blk(0,(bracket ((compound lambda_fn) 
                                            andalso (not(is_app lambda_fn)))
                                   [decoded_lambda_fn])),
                          P.brk 1,
                          P.blk(1,argstuff :: str)]),
              env)
d284 1
a284 1
           (P.blk(0,[P.str("SCON "),P.str (IP.printSCon scon)]),env)
d287 1
a287 1
           (P.blk(0,[P.str("MLVALUE "),P.str ("_")]),env)
d289 2
a290 3
       | LambdaTypes.INT i
	 => (P.blk(0,[P.str("INT "), 
	     P.str (MLWorks.Integer.makestring i)]),env)
d294 2
a295 2
             val (pt1, env') = decodelambda options (lambda,env)
             val (pt3, env'') = map_passing_on_env 
d298 2
a299 2
                  val (tag', env') = decodetag options (tag, env)
                  val (lambda', env'') = decodelambda options (x, env')
d301 1
a301 1
                  ((tag', lambda'), env'')
d303 2
a304 2
               c_lambda_list, env', [])
               val (pt4, env''') = 
d306 7
a312 2
                   Option.ABSENT => (P.str "<none>", env)
                 | Option.PRESENT(lam) => decodelambda options (lam, env'')
d314 8
a321 12
	     (P.blk(0,[P.str "SWITCH <", pt1, P.str "> ", 
	      P.nl,
	      P.blk(0,
		    (P.lst (" [ ",[P.nl, P.str" | "],"  ]")
		    ((map (fn (c, l) => 
			   (P.blk(3, [c, 
				      P.brk 1, P.str"=> ", 
                                        l])))
		      pt3) @@
		     [P.blk(3,[P.str"default", P.brk 1, P.str"=> ",
			       pt4])])
		     ))]),env''')
d323 2
a324 2

       | LambdaTypes.STRUCT lambda_list
d329 1
a329 1
             (P.blk(0,[P.blk(1,P.lst ("{", [P.str ",", P.brk 1], "}")
d349 1
a349 1
             (P.blk(0,[P.str "RAISE ",expr]),env')
d359 1
a359 1
                    [P.str(" HANDLE"), P.brk 1] @@
d364 1
a364 1
	 => (P.blk(0,[P.str"BUILTIN ", P.str(LambdaTypes.printPrim prim)]),env)
d381 1
a381 1
      val pt = (P.blk(1,[P.brk 1, #1(decodelambda options (e,[]))]));
d399 1
a399 1
		  (LambdaTypes.Set.set_print (lvs, LambdaTypes.printLVar))
d404 1
a404 2
	   (myprint ("  v"^(LambdaTypes.printLVar var)^
		     " =====>");
@


1.47
log
@Functions and applications take a list of parameters
@
text
@d1 1
a1 1
(* _Lambdaprint.sml the functor *)
d4 3
d83 1
d86 1
d97 1
d119 1
a119 1
	  fun unwl(acc, LambdaTypes.LET(var,bind,body)) = unwl((var,bind)::acc,body)
d196 2
a197 1
             val (decoded_lambda_list,env') = map_passing_on_env (decodelambda options ,lambda_list,env,[])
d208 1
a208 1
                           (Lists.zip(map LambdaTypes.fetch_var lvar_list,
d215 1
a215 1
       | LambdaTypes.LET(var,bind,body) =>
d218 7
a224 6
             val (decoded_lets,env') = map_passing_on_env ((fn ((x,y),env) =>
                                                            let
                                                              val (exp,env') = decodelambda options (y,env)
                                                            in
                                                              ((x,exp),env')
                                                            end),lets,env,[])
d226 5
d235 3
a237 12
                                 P.blk(2,[P.str ("v"^(
                                   case var of
                                     Option.SOME1(var)=> 
                                           LambdaTypes.printLVar (var)
                                   | Option.SOME2(ref(var,
                                              Option.PRESENT(name,_,_)))=>
                                     LambdaTypes.printLVar (var)^":"^name
                                   | Option.SOME2(ref(var,_)) => 
                                           LambdaTypes.printLVar (var)
                                          )),
                                            P.str " = ",
                                            P.blk(0,[arg])])) decoded_lets)),
a309 5
	     val pt2 =
	       case info_opt of
		 Option.ABSENT => P.str "<none>"
	       | Option.PRESENT{lv, ...} =>
		   P.str(LambdaTypes.printLVar lv)
a325 2
	      P.blk(0, [P.str "BINDING <", pt2, P.str "> ",
	      P.nl,
d335 1
a335 1
		     ))])]),env''')
@


1.46
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d91 1
a110 9
      fun unwrap_old_lets expr =
       let 
	fun unwl(acc, LambdaTypes.APP(LambdaTypes.FN(var,body,_,_,_),arg,_)) =
		 unwl ((var,arg)::acc, body)
	  | unwl(acc, expr) = (rev acc, expr)
       in
	    unwl([],expr)
       end

d135 10
d165 1
a165 1
       | LambdaTypes.FN (lvar, lambda,name,ty,_)
d181 1
a181 1
                        P.blk(0,[P.str(LambdaTypes.printLVar lvar),
d224 1
a224 1
                                     LambdaTypes.Option.SOME1(var)=> 
d226 2
a227 2
                                   | LambdaTypes.Option.SOME2(ref(var,
                                              LambdaTypes.Option.PRESENT(name,_,_)))=>
d229 1
a229 1
                                   | LambdaTypes.Option.SOME2(ref(var,_)) => 
d240 1
a240 1
       | LambdaTypes.APP(lambda_fn, lambda_arg, ty) =>
d244 12
a255 12
                  val (str,env''') =
                         let
                           val (tystr,env''') = 
                             case ty of 
                               LambdaTypes.Option.ABSENT => ("Nulltype",env'')
                             | LambdaTypes.Option.PRESENT(ty) => 
                                 Debugger_Types.string_types options (!ty,env'')
                         in
                           ([P.brk 1, P.str ":", P.brk 1,
                            P.str(tystr)],
                            env''')
                         end
d267 31
a297 7
       | LambdaTypes.SCON scon
	 => (P.blk(0,[P.str("SCON "), 
                      P.str (IP.printSCon scon)]),env)

       | LambdaTypes.MLVALUE scon
	 => (P.blk(0,[P.str("MLVALUE "), 
                      P.str ("_")]),env)
d308 2
a309 2
		 LambdaTypes.Option.ABSENT => P.str "<none>"
	       | LambdaTypes.Option.PRESENT{lv, ...} =>
d322 2
a323 2
                   LambdaTypes.Option.ABSENT => (P.str "<none>", env)
                 | LambdaTypes.Option.PRESENT(lam) => decodelambda options (lam, env'')
d430 2
a431 2
					   LambdaTypes.INT ~1,
                                           LambdaTypes.Option.ABSENT))
@


1.45
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d4 4
d108 1
a108 1
	fun unwl(acc, LambdaTypes.APP(LambdaTypes.FN(var,body,_,_),arg,_)) =
d159 1
a159 1
       | LambdaTypes.FN (lvar, lambda,name,ty)
d221 1
a221 1
                                              LambdaTypes.Option.PRESENT(name,_)))=>
d242 1
a242 1
                               LambdaTypes.Option.ABSENT => ("Nulltype ",env'')
@


1.45.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.45  1993/07/29  13:12:43  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.44
log
@Diddling about a little.
Suppress location information
@
text
@d4 4
d138 1
a138 1
	     LambdaTypes.VCC_TAG i => 
d141 1
a141 1
	   | LambdaTypes.IMM_TAG i => 
d190 3
a192 2
                                          P.str " >"])) (Lists.zip(lvar_list,
                                                                   decoded_lambda_list)))),
d212 10
a221 1
                                   P.blk(2,[P.str ("v"^(LambdaTypes.printLVar var)),
d236 5
a240 1
                           val (tystr,env''') = Debugger_Types.string_types options (ty,env'')
d274 2
a275 2
		 LambdaTypes.ABSENT => P.str "<none>"
	       | LambdaTypes.PRESENT{lv, ...} =>
d288 2
a289 2
                   LambdaTypes.ABSENT => (P.str "<none>", env)
                 | LambdaTypes.PRESENT(lam) => decodelambda options (lam, env'')
d327 1
a327 1
       | LambdaTypes.RAISE lambda
d397 1
a397 1
					   LambdaTypes.null_type_annotation))
@


1.43
log
@Removed integer parameter
@
text
@d4 3
d89 4
a92 2
      fun bracket t x = if t then [P.brk 0, P.str "("] @@ x @@ [P.str ")"]
			else x
d122 9
d163 1
a163 1
             (P.blk(0,[P.str name] @@
d168 1
a168 1
                                 P.str("."), 
d183 1
a183 2
                                 P.blk(2,[P.str "< ",
                                          P.str(LambdaTypes.printLVar lv),
d204 1
a204 1
	     (P.blk(0,[P.str "Let ",
d211 2
a212 2
                       P.str "In "] @@
	     (bracket (compound expr) [expr']) @@ [P.str" End "]),
@


1.42
log
@Signature revisions
@
text
@d4 3
a51 1
require "../utils/integer";
a59 1
  structure Integer : INTEGER
d122 1
a122 1
			   P.str(Integer.makestring i)]),env)
d125 1
a125 1
			   P.str(Integer.makestring i)]),env)
d236 1
a236 1
	     P.str (Integer.makestring i)]),env)
@


1.41
log
@Options & Info changes
@
text
@d4 3
d64 3
a66 2
  sharing LambdaTypes.Datatypes = Debugger_Types.Datatypes
  sharing LambdaTypes.Datatypes.Ident = IdentPrint.Ident) : LAMBDAPRINT =
@


1.40
log
@Added MLVALUE lambda exp
@
text
@d4 3
d70 1
a70 1
  structure Info = Debugger_Types.Info
d315 1
a315 1
	P.string_of_T (P.blk(1,[P.brk 1, #1(decodelambda Info.default_options (e,[]))]));
@


1.39
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d221 4
@


1.38
log
@Minor changes to support the new type of SWITCHes.
@
text
@d4 3
d63 1
a63 3


  val fabricate_lets = ref true;    (* print APP(FN _,_) as LET .. in .. *)
a64 4
  val show_types = ref true;

  val print_margin = P.margin;
     
a68 3
      fun is_abs (LambdaTypes.FN _) = true
	| is_abs _ = false

d106 1
a106 1
     fun decodetag (tag,env) =
d118 1
a118 1
               decodelambda (exp,env)
d120 1
a120 1
     and decodelambda (expression,env) = 
a128 2
               (if !show_types 
                  then 
d130 1
a130 1
                      val (str,env') =  Debugger_Types.string_types(ty,env)
d135 1
a135 2
                else ([],env))
             val (lambda',env'') = decodelambda(lambda,env')
d150 2
a151 2
             val (decoded_lambda_list,env') = map_passing_on_env (decodelambda,lambda_list,env,[])
             val (lambda_exp',env'') = decodelambda (lambda_exp,env')
d173 1
a173 1
                                                              val (exp,env') = decodelambda(y,env)
d177 1
a177 1
             val (expr',env'') = decodelambda (expr,env')
d191 1
a191 27
       | LambdaTypes.APP(lambda_fn, lambda_arg, ty)
	 => if (is_abs lambda_fn) andalso (!fabricate_lets)
	     then
	      let
		val (lets,expr) = unwrap_old_lets expression
                val (decoded_lets,env') = map_passing_on_env((fn ((x,y),env) =>
                                                              let 
                                                                val (exp',env') = decodelambda (y,env)
                                                              in
                                                                ((x,exp'),env')
                                                              end),
                                                             lets,env,[])
                val (decoded_expr,env'') = decodelambda (expr,env')
	      in
	        (P.blk(0,[P.str "OldLet ",
                          P.blk(0, P.lst ("",[P.nl],"")
                                (map (fn (var,arg) =>
                                      P.blk(2,[P.str ("v"^(LambdaTypes.printLVar var)),
                                               P.str " = ",
                                               P.blk(0,[arg])])) decoded_lets)),
                          P.nl,
                          P.str "In "] @@
                (bracket (compound expr) [decoded_expr]) @@ [P.str" End "]),
                env'')
	      end

	    else 
d193 2
a194 2
                val (decoded_lambda_fn,env') = decodelambda (lambda_fn,env)
                val (decoded_lambda_arg,env'') = decodelambda (lambda_arg,env')
a195 2
                    (if !show_types 
                       then 
d197 1
a197 1
                           val (tystr,env''') = Debugger_Types.string_types(ty,env'')
a202 1
                     else ([],env''))
d224 1
a224 1
             val (pt1, env') = decodelambda (lambda,env)
d233 2
a234 2
                  val (tag', env') = decodetag(tag, env)
                  val (lambda', env'') = decodelambda(x, env')
d242 1
a242 1
                 | LambdaTypes.PRESENT(lam) => decodelambda (lam, env'')
d263 1
a263 1
             val (exp,env') = map_passing_on_env(decodelambda,lambda_list,env,[])
d272 1
a272 1
             val (expr,env') = decodelambda (lambda,env)
d283 1
a283 1
             val (expr,env') = decodelambda (lambda,env)
d291 2
a292 2
             val (expr,env') = decodelambda (lambda1,env)
             val (expr',env'') = decodelambda (lambda2,env')
d303 2
a304 2
  fun string_of_lambda e = P.string_of_T 
      				(P.blk(1,[P.brk 1, #1(decodelambda (e,[]))]));
d315 1
a315 1
  fun output_lambda (stm,e) = 
d317 1
a317 1
      val pt = (P.blk(1,[P.brk 1, #1(decodelambda (e,[]))]));
d323 1
a323 1
  val print_lambda = fn lam => output_lambda(std_out,lam)
d326 2
a327 1
  fun output_info (stm,
d342 1
a342 1
	    output_lambda (stm,expr);
d368 1
a368 1
  val print_info = fn lam => output_info(std_out,lam)
@


1.37
log
@Changed hashtables to a single structure implementation
@
text
@d4 3
d114 5
a118 2
	     LambdaTypes.CON_TAG i => 
               (P.blk(2,[P.str("CON_TAG "),
a119 1

a122 1
		 
d260 1
a260 1
       | LambdaTypes.SWITCH(lambda, c_lambda_list, lambda_opt1, lambda_opt2) =>
d262 8
a269 3
             val (pt1,env') = decodelambda (lambda,env)
             val (pt2,env'') = map_passing_on_env 
               (fn ((tag,x),env) => 
d271 2
a272 2
                  val (tag',env') = decodetag(tag,env)
                  val (lambda',env'') = decodelambda(x,env')
d274 1
a274 1
                  ((tag',lambda'),env'')
d276 5
a280 10
               c_lambda_list,env',[])
               val (pt3,env''') = 
                 case lambda_opt1 of 
                   LambdaTypes.ABSENT => (P.str"<none>",env)
                 | LambdaTypes.PRESENT(lam) => decodelambda (lam,env'')
               val (pt4,env'''') = 
                 case lambda_opt2 of 
                   LambdaTypes.ABSENT => (P.str"<none>",env''')
                 | LambdaTypes.PRESENT(lam) => 
                     decodelambda (lam,env''')
d284 2
d292 1
a292 1
		      pt2) @@
a293 2
			       pt3]),
		      P.blk(3,[P.str"pointer", P.brk 1, P.str"=> ",
d295 1
a295 1
		    ))]),env'''')
@


1.36
log
@Removed some redundant structures and sharing
@
text
@d4 3
a48 2
  sharing type LambdaTypes.BindingTable.Key = LambdaTypes.LVar
  sharing type LambdaTypes.BindingTable.Value = LambdaTypes.LambdaExp
d385 1
a385 1
			else acc) (LambdaTypes.Set.empty_set,LambdaTypes.BindingTable.to_list bindings)
d391 1
a391 1
	print_bindings (LambdaTypes.BindingTable.to_list bindings);
@


1.35
log
@Changed the bindingtable to be a hashtable
@
text
@d4 3
a31 1
require "../basics/ident";
a41 1
  structure Ident : IDENT
d48 1
a48 1
  sharing Ident = LambdaTypes.Ident = IdentPrint.Ident) : LAMBDAPRINT =
d53 1
@


1.34
log
@Changed to depend on debugger_types and not types ;
Changed the lambda printing to show type dependencies between functions and sub-functions
@
text
@d4 4
d45 2
@


1.33
log
@Added string_of_tag for printing tags.
@
text
@d4 3
d26 1
a26 1
require "../typechecker/types";
d38 1
a38 1
  structure Types : TYPES
d40 1
a40 1
  sharing Types.Datatypes = LambdaTypes.Datatypes
d92 7
d100 1
a100 1
     fun decodetag tag =
d103 2
a104 2
		 P.blk(2,[P.str("CON_TAG "),
			   P.str(Integer.makestring i)])
d107 2
a108 2
		 P.blk(2,[P.str("SCON_TAG "),
			   P.str(IP.printSCon scon)])
d111 1
a111 1
		 decodelambda exp
d113 2
a114 2
     and decodelambda expression = 
	P.blk(0,case expression of
d116 1
a116 1
	     => [P.str("v" ^ LambdaTypes.printLVar lvar)]
d119 23
a141 11
	 => [P.str name] @@
	    (if !show_types 
	       then [P.brk 1, P.str ": ",
		     P.str(Types.print_type ty)]
	     else []) @@
             [P.brk 1,
	      P.str "\\",
	      P.blk(0,[P.str(LambdaTypes.printLVar lvar),
		       P.str("."), 
		       (* P.brk 0,  gives too many nl's *)
		       decodelambda lambda])]
d144 20
a163 14
	 => [P.str "LETREC ",
	     P.blk(0, P.lst ("",[P.nl],"")
		       (map (fn (lv, le) =>
			     P.blk(2,[P.str "< ",
				      P.str(LambdaTypes.printLVar lv),
				      P.str ", ",
				      P.blk(0,[decodelambda le]),
				      P.str " >"])) (Lists.zip(lvar_list,
							       lambda_list)))),
	     P.nl,
	     P.str "IN "]@@
	     (bracket (compound lambda_exp) [decodelambda lambda_exp]) @@
	     [P.str" END "]

d167 7
d175 10
a184 9
	     [P.str "Let ",
	      P.blk(0, P.lst ("",[P.nl],"")
		    (map (fn (var,arg) =>
			  P.blk(2,[P.str ("v"^(LambdaTypes.printLVar var)),
				   P.str " = ",
				   P.blk(0,[decodelambda arg])])) lets)),
	      P.nl,
	      P.str "In "] @@
	     (bracket (compound expr) [decodelambda expr]) @@ [P.str" End "]
d186 1
a186 1

d192 8
d201 10
a210 9
	        [P.str "OldLet ",
		 P.blk(0, P.lst ("",[P.nl],"")
		       (map (fn (var,arg) =>
			     P.blk(2,[P.str ("v"^(LambdaTypes.printLVar var)),
				      P.str " = ",
				      P.blk(0,[decodelambda arg])])) lets)),
		 P.nl,
		 P.str "In "] @@
		 (bracket (compound expr) [decodelambda expr]) @@ [P.str" End "]
d213 25
a237 11
	    else [P.blk(0,(bracket ((compound lambda_fn) 
				    andalso (not(is_app lambda_fn)))
			   [decodelambda lambda_fn])),
		  P.brk 1,
		  P.blk(1,(bracket (compound lambda_arg) 
			   [decodelambda lambda_arg]) @@
			  (if !show_types 
			     then 
			       [P.brk 1, P.str ":", P.brk 1,
				P.str(Types.print_type ty)]
			   else []))]
d240 2
a241 2
	 => [P.str("SCON "), 
	     P.str (IP.printSCon scon)]
d244 2
a245 2
	 => [P.str("INT "), 
	     P.str (Integer.makestring i)]
d248 22
a269 1
	     [P.str "SWITCH <", decodelambda lambda, P.str "> ", 
d274 1
a274 1
			   (P.blk(3, [decodetag c, 
d276 2
a277 2
				      decodelambda l])))
		      c_lambda_list) @@
d279 1
a279 4
			       case lambda_opt1 of 
				   LambdaTypes.ABSENT => P.str"<none>"
				 | LambdaTypes.PRESENT(lam) => 
				       			decodelambda lam]),
d281 3
a283 5
			       case lambda_opt2 of 
				   LambdaTypes.ABSENT => P.str"<none>"
				 | LambdaTypes.PRESENT(lam) => 
				       			decodelambda lam])])
		    ))]
d286 7
a292 2
	 => [P.blk(1,P.lst ("{", [P.str ",", P.brk 1], "}")
		   (map decodelambda lambda_list))]
d295 10
a304 5
	 => bracket(compound lambda) [decodelambda lambda,
				      P.str "[",
				      P.str(LambdaTypes.printField(field)),
				      P.str "]"]

d306 6
a311 2
	 => [P.str "RAISE ",
	     decodelambda lambda]
d314 9
a322 3
	 => (bracket (compound lambda1) [decodelambda lambda1]) @@
	    [P.str(" HANDLE"), P.brk 1] @@
	    (bracket (compound lambda2) [decodelambda lambda2])
d325 1
a325 1
	 => [P.str"BUILTIN ", P.str(LambdaTypes.printPrim prim)])
d329 1
a329 1
      				(P.blk(1,[P.brk 1, decodelambda e]));
a330 3
  fun string_of_tag t = P.string_of_T (P.blk(1,[P.brk 1, decodetag t]));
    

d342 1
a342 1
      val pt = (P.blk(1,[P.brk 1, decodelambda e]));
d374 1
a374 1
					   LambdaTypes.null_type_annotation()))
@


1.32
log
@Added print_types flag.
@
text
@d4 3
a89 2
   val decodelambda_expr = 
    let
a230 3
   in
       decodelambda
   end
d234 1
a234 1
      				(P.blk(1,[P.brk 1, decodelambda_expr e]));
d236 3
d250 1
a250 1
      val pt = (P.blk(1,[P.brk 1, decodelambda_expr e]));
@


1.31
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d46 2
d108 11
a118 9
	 => [P.str name,
             P.brk 1, P.str ": ",
             P.str(Types.print_type ty),
             P.brk 1,
             P.str "\\",
	     P.blk(0,[P.str(LambdaTypes.printLVar lvar),
		      P.str("."), 
		      (* P.brk 0,  gives too many nl's *)
		      decodelambda lambda])]
d173 5
a177 2
			  [P.brk 1, P.str ":", P.brk 1,
			   P.str(Types.print_type ty)])]
@


1.30
log
@Added an annotation slot to HANDLE
@
text
@d4 3
a9 92
Revision 1.28  1992/06/11  08:41:08  clive
Needed to add type annotation to Fnexps

Revision 1.27  1992/04/16  08:31:56  clive
Modified to print function name information

Revision 1.26  1992/04/13  13:56:02  clive
First version of the profiler

Revision 1.25  1992/03/23  11:06:05  jont
Added Integer parameter to the functor

Revision 1.24  1992/02/11  17:16:48  jont
Put terminators on print of Letsand LETRECs in order to distinguish
APP(LETREC(lv, _, V(lv)), exp) from LETREC(lv, _, APP(V(lv), exp))
and the same for Lets.

Revision 1.23  1991/09/24  13:27:00  davida
Clarified bracketing of HANDLE expressions

Revision 1.22  91/09/11  15:58:34  davida
print_info stuff corrected to avoid building huge
strings.

Revision 1.21  91/09/10  17:10:40  davida
Added string_of_info function.

Revision 1.20  91/08/23  17:07:21  davida
_Removed_ code to print names of builtins from
initial environment in main/primitives -
Jon decided he'd do it instead!!

Revision 1.19  91/08/22  15:35:46  davida
Added code to print names of builtins from
initial environment in main/primitives.

Revision 1.18  91/08/07  15:29:42  davida
Added flag to allow APP(FN ...) to be displayed as Let .. In ..

Revision 1.17  91/08/06  13:46:56  davida
Added function to print lambda-expression as
it is converted from pretty-printing tree.

Revision 1.16  91/08/05  14:54:15  davida
Removed the new-line added to the end of all
output because it was annoying me.

Revision 1.15  91/07/31  12:42:51  davida
Perfectionist touch-up to output of STRUCTS split across lines.

Revision 1.14  91/07/24  10:16:48  davida
Now knows function application assocs to left, and
so prints less brackets.

Revision 1.13  91/07/22  13:53:35  davida
Minor improvements in output aesthetics...

Revision 1.12  91/07/19  16:45:12  davida
New version using custom pretty-printer

Revision 1.11  91/07/16  14:54:32  jont
Updated to cope with extra tag type in switches

Revision 1.10  91/07/11  11:53:32  jont
Changed to cope with new style LETREC

Revision 1.9  91/06/26  17:43:29  jont
Tidied up LETREC

Revision 1.8  91/06/26  16:35:33  jont
Now decodes all lambda expression types

Revision 1.7  91/06/24  17:04:10  jont
Tidied up by reducing the number of brackets

Revision 1.6  91/06/18  19:10:00  jont
Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor

Revision 1.5  91/06/18  13:40:00  jont
Added printing of INT in lambda calculus for nullary constructors

Revision 1.4  91/06/14  17:25:00  jont
Added printing of module structures (to some extent)

Revision 1.3  91/06/13  19:55:00  jont
*** empty log message ***

Revision 1.2  91/06/12  19:36:00  jont
Removed left over junk. Split out types from Lambda.

d62 1
d64 9
d74 7
a80 7
	  let 
	      fun unwl(acc, LambdaTypes.APP(LambdaTypes.FN(var,body,_,_),arg)) =
		  				unwl ((var,arg)::acc, body)
		| unwl(acc, expr) = (rev acc, expr)
	  in
	      unwl([],expr)
	  end
d104 1
a104 1
             P.brk 1,
d128 16
a143 1
       | LambdaTypes.APP(lambda_fn, lambda_arg)
d147 1
a147 1
		val (lets,expr) = unwrap_lets expression
d149 1
a149 1
	        [P.str "Let ",
d165 3
a167 1
			   [decodelambda lambda_arg]))]
d270 2
a271 1
					   LambdaTypes.INT ~1))
@


1.29
log
@Faster printing scheme.
@
text
@d4 3
d275 1
a275 1
       | LambdaTypes.HANDLE(lambda1, lambda2)
@


1.28
log
@Needed to add type annotation to Fnexps
@
text
@d4 3
d129 1
a129 1

d296 7
a302 5
  val myprint = fn s => output(std_out, s);
 
  fun print_lambda e = (P.print_T myprint
			(P.blk(1,[P.brk 1, decodelambda_expr e]));
			myprint "\n");
d304 2
d307 3
a309 2
  fun print_info (LambdaTypes.Info{bindings,known_fns,non_escaping_fns,
					    is_shiftable,...}) = 
d311 6
a316 4
	fun print_lvar_set lvs = 
	   myprint ("{" ^ 
		    (LambdaTypes.Set.set_print (lvs, LambdaTypes.printLVar))
		    ^ "}")
d318 28
a345 6
	fun print_bindings [] = ()
	  | print_bindings ((var,expr)::bs) = 
	    (myprint ("  v"^(LambdaTypes.printLVar var)^
		      " =====>");
	     print_lambda expr;
	     print_bindings bs)
d347 1
a347 7
	val shiftable_appvars = 
	   Lists.reducel (fn (acc,(var,_)) => 
			  if is_shiftable 
			   (LambdaTypes.APP(LambdaTypes.VAR var, 
					    LambdaTypes.INT ~1))
			     then LambdaTypes.Set.add_member (var,acc)
			  else acc) (LambdaTypes.Set.empty_set,LambdaTypes.BindingTable.to_list bindings)
a348 13
	fun iter f [] = ()
	  | iter f (x::xs) = (f x; iter f xs)
     in
	(myprint "Bindings: \n";
	 print_bindings (LambdaTypes.BindingTable.to_list bindings);
	 myprint "Shiftable app var's: ";
	 print_lvar_set shiftable_appvars;
	 myprint "\nKnown functions: ";
	 print_lvar_set known_fns;
	 myprint "\nNon-escaping functions: ";
	 print_lvar_set non_escaping_fns;
	 myprint "\n")
     end
@


1.27
log
@Modified to print function name information
@
text
@d4 3
d100 1
d112 1
d114 1
d148 1
a148 1
	      fun unwl(acc, LambdaTypes.APP(LambdaTypes.FN(var,body,_),arg)) =
d175 1
a175 1
       | LambdaTypes.FN (lvar, lambda,name)
d177 2
@


1.26
log
@First version of the profiler
@
text
@d4 3
d169 4
a172 2
       | LambdaTypes.FN (lvar, lambda,_)
	 => [P.str "\\",
d313 1
a313 1
			  else acc) (LambdaTypes.Set.empty_set,bindings)
d319 1
a319 1
	 print_bindings bindings;
@


1.25
log
@Added Integer parameter to the functor
@
text
@d4 3
d139 1
a139 1
	      fun unwl(acc, LambdaTypes.APP(LambdaTypes.FN(var,body),arg)) =
d166 1
a166 1
       | LambdaTypes.FN (lvar, lambda)
@


1.24
log
@Put terminators on print of Letsand LETRECs in order to distinguish
APP(LETREC(lv, _, V(lv)), exp) from LETREC(lv, _, APP(V(lv), exp))
and the same for Lets.
@
text
@d4 5
d88 1
d96 2
a100 1
  structure Lists : LISTS
@


1.23
log
@Clarified bracketing of HANDLE expressions
@
text
@d3 4
a6 1
$Log:	_lambdaprint.sml,v $
d175 2
a176 1
	     (bracket (compound lambda_exp) [decodelambda lambda_exp])
d192 1
a192 1
		 (bracket (compound expr) [decodelambda expr])
@


1.22
log
@print_info stuff corrected to avoid building huge
strings.
@
text
@d4 4
d113 4
a116 1
      fun compound x = (is_app x) orelse (is_abs x)
d243 3
a245 4
	 => bracket (true) [decodelambda lambda1, 
			    P.str(" HANDLE"), 
			    P.brk 1,
			    decodelambda lambda2]
@


1.21
log
@Added string_of_info function.
@
text
@d4 3
d248 12
a265 2
  fun string_of_lambda e = P.string_of_T 
      				(P.blk(1,[P.brk 1, decodelambda_expr e]));
d267 2
a268 2
  fun string_of_info (LambdaTypes.Info{bindings,known_fns,non_escaping_fns,
				       is_shiftable,...}) = 
d271 3
a273 2
	   "{" ^ (LambdaTypes.Set.set_print (lvs, LambdaTypes.printLVar))
	   ^ "}"
d275 6
a280 3
	fun print_binding (var,expr) = "  v"^(LambdaTypes.printLVar var)^
	   				" =====>\n"^
	   			       (string_of_lambda expr)^"\n"
d289 3
d293 9
a301 4
	"Bindings: \n"^(implode(map print_binding bindings))^
	"Of which shiftable app var's: "^(print_lvar_set shiftable_appvars)^
	"\nKnown functions: "^(print_lvar_set known_fns)^
	"\nNon-escaping functions: "^(print_lvar_set non_escaping_fns)^"\n"
@


1.20
log
@_Removed_ code to print names of builtins from
initial environment in main/primitives -
Jon decided he'd do it instead!!
@
text
@d4 5
d254 24
@


1.19
log
@Added code to print names of builtins from
initial environment in main/primitives.
@
text
@d4 4
a67 1
require "../utils/map";
a73 3
require "environ";
require "../main/primitives";

a77 1
  structure Types : TYPES
a78 1
  structure Map : MAP
a79 2
  structure Environ : ENVIRON
  structure Primitives : PRIMITIVES
d81 1
a81 6
  sharing LambdaTypes = Environ.EnvironTypes.LambdaTypes
          = Primitives.LambdaTypes
  sharing Environ.EnvironTypes = Primitives.EnvironTypes
  sharing Map = Environ.EnvironTypes.Map
  sharing Ident = LambdaTypes.Ident = 
          Environ.Ident = IdentPrint.Ident) : LAMBDAPRINT =
a93 35
 local
    val initial_env_assoc = 
       let
	  fun flatten [] = []
	    | flatten (x::xs) = x@@(flatten xs)
	      
	  fun extract_env (Environ.EnvironTypes.ENV (VE,EE,SE)) = 
	     Map.assoc VE @@ Map.assoc EE @@ (flatten (map extract_env
					    (map (fn(e,_)=>e) (Map.range SE))))
       in
	  extract_env Primitives.initial_env
       end

    val primitive_names =
       let
	  val _ = IdentPrint.include_class := false;

	  fun revenv ([],acc) = acc
	    | revenv ((valid, Environ.EnvironTypes.PRIM prim)::env, acc) =
	              (revenv (env, (prim, IdentPrint.printValId valid)::acc))
	    | revenv (_::env,acc) = revenv(env,acc)
       in
	  revenv (initial_env_assoc,[])
       end
 in
    fun get_prim_name key =
       let 
	  fun getprim [] = LambdaTypes.printPrim key
	    | getprim ((key',value)::kvs) = if key=key' then value
					    else getprim kvs
       in
	  getprim primitive_names
       end
 end

d234 1
a234 1
	 => [P.str"BUILTIN ", P.str(get_prim_name prim)])
@


1.18
log
@
Added flag to allow APP(FN ...) to be displayed as Let .. In ..
@
text
@d4 3
d64 1
a69 1
require "environtypes";
d71 3
d79 5
a83 7
  structure Lists: LISTS
  structure LambdaTypes: LAMBDATYPES
  structure EnvironTypes: ENVIRONTYPES
  sharing LambdaTypes = EnvironTypes.LambdaTypes
  sharing Ident = LambdaTypes.Ident
  sharing Ident = IdentPrint.Ident) : LAMBDAPRINT =
struct
d85 8
d101 37
d278 1
a278 2
	 => [P.str"BUILTIN ", 
	     P.str(LambdaTypes.printPrim prim)])
@


1.17
log
@Added function to print lambda-expression as
it is converted from pretty-printing tree.
@
text
@d4 4
d86 3
d100 12
d128 2
a129 2
     and decodelambda x = 
	P.blk(0,case x of
d151 2
a152 2
	     P.str "in ",
	     decodelambda lambda_exp]
d155 22
a176 6
	 => [P.blk(0,(bracket ((compound lambda_fn) 
			       andalso (not(is_app lambda_fn)))
		      [decodelambda lambda_fn])),
	     P.brk 1,
	     P.blk(1,(bracket (compound lambda_arg) 
		      [decodelambda lambda_arg]))]
@


1.16
log
@Removed the new-line added to the end of all
output because it was annoying me.
@
text
@d4 4
d109 2
a110 2
     and decodelambda x = P.blk(0,
	 case x of
d112 1
a112 2
	     => [P.str("v"), 
		 P.str(LambdaTypes.printLVar lvar)]
d115 1
a115 1
	 => [P.str("\\"), 
d201 8
a208 3
  fun printlambda e = P.string_of_T 
      			(P.blk(1,[P.brk 1, decodelambda_expr e]));
		       
@


1.15
log
@Perfectionist touch-up to output of STRUCTS split across lines.
@
text
@d4 3
d199 1
a199 1
      			(P.blk(1,[P.brk 1, decodelambda_expr e, P.nl]));
@


1.14
log
@Now knows function application assocs to left, and
so prints less brackets.
@
text
@d4 4
d168 2
a169 2
	 => P.lst ("{", [P.str ",", P.brk 1], "}")
	     (map decodelambda lambda_list)
@


1.13
log
@Minor improvements in output aesthetics...
@
text
@d4 3
d71 3
d75 2
a76 12
  fun compound (LambdaTypes.VAR _) = false
    | compound (LambdaTypes.FN(_,le)) = compound le
    | compound (LambdaTypes.LETREC _) = false
    | compound (LambdaTypes.APP _) = true
    | compound (LambdaTypes.SCON _) = false
    | compound (LambdaTypes.INT _) = false
    | compound (LambdaTypes.SWITCH _) = false
    | compound (LambdaTypes.STRUCT _) = false
    | compound (LambdaTypes.SELECT _) = false
    | compound (LambdaTypes.RAISE _) = false
    | compound (LambdaTypes.HANDLE _) = false
    | compound (LambdaTypes.BUILTIN _) = false
d78 1
a78 2
  fun bracket t x = if t then [P.brk 0, P.str "("] @@ x @@ [P.str ")"]
		    else x;
d80 5
a84 3
  val decodelambda_expr = 
   let

d126 3
a128 1
	 => [P.blk(0,(bracket (compound lambda_fn) [decodelambda lambda_fn])),
d188 2
a189 1
   end;
@


1.12
log
@New version using custom pretty-printer
@
text
@d4 3
d109 4
a112 2
	     P.blk(1,[P.str(LambdaTypes.printLVar lvar),
		      P.str("."), decodelambda lambda])]
d120 1
a120 2
				      P.str ",",
				      P.brk 2,
d124 3
a126 5
	     P.brk 1,
	     P.str "in",
	     P.brk 1,
	     decodelambda lambda_exp,
	     P.nl]
d144 1
d146 1
a146 1
		    (P.lst ("[  ",[P.nl, P.str" | "],"  ]")
d148 1
a148 1
			   (P.blk(4, [decodetag c, 
d152 1
a152 1
		     [P.blk(4,[P.str"default", P.brk 1, P.str"=> ",
d157 1
a157 1
		      P.blk(4,[P.str"pointer", P.brk 1, P.str"=> ",
d175 1
a175 1
	 => [P.str("RAISE "), 
@


1.11
log
@Updated to cope with extra tag type in switches
@
text
@d4 3
a38 1
require "../utils/sexpr";
d42 1
d48 1
a48 1
  structure Sexpr : SEXPR
d60 1
a60 1
  structure S = Sexpr
a64 1
  type 'a Sexpr = 'a Sexpr.Sexpr
d66 12
a77 2
  exception not_done_yet (*of string*) = LambdaTypes.not_done_yet
  val printSexpr = S.pprintSexpr (fn x => x)
d79 113
a191 47
  fun decodelambda x = let
    fun decodetag tag =
      case tag of
        LambdaTypes.CON_TAG i => S.list[S.ATOM("CON_TAG"),
        S.ATOM(Integer.makestring i)]
      | LambdaTypes.SCON_TAG scon => S.list[S.ATOM("SCON_TAG"),
        S.ATOM(IP.printSCon scon)]
      | LambdaTypes.EXP_TAG exp => decodelambda exp
  in
    case x of
      LambdaTypes.VAR lvar
      => S.list[S.ATOM("VAR"), S.ATOM(LambdaTypes.printLVar lvar)]
    | LambdaTypes.FN (lvar, lambda)
      => S.list[S.ATOM("lambda"), S.ATOM(LambdaTypes.printLVar lvar),
	S.ATOM("."), decodelambda lambda]
    | LambdaTypes.LETREC(lvar_list, lambda_list, lambda_exp)
      => S.list((S.ATOM"LETREC") :: (map (fn (lv, le) =>
        S.list[S.ATOM(LambdaTypes.printLVar lv), S.ATOM",", decodelambda le])
	  (Lists.zip(lvar_list, lambda_list))) @@
	    [S.ATOM" in ", decodelambda lambda_exp, S.ATOM" end "])
    | LambdaTypes.APP(lambda_fn, lambda_arg)
      => S.list[decodelambda lambda_fn,	decodelambda lambda_arg]
    | LambdaTypes.SCON scon
      => S.list[S.ATOM("SCON"), S.ATOM (IP.printSCon scon)]
    | LambdaTypes.INT i
      => S.list[S.ATOM("INT"), S.ATOM (Integer.makestring i)]
    | LambdaTypes.SWITCH(lambda, c_lambda_list, lambda_opt1, lambda_opt2) =>
      S.list[S.ATOM "SWITCH", decodelambda lambda,
	S.list(map (fn (c, l) => (S.list[decodetag c, decodelambda l]))
          c_lambda_list),
	case lambda_opt1 of LambdaTypes.ABSENT => S.ATOM"()"
	| LambdaTypes.PRESENT(lam) => decodelambda lam,
	case lambda_opt2 of LambdaTypes.ABSENT => S.ATOM"()"
	| LambdaTypes.PRESENT(lam) => decodelambda lam]
    | LambdaTypes.STRUCT lambda_list
      => S.list[S.ATOM "STRUCT", S.list(map decodelambda lambda_list)]
    | LambdaTypes.SELECT(field, lambda)
      => S.list[S.ATOM("SELECT"), S.ATOM(LambdaTypes.printField(field)),
        decodelambda(lambda)]
    | LambdaTypes.RAISE lambda
      => S.list[S.ATOM("RAISE"), decodelambda lambda]
    | LambdaTypes.HANDLE(lambda1, lambda2)
      => S.list[S.ATOM("HANDLE"), decodelambda lambda1, decodelambda lambda2]
    | LambdaTypes.BUILTIN prim
      => S.list[S.ATOM"BUILTIN", S.ATOM(LambdaTypes.printPrim prim)]
  end
  fun printlambda x = printSexpr (decodelambda x)
@


1.10
log
@Changed to cope with new style LETREC
@
text
@d4 3
d68 3
a70 3
    fun decodeconstruc(construc) =
      case construc of
        LambdaTypes.CON_TAG(i) => S.list[S.ATOM("CON_TAG"),
d72 1
a72 1
      | LambdaTypes.SCON_TAG(scon) => S.list[S.ATOM("SCON_TAG"),
d74 1
d95 1
a95 1
	S.list(map (fn (c, l) => (S.list[decodeconstruc c, decodelambda l]))
@


1.9
log
@Tidied up LETREC
@
text
@d4 3
d78 1
a78 1
    | LambdaTypes.LETREC(lvar_list, lambda_list)
d81 2
a82 1
	  (Lists.zip(lvar_list, lambda_list))))
@


1.8
log
@Now decodes all lambda expression types
@
text
@d4 3
d76 1
a76 1
      => S.list(map (fn (lv, le) =>
d78 1
a78 4
	  (Lists.zip(lvar_list, lambda_list)))
(*
 raise(not_done_yet("Dunno how to deal with LambdaTypes.LETREC"))
*)
a101 3
(*
raise(not_done_yet("Dunno how to deal with LambdaTypes.HANDLE"))
*)
a103 3
(*
raise(not_done_yet("Dunno how to deal with LambdaTypes.BUILTIN"))
*)
@


1.7
log
@Tidied up by reducing the number of brackets
@
text
@d4 3
d28 1
d35 11
a45 9
functor LambdaPrint (structure Sexpr : SEXPR
		    structure IdentPrint : IDENTPRINT
		    structure Ident : IDENT
                    structure Types : TYPES
		    structure LambdaTypes: LAMBDATYPES
		    structure EnvironTypes: ENVIRONTYPES
		    sharing LambdaTypes = EnvironTypes.LambdaTypes
		    sharing Ident = LambdaTypes.Ident
		    sharing Ident = IdentPrint.Ident) : LAMBDAPRINT =
d72 7
a78 2
    | LambdaTypes.LETREC(lvar_list, lambda_list, lambda)
      => raise(not_done_yet("Dunno how to deal with LambdaTypes.LETREC"))
d101 9
a109 3
      => raise(not_done_yet("Dunno how to deal with LambdaTypes.HANDLE"))
    | LambdaTypes.BUILTIN primitive
      => raise(not_done_yet("Dunno how to deal with LambdaTypes.BUILTIN"))
@


1.6
log
@Added second default case to SWITCH statement to allow easy distinction
of tag from not a tag cases, eg when deconstructing a value carrying
constructor
@
text
@d4 5
d55 4
a58 4
        LambdaTypes.CON_TAG(i) => S.list[S.ATOM("CON_TAG("),
        S.ATOM(Integer.makestring i), S.ATOM(")")]
      | LambdaTypes.SCON_TAG(scon) => S.list[S.ATOM("SCON_TAG("),
        S.ATOM(IP.printSCon scon), S.ATOM(")")]
d61 6
a66 7
      LambdaTypes.VAR (lvar)              (* variable lookup *)
      => S.list[S.ATOM("VAR("), S.ATOM(LambdaTypes.printLVar lvar), S.ATOM(")")]
    | LambdaTypes.FN (lvar, lambda)       (* function definition *)
      => S.list[S.ATOM("(lambda"), S.ATOM(LambdaTypes.printLVar lvar),
	S.ATOM("."), decodelambda lambda, S.ATOM(")")]
    | LambdaTypes.LETREC                  (* allows recursive definitions *)
      (lvar_list, lambda_list, lambda)
d68 8
a75 10
    | LambdaTypes.APP (lambda_fn, lambda_arg) (* function application *)
      => S.list[S.ATOM("("), decodelambda lambda_fn,
	decodelambda lambda_arg, S.ATOM(")")]
    | LambdaTypes.SCON (scon)             (* int, real, string ... *)
      => S.list[S.ATOM("SCON("), S.ATOM (IP.printSCon scon), S.ATOM(")")]
    | LambdaTypes.INT (i)                 (* int, real, string ... *)
      => S.list[S.ATOM("INT("), S.ATOM (Integer.makestring i), S.ATOM(")")]
    | LambdaTypes.SWITCH                  (* like a case statement *)
      (lambda, c_lambda_list, lambda_opt1, lambda_opt2) =>
      S.list[S.ATOM("SWITCH("), decodelambda lambda,
d81 9
a89 11
	| LambdaTypes.PRESENT(lam) => decodelambda lam,
	  S.ATOM(")")]
    | LambdaTypes.STRUCT (lambda_list)    (* structure definition *)
      => S.list[S.ATOM "STRUCT(", S.list(map decodelambda lambda_list),
        S.ATOM")"]
    | LambdaTypes.SELECT (field, lambda)   (* field selector *)
      => S.list[S.ATOM("SELECT("), S.ATOM(LambdaTypes.printField(field)),
        decodelambda(lambda), S.ATOM(")")]
    | LambdaTypes.RAISE (lambda)          (* Exceptions --- throw ... *)
      => S.list[S.ATOM("("), decodelambda lambda, S.ATOM(")")]
    | LambdaTypes.HANDLE (lambda1, lambda2)(*            ... and catch *)
d91 1
a91 4
    | LambdaTypes.BUILTIN (primitive)     (* built-in functions --
				        These functions are
					primitive to the abstract
					machine. *)
@


1.5
log
@Added printing of INT in lambda calculus for nullary constructors
@
text
@d4 3
d72 1
a72 1
      (lambda, c_lambda_list, lambda_opt) =>
d76 3
a78 1
	case lambda_opt of LambdaTypes.ABSENT => S.NIL
@


1.4
log
@Added printing of module structures (to some extent)
@
text
@d4 3
d66 2
@


1.3
log
@*** empty log message ***
@
text
@d1 1
a1 1
(* _LambdaExpprint.sml the functor *)
d4 3
@


1.2
log
@Removed left over junk. Split out types from Lambda.
@
text
@d3 4
a6 1
$Log$
d69 2
a70 1
      => S.list(map decodelambda lambda_list)
@


1.1
log
@Initial revision
@
text
@d1 6
a6 2
(* _lambdaprint.sml the functor *)
require "lambdaprint";
a8 1
require "lambda";
d10 3
a12 1
require "environ";
d18 4
a21 4
		    structure Lambda: LAMBDA
		    structure Environ: ENVIRON
		    sharing Ident = Lambda.Ident
		    sharing type Environ.LVar = Lambda.LVar
d23 1
a23 1
  struct
d25 4
a28 5
    structure S = Sexpr
    structure IP = IdentPrint
    structure Ident = Ident
    structure Symbol = Ident.Symbol
    structure Lambda = Lambda
d30 1
a30 4
    type 'a Sexpr = 'a Sexpr.Sexpr
(*
    type LVar = Environ.LVar           (* The type of lambda variables *)
*)
d32 2
a33 1
      exception not_done_yet (*of string*) = Environ.not_done_yet
d35 41
a75 347
(*
    fun detreeTy (ty) =
      case ty of
	Absyn.TYVARty tyvar => S.ATOM (IP.printTyVar tyvar)
      | Absyn.RECORDty tyrow => 
	  S.list (S.ATOM "RECORDty" :: detreeTyRow tyrow)
      | Absyn.APPty (tyseq, longtycon) => 
	  S.list (S.ATOM "APPty" :: S.ATOM (IP.printLongTyCon longtycon) ::
		  map detreeTy tyseq)
      | Absyn.FNty (ty,ty') =>
	  S.list [S.ATOM "FNty", detreeTy ty, detreeTy ty']

    and detreeTyRow (tyrow) =
      map (fn (lab,ty) => S.list [S.ATOM (IP.printLab lab), detreeTy ty]) tyrow
      
    fun detreePat (pat) =
      case pat of
	Absyn.WILDpat => S.ATOM "_"
      | Absyn.SCONpat scon => S.ATOM (IP.printSCon scon)
      | Absyn.VALpat (longvalid,ref ty) => 
	  S.list [S.ATOM (IP.printLongValId longvalid),
		  S.ATOM (Types.print_type ty)]
      | Absyn.RECORDpat (patrow, false, ref ty) => 
	  S.list [S.list (S.ATOM "RECORDpat" :: detreePatRow patrow),
		  S.ATOM (Types.print_type ty)]
      | Absyn.RECORDpat (patrow, true, ref ty) => 
	  S.list [S.list (S.ATOM "FLEXRECORDpat" :: detreePatRow patrow),
		  S.ATOM (Types.print_type ty)]
      | Absyn.APPpat ((longvalid,_), pat) => 
	  S.list [S.ATOM (IP.printLongValId longvalid), detreePat pat]
      | Absyn.TYPEDpat (pat,ty) => 
	  S.list [detreePat pat, detreeTy ty]
      | Absyn.LAYEREDpat ((valid,ref ty), pat) => 
	  S.list [S.list [S.ATOM (IP.printValId valid),
			  S.ATOM (Types.print_type ty)], detreePat pat]
	  
    and detreePatRow (patrow) =
      map (fn (lab,pat) => S.list [S.ATOM (IP.printLab lab), detreePat pat])
      patrow
      

    fun detreeExp (exp) =
      case exp of
	Absyn.SCONexp scon => S.ATOM (IP.printSCon scon)
      | Absyn.VALexp (longvalid,ref ty) => 
          S.list [S.ATOM (IP.printLongValId longvalid),
		  S.ATOM (Types.print_type ty)]
      | Absyn.RECORDexp exprow => 
	  S.list (S.ATOM "RECORDexp" :: detreeExpRow exprow)
      | Absyn.LOCALexp (dec,exp) => 
	  S.list [S.ATOM "LOCALexp", detreeDec dec, detreeExp exp]
      | Absyn.APPexp (exp,exp') => 
	  S.list [S.ATOM "APPexp", detreeExp exp, detreeExp exp']
      | Absyn.TYPEDexp (exp,ty) => 
	  S.list [S.ATOM "TYPEDexp", detreeExp exp, detreeTy ty]
      | Absyn.HANDLEexp (exp,match) =>
	  S.list (S.ATOM "HANDLEexp" :: detreeExp exp :: detreeMatch match)
      | Absyn.RAISEexp (exp,_) => 
	  S.list [S.ATOM "RAISEexp", detreeExp exp]
      | Absyn.FNexp (match,_,_) =>
	  S.list (S.ATOM "FNexp" :: detreeMatch match)
	  
    and detreeExpRow exprow = 
      map (fn (lab,exp) => S.list [S.ATOM (IP.printLab lab), detreeExp exp])
      exprow
      
    and detreeMatch match =
      map (fn (pat,exp) => S.list [detreePat pat, detreeExp exp]) match
  
    and detreeDec dec = 
      case dec of
	Absyn.VALdec (valbind,valbind',tyvars) =>
	  S.list [S.ATOM "VALdec",
		  S.list (detreeValBind valbind),
		  S.list (detreeValBind valbind'),
		  S.list (detreeTyVars (Set.set_to_list tyvars))]
	  
      | Absyn.TYPEdec typbind => 
	  S.list (S.ATOM "TYPEdec" :: detreeTypBind typbind)
	  
      | Absyn.DATATYPEdec datbind => 
	  S.list (S.ATOM "DATATYPEdec" :: detreeDatBind datbind)
	  
      | Absyn.ABSTYPEdec (datbind,dec) => 
	  S.list [S.ATOM "ABSTYPEdec",
		  S.list (detreeDatBind datbind), detreeDec dec]
	  
      | Absyn.EXCEPTIONdec (exbind) => 
	  S.list (S.ATOM "EXCEPTIONdec" :: detreeExBind exbind)
	  
      | Absyn.LOCALdec (dec,dec') => 
	  S.list [S.ATOM "LOCALdec", detreeDec dec, detreeDec dec']
	  
      | Absyn.OPENdec (longstrids) => 
	  S.list (S.ATOM "OPENdec" :: detreeLongStrIds longstrids)

      | Absyn.SEQUENCEdec (decs) => 
	  S.list (S.ATOM "SEQUENCEdec" :: map detreeDec decs)
	  
    and detreeTyVars (tyvars) =
      map (fn tyvar => S.ATOM (IP.printTyVar tyvar)) tyvars
      
    and detreeLongStrIds (longstrids) =
      map (fn longstrid => S.ATOM (IP.printLongStrId longstrid)) longstrids
  
    and detreeTypBind (typbind) =
      map (fn (tyvars,tycon,ty) =>
	   S.list [S.list (S.ATOM (IP.printTyCon tycon) :: 
			   detreeTyVars tyvars), detreeTy ty]) 
      typbind

    and detreeDatBind (datbind) =
      map (fn (tyvars,tycon,_,conbind) =>
	   S.list (S.list (S.ATOM (IP.printTyCon tycon) :: 
			   detreeTyVars tyvars) :: detreeConBind conbind)) 
      datbind

    and detreeConBind (conbind) =
      map (fn ((valid,ref ty),Absyn.ABSENT) => 
	       S.list [S.ATOM (IP.printValId valid),
		       S.ATOM (Types.print_type ty)]
             | ((valid,_),Absyn.PRESENT ty) =>
		 S.list [S.ATOM (IP.printValId valid), detreeTy ty])
      conbind
      
    and detreeExBind (exbind) =
      map (fn Absyn.NEWexbind ((valid,ref ty),Absyn.ABSENT) =>
	       S.list [S.ATOM (IP.printValId valid),
		       S.ATOM (Types.print_type ty)]
	    | Absyn.NEWexbind ((valid,ref ty),Absyn.PRESENT ty') => 
		S.list [S.list [S.ATOM (IP.printValId valid),
				S.ATOM (Types.print_type ty)],detreeTy ty']
	    | Absyn.OLDexbind ((valid,ref ty),longvalid) => 
		S.list [S.list [S.ATOM (IP.printValId valid),
				S.ATOM (Types.print_type ty)],
			S.ATOM (IP.printLongValId longvalid)])
      exbind

    and detreeValBind (valbind) =
      map (fn (pat,exp) => S.list [detreePat pat, detreeExp exp]) valbind

    val printSexpr = S.pprintSexpr (fn x => x)

    fun printDec x = printSexpr (detreeDec x)
    fun printExp x = printSexpr (detreeExp x)
    fun printPat x = printSexpr (detreePat x)
    fun printTy x = printSexpr (detreeTy x)

(* Make a string version of a record, with the labels separated
   from the items by labsep, and the fields separated by sep.  Using
   unparseLab to generate the string representation of the labels, and
   unparseOther to make the string version of the other fields. *)
    fun record_print labsep sep unparseLab unparseOther all =
      let
	fun rec_f [] rest = rest
	  | rec_f [(lab, other)] rest =
	      rest ^ (unparseLab lab) ^ labsep ^ (unparseOther other)
	  | rec_f ((lab, other)::more) rest =
	      rec_f more (rest ^ (unparseLab lab) ^
			  labsep ^ (unparseOther other) ^ sep)
      in
	rec_f all ""
      end

(* Make a string version of a tuple. *)
    fun tuple_print _ unparseOther [ one ] = unparseOther one
      | tuple_print sep unparseOther all =
      let
	fun internal [] rest = rest
	  | internal [ h ] rest =
	      rest ^ (unparseOther h)
	  | internal (h::t) rest =
	      internal t (rest ^ (unparseOther h) ^ sep)
      in
	"(" ^ (internal all "") ^ ")"
      end

(* Given a record, find out if it is in suitable form to use
   tuple_print (ie we have all numeric labels from 1 -> n inclusive.)
   If so we return (true, the ordered list of values), otherwise we
   return (false, []). *)
    fun tuple_p all =
      let
	fun num_labs 0 _ rest = (true, rest)
	  | num_labs _ [] _ = (false, [])
	  | num_labs n all rest =
	    let
	      fun present a [] = (false, [])
		| present a ((Ident.LAB h, the_val)::t) =
		  if (Symbol.eq_symbol (a, h)) then
		    (true, the_val::rest)
		  else
		    present a t
	      val (found, newlist) = present (Symbol.find_symbol (Integer.makestring n)) all
	    in
	       if found then
		 num_labs (n - 1) all newlist
	       else
		 (false, [])
	    end
      in
	num_labs (length all) all []
      end

(* Convert a Type to a string. *)
    fun unparseTy ty =
      let
	fun record all =
	  let
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print "*" unparseTy new
	    else
	      "{" ^ (record_print ":" "," IP.printLab unparseTy all) ^ "}"
	  end

      in
	case ty of
	  Absyn.TYVARty tyvar => IP.printTyVar tyvar
	| Absyn.RECORDty tyrow => record tyrow
	| Absyn.APPty (tyseq, ltc) =>
	    ((tuple_print "," unparseTy tyseq) ^
	     " " ^ (IP.printLongTyCon ltc))
	| Absyn.FNty (ty, ty') =>
	    ( "(" ^ (unparseTy ty) ^ " -> " ^ (unparseTy ty') ^ ")" )
      end

(* Convert a Pat to a string. *)
    fun unparsePat pat =
      let
	fun record all =
	  let
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print "," unparsePat new
	    else
	      "{" ^ (record_print "=" "," IP.printLab unparsePat all ) ^ "}"
	  end

(* Flex records have ', ...' extra, and can't be in tuple form *)
	fun flex_record all =
	  "{" ^ (record_print "=" "," IP.printLab unparsePat all ) ^ ",...}"
      in
	    case pat of
	      Absyn.WILDpat => "_"
	    | Absyn.SCONpat scon => IP.printSCon scon
	    | Absyn.VALpat (lvi, _) => IP.printLongValId lvi
	    | Absyn.RECORDpat (pr, false, _) => record pr
	    | Absyn.RECORDpat (pr, true, _)  => flex_record pr

(* The routine should take account of the fact that infix constructor
   functions should be displayed differently, to other APPpats.  But
   I'll leave this 'til later. *)

	    | Absyn.APPpat ((lvi, _), pat) =>
		((IP.printLongValId lvi) ^ " " ^ unparsePat pat)
	    | Absyn.TYPEDpat (pat, ty) =>
		("(" ^ (unparsePat pat) ^ " : " ^ (unparseTy ty) ^ ")")
	    | Absyn.LAYEREDpat ((vi, _), pat) =>
		((IP.printValId vi) ^ " as " ^ (unparsePat pat))
      end

    fun unparseExp exp =
      let
	fun record all =
	  let
	    val (is_tuple, new) = tuple_p all
	  in
	    if (is_tuple) then
	      tuple_print "," unparseExp new
	    else
	      "{" ^ (record_print "=" "," IP.printLab unparseExp all ) ^ "}"
	  end

	fun fn_body [] rest = rest
	  | fn_body [ (pat, exp) ] rest =
	      rest ^ (unparsePat pat) ^ " => " ^ (unparseExp exp)
	  | fn_body ((pat, exp)::ll) rest =
	      fn_body ll (rest ^ (unparsePat pat) ^ " => " ^
			  (unparseExp exp) ^ " | ")

      in
	case exp of
	  Absyn.SCONexp scon => IP.printSCon scon
	| Absyn.VALexp (lvi, _) => IP.printLongValId lvi
	| Absyn.RECORDexp pr => record pr
	| Absyn.LOCALexp (dec, e) => "let ... in " ^ (unparseExp e) ^ " end"
	| Absyn.APPexp (e1, e2) => "(" ^ (unparseExp e1) ^ " " ^ (unparseExp e2) ^ ")"
	| Absyn.TYPEDexp (e, ty) => (unparseExp e) ^ ":" ^ (unparseTy ty)
	| Absyn.HANDLEexp _ => "...handle..."
	| Absyn.RAISEexp _ => "...raise..."
	| Absyn.FNexp (all,_,_) =>
	    fn_body all "fn "
      end

*)
    val printSexpr = S.pprintSexpr (fn x => x)

    fun decodelambda x = let
      fun decodeconstruc(construc) =
	case construc of
	  Lambda.CON_TAG(i) => S.list[S.ATOM("CON_TAG("),
          S.ATOM(Integer.makestring i), S.ATOM(")")]
	| Lambda.SCON_TAG(scon) => S.list[S.ATOM("SCON_TAG("),
          S.ATOM(IP.printSCon scon), S.ATOM(")")]
(*
      fun decode_construc_lambda_list [] = S.NIL
      | decode_construc_lambda_list ((construc, lambda) :: tl) =
	S.append(S.list[decodeconstruc construc, decodelambda lambda],
          decode_construc_lambda_list tl)
*)
    in
      case x of
	Lambda.VAR (lvar)              (* variable lookup *)
	=> S.list[S.ATOM("VAR("), S.ATOM(Environ.printLVar lvar), S.ATOM(")")]
      | Lambda.FN (lvar, lambda)       (* function definition *)
	=> S.list[S.ATOM("(lambda"), S.ATOM(Environ.printLVar lvar),
		  S.ATOM("."), decodelambda lambda, S.ATOM(")")]
      | Lambda.LETREC                  (* allows recursive definitions *)
	(lvar_list, lambda_list, lambda)
	=> raise(not_done_yet("Dunno how to deal with Lambda.LETREC"))
      | Lambda.APP (lambda_fn, lambda_arg) (* function application *)
	=> S.list[S.ATOM("("), decodelambda lambda_fn,
		  decodelambda lambda_arg, S.ATOM(")")]
      | Lambda.SCON (scon)             (* int, real, string ... *)
	=> S.list[S.ATOM("SCON("), S.ATOM (IP.printSCon scon), S.ATOM(")")]
      | Lambda.SWITCH                  (* like a case statement *)
	(lambda, c_lambda_list, lambda_opt) =>
	S.list[S.ATOM("SWITCH("), decodelambda lambda,
	  S.list(map (fn (c, l) => (S.list[decodeconstruc c, decodelambda l]))
            c_lambda_list),
	  case lambda_opt of Lambda.ABSENT => S.NIL
	  | Lambda.PRESENT(lam) => decodelambda lam,
	    S.ATOM(")")]
      | Lambda.STRUCT (lambda_list)    (* structure definition *)
	=> S.list(map decodelambda lambda_list)
      | Lambda.SELECT (inti, lambda)   (* field selector *)
	=> S.list[S.ATOM("SELECT("), S.ATOM(Integer.makestring(inti)),
          decodelambda(lambda), S.ATOM(")")]
      | Lambda.RAISE (lambda)          (* Exceptions --- throw ... *)
	=> S.list[S.ATOM("("), decodelambda lambda, S.ATOM(")")]
      | Lambda.HANDLE (lambda1, lambda2)(*            ... and catch *)
	=> raise(not_done_yet("Dunno how to deal with Lambda.HANDLE"))
      | Lambda.BUILTIN (primitive)     (* built-in functions --
					These functions are
d78 1
a78 3
	=> raise(not_done_yet("Dunno how to deal with Lambda.BUILTIN"))
    end
    fun printlambda x = printSexpr (decodelambda x)
d80 2
@
