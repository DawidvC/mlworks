head	1.46;
access;
symbols
	MLW_daveb_inline_1_4_99:1.46.1
	MLWorks_21c0_1999_03_25:1.46
	MLWorks_20c1_1998_08_20:1.46
	MLWorks_20c0_1998_08_04:1.46
	MLWorks_20b2c2_1998_06_19:1.46
	MLWorks_20b2_Windows_1998_06_12:1.46
	MLWorks_20b1c1_1998_05_07:1.46
	MLWorks_20b0_1998_04_07:1.46
	MLWorks_20b0_1998_03_20:1.46
	MLWorks_20m2_1998_02_16:1.46
	MLWorks_20m1_1997_10_23:1.45
	MLWorks_11r1:1.45.1.1.1.1.1
	MLWorks_workspace_97:1.45.3
	MLWorks_dt_wizard:1.45.2
	MLWorks_11c0_1997_09_09:1.45.1.1.1.1
	MLWorks_10r3:1.45.1.1.3
	MLWorks_10r2_551:1.45.1.1.2
	MLWorks_11:1.45.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.45.1.1
	MLWorks_20m0_1997_06_20:1.45
	MLWorks_1_0_r2c2_1997_06_14:1.45.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.45.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.45.1
	MLWorks_BugFix_1997_04_24:1.45
	MLWorks_1_0_r2_Win32_1997_04_11:1.45
	MLWorks_1_0_r2_Unix_1997_04_04:1.45
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.44.5.1.1
	MLWorks_gui_1996_12_18:1.44.6
	MLWorks_1_0_Win32_1996_12_17:1.44.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.44.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.44.3.1
	MLWorks_1_0_Irix_1996_11_28:1.44.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.44.4
	MLWorks_1_0_Unix_1996_11_14:1.44.3
	MLWorks_Open_Beta2_1996_10_11:1.44.2
	MLWorks_License_dev:1.44.1
	MLWorks_1_open_beta_1996_09_13:1.43.1
	MLWorks_Open_Beta_1996_08_22:1.43
	MLWorks_Beta_1996_07_02:1.41
	MLWorks_Beta_1996_06_07:1.41
	MLWorks_Beta_1996_06_06:1.41
	MLWorks_Beta_1996_06_05:1.41
	MLWorks_Beta_1996_06_03:1.41
	MLWorks_Beta_1996_05_31:1.41
	MLWorks_Beta_1996_05_30:1.41
	ML_beta_release_12/08/94:1.32
	ML_beta_release_03/08/94:1.32
	ML_revised_beta_release_25/05/94:1.30
	ML_final_beta_release_02/03/94:1.30
	mlworks-28-01-1994:1.28
	Release:1.27
	mlworks-beta-01-09-1993:1.27
	MLWorks-1-0-4-29/01/1993:1.21
	MLWorks-1-0-3-21/12/1992:1.21
	MLWorks-1-0-2-15/12/1992:1.21
	MLWorks-1-0-1-04/12/1992:1.21
	checkpoint_17_08_92:1.14;
locks; strict;
comment	@ * @;


1.46
date	98.02.05.16.25.57;	author jont;	state Exp;
branches
	1.46.1.1;
next	1.45;

1.45
date	96.12.02.15.41.41;	author matthew;	state Exp;
branches
	1.45.1.1
	1.45.2.1
	1.45.3.1;
next	1.44;

1.44
date	96.10.04.13.01.55;	author matthew;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1
	1.44.4.1
	1.44.5.1
	1.44.6.1;
next	1.43;

1.43
date	96.08.06.12.11.33;	author andreww;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	96.08.01.12.08.29;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	96.04.30.16.45.57;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	95.08.11.17.04.17;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	95.07.25.12.07.32;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	95.07.19.13.10.39;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	95.02.28.12.28.00;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	95.01.13.17.18.08;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	94.10.10.10.11.20;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	94.09.22.09.39.51;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	94.08.26.14.41.42;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	94.07.19.14.52.59;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	94.06.22.14.32.10;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	94.02.28.07.00.48;	author nosa;	state Exp;
branches;
next	1.29;

1.29
date	94.02.25.14.49.52;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	93.09.06.09.02.32;	author nosa;	state Exp;
branches;
next	1.27;

1.27
date	93.07.29.16.26.10;	author nosa;	state Exp;
branches
	1.27.1.1;
next	1.26;

1.26
date	93.03.10.17.02.43;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.03.04.13.14.06;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.03.02.17.48.38;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.03.01.14.19.48;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.02.04.14.23.22;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	92.11.10.13.41.19;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	92.10.26.18.15.46;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	92.09.10.10.10.34;	author richard;	state Exp;
branches;
next	1.18;

1.18
date	92.09.09.09.59.31;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.09.01.17.37.45;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	92.08.26.13.40.30;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.08.24.16.13.15;	author clive;	state Exp;
branches;
next	1.14;

1.14
date	92.08.07.15.21.06;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.08.04.14.43.43;	author davidt;	state Exp;
branches;
next	1.12;

1.12
date	92.07.22.09.05.10;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.07.21.14.21.23;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.07.16.17.00.00;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.07.14.10.14.19;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.07.07.14.40.06;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.07.02.13.23.10;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	92.06.29.09.31.55;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.06.25.19.19.23;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.06.23.10.04.39;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	92.06.18.10.27.58;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	92.06.11.11.01.21;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	92.05.05.13.25.57;	author jont;	state Exp;
branches;
next	;

1.27.1.1
date	93.07.29.16.26.10;	author jont;	state Exp;
branches;
next	;

1.43.1.1
date	96.09.13.11.17.31;	author hope;	state Exp;
branches;
next	;

1.44.1.1
date	96.10.07.16.07.16;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.10.17.11.25.34;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.11.14.12.50.36;	author hope;	state Exp;
branches
	1.44.3.1.1.1;
next	;

1.44.3.1.1.1
date	96.11.28.15.01.42;	author hope;	state Exp;
branches;
next	;

1.44.4.1
date	96.11.22.18.10.01;	author hope;	state Exp;
branches;
next	;

1.44.5.1
date	96.12.17.17.48.38;	author hope;	state Exp;
branches
	1.44.5.1.1.1;
next	;

1.44.5.1.1.1
date	97.02.24.11.38.37;	author hope;	state Exp;
branches;
next	;

1.44.6.1
date	96.12.18.09.42.40;	author hope;	state Exp;
branches;
next	;

1.45.1.1
date	97.05.12.10.35.07;	author hope;	state Exp;
branches
	1.45.1.1.1.1
	1.45.1.1.2.1
	1.45.1.1.3.1;
next	;

1.45.1.1.1.1
date	97.07.28.18.20.30;	author daveb;	state Exp;
branches
	1.45.1.1.1.1.1.1;
next	;

1.45.1.1.1.1.1.1
date	97.10.07.11.45.46;	author jkbrook;	state Exp;
branches;
next	;

1.45.1.1.2.1
date	97.09.08.17.13.59;	author daveb;	state Exp;
branches;
next	;

1.45.1.1.3.1
date	97.09.09.14.09.43;	author daveb;	state Exp;
branches;
next	;

1.45.2.1
date	97.09.10.19.25.41;	author brucem;	state Exp;
branches;
next	;

1.45.3.1
date	97.09.11.20.55.50;	author daveb;	state Exp;
branches;
next	;

1.46.1.1
date	99.04.01.17.57.21;	author daveb;	state Exp;
branches;
next	;


desc
@Augmented lambda calculus, with information on static gc objects
@


1.46
log
@[Bug #30090]
Remove references to MLWorks.IO
@
text
@(* _auglambda.sml the functor *)
(*
$Log: _auglambda.sml,v $
 * Revision 1.45  1996/12/02  15:41:41  matthew
 * Adding change for local functions
 *
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
 * Revision 1.43  1996/08/06  12:11:33  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
 * Revision 1.42  1996/08/01  12:08:29  jont
 * [Bug #1503]
 * Add field to FUNINFO to say if arg actually saved
 *
 * Revision 1.41  1996/04/30  16:45:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.40  1995/08/11  17:04:17  daveb
 * Added types for different lengths of words, ints and reals.
 *
Revision 1.39  1995/07/25  12:07:32  jont
Add WORD SCon

Revision 1.38  1995/07/19  13:10:39  jont
Modify count_gc_objects in light of Ident.CHAR which isn't static gc

Revision 1.37  1995/02/28  12:28:00  matthew
Abstracting debug_info type
Various tidying up

Revision 1.36  1995/01/13  17:18:08  matthew
Renaming debugger_env to runtime_env
Removed warning_issued parameter to everything

Revision 1.35  1994/10/10  10:11:20  matthew
Adding module annotations to lambda syntax.
Lambdatypes changes

Revision 1.34  1994/09/22  09:39:51  matthew
Abstraction of debug information in lambdatypes

Revision 1.33  1994/08/26  14:41:42  matthew
Extensions for argument lists

Revision 1.32  1994/07/19  14:52:59  matthew
Functions and applications take a list of parameters

Revision 1.31  1994/06/22  14:32:10  jont
Update debugger information production

Revision 1.30  1994/02/28  07:00:48  nosa
Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
Type function spills for Modules Debugger.

Revision 1.29  1994/02/25  14:49:52  daveb
Made generation of debug info for setup functions obey flag.

Revision 1.28  1993/09/06  09:02:32  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger;
change also to Debugger_Types.INFO.

Revision 1.27  1993/07/29  16:26:10  nosa
Local and Closure variable inspection in the debugger;
Changed Tags and LETs.

Revision 1.26  1993/03/10  17:02:43  matthew
Signature revisions

Revision 1.25  1993/03/04  13:14:06  matthew
Option & Info changes
removed options param from count_gc_objects

Revision 1.24  1993/03/02  17:48:38  matthew
Rationalised use of Mapping structure

Revision 1.23  1993/03/01  14:19:48  matthew
Added MLVALUE lambda exp

Revision 1.22  1993/02/04  14:23:22  matthew
Simplified parameter signature

Revision 1.21  1992/11/10  13:41:19  matthew
Changed Error structure to Info

Revision 1.20  1992/10/26  18:15:46  daveb
Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.

Revision 1.19  1992/09/10  10:10:34  richard
Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.

Revision 1.18  1992/09/09  09:59:31  clive
Added a flag to inhibit warning for debugger unable to generate recipe

Revision 1.17  1992/09/01  17:37:45  jont
Removed eta abstraction of exception handlers. This should allow them
to be abstracted.

Revision 1.16  1992/08/26  13:40:30  jont
Removed some redundant structures and sharing

Revision 1.15  1992/08/24  16:13:15  clive
Added details about leafness to the debug information

Revision 1.14  1992/08/07  15:21:06  clive
Added type annotation for handler expressions

Revision 1.13  1992/08/04  14:43:43  davidt
Took out redundant structure arguments. Added stuff to support optimisation of
BECOMES and UPDATE.

Revision 1.12  1992/07/22  09:05:10  clive
Changed type_of_setup

Revision 1.11  1992/07/21  14:21:23  clive
Gather type information

Revision 1.10  1992/07/16  17:00:00  clive
Changed sharing constraint - _debugger_types has datatypes and not types in the structure now

Revision 1.9  1992/07/14  10:14:19  clive
Added the debug information recording for the setup function

Revision 1.8  1992/07/07  14:40:06  clive
Generation of function call point debug information

Revision 1.7  1992/07/02  13:23:10  davida
Added LET constructor and new slot to APP.

Revision 1.6  1992/06/29  09:31:55  clive
Added type annotation information at applications

Revision 1.5  1992/06/25  19:19:23  jont
Stopped count counting strings referenced by load_var etc

Revision 1.4  1992/06/23  10:04:39  clive
Added an annotation slot to HANDLE

Revision 1.3  1992/06/18  10:27:58  jont
Fixed comparison of types problem by using a case statement

Revision 1.2  1992/06/11  11:01:21  clive
Added types to the fnexp of the lambda tree for the debugger to use

Revision 1.1  1992/05/05  13:25:57  jont
Initial revision

Copyright (c) 1992 Harlequin Ltd.
*)

require "../utils/crash";
require "../lambda/lambdatypes";
require "../main/pervasives";
require "../debugger/debugger_utilities";
require "auglambda";

functor AugLambda(
  structure Crash : CRASH
  structure LambdaTypes : LAMBDATYPES
  structure Pervasives : PERVASIVES
  structure DebuggerUtilities : DEBUGGER_UTILITIES

  sharing DebuggerUtilities.Options = DebuggerUtilities.Debugger_Types.Options
  sharing type LambdaTypes.Type = DebuggerUtilities.Debugger_Types.Type
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
    ) : AUGLAMBDA =
struct
  structure LambdaTypes = LambdaTypes
  structure Ident = LambdaTypes.Ident
  structure Debugger_Types = DebuggerUtilities.Debugger_Types
  structure Options = Debugger_Types.Options

  (* We define a new datatype, isomorphic to LambdaTypes.LambdaExp, but annotated *)
  (* with size information -- this is the number of ML objects required by the expression *)
  (* ie. the number of items that will be required in a closure *)

  datatype Tag =
    VCC_TAG of string * int           (* value carrying constructor *)
  | IMM_TAG of string * int           (* constant constructor *)
  | SCON_TAG of Ident.SCon * int option   (* simple int, real, string ... *)
					(* The int option gives the size of a numeric type *)
  | EXP_TAG of sized_AugLambdaExp
  (* more complex tag, for dynamic switching *)

  and AugLambdaExp =
    VAR of LambdaTypes.LVar             (* variable lookup *)
  | FN of ((LambdaTypes.LVar list * LambdaTypes.LVar list) * {size:int, lexp:AugLambdaExp} * string * LambdaTypes.FunInfo)
    (* function definition *)
  | LET of ((LambdaTypes.LVar * LambdaTypes.VarInfo ref option * sized_AugLambdaExp) * sized_AugLambdaExp)
  | LETREC of
    ((LambdaTypes.LVar * LambdaTypes.VarInfo ref option) list *
     sized_AugLambdaExp list *
     sized_AugLambdaExp)
  | APP of (sized_AugLambdaExp *
	    (sized_AugLambdaExp list * sized_AugLambdaExp list) *
	    Debugger_Types.Backend_Annotation)
    (* function application *)
  | SCON of LambdaTypes.Ident.SCon * int option 
					(* int, real, string as strings *)
					(* The int option gives the size of a numeric type *)
  | MLVALUE of MLWorks.Internal.Value.ml_value (* immediate constants *)
  | INT of int                          (* int as int (for tags) *)
  | SWITCH of                           (* like a case statement *)
    (sized_AugLambdaExp *
     {num_vccs: int, num_imms: int} option *
     (Tag * sized_AugLambdaExp) list *
     sized_AugLambdaExp option)
  (* The second argument contains enough information about the type being
     matched for the code generator to choose an appropriate representation.
     The LVar is bound to the argument of a value carrying constructor.
  *)
  | STRUCT of sized_AugLambdaExp list
    (* structure definition *)
  | SELECT of {index : int, size : int} * sized_AugLambdaExp
    (* field selector *)
  | RAISE of sized_AugLambdaExp 
    (* Exceptions --- throw ... *)
  | HANDLE of (sized_AugLambdaExp * sized_AugLambdaExp)
    (*            ... and catch *)
  | BUILTIN of LambdaTypes.Primitive * LambdaTypes.Type
		      (* built-in functions -- These functions are
		       primitive to the abstract
		       machine. *)
  withtype sized_AugLambdaExp = {size:int, lexp:AugLambdaExp}


  fun count_gc_objects (options,
                        exp,generate_debug_info,mapping,setup_function) =
    let
      fun count_gc_objects' (LambdaTypes.VAR lv,_,mapping,_) = 
        ({size=0, lexp=VAR lv} : sized_AugLambdaExp ,mapping)
        | count_gc_objects'(LambdaTypes.LET((lv,info,lb), le),ty,mapping,name) =
	  let
	    val (lb' as {size,lexp},mapping') = count_gc_objects' (lb,ty,mapping,name)
	    val (le' as {size=size',lexp},mapping'') = count_gc_objects' (le,ty,mapping',name)
	  in
	    ({size=size+size', lexp=LET((lv,info,lb'),le')},mapping'')
	  end

        | count_gc_objects' (LambdaTypes.APP(LambdaTypes.BUILTIN prim, ([le],[]),annotation),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (le,ty,mapping,name)
	    val size = case prim of
	      Pervasives.LOAD_STRING => 0
	    | Pervasives.LOAD_VAR => 0
	    | Pervasives.LOAD_EXN => 0
	    | Pervasives.LOAD_STRUCT => 0
	    | Pervasives.LOAD_FUNCT => 0
	    | _ => size
          in
	    ({size=size, lexp=APP({size=0, lexp=BUILTIN(prim,
                         case annotation of
                          NONE => LambdaTypes.null_type_annotation
                        | SOME(annotation) => !annotation)},
                         ([le],[]),Debugger_Types.null_backend_annotation)},
	     mapping')
          end

        | count_gc_objects' (LambdaTypes.APP(le, ([le'],[]),ty'),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (le,ty,mapping,name)
            val (le' as {size=size', ...},mapping'') = 
              count_gc_objects' (le',ty,mapping',name)
            val annotation = 
              if generate_debug_info
                then 
                  (* Add in the recipe for this call *)
                  let
                    val this_ty =
                      case ty' of
                        NONE => LambdaTypes.null_type_annotation
                      | SOME ty' => !ty'
                  in
                    DebuggerUtilities.generate_recipe options (ty,this_ty,name)
                  end
              else Debugger_Types.null_backend_annotation
          in
            ({size=size+size', lexp=APP(le, ([le'],[]),annotation)},mapping'')
          end

        (* This should be combined with the above case *)
        | count_gc_objects' (LambdaTypes.APP(le,(lel,fpel),ty'),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (le,ty,mapping,name)

            fun countlist el =
              foldr
              (fn (form,(x,forms,mapping)) => 
               let
                 val (le as {size=size,lexp=lexp},mapping') = 
                   count_gc_objects'(form,ty,mapping,name)
               in
                 (x+size,le::forms,mapping')
               end)
              (0,[],mapping')
              el

            val (size',lel',mapping'') = countlist lel
            val (size'',fpel',mapping'') = countlist fpel
            val annotation = 
              (* Add in the recipe for this call *)
              if generate_debug_info
                then
                  let
                    val this_ty = 
                      case ty' of
                        NONE => LambdaTypes.null_type_annotation
                      | SOME(ty') => !ty'
                  in
                    DebuggerUtilities.generate_recipe options (ty,this_ty,name)
                  end
              else (Debugger_Types.null_backend_annotation)
          in
            ({size=size+size'+size'', lexp=APP(le,(lel',fpel'),annotation)},mapping'')
          end
        | count_gc_objects' (LambdaTypes.FN((lvl,fpvl), lexp, status, name,ty,funinfo),_,
                             debug_info,_) =
          let
            val (le as {size=size, ...},debug_info) = 
              count_gc_objects' (lexp,ty,debug_info,name)
            val debug_info =
              if DebuggerUtilities.is_nulltype ty orelse not generate_debug_info
                then debug_info
              else
                (* Add in the debug information for this call *)
                Debugger_Types.add_debug_info
                (debug_info,
                 name,
                 Debugger_Types.FUNINFO {ty = DebuggerUtilities.slim_down_a_type ty,
                                         is_leaf = false,
					 has_saved_arg = false,
                                         annotations = [],
                                         runtime_env = Debugger_Types.empty_runtime_env, 
                                         is_exn = false})
            (* If its a local function then there is no GC object for it *)
            val newsize = if LambdaTypes.isLocalFn funinfo then size else size+1
          in
            ({size=newsize, lexp=FN((lvl,fpvl), le, name,funinfo)},debug_info)
          end
        | count_gc_objects'(LambdaTypes.LETREC(lv_list, le_list, lexp),ty,mapping,name) =
          let
            val (le_list,mapping') =
              foldr
              (fn (form,(forms,mapping)) => 
               let
                 val (form',mapping') = 
                   count_gc_objects' (case form of 
                                        LambdaTypes.FN _ => form
                                      | _ => 
                                          Crash.impossible "Bad letrec form",
                                          ty,mapping,name)
               in
                 (form'::forms,mapping')
               end)
              ([],mapping)
              le_list
            val (lexp as {size=size, ...},mapping'') = count_gc_objects' (lexp,ty,mapping',name)
          in
            ({size=
              foldl
              (fn ({size=size, ...},x) => x+size)
              size
              le_list,
              lexp=LETREC(lv_list, le_list, lexp)},mapping'')
          end
        | count_gc_objects'(LambdaTypes.SCON (scon, opt), _,mapping,_) =
          ({size=case scon of
                   Ident.INT _ => 0
                 | Ident.CHAR _ => 0
                 | Ident.WORD _ => 0
                 | Ident.REAL _ => 1
                 | Ident.STRING _ => 1,
	   lexp=SCON (scon, opt)},mapping)
        | count_gc_objects'(LambdaTypes.MLVALUE value,_,mapping,_) =
          ({size= 1, lexp=MLVALUE value},mapping)
        | count_gc_objects'(LambdaTypes.INT i,_,mapping,_) = 
          ({size=0, lexp=INT i},mapping)
        | count_gc_objects'(LambdaTypes.SWITCH(le, info, tag_le_list, le_opt),
			    ty,mapping,name) =
          let
            fun transform_tag((tag, le),mapping) =
              let
                val (le,mapping') =
		  count_gc_objects' (le,ty,mapping,name)
                val (tag,mapping''') = case tag of
                  LambdaTypes.EXP_TAG lexp =>
                    let
                      val (lexp as {size=size, ...},mapping'') = 
                        count_gc_objects' (lexp,ty,mapping',name)
                    in
                      if size <> 0 then
                        Crash.impossible"EXP_TAG contains static gc"
                      else
                        (EXP_TAG lexp,mapping'')
                    end
                | LambdaTypes.IMM_TAG i => (IMM_TAG i,mapping')
                | LambdaTypes.VCC_TAG i => (VCC_TAG i,mapping')
                | LambdaTypes.SCON_TAG scon => (SCON_TAG scon,mapping')
              in
                ((tag, le),mapping''')
              end

            fun transform_opt (NONE,mapping) = 
              ((0, NONE),mapping)
              | transform_opt(SOME le,mapping) =
                let
                  val (le as {size=size, ...},mapping') = 
                    count_gc_objects' (le,ty,mapping,name)
                in
                  ((size, SOME le),mapping')
                end

            val (tag_le_list,mapping') =
              foldr(fn (form,(forms,mapping)) => 
                            let
                              val (a,mapping') = 
				transform_tag (form,mapping)
                            in
                              (a::forms,mapping')
                              end)
              ([],mapping)
              tag_le_list

            val ((size1, le_opt),mapping'') =
	      transform_opt (le_opt,mapping')

            val (le as {size=size, ...},mapping''') = 
              count_gc_objects' (le,ty,mapping'',name)

            val sizes =
              foldl
              (fn ((tag, {size=size, ...}),x) =>
               x + size +
               (case tag of
                  SCON_TAG(Ident.REAL _, _) => 1
                | SCON_TAG(Ident.STRING _, _) => 1
		| SCON_TAG(Ident.INT _, _) => 0
		| SCON_TAG(Ident.CHAR _, _) => 0
		| SCON_TAG(Ident.WORD _, _) => 0
                | _ => 0))
              (size1+size)
              tag_le_list
          in
            ({size=sizes, lexp=SWITCH(le, info, tag_le_list, le_opt)},
	     mapping''')
          end
        | count_gc_objects'(LambdaTypes.STRUCT (le_list,_),ty,mapping,name) =
          let
            val (size,le_list,mapping') = 
             foldr
             (fn (form,(x,forms,mapping)) => 
              let
                val (le as {size=size,lexp=lexp},mapping') = 
                  count_gc_objects'(form,ty,mapping,name)
              in
                (x+size,le::forms,mapping')
              end)
             (0,[],mapping)
             le_list
          in
            ({size=size, lexp=STRUCT le_list},mapping')
          end
        | count_gc_objects'(LambdaTypes.SELECT({index,size=lsize,...}, le),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (le,ty,mapping,name)
            val info = {index=index,size=lsize}
          in
            ({size=size, lexp=SELECT(info, le)},mapping')
          end
        | count_gc_objects'(LambdaTypes.RAISE (le),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (le,ty,mapping,name)
          in
            ({size=size, lexp=RAISE (le)},mapping')
          end
        | count_gc_objects'(LambdaTypes.HANDLE(le, le',annotation),ty,mapping,name) =
          let
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping,name)
            val function = le'
            val (le' as {size=size', ...},mapping'') =
              count_gc_objects'(case function of
                                  LambdaTypes.FN (a,b,status,c,_,info) => 
                                    LambdaTypes.FN(a,b,status,c,DebuggerUtilities.handler_type,info)
				| x => x,
                                    ty,mapping',
                                    name)
          in
            ({size=size+size', lexp=HANDLE(le, le')},mapping'')
          end
        | count_gc_objects'(LambdaTypes.BUILTIN prim,ty,mapping,_) =
          ({size=0, lexp=BUILTIN(prim,ty)},mapping)

    in
      count_gc_objects' (exp,DebuggerUtilities.setup_function_type,
                         if generate_debug_info then
                           Debugger_Types.add_debug_info
                           (mapping,
                            setup_function,
                            Debugger_Types.FUNINFO {ty = DebuggerUtilities.setup_function_type,
                                                    is_leaf = false,
						    has_saved_arg = false,
                                                    annotations = [],
                                                    runtime_env = Debugger_Types.empty_runtime_env, 
                                                    is_exn = false})
                         else mapping,
                         setup_function)
    end

end
@


1.46.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.46  1998/02/05  16:25:57  jont
 * [Bug #30090]
 * Remove references to MLWorks.IO
 *
@


1.45
log
@Adding change for local functions
@
text
@d4 3
a180 7

  val do_debug = false

  fun debug f =
    if do_debug
      then MLWorks.IO.output(MLWorks.IO.std_err,"  # " ^ f () ^ "\n")
    else ()
@


1.45.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.45  1996/12/02  15:41:41  matthew
 * Adding change for local functions
 *
@


1.45.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.45  1996/12/02  15:41:41  matthew
 * Adding change for local functions
 *
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 3
 * Revision 1.45  1996/12/02  15:41:41  matthew
 * Adding change for local functions
 *
@


1.45.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.45.1.1  1997/05/12  10:35:07  hope
 * branched from 1.45
 *
@


1.45.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.45.1.1  1997/05/12  10:35:07  hope
 * branched from 1.45
 *
@


1.45.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.45.1.1  1997/05/12  10:35:07  hope
 * branched from 1.45
 *
@


1.45.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.45.1.1.1.1  1997/07/28  18:20:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.44
log
@Removing redundant LambdaSub
@
text
@d4 3
a156 1
require "../utils/lists";
a163 1
  structure Lists : LISTS
a177 1
  structure Option = MLWorks.Option
d179 1
a179 1
  val do_debug = true
d186 4
d193 1
a193 1
  | SCON_TAG of Ident.SCon * int Option.option   (* simple int, real, string ... *)
d200 1
a200 1
  | FN of (LambdaTypes.LVar list * sized_AugLambdaExp * string * LambdaTypes.FunInfo)
d202 1
a202 1
  | LET of ((LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.option * sized_AugLambdaExp) * sized_AugLambdaExp)
d204 1
a204 1
    ((LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.option) list *
d208 1
a208 1
	    sized_AugLambdaExp list *
d211 1
a211 1
  | SCON of LambdaTypes.Ident.SCon * int Option.option 
d218 1
a218 1
     {num_vccs: int, num_imms: int} Option.option *
d220 1
a220 1
     sized_AugLambdaExp Option.option)
d243 1
a243 1
      fun count_gc_objects'(LambdaTypes.VAR lv,_,mapping,_) = 
d253 1
a253 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, [le],annotation),ty,mapping,name) =
d267 3
a269 3
                          Option.NONE => LambdaTypes.null_type_annotation
                        | Option.SOME(annotation) => !annotation)},
                         [le],Debugger_Types.null_backend_annotation)},
d273 1
a273 1
        | count_gc_objects'(LambdaTypes.APP(le, [le'],ty'),ty,mapping,name) =
d286 2
a287 2
                        Option.NONE => LambdaTypes.null_type_annotation
                      | Option.SOME ty' => !ty'
d293 1
a293 1
            ({size=size+size', lexp=APP(le, [le'],annotation)},mapping'')
d297 1
a297 1
        | count_gc_objects'(LambdaTypes.APP(le,lel,ty'),ty,mapping,name) =
a300 11
              
            val (size',lel',mapping'') = 
             Lists.reducer
             (fn (form,(x,forms,mapping)) => 
              let
                val (le as {size=size,lexp=lexp},mapping') = 
                  count_gc_objects'(form,ty,mapping,name)
              in
                (x+size,le::forms,mapping')
              end)
             (lel,(0,[],mapping'))
d302 14
d323 2
a324 2
                        Option.NONE => LambdaTypes.null_type_annotation
                      | Option.SOME(ty') => !ty'
d330 1
a330 1
            ({size=size+size', lexp=APP(le,lel',annotation)},mapping'')
d332 2
a333 2
        | count_gc_objects'(LambdaTypes.FN(lvl, lexp, name,ty,instances),_,
                            debug_info,_) =
d351 2
d354 1
a354 1
            ({size=size+1, lexp=FN(lvl, le, name,instances)},debug_info)
d359 1
a359 1
              Lists.reducer
d371 2
a372 1
              (le_list,([],mapping))
d376 4
a379 3
              Lists.reducel
              (fn (x, {size=size, ...}) => x+size)
              (size, le_list),
d419 3
a421 3
            fun transform_opt (Option.NONE,mapping) = 
              ((0, Option.NONE),mapping)
              | transform_opt(Option.SOME le,mapping) =
d426 1
a426 1
                  ((size, Option.SOME le),mapping')
d430 1
a430 1
              Lists.reducer(fn (form,(forms,mapping)) => 
d437 2
a438 1
              (tag_le_list,([],mapping))
d447 2
a448 2
              Lists.reducel
              (fn (x, (tag, {size=size, ...})) =>
d457 2
a458 1
              (size1+size, tag_le_list)
d466 1
a466 1
             Lists.reducer
d474 2
a475 1
             (le_list,(0,[],mapping))
d500 2
a501 2
                                  LambdaTypes.FN (a,b,c,_,instances) => 
                                    LambdaTypes.FN(a,b,c,DebuggerUtilities.handler_type,instances)
@


1.44.6.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.44.5.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.44.5.1.1.1
log
@branched from 1.44.5.1
@
text
@a3 3
 * Revision 1.44.5.1  1996/12/17  17:48:38  hope
 * branched from 1.44
 *
@


1.44.4.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.44.3.1.1.1
log
@branched from 1.44.3.1
@
text
@a3 3
 * Revision 1.44.3.1  1996/11/14  12:50:36  hope
 * branched from 1.44
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/10/04  13:01:55  matthew
 * Removing redundant LambdaSub
 *
@


1.43
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml (essentially
just passing options rather than print_options).
@
text
@d4 5
d156 1
a156 1
require "../lambda/lambdasub";
d164 1
a164 1
  structure LambdaSub : LAMBDASUB
d169 2
a170 2
  sharing type LambdaSub.LT.Type = DebuggerUtilities.Debugger_Types.Type
  sharing type LambdaSub.LT.Primitive = Pervasives.pervasive
d173 1
a173 1
  structure LambdaTypes = LambdaSub.LT
d357 1
a357 2
                                          Crash.impossible "Bad letrec form"
                                          (* LambdaSub.eta_abstract (x,"",ref(LambdaTypes.null_type_annotation))*),
@


1.43.1.1
log
@branched from 1.43
@
text
@a3 5
 * Revision 1.43  1996/08/06  12:11:33  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.42
log
@[Bug #1503]
Add field to FUNINFO to say if arg actually saved
@
text
@d4 4
d163 1
d171 1
d231 2
a232 1
  fun count_gc_objects (exp,generate_debug_info,mapping,setup_function) =
d280 1
a280 1
                    DebuggerUtilities.generate_recipe (ty,this_ty,name)
d314 1
a314 1
                    DebuggerUtilities.generate_recipe (ty,this_ty,name)
@


1.41
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d328 1
d494 1
@


1.40
log
@Added types for different lengths of words, ints and reals.
@
text
@d4 3
d166 1
a166 1
      then output(MLWorks.IO.std_err,"  # " ^ f () ^ "\n")
@


1.39
log
@Add WORD SCon
@
text
@d4 3
d157 1
a157 1
  structure Option = LambdaTypes.Option
d169 2
a170 1
  | SCON_TAG of Ident.SCon   (* simple int, real, string ... *)
d178 1
a178 1
  | LET of ((LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.opt * sized_AugLambdaExp) * sized_AugLambdaExp)
d180 1
a180 1
    ((LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.opt) list *
d187 1
a187 1
  | SCON of LambdaTypes.Ident.SCon   
d189 1
d194 1
a194 1
     {num_vccs: int, num_imms: int} Option.opt *
d196 1
a196 1
     sized_AugLambdaExp Option.opt)
d242 2
a243 2
                          Option.ABSENT => LambdaTypes.null_type_annotation
                        | Option.PRESENT(annotation) => !annotation)},
d261 2
a262 2
                        Option.ABSENT => LambdaTypes.null_type_annotation
                      | Option.PRESENT ty' => !ty'
d295 2
a296 2
                        Option.ABSENT => LambdaTypes.null_type_annotation
                      | Option.PRESENT(ty') => !ty'
d350 1
a350 1
        | count_gc_objects'(LambdaTypes.SCON scon,_,mapping,_) =
d352 6
a357 5
            Ident.INT _ => 0
          | Ident.CHAR _ => 0
          | Ident.WORD _ => 0
          | Ident.REAL _ => 1
          | Ident.STRING _ => 1, lexp=SCON scon},mapping)
d387 3
a389 3
            fun transform_opt (Option.ABSENT,mapping) = 
              ((0, Option.ABSENT),mapping)
              | transform_opt(Option.PRESENT le,mapping) =
d394 1
a394 1
                  ((size, Option.PRESENT le),mapping')
d418 5
a422 5
                  SCON_TAG(Ident.REAL _) => 1
                | SCON_TAG(Ident.STRING _) => 1
		| SCON_TAG(Ident.INT _) => 0
		| SCON_TAG(Ident.CHAR _) => 0
		| SCON_TAG(Ident.WORD _) => 0
@


1.38
log
@Modify count_gc_objects in light of Ident.CHAR which isn't static gc
@
text
@d4 3
d349 1
d416 1
@


1.37
log
@Abstracting debug_info type
Various tidying up
@
text
@d4 4
d345 3
a347 1
          | _ => 1, lexp=SCON scon},mapping)
d410 2
@


1.36
log
@Renaming debugger_env to runtime_env
Removed warning_issued parameter to everything
@
text
@d4 4
d44 1
a44 1
Options & Info changes
a129 1
require "../typechecker/types";
a137 1
  structure Types : TYPES
d140 1
a140 4
  sharing LambdaSub.LT.Ident = Types.Datatypes.Ident
  sharing DebuggerUtilities.Debugger_Types.NewMap = Types.Datatypes.NewMap

  sharing type LambdaSub.LT.Type = Types.Datatypes.Type = DebuggerUtilities.Debugger_Types.Type
d145 1
a145 2
  structure Datatypes = Types.Datatypes
  structure Ident = Datatypes.Ident
a146 1
  structure NewMap = Datatypes.NewMap
d165 1
a165 1
  | FN of (LambdaTypes.LVar list * sized_AugLambdaExp * string * LambdaTypes.FunInfo Option.opt)
d204 1
a204 1
  fun count_gc_objects (exp,generate_debug_information,mapping,setup_function) =
d243 1
a243 1
              if generate_debug_information
d245 1
d250 1
a250 1
                      | Option.PRESENT(ty') => !ty'
d259 1
d277 2
a278 1
              if generate_debug_information
d293 1
a293 1
                            mapping,_) =
d295 15
a309 21
            val (le as {size=size, ...},mapping') = 
              count_gc_objects' (lexp,ty,mapping,name)
            val mapping'' =
	      case ty of
		Datatypes.NULLTYPE => mapping'
	      | _ =>
                  if generate_debug_information then
                    let
                      val Debugger_Types.INFO i = mapping'
                    in
                      Debugger_Types.INFO
                      (NewMap.define(i,name,
                                     Debugger_Types.FUNINFO
                                     {ty = DebuggerUtilities.slim_down_a_type ty,
                                      is_leaf = false,
                                      annotations = [],
                                      runtime_env = Debugger_Types.empty_runtime_env, 
                                      is_exn = false}))
                    end
                  else
                    mapping'
d311 1
a311 1
            ({size=size+1, lexp=FN(lvl, le, name,instances)},mapping'')
d320 6
a325 5
                   count_gc_objects'(case form of 
                                       (fcn as LambdaTypes.FN _) => fcn
                                     | x => LambdaSub.eta_abstract(x,"",
                                                     ref(LambdaTypes.null_type_annotation)),
                                         ty,mapping,name)
a441 2
            val type_of_a_handler =
              Datatypes.FUNTYPE(Datatypes.CONSTYPE([],Types.exn_tyname),Datatypes.NULLTYPE)
d447 1
a447 1
                                    LambdaTypes.FN(a,b,c,type_of_a_handler,instances)
d457 7
a463 14
      val type_of_setup = 
        Datatypes.FUNTYPE
        (Types.empty_rectype,Types.empty_rectype)

      val (a,b) = 
        let
          val Debugger_Types.INFO i = mapping
        in
          count_gc_objects' (exp,type_of_setup,
			     if generate_debug_information then
                             Debugger_Types.INFO (NewMap.define
                                                  (i,setup_function,
                                                   Debugger_Types.FUNINFO
                                                   {ty = type_of_setup,
d467 3
a469 7
                                                    is_exn = false}))
			     else
			       mapping,
                             setup_function)
        end
    in
      (a,b)
@


1.35
log
@Adding module annotations to lambda syntax.
Lambdatypes changes
@
text
@d4 4
d127 1
a127 1
require "../debugger/debugger_type_utilities";
d136 1
a136 1
  structure Debugger_Type_Utilities : DEBUGGER_TYPE_UTILITIES
d139 1
a139 1
  sharing Debugger_Type_Utilities.Debugger_Types.NewMap = Types.Datatypes.NewMap
d141 1
a141 1
  sharing type LambdaSub.LT.Type = Types.Datatypes.Type = Debugger_Type_Utilities.Debugger_Types.Type
d148 1
a148 2
  structure Debugger_Types = Debugger_Type_Utilities.Debugger_Types
  structure Debugger_Type_Utilities = Debugger_Type_Utilities
d152 7
d207 1
a207 1
  fun count_gc_objects (exp,generate_debug_information,mapping,setup_function,inhibit_warnings) =
d209 3
a211 17

      fun count_gc_objects'(LambdaTypes.VAR lv,_,mapping,_,warning_issued) = 
               ({size=0, lexp=VAR lv} : sized_AugLambdaExp ,mapping,warning_issued)
(* shouldn't need this case *)
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN([lv],le, _,_,_), [le'],annotation),ty,mapping,name,warning_issued) =
          let
            val (le as {size=size, lexp=_},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
            val (le' as {size=size', lexp=_},mapping'',warning_issued) = 
              count_gc_objects' (le',ty,mapping',name,warning_issued)
	    val _ = output(std_out, "*** Optimised code contains APP-FN, on v"^(LambdaTypes.printLVar lv)^"\n")
          in
	    ({size=size+size', lexp=LET((lv,Option.ABSENT,le'),le)},mapping'',warning_issued)
          end
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lvl, le, _,_,_), lel,annotation),ty,mapping,name,warning_issued) =
          Crash.impossible "Difficult APP-FN"
        | count_gc_objects'(LambdaTypes.LET((lv,info,lb), le),ty,mapping,name,warning_issued) =
d213 2
a214 2
	    val (lb' as {size,...},mapping',warning_issued) = count_gc_objects' (lb,ty,mapping,name,warning_issued)
	    val (le' as {size=size',...},mapping'',warning_issued) = count_gc_objects' (le,ty,mapping',name,warning_issued)
d216 1
a216 1
	    ({size=size+size', lexp=LET((lv,info,lb'),le')},mapping'',warning_issued)
d219 1
a219 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, [le],annotation),ty,mapping,name,warning_issued) =
d221 2
a222 2
            val (le as {size=size, ...},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
d236 1
a236 1
	     mapping',warning_issued)
d239 1
a239 1
        | count_gc_objects'(LambdaTypes.APP(le, [le'],ty'),ty,mapping,name,warning_issued) =
d241 5
a245 5
            val (le as {size=size, ...},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
            val (le' as {size=size', ...},mapping'',warning_issued) = 
              count_gc_objects' (le',ty,mapping',name,warning_issued)
            val (annotation,warning) = 
d247 10
a256 5
                then Debugger_Type_Utilities.generate_recipe (ty,
                         case ty' of
                          Option.ABSENT => LambdaTypes.null_type_annotation
                        | Option.PRESENT(ty') => !ty',name,warning_issued)
              else (Debugger_Type_Utilities.Debugger_Types.null_backend_annotation,warning_issued)
d258 1
a258 1
            ({size=size+size', lexp=APP(le, [le'],annotation)},mapping'',warning_issued)
d261 1
a261 1
        | count_gc_objects'(LambdaTypes.APP(le,lel,ty'),ty,mapping,name,warning_issued) =
d263 2
a264 2
            val (le as {size=size, ...},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
d266 1
a266 1
            val (size',lel',mapping'',warning_issued) = 
d268 1
a268 1
             (fn (form,(x,forms,mapping,warning_issued)) => 
d270 2
a271 2
                val (le as {size=size,lexp=lexp},mapping',warning_issued) = 
                  count_gc_objects'(form,ty,mapping,name,warning_issued)
d273 1
a273 1
                (x+size,le::forms,mapping',warning_issued)
d275 1
a275 1
             (lel,(0,[],mapping',warning_issued))
d277 1
a277 1
            val (annotation,warning) = 
d279 10
a288 5
                then Debugger_Type_Utilities.generate_recipe (ty,
                         case ty' of
                          Option.ABSENT => LambdaTypes.null_type_annotation
                        | Option.PRESENT(ty') => !ty',name,warning_issued)
              else (Debugger_Type_Utilities.Debugger_Types.null_backend_annotation,warning_issued)
d290 1
a290 1
            ({size=size+size', lexp=APP(le,lel',annotation)},mapping'',warning_issued)
d293 1
a293 1
                            mapping,_,warning_issued) =
d295 2
a296 2
            val (le as {size=size, ...},mapping',_) = 
              count_gc_objects' (lexp,ty,mapping,name,inhibit_warnings)
d306 7
a312 2
                      (NewMap.define(i,name,((Debugger_Type_Utilities.slim_down_a_type ty,
                                      false,[]),Debugger_Types.empty_debugger_env, false)))
d317 1
a317 1
            ({size=size+1, lexp=FN(lvl, le, name,instances)},mapping'',warning_issued)
d319 1
a319 1
        | count_gc_objects'(LambdaTypes.LETREC(lv_list, le_list, lexp),ty,mapping,name,warning_issued) =
d321 1
a321 1
            val (le_list,mapping',warning_issued) =
d323 1
a323 1
              (fn (form,(forms,mapping,warning_issued)) => 
d325 1
a325 1
                 val (form',mapping',warning_issued) = 
d330 1
a330 1
                                         ty,mapping,name,warning_issued)
d332 1
a332 1
                 (form'::forms,mapping',warning_issued)
d334 2
a335 2
              (le_list,([],mapping,warning_issued))
            val (lexp as {size=size, ...},mapping'',warning_issued) = count_gc_objects' (lexp,ty,mapping',name,warning_issued)
d341 1
a341 1
              lexp=LETREC(lv_list, le_list, lexp)},mapping'',warning_issued)
d343 1
a343 1
        | count_gc_objects'(LambdaTypes.SCON scon,_,mapping,_,warning_issued) =
d346 5
a350 5
          | _ => 1, lexp=SCON scon},mapping,warning_issued)
        | count_gc_objects'(LambdaTypes.MLVALUE value,_,mapping,_,warning_issued) =
          ({size= 1, lexp=MLVALUE value},mapping,warning_issued)
        | count_gc_objects'(LambdaTypes.INT i,_,mapping,_,warning_issued) = 
          ({size=0, lexp=INT i},mapping,warning_issued)
d352 1
a352 1
			    ty,mapping,name,warning_issued) =
d354 1
a354 1
            fun transform_tag((tag, le),mapping,warning_issued) =
d356 3
a358 3
                val (le,mapping',warning_issued) =
		  count_gc_objects' (le,ty,mapping,name,warning_issued)
                val (tag,mapping''',warning_issued) = case tag of
d361 2
a362 2
                      val (lexp as {size=size, ...},mapping'',warning_issued) = 
                        count_gc_objects' (lexp,ty,mapping',name,warning_issued)
d367 1
a367 1
                        (EXP_TAG lexp,mapping'',warning_issued)
d369 3
a371 3
                | LambdaTypes.IMM_TAG i => (IMM_TAG i,mapping',warning_issued)
                | LambdaTypes.VCC_TAG i => (VCC_TAG i,mapping',warning_issued)
                | LambdaTypes.SCON_TAG scon => (SCON_TAG scon,mapping',warning_issued)
d373 1
a373 1
                ((tag, le),mapping''',warning_issued)
d376 3
a378 3
            fun transform_opt (Option.ABSENT,mapping,warning_issued) = 
              ((0, Option.ABSENT),mapping,warning_issued)
              | transform_opt(Option.PRESENT le,mapping,warning_issued) =
d380 2
a381 2
                  val (le as {size=size, ...},mapping',warning_issued) = 
                    count_gc_objects' (le,ty,mapping,name,warning_issued)
d383 1
a383 1
                  ((size, Option.PRESENT le),mapping',warning_issued)
d386 2
a387 2
            val (tag_le_list,mapping',warning_issued) =
              Lists.reducer(fn (form,(forms,mapping,warning_issued)) => 
d389 2
a390 2
                              val (a,mapping',warning_issued) = 
				transform_tag (form,mapping,warning_issued)
d392 1
a392 1
                              (a::forms,mapping',warning_issued)
d394 1
a394 1
              (tag_le_list,([],mapping,warning_issued))
d396 2
a397 2
            val ((size1, le_opt),mapping'',warning_issued) =
	      transform_opt (le_opt,mapping',warning_issued)
d399 2
a400 2
            val (le as {size=size, ...},mapping''',warning_issued) = 
              count_gc_objects' (le,ty,mapping'',name,warning_issued)
d413 1
a413 2
	     mapping''',
	     warning_issued)
d415 1
a415 1
        | count_gc_objects'(LambdaTypes.STRUCT (le_list,_),ty,mapping,name,warning_issued) =
d417 1
a417 1
            val (size,le_list,mapping',warning_issued) = 
d419 1
a419 1
             (fn (form,(x,forms,mapping,warning_issued)) => 
d421 2
a422 2
                val (le as {size=size,lexp=lexp},mapping',warning_issued) = 
                  count_gc_objects'(form,ty,mapping,name,warning_issued)
d424 1
a424 1
                (x+size,le::forms,mapping',warning_issued)
d426 1
a426 1
             (le_list,(0,[],mapping,warning_issued))
d428 1
a428 1
            ({size=size, lexp=STRUCT le_list},mapping',warning_issued)
d430 1
a430 1
        | count_gc_objects'(LambdaTypes.SELECT({index,size=lsize,...}, le),ty,mapping,name,warning_issued) =
d432 2
a433 2
            val (le as {size=size, ...},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
d436 1
a436 1
            ({size=size, lexp=SELECT(info, le)},mapping',warning_issued)
d438 1
a438 1
        | count_gc_objects'(LambdaTypes.RAISE (le),ty,mapping,name,warning_issued) =
d440 2
a441 2
            val (le as {size=size, ...},mapping',warning_issued) = 
              count_gc_objects' (le,ty,mapping,name,warning_issued)
d443 1
a443 1
            ({size=size, lexp=RAISE (le)},mapping',warning_issued)
d445 1
a445 1
        | count_gc_objects'(LambdaTypes.HANDLE(le, le',annotation),ty,mapping,name,warning_issued) =
d449 1
a449 1
            val (le as {size=size, ...},mapping',warning_issued) = count_gc_objects' (le,ty,mapping,name,warning_issued)
d451 1
a451 6
(*
              case le' of
                LambdaTypes.FN _ => le' 
              | _ => LambdaSub.eta_abstract(le', annotation,Debugger_Types.exn_type)
*)
            val (le' as {size=size', ...},mapping'',warning_issued) =
d457 1
a457 1
                                    name,warning_issued)
d459 1
a459 1
            ({size=size+size', lexp=HANDLE(le, le')},mapping'',warning_issued)
d461 2
a462 2
        | count_gc_objects'(LambdaTypes.BUILTIN prim,ty,mapping,_,warning_issued) =
          ({size=0, lexp=BUILTIN(prim,ty)},mapping,warning_issued)
d468 1
a468 1
      val (a,b,_) = 
d474 8
a481 3
                             Debugger_Types.INFO (NewMap.define(i,setup_function,
                                                ((type_of_setup,false,[]),
                                                 Debugger_Types.empty_debugger_env, false)))
d484 1
a484 2
                             setup_function,
                             inhibit_warnings)
@


1.34
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d160 1
a160 3
  | LET of (LambdaTypes.LVar * LambdaTypes.VarInfo ref Option.opt * 
	    sized_AugLambdaExp *
	    sized_AugLambdaExp)
d211 1
a211 1
	    ({size=size+size', lexp=LET(lv,Option.ABSENT,le',le)},mapping'',warning_issued)
d215 1
a215 1
        | count_gc_objects'(LambdaTypes.LET(lv, info,lb, le),ty,mapping,name,warning_issued) =
d220 1
a220 1
	    ({size=size+size', lexp=LET(lv,info,lb',le')},mapping'',warning_issued)
d405 1
a405 1
        | count_gc_objects'(LambdaTypes.STRUCT le_list,ty,mapping,name,warning_issued) =
d420 1
a420 1
        | count_gc_objects'(LambdaTypes.SELECT(f, le),ty,mapping,name,warning_issued) =
d424 1
d426 1
a426 1
            ({size=size, lexp=SELECT(f, le)},mapping',warning_issued)
@


1.33
log
@Extensions for argument lists
@
text
@d4 3
d144 1
d155 1
a155 2
  | FN of (LambdaTypes.LVar list * sized_AugLambdaExp * string  
           * ((int * LambdaTypes.Type * LambdaTypes.Instance) ref list * (int,int) LambdaTypes.Option.option ref LambdaTypes.Option.opt) LambdaTypes.Option.opt)
d157 1
a157 5
  | LET of ((LambdaTypes.LVar,(LambdaTypes.LVar * (string * (LambdaTypes.Type 
                                      * LambdaTypes.Instance ref LambdaTypes.Option.opt
                   * (LambdaTypes.Tyfun ref * (int,int) LambdaTypes.Option.option ref) list) ref 
              * (int,int) LambdaTypes.Option.option ref LambdaTypes.Option.opt) LambdaTypes.Option.opt)ref) LambdaTypes.Option.option * 
            (* non-rec def's *)
d160 3
a162 6
  | LETREC of                           (* allows recursive definitions *)
    ((LambdaTypes.LVar,(LambdaTypes.LVar * (string * (LambdaTypes.Type 
                                     * LambdaTypes.Instance ref LambdaTypes.Option.opt
                   * (LambdaTypes.Tyfun ref * (int,int) LambdaTypes.Option.option ref) list) ref 
                                            * (int,int) LambdaTypes.Option.option ref LambdaTypes.Option.opt) LambdaTypes.Option.opt)ref) 
     LambdaTypes.Option.option list * sized_AugLambdaExp list *
d174 1
a174 1
     {lv: LambdaTypes.LVar, num_vccs: int, num_imms: int} LambdaTypes.Option.opt *
d176 1
a176 1
     sized_AugLambdaExp LambdaTypes.Option.opt)
d210 1
a210 1
	    ({size=size+size', lexp=LET(LambdaTypes.Option.SOME1(lv),le',le)},mapping'',warning_issued)
d214 1
a214 1
        | count_gc_objects'(LambdaTypes.LET(lv, lb, le),ty,mapping,name,warning_issued) =
d219 1
a219 1
	    ({size=size+size', lexp=LET(lv,lb',le')},mapping'',warning_issued)
d236 2
a237 2
                          LambdaTypes.Option.ABSENT => LambdaTypes.null_type_annotation
                        | LambdaTypes.Option.PRESENT(annotation) => !annotation)},
d252 2
a253 2
                          LambdaTypes.Option.ABSENT => LambdaTypes.null_type_annotation
                        | LambdaTypes.Option.PRESENT(ty') => !ty',name,warning_issued)
d279 2
a280 2
                          LambdaTypes.Option.ABSENT => LambdaTypes.null_type_annotation
                        | LambdaTypes.Option.PRESENT(ty') => !ty',name,warning_issued)
d364 3
a366 3
            fun transform_opt (LambdaTypes.Option.ABSENT,mapping,warning_issued) = 
              ((0, LambdaTypes.Option.ABSENT),mapping,warning_issued)
              | transform_opt(LambdaTypes.Option.PRESENT le,mapping,warning_issued) =
d371 1
a371 1
                  ((size, LambdaTypes.Option.PRESENT le),mapping',warning_issued)
@


1.32
log
@Functions and applications take a list of parameters
@
text
@d4 3
d245 1
d262 27
a288 2
        | count_gc_objects'(LambdaTypes.APP(_, lel,annotation),ty,mapping,name,warning_issued) =
          Crash.impossible "Arglist in count_gc_objects"
@


1.31
log
@Update debugger information production
@
text
@d4 3
d148 1
a148 1
  | FN of (LambdaTypes.LVar * sized_AugLambdaExp * string  
d166 1
a166 1
	    sized_AugLambdaExp *
d203 1
a203 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lv, le, _,_,_), le',annotation),ty,mapping,name,warning_issued) =
d213 2
d223 1
a223 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le,annotation),ty,mapping,name,warning_issued) =
d239 1
a239 1
				  le,Debugger_Types.null_backend_annotation)},
d242 1
a242 1
        | count_gc_objects'(LambdaTypes.APP(le, le',ty'),ty,mapping,name,warning_issued) =
d256 1
a256 1
            ({size=size+size', lexp=APP(le, le',annotation)},mapping'',warning_issued)
d258 3
a260 1
        | count_gc_objects'(LambdaTypes.FN(lv, lexp, name,ty,instances),_,
d280 1
a280 1
            ({size=size+1, lexp=FN(lv, le, name,instances)},mapping'',warning_issued)
@


1.30
log
@Deleted compiler option debug_polyvariables in Debugger_Types.INFO;
Type function spills for Modules Debugger.
@
text
@d4 4
d268 1
a268 1
                                      false,[]),Debugger_Types.empty_debugger_env)))
d437 1
a437 1
                                                 Debugger_Types.empty_debugger_env)))
@


1.29
log
@Made generation of debug info for setup functions obey flag.
@
text
@d4 3
d145 2
a146 1
                                      * LambdaTypes.Instance ref LambdaTypes.Option.opt) ref 
d153 2
a154 1
                                     * LambdaTypes.Instance ref LambdaTypes.Option.opt) ref 
d260 1
a260 1
                      val Debugger_Types.INFO (i,b) = mapping'
d264 1
a264 1
                                      false,[]),Debugger_Types.empty_debugger_env)),b)
d427 1
a427 1
          val Debugger_Types.INFO (i,b) = mapping
d431 3
a433 5
			       Debugger_Types.INFO
				 (NewMap.define
				    (i, setup_function,
                                     ((type_of_setup,false,[]),
                                       Debugger_Types.empty_debugger_env)),b)
@


1.28
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger;
change also to Debugger_Types.INFO.
@
text
@d4 5
d425 8
a432 3
                             Debugger_Types.INFO (NewMap.define(i,setup_function,
                                                ((type_of_setup,false,[]),
                                                 Debugger_Types.empty_debugger_env)),b),
@


1.27
log
@Local and Closure variable inspection in the debugger;
Changed Tags and LETs.
@
text
@d4 4
d133 2
a134 1
  | FN of (LambdaTypes.LVar * sized_AugLambdaExp * string)
d136 3
a138 1
  | LET of ((LambdaTypes.LVar,(LambdaTypes.LVar * (string * LambdaTypes.Type ref) LambdaTypes.Option.opt)ref) LambdaTypes.Option.option * 
d143 3
a145 1
    ((LambdaTypes.LVar,(LambdaTypes.LVar * (string * LambdaTypes.Type ref) LambdaTypes.Option.opt)ref) 
d186 1
a186 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lv, le, _,_), le',annotation),ty,mapping,name,warning_issued) =
d239 1
a239 1
        | count_gc_objects'(LambdaTypes.FN(lv, lexp, name,ty),_,
d250 1
a250 1
                      val Debugger_Types.INFO i = mapping'
d254 1
a254 1
                                      false,[]),Debugger_Types.empty_debugger_env)))
d259 1
a259 1
            ({size=size+1, lexp=FN(lv, le, name)},mapping'',warning_issued)
d400 2
a401 2
                                  LambdaTypes.FN (a,b,c,_) => 
                                    LambdaTypes.FN(a,b,c,type_of_a_handler)
d417 1
a417 1
          val Debugger_Types.INFO i = mapping
d422 1
a422 1
                                                 Debugger_Types.empty_debugger_env))),
@


1.27.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.27  1993/07/29  16:26:10  nosa
Local and Closure variable inspection in the debugger;
Changed Tags and LETs.

@


1.26
log
@Signature revisions
@
text
@d4 3
d121 2
a122 2
    VCC_TAG of int           (* value carrying constructor *)
  | IMM_TAG of int           (* constant constructor *)
d128 1
a128 1
    VAR of LambdaTypes.LVar                       (* variable lookup *)
d131 2
a132 1
  | LET of (LambdaTypes.LVar *                    (* non-rec def's *)
d135 3
a137 2
  | LETREC of                         (* allows recursive definitions *)
    (LambdaTypes.LVar list * sized_AugLambdaExp list *
d143 2
a144 1
  | SCON of Ident.SCon                (* int, real, string as strings *)
d146 2
a147 2
  | INT of int                        (* int as int (for tags) *)
  | SWITCH of                         (* like a case statement *)
d149 1
a149 1
     {lv: LambdaTypes.LVar, num_vccs: int, num_imms: int} LambdaTypes.Opt *
d151 1
a151 1
     sized_AugLambdaExp LambdaTypes.Opt)
a155 1

d160 1
a160 1
  | RAISE of sized_AugLambdaExp
d164 1
a164 1
  | BUILTIN of LambdaTypes.Primitive * Datatypes.Type
d185 1
a185 1
	    ({size=size+size', lexp=LET(lv,le',le)},mapping'',warning_issued)
d207 4
a210 1
	    ({size=size, lexp=APP({size=0, lexp=BUILTIN(prim,annotation)},
d222 4
a225 1
                then Debugger_Type_Utilities.generate_recipe (ty,ty',name,warning_issued)
d230 2
a231 1
        | count_gc_objects'(LambdaTypes.FN(lv, lexp, name,ty),_,mapping,_,warning_issued) =
d244 2
a245 1
                      (NewMap.define(i,name,(Debugger_Type_Utilities.slim_down_a_type ty,false,[])))
d261 2
a262 1
                                     | x => LambdaSub.eta_abstract(x,"",LambdaTypes.null_type_annotation),
d309 3
a311 3
            fun transform_opt (LambdaTypes.ABSENT,mapping,warning_issued) = 
              ((0, LambdaTypes.ABSENT),mapping,warning_issued)
              | transform_opt(LambdaTypes.PRESENT le,mapping,warning_issued) =
d316 1
a316 1
                  ((size, LambdaTypes.PRESENT le),mapping',warning_issued)
d371 1
a371 1
        | count_gc_objects'(LambdaTypes.RAISE le,ty,mapping,name,warning_issued) =
d376 1
a376 1
            ({size=size, lexp=RAISE le},mapping',warning_issued)
d391 2
a392 1
                                  LambdaTypes.FN (a,b,c,_) => LambdaTypes.FN(a,b,c,type_of_a_handler)
d411 3
a413 1
                             Debugger_Types.INFO (NewMap.define(i,setup_function,(type_of_setup,false,[]))),
@


1.25
log
@Options & Info changes
removed options param from count_gc_objects
@
text
@d4 4
d103 4
a106 1
  sharing LambdaSub.LT.Datatypes = Types.Datatypes = Debugger_Type_Utilities.Debugger_Types.Datatypes
d159 1
a159 1
  | BUILTIN of LambdaTypes.Primitive * LambdaTypes.Datatypes.Type
d225 1
a225 1
		LambdaTypes.Datatypes.NULLTYPE => mapping'
d388 1
a388 1
        LambdaTypes.Datatypes.FUNTYPE
@


1.24
log
@Rationalised use of Mapping structure
@
text
@d4 3
a108 1
  structure Info = Debugger_Type_Utilities.Debugger_Types.Info
d159 1
a159 1
  fun count_gc_objects options (exp,generate_debug_information,mapping,setup_function,inhibit_warnings) =
d207 1
a207 3
                then Debugger_Type_Utilities.generate_recipe options (ty,ty',
                                                                      name,
                                                                      warning_issued)
@


1.23
log
@Added MLVALUE lambda exp
@
text
@d4 3
d382 1
a382 2
        (LambdaTypes.Datatypes.RECTYPE LambdaTypes.Datatypes.Mapping.empty_map,
         LambdaTypes.Datatypes.RECTYPE LambdaTypes.Datatypes.Mapping.empty_map)
d384 9
a392 9
        val (a,b,_) = 
          let
            val Debugger_Types.INFO i = mapping
          in
            count_gc_objects' (exp,type_of_setup,
                               Debugger_Types.INFO (NewMap.define(i,setup_function,(type_of_setup,false,[]))),
                               setup_function,
                               inhibit_warnings)
          end
@


1.22
log
@Simplified parameter signature
@
text
@d4 3
d127 1
d256 2
@


1.21
log
@Changed Error structure to Info
@
text
@d4 3
d100 1
a100 1
  structure Info = Debugger_Type_Utilities.Info
@


1.20
log
@Changed type of SWITCH; pointer defaults are no longer used, but information
about value-carrying and constant constructors is added.
@
text
@d4 4
d97 1
d147 1
a147 1
  fun count_gc_objects (exp,generate_debug_information,mapping,setup_function,inhibit_warnings) =
d195 3
a197 3
                then Debugger_Type_Utilities.generate_recipe(ty,ty',
                                                             name,
                                                             warning_issued)
@


1.19
log
@Created a type `information' which wraps up the debugger information
needed in so many parts of the compiler.
@
text
@d4 4
d93 1
d95 2
a96 1
    CON_TAG of int           (* basic datatype tagging type *)
d100 1
d111 3
a113 1
  | APP of (sized_AugLambdaExp * sized_AugLambdaExp * Debugger_Types.Backend_Annotation)
d119 1
a120 1
     sized_AugLambdaExp LambdaTypes.Opt *
d122 5
a126 2
    (* First default for constructor not in list, second for not a constructor
     so we can efficiently check for non-nullary constructors *)
d246 2
a247 1
        | count_gc_objects'(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt),ty,mapping,name,warning_issued) =
d251 2
a252 1
                val (le,mapping',warning_issued) = count_gc_objects' (le,ty,mapping,name,warning_issued)
d264 2
a265 1
                | LambdaTypes.CON_TAG i => (CON_TAG i,mapping',warning_issued)
d270 1
d280 1
d284 2
a285 1
                              val (a,mapping',warning_issued) = transform_tag (form,mapping,warning_issued)
d290 7
a296 4
            val ((size1, le_opt1),mapping'',warning_issued) = transform_opt (le1_opt,mapping',warning_issued)
            val ((size2, le_opt2),mapping''',warning_issued) = transform_opt (le2_opt,mapping'',warning_issued)
            val (le as {size=size, ...},mapping'''',warning_issued) = 
              count_gc_objects' (le,ty,mapping''',name,warning_issued)
d305 1
a305 1
              (size1+size2+size, tag_le_list)
d307 3
a309 1
            ({size=sizes, lexp=SWITCH(le, tag_le_list, le_opt1, le_opt2)},mapping'''',warning_issued)
@


1.18
log
@Added a flag to inhibit warning for debugger unable to generate recipe
@
text
@d4 3
d193 9
a201 4
                  if generate_debug_information 
                    then
                      NewMap.define(mapping',name,(Debugger_Type_Utilities.slim_down_a_type ty,false,[]))
                  else mapping'
d346 8
a353 4
          count_gc_objects' (exp,type_of_setup,
                             NewMap.define(mapping,setup_function,(type_of_setup,false,[])),
                             setup_function,
                             inhibit_warnings)
@


1.17
log
@Removed eta abstraction of exception handlers. This should allow them
to be abstracted.
@
text
@d4 4
d127 1
a127 1
  fun count_gc_objects (exp,generate_debug_information,mapping,setup_function) =
d184 2
a185 1
            val (le as {size=size, ...},mapping',_) = count_gc_objects' (lexp,ty,mapping,name,false)
d341 1
a341 1
                             false)
@


1.16
log
@Removed some redundant structures and sharing
@
text
@d4 3
d309 2
a310 1
            val function = 
d314 1
@


1.15
log
@Added details about leafness to the debug information
@
text
@d4 3
d74 2
a75 1
  structure Ident = LambdaTypes.Ident
d78 1
a78 2
  structure Datatypes = Types.Datatypes

d184 1
a184 1
                      Debugger_Types.Map.define(mapping',name,(Debugger_Type_Utilities.slim_down_a_type ty,false,[]))
d329 1
a329 1
                             Debugger_Types.Map.define(mapping,setup_function,(type_of_setup,false,[])),
@


1.14
log
@Added type annotation for handler expressions
@
text
@d4 3
d181 1
a181 1
                      Debugger_Types.Map.define(mapping',name,(Debugger_Type_Utilities.slim_down_a_type ty,[]))
d326 1
a326 1
                             Debugger_Types.Map.define(mapping,setup_function,(type_of_setup,[])),
@


1.13
log
@Took out redundant structure arguments. Added stuff to support optimisation of
BECOMES and UPDATE.
@
text
@d4 4
d71 1
d297 2
d300 4
d305 3
a307 3
              count_gc_objects'(case le'
				  of LambdaTypes.FN _ => le'
				| _ => LambdaSub.eta_abstract(le', annotation,Debugger_Types.exn_type),
@


1.12
log
@Changed type_of_setup
@
text
@d4 3
a44 1
require "../lambda/lambdatypes";
a45 1
require "../basics/ident";
a53 1
  structure LambdaTypes : LAMBDATYPES
a55 1
  structure Ident: IDENT
d59 3
a61 5
  sharing LambdaSub.LT = LambdaTypes
  sharing LambdaTypes.Datatypes = Types.Datatypes = Debugger_Type_Utilities.Debugger_Types.Datatypes
  sharing Ident = LambdaTypes.Ident
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
) : AUGLAMBDA =
d63 2
a64 2
  structure LambdaTypes = LambdaTypes
  structure Ident = Ident
d102 1
a102 1
  | BUILTIN of LambdaTypes.Primitive
d145 3
a147 1
            ({size=size, lexp=APP({size=0, lexp=BUILTIN prim}, le,Debugger_Types.null_backend_annotation)},mapping',warning_issued)
d274 1
a274 2
            ({size=size,
             lexp=STRUCT le_list},mapping',warning_issued)
d302 2
a303 2
        | count_gc_objects'(LambdaTypes.BUILTIN prim,_,mapping,_,warning_issued) =
          ({size=0, lexp=BUILTIN prim},mapping,warning_issued)
@


1.11
log
@Gather type information
@
text
@d4 3
d307 4
a310 2
      val type_of_setup = LambdaTypes.Datatypes.FUNTYPE(LambdaTypes.Datatypes.RECTYPE LambdaTypes.Datatypes.Mapping.empty_map,
                                                        LambdaTypes.Datatypes.RECTYPE LambdaTypes.Datatypes.Mapping.empty_map)
@


1.10
log
@Changed sharing constraint - _debugger_types has datatypes and not types in the structure now
@
text
@d4 3
d112 2
a113 2
      fun count_gc_objects'(LambdaTypes.VAR lv,_,mapping) = 
               ({size=0, lexp=VAR lv} : sized_AugLambdaExp ,mapping)
d115 1
a115 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lv, le, name,_), le',annotation),ty,mapping) =
d117 4
a120 2
            val (le as {size=size, lexp=_},mapping') = count_gc_objects' (le,ty,mapping)
            val (le' as {size=size', lexp=_},mapping'') = count_gc_objects' (le',ty,mapping')
d123 1
a123 1
	    ({size=size+size', lexp=LET(lv,le',le)},mapping'')
d125 1
a125 1
        | count_gc_objects'(LambdaTypes.LET(lv, lb, le),ty,mapping) =
d127 2
a128 2
	    val (lb' as {size,...},mapping') = count_gc_objects' (lb,ty,mapping)
	    val (le' as {size=size',...},mapping'') = count_gc_objects' (le,ty,mapping')
d130 1
a130 1
	    ({size=size+size', lexp=LET(lv,lb',le')},mapping'')
d133 1
a133 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le,annotation),ty,mapping) =
d135 2
a136 1
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
d145 1
a145 1
            ({size=size, lexp=APP({size=0, lexp=BUILTIN prim}, le,Debugger_Types.null_backend_annotation)},mapping')
d147 1
a147 1
        | count_gc_objects'(LambdaTypes.APP(le, le',ty'),ty,mapping) =
d149 10
a158 2
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
            val (le' as {size=size', ...},mapping'') = count_gc_objects' (le',ty,mapping')
d160 1
a160 1
            ({size=size+size', lexp=APP(le, le',Debugger_Type_Utilities.generate_recipe(ty,ty'))},mapping'')
d162 1
a162 1
        | count_gc_objects'(LambdaTypes.FN(lv, lexp, name,ty),_,mapping) =
d164 1
a164 1
            val (le as {size=size, ...},mapping') = count_gc_objects' (lexp,ty,mapping)
d174 1
a174 1
            ({size=size+1, lexp=FN(lv, le, name)},mapping'')
d176 1
a176 1
        | count_gc_objects'(LambdaTypes.LETREC(lv_list, le_list, lexp),ty,mapping) =
d178 1
a178 1
            val (le_list,mapping') =
d180 1
a180 1
              (fn (form,(forms,mapping)) => 
d182 1
a182 1
                 val (form',mapping') = 
d185 2
a186 2
                                     | x => LambdaSub.eta_abstract(x,""),
                                         ty,mapping)
d188 1
a188 1
                 (form'::forms,mapping')
d190 2
a191 2
              (le_list,([],mapping))
            val (lexp as {size=size, ...},mapping'') = count_gc_objects' (lexp,ty,mapping')
d197 1
a197 1
              lexp=LETREC(lv_list, le_list, lexp)},mapping'')
d199 1
a199 1
        | count_gc_objects'(LambdaTypes.SCON scon,_,mapping) =
d202 4
a205 3
          | _ => 1, lexp=SCON scon},mapping)
        | count_gc_objects'(LambdaTypes.INT i,_,mapping) = ({size=0, lexp=INT i},mapping)
        | count_gc_objects'(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt),ty,mapping) =
d207 1
a207 1
            fun transform_tag((tag, le),mapping) =
d209 2
a210 2
                val (le,mapping') = count_gc_objects' (le,ty,mapping)
                val (tag,mapping''') = case tag of
d213 2
a214 1
                      val (lexp as {size=size, ...},mapping'') = count_gc_objects' (lexp,ty,mapping')
d219 1
a219 1
                        (EXP_TAG lexp,mapping'')
d221 2
a222 2
                | LambdaTypes.CON_TAG i => (CON_TAG i,mapping')
                | LambdaTypes.SCON_TAG scon => (SCON_TAG scon,mapping')
d224 1
a224 1
                ((tag, le),mapping''')
d226 3
a228 2
            fun transform_opt (LambdaTypes.ABSENT,mapping) = ((0, LambdaTypes.ABSENT),mapping)
              | transform_opt(LambdaTypes.PRESENT le,mapping) =
d230 2
a231 1
                  val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
d233 1
a233 1
                  ((size, LambdaTypes.PRESENT le),mapping')
d235 2
a236 2
            val (tag_le_list,mapping') =
              Lists.reducer(fn (form,(forms,mapping)) => 
d238 1
a238 1
                              val (a,mapping') = transform_tag (form,mapping)
d240 1
a240 1
                              (a::forms,mapping')
d242 5
a246 4
              (tag_le_list,([],mapping))
            val ((size1, le_opt1),mapping'') = transform_opt (le1_opt,mapping')
            val ((size2, le_opt2),mapping''') = transform_opt (le2_opt,mapping'')
            val (le as {size=size, ...},mapping'''') = count_gc_objects' (le,ty,mapping''')
d257 1
a257 1
            ({size=sizes, lexp=SWITCH(le, tag_le_list, le_opt1, le_opt2)},mapping'''')
d259 1
a259 1
        | count_gc_objects'(LambdaTypes.STRUCT le_list,ty,mapping) =
d261 1
a261 1
            val (size,le_list,mapping') = 
d263 1
a263 1
             (fn (form,(x,forms,mapping)) => 
d265 2
a266 1
                val (le as {size=size,lexp=lexp},mapping') = count_gc_objects'(form,ty,mapping)
d268 1
a268 1
                (x+size,le::forms,mapping')
d270 1
a270 1
             (le_list,(0,[],mapping))
d273 1
a273 1
             lexp=STRUCT le_list},mapping')
d275 1
a275 1
        | count_gc_objects'(LambdaTypes.SELECT(f, le),ty,mapping) =
d277 2
a278 1
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
d280 1
a280 1
            ({size=size, lexp=SELECT(f, le)},mapping')
d282 1
a282 1
        | count_gc_objects'(LambdaTypes.RAISE le,ty,mapping) =
d284 2
a285 1
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
d287 1
a287 1
            ({size=size, lexp=RAISE le},mapping')
d289 1
a289 1
        | count_gc_objects'(LambdaTypes.HANDLE(le, le',annotation),ty,mapping) =
d291 2
a292 2
            val (le as {size=size, ...},mapping') = count_gc_objects' (le,ty,mapping)
            val (le' as {size=size', ...},mapping'') =
d295 3
a297 1
				| _ => LambdaSub.eta_abstract(le', annotation),ty,mapping')
d299 1
a299 1
            ({size=size+size', lexp=HANDLE(le, le')},mapping'')
d301 2
a302 2
        | count_gc_objects'(LambdaTypes.BUILTIN prim,_,mapping) =
          ({size=0, lexp=BUILTIN prim},mapping)
d306 6
d313 1
a313 2
      (count_gc_objects' (exp,type_of_setup,
                          Debugger_Types.Map.define(mapping,setup_function,(type_of_setup,[]))))
@


1.9
log
@Added the debug information recording for the setup function
@
text
@d4 3
d55 1
a55 1
  sharing LambdaTypes.Datatypes = Types.Datatypes = Debugger_Type_Utilities.Debugger_Types.Types.Datatypes
@


1.8
log
@Generation of function call point debug information
@
text
@d4 3
d103 1
a103 1
  fun count_gc_objects (exp,generate_debug_information,mapping) =
d276 3
a278 1
          
d280 2
a281 1
      (count_gc_objects' (exp,LambdaTypes.Datatypes.NULLTYPE,mapping))
@


1.7
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d35 1
a35 1
require "../debugger/debugger_types";
d46 1
a46 1
  structure Debugger_Types : DEBUGGER_TYPES
d49 1
a49 1
  sharing LambdaTypes.Datatypes = Types.Datatypes
d56 2
a57 1
  structure Debugger_Types = Debugger_Types
d100 1
a100 1
  fun count_gc_objects (exp,generate_debug_information,print_generated_debug_information) =
a101 1
      val accumulated_debug_info = ref([])
d103 2
a104 2
      fun count_gc_objects'(LambdaTypes.VAR lv) = 
               {size=0, lexp=VAR lv} : sized_AugLambdaExp 
d106 1
a106 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lv, le, name,_), le',annotation)) =
d108 2
a109 2
            val le as {size=size, lexp=_} = count_gc_objects' le
            val le' as {size=size', ...}= count_gc_objects' le'
d112 1
a112 2
	    {size=size+size', lexp=LET(lv,le',le)}
(*            {size=size+size', lexp=APP({size=size, lexp=FN(lv, le, name)}, le',Debugger_Types.null_backend_annotation)} *)
d114 1
a114 1
        | count_gc_objects'(LambdaTypes.LET(lv, lb, le)) =
d116 2
a117 2
	    val lb' as {size,...} = count_gc_objects' lb
	    val le' as {size=size',...} = count_gc_objects' le
d119 1
a119 1
	    {size=size+size', lexp=LET(lv,lb',le')}
d122 1
a122 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le,annotation)) =
d124 1
a124 1
            val le as {size=size, ...} = count_gc_objects' le
d133 1
a133 1
            {size=size, lexp=APP({size=0, lexp=BUILTIN prim}, le,Debugger_Types.null_backend_annotation)}
d135 1
a135 1
        | count_gc_objects'(LambdaTypes.APP(le, le',annotation)) =
d137 2
a138 2
            val le as {size=size, ...} = count_gc_objects' le
            val le' as {size=size', ...} = count_gc_objects' le'
d140 1
a140 1
            {size=size+size', lexp=APP(le, le',Debugger_Types.null_backend_annotation)}
d142 1
a142 1
        | count_gc_objects'(LambdaTypes.FN(lv, lexp, name,ty)) =
d144 2
a145 2
            val le as {size=size, ...} = count_gc_objects' lexp
            val _ = 
d147 1
a147 1
		LambdaTypes.Datatypes.NULLTYPE => ()
d149 4
a152 8
		  (if generate_debug_information then
		     accumulated_debug_info :=
		     (name,ty) :: !accumulated_debug_info
		   else ();
		     if print_generated_debug_information then
		       (output(std_out,name ^ "\n     ");
			output(std_out,Types.print_type ty ^ "\n"))
		     else ())
d154 1
a154 1
            {size=size+1, lexp=FN(lv, le, name)}
d156 1
a156 1
        | count_gc_objects'(LambdaTypes.LETREC(lv_list, le_list, lexp)) =
d158 14
a171 7
            val le_list =
              map
              (count_gc_objects' o
               (fn (fcn as LambdaTypes.FN _) => fcn
             | x => LambdaSub.eta_abstract(x,"")))
              le_list
            val lexp as {size=size, ...} = count_gc_objects' lexp
d173 5
a177 5
            {size=
             Lists.reducel
             (fn (x, {size=size, ...}) => x+size)
             (size, le_list),
             lexp=LETREC(lv_list, le_list, lexp)}
d179 6
a184 6
        | count_gc_objects'(LambdaTypes.SCON scon) =
          {size=case scon of
           Ident.INT _ => 0
         | _ => 1, lexp=SCON scon}
        | count_gc_objects'(LambdaTypes.INT i) = {size=0, lexp=INT i}
        | count_gc_objects'(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
d186 1
a186 1
            fun transform_tag(tag, le) =
d188 2
a189 2
                val le = count_gc_objects' le
                val tag = case tag of
d192 1
a192 1
                      val lexp as {size=size, ...} = count_gc_objects' lexp
d197 1
a197 1
                        EXP_TAG lexp
d199 2
a200 2
                | LambdaTypes.CON_TAG i => CON_TAG i
                | LambdaTypes.SCON_TAG scon => SCON_TAG scon
d202 1
a202 1
                (tag, le)
d204 2
a205 2
            fun transform_opt LambdaTypes.ABSENT = (0, LambdaTypes.ABSENT)
              | transform_opt(LambdaTypes.PRESENT le) =
d207 1
a207 1
                  val le as {size=size, ...} = count_gc_objects' le
d209 1
a209 1
                  (size, LambdaTypes.PRESENT le)
d211 20
a230 13
            val tag_le_list = map transform_tag tag_le_list
            val (size1, le_opt1) = transform_opt le1_opt
	val (size2, le_opt2) = transform_opt le2_opt
	val le as {size=size, ...} = count_gc_objects' le
	val sizes =
	  Lists.reducel
	  (fn (x, (tag, {size=size, ...})) =>
	   x + size +
	   (case tag of
	      SCON_TAG(Ident.REAL _) => 1
	    | SCON_TAG(Ident.STRING _) => 1
	    | _ => 0))
	  (size1+size2+size, tag_le_list)
d232 1
a232 1
            {size=sizes, lexp=SWITCH(le, tag_le_list, le_opt1, le_opt2)}
d234 1
a234 1
        | count_gc_objects'(LambdaTypes.STRUCT le_list) =
d236 9
a244 1
            val le_list = map count_gc_objects' le_list
d246 2
a247 5
            {size=
             Lists.reducel
             (fn (x, {size=size, ...}) => x+size)
             (0, le_list),
             lexp=STRUCT le_list}
d249 1
a249 1
        | count_gc_objects'(LambdaTypes.SELECT(f, le)) =
d251 1
a251 1
            val le as {size=size, ...} = count_gc_objects' le
d253 1
a253 1
            {size=size, lexp=SELECT(f, le)}
d255 1
a255 1
        | count_gc_objects'(LambdaTypes.RAISE le) =
d257 1
a257 1
            val le as {size=size, ...} = count_gc_objects' le
d259 1
a259 1
            {size=size, lexp=RAISE le}
d261 1
a261 1
        | count_gc_objects'(LambdaTypes.HANDLE(le, le',annotation)) =
d263 2
a264 2
            val le as {size=size, ...} = count_gc_objects' le
            val le' as {size=size', ...} =
d267 1
a267 1
				| _ => LambdaSub.eta_abstract(le', annotation))
d269 1
a269 1
            {size=size+size', lexp=HANDLE(le, le')}
d271 2
a272 2
        | count_gc_objects'(LambdaTypes.BUILTIN prim) =
          {size=0, lexp=BUILTIN prim}
d275 1
a275 1
      (count_gc_objects' exp,! accumulated_debug_info)
@


1.6
log
@Added type annotation information at applications
@
text
@d4 3
d58 1
a58 1
  | EXP_TAG of {size:int, lexp:AugLambdaExp}
d62 1
a62 1
  | FN of (LambdaTypes.LVar * {size:int, lexp:AugLambdaExp} * string)
d64 3
d68 3
a70 3
    (LambdaTypes.LVar list * {size:int, lexp:AugLambdaExp} list *
     {size:int, lexp:AugLambdaExp})
  | APP of ({size:int, lexp:AugLambdaExp} * {size:int, lexp:AugLambdaExp} * Debugger_Types.Backend_Annotation)
d75 4
a78 4
    ({size:int, lexp:AugLambdaExp} *
     (Tag * {size:int, lexp:AugLambdaExp}) list *
     {size:int, lexp:AugLambdaExp} LambdaTypes.Opt *
     {size:int, lexp:AugLambdaExp} LambdaTypes.Opt)
d81 1
a81 1
  | STRUCT of {size:int, lexp:AugLambdaExp} list
d83 1
a83 1
  | SELECT of {index : int, size : int} * {size:int, lexp:AugLambdaExp}
d85 1
a85 1
  | RAISE of {size:int, lexp:AugLambdaExp}
d87 1
a87 1
  | HANDLE of ({size:int, lexp:AugLambdaExp} * {size:int, lexp:AugLambdaExp})
d93 1
d95 1
d100 4
a103 2
      fun count_gc_objects'(LambdaTypes.VAR lv) = {size=0, lexp=VAR lv}
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.FN(lv, le, name,_), le')) =
d107 1
d109 2
a110 1
            {size=size+size', lexp=APP({size=size, lexp=FN(lv, le, name)}, le',Debugger_Types.null_backend_annotation)}
d112 9
a120 1
        | count_gc_objects'(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
d133 1
a133 1
        | count_gc_objects'(LambdaTypes.APP(le, le')) =
d248 3
a250 1
              count_gc_objects'(LambdaSub.eta_abstract(le', annotation))
@


1.5
log
@Stopped count counting strings referenced by load_var etc
@
text
@d4 3
d29 1
d40 2
d50 2
d64 1
a64 1
  | APP of ({size:int, lexp:AugLambdaExp} * {size:int, lexp:AugLambdaExp})
d98 1
a98 1
            {size=size+size', lexp=APP({size=size, lexp=FN(lv, le, name)}, le')}
d111 1
a111 1
            {size=size, lexp=APP({size=0, lexp=BUILTIN prim}, le)}
d118 1
a118 1
            {size=size+size', lexp=APP(le, le')}
@


1.4
log
@Added an annotation slot to HANDLE
@
text
@d4 3
d95 7
d103 1
a103 2
            {size= if prim = Pervasives.LOAD_STRING then 0 else size,
             lexp=APP({size=0, lexp=BUILTIN prim}, le)}
@


1.3
log
@Fixed comparison of types problem by using a case statement
@
text
@d4 3
d207 1
a207 1
        | count_gc_objects'(LambdaTypes.HANDLE(le, le')) =
d211 1
a211 1
              count_gc_objects'(LambdaSub.eta_abstract(le', "Handler in _mir_cg"))
@


1.2
log
@Added types to the fnexp of the lambda tree for the debugger to use
@
text
@d4 3
d104 11
a114 11
              if ty = LambdaTypes.Datatypes.NULLTYPE
                then ()
              else
                (if generate_debug_information
                   then accumulated_debug_info := (name,ty) :: ! accumulated_debug_info
                 else ();
                 if print_generated_debug_information
                   then
                     (output(std_out,name ^ "\n     ");
                      output(std_out,Types.print_type ty ^ "\n"))
                 else ())
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d16 1
d26 1
d28 1
d71 94
a164 78
  fun count_gc_objects(LambdaTypes.VAR lv) = {size=0, lexp=VAR lv}
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.FN(lv, le, name), le')) =
      let
	val le as {size=size, lexp=_} = count_gc_objects le
	val le' as {size=size', ...}= count_gc_objects le'
      in
	{size=size+size', lexp=APP({size=size, lexp=FN(lv, le, name)}, le')}
      end
    | count_gc_objects(LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
      let
	val le as {size=size, ...} = count_gc_objects le
      in
	{size= if prim = Pervasives.LOAD_STRING then 0 else size,
	 lexp=APP({size=0, lexp=BUILTIN prim}, le)}
      end
    | count_gc_objects(LambdaTypes.APP(le, le')) =
      let
	val le as {size=size, ...} = count_gc_objects le
	val le' as {size=size', ...} = count_gc_objects le'
      in
	{size=size+size', lexp=APP(le, le')}
      end
    | count_gc_objects(LambdaTypes.FN(lv, lexp, name)) =
      let
	val le as {size=size, ...} = count_gc_objects lexp
      in
	{size=size+1, lexp=FN(lv, le, name)}
      end
    | count_gc_objects(LambdaTypes.LETREC(lv_list, le_list, lexp)) =
      let
	val le_list =
	  map
	  (count_gc_objects o
	   (fn (fcn as LambdaTypes.FN _) => fcn
	   | x => LambdaSub.eta_abstract(x,"")))
	  le_list
	val lexp as {size=size, ...} = count_gc_objects lexp
      in
	{size=
	 Lists.reducel
	 (fn (x, {size=size, ...}) => x+size)
	 (size, le_list),
	 lexp=LETREC(lv_list, le_list, lexp)}
      end
    | count_gc_objects(LambdaTypes.SCON scon) =
      {size=case scon of
       Ident.INT _ => 0
     | _ => 1, lexp=SCON scon}
    | count_gc_objects(LambdaTypes.INT i) = {size=0, lexp=INT i}
    | count_gc_objects(LambdaTypes.SWITCH(le, tag_le_list, le1_opt, le2_opt)) =
      let
	fun transform_tag(tag, le) =
	  let
	    val le = count_gc_objects le
	    val tag = case tag of
	      LambdaTypes.EXP_TAG lexp =>
		let
		  val lexp as {size=size, ...} = count_gc_objects lexp
		in
		  if size <> 0 then
		    Crash.impossible"EXP_TAG contains static gc"
		  else
		    EXP_TAG lexp
		end
	    | LambdaTypes.CON_TAG i => CON_TAG i
	    | LambdaTypes.SCON_TAG scon => SCON_TAG scon
	  in
	    (tag, le)
	  end
	fun transform_opt LambdaTypes.ABSENT = (0, LambdaTypes.ABSENT)
	  | transform_opt(LambdaTypes.PRESENT le) =
	    let
	      val le as {size=size, ...} = count_gc_objects le
	    in
	      (size, LambdaTypes.PRESENT le)
	    end
	val tag_le_list = map transform_tag tag_le_list
	val (size1, le_opt1) = transform_opt le1_opt
d166 1
a166 1
	val le as {size=size, ...} = count_gc_objects le
d176 39
a214 35
      in
	{size=sizes, lexp=SWITCH(le, tag_le_list, le_opt1, le_opt2)}
      end
    | count_gc_objects(LambdaTypes.STRUCT le_list) =
      let
	val le_list = map count_gc_objects le_list
      in
	{size=
	 Lists.reducel
	 (fn (x, {size=size, ...}) => x+size)
	 (0, le_list),
	 lexp=STRUCT le_list}
      end
    | count_gc_objects(LambdaTypes.SELECT(f, le)) =
      let
	val le as {size=size, ...} = count_gc_objects le
      in
	{size=size, lexp=SELECT(f, le)}
      end
    | count_gc_objects(LambdaTypes.RAISE le) =
      let
	val le as {size=size, ...} = count_gc_objects le
      in
	{size=size, lexp=RAISE le}
      end
    | count_gc_objects(LambdaTypes.HANDLE(le, le')) =
      let
	val le as {size=size, ...} = count_gc_objects le
	val le' as {size=size', ...} =
	  count_gc_objects(LambdaSub.eta_abstract(le', "Handler in _mir_cg"))
      in
	{size=size+size', lexp=HANDLE(le, le')}
      end
    | count_gc_objects(LambdaTypes.BUILTIN prim) =
      {size=0, lexp=BUILTIN prim}
@
