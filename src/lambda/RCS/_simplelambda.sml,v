head	1.50;
access;
symbols
	MLW_daveb_inline_1_4_99:1.50.1
	MLWorks_21c0_1999_03_25:1.50
	MLWorks_20c1_1998_08_20:1.48
	MLWorks_20c0_1998_08_04:1.48
	MLWorks_20b2c2_1998_06_19:1.48
	MLWorks_20b2_Windows_1998_06_12:1.48
	MLWorks_20b1c1_1998_05_07:1.48
	MLWorks_20b0_1998_04_07:1.48
	MLWorks_20b0_1998_03_20:1.48
	MLWorks_20m2_1998_02_16:1.47
	MLWorks_20m1_1997_10_23:1.45
	MLWorks_11r1:1.40.1.3.1.1.1
	MLWorks_workspace_97:1.44.2
	MLWorks_dt_wizard:1.44.1
	MLWorks_11c0_1997_09_09:1.40.1.3.1.1
	MLWorks_10r3:1.40.1.3.3
	MLWorks_10r2_551:1.40.1.3.2
	MLWorks_11:1.40.1.3.1
	MLWorks_1_0_r2c2_1997_07_28:1.40.1.3
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.40.1.3
	MLWorks_1_0_r2c1_released_1997_05_23:1.40.1.3
	MLWorks_1_0_r2c1_1997_05_12:1.40.1
	MLWorks_BugFix_1997_04_24:1.40
	MLWorks_1_0_r2_Win32_1997_04_11:1.40
	MLWorks_1_0_r2_Unix_1997_04_04:1.40
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.34.3.1.1
	MLWorks_gui_1996_12_18:1.34.4
	MLWorks_1_0_Win32_1996_12_17:1.34.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.34.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.34.1.1
	MLWorks_1_0_Irix_1996_11_28:1.34.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.34.2
	MLWorks_1_0_Unix_1996_11_14:1.34.1
	MLWorks_Open_Beta2_1996_10_11:1.32.2
	MLWorks_License_dev:1.32.1
	MLWorks_1_open_beta_1996_09_13:1.31.1
	MLWorks_Open_Beta_1996_08_22:1.31
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.28;
locks; strict;
comment	@ * @;


1.50
date	98.11.26.12.11.48;	author mitchell;	state Exp;
branches
	1.50.1.1;
next	1.49;

1.49
date	98.11.26.10.50.38;	author mitchell;	state Exp;
branches;
next	1.48;

1.48
date	98.02.19.16.57.03;	author mitchell;	state Exp;
branches;
next	1.47;

1.47
date	98.01.30.09.37.58;	author johnh;	state Exp;
branches;
next	1.46;

1.46
date	97.11.13.11.17.36;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	97.09.18.15.55.20;	author brucem;	state Exp;
branches;
next	1.44;

1.44
date	97.08.01.17.37.05;	author jkbrook;	state Exp;
branches
	1.44.1.1
	1.44.2.1;
next	1.43;

1.43
date	97.07.03.15.33.38;	author jkbrook;	state Exp;
branches;
next	1.42;

1.42
date	97.05.21.10.55.22;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	97.05.09.11.57.05;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	97.02.12.14.24.18;	author matthew;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	97.01.24.15.35.30;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	97.01.24.13.27.31;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	97.01.21.16.17.07;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	97.01.06.16.38.41;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	97.01.06.10.06.23;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.11.06.11.02.32;	author matthew;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1
	1.34.4.1;
next	1.33;

1.33
date	96.10.09.19.57.52;	author io;	state Exp;
branches;
next	1.32;

1.32
date	96.10.04.13.23.24;	author matthew;	state Exp;
branches
	1.32.1.1
	1.32.2.1;
next	1.31;

1.31
date	96.07.25.14.51.04;	author jont;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	96.05.30.15.40.59;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.05.30.12.23.13;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	96.05.13.14.32.01;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	96.04.30.17.35.21;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	96.04.29.16.24.39;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	96.03.28.10.28.38;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.03.21.15.30.51;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.01.04.13.04.49;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.01.03.14.31.06;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.11.15.10.16.09;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.09.05.14.45.57;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	95.08.01.14.05.01;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.07.25.11.52.11;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.07.21.16.00.06;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.07.19.15.47.28;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.07.19.11.04.56;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.07.18.10.55.47;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.05.23.10.08.00;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	95.05.19.10.49.56;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.05.03.16.31.05;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	95.04.26.16.18.14;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.03.17.10.08.51;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.02.28.12.54.27;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.01.30.10.48.37;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.01.10.10.56.08;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	94.11.15.11.12.59;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	94.10.27.11.12.18;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.10.17.12.04.33;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	94.10.11.09.50.35;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	94.09.23.14.50.47;	author matthew;	state Exp;
branches;
next	;

1.31.1.1
date	96.09.13.11.16.54;	author hope;	state Exp;
branches;
next	;

1.32.1.1
date	96.10.07.16.06.42;	author hope;	state Exp;
branches;
next	;

1.32.2.1
date	96.10.17.11.24.58;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	96.11.14.12.49.54;	author hope;	state Exp;
branches
	1.34.1.1.1.1;
next	;

1.34.1.1.1.1
date	96.11.28.15.01.05;	author hope;	state Exp;
branches;
next	;

1.34.2.1
date	96.11.22.18.09.25;	author hope;	state Exp;
branches;
next	;

1.34.3.1
date	96.12.17.17.48.04;	author hope;	state Exp;
branches
	1.34.3.1.1.1;
next	;

1.34.3.1.1.1
date	97.02.24.11.37.53;	author hope;	state Exp;
branches;
next	;

1.34.4.1
date	96.12.18.09.42.05;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	97.05.12.10.34.33;	author hope;	state Exp;
branches;
next	1.40.1.2;

1.40.1.2
date	97.05.14.13.55.47;	author daveb;	state Exp;
branches;
next	1.40.1.3;

1.40.1.3
date	97.05.15.16.10.37;	author daveb;	state Exp;
branches
	1.40.1.3.1.1
	1.40.1.3.2.1
	1.40.1.3.3.1;
next	;

1.40.1.3.1.1
date	97.07.28.18.19.51;	author daveb;	state Exp;
branches
	1.40.1.3.1.1.1.1;
next	;

1.40.1.3.1.1.1.1
date	97.10.07.11.44.59;	author jkbrook;	state Exp;
branches;
next	;

1.40.1.3.2.1
date	97.09.08.17.13.25;	author daveb;	state Exp;
branches;
next	;

1.40.1.3.3.1
date	97.09.09.14.09.06;	author daveb;	state Exp;
branches;
next	;

1.44.1.1
date	97.09.10.19.24.36;	author brucem;	state Exp;
branches;
next	;

1.44.2.1
date	97.09.11.20.55.14;	author daveb;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	97.11.20.17.08.53;	author daveb;	state Exp;
branches;
next	;

1.50.1.1
date	99.04.01.17.57.03;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.50
log
@[Bug #190493]
Don't bother optimising & tracing code generated by the history mechanism
@
text
@(*
 * $Log: _simplelambda.sml,v $
 * Revision 1.49  1998/11/26  10:50:38  mitchell
 * [Bug #190491]
 * Fix constant switch optimisation bug for lists
 *
 * Revision 1.48  1998/02/19  16:57:03  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.47  1998/01/30  09:37:58  johnh
 * [Bug #30326]
 * Merge in Project Workspace changes.
 *
 * Revision 1.46  1997/11/13  11:17:36  jont
 * [Bug #30089]
 * Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
 *
 * Revision 1.45  1997/09/18  15:55:20  brucem
 * [Bug #30153]
 * Remove references to Old.
 * Revision 1.44.2.2  1997/11/20  17:08:53  daveb
 * [Bug #30326]
 *
 * Revision 1.44.2.1  1997/09/11  20:55:14  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.44  1997/08/01  17:37:05  jkbrook
 * [Bug #30184]
 * Fixing interaction of global CSE with functors in same compilation unit
 *
 * Revision 1.43  1997/07/03  15:33:38  jkbrook
 * [Bug #30186]
 * Added note about compiler option consistency with _mir_cg
 *
 * Revision 1.42  1997/05/21  10:55:22  matthew
 * Loop optimizations
 *
 * Revision 1.41  1997/05/09  11:57:05  matthew
 * Improving interaction between local functions and FP args
 *
 * Revision 1.40  1997/02/12  14:24:18  matthew
 * Improving treatment of array indexing
 *
 * Revision 1.39  1997/01/24  15:35:30  matthew
 * Slight improvement to previous change
 *
 * Revision 1.38  1997/01/24  13:27:31  matthew
 * Adding "replace mult by power of 2 by a shift" optimization.
 *
 * Revision 1.37  1997/01/21  16:17:07  matthew
 * Adding "multiplication by small constant" optimization
 *
 * Revision 1.36  1997/01/06  16:38:41  jont
 * [Bug #1633]
 * Add copyright message
 *
 * Revision 1.35  1997/01/06  10:06:23  matthew
 * Simplifications and rationalizations
 *
 * Revision 1.34  1996/11/06  11:02:32  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.33  1996/10/09  19:57:52  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.32  1996/10/04  13:23:24  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
 * Revision 1.31  1996/07/25  14:51:04  jont
 * Add mechanism to remove entry functions for functions of a single variable
 *
 * Revision 1.30  1996/05/30  15:40:59  matthew
 * globalize needs to record if it is in a switch statement and therefore should be
 * conservative about lifting switches
 *
 * Revision 1.29  1996/05/30  12:23:13  daveb
 * The Ord exception is no longer at top level.
 *
 * Revision 1.28  1996/05/13  14:32:01  jont
 * Fix problems with optimising manifest chars
 *
 * Revision 1.27  1996/04/30  17:35:21  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.26  1996/04/29  16:24:39  matthew
 * Integer changes
 *
 * Revision 1.25  1996/03/28  10:28:38  matthew
 * Adding where type clause
 *
 * Revision 1.24  1996/03/21  15:30:51  matthew
 * Adding shift optimizations
 *
 * Revision 1.23  1996/01/04  13:04:49  matthew
 * Previous fix wasn't quite right -- need to handle negative numbers also.
 *
 * Revision 1.22  1996/01/03  14:31:06  matthew
 * Int scons can now be hexadecimal
 *
 * Revision 1.21  1995/11/15  10:16:09  matthew
 * Added inlining of functors for test purposes.  Currently switched off.
 *
 * Revision 1.20  1995/09/05  14:45:57  daveb
 * Added new types for different sizes of ints, words, and reals.
 *
 * Revision 1.19  1995/08/01  14:05:01  matthew
 * Changes for new overloaded div and mod
 *
 * Revision 1.18  1995/07/25  11:52:11  jont
 * Add word operations
 *
 * Revision 1.17  1995/07/21  16:00:06  matthew
 * Removed some eta reduction
 *
 * Revision 1.16  1995/07/19  15:47:28  jont
 * Change Ident.scon_eqrep to Scons.scon_eqval
 *
 * Revision 1.15  1995/07/19  11:04:56  jont
 * Add CHAR to scon types
 *
 * Revision 1.14  1995/07/18  10:55:47  jont
 * Fix tests for equality of scons to test equality of meaning
 *
 * Revision 1.13  1995/05/23  10:08:00  matthew
 * Adding optimization to eliminate CASTs
 *
 * Revision 1.12  1995/05/19  10:49:56  matthew
 * Tuple optimization improvements
 *
 * Revision 1.11  1995/05/03  16:31:05  matthew
 * Removing debug_polyvariables option
 *
 * Revision 1.10  1995/04/26  16:18:14  matthew
 * Don't do function lifting when compiling for interceptable code
 *
 * Revision 1.9  1995/03/17  10:08:51  matthew
 * Adding more controls for different optimizations.
 *
 * Revision 1.8  1995/02/28  12:54:27  matthew
 * More debugger stuff
 *
 * Revision 1.7  1995/01/30  10:48:37  matthew
 * Improved interface to debugging stuff
 *
 * Revision 1.6  1995/01/10  10:56:08  matthew
 * Adding strings to VCC_TAG and IMM_TAG
 * Added MLVALUE
 *
 * Revision 1.5  1994/11/15  11:12:59  matthew
 * Added some imperative CSE optimization.
 * Pass closures of looping functions as parameters
 * Lift selections from curried arguments.
 *
 * Revision 1.4  1994/10/27  11:12:18  matthew
 * Fix problem with lifting selections for switched on global expressions.
 *
 * Revision 1.3  1994/10/17  12:04:33  matthew
 * Improved switch weeding and inlineing heuristics
 *
 * Copyright (c) 1995,1996 Harlequin Ltd.
 *)

require "../basis/__int";

require "../utils/crash";
require "../utils/lists";
require "../utils/inthashtable";
require "../utils/hashtable";
require "../utils/bignum";
require "../utils/mlworks_timer";
require "../main/pervasives";
require "../basics/scons";
require "../main/options";
require "lambdaprint";
require "lambdaflow";
require "transsimple";
require "simpleutils";

require "lambdaoptimiser";
require "^.basis.__string";

functor SimpleLambda (include
                      sig
                      structure Crash : CRASH
                      structure Lists : LISTS
                      structure Timer : INTERNAL_TIMER
                      structure Scons : SCONS
                      structure Bignum : BIGNUM
                      structure Options : OPTIONS
                      structure Pervasives : PERVASIVES
                      structure IntHashTable : INTHASHTABLE
                      structure HashTable : HASHTABLE
                      structure TransSimple : TRANSSIMPLE
                      structure SimpleUtils : SIMPLEUTILS
                      structure LambdaPrint : LAMBDAPRINT
                      structure LambdaFlow : LAMBDAFLOW

                      sharing TransSimple.LambdaTypes = SimpleUtils.LambdaTypes = LambdaFlow.LambdaTypes =
                        LambdaPrint.LambdaTypes
                      sharing type TransSimple.LambdaTypes.Primitive = Pervasives.pervasive
                      sharing type TransSimple.LambdaTypes.Ident.SCon = Scons.SCon
                      end where type TransSimple.LambdaTypes.LVar = int

                        ) : LAMBDAOPTIMISER =
struct
  structure LambdaTypes = TransSimple.LambdaTypes
  structure Ident = LambdaTypes.Ident
  structure Location = Ident.Location
  structure LambdaTypes = LambdaTypes
  structure Options = Options

  open LambdaTypes

  val N = Int.toString

  val inline_functors = false

  val null_debug = NONE
  val null_type = LambdaTypes.null_type_annotation

  (* Debug controls *)

  val do_diag = false
  val diag_level = 5
  val do_print = false
  val print_level = 1

  val print_result = do_diag andalso false
  (* This should be platform dependent *)
  val num_args_limit = 5
  val print_timings = ref false

  fun diag (level,f) = 
    if do_diag 
      then if level <= diag_level  then print (f()) else ()
    else ()

  fun ddiag (level,f) =
    if level <= diag_level then print (f()) else ()

  (* Optimization controls *)

  val do_cse = true
  val max_depth = 4
  val inline_size = 10

  val unsigned_array_test = true
  val do_imperative_cse = true
  val do_loop_functions = true

  (* I'm not convinced about this optimization yet *)
  val do_curry_transform = false

  val nulltype = NONE

  fun make_call_ty ty = NONE

  val crash = Crash.impossible

  (* Utilities *)

  fun is_absent NONE = true
    | is_absent _ = false

  fun max ([],acc) = acc
    | max ((a:int)::b,acc) = max (b,if a > acc then a else acc)

  fun optfun f (SOME x) = SOME (f x)
    | optfun f NONE = NONE

  (* Member and assoc for vars *)

  fun varlist_member (var:LVar,[]) = false
    | varlist_member (var:LVar,var':: rest) = var = var' orelse varlist_member (var,rest)

  fun varassoc (_, []) = NONE
    | varassoc (v:int, ((v',a) :: rest)) = 
      if v = v' then SOME a else varassoc (v,rest)
      
  fun varassoc' (v,l) =
    case varassoc (v,l) of
      SOME x => x
    | _ => crash "var not found in varassoc'"

  (* Hashmap functions *)
  fun hashmap_find (v,env) = IntHashTable.tryLookup (env,v)

  fun hashmap_member (v,env) = 
    IntHashTable.is_defined (env,v)

  fun list_to_hashmap l =
    let
      val map = IntHashTable.new (length l)
    in
      Lists.iterate (fn (n,x) => IntHashTable.update (map,n,x)) l;
      map
    end

  fun empty_hashmap () =
    IntHashTable.new 16

  (* find a function definition for an applied term *)
  fun lookup (e,defns) =
    let
      fun aux (VAR v,defns,n) =
        (* Hack to cope with infinite lookup *)
        if n > 100 
          then NONE
        else
          (case hashmap_find (v,defns) of
             SOME (VAL (e as VAR _)) => aux (e,defns,n+1)
           | SOME (VAL e) => SOME e
           | x => NONE)
        | aux (e,_,_) = SOME e
    in
      aux (e,defns,0)
    end

  (* Function bodies we are prepared to inline *)
  (* Want to become less willing to inline as we get deeper *)
  (* ie. we become more unwilling to inline stuff into a function body that itself was inlined *)

  fun is_inlineable (e,depth)=
    SimpleUtils.size_less (e,inline_size - (depth + depth),false)

  fun is_curry_inlineable (LET ((_,_,e1),FN (_,e,_,_,_,_)),depth) =
    is_inlineable (e1,depth) andalso is_curry_inlineable (e,depth)
    | is_curry_inlineable (LET ((_,_,e1),LET ((_,_,e2),FN (_,e,_,_,_,_))),depth) =
    is_inlineable (e1,depth) andalso is_inlineable (e2,depth) andalso is_curry_inlineable (e,depth)
    | is_curry_inlineable (FN (_,e,_,_,_,_),depth) = is_curry_inlineable (e,depth)
    | is_curry_inlineable (e,depth) = is_inlineable (e,depth)

(*
  val is_curry_inlineable =
    fn (e,depth) =>
    if is_curry_inlineable (e,depth)
      then (diag (2, fn () => "Curry inline found\n");
            true)
    else false
*)

  (* Simultaneous substitution of a set of variables *)
  (* substitution represented by a hashtable *)
  fun lsubst (binds,e) = 
    SimpleUtils.subst 
    (fn v =>
     case hashmap_find (v,binds) of
       SOME e => e
     | NONE => VAR v,
     e)

  (* Substitution of a list of variables together with renaming *)
  fun alpha (binds,e) =
    let
      fun aux (e as INT _) = e
        | aux (e as SCON _) = e
        | aux (e as MLVALUE _) = e
        | aux (e as BUILTIN _) = e
        | aux (e as VAR v) =
          (case hashmap_find (v,binds) of
             SOME e' => e'
           | NONE => e)
        | aux (APP (e,(el,fpel),ty)) = APP (aux e,(map aux el,map aux fpel), ty)
        | aux (STRUCT (el,ty)) = STRUCT (map aux el,ty)
        | aux (SWITCH (e,info,tel,opte)) =
          SWITCH (aux e, 
                  info,
                  map (telfun aux) tel,
                  optfun aux opte)
        | aux (HANDLE (e1,e2,s)) = HANDLE(aux e1,aux e2,s)
        | aux (RAISE e) = RAISE (aux e)
        | aux (SELECT (info,e)) = SELECT (info,aux e)
        | aux (LET ((v,i,e1),e2)) =
          let
            val v' = new_LVar ()
            val e1' = aux e1
            val _ = IntHashTable.update (binds,v,VAR v')
          in
            LET((v',i,e1'),aux e2)
          end
        | aux (FN ((vl,fpvl),body,status,name,ty,info)) = 
          let
            val new_vl = map (fn v => (v,new_LVar ())) vl
            val new_fpvl = map (fn v => (v,new_LVar ())) fpvl
            val _ =
              Lists.iterate
              (fn (v,v') => IntHashTable.update (binds,v,VAR v'))
              (new_vl @@ new_fpvl)
          in
            FN ((map #2 new_vl,map #2 new_fpvl),aux body,status,name,ty,info)
          end
        | aux (LETREC (fl,el,e)) =
          let
            val fl' = map (fn (v,info) => (new_LVar(),info)) fl
            val _ =
              Lists.iterate
              (fn ((v,_),(v',_)) => IntHashTable.update (binds,v,VAR v'))
              (Lists.zip (fl,fl'))
          in
            LETREC (fl',map aux el,aux e)
          end
    in
      aux e
    end

  fun rename e = alpha (empty_hashmap () ,e)

  fun wrap_lets ([],e) = e
    | wrap_lets ((v,i,e)::vel,e') =
      wrap_lets (vel, LET ((v,i,e),e'))

  fun unwrap_lets e =
    let
      fun aux (LET ((v,i,e1),e2),acc) =
        aux (e2,(v,i,e1)::acc)
        | aux (e,acc) = (e,acc)
    in
      aux (e,[])
    end

  (* returns list of selections from arg in e *)
  fun find_selects (arg,e) =
    let
      fun find (e as LET ((v,i,e' as SELECT (_,VAR v')),body), acc) =
        if v' = arg
          then find (body,(v,i,e')::acc)
        else (acc,e)
        | find (e,acc) = (acc,e)
    in
      find (e,[])
    end

  (* returns list of selections and selections from selections from arg in e *)
  (* This benefits some programs, but may be disadvantageous for others *)
(*
  fun find_selects (arg,e) =
    let
      fun find (vars,e as LET ((v,i,e' as SELECT (_,VAR v')),body), acc) =
        if Lists.member (v',vars)
          then find (v::vars,body,(v,i,e')::acc)
        else (acc,e)
        | find (vars,e,acc) = (acc,e)
    in
      find ([arg],e,[])
    end
*)
  
  (* Finds selections and lifts out of function definitions *) 
  (* This is one of the few bits of lifting we do right now *)
  fun curry_transform ([arg],e) =
    let
      fun lift (FN (vl,body,status,name,ty,info)) =
        let
          val (selects,body') = lift body
        in
          (selects,FN (vl,body',status,name,ty,info))
        end
        | lift (LET ((v,i,e1 as SELECT (_,VAR x')),body)) =
          let
            val (selects,body') = lift body
          in
            if arg = x' 
              then ((v,i,e1)::selects,body')
            else (selects,LET ((v,i,e1),body'))
          end
        | lift (LET ((v,i,e1),body)) =
          let
            val (selects,body') = lift body
          in
            (selects,LET ((v,i,e1),body'))
          end
        | lift e = ([],e)
      val (selects,e') = lift e
    in
      wrap_lets (rev selects,e')
    end
  | curry_transform (vl,e) = crash "Multi arg function in curry_transform"

  val curry_transform =
    fn (args,e) =>
    if do_curry_transform then curry_transform (args,e)
    else e

  (* Find the value returned by a function *)
  fun get_returned_exp (LET (_,e)) = get_returned_exp e
    | get_returned_exp e = e

  (* Substitute for the returned expression in a let *)
  fun sub_returned_exp (e',e) =
    let
      fun aux (LET((v,i,e1),e2)) = LET((v,i,e1),aux e2)
        | aux e = e'
    in
      aux e
    end 

(* Map an expression function over a let *)
fun letmap expfun e =
  let
    fun letmap_aux (LET ((x,i,e1),e2),acc) = 
      letmap_aux (e2,(x,i,letmap expfun e1)::acc)
      | letmap_aux (SWITCH (e,info,tel,opte),acc) =
        wrap_lets (acc,
                   SWITCH (letmap expfun e,
                           info,
                           map 
                           (fn (EXP_TAG e1,e2) => (EXP_TAG (letmap expfun e1), letmap expfun e2)
                             | (t,e2) => (t, letmap expfun e2))
                           tel,
                           case opte of 
                             SOME e => SOME (letmap expfun e) 
                           | _ => NONE))
      | letmap_aux (HANDLE (e1,e2,s),acc) =
        wrap_lets (acc,
                   HANDLE (letmap expfun e1,letmap expfun e2,s))
      | letmap_aux (FN (vl,e,b,name,ty,info),acc) =
        wrap_lets (acc, FN (vl,letmap expfun e,b,name,ty,info))
        (* Is this right? *)
      | letmap_aux (LETREC (fl,el,e),acc) =
        wrap_lets (acc, (LETREC (fl,map (letmap expfun) el,letmap expfun e)))
      | letmap_aux (e,acc) = wrap_lets (acc,expfun e)
  in
    letmap_aux (e,[])
  end

(* Iterate a function over a linearized let expression *)
fun letiterate f e =
  let
    fun aux (LET ((v,i,e1),e2)) = (aux e1; aux e2)
      | aux (FN (vl,e,_,_,_,_)) = aux e
      | aux (SWITCH (e,info,tel,opte)) =
        (aux e;
         Lists.iterate (fn (EXP_TAG et,e) => (aux et;aux e) | (t,e) => aux e) tel;
         ignore(optfun aux opte);
         ())
      | aux (HANDLE (e1,e2,s)) = (aux e1; aux e2)
      | aux (LETREC (fl,el,e)) = 
        (Lists.iterate aux el;aux e)
      | aux e = f e
  in
    aux e
  end

(* We have problems with lifting selections from a global that has been switched on *)
(* We could keep track of which variables have been switched on, but there may be *)
(* problems with aliasing of variables *)
(* Selecting with selecttype=TUPLE normally would be safe, but may fail for lists *)
(* Since they don't have an explicit constructor *)
(* Selects from structures are OK though *)

fun is_safe_to_lift (SELECT ({selecttype=STRUCTURE,...},_)) = true
  | is_safe_to_lift (SELECT _) = false
  | is_safe_to_lift _ = true

(* This should lift strings and reals *)
fun lift_globalp (e,dyn_vars,in_switch) =
  not (SimpleUtils.is_atomic e) andalso 
  SimpleUtils.is_simple e andalso 
  (not in_switch orelse is_safe_to_lift e) andalso
  SimpleUtils.safe e andalso 
  SimpleUtils.freevars (e,dyn_vars) = []

fun globalize_simple (e,env,dyn_vars,in_switch) =
  if SimpleUtils.is_simple e
    then (e,env)
  else globalize' (e,env,dyn_vars,in_switch)

(* dyn_vars are the variables currently in scope that have not been lifted *)
(* to the top level *)
(* Any safe expression not using any of dyn_vars may be lifted *)
(* (with proviso about selections as above) *)

and globalize' (LET ((v,i,e1),e2),env,dyn_vars,in_switch) =
  let
    val (e1',env') = globalize_simple (e1,env,dyn_vars,in_switch)
  in
    if lift_globalp (e1',dyn_vars,in_switch)
      then
        let
          val _ = diag (3, fn () => "Found global 1: " ^ LambdaPrint.pde e1' ^ "\n")
        in
          globalize' (e2, (v,i,e1')::env',dyn_vars,in_switch)
        end
    else
      let
        val (e2',env'') = globalize' (e2,env',v::dyn_vars,in_switch)
      in
        (LET ((v,i,e1'),e2'),env'')
      end
  end
  | globalize' (FN (([x],[]),body,status,name,ty,info),env,dyn_vars,in_switch) = 
    (case status of
      FUNC => 
        let 
          val body' = globalize (body,[],dyn_vars,in_switch)
          val id = new_LVar()
        in
          (FN (([x],[]),body',status,name,ty,info),env)
        end
    | _ => 
        let 
          val (body',env') = globalize' (body,env,x::dyn_vars,in_switch)
        in
          (FN (([x],[]),body',BODY,name,ty,info),env')
        end)
  | globalize' (FN _,env,dyn_vars,in_switch) = crash "Multi arg FN in globalize'"
  | globalize' (LETREC (fl,el,body),env,dyn_vars,in_switch) =
    let
      val fnnames = map #1 fl
      val dyn_vars' = fnnames@@dyn_vars
      fun do_el (FN ((vl,fpvl),e,status,name,ty,info)::rest,env,acc) =
        let
          val (e',env') = globalize' (e,env,fpvl@@vl@@dyn_vars',in_switch)
        in
          do_el (rest,env',FN ((vl,fpvl),e',status,name,ty,info)::acc)
        end
        | do_el (_::rest,env,acc) = crash "Bad fn in letrec in globalize"
        | do_el ([],env,acc) = (rev acc,env)
      val (el',env') = do_el (el,env,[])
      val (body',env'') = globalize' (body,env',dyn_vars',in_switch)
    in
      (LETREC (fl,el',body'),env'')
    end
  | globalize' (SWITCH (e,info,tel,opte),env,dyn_vars,in_switch) = 
    let
      val (e',env1) = globalize_simple (e,env,dyn_vars,in_switch)
      fun do_tel ([],env) = ([],env)
        | do_tel ((EXP_TAG e1,e)::l,env) =
          let
            val (e',env') = globalize' (e,env,dyn_vars,true)
            val (e1',env'') = globalize' (e1,env',dyn_vars,true)
            val (tel',env''') = do_tel (l,env'')
          in
            ((EXP_TAG e1',e') :: tel', env''')
          end
        | do_tel ((t,e)::l,env) =
          let
            val (e',env') = globalize' (e,env,dyn_vars,true)
            val (tel',env'') = do_tel (l,env')
          in
            ((t,e') :: tel', env'')
          end
      val (tel',env2) = do_tel (tel,env1)
      val (opte',env3) =
        case opte of
          SOME e => 
            let val (e',env) = globalize' (e,env2,dyn_vars,true)
            in
              (SOME e',env)
            end
        | NONE => (NONE,env2)
    in
      (SWITCH (e',info,tel',opte'),env3)
    end
  | globalize' (HANDLE (e1,e2,s),env,dyn_vars,in_switch) =
    let
      val (e1',env') = globalize' (e1,env,dyn_vars,in_switch)
      val (e2',env'') = globalize' (e2,env',dyn_vars,in_switch)
    in
      (HANDLE (e1',e2',s),env'')
    end
  | globalize' (e,env,dyn_vars,in_switch) = 
    if lift_globalp (e,dyn_vars,in_switch)
      then
        let
          val _ = diag (3, fn () => "Found global 2\n")
          val new_var = new_LVar ()
        in
          (VAR new_var,(new_var,null_debug,e)::env)
        end
    else
      (e,env)

and globalize (e,env,dyn_vars,in_switch) =
  let
    val (e',lets) = globalize' (e,env,dyn_vars,in_switch)
  in
    wrap_lets (lets,e')
  end

(*
fun case_transform (arg as ((id,FUN (vars,status,s,body)) :: env)) =
  let
    fun doit (v,info,t,e,body) =
      let
        val bid = new_LVar()
        val vars' = SimpleUtils.freevars (body,vars)
        val varargs = map VAR vars'
      in
        (id,null_debug,FUN (vars,ENTRY,s ^ "<Case entry>",
        SWITCH (VAR v,info,[(t,e)],
                SOME (APP (VAR bid,(varargs,[])))))) ::
        (bid,null_debug,FUN (vars',status,s,body)) :: env
      end
  in
    case body of
      SWITCH (VAR v,info,[(t1,e1)], SOME e2) =>
        if SimpleUtils.is_atomic e1
          then
            doit (v,info,t1,e1,e2)
        else
          arg
    | SWITCH (VAR v,info,[(t1,e1),(t2,e2)],NONE) =>
        if SimpleUtils.is_atomic e1
          then
            doit (v,info,t1,e1,e2)
        else arg
    | _ => arg
  end

  | case_transform _ = crash "Bad arg to case_transform"
*)

fun case_transform arg = arg

(* args is the variables to consider selection from *)

(* This doesn't seem to achieve much, and I am not sure that it is correct *)
(*
fun return_transform (arg as ((id,i,VAL (FN (vars,body,status,s,ty,info))) :: env)) =
  let
    fun check (LET _) = true
      | check _ = false
  in
    if check body
      then
        let

          val returned_exp = get_returned_exp body
          val transform_var = 
            case returned_exp of
              FN ([x],APP (VAR f,([VAR v,VAR x'],[]),_),_,_,_,_) => 
                if x = x' then SOME v else NONE
            | STRUCT ([VAR v],_) => SOME v
            | _ => NONE
        in
          case transform_var of
            SOME v =>
              (* This doesn't happen that much, I wonder why *)
              let
                val bid = new_LVar()
              in
                diag (1, fn _ => "Return transform of " ^ s ^ "\n");
                (id,null_debug,VAL (FN (vars,LET ((v,null_debug,
                                                   APP(VAR bid,(map VAR vars,[]),nulltype)),
                                                  returned_exp),
                                        BODY,s ^ "<Ret>",ty,info))) ::
                (case_transform ((bid,null_debug,VAL (FN (vars,sub_returned_exp(VAR v,body),status,s,ty,info))) :: env))
              end
            | NONE => (case_transform arg)
        end
    else
      (case_transform arg)
  end
  | return_transform _ = crash "Bad arg for return transform"
*)

fun return_transform arg = arg

(* This splits a function into two functions, an entry function that does selections *)
(* from the argument, as determined by find_selects, and a body function that does the rest *)
(* of the function *)
(* dyn_vars is the set of non-global variables defined at this point *)
(* excluding the argument being selected on *)
(* This should perhaps do something sensible when selvars = [] *)

(* Returns a new function body and an augmented environment *)

fun select_transform (arg,dyn_vars,name,(body,env)) =
  let
    val (selects,newbody) = find_selects (arg,body)
    val bid = new_LVar ()
    val selvars = map #1 selects
    val fvars = SimpleUtils.freevars (newbody,arg :: (selvars @@ dyn_vars))
  in
    (wrap_lets (selects, APP (VAR bid, (map VAR fvars,[]),nulltype)),
     (* What should the debug info etc. be? *)
     return_transform ((bid,null_debug,
                        VAL (FN ((fvars,[]),newbody,BODY,name,null_type,LambdaTypes.internal_funinfo))) :: env))
  end

(* convenience function *)
fun mk_tuple_select (index,size,e) = SELECT ({index=index,size=size,selecttype=TUPLE}, e)

(* insert_closure_selections (varlist,closid,body) inserts selections from the closure *)
(* identifier in body for the variables in varlist *)
(* Three different algorithms are here present, only one is used *)

(* The superior version *)
fun insert_closure_selections (vars,closid,body) =
  let
    val len = length vars
    val count = ref 0
    fun next () = let val result = !count in count := result + 1; result end
    val binds =
      map (fn var => (var,null_debug, mk_tuple_select (next(),len,VAR closid))) vars
  in
    SimpleUtils.insert_as_needed (binds,body)
  end

(*
fun insert_closure_selections (vars,closid,body) =
  let
    val len = length vars
    val closexp = VAR closid
    fun aux ([],n) = body
      | aux ((v::rest),n) =
        LET ((v,null_debug,mk_tuple_select (n,len,closexp)),
             aux (rest,n+1))
  in
    aux (vars,0)
  end
*)

(* Conservative version that does late selection from closure *)
(* ie. the variables are replaced by selection expressions *)
(* Should optimize these away *)
(*
fun insert_closure_selections (vars,closid,body) =
  let
    val len = length vars
    val count = ref 0
    fun next () = let val result = !count in count := result + 1; result end
    val binds =
      map (fn var => (var, mk_tuple_select (next(),len,VAR closid))) vars
  in
    lsubst (list_to_hashmap binds,body)
  end
*)

fun make_closure_function (f,closure,name) =
  let
    val x = new_LVar ()
  in
    FN (([x],[]),
        APP (VAR f,([closure,VAR x],[]),NONE),
        ENTRY,
        name ^ "<Closure>",
        null_type,
        LambdaTypes.internal_funinfo)
  end

(*
 transform (e,env,dyn_vars,global)

 lifts out "global" functions from env and extends env with them
 dyn_vars is set of non-global variables in scope at the expression
 global means that the expression is at the top-level

 global => dyn_vars = []
*)

fun transform (func as (FN (([x],[]),body,status,name,ty,info)),env,dyn_vars,global) = 
  (case status of
     (* functor bodies are treated as top level things and are transformed recursively *)
     FUNC =>
       let 
         val _ = if not global then crash "Functor not global" else ()
         val _ = if not (dyn_vars = []) then crash "Functor has dynamic vars" else ()
         val (body',env') = transform (body,[],[],true)
         val id = new_LVar()
       in
         (VAR id, (id,null_debug,FUNCTOR (x,name,(rev env',body'))) :: env)
       end
   | _ => 
       (* convert to a letrec and transform *)
       let
         val f = new_LVar ()
       in
         transform (LETREC ([(f,null_debug)],[func],VAR f),env,dyn_vars,global)
       end)
  (* Multiple arguments are only introduced here so .. *)
  | transform (FN _,env,dyn_vars,_) = crash "Multi arg FN in transform"
  (* This is the complicated part *)
  | transform (LETREC (fl,el,body),env,dyn_vars,global) =
    let
      val fvel =
        map 
        (fn ((f,_),FN ((vl,[]),body,_,name,_,info)) => (f,vl,name,body)
           | _ => crash "Bad fn in letrec in transform")
        (Lists.zip (fl,el))
      (* Lift selections from curried parameters before transforming *)
      val fvel = map (fn (f,vl,name,body) => (f,vl,name,curry_transform (vl,body))) fvel
      (* These are the external variables that go in the closures *)
      val fvars = SimpleUtils.freevars (LETREC (fl,el,INT 0),dyn_vars)
    in
      if fvars = []
        then 
          (* the simple case *)
          (* Lift all the functions straight up to top level *)
          let
            val funnames = map #1 fvel

            (* now convert the bodies of the letrec *)
            fun make_bodies ([],env) = env
              | make_bodies ((f,[x],name,fbody)::l,env) =
                let
                  (* transform the body *)
                  val (fbody',env') = 
                    select_transform (x,[x],name,transform (fbody,env,x::dyn_vars,false))
                  val result = 
                    (f,null_debug,VAL (FN(([x],[]),fbody',ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) :: env'
                in
                  make_bodies (l,result)
                end
              | make_bodies _ = crash "Can't do multiple args in letrec yet"
            val env' = make_bodies (fvel,env)
          in
            transform (body,env',dyn_vars,global)
          end (* Simple Case *)
      else
        (* The complex case, lift the functions out with an explicit closure parameter *)
        let
          (* Change calls to take a closure parameter also *)
          fun letrec_trans (exp,nameidmap,closexpr) =
            let
              fun expaux (e as APP (VAR f,([y],[]),ty)) =
                (case varassoc (f,nameidmap) of
                   SOME f' => APP (VAR f',([closexpr,y],[]),make_call_ty ty)
                 | NONE => e)
                | expaux e = e
            in
              letmap expaux exp
            end

          (* The idea of a loop function is that we take all of its closure variables *)
          (* and pass them around as individual parameters *)
          (* it's not clear that this is always a good idea though *)
          (* can make too many variables *)

          (* A simple test for a tail-recursive loop function *)
         fun is_loop_function (f,_,s,e) =
            let
              fun has_self_tail_call e =
                case e of
                  APP (VAR f',_,_) => f = f'
                | SWITCH (e,info,tel,opte) =>
                  Lists.exists (fn (t,e) => has_self_tail_call e) tel
                  orelse
                  (case opte of 
                     SOME e => has_self_tail_call e
                   | _ => false)
                | LET (_,e) => has_self_tail_call e
                | LETREC (_,_,e) => has_self_tail_call e
                | _ => false
              val result = has_self_tail_call e
            in
              if result then diag (2, fn () => "Doing " ^ s ^ " as loop function\n") else ();
              result
            end
            
          val loop_function = do_loop_functions andalso Lists.forall is_loop_function fvel

          (* Create various new name mappings *)
          val funnames = map #1 fvel
          val funids = map (fn _ => new_LVar ()) funnames
          val idtids = map (fn id => (id,new_LVar ())) funids
          val funmap = Lists.zip (funnames,funids)
          val funnamemap = Lists.zip (funmap,map #3 fvel)

          (* If only one closure var, use it as the closure object *)
          val closid = 
            case fvars of
              [x] => x
            | _ => new_LVar()

          val max_num_args = 
            let
              fun get_num_args (f,[v],_,e as LET ((_,_,SELECT ({size,...},VAR v')),_)) =
                if v = v' then size else if SimpleUtils.occurs (v,e) then 1 else 0
                | get_num_args (f,[v],_,e) = if SimpleUtils.occurs (v,e) then 1 else 0
                | get_num_args _ = crash "too many vars in get_num_args"
            in
              max (map get_num_args fvel,0)
            end

          (* Substitute for applications of the defined functions *)
          (* ie. f x become f (c,x) where c is the relevant closure id and f' is the relevant new function *)
          val fvel = map (fn (f,vl,name,e) => (f,vl,name,letrec_trans (e, funmap,VAR closid))) fvel

          val no_escapers = 
            let
              val dummy_body = STRUCT (map (fn (f,vl,name,e)=> e) fvel,TUPLE)
              val escapers = SimpleUtils.freevars (dummy_body,funnames)
            in
              escapers = []
            end

          (* Eliminate escaping functions if necessary *)
          val fvel = 
            if no_escapers 
              then fvel
            else
              (* There may be a better way of doing this *)
              (* Eg. to use insert_as_necessary *)
              let
                val subst = 
                  list_to_hashmap
                  (map 
                   (fn ((f,f'),name) => (f,make_closure_function (f',VAR closid,name)))
                   funnamemap)
              in
                map (fn (f,vl,name,e) => (f,vl,name,lsubst (subst,e))) fvel
              end

          val inline_recs =
            letmap (fn (e as APP (VAR id,([VAR c,y],[]),nulltype)) =>
                    if Lists.member (id,funids) andalso c = closid
                      then 
                        APP (VAR (varassoc' (id,idtids)), ((map VAR fvars) @@ [y],[]),nulltype)
                    else e
                   | e => e)

          (* "inlining the closure" means that instead of passing a single closure argument *)
          (* we pass in the elements of the closure as individual arguments *)

          (* inlining closures is too difficult when the closure itself is needed, ie. if *)
          (* one of the functions escape *)
          val inline_closure = 
            no_escapers andalso 
            (* The args = 0 is sort of a hack for default functions *)
            (max_num_args = 0 orelse
             loop_function orelse
             max_num_args + length fvars <= num_args_limit)

          (* now convert the bodies of the letrec *)
          fun make_bodies ([],env) = env
            | make_bodies ((id,(f,[x],name,fbody))::l,env) =
              if inline_closure
                then
                  let
                    val vars = fvars @@ [x] (* the new function parameters *)
                    (* convert calls inside the function body *)
                    val newbody = inline_recs fbody
                    (* transform the body *)
                    val (newbody',env') = 
                      select_transform (x, closid :: vars,name,transform (newbody,env,vars @@ dyn_vars,false))
                    val tid = varassoc' (id,idtids)
                    val entrybody =
                      case fvars of
                        [y] => 
                            (if x = y then crash "Bad id in transform" else ();
                             APP(VAR tid,([VAR y,VAR x],[]),nulltype))
                        | _ => insert_closure_selections (fvars,closid,APP(VAR tid,(map VAR vars,[]),nulltype))
                    val result = 
                      (id,null_debug,VAL (FN(([closid,x],[]),entrybody,ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) ::
                      (tid,null_debug,VAL (FN ((vars,[]),newbody',ENTRY,name^"<Entry2>",null_type,LambdaTypes.internal_funinfo))) :: 
                      env'
                  in
                    make_bodies (l,result)
                  end
              else
                (* Should do a destruct transform before insert_closure_selections *)
                let
                  (* put selections from closure inside body *)
                  (* and after selections from arguments *)
                  fun insert_select (e as LET ((v,i,e1 as SELECT (_,VAR id)),e2)) =
                    (if Lists.member(id,fvars) 
                       then insert_closure_selections (fvars,closid,e)
                     else LET ((v,i,e1),insert_select e2))
                    | insert_select e = insert_closure_selections (fvars,closid,e)
                  val vars = fvars@@[x]
                  (* transform the body *)
                  val newbody = 
                    case fvars of
                      [_] => fbody
                    | _ => insert_select fbody
                  val (newbody',env') = 
                    select_transform (x,[x,closid],name,transform (newbody,env,[x,closid]@@dyn_vars,false))
                  val result = 
                    (id,
                     null_debug,
                     VAL (FN (([closid,x],[]),newbody',ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) :: env'
                in
                  make_bodies (l,result)
                end
            | make_bodies ((id,(f,xl,name,e))::l,env) =
              crash "Can't do multiple args in letrec yet"

          fun make_lets ([],closexp,e) = e
            | make_lets (((f,id),name)::l,closexp,e) =
              LET ((f,null_debug,make_closure_function (id,closexp,name)),make_lets (l,closexp,e))

          val clos_expression =
            case fvars of 
              [x] => VAR x 
            | _ => STRUCT (map VAR fvars,TUPLE)
          val body' = letrec_trans (body,funmap,VAR closid)
          val body'' = if inline_closure then inline_recs body' else body'
          val env' = make_bodies(Lists.zip (funids,fvel),env)
          val (body''',env'') = transform (body'',env',closid::(funnames@@dyn_vars),false)
        in
          (LET ((closid,null_debug,clos_expression),
                make_lets (funnamemap,VAR closid,body''')),
           env'')
        end
    end

  (* straighforward recursion into the expression *)
  | transform (LET ((v,i,e1 as FN (vl,body,BODY,name,ty,info)),e2),env,dyn_vars,global) =
    transform (LETREC ([(v,i)],[e1],e2),env,dyn_vars,global)
  | transform (LET ((v,i,e1 as FN (vl,body,ENTRY,name,ty,info)),e2),env,dyn_vars,global) =
    transform (LETREC ([(v,i)],[e1],e2),env,dyn_vars,global)
  (* Global case *)
  | transform (LET ((v,i,e1),e2),env,dyn_vars,true) =
    let
      val (e1',env') = transform (e1,env,dyn_vars,true)
      val (e2',env'') = transform(e2,(v,i,VAL e1')::env',dyn_vars,true)
    in
      (e2',env'')
    end
  | transform (LET ((v,i,e1),e2),env,dyn_vars,false) =
    let
      val (e1',env') = transform (e1,env,dyn_vars,false)
      fun diddle_lets (LET ((v1,i1,LET ((v2,i2,e2),e1)),body)) =
        diddle_lets (LET ((v2,i2,e2),LET((v1,i1,e1),body)))
        | diddle_lets (LET ((v1,i1,e1),body)) =
          LET ((v1,i1,e1),diddle_lets body)
        | diddle_lets e = e
    in
      let
        val (e2',env'') = transform(e2,env',v::dyn_vars,false)
      in
        (diddle_lets (LET ((v,i,e1'),e2')),env'')
      end
    end
  | transform (SWITCH (e,info,tel,opte),env,dyn_vars,global) = 
    let
      val (e',env1) = transform (e,env,dyn_vars,global)
      fun do_tel ([],env) = ([],env)
        | do_tel ((t,e)::l,env) =
          let
            val (e',env') = transform (e,env,dyn_vars,false)
            val (tel',env'') = do_tel (l,env')
          in
            ((t,e') :: tel', env'')
          end
      val (tel',env2) = do_tel (tel,env1)
      val (opte',env3) =
        case opte of
          SOME e => 
            let val (e',env) = transform (e,env2,dyn_vars,false)
            in
              (SOME e',env)
            end
        | NONE => (NONE,env2)
    in
      (SWITCH (e',info,tel',opte'),env3)
    end
  | transform (HANDLE (e1,e2,s),env,dyn_vars,global) =
    let
      val (e1',env') = transform (e1,env,dyn_vars,false)
      val (e2',env'') = transform (e2,env',dyn_vars,global)
    in
      (HANDLE (e1',e2',s),env'')
    end
  | transform (e,env,_,_) = (e,env)

(* This is kind of essential if we use a global table for environments *)
(* Just renames all local variable names to ensure uniqueness *)
fun rename_all declist =
  let
    fun decfun (VAL e) = VAL (rename e)
      | decfun (FUNCTOR (var,name,(declist,e))) =
        FUNCTOR (var,name,(rename_all declist,e))
  in
    map (fn (var,info,dec) => (var,info,decfun dec)) declist
  end

val transform = 
  fn args => 
  let val (e,decs) = transform args
  in
    (e,rename_all decs)
  end

fun mkif (test,e1,e2) =
  SWITCH (test,SOME {num_vccs = 0,num_imms= 2},
          [((IMM_TAG ("true",1)),e1),
           ((IMM_TAG ("false",0)),e2)],
          NONE)

(* Real optimization rather than transforming to flattened form as above *)

fun make_subtest (e1,e2,lenfun,result) =
  let
    val lenvar = new_LVar ()
    val raiseexp = 
      SimpleUtils.linearize 
      (RAISE (STRUCT ([BUILTIN Pervasives.EXSUBSCRIPT,
                       STRUCT ([],TUPLE)],
                      CONSTRUCTOR)))
  in
    if unsigned_array_test
      then
        (* This one is shorter *)
        LET ((lenvar,NONE,APP (BUILTIN lenfun,([e1],[]),nulltype)),
             mkif (APP (BUILTIN Pervasives.WORDGE,([e2,VAR lenvar],[]),NONE),
                   raiseexp,
                   result))
    else
      (* But this one may be easier to optimize *)
      LET ((lenvar,NONE,APP (BUILTIN lenfun,([e1],[]),nulltype)),
           mkif (APP (BUILTIN Pervasives.INTGREATEREQ,([e2,VAR lenvar],[]),NONE),
                 raiseexp,
                 mkif (APP (BUILTIN Pervasives.INTLESS,
                            ([e2,SCON (Ident.INT  ("0",Location.UNKNOWN),NONE)],[]),
                            NONE),
                       raiseexp,
                       result)))
  end
                            
(* Attempt to optimize an application of a builtin function *)
fun do_builtinapp ((Pervasives.CAST,[e],ty),env) = SOME e
  (* Expand an application of identity builtin *)
  | do_builtinapp ((Pervasives.IDENT_FN,[e],ty),env) = SOME e
  | do_builtinapp ((Pervasives.NOT,[e],ty),env) =
  SOME (mkif (e,INT 0, INT 1))
  (* Expand an application of O *)
  | do_builtinapp ((Pervasives.O,[e1,e2],ty),env) =
  let
    val arg = new_LVar ()
  in
    SOME (FN (([arg],[]),
              SimpleUtils.linearize (APP (e1,([APP (e2,([VAR arg],[]),NONE)],[]),NONE)),
              BODY,
              "Builtin compose",
              null_type,
              LambdaTypes.internal_funinfo))
  end
              
  (* Expand array references here *)
  | do_builtinapp ((Pervasives.SUB,[e1,e2],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.LENGTH,
                      APP (BUILTIN Pervasives.UNSAFE_SUB,([e1,e2],[]),ty)))
  | do_builtinapp ((Pervasives.BYTEARRAY_SUB,[e1,e2],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.BYTEARRAY_LENGTH,
                      APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_SUB,([e1,e2],[]),ty)))
  | do_builtinapp ((Pervasives.FLOATARRAY_SUB,[e1,e2],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.FLOATARRAY_LENGTH,
                      APP (BUILTIN Pervasives.FLOATARRAY_UNSAFE_SUB,([e1,e2],[]),ty)))
  | do_builtinapp ((Pervasives.UPDATE,[e1,e2,e3],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.LENGTH,
                      APP (BUILTIN Pervasives.UNSAFE_UPDATE,([e1,e2,e3],[]),ty)))
  | do_builtinapp ((Pervasives.BYTEARRAY_UPDATE,[e1,e2,e3],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.BYTEARRAY_LENGTH,
                      APP (BUILTIN Pervasives.BYTEARRAY_UNSAFE_UPDATE,([e1,e2,e3],[]),ty)))
  | do_builtinapp ((Pervasives.FLOATARRAY_UPDATE,[e1,e2,e3],ty),env) =
  SOME (make_subtest (e1,e2,Pervasives.FLOATARRAY_LENGTH,
                      APP (BUILTIN Pervasives.FLOATARRAY_UNSAFE_UPDATE,([e1,e2,e3],[]),ty)))
  | do_builtinapp ((b,el,ty),env) =
  let
    exception Foo
    fun power2 n =
      if n <= 0 
        then NONE
      else
        let
          fun aux (1,acc) = SOME acc
            | aux (n,acc) =
              if n mod 2 = 0
                then aux (n div 2,acc+1)
              else NONE
        in
          aux (n,0)
        end

    fun get_val e =
      case lookup (e,env) of
        SOME (e as INT _) => e
      | SOME (e as SCON _) => e
      | _ => raise Foo

    fun make_int_scon (n,location) =
      SCON (Ident.INT (N n,location), NONE)

    fun make_bignum_scon (n,location) =
      SCON (Ident.INT (Bignum.bignum_to_string n,location), NONE)

    fun make_string_scon s =
      SCON (Ident.STRING s, NONE)

    fun scon_to_bignum(Ident.INT(n, _)) =
      if String.isPrefix "0x" n orelse String.isPrefix "~0x" n then
	Bignum.hex_string_to_bignum n
      else Bignum.string_to_bignum n
      | scon_to_bignum(Ident.CHAR s) =
          Bignum.int_to_bignum(ord (String.sub(s, 0)))
      | scon_to_bignum _ = crash "scon_to_bignum"

    fun scon_location (Ident.INT(_,loc)) = loc
      | scon_location (Ident.REAL(_,loc)) = loc
      | scon_location _ = Location.UNKNOWN

    fun scon_to_int s =
      Bignum.bignum_to_int (scon_to_bignum s)

    (* Why do we have these special cases here? *)
    fun foldable Pervasives.LOAD_STRING = false
      | foldable Pervasives.LOAD_STRUCT = false
      | foldable Pervasives.LOAD_VAR = false
      | foldable Pervasives.LOAD_EXN = false
      | foldable Pervasives.LOAD_FUNCT = false
      | foldable Pervasives.CALL_C = false
      | foldable _ = SimpleUtils.safe_cse (APP (BUILTIN b,(el,[]),ty))
        
    (* try_fold eliminates applications of builtins to constants *)
    fun try_fold (Pervasives.ORD,[SCON (Ident.STRING s, l)]) =
        (SOME (make_int_scon (ord(String.sub(s, 0)),Location.UNKNOWN)) 
         handle MLWorks.String.Ord => NONE)
      | try_fold (Pervasives.CHR,[SCON (n, _)]) =
        (SOME (make_string_scon (MLWorks.String.chr (scon_to_int n)))
         handle Chr => NONE
              | Bignum.Unrepresentable => NONE)
      | try_fold (Pervasives.HAT,[SCON (Ident.STRING s1, _),SCON (Ident.STRING s2, _)]) =
        SOME (make_string_scon (s1 ^ s2))
      | try_fold (Pervasives.SIZE,[SCON (Ident.STRING s, l)]) =
        SOME (make_int_scon (size s,Location.UNKNOWN))
      | try_fold (Pervasives.INTPLUS,[SCON (n1,_),SCON (n2,_)]) =
        SOME (make_bignum_scon (Bignum.+ (scon_to_bignum n1, scon_to_bignum n2),
                                scon_location n1))
      | try_fold (Pervasives.INTSTAR,[SCON (n1,_),SCON (n2,_)]) =
        SOME (make_bignum_scon (Bignum.* (scon_to_bignum n1, scon_to_bignum n2),
                                scon_location n1))
      | try_fold (Pervasives.INTDIV,[SCON (n1,_),SCON (n2,_)]) =
        SOME (make_bignum_scon (Bignum.div (scon_to_bignum n1, scon_to_bignum n2),
                                scon_location n1))
      | try_fold (Pervasives.INTMOD,[SCON (n1,_),SCON (n2,_)]) =
        SOME (make_bignum_scon (Bignum.mod (scon_to_bignum n1, scon_to_bignum n2),
                                scon_location n1))
      | try_fold (Pervasives.INTMINUS,[SCON (n1,_),SCON (n2,_)]) =
        SOME (make_bignum_scon (Bignum.- (scon_to_bignum n1, scon_to_bignum n2),
                                scon_location n1))
      | try_fold (Pervasives.INTEQ,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.eq (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold (Pervasives.INTLESS,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.< (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold (Pervasives.INTGREATER,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.> (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold (Pervasives.INTLESSEQ,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.<= (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold (Pervasives.INTGREATEREQ,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.>= (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold (Pervasives.INTNE,[SCON (n1,_),SCON (n2,_)]) =
        SOME (INT (if (Bignum.<> (scon_to_bignum n1, scon_to_bignum n2)) then 1 else 0))
      | try_fold _ = NONE

    fun make_mult (0,powerexp,accexp,bindings,location) =
      wrap_lets (bindings,accexp)
      | make_mult (n,powerexp,accexp,bindings,location) =
      let
        val powervar' = new_LVar ()
        val powerexp' =  APP (BUILTIN Pervasives.INTPLUS, ([powerexp,powerexp],[]), ty)
        val (accexp',bindings) =
          if n mod 2 = 0
            then (accexp,bindings)
          else
            let
              val accvar' = new_LVar ()
              val accexp' = APP (BUILTIN Pervasives.INTPLUS, ([accexp,powerexp],[]), ty)
            in
              (VAR accvar',
               (accvar',NONE,accexp') :: bindings)
            end
        val n' = n div 2
      in
        if n' = 0 then wrap_lets (bindings,accexp')
        else make_mult (n', 
                        VAR powervar', 
                        accexp',
                        (powervar',NONE,powerexp') :: bindings,
                        location)
      end

    val small_value = 10
    fun do_multiply (e,i,location) =
      let
        val n = scon_to_int i
      in
        if n >= 0 andalso n <= small_value
          then SOME (make_mult (n,e,SCON (Ident.INT ("0",location),NONE),[],location))
        else
          case power2 n of
            SOME j =>
              let
                fun pow n = MLWorks.Internal.Bits.lshift (1,n)
                val n = pow (29-j)
                val n2 = pow (30-j)
                val a = new_LVar ()
              in
                (* Cunning stuff for checking for overflow *)
                (* need top j + 1 bits to be the same.  Add in 2 ** (29 - j) *)
                (* This puts allowable result in the range 0 <= x < 2 ** (30 - j) *)
                (* Test for this with unsigned comparison *)
                SOME (LET ((a,
                            NONE,
                            APP (BUILTIN Pervasives.UNSAFEINTPLUS, ([e,make_int_scon (n,location)],
                                                                    []),
                                 ty)),
                           SWITCH (APP (BUILTIN Pervasives.WORDLT, ([VAR a,make_int_scon (n2,location)],[]),ty),
                                   SOME {num_vccs = 0, num_imms = 2},
                                   [(IMM_TAG ("false",0), RAISE (STRUCT ([BUILTIN Pervasives.EXOVERFLOW,
                                                                          STRUCT ([],TUPLE)],CONSTRUCTOR))),
                                    (IMM_TAG ("true",1),
                                     APP (BUILTIN Pervasives.LSHIFT, ([e,make_int_scon (j,location)],[]),ty))],
                                   NONE)))
              end
          | _ => NONE
      end

    (* try_simplify using "algebra" to simplify expressions where it can *)
    (*  Lots of word operations could go in here too *)
    fun try_simplify (Pervasives.INTDIV,[e,SCON (s,_)]) =
      let
        val i = scon_to_int s
        val location = scon_location s
      in
        case power2 i of
          SOME j => SOME (APP (BUILTIN Pervasives.ARSHIFT,([e,make_int_scon (j,location)],[]),ty))
        | _ => NONE
      end
      | try_simplify (Pervasives.INTMOD,[e,SCON (s,location)]) =
        let
          val i = scon_to_int s
          val location = scon_location s
        in
          case power2 i of
            SOME j => SOME (APP (BUILTIN Pervasives.ANDB,([e,make_int_scon (i-1,location)],[]),ty))
          | _ => NONE
        end
      (* Now we can do this as the exceptions raised are the same *)
      (* Note that we can't replace by a shift as overflow goes wrong *)
      (* Replace multiplications by 2 by an addition *)
      | try_simplify (Pervasives.INTSTAR, [e,SCON (s as Ident.INT (i,l),_)]) =
        do_multiply (e,s,l)
      | try_simplify (Pervasives.INTSTAR, [SCON (s as Ident.INT (i,l),_),e]) =
        do_multiply (e,s,l)

      (* Some easy ones *)
      | try_simplify (Pervasives.ARSHIFT,[e,SCON (Ident.INT ("0",l),_)]) = SOME e
      | try_simplify (Pervasives.RSHIFT,[e,SCON (Ident.INT ("0",l),_)]) = SOME e
      | try_simplify (Pervasives.LSHIFT,[e,SCON (Ident.INT ("0",l),_)]) = SOME e
      | try_simplify (Pervasives.INTPLUS,[e,SCON (Ident.INT ("0",l),_)]) = SOME e
      | try_simplify (Pervasives.INTPLUS,[SCON (Ident.INT ("0",l),_),e]) = SOME e
      | try_simplify _ = NONE

  in
    (if not (foldable b) 
       then NONE
     else
       let
         val args = map get_val el
         val result = try_fold (b,args)
         val _ =
           case result of
             SOME e => diag (3,
                             fn () => 
                             "Folded " ^ 
                             LambdaPrint.print_exp (APP (BUILTIN b,(args,[]),ty)) ^ 
                             "\n")
           | NONE => diag (2,
                           fn () => 
                           "CONSTANT " ^ 
                           LambdaPrint.print_exp (APP (BUILTIN b,(args,[]),ty)) ^ 
                           "\n");
       in
         result
       end
       handle Foo => try_simplify (b,el))
       handle Bignum.Unrepresentable => NONE
            | Bignum.Runtime _ => NONE
  end

(* For representing information about how variables are used *)
datatype UsesType = APP_USE | ARG_USE

(* Fill in all the lvars that are applied to something *)
(* And the arguments too *)
(* Could limit this to those that are locally defined *)
(* This looks kind of crummy *)
fun make_use_table e =
  let
    val table = empty_hashmap ()
    val app_use = [APP_USE]
    val arg_use = [ARG_USE]
    fun expfun (APP (function,(arg,_),_)) =
      (case function of
         VAR f => IntHashTable.update (table,f,app_use)
       | _ => ();
       case arg of
         [VAR a] => IntHashTable.update (table,a,arg_use)
       | _ => ())
      | expfun _ = ()
  in
    letiterate expfun e;
    table
  end

fun simplify (e,do_full,env,changed,depth) =
  let
    fun change ()  = changed := true
    val novar = NONE

    (* It's conceivable that this should be updated as we go along *)
    val use_table = make_use_table e
    fun get_uses x = 
      case hashmap_find (x,use_table) of
        SOME uses => uses
      | _ => []

    fun has_app_use (NONE) = false
      | has_app_use (SOME x) =
        Lists.member (APP_USE,get_uses x)

    fun has_arg_use (NONE) = false
      | has_arg_use (SOME x) =
        Lists.member (ARG_USE,get_uses x)

    (* This deals with non-nested constructs *)
    (* At least, they should be non-nested *)
    (* optvar is the variable being defined by the current expression, if known *)

    fun do_simple (exp,optvar,depth,switches) = 
      (case exp of
         APP (e,(el,fpel),ty) =>
           let
             val def = lookup (e,env)
             val _ = case fpel of [] => () | _ => Crash.impossible ("do_simple: fp args in APP")
           in 
             case def of
               SOME (FN ((vars,[]),body,status,_,_,_)) =>
                 (* only inline when we are doing full optimization *)
                 if do_full andalso depth <= max_depth andalso 
                   (status = ENTRY orelse (inline_functors andalso status = FUNC) orelse 
                    is_inlineable (body,depth) orelse
                    (has_app_use optvar andalso is_curry_inlineable (body,depth))) (* Only if used for an APP *)
                   then
                     (diag (3, 
                            (fn () => 
                             let
                               val f = 
                                 case e of 
                                   VAR f => LambdaPrint.print_var f 
                                 | _ => "<Function>"
                             in
                               "Inlined " ^ f ^ "\n"
                             end));
                     change();
                     aux (alpha (list_to_hashmap (Lists.zip (vars,el)),body),optvar,depth+1,switches))
                 else exp
             | SOME (BUILTIN b) =>
                 (* First thing, see if we need to do multiple argument conversion *)
                 let
                   val do_mult_convert =
                     case el of 
                       [e] => SimpleUtils.get_arity b <> 1
                     | _ => false
                 in
                   if not do_mult_convert
                     then
                       (case do_builtinapp ((b,el,ty),env) of
                          SOME e => (change(); aux (e,optvar,depth,switches))
                        | _ => exp)
                   else
                     let
                       val e2 = case el of [e2] => e2 | _ => crash "Multiarg APP of BUILTIN"
                       val arity = SimpleUtils.get_arity b
                       fun make_vars (0,acc) = acc
                         | make_vars (n,acc) = make_vars (n-1,new_LVar () :: acc)
                       fun make_lets (n,[],e) = e
                         | make_lets (n,(var::vars),e) =
                           LET ((var,null_debug,mk_tuple_select (n,arity,e2)),
                                make_lets (n+1,vars,e))
                       val vars = make_vars (arity,[])
                     in
                       diag (3, fn () => "Done a builtinapp\n");
                       change();
                       aux (make_lets  (0,vars,APP (BUILTIN b,(map VAR vars,[]),ty)),optvar,depth,switches)
                     end
                 end
             (* Want to do something if def is APP (f',...), maybe encourage this to be inlined if possible *)
             (* Convert curried to uncurried maps *)
             | SOME (APP (BUILTIN Pervasives.MAP, ([e],[]),_)) => 
                 (* We have "map f x" *)
                 (change();
                  aux (APP (BUILTIN Pervasives.UMAP,(e::el,[]),ty), optvar,depth,switches))
             | _ => exp
           end
       | SELECT (info as {index=i,size=j,selecttype=ty},e) =>
           (let 
             val def = lookup (e,env)
            in
              case def of 
                SOME (STRUCT (args,ty')) => 
                  (diag (3, (fn () => "Done a select on " ^ LambdaPrint.print_exp (SELECT(info,e)) ^ "\n"));
                   if ty <> ty' 
                     then diag (1, 
                                fn () => "Bad struct-select pair:" ^ 
                                LambdaPrint.print_exp (SELECT (info,e)) ^ ":" ^ 
                                LambdaPrint.print_exp (STRUCT (args,ty')) ^ "\n") 
                   else ();
                   change();
                   aux (Lists.nth (i,args),optvar,depth,switches))
              | _ => exp
             end 
             handle Lists.Nth => 
               (crash ("Bad Select: " ^ LambdaPrint.print_exp (SELECT(info,e)) ^ "\n")))
       | STRUCT (v::vl,ty) =>
           (* I have a suspicion that compiling the compiler is helped by not checking *)
           (* for function arguments -- curried applications that are later transformed *)
           (* into non-curried application are the difficult case *)
           if not (has_arg_use optvar) then (* Don't do this if used as a function arg *)
             let
               val def = lookup (v,env)
             in
               case def of
                 SOME (SELECT ({index=0,size=j,selecttype=ty'},e)) =>
                   (* If e doesn't have a definition, then its probably a function argument *)
                   (case lookup (e,env) of
                      SOME _ =>
                        let
                          val len = 1 + length vl
                        in
                          if j = len andalso ty = ty' 
                            then
                              let
                                fun check (n,[]) = true
                                  | check (n,v::vl) =
                                    case lookup (v,env) of
                                      SOME (SELECT ({index=i,size=j,...},e')) =>
                                        i = n andalso
                                        j = len andalso
                                        (* Is this safe? *)
                                        SimpleUtils.exp_eq (e,e') andalso
                                        check (n+1,vl)
                                    | _ => false
                              in
                                if check (1,vl)
                                  then (diag (3, fn () => "Done a struct\n");
                                        change();
                                        aux (e,optvar,depth,switches))
                                else exp
                              end
                          else
                            exp
                        end
                    | _ => exp)
               | _ => exp
             end
           else exp
       | SWITCH (e,info,tel,opte) =>
           (* First see if the rhs's are all equal *)
           (* Then if we are switching on a known value *)
           (* Then if we have switched on the value before *)
           (* Else just simplify the branches of the switch *)
           let
             fun eq_tag (IMM_TAG (_,i),IMM_TAG (_,i')) = i = i'
               | eq_tag (VCC_TAG (_,i),VCC_TAG (_,i')) = i = i'
               | eq_tag (SCON_TAG (s,_),SCON_TAG (s',_)) =
		 (case s of
		    Ident.REAL _ => Crash.impossible"simplelambda:eq_tag:real"
		  | _ => Scons.scon_eqval(s, s'))
               | eq_tag _ = false
             fun print_tag (IMM_TAG (_,i)) = "IMM " ^ N i
               | print_tag (VCC_TAG (_,i)) = "VCC " ^ N i
               | print_tag (SCON_TAG (Ident.INT (i,_),_)) = "INT " ^ i
               | print_tag (SCON_TAG (Ident.WORD (i,_),_)) = "WORD " ^ i
               | print_tag (SCON_TAG (Ident.REAL (i,_),_)) = "REAL " ^ i
               | print_tag (SCON_TAG (Ident.STRING s, _)) = "STRING " ^ MLWorks.String.ml_string (s,~1)
               | print_tag (SCON_TAG (Ident.CHAR s, _)) = "CHAR " ^ MLWorks.String.ml_string (s,~1)
               | print_tag (EXP_TAG i) = "<EXP_TAG>"
             fun constant_switch_weed (t,[],SOME e) = e
               | constant_switch_weed (t,[],NONE) = crash ("constant tag: " ^ print_tag t ^ " not found: " ^ LambdaPrint.print_exp (SWITCH (e,info,tel,opte)))
               | constant_switch_weed (t,((t',e)::rest),opte) =
                 if eq_tag (t,t')
                   then e
                 else constant_switch_weed (t,rest,opte)
             fun all_equal (tel,opte) =
               let
                 fun dotags (e,[]) = SOME e
                   | dotags (e,(e'::l)) = 
                     if SimpleUtils.exp_eq (e,e') then dotags (e,l) else NONE
               in
                 case (tel,opte) of
                   (_,SOME e) => dotags (e,map #2 tel)
                 | (((t,e)::rest),NONE) => dotags (e, map #2 rest)
                 | _ => crash "No cases in all_equal"
               end
             fun find_switch (e,[]) = NONE
               | find_switch (e,(e',t)::rest) = 
               if SimpleUtils.exp_eq (e,e') 
                 then SOME t 
               else find_switch (e,rest)
             fun find_default_tag (tel, SOME{num_vccs,num_imms}) =
               if length tel + 1 = num_vccs + num_imms
                 then
                   let
                     fun find ([],tags,vccs,imms) = (tags,vccs,imms)
                       | find ((VCC_TAG (_,i),_)::rest,tags,vccs,imms) = find (rest,i::tags,1+vccs,imms)
                       | find ((IMM_TAG (_,i),_)::rest,tags,vccs,imms) = find (rest,i::tags,vccs,1+imms)
                       | find (_::rest,tags,vccs,imms) = crash "Bad tag in find_default_tag"
                     fun find_missing tags =
                       let
                         val tags = Lists.qsort (op<) tags
                         fun scan (n,[]) = n
                           | scan (n,(n'::rest)) =
                             if n = n' then scan (n+1,rest)
                             else n
                       in
                         scan (0,tags)
                       end
                     val (tags,vccs,imms) = find (tel,[],0,0)
                   in
                     if vccs = num_vccs-1
                       then SOME (VCC_TAG ("?",find_missing tags))
                     else
                       if imms = num_imms-1
                         then SOME (IMM_TAG ("?",find_missing tags))
                       else crash "Can't find default tag"
                   end
               else NONE
               | find_default_tag (tel, NONE) = NONE
           in
             case all_equal (tel,opte) of
               SOME e' =>
                 let 
                   val _ = diag (2,fn () => "All equal switch found: " ^ LambdaPrint.print_exp e' ^ "\n")
                   val _ = change()
                   val id = new_LVar ()
                 in
                   LET ((id,null_debug,aux (e,novar,depth,switches)),aux (e',optvar,depth,switches))
                 end
             | NONE => 
                 let
                   val edef = lookup (e,env)
                 in
                   case edef of
                     SOME (INT i) =>
                       (change();
                        diag (1,fn _ => "Found INT constant switch\n");
                        aux (constant_switch_weed (IMM_TAG ("",i),tel,opte),optvar,depth,switches))
                   | SOME (STRUCT ([INT i,_],TUPLE)) =>
                       (* It looks like this can only happen for lists *)
                       let fun auxweed i =
                           aux(constant_switch_weed(VCC_TAG ("",i),tel,opte),
                               optvar,depth,switches)
                       in 
                         change();
                         diag (1,fn _ => "Found VCC constant switch\n");
                         case info of 
                           NONE => auxweed i 
                         | SOME {num_vccs, num_imms} =>
                             if num_vccs = 1 andalso num_imms = 1
                             then 
                               (* We presumably have a cons cell here.  
                                  Quite why lists are treated specially,
                                  rather than implementing a general 
                                  optimisation for the num_vccs = 1 case,
                                  is a mystery to me.  But we need to generate
                                  the 0 (cons) tag in this case rather than 
                                  interpreting the contents of the cell as
                                  a tag. It would be more robust if we could
                                  determine the constructor to use from the
                                  type, but the lambda code doesn't contain
                                  type information. *)
                               auxweed 0 
                             else 
                               (* I don't think this can happen, but treat 
                                  like before just in case - at least we won't
                                  break anything new :-) *)
                               auxweed i 
                       end
                   | SOME (STRUCT ([INT i,_],_)) =>
                       (change();
                        diag (1,fn _ => "Found VCC constant switch\n");
                        aux (constant_switch_weed (VCC_TAG ("",i),tel,opte),optvar,depth,switches))
                   | SOME (SCON(s as Ident.INT _, opt)) =>
                       (change();
                        diag (1,fn _ => "Found SCON constant switch\n");
                        aux (constant_switch_weed (SCON_TAG (s,opt),tel,opte),optvar,depth,switches))
                   | SOME (SCON(s as Ident.STRING _, opt)) =>
                       (change();
                        diag (1,fn _ => "Found SCON constant switch\n");
                        aux (constant_switch_weed (SCON_TAG (s,opt),tel,opte),optvar,depth,switches))
                   | _ =>
                       (case find_switch (e,switches) of
                          SOME t =>
                            (change();
                             diag (2,fn _ => "Repeated switch found\n");
                             aux (constant_switch_weed (t,tel,opte),optvar,depth,switches))
                        | _ =>
                            let
                              val e' = 
                                case edef of
                                  SOME e' => 
                                    if SimpleUtils.switchable_exp e' then e'
                                    else e
                                | _ => e
                              val (e'',lets) =
                                unwrap_lets (aux (e',novar,depth,switches))
                            in
                              wrap_lets 
                              (lets,
                               SWITCH (e'',
                                       info,
                                       (* Maybe we should carry the uses over *)
                                       map
                                       (* Don't add EXP tags to switches just yet *)
                                       (fn (EXP_TAG te,e') =>
					(EXP_TAG (aux (te,novar,depth,switches)),
					 aux(e',novar,depth,switches))
					| (t as SCON_TAG(Ident.REAL _, _), e') =>
					    (t, aux(e',novar,depth,switches))
					| (t,e') => (t,aux(e',novar,depth,(e,t)::switches)))
                                       tel,
                                       let
                                         val switches' = 
                                           case find_default_tag (tel,info) of
                                             SOME t => (e,t) :: switches
                                           | _ => switches
                                       in
                                         optfun (fn e => aux (e,novar,depth,switches')) opte
                                       end))

                            end)
                 end
           end
       (* Maybe we should carry the uses over *)
       | HANDLE (e1,e2,s) => HANDLE (aux (e1,novar,depth,switches),
                                     aux (e2,novar,depth,switches),s)
       | FN ((vl,fpvl),body,status,name,ty,debug) => 
           let
             val newbody = aux (body,novar,depth,switches)
             fun eqvars ([],[]) = true
               | eqvars (VAR v::l,v'::l') =
                 v = v' andalso eqvars (l,l')
               | eqvars _ = false
             val is_eta =
               case newbody of
                 APP (f,(el,fpel),_) => 
                   if eqvars (el, vl) andalso eqvars (fpel, fpvl) then SOME f else NONE
                | _ => NONE
           in
             case is_eta of
               SOME e => (diag (2,fn _ => "Found eta\n"); change(); e)
               | _ => FN ((vl,fpvl),newbody,status,name,ty,debug)
           end
       (* error for these cases *)
       | LET ((x,_,e1),e2) => crash "NotLinearized: let"
       | LETREC _ => crash "NotLinearized: letrec"
       | _ => exp)

    and merge_lets (x1,i1,LET ((x2,i2,e1),e2),e3,optvar,depth,switches) =
      (IntHashTable.update (env,x2,VAL e1);
       LET ((x2,i2,e1),merge_lets (x1,i1,e2,e3,optvar,depth,switches)))
      | merge_lets (x1,i1,e1,e2,optvar,depth,switches) =
        (IntHashTable.update (env,x1,VAL e1);
         LET ((x1,i1,e1),aux (e2,optvar,depth,switches)))

    and aux (LET ((x1,i1,LET ((x2,i2,e1),e2)),e3),optvar,depth,switches) =
        aux (LET ((x2,i2,e1),(LET ((x1,i1,e2),e3))),optvar,depth,switches) 
      | aux (LET ((x1,i1,LETREC (fl,vl,e2)),e3),optvar,depth,switches) =
        aux (LETREC (fl,vl, LET ((x1,i1,e2),e3)),optvar,depth,switches)
      (* Discard computations after raises *)
      | aux (LET ((x1,i1,e1 as RAISE _),e2),optvar,depth,switches) =
        aux (e1,optvar,depth,switches)
      | aux (LET ((x,i,e1),e2),optvar,depth,switches) =
        (case e1 of
           (* Special case for boundary checks *)
           (* We could generalize this form a little *)
           SWITCH (e1',info,[(t1,se1 as RAISE _),
                             (t2,se2)],
                   NONE) =>
           aux (SWITCH (e1',info,[(t1,se1),(t2,LET ((x,i,se2),e2))],NONE),
                optvar,depth,switches)
        | _ => 
           merge_lets (x,i,do_simple (e1,SOME x,depth,switches),e2,optvar,depth,switches))
      | aux (LETREC (fl,el,e),optvar,depth,switches) =
        let
          val el' =
            map
            (* do it like this to avoid eta reduction of fns *)
            (fn ((f,info),FN (args,e,status,name,ty,debug)) => 
             let
               val e' = aux (e,novar,depth,switches)
               val f' = FN (args,e',status,name,ty,debug)
               val _ = IntHashTable.update (env,f,VAL f')
             in
               f'
             end
           | ((f,info),_) => crash "Bad fn in letrec - simplify")
            (Lists.zip (fl,el))
        in
          LETREC (fl,el',aux (e,optvar,depth,switches))
        end
      | aux (e,optvar,depth,switches) = do_simple (e,optvar,depth,switches)
  in
    aux (e,novar,depth,[])
  end

fun simplify_exp (e,do_full) = simplify (e,do_full,empty_hashmap (),ref false,0)

(* Various auxiliary optimization functions *)

(* This finds unused local bindings of names *)

fun remove_unused e =
  (* This assumes e is linearized *)
  let
    (* Accumulate used variables in here *)
    val vars = empty_hashmap ()
    fun do_simple e =
      case e of
        SWITCH (e,info,tel,opte) =>
          SWITCH (do_simple e,info,map (telfun do_let) tel,optfun do_let opte)
      | HANDLE (e1,e2,s) => HANDLE (do_let e1,do_let e2,s)
      | FN (args,e,status,name,ty,debug) => FN (args,do_let e,status,name,ty,debug)
      (* Don't eliminate functions in letrecs for the moment *)
      (* But we should do! *)
      | LETREC (fl,el,e) => LETREC (fl,map do_let el,do_let e)
      | LET _ => crash ("NotLinearized: remove_unused" ^ LambdaPrint.print_exp e)
      | e => 
          (Lists.iterate
           (fn x => IntHashTable.update (vars,x,()))
           (SimpleUtils.vars_of e);
           e)
    and do_let e =
      case e of
        LET ((x,i,e1),e2) =>
          let
            val e2' = do_let e2
          in
            if hashmap_member (x,vars) orelse 
              not (is_absent i) orelse (* Don't eliminate vars with debug info attached *)
              not (SimpleUtils.safe_elim e1)
              then LET ((x,i,do_simple e1),e2')
            else
              (diag (3, fn () => "Dropping let\n");
               e2')
          end
      | e => do_simple e
  in
    do_let e
  end

(* Eliminate simple bindings of expressions *)

fun internal_elim_simple_bindings (binds,e) =
    let
      (* This is the most called function, according to the profiler *)
      fun aux (e as INT _) = e
        | aux (e as SCON _) = e
        | aux (e as MLVALUE _) = e
        | aux (e as BUILTIN _) = e
        | aux (e as VAR v) =
          (case hashmap_find (v,binds) of
             SOME e' => e'
           | NONE => e)
        | aux (APP (e,(el,fpel),ty)) = APP (aux e,(map aux el,map aux fpel), ty)
        | aux (FN (args,e,status,name,ty,debug)) = FN (args,aux e,status,name,ty,debug)
        | aux (LETREC (fl,el,e)) =
          LETREC (fl,map aux el,aux e)
        | aux (STRUCT (el,ty)) = STRUCT (map aux el,ty)
        | aux (SWITCH (e,info,tel,opte)) =
          SWITCH (aux e, 
                  info,
                  map (telfun aux) tel,
                  optfun aux opte)
        | aux (HANDLE (e1,e2,s)) = HANDLE(aux e1,aux e2,s)
        | aux (RAISE e) = RAISE (aux e)
        | aux (SELECT (info,e)) = SELECT (info,aux e)
        | aux (e as LET _) = do_let (e,[])
      and do_let (LET ((v,i,e1),e2),acc) =
        (* Only do this for variables without debug info *)
        if SimpleUtils.is_atomic e1 andalso is_absent i
          then 
            (IntHashTable.update (binds,v,aux e1);
             do_let (e2,acc))
        else do_let (e2,(v,i,aux e1)::acc)
        | do_let (e,acc) =
          wrap_lets (acc,aux e)
(*
        | aux (LET ((v,i,e1),e2)) = do_let (v,i,e1,e2)
      and do_let (v,i,e1,e2) =
        (* Only do this for variables without debug info *)
        if SimpleUtils.is_atomic e1 andalso is_absent i
          then 
            (IntHashTable.update (binds,v,aux e1);
             aux e2)
        else LET((v,i,aux e1),aux e2)
*)
    in
      aux e
    end

fun elim_simple_bindings e = internal_elim_simple_bindings (empty_hashmap (),e)

fun pprint (level,p) = 
  if do_print andalso level <= print_level 
    then print (LambdaPrint.pds (PROGRAM p) ^ "\n") 
  else ()
  
fun pprint_exp (level,e) = 
  if do_print andalso level <= print_level 
    then print (LambdaPrint.pde e ^ "\n")
  else ()

fun cleanup e = 
  let
    val e = elim_simple_bindings e
    val _ = diag (2,fn () => "Done elim simple bindings\n")
    val e = remove_unused e
    val _ = diag (2,fn () => "Done remove unused\n")
  in
    e
  end

fun progmap f (declist,exp) =
  let
    fun decfun (VAL (FN (vl,e,status,name,ty,debug))) = VAL (FN (vl,f e,status,name,ty,debug))
      | decfun (VAL e) = VAL (f e)
      | decfun (FUNCTOR (var,name,prog)) =
        FUNCTOR (var,name,progmap f prog)
  in
    (map (fn (var,info,dec) => (var,info,decfun dec)) declist,
     f exp)
  end

val linearize = elim_simple_bindings o SimpleUtils.linearize o elim_simple_bindings

fun linearize_all prog =
  let
    val result = progmap linearize prog
  in
    pprint (2,result);
    result
  end

fun make_hashmap_env declist =
  let
    val env = empty_hashmap ()
    fun aux declist = 
      let
        fun decfun (FUNCTOR (var,name,(declist,exp))) = aux declist
          | decfun _ = ()
      in
        Lists.iterate (fn (var,info,dec) => 
                       (IntHashTable.update (env,var,dec);
                        decfun dec))
        declist
      end
  in
    aux declist;
    env
  end

(* inline objects only used once *)

fun count_occurrences (counts,prog) =
  let
    fun inc_var x = 
      case hashmap_find (x,counts) of
        SOME (r,_,_) => r := 1 + (!r)
      | NONE => ()
    fun aux (INT _) = ()
      | aux (SCON _) = ()
      | aux (MLVALUE _) = ()
      | aux (BUILTIN _) = ()
      | aux (VAR x) = inc_var x
      | aux (FN (vl,e,_,_,_,_)) = aux e
      | aux (STRUCT (el,_)) = Lists.iterate aux el
      | aux (SWITCH (e,info,tel,opte)) =
        (aux e;
         Lists.iterate (fn (EXP_TAG et,e) => (aux et;aux e) | (t,e) => aux e) tel;
         ignore(optfun aux opte);
         ())
      | aux (HANDLE (e1,e2,s)) = (aux e1; aux e2)
      | aux (RAISE e) = aux e
      | aux (SELECT (_,e)) = aux e
      | aux (LET ((v,_,e1),e2)) = (aux e1; aux e2)
      | aux (LETREC (fl,el,e)) = (Lists.iterate aux el; aux e)
      | aux (APP (VAR x,(el,fpel),_)) = (inc_var x; Lists.iterate aux el; Lists.iterate aux fpel)
      | aux (APP (e,(el,fpel),_)) = (aux e; Lists.iterate aux el; Lists.iterate aux fpel)
    fun decfun (_,_,VAL (FN (_,e,_,_,_,_))) = aux e
      | decfun (_,_,VAL e) = aux e
      | decfun (_,_,FUNCTOR (var,_,prog)) =
        progfun prog
    and progfun (defns,exp) =
      (Lists.iterate decfun defns;
       aux exp)
  in
    progfun prog
  end

(* This goes inside expressions as well to get locally defined functions *)
fun internal_inline_single_callees (do_lifting,prog as (defns,exp)) =
  let
    val counts = empty_hashmap ()
    fun add_name (f,args,body) = 
      (diag (0,fn _ => "Adding function " ^ LambdaPrint.print_var f ^ "\n");
       IntHashTable.update (counts, f, (ref 0,args,body)))

    fun get_exp_funnames exp =
      case exp of
        FN (vl,e,stat,name,ty,funinfo) => get_exp_funnames e
      | LET ((f,info,e as FN ((vl,[]),funbody,stat,name,ty,funinfo)),body) =>
          (add_name (f,vl,funbody);
           get_exp_funnames e;
           get_exp_funnames body)
      | LET ((x,info,e),body) =>
          (get_exp_funnames e;
           get_exp_funnames body)
      | LETREC (vl,el,e) =>
        (Lists.iterate
         (fn ((f,info),FN ((vl,[]),funbody,stat,name,ty,funinfo)) => 
          add_name (f,vl,funbody)
          | _ => Crash.impossible "Malformed letrec in internal_inline_single_callees")
         (Lists.zip (vl,el));
         Lists.iterate get_exp_funnames el;
         get_exp_funnames e)
      | SWITCH (e,info,tel,opte) =>
        (Lists.iterate
         (fn (t,e) => get_exp_funnames e)
         tel;
         case opte of
           SOME e => get_exp_funnames e
         | _ => ())
      | HANDLE (e1,e2,_) =>
          (get_exp_funnames e1;
           get_exp_funnames e2)
      (* Usual assumption that the argument is linearized *)
      | _ => ()

    fun get_funnames [] = ()
      | get_funnames ((f,_,VAL (FN ((vl,[]),e,stat,name,ty,funinfo))):: l) = 
        (add_name (f,vl,e);
         get_exp_funnames e;
         get_funnames l)
      | get_funnames ((_,_,VAL e):: l) = 
        (get_exp_funnames e;
         get_funnames l)
      | get_funnames ((f,_,FUNCTOR (x,name,(declist,e)))::l) =
        (get_funnames declist;
         get_exp_funnames e;
         get_funnames l)

    val env = make_hashmap_env defns
    val _ = get_funnames defns
    val _ = get_exp_funnames exp
    val _ = count_occurrences (counts,prog)

    (* Get the non-single-occurence definitions *)
    (* Should check size of f body here too *)
    fun toinline f = 
      case hashmap_find (f,counts) of
        SOME (ref 1,args,body) => SOME (args,body)
      | _ => NONE

    (* Assume linearized *)
    (* Should we inline in function bodies or not? *)
    (* Yes in debugging mode, no otherwise *)
    (* At least, we want to inline match functions where possible because *)
    (* otherwise debug information gets lost *)

    (* Ensure we don't go wibbling off into infinity *)
    (* A better solution would be nice *)
    val max_depth = 20
    fun inline (e,count) =
      let
        fun aux (FN (vl,e,b,name,ty,debug)) = 
          FN (vl, if do_lifting then e else aux e, b,name,ty,debug)
          | aux (SWITCH (e,info,tel,opte)) =
            SWITCH (aux e,
                    info,
                    map (telfun aux) tel,
                    optfun aux opte)
          | aux (HANDLE (e1,e2,s)) = HANDLE (aux e1,aux e2,s)
          | aux (LET ((v,i,e1),e2)) = LET ((v,i,aux e1),aux e2)
          | aux (e as APP (VAR f,(el,[]),ty)) =
            (case toinline f of
               SOME (args,body) =>
                 if SimpleUtils.size_less (body,1000,true) andalso count < max_depth
                   then
                     inline (alpha (list_to_hashmap (Lists.zip (args,el)),body),count+1)
                 else e
             | NONE => e)
          | aux (e as APP _) = e
          | aux (LETREC (fl,el,e)) = LETREC (fl, map aux el, aux e)
          | aux e = e
      in
        aux e
      end
  in
    progmap (fn e => inline (e,0)) prog
  end
      
fun used_globals (prog as (defns,exp)) =
  let
    val global_env = make_hashmap_env defns
    val seen = empty_hashmap ()
    val todo = ref [] : LambdaExp list ref
    fun pop () = case !todo of (a::b) => (todo:=b;a) | _ => crash "Bad Pop"
    fun push e = todo := e :: !todo
    fun check var = hashmap_member (var,global_env) andalso not (hashmap_member (var,seen))
    fun add var = (IntHashTable.update (seen,var,());
                   do_var_def var)
    and do_var_def var =
      case hashmap_find (var,global_env) of
        NONE => crash "No environment entry for global"
      | SOME d =>
          (case d of
             VAL e => push e
           | FUNCTOR (_,_,(defs,e)) => (Lists.iterate do_one defs; push e))
    and do_one (i,info,VAL e) = 
      if check i andalso not (SimpleUtils.safe_elim e) 
        then (push e;add i) 
      else ()
      | do_one _ = ()
    fun do_var var = if check var then add var else ()
    fun aux (INT _) = ()
      | aux (SCON _) = ()
      | aux (MLVALUE _) = ()
      | aux (BUILTIN _) = ()
      | aux (VAR var) = do_var var
      | aux (STRUCT (el,_)) = laux el
      | aux (SWITCH (e,info,tel,opte)) = 
        (aux e;
         Lists.iterate (fn (t,e) => (aux e; taux t)) tel;
         case opte of
           SOME e' => aux e'
         | NONE => ())
      | aux (HANDLE (e1,e2,s)) = (aux e1;aux e2)
      | aux (RAISE e) = aux e
      | aux (SELECT (_,e)) = aux e
      | aux (LET ((v,_,e1),e2)) = (aux e1;aux e2)
      | aux (APP (e,(el,fpel),_)) = (aux e;Lists.iterate aux el; Lists.iterate aux fpel)
      | aux (FN (vl,e,status,name,_,_)) = aux e
      | aux (LETREC (fl,el,e)) = (Lists.iterate aux el; aux e)
    and laux ([]) = ()
      | laux (e::el) = (aux e; laux el)
    and taux (EXP_TAG e) = aux e
      | taux (_) = ()
    fun null [] = true
      | null _ = false
  in
    push exp;
    Lists.iterate do_one defns;
    while not (null (!todo)) do aux (pop());
    seen
  end

fun weed (prog as (defns,exp)) =
  let
    val _ = diag (2, fn () => ("Weeding..\n"))
    val vars = used_globals prog
    fun strip ((def as (a,info,VAL e))::rest,acc) =
      if hashmap_member(a,vars) orelse not (is_absent info)
        then strip (rest,def::acc)
      else 
        (diag (3, fn () => ("Weeding " ^ LambdaPrint.print_var a ^ "\n"));
         if SimpleUtils.safe_elim e then () else crash "Eliminating unsafe expression";
         strip (rest,acc))
      | strip ((a,info,FUNCTOR (var,name,(defns,exp))) :: rest,acc) =
        strip (rest,(a,info,FUNCTOR (var,name,(strip (defns,[]),exp))) :: acc)
      | strip ([],acc) = rev acc
    val new = strip (defns,[])
  in
    (new,exp)
  end

fun globify (defs,exp) =
  let
    fun globify_aux ([],acc) = rev acc
      | globify_aux ((a,i1,VAL (LETREC (fl,el,e))) :: l,acc) =
        let
          val fns =
            map (fn ((f,info),e) => (f,info,VAL e))
            (Lists.zip (fl,el))
        in
          globify_aux (l, (a,i1,VAL e) :: (rev fns @@ acc))
        end
      | globify_aux ((a,i1,VAL (LET ((v,i2,e1),e2))) :: l,acc) =
        globify_aux ((a,i1,VAL e2)::l,(v,i2,VAL e1)::acc)
      | globify_aux ((a,i1,FUNCTOR (v,name,prog)) :: l,acc) =
        globify_aux (l,(a,i1,FUNCTOR (v,name,globify prog))::acc)
      | globify_aux (d::l,env) =
        globify_aux (l,d::env)
  in
    (globify_aux (defs,[]),exp)
  end

fun simplify_all (prog,do_full,env,depth) =
  let
    val changed = ref false
    fun aux (declist,exp) =
      let
        (* Only simplify inside the body to prevent bad eta reductions *)
        fun doval (FN (vl,body,status,name,ty,debug)) =
          FN (vl,simplify (body,do_full,env,changed,depth),status,name,ty,debug)
          | doval e = simplify (e,do_full,env,changed,depth)
        fun decfun (x,info,VAL e) = 
            let
              val new = VAL (doval e)
            in
              IntHashTable.update (env,x,new);
              diag (1,fn _ => "Done " ^ N x ^ "\n");
              (x,info,new)
            end
          | decfun (f,info,FUNCTOR (var,name,prog)) =
            (f,info,FUNCTOR (var,name,aux prog))
      in
        (map decfun declist,
         simplify (exp,do_full,env,changed,depth))
      end
    val prog' = aux prog
  in
    (!changed,prog')
  end

fun simplify_till_done (prog as (declist,exp),do_full) =
  let 
    val env = make_hashmap_env declist
    fun aux (prog,n) =
      let      
        val _ = diag (2, fn () => ("Optimize pass " ^ N n ^ "\n"))
        val _ = pprint (2,prog)
        val (changed,prog') = simplify_all (prog,do_full,env,n)
        val _ = diag (2, fn () => ("Done pass " ^ N n ^ "\n"))
      in
        if changed then aux (globify prog',n+1)
        else 
          (diag (1, fn () => (N n ^ " iterations of simplify_all\n"));
           weed (progmap cleanup (globify prog')))
      end
  in
    aux (prog,0)
  end

(* This should only be called on simple expressions, hence the Crash.impossible *)
fun exp_hash (VAR v) = v
  | exp_hash (APP (e1,(el,fpel),_)) = 7 * exp_hash e1
  | exp_hash (SCON (s,_)) = 91
  | exp_hash (INT n) = 1001 + n
  | exp_hash (STRUCT (el,ty)) = elist_hash el
  | exp_hash (SELECT (_,e)) = 10001 + exp_hash e
  | exp_hash (BUILTIN b) = 100001
  | exp_hash (MLVALUE _) = 200001
  | exp_hash _ = Crash.impossible "exp_hash"
and elist_hash [] = 2001
  | elist_hash (a::b) = exp_hash a + elist_hash b

fun make_exp_table () =
  ref (HashTable.new (16,SimpleUtils.exp_eq,exp_hash))
fun empty_exp_table table =
  table := HashTable.new (16,SimpleUtils.exp_eq,exp_hash)
fun exp_add (e,v,table) =
  HashTable.update (!table,e,v)
fun exp_remove (e,table) =
  HashTable.delete (!table,e)
fun exp_lookup (e,table) =
  HashTable.tryLookup (!table,e)

(* version with hash-table copying *)

fun global_cse (defs,exp) =
  let
    val top_level_table = make_exp_table ()
    fun aux ([],acc,substs,_) = (rev acc,substs)
      | aux ((v,info,VAL (FN(args,e,s,n,t,d))) :: l,acc,substs,table) =
        let
          val e' = lsubst (substs,e)
        in
          aux (l,(v,info,VAL (FN(args,e',s,n,t,d)))::acc,substs,table)
        end
      | aux ((v,info,VAL e) :: l,acc,substs,table) =
        let
          val e' = lsubst (substs,e)
        in
          (* Only CSE non-atomic expressions -- else eta funs fall over *)
          if SimpleUtils.is_atomic e' orelse not (SimpleUtils.is_simple e')
            then aux (l,(v,info,VAL e')::acc,substs,table)
          else
            case exp_lookup (e',table) of
              SOME v' =>
                (diag (3, fn () => "CSE of " ^ LambdaPrint.print_var v ^ " = "
 ^ LambdaPrint.print_exp e' ^ "\n");
                 IntHashTable.update (substs,v,VAR v');
                 aux (l,acc,substs,table))
            | NONE =>
                if SimpleUtils.safe e'
                  then
                    (exp_add (e',v,table);
                     aux (l,(v,info,VAL e')::acc,substs,table))
                else
                  aux (l,(v,info,VAL e')::acc,substs,table)
        end
      | aux ((v,info,FUNCTOR(arg,name,(fdefs,fexp))) :: rest,acc,substs,table) =
        let
          (* intra-functor CSE inherits top-level exp table ... *)
          val ftable = make_exp_table ()
          val _ = (ftable := HashTable.copy(!table))
          (* ... but uses its own copy to do its own CSE *)
          val (fdefs',fsubsts') = aux (fdefs,[],empty_hashmap (),ftable)
          val fexp' = lsubst (fsubsts',fexp)
        in
          (* pass original top-level table value back to next (potentially)
          top-level call to aux *)
          aux (rest,(v,info,FUNCTOR(arg,name,(fdefs',fexp')))::acc,substs,table)
        end
    val (defs',substs') = aux (defs,[],empty_hashmap (),top_level_table)
    val exp' = lsubst (substs',exp)
  in
    (defs',exp')
  end


fun is_imperative (APP (BUILTIN builtin,_,_)) =
  (case builtin of
     Pervasives.SUB => true
   | Pervasives.UNSAFE_SUB => true
   | Pervasives.BYTEARRAY_SUB => true
   | Pervasives.BYTEARRAY_UNSAFE_SUB => true
   | Pervasives.DEREF => true
   | _ => false)
  | is_imperative _ = false

fun new_imp_env (e,imp_table) =
  (* Note, e is simple but unsafe and not an imperative dereference *)
  (* This does some clever stuff for keeping track of the values in references *)
  (empty_exp_table imp_table;
   case e of
     APP (BUILTIN Pervasives.UNSAFE_UPDATE, ([r,i,VAR x],[]),_) =>
       let
         val e = APP (BUILTIN Pervasives.UNSAFE_SUB, ([r,i],[]),NONE)
       in
         exp_add (e,x,imp_table);
         SOME e
       end
   (* Be nice to deal with setting to non variables *)
   | APP (BUILTIN Pervasives.BECOMES, ([r,VAR x],[]),_) =>
       let
         val e = APP (BUILTIN Pervasives.DEREF, ([r],[]),NONE)
       in
         exp_add (e,x,imp_table);
         SOME e
       end
   | _ => NONE)

(* imp_env contains a list of bindings var -> store reference *)
(* When the store is updated, imp_env is modified to reflect the value *)
(* stored.  Other operations that may modify the store set it to nil *)
fun local_cse exp =
  let
    val table = make_exp_table ()
    val imp_table = make_exp_table ()
    fun do_let (LET ((x,i,e1),e2),substs,acc) =
      let
        val e1' = lsubst (substs,e1)
      in
        if SimpleUtils.is_simple e1'
          then
            if SimpleUtils.safe_cse e1'
              then
                case exp_lookup (e1',table) of
                  SOME x' => 
                    (diag (1, fn () => "Found CSE: " ^ LambdaPrint.print_exp e1' ^ "\n");
                     IntHashTable.update (substs,x,VAR x');
                     do_let (e2,substs,(x,i,VAR x')::acc))
                | NONE => 
                    let
                      val _ = exp_add (e1',x,table)
                      val result = do_let (e2,substs,(x,i,e1')::acc)
                      val _ = exp_remove (e1',table)
                    in
                      result
                    end
            (* Is it a reference to the store *)
            else if do_imperative_cse andalso is_imperative e1'
              then
                case exp_lookup (e1',imp_table) of
                  SOME x' => 
                    (diag (2, fn () => "Found imperative CSE: " ^ LambdaPrint.print_exp e1' ^ "\n");
                     IntHashTable.update (substs,x,VAR x');
                     do_let (e2,substs,(x,i,VAR x')::acc))
                | NONE => 
                    let
                      val _ = exp_add (e1',x,imp_table)
                      val result = do_let (e2,substs,(x,i,e1')::acc)
                      val _ = exp_remove (e1',imp_table)
                    in
                      result
                    end
            else 
              (* should remove these bindings also *)
              let
                val e = new_imp_env (e1',imp_table)
                val result = do_let (e2,substs,(x,i,e1')::acc)
                val _ = 
                  case e of
                    SOME e' => exp_remove (e',imp_table)
                  | _ => ()
              in
                result
              end
        else
          (* For a complex expression, give up on imperative stuff in body *)
          (empty_exp_table imp_table;
           do_let (e2,substs,(x,i,do_complex (e1',substs))::acc))
      end
      | do_let (e,substs,acc) =
        wrap_lets (acc,do_complex (e,substs))
    and do_complex (SWITCH (e,info,tel,opte),substs) =
      let
        val e' = lsubst (substs,e)
        val e'' =
          if SimpleUtils.is_simple e' andalso SimpleUtils.safe_cse e'
            then
              case exp_lookup (e',table) of
                SOME x => VAR x
              | _ => e'
          else e'
      in
        SWITCH (e'',
                info,
                map (telfun (fn e => do_let (e,substs,[]))) tel,
                optfun (fn e => do_let (e,substs,[])) opte)
      end
      | do_complex (HANDLE (e1,e2,s),substs) =
      (empty_exp_table imp_table;
       HANDLE (do_let (e1,substs,[]),do_let (e2,substs,[]),s))
      | do_complex (FN (f,e,v,n,t,d),substs) =
      (empty_exp_table imp_table;
       FN (f,do_let (e,substs,[]),v,n,t,d))
      | do_complex (LETREC (fl,el,e),substs) =
      (empty_exp_table imp_table;
       LETREC (fl,map (fn e => do_let (e,substs,[])) el,do_let (e,substs,[])))
      | do_complex (LET _,substs) = crash "LET in do_complex in CSE"
      | do_complex (e1,substs) =
        let
          val e1' = lsubst (substs,e1)
        in
          if SimpleUtils.is_simple e1'
            then
              if SimpleUtils.safe_cse e1'
                then
                  case exp_lookup (e1',table) of
                    SOME x' => 
                      (diag (1, fn () => "Found CSE: " ^ LambdaPrint.print_exp e1' ^ "\n");
                       VAR x')
                | NONE => e1'
            (* Is it a reference to the store *)
            else if do_imperative_cse andalso is_imperative e1'
              then
                case exp_lookup (e1',imp_table) of
                  SOME x' => 
                    (diag (1, fn () => "Found imperative CSE: " ^ LambdaPrint.print_exp e1' ^ "\n");
                     VAR x')
                | NONE => e1'
            else e1'
          else e1'
        end
    val result = do_let (exp,empty_hashmap (),[])
  in
    result
  end

val local_cse_all = progmap (elim_simple_bindings o local_cse)

(* This is really to get rid of eta reducible functions *)
fun elim_global_simple_bindings (defs,exp) =
  let
    val max_iterations = 100
    val substs = empty_hashmap ()
    (* Collect all the substitutions in substs *)
    fun aux ([],acc) = rev acc
      | aux ((v,info,VAL e) :: l,acc) =
        (* Eliminate atomic bindings *)
	if is_absent info then
	  if SimpleUtils.is_atomic e then
	    (* We can substitute and discard *)
            (IntHashTable.update (substs,v,e);
             diag (2,fn () => "Eliminating global " ^ LambdaPrint.print_var v ^ "\n");
             aux (l,acc))
	  else
	    (* Ok, see if it's a simple tail call of its own argument *)
	    (case e of
	       FN(([x],[]), APP(e' as VAR _, ([VAR y], []), _), _, _, _, _) =>
		 ((if x = y then
		     (IntHashTable.update (substs,v,e');
		      diag (2,fn () => "Eliminating global " ^ LambdaPrint.print_var v ^ "\n"))
		   else
		     ());
		     (* Note, we don't necessarily eliminate here *)
		     (* we let a later stage do that *)
		     (* This is because we are looking at a function *)
		     (* which may already have been referenced above *)
		     aux (l,(v,info,VAL e)::acc))
	     | _ => aux (l,(v,info,VAL e)::acc))
	else
          aux (l,(v,info,VAL e)::acc)
      | aux ((v,info,FUNCTOR(arg,name,(defs,exp))) :: rest,acc) =
        let
          val defs' = aux (defs,[])
        in
          aux (rest,(v,info,FUNCTOR (arg,name,(defs',exp)))::acc)
        end
    (* Lookup chains of bindings *)
    fun lookup (exp as VAR x,n) =
      if n > max_iterations
        (* This really indicates an infinite loop in user code *)
        then exp  (* crash "Too many iterations of eta lookup" *)
      else
        (case hashmap_find (x,substs) of
           SOME e => 
             (case e of
                VAR _ => lookup (e,n+1)
              | _ => e)
         | NONE => exp)
      | lookup (exp,n) = exp
    val defs' = aux (defs,[])
    (* Make a proper substution table *)
    val fullsubsts = IntHashTable.map (fn (x,e) => lookup (e,0)) substs
    (* and apply to the trimmed definitions *)
    fun subfun e = lsubst (fullsubsts,e)
  in
    progmap subfun (defs',exp)
  end

val schedule_all = progmap SimpleUtils.schedule

fun inline_single_callees (do_lifting,prog) = weed (internal_inline_single_callees (do_lifting,prog))

fun global_cleanup prog =
  let
    val prog = if do_cse then global_cse prog else prog
    val _ = pprint (2,prog)
    val _ = diag (1, fn () => "Eta elim..\n")
  in
    weed(elim_global_simple_bindings prog)
  end

fun optimise options e =
  let
    val Options.OPTIONS {compiler_options,...} = options
    val Options.COMPILEROPTIONS {generate_debug_info,
                                 local_functions,
                                 opt_self_calls,
                                 intercept,
                                 debug_variables,
                                 generate_moduler,...} = compiler_options
    (* If we are doing any of these complex things, then do only simple optimizations *)
    (* Keep the corresponding code in mir/_mir_cg#mir_cg consistent with this *)
    val do_debug = generate_moduler
    (* Do full optimization only if no debug options set *)
    val do_full = not do_debug andalso not generate_debug_info andalso not debug_variables andalso not intercept
    val do_local_functions = do_full andalso local_functions

    val _ = 
      diag (1,fn () => 
            if do_full then "Full Optimization\n"
            else if do_debug then "Debug Optimization\n"
            else "Simple Optimization\n")

    (* It would be nice have a better structure for specifying which optimizations *)
    (* take place at which debug levels *)

    fun make_lamb e =
      let
        val _ = diag (1,fn () => "Linearizing..\n")
        val e = linearize e
        val _ = pprint_exp (2,e)

        val e =
          if not do_debug
            then
              (diag (1,fn () => "Optimizing..\n");
               simplify_exp (e, do_full))
          else e

        val _ = diag (1,fn () => "Cleaning up..\n")
        val e = cleanup e
        val _ = pprint_exp (2,e)

        val _ = diag (1,fn () => "Globalizing..\n")
        val e = globalize (e,[],[],false)
        val _ = pprint_exp (2,e)

        val prog =
          if do_full
            then
              let
                val e = if do_local_functions 
                          then (diag (1, fn () => "Preanalyse\n");
                                let 
                                  val _ = pprint_exp (0,e)
                                  val e = LambdaFlow.preanalyse e
                                in
                                  pprint_exp (0,e);
                                  cleanup (simplify_exp (e,do_full))
                                end)
                        else e
                val _ = pprint_exp (0,e)
                val _ = diag (1,fn () => "Transforming..\n")
                val (e,defs) = Timer.xtime ("Transforming",
                                            !print_timings,
                                            fn () => (transform (e,[],[],true)))
                (* Is this phase necessary? *)
                val _ = diag (1,fn () => "Linearizing..\n")
                val prog = progmap SimpleUtils.linearize (rev defs,e)
                val _ = pprint (2,prog)
                val _ = diag (1,fn () => "Optimizing..\n")
                val prog = simplify_till_done (prog,do_full)
              in
                prog
              end
          else globify ([],e)

        val _ = diag (1,fn () => "Inlining single callees..\n")

        (* This linearize is necessary, but we don't need elim_simple_bindings *)
        val prog = 
          if do_full
            then progmap SimpleUtils.linearize (inline_single_callees (do_full,prog))
          else prog

        (* Should structure this stuff a little more *)
        val prog =
          if not do_debug
            then
              let
                val _ = diag (1,fn () => "Optimizing..\n")
                val prog = simplify_till_done (prog,do_full)
                val _ = pprint (2,prog)
              in
                prog
              end
          else
            prog

        val prog = 
          if do_cse 
            then
              let 
                val _ = diag (1, fn () => "Doing Local CSE..\n")
                val prog = local_cse_all prog
                val _ = pprint (2,prog)
              in
                prog
              end
          else prog
            
        (* Some of this could be done with debugging on *)
        val prog =
          if not do_debug
            then
              let
                val _ = diag (1,fn () => "Optimizing..\n")
                val prog = simplify_till_done (prog,do_full)
                val _ = pprint (2,prog)
              in
                prog
              end
          else
            prog

        val _ = diag (1, fn () => "Doing Global Cleanup..\n")
        val prog = global_cleanup prog
        val _ = pprint (2,prog)
        val prog = 
          if not do_debug
            then
              (diag (1, fn () => "Doing Schedule..\n");
               schedule_all prog)
          else prog
        val _ = pprint (2,prog)
        val _ = diag (1, fn () => "Done\n")
        val PROGRAM prog = 
          if do_local_functions 
            then LambdaFlow.tail_convert (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog = 
          if do_local_functions
            then LambdaFlow.loop_analysis (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog = 
          if do_full 
            then LambdaFlow.findfpargs (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog = 
          if do_local_functions 
            then LambdaFlow.lift_locals (PROGRAM prog) else PROGRAM prog
      in
        prog
      end                           
    val prog = 
      Timer.xtime ("Inner lambda",!print_timings,fn () => make_lamb e)
  in
    if print_result then print (LambdaPrint.pds (PROGRAM prog) ^ "\n") else ();
    TransSimple.trans_program (PROGRAM prog)
  end

val optimise = fn options => fn e =>
  let
    val Options.OPTIONS {compiler_options,...} = options
    val Options.COMPILEROPTIONS 
         {generate_debug_info, debug_variables, generate_moduler,
          intercept, interrupt, opt_handlers, opt_leaf_fns, opt_tail_calls,
          opt_self_calls, local_functions, ...} = compiler_options
  in 
    if generate_debug_info orelse debug_variables orelse generate_moduler 
    orelse intercept orelse interrupt orelse opt_handlers orelse opt_leaf_fns 
    orelse opt_tail_calls orelse opt_self_calls orelse local_functions
    then optimise options e
    else e (* Don't bother optimising 
              - probably a trivial bit of code for the "history" *)
  end;

(* This is used to simplify expressions in polymorphic equality *)
fun simple_beta_reduce e =
  TransSimple.trans_program
  (PROGRAM ([],cleanup (simplify_exp (linearize e,false))))

end
@


1.50.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.50  1998/11/26  12:11:48  mitchell
 * [Bug #190493]
 * Don't bother optimising & tracing code generated by the history mechanism
 *
@


1.49
log
@[Bug #190491]
Fix constant switch optimisation bug for lists
@
text
@d3 4
d2806 16
@


1.48
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d3 4
d1746 31
@


1.47
log
@[Bug #30326]
Merge in Project Workspace changes.
@
text
@d3 4
d534 1
a534 1
         optfun aux opte;
d2044 1
a2044 1
         optfun aux opte;
@


1.46
log
@[Bug #30089]
Modify TIMER (from utils) to be INTERNAL_TIMER to keep bootstrap happy
@
text
@d3 4
d10 5
d166 1
a166 1
require "../utils/timer";
@


1.45
log
@[Bug #30153]
Remove references to Old.
@
text
@d3 4
d173 1
a173 1
                      structure Timer : TIMER
@


1.44
log
@[Bug #30184]
Fixing interaction of global CSE with functors in same compilation unit
@
text
@d3 4
a162 1
require "^.basis.__old";
d1270 2
a1271 1
      | scon_to_bignum(Ident.CHAR s) = Bignum.int_to_bignum(Old.ord s)
d1292 1
a1292 1
        (SOME (make_int_scon (Old.ord s,Location.UNKNOWN)) 
@


1.44.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.44  1997/08/01  17:37:05  jkbrook
 * [Bug #30184]
 * Fixing interaction of global CSE with functors in same compilation unit
 *
@


1.44.2.2
log
@[Bug #30326]
@
text
@a2 3
 * Revision 1.44.2.1  1997/09/11  20:55:14  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d153 1
a153 1
require "../utils/mlworks_timer";
@


1.44.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.44  1997/08/01  17:37:05  jkbrook
 * [Bug #30184]
 * Fixing interaction of global CSE with functors in same compilation unit
 *
@


1.43
log
@[Bug #30186]
Added note about compiler option consistency with _mir_cg
@
text
@d3 4
d2310 3
d2315 3
a2317 3
    val table = make_exp_table ()
    fun aux ([],acc,substs) = (rev acc,substs)
      | aux ((v,info,VAL (FN(args,e,s,n,t,d))) :: l,acc,substs) =
d2321 1
a2321 1
          aux (l,(v,info,VAL (FN(args,e',s,n,t,d)))::acc,substs)
d2323 2
a2324 2
      | aux ((v,info,VAL e) :: l,acc,substs) =
        let 
d2329 1
a2329 2
            then aux (l,(v,info,VAL e')::acc,substs)

d2333 2
a2334 1
                (diag (3, fn () => "CSE of " ^ LambdaPrint.print_var v ^ " = " ^ LambdaPrint.print_exp e' ^ "\n");
d2336 3
a2338 3
                 aux (l,acc,substs))
            | NONE => 
                if SimpleUtils.safe e' 
d2341 1
a2341 1
                     aux (l,(v,info,VAL e')::acc,substs))
d2343 1
a2343 1
                  aux (l,(v,info,VAL e')::acc,substs)
d2345 1
a2345 1
      | aux ((v,info,FUNCTOR(arg,name,(defs,exp))) :: rest,acc,substs) =
d2347 6
a2352 2
          val (defs',substs') = aux (defs,[],substs)
          val exp' = lsubst (substs',exp)
d2354 3
a2356 1
          aux (rest,(v,info,FUNCTOR (arg,name,(defs',exp')))::acc,substs)
d2358 1
a2358 1
    val (defs',substs') = aux (defs,[],empty_hashmap ())
d2363 1
@


1.42
log
@Loop optimizations
@
text
@d3 3
d2586 1
@


1.41
log
@Improving interaction between local functions and FP args
@
text
@d3 3
d1471 1
a1471 1
fun simplify (e,env,changed,depth) =
d1504 2
a1505 1
                 if depth <= max_depth andalso 
d1805 3
d1842 1
a1842 1
fun simplify_exp e = simplify (e,empty_hashmap (),ref false,0)
d2233 1
a2233 1
fun simplify_all (prog,env,depth) =
d2240 2
a2241 2
          FN (vl,simplify (body,env,changed,depth),status,name,ty,debug)
          | doval e = simplify (e,env,changed,depth)
d2254 1
a2254 1
         simplify (exp,env,changed,depth))
d2261 1
a2261 1
fun simplify_till_done (prog as (declist,exp)) =
d2268 1
a2268 1
        val (changed,prog') = simplify_all (prog,env,n)
d2607 1
a2607 1
               simplify_exp (e))
d2629 1
a2629 1
                                  cleanup (simplify_exp (e))
d2642 1
a2642 1
                val prog = simplify_till_done (prog)
d2662 1
a2662 1
                val prog = simplify_till_done (prog)
d2688 1
a2688 1
                val prog = simplify_till_done (prog)
d2709 4
a2712 1
            then LambdaFlow.postanalyse (PROGRAM prog) else PROGRAM prog
d2716 3
d2732 1
a2732 1
  (PROGRAM ([],cleanup (simplify_exp (linearize e))))
@


1.40
log
@Improving treatment of array indexing
@
text
@d3 3
d137 1
d162 1
d314 7
a320 28
  fun lsubst (binds,e) =
    let
      fun aux (e as INT _) = e
        | aux (e as SCON _) = e
        | aux (e as MLVALUE _) = e
        | aux (e as BUILTIN _) = e
        | aux (e as VAR v) =
          (case hashmap_find (v,binds) of
             SOME e' => e'
           | NONE => e)
        | aux (APP (e,(el,fpel),ty)) = APP (aux e,(map aux el,map aux fpel), ty)
        | aux (FN (args,e,status,name,ty,info)) = FN (args,aux e,status,name,ty,info)
        | aux (LETREC (fl,el,e)) =
          LETREC (fl,map aux el,aux e)
        | aux (STRUCT (el,ty)) = STRUCT (map aux el,ty)
        | aux (SWITCH (e,info,tel,opte)) =
          SWITCH (aux e, 
                  info,
                  map (telfun aux) tel,
                  optfun aux opte)
        | aux (HANDLE (e1,e2,s)) = HANDLE(aux e1,aux e2,s)
        | aux (RAISE e) = RAISE (aux e)
        | aux (SELECT (info,e)) = SELECT (info,aux e)
        | aux (LET ((v,i,e1),e2)) =
          LET((v,i,aux e1),aux e2)
    in
      aux e
    end
a322 1

d688 1
a688 1
(* This doesn't seem to acheive much, and I am not sure that it is correct *)
d2273 23
d2298 3
a2300 5
    fun find_def (e,[]) = NONE
      | find_def (e,(v,e')::rest) = 
        if SimpleUtils.exp_eq (e,e') then SOME v else find_def (e,rest)
    fun aux ([],acc,substs,env) = (rev acc,substs)
      | aux ((v,info,VAL (FN(args,e,s,n,t,d))) :: l,acc,substs,env) =
d2304 1
a2304 1
          aux (l,(v,info,VAL (FN(args,e',s,n,t,d)))::acc,substs,env)
d2306 1
a2306 1
      | aux ((v,info,VAL e) :: l,acc,substs,env) =
d2311 3
a2313 2
          if SimpleUtils.is_atomic e'
            then aux (l,(v,info,VAL e')::acc,substs,env)
d2315 1
a2315 1
            case find_def (e',env) of
d2319 1
a2319 1
                 aux (l,acc,substs,env))
d2323 2
a2324 1
                    aux (l,(v,info,VAL e')::acc,substs,(v,e')::env)
d2326 1
a2326 1
                  aux (l,(v,info,VAL e')::acc,substs,env)
d2328 1
a2328 1
      | aux ((v,info,FUNCTOR(arg,name,(defs,exp))) :: rest,acc,substs,env) =
d2330 1
a2330 1
          val (defs',substs') = aux (defs,[],substs,env)
d2333 1
a2333 1
          aux (rest,(v,info,FUNCTOR (arg,name,(defs',exp')))::acc,substs,env)
d2335 1
a2335 1
    val (defs',substs') = aux (defs,[],empty_hashmap (),[])
d2351 1
a2351 1
fun new_imp_env (e,imp_env) =
d2354 18
a2371 7
  case e of
    APP (BUILTIN Pervasives.UNSAFE_UPDATE, ([r,i,VAR x],[]),_) =>
      [(x,APP (BUILTIN Pervasives.UNSAFE_SUB, ([r,i],[]),NONE))]
  (* Be nice to deal with setting to non variables *)
  | APP (BUILTIN Pervasives.BECOMES, ([r,VAR x],[]),_) =>
      [(x,APP (BUILTIN Pervasives.DEREF, ([r],[]),NONE))]
  | _ => []
d2378 3
a2380 4
    fun find_def (e,[]) = NONE
      | find_def (e,(v,e')::rest) = 
        if SimpleUtils.exp_eq (e,e') then SOME v else find_def (e,rest)
    fun do_let (LET ((x,i,e1),e2),env,imp_env,substs,acc) =
d2388 1
a2388 1
                case find_def (e1',env) of
d2392 9
a2400 2
                     do_let (e2,env,imp_env,substs,(x,i,VAR x')::acc))
                | NONE => do_let (e2,(x,e1')::env,imp_env,substs,(x,i,e1')::acc)
d2404 1
a2404 1
                case find_def (e1',imp_env) of
d2408 21
a2428 3
                     do_let (e2,env,imp_env,substs,(x,i,VAR x')::acc))
                | NONE => do_let (e2,env,(x,e1')::imp_env,substs,(x,i,e1')::acc)
            else do_let (e2,env,new_imp_env (e1',imp_env),substs,(x,i,e1')::acc)
d2431 2
a2432 1
          do_let (e2,env,[],substs,(x,i,do_complex (e1',env,imp_env,substs))::acc)
d2434 3
a2436 3
      | do_let (e,env,imp_env,substs,acc) =
        wrap_lets (acc,do_complex (e,env,imp_env,substs))
    and do_complex (SWITCH (e,info,tel,opte),env,imp_env,substs) =
d2442 1
a2442 1
              case find_def (e',env) of
d2444 1
a2444 1
                  | _ => e'
d2449 2
a2450 2
                map (telfun (fn e => do_let (e,env,imp_env,substs,[]))) tel,
                optfun (fn e => do_let (e,env,imp_env,substs,[])) opte)
d2452 11
a2462 8
      | do_complex (HANDLE (e1,e2,s),env,imp_env,substs) =
        HANDLE (do_let (e1,env,imp_env,substs,[]),do_let (e2,env,[],substs,[]),s)
      | do_complex (FN (f,e,v,n,t,d),env,imp_env,substs) =
        FN (f,do_let (e,env,[],substs,[]),v,n,t,d)
      | do_complex (LETREC (fl,el,e),env,imp_env,substs) =
        LETREC (fl,map (fn e => do_let (e,env,[],substs,[])) el,do_let (e,env,imp_env,substs,[]))
      | do_complex (LET _,env,imp_env,substs) = crash "LET in do_complex in CSE"
      | do_complex (e1,env,imp_env,substs) =
d2470 1
a2470 1
                  case find_def (e1',env) of
d2478 1
a2478 1
                case find_def (e1',imp_env) of
d2486 1
a2486 1
    val result = do_let (exp,[],[],empty_hashmap (),[])
d2559 1
a2559 1
    val prog = global_cse prog
d2579 1
a2594 3
        val _ = diag (1,fn () => "Globalizing..\n")
        val e = globalize (e,[],[],false)
        val _ = pprint_exp (2,e)
d2600 1
a2600 1
               simplify_exp e)
d2606 5
d2615 1
a2615 1
                val e = if local_functions 
d2622 1
a2622 1
                                  cleanup (simplify_exp e)
d2635 1
a2635 1
                val prog = simplify_till_done prog
d2644 4
a2647 1
        val prog = progmap SimpleUtils.linearize (inline_single_callees (do_full,prog))
d2655 1
a2655 1
                val prog = simplify_till_done prog
d2681 1
a2681 1
                val prog = simplify_till_done prog
d2701 5
a2705 5
          if do_full andalso local_functions then LambdaFlow.postanalyse (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog =
          if do_full then 
            LambdaFlow.findfpargs (PROGRAM prog)
          else PROGRAM prog
@


1.40.1.1
log
@branched from 1.40
@
text
@a2 3
 * Revision 1.40  1997/02/12  14:24:18  matthew
 * Improving treatment of array indexing
 *
@


1.40.1.2
log
@[Bug #20036]
Use hash tables instead of assoc lists for doing CSE.
@
text
@a2 7
 *
 * Revision 1.40.1.1  1997/05/12  10:34:33  hope
 * branched from 1.40
 *
 * Revision 1.41  1997/05/09  11:57:05  matthew
 * Improving interaction between local functions and FP args
 *
a136 1
require "../utils/hashtable";
a160 1
                      structure HashTable : HASHTABLE
d312 28
a339 7
  fun lsubst (binds,e) = 
    SimpleUtils.subst 
    (fn v =>
     case hashmap_find (v,binds) of
       SOME e => e
     | NONE => VAR v,
     e)
d342 1
d708 1
a708 1
(* This doesn't seem to achieve much, and I am not sure that it is correct *)
a2292 23
(* This should only be called on simple expressions, hence the Crash.impossible *)
fun exp_hash (VAR v) = v
  | exp_hash (APP (e1,(el,fpel),_)) = 7 * exp_hash e1
  | exp_hash (SCON (s,_)) = 91
  | exp_hash (INT n) = 1001 + n
  | exp_hash (STRUCT (el,ty)) = elist_hash el
  | exp_hash (SELECT (_,e)) = 10001 + exp_hash e
  | exp_hash (BUILTIN b) = 100001
  | exp_hash (MLVALUE _) = 200001
  | exp_hash _ = Crash.impossible "exp_hash"
and elist_hash [] = 2001
  | elist_hash (a::b) = exp_hash a + elist_hash b

fun make_exp_table () =
  ref (HashTable.new (16,SimpleUtils.exp_eq,exp_hash))
fun empty_exp_table table =
  table := HashTable.new (16,SimpleUtils.exp_eq,exp_hash)
fun exp_add (e,v,table) =
  HashTable.update (!table,e,v)
fun exp_remove (e,table) =
  HashTable.delete (!table,e)
fun exp_lookup (e,table) =
  HashTable.tryLookup (!table,e)
d2295 5
a2299 3
    val table = make_exp_table ()
    fun aux ([],acc,substs) = (rev acc,substs)
      | aux ((v,info,VAL (FN(args,e,s,n,t,d))) :: l,acc,substs) =
d2303 1
a2303 1
          aux (l,(v,info,VAL (FN(args,e',s,n,t,d)))::acc,substs)
d2305 1
a2305 1
      | aux ((v,info,VAL e) :: l,acc,substs) =
d2310 2
a2311 3
          if SimpleUtils.is_atomic e' orelse not (SimpleUtils.is_simple e')
            then aux (l,(v,info,VAL e')::acc,substs)

d2313 1
a2313 1
            case exp_lookup (e',table) of
d2317 1
a2317 1
                 aux (l,acc,substs))
d2321 1
a2321 2
                    (exp_add (e',v,table);
                     aux (l,(v,info,VAL e')::acc,substs))
d2323 1
a2323 1
                  aux (l,(v,info,VAL e')::acc,substs)
d2325 1
a2325 1
      | aux ((v,info,FUNCTOR(arg,name,(defs,exp))) :: rest,acc,substs) =
d2327 1
a2327 1
          val (defs',substs') = aux (defs,[],substs)
d2330 1
a2330 1
          aux (rest,(v,info,FUNCTOR (arg,name,(defs',exp')))::acc,substs)
d2332 1
a2332 1
    val (defs',substs') = aux (defs,[],empty_hashmap ())
d2348 1
a2348 1
fun new_imp_env (e,imp_table) =
d2351 7
a2357 18
  (empty_exp_table imp_table;
   case e of
     APP (BUILTIN Pervasives.UNSAFE_UPDATE, ([r,i,VAR x],[]),_) =>
       let
         val e = APP (BUILTIN Pervasives.UNSAFE_SUB, ([r,i],[]),NONE)
       in
         exp_add (e,x,imp_table);
         SOME e
       end
   (* Be nice to deal with setting to non variables *)
   | APP (BUILTIN Pervasives.BECOMES, ([r,VAR x],[]),_) =>
       let
         val e = APP (BUILTIN Pervasives.DEREF, ([r],[]),NONE)
       in
         exp_add (e,x,imp_table);
         SOME e
       end
   | _ => NONE)
d2364 4
a2367 3
    val table = make_exp_table ()
    val imp_table = make_exp_table ()
    fun do_let (LET ((x,i,e1),e2),substs,acc) =
d2375 1
a2375 1
                case exp_lookup (e1',table) of
d2379 2
a2380 9
                     do_let (e2,substs,(x,i,VAR x')::acc))
                | NONE => 
                    let
                      val _ = exp_add (e1',x,table)
                      val result = do_let (e2,substs,(x,i,e1')::acc)
                      val _ = exp_remove (e1',table)
                    in
                      result
                    end
d2384 1
a2384 1
                case exp_lookup (e1',imp_table) of
d2388 3
a2390 21
                     do_let (e2,substs,(x,i,VAR x')::acc))
                | NONE => 
                    let
                      val _ = exp_add (e1',x,imp_table)
                      val result = do_let (e2,substs,(x,i,e1')::acc)
                      val _ = exp_remove (e1',imp_table)
                    in
                      result
                    end
            else 
              (* should remove these bindings also *)
              let
                val e = new_imp_env (e1',imp_table)
                val result = do_let (e2,substs,(x,i,e1')::acc)
                val _ = 
                  case e of
                    SOME e' => exp_remove (e',imp_table)
                  | _ => ()
              in
                result
              end
d2393 1
a2393 2
          (empty_exp_table imp_table;
           do_let (e2,substs,(x,i,do_complex (e1',substs))::acc))
d2395 3
a2397 3
      | do_let (e,substs,acc) =
        wrap_lets (acc,do_complex (e,substs))
    and do_complex (SWITCH (e,info,tel,opte),substs) =
d2403 1
a2403 1
              case exp_lookup (e',table) of
d2405 1
a2405 1
              | _ => e'
d2410 2
a2411 2
                map (telfun (fn e => do_let (e,substs,[]))) tel,
                optfun (fn e => do_let (e,substs,[])) opte)
d2413 8
a2420 11
      | do_complex (HANDLE (e1,e2,s),substs) =
      (empty_exp_table imp_table;
       HANDLE (do_let (e1,substs,[]),do_let (e2,substs,[]),s))
      | do_complex (FN (f,e,v,n,t,d),substs) =
      (empty_exp_table imp_table;
       FN (f,do_let (e,substs,[]),v,n,t,d))
      | do_complex (LETREC (fl,el,e),substs) =
      (empty_exp_table imp_table;
       LETREC (fl,map (fn e => do_let (e,substs,[])) el,do_let (e,substs,[])))
      | do_complex (LET _,substs) = crash "LET in do_complex in CSE"
      | do_complex (e1,substs) =
d2428 1
a2428 1
                  case exp_lookup (e1',table) of
d2436 1
a2436 1
                case exp_lookup (e1',imp_table) of
d2444 1
a2444 1
    val result = do_let (exp,empty_hashmap (),[])
d2517 1
a2517 1
    val prog = if do_cse then global_cse prog else prog
a2536 1
    val do_local_functions = do_full andalso local_functions
d2552 3
d2560 1
a2560 1
               simplify_exp (e))
a2565 5

        val _ = diag (1,fn () => "Globalizing..\n")
        val e = globalize (e,[],[],false)
        val _ = pprint_exp (2,e)

d2570 1
a2570 1
                val e = if do_local_functions 
d2577 1
a2577 1
                                  cleanup (simplify_exp (e))
d2590 1
a2590 1
                val prog = simplify_till_done (prog)
d2599 1
a2599 4
        val prog = 
          if do_full
            then progmap SimpleUtils.linearize (inline_single_callees (do_full,prog))
          else prog
d2607 1
a2607 1
                val prog = simplify_till_done (prog)
d2633 1
a2633 1
                val prog = simplify_till_done (prog)
d2653 5
a2657 5
          if do_local_functions 
            then LambdaFlow.postanalyse (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog = 
          if do_full 
            then LambdaFlow.findfpargs (PROGRAM prog) else PROGRAM prog
@


1.40.1.3
log
@[Bug #20036]
Undid previous merge.
@
text
@d3 7
d144 1
d169 1
d321 7
a327 28
  fun lsubst (binds,e) =
    let
      fun aux (e as INT _) = e
        | aux (e as SCON _) = e
        | aux (e as MLVALUE _) = e
        | aux (e as BUILTIN _) = e
        | aux (e as VAR v) =
          (case hashmap_find (v,binds) of
             SOME e' => e'
           | NONE => e)
        | aux (APP (e,(el,fpel),ty)) = APP (aux e,(map aux el,map aux fpel), ty)
        | aux (FN (args,e,status,name,ty,info)) = FN (args,aux e,status,name,ty,info)
        | aux (LETREC (fl,el,e)) =
          LETREC (fl,map aux el,aux e)
        | aux (STRUCT (el,ty)) = STRUCT (map aux el,ty)
        | aux (SWITCH (e,info,tel,opte)) =
          SWITCH (aux e, 
                  info,
                  map (telfun aux) tel,
                  optfun aux opte)
        | aux (HANDLE (e1,e2,s)) = HANDLE(aux e1,aux e2,s)
        | aux (RAISE e) = RAISE (aux e)
        | aux (SELECT (info,e)) = SELECT (info,aux e)
        | aux (LET ((v,i,e1),e2)) =
          LET((v,i,aux e1),aux e2)
    in
      aux e
    end
a329 1

d695 1
a695 1
(* This doesn't seem to acheive much, and I am not sure that it is correct *)
d2280 23
d2305 3
a2307 5
    fun find_def (e,[]) = NONE
      | find_def (e,(v,e')::rest) = 
        if SimpleUtils.exp_eq (e,e') then SOME v else find_def (e,rest)
    fun aux ([],acc,substs,env) = (rev acc,substs)
      | aux ((v,info,VAL (FN(args,e,s,n,t,d))) :: l,acc,substs,env) =
d2311 1
a2311 1
          aux (l,(v,info,VAL (FN(args,e',s,n,t,d)))::acc,substs,env)
d2313 1
a2313 1
      | aux ((v,info,VAL e) :: l,acc,substs,env) =
d2318 3
a2320 2
          if SimpleUtils.is_atomic e'
            then aux (l,(v,info,VAL e')::acc,substs,env)
d2322 1
a2322 1
            case find_def (e',env) of
d2326 1
a2326 1
                 aux (l,acc,substs,env))
d2330 2
a2331 1
                    aux (l,(v,info,VAL e')::acc,substs,(v,e')::env)
d2333 1
a2333 1
                  aux (l,(v,info,VAL e')::acc,substs,env)
d2335 1
a2335 1
      | aux ((v,info,FUNCTOR(arg,name,(defs,exp))) :: rest,acc,substs,env) =
d2337 1
a2337 1
          val (defs',substs') = aux (defs,[],substs,env)
d2340 1
a2340 1
          aux (rest,(v,info,FUNCTOR (arg,name,(defs',exp')))::acc,substs,env)
d2342 1
a2342 1
    val (defs',substs') = aux (defs,[],empty_hashmap (),[])
d2358 1
a2358 1
fun new_imp_env (e,imp_env) =
d2361 18
a2378 7
  case e of
    APP (BUILTIN Pervasives.UNSAFE_UPDATE, ([r,i,VAR x],[]),_) =>
      [(x,APP (BUILTIN Pervasives.UNSAFE_SUB, ([r,i],[]),NONE))]
  (* Be nice to deal with setting to non variables *)
  | APP (BUILTIN Pervasives.BECOMES, ([r,VAR x],[]),_) =>
      [(x,APP (BUILTIN Pervasives.DEREF, ([r],[]),NONE))]
  | _ => []
d2385 3
a2387 4
    fun find_def (e,[]) = NONE
      | find_def (e,(v,e')::rest) = 
        if SimpleUtils.exp_eq (e,e') then SOME v else find_def (e,rest)
    fun do_let (LET ((x,i,e1),e2),env,imp_env,substs,acc) =
d2395 1
a2395 1
                case find_def (e1',env) of
d2399 9
a2407 2
                     do_let (e2,env,imp_env,substs,(x,i,VAR x')::acc))
                | NONE => do_let (e2,(x,e1')::env,imp_env,substs,(x,i,e1')::acc)
d2411 1
a2411 1
                case find_def (e1',imp_env) of
d2415 21
a2435 3
                     do_let (e2,env,imp_env,substs,(x,i,VAR x')::acc))
                | NONE => do_let (e2,env,(x,e1')::imp_env,substs,(x,i,e1')::acc)
            else do_let (e2,env,new_imp_env (e1',imp_env),substs,(x,i,e1')::acc)
d2438 2
a2439 1
          do_let (e2,env,[],substs,(x,i,do_complex (e1',env,imp_env,substs))::acc)
d2441 3
a2443 3
      | do_let (e,env,imp_env,substs,acc) =
        wrap_lets (acc,do_complex (e,env,imp_env,substs))
    and do_complex (SWITCH (e,info,tel,opte),env,imp_env,substs) =
d2449 1
a2449 1
              case find_def (e',env) of
d2451 1
a2451 1
                  | _ => e'
d2456 2
a2457 2
                map (telfun (fn e => do_let (e,env,imp_env,substs,[]))) tel,
                optfun (fn e => do_let (e,env,imp_env,substs,[])) opte)
d2459 11
a2469 8
      | do_complex (HANDLE (e1,e2,s),env,imp_env,substs) =
        HANDLE (do_let (e1,env,imp_env,substs,[]),do_let (e2,env,[],substs,[]),s)
      | do_complex (FN (f,e,v,n,t,d),env,imp_env,substs) =
        FN (f,do_let (e,env,[],substs,[]),v,n,t,d)
      | do_complex (LETREC (fl,el,e),env,imp_env,substs) =
        LETREC (fl,map (fn e => do_let (e,env,[],substs,[])) el,do_let (e,env,imp_env,substs,[]))
      | do_complex (LET _,env,imp_env,substs) = crash "LET in do_complex in CSE"
      | do_complex (e1,env,imp_env,substs) =
d2477 1
a2477 1
                  case find_def (e1',env) of
d2485 1
a2485 1
                case find_def (e1',imp_env) of
d2493 1
a2493 1
    val result = do_let (exp,[],[],empty_hashmap (),[])
d2566 1
a2566 1
    val prog = global_cse prog
d2586 1
a2601 3
        val _ = diag (1,fn () => "Globalizing..\n")
        val e = globalize (e,[],[],false)
        val _ = pprint_exp (2,e)
d2607 1
a2607 1
               simplify_exp e)
d2613 5
d2622 1
a2622 1
                val e = if local_functions 
d2629 1
a2629 1
                                  cleanup (simplify_exp e)
d2642 1
a2642 1
                val prog = simplify_till_done prog
d2651 4
a2654 1
        val prog = progmap SimpleUtils.linearize (inline_single_callees (do_full,prog))
d2662 1
a2662 1
                val prog = simplify_till_done prog
d2688 1
a2688 1
                val prog = simplify_till_done prog
d2708 5
a2712 5
          if do_full andalso local_functions then LambdaFlow.postanalyse (PROGRAM prog) else PROGRAM prog
        val PROGRAM prog =
          if do_full then 
            LambdaFlow.findfpargs (PROGRAM prog)
          else PROGRAM prog
@


1.40.1.3.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 4
 * Revision 1.40.1.3  1997/05/15  16:10:37  daveb
 * [Bug #20036]
 * Undid previous merge.
 *
@


1.40.1.3.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 4
 * Revision 1.40.1.3  1997/05/15  16:10:37  daveb
 * [Bug #20036]
 * Undid previous merge.
 *
@


1.40.1.3.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 4
 * Revision 1.40.1.3  1997/05/15  16:10:37  daveb
 * [Bug #20036]
 * Undid previous merge.
 *
@


1.40.1.3.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.40.1.3.1.1  1997/07/28  18:19:51  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.39
log
@Slight improvement to previous change
@
text
@d3 3
d212 5
a216 2
  (* I'm not convinced about these new optimizations yet *)
  val do_imperative_cse = false
a217 1
  val do_loop_functions = false
d1164 6
d1172 28
d1202 36
d1261 2
a1262 2
    fun make_int_scon n =
      SCON (Ident.INT (N n,Location.UNKNOWN), NONE)
d1264 2
a1265 2
    fun make_bignum_scon n =
      SCON (Ident.INT (Bignum.bignum_to_string n,Location.UNKNOWN), NONE)
d1277 4
d1294 2
a1295 2
    fun try_fold (Pervasives.ORD,[SCON (Ident.STRING s, _)]) =
        (SOME (make_int_scon (Old.ord s)) 
d1303 2
a1304 2
      | try_fold (Pervasives.SIZE,[SCON (Ident.STRING s, _)]) =
        SOME (make_int_scon (size s))
d1306 2
a1307 1
        SOME (make_bignum_scon (Bignum.+ (scon_to_bignum n1, scon_to_bignum n2)))
d1309 2
a1310 1
        SOME (make_bignum_scon (Bignum.* (scon_to_bignum n1, scon_to_bignum n2)))
d1312 2
a1313 1
        SOME (make_bignum_scon (Bignum.div (scon_to_bignum n1, scon_to_bignum n2)))
d1315 2
a1316 1
        SOME (make_bignum_scon (Bignum.mod (scon_to_bignum n1, scon_to_bignum n2)))
d1318 2
a1319 1
        SOME (make_bignum_scon (Bignum.- (scon_to_bignum n1, scon_to_bignum n2)))
d1383 4
a1386 2
                            APP (BUILTIN Pervasives.UNSAFEINTPLUS, ([e,make_int_scon n],[]),ty)),
                           SWITCH (APP (BUILTIN Pervasives.WORDLT, ([VAR a,make_int_scon n2],[]),ty),
d1391 1
a1391 1
                                     APP (BUILTIN Pervasives.LSHIFT, ([e,make_int_scon j],[]),ty))],
d1402 1
d1405 1
a1405 1
          SOME j => SOME (APP (BUILTIN Pervasives.ARSHIFT,([e,make_int_scon j],[]),ty))
d1408 1
a1408 1
      | try_simplify (Pervasives.INTMOD,[e,SCON (s,_)]) =
d1411 1
d1414 1
a1414 1
            SOME j => SOME (APP (BUILTIN Pervasives.ANDB,([e,make_int_scon (i-1)],[]),ty))
d1442 10
a1451 2
             SOME e => diag (3,fn () => "Folded " ^ LambdaPrint.print_exp (APP (BUILTIN b,(args,[]),ty)) ^ "\n")
           | NONE => diag (2,fn () => "CONSTANT " ^ LambdaPrint.print_exp (APP (BUILTIN b,(args,[]),ty)) ^ "\n");
d1519 3
a1521 2
                   (status = ENTRY orelse (inline_functors andalso status = FUNC) orelse is_inlineable (body,depth)
                    orelse (has_app_use optvar andalso is_curry_inlineable (body,depth))) (* Only if used for an APP *)
d1567 5
d1676 3
a1678 3
                 if SimpleUtils.exp_eq (e,e') 
                   then SOME t 
                 else find_switch (e,rest)
d1725 1
d1819 10
a1828 1
        merge_lets (x,i,aux (e1,SOME x,depth,switches),e2,optvar,depth,switches)
d1852 2
a2531 1

a2545 2
        val e = TransSimple.trans_lamb e
        val _ = pprint_exp (2,e)
d2557 1
a2557 1
               simplify (e,empty_hashmap (),ref false,0))
d2567 11
a2577 1
                val e = if local_functions then LambdaFlow.preanalyse e else e
d2668 1
a2668 1
  (PROGRAM ([],cleanup (simplify (linearize (TransSimple.trans_lamb e),empty_hashmap (),ref false,0))))
@


1.38
log
@Adding "replace mult by power of 2 by a shift" optimization.
@
text
@d3 3
d1282 2
a1283 3
        if n = 0 then SOME (SCON (Ident.INT ("0",location),NONE))
        else if n = 1 then SOME (e)
        else if n = 2 then SOME (APP (BUILTIN Pervasives.INTPLUS, ([e,e],[]),ty))
d1308 1
a1308 4
          | _ => 
            if n > 0 andalso n <= small_value
              then SOME (make_mult (n,e,SCON (Ident.INT ("0",location),NONE),[],location))
            else NONE
@


1.37
log
@Adding "multiplication by small constant" optimization
@
text
@d3 3
d1275 1
a1275 1
    fun do_small_multiply (e,i,location) =
d1280 30
a1309 3
        else if n > 0 andalso n <= small_value
          then SOME (make_mult (n,e,SCON (Ident.INT ("0",location),NONE),[],location))
        else NONE
d1334 1
a1334 1
        do_small_multiply (e,s,l)
d1336 1
a1336 1
        do_small_multiply (e,s,l)
@


1.36
log
@[Bug #1633]
Add copyright message
@
text
@d3 4
d1244 37
a1280 4
    fun getint s =
      case Int.fromString s of
        SOME n => n
      | _ => Crash.impossible "getint"
a1282 1
    (* Multiplications by 1 convert to shifts of 0 which convert to nops *)
d1284 1
a1284 1
    fun try_simplify (Pervasives.INTDIV,[e,SCON (Ident.INT (n,l),_)]) =
d1286 1
a1286 1
        val i = getint n
d1292 1
a1292 1
      | try_simplify (Pervasives.INTMOD,[e,SCON (Ident.INT (n,l),_)]) =
d1294 1
a1294 1
          val i = getint n
a1299 1

d1303 4
a1306 4
      | try_simplify (Pervasives.INTSTAR, [e,SCON (Ident.INT ("2",l),_)]) =
        SOME (APP (BUILTIN Pervasives.INTPLUS, ([e,e],[]),ty))
      | try_simplify (Pervasives.INTSTAR, [SCON (Ident.INT ("2",l),_),e]) =
        SOME (APP (BUILTIN Pervasives.INTPLUS, ([e,e],[]), ty))
a1313 3
      | try_simplify (Pervasives.INTSTAR,[e,SCON (Ident.INT ("1",l),_)]) = SOME e
      | try_simplify (Pervasives.INTSTAR,[SCON (Ident.INT ("1",l),_),e]) = SOME e

d1331 2
a1332 2
     handle Bignum.Unrepresentable => NONE
          | Bignum.Runtime _ => NONE
@


1.35
log
@Simplifications and rationalizations
@
text
@d3 3
d113 2
a114 2
 Copyright (c) 1995,1996 Harlequin Ltd.
*)
@


1.34
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d123 2
d144 2
d147 5
a151 4
                      sharing TransSimple.SimpleTypes = SimpleUtils.SimpleTypes
                      sharing type TransSimple.SimpleTypes.LambdaTypes.Primitive = Pervasives.pervasive
                      sharing type TransSimple.SimpleTypes.LambdaTypes.Ident.SCon = Scons.SCon
                      end where type TransSimple.SimpleTypes.var = int
d155 2
a156 2
  structure SimpleTypes = TransSimple.SimpleTypes
  structure Ident = SimpleTypes.LambdaTypes.Ident
d158 1
a158 1
  structure LambdaTypes = SimpleTypes.LambdaTypes
d161 1
a161 2
  open MLWorks.Option
  open SimpleTypes
d164 1
a164 4
  fun getint s =
    case Int.fromString s of
      SOME n => n
    | _ => Crash.impossible "getint"
d174 2
a175 2
  val print = false
  val print_level = 5
d178 2
a179 1
  val max_num_args = 5
d184 1
a184 1
      then if level <= diag_level  then MLWorks.IO.output(MLWorks.IO.std_out, f()) else ()
d188 1
a188 1
    if level <= diag_level then MLWorks.IO.output(MLWorks.IO.std_out, f()) else ()
d220 2
a221 2
  fun varlist_member (var:var,[]) = false
    | varlist_member (var:var,var':: rest) = var = var' orelse varlist_member (var,rest)
d265 1
d267 2
a269 36
  (* A simple size measure *)

  fun size_less (exp,n) =
    if n <= 0 then n
    else
      case exp of
        INT _ => n-1
      | SCON _ => n-1
      | MLVALUE _ => n-1
      | BUILTIN _ => n-1
      | VAR _ => n-1
      | APP (e,el,_) => n - (3 + length el)
      (* Don't want to inline these right now *)
      | FN _ => 0
      | LETREC _ => 0
      (* Should be a function of the builtin *)
      | BUILTINAPP _ => n-1
      (* 3 for the overhead of allocation *)
      | STRUCT (el,_) => n - 3 - length el
      (* 2 overhead for each switch *)
      | SWITCH (e,_,tel,opte) =>
          let
            fun red ([],SOME e,n) = size_less (e,n-2)
              | red ([],NONE,n) = n
              | red ((t,e)::l,opte,n) = red (l,opte,size_less (e,n-2))
          in
            red (tel,opte,n-1)
          end
      (* 10 for the overhead of handling *)
      | HANDLE (e1,e2,_) =>
          size_less (e2,size_less (e1,n-10))
      | RAISE e => n-5
      | SELECT _ => n-1
      | LET ((v,_,e1),e2) => size_less (e2,size_less (e1,n))

  (* Want to become less willing to inline as we get deeper *)
d271 1
a271 12
    size_less (e,inline_size - (depth + depth)) > 0

(* This is rather crude *)
(*
  fun (* is_inlineable (LET ((_,_,e1),LET ((_,_,e2),LET ((_,_,e3),e4)))) = 
    SimpleUtils.is_simple e1 andalso SimpleUtils.is_simple e2 andalso 
    SimpleUtils.is_simple e3 andalso SimpleUtils.is_simple e4
    | *) is_inlineable (LET ((_,_,e1),(LET ((_,_,e2),e3)))) = 
    SimpleUtils.is_simple e1 andalso SimpleUtils.is_simple e2 andalso SimpleUtils.is_simple e3
    | is_inlineable (LET ((_,_,e1),e2)) = SimpleUtils.is_simple e1 andalso SimpleUtils.is_simple e2
    | is_inlineable e = SimpleUtils.is_simple e
*)
d289 2
a290 1
  (* Simultaneous substitution of a list of variables *)
d301 1
a301 1
        | aux (APP (e,el,ty)) = APP (aux e,map aux el,ty)
a304 1
        | aux (BUILTINAPP(b,el,ty)) = BUILTINAPP(b,map aux el,ty)
d332 1
a332 2
        | aux (APP (e,el,ty)) = APP (aux e,map aux el,ty)
        | aux (BUILTINAPP(b,el,ty)) = BUILTINAPP(b,map aux el,ty)
d344 1
a344 1
            val v' = new_valid ()
d350 1
a350 1
        | aux (FN (vl,body,status,name,ty,info)) = 
d352 2
a353 1
            val new_vl = map (fn v => (v,new_valid ())) vl
d357 1
a357 1
              new_vl
d359 1
a359 1
            FN (map #2 new_vl,aux body,status,name,ty,info)
d363 1
a363 1
            val fl' = map (fn (v,info) => (new_valid(),info)) fl
d549 1
a549 1
          val _ = diag (3, fn () => "Found global 1: " ^ pde e1' ^ "\n")
d560 1
a560 1
  | globalize' (FN ([x],body,status,name,ty,info),env,dyn_vars,in_switch) = 
d565 1
a565 1
          val id = new_valid()
d567 1
a567 1
          (FN ([x],body',status,name,ty,info),env)
d573 1
a573 1
          (FN ([x],body',BODY,name,ty,info),env')
d580 1
a580 1
      fun do_el (FN (vl,e,status,name,ty,info)::rest,env,acc) =
d582 1
a582 1
          val (e',env') = globalize' (e,env,vl@@dyn_vars',in_switch)
d584 1
a584 1
          do_el (rest,env',FN (vl,e',status,name,ty,info)::acc)
d636 1
a636 1
          val new_var = new_valid ()
d655 1
a655 1
        val bid = new_valid()
d659 3
a661 1
        (id,null_debug,FUN (vars,ENTRY,s ^ "<Case entry>",SWITCH (VAR v,info,[(t,e)],SOME (APP (VAR bid,varargs))))) ::
d701 1
a701 1
              FN ([x],APP (VAR f,[VAR v,VAR x'],_),_,_,_,_) => 
d710 1
a710 1
                val bid = new_valid()
d713 4
a716 1
                (id,null_debug,VAL (FN (vars,LET ((v,null_debug,APP(VAR bid,map VAR vars,nulltype)),returned_exp),BODY,s ^ "<Ret>",ty,info))) ::
d729 4
a732 3
(* This puts the body in an entry function, with selections done and unused variables *)
(* thrown away *)
(* dyn_vars should be all the things that might have to be passed to the body, *)
d734 3
a736 1
(* This should do something sensible when selvars = [] *)
d741 1
a741 1
    val bid = new_valid ()
d745 1
a745 1
    (wrap_lets (selects,APP (VAR bid,map VAR fvars,nulltype)),
d747 2
a748 1
     return_transform ((bid,null_debug,VAL (FN (fvars,newbody,BODY,name,null_type,LambdaTypes.internal_funinfo))) :: env))
d751 6
a756 1
fun mk_tuple_select (index,size,e) = SELECT ({index=index,size=size,selecttype=TUPLE},e)
d758 2
a759 2
(* A superior version *)    
fun make_select (vars,closid,body) =
d771 1
a771 1
fun make_select (vars,closid,body) =
d785 1
d788 1
a788 1
fun make_select (vars,closid,body) =
d800 1
a800 1
fun make_closure (f,closure,name) =
d802 1
a802 1
    val x = new_valid ()
d804 6
a809 1
    FN ([x],APP (VAR f,[closure,VAR x],NONE),ENTRY,name ^ "<Closure>",null_type,LambdaTypes.internal_funinfo)
d812 6
a817 1
(* This does the business *)
d819 4
a822 2
(* global => dyn_vars = [], but not vice-versa due to handlers *)
fun transform (func as (FN ([x],body,status,name,ty,info)),env,dyn_vars,global) = 
d824 1
d830 1
a830 1
         val id = new_valid()
d832 1
a832 1
         (VAR id,(id,null_debug,FUNCTOR (x,name,(rev env',body'))) :: env)
d835 1
a835 1
       (* to letrec code *)
d837 1
a837 1
         val f = new_valid ()
d841 1
d843 1
d848 1
a848 1
        (fn ((f,_),FN (vl,body,_,name,_,info)) => (f,vl,name,body)
d871 1
a871 1
                    (f,null_debug,VAL (FN([x],fbody',ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) :: env'
d886 1
a886 1
              fun expaux (e as APP (VAR f,[y],ty)) =
d888 1
a888 1
                   SOME f' => APP(VAR f',[closexpr,y],make_call_ty ty)
d895 5
d901 1
a901 1
          fun is_loop_function (f,_,s,e) =
d903 1
a903 1
              fun has_tail_call e =
d907 1
a907 1
                  Lists.exists (fn (t,e) => has_tail_call e) tel
d910 1
a910 1
                     SOME e => has_tail_call e
d912 2
a913 2
                | LET (_,e) => has_tail_call e
                | LETREC (_,_,e) => has_tail_call e
d915 1
a915 1
              val result = has_tail_call e
d925 2
a926 2
          val funids = map (fn _ => new_valid ()) funnames
          val idtids = map (fn id => (id,new_valid ())) funids
d934 1
a934 1
            | _ => new_valid()
d936 9
a944 6
          fun get_num_args (f,[v],_,e as LET ((_,_,SELECT ({size,...},VAR v')),_)) =
            if v = v' then size else if SimpleUtils.occurs (v,e) then 1 else 0
            | get_num_args (f,[v],_,e) = if SimpleUtils.occurs (v,e) then 1 else 0
            | get_num_args _ = crash "too many vars in get_num_args"
        
          val num_args = max (map get_num_args fvel,0)
d947 1
d969 1
a969 1
                   (fn ((f,f'),name) => (f,make_closure (f',VAR closid,name)))
d976 1
a976 1
            letmap (fn (e as APP(VAR id,[VAR c,y],nulltype)) =>
d979 1
a979 1
                        APP(VAR (varassoc' (id,idtids)),((map VAR fvars)@@[y]),nulltype)
d983 5
a987 1
          (* inlining closures is too delicate when the closure itself is needed *)
d991 1
a991 2
            (num_args = 0 orelse
             (* Try taking this out for the moment *)
d993 1
a993 1
             num_args + length fvars <= max_num_args)
d1001 2
a1002 1
                    val vars = fvars@@[x]
d1006 1
a1006 1
                      select_transform (x,closid::vars,name,transform (newbody,env,vars@@dyn_vars,false))
d1012 2
a1013 2
                             APP(VAR tid,[VAR y,VAR x],nulltype))
                        | _ => make_select (fvars,closid,APP(VAR tid,map VAR vars,nulltype))
d1015 2
a1016 2
                      (id,null_debug,VAL (FN([closid,x],entrybody,ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) ::
                      (tid,null_debug,VAL (FN (vars,newbody',ENTRY,name^"<Entry2>",null_type,LambdaTypes.internal_funinfo))) :: 
d1022 1
a1022 1
                (* Should do a destruct transform before make_select *)
d1028 1
a1028 1
                       then make_select (fvars,closid,e)
d1030 1
a1030 1
                    | insert_select e = make_select (fvars,closid,e)
d1042 1
a1042 1
                     VAL (FN ([closid,x],newbody',ENTRY,name^"<Entry1>",null_type,LambdaTypes.internal_funinfo))) :: env'
d1051 1
a1051 1
              LET ((f,null_debug,make_closure (id,closexp,name)),make_lets (l,closexp,e))
d1067 2
d1129 1
d1146 1
a1146 1
(* Second level transformation *)
d1148 1
d1166 1
a1172 8
    fun foldable Pervasives.LOAD_STRING = false
      | foldable Pervasives.LOAD_STRUCT = false
      | foldable Pervasives.LOAD_VAR = false
      | foldable Pervasives.LOAD_EXN = false
      | foldable Pervasives.LOAD_FUNCT = false
      | foldable Pervasives.CALL_C = false
      | foldable _ = SimpleUtils.safe_cse (BUILTINAPP (b,el,ty))
        
d1192 9
d1236 9
d1250 1
a1250 1
          SOME j => SOME (BUILTINAPP (Pervasives.ARSHIFT,[e,make_int_scon j],ty))
d1258 1
a1258 1
            SOME j => SOME (BUILTINAPP (Pervasives.ANDB,[e,make_int_scon (i-1)],ty))
d1261 3
a1263 9
      | try_simplify (Pervasives.ARSHIFT,[e,SCON (Ident.INT ("0",l),_)]) =
        SOME e
      | try_simplify (Pervasives.RSHIFT,[e,SCON (Ident.INT ("0",l),_)]) =
        SOME e
      | try_simplify (Pervasives.LSHIFT,[e,SCON (Ident.INT ("0",l),_)]) =
        SOME e
        
(*
 (* Oh dear *)
d1265 14
a1278 5
      | try_simplify (Pervasives.INTSTAR,[e,SCON (Ident.INT ("2",l),_)]) =
        SOME (BUILTINAPP (Pervasives.INTPLUS,[e,e],ty))
      | try_simplify (Pervasives.INTSTAR,[SCON (Ident.INT ("2",l),_),e]) =
        SOME (BUILTINAPP (Pervasives.INTPLUS,[e,e],ty))
*)
d1290 2
a1291 2
             SOME e => diag (3,fn () => "Folded " ^ print_exp (BUILTINAPP (b,args,ty)) ^ "\n")
           | NONE => diag (2,fn () => "CONSTANT " ^ print_exp (BUILTINAPP (b,args,ty)) ^ "\n");
d1301 1
a1301 1
datatype UsesType = APP_USE | ARG_USE | OTHER (* OTHER is just a dummy *)
d1306 1
d1312 1
a1312 1
    fun expfun (APP (function,arg,_)) =
d1351 1
a1351 1
         APP (e,el,ty) =>
d1354 1
d1357 1
a1357 1
               SOME (FN (vars,body,status,_,_,_)) =>
d1367 1
a1367 1
                                   VAR f => print_var f 
d1375 2
a1376 1
             | SOME (BUILTIN builtin) =>
d1378 4
a1381 2
                   val e2 = case el of [e2] => e2 | _ => crash "Multiarg APP of BUILTIN"
                   val arity = SimpleUtils.get_arity builtin
d1383 6
a1388 5
                   if arity = 1 
                     then 
                       (change();
                        aux (BUILTINAPP (builtin,[e2],ty),optvar,depth,switches))
                   else if arity > 1 then
d1390 2
d1393 1
a1393 1
                         | make_vars (n,acc) = make_vars (n-1,new_valid () :: acc)
d1402 1
a1402 1
                       aux (make_lets  (0,vars,BUILTINAPP (builtin,map VAR vars,ty)),optvar,depth,switches)
a1403 1
                        else crash "Bad Arity"
d1414 1
a1414 1
                  (diag (3, (fn () => "Done a select on " ^ print_exp (SELECT(info,e)) ^ "\n"));
d1418 2
a1419 2
                                print_exp (SELECT (info,e)) ^ ":" ^ 
                                print_exp (STRUCT (args,ty')) ^ "\n") 
d1426 1
a1426 1
               (crash ("Bad Select: " ^ print_exp (SELECT(info,e)) ^ "\n")))
d1453 1
a1453 1
                                        exp_eq (e,e') andalso
a1469 4
       | BUILTINAPP (b,el,ty) => 
           (case do_builtinapp ((b,el,ty),env) of
              SOME e => (change(); aux (e,optvar,depth,switches))
            | _ => exp)
d1492 1
a1492 1
               | constant_switch_weed (t,[],NONE) = crash ("constant tag: " ^ print_tag t ^ " not found: " ^ print_exp (SWITCH (e,info,tel,opte)))
d1501 1
a1501 1
                     if exp_eq (e,e') then dotags (e,l) else NONE
d1510 1
a1510 1
                 if exp_eq (e,e') 
d1546 1
a1546 1
                   val _ = diag (2,fn () => "All equal switch found: " ^ print_exp e' ^ "\n")
d1548 1
a1548 1
                   val id = new_valid ()
d1583 1
a1583 1
                                    if SimpleUtils.switchable_expr e' then e'
d1618 1
a1618 1
       | FN (vl,body,status,name,ty,debug) => 
d1627 2
a1628 2
                 APP (f,el,_) => 
                   if eqvars (el, vl) then SOME f else NONE
d1633 1
a1633 1
               | _ => FN (vl,newbody,status,name,ty,debug)
d1658 1
a1658 1
            (fn ((f,info),FN (vl,e,status,name,ty,debug)) => 
d1661 1
a1661 1
               val f' = FN (vl,e',status,name,ty,debug)
d1676 2
d1690 1
a1690 1
      | FN (vl,e,status,name,ty,debug) => FN (vl,do_let e,status,name,ty,debug)
d1694 1
a1694 1
      | LET _ => crash ("NotLinearized: remove_unused" ^ print_exp e)
d1732 1
a1732 1
        | aux (APP (e,el,ty)) = APP (aux e,map aux el,ty)
a1735 1
        | aux (BUILTINAPP(b,el,ty)) = BUILTINAPP(b,map aux el,ty)
d1771 4
a1774 1
fun pprint (level,p) = if print andalso level <= print_level then MLWorks.IO.output(MLWorks.IO.std_out,pds (PROGRAM p) ^ "\n") else ()
d1776 4
a1779 1
fun pprint_exp (level,e) = if print andalso level <= print_level then MLWorks.IO.output (MLWorks.IO.std_out,pde e ^ "\n") else ()
a1843 1
      | aux (BUILTINAPP (b,el,_)) = Lists.iterate aux el
d1855 2
a1856 2
      | aux (APP (VAR x,el,_)) = (inc_var x; Lists.iterate aux el)
      | aux (APP (e,el,_)) = (aux e; Lists.iterate aux el)
d1873 1
a1873 1
      (diag (0,fn _ => "Adding function " ^ print_var f ^ "\n");
d1879 1
a1879 1
      | LET ((f,info,e as FN (vl,funbody,stat,name,ty,funinfo)),body) =>
d1888 2
a1889 1
         (fn ((f,info),FN (vl,funbody,stat,name,ty,funinfo)) => add_name (f,vl,funbody)
d1908 1
a1908 1
      | get_funnames ((f,_,VAL (FN (vl,e,stat,name,ty,funinfo))):: l) = 
d1952 1
a1952 1
          | aux (e as APP (VAR f,el,ty)) =
d1955 1
a1955 1
                 if size_less (body,1000) > 0 andalso count < max_depth
d1974 1
a1974 1
    val todo = ref [] : exp list ref
a1997 1
      | aux (BUILTINAPP (b,el,_)) = laux el
d2009 1
a2009 1
      | aux (APP (e,el,_)) = (aux e;Lists.iterate aux el)
d2033 1
a2033 1
        (diag (3, fn () => ("Weeding " ^ print_var a ^ "\n"));
d2065 1
a2065 1
fun optimize_all (prog,env,depth) =
d2093 1
a2093 1
fun optimize_till_done (prog as (declist,exp)) =
d2098 1
a2098 1
        val _ = diag (2, fn () => ("Optimise pass " ^ N n ^ "\n"))
d2100 1
a2100 1
        val (changed,prog') = optimize_all (prog,env,n)
d2105 1
a2105 1
          (diag (1, fn () => (N n ^ " iterations of optimize_all\n"));
d2116 1
a2116 1
        if exp_eq (e,e') then SOME v else find_def (e,rest)
d2134 1
a2134 1
                (diag (3, fn () => "CSE of " ^ print_var v ^ " = " ^ print_exp e' ^ "\n");
d2157 1
a2157 1
fun is_imperative (BUILTINAPP (builtin,_,_)) =
d2171 2
a2172 2
    BUILTINAPP (Pervasives.UNSAFE_UPDATE, [r,i,VAR x],_) =>
      [(x,BUILTINAPP (Pervasives.UNSAFE_SUB, [r,i],NONE))]
d2174 2
a2175 2
  | BUILTINAPP (Pervasives.BECOMES, [r,VAR x],_) =>
      [(x,BUILTINAPP (Pervasives.DEREF, [r],NONE))]
d2185 1
a2185 1
        if exp_eq (e,e') then SOME v else find_def (e,rest)
d2196 1
a2196 1
                    (diag (1, fn () => "Found CSE: " ^ print_exp e1' ^ "\n");
d2205 1
a2205 1
                    (diag (2, fn () => "Found imperative CSE: " ^ print_exp e1' ^ "\n");
d2249 1
a2249 1
                      (diag (1, fn () => "Found CSE: " ^ print_exp e1' ^ "\n");
d2257 1
a2257 1
                    (diag (1, fn () => "Found imperative CSE: " ^ print_exp e1' ^ "\n");
d2283 1
a2283 1
             diag (2,fn () => "Eliminating global " ^ print_var v ^ "\n");
d2288 1
a2288 1
	       FN([x], APP(e' as VAR _, [VAR y], _), _, _, _, _) =>
d2291 1
a2291 1
		      diag (2,fn () => "Eliminating global " ^ print_var v ^ "\n"))
d2334 9
d2347 2
d2369 1
d2373 1
a2373 1
        val _ = pprint_exp (0,e)
a2381 1
               (* elim_simple_bindings (local_cse (simplify (e,empty_hashmap (),ref false,0))) *)
d2387 1
a2387 1
        val _ = pprint_exp (0,e)
d2392 1
d2400 1
a2400 1
                val _ = pprint (1,prog)
d2402 1
a2402 1
                val prog = optimize_till_done prog
d2409 1
d2419 1
a2419 1
                val prog = optimize_till_done prog
d2445 1
a2445 1
                val prog = optimize_till_done prog
d2453 2
a2454 5
        val _ = diag (1, fn () => "Doing Global CSE..\n")
        val prog = global_cse prog
        val _ = pprint (2,prog)
        val _ = diag (1, fn () => "Eta elim..\n")
        val prog = weed(elim_global_simple_bindings prog)
d2464 6
a2472 1
    val e = TransSimple.trans_lamb e
d2476 1
a2476 1
    if print_result then MLWorks.IO.output (MLWorks.IO.std_out, pds (PROGRAM prog) ^ "\n") else ();
d2480 1
@


1.34.4.1
log
@branched from 1.34
@
text
@a2 4
 * Revision 1.34  1996/11/06  11:02:32  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.3.1
log
@branched from 1.34
@
text
@a2 4
 * Revision 1.34  1996/11/06  11:02:32  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.3.1.1.1
log
@branched from 1.34.3.1
@
text
@a2 3
 * Revision 1.34.3.1  1996/12/17  17:48:04  hope
 * branched from 1.34
 *
@


1.34.2.1
log
@branched from 1.34
@
text
@a2 4
 * Revision 1.34  1996/11/06  11:02:32  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.1.1
log
@branched from 1.34
@
text
@a2 4
 * Revision 1.34  1996/11/06  11:02:32  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.34.1.1.1.1
log
@branched from 1.34.1.1
@
text
@a2 3
 * Revision 1.34.1.1  1996/11/14  12:49:54  hope
 * branched from 1.34
 *
@


1.33
log
@[Bug #1614]
basifying String
@
text
@d3 4
d109 1
a109 1
require "../basis/__integer";
@


1.32
log
@[Bug #1634]

Tidying up
@
text
@d3 5
d119 2
d230 1
a230 1
      val map = IntHashTable.new (Lists.length l)
d268 1
a268 1
      | APP (e,el,_) => n - (3 + Lists.length el)
d275 1
a275 1
      | STRUCT (el,_) => n - 3 - Lists.length el
d781 1
a781 1
    val len = Lists.length vars
d793 1
a793 1
    val len = Lists.length vars
d809 1
a809 1
    val len = Lists.length vars
d985 1
a985 1
             num_args + Lists.length fvars <= max_num_args)
d1177 2
a1178 3
      if (size n >= 2 andalso MLWorks.String.substring (n,0,2) = "0x") orelse
        (size n >= 3 andalso MLWorks.String.substring (n,0,3) = "~0x")
        then Bignum.hex_string_to_bignum n
d1180 1
a1180 1
      | scon_to_bignum(Ident.CHAR s) = Bignum.int_to_bignum(MLWorks.String.ord s)
d1188 1
a1188 1
        (SOME (make_int_scon (MLWorks.String.ord s)) 
d1407 1
a1407 1
                          val len = 1 + Lists.length vl
d1484 1
a1484 1
               if Lists.length tel + 1 = num_vccs + num_imms
@


1.32.2.1
log
@branched from 1.32
@
text
@a2 5
 * Revision 1.32  1996/10/04  13:23:24  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.32.1.1
log
@branched from 1.32
@
text
@a2 5
 * Revision 1.32  1996/10/04  13:23:24  matthew
 * [Bug #1634]
 *
 * Tidying up
 *
@


1.31
log
@Add mechanism to remove entry functions for functions of a single variable
@
text
@d3 3
d97 1
a108 1
require "../basics/identprint";
a109 1
require "../typechecker/types";
a120 1
                      structure IdentPrint : IDENTPRINT
a122 1
                      structure Types : TYPES
d128 1
d130 1
a130 4
                      sharing type TransSimple.SimpleTypes.LambdaTypes.Type = Types.Datatypes.Type
                      sharing TransSimple.SimpleTypes = SimpleUtils.SimpleTypes
                      sharing IdentPrint.Ident = TransSimple.SimpleTypes.LambdaTypes.Ident
		      sharing type IdentPrint.Ident.SCon = Scons.SCon
@


1.31.1.1
log
@branched from 1.31
@
text
@a2 3
 * Revision 1.31  1996/07/25  14:51:04  jont
 * Add mechanism to remove entry functions for functions of a single variable
 *
@


1.30
log
@globalize needs to record if it is in a switch statement and therefore should be
conservative about lifting switches
@
text
@d3 4
d2239 3
a2241 2
        if SimpleUtils.is_atomic e andalso is_absent info
          then 
d2245 16
a2260 1
        else
d2404 1
a2404 1
        val prog = elim_global_simple_bindings prog
@


1.29
log
@The Ord exception is no longer at top level.
@
text
@d3 3
d550 1
a550 1
fun lift_globalp (e,dyn_vars) =
d553 1
a553 1
  is_safe_to_lift e andalso
d557 1
a557 125
(*
fun globalize_simple (e,env,dyn_vars,global) =
  if SimpleUtils.is_simple e
    then (e,env)
  else globalize' (e,env,dyn_vars,global)

and globalize' (LET ((v,i,e1),e2),env,dyn_vars,true) =
  let
    val (e1',env') = globalize_simple (e1,env,dyn_vars,true)
  in
    globalize' (e2,(v,i,e1')::env',dyn_vars,true)
  end
  | globalize' (LET ((v,i,e1),e2),env,dyn_vars,false) =
  let
    val (e1',env') = globalize_simple (e1,env,dyn_vars,false)
  in
    if lift_globalp (e1',dyn_vars)
      then
        let
          val () = diag (3, fn () => "Found global\n")
        in
          globalize' (e2, (v,i,e1')::env',dyn_vars,false)
        end
    else
      let
        val (e2',env'') = globalize' (e2,env',v::dyn_vars,false)
      in
        (LET ((v,i,e1'),e2'),env'')
      end
  end
  | globalize' (FN ([x],body,status,name,ty,info),env,dyn_vars,global) = 
    (case status of
      FUNC => 
        let 
          val _ = if not global then crash "Functor not global" else ()
          val _ = if not (dyn_vars = []) then crash "Functor has dynamic vars" else ()
          val body' = globalize (body,[],[],true)
          val id = new_valid()
        in
          (FN ([x],body',status,name,ty,info),env)
        end
    | _ => 
        let 
          val (body',env') = globalize' (body,env,x::dyn_vars,false)
        in
          (FN ([x],body',BODY,name,ty,info),env')
        end)
  | globalize' (FN _,env,dyn_vars,_) = crash "Multi arg FN in globalize'"
  | globalize' (LETREC (fl,el,body),env,dyn_vars,global) =
    let
      val fnnames = map #1 fl
      val dyn_vars' = fnnames@@dyn_vars
      fun do_el (FN (vl,e,status,name,ty,info)::rest,env,acc) =
        let
          val (e',env') = globalize' (e,env,vl@@dyn_vars',false)
        in
          do_el (rest,env',FN (vl,e',status,name,ty,info)::acc)
        end
        | do_el (_::rest,env,acc) = crash "Bad fn in letrec in globalize"
        | do_el ([],env,acc) = (rev acc,env)
      val (el',env') = do_el (el,env,[])
      val (body',env'') = globalize' (body,env',dyn_vars',false)
    in
      (LETREC (fl,el',body'),env'')
    end
  | globalize' (SWITCH (e,info,tel,opte),env,dyn_vars,global) = 
    let
      val (e',env1) = globalize_simple (e,env,dyn_vars,global)
      fun do_tel ([],env) = ([],env)
        | do_tel ((EXP_TAG e1,e)::l,env) =
          let
            val (e',env') = globalize' (e,env,dyn_vars,false)
            val (e1',env'') = globalize' (e1,env',dyn_vars,false)
            val (tel',env''') = do_tel (l,env'')
          in
            ((EXP_TAG e1',e') :: tel', env''')
          end
        | do_tel ((t,e)::l,env) =
          let
            val (e',env') = globalize' (e,env,dyn_vars,false)
            val (tel',env'') = do_tel (l,env')
          in
            ((t,e') :: tel', env'')
          end
      val (tel',env2) = do_tel (tel,env1)
      val (opte',env3) =
        case opte of
          SOME e => 
            let val (e',env) = globalize' (e,env2,dyn_vars,false)
            in
              (SOME e',env)
            end
        | NONE => (NONE,env2)
    in
      (SWITCH (e',info,tel',opte'),env3)
    end
  | globalize' (HANDLE (e1,e2,s),env,dyn_vars,global) =
    let
      val (e1',env') = globalize' (e1,env,dyn_vars,false)
      val (e2',env'') = globalize' (e2,env',dyn_vars,global)
    in
      (HANDLE (e1',e2',s),env'')
    end
  | globalize' (e,env,_,true) = (e,env)
  | globalize' (e,env,dyn_vars,false) = 
    if lift_globalp (e,dyn_vars)
      then
        let
          val _ = diag (3, fn () => "Found global\n")
          val new_var = new_valid ()
        in
          (VAR new_var,(new_var,null_debug,e)::env)
        end
    else
      (e,env)

and globalize (e,env,dyn_vars,global) =
  let
    val (e',lets) = globalize' (e,env,dyn_vars,global)
  in
    wrap_lets (lets,e')
  end
*)

fun globalize_simple (e,env,dyn_vars) =
d560 1
a560 1
  else globalize' (e,env,dyn_vars)
d567 1
a567 1
and globalize' (LET ((v,i,e1),e2),env,dyn_vars) =
d569 1
a569 1
    val (e1',env') = globalize_simple (e1,env,dyn_vars)
d571 1
a571 1
    if lift_globalp (e1',dyn_vars)
d574 1
a574 1
          val _ = diag (3, fn () => "Found global\n")
d576 1
a576 1
          globalize' (e2, (v,i,e1')::env',dyn_vars)
d580 1
a580 1
        val (e2',env'') = globalize' (e2,env',v::dyn_vars)
d585 1
a585 1
  | globalize' (FN ([x],body,status,name,ty,info),env,dyn_vars) = 
d589 1
a589 1
          val body' = globalize (body,[],dyn_vars)
d596 1
a596 1
          val (body',env') = globalize' (body,env,x::dyn_vars)
d600 2
a601 2
  | globalize' (FN _,env,dyn_vars) = crash "Multi arg FN in globalize'"
  | globalize' (LETREC (fl,el,body),env,dyn_vars) =
d607 1
a607 1
          val (e',env') = globalize' (e,env,vl@@dyn_vars')
d614 1
a614 1
      val (body',env'') = globalize' (body,env',dyn_vars')
d618 1
a618 1
  | globalize' (SWITCH (e,info,tel,opte),env,dyn_vars) = 
d620 1
a620 1
      val (e',env1) = globalize_simple (e,env,dyn_vars)
d624 2
a625 2
            val (e',env') = globalize' (e,env,dyn_vars)
            val (e1',env'') = globalize' (e1,env',dyn_vars)
d632 1
a632 1
            val (e',env') = globalize' (e,env,dyn_vars)
d641 1
a641 1
            let val (e',env) = globalize' (e,env2,dyn_vars)
d649 1
a649 1
  | globalize' (HANDLE (e1,e2,s),env,dyn_vars) =
d651 2
a652 2
      val (e1',env') = globalize' (e1,env,dyn_vars)
      val (e2',env'') = globalize' (e2,env',dyn_vars)
d656 2
a657 2
  | globalize' (e,env,dyn_vars) = 
    if lift_globalp (e,dyn_vars)
d660 1
a660 1
          val _ = diag (3, fn () => "Found global\n")
d668 1
a668 1
and globalize (e,env,dyn_vars) =
d670 1
a670 1
    val (e',lets) = globalize' (e,env,dyn_vars)
d2303 1
a2303 1
        val e = globalize (e,[],[])
@


1.28
log
@Fix problems with optimising manifest chars
@
text
@d3 3
d1289 2
a1290 2
      if (size n >= 2 andalso String.substring (n,0,2) = "0x") orelse
        (size n >= 3 andalso String.substring (n,0,3) = "~0x")
d1301 2
a1302 2
        (SOME (make_int_scon (String.ord s)) 
         handle Ord => NONE)
d1304 1
a1304 1
        (SOME (make_string_scon (String.chr (scon_to_int n)))
@


1.27
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d1285 1
a1285 1
    fun scon_to_bignum (Ident.INT (n,_)) =
d1290 1
@


1.26
log
@Integer changes
,
@
text
@d3 3
d153 1
a153 1
      then if level <= diag_level  then output(std_out, f()) else ()
d157 1
a157 1
    if level <= diag_level then output(std_out, f()) else ()
d1291 1
a1291 1
        (SOME (make_int_scon (ord s)) 
d1294 1
a1294 1
        (SOME (make_string_scon (chr (scon_to_int n)))
d1843 1
a1843 1
fun pprint (level,p) = if print andalso level <= print_level then output(std_out,pds (PROGRAM p) ^ "\n") else ()
d1845 1
a1845 1
fun pprint_exp (level,e) = if print andalso level <= print_level then output (std_out,pde e ^ "\n") else ()
d2512 1
a2512 1
    if print_result then output (std_out, pds (PROGRAM prog) ^ "\n") else ();
@


1.25
log
@Adding where type clause
@
text
@d3 3
d77 2
a78 1
require "../utils/integer";
a95 1
                      structure Integer : INTEGER
d127 5
d1268 1
a1268 1
      SCON (Ident.INT (Integer.makestring n,Location.UNKNOWN), NONE)
d1323 1
a1323 1
        val i = Integer.parseinteger n
d1331 1
a1331 1
          val i = Integer.parseinteger n
d1553 2
a1554 2
             fun print_tag (IMM_TAG (_,i)) = "IMM " ^ MLWorks.Integer.makestring i
               | print_tag (VCC_TAG (_,i)) = "VCC " ^ MLWorks.Integer.makestring i
d2143 1
a2143 1
              diag (1,fn _ => "Done " ^ Integer.makestring x ^ "\n");
d2162 1
a2162 1
        val _ = diag (2, fn () => ("Optimise pass " ^ Integer.makestring n ^ "\n"))
d2165 1
a2165 1
        val _ = diag (2, fn () => ("Done pass " ^ Integer.makestring n ^ "\n"))
d2169 1
a2169 1
          (diag (1, fn () => (Integer.makestring n ^ " iterations of optimize_all\n"));
@


1.24
log
@Adding shift optimizations
@
text
@d3 3
d90 3
a92 1
functor SimpleLambda (structure Integer : INTEGER
a106 1
                      sharing type SimpleUtils.SimpleTypes.var = int
d111 1
@


1.23
log
@Previous fix wasn't quite right -- need to handle negative numbers also.
@
text
@d3 3
d1324 7
@


1.22
log
@Int scons can now be hexadecimal
@
text
@d3 3
d1261 2
a1262 1
      if size n >= 2 andalso String.substring (n,0,2) = "0x"
d1267 2
a1268 3
    fun scon_to_int (Ident.INT (n,_)) =
      Integer.parseinteger n
      | scon_to_int _ = crash "scon_to_int"
d1277 1
a1277 1
              | Prod => NONE)
@


1.21
log
@Added inlining of functors for test purposes.  Currently switched off.
@
text
@d3 3
d1258 3
a1260 1
      Bignum.string_to_bignum n
@


1.20
log
@Added new types for different sizes of ints, words, and reals.
@
text
@d3 3
d110 2
d1399 1
a1399 1
                   (status = ENTRY orelse is_inlineable (body,depth)
d1685 1
d1687 3
a1689 1
        aux (LET ((x2,i2,e1),(LET ((x1,i1,e2),e3))),optvar,depth,switches)
d1691 1
a1691 1
        merge_lets (x,i,do_simple (e1,SOME x,depth,switches),e2,optvar,depth,switches)
@


1.19
log
@Changes for new overloaded div and mod
@
text
@d3 3
d104 5
a108 2
  val null_debug = SimpleTypes.LambdaTypes.Option.ABSENT
  val null_type = SimpleTypes.LambdaTypes.null_type_annotation
a139 3
  open SimpleTypes
  open MLWorks.Option

d148 1
a148 1
  fun is_absent LambdaTypes.Option.ABSENT = true
d1241 1
a1241 1
      SCON (Ident.INT (Integer.makestring n,Location.UNKNOWN))
d1244 1
a1244 1
      SCON (Ident.INT (Bignum.bignum_to_string n,Location.UNKNOWN))
d1247 1
a1247 1
      SCON (Ident.STRING s)
d1255 1
a1255 1
      | scon_to_int _ = crash "scon_to_bignum"
d1258 1
a1258 1
    fun try_fold (Pervasives.ORD,[SCON (Ident.STRING s)]) =
d1261 1
a1261 1
      | try_fold (Pervasives.CHR,[SCON n]) =
d1265 1
a1265 1
      | try_fold (Pervasives.HAT,[SCON (Ident.STRING s1),SCON (Ident.STRING s2)]) =
d1267 1
a1267 1
      | try_fold (Pervasives.SIZE,[SCON (Ident.STRING s)]) =
d1269 1
a1269 1
      | try_fold (Pervasives.INTPLUS,[SCON n1,SCON n2]) =
d1271 1
a1271 1
      | try_fold (Pervasives.INTSTAR,[SCON n1,SCON n2]) =
d1273 1
a1273 1
      | try_fold (Pervasives.INTDIV,[SCON n1,SCON n2]) =
d1275 1
a1275 1
      | try_fold (Pervasives.INTMOD,[SCON n1,SCON n2]) =
d1277 1
a1277 1
      | try_fold (Pervasives.INTMINUS,[SCON n1,SCON n2]) =
d1279 1
a1279 1
      | try_fold (Pervasives.INTEQ,[SCON n1,SCON n2]) =
d1281 1
a1281 1
      | try_fold (Pervasives.INTLESS,[SCON n1,SCON n2]) =
d1283 1
a1283 1
      | try_fold (Pervasives.INTGREATER,[SCON n1,SCON n2]) =
d1285 1
a1285 1
      | try_fold (Pervasives.INTLESSEQ,[SCON n1,SCON n2]) =
d1287 1
a1287 1
      | try_fold (Pervasives.INTGREATEREQ,[SCON n1,SCON n2]) =
d1289 1
a1289 1
      | try_fold (Pervasives.INTNE,[SCON n1,SCON n2]) =
d1292 1
a1292 1
    fun try_simplify (Pervasives.INTDIV,[e,SCON (Ident.INT (n,l))]) =
d1300 1
a1300 1
      | try_simplify (Pervasives.INTMOD,[e,SCON (Ident.INT (n,l))]) =
d1311 1
a1311 1
      | try_simplify (Pervasives.INTSTAR,[e,SCON (Ident.INT ("2",l))]) =
d1313 1
a1313 1
      | try_simplify (Pervasives.INTSTAR,[SCON (Ident.INT ("2",l)),e]) =
d1512 1
a1512 1
               | eq_tag (SCON_TAG s,SCON_TAG s') =
d1519 5
a1523 5
               | print_tag (SCON_TAG (Ident.INT (i,_))) = "INT " ^ i
               | print_tag (SCON_TAG (Ident.WORD (i,_))) = "WORD " ^ i
               | print_tag (SCON_TAG (Ident.REAL (i,_))) = "REAL " ^ i
               | print_tag (SCON_TAG (Ident.STRING s)) = "STRING " ^ MLWorks.String.ml_string (s,~1)
               | print_tag (SCON_TAG (Ident.CHAR s)) = "CHAR " ^ MLWorks.String.ml_string (s,~1)
d1598 1
a1598 1
                   | SOME (SCON(s as Ident.INT _)) =>
d1601 2
a1602 2
                        aux (constant_switch_weed (SCON_TAG s,tel,opte),optvar,depth,switches))
                   | SOME (SCON(s as Ident.STRING _)) =>
d1605 1
a1605 1
                        aux (constant_switch_weed (SCON_TAG s,tel,opte),optvar,depth,switches))
d1633 1
a1633 1
					| (t as SCON_TAG(Ident.REAL _), e') =>
@


1.18
log
@Add word operations
@
text
@d3 3
d1270 1
a1270 1
      | try_fold (Pervasives.DIV,[SCON n1,SCON n2]) =
d1272 1
a1272 1
      | try_fold (Pervasives.MOD,[SCON n1,SCON n2]) =
d1289 1
a1289 1
    fun try_simplify (Pervasives.DIV,[e,SCON (Ident.INT (n,l))]) =
d1297 1
a1297 1
      | try_simplify (Pervasives.MOD,[e,SCON (Ident.INT (n,l))]) =
@


1.17
log
@Removed some eta reduction
@
text
@d3 3
d1509 1
a1509 1
		  | _ =>Scons.scon_eqval(s, s'))
d1514 1
@


1.16
log
@Change Ident.scon_eqrep to Scons.scon_eqval
@
text
@d3 3
d1644 1
a1648 1
             val newbody = aux (body,novar,depth,switches)
d2085 4
d2091 1
a2091 1
              val new = VAL (simplify (e,env,changed,depth))
@


1.15
log
@Add CHAR to scon types
@
text
@d2 4
a5 1
$Log: _simplelambda.sml,v $
d54 1
d67 1
d82 2
d1503 1
a1503 1
		  | _ =>Ident.scon_eqrep(s, s'))
@


1.14
log
@Fix tests for equality of scons to test equality of meaning
@
text
@d3 39
a41 36
# Revision 1.13  1995/05/23  10:08:00  matthew
# Adding optimization to eliminate CASTs
#
# Revision 1.12  1995/05/19  10:49:56  matthew
# Tuple optimization improvements
#
# Revision 1.11  1995/05/03  16:31:05  matthew
# Removing debug_polyvariables option
#
# Revision 1.10  1995/04/26  16:18:14  matthew
# Don't do function lifting when compiling for interceptable code
#
# Revision 1.9  1995/03/17  10:08:51  matthew
# Adding more controls for different optimizations.
#
# Revision 1.8  1995/02/28  12:54:27  matthew
# More debugger stuff
#
# Revision 1.7  1995/01/30  10:48:37  matthew
# Improved interface to debugging stuff
#
# Revision 1.6  1995/01/10  10:56:08  matthew
# Adding strings to VCC_TAG and IMM_TAG
# Added MLVALUE
#
# Revision 1.5  1994/11/15  11:12:59  matthew
# Added some imperative CSE optimization.
# Pass closures of looping functions as parameters
# Lift selections from curried arguments.
#
# Revision 1.4  1994/10/27  11:12:18  matthew
# Fix problem with lifting selections for switched on global expressions.
#
# Revision 1.3  1994/10/17  12:04:33  matthew
# Improved switch weeding and inlineing heuristics
#
d1501 3
a1503 2
               | print_tag (SCON_TAG (Ident.REAL (i,_))) = "INT " ^ i
               | print_tag (SCON_TAG (Ident.STRING s)) = "INT " ^ MLWorks.String.ml_string (s,~1)
@


1.13
log
@Adding optimization to eliminate CASTs
@
text
@d3 3
d1490 4
a1493 1
               | eq_tag (SCON_TAG s,SCON_TAG s') = s = s'
d1574 5
a1578 1
                   | SOME (SCON s) =>
d1604 1
a1604 1
                                       map 
d1606 6
a1611 3
                                       (fn (EXP_TAG te,e') => (EXP_TAG (aux (te,novar,depth,switches)),
                                                               aux(e',novar,depth,switches))
                                         | (t,e') => (t,aux(e',novar,depth,(e,t)::switches)))
@


1.12
log
@Tuple optimization improvements
@
text
@d3 3
d1184 2
a1185 1
fun do_builtinapp ((b,el,ty),env) =
d1232 1
a1282 1

@


1.11
log
@Removing debug_polyvariables option
@
text
@d3 3
a108 24
  (* Some crap for the current signature *)

  val print_hash_table_stats = ref false

  val max_struct_dup   = ref 0
  val max_scon_space   = ref 0
  val max_func_dup     = ref 0
  val code_node_factor = ref 0
  val max_map_fold     = ref 0
  val max_small_size   = ref 0
  val optimise_switches = []

  val show_debug_info            = ref false
  val show_optimisations_applied = ref false
  val show_lambda_code           = ref false
  val show_timings               = ref false
  val check_validity             = ref false
    
  fun show_none () = ()
  fun show_all () = ()
    
  fun turn_on_all () = ()
  fun turn_off_all () = ()

d1309 1
a1309 1
datatype UsesType = APP_USE | OTHER (* OTHER is just a dummy *)
d1312 1
d1318 8
a1325 2
    fun expfun (APP (VAR f,_,_)) =
      IntHashTable.update (table,f,app_use)
d1331 1
a1331 1
    
d1335 1
a1335 3
    fun has_app_use [] = false
      | has_app_use (APP_USE::_) = true
      | has_app_use (_::rest) = has_app_use rest
a1336 2
    val default_uses = []

d1344 8
d1354 3
a1356 1
    fun do_simple (exp,uses,depth,switches) = 
d1366 1
a1366 1
                    orelse (has_app_use uses andalso is_curry_inlineable (body,depth))) (* Only if used for an APP *)
d1379 1
a1379 1
                     aux (alpha (list_to_hashmap (Lists.zip (vars,el)),body),uses,depth+1,switches))
d1389 1
a1389 1
                        aux (BUILTINAPP (builtin,[e2],ty),uses,depth,switches))
d1402 1
a1402 1
                       aux (make_lets  (0,vars,BUILTINAPP (builtin,map VAR vars,ty)),uses,depth,switches)
d1423 1
a1423 1
                   aux (Lists.nth (i,args),uses,depth,switches))
d1429 42
a1470 34
         let
           val def = lookup (v,env)
         in
           (* We don't want to do this when the select is on a function argument *)
           case def of
             SOME (SELECT ({index=0,size=j,selecttype=ty'},e)) =>
               let
                 val len = 1 + Lists.length vl
               in
                 if j = len andalso ty = ty' 
                   then
                     let
                       fun check (n,[]) = true
                         | check (n,v::vl) =
                           case lookup (v,env) of
                             SOME (SELECT ({index=i,size=j,...},e')) =>
                               i = n andalso
                               j = len andalso
                               (* Is this safe? *)
                               exp_eq (e,e') andalso
                               check (n+1,vl)
                           | _ => false
                     in
                       if check (1,vl)
                         then (diag (3, fn () => "Done a struct\n");
                               change();
                               aux (e,uses,depth,switches))
                       else exp
                     end
                 else
                   exp
               end
           | _ => exp
         end
d1473 1
a1473 1
              SOME e => (change(); aux (e,uses,depth,switches))
d1550 1
a1550 1
                   LET ((id,null_debug,aux (e,default_uses,depth,switches)),aux (e',uses,depth,switches))
d1559 1
a1559 1
                        aux (constant_switch_weed (IMM_TAG ("",i),tel,opte),uses,depth,switches))
d1563 1
a1563 1
                        aux (constant_switch_weed (VCC_TAG ("",i),tel,opte),uses,depth,switches))
d1567 1
a1567 1
                        aux (constant_switch_weed (SCON_TAG s,tel,opte),uses,depth,switches))
d1573 1
a1573 1
                             aux (constant_switch_weed (t,tel,opte),uses,depth,switches))
d1583 1
a1583 1
                                unwrap_lets (aux (e',default_uses,depth,switches))
d1592 3
a1594 3
                                       (fn (EXP_TAG te,e') => (EXP_TAG (aux (te,default_uses,depth,switches)),
                                                               aux(e',default_uses,depth,switches))
                                         | (t,e') => (t,aux(e',default_uses,depth,(e,t)::switches)))
d1602 1
a1602 1
                                         optfun (fn e => aux (e,default_uses,depth,switches')) opte
d1609 2
a1610 2
       | HANDLE (e1,e2,s) => HANDLE (aux (e1,default_uses,depth,switches),
                                     aux (e2,default_uses,depth,switches),s)
d1617 1
a1617 1
             val newbody = aux (body,default_uses,depth,switches)
d1633 1
a1633 1
    and merge_lets (x1,i1,LET ((x2,i2,e1),e2),e3,uses,depth,switches) =
d1635 2
a1636 2
       LET ((x2,i2,e1),merge_lets (x1,i1,e2,e3,uses,depth,switches)))
      | merge_lets (x1,i1,e1,e2,uses,depth,switches) =
d1638 6
a1643 6
         LET ((x1,i1,e1),aux (e2,uses,depth,switches)))
    and aux (LET ((x1,i1,LET ((x2,i2,e1),e2)),e3),uses,depth,switches) =
        aux (LET ((x2,i2,e1),(LET ((x1,i1,e2),e3))),uses,depth,switches)
      | aux (LET ((x,i,e1),e2),uses,depth,switches) =
        merge_lets (x,i,do_simple (e1,get_uses x,depth,switches),e2,uses,depth,switches)
      | aux (LETREC (fl,el,e),uses,depth,switches) =
d1650 1
a1650 1
               val e' = aux (e,default_uses,depth,switches)
d1659 1
a1659 1
          LETREC (fl,el',aux (e,uses,depth,switches))
d1661 1
a1661 1
      | aux (e,uses,depth,switches) = do_simple (e,uses,depth,switches)
d1663 1
a1663 1
    aux (e,default_uses,depth,[])
@


1.10
log
@Don't do function lifting when compiling for interceptable code
@
text
@d3 3
d1440 1
a2302 1
                                 debug_polyvariables,
a2303 1
                                 generate_stepper,
d2306 1
a2306 1
    val do_debug = debug_polyvariables orelse generate_stepper orelse generate_moduler
@


1.9
log
@Adding more controls for different optimizations.
@
text
@d3 3
d2298 1
d2307 1
a2307 1
    val do_full = not do_debug andalso not generate_debug_info andalso not debug_variables
@


1.8
log
@More debugger stuff
@
text
@d3 3
d70 1
a70 1
  (* Parameters *)
d73 1
a73 1
  val diag_level = 1
d75 1
a75 1
  val print_level = 0
a79 3
  val do_cse = true
  val max_depth = 4
  val inline_size = 10
d89 11
d418 5
d980 1
a980 1
          val loop_function = Lists.forall is_loop_function fvel
d1043 1
a1701 2
val binding_eliminated = ref false

d1727 11
a1743 1
             binding_eliminated := true;
d1746 1
a1760 1
    (* val _ = output (std_out,pde e ^ "\n") *)
d2078 1
a2078 3
          (if n > 1 
             then diag (1, fn () => (Integer.makestring n ^ " iterations of optimize_all\n"))
           else diag (1, fn () => (Integer.makestring n ^ " iterations of optimize_all\n"));
d2174 1
a2174 1
            else if is_imperative e1'
d2226 1
a2226 1
            else if is_imperative e1'
d2328 1
d2343 1
d2345 1
a2345 1
                val prog = linearize_all (rev defs,e)
d2355 2
a2356 1
        val prog = linearize_all (inline_single_callees (do_full,prog))
@


1.7
log
@Improved interface to debugging stuff
@
text
@d3 3
d61 1
a61 1

d70 1
a70 1
  val diag_level = 0
d486 1
d505 1
a505 1
          val _ = diag (3, fn () => "Found global\n")
d608 112
d721 6
d817 1
a817 1
     return_transform ((bid,null_debug,VAL (FN (fvars,newbody,BODY,name,null_type,null_debug))) :: env))
d867 1
a867 1
    FN ([x],APP (VAR f,[closure,VAR x],NONE),ENTRY,name ^ "<Closure>",null_type,null_debug)
d919 1
a919 1
                    (f,null_debug,VAL (FN([x],fbody',ENTRY,name^"<Entry1>",null_type,null_debug))) :: env'
d1049 2
a1050 2
                      (id,null_debug,VAL (FN([closid,x],entrybody,ENTRY,name^"<Entry1>",null_type,null_debug))) ::
                      (tid,null_debug,VAL (FN (vars,newbody',ENTRY,name^"<Entry2>",null_type,null_debug))) :: 
d1074 3
a1076 1
                    (id,null_debug,VAL (FN([closid,x],newbody',ENTRY,name^"<Entry1>",null_type,null_debug))) :: env'
d1656 1
d1685 2
d1689 1
d1718 1
d1787 1
a1787 1
        SOME r => r := 1 + (!r)
d1820 2
a1821 2
(* This should probably go inside expressions as well to get locally defined functions *)
fun internal_inline_single_callees (prog as (defns,exp)) =
d1824 34
d1859 6
a1864 2
      | get_funnames ((f,_,VAL (FN _)):: l) = 
        (IntHashTable.update (counts, f, ref 0);
a1865 1
      | get_funnames ((_,_,VAL _):: l) = get_funnames l
d1868 1
d1873 1
d1880 2
a1881 2
        SOME (ref 1) => true
      | _ => false
d1885 32
a1916 23
    fun inline (FN (vl,e,b,name,ty,debug)) = FN (vl,(*inline*) e,b,name,ty,debug)
      | inline (SWITCH (e,info,tel,opte)) =
        SWITCH (inline e,
                info,
                map (telfun inline) tel,
                optfun inline opte)
      | inline (HANDLE (e1,e2,s)) = HANDLE (inline e1,inline e2,s)
      | inline (LET ((v,i,e1),e2)) = LET ((v,i,inline e1),inline e2)
      | inline (e as APP (VAR f,el,ty)) =
        if toinline f
          then 
            case hashmap_find (f,env) of
              SOME (VAL (FN (args,body,_,_,_,_))) =>
                if size_less (body,1000) > 0
                  then
                    inline (alpha (list_to_hashmap (Lists.zip (args,el)),body))
                else e
            | _ => crash "APP body not found in inline"
        else
          e
      | inline (e as APP _) = e
      | inline (LETREC (fl,el,e)) = LETREC (fl, map inline el, inline e)
      | inline e = e
d1918 1
a1918 1
    progmap inline prog
d2207 1
a2207 1
                    (ddiag (1, fn () => "Found imperative CSE: " ^ print_exp e1' ^ "\n");
d2246 1
a2246 1
        then crash "Too many iterations of eta lookup"
d2266 1
a2266 1
fun inline_single_callees prog = weed (internal_inline_single_callees prog)
d2271 1
a2271 1
    val Options.COMPILEROPTIONS {debug,
d2276 5
a2280 5
    val do_lifting = not debug andalso not debug_variables
    val do_complex = 
      not debug_polyvariables andalso 
      not generate_stepper andalso 
      not generate_moduler
d2284 3
a2286 3
            if do_lifting then "Full Optimization\n"
            else if do_complex then "Simple Optimization\n"
            else "Debug Optimization")
d2296 1
a2296 1
        val _ = pprint_exp (2,e)
d2298 1
a2298 1
        val e = globalize (e,[],[],true)
d2302 1
a2302 1
          if do_complex
d2310 1
a2310 1
        val _ = pprint_exp (1,e)
d2312 1
a2312 1
          if do_lifting
d2329 29
d2360 1
a2360 1
          if do_complex
a2362 2
                val _ = diag (1,fn () => "Inlining single callees..\n")
                val prog = linearize_all (inline_single_callees prog)
a2365 12
                val prog = 
                  if do_cse 
                    then
                      let 
                        val _ = diag (1, fn () => "Doing Local CSE..\n")
                        val prog = local_cse_all prog
                        val prog = optimize_till_done prog
                        val _ = pprint (2,prog)
                      in
                        prog
                      end
                  else prog
d2369 3
a2371 1
          else prog
d2379 1
a2379 1
          if do_complex
@


1.6
log
@Adding strings to VCC_TAG and IMM_TAG
Added MLVALUE
@
text
@d3 4
d121 3
d1545 3
a1547 1
            if  hashmap_member (x,vars) orelse not (SimpleUtils.safe_elim e1)
d1586 2
a1587 1
        if SimpleUtils.is_atomic e1
d1691 1
d1761 1
a1761 1
    and do_one (i,_,VAL e) = 
d1805 1
a1805 1
      if hashmap_member(a,vars)
d2052 1
a2052 1
        if SimpleUtils.is_atomic e
d2099 11
a2109 2
    val do_complex_stuff = not debug andalso not debug_variables
    val do_anything_at_all = not debug_polyvariables andalso not generate_stepper andalso not generate_moduler
d2111 2
a2112 1
    val _ = diag (1,fn () => if do_complex_stuff then "Full Optimization\n" else "Debug Optimization\n")
d2123 8
a2130 2
        val _ = diag (1,fn () => "Optimizing..\n")
        val e = simplify (e,empty_hashmap (),ref false,0)
d2135 1
a2135 1
          if do_complex_stuff
d2151 4
a2154 7
        val _ = diag (1,fn () => "Inlining single callees..\n")
        val prog = linearize_all (inline_single_callees prog)
        val _ = diag (1,fn () => "Optimizing..\n")
        val prog = optimize_till_done prog
        val _ = pprint (2,prog)
        val prog = 
          if do_cse 
d2156 4
a2159 3
              let 
                val _ = diag (1, fn () => "Doing Local CSE..\n")
                val prog = local_cse_all prog
d2162 12
d2178 1
a2178 1
        val _ = diag (1, fn () => "Doing CSE..\n")
d2184 6
a2189 2
        val _ = diag (1, fn () => "Doing Schedule..\n")
        val prog = schedule_all prog
d2197 1
a2197 3
      if do_anything_at_all 
        then Timer.xtime ("Inner lambda",!print_timings,fn () => make_lamb e)
      else ([],e)
@


1.5
log
@Added some imperative CSE optimization.
Pass closures of looping functions as parameters
Lift selections from curried arguments.
@
text
@d3 5
d180 1
d243 1
d275 1
d1326 2
a1327 2
             fun eq_tag (IMM_TAG i,IMM_TAG i') = i = i'
               | eq_tag (VCC_TAG i,VCC_TAG i') = i = i'
d1330 2
a1331 2
             fun print_tag (IMM_TAG i) = "IMM " ^ MLWorks.Integer.makestring i
               | print_tag (VCC_TAG i) = "VCC " ^ MLWorks.Integer.makestring i
d1363 2
a1364 2
                       | find ((VCC_TAG i,_)::rest,tags,vccs,imms) = find (rest,i::tags,1+vccs,imms)
                       | find ((IMM_TAG i,_)::rest,tags,vccs,imms) = find (rest,i::tags,vccs,1+imms)
d1379 1
a1379 1
                       then SOME (VCC_TAG (find_missing tags))
d1382 1
a1382 1
                         then SOME (IMM_TAG (find_missing tags))
d1404 1
a1404 1
                        aux (constant_switch_weed (IMM_TAG i,tel,opte),uses,depth,switches))
d1408 1
a1408 1
                        aux (constant_switch_weed (VCC_TAG i,tel,opte),uses,depth,switches))
d1555 1
d1652 1
d1758 1
@


1.4
log
@Fix problem with lifting selections for switched on global expressions.
@
text
@d3 3
d58 5
a62 3
  val diag_level = 2
  val print = do_diag andalso false
  val print_result = do_diag andalso true
d342 1
a342 1
  
d344 3
a346 1
  fun find_all_selects (arg,e) =
d356 1
d358 31
d651 1
a651 1
                diag (0, fn _ => "Return transform of " ^ s ^ "\n");
d762 2
d806 23
d890 1
d1263 1
a1263 1
                     then diag (0, 
d1322 6
d1329 1
a1329 1
               | constant_switch_weed (t,[],NONE) = crash "constant switch not found"
d1399 1
a1399 1
                        diag (0,fn _ => "Found VCC constant switch\n");
d1403 1
a1403 1
                        diag (0,fn _ => "Found SCON constant switch\n");
d1579 1
a1579 1
fun pprint p = if print then output(std_out,pds (PROGRAM p) ^ "\n") else ()
d1581 1
a1581 1
fun pprint_exp e = if print then output (std_out,pde e ^ "\n") else ()
d1611 1
a1611 1
    pprint result;
d1828 1
a1828 1
              diag (0,fn _ => "Done " ^ Integer.makestring x ^ "\n");
d1848 1
a1848 1
        val _ = pprint prog
d1908 24
d1937 1
a1937 1
    fun do_let (LET ((x,i,e1),e2),env,substs,acc) =
d1949 12
a1960 4
                     do_let (e2,env,substs,(x,i,VAR x')::acc))
                | NONE => do_let (e2,(x,e1')::env,substs,(x,i,e1')::acc)
            else
              do_let (e2,env,substs,(x,i,e1')::acc)
d1962 2
a1963 1
          do_let (e2,env,substs,(x,i,do_complex (e1',env,substs))::acc)
d1965 3
a1967 3
      | do_let (e,env,substs,acc) =
        wrap_lets (acc,do_complex (e,env,substs))
    and do_complex (SWITCH (e,info,tel,opte),env,substs) =
d1980 2
a1981 2
                map (telfun (fn e => do_let (e,env,substs,[]))) tel,
                optfun (fn e => do_let (e,env,substs,[])) opte)
d1983 32
a2014 9
      | do_complex (HANDLE (e1,e2,s),env,substs) =
        HANDLE (do_let (e1,env,substs,[]),do_let (e2,env,substs,[]),s)
      | do_complex (FN (f,e,v,n,t,d),env,substs) =
        FN (f,do_let (e,env,substs,[]),v,n,t,d)
      | do_complex (LETREC (fl,el,e),env,substs) =
        LETREC (fl,map (fn e => do_let (e,env,substs,[])) el,do_let (e,env,substs,[]))
      | do_complex (LET _,env,substs) = crash "LET in do_complex in CSE"
      | do_complex (e,env,substs) = lsubst (substs,e)
    val result = do_let (exp,[],empty_hashmap (),[])
d2084 1
a2084 1
        val _ = pprint_exp e
d2087 1
a2087 1
        val _ = pprint_exp e
d2090 1
a2090 1
        val _ = pprint_exp e
d2095 1
a2095 1
        val _ = pprint_exp e
d2106 1
a2106 1
                val _ = pprint prog
d2117 1
a2117 1
        val _ = pprint prog
d2124 2
a2125 1
                val _ = pprint prog
d2132 1
a2132 1
        val _ = pprint prog
d2135 1
a2135 1
        val _ = pprint prog
d2138 1
a2138 1
        val _ = pprint prog
@


1.3
log
@Improved switch weeding and inlineing heuristics
@
text
@d3 3
d410 11
d425 1
@


1.2
log
@All kinds of stuff
@
text
@d1 4
d59 1
d66 3
d157 39
d197 2
a198 1
  (* Function bodies we are prepared to inline *)
d206 1
d208 6
a213 4
  fun is_curry_inlineable (LET ((_,_,e1),FN (_,e2,_,_,_,_))) =
    is_inlineable e1 andalso is_curry_inlineable e2
    | is_curry_inlineable (FN (_,e,_,_,_,_)) = is_curry_inlineable e
    | is_curry_inlineable e = is_inlineable e
d215 1
d217 2
a218 2
    fn e =>
    if is_curry_inlineable e
d222 1
d1122 1
a1122 1
    fun do_simple (exp,uses,depth) = 
d1131 2
a1132 2
                   (status = ENTRY orelse is_inlineable body
                    orelse (has_app_use uses andalso is_curry_inlineable body)) (* Only if used for an APP *)
d1145 1
a1145 1
                     aux (alpha (list_to_hashmap (Lists.zip (vars,el)),body),uses,depth+1))
d1155 1
a1155 1
                        aux (BUILTINAPP (builtin,[e2],ty),uses,depth))
d1168 1
a1168 1
                       aux (make_lets  (0,vars,BUILTINAPP (builtin,map VAR vars,ty)),uses,depth)
d1189 1
a1189 1
                   aux (Lists.nth (i,args),uses,depth))
d1220 1
a1220 1
                               aux (e,uses,depth))
d1230 1
a1230 1
              SOME e => (change(); aux (e,uses,depth))
d1233 4
d1238 8
a1245 4
             fun constant_switch_weed (i,[],SOME e) = e
               | constant_switch_weed (i,[],NONE) = crash "constant switch not found"
               | constant_switch_weed (i,((IMM_TAG i',e)::rest),opte) =
                 if i = i'
d1247 1
a1247 3
                 else constant_switch_weed (i,rest,opte)
               | constant_switch_weed (i,(_::rest),opte) =
                 constant_switch_weed (i,rest,opte)
d1250 3
a1252 3
                 fun aux (e,[]) = SOME e
                   | aux (e,(e'::l)) = 
                     if exp_eq (e,e') then aux (e,l) else NONE
d1255 2
a1256 2
                   (_,SOME e) => aux (e,map #2 tel)
                 | (((t,e)::rest),NONE) => aux (e, map #2 rest)
d1259 34
d1301 1
a1301 1
                   LET ((id,null_debug,aux (e,default_uses,depth)),aux (e',uses,depth))
d1310 9
a1318 1
                        aux (constant_switch_weed (i,tel,opte),uses,depth))
d1320 37
a1356 17
                       let
                         val e' = 
                           case edef of
                             SOME e' => 
                               if SimpleUtils.switchable_expr e' then e'
                                 else e
                           | _ => e
                         val (e'',lets) =
                           unwrap_lets (aux (e',default_uses,depth))
                       in
                         wrap_lets (lets,
                                    SWITCH (e'',
                                            info,
                                            (* Maybe we should carry the uses over *)
                                            map (telfun (fn e => aux(e,default_uses,depth))) tel,
                                            optfun (fn e => aux (e,default_uses,depth)) opte))
                       end
d1360 2
a1361 1
       | HANDLE (e1,e2,s) => HANDLE (aux (e1,default_uses,depth),aux (e2,default_uses,depth),s)
d1368 1
a1368 1
             val newbody = aux (body,default_uses,depth)
d1384 1
a1384 1
    and merge_lets (x1,i1,LET ((x2,i2,e1),e2),e3,uses,depth) =
d1386 2
a1387 2
       LET ((x2,i2,e1),merge_lets (x1,i1,e2,e3,uses,depth)))
      | merge_lets (x1,i1,e1,e2,uses,depth) =
d1389 6
a1394 6
         LET ((x1,i1,e1),aux (e2,uses,depth)))
    and aux (LET ((x1,i1,LET ((x2,i2,e1),e2)),e3),uses,depth) =
        aux (LET ((x2,i2,e1),(LET ((x1,i1,e2),e3))),uses,depth)
      | aux (LET ((x,i,e1),e2),uses,depth) =
        merge_lets (x,i,do_simple (e1,get_uses x,depth),e2,uses,depth)
      | aux (LETREC (fl,el,e),uses,depth) =
d1401 1
a1401 1
               val e' = aux (e,default_uses,depth)
d1410 1
a1410 1
          LETREC (fl,el',aux (e,uses,depth))
d1412 1
a1412 1
      | aux (e,uses,depth) = do_simple (e,uses,depth)
d1414 1
a1414 1
    aux (e,default_uses,depth)
d1623 4
a1626 1
                inline (alpha (list_to_hashmap (Lists.zip (args,el)),body))
@


1.1
log
@new file
@
text
@d2 1
d5 1
d7 1
d17 1
d21 1
d24 1
d29 1
d31 1
a31 1
                      sharing type TransSimple.SimpleTypes.Type = Types.Datatypes.Type
d33 1
a33 1
                      sharing IdentPrint.Ident = TransSimple.SimpleTypes.Ident
d37 1
a37 2
  structure Pervasives = SimpleTypes.Pervasives
  structure Ident = SimpleTypes.Ident
a40 1
  structure LambdaTypes = TransSimple.LambdaTypes
d42 3
d47 4
a50 3
  val diag_level = 0
  val print = false
  val print_result = false
d53 7
a59 4
(* Setting late_closures to true seems far worse than I would expect *)
(* Why should this be? *)
  val late_closures = false
  val do_cse = false
a84 3
  (* Used for equality handling *)
  (* This should do a little more *)

d92 1
a92 5
  fun diag (level,f) = if level <= diag_level  then output(std_out,f()) else ()

  exception Error of string

  fun crash s = (output (std_out,s ^ "\n"); raise Error s)
d134 15
a148 7
  fun lookup (VAREXP v,defns) = 
    ((* diag (5, fn () => "Lookup of " ^ MLWorks.Integer.makestring v ^ "\n"); *)
     case hashmap_find (v,defns) of
       SOME (VAL (e as VAREXP _)) => lookup (e,defns)
     | SOME (VAL e) => SOME e
     | x => NONE)
    | lookup (e,_) = SOME e
d151 1
a151 1
  fun (* is_inlineable (LET (_,e1,LET (_,e2,LET (_,e3,e4)))) = 
d154 1
a154 1
    | *) is_inlineable (LET (_,e1,(LET (_,e2,e3)))) = 
d156 1
a156 1
    | is_inlineable (LET (_,e1,e2)) = SimpleUtils.is_simple e1 andalso SimpleUtils.is_simple e2
d159 1
a159 1
  fun is_curry_inlineable (LET (_,e1,FN (_,_,_,e2))) =
d161 1
a161 1
    | is_curry_inlineable (FN (_,_,_,e)) = is_curry_inlineable e
d175 3
a177 3
        | aux (e as SCONEXP _) = e
        | aux (e as BOP _) = e
        | aux (e as VAREXP v) =
d182 5
a186 5
        | aux (FN (args,status,name,e)) = FN (args,status,name,aux e)
        | aux (LETREC (fvel,e)) =
          LETREC (map (fn (f,vl,name,e) => (f,vl,name,aux e)) fvel,aux e)
        | aux (BOPAPP(b,el,ty)) = BOPAPP(b,map aux el,ty)
        | aux (STRUCT el) = STRUCT (map aux el)
d192 1
a192 1
        | aux (HANDLE (e1,e2)) = HANDLE(aux e1,aux e2)
d194 3
a196 3
        | aux (SELECT (i,j,e)) = SELECT (i,j,aux e)
        | aux (LET (v,e1,e2)) =
          LET(v,aux e1,aux e2)
d201 1
a201 2
  (* Simultaneous substitution of a list of variables *)
  (* Substitute a list of expressions for a list of variables *)
d206 3
a208 3
        | aux (e as SCONEXP _) = e
        | aux (e as BOP _) = e
        | aux (e as VAREXP v) =
d213 2
a214 2
        | aux (BOPAPP(b,el,ty)) = BOPAPP(b,map aux el,ty)
        | aux (STRUCT el) = STRUCT (map aux el)
d220 1
a220 1
        | aux (HANDLE (e1,e2)) = HANDLE(aux e1,aux e2)
d222 2
a223 2
        | aux (SELECT (i,j,e)) = SELECT (i,j,aux e)
        | aux (LET (v,e1,e2)) =
d227 1
a227 1
            val _ = IntHashTable.update (binds,v,VAREXP v')
d229 1
a229 1
            LET(v',e1',aux e2)
d231 1
a231 1
        | aux (FN (vl,status,name,body)) = 
d236 1
a236 1
              (fn (v,v') => IntHashTable.update (binds,v,VAREXP v'))
d239 11
a249 1
            FN (map #2 new_vl,status,name,aux body)
a250 1
        | aux (LETREC (fvel,e)) = crash "LETREC in alpha"
d258 2
a259 2
    | wrap_lets ((v,e)::vel,e') =
      wrap_lets (vel, LET (v,e,e'))
d263 2
a264 2
      fun aux (LET (v,e1,e2),acc) =
        aux (e2,(v,e1)::acc)
d273 1
a273 1
      fun find (e as LET (v,e' as SELECT (_,_,VAREXP v'),body), acc) =
d275 1
a275 1
          then find (body,(v,e')::acc)
d285 1
a285 1
      fun find (vars,e as LET (v,e' as SELECT (_,_,VAREXP v'),body), acc) =
d287 1
a287 1
          then find (v::vars,body,(v,e')::acc)
d295 1
a295 1
  fun get_returned_exp (LET (_,_,e)) = get_returned_exp e
d301 1
a301 1
      fun aux (LET(v,e1,e2)) = LET(v,e1,aux e2)
d310 2
a311 2
    fun letmap_aux (LET (x,e1,e2),acc) = 
      letmap_aux (e2,(x,letmap expfun e1)::acc)
d323 1
a323 1
      | letmap_aux (HANDLE (e1,e2),acc) =
d325 6
a330 5
                   HANDLE (letmap expfun e1,letmap expfun e2))
      | letmap_aux (FN (vl,b,name,e),acc) =
        wrap_lets (acc, FN (vl,b,name,letmap expfun e))
      | letmap_aux (LETREC (fvel,e),acc) =
        wrap_lets (acc, (LETREC (map (fn (f,vl,name,e) => (f,vl,name,letmap expfun e)) fvel,letmap expfun e)))
d339 2
a340 2
    fun aux (LET (v,e1,e2)) = (aux e1; aux e2)
      | aux (FN (vl,_,_,e)) = aux e
d346 3
a348 4
      | aux (HANDLE (e1,e2)) = (aux e1; aux e2)
      | aux (LETREC (fvel,e)) = 
        (Lists.iterate (fn (a,b,c,e) => aux e);
         aux e)
d366 1
a366 1
and globalize' (LET (v,e1,e2),env,dyn_vars,true) =
d370 1
a370 1
    globalize' (e2,(v,e1')::env',dyn_vars,true)
d372 1
a372 1
  | globalize' (LET (v,e1,e2),env,dyn_vars,false) =
d381 1
a381 1
          globalize' (e2, (v,e1')::env',dyn_vars,false)
d387 1
a387 1
        (LET (v,e1',e2'),env'')
d390 1
a390 1
  | globalize' (FN ([x],status,name,body),env,dyn_vars,global) = 
d399 1
a399 1
          (FN ([x],status,name,body'),env)
d405 1
a405 1
          (FN ([x],BODY,name,body'),env')
d408 1
a408 1
  | globalize' (LETREC (fvel,body),env,dyn_vars,global) =
d410 1
a410 1
      val fnnames = map #1 fvel
d412 1
a412 1
      fun do_fvel ((f,vl,name,e)::rest,env,acc) =
d416 1
a416 1
          do_fvel (rest,env',(f,vl,name,e')::acc)
d418 3
a420 2
      | do_fvel ([],env,acc) = (rev acc,env)
      val (fvel',env') = do_fvel (fvel,env,[])
d423 1
a423 1
      (LETREC (fvel',body'),env'')
d456 1
a456 1
  | globalize' (HANDLE (e1,e2),env,dyn_vars,global) =
d461 1
a461 1
      (HANDLE (e1',e2'),env'')
d471 1
a471 1
          (VAREXP new_var,(new_var,e)::env)
d491 1
a491 1
        val varargs = map VAREXP vars'
d493 2
a494 2
        (id,FUN (vars,ENTRY,s ^ "<Case entry>",SWITCH (VAREXP v,info,[(t,e)],SOME (APP (VAREXP bid,varargs))))) ::
        (bid,FUN (vars',status,s,body)) :: env
d498 1
a498 1
      SWITCH (VAREXP v,info,[(t1,e1)], SOME e2) =>
d504 1
a504 1
    | SWITCH (VAREXP v,info,[(t1,e1),(t2,e2)],NONE) =>
d519 3
a521 1
fun return_transform (arg as ((id,VAL (FN (vars,status,s,body))) :: env)) =
d533 1
a533 1
              FN ([x],_,_,APP (VAREXP f,[VAREXP v,VAREXP x'],_)) => 
d535 1
a535 1
            | STRUCT [VAREXP v] => SOME v
d545 2
a546 2
                (id,VAL (FN(vars,BODY,s ^ "<Ret>",LET (v,APP(VAREXP bid,map VAREXP vars,nulltype),returned_exp)))) ::
                (case_transform ((bid,VAL (FN (vars,status,s,sub_returned_exp(VAREXP v,body)))) :: env))
d554 3
d563 1
d571 3
a573 2
    (wrap_lets (selects,APP (VAREXP bid,map VAREXP fvars,nulltype)),
     return_transform ((bid,VAL (FN (fvars,BODY,name,newbody))) :: env))
d576 2
d585 1
a585 1
      map (fn var => (var, SELECT (next(),len,VAREXP closid))) vars
d594 1
a594 1
    val closexp = VAREXP closid
d597 1
a597 1
        LET (v,SELECT (n,len,closexp),
d613 1
a613 1
      map (fn var => (var, SELECT (next(),len,VAREXP closid))) vars
d623 1
a623 1
    FN ([x],ENTRY,name ^ "<Closure>",APP (VAREXP f,[closure,VAREXP x],NONE))
d629 1
a629 1
fun transform (FN ([x],status,name,body),env,dyn_vars,global) = 
d638 1
a638 1
         (VAREXP id, (id,FUNCTOR (x,name,(rev env',body'))) :: env)
d645 1
a645 1
         transform (LETREC ([(f,[x],name,body)],VAREXP f),env,dyn_vars,global)
d648 1
a648 1
  | transform (LETREC (fvel,body),env,dyn_vars,global) =
d650 5
d656 1
a656 1
      val fvars = SimpleUtils.freevars (LETREC (fvel,INT 0),dyn_vars)
d673 1
a673 1
                    (f,VAL (FN([x],ENTRY,name^"<Entry1>",fbody'))) :: env'
d688 1
a688 1
              fun expaux (e as APP (VAREXP f,[y],ty)) =
d690 1
a690 1
                   SOME f' => APP(VAREXP f',[closexpr,y],make_call_ty ty)
d710 2
a711 2
          fun get_num_args (f,[v],_,e as LET (_,SELECT (_,len,VAREXP v'),_)) =
            if v = v' then len else if SimpleUtils.occurs (v,e) then 1 else 0
d718 1
a718 1
          val fvel = map (fn (f,vl,name,e) => (f,vl,name,letrec_trans (e, funmap,VAREXP closid))) fvel
d722 1
a722 1
              val dummy_body = STRUCT (map (fn (f,vl,name,e)=> e) fvel)
d739 1
a739 1
                   (fn ((f,f'),name) => (f,make_closure (f',VAREXP closid,name)))
d746 1
a746 1
            letmap (fn (e as APP(VAREXP id,[VAREXP c,y],nulltype)) =>
d749 1
a749 1
                        APP(VAREXP (varassoc' (id,idtids)),((map VAREXP fvars)@@[y]),nulltype)
d776 2
a777 2
                             APP(VAREXP tid,[VAREXP y,VAREXP x],nulltype))
                        | _ => make_select (fvars,closid,APP(VAREXP tid,map VAREXP vars,nulltype))
d779 2
a780 2
                      (id,VAL (FN([closid,x],ENTRY,name^"<Entry1>",entrybody))) ::
                      (tid,VAL (FN (vars,ENTRY,name^"<Entry2>",newbody'))) :: 
d790 1
a790 1
                  fun insert_select (e as LET (v,e1 as SELECT (_,_,VAREXP id),e2)) =
d793 1
a793 1
                     else LET (v,e1,insert_select e2))
d804 1
a804 1
                    (id,VAL (FN([closid,x],ENTRY,name^"<Entry1>",newbody'))) :: env'
d813 1
a813 1
              LET (f,make_closure (id,closexp,name),make_lets (l,closexp,e))
d817 3
a819 3
              [x] => VAREXP x 
            | _ => STRUCT (map VAREXP fvars)
          val body' = letrec_trans (body,funmap,VAREXP closid)
d824 2
a825 2
          (LET (closid,clos_expression,
                make_lets (funnamemap,VAREXP closid,body''')),
d829 6
a834 5
  | transform (LET (v,e1 as FN (vl,BODY,name,body),e2),env,dyn_vars,global) =
    transform (LETREC ([(v,vl,name,body)],e2),env,dyn_vars,global)
  | transform (LET (v,e1 as FN (vl,ENTRY,name,body),e2),env,dyn_vars,global) =
    transform (LETREC ([(v,vl,name,body)],e2),env,dyn_vars,global)
  | transform (LET (v,e1,e2),env,dyn_vars,true) =
d837 1
a837 1
      val (e2',env'') = transform(e2,(v,VAL e1')::env',dyn_vars,true)
d841 1
a841 1
  | transform (LET (v,e1,e2),env,dyn_vars,false) =
d844 4
a847 4
      fun diddle_lets (LET (v1,LET (v2,e2,e1),body)) =
        diddle_lets (LET (v2,e2,LET(v1,e1,body)))
        | diddle_lets (LET (v1,e1,body)) =
          LET (v1,e1,diddle_lets body)
d853 1
a853 1
        (diddle_lets (LET (v,e1',e2')),env'')
d879 1
a879 1
  | transform (HANDLE (e1,e2),env,dyn_vars,global) =
d884 1
a884 1
      (HANDLE (e1',e2'),env'')
d895 1
a895 1
    map (fn (var,dec) => (var,decfun dec)) declist
d907 1
a907 1
fun do_bopapp ((b,el,ty),env) =
d926 1
a926 1
      | SOME (e as SCONEXP _) => e
d935 1
a935 1
      | foldable _ = SimpleUtils.safe_cse (BOPAPP (b,el,ty))
d938 5
a942 1
      SCONEXP (Ident.INT (Integer.makestring n,Location.UNKNOWN))
d944 18
a961 6
      SCONEXP (Ident.STRING s)
    fun try_fold (Pervasives.ORD,[SCONEXP (Ident.STRING s)]) =
      SOME (make_int_scon (ord s))
      | try_fold (Pervasives.CHR,[SCONEXP (Ident.INT (n,_))]) =
        SOME (make_string_scon (chr (Integer.parseinteger n)))
      | try_fold (Pervasives.HAT,[SCONEXP (Ident.STRING s1),SCONEXP (Ident.STRING s2)]) =
d963 1
a963 1
      | try_fold (Pervasives.SIZE,[SCONEXP (Ident.STRING s)]) =
d965 22
a986 24
      | try_fold (Pervasives.INTPLUS,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (make_int_scon (Integer.parseinteger n1 + Integer.parseinteger n2))
      | try_fold (Pervasives.INTSTAR,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (make_int_scon (Integer.parseinteger n1 * Integer.parseinteger n2))
      | try_fold (Pervasives.DIV,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (make_int_scon (Integer.parseinteger n1 div Integer.parseinteger n2))
      | try_fold (Pervasives.MOD,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (make_int_scon (Integer.parseinteger n1 mod Integer.parseinteger n2))
      | try_fold (Pervasives.INTMINUS,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (make_int_scon (Integer.parseinteger n1 - Integer.parseinteger n2))
      | try_fold (Pervasives.INTLESS,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (INT (if Integer.parseinteger n1 < Integer.parseinteger n2 then 1 else 0))
      | try_fold (Pervasives.INTGREATEREQ,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (INT (if Integer.parseinteger n1 >= Integer.parseinteger n2 then 1 else 0))
      | try_fold (Pervasives.INTEQ,
                  [SCONEXP (Ident.INT (n1,_)),SCONEXP (Ident.INT (n2,_))]) =
        SOME (INT (if Integer.parseinteger n1 = Integer.parseinteger n2 then 1 else 0))
d988 1
a988 1
    fun try_simplify (Pervasives.DIV,[e,SCONEXP (Ident.INT (n,l))]) =
d993 1
a993 1
          SOME j => SOME (BOPAPP (Pervasives.ARSHIFT,[e,make_int_scon j],ty))
d996 1
a996 1
      | try_simplify (Pervasives.MOD,[e,SCONEXP (Ident.INT (n,l))]) =
d1001 1
a1001 1
            SOME j => SOME (BOPAPP (Pervasives.ANDB,[e,make_int_scon (i-1)],ty))
d1008 4
a1011 4
      | try_simplify (Pervasives.INTSTAR,[e,SCONEXP (Ident.INT ("2",l))]) =
        SOME (BOPAPP (Pervasives.INTPLUS,[e,e],ty))
      | try_simplify (Pervasives.INTSTAR,[SCONEXP (Ident.INT ("2",l)),e]) =
        SOME (BOPAPP (Pervasives.INTPLUS,[e,e],ty))
d1014 1
d1016 16
a1031 14
    if not (foldable b) 
      then NONE
    else
      let
        val args = map get_val el
        val result = try_fold (b,args)
        val _ =
          case result of
            SOME e => diag (3,fn () => "Folded " ^ print_exp (BOPAPP (b,args,ty)) ^ "\n")
          | NONE => diag (2,fn () => "CONSTANT " ^ print_exp (BOPAPP (b,args,ty)) ^ "\n");
      in
        result
      end
      handle Foo => try_simplify (b,el)
d1043 1
a1043 1
    fun expfun (APP (VAREXP f,_,_)) =
d1051 1
a1051 1
fun simplify (e,env) =
d1053 1
d1069 1
a1069 1
    fun do_simple (exp,uses) = 
d1076 4
a1079 3
               SOME (FN (vars,status,_,body)) =>
                 if status = ENTRY orelse is_inlineable body
                   orelse (has_app_use uses andalso is_curry_inlineable body) (* Only if used for an APP *)
d1086 1
a1086 1
                                   VAREXP f => print_var f 
d1091 2
a1092 1
                     aux (alpha (list_to_hashmap (Lists.zip (vars,el)),body),uses))
d1094 1
a1094 1
             | SOME (BOP bop) =>
d1096 2
a1097 2
                   val e2 = case el of [e2] => e2 | _ => crash "Multiarg APP of BOP"
                   val arity = SimpleUtils.get_arity bop
d1100 3
a1102 1
                     then aux (BOPAPP (bop,[e2],ty),uses)
d1109 1
a1109 1
                           LET (var,SELECT (n,arity,e2),
d1113 3
a1115 2
                       diag (3, fn () => "Done a bopapp\n");
                       aux (make_lets  (0,vars,BOPAPP (bop,map VAREXP vars,ty)),uses)
d1122 1
a1122 1
       | SELECT (i,j,e) =>
d1127 10
a1136 3
                SOME (STRUCT args) => 
                  (diag (3, (fn () => "Done a select on " ^ print_exp (SELECT(i,j,e)) ^ "\n"));
                   aux (Lists.nth (i,args),uses))
d1140 2
a1141 2
               (output (std_out,"Bad Select: " ^ print_exp (SELECT(i,j,e)) ^ "\n");exp))
       | STRUCT (v::vl) =>
d1146 1
a1146 1
             SOME (SELECT (0,j,e)) =>
d1150 1
a1150 1
                 if j = len
d1156 1
a1156 1
                             SOME (SELECT (i,j,e')) =>
d1159 2
a1160 1
                               e' = e andalso
d1166 2
a1167 1
                               aux (e,uses))
d1175 3
a1177 3
       | BOPAPP (b,el,ty) => 
           (case do_bopapp ((b,el,ty),env) of
              SOME e => aux (e,uses)
d1205 1
d1208 1
a1208 1
                   LET (id,aux (e,default_uses),aux (e',uses))
d1211 26
a1236 14
                 (case lookup (e,env) of
                    SOME (INT i) =>
                      aux (constant_switch_weed (i,tel,opte),uses)
                  | _ => 
                      let
                        val (e',lets) = unwrap_lets (aux (e,default_uses))
                      in
                        wrap_lets (lets,
                                   SWITCH (e',
                                           info,
                                           (* Maybe we should carry the uses over *)
                                           map (telfun (fn e => aux(e,default_uses))) tel,
                                           optfun (fn e => aux (e,default_uses)) opte))
                      end)
d1239 2
a1240 2
       | HANDLE (e1,e2) => HANDLE (aux (e1,default_uses),aux (e2,default_uses))
       | FN (vl,status,name,body) => 
d1242 5
a1246 1
             val newbody = aux (body,default_uses)
d1250 1
a1250 1
                   if el = map VAREXP vl then SOME f else NONE
d1254 2
a1255 2
               SOME e => (diag (2,fn _ => "Found eta\n"); e)
               | _ => FN (vl,status,name,newbody)
d1258 1
a1258 1
       | LET (x,e1,e2) => crash "NotLinearized: let"
d1262 1
a1262 1
    and merge_lets (x1,LET (x2,e1,e2),e3,uses) =
d1264 2
a1265 2
       LET (x2,e1,merge_lets (x1,e2,e3,uses)))
      | merge_lets (x1,e1,e2,uses) =
d1267 6
a1272 6
         LET (x1,e1,aux (e2,uses)))
    and aux (LET (x1,LET (x2,e1,e2),e3),uses) =
        aux (LET (x2,e1,(LET (x1,e2,e3))),uses)
      | aux (LET (x,e1,e2),uses) =
        merge_lets (x,do_simple (e1,get_uses x),e2,uses)
      | aux (LETREC (fvel,e),uses) =
d1274 1
a1274 1
          val fvel' =
d1276 2
a1277 1
            (fn (f,vl,n,e) => 
d1279 3
a1281 2
               val e' = aux (e,default_uses)
               val _ = IntHashTable.update (env,f,VAL (FN (vl,BODY,n,e')))
d1283 4
a1286 3
               (f,vl,n,e')
             end)
            fvel
d1288 1
a1288 1
          LETREC (fvel',aux (e,uses))
d1290 1
a1290 1
      | aux (e,uses) = do_simple (e,uses)
d1292 1
a1292 1
    aux (e,default_uses)
d1306 2
a1307 2
      | HANDLE (e1,e2) => HANDLE (do_let e1,do_let e2)
      | FN (vl,status,name,e) => FN (vl,status,name,do_let e)
d1309 1
a1309 8
      | LETREC (fvel,e) =>
          let
            val e' = do_let e
            val fvel' = 
              map (fn (f,vl,n,body) => (f,vl,n,do_let body)) fvel
          in
            LETREC (fvel',e')
          end
d1318 1
a1318 1
        LET (x,e1,e2) =>
d1323 1
a1323 1
              then LET (x,do_simple e1,e2')
d1338 3
a1340 3
        | aux (e as SCONEXP _) = e
        | aux (e as BOP _) = e
        | aux (e as VAREXP v) =
d1345 5
a1349 5
        | aux (FN (args,status,name,e)) = FN (args,status,name,aux e)
        | aux (LETREC (fvel,e)) =
          LETREC (map (fn (f,vl,name,e) => (f,vl,name,aux e)) fvel,aux e)
        | aux (BOPAPP(b,el,ty)) = BOPAPP(b,map aux el,ty)
        | aux (STRUCT el) = STRUCT (map aux el)
d1355 1
a1355 1
        | aux (HANDLE (e1,e2)) = HANDLE(aux e1,aux e2)
d1357 3
a1359 17
        | aux (SELECT (i,j,e)) = SELECT (i,j,aux e)
        (* Nasty stuff to inline comparisons in switches *)
        (* This isn't the best place for this, but there you go *)
        | aux (LET (v,e1,e2 as SWITCH (VAREXP v',info,tel,opte))) =
          if v = v' andalso
            SimpleUtils.is_simple e1 andalso 
            not (SimpleUtils.occurs (v, SWITCH (INT 0,info,tel,opte)))
            then aux (SWITCH (e1,info,tel,opte))
          else do_let (v,e1,e2)
        | aux (LET (v,e1,e2 as LET (v2,SWITCH (VAREXP v3,info,tel,opte),body))) =
          if v = v3 andalso 
            SimpleUtils.is_simple e1 andalso
            not (SimpleUtils.occurs (v,STRUCT [SWITCH (INT 0,info,tel,opte),body]))
            then aux (LET (v2,SWITCH (e1,info,tel,opte),body))
          else do_let (v,e1,e2)
        | aux (LET (v,e1,e2)) = do_let (v,e1,e2)
      and do_let (v,e1,e2) =
d1364 1
a1364 1
        else LET(v,aux e1,aux e2)
d1388 1
a1388 1
    fun decfun (VAL (FN (a,b,c,e))) = VAL (FN (a,b,c,f e))
d1393 1
a1393 1
    (map (fn (var,dec) => (var,decfun dec)) declist,
d1415 1
a1415 1
        Lists.iterate (fn (var,dec) => 
d1425 1
a1425 1
(* And finally -- inline objects only used once *)
d1434 6
a1439 6
      | aux (SCONEXP _) = ()
      | aux (BOP _) = ()
      | aux (VAREXP x) = inc_var x
      | aux (FN (vl,_,_,e)) = aux e
      | aux (BOPAPP (b,el,_)) = Lists.iterate aux el
      | aux (STRUCT el) = Lists.iterate aux el
d1445 1
a1445 1
      | aux (HANDLE (e1,e2)) = (aux e1; aux e2)
d1447 4
a1450 4
      | aux (SELECT (i,j,e)) = aux e
      | aux (LET (v,e1,e2)) = (aux e1; aux e2)
      | aux (LETREC _) = crash "Letrec in count_occurrences"
      | aux (APP (VAREXP x,el,_)) = (inc_var x; Lists.iterate aux el)
d1452 3
a1454 3
    fun decfun (_,VAL (FN (_,_,_,e))) = aux e
      | decfun (_,VAL e) = aux e
      | decfun (_,FUNCTOR (var,_,prog)) =
d1467 1
a1467 1
      | get_funnames ((f,VAL (FN _)):: l) = 
d1470 2
a1471 2
      | get_funnames ((_,VAL _):: l) = get_funnames l
      | get_funnames ((f,FUNCTOR (x,name,(declist,e)))::l) =
d1487 2
a1488 1
    fun inline (FN (vl,b,name,e)) = FN (vl,b,name,inline e)
d1494 3
a1496 3
      | inline (HANDLE (e1,e2)) = HANDLE (inline e1,inline e2)
      | inline (LET (v,e1,e2)) = LET (v,inline e1,inline e2)
      | inline (e as APP (VAREXP f,el,ty)) =
d1500 1
a1500 1
              SOME (VAL (FN (args,_,_,body))) =>
d1506 1
a1506 1
      | inline (LETREC _) = crash "Letrec in inline"
d1529 1
a1529 1
    and do_one (i,VAL e) = 
d1536 5
a1540 5
      | aux (SCONEXP _) = ()
      | aux (BOP _) = ()
      | aux (VAREXP var) = do_var var
      | aux (BOPAPP (b,el,_)) = laux el
      | aux (STRUCT el) = laux el
d1547 1
a1547 1
      | aux (HANDLE (e1,e2)) = (aux e1;aux e2)
d1549 2
a1550 2
      | aux (SELECT (i,j,e)) = aux e
      | aux (LET (v,e1,e2)) = (aux e1;aux e2)
d1552 2
a1553 2
      | aux (FN (vl,status,name,e)) = aux e
      | aux _ = crash "Bad exp in used_globals"
d1558 2
d1563 1
a1563 1
    while !todo <> [] do aux (pop());
d1571 1
a1571 1
    fun strip ((def as (a,VAL e))::rest,acc) =
d1578 2
a1579 2
      | strip ((a,FUNCTOR (var,name,(defns,exp))) :: rest,acc) =
        strip (rest,(a,FUNCTOR (var,name,(strip (defns,[]),exp))) :: acc)
d1589 12
a1600 4
      | globify_aux ((a,VAL (LET (v,e1,e2))) :: l,acc) =
        globify_aux ((a,VAL e2)::l,(v,VAL e1)::acc)
      | globify_aux ((a,FUNCTOR (v,name,prog)) :: l,acc) =
        globify_aux (l,(a,FUNCTOR (v,name,globify prog))::acc)
d1607 1
a1607 1
fun optimize_all (prog,env) =
d1609 1
d1612 1
a1612 1
        fun decfun (x,VAL e) = 
d1614 1
a1614 1
              val new = VAL (simplify (e,env))
d1617 2
a1618 1
              (x,new)
d1620 2
a1621 2
          | decfun (f,FUNCTOR (var,name,prog)) =
            (f,FUNCTOR (var,name,aux prog))
d1624 1
a1624 1
         simplify (exp,env))
d1626 1
d1628 1
a1628 1
    aux prog
d1638 1
a1638 1
        val prog' = globify (optimize_all (prog,env))
d1641 6
a1646 7
        if prog' = prog
          then
            (if n > 1 
               then diag (1, fn () => (Integer.makestring n ^ " iterations of optimize_all\n"))
             else diag (1, fn () => (Integer.makestring n ^ " iterations of optimize_all\n"));
             weed (progmap cleanup prog'))
        else aux (prog',n+1)
d1658 1
a1658 1
      | aux ((v,VAL (FN(args,s,n,e))) :: l,acc,substs,env) =
d1662 1
a1662 1
          aux (l,(v,VAL (FN(args,s,n,e')))::acc,substs,env)
d1664 1
a1664 2
      | aux ((v,VAL e) :: l,acc,substs,env) =
        (* Eliminate atomic bindings too *)
d1670 1
a1670 1
            then aux (l,(v,VAL e')::acc,substs,env)
d1675 1
a1675 1
                 IntHashTable.update (substs,v,VAREXP v');
d1680 1
a1680 1
                    aux (l,(v,VAL e')::acc,substs,(v,e')::env)
d1682 1
a1682 1
                  aux (l,(v,VAL e')::acc,substs,env)
d1684 1
a1684 1
      | aux ((v,FUNCTOR(arg,name,(defs,exp))) :: rest,acc,substs,env) =
d1689 1
a1689 1
          aux (rest,(v,FUNCTOR (arg,name,(defs',exp')))::acc,substs,env)
d1702 1
a1702 1
    fun do_let (LET (x,e1,e2),env,substs,acc) =
d1712 4
a1715 4
                    (diag (2, fn () => "Found CSE: " ^ print_exp e1' ^ "\n");
                     IntHashTable.update (substs,x,VAREXP x');
                     do_let (e2,env,substs,(x,VAREXP x')::acc))
                | NONE => do_let (e2,(x,e1')::env,substs,(x,e1')::acc)
d1717 1
a1717 1
              do_let (e2,env,substs,(x,e1')::acc)
d1719 1
a1719 1
          do_let (e2,env,substs,(x,do_complex (e1,env,substs))::acc)
d1724 21
a1744 11
      SWITCH (lsubst (substs,e),
              info,
              map (telfun (fn e => do_let (e,env,substs,[]))) tel,
              optfun (fn e => do_let (e,env,substs,[])) opte)
      | do_complex (HANDLE (e1,e2),env,substs) =
        HANDLE (do_let (e1,env,substs,[]),do_let (e2,env,substs,[]))
      | do_complex (FN (f,v,n,e),env,substs) =
        FN (f,v,n,do_let (e,env,substs,[]))
      | do_complex (LETREC (fvel,e),env,substs) =
        LETREC (map (fn (a,b,c,e) => (a,b,c,do_let (e,env,substs,[]))) fvel,
                do_let (e,env,substs,[]))
d1747 1
a1747 1
    val result =     do_let (exp,[],empty_hashmap (),[])
d1761 1
a1761 1
      | aux ((v,VAL e) :: l,acc) =
d1769 2
a1770 2
          aux (l,(v,VAL e)::acc)
      | aux ((v,FUNCTOR(arg,name,(defs,exp))) :: rest,acc) =
d1774 1
a1774 1
          aux (rest,(v,FUNCTOR (arg,name,(defs',exp)))::acc)
d1777 1
a1777 1
    fun lookup (exp as VAREXP x,n) =
d1779 1
d1785 1
a1785 1
                VAREXP _ => lookup (e,n+1)
d1802 1
a1802 1
fun make_lamb e =
d1804 72
a1875 26
    val _ = pprint_exp e
    val _ = diag (1,fn () => "Linearizing..\n")
    val e = linearize e
    val _ = pprint_exp e
    val _ = diag (1,fn () => "Globalizing..\n")
    val e = globalize (e,[],[],true)
    val _ = pprint_exp e
    val _ = diag (1,fn () => "Optimizing..\n")
    val e = simplify (e,empty_hashmap ())
    val _ = diag (1,fn () => "Cleaning up..\n")
    val e = cleanup e
    val _ = pprint_exp e
    val _ = diag (1,fn () => "Transforming..\n")
    val (e,defs) = Timer.xtime ("Transforming",
                            !print_timings,
                            fn () => (transform (e,[],[],true)))
    val _ = diag (1,fn () => "Linearizing..\n")
    val prog = linearize_all (rev defs,e)
    val _ = pprint prog
    val _ = diag (1,fn () => "Optimizing..\n")
    val prog = optimize_till_done prog
    val _ = diag (1,fn () => "Inlining single callees..\n")
    val prog = linearize_all (inline_single_callees prog)
    val _ = diag (1,fn () => "Optimizing..\n")
    val prog = optimize_till_done prog
    val _ = pprint prog
d1877 3
a1879 26
      if do_cse 
        then
          let 
            val _ = diag (1, fn () => "Doing Local CSE..\n")
            val prog = local_cse_all prog
            val _ = pprint prog
          in
            prog
          end
      else prog
    val _ = diag (1, fn () => "Doing CSE..\n")
    val prog = global_cse prog
    val _ = pprint prog
    val _ = diag (1, fn () => "Eta elim..\n")
    val prog = elim_global_simple_bindings prog
    val _ = pprint prog
    val _ = diag (1, fn () => "Doing Schedule..\n")
    val prog = schedule_all prog
    val _ = pprint prog
    val _ = diag (1, fn () => "Done\n")
(*
 (* This is currently buggy *)
 (* And not much of an optimization *)
    val _ = diag (1, fn () => "Blockification..\n")
    val prog = linearize_all (blockify_all prog)
*)
d1881 2
a1882 11
    prog
  end                           

fun optimise options e =
  let
    val e' = TransSimple.trans_lamb e
    val prog' = Timer.xtime ("Inner lambda",!print_timings,fn () => make_lamb e')
(*  val _ = Analyse.analyse (PROGRAM prog') *)
  in
    if print_result then output (std_out, pds (PROGRAM prog') ^ "\n") else ();
    TransSimple.trans_program (PROGRAM prog')
d1887 1
a1887 11
  (PROGRAM ([],cleanup (simplify (linearize (TransSimple.trans_lamb e),empty_hashmap ()))))

fun show_simple e =
  let
    val res = make_lamb (TransSimple.trans_lamb e)
  in
    if print_result
      then
        pds (PROGRAM res)
    else ""
  end
@
