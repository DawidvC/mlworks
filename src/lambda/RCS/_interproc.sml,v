head	1.48;
access;
symbols
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.48.3.1.1
	MLWorks_gui_1996_12_18:1.48.4
	MLWorks_1_0_Win32_1996_12_17:1.48.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.48.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.48.1.1
	MLWorks_1_0_Irix_1996_11_28:1.48.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.48.2
	MLWorks_1_0_Unix_1996_11_14:1.48.1
	MLWorks_Open_Beta2_1996_10_11:1.47.3
	MLWorks_License_dev:1.47.2
	MLWorks_1_open_beta_1996_09_13:1.47.1
	MLWorks_Open_Beta_1996_08_22:1.47
	MLWorks_Beta_1996_07_02:1.47
	MLWorks_Beta_1996_06_07:1.47
	MLWorks_Beta_1996_06_06:1.47
	MLWorks_Beta_1996_06_05:1.47
	MLWorks_Beta_1996_06_03:1.47
	MLWorks_Beta_1996_05_31:1.47
	MLWorks_Beta_1996_05_30:1.47
	ML_beta_release_12/08/94:1.38
	ML_beta_release_03/08/94:1.38
	ML_revised_beta_release_25/05/94:1.37
	ML_final_beta_release_02/03/94:1.37
	mlworks-28-01-1994:1.37
	Release:1.36
	mlworks-beta-01-09-1993:1.36
	MLWorks-1-0-4-29/01/1993:1.31
	MLWorks-1-0-3-21/12/1992:1.30
	MLWorks-1-0-2-15/12/1992:1.30
	MLWorks-1-0-1-04/12/1992:1.30
	checkpoint_17_08_92:1.22;
locks; strict;
comment	@ * @;


1.48
date	96.10.31.10.35.08;	author io;	state Exp;
branches
	1.48.1.1
	1.48.2.1
	1.48.3.1
	1.48.4.1;
next	1.47;

1.47
date	96.03.28.10.41.08;	author matthew;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1;
next	1.46;

1.46
date	95.12.04.12.00.21;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	95.08.11.17.12.16;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	95.02.28.12.58.53;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	95.01.09.13.43.25;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.10.13.11.09.16;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	94.10.10.10.18.58;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	94.09.19.13.46.55;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	94.07.26.13.39.46;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	94.07.22.14.48.50;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	93.08.12.12.16.12;	author nosa;	state Exp;
branches;
next	1.36;

1.36
date	93.07.30.09.31.21;	author nosa;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	93.07.07.16.54.27;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	93.06.04.11.32.59;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	93.05.18.18.49.45;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	93.03.01.15.04.52;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	93.01.22.15.47.03;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	92.11.30.12.38.10;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	92.11.26.15.55.38;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	92.11.04.16.41.03;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	92.11.03.11.57.23;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	92.10.30.13.28.15;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	92.10.05.09.40.55;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.08.28.14.34.02;	author davidt;	state Exp;
branches;
next	1.23;

1.23
date	92.08.24.12.30.56;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.08.07.17.56.24;	author davidt;	state Exp;
branches;
next	1.21;

1.21
date	92.07.20.10.14.47;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.07.01.12.22.29;	author davida;	state Exp;
branches;
next	1.19;

1.19
date	92.06.24.12.24.00;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.06.23.10.12.42;	author clive;	state Exp;
branches;
next	1.17;

1.17
date	92.06.11.09.12.13;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.06.05.16.31.08;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	92.05.05.18.14.02;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	92.04.14.08.57.49;	author clive;	state Exp;
branches;
next	1.13;

1.13
date	92.04.09.12.48.33;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	92.03.31.14.30.45;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	92.02.04.16.21.00;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	92.02.03.17.39.06;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.01.29.09.10.57;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.01.28.17.48.55;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	92.01.08.15.32.35;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.01.07.19.04.40;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	92.01.03.18.07.54;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	91.12.16.15.38.42;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.11.14.17.14.27;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.11.07.17.34.58;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.11.05.16.45.28;	author jont;	state Exp;
branches;
next	;

1.36.1.1
date	93.07.30.09.31.21;	author jont;	state Exp;
branches;
next	;

1.47.1.1
date	96.09.13.11.17.25;	author hope;	state Exp;
branches;
next	;

1.47.2.1
date	96.10.07.16.07.11;	author hope;	state Exp;
branches;
next	;

1.47.3.1
date	96.10.17.11.25.28;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	96.11.14.12.50.29;	author hope;	state Exp;
branches
	1.48.1.1.1.1;
next	;

1.48.1.1.1.1
date	96.11.28.15.01.35;	author hope;	state Exp;
branches;
next	;

1.48.2.1
date	96.11.22.18.09.55;	author hope;	state Exp;
branches;
next	;

1.48.3.1
date	96.12.17.17.48.33;	author hope;	state Exp;
branches
	1.48.3.1.1.1;
next	;

1.48.3.1.1.1
date	97.02.24.11.38.31;	author hope;	state Exp;
branches;
next	;

1.48.4.1
date	96.12.18.09.42.34;	author hope;	state Exp;
branches;
next	;


desc
@Interprocedural analysis (simple), for spotting functions whose result
doesn't involve the entire argument. This is intended to allow (one day)
parameter passing on the stack
@


1.48
log
@moving String from toplevel
@
text
@(* _interproc.sml the functor *)
(*
$Log: _interproc.sml,v $
 * Revision 1.47  1996/03/28  10:41:08  matthew
 * Adding where type clause
 *
 * Revision 1.46  1995/12/04  12:00:21  matthew
 * Simplifying LambdaTypes
 *
Revision 1.45  1995/08/11  17:12:16  daveb
Replaced uses of LambdaTypes.Option.opt with MLWorks.Option.option.

Revision 1.44  1995/02/28  12:58:53  matthew
Removed call to eta_abstract

Revision 1.43  1995/01/09  13:43:25  matthew
Removing APP-FN message

Revision 1.42  1994/10/13  11:09:16  matthew
Use pervasive Option.option for return values in NewMap

Revision 1.41  1994/10/10  10:18:58  matthew
Lambdatypes changes

Revision 1.40  1994/09/19  13:46:55  matthew
Abstraction of debug information in lambdatypes

Revision 1.39  1994/07/26  13:39:46  matthew
Extensions for argument lists

Revision 1.38  1994/07/22  14:48:50  matthew
Functions and applications take a list of parameters

Revision 1.37  1993/08/12  12:16:12  nosa
FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.

Revision 1.36  1993/07/30  09:31:21  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.35  1993/07/07  16:54:27  daveb
Changed EXIOVAL to EXIO, as we no longer have separate exception
environments.

Revision 1.34  1993/06/04  11:32:59  matthew
Added newline after message

Revision 1.33  1993/05/18  18:49:45  jont
Removed integer parameter

Revision 1.32  1993/03/01  15:04:52  matthew
Added MLVALUE lambda exp

Revision 1.31  1993/01/22  15:47:03  jont
Changed escape analysis of switch statements so as not to use the bound
variable. This changes its depth complexity dramatically.

Revision 1.30  1992/11/30  12:38:10  jont
Took out a number of unnecessary map operations

Revision 1.29  1992/11/26  15:55:38  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.28  1992/11/04  16:41:03  jont
Modified escapes_sub so as to mark APP(VAR lv, _, _) as not ecsaping on lv

Revision 1.27  1992/11/03  11:57:23  daveb
Minor changes to support the new type of SWITCHes.

Revision 1.26  1992/10/30  13:28:15  jont
Changed type of escape_map to use LambdaTypes.Map

Revision 1.25  1992/10/05  09:40:55  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.24  1992/08/28  14:34:02  davidt
Removed some unncesessary intermediate lists which
were being built.

Revision 1.23  1992/08/24  12:30:56  jont
Added list of escaping primitives

Revision 1.22  1992/08/07  17:56:24  davidt
Now use NewMap instead of BalancedTree.

Revision 1.21  1992/07/20  10:14:47  clive
eta_abstract now takes a type annotation

Revision 1.20  1992/07/01  12:22:29  davida
Added LET constructor and new slot to APP.

Revision 1.19  1992/06/24  12:24:00  jont
Fixed a problem whereby function arguments got put in closures of
sub functions without realising that those arguments must be on the heap

Revision 1.18  1992/06/23  10:12:42  clive
Added an annotation slot to HANDLE

Revision 1.17  1992/06/11  09:12:13  clive
Needed to add NullTypes in the FNexps that are generated

Revision 1.16  1992/06/05  16:31:08  jont
Modified to use newmap

Revision 1.15  1992/05/05  18:14:02  jont
Changed to use balanced trees instead of association lists

Revision 1.14  1992/04/14  08:57:49  clive
First version of the profiler

Revision 1.13  1992/04/09  12:48:33  jont
Improved escapes in order to reflect a conservatively correct answer

Revision 1.12  1992/03/31  14:30:45  jont
Changed print for Print.print

Revision 1.11  1992/02/04  16:21:00  jont
Fixed bug in find_letrec_real_bindings whereby a LETREC stage was
being skipped.

Revision 1.10  1992/02/03  17:39:06  clive
Took out the odd letrec binding message

Revision 1.9  1992/01/29  09:10:57  clive
Added ARRAY and UPDATE details

Revision 1.8  1992/01/28  17:48:55  jont
Added Lists.Assoc handlers. Coped with case of var bindings direct
to function argument, which optimiser would have removed

Revision 1.7  1992/01/08  15:32:35  jont
Fixed problem with unusual LETREC bindings.
This may need more investigation

Revision 1.6  1992/01/07  19:04:40  jont
Added function to return variable and function bindings for
curried function optimisation

Revision 1.5  1992/01/03  18:07:54  jont
Added function to return list of function bindings
Modified escape_map to use this list rather than recalculating it

Revision 1.4  1991/12/16  15:38:42  jont
Fixed bug whereby function bodies within LETRECs weren't searched for
further bindings

Revision 1.3  91/11/14  17:14:27  jont
Removed eta_abstract and referenced one in LambdaSub

Revision 1.2  91/11/07  17:34:58  jont
Added function to produce a lambda var to bool map of whether the
 referenced function has an escaping argument or not

Revision 1.1  91/11/05  16:45:28  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/crash";
require "../utils/print";
require "../utils/intnewmap";
require "../main/pervasives";
require "lambdasub";
require "lambdaprint";
require "interproc";

functor InterProc(include
                  sig
                    structure Lists : LISTS
                    structure Crash : CRASH
                    structure Print : PRINT
                    structure IntMap : INTNEWMAP
                    structure Pervasives : PERVASIVES
                    structure LambdaSub : LAMBDASUB
                    structure LambdaPrint : LAMBDAPRINT

                    sharing LambdaSub.LT = LambdaPrint.LambdaTypes
                    sharing type LambdaSub.LT.Primitive = Pervasives.pervasive
                  end where type LambdaSub.LT.LVar = int
                  ) : INTERPROC =
struct
  structure LambdaTypes = LambdaSub.LT

  type 'a Map = 'a IntMap.T

  datatype escape_result =
    SIMPLE_ESCAPE |
    RAISE_ESCAPE |
    NO_ESCAPE

  fun combine_type(RAISE_ESCAPE, _) = RAISE_ESCAPE
    | combine_type(SIMPLE_ESCAPE, esc) =
      (case esc of
	 NO_ESCAPE => SIMPLE_ESCAPE
       | _ => RAISE_ESCAPE)
    | combine_type(NO_ESCAPE, esc) = esc

  fun convert_escape NO_ESCAPE = NO_ESCAPE
  | convert_escape _ = RAISE_ESCAPE

  fun reduce_escape RAISE_ESCAPE = RAISE_ESCAPE
  | reduce_escape _ = NO_ESCAPE

  val escaping_prim_list =
    [Pervasives.REF,
     Pervasives.MAP,
     Pervasives.REV,
     Pervasives.O,
     Pervasives.CALL_C,
     Pervasives.EXIO,
     Pervasives.EXPLODE]

  fun escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, [le],_)) =
    let
      val esc_type = escapes_sub(lvar, le)
    in
      case esc_type of
	RAISE_ESCAPE => RAISE_ESCAPE
      | NO_ESCAPE => NO_ESCAPE
      | _ =>
	  if Lists.member(prim, escaping_prim_list) then
	    RAISE_ESCAPE
	  else
	    NO_ESCAPE
    end
    | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, lel,x)) =
      escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, [LambdaTypes.STRUCT (lel,LambdaTypes.TUPLE)],x))
    | escapes_sub(lvar, LambdaTypes.LET((lv',_,LambdaTypes.VAR lvar'),le)) =
      let
	val esc1 = escapes_sub(lvar, le)
      in
	case esc1 of
	  RAISE_ESCAPE => RAISE_ESCAPE
	| _ =>
	    if lvar = lvar' then
	      combine_type(esc1, escapes_sub(lv', le))
	    else
	      esc1
      end
    | escapes_sub(lvar, LambdaTypes.LET((lv',_,le'),le)) =
      (case escapes_sub(lvar, le') of
	 RAISE_ESCAPE => RAISE_ESCAPE
       | NO_ESCAPE => escapes_sub(lvar, le)
       | SIMPLE_ESCAPE =>
	   combine_type(escapes_sub(lv', le), escapes_sub(lvar, le)))

    (* The next two cases can occur if optimization is switched off *)
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN([lv'], le,_,_,_),
				      [LambdaTypes.VAR lvar'],_)) =
    let
      val esc1 = escapes_sub(lvar, le)
    in
      case esc1 of
	RAISE_ESCAPE => RAISE_ESCAPE
      | _ =>
	  if lvar = lvar' then
	    combine_type(esc1, escapes_sub(lv', le))
	  else
	    esc1
    end
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN([lv'], le,_,_,_), [le'],_)) =
    (case escapes_sub(lvar, le') of
       RAISE_ESCAPE => RAISE_ESCAPE
     | NO_ESCAPE => escapes_sub(lvar, le)
     | SIMPLE_ESCAPE =>
	 combine_type(escapes_sub(lv', le), escapes_sub(lvar, le)))
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(varlist, le,_,_,_),_,_)) =
    Crash.impossible "Varlist in APP-FN in escapes_sub"
  | escapes_sub(lvar, LambdaTypes.APP(le, [le'],_)) =
    (case escapes_sub(lvar, le') of
       NO_ESCAPE =>
	 (case le of
	    LambdaTypes.VAR _ => NO_ESCAPE
	  | _ => escapes_sub(lvar, le))
     | _ => RAISE_ESCAPE)
    (* No analysis of called function here *)
  | escapes_sub(lvar, LambdaTypes.APP(le, lel,x)) =
    escapes_sub(lvar, LambdaTypes.APP(le, [LambdaTypes.STRUCT (lel,LambdaTypes.TUPLE)],x))
  | escapes_sub(lvar, le as LambdaTypes.VAR lvar') =
    if lvar = lvar' then SIMPLE_ESCAPE else NO_ESCAPE
  | escapes_sub(lvar, LambdaTypes.FN(_, le,_,_,_)) =
    if LambdaSub.occurs(lvar, le) then RAISE_ESCAPE else NO_ESCAPE
    (* In case it gets into the closure *)
  | escapes_sub(lvar, LambdaTypes.LETREC(lv_list, le_list, le)) =
    if Lists.exists (fn le => LambdaSub.occurs(lvar, le)) le_list then
      RAISE_ESCAPE
    else
      escapes_sub(lvar, le)
    (* In case it gets into the closure *)
  | escapes_sub(lvar, LambdaTypes.SCON _) = NO_ESCAPE
  | escapes_sub(lvar, LambdaTypes.MLVALUE _) = NO_ESCAPE
  | escapes_sub(lvar, LambdaTypes.INT _) = NO_ESCAPE
  | escapes_sub(lvar, LambdaTypes.SWITCH(le, info, tag_le_list, le_opt)) =
    let
      fun escapes_opt NONE = NO_ESCAPE
      |   escapes_opt(SOME le) = escapes_sub(lvar, le)
    in
      case escapes_sub(lvar, le) of
	RAISE_ESCAPE => RAISE_ESCAPE
      | esc =>
	  case escapes_opt le_opt of
	    RAISE_ESCAPE => RAISE_ESCAPE
	  | esc' =>
	      escapes_tag_list(esc', lvar, tag_le_list)
	      (* The assumption is that bindings will never be made to the entire *)
	      (* switch parameter, and hence they are of no significance in calculating *)
	      (* whether or not function arguments escape *)
    end
  | escapes_sub(lvar, LambdaTypes.STRUCT (le_list,_)) =
    convert_escape(escapes_sub_list(NO_ESCAPE, lvar, le_list))
  | escapes_sub(lvar, LambdaTypes.SELECT(_, LambdaTypes.VAR _)) = NO_ESCAPE
  | escapes_sub(lvar, LambdaTypes.SELECT(_, le)) =
    reduce_escape(escapes_sub(lvar, le))
    (* We ought to be able to treat simple escape from SELECT as NO_ESCAPE *)
    (* Think very hard! *)
  | escapes_sub(lvar, LambdaTypes.RAISE (le)) =
    convert_escape(escapes_sub(lvar, le))
  | escapes_sub(lvar, LambdaTypes.HANDLE(le, le',_)) =
    combine_type(escapes_sub(lvar, le), escapes_sub(lvar, le'))
  | escapes_sub(lvar, LambdaTypes.BUILTIN _) = NO_ESCAPE

  and escapes_sub_list(acc, _, []) = acc
    | escapes_sub_list(RAISE_ESCAPE, _, _) = RAISE_ESCAPE
    | escapes_sub_list(esc, lv, le :: le_list) =
      escapes_sub_list(combine_type(esc, escapes_sub(lv, le)), lv, le_list)

  and escapes_tag_list(acc, _, []) = acc
    | escapes_tag_list(RAISE_ESCAPE, _, _) = RAISE_ESCAPE
    | escapes_tag_list(esc, lv, (tag, le) :: tag_le_list) =
      let
	val tag_esc = case tag of
	  LambdaTypes.EXP_TAG le' => escapes_sub(lv, le')
	| _ => NO_ESCAPE
      in
	case combine_type(esc, tag_esc) of
	  RAISE_ESCAPE => RAISE_ESCAPE
	| esc' =>
	    (case combine_type(esc', escapes_sub(lv, le)) of
	       RAISE_ESCAPE => RAISE_ESCAPE
	     | esc'' => escapes_tag_list(esc'', lv, tag_le_list))
(*	    
	escapes_tag_list
	((case combine_type(esc, tag_esc) of
	    RAISE_ESCAPE => RAISE_ESCAPE
	  | esc' => combine_type(esc', escapes_sub(lv, le))),
	    lv, tag_le_list)
*)
      end

  fun escapes lv_le = escapes_sub lv_le <> NO_ESCAPE

  fun get_simple_bindings(tree, le as LambdaTypes.LET _) =
    let
      val (bindings, le) = LambdaSub.unwrap_lets le
      val tree =
	Lists.reducel
	(fn (tree, (lv, le)) => IntMap.define(tree, lv, le))
	(get_simple_bindings(tree, le), bindings)
    in
      add_sub_bindings(tree, bindings)
    end
(* get_simple_bindings (LambdaTypes.APP(LambdaTypes.FN _, _, _,_),_,_,_)  *)
  | get_simple_bindings(tree, LambdaTypes.VAR _) = tree
  | get_simple_bindings(tree, LambdaTypes.FN(_, le,_,_,_)) =
      get_simple_bindings(tree, le)
  | get_simple_bindings(tree, LambdaTypes.LETREC(lv_list, le_list, le)) =
    let
      val lv_list = map #1 lv_list
      val tree = Lists.reducel
	(fn (tree, le) => get_simple_bindings(tree, le))
	(get_simple_bindings(tree, le), le_list)
      val bindings = Lists.zip(lv_list, le_list)
    in
      Lists.reducel
        (fn (tree, (lv, le)) =>
	 IntMap.define(tree, lv,
		       case le of
			 LambdaTypes.FN _ => le
		       | _ => Crash.impossible "get_simple_bindings: non-FN in LETREC"))
        (tree, bindings)
    end
  | get_simple_bindings(tree, LambdaTypes.APP(le, lel,_)) =
    Lists.reducel
      (fn (tree, le) => get_simple_bindings(tree, le))
      (get_simple_bindings(tree, le), lel)
  | get_simple_bindings(tree, LambdaTypes.SCON _) = tree
  | get_simple_bindings(tree, LambdaTypes.MLVALUE _) = tree
  | get_simple_bindings(tree, LambdaTypes.INT _) = tree
  | get_simple_bindings(tree, LambdaTypes.SWITCH(le, info, tag_le_list, def)) =
    let
      val tree = get_simple_bindings(do_opt(tree, def), le)
    in
      Lists.reducel
        (fn (tree, (tag, le)) =>
         do_tag(get_simple_bindings(tree, le), tag))
        (tree, tag_le_list)
    end
  | get_simple_bindings(tree, LambdaTypes.STRUCT (le_list,_)) =
    Lists.reducel
      (fn (tree, le) => get_simple_bindings(tree, le))
      (tree, le_list)
  | get_simple_bindings(tree, LambdaTypes.SELECT(_, le)) =
      get_simple_bindings(tree, le)
  | get_simple_bindings(tree, LambdaTypes.RAISE (le)) =
      get_simple_bindings(tree, le)
  | get_simple_bindings(tree, LambdaTypes.HANDLE(le, le',_)) =
      get_simple_bindings(get_simple_bindings(tree, le), le')
  | get_simple_bindings(tree, LambdaTypes.BUILTIN _) = tree

  and add_sub_bindings arg =
    Lists.reducel
    (fn (tree, (_, le)) => get_simple_bindings(tree, le))
    arg

  and do_opt(tree, NONE) = tree
    | do_opt(tree, SOME le) = get_simple_bindings(tree, le)

  and do_tag(tree, LambdaTypes.EXP_TAG le) = get_simple_bindings(tree, le)
    | do_tag(tree, _) = tree

  fun is_fn_binding(_, LambdaTypes.FN _) = true
    | is_fn_binding _ = false

  fun is_letrec_binding(_, LambdaTypes.LETREC _) = true
    | is_letrec_binding _ = false

  fun is_var_binding(_, LambdaTypes.VAR _) = true
    | is_var_binding _ = false

  fun is_fn_or_var_binding x = is_fn_binding x orelse is_var_binding x

  fun find_letrec_real_bindings(LambdaTypes.LETREC(_, _, le)) =
    (case le of
      LambdaTypes.VAR _ => le
    | LambdaTypes.STRUCT _ => le
    | LambdaTypes.LETREC _ => find_letrec_real_bindings le
    | _ => le)
  | find_letrec_real_bindings le =
    Crash.impossible("find_letrec_bindings on non-LETREC\n" ^
		     LambdaPrint.string_of_lambda le ^ "\n")

  fun print_bindings bindings =
    Lists.iterate
    (fn (lv, le) => Print.print("Var " ^ LambdaTypes.printLVar lv ^ ", Exp" ^
			  LambdaPrint.string_of_lambda le ^ "\n"))
    bindings

  fun reduce_select_bindings(le as LambdaTypes.SELECT({index=index, ...},
						      LambdaTypes.VAR lv'),
			     all_bindings) =
    (* Attempt to pull out what a selection really binds to *)
    (case IntMap.tryApply'(all_bindings, lv') of
	SOME(LambdaTypes.STRUCT (le_list,_)) =>
	  (true, Lists.nth(index, le_list))
      | _ => (false, le))

  | reduce_select_bindings(le as
			   LambdaTypes.SELECT(selval,
					      LambdaTypes.LETREC(_, _, lexp)),
			   all_bindings) =
    reduce_select_bindings(LambdaTypes.SELECT(selval, lexp), all_bindings)
  | reduce_select_bindings(x, _) = (false, x)

  fun reduce_var_bindings(all_bindings, (lv, le as LambdaTypes.VAR lv')) =
    (case IntMap.tryApply'(all_bindings, lv') of
       SOME answer => IntMap.define(all_bindings, lv, answer)
     | _ => all_bindings)
  | reduce_var_bindings(tree, _) = tree

  fun reduce_var_bindings'(all_bindings, (lv, var as LambdaTypes.VAR lv')) =
    let
(*
	  (Print.print("Bad binding " ^ LambdaTypes.printLVar lv' ^ "in\n");
	   Lists.iterate
	   (fn (lv, le) =>
	    Print.print("Lv : " ^ LambdaTypes.printLVar lv ^ ", le : " ^
			LambdaPrint.string_of_lambda le ^ "\n"))
	   all_bindings;
	   Crash.impossible"reduce_var_bindings'")
*)
    in
      case IntMap.tryApply'(all_bindings, lv) of
	SOME (LambdaTypes.FN _) => all_bindings
      | SOME le' => IntMap.define(all_bindings, lv, le')
      | _ => all_bindings
    end
  | reduce_var_bindings'(tree, _) = tree

  fun reduce_some_bindings all_bindings =
    let
      val all_bindings =
	Lists.reducel
	(fn (tree, x) => reduce_var_bindings'(all_bindings, x))
	(all_bindings, IntMap.to_list all_bindings)
      val reduced_list =
	map
	(fn (lv, le) =>
	 (lv, reduce_select_bindings(le, all_bindings)))
	(IntMap.to_list all_bindings)
      (* Sort out the selects *)
      val done =
	let
	  fun acc(true, _) = true
	  | acc(done, []) = done
	  | acc(_, (_, (done, _)) :: rest) = acc(done, rest)
	in
	  acc(false, reduced_list)
	end
      val new_bindings =
	Lists.reducel
	(fn (tree, (lv, (_, le))) =>
	 IntMap.define(tree, lv, le))
	(IntMap.empty, reduced_list)
    in
      if done then reduce_some_bindings new_bindings else new_bindings 
    (* Try again if some selects reduced *)
    end

  fun reduce_all_bindings all_bindings =
    let
      val all_bindings =
	Lists.reducel
	(fn (tree, x) => reduce_var_bindings'(all_bindings, x))
	(all_bindings, IntMap.to_list all_bindings)
      val reduced_list =
	map
	(fn (lv, le) =>
	 (lv, reduce_select_bindings(le, all_bindings)))
	(IntMap.to_list all_bindings)
      val done =
	let
	  fun acc(true, _) = true
	  | acc(done, []) = done
	  | acc(_, (_, (done, _)) :: rest) = acc(done, rest)
	in
	  acc(false, reduced_list)
	end
      val new_bindings =
	Lists.reducel
	(fn (tree, (lv, (_, le))) =>
	 IntMap.define(tree, lv, le))
	(IntMap.empty, reduced_list)
    in
      if done then reduce_all_bindings new_bindings else new_bindings 
    end

  fun modify_tree_for_letrec(tree, (lv, le)) =
    if is_letrec_binding(lv, le) then
      let
	val le = find_letrec_real_bindings le
      in
	IntMap.define(tree, lv, le)
      end
    else
      tree

  fun get_all_bindings lambda_exp =
    let
      val all_bindings =
	get_simple_bindings(IntMap.empty, lambda_exp)
      val all_list = IntMap.to_list all_bindings
(*
      val letrec_bindings = List.filter is_letrec_binding all_list
      val letrec_real_bindings =
	map
	(fn (lv, le) => (lv, find_letrec_real_bindings le))
	letrec_bindings
      val other_bindings =
	List.filter
	(fn x => not(is_letrec_binding x))
	all_list
*)
    in
      Lists.reducel
      modify_tree_for_letrec
      (all_bindings, all_list)
(*
      other_bindings @@ letrec_real_bindings
*)
    end

  fun binding_list lambda_exp =
    let
      val all_bindings = get_all_bindings lambda_exp
      val all_bindings = reduce_all_bindings all_bindings
    in
      Lists.filterp is_fn_binding (IntMap.to_list all_bindings)
    end

  fun fn_and_var_binding_list lambda_exp =
    let
      val all_bindings = get_all_bindings lambda_exp
      val all_bindings = reduce_some_bindings all_bindings
    in
      Lists.filterp is_fn_or_var_binding (IntMap.to_list all_bindings)
    end

  fun escape_map fn_bindings =
    let
      fun add_escape (res, (lv, LambdaTypes.FN([lvar], lexp,_,_,_))) =
	  IntMap.define(res, lv, escapes(lvar, lexp))
        | add_escape (res, (lv, LambdaTypes.FN(lvarl, lexp,_,_,_))) =
	  IntMap.define(res, lv,Lists.exists (fn lvar => escapes (lvar,lexp)) lvarl)
	| add_escape _ =
	  Crash.impossible"Non-FN in escape_map fn_bindings"
    in
      Lists.reducel add_escape (IntMap.empty, fn_bindings)
    end
end;


@


1.48.4.1
log
@branched from 1.48
@
text
@a3 3
 * Revision 1.48  1996/10/31  10:35:08  io
 * moving String from toplevel
 *
@


1.48.3.1
log
@branched from 1.48
@
text
@a3 3
 * Revision 1.48  1996/10/31  10:35:08  io
 * moving String from toplevel
 *
@


1.48.3.1.1.1
log
@branched from 1.48.3.1
@
text
@a3 3
 * Revision 1.48.3.1  1996/12/17  17:48:33  hope
 * branched from 1.48
 *
@


1.48.2.1
log
@branched from 1.48
@
text
@a3 3
 * Revision 1.48  1996/10/31  10:35:08  io
 * moving String from toplevel
 *
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 3
 * Revision 1.48  1996/10/31  10:35:08  io
 * moving String from toplevel
 *
@


1.48.1.1.1.1
log
@branched from 1.48.1.1
@
text
@a3 3
 * Revision 1.48.1.1  1996/11/14  12:50:29  hope
 * branched from 1.48
 *
@


1.47
log
@Adding where type clause
@
text
@d4 3
a189 2
  open MLWorks.Option

d457 1
a457 1
	MLWorks.Option.SOME(LambdaTypes.STRUCT (le_list,_)) =>
d470 1
a470 1
       MLWorks.Option.SOME answer => IntMap.define(all_bindings, lv, answer)
d487 2
a488 2
	MLWorks.Option.SOME(LambdaTypes.FN _) => all_bindings
      | MLWorks.Option.SOME le' => IntMap.define(all_bindings, lv, le')
d567 1
a567 1
      val letrec_bindings = Lists.filterp is_letrec_binding all_list
d573 1
a573 1
	Lists.filterp
@


1.47.3.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/03/28  10:41:08  matthew
 * Adding where type clause
 *
@


1.47.2.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/03/28  10:41:08  matthew
 * Adding where type clause
 *
@


1.47.1.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/03/28  10:41:08  matthew
 * Adding where type clause
 *
@


1.46
log
@Simplifying LambdaTypes
@
text
@d4 3
d168 14
a181 14
functor InterProc(
  structure Lists : LISTS
  structure Crash : CRASH
  structure Print : PRINT
  structure IntMap : INTNEWMAP
  structure Pervasives : PERVASIVES
  structure LambdaSub : LAMBDASUB
  structure LambdaPrint : LAMBDAPRINT

  sharing LambdaSub.LT = LambdaPrint.LambdaTypes

  sharing type LambdaSub.LT.LVar = int
  sharing type LambdaSub.LT.Primitive = Pervasives.pervasive
) : INTERPROC =
@


1.45
log
@Replaced uses of LambdaTypes.Option.opt with MLWorks.Option.option.
@
text
@d4 3
d159 1
d169 1
d175 2
d181 2
a182 1
  structure NewMap = LambdaTypes.Map
d357 1
a357 1
	(fn (tree, (lv, le)) => NewMap.define(tree, lv, le))
d376 1
a376 1
	 NewMap.define(tree, lv,
d452 1
a452 1
    (case NewMap.tryApply'(all_bindings, lv') of
d465 2
a466 2
    (case NewMap.tryApply'(all_bindings, lv') of
       MLWorks.Option.SOME answer => NewMap.define(all_bindings, lv, answer)
d482 1
a482 1
      case NewMap.tryApply'(all_bindings, lv) of
d484 1
a484 1
      | MLWorks.Option.SOME le' => NewMap.define(all_bindings, lv, le')
d494 1
a494 1
	(all_bindings, NewMap.to_list all_bindings)
d499 1
a499 1
	(NewMap.to_list all_bindings)
d512 2
a513 2
	 NewMap.define(tree, lv, le))
	(NewMap.empty, reduced_list)
d524 1
a524 1
	(all_bindings, NewMap.to_list all_bindings)
d529 1
a529 1
	(NewMap.to_list all_bindings)
d541 2
a542 2
	 NewMap.define(tree, lv, le))
	(NewMap.empty, reduced_list)
d552 1
a552 1
	NewMap.define(tree, lv, le)
d560 2
a561 2
	get_simple_bindings(NewMap.empty, lambda_exp)
      val all_list = NewMap.to_list all_bindings
d587 1
a587 1
      Lists.filterp is_fn_binding (NewMap.to_list all_bindings)
d595 1
a595 1
      Lists.filterp is_fn_or_var_binding (NewMap.to_list all_bindings)
d601 1
a601 1
	  NewMap.define(res, lv, escapes(lvar, lexp))
d603 1
a603 1
	  NewMap.define(res, lv,Lists.exists (fn lvar => escapes (lvar,lexp)) lvarl)
d607 1
a607 1
      Lists.reducel add_escape (NewMap.empty, fn_bindings)
@


1.44
log
@Removed call to eta_abstract
@
text
@d4 3
d176 2
d287 2
a288 2
      fun escapes_opt LambdaTypes.Option.ABSENT = NO_ESCAPE
      |   escapes_opt(LambdaTypes.Option.PRESENT le) = escapes_sub(lvar, le)
d407 2
a408 2
  and do_opt(tree, LambdaTypes.Option.ABSENT) = tree
    | do_opt(tree, LambdaTypes.Option.PRESENT le) = get_simple_bindings(tree, le)
@


1.43
log
@Removing APP-FN message
@
text
@d4 3
d366 1
a366 3
		       | _ => LambdaSub.eta_abstract
			   (le, "eta_abstract in _interproc",
			    ref(LambdaTypes.null_type_annotation))))
@


1.42
log
@Use pervasive Option.option for return values in NewMap
@
text
@d4 3
d231 1
a231 1
(* shouldn't need these next two cases *)
a235 1
      val _ = output(std_out, "*** APP-FN (var) found in escapes\n")
d246 1
a246 2
    (output(std_out, "*** APP-FN found in escapes\n");
     (case escapes_sub(lvar, le') of
d250 1
a250 1
	 combine_type(escapes_sub(lv', le), escapes_sub(lvar, le))))
@


1.41
log
@Lambdatypes changes
@
text
@d4 3
d438 1
a438 1
	NewMap.YES(LambdaTypes.STRUCT (le_list,_)) =>
d451 1
a451 1
       NewMap.YES answer => NewMap.define(all_bindings, lv, answer)
d468 2
a469 2
	NewMap.YES(LambdaTypes.FN _) => all_bindings
      | NewMap.YES le' => NewMap.define(all_bindings, lv, le')
@


1.40
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d205 2
a206 2
      escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, [LambdaTypes.STRUCT lel],x))
    | escapes_sub(lvar, LambdaTypes.LET(lv',_,LambdaTypes.VAR lvar',le)) =
d218 1
a218 1
    | escapes_sub(lvar, LambdaTypes.LET(lv',_,le',le)) =
d258 1
a258 1
    escapes_sub(lvar, LambdaTypes.APP(le, [LambdaTypes.STRUCT lel],x))
d289 1
a289 1
  | escapes_sub(lvar, LambdaTypes.STRUCT le_list) =
d380 1
a380 1
  | get_simple_bindings(tree, LambdaTypes.STRUCT le_list) =
d435 1
a435 1
	NewMap.YES(LambdaTypes.STRUCT le_list) =>
@


1.39
log
@Extensions for argument lists
@
text
@d4 3
d203 1
a203 1
    | escapes_sub(lvar, LambdaTypes.LET(lv',LambdaTypes.VAR lvar',le)) =
a204 1
        val lv' = LambdaTypes.fetch_var lv'
d215 1
a215 4
    | escapes_sub(lvar, LambdaTypes.LET(lv',le',le)) =
      let
        val lv' = LambdaTypes.fetch_var lv'
      in
a220 1
      end
d345 1
a345 1
      val lv_list = map LambdaTypes.fetch_var lv_list
@


1.38
log
@Functions and applications take a list of parameters
@
text
@d4 3
d198 2
a199 2
    | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, lel,_)) =
      Crash.impossible "Arglist in escapes_sub"
d256 2
a257 2
  | escapes_sub(lvar, LambdaTypes.APP(le, lel,_)) =
    Crash.impossible "Arglist in escapes_sub"
d260 1
a260 1
  | escapes_sub(lvar, LambdaTypes.FN([lv], le,_,_,_)) =
a261 2
  | escapes_sub(lvar, LambdaTypes.FN(lvl, le,_,_,_)) =
    Crash.impossible "Varlist in FN in escapes_sub"
@


1.37
log
@FNs now passed closed-over type variables and
stack frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 4
d154 1
d156 3
a158 3
    simple_escape |
    raise_escape |
    no_escape
d160 2
a161 2
  fun combine_type(raise_escape, _) = raise_escape
    | combine_type(simple_escape, esc) =
d163 3
a165 3
	 no_escape => simple_escape
       | _ => raise_escape)
    | combine_type(no_escape, esc) = esc
d167 2
a168 2
  fun convert_escape no_escape = no_escape
  | convert_escape _ = raise_escape
d170 2
a171 2
  fun reduce_escape raise_escape = raise_escape
  | reduce_escape _ = no_escape
d182 1
a182 1
  fun escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, le,_)) =
d187 2
a188 2
	raise_escape => raise_escape
      | no_escape => no_escape
d191 1
a191 1
	    raise_escape
d193 1
a193 1
	    no_escape
d195 2
d203 1
a203 1
	  raise_escape => raise_escape
d215 3
a217 3
	 raise_escape => raise_escape
       | no_escape => escapes_sub(lvar, le)
       | simple_escape =>
d222 2
a223 2
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_,_,_),
				      LambdaTypes.VAR lvar',_)) =
d229 1
a229 1
	raise_escape => raise_escape
d236 1
a236 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_,_,_), le',_)) =
d239 3
a241 3
       raise_escape => raise_escape
     | no_escape => escapes_sub(lvar, le)
     | simple_escape =>
d243 3
a245 2

  | escapes_sub(lvar, LambdaTypes.APP(le, le',_)) =
d247 1
a247 1
       no_escape =>
d249 1
a249 1
	    LambdaTypes.VAR _ => no_escape
d251 1
a251 1
     | _ => raise_escape)
d253 2
d256 5
a260 3
    if lvar = lvar' then simple_escape else no_escape
  | escapes_sub(lvar, LambdaTypes.FN(lv, le,_,_,_)) =
    if LambdaSub.occurs(lvar, le) then raise_escape else no_escape
d264 1
a264 1
      raise_escape
d268 3
a270 3
  | escapes_sub(lvar, LambdaTypes.SCON _) = no_escape
  | escapes_sub(lvar, LambdaTypes.MLVALUE _) = no_escape
  | escapes_sub(lvar, LambdaTypes.INT _) = no_escape
d273 1
a273 1
      fun escapes_opt LambdaTypes.Option.ABSENT = no_escape
d277 1
a277 1
	raise_escape => raise_escape
d280 1
a280 1
	    raise_escape => raise_escape
d288 2
a289 2
    convert_escape(escapes_sub_list(no_escape, lvar, le_list))
  | escapes_sub(lvar, LambdaTypes.SELECT(_, LambdaTypes.VAR _)) = no_escape
d292 1
a292 1
    (* We ought to be able to treat simple escape from SELECT as no_escape *)
d298 1
a298 1
  | escapes_sub(lvar, LambdaTypes.BUILTIN _) = no_escape
d301 1
a301 1
    | escapes_sub_list(raise_escape, _, _) = raise_escape
d306 1
a306 1
    | escapes_tag_list(raise_escape, _, _) = raise_escape
d311 1
a311 1
	| _ => no_escape
d314 1
a314 1
	  raise_escape => raise_escape
d317 1
a317 1
	       raise_escape => raise_escape
d322 1
a322 1
	    raise_escape => raise_escape
d328 1
a328 1
  fun escapes lv_le = escapes_sub lv_le <> no_escape
d362 4
a365 2
  | get_simple_bindings(tree, LambdaTypes.APP(le, le',_)) =
      get_simple_bindings(get_simple_bindings(tree, le), le')
d580 1
a580 1
      fun add_escape (res, (lv, LambdaTypes.FN(lvar, lexp,_,_,_))) =
d582 2
@


1.36
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d4 4
d215 1
a215 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_,_),
d229 1
a229 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_,_), le',_)) =
d247 1
a247 1
  | escapes_sub(lvar, LambdaTypes.FN(lv, le,_,_)) =
d330 1
a330 1
  | get_simple_bindings(tree, LambdaTypes.FN(_, le,_,_)) =
d566 1
a566 1
      fun add_escape (res, (lv, LambdaTypes.FN(lvar, lexp,_,_))) =
@


1.36.1.1
log
@Fork for bug fixing
@
text
@a3 4
Revision 1.36  1993/07/30  09:31:21  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.35
log
@Changed EXIOVAL to EXIO, as we no longer have separate exception
environments.
@
text
@d4 4
d188 1
d200 3
d208 1
d257 2
a258 2
      fun escapes_opt LambdaTypes.ABSENT = no_escape
      |   escapes_opt(LambdaTypes.PRESENT le) = escapes_sub(lvar, le)
d278 1
a278 1
  | escapes_sub(lvar, LambdaTypes.RAISE le) =
d324 1
a324 1
(* get_simple_bindings (LambdaTypes.APP(LambdaTypes.FN _, _, _))  *)
d330 1
d343 1
a343 1
			    LambdaTypes.null_type_annotation)))
d366 1
a366 1
  | get_simple_bindings(tree, LambdaTypes.RAISE le) =
d377 2
a378 2
  and do_opt(tree, LambdaTypes.ABSENT) = tree
    | do_opt(tree, LambdaTypes.PRESENT le) = get_simple_bindings(tree, le)
@


1.34
log
@Added newline after message
@
text
@d4 3
d166 1
a166 1
     Pervasives.EXIOVAL,
@


1.33
log
@Removed integer parameter
@
text
@d4 3
d203 1
a203 1
      val _ = output(std_out, "*** APP-FN (var) found in escapes")
d214 1
a214 1
    (output(std_out, "*** APP-FN found in escapes");
@


1.32
log
@Added MLVALUE lambda exp
@
text
@d4 3
a115 1
require "../utils/integer";
a124 1
  structure Integer : INTEGER
@


1.31
log
@Changed escape analysis of switch statements so as not to use the bound
variable. This changes its depth complexity dramatically.
@
text
@d4 4
d237 1
d332 1
@


1.30
log
@Took out a number of unnecessary map operations
@
text
@d4 3
d137 5
a141 6
  | combine_type(_, raise_escape) = raise_escape
  | combine_type(simple_escape, simple_escape) = raise_escape
    (* Complicated case whereby arg gets out by two routes *)
  | combine_type(simple_escape, _) = simple_escape
  | combine_type(_, simple_escape) = simple_escape
  | combine_type _ = no_escape
d162 8
a169 4
      if Lists.member(prim, escaping_prim_list) then
	convert_escape esc_type
      else
	reduce_escape esc_type
d184 5
a188 5
    (case escapes_sub(lvar, le') of
       raise_escape => raise_escape
     | no_escape => escapes_sub(lvar, le)
     | simple_escape =>
	 combine_type(escapes_sub(lv', le), escapes_sub(lvar, le)))
d241 1
a241 1
      | _ =>
d244 5
a248 7
	  | esc =>
	      let val esc' = escapes_tag_list(esc, lvar, tag_le_list)
	      in case info of
		   LambdaTypes.ABSENT => esc'
		 | LambdaTypes.PRESENT {lv, ...} =>
		     escapes_tag_list(esc', lv, tag_le_list)
	      end
d263 1
a263 1
  and escapes_sub_list(acc, lv, []) = acc
d268 1
a268 1
  and escapes_tag_list(acc, lv, []) = acc
d276 7
d286 1
a286 1
	  | esc' => combine_type(esc, escapes_sub(lv, le))),
d288 1
@


1.29
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d300 1
a300 11
      val bindings =
	Lists.zip(
	  lv_list,
	  map
	    (fn arg as LambdaTypes.FN _ => arg
              | arg => LambdaSub.eta_abstract(arg,
					      "eta_abstract in _interproc",
					      LambdaTypes.null_type_annotation)
	    )
	    le_list
	)
d303 7
a309 1
        (fn (tree, (lv, le)) => NewMap.define(tree, lv, le))
d369 6
d379 4
a382 3
    ((case NewMap.apply'(all_bindings, lv') of
	LambdaTypes.STRUCT le_list => (true, Lists.nth(index, le_list))
      | _ => (false, le)) handle NewMap.Undefined => (false, le))
a383 19
(*
    let  
      val all_lambdas = map #1 all_bindings
    in
      if Lists.member(lv', all_lambdas) then
	let
	  val new_exp = Lists.assoc(lv', all_bindings)
	    handle Lists.Assoc =>
	      Crash.impossible"reduce_select_bindings"
	in
	  case new_exp of
	    LambdaTypes.STRUCT le_list =>
	      (true, Lists.nth(index, le_list))
	  | _ => (false, le)
	end
      else
	(false, le)
    end
*)
d392 3
a394 2
    ((NewMap.define(all_bindings, lv, NewMap.apply'(all_bindings, lv')))
     handle NewMap.Undefined  => all_bindings)
d409 4
a412 4
      (case NewMap.apply'(all_bindings, lv) of
	 LambdaTypes.FN _ => all_bindings
	| le' => NewMap.define(all_bindings, lv, le'))
      handle NewMap.Undefined => all_bindings
@


1.28
log
@Modified escapes_sub so as to mark APP(VAR lv, _, _) as not ecsaping on lv
@
text
@d4 3
a367 6

  fun print_bindings bindings =
    map
    (fn (lv, le) => Print.print("Var " ^ LambdaTypes.printLVar lv ^ ", Exp" ^
			  LambdaPrint.string_of_lambda le ^ "\n"))
    bindings
@


1.27
log
@Minor changes to support the new type of SWITCHes.
@
text
@d4 3
d202 4
a205 1
       no_escape => escapes_sub(lvar, le)
d272 1
a272 1
  fun escapes lv_le = (*true orelse*) escapes_sub lv_le <> no_escape
@


1.26
log
@Changed type of escape_map to use LambdaTypes.Map
@
text
@d4 3
d215 1
a215 1
  | escapes_sub(lvar, LambdaTypes.SWITCH(le, tag_le_list, le_opt1, le_opt2)) =
d218 1
a218 1
      | escapes_opt(LambdaTypes.PRESENT le) = escapes_sub(lvar, le)
d223 1
a223 1
	  case escapes_opt le_opt1 of
d226 5
a230 4
	      let
		val esc' = combine_type(esc, escapes_opt le_opt2)
	      in
		escapes_tag_list(esc', lvar, tag_le_list)
d281 1
a281 1
    get_simple_bindings(tree, le)
d288 10
a297 6
	Lists.zip
	(lv_list,
	 map
	 (fn arg as LambdaTypes.FN _ => arg
         | arg => LambdaSub.eta_abstract (arg,"eta_abstract in _interproc",LambdaTypes.null_type_annotation))
	 le_list)
d300 2
a301 2
      (fn (tree, (lv, le)) => NewMap.define(tree, lv, le))
      (tree, bindings)
d304 1
a304 1
    get_simple_bindings(get_simple_bindings(tree, le), le')
d307 1
a307 2
  | get_simple_bindings(tree,
			LambdaTypes.SWITCH(le, tag_le_list, def1, def2)) =
d309 1
a309 1
      val tree = get_simple_bindings(do_opt(do_opt(tree, def1), def2), le)
d312 3
a314 3
      (fn (tree, (tag, le)) =>
       do_tag(get_simple_bindings(tree, le), tag))
      (tree, tag_le_list)
d318 2
a319 2
    (fn (tree, le) => get_simple_bindings(tree, le))
    (tree, le_list)
d321 1
a321 1
    get_simple_bindings(tree, le)
d323 1
a323 1
    get_simple_bindings(tree, le)
d325 1
a325 1
    get_simple_bindings(get_simple_bindings(tree, le), le')
@


1.25
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d4 3
d114 1
a114 1
  structure NewMap = LambdaTypes.Datatypes.NewMap
d441 1
a441 6
	(NewMap.empty (LambdaTypes.LVar_order,LambdaTypes.LVar_eq), reduced_list)
(*
	map
	(fn (lv, (_, le)) => (lv, le))
	reduced_list
*)
d470 1
a470 6
	(NewMap.empty(LambdaTypes.LVar_order,LambdaTypes.LVar_eq), reduced_list)
(*
	map
	(fn (lv, (_, le)) => (lv, le))
	reduced_list
*)
d488 1
a488 1
	get_simple_bindings(NewMap.empty (LambdaTypes.LVar_order,LambdaTypes.LVar_eq), lambda_exp)
d533 1
a533 1
      Lists.reducel add_escape (NewMap.empty(LambdaTypes.LVar_order,LambdaTypes.LVar_eq), fn_bindings)
@


1.24
log
@Removed some unncesessary intermediate lists which
were being built.
@
text
@d4 4
a260 5
  fun lv_order arg =
    if LambdaTypes.LVar_eq arg then NewMap.EQUAL
    else if LambdaTypes.LVar_order arg then NewMap.LESS
    else NewMap.GREATER

d438 1
a438 1
	(NewMap.empty lv_order, reduced_list)
d472 1
a472 1
	(NewMap.empty lv_order, reduced_list)
d495 1
a495 1
	get_simple_bindings(NewMap.empty lv_order, lambda_exp)
a538 5

      fun lv_order x =
	if LambdaTypes.LVar_eq x then NewMap.EQUAL
	else if LambdaTypes.LVar_order x then NewMap.LESS
	     else NewMap.GREATER
d540 1
a540 1
      Lists.reducel add_escape (NewMap.empty lv_order, fn_bindings)
@


1.23
log
@Added list of escaping primitives
@
text
@d4 3
d536 9
a544 35
(*
      val _ = print_bindings fn_bindings
      val _ =
	Print.print
	(implode
	 ("Lambdas bound to functions" ::
	  (map (fn (x, y) => "Lambda " ^ LambdaTypes.printLVar x ^
		"\nbinds to\n" ^ LambdaPrint.string_of_lambda y ^ "\n")
	   fn_bindings)))
*)

      val escape_list =
	map (fn (lv, LambdaTypes.FN(lvar, lexp,_,_)) =>
	     (lv, escapes(lvar, lexp))
            | _ => Crash.impossible"Non-FN in escape_map fn_bindings")
	fn_bindings
(*
      val _ = Print.print"Escaping function list\n"
      val _ =
	Lists.iterate
	(fn (lv, b) => Print.print(LambdaTypes.printLVar lv ^
				   (if b then
				      " escapes\n"
				    else
				      " does not escape\n")))
	escape_list
*)
	fun lv_order x =
	  if LambdaTypes.LVar_eq x then
	    NewMap.EQUAL
	  else
	    if LambdaTypes.LVar_order x then
	      NewMap.LESS
	    else
	      NewMap.GREATER
d546 1
a546 1
      NewMap.from_list lv_order escape_list 
d548 2
a549 1
end
@


1.22
log
@Now use NewMap instead of BalancedTree.
@
text
@d4 3
a81 1
require "../utils/newmap";
a87 1
require "lambdatypes";
a91 1
  structure NewMap : NEWMAP
a97 1
  structure LambdaTypes : LAMBDATYPES
d99 2
a100 2
  sharing LambdaSub.LT = LambdaTypes = LambdaPrint.LambdaTypes
  sharing type LambdaTypes.Primitive = Pervasives.pervasive
d103 2
a104 3
  structure LambdaTypes = LambdaTypes
  structure NewMap = NewMap

d124 8
d137 4
a140 14
      (case prim of
	Pervasives.REF => convert_escape esc_type
      | Pervasives.ARRAY_FN => convert_escape esc_type
      | Pervasives.MAP => convert_escape esc_type
      | Pervasives.REV => convert_escape esc_type
      | Pervasives.AT => convert_escape esc_type
      | Pervasives.HAT => convert_escape esc_type
      | Pervasives.BECOMES => convert_escape esc_type
      | Pervasives.UPDATE => convert_escape esc_type
      | Pervasives.O => convert_escape esc_type
      | Pervasives.CALL_C => convert_escape esc_type
      | Pervasives.EXIOVAL => convert_escape esc_type
      | Pervasives.EXPLODE => convert_escape esc_type
      | _ => reduce_escape esc_type)
@


1.21
log
@eta_abstract now takes a type annotation
@
text
@d4 3
a79 1
require "../utils/balancedtree";
a91 1
  structure BalancedTree : BALANCEDTREE
d259 3
a261 7
    if LambdaTypes.LVar_eq arg then
      BalancedTree.EQ
    else
      if LambdaTypes.LVar_order arg then
	BalancedTree.LT
      else
	BalancedTree.GT
d268 1
a268 1
	(fn (tree, (lv, le)) => BalancedTree.insert(tree, lv, le))
d291 1
a291 1
      (fn (tree, (lv, le)) => BalancedTree.insert(tree, lv, le))
d362 4
a365 4
    (case BalancedTree.lookup(all_bindings, lv') of
       BalancedTree.YES(LambdaTypes.STRUCT le_list) =>
	 (true, Lists.nth(index, le_list))
     | _ => (false, le))
d393 2
a394 8
(*
    ((lv, Lists.assoc(lv', all_bindings))
     handle Lists.Assoc =>
       (lv, le))
*)
    (case BalancedTree.lookup(all_bindings, lv') of
       BalancedTree.YES le' => BalancedTree.insert(all_bindings, lv, le')
     | _ => all_bindings)
a399 4
      val le = Lists.assoc(lv', all_bindings)
	handle Lists.Assoc => var
*)
(*
d409 4
a412 8
      case BalancedTree.lookup(all_bindings, lv) of
	BalancedTree.YES le' =>
	  (case le' of LambdaTypes.FN _ => all_bindings
	| _ => BalancedTree.insert(all_bindings, lv, le'))
      | _ => all_bindings
    (*
     (lv, case le of LambdaTypes.FN _ => var | _ => le)
       *)
d421 1
a421 1
	(all_bindings, BalancedTree.to_alist all_bindings)
d426 1
a426 1
	(BalancedTree.to_alist all_bindings)
d439 2
a440 2
	 BalancedTree.insert(tree, lv, le))
	(BalancedTree.empty lv_order, reduced_list)
d456 1
a456 1
	(all_bindings, BalancedTree.to_alist all_bindings)
d461 1
a461 1
	(BalancedTree.to_alist all_bindings)
d473 2
a474 2
	 BalancedTree.insert(tree, lv, le))
	(BalancedTree.empty lv_order, reduced_list)
d489 1
a489 1
	BalancedTree.insert(tree, lv, le)
d497 2
a498 2
	get_simple_bindings(BalancedTree.empty lv_order, lambda_exp)
      val all_list = BalancedTree.to_alist all_bindings
d524 1
a524 1
      Lists.filterp is_fn_binding (BalancedTree.to_alist all_bindings)
d532 1
a532 1
      Lists.filterp is_fn_or_var_binding (BalancedTree.to_alist all_bindings)
@


1.20
log
@Added LET constructor and new slot to APP.
@
text
@d4 3
d290 1
a290 1
         | arg => LambdaSub.eta_abstract (arg,"eta_abstract in _interproc"))
@


1.19
log
@Fixed a problem whereby function arguments got put in closures of
sub functions without realising that those arguments must be on the heap
@
text
@d4 4
a121 20
  fun occurs(lvar, expression) =
    let
      fun occurs'(LambdaTypes.VAR lv) = LambdaTypes.LVar_eq(lv, lvar)
      | occurs'(LambdaTypes.FN(_, le,_,_)) = occurs' le
      | occurs'(LambdaTypes.LETREC(lv_list, le_list, le)) =
	Lists.exists occurs' (le :: le_list)
      | occurs'(LambdaTypes.APP(le, le' )) = occurs' le orelse occurs' le'
      | occurs'(LambdaTypes.SCON _) = false
      | occurs'(LambdaTypes.INT _) = false
      | occurs'(LambdaTypes.SWITCH(le, tag_le_list, leo1, leo2)) =
	occurs' le orelse occurs_opt leo1 orelse occurs_opt leo2 orelse
	Lists.exists
	occurs_tag
	tag_le_list
      | occurs'(LambdaTypes.STRUCT le_list) =
	Lists.exists occurs' le_list
      | occurs'(LambdaTypes.SELECT(_, le)) = occurs' le
      | occurs'(LambdaTypes.RAISE le) = occurs' le
      | occurs'(LambdaTypes.HANDLE(le, le' ,_)) = occurs' le orelse occurs' le'
      | occurs'(LambdaTypes.BUILTIN _) = false
d123 1
a123 12
      and occurs_opt(LambdaTypes.ABSENT) = false
      | occurs_opt(LambdaTypes.PRESENT le) = occurs' le

      and occurs_tag(tag, le) =
	(case tag of
	   LambdaTypes.EXP_TAG le => occurs' le
	 | _ => false) orelse occurs' le
    in
      occurs' expression
    end

  fun escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.BUILTIN prim, le)) =
d142 20
d163 1
a163 1
				  LambdaTypes.VAR lvar')) =
d166 1
d176 3
a178 2
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_,_), le')) =
    (case escapes_sub(lvar, le') of
d182 3
a184 2
	 combine_type(escapes_sub(lv', le), escapes_sub(lvar, le)))
  | escapes_sub(lvar, LambdaTypes.APP(le, le')) =
d192 1
a192 1
    if occurs(lvar, le) then raise_escape else no_escape
d195 1
a195 1
    if Lists.exists (fn le => occurs(lvar, le)) le_list then
d263 1
a263 1
  fun get_simple_bindings(tree, le as LambdaTypes.APP(LambdaTypes.FN _, _)) =
d273 1
d294 1
a294 1
  | get_simple_bindings(tree, LambdaTypes.APP(le, le')) =
d332 1
a332 1
  | is_fn_binding _ = false
d335 1
a335 1
  | is_letrec_binding _ = false
d338 1
a338 1
  | is_var_binding _ = false
@


1.18
log
@Added an annotation slot to HANDLE
@
text
@d4 3
d118 32
d196 1
a196 1
    convert_escape(escapes_sub(lvar, le))
d199 4
a202 7
(*
    (case convert_escape
       (Lists.reducel
	combine_type
	(no_escape, map (fn le => escapes_sub(lvar, le)) le_list)) of
       no_escape => escapes_sub(lvar, le)
     | _ => raise_escape)
a203 4
*)
    (case convert_escape(escapes_sub_list(no_escape, lvar, le_list)) of
       no_escape => escapes_sub(lvar, le)
     | _ => raise_escape)
a209 4
(*
      fun escapes_tag(LambdaTypes.EXP_TAG le) = escapes_sub(lvar, le)
      | escapes_tag _ = no_escape
*)
a221 9
(*
      Lists.reducel
      combine_type
      (escapes_sub(lvar, le),
       escapes_opt le_opt1 ::
       escapes_opt le_opt2 ::
       map (fn (tag, x) => combine_type(escapes_tag tag,
					escapes_sub(lvar, x))) tag_le_list)
*)
a224 5
(*
    (Lists.reducel
     combine_type
     (no_escape, map (fn x => escapes_sub(lvar, x)) le_list))
*)
@


1.17
log
@Needed to add NullTypes in the FNexps that are generated
@
text
@d4 3
d222 1
a222 1
  | escapes_sub(lvar, LambdaTypes.HANDLE(le, le')) =
d309 1
a309 1
  | get_simple_bindings(tree, LambdaTypes.HANDLE(le, le')) =
@


1.16
log
@Modified to use newmap
@
text
@d4 3
d131 1
a131 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_),
d144 1
a144 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le,_), le')) =
d157 1
a157 1
  | escapes_sub(lvar, LambdaTypes.FN(lv, le,_)) =
d265 1
a265 1
  | get_simple_bindings(tree, LambdaTypes.FN(_, le,_)) =
d553 1
a553 1
	map (fn (lv, LambdaTypes.FN(lvar, lexp,_)) =>
@


1.15
log
@Changed to use balanced trees instead of association lists
@
text
@d4 3
d60 1
a60 1
require "../utils/map";
d73 1
a73 1
  structure Map : MAP
d88 1
a88 1
  structure Map = Map
d565 8
d574 1
a574 3
      Lists.reducel
      (fn (x, y) => Map.add(y, x, LambdaTypes.LVar_order))
      (Map.empty_map, escape_list)
@


1.14
log
@First version of the profiler
@
text
@d4 3
d58 1
d71 1
d130 7
a136 4
      if lvar = lvar' then
	combine_type(esc1, escapes_sub(lv', le))
      else
	esc1
d155 1
d163 4
d173 1
d176 1
d178 12
d197 1
d200 2
a201 1
    convert_escape
d205 1
d217 20
d239 10
a248 1
  fun get_simple_bindings(le as LambdaTypes.APP(LambdaTypes.FN _, _)) =
d251 4
a254 1
      val bindings' = get_simple_bindings le
d256 18
d275 2
a276 3
      op @@
      (bindings,
       bindings' :: map (fn (_, le) => get_simple_bindings le) bindings)
d278 6
a283 16
  | get_simple_bindings(LambdaTypes.VAR _) = []
  | get_simple_bindings(LambdaTypes.FN(_, le,_)) = get_simple_bindings le
  | get_simple_bindings(LambdaTypes.LETREC(lv_list, le_list, le)) =
    Lists.reducel
    op @@
    (Lists.zip(lv_list,
	       map
	       (fn (arg as LambdaTypes.FN _) => arg
	       | arg => LambdaSub.eta_abstract (arg,"eta_abstract in _interproc"))
	       le_list) @@ get_simple_bindings le,
     map get_simple_bindings le_list)
  | get_simple_bindings(LambdaTypes.APP(le, le')) =
    get_simple_bindings le @@ get_simple_bindings le'
  | get_simple_bindings(LambdaTypes.SCON _) = []
  | get_simple_bindings(LambdaTypes.INT _) = []
  | get_simple_bindings(LambdaTypes.SWITCH(le, tag_le_list, def1, def2)) =
d285 1
a285 4
      fun do_opt LambdaTypes.ABSENT = []
      | do_opt(LambdaTypes.PRESENT le) = get_simple_bindings le
      fun do_tag(LambdaTypes.EXP_TAG le) = get_simple_bindings le
      | do_tag _ = []
d287 4
a290 3
      Lists.reducel op @@
      (get_simple_bindings le @@ do_opt def1 @@ do_opt def2,
       map (fn (tag, le) => do_tag tag @@ get_simple_bindings le) tag_le_list)
d292 11
a302 8
  | get_simple_bindings(LambdaTypes.STRUCT le_list) =
    Lists.reducel op @@
    ([], map get_simple_bindings le_list)
  | get_simple_bindings(LambdaTypes.SELECT(_, le)) = get_simple_bindings le
  | get_simple_bindings(LambdaTypes.RAISE le) = get_simple_bindings le
  | get_simple_bindings(LambdaTypes.HANDLE(le, le')) =
    get_simple_bindings le @@ get_simple_bindings le'
  | get_simple_bindings(LambdaTypes.BUILTIN _) = []
d304 11
d346 5
d368 1
d376 2
a377 1
  fun reduce_var_bindings((lv, le as LambdaTypes.VAR lv'), all_bindings) =
d381 5
a385 1
  | reduce_var_bindings(arg, _) = arg
d387 1
a387 1
  fun reduce_var_bindings'((lv, var as LambdaTypes.VAR lv'), all_bindings) =
d389 1
d392 1
d403 8
a410 1
      (lv, case le of LambdaTypes.FN _ => var | _ => le)
d412 1
a412 1
  | reduce_var_bindings'(arg, _) = arg
d417 3
a419 3
	map
	(fn x => reduce_var_bindings'(x, all_bindings))
	all_bindings
d424 1
a424 1
	all_bindings
d435 5
d443 1
d452 3
a454 3
	map
	(fn x => reduce_var_bindings(x, all_bindings))
	all_bindings
d459 1
a459 1
	all_bindings
d469 5
d477 1
d482 10
d494 5
a498 2
      val all_bindings = get_simple_bindings lambda_exp
      val letrec_bindings = Lists.filterp is_letrec_binding all_bindings
d506 2
a507 1
	all_bindings
d509 4
d514 1
d522 1
a522 1
      Lists.filterp is_fn_binding all_bindings
d530 1
a530 1
      Lists.filterp is_fn_or_var_binding all_bindings
@


1.13
log
@Improved escapes in order to reflect a conservatively correct answer
@
text
@d4 3
d120 1
a120 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le),
d130 1
a130 1
  | escapes_sub(lvar, LambdaTypes.APP(LambdaTypes.FN(lv', le), le')) =
d143 1
a143 1
  | escapes_sub(lvar, LambdaTypes.FN(lv, le)) =
d200 1
a200 1
  | get_simple_bindings(LambdaTypes.FN(_, le)) = get_simple_bindings le
d207 1
a207 1
	       | arg => LambdaSub.eta_abstract arg)
d415 1
a415 1
	map (fn (lv, LambdaTypes.FN(lvar, lexp)) =>
@


1.12
log
@Changed print for Print.print
@
text
@d4 3
d84 3
a86 4
  fun combine_type((raise_escape, opt), _) = (raise_escape, opt)
  | combine_type(_, (raise_escape, opt)) = (raise_escape, opt)
  | combine_type((simple_escape, _), (simple_escape, _)) =
    (raise_escape, LambdaTypes.ABSENT)
d88 3
a90 3
  | combine_type(arg1 as (simple_escape, _), _) = arg1
  | combine_type(_, arg2 as (simple_escape, _)) = arg2
  | combine_type _ = (no_escape, LambdaTypes.ABSENT)
d92 6
d100 1
a100 3
      fun convert_escape no_escape = (no_escape, LambdaTypes.ABSENT)
      | convert_escape _ = (raise_escape, LambdaTypes.ABSENT)
      val esc_type = #1 (escapes_sub(lvar, le))
d108 1
d113 3
a115 4
      | _ =>
	  (case esc_type of
	    raise_escape => (raise_escape, LambdaTypes.ABSENT)
	  | _ => (no_escape, LambdaTypes.ABSENT)))
d119 8
a126 4
    if lvar = lvar' then
      combine_type(escapes_sub(lvar, le), escapes_sub(lv', le))
    else
      escapes_sub(lvar, le)
d128 5
a132 2
    combine_type(escapes_sub(lvar, le'), escapes_sub(lvar, le))
    (* Take naive view at the moment *)
d134 4
a137 2
    combine_type(escapes_sub(lvar, le'), escapes_sub(lvar, le))
    (* Take naive view at the moment, ie not analysing the function *)
d139 1
a139 4
    if lvar = lvar' then
      (simple_escape, LambdaTypes.PRESENT le)
    else
      (no_escape, LambdaTypes.ABSENT)
d141 2
a142 1
    (no_escape, LambdaTypes.ABSENT)
d144 9
a152 5
    (no_escape, LambdaTypes.ABSENT)
  | escapes_sub(lvar, LambdaTypes.SCON _) =
    (no_escape, LambdaTypes.ABSENT)
  | escapes_sub(lvar, LambdaTypes.INT _) =
    (no_escape, LambdaTypes.ABSENT)
d155 1
a155 1
      fun escapes_opt LambdaTypes.ABSENT = (no_escape, LambdaTypes.ABSENT)
d157 2
d162 2
a163 1
      (escapes_opt le_opt1,
d165 2
a166 1
       map (fn (_, x) => escapes_sub(lvar, x)) tag_le_list)
d169 9
a177 7
      Lists.reducel
      combine_type
      ((no_escape, LambdaTypes.ABSENT),
       map (fn x => escapes_sub(lvar, x)) le_list)
  | escapes_sub(lvar, LambdaTypes.SELECT(_, LambdaTypes.VAR _)) =
    (no_escape, LambdaTypes.ABSENT)
  | escapes_sub(lvar, LambdaTypes.SELECT(_, le)) = escapes_sub(lvar, le)
d179 1
a179 3
    (case escapes_sub(lvar, le) of
       result as (no_escape, opt) => result
    | _ => (raise_escape, LambdaTypes.ABSENT))
d182 1
a182 2
  | escapes_sub(lvar, LambdaTypes.BUILTIN _) =
    (no_escape, LambdaTypes.ABSENT)
d184 1
a184 5
  fun escapes(lvar, le) =
    (case #1 (escapes_sub(lvar, le)) of
      simple_escape => true
    | raise_escape => true
    | no_escape => false)
d215 2
d220 1
a220 1
       map (fn (_, le) => get_simple_bindings le) tag_le_list)
d400 11
d417 1
a417 1
      val _ = print"Escaping function list"
d419 6
a424 3
	map
	(fn (lv, b) => print(LambdaTypes.printLVar lv ^
			     if b then " escapes" else " does not escape"))
d433 1
@


1.11
log
@Fixed bug in find_letrec_real_bindings whereby a LETREC stage was
being skipped.
@
text
@d4 4
d236 2
a237 2
    (fn (lv, le) => print("Var " ^ LambdaTypes.printLVar lv ^ ", Exp" ^
			  LambdaPrint.string_of_lambda le))
@


1.10
log
@Took out the odd letrec binding message
@
text
@d4 3
d224 1
a224 1
    | LambdaTypes.LETREC(_, _, le) => find_letrec_real_bindings le
d226 3
a228 2
  | find_letrec_real_bindings _ =
    Crash.impossible"find_letrec_bindings on non-LETREC"
@


1.9
log
@Added ARRAY and UPDATE details
@
text
@d4 3
d222 1
a222 10
    | _ =>
	let
	  val _ = print"Odd LETREC binding in"
	  val _ = LambdaPrint.print_lambda le
	in
	  le
(*
	  Crash.impossible"Impossible?"
*)
	end)
@


1.8
log
@Added Lists.Assoc handlers. Coped with case of var bindings direct
to function argument, which optimiser would have removed
@
text
@d4 4
d88 1
d93 1
@


1.7
log
@Fixed problem with unusual LETREC bindings.
This may need more investigation
@
text
@d4 4
d37 1
d49 1
d242 2
d260 4
a263 2
  fun reduce_var_bindings((lv, LambdaTypes.VAR lv'), all_bindings) =
    (lv, Lists.assoc(lv', all_bindings))
d269 10
@


1.6
log
@Added function to return variable and function bindings for
curried function optimisation
@
text
@d4 4
d209 1
a209 1
	  val _ = print"Bad LETREC binding in"
d212 2
d215 1
@


1.5
log
@Added function to return list of function bindings
Modified escape_map to use this list rather than recalculating it
@
text
@d4 4
d160 4
a163 1
	       map LambdaSub.eta_abstract le_list) @@ get_simple_bindings le,
d193 5
d208 1
a208 1
	  Crash.impossible"Impossible"
d222 1
a222 2
    (* Attempt to pull out what a selection really binds to in the *)
    (* case of a LETREC value *)
d249 37
d313 1
a313 1
  fun binding_list lambda_exp =
d325 7
a331 1
      val all_bindings = other_bindings @@ letrec_real_bindings
a332 2
      val fn_bindings =
	Lists.filterp is_fn_binding all_bindings
d334 9
a342 1
      fn_bindings
@


1.4
log
@Fixed bug whereby function bodies within LETRECs weren't searched for
further bindings
@
text
@d3 5
a7 1
$Log:	_interproc.sml,v $
d265 1
a265 1
  fun escape_map lambda_exp =
a277 12

(*
      val _ = print"Total binding set"
      val _ = print_bindings all_bindings

      val _ = print"Letrec binding set"
      val _ = print_bindings letrec_bindings

      val _ = print"Letrec real binding set"
      val _ = print_bindings letrec_real_bindings
*)

a278 6

(*
      val _ = print"New all_binding set"
      val _ = print_bindings all_bindings
*)

d281 3
a283 4
      
(*
      val _ = print"fn_binding set"
      val _ = print_bindings fn_bindings
d285 2
a286 3
      val _ = print"New all_binding set"
      val _ = print_bindings all_bindings
*)
d290 1
a290 1
            | _ => Crash.impossible"Non-FN in new_fn_bindings")
@


1.3
log
@Removed eta_abstract and referenced one in LambdaSub
@
text
@d4 3
d149 5
a153 2
    Lists.zip(lv_list,
	      map LambdaSub. eta_abstract le_list) @@ get_simple_bindings le
@


1.2
log
@Added function to produce a lambda var to bool map of whether the
 referenced function has an escaping argument or not
@
text
@d4 4
a132 6
  fun eta_abstract le =
    let val lvar = LambdaTypes.new_LVar()
    in
      LambdaTypes.FN(lvar, LambdaTypes.APP(le, LambdaTypes.VAR lvar))
    end

d146 2
a147 1
    Lists.zip(lv_list, map eta_abstract le_list) @@ get_simple_bindings le
@


1.1
log
@Initial revision
@
text
@d3 4
a6 1
$Log$
d11 2
d16 1
d22 2
d27 1
d30 1
a30 1
  sharing LambdaSub.LT = LambdaTypes
d34 2
a36 1
  structure LambdaTypes = LambdaTypes
d129 187
a316 1

@
