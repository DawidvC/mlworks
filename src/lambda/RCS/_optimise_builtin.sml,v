head	1.44;
access;
symbols
	ML_beta_release_12/08/94:1.41
	ML_beta_release_03/08/94:1.41
	ML_revised_beta_release_25/05/94:1.37
	ML_final_beta_release_02/03/94:1.37
	mlworks-28-01-1994:1.36
	Release:1.33
	mlworks-beta-01-09-1993:1.33
	MLWorks-1-0-4-29/01/1993:1.29
	MLWorks-1-0-3-21/12/1992:1.28
	MLWorks-1-0-2-15/12/1992:1.27
	MLWorks-1-0-1-04/12/1992:1.26
	checkpoint_17_08_92:1.22;
locks; strict;
comment	@ * @;


1.44
date	94.10.10.09.44.11;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	94.09.19.14.22.23;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	94.09.12.11.16.06;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	94.07.19.14.23.54;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	94.06.15.10.42.46;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	94.06.10.17.23.52;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	94.06.10.16.29.14;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	94.02.01.15.04.13;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	93.11.25.15.48.34;	author nosa;	state Exp;
branches;
next	1.35;

1.35
date	93.11.25.13.54.59;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	93.08.16.11.31.25;	author nosa;	state Exp;
branches;
next	1.33;

1.33
date	93.07.12.10.10.53;	author nosa;	state Exp;
branches
	1.33.1.1;
next	1.32;

1.32
date	93.07.05.13.14.03;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	93.03.10.16.28.27;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	93.03.03.17.47.30;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	93.01.14.14.30.01;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	92.12.17.17.14.33;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	92.12.15.11.57.34;	author clive;	state Exp;
branches;
next	1.26;

1.26
date	92.11.26.19.33.05;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	92.09.30.13.54.20;	author clive;	state Exp;
branches;
next	1.24;

1.24
date	92.09.21.12.08.03;	author clive;	state Exp;
branches;
next	1.23;

1.23
date	92.08.26.13.10.44;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	92.08.05.17.51.55;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.07.29.10.19.20;	author clive;	state Exp;
branches;
next	1.20;

1.20
date	92.07.24.16.31.50;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.07.23.14.56.23;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	92.07.23.13.00.56;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	92.07.17.14.25.36;	author clive;	state Exp;
branches;
next	1.16;

1.16
date	92.07.10.14.35.19;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	92.07.09.14.17.12;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	92.07.02.10.02.07;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	92.07.02.10.00.04;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	92.06.30.10.26.08;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	92.06.16.14.37.26;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.06.11.08.46.43;	author clive;	state Exp;
branches;
next	1.9;

1.9
date	92.05.20.10.36.04;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.05.15.10.44.53;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	92.04.16.11.09.25;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	92.04.13.16.42.36;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.04.08.16.55.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	92.03.27.12.17.30;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.10.22.14.05.01;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.09.11.12.32.13;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.09.09.11.46.29;	author davida;	state Exp;
branches;
next	;

1.33.1.1
date	93.07.12.10.10.53;	author jont;	state Exp;
branches;
next	;


desc
@Optimisation on expressions containing 
applications of built-in functions.
@


1.44
log
@Lambdatypes changes
@
text
@
(*
 * Lambda-Calculus Optimisation: _optimise_builtin
 * Constant Folding, Identity Re-writes,
 * Algebraic Transformations.
 *
 * Copyright (c) 1991 Harlequin Ltd.
 *)

require "../utils/crash";
require "../utils/lists";
require "../utils/print";
require "../utils/integer";
require "../utils/bignum";
require "../main/primitives";
require "../main/pervasives";
require "../typechecker/types";
require "../debugger/debugger_types";
require "environ";
require "optimise_beta";   (* for inlining during map *)
require "optimise_builtin";
require "lambdasub";
require "lambdaprint";

functor OptimiseBuiltin(
  structure Crash : CRASH
  structure Lists : LISTS
  structure Print : PRINT
  structure Integer : INTEGER

  structure LambdaSub : LAMBDASUB
  structure LambdaPrint : LAMBDAPRINT
  structure Types : TYPES

  structure OptimiseBeta : OPTIMISE_BETA

  and Environ     : ENVIRON
  and Primitives  : PRIMITIVES
  and Pervasives  : PERVASIVES
  and BigNum      : BIGNUM

  structure Debugger_Types : DEBUGGER_TYPES

  sharing LambdaPrint.LambdaTypes.Ident = Types.Datatypes.Ident

  sharing type Debugger_Types.Type = LambdaPrint.LambdaTypes.Type = Types.Datatypes.Type

  val primitive_list_nil  : LambdaSub.LT.LambdaExp
  val primitive_true      : LambdaSub.LT.LambdaExp
  and primitive_false     : LambdaSub.LT.LambdaExp

  exception Ord and Chr
  val ord_fold_function : string -> int
  and chr_fold_function : int -> string

    sharing type Pervasives.pervasive = 
                 LambdaSub.LT.Primitive (* Ha! I know this! *)

    sharing LambdaSub.LT =
            Primitives.EnvironTypes.LambdaTypes = LambdaPrint.LambdaTypes =
	    OptimiseBeta.LT
    sharing Environ.EnvironTypes = Primitives.EnvironTypes
    ) : OPTIMISE_BUILTIN = 

struct
  (* preamble *)

  structure LS = LambdaSub
  structure LT = LS.LT
  structure Ident = LT.Ident
  structure Location = Ident.Location
  structure P = Pervasives
  structure Symbol = Ident.Symbol
  structure Datatypes = Types.Datatypes

  val unknownLocation = Location.UNKNOWN

  fun fst(x,_)=x and snd(_,y)=y
  fun curry f x y = f(x,y)

  val show_debug_info = ref true;
  fun info message = if !show_debug_info then Print.print message else ()

 (***********************************************)
 (*  CONSTANT FOLDING  &  ALGEBRAIC IDENTITIES  *)
 (***********************************************)

   val max_map_fold_length = ref 30;   (*  max list length to constant fold *)
   val min_concats_to_implode = ref 3; (*  conversion of ^'s to implode     *)
   val inline_during_map_fold = ref true   (* whether to call inlining *)

   exception Div and Mod

   exception CantRewrite         (* raised when rewrites are not applicable *)

  (*************************************************)
  (*  functions for building and extracting lists  *)
  (*************************************************)
 
 fun make_primitive_list [] = primitive_list_nil
   | make_primitive_list (x::xs) = LT.STRUCT([x,make_primitive_list xs],LT.TUPLE)

 exception CantFindList 
 fun extract_primitive_list (LT.STRUCT([element,tail],LT.TUPLE)) =
				element::(extract_primitive_list tail)
   | extract_primitive_list tag = if LS.lambda_equality(tag,primitive_list_nil)
				     then []
				  else raise CantFindList

 fun extract_primitive_list'(acc, LT.STRUCT([element,tail],LT.TUPLE)) =
     extract_primitive_list'(element :: acc, tail)
   | extract_primitive_list'(acc, tag) =
     if LS.lambda_equality(tag,primitive_list_nil) then
       acc
     else raise CantFindList

 (*******************************)
 (*  Specific Function Folding  *)
 (*******************************)

 fun fold_map generate_recipes element_type (oinfo, inlinesub) (map_fn, map_list) =
   (let
      val thelist = extract_primitive_list map_list
    in
      if (Lists.length thelist <= (!max_map_fold_length))
	then 
	  let
	    val (map_fn_var,need_let) = 
	      case map_fn of
		LT.VAR fn_var => (fn_var,false)
	      | _ => let
		       val v = LT.new_LVar()
		     in 
		       (v, true)
		     end
		   
	    fun app_map_fn x = LT.APP(LT.VAR map_fn_var, [x],
				      LT.Option.PRESENT(ref(element_type)))

	    val mapped_list = (make_primitive_list (map app_map_fn thelist))

	    val inlined_mapped_list = 
	      if !inline_during_map_fold
		then 
		  OptimiseBeta.function_inline generate_recipes inlinesub (oinfo,mapped_list)
	      else mapped_list
	  in
	    (info "folded map";
	     if need_let
	       then LT.LET((map_fn_var,LT.Option.ABSENT,map_fn),mapped_list)
	     else mapped_list)
	  end
      else raise CantRewrite
    end) handle CantFindList => raise CantRewrite



  fun fold_rev listexpr =
     (let
	 val thelist = extract_primitive_list listexpr
	 val result  = make_primitive_list (rev thelist)
      in
	 (info "folded rev"; result)
      end) handle CantFindList => raise CantRewrite


  fun fold_explode (LT.SCON (Ident.STRING string)) =
     (info "folded explode";
      make_primitive_list (map (LT.SCON o Ident.STRING) (explode string)))
    | fold_explode _ = raise CantRewrite


  fun fold_implode listexpr =
    (let
       val thelist = extract_primitive_list'([], listexpr)

       fun coalesce_strings strings =
	 (* Takes a reversed list of items to be coalesced (imploded) *)
	 let
	   fun add_sofar (acc,[]) = acc
	     (* sofar is a correctly ordered list of strings *)
	     | add_sofar (acc,sofar) =
	       let
		 val coalesced = LT.SCON (Ident.STRING (implode sofar))
	       in
		 coalesced::acc
	       end

	   fun coalesce(acc,sofar,[]) =
	     (* This has two accumulators (acc and sofar) *)
	     (* acc is the set of fully reduced expressions, which will *)
	     (* be imploded in the resulting runtime *)
	     (* sofar is a list of strings which will be imploded now *)
	     (* when we can't find any more to add to it *)
	     (* sofar is a correctly ordered list *)
	     (* acc is a correctly ordered list *)
	     (* The final parameter is the reverse ordered input list *)
	     (* which in the simple case just becomes reversed into sofar *)
	     (case add_sofar(acc,sofar) of
		[] => LT.SCON (Ident.STRING "")
	      | [result] => result
	      | [r1,r2] => LT.APP(LT.BUILTIN P.HAT, [LT.STRUCT([r1,r2],LT.TUPLE)],
				  LT.Option.PRESENT(ref(Debugger_Types.string_pair_type)))
	      | new_list => LT.APP(LT.BUILTIN P.IMPLODE, 
				   [make_primitive_list new_list],
                                   LT.Option.PRESENT(ref(Debugger_Types.string_list_type))))
	     | coalesce (acc,sofar,s::ss) =
	       (case s of
		  (LT.SCON (Ident.STRING t)) => coalesce(acc,t::sofar,ss)
		| (le as LT.APP(LT.BUILTIN P.IMPLODE, [another_list], _)) =>
		    (let
		       val nested_list =
			 extract_primitive_list'([], another_list)
		     (* Another reversed list coming up *)
		     in
		       coalesce(acc,sofar,nested_list@@ss)
		       (* Note both ss and nested_list are reversed *)
		     end handle CantFindList =>
		       coalesce(le :: add_sofar(acc,sofar),[],ss))
		| (LT.APP(LT.BUILTIN P.HAT,[LT.STRUCT([x,y],LT.TUPLE)],_)) => 
		    coalesce(acc, sofar, y::x::ss)
		| le => coalesce(le::(add_sofar(acc,sofar)),[],ss))
	 in
	   coalesce([],[],strings)
	 end

     in
       coalesce_strings thelist
     end) handle CantFindList => raise CantRewrite

  fun fold_ord (LT.SCON (Ident.STRING s)) =
     (info "folded ord";
      LT.SCON(Ident.INT(Integer.makestring(ord_fold_function s),unknownLocation)))
    | fold_ord _ = raise CantRewrite
      

  fun fold_chr (LT.SCON (Ident.INT(i,_))) =
     let
	fun makeint(acc, x::xs) = makeint(acc*10 + ord x-ord "0", xs)
	  | makeint(acc, []) = acc
     in
	(info "folded chr";
	 LT.SCON (Ident.STRING (chr_fold_function (makeint(0,explode i)))))
     end
   | fold_chr _ = raise CantRewrite
  

  fun fold_concat (LT.SCON(Ident.STRING s1),
		   LT.SCON(Ident.STRING s2)) = (info "folded ^";
						LT.SCON(Ident.STRING(s1^s2)))
    | fold_concat _ = raise CantRewrite


  fun fold_size (LT.SCON(Ident.STRING s)) =
    (info "folded size";
     LT.SCON(Ident.INT 
	     (Integer.makestring (size s),
              unknownLocation)))
    | fold_size _ = raise CantRewrite


  (***********************)
  (*  Simple Identities  *)  (* NB:- rely on unique reps for SCON's *)
  (***********************)

  local 
     val s = "+ identity removed"
  in
  fun plus_ident (LT.SCON(Ident.INT("0",_)), y) = (info s; y)
    | plus_ident (x, LT.SCON(Ident.INT("0",_))) = (info s; x)
    | plus_ident _ = raise CantRewrite
  end


  local 
     val s = "- identity removed"
  in
  fun minus_ident (x, LT.SCON(Ident.INT("0",_))) = (info s; x)
    | minus_ident (LT.SCON(Ident.INT("0",_)), y) = 
      (info s; LT.APP(LT.BUILTIN P.INTUMINUS, [y],
                      LT.Option.PRESENT(ref(Debugger_Types.int_type))))
(*
    | minus_ident (x,y) = if LS.lambda_equality(x,y )
			    then (info s; LT.SCON(Ident.INT("0",unknownLocation)))
			  else raise CantRewrite
*)
    | minus_ident _ = raise CantRewrite
  end

  local
     val s = "* identity removed";
  in	
  fun times_ident (x, LT.SCON(Ident.INT("1",_)))         = (info s; x)
    | times_ident (LT.SCON(Ident.INT("1",_)), y)         = (info s; y)
(*
    | times_ident (zero as LT.SCON(Ident.INT("0",_)), y) = (info s; zero)
    | times_ident (x, zero as LT.SCON(Ident.INT("0",_))) = (info s; zero)
*)
    | times_ident _ = raise CantRewrite
  end

  fun is_an_optimisable_power_of_two 0 = false 
    | is_an_optimisable_power_of_two 1 = true
    | is_an_optimisable_power_of_two x = 
      if x mod 2 = 1
        then false
      else is_an_optimisable_power_of_two(x div 2)

  local
     val s = "div identity removed"
  in
  fun div_ident (x, LT.SCON(Ident.INT("1",_))) = (info s; x)
    | div_ident (x, LT.SCON(Ident.INT("0",_))) = (info s; raise Div)
    | div_ident (LT.SCON(Ident.INT ("0",l)), _) = (info s; LT.SCON(Ident.INT("0",l)))
    | div_ident (x,y) = 
(*
      if LS.lambda_equality(x,y)
	then (info s; LT.SCON(Ident.INT("1",unknownLocation)))
      else
*)
      let
        fun log2 1 = 0
          | log2 x = 1 + log2(x div 2)
        val true_value = 
          case y of
            LT.SCON(Ident.INT(value,_)) => 
	      (Integer.parseinteger value handle _ => 0)
          | _ => 0
        val optimise = (true_value > 0) andalso 
	  		is_an_optimisable_power_of_two true_value
      in
        if optimise
          then
            (info "div of positive power of two changed to arithmetic rshift";
             LT.APP(LT.BUILTIN(P.ARSHIFT),
		    [LT.STRUCT([x,LT.SCON(Ident.INT 
                                         (Integer.makestring(log2 true_value),
                                          unknownLocation))],LT.TUPLE)],
		    LT.Option.PRESENT(ref(Debugger_Types.int_pair_type))))
        else
	  raise CantRewrite
      end
  end



(*
  local 
     val s = "mod identity removed"
  in
  fun
      mod_ident (x, LT.SCON(Ident.INT("1",l))) = (info s; LT.SCON(Ident.INT("0",l)))
    | mod_ident (LT.SCON(Ident.INT ("0",l)), y) = (info s; LT.SCON(Ident.INT ("0",l)))
    | mod_ident (x, LT.SCON(Ident.INT ("0",l))) = (info s; raise Mod)
    | mod_ident (x,y) = 
      if LS.lambda_equality(x,y)
	then (info s; LT.SCON(Ident.INT("0",unknownLocation)))
      else
      let
        val true_value = 
          case y of
            LT.SCON(Ident.INT(value,_)) => 
	      (Integer.parseinteger value handle _ => 0)
          | _ => 0
        val optimise = (true_value > 0) andalso 
	  	       is_an_optimisable_power_of_two true_value
      in
        if optimise
          then
            (info "mod of positive power of two changed to and";
             LT.APP(LT.BUILTIN(P.ANDB),
                    [LT.STRUCT([x,
                               LT.SCON(Ident.INT (Integer.makestring(true_value-1),
                               unknownLocation))],LT.TUPLE)],
		    LT.Option.PRESENT(ref(Debugger_Types.int_pair_type))))
        else
	  raise CantRewrite
      end
  end
*)

  local 
     val s = "mod identity removed"
  in
  fun mod_ident (x,y) = 
    let
      val true_value = 
        case y of
          LT.SCON(Ident.INT(value,_)) => 
            (Integer.parseinteger value handle _ => 0)
        | _ => 0
      val optimise = (true_value > 0) andalso 
        is_an_optimisable_power_of_two true_value
    in
      if optimise
        then
          (info "mod of positive power of two changed to and";
           LT.APP(LT.BUILTIN(P.ANDB),
                  [LT.STRUCT([x,
                             LT.SCON(Ident.INT 
                                     (Integer.makestring(true_value-1),
                                      unknownLocation))],LT.TUPLE)],
                  LT.Option.PRESENT(ref(Debugger_Types.int_pair_type))))
      else
        raise CantRewrite
    end
  end

  fun append_ident_fold (list1,list2) =
     let
	exception CantFindNil

	fun replace_end (LT.STRUCT([element,tail],ty)) = 
			  LT.STRUCT([element,replace_end tail],ty)
	  | replace_end tag = 
	    if LS.lambda_equality(tag,primitive_list_nil)
	       then list2
	    else raise CantFindNil
     in
	(let 
	    val result = (if LS.lambda_equality(list2,primitive_list_nil)
			     then list1
			  else (replace_end list1))
	 in
	    info "folded @@";
	    result
	 end)  handle CantFindNil => raise CantRewrite
     end;


  local 
     val s = "^ identity removed"
  in
  fun concat_ident (x, LT.SCON(Ident.STRING "")) = (info s; x)
    | concat_ident (LT.SCON(Ident.STRING ""), y) = (info s; y)
    | concat_ident _ = raise CantRewrite
  end


  fun eq_ident (x,y) = if LS.lambda_equality(x,y)
			 then (info "= identity removed";
			       primitive_true)
		       else raise CantRewrite


  fun ne_ident (x,y) = if LS.lambda_equality(x,y)
			 then (info "<> identity removed";
			       primitive_false)
		       else raise CantRewrite


  (************************)
  (*  The Main Functions  *)
  (************************)

  local
    fun findexn s = 
      case (Environ.lookup_valid
	      (Ident.EXCON(Symbol.find_symbol s),
	    Primitives.initial_env)) of
	Environ.EnvironTypes.PRIM p => p
      | _ => Crash.impossible
	  ("Expected primitive exn in environment for "^s)
     
    fun extract_list_element_type
      (Datatypes.METATYVAR(ref(_,ty,_),_,_),other) =
          extract_list_element_type(ty,other)
      | extract_list_element_type
        (Datatypes.CONSTYPE([el],ty'),default) =
          if ty' = Types.list_tyname then el else default
      | extract_list_element_type (ty,_) =
	  (Pervasives.Diagnostic.output 2 (fn _ => ["*** WARNING: Found ",
					  	    Types.debug_print_type ty,
                                          	    " in extract_list_elem\n"]);
           Datatypes.NULLTYPE)

(*
    fun is_manifest_list l =
      let
	val list = extract_primitive_list l
      in
	Lists.forall is_const list
      end
    handle CantFindList => false
*)

    fun is_const (LT.SCON _) = true
      | is_const (LT.INT _)  = true
      | is_const (LT.STRUCT (list,_)) = Lists.forall is_const list
      | is_const (LT.SELECT(_, le)) = is_const le
      | is_const _ = false

    fun K x _ = x

    fun mkexn ex = LT.RAISE (LT.STRUCT ([LT.BUILTIN ex,LT.STRUCT([],LT.TUPLE)],LT.CONSTRUCTOR));

    fun decon_int (LT.SCON (Ident.INT(s,_))) = BigNum.string_to_bignum s
      | decon_int _ = raise CantRewrite(*Crash.impossible "descon_int: bad arg"*)

    fun recon_int bn = LT.SCON (Ident.INT (BigNum.bignum_to_string bn,unknownLocation))

    fun eval_const(y as LT.SCON x) =
      (case x of
	 Ident.INT(s, l) =>
	 if size s > 1 andalso String.substring(s, 0, 1) = "0" then
	   eval_const(LT.SCON(Ident.INT(String.substring(s, 1, size s - 1), l)))
	 else
	   y
	| Ident.REAL _ => raise CantRewrite
	| Ident.STRING _ => y)
      | eval_const(x as LT.INT _)  = x
      | eval_const(LT.STRUCT (list,ty)) = LT.STRUCT(map eval_const list,ty)
      | eval_const(LT.SELECT({index, ...}, LT.STRUCT (le_list,_))) =
	eval_const(Lists.nth(index, le_list))
      | eval_const _ = raise CantRewrite

    fun recon_bool true  = primitive_true
      | recon_bool false = primitive_false

    (* x&y must be constant *)
    fun wob_fold_eq (x,y) =
      (info "folded =";
       recon_bool (LS.lambda_equality(eval_const x, eval_const y)))

    and wob_fold_ne (x,y) =
      (info "folded <>";
       recon_bool (not(LS.lambda_equality(eval_const x, eval_const y))))

    fun big_wobble1 f x     = (info "folded unary op";
			       recon_int(f (decon_int x)))
    fun big_wobble2 f (x,y) = (info "folded binary op";
			       recon_int(f (decon_int x,decon_int y)))
    fun big_boolwob f (x,y) = (info "folded comparison";
			       recon_bool(f (decon_int x,decon_int y)))

    val zero = BigNum.string_to_bignum "0"
    val one = BigNum.string_to_bignum "1"
    val two = BigNum.string_to_bignum "2"

    fun is_positive(x) =
      BigNum.> (decon_int x,zero)

    fun optimise_shift rightwards (x,y) =
      let
	(* The second argument is positive *)
	val first = decon_int x
	val second = decon_int y
	fun do_shift (first,second) =
	  if BigNum.eq(zero,second)
	    then recon_int first
	  else do_shift((if rightwards then BigNum.div 
			 else BigNum.* ) (first,two),
			BigNum.-(second,one))
      in
	do_shift(first,second)
      end


    fun optimise_logical function (x,y) =
      let
	val first = decon_int x
	val second = decon_int y
	fun do_logical (first,second,position,acc) =
	  if BigNum.eq(zero,first) andalso BigNum.eq(zero,second)
	    then 
	      recon_int acc
	  else 
	    let
	      val first' = BigNum.eq(BigNum.mod(first,two),one)
	      val second' = BigNum.eq(BigNum.mod(second,two),one)
	      val result = 
		if function(first',second')
		  then one
		else zero
	    in
	      do_logical(BigNum.div(first,two),
			 BigNum.div(second,two),
			 BigNum.*(position,two),
			 BigNum.+(acc,BigNum.*(position,result)))
	    end
      in
	do_logical(first,second,one,zero)
      end


    (* Folding/Simplifying Binary functions *)
    (* raises exception CantRewrite if none *)
    (* of the rewrites are applicable.      *)
    (* (NB: includes list functions since   *)
    (*  list arguments appear as a STRUCT). *)

    fun fold_binary (LT.BUILTIN p, (x,y)) =
      if (is_const x) andalso (is_const y) then
	(let
	  val folder =
	  (case p of
	      P.INTPLUS      => big_wobble2 BigNum.+
	    | P.INTMINUS     => big_wobble2 BigNum.-
	    | P.INTSTAR      => big_wobble2 BigNum.*
	    | P.DIV          => big_wobble2 BigNum.div
	    | P.MOD          => big_wobble2 BigNum.mod
	    | P.INTLESS      => big_boolwob BigNum.<
	    | P.INTGREATER   => big_boolwob BigNum.>
	    | P.INTLESSEQ    => big_boolwob BigNum.<=
	    | P.INTGREATEREQ => big_boolwob BigNum.>=
	    | P.EQ           => wob_fold_eq
	    | P.INTEQ 	     => wob_fold_eq
	    | P.REALEQ       => eq_ident
	    | P.STRINGEQ     => wob_fold_eq
	    | P.NE           => wob_fold_ne
	    | P.INTNE        => wob_fold_ne
	    | P.REALNE       => ne_ident
	    | P.STRINGNE     => wob_fold_ne
	    | P.AT           => append_ident_fold
	    | P.HAT          => fold_concat
	    | P.RSHIFT       => if is_positive x andalso is_positive y
				  then raise CantRewrite
				else optimise_shift true 
	    | P.LSHIFT       => if is_positive x andalso is_positive y
				  then raise CantRewrite
				else optimise_shift false
	    | P.ANDB         => if is_positive x andalso is_positive y 
				  then optimise_logical (fn (x,y) => 
							 x andalso y)
				else raise CantRewrite
            | P.ORB          => if is_positive x andalso is_positive y
				  then optimise_logical (fn (x,y) => 
							 x orelse y)
				else raise CantRewrite
	    | _              => raise CantRewrite)
	in
	  folder (x,y)
	end) 
           handle 
           BigNum.Unrepresentable => raise CantRewrite
         | Prod => raise CantRewrite
         | Diff => raise CantRewrite
         | Neg => raise CantRewrite
         | BigNum.Runtime s => mkexn (findexn s)

      (* --- Algebraic Identities & List Arg Folds --- *)
	   
      else 
       (let
	  val folder =
	    (case p of
	       P.INTPLUS   => plus_ident
	     | P.INTMINUS  => minus_ident
	     | P.INTSTAR   => times_ident
	     | P.DIV       => div_ident
	     | P.MOD       => mod_ident
	     | P.AT        => append_ident_fold
	     | P.HAT       => concat_ident
	     | P.IMPLODE   => K (fold_implode (LT.STRUCT ([x,y],LT.TUPLE)))
	     | P.REV       => K (fold_rev (LT.STRUCT ([x,y],LT.TUPLE)))
	     | _           => raise CantRewrite)
	in
	  folder (x,y)
	end handle Div => mkexn P.EXDIV
                 | Mod => mkexn P.EXMOD)

      | fold_binary _ = raise CantRewrite


    (* Folding/Simplifying unary functions  *)
    (* raises exception CantRewrite if none *)
    (* of the rewrites are applicable.      *)
	
   fun fold_unary (LT.BUILTIN p, x) =

     if (is_const x)
       then
	 ((case p of
	     P.INTABS     => big_wobble1 BigNum.abs
	   | P.INTUMINUS  => big_wobble1 BigNum.~
	   | P.ORD        => fold_ord
	   | P.CHR        => fold_chr
	   | P.REV        => fold_rev     (* for nil case *)
	   | P.IMPLODE    => fold_implode (* ditto        *)
	   | P.EXPLODE    => fold_explode
	   | P.SIZE       => fold_size
	   | _            => raise CantRewrite) x)
	     handle BigNum.Runtime s => mkexn (findexn s)
		  | Ord => mkexn P.EXORD
		  | Chr => mkexn P.EXCHR
     else raise CantRewrite
     
     | fold_unary _ = raise CantRewrite

    fun reduce_fold (func, arglist) =
      let
	fun redf (a1::a2::args, done) =
	  (let
	     val reduct = fold_binary (func, (a1,a2))
	   in
	     redf (reduct::args, done)
	   end handle CantRewrite => redf(a2::args, a1::done))
	  | redf ([last_arg], done) = rev(last_arg :: done)
	  | redf ([], done) = rev done
      in
	redf (arglist, [])
      end
    


in
  (* constant folding without rearrangement *)
    
  fun fold_constants generate_recipes inlinesub (optinfo,expression) =
    let
      fun fold_map_fn ty = fold_map generate_recipes ty (optinfo,inlinesub)

      fun foldc (mapapp as LT.APP(LT.APP(LT.BUILTIN P.MAP,[map_fn],ty1),
				  [map_list],ty2)) =
	(fold_map_fn (extract_list_element_type 
                      (case ty2 of
                         LT.Option.ABSENT => LT.null_type_annotation
                       | LT.Option.PRESENT(ty2) => !ty2,LT.null_type_annotation)) (map_fn,map_list)
	 handle CantRewrite => mapapp)

	| foldc (binapp as LT.APP(func, [LT.STRUCT([x,y],_)],ty)) =
	  let
(*
	    val _ = Print.print"fold_binary in foldc\n"
*)
	  in
	  (fold_binary(func,(x,y))
	   handle CantRewrite => binapp)
	  end

	| foldc (unapp as LT.APP(func, [arg], ty)) =
	  (fold_unary(func, arg)
	   handle CantRewrite => unapp)

        | foldc (LT.APP (func,arglist,ty)) =
          Crash.impossible "Arglist in fold_constants"
	| foldc expr = expr
    in
      LS.apply_innermost foldc expression
    end;


(* Rearrangement of arithmetic and other expressions in the hope of making  *)
(* as many optimisations as possible applicable.  The normal form uses the  *)
(* ordering on constructors given in LambdaSub.  We try and make the first  *)
(* arg of commutative funcs shiftables (with a mind to beta-redexes on      *)
(* unshiftable args), and make all associative applications group to the    *)
(* left.  Some additional work: transforms nested applications of ^ implode *)
(* Constant folding is performed at the same time, avoiding the need for a  *)
(* separate pass.				 			    *)


local
    (* fold constants in a list of arguments to an associative binary *)
    (* function.  Folding is attempted on each adjacent pair of elts. *)

    (* arbitrarily nested applications of ^ are accumulated to an implode *)

    fun htransform1 (hatsnum, LT.STRUCT([LT.APP(LT.BUILTIN P.HAT,[arg],_),arg'],_)) =
	    htransform(htransform1(hatsnum,arg), arg')
      | htransform1 (hatsnum, LT.STRUCT([arg,LT.APP(LT.BUILTIN P.HAT,[arg'],_)],_)) =
	    htransform1(htransform(hatsnum,arg), arg')
      | htransform1 ((hats,num), LT.STRUCT([string1, string2],_)) = 
	    (string2::string1::hats, num+2)
      | htransform1 ((hats,num), string) = (string::hats, num+1)
    and htransform (hatsnum, LT.APP(LT.BUILTIN P.HAT,[arg],_)) = 
            htransform1(hatsnum,arg)
      | htransform ((hats, num), string) = (string::hats, num+1)


    fun quick_equality (LT.VAR x,LT.VAR y) = op=(x,y)
      | quick_equality (LT.BUILTIN p,LT.BUILTIN q) = p=q
      | quick_equality _ = false


    fun make_best_application_association (func, ty, a::args) =
      let
	fun app_func (x,y) = LT.APP(func, [LT.STRUCT ([x,y],LT.TUPLE)], ty)
      in
	Lists.reducel app_func (a,args)   (* best is left associative *)
      end
      | make_best_application_association _ = 
	Crash.impossible "make_best_application_association: two few args"
in


  fun rearrange_arithmetic generate_recipes
    (optinfo as 
     LT.Info{is_shiftable,
             is_commutative, 
             is_associative,
             bindings,...}, expression) = 
  let
(*
    val _ = Print.print"rearrange_arithmetic trying to rearrange:\n"
    val _ = LambdaPrint.print_lambda expression
*)
    fun fold_map_fn ty x = 
      fold_map generate_recipes ty (optinfo,fn (i,le)=>
		(rearrange
		 (OptimiseBeta.heuristic_beta_reduce generate_recipes (i,le)))) x

    and hats_to_implode (arg,original) =
      let
	val (hats,num) = htransform1 (([],0),arg)  (* sub exprs ignored *)
      in
	if num>(!min_concats_to_implode)
	  then (* build implode of list *)
	    let
	      val implode_list = make_primitive_list (rev hats)
	    in
	      LT.APP(LT.BUILTIN P.IMPLODE, [implode_list],
		     LT.Option.PRESENT(ref(Debugger_Types.string_list_type)))
	    end
	else LS.apply_one_level rearrange original
      end

(*
   (* This function is hopeless MLA *)
    and recommute_order (x,y) =
    if LT.expr_order(y,x)
      then if not(LT.expr_order(x,y))
	     then (* reverse if either arg is shiftable *)
	       if (is_shiftable y) orelse (is_shiftable x)
		 then false
	       else true
	  else (* if order same, want shiftables first *)
	    (case (is_shiftable x,is_shiftable y) of
	       (false,true) => false
	     | (true,true) => 
		 (case y of
		    (LT.VAR v) => (* in case of beta-reduction *)
		                 ((if not(is_shiftable 
					 (LT.NewHashTable.lookup(bindings,v)))
				    then false
				  else true) 
				    handle LT.NewHashTable.Lookup => 
				  (* go by lvar order so that closer bound *)
				  (* variables appear earlier *)
				      (case x of
					 LT.VAR v'=> LT.LVar_order(v',v)
				       | _ => true))
		  | _ => true)
	     | _ => true)
    else true
*)

(*
    and reassociate_and_commute (func, arg, ty) =
      let
(*
	val _ = Print.print"reassociate_and_commute: func =\n"
	val _ = LambdaPrint.print_lambda func
	val _ = Print.print"\narg =\n"
	val _ = LambdaPrint.print_lambda arg
*)
	fun transform1 (accargs, LT.STRUCT([app as LT.APP(func',[arg],_),arg'],_)) =
	    if quick_equality(func,func')
	      then transform(transform1(accargs,arg), arg')
	    else (arg' :: (rearrange app) :: accargs)

	  | transform1 (accargs, LT.STRUCT([arg, app as LT.APP(func',[arg'],_)],_)) =
	    if quick_equality(func,func')
	      then transform1(transform(accargs, arg), arg')
	    else ((rearrange app) :: arg :: accargs)

	  | transform1 (accargs, LT.STRUCT([arg1, arg2],_)) = 
	    let
(*
		 val _ = Print.print"fold_binary in transform1\n"
*)
	    in
	     ((fold_binary(func, (arg1,arg2)) :: accargs)
	      handle CantRewrite => (arg2::arg1::accargs))
	     end

	  | transform1 (accargs, arg) = arg::accargs

	and transform (accargs, app as LT.APP(func',[arg],_)) = 
	    if quick_equality(func,func')
	      then transform1(accargs,arg)
	    else (rearrange app) :: accargs

	  | transform (accargs, arg) = arg::accargs
	
	val list_of_args = rev(transform1 ([],arg))

(*
	val _ = Print.print"arg list =\n"
	val _ = Lists.iterate LambdaPrint.print_lambda list_of_args
*)
	val folded_list_of_args = reduce_fold (func,list_of_args)
      in
	case folded_list_of_args of
	  [expr] => expr
	| _::_ => let
		    val reordered_args =
(* recommute order is meaningless as far as I can see *)
(*
                      if is_commutative func
                        then 
                          Lists.qsort recommute_order list_of_args
                      else
*)
                        list_of_args
		  in
		    make_best_application_association (func,ty,reordered_args)
		  end
	| [] => Crash.impossible "reassociate_and_commute: empty arg list"
      end
*)

    and rearrange (LT.APP(LT.APP(LT.BUILTIN P.MAP,[map_fn],ty1),[map_list],ty2)) =
      let
	val map_fn' = rearrange map_fn
	val map_list' = rearrange map_list
      in
	((fold_map_fn 
          (extract_list_element_type (case ty2 of
                         LT.Option.ABSENT => LT.null_type_annotation
                       | LT.Option.PRESENT(ty2) => !ty2,LT.null_type_annotation))
          (map_fn', map_list'))
	  handle CantRewrite =>
	    LT.APP(LT.APP(LT.BUILTIN P.MAP,[map_fn'],ty1),[map_list'],ty2))
      end

      | rearrange (binapp as LT.APP(func,[arg as LT.STRUCT([x,y],_)],ty)) =
	let
(*
	  val _ = Print.print"rearrange trying to rearrange:\n"
	  val _ = LambdaPrint.print_lambda binapp
*)
	in
	(case func of
	   LT.BUILTIN P.HAT => hats_to_implode (arg, binapp)
         | LT.BUILTIN P.O =>
             let
               fun get_details(LT.VAR v) =
                 (case LT.NewHashTable.tryLookup(bindings,v) of
                    LT.NewHashTable.YES(LT.FN(_,_,annotation,_,_)) => annotation 
                  | _ => "")
                 | get_details _ = ""
               val first = get_details x
               val second = get_details y
               val ocode =
                 let
                   val l2 = LT.new_LVar()
                 in
                   LT.FN
                   ([l2],
                    LT.APP
                    (x,
                     [LT.APP
                      (y,
                       [LT.VAR l2],
                       LT.Option.ABSENT)],
                     LT.Option.ABSENT),
                    if first <> "" andalso second <> ""
                      then
                        "Builtin o of " ^ first ^ " and " ^ second
                    else 
                      "Builtin o",
                      LT.null_type_annotation,
                      LT.Option.ABSENT)
                 end
             in
               ocode
             end
	 | _ => 
(* Associativity can change the semantics of eg. addition *)
(* It's OK for eg ^ and @@, but, one thinks, what is the point? *)
(*
	     if is_associative(func)
	       then reassociate_and_commute (func,arg,ty)
	     else 
*)
	       let
		 val x' = rearrange x
		 and y' = rearrange y
(*
		 val _ = Print.print"fold_binary in rearrange\n"
*)
	       in
		 (fold_binary (func, (x,y)))
		 handle CantRewrite =>
(* recommute order is meaningless as far as I can see *)
(*
                   if is_commutative(func) andalso recommute_order(x',y')
		     then 
                       LT.APP(func, [LT.STRUCT([y',x'],LT.TUPLE)],ty)
		   else
*)
                     LT.APP(func, [LT.STRUCT([x',y'],LT.TUPLE)],ty)
	       end)
	end

      | rearrange (LT.APP(func, [arg], ty)) = 
	let
	  val func' = rearrange func
	  val arg' = rearrange arg
	in
	  fold_unary(func,arg)
	    handle CantRewrite => LT.APP(func',[arg'],ty)
	end
      | rearrange (LT.APP(func, argl, ty)) = 
        Crash.impossible "Arglist in rearrange"

      | rearrange expr = LS.apply_one_level rearrange expr
	       
  in
    rearrange expression
  end

end (* of local *)

end (* of local *)


(* minor note on rearrangement of commutative func's: *)

(* NB: this strategy doesn't guarantee complete coverage in beta-red;   *)
(* when the expression order requires that a shiftable expression goes  *)
(* after an unshiftable, or when both args are unshiftable and we hit   *)
(* a redex on the wrong one, there'll be a redex that won't be reduced  *)
(* that we could do better with.  The old version of beta reduction     *)
(* (_optimise_beta, before 1.21) would fiddle the commutative order on  *)
(* expressions, but this is much effort for infrequent reward.          *)

local
   open P
in
   (*  These primitives are exported so that other parts of the  *)
   (*  optimiser can predict which functions can be reduced at   *)
   (*  compile-time.						 *)

   val folded_primitives_onearg = [INTPLUS, INTMINUS, INTSTAR, DIV, MOD,
				   INTLESS, INTGREATER, INTEQ, INTNE, AT, HAT,
				   REV, INTABS, INTUMINUS, CHR, ORD, IMPLODE,
				   EXPLODE, SIZE,
				   EQ, STRINGEQ, REALEQ,
				   NE, STRINGNE, REALNE,
				   RSHIFT,LSHIFT,ANDB,ORB]

   val folded_primitives_twoarg = [MAP]
end



end (* of functor *)


(* $Log: _optimise_builtin.sml,v $
Revision 1.43  1994/09/19  14:22:23  matthew
Abstraction of debug information in lambdatypes

Revision 1.42  1994/09/12  11:16:06  jont
Add small evaluator to ensure that constant expressions reduce correctly

Revision 1.41  1994/07/19  14:23:54  matthew
Functions and applications take a list of parameters

Revision 1.40  1994/06/15  10:42:46  jont
Modified decon_int to raise CantRewrite when applied to something
which isn't directly an int. This allows the more general definition
of is_const to work better

Revision 1.39  1994/06/10  17:23:52  jont
Improve compile time elimination of equality and inequality
to deal with all STRUCTs and SELECTs, as well as INTs and SCONs

Revision 1.38  1994/06/10  16:29:14  jont
Fix bad equality of lambda expressions

Revision 1.37  1994/02/01  15:04:13  matthew
 Commented out some nasty stuff doing rearrangement of expressions with
associativity and commutativity.  The commutative stuff was wrong, with arguments\ngetting evaluated in the wrong order.  The associative stuff produces odd results\neg. for reals.  A more intelligent approach may be possible sometime.

Revision 1.36  1993/11/25  15:48:34  nosa
Pass recipe-generation compiler option to optimiser.

Revision 1.35  1993/11/25  13:54:59  matthew
Commented out the incorrect identities for built in functions, which assumed
expressions don't have side effects.  Some less optimistic optimizations are
possible here (eg. replace (e div 0) by (e;raise Div)).

Revision 1.34  1993/08/16  11:31:25  nosa
Instances for METATYVARs and passed closed-over type variables and
stack frame-offset for runtime-instance for FNs for polymorphic debugger.

Revision 1.33  1993/07/12  10:10:53  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

Revision 1.32  1993/07/05  13:14:03  daveb
Removed exception environments.

Revision 1.31  1993/03/10  16:28:27  matthew
Signature revisions

Revision 1.30  1993/03/03  17:47:30  jont
Removed LVar_eq in favour of polymorphic equality

Revision 1.29  1993/01/14  14:30:01  daveb
Changed explicit manipulations of list representations to use new format.

Revision 1.28  1992/12/17  17:14:33  matthew
Changed int and real scons to carry a location around

Revision 1.27  1992/12/15  11:57:34  clive
Hanlded exceptions in the constant folding code

Revision 1.26  1992/11/26  19:33:05  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.25  1992/09/30  13:54:20  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.24  1992/09/21  12:08:03  clive
Changed hashtables to a single structure implementation

Revision 1.23  1992/08/26  13:10:44  jont
Removed some redundant structures and sharing

Revision 1.22  1992/08/05  17:51:55  jont
Removed some structures and sharing

Revision 1.21  1992/07/29  10:19:20  clive
Changed the bindingtable to be a hashtable

Revision 1.20  1992/07/24  16:31:50  jont
Hopefully fixed a bug in folding of append and the like

Revision 1.19  1992/07/23  14:56:23  jont
Fixed bug in fold_implode which was leaving out most of the list

Revision 1.18  1992/07/23  13:00:56  jont
Removed faulty implementation of fold_implode. Optimisation removed entirely
pending a reasonable implementation

Revision 1.17  1992/07/17  14:25:36  clive
Needed to preserve type information

Revision 1.16  1992/07/10  14:35:19  davida
Bug fix and extensions to implode folding,
rearrange arithmetic does folding on the fly.

Revision 1.14  1992/07/02  10:02:07  davida
Added LET constructor and new slot to APP.

Revision 1.13  1992/07/02  10:00:04  davida
Added missing handle in rearrange.

Revision 1.12  1992/06/30  10:26:08  davida
Fixed instances of map folding broken by previous bug-fix.
Made implode folding more general - it now coalesces
adjacent constant strings.  Added primitives into
folded_primitives lists.  Begun work on rearrangement:
commutative functions are now re-ordered.  Added variable
controlling number of ^'s replaced by implode (but function
not written yet).

Revision 1.11  1992/06/16  14:37:26  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.10  1992/06/11  08:46:43  clive
Added type annotations to FNexp

Revision 1.9  1992/05/20  10:36:04  clive
Div goes to arithmetic shift

Revision 1.8  1992/05/15  10:44:53  clive
Optimisations to div and mod (via andb and rshift), and logicals

Revision 1.7  1992/04/16  11:09:25  clive
Added debug information

Revision 1.6  1992/04/13  16:42:36  clive
First version of the profiler

Revision 1.5  1992/04/08  16:55:24  jont
Fixed problems with fold_implode whereby some lists were erroneously
thought to be constant.

Revision 1.4  1992/03/27  12:17:30  jont
Added requires for Lists, Print, Integer

Revision 1.3  1991/10/22  14:05:01  davidt
Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception).

Revision 1.2  91/09/11  12:32:13  davida
All optimisations now produce messages; map folding has
been improved for a wider class of args.

Revision 1.1  91/09/09  11:46:29  davida
Initial revision
 *)
@


1.43
log
@Abstraction of debug information in lambdatypes
@
text
@d101 1
a101 1
   | make_primitive_list (x::xs) = LT.STRUCT[x,make_primitive_list xs]
d104 1
a104 1
 fun extract_primitive_list (LT.STRUCT[element,tail]) =
d110 1
a110 1
 fun extract_primitive_list'(acc, LT.STRUCT[element,tail]) =
d150 1
a150 1
	       then LT.LET(map_fn_var,LT.Option.ABSENT,map_fn,mapped_list)
d202 1
a202 1
	      | [r1,r2] => LT.APP(LT.BUILTIN P.HAT, [LT.STRUCT[r1,r2]],
d220 1
a220 1
		| (LT.APP(LT.BUILTIN P.HAT,[LT.STRUCT[x,y]],_)) => 
d336 1
a336 1
		    [LT.STRUCT[x,LT.SCON(Ident.INT 
d338 1
a338 1
                                          unknownLocation))]],
d372 1
a372 1
                    [LT.STRUCT[x,
d374 1
a374 1
                               unknownLocation))]],
d399 1
a399 1
                  [LT.STRUCT[x,
d402 1
a402 1
                                      unknownLocation))]],
d413 2
a414 2
	fun replace_end (LT.STRUCT[element,tail]) = 
			  LT.STRUCT[element,replace_end tail]
d489 1
a489 1
      | is_const (LT.STRUCT list) = Lists.forall is_const list
d495 1
a495 1
    fun mkexn ex = LT.RAISE (LT.STRUCT [LT.BUILTIN ex,LT.STRUCT[]]);
d512 2
a513 2
      | eval_const(LT.STRUCT list) = LT.STRUCT(map eval_const list)
      | eval_const(LT.SELECT({index, ...}, LT.STRUCT le_list)) =
d654 2
a655 2
	     | P.IMPLODE   => K (fold_implode (LT.STRUCT [x,y]))
	     | P.REV       => K (fold_rev (LT.STRUCT [x,y]))
d721 1
a721 1
	| foldc (binapp as LT.APP(func, [LT.STRUCT[x,y]],ty)) =
d759 1
a759 1
    fun htransform1 (hatsnum, LT.STRUCT[LT.APP(LT.BUILTIN P.HAT,[arg],_),arg']) =
d761 1
a761 1
      | htransform1 (hatsnum, LT.STRUCT[arg,LT.APP(LT.BUILTIN P.HAT,[arg'],_)]) =
d763 1
a763 1
      | htransform1 ((hats,num), LT.STRUCT[string1, string2]) = 
d778 1
a778 1
	fun app_func (x,y) = LT.APP(func, [LT.STRUCT [x,y]], ty)
d857 1
a857 1
	fun transform1 (accargs, LT.STRUCT[app as LT.APP(func',[arg],_),arg']) =
d862 1
a862 1
	  | transform1 (accargs, LT.STRUCT[arg, app as LT.APP(func',[arg'],_)]) =
d867 1
a867 1
	  | transform1 (accargs, LT.STRUCT[arg1, arg2]) = 
d927 1
a927 1
      | rearrange (binapp as LT.APP(func,[arg as LT.STRUCT[x,y]],ty)) =
d990 1
a990 1
                       LT.APP(func, [LT.STRUCT[y',x']],ty)
d993 1
a993 1
                     LT.APP(func, [LT.STRUCT[x',y']],ty)
d1053 3
@


1.42
log
@Add small evaluator to ensure that constant expressions reduce correctly
@
text
@d150 1
a150 1
	       then LT.LET(LT.Option.SOME1(map_fn_var),map_fn,mapped_list)
d1053 3
@


1.41
log
@Functions and applications take a list of parameters
@
text
@d502 15
d521 7
a527 5
    fun wob_fold_eq (x,y) = (info "folded =";  
			     recon_bool (LS.lambda_equality(x,y)))

    and wob_fold_ne (x,y) = (info "folded <>"; 
			     recon_bool (not(LS.lambda_equality(x,y))))
d1053 3
@


1.40
log
@Modified decon_int to raise CantRewrite when applied to something
which isn't directly an int. This allows the more general definition
of is_const to work better
@
text
@d137 1
a137 1
	    fun app_map_fn x = LT.APP(LT.VAR map_fn_var, x,
d202 1
a202 1
	      | [r1,r2] => LT.APP(LT.BUILTIN P.HAT, (LT.STRUCT[r1,r2]),
d205 1
a205 1
				   make_primitive_list new_list,
d210 1
a210 1
		| (le as LT.APP(LT.BUILTIN P.IMPLODE, another_list, _)) =>
d220 1
a220 1
		| (LT.APP(LT.BUILTIN P.HAT, LT.STRUCT[x,y],_)) => 
d280 1
a280 1
      (info s; LT.APP(LT.BUILTIN P.INTUMINUS,y,
d336 3
a338 3
		    LT.STRUCT[x,LT.SCON(Ident.INT 
				       (Integer.makestring(log2 true_value),
                                        unknownLocation))],
d372 3
a374 4
		    LT.STRUCT[x,
			      LT.SCON(Ident.INT 
				      (Integer.makestring(true_value-1),
                                       unknownLocation))],
d399 4
a402 4
                  LT.STRUCT[x,
                            LT.SCON(Ident.INT 
                                    (Integer.makestring(true_value-1),
                                     unknownLocation))],
d696 2
a697 2
      fun foldc (mapapp as LT.APP(LT.APP(LT.BUILTIN P.MAP,map_fn,ty1),
				  map_list,ty2)) =
d704 1
a704 1
	| foldc (binapp as LT.APP(func, LT.STRUCT[x,y],ty)) =
d714 1
a714 1
	| foldc (unapp as LT.APP(func, arg, ty)) =
d718 2
d742 1
a742 1
    fun htransform1 (hatsnum, LT.STRUCT[LT.APP(LT.BUILTIN P.HAT,arg,_),arg']) =
d744 1
a744 1
      | htransform1 (hatsnum, LT.STRUCT[arg,LT.APP(LT.BUILTIN P.HAT,arg',_)]) =
d749 1
a749 1
    and htransform (hatsnum, LT.APP(LT.BUILTIN P.HAT,arg,_)) = 
d761 1
a761 1
	fun app_func (x,y) = LT.APP(func, LT.STRUCT [x,y], ty)
d795 1
a795 1
	      LT.APP(LT.BUILTIN P.IMPLODE, implode_list,
d840 1
a840 1
	fun transform1 (accargs, LT.STRUCT[app as LT.APP(func',arg,_),arg']) =
d845 1
a845 1
	  | transform1 (accargs, LT.STRUCT[arg, app as LT.APP(func',arg',_)]) =
d862 1
a862 1
	and transform (accargs, app as LT.APP(func',arg,_)) = 
d896 1
a896 1
    and rearrange (LT.APP(LT.APP(LT.BUILTIN P.MAP,map_fn,ty1),map_list,ty2)) =
d907 1
a907 1
	    LT.APP(LT.APP(LT.BUILTIN P.MAP,map_fn',ty1),map_list',ty2))
d910 1
a910 1
      | rearrange (binapp as LT.APP(func,arg as LT.STRUCT[x,y],ty)) =
d933 1
a933 1
                   (l2,
d936 4
a939 4
                     LT.APP
                     (y,
                      LT.VAR l2,
                      LT.Option.ABSENT),
d946 2
a947 2
                    LT.null_type_annotation,
                    LT.Option.ABSENT)
d973 1
a973 1
                       LT.APP(func, LT.STRUCT[y',x'],ty)
d976 1
a976 1
                     LT.APP(func, LT.STRUCT[x',y'],ty)
d980 1
a980 1
      | rearrange (LT.APP(func, arg, ty)) = 
d986 1
a986 1
	    handle CantRewrite => LT.APP(func',arg',ty)
d988 2
d1036 5
@


1.39
log
@Improve compile time elimination of equality and inequality
to deal with all STRUCTs and SELECTs, as well as INTs and SCONs
@
text
@d499 1
a499 1
      | decon_int _ = Crash.impossible "descon_int: bad arg"
d577 2
a578 4

      if (is_const x) andalso (is_const y)
      then
	(let 
d1033 4
@


1.38
log
@Fix bad equality of lambda expressions
@
text
@d478 1
d486 1
d488 1
a488 1
    and is_const (LT.SCON _) = true
d490 3
a492 1
      | is_const l = is_manifest_list l
d1035 3
@


1.37
log
@ Commented out some nasty stuff doing rearrangement of expressions with
associativity and commutativity.  The commutative stuff was wrong, with arguments\ngetting evaluated in the wrong order.  The associative stuff produces odd results\neg. for reals.  A more intelligent approach may be possible sometime.
@
text
@d479 6
a484 1
      (extract_primitive_list l; true) handle CantFindList => false;
d486 1
a486 1
    fun is_const (LT.SCON _) = true
d1031 4
@


1.36
log
@Pass recipe-generation compiler option to optimiser.
@
text
@d793 2
d821 1
d823 1
d872 9
a880 4
		    val reordered_args = if is_commutative func
					   then Lists.qsort 
					          recommute_order list_of_args
					 else list_of_args
d886 1
d945 3
d951 1
d961 8
a968 3
		   if is_commutative(func) andalso recommute_order(x',y')
		     then LT.APP(func, LT.STRUCT[y',x'],ty)
		   else LT.APP(func, LT.STRUCT[x',y'],ty)
d1026 3
@


1.35
log
@Commented out the incorrect identities for built in functions, which assumed
expressions don't have side effects.  Some less optimistic optimizations are
possible here (eg. replace (e div 0) by (e;raise Div)).
@
text
@d121 1
a121 1
 fun fold_map element_type (oinfo, inlinesub) (map_fn, map_list) =
d145 1
a145 1
		  OptimiseBeta.function_inline inlinesub (oinfo,mapped_list)
d686 1
a686 1
  fun fold_constants inlinesub (optinfo,expression) =
d688 1
a688 1
      fun fold_map_fn ty = fold_map ty (optinfo,inlinesub)
d762 6
a767 5
  fun rearrange_arithmetic (optinfo as 
			    LT.Info{is_shiftable,
				    is_commutative, 
				    is_associative,
				    bindings,...}, expression) = 
d774 1
a774 1
      fold_map ty (optinfo,fn (i,le)=>
d776 1
a776 1
		 (OptimiseBeta.heuristic_beta_reduce (i,le)))) x
d1007 5
@


1.34
log
@Instances for METATYVARs and passed closed-over type variables and
stack frame-offset for runtime-instance for FNs for polymorphic debugger.
@
text
@d282 1
d286 2
d293 4
a296 1
  fun times_ident (zero as LT.SCON(Ident.INT("0",_)), y) = (info s; zero)
d298 1
a298 2
    | times_ident (x, LT.SCON(Ident.INT("1",_)))         = (info s; x)
    | times_ident (LT.SCON(Ident.INT("1",_)), y)         = (info s; y)
d316 1
d320 1
d347 1
d351 2
a352 1
  fun mod_ident (x, LT.SCON(Ident.INT("1",l))) = (info s; LT.SCON(Ident.INT("0",l)))
d381 1
d383 26
a411 6
(*
       val _ = Print.print"append_ident_fold, trying to fold:\nList 1 =\n"
       val _ = LambdaPrint.print_lambda list1
       val _ = Print.print"\nList 2 =\n"
       val _ = LambdaPrint.print_lambda list2
*)
a630 8
	     | P.EQ        => eq_ident
	     | P.INTEQ     => eq_ident
	     | P.REALEQ    => eq_ident
	     | P.STRINGEQ  => eq_ident
	     | P.NE        => ne_ident
	     | P.INTNE     => ne_ident
	     | P.REALNE    => ne_ident
	     | P.STRINGNE  => ne_ident
a670 3
(*
		 val _ = Print.print"fold_binary in reduce_fold\n"
*)
d1006 4
@


1.33
log
@Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.
@
text
@d437 1
a437 1
      (Datatypes.METATYVAR(ref(_,ty),_,_),other) =
d885 1
a885 1
                    LT.NewHashTable.YES(LT.FN(_,_,annotation,_)) => annotation 
d908 2
a909 1
                    LT.null_type_annotation)
d987 4
@


1.33.1.1
log
@Fork for bug fixing
@
text
@a985 4
Revision 1.33  1993/07/12  10:10:53  nosa
Types of constructors LET and LETREC have changed for
local and closure variable inspection in the debugger.

@


1.32
log
@Removed exception environments.
@
text
@d138 1
a138 1
				      element_type)
d150 1
a150 1
	       then LT.LET(map_fn_var,map_fn,mapped_list)
d203 1
a203 1
				  Debugger_Types.string_pair_type)
d206 1
a206 1
                                   Debugger_Types.string_list_type))
d280 2
a281 1
      (info s; LT.APP(LT.BUILTIN P.INTUMINUS,y,Debugger_Types.int_type))
d332 1
a332 1
		    Debugger_Types.int_pair_type))
d367 1
a367 1
		    Debugger_Types.int_pair_type))
d673 4
a676 1
	(fold_map_fn (extract_list_element_type (ty2,LT.null_type_annotation)) (map_fn,map_list)
d768 1
a768 1
		     Debugger_Types.string_list_type)
d864 3
a866 1
          (extract_list_element_type (ty2,LT.null_type_annotation))
d901 2
a902 2
                      LT.null_type_annotation),
                     LT.null_type_annotation),
d986 3
@


1.31
log
@Signature revisions
@
text
@d428 3
a430 2
      case (Environ.lookup_exn(Ident.EXCON(Symbol.find_symbol s),
			       Primitives.initial_env)) of
d980 3
@


1.30
log
@Removed LVar_eq in favour of polymorphic equality
@
text
@a42 3
  sharing LambdaPrint.LambdaTypes.Datatypes =
	  Debugger_Types.Datatypes =
	  Types.Datatypes
d44 4
d70 1
a70 1
  structure Ident = LT.Datatypes.Ident
d74 1
d434 2
a435 3
    fun extract_list_element_type(
          Debugger_Types.Datatypes.METATYVAR(ref(_,ty),_,_),other
	) =
d437 2
a438 3
      | extract_list_element_type(
	  Debugger_Types.Datatypes.CONSTYPE([el],ty'),default
	) =
d444 1
a444 1
           Types.Datatypes.NULLTYPE)
d979 3
@


1.29
log
@Changed explicit manipulations of list representations to use new format.
@
text
@d722 1
a722 1
    fun quick_equality (LT.VAR x,LT.VAR y) = LT.LVar_eq(x,y)
d979 3
@


1.28
log
@Changed int and real scons to carry a location around
@
text
@d47 1
a47 2
  val primitive_list_cons : LambdaSub.LT.LambdaExp
  and primitive_list_nil  : LambdaSub.LT.LambdaExp
d99 1
a99 2
   | make_primitive_list (x::xs) = LT.STRUCT[primitive_list_cons,
					   LT.STRUCT[x,make_primitive_list xs]]
d102 2
a103 4
 fun extract_primitive_list (LT.STRUCT[tag,LT.STRUCT[element,tail]]) =
    				if LS.lambda_equality(tag,primitive_list_cons)
				   then element::(extract_primitive_list tail)
				else raise CantFindList
d108 1
a108 2
 fun extract_primitive_list'(acc, LT.STRUCT[tag,LT.STRUCT[element,tail]]) =
   if LS.lambda_equality(tag,primitive_list_cons) then
a109 1
   else raise CantFindList
d381 2
a382 8
	fun replace_end (LT.STRUCT[tag,value]) =
	   if LS.lambda_equality(tag,primitive_list_cons)
	      then (case value of
		       (LT.STRUCT[element,tail]) => 
			  LT.STRUCT[tag,LT.STRUCT[element,replace_end tail]]
		     | _ => raise CantFindNil)
	   else raise CantFindNil

a386 1

d979 3
@


1.27
log
@Hanlded exceptions in the constant folding code
@
text
@d71 1
d75 2
d237 1
a237 1
      LT.SCON(Ident.INT(Integer.makestring(ord_fold_function s))))
d241 1
a241 1
  fun fold_chr (LT.SCON (Ident.INT i)) =
d261 2
a262 1
	     (Integer.makestring (size s))))
d273 2
a274 2
  fun plus_ident (LT.SCON(Ident.INT "0"), y) = (info s; y)
    | plus_ident (x, LT.SCON(Ident.INT "0")) = (info s; x)
d282 2
a283 2
  fun minus_ident (x, LT.SCON(Ident.INT "0")) = (info s; x)
    | minus_ident (LT.SCON(Ident.INT "0"), y) = 
d286 1
a286 1
			    then (info s; LT.SCON(Ident.INT "0"))
d293 4
a296 4
  fun times_ident (zero as LT.SCON(Ident.INT "0"), y) = (info s; zero)
    | times_ident (x, zero as LT.SCON(Ident.INT "0")) = (info s; zero)
    | times_ident (x, LT.SCON(Ident.INT "1"))         = (info s; x)
    | times_ident (LT.SCON(Ident.INT "1"), y)         = (info s; y)
d310 3
a312 3
  fun div_ident (x, LT.SCON(Ident.INT "1")) = (info s; x)
    | div_ident (x, LT.SCON(Ident.INT "0")) = (info s; raise Div)
    | div_ident (LT.SCON(Ident.INT "0"), _) = (info s; LT.SCON(Ident.INT "0"))
d315 1
a315 1
	then (info s; LT.SCON(Ident.INT "1"))
d322 1
a322 1
            LT.SCON(Ident.INT value) => 
d333 2
a334 1
				       (Integer.makestring(log2 true_value)))],
d346 3
a348 3
  fun mod_ident (x, LT.SCON(Ident.INT "1")) = (info s; LT.SCON(Ident.INT "0"))
    | mod_ident (LT.SCON(Ident.INT "0"), y) = (info s; LT.SCON(Ident.INT "0"))
    | mod_ident (x, LT.SCON(Ident.INT "0")) = (info s; raise Mod)
d351 1
a351 1
	then (info s; LT.SCON(Ident.INT "0"))
d356 1
a356 1
            LT.SCON(Ident.INT value) => 
d368 2
a369 1
				      (Integer.makestring(true_value-1)))],
d470 1
a470 1
    fun decon_int (LT.SCON (Ident.INT s)) = BigNum.string_to_bignum s
d473 1
a473 1
    fun recon_int bn = LT.SCON (Ident.INT (BigNum.bignum_to_string bn))
d992 3
@


1.26
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d585 7
a591 1
	end) handle BigNum.Runtime s => mkexn (findexn s)
d986 4
@


1.25
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d17 1
d33 1
d43 3
a45 1
  sharing LambdaPrint.LambdaTypes.Datatypes = Debugger_Types.Datatypes
d439 14
d672 1
a672 1
	(fold_map_fn (Debugger_Types.extract_list_element_type (ty2,LT.null_type_annotation)) (map_fn,map_list)
d860 1
a860 1
          (Debugger_Types.extract_list_element_type (ty2,LT.null_type_annotation))
d980 3
@


1.24
log
@Changed hashtables to a single structure implementation
@
text
@d857 32
d962 3
@


1.23
log
@Removed some redundant structures and sharing
@
text
@a41 2
  sharing type LambdaSub.LT.BindingTable.Key = LambdaSub.LT.LVar
  sharing type LambdaSub.LT.BindingTable.Value = LambdaSub.LT.LambdaExp
d765 1
a765 1
					 (LT.BindingTable.lookup(bindings,v)))
d768 1
a768 1
				    handle LT.BindingTable.Lookup _ => 
d930 3
@


1.22
log
@Removed some structures and sharing
@
text
@d58 1
a58 1
            Primitives.LambdaTypes = LambdaPrint.LambdaTypes =
a65 1
  structure Ident = LambdaSub.LT.Ident
d68 1
d932 3
@


1.21
log
@Changed the bindingtable to be a hashtable
@
text
@a14 1
require "../basics/ident";
a37 1
  and Ident       : IDENT
d57 1
a57 1
    sharing LambdaSub.LT = Environ.LambdaTypes = 
d61 1
a61 1
    sharing Ident = Environ.Ident) : OPTIMISE_BUILTIN = 
d66 1
d932 3
@


1.20
log
@Hopefully fixed a bug in folding of append and the like
@
text
@d44 2
d768 1
a768 1
					 (LT.BindingTable.apply bindings v))
d771 1
a771 1
				    handle LT.BindingTable.Undefined => 
d933 3
@


1.19
log
@Fixed bug in fold_implode which was leaving out most of the list
@
text
@d370 6
d631 3
d659 5
d666 1
d728 4
d780 7
a786 1
      let 
d798 5
d805 1
d814 3
a816 1
      | transform (accargs, arg) = arg::accargs
d818 4
a821 2
	val list_of_args = transform1 ([],arg)

d850 6
d865 3
d875 1
d931 3
@


1.18
log
@Removed faulty implementation of fold_implode. Optimisation removed entirely
pending a reasonable implementation
@
text
@d106 8
a114 1

d171 1
a171 2
  fun fold_implode listexpr = raise CantRewrite
(*
d173 1
a173 1
       val thelist = extract_primitive_list listexpr
d175 2
a176 1
       fun coalesce_strings strings = 
d179 1
d182 1
a182 1
		 val coalesced = LT.SCON (Ident.STRING (implode (rev sofar)))
d188 10
a197 1
	     (case add_sofar(acc,sofar) of 
d200 1
a200 1
	      | [r2,r1] => LT.APP(LT.BUILTIN P.HAT, (LT.STRUCT[r1,r2]),
d203 1
a203 1
				   make_primitive_list (rev new_list),
d208 1
a208 1
		| (LT.APP(LT.BUILTIN P.IMPLODE, another_list, _)) =>
d210 3
a212 1
		       val nested_list = extract_primitive_list another_list
d215 3
a217 1
		     end handle CantFindList => s)
d219 1
a219 1
		    coalesce(acc, sofar, x::y::ss)
a224 1
       val result = coalesce_strings thelist
d226 1
a226 1
       result
a227 1
*)
d886 4
@


1.17
log
@Needed to preserve type information
@
text
@d164 2
a165 1
  fun fold_implode listexpr =
d208 1
a209 1

d867 3
@


1.16
log
@Bug fix and extensions to implode folding,
rearrange arithmetic does folding on the fly.
@
text
@d18 1
d42 3
d112 1
a112 1
 fun fold_map (oinfo, inlinesub) (map_fn, map_list) =
d129 1
a129 1
				      LT.null_type_annotation())
d183 1
a183 1
				  LT.null_type_annotation())
d186 1
a186 1
				   LT.null_type_annotation()))
d257 1
a257 1
      (info s; LT.APP(LT.BUILTIN P.INTUMINUS,y,LT.null_type_annotation()))
d307 1
a307 1
		    LT.null_type_annotation()))
d341 1
a341 1
		    LT.null_type_annotation()))
d622 1
a622 1
      val fold_map_fn = fold_map (optinfo,inlinesub)
d626 1
a626 1
	(fold_map_fn(map_fn,map_list)
d693 2
a694 2
    fun fold_map_fn x = 
      fold_map (optinfo,fn (i,le)=>
d708 1
a708 1
		     LT.null_type_annotation())
d787 3
a789 1
	((fold_map_fn (map_fn', map_list'))
d866 4
@


1.15
log
@Provisional full version of arithmetic
rearrangement.
@
text
@d19 1
d29 1
d32 3
d54 2
a55 1
            Primitives.LambdaTypes = LambdaPrint.LambdaTypes
d78 2
a79 5
   val min_concats_to_implode = ref 4; (*  conversion of ^'s to implode     *)
     
 fun make_primitive_list [] = primitive_list_nil
   | make_primitive_list (x::xs) = LT.STRUCT[primitive_list_cons,
					   LT.STRUCT[x,make_primitive_list xs]]
d81 1
d83 1
a83 2
local
 exception Div and Mod
d89 5
a93 1
 exception cant_find_list 
d97 1
a97 1
				else raise cant_find_list
d100 1
a100 1
				  else raise cant_find_list
d108 1
a108 1
 fun fold_map (original, map_fn, map_list) =
d128 6
a138 1
	  (* NB:- we may like to do some inlining at this point *)
d140 2
a141 2
      else original
    end) handle cant_find_list => original
d145 1
a145 1
  fun fold_rev original listexpr =
d151 1
a151 1
      end) handle cant_find_list => original
d154 1
a154 1
  fun fold_explode _ (LT.SCON (Ident.STRING string)) =
d157 1
a157 1
    | fold_explode original _ = original
d160 1
a160 1
  fun fold_implode original listexpr =
d178 1
a178 1
	      | [r1,r2] => LT.APP(LT.BUILTIN P.HAT, (LT.STRUCT[r1,r2]),
d186 8
d202 1
a202 1
     end) handle cant_find_list => original
d205 1
a205 1
  fun fold_ord _ (LT.SCON (Ident.STRING s)) =
d208 1
a208 1
    | fold_ord original _ = original
d211 1
a211 1
  fun fold_chr _ (LT.SCON (Ident.INT i)) =
d219 1
a219 1
   | fold_chr original _ = original
d222 4
a225 4
  fun fold_concat _ (LT.SCON(Ident.STRING s1),
		     LT.SCON(Ident.STRING s2)) = (info "folded ^";
						  LT.SCON(Ident.STRING(s1^s2)))
    | fold_concat original _ = original
d228 1
a228 1
  fun fold_size _ (LT.SCON(Ident.STRING s)) =
d232 1
a232 1
    | fold_size original _ = original
d242 3
a244 3
  fun plus_ident (_,  (LT.SCON(Ident.INT "0"), y)) = (info s; y)
    | plus_ident (_,  (x, LT.SCON(Ident.INT "0"))) = (info s; x)
    | plus_ident (sum, _) = sum
d251 2
a252 2
  fun minus_ident (_, (x, LT.SCON(Ident.INT "0"))) = (info s; x)
    | minus_ident (_, (LT.SCON(Ident.INT "0"), y)) = 
d254 3
a256 3
    | minus_ident (diff, (x,y)) = if LS.lambda_equality(x,y )
				     then (info s; LT.SCON(Ident.INT "0"))
				  else diff
d262 5
a266 5
  fun times_ident (_,    (zero as LT.SCON(Ident.INT "0"), y)) = (info s; zero)
    | times_ident (_,    (x, zero as LT.SCON(Ident.INT "0"))) = (info s; zero)
    | times_ident (_,    (x, LT.SCON(Ident.INT "1")))         = (info s; x)
    | times_ident (_,    (LT.SCON(Ident.INT "1"), y))         = (info s; y)
    | times_ident (prod, _)                                   = prod
d279 7
a285 5
  fun div_ident (_,    (x, LT.SCON(Ident.INT "1"))) = (info s; x)
    | div_ident (_,    (x, LT.SCON(Ident.INT "0"))) = (info s; raise Div)
    | div_ident (_,    (LT.SCON(Ident.INT "0"), _)) = (info s;
						       LT.SCON(Ident.INT "0"))
    | div_ident (same, (x,y)) = 
d291 2
a292 1
            LT.SCON(Ident.INT value) => (Integer.parseinteger value handle _ => 0)
d294 2
a295 1
        val optimise = (true_value > 0) andalso is_an_optimisable_power_of_two true_value
d305 1
a305 3
          if LS.lambda_equality(x,y)
            then (info s; LT.SCON(Ident.INT "1"))
          else same
d310 1
d314 7
a320 6
  fun mod_ident (_,    (x, LT.SCON(Ident.INT "1"))) = (info s;
						       LT.SCON(Ident.INT "0"))
    | mod_ident (_,    (LT.SCON(Ident.INT "0"), y)) = (info s;
						       LT.SCON(Ident.INT "0"))
    | mod_ident (_,    (x, LT.SCON(Ident.INT "0"))) = (info s; raise Mod)
    | mod_ident (same, (x,y)) = 
d324 2
a325 1
            LT.SCON(Ident.INT value) => (Integer.parseinteger value handle _ => 0)
d327 2
a328 1
        val optimise = (true_value > 0) andalso is_an_optimisable_power_of_two true_value
d332 1
a332 1
            (info "mod of positive power of two  changed to and";
d339 1
a339 3
          if LS.lambda_equality(x,y)
            then (info s; LT.SCON(Ident.INT "0"))
          else same
d344 1
a344 1
  fun append_ident_fold (original,(list1,list2)) =
d346 1
a346 1
	exception cant_find_nil
d353 2
a354 2
		     | _ => raise cant_find_nil)
	   else raise cant_find_nil
d359 1
a359 1
	    else raise cant_find_nil
d369 1
a369 1
	 end)  handle cant_find_nil => original
d376 3
a378 3
  fun concat_ident (_,  (x, LT.SCON(Ident.STRING ""))) = (info s; x)
    | concat_ident (_,  (LT.SCON(Ident.STRING ""), y)) = (info s; y)
    | concat_ident (cc, _) = cc
d382 4
a385 4
  fun eq_ident (test, (x,y)) = if LS.lambda_equality(x,y)
				  then (info "= identity removed";
					primitive_true)
			       else test
d388 4
a391 4
  fun ne_ident (test, (x,y)) = if LS.lambda_equality(x,y)
				  then (info "<> identity removed";
					primitive_false)
			       else test
a392 4
in
  (***********************)
  (*  The Main Function  *)
  (***********************)
d394 11
a404 8
  fun fold_constants inlinesub (optinfo(*not used yet*),expression) =
     let
	fun findexn s = 
	   case (Environ.lookup_exn(Ident.EXCON(Symbol.find_symbol s),
				    Primitives.initial_env)) of
	      Environ.EnvironTypes.PRIM p => p
	    | _ => Crash.impossible
		("Expected primitive exn in environment for "^s)
d406 2
a407 2
	fun is_manifest_list l =
	  (extract_primitive_list l; true) handle cant_find_list => false;
d409 3
a411 3
	fun is_const (LT.SCON _) = true
	  | is_const (LT.INT _)  = true
	  | is_const l = is_manifest_list l
d413 1
a413 1
	fun K x _ = x
d415 1
a415 1
	fun mkexn ex = LT.RAISE (LT.STRUCT [LT.BUILTIN ex,LT.STRUCT[]]);
d417 2
a418 2
	fun decon_int (LT.SCON (Ident.INT s)) = BigNum.string_to_bignum s
	  | decon_int _ = Crash.impossible "descon_int: bad arg"
d420 1
a420 1
	fun recon_int bn = LT.SCON (Ident.INT (BigNum.bignum_to_string bn))
d422 2
a423 2
	fun recon_bool true  = primitive_true
	  | recon_bool false = primitive_false
d425 3
a427 3
        (* x&y must be constant *)
	fun wob_fold_eq (x,y) = (info "folded =";  
				 recon_bool (LS.lambda_equality(x,y)))
d429 2
a430 2
	and wob_fold_ne (x,y) = (info "folded <>"; 
				 recon_bool (not(LS.lambda_equality(x,y))))
d432 6
a437 6
	fun big_wobble1 f x     = (info "folded unary op";
				   recon_int(f (decon_int x)))
	fun big_wobble2 f (x,y) = (info "folded binary op";
				   recon_int(f (decon_int x,decon_int y)))
	fun big_boolwob f (x,y) = (info "folded comparison";
				   recon_bool(f (decon_int x,decon_int y)))
d439 3
a441 3
        val zero = BigNum.string_to_bignum "0"
        val one = BigNum.string_to_bignum "1"
        val two = BigNum.string_to_bignum "2"
d443 2
a444 2
        fun is_positive(x) =
            BigNum.> (decon_int x,zero)
d446 14
a459 13
        fun optimise_shift rightwards (x,y) =
          let
            (* The second argument is positive *)
            val first = decon_int x
            val second = decon_int y
            fun do_shift (first,second) =
              if BigNum.eq(zero,second)
                then recon_int first
              else do_shift((if rightwards then BigNum.div else BigNum.* ) (first,two),
                            BigNum.-(second,one))
          in
            do_shift(first,second)
          end
d462 25
a486 26
        fun optimise_logical function (x,y) =
          let
            val first = decon_int x
            val second = decon_int y
            fun do_logical (first,second,position,acc) =
              if BigNum.eq(zero,first) andalso BigNum.eq(zero,second)
                then 
                   recon_int acc
              else 
                let
                  val first' = BigNum.eq(BigNum.mod(first,two),one)
                  val second' = BigNum.eq(BigNum.mod(second,two),one)
                  val result = 
                    if function(first',second')
                      then one
                    else zero
                in
                do_logical(BigNum.div(first,two),
                           BigNum.div(second,two),
                           BigNum.*(position,two),
                           BigNum.+(acc,BigNum.*(position,result)))
                end
          in
            do_logical(first,second,one,zero)
          end
                  
a487 2
	fun foldc (original as 
		   LT.APP(LT.APP(LT.BUILTIN p, map_fn,_),map_list,_)) =
d489 5
a493 1
	   (* --- folding map --- *)
d495 1
a495 3
	   (case p of
	       P.MAP => fold_map (original, map_fn, map_list)
	     | _ => original)
d497 42
a538 1
	  | foldc (original as LT.APP(LT.BUILTIN p, l as LT.STRUCT[x,y], _)) =
d540 28
a567 1
	   (* --- folding binary functions --- *)
d569 1
a569 39
	   if (is_const x) andalso (is_const y)
	      then
		 ((case p of
		    P.INTPLUS      => big_wobble2 BigNum.+
		  | P.INTMINUS     => big_wobble2 BigNum.-
		  | P.INTSTAR      => big_wobble2 BigNum.*
		  | P.DIV          => big_wobble2 BigNum.div
		  | P.MOD          => big_wobble2 BigNum.mod
		  | P.INTLESS      => big_boolwob BigNum.<
		  | P.INTGREATER   => big_boolwob BigNum.>
		  | P.INTLESSEQ    => big_boolwob BigNum.<=
		  | P.INTGREATEREQ => big_boolwob BigNum.>=
		  | P.EQ           => wob_fold_eq
		  | P.INTEQ 	   => wob_fold_eq
		  | P.REALEQ       => curry eq_ident original
		  | P.STRINGEQ     => wob_fold_eq
		  | P.NE           => wob_fold_ne
		  | P.INTNE        => wob_fold_ne
		  | P.REALNE       => curry ne_ident original
		  | P.STRINGNE     => wob_fold_ne
		  | P.AT           => curry append_ident_fold original
		  | P.HAT          => fold_concat original
                  | P.RSHIFT       => if is_positive x andalso is_positive y
                                        then K original
                                      else optimise_shift true 
                  | P.LSHIFT       => if is_positive x andalso is_positive y
                                        then K original
                                      else optimise_shift false
                  | P.ANDB         => if is_positive x andalso is_positive y 
                                        then optimise_logical (fn (x,y) => 
							       x andalso y)
                                      else K original
                  | P.ORB          => if is_positive x andalso is_positive y
                                        then optimise_logical (fn (x,y) => 
							       x orelse y)
                                      else K original
		  | _              => K original) (x,y))
		      
		      handle BigNum.Runtime s => mkexn (findexn s)
a570 1
	    (* --- Algebraic Identities & List Arg Folds --- *)
d572 5
a576 23
	   else 
	      ((case p of
		   P.INTPLUS   => plus_ident
		 | P.INTMINUS  => minus_ident
		 | P.INTSTAR   => times_ident
		 | P.DIV       => div_ident
		 | P.MOD       => mod_ident
		 | P.AT        => append_ident_fold
		 | P.HAT       => concat_ident
		 | P.EQ        => eq_ident
		 | P.INTEQ     => eq_ident
		 | P.REALEQ    => eq_ident
		 | P.STRINGEQ  => eq_ident
		 | P.NE        => ne_ident
		 | P.INTNE     => ne_ident
		 | P.REALNE    => ne_ident
		 | P.STRINGNE  => ne_ident
		 | P.IMPLODE   => K (fold_implode original l)
		 | P.REV       => K (fold_rev original l)
		 | _           => K original) (original,(x,y))
		     
		   handle Div => mkexn P.EXDIV
			| Mod => mkexn P.EXMOD)
d578 18
d597 14
a611 1
	  | foldc (original as LT.APP(LT.BUILTIN p, x, _)) =
d613 6
a618 14
	   (* --- folding unary functions --- *)
	    
	   if (is_const x)
	      then
		 ((case p of
		     P.INTABS     => big_wobble1 BigNum.abs
		   | P.INTUMINUS  => big_wobble1 BigNum.~
		   | P.ORD        => fold_ord original
		   | P.CHR        => fold_chr original
		   | P.REV        => fold_rev original     (* picks up nil *)
		   | P.IMPLODE    => fold_implode original (* ditto        *)
		   | P.EXPLODE    => fold_explode original 
		   | P.SIZE       => fold_size original
		   | _            => K original) x)
d620 4
a623 3
		      handle BigNum.Runtime s => mkexn (findexn s)
			   | Ord => mkexn P.EXORD
			   | Chr => mkexn P.EXCHR
d625 3
a627 1
	   else original
d629 3
a631 1
	  | foldc original = original
d633 4
a636 3
     in
	LS.apply_innermost foldc expression
     end;
a637 1
end (* of local *)
a638 19
local
   open P
in
   (*  These primitives are exported so that other parts of the  *)
   (*  optimiser can predict which functions can be reduced at   *)
   (*  compile-time.						 *)

   val folded_primitives_onearg = [INTPLUS, INTMINUS, INTSTAR, DIV, MOD,
				   INTLESS, INTGREATER, INTEQ, INTNE, AT, HAT,
				   REV, INTABS, INTUMINUS, CHR, ORD, IMPLODE,
				   EXPLODE, SIZE,
				   EQ, STRINGEQ, REALEQ,
				   NE, STRINGNE, REALNE,
				   RSHIFT,LSHIFT,ANDB,ORB]

   val folded_primitives_twoarg = [MAP]
end


d645 2
a647 7
(* NB: this strategy doesn't guarantee complete coverage in beta-red;   *)
(* when the expression order requires that a shiftable expression goes  *)
(* after an unshiftable, or when both args are unshiftable and we hit   *)
(* a redex on the wrong one, there'll be a redex that won't be reduced  *)
(* that we could do better with.  The old version of beta reduction     *)
(* (_optimise_beta, before 1.21) would fiddle the commutative order on  *)
(* expressions, but this is much effort for infrequent reward.          *)
d649 3
a652 1
local
d683 10
d694 1
a694 6
fun rearrange_arithmetic (LT.Info{is_shiftable,
				  is_commutative, 
				  is_associative,
				  bindings,...}, expression) = 
  let
    fun hats_to_implode (arg,original) =
d742 1
d747 5
a751 1
	  | transform1 (accargs, LT.STRUCT[arg1, arg2]) = arg2::arg1::accargs
d753 1
d758 1
d763 1
a763 3
	val reordered_args = if is_commutative func
			       then Lists.qsort recommute_order list_of_args
			     else list_of_args
d765 11
a775 1
	make_best_application_association (func,ty,reordered_args)
d778 9
d788 27
a814 15
    and rearrange(binapp as LT.APP(func,arg as LT.STRUCT[x,y],ty)) =
      (case func of
	 LT.BUILTIN P.HAT => hats_to_implode (arg, binapp)
       | _ => 
	   if is_associative(func)
	     then reassociate_and_commute (func,arg,ty)
	   else 
	     let
	       val x' = rearrange x
	       and y' = rearrange y
	     in
	       if is_commutative(func) andalso recommute_order(x',y')
		 then LT.APP(func, LT.STRUCT[y',x'],ty)
	       else LT.APP(func, LT.STRUCT[x',y'],ty)
	     end)
d822 32
@


1.14
log
@Added LET constructor and new slot to APP.
@
text
@a18 1
require "optimise_lib";
d20 1
d28 1
d30 5
a34 6
    and Lib         : OPTIMISE_LIB
    and Environ     : ENVIRON
    and Primitives  : PRIMITIVES
    and Pervasives  : PERVASIVES
    and Ident       : IDENT
    and BigNum      : BIGNUM
d36 4
a39 4
    val primitive_list_cons : Lib.LT.LambdaExp
    and primitive_list_nil  : Lib.LT.LambdaExp
    val primitive_true      : Lib.LT.LambdaExp
    and primitive_false     : Lib.LT.LambdaExp
d41 3
a43 3
    exception Ord and Chr
    val ord_fold_function : string -> int
    and chr_fold_function : int -> string
d45 2
a46 1
    sharing type Pervasives.pervasive = Lib.LT.Primitive (* Ha! I know this! *)
d48 2
a49 1
    sharing Lib.LT = Environ.LambdaTypes = Primitives.LambdaTypes = LambdaPrint.LambdaTypes
d54 1
d56 4
a59 3
   structure P = Pervasives
   structure Symbol = Ident.Symbol
   open Lib  infix mem == ++ -- (* !!! *)
d61 2
d64 2
a65 2
   val show_debug_info = ref true;
   fun info message = if !show_debug_info then Print.print message else ()
d74 3
d78 1
a85 4
 fun make_primitive_list [] = primitive_list_nil
   | make_primitive_list (x::xs) = LT.STRUCT[primitive_list_cons,
					   LT.STRUCT[x,make_primitive_list xs]]

d601 1
a601 1
(* left. *)
d612 32
d649 14
a662 3
    fun quick_equality (LT.VAR x,LT.VAR y) = LT.LVar_eq(x,y)
      | quick_equality (LT.BUILTIN p,LT.BUILTIN q) = p=q
      | quick_equality _ = false
d664 7
a670 7
    fun rearrange(binapp as LT.APP(func,LT.STRUCT[x,y],ty)) =
    if (is_commutative func) andalso LT.expr_order(y,x)
     then if not(LT.expr_order(x,y))
	   then (* reverse if either arg is shiftable *)
	     if (is_shiftable y) orelse (is_shiftable x)
	       then LT.APP(func,LT.STRUCT[y,x],ty)
	     else binapp
d673 1
a673 1
	       (false,true) => LT.APP(func,LT.STRUCT[y,x],ty)
d679 57
a735 7
				    then LT.APP(func,LT.STRUCT[y,x],ty)
				  else binapp) 
				    handle LT.BindingTable.Undefined => binapp)
		  | _ => binapp)
	     | _ => binapp)
    else binapp
      | rearrange expr = expr
d737 1
a737 1
    LS.apply_outermost rearrange expression
d740 1
a741 7
(*
      | rearrange(nestedapp as LT.APP(func,LT.APP(func',arg),ty)) =
	if quick_equality(func,func') andalso 
	   (is_associative func)
	  then LT.APP(LT.APP(
                  LT.AP
*)
d747 3
@


1.13
log
@Added missing handle in rearrange.
@
text
@d102 1
a102 1
	    val (map_fn_var,wrll) = 
d104 1
a104 1
		LT.VAR fn_var => (fn_var,[])
d108 1
a108 3
		       (v, [(v,map_fn,
			     "wrap_lets in _optimise_builtin",
			     LT.null_type_annotation())])
d111 4
a114 1
	    fun app_map_fn x = LT.APP(LT.VAR map_fn_var, x)
d116 5
a120 3
	    info "folded map";
	    LS.wrap_lets (make_primitive_list (map app_map_fn thelist),
			  wrll)
d160 2
a161 1
	      | [r1,r2] => LT.APP(LT.BUILTIN P.HAT, (LT.STRUCT[r1,r2]))
d163 2
a164 1
				   make_primitive_list (rev new_list)))
d226 2
a227 3
    | minus_ident (_, (LT.SCON(Ident.INT "0"), y)) = (info s;
						      LT.APP(LT.BUILTIN 
							     P.INTUMINUS,y))
d270 4
a273 1
             LT.APP(LT.BUILTIN(P.ARSHIFT),LT.STRUCT[x,LT.SCON(Ident.INT (Integer.makestring(log2 true_value)))]))
d301 5
a305 1
             LT.APP(LT.BUILTIN(P.ANDB),LT.STRUCT[x,LT.SCON(Ident.INT (Integer.makestring(true_value-1)))]))
d459 2
a460 1
	fun foldc (original as LT.APP(LT.APP(LT.BUILTIN p, map_fn),map_list)) =
d468 1
a468 1
	  | foldc (original as LT.APP(LT.BUILTIN p, l as LT.STRUCT[x,y])) =
d540 1
a540 1
	  | foldc (original as LT.APP(LT.BUILTIN p, x)) =
d615 1
a615 1
    fun rearrange(binapp as LT.APP(func,LT.STRUCT[x,y])) =
d620 1
a620 1
	       then LT.APP(func,LT.STRUCT[y,x])
d624 1
a624 1
	       (false,true) => LT.APP(func,LT.STRUCT[y,x])
d629 4
a632 4
					  (LT.BindingTable.apply bindings v))
				     then LT.APP(func,LT.STRUCT[y,x])
				   else binapp) 
				     handle LT.BindingTable.Undefined => binapp)
d643 1
a643 1
      | rearrange(nestedapp as LT.APP(func,LT.APP(func',arg))) =
d654 3
@


1.12
log
@Fixed instances of map folding broken by previous bug-fix.
Made implode folding more general - it now coalesces
adjacent constant strings.  Added primitives into
folded_primitives lists.  Begun work on rearrangement:
commutative functions are now re-ordered.  Added variable
controlling number of ^'s replaced by implode (but function
not written yet).
@
text
@d616 5
a620 4
		                 if not(is_shiftable 
					(LT.BindingTable.apply bindings v))
				   then LT.APP(func,LT.STRUCT[y,x])
				 else binapp
d642 9
@


1.11
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d66 2
a88 3
 fun is_const (LT.SCON _) = true
 | is_const (LT.INT _)  = true
 | is_const l = is_const_list l
a89 3
 and is_const_list l =
   (Lists.forall is_const (extract_primitive_list l))
   handle cant_find_list => false;
a90 1

d96 16
a111 17
   if (is_const_list map_list)
     then
	let
	   val thelist = extract_primitive_list map_list
	in
	   if (Lists.length thelist <= (!max_map_fold_length))
	      then 
		 let
		   val (map_fn_var,wrll) = 
		      case map_fn of
			 LT.VAR fn_var => (fn_var,[])
		       | _ => let
				 val v = LT.new_LVar()
			      in 
				 (v, [(v,map_fn,"wrap_lets in _optimise_builtin",
                                       LT.null_type_annotation())])
			      end
d113 8
a120 9
		   fun app_map_fn x = LT.APP(LT.VAR map_fn_var, x)
		 in
		    info "folded map";
		    LS.wrap_lets (make_primitive_list (map app_map_fn thelist),
				  wrll)
		 end
	   else original
	end
   else original
d123 1
d140 2
a141 12
    if is_const listexpr then
      (let
	 val thelist = extract_primitive_list listexpr
	 val _ = Print.print"fold_implode of\n"
	 val _ =
	   Lists.iterate
	   (fn le => (LambdaPrint.print_lambda le;
		      Print.print"\n"))
	   thelist
	 fun destruct_string (LT.SCON (Ident.STRING s)) = s
	   | destruct_string _ =
	     Crash.impossible "Non string in fold_implode list"
d143 9
a151 7
	 val result = LT.SCON (Ident.STRING 
			       (implode (map destruct_string thelist)))
       in
	 (info "folded implode"; result)
       end) handle cant_find_list => original
    else
      original
d153 21
d176 1
a176 3
      case (explode s) of
	 [] => raise Ord
       | (x::_) => LT.SCON(Ident.INT(Integer.makestring(ord_fold_function x))))
d191 1
a191 1
  fun concat_fold _ (LT.SCON(Ident.STRING s1),
d194 1
a194 1
    | concat_fold original _ = original
d357 1
a357 1
  fun fold_constants _ expression =
d366 7
d386 2
a387 2
	fun wob_fold_eq (x,y) = (info "folded =";  recon_bool (LS.lambda_equality(x,y)))
	and wob_fold_ne (x,y) = (info "folded <>"; recon_bool (not(LS.lambda_equality(x,y))))
d389 3
d481 1
a481 1
		  | P.HAT          => concat_fold original
d489 2
a490 1
                                        then optimise_logical (fn (x,y) => if x andalso y then true else false)
d493 2
a494 1
                                        then optimise_logical (fn (x,y) => if x orelse y then true else false)
d571 2
a572 1
				   NE, STRINGNE, REALNE]
d578 6
a583 1
fun rearrange_arithmetic info x = x
d585 7
d593 44
d641 3
@


1.10
log
@Added type annotations to FNexp
@
text
@d80 1
a80 1
    				if tag=primitive_list_cons
d83 1
a83 1
   | extract_primitive_list tag = if tag=primitive_list_nil
d219 1
a219 1
    | minus_ident (diff, (x,y)) = if x=y 
d263 1
a263 1
          if x=y 
d291 1
a291 1
          if x=y 
d303 1
a303 1
	   if tag=primitive_list_cons
d311 1
a311 1
	    if tag=primitive_list_nil
d317 1
a317 1
	    val result = (if list2 = primitive_list_nil
d336 1
a336 1
  fun eq_ident (test, (x,y)) = if x=y 
d342 1
a342 1
  fun ne_ident (test, (x,y)) = if x=y
d374 2
a375 2
	fun wob_fold_eq (x,y) = (info "folded =";  recon_bool (x=y))
	and wob_fold_ne (x,y) = (info "folded <>"; recon_bool (x<>y))
d567 3
@


1.9
log
@Div goes to arithmetic shift
@
text
@d115 2
a116 1
				 (v, [(v,map_fn,"wrap_lets in _optimise_builtin")])
d567 3
@


1.8
log
@Optimisations to div and mod (via andb and rshift), and logicals
@
text
@d259 2
a260 2
            (info "div of positive power of two changed to rshift";
             LT.APP(LT.BUILTIN(P.RSHIFT),LT.STRUCT[x,LT.SCON(Ident.INT (Integer.makestring(log2 true_value)))]))
d566 3
@


1.7
log
@Added debug information
@
text
@a222 1

d233 6
d247 19
a265 3
    | div_ident (same, (x,y)) = if x=y 
				   then (info s; LT.SCON(Ident.INT "1"))
				else same
d277 17
a293 3
    | mod_ident (same, (x,y)) = if x=y 
				   then (info s; LT.SCON(Ident.INT "0"))
				else same
d383 49
d466 12
d566 3
@


1.6
log
@First version of the profiler
@
text
@d21 1
a22 1

d28 1
d47 1
a47 1
    sharing Lib.LT = Environ.LambdaTypes = Primitives.LambdaTypes = LambdaPrint_.LambdaTypes
d151 1
a151 1
	   (fn le => (LambdaPrint_.print_lambda le;
d470 3
@


1.5
log
@Fixed problems with fold_implode whereby some lists were erroneously
thought to be constant.
@
text
@d114 1
a114 1
				 (v, [(v,map_fn)])
d469 4
@


1.4
log
@Added requires for Lists, Print, Integer
@
text
@d46 1
a46 1
    sharing Lib.LT = Environ.LambdaTypes = Primitives.LambdaTypes 
d86 3
a88 2
 fun is_const_list l = (extract_primitive_list l;
			true) handle cant_find_list => false;
d90 3
d94 1
d144 2
a145 1
     (let
d147 6
a152 1

d159 1
a159 1
      in
d161 3
a163 1
      end) handle cant_find_list => original
a164 1

a323 4
	fun is_const (LT.SCON _) = true
	  | is_const (LT.INT _)  = true
	  | is_const l = is_const_list l

d469 3
@


1.3
log
@Took out imposs function and exception impossible (replaced
them with Crash.impossible which prints the message before
raising its exception).
@
text
@d11 3
d23 5
a27 2
functor OptimiseBuiltin 
   (structure Crash : CRASH
d58 1
a58 1
   fun info message = if !show_debug_info then print message else ()
d100 1
a100 1
	   if (length thelist <= (!max_map_fold_length))
d157 1
a157 1
       | (x::_) => LT.SCON (Ident.INT (makestring (ord_fold_function x))))
d178 4
a181 3
  fun fold_size _ (LT.SCON(Ident.STRING s)) = (info "folded size";
					       LT.SCON(Ident.INT 
						       (makestring (size s))))
d460 6
a465 1
(* $Log:	_optimise_builtin.sml,v $
@


1.2
log
@All optimisations now produce messages; map folding has
been improved for a wider class of args.
@
text
@d2 7
a8 1
 (*  Lambda-Calculus Optimisation: _optimise_builtin  *)
d10 1
a10 7
     (*  Constant Folding, Identity Re-writes,  *)
     (*       Algebraic Transformations.        *)


(*  Copyright (c) 1991 Harlequin Ltd. *)


d21 7
a27 6
   (structure Lib  : OPTIMISE_LIB
    and Environ    : ENVIRON
    and Primitives : PRIMITIVES
    and Pervasives : PERVASIVES
    and Ident      : IDENT
    and BigNum     : BIGNUM
a53 3
   exception impossible of string
   fun imposs message = raise impossible message

d137 2
a138 1
	   | destruct_string _ = imposs "Non string in implode fold list"
d302 2
a303 1
	    | _ => imposs ("Expected primitive exn in environment for "^s)
d314 1
a314 1
	  | decon_int _ = imposs "descon_int: bad arg"
d454 4
@


1.1
log
@Initial revision
@
text
@d91 26
a116 12
    if (is_const_list map_list) andalso (LS.whnf map_fn)
       then
	  let
	     val thelist = extract_primitive_list map_list
	  in
	     if (length thelist <= (!max_map_fold_length))
		then 
		   (info "folded map";
		    make_primitive_list (map (fn x=>LT.APP(map_fn,x)) thelist))
	     else original
	  end
    else original
d149 2
a150 1
     (case (explode s) of
d152 2
a153 3
       | (x::_) => (info "folded ord";
		    LT.SCON (Ident.INT (makestring (ord_fold_function x)))))
    | fold_ord original _ = original;
d161 2
a162 1
	LT.SCON (Ident.STRING (chr_fold_function (makeint(0,explode i))))
d164 1
a164 1
   | fold_chr original _ = original;
d168 2
a169 1
		     LT.SCON(Ident.STRING s2)) = LT.SCON(Ident.STRING(s1^s2))
d173 3
a175 2
  fun fold_size _ (LT.SCON(Ident.STRING s)) = LT.SCON(Ident.INT 
						      (makestring (size s)))
d183 5
a187 2
  fun plus_ident (_,  (LT.SCON(Ident.INT "0"), y)) = y
    | plus_ident (_,  (x, LT.SCON(Ident.INT "0"))) = x
d189 1
d192 7
a198 4
  fun minus_ident (_, (x, LT.SCON(Ident.INT "0"))) = x
    | minus_ident (_, (LT.SCON(Ident.INT "0"), y)) = LT.APP(LT.BUILTIN 
							     P.INTUMINUS,
							    y)
d200 1
a200 1
				     then (LT.SCON(Ident.INT "0"))
d202 1
d205 7
a211 4
  fun times_ident (_,    (zero as LT.SCON(Ident.INT "0"), y)) = zero
    | times_ident (_,    (x, zero as LT.SCON(Ident.INT "0"))) = zero
    | times_ident (_,    (x, LT.SCON(Ident.INT "1")))         = x
    | times_ident (_,    (LT.SCON(Ident.INT "1"), y))         = y
d213 1
d216 7
a222 3
  fun div_ident (_,    (x, LT.SCON(Ident.INT "1"))) = x
    | div_ident (_,    (x, LT.SCON(Ident.INT "0"))) = raise Div
    | div_ident (_,    (LT.SCON(Ident.INT "0"), _)) = LT.SCON(Ident.INT "0")
d224 1
a224 1
				   then LT.SCON(Ident.INT "1")
d226 1
d229 8
a236 3
  fun mod_ident (_,    (x, LT.SCON(Ident.INT "1"))) = LT.SCON(Ident.INT "0")
    | mod_ident (_,    (x, LT.SCON(Ident.INT "0"))) = raise Mod
    | mod_ident (_,    (LT.SCON(Ident.INT "0"), y)) = LT.SCON(Ident.INT "0")
d238 1
a238 1
				   then LT.SCON(Ident.INT "0")
d240 1
d257 1
a257 1
	       then (info "folded @@"; list2)
d259 1
d261 8
a268 3
	if list2 = primitive_list_nil
	   then list1
	else (replace_end list1) handle cant_find_nil => original
d271 6
a276 2
  fun concat_ident (_,  (x, LT.SCON(Ident.STRING ""))) = x
    | concat_ident (_,  (LT.SCON(Ident.STRING ""), y)) = y
d278 1
d282 2
a283 1
				  then primitive_true
d286 1
d288 3
a290 2
				   then primitive_false
				else test
d297 1
a297 1
  fun fold_constants info expression =
d321 3
a323 2
	fun wob_fold_eq (x,y) = recon_bool (x=y)   (* x&y must be constant *)
	and wob_fold_ne (x,y) = recon_bool (x<>y)
d325 6
a330 3
	fun big_wobble1 f x     = recon_int(f (decon_int x))
	fun big_wobble2 f (x,y) = recon_int(f (decon_int x,decon_int y))
	fun big_boolwob f (x,y) = recon_bool(f (decon_int x,decon_int y))
d453 4
a456 1
(* $Log$ *)
@
