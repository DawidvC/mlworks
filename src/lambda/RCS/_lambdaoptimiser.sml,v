head	1.66;
access;
symbols
	ML_beta_release_12/08/94:1.64
	ML_beta_release_03/08/94:1.64
	ML_revised_beta_release_25/05/94:1.63
	ML_final_beta_release_02/03/94:1.63
	mlworks-28-01-1994:1.61
	Release:1.58
	mlworks-beta-01-09-1993:1.58
	MLWorks-1-0-4-29/01/1993:1.52
	MLWorks-1-0-3-21/12/1992:1.52
	MLWorks-1-0-2-15/12/1992:1.52
	MLWorks-1-0-1-04/12/1992:1.52
	checkpoint_17_08_92:1.47
	Ten15_release_21-08-91:1.20
	Ten15_release_19-08-91:1.19
	ten15_release:1.12;
locks; strict;
comment	@ * @;


1.66
date	94.10.10.10.01.49;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	94.09.19.14.41.49;	author matthew;	state Exp;
branches;
next	1.64;

1.64
date	94.07.19.14.41.40;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	94.02.23.13.09.17;	author nosa;	state Exp;
branches;
next	1.62;

1.62
date	94.02.17.14.44.47;	author jont;	state Exp;
branches;
next	1.61;

1.61
date	93.12.09.19.21.59;	author jont;	state Exp;
branches;
next	1.60;

1.60
date	93.11.25.15.40.44;	author nosa;	state Exp;
branches;
next	1.59;

1.59
date	93.09.16.14.54.44;	author nosa;	state Exp;
branches;
next	1.58;

1.58
date	93.07.14.10.21.45;	author nosa;	state Exp;
branches
	1.58.1.1;
next	1.57;

1.57
date	93.07.12.16.13.53;	author jont;	state Exp;
branches;
next	1.56;

1.56
date	93.05.18.15.48.22;	author jont;	state Exp;
branches;
next	1.55;

1.55
date	93.05.18.12.18.55;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	93.05.11.12.46.34;	author jont;	state Exp;
branches;
next	1.53;

1.53
date	93.03.04.12.57.14;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	92.11.26.19.40.56;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	92.11.19.15.58.54;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	92.11.09.12.52.58;	author clive;	state Exp;
branches;
next	1.49;

1.49
date	92.09.29.13.58.55;	author matthew;	state Exp;
branches;
next	1.48;

1.48
date	92.08.26.13.19.55;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	92.07.24.13.43.48;	author clive;	state Exp;
branches;
next	1.46;

1.46
date	92.07.10.14.09.00;	author davida;	state Exp;
branches;
next	1.45;

1.45
date	92.07.09.17.39.12;	author davida;	state Exp;
branches;
next	1.44;

1.44
date	92.07.08.13.54.02;	author davida;	state Exp;
branches;
next	1.43;

1.43
date	92.07.07.16.59.46;	author davida;	state Exp;
branches;
next	1.42;

1.42
date	92.07.03.09.37.20;	author davida;	state Exp;
branches;
next	1.41;

1.41
date	92.06.30.13.14.59;	author davida;	state Exp;
branches;
next	1.40;

1.40
date	92.06.16.15.20.47;	author clive;	state Exp;
branches;
next	1.39;

1.39
date	92.04.22.11.46.30;	author clive;	state Exp;
branches;
next	1.38;

1.38
date	92.03.27.13.39.25;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	92.01.31.11.50.16;	author clive;	state Exp;
branches;
next	1.36;

1.36
date	92.01.03.12.34.16;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	91.11.22.17.48.04;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	91.10.24.14.34.10;	author davidt;	state Exp;
branches;
next	1.33;

1.33
date	91.10.22.18.24.06;	author davidt;	state Exp;
branches;
next	1.32;

1.32
date	91.10.22.12.54.17;	author davidt;	state Exp;
branches;
next	1.31;

1.31
date	91.09.24.14.35.12;	author davida;	state Exp;
branches;
next	1.30;

1.30
date	91.09.16.12.43.06;	author davida;	state Exp;
branches;
next	1.29;

1.29
date	91.09.12.15.53.45;	author davida;	state Exp;
branches;
next	1.28;

1.28
date	91.09.10.16.00.02;	author davida;	state Exp;
branches;
next	1.27;

1.27
date	91.09.09.16.51.44;	author davida;	state Exp;
branches;
next	1.26;

1.26
date	91.09.04.14.46.18;	author davida;	state Exp;
branches;
next	1.25;

1.25
date	91.09.04.14.38.57;	author davida;	state Exp;
branches;
next	1.24;

1.24
date	91.09.04.11.13.47;	author davida;	state Exp;
branches;
next	1.23;

1.23
date	91.09.02.15.08.22;	author davida;	state Exp;
branches;
next	1.22;

1.22
date	91.08.27.16.29.17;	author davida;	state Exp;
branches;
next	1.21;

1.21
date	91.08.27.08.51.19;	author davida;	state Exp;
branches;
next	1.20;

1.20
date	91.08.19.17.02.31;	author davida;	state Exp;
branches;
next	1.19;

1.19
date	91.08.13.17.08.34;	author davida;	state Exp;
branches;
next	1.18;

1.18
date	91.08.09.18.56.11;	author davida;	state Exp;
branches;
next	1.17;

1.17
date	91.08.06.16.13.01;	author davida;	state Exp;
branches;
next	1.16;

1.16
date	91.08.02.17.48.14;	author davida;	state Exp;
branches;
next	1.15;

1.15
date	91.08.02.10.02.36;	author davida;	state Exp;
branches;
next	1.14;

1.14
date	91.07.31.19.55.31;	author davida;	state Exp;
branches;
next	1.13;

1.13
date	91.07.31.14.48.49;	author davida;	state Exp;
branches;
next	1.12;

1.12
date	91.07.30.18.59.52;	author davida;	state Exp;
branches;
next	1.11;

1.11
date	91.07.29.17.23.46;	author davida;	state Exp;
branches;
next	1.10;

1.10
date	91.07.25.15.07.08;	author davida;	state Exp;
branches;
next	1.9;

1.9
date	91.07.24.13.59.35;	author davida;	state Exp;
branches;
next	1.8;

1.8
date	91.07.22.14.39.14;	author davida;	state Exp;
branches;
next	1.7;

1.7
date	91.07.17.13.17.04;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	91.07.17.10.05.38;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.07.15.16.38.26;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.07.12.13.44.47;	author davida;	state Exp;
branches;
next	1.3;

1.3
date	91.07.11.12.44.26;	author davida;	state Exp;
branches;
next	1.2;

1.2
date	91.07.10.14.07.09;	author davida;	state Exp;
branches;
next	1.1;

1.1
date	91.07.09.12.34.12;	author davida;	state Exp;
branches;
next	;

1.58.1.1
date	93.07.14.10.21.45;	author jont;	state Exp;
branches;
next	;


desc
@Lambda-expression optimiser.
@


1.66
log
@Lambdatypes changes
@
text
@(* _lambdaoptimiser the functor *)
(*
$Log: _lambdaoptimiser.sml,v $
Revision 1.65  1994/09/19  14:41:49  matthew
Abstraction of debug information in lambdatypes

Revision 1.64  1994/07/19  14:41:40  matthew
Multiple function parameters

Revision 1.63  1994/02/23  13:09:17  nosa
Do not lambda optimise when compiling for Stepper or Modules Debugger.

Revision 1.62  1994/02/17  14:44:47  jont
Added an extra optimisation phase between the middle pahse and the lifting
phase. This beta reduces until no APP-FN constructs are left.

Revision 1.61  1993/12/09  19:21:59  jont
Added copyright message

Revision 1.60  1993/11/25  15:40:44  nosa
Pass recipe-generation compiler option to optimiser.

Revision 1.59  1993/09/16  14:54:44  nosa
Switch off optimisations for polymorphic debugger;
FNs now passed closed-over type variables and stack
frame-offset for runtime-instance for polymorphic debugger.

Revision 1.58  1993/07/14  10:21:45  nosa
structure Option.

Revision 1.57  1993/07/12  16:13:53  jont
Reinstated constant folding

Revision 1.56  1993/05/18  15:48:22  jont
Removed integer parameter

Revision 1.55  1993/05/18  12:18:55  jont
Changed contraction optimisations to optimise unitl done for small expressions

Revision 1.54  1993/05/11  12:46:34  jont
Made intercept option turn off inlining

Revision 1.53  1993/03/04  12:57:14  matthew
Options & Info changes

Revision 1.52  1992/11/26  19:40:56  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.51  1992/11/19  15:58:54  daveb
Added final switch elimination pass to deal with cases exposed by letrec
elimination.  This should remove the need for _mir_cg to deal with
switches on integers, among other things.

Revision 1.50  1992/11/09  12:52:58  clive
Added some LETREC optimisation

Revision 1.49  1992/09/29  13:58:55  matthew
Replaced float constants by calls to "real"

Revision 1.48  1992/08/26  13:19:55  jont
Removed some redundant structures and sharing

Revision 1.47  1992/07/24  13:43:48  clive
Modified to use the new hashtables

Revision 1.46  1992/07/10  14:09:00  davida
Configuration.

Revision 1.45  1992/07/09  17:39:12  davida
Configuration.

Revision 1.44  1992/07/08  13:54:02  davida
Minor alterations to configuration.

Revision 1.43  1992/07/07  16:59:46  davida
Changed default value of flags to false.

Revision 1.42  1992/07/03  09:37:20  davida
Added LET constructor and new slot to APP.
Further experiments with configuration.
(still needs adjustment).

Revision 1.41  1992/06/30  13:14:59  davida
(Provisionally) altered configuration to perform a fixed
number of iterations of the optimisation functions (just
two presently).

Revision 1.40  1992/06/16  15:20:47  clive
LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality

Revision 1.39  1992/04/22  11:46:30  clive
Modified a few calls to isolate the state in other functions to allow the use of hash table

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/lists";
require "../utils/timer";
require "../utils/print";
require "optimise_contract";
require "optimise_builtin";
require "optimise_beta";
require "optimise_cse";
require "optimise_lift";

require "lambdasub";
require "lambdaprint";
require "lambdaoptimiser";

functor LambdaOptimiser(
  structure Lists            : LISTS
  structure Print            : PRINT
  structure Timer 	     : TIMER

  structure OptimiseContract : OPTIMISE_CONTRACT
  structure OptimiseBuiltin  : OPTIMISE_BUILTIN
  structure OptimiseBeta     : OPTIMISE_BETA
  structure OptimiseCSE      : OPTIMISE_CSE
  structure OptimiseLift     : OPTIMISE_LIFT
				
  structure LambdaPrint : LAMBDAPRINT
  structure LambdaSub   : LAMBDASUB

  sharing LambdaSub.LT
    = OptimiseContract.LT
    = OptimiseBuiltin.LT
    = OptimiseCSE.LT
    = OptimiseBeta.LT
    = OptimiseLift.LT
    = LambdaPrint.LambdaTypes
) : LAMBDAOPTIMISER =
struct

  (* preamble *)

  structure LS = LambdaSub
  structure LT = LS.LT and LambdaTypes = LS.LT
  structure Set = LT.Set
  structure Options = LambdaPrint.Options

  val print_hash_table_stats = LS.print_hash_table_stats

  fun fst(x,_)=x and snd(_,y)=y
  fun swap f (x,y) = f (y,x)
  fun curry f x y = f (x,y)
  and uncurry f (x,y) = f x y
  fun apfst f (x,y) = (f x, y)
  and apsnd f (x,y) = (x, f y)
  fun K x y = y


  val mem = Set.is_member
  val ==  = Set.seteq
  val ++  = swap Set.add_member
  fun -- (S,a) = Set.setdiff (S, Set.singleton a)
  infix ++ -- == mem

   
  val show_debug_info = ref true;
  fun info message = if !show_debug_info then Print.print message else ()

  val show_optimisations_applied = ref false;
  val show_lambda_code = ref false;
  val show_timings = ref false;
  val check_validity = ref false;

  local 
     val show_switches =
	[show_debug_info, show_optimisations_applied, 
	 show_lambda_code, show_timings,
	 OptimiseContract.show_debug_info,
	 OptimiseBuiltin.show_debug_info,
	 OptimiseBeta.show_debug_info,
	 OptimiseCSE.show_debug_info,
	 OptimiseLift.show_debug_info]

     fun iter f [] = ()
       | iter f (x::xs) = (f x; iter f xs)
  in
     fun show_all()  = iter (fn s=>s:=true) show_switches
     and show_none() = iter (fn s=>s:=false) show_switches
  end

  val _ = show_none()   (* ###for everyone else### *)

  val print_lam = LambdaPrint.print_lambda;

  (***************************)
  (* Apply all Optimisations *)
  (***************************)
 
  fun repeat_contract (build_opt_fn,max_iters) expr =
     let 
	fun repeat (n,expr) =
	   let
	      val optinfo = OptimiseBeta.process_expr expr
	      val opt_expr = (build_opt_fn optinfo) expr
	   in 
	      if (n>max_iters) orelse LS.lambda_equality(opt_expr,expr)
		then (opt_expr, OptimiseBeta.process_expr expr)
	      else repeat (n+1,opt_expr)
	   end
     in
	repeat (0,expr)
     end

  (*  A list of the optimisation functions available, with their names  *)
  (*  and individual switches to turn them on and off.  Each function   *)
  (*  is an independent transformation on lambda-expressions, although  *)
  (*  the transformations do interact.  				*)

  local 
     val AI = LS.apply_innermost
     and AO = LS.apply_outermost
     and AIWC = LS.apply_innermost_with_context
     fun specialK f (info:LT.LambdaInfo) = f

     val beta_reduce = OptimiseContract.beta_reduce 
     val raise_cut   = OptimiseContract.raise_cut
     val struct_elim = fn info => AIWC (OptimiseContract.struct_elim info)
     val switch_elim = fn info => AI (OptimiseContract.switch_elim info)
     val switch_weed = OptimiseContract.switch_weed
     val select_elim = fn info => AO (OptimiseContract.select_elim info)
     val letrec_elim = fn info => AO (OptimiseContract.letrec_elim info)

     fun mega_beta_reduce generate_recipes = curry (OptimiseBeta.heuristic_beta_reduce generate_recipes)
     fun rearrange_and_fold generate_recipes = curry (OptimiseBuiltin.rearrange_arithmetic generate_recipes)
       
     val lift_expressions = OptimiseLift.lift_expressions
     val cse = OptimiseCSE.eliminate_common_subexprs

     fun inlinesub generate_recipes (info,expr) = (* function used to reduce inlined forms *)
	 ((select_elim info) o
	  (switch_elim info) o
	  (raise_cut info) o
	  (rearrange_and_fold generate_recipes info) o
	  (mega_beta_reduce generate_recipes info)) expr

     and inline generate_recipes i e =
       OptimiseBeta.function_inline generate_recipes (inlinesub generate_recipes) (i,e)
     fun fold_constants generate_recipes =
       curry (OptimiseBuiltin.fold_constants generate_recipes (inlinesub generate_recipes))
  in
   (* NB:- lists in reverse order of application *)

    val initial_optimisations = 
     [("initial_letrec_elim",      ref true, fn _ => letrec_elim),
      ("initial_beta_reduce",      ref true, fn _ => fn _ => beta_reduce),
      ("initial_mega_beta_reduce", ref true, fn generate_recipes=>mega_beta_reduce generate_recipes)];

    val inline_name = "inline"

    val beta_reducer =
      [("beta_reducer", ref true, fn generate_recipes=>mega_beta_reduce generate_recipes)]

    val inter_contraction_optimisations =
    [("inter_mega_beta_reduce", ref true, fn generate_recipes=>mega_beta_reduce generate_recipes),
     ("inter_letrec_elim",      ref true, fn _ => letrec_elim),
     (inline_name,              ref true, fn generate_recipes=>inline generate_recipes)];
    
     
    val contraction_optimisations =  
     [("mega_beta_reduce", ref true, fn generate_recipes=>mega_beta_reduce generate_recipes),
      ("raise_cut",        ref true, fn _ => raise_cut),
      ("struct_elim",      ref true, fn _ => struct_elim),
      ("switch_elim",      ref true, fn _ => switch_elim),
      ("switch_weed",      ref true, fn _ => switch_weed),
      ("select_elim",      ref true, fn _ => select_elim),
      ("rearrange",        ref true, fn generate_recipes => rearrange_and_fold generate_recipes),
      ("fold_constants",   ref true, fn generate_recipes=>fold_constants generate_recipes)];
     


    val lifting_optimisations =
     [("lifting",          ref true, fn _ => lift_expressions),
      ("cse",              ref true, fn _ => cse),
      ("letrec_elim",      ref true, fn _ => letrec_elim),
      ("final_switch_elim",      ref true, fn _ => switch_elim)
     ];



(* Justification of strategy. *)

(* Initial quick beta reduction removes vast numbers of aliases and other *)
(* simple redexes from code.  Letrec-elim then eliminates and re-nests    *)
(* letrecs.  Then there is a phase of inlining; a small amount of         *)
(* optimisation is done on inlined forms during inlining, but inlining    *)
(* introduces redexes further out also.  The contraction phase is         *)
(* repeated a couple of times as the optimisations interact a bit, and    *)
(* in general may not be complete.  Ideally we would iterate to a fixed   *)
(* point, but two passes seem to be sufficient in most cases.  The next   *)
(* phase does a further letrec removal in case our optimisations have     *)
(* removed any recursion, then CSE and lifting form the final stage.	  *)


     

  end (* of local *)


  val max_small_size   = ref 100

  fun do_all_optimisations
    (Options.OPTIONS{print_options, compiler_options =
		     Options.COMPILEROPTIONS{intercept, debug, debug_polyvariables, debug_variables,
                                             generate_stepper, generate_moduler, ...}, ...})
    expression =
    let 
       val _ = 
         if debug_polyvariables orelse generate_moduler orelse generate_stepper then
          (map (fn (name,switch,_)=> if name <> "final_switch_elim" then switch := false else ())
           (beta_reducer @@
	    initial_optimisations @@
            contraction_optimisations @@
            inter_contraction_optimisations @@
            lifting_optimisations);())
         else 
           ()
       val _ = if (!show_optimisations_applied)
		  then Print.print ("size of original expression: "^
			      (MLWorks.Integer.makestring 
			       (LS.size_of_expr expression))^"\n")
	       else ()


       val get_info = OptimiseBeta.process_expr
	 
       (* build the optimising functions... *)

       exception Continue 
       val I = fn x=>x
       val D = fn x=>fn y=>y
       val P = if !show_optimisations_applied
		  then fn s=>fn f=>fn x=>
		     (let 
			 val x' = if !show_timings
				     then Timer.time_it(s, fn () => f x)
				  else f x
			 val _ = 
			   if !check_validity
			     then (LS.check_validity 
				   (x', Continue)) 
			       handle Continue => 
			     Print.print("Bad lambda expression after "^s^"\n")
			   else ()
		      in 
			 (if LS.lambda_equality(x',x) then ()
			  else (Print.print ("after "^s^", size of expr = "^
				       (MLWorks.Integer.makestring
					(LS.size_of_expr x'))^
				       "...\n");
				if !show_lambda_code
				   then print_lam print_options x'
				else ()));
			     x'
		      end)
	       else D

       fun turn_on info (name,flag,func) =
	 if !flag andalso ((not intercept) orelse name <> inline_name) then
	   (P name (func debug info))
	 else
	   I

       val make_initial_optimiser =
	  fn i=>Lists.reducel 
	      (op o) (I, map (turn_on i) initial_optimisations)

       val make_inter_contraction_optimiser = 
	  fn i=>Lists.reducel 
	      (op o) (I, map (turn_on i) inter_contraction_optimisations)

       val make_beta_reducer = 
	  fn i=>Lists.reducel 
	      (op o) (I, map (turn_on i) beta_reducer)

       val make_contraction_optimiser = 
	  fn i=>Lists.reducel 
	      (op o) (I, map (turn_on i) contraction_optimisations)
	  
       val make_lifting_optimiser = 
	 fn i=>Lists.reducel (op o) (I, map (turn_on i) lifting_optimisations)

       val phase1_function = make_initial_optimiser OptimiseBeta.basic_info
       val phase2_function = repeat_contract (make_contraction_optimiser,10)
    in 
       let
	 fun count_expr le =
	   let
	     val max = !max_small_size
	     exception too_big
	     fun count(n, LT.VAR lv) = if n >= max then raise too_big else n+1
	       | count(n, LT.FN(_, le, _, _,_)) =
		 if n >= max then raise too_big else count(n+1, le)
	       | count(n, LT.LET((_,_,lb),le)) =
		 if n >= max then raise too_big else count(count(n+1, lb), le)
	       | count(n, LT.LETREC(_, le_list, le)) =
		 if n >= max then raise too_big else
		   Lists.reducel
		   count
		   (n, le :: le_list)
	       | count(n, LT.APP(le, le', _)) =
		 if n >= max then raise too_big else
		   Lists.reducel count (count(n+1, le), le')
	       | count(n, LT.SCON _) = if n >= max then raise too_big else n+1
	       | count(n, LT.MLVALUE _) = if n >= max then raise too_big else n+1
	       | count(n, LT.INT _) = if n >= max then raise too_big else n+1
	       | count(n, LT.SWITCH(le, _, tag_le_list, leo)) =
		 if n >= max then raise too_big else
		   Lists.reducel
		   count_tag
		   (count(count_opt(n+1, leo), le), tag_le_list)
	       | count(n, LT.STRUCT (le_list,_)) =
		 if n >= max then raise too_big else Lists.reducel count (n+1, le_list)
	       | count(n, LT.SELECT(_, le)) =
		 if n >= max then raise too_big else count(n+1, le)
	       | count(n, LT.RAISE le) =
		 if n >= max then raise too_big else count(n+1, le)
	       | count(n, LT.HANDLE(le, le', _)) =
		 if n >= max then raise too_big else
		   count(count(n+1, le), le')
	       | count(n, LT.BUILTIN _) = if n >= max then raise too_big else n+1

	     and count_opt(n, LT.Option.ABSENT) = n
	       | count_opt(n, LT.Option.PRESENT le) = count(n, le)

	     and count_tag(n, (tag, le)) =
	       count((case tag of
			LT.EXP_TAG le => count(n, le)
		      | _ => n), le)
	   in
	     (count(0, le); true) handle too_big => false
	   end

	  (*  Apply Optimisations  *)


	 fun check_for_app_fn(LT.VAR _) = false
	   | check_for_app_fn(LT.FN(_, le, _, _,_)) = check_for_app_fn le
	   | check_for_app_fn(LT.LET((_,_,lb),le)) =
	     check_for_app_fn lb orelse check_for_app_fn le
	   | check_for_app_fn(arg as LT.LETREC(_, le_list, le)) =
	     check_for_app_fn le orelse
	     (Lists.exists check_for_app_fn le_list)
	   | check_for_app_fn(LT.APP(LT.FN _, le', _)) = true
	   | check_for_app_fn(LT.APP(le, lel, _)) =
	     check_for_app_fn le orelse Lists.exists check_for_app_fn lel
	   | check_for_app_fn(LT.SCON _) = false
	   | check_for_app_fn(LT.MLVALUE _) = false
	   | check_for_app_fn(LT.INT _) = false
	   | check_for_app_fn(LT.SWITCH(le, _, tag_le_list, leo)) =
	     check_for_app_fn le orelse
	     check_for_app_fn_opt leo orelse
	     Lists.exists check_for_app_fn_tag_exp tag_le_list
	   | check_for_app_fn(LT.STRUCT (le_list,_)) = Lists.exists check_for_app_fn le_list
	   | check_for_app_fn(LT.SELECT(field, le)) = check_for_app_fn le
	   | check_for_app_fn(LT.RAISE le) = check_for_app_fn le
	   | check_for_app_fn(LT.HANDLE(le, le', _)) =
	     check_for_app_fn le orelse check_for_app_fn le'
	   | check_for_app_fn(LT.BUILTIN _) = false

	 and check_for_app_fn_tag_exp(tag, le) =
	   check_for_app_fn le orelse
	   (case tag of
	      LT.EXP_TAG le => check_for_app_fn le
	    | _ => false)

	 and check_for_app_fn_opt(LT.Option.PRESENT le) = check_for_app_fn le
	   | check_for_app_fn_opt _ = false

	 fun remove_app_fn expr =
	   if check_for_app_fn expr then
	     let
	       val info = get_info expr
	       val expr = make_beta_reducer info expr
	     in
	       remove_app_fn expr
	     end
	   else
	     expr

	 fun do_middle_optimisations(info, input) =
	   let
(*
	     val _ = output(std_out, "Initial expression\n")
	     val _ = print_lam print_options input
*)
	     val first_function = make_inter_contraction_optimiser info
	     val first_result = first_function input
	     val first_info = get_info first_result

	     val second_function = make_contraction_optimiser first_info
	     val second_result = second_function first_result
	     val second_info = get_info second_result
	     val res = (second_info, second_result)
(*
	     val _ = output(std_out, "Final expression\n")
	     val _ = print_lam print_options second_result
	     val _ =
	       output(std_out, "Size of input = " ^
		      MLWorks.Integer.makestring(LS.size_of_expr input) ^ "\n")
	     val _ =
	       output(std_out, "Size of result = " ^
		      MLWorks.Integer.makestring(LS.size_of_expr second_result) ^ "\n")
*)
	   in
	     if count_expr second_result andalso
	       LS.size_of_expr input > LS.size_of_expr second_result then
	       ((*output(std_out, "Retrying middle optimisations with new size " ^
		       MLWorks.Integer.makestring(LS.size_of_expr second_result) ^ "\n");*)
		do_middle_optimisations res)
	     else
	       res
	   end

	 val phase1_result = phase1_function expression
	 val phase1_info   = get_info phase1_result

	 val (phase2_info, phase2_result) =
	   do_middle_optimisations(phase1_info, phase1_result)

	 val phase3_function = make_contraction_optimiser phase2_info
	 val phase3_result = phase3_function phase2_result

	 (*  Put in a loop to remove all APP-FN into LETs *)
	 val phase3_result = remove_app_fn phase2_result

	 val phase3_info = get_info phase3_result

	 val phase4_function = make_lifting_optimiser phase3_info
	 val phase4_result = phase4_function phase3_result

(*
	  val _ = if (!show_lambda_code)
		     then LambdaPrint.print_info (get_info phase4_result)
		  else ()
*)

	  fun string_of_size expr = MLWorks.Integer.makestring(LS.size_of_expr expr)

(*
	  val _ = if (!show_debug_info) then Print.print
	       ("\n         Lambda Optimiser Report:\n"^
		   "         -----------------------\n"^
		   "    Size of original expression:    "^
		   (string_of_size expression)^"\n"^
		   "    Size of phase 1 expression:     "^
		   (string_of_size phase1_result)^"\n"^
		   "    Size of phase 2 expression:     "^
		   (string_of_size phase2_result)^"\n"^
		   "    Size of phase 3 expression:  "^
	           (string_of_size phase3_result)^"\n"^
		   "    Size of phase 4 expression:     "^
		   (string_of_size phase4_result)^"\n"^
		   "    Reduced by :                    "^
		   (MLWorks.Integer.makestring 
		    (floor
		     (real(floor((real 1000) * 
				 (real((LS.size_of_expr expression)
				       - (LS.size_of_expr phase4_result))
				  /(real(LS.size_of_expr expression)))))
		      /(real 10)))
		    )
		   ^"%\n")
		  else ()
*)
       in
	  phase4_result
       end
    end;
      

  (***********************)
  (*  Things for Export  *)
  (***********************)

  (*  Heuristic Parameters  *)

  val max_struct_dup   = OptimiseBeta.max_struct_dup
  val max_scon_space   = OptimiseBeta.max_scon_space
  val max_func_dup     = OptimiseBeta.max_func_dup
  val code_node_factor = OptimiseBeta.code_node_factor
  val max_map_fold     = OptimiseBuiltin.max_map_fold_length


  val optimise_switches = map (fn(name,switch,_)=>(name,switch)) 
     			  (initial_optimisations @@
			   contraction_optimisations @@
			   inter_contraction_optimisations @@
			   lifting_optimisations)
  
  val optimise = do_all_optimisations

  val simple_beta_reduce = curry (OptimiseBeta.heuristic_beta_reduce false)
    				OptimiseBeta.basic_info

  fun turn_on_all()  = (map (fn(_,x)=>x:=true) optimise_switches; ())
  fun turn_off_all() = (map (fn(_,x)=>x:=false) optimise_switches; ())

end
@


1.65
log
@Abstraction of debug information in lambdatypes
@
text
@d4 3
d397 1
a397 1
	       | count(n, LT.LET(_,_,lb,le)) =
d415 1
a415 1
	       | count(n, LT.STRUCT le_list) =
d442 1
a442 1
	   | check_for_app_fn(LT.LET(_,_,lb,le)) =
d457 1
a457 1
	   | check_for_app_fn(LT.STRUCT le_list) = Lists.exists check_for_app_fn le_list
@


1.64
log
@Multiple function parameters
@
text
@d4 3
d394 1
a394 1
	       | count(n, LT.LET(_,lb,le)) =
d439 1
a439 1
	   | check_for_app_fn(LT.LET(_,lb,le)) =
@


1.63
log
@Do not lambda optimise when compiling for Stepper or Modules Debugger.
@
text
@d4 3
d400 1
a400 1
		   count(count(n+1, le), le')
d442 2
a443 2
	   | check_for_app_fn(LT.APP(le, le', _)) =
	     check_for_app_fn le orelse check_for_app_fn le'
@


1.62
log
@Added an extra optimisation phase between the middle pahse and the lifting
phase. This beta reduces until no APP-FN constructs are left.
@
text
@d4 4
d298 2
a299 1
		     Options.COMPILEROPTIONS{intercept, debug, debug_polyvariables, ...}, ...})
d303 1
a303 1
         if debug_polyvariables then
a311 1

@


1.61
log
@Added copyright message
@
text
@d4 3
d241 3
d300 2
a301 1
           (initial_optimisations @@
d362 4
d426 45
a507 9
(*
	 val phase3_function = make_contraction_optimiser phase1_info
	 val phase3_result = phase3_function phase1_result
	 val phase3_info = get_info phase3_result

	 val phase2_function = make_inter_contraction_optimiser phase3_info
	 val phase2_result = phase2_function phase3_result
	 val phase2_info = get_info phase2_result
*)
d511 7
a517 3
	 val phase3'_function = make_contraction_optimiser phase2_info
	 val phase3'_result = phase3'_function phase2_result
	 val phase3'_info = get_info phase3'_result
d519 2
a520 2
	 val phase4_function = make_lifting_optimiser phase3'_info
	 val phase4_result = phase4_function phase3'_result
d540 2
a541 3
		   "    Size of phase 3,3' expression:  "^
		   (string_of_size phase3_result)^","^
	           (string_of_size phase3'_result)^"\n"^
@


1.60
log
@Pass recipe-generation compiler option to optimiser.
@
text
@d4 3
a80 6
(*
 * Lambda-Calculus Optimisation: _lambdaoptimiser
 * Main Control Module
 *
 * Copyright (c) 1991 Harlequin Ltd.
 *)
@


1.59
log
@Switch off optimisations for polymorphic debugger;
FNs now passed closed-over type variables and stack
frame-offset for runtime-instance for polymorphic debugger.
@
text
@d4 5
d214 2
a215 2
     val mega_beta_reduce = curry OptimiseBeta.heuristic_beta_reduce
     val rearrange_and_fold = curry OptimiseBuiltin.rearrange_arithmetic
d220 1
a220 1
     fun inlinesub (info,expr) = (* function used to reduce inlined forms *)
d224 2
a225 2
	  (rearrange_and_fold info) o
	  (mega_beta_reduce info)) expr
d227 4
a230 2
     and inline i e = OptimiseBeta.function_inline inlinesub (i,e)
     val fold_constants = curry (OptimiseBuiltin.fold_constants inlinesub)
d235 3
a237 3
     [("initial_letrec_elim",      ref true, letrec_elim),
      ("initial_beta_reduce",      ref true, fn _ => beta_reduce),
      ("initial_mega_beta_reduce", ref true, mega_beta_reduce)];
d242 3
a244 3
    [("inter_mega_beta_reduce", ref true, mega_beta_reduce),
     ("inter_letrec_elim",      ref true, letrec_elim),
     (inline_name,              ref true, inline)];
d248 8
a255 8
     [("mega_beta_reduce", ref true, mega_beta_reduce),
      ("raise_cut",        ref true, raise_cut),
      ("struct_elim",      ref true, struct_elim),
      ("switch_elim",      ref true, switch_elim),
      ("switch_weed",      ref true, switch_weed),
      ("select_elim",      ref true, select_elim),
      ("rearrange",        ref true, rearrange_and_fold),
      ("fold_constants",   ref true, fold_constants)];
d260 4
a263 4
     [("lifting",          ref true, lift_expressions),
      ("cse",              ref true, cse),
      ("letrec_elim",      ref true, letrec_elim),
      ("final_switch_elim",      ref true, switch_elim)
d291 1
a291 1
		     Options.COMPILEROPTIONS{intercept, debug_polyvariables, ...}, ...})
d303 1
d346 1
a346 1
	   (P name (func info))
d536 1
a536 1
  val simple_beta_reduce = curry OptimiseBeta.heuristic_beta_reduce 
@


1.58
log
@structure Option.
@
text
@d4 3
d284 1
a284 1
		     Options.COMPILEROPTIONS{intercept, ...}, ...})
d287 9
d366 1
a366 1
	       | count(n, LT.FN(_, le, _, _)) =
@


1.58.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.58  1993/07/14  10:21:45  nosa
structure Option.

@


1.57
log
@Reinstated constant folding
@
text
@d4 3
d385 2
a386 2
	     and count_opt(n, LT.ABSENT) = n
	       | count_opt(n, LT.PRESENT le) = count(n, le)
@


1.56
log
@Removed integer parameter
@
text
@d4 3
d241 2
a242 3
      ("rearrange",        ref true, rearrange_and_fold)];
     
(*      ("fold_constants",   ref true, fold_constants)    *)
@


1.55
log
@Changed contraction optimisations to optimise unitl done for small expressions
@
text
@d4 3
a73 2
require "../utils/integer";

a86 1
  structure Integer          : INTEGER
d281 1
a281 1
			      (Integer.makestring 
d309 1
a309 1
				       (Integer.makestring
d412 1
a412 1
		      Integer.makestring(LS.size_of_expr input) ^ "\n")
d415 1
a415 1
		      Integer.makestring(LS.size_of_expr second_result) ^ "\n")
d421 1
a421 1
		       Integer.makestring(LS.size_of_expr second_result) ^ "\n");*)
d455 1
a455 1
	  fun string_of_size expr = Integer.makestring(LS.size_of_expr expr)
d473 1
a473 1
		   (Integer.makestring 
@


1.54
log
@Made intercept option turn off inlining
@
text
@d4 3
d272 2
d344 47
d393 9
a401 2
	  val phase1_result = phase1_function expression
	  val phase1_info   = get_info phase1_result
d403 23
a425 3
	  val phase3_function = make_contraction_optimiser phase1_info
	  val phase3_result = phase3_function phase1_result
	  val phase3_info = get_info phase3_result
d427 2
a428 3
	  val phase2_function = make_inter_contraction_optimiser phase3_info
	  val phase2_result = phase2_function phase3_result
	  val phase2_info = get_info phase2_result
d430 4
a433 3
	  val phase3'_function = make_contraction_optimiser phase2_info
	  val phase3'_result = phase3'_function phase2_result
	  val phase3'_info = get_info phase3'_result
d435 6
a440 2
	  val phase4_function = make_lifting_optimiser phase3'_info
	  val phase4_result = phase4_function phase3'_result
d442 7
d457 1
d483 1
@


1.53
log
@Options & Info changes
@
text
@d4 3
d218 1
a218 1
      ("initial_mega_beta_reduce",   ref true, mega_beta_reduce)];
d220 2
d224 2
a225 2
     ("inter_letrec_elim", ref true, letrec_elim),
     ("inline",                 ref true, inline)];
d269 4
a272 1
  fun do_all_optimisations print_options expression =
d314 5
a318 3
       fun turn_on info (name,flag,func) = if !flag 
					      then (P name (func info))
					   else I
@


1.52
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d107 1
a107 1
  structure Info = LambdaPrint.Info
d264 1
a264 1
  fun do_all_optimisations options expression =
d300 1
a300 1
				   then print_lam options x'
@


1.51
log
@Added final switch elimination pass to deal with cases exposed by letrec
elimination.  This should remove the need for _mir_cg to deal with
switches on integers, among other things.
@
text
@d4 5
d103 1
d260 1
a260 1
  fun do_all_optimisations expression =
d296 1
a296 1
				   then print_lam x'
@


1.50
log
@Added some LETREC optimisation
@
text
@d4 3
d229 3
a231 1
      ("letrec_elim",      ref true, letrec_elim)];
@


1.49
log
@Replaced float constants by calls to "real"
@
text
@d4 3
d206 1
@


1.48
log
@Removed some redundant structures and sharing
@
text
@d4 3
d355 1
a355 1
		     (real(floor(1000.0 * 
d359 1
a359 1
		      /10.0))
@


1.47
log
@Modified to use the new hashtables
@
text
@d4 3
d88 1
a88 1
  structure Set = LambdaSub.Set
@


1.46
log
@Configuration.
@
text
@d4 3
d86 2
@


1.45
log
@Configuration.
@
text
@d4 3
d168 1
a168 2
     val rearrange = curry OptimiseBuiltin.rearrange_arithmetic
     val reorder_apps = specialK OptimiseBeta.reorder_apps
d174 5
a178 8
        (beta_reduce o
	 (curry (OptimiseBuiltin.fold_constants inlinesub) info) o
	 (select_elim info) o
	 (switch_elim info) o
	 (raise_cut info) o
	 OptimiseBeta.reorder_apps o
	 (rearrange info) o
	 (beta_reduce)) expr
d186 3
a188 3
     [("rearrange",                ref true, rearrange),
      ("initial_letrec_elim",      ref true, letrec_elim),
      ("initial_beta_reduce",      ref true, fn _ => beta_reduce)];
a196 1
      ("reorder_apps",     ref true, reorder_apps),
d202 3
a204 1
      ("fold_constants",   ref true, fold_constants)];
@


1.44
log
@Minor alterations to configuration.
@
text
@d4 3
d39 1
a39 1
require "optimise_lib";
d46 1
d54 2
a55 1
  structure OptimiseLib      : OPTIMISE_LIB
d63 1
d65 1
a65 3
  structure Timer : TIMER

  sharing OptimiseLib.LT 
a73 3
  structure LT = OptimiseLib.LT
  structure LS = OptimiseLib.LS
  infix mem == ++ --
d75 12
a87 2
   
  fun curry f x y = f(x,y)
a88 1
  structure LambdaTypes = LT
d90 7
d160 1
d172 1
a172 1
        ((beta_reduce info) o
d178 2
a179 1
	 (beta_reduce info)) expr
d189 1
a189 1
      ("initial_beta_reduce",      ref true, beta_reduce)];
d202 1
@


1.43
log
@Changed default value of flags to false.
@
text
@d4 3
@


1.42
log
@Added LET constructor and new slot to APP.
Further experiments with configuration.
(still needs adjustment).
@
text
@d4 5
d80 4
a83 4
  val show_optimisations_applied = ref true;
  val show_lambda_code = ref true;
  val show_timings = ref true;
  val check_validity = ref true;
d296 1
d300 1
@


1.41
log
@(Provisionally) altered configuration to perform a fixed
number of iterations of the optimisation functions (just
two presently).
@
text
@d4 5
d78 1
d129 1
a130 1

d138 6
a143 1
     fun specialK f (info:LT.LambdaInfo) = f
d153 3
d160 1
a160 2
     [("rearrange",                ref true, 
       curry OptimiseBuiltin.rearrange_arithmetic),
d165 3
a167 2
    [("mega_beta_reduce", ref true, curry OptimiseBeta.heuristic_beta_reduce),
     ("inline",           ref true, curry (OptimiseBeta.function_inline inlinesub))];
d170 2
a171 2
     [("mega_beta_reduce", ref true, curry OptimiseBeta.heuristic_beta_reduce),
      ("reorder_apps",     ref true, specialK OptimiseBeta.reorder_apps),
d176 2
a177 1
      ("fold_constants",   ref true, curry (OptimiseBuiltin.fold_constants inlinesub))];
d181 2
a182 2
     [("lifting",          ref true, OptimiseLift.lift_expressions),
      ("cse",              ref true, OptimiseCSE.eliminate_common_subexprs),
d219 1
d228 7
d344 1
@


1.40
log
@LambdaExp is no longer an equality type, so replaced calls to = with LS.lambda_equality
@
text
@d4 3
a9 146
Revision 1.38  1992/03/27  13:39:25  jont
Added Print and Integer parameters to functor. Removed instances
of pervasive print and makestring

Revision 1.37  1992/01/31  11:50:16  clive
Modified to use the new timer module

Revision 1.36  1992/01/03  12:34:16  jont
Redid the call to struct_elim to use apply_innermost_with_context

Revision 1.35  1991/11/22  17:48:04  jont
Removed opens

Revision 1.34  91/10/24  14:34:10  davidt
raise_cut now works in a single pass to avoid a lot of needless
recalculation incurred by analysing each level of the tree separately.

Revision 1.33  91/10/22  18:24:06  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.32  91/10/22  12:54:17  davidt
Took out imposs function and exception impossible.

Revision 1.31  91/09/24  14:35:12  davida
Made function used by in-liner more complex,
reorganised structure a little. 

Revision 1.30  91/09/16  12:43:06  davida
Removed report switch, added timing, added raise_cut,
turn_on_all and turn_off_all.

Revision 1.29  91/09/12  15:53:45  davida
Added initial optimisation phase, and new
display flags

Revision 1.28  91/09/10  16:00:02  davida
Added info printing, new inlining optimisation.

Revision 1.27  91/09/09  16:51:44  davida
New version to cope with reorganised sources.

Revision 1.26  91/09/04  14:46:18  davida
oops

Revision 1.25  91/09/04  14:38:57  davida
Added to & fixed single-branch case in Switch-Elimination.

Revision 1.24  91/09/04  11:13:47  davida
Added simple beta reduce function for export.

Revision 1.23  91/09/02  15:08:22  davida
Added test to eta-reduction at last to ensure that
the result function is a shiftable expression, so
that it doesn't matter when it's evaluated.  Why was
I convinced this wasn't necessary before?  Not sure,
perhaps we got caught up in the fallacy that it wouldn't
matter, because it would still not be evaluated until
application time.  Not true!!

Revision 1.22  91/08/27  16:29:17  davida
Removed select_lift

Revision 1.21  91/08/27  08:51:19  davida
Corrected replacing of non-shiftable expressions
that appear only once in a function body
(Ensuring that they are replaced only if evaluated before
 all other non-shiftables, and _are_ evaluated -- this
is tricky).  Altered form of debug switches.

Revision 1.20  91/08/19  17:02:31  davida
Invokes constant folding (not quite in the
right place at the mo, mind).

Revision 1.19  91/08/13  17:08:34  davida
fn_substitute heuristic wasn't quite right: we revert to
not substituting multiple functions at all for the time
being.  Ideally, renaming needs to be done at the heart
of the beta-reduction...

Revision 1.18  91/08/09  18:56:11  davida
Major addition is switch-folding on constant
valued switch expressions.

Revision 1.17  91/08/06  16:13:01  davida
Re-organized and added second phase of optimisation
(which involves beta-abstracting again, cse etc).

Revision 1.16  91/08/02  17:48:14  davida
Added expression size diagnostics, and select-elimination
on LETREC's.

Revision 1.15  91/08/02  10:02:36  davida
Removed superfluous argument from top-level optimise
function, at last!

Revision 1.14  91/07/31  19:55:31  davida
Added free variable check in eta-reduction (oops)

Revision 1.13  91/07/31  14:48:49  davida
Added struct_elim to eliminate re-generated structures,
and also beta-reduction on multiply appearing constant
functions and select operations.  NB!! These two will
conflict with CSE!

Revision 1.12  91/07/30  18:59:52  davida
Begun evaluation-order checks and sorted out struct-breakup
to give nested app/fn's instead of curried functions.

Revision 1.11  91/07/29  17:23:46  davida
Major restructuring for beta-reduction, and talk of
shiftable expressions.  Added new "optimisation"
which may be removed later - reorder_apps to remove curried
applications of explicit functions  (which in all likelihood
get beta-reduced anyway...)

Revision 1.10  91/07/25  15:07:08  davida
Beta-reduction of structure args done more generally via beta-reduction.

Revision 1.9  91/07/24  13:59:35  davida
More SWITCH eliminations, changed functor arguments and lambdasub

Revision 1.8  91/07/22  14:39:14  davida
Trivial change.

Revision 1.7  91/07/17  13:17:04  davida
Beta-reduction now performs expansive expression test.

Revision 1.6  91/07/17  10:05:38  davida
Altered to conform with changed version of Lambdasub.

Revision 1.5  91/07/15  16:38:26  davida
Updated for new module LambdaSub

Revision 1.4  91/07/12  13:44:47  davida
Added missing STRUCT clause to lvar_occurrences

Revision 1.3  91/07/11  12:44:26  davida
Altered for new LETREC form.

Revision 1.2  91/07/10  14:07:09  davida
Added SELECT optimisation.

Revision 1.1  91/07/09  12:34:12  davida
Initial revision

d36 1
a36 1
  structure Integer            : INTEGER
d63 2
d99 1
a99 1
  fun repeat_contract build_opt_fn =
d101 1
a101 1
	fun repeat expr =
d106 3
a108 3
	      if LS.lambda_equality(opt_expr,expr)
		 then (opt_expr, optinfo)
	      else repeat opt_expr
d111 1
a111 1
	repeat
a123 2
     (* eventually, these optimisations should be combined into a single *)
     (* tree pass, by composing them them and using apply inner/outer    *)
d126 1
a126 1
     val eta_reduce  = fn info => AI (OptimiseContract.eta_reduce  info)
a131 7
     (*
      * raise_cut works in a single pass to avoid a lot of needless
      * recalculation incurred by analysing each level of the tree separately.
      *)

     val raise_cut = OptimiseContract.raise_cut

d134 8
a141 10
     val inlinesub = (* function used to reduce inlined forms *)
	fn expr => 
          OptimiseLib.fst (repeat_contract
                           (fn info => 
                            ((OptimiseBuiltin.fold_constants info) o
                             (switch_elim info) o
                             (raise_cut info) o
                             OptimiseBeta.reorder_apps o
                             (OptimiseBeta.heuristic_beta_reduce info)))
                           expr)
d146 8
a153 2
     [("initial_beta_reduce",      ref true, beta_reduce),
      ("initial_letrec_elim",      ref true, letrec_elim)];
d156 1
a156 3
     [("letrec_elim",      ref true, letrec_elim),
      ("mega_beta_reduce", ref true, OptimiseBeta.heuristic_beta_reduce),
      ("eta_reduce",       ref true, eta_reduce),
d162 1
a162 3
      ("fold_constants",   ref true, OptimiseBuiltin.fold_constants),
      ("rearrange",        ref true, OptimiseBuiltin.rearrange_arithmetic),
      ("inline",           ref true, OptimiseBeta.function_inline inlinesub)]
d164 1
d167 2
a168 1
      ("common_subexpr",   ref true, OptimiseCSE.eliminate_common_subexprs)]
d170 18
d195 2
a196 1
			      (Integer.makestring (LS.size_of_expr expression)))
d200 2
d217 1
a217 1
				       "...");
d230 2
a231 1
	  fn i=>Lists.reducel (op o) (I, map (turn_on i) initial_optimisations)
d233 4
d238 2
a239 1
	  fn i=>Lists.reducel (op o) (I, map (turn_on i) contraction_optimisations)
d242 1
a242 1
	  fn i=>Lists.reducel (op o) (I, map (turn_on i) lifting_optimisations)
d245 1
a245 1
       val phase2_function = repeat_contract make_contraction_optimiser
d250 2
a251 1
	  val phase1 = phase1_function expression
d253 3
a255 1
	  val (phase2,opt_info) = phase2_function phase1
d257 11
d269 1
a269 1
		     then LambdaPrint.print_info opt_info
d272 1
a272 1
	  val phase3 = (make_lifting_optimiser opt_info phase2)
d278 1
a278 2
		   (Integer.makestring
		    (LS.size_of_expr expression))^"\n"^
d280 1
a280 2
		   (Integer.makestring
		    (LS.size_of_expr phase1))^"\n"^
d282 6
a287 5
		   (Integer.makestring
		    (LS.size_of_expr phase2))^"\n"^
		   "    Size of phase 3 expression:     "^
		   (Integer.makestring
		    (LS.size_of_expr phase3))^"\n"^
d293 1
a293 1
				       - (LS.size_of_expr phase3))
d300 1
a300 1
	  phase3
d325 2
a326 2
  val simple_beta_reduce = OptimiseBeta.heuristic_beta_reduce 
						OptimiseBeta.basic_info
@


1.39
log
@Modified a few calls to isolate the state in other functions to allow the use of hash table
@
text
@d4 3
d247 1
a247 1
	      if (opt_expr = expr)
d340 1
a340 1
			 (if x' = x then ()
@


1.38
log
@Added Print and Integer parameters to functor. Removed instances
of pervasive print and makestring
@
text
@d4 4
d265 1
a265 1
     val beta_reduce = fn info => AI (OptimiseContract.beta_reduce info)
d283 8
a290 8
	OptimiseLib.fst (repeat_contract
	     (fn info => 
	      ((OptimiseBuiltin.fold_constants info) o
	       (switch_elim info) o
	       (raise_cut info) o
	       OptimiseBeta.reorder_apps o
	       (OptimiseBeta.heuristic_beta_reduce info)))
	     expr)
a428 4

  val very_simple_beta_reduce = 
     LS.apply_outermost (OptimiseContract.beta_reduce 
			 OptimiseBeta.basic_info)
@


1.37
log
@Modified to use the new timer module
@
text
@d4 3
d157 2
d169 10
a178 8
functor LambdaOptimiser
  (structure Lists            : LISTS
   structure OptimiseLib      : OPTIMISE_LIB
   structure OptimiseContract : OPTIMISE_CONTRACT
   structure OptimiseBuiltin  : OPTIMISE_BUILTIN
   structure OptimiseBeta     : OPTIMISE_BETA
   structure OptimiseCSE      : OPTIMISE_CSE
   structure OptimiseLift     : OPTIMISE_LIFT
d180 1
a180 1
   structure LambdaPrint : LAMBDAPRINT
d182 1
a182 1
   structure Timer : TIMER
d184 8
a191 7
   sharing OptimiseLib.LT 
     = OptimiseContract.LT
     = OptimiseBuiltin.LT
     = OptimiseCSE.LT
     = OptimiseBeta.LT
     = OptimiseLift.LT
     = LambdaPrint.LambdaTypes) : LAMBDAOPTIMISER =
d202 1
a202 1
  fun info message = if !show_debug_info then print message else ()
d317 2
a318 2
		  then print ("size of original expression: "^
			      (makestring (LS.size_of_expr expression)))
d334 2
a335 2
			  else (print ("after "^s^", size of expr = "^
				       (makestring
d374 1
a374 1
	  val _ = if (!show_debug_info) then print
d378 1
a378 1
		   (makestring
d381 1
a381 1
		   (makestring
d384 1
a384 1
		   (makestring
d387 1
a387 1
		   (makestring
d390 8
a397 6
		   (makestring 
		    (real(floor(1000.0 * 
				(real((LS.size_of_expr expression)
				      - (LS.size_of_expr phase3))
				 /(real(LS.size_of_expr expression)))))
		     /10.0))
@


1.36
log
@Redid the call to struct_elim to use apply_innermost_with_context
@
text
@d4 3
d153 1
d175 1
a175 1
   val time_it : string * (unit -> 'a) -> 'a
d322 1
a322 1
				     then time_it(s, fn () => f x)
@


1.35
log
@Removed opens
@
text
@d3 4
a6 1
$Log:	_lambdaoptimiser.sml,v $
d244 1
d251 1
a251 1
     val struct_elim = fn info => AI (OptimiseContract.struct_elim info)
@


1.34
log
@raise_cut now works in a single pass to avoid a lot of needless
recalculation incurred by analysing each level of the tree separately.
@
text
@d1 6
d8 131
d178 2
a179 1
  open OptimiseLib
d263 1
a263 1
	fst (repeat_contract
d418 1
a418 141
end;




(*
$Log:	_lambdaoptimiser.sml,v $
Revision 1.33  91/10/22  18:24:06  davidt
Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.

Revision 1.32  91/10/22  12:54:17  davidt
Took out imposs function and exception impossible.

Revision 1.31  91/09/24  14:35:12  davida
Made function used by in-liner more complex,
reorganised structure a little. 

Revision 1.30  91/09/16  12:43:06  davida
Removed report switch, added timing, added raise_cut,
turn_on_all and turn_off_all.

Revision 1.29  91/09/12  15:53:45  davida
Added initial optimisation phase, and new
display flags

Revision 1.28  91/09/10  16:00:02  davida
Added info printing, new inlining optimisation.

Revision 1.27  91/09/09  16:51:44  davida
New version to cope with reorganised sources.

Revision 1.26  91/09/04  14:46:18  davida
oops

Revision 1.25  91/09/04  14:38:57  davida
Added to & fixed single-branch case in Switch-Elimination.

Revision 1.24  91/09/04  11:13:47  davida
Added simple beta reduce function for export.

Revision 1.23  91/09/02  15:08:22  davida
Added test to eta-reduction at last to ensure that
the result function is a shiftable expression, so
that it doesn't matter when it's evaluated.  Why was
I convinced this wasn't necessary before?  Not sure,
perhaps we got caught up in the fallacy that it wouldn't
matter, because it would still not be evaluated until
application time.  Not true!!

Revision 1.22  91/08/27  16:29:17  davida
Removed select_lift

Revision 1.21  91/08/27  08:51:19  davida
Corrected replacing of non-shiftable expressions
that appear only once in a function body
(Ensuring that they are replaced only if evaluated before
 all other non-shiftables, and _are_ evaluated -- this
is tricky).  Altered form of debug switches.

Revision 1.20  91/08/19  17:02:31  davida
Invokes constant folding (not quite in the
right place at the mo, mind).

Revision 1.19  91/08/13  17:08:34  davida
fn_substitute heuristic wasn't quite right: we revert to
not substituting multiple functions at all for the time
being.  Ideally, renaming needs to be done at the heart
of the beta-reduction...

Revision 1.18  91/08/09  18:56:11  davida
Major addition is switch-folding on constant
valued switch expressions.

Revision 1.17  91/08/06  16:13:01  davida
Re-organized and added second phase of optimisation
(which involves beta-abstracting again, cse etc).

Revision 1.16  91/08/02  17:48:14  davida
Added expression size diagnostics, and select-elimination
on LETREC's.

Revision 1.15  91/08/02  10:02:36  davida
Removed superfluous argument from top-level optimise
function, at last!

Revision 1.14  91/07/31  19:55:31  davida
Added free variable check in eta-reduction (oops)

Revision 1.13  91/07/31  14:48:49  davida
Added struct_elim to eliminate re-generated structures,
and also beta-reduction on multiply appearing constant
functions and select operations.  NB!! These two will
conflict with CSE!

Revision 1.12  91/07/30  18:59:52  davida
Begun evaluation-order checks and sorted out struct-breakup
to give nested app/fn's instead of curried functions.

Revision 1.11  91/07/29  17:23:46  davida
Major restructuring for beta-reduction, and talk of
shiftable expressions.  Added new "optimisation"
which may be removed later - reorder_apps to remove curried
applications of explicit functions  (which in all likelihood
get beta-reduced anyway...)

Revision 1.10  91/07/25  15:07:08  davida
Beta-reduction of structure args done more generally via beta-reduction.

Revision 1.9  91/07/24  13:59:35  davida
More SWITCH eliminations, changed functor arguments and lambdasub

Revision 1.8  91/07/22  14:39:14  davida
Trivial change.

Revision 1.7  91/07/17  13:17:04  davida
Beta-reduction now performs expansive expression test.

Revision 1.6  91/07/17  10:05:38  davida
Altered to conform with changed version of Lambdasub.

Revision 1.5  91/07/15  16:38:26  davida
Updated for new module LambdaSub

Revision 1.4  91/07/12  13:44:47  davida
Added missing STRUCT clause to lvar_occurrences

Revision 1.3  91/07/11  12:44:26  davida
Altered for new LETREC form.

Revision 1.2  91/07/10  14:07:09  davida
Added SELECT optimisation.

Revision 1.1  91/07/09  12:34:12  davida
Initial revision


David R. Aspinall.

Copyright (c) 1991 Harlequin Ltd.
*)
@


1.33
log
@Put in an explicit Lists structure instead of having it
implicit opened in the LambdaSub structure.
@
text
@a112 1
     val raise_cut   = fn info => AI (OptimiseContract.raise_cut info)
d114 7
d125 7
a131 6
	fst (repeat_contract (fn info => 
			      ((OptimiseBuiltin.fold_constants info) o
			       (switch_elim info) o
			       (raise_cut info) o
			       OptimiseBeta.reorder_apps o
			       (OptimiseBeta.heuristic_beta_reduce info)))
d287 4
@


1.32
log
@Took out imposs function and exception impossible.
@
text
@d2 6
a7 1
(*  Lambda-Calculus Optimisation:  _lambdaoptimiser  *)
d9 1
a9 6
           (*  Main Control Module  *)

    (*  Copyright (c) 1991 Harlequin Ltd. *)



d20 8
a27 7

functor LambdaOptimiser(structure OptimiseLib      : OPTIMISE_LIB
			      and OptimiseContract : OPTIMISE_CONTRACT
			      and OptimiseBuiltin  : OPTIMISE_BUILTIN
			      and OptimiseBeta     : OPTIMISE_BETA
			      and OptimiseCSE      : OPTIMISE_CSE
			      and OptimiseLift     : OPTIMISE_LIFT
d29 1
a29 1
			structure LambdaPrint : LAMBDAPRINT
d31 1
a31 1
			val time_it : string * (unit -> 'a) -> 'a
d33 7
a39 7
			sharing OptimiseLib.LT 
			      = OptimiseContract.LT
			      = OptimiseBuiltin.LT
			      = OptimiseCSE.LT
			      = OptimiseBeta.LT
			      = OptimiseLift.LT
			      = LambdaPrint.LambdaTypes) : LAMBDAOPTIMISER =
d41 2
a43 2
  open OptimiseLib  infix mem == ++ -- (* !!! *)

d189 1
a189 1
	  fn i=>reducel (op o) (I, map (turn_on i) initial_optimisations)
d192 1
a192 1
	  fn i=>reducel (op o) (I, map (turn_on i) contraction_optimisations)
d195 1
a195 1
	  fn i=>reducel (op o) (I, map (turn_on i) lifting_optimisations)
d280 3
@


1.31
log
@Made function used by in-liner more complex,
reorganised structure a little. 
@
text
@a72 3
  exception impossible of string
  fun imposs message = raise impossible message

d279 4
@


1.30
log
@Removed report switch, added timing, added raise_cut,
turn_on_all and turn_off_all.
@
text
@a77 1

d82 14
d119 9
a127 10
     fun optsub expr = (* function used to reduce inlined forms *)
	let
	   val info = OptimiseBeta.basic_info
	in 
	   fixpoint (op=) (((OptimiseBuiltin.fold_constants info) o
			    (switch_elim info) o
			    OptimiseBeta.reorder_apps o
			    (OptimiseBeta.heuristic_beta_reduce info)),
			   expr)
	end
d146 1
a146 1
      ("inline",           ref true, OptimiseBeta.function_inline optsub)]
a197 1
	  
d199 2
a200 10
       fun repeat_contract (expr,n) = 
	  let 
	     val optinfo = OptimiseBeta.process_expr expr
	     val opt_expr = (make_contraction_optimiser optinfo) expr
	  in 
	     if (opt_expr = expr)
		then (opt_expr, n, optinfo)
	     else repeat_contract (opt_expr, n+1)
	  end

d205 1
a205 2
	  val phase1 = (make_initial_optimiser (OptimiseBeta.basic_info)
			expression)
d207 1
a207 1
	  val (phase2,times,opt_info) = repeat_contract (phase1,0)
a217 2
		   "    Number of contraction cycles:   "^
		   (makestring times)^"\n"^
d282 4
@


1.29
log
@Added initial optimisation phase, and new
display flags
@
text
@d30 2
d52 1
a52 1
  val show_optimisation_report = ref true;
d57 1
a57 1
	 show_lambda_code, show_optimisation_report,
d102 1
d128 1
d158 3
a160 1
			 val x' = f x
d211 1
a211 1
	  val phase3 = (make_lifting_optimiser opt_info phase1)
d213 1
a213 3


	  val _ = if (!show_optimisation_report) then print
d240 1
a240 1
	  phase2
d272 3
d282 4
@


1.28
log
@Added info printing, new inlining optimisation.
@
text
@d50 1
d52 19
d78 1
a78 1
  (* Apply all Optimisations *)  (* order ?  repeats ? *)
d85 1
a85 2
  (*  the transformations do interact.  The order they are given in is  *)
  (*  the reverse of the order that they will be applied.               *)
d94 1
a94 1
     val beta_reduce = fn info => AO (OptimiseContract.beta_reduce info)
d99 1
d103 1
a103 1
     val optsub = 
d107 5
a111 3
	   (OptimiseBuiltin.fold_constants info) o
	   (switch_elim info) o
	   (OptimiseBeta.heuristic_beta_reduce info)
d114 1
d116 7
a122 2
    val iterated_optimisations =  
     [("reorder_apps",     ref true, specialK OptimiseBeta.reorder_apps),
d124 1
d130 1
a130 3
      ("inline",           ref true, OptimiseBeta.function_inline optsub),
      ("mega_beta_reduce", ref true, OptimiseBeta.heuristic_beta_reduce)]
      (* simpler beta:     ("beta_reduce",      ref true, beta_reduce)   *)
d132 3
a134 3
    val oneshot_optimisations =
     [("common_subexpr",   ref true, OptimiseCSE.eliminate_common_subexprs),
      ("lifting",          ref true, OptimiseLift.lift_expressions)]
d141 6
d172 5
a176 2
       val make_iterated_optimiser = 
	  fn i=>reducel (op o) (I, map (turn_on i) iterated_optimisations)
d178 2
a179 2
       val make_oneshot_optimiser = 
	  fn i=>reducel (op o) (I, map (turn_on i) oneshot_optimisations)
a181 2
       (* iterate & count loop  *)
	  
d184 2
a185 2
	     val info = OptimiseBeta.process_expr expr
	     val opt_expr = (make_iterated_optimiser info) expr
d188 2
a189 2
		then (opt_expr, n-1, info)
	     else repeat_contract (opt_expr,n+1)
d196 1
a196 1
	  val phase0 = (make_iterated_optimiser (OptimiseBeta.basic_info)
d199 1
a199 1
	  val (phase1,times,opt_info) = repeat_contract (phase0,2)
d201 3
a203 2
	  val _ = info ("Optimisation information: \n"^
			LambdaPrint.string_of_info opt_info)
d205 1
a205 1
	  val phase2 = (make_oneshot_optimiser opt_info phase1)
d207 4
a210 2
	  val _ = 
	     info ("\n         Lambda Optimiser Report:\n"^
d217 1
a217 1
		   "    Size of contracted expression:  "^
d220 1
a220 1
		   "    Size of lifted expression:      "^
d223 3
d230 1
a230 1
				      - (LS.size_of_expr phase2))
d233 2
a234 1
		   ^"%\n");
d255 3
a257 1
     			    (iterated_optimisations @@ oneshot_optimisations)
d275 3
@


1.27
log
@New version to cope with reorganised sources.
@
text
@d82 9
d101 1
d150 1
a150 1
	     val info = OptimiseBeta.process_expr expr 
d166 4
a169 1
	     
d173 2
a174 2
	     info ("\n  Lambda Optimiser Report:\n"^
		   "   -----------------------\n"^
a208 1
  val max_curry_body   = OptimiseBeta.max_curry_body
d232 3
@


1.26
log
@oops
@
text
@d1 217
a217 1
(* _lambdaoptimiser.sml the functor *)
d220 3
a328 794

require "../utils/set";
require "../utils/map";
require "../basics/ident";
require "lambdaprint";
require "lambdasub";
require "optimisesub";
require "lambdaoptimiser";

(*********************************************************************)
(*  Various optimisations to the lambda-expressions produced by the  *)
(*  lambda-translator.  Care needs to be taken to ensure semantic    *)
(*  equivalence -- much analysis is done on `shiftable' expressions. *)
(*********************************************************************)

functor LambdaOptimiser( val real_size : int
			 and string_size_fn : string -> int
			 and int_size    : int
			structure Set         : SET
			structure Map         : MAP
			structure Ident       : IDENT
			structure LambdaSub   : LAMBDASUB
			structure OptimiseSub : OPTIMISESUB
			structure LambdaPrint : LAMBDAPRINT
			sharing LambdaSub.LambdaTypes.Ident = Ident
			sharing LambdaSub.Set = Set
			sharing LambdaPrint.LambdaTypes = LambdaSub.LambdaTypes
			         = OptimiseSub.LT
			) : LAMBDAOPTIMISER =
struct

    structure LambdaTypes = LambdaSub.LambdaTypes;
	
    (* Abbreviated names... *)

    structure LS = LambdaSub;
    structure LT = LambdaTypes;


   (**************)
   (* Miscellany *)
   (**************)

    val show_info = true;      (*  false to disable debug output, and  *)    
    val show_code = true;      (*  hopefully eliminate dead-code.      *)


    exception impossible of string;
    fun imposs s = (print ("impossible: "^s);
		    raise impossible s);

    fun select_field fieldlist field =
	(LS.nth (LT.fromField field, fieldlist)
			handle LS.LambdaSubNth => 
			    imposs "select_field: bad SELECT field number!")

    (* aliases for Set functions *)
    val mem = Set.is_member;
    val == = Set.seteq;
    val ++ = Set.add_member;
    val nullset = Set.empty_set;
    infix mem;
    infix ==;
    infix ++;

    fun fst (x,y) = x
    and snd (x,y) = y;

    infix upto;
    fun a upto b = if a>b then [] else a::(a+1 upto b);

    fun length [] = 0
      | length (x::xs) = 1+length xs;

    fun take(0,_) = []
      | take(_,[]) = []
      | take(n,x::xs) = x::(take(n-1,xs));


    fun take_prefix p [] = []
      | take_prefix p (x::xs) = if p x then x::(take_prefix p xs)
				else []

    fun zip (x::xs,y::ys) = (x,y)::(zip (xs,ys))
      | zip ([],[]) = []
      | zip _ = raise LT.impossible "LambdaOptimser: zip"
	
    fun forall P [] = true
      | forall P (x::xs) = (P x) andalso forall P xs;

    fun info s = if show_info
		     then print ("Lambda Optimiser: "^s)
		 else ();

    fun display s = if show_code
			then print s
		    else ();

    val makestring_lam = LambdaPrint.string_of_lambda;
    val print_lam = LambdaPrint.print_lambda;


  (*****************)
  (* OPTIMIZATIONS *)
  (*****************)

  (************************)
  (* Shared Sub-Functions *)
  (************************)



  (*  Beta-reduction -- eliminates lambda-variables  *)
  

  (*  Beta-reduction is possible when the function argument is            *)
  (*  shiftable (i.e. can be guaranteed not to reference state, raise an  *)
  (*  exception, or loop forever when evaluated), or when substitution    *)
  (*  will not change the evaluation order or number of times a 	  *)
  (*  non-shiftable argument will be evaluated.  This ensures semantic    *)
  (*  equivalence.   Beta-reductions might be valuable optimisations, so  *)
  (*  some effort is made to analyse user-defined functions to attempt    *)
  (*  to classify them as shiftable.					  *)

  (*  Since beta-redexes are generated mostly from the equivalent of       *)
  (*  let-constructs during translation, and are spotted as such in code-  *)
  (*  generation, the final savings from performing beta-reduction as far  *)
  (*  as possible at this stage may not justify the computational cost of  *)
  (*  doing it.  We will find out if this is the case by experience.       *)


(* Heuristic Measures *)

val max_struct_dup   = ref 500;      (*  space from duplicating structs   *)
val max_scon_space   = ref 500;	     (*  space from duplicating SCON's    *)
val max_func_dup     = ref 500;	     (*  space from duplicating fn's      *)
val max_curry_body   = ref 50;       (*  size of dup'd curry fun bodies   *)
val code_node_factor = 4;            (*  for wintertime, wear balaclavas  *)
val max_map_fold     =               (*  constant folding map list length *)
   OptimiseSub.max_map_fold_length;
				      
    

local 

      fun cost_scon (Ident.INT _) = int_size
	| cost_scon (Ident.REAL _) = real_size
	| cost_scon (Ident.STRING s) = string_size_fn s

      fun cost_all_scons expr =
	  let
	      fun count(cost, LT.SCON s) = cost + cost_scon s
		| count(cost, _) = cost
	  in
	      LS.reduce_outermost count (0,expr)
	  end

      fun cost_expr expr = (LS.size_of_expr expr) * code_node_factor
	  			+ cost_all_scons expr

      fun scon_heuristic(scon,no_of_times) = 
	  (cost_scon scon * no_of_times) < (!max_scon_space)

      fun struct_heuristic(strct,no_of_times) = 
	  (cost_expr strct * no_of_times) < (!max_struct_dup)

      fun fn_heuristic(body,no_of_times) = false   (* ##### *)
	  (* (cost_expr body * no_of_times) < (!max_func_dup) *)



      (*   should_reduce : expr * int -> bool				  *)
      (* 								  *)
      (*  A heuristic function to decide if beta-reduction should be      *)
      (*  performed in the case that the bound-variable appears in the    *)
      (*  body more than once.  In general, this is a compromise between  *)
      (*  the cost of function application at run-time, and the cost of   *)
      (*  evaluating the argument.  Simple cases are when the arg is:     *)
      (*  VAR, SCON, INT, BUILTIN.                                        *)
      (*  (only called with a shiftable argument)			  *)
       
      fun should_reduce(arg,times,(var,body)) = 
	 (case arg of
	      LT.VAR _  => true
	    | LT.BUILTIN _ => true

	    | LT.SCON sc => scon_heuristic(sc,times)

	    | LT.INT i  => scon_heuristic(Ident.INT (makestring i), times)


	    | LT.SELECT _ => true    (* only if abstracted out again later!  *)
				     (* leads to duplication of selects, but *)
				     (* possible elimination of superfluous  *)
				     (* restructuring... THIS IS THE ONLY    *)
				     (* PLACE WHERE BETA-REDUCTION LEADS TO  *)
				     (* COSTLY DUPLICATION & instability with*)
				     (* common-subexpression-elimination.... *)
				     (* It would be better to realise struct *)
				     (* elim in a different way.	     *)

	    | LT.FN(_,fnbody) =>  fn_heuristic(fnbody,times)
				     (* could perhaps check for constant *)
				     (* functions instead, currently may *)
				     (* duplicate LETREC's if we're not  *)
				     (* careful.  !!!!!!!		 *)

	    | _ => false)


      (* breakup_struct: expr * expr * expr list -> expr  	          *)
      (* 								  *)
      (*  Abstracts out a new lambda-variable over each component of a    *)
      (*  structure, producing a nested app-fn expression (like let's).   *)
      (*  Code is a lot more concise to do curried form of this, but      *)
      (*  ensuring nested app's means beta-reduction can be done in one   *)
      (*  go.  Typically this will introduce new beta-redexes, and        *)
      (*  usefully splits apart a structure with a mixture of shiftable   *)
      (*  non-shiftable components.  					  *)

      fun breakup_struct(var, body, fields) =
	  let
	    fun abs_app(expr,(subx,arg)::sas,vars) = 
		let 
		    val (var,expr') = LS.beta_abstract(expr,subx)
		    val expr'' = LT.APP(expr',arg)
		in
		    abs_app(expr'', sas, var::vars)
		end
	      | abs_app(expr,[],vars) = (expr,vars)

	    val size_of_struct = length fields
	    val selects = map LT.toField (0 upto (size_of_struct-1))
	    val args = map (select_field fields) selects
	    val evar = LT.VAR var
	    val sub_exprs = (map (fn field=> LT.SELECT(field,evar)) selects)
	    val (expr,newvars) = abs_app (body,zip(rev sub_exprs,rev args),[])
	    val newstruct = LT.STRUCT(map LT.VAR newvars)
	  in
	       LS.substitute [(var,newstruct)] expr
	  end


      (*  Add bindings for variables to a map, based on the translated  *)
      (*  form of LET expressions.					*)

      fun extend_environment (envir,expr) =
       let
	 fun aug(envir, LT.APP(LT.FN(var,_),arg)) = Map.add((var,arg),envir,
							    LT.LVar_order)
	   | aug(envir, _) = envir
       in
	   LS.reduce_outermost aug (envir,expr)
       end
								 

     (*  Deduce a set of variables corresponding to functions which are  *)
     (*  shiftable when applied to some argument.  Maximal fixed point   *)
     (*  of a monotonic operator job.			 		 *)

      fun shiftable_bodies stuff =
	  let
	      (* fun get_letrecs x = x *)

	      fun shift_bodies(acc, (var, LT.FN(_,body))) =
		  if LS.is_shiftable acc body
		      then var++acc
		  else acc
		| shift_bodies(acc, _) = acc

	      fun iter shiftables =
	       let
		val shiftables' = LS.reduce_left 
					shift_bodies (shiftables, stuff)
	       in
		   if shiftables == shiftables'
		       then shiftables
		   else iter shiftables'
	       end
	  in
	      iter nullset
	  end


in
  fun beta_reduce effort_depth expression =
   let
       val environment =
	   case effort_depth of
	       0 => Map.empty_map
	     | _ => extend_environment (Map.empty_map,expression)

       (* build up a list of shiftable user-functions, plus their *)
       (* definitions...					  *)

       val shiftable_appvars = 
	   case effort_depth of
	       0 => nullset
	     | _ => shiftable_bodies (Map.assoc environment)

       val is_shiftable = LS.is_shiftable shiftable_appvars
       val is_commutative = LS.is_commutative         (* perhaps analysis? *)

    (*  Do some judicious fiddling of commutative operators, etc, etc.   *)
    (*  in order to place all shiftable expressions as early as poss in  *)
    (*  the evaluation order to maximise the chance of being able to     *)
    (*  substitute.  If this seems like a bit of a hack...		 *)
	
    val fiddle_order =
	let
	    fun rearrange (app as LT.APP(func,LT.STRUCT [arg1,arg2])) =
		if is_commutative func
		    andalso is_shiftable arg2
		    andalso not(is_shiftable arg1)
		      then LT.APP(func,LT.STRUCT [arg2,arg1])
		else app
	      | rearrange expr = expr
	in 
	    LS.apply_outermost rearrange
	end
       


      (*  Beta-reduction when the argument is a structure.  This considers  *)
      (*  whether to break up the structure into separate lambda variables. *)
      (*  If the structure is always SELECT'd on in the body, it will be    *)
      (*  broken up.  Otherwise, a heuristic is used to decide based on     *)
      (*  the size of the struct and the number of times it appears in the  *)
      (*  body without an immediate SELECT.				    *)

       fun beta (original as LT.APP(LT.FN(var,body),s as LT.STRUCT fields)) =
	   if LS.occurrences(var,body)>1
	       then 
		   let 
		       val noselects = LS.count_noselects (body,var) 
		   in 
		       if noselects = 0 orelse 
			   (struct_heuristic(s,noselects))
			   then 
			       beta (breakup_struct (var,body,fields))
		       else 
			   beta2 original
		   end
	   else beta2 original
	       
	 | beta e = beta2 e


       (*  BETA-reduction in the more general case.  Recurses to reduce   *)
       (*  the outermost redexes, when the argument is shiftable, or      *)
       (*  substituting it will definitely evaluate it, and do so before  *)
       (*  any other un-shiftable expression is evaluated.		  *)

       and beta2 (original as (LT.APP(LT.FN(var,body),arg))) = 
	   let
	       val occurs = LS.occurrences(var,body)
	       val shiftable = is_shiftable arg
	       fun reduce (arg,body) = beta (LS.substitute [(var,arg)] body)
	   in 
	    if shiftable then
		(case occurs of
		   0 => body

		 | 1 =>  reduce (arg,body)

		 | more => if should_reduce(arg,more,(var,body)) 
			       then reduce (LS.rename_fresh arg, body)
			   else 
			       curry_optimise original)
	    else
	      (case occurs of
		   0 => (info ("non-shiftable isn't in body -"^
			       "can't reduce away "^
			       (makestring_lam (LT.VAR var)));
			 original)
		       
	      | 1 => 
		let
		    val _ = info ("non-shiftable occurs once: "^
				  (makestring_lam (LT.VAR var)))

		    datatype action = Reduce | Give_Up | Fiddle_It

		    fun reduce_non_shiftables body =
			let
			   exception Stop of bool

			   fun find_var_nonshift (LT.VAR v, _) = 
			      if v=var then (true,true)
			      else (false,false)
			     | find_var_nonshift (expr,_) = 
			       if not(is_shiftable expr) then (false,true)
			       else (false,false)

			   val evset = LS.evaluation_set body
			   val before_nonshifts =  LS.reduce_inner_until
			      			   find_var_nonshift 
			in 
			   if (LT.VAR var) mem evset
			      then if before_nonshifts (body,false)
				      then Reduce
				   else Fiddle_It
			   else Give_Up
			end
		in
		    case reduce_non_shiftables body of
		        Give_Up => (info "<given up>";
				    original)
		      | Reduce => (info "<reduced it>";
				   reduce (arg,body))
		      | Fiddle_It => 
			    let 
				val newbody = fiddle_order body
				val _ = info 
				    "attempted fiddle on commutative order"
			    in 
				case reduce_non_shiftables newbody of
				    Reduce => 
					(info "-- it worked!!";
					 reduce (arg,newbody))
				  | _ => (info "-- it failed. boo hoo";
					  original)
			    end
		end

	      | more => (info ("non-shiftable appears more than once: "^
			       (makestring_lam (LT.VAR var)));

			 original)) (* could test for a subset which _can_ *)
				    (* appear more than once, given eval'd *)
		                    (* first: eg, RAISE.		   *)
	   end

	 | beta2 expr = expr


       (*  This optimisation  is intended to generate new instances of  *)
       (*  partially applied curried functions, to save the run-time    *)
       (*  costs of closures.  It would typically create new functions  *)
       (*  when using functionals like "pair", "fold" etc.  There is a  *)
       (*  maximal size of function which will be duplicated like this, *)
       (*  to prevent code-generating huge functions multiply.		*)

       and curry_optimise (original as LT.APP(LT.FN(var,body),
					      arg as LT.FN(v1,LT.FN(v2,b2)))) =

	   if (cost_expr b2 < (!max_curry_body))
	       then 
		   let
		       fun curry_reduce (expr as LT.APP(LT.VAR v, operand)) =
			   if v=var 
			       then LS.rename_fresh(LT.FN(v2,
					     LS.substitute [(v1,operand)] b2))
			   else expr
			 | curry_reduce expr = expr

		       val _ = info ("curry-generation applied to v"^
				     (LT.printLVar var))
		   in
		       LT.APP(LT.FN(var,LS.apply_outermost curry_reduce body),
			      arg)
		   end
	   else original

	 | curry_optimise expr = expr
			   
   in
       LS.apply_innermost beta expression
   end  

  end (* of local *)  


  (************************************************)
  (* Eta-reduction -- eliminates lambda-variables *)
  (************************************************)

  val eta_reduce =
      let 
	  fun eta (expr as (LT.FN(var,LT.APP(result,LT.VAR var')))) =
	      if (var=var') andalso 
		  not(var' mem (snd (LS.bounds_and_frees result))) andalso
		  (LS.is_shiftable nullset result)
		 then result
	      else expr
	    | eta expr = expr
      in 
	  LS.apply_innermost eta 
      end;



  (***************************************************)
  (* Select-elimination -- removes redundant SELECTs *)
  (***************************************************)

  val select_elim =
      let 
	  fun select (LT.SELECT(field,LT.STRUCT expr_list)) =
	      	       				select_field expr_list field
	    | select (LT.SELECT(field,LT.LETREC(lvl,lel,
						LT.STRUCT expr_list))) =
	      		      LT.LETREC(lvl,lel,select_field expr_list field)
	    | select expr = expr
      in 
	  LS.apply_outermost select
      end;
	  


  (****************************************************)
  (* Switch-elimination -- removes redundant SWITCHes *)
  (****************************************************)

  val switch_elim =
   let 
    val imposs = fn s => imposs ("LambdaOptimiser.switch_elim: "^s)

    fun makeK (eval,result) = LT.APP(LT.FN(LT.new_LVar(),result),eval)

    fun switch expr = case expr of

    (* single branches *)
    
     (LT.SWITCH(expr,[],LT.ABSENT,LT.PRESENT default)) => makeK (expr,default)
   | (LT.SWITCH(expr,[],LT.PRESENT default,LT.ABSENT)) => makeK (expr,default)
   | (LT.SWITCH(expr,[(_,item)],LT.ABSENT,LT.ABSENT)) => makeK (expr,item)


    (* switch on atomic constants *)

   | (LT.SWITCH(LT.INT n, cases, case_default, LT.ABSENT)) =>
	 (case (LS.assoc (LT.CON_TAG n) cases) of
	      (LT.PRESENT expr) => expr
	    |  LT.ABSENT => 
		   (case case_default of
			(LT.PRESENT expr) => expr
		      |  LT.ABSENT => 
			     imposs "no constructor match or default"))

   | (LT.SWITCH(LT.INT _, _, _, _)) => imposs "screwy SWITCH-tag expression!"

   | (LT.SWITCH(LT.SCON scon, cases, case_default, LT.ABSENT)) => 
	 let 
	     fun find [] = 
		(case scon of 
		     Ident.REAL _ => expr  (* use dynamic equality instead *)

		   	      | _ => (case case_default of
					  (LT.PRESENT expr) => expr
					|  LT.ABSENT => 
 				     imposs "no scon match or default"))

	       | find ((LT.SCON_TAG tag,expr)::cs)= 
		 			if Ident.scon_eqrep(tag,scon) 
					    then expr
					else find cs

	       | find _ = imposs "mismatched SWITCH-scon expression"
	 in
	     find cases
	 end
		            
   | (LT.SWITCH(LT.SCON _, _, _, _)) => imposs "screwy SWITCH-scon expression!"


   (* switch on constant structures *)

   | (LT.SWITCH(LT.STRUCT _, _, _, ptr_default)) =>
	 (case ptr_default of
	      (LT.PRESENT expr) => expr
	    |  LT.ABSENT => imposs "no pointer-default")
				  	   
   (*  nested switches with constant results  *)

   | (LT.SWITCH(LT.SWITCH(innerexpr, case_list, case_def1, ptr_def1),
		case_list2, case_def2, LT.ABSENT)) =>
     (let
	  fun is_constant (LT.INT _) = true
	    | is_constant (LT.SCON _) = true
	    | is_constant _ = false
	  and is_constant_opt (LT.PRESENT x) = is_constant x
	    | is_constant_opt LT.ABSENT = true

	  fun new_result constant =
	      let 
		  fun find_it x =
		      (case LS.assoc x case_list2 of
			   LT.PRESENT expr => expr
			 | LT.ABSENT => 
			       (case case_def2 of
				    LT.PRESENT expr => expr
				  | LT.ABSENT => imposs"screwy nesting"))
	      in
		  (case constant of
		       LT.INT i => find_it (LT.CON_TAG i)
		     | LT.SCON s => find_it (LT.SCON_TAG s)
		     | _ => imposs "never say never")
	      end
      in
	  if (forall is_constant (map snd case_list))
	      andalso (is_constant_opt case_def1)
	      andalso (is_constant_opt ptr_def1)
	      then 
		  LT.SWITCH(innerexpr, 
			    zip (map fst case_list,
				 map new_result (map snd case_list)),
			    LS.apopt new_result case_def1,
			    LS.apopt new_result ptr_def1)
	  else expr
      end)
  
  | _ => expr

   in 
       LS.apply_innermost switch 
   end;



  (**************************************************************)
  (*  Structure-elimination - removes redundant re-structuring  *)
  (**************************************************************)

  val struct_elim =
      let
	  val is_shiftable = LS.is_shiftable nullset
	  val is_commutative = LS.is_commutative

	  fun is_restruct (expr,selects) =
	      let 
		  fun i(n,LT.SELECT(f,e)::ss) = 
		      e=expr andalso (LT.fromField f)=n andalso i(n+1,ss)
		    | i(_,[]) = true
		    | i _ = false
	      in 
		  i(0,selects)
	      end

	  fun elim (str as LT.STRUCT(sels as (LT.SELECT(_,str'))::_)) = 
	      if is_restruct (str',sels)
		  then str'
	      else 
		  str
	    | elim expr = expr

	  and backwards_elim (expr as LT.APP(func, 
			    LT.STRUCT[LT.SELECT(f1,str1),LT.SELECT(f0,str0)]))=
	      if (LT.fromField(f1)=1) andalso (LT.fromField(f0)=0)
		 andalso str1=str0
		 andalso is_commutative func
		 andalso is_shiftable str1
		  then (info "One in a million! backwards commutative strelim";
			LT.APP(func,str1))
	      else expr
	    | backwards_elim expr = elim expr
      in
	  LS.apply_innermost backwards_elim
      end;



  (***********************************************************)
  (*  Application-Reordering - transforms for code generator *)
  (***********************************************************)

  (*  A function to break apart all APP's and put them back together again, *)
  (*  converting curried forms into nested functions, which the code 	    *)
  (*  code generator (obstinately) likes a lot better.  This prevents the   *)
  (*  creation of closures for fully applied forms, but makes the beautiful *)
  (*  lambda-expressions into ugly ones.  Sorry.			    *)
  (*  (actually, these forms are probably pretty infrequent, and not worth  *)
  (*   worrying over...)  Should probably only be applied once, although it *)
  (*  is perhaps useful in preventing extra iterations of beta-reduction.   *)

  val reorder_apps =
      let
	  fun apply_app (expr as LT.APP _) = 
	      let 
		  fun wrap (body,(var,arg)) = LT.APP(LT.FN(var,body),arg)
	      in
		  LS.reduce_left wrap (LS.unwrap_apps expr)
	      end
	    | apply_app expr = expr
      in
	  LS.apply_outermost apply_app
      end;


  (***************************)
  (* Apply all Optimisations *)  (* order ?  repeats ? *)
  (***************************)
 

  (*  A list of the optimisation functions available, with their names  *)
  (*  and individual switches to turn them on and off.  Each function   *)
  (*  is an independent transformation on lambda-expressions, although  *)
  (*  the transformations do interact.  The order they are given in is  *)
  (*  the reverse of the order that they will be applied.               *)

  val optimisations =  [("beta_reduce2", ref true, beta_reduce 1),
			("reorder_apps", ref true, reorder_apps),
			("eta_reduce",   ref true, eta_reduce),
			("struct_elim",  ref true, struct_elim),
			("switch_elim",  ref true, switch_elim),
			("select_elim",  ref true, select_elim),
			("fold_constants", ref true,
			 OptimiseSub.fold_constants),
			("beta_reduce",  ref true, beta_reduce 0)];

  val optimise_switches = 
      map (fn(name,switch,_)=>(name,switch)) optimisations;
      

  fun optimise1 expression =
      let 
	  (* build the optimising function... *)

	  val loadsa_output = show_info andalso show_code
	  val I = fn x=>x
	  val P = if loadsa_output
		      then fn s=>fn f=>fn x=>
			   (let 
				val x' = f x
			    in 
				(if x' = x then ()
				 else (display ("after "^s^", size of expr = "^
					       (makestring
						(LS.size_of_expr x'))^
						"...");
				       print_lam x'));
				x'
			    end)
		  else fn s=>I

	  val optimiser =              
	      LS.reduce_left (op o) 
	      (I, (map (fn(name,flag,f)=>if !flag then (P name f)
					 else I) optimisations))
	  

	  (* apply it... *)
	      
	  fun repeat_reduceopts (expr,n) = 
	      let 
		  val opt_expr = optimiser expr;
	      in 
		  if (opt_expr = expr)
		      then (opt_expr, n-1)
		  else (display
			("optimisation "^(makestring n));
			print_lam opt_expr;
			repeat_reduceopts (opt_expr,n+1))
	      end

	  
      in 
	  let
	      val (phase1,times) = repeat_reduceopts (expression,1)

	      val phase3 = OptimiseSub.common_subexpr_elim phase1

	      val _ = info "After CSE:"
	      val _ = print_lam phase3;

	      val _ = info ("\nNumber of reduction opt cycles: "^
			    (makestring times)^"\n"^
			    "Size of original expression: "^
			    (makestring
			     (LS.size_of_expr expression))^"\n"^
			    "Size of optimized expression: "^
			    (makestring
			     (LS.size_of_expr phase1))^"\n"^
			    "Reduced by : "^
			    (implode(take(5,explode (makestring 
				  (100.0 - (real(LS.size_of_expr phase1))/
				  (real(LS.size_of_expr expression))*100.0)))))
			    ^"\nAfter CSE, final size: "^
			    (makestring
			     (LS.size_of_expr phase3))^"\n"^
			    "Overall reduction factor: "^
			    (implode(take(5,explode (makestring 
				  (100.0 - (real(LS.size_of_expr phase3))/
				  (real(LS.size_of_expr expression))*100.0)))))
			    ^"%\n");
	  in
	      phase3
	  end
      end;
      
   val optimise = optimise1

   val simple_beta_reduce = beta_reduce 0
end;
@


1.25
log
@Added to & fixed single-branch case in Switch-Elimination.
@
text
@d4 3
d628 1
a628 1
    fun makeK (eval,result) = LT.APP(LT.FN(LT.new_LVar(),eval),result)
@


1.24
log
@Added simple beta reduce function for export.
@
text
@d4 3
d244 4
a247 1
val code_node_factor = 4;            (*  For wintertime, wear balaclavas  *)
d625 2
d629 1
a629 1
    (* empty case list and single default *)
d631 3
a633 2
     (LT.SWITCH(expr,[],LT.ABSENT,LT.PRESENT default)) => default
   | (LT.SWITCH(expr,[],LT.PRESENT default,LT.ABSENT)) => default
d658 1
a658 1
				     imposs "no scon match or default"))
@


1.23
log
@Added test to eta-reduction at last to ensure that
the result function is a shiftable expression, so
that it doesn't matter when it's evaluated.  Why was
I convinced this wasn't necessary before?  Not sure,
perhaps we got caught up in the fallacy that it wouldn't
matter, because it would still not be evaluated until
application time.  Not true!!
@
text
@d4 9
d889 2
@


1.22
log
@Removed select_lift
@
text
@d4 3
a139 1
	
d141 1
d232 1
a232 1
val code_node_factor = 4;            (*  For wintertime  		  *)
d548 2
a549 1
		       val _ = info "curry-generation applied."
d572 4
a575 3
	      if var=var' 
		  andalso not(var' mem (snd (LS.bounds_and_frees result)))
		then result
@


1.21
log
@Corrected replacing of non-shiftable expressions
that appear only once in a function body
(Ensuring that they are replaced only if evaluated before
 all other non-shiftables, and _are_ evaluated -- this
is tricky).  Altered form of debug switches.
@
text
@d4 7
d798 1
a798 1
  fun optimise expression =
a842 1
	      val phase2 = OptimiseSub.select_lift phase1
d844 1
a844 2
	      val _ = info "After select lift:"
	      val _ = print_lam phase2;
a845 2
	      val phase3 = OptimiseSub.common_subexpr_elim phase2

d861 1
a861 1
			    ^"%\nAfter select lift, size: "^
a862 3
			     (LS.size_of_expr phase2))^"\n"
			    ^"After CSE, final size: "^
			    (makestring
d870 1
a870 1
	      phase2
d874 1
@


1.20
log
@Invokes constant folding (not quite in the
right place at the mo, mind).
@
text
@d4 4
d128 3
d175 1
a175 4
    val show_diagnostics = ref true;    
    val show_stages = ref true;
	
    fun info s = if !show_diagnostics 
d179 1
a179 1
    fun display s = if !show_stages 
d473 1
a473 1
			       if (is_shiftable expr) then (false,true)
d783 2
d795 1
a795 1
	  val loadsa_output = !show_diagnostics andalso !show_stages
a845 5
	      val phase4 = OptimiseSub.fold_constants phase3 (* wrong place! *)

	      val _ = info "After constant folding:"
	      val _ = print_lam phase4;

d858 1
a858 1
			    ^"%\nAbstraction phase, final size: "^
d861 1
a861 1
			    ^"Final size: "^
d863 1
a863 1
			     (LS.size_of_expr phase4))^"\n"^
@


1.19
log
@fn_substitute heuristic wasn't quite right: we revert to
not substituting multiple functions at all for the time
being.  Ideally, renaming needs to be done at the heart
of the beta-reduction...
@
text
@d4 6
d463 12
a474 3
			    fun is_var x = (x = LT.VAR var)
			    val evseq = LS.strictly_evaluated_sequence body
			    val befores = take_prefix (not o is_var) evseq
d476 5
a480 5
			    if (exists is_var evseq) 
				then if (forall is_shiftable befores)
					 then Reduce
				     else Fiddle_It
			    else Give_Up
d574 1
a574 1
	  fun select (LT.SELECT(field,LT.STRUCT(expr_list))) =
d577 1
a577 1
						LT.STRUCT(expr_list)))) =
a830 1
	      val phase3 = OptimiseSub.common_subexpr_elim phase2
d832 1
a832 1
	      val _ = info "After abstraction phase:"
d835 3
a837 1
	      val _ = info "After abstraction phase again:"
d840 5
d860 1
a860 1
			    ^"Abstraction phase 2, final size: "^
d862 1
a862 1
			     (LS.size_of_expr phase3))^"\n"^
@


1.18
log
@Major addition is switch-folding on constant
valued switch expressions.
@
text
@d4 4
d238 2
a239 2
      fun fn_heuristic(body,no_of_times) =
	  (cost_expr body * no_of_times) < (!max_func_dup)
d273 5
a277 13
	    | LT.FN _ => 
	       let
		val apps = LS.reduce_outermost 
		    (fn (count,LT.APP(LT.VAR v,_)) => if v=var 
							  then count+1
						      else count
		       |(count,_) => count) (0,body)
	       in
		   (times-apps < 2) 
		   andalso  length(Set.set_to_list
				   (fst(LS.bounds_and_frees arg))) < 2
		   andalso  fn_heuristic(body,apps)
	       end
d429 1
a429 1
	       fun reduce_original() = beta (LS.substitute [(var,arg)] body)
d435 1
a435 1
		 | 1 =>  reduce_original()
d438 1
a438 1
			       then reduce_original()
d472 1
a472 1
				   reduce_original())
d482 1
a482 2
					 beta (LS.substitute [(var,arg)]
					       newbody))
d816 1
a816 1
	      val phase3 = (* OptimiseSub.common_subexpr_elim *) phase2
@


1.17
log
@Re-organized and added second phase of optimisation
(which involves beta-abstracting again, cse etc).
@
text
@d4 4
d177 3
d181 2
d379 18
a397 4
      (*  Do some judicious fiddling of commutative operators, etc, etc.   *)
      (*  in order to place all shiftable expressions as early as poss in  *)
      (*  the evaluation order to maximise the chance of being able to     *)
      (*  substitute.  If this seems like a bit of a hack...		   *)
a398 15
       val fiddle_order =
	   let
	       fun rearrange (app as LT.APP(func,LT.STRUCT [arg1,arg2])) =
		   if is_commutative func
		     andalso is_shiftable arg2
		     andalso not(is_shiftable arg1)
		       	then LT.APP(func,LT.STRUCT [arg2,arg1])
		   else app
		 | rearrange expr = expr

	   in 
	       LS.apply_outermost rearrange
	   end

       
d546 3
a548 3
	  fun eta (expr as (LT.FN(var,LT.APP(result,LT.VAR var2)))) =
	      if var=var2 
		  andalso not(var2 mem (snd (LS.bounds_and_frees result)))
d571 1
a571 1
	  LS.apply_innermost select
d636 1
a636 1
   | expr => expr
d638 39
d682 1
d689 3
d705 2
a706 1
	      else str
d708 11
d720 1
a720 1
	  LS.apply_innermost elim
a815 4
	  fun abstract_opts expression =
	      (OptimiseSub.common_subexpr_elim o
	       OptimiseSub.select_lift) expression

d820 2
a821 1
	      val phase2 = abstract_opts phase1
d826 3
d843 4
a846 1
			     (LS.size_of_expr phase2))^"\n"^
d849 1
a849 1
				  (100.0 - (real(LS.size_of_expr phase2))/
a857 1

@


1.16
log
@Added expression size diagnostics, and select-elimination
on LETREC's.
@
text
@d4 4
d69 1
d73 1
d82 6
a87 1
functor LambdaOptimiser(structure Ident       : IDENT
d89 1
a89 1
			structure Set         : SET
d94 1
a98 1
    structure Set = Set;
d120 1
d122 1
d126 1
d165 2
a166 1
    val makestring_lam = LambdaPrint.printlambda;
a175 1
    (* <The Big One!> *)
d182 3
a184 3
  (*  equivalence.   Beta-reductions are valuable optimisations, so some  *)
  (*  effort is made to analyse user-defined functions to attempt to      *)
  (*  classify them as shiftable.					  *)
d186 16
d204 26
d240 1
a240 1
      fun should_reduce(arg,times) = 
d243 1
d245 1
a245 1
	    | LT.SCON _ => true   (* ### measure of size of scon, please! *)
d247 1
a247 1
	    | LT.INT _  => true
a248 1
	    | LT.BUILTIN _ => true
d260 14
a273 5
	    | LT.FN(_,e) => LS.whnf e    (* all constant functions: perhaps  *)
					 (* should only do if they're only   *)
					 (* applied inside the function body,*)
					 (* and certainly in the case of     *)
                                         (* SCON's should be a size measure. *)
a275 1
      fun struct_cost(no_of_fields,no_of_times) = true  (* #### *)
a276 1

d308 43
d352 1
a352 1
  fun beta_reduce expression =
d354 5
d362 6
a367 2
       val shiftables = nullset
       val is_shiftable = LS.is_shiftable shiftables
d379 4
a382 4
		   if not(is_shiftable arg2)
		      andalso (is_shiftable arg1)
		      andalso (is_commutative func)
		       then LT.APP(func,LT.STRUCT [arg2,arg1])
d398 1
a398 1
       fun beta (original as LT.APP(LT.FN(var,body),LT.STRUCT fields)) =
d405 1
a405 1
			   (struct_cost(length fields,noselects))
d416 1
a416 1
       (*  Beta-reduction in the more general case.  Recurses to reduce   *)
d433 1
a433 1
		 | more => if should_reduce(arg,more) 
d435 2
a436 1
			   else original)
d439 2
a440 2
		   0 => (info ("non-shiftable doesn't appear in body -"^
			       "can't remove arg to "^
d446 2
a447 3
		    val _ = info ("non-shiftable "^
				  (makestring_lam (LT.VAR var))^
				  " occurs once in expr...")
d485 2
a486 2
	      | more => (info ("non-shiftable "^(makestring_lam (LT.VAR var))^
			 "appears more than once");
d489 2
a490 2
				  (* appear more than once, given eval'd *)
		                  (* first: eg, RAISE.			 *)
d495 30
d700 2
a701 1
  val optimisations =  [("reorder_apps", ref true, reorder_apps),
d706 1
a706 1
			("beta_reduce",  ref true, beta_reduce)];
d727 2
a728 2
					       "...\n"^
					       (makestring_lam x'))));
d741 1
a741 1
	  fun repeatopts (expr,n) = 
d746 1
a746 10
		      then (info ("Number of times optimised: "^
				  (makestring (n-1))^"\n"^
				  "Size of original expression: "^
				  (makestring
				   (LS.size_of_expr expression))^"\n"^
				  "Size of optimized expression: "^
				  (makestring
				   (LS.size_of_expr opt_expr))^"\n");
			  opt_expr)

d748 3
a750 4
			("optimisation "^
			 (makestring n)^"\n"^
			 (makestring_lam opt_expr));
			repeatopts (opt_expr,n+1))
d752 6
d759 30
a788 1
	  repeatopts (expression,1) 
@


1.15
log
@Removed superfluous argument from top-level optimise
function, at last!
@
text
@d4 4
d194 9
a202 1
	    | LT.SELECT _ => true    (* only if abstracted out again later! *)
d323 3
a325 1
		   0 => (info "non-shiftable doesn't appear in body";
d330 3
a332 2
		    val _ = info ("non-shiftable occurs once in \n"^
				  makestring_lam original)
d350 4
a353 2
		        Give_Up => original
		      | Reduce => reduce_original()
d365 2
a366 1
				  | _ => original
d370 3
a372 1
	      | more => (info "non-shiftable appears more than once";
d413 3
d528 1
a528 1
  (*  is useful in preventing extra iterations of beta-reduction.	    *)
a531 2
	  val _ = "Hey wow! reorder_apps actually did something!"

d578 6
a583 3
				 else (display ("after "^s^":\n"^
						makestring_lam x'));
				 x')
d601 8
a608 2
				  (makestring (n-1)));
			    opt_expr)
@


1.14
log
@Added free variable check in eta-reduction (oops)
@
text
@d4 3
d545 1
a545 1
  fun optimise nothing_anymore_remove_soon expression =
@


1.13
log
@Added struct_elim to eliminate re-generated structures,
and also beta-reduction on multiply appearing constant
functions and select operations.  NB!! These two will
conflict with CSE!
@
text
@d4 6
d108 3
d371 3
a373 1
	      if var=var2 then result
@


1.12
log
@Begun evaluation-order checks and sorted out struct-breakup
to give nested app/fn's instead of curried functions.
@
text
@d4 4
d60 1
a60 1
(*  equivalence -- much analysis is done on shiftable expressions... *)
d135 1
d137 1
d171 1
d173 1
d175 1
d177 8
a189 9
	   
      (*  Do some judicious fiddling of commutative operators, etc, etc.   *)
      (*  in order to place all shiftable expressions as early as poss in  *)
      (*  the evaluation order to maximise the chance of being able to     *)
      (*  substitute.  What a hack!  					   *)

      fun fiddle_order (is_shiftable, expr) = expr;
	  

d193 6
a198 5
      (*  structure, by producing a whopping huge curried function.       *)
      (*  Typically this introduces new beta-redexes, and can also be     *)
      (*  used to split apart a structure that has a mixture of shiftable *)
      (*  non-shiftable components.  (Ensuring beta-redexes have nested-  *)
      (*  function format rather than curried makes code tedious)         *)
d229 22
d260 14
a273 9
	   let
	       val noselects = LS.count_noselects (body,var)
	   in
	       if noselects=0 orelse (struct_cost(length fields,noselects))
		   then 
		       beta (breakup_struct (var,body,fields))
	       else 
		   beta2 original
	   end
d294 2
a295 1
		 | more => if should_reduce(arg,more) then reduce_original()
d299 2
a300 1
		0 => original
d304 3
d327 3
a329 1
				val newbody = fiddle_order (is_shiftable,body)
d332 4
a335 2
				    Reduce => beta (LS.substitute [(var,arg)]
						    newbody)
d340 2
a341 1
	      | more => original) (* could test for a subset which _can_ *)
d453 3
d457 27
d490 2
a491 1
  (*   worrying over?)							    *)
d495 2
d520 3
a522 1
  val optimisations =  [("reorder_apps",  ref true, reorder_apps),
a524 1
			("eta_reduce",   ref true, eta_reduce),
d544 1
a544 1
						LambdaPrint.printlambda x'));
d569 1
a569 1
			 (LambdaPrint.printlambda opt_expr));
@


1.11
log
@Major restructuring for beta-reduction, and talk of
shiftable expressions.  Added new "optimisation"
which may be removed later - reorder_apps to remove curried
applications of explicit functions  (which in all likelihood
get beta-reduced anyway...)
@
text
@d4 7
d49 1
d59 4
a62 3
functor LambdaOptimiser(structure Ident      : IDENT
			structure LambdaSub  : LAMBDASUB
			structure Set        : SET       
d65 1
d106 1
a106 1
      | take(n,x::xs) = x::(take(n-1,xs))
d108 24
d172 10
d188 2
a189 1
      (*  non-shiftable components.			  		  *)
d193 9
d207 1
a207 2
	    val newfunc = LS.reduce_left LS.beta_abstract (body, rev sub_exprs)
	    val newvars = take(size_of_struct, LS.strip_abs newfunc)
a208 2
	    val newfunc' = LS.substitute [(var,newstruct)] newfunc
	    val expr = LS.reduce_left LT.APP (newfunc',args)
d210 1
a210 1
	       expr
d216 1
a216 1
       (* definitions...					      *)
d219 1
d221 8
a228 1
       fun beta_general (original as (LT.APP(LT.FN(var,body),arg))) = 
d230 1
a230 2
	       val occurs = LS.occurrences(var,body)
	       val shiftable = LS.is_shiftable shiftables arg
d232 7
a238 3
	       if shiftable then
		   (case occurs of
			0 => body
a239 1
		      | 1 =>  LS.substitute [(var,arg)] body
d241 4
a244 6
		      | more => if should_reduce(arg,more)
				       then LS.substitute [(var,arg)] body
				   else original)
	       else
		   (case occurs of
			0 => original
d246 9
a254 1
		      | 1 => original   (* evaluation order stuff here *)
d256 42
a297 1
		      | more => original)
d300 1
a300 1
	 | beta_general expr = expr
a301 19
      (*  Beta-reduction when the argument is a structure.  This considers  *)
      (*  whether to break up the structure into separate lambda variables. *)
      (*  If the structure is always SELECT'd on in the body, it will be    *)
      (*  broken up.  Otherwise, a heuristic is used to decide based on     *)
      (*  the size of the struct and the number of times it appears in the  *)
      (*  body without an immediate SELECT.				    *)
 
    fun beta_struct (e as LT.APP(LT.FN(var,body),LT.STRUCT fields)) =
	  let
	      val noselects = LS.count_noselects (body,var)
	  in
	      if noselects=0 orelse (struct_cost(length fields,noselects))
		  then 
		      (beta_struct (breakup_struct (var,body,fields)))
	      else 
		  beta_general e
	  end
	| beta_struct expr = beta_general expr
	  
d303 1
a303 2
       LS.apply_innermost beta_struct 
         (LS.apply_innermost beta_general expression)
d413 2
d455 1
d457 12
d471 2
a472 1
	      (I, (map (fn(_,flag,f)=>if !flag then f else I) optimisations))
d482 9
a490 8
		      then 
			 (if n<2 then opt_expr
			  else 
			      (print 
			       ("lambdaoptimiser diagnostic: optimised "^
				(makestring n)^" times, we're getting there!");
			       opt_expr))
		  else repeatopts (opt_expr,n+1)
d493 1
a493 1
	  repeatopts (expression,0) 
d497 1
@


1.10
log
@Beta-reduction of structure args done more generally via beta-reduction.
@
text
@d4 3
d48 1
a48 1
(*  equivalence -- much analysis is done on expansive expressions... *)
d55 2
a56 1
			sharing LambdaSub.Set = Set) : LAMBDAOPTIMISER =
d88 10
d108 7
a114 4
  (*  non-expansive (i.e. can be guaranteed not to have side effects      *)
  (*  or raise an exception when evaluated), or when substitution will    *)
  (*  not change the evaluation order or number of times an expansive     *)
  (*  argument will be evaluated.  This ensures semantic equivalence.     *)
d116 1
a116 3
  (*  I use a more exact definition of non-expansive than the Definition, *)
  (*  see _lambdasub.sml for details.  	Also, some analysis of defined    *)
  (*  functions is undertaken to see if they can be proven non-expansive. *)
d118 1
a118 3
  local 

      (*   worth_reducing : expr * int -> bool				  *)
d126 1
a126 1
      (*  (only called with a non-expansive argument)			  *)
d128 1
a128 1
      fun worth_reducing(arg,times) =
d131 1
a131 1
	    | LT.SCON _ => true   (* measure of size of scon, please! *)
a134 1
	| worth_reducing _ = imposs "worth_reducing: bad argument!"
d136 1
d138 1
a138 1
      (* breakup_struct: expr * expr * expr list * field list -> expr  	  *)
d141 4
a144 3
      (*  structure.  Typically this introduces new beta-redexes, and     *)
      (*  can also be used to split apart a structure that has a mixture  *)
      (*  of expansive and non-expansive components.			  *)
d146 1
a146 1
      fun breakup_struct(var, body, fields, selects) =
d148 2
d151 7
a157 4
	    val sub_exprs = map (fn field=>(LT.SELECT(field,var))) selects
	  
	    val newfunc = LS.reduce_left LS.beta_abstract (body, sub_exprs)
	    val newexpr = LS.reduce_left LT.APP (newfunc, rev args)
d159 1
a159 1
	      newexpr
d161 5
d167 10
d178 1
a178 8
  in
      fun beta_reduce expression =
      let
	  fun beta (original as (LT.APP(function,arg))) = 
	   if (LS.is_expansive Set.empty_set arg)   (* do lots of clever *)
	       then original			    (* stuff here!!      *)
	   else 
	    (case function of 
d180 6
a185 8
	      (LT.FN(var,body)) => 
		  (case LS.occurrences(var,body) of
		       0 => body
		     | 1 => LS.substitute [(var,arg)] body
		     | several => if worth_reducing(arg,several)
				      then LS.substitute [(var,arg)] body
				  else 
				  reduce_struct_arg original)
d187 1
a187 2
	    | (LT.BUILTIN prim) => original  (* constant folding here! *)
	    | _ => original)
d189 2
a190 4
	 | beta expr = expr
      in 
	  LS.apply_innermost beta expression
      end
d192 1
a192 4
      (*  Beta-reduction when the argument is a structure, and is always    *) 
      (*  destructed inside the function body.   This takes place via       *)
      (*  beta-abstraction over each of the components of the struct, if it *)
      (*  is deemed worth-while, then recursive beta-reduction.		    *)
d194 10
a203 3
      and reduce_struct_arg (e as LT.APP(LT.FN(var,body),LT.STRUCT fields)) =
	  let 
	      val selects = LS.selects_on_var (body,var)
d205 5
a209 9
	      if (~1 mem selects)    (* don't reduce if entire *)
		  then e	     (* struct is referenced   *)
	      else
		  let
		      val sels = map LT.toField (Set.set_to_list selects)
		      val expr = breakup_struct(LT.VAR var,body,fields,sels)
		  in
		      beta_reduce expr
		  end
d211 6
a216 1
	| reduce_struct_arg expr = expr
d218 1
a218 2
end (* of local *)
  
a220 1

d320 5
d326 14
d351 2
a352 1
  val optimisations =  [("switch_elim",  ref true, switch_elim),
@


1.9
log
@More SWITCH eliminations, changed functor arguments and lambdasub
@
text
@d4 3
d73 4
d78 5
d91 1
a91 1
    (* The Big One! *)
d93 6
a98 7
  (*  Beta-reduction will only be attempted if the function argument      *)
  (*  is non-expansive, i.e. can be guaranteed not to have side effects   *)
  (*  or raise an exception when evaluated.  The exception to this is     *)
  (*  when the argument is an immediate RAISE - in which case, the        *)
  (*  function body itself is redundant!				  *)
  (*  <Since the expression is in a form suitable for beta-reduction, the *)
  (*   function itself is non-expansive, trivially>			  *)
d100 2
a101 1
  (*  see _lambdasub.sml for details...					  *)
d112 2
a113 6
      (* 								  *)
      (* 1. VAR, SCON, INT, BUILTIN  - little/no overhead - go ahead!     *)
      (*								  *)
      (* 2. STRUCT (restrict to of lambda variables only?), where         *)
      (*    appearances in body are all operated on by SELECT.		  *)
      (* 								  *)
d115 1
a115 1
      fun worth_reducing(LT.APP(LT.FN(var,body),arg),times) =
d117 3
a119 3
	      LT.VAR _ => true
	    | LT.SCON _ => true
	    | LT.INT _ => true
d121 2
a123 6
	    | LT.STRUCT fields =>   (* if forall is_var fields then ... *)
		  let 
		      val selects = LS.set_of_selects (body,var)
		  in
		      not(Set.is_member (~1,selects))
		  end
d125 6
a130 1
	    | _  => false)
d132 10
a141 1
	| worth_reducing _ = imposs "worth_reducing: bad argument!"
d143 7
a149 6
 in
     val beta_reduce =
      let 
       fun beta (original as (LT.APP(function,arg))) = 
	   if (LS.is_expansive Set.empty_set arg)
	       then original
d154 1
a154 1
		  (case (LS.lvar_occurrences var body) of
d157 1
a157 1
		     | several => if worth_reducing(original,several)
d159 2
a160 1
				  else original)
d167 1
a167 1
	  LS.apply_innermost_lexprs beta 
d169 23
a191 1
 end
d207 1
a207 1
	  LS.apply_innermost_lexprs eta 
d219 1
a219 4
	      	       (LS.nth(LT.fromField field,expr_list)
			handle LS.LambdaSubNth => 
			    imposs "select_elim: bad SELECT field no.")
				     
d222 1
a222 1
	  LS.apply_innermost_lexprs select
d290 1
a290 1
       LS.apply_innermost_lexprs switch 
d307 1
a307 2
  val optimisations =  [("beta_reduce2", ref true, beta_reduce),
			("switch_elim",  ref true, switch_elim),
d332 1
a332 1
		  if (opt_expr = expr) 
d334 1
a334 1
			 (if n<2 then expr 
@


1.8
log
@Trivial change.
@
text
@d4 3
d35 1
d39 5
a43 3
(* Various simplistic optimisations to the lambda-expressions produced *)
(* by the lambda-translator.  Care needs to be taken over preserving   *)
(* evaluation order, whatever it may be...  			       *)
d45 4
a48 7
(* This implementation applies one optimisation after another in some *)
(* fixed order, without repetitions.   There most be more efficient   *)
(* (and perhaps productive) schemes!				      *)


functor LambdaOptimiser(structure LambdaSub : LAMBDASUB
			structure Set       : SET       
a54 1

d61 3
a63 3
  (**************************)
  (* PEEPHOLE OPTIMIZATIONS *)
  (**************************)
d65 13
a77 1
  (* Beta-reduction -- eliminates lambda-variables *)
d79 1
a79 6
  (* Currently if argument appears in body at most once, beta-reduction  *)
  (* will be attempted.  It will only proceed if the function argument   *)
  (* is non-expansive, i.e. can be guaranteed not to have side effects   *)
  (* or raise an exception when evaluated.   We use a more exact         *)
  (* definition of non-expansive than the Definition, see _lambdasub.sml *)
 
d81 46
a126 1
  fun beta_reduce imperatives_set expression =
d128 18
a145 11
	  fun beta (expr as (LT.APP(f',g'))) = 
	      if LS.is_expansive imperatives_set g' 
		  then expr
	      else (case f' of 
			(LT.FN(lv,le)) => 
			    if (LS.lvar_occurrences lv le)<2
				then LS.substitute [(lv,g')] le 
			    else expr
		      | (LT.BUILTIN prim) => expr  (* constant folding! *)
		      | _ => expr)
	    | beta expr = expr
d147 3
a149 2
	  LS.apply_innermost_lexprs beta expression
      end;
d154 1
d156 1
d158 1
a158 1
  fun eta_reduce _ expression =
d165 1
a165 1
	  LS.apply_innermost_lexprs eta expression
d170 1
a170 1

d172 1
d174 1
a174 1
  fun select_elim _ expression =
d177 4
a180 1
	      			LS.nth(LT.fromField field,expr_list)
d183 1
a183 1
	  LS.apply_innermost_lexprs select expression
d188 1
d190 1
d192 3
a194 4
  fun switch_elim _ expression =
    let 
	fun impossible s = raise LT.impossible 
					("LambdaOptimiser.switch_elim: "^s)
d196 1
a196 1
	fun switch (LT.SWITCH(expr,[],LT.ABSENT,LT.PRESENT default)) = default
d198 4
a201 1
	  | switch (LT.SWITCH(expr,[],LT.PRESENT default,LT.ABSENT)) = default
d203 7
a209 5
	  | switch (LT.SWITCH(LT.INT n, cases, case_default,LT.ABSENT)) =
            (* NB:- last argument should always be ABSENT anyhow. *)
	  (case (LS.assoc (LT.CON_TAG n) cases) of
	       (LT.PRESENT expr) => expr
	     | LT.ABSENT => 
d212 2
a213 2
		      | LT.ABSENT => impossible
			    		"no constructor match or default"))
d215 32
a246 4
	  | switch (LT.SWITCH(LT.STRUCT _, _, _, ptr_default)) =
	    (case ptr_default of
		 (LT.PRESENT expr) => expr
	       | LT.ABSENT => impossible "no pointer-default")
d248 1
a248 4
	  | switch expr = expr
    in 
	  LS.apply_innermost_lexprs switch expression
    end;
d250 3
d256 1
d262 5
a266 4
  (* A list of the optimisation functions available, with their names, *)
  (* in the reverse of the order that they will be applied.  These     *)
  (* functions represent independent transformations on lambda-expr's  *)
  (* similar to traditional "peephole" optimisations.		       *)
d268 5
a272 4
  val optimisations =  [("switch_elim", switch_elim),
			("select_elim", select_elim),
			("eta_reduce",  eta_reduce),
			("beta_reduce", beta_reduce)];
a273 7
  (********************************************************************)

  (* Initially, turn on all optimisations *)

  val optimise_fn_switches = 
      map (fn(name,f)=>(name,ref true,f)) optimisations;

d275 1
a275 1
      map (fn(name,switch,_)=>(name,switch)) optimise_fn_switches
d278 1
a278 1
  fun optimise imperatives_set expression =
d280 2
d283 1
a283 2

	  val optimiser = 
d285 1
a285 2
	      (I, (map (fn(_,flag,f)=>if !flag then (f imperatives_set) else I)
		   optimise_fn_switches))
d287 3
@


1.7
log
@Beta-reduction now performs expansive expression test.
@
text
@d4 3
d164 4
a167 4
  val optimisations = [("switch_elim", switch_elim),
		       ("select_elim", select_elim),
		       ("eta_reduce",  eta_reduce),
		       ("beta_reduce", beta_reduce)];
d191 1
a191 1
		  val opt_expr = optimiser expression;
d195 1
a195 1
			  if n=1 then opt_expr 
d200 1
a200 1
			       opt_expr)
@


1.6
log
@Altered to conform with changed version of Lambdasub.
@
text
@d4 3
d28 1
a29 1
require "../utils/set";
d42 2
a43 1
			structure Set       : SET       ) : LAMBDAOPTIMISER =
a54 3
  (*****************)
  (* OPTIMIZATIONS *)
  (*****************)
d56 4
d66 2
a67 1
  (* definition of non-expansive w                 *)
d69 1
a69 5
  (* For more than once, must check imperative attribute of expression,  *)
  (* and judge trade-off with cost of function application.		 *)
  (* THINK ABOUT EVALUATION ORDER!! -- in what order are lexpr's eval'd? *)

  fun beta_reduce expression =
d72 9
a80 7
	      (case f' of (LT.FN(lv,le)) => 
		   if (LS.lvar_occurrences lv le)<2    
		       then LS.substitute [(lv,g')] le 
		   else expr
	        | (LT.BUILTIN prim) => 
		      expr (* Opp'ty for constant folding *)
		| _ => expr)
d91 1
a91 1
  fun eta_reduce expression =
d106 1
a106 1
  fun select_elim expression =
d119 1
a119 1
  fun switch_elim expression =
d157 3
a159 2
  (* in the order that they will be applied.  All functions are        *)
  (* independent.						       *)
d161 2
a162 1
  val optimisations = [("beta_reduce", beta_reduce),
d164 1
a164 2
		       ("select_elim", select_elim),
		       ("switch_elim", switch_elim)];
d177 1
a177 1
  fun optimise imperatives_set expression = 
d181 4
a184 3
	  val optimiser = LS.reduce_left (op o) 
	      		   (I, (map (fn(_,flag,f)=>if !flag then f else I)
				(rev optimise_fn_switches)))
@


1.5
log
@Updated for new module LambdaSub
@
text
@d4 3
d41 1
d43 2
a47 1

a50 62
    structure Set = Set;
	

  (*******************)
  (* Minor Functions *)
  (*******************)

  (* Functions to recursively apply a function to sub-sub- lambda *)
  (* expressions.  						  *)


  fun apply_apps f =
    let 
	fun apply (LT.APP (p,q)) = f (LT.APP (apply p,apply q))
	  | apply expr = LS.apply_innermost_lexprs apply expr
    in 
	apply 
    end;


  fun apply_abs f =
    let 
	fun apply (LT.FN(lv,le)) = f (LT.FN(lv, apply le))
	  | apply expr = LS.apply_innermost_lexprs apply expr
    in 
	apply 
    end;


  fun apply_selects f =
    let 
	fun apply (LT.SELECT (fld,le)) = f (LT.SELECT (fld, apply le))
	  | apply expr = LS.apply_innermost_lexprs apply expr
    in 
	apply 
    end;


  fun apply_switches f =
    let 
	fun apply (LT.SWITCH(le,clel,leo1,leo2)) = 
	    		f (LT.SWITCH(apply le, 
				     map (LS.apsnd apply) clel,
				     LS.apopt apply leo1,
				     LS.apopt apply leo2))
	  | apply expr = LS.apply_innermost_lexprs apply expr
    in 
	apply 
    end;


  fun apply_letrecs f =
    let 
	fun apply (LT.LETREC(lvl,lel,le)) = f (LT.LETREC (lvl,map apply lel,
							  apply le))
	  | apply expr = LS.apply_innermost_lexprs apply expr
    in 
	apply 
    end;



d57 6
a62 1
  (* Currently if argument appears in body at most once.                 *)
d68 9
a76 7
      let fun beta (expr as (LT.APP(f',g'))) = 
	  (case f' of (LT.FN(lv,le)) => if (LS.lvar_occurrences lv le)<2    
					    then LS.substitute [(lv,g')] le 
					else expr
	            | (LT.BUILTIN prim) => 
			  		expr (* Opp'ty for constant folding *)
		    | _ => expr)
d78 3
a80 1
      in (apply_apps beta) expression end;
d88 4
a91 3
      let fun eta (expr as (LT.FN(var,LT.APP(result,LT.VAR var2)))) =
	  if var=var2 then result
	  else expr
d93 3
a95 1
      in (apply_abs eta) expression end;
d103 3
a105 2
      let fun select (LT.SELECT(field,LT.STRUCT(expr_list))) =
	                             LS.nth(LT.fromField field,expr_list)
d107 3
a109 1
      in (apply_selects select) expression end;
d113 1
a113 1
  (* Switch-reduction -- removes redundant SWITCHes *)
d116 6
a121 1
    let fun switch (LT.SWITCH(expr,[],LT.ABSENT,LT.PRESENT default)) = default
d123 16
d140 3
a142 1
    in (apply_switches switch) expression end;
d145 3
a147 1
  (*-------------------------*)
d149 1
a149 1
  (*-------------------------*)
@


1.4
log
@Added missing STRUCT clause to lvar_occurrences
@
text
@d4 3
d22 1
a22 1
require "lambdatypes";
d35 2
a36 2
functor LambdaOptimiser(structure LambdaTypes : LAMBDATYPES
			structure Set : SET) : LAMBDAOPTIMISER =
d38 1
a38 2
  structure LambdaTypes = LambdaTypes;
  structure Set = Set;
d40 1
a40 1
  (* trivia *)
a41 1
  exception TEMPERROR of string;
d43 2
a44 7
  fun itlist f =
    let 
	fun itl (i,[]) = i
	  | itl (i,x::xs) = itl(f(i,x),xs)
    in 
	itl 
    end;
d46 2
d49 3
a51 2
  fun apfst f (x,y) = (f x,y);
  fun apsnd f (x,y) = (x, f y);
d53 2
a54 3
  fun nth (0,x::_) = x
    | nth (n,_::xs) = nth (n-1, xs)
    | nth (_,[]) = raise TEMPERROR "nth";
a55 1
  open LambdaTypes;  (* please, can  I ? *)
a56 13
  fun apopt f (PRESENT x) = PRESENT (f x)
    | apopt _ ABSENT = ABSENT;



  (* the real stuff *)


  (*  Functions to recursively apply a function to sub-sub- lambda *)
  (* expressions.  It would be more concise and elegant to         *)
  (* generalise these, at the expense of some efficiency in the    *)
  (* optimisation functions themselves.				   *)

d59 2
a60 13
	fun apply (FN(lv,le)) = FN (lv, apply le)
	  | apply (LETREC(lvl,lel,le)) = LETREC (lvl,map apply lel,apply le)
	  | apply (SWITCH(le,clel,leo1,leo2)) = 
	           SWITCH(apply le, 
			  map (apsnd apply) clel,
			  apopt apply leo1,
			  apopt apply leo2)
	  | apply (STRUCT lel) = STRUCT (map apply lel)
	  | apply (SELECT (fld,le)) = SELECT (fld, apply le)
	  | apply (RAISE le) = RAISE (apply le)
	  | apply (HANDLE (le1,le2)) = HANDLE (apply le1, apply le2)
	  | apply (APP (p,q)) = f (APP (apply p,apply q))
	  | apply expr = expr
d65 1
d68 2
a69 13
	fun apply (LETREC(lvl,lel,le)) = LETREC (lvl,map apply lel,apply le)
	  | apply (APP (p,q)) = APP (apply p,apply q)
	  | apply (SWITCH(le,clel,leo1,leo2)) = 
	           SWITCH(apply le, 
			  map (apsnd apply) clel,
			  apopt apply leo1,
			  apopt apply leo2)
	  | apply (STRUCT lel) = STRUCT (map apply lel)
	  | apply (SELECT (fld,le)) = SELECT (fld, apply le)
	  | apply (RAISE le) = RAISE (apply le)
	  | apply (HANDLE (le1,le2)) = HANDLE (apply le1, apply le2)
	  | apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply expr = expr
d74 1
d77 2
a78 13
	fun apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply (LETREC(lvl,lel,le)) = LETREC (lvl,map apply lel,apply le)
	  | apply (APP (p,q)) = APP (apply p,apply q)
	  | apply (SWITCH(le,clel,leo1,leo2)) = 
	           SWITCH(apply le, 
			  map (apsnd apply) clel,
			  apopt apply leo1,
			  apopt apply leo2)
	  | apply (STRUCT lel) = STRUCT (map apply lel)
	  | apply (RAISE le) = RAISE (apply le)
	  | apply (HANDLE (le1,le2)) = HANDLE (apply le1, apply le2)
	  | apply (SELECT (fld,le)) = f (SELECT (fld, apply le))
	  | apply expr = expr
d83 1
d86 6
a91 13
	fun apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply (LETREC(lvl,lel,le)) = LETREC (lvl,map apply lel,apply le)
	  | apply (APP (p,q)) = APP (apply p,apply q)
	  | apply (STRUCT lel) = STRUCT (map apply lel)
	  | apply (SELECT (fld,le)) = SELECT (fld, apply le)
	  | apply (RAISE le) = RAISE (apply le)
	  | apply (HANDLE (le1,le2)) = HANDLE (apply le1, apply le2)
	  | apply (SWITCH(le,clel,leo1,leo2)) = 
	           f (SWITCH(apply le, 
			     map (apsnd apply) clel,
			     apopt apply leo1,
			     apopt apply leo2))
	  | apply expr = expr
d96 1
d99 3
a101 14
	fun apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply (APP (p,q)) = APP (apply p,apply q)
	  | apply (SWITCH(le,clel,leo1,leo2)) = 
	           SWITCH(apply le, 
			  map (apsnd apply) clel,
			  apopt apply leo1,
			  apopt apply leo2)
	  | apply (STRUCT lel) = STRUCT (map apply lel)
	  | apply (SELECT (fld,le)) = SELECT (fld, apply le)
	  | apply (RAISE le) = RAISE (apply le)
	  | apply (HANDLE (le1,le2)) = HANDLE (apply le1, apply le2)
	  | apply (LETREC(lvl,lel,le)) = f (LETREC (lvl,map apply lel,
						    apply le))
	  | apply expr = expr
a106 4
  (* Calculate the number of occurrences of a lambda-variable *)
  (* in a lambda-expression, assuming unique naming. Could    *)
  (* be more efficient, especially as the exact number of     *)
  (* occurrences is probably not needed.		      *)
d108 1
a108 61
  fun lvar_occurrences lvar =
    let 
	fun count (VAR lvar') = if lvar=lvar' then 1 else 0
	  | count (FN (_,le)) = count le 
	  | count (LETREC (_,les,le)) = itlist (op +) (0,map count (le::les))
	  | count (APP (le1,le2)) = (count le1) + (count le2)
	  | count (SWITCH (le,clel,leo1,leo2)) = 
	    	let 
		    fun count_opt (PRESENT lexpr) = count lexpr
		      | count_opt ABSENT = 0
		in 
		    itlist (op +) (0, (count_opt leo1) :: (count_opt leo2) ::
				      (map (fn(_,x)=>count x) clel))
		end
	  | count (STRUCT lel) = itlist (op +) (0, map count lel)
	  | count (SELECT (_,le)) = count le 
	  | count (RAISE le) = count le
	  | count (HANDLE (le1,le2)) = (count le1) + (count le2)
	  | count _ = 0
    in 
	count 
    end;


  (* Look-up in an association list, using Opt type from Lambdatypes *)

  fun assoc key =
    let 
	fun ass ((k,v)::kvs) = if k=key 
				 then (PRESENT v)
			       else 
				 ass kvs
	  | ass [] = ABSENT
    in 
	ass 
    end;


  (* Simultaneous substitution *)

  fun substitute subslist =
    let 
	fun subs (v as VAR lvar) = (case (assoc lvar subslist) of
					(PRESENT expr) => expr
				      | ABSENT => v)
	  | subs (FN(lv,le)) = FN(lv, subs le)
	  | subs (LETREC(lvl,lel,le)) = LETREC(lvl, map subs lel, subs le)
	  | subs (APP(le1,le2)) = APP(subs le1, subs le2)
	  | subs (SWITCH(le,clel,leo1,leo2)) = SWITCH(subs le,
						     map (apsnd subs) clel,
						     apopt subs leo1,
						     apopt subs leo2)
	  | subs (STRUCT lel) = STRUCT(map subs lel)
	  | subs (SELECT (fld,le)) = SELECT(fld, subs le)
	  | subs (RAISE le) = RAISE(subs le)
	  | subs (HANDLE (le1,le2)) = HANDLE(subs le1, subs le2)
	  | subs expr = expr
    in subs end;


  (*---------------*)
d110 1
a110 1
  (*---------------*)
d120 6
a125 5
      let fun beta (expr as (APP(f',g'))) = 
	  (case f' of (FN(lv,le)) => if (lvar_occurrences lv le)<2    
					 then substitute [(lv,g')] le 
				     else expr
	            | (BUILTIN prim) => expr (* Opp'ty for constant folding *)
d136 1
a136 1
      let fun eta (expr as (FN(var,APP(result,VAR var2)))) =
d145 1
a145 1
  (* Select-reduction -- removes redundant SELECTs *)
d147 3
a149 3
  fun select_reduce expression =
      let fun select (SELECT(field,STRUCT(expr_list))) =
	  nth(LambdaTypes.fromField field,expr_list)
d157 3
a159 3
  fun switch_reduce expression =
    let fun switch (SWITCH(expr,[],ABSENT,PRESENT default)) = default
	  | switch (SWITCH(expr,[],PRESENT default,ABSENT)) = default
d168 21
a188 5
  val optimiser = switch_reduce o 
         	  select_reduce o 
		  eta_reduce o 
		  beta_reduce;
  
d191 6
@


1.3
log
@Altered for new LETREC form.
@
text
@d4 3
d189 1
@


1.2
log
@Added SELECT optimisation.
@
text
@d4 3
d40 2
a41 1
    let fun itl (i,[]) = i
d43 3
a45 1
    in itl end;
a54 2
  (* real stuff *)

d61 4
d71 3
a73 2
    let fun apply (FN(lv,le)) = FN (lv, apply le)
	  | apply (LETREC(lvl,lel)) = LETREC (lvl,map apply lel)
d85 3
a87 1
    in apply end;
d90 2
a91 1
    let fun apply (LETREC(lvl,lel)) = LETREC (lvl,map apply lel)
d104 3
a106 1
    in apply end;
d109 3
a111 2
    let fun apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply (LETREC(lvl,lel)) = LETREC (lvl,map apply lel)
d123 3
a125 1
    in apply end;
d128 3
a130 2
    let fun apply (FN(lv,le)) = f (FN(lv, apply le))
	  | apply (LETREC(lvl,lel)) = LETREC (lvl,map apply lel)
d142 3
a144 1
    in apply end;
d147 2
a148 1
    let fun apply (FN(lv,le)) = f (FN(lv, apply le))
d159 2
a160 1
	  | apply (LETREC(lvl,lel)) = f (LETREC (lvl,map apply lel))
d162 3
a164 1
    in apply end;
d168 3
a170 1
  (* in a lambda-expression, assuming unique naming.          *)
d172 3
a174 2
  fun occurrences lvar =
    let fun count (VAR lvar') = if lvar=lvar' then 1 else 0
d176 1
a176 1
	  | count (LETREC (_,les)) = itlist (op +) (0,map count les)
d178 8
a185 1
	  | count (SWITCH (le,clel,leo1,leo2)) = 0 (* !! *)
d190 3
a192 1
    in count end;
d198 2
a199 1
    let fun ass ((k,v)::kvs) = if k=key 
d204 3
a206 1
    in ass end;
d212 4
a215 3
    let fun subs (v as VAR lvar) = (case (assoc lvar subslist) of
      				   (PRESENT expr) => expr
				  | ABSENT => v)
d217 1
a217 1
	  | subs (LETREC(lvl,lel)) = LETREC(lvl, map subs lel)
d244 1
a244 1
	  (case f' of (FN(lv,le)) => if (occurrences lv le)<2    
d267 1
a267 1
  (* Select-reduction -- simplifies SELECT(field, STRUCT ...) forms *)
d277 1
a277 2
  (* Switch-reduction -- simplifies SWITCH(expr, [], NONE/expr, expr/NONE) *)
  (* does the second case ever crop up??? *)
d281 1
a281 3
	  | switch (SWITCH(expr,[],PRESENT default,ABSENT)) = 
	    (print "lambdaoptimiser: yes, it does";   (* ##### *)
	     default)
a285 18
  (* can't do this one; need to access environment, to alter bindings...
    

  (* letrec-reduction -- simplifies LETREC([x],[non-recursive-fn]) *)
 
  (* could generalise to non-recursive FN not called from others, to *)
  (* effectively remove superfluous use of "and".... worth it ?      *)

  fun letrec_reduce expression =
    let fun letrec (expr as LETREC([lvar],[lexpr])) =
            if (occurrences lvar lexpr)=0 then FN(lvar,lexpr)
	    else expr
	  | letrec expr = expr
    in (apply_letrecs letrec) expression end;

  *)


d290 4
a293 1
  val optimiser = switch_reduce o select_reduce o eta_reduce o beta_reduce;
d295 19
a313 1
  fun optimise imperatives_set expression = optimiser expression;
@


1.1
log
@Initial revision
@
text
@d3 3
a5 1
$Log$
d7 1
d14 2
d17 9
d27 1
a27 1
			structure Set : SET) =
d56 6
d94 1
a94 1
  fun apply_sel f =
d110 36
d148 1
a148 1
	  | count (FN (_,le)) = count le   (* assume uniquely named *)
d158 3
d169 1
d195 6
a200 3
  (* Beta-reduction.  Currently if argument appears in body at most once *)
  (* Otherwise, must check imperative attribute of expression, and judge *)
  (* trade-off with cost of function application.			 *)
a212 1
  (* Eta-reduction. *)
d214 3
a223 1
  (* Select-reduction. *)
d225 4
d233 1
a233 1
      in (apply_sel select) expression end;
d236 31
d271 1
a271 1
  val optimiser = select_reduce o eta_reduce o beta_reduce;
@
