head	1.43;
access;
symbols
	MLW_daveb_inline_1_4_99:1.43.1
	MLWorks_21c0_1999_03_25:1.43
	MLWorks_20c1_1998_08_20:1.43
	MLWorks_20c0_1998_08_04:1.43
	MLWorks_20b2c2_1998_06_19:1.43
	MLWorks_20b2_Windows_1998_06_12:1.43
	MLWorks_20b1c1_1998_05_07:1.43
	MLWorks_20b0_1998_04_07:1.43
	MLWorks_20b0_1998_03_20:1.43
	MLWorks_20m2_1998_02_16:1.42
	MLWorks_20m1_1997_10_23:1.42
	MLWorks_11r1:1.42.1.1.1.1.1
	MLWorks_workspace_97:1.42.3
	MLWorks_dt_wizard:1.42.2
	MLWorks_11c0_1997_09_09:1.42.1.1.1.1
	MLWorks_10r3:1.42.1.1.3
	MLWorks_10r2_551:1.42.1.1.2
	MLWorks_11:1.42.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.42.1.1
	MLWorks_20m0_1997_06_20:1.42
	MLWorks_1_0_r2c2_1997_06_14:1.42.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.42.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.42.1
	MLWorks_BugFix_1997_04_24:1.42
	MLWorks_1_0_r2_Win32_1997_04_11:1.42
	MLWorks_1_0_r2_Unix_1997_04_04:1.42
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.41.3.1.1
	MLWorks_gui_1996_12_18:1.41.4
	MLWorks_1_0_Win32_1996_12_17:1.41.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.41.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.41.1.1
	MLWorks_1_0_Irix_1996_11_28:1.41.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.41.2
	MLWorks_1_0_Unix_1996_11_14:1.41.1
	MLWorks_Open_Beta2_1996_10_11:1.39.1
	MLWorks_License_dev:1.38.1
	MLWorks_1_open_beta_1996_09_13:1.36.1
	MLWorks_Open_Beta_1996_08_22:1.36
	MLWorks_Beta_1996_07_02:1.35
	MLWorks_Beta_1996_06_07:1.35
	MLWorks_Beta_1996_06_06:1.35
	MLWorks_Beta_1996_06_05:1.35
	MLWorks_Beta_1996_06_03:1.35
	MLWorks_Beta_1996_05_31:1.35
	MLWorks_Beta_1996_05_30:1.35
	ML_beta_release_12/08/94:1.29
	ML_beta_release_03/08/94:1.29
	ML_revised_beta_release_25/05/94:1.29
	ML_final_beta_release_02/03/94:1.29
	mlworks-28-01-1994:1.28
	Release:1.28
	mlworks-beta-01-09-1993:1.28
	MLWorks-1-0-4-29/01/1993:1.22
	MLWorks-1-0-3-21/12/1992:1.22
	MLWorks-1-0-2-15/12/1992:1.22
	MLWorks-1-0-1-04/12/1992:1.19
	checkpoint_17_08_92:1.12
	Ten15_release_21-08-91:1.7
	Ten15_release_19-08-91:1.7
	ten15_release:1.7;
locks; strict;
comment	@ * @;


1.43
date	98.03.03.09.58.39;	author mitchell;	state Exp;
branches
	1.43.1.1;
next	1.42;

1.42
date	96.11.22.12.06.43;	author matthew;	state Exp;
branches
	1.42.1.1
	1.42.2.1
	1.42.3.1;
next	1.41;

1.41
date	96.10.31.15.53.30;	author io;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1;
next	1.40;

1.40
date	96.10.29.14.00.17;	author andreww;	state Exp;
branches;
next	1.39;

1.39
date	96.10.11.09.29.35;	author andreww;	state Exp;
branches
	1.39.1.1;
next	1.38;

1.38
date	96.10.04.11.12.27;	author matthew;	state Exp;
branches
	1.38.1.1;
next	1.37;

1.37
date	96.09.18.13.08.47;	author andreww;	state Exp;
branches;
next	1.36;

1.36
date	96.08.05.18.07.39;	author andreww;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	96.04.30.16.43.32;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	96.04.02.16.33.34;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.03.26.16.42.45;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	96.01.16.12.47.52;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	95.12.27.12.54.26;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	95.11.22.09.12.47;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	94.02.05.18.10.06;	author nosa;	state Exp;
branches;
next	1.28;

1.28
date	93.08.12.16.32.25;	author daveb;	state Exp;
branches
	1.28.1.1;
next	1.27;

1.27
date	93.07.08.14.25.29;	author nosa;	state Exp;
branches;
next	1.26;

1.26
date	93.07.02.17.17.38;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	93.05.20.12.43.44;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	93.03.09.12.45.59;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	93.02.08.15.39.00;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	92.12.14.18.47.04;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	92.12.10.16.34.43;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	92.12.08.19.17.59;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	92.12.02.14.00.04;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	92.11.27.10.49.23;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	92.10.14.12.06.34;	author richard;	state Exp;
branches;
next	1.16;

1.16
date	92.09.24.11.43.17;	author richard;	state Exp;
branches;
next	1.15;

1.15
date	92.09.17.11.16.04;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	92.09.16.08.40.20;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	92.09.08.18.35.03;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.05.19.15.52.44;	author clive;	state Exp;
branches;
next	1.11;

1.11
date	92.04.13.14.26.55;	author clive;	state Exp;
branches;
next	1.10;

1.10
date	92.02.14.19.21.26;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	91.12.19.16.50.15;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	91.11.22.17.41.08;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	91.07.23.11.38.54;	author davida;	state Exp;
branches;
next	1.6;

1.6
date	91.07.23.11.33.54;	author davida;	state Exp;
branches;
next	1.5;

1.5
date	91.07.23.10.54.43;	author davida;	state Exp;
branches;
next	1.4;

1.4
date	91.07.12.13.25.35;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	91.07.11.14.47.03;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	91.07.10.12.51.59;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.07.10.09.33.00;	author jont;	state Exp;
branches;
next	;

1.28.1.1
date	93.08.12.16.32.25;	author jont;	state Exp;
branches;
next	;

1.36.1.1
date	96.09.13.11.16.56;	author hope;	state Exp;
branches;
next	;

1.38.1.1
date	96.10.07.16.06.44;	author hope;	state Exp;
branches;
next	;

1.39.1.1
date	96.10.17.11.25.00;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	96.11.14.12.49.56;	author hope;	state Exp;
branches
	1.41.1.1.1.1;
next	;

1.41.1.1.1.1
date	96.11.28.15.01.07;	author hope;	state Exp;
branches;
next	;

1.41.2.1
date	96.11.22.18.09.26;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.12.17.17.48.05;	author hope;	state Exp;
branches
	1.41.3.1.1.1;
next	;

1.41.3.1.1.1
date	97.02.24.11.37.54;	author hope;	state Exp;
branches;
next	;

1.41.4.1
date	96.12.18.09.42.06;	author hope;	state Exp;
branches;
next	;

1.42.1.1
date	97.05.12.10.34.34;	author hope;	state Exp;
branches
	1.42.1.1.1.1
	1.42.1.1.2.1
	1.42.1.1.3.1;
next	;

1.42.1.1.1.1
date	97.07.28.18.19.53;	author daveb;	state Exp;
branches
	1.42.1.1.1.1.1.1;
next	;

1.42.1.1.1.1.1.1
date	97.10.07.11.45.00;	author jkbrook;	state Exp;
branches;
next	;

1.42.1.1.2.1
date	97.09.08.17.13.26;	author daveb;	state Exp;
branches;
next	;

1.42.1.1.3.1
date	97.09.09.14.09.07;	author daveb;	state Exp;
branches;
next	;

1.42.2.1
date	97.09.10.19.24.39;	author brucem;	state Exp;
branches;
next	;

1.42.3.1
date	97.09.11.20.55.16;	author daveb;	state Exp;
branches;
next	;

1.43.1.1
date	99.04.01.17.57.03;	author daveb;	state Exp;
branches;
next	;


desc
@Extensions to absynprint for top level declarations
@


1.43
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@(* topdecprint.sml the functor *)
(*
$Log: _topdecprint.sml,v $
 * Revision 1.42  1996/11/22  12:06:43  matthew
 * Removing reference to MLWorks.Option
 *
 * Revision 1.41  1996/10/31  15:53:30  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.40  1996/10/29  14:00:17  andreww
 * [Bug #1708]
 * changing syntax of datatype replication.
 *
 * Revision 1.39  1996/10/11  09:29:35  andreww
 * [Bug #1320]
 * Reverse engineering the derived form for type abbreviation.
 * Makes printed signatures much nicer.
 *
 * Revision 1.38  1996/10/04  11:12:27  matthew
 * [Bug #1622]
 * Change to signature absyn
 *
 * Revision 1.37  1996/09/18  13:08:47  andreww
 * [Bug #1577]
 * Adding extra clause for the new abstract syntax for
 * datatype replication in signatures.
 *
 * Revision 1.36  1996/08/05  18:07:39  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
 * Revision 1.35  1996/04/30  16:43:32  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.34  1996/04/02  16:33:34  matthew
 * Changes to WHEREsigexp
 *
 * Revision 1.33  1996/03/26  16:42:45  matthew
 * Language changes
 *
 * Revision 1.32  1996/01/16  12:47:52  daveb
 * Added location information to Absyn.SIGNATUREtopdec.
 *
Revision 1.31  1995/12/27  12:54:26  jont
Removing Option in favour of MLWorks.Option

Revision 1.30  1995/11/22  09:12:47  daveb
Changed Absyn.REQUIREtopdec to take a string instead of a module_id.

Revision 1.29  1994/02/05  18:10:06  nosa
Debugger structure, and structure recording for Modules Debugger.

Revision 1.28  1993/08/12  16:32:25  daveb
Change to print moduleids.

Revision 1.27  1993/07/08  14:25:29  nosa
structure Option.

Revision 1.26  1993/07/02  17:17:38  daveb
Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.

Revision 1.25  1993/05/20  12:43:44  matthew
Added code for abstractions.

Revision 1.24  1993/03/09  12:45:59  matthew
Options & Info changes
Absyn changes

Revision 1.23  1993/02/08  15:39:00  matthew
Removed ref nameset in Absyn.FunBind

Revision 1.22  1992/12/14  18:47:04  jont
Improved format of printing for exception sepcifications in signatures

Revision 1.21  1992/12/10  16:34:43  jont
Modified printing of signatures to look pretty and aligned

Revision 1.20  1992/12/08  19:17:59  jont
Removed a number of duplicated signatures and structures

Revision 1.19  1992/12/02  14:00:04  matthew
Fixed bug in signature printing

Revision 1.18  1992/11/27  10:49:23  daveb
Changes to make show_id_class and show_eq_info part of Info structure
instead of references.

Revision 1.17  1992/10/14  12:06:34  richard
Added location information to the `require' topdec.

Revision 1.16  1992/09/24  11:43:17  richard
Added print_sigexp using Pretty.reduce.

Revision 1.15  1992/09/17  11:16:04  daveb
Fixed bug in printing of datatype specs.

Revision 1.14  1992/09/16  08:40:20  daveb
Improved printing of datatypes and substructures.

Revision 1.13  1992/09/08  18:35:03  matthew
Changes to absyn

Revision 1.12  1992/05/19  15:52:44  clive
Added marks to some of the abstract syntax

Revision 1.11  1992/04/13  14:26:55  clive
First version of the profiler

Revision 1.10  1992/02/14  19:21:26  jont
Removed use of pervasive fold (now done by implode). Removed use of
word require from a pattern (it's a reserved word). Tidied up slightly.

Revision 1.9  1991/12/19  16:50:15  jont
Added printing of REQUIREtopdec

Revision 1.8  91/11/22  17:41:08  jont
Removed opens

Revision 1.7  91/07/23  11:38:54  davida
Altered type-arg printing to conform with tidied version in Absynprint.

Revision 1.6  91/07/23  11:33:54  davida
Added missing require (not my fault, honest!).

Revision 1.5  91/07/23  10:54:43  davida
Added pretty-printing for signature expressions, provisionally.

Revision 1.4  91/07/12  13:25:35  jont
Added some spaces to improve output

Revision 1.3  91/07/11  14:47:03  jont
Minor mods

Revision 1.2  91/07/10  12:51:59  jont
Fixed errors

Revision 1.1  91/07/10  09:33:00  jont
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../basics/absynprint";
require "../basics/identprint";
require "topdecprint";
require "pretty";

functor TopdecPrint (
  structure Pretty : PRETTY
  structure AbsynPrint : ABSYNPRINT
  structure IdentPrint : IDENTPRINT

  sharing AbsynPrint.Absyn.Ident = IdentPrint.Ident
  sharing AbsynPrint.Options = IdentPrint.Options
  sharing type AbsynPrint.Absyn.options = IdentPrint.Options.options
  sharing type AbsynPrint.Absyn.Type = AbsynPrint.Absyn.Datatypes.Type
) : TOPDECPRINT =
struct

    structure Absyn = AbsynPrint.Absyn;
    structure P     = Pretty;
    structure Options  = IdentPrint.Options
    structure Datatypes = Absyn.Datatypes

    fun print_options (Options.OPTIONS{print_options=p,...}) = p


    (* Pretty Printing of signature specifications:  An Early Attempt!     *)
    (* Ideally, we should have a pretty-printer that provides consistent   *)
    (* breaks which would replace much of the use of newlines (P.nl) here. *)
    (* Also, routines in AbsynPrint should use the pretty printer too, so  *)
    (* that types can be printed nicely.			      	   *)

    fun sigexp_to_prettyT options depth =
      let
	fun sigexp_to_T options (Absyn.OLDsigexp(sigid,_,_)) =
	  P.str (IdentPrint.printSigId sigid)
	  | sigexp_to_T options (Absyn.NEWsigexp(topspec, _)) =
	    if depth > 0
	      then P.blk(0,[P.str "sig",
			    P.blk(2,(fn []=>[] | x => P.nl :: x)
				  (specs_to_prettyT [topspec])),
			    P.nl,
			    P.str "end"])
	    else P.str "sig ... end"
          | sigexp_to_T options (Absyn.WHEREsigexp (sigexp,wherestuff)) =
            P.blk (0, [sigexp_to_T options sigexp,
                       P.str " where "] @@ 
                       (where_to_T true (rev wherestuff)))

        and where_to_T _ [] = []           (* never called *)
          | where_to_T is_first ((tyvars,tycon,ty,_)::rest) =
             P.blk(if is_first then 0 else 10,    (* magic number is
                                                     to align "and" with
                                                     "type" *)
                  (if is_first then [P.str "type "]
                   else [P.nl,P.str " and "]) @@
                     (plongtypename (tyvars,tycon)) @@
                     [P.str " = ",
                      P.str (AbsynPrint.unparseTy 
                                (print_options options) ty)])
              :: (where_to_T false rest)


	and valspec(valid,ty,tyvars) =
	  [P.str "val ",
	   P.str (IdentPrint.printValId (print_options options) valid),
	   P.str " :",
	   P.brk 1,
	   P.blk(4,[P.str (AbsynPrint.unparseTy (print_options options) ty)])]

	and ptypename(tyvars, tycon) =
	  (case tyvars of
	     [] => []
	   | [tv] => [P.str (IdentPrint.printTyVar tv)]
	   | _ => (P.lst ("(",[P.str ",", P.brk 1],")")
		   (map (P.str o IdentPrint.printTyVar) tyvars))) @@
	     [P.brk (if tyvars=[] then 0 else 1),
	      P.str (IdentPrint.printTyCon tycon)]

	and plongtypename(tyvars, longtycon) =
	  (case tyvars of
	     [] => []
	   | [tv] => [P.str (IdentPrint.printTyVar tv)]
	   | _ => (P.lst ("(",[P.str ",", P.brk 1],")")
		   (map (P.str o IdentPrint.printTyVar) tyvars))) @@
	     [P.brk (if tyvars=[] then 0 else 1),
	      P.str (IdentPrint.printLongTyCon longtycon)]

	and typespec ts = (P.str "type ") :: (ptypename ts)

	and eqtypespec ts = (P.str "eqtype ") :: (ptypename ts)

	and datatypespec(tyvars,tycon,valtys) =
	  let
	    val tycon_str = ptypename (tyvars,tycon)

            fun string_ty NONE = []
              | string_ty (SOME ty) =
                [P.blk(4, [P.str" of ",
                           P.str (AbsynPrint.unparseTy 
                                  (print_options options) ty)])]
            

            fun valty (valid,tyopt,_) =
	      P.blk(2,
		    P.nl ::
		    P.str (IdentPrint.printValId 
                           (print_options options) valid) ::
		    string_ty tyopt)
              
            fun do_contypes[] = []
              | do_contypes[x] = [valty x]
              | do_contypes(x :: xs) =
                P.blk(0, [valty x, P.str" |"]) :: do_contypes xs



	  in (P.str "datatype ") :: tycon_str
	    @@ (P.str" =" :: do_contypes valtys)
	  end

        and datareplspec (location,tycon,longtycon,associatedConstructors) =
          let
            val tycon_str = P.str (IdentPrint.printTyCon tycon)
            val longtycon_str = P.str (IdentPrint.printLongTyCon longtycon)
            
                 (* the following simply strips the "-> tyvars tycon"
                    suffix of constructor types and then prints the
                    result *)

            fun string_ty (Datatypes.FUNTYPE(args,_)) =
              Absyn.print_type options args
              | string_ty ty = Absyn.print_type options ty


            fun valty (valid,tyopt,_) =
	      P.blk(2,
		    P.nl ::
		    P.str (IdentPrint.printValId 
                           (print_options options) valid) ::
                    (case tyopt
                       of NONE => []
                        | SOME ty => [P.blk(4, [P.str" of ",
                           P.str (string_ty ty)])]))
              

            fun do_contypes [] = []
              | do_contypes [x] = [valty x]
              | do_contypes(x :: xs) =
                P.blk(0, [valty x, P.str" |"]) :: do_contypes xs

                (* following function attempts to extract all the
                   free tyvars in the replicated datatype. *)

                
            exception noTyvars

            fun tyvars ((_,SOME(Datatypes.FUNTYPE(_,res)),_)::_) =
                            P.str(Absyn.print_type options res)
              | tyvars ((_,NONE,_)::rest) = tyvars rest
              | tyvars _ = raise noTyvars

            val default_str = case (!associatedConstructors)
                                of NONE => longtycon_str
                                 | SOME v => (tyvars v
                                              handle noTyvars => longtycon_str)

          in
           (P.str "datatype "):: [tycon_str] @@ 
           (P.str " = datatype ":: [default_str]) @@
           (P.str " = " ::
           (do_contypes (case (!associatedConstructors)
                           of NONE => [] (* this case is impossible:
                                            a replicated datatype must
                                            have some associated constructors*)
                            | (SOME v) => v)))
          end

	and exceptionspec(valid, typopt,_) =
	  case typopt of
	    NONE =>
	      [P.str "exception ",
	       P.str (IdentPrint.printValId (print_options options) valid)]
	  | SOME typ =>
	      [P.str "exception ",
	       P.str (IdentPrint.printValId (print_options options) valid),
	       P.str " of",
	       P.brk 1,
	       P.blk(0,[P.str(AbsynPrint.unparseTy 
                              (print_options options) typ)])]

	and structurespec(strid, sigexp) =
	  let val new_depth = depth - 1 
           in [P.str "structure ",
    	       P.str (IdentPrint.printStrId strid),
	       P.str " :",
               if new_depth > 0 then P.nl else P.brk 1,
               P.blk(2, [sigexp_to_prettyT options new_depth sigexp])]
           end

        and sharingspec(Absyn.STRUCTUREshareq strids) =
	  (P.str "sharing ") ::
	  (P.lst ("", [P.brk 1, P.str "= "],"")
	   (map (P.str o IdentPrint.printLongStrId) strids))

	  | sharingspec(Absyn.TYPEshareq tycons) =
	    (P.str "sharing type ") ::
	    (P.lst ("", [P.brk 1, P.str "= "],"")
	     (map (P.str o IdentPrint.printLongTyCon) tycons))

        and localspec(spec1,spec2) =
	  [P.blk (0, [P.str "local",
		      P.blk(2, [P.nl] @@
			    (specs_to_prettyT [spec1])),
		      P.nl,
		      P.str "in",
		      P.blk (1, [P.nl] @@
			     (specs_to_prettyT [spec2])),
		      P.nl,
		      P.str "end"])]

        and openspec(strids) =
	  (P.str "open ") ::
	  (P.lst ("",[P.brk 1],"")
	   (map (P.str o IdentPrint.printLongStrId) strids))

             (* the following function attempts to reverse engineer
                the derived forms of type abbreviations.  See the
                function do_type_spec in parser/_actionfunctions.sml
                and appendix A (fig 19) of the revised definition *)

	and includespec(Absyn.WHEREsigexp
                        (Absyn.NEWsigexp(Absyn.TYPEspec [ts],_),
                         [(_,_,ty,_)])) =
             P.str "type " :: (ptypename ts) @@
             [P.str " = ",
              P.str (AbsynPrint.unparseTy (print_options options) ty)]
                         
          | includespec(Absyn.WHEREsigexp
                        (Absyn.NEWsigexp(Absyn.EQTYPEspec [ts],_),
                         [(_,_,ty,_)])) =
             P.str "eqtype ":: (ptypename ts) @@
             [P.str " = ",
              P.str (AbsynPrint.unparseTy (print_options options) ty)]
                         
          | includespec(sigexp) =
           (P.str "include ") :: [sigexp_to_T options sigexp]

	and specs_to_prettyT speclist =
	  let
	    fun addnls [] = []
	      | addnls ([]::ts) = addnls ts
	      | addnls [t] = [P.blk(0,t)]
	      | addnls (t::ts) = (P.blk(0,t)) :: (P.nl) :: (addnls ts)
		
	    fun specs_to_pTl [] = []
	      | specs_to_pTl (spec::rest) =
		let
		  val lines =  case spec of
		    (Absyn.VALspec (sl,_)) => map valspec sl
		  | (Absyn.TYPEspec sl) => map typespec sl
		  | (Absyn.EQTYPEspec sl) => map eqtypespec sl
		  | (Absyn.DATATYPEspec sl) => map datatypespec sl
                  | (Absyn.DATATYPEreplSpec s) => [datareplspec s]
		  | (Absyn.EXCEPTIONspec sl) => map exceptionspec sl
		  | (Absyn.STRUCTUREspec sl) => map structurespec sl
		  | (Absyn.SHARINGspec (spec,sl)) => specs_to_pTl [spec] @@ map (sharingspec o #1) sl
		  | (Absyn.LOCALspec specpair) => [localspec specpair]
		  | (Absyn.OPENspec (strs,_)) => [openspec strs]
		  | (Absyn.INCLUDEspec (sigs,_)) => [includespec sigs]
		  | (Absyn.SEQUENCEspec sl) => [specs_to_prettyT sl]
		in
		  lines @@ (specs_to_pTl rest)
		end
	  in
	    addnls (specs_to_pTl speclist)
	  end

      in
	sigexp_to_T options
      end

    fun sigexp_to_string options sigexp = 
        let val Options.PRINTOPTIONS{maximum_sig_depth,...} = print_options options 
         in P.string_of_T (sigexp_to_prettyT options maximum_sig_depth sigexp) end

    fun print_sigexp options f (result, indent, sigexp) =
        let val Options.PRINTOPTIONS{maximum_sig_depth,...} = print_options options
         in P.reduce f (result, indent, sigexp_to_prettyT options maximum_sig_depth sigexp) end

    fun strexp_to_string options strexp = 
      case strexp of
        Absyn.NEWstrexp strdec => " struct " ^ strdec_to_string options strdec ^ " end"
      | Absyn.OLDstrexp (longstrid,_,_) => IdentPrint.printLongStrId longstrid
      | Absyn.APPstrexp(funid, strexp, _, _, _) => IdentPrint.printFunId funid ^ "(" ^
          (strexp_to_string options strexp) ^ ")"
      | Absyn.LOCALstrexp(strdec, strexp) => (strdec_to_string options strdec) ^
          (strexp_to_string options strexp)
      | Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,_,_) =>
          strexp_to_string options strexp ^ 
          (if abs then " :> " else " : ") ^
          sigexp_to_string options sigexp

    and strdec_to_string options strdec = case strdec of
      Absyn.DECstrdec ord_dec => AbsynPrint.printDec options ord_dec
    | Absyn.STRUCTUREstrdec struc_dec_list =>
      let
        fun struc_dec_list_to_string [] = ""
          | struc_dec_list_to_string((strid, sigexp_opt, strexp, _, _, _, _) :: tl) =
            "(structure " ^ (IdentPrint.printStrId strid) ^ " : " ^
            (case sigexp_opt of
               NONE => ""
             | SOME (sigexp,abs) => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
               (strexp_to_string options strexp) ^ ")" ^ struc_dec_list_to_string(tl)
      in
        struc_dec_list_to_string struc_dec_list
      end
    | Absyn.ABSTRACTIONstrdec struc_dec_list =>
      let
        fun struc_dec_list_to_string [] = ""
          | struc_dec_list_to_string((strid, sigexp_opt, strexp, _, _, _, _) :: tl) =
            "(abstraction " ^ (IdentPrint.printStrId strid) ^ " : " ^
            (case sigexp_opt of
               NONE => ""
             | SOME (sigexp,e) => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
               (strexp_to_string options strexp) ^ ")" ^ struc_dec_list_to_string(tl)
      in
        struc_dec_list_to_string struc_dec_list
      end
    | Absyn.LOCALstrdec(strdec1, strdec2) =>
        "LOCAL " ^ strdec_to_string options strdec1 ^ "IN " ^ strdec_to_string options (strdec2) ^
        "END"
    | Absyn.SEQUENCEstrdec strdec_list =>
        let
          fun strdec_list_to_string [] = ""
            | strdec_list_to_string(hd :: tl) = strdec_to_string options (hd) ^
              strdec_list_to_string tl
        in
          strdec_list_to_string strdec_list
        end
    fun topdec_to_string options (Absyn.STRDECtopdec (strdec,_)) =
                                           strdec_to_string options strdec
      | topdec_to_string options (Absyn.SIGNATUREtopdec (sigbind_list, _)) =
        let
          val Options.PRINTOPTIONS{maximum_sig_depth,...} = print_options options
          fun print_sig_bind(Absyn.SIGBIND sigblist) =
            let
              fun doublelist (id,bind,_) =
                P.string_of_T
                (P.blk(0,[P.str "signature ",
                          P.str (IdentPrint.printSigId id),
                          P.str " = ",
                          P.nl,
			  P.blk(2, [sigexp_to_prettyT options maximum_sig_depth bind])]))
            in
              concat(map doublelist sigblist)
            end
        in
          concat(map print_sig_bind sigbind_list)
        end

      | topdec_to_string options (Absyn.FUNCTORtopdec (funbind_list,_)) =
        let
          fun print_fun_list [] = "()"
            | print_fun_list((Absyn.FUNBIND head) :: tail) =
              let
                fun print_funbind [] = ";"
                  | print_funbind
		      ((funid, strid, sigexp, strexp, sig_opt, _, _, _, _, _) ::
		 	 rest) =
                    "functor " ^ IdentPrint.printFunId funid ^
                    "(" ^ IdentPrint.printStrId strid ^ ": sig)" ^
                    (case sig_opt of NONE => "" | _ => ": sig") ^ "=" ^
                       (strexp_to_string options strexp) ^
                       (print_funbind rest)
              in
                (print_funbind head) ^ (print_fun_list tail)
              end
        in
          print_fun_list funbind_list
        end
      | topdec_to_string options (Absyn.REQUIREtopdec (x, _)) =
        "require \"" ^ x ^ "\""
  end


@


1.43.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.43  1998/03/03  09:58:39  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
@


1.42
log
@Removing reference to MLWorks.Option
@
text
@d4 3
a174 1
    (* print_depth controls the depth of signature expressions displayed.  *)
d180 1
a180 3
    val print_depth = ref 1;

    fun sigexp_to_prettyT options nest_depth =
d185 1
a185 1
	    if nest_depth<(!print_depth)
d191 1
a191 1
	    else P.str "sig...end"
d340 7
a346 3
	  [P.str "structure ",
	   P.str (IdentPrint.printStrId strid),
	   P.str " : sig ... end"]
d430 4
a433 1
    fun sigexp_to_string options = P.string_of_T o (sigexp_to_prettyT options 0)
d435 2
a436 1
        P.reduce f (result, indent, sigexp_to_prettyT options 0 sigexp)
d492 1
d501 1
a501 1
			  P.blk(2, [sigexp_to_prettyT options 0 bind])]))
@


1.42.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 3
 * Revision 1.42  1996/11/22  12:06:43  matthew
 * Removing reference to MLWorks.Option
 *
@


1.42.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 3
 * Revision 1.42  1996/11/22  12:06:43  matthew
 * Removing reference to MLWorks.Option
 *
@


1.42.1.1
log
@branched from 1.42
@
text
@a3 3
 * Revision 1.42  1996/11/22  12:06:43  matthew
 * Removing reference to MLWorks.Option
 *
@


1.42.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.42.1.1  1997/05/12  10:34:34  hope
 * branched from 1.42
 *
@


1.42.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.42.1.1  1997/05/12  10:34:34  hope
 * branched from 1.42
 *
@


1.42.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.42.1.1  1997/05/12  10:34:34  hope
 * branched from 1.42
 *
@


1.42.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.42.1.1.1.1  1997/07/28  18:19:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.41
log
@[Bug #1614]
removing toplevel String.
@
text
@d4 4
d245 1
a245 1
              | string_ty (MLWorks.Option.SOME ty) =
@


1.41.4.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/31  15:53:30  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.41.3.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/31  15:53:30  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.41.3.1.1.1
log
@branched from 1.41.3.1
@
text
@a3 3
 * Revision 1.41.3.1  1996/12/17  17:48:05  hope
 * branched from 1.41
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/31  15:53:30  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a3 4
 * Revision 1.41  1996/10/31  15:53:30  io
 * [Bug #1614]
 * removing toplevel String.
 *
@


1.41.1.1.1.1
log
@branched from 1.41.1.1
@
text
@a3 3
 * Revision 1.41.1.1  1996/11/14  12:49:56  hope
 * branched from 1.41
 *
@


1.40
log
@[Bug #1708]
changing syntax of datatype replication.
@
text
@d4 4
a141 1
require "../utils/lists";
a147 1
  structure Lists : LISTS
d240 1
a240 1
            fun string_ty MLWorks.Option.NONE = []
d324 1
a324 1
	    MLWorks.Option.NONE =>
d327 1
a327 1
	  | MLWorks.Option.SOME typ =>
d447 2
a448 2
               MLWorks.Option.NONE => ""
             | MLWorks.Option.SOME (sigexp,abs) => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d459 2
a460 2
               MLWorks.Option.NONE => ""
             | MLWorks.Option.SOME (sigexp,e) => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d490 1
a490 1
              String.implode(map doublelist sigblist)
d493 1
a493 1
          String.implode(map print_sig_bind sigbind_list)
d507 1
a507 1
                    (case sig_opt of MLWorks.Option.NONE => "" | _ => ": sig") ^ "=" ^
@


1.39
log
@[Bug #1320]
Reverse engineering the derived form for type abbreviation.
Makes printed signatures much nicer.
@
text
@d4 5
d263 1
a263 1
        and datareplspec (location,tyvars,tycon,longtycon,associatedConstructors) =
d265 2
a266 2
            val tycon_str = ptypename (tyvars,tycon)
            val longtycon_str = plongtypename (tyvars,longtycon)
d273 1
a273 1
                                 Absyn.print_type options args
d276 1
d284 2
a285 1
                        | SOME ty => [P.str (string_ty ty)]))
d292 17
d310 2
a311 2
           (P.str "datatype "):: tycon_str @@ 
           (P.str " = datatype ":: longtycon_str) @@
@


1.39.1.1
log
@branched from 1.39
@
text
@a3 5
 * Revision 1.39  1996/10/11  09:29:35  andreww
 * [Bug #1320]
 * Reverse engineering the derived form for type abbreviation.
 * Makes printed signatures much nicer.
 *
@


1.38
log
@[Bug #1622]
Change to signature absyn
@
text
@d4 4
d181 18
a198 3
          | sigexp_to_T options (Absyn.WHEREsigexp (sigexp,_)) =
            P.blk (0,[sigexp_to_T options sigexp,
                      P.str " where ..."])
d340 21
a360 2
	and includespec(sigexp) =
	  (P.str "include ") :: [sigexp_to_T options sigexp]
@


1.38.1.1
log
@branched from 1.38
@
text
@a3 4
 * Revision 1.38  1996/10/04  11:12:27  matthew
 * [Bug #1622]
 * Change to signature absyn
 *
@


1.37
log
@[Bug #1577]
Adding extra clause for the new abstract syntax for
datatype replication in signatures.
@
text
@d4 5
d221 1
a221 1
            fun valty (valid,tyopt) =
d252 1
a252 1
            fun valty (valid,tyopt) =
@


1.36
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml (essentially
just passing options rather than print_options).
@
text
@d4 5
d138 2
d146 1
d189 1
a189 1
	     [P.brk 1,
d192 9
d208 5
a212 4
	    fun string_ty MLWorks.Option.NONE = []
	      | string_ty (MLWorks.Option.SOME ty) =
		[P.blk(4, [P.str" of ",
			   P.str (AbsynPrint.unparseTy 
d214 3
a216 1
	    fun valty (valid,tyopt) =
d222 6
a228 4
	    fun do_contypes[] = []
	      | do_contypes[x] = [valty x]
	      | do_contypes(x :: xs) =
		P.blk(0, [valty x, P.str" |"]) :: do_contypes xs
d234 38
d334 1
@


1.36.1.1
log
@branched from 1.36
@
text
@a3 5
 * Revision 1.36  1996/08/05  18:07:39  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml (essentially
 * just passing options rather than print_options).
 *
@


1.35
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d140 3
d148 1
a148 1
    (* that types can be printed nicely.					 *)
d170 1
a170 1
	   P.str (IdentPrint.printValId options valid),
d173 1
a173 1
	   P.blk(4,[P.str (AbsynPrint.unparseTy options ty)])]
d194 2
a195 1
			   P.str (AbsynPrint.unparseTy options ty)])]
d199 2
a200 1
		    P.str (IdentPrint.printValId options valid) ::
d216 1
a216 1
	       P.str (IdentPrint.printValId options valid)]
d219 1
a219 1
	       P.str (IdentPrint.printValId options valid),
d222 2
a223 1
	       P.blk(0,[P.str(AbsynPrint.unparseTy options typ)])]
d346 2
a347 1
    fun topdec_to_string options (Absyn.STRDECtopdec (strdec,_)) = strdec_to_string options strdec
d389 2
@


1.34
log
@Changes to WHEREsigexp
@
text
@d4 3
d347 1
a347 1
              implode(map doublelist sigblist)
d350 1
a350 1
          implode(map print_sig_bind sigbind_list)
@


1.33
log
@Language changes
@
text
@d4 3
d152 3
a154 2
          | sigexp_to_T options (Absyn.WHEREsigexp sigexp) =
            sigexp_to_T options sigexp
d255 1
a255 1
		    (Absyn.VALspec sl) => map valspec sl
d261 1
a261 1
		  | (Absyn.SHARINGspec sl) => map (sharingspec o #1) sl
d289 1
a289 1
      | Absyn.CONSTRAINTstrexp (strexp,sigexp,abs,_) =>
@


1.32
log
@Added location information to Absyn.SIGNATUREtopdec.
@
text
@d4 3
d149 2
d237 2
a238 4
	and includespec(sigids) =
	  (P.str "include ") ::
	  (P.lst ("",[P.brk 1],"")
	   (map (P.str o IdentPrint.printSigId) sigids))
d277 12
a288 7
    fun strexp_to_string options strexp = case strexp of
      Absyn.NEWstrexp strdec => " struct " ^ strdec_to_string options strdec ^ " end"
    | Absyn.OLDstrexp (longstrid,_,_) => IdentPrint.printLongStrId longstrid
    | Absyn.APPstrexp(funid, strexp, _, _, _) => IdentPrint.printFunId funid ^ "(" ^
      (strexp_to_string options strexp) ^ ")"
    | Absyn.LOCALstrexp(strdec, strexp) => (strdec_to_string options strdec) ^
      (strexp_to_string options strexp)
d299 1
a299 1
             | MLWorks.Option.SOME sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d311 1
a311 1
             | MLWorks.Option.SOME sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
@


1.31
log
@Removing Option in favour of MLWorks.Option
@
text
@d4 3
d320 1
a320 1
      | topdec_to_string options (Absyn.SIGNATUREtopdec sigbind_list) =
@


1.30
log
@Changed Absyn.REQUIREtopdec to take a string instead of a module_id.
@
text
@d4 3
d167 2
a168 2
	    fun string_ty Absyn.Option.ABSENT = []
	      | string_ty (Absyn.Option.PRESENT ty) =
d188 1
a188 1
	    Absyn.Option.ABSENT =>
d191 1
a191 1
	  | Absyn.Option.PRESENT typ =>
d287 2
a288 2
               Absyn.Option.ABSENT => ""
             | Absyn.Option.PRESENT sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d299 2
a300 2
               Absyn.Option.ABSENT => ""
             | Absyn.Option.PRESENT sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d346 1
a346 1
                    (case sig_opt of Absyn.Option.ABSENT => "" | _ => ": sig") ^ "=" ^
@


1.29
log
@Debugger structure, and structure recording for Modules Debugger.
@
text
@d4 3
a100 1
require "../basics/module_id";
a108 1
  structure ModuleId : MODULE_ID  
a111 1
  sharing type ModuleId.ModuleId = AbsynPrint.Absyn.ModuleId
d353 1
a353 1
        "require \"" ^ ModuleId.string x ^ "\""
@


1.28
log
@Change to print moduleids.
@
text
@d4 3
d270 2
a271 2
    | Absyn.OLDstrexp (longstrid,_) => IdentPrint.printLongStrId longstrid
    | Absyn.APPstrexp(funid, strexp, _, _) => IdentPrint.printFunId funid ^ "(" ^
d281 1
a281 1
          | struc_dec_list_to_string((strid, sigexp_opt, strexp, _, _) :: tl) =
d293 1
a293 1
          | struc_dec_list_to_string((strid, sigexp_opt, strexp, _, _) :: tl) =
d339 1
a339 1
		      ((funid, strid, sigexp, strexp, sig_opt, _, _, _) ::
@


1.28.1.1
log
@Fork for bug fixing
@
text
@a3 3
Revision 1.28  1993/08/12  16:32:25  daveb
Change to print moduleids.

@


1.27
log
@structure Option.
@
text
@d4 3
d95 1
d104 1
d108 1
a264 9

  (* Pretty Printing of structure expressions....
    fun strexp_to_prettyT strexp =
        case strexp of
            Absyn.NEWstrexp strdec =>
                P.blk(0,[P.str "struct",
                         P.blk(2,[P.brk 1,
  *)

d350 1
a350 1
        "require \"" ^ x ^ "\""
@


1.26
log
@Added field to some topdecs to indicate when signature matching is required
to match an exception against a value specification.
@
text
@d4 4
d155 2
a156 2
	    fun string_ty Absyn.ABSENT = []
	      | string_ty (Absyn.PRESENT ty) =
d176 1
a176 1
	    Absyn.ABSENT =>
d179 1
a179 1
	  | Absyn.PRESENT typ =>
d284 2
a285 2
               Absyn.ABSENT => ""
             | Absyn.PRESENT sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d296 2
a297 2
               Absyn.ABSENT => ""
             | Absyn.PRESENT sigexp => "\n" ^ sigexp_to_string options sigexp) ^ "\n = " ^
d343 1
a343 1
                    (case sig_opt of Absyn.ABSENT => "" | _ => ": sig") ^ "=" ^
@


1.25
log
@Added code for abstractions.
@
text
@d4 3
d267 1
a267 1
    | Absyn.APPstrexp(funid, strexp,_) => IdentPrint.printFunId funid ^ "(" ^
d277 1
a277 1
          | struc_dec_list_to_string((strid, sigexp_opt, strexp,_) :: tl) =
d289 1
a289 1
          | struc_dec_list_to_string((strid, sigexp_opt, strexp,_) :: tl) =
d334 3
a336 1
                  | print_funbind((funid, strid, sigexp, strexp, sig_opt,_,_) :: rest) =
@


1.24
log
@Options & Info changes
Absyn changes
@
text
@d4 4
d276 12
@


1.23
log
@Removed ref nameset in Absyn.FunBind
@
text
@d4 3
d90 2
a91 2
  sharing AbsynPrint.Absyn.Datatypes.Ident = IdentPrint.Ident
  sharing AbsynPrint.Info = IdentPrint.Info
d97 1
a97 1
    structure Info  = IdentPrint.Info
@


1.22
log
@Improved format of printing for exception sepcifications in signatures
@
text
@d4 3
d312 1
a312 1
                  | print_funbind((funid, strid, sigexp, _, strexp, sig_opt,_,_) :: rest) =
@


1.21
log
@Modified printing of signatures to look pretty and aligned
@
text
@d4 3
d158 10
a167 9
	  [P.str "exception ",
	   P.str (IdentPrint.printValId options valid),
	   P.str " :",
	   P.brk 1,
	   P.blk(0,[P.str (case typopt of
			     Absyn.ABSENT => "exn"
			   | Absyn.PRESENT typ =>
			       (AbsynPrint.unparseTy options typ) ^ " -> exn")
		    ])]
@


1.20
log
@Removed a number of duplicated signatures and structures
@
text
@d4 3
d100 11
a110 11
        let
            fun sigexp_to_T options (Absyn.OLDsigexp(sigid,_,_)) =
                P.str (IdentPrint.printSigId sigid)
              | sigexp_to_T options (Absyn.NEWsigexp(topspec, _)) =
                if nest_depth<(!print_depth)
                    then P.blk(0,[P.str "sig",
                                  P.blk(1,(fn []=>[] | x => P.nl :: x)
                                          (specs_to_prettyT [topspec])),
                                  P.nl,
                                  P.str "end"])
                else P.str "sig...end"
d112 6
a117 6
            and valspec(valid,ty,tyvars) =
                [P.str "val ",
                 P.str (IdentPrint.printValId options valid),
                 P.str " :",
                 P.brk 1,
                 P.blk(4,[P.str (AbsynPrint.unparseTy options ty)])]
d119 8
a126 8
            and ptypename(tyvars, tycon) =
                (case tyvars of
                     [] => []
                   | [tv] => [P.str (IdentPrint.printTyVar tv)]
                   | _ => (P.lst ("(",[P.str ",", P.brk 1],")")
                           (map (P.str o IdentPrint.printTyVar) tyvars))) @@
                     [P.brk 1,
                      P.str (IdentPrint.printTyCon tycon)]
d128 1
a128 1
            and typespec ts = (P.str "type ") :: (ptypename ts)
d130 1
a130 1
            and eqtypespec ts = (P.str "eqtype ") :: (ptypename ts)
d132 12
a143 16
            and datatypespec(tyvars,tycon,valtys) =
                let val tycon_str = ptypename (tyvars,tycon)
                    fun string_ty Absyn.ABSENT = []
                    |   string_ty (Absyn.PRESENT ty) =
                          [P.blk(4, P.str (AbsynPrint.unparseTy options ty) ::
                                    P.str " -> " ::
                                    tycon_str)]
                    fun valty (valid,tyopt) =
                      P.nl ::
                      P.str "val " ::
                      P.str (IdentPrint.printValId options valid) ::
                      P.str " : " ::
                      string_ty tyopt
                in (P.str "datatype ") :: tycon_str
                   @@ Lists.reducer (op @@) (map valty valtys, [])
                end
d145 4
a148 10
            and exceptionspec(valid, typopt,_) =
                [P.str "exception ",
                 P.str (IdentPrint.printValId options valid),
                 P.str " :",
                 P.brk 1,
                 P.blk(0,[P.str (case typopt of
                                     Absyn.ABSENT => "exn"
                                   | Absyn.PRESENT typ =>
                                         (AbsynPrint.unparseTy options typ) ^ " -> exn")
                          ])]
d150 3
a152 4
            and structurespec(strid, sigexp) =
                [P.str "structure ",
                 P.str (IdentPrint.printStrId strid),
                 P.str " : sig ... end"]
d154 10
a163 4
            and sharingspec(Absyn.STRUCTUREshareq strids) =
                (P.str "sharing ") ::
                (P.lst ("", [P.brk 1, P.str "= "],"")
                 (map (P.str o IdentPrint.printLongStrId) strids))
d165 4
a168 4
              | sharingspec(Absyn.TYPEshareq tycons) =
                (P.str "sharing type ") ::
                (P.lst ("", [P.brk 1, P.str "= "],"")
                 (map (P.str o IdentPrint.printLongTyCon) tycons))
d170 4
a173 10
            and localspec(spec1,spec2) =
                [P.blk (0, [P.str "local",
                            P.blk(1, [P.nl] @@
                                  (specs_to_prettyT [spec1])),
                            P.nl,
                            P.str "in",
                            P.blk (1, [P.nl] @@
                                   (specs_to_prettyT [spec2])),
                            P.nl,
                            P.str "end"])]
d175 4
a178 4
            and openspec(strids) =
                (P.str "open ") ::
                (P.lst ("",[P.brk 1],"")
                 (map (P.str o IdentPrint.printLongStrId) strids))
d180 10
a189 4
            and includespec(sigids) =
                (P.str "include ") ::
                (P.lst ("",[P.brk 1],"")
                 (map (P.str o IdentPrint.printSigId) sigids))
d191 4
a194 6
            and specs_to_prettyT speclist =
                let
                  fun addnls [] = []
                    | addnls ([]::ts) = addnls ts
                    | addnls [t] = [P.blk(0,t)]
                    | addnls (t::ts) = (P.blk(0,t)) :: (P.nl) :: (addnls ts)
d196 37
a232 21
                  fun specs_to_pTl [] = []
                    | specs_to_pTl (spec::rest) =
                      let
                        val lines =  case spec of
                          (Absyn.VALspec sl) => map valspec sl
                        | (Absyn.TYPEspec sl) => map typespec sl
                        | (Absyn.EQTYPEspec sl) => map eqtypespec sl
                        | (Absyn.DATATYPEspec sl) => map datatypespec sl
                        | (Absyn.EXCEPTIONspec sl) => map exceptionspec sl
                        | (Absyn.STRUCTUREspec sl) => map structurespec sl
                        | (Absyn.SHARINGspec sl) => map (sharingspec o #1) sl
                        | (Absyn.LOCALspec specpair) => [localspec specpair]
                        | (Absyn.OPENspec (strs,_)) => [openspec strs]
                        | (Absyn.INCLUDEspec (sigs,_)) => [includespec sigs]
                        | (Absyn.SEQUENCEspec sl) => [specs_to_prettyT sl]
                      in
                        lines @@ (specs_to_pTl rest)
                      end
                in
                  addnls (specs_to_pTl speclist)
                end
a233 4
        in
            sigexp_to_T options
        end

d291 1
a291 2
                          P.str "  ",
                          sigexp_to_prettyT options 0 bind]))
@


1.19
log
@Fixed bug in signature printing
@
text
@d4 3
a66 1
require "../basics/absyn";
a74 1
  structure Absyn : ABSYN
d78 1
a78 2
  sharing Absyn.IdentClass = IdentPrint.Ident
  sharing Absyn = AbsynPrint.Absyn
d83 1
a83 1
    structure Absyn = Absyn;
@


1.18
log
@Changes to make show_id_class and show_eq_info part of Info structure
instead of references.
@
text
@d4 4
d103 1
a103 2
                                  P.nl,
                                  P.blk(4,(fn []=>[] | x => [P.str "  "] @@ x)
@


1.17
log
@Added location information to the `require' topdec.
@
text
@d4 3
d66 12
a77 9
functor TopdecPrint (structure Lists : LISTS
                     structure Pretty : PRETTY
                     structure Absyn : ABSYN
                     structure AbsynPrint : ABSYNPRINT
                     structure IdentPrint : IDENTPRINT

                     sharing Absyn.IdentClass = IdentPrint.Ident
                     sharing Absyn = AbsynPrint.Absyn) : TOPDECPRINT =
  struct
d81 1
a81 2

    val show_id_class = IdentPrint.show_id_class;
d92 1
a92 1
    fun sigexp_to_prettyT nest_depth =
d94 1
a94 1
            fun sigexp_to_T (Absyn.OLDsigexp(sigid,_,_)) =
d96 1
a96 1
              | sigexp_to_T (Absyn.NEWsigexp(topspec, _)) =
d108 1
a108 1
                 P.str (IdentPrint.printValId valid),
d111 1
a111 1
                 P.blk(4,[P.str (AbsynPrint.unparseTy ty)])]
d130 1
a130 1
                          [P.blk(4, P.str (AbsynPrint.unparseTy ty) ::
d136 1
a136 1
                      P.str (IdentPrint.printValId valid) ::
d145 1
a145 1
                 P.str (IdentPrint.printValId valid),
d151 1
a151 1
                                         (AbsynPrint.unparseTy typ) ^ " -> exn")
d220 1
a220 1
            sigexp_to_T
d223 3
a225 3
    val sigexp_to_string = P.string_of_T o (sigexp_to_prettyT 0)
    fun print_sigexp f (result, indent, sigexp) =
        P.reduce f (result, indent, sigexp_to_prettyT 0 sigexp)
d236 2
a237 2
    fun strexp_to_string strexp = case strexp of
      Absyn.NEWstrexp strdec => " struct " ^ strdec_to_string strdec ^ " end"
d240 3
a242 3
      (strexp_to_string strexp) ^ ")"
    | Absyn.LOCALstrexp(strdec, strexp) => (strdec_to_string strdec) ^
      (strexp_to_string strexp)
d244 2
a245 2
    and strdec_to_string strdec = case strdec of
      Absyn.DECstrdec ord_dec => AbsynPrint.printDec ord_dec
d253 2
a254 2
             | Absyn.PRESENT sigexp => "\n" ^ sigexp_to_string sigexp) ^ "\n = " ^
               (strexp_to_string strexp) ^ ")" ^ struc_dec_list_to_string(tl)
d259 1
a259 1
        "LOCAL " ^ strdec_to_string strdec1 ^ "IN " ^ strdec_to_string(strdec2) ^
d264 1
a264 1
            | strdec_list_to_string(hd :: tl) = strdec_to_string(hd) ^
d269 2
a270 2
    fun topdec_to_string(Absyn.STRDECtopdec (strdec,_)) = strdec_to_string strdec
      | topdec_to_string(Absyn.SIGNATUREtopdec sigbind_list) =
d281 1
a281 1
                          sigexp_to_prettyT 0 bind]))
d289 1
a289 1
      | topdec_to_string(Absyn.FUNCTORtopdec (funbind_list,_)) =
d299 1
a299 1
                       (strexp_to_string strexp) ^
d307 1
a307 1
      | topdec_to_string(Absyn.REQUIREtopdec (x, _)) =
@


1.16
log
@Added print_sigexp using Pretty.reduce.
@
text
@d4 3
d302 1
a302 1
      | topdec_to_string(Absyn.REQUIREtopdec x) =
@


1.15
log
@Fixed bug in printing of datatype specs.
@
text
@d4 3
d60 187
a246 199
functor TopdecPrint(
  structure Lists : LISTS
  structure Pretty : PRETTY
  structure Absyn : ABSYN
  structure AbsynPrint : ABSYNPRINT
  structure IdentPrint : IDENTPRINT

  sharing Absyn.IdentClass = IdentPrint.Ident
  sharing Absyn = AbsynPrint.Absyn
  ) : TOPDECPRINT =
struct

  structure Absyn = Absyn;
  structure P     = Pretty;

  val show_id_class = IdentPrint.show_id_class;

  (* Pretty Printing of signature specifications:  An Early Attempt!     *)
  (* print_depth controls the depth of signature expressions displayed.  *)
  (* Ideally, we should have a pretty-printer that provides consistent   *)
  (* breaks which would replace much of the use of newlines (P.nl) here. *)
  (* Also, routines in AbsynPrint should use the pretty printer too, so  *)
  (* that types can be printed nicely.					 *)

  val print_depth = ref 1;

  fun sigexp_to_prettyT nest_depth = 
      let 
	  fun sigexp_to_T (Absyn.OLDsigexp(sigid,_,_)) = 
	      P.str (IdentPrint.printSigId sigid)
	    | sigexp_to_T (Absyn.NEWsigexp(topspec, _)) =
	      if nest_depth<(!print_depth) 
		  then P.blk(0,[P.str "sig",
				P.nl,
				P.blk(4,(fn []=>[] | x => [P.str "  "] @@ x)
				        (specs_to_prettyT [topspec])),
				P.nl,
				P.str "end"])
	      else P.str "sig...end"

	  and valspec(valid,ty,tyvars) =
	      [P.str "val ",
	       P.str (IdentPrint.printValId valid),
	       P.str " :",
	       P.brk 1,
	       P.blk(4,[P.str (AbsynPrint.unparseTy ty)])]
	      
	  and ptypename(tyvars, tycon) =
	      (case tyvars of
		   [] => []
		 | [tv] => [P.str (IdentPrint.printTyVar tv)]
		 | _ => (P.lst ("(",[P.str ",", P.brk 1],")") 
			 (map (P.str o IdentPrint.printTyVar) tyvars))) @@
		   [P.brk 1,
		    P.str (IdentPrint.printTyCon tycon)]
	      
	  and typespec ts = (P.str "type ") :: (ptypename ts)
	      
	  and eqtypespec ts = (P.str "eqtype ") :: (ptypename ts)
	      
	  and datatypespec(tyvars,tycon,valtys) =
	      let val tycon_str = ptypename (tyvars,tycon)
	          fun string_ty Absyn.ABSENT = []
		  |   string_ty (Absyn.PRESENT ty) =
			[P.blk(4, P.str (AbsynPrint.unparseTy ty) ::
				  P.str " -> " ::
				  tycon_str)]
	          fun valty (valid,tyopt) =
		    P.nl ::
		    P.str "val " ::
		    P.str (IdentPrint.printValId valid) ::
		    P.str " : " ::
		    string_ty tyopt
	      in (P.str "datatype ") :: tycon_str
	         @@ Lists.reducer (op @@) (map valty valtys, [])
	      end
	      
	  and exceptionspec(valid, typopt,_) = 
	      [P.str "exception ",
	       P.str (IdentPrint.printValId valid),
	       P.str " :",
	       P.brk 1,
	       P.blk(0,[P.str (case typopt of 
				   Absyn.ABSENT => "exn"
				 | Absyn.PRESENT typ => 
				       (AbsynPrint.unparseTy typ) ^ " -> exn")
			])]

	  and structurespec(strid, sigexp) = 
	      [P.str "structure ",
	       P.str (IdentPrint.printStrId strid),
	       P.str " : sig ... end"]
	      
	  and sharingspec(Absyn.STRUCTUREshareq strids) = 
	      (P.str "sharing ") ::
	      (P.lst ("", [P.brk 1, P.str "= "],"")
	       (map (P.str o IdentPrint.printLongStrId) strids))
	      
	    | sharingspec(Absyn.TYPEshareq tycons) = 
	      (P.str "sharing type ") ::
	      (P.lst ("", [P.brk 1, P.str "= "],"")
	       (map (P.str o IdentPrint.printLongTyCon) tycons))
	      
	  and localspec(spec1,spec2) = 
	      [P.blk (0, [P.str "local",
			  P.blk(1, [P.nl] @@ 
				(specs_to_prettyT [spec1])),
			  P.nl,
			  P.str "in",
			  P.blk (1, [P.nl] @@ 
				 (specs_to_prettyT [spec2])),
			  P.nl,
			  P.str "end"])]

	  and openspec(strids) = 
	      (P.str "open ") ::
	      (P.lst ("",[P.brk 1],"") 
	       (map (P.str o IdentPrint.printLongStrId) strids))

	  and includespec(sigids) = 
	      (P.str "include ") ::
	      (P.lst ("",[P.brk 1],"")
	       (map (P.str o IdentPrint.printSigId) sigids))

	  and specs_to_prettyT speclist =
	      let 
		fun addnls [] = []
		  | addnls ([]::ts) = addnls ts
		  | addnls [t] = [P.blk(0,t)]
		  | addnls (t::ts) = (P.blk(0,t)) :: (P.nl) :: (addnls ts)

		fun specs_to_pTl [] = []
		  | specs_to_pTl (spec::rest) = 
		    let 
		      val lines =  case spec of 
			(Absyn.VALspec sl) => map valspec sl
		      | (Absyn.TYPEspec sl) => map typespec sl
		      | (Absyn.EQTYPEspec sl) => map eqtypespec sl
		      | (Absyn.DATATYPEspec sl) => map datatypespec sl
		      | (Absyn.EXCEPTIONspec sl) => map exceptionspec sl
		      | (Absyn.STRUCTUREspec sl) => map structurespec sl
		      | (Absyn.SHARINGspec sl) => map (sharingspec o #1) sl
		      | (Absyn.LOCALspec specpair) => [localspec specpair]
		      | (Absyn.OPENspec (strs,_)) => [openspec strs]
		      | (Absyn.INCLUDEspec (sigs,_)) => [includespec sigs]
		      | (Absyn.SEQUENCEspec sl) => [specs_to_prettyT sl]
		    in 
		      lines @@ (specs_to_pTl rest)
		    end
	      in 
		addnls (specs_to_pTl speclist)
	      end
	       
      in 
	  sigexp_to_T
      end;

  val sigexp_to_string = P.string_of_T o (sigexp_to_prettyT 0);
	


(* Pretty Printing of structure expressions....
  fun strexp_to_prettyT strexp = 
      case strexp of
	  Absyn.NEWstrexp strdec => 
	      P.blk(0,[P.str "struct",
	               P.blk(2,[P.brk 1,
*)

  fun strexp_to_string strexp = case strexp of
    Absyn.NEWstrexp strdec => " struct " ^ strdec_to_string strdec ^ " end"
  | Absyn.OLDstrexp (longstrid,_) => IdentPrint.printLongStrId longstrid
  | Absyn.APPstrexp(funid, strexp,_) => IdentPrint.printFunId funid ^ "(" ^
    (strexp_to_string strexp) ^ ")"
  | Absyn.LOCALstrexp(strdec, strexp) => (strdec_to_string strdec) ^
    (strexp_to_string strexp)

  and strdec_to_string strdec = case strdec of
    Absyn.DECstrdec ord_dec => AbsynPrint.printDec ord_dec
  | Absyn.STRUCTUREstrdec struc_dec_list =>
    let
      fun struc_dec_list_to_string [] = ""
        | struc_dec_list_to_string((strid, sigexp_opt, strexp,_) :: tl) =
          "(structure " ^ (IdentPrint.printStrId strid) ^ " : " ^
          (case sigexp_opt of
             Absyn.ABSENT => ""
           | Absyn.PRESENT sigexp => "\n" ^ sigexp_to_string sigexp) ^ "\n = " ^
             (strexp_to_string strexp) ^ ")" ^ struc_dec_list_to_string(tl)
    in
      struc_dec_list_to_string struc_dec_list
    end
  | Absyn.LOCALstrdec(strdec1, strdec2) =>
      "LOCAL " ^ strdec_to_string strdec1 ^ "IN " ^ strdec_to_string(strdec2) ^
      "END"
  | Absyn.SEQUENCEstrdec strdec_list =>
      let 
        fun strdec_list_to_string [] = ""
          | strdec_list_to_string(hd :: tl) = strdec_to_string(hd) ^
            strdec_list_to_string tl
d248 1
a248 1
        strdec_list_to_string strdec_list
d250 15
a264 24
  fun topdec_to_string(Absyn.STRDECtopdec (strdec,_)) = strdec_to_string strdec
    | topdec_to_string(Absyn.SIGNATUREtopdec sigbind_list) =
      let 
        fun print_sig_bind(Absyn.SIGBIND sigblist) =
          let
            fun doublelist (id,bind,_) = 
              P.string_of_T 
              (P.blk(0,[P.str "signature ",
                        P.str (IdentPrint.printSigId id),
                        P.str " = ",
                        P.nl,
                        P.str "  ",
                        sigexp_to_prettyT 0 bind]))
          in
            implode(map doublelist sigblist)
          end
      in 
        implode(map print_sig_bind sigbind_list)
      end
    
    | topdec_to_string(Absyn.FUNCTORtopdec (funbind_list,_)) =
      let
        fun print_fun_list [] = "()"
          | print_fun_list((Absyn.FUNBIND head) :: tail) =
d266 8
a273 7
              fun print_funbind [] = ";"
                | print_funbind((funid, strid, sigexp, _, strexp, sig_opt,_,_) :: rest) =
                  "functor " ^ IdentPrint.printFunId funid ^
                  "(" ^ IdentPrint.printStrId strid ^ ": sig)" ^
                  (case sig_opt of Absyn.ABSENT => "" | _ => ": sig") ^ "=" ^
                     (strexp_to_string strexp) ^
                     (print_funbind rest)
d275 1
a275 1
              (print_funbind head) ^ (print_fun_list tail)
d277 25
a301 6
      in
        print_fun_list funbind_list
      end
    | topdec_to_string(Absyn.REQUIREtopdec x) =
      "require \"" ^ x ^ "\""
end
@


1.14
log
@Improved printing of datatypes and substructures.
@
text
@d4 3
d118 6
a123 3
	      let fun ty_str Absyn.ABSENT = []
		  |   ty_str (Absyn.PRESENT ty) =
			[P.blk(4,[P.str (AbsynPrint.unparseTy ty)])]
d128 3
a130 2
		    ty_str tyopt
	      in (P.str "datatype ") :: (ptypename (tyvars,tycon))
@


1.13
log
@Changes to absyn
@
text
@d4 3
d47 1
d55 1
d69 1
d104 1
d114 12
a125 2
	  and datatypespec(tyvars, tycon, valtys) =
	      (P.str "datatype ") :: (ptypename (tyvars,tycon))
d141 1
a141 2
	       P.str " : ",
	       sigexp_to_prettyT (nest_depth+1) sigexp]
@


1.12
log
@Added marks to some of the abstract syntax
@
text
@d4 3
d76 1
a76 1
	  fun sigexp_to_T (Absyn.OLDsigexp(sigid,_)) = 
d177 2
a178 2
		      | (Absyn.OPENspec strs) => [openspec strs]
		      | (Absyn.INCLUDEspec sigs) => [includespec sigs]
d205 1
a205 1
  | Absyn.OLDstrexp longstrid => IdentPrint.printLongStrId longstrid
@


1.11
log
@First version of the profiler
@
text
@d4 3
d107 1
a107 1
	  and exceptionspec(valid, typopt) = 
d172 1
a172 1
		      | (Absyn.SHARINGspec sl) => map sharingspec sl
d203 1
a203 1
  | Absyn.APPstrexp(funid, strexp) => IdentPrint.printFunId funid ^ "(" ^
d211 8
a218 7
    let fun struc_dec_list_to_string [] = ""
    | struc_dec_list_to_string((strid, sigexp_opt, strexp) :: tl) =
      "(structure " ^ (IdentPrint.printStrId strid) ^ " : " ^
      (case sigexp_opt of
	 Absyn.ABSENT => ""
       | Absyn.PRESENT sigexp => "\n" ^ sigexp_to_string sigexp) ^ "\n = " ^
	 (strexp_to_string strexp) ^ ")" ^ struc_dec_list_to_string(tl)
d223 2
a224 2
    "LOCAL " ^ strdec_to_string strdec1 ^ "IN " ^ strdec_to_string(strdec2) ^
    "END"
d226 47
a272 46
    let fun strdec_list_to_string [] = ""
    | strdec_list_to_string(hd :: tl) = strdec_to_string(hd) ^
      strdec_list_to_string tl
    in
      strdec_list_to_string strdec_list
    end
  fun topdec_to_string(Absyn.STRDECtopdec strdec) = strdec_to_string strdec
  | topdec_to_string(Absyn.SIGNATUREtopdec sigbind_list) =
    let 
      fun print_sig_bind(Absyn.SIGBIND sigblist) =
	let
	  fun doublelist (id,bind) = 
	    P.string_of_T 
	    (P.blk(0,[P.str "signature ",
		      P.str (IdentPrint.printSigId id),
		      P.str " = ",
		      P.nl,
		      P.str "  ",
		      sigexp_to_prettyT 0 bind]))
	in
	  implode(map doublelist sigblist)
	end
    in 
      implode(map print_sig_bind sigbind_list)
    end
  
  | topdec_to_string(Absyn.FUNCTORtopdec funbind_list) =
    let
      fun print_fun_list [] = "()"
      | print_fun_list((Absyn.FUNBIND head) :: tail) =
	let
	  fun print_funbind [] = ";"
	  | print_funbind((funid, strid, sigexp, _, strexp, sig_opt,_) :: rest) =
	    "functor " ^ IdentPrint.printFunId funid ^
	    "(" ^ IdentPrint.printStrId strid ^ ": sig)" ^
	    (case sig_opt of Absyn.ABSENT => "" | _ => ": sig") ^ "=" ^
	       (strexp_to_string strexp) ^
	       (print_funbind rest)
	in
	  (print_funbind head) ^ (print_fun_list tail)
	end
    in
      print_fun_list funbind_list
    end
  | topdec_to_string(Absyn.REQUIREtopdec x) =
    "require \"" ^ x ^ "\""
@


1.10
log
@Removed use of pervasive fold (now done by implode). Removed use of
word require from a pattern (it's a reserved word). Tidied up slightly.
@
text
@d4 4
d254 1
a254 1
	  | print_funbind((funid, strid, sigexp, _, strexp, sig_opt) :: rest) =
@


1.9
log
@Added printing of REQUIREtopdec
@
text
@d3 4
a6 1
$Log:	_topdecprint.sml,v $
d224 26
a249 23
  fun topdec_to_string topdec = case topdec of
      Absyn.STRDECtopdec strdec => strdec_to_string strdec

    | Absyn.SIGNATUREtopdec sigbind_list =>
      let 
	  fun print_sig_bind(Absyn.SIGBIND sigblist) =
	      let fun doublelist (id,bind) = 
	          P.string_of_T 
		  (P.blk(0,[P.str "signature ",
			    P.str (IdentPrint.printSigId id),
			    P.str " = ",
			    P.nl,
			    P.str "  ",
			    sigexp_to_prettyT 0 bind]))
	      in (fold (op ^) (map doublelist sigblist)) "" end
      in 
	  fold (op ^) (map print_sig_bind sigbind_list) ""   (********)
      end

    | Absyn.FUNCTORtopdec funbind_list =>
      let fun print_fun_list [] = "()"
	| print_fun_list((Absyn.FUNBIND head) :: tail) =
	let fun print_funbind [] = ";"
d251 5
a255 5
	  "functor " ^ IdentPrint.printFunId funid ^
	  "(" ^ IdentPrint.printStrId strid ^ ": sig)" ^
	  (case sig_opt of Absyn.ABSENT => "" | _ => ": sig") ^ "=" ^
	  (strexp_to_string strexp) ^
	  (print_funbind rest)
d259 5
a263 6
      in
	print_fun_list funbind_list
      end
    | Absyn.REQUIREtopdec require =>
      "require \"" ^ require ^ "\""

a264 1

@


1.8
log
@Removed opens
@
text
@d4 3
d257 1
a257 1
      "Can't print REQUIREtopdec yet "
@


1.7
log
@Altered type-arg printing to conform with tidied version in Absynprint.
@
text
@d4 3
d151 15
a165 17
		    let open Absyn in
		      let 
			  val lines =  case spec of 
			      (VALspec sl) => map valspec sl
			    | (TYPEspec sl) => map typespec sl
			    | (EQTYPEspec sl) => map eqtypespec sl
			    | (DATATYPEspec sl) => map datatypespec sl
			    | (EXCEPTIONspec sl) => map exceptionspec sl
			    | (STRUCTUREspec sl) => map structurespec sl
			    | (SHARINGspec sl) => map sharingspec sl
			    | (LOCALspec specpair) => [localspec specpair]
			    | (OPENspec strs) => [openspec strs]
			    | (INCLUDEspec sigs) => [includespec sigs]
			    | (SEQUENCEspec sl) => [specs_to_prettyT sl]
		      in 
	                 lines @@ (specs_to_pTl rest)
		      end
d168 1
a168 1
		  addnls (specs_to_pTl speclist)
@


1.6
log
@Added missing require (not my fault, honest!).
@
text
@d4 3
d77 6
a82 4
	      (P.lst ("(",[P.str ",", P.brk 1],")") 
	       (map (P.str o IdentPrint.printTyVar) tyvars)) @@
	      [P.brk 1,
	       P.str (IdentPrint.printTyCon tycon)]
@


1.5
log
@Added pretty-printing for signature expressions, provisionally.
@
text
@d4 3
d23 1
@


1.4
log
@Added some spaces to improve output
@
text
@d4 3
d22 1
d25 1
a33 1
  structure Absyn = Absyn
d35 2
a36 3
  fun sigexp_to_string sigexp = case sigexp of
    Absyn.NEWsigexp(spec, _) => "Can't print sigid specs yet "
  | Absyn.OLDsigexp(sigid, _) => IdentPrint.printSigId sigid
d38 139
d190 1
a190 1
      "(structure " ^ (IdentPrint.printStrId strid) ^ " = " ^
d193 1
a193 1
       | Absyn.PRESENT sigexp => sigexp_to_string sigexp) ^
d210 1
d212 15
a226 1
      "Can't print SIGNATUREtopdec yet "
@


1.3
log
@Minor mods
@
text
@d4 3
d32 1
a32 1
    Absyn.NEWsigexp(spec, _) => "Can't print sigid specs yet"
d69 1
a69 1
      "Can't print SIGNATUREtopdec yet"
d87 1
a87 1
      "Can't print REQUIREtopdec yet"
@


1.2
log
@Fixed errors
@
text
@d4 3
d33 3
a35 3
    Absyn.NEWstrexp strdec => " struct " ^ strdec_to_string(strdec) ^ " end"
  | Absyn.OLDstrexp longstrid => IdentPrint.printLongStrId(longstrid)
  | Absyn.APPstrexp(funid, strexp) => (IdentPrint.printFunId funid) ^ "(" ^
d41 1
a41 1
    Absyn.DECstrdec ord_dec => AbsynPrint.printDec(ord_dec)
d45 1
a45 1
      "(" ^ (IdentPrint.printStrId strid) ^
@


1.1
log
@Initial revision
@
text
@d3 3
a5 1
$Log$
d12 1
@
