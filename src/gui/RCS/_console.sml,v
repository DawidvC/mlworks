head	1.27;
access;
symbols
	MLW_daveb_inline_1_4_99:1.27.1
	MLWorks_21c0_1999_03_25:1.27
	MLWorks_20c1_1998_08_20:1.26
	MLWorks_20c0_1998_08_04:1.26
	MLWorks_20b2c2_1998_06_19:1.26
	MLWorks_20b2_Windows_1998_06_12:1.26
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.23
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.22.1.1.1.1.1
	MLWorks_workspace_97:1.22.3
	MLWorks_dt_wizard:1.22.2
	MLWorks_11c0_1997_09_09:1.22.1.1.1.1
	MLWorks_10r3:1.22.1.1.3
	MLWorks_10r2_551:1.22.1.1.2
	MLWorks_11:1.22.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.22.1.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.22.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.22.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.22.1
	MLWorks_BugFix_1997_04_24:1.22
	MLWorks_1_0_r2_Win32_1997_04_11:1.22
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.21.2.1.1
	MLWorks_gui_1996_12_18:1.21.3
	MLWorks_1_0_Win32_1996_12_17:1.21.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.1.1
	JFHgui:1.21.1
	MLWorks_1_0_Irix_1996_11_28:1.19.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.1
	MLWorks_1_0_Unix_1996_11_14:1.19.1
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13;
locks; strict;
comment	@ * @;


1.27
date	99.02.02.15.59.11;	author mitchell;	state Exp;
branches
	1.27.1.1;
next	1.26;

1.26
date	98.03.24.17.20.27;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	98.02.19.20.16.58;	author mitchell;	state Exp;
branches;
next	1.24;

1.24
date	98.02.18.16.57.10;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	97.09.18.15.09.12;	author brucem;	state Exp;
branches;
next	1.22;

1.22
date	97.03.17.11.39.06;	author andreww;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1;
next	1.21;

1.21
date	96.12.03.20.32.21;	author johnh;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1;
next	1.20;

1.20
date	96.11.21.12.20.45;	author jont;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	96.11.06.11.15.48;	author matthew;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	96.10.09.11.53.15;	author io;	state Exp;
branches;
next	1.17;

1.17
date	96.07.15.13.33.45;	author andreww;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1;
next	1.16;

1.16
date	96.07.03.12.55.52;	author andreww;	state Exp;
branches;
next	1.15;

1.15
date	96.07.02.14.35.24;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.06.13.17.50.25;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	96.05.15.16.00.22;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.05.15.11.42.10;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.05.01.11.18.57;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.04.30.10.05.04;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	96.03.06.14.55.41;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.22.11.52.50;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	96.01.22.11.03.35;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.12.07.14.37.07;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.11.13.17.26.38;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.30.13.23.34;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.11.10.25.20;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.55.46;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.42.37;	author matthew;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.13.40;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.04.17;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.22.30;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	96.11.14.12.46.38;	author hope;	state Exp;
branches
	1.19.1.1.1.1;
next	;

1.19.1.1.1.1
date	96.11.28.14.58.16;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.11.22.18.06.52;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	96.12.17.09.54.57;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.12.17.17.45.34;	author hope;	state Exp;
branches
	1.21.2.1.1.1;
next	;

1.21.2.1.1.1
date	97.02.24.11.35.04;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.12.18.09.39.34;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	97.05.12.10.31.55;	author hope;	state Exp;
branches
	1.22.1.1.1.1
	1.22.1.1.2.1
	1.22.1.1.3.1;
next	;

1.22.1.1.1.1
date	97.07.28.18.16.56;	author daveb;	state Exp;
branches
	1.22.1.1.1.1.1.1;
next	;

1.22.1.1.1.1.1.1
date	97.10.07.11.41.47;	author jkbrook;	state Exp;
branches;
next	;

1.22.1.1.2.1
date	97.09.08.17.10.30;	author daveb;	state Exp;
branches;
next	;

1.22.1.1.3.1
date	97.09.09.14.06.04;	author daveb;	state Exp;
branches;
next	;

1.22.2.1
date	97.09.10.19.20.30;	author brucem;	state Exp;
branches;
next	;

1.22.3.1
date	97.09.11.20.51.42;	author daveb;	state Exp;
branches;
next	;

1.27.1.1
date	99.04.01.17.55.17;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.27
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* IO Console - imitates user's TTY *)
(*
 *  $Log: _console.sml,v $
 * Revision 1.26  1998/03/24  17:20:27  jont
 * [Bug #30090]
 * Remove uses of MLWorks.IO
 *
 * Revision 1.25  1998/02/19  20:16:58  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.24  1998/02/18  16:57:10  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.23  1997/09/18  15:09:12  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.22  1997/03/17  11:39:06  andreww
 * [Bug #1677]
 * adding new access field to currentIO record.
 *
 * Revision 1.21  1996/12/03  20:32:21  johnh
 * Putting clear_console in _console to set the write_pos.
 *
 * Revision 1.20  1996/11/21  12:20:45  jont
 * [Bug #1799]
 * Modify call to check_insertion to allow for string being truncated
 * in order to fit
 *
 * Revision 1.19  1996/11/06  11:15:48  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.18  1996/10/09  11:53:15  io
 * moving String from toplevel
 *
 * Revision 1.17  1996/07/15  13:33:45  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
 * Revision 1.16  1996/07/03  12:55:52  andreww
 * Adding GuiStandardIO-specific functions to the console create function.
 *
 * Revision 1.15  1996/07/02  14:35:24  daveb
 * Added call to Capi.Text.check_insertion.
 *
 * Revision 1.14  1996/06/13  17:50:25  daveb
 * The changes in Version 1.12 were lost - presumably a conflict over checking
 * stuff in.  I've merged them back in.
 *
 * Revision 1.13  1996/05/15  16:00:22  daveb
 * Changed create to return the scrolledtext widgets, instead of a popup shell.
 *
 * Revision 1.11  1996/05/01  11:18:57  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.10  1996/04/30  10:05:04  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.9  1996/03/06  14:55:41  daveb
 * Added a "delete all" menu entry.
 *
 * Revision 1.8  1996/01/22  11:52:50  daveb
 * Removed binding of linefeed character - the translation table now makes this
 * insert a new line character without performing any action (to match Windows).
 *
 * Revision 1.7  1996/01/22  11:03:35  daveb
 * Changed to use the new history mechanism in gui_utils.
 *
 * Revision 1.6  1995/12/07  14:37:07  matthew
 * Change to clipboard interface
 *
 * Revision 1.5  1995/11/13  17:26:38  matthew
 * Simplifying capi interface.
 *
 * Revision 1.4  1995/08/30  13:23:34  matthew
 * Changes to Capi text widget
 *
 * Revision 1.3  1995/08/11  10:25:20  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:55:46  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:42:37  matthew
 * new unit
 * New unit
 *
 *  Revision 1.3  1995/07/04  17:18:31  daveb
 *  Replaced ad-hoc handling of CTRL-D (which has stopped working)
 *  with an explicit function.
 *
 *  Revision 1.2  1995/07/04  15:09:39  matthew
 *  Further capification
 *
 *  Revision 1.1  1995/07/04  13:12:34  daveb
 *  new unit
 *  Std_in and std_out.
 *
 *
 *  Copyright (c) 1995 Harlequin Ltd.
 *  
*)

require "../basis/__int";
require "../basis/__text_io";
require "../basis/__text_prim_io";
require "^.utils.__terminal";

require "../utils/lists";
require "../interpreter/shell_utils";
require "capi";
require "menus";
require "gui_utils";

require "console";

(* WARNING: Don't use std_out for error tracing when debugging this file.
   Usually you should use MLWorks.IO.terminal_out instead. *)

functor Console (
  structure Capi: CAPI
  structure Lists: LISTS
  structure ShellUtils : SHELL_UTILS
  structure GuiUtils : GUI_UTILS
  structure Menus : MENUS

  sharing type GuiUtils.user_tool_options = ShellUtils.UserOptions 

  sharing type Menus.Widget = GuiUtils.Widget = Capi.Widget

  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec

  sharing type ShellUtils.user_preferences = GuiUtils.user_preferences
): CONSOLE =
struct
  type Widget = Capi.Widget
  type user_preferences = GuiUtils.user_preferences

  val do_debug = false
  fun debug s = if do_debug then Terminal.output(s ^ "\n") else ()
  fun fdebug f = if do_debug then Terminal.output(f() ^ "\n") else ()
  fun ddebug s = Terminal.output(s ^ "\n")

  fun create (parent, title, user_preferences) =
    let
      val (textscroll, text) =
	Capi.make_scrolled_text ("textIO", parent, [])

      (*** IO functions ***)

      (* write_pos is the position new input should go in the buffer, usually
	 the end.  Also used as the position from which input is read. 
         Output from the program should go before this position.  Input is read
         from after it. *)
      val write_pos = ref 0

      fun clear_console _ = (Capi.Text.set_string (text, "");
			     write_pos := 0)

      (* Note use of text_size -- important for Windows CR/LF!!!
	 Also check_insertion to get around size limitations of Windows. *)

      fun insert_text str =
	let
	  val str = Capi.Text.check_insertion (text, str, !write_pos, [write_pos])
	in
	  Capi.Text.insert(text, !write_pos, str);
          write_pos := Capi.Text.text_size str + !write_pos;
	  Capi.Text.set_insertion_position (text, !write_pos)
	end

      val outstream = GuiUtils.make_outstream insert_text

      val (input_string, input_flag) = (ref "", ref false)

      fun input_fun () =
        (input_flag := true;
	 Capi.event_loop (input_flag);
         fdebug(fn _ => "Input line is:" ^ (!input_string)^":");
         !input_string)

      local 
        val inbuff as (posref, strref) = (ref 0, ref "")
            
        fun refill_buff () =
          let
            val new_string = input_fun ()
          in
            posref := 0;
            strref := new_string
          end

	val eof_flag = ref false
        val close_in = fn () => eof_flag:=true

        val thisWindow = {output={descriptor=NONE,
                                  put= fn {buf,i,sz} =>
                                       let val els = case sz of
                                                    NONE=>size buf-i
                                                  | (SOME s)=> s
                                       in insert_text (substring (buf,i,els));
                                          els
                                       end,
                                  get_pos=NONE,
                                  set_pos=NONE,
                                  can_output=NONE,
                                  close = fn()=>()},
                          error ={descriptor=NONE,
                                  put= fn {buf,i,sz} =>
                                       let val els = case sz of
                                                    NONE=>size buf-i
                                                  | (SOME s)=> s
                                       in insert_text (substring (buf,i,els));
                                          els
                                       end,
                                  get_pos=NONE,
                                  set_pos=NONE,
                                  can_output=NONE,
                                  close=fn()=>()},
                          input ={descriptor=NONE,
                                  get=fn _ =>input_fun(),
                                  get_pos=SOME(fn()=> !posref),
                                  set_pos=SOME(fn i=>posref:=i),
                                  can_input=SOME(fn()=>
                                                 (!posref<size (!strref))),
                                  close=close_in},
                          access = fn f => f ()}
          (* see: <URI:spring:/ML_Notebook/Design/GUI/Mutexes> for
           * description of access. *)
      in

        fun inThisWindow () =
             MLWorks.Internal.StandardIO.redirectIO thisWindow

        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
          in
            if !eof_flag then
              ""
            else if pointer + n > len then
              (refill_buff ();
               substring (* could raise Substring *) (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
                 else
                   let val result = substring (* could raise Substring *) (string,pointer,n)
                   in
                     posref := (!posref + n);
                     result
                   end
          end

        fun clear_input () =
	  (debug "Clearing input";
           posref := 0;
	   strref := "";
	   eof_flag := false)
	  
        fun do_lookahead () =
          (if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff ();
              do_lookahead ())
               else 
                 substring (* could raise Substring *) (!strref, !posref, 1))
	       
	val close_in  = close_in
      end;

      fun mkInstream(input, lookahead, close_in) =
	let
	  fun can_input() = do_lookahead() <> ""
	  val prim_reader =
	    TextPrimIO.RD{name = "console reader",
			  chunkSize = 1,
			  readVec = SOME get_input,
			  readArr = NONE,
			  readVecNB = NONE,
			  readArrNB = NONE,
			  block = NONE,
			  canInput = SOME can_input,
			  avail = fn () => SOME(size(do_lookahead())),
			  getPos = NONE,
			  setPos = NONE,
			  endPos = NONE,
			  verifyPos = NONE,
			  close = close_in, 
			  ioDesc = NONE}

	in
	  TextIO.mkInstream(TextIO.StreamIO.mkInstream(TextPrimIO.augmentReader prim_reader, ""))
	end

      val instream = mkInstream(get_input, do_lookahead, close_in)

      fun replace_current_input line =
	let
          val last_pos = Capi.Text.get_last_position text
	in 
	  (* Motif Text.replace doesn't always work properly.  But setting the
	     whole string causes ridiculous amounts of flicker. *)
          Capi.Text.replace (text, !write_pos, last_pos, line);
	  Capi.Text.set_insertion_position (text, !write_pos + size line)
	end

      fun delete_current_line () =
        replace_current_input ""

      val {update_history, prev_history, next_history, history_menu, ...} =
        GuiUtils.make_history
          (user_preferences, fn line => replace_current_input line)

      fun start_of_line () =
        let
          val ppos = !write_pos
          val pos = Capi.Text.get_insertion_position text
	  val new_pos =
            if pos < ppos
              then Capi.Text.current_line (text,pos)
            else ppos
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun end_of_line () =
        let
          val ppos = !write_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.end_line (text,pos)
            else Capi.Text.get_last_position text
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun eof_or_delete () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos = last_pos andalso pos = !write_pos then
            (debug "eof";
             close_in ();
             input_flag := false)
          else
            (debug "delete";
             Capi.Text.replace (text, pos, pos + 1, ""))
        end

      fun do_return () =
	let
          val pos = Capi.Text.get_insertion_position text
          val lines =
            if pos < !write_pos then
              let
                val line = Capi.Text.get_line (text, pos) ^ "\n"
                val last_pos = Capi.Text.get_last_position text
              in
                Capi.Text.insert(text, last_pos, line);
                write_pos := last_pos + size line;
                Capi.Text.set_insertion_position (text, last_pos + size line);
                [line]
              end
            else
              let
                val str = Capi.Text.get_string text
                val length = size str

                fun get_lines ([], current, acc, _) =
		  map (implode o rev) (current :: acc)
                |   get_lines (#"\n"::rest, current, acc, column) =
		  get_lines (rest, [], (#"\n"::current)::acc, 1)
                |   get_lines (c::rest, current, acc, column) =
		  get_lines (rest, c::current, acc, column+1)

                val line = substring (* could raise Substring *) (str, !write_pos,
                                             length - !write_pos)
                val lines = get_lines (explode line,[],[],0)
              in
                case lines of
                  last :: rest =>
                    (Capi.Text.insert(text, length, "\n");
                     write_pos := length + 1;
                     Capi.Text.set_insertion_position
		     (text, length+1); last ^ "\n" :: rest)
                | _ => lines
              end
        in
	  input_flag := false;
          input_string := concat (rev lines);
	  update_history [!input_string]
        end

      (* A flag to indicate whether escape has just been pressed *)
      val escape_pressed = ref false

      fun do_escape () = escape_pressed := true

      val meta_bindings =
        [("p", prev_history),
         ("n", next_history),
         ("w", fn _ => Capi.Text.copy_selection text)]

      val normal_bindings =
        [("\^A", start_of_line),
         ("\^D", eof_or_delete),
         ("\^E", end_of_line),
         ("\^W", fn _ => Capi.Text.cut_selection text),
         ("\^Y", fn _ => Capi.Text.paste_selection text),
         ("\^U", delete_current_line),
         ("\013",do_return),
         ("\027",do_escape)]

      fun despatch_key bindings key =
        let
          fun loop [] = false
            | loop ((key',action)::rest) =
              if key = key' then (ignore(action ()); true)
              else loop rest
        in
          loop bindings
        end

      val despatch_meta = despatch_key meta_bindings
      val despatch_normal = despatch_key normal_bindings

      fun text_handler (key, modifiers) =
        if modifiers = [Capi.Event.meta_modifier] then
          despatch_meta key
        else
          despatch_normal key

      fun modifyVerify (start_pos, end_pos, str, doit) =
        if !escape_pressed andalso size str = 1 
          then 
            (escape_pressed := false;
             doit false;
             ignore(despatch_meta str);
             ())
        else
          (fdebug (fn _ =>
                   "Verify: start_pos is " ^ Int.toString start_pos ^
                   ", end_pos is " ^ Int.toString end_pos ^
                   ", write_pos is " ^ Int.toString (!write_pos) ^
                   ", string is '" ^ str ^ "'");
          if end_pos < !write_pos then
            write_pos := (!write_pos) - end_pos + start_pos + size str
          else if start_pos < !write_pos then
            write_pos := start_pos + size str
          else ();
          if end_pos < !write_pos 
            then write_pos := (!write_pos) - end_pos + start_pos + size str
          else if start_pos < !write_pos 
            then write_pos := start_pos + size str
          else ();
          doit true)
    in
      Capi.Text.add_handler (text, text_handler);
      Capi.Text.add_modify_verify (text,modifyVerify);
      {instream = instream,
       outstream = outstream,
       console_widget = textscroll,
       console_text = text,
       clear_input = clear_input,
       clear_console = clear_console,
       set_window=inThisWindow}
    end
end;

@


1.27.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.27  1999/02/02  15:59:11  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.26
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d4 4
a111 1
require "../basis/__io";
a112 1
require "../basis/_stream_io";
@


1.25
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d107 4
a139 2
  structure IO = MLWorks.IO

d275 21
a295 4
	  
	fun closed_in () = !eof_flag
	  
	fun clear_eof () = eof_flag := false
d297 3
d301 1
a301 9
      end;
	  
      val instream = 
        IO.instream {input = get_input,
                     lookahead = do_lookahead,
                     end_of_stream = fn () => do_lookahead () = "",
                     clear_eof = clear_eof,
                     close_in = close_in,
		     closed_in = closed_in}
@


1.24
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d408 1
a408 1
              if key = key' then (action (); true)
d428 1
a428 1
             despatch_meta str;
@


1.23
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 4
d99 1
d134 3
a136 3
  fun debug s = if do_debug then MLWorks.IO.output(IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then MLWorks.IO.output(IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = MLWorks.IO.output(IO.terminal_out,s ^ "\n")
@


1.22
log
@[Bug #1677]
adding new access field to currentIO record.
@
text
@d4 4
a102 1
require "^.basis.__old";
d351 3
a353 3
		  map (concat o rev) (current :: acc)
                |   get_lines ("\n"::rest, current, acc, column) =
		  get_lines (rest, [], ("\n"::current)::acc, 1)
d359 1
a359 1
                val lines = get_lines (Old.explode line,[],[],0)
@


1.22.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.22  1997/03/17  11:39:06  andreww
 * [Bug #1677]
 * adding new access field to currentIO record.
 *
@


1.22.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.22  1997/03/17  11:39:06  andreww
 * [Bug #1677]
 * adding new access field to currentIO record.
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a3 4
 * Revision 1.22  1997/03/17  11:39:06  andreww
 * [Bug #1677]
 * adding new access field to currentIO record.
 *
@


1.22.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.22.1.1  1997/05/12  10:31:55  hope
 * branched from 1.22
 *
@


1.22.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.22.1.1  1997/05/12  10:31:55  hope
 * branched from 1.22
 *
@


1.22.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.22.1.1  1997/05/12  10:31:55  hope
 * branched from 1.22
 *
@


1.22.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.22.1.1.1.1  1997/07/28  18:16:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.21
log
@Putting clear_console in _console to set the write_pos.
@
text
@d4 3
d212 4
a215 2
                                  close=close_in}}

@


1.21.3.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/12/03  20:32:21  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/12/03  20:32:21  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.21.2.1.1.1
log
@branched from 1.21.2.1
@
text
@a3 3
 * Revision 1.21.2.1  1996/12/17  17:45:34  hope
 * branched from 1.21
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a3 3
 * Revision 1.21  1996/12/03  20:32:21  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.20
log
@[Bug #1799]
Modify call to check_insertion to allow for string being truncated
in order to fit
@
text
@d4 5
d140 3
d438 1
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 5
 * Revision 1.20  1996/11/21  12:20:45  jont
 * [Bug #1799]
 * Modify call to check_insertion to allow for string being truncated
 * in order to fit
 *
@


1.19
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d139 3
a141 1
	( Capi.Text.check_insertion (text, str, !write_pos, [write_pos]);
d145 1
a145 1
	)
@


1.19.1.1
log
@branched from 1.19
@
text
@a3 4
 * Revision 1.19  1996/11/06  11:15:48  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.19.1.1.1.1
log
@branched from 1.19.1.1
@
text
@a3 3
 * Revision 1.19.1.1  1996/11/14  12:46:38  hope
 * branched from 1.19
 *
@


1.18
log
@moving String from toplevel
@
text
@d4 3
d78 1
a78 1
require "../basis/__integer";
@


1.17
log
@propagating changes made to the GUI standard IO redirection mechanism
(see __pervasive_library.sml for the StandardIO structure)
@
text
@d4 4
d84 1
d209 1
a209 1
               String.substring (string,pointer,len-pointer) ^
d212 1
a212 1
                   let val result = String.substring (string,pointer,n)
d232 1
a232 1
                 String.substring (!strref, !posref, 1))
d326 1
a326 1
		  map (String.implode o rev) (current :: acc)
d332 1
a332 1
                val line = String.substring (str, !write_pos,
d334 1
a334 1
                val lines = get_lines (String.explode line,[],[],0)
d346 1
a346 1
          input_string := String.implode (rev lines);
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/07/15  13:33:45  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/07/15  13:33:45  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 4
 * Revision 1.17  1996/07/15  13:33:45  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
@


1.16
log
@Adding GuiStandardIO-specific functions to the console create function.
@
text
@d4 3
d155 1
d157 31
a187 6
        val thisWindow = {output_fun=insert_text,
                          input_fun=input_fun,
                          eof_flag=eof_flag,
                          buffer_pos=posref,
                          buffer_data=strref}

d192 1
a192 1
             MLWorks.Internal.GuiStandardIO.setCurrentWindow thisWindow
d229 1
a229 1
	fun close_in () = eof_flag := true
@


1.15
log
@Added call to Capi.Text.check_insertion.
@
text
@d4 3
a13 3
 * Revision 1.12  1996/05/15  11:42:10  matthew
 * Use Capi.Text.text_size in insert_text
 *
d122 1
d152 8
d161 4
d205 2
d386 2
a387 1
       clear_input = clear_input}
@


1.14
log
@The changes in Version 1.12 were lost - presumably a conflict over checking
stuff in.  I've merged them back in.
@
text
@d4 4
d120 2
a121 1
      (* Note use of text_size -- important for Windows CR/LF!!! *)
d123 2
a124 1
	( Capi.Text.insert(text, !write_pos, str);
@


1.13
log
@Changed create to return the scrolledtext widgets, instead of a popup shell.
@
text
@d4 6
d116 1
d119 1
a119 1
          write_pos := size str + !write_pos;
@


1.12
log
@Use Capi.Text.text_size in insert_text
@
text
@a98 4
      (*** Make the windows ***)
      val (shell, mainWindow, menuBar, _) =
	Capi.make_main_popup ("console", title ^ " Console", parent, false);

d100 1
a100 1
	Capi.make_scrolled_text ("textIO", mainWindow, [])
a103 2
      fun beep _ = Capi.beep shell

a109 1
      (* Note use of text_size -- important for Windows CR/LF!!! *)
d112 1
a112 1
          write_pos := Capi.Text.text_size str + !write_pos;
a117 12
      val console_visible_ref = ref false
        
      fun console_visible () = !console_visible_ref

      fun show_console b =
        (console_visible_ref := b;
         if b then
           (Capi.reveal mainWindow;
            Capi.to_front shell)
         else
            Capi.hide mainWindow)

a130 1
            val _ = show_console true;
a350 12

      val menuspec =
        [Menus.CASCADE ("window",
                        [Menus.PUSH ("deleteAll",
                                     fn _ => Capi.Text.set_string (text, ""),
                                     fn _ => true),
			 Menus.SEPARATOR,
                         Menus.PUSH ("close",
                                     fn _ => show_console false,
                                     fn _ => true)],
                        fn _ => true),
	 history_menu]
a351 7
      Menus.make_submenus (menuBar,menuspec);
      Capi.Layout.lay_out
      (mainWindow,
       [Capi.Layout.MENUBAR menuBar,
        Capi.Layout.SPACE,
        Capi.Layout.FLEX textscroll,
        Capi.Layout.SPACE]);
d356 2
a357 3
       console_widget = shell,
       show_console = show_console,
       console_visible = console_visible,
@


1.11
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d116 1
d119 1
a119 1
          write_pos := size str + !write_pos;
@


1.10
log
@Replacing MLWorks.Integer with basis file
@
text
@d4 3
d87 3
a89 3
  fun debug s = if do_debug then output(IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then output(IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = output(IO.terminal_out,s ^ "\n")
d277 1
a277 1
		  map (implode o rev) (current :: acc)
d285 1
a285 1
                val lines = get_lines (explode line,[],[],0)
d297 1
a297 1
          input_string := implode (rev lines);
@


1.9
log
@Added a "delete all" menu entry.
@
text
@d4 3
d49 2
a77 1
  structure Integer = MLWorks.Integer
d346 3
a348 3
                   "Verify: start_pos is " ^ Integer.makestring start_pos ^
                   ", end_pos is " ^ Integer.makestring end_pos ^
                   ", write_pos is " ^ Integer.makestring (!write_pos) ^
@


1.8
log
@Removed binding of linefeed character - the translation table now makes this
insert a new line character without performing any action (to match Windows).
@
text
@d4 4
d360 5
a364 1
                        [Menus.PUSH ("close",
@


1.7
log
@Changed to use the new history mechanism in gui_utils.
@
text
@d4 3
a207 15
      fun yank_current_line () =
	let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos < !write_pos then
            let val line = Capi.Text.get_line (text, pos)
            in
              Capi.Text.insert(text, last_pos, line);
              Capi.Text.set_insertion_position (text, last_pos+size line)
            end
          else
            ()
        end

a306 1
         ("\^J", yank_current_line),
@


1.6
log
@Change to clipboard interface
@
text
@d4 3
a187 34
      (* The history is a list of topdecs, combined with an index number.
	 The index is used to set the current_index ref when a topdec is
	 selected from the menu. *)
      val history = ref []: (string * int) list ref;
      val history_size = ref 0;
      val initial_index = ~1;
      val history_index = ref initial_index;

      fun whitespacep x =
        case x of
          " " => true
        | "\n" => true
        | "\t" => true
        | "\012" => true
        | "\013" => true
        | _ => false
          
      fun strip_whitespace s =
        let
          fun strip [] = []
            | strip (l as (a::b)) =
              if whitespacep a then strip b else l
        in
          implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
        end

      fun add_history_entry new_entry =
        (history_size := !history_size + 1;
         ShellUtils.add_history_item
	   ((new_entry, !history_size),
            history,
            (fn ((s,_),(s',_))=>s=s'),
            user_preferences))
        
d201 3
a203 21
      fun pop_history () = 
	let val _ = history_index := !history_index + 1
	    val line = #1 (Lists.nth (!history_index, !history))
	in 
	  replace_current_input line
	end
	handle
	  Lists.Nth =>
	    history_index := !history_index - 1;

      fun push_history () = 
	let val _ = history_index := !history_index - 1;
	    val line = #1 (Lists.nth (!history_index, !history))
	               handle
	  		 Lists.Nth =>
			   (history_index := initial_index;
			    ""	(* empty input *))
	in 
	  replace_current_input line
	end

d299 1
a299 2
          add_history_entry (strip_whitespace (!input_string));
      	  history_index := initial_index
d308 2
a309 2
        [("p", pop_history),
         ("n", push_history),
a366 3
      fun warp_history string =
        ShellUtils.trim_history_string (string, user_preferences)

d373 1
a373 10
         Menus.DYNAMIC ("history",
			fn () =>
			map (fn (s,i) =>
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_input s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> [])]
@


1.5
log
@Simplifying capi interface.
@
text
@d4 3
d360 1
a360 1
         ("w", fn _ => GuiUtils.copySelection text)]
d366 2
a367 2
         ("\^W", fn _ => GuiUtils.cutSelection text),
         ("\^Y", fn _ => GuiUtils.pasteSelection text),
@


1.4
log
@Changes to Capi text widget
@
text
@d4 3
d389 24
a412 29
      fun modifyVerify callback_data =
        let
          val (event, start_pos, end_pos, str, doit) =
            Capi.Callback.convert_verify_data callback_data
        in
          if !escape_pressed andalso size str = 1 
            then 
              (escape_pressed := false;
	       doit false;
               despatch_meta str;
               ())
          else
            (fdebug (fn _ =>
                     "Verify: start_pos is " ^ Integer.makestring start_pos ^
                     ", end_pos is " ^ Integer.makestring end_pos ^
                     ", write_pos is " ^ Integer.makestring (!write_pos) ^
                     ", string is '" ^ str ^ "'");
             if end_pos < !write_pos then
	       write_pos := (!write_pos) - end_pos + start_pos + size str
             else if start_pos < !write_pos then
	       write_pos := start_pos + size str
	     else ();
             if end_pos < !write_pos then
	       write_pos := (!write_pos) - end_pos + start_pos + size str
             else if start_pos < !write_pos then
	       write_pos := start_pos + size str
             else ();
             doit true)
        end
d442 1
a442 1
      Capi.Callback.add (text, Capi.Callback.ModifyVerify, modifyVerify);
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
d72 1
a72 1
	Capi.make_main_window ("console", title ^ " Console", parent, false);
d102 1
a102 1
           (Capi.manage shell;
d105 1
a105 1
            Capi.unmanage shell)
d369 1
a369 1
          fun loop [] = beep ()
d371 1
a371 1
              if key = key' then action ()
d380 5
a384 12
      fun activate callback_data =
	let 
	  val event = Capi.Callback.get_event callback_data
        in
	  case Capi.Event.get_key_data event
	  of MLWorks.Option.SOME (key, modifiers) =>
	    if modifiers = [Capi.Event.meta_modifier] then
	      despatch_meta key
	    else
              despatch_normal key
	  |  MLWorks.Option.NONE => beep ()
        end
d395 2
a396 1
               despatch_meta str)
d441 1
a441 1
        Capi.Layout.TEXT textscroll,
d443 1
a443 1
      Capi.Callback.add (text, Capi.Callback.Activate, activate);
a444 2
      Capi.manage menuBar;
      Capi.manage text;
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
a73 7
      val _ =
        Capi.Layout.lay_out
	  [Capi.Layout.MENUBAR menuBar,
	   Capi.Layout.SPACE,
	   Capi.Layout.TEXT textscroll,
	   Capi.Layout.SPACE]

d440 6
@


1.1
log
@new unit
New unit
@
text
@d4 4
d26 2
a27 2
require "../library/capi";
require "../library/menus";
@
