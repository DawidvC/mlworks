head	1.33;
access;
symbols
	MLW_daveb_inline_1_4_99:1.33.1
	MLWorks_21c0_1999_03_25:1.33
	MLWorks_20c1_1998_08_20:1.33
	MLWorks_20c0_1998_08_04:1.33
	MLWorks_20b2c2_1998_06_19:1.33
	MLWorks_20b2_Windows_1998_06_12:1.33
	MLWorks_20b1c1_1998_05_07:1.33
	MLWorks_20b0_1998_04_07:1.33
	MLWorks_20b0_1998_03_20:1.33
	MLWorks_20m2_1998_02_16:1.32
	MLWorks_20m1_1997_10_23:1.32
	MLWorks_11r1:1.31.6.1.1.1.1
	MLWorks_workspace_97:1.32.2
	MLWorks_dt_wizard:1.32.1
	MLWorks_11c0_1997_09_09:1.31.6.1.1.1
	MLWorks_10r3:1.31.6.1.3
	MLWorks_10r2_551:1.31.6.1.2
	MLWorks_11:1.31.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.6.1
	MLWorks_20m0_1997_06_20:1.32
	MLWorks_1_0_r2c2_1997_06_14:1.31.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.6
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.4.1.1
	MLWorks_gui_1996_12_18:1.31.5
	MLWorks_1_0_Win32_1996_12_17:1.31.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.1.1
	JFHgui:1.31.3
	MLWorks_1_0_Irix_1996_11_28:1.31.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.2
	MLWorks_1_0_Unix_1996_11_14:1.31.1
	MLWorks_Open_Beta2_1996_10_11:1.30.3
	MLWorks_License_dev:1.30.2
	MLWorks_1_open_beta_1996_09_13:1.30.1
	MLWorks_Open_Beta_1996_08_22:1.30
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30;
locks; strict;
comment	@ * @;


1.33
date	98.02.18.16.57.40;	author jont;	state Exp;
branches
	1.33.1.1;
next	1.32;

1.32
date	97.05.01.13.09.17;	author jont;	state Exp;
branches
	1.32.1.1
	1.32.2.1;
next	1.31;

1.31
date	96.11.06.11.15.57;	author matthew;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1
	1.31.5.1
	1.31.6.1;
next	1.30;

1.30
date	96.05.10.14.45.45;	author daveb;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1;
next	1.29;

1.29
date	96.05.01.11.22.55;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	96.04.30.10.04.27;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.03.07.16.43.16;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.02.19.16.18.26;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.01.23.15.38.30;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	96.01.17.11.45.52;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.01.09.14.03.57;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.12.18.10.49.52;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	95.12.07.14.34.39;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.11.23.11.30.14;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.11.17.11.08.49;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.11.17.11.08.49;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.11.16.13.17.06;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.15.16.50.12;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.11.13.17.27.28;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.10.26.15.16.46;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.10.25.12.28.19;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.10.20.10.09.32;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	95.10.18.13.45.06;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	95.10.09.11.43.46;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.10.05.13.31.10;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.10.04.13.41.18;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	95.10.03.16.25.28;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.22.13.41.40;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.09.11.15.29.24;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.30.13.23.37;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.11.10.07.11;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.56.13;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.38.31;	author matthew;	state Exp;
branches;
next	;

1.30.1.1
date	96.09.13.11.13.07;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.10.07.16.03.47;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.10.17.11.22.02;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	96.11.14.12.45.59;	author hope;	state Exp;
branches
	1.31.1.1.1.1;
next	;

1.31.1.1.1.1
date	96.11.28.14.57.47;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.11.22.18.06.24;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.12.17.09.54.26;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.12.17.17.45.06;	author hope;	state Exp;
branches
	1.31.4.1.1.1;
next	;

1.31.4.1.1.1
date	97.02.24.11.34.34;	author hope;	state Exp;
branches;
next	;

1.31.5.1
date	96.12.18.09.39.05;	author hope;	state Exp;
branches;
next	;

1.31.6.1
date	97.05.12.10.31.25;	author hope;	state Exp;
branches
	1.31.6.1.1.1
	1.31.6.1.2.1
	1.31.6.1.3.1;
next	;

1.31.6.1.1.1
date	97.07.28.18.17.17;	author daveb;	state Exp;
branches
	1.31.6.1.1.1.1.1;
next	;

1.31.6.1.1.1.1.1
date	97.10.07.11.42.09;	author jkbrook;	state Exp;
branches;
next	;

1.31.6.1.2.1
date	97.09.08.17.10.50;	author daveb;	state Exp;
branches;
next	;

1.31.6.1.3.1
date	97.09.09.14.06.24;	author daveb;	state Exp;
branches;
next	;

1.32.1.1
date	97.09.10.19.20.53;	author brucem;	state Exp;
branches;
next	;

1.32.2.1
date	97.09.11.20.52.06;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	99.04.01.17.55.28;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.33
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@(* Replacement for Listener *)
(*
 *  $Log: _evaluator.sml,v $
 * Revision 1.32  1997/05/01  13:09:17  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.30  1996/05/10  14:45:45  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
 * Revision 1.29  1996/05/01  11:22:55  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.28  1996/04/30  10:04:27  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.27  1996/03/07  16:43:16  daveb
 * Corrected behaviour of window close function.
 *
 * Revision 1.26  1996/02/19  16:18:26  daveb
 * Converting this to be a source browser.
 *
 * Revision 1.25  1996/01/23  15:38:30  daveb
 * Type of GuiUtils.value_menu has changed.
 *
 * Revision 1.24  1996/01/17  11:45:52  matthew
 * Reordering top level menus.
 *
 * Revision 1.23  1996/01/09  14:03:57  matthew
 * Moved list_select to capi
 *
 * Revision 1.22  1995/12/18  10:49:52  matthew
 * Fixing problem with busy cursor
 *
 * Revision 1.21  1995/12/07  14:34:39  matthew
 * Changing interface to edit_menu
 *
 * Revision 1.20  1995/11/23  11:30:14  matthew
 * Adding call to transfer_focus
 *
 * Revision 1.19  1995/11/17  11:08:49  matthew
 * Fixing problem with last change
 *
 * Revision 1.17  1995/11/16  13:17:06  matthew
 * Changing button resources
 *
 * Revision 1.16  1995/11/15  16:50:12  matthew
 * Adding windows menu
 *
 * Revision 1.15  1995/11/13  17:27:28  matthew
 * Simplifying capi interface.
 *
 * Revision 1.14  1995/10/26  15:16:46  daveb
 * Now creates a new list widget each time that completion is asked for, so that
 * it pops up with the correct size under TWM.
 *
 * Revision 1.13  1995/10/25  12:28:19  nickb
 * Make profile tool a child of the application shell.
 *
 * Revision 1.12  1995/10/20  10:09:32  daveb
 * Renamed ShellUtils.edit_source to ShellUtils.edit_location.
 *
 * Revision 1.11  1995/10/18  13:45:06  nickb
 * Add profiler to the shelldata made here.
 *
 * Revision 1.10  1995/10/09  11:43:46  daveb
 * The search_opt field of the context menu now takes a boolean component which
 * controls whether users are given the option of which contexts to search.
 * In input tools this should be true, in the context browser it should be false.
 *
 * Revision 1.9  1995/10/05  13:31:10  daveb
 * Added search facility.
 *
 * Revision 1.8  1995/10/04  13:41:18  daveb
 * Moved breakpoints_menu to podium.
 *
 * Revision 1.7  1995/10/03  16:25:28  daveb
 * Menus.make_buttons now returns a record of functions.
 *
 * Revision 1.6  1995/09/22  13:41:40  daveb
 * Added highlight function, for highlighting errors in the input text window.
 *
 * Revision 1.5  1995/09/11  15:29:24  matthew
 * Changing top level window initialization
 *
 * Revision 1.4  1995/08/30  13:23:37  matthew
 * Changes to Capi text widget
 *
 * Revision 1.3  1995/08/11  10:07:11  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:56:13  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:38:31  matthew
 * new unit
 * New unit
 *
 *  Revision 1.59  1995/07/13  11:16:33  matthew
 *  Removing Incremental from Ml_Debugger
 *
 *  Revision 1.58  1995/07/07  15:25:24  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.57  1995/07/04  15:10:41  matthew
 *  Capification
 *
 *  Revision 1.56  1995/07/04  10:28:39  daveb
 *  Replaced input and output windows with a console window.
 *
 *  Revision 1.55  1995/06/30  09:30:11  daveb
 *  Replaced explicit setting of constraint resources with Layout functions.
 *
 *  Revision 1.53  1995/06/16  10:31:38  daveb
 *  Added Time button.
 *
 *  Revision 1.52  1995/06/15  15:58:15  daveb
 *  Moved code that resets state to outside the exception handlers (in
 *  the evaluate function).
 *
 *  Revision 1.51  1995/06/15  13:14:52  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.50  1995/06/14  13:54:17  daveb
 *  Made use of error browser depend on preferences.
 *  Type of Ml_Debugger.ml_debugger, ShellUtils.edit_* and OutputWindow.create
 *  have changed.
 *
 *  Revision 1.49  1995/06/12  15:03:07  daveb
 *  Ensured that the result strings are not overwritten by the
 *  selection mechanism.
 *
 *  Revision 1.48  1995/06/06  14:17:17  daveb
 *  Added history commands.
 *
 *  Revision 1.47  1995/06/05  13:55:26  daveb
 *  Changed sensitivity argument of view_options to SENSE_ALL, because
 *  the shell functions now set the current selection.
 *
 *  Revision 1.46  1995/06/05  13:10:54  daveb
 *  Made evaluator sensitive to current selection.  The current definition
 *  is preserved when necessary.
 *
 *  Revision 1.45  1995/06/01  11:37:21  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.44  1995/05/23  14:09:44  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.43  1995/05/23  08:57:23  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.42  1995/05/16  09:46:35  matthew
 *  Adding escape key functionality
 *
 *  Revision 1.41  1995/05/04  09:46:13  matthew
 *  Removed script from ml_debugger
 *
 *  Revision 1.40  1995/04/28  16:58:40  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.39  1995/04/24  14:21:52  daveb
 *  Added breakpoint menu.  Removed value menu.
 *
 *  Revision 1.38  1995/04/19  10:57:28  daveb
 *  Changes to context_menu.
 *
 *  Revision 1.37  1995/04/13  11:28:08  daveb
 *  Added catch for ShellTypes.DebuggerTrapped in evaluate function.
 *
 *  Revision 1.36  1995/04/06  15:47:21  daveb
 *  Input widget now takes an applicationShell argument.
 *
 *  Revision 1.35  1995/03/31  14:51:04  daveb
 *  Ensured that we always use a windowing debugger.
 *
 *  Revision 1.34  1995/03/31  13:35:26  daveb
 *  Removed unimplemented menu items.
 *
 *  Revision 1.33  1995/03/30  13:49:36  daveb
 *  Removed the history pane to the new context tool.
 *
 *  Revision 1.32  1995/03/17  12:27:36  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 * 
 *  Revision 1.31  1995/03/16  15:49:09  daveb
 *  Removed context_function from register when closing the window.
 * 
 *  Revision 1.30  1995/03/15  17:42:31  daveb
 *  Changed to share current context with other tools..
 * 
 *  Revision 1.29  1995/03/10  17:01:42  daveb
 *  Replaced "inspect" command with automatic updating of context selection.
 * 
 *  Revision 1.28  1995/03/06  12:29:18  daveb
 *  Added contexts to history info.  Also replaced evaluation sequence
 *  with ShellTypes.process_result.
 * 
 *  Revision 1.27  1995/03/02  13:31:24  matthew
 *  Changes to Parser & Lexer structures
 * 
 *  Revision 1.26  1995/03/01  15:14:26  daveb
 *  Removed redundant code.
 * 
 *  Revision 1.25  1995/02/27  14:05:44  daveb
 *  Fixed timing of call to ActionQueue.do_actions.
 * 
 *  Revision 1.24  1995/02/20  15:31:38  daveb
 *  Changed name of output pane so that resources can make it read-only.
 * 
 *  Revision 1.23  1995/02/20  14:21:11  daveb
 *  Made use update the history of the context, and regenerated the
 *  history from the context every time.
 * 
 *  Revision 1.22  1995/02/16  16:49:59  daveb
 *  Added shortcuts for the buttons.
 * 
 *  Revision 1.21  1995/02/16  15:02:45  daveb
 *  Removed the augment button, and all that depended on it.
 * 
 *  Revision 1.20  1995/01/13  16:17:47  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 * 
 *  Revision 1.19  1994/11/30  18:30:21  daveb
 *  Fixed bug in form layout code for MIPS.  Also simplified this code
 *  by replacing separator widgets with Xm.*Offset values.  Also added
 *  an initial call to Xm.Widget.processTraversal for correct
 *  behaviour on the MIPS.
 * 
 *  Revision 1.18  1994/09/21  12:29:15  brianm
 *  Adding value menu (Edit/Trace/Untrace)
 * 
 *  Revision 1.17  1994/08/11  11:11:06  daveb
 *  Ensured that accept function augmented the correct context.
 * 
 *  Revision 1.16  1994/08/11  10:53:58  daveb
 *  Added semicolons when saving history.
 * 
 *  Revision 1.15  1994/08/09  12:55:02  daveb
 *  Changed type of InterPrint.strings.  Renamed source_result to result.
 *  A minor change to how results are used.
 * 
 *  Revision 1.14  1994/08/02  16:55:52  daveb
 *  Made error browser handle edit operation correctly.
 * 
 *  Revision 1.13  1994/08/02  09:20:37  daveb
 *  Passed token_stream to Incremental.compile_source instead of a parsed
 *  topdec, thus ensuring correct error handling.  Also made errors from
 *  the action queue invoke an error browser.
 * 
 *  Revision 1.11  1994/07/28  11:41:39  daveb
 *  Corrected sensitivity of history menu items.  Removed edit and inspect
 *  entries until they actually work.
 * 
 *  Revision 1.10  1994/07/28  10:24:12  daveb
 *  Excised unimplemented parts of user-interface.
 * 
 *  Revision 1.9  1994/07/27  14:32:52  daveb
 *  Cut-down menus for novices.
 * 
 *  Revision 1.8  1994/07/19  13:20:42  daveb
 *  Corrected misnamed "print_options" to the correct "options".
 * 
 *  Revision 1.7  1994/07/12  16:03:57  daveb
 *  ToolData.works_menu takes different arguments.
 * 
 *  Revision 1.6  1994/07/11  17:51:04  daveb
 *  Made accept button insensitive when there is no current result.
 * 
 *  Revision 1.5  1994/07/05  19:05:23  daveb
 *  Added input widget.
 * 
 *  Revision 1.4  1994/06/30  17:39:36  daveb
 *  Ensured that source is saved in user contexts.  Set history from user
 *  contexts.  Added facility to save the source of the current context.
 *  Also disabled entries in Output menu as appropriate.
 * 
 *  Revision 1.3  1994/06/23  10:55:32  jont
 *  Update debugger information production
 * 
 *  Revision 1.2  1994/06/23  10:36:04  daveb
 *  Added calls to Xm.Widget.processTraversal.  Also cleared output window
 *  before evaluating.
 * 
 *  Revision 1.1  1994/06/21  18:50:43  daveb
 *  new file
 *  
 *  Copyright (c) 1994 Harlequin Ltd.
 *  
*)

require "../basis/__int";
require "^.utils.__terminal";

require "../main/info";
require "../utils/lists";
require "../main/preferences";
require "../main/user_options";
require "tooldata";
require "gui_utils";
require "capi";
require "menus";
require "evaluator";

functor Evaluator (
  structure Lists: LISTS
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure ToolData : TOOL_DATA
  structure Menus : MENUS
  structure GuiUtils : GUI_UTILS
  structure Capi : CAPI
  structure Info : INFO

  sharing type Preferences.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       GuiUtils.user_preferences

  sharing type GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options =
	       UserOptions.user_context_options

  sharing type ToolData.ShellTypes.user_options =
	       GuiUtils.user_tool_options =
	       UserOptions.user_tool_options

  sharing type Menus.Widget = 
	       ToolData.Widget = GuiUtils.Widget =
	       Capi.Widget

  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec

  sharing type ToolData.ShellTypes.user_context =
	       GuiUtils.user_context 

  sharing type Preferences.preferences =
               ToolData.ShellTypes.preferences

  sharing type GuiUtils.MotifContext = ToolData.MotifContext
): EVALUATOR =
struct
  structure Location = Info.Location
  structure ShellTypes = ToolData.ShellTypes
  structure Options = ShellTypes.Options
  structure UserContext = ToolData.UserContext
  structure Option = MLWorks.Option

  type Widget = Capi.Widget
  type Context = ShellTypes.Context
  type UserOptions = UserOptions.user_tool_options

  type ToolData = ToolData.ToolData

  val evaluator_number = ref 1

  val do_debug = false
  fun debug s =
    if do_debug then Terminal.output(s ^ "\n") else ()

  fun create (parent,
	      tooldata as ToolData.TOOLDATA
		{args, current_context, motif_context, tools, ...},
	      destroy_fn) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args

      val (full_menus, update_fns) =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	  (!full_menus, update_fns)

      val title =
        let
          val n = !evaluator_number
        in
          evaluator_number := n+1;
          "Source Browser #" ^ Int.toString n
        end

      (*** Make the windows ***)
      val (shell,frame,menuBar,contextLabel) =
        Capi.make_main_window ("evaluator", title, parent, false)

      val paned =
        Capi.make_managed_widget ("paned", Capi.Paned, frame, [])

      val sourcePane =
  	Capi.make_managed_widget ("sourcePane", Capi.Form, paned,[]);

      val sourceTitleLabel =
  	Capi.make_managed_widget
	  ("sourceTitleLabel", Capi.Label, sourcePane, [])

      val (sourceScroll,sourceText) =
	Capi.make_scrolled_text ("sourceText", sourcePane, [])

      val resultPane =
	Capi.make_managed_widget ("resultPane", Capi.Form, paned, [])

      val resultTitleLabel =
  	Capi.make_managed_widget
	  ("resultTitleLabel", Capi.Label, resultPane, [])

      val (resultScroll,resultText) =
	Capi.make_scrolled_text ("resultText", resultPane, [])

      (*** Local Motif Context ***)

      val local_context = ref motif_context

      fun get_user_context () = GuiUtils.get_user_context (!local_context)
      fun get_context () = UserContext.get_context (get_user_context ())

      fun get_user_options () = user_options

      fun beep _ = Capi.beep shell

      fun get_user_options () = user_options

      fun close_window _ =
	(destroy_fn ();
	 Capi.destroy shell)

      val do_automatic = ref false
      val current_item_ref = ref NONE

      fun get_value () = !current_item_ref

      fun duplicate (src, res) =
	let
	  val f = create (parent, tooldata, fn _ => ())
	in
	  f false (src, res)
	end

      val main_menu =
        Menus.CASCADE
          ("main",
           [Menus.TOGGLE
	      ("autoSelection",
               fn _ => !do_automatic,
               fn b => do_automatic := b,
               fn _ => true),
            Menus.PUSH
	      ("duplicate",
               fn _ =>
		 case get_value () of
                   SOME x => duplicate x
                 | _ => (),
               fn _ =>
                 case get_value () of
                   SOME x => true
                 | _ => false),
            Menus.SEPARATOR,
            Menus.PUSH ("close", close_window, fn _ => true)],
           fn _ => true)

      val view_options =
	GuiUtils.view_options
	  {parent = shell, title = title, user_options = user_options,
	   user_preferences = user_preferences,
	   caller_update_fn = fn _ => (),
	   view_type = GuiUtils.VIEW_ALL}

      val view_menu =
	Menus.CASCADE ("view", view_options, fn _ => true)

      fun show_defn auto (src, res) =
	if auto andalso not (!do_automatic) then
	  ()
	else
	  (Capi.Text.set_string (sourceText, src);
	   Capi.Text.set_string (resultText, res);
	   current_item_ref := SOME (src, res);
	   Capi.to_front shell)

      fun get_selection _ =
        let
          val s1 = Capi.Text.get_selection sourceText
        in
          if s1 = "" then Capi.Text.get_selection resultText
          else s1
        end

      val menuspec =
        [main_menu,
         ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME (fn _ => Capi.Text.copy_selection sourceText),
             delete = NONE,
	     edit_possible = fn _ => false,
             selection_made = fn _ => get_selection () <> "",
	     tail = []}),
	 view_menu]

      val sep_size = 10

    in
      Menus.make_submenus (menuBar,menuspec);
      Capi.Layout.lay_out
        (sourcePane,
         [Capi.Layout.FIXED sourceTitleLabel,
          Capi.Layout.FLEX sourceScroll,
          Capi.Layout.SPACE]);
      Capi.Layout.lay_out
        (resultPane,
         [Capi.Layout.FIXED resultTitleLabel,
          Capi.Layout.FLEX resultScroll,
          Capi.Layout.SPACE]);
      case contextLabel
      of MLWorks.SOME w =>
        Capi.Layout.lay_out
        (frame,
         [Capi.Layout.MENUBAR menuBar,
          Capi.Layout.FIXED w,
          Capi.Layout.PANED paned])
      |  MLWorks.NONE => 
        Capi.Layout.lay_out
        (frame,
         [Capi.Layout.MENUBAR menuBar,
          Capi.Layout.SPACE,
          Capi.Layout.PANED paned]);
      Capi.initialize_toplevel shell;
      show_defn
    end

  fun show_defn (parent, tooldata) =
    let
      val display_fun = ref NONE
      fun destroy_fun _ = display_fun := NONE
    in
      fn auto =>
      fn (src, res) =>
        case !display_fun of
          SOME f => f auto (src, res)
        | _ =>
          if auto then
 	    ()
          else
            let
	      val f = create (parent, tooldata, destroy_fun)
            in
	      f false (src, res);
              display_fun := SOME f
            end
    end

end;
@


1.33.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.33  1998/02/18  16:57:40  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
@


1.32
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d300 1
d365 1
a365 1
    if do_debug then MLWorks.IO.output(MLWorks.IO.terminal_out,s ^ "\n") else ()
@


1.32.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.32  1997/05/01  13:09:17  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.32.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.32  1997/05/01  13:09:17  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
@


1.31
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d431 1
a431 1
      val current_item_ref = ref Option.NONE
d454 1
a454 1
                   Option.SOME x => duplicate x
d458 1
a458 1
                   Option.SOME x => true
d480 1
a480 1
	   current_item_ref := Option.SOME (src, res);
d495 4
a498 4
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME (fn _ => Capi.Text.copy_selection sourceText),
             delete = Option.NONE,
d519 1
a519 1
      of MLWorks.Option.SOME w =>
d525 1
a525 1
      |  MLWorks.Option.NONE => 
d537 2
a538 2
      val display_fun = ref Option.NONE
      fun destroy_fun _ = display_fun := Option.NONE
d543 1
a543 1
          Option.SOME f => f auto (src, res)
d552 1
a552 1
              display_fun := Option.SOME f
@


1.31.6.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.31.6.1  1997/05/12  10:31:25  hope
 * branched from 1.31
 *
@


1.31.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.31.6.1  1997/05/12  10:31:25  hope
 * branched from 1.31
 *
@


1.31.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.31.6.1  1997/05/12  10:31:25  hope
 * branched from 1.31
 *
@


1.31.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.31.6.1.1.1  1997/07/28  18:17:17  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31.5.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.4.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.4.1.1.1
log
@branched from 1.31.4.1
@
text
@a3 3
 * Revision 1.31.4.1  1996/12/17  17:45:06  hope
 * branched from 1.31
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 4
 * Revision 1.31  1996/11/06  11:15:57  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.31.1.1.1.1
log
@branched from 1.31.1.1
@
text
@a3 3
 * Revision 1.31.1.1  1996/11/14  12:45:59  hope
 * branched from 1.31
 *
@


1.30
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d4 3
d291 1
a291 1
require "../basis/__integer";
@


1.30.3.1
log
@branched from 1.30
@
text
@a3 3
 * Revision 1.30  1996/05/10  14:45:45  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a3 3
 * Revision 1.30  1996/05/10  14:45:45  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a3 3
 * Revision 1.30  1996/05/10  14:45:45  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
@


1.29
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d492 1
@


1.28
log
@Replacing MLWorks.Integer with basis file
@
text
@d4 3
d347 1
a347 1
    if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()
@


1.27
log
@Corrected behaviour of window close function.
@
text
@d4 3
d279 2
a331 1
  structure Integer = MLWorks.Integer
d367 1
a367 1
          "Source Browser #" ^ Integer.makestring n
@


1.26
log
@Converting this to be a source browser.
@
text
@d4 3
d406 3
a408 1
      fun close_window _ = Capi.destroy shell
@


1.25
log
@Type of GuiUtils.value_menu has changed.
@
text
@d4 3
d273 1
a276 5
require "../interpreter/shell";
require "../interpreter/tty_listener";
require "../interpreter/shell_utils";
require "../interpreter/action_queue";
require "../debugger/ml_debugger";
a277 2
require "debugger_window";
require "profile_tool";
a280 2
require "console";
require "error_browser";
a286 5
  structure Shell: SHELL
  structure ShellUtils : SHELL_UTILS
  structure TTYListener: TTY_LISTENER
  structure Ml_Debugger: ML_DEBUGGER
  structure ProfileTool : PROFILE_TOOL
a289 1
  structure DebuggerWindow : DEBUGGERWINDOW
d291 1
a291 7
  structure Console : CONSOLE
  structure ActionQueue: ACTION_QUEUE
  structure ErrorBrowser: ERROR_BROWSER

  sharing ActionQueue.Info = ShellUtils.Info

  sharing Ml_Debugger.ValuePrinter.Options = ShellUtils.Options = ToolData.ShellTypes.Options
d295 1
a295 3
	       GuiUtils.user_preferences =
	       ProfileTool.user_preferences =
	       Console.user_preferences
d302 2
a303 8
	       GuiUtils.user_tool_options = ShellUtils.UserOptions =
	       ActionQueue.UserOptions = UserOptions.user_tool_options

  sharing type Shell.Context = ShellUtils.Context = ToolData.ShellTypes.Context

  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData

  sharing type ToolData.UserContext.Result = ShellUtils.Result
d305 3
a307 3
  sharing type Menus.Widget = Console.Widget = DebuggerWindow.Widget =
	       ProfileTool.Widget = ToolData.Widget = GuiUtils.Widget =
	       ErrorBrowser.Widget = Console.Widget = Capi.Widget
a308 2
  sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
   
d311 2
a312 1
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
d314 2
a315 9
  sharing type ErrorBrowser.error = ActionQueue.Info.error

  sharing type ActionQueue.user_context = ToolData.ShellTypes.user_context =
	       GuiUtils.user_context = ShellUtils.user_context

  sharing type Preferences.preferences = ShellUtils.preferences =
               Ml_Debugger.preferences = ToolData.ShellTypes.preferences

  sharing type ErrorBrowser.location = ShellUtils.Info.Location.T
a317 2

  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
a319 1
  structure Info = ShellUtils.Info
a320 1
  structure Options = ShellUtils.Options
d322 1
d328 2
a329 2
  type Context = ShellUtils.Context
  type UserOptions = ShellUtils.UserOptions
d336 2
a337 1
  fun debug s = if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()
d339 4
a342 2
  fun create (tooldata as ToolData.TOOLDATA
		{args,appdata,current_context,motif_context,tools}) =
a348 1
      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata
d360 1
a360 1
          "Evaluator #" ^ Integer.makestring n
a362 2
      val location_title = "<"^title^">"

d365 1
a365 1
        Capi.make_main_window ("evaluator",title,applicationShell,full_menus)
d370 2
a371 5
      val inputPane =
  	Capi.make_managed_widget ("inputPane", Capi.Form, paned,[]);

      val inputTitleLabel =
  	Capi.make_managed_widget ("inputTitleLabel", Capi.Label, inputPane, [])
d373 3
a375 1
      val (inputScroll,inputText) = Capi.make_scrolled_text ("textIO", inputPane, [])
d377 2
a378 1
      val _ = Capi.transfer_focus (frame,inputText)
d380 2
a381 2
      val buttonPane =
  	Capi.make_managed_widget ("buttonPane", Capi.RowColumn,inputPane, []);
d383 3
a385 1
      val outputPane = Capi.make_managed_widget ("outputPane", Capi.Form, paned, [])
d387 2
a388 4
      val outputTitleLabel =
  	Capi.make_managed_widget ("outputTitleLabel", Capi.Label,outputPane, [])

      val (outputScroll,outputText) = Capi.make_scrolled_text ("resultText",outputPane, [])
a396 15
      fun print_result s =
	Capi.Text.insert (outputText, Capi.Text.get_insertion_position outputText, s);

      val errstream = GuiUtils.make_outstream (print_result)

      (*** Debugger Functions ***)

      (* This creates the debugger window when the evaluator is being created *)
      (* Strange things happen if done at debugger entry time *)
      val debugger_type = 
        Ml_Debugger.WINDOWING
	  (DebuggerWindow.make_debugger_window (shell, title ^ " Debugger",tooldata),
	   print_result,
	   false)

d401 1
a401 147
      fun debugger_function f x =
        Ml_Debugger.with_start_frame
        (fn base_frame =>
         (f x)
         handle
	    exn as ShellTypes.DebuggerTrapped => raise exn
         |  exn as Shell.Exit _ => raise exn
         |  exn as Interrupt => raise exn
         |  exn as Info.Stop _ => raise exn
         |  exn as Capi.SubLoopTerminated => raise exn
         |  exn =>
           (Ml_Debugger.ml_debugger
              (debugger_type,
               ShellTypes.new_options (user_options, get_user_context ()),
               Preferences.new_preferences user_preferences)
              (base_frame,
               Ml_Debugger.EXCEPTION exn,
               Ml_Debugger.POSSIBLE
                 ("quit (return to evaluator)",
                  Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
               Ml_Debugger.NOT_POSSIBLE);
            raise ShellTypes.DebuggerTrapped))
   
      val profiler = ProfileTool.create (applicationShell,user_preferences)

      val shell_data = 
        ShellTypes.SHELL_DATA
        {get_user_context = get_user_context,
         user_options = user_options,
	 user_preferences = user_preferences,
         prompter = prompter,
         debugger = debugger_function,
	 profiler = profiler,
         exit_fn = fn n => raise Shell.Exit n,
         x_running = true,	(* Can't start X interface from an evaluator *)
         mk_xinterface_fn = mk_xinterface_fn,
				(* for starting X from a saved image *)
         mk_tty_listener = TTYListener.listener
				(* for starting saved images *)
         }
      
      fun set_state (motif_context) =
	case contextLabel
	of MLWorks.Option.SOME w =>
          (local_context := motif_context;
           let
              val context_name = GuiUtils.get_context_name motif_context

              val cstring = "Context: " ^ context_name
            in
              Capi.set_label_string (w, cstring)
            end)
	|  MLWorks.Option.NONE => ()
              
      val _ = set_state (!local_context)

      val current_definition =
	ref MLWorks.Option.NONE: (string * string) MLWorks.Option.option ref
      (* This reference stores the current definition when the display
	 is showing something else (such as an entry on the history list).
	 If the current definition is being displayed, then this reference
	 contains NONE. *)

      val current_history =
        ref MLWorks.Option.NONE: int MLWorks.Option.option ref
      (* This reference stores the index of the current item in the history.
	 It is set by the history commands and by setting the selection. *)

      fun show_current _ =
	case !current_definition
	of MLWorks.Option.SOME (src, res) =>
	  (* Restore saved definition *)
	  (Capi.Text.set_string (inputText, src);
	   Capi.Text.set_string (outputText, res);
	   current_definition := MLWorks.Option.NONE;
	   current_history := MLWorks.Option.NONE)
	|  MLWorks.Option.NONE =>
	  current_history := MLWorks.Option.NONE
	
      fun prev_hist () =
	case !current_history
	of MLWorks.Option.NONE =>
	  (current_definition :=
	     MLWorks.Option.SOME
	       (Capi.Text.get_string inputText, Capi.Text.get_string outputText);
	   case UserContext.get_latest (get_user_context ())
	   of MLWorks.Option.NONE =>
	     current_definition := MLWorks.Option.NONE
	   |  MLWorks.Option.SOME (UserContext.ITEM (n, _, _, result, src)) =>
	     (current_history := MLWorks.Option.SOME n;
	      Capi.Text.set_string (inputText, src);
	      Capi.Text.set_string (outputText, result)))
	|  MLWorks.Option.SOME n =>
	  case UserContext.get_nth (get_user_context (), n-1)
	  of MLWorks.Option.NONE =>
	    ()
	  |  MLWorks.Option.SOME (UserContext.ITEM (_, _, _, result, src)) =>
	    (current_history := MLWorks.Option.SOME (n-1);
	     Capi.Text.set_string (inputText, src);
	     Capi.Text.set_string (outputText, result))

      fun next_hist () =
	case !current_history
	of MLWorks.Option.NONE =>
	  ()
	|  MLWorks.Option.SOME n =>
	  case UserContext.get_nth (get_user_context (), n+1)
	  of MLWorks.Option.NONE =>
	    (show_current ())
	  |  MLWorks.Option.SOME (UserContext.ITEM (_, _, _, result, src)) =>
	    (current_history := MLWorks.Option.SOME (n+1);
	     Capi.Text.set_string (inputText, src);
	     Capi.Text.set_string (outputText, result))
	    
      fun select (UserContext.ITEM (n, _, _, result, src)) =
	(case !current_definition
	 of MLWorks.Option.SOME _ => ()
	 |  MLWorks.Option.NONE =>
	   current_definition :=
	     MLWorks.Option.SOME
	       (Capi.Text.get_string inputText, Capi.Text.get_string outputText);
	 current_history := MLWorks.Option.SOME n;
	 Capi.Text.set_string (inputText, src);
	 Capi.Text.set_string (outputText, result))
	
      fun sense_select user_options =
        case UserContext.get_selected (get_user_context (), user_options)
        of MLWorks.Option.NONE => ()
        |  MLWorks.Option.SOME entry => select entry

      val context_key =
	ToolData.add_context_fn
          (current_context, (set_state, get_user_options, ToolData.WRITABLE))

      val select_key =
	UserContext.add_select_fn
	  (get_user_context (), (select, get_user_options))

      val {instream, outstream, console_widget, console_visible, show_console,
	   clear_input} =
	Console.create (shell, title, user_preferences)

      val quit_funs = ref []

      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

      (*** IO functions ***)
d403 1
a403 1
      fun to_top () = Capi.Text.set_insertion_position (inputText,0)
d405 2
a406 38
      fun to_bottom () =
        let
          val pos = Capi.Text.get_last_position inputText
        in
	  Capi.Text.set_insertion_position (inputText, pos)
        end

      fun clear text =
	Capi.Text.set_string (text, "");

      fun message_fun s =
        Capi.send_message (shell,s)

      exception NoLocation
      fun get_location line =
        let
          val sz = size line
          fun aux index =
            if index < sz
              then
                if String.ordof(line,index) = ord ":"
                  then index+1
                else
                  aux (index+1)
            else
              raise NoLocation
          (* skip up to second ":" *)
          val result = String.substring(line,0,(aux (aux 0))-1)
        in
          result
        end
      
      val _ =
	quit_funs :=
	  (fn _ => 
	     (ToolData.remove_context_fn (current_context, context_key);
	      UserContext.remove_select_fn (get_user_context (), select_key)))
	  :: !quit_funs
d408 1
a408 1
      datatype Exitter = NONE | SOME of (unit -> unit)
d410 1
a410 51
      val exitter_ref = ref NONE


      (* name completion *)
      fun do_completion start_pos =
        let
          val (line,ix) = Capi.Text.get_line_and_index (inputText,start_pos)
          val line2 = line
          val ix2 = ix - (size line - size line2)
          val subline = if ix2 > 0 then String.substring (line,0,ix2) else ""

          val Preferences.PREFERENCES
		{environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu, ...},
		 ...} =
            ShellTypes.get_current_preferences shell_data

          val options = ShellTypes.get_current_options shell_data

          val (sofar,completions) = 
            ShellUtils.get_completions
	      (subline, options, get_context ())

          fun insert_fun a =
	    ( Capi.Text.insert
		(inputText, start_pos,
		 String.substring (a, size sofar, size a - size sofar));
	      Capi.Text.set_insertion_position
		(inputText, start_pos + size a - size sofar))
        in
          case completions of
            [] => beep ()
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if (!completion_menu) then
                    let
                      val popdown = Capi.list_select (shell,"completions")(l,insert_fun, fn x => x)
                    in
                      Capi.set_focus inputText;
                      exitter_ref := SOME popdown
                    end
                  else beep ()
                else insert_fun c
              end
        end

      fun highlight
	    (Info.Location.EXTENT {s_line, s_col, e_line, e_col, ...}, b) =
d412 1
a412 20
	  val str = Capi.Text.get_string inputText

	  (* input: number of lines to advance * start position.
	     returns: position of first character of nth line. *)
	  fun n_lines (1, pos) = pos
	  |   n_lines (n, pos) =
	    if String.ordof (str, pos) = ord "\n" then
	      n_lines (n-1, pos+1)
	    else
	      n_lines (n, pos+1)
	    handle
	      Ord => size str - 1

	  val s_pos = n_lines (s_line, 0) + s_col - 1;

	  val e_pos = 
	    if s_line = e_line then
	      s_pos + e_col - s_col
	    else
	      n_lines (e_line - s_line + 1, s_pos) + e_col - 1
d414 1
a414 1
	  Capi.Text.set_highlight (inputText, s_pos, e_pos, b)
a415 1
      |   highlight _ = ()
d417 21
a437 244
      fun error_handler
	    (error, error_list, header, preferences_fn, redo_action) =
        let
          fun edit_action location =
	    if ShellUtils.editable location then
              {quit_fn = ShellUtils.edit_location (location, preferences_fn()),
	       clean_fn = fn () => ()}
	    else
	      (highlight (location, true);
	       {quit_fn = fn () => (),
		clean_fn = fn () => highlight (location, false)})

          val Preferences.PREFERENCES
		{environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {use_error_browser, ...},
		 ...} =
	    preferences_fn ()

	  fun show_full_message (Info.ERROR(_,_,message)) =
	    print_result message
        in
	  if !use_error_browser then
            ErrorBrowser.create
              {parent = shell,
	       errors = rev error_list,
	       action_message = header,
	       file_message = "Error in: " ^ location_title,
	       edit_action = edit_action,
	       editable = fn _ => true,
               redo_action = redo_action}
	  else
	    Lists.iterate show_full_message error_list
        end

      val UserOptions.USER_TOOL_OPTIONS ({sense_selection, ...}, _) =
	user_options

      fun with_sense_selection b f x =
	let val old = ref (!sense_selection)
	in
	  sense_selection := b;
	  f x
	  handle e => (sense_selection := !old; raise e);
	  sense_selection := !old
	end

      val error_info = Info.default_options

      fun compile src =
        let
          (* compile the source in the parsing context *)
          val result = ShellUtils.compile_string error_info (src,location_title,get_user_context,user_options,debugger_function)
	  val _ =
	    with_sense_selection
	      false
	      UserContext.process_result
	      (src, result, get_user_context (),
               ShellTypes.get_current_options shell_data, user_options,
	       print_result);
        in
          ActionQueue.do_actions
            (get_user_context (),
             ShellTypes.get_user_options shell_data,
             debugger_function,
	     print_result,
             fn s => output (std_out, "Make: compiling " ^ s))
 	end

      fun handler s =
        MLWorks.IO.with_standard_input
          instream
	  (fn () =>
             MLWorks.IO.with_standard_output
               outstream
               (fn () =>
                MLWorks.IO.with_standard_error
                errstream
                (fn () =>
                 Ml_Debugger.with_debugger_type
                 debugger_type
                 (fn _ => 
                  ShellTypes.with_toplevel_name location_title
                  (fn _ =>
                   ShellTypes.with_shell_data shell_data
                   (fn _ => (compile s;
                             MLWorks.IO.flush_out std_out)))))))

      (* The following functions change the state during the evaluation of
	 an expression.  All the buttons are made insensitive and the cursor
	 is changed to a busy cursor.  The in_evaluation flag is set; this
	 is tested in the evaluate function to prevent further evaluations
	 being started from this tool if one evaluation enters a recursive
	 input loop. *)
      val in_evaluation = ref false

      fun buttons_sensitive () = not (!in_evaluation)

      val buttons_update_fn_ref = ref (fn () => ())
      fun buttons_update_fn () = (!buttons_update_fn_ref) ()

      fun set_evaluation () =
	(in_evaluation := true;
         buttons_update_fn ();
	 Capi.set_busy shell)

      fun unset_evaluation () =
	(in_evaluation := false;
         buttons_update_fn();
	 Capi.unset_busy shell)

      (* The parameter is an internal mlval.  It is not used, except as the
	 argument of the recursive calls. *)
      fun evaluate x =
	if !in_evaluation then
	  ()
	else
	  (clear outputText;
	   clear_input ();
	   set_evaluation ();
	   Capi.set_focus inputText;
	   handler (Capi.Text.get_string inputText)
	   handle
	     ActionQueue.Error(message, error, error_list) =>
	        error_handler
                  (error, error_list, "Evaluate",
                   fn () => ShellTypes.get_current_preferences shell_data,
                   fn () => evaluate x)
           | ActionQueue.Handled => ()
	   | ShellTypes.DebuggerTrapped => ()
	   | Info.Stop (error,error_list) =>
              error_handler 
                (error, error_list, "Evaluate",
                 fn () => ShellTypes.get_current_preferences shell_data,
                 fn () => evaluate x)
           | exn => (unset_evaluation (); raise exn);
	   current_definition := MLWorks.Option.NONE;
	   current_history := MLWorks.Option.NONE;
	   unset_evaluation ())

      fun time_eval x =
	let
	  val start = MLWorks.Time.Elapsed.elapsed ()

	  fun print_time () =
	    let
	      val elapsed = MLWorks.Time.Elapsed.elapsed_since start
	    in
	      print_result (MLWorks.Time.Elapsed.format elapsed ^ "\n")
	    end

	  val result =
	    evaluate x
	    handle
	      exn => (print_time (); raise exn)
	in
	  print_time ();
	  result
	end

      fun select_state motif_context =
        (set_state motif_context;
	 ToolData.set_current
	   (current_context, context_key, user_options, motif_context))

      fun start_of_line () =
        let
	  val pos = Capi.Text.get_insertion_position inputText
          val new_pos = Capi.Text.current_line (inputText,pos)
        in
          Capi.Text.set_insertion_position (inputText,new_pos)
        end
          
      val escape_pressed = ref false

      fun do_escape () = escape_pressed := true

      fun despatch_key bindings key =
        let
          fun loop [] = (debug key; false)
            | loop ((key',action)::rest) =
              if key = key' then (action (); true)
              else loop rest
        in
          loop bindings
        end

      val meta_bindings =
        [("w", fn _ => Capi.Text.copy_selection inputText),
         ("p", fn _ => prev_hist ()),
         ("n", fn _ => next_hist ())]

      val normal_bindings =
        [("\173", evaluate), 	(* control-return *)
         ("\159", fn _ => (clear inputText; clear outputText)),
		  		(* control-delete *)
         ("\^A",  start_of_line),
         ("\^W",  fn _ => Capi.Text.cut_selection inputText),
         ("\^Y",  fn _ => Capi.Text.paste_selection inputText),
         ("\t" ,  fn _ => do_completion (Capi.Text.get_insertion_position inputText))]         

      val despatch_meta = despatch_key meta_bindings
      val despatch_normal = despatch_key normal_bindings

      fun text_handler (key,modifiers) =
        (case !exitter_ref of
           NONE => ()
         | SOME f => (f(); exitter_ref := NONE);
         if Lists.member (Capi.Event.meta_modifier, modifiers)
           then despatch_meta key
         else despatch_normal key)
        handle Shell.Exit _ => (Capi.destroy shell; true)

      fun handle_key str =
        (despatch_meta str; ())

      fun modifyVerify (start_pos,end_pos,str,set_fn) =
        let
          val _ = 
            case !exitter_ref of
              NONE => ()
            | SOME f => (f(); exitter_ref := NONE)
        in
          if !escape_pressed andalso size str = 1 
            then 
              (escape_pressed := false;
               set_fn false;
               handle_key str)
          else
             set_fn true
        end
	handle Shell.Exit _ => Capi.destroy shell

      fun mk_tooldata () =
	ToolData.TOOLDATA {args = ShellTypes.get_listener_args shell_data,
			   appdata = appdata,
			   current_context = current_context,
			   motif_context = !local_context,
                           tools = tools}

      fun get_user_options () = user_options

      fun close_window _ =
	(do_quit_funs ();
	 Capi.destroy shell)
d443 1
a443 2
	   caller_update_fn = sense_select,
	   sensitivity = GuiUtils.SENSE_ALL,
d447 10
a456 6
	Menus.CASCADE
	  ("view",
	   view_options
	   @@ [Menus.TOGGLE
		("console", console_visible, show_console, fn () => true)],
	   fn _ => true)
a457 28
      val action_menu =
        Menus.CASCADE
        ("action",
         [Menus.PUSH ("evaluate",
                      evaluate,
                      buttons_sensitive),                    
          Menus.PUSH ("clear",
                      fn _ => (clear inputText; clear outputText;
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("current",
                      fn _ => (show_current ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("prev",
                      fn _ => (prev_hist ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("next",
                      fn _ => (next_hist ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("time",
                      fn _ => (time_eval ();
                               Capi.set_focus inputText),
                      buttons_sensitive)],
         fn _ => true)
        
d460 1
a460 1
          val s1 = Capi.Text.get_selection inputText
d462 1
a462 1
          if s1 = "" then Capi.Text.get_selection outputText
a465 11
      (* only one will actually have a selection *)
      fun delete_selection _ =
        (Capi.Text.remove_selection inputText;
         Capi.Text.remove_selection outputText)

      fun paste s =
        Capi.Text.insert
        (inputText,
         Capi.Text.get_insertion_position inputText,
         s)

d467 1
a467 2
        [ToolData.works_menu
	  (mk_tooldata, close_window, fn _ => true, get_user_context), 
d469 8
a476 17
         (shell,
          {cut = Option.SOME (fn _ => Capi.Text.cut_selection inputText),
           paste = Option.SOME (fn _ => Capi.Text.paste_selection inputText),
           copy = Option.SOME (fn _ => Capi.Text.copy_selection inputText),
           delete = Option.SOME (fn _ => Capi.Text.remove_selection inputText),
           selection_made = fn _ => get_selection () <> "",
	   tail = []}),
         action_menu,
	 view_menu,
	 GuiUtils.context_menu
	   {set_state = select_state,
	    get_context = fn _ => !local_context,
	    writable = GuiUtils.WRITABLE,
	    applicationShell = applicationShell,
	    shell = shell,
	    user_preferences = user_preferences},
           ToolData.windows_menu ()]
a479 26
      val {update, ...} =
        Menus.make_buttons
        (buttonPane,
         [Menus.PUSH ("evaluate",
                      evaluate,
                      buttons_sensitive),                    
          Menus.PUSH ("clear",
                      fn _ => (clear inputText; clear outputText;
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("current",
                      fn _ => (show_current ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("prev",
                      fn _ => (prev_hist ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("next",
                      fn _ => (next_hist ();
                               Capi.set_focus inputText),
                      buttons_sensitive),
          Menus.PUSH ("time",
                      fn _ => (time_eval ();
                               Capi.set_focus inputText),
                      buttons_sensitive)]);
a480 1
      buttons_update_fn_ref := update;
d483 4
a486 5
      (inputPane,
       [Capi.Layout.FIXED inputTitleLabel,
        Capi.Layout.FLEX inputScroll,
        Capi.Layout.SPACE,
        Capi.Layout.FIXED buttonPane]);
d488 4
a491 4
      (outputPane,
       [Capi.Layout.FIXED outputTitleLabel,
        Capi.Layout.FLEX outputScroll,
        Capi.Layout.SPACE]);
a504 3
      Capi.Text.add_handler (inputText, text_handler);
      Capi.Text.add_modify_verify (inputText, modifyVerify);
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
d506 1
a506 1
      Capi.set_focus inputText
d508 22
@


1.24
log
@Reordering top level menus.
@
text
@d4 3
d1037 2
a1038 1
           selection_made = fn _ => get_selection () <> ""}),
a1046 8
	    search_opt =
	      MLWorks.Option.SOME
		(fn s =>
		   Capi.Text.insert
		     (inputText,
		      Capi.Text.get_insertion_position inputText,
		      s),
		 true),
@


1.23
log
@Moved list_select to capi
@
text
@d4 3
a1027 1
         ToolData.windows_menu (),
d1051 2
a1052 1
	    user_preferences = user_preferences}]
@


1.22
log
@Fixing problem with busy cursor
@
text
@d4 3
d676 1
a676 1
                      val popdown = GuiUtils.list_select (shell,"completions")(l,insert_fun, fn x => x)
@


1.21
log
@Changing interface to edit_menu
@
text
@d4 3
d844 2
a845 1
                 fn () => evaluate x);
@


1.20
log
@Adding call to transfer_focus
@
text
@d4 3
d894 1
a894 1
        [("w", fn _ => GuiUtils.copySelection inputText),
d903 2
a904 2
         ("\^W",  fn _ => GuiUtils.cutSelection inputText),
         ("\^Y",  fn _ => GuiUtils.pasteSelection inputText),
d1020 6
a1025 3
         {paste = Option.SOME paste,
          copy = Option.SOME get_selection,
          delete = Option.SOME delete_selection},
@


1.19
log
@Fixing problem with last change
@
text
@d4 3
d399 2
d666 6
a671 4
                    exitter_ref :=
		      SOME (GuiUtils.list_select
			      (shell,"completions")
		      	      (l,insert_fun, fn x => x))
d908 6
a913 3
        if Lists.member (Capi.Event.meta_modifier, modifiers)
          then despatch_meta key
        else despatch_normal key
d921 1
a921 1
          val _ =
@


1.18
log
@Changing text callbacks
@
text
@@


1.17
log
@Changing button resources
@
text
@d4 3
d894 2
a895 1
         ("\^Y",  fn _ => GuiUtils.pasteSelection inputText)]
a920 4
          else if str = "\t"
            then
              (do_completion start_pos;
               set_fn false)
@


1.16
log
@Adding windows menu
@
text
@d4 3
d1033 1
a1033 1
         [Menus.PUSH ("evaluateButton",
d1036 1
a1036 1
          Menus.PUSH ("clearButton",
d1040 1
a1040 1
          Menus.PUSH ("currentButton",
d1044 1
a1044 1
          Menus.PUSH ("prevButton",
d1048 1
a1048 1
          Menus.PUSH ("nextButton",
d1052 1
a1052 1
          Menus.PUSH ("timeButton",
@


1.15
log
@Simplifying capi interface.
@
text
@d4 3
d337 1
d980 19
d1001 6
a1006 1
	  (mk_tooldata, close_window, fn _ => true, get_user_context),
@


1.14
log
@Now creates a new list widget each time that completion is asked for, so that
it pops up with the correct size under TWM.
@
text
@d4 4
d898 1
a898 1
      fun modifyVerify callback_data =
a903 3

          val (event,start_pos,end_pos,str,set_fn) =
            Capi.Callback.convert_verify_data callback_data
d1053 1
a1053 1
      Capi.Callback.add (inputText, Capi.Callback.ModifyVerify, modifyVerify);
@


1.13
log
@Make profile tool a child of the application shell.
@
text
@d4 3
a610 1
      val completion_popup = GuiUtils.list_select (shell,"completions")
d648 3
a650 1
		      SOME (completion_popup (l,insert_fun, fn x => x))
@


1.12
log
@Renamed ShellUtils.edit_source to ShellUtils.edit_location.
@
text
@d4 3
d438 1
a438 1
      val profiler = ProfileTool.create (shell,user_preferences)
@


1.11
log
@Add profiler to the shelldata made here.
@
text
@d4 3
d682 1
a682 1
              {quit_fn = ShellUtils.edit_source (location, preferences_fn()),
@


1.10
log
@The search_opt field of the context menu now takes a boolean component which
controls whether users are given the option of which contexts to search.
In input tools this should be true, in the context browser it should be false.
@
text
@d4 5
d240 1
d256 1
d273 1
d291 1
a291 1
	       ToolData.Widget = GuiUtils.Widget =
d432 2
d441 1
@


1.9
log
@Added search facility.
@
text
@d4 3
d971 2
a972 1
		      s)),
@


1.8
log
@Moved breakpoints_menu to podium.
@
text
@d4 3
d962 7
a968 1
	    search_opt = MLWorks.Option.NONE,
@


1.7
log
@Menus.make_buttons now returns a record of functions.
@
text
@d4 3
d920 1
a920 1
      val evaluate_menu =
d922 5
a926 5
        ("evaluate",
         [Menus.PUSH ("evaluateButton",
                    evaluate,
                    buttons_sensitive),                    
          Menus.PUSH ("clearButton",
d930 1
a930 1
          Menus.PUSH ("currentButton",
d934 1
a934 1
          Menus.PUSH ("prevButton",
d938 1
a938 1
          Menus.PUSH ("nextButton",
d942 1
a942 1
          Menus.PUSH ("timeButton",
d951 1
a951 1
         evaluate_menu,
a952 1
	 GuiUtils.breakpoints_menu shell,
d958 2
@


1.6
log
@Added highlight function, for highlighting errors in the input text window.
@
text
@d4 3
d959 27
d987 1
a987 26
      buttons_update_fn_ref :=
      Menus.make_buttons
      (buttonPane,
       [Menus.PUSH ("evaluateButton",
                    evaluate,
                    buttons_sensitive),                    
        Menus.PUSH ("clearButton",
                    fn _ => (clear inputText; clear outputText;
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("currentButton",
                    fn _ => (show_current ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("prevButton",
                    fn _ => (prev_hist ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("nextButton",
                    fn _ => (next_hist ();
                             Capi.set_focus inputText),
                    buttons_sensitive),
        Menus.PUSH ("timeButton",
                    fn _ => (time_eval ();
                             Capi.set_focus inputText),
                    buttons_sensitive)]);
@


1.5
log
@Changing top level window initialization
@
text
@d4 3
d623 28
d655 7
a661 1
             ShellUtils.edit_source (location, preferences_fn())
d679 1
@


1.4
log
@Changes to Capi text widget
@
text
@d4 3
d370 2
d637 1
a637 1
              {parent = applicationShell,
d688 11
a698 8
                  Ml_Debugger.with_debugger_type
                    debugger_type
                    (fn _ => 
                       ShellTypes.with_toplevel_name location_title
                       (fn _ =>
			  ShellTypes.with_shell_data shell_data
			     (fn _ => (compile s;
				       MLWorks.IO.flush_out std_out))))))
d973 1
a973 2
      Capi.reveal shell;
      Capi.initialize shell;
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
a356 3
      val _ = Capi.manage inputText
      val _ = Capi.manage outputText

d373 1
a373 1
	  (DebuggerWindow.make_debugger_window (shell, "debugger",tooldata),
d782 1
a782 1
          fun loop [] = (debug key; beep ())
d784 1
a784 1
              if key = key' then action ()
d806 5
a810 13
      fun activate callback_data =
	let 
          val event = Capi.Callback.get_event callback_data
        in
          case Capi.Event.get_key_data event of
            MLWorks.Option.SOME (key,modifiers) =>
              if Lists.member (Capi.Event.meta_modifier, modifiers)
                then despatch_meta key
              else despatch_normal key
          | _ => (debug("activate: non-key event");
                  beep ())
        end
        handle Shell.Exit _ => Capi.destroy shell
d813 1
a813 1
        despatch_meta str
d940 2
a941 2
       [Capi.Layout.OTHER inputTitleLabel,
        Capi.Layout.TEXT inputScroll,
d943 1
a943 1
        Capi.Layout.OTHER buttonPane]);
d946 2
a947 2
       [Capi.Layout.OTHER outputTitleLabel,
        Capi.Layout.TEXT outputScroll,
d954 1
a954 1
          Capi.Layout.OTHER w,
d962 1
a962 1
      Capi.Callback.add (inputText, Capi.Callback.Activate, activate);
d965 3
a967 4
      Capi.manage shell;
      Capi.realize shell;
      Capi.set_focus inputText;
      Capi.realize console_widget
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d876 28
d907 1
d920 1
a920 1
      Menus.make_submenus
d946 11
d960 4
a963 3
	  [Capi.Layout.MENUBAR menuBar,
	   Capi.Layout.OTHER w,
	   Capi.Layout.PANED paned]
d966 4
a969 12
	  [Capi.Layout.MENUBAR menuBar,
	   Capi.Layout.SPACE,
	   Capi.Layout.PANED paned];
      Capi.Layout.lay_out
	[Capi.Layout.OTHER inputTitleLabel,
	 Capi.Layout.TEXT inputScroll,
	 Capi.Layout.SPACE,
	 Capi.Layout.OTHER buttonPane];
      Capi.Layout.lay_out
	[Capi.Layout.OTHER outputTitleLabel,
	 Capi.Layout.TEXT outputScroll,
	 Capi.Layout.SPACE];
@


1.1
log
@new unit
New unit
@
text
@d4 4
d212 2
a213 2
require "../library/capi";
require "../library/menus";
@
