head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.1
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.34
	MLWorks_20m1_1997_10_23:1.34
	MLWorks_11r1:1.31.9.1.1.1.1
	MLWorks_workspace_97:1.34.2
	MLWorks_dt_wizard:1.34.1
	MLWorks_11c0_1997_09_09:1.31.9.1.1.1
	MLWorks_10r3:1.31.9.1.3
	MLWorks_10r2_551:1.31.9.1.2
	MLWorks_11:1.31.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.31.9.1
	MLWorks_20m0_1997_06_20:1.32
	MLWorks_1_0_r2c2_1997_06_14:1.31.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.31.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.31.9
	MLWorks_BugFix_1997_04_24:1.31
	MLWorks_1_0_r2_Win32_1997_04_11:1.31
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.7.1.1
	MLWorks_gui_1996_12_18:1.31.8
	MLWorks_1_0_Win32_1996_12_17:1.31.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.31.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.31.4.1
	JFHgui:1.31.6
	MLWorks_1_0_Irix_1996_11_28:1.31.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.5
	MLWorks_1_0_Unix_1996_11_14:1.31.4
	MLWorks_Open_Beta2_1996_10_11:1.31.3
	MLWorks_License_dev:1.31.2
	MLWorks_1_open_beta_1996_09_13:1.31.1
	MLWorks_Open_Beta_1996_08_22:1.31
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30;
locks; strict;
comment	@ * @;


1.37
date	99.03.23.18.05.40;	author johnh;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	99.02.02.15.59.16;	author mitchell;	state Exp;
branches;
next	1.35;

1.35
date	98.02.19.19.42.05;	author mitchell;	state Exp;
branches;
next	1.34;

1.34
date	97.09.05.10.44.38;	author johnh;	state Exp;
branches
	1.34.1.1
	1.34.2.1;
next	1.33;

1.33
date	97.08.06.14.40.08;	author brucem;	state Exp;
branches;
next	1.32;

1.32
date	97.05.02.17.26.09;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	96.08.09.15.25.41;	author nickb;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1
	1.31.5.1
	1.31.6.1
	1.31.7.1
	1.31.8.1
	1.31.9.1;
next	1.30;

1.30
date	96.05.28.14.45.08;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.05.28.11.59.16;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	96.05.28.10.51.18;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.05.24.15.58.11;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.05.24.14.34.40;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.05.07.11.35.06;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	96.05.01.10.48.21;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	96.04.18.10.05.09;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.04.04.10.58.56;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.02.02.12.44.18;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	96.01.25.13.06.43;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	96.01.17.11.28.50;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.11.22.13.54.52;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.11.16.14.14.13;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.13.15.23.25;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.10.19.12.35.10;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.10.15.13.58.24;	author brianm;	state Exp;
branches;
next	1.13;

1.13
date	95.10.13.15.50.50;	author brianm;	state Exp;
branches;
next	1.12;

1.12
date	95.10.13.08.41.06;	author brianm;	state Exp;
branches;
next	1.11;

1.11
date	95.10.10.16.06.30;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	95.10.09.08.29.37;	author brianm;	state Exp;
branches;
next	1.9;

1.9
date	95.10.06.11.35.46;	author brianm;	state Exp;
branches;
next	1.8;

1.8
date	95.10.05.13.56.03;	author brianm;	state Exp;
branches;
next	1.7;

1.7
date	95.09.21.16.03.59;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.18.14.06.40;	author brianm;	state Exp;
branches;
next	1.5;

1.5
date	95.09.07.11.42.45;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.09.06.14.08.10;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.02.16.12.31;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.57.03;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.27.10.39.07;	author matthew;	state Exp;
branches;
next	;

1.31.1.1
date	96.09.13.11.13.13;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.10.07.16.03.54;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.10.17.11.22.08;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.11.14.12.46.07;	author hope;	state Exp;
branches
	1.31.4.1.1.1;
next	;

1.31.4.1.1.1
date	96.11.28.14.57.53;	author hope;	state Exp;
branches;
next	;

1.31.5.1
date	96.11.22.18.06.31;	author hope;	state Exp;
branches;
next	;

1.31.6.1
date	96.12.17.09.54.33;	author hope;	state Exp;
branches;
next	;

1.31.7.1
date	96.12.17.17.45.12;	author hope;	state Exp;
branches
	1.31.7.1.1.1;
next	;

1.31.7.1.1.1
date	97.02.24.11.34.40;	author hope;	state Exp;
branches;
next	;

1.31.8.1
date	96.12.18.09.39.11;	author hope;	state Exp;
branches;
next	;

1.31.9.1
date	97.05.12.10.31.31;	author hope;	state Exp;
branches
	1.31.9.1.1.1
	1.31.9.1.2.1
	1.31.9.1.3.1;
next	;

1.31.9.1.1.1
date	97.07.28.18.17.24;	author daveb;	state Exp;
branches
	1.31.9.1.1.1.1.1;
next	;

1.31.9.1.1.1.1.1
date	97.10.07.11.42.15;	author jkbrook;	state Exp;
branches;
next	;

1.31.9.1.2.1
date	97.09.08.17.10.56;	author daveb;	state Exp;
branches;
next	;

1.31.9.1.3.1
date	97.09.09.14.06.30;	author daveb;	state Exp;
branches;
next	;

1.34.1.1
date	97.09.10.19.21.02;	author brucem;	state Exp;
branches;
next	;

1.34.2.1
date	97.09.11.20.52.15;	author daveb;	state Exp;
branches;
next	;

1.37.1.1
date	99.04.01.17.55.34;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Moved from library
@


1.37
log
@[Bug #190539]
Fix problem centerOnNode.
@
text
@(*
 * Copyright (c) 1995 Harlequin Ltd.
 *  $Log: _graph_widget.sml,v $
 * Revision 1.36  1999/02/02  15:59:16  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.35  1998/02/19  19:42:05  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.34  1997/09/05  10:44:38  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
 * Revision 1.33  1997/08/06  14:40:08  brucem
 * [Bug #30202]
 * Add functionality to generic graphs in order to improve compilation manager dependency graphs.
 * Also added search facility (this relates to bugs #30202 and #30224).
 *
 * Revision 1.32  1997/05/02  17:26:09  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.30  1996/05/28  14:45:08  matthew
 * Attempting to give dialogs more meaningful names
 *
 * Revision 1.29  1996/05/28  11:59:16  daveb
 * Removed unused debugging code (that referenced MLWorks.RawIO).
 *
 * Revision 1.28  1996/05/28  10:51:18  matthew
 * Updating
 *
 * Revision 1.27  1996/05/24  15:58:11  daveb
 * Changed behaviour of click - clicking an unselected item selects it;
 * clicking a selected item expands or contracts it.
 *
 * Revision 1.26  1996/05/24  14:34:40  daveb
 * Graph menu changes.
 *
 * Revision 1.25  1996/05/07  11:35:06  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.24  1996/05/01  10:48:21  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.23  1996/04/18  10:05:09  matthew
 * Adding start/stop graphics functions
 *
 * Revision 1.22  1996/04/04  10:58:56  matthew
 * Changing interface ot allow monitoring of options
 *
 * Revision 1.21  1996/02/02  12:44:18  daveb
 * Changed update behaviour of layout dialog, as it wasn't updating properly
 * after selecting expand_all_nodes.
 *
 * Revision 1.20  1996/01/25  13:06:43  matthew
 * Adding hightlighted flag to draw_item
 *
 * Revision 1.19  1996/01/17  11:28:50  matthew
 * Sorting out some minor problems
 *
 * Revision 1.18  1995/11/22  13:54:52  matthew
 * Renaming some buttons
 *
 * Revision 1.17  1995/11/16  14:14:13  matthew
 * Fiddling with button names
 *
 * Revision 1.16  1995/11/13  15:23:25  matthew
 * Restructuring use of OPTRADIO
 *
 * Revision 1.15  1995/10/19  12:35:10  matthew
 * Removing debug message
 *
 * Revision 1.14  1995/10/15  13:58:24  brianm
 * Added Extent datatype and modified GraphWidget.make interface to
 * include modified item_draw and item_extent functions.
 *
 * Revision 1.13  1995/10/13  15:50:50  brianm
 * Update to button action interface ...
 *
 * Revision 1.11  1995/10/10  16:06:30  brianm
 * Modifications to selection/expansion protocol + changes to GraphSpec.
 *
 * Revision 1.10  1995/10/09  08:29:37  brianm
 * Changed the graph widget repositioning interface and add interface to
 * set the button action functions.
 *
 * Revision 1.9  1995/10/06  11:35:46  brianm
 * Modifying make interface so that initialise takes the selection function
 * and added utilities for repositioning the graph selection.
 *
 * Revision 1.8  1995/10/05  13:56:03  brianm
 * Adding user-controlled graph positioning.
 *
 * Revision 1.7  1995/09/21  16:03:59  nickb
 * Capi.make_scrolled_graphics changed to Capi.make_graphics
 *
 * Revision 1.6  1995/09/18  14:06:40  brianm
 * Updating by adding Capi Point/Region datatypes
 *
 * Revision 1.5  1995/09/07  11:42:45  matthew
 * More stuff
 *
 * Revision 1.4  1995/09/06  14:08:10  matthew
 * General improvements
 *
 * Revision 1.3  1995/08/02  16:12:31  matthew
 * Adding graph menu
 *
 * Revision 1.2  1995/07/27  10:57:03  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/27  10:39:07  matthew
 * new unit
 * Moved from library
 *
 *  Revision 1.2  1995/07/26  13:19:13  matthew
 *  Adding check on initialization of Graphics Ports
 *
 *  Revision 1.1  1995/07/21  13:54:44  matthew
 *  new unit
 *  New graph unit
 *
*)

require "../utils/lists";
require "gui_utils";
require "menus";
require "capi";
require "^.basis.__list";

require "graph_widget";

functor GraphWidget (structure Lists : LISTS
                     structure Menus : MENUS
                     structure Capi : CAPI
		     structure GuiUtils : GUI_UTILS

                     sharing type Menus.Widget = Capi.Widget
                     sharing type Menus.OptionSpec = GuiUtils.OptionSpec

                       ) : GRAPH_WIDGET =
  struct

    type Point = Capi.Point
    type Region = Capi.Region

    type Widget = Capi.Widget
    type GraphicsPort = Capi.GraphicsPorts.GraphicsPort

    (* utils *)
    fun ++ x = x := !x + 1;
    fun -- x = x := !x - 1;
    fun max (x:int,y:int) = if x > y then x else y
    fun min (x:int,y:int) = if x < y then x else y

    fun mk_pt(x,y) = Capi.POINT{x=x,y=y}
    fun mk_reg(x,y,wid,hgt) = Capi.REGION{x=x,y=y,width=wid,height=hgt}

    (* These should be parameters *)
    val left_margin = 0
    val right_margin = 10
    val top_margin = 0
    val bottom_margin = 10

    (* NEXT = put the children below and right of (right and down)
              from the parent *)
    (* BELOW = put the children below the parent (like FileManager) *)
    (* CENTRE = put the children below (right) and on both sides of parent *)
    datatype ChildPosition = NEXT | BELOW | CENTRE

    (* ALWAYS - always expand children (but never contract) *)
    (* TOGGLE - toggle between hidden/exposed               *)
    (* SOMETIMES(hfun) - parent-controlled exposure of children :-) *)
    datatype ChildExpansion = ALWAYS | TOGGLE | SOMETIMES of (bool -> bool)

    (* Horizontal = root on left hand side *)
    (* Vertical = root on top *)
    datatype Orientation = HORIZONTAL | VERTICAL

    datatype LineStyle = STRAIGHT | STEP

    datatype GraphSpec =
      GRAPH_SPEC of
      {child_position : ChildPosition ref,
       child_expansion : ChildExpansion ref,
       default_visibility : bool ref,
       show_root_children : bool ref ,  (* expose root's children? *)
       indicateHiddenChildren : bool ref, (* draw a dotted line
                                             if children are hidden *)
       orientation : Orientation ref,
       line_style: LineStyle ref,
       horizontal_delta : int ref,
       vertical_delta : int ref,
       graph_origin : (int * int) ref,  (* origin for root and hence graph *) 
       show_all : bool ref}

    datatype Extent =
         EXTENT of { left : int, right : int, up : int, down : int } 

    datatype 'a node =
      NODE of {node : 'a,
               id : int, (* not currently used,
                            but useful for unique identification *)
               hide_children : bool ref,
               children : int list,

               hidden : bool ref,
               level : int ref,
               parent_count : int ref, 
               layout_children : int list ref,
               child_offset : int ref,
               selected : bool ref,
               x : int ref,
               y : int ref,
               extent : Extent ref }
      
    fun node_node (NODE {node,...}) = node
      
    fun reset_node
           (NODE {level,hidden,layout_children,
                  parent_count,child_offset,...}) =
	      (hidden := true;
	       level := 0;
	       parent_count := 0;
	       layout_children := [];
	       child_offset := 0)

    val point_extent = EXTENT {up=0,down=0,left=0,right=0}

    fun make_nodes (invisible, nodelist) =
      MLWorks.Internal.ExtendedArray.map_index
      (fn (id,(node,children)) =>
       NODE {node = node,
             hide_children = ref invisible,
             hidden = ref true,
             id = id,
             level = ref 0,
             parent_count = ref 0,
             children = children,
             layout_children = ref [],
             child_offset = ref 0,
             selected = ref false,
             x = ref 0,
             y = ref 0,
             extent = ref point_extent}
      )
      nodelist

    (* This is called from layout_items *)
    (* Return: (nodes, root, get_layout_children) 
       The `nodes' which is returned is the same as the parameter! *)
    fun set_layout (nodes,roots,show_all) =
      let

        fun get_node id = MLWorks.Internal.Array.sub (nodes,id)

        fun set_levels nodes =
          let

            fun get_shown_children (NODE {children,hide_children,...}) =
              if not show_all andalso !hide_children then []
              else children

           (* Need to: *)
           (* reinitialize nodes - set hidden to true etc. *)
           (* eliminate cyclic arcs *)
           (* count the number of visible forward arcs going to each node *)
           (* calculate layout_children *)
           (* assign a level & layout children to each node *)
           (* level (root) = 0; *)
           (* level (node) = max {level (node') | 
                                  node in noncyclic_children (node')} + 1 *)
           (* or we could assign layout_parent to each node (except roots) *)
           (* then layout_children (node) =
                     {node' | layout_parent (node') = node} *)

           (* so, assume G is non-cyclic
              (can eliminate back arcs to get G, if necessary) *)
           (* assign level and layout_parent such that: *)
           (* level (node) = 1 + level (layout_parent node) *)
           (* if G (parent,child) then level parent < level child *)

            val seen = ref []

            fun scan id =
              let
                val (NODE {hidden,hide_children,children,...}) = get_node id
                val children = if not show_all andalso !hide_children
                               then [] else children
              in
                hidden := false;
                List.app
                (fn child_id =>
                 let
                   val child = get_node child_id
                   val NODE {parent_count,...} = child
                 in
                   ++parent_count
                 end)
                children;
                List.app
                (fn child_id =>
                 if Lists.member (child_id,!seen)
                   then ()
                 else
                   (seen := child_id :: !seen;
                    scan child_id))
                children
              end

            fun set_level ([],n) = ()
              | set_level (nodeset,n) =
                let
                  val nextnodes = ref []
                  fun do_node (node as NODE {layout_children,...})=
                    List.app
                    (fn child_id =>
                     let
                       val child_node as NODE {level,parent_count,...} =
                         get_node child_id
                     in
                       --parent_count;
                       if !parent_count = 0
                         then
                           (level := n;
                            layout_children := child_id :: !layout_children;
                            nextnodes := child_node :: !nextnodes)
                       else ()
                     end)
                    (get_shown_children node)
                in
                  List.app do_node nodeset;
                  set_level (!nextnodes,n+1)
                end

          in
            scan 0;
            set_level ( map get_node roots, 1)
          end (* of fun set_levels *)

        fun set_layout_children (NODE {children,layout_children,...}) =
          let
            fun unique_children children =
              let
                val result = ref []
              in
                List.app
                (fn id => if Lists.member (id,!result)
                          then ()
                          else result := id :: !result)
                children;
                rev (!result)
              end
          in
            layout_children := 
              List.filter 
                (fn id => Lists.member (id,!layout_children))
                (unique_children children)
          end

        fun get_layout_children (NODE {layout_children,...}) =
          map (fn id => MLWorks.Internal.Array.sub (nodes,id))
              (!layout_children)

        val root = MLWorks.Internal.ExtendedArray.sub
                     (nodes, (case roots of (h::t) => h | _ => 0))

      in
        set_levels nodes;

        (* Now put the layout children into "canonical" form *)
        MLWorks.Internal.ExtendedArray.iterate set_layout_children nodes;

        (nodes, root, get_layout_children)
      end (* of fun set_layout *)
    

    (***Layout utilities***)
    (* Note: where in doubt, assume left/right, up/down and x/y are
             for a HORIZONTAL graph (i.e. children go right of their
             parents).  The function transform_pair converts to the
             correct context.  *)

    (* This function lays out items according to their size *)
    (* This is called when the user application uses the `initialise' function
       supplied by `make'. *)
    fun layout_items (gp          (* Graphics port *),
                      nodes       (* From the user's make_graph *),
                      roots       (* From the user's make_graph *),
                      node_extent (* Given by the user *),
                      gspec       (* layout style *) ) =
      let

        datatype 'a Layout = LAYOUT of 'a             (* root *) *
                                       int            (* height in pxls *) *
                                       'a Layout list (* subtrees *)

        val {child_position = ref_child_position,
             child_expansion = ref_child_expansion,
             default_visibility = ref_default_visibility,
             show_root_children = ref_show_root_children,
             indicateHiddenChildren = ref_indicateHiddenChildren,
             orientation = ref_orientation,
             line_style = ref_line_style,
             horizontal_delta = ref_horizontal_delta,
             vertical_delta = ref_vertical_delta,
             graph_origin = ref_graph_origin,
             show_all = ref_show_all} = gspec
          
        val (left_margin,top_margin) = !ref_graph_origin

        val orientation = !ref_orientation
        val horizontal_delta = !ref_horizontal_delta
        val vertical_delta = !ref_vertical_delta

        val child_position = !ref_child_position
        val child_expansion = !ref_child_expansion
        val hide_root_children = not(!ref_show_root_children)
            
        fun transform_pair (HORIZONTAL,point) = point
          | transform_pair (VERTICAL,(x,y)) = (y,x)

	val (horizontal_delta,vertical_delta) =
            transform_pair (orientation,(horizontal_delta,vertical_delta))

        fun transform_extent (HORIZONTAL,extent) = extent
          | transform_extent (VERTICAL,EXTENT{left,right,up,down}) =
               EXTENT{left=up,right=down,up=left,down=right}

        fun transform_block (HORIZONTAL,extent) = extent
          | transform_block (VERTICAL,(left,right,up,down)) =
              (up,down,left,right)

        val (left_margin,right_margin,top_margin,bottom_margin) =
            transform_block(orientation,
                            (left_margin, right_margin,
                             top_margin, bottom_margin)
                            )

        (* reinitialize various slots *)
        val _ = 
          (MLWorks.Internal.ExtendedArray.iterate reset_node nodes;
           MLWorks.Internal.ExtendedArray.iterate 
           (fn (NODE {node,extent,...}) => 
            extent := node_extent (node,gp))
           nodes)

        val _ =
          let
            val NODE {hide_children,...} = MLWorks.Internal.Array.sub (nodes,0)
          in
            hide_children := (hide_root_children andalso !hide_children)
                             (* expose root's children?
			        - and once exposed, keep them exposed ...
                              *)
          end

        val (nodes,root,get_layout_children) =
          set_layout (nodes,roots,!ref_show_all)
          
        fun get_node_extent (NODE {extent, ...}) = 
          transform_extent (orientation,!extent)
          
        fun root_coords (x:int,y:int,left,right,up,down,th) =
          case child_position  of
            CENTRE =>
              (x+left,
               y + up + ((th - up - down) div 2))
          | NEXT => (x+left,y+up)
          | BELOW => (x+left,y+up)
             
        (* lays out children assuming root has position 0,0 *)
        fun layout (root as NODE {child_offset,...}) =
          let
            val children = get_layout_children root
            val EXTENT{left,right,up,down} = get_node_extent root
          in
            case children of
              [] => LAYOUT (root,up+down,[])
                   (* this is the return value of layout for a trivial tree *)
            | _ =>
                let
                  val subtrees = map layout children
                  fun get_children_height ([],acc) = acc
                    | get_children_height 
                        ([LAYOUT (node, totalh, subtrees)], acc) = 
                      totalh + acc
                    | get_children_height
                        (LAYOUT (node,totalh,subtrees)::rest,acc) = 
                      get_children_height (rest,totalh + vertical_delta + acc)
                  val root_height = up + down
                  val total_height = 
                    let 
                      val is_next = 
                        case child_position of
                          NEXT => true
                        | CENTRE => true
                        | BELOW => false
                    in
                      if is_next
                        then
                          let
                            val children_height = 
                              get_children_height (subtrees,0)
                          in
                            if root_height > children_height
                            then
                              (child_offset := 
                                 (root_height - children_height) div 2;
                               root_height)
                            else
                              children_height
                          end
                      else
                        root_height + vertical_delta + 
                        get_children_height (subtrees,0)
                    end
                in
                  LAYOUT (root,total_height,subtrees)
                end
          end (* of fun layout *)
        
        fun real_layout (x,y,LAYOUT (root,th,subtrees)) =
          (* x is the width so far of the tree *)
          (* y is the _top_ of the vertical space allocated *)
          let
            val NODE {x=x_ref,y=y_ref,child_offset,...} = root
            val EXTENT{left,right,up,down} = get_node_extent root

            fun dosubtrees ([],y) = ()
              | dosubtrees ((tree as LAYOUT (node,th,_))::rest,y) =
                let
                  val new_x = 
                    case child_position of 
                      NEXT => x+left+right+horizontal_delta
                    | CENTRE => x+left+right+horizontal_delta
                    | BELOW => x + horizontal_delta
                in
                  real_layout (new_x,y,tree);
                  dosubtrees (rest,y+th+vertical_delta)
                end

            val (root_x,root_y) = 
              transform_pair (orientation,root_coords
                               (x, y, left, right, up, down, th))

          in
            x_ref := root_x;
            y_ref := root_y;
            dosubtrees (subtrees,
                        case child_position of 
                          NEXT => y + !child_offset
                        | CENTRE => y + !child_offset
                        | BELOW => up + down + vertical_delta + y)
          end
        
        fun dimensions (layout as LAYOUT (node,th,subtrees)) =
          let
            val height = top_margin + th + bottom_margin
            fun get_width (LAYOUT (node,th,[])) = 
              let 
                val EXTENT{left,right,up,down} = get_node_extent node
              in
                left+right
              end
              | get_width (LAYOUT (node,th,subtrees)) =
                let
                  fun do_subtrees ([],max_width) = max_width
                    | do_subtrees (subtree::rest,max_width) =
                      let
                        val width = horizontal_delta + get_width subtree
                      in
                        do_subtrees (rest, if width > max_width 
                                           then width else max_width)
                      end
                  val width = do_subtrees (subtrees,0)
                  val EXTENT{left,right,up,down} = get_node_extent node
                in
                  case child_position of
                    NEXT => left+ right + width
                  | CENTRE => left+ right + width
                  | BELOW => width
                end
            val width = left_margin + get_width layout + right_margin
          in
            transform_pair ( orientation, (width, height) )
          end
        
        val layout = layout root
        val (x_width,y_height) = dimensions layout
      in
        real_layout (left_margin,top_margin,layout);
        (nodes,x_width+12,y_height+12)
         (* Completely arbitrary extra margin just in case graph overspills
            or previous calculations are wrong.  *)
      end (* of fun layout_items *)




    (* `make' builds an instance of the graph widget *)
    (* See the signature for an explanation of parameters and return values *)
    fun make (name, title, parent_title, widget, graph_spec,
              make_graph, draw_item, item_extent) =
      let
        val GRAPH_SPEC gspec = graph_spec
        val selected_node = ref NONE

        fun get_line_end
             (NODE {x,y,extent = ref (EXTENT{left,right,up,down}),...}) =
          case !(#orientation gspec) of
            HORIZONTAL => mk_pt(!x-left-1, !y + down - ((up+down) div 2))
          | VERTICAL =>   mk_pt(!x,        !y-up)

        fun get_line_start
            (NODE {x,y,extent=ref (EXTENT{left,right,up,down}),...},
             child_no,child_count) =
          let
            val is_next =
              case !(#child_position gspec) of
                NEXT => true
              | CENTRE => true
              | BELOW => false
          in
            if is_next
              then
                (case !(#orientation gspec) of
                   HORIZONTAL => mk_pt(!x,!y)
                 | VERTICAL =>
                     let
                       val x' = !x - left
                       val y' = !y+down
                     in
                       mk_pt(x'+ ((child_no + 1) *
                                  (left+right)) div
                             (child_count + 1), y')
                     end)
            else
                 mk_pt(!x-left+3, !y)
          end

        fun get_region
             (NODE {x,y,extent = ref (EXTENT{left,right,up,down}),...}) =
          let
            val width = left + right
            val height = up + down
          in 
	    case !(#orientation gspec) of
	      HORIZONTAL =>
                mk_reg(!x-left-1, !y + down - ((up+down) div 2), width, height)
	    | VERTICAL =>
                mk_reg(!x, !y-up, width, height)
          end

        fun draw_line (gp,p as Capi.POINT{x,y},p' as Capi.POINT{x=x',y=y'}) =
          case !(#line_style gspec) of
            STRAIGHT => 
              Capi.GraphicsPorts.draw_line (gp,p,p')
          | STEP => 
              (case !(#orientation gspec) of
                 HORIZONTAL =>
                   (Capi.GraphicsPorts.draw_line (gp,p,mk_pt(x,y'));
                    Capi.GraphicsPorts.draw_line (gp,mk_pt(x,y'),p'))
               | VERTICAL =>
                   (Capi.GraphicsPorts.draw_line (gp,p,mk_pt(x',y));
                    Capi.GraphicsPorts.draw_line (gp,mk_pt(x',y),mk_pt(x',y')))
              )
        
        fun drawDottedLine (gp, p, p') =
          (Capi.GraphicsPorts.setAttributes
            (gp,[Capi.GraphicsPorts.LINE_STYLE
                   Capi.GraphicsPorts.LINEONOFFDASH]);
           draw_line (gp, p, p');
           Capi.GraphicsPorts.setAttributes
            (gp,[Capi.GraphicsPorts.LINE_STYLE Capi.GraphicsPorts.LINESOLID])
          )

        fun child_invisibility() = not(!(#default_visibility gspec))

        (*  The extent of the drawing area *)
        val layout_info = ref NONE
        fun get_extent () = 
          case !layout_info of
            SOME (layout,width,height) =>
              (width,height)
          | _ => (100, 100) (* Arbitrary value, but this bit
                               of code is never actually used *)

        val (nodelist,roots) = make_graph ()
        val nodes_ref = ref (make_nodes (child_invisibility(),nodelist))
        val roots_ref = ref roots

        (* We access the dc for text extents, so require the wrapper *)
        fun do_layout gp =
          Capi.GraphicsPorts.with_graphics gp
          (fn _ =>
             layout_info := 
              SOME (layout_items (gp,!nodes_ref,!roots_ref,item_extent,gspec)))
          ()

        (* This function draws short dotted lines descending
           from a node to indicate that it has hidden children *)
        fun indicateHiddenChildren
              (gp, node as NODE {x, y,
                                 extent=ref(EXTENT{left, right, up, down}),
                                 children,  ...}) =
           let
             val numKids = List.length children
             val childNum = ref 0
             val (xBasic, yBasic) = 
                  if (!(#child_position gspec))<>BELOW
                  then
                     case !(#orientation gspec) of
                       HORIZONTAL =>
                         (!x+right+(!(#horizontal_delta gspec)),
                          !y - up - (!(#vertical_delta gspec)) div 2)
                     | VERTICAL =>
                        (!x -left-(!(#horizontal_delta gspec)) div 2,
                         !y + (!(#vertical_delta gspec)) div 2)
                  else (!x-left+3, !y)
             val (xRange, yRange) =
               case !(#orientation gspec) of
                 HORIZONTAL =>
                  (0,
                   (!(#vertical_delta gspec) + up + down) )
               | VERTICAL =>
                  ((left+right+(!(#horizontal_delta gspec))) ,
                   0)
           in
             while(!childNum < numKids) do 
              let
                val p = get_line_start (node, !childNum, numKids)
                val p' = mk_pt (xBasic + (((!childNum)+1)*xRange) div (numKids+1),
                                yBasic + (((!childNum)+1)*yRange) div (numKids+1))
              in
                drawDottedLine (gp, p, p');
                ++childNum
              end
           end

        (* This draws the graph *)
        fun draw_graph gp =
          case !layout_info of
            SOME (layout,width,height) =>
              let
                (* Draw the lines to a node's children *)
                fun do_node1 
                    (node as NODE {x, y,
                                   extent=ref(EXTENT{left, right, up, down}),
                                   hidden,hide_children,children,level,...}) =
                  if !hidden orelse 
                     (not (!(#show_all gspec)) andalso !hide_children)
                  then 
                     if not (!hidden) andalso
                        (!(#indicateHiddenChildren gspec)) andalso
                        (List.length children > 0)
                     then indicateHiddenChildren (gp, node)
                     else ()
                  else
                    let
                      val numKids = List.length children
                      val kidNum = ref 0
                    in
                      (* The lines are sorted left-right before 
                         plotting to prevent unsightly crossovers *)
                      (* For better results, sort by gradient (trickier
                         as the relative co-ordinate needs to be known --
                         rather than the absolute). *)
                      List.app
                        (fn p' => (* Draw the lines *)
                           let
                             val p = get_line_start (node, !kidNum, numKids)
                             val _ = ++ kidNum
                           in draw_line (gp, p, p') end )
                        (Lists.msort (* Sort left to right *)
                          (fn (Capi.POINT{x,y},Capi.POINT{x=x',y=y'}) =>
                            case !(#orientation gspec) of
                              VERTICAL => x<x'
                            | HORIZONTAL => y<y')
                          (List.mapPartial (* find points to draw to *)
                            (fn id => 
                               let
                                 val kid as NODE {level=level',...} =
                                   MLWorks.Internal.Array.sub (layout, id)
                                 val p' = get_line_end kid
                               in
                                 if (!level < !level') then (SOME p') else NONE
                               end)
                            children))
                    end

                (* Draw the node *)
                fun do_node2 (NODE {node,x,y,hidden,children,selected,...}) =
                  if !hidden then ()
                  else draw_item (node,!selected,gp,mk_pt(!x,!y))


              in
                MLWorks.Internal.ExtendedArray.iterate do_node1 layout;
                MLWorks.Internal.ExtendedArray.iterate do_node2 layout
              end
          | _ => ()

        (* This draws a bit of the graph (by clipping)
           it is called by Capi *)
        fun draw (gp,region) =
          (Capi.GraphicsPorts.set_clip_region (gp,region);
           draw_graph gp;
           Capi.GraphicsPorts.clear_clip_region gp)

        fun get_nodes () =
          case !layout_info of
            SOME (layout,_,_) => layout
          | _ => raise Div

        (* Set up the graphics port, supplying `draw' as the redraw function *)
        val (scroll,gp,set_scrollbars,set_position) = 
          Capi.GraphicsPorts.make_graphics
	  (name, title, draw, get_extent, (true, true), widget)

        fun centerOnNode (nodeId : int) : unit =
            let
              val _ = do_layout gp
              val NODE{x, y, ...} =
                MLWorks.Internal.Array.sub(!nodes_ref, nodeId)
              val (xSize, ySize) = Capi.widget_size scroll
              val (newX, newY) =
                    (!x - (xSize div 2), !y - (ySize div 2))
            in
              set_position (mk_pt(newX, newY));
              set_scrollbars()
            end (* of fun centerOnNode *)

        (* This is replaced when the calling routine initialises the graph *)
        val select_fn_hook = ref(fn (_) => ())

        (* This function is returned to the caller, it creates the graph
           and sets up the selection function *)
        fun initialize (select_fn) =
          (select_fn_hook := select_fn;
           Capi.GraphicsPorts.initialize_gp gp;
           centerOnNode ((fn (h::t) => h | _ => 0)(!roots_ref)))

        (* This returns boolean saying if children _need_ to be expanded *)
        fun test_expand_children ([],_) = false
          | test_expand_children (children,hide_children) =
	    if !(#show_all gspec) then false else
	    ( case !(#child_expansion gspec) of
		ALWAYS =>
		   if !hide_children
		   then ( hide_children := false;
			  true
			)
		   else false
	      | TOGGLE =>
		   let val hide = !hide_children
		   in
		     hide_children := not hide;
		     true
		   end
	      | SOMETIMES(hfun) =>
		   let val hide = !hide_children
		       val new_hide = hfun(hide)
		   in
		     hide_children := new_hide;
		     (hide <> new_hide)
		   end
	    )

        (* This is called when the user clicks on a node,
           it can pass a message to the calling function using the
           selection function *)
        fun do_select
              (thisnode as 
               NODE {node,hide_children,children,x,y,selected,...}) =
	    ( (!select_fn_hook) (node,get_region(thisnode));
                   (* `select_fn' may use point info to move gp etc.
		      Hence do `select_fn' first to ensure all updates are done
		      consistently. *)
	      let
                val draw_item' = Capi.GraphicsPorts.with_graphics gp draw_item 
		val old_x = !x
		val old_y = !y
		val Capi.POINT{x=ix,y=iy} = Capi.GraphicsPorts.get_offset gp
	      in
		if !selected then
		  if test_expand_children(children,hide_children) then
		    (do_layout gp;
		     Capi.GraphicsPorts.set_offset
                          (gp,mk_pt(ix + !x - old_x, iy + !y - old_y));
		     set_scrollbars ()
                    )
                  else
		    ()
		else
		  ( case !selected_node of
		      NONE => ()
		    | SOME (NODE {node,x,y,selected,...}) =>
		        ( selected := false; 
                          draw_item' (node,false,gp,mk_pt(!x,!y)) );
		    selected := true;
		    selected_node := SOME thisnode;
		    draw_item' (node,true,gp,mk_pt(!x,!y))
		  )
		  (* only bother doing this if the graph is
                     actually going to change *)
	      end
            )
        
        fun do_press (x,y) =
          let
            val nodes = get_nodes ()
            fun find 0 = ()
              | find n =
                let
                  val (node as NODE {hidden, 
                                     x = ref x',
                                     y = ref y',
                                     extent = ref
                                       (EXTENT{left,right,up,down}),...} ) =
                    MLWorks.Internal.Array.sub (nodes,n-1)
                in
                  if not (!hidden) andalso x >= x'-left andalso
                     x < x' + right andalso y >= y'-up andalso y < y' + down
                  then do_select node 
                  else find (n-1)
                end
          in
            find (MLWorks.Internal.Array.length nodes)
          end

        fun is_vertical _ = !(#orientation gspec) = VERTICAL
        fun set_vertical b = 
	  (#orientation gspec := (if b then VERTICAL else HORIZONTAL);
	   true)

        fun is_horizontal _ = !(#orientation gspec) = HORIZONTAL
        fun set_horizontal b =
	  (#orientation gspec := (if not b then VERTICAL else HORIZONTAL);
	   true)

        fun is_straight _ = !(#line_style gspec) = STRAIGHT
        fun set_straight b = 
	  (#line_style gspec := (if b then STRAIGHT else STEP);
	   true)

        fun is_step _ = !(#line_style gspec) = STEP
        fun set_step b = 
	  (#line_style gspec := (if not b then STRAIGHT else STEP);
	   true)

        fun is_next _ = !(#child_position gspec) = NEXT
        fun set_next b = 
	  ((if b then #child_position gspec := NEXT else ());
	   true)

        fun is_centre _ = !(#child_position gspec) = CENTRE
        fun set_centre b =
	  ((if b then #child_position gspec := CENTRE else ());
	   true)

        fun is_below _ = !(#child_position gspec) = BELOW
        fun set_below b = 
	  ((if b then #child_position gspec := BELOW else ());
	   true)

        fun is_show_all _ = !(#show_all gspec)

        fun update () = 
          if Capi.GraphicsPorts.is_initialized gp
            then
              let
                val _ = Capi.set_busy scroll
                val (nodelist, roots) = make_graph ()
              in
                nodes_ref := (make_nodes (child_invisibility (),nodelist));
                roots_ref := roots;
                selected_node := NONE;
                centerOnNode ((fn h::t => h | _ => 0)(!roots_ref));
                Capi.unset_busy scroll
              end
          else ()

        fun redraw_graph () = 
          if Capi.GraphicsPorts.is_initialized gp
            then
              (Capi.set_busy scroll;
               do_layout gp;
               set_scrollbars ();
               Capi.unset_busy scroll)
          else ()

        val (popup_menu,_) =
          Menus.create_dialog
          (widget,
           parent_title ^ ": Graph Layout",
           "graphLayoutMenu",
	   fn _ => redraw_graph (),
           [Menus.OPTLABEL "orientation",
            Menus.OPTRADIO [Menus.OPTTOGGLE
                              ("horizontal",is_horizontal,set_horizontal),
                            Menus.OPTTOGGLE
                              ("vertical",is_vertical,set_vertical)],
            Menus.OPTSEPARATOR,
            Menus.OPTLABEL "lineStyle",
            Menus.OPTRADIO [Menus.OPTTOGGLE ("step",is_step,set_step),
                            Menus.OPTTOGGLE
                              ("straight",is_straight,set_straight)],
            Menus.OPTSEPARATOR,
            Menus.OPTLABEL "childPosition",
            Menus.OPTRADIO [Menus.OPTTOGGLE ("below",is_below,set_below),
                            Menus.OPTTOGGLE ("centre",is_centre,set_centre),
                            Menus.OPTTOGGLE ("next",is_next,set_next)],
            Menus.OPTSEPARATOR,
            Menus.OPTTOGGLE ("indicate_hidden",
                             fn _ => !(#indicateHiddenChildren gspec),
                             fn b =>((#indicateHiddenChildren gspec) := b;
                                     true)),
            Menus.OPTSEPARATOR,
            Menus.OPTINT ("horizontalSpacing",
                          fn _ => !(#horizontal_delta gspec),
                          fn n =>
			  n > 0 andalso ((#horizontal_delta gspec) := n;
					 true)),
            Menus.OPTINT ("verticalSpacing",
                          fn _ => !(#vertical_delta gspec),
                          fn n => 
			  n > 0 andalso ((#vertical_delta gspec) := n;
					 true))
          ])

        (* Button action function hooks *)
        val left_button_action = ref (fn (pa,_) => pa ())
        val middle_button_action = ref (fn _ => ())
        val right_button_action = ref (fn _ => (* popup_menu *)())

        fun set_button_actions {left,middle,right} = 
	    ( left_button_action   := left;
	      middle_button_action := middle;
	      right_button_action  := right
	    )

        val input_x = ref 0
        val input_y = ref 0

        fun press_action () = do_press(!input_x,!input_y) 

        fun input_action (button,Capi.POINT {x,y}) =
          let
            val pt = mk_pt(x,y)
          in
            input_x := x;
            input_y := y;
            case button of
              Capi.Event.LEFT =>
                (!left_button_action)(press_action,pt)
            | Capi.Event.RIGHT =>
                (!right_button_action)(press_action,pt)
            | _ => 
                (!middle_button_action)(press_action,pt)
          end

	fun initialiseSearch getDefault (matchWhole, matchPart) = 
	  let
	    val nodeIndex = ref 0

	    fun startSearch () = 
                (* Hide all children *)
                MLWorks.Internal.ExtendedArray.iterate
                     (fn (NODE{hide_children,...}) => hide_children := true)
                     (!nodes_ref)

            (* The function which actually does the search *)
            fun search searchString miniSearchFn =
              let
                (* Traverse all below a node *)
                fun traverse n =
                  let
                     val (this as
                       NODE{node, children, hide_children, ...}) = 
                          MLWorks.Internal.Array.sub(!nodes_ref, n)
                     val iMatch = miniSearchFn searchString node
                  in
		    if iMatch then 
		      (do_select this;
		       centerOnNode n)
		    else ();
		    hide_children := false;
                    iMatch
                  end (* of fun traverse *)

		fun find_one n = 
		  if n = MLWorks.Internal.Array.length (!nodes_ref) then false
		  else
		    (nodeIndex := n+1;
		    if traverse n then true else find_one (n+1))

              in
		find_one (!nodeIndex) 
              end (* of fun search *)

	    fun doSearch {searchStr, wholeWord, matchCase, searchDown} = 
	      let val miniSearchFn = if wholeWord then matchWhole else matchPart
	      in
		if (search searchStr miniSearchFn) then 
		  redraw_graph()
		else
		  (nodeIndex := 0;
		   startSearch();
		   redraw_graph();
		   Capi.beep widget)
	      end

	     val find_dialog = 
		Capi.find_dialog (widget, doSearch, 
				  {findStr = "",
				   caseOpt = NONE,
				   wordOpt = SOME false,
				   downOpt = NONE})
	  in 
	    startSearch();
	    fn () => (ignore(find_dialog()); ())
							    
	  end  (* of initialiseSearch *)

      in
        Capi.GraphicsPorts.add_input_handler (gp,input_action);

        {widget=scroll,
         initialize=initialize,
         update=update,
         popup_menu=popup_menu,
         set_position=set_position,
         set_button_actions=set_button_actions,
         initialiseSearch=initialiseSearch
        }

      end (* of fun make *)


  datatype Position  = NONE | TOP  | CENTER | BOTTOM | LEFT | RIGHT | ORIGIN

  fun printpos(NONE) = "none"
    | printpos(TOP) = "top"
    | printpos(CENTER) = "centre"
    | printpos(BOTTOM) = "bottom"
    | printpos(LEFT) = "left"
    | printpos(RIGHT) = "right"
    | printpos(ORIGIN) = "origin"

 val toolbar_width = 15

  fun reposition_graph_selection (graph_window,set_position) =
    let
      val v_position = ref(NONE)
      val h_position = ref(NONE)

      val v_offset = ref(0)
      val h_offset = ref(0)

      fun is_none_vp ()      = (!v_position = NONE)
      fun is_top_vp ()       = (!v_position = TOP)
      fun is_center_vp ()    = (!v_position = CENTER)
      fun is_bottom_vp ()    = (!v_position = BOTTOM)

      fun set_none_vp (b)    = ((if b then v_position := NONE else ());
				true)
      fun set_top_vp (b)     = ((if b then v_position := TOP else ());
				true)
      fun set_center_vp (b)  = ((if b then v_position := CENTER else ());
				true)
      fun set_bottom_vp (b)  = ((if b then v_position := BOTTOM else ());
				true)

      fun is_none_hp ()      = (!h_position = NONE)
      fun is_left_hp ()      = (!h_position = LEFT)
      fun is_center_hp ()    = (!h_position = CENTER)
      fun is_right_hp ()     = (!h_position = RIGHT)
      fun is_origin_hp ()    = (!h_position = ORIGIN)

      fun set_none_hp (b)    = ((if b then h_position := NONE else ());
				true)
      fun set_left_hp (b)    = ((if b then h_position := LEFT else ());
				true)
      fun set_center_hp (b)  = ((if b then h_position := CENTER else ());
				true)
      fun set_right_hp (b)   = ((if b then h_position := RIGHT else ());
				true)
      fun set_origin_hp (b)  = ((if b then h_position := ORIGIN else ());
				true)

      val seln_posn_spec = 
        [Menus.OPTLABEL "verticalSelection",
         Menus.OPTSEPARATOR,
         Menus.OPTRADIO
         [Menus.OPTTOGGLE ("vnone"      ,  is_none_vp,    set_none_vp),
          Menus.OPTTOGGLE ("top"        ,  is_top_vp,     set_top_vp),
          Menus.OPTTOGGLE ("vcentre"     ,  is_center_vp,  set_center_vp),
          Menus.OPTTOGGLE ("bottom"     ,  is_bottom_vp,  set_bottom_vp)],
         Menus.OPTINT ("labelOffset",
                       fn _ => !v_offset,
                       fn n =>  n > 0 andalso (v_offset := n; true)),
         Menus.OPTSEPARATOR,
         Menus.OPTLABEL "horizontalSelection",
         Menus.OPTSEPARATOR,
         Menus.OPTRADIO
         [Menus.OPTTOGGLE ("hnone"     ,  is_none_hp,    set_none_hp),
          Menus.OPTTOGGLE ("horigin"   ,  is_origin_hp,  set_origin_hp),
          Menus.OPTTOGGLE ("left"     ,  is_left_hp,    set_left_hp),
          Menus.OPTTOGGLE ("hcentre"   ,  is_center_hp,  set_center_hp),
          Menus.OPTTOGGLE ("right"    ,  is_right_hp,   set_right_hp)],
          Menus.OPTINT ("labelOffset",
                       fn _ => !h_offset,
                       fn n => n > 0 andalso (h_offset := n; true))]

      (* Repositioning functions *)

      val lower_h = 10
      val lower_v = 10

      fun hnorm(n) = max (lower_h,n)
      fun vnorm(n) = max (lower_v,n)

      fun compute_h_posn (x,r_width,w_wid) =
	  case (!h_position) of
	    LEFT     =>
               let val left = !h_offset + lower_h
	       in
		   max(0, x - left)
	       end
	  | CENTER   =>
               let val left   = hnorm ((w_wid - r_width) div 2)
                   val new_x  = x - left
	       in
		   if new_x < 0
                   then max(0, x - (w_wid div 4))
                   else new_x
	       end
	  | RIGHT    =>
               let val left = hnorm (w_wid - (r_width + !h_offset))
                   val new_x  = x - left
	       in
		   max(0, new_x)
	       end
	  | ORIGIN  =>  0
	  | _ =>  ~1

      fun compute_v_posn (y,r_height,w_hgt) =
          let 
          in
	      case (!v_position) of
		TOP      =>
                  let val top = !v_offset + lower_v
                      val new_y = y - top
                  in
                      max(0, new_y)
                  end
	      | CENTER   =>
                  let val top = vnorm ((w_hgt - r_height) div 2)
                      val new_y = y - top
                  in
		      if new_y < 0
		      then max(0, y - (w_hgt div 4))
		      else new_y
                  end
	      | BOTTOM   => 
                  let val top = vnorm (w_hgt - (r_height + !v_offset))
                      val new_y = y - top
                  in
                      max(0, new_y)
                  end
	      | _ =>  ~1
          end

      fun reposition (region as
                      Capi.REGION{x,y,width=r_width,height=r_height}) =
	  let val (w_wid,w_hgt) = Capi.widget_size(graph_window)

              val w_wid  = w_wid  - toolbar_width
	      val w_hgt  = w_hgt  - toolbar_width

	      val new_x  = compute_h_posn(x,r_width,w_wid)
	      val new_y  = compute_v_posn(y,r_height,w_hgt)
	  in
	     set_position (mk_pt(new_x,new_y))

          end

      val last_region = ref(Capi.REGION{x=0,y=0,width=0,height=0})

      fun reposition_fn (region) = ( reposition(region); last_region := region)

      fun update_region () = reposition (!last_region)

      fun popup_fn (shell) =
          #1 (Menus.create_dialog
	      (shell, "Selection Position",
               "graphSelnPosnMenu",
               update_region, seln_posn_spec)
              )
    in
	{ reposition_fn=reposition_fn,
          redisplay_fn=update_region,
	  popup_fn = popup_fn,
	  h_position = h_position,
          v_position = v_position,
          h_offset = h_offset,
          v_offset = v_offset
	}
    end
  end

@


1.37.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.37  1999/03/23  18:05:40  johnh
 * [Bug #190539]
 * Fix problem centerOnNode.
 *
@


1.36
log
@[Bug #190500]
Remove redundant require statements
@
text
@d4 4
d836 1
a836 1
                    (!x - (xSize div 2), !y - (xSize div 2))
d1116 1
a1116 2
		  (redraw_graph();
		   nodeIndex := 0;
d1118 1
@


1.35
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
a133 1
require "^.basis.__int";
@


1.34
log
@[Bug #30241]
Implementing proper Find Dialog.
@
text
@d4 4
d1123 1
a1123 1
	    fn () => (find_dialog(); ())
@


1.34.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.34  1997/09/05  10:44:38  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.34.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.34  1997/09/05  10:44:38  johnh
 * [Bug #30241]
 * Implementing proper Find Dialog.
 *
@


1.33
log
@[Bug #30202]
Add functionality to generic graphs in order to improve compilation manager dependency graphs.
Also added search facility (this relates to bugs #30202 and #30224).
@
text
@d4 5
d1060 9
a1068 10
          (* Function returned to the user to let then set up a search
             facility.  This takes a (unit -> string) function to get the
             default, and (string * (string -> 'node  -> bool)) list for
             searching (search name and match function); and
             returns a popup (to be added to a menu). *)
          fun initialiseSearch _ [] =
                (fn () => ()) (* must have a search function! *)
            | initialiseSearch
                getDefault (searches as (search1::otherSearches)) =
            let
d1070 24
a1093 2
              val searchRef = ref search1
              val searchString = ref (getDefault ())
d1095 3
a1097 18
              (* If there is >1 search type, use this dialog to pick one *)
              val searchStyleSelect =
                let
                  fun build [] = []
                    | build ((search, name)::t) =
                        (Menus.OPTTOGGLE (name,
                                          fn _ => #2(!searchRef) = name ,
                                          fn true =>
                                              (searchRef := (search, name);
                                               true)
                                           | false => true  )) ::
                        (build t)
                in
                  case otherSearches of
                    [] => []
                  |  _ => [Menus.OPTRADIO (build searches),
                           Menus.OPTSEPARATOR]
                end
d1099 11
a1109 20
              (* A version of List.exists which searches the whole
                 list (so imperative effects take place) *)
              fun strictExists c =
                List.foldl (fn (i,b) => (c i) orelse b) false 

              (* This asks the user if they want to continue and
                 raises an exception if they don't.  It might be
                 nice to have a third `find all' option. *)
              exception userStops
              val ask = Capi.makeYesNo (widget, "Search for more matches?")
              fun askUser () =
                    if ask()
                    then ()
                    else raise userStops

              (* The function which actually does the search *)
              fun search searchString =
                let

                  val condition = #1(!searchRef)
d1111 11
a1121 83
                  (* Mark nodes seen.  Prevents repeated traversals. *)
                  val seenA = MLWorks.Internal.Array.tabulate
                               ((MLWorks.Internal.Array.length (!nodes_ref)),
                                (fn _ => (false, false)))

                  (* Hide all children *)
                  val _ = MLWorks.Internal.ExtendedArray.iterate
                            (fn (NODE{hide_children,...}) =>
                                hide_children := true )
                            (!nodes_ref)

                  fun markPath [] = ()
                    | markPath (h::t) =
                        (h := false; markPath t)

                  (* Traverse all below a node *)
                  fun traverse path root =
                      let
                        val (seen, on)=MLWorks.Internal.Array.sub(seenA, root)
                      in
                        if (not seen)
                        then
                          let
                            val (this as
                                 NODE{node, children, hide_children, ...}) =
                                  MLWorks.Internal.Array.sub(!nodes_ref, root)
                            val iMatch = condition searchString node
                            val _ = if iMatch
                                    then
                                      (do_select this;
                                       markPath path;
                                       centerOnNode root;
                                       askUser () )
                                    else ()
                            val descMatches =
                              strictExists (traverse (hide_children::path))
                                           children
                            val _ = MLWorks.Internal.Array.update
                                      (seenA, root,
                                       (true, iMatch orelse descMatches))
                          in
                            descMatches orelse iMatch
                          end
                        else
                          if on then
                            (* This node has been seen and is on a path
                               so everything that can reach it should also
                               be marked as on a path *)
                            (markPath path; true)
                          else
                            (* Node has been seen and is not on a path,
                               stop searching this path *)
                            false
                      end (* of fun traverse *)

                  val result = (strictExists (traverse []) (!roots_ref) )
                               handle userStops => true
                in
                  result
                end (* of fun search *)

              val searchString = ref (getDefault())

              fun doSearch () =
                if (search (!searchString))
                then redraw_graph()
                else  (redraw_graph ();
                       Capi.beep widget
                       (* Beep to warn the user that nothing was found *) )

              val (popup, _) =
                Menus.create_dialog
                (widget,
                 "Search "^parent_title,
                 "pathSearchMenu",
                 fn _ => (),
                 searchStyleSelect @@
                 [Menus.OPTTEXT
                   ("search_word", getDefault,
                    fn s => (searchString := s; doSearch () ; true) ) ] )
            in
              popup
            end (* of fun initialiseSearch *)
a1123 1

@


1.32
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d120 2
d135 1
d157 2
a158 1
    (* NEXT = put the children next to the parent *)
d160 1
d179 3
a181 1
       show_root_children : bool ref ,  (* expose root's children? *) 
d189 2
a190 1
    datatype Extent = EXTENT of { left : int, right : int, up : int, down : int } 
d194 2
a195 1
               id : int, (* not currently used, but useful for unique identification *)
a198 1
               (* internal use only *)
d212 2
a213 1
           (NODE {level,hidden,layout_children,parent_count,child_offset,...}) =
d241 3
d246 1
d248 1
d251 1
d256 18
a273 15
            (* Need to: *)
            (* reinitialize nodes - set hidden to true etc. *)
            (* eliminate cyclic arcs *)
            (* count the number of visible forward arcs going to each node *)
            (* calculate layout_children *)
            (* assign a level & layout children to each node *)
            (* level (root) = 0; *)
            (* level (node) = max {level (node') | node in noncyclic_children (node')} + 1 *)
            (* or we could assign layout_parent to each node (except roots) *)
            (* then layout_children (node) = {node' | layout_parent (node') = node} *)

            (* so, assume G is non-cyclic (can eliminate back arcs to get G, if necessary) *)
            (* assign level and layout_parent such that: *)
            (* level (node) = 1 + level (layout_parent node) *)
            (* if G (parent,child) then level parent < level child *)
d276 1
d280 2
a281 1
                val children = if not show_all andalso !hide_children then [] else children
d284 1
a284 1
                Lists.iterate
d293 1
a293 1
                Lists.iterate
d308 1
a308 1
                    Lists.iterate
d311 2
a312 1
                       val child_node as NODE {level,parent_count,...} = get_node child_id
d324 1
a324 1
                  Lists.iterate do_node nodeset;
d330 2
a331 2
            set_level ([get_node 0],1)
          end
d339 4
a342 2
                Lists.iterate
                (fn id => if Lists.member (id,!result) then () else result := id :: !result)
d348 3
a350 1
            (Lists.filterp (fn id => Lists.member (id,!layout_children)) (unique_children children))
d354 6
a359 1
          map (fn id => MLWorks.Internal.Array.sub (nodes,id)) (!layout_children)
d362 1
d365 3
a367 4
        (nodes,
         MLWorks.Internal.Array.sub (nodes,0),
         get_layout_children)
      end
d369 7
a375 1
    (* Layout utilities *)
d377 7
a383 5
    fun layout_items (gp,
                      nodes,
                      roots,
                      node_extent,
                      gspec) =
d385 5
a389 1
        datatype 'a Layout = LAYOUT of 'a * int * 'a Layout list
d394 1
d423 2
a424 1
          | transform_block (VERTICAL,(left,right,up,down)) = (up,down,left,right)
d427 3
a429 2
            transform_block ( orientation,
                              (left_margin,right_margin,top_margin,bottom_margin)
d453 2
a454 1
        fun get_node_extent (NODE {extent,...}) = transform_extent (orientation,!extent)
d472 1
d477 2
a478 1
                    | get_children_height ([LAYOUT (node,totalh,subtrees)],acc) = 
d480 2
a481 1
                    | get_children_height (LAYOUT (node,totalh,subtrees)::rest,acc) = 
d495 2
a496 1
                            val children_height = get_children_height (subtrees,0)
d499 4
a502 3
                              then
                                (child_offset := (root_height - children_height) div 2;
                                 root_height)
d507 2
a508 1
                        root_height + vertical_delta + get_children_height (subtrees,0)
d513 1
a513 1
          end
d521 1
d534 1
d536 3
a538 1
              transform_pair (orientation,root_coords (x,y,left,right,up,down,th))
d565 2
a566 1
                        do_subtrees (rest,if width > max_width then width else max_width)
d585 12
a596 4
        (nodes,x_width,y_height)
      end
    
    fun make (name,title,parent_title,widget,graph_spec,make_graph,draw_item,item_extent) =
d601 2
a602 1
        fun get_line_end (NODE {x,y,extent = ref (EXTENT{left,right,up,down}),...}) =
d607 3
a609 2
        (* or could have one analagous to above *)
        fun get_line_start (NODE {x,y,extent=ref (EXTENT{left,right,up,down}),...},child_no,child_count) =
d626 3
a628 1
                       mk_pt(x'+ ((child_no + 1) * (left+right)) div (child_count + 1), y')
d634 2
a635 1
        fun get_region (NODE {x,y,extent = ref (EXTENT{left,right,up,down}),...}) =
d641 4
a644 2
	      HORIZONTAL => mk_reg(!x-left-1, !y + down - ((up+down) div 2), width, height)
	    | VERTICAL =>   mk_reg(!x,        !y-up,                         width, height)
d661 9
d678 3
a680 1
          | _ => (100,100)
d688 3
a690 1
          (fn _ => layout_info := SOME (layout_items (gp,!nodes_ref,!roots_ref,item_extent,gspec)))
d693 41
d738 13
a750 2
                fun do_node1 (node as NODE {hidden,hide_children,children,level,...}) =
                  if !hidden orelse (not (!(#show_all gspec)) andalso !hide_children) then ()
d753 2
a754 2
                      val child_count = Lists.length children
                      val child_no_ref = ref 0
d756 26
a781 15
                      (Lists.iterate
                       (fn id =>
                        let
                          val child as NODE {level=level',...} = 
                            MLWorks.Internal.Array.sub (layout,id)
                          val child_no = !child_no_ref
                          val _ = ++child_no_ref
                          val p = get_line_start (node,child_no,child_count)
                          val p' = get_line_end child
                        in
                          if !level < !level'
                            then draw_line (gp,p,p')
                          else draw_line (gp,p,p')
                        end)
                     children)
d783 2
d788 2
d795 3
d802 1
d808 1
d811 14
a824 1
	  (name,title,draw,get_extent,(true,true),widget)
d826 1
d829 2
d834 1
a834 2
           do_layout gp;
           set_scrollbars ())
d836 1
a836 1
        (* this returns boolean saying if children _need_ to be expanded *)
d862 6
a867 1
        fun do_select (thisnode as NODE {node,hide_children,children,x,y,selected,...}) =
d871 1
a871 2
		      consistently.
                    *)
d891 2
a892 1
		        ( selected := false; draw_item' (node,false,gp,mk_pt(!x,!y)) );
d897 2
a898 1
		  (* only bother doing this if the graph is actually going to change *)
d911 2
a912 1
                                     extent = ref (EXTENT{left,right,up,down}),...}) =
d915 3
a917 2
                  if not (!hidden) andalso x >= x'-left andalso x < x' + right andalso y >= y'-up andalso y < y' + down
                    then do_select node 
d966 1
a966 1
                val (nodelist,roots) = make_graph ()
d971 1
a971 2
                do_layout gp;
                set_scrollbars ();
d992 4
a995 2
            Menus.OPTRADIO [Menus.OPTTOGGLE ("horizontal",is_horizontal,set_horizontal),
                            Menus.OPTTOGGLE ("vertical",is_vertical,set_vertical)],
d999 2
a1000 1
                            Menus.OPTTOGGLE ("straight",is_straight,set_straight)],
d1007 5
a1024 1

d1054 139
d1194 1
d1196 1
d1202 2
a1203 1
         set_button_actions=set_button_actions
d1205 2
a1206 1
      end
d1219 1
a1219 1
  val toolbar_width = 15
d1343 2
a1344 1
      fun reposition (region as Capi.REGION{x,y,width=r_width,height=r_height}) =
@


1.31
log
@Option dialog setter functions now return accept/reject.
@
text
@d4 3
a128 2
    structure Option = MLWorks.Option

d530 1
a530 1
        val selected_node = ref Option.NONE
d588 1
a588 1
        val layout_info = ref Option.NONE
d591 1
a591 1
            Option.SOME (layout,width,height) =>
d601 1
a601 1
          (fn _ => layout_info := Option.SOME (layout_items (gp,!nodes_ref,!roots_ref,item_extent,gspec)))
d606 1
a606 1
            Option.SOME (layout,width,height) =>
d645 1
a645 1
            Option.SOME (layout,_,_) => layout
d709 2
a710 2
		      Option.NONE => ()
		    | Option.SOME (NODE {node,x,y,selected,...}) =>
d713 1
a713 1
		    selected_node := Option.SOME thisnode;
d786 1
a786 1
                selected_node := Option.NONE;
@


1.31.9.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.31.9.1  1997/05/12  10:31:31  hope
 * branched from 1.31
 *
@


1.31.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.31.9.1  1997/05/12  10:31:31  hope
 * branched from 1.31
 *
@


1.31.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.31.9.1  1997/05/12  10:31:31  hope
 * branched from 1.31
 *
@


1.31.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.31.9.1.1.1  1997/07/28  18:17:24  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31.8.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.7.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.7.1.1.1
log
@branched from 1.31.7.1
@
text
@a3 3
 * Revision 1.31.7.1  1996/12/17  17:45:12  hope
 * branched from 1.31
 *
@


1.31.6.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.5.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.4.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.4.1.1.1
log
@branched from 1.31.4.1
@
text
@a3 3
 * Revision 1.31.4.1  1996/11/14  12:46:07  hope
 * branched from 1.31
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a3 3
 * Revision 1.31  1996/08/09  15:25:41  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.30
log
@Attempting to give dialogs more meaningful names
@
text
@d4 3
d740 4
a743 1
        fun set_vertical b = #orientation gspec := (if b then VERTICAL else HORIZONTAL)
d745 3
a747 1
        fun set_horizontal b = #orientation gspec := (if not b then VERTICAL else HORIZONTAL)
d750 4
d755 3
a757 2
        fun set_straight b = #line_style gspec := (if b then STRAIGHT else STEP)
        fun set_step b = #line_style gspec := (if not b then STRAIGHT else STEP)
d760 4
a763 1
        fun set_next b = if b then #child_position gspec := NEXT else ()
d765 4
a768 1
        fun set_centre b = if b then #child_position gspec := CENTRE else ()
d770 3
a772 1
        fun set_below b = if b then #child_position gspec := BELOW else ()
d822 3
a824 1
                          fn n => (#horizontal_delta gspec) := n),
d827 3
a829 1
                          fn n => (#vertical_delta gspec) := n)
d900 8
a907 4
      fun set_none_vp (b)    = if b then v_position := NONE else ()
      fun set_top_vp (b)     = if b then v_position := TOP else ()
      fun set_center_vp (b)  = if b then v_position := CENTER else ()
      fun set_bottom_vp (b)  = if b then v_position := BOTTOM else ()
d915 10
a924 5
      fun set_none_hp (b)    = if b then h_position := NONE else ()
      fun set_left_hp (b)    = if b then h_position := LEFT else ()
      fun set_center_hp (b)  = if b then h_position := CENTER else ()
      fun set_right_hp (b)   = if b then h_position := RIGHT else ()
      fun set_origin_hp (b)  = if b then h_position := ORIGIN else ()
d936 1
a936 1
                       fn n =>  v_offset := n),
d946 1
a946 1
         Menus.OPTINT ("labelOffset",
d948 1
a948 1
                       fn n => h_offset := n)]
@


1.29
log
@Removed unused debugging code (that referenced MLWorks.RawIO).
@
text
@d4 3
d523 1
a523 1
    fun make (name,title,widget,graph_spec,make_graph,draw_item,item_extent) =
d783 1
a783 1
           "Graph Layout",
d811 1
a811 1
        val right_button_action = ref (fn _ => popup_menu())
d996 2
a997 1
	      (shell, "Selection Position","graphSelnPosnMenu",
d1011 1
@


1.28
log
@Updating
@
text
@d4 3
a126 20

    local
       structure IO = MLWorks.RawIO 

       val std_out = IO.std_out
       val output  = IO.output

       structure Value = MLWorks.Internal.Value
       val DEFAULT = Value.DEFAULT
       val print = Value.print
    in
       fun debugP s v =
	   ( output(std_out, s);
	     print(DEFAULT,std_out,v);
	     output(std_out, "\n");
	     v
	   )
    end

    fun debug_output s = MLWorks.IO.output(MLWorks.IO.terminal_out,s ^"\n")
@


1.27
log
@Changed behaviour of click - clicking an unselected item selects it;
clicking a selected item expands or contracts it.
@
text
@d4 4
d785 9
d799 1
a799 1
	   fn _ => update (),
@


1.26
log
@Graph menu changes.
@
text
@d4 3
d704 19
a722 17
		( case !selected_node of
		    Option.NONE => ()
		  | Option.SOME (NODE {node,x,y,selected,...}) =>
		      ( selected := false; draw_item' (node,false,gp,mk_pt(!x,!y)) )
                );
		selected := true;
		selected_node := Option.SOME thisnode;
		draw_item' (node,true,gp,mk_pt(!x,!y));
		(* only bother doing this if the graph is actually going to change *)
		if test_expand_children(children,hide_children)
                then
		  (do_layout gp;
		   Capi.GraphicsPorts.set_offset
                        (gp,mk_pt(ix + !x - old_x, iy + !y - old_y));
		   set_scrollbars ()
                  )
                else ()
@


1.25
log
@Array moving to MLWorks.Array
@
text
@d4 3
a758 1
        fun set_show_all b = #show_all gspec := b
d800 1
a800 5
                          fn n => (#vertical_delta gspec) := n),
            Menus.OPTSEPARATOR,
            GuiUtils.bool_value("show_root_children",(#show_root_children gspec)),
            GuiUtils.bool_value("default_visibility",(#default_visibility gspec)),
            Menus.OPTTOGGLE ("show_all",is_show_all,set_show_all)
@


1.24
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d210 1
a210 1
      ExtendedArray.map_index
d230 1
a230 1
        fun get_node id = Array.sub (nodes,id)
d325 1
a325 1
          map (fn id => Array.sub (nodes,id)) (!layout_children)
d329 1
a329 1
        ExtendedArray.iterate set_layout_children nodes;
d331 1
a331 1
         Array.sub (nodes,0),
d385 2
a386 2
          (ExtendedArray.iterate reset_node nodes;
           ExtendedArray.iterate 
d393 1
a393 1
            val NODE {hide_children,...} = Array.sub (nodes,0)
d619 1
a619 1
                            Array.sub (layout,id)
d635 2
a636 2
                ExtendedArray.iterate do_node1 layout;
                ExtendedArray.iterate do_node2 layout
d728 1
a728 1
                    Array.sub (nodes,n-1)
d735 1
a735 1
            find (Array.length nodes)
@


1.23
log
@Adding start/stop graphics functions
@
text
@d4 3
d127 1
a127 1
    fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")
@


1.22
log
@Changing interface ot allow monitoring of options
@
text
@d4 3
d588 2
d591 3
a593 1
          layout_info := Option.SOME (layout_items (gp,!nodes_ref,!roots_ref,item_extent,gspec))
d684 1
d692 1
a692 1
		      ( selected := false; draw_item (node,false,gp,mk_pt(!x,!y)) )
d696 1
a696 1
		draw_item (node,true,gp,mk_pt(!x,!y));
@


1.21
log
@Changed update behaviour of layout dialog, as it wasn't updating properly
after selecting expand_all_nodes.
@
text
@d4 4
d155 2
a156 2
      {child_position : ChildPosition,
       child_expansion : ChildExpansion,
d158 7
a164 7
       show_root_children : bool,  (* expose root's children? *) 
       orientation : Orientation,
       line_style: LineStyle,
       horizontal_delta : int,
       vertical_delta : int,
       graph_origin : (int * int),  (* origin for root and hence graph *) 
       show_all : bool}
d517 1
a517 25
        local
          val GRAPH_SPEC {child_position,
			  child_expansion,
			  default_visibility,
			  show_root_children,
                          orientation,
                          line_style,
                          horizontal_delta,
                          vertical_delta,
                          graph_origin,
                          show_all} = graph_spec
        in
          val gspec =
            {child_position = ref child_position,
             child_expansion = ref child_expansion,
             default_visibility = default_visibility,
	     show_root_children = ref show_root_children,
             orientation = ref orientation,
             line_style = ref line_style,
             horizontal_delta = ref horizontal_delta,
             vertical_delta = ref vertical_delta,
	     graph_origin = ref graph_origin,
             show_all = ref show_all}
        end

@


1.20
log
@Adding hightlighted flag to draw_item
@
text
@d4 3
d761 16
d782 1
a782 1
           fn _ => (do_layout gp; Capi.GraphicsPorts.redisplay gp; set_scrollbars()),
a838 16
        
        fun update () = 
          if Capi.GraphicsPorts.is_initialized gp
            then
              let
                val _ = Capi.set_busy scroll
                val (nodelist,roots) = make_graph ()
              in
                nodes_ref := (make_nodes (child_invisibility (),nodelist));
                roots_ref := roots;
                selected_node := Option.NONE;
                do_layout gp;
                set_scrollbars ();
                Capi.unset_busy scroll
              end
          else ()
@


1.19
log
@Sorting out some minor problems
@
text
@d4 3
d634 1
a634 5
                  else 
                    if !selected
                      then Capi.GraphicsPorts.with_highlighting
                              (gp,draw_item, (node,gp,mk_pt(!x,!y)))
                    else draw_item (node,gp,mk_pt(!x,!y))
d701 1
a701 1
		      ( selected := false; draw_item (node,gp,mk_pt(!x,!y)) )
d705 1
a705 1
		Capi.GraphicsPorts.with_highlighting (gp,draw_item, (node,gp,mk_pt(!x,!y)));
@


1.18
log
@Renaming some buttons
@
text
@d4 3
d762 1
a762 1
           "Graph Layout Menu",
d792 3
a794 8
        val left_button_action = ref(fn (pa,_) => pa())
        val middle_button_action =
            ref(fn (_) =>
(*
                output (MLWorks.IO.terminal_out,"Other button pressed\n")
*)
                ())
        val right_button_action = ref(fn (_) => popup_menu())
d995 1
a995 1
	      (shell, "Selection Position Settings","graphSelnPosnMenu",
@


1.17
log
@Fiddling with button names
@
text
@d4 3
d763 2
a764 2
            Menus.OPTRADIO [Menus.OPTTOGGLE ("vertical",is_vertical,set_vertical),
                            Menus.OPTTOGGLE ("horizontal",is_horizontal,set_horizontal)],
d767 2
a768 2
            Menus.OPTRADIO [Menus.OPTTOGGLE ("straight",is_straight,set_straight),
                            Menus.OPTTOGGLE ("step",is_step,set_step)],
d771 3
a773 3
            Menus.OPTRADIO [Menus.OPTTOGGLE ("next",is_next,set_next),
                            Menus.OPTTOGGLE ("below",is_below,set_below),
                            Menus.OPTTOGGLE ("centre",is_centre,set_centre)],
d897 1
a897 1
         [Menus.OPTTOGGLE ("none"       ,  is_none_vp,    set_none_vp),
d899 1
a899 1
          Menus.OPTTOGGLE ("centre"     ,  is_center_vp,  set_center_vp),
d908 2
a909 2
         [Menus.OPTTOGGLE ("none"     ,  is_none_hp,    set_none_hp),
          Menus.OPTTOGGLE ("origin"   ,  is_origin_hp,  set_origin_hp),
d911 1
a911 1
          Menus.OPTTOGGLE ("centre"   ,  is_center_hp,  set_center_hp),
@


1.16
log
@Restructuring use of OPTRADIO
@
text
@d4 3
d852 1
a852 1
    | printpos(CENTER) = "center"
d896 1
a896 1
          Menus.OPTTOGGLE ("center"     ,  is_center_vp,  set_center_vp),
d908 1
a908 1
          Menus.OPTTOGGLE ("center"   ,  is_center_hp,  set_center_hp),
@


1.15
log
@Removing debug message
@
text
@d4 3
d803 1
a803 1
        fun input_callback data =
d805 1
a805 2
            val event = Capi.Callback.get_event data
            val event_type = Capi.Event.get_event_type event
d807 9
a815 22
            if event_type = Capi.Event.ButtonPress
              then
                case Capi.Event.get_button_data event of
                  Option.SOME (Capi.POINT{x,y},button) =>
		    let
		      val Capi.POINT{x=xi,y=yi} = Capi.GraphicsPorts.get_offset gp
                      val new_x = x + xi
                      val new_y = y + yi
                      val pt = mk_pt(new_x,new_y)
		    in
		       input_x := new_x;
		       input_y := new_y;
		       case button of
			  Capi.Event.LEFT =>
			      (!left_button_action)(press_action,pt)
			| Capi.Event.RIGHT =>
                            (!right_button_action)(press_action,pt)
			| _ => 
                            (!middle_button_action)(press_action,pt)
                    end
                | _ => ()
            else ()
d817 1
a817 1

d834 1
a834 4
        Capi.Callback.add
            (Capi.GraphicsPorts.gp_widget gp,
             Capi.Callback.Input,input_callback
            );
a858 1

d888 22
a909 28
	  [  Menus.OPTRADIO
	     [
               Menus.OPTLABEL "verticalSelection",
               Menus.OPTSEPARATOR,
	       Menus.OPTTOGGLE ("none"       ,  is_none_vp,    set_none_vp),
	       Menus.OPTTOGGLE ("top"        ,  is_top_vp,     set_top_vp),
	       Menus.OPTTOGGLE ("center"     ,  is_center_vp,  set_center_vp),
	       Menus.OPTTOGGLE ("bottom"     ,  is_bottom_vp,  set_bottom_vp),
	       Menus.OPTINT ("labelOffset",
			     fn _ => !v_offset,
			     fn n =>  v_offset := n),
               Menus.OPTSEPARATOR
             ],
             Menus.OPTRADIO
	     [
               Menus.OPTLABEL "horizontalSelection",
               Menus.OPTSEPARATOR,
	       Menus.OPTTOGGLE ("none"     ,  is_none_hp,    set_none_hp),
	       Menus.OPTTOGGLE ("origin"   ,  is_origin_hp,  set_origin_hp),
	       Menus.OPTTOGGLE ("left"     ,  is_left_hp,    set_left_hp),
	       Menus.OPTTOGGLE ("center"   ,  is_center_hp,  set_center_hp),
	       Menus.OPTTOGGLE ("right"    ,  is_right_hp,   set_right_hp),
	       Menus.OPTINT ("labelOffset",
			     fn _ => !h_offset,
			     fn n => h_offset := n)
	     ]
	  ]

@


1.14
log
@Added Extent datatype and modified GraphWidget.make interface to
include modified item_draw and item_extent functions.
@
text
@d4 4
d783 4
a786 2
                 output (MLWorks.IO.terminal_out,"Other button pressed\n")
               )
@


1.13
log
@Update to button action interface ...
@
text
@d4 3
d53 1
d62 2
d65 2
d103 3
d127 2
a128 2
    datatype GraphSpec = 
      GRAPH_SPEC of 
d131 1
d140 2
d157 1
a157 1
               extent : (int * int * int * int) ref }
d161 7
a167 6
    fun reset_node (NODE {level,hidden,layout_children,parent_count,child_offset,...}) =
      (hidden := true;
       level := 0;
       parent_count := 0;
       layout_children := [];
       child_offset := 0)
d169 3
a171 1
    fun make_nodes nodelist =
d175 1
a175 1
             hide_children = ref true,
d186 2
a187 1
             extent = ref (0,0,0,0)})
d308 1
d326 10
a339 1

a343 6
            
        fun transform_point (HORIZONTAL,point) = point
          | transform_point (VERTICAL,(x,y)) = (y,x)
            
	val (horizontal_delta,vertical_delta) =
            transform_point (orientation,(horizontal_delta,vertical_delta))
d366 1
a366 1
        fun get_node_extent (NODE {extent,...}) = transform_block (orientation,!extent)
d380 1
a380 1
            val (left,right,up,down) = get_node_extent root
d426 1
a426 1
            val (left,right,up,down) = get_node_extent root
d440 1
a440 1
              transform_point (orientation,root_coords (x,y,left,right,up,down,th))
d456 1
a456 1
                val (left,right,up,down) = get_node_extent node
d470 1
a470 1
                  val (left,right,up,down) = get_node_extent node
d477 1
d479 1
a479 3
            transform_point (orientation,
                             (left_margin + get_width layout + right_margin,
                              height ))
d483 1
a483 1
        val (xextent,yextent) = dimensions layout
d486 1
a486 1
        (nodes,xextent,yextent)
d494 1
d506 1
d518 1
a518 1
        fun get_line_end (NODE {x,y,extent = ref (left,right,up,down),...}) =
d520 2
a521 4
            HORIZONTAL => 
              Capi.POINT{x=(!x-left-1), y=(!y + down - ((up+down) div 2))}
          | VERTICAL =>
              Capi.POINT{x=(!x), y=(!y-up)}
d524 1
a524 1
        fun get_line_start (NODE {x,y,extent=ref (left,right,up,down),...},child_no,child_count) =
d535 1
a535 1
                   HORIZONTAL => Capi.POINT{x=(!x),y=(!y)}
d541 1
a541 2
                       Capi.POINT{x=x'+ ((child_no + 1) * (left+right)) div (child_count + 1),
                             y=y'}
d544 1
a544 1
                 Capi.POINT{x=(!x-left+3),y=(!y)}
d547 1
a547 1
        fun get_region (NODE {x,y,extent = ref (left,right,up,down),...}) =
d553 2
a554 6
	      HORIZONTAL => 
		Capi.REGION{x=(!x-left-1), y=(!y + down - ((up+down) div 2)),
                            width=width,height=height
                           }
	    | VERTICAL =>
		Capi.REGION{x=(!x), y=(!y-up),width=width,height=height}
d564 2
a565 2
                   (Capi.GraphicsPorts.draw_line (gp,p,Capi.POINT{x=x,y=y'});
                    Capi.GraphicsPorts.draw_line (gp,Capi.POINT{x=x,y=y'},p'))
d567 6
a572 3
                   (Capi.GraphicsPorts.draw_line (gp,p,Capi.POINT{x=x',y=y});
                    Capi.GraphicsPorts.draw_line (gp,Capi.POINT{x=x',y=y},Capi.POINT{x=x',y=y'})))
                 
d581 1
a581 1
        val nodes_ref = ref (make_nodes nodelist)
d585 1
a585 1
                                       
d617 3
a619 2
                      then Capi.GraphicsPorts.with_highlighting (gp,draw_item, (node,gp,!x,!y))
                    else draw_item (node,gp,!x,!y)
d683 5
a687 5
		case !selected_node of
		  Option.NONE => ()
		| Option.SOME (NODE {node,x,y,selected,...}) =>
		    (selected := false;
		     draw_item (node,gp,!x,!y));
d690 1
a690 1
		Capi.GraphicsPorts.with_highlighting (gp,draw_item, (node,gp,!x,!y));
d696 1
a696 1
                        (gp,Capi.POINT{x=ix + !x - old_x, y=iy + !y - old_y});
d712 1
a712 1
                                     extent = ref (left,right,up,down),...}) =
d769 4
a772 1
            Menus.OPTTOGGLE ("show_all",is_show_all,set_show_all)])
d778 1
a778 1
            ref(fn (_,_) =>
d781 1
a781 1
        val right_button_action = ref(fn (_,_) => popup_menu())
d807 1
a807 1
                      val pt = Capi.POINT{x=new_x, y=new_y}
d827 1
d830 1
a830 1
                nodes_ref := (make_nodes nodelist);
d834 2
a835 1
                set_scrollbars ()
d994 1
a994 1
	     set_position (Capi.POINT{x=new_x,y=new_y})
@


1.12
log
@Minor mods to set margins and adjustments to repositioning code.
@
text
@d753 1
a753 1
        val left_button_action = ref(fn (_) => ())
d755 1
a755 1
            ref(fn (_) =>
d758 1
a758 1
        val right_button_action = ref(fn (_) => popup_menu())
d766 5
d786 2
d790 1
a790 3
			    ( do_press (new_x,new_y);
			      (!left_button_action)(pt)
                            )
d792 1
a792 1
                            (!right_button_action)(pt)
d794 1
a794 1
                            (!middle_button_action)(pt)
d986 1
@


1.11
log
@Modifications to selection/expansion protocol + changes to GraphSpec.
@
text
@d4 3
d97 1
a97 1
    val right_margin = 0
d99 1
a99 1
    val bottom_margin = 0
d298 1
a298 1
        val (x_origin,y_origin) = !ref_graph_origin
d308 8
a315 2
        fun transform (HORIZONTAL,extent) = extent
          | transform (VERTICAL,(left,right,up,down)) = (up,down,left,right)
d317 2
a318 2
        fun transform2 (HORIZONTAL,point) = point
          | transform2 (VERTICAL,(x,y)) = (y,x)
d320 3
a322 2
	val (horizontal_delta,vertical_delta) = transform2 (orientation,(horizontal_delta,vertical_delta))
          
d344 1
a344 1
        fun get_node_extent (NODE {extent,...}) = transform (orientation,!extent)
d349 4
a352 4
              (x+x_origin+left,
               y+y_origin + up + ((th - up - down) div 2))
          | NEXT => (x+left+x_origin,y+up+y_origin)
          | BELOW => (x+left+x_origin,y+up+y_origin)
d418 1
a418 1
              transform2 (orientation,root_coords (x,y,left,right,up,down,th))
d456 3
a458 3
            transform2 (orientation,
                        (left_margin + get_width layout + right_margin,
                         height))
d909 1
a909 1
		   x - left
d934 1
d936 1
a936 1
                      y - top
d940 1
d942 3
a944 1
                      y - top
d948 1
d950 1
a950 1
                      y - top
d965 1
a966 1

@


1.10
log
@Changed the graph widget repositioning interface and add interface to
set the button action functions.
@
text
@d4 4
d102 5
d109 1
a110 1
    datatype Orientation = HORIZONTAL | VERTICAL
d116 2
d122 1
d286 2
d292 1
d295 2
d300 1
d302 2
d325 4
a328 1
            hide_children := false
d339 4
a342 4
              (x+left,
               y + up + ((th - up - down) div 2))
          | NEXT => (x+left,y+up)
          | BELOW => (x+left,y+up)
d462 2
d468 1
d473 2
d479 1
d616 26
a660 1
		hide_children := not (!hide_children);
d662 2
a663 3
		if children = [] orelse !(#show_all gspec)
		  then ()
		else
d665 5
a669 2
		   Capi.GraphicsPorts.set_offset (gp,Capi.POINT{x=ix + !x - old_x, y=iy + !y - old_y});
		   set_scrollbars ())
@


1.9
log
@Modifying make interface so that initialise takes the selection function
and added utilities for repositioning the graph selection.
@
text
@d4 4
d62 20
d453 1
d455 1
d462 1
d487 1
d495 3
a497 1
		Capi.REGION{x=(!x-left-1), y=(!y + down - ((up+down) div 2)),width=width,height=height}
d501 1
d685 15
d709 16
a724 10
                    (case button of
                       Capi.Event.LEFT =>
                         let
                           val Capi.POINT{x=xi,y=yi} = Capi.GraphicsPorts.get_offset gp
                         in
                           do_press (x+xi,y+yi)
                         end
                     | Capi.Event.RIGHT =>
                         popup_menu ()
                     | _ => output (MLWorks.IO.terminal_out,"Other button pressed\n"))
d728 1
a741 2
          
        val _ = Capi.Callback.add (Capi.GraphicsPorts.gp_widget gp,Capi.Callback.Input,input_callback)
d743 4
d751 3
a753 1
         set_position=set_position}
d757 9
a765 1
  datatype SelectPosn = NONE | TOP | CENTER | BOTTOM | ORIGIN
d772 5
a776 1
      val position = ref(NONE)
d778 21
a798 11
      fun is_none ()      = (!position = NONE)
      fun is_top ()       = (!position = TOP)
      fun is_center ()    = (!position = CENTER)
      fun is_bottom ()    = (!position = BOTTOM)
      fun is_origin ()    = (!position = ORIGIN)

      fun set_none (b)   = if b then position := NONE else ()
      fun set_top (b)    = if b then position := TOP else ()
      fun set_center (b) = if b then position := CENTER else ()
      fun set_bottom (b) = if b then position := BOTTOM else ()
      fun set_origin (b) = if b then position := ORIGIN else ()
d803 23
a825 5
	       Menus.OPTTOGGLE ("no policy",  is_none,    set_none),
	       Menus.OPTTOGGLE ("top"      ,  is_top,     set_top),
	       Menus.OPTTOGGLE ("center"   ,  is_center,  set_center),
	       Menus.OPTTOGGLE ("bottom"   ,  is_bottom,  set_bottom),
	       Menus.OPTTOGGLE ("origin"   ,  is_origin,  set_origin)
a828 5
      fun popup_fn (shell,class,update_fn) =            
          #1 (Menus.create_dialog
	      (shell, "Selection Position Settings", class,
               update_fn, seln_posn_spec)
              )
d830 55
a884 1
      fun reposition_fn (Capi.REGION{x,y,width=r_width,height=r_height}) =
d886 6
a891 2
              val w_wid         = w_wid  - toolbar_width
	      val w_hgt         = w_hgt  - toolbar_width
d893 1
a893 34
	     case (!position) of
	       NONE => ()
	     | TOP => 
		 let val left'  = (w_wid - r_width) div 2
		     val left   = if left' < 10 then 10 else left'
		     val new_x  = x - left
		     val new_y  = y - 10
		 in
		    set_position (Capi.POINT{x=new_x,y=new_y})
		 end
	     | CENTER => 
		 let val left' = (w_wid - r_width) div 2
		     val left  = if left' < 10 then 10 else left'
		     val top   = (w_hgt - r_height) div 2
		     val new_x = x - left
		     val new_y = y - top
		 in
		    set_position (Capi.POINT{x=new_x,y=new_y})
		 end
	     | BOTTOM => 
		 let val left' = (w_wid - r_width) div 2
		     val left  = if left' < 10 then 10 else left'
		     val top   = w_hgt - r_height
		     val new_x = x - left
		     val new_y = y - top
		 in
		    set_position (Capi.POINT{x=new_x,y=new_y})
		 end
	     | ORIGIN => 
		 let val new_x = x - 10
		     val new_y = y - 10
		 in
		    set_position (Capi.POINT{x=new_x,y=new_y})
		 end
d896 12
d911 4
a914 1
	  position = position
@


1.8
log
@Adding user-controlled graph positioning.
@
text
@d4 3
d411 1
a411 1
    fun make (name,title,widget,graph_spec,make_graph,select_fn,draw_item,item_extent) =
d547 6
a552 2
        fun initialize () =
          (Capi.GraphicsPorts.initialize_gp gp;
d557 4
a560 4
	    ( select_fn (node,get_region(thisnode));
                   (* select_fn may use point info to move gp etc.
		      Hence do select_fn first to ensure all updates are done
		      first.
d698 87
@


1.7
log
@Capi.make_scrolled_graphics changed to Capi.make_graphics
@
text
@d4 3
d49 2
a50 12

    structure CapiData :
       sig
	  datatype Point = POINT of { x : int, y : int }

	  datatype Region = REGION of { x : int, y :int, width : int, height :int }
       end =
       struct
          open Capi
       end

    open CapiData;
d430 1
a430 1
              POINT{x=(!x-left-1), y=(!y + down - ((up+down) div 2))}
d432 1
a432 1
              POINT{x=(!x), y=(!y-up)}
d445 1
a445 1
                   HORIZONTAL => POINT{x=(!x),y=(!y)}
d451 1
a451 1
                       POINT{x=x'+ ((child_no + 1) * (left+right)) div (child_count + 1),
d455 12
a466 1
                 POINT{x=(!x-left+3),y=(!y)}
d468 1
a468 1
        fun draw_line (gp,p as POINT{x,y},p' as POINT{x=x',y=y'}) =
d475 2
a476 2
                   (Capi.GraphicsPorts.draw_line (gp,p,POINT{x=x,y=y'});
                    Capi.GraphicsPorts.draw_line (gp,POINT{x=x,y=y'},p'))
d478 2
a479 2
                   (Capi.GraphicsPorts.draw_line (gp,p,POINT{x=x',y=y});
                    Capi.GraphicsPorts.draw_line (gp,POINT{x=x',y=y},POINT{x=x',y=y'})))
d541 1
a541 1
        val (scroll,gp,set_scrollbars) = 
d550 28
a577 23
          let
            val old_x = !x
            val old_y = !y
            val POINT{x=ix,y=iy} = Capi.GraphicsPorts.get_offset gp
          in
            select_fn node;
            case !selected_node of
              Option.NONE => ()
            | Option.SOME (NODE {node,x,y,selected,...}) =>
                (selected := false;
                 draw_item (node,gp,!x,!y));
            selected := true;
            selected_node := Option.SOME thisnode;
            Capi.GraphicsPorts.with_highlighting (gp,draw_item, (node,gp,!x,!y));
            hide_children := not (!hide_children);
            (* only bother doing this if the graph is actually going to change *)
            if children = [] orelse !(#show_all gspec)
              then ()
            else
              (do_layout gp;
               Capi.GraphicsPorts.set_offset (gp,POINT{x=ix + !x - old_x, y=iy + !y - old_y});
               set_scrollbars ())
          end
d655 1
a655 1
                  Option.SOME (POINT{x,y},button) =>
d659 1
a659 1
                           val POINT{x=xi,y=yi} = Capi.GraphicsPorts.get_offset gp
d688 2
a689 1
         popup_menu=popup_menu}
@


1.6
log
@Updating by adding Capi Point/Region datatypes
@
text
@d4 3
d538 2
a539 1
          Capi.GraphicsPorts.make_scrolled_graphics (name,title,draw,get_extent,widget)
@


1.5
log
@More stuff
@
text
@d4 3
d43 13
d434 1
a434 1
              (!x-left-1,!y + down - ((up+down) div 2))
d436 1
a436 1
              (!x,!y-up)
d449 1
a449 1
                   HORIZONTAL => (!x,!y)
d455 2
a456 2
                       (x'+ ((child_no + 1) * (left+right)) div (child_count + 1),
                        y')
d459 1
a459 1
                 (!x-left+3,!y)
d461 1
a461 1
        fun draw_line (gp,x,y,x',y') =
d464 1
a464 1
              Capi.GraphicsPorts.draw_line (gp,x,y,x',y')
d468 2
a469 2
                   (Capi.GraphicsPorts.draw_line (gp,x,y,x,y');
                    Capi.GraphicsPorts.draw_line (gp,x,y',x',y'))
d471 2
a472 2
                   (Capi.GraphicsPorts.draw_line (gp,x,y,x',y);
                    Capi.GraphicsPorts.draw_line (gp,x',y,x',y')))
d505 2
a506 2
                          val (x,y) = get_line_start (node,child_no,child_count)
                          val (x',y') = get_line_end child
d509 2
a510 2
                            then draw_line (gp,x,y,x',y')
                          else draw_line (gp,x,y,x',y')
d525 2
a526 2
        fun draw (gp,x,y,width,height) =
          (Capi.GraphicsPorts.set_clip_region (gp,(x,y,width,height));
d545 1
a545 1
            val (ix,iy) = Capi.GraphicsPorts.get_offset gp
d562 1
a562 1
               Capi.GraphicsPorts.set_offset (gp,ix + !x - old_x, iy + !y - old_y);
d642 1
a642 1
                  Option.SOME (x,y,button) =>
d646 1
a646 1
                           val (xi,yi) = Capi.GraphicsPorts.get_offset gp
@


1.4
log
@General improvements
@
text
@d4 3
d71 2
a72 1
       vertical_delta : int}
d118 1
a118 1
    fun set_layout (nodes,roots) =
d124 1
a124 1
              if !hide_children then []
d147 1
a147 1
                val children = if !hide_children then [] else children
d238 2
a239 1
             vertical_delta = ref_vertical_delta} = gspec
d270 1
a270 1
          set_layout (nodes,roots)
d399 6
a404 1
          val GRAPH_SPEC {child_position,orientation,line_style,horizontal_delta,vertical_delta} = graph_spec
d411 2
a412 1
             vertical_delta = ref vertical_delta}
d414 1
d476 1
a476 1
                  if !hidden orelse !hide_children then ()
a524 1
        val selected_node = ref Option.NONE
d540 1
d542 6
a547 7
            case children of
              [] => ()
            | _ => 
                (hide_children := not (!hide_children);
                 do_layout gp;
                 Capi.GraphicsPorts.set_offset (gp,ix + !x - old_x, iy + !y - old_y);
                 set_scrollbars ())
d587 3
d614 3
a616 2
                          fn n => (#vertical_delta gspec) := n)])
            
d648 1
@


1.3
log
@Adding graph menu
@
text
@d4 3
d40 7
a69 8
    val do_debug = false
    fun iterate f [] = ()
      | iterate f (a::b) =
        (f a; iterate f b)
    fun ++ x = x := !x + 1;
    fun -- x = x := !x - 1;
    fun max (x:int,y:int) = if x > y then x else y
    fun min (x:int,y:int) = if x < y then x else y
d72 1
a72 1
               id : int,
d96 17
a112 99
    fun massage_graph (root,get_children,eq) =
      let
        (* return a list of nodes *)
        fun list_nodes root =
          let
            val nodes = ref []
            fun add node =
              let
                fun lookup (node,[]) =
                  (nodes := node :: !nodes;
                   true)
                  | lookup (node,a::b) =
                    if eq (node,a) then false
                    else lookup (node,b)
              in
                lookup (node,!nodes)
              end
            fun scan node =
              (if add node
                 then iterate scan (get_children node)
               else ())
          in
            scan root;
            rev (!nodes)
          end
        
        (* Annotate them *)
        fun transform_nodes nodelist =
          let
            exception Index
            fun index' (node,[],n) = raise Index
              | index' (node,node'::rest,n) =
                if eq(node,node') then n
                else index' (node,rest,n+1)
            fun index node = index' (node,nodelist,0)
          in
            Array.arrayoflist
            (map 
             (fn node =>
              NODE {node = node,
                    hide_children = ref true,
                    hidden = ref true,
                    id = index node,
                    level = ref 0,
                    parent_count = ref 0,
                    children = map index (get_children node),
                    layout_children = ref [],
                    child_offset = ref 0,
                    selected = ref false,
                    x = ref 0,
                    y = ref 0,
                    extent = ref (0,0,0,0)})
             nodelist)
          end
        val nodelist = list_nodes root
        val nodes = transform_nodes nodelist
      in
        nodes
      end
      
    fun massage_tree (root,get_children) =
      (* This version just does trees, ie. the eq function is ignored *)
      let
        val count = ref 0
        val nodes = ref []
        fun make_node (node,children,id) =
          NODE {node = node,
                hide_children = ref true,
                hidden = ref true,
                id = id,
                level = ref 0,
                parent_count = ref 0,
                children = children,
                layout_children = ref [],
                child_offset = ref 0,
                selected = ref false,
                x = ref 0,
                y = ref 0,
                extent = ref (0,0,0,0)}
        fun scan node =
          let
            val id = !count
            val _ = ++count
            val children = map scan (get_children node)
          in
            nodes := make_node (node,children,id) :: !nodes;
            id
          end
        val _ = scan root
        val dummy_node = make_node (root,[],0)
        val nodearray = Array.array (!count,dummy_node)
        val _ = 
          Lists.iterate 
          (fn (node as NODE {id,...}) => 
           Array.update (nodearray,id,node)) 
          (!nodes)
      in
        nodearray
      end
d114 1
a114 6
    fun massage0 (root,get_children,Option.NONE) =
      massage_tree (root,get_children)
      | massage0 (root,get_children,Option.SOME eq) =
        massage_graph (root,get_children,eq)
      
    fun set_layout nodes =
d116 1
a116 1
        val get_node = Array.sub;
d119 1
a119 2
            val root = get_node (nodes,0)
            fun get_children (NODE {children,hide_children,...}) =
d123 15
a137 3
            (* What this function is meant to do is to set the parent count *)
            (* to the number of actual arcs reaching the node from the *)
            (* displayed nodes *)
d139 5
a143 3
            fun set_hidden_nodes id =
              let 
                val (NODE {hidden,hide_children,children,...}) = get_node (nodes,id)
d145 3
a147 13
                hidden:=false;
                if !hide_children then ()
                else
                  Lists.iterate
                  set_hidden_nodes
                  children
              end
              
            fun set_parent_count (node as NODE {hidden,...}) =
              if !hidden then ()
              else
                iterate 
                (fn id =>
d149 2
a150 2
                   val node = get_node (nodes,id)
                   val NODE {parent_count,...} = node
d154 9
a162 27
                (get_children node)

            fun adjust_counts () =
              let
                val seen = ref []
                fun aux (path,id) =
                  if Lists.member (id,!seen) then ()
                  else
                    let
                      val _ = seen := id :: !seen
                      val node = get_node (nodes,id)
                      val path' = id :: path
                      fun do_child child =
                        if Lists.member (child,path)
                          then
                            let
                              val NODE {parent_count,...} = get_node (nodes,child)
                            in
                              --parent_count
                            end
                        else
                          aux (path',child)
                    in
                      iterate do_child (get_children node)
                    end
              in
                aux ([],0)
d170 1
a170 1
                    iterate
d173 1
a173 1
                       val child_node as NODE {level,parent_count,...} = get_node (nodes,child_id)
d183 1
a183 1
                    (get_children node)
d185 1
a185 1
                  iterate do_node nodeset;
d190 2
a191 4
            set_hidden_nodes 0;
            ExtendedArray.iterate set_parent_count nodes;
            adjust_counts ();
            set_level ([root],1)
d194 1
a194 10
        fun node_level (NODE {level,...}) = !level
        fun node_id (NODE {id,...}) = id
        fun get_children (NODE {children,...}) =
          map (fn id => Array.sub (nodes,id)) children
        fun filter f [] = []
          | filter f (a::b) =
            if f a then a::filter f b
            else filter f b
        fun hide_children (NODE {hide_children,...}) = !hide_children
        fun unique_children children =
d196 9
a204 1
            val result = ref []
d206 2
a207 4
            Lists.iterate
            (fn id => if Lists.member (id,!result) then () else result := id :: !result)
            children;
            rev (!result)
d209 3
a211 3
        fun get_layout_children (NODE {children,layout_children,...}) =
          map (fn id => Array.sub (nodes,id)) 
          (filter (fn id => Lists.member (id,!layout_children)) (unique_children children))
d214 2
d218 1
a218 3
         get_children,
         get_layout_children,
         fn (node1,node2) => node_id node1 = node_id node2)
d225 1
d259 1
a259 1
            val NODE{hide_children,...} = Array.sub (nodes,0)
d264 2
a265 2
        val (nodes,root,get_children,get_layout_children,eq) =
          set_layout nodes
d278 1
a278 1
        fun layout (root as NODE {hidden,child_offset,...}) =
d391 1
a391 1
    fun make (name,title,graph_spec,draw_item,item_extent,make_graph,widget) =
d453 3
a455 1
        val nodes = ref (massage0 (make_graph ()))
d457 1
a457 1
          layout_info := Option.SOME (layout_items (gp,!nodes,item_extent,gspec))
d470 1
a470 1
                      (iterate
d486 1
a486 1
                fun do_node2 (NODE {node,x,y,hidden,children,level,selected,...}) =
d514 1
a514 1
        fun do_select (thisnode as NODE {node,hide_children,x,y,selected,...}) =
d520 1
d529 8
a536 4
            hide_children := not (!hide_children);
            do_layout gp;
            Capi.GraphicsPorts.set_offset (gp,ix + !x - old_x, iy + !y - old_y);
            set_scrollbars ()
d628 8
a635 3
              (nodes := massage0 (make_graph ());
               do_layout gp;
               set_scrollbars ())
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d21 1
d27 1
d29 1
a36 1
    fun P s = () (* output (MLWorks.IO.terminal_out,s ^ "\n") *)
d44 1
a44 2
    datatype ChildPosition = NEXT | BELOW
    datatype ParentPosition = TOP | CENTRE
a54 1
       parent_position : ParentPosition,
d80 1
d142 1
d169 1
d331 1
a331 1
                      graph_spec) =
a332 3
        val _ = P "in layout_items"
        val GRAPH_SPEC{child_position,parent_position,orientation,line_style,horizontal_delta,vertical_delta} = graph_spec

d334 5
d340 5
d374 1
a374 1
          case parent_position  of
d378 2
a379 3
          | TOP =>
              (x+left,
               y+up)
d399 22
a420 13
                    case child_position of 
                      NEXT => 
                        let
                          val children_height = get_children_height (subtrees,0)
                        in
                          if root_height > children_height
                            then
                              (child_offset := (root_height - children_height) div 2;
                               root_height)
                          else
                            children_height
                        end
                    | BELOW => root_height + vertical_delta + get_children_height (subtrees,0)
d438 1
d452 1
d479 1
d497 10
a506 1
        val GRAPH_SPEC {child_position,parent_position,orientation,line_style,horizontal_delta,vertical_delta} = graph_spec
d508 1
a508 1
          case orientation of
d515 22
a536 15
          case child_position of
            NEXT => 
              (case orientation of
                 HORIZONTAL => (!x,!y)
               | VERTICAL =>
                   let
                     val x' = !x - left
                     val y' = !y+down
                   in
                     (x'+ ((child_no + 1) * (left+right)) div (child_count + 1),
                      y')
                   end)
          | BELOW => (!x-left+3,!y)
          
          
d538 1
a538 1
          case line_style of
d542 1
a542 1
              (case orientation of
d559 1
a559 3
          (P "do_layout1";
           layout_info := Option.SOME (layout_items (gp,!nodes,item_extent,graph_spec));
           P "do_layout2")
a564 1
                val _ = P "in draw graph"
d588 1
a588 1
                fun do_node2 (NODE {node,x,y,hidden,children,level,...}) =
d590 4
a593 1
                  else draw_item (node,gp,!x,!y)
d600 1
a600 2
          (P "in draw graph";
           Capi.GraphicsPorts.set_clip_region (gp,(x,y,width,height));
d614 3
a616 2
          
        fun do_select (NODE {hide_children,x,y,...}) =
d622 8
d655 45
a699 1
        
d708 11
a718 8
                  Option.SOME (x,y) =>
                    let
                      val _ = P "foo1"
                      val (xi,yi) = Capi.GraphicsPorts.get_offset gp
                    in
                      do_press (x+xi,y+yi);
                      P "foo2"
                    end
d722 1
a722 1
        fun reset () = 
a725 1
               P "bar1";
d732 4
a735 1
        (scroll,initialize,reset)
@


1.1
log
@new unit
Moved from library
@
text
@d4 4
d18 1
a18 1
require "../library/capi";
@
