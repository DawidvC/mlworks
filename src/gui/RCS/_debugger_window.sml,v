head	1.57;
access;
symbols
	MLW_daveb_inline_1_4_99:1.57.1
	MLWorks_21c0_1999_03_25:1.57
	MLWorks_20c1_1998_08_20:1.57
	MLWorks_20c0_1998_08_04:1.57
	MLWorks_20b2c2_1998_06_19:1.57
	MLWorks_20b2_Windows_1998_06_12:1.57
	MLWorks_20b1c1_1998_05_07:1.57
	MLWorks_20b0_1998_04_07:1.57
	MLWorks_20b0_1998_03_20:1.56
	MLWorks_20m2_1998_02_16:1.54
	MLWorks_20m1_1997_10_23:1.53
	MLWorks_11r1:1.48.1.1.1.2.1
	MLWorks_workspace_97:1.52.2
	MLWorks_dt_wizard:1.52.1
	MLWorks_11c0_1997_09_09:1.48.1.1.1.2
	MLWorks_10r3:1.48.1.1.3
	MLWorks_10r2_551:1.48.1.1.2
	MLWorks_11:1.48.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.48.1.1
	MLWorks_20m0_1997_06_20:1.51
	MLWorks_1_0_r2c2_1997_06_14:1.48.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.48.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.48.1
	MLWorks_BugFix_1997_04_24:1.48
	MLWorks_1_0_r2_Win32_1997_04_11:1.48
	MLWorks_1_0_r2_Unix_1997_04_04:1.48
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.46.2.1.1
	MLWorks_gui_1996_12_18:1.46.3
	MLWorks_1_0_Win32_1996_12_17:1.46.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.45.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.45.1.1
	JFHgui:1.46.1
	MLWorks_1_0_Irix_1996_11_28:1.45.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.45.2
	MLWorks_1_0_Unix_1996_11_14:1.45.1
	MLWorks_Open_Beta2_1996_10_11:1.44.3
	MLWorks_License_dev:1.44.2
	MLWorks_1_open_beta_1996_09_13:1.44.1
	MLWorks_Open_Beta_1996_08_22:1.44
	MLWorks_Beta_1996_07_02:1.40
	MLWorks_Beta_1996_06_07:1.37
	MLWorks_Beta_1996_06_06:1.37
	MLWorks_Beta_1996_06_05:1.37
	MLWorks_Beta_1996_06_03:1.37
	MLWorks_Beta_1996_05_31:1.37
	MLWorks_Beta_1996_05_30:1.37;
locks; strict;
comment	@ * @;


1.57
date	98.03.31.16.02.16;	author johnh;	state Exp;
branches
	1.57.1.1;
next	1.56;

1.56
date	98.02.18.11.42.34;	author johnh;	state Exp;
branches;
next	1.55;

1.55
date	98.02.10.15.34.47;	author jont;	state Exp;
branches;
next	1.54;

1.54
date	98.01.27.15.56.02;	author johnh;	state Exp;
branches;
next	1.53;

1.53
date	97.10.09.11.02.20;	author johnh;	state Exp;
branches;
next	1.52;

1.52
date	97.08.04.13.26.02;	author johnh;	state Exp;
branches
	1.52.1.1
	1.52.2.1;
next	1.51;

1.51
date	97.06.13.10.52.23;	author johnh;	state Exp;
branches;
next	1.50;

1.50
date	97.05.16.15.35.29;	author johnh;	state Exp;
branches;
next	1.49;

1.49
date	97.05.06.09.25.19;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	97.02.26.15.08.24;	author johnh;	state Exp;
branches
	1.48.1.1;
next	1.47;

1.47
date	96.12.19.12.15.47;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	96.12.03.20.55.24;	author daveb;	state Exp;
branches
	1.46.1.1
	1.46.2.1
	1.46.3.1;
next	1.45;

1.45
date	96.10.09.11.53.19;	author io;	state Exp;
branches
	1.45.1.1
	1.45.2.1;
next	1.44;

1.44
date	96.08.09.15.25.15;	author nickb;	state Exp;
branches
	1.44.1.1
	1.44.2.1
	1.44.3.1;
next	1.43;

1.43
date	96.08.07.11.22.52;	author andreww;	state Exp;
branches;
next	1.42;

1.42
date	96.07.29.09.35.03;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	96.07.05.14.23.11;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	96.06.25.09.54.11;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	96.06.19.12.10.16;	author stephenb;	state Exp;
branches;
next	1.38;

1.38
date	96.06.18.12.48.42;	author stephenb;	state Exp;
branches;
next	1.37;

1.37
date	96.05.29.16.00.47;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	96.05.29.16.00.47;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	96.05.23.16.58.42;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	96.05.14.14.28.25;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.05.07.11.37.54;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	96.05.01.10.53.22;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	96.04.23.13.27.30;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.03.15.16.17.56;	author stephenb;	state Exp;
branches;
next	1.29;

1.29
date	96.03.05.14.27.14;	author stephenb;	state Exp;
branches;
next	1.28;

1.28
date	96.02.29.11.18.47;	author stephenb;	state Exp;
branches;
next	1.27;

1.27
date	96.02.26.16.00.16;	author stephenb;	state Exp;
branches;
next	1.26;

1.26
date	96.02.19.17.11.06;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.02.19.10.47.51;	author stephenb;	state Exp;
branches;
next	1.24;

1.24
date	96.02.05.11.48.09;	author daveb;	state Exp;
branches;
next	1.23;

1.23
date	96.01.26.09.36.30;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.01.24.15.39.21;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.01.19.11.00.42;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.01.16.15.04.37;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.11.22.15.58.17;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.11.21.16.44.48;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.11.16.13.14.39;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.14.16.50.09;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.11.06.16.39.18;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.10.26.10.18.27;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.10.24.16.05.17;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.10.24.12.51.41;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	95.10.20.10.51.19;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.10.04.09.09.08;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.10.03.15.18.55;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.09.05.10.27.13;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.08.30.13.23.35;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.25.14.17.56;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.24.16.26.40;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.15.10.31.11;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.12.18.03;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.56.02;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.42.57;	author matthew;	state Exp;
branches;
next	;

1.44.1.1
date	96.09.13.11.13.18;	author hope;	state Exp;
branches;
next	;

1.44.2.1
date	96.10.07.16.03.59;	author hope;	state Exp;
branches;
next	;

1.44.3.1
date	96.10.17.11.22.13;	author hope;	state Exp;
branches;
next	;

1.45.1.1
date	96.11.14.12.46.15;	author hope;	state Exp;
branches
	1.45.1.1.1.1;
next	;

1.45.1.1.1.1
date	96.11.28.14.57.58;	author hope;	state Exp;
branches;
next	;

1.45.2.1
date	96.11.22.18.06.36;	author hope;	state Exp;
branches;
next	;

1.46.1.1
date	96.12.17.09.54.40;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.12.17.17.45.18;	author hope;	state Exp;
branches
	1.46.2.1.1.1;
next	;

1.46.2.1.1.1
date	97.02.24.11.34.46;	author hope;	state Exp;
branches;
next	;

1.46.3.1
date	96.12.18.09.39.17;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	97.05.12.10.31.36;	author hope;	state Exp;
branches
	1.48.1.1.1.1
	1.48.1.1.2.1
	1.48.1.1.3.1;
next	;

1.48.1.1.1.1
date	97.07.28.18.17.30;	author daveb;	state Exp;
branches;
next	1.48.1.1.1.2;

1.48.1.1.1.2
date	97.08.04.17.13.04;	author johnh;	state Exp;
branches
	1.48.1.1.1.2.1.1;
next	;

1.48.1.1.1.2.1.1
date	97.10.07.11.42.22;	author jkbrook;	state Exp;
branches;
next	;

1.48.1.1.2.1
date	97.09.08.17.11.01;	author daveb;	state Exp;
branches;
next	;

1.48.1.1.3.1
date	97.09.09.14.06.37;	author daveb;	state Exp;
branches;
next	1.48.1.1.3.2;

1.48.1.1.3.2
date	97.09.23.10.15.37;	author jkbrook;	state Exp;
branches;
next	;

1.52.1.1
date	97.09.10.19.21.10;	author brucem;	state Exp;
branches;
next	;

1.52.2.1
date	97.09.11.20.52.22;	author daveb;	state Exp;
branches;
next	1.52.2.2;

1.52.2.2
date	97.11.20.17.05.02;	author johnh;	state Exp;
branches;
next	;

1.57.1.1
date	99.04.01.17.55.38;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.57
log
@[Bug #30346]
Call Capi.getNextWindowPos.
@
text
@(*  Copyright (c) 1993 Harlequin Ltd.
 *
 *  $Log: _debugger_window.sml,v $
 * Revision 1.56  1998/02/18  11:42:34  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.55  1998/02/10  15:34:47  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.54  1998/01/27  15:56:02  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.53  1997/10/09  11:02:20  johnh
 * [Bug #30193]
 * Output backtrace to system messages window.
 *
 * Revision 1.52.2.2  1997/11/20  17:05:02  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.52.2.1  1997/09/11  20:52:22  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.52  1997/08/04  13:26:02  johnh
 * [Bug #30111]
 * Silently fail view source when source not available, except for explicit action.
 *
 * Revision 1.51  1997/06/13  10:52:23  johnh
 * [Bug #30175]
 * Combine tools and windows menus .
 *
 * Revision 1.50  1997/05/16  15:35:29  johnh
 * Implementing single menu bar on Windows.
 * Re-organising menus for Motif.
 *
 * Revision 1.49  1997/05/06  09:25:19  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.48  1997/02/26  15:08:24  johnh
 * [Bug #1421]
 * update the variable window when settings are changed.
 *
 * Revision 1.47  1996/12/19  12:15:47  jont
 * [Bug #1825]
 * Remove use of old structure
 *
 * Revision 1.46  1996/12/03  20:55:24  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
 * Revision 1.45  1996/10/09  11:53:19  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.44  1996/08/09  15:25:15  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.43  1996/08/07  11:22:52  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml
 *
 * Revision 1.42  1996/07/29  09:35:03  daveb
 * [Bug #1478]
 * Added Unmap callback.  Corrected definition of editable frames to excluse
 * C frames and Setup frames.  Added quit_fn that reset viewer_fn_ref.
 *
 * Revision 1.41  1996/07/05  14:23:11  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
 * Revision 1.40  1996/06/25  09:54:11  daveb
 * Made button buttons have different names from menu buttons, so that
 * Windows can distinguish between them, and so let us put mnemonics on
 * the menu items but not the buttons.
 *
 * Revision 1.39  1996/06/19  12:10:16  stephenb
 * Fix #1423 - duplicate anonymous frames not hidden correctly.
 *
 * Revision 1.38  1996/06/18  12:48:42  stephenb
 * Add a handler for FilewViewer.ViewFailed to show_fn so that something
 * sensible is done if the file cannot be viewed.  This is part of a fix
 * for #1413.
 *
 * Revision 1.37  1996/05/29  16:00:47  daveb
 * make_debugger_window now returns a pair of functions.  The second of these
 * is to be run at the end of the evaluation, and clears the windows, etc.
 * This reduces flicker (Bug 1065), and stops the debugger from always popping
 * to the top.
 *
 * Revision 1.35  1996/05/23  16:58:42  daveb
 * Changed interface to file viewer.
 * Added button to pop file viewer back up if it has been closed.
 *
 * Revision 1.34  1996/05/14  14:28:25  matthew
 * Fixing layout
 *
 * Revision 1.33  1996/05/07  11:37:54  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.32  1996/05/01  10:53:22  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.31  1996/04/23  13:27:30  daveb
 * Added FileViewer.
 *
 * Revision 1.30  1996/03/15  16:17:56  stephenb
 * Remove some redundant Trace.set_stepping calls now that the
 * Trace module takes care of keeping all this stuff internally
 * consistent.
 *
 * Revision 1.29  1996/03/05  14:27:14  stephenb
 * Fix the frame filtering mechanism so that it doesn't drop
 * the top frame if it is a delivered frame.
 *
 * Revision 1.28  1996/02/29  11:18:47  stephenb
 * Modify the tty->gui interface so that the gui debugger knows
 * which frame to apply Trace.next to.
 * Rewrote the frame filtering so that it correctly hides frames that
 * result from the new step/next/break mechanism.
 * Added a "next" button and "next" menu item to the action menu and
 * hooked them up so that the call Trace.next.
 *
 * Revision 1.27  1996/02/26  16:00:16  stephenb
 * Unify control of hiding and revealing frames in the tty&gui debuggers.
 *
 * Revision 1.26  1996/02/19  17:11:06  daveb
 * Made select_fn for local variables call the inspect_fn with auto = true.
 *
 * Revision 1.25  1996/02/19  10:47:51  stephenb
 * Updated wrt to Trace.step_status -> Trace.stepping name change.
 *
 * Revision 1.24  1996/02/05  11:48:09  daveb
 * Capi.make_scrolllist now returns a record, with an add_items field.
 *
 * Revision 1.23  1996/01/26  09:36:30  daveb
 * Revised layout.
 *
 * Revision 1.22  1996/01/24  15:39:21  matthew
 * Make inspector window sibling of debugger window
 *
 * Revision 1.21  1996/01/19  11:00:42  matthew
 * Changing interface to inspector
 *
 * Revision 1.20  1996/01/16  15:04:37  matthew
 * Changes to what is done with full_menus
 *
 * Revision 1.19  1995/11/22  15:58:17  jont
 * Fix bug 1079
 * Done by as part of abort_action, as well as continue_action and step_action
 *
 * Revision 1.18  1995/11/21  16:44:48  jont
 * Modify to display local variable info on full menus
 *
 * Revision 1.17  1995/11/16  13:14:39  matthew
 * Changing button resources
 *
 * Revision 1.16  1995/11/14  16:50:09  jont
 * Some tidying up and a little documentation added
 * This should make it easier for the next person to look at this stuff
 *
 * Revision 1.15  1995/11/06  16:39:18  jont
 * Remove duplication of function information in debugger frame window
 *
 * Revision 1.14  1995/10/26  10:18:27  nickb
 * Hide some additional frames.
 *
 * Revision 1.13  1995/10/24  16:05:17  daveb
 * Moved call of set_active_buttons to after popup, so that focus is set
 * correctly.
 *
 * Revision 1.11  1995/10/20  10:51:19  daveb
 * Renamed ShellUtils.edit_string to ShellUtils.edit_source
 * (and ShellUtils.edit_source to ShellUtils.edit_location).
 *
 * Revision 1.10  1995/10/04  09:09:08  daveb
 * Changed run_debugger to select the appropriate button for default action.
 *
 * Revision 1.9  1995/10/03  15:18:55  daveb
 * Made debugger show source of current frame in emacs, when possible.
 * This is a stop-gap implementation - we need a source browser for non-emacs
 * users.
 *
 * Revision 1.8  1995/09/05  10:27:13  matthew
 * Fixing some problems with running under Win32
 *
 * Revision 1.7  1995/08/30  13:23:35  matthew
 * Renaming layout constructors
 *
 * Revision 1.6  1995/08/25  14:17:56  matthew
 * Fixing problem with empty frame list
 *
 * Revision 1.5  1995/08/24  16:26:40  matthew
 * Bring window to front when entered.
 *
 * Revision 1.4  1995/08/15  10:31:11  matthew
 * Using Menus.make_buttons for buttons
 *
 * Revision 1.3  1995/08/10  12:18:03  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:56:02  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:42:57  matthew
 * new unit
 * New unit
 *
 *  Revision 1.46  1995/07/07  14:58:28  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.45  1995/07/04  14:31:13  matthew
 *  Capification
 *
 *  Revision 1.44  1995/06/28  13:07:36  daveb
 *  Made edit action disabled for functions defined in the listener.
 *
 *  Revision 1.43  1995/06/15  15:01:21  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *  Removed edit function from parameters of run_debugger, and hardwired it
 *  in this file.
 *
 *  Revision 1.42  1995/06/08  13:44:11  daveb
 *  InspectorTool no longer contains a Widget Type.
 *
 *  Revision 1.41  1995/06/08  09:45:42  daveb
 *  Types of the InspectorTool functions have changed.  Also corrected
 *  spelling of InspectorTool (from Inspector_Tool).
 *
 *  Revision 1.40  1995/06/01  13:28:58  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.39  1995/05/26  15:52:17  matthew
 *  Changing uses of substring
 *
 *  Revision 1.38  1995/05/22  15:20:50  daveb
 *  Made breakpoints menu visible to novices.
 *
 *  Revision 1.37  1995/04/27  11:09:11  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.36  1995/04/24  15:06:26  matthew
 *  Cosmetic debugger changes
 *
 *  Revision 1.35  1995/04/24  11:04:58  daveb
 *  Added call to Xm.ungrabPointer to event-handling subloop.
 *
 *  Revision 1.34  1995/04/19  14:41:36  matthew
 *  Added extra buttons for abort etc.
 *  First version of new stepping functionality
 *
 *  Revision 1.33  1995/04/13  17:10:43  daveb
 *  Xm.doInput is back to taking unit.
 *
 *  Revision 1.32  1995/04/06  15:31:12  daveb
 *  Type of Xm.doInput has changed.
 *
 *  Revision 1.31  1995/01/13  15:38:20  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *
 *  Revision 1.30  1994/07/27  16:12:07  daveb
 *  Cut-down menus for novices.
 *
 *  Revision 1.29  1994/07/12  16:17:02  daveb
 *  Changes to reflect minor changes in inspector_tool.
 *
 *  Revision 1.28  1994/04/06  15:30:13  daveb
 *  Disabled stepper and breakpoint actions when appropriate, and removed
 *  irrelevant entries ffrom inspect submenu.  Moved breakpoint menu into
 *  GUI_UTILS, and into the menu bar.  Simplified stepper interface.
 *
 *  Revision 1.27  1994/03/15  14:11:43  matthew
 *  Changed resource names
 *
 *  Revision 1.26  1994/02/28  08:55:55  nosa
 *  Menus for Step and breakpoints Debugger.
 *
 *  Revision 1.25  1993/12/10  16:52:08  daveb
 *  Added exists_frame_info to disable frames menu entry when no frame info
 *  exists.
 *
 *  Revision 1.24  1993/12/10  10:32:11  daveb
 *  Added copyright notice.
 *
 *  Revision 1.23  1993/09/09  09:34:01  nosa
 *  Restricted strings in inspect frame info menu to 80 characters;
 *  Hiding instance-frames for polymorphic debugger.
 *
 *  Revision 1.22  1993/08/28  17:59:07  daveb
 *  Changed Options menu to Settings menu, to avoid confusion.
 *
 *  Revision 1.21  1993/08/24  16:31:36  matthew
 *  Improved label names etc.
 *
 *  Revision 1.20  1993/08/11  12:02:19  matthew
 *  create_dialog interface change
 *
 *  Revision 1.19  1993/08/09  16:57:34  nosa
 *  Inspector now invoked for values of local and closure variables;
 *  new action "InspectFrameInfo".
 *
 *  Revision 1.18  1993/08/05  11:01:30  nosa
 *  New option ShowFrameInfo in debugger window.
 *
 *  Revision 1.17  1993/08/03  11:13:16  matthew
 *  Combined frame and action menus. Renamed quit to abort
 *
 *  Revision 1.16  1993/07/28  15:54:56  nosa
 *  Reversed logic for frame filters.
 *  More user-friendly labels.
 *
 *  Revision 1.15  1993/05/20  11:43:46  matthew
 *  Fixed bug with item selection
 *
 *  Revision 1.14  1993/05/13  18:22:13  daveb
 *  Renamed file menu to action menu.
 *
 *  Revision 1.13  1993/05/13  15:26:03  daveb
 *  create_dialog now requires a title argument.
 *
 *  Revision 1.12  1993/05/12  14:43:35  matthew
 *  Added message function to debugger window
 *
 *  Revision 1.11  1993/05/10  10:42:52  matthew
 *  Change to termination protocol
 *
 *  Revision 1.10  1993/05/07  17:10:14  matthew
 *  Added Quit and Continue buttons
 *  Enter event handling loop before exitting.
 *
 *  Revision 1.9  1993/05/05  19:30:54  daveb
 *  Gave sensible names to the shell and form widgets.
 *
 *  Revision 1.8  1993/04/30  14:24:22  matthew
 *  Added menubar, frame suppression, editor interface
 *
 *  Revision 1.7  1993/04/28  10:24:16  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.6  1993/04/26  13:50:16  daveb
 *  Now uses GuiUtils.make_scrolllist.
 *
 *  Revision 1.5  1993/04/19  09:46:25  matthew
 *  Used Xm callback conversion function.
 *
 *  Revision 1.4  1993/04/05  14:55:08  daveb
 *  Names of Callbacks have changed.
 *
 *  Revision 1.3  1993/03/30  14:46:56  matthew
 *  Removed MENUSPEC data constructor
 *
 *  Revision 1.2  1993/03/26  18:27:32  matthew
 *  Changed widget names
 *
 *  Revision 1.1  1993/03/25  17:07:11  matthew
 *  Initial revision
 *
 *
 *)

require "capi";
require "menus";
require "../utils/lists";
require "^.utils.__messages";
require "../main/preferences";
require "../debugger/newtrace";
require "../debugger/ml_debugger";
require "../typechecker/types";
require "tooldata";
require "inspector_tool";
require "gui_utils";
require "file_viewer";
require "../interpreter/shell_utils";
require "../debugger/stack_frame";
require "debugger_window";
require "../main/user_options";
require "^.basis.__string";

functor DebuggerWindow(
  structure Capi : CAPI
  structure Lists : LISTS
  structure Trace : TRACE
  structure InspectorTool : INSPECTORTOOL
  structure FileViewer : FILE_VIEWER
  structure UserOptions : USER_OPTIONS
  structure Types : TYPES
  structure Menus : MENUS
  structure GuiUtils: GUI_UTILS
  structure ShellUtils: SHELL_UTILS
  structure ToolData: TOOL_DATA
  structure Preferences: PREFERENCES
  structure StackFrame : STACK_FRAME
  structure Ml_Debugger : ML_DEBUGGER

  sharing UserOptions.Options = ToolData.ShellTypes.Options =
    ShellUtils.Options = Types.Options

  (* The only function from Types used here is printTypes.  Perhaps that
     should be (or is, for all I know) available elsewhere? *)
  sharing type Types.Datatypes.Type = InspectorTool.Type
  sharing type Types.Options.print_options = ShellUtils.Options.print_options
  sharing type Menus.Widget = GuiUtils.Widget = ToolData.Widget = Capi.Widget =
               InspectorTool.Widget = FileViewer.Widget
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ToolData = InspectorTool.ToolData = FileViewer.ToolData
  sharing type ToolData.ShellTypes.user_preferences =
               Preferences.user_preferences
  sharing type ShellUtils.preferences = Preferences.preferences
  sharing type FileViewer.Location.T = ShellUtils.Info.Location.T
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type UserOptions.user_tool_options = ToolData.ShellTypes.user_options
  sharing type GuiUtils.user_context = ToolData.UserContext.user_context
  sharing type UserOptions.user_context_options = ToolData.UserContext.user_context_options
) : DEBUGGERWINDOW =
  struct
    structure Options = ShellUtils.Options
    structure UserContext = ToolData.UserContext

    type Widget = Capi.Widget
    type ToolData = InspectorTool.ToolData
    type Type = InspectorTool.Type

    local
      type part_of_a_frame =
        (string
         * (Type * MLWorks.Internal.Value.ml_value * string)
         ) list

      type frame_details =
        string
        * string
        * (Type * MLWorks.Internal.Value.ml_value * string)
        * (unit -> string * part_of_a_frame,
           string * part_of_a_frame)
          Ml_Debugger.union ref option

      type frame =
        {name : string, loc : string, details: frame_details}
    in
      datatype Frame =
        FRAME of frame

      (* This type must be the same as that in _ml_debugger. *)
      type debugger_window =
        {parameter_details: string,
         frames: frame list,
         quit_fn: (unit -> unit) option,
         continue_fn: (unit -> unit) option,
         top_ml_user_frame: MLWorks.Internal.Value.Frame.frame option}
        -> unit
    end

    fun make_debugger_window (parent,title,tooldata) =
      let
        val ToolData.TOOLDATA
              {args as ToolData.ShellTypes.LISTENER_ARGS
                        {user_preferences as Preferences.USER_PREFERENCES
                                          ({full_menus, ...}, _),
                         user_options,user_context,prompter,mk_xinterface_fn,...},
               appdata as ToolData.APPLICATIONDATA {applicationShell, ...},
               current_context, motif_context, tools, ...} =
          tooldata

        fun get_user_context_options () =
	  UserContext.get_user_options
	    (GuiUtils.get_user_context (motif_context))

        fun get_compiler_options () =
          UserOptions.new_options (user_options, get_user_context_options())

        val title = "Stack Browser"

        (* Some state variables *)

        val show_debug_info = ref true
        val show_variable_debug_info = ref(true)

	val visible = ref false

        val (shell,form,menuBar,_) =
          Capi.make_main_popup 
		{name = "debugger",
		 title = title, 
		 parent = parent,
		 contextLabel = false, 
		 visibleRef = visible,
		 pos = Capi.getNextWindowPos()}

        (* Controls local event handling loop *)
        val continue = ref true

        fun popup () =
          (Capi.reveal form;
           Capi.to_front shell;
	   Capi.add_main_window (shell, title);
	   visible := true)

        fun popdown () =
	  (Capi.hide form;
	   visible := false)

        val buttonPane =
          Capi.make_managed_widget ("buttonPane", Capi.RowColumn, form, [])

        val text = Capi.make_managed_widget
                     ("debuggerText", Capi.Text, form,[])

        val debuggerFrame =
          Capi.make_managed_widget
            ("debuggerFrame", Capi.Paned, form, [Capi.PanedMargin true])

        val varPane =
          Capi.make_managed_widget ("varPane", Capi.Form, debuggerFrame, []);

        val argsLabel =
          Capi.make_managed_widget
            ("debuggerArgsLabel", Capi.Label, varPane, [])

        val argsText =
          Capi.make_managed_widget
            ("debuggerArgsText", Capi.Text, varPane, [])

        val framePane =
          Capi.make_managed_widget ("framePane", Capi.Form, debuggerFrame, []);

        val framesLabel =
          Capi.make_managed_widget
            ("debuggerFramesLabel", Capi.Label, framePane, [])

	val quit_fns = ref [fn () => Capi.remove_main_window shell];

        fun do_quit_fns () = Lists.iterate (fn f => f ()) (!quit_fns)
	
	local
	  val viewer_fn_ref = ref NONE
	in
	  fun viewer_fn auto location =
	    case !viewer_fn_ref
	    of SOME f =>
	      f auto (FileViewer.LOCATION location)
	    |  NONE =>
	      let
		val the_fn = FileViewer.create (parent, true, tooldata)
	      in
		viewer_fn_ref := SOME (the_fn);
		quit_fns :=
		  (fn _ => viewer_fn_ref := NONE) :: !quit_fns;
		the_fn false (FileViewer.LOCATION location)
	      end
	end

        val frames_ref = ref [] : Frame list ref
        val displayed_frames = ref [] : Frame list ref
        val present_name = ref "";

        val logical_top_frame : MLWorks.Internal.Value.Frame.frame option ref =
          ref NONE

        val present_frame_info : (InspectorTool.Type * MLWorks.Internal.Value.ml_value
                                       * string) option ref =
          ref NONE

        val present_variable_frame_info :
          (unit -> string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value
                                       * string)) list),
           string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value
                               * string)) list)) Ml_Debugger.union ref ref =
          ref(ref(Ml_Debugger.INR("",[])))

        (* The inspector can't be a child of the debugger itself *)
        val inspect_fn = InspectorTool.inspect_value (parent,true,tooldata)

        fun fetch_frame_info (info' as ref(Ml_Debugger.INL info_fn)) =
          let val info as (_,info'') = info_fn ()
          in
            info' := Ml_Debugger.INR info;
            info''
          end
        |   fetch_frame_info (ref(Ml_Debugger.INR(_,info))) = info

        fun exists_frame_info () =
          case (!present_frame_info,
                fetch_frame_info (!present_variable_frame_info))
          of (NONE, []) => false
          |  _ => true

	fun print_frames [] = 
	      Capi.send_message (shell, "See System Messages window for backtrace")
	  | print_frames (frame1::rest) = 
	      let 
		val FRAME {details, ...} = frame1
		val (name, _, (_, _, info), _) = details
	      in
		Messages.output(name ^ info ^ "\n");
		print_frames rest
	      end

        val max_length = 80
        fun strip str =
          if size str <= max_length then str
          else substring (* could raise Substring *)(str,0,max_length-3) ^ "..."

        val current_var = ref NONE

        fun exists_current_var () =
          case !current_var
          of NONE => false
          |  _ => true

        fun inspect_current_var () =
          case !current_var
          of NONE => ()
          |  SOME (var,(ty,value,valuestr)) =>
            inspect_fn false (var,(value,ty))

        val {scroll = varsScroll, list = varsList,
             set_items = set_var_items, ...} =
          Capi.make_scrolllist
            {parent = varPane,
             name = "debuggerVars",
             select_fn = fn _ =>
               fn x as (var,(ty,value,valuestr)) =>
                 (current_var := SOME x;
                  inspect_fn true (var,(value,ty))),
             action_fn = fn _ =>
               fn (var,(ty,value,valuestr)) =>
                 inspect_fn false (var,(value,ty)),
             print_fn = fn _ =>
               (* This is what prints the args in the middle window *)
               fn (var,(ty,value,valuestr)) =>
                 "val " ^ var
                 ^ ": " ^ Types.print_type (get_compiler_options()) ty ^
                 " = " ^ strip valuestr}

	fun is_editable ("<Cframe>", _) = false
	|   is_editable ("<Setup>", _) = false
	|   is_editable (_, location) = ShellUtils.editable location

	(* show_fn shows the source for the current frame in the editor,
	   or the file viewer if the editor doesn't support incremental
	   update.  It is used for displaying the current source while
	   stepping. *)
        fun show_fn (auto, name, loc) =
	  let
	    val location = ShellUtils.Info.Location.from_string loc
	  in
	    if is_editable (name, location) then
              (ShellUtils.show_source
                 (loc, Preferences.new_preferences user_preferences))
               handle ShellUtils.EditFailed s =>
	         (viewer_fn auto location
                   handle FileViewer.ViewFailed filename =>
                     if not auto then
		       Capi.send_message (shell, "Cannot view: " ^ filename)
	             else ())
	    else
	      ()
	  end

	(* edit_fn shows source for the current frame in the editor,
	   whether it supports incremental update or not.  It is
	   used for the edit menu command. *)
        fun edit_fn (name, loc) =
	  let
	    val location = ShellUtils.Info.Location.from_string loc
	  in
            if is_editable (name, location) then
              let
		val quit_fn =
		  ShellUtils.edit_source
                    (loc, Preferences.new_preferences user_preferences)
	      in
		quit_fns := quit_fn :: !quit_fns
	      end
              handle ShellUtils.EditFailed s =>
                Capi.send_message (shell, "Edit failed: " ^ s)
	    else
              Capi.send_message (shell, "Can't edit: " ^ loc)
	  end

        (* This prints stuff in the middle window *)
        fun show_vars NONE = ()
        |   show_vars (SOME info') =
          (present_variable_frame_info := info';
           if !show_variable_debug_info then
             case !present_frame_info of
               NONE =>
                 set_var_items
                   Options.default_print_options
                   (fetch_frame_info(!present_variable_frame_info))
             | SOME x =>
                 set_var_items
                   Options.default_print_options
                   (("frame argument", x)
                    :: fetch_frame_info (!present_variable_frame_info))
           else
	     set_var_items Options.default_print_options [])

        fun frame_select_fn _ frame =
          let val FRAME
                    {name, loc, details = (a,b,(ty,value,valuestr),info'),...} =
                frame
          in
            (case valuestr of
               "" => ()
             | "_" => ()
             | _ => present_frame_info := SOME(ty,value,valuestr));
             present_name := name;
             Capi.Text.set_string (argsText, b);
             show_vars info';
	     show_fn (true, name, loc)
          end

        val {scroll=framesScroll, list=framesList,
             set_items=set_frame_items, ...} =
          Capi.make_scrolllist
            {parent = framePane,
             name = "debuggerFrames",
             select_fn = frame_select_fn,
             action_fn = fn _ => fn FRAME{name, loc, ...} =>
	       (show_fn (false, name, loc); 
		Capi.set_focus shell),
             print_fn =
             fn _ =>
             fn FRAME {details = (a,_,(_,_,info),_),...} =>
             a ^ (if !show_debug_info then info else "")
             (* This is what prints the args in the lower window *)}

	fun getter r () = !r
	fun setter r b = (r := b; true)
	fun toggle (s,r) = Menus.OPTTOGGLE(s,getter r, setter r)

        val settings_spec =
	  toggle ("hideAnonymousFrames", StackFrame.hide_anonymous_frames)
          :: toggle ("hideHandlerFrames", StackFrame.hide_handler_frames)
          :: (if !full_menus then
                [toggle ("hideSetupFrames", StackFrame.hide_setup_frames),
		 toggle ("hideCFrames", StackFrame.hide_c_frames),
                 toggle ("hideDeliveredFrames",
			 StackFrame.hide_delivered_frames),
		 toggle ("hideDuplicateFrames",
			 StackFrame.hide_duplicate_frames)]
              else
                nil)



        (* The following is a variant of classify_frames in
         * ../debugger/_ml_debugger.sml.  The differences are due to :-
         *
         * 1. The gui and tty debuggers work on different types of frame
         *    This is something that should definitely be change in
         *    a future version!
         *
         * 2. The tty debugger keeps the user's current position in
         *    the stack.  As a consequence all the frames are classifed
         *    first since it is easier to do this in one go rather
         *    than on the fly as the user moves through the stack.
         *    The gui debugger doesn't need to keep the user's position
         *    since the user is presented with stack and they can point
         *    at any frame they want.  Consequently each time the hide/reveal
         *    status of a frame type is changed, the list of visible
         *    frames is recalculated.
         *
         * 3. As a consequence of 2., it is more difficult to determine
         *    if a frame is a duplicate or not.
         *)

        local
          fun classify "<Cframe>" (cframe, _, _, _, _) = cframe ()
            | classify "<Setup>"  (_, setup, _, _, _) = setup ()
            | classify "<anon>"   (_, _, anon, _, _) = anon ()
            | classify "<handle>" (_, _, _, handler, _) = handler ()
            | classify    _       (_, _, _, _, user) = user ()

          fun user_frame loc = size loc > 0 andalso String.sub (loc, 0) <> #" "

        in
          fun filter ([], acc, _) = acc
            | filter ((f as FRAME{name,loc,...})::rest, acc, previousDelivered) =
                let
                  fun keep_it () = filter (rest, f::acc, false)
                  fun skip_it () = filter (rest, acc, false)
                  fun loop var = if var then skip_it () else keep_it ()
                  fun cframe () =    loop (!StackFrame.hide_c_frames)
                  fun setup () =     loop (!StackFrame.hide_setup_frames)
                  fun anon () =      loop (!StackFrame.hide_anonymous_frames orelse (previousDelivered andalso (!StackFrame.hide_duplicate_frames)))
                  fun handler () =   loop (!StackFrame.hide_handler_frames)
                  fun delivered () = loop (!StackFrame.hide_delivered_frames)
                  fun user () =
                    if user_frame loc then
                      loop (previousDelivered andalso (!StackFrame.hide_duplicate_frames))
                    else
                      if (!StackFrame.hide_delivered_frames)
                      then filter (rest, acc, true)
                      else filter (rest, f::acc, true)
                in
                  classify name (cframe, setup, anon, handler, user)
                end


          fun filter_frames frames = filter (rev frames, [], false)

        end



        val info_settings_spec =
          [toggle ("showDebugInfo",show_debug_info),
           toggle ("showVariableDebugInfo", show_variable_debug_info)]

        fun update_items () =
          let
            val frame_list = filter_frames (!frames_ref)
          in
            displayed_frames := frame_list;
	    show_vars (SOME (!present_variable_frame_info));
            set_frame_items Options.default_print_options frame_list
          end

        fun clear_window () =
          (frames_ref := [];
           update_items ();
           set_var_items
             Options.default_print_options
             [];
           Capi.Text.set_string(text,"");
           Capi.Text.set_string(argsText,""))

        fun item_selected _ =
          MLWorks.Internal.Vector.length (Capi.List.get_selected_pos framesList) = 1

        fun show_callback _ =
          let
            val pos = Capi.List.get_selected_pos framesList
          in
            if MLWorks.Internal.Vector.length pos = 1
              then
                let
                  val index = MLWorks.Internal.Vector.sub (pos,0)
                  val FRAME{name, loc, ...} =
		    Lists.nth (index-1,!displayed_frames)
                in
                  show_fn (false, name, loc)
                end
                handle Lists.Nth => ()
            else ()
          end

        fun edit_callback _ =
          let
            val pos = Capi.List.get_selected_pos framesList
          in
            if MLWorks.Internal.Vector.length pos = 1
              then
                let
                  val index = MLWorks.Internal.Vector.sub (pos,0)
                  val FRAME{name, loc, ...} =
		    Lists.nth (index-1,!displayed_frames)
                in
                  edit_fn (name, loc)
                end
                handle Lists.Nth => ()
            else ()
          end

        fun can_edit _ =
          let
            val pos = Capi.List.get_selected_pos framesList
          in
            if MLWorks.Internal.Vector.length pos = 1
              then
                let
                  val index = MLWorks.Internal.Vector.sub (pos,0)
                  val FRAME{name, loc,...} =
		    Lists.nth (index-1,!displayed_frames)
                  val location = ShellUtils.Info.Location.from_string loc
                in
		  is_editable (name, location)
                end
                handle Lists.Nth =>
                  false
            else
              false
          end

        val settings_popup =
          #1 (Menus.create_dialog (shell,
                                   "Debugger Settings",
                                   "debuggerDialog",
                                   update_items,
                                   settings_spec))
        val info_settings_popup =
          #1(Menus.create_dialog (shell,
                                  "Debugger Settings",
                                  "debuggerDialog",
                                  update_items,
                                  info_settings_spec))

        val quit_fn_ref = ref NONE
        val continue_fn_ref = ref NONE

        fun present (ref NONE) = false
        |   present (ref (SOME _)) = true

        fun abort_present _ = present quit_fn_ref
        fun continue_present _ = present continue_fn_ref
        fun next_present _ = present continue_fn_ref andalso
                             present logical_top_frame

        fun abort_action _ =
	  (do_quit_fns ();
           case !quit_fn_ref of
             NONE => ()
           | SOME f =>
               (continue := false;
                clear_window ();
                popdown();
                f ()))

	(* unmap_action is assigned to the Unmap callback.   It is similar to
	   abort_action, but doesn't hide the window because the window
	   manager will already do that. *)
        fun unmap_action _ =
	  (do_quit_fns ();
	   clear_window ();
	   visible := false;
	   continue := false;
           case !quit_fn_ref of
             NONE => ()
           | SOME f => f ())

        val set_active_buttons = ref (fn () => ())

        fun continue_action _ =
          case !continue_fn_ref of
            NONE => ()
          | SOME f =>
              (continue_fn_ref := NONE;
               continue := false;
	       (*
               (!set_active_buttons) ();
               clear_window ();
	       *)
               f ())

        fun step_action _ =
          case !continue_fn_ref of
            NONE => ()
          | SOME f =>
              (Trace.set_stepping true;
               continue_fn_ref := NONE;
               continue := false;
	       (*
               (!set_active_buttons) ();
               clear_window ();
	       *)
               f ())

        fun next_action _ =
          case !continue_fn_ref of
            NONE => ()
          | SOME f =>
              case !logical_top_frame of
                NONE => ()
              | SOME frame =>
                  (Trace.next frame;
                  continue_fn_ref := NONE;
                  continue := false;
		  (*
                  (!set_active_buttons) ();
                  clear_window ();
		  *)
                  f ())

        val _ =
          let
            val {update, set_focus} =
              Menus.make_buttons
                (buttonPane,
                 [Menus.PUSH ("abortButton", abort_action, abort_present),
                  Menus.PUSH
		    ("continueButton", continue_action, continue_present),
                  Menus.PUSH ("stepButton", step_action, continue_present),
                  Menus.PUSH ("nextButton", next_action, next_present)])

            fun do_set_focus () =
              if continue_present () then
                if Trace.stepping () then
                  set_focus 2
                else
                  set_focus 1
              else
                set_focus 0
          in
            set_active_buttons := (do_set_focus o update)
          end

        fun mk_tooldata () =
          ToolData.TOOLDATA
          {args = ToolData.ShellTypes.LISTENER_ARGS
           {user_options = user_options,
            user_preferences = user_preferences,
            user_context =
            GuiUtils.get_user_context motif_context,
            prompter = prompter,
            mk_xinterface_fn = mk_xinterface_fn},
           current_context = current_context,
           appdata = appdata,
           motif_context = motif_context,
           tools = tools}

	fun get_user_context () = GuiUtils.get_user_context (motif_context)

        val menuspec =
          [ToolData.file_menu [("save", fn _ =>
		       GuiUtils.save_history (false, get_user_context (), applicationShell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), applicationShell),
		       fn _ => not (UserContext.null_history (get_user_context ()))),
	    ("close", abort_action, abort_present)],
	   ToolData.edit_menu
	   (shell, {cut = NONE, paste = NONE, copy = NONE, delete = NONE,
	     edit_possible = fn _ => false, selection_made = fn _ => false,
	     edit_source = [Menus.PUSH ("editSource",edit_callback,can_edit)],
	     delete_all = NONE}),
	   ToolData.tools_menu (mk_tooldata, get_user_context),
	   ToolData.usage_menu 
	       ([("show_defn",show_callback,can_edit),
		("inspect", fn _ => inspect_current_var (), fn _ => exists_current_var ()),
		("filterFrames", fn _ => settings_popup (), fn _ => true),
		("showFrameInfo", fn _ => info_settings_popup (), fn _ => true),
		("backtrace", fn _ => print_frames (!frames_ref), fn _ => true)], []),
	   ToolData.debug_menu [("abort",abort_action,abort_present),
				("continue",continue_action,continue_present),
				("step",step_action,continue_present),
				("next", next_action, next_present)]]

        fun run_debugger {parameter_details, frames, quit_fn, continue_fn, top_ml_user_frame} =
          (frames_ref := map FRAME frames;
           continue := true;
           quit_fn_ref := quit_fn;
           continue_fn_ref := continue_fn;
           logical_top_frame := top_ml_user_frame;
           update_items ();
           case !displayed_frames of
             [] => ()
           | _ =>
              Capi.List.select_pos (framesList, 1, true);
           Capi.Text.set_string(text, parameter_details);
	   if not (!visible) then
             popup()
	   else
	     ();
           (!set_active_buttons) ();
           (* Go into a local event loop while the window is displayed *)
           (* Loop terminated when window is unmapped *)
           Capi.event_loop continue)

	fun clean_debugger () =
	  clear_window ()

        val varPaneLayout =
          (varPane,
           [Capi.Layout.FIXED argsLabel,
            Capi.Layout.FIXED argsText,
            Capi.Layout.FLEX varsScroll]);

        val framePaneLayout =
          (framePane,
           [Capi.Layout.FIXED framesLabel,
            Capi.Layout.FLEX framesScroll]);
      in
        quit_fns := Menus.quit :: (!quit_fns);
	Menus.make_submenus (menuBar, menuspec);
        (* Add a callback to terminate loop when popup is unmapped *)
        Capi.Callback.add
	  (form, Capi.Callback.Unmap, unmap_action);
	Capi.set_close_callback (form, abort_action);
        Capi.Layout.lay_out
          (form, NONE,
           [Capi.Layout.MENUBAR menuBar,
            Capi.Layout.FIXED buttonPane,
            Capi.Layout.FIXED text,
            Capi.Layout.PANED (debuggerFrame, [varPaneLayout, framePaneLayout]),
            Capi.Layout.SPACE]);
        (run_debugger, clean_debugger)
      end
  end;
@


1.57.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.57  1998/03/31  16:02:16  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos.
 *
@


1.56
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d4 4
d495 1
a495 1
		 pos = (100,100)}
@


1.55
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d4 4
d485 7
a491 1
          Capi.make_main_popup ("debugger",title, parent,false, visible)
d1088 1
a1088 1
          (form,
@


1.54
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d364 1
d588 1
a588 1
		MLWorks.IO.output (MLWorks.IO.messages, name ^ info ^ "\n");
@


1.53
log
@[Bug #30193]
Output backtrace to system messages window.
@
text
@d4 11
d1029 1
a1029 2
				("next", next_action, next_present)],
	   GuiUtils.paths_menu shell]
@


1.52
log
@[Bug #30111]
Silently fail view source when source not available, except for explicit action.
@
text
@d4 4
d565 11
d1013 2
a1014 1
		("showFrameInfo", fn _ => info_settings_popup (), fn _ => true)], []),
@


1.52.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.52  1997/08/04  13:26:02  johnh
 * [Bug #30111]
 * Silently fail view source when source not available, except for explicit action.
 *
@


1.52.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a3 3
 * Revision 1.52.2.1  1997/09/11  20:52:22  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d1006 2
a1007 1
				("next", next_action, next_present)]]
@


1.52.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.52  1997/08/04  13:26:02  johnh
 * [Bug #30111]
 * Silently fail view source when source not available, except for explicit action.
 *
@


1.51
log
@[Bug #30175]
Combine tools and windows menus .
@
text
@d4 4
d517 1
a517 2
		val (the_fn, quit_fn) =
		  FileViewer.create (parent, true, tooldata)
d521 1
a521 2
		  (fn _ => viewer_fn_ref := NONE) ::
		  quit_fn :: !quit_fns;
d616 3
a618 1
                     Capi.send_message (shell, "Cannot view: " ^ filename))
d684 2
a685 1
	       show_fn (false, name, loc),
@


1.50
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d4 4
d465 1
d500 1
a500 1
	val quit_fns = ref [];
d998 1
a998 2
	   GuiUtils.paths_menu shell,
	   ToolData.windows_menu ()]
@


1.49
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d376 1
a376 1
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec
a426 1

d431 1
a431 1
                         user_options,user_context,...},
d433 1
a433 2
               motif_context,
               ...} =
a435 1

a439 2


a442 2


d450 2
d453 1
a453 1
          Capi.make_main_popup ("debugger",title, parent,false)
a457 2
	val visible = ref false

d952 16
d969 26
a994 21
          [Menus.CASCADE ("action",
                          [Menus.PUSH ("abort",abort_action,abort_present),
                           Menus.PUSH ("continue",continue_action,continue_present),
                           Menus.PUSH ("step",step_action,continue_present),
                           Menus.PUSH ("next", next_action, next_present),
			   Menus.SEPARATOR,
                           Menus.PUSH ("show_defn",show_callback,can_edit),
                           Menus.PUSH ("edit_frame",edit_callback,can_edit),
                           Menus.PUSH ("inspectFrameInfo",
                                       fn _ => inspect_current_var (),
                                       fn _ => exists_current_var ())],
                          fn _ => true),
           Menus.CASCADE ("settings",
                          [Menus.PUSH ("filterFrames",
                                       fn _ => settings_popup (),
                                       fn _ => true),
                           Menus.PUSH ("showFrameInfo",
                                       fn _ => info_settings_popup (),
                                       fn _ => true)],
                          fn _ => true),
           GuiUtils.breakpoints_menu shell]
d1031 2
a1032 1
        Menus.make_submenus (menuBar, menuspec);
@


1.48
log
@[Bug #1421]
update the variable window when settings are changed.
@
text
@d4 4
d314 1
a314 1
 *  
d317 1
a317 1
 *  
d320 1
a320 1
 *  
d323 1
a323 1
 *  
d326 2
a327 2
 *  
 *  
d335 1
d361 1
a383 1
    structure Option = MLWorks.Option
d390 1
a390 1
      
d403 1
a403 1
          MLWorks.Option.union ref option
d422 1
a422 1
      let 
d461 1
a461 1
        fun popup () = 
d526 1
a526 1
        val logical_top_frame : MLWorks.Internal.Value.Frame.frame Option.option ref =
d529 2
a530 2
        val present_frame_info : (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
                                       * string) Option.option ref =
d533 2
a534 2
        val present_variable_frame_info : 
          (unit -> string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
d536 3
a538 3
           string * ((string * (InspectorTool.Type * MLWorks.Internal.Value.ml_value 
                               * string)) list)) Option.union ref ref = 
          ref(ref(Option.INR("",[])))
d543 1
a543 1
        fun fetch_frame_info (info' as ref(Option.INL info_fn)) = 
d546 1
a546 1
            info' := Option.INR info;
d549 1
a549 1
        |   fetch_frame_info (ref(Option.INR(_,info))) = info
d554 1
a554 1
          of (Option.NONE, []) => false
d558 1
a558 1
        fun strip str = 
d584 1
a584 1
             action_fn = fn _ => 
d640 1
a640 1
        |   show_vars (Option.SOME info') = 
d642 1
a642 1
           if !show_variable_debug_info then 
d648 1
a648 1
             | SOME x => 
d678 4
a681 4
	       show_fn (false, name, loc), 
             print_fn = 
             fn _ => 
             fn FRAME {details = (a,_,(_,_,info),_),...} => 
d706 1
a706 1
         * 
d785 1
a785 1
           
d837 1
a837 1
                handle Lists.Nth => 
d860 1
a860 1
        |   present (ref (Option.SOME _)) = true
d864 1
a864 1
        fun next_present _ = present continue_fn_ref andalso 
d871 1
a871 1
           | SOME f => 
d894 1
a894 1
          | SOME f => 
d903 1
a903 1
        fun step_action _ = 
d906 1
a906 1
          | SOME f => 
d916 1
a916 1
        fun next_action _ = 
d919 1
a919 1
          | SOME f => 
d932 1
a932 1
        val _ = 
d987 1
a987 1
           | _ => 
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1997/02/26  15:08:24  johnh
 * [Bug #1421]
 * update the variable window when settings are changed.
 *
@


1.48.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:36  hope
 * branched from 1.48
 *
@


1.48.1.1.3.2
log
@[Bug #30111]
Merging from trunk:
Debugger pops up dialog when source not available
@
text
@a3 3
 * Revision 1.48.1.1.3.1  1997/09/09  14:06:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d513 2
a514 1
		val the_fn = FileViewer.create (parent, true, tooldata)
d518 2
a519 1
		  (fn _ => viewer_fn_ref := NONE) :: !quit_fns;
d614 1
a614 3
                     if not auto then
		       Capi.send_message (shell, "Cannot view: " ^ filename)
	             else ())
d680 1
a680 3

	       (show_fn (false, name, loc); 
		Capi.set_focus shell),
@


1.48.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:36  hope
 * branched from 1.48
 *
@


1.48.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:36  hope
 * branched from 1.48
 *
@


1.48.1.1.1.2
log
@[Bug #30111]
Merging - silently fail viewing source if error and file viewer is auto update.
@
text
@a3 4
 *
 * Revision 1.48.1.1.1.1  1997/07/28  18:17:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d513 2
a514 1
		val the_fn = FileViewer.create (parent, true, tooldata)
d518 2
a519 1
		  (fn _ => viewer_fn_ref := NONE) :: !quit_fns;
d614 1
a614 3
                     if not auto then
		       Capi.send_message (shell, "Cannot view: " ^ filename)
	             else ())
d680 4
a683 5
	       (show_fn (false, name, loc); 
		Capi.set_focus shell),
             print_fn =
             fn _ =>
             fn FRAME {details = (a,_,(_,_,info),_),...} =>
@


1.48.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.48.1.1.1.2  1997/08/04  17:13:04  johnh
 * [Bug #30111]
 * Merging - silently fail viewing source if error and file viewer is auto update.
 *
@


1.47
log
@[Bug #1825]
Remove use of old structure
@
text
@d4 4
d649 1
a649 1
             ())
d768 1
@


1.46
log
@Replaced the hacky mswindows simulation of unmap callbacks with a call
to Capi.set_close_callback.
@
text
@d4 4
d336 1
a336 1
require "^.basis.__old";
d723 1
a723 1
          fun user_frame loc = size loc > 0 andalso Old.ord loc <> ord #" "
@


1.46.3.1
log
@branched from 1.46
@
text
@a3 4
 * Revision 1.46  1996/12/03  20:55:24  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.46.2.1
log
@branched from 1.46
@
text
@a3 4
 * Revision 1.46  1996/12/03  20:55:24  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.46.2.1.1.1
log
@branched from 1.46.2.1
@
text
@a3 3
 * Revision 1.46.2.1  1996/12/17  17:45:18  hope
 * branched from 1.46
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 4
 * Revision 1.46  1996/12/03  20:55:24  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.45
log
@[Bug #1614]
basifying String
@
text
@d4 4
d1003 1
@


1.45.2.1
log
@branched from 1.45
@
text
@a3 4
 * Revision 1.45  1996/10/09  11:53:19  io
 * [Bug #1614]
 * basifying String
 *
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 4
 * Revision 1.45  1996/10/09  11:53:19  io
 * [Bug #1614]
 * basifying String
 *
@


1.45.1.1.1.1
log
@branched from 1.45.1.1
@
text
@a3 3
 * Revision 1.45.1.1  1996/11/14  12:46:15  hope
 * branched from 1.45
 *
@


1.44
log
@Option dialog setter functions now return accept/reject.
@
text
@d4 3
d328 1
d386 1
a386 1
          MLWorks.Option.union ref MLWorks.Option.option
d398 3
a400 3
         quit_fn: (unit -> unit) MLWorks.Option.option,
         continue_fn: (unit -> unit) MLWorks.Option.option,
         top_ml_user_frame: MLWorks.Internal.Value.Frame.frame MLWorks.Option.option}
d486 1
a486 1
	  val viewer_fn_ref = ref Option.NONE
d490 1
a490 1
	    of Option.SOME f =>
d492 1
a492 1
	    |  Option.NONE =>
d497 1
a497 1
		viewer_fn_ref := Option.SOME (the_fn);
d499 1
a499 1
		  (fn _ => viewer_fn_ref := Option.NONE) ::
d510 1
a510 1
          ref Option.NONE
d514 1
a514 1
          ref Option.NONE
d543 1
a543 1
          else String.substring(str,0,max_length-3) ^ "..."
d545 1
a545 1
        val current_var = ref Option.NONE
d549 1
a549 1
          of Option.NONE => false
d554 2
a555 2
          of Option.NONE => ()
          |  Option.SOME (var,(ty,value,valuestr)) =>
d565 1
a565 1
                 (current_var := Option.SOME x;
d622 1
a622 1
        fun show_vars Option.NONE = ()
d627 1
a627 1
               Option.NONE =>
d631 1
a631 1
             | Option.SOME x => 
d647 1
a647 1
             | _ => present_frame_info := Option.SOME(ty,value,valuestr));
d715 1
a715 1
          fun user_frame loc = size loc > 0 andalso String.ord loc <> String.ord " "
d838 2
a839 2
        val quit_fn_ref = ref Option.NONE
        val continue_fn_ref = ref Option.NONE
d841 1
a841 1
        fun present (ref Option.NONE) = false
d852 2
a853 2
             Option.NONE => ()
           | Option.SOME f => 
d868 2
a869 2
             Option.NONE => ()
           | Option.SOME f => f ())
d875 3
a877 3
            Option.NONE => ()
          | Option.SOME f => 
              (continue_fn_ref := Option.NONE;
d887 2
a888 2
            Option.NONE => ()
          | Option.SOME f => 
d890 1
a890 1
               continue_fn_ref := Option.NONE;
d900 2
a901 2
            Option.NONE => ()
          | Option.SOME f => 
d903 2
a904 2
                Option.NONE => ()
              | Option.SOME frame =>
d906 1
a906 1
                  continue_fn_ref := Option.NONE;
@


1.44.3.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/08/09  15:25:15  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.44.2.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/08/09  15:25:15  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.44.1.1
log
@branched from 1.44
@
text
@a3 3
 * Revision 1.44  1996/08/09  15:25:15  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.43
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml
@
text
@d4 4
d664 3
d669 2
a670 6
          Menus.OPTTOGGLE ("hideAnonymousFrames",
                            fn () => !StackFrame.hide_anonymous_frames,
                            fn b => StackFrame.hide_anonymous_frames := b)
          :: Menus.OPTTOGGLE ("hideHandlerFrames",
                            fn () => !StackFrame.hide_handler_frames,
                            fn b => StackFrame.hide_handler_frames := b)
d672 6
a677 12
                [Menus.OPTTOGGLE ("hideSetupFrames",
                                  fn () => !StackFrame.hide_setup_frames,
                                  fn b => StackFrame.hide_setup_frames := b),
                 Menus.OPTTOGGLE ("hideCFrames",
                                  fn () => !StackFrame.hide_c_frames,
                                  fn b => StackFrame.hide_c_frames := b),
                 Menus.OPTTOGGLE ("hideDeliveredFrames",
                                  fn () => !StackFrame.hide_delivered_frames,
                                  fn b => StackFrame.hide_delivered_frames := b),
                 Menus.OPTTOGGLE ("hideDuplicateFrames",
                                  fn () => !StackFrame.hide_duplicate_frames,
                                  fn b => StackFrame.hide_duplicate_frames := b)]
d744 2
a745 6
          [Menus.OPTTOGGLE ("showDebugInfo",
                            fn () => !show_debug_info,
                            fn b => show_debug_info := b),
           Menus.OPTTOGGLE ("showVariableDebugInfo",
                            fn () => !show_variable_debug_info,
                            fn b => show_variable_debug_info := b)]
@


1.42
log
@[Bug #1478]
Added Unmap callback.  Corrected definition of editable frames to excluse
C frames and Setup frames.  Added quit_fn that reset viewer_fn_ref.
@
text
@d4 5
d320 1
d328 1
d337 3
d352 4
d360 1
d403 1
a403 1
                         ...},
d405 1
d409 12
d566 1
a566 1
                 ^ ": " ^ Types.print_type Options.default_print_options ty ^
@


1.41
log
@[Bug #1260]
Changed the Capi layout datatype so that the PANED constructor takes the
layout info for its sub-panes.  This enables the Windows layout code to
calculate the minimum size of each window.
@
text
@d4 6
d462 3
a464 1
		quit_fns := quit_fn :: !quit_fns;
d541 4
d549 1
a549 1
        fun show_fn (auto, loc) =
d553 1
a553 1
            if ShellUtils.editable location then
d567 1
a567 1
        fun edit_fn loc =
d571 1
a571 1
            if ShellUtils.editable location then
d615 1
a615 1
	     show_fn (true, loc)
d624 2
a625 1
             action_fn = fn _ => fn FRAME{loc,...} => show_fn (false, loc), 
d754 2
a755 1
                  val FRAME{loc,...} = Lists.nth (index-1,!displayed_frames)
d757 1
a757 1
                  show_fn (false, loc)
d771 2
a772 1
                  val FRAME{loc,...} = Lists.nth (index-1,!displayed_frames)
d774 1
a774 1
                  edit_fn loc
d780 1
a780 1
        fun is_editable _ =
d788 2
a789 1
                  val FRAME{loc,...} = Lists.nth (index-1,!displayed_frames)
d792 1
a792 1
                  ShellUtils.editable location
d834 12
d919 2
a920 2
                           Menus.PUSH ("show_defn",show_callback,is_editable),
                           Menus.PUSH ("edit_frame",edit_callback,is_editable),
d972 2
a973 3
        Capi.Callback.add (form,
                           Capi.Callback.Unmap,
                           fn _ => continue := false);
@


1.40
log
@Made button buttons have different names from menu buttons, so that
Windows can distinguish between them, and so let us put mnemonics on
the menu items but not the buttons.
@
text
@d4 5
d930 2
a931 7
      in
        Menus.make_submenus (menuBar, menuspec);
        (* Add a callback to terminate loop when popup is unmapped *)
        Capi.Callback.add (form,
                           Capi.Callback.Unmap,
                           fn _ => continue := false);
        Capi.Layout.lay_out
d936 2
a937 1
        Capi.Layout.lay_out
d941 6
d952 1
a952 1
            Capi.Layout.PANED debuggerFrame,
@


1.39
log
@Fix #1423 - duplicate anonymous frames not hidden correctly.
@
text
@d4 3
d861 5
a865 4
                 [Menus.PUSH ("abort", abort_action, abort_present),
                  Menus.PUSH ("continue", continue_action, continue_present),
                  Menus.PUSH ("step", step_action, continue_present),
                  Menus.PUSH ("next", next_action, next_present)])
@


1.38
log
@Add a handler for FilewViewer.ViewFailed to show_fn so that something
sensible is done if the file cannot be viewed.  This is part of a fix
for #1413.
@
text
@d4 5
d668 2
a669 2
          fun filter_frames ([], acc) = rev acc
            | filter_frames ((f as FRAME{name,loc,...})::rest, acc) =
d671 2
a672 2
                  fun keep_it () = filter_frames (rest, f::acc)
                  fun skip_it () = filter_frames (rest, acc)
d676 1
a676 1
                  fun anon () =      loop (!StackFrame.hide_anonymous_frames)
d681 5
a685 19
                      keep_it ()
                    else 
                      case acc of
                        [] => delivered ()
                      | ((FRAME{name,loc,...})::pfs) =>
                          let
                            fun possible_duplicate () =
                              if !StackFrame.hide_duplicate_frames then
                                if user_frame loc
                                andalso !StackFrame.hide_delivered_frames then
                                  filter_frames (rest, pfs)
                                else
                                  filter_frames (rest, f::pfs)
                              else
                                loop (!StackFrame.hide_delivered_frames)
                          in
                            classify name (keep_it, keep_it, keep_it, keep_it, possible_duplicate)
                          end

d689 4
d707 1
a707 1
            val frame_list = filter_frames (!frames_ref,[])
@


1.37
log
@make_debugger_window now returns a pair of functions.  The second of these
is to be run at the end of the evaluation, and clears the windows, etc.
This reduces flicker (Bug 1065), and stops the debugger from always popping
to the top.
@
text
@d4 6
d532 3
a534 1
	         viewer_fn auto location
@


1.36
log
@make_debugger_window now returns a pair of functions.  The second of these
is to be run at the end of the evaluation, and clears the windows, etc.
This reduces flicker (Bug 1065), and stops the debugger from always popping
to the top.
@
text
@@


1.35
log
@Changed interface to file viewer.
Added button to pop file viewer back up if it has been closed.
@
text
@d4 4
d381 2
d385 2
a386 1
           Capi.to_front shell)
d388 3
a390 1
        fun popdown () = Capi.hide form;
d713 3
d814 2
a816 1
               continue := false;
d818 1
d827 2
a829 1
               continue := false;
d831 1
d843 2
a845 1
                  continue := false;
d847 1
d907 4
a910 1
           popup();
d915 3
d940 1
a940 1
        run_debugger
@


1.34
log
@Fixing layout
@
text
@d4 3
d418 1
a418 1
	  fun viewer_fn x =
d420 2
a421 1
	    of Option.SOME f => f x
d425 1
a425 1
		  FileViewer.view_location (parent, true, tooldata)
d429 1
a429 1
		the_fn x
d710 16
d860 2
@


1.33
log
@Array moving to MLWorks.Array
@
text
@d4 3
d383 3
a389 3
        val text = Capi.make_managed_widget
                     ("debuggerText", Capi.Text, debuggerFrame,[])

d891 1
@


1.32
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d701 1
a701 1
          Vector.length (Capi.List.get_selected_pos framesList) = 1
d707 1
a707 1
            if Vector.length pos = 1
d710 1
a710 1
                  val index = Vector.sub (pos,0)
d723 1
a723 1
            if Vector.length pos = 1
d726 1
a726 1
                  val index = Vector.sub (pos,0)
@


1.31
log
@Added FileViewer.
@
text
@d4 3
d630 1
a630 1
          fun user_frame loc = size loc > 0 andalso ord loc <> ord " "
@


1.30
log
@Remove some redundant Trace.set_stepping calls now that the
Trace module takes care of keeping all this stuff internally
consistent.
@
text
@d4 5
d267 1
d277 1
d291 1
a291 1
               InspectorTool.Widget
d293 1
a293 1
  sharing type ToolData.ToolData = InspectorTool.ToolData
d297 1
d396 20
a415 5
        fun edit_fn s =
          (ShellUtils.edit_source
             (s, Preferences.new_preferences user_preferences); ())
          handle ShellUtils.EditFailed s =>
            Capi.send_message (shell, "Edit failed: " ^ s)
d489 38
d557 1
a557 9
             if ShellUtils.editable
                  (ShellUtils.Info.Location.from_string loc) then
               (ShellUtils.show_source
                  (loc, Preferences.new_preferences user_preferences);
                ())
               handle
                 ShellUtils.EditFailed _ => ()
             else
               ()
d566 1
a566 1
             action_fn = fn _ => fn FRAME{loc,...} => edit_fn loc, 
d754 8
a761 7
          case !quit_fn_ref of
            Option.NONE => ()
          | Option.SOME f => 
              (continue := false;
               clear_window ();
               popdown();
               f ())
@


1.29
log
@Fix the frame filtering mechanism so that it doesn't drop
the top frame if it is a delivered frame.
@
text
@d4 4
d715 1
a715 2
              (Trace.set_stepping false;
               continue_fn_ref := Option.NONE;
@


1.28
log
@Modify the tty->gui interface so that the gui debugger knows
which frame to apply Trace.next to.
Rewrote the frame filtering so that it correctly hides frames that
result from the new step/next/break mechanism.
Added a "next" button and "next" menu item to the action menu and
hooked them up so that the call Trace.next.
@
text
@d4 8
d579 5
a583 4
                  fun cframe () =  loop (!StackFrame.hide_c_frames)
                  fun setup () =   loop (!StackFrame.hide_setup_frames)
                  fun anon () =    loop (!StackFrame.hide_anonymous_frames)
                  fun handler () = loop (!StackFrame.hide_handler_frames)
d589 1
a589 1
                        [] => skip_it ()
@


1.27
log
@Unify control of hiding and revealing frames in the tty&gui debuggers.
@
text
@d4 3
d312 2
a313 1
         continue_fn: (unit -> unit) MLWorks.Option.option}
d385 4
d532 35
a566 4
        fun filter_frames ([],acc) = rev acc
          | filter_frames ((f as FRAME{name,loc,details}) :: rest,acc) =
            case name of
              "<Cframe>" =>
d568 28
a595 9
                  val newacc = if (!StackFrame.hide_c_frames) then acc else f::acc
                  val newrest =
                    if (!StackFrame.hide_duplicate_frames)
                      andalso loc = "start intercept" then 
                      (case rest of
                         (FRAME{name="<Cframe>",...})::_ => rest
                       | _::rest' => rest'
                       | _ => rest)
                    else rest
d597 1
a597 16
                  filter_frames(newrest,newacc)
                end
            | _ =>
                let
                  val hide_it = 
                    case name of
                      "<handle>" => !StackFrame.hide_handler_frames
                    | "<anon>" =>   !StackFrame.hide_anonymous_frames
                    | "<Setup>" =>  !StackFrame.hide_setup_frames
                    | _ => false
                  val delivered = size loc > 0 andalso ord loc = ord " " 
                  val hide_it =
                    (!StackFrame.hide_delivered_frames andalso delivered)
                    orelse hide_it
                in
                  filter_frames (rest, if hide_it then acc else f::acc)
d599 3
d684 2
d712 21
a732 7
           | Option.SOME f => 
               (Trace.set_stepping true;
                continue_fn_ref := Option.NONE;
                (!set_active_buttons) ();
                continue := false;
                clear_window ();
                f ())
d740 3
a742 3
                  Menus.PUSH
                    ("continue", continue_action, continue_present),
                  Menus.PUSH ("step", step_action, continue_present)])
d761 1
d777 1
a777 1
        fun run_debugger {parameter_details, frames, quit_fn, continue_fn} =
d782 1
@


1.26
log
@Made select_fn for local variables call the inspect_fn with auto = true.
@
text
@d4 3
d248 1
d262 1
d273 1
a273 1
	       Preferences.user_preferences
d299 1
a299 1
	{name : string, loc : string, details: frame_details}
d302 1
a302 1
	FRAME of frame
d316 8
a323 8
	val ToolData.TOOLDATA
	      {args as ToolData.ShellTypes.LISTENER_ARGS
			{user_preferences as Preferences.USER_PREFERENCES
					  ({full_menus, ...}, _),
			 ...},
	       appdata as ToolData.APPLICATIONDATA {applicationShell, ...},
	       ...} =
	  tooldata
d333 1
a333 1
	  Capi.make_main_popup ("debugger",title, parent,false)
d345 1
a345 1
	  Capi.make_managed_widget ("buttonPane", Capi.RowColumn, form, [])
d348 2
a349 2
	  Capi.make_managed_widget
	    ("debuggerFrame", Capi.Paned, form, [Capi.PanedMargin true])
d351 2
a352 2
	val text = Capi.make_managed_widget
		     ("debuggerText", Capi.Text, debuggerFrame,[])
d357 7
a363 7
	val argsLabel =
	  Capi.make_managed_widget
	    ("debuggerArgsLabel", Capi.Label, varPane, [])

	val argsText =
	  Capi.make_managed_widget
	    ("debuggerArgsText", Capi.Text, varPane, [])
d368 3
a370 3
	val framesLabel =
	  Capi.make_managed_widget
	    ("debuggerFramesLabel", Capi.Label, framePane, [])
d374 1
a374 1
 	     (s, Preferences.new_preferences user_preferences); ())
d380 1
a380 1
	val present_name = ref "";
d383 1
a383 1
	  ref Option.NONE
d399 1
a399 1
	    info''
d403 5
a407 5
	fun exists_frame_info () =
	  case (!present_frame_info,
		fetch_frame_info (!present_variable_frame_info))
	  of (Option.NONE, []) => false
	  |  _ => true
d417 3
a419 3
	  case !current_var
	  of Option.NONE => false
	  |  _ => true
d422 4
a425 4
	  case !current_var
	  of Option.NONE => ()
	  |  Option.SOME (var,(ty,value,valuestr)) =>
	    inspect_fn false (var,(value,ty))
d428 1
a428 1
	     set_items = set_var_items, ...} =
d430 3
a432 3
	    {parent = varPane,
	     name = "debuggerVars",
	     select_fn = fn _ =>
d434 3
a436 3
		 (current_var := Option.SOME x;
	          inspect_fn true (var,(value,ty))),
	     action_fn = fn _ => 
d438 3
a440 3
	         inspect_fn false (var,(value,ty)),
	     print_fn = fn _ =>
	       (* This is what prints the args in the middle window *)
d442 3
a444 3
		 "val " ^ var
		 ^ ": " ^ Types.print_type Options.default_print_options ty ^
		 " = " ^ strip valuestr}
d446 1
a446 1
	(* This prints stuff in the middle window *)
d453 3
a455 3
	         set_var_items
		   Options.default_print_options
		   (fetch_frame_info(!present_variable_frame_info))
d457 1
a457 1
	         set_var_items
d459 10
a468 10
		   (("frame argument", x)
		    :: fetch_frame_info (!present_variable_frame_info))
	   else
	     ())

	fun frame_select_fn _ frame =
	  let val FRAME
		    {name, loc, details = (a,b,(ty,value,valuestr),info'),...} =
		frame
	  in
d473 1
a473 1
	     present_name := name;
d475 1
a475 1
	     show_vars info';
d477 1
a477 1
		  (ShellUtils.Info.Location.from_string loc) then
d479 2
a480 2
 	          (loc, Preferences.new_preferences user_preferences);
		())
d482 4
a485 4
		 ShellUtils.EditFailed _ => ()
	     else
	       ()
	  end
d488 1
a488 1
	     set_items=set_frame_items, ...} =
d490 5
a494 5
	    {parent = framePane,
	     name = "debuggerFrames",
	     select_fn = frame_select_fn,
	     action_fn = fn _ => fn FRAME{loc,...} => edit_fn loc, 
	     print_fn = 
d498 1
a498 1
	     (* This is what prints the args in the lower window *)}
d500 56
a555 66
        local
          val don'tshow_cframes = ref true
          val don'tshow_handlers = ref true
          val don'tshow_setups = ref true
          val don'tshow_anon = ref false
	  val don'tshow_delivered = ref true
	  val don'tshow_traced = ref true
        in
          val settings_spec =
            Menus.OPTTOGGLE ("hideAnonymousFrames",
                              fn () => !don'tshow_anon,
                              fn b => don'tshow_anon := b)
            :: Menus.OPTTOGGLE ("hideHandlerFrames",
                              fn () => !don'tshow_handlers,
                              fn b => don'tshow_handlers := b)
            :: (if !full_menus then
		  [Menus.OPTTOGGLE ("hideSetupFrames",
                                    fn () => !don'tshow_setups,
                                    fn b => don'tshow_setups := b),
                   Menus.OPTTOGGLE ("hideCFrames",
                                    fn () => !don'tshow_cframes,
                                    fn b => don'tshow_cframes := b),
		   Menus.OPTTOGGLE ("hideDeliveredFrames",
                                    fn () => !don'tshow_delivered,
                                    fn b => don'tshow_delivered := b),
                   Menus.OPTTOGGLE ("hideTracedFrames",
                                    fn () => !don'tshow_traced,
                                    fn b => don'tshow_traced := b)]
		else
		  nil)

          fun filter_frames ([],acc) = rev acc
            | filter_frames ((f as FRAME{name,loc,details}) :: rest,acc) =
	      case name of
		"<Cframe>" =>
		  let
		    val newacc = if (!don'tshow_cframes) then acc else f::acc
		    val newrest =
		      if (!don'tshow_traced)
			andalso loc = "start intercept" then 
			(case rest of
			   (FRAME{name="<Cframe>",...})::_ => rest
			 | _::rest' => rest'
			 | _ => rest)
		      else rest
		  in
		    filter_frames(newrest,newacc)
		  end
	      | _ =>
		  let
		    val don'tshowit = 
		      case name of
			"<handle>" => !don'tshow_handlers
		      | "<anon>" => !don'tshow_anon
		      | "<Setup>" => !don'tshow_setups
		      | _ => false
		      val delivered =
			size loc > 0 andalso
			ord loc = ord " " 
		      val don'tshowit =
			(!don'tshow_delivered andalso delivered)
			orelse don'tshowit
		  in
		    filter_frames (rest, if don'tshowit then acc else f::acc)
		  end
        end
d580 1
a580 1
	  Vector.length (Capi.List.get_selected_pos framesList) = 1
d598 1
a598 1
	fun is_editable _ =
d607 1
a607 1
		  val location = ShellUtils.Info.Location.from_string loc
d612 1
a612 1
		  false
d614 1
a614 1
	      false
d633 2
a634 2
	fun present (ref Option.NONE) = false
	|   present (ref (Option.SOME _)) = true
d644 1
a644 1
	       clear_window ();
d673 2
a674 2
	  let
	    val {update, set_focus} =
d676 1
a676 1
		(buttonPane,
d679 1
a679 1
		    ("continue", continue_action, continue_present),
d682 9
a690 9
	    fun do_set_focus () =
	      if continue_present () then
	        if Trace.stepping () then
	          set_focus 2
	        else
	          set_focus 1
	      else
	        set_focus 0
	  in
d692 1
a692 1
	  end
d701 1
a701 1
                             	       fn _ => inspect_current_var (),
d723 1
a723 1
	      Capi.List.select_pos (framesList, 1, true);
d736 9
a744 9
	Capi.Layout.lay_out
	  (varPane,
	   [Capi.Layout.FIXED argsLabel,
	    Capi.Layout.FIXED argsText,
	    Capi.Layout.FLEX varsScroll]);
	Capi.Layout.lay_out
	  (framePane,
	   [Capi.Layout.FIXED framesLabel,
	    Capi.Layout.FLEX framesScroll]);
@


1.25
log
@Updated wrt to Trace.step_status -> Trace.stepping name change.
@
text
@d4 3
d427 4
a430 1
	     select_fn = fn _ => fn x => current_var := Option.SOME x,
@


1.24
log
@Capi.make_scrolllist now returns a record, with an add_items field.
@
text
@d4 3
d683 1
a683 1
	        if Trace.step_state () then
@


1.23
log
@Revised layout.
@
text
@d4 3
d416 2
a417 1
        val (varsScroll, varsList, set_var_items) =
d473 2
a474 1
        val (framesScroll, framesList, set_frame_items) =
@


1.22
log
@Make inspector window sibling of debugger window
@
text
@d4 3
d231 1
d243 1
d250 4
d311 2
d318 2
a319 2
        val (shell,form,menuBar,_) = Capi.make_main_popup ("debugger",title,
                                                           parent,false)
d330 2
a331 1
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, form, [])
d337 20
a356 2
        val (_,text) = Capi.make_scrolled_text ("debuggerText",debuggerFrame,[])
        val (_,argsText) = Capi.make_scrolled_text ("debuggerArgsText",debuggerFrame,[])
a363 4
        fun find(_,[]) = ()
          | find(1,(_,a)::t) = Capi.Text.set_string(argsText,a)
          | find(n,_::t) = find(n-1,t)

d378 69
a446 1
	fun select_fn _ frame =
d456 2
a457 32
             Capi.Text.set_string
	       (argsText,
		b ^ (case info' of
                       Option.NONE => ""
                     | Option.SOME info' =>
                       (present_variable_frame_info := info';
                        if !show_variable_debug_info then 
			  let
			    val info =
			      case !info' of
				Option.INL info => 
				  let
				    val info as (info'',_) = info()
				  in
				    (info' := Option.INR info;info'')
				  end
			      | Option.INR(info',_) => info'
			    val size_info = size info
			    fun remove_upto_cr i =
			      if i >= size_info orelse String.ordof(info, i) = ord"\n" then
				if i < size_info then
				  String.substring(info, i, size_info - i)
				else
				  ""
			      else
				remove_upto_cr(i+1)
			  in
			    remove_upto_cr 0
			  end
                        else
		          "")));
	       (* This prints stuff in the middle window *)
d469 1
a469 1
        val (framesScroll, framesList, set_items) =
d471 1
a471 1
	    {parent = debuggerFrame,
d473 1
a473 1
	     select_fn = select_fn,
d561 1
a561 1
            set_items Options.default_print_options frame_list
d570 2
a571 1
        fun item_selected _ = Vector.length (Capi.List.get_selected_pos framesList) = 1
a626 41
        val max_length = 80
        fun strip str = 
          if size str <= max_length then str
          else String.substring(str,0,max_length-3) ^ "..."

        fun fetch_frame_info (info' as ref(Option.INL info_fn)) = 
          let val info as (_,info'') = info_fn ()
          in
            info' := Option.INR info;
	    info''
          end
        |   fetch_frame_info (ref(Option.INR(_,info))) = info

	fun exists_frame_info () =
	  case (!present_frame_info,
		fetch_frame_info (!present_variable_frame_info))
	  of (Option.NONE, []) => false
	  |  _ => true

        (* The inspector can't be a child of the debugger itself *)
        val inspect_fn = InspectorTool.inspect_value (parent,true,tooldata)
        fun inspect_frame_info () = 
          let
            val push_values = 
              map (fn (var,(ty,value,valuestr)) =>
                   Menus.PUSH (var^" = "^strip valuestr,
                               fn _ => inspect_fn false (var,(value,ty)),
                               fn _ => true))

          in
             case !present_frame_info of
               Option.NONE =>
		 push_values (fetch_frame_info(!present_variable_frame_info))
             | Option.SOME(ty,value,valuestr) => 
                 Menus.PUSH ("frame argument"^" = "^strip valuestr,
                             fn _ => inspect_fn false ("frame argument",(value,ty)),
                             fn _ => true)
                 :: push_values
		      (fetch_frame_info(!present_variable_frame_info))
          end

d691 3
a693 3
                           Menus.DYNAMIC ("inspectFrameInfo",
                                          inspect_frame_info,
                                          fn _ => exists_frame_info ())],
d727 9
d737 5
a741 5
        (form,
         [Capi.Layout.MENUBAR menuBar,
          Capi.Layout.FIXED buttonPane,
          Capi.Layout.PANED debuggerFrame,
          Capi.Layout.SPACE]);
@


1.21
log
@Changing interface to inspector
@
text
@d4 3
d581 2
a582 1
        val inspect_fn = InspectorTool.inspect_value (shell,true,tooldata)
@


1.20
log
@Changes to what is done with full_menus
@
text
@d4 3
d242 2
a243 1
  sharing type Menus.Widget = GuiUtils.Widget = ToolData.Widget = Capi.Widget
d578 1
d584 2
a585 4
                          fn _ => InspectorTool.inspect_value
				    true
                                    (var,(value,ty),tooldata),
                          fn _ => true))
d593 1
a593 4
                             fn _ =>
			       InspectorTool.inspect_value
				 true 
                                 ("frame argument",(value,ty),tooldata),
@


1.19
log
@Fix bug 1079
Done by as part of abort_action, as well as continue_action and step_action
@
text
@d4 4
d298 1
a298 1
        val show_variable_debug_info = ref(!full_menus)
d659 8
a666 13
                         Menus.PUSH ("abort",abort_action,abort_present) ::
                         Menus.PUSH ("continue",continue_action,continue_present) ::
                         Menus.PUSH ("step",step_action,continue_present) ::
                         (if !full_menus then
                            [Menus.PUSH ("edit_frame",edit_callback,is_editable),
                             Menus.DYNAMIC ("inspectFrameInfo",
                                            inspect_frame_info,
                                            fn _ => exists_frame_info ())]
                          else
                            [Menus.PUSH ("edit_frame",
                                         edit_callback,
                                         is_editable)]),
                         fn _ => true),
d668 7
a674 10
                         Menus.PUSH ("filterFrames",
                                     fn _ => settings_popup (),
                                     fn _ => true) ::
                         (if !full_menus then
                            [Menus.PUSH ("showFrameInfo",
                                         fn _ => info_settings_popup (),
                                         fn _ => true)]
                          else
                            nil),
                         fn _ => true),
@


1.18
log
@Modify to display local variable info on full menus
@
text
@d4 3
d603 1
@


1.17
log
@Changing button resources
@
text
@d4 3
d290 2
a291 2
        val show_debug_info : bool ref = ref true
        val show_variable_debug_info : bool ref = ref false
@


1.16
log
@Some tidying up and a little documentation added
This should make it easier for the next person to look at this stuff
@
text
@d4 4
d629 1
a629 1
                 [Menus.PUSH ("abortButton", abort_action, abort_present),
d631 2
a632 2
		    ("continueButton", continue_action, continue_present),
                  Menus.PUSH ("stepButton", step_action, continue_present)])
@


1.15
log
@Remove duplication of function information in debugger frame window
@
text
@d4 3
d343 1
a343 1
		b ^(case info' of
d372 1
d393 2
a394 1
             a ^(if !show_debug_info then info else "")}
@


1.14
log
@Hide some additional frames.
@
text
@d4 3
d340 1
a340 1
		b ^ (case info' of
d345 22
a366 8
                          case !info' of
                            Option.INL info => 
                            let
                               val info as (info'',_) = info()
                            in
                              (info' := Option.INR info;info'')
                            end
                          | Option.INR(info',_) => info'
d389 1
a389 1
             a ^ (if !show_debug_info then info else "")}
@


1.13
log
@Moved call of set_active_buttons to after popup, so that focus is set
correctly.
@
text
@d4 4
d233 1
a233 1

d379 2
d395 7
a401 1
                                    fn b => don'tshow_cframes := b)]
d407 32
a438 11
              let
                val don'tshowit =
                  case name of
                    "<handle>" => !don'tshow_handlers
                  | "<anon>" => !don'tshow_anon
                  | "<Cframe>" => !don'tshow_cframes
                  | "<Setup>" => !don'tshow_setups
                  | _ => false
              in
                filter_frames (rest, if don'tshowit then acc else (f::acc))
              end
@


1.12
log
@Replaced Trace.get_stepping with Trace.step_state (which does the same thing).
@
text
@d626 1
a627 1
           popup();
@


1.11
log
@Renamed ShellUtils.edit_string to ShellUtils.edit_source
(and ShellUtils.edit_source to ShellUtils.edit_location).
@
text
@d4 4
d577 1
a577 1
	        if Trace.get_stepping () then
@


1.10
log
@Changed run_debugger to select the appropriate button for default action.
@
text
@d4 3
d294 1
a294 1
          (ShellUtils.edit_string
d346 1
a346 1
               (ShellUtils.edit_string
@


1.9
log
@Made debugger show source of current frame in emacs, when possible.
This is a stop-gap implementation - we need a source browser for non-emacs
users.
@
text
@d4 5
d559 20
a578 11
          set_active_buttons :=
          Menus.make_buttons (buttonPane,
                              [Menus.PUSH ("abortButton",
                                           abort_action,
                                           abort_present),
                               Menus.PUSH ("continueButton",
                                           continue_action,
                                           continue_present),
                               Menus.PUSH ("stepButton",
                                           step_action,
                                           continue_present)])
@


1.8
log
@Fixing some problems with running under Win32
@
text
@d4 3
d311 1
a311 1
		    {name, details = (a,b,(ty,value,valuestr),info'),...} =
d335 10
a344 1
		          "")))
d600 1
a600 1
           case frames of
d603 1
a603 3
               select_fn
               (framesScroll, framesList, set_items)
               (FRAME (Lists.nth (0,frames)));
@


1.7
log
@Renaming layout constructors
@
text
@d4 3
a272 8
        (* Need to terminate main loop even if we are not popping window down *)

        fun maybe_popdown () = 
          (*
           if Trace.step_state () then continue := false else popdown ()
             *)
          continue := false

d513 2
a514 1
              (popdown();
d526 1
a526 1
               maybe_popdown();
d537 1
a537 1
                maybe_popdown();
@


1.6
log
@Fixing problem with empty frame list
@
text
@d4 3
d241 1
a241 1
    fun make_debugger_window (parent,name,tooldata) =
d258 2
a259 2
        val shell = Capi.make_popup_shell ("debuggerShell",parent,[])
        val (form,menuBar,_) = Capi.make_main_subwindows (shell,false)
d265 1
a265 1
          (Capi.manage form;
d268 1
a268 1
        fun popdown () = Capi.unmanage form;
d613 1
a613 1
          Capi.Layout.OTHER buttonPane,
a615 2
        Capi.manage text;
        Capi.manage argsText;
@


1.5
log
@Bring window to front when entered.
@
text
@d4 3
d583 1
a583 2
        fun run_debugger
	      {parameter_details, frames, quit_fn, continue_fn} =
d589 6
a594 3
	   select_fn
	     (framesScroll, framesList, set_items)
	     (FRAME (Lists.nth (0,frames)));
@


1.4
log
@Using Menus.make_buttons for buttons
@
text
@d4 3
d258 4
a261 1
        fun popup () = Capi.manage form;
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
a266 3
        val abortButton = Capi.make_managed_widget ("abortButton", Capi.PushButton, buttonPane, [])
        val continueButton = Capi.make_managed_widget ("continueButton", Capi.PushButton, buttonPane, [])
        val stepButton = Capi.make_managed_widget ("stepButton", Capi.PushButton, buttonPane, [])
d509 1
a509 4
        fun set_active_buttons _ =
          (Capi.set_sensitivity (abortButton,abort_present());
           Capi.set_sensitivity (continueButton,continue_present());
           Capi.set_sensitivity (stepButton,continue_present()))
d517 3
a519 3
                set_active_buttons ();
                maybe_popdown();
                clear_window ();
d528 1
a528 1
                set_active_buttons ();
d533 13
d585 1
a585 1
           set_active_buttons ();
a595 4
        (* Set callbacks for buttons *)
        Capi.Callback.add (abortButton, Capi.Callback.Activate,abort_action);
        Capi.Callback.add (continueButton, Capi.Callback.Activate,continue_action);
        Capi.Callback.add (stepButton, Capi.Callback.Activate,step_action);
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d247 1
a247 1
        val form = Capi.make_widget ("debuggerForm",Capi.Form,shell,[])
a262 1
        val menuBar = Capi.make_managed_widget ("menuBar", Capi.RowColumn, form, [])
d334 4
a337 2
	     print_fn = fn _ => fn FRAME{details = (a,_,(_,_,info),_),...} => 
                                     a^(if !show_debug_info then info else "")}
d591 5
a595 4
        [Capi.Layout.MENUBAR menuBar,
         Capi.Layout.OTHER buttonPane,
         Capi.Layout.PANED debuggerFrame,
	 Capi.Layout.SPACE];
@


1.1
log
@new unit
New unit
@
text
@d4 4
d160 2
a161 2
require "../library/capi";
require "../library/menus";
@
