head	1.35;
access;
symbols
	MLW_daveb_inline_1_4_99:1.35.1
	MLWorks_21c0_1999_03_25:1.35
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.34
	MLWorks_20m2_1998_02_16:1.32
	MLWorks_20m1_1997_10_23:1.31
	MLWorks_11r1:1.26.6.1.1.2.1
	MLWorks_workspace_97:1.30.2
	MLWorks_dt_wizard:1.30.1
	MLWorks_11c0_1997_09_09:1.26.6.1.1.2
	MLWorks_10r3:1.26.6.1.3
	MLWorks_10r2_551:1.26.6.1.2
	MLWorks_11:1.26.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.6.1
	MLWorks_20m0_1997_06_20:1.29
	MLWorks_1_0_r2c2_1997_06_14:1.26.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.26.6
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.26.4.1.1
	MLWorks_gui_1996_12_18:1.26.5
	MLWorks_1_0_Win32_1996_12_17:1.26.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.26.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.26.1.1
	JFHgui:1.26.3
	MLWorks_1_0_Irix_1996_11_28:1.26.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.26.2
	MLWorks_1_0_Unix_1996_11_14:1.26.1
	MLWorks_Open_Beta2_1996_10_11:1.24.3
	MLWorks_License_dev:1.24.2
	MLWorks_1_open_beta_1996_09_13:1.24.1
	MLWorks_Open_Beta_1996_08_22:1.24
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22;
locks; strict;
comment	@ * @;


1.35
date	98.03.31.15.15.28;	author johnh;	state Exp;
branches
	1.35.1.1;
next	1.34;

1.34
date	98.03.16.11.28.18;	author mitchell;	state Exp;
branches;
next	1.33;

1.33
date	98.02.13.15.58.04;	author johnh;	state Exp;
branches;
next	1.32;

1.32
date	98.01.27.15.55.36;	author johnh;	state Exp;
branches;
next	1.31;

1.31
date	97.09.18.15.13.35;	author brucem;	state Exp;
branches;
next	1.30;

1.30
date	97.08.04.12.03.29;	author johnh;	state Exp;
branches
	1.30.1.1
	1.30.2.1;
next	1.29;

1.29
date	97.06.12.15.03.15;	author johnh;	state Exp;
branches;
next	1.28;

1.28
date	97.06.10.11.20.02;	author johnh;	state Exp;
branches;
next	1.27;

1.27
date	97.05.16.15.35.36;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	96.11.01.11.03.06;	author johnh;	state Exp;
branches
	1.26.1.1
	1.26.2.1
	1.26.3.1
	1.26.4.1
	1.26.5.1
	1.26.6.1;
next	1.25;

1.25
date	96.10.09.11.53.17;	author io;	state Exp;
branches;
next	1.24;

1.24
date	96.08.15.14.25.57;	author daveb;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1;
next	1.23;

1.23
date	96.08.07.11.36.39;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.05.24.13.43.21;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	96.05.23.15.49.38;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	96.05.14.15.08.19;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	96.05.10.14.45.30;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	96.05.01.11.24.46;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	96.04.11.16.02.01;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	96.03.07.17.04.07;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.19.16.36.29;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.02.19.14.13.50;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	96.02.08.15.59.16;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.01.23.15.56.13;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	96.01.22.16.35.18;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.01.19.11.00.05;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	96.01.17.17.28.22;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.12.07.14.40.01;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.11.15.16.50.28;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.10.04.13.01.16;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.09.11.13.19.12;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.30.13.23.34;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.12.22.31;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.55.56;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.42.46;	author matthew;	state Exp;
branches;
next	;

1.24.1.1
date	96.09.13.11.13.22;	author hope;	state Exp;
branches;
next	;

1.24.2.1
date	96.10.07.16.04.03;	author hope;	state Exp;
branches;
next	;

1.24.3.1
date	96.10.17.11.22.18;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	96.11.14.12.46.21;	author hope;	state Exp;
branches
	1.26.1.1.1.1;
next	;

1.26.1.1.1.1
date	96.11.28.14.58.03;	author hope;	state Exp;
branches;
next	;

1.26.2.1
date	96.11.22.18.06.40;	author hope;	state Exp;
branches;
next	;

1.26.3.1
date	96.12.17.09.54.44;	author hope;	state Exp;
branches;
next	;

1.26.4.1
date	96.12.17.17.45.21;	author hope;	state Exp;
branches
	1.26.4.1.1.1;
next	;

1.26.4.1.1.1
date	97.02.24.11.34.50;	author hope;	state Exp;
branches;
next	;

1.26.5.1
date	96.12.18.09.39.21;	author hope;	state Exp;
branches;
next	;

1.26.6.1
date	97.05.12.10.31.41;	author hope;	state Exp;
branches
	1.26.6.1.1.1
	1.26.6.1.2.1
	1.26.6.1.3.1;
next	;

1.26.6.1.1.1
date	97.07.28.18.17.34;	author daveb;	state Exp;
branches;
next	1.26.6.1.1.2;

1.26.6.1.1.2
date	97.08.04.17.10.07;	author johnh;	state Exp;
branches
	1.26.6.1.1.2.1.1;
next	;

1.26.6.1.1.2.1.1
date	97.10.07.11.42.26;	author jkbrook;	state Exp;
branches;
next	;

1.26.6.1.2.1
date	97.09.08.17.11.05;	author daveb;	state Exp;
branches;
next	;

1.26.6.1.3.1
date	97.09.09.14.06.40;	author daveb;	state Exp;
branches;
next	1.26.6.1.3.2;

1.26.6.1.3.2
date	97.09.22.16.22.15;	author jkbrook;	state Exp;
branches;
next	;

1.30.1.1
date	97.09.10.19.21.14;	author brucem;	state Exp;
branches;
next	;

1.30.2.1
date	97.09.11.20.52.27;	author daveb;	state Exp;
branches;
next	1.30.2.2;

1.30.2.2
date	97.11.20.17.05.12;	author johnh;	state Exp;
branches;
next	;

1.35.1.1
date	99.04.01.17.55.40;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.35
log
@[Bug #30346]
Call Capi.getNextWindowPos.
@
text
@(*  Context window
 *
 *  $Log: _context.sml,v $
 * Revision 1.34  1998/03/16  11:28:18  mitchell
 * [Bug #50061]
 * Fix tools so they restart in a saved image
 *
 * Revision 1.33  1998/02/13  15:58:04  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.32  1998/01/27  15:55:36  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.31  1997/09/18  15:13:35  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.30.2.2  1997/11/20  17:05:12  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.30.2.1  1997/09/11  20:52:27  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.30  1997/08/04  12:03:29  johnh
 * [Bug #30111]
 * Start file viewer on double click.
 *
 * Revision 1.29  1997/06/12  15:03:15  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.28  1997/06/10  11:20:02  johnh
 * [Bug #30075]
 * Allowing only one instance of tools.
 *
 * Revision 1.27  1997/05/16  15:35:36  johnh
 * \Implementing single menu bar on Windows.
 *
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.25  1996/10/09  11:53:17  io
 * moving String from toplevel
 *
 * Revision 1.24  1996/08/15  14:25:57  daveb
 * [Bug #1519]
 * Changed the type of history entries (in UserContext) so that when a single
 * expression defines several identifiers, only the first stores the string.
 * Also replaced code in get_current_item with a call to
 * ShellUtils.value_from_history_entry.
 *
 * Revision 1.23  1996/08/07  11:36:39  daveb
 * [Bug #1531]
 * Unset the current item when after a delete command.
 *
 * Revision 1.22  1996/05/24  13:43:21  daveb
 * Type of GuiUtils.view_option has changed.
 *
 * Revision 1.21  1996/05/23  15:49:38  daveb
 * Replace Evaluator with File Viewer.
 *
 * Revision 1.20  1996/05/14  15:08:19  daveb
 * Added File menu.
 *
 * Revision 1.19  1996/05/10  14:45:30  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
 * Revision 1.18  1996/05/01  11:24:46  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.17  1996/04/11  16:02:01  daveb
 * Added ability to delete entries.
 *
 * Revision 1.16  1996/03/07  17:04:07  daveb
 * Disabled show_defn menu entry when no item selected.
 *
 * Revision 1.15  1996/02/19  16:36:29  daveb
 * Added "output-only" evaluator to display source and result of selected entry
 *
 * Revision 1.14  1996/02/19  14:13:50  daveb
 * Removed redundant function definition.
 *
 * Revision 1.13  1996/02/08  15:59:16  daveb
 * Stopped the update from always selecting the newly updated item.
 * Capi.make_scrolllist now returns a record, with an add_items field.
 * Removed the old sensitivity code.
 *
 * Revision 1.12  1996/01/23  15:56:13  daveb
 * Type of GuiUtils.value_menu has changed.
 *
 * Revision 1.11  1996/01/22  16:35:18  matthew
 * Using Info.null_options in call to eval
 *
 * Revision 1.10  1996/01/19  11:00:05  matthew
 * Changing inspector interface.
 *
 * Revision 1.9  1996/01/17  17:28:22  matthew
 * Reordering top level menus.
 *
 * Revision 1.8  1995/12/07  14:40:01  matthew
 * Changing interface to edit_menu
 *
 * Revision 1.7  1995/11/15  16:50:28  matthew
 * Adding windows menu
 *
 * Revision 1.6  1995/10/04  13:01:16  daveb
 * Type of context_menu has changed.
 *
 * Revision 1.5  1995/09/11  13:19:12  matthew
 * Changing top level window initialization
 *
 * Revision 1.4  1995/08/30  13:23:34  matthew
 * Changing layout
 *
 * Revision 1.3  1995/08/10  12:22:31  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:55:56  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:42:46  matthew
 * new unit
 * New unit
 *
 *  Revision 1.17  1995/07/07  15:31:21  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.16  1995/07/04  14:04:00  matthew
 *  More capification
 *
 *  Revision 1.15  1995/06/29  10:05:23  matthew
 *  Capification
 *
 *  Revision 1.14  1995/06/20  14:37:37  daveb
 *  Added call to Xm.List.setBottomPos, to ensure that selected item is
 *  always visible.
 *
 *  Revision 1.13  1995/06/08  14:20:49  daveb
 *  Ensured that current selection is highlighted after an update.
 *
 *  Revision 1.12  1995/06/06  10:38:12  daveb
 *  Made the context history highlight the current selection on start up.
 *
 *  Revision 1.11  1995/06/01  12:57:45  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.10  1995/05/23  09:27:14  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.9  1995/05/04  09:46:49  matthew
 *  Changing createPopupShell to create
 *
 *  Revision 1.8  1995/04/28  15:00:41  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.7  1995/04/24  14:51:52  daveb
 *  Changed title to Context History.
 *
 *  Revision 1.6  1995/04/19  12:17:10  daveb
 *  A new tool is now passed the right user context.
 *
 *  Revision 1.4  1995/04/06  16:08:23  daveb
 *  FileDialog.find_file now takes an applicationShell parameter.
 *
 *  Revision 1.3  1995/03/31  17:44:02  daveb
 *  Added the history number to items in the history, and made this tool
 *  sensitive to selections elsewhere.
 *
 *  Revision 1.2  1995/03/31  13:27:29  daveb
 *  Tidied writing of history to files.
 *  Also disabled "save" menu item when there is no name for the save file.
 *  Also fixed bug that stopped version 1.1 from compiling at all!!
 *
 *  Revision 1.1  1995/03/31  09:14:08  daveb
 *  new unit
 *  Context history window.
 *
 *  Copyright (c) 1995 Harlequin Ltd.
 *
 *)

require "capi";
require "menus";
require "../utils/lists";
require "../main/user_options";
require "../main/preferences";

require "../interpreter/shell_utils";
require "../interpreter/save_image";

require "tooldata";
require "inspector_tool";
require "file_viewer";
require "gui_utils";
require "context";

functor ContextHistory (
  structure Capi : CAPI
  structure ToolData : TOOL_DATA
  structure Menus : MENUS
  structure GuiUtils : GUI_UTILS
  structure FileViewer : FILE_VIEWER
  structure InspectorTool : INSPECTORTOOL
  structure ShellUtils : SHELL_UTILS
  structure Lists: LISTS
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure SaveImage : SAVE_IMAGE

  sharing ToolData.ShellTypes.Options = UserOptions.Options = ShellUtils.Options

  sharing type Preferences.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       GuiUtils.user_preferences

  sharing type GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options

  sharing type ToolData.ShellTypes.user_options =
	       GuiUtils.user_tool_options =
	       UserOptions.user_tool_options

  sharing type Menus.Widget = ToolData.Widget = FileViewer.Widget =
	       GuiUtils.Widget = Capi.Widget = InspectorTool.Widget

  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec

  sharing type ToolData.ShellTypes.user_context = GuiUtils.user_context

  sharing type GuiUtils.MotifContext = ToolData.MotifContext

  sharing type InspectorTool.ToolData = ToolData.ToolData = FileViewer.ToolData

  sharing type ShellUtils.Context = ToolData.ShellTypes.Context
  sharing type GuiUtils.Type = ShellUtils.Type = InspectorTool.Type
  sharing type ShellUtils.history_entry = ToolData.UserContext.history_entry

): CONTEXT_HISTORY =
struct
  
  structure UserContext = ToolData.UserContext
  structure ShellTypes = ToolData.ShellTypes
  structure Options = UserOptions.Options

  structure Info = ShellUtils.Info

  type ToolData = ToolData.ToolData

  val history_tool = ref NONE

  val sizeRef = ref NONE
  val posRef = ref NONE

  fun create_history (tooldata as ToolData.TOOLDATA
                {args,appdata,current_context,motif_context,tools}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args
      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val full_menus =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
          !full_menus

      val title = "History"

      (*** Make the windows ***)
      val (shell,frame,menuBar,contextLabel) = 
        Capi.make_main_window 
	       {name = "context",
		title = title,
		parent = applicationShell,
		contextLabel = full_menus, 
		winMenu = false,
		pos = getOpt (!posRef, Capi.getNextWindowPos())}

      val local_context = ref motif_context

      fun get_user_context () =
	GuiUtils.get_user_context (!local_context)

      val history = ref []: UserContext.history_entry list ref;

      fun empty_history () =
	case !history
	of [] => true
	|  _  => false

      val curr_string = ref ""
      val curr_item = ref NONE
      val do_select_fn = ref (fn () => ())
      val do_action_fn = ref (fn () => ())

      fun unset_selection _ =
	(curr_string := "";
	 curr_item := NONE)

      fun select_fn
	    _
            (entry as UserContext.ITEM (item as {result, ...})) =
        (curr_string := result;
         curr_item := SOME entry;
         (!do_select_fn) ())

      fun action_fn _ (entry as UserContext.ITEM (item as {result, ...})) = 
	(curr_string := result;
	 curr_item := SOME entry;
	 (!do_action_fn) ())

      val {scroll, list, set_items, add_items} =
        Capi.make_scrolllist
          {parent = frame, name = "context_window",
           print_fn =
             fn _ => fn (UserContext.ITEM {result, ...}) => result,
           select_fn = select_fn,
           action_fn = action_fn}

      fun get_print_options () =
        UserOptions.new_print_options user_options

      fun set_history_from_context user_context  =
        let
          val hist = UserContext.get_history user_context
        in
          history := hist;
          set_items(get_print_options ()) (rev hist)
        end

      fun delete_selection () =
	case !curr_item
	of NONE => ()
	|  SOME x =>
	  (UserContext.delete_from_history (get_user_context (), x);
	   unset_selection ())

      fun delete_all_duplicates () =
        (UserContext.remove_duplicates_from_history (get_user_context ());
	 unset_selection ())
      
      fun delete_all () =
        (UserContext.delete_entire_history (get_user_context ());
	 unset_selection ())
      
      fun update_fn NONE =
	set_history_from_context (get_user_context ())
      |   update_fn (SOME new_items) =
	(* This is partly to avoid flicker; partly an optimisation. *)
	(history := new_items @@ !history;
         add_items(get_print_options ()) (rev new_items))

      val update_register_key =
        ref (UserContext.add_update_fn (get_user_context (), update_fn))

      fun with_no_history f arg1 arg2 =
	  let 
	    val history = !history_tool
            val user_context = get_user_context ()
	  in
	    history_tool := NONE;
            UserContext.remove_update_fn
              (user_context, !update_register_key);
	    ignore(f arg1 arg2 
                   handle exn => (history_tool := history; 
                                  update_register_key :=
                                    UserContext.add_update_fn
                                      (user_context, update_fn);
                                  raise exn));
	    history_tool := history;
            update_register_key :=
              UserContext.add_update_fn(user_context, update_fn)
	  end

      fun set_state motif_context =
        let
          val context_name = GuiUtils.get_context_name motif_context

          val cstring = "Context: " ^ context_name

	  val old_user_context = get_user_context ()

	  val new_user_context = GuiUtils.get_user_context motif_context
        in
          UserContext.remove_update_fn
            (old_user_context, !update_register_key);
	  case contextLabel
	  of SOME w =>
            Capi.set_label_string (w,cstring)
	  |  NONE => ();
          local_context := motif_context;
          set_history_from_context new_user_context;
          update_register_key :=
            UserContext.add_update_fn (new_user_context, update_fn)
        end

      val _ = set_state (!local_context)

      val context_key =
        ToolData.add_context_fn
          (current_context,
	   (set_state, fn () => user_options, ToolData.WRITABLE))

      fun select_state motif_context =
        (set_state motif_context;
         ToolData.set_current
           (current_context, context_key, user_options, motif_context))

      val quit_funs = ref []

      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

      val _ =
        quit_funs :=
          (fn _ =>
	     let
	       val user_context = get_user_context ()
	     in
	       ToolData.remove_context_fn (current_context, context_key);
	       UserContext.remove_update_fn
                 (user_context, !update_register_key)
	     end)
          :: (fn _ => (history_tool := NONE))
	  :: !quit_funs

      fun close_window _ =
        (do_quit_funs ();
         Capi.destroy shell)

      fun mk_tooldata () =
        ToolData.TOOLDATA
          {args = ToolData.ShellTypes.LISTENER_ARGS
                    {user_options = user_options,
                     user_context = get_user_context (),
		     user_preferences = user_preferences,
                     prompter = prompter,
                     mk_xinterface_fn = mk_xinterface_fn},
           appdata = appdata,
	   motif_context = !local_context,
           current_context = current_context,
           tools = tools}

      val view_options =
        GuiUtils.view_options
          {parent = shell, title = title, user_options = user_options,
	   user_preferences = user_preferences,
           caller_update_fn = fn _ => (),
	   view_type = [GuiUtils.SENSITIVITY]}

      (* What this is doing is taking a history item (UserContext.Item)
	 and evaluating it in the context contained in the item *)
      fun get_current_value () =
        case !curr_item of
          NONE => NONE
        | SOME item =>
	  ShellUtils.value_from_history_entry
	    (item, ShellTypes.new_options (user_options, get_user_context()))

      val inspect_fn = InspectorTool.inspect_value (shell,false, mk_tooldata())

      fun is_selection () =
	case !curr_item
	of SOME _ => true
	|  NONE => false

      val show_defn_fn = FileViewer.create (shell, true, mk_tooldata())

      fun show_defn auto =
        case !curr_item of
          NONE => ()
        | SOME (item as UserContext.ITEM {source, ...}) =>
	   case source
	   of UserContext.STRING src => 
             show_defn_fn auto (FileViewer.STRING src)
	   |  UserContext.COPY src => 
             show_defn_fn auto (FileViewer.STRING src)

      val _ = 
        do_select_fn := 
	  (fn () =>
             (show_defn true;
	      case get_current_value () of
                SOME x => (inspect_fn true x)
              | _ => ()))

      (* set_focus needs to be done here so that once the file viewer is popped up,
       * focus is returned back to the History tool.
       *)
      val _ = do_action_fn := (fn () => (show_defn false;
					Capi.set_focus shell))

      val edit_menu =
         ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME (fn _ => Capi.clipboard_set (shell,!curr_string)),
             delete = SOME delete_selection,
             selection_made = fn _ => !curr_string <> "",
	     edit_possible = fn _ => true,
	     delete_all = SOME ("deleteAll",
		           fn _ => delete_all (),
		           fn _ => not (empty_history ())),
	     edit_source = [] })

      val value_menu =
	GuiUtils.value_menu
	  {parent = shell,
           user_preferences = user_preferences,
           inspect_fn = SOME (inspect_fn false),
           get_value = get_current_value,
	   enabled = true,
	   tail =
             [Menus.PUSH
                ("show_defn",
		 fn _ => show_defn false,
		 fn _ => is_selection ())]}

      val view = ToolData.extract view_options
      val values = ToolData.extract value_menu

      val menuspec =
        [ToolData.file_menu 
	    [("save",
		fn _ => GuiUtils.save_history
                 	(false, get_user_context (), applicationShell),
	        fn _ => not (UserContext.null_history (get_user_context ()))
         	        andalso UserContext.saved_name_set (get_user_context ())),
	     ("saveAs", 
		fn _ => GuiUtils.save_history
		        (true, get_user_context (), applicationShell),
		fn _ => not (UserContext.null_history (get_user_context ()))),
	     ("close", close_window, fn _ => true) ],
	 edit_menu,
	 ToolData.tools_menu (mk_tooldata, get_user_context),
	 ToolData.usage_menu 
	       (("removeDuplicates", 
		 fn _ => delete_all_duplicates (),
		 fn _ => not (empty_history ())) :: (values @@ view), []),
	 ToolData.debug_menu (values)]

      val sep_size = 10

      fun storeSizePos () = 
	(sizeRef := SOME (Capi.widget_size shell);
	 posRef := SOME (Capi.widget_pos shell))

    in
      SaveImage.add_with_fn with_no_history;
      history_tool := SOME shell;
      Menus.make_submenus (menuBar,menuspec);
      quit_funs := Menus.quit :: (!quit_funs);
      quit_funs := storeSizePos :: (!quit_funs);
      Capi.Layout.lay_out
      (frame, !sizeRef,
       [Capi.Layout.MENUBAR menuBar] @@
       (case contextLabel of
          SOME w => [Capi.Layout.FIXED w]
        | _ => [Capi.Layout.SPACE]) @@
       [Capi.Layout.FLEX scroll,
        Capi.Layout.SPACE]);
      Capi.set_close_callback(frame, close_window);
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
      Capi.initialize_toplevel shell
    end

  fun create tooldata = 
    if isSome (!history_tool) then 
      Capi.to_front (valOf (!history_tool))
    else
      create_history tooldata

end;
@


1.35.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.35  1998/03/31  15:15:28  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos.
 *
@


1.34
log
@[Bug #50061]
Fix tools so they restart in a saved image
@
text
@d4 4
d285 1
a285 1
		pos = getOpt (!posRef, (100,100))}
@


1.33
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d4 4
d191 1
d210 1
d360 19
d553 1
@


1.32
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d247 3
d269 7
a275 1
        Capi.make_main_window ("context",title,applicationShell,full_menus, false)
d522 5
d531 1
d533 1
a533 1
      (frame,
@


1.31
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 11
d506 1
a506 2
	 ToolData.debug_menu (values),
	 GuiUtils.paths_menu shell]
@


1.30
log
@[Bug #30111]
Start file viewer on double click.
@
text
@d4 4
a177 1
require "^.basis.__old";
@


1.30.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.30  1997/08/04  12:03:29  johnh
 * [Bug #30111]
 * Start file viewer on double click.
 *
@


1.30.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a3 3
 * Revision 1.30.2.1  1997/09/11  20:52:27  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d496 2
a497 1
	 ToolData.debug_menu (values)]
@


1.30.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.30  1997/08/04  12:03:29  johnh
 * [Bug #30111]
 * Start file viewer on double click.
 *
@


1.29
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d4 4
d265 1
d278 5
d289 1
a289 1
           action_fn = fn _ => fn _ => ()}
d413 4
a416 2
      val (show_defn_fn, quit_fn) =
	FileViewer.create (shell, true, mk_tooldata())
d418 1
a418 1
      val _ = quit_funs := quit_fn :: !quit_funs
d438 5
a442 4
      fun is_selection () =
	case !curr_item
	of SOME _ => true
	|  NONE => false
@


1.28
log
@[Bug #30075]
Allowing only one instance of tools.
@
text
@d4 4
d244 1
a244 1
        Capi.make_main_window ("context",title,applicationShell,full_menus)
d480 1
a480 2
	 GuiUtils.paths_menu shell,
	 ToolData.windows_menu ()]
@


1.27
log
@\Implementing single menu bar on Windows.
@
text
@d4 3
d219 1
a219 1
  val context_window_number = ref 1;
d221 1
a221 1
  fun create (tooldata as ToolData.TOOLDATA
d236 1
a236 10
      val title =
        let
          val n = !context_window_number
          fun p (s, 0) = s
            | p (s, n) = p (Old.chr (48+(n mod 10)) ^ s, n div 10)
        in
          context_window_number := n+1;
          "History #" ^ p ("", n)
        end

d361 2
a362 1
          :: !quit_funs
d481 1
d496 7
@


1.26
log
@Enabling close from control box on top left of window.
@
text
@d4 3
d441 4
a444 10
	     tail =
	       [Menus.PUSH
	          ("removeDuplicates",
	           fn _ => delete_all_duplicates (),
	           fn _ => not (empty_history ())),
	        Menus.PUSH
	          ("deleteAll",
	           fn _ => delete_all (),
	           fn _ => not (empty_history ()))]
	    })
d452 1
d459 2
a460 28
      val menu_tail =
        [value_menu,
	 ToolData.tools_menu (mk_tooldata, get_user_context),
         ToolData.windows_menu ()]

      val file_menu =
	Menus.CASCADE
	  ("file",
           [Menus.PUSH
              ("save",
               fn _ =>
                 GuiUtils.save_history
                   (false, get_user_context (), applicationShell),
               fn _ =>
                 not (UserContext.null_history (get_user_context ()))
                      andalso UserContext.saved_name_set
                                (get_user_context ())),
            Menus.PUSH
              ("saveAs",
               fn _ =>
                 GuiUtils.save_history
                   (true, get_user_context (), applicationShell),
               fn _ =>
                 not (UserContext.null_history (get_user_context ()))),
            Menus.SEPARATOR,
            Menus.PUSH
	      ("close", close_window, fn _ => true)],
	   fn _ => true)
d463 20
a482 7
        [file_menu,
	 edit_menu]
	@@ (if full_menus then
             Menus.CASCADE ("view", view_options, fn _ => true) ::
	     menu_tail
	   else
	     menu_tail)
d487 1
@


1.26.6.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.26.6.1  1997/05/12  10:31:41  hope
 * branched from 1.26
 *
@


1.26.6.1.3.2
log
@[Bug #30111]
Merging from trunk:
Debugger pops up dialog when source not available
@
text
@a3 3
 * Revision 1.26.6.1.3.1  1997/09/09  14:06:40  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
a265 1
      val do_action_fn = ref (fn () => ())
a277 5
      fun action_fn _ (entry as UserContext.ITEM (item as {result, ...})) = 
	(curr_string := result;
	 curr_item := SOME entry;
	 (!do_action_fn) ())

d284 1
a284 1
           action_fn = action_fn}
d407 2
a408 4
      fun is_selection () =
	case !curr_item
	of SOME _ => true
	|  NONE => false
d410 1
a410 1
      val show_defn_fn = FileViewer.create (shell, true, mk_tooldata())
d430 4
a433 5
      (* set_focus needs to be done here so that once the file viewer is popped up,
       * focus is returned back to the History tool.
       *)
      val _ = do_action_fn := (fn () => (show_defn false;
					Capi.set_focus shell))
@


1.26.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.26.6.1  1997/05/12  10:31:41  hope
 * branched from 1.26
 *
@


1.26.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.26.6.1  1997/05/12  10:31:41  hope
 * branched from 1.26
 *
@


1.26.6.1.1.2
log
@[Bug #30111]
Merging - double click on item brings up File Viewer.
@
text
@a3 4
 *
 * Revision 1.26.6.1.1.1  1997/07/28  18:17:34  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a265 1
      val do_action_fn = ref (fn () => ())
a277 5
      fun action_fn _ (entry as UserContext.ITEM (item as {result, ...})) = 
	(curr_string := result;
	 curr_item := SOME entry;
	 (!do_action_fn) ())

d284 1
a284 1
           action_fn = action_fn}
d407 2
a408 4
      fun is_selection () =
	case !curr_item
	of SOME _ => true
	|  NONE => false
d410 1
a410 1
      val show_defn_fn = FileViewer.create (shell, true, mk_tooldata())
d430 4
a433 5
      (* set_focus needs to be done here so that once the file viewer is popped up,
       * focus is returned back to the History tool.
       *)
      val _ = do_action_fn := (fn () => (show_defn false;
					Capi.set_focus shell))
@


1.26.6.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.26.6.1.1.2  1997/08/04  17:10:07  johnh
 * [Bug #30111]
 * Merging - double click on item brings up File Viewer.
 *
@


1.26.5.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.4.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.4.1.1.1
log
@branched from 1.26.4.1
@
text
@a3 3
 * Revision 1.26.4.1  1996/12/17  17:45:21  hope
 * branched from 1.26
 *
@


1.26.3.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.2.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.1.1
log
@branched from 1.26
@
text
@a3 3
 * Revision 1.26  1996/11/01  11:03:06  johnh
 * Enabling close from control box on top left of window.
 *
@


1.26.1.1.1.1
log
@branched from 1.26.1.1
@
text
@a3 3
 * Revision 1.26.1.1  1996/11/14  12:46:21  hope
 * branched from 1.26
 *
@


1.25
log
@moving String from toplevel
@
text
@d4 3
d510 1
@


1.24
log
@[Bug #1519]
Changed the type of history entries (in UserContext) so that when a single
expression defines several identifiers, only the first stores the string.
Also replaced code in get_current_item with a call to
ShellUtils.value_from_history_entry.
@
text
@d4 7
d157 1
d231 1
a231 1
            | p (s, n) = p (String.chr (48+(n mod 10)) ^ s, n div 10)
@


1.24.3.1
log
@branched from 1.24
@
text
@a3 7
 * Revision 1.24  1996/08/15  14:25:57  daveb
 * [Bug #1519]
 * Changed the type of history entries (in UserContext) so that when a single
 * expression defines several identifiers, only the first stores the string.
 * Also replaced code in get_current_item with a call to
 * ShellUtils.value_from_history_entry.
 *
@


1.24.2.1
log
@branched from 1.24
@
text
@a3 7
 * Revision 1.24  1996/08/15  14:25:57  daveb
 * [Bug #1519]
 * Changed the type of history entries (in UserContext) so that when a single
 * expression defines several identifiers, only the first stores the string.
 * Also replaced code in get_current_item with a call to
 * ShellUtils.value_from_history_entry.
 *
@


1.24.1.1
log
@branched from 1.24
@
text
@a3 7
 * Revision 1.24  1996/08/15  14:25:57  daveb
 * [Bug #1519]
 * Changed the type of history entries (in UserContext) so that when a single
 * expression defines several identifiers, only the first stores the string.
 * Also replaced code in get_current_item with a call to
 * ShellUtils.value_from_history_entry.
 *
@


1.23
log
@[Bug #1531]
Unset the current item when after a delete command.
@
text
@d4 4
d189 1
d256 1
a256 1
            (entry as UserContext.ITEM (item as (_, _, _, result, _))) =
d265 1
a265 1
             fn _ => fn (UserContext.ITEM (_, _, _, result, _)) => result,
d384 3
a386 17
        | SOME (item as UserContext.ITEM (_,id,context,_,src)) => 
            (case UserContext.history_entry_name item of
               SOME s =>
                 (let
                   val value =
                     ShellUtils.eval
                     Info.null_options
                     (s,
                      ShellTypes.new_options(user_options,get_user_context()),
                      context, fn f => fn a => f a)
                 in
                   (* This should be done by with_standard_output *)
                   MLWorks.IO.flush_out MLWorks.IO.std_out;
                   SOME (s,value)
                 end
                 handle _ => NONE)
             | _ => NONE)
d398 6
a403 2
        | SOME (item as UserContext.ITEM (_,_,_,res,src)) =>
            show_defn_fn auto (FileViewer.STRING src)
d407 5
a411 3
          (fn () => case get_current_value () of
             SOME x => (show_defn true; inspect_fn true x)
           | _ => ())
@


1.22
log
@Type of GuiUtils.view_option has changed.
@
text
@d4 3
a191 1
  structure Option = MLWorks.Option
d242 1
a242 1
      val curr_item = ref Option.NONE
d245 4
d253 1
a253 1
         curr_item := Option.SOME entry;
d277 4
a280 3
	of Option.NONE => ()
	|  Option.SOME x =>
	  UserContext.delete_from_history (get_user_context (), x)
d283 2
a284 1
        UserContext.remove_duplicates_from_history (get_user_context ())
d287 2
a288 1
        UserContext.delete_entire_history (get_user_context ())
d290 1
a290 1
      fun update_fn Option.NONE =
d292 1
a292 1
      |   update_fn (Option.SOME new_items) =
d313 1
a313 1
	  of Option.SOME w =>
d315 1
a315 1
	  |  Option.NONE => ();
d378 2
a379 2
          Option.NONE => Option.NONE
        | Option.SOME (item as UserContext.ITEM (_,id,context,_,src)) => 
d381 1
a381 1
               Option.SOME s =>
d392 1
a392 1
                   Option.SOME (s,value)
d394 2
a395 2
                 handle _ => Option.NONE)
             | _ => Option.NONE)
d406 2
a407 2
          Option.NONE => ()
        | Option.SOME (item as UserContext.ITEM (_,_,_,res,src)) =>
d413 1
a413 2
             Option.SOME x => (show_defn true;
			       inspect_fn true x)
d418 2
a419 2
	of Option.SOME _ => true
	|  Option.NONE => false
d424 4
a427 5
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME
		      (fn _ => Capi.clipboard_set (shell,!curr_string)),
             delete = Option.SOME delete_selection,
d445 1
a445 1
           inspect_fn = Option.SOME (inspect_fn false),
d498 1
a498 1
          MLWorks.Option.SOME w => [Capi.Layout.FIXED w]
@


1.21
log
@Replace Evaluator with File Viewer.
@
text
@d4 3
d363 1
a363 1
	   view_type = GuiUtils.SENSE_ONLY}
@


1.20
log
@Added File menu.
@
text
@d4 3
d137 1
a137 1
require "evaluator";
d146 1
a146 1
  structure Evaluator : EVALUATOR
d166 1
a166 1
  sharing type Menus.Widget = ToolData.Widget = Evaluator.Widget =
d175 1
a175 1
  sharing type InspectorTool.ToolData = ToolData.ToolData = Evaluator.ToolData
d387 4
a390 1
      val show_defn_fn = Evaluator.show_defn (shell, mk_tooldata())
d396 1
a396 1
            show_defn_fn auto (src, res)
@


1.19
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d4 3
d439 1
a439 7
	 GuiUtils.context_menu
	   {set_state = select_state,
	    get_context = fn _ => !local_context,
	    writable = GuiUtils.WRITABLE,
	    applicationShell = applicationShell,
	    shell = shell,
	    user_preferences = user_preferences},
d442 24
d467 1
a467 2
        [ToolData.works_menu
           (mk_tooldata, close_window, fn _ => true, get_user_context),
d470 2
a471 1
             Menus.CASCADE ("view", view_options, fn _ => true) :: menu_tail
@


1.18
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d410 1
@


1.17
log
@Added ability to delete entries.
@
text
@d4 3
d201 1
a201 1
            | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
d367 1
a367 1
                   MLWorks.IO.flush_out std_out;
@


1.16
log
@Disabled show_defn menu entry when no item selected.
@
text
@d4 3
d216 5
d251 18
a268 2
      fun update_fn new_items =
        add_items(get_print_options ()) (rev new_items)
d286 1
a286 1
	  of MLWorks.Option.SOME w =>
d288 1
a288 1
	  |  MLWorks.Option.NONE => ();
d387 25
d422 1
a422 4
		 fn _ => 
		   case get_current_value ()
		   of Option.SOME _ => true
		   |  Option.NONE => false)]}
d438 1
a438 9
         ToolData.edit_menu
           (shell,
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME
		      (fn _ => Capi.clipboard_set (shell,!curr_string)),
             delete = Option.NONE,
             selection_made = fn _ => !curr_string <> "",
	     tail = []})]
@


1.15
log
@Added "output-only" evaluator to display source and result of selected entry
@
text
@d4 3
d371 6
a376 1
                ("show_defn", fn _ => show_defn false, fn _ => true)]}
@


1.14
log
@Removed redundant function definition.
@
text
@d4 3
d116 1
d125 1
d145 1
a145 1
  sharing type Menus.Widget = ToolData.Widget =
d154 1
a154 1
  sharing type InspectorTool.ToolData = ToolData.ToolData
d345 8
d355 4
a358 3
        (fn () => case get_current_value () of
         Option.SOME x => inspect_fn true x
       | _ => ())
d366 3
a368 1
	   tail = []}
d385 8
a392 7
         (shell,
          {cut = Option.NONE,
           paste = Option.NONE,
           copy = Option.SOME (fn _ => Capi.clipboard_set (shell,!curr_string)),
           delete = Option.NONE,
           selection_made = fn _ => !curr_string <> "",
	   tail = []})]
@


1.13
log
@Stopped the update from always selecting the newly updated item.
Capi.make_scrolllist now returns a record, with an add_items field.
Removed the old sensitivity code.
@
text
@d4 5
a225 3

      fun select (UserContext.ITEM (n, _, _, _, _)) =
	Capi.List.select_pos (list, n, false)
@


1.12
log
@Type of GuiUtils.value_menu has changed.
@
text
@d4 3
d203 1
d209 1
a209 2
         (!do_select_fn) ();
         UserContext.set_selected (get_user_context (), user_options, entry))
d211 1
a211 1
      val (winScroll, winList, set_items) =
d222 2
a223 3
      fun sense_select (UserContext.ITEM (n, _, _, _, _)) =
	(Capi.List.select_pos (winList, n, false);
	 Capi.List.set_bottom_pos (winList, n))
d227 1
a227 2
          val (_, _, hist, _) =
            UserContext.get_context_info user_context
d230 1
a230 4
          set_items(get_print_options ()) (rev hist);
	  case UserContext.get_selected (get_user_context (), user_options) of
            MLWorks.Option.NONE => ()
          | MLWorks.Option.SOME item => sense_select item
d233 2
a234 7
      val select_register_key =
        ref (UserContext.add_select_fn
	       (get_user_context (),
		(sense_select, fn () => user_options)))

      fun update_fn () =
        set_history_from_context (get_user_context ())
a250 2
          UserContext.remove_select_fn
            (old_user_context, !select_register_key);
d258 1
a258 4
            UserContext.add_update_fn (new_user_context, update_fn);
          select_register_key :=
            UserContext.add_select_fn
	      (new_user_context, (sense_select, fn () => user_options))
a283 2
	       UserContext.remove_select_fn
                 (user_context, !select_register_key);
a310 1
	   sensitivity = GuiUtils.SENSE_ALL,
d313 2
a314 5
      val view_menu =
        Menus.CASCADE ("view", view_options, fn _ => true)

      (* What this is doing is taking a history item (UserContext.Item) and evaluating it *)
      (* in the context contained in the item *)
d352 11
d373 5
a377 11
	   tail = []}),
         view_menu,
         value_menu,
	 GuiUtils.context_menu
	   {set_state = select_state,
	    get_context = fn _ => !local_context,
	    writable = GuiUtils.WRITABLE,
	    applicationShell = applicationShell,
	    shell = shell,
	    user_preferences = user_preferences},
         ToolData.windows_menu ()]
d388 1
a388 1
       [Capi.Layout.FLEX winScroll,
a390 3
      case UserContext.get_selected (get_user_context (), user_options)
      of MLWorks.Option.SOME item => sense_select item
      |  MLWorks.Option.NONE => ();
@


1.11
log
@Using Info.null_options in call to eval
@
text
@d4 3
d362 8
a369 4
      val value_menu = GuiUtils.value_menu (shell,
                                            user_preferences,
                                            Option.SOME (inspect_fn false),
                                            get_current_value)
d379 2
a380 1
           selection_made = fn _ => !curr_string <> ""}),
a388 1
	    search_opt = MLWorks.Option.NONE,
@


1.10
log
@Changing inspector interface.
@
text
@d4 3
d339 1
a339 1
                     Info.default_options
@


1.9
log
@Reordering top level menus.
@
text
@d4 3
d127 1
a127 1
	       GuiUtils.Widget = Capi.Widget
d193 1
d199 1
d333 1
a333 1
                 let
d345 1
d348 7
a354 9
      fun inspect_fn () = 
        case get_current_value () of
          Option.SOME (s,x) => InspectorTool.inspect_value false (s, x, mk_tooldata())
        | _ => ()

      fun get_value () = 
        case get_current_value () of
          Option.SOME (a,b) => Option.SOME b
        | _ => Option.NONE
d358 2
a359 2
                                            Option.SOME inspect_fn,
                                            get_value)
a399 1

@


1.8
log
@Changing interface to edit_menu
@
text
@d4 3
d91 3
d95 1
d104 2
d110 1
a110 1
  sharing ToolData.ShellTypes.Options = UserOptions.Options
d131 6
d145 2
d173 1
a173 1
          "Context History #" ^ p ("", n)
d189 1
d194 1
d320 36
a358 1
         ToolData.windows_menu (),
d367 1
d375 2
a376 1
	    user_preferences = user_preferences}]
@


1.7
log
@Adding windows menu
@
text
@d4 3
d306 6
a311 3
         {paste = Option.NONE,
          copy = Option.SOME (fn _ => !curr_string),
          delete = Option.NONE},
@


1.6
log
@Type of context_menu has changed.
@
text
@d4 3
d125 1
d168 1
d172 2
a173 1
        UserContext.set_selected (get_user_context (), user_options, entry)
d196 4
a199 4
          set_items (get_print_options ()) (rev hist);
	  case UserContext.get_selected (get_user_context (), user_options)
	  of MLWorks.Option.NONE => ()
	  |  MLWorks.Option.SOME item => sense_select item
d301 5
@


1.5
log
@Changing top level window initialization
@
text
@d4 3
d301 2
@


1.4
log
@Changing layout
@
text
@d4 3
d315 1
a315 2
      Capi.reveal shell;
      Capi.initialize shell
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
d304 1
a304 1
          MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
d306 1
a306 1
       [Capi.Layout.OTHER winScroll,
d312 2
a313 2
      Capi.manage shell;
      Capi.realize shell
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d298 2
a299 1
      ([Capi.Layout.MENUBAR menuBar] @@
@


1.1
log
@new unit
New unit
@
text
@d4 4
d65 2
a66 2
require "../library/capi";
require "../library/menus";
@
