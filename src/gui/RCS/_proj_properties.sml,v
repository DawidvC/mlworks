head	1.38;
access;
symbols
	MLW_daveb_inline_1_4_99:1.36.1
	MLWorks_21c0_1999_03_25:1.36
	MLWorks_20c1_1998_08_20:1.28
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.20
	MLWorks_20b2_Windows_1998_06_12:1.18
	MLWorks_20b1c1_1998_05_07:1.14
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_workspace_97:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	99.04.30.16.17.07;	author johnh;	state Exp;
branches;
next	1.37;

1.37
date	99.04.29.16.01.08;	author johnh;	state Exp;
branches;
next	1.36;

1.36
date	99.03.18.12.05.06;	author daveb;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	99.03.18.10.19.55;	author mitchell;	state Exp;
branches;
next	1.34;

1.34
date	99.02.03.23.15.21;	author mitchell;	state Exp;
branches;
next	1.33;

1.33
date	99.02.02.15.59.29;	author mitchell;	state Exp;
branches;
next	1.32;

1.32
date	98.12.15.14.22.51;	author johnh;	state Exp;
branches;
next	1.31;

1.31
date	98.12.09.15.26.30;	author johnh;	state Exp;
branches;
next	1.30;

1.30
date	98.12.08.16.38.01;	author johnh;	state Exp;
branches;
next	1.29;

1.29
date	98.11.24.11.18.05;	author johnh;	state Exp;
branches;
next	1.28;

1.28
date	98.08.19.13.12.27;	author mitchell;	state Exp;
branches;
next	1.27;

1.27
date	98.08.17.10.58.11;	author mitchell;	state Exp;
branches;
next	1.26;

1.26
date	98.08.14.14.00.55;	author johnh;	state Exp;
branches;
next	1.25;

1.25
date	98.08.13.12.34.11;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	98.08.13.12.28.07;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	98.07.31.11.41.20;	author mitchell;	state Exp;
branches;
next	1.22;

1.22
date	98.07.29.14.01.47;	author johnh;	state Exp;
branches;
next	1.21;

1.21
date	98.07.03.09.42.03;	author johnh;	state Exp;
branches;
next	1.20;

1.20
date	98.06.17.15.53.21;	author johnh;	state Exp;
branches;
next	1.19;

1.19
date	98.06.16.11.18.39;	author mitchell;	state Exp;
branches;
next	1.18;

1.18
date	98.06.09.13.22.18;	author mitchell;	state Exp;
branches;
next	1.17;

1.17
date	98.06.08.12.20.08;	author mitchell;	state Exp;
branches;
next	1.16;

1.16
date	98.06.01.16.01.36;	author johnh;	state Exp;
branches;
next	1.15;

1.15
date	98.05.14.14.57.58;	author johnh;	state Exp;
branches;
next	1.14;

1.14
date	98.05.01.12.40.48;	author mitchell;	state Exp;
branches;
next	1.13;

1.13
date	98.04.30.11.46.22;	author johnh;	state Exp;
branches;
next	1.12;

1.12
date	98.04.24.14.40.36;	author jkbrook;	state Exp;
branches;
next	1.11;

1.11
date	98.04.22.16.37.38;	author mitchell;	state Exp;
branches;
next	1.10;

1.10
date	98.04.22.10.23.54;	author johnh;	state Exp;
branches;
next	1.9;

1.9
date	98.03.31.16.23.42;	author johnh;	state Exp;
branches;
next	1.8;

1.8
date	98.03.17.11.12.20;	author johnh;	state Exp;
branches;
next	1.7;

1.7
date	98.03.12.16.48.58;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	98.02.26.11.16.46;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	98.02.19.19.51.41;	author mitchell;	state Exp;
branches;
next	1.4;

1.4
date	98.02.17.17.56.14;	author johnh;	state Exp;
branches;
next	1.3;

1.3
date	98.02.06.16.51.30;	author johnh;	state Exp;
branches;
next	1.2;

1.2
date	98.02.06.15.55.48;	author johnh;	state Exp;
branches;
next	1.1;

1.1
date	97.09.12.10.32.35;	author johnh;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	97.09.12.10.32.36;	author johnh;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	97.09.12.14.21.47;	author johnh;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	97.11.03.15.57.46;	author johnh;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	97.11.04.10.14.37;	author daveb;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	97.11.11.11.23.38;	author johnh;	state Exp;
branches;
next	1.1.1.6;

1.1.1.6
date	97.11.18.17.36.55;	author daveb;	state Exp;
branches;
next	1.1.1.7;

1.1.1.7
date	97.11.19.11.25.06;	author johnh;	state Exp;
branches;
next	1.1.1.8;

1.1.1.8
date	97.12.01.11.16.18;	author daveb;	state Exp;
branches;
next	1.1.1.9;

1.1.1.9
date	97.12.01.13.22.48;	author johnh;	state Exp;
branches;
next	1.1.1.10;

1.1.1.10
date	97.12.01.15.18.30;	author johnh;	state Exp;
branches;
next	1.1.1.11;

1.1.1.11
date	97.12.02.16.38.38;	author johnh;	state Exp;
branches;
next	1.1.1.12;

1.1.1.12
date	97.12.12.11.09.54;	author johnh;	state Exp;
branches;
next	1.1.1.13;

1.1.1.13
date	98.01.06.15.01.46;	author johnh;	state Exp;
branches;
next	1.1.1.14;

1.1.1.14
date	98.01.09.11.55.46;	author johnh;	state Exp;
branches;
next	1.1.1.15;

1.1.1.15
date	98.01.12.15.15.56;	author johnh;	state Exp;
branches;
next	1.1.1.16;

1.1.1.16
date	98.01.21.14.03.02;	author johnh;	state Exp;
branches;
next	;

1.36.1.1
date	99.04.01.17.55.23;	author daveb;	state Exp;
branches;
next	;


desc
@new file on MLWorks_workspace_97
@


1.38
log
@[Bug #190552]
Change new_project to return success or failure.
@
text
@(*
 * $Log: _proj_properties.sml,v $
 * Revision 1.37  1999/04/29  16:01:08  johnh
 * [Bug #190557]
 * reset project so that units are displayed in PW when project first opened.
 *
 * Revision 1.36  1999/03/18  12:05:06  daveb
 * [Bug #190521]
 * OS.FileSys.readDir now returns an option type.
 *
 * Revision 1.35  1999/03/18  10:19:55  mitchell
 * [Bug #190534]
 * Ensure projects created by Shell.Project have Debug and Release modes as default
 *
 * Revision 1.34  1999/02/03  23:15:21  mitchell
 * [Bug #50108]
 * Change ModuleId from an equality type
 *
 * Revision 1.33  1999/02/02  15:59:29  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
 * Revision 1.32  1998/12/15  14:22:51  johnh
 * [Bug #190497]
 * Make sure setConfigurations is done before setCurrentConfiguration.
 *
 * Revision 1.31  1998/12/09  15:26:30  johnh
 * [Bug #70240]
 * Remove confiugration files from project unit list when changing current configuration.
 *
 * Revision 1.30  1998/12/08  16:38:01  johnh
 * [Bug #190494]
 * Check for duplicate module ids when adding new files and changing configurations.
 *
 * Revision 1.29  1998/11/24  11:18:05  johnh
 * [Bug #70214]
 * add check to save changes when properties dialogs close.
 *
 * Revision 1.28  1998/08/19  13:12:27  mitchell
 * [Bug #30482]
 * Clear units when opening a new project
 *
 * Revision 1.27  1998/08/17  10:58:11  mitchell
 * [Bug #30474]
 * Replace orig_proj reference by a project stack for subprojects
 *
 * Revision 1.26  1998/08/14  14:00:55  johnh
 * [Bug #50102]
 * reset dialogs if no changes made by user so that dialogs are kept up to date with ProjFile.
 *
 * Revision 1.25  1998/08/13  12:34:11  jont
 * [Bug #30468]
 * Change types of mkAbsolute and mkRelative to uses records with names fields
 *
 * Revision 1.24  1998/08/13  12:28:07  jont
 * Automatic checkin:
 * changed attribute _comment to ' * '
 *
 * Revision 1.23  1998/07/31  11:41:20  mitchell
 * [Bug #30440]
 * Modify test_save to optionally allow cancel
 *
 * Revision 1.22  1998/07/29  14:01:47  johnh
 * [Bug #30453]
 * Check for a new target being in the list of files.
 *
 * Revision 1.21  1998/07/03  09:42:03  johnh
 * [Bug #50088]
 * Fix SysErr exception problem when adding files from directory.
 *
 * Revision 1.20  1998/06/17  15:53:21  johnh
 * [Bug #30423]
 * remove units for a new project.
 *
 * Revision 1.19  1998/06/16  11:18:39  mitchell
 * [Bug #30422]
 * Prompt for working directory when creating a new project
 *
 * Revision 1.18  1998/06/09  13:22:18  mitchell
 * [Bug #30405]
 * Fix update of display when configuration changes
 *
 * Revision 1.17  1998/06/08  12:20:08  mitchell
 * [Bug #30418]
 * Handle broken project files gracefully
 *
 * Revision 1.16  1998/06/01  16:01:36  johnh
 * [Bug #30369]
 * Replace source path with a list of files.
 *
 * Revision 1.15  1998/05/14  14:57:58  johnh
 * [Bug #30384]
 * Fix test_save.
 *
 * Revision 1.14  1998/05/01  12:40:48  mitchell
 * [Bug #50071]
 * setCurrentConfiguration now takes an option
 *
 * Revision 1.13  1998/04/30  11:46:22  johnh
 * [Bug #30407]
 * Temporarily remove target type.
 *
 * Revision 1.12  1998/04/24  14:40:36  jkbrook
 * [Bug #30376]
 * Change default mode to Release so that our distributed objects
 * can be found
 *
 * Revision 1.11  1998/04/22  16:37:38  mitchell
 * [Bug #70095]
 * Check for bogus characters in modes and configurations
 *
 * Revision 1.10  1998/04/22  10:23:54  johnh
 * [Bug #50073]
 * Give warning when saving new project or saving project in different place.
 *
 * Revision 1.9  1998/03/31  16:23:42  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos().
 *
 * Revision 1.8  1998/03/17  11:12:20  johnh
 * [Bug #30365]
 * Fix warning.
 *
 * Revision 1.7  1998/03/12  16:48:58  johnh
 * [Bug #30365]
 * No need for per-target modes or configurations now that subprojects are here.
 *
 * Revision 1.6  1998/02/26  11:16:46  johnh
 * [Bug #30362]
 * Setting current mode changes object file location.
 *
 * Revision 1.5  1998/02/19  19:51:41  mitchell
 * [Bug #30337]
 * Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
 *
 * Revision 1.4  1998/02/17  17:56:14  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.3  1998/02/06  16:51:30  johnh
 * [Bug #30071]
 * Fixing require bug.
 *
 * Revision 1.2  1998/02/06  15:55:48  johnh
 * new unit
 * [Bug #30071]
 * Project Properties of the new Project Workspace tool.
 *
 *  Revision 1.1.1.16  1998/01/21  14:03:02  johnh
 *  [Bug #30071]
 *  Introducing subprojects.
 *
 *  Revision 1.1.1.15  1998/01/12  15:15:56  johnh
 *  [Bug #30071]
 *  Split locations dialog in two.
 *
 *  Revision 1.1.1.14  1998/01/09  11:55:46  johnh
 *  [Bug #30071]
 *  Add directory location for modes.
 *  Remove objects location from configurations.
 *
 *  Revision 1.1.1.13  1998/01/06  15:01:46  johnh
 *  [Bug #30071]
 *  Fix problems with setting library path.
 *
 *  Revision 1.1.1.12  1997/12/12  11:09:54  johnh
 *  [Bug #30071]
 *  Add save_project_as
 *  when properties dialog closes, set focus to project workspace.
 *
 *  Revision 1.1.1.11  1997/12/02  16:38:38  johnh
 *  [Bug #30071]
 *  Fixed mk_path_dialog so that the relative paths radio button has a unique action id.
 *
 *  Revision 1.1.1.10  1997/12/01  15:18:30  johnh
 *  [Bug #30071]
 *  Use ProfFile.getProjectName returning SOME "" to mean new project created.
 *
 *  Revision 1.1.1.9  1997/12/01  13:22:48  johnh
 *  [Bug #30071]
 *  Comment out any reference to binaries for the time being.
 *
 *  Revision 1.1.1.8  1997/12/01  11:16:18  daveb
 *  [Bug #30071]
 *  ProjFile.getProjectName now returns an option.
 *  Use ProjFile.getProjectDir instead of getBasePath.
 *
 *  Revision 1.1.1.7  1997/11/19  11:25:06  johnh
 *  [Bug #30071]
 *  Further improvements.
 *
 *  Revision 1.1.1.6  1997/11/18  17:36:55  daveb
 *  [Bug #30071]
 *  Make targets be just the file name.
 *  Also replaced use of Path by OS.Path.
 *
 *  Revision 1.1.1.5  1997/11/11  11:23:38  johnh
 *  [Bug #30071]
 *  Make further improvements.
 *  Current mode and config added, improved save/load.
 *
 *  Revision 1.1.1.4  1997/11/04  10:14:37  daveb
 *  [Bug #30071]
 *  Added support for current configurations, modes and targets.
 *
 *  Revision 1.1.1.3  1997/11/03  15:57:46  johnh
 *  [Bug #30071]
 *   Continuing work for Project Workspace - adding option for storing relative pathnames
 *
 *  Revision 1.1.1.2  1997/09/12  14:21:47  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
 *
 * 
 * Copyright (C) 1997.  The Harlequin Group Limited.  All rights reserved.
 *
 *)

require "../utils/__lists";
require "../basis/__char";
require "../basis/__string";

require "../basis/list";
require "../basis/os";
require "../basics/module_id";
require "../main/machspec";
require "../main/info";
require "../main/toplevel";
require "../main/proj_file";
require "../main/project";

require "../interpreter/incremental";

require "capi";
require "menus";
require "proj_properties";

functor ProjProperties (
  structure List: LIST
  structure MachSpec: MACHSPEC
  structure Info: INFO
  structure TopLevel: TOPLEVEL
  structure Capi: CAPI
  structure Menus: MENUS
  structure ProjFile: PROJ_FILE
  structure OS: OS
  structure Incremental: INCREMENTAL
  structure ModuleId: MODULE_ID
  structure Project: PROJECT

  sharing type Capi.Widget = Menus.Widget
  sharing type Info.Location.T = ProjFile.location = ModuleId.Location
  sharing type Info.options = ProjFile.error_info
  sharing type Incremental.InterMake.Project = Project.Project
  sharing type Incremental.ModuleId = Project.ModuleId = ModuleId.ModuleId
): PROJ_PROPERTIES = 
struct
  structure Options = TopLevel.Options

  type Widget = Capi.Widget

  type targetType = ProjFile.target_type
  type mode_details = ProjFile.mode_details
  type config_details = ProjFile.config_details

  (* parse_name removes leading and trailing spaces from the input *)
  fun parse_name(widget, parent) =
      let val name = Capi.Text.get_string widget
       in case String.tokens Char.isSpace name of
            [] => (Capi.Text.set_string (widget, ""); "")
          | [s] => 
              if List.length(String.fields Char.isCntrl s) <> 1 then
                (Capi.send_message (parent, 
                  "String contains illegal characters: '" ^ (String.toString name) ^ "'");
                 "")
              else s
          | _ =>
              (Capi.send_message (parent, 
                "String contains multiple tokens: '" ^ (String.toString name) ^ "'");
               "")
      end

  fun renumber_up (s, n) = (s, n + 1)
  fun renumber_down (s, n) = (s, n - 1)

  val need_saved = ref false
  val proj_stack = ref []

  fun confirm_save parent = 
    case ProjFile.getProjectName()
    of SOME "" => 
      (Capi.send_message (parent, "Not saved"); 
       false) 
    | SOME file =>
      (Capi.send_message (parent, "Saved project to " ^ file);
       need_saved := false;
       true)
    | NONE => false

  (* There is some checking here to warn the user that relative path names
   * specified in the project will become invalid if they save the project
   * to a different directory.
   *)
  fun save_project_as parent = 
    let 
      val old_dir = ProjFile.getProjectDir()
      val saved_cwd = OS.FileSys.getDir()
      val _ = OS.FileSys.chDir old_dir
      val filename = Capi.save_as_dialog (parent, ".mlp")
      val _ = OS.FileSys.chDir saved_cwd
      fun not_saved () = 
	(Capi.send_message (parent, "Project not saved");
	 false)
    in
      case filename of 
	SOME file => 
	  let
	    val new_dir = OS.Path.dir file
	    val continue = 
	      if (OS.Path.mkCanonical(new_dir) <> OS.Path.mkCanonical(old_dir)) then 
	        Capi.makeYesNoCancel (parent, 
                  "Any relative paths specified in the project will become invalid.  Continue saving?", false) ()
	      else
	        SOME true 
	  in
	    case continue of
	      SOME true => 
	        (ProjFile.save_proj file;
	         confirm_save parent)
	    | SOME false => (* user clicked 'no' *)
		not_saved()
	    | NONE => 	    (* user clicked 'cancel' - not applicable in this case *)
		not_saved()		
	  end
      | NONE => not_saved()
    end 

  fun save_project parent = 
    case ProjFile.getProjectName()
    of SOME "" => save_project_as parent
    |  SOME file =>
      (ProjFile.save_proj file;
       confirm_save parent)
    |  NONE =>
      (Capi.send_message (parent, "Error getting project name - project not saved");
       false)

  (* returns false if the user clicks cancel either when asked to save or 
   * when asked for a filename to save to *)
  fun test_save (parent, cancel) = 
    if (!need_saved) then
      let 
        val askSave =
	  Capi.makeYesNoCancel (parent, "Save the current project?", cancel)
	val answer = askSave()
	val yesOrNo = isSome answer
      in 
        if yesOrNo then 
	  if valOf(answer) then 
	    if (save_project parent) then 
	      (need_saved := false; (* needed when test_save called from outside *)
	       true)
	     else false
	  else true
	else false
      end
    else 
      true

  fun new_project parent = 
    if test_save (parent, true) then 
      case Capi.open_dir_dialog parent of
        NONE => false
      | SOME dir =>
          (need_saved := false;
           ProjFile.new_proj dir;
	   Incremental.reset_project();
           proj_stack := [];
           ProjFile.setInitialModes();
           ProjFile.setCurrentMode
	     (Info.make_default_options (),
	      Info.Location.FILE "Project Properties")
	     "Release";
	   true)
    else false

  fun open_project parent open_ok = 
    if test_save (parent, true) then 
      let 
	val files = Capi.open_file_dialog (parent, ".mlp", false)
      in
        if isSome(files) then 
	  (ProjFile.new_proj "";  (* needed here so that projectName <> NONE 
				    * otherwise a dialog will pop up asking the 
				    * user to create a new project or open one. *)
           Incremental.reset_project();
	   ignore(open_ok());
           let val selected_proj = OS.Path.mkCanonical (hd(valOf(files)))
               fun find [] = []
                 | find (h::t) = if h = selected_proj then t else find t
            in ProjFile.open_proj selected_proj;
               Incremental.reset_project();
               proj_stack := find (!proj_stack) 
           end
             handle ProjFile.InvalidProjectFile s => 
                      (Capi.send_message (parent, 
                         "Error in project file: " ^ s); ());
	   need_saved := false;
	   true)
	else false
      end
    else false

  local 
    fun apply_changes (shell, title, changed) = 
      if changed then 
	getOpt (Capi.makeYesNoCancel (shell, title, false)(), false)
      else 
	false

    fun get_file shell =
      case Capi.open_file_dialog (shell, ".sml", false) of
	 SOME s => OS.Path.mkCanonical (hd(s))
      |  NONE => ""

    fun get_files shell = 
      case Capi.open_file_dialog (shell, ".sml", true) of
	SOME f => map OS.Path.mkCanonical f
      | NONE => []

    datatype dirExist = MAY_EXIST | MUST_EXIST

    fun get_directory (shell, exist) =
      let 
	val dirOpt = 
	  if (exist = MUST_EXIST) then 
	    Capi.open_dir_dialog shell
	  else
	    Capi.set_dir_dialog shell
      in
	case dirOpt of 
           SOME s => OS.Path.mkCanonical s
        |  NONE => ""
      end

    fun list2str [] = ""
      | list2str (h::t) = h ^ "; " ^ list2str t

    fun number_entries ([], _) = []
      | number_entries (h::t, n) = (h, n) :: number_entries (t, n + 1)
    
    fun duplicate_mod_ids [] ids = NONE
      | duplicate_mod_ids (a::rest) ids =
	let 
	  val filen = OS.Path.file a
	  val id = ModuleId.from_host (filen, Info.Location.FILE "Project Properties")
	in
	  if (List.exists (fn id' => ModuleId.eq(id,id')) ids) then (SOME filen)
	  else duplicate_mod_ids rest (id :: ids)
	end

    fun duplicate_id (shell, f) = 
      Capi.send_message (shell, "No duplicate filenames allowed. <" ^ f ^ "> already exists")

    exception PW_Find
    fun find_nth n [] = raise PW_Find
      | find_nth n' ((h as (s, n))::t) = 
          if n = n' then (s,n) else find_nth n' t

    (* is_in, get_position, and moveup functions operate on lists of tuples of
     * type (string * int).  The items in the list are numerically ordered *)

    fun is_in (n:string, []) = false
      | is_in (n, (n', _)::t) = n = n' orelse is_in (n, t)
	infix is_in

    fun get_position (s, []) = 0
      | get_position (s, (s', n) :: rest) = 
          if s = s' then n
           else get_position (s, rest)

    (* moveup: moves the given tuple item one place up the list *)
    fun moveup (s,n) [] = []
      | moveup (s,n) (h::t) = 
         if (s = #1 h) then
           (s,n - 1)::(moveup (s,n) t)
         else
           if (n - 1 = #2 h) then
    	     (#1 h, n)::(moveup (s,n) t)
           else 
    	     h::(moveup (s,n) t)

    fun remove_nth ([], _) = []
      | remove_nth (h::t, n) =
        if n = #2 h then
          map renumber_down t
        else
          h :: remove_nth (t, n)

    (* moveup:  function for moving an item in a listbox. 
     * The function takes the item to be moved up, the list of items, a 
     * selection reference, and the (dec/inc)rement of the move.
     *)
    fun move (s,n) item_list (sel, changed) inc = 
      if ((s,n) <> ("",0) andalso (n > 1) andalso (item_list <> [])) then
        let 
          val result = moveup (s,n) item_list 
          val (name, pos) = valOf(!sel)
        in
          sel := SOME (find_nth (pos + inc) result);
	  changed := true;
          result
        end
      else item_list

    (* removeSelCB:  generalised function for removing a selection from a listbox.
     * The function takes the selection reference, the items list reference, and 
     * an update function for redisplaying the list and any other redisplay that may
     * be necessary.
     *)
    fun removeSelCB (sel, items, changed) updateFn =
      if isSome (!sel) then 
        let 
          val (name, pos) = valOf(!sel)
          val new_items = remove_nth (!items, pos)
        in
          if new_items = [] then 
            sel := NONE
          else 
            sel := SOME (find_nth pos new_items)
	  handle PW_Find => sel := SOME (find_nth 1 new_items);
	  changed := true;
          updateFn new_items
        end
      else ()

    fun moveUpCB (sel_ref, items_ref, changed) update_fn = 
      if (isSome (!sel_ref)) then 
	 update_fn (move (valOf (!sel_ref)) (!items_ref) (sel_ref, changed) (~1))
      else ()

    fun moveDownCB (sel_ref, items_ref, changed) update_fn = 
      if (isSome (!sel_ref)) then
        let 
          val item_below = find_nth (#2 (valOf (!sel_ref)) + 1) (!items_ref)
    			handle PW_Find => ("",0)
          val new_items = move item_below (!items_ref) (sel_ref, changed) 1
        in
          update_fn new_items
        end
      else ()

    (* select_fn:  function that is called when a selection is made in a listbox. *)
    fun select_fn store _ (s,n) = store := SOME (s,n)

    fun print_fn _ (s,_) = s
    fun action_fn _ _ = ()

    (* mk_list:  general function for creating a listbox control.
     *  Takes a tuple of parent shell, and name of listbox followed by curried args 
     *  of the selection reference, a function reference (+), and the item list 
     *	reference.  The function returns the list widget, and an update function 
     *  which can be called to update the display of the listbox control.
     * The passed update function is called when the user selects an item in the 
     * list and also when the returned update function is called. 
     *)
    fun mk_list (parent, name) sel_ref update_ref items_ref = 
      let
        fun selectFn opts (s,n) = (select_fn sel_ref opts (s,n); (!update_ref)())

        val {scroll, list, set_items, add_items} =
          Capi.make_scrolllist
    			{parent = parent,
    			 name = name,
    			 select_fn = selectFn,
    			 action_fn = action_fn,
    			 print_fn = print_fn}

        fun update new_items = 
          (items_ref := Lists_.msort (fn ((a,b), (a',b')) => b < b') new_items;
           set_items Options.default_print_options (!items_ref);
           if isSome(!sel_ref) then
	     let 
		val pos = #2 (valOf (!sel_ref))
		val set_pos = if (pos > 2) then pos - 2 else 1
	     in
		Capi.List.select_pos (list, pos, false);
		Capi.List.set_pos (list, set_pos)
	     end
           else
             ();
           (!update_ref)())
      in
        (scroll, update)
      end

    fun mkCloseButtons {parent, apply, reset, close, changed} = 
      let 
	val closeRC = Capi.make_managed_widget 
				("closeRC", Capi.RowColumn, parent, [])

	(* Note that calling apply() has the effect of changing the result
	 * of calling changed().  Calling apply() before calling changed() 
	 * will result in changed() always returning false.
	 *)

	fun ok () = 
	  let val change = changed()
	  in
	    if apply() then 
	      (if change then need_saved := true else ();
	       close())
	    else ()
	  end

	fun cancel () = (reset(); close())

	fun apply_fn () = 
	  if changed() andalso apply() then 
	    need_saved := true
	  else ()

	val {update, ...} = 
	  Menus.make_buttons (closeRC, 
		[Menus.PUSH ("PWP_Ok",     ok,       fn _ => true),
		 Menus.PUSH ("PWP_Apply",  apply_fn, changed),
		 Menus.PUSH ("PWP_Reset",  reset,    changed),
		 Menus.PUSH ("PWP_Cancel", cancel,   fn _ => true)])
      in
	(closeRC, update)
      end

    fun toRel []              f = []
      | toRel ((a,pos)::rest) f = 
	let
	  val newPath =
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative {path=a, relativeTo=ProjFile.getProjectDir()})
	in
	  ignore(f (a, newPath));
	  (newPath, pos) :: (toRel rest f)
	end

    fun toAbs []              f = []
      | toAbs ((a,pos)::rest) f = 
	let 
	  val newPath =
	    OS.Path.mkCanonical
	      (OS.Path.mkAbsolute {path=a, relativeTo=ProjFile.getProjectDir()})
	in
	  ignore(f (a, newPath));
	  (newPath, pos) :: (toAbs rest f)
	end

    val noConfigSelStr = "No configuration selected"

  in

    (* mk_path_dialog:  creates a dialog which allows the user to construct a path.
     *  Takes the parent shell and two functions:
     * get: unit -> string list:  a function to display the initial path when the dialog
     * 				  is brought up.
     * set: string option * string list -> unit:  a function to set the path given 
     * 	    a new list of directories.  The string option is used in the case when 
     *	    the path dialog was created by the configurations dialog to display a 
     * 	    path belonging to a particular configuration.
     *)
    fun mk_path_dialog (parent, caller_id, get, set) = 
      let 
	val visible = ref false
	val pathChanged = ref false
	val relativePaths = ref false

	(* DO NOT change these strings (of caller_id) as they as also used 
	 * in app-defaults/MLWorks-labels and mswindows/__labelstrings.sml
	 *)
	(* caller_id is used as a label identifier below and is needed so 
	 * that with each call to mk_path_dialog, controls created using
	 * this label id can have unique action ids on Windows (see 
	 * Labelstrings for each entry associated with each caller_id)
	 *)
	val title = 
	  case caller_id of 
	     "config_lib" => "Configuration Library Path"
	   | "lib_path"   => "Set Library Path"
	   | _ => ""

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propFilesDialog", 
				title = title,
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val label = Capi.make_managed_widget 
				("PWP_propFilesLabel", Capi.Label, frame, [])

        val path_items = ref (number_entries (get(), 1))

	val dir_selection = 
	  ref (if !path_items = [] 
		then NONE 
		else SOME (find_nth 1 (!path_items)))

	(* This update function is called when set_new_path is called or when 
	 * a selection is made in the listbox control. 
	 *)
	val updatePathsRef = ref (fn () => ())

	val (scroll, set_new_path) = 
	  mk_list (frame, "file_list")
	    dir_selection updatePathsRef path_items

	fun addNewCB () = 
	  let 
	    val rawDir = get_directory (shell, MUST_EXIST)
	    val dir = 
	      if (!relativePaths) then 
		OS.Path.mkCanonical
		  (OS.Path.mkRelative {path=rawDir, relativeTo=ProjFile.getProjectDir ()})
	      else
		rawDir
	  in
	    if rawDir = "" orelse dir is_in !path_items then ()
	    else 
	      let
	        val new_path_items = 
		  (dir, 1) :: (map renumber_up (!path_items))
	      in
		dir_selection := SOME (dir, 1);
		pathChanged := true;
		set_new_path new_path_items		
	      end
	  end

	fun removeAllCB () = 
	  (dir_selection := NONE;
	   pathChanged := true;
	   set_new_path [])

	fun removeSel () = removeSelCB (dir_selection, path_items, pathChanged) set_new_path
	fun moveUp () = moveUpCB (dir_selection, path_items, pathChanged) set_new_path
	fun moveDown () = moveDownCB (dir_selection, path_items, pathChanged) set_new_path

	val removeRC = Capi.make_managed_widget 
				("PWP_removeRC", Capi.RowColumn, frame, [])

	val {update, ...} = 
	  Menus.make_buttons (removeRC, 
		[Menus.PUSH ("PWP_addButton", addNewCB, fn _ => true),
		 Menus.PUSH ("PWP_moveUp", moveUp, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWP_moveDown", moveDown, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWP_removeSel", removeSel, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWP_removeAll", removeAllCB, fn () => true)])

	fun getRel () = (!relativePaths)
	fun setRel b = 
	  if b then 
	    (relativePaths := true;
	     pathChanged := true;
	     path_items := toRel (!path_items) (fn _ => ());
	     set_new_path (!path_items))
	  else
	    (relativePaths := false;
	     pathChanged := true;
	     path_items := toAbs (!path_items) (fn _ => ());
	     set_new_path (!path_items))

	val relativeRC = Capi.make_managed_widget 
				("PWP_relativeRC", Capi.RowColumn, frame, [])

	(* Please note the comment at the start of this function
	 * about the caller_id string.
	 *)
	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
		[Menus.TOGGLE ("PWP_" ^ caller_id, getRel, setRel, fn _ => true)])


	(* title_ref is used not only to display the title of the path dialog, 
	 * but also to keep a record of which configuration the path information 
	 * belongs to.
	 *)
	val title_ref = ref ""


	(* In the function apply(), the set command must come after the change to
	 * the pathChanged reference.  This is needed when (at least) the path 
	 * dialog was created by the configurations dialog.  In that case, this set 
	 * command is bound to setConfigFiles which updates the configurations and
	 * this has the side effect that the applyReset function of this path dialog
	 * is called therefore causing the applyReset check to be made - see the end
	 * of this function.  During this applyReset call, this dialog is updated, 
	 * and therefore, strictly speaking the set_new_path call below is not 
	 * needed.  It should be kept though as it does no harm and guards against
	 * having to depend on the set call to do the update implicitly.
	 *)
	fun apply () = 
	  (pathChanged := false;
	   ignore(set (SOME (!title_ref), map #1 (!path_items)));
	   set_new_path (!path_items);
	   true)

	fun reset () = 
	  (path_items := number_entries (get(), 1);
	   dir_selection := NONE;
	   pathChanged := false;
	   set_new_path (!path_items))

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!pathChanged)}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FIXED relativeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FLEX scroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED removeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

	fun tempUpdatePaths () = 
	  (Capi.set_label_string (label, !title_ref);
	   update(); 
	   updateCloseButtons(); 
	   if (!path_items) <> [] then
	     relativePaths := OS.Path.isRelative (#1(hd(!path_items)))
	   else ();
	   updateRel())

    in 
      Capi.remove_menu menuBar;
      Capi.set_close_callback (frame, close);
      do_layout();

      updatePathsRef := tempUpdatePaths;
      reset();

      (* returns two functions:
       * update_fn: ((string list -> unit) -> string -> unit)
       *  This function takes a callerUpdate function (see mk_path_dialog call
       *    from ProjWorkspace), creates the path dialog, and returns a function
       *    which displays the dialog showing the correct label at the top 
       *    (ie. to indicate what the dialog is for).
       * apply_reset_fn: (unit -> unit)
       *  This function is used by ProjWorkspace and Podium for updating the 
       *    display of the properties dialogs to be consistent with both the 
       *    project workspace and the ProjFile info.
       *)
     ((fn getMiniTitle => 
	 (updatePathsRef := 
	    (fn () => 
		(title_ref := getMiniTitle();
	       	if ((!title_ref) = noConfigSelStr) then
		  (visible := false;
		   Capi.set_focus (Capi.parent shell);
		   Capi.hide shell)
	        else
	          tempUpdatePaths()));
    	  visible := true;
	  if not (!pathChanged) then reset() else ();
    	  set_new_path (!path_items);
    	  Capi.reveal frame;
    	  Capi.reveal shell;
    	  Capi.to_front shell)),
      fn () => 
	(if apply_changes(shell, "Apply changes in path dialog?", !pathChanged) then 
	   ignore(apply())
	 else ();
	 reset())
      )
    end

    fun mk_get_files_dialog (parent, caller_id, get, set) = 
      let 
	val visible = ref false
	val filesChanged = ref false
	val relativePaths = ref false

	val (title, configs) = 
	  case caller_id of 
	     "files"        => ("Project Properties - Common Files", false)
	   | "config_files" => ("Configuration Files", true)
	   | _ => ("", false)

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propFilesDialog", 
				title = title,
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val label = Capi.make_managed_widget 
				("PWF_propFilesLabel", Capi.Label, frame, [])

        val files = ref (number_entries (get(), 1))

	val file_selection = 
	  ref (if !files = [] 
		then NONE 
		else SOME (find_nth 1 (!files)))

	(* This update function is called when set_new_files is called or 
	 * when a selection is made in the listbox control. 
	 *)
	val updateFilesRef = ref (fn () => ())

	val (scroll, set_new_files) = 
	  mk_list (frame, "file_list")
	    file_selection updateFilesRef files

	fun addFromDirCB () = 
	  let 
	    val rawDir = get_directory (shell, MUST_EXIST)

	    val relFn = 
	      if (!relativePaths) then 
		fn f => OS.Path.mkCanonical
		  (OS.Path.mkRelative {path=f, relativeTo=ProjFile.getProjectDir ()})
	      else
		fn f => f

	    fun getFiles dirstream = 
	      case OS.FileSys.readDir dirstream
	      of NONE => []
	      |  SOME raw_f =>
                  let
		    val f = OS.Path.mkCanonical raw_f
	       
		    val ss = (String.extract(f, size(f) - 4, NONE) = ".sml"
			handle Subscript => false)
		  in
		    if ss then 
		      relFn(OS.Path.concat [rawDir, f]) :: (getFiles dirstream)
		    else 
		      getFiles dirstream
		  end

	    fun add_file (file_list, f) = 
	      if f is_in file_list then file_list
	      else
		(f, 1) :: (map renumber_up file_list)

	    fun do_add dirstream = 
	      let 
	        val new_files = getFiles dirstream
 		val new_file_list = Lists_.reducel add_file (!files, new_files)
	      in
		file_selection := SOME (find_nth 1 new_file_list);
		filesChanged := true;
		set_new_files new_file_list;
		OS.FileSys.closeDir dirstream
	      end

	  in
	    if rawDir <> "" then
	      do_add (OS.FileSys.openDir rawDir)
	    else
	      ()
	  end

	(* Allows user to select more than one file from the file dialog *)
	fun addFilesCB () = 
	  let
	    val new_files = get_files shell

	    val relFn = 
	      if (!relativePaths) then 
		fn f =>  (* OS.Path.mkCanonical *) 
		  (OS.Path.mkRelative {path=f, relativeTo=ProjFile.getProjectDir ()})
	      else
		fn f => f

	    fun add_file (file_list, f) = 
	      if f is_in file_list then file_list
	      else 
		(f, 1) :: (map renumber_up file_list)
	  in
	    if (new_files = []) then () 
	    else
	      let
		val new_file_list = 
		  Lists_.reducel (fn (l, f) => add_file (l, relFn f)) (!files, new_files)
	      in
	        file_selection := SOME (find_nth 1 new_file_list);
		filesChanged := true;
		set_new_files new_file_list
	      end
	  end


	fun removeAllCB () = 
	  (file_selection := NONE;
	   filesChanged := true;
	   set_new_files [])

	fun removeSel () = removeSelCB (file_selection, files, filesChanged) set_new_files

	val removeRC = Capi.make_managed_widget 
				("PWF_removeRC", Capi.RowColumn, frame, [])

	val {update, ...} = 
	  Menus.make_buttons (removeRC, 
		[Menus.PUSH ("PWF_addButton", addFromDirCB, fn _ => true),
		 Menus.PUSH ("PWF_addFiles", addFilesCB, fn _ => true),
		 Menus.PUSH ("PWF_removeSel", removeSel, fn () => isSome (!file_selection)),
		 Menus.PUSH ("PWF_removeAll", removeAllCB, fn () => true)])

	fun getRel () = (!relativePaths)
	fun setRel b = 
	  if b then 
	    (relativePaths := true;
	     filesChanged := true;
	     files := toRel (!files) (fn _ => ());
	     set_new_files (!files))
	  else
	    (relativePaths := false;
	     filesChanged := true;
	     files := toAbs (!files) (fn _ => ());
	     set_new_files (!files))

	val relativeRC = Capi.make_managed_widget 
				("PWF_relativeRC", Capi.RowColumn, frame, [])

	(* Please note the comment at the start of this function
	 * about the caller_id string.
	 *)
	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
		[Menus.TOGGLE ("PWP_" ^ caller_id, getRel, setRel, fn _ => true)])

	(* Used for storing the configuration name that these files belong to 
	 * as well as being used for the title of the listbox.
	 *)
	val title_ref = ref ""

	(* IMPORTANT - see comment for apply function in mk_path_dialog above. *)
	(* Also the set function here returns true if the update was not successful *)
	fun apply () = 
	  (filesChanged := false;
	   filesChanged := set (SOME (!title_ref), (map #1 (!files)));
	   set_new_files (!files);
	   true)

	fun reset () = 
	  (files := number_entries (get(), 1);
	   file_selection := NONE;
	   filesChanged := false;
	   set_new_files (!files))

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!filesChanged)}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FIXED relativeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FLEX scroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED removeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      fun tempUpdateFiles () =
	(Capi.set_label_string (label, !title_ref);
	 update(); 
	 updateCloseButtons(); 
	 if (!files) <> [] then
	   relativePaths := OS.Path.isRelative (#1(hd(!files)))
	 else ();
	 updateRel())

    in 
      Capi.remove_menu menuBar;
      Capi.set_close_callback (frame, close);
      do_layout();

      updateFilesRef := tempUpdateFiles;
      reset();

      (* returns two functions:
       * update_fn: ((string list -> unit) -> string -> unit)
       *  This function takes a callerUpdate function (see mk_path_dialog call
       *    from ProjWorkspace), creates the path dialog, and returns a function
       *    which displays the dialog showing the correct label at the top 
       *    (ie. to indicate what the dialog is for).
       * apply_reset_fn: (unit -> unit)
       *  This function is used by ProjWorkspace and Podium for updating the 
       *    display of the properties dialogs to be consistent with both the 
       *    project workspace and the ProjFile info.
       *)
     ((fn getTitle => 
	 (updateFilesRef := 
	    (fn () =>
	      (title_ref := getTitle();
	       if (getTitle() = noConfigSelStr) then
		 (visible := false;
		  Capi.set_focus (Capi.parent shell);
		  Capi.hide shell)
	       else
	         tempUpdateFiles()));
    	  visible := true;
	  if not (!filesChanged) then reset() else ();
	  set_new_files (!files);
    	  Capi.reveal frame;
    	  Capi.reveal shell;
    	  Capi.to_front shell)),
      fn () =>
	(if apply_changes (shell, "Apply changes in files dialog?", !filesChanged) then
	   ignore(apply())
	 else ();
	 reset())
      )
    end

    fun mk_files_dialog (parent, updateFiles: string list -> unit) = 
      let
	fun c_files () = 
	  let val (configs, c_details, curConfig) = ProjFile.getConfigurations()
	  in
	    case curConfig of 
	      NONE => []
	    | SOME c => #files (ProjFile.getConfigDetails (c, c_details))
	  end

	val (mk_new_files_dialog, applyResetFiles) = 
          mk_get_files_dialog (parent,
		       	  "files", 
	    		  ProjFile.getFiles,
			  fn (config_, newFiles) => 
			    case (duplicate_mod_ids (c_files() @@ newFiles) []) of
			      NONE =>
			        (ProjFile.setFiles newFiles;
			         updateFiles newFiles;
			         false)
			    | SOME f => 
				(duplicate_id (parent, f); 
				 true))

        fun files_dialog () = 
	  mk_new_files_dialog 
    	    (fn () => "List of files belonging to current project:")
      in
	(files_dialog, applyResetFiles)
      end

    fun mk_subprojects_dialog (parent, callerUpdate, updatePW) = 
      let
	val visible = ref false
	val subChange = ref false
	val subSel = ref NONE
	val subprojects = ref []
	val relSubproj = ref false

	fun isSel () = isSome(!subSel)

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propSubProjectsDialog", 
				title = "Project Properties - Subprojects", 
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val label = Capi.make_managed_widget 
				("PWS_subprojLabel", Capi.Label, frame, [])

	val updateSubsRef = ref (fn () => ())

	val (scroll, set_new_projs) = 
	  mk_list (frame, "proj_list")
	    subSel updateSubsRef subprojects

	fun apply () = 
	  (ProjFile.setSubprojects (map #1 (!subprojects));
	   ignore(callerUpdate (map #1 (!subprojects)));
	   subChange := false;
	   set_new_projs (!subprojects);
	   true)

	fun reset () = 
	  (subprojects := number_entries (ProjFile.getSubprojects(), 1);
	   subSel := NONE;
	   subChange := false;
	   set_new_projs (!subprojects))

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	fun addNewProj () = 
	  let 
	    val rawText = 
	      case Capi.open_file_dialog (shell, ".mlp", true) of
	         NONE => ""
	      |  SOME (a::rest) => OS.Path.mkCanonical a
	      |  SOME [] => ""

	    val file = 
	      if (!relSubproj) then 
		OS.Path.mkCanonical
		  (OS.Path.mkRelative {path=rawText, relativeTo=ProjFile.getProjectDir ()})
	      else
		rawText

	    fun isCurProj n = 
	      n = OS.Path.mkCanonical (valOf (ProjFile.getProjectName()))
	  in
	    if rawText = "" orelse file is_in !subprojects then ()
	    else 
	      if isSome (List.find isCurProj (ProjFile.getAllSubProjects rawText)) then 
		Capi.send_message(shell, 
			"Can't add subproject - results in circular reference")
	      else
	        let
	          val new_projects = 
		    (file, 1) :: (map renumber_up (!subprojects))
	        in
		  subSel := SOME (file, 1);
		  subChange := true;
		  set_new_projs new_projects		
	        end
	  end

	fun removeSel () = removeSelCB (subSel, subprojects, subChange) set_new_projs
	fun openProj' () = 
	  if test_save (shell, true) then
            let val sub_project = 
                    OS.Path.mkAbsolute{path= #1(valOf(!subSel)), 
                                       relativeTo=ProjFile.getProjectDir()}
                val parent_proj = ProjFile.getProjectName()
	    in 
              ProjFile.open_proj sub_project;
              case parent_proj of
                SOME "" => (* User declined to save new project *)
                  proj_stack := []
              | SOME s => 
                  proj_stack := (OS.Path.mkCanonical s) :: (!proj_stack)
              | NONE => proj_stack := [] (* Should never happen *);
              updatePW true;
	      need_saved := false
            end
	  else ()

	fun openProj () = 
	  (if (!subChange) then need_saved := true else ();
	   ignore(apply());
	   openProj'())

	val projRC = Capi.make_managed_widget 
				("PWS_projRC", Capi.RowColumn, frame, [])

	fun backProj' () = 
	  if test_save (shell, true) then
	    (case (!proj_stack) of
	       [] => (* This shouldn't happen *) ()
	     | h :: t => (ProjFile.open_proj h; proj_stack := t);
	     updatePW true)
	  else ()

	fun backProj () = 
	  (if (!subChange) then need_saved := true else ();
	   ignore(apply());
	   backProj'())

	fun backSens () = not(null(!proj_stack))

	val {update, ...} = 
	  Menus.make_buttons (projRC, 
		[Menus.PUSH ("PWS_addProj", addNewProj, fn _ => true),
		 Menus.PUSH ("PWS_removeProj", removeSel, isSel),
		 Menus.PUSH ("PWS_openProj", openProj, isSel),
		 Menus.PUSH ("PWS_backProj", backProj, backSens)])

	fun getRel () = (!relSubproj)
	fun setRel b = 
	  if b then 
	    (relSubproj := true;
	     subChange := true;
	     subprojects := toRel (!subprojects) (fn _ => ());
	     set_new_projs (!subprojects))
	  else
	    (relSubproj := false;
	     subChange := true;
	     subprojects := toAbs (!subprojects) (fn _ => ());
	     set_new_projs (!subprojects))

	val relProjRC = Capi.make_managed_widget 
				("PWS_relProjRC", Capi.RowColumn, frame, [])

	val {update = updateRel, ...} = 
	  Menus.make_buttons (relProjRC, 
		[Menus.TOGGLE ("PWS_relProj", getRel, setRel, fn _ => true)])

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!subChange)}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FIXED relProjRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FLEX scroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED projRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in 
        Capi.remove_menu menuBar;
        Capi.set_close_callback (frame, close);
        do_layout();

        updateSubsRef := 
	  (fn () => 
	    (update(); 
	     updateCloseButtons(); 
	     if (!subprojects) <> [] then
	       relSubproj := OS.Path.isRelative (#1(hd(!subprojects)))
	     else ();
	     updateRel()));

       ((fn () => 
	 (visible := true;
	  if not (!subChange) then reset() else ();
	  set_new_projs (!subprojects);
    	  Capi.reveal frame;
    	  Capi.reveal shell;
    	  Capi.to_front shell)),
	 fn () =>
	   if apply_changes (shell, "Apply changes in subprojects dialog?", !subChange) then
	     ignore(apply())
	   else
	     reset()
	)

      end (* mk_subprojects_dialog *)

    fun mk_targets_dialog (parent, callerUpdate) = 
      let 
	val visible = ref false
	val changed = ref false
	val curSel = ref NONE
	val disTargets = ref []
	val curTargets = ref []
	val targetDetails = ref []

	fun isCurSel () = isSome(!curSel)

	val disSel = ref NONE

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propTargetsDialog", 
				title = "Project Properties - Targets", 
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}
	val label = Capi.make_managed_widget 
				("PWT_targetsLabel", Capi.Label, frame, [])

	(* Rowcolumn widget which stores five buttons:
	 * addTarget for selecting a new (current) target to add to the list,
	 * moveUp for moving a target up the ordered list - to be built earlier.
	 * moveDown for moving a target down the build order.
	 * disable for disabling the selected target.
	 * reomveTarget for removing the selected target from the list.
	 *)
	val targetRC = Capi.make_managed_widget 
				("PWT_targetRC", Capi.RowColumn, frame, [])

	(* addDetails: takes a list of targets ((name, pos) tuples) and returns a
	 * list of the details of the specified targets.
	 * This is used to keep the targetDetails list consistent with the all the 
	 * targets (inc disabled ones) by:  targetDetails := addDetails <allTargets>;
	 *)
	fun addDetails [] = []
	  | addDetails ((name, p)::t) = 
	      let 
		val details = List.find (fn (n,_) => n=name) (!targetDetails)
	      in
		if isSome details then
		  valOf(details) :: (addDetails t)
		else
		  (name, ProjFile.OBJECT_FILE) :: (addDetails t)
	      end

	(* This update function is called whenever a selection of the current 
	 * targets is made - see end of mk_targets_dialog function where this 
	 * reference is set.
         *) 
	val updateTargetsRef = ref (fn () => ())

	(* List of all current targets *)
	val (curScroll, updateTargets) = 
	  mk_list (frame, "curList")
		   curSel 
		   updateTargetsRef
		   curTargets

	(* Modifies the details associated with the selected current target *)
	fun modifyTarget (name, tarType) = 
	  let 
	    val (name', t) = 
	      valOf (List.find (fn (n,_) => n=name) (!targetDetails))
	    val others = List.filter (fn (n,_) => n <> name) (!targetDetails);
	  in 
	    targetDetails := (name, tarType) :: others
	  end

	(* get_details:  get the details of the selected current target *)
	fun get_details () = 
	  let 
	    val name = #1 (valOf (!curSel))
	  in
	    ProjFile.getTargetDetails (name, !targetDetails)
	    handle ProjFile.NoTargetDetailsFound n => 
	      (Capi.send_message (shell, 
		 "Error in targets.  No details found for target: " ^ n);
	       (n, ProjFile.OBJECT_FILE))
	  end


	(* Adds a new target to the list of current targets if it isn't already 
	 * in the current targets OR in the disabled targets.
	 *)
	fun addTargetCB () = 
	  let 
	    val rawText = get_file shell
	    val text = OS.Path.file rawText

	    fun valid_target target = 
	      not (target is_in (!curTargets)) andalso
	      not (target is_in (!disTargets)) andalso
	      target <> ""

	    fun add_target target = 
	      let 
		val new = (target, 1) :: (map renumber_up (!curTargets))
	      in
		curSel := SOME (target, 1);
		changed := true;
		updateTargets new
	      end

	    val files = ProjFile.getFiles()

	    val (_, configDetails, currentConfig) = ProjFile.getConfigurations()
	    val cc_files = 
	      case currentConfig of 
		NONE => []
	      | SOME cc => #files (ProjFile.getConfigDetails (cc, configDetails))

	    fun modified_target file_list = 
	      case file_list of 
		[] => rawText
	      | (f::rest) => 
		  if OS.Path.isRelative(f) then 
		    OS.Path.mkRelative{path=rawText, relativeTo=ProjFile.getProjectDir()}
		  else rawText

	  in 
	    if valid_target(text) then
	      if (not (List.exists (fn t => t=modified_target(files)) files)) andalso
		 (not (List.exists (fn t => t=modified_target(cc_files)) cc_files)) then 
		Capi.send_message (shell, "Target " ^ rawText ^ 
					" not in list of ML files specified in this project")
	      else
		add_target text
	    else ()
	  end

	val disableLabel = Capi.make_managed_widget
				("PWT_disableLabel", Capi.Label, frame, [])

	local 
	  fun tarType () = 
	    if isCurSel() then 
	      SOME (#2 (get_details ()))
	    else NONE

	  fun setType whichType = 
	    if isCurSel() then 
	      let val (name, curType) = get_details()
	      in
		changed := true;
		modifyTarget (name, whichType);
		updateTargets (!curTargets)
	      end
	    else ()

	in
	  fun is_exe () = tarType() = SOME ProjFile.EXECUTABLE
	  fun is_dynlib () = tarType() = SOME ProjFile.LIBRARY
	  fun is_image () = tarType() = SOME ProjFile.IMAGE
	  fun is_objfile () = tarType() = SOME ProjFile.OBJECT_FILE

	  fun set_exe b = if b then setType ProjFile.EXECUTABLE else ()
	  fun set_dynlib b = if b then setType ProjFile.LIBRARY else ()
	  fun set_image b = if b then setType ProjFile.IMAGE else ()
	  fun set_objfile b = if b then setType ProjFile.OBJECT_FILE else ()
	end

(* TTT: temporarily removed

	val typesRC = Capi.make_managed_widget
				("PWT_typesRC", Capi.RowColumn, frame, [])

	val {update=updateTypes, ...} = 
	  Menus.make_buttons (typesRC, 
	    [Menus.RADIO ("PWT_exeRadio",    is_exe,    set_exe,     fn () => true),
	     Menus.RADIO ("PWT_dynlibRadio", is_dynlib, set_dynlib,  fn () => true),
	     Menus.RADIO ("PWT_imageRadio",  is_image,  set_image,   fn () => true),
	     Menus.RADIO ("PWT_objfileRadio",is_objfile,set_objfile, fn () => true)])
*)

	val updateDisabledRef = ref (fn () => ())

	(* updateDetails needs to be called by the select_fn as well as the 
	 * returned update function.
	 *)
	val (disScroll, updateDisabled) = 
	  mk_list (frame, "disList")
	    disSel updateDisabledRef disTargets

	(* Disables the selected current target - adds it to the list of 
	 * disabled targets and removes it from the list of current targets.
	 * The order of this operation is important - it must be added to the
	 * list first otherwise, during updating, the details of the target
	 * are lost.
	 *)
	fun disableCB () = 
	  if isCurSel() then 
	    let 
	      val (s,n) = valOf(!curSel)
	      val new_disabled = (s,1) :: (map renumber_up (!disTargets))
	    in
	      disSel := SOME (s,1);
	      updateDisabled new_disabled;
	      removeSelCB (curSel, curTargets, changed) updateTargets
	    end
	  else ()

	(* Enables the selected disabled target - adds it to the list of
	 * current targets and removes it from the list of current targets.
	 * The order of this operation is important - it must be added to the
	 * list first otherwise, during updating, the details of the target
	 * are lost.
	 *)
	fun enableCB () = 
	  if isSome(!disSel) then 
	    let 
	      val (s,n) = valOf(!disSel)
	      val new_enabled = (s,1) :: (map renumber_up (!curTargets))
	    in
	      curSel := SOME (s,1);
	      updateTargets new_enabled;
	      removeSelCB (disSel, disTargets, changed) updateDisabled
	    end
	  else ()

	val delTarget = 
	  Capi.makeYesNoCancel (shell, "Remove the selected target?", false)

	(* When removing a target, the selected disabled target (if any) is 
	 * deselected so that the user is clear as to which target is being 
	 * removed, ie. the selected CURRENT target.
	 *)
	fun removeTarget () = 
	  (disSel := NONE; 
	   updateDisabled (!disTargets);
	   if valOf(delTarget()) then 
	     (changed := true;
	     removeSelCB (curSel, curTargets, changed) updateTargets)
	   else ())

	fun moveUp () = moveUpCB (curSel, curTargets, changed) updateTargets
	fun moveDown () = moveDownCB (curSel, curTargets, changed) updateTargets

	val {update=updateTargetButtons, ...} = 
	  Menus.make_buttons (targetRC, 
		[Menus.PUSH ("PWT_addTarget", addTargetCB, fn _ => true),
		 Menus.PUSH ("PWT_moveUp", moveUp, isCurSel),
		 Menus.PUSH ("PWT_moveDown", moveDown, isCurSel),
		 Menus.PUSH ("PWT_disable", disableCB, isCurSel),
		 Menus.PUSH ("PWT_removeTarget", removeTarget, isCurSel)])

	val disableRC = Capi.make_managed_widget 
				("PWT_disableRC", Capi.RowColumn, frame, [])

	val {update=updateDisableButtons, ...} = 
	  Menus.make_buttons (disableRC, 
		[Menus.PUSH ("PWT_enableTarget", enableCB, fn _ => isSome(!disSel))])

(* TTT: temporarily removed
	val detailsLabel = Capi.make_managed_widget
				("PWT_detailsLabel", Capi.Label, frame, [])
	val typeLabel = Capi.make_managed_widget
				("PWT_typeLabel", Capi.Label, frame, [])
*)

	fun update () = 
	  (updateTargets (!curTargets);
	   updateDisabled (!disTargets))

	fun apply () =
	  let 
	    val cur = map #1 (!curTargets) and dis = map #1 (!disTargets)
	  in
	    ProjFile.setTargets(cur, dis, !targetDetails);
	    changed := false;
	    update();
	    ignore(callerUpdate cur);
	    true
	  end
	  handle ProjFile.InvalidTarget t => 
	    (Capi.send_message (shell, "Target " ^ t ^ " not specified in the list of files");
	     false)

	fun reset () = 
	  let 
	    val (current, disabled, details) = ProjFile.getTargets ()
	  in
	    curTargets := number_entries (current, 1);
	    disTargets := number_entries (disabled, 1);
	    targetDetails := details;
	    curSel := NONE;
	    disSel := NONE;
	    changed := false;
	    update()
	  end

	(* On closing the dialog, the selections in the listbox must be desselected,
	 * for the following reason:  if a NewProject command is given, the reference
	 * lists are reset, but the selection references are not as they are out of 
	 * scope, so when NewProject command is given, the dialogs are closed to 
	 * reset the selection references to avoid inconsistencies. 
	 *)
	fun close () = 
	  (reset ();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!changed)}

	(* Updates the display of the details of the selected current target *)
	fun updateDetails () = 
	  ((* TTT: temporarily removed
	   updateTypes();
	   *)
	   updateCloseButtons())

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX curScroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED targetRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED disableLabel,
		 Capi.Layout.FIXED disScroll,
		 Capi.Layout.FIXED disableRC,
		 Capi.Layout.SPACE,

(* TTT: temporarily removed 
		 Capi.Layout.FIXED detailsLabel,
		 Capi.Layout.FIXED typeLabel,
		 Capi.Layout.FIXED typesRC,
		 Capi.Layout.SPACE, 
*)
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in
	(* Steps in updating the targets (order not important):
	 * 1)	Keep targetDetails consistent with targets
	 * 2)	Update sensitivity of buttons applying to list of current targets
	 * 3)	Call the update function passed in by the caller
	 * 4)	Update buttons for changing the mode and configuration of a target
	 * 5)	Update the display of the details of the selected current target
	 *)
	updateTargetsRef := 
	  (fn () => (targetDetails := addDetails ((!curTargets) @@ (!disTargets));
		     updateTargetButtons();
		     updateDetails()));
	updateDisabledRef := 
	  (fn () => (updateDisableButtons();
		     updateCloseButtons()));

	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
 		  if not (!changed) then reset() else ();
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 fn () =>
	   if apply_changes (shell, "Apply changes in targets dialog?", !changed) then
	     ignore(apply())
	   else
	     reset()
	)
      end  (* mk_targets_dialog *)

    (* This caller update function isn't needed as in prop_config_dialog *)
    fun mk_modes_dialog (parent, callerUpdate) =
      let
	val modeSel = ref NONE
	val modeChanged = ref false
	val modes = ref []
	val modeDetails = ref ([]: mode_details list)
	val curMode = ref ""

	val visible = ref false
	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propModesDialog", 
				title = "Project Properties - Modes", 
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val label = Capi.make_managed_widget 
				("PWM_modeLabel", Capi.Label, frame, [])

	val curLabel = Capi.make_managed_widget
				("PWM_curLabel", Capi.Label, frame, [])

	fun initModeDetails modeName = 
	  {name 			= modeName, 
	   location			= ref modeName,  (* default of name of mode *)
	   generate_interruptable_code  = ref true,
	   generate_interceptable_code  = ref true,
	   generate_debug_info		= ref true,
	   generate_variable_debug_info = ref true,
	   optimize_leaf_fns		= ref false,
	   optimize_tail_calls		= ref false,
	   optimize_self_tail_calls	= ref false,
	   mips_r4000			= ref true,
	   sparc_v7			= ref false}

	fun get_mode_details () = 
	  let val name = #1 (valOf (!modeSel)) 
	  in
	    ProjFile.getModeDetails (#1 (valOf (!modeSel)), !modeDetails)
	    handle ProjFile.NoModeDetailsFound m =>
	      (Capi.send_message (shell, 
		 "Error in modes.  No details found for mode: " ^ m);
	       initModeDetails m)
	  end

	val modeList = 
	  [("PWM_genInterruptCode"),
	   ("PWM_genInterceptCode"),
	   ("PWM_genDebugInfo"),
	   ("PWM_genVarDebugInfo"),
	   ("PWM_optLeaf"),
	   ("PWM_optTail"),
	   ("PWM_optSelfTail")] @@ 
          (case MachSpec.mach_type of
             MachSpec.MIPS =>  [("PWM_mipsR4000")]
           | MachSpec.SPARC => [("PWM_sparcV7")]
           | MachSpec.I386 =>  [])

	fun getBoolRef s (r: mode_details) = 
	  case s of 
	     "PWM_genInterruptCode" 	=> #generate_interruptable_code r
           | "PWM_genInterceptCode" 	=> #generate_interceptable_code r
      	   | "PWM_genDebugInfo"		=> #generate_debug_info r
      	   | "PWM_genVarDebugInfo"	=> #generate_variable_debug_info r
    	   | "PWM_optLeaf"		=> #optimize_leaf_fns r
    	   | "PWM_optTail"		=> #optimize_tail_calls r
      	   | "PWM_optSelfTail"		=> #optimize_self_tail_calls r
       	   | "PWM_mipsR4000"		=> #mips_r4000 r
       	   | "PWM_sparcV7"		=> #sparc_v7 r
     	   | _ => ref false

	val updateModesRef = ref (fn () => ())

	val (modeScroll, updateModes) = 
	  mk_list (frame, "modeList")
	    modeSel updateModesRef modes

	fun modeGet s () = 
	  if isSome (!modeSel) then 
	    let val details = get_mode_details()
	    in !(getBoolRef s details)
	    end
	  else false

	fun modeSet s value = 
	  if isSome (!modeSel) then 
	    let val details = get_mode_details()
	    in
	      (getBoolRef s details) := value;
	      modeChanged := true;
	      updateModes (!modes)
	    end
	  else ()

	fun addModeDetails [] = []
	  | addModeDetails ((name, p)::t) = 
	    let 
	      val details = 
		List.find (fn {name=n,...} => name=n) (!modeDetails)
	    in
	      if isSome details then
		valOf(details) :: (addModeDetails t)
	      else
		(initModeDetails name) :: (addModeDetails t)
	    end

	fun create_opt s = 
	  let 
	    val detailsRC = Capi.make_managed_widget
				("PWM_detailsRC", Capi.RowColumn, frame, [])
	    val {update, ...} = 
	      Menus.make_buttons (detailsRC, 
		[Menus.TOGGLE (s, modeGet s, modeSet s, fn _ => true)])
	  in
	    (detailsRC, update)
	  end

	val details = map create_opt modeList

	fun updateModeDetails () = 
	  (modeDetails := addModeDetails (!modes);
	   app (fn a => (#2 a)()) details)

	val modesRC = Capi.make_managed_widget 
				("PWM_modesRC", Capi.RowColumn, frame, [])

	fun removeModeCB () =
	  removeSelCB (modeSel, modes, modeChanged) updateModes

	fun updateCurMode newCurMode = 
	  (curMode := newCurMode;
	   Capi.set_label_string(curLabel, "Current Mode:  " ^ newCurMode))

	fun setCurModeCB () =
	  let 
	    val (selection, pos) = getOpt(!modeSel, ("",0))
	  in
	    if (selection <> "") then 
	      (updateCurMode selection;
	       modeChanged := true;
	       updateModes (!modes))
	    else
	      Capi.beep parent
	  end

	val {update=updateModeButtons, ...} = 
	  Menus.make_buttons (modesRC, 
		[Menus.PUSH ("PWM_removeMode", removeModeCB, fn _ => isSome(!modeSel)),
		 Menus.PUSH ("PWM_setCurMode", setCurModeCB, fn _ => isSome(!modeSel))])

	val newMode = Capi.make_managed_widget
				("PWM_newMode", Capi.Text, frame, [])

	val addModeRC = Capi.make_managed_widget 
				("PWM_addModeRC", Capi.RowColumn, frame, [])

	fun addModeCB () = 
	  let 
	    val mode = parse_name (newMode, parent)
	  in 
	    if not (mode is_in (!modes)) andalso mode <> "" then 
	      let 
		val new_modes = (mode,1) :: (map renumber_up (!modes))
	      in
		modeSel := SOME (mode,1);
		Capi.Text.set_string (newMode, "");
		modeChanged := true;
		updateModes new_modes
	      end
	    else ()
	  end

	val {update, ...} = 
	  Menus.make_buttons (addModeRC, 
		[Menus.PUSH ("PWM_addMode", addModeCB, fn _ => true)])

	val locLabel = Capi.make_managed_widget
				("PWM_locLabel", Capi.Label, frame, [])
	val locText = Capi.make_managed_widget
				("PWM_locText", Capi.Text, frame, [])

	val locChangeRC = Capi.make_managed_widget
				("PWM_locChangeRC", Capi.RowColumn, frame, [])

	fun locChangeCB () = 
	  if isSome (!modeSel) then
	    let 
	      val dirName = parse_name (locText, parent)
	      val {name, location, ...} = get_mode_details()
	      val (_, _, curConfig) = ProjFile.getConfigurations()
	      val (lib, obj, bin) = ProjFile.getLocations()
	      val legal_location = 
		(ignore (OS.Path.concat [obj, getOpt(curConfig, ""), dirName]);
		 true)
		 handle OS.Path.Path => 
		   (Capi.send_message (shell, "Invalid directory name for mode: " ^ name);
		    false)
	    in
	      if legal_location then 
	        (location := dirName;
	         Capi.Text.set_string (locText, "");
	         modeChanged := true;
	         updateModes (!modes))
	      else ()
	    end
	  else ()

	val {update=updateLocButton, ...} = 
	  Menus.make_buttons (locChangeRC, 
		[Menus.PUSH ("PWM_locChange", locChangeCB, fn _ => isSome(!modeSel))])

	fun updateModeLoc () = 
	  if isSome(!modeSel) then
	    let 
	      val {location, ...} = get_mode_details()
	    in
	      Capi.set_label_string (locLabel, "Mode directory name:  " ^ (!location))
	    end
	  else
	    Capi.set_label_string (locLabel, "Mode directory name:  <No mode selected>")

	val modeDetailsLabel = Capi.make_managed_widget 
				("PWM_modeDetailsLabel", Capi.Label, frame, [])

	fun update () = updateModes (!modes)

	fun apply () = 
	  let
	    val modeNames = map #1 (!modes)
	    val modeExists = List.find (fn c => c = (!curMode)) modeNames
	  in
	    if isSome(modeExists) then
	      (ProjFile.setModes (modeNames, !modeDetails);
	       ProjFile.setCurrentMode
		 (Info.make_default_options (),
		  Info.Location.FILE "Project Properties")
		 (!curMode);
	       ignore(callerUpdate modeNames);
	       modeChanged := false;
	       update();
	       true)
	    else 
	      (Capi.send_message (shell, "Invalid current mode or none set");
	       false)
	  end

	fun reset () = 
	  let 
	    val (modeList, details, currentMode) = ProjFile.getModes()
	  in
	    modes := number_entries (modeList, 1);
	    modeDetails := details;
	    curMode := getOpt(currentMode, "");
	    modeChanged := false;
	    modeSel := NONE;
	    update()
	  end

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!modeChanged)}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX modeScroll,
		 Capi.Layout.FIXED curLabel,
		 Capi.Layout.FIXED modesRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED newMode,
		 Capi.Layout.FIXED addModeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED locLabel,
		 Capi.Layout.FIXED locText,
		 Capi.Layout.FIXED locChangeRC,
		 Capi.Layout.FIXED modeDetailsLabel] @@ 
		(map Capi.Layout.FIXED (map (fn (a,b) => a) details)) @@
		[Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in
 	updateModesRef := (fn () => (updateCurMode(!curMode);
				     updateModeDetails(); 
				     updateCloseButtons();
				     updateModeButtons();
				     updateModeLoc();
				     updateLocButton()));
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
		  if not (!modeChanged) then reset() else ();
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 fn () =>
	   if apply_changes (shell, "Apply changes in modes dialog?", !modeChanged) then
	     ignore(apply())
	   else
	     reset()
	 )
      end  (* mk_modes_dialog *)

    fun mk_configs_dialog (parent, callerUpdate) = 
      let
	val configSel = ref NONE
	val pathSel = ref NONE
	val configChanged = ref false
	val configs = ref []
	val configDetails = ref ([]: ProjFile.config_details list)
	val curConfig = ref ""

	fun is_sel () = isSome(!configSel)

	val visible = ref false
	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propConfigDialog", 
				title = "Project Properties - Configurations", 
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val label = Capi.make_managed_widget 
				("PWC_configLabel", Capi.Label, frame, [])

	val curLabel = Capi.make_managed_widget
				("PWC_curLabel", Capi.Label, frame, [])

	val configUpdateRef = ref (fn () => ())

	fun initConfigDetails name = 
	  {name = name, 
	   files = [],
	   library = []}

	fun modifyConfigDetails ((n, files, lib), configRef) = 
	  ProjFile.modifyConfigDetails
	    ({name=n, files=files, library=lib}, !configRef)
	  handle ProjFile.NoConfigDetailsFound c =>
	      (Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c);
	       (!configDetails))

	fun get_cf_details () = 
	  let val configName = #1 (valOf (!configSel))
	  in
	    ProjFile.getConfigDetails (configName, !configDetails)
	    handle ProjFile.NoConfigDetailsFound c =>
	      (Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c);
	       initConfigDetails configName)
	     | Option => 
	      (Capi.send_message (shell, "No configuration selected");
		initConfigDetails configName)
	  end

	val (configScroll, updateConfigs) = 
	  mk_list (frame, "configList")
	    configSel configUpdateRef configs

	val configRC = Capi.make_managed_widget 
				("PWC_configRC", Capi.RowColumn, frame, [])

	fun removeConfigCB () = 
	  removeSelCB (configSel, configs, configChanged) updateConfigs

	fun updateCurConfig newCurConfig = 
	  (curConfig := newCurConfig;
	   Capi.set_label_string(curLabel, "Current Configuration:  " ^ newCurConfig))

	fun setCurConfigCB () =
	  let 
	    val (selection, pos) = getOpt(!configSel, ("",0))
	  in
	    if (selection <> "") then 
	      (updateCurConfig selection;
	       configChanged := true;
	       updateConfigs(!configs))
	    else
	      Capi.beep parent
	  end

	val {update=updateConfigButtons, ...} = 
	  Menus.make_buttons (configRC, 
		[Menus.PUSH ("PWC_removeConfig", removeConfigCB, is_sel),
		 Menus.PUSH ("PWC_setCurConfig", setCurConfigCB, is_sel)])

	val addConfig = Capi.make_managed_widget
				("PWC_addConfig", Capi.Text, frame, [])

	fun addConfigCB () =
	  let 
	    val config = parse_name (addConfig, parent)
	  in 
	    if not (config is_in (!configs)) andalso config <> "" then 
	      let 
		val new_configs = (config,1) :: (map renumber_up (!configs))
	      in
		configSel := SOME (config,1);
		Capi.Text.set_string (addConfig, "");
		configChanged := true;
		updateConfigs new_configs
	      end
	    else ()
	  end

	val addConfigRC = Capi.make_managed_widget 
				("PWC_addConfigRC", Capi.RowColumn, frame, [])

	val {update, ...} = 
	  Menus.make_buttons (addConfigRC, 
		[Menus.PUSH ("PWC_addConfig", addConfigCB, fn _ => true)])

	val libraryLabel = Capi.make_managed_widget 
				("PWC_libraryLabel", Capi.Label, frame, [])
	val libraryText = Capi.make_managed_widget 
				("PWC_libraryText", Capi.Text, frame, [])

	val configPathRC = Capi.make_managed_widget 
				("PWC_configPathRC", Capi.RowColumn, frame, [])

	fun getConfigFiles () = 
	  if is_sel() then 
	    #files (get_cf_details())
	  else 
	    []

	fun setConfigFiles_no_check (changed_config, theList) = 
	  let 
	    val the_config = valOf (changed_config)
	    val {name, files, library} = 
	      ProjFile.getConfigDetails (the_config, !configDetails)
	  in
	    configDetails := 
		modifyConfigDetails ((name, theList, library), 
				     configDetails);
	    configChanged := true;
 	    updateConfigs (!configs);
	    false    (* Indicates that the files dialog contains
		      * no changes after this update *)
	  end
	  handle ProjFile.NoConfigDetailsFound c =>
	    (Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c);
	     true)

	(* This checks for duplicate module ids with any configuration + common files *)
	fun setConfigFiles (config, theList) = 
	  case (duplicate_mod_ids (theList @@ ProjFile.getFiles()) []) of
	    NONE => setConfigFiles_no_check (config, theList)
	  | SOME f => (duplicate_id (shell, f); true)

	val filesDialog = mk_get_files_dialog (shell,
					 "config_files", 
			    		 getConfigFiles,
			    		 setConfigFiles)

	fun getConfigLibraryPath () = 
	  if is_sel() then 
	    #library (get_cf_details())
	  else []

	fun setConfigLibraryPath (changed_config, theList) =
	  let 
	    val the_config = valOf (changed_config)
	    val {name, files, library} = 
	      ProjFile.getConfigDetails (the_config, !configDetails)
	  in
	    configDetails := 
		modifyConfigDetails ((name, files, theList), 
				     configDetails);
	    configChanged := true;
	    updateConfigs (!configs);
	    Capi.Text.set_string (libraryText, list2str theList)
	  end
	  handle ProjFile.NoConfigDetailsFound c =>
	      Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c)

	val libPath = mk_path_dialog (shell,
				      "config_lib", 
			    	      getConfigLibraryPath,
			    	      setConfigLibraryPath)

	fun get_config_sel () = 
	  #1 (valOf (!configSel))
	  handle Option => noConfigSelStr

	fun setPathCB (setPath, applyReset) () =
	  if is_sel() then 
	    (pathSel := (!configSel);
	    setPath get_config_sel)
	  else
 	    applyReset()

	val {update=updateSetButtons, ...} = 
	  Menus.make_buttons (configPathRC, 
		[Menus.PUSH ("PWC_files", setPathCB filesDialog, is_sel),
		 Menus.PUSH ("PWC_libraryPath", setPathCB libPath, is_sel)])

	fun addCFdetails [] = []
	  | addCFdetails ((configName, p)::t) = 
	      let 
		val details = 
		  List.find (fn {name=n, ...} => n = configName) (!configDetails)
	      in
		if isSome details then
		  valOf(details) :: (addCFdetails t)
		else
		  (initConfigDetails configName) :: (addCFdetails t)
	      end

	fun rem_old_config_units (configs, c_details, old_config) new_config =
          let
	    fun get_c_files config = 
	      #files (ProjFile.getConfigDetails (config, c_details))
	    fun get_c_modules config = 
	      map (fn f => ModuleId.from_host(OS.Path.file f,
                                              Info.Location.FILE "Project Properties"))
		  (get_c_files config)
            fun remove_unit (mod_id, proj) = Project.delete(proj, mod_id, false)
            val init_proj = Incremental.get_project()
            val set = Incremental.set_project
          in
            case (old_config, new_config) of
              (NONE, _) => ()
	    | (SOME old, NONE) =>
		set (foldl remove_unit init_proj (get_c_modules old))
            | (SOME old, SOME new) =>
		if (old = new) then ()
		else
                  set (foldl remove_unit init_proj (get_c_modules old))
          end
          handle ProjFile.NoConfigDetailsFound c => ()

	fun apply () = 
	  let 
	    val configNames = map #1 (!configs)
	    val configExists = List.find (fn c => c = (!curConfig)) configNames
	    val details = 
	      (if isSome(configExists) then
		SOME (ProjFile.getConfigDetails((!curConfig), (!configDetails)))
	      else
		NONE)
	      handle ProjFile.NoConfigDetailsFound c =>
		(Capi.send_message (shell, 
		   "Error in configurations.  No details found for configuration: " ^ c);
		 NONE)
	    val c_files = case details of NONE => [] | SOME d => #files d

	    fun invalid_config () = 
	      (Capi.send_message (shell, "Invalid current configuration or none set");
	       false)
	    val newConfig = if (configNames <> []) then SOME (!curConfig) else NONE
	    val oldDetails = ProjFile.getConfigurations()

	    (* the configChanged reference should be reset before calling rem_old_config
	     * because the applyReset function for configurations is called as a result 
	     * of calling Incremental.set_project (via ProjectWorkspace.updateDisplay).
	     * This also means that rem_old_config_units should be called after the 
	     * calls to ProjFile otherwise the dialog will be reset before applied. 
	     * Also setCurrentConfiguration should be called after setConfigurations. *)
	    fun apply_it () = 
	      (configChanged := false;
	       ProjFile.setConfigurations (configNames, !configDetails);
	       ProjFile.setCurrentConfiguration
		 (Info.make_default_options (),
		  Info.Location.FILE "Project Properties")
		  newConfig;
	       (* callerUpdate should be called after the current configuration
		* is set as the callerUpdate calls ProjFile.getConfigurations.   
		*)
	       rem_old_config_units oldDetails newConfig;
               ignore(callerUpdate());
	       updateConfigs (!configs);
	       true)

	    fun check_apply () = 
	      case (duplicate_mod_ids (ProjFile.getFiles() @@ c_files) []) of
		NONE => apply_it()
	      | SOME f => (duplicate_id (shell, f); false)
	  in
	    case configExists of 
	      NONE => if (configNames = []) then 
			(curConfig := "";
	                 Capi.set_label_string(curLabel, "Current Configuration:");
			 check_apply())
		      else 
			invalid_config()
	    | SOME c => check_apply()
	  end

	fun reset () = 
	  let 
	    val (configList, details, currentConfig) = ProjFile.getConfigurations()
	  in
	    configs := number_entries (configList, 1);
	    configDetails := details;
	    curConfig := getOpt(currentConfig, "");
	    configChanged := false;
	    configSel := NONE;
	    updateConfigs (!configs)
	  end

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!configChanged)}

	fun updateCFdetails () = 
	  (configDetails := addCFdetails (!configs);
	   updateCloseButtons();
	   if is_sel() then 
	     let 
	       val {name, files, library} = get_cf_details()
	     in
	       Capi.Text.set_string (libraryText, list2str library)
	     end
	   else ())

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX configScroll,
		 Capi.Layout.FIXED curLabel,
		 Capi.Layout.FIXED configRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED addConfig,
		 Capi.Layout.FIXED addConfigRC,
		 Capi.Layout.SPACE,
 		 Capi.Layout.FIXED libraryLabel,
		 Capi.Layout.FIXED libraryText,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED configPathRC,
		 Capi.Layout.SPACE, 
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])


	val closing_dialogs = ref false
      in
	configUpdateRef := 
	    (fn () => 
		let 
		  (* This must be called before filesDialog and libPath are called, 
		   * so that the configuration details are up to date, otherwise
		   * an attempt is made to access details which will be out of 
		   * date after adding a new configuration.
		   *)
		  val _ = updateCFdetails()
		  val (F, applyResetF) = filesDialog
		  val (L, applyResetL) = libPath

		  fun applyResetThem () = 
		    if (!closing_dialogs) then ()
		    else 
		      (closing_dialogs := true;
		       applyResetF(); applyResetL(); updateCFdetails();
		       closing_dialogs := false)

		in
		  applyResetThem();
		  updateCurConfig(!curConfig);
		  updateConfigButtons();
		  updateSetButtons()
		end);
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
 		  if not (!configChanged) then reset() else ();
		  updateConfigs (!configs);
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 fn () =>
	   if apply_changes (shell, "Apply changes in configurations dialog?", !configChanged) then
	     ignore(apply())
	   else
	     reset()
	)
      end  (* mk_configs_dialog *)

    fun mk_library_dialog (parent, callerUpdate) = 
      let
	fun getLibPath() = #1 (ProjFile.getLocations())

	fun setLibPath (config_, dirList) = 
	  let
	    val (libPath, objDir, binDir) = ProjFile.getLocations()
	  in
	    ignore(callerUpdate (list2str dirList));
	    ProjFile.setLocations (dirList, objDir, binDir)
	  end

	val (mkLibPath, applyResetLibPath) = 
	  mk_path_dialog (parent, "lib_path", getLibPath, setLibPath)

      in
	((fn () => 
	   mkLibPath (fn () => "Ordered list of directories where library files are found:")),
	 applyResetLibPath)
      end

    fun set_objects_dir (parent, objRelativeRef, callerUpdate) = 
      let 
	val rawText = get_directory (parent, MAY_EXIST)
	val text = 
	  if (!objRelativeRef) then 
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative {path=rawText, relativeTo=ProjFile.getProjectDir ()})
	  else
	    rawText

	val (libPath, objDir, binDir) = ProjFile.getLocations()
      in
	if (rawText <> "") andalso (text <> objDir) then 
	  (need_saved := true;
	   ProjFile.setLocations (libPath, text, binDir);
	   callerUpdate text)
	else ()
      end

    fun set_binaries_dir (parent, binRelativeRef, callerUpdate) = 
      let 
	val rawText = get_directory (parent, MAY_EXIST)
	val text = 
	  if (!binRelativeRef) then 
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative {path=rawText, relativeTo=ProjFile.getProjectDir ()})
	  else
	    rawText

	val (libPath, objDir, binDir) = ProjFile.getLocations()
      in
	if (text <> "") andalso (text <> binDir) then 
	  (need_saved := true;
	   ProjFile.setLocations (libPath, objDir, text);
	   callerUpdate text)
	else ()
      end

    fun setRelObjBin (objChange, callerUpdate, relRef) b = 
      let
	val (lib, obj, bin) = ProjFile.getLocations()
	val relAbs = if b then OS.Path.mkRelative else OS.Path.mkAbsolute
	val valueChange = if objChange then obj else bin
	val newValue = 
	  OS.Path.mkCanonical (relAbs {path=valueChange, relativeTo=ProjFile.getProjectDir ()})
      in
	relRef := b;
	need_saved := true;
	if objChange then 
	  ProjFile.setLocations (lib, newValue, bin)
	else
	  ProjFile.setLocations (lib, obj, newValue);
	callerUpdate newValue
      end	

    fun mk_about_dialog parent = 
      let 
        val description = ref ""
        val version = ref ""
        val visible = ref false

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup {name = "propAboutDialog", 
				title = "Project Properties - About Project", 
				parent = parent, 
				contextLabel = false, 
				visibleRef = visible,
				pos = Capi.getNextWindowPos()}

	val descLabel = Capi.make_managed_widget 
				("PWA_descLabel", Capi.Label, frame, [])
	val descText = Capi.make_managed_widget
				("PWA_descText", Capi.Text, frame, [])
	val verLabel = Capi.make_managed_widget 
				("PWA_verLabel", Capi.Label, frame, [])
	val verText = Capi.make_managed_widget
				("PWA_verText", Capi.Text, frame, [])

	val updateRef = ref (fn () => ())
	fun update () = (!updateRef)()

	fun about_changed () = 
	  let
	    val desc = Capi.Text.get_string descText
	    val ver = Capi.Text.get_string verText
	  in
	    (desc <> (!description)) orelse (ver <> (!version))
	  end

	fun apply () = 
	  if about_changed() then
	    (description := Capi.Text.get_string descText;
	     version := Capi.Text.get_string verText;
	     ProjFile.setAboutInfo (!description, !version);
	     update();
	     true)
	  else
	    true

	fun reset () = 
	  let 
	    val (desc, ver) = ProjFile.getAboutInfo()
	  in
	    description := desc;
	    version := ver;
	    update()
	  end

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame,
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = about_changed}

	fun setAbout (descript, ver) =
	  (description := descript;
	   version := ver;
	   Capi.Text.set_string (descText, descript);
	   Capi.Text.set_string (verText, ver);
	   updateCloseButtons())

	fun updateAbout () = 
	  (setAbout (!description, !version);
	   updateCloseButtons())

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, NONE,
	    [Capi.Layout.FIXED descLabel,
	     Capi.Layout.FLEX descText,
	     Capi.Layout.FIXED verLabel,
	     Capi.Layout.FIXED verText,
	     Capi.Layout.SPACE,
	     Capi.Layout.FIXED closeRC,
	     Capi.Layout.SPACE])

      in
	updateRef := updateAbout;
	Capi.Callback.add (descText, Capi.Callback.ValueChange, updateCloseButtons);
	Capi.Callback.add (verText, Capi.Callback.ValueChange, updateCloseButtons);
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	reset();
	(fn () => (visible := true;
		  if not (about_changed()) then reset() else ();
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 fn () => 
	   if apply_changes (shell, "Apply changes in about dialog?", about_changed()) then
	     ignore(apply())
	   else
	     reset()
	)

      end  (* mk_about_dialog *)

    end  (* local containing mk_???_dialogs *)

end  (* struct *)


@


1.37
log
@[Bug #190557]
reset project so that units are displayed in PW when project first opened.
@
text
@d3 4
d374 1
a374 1
        NONE => ()
d384 3
a386 2
	     "Release")
    else ()
@


1.36
log
@[Bug #190521]
OS.FileSys.readDir now returns an option type.
@
text
@d3 4
d398 1
d892 1
a892 1
	     "files"        => ("Project Properties - Files", false)
@


1.36.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.36  1999/03/18  12:05:06  daveb
 * [Bug #190521]
 * OS.FileSys.readDir now returns an option type.
 *
@


1.35
log
@[Bug #190534]
Ensure projects created by Shell.Project have Debug and Release modes as default
@
text
@d3 4
d930 6
a935 8
	      let 
		val raw_f = OS.FileSys.readDir dirstream
		val f = OS.Path.mkCanonical raw_f
	      in
		if (raw_f = "") then 
		  []
		else 
		  let 
a943 1
	      end
@


1.34
log
@[Bug #50108]
Change ModuleId from an equality type
@
text
@d3 4
a274 26
  val debugMode =
    {name = "Debug",
     location = ref "Debug",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref true,
     generate_debug_info = ref true,
     generate_variable_debug_info = ref true,
     optimize_leaf_fns = ref false,
     optimize_tail_calls = ref false,
     optimize_self_tail_calls = ref false,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

  val releaseMode =
    {name = "Release",
     location = ref "Release",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref false,
     generate_debug_info = ref false,
     generate_variable_debug_info = ref false,
     optimize_leaf_fns = ref true,
     optimize_tail_calls = ref true,
     optimize_self_tail_calls = ref true,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

d368 1
a368 3
           ProjFile.setModes
             (["Debug", "Release"],
              [debugMode, releaseMode]);
@


1.33
log
@[Bug #190500]
Remove redundant require statements
@
text
@d3 4
d469 1
a469 1
	  if (List.exists (fn id' => id = id') ids) then (SOME filen)
@


1.32
log
@[Bug #190497]
Make sure setConfigurations is done before setCurrentConfiguration.
@
text
@d3 4
a202 2
require "../basis/__int";
require "../basis/__text_io";
@


1.31
log
@[Bug #70240]
Remove confiugration files from project unit list when changing current configuration.
@
text
@d3 4
d1151 1
a1151 1
    fun mk_files_dialog (parent, updateFiles) = 
d2329 2
a2330 1
	     * calls to ProjFile otherwise the dialog will be reset before applied. *)
d2333 1
a2337 1
	       ProjFile.setConfigurations (configNames, !configDetails);
@


1.30
log
@[Bug #190494]
Check for duplicate module ids when adding new files and changing configurations.
@
text
@d3 4
d205 1
d224 1
d229 2
a2115 1
(* XXX *)
d2117 1
a2117 1
	      (Capi.send_message (shell, "Option error in configurations - oh dear!");
d2277 23
d2318 2
d2321 5
d2327 2
a2328 1
	      (ProjFile.setCurrentConfiguration
d2331 1
a2331 1
		 (if (configNames <> []) then SOME (!curConfig) else NONE);
d2336 1
a2337 1
	       configChanged := false;
d2339 1
a2339 1
	       true)	
@


1.29
log
@[Bug #70214]
add check to save changes when properties dialogs close.
@
text
@d3 4
d196 1
d218 1
d221 1
a221 1
  sharing type Info.Location.T = ProjFile.location
d445 13
d1049 1
d1052 1
a1052 1
	   ignore(set (SOME (!title_ref), (map #1 (!files))));
d1141 8
d1154 8
a1161 2
				(ProjFile.setFiles newFiles;
				 updateFiles newFiles))
d2185 1
a2185 1
	fun setConfigFiles (changed_config, theList) = 
d2195 3
a2197 1
 	    updateConfigs (!configs)
d2200 9
a2208 2
	      Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c)
d2283 12
a2294 13
	    val valid_cur_config = 
	      isSome(configExists) orelse (configNames = [])
	  in
	    if valid_cur_config then 
	      (ProjFile.setConfigurations (configNames, !configDetails);
	       if (configNames <> []) then 
		 ProjFile.setCurrentConfiguration
		   (Info.make_default_options (),
		    Info.Location.FILE "Project Properties")
		   (SOME (!curConfig))
               else 
                 ( curConfig := "";
                   Capi.set_label_string(curLabel, "Current Configuration:") );
d2296 1
a2296 1
		* is set as the callerUpdate calls ProjFile.getConfigurations.
d2301 15
a2315 4
	       true)
	    else
	      (Capi.send_message (shell, "Invalid current configuration or none set");
	       false)
@


1.28
log
@[Bug #30482]
Clear units when opening a new project
@
text
@d3 4
d402 6
d629 2
d637 4
a640 2
     * set: string list -> unit:  a function to set the path given a new list of 
     * 				  directories.
d754 19
d774 2
a775 2
	  (ignore(set (map #1 (!path_items)));
	   pathChanged := false;
d810 9
d824 1
a824 9
      updatePathsRef := 
	(fn () => 
	  (update(); 
	   updateCloseButtons(); 
	   if (!path_items) <> [] then
	     relativePaths := OS.Path.isRelative (#1(hd(!path_items)))
	   else ();
	   updateRel()));

d833 4
a836 4
       * close_fn: (unit -> unit)
       *  This function is called in two places:  one by the caller when the caller
       *  needs the path dialog to be hidden, and one by the close callback when the 
       *  user explicitly closes the dialog.
d838 11
a848 5
     ((fn miniTitle => 
	 (Capi.set_label_string (label, miniTitle);
	  if (!path_items) <> [] then 
	    relativePaths := OS.Path.isRelative (#1(hd(!path_items)))
	  else ();
a849 1
    	  visible := true;
d854 6
a859 1
      close)
d868 1
a868 1
	val title = 
d870 3
a872 3
	     "files"        => "Project Properties - Files"
	   | "config_files" => "Configuration Files"
	   | _ => ""
d1024 6
d1031 2
a1032 2
	  (ignore(set (map #1 (!files)));
	   filesChanged := false;
d1067 9
d1081 1
a1081 9
      updateFilesRef := 
	(fn () => 
	  (update(); 
	   updateCloseButtons(); 
	   if (!files) <> [] then
	     relativePaths := OS.Path.isRelative (#1(hd(!files)))
	   else ();
	   updateRel()));

d1090 4
a1093 4
       * close_fn: (unit -> unit)
       *  This function is called in two places:  one by the caller when the caller
       *  needs the path dialog to be hidden, and one by the close callback when the 
       *  user explicitly closes the dialog.
d1095 11
a1105 5
     ((fn miniTitle => 
	 (Capi.set_label_string (label, miniTitle);
	  if (!files) <> [] then 
	    relativePaths := OS.Path.isRelative (#1(hd(!files)))
	  else ();
a1106 1
    	  visible := true;
d1111 6
a1116 1
      close)
d1121 1
a1121 1
	val (mk_new_files_dialog, closeFilesDialog) = 
d1125 3
a1127 2
			  fn newFiles => (ProjFile.setFiles newFiles;
				         updateFiles newFiles))
d1131 1
a1131 1
    	    "List of files belonging to current project:"
d1133 1
a1133 1
	(files_dialog, closeFilesDialog)
d1320 1
a1320 3
	 (if (!subprojects) <> [] then 
	    relSubproj := OS.Path.isRelative (#1(hd(!subprojects)))
	  else ();
a1321 1
    	  visible := true;
d1326 6
a1331 1
        reset)
d1696 1
a1696 1
		  if not (!changed) then reset() else ();
d1701 6
a1706 1
	 close)
d2017 6
a2022 1
	 close)
d2074 4
d2151 5
a2155 4
	fun setConfigFiles theList = 
	  let val {name, files, library} = get_cf_details()
		(* WWW: get_cf_details may raise an exception if !configSel is NONE, 
		 *	BUT this should never be the case here *)
d2163 3
d2177 5
a2181 4
	fun setConfigLibraryPath theList =
	  let val {name, files, library} = get_cf_details()
		(* WWW: get_cf_details may raise an exception if !configSel is NONE, 
		 *	BUT this should never be the case here *)
d2190 3
d2199 5
a2203 1
	fun setPathCB (setPath, closeDialog) () =
d2206 1
a2206 1
	    setPath (#1 (valOf (!configSel))))
d2208 1
a2208 1
	    closeDialog()
d2319 2
d2325 1
a2325 1
		  (* This must be called before sourcePath and libPath are called, 
d2331 9
a2339 3
		  val (F, closeF) = filesDialog
		  val (L, closeL) = libPath
		  fun closeThem () = (closeF(); closeL())
d2342 1
a2342 10

		  (* These two dialogs are closed in the event that the current
		   * selection of configuration is changed to avoid confusion
		   * as to which configuration these dialogs refer to.
		   *)
		  if isSome(!configSel) andalso isSome (!pathSel) then
		    if (#1 (valOf (!configSel)) <> #1 (valOf (!pathSel))) then
		       closeThem()
		    else ()
		  else closeThem();
d2351 1
a2351 1
		  if not (!configChanged) then reset() else ();
d2356 6
a2361 1
	 close)
d2368 1
a2368 1
	fun setLibPath dirList = 
d2376 1
a2376 1
	val (mkLibPath, closeLibPath) = 
d2381 2
a2382 2
	    mkLibPath "Ordered list of directories where library files are found:"),
	 closeLibPath)
d2541 6
a2546 1
	close)
d2553 1
@


1.27
log
@[Bug #30474]
Replace orig_proj reference by a project stack for subprojects
@
text
@d3 4
d380 1
d389 2
a390 1
 	      (Capi.send_message (parent, "Error in project file: " ^ s); ());
@


1.26
log
@[Bug #50102]
reset dialogs if no changes made by user so that dialogs are kept up to date with ProjFile.
@
text
@d3 4
d266 1
a266 1
  val orig_proj = ref NONE
d357 1
a357 1
           orig_proj := NONE;
d377 6
a382 1
	   ProjFile.open_proj (hd(valOf(files)))
a384 1
	   orig_proj := SOME (hd(valOf(files)));
d1154 1
d1157 7
a1163 3
   	      case (!orig_proj) of 
	        NONE => (orig_proj := ProjFile.getProjectName(); updatePW true)
	      | SOME f => updatePW (f = getOpt (ProjFile.getProjectName(), ""));
d1178 3
a1180 3
	    (case (!orig_proj) of
	       NONE => orig_proj := ProjFile.getProjectName()
	     | SOME filename => ProjFile.open_proj filename;
d1189 1
a1189 4
	fun backSens () = 
	  case (!orig_proj) of 
	    NONE => false
	  | SOME f => f <> getOpt(ProjFile.getProjectName(), "")
@


1.25
log
@[Bug #30468]
Change types of mkAbsolute and mkRelative to uses records with names fields
@
text
@d3 4
d795 1
d1035 1
d1245 1
d1616 1
d1927 1
d2246 1
d2426 1
@


1.24
log
@Automatic checkin:
changed attribute _comment to ' * '
@
text
@d3 94
a96 86
*Revision 1.22  1998/07/29  14:01:47  johnh
*[Bug #30453]
*Check for a new target being in the list of files.
*
*Revision 1.21  1998/07/03  09:42:03  johnh
*[Bug #50088]
*Fix SysErr exception problem when adding files from directory.
*
*Revision 1.20  1998/06/17  15:53:21  johnh
*[Bug #30423]
*remove units for a new project.
*
*Revision 1.19  1998/06/16  11:18:39  mitchell
*[Bug #30422]
*Prompt for working directory when creating a new project
*
*Revision 1.18  1998/06/09  13:22:18  mitchell
*[Bug #30405]
*Fix update of display when configuration changes
*
*Revision 1.17  1998/06/08  12:20:08  mitchell
*[Bug #30418]
*Handle broken project files gracefully
*
*Revision 1.16  1998/06/01  16:01:36  johnh
*[Bug #30369]
*Replace source path with a list of files.
*
*Revision 1.15  1998/05/14  14:57:58  johnh
*[Bug #30384]
*Fix test_save.
*
*Revision 1.14  1998/05/01  12:40:48  mitchell
*[Bug #50071]
*setCurrentConfiguration now takes an option
*
*Revision 1.13  1998/04/30  11:46:22  johnh
*[Bug #30407]
*Temporarily remove target type.
*
*Revision 1.12  1998/04/24  14:40:36  jkbrook
*[Bug #30376]
*Change default mode to Release so that our distributed objects
*can be found
*
*Revision 1.11  1998/04/22  16:37:38  mitchell
*[Bug #70095]
*Check for bogus characters in modes and configurations
*
*Revision 1.10  1998/04/22  10:23:54  johnh
*[Bug #50073]
*Give warning when saving new project or saving project in different place.
*
*Revision 1.9  1998/03/31  16:23:42  johnh
*[Bug #30346]
*Call Capi.getNextWindowPos().
*
*Revision 1.8  1998/03/17  11:12:20  johnh
*[Bug #30365]
*Fix warning.
*
*Revision 1.7  1998/03/12  16:48:58  johnh
*[Bug #30365]
*No need for per-target modes or configurations now that subprojects are here.
*
*Revision 1.6  1998/02/26  11:16:46  johnh
*[Bug #30362]
*Setting current mode changes object file location.
*
*Revision 1.5  1998/02/19  19:51:41  mitchell
*[Bug #30337]
*Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
*
*Revision 1.4  1998/02/17  17:56:14  johnh
*[Bug #30344]
*Allow windows to retain size and position.
*
*Revision 1.3  1998/02/06  16:51:30  johnh
*[Bug #30071]
*Fixing require bug.
*
*Revision 1.2  1998/02/06  15:55:48  johnh
*new unit
*[Bug #30071]
*Project Properties of the new Project Workspace tool.
*
d584 1
a584 1
	      (OS.Path.mkRelative (a, ProjFile.getProjectDir()))
d595 1
a595 1
	      (OS.Path.mkAbsolute (a, ProjFile.getProjectDir()))
d663 1
a663 1
		  (OS.Path.mkRelative (rawDir, ProjFile.getProjectDir ()))
d845 1
a845 1
		  (OS.Path.mkRelative (f, ProjFile.getProjectDir ()))
d899 1
a899 1
		  (OS.Path.mkRelative (f, ProjFile.getProjectDir ()))
d1111 1
a1111 1
		  (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
d1138 2
a1139 2
                    OS.Path.mkAbsolute(#1(valOf(!subSel)), 
                                       ProjFile.getProjectDir())
d1368 1
a1368 1
		    OS.Path.mkRelative(rawText, ProjFile.getProjectDir())
d2271 1
a2271 1
	      (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
d2290 1
a2290 1
	      (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
d2309 1
a2309 1
	  OS.Path.mkCanonical (relAbs (valueChange, ProjFile.getProjectDir ()))
@


1.23
log
@[Bug #30440]
Modify test_save to optionally allow cancel
@
text
@@


1.22
log
@[Bug #30453]
Check for a new target being in the list of files.
@
text
@d3 4
d313 1
a313 1
  fun test_save parent = 
d317 1
a317 1
	  Capi.makeYesNoCancel (parent, "Save the current project?", true)
d334 1
a334 1
    if test_save parent then 
d352 1
a352 1
    if test_save parent then 
d1128 1
a1128 1
	  if test_save shell then
d1150 1
a1150 1
	  if test_save shell then
@


1.21
log
@[Bug #50088]
Fix SysErr exception problem when adding files from directory.
@
text
@d3 4
d1019 1
a1019 1
    	  set_new_files (!files);
d1228 1
a1228 1
    	  set_new_projs (!subprojects);
d1320 1
d1328 7
a1334 3
	  in 
	    if not (text is_in (!curTargets) orelse text is_in (!disTargets)) 
		 andalso text <> "" then 
d1336 1
a1336 1
		val new_targets = (text,1) :: (map renumber_up (!curTargets))
d1338 1
a1338 1
		curSel := SOME (text,1);
d1340 1
a1340 1
		updateTargets new_targets
d1342 25
d1503 13
a1515 8
	fun apply () = 
	  (ProjFile.setTargets (map #1 (!curTargets), 
				map #1 (!disTargets), 
				!targetDetails);
	   changed := false;
	   update();
	   ignore(callerUpdate (map #1 (!curTargets)));
	   true)
@


1.20
log
@[Bug #30423]
remove units for a new project.
@
text
@d3 4
d651 1
a651 1
	    if dir = "" orelse dir is_in !path_items then ()
d833 1
a833 2
	    val dirstream = OS.FileSys.openDir rawDir
	    fun getFiles () = 
d835 1
a835 1
		val raw_f = OS.FileSys.readDir(dirstream)
d846 1
a846 1
		      relFn(OS.Path.concat [rawDir, f]) :: (getFiles())
d848 1
a848 1
		      getFiles()
d856 4
a859 5
	  in
	    if rawDir = "" then ()
	    else
	      let
	        val new_files = getFiles()
d864 9
a872 3
		set_new_files new_file_list
	      end;
	    OS.FileSys.closeDir dirstream
@


1.19
log
@[Bug #30422]
Prompt for working directory when creating a new project
@
text
@d3 4
d161 2
d176 1
d328 1
@


1.18
log
@[Bug #30405]
Fix update of display when configuration changes
@
text
@d3 4
d250 3
d254 1
a262 1
	    val old_dir = ProjFile.getProjectDir()
d265 2
a266 1
	        Capi.makeYesNoCancel (parent, "Any relative paths specified in the project will become invalid.  Continue saving?", false) ()
d316 13
a328 10
      (need_saved := false;
       ProjFile.initialize();
       orig_proj := NONE;
       ProjFile.setModes
         (["Debug", "Release"],
	  [debugMode, releaseMode]);
       ProjFile.setCurrentMode
	 (Info.make_default_options (),
	  Info.Location.FILE "Project Properties")
	 "Release")
d337 1
a337 1
	  (ProjFile.initialize();  (* needed here so that projectName <> NONE 
d1105 10
a1114 5
	    (ProjFile.open_proj (#1(valOf(!subSel)));
 	     case (!orig_proj) of 
	       NONE => (orig_proj := ProjFile.getProjectName(); updatePW true)
	     | SOME f => updatePW (f = getOpt (ProjFile.getProjectName(), ""));
	     need_saved := false)
@


1.17
log
@[Bug #30418]
Handle broken project files gracefully
@
text
@d3 4
d2052 3
a2054 1
               else ();
d2058 1
a2058 3
	       if isSome(details) then 
		 callerUpdate(valOf(details)) 
	       else ();
@


1.16
log
@[Bug #30369]
Replace source path with a list of files.
@
text
@d3 4
d326 3
a328 1
	   ProjFile.open_proj (hd(valOf(files)));
d2048 1
a2048 1
	       else ();
@


1.15
log
@[Bug #30384]
Fix test_save.
@
text
@d3 4
d315 1
a315 1
	val filename = Capi.open_file_dialog (parent, ".mlp")
d317 1
a317 1
        if isSome(filename) then 
d322 2
a323 2
	   ProjFile.open_proj (valOf(filename));
	   orig_proj := filename;
d332 2
a333 2
      case Capi.open_file_dialog (shell, ".sml") of
	 SOME s => OS.Path.mkCanonical s
d336 5
d427 2
a428 1
            sel := SOME (find_nth 1 new_items);
d577 1
a577 3
	     "files"      => "Project Properties - Files"
	   | "config_src" => "Configuration Source Path"
	   | "config_lib" => "Configuration Library Path"
d590 1
a590 1
				("PWF_propFilesLabel", Capi.Label, frame, [])
d640 1
a640 1
				("PWF_removeRC", Capi.RowColumn, frame, [])
d644 5
a648 5
		[Menus.PUSH ("PWF_addButton", addNewCB, fn _ => true),
		 Menus.PUSH ("PWF_moveUp", moveUp, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_moveDown", moveDown, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_removeSel", removeSel, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_removeAll", removeAllCB, fn () => true)])
d664 1
a664 1
				("PWF_relativeRC", Capi.RowColumn, frame, [])
d724 2
d750 1
a750 1
    fun mk_source_dialog (parent, updatePath) = 
d752 237
a988 2
	val (mk_new_path_dialog, closePathDialog) = 
          mk_path_dialog (parent,
d990 7
a996 7
	    		  ProjFile.getSourcePath,
			  fn newPath => (ProjFile.setSourcePath newPath;
				         updatePath newPath))

        fun path_dialog () = 
	  mk_new_path_dialog 
    	    "Ordered list of directories where ML source files are found:"
d998 1
a998 1
	(path_dialog, closePathDialog)
d1050 5
a1054 3
	      case Capi.open_file_dialog (shell, ".mlp") of
		 SOME p => OS.Path.mkCanonical p
	      |  NONE => ""
d1863 1
a1863 1
	   source = [],
d1866 1
a1866 1
	fun modifyConfigDetails ((n, source, lib), configRef) = 
d1868 1
a1868 1
	    ({name=n, source=source, library=lib}, !configRef)
a1940 5
	val sourceLabel = Capi.make_managed_widget 
				("PWC_sourceLabel", Capi.Label, frame, [])
	val sourceText = Capi.make_managed_widget 
				("PWC_sourceText", Capi.Text, frame, [])

d1949 1
a1949 1
	fun getConfigSourcePath () = 
d1951 3
a1953 2
	    #source (get_cf_details())
	  else []
d1955 2
a1956 2
	fun setConfigSourcePath theList = 
	  let val {name, source, library} = get_cf_details()
d1964 1
a1964 2
 	    updateConfigs (!configs);
	    Capi.Text.set_string (sourceText, list2str theList)
d1967 4
a1970 4
	val sourcePath = mk_path_dialog (shell,
					 "config_src", 
			    		 getConfigSourcePath,
			    		 setConfigSourcePath)
d1978 1
a1978 1
	  let val {name, source, library} = get_cf_details()
d1983 1
a1983 1
		modifyConfigDetails ((name, source, theList), 
d2004 1
a2004 1
		[Menus.PUSH ("PWC_sourcePath", setPathCB sourcePath, is_sel),
d2087 1
a2087 1
	       val {name, source, library} = get_cf_details()
a2088 1
	       Capi.Text.set_string (sourceText, list2str source);
a2101 2
		 Capi.Layout.FIXED sourceLabel,
		 Capi.Layout.FIXED sourceText,
d2121 1
a2121 1
		  val (S, closeS) = sourcePath
d2123 1
a2123 1
		  fun closeThem () = (closeS(); closeL())
@


1.14
log
@[Bug #50071]
setCurrentConfiguration now takes an option
@
text
@d3 4
d272 2
a273 1
  (* returns false iff the user clicks cancel *)
d282 8
a289 7
	ignore(
          if yesOrNo then 
	    if valOf(answer) then 
	      save_project parent
	    else false
	  else false);
	yesOrNo
@


1.13
log
@[Bug #30407]
Temporarily remove target type.
@
text
@d3 4
d1793 1
a1793 1
		   (!curConfig)
@


1.12
log
@[Bug #30376]
Change default mode to Release so that our distributed objects
can be found
@
text
@d3 5
d979 1
a979 1
		  (name, ProjFile.EXECUTABLE) :: (addDetails t)
d1014 1
a1014 1
	       (n, ProjFile.EXECUTABLE))
d1068 2
d1079 1
d1159 1
d1164 1
d1213 3
a1215 1
	  (updateTypes();
d1229 2
d1235 1
@


1.11
log
@[Bug #70095]
Check for bogus characters in modes and configurations
@
text
@d3 4
d290 1
a290 1
	 "Debug")
@


1.10
log
@[Bug #50073]
Give warning when saving new project or saving project in different place.
@
text
@d3 4
d112 2
d151 16
a166 22
  fun find_space(arg as (s, i)) =
    if i >= size s orelse MLWorks.String.ordof arg = ord #" " then
      i
    else
      find_space(s, i+1)

  fun ignore_spaces(arg as (s, i)) =
    if i >= size s orelse MLWorks.String.ordof arg <> ord #" " then
      i
    else
      ignore_spaces(s, i+1)

  (* parse_name removes leading and trailing spaces from the input name *)
  fun parse_name name =
    let
      val i = ignore_spaces(name, 0)
    in
      if i >= size name then
        ""
      else
        substring (name, i, (find_space (name, i)) -i)
    end
d1407 1
a1407 1
	    val mode = parse_name (Capi.Text.get_string newMode)
d1436 1
a1436 1
	      val dirName = parse_name (Capi.Text.get_string locText)
d1644 1
a1644 1
	    val config = parse_name (Capi.Text.get_string addConfig)
@


1.9
log
@[Bug #30346]
Call Capi.getNextWindowPos().
@
text
@d3 4
d211 4
d216 3
a218 6
    let val filename = Capi.save_as_dialog (parent, ".mlp")
    in
      if isSome(filename) then
	(ProjFile.save_proj (valOf(filename));
	 confirm_save parent)
      else 
d221 22
@


1.8
log
@[Bug #30365]
Fix warning.
@
text
@d3 4
d533 1
a533 1
				pos = (100,100)}
d726 1
a726 1
				pos = (100, 100)}
d916 1
a916 1
				pos = (100,100)}
d1236 1
a1236 1
				pos = (100, 100)}
d1548 1
a1548 1
				pos = (100, 100)}
d1944 1
a1944 1
				pos = (100, 100)}
@


1.7
log
@[Bug #30365]
No need for per-target modes or configurations now that subprojects are here.
@
text
@d3 4
d1410 1
a1410 1
		(OS.Path.concat [obj, getOpt(curConfig, ""), dirName];
@


1.6
log
@[Bug #30362]
Setting current mode changes object file location.
@
text
@d3 4
d766 1
a766 1
	      if isSome (List.find isCurProj (ProjFile.getSubProjects rawText)) then 
d930 1
a930 1
		val details = List.find (fn (n,_,_,_) => n=name) (!targetDetails)
d935 1
a935 1
		  (name, ProjFile.EXECUTABLE, "", "") :: (addDetails t)
d952 1
a952 1
	fun modifyTarget (name, tarType, mode, config) = 
d954 3
a956 3
	    val (name', t, m, c) = 
	      valOf (List.find (fn (n,_,_,_) => n=name) (!targetDetails))
	    val others = List.filter (fn (n,_,_,_) => n <> name) (!targetDetails);
d958 1
a958 1
	    targetDetails := (name, tarType, mode, config) :: others
d970 1
a970 1
	       (n, ProjFile.EXECUTABLE, "", ""))
d1004 1
a1004 1
	      let val (name, curType, mode, config) = get_details()
d1007 1
a1007 1
		modifyTarget (name, whichType, mode, config);
a1033 5
	val modeLabel = Capi.make_managed_widget
				("PWT_modeLabel", Capi.Label, frame, [])
	val configLabel = Capi.make_managed_widget
				("PWT_configLabel", Capi.Label, frame, [])

a1116 5
	val modeConfig = Capi.make_managed_widget
				("PWT_modeConfig", Capi.Text, frame, [])
	val modeConfigRC = Capi.make_managed_widget 
				("PWT_modeConfigRC", Capi.RowColumn, frame, [])

a1154 10
	fun changeName [] names = []
	  | changeName ((n, t, m, c)::rest) (old, new) = 
	      if n = old then 
		(new, t, m, c) :: rest

	      else
		(n, t, m, c) :: (changeName rest (old, new))
	fun changeTargetName names = 
	  targetDetails := changeName (!targetDetails) names

d1165 1
a1165 45
	   updateCloseButtons();
	   let 
	     val (_,_, mode, config) = 
	       if isCurSel() then
		 get_details()
	       else
		 ("", ProjFile.EXECUTABLE, "", "")
	   in
	     Capi.set_label_string (modeLabel, "Mode:  " ^ mode);
	     Capi.set_label_string (configLabel, "Configuration:  " ^ config)
	   end)

	(* addModeCB:  changes the mode of the selected current target *)
	fun addModeCB () = 
	  if isSome (!curSel) then 
	    let val (name, curType, mode, config) = get_details()
	    in
	      modifyTarget
		(name, curType, 
	         parse_name (Capi.Text.get_string modeConfig),
		 config);
	      Capi.Text.set_string (modeConfig, "");
	      changed := true;
	      updateDetails()
	    end
	  else ()

	(* addConfigCB:  changes the configuration of the selected
	   current target *)
	fun addConfigCB () = 
	  if isSome (!curSel) then 
	    let val (name, curType, mode, config) = get_details()
	    in
	      modifyTarget (name, curType, mode, 
			    parse_name (Capi.Text.get_string modeConfig));
	      Capi.Text.set_string (modeConfig, "");
	      changed := true;
	      updateDetails()
	    end
	  else ()

	val {update=updateMCbuttons, ...} = 
	  Menus.make_buttons (modeConfigRC,
		[Menus.PUSH ("PWT_addMode", addModeCB, isCurSel),
		 Menus.PUSH ("PWT_addConfig", addConfigCB, isCurSel)])
a1180 4
		 Capi.Layout.FIXED modeLabel,
		 Capi.Layout.FIXED configLabel,
		 Capi.Layout.FIXED modeConfig,
		 Capi.Layout.FIXED modeConfigRC,
a1195 1
		     updateMCbuttons();
@


1.5
log
@[Bug #30337]
Change uses of OS.Path.concat to take a string list, instead of a pair of strings.
@
text
@d3 4
d1468 8
d1477 6
a1482 4
	      location := dirName;
	      Capi.Text.set_string (locText, "");
	      modeChanged := true;
	      updateModes (!modes)
a1795 3
	       if isSome(details) then 
		 callerUpdate(valOf(details)) 
	       else ();
d1802 6
a1944 1
	val (_, _, curConfig) = ProjFile.getConfigurations()
d1946 1
a1946 1
	if (text <> "") andalso (text <> objDir) then 
d1949 1
a1949 1
	   callerUpdate (OS.Path.concat[text, getOpt(curConfig, "")]))
a1963 1
	val (_, _, curConfig) = ProjFile.getConfigurations()
d1968 1
a1968 1
	   callerUpdate (OS.Path.concat[text, getOpt(curConfig, "")]))
a1974 1
	val (_, _, curConfig) = ProjFile.getConfigurations()
d1986 1
a1986 1
	callerUpdate (OS.Path.concat[newValue, getOpt(curConfig, "")])
@


1.4
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d3 4
d221 6
a226 5
	if yesOrNo then 
	  if valOf(answer) then 
	    save_project parent
	  else false
	else false;
d255 1
a255 1
	   open_ok();
d465 1
a465 1
	  f (a, newPath);
d476 1
a476 1
	  f (a, newPath);
d604 1
a604 1
	  (set (map #1 (!path_items));
d723 1
a723 1
	   callerUpdate (map #1 (!subprojects));
d784 1
a784 1
	   apply();
d800 1
a800 1
	   apply();
d1129 1
a1129 1
	   callerUpdate (map #1 (!curTargets));
d1502 1
a1502 1
	       callerUpdate modeNames;
d1904 1
a1904 1
	    callerUpdate (list2str dirList);
d1933 1
a1933 1
	   callerUpdate (OS.Path.concat(text, getOpt(curConfig, ""))))
d1953 1
a1953 1
	   callerUpdate (OS.Path.concat(text, getOpt(curConfig, ""))))
d1972 1
a1972 1
	callerUpdate (OS.Path.concat(newValue, getOpt(curConfig, "")))
@


1.3
log
@[Bug #30071]
Fixing require bug.
@
text
@d3 4
d507 7
a513 2
	  Capi.make_main_popup ("propFilesDialog", title,
				parent, false, visible)
d624 1
a624 1
	  Capi.Layout.lay_out (frame, 
d700 7
a706 2
	  Capi.make_main_popup ("propSubProjectsDialog", "Project Properties - Subprojects", 
				parent, false, visible)
d838 1
a838 1
	  Capi.Layout.lay_out (frame, 
d890 6
a895 2
	  Capi.make_main_popup ("propTargetsDialog", "Project Properties - Targets", 
				parent, false, visible)
d1219 1
a1219 1
	  Capi.Layout.lay_out (frame, 
d1279 7
a1285 2
	  Capi.make_main_popup ("propModesDialog", "Project Properties - Modes", 
				parent, false, visible)
d1532 1
a1532 1
	  Capi.Layout.lay_out (frame, 
d1581 7
a1587 3
	  Capi.make_main_popup ("propConfigDialog", 
				"Project Properties - Configurations", 
				parent, false, visible)
d1832 1
a1832 1
	  Capi.Layout.lay_out (frame, 
d1977 7
a1983 2
	  Capi.make_main_popup ("propAboutDialog", "Project Properties - About Project", 
				parent, false, visible)
d2048 1
a2048 1
	  Capi.Layout.lay_out (frame, 
@


1.2
log
@new unit
[Bug #30071]
Project Properties of the new Project Workspace tool.
@
text
@d3 5
d81 1
a81 1
require "../bassi/__text_io";
@


1.1
log
@new file on MLWorks_workspace_97
@
text
@d1 2040
@


1.1.1.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a0 1425
(*
 * $Log: _proj_properties.sml,v $
 *
 * 
 * Copyright (C) 1997.  The Harlequin Group Limited.  All rights reserved.
 *
 *)

require "../utils/__lists";
require "../basis/__int";

require "../basis/list";
require "../main/machspec";
require "../main/toplevel";
require "../main/proj_file";

require "capi";
require "menus";
require "proj_properties";

functor ProjProperties (
  structure List: LIST
  structure MachSpec: MACHSPEC
  structure TopLevel: TOPLEVEL
  structure Capi: CAPI
  structure Menus: MENUS
  structure ProjFile: PROJ_FILE

  sharing type Capi.Widget = Menus.Widget
): PROJ_PROPERTIES = 
struct
  structure Options = TopLevel.Options

  type Widget = Capi.Widget

  val projNameSet = ref false

  type targetType = ProjFile.target_type
  type mode_details = ProjFile.mode_details
  type config_details = ProjFile.config_details

  fun find_space(arg as (s, i)) =
    if i >= size s orelse MLWorks.String.ordof arg = ord #" " then
      i
    else
      find_space(s, i+1)

  fun ignore_spaces(arg as (s, i)) =
    if i >= size s orelse MLWorks.String.ordof arg <> ord #" " then
      i
    else
      ignore_spaces(s, i+1)

  (* parse_name removes leading and trailing spaces from the input name *)
  fun parse_name name =
    let
      val i = ignore_spaces(name, 0)
    in
      if i >= size name then
        ""
      else
        substring (name, i, (find_space (name, i)) -i)
    end

  fun renumber_up (s, n) = (s, n + 1)
  fun renumber_down (s, n) = (s, n - 1)

  fun confirm_save parent = 
    (Capi.send_message (parent, "Saved project to " ^ ProjFile.getProjectName());
     true)

  fun save_project parent = 
    if (!projNameSet) then 
      (ProjFile.save_proj (ProjFile.getProjectName());
       confirm_save parent)
    else
      let val filename = Capi.save_as_dialog (parent, ".mlp")
      in
        if isSome(filename) then
	  (ProjFile.save_proj (valOf(filename));
	   projNameSet := true;
	   confirm_save parent)
	else false
      end

  (* returns false iff the user clicks cancel *)
  fun test_save parent = 
    if (ProjFile.getProjectName() <> "") then
      let 
        val askSave = Capi.makeYesNoCancel (parent, "Save the current project?", true)
	val answer = askSave()
	val yesOrNo = isSome answer
      in 
	if yesOrNo then 
	  if valOf(answer) then 
	    ProjFile.save_proj (ProjFile.getProjectName())
	  else ()
	else ();
	yesOrNo
      end
    else true

  fun new_project parent = 
    if test_save parent then 
      (ProjFile.setProjectName "untitled.mlp";
       projNameSet := false;
       ProjFile.initialize())
    else ()

  fun open_project parent = 
    if test_save parent then 
      let val filename = Capi.open_file_dialog (parent, ".mlp")
      in
        if isSome(filename) then 
	  (ProjFile.open_proj (valOf(filename));
	   projNameSet := true;
	   true)
	else false
      end
    else false

  local 
    fun get_file shell =
      case Capi.open_file_dialog (shell, ".sml") of
	 SOME s => s
      |  NONE => ""

    datatype dirExist = MAY_EXIST | MUST_EXIST

    fun get_directory (shell, exist) =
      let 
	val dirOpt = 
	  if (exist = MUST_EXIST) then 
	    Capi.open_dir_dialog shell
	  else
	    Capi.set_dir_dialog shell
      in
	case dirOpt of 
           SOME s => s
        |  NONE => ""
      end

    fun list2str [] = ""
      | list2str (h::t) = h ^ "; " ^ list2str t

    fun number_entries ([], _) = []
      | number_entries (h::t, n) = (h, n) :: number_entries (t, n + 1)
    
    exception PW_Find
    fun find_nth n [] = raise PW_Find
      | find_nth n' ((h as (s, n))::t) = 
          if n = n' then (s,n) else find_nth n' t

    (* is_in, get_position, and moveup functions operate on lists of tuples of
     * type (string * int).  The items in the list are numerically ordered *)

    fun is_in (n:string, []) = false
      | is_in (n, (n', _)::t) = n = n' orelse is_in (n, t)
	infix is_in

    fun get_position (s, []) = 0
      | get_position (s, (s', n) :: rest) = 
          if s = s' then n
           else get_position (s, rest)

    (* moveup: moves the given tuple item one place up the list *)
    fun moveup (s,n) [] = []
      | moveup (s,n) (h::t) = 
         if (s = #1 h) then
           (s,n - 1)::(moveup (s,n) t)
         else
           if (n - 1 = #2 h) then
    	     (#1 h, n)::(moveup (s,n) t)
           else 
    	     h::(moveup (s,n) t)

    fun remove_nth ([], _) = []
      | remove_nth (h::t, n) =
        if n = #2 h then
          map renumber_down t
        else
          h :: remove_nth (t, n)

    (* moveup:  function for moving an item in a listbox. 
     * The function takes the item to be moved up, the list of items, a 
     * selection reference, and the (dec/inc)rement of the move.
     *)
    fun move (s,n) item_list (sel, changed) inc = 
      if ((s,n) <> ("",0) andalso (n > 1) andalso (item_list <> [])) then
        let 
          val result = moveup (s,n) item_list 
          val (name, pos) = valOf(!sel)
        in
          sel := SOME (find_nth (pos + inc) result);
	  changed := true;
          result
        end
      else item_list

    (* removeSelCB:  generalised function for removing a selection from a listbox.
     * The function takes the selection reference, the items list reference, and 
     * an update function for redisplaying the list and any other redisplay that may
     * be necessary.
     *)
    fun removeSelCB (sel, items, changed) updateFn =
      if isSome (!sel) then 
        let 
          val (name, pos) = valOf(!sel)
          val new_items = remove_nth (!items, pos)
        in
          if new_items = [] then 
            sel := NONE
          else 
            sel := SOME (find_nth 1 new_items);
	  changed := true;
          updateFn new_items
        end
      else ()

    fun moveUpCB (sel_ref, items_ref, changed) update_fn = 
      if (isSome (!sel_ref)) then 
	 update_fn (move (valOf (!sel_ref)) (!items_ref) (sel_ref, changed) (~1))
      else ()

    fun moveDownCB (sel_ref, items_ref, changed) update_fn = 
      if (isSome (!sel_ref)) then
        let 
          val item_below = find_nth (#2 (valOf (!sel_ref)) + 1) (!items_ref)
    			handle PW_Find => ("",0)
          val new_items = move item_below (!items_ref) (sel_ref, changed) 1
        in
          update_fn new_items
        end
      else ()

    (* select_fn:  function that is called when a selection is made in a listbox. *)
    fun select_fn store _ (s,n) = store := SOME (s,n)

    fun print_fn _ (s,_) = s
    fun action_fn _ _ = ()

    (* mk_list:  general function for creating a listbox control.
     *  Takes a tuple of parent shell, and name of listbox followed by curried args 
     *  of the selection reference, a function reference (+), and the item list 
     *	reference.  The function returns the list widget, and an update function 
     *  which can be called to update the display of the listbox control.
     * The passed update function is called when the user selects an item in the 
     * list and also when the returned update function is called. 
     *)
    fun mk_list (parent, name) sel_ref update_ref items_ref = 
      let
        fun selectFn opts (s,n) = (select_fn sel_ref opts (s,n); (!update_ref)())

        val {scroll, list, set_items, add_items} =
          Capi.make_scrolllist
    			{parent = parent,
    			 name = name,
    			 select_fn = selectFn,
    			 action_fn = action_fn,
    			 print_fn = print_fn}

        fun update new_items = 
          (items_ref := Lists_.msort (fn ((a,b), (a',b')) => b < b') new_items;
           set_items Options.default_print_options (!items_ref);
           if isSome(!sel_ref) then
	     let 
		val pos = #2 (valOf (!sel_ref))
		val set_pos = if (pos > 2) then pos - 2 else 1
	     in
		Capi.List.select_pos (list, pos, false);
		Capi.List.set_pos (list, set_pos)
	     end
           else
             ();
           (!update_ref)())
      in
        (scroll, update)
      end

    fun mkCloseButtons {parent, apply, reset, close, changeRef} = 
      let 
	val closeRC = Capi.make_managed_widget 
				("closeRC", Capi.RowColumn, parent, [])

	fun ok () = (apply(); close())
	fun cancel () = (reset(); close())

	val {update, ...} = 
	  Menus.make_buttons (closeRC, 
		[Menus.PUSH ("PWP_Ok", ok, fn _ => true),
		 Menus.PUSH ("PWP_Apply", apply, fn _ => (!changeRef)),
		 Menus.PUSH ("PWP_Reset", reset, fn _ => (!changeRef)),
		 Menus.PUSH ("PWP_Cancel", cancel, fn _ => true)])
      in
	(closeRC, update)
      end

  in

    (* mk_path_dialog:  creates a dialog which allows the user to construct a path.
     *  Takes the parent shell and two functions:
     * get: unit -> string list:  a function to display the initial path when the dialog
     * 				  is brought up.
     * set: string list -> unit:  a function to set the path given a new list of 
     * 				  directories.
     *)
    fun mk_path_dialog (parent, title, get, set) = 
      let 
	val visible = ref false
	val pathChanged = ref false

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propFilesDialog", title,
				parent, false, visible)
	val label = Capi.make_managed_widget 
				("PWF_propFilesLabel", Capi.Label, frame, [])

        val path_items = ref (number_entries (get(), 1))

	val dir_selection = 
	  ref (if !path_items = [] 
		then NONE 
		else SOME (find_nth 1 (!path_items)))

	(* This update function is called when set_new_path is called or when 
	 * a selection is made in the listbox control. 
	 *)
	val update_ref = ref (fn () => ())

	val (scroll, set_new_path) = 
	  mk_list (frame, "file_list")
	    dir_selection update_ref path_items

	fun addNewCB () = 
	  let val dir = get_directory (shell, MUST_EXIST)
	  in
	    if dir = "" orelse dir is_in !path_items then ()
	    else 
	      let
	        val new_path_items = 
		  (dir, 1) :: (map renumber_up (!path_items))
	      in
		dir_selection := SOME (dir, 1);
		pathChanged := true;
		set_new_path new_path_items		
	      end
	  end

	fun removeAllCB () = 
	  (dir_selection := NONE;
	   pathChanged := true;
	   set_new_path [])

	fun removeSel () = removeSelCB (dir_selection, path_items, pathChanged) set_new_path
	fun moveUp () = moveUpCB (dir_selection, path_items, pathChanged) set_new_path
	fun moveDown () = moveDownCB (dir_selection, path_items, pathChanged) set_new_path

	val removeRC = Capi.make_managed_widget 
				("PWF_removeRC", Capi.RowColumn, frame, [])

	val {update, ...} = 
	  Menus.make_buttons (removeRC, 
		[Menus.PUSH ("PWF_addButton", addNewCB, fn _ => true),
		 Menus.PUSH ("PWF_moveUp", moveUp, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_moveDown", moveDown, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_removeSel", removeSel, fn () => isSome (!dir_selection)),
		 Menus.PUSH ("PWF_removeAll", removeAllCB, fn () => true)])

	fun apply () = 
	  (set (map #1 (!path_items));
	   pathChanged := false;
	   set_new_path (!path_items))

	fun reset () = 
	  (path_items := number_entries (get(), 1);
	   dir_selection := NONE;
	   pathChanged := false;
	   set_new_path (!path_items))

	fun close () = 
	  (reset();
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changeRef = pathChanged}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX scroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED removeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

    in
      Capi.remove_menu menuBar;
      Capi.set_close_callback (frame, close);
      do_layout();

      update_ref := (fn () => (update(); updateCloseButtons()));

      (* returns two functions:
       * update_fn: ((string list -> unit) -> string -> unit)
       *  This function takes a callerUpdate function (see mk_path_dialog call
       *    from ProjWorkspace), creates the path dialog, and returns a function
       *    which displays the dialog showing the correct label at the top 
       *    (ie. to indicate what the dialog is for).
       * close_fn: (unit -> unit)
       *  This function is called in two places:  one by the caller when the caller
       *  needs the path dialog to be hidden, and one by the close callback when the 
       *  user explicitly closes the dialog.
       *)
     ((fn miniTitle => 
	   (Capi.set_label_string (label, miniTitle);
    	    visible := true;
    	    set_new_path (!path_items);
    	    Capi.reveal frame;
    	    Capi.reveal shell;
    	    Capi.to_front shell)),
      close)
    end

    fun mk_source_dialog (parent, updatePath) = 
      let 
	val (mk_new_path_dialog, closePathDialog) = 
          mk_path_dialog (parent,
		       	  "Project Properties - Files", 
	    		  ProjFile.getSourcePath,
			  fn newPath => (ProjFile.setSourcePath newPath;
				         updatePath newPath))

        fun path_dialog () = 
	  mk_new_path_dialog 
    	    "Ordered list of directories where ML source files are found:"
      in
	(path_dialog, closePathDialog)
      end

    fun mk_targets_dialog (parent, callerUpdate) = 
      let 
	val changed = ref false
	val curSel = ref NONE
	val LdisTargets = ref []
	val LcurTargets = ref []
	val LtargetDetails = ref []

	fun isCurSel () = isSome(!curSel)

	val disSel = ref NONE

	val visible = ref false
	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propTargetsDialog", "Project Properties - Targets", 
				parent, false, visible)
	val label = Capi.make_managed_widget 
				("PWT_targetsLabel", Capi.Label, frame, [])

	(* Rowcolumn widget which stores five buttons:
	 * addTarget for selecting a new (current) target to add to the list,
	 * moveUp for moving a target up the ordered list - to be built earlier.
	 * moveDown for moving a target down the build order.
	 * disable for disabling the selected target.
	 * reomveTarget for removing the selected target from the list.
	 *)
	val targetRC = Capi.make_managed_widget 
				("PWT_targetRC", Capi.RowColumn, frame, [])

	(* addDetails: takes a list of targets ((name, pos) tuples) and returns a
	 * list of the details of the specified targets.
	 * This is used to keep the targetDetails list consistent with the all the 
	 * targets (inc disabled ones) by:  LtargetDetails := addDetails <allTargets>;
	 *)
	fun addDetails [] = []
	  | addDetails ((name, p)::t) = 
	      let 
		val details = List.find (fn (n,_,_,_) => n=name) (!LtargetDetails)
	      in
		if isSome details then
		  valOf(details) :: (addDetails t)
		else
		  (name, ProjFile.EXECUTABLE, "", "") :: (addDetails t)
	      end

	(* This update function is called whenever a selection of the current 
	 * targets is made - see end of mk_targets_dialog function where this 
	 * reference is set.
         *) 
	val updateTargetsRef = ref (fn () => ())

	(* List of all current targets *)
	val (curScroll, updateTargets) = 
	  mk_list (frame, "curList")
		   curSel 
		   updateTargetsRef
		   LcurTargets

	(* Modifies the details associated with the selected current target *)
	fun modifyTarget (name, tarType, mode, config) = 
	  let 
	    val (name', t, m, c) = 
	      valOf (List.find (fn (n,_,_,_) => n=name) (!LtargetDetails))
	    val others = List.filter (fn (n,_,_,_) => n <> name) (!LtargetDetails);
	  in 
	    LtargetDetails := (name, tarType, mode, config) :: others
	  end

	(* get_details:  get the details of the selected current target *)
	fun get_details () = 
	  ProjFile.getTargetDetails ((#1 (valOf (!curSel))), !LtargetDetails)

	(* Adds a new target to the list of current targets if it isn't already 
	 * in the current targets OR in the disabled targets.
	 *)
	fun addTargetCB () = 
	  let val text = get_file shell
	  in 
	    if not (text is_in (!LcurTargets) orelse text is_in (!LdisTargets)) 
		 andalso text <> "" then 
	      let 
		val new_targets = (text,1) :: (map renumber_up (!LcurTargets))
	      in
		curSel := SOME (text,1);
		changed := true;
		updateTargets new_targets
	      end
	    else ()
	  end

	val disableLabel = Capi.make_managed_widget
				("PWT_disableLabel", Capi.Label, frame, [])

	local 
	  fun tarType () = 
	    if isCurSel() then 
	      SOME (#2 (get_details ()))
	    else NONE

	  fun setType whichType = 
	    if isCurSel() then 
	      let val (name, curType, mode, config) = get_details()
	      in
		changed := true;
		modifyTarget (name, whichType, mode, config);
		updateTargets (!LcurTargets)
	      end
	    else ()

	in
	  fun is_exe () = tarType() = SOME ProjFile.EXECUTABLE
	  fun is_dynlib () = tarType() = SOME ProjFile.LIBRARY
	  fun is_image () = tarType() = SOME ProjFile.IMAGE
	  fun is_objfile () = tarType() = SOME ProjFile.OBJECT_FILE

	  fun set_exe b = if b then setType ProjFile.EXECUTABLE else ()
	  fun set_dynlib b = if b then setType ProjFile.LIBRARY else ()
	  fun set_image b = if b then setType ProjFile.IMAGE else ()
	  fun set_objfile b = if b then setType ProjFile.OBJECT_FILE else ()
	end

	val typesRC = Capi.make_managed_widget
				("PWT_typesRC", Capi.RowColumn, frame, [])

	val {update=updateTypes, ...} = 
	  Menus.make_buttons (typesRC, 
	    [Menus.RADIO ("PWT_exeRadio",    is_exe,    set_exe,     fn () => true),
	     Menus.RADIO ("PWT_dynlibRadio", is_dynlib, set_dynlib,  fn () => true),
	     Menus.RADIO ("PWT_imageRadio",  is_image,  set_image,   fn () => true),
	     Menus.RADIO ("PWT_objfileRadio",is_objfile,set_objfile, fn () => true)])

	val modeLabel = Capi.make_managed_widget
				("PWT_modeLabel", Capi.Label, frame, [])
	val configLabel = Capi.make_managed_widget
				("PWT_configLabel", Capi.Label, frame, [])

	val updateDisabledRef = ref (fn () => ())

	(* updateDetails needs to be called by the select_fn as well as the 
	 * returned update function.
	 *)
	val (disScroll, updateDisabled) = 
	  mk_list (frame, "disList")
	    disSel updateDisabledRef LdisTargets

	(* Disables the selected current target - adds it to the list of 
	 * disabled targets and removes it from the list of current targets.
	 * The order of this operation is important - it must be added to the
	 * list first otherwise, during updating, the details of the target
	 * are lost.
	 *)
	fun disableCB () = 
	  if isCurSel() then 
	    let 
	      val (s,n) = valOf(!curSel)
	      val new_disabled = (s,1) :: (map renumber_up (!LdisTargets))
	    in
	      disSel := SOME (s,1);
	      removeSelCB (curSel, LcurTargets, changed) updateTargets;
	      updateDisabled new_disabled
	    end
	  else ()

	(* Enables the selected disabled target - adds it to the list of
	 * current targets and removes it from the list of current targets.
	 * The order of this operation is important - it must be added to the
	 * list first otherwise, during updating, the details of the target
	 * are lost.
	 *)
	fun enableCB () = 
	  if isSome(!disSel) then 
	    let 
	      val (s,n) = valOf(!disSel)
	      val new_enabled = (s,1) :: (map renumber_up (!LcurTargets))
	    in
	      curSel := SOME (s,1);
	      removeSelCB (disSel, LdisTargets, changed) updateDisabled;
	      updateTargets new_enabled
	    end
	  else ()

	val delTarget = 
	  Capi.makeYesNoCancel (shell, "Remove the selected target?", false)

	(* When removing a target, the selected disabled target (if any) is 
	 * deselected so that the user is clear as to which target is being 
	 * removed, ie. the selected CURRENT target.
	 *)
	fun removeTarget () = 
	  (disSel := NONE; 
	   updateDisabled (!LdisTargets);
	   if valOf(delTarget()) then 
	     (changed := true;
	     removeSelCB (curSel, LcurTargets, changed) updateTargets)
	   else ())

	fun moveUp () = moveUpCB (curSel, LcurTargets, changed) updateTargets
	fun moveDown () = moveDownCB (curSel, LcurTargets, changed) updateTargets

	val {update=updateTargetButtons, ...} = 
	  Menus.make_buttons (targetRC, 
		[Menus.PUSH ("PWT_addTarget", addTargetCB, fn _ => true),
		 Menus.PUSH ("PWT_moveUp", moveUp, isCurSel),
		 Menus.PUSH ("PWT_moveDown", moveDown, isCurSel),
		 Menus.PUSH ("PWT_disable", disableCB, isCurSel),
		 Menus.PUSH ("PWT_removeTarget", removeTarget, isCurSel)])

	val disableRC = Capi.make_managed_widget 
				("PWT_disableRC", Capi.RowColumn, frame, [])

	val {update=updateDisableButtons, ...} = 
	  Menus.make_buttons (disableRC, 
		[Menus.PUSH ("PWT_enableTarget", enableCB, fn _ => isSome(!disSel))])

	val detailsLabel = Capi.make_managed_widget
				("PWT_detailsLabel", Capi.Label, frame, [])
	val typeLabel = Capi.make_managed_widget
				("PWT_typeLabel", Capi.Label, frame, [])

	val modeConfig = Capi.make_managed_widget
				("PWT_modeConfig", Capi.Text, frame, [])
	val modeConfigRC = Capi.make_managed_widget 
				("PWT_modeConfigRC", Capi.RowColumn, frame, [])

	fun update () = 
	  (updateTargets (!LcurTargets);
	   updateDisabled (!LdisTargets))

	fun apply () = 
	  (ProjFile.setTargets (map #1 (!LcurTargets), 
				map #1 (!LdisTargets), 
				!LtargetDetails);
	   changed := false;
	   update();
	   callerUpdate (map #1 (!LcurTargets)))

	fun reset () = 
	  let 
	    val (current, disabled, details) = ProjFile.getTargets ()
	  in
	    LcurTargets := number_entries (current, 1);
	    LdisTargets := number_entries (disabled, 1);
	    LtargetDetails := details;
	    curSel := NONE;
	    disSel := NONE;
	    changed := false;
	    update()
	  end

	(* On closing the dialog, the selections in the listbox must be desselected,
	 * for the following reason:  if a NewProject command is given, the reference
	 * lists are reset, but the selection references are not as they are out of 
	 * scope, so when NewProject command is given, the dialogs are closed to 
	 * reset the selection references to avoid inconsistencies. 
	 *)
	fun close () = 
	  (reset ();
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changeRef = changed}

	(* Updates the display of the details of the selected current target *)
	fun updateDetails () = 
	  (updateTypes();
	   updateCloseButtons();
	   let 
	     val (_,_, mode, config) = 
	       if isCurSel() then get_details() else ("", ProjFile.EXECUTABLE, "", "")
	   in
	     Capi.set_label_string (modeLabel, "Mode:  " ^ mode);
	     Capi.set_label_string (configLabel, "Configuration:  " ^ config)
	   end)

	(* addModeCB:  changes the mode of the selected current target *)
	fun addModeCB () = 
	  if isSome (!curSel) then 
	    let val (name, curType, mode, config) = get_details()
	    in
	      modifyTarget (name, curType, 
			    parse_name (Capi.Text.get_string modeConfig), config);
	      Capi.Text.set_string (modeConfig, "");
	      updateDetails()
	    end
	  else ()

	(* addModeCB:  changes the configuration of the selected current target *)
	fun addConfigCB () = 
	  if isSome (!curSel) then 
	    let val (name, curType, mode, config) = get_details()
	    in
	      modifyTarget (name, curType, mode, 
			    parse_name (Capi.Text.get_string modeConfig));
	      Capi.Text.set_string (modeConfig, "");
	      updateDetails()
	    end
	  else ()

	val {update=updateMCbuttons, ...} = 
	  Menus.make_buttons (modeConfigRC,
		[Menus.PUSH ("PWT_addMode", addModeCB, isCurSel),
		 Menus.PUSH ("PWT_addConfig", addConfigCB, isCurSel)])

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX curScroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED targetRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED disableLabel,
		 Capi.Layout.FIXED disScroll,
		 Capi.Layout.FIXED disableRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED detailsLabel,
		 Capi.Layout.FIXED typeLabel,
		 Capi.Layout.FIXED typesRC,
		 Capi.Layout.FIXED modeLabel,
		 Capi.Layout.FIXED configLabel,
		 Capi.Layout.FIXED modeConfig,
		 Capi.Layout.FIXED modeConfigRC,
		 Capi.Layout.SPACE, 
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in
	(* Steps in updating the targets (order not important):
	 * 1)	Keep LtargetDetails consistent with targets
	 * 2)	Update sensitivity of buttons applying to list of current targets
	 * 3)	Call the update function passed in by the caller
	 * 4)	Update buttons for changing the mode and configuration of a target
	 * 5)	Update the display of the details of the selected current target
	 *)
	updateTargetsRef := 
	  (fn () => (LtargetDetails := addDetails ((!LcurTargets) @@ (!LdisTargets));
		     updateTargetButtons();
		     updateMCbuttons();
		     updateDetails()));
	updateDisabledRef := 
	  (fn () => (updateDisableButtons();
		     updateCloseButtons()));

	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 close)
      end  (* mk_targets_dialog *)

    (* This caller update function isn't needed as in prop_config_dialog *)
    fun mk_modes_dialog (parent, callerUpdate) =
      let
	val modeSel = ref NONE
	val modeChanged = ref false
	val Lmodes = ref []
	val LmodeDetails = ref ([]: mode_details list)

	val visible = ref false
	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propModesDialog", "Project Properties - Modes", 
				parent, false, visible)
	val label = Capi.make_managed_widget 
				("PWM_modeLabel", Capi.Label, frame, [])

	fun get_mode_details () = 
	  ProjFile.getModeDetails (#1 (valOf (!modeSel)), !LmodeDetails)

	val modeList = 
	  [("PWM_genInterruptCode"),
	   ("PWM_genInterceptCode"),
	   ("PWM_genDebugInfo"),
	   ("PWM_genVarDebugInfo"),
	   ("PWM_optLeaf"),
	   ("PWM_optTail"),
	   ("PWM_optSelfTail")] @@ 
          (case MachSpec.mach_type of
             MachSpec.MIPS =>  [("PWM_mipsR4000")]
           | MachSpec.SPARC => [("PWM_sparcV7")]
           | MachSpec.I386 =>  [])

	fun getBoolRef s (r: mode_details) = 
	  case s of 
	     "PWM_genInterruptCode" 	=> #generate_interruptable_code r
           | "PWM_genInterceptCode" 	=> #generate_interceptable_code r
      	   | "PWM_genDebugInfo"		=> #generate_debug_info r
      	   | "PWM_genVarDebugInfo"	=> #generate_variable_debug_info r
    	   | "PWM_optLeaf"		=> #optimize_leaf_fns r
    	   | "PWM_optTail"		=> #optimize_tail_calls r
      	   | "PWM_optSelfTail"		=> #optimize_self_tail_calls r
       	   | "PWM_mipsR4000"		=> #mips_r4000 r
       	   | "PWM_sparcV7"		=> #sparc_v7 r
     	   | _ => ref false

	val updateModesRef = ref (fn () => ())

	val (modeScroll, updateModes) = 
	  mk_list (frame, "modeList")
	    modeSel updateModesRef Lmodes

	fun modeGet s () = 
	  if isSome (!modeSel) then 
	    let val details = get_mode_details()
	    in !(getBoolRef s details)
	    end
	  else false

	fun modeSet s value = 
	  if isSome (!modeSel) then 
	    let val details = get_mode_details()
	    in
	      (getBoolRef s details) := value;
	      modeChanged := true;
	      updateModes (!Lmodes)
	    end
	  else ()

	fun addModeDetails [] = []
	  | addModeDetails ((name, p)::t) = 
	    let 
	      val details = 
		List.find (fn {name=n,...} => name=n) (!LmodeDetails)
	    in
	      if isSome details then
		valOf(details) :: (addModeDetails t)
	      else
		{name = name,
		 generate_interruptable_code  = ref true,
		 generate_interceptable_code  = ref false,
		 generate_debug_info		= ref false,
		 generate_variable_debug_info = ref false,
		 optimize_leaf_fns		= ref true,
		 optimize_tail_calls		= ref true,
		 optimize_self_tail_calls	= ref true,
		 mips_r4000			= ref false,
		 sparc_v7			= ref false} :: (addModeDetails t)
	    end

	fun create_opt s = 
	  let 
	    val detailsRC = Capi.make_managed_widget
				("PWM_detailsRC", Capi.RowColumn, frame, [])
	    val {update, ...} = 
	      Menus.make_buttons (detailsRC, 
		[Menus.TOGGLE (s, modeGet s, modeSet s, fn _ => true)])
	  in
	    (detailsRC, update)
	  end

	val details = map create_opt modeList

	fun updateModeDetails () = 
	  (LmodeDetails := addModeDetails (!Lmodes);
	   app (fn a => (#2 a)()) details)

	val modesRC = Capi.make_managed_widget 
				("PWM_modesRC", Capi.RowColumn, frame, [])

	fun removeModeCB () = removeSelCB (modeSel, Lmodes, modeChanged) updateModes
	fun setCurModeCB () = ()

	val {update=updateModeButtons, ...} = 
	  Menus.make_buttons (modesRC, 
		[Menus.PUSH ("PWM_removeMode", removeModeCB, fn _ => isSome(!modeSel)),
		 Menus.PUSH ("PWM_setCurMode", setCurModeCB, fn _ => isSome(!modeSel))])

	val newMode = Capi.make_managed_widget
				("PWM_newMode", Capi.Text, frame, [])

	val addModeRC = Capi.make_managed_widget 
				("PWM_addModeRC", Capi.RowColumn, frame, [])

	fun addModeCB () = 
	  let 
	    val mode = parse_name (Capi.Text.get_string newMode)
	  in 
	    if not (mode is_in (!Lmodes)) andalso mode <> "" then 
	      let 
		val new_modes = (mode,1) :: (map renumber_up (!Lmodes))
	      in
		modeSel := SOME (mode,1);
		Capi.Text.set_string (newMode, "");
		modeChanged := true;
		updateModes new_modes
	      end
	    else ()
	  end

	val {update, ...} = 
	  Menus.make_buttons (addModeRC, 
		[Menus.PUSH ("PWM_addMode", addModeCB, fn _ => true)])

	val modeDetailsLabel = Capi.make_managed_widget 
				("PWM_modeDetailsLabel", Capi.Label, frame, [])

	fun update () = updateModes (!Lmodes)

	fun apply () = 
	  (ProjFile.setModes (map #1 (!Lmodes), !LmodeDetails);
	   callerUpdate (map #1 (!Lmodes));
	   modeChanged := false;
	   update())

	fun reset () = 
	  let 
	    val (modeList, details) = ProjFile.getModes()
	  in
	    Lmodes := number_entries (modeList, 1);
	    LmodeDetails := details;
	    modeChanged := false;
	    modeSel := NONE;
	    update()
	  end

	fun close () = 
	  (reset();
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changeRef = modeChanged}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX modeScroll,
		 Capi.Layout.FIXED modesRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED newMode,
		 Capi.Layout.FIXED addModeRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED modeDetailsLabel] @@ 
		(map Capi.Layout.FIXED (map (fn (a,b) => a) details)) @@
		[Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in
 	updateModesRef := (fn () => (updateModeDetails(); 
				     updateCloseButtons();
				     updateModeButtons()));
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 close)
      end  (* mk_modes_dialog *)

    fun mk_configs_dialog parent = 
      let
	val configSel = ref NONE
	val pathSel = ref NONE
	val configChanged = ref false
	val Lconfigs = ref []
	val LconfigDetails = ref ([]: ProjFile.config_details list)

	fun is_sel () = isSome(!configSel)

	fun modifyConfigDetails ((n, source, lib, obj, bin), configRef) = 
	  ProjFile.modifyConfigDetails
		({name=n, source=source, library=lib, objects=obj, bins=bin}, !configRef)
	fun get_cf_details () = 
	  ProjFile.getConfigDetails (#1 (valOf (!configSel)), !LconfigDetails)

	val visible = ref false
	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propConfigDialog", "Project Properties - Configurations", 
				parent, false, visible)
	val label = Capi.make_managed_widget 
				("PWC_configLabel", Capi.Label, frame, [])

	val configUpdateRef = ref (fn () => ())

	val (configScroll, updateConfigs) = 
	  mk_list (frame, "configList")
	    configSel configUpdateRef Lconfigs

	val configRC = Capi.make_managed_widget 
				("PWC_configRC", Capi.RowColumn, frame, [])

	fun removeConfigCB () = removeSelCB (configSel, Lconfigs, configChanged) updateConfigs
	fun setCurConfigCB () = ()

	val {update=updateConfigButtons, ...} = 
	  Menus.make_buttons (configRC, 
		[Menus.PUSH ("PWC_removeConfig", removeConfigCB, is_sel),
		 Menus.PUSH ("PWC_setCurConfig", setCurConfigCB, is_sel)])

	val addConfig = Capi.make_managed_widget
				("PWC_addConfig", Capi.Text, frame, [])

	fun addConfigCB () =
	  let 
	    val config = parse_name (Capi.Text.get_string addConfig)
	  in 
	    if not (config is_in (!Lconfigs)) andalso config <> "" then 
	      let 
		val new_configs = (config,1) :: (map renumber_up (!Lconfigs))
	      in
		configSel := SOME (config,1);
		Capi.Text.set_string (addConfig, "");
		configChanged := true;
		updateConfigs new_configs
	      end
	    else ()
	  end

	val addConfigRC = Capi.make_managed_widget 
				("PWC_addConfigRC", Capi.RowColumn, frame, [])

	val {update, ...} = 
	  Menus.make_buttons (addConfigRC, 
		[Menus.PUSH ("PWC_addConfig", addConfigCB, fn _ => true)])

	val sourceLabel = Capi.make_managed_widget 
				("PWC_sourceLabel", Capi.Label, frame, [])
	val sourceText = Capi.make_managed_widget 
				("PWC_sourceText", Capi.Text, frame, [])

	val libraryLabel = Capi.make_managed_widget 
				("PWC_libraryLabel", Capi.Label, frame, [])
	val libraryText = Capi.make_managed_widget 
				("PWC_libraryText", Capi.Text, frame, [])

	val configPathRC = Capi.make_managed_widget 
				("PWC_configPathRC", Capi.RowColumn, frame, [])

	fun getConfigSourcePath () = 
	  if is_sel() then 
	    #source (get_cf_details())
	  else []

	fun setConfigSourcePath theList = 
	  let val {name, source, library, objects, bins} = get_cf_details()
		(* WWW: get_cf_details may raise an exception if !configSel is NONE, 
		 *	BUT this should never be the case here *)
	  in
	    LconfigDetails := 
		modifyConfigDetails ((name, theList, library, objects, bins), 
				     LconfigDetails);
	    configChanged := true;
 	    updateConfigs (!Lconfigs);
	    Capi.Text.set_string (sourceText, list2str theList)
	  end

	val sourcePath = mk_path_dialog (shell,
					 "Configuration Source Path", 
			    		 getConfigSourcePath,
			    		 setConfigSourcePath)

	fun getConfigLibraryPath () = 
	  if is_sel() then 
	    #library (get_cf_details())
	  else []

	fun setConfigLibraryPath theList =
	  let val {name, source, library, objects, bins} = get_cf_details()
		(* WWW: get_cf_details may raise an exception if !configSel is NONE, 
		 *	BUT this should never be the case here *)
	  in
	    LconfigDetails := 
		modifyConfigDetails ((name, source, theList, objects, bins), 
				     LconfigDetails);
	    configChanged := true;
	    updateConfigs (!Lconfigs);
	    Capi.Text.set_string (libraryText, list2str theList)
	  end

	val libPath = mk_path_dialog (shell,
				      "Configuration Library Path", 
			    	      getConfigLibraryPath,
			    	      setConfigLibraryPath)

	fun setPathCB (setPath, closeDialog) () =
	  if is_sel() then 
	    (pathSel := (!configSel);
	    setPath (#1 (valOf (!configSel))))
	  else
	    closeDialog()

	val objLabel = Capi.make_managed_widget 
				("PWC_objLabel", Capi.Label, frame, [])
	val binLabel = Capi.make_managed_widget 
				("PWC_binLabel", Capi.Label, frame, [])

	fun updateObjBinLabels (objLoc, binLoc) = 
	  (Capi.set_label_string (objLabel, "Location for object files:  " ^ objLoc);
	   Capi.set_label_string (binLabel, "Location for binary files:  " ^ binLoc))

	fun addObjBinCB objectChange () = 
	  if is_sel() then 
	    let 
	      val text = get_directory (shell, MAY_EXIST)
	      val {name, source, library, objects, bins} = get_cf_details()
	      val (obj, bin) = 
		if objectChange then (text, bins) else (objects, text)
	    in 
	      if text <> "" then 
	        (LconfigDetails := 
		    modifyConfigDetails ((name, source, library, obj, bin), 
					 LconfigDetails);
		configChanged := true;
		updateConfigs (!Lconfigs);
		updateObjBinLabels (obj, bin))
	      else ()
	    end
	  else ()

	val {update=updateSetButtons, ...} = 
	  Menus.make_buttons (configPathRC, 
		[Menus.PUSH ("PWC_sourcePath", setPathCB sourcePath, is_sel),
		 Menus.PUSH ("PWC_libraryPath", setPathCB libPath, is_sel),
		 Menus.PUSH ("PWC_addObjLoc", addObjBinCB true, is_sel),
		 Menus.PUSH ("PWC_addBinLoc", addObjBinCB false, is_sel)])

	fun addCFdetails [] = []
	  | addCFdetails ((configName, p)::t) = 
	      let 
		val details = 
		  List.find (fn {name=n, ...} => n = configName) (!LconfigDetails)
	      in
		if isSome details then
		  valOf(details) :: (addCFdetails t)
		else
		  {name = configName, 
		   source = [],
		   library = [],
		   objects = "",
		   bins = ""} :: (addCFdetails t)
	      end

	fun apply () = 
	  (ProjFile.setConfigurations (map #1 (!Lconfigs), !LconfigDetails);
	   configChanged := false;
	   updateConfigs (!Lconfigs))

	fun reset () = 
	  let 
	    val (configList, details) = ProjFile.getConfigurations()
	  in
	    Lconfigs := number_entries (configList, 1);
	    LconfigDetails := details;
	    configChanged := false;
	    configSel := NONE;
	    updateConfigs (!Lconfigs)
	  end

	fun close () = 
	  (reset();
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changeRef = configChanged}

	fun updateCFdetails () = 
	  (LconfigDetails := addCFdetails (!Lconfigs);
	   updateCloseButtons();
	   if is_sel() then 
	     let 
	       val {name, source, library, objects, bins} = get_cf_details()
	     in
	       Capi.Text.set_string (sourceText, list2str source);
	       Capi.Text.set_string (libraryText, list2str library);
	       updateObjBinLabels (objects, bins)
	     end
	   else ())

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED label,
		 Capi.Layout.FLEX configScroll,
		 Capi.Layout.FIXED configRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED addConfig,
		 Capi.Layout.FIXED addConfigRC,
		 Capi.Layout.FIXED sourceLabel,
		 Capi.Layout.FIXED sourceText,
		 Capi.Layout.SPACE,
 		 Capi.Layout.FIXED libraryLabel,
		 Capi.Layout.FIXED libraryText,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED objLabel,
		 Capi.Layout.FIXED binLabel,
		 Capi.Layout.FIXED configPathRC,
		 Capi.Layout.SPACE, 
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in
	configUpdateRef := 
	    (fn () => 
		let 
		  (* This must be called before sourcePath and libPath are called, 
		   * so that the configuration details are up to date, otherwise
		   * an attempt is made to access details which will be out of 
		   * date after adding a new configuration.
		   *)
		  val _ = updateCFdetails()
		  val (S, closeS) = sourcePath
		  val (L, closeL) = libPath
		  fun closeThem () = (closeS(); closeL())

		in

		  (* These two dialogs are closed in the event that the current
		   * selection of configuration is changed to avoid confusion
		   * as to which configuration these dialogs refer to.
		   *)
		  if isSome(!configSel) andalso isSome (!pathSel) then
		    if (#1 (valOf (!configSel)) <> #1 (valOf (!pathSel))) then
		       closeThem()
		    else ()
		  else closeThem();
		  updateConfigButtons();
		  updateSetButtons()
		end);
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
		  updateConfigs (!Lconfigs);
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 close)
      end  (* mk_configs_dialog *)

    (* This callerUpdate function has spec:  
     * callerUpdate: (objectsLoc, binariesLoc) libPath -> unit
     * callerUpdate: (string * string) -> string list -> unit
     *)
    fun mk_locations_dialog (parent, callerUpdate) = 
      let
	val visible = ref false
	val locChanged = ref false
	val localLibPath = ref []
	val LobjectsLoc = ref ""
	val LbinariesLoc = ref ""

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propConfigDialog", "Project Properties - Locations", 
				parent, false, visible)
	val libLabel = Capi.make_managed_widget 
				("PWL_libLabel", Capi.Label, frame, [])
	val libText = Capi.make_managed_widget
				("PWL_libText", Capi.Text, frame, [])

	val objLabel = Capi.make_managed_widget 
				("PWL_objLabel", Capi.Label, frame, [])
	val binLabel = Capi.make_managed_widget 
				("PWL_binLabel", Capi.Label, frame, [])

	val setRC = Capi.make_managed_widget 
				("PWL_setRC", Capi.RowColumn, frame, [])

	val updateRef = ref (fn () => ())
	fun update () = (!updateRef)()

	fun apply () = 
	  (ProjFile.setLocations (!localLibPath, !LobjectsLoc, !LbinariesLoc);
	   callerUpdate (!LobjectsLoc, !LbinariesLoc) (!localLibPath);
	   locChanged := false;
	   update())

	fun reset () = 
	  let 
	    val (libPath, obj, bin) = ProjFile.getLocations()
	  in
	    localLibPath := libPath;
	    LobjectsLoc := obj;
	    LbinariesLoc := bin;
	    locChanged := false;
	    update()
	  end

	fun close () = 
	  (reset();
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame,
			  apply = apply,
			  reset = reset,
			  close = close,
			  changeRef = locChanged}

	fun getLibPath() = (!localLibPath)

	fun setLibPath theList =
	  (localLibPath := theList;
	   Capi.Text.set_string (libText, list2str theList);
	   locChanged := true;
	   updateCloseButtons())

	val (mkLibPath,_) = 
	  mk_path_dialog (shell, "Set Library Path", getLibPath, setLibPath)

	fun libPath () = mkLibPath
	    "Ordered list of directories where library files are found:"

	fun updateObjBin () = 
	  (Capi.set_label_string 
		(objLabel, "Location for object files: " ^ (!LobjectsLoc));
	   Capi.set_label_string 
		(binLabel, "Location for binary files: " ^ (!LbinariesLoc)))

	fun setObjBinLoc objLoc () = 
	  let 
	    val text = get_directory (shell, MAY_EXIST)
	    fun updateLoc loc = 
	      if text <> "" then 
		(loc := text;
		 locChanged := true;
		 updateCloseButtons())
	      else ()
	  in
	    if objLoc then updateLoc LobjectsLoc else updateLoc LbinariesLoc;
	    updateObjBin()
	  end

	val {update, ...} = 
	  Menus.make_buttons (setRC, 
		[Menus.PUSH ("PWL_setLibPath", libPath, fn _ => true),
		 Menus.PUSH ("PWL_setObjLoc", setObjBinLoc true, fn _ => true),
		 Menus.PUSH ("PWL_setBinLoc", setObjBinLoc false, fn _ => true)])

	fun updateLoc () =
	  let val prev = (!locChanged)
	  in
	    setLibPath (!localLibPath);
	    locChanged := prev;
	    updateCloseButtons();
	    updateObjBin()
	  end

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED libLabel,
		 Capi.Layout.FIXED libText,
		 Capi.Layout.FIXED objLabel,
		 Capi.Layout.FIXED binLabel,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED setRC, 
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])
      in
	updateRef := updateLoc;
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	(fn () => (visible := true;
		  updateLoc();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	 close)
      end  (* mk_locations_dialog *)

    end  (* local containing mk_???_dialogs *)

end  (* struct *)

@


1.1.1.2
log
@Automatic checkin:
changed attribute _comment to ' *  '
@
text
@@


1.1.1.3
log
@[Bug #30071]
 Continuing work for Project Workspace - adding option for storing relative pathnames
@
text
@a2 4
 *  Revision 1.1.1.2  1997/09/12  14:21:47  johnh
 *  Automatic checkin:
 *  changed attribute _comment to ' *  '
 *
a12 1
require "../basis/path";
a27 1
  structure Path: PATH
a297 20
    fun getBasePath () = Path.dir (ProjFile.getProjectName())

    fun toRel []              f = []
      | toRel ((a,pos)::rest) f = 
	let
	  val newPath = Path.mkCanonical (Path.mkRelative (a, getBasePath()))
	in
	  f (a, newPath);
	  (newPath, pos) :: (toRel rest f)
	end

    fun toAbs []              f = []
      | toAbs ((a,pos)::rest) f = 
	let 
	  val newPath = Path.mkCanonical (Path.mkAbsolute (a, getBasePath()))
	in
	  f (a, newPath);
	  (newPath, pos) :: (toAbs rest f)
	end

a310 1
	val relativePaths = ref false
d328 1
a328 1
	val updatePathsRef = ref (fn () => ())
d332 1
a332 1
	    dir_selection updatePathsRef path_items
d335 1
a335 7
	  let 
	    val rawDir = get_directory (shell, MUST_EXIST)
	    val dir = 
	      if (!relativePaths) then 
		Path.mkRelative (rawDir, getBasePath())
	      else
		rawDir
a368 25
	fun getRel () = (!relativePaths)
	fun setRel b = 
	  if b then 
	    (relativePaths := true;
	     pathChanged := true;
	     path_items := toRel (!path_items) (fn _ => ());
	     set_new_path (!path_items))
	  else
	    (relativePaths := false;
	     pathChanged := true;
	     path_items := toAbs (!path_items) (fn _ => ());
	     set_new_path (!path_items))

	val relativeRC = Capi.make_managed_widget 
				("PWF_relativeRC", Capi.RowColumn, frame, [])

	(* This toggle button cannot be put into the labelstrings list because if 
	 * it is found there then its associated control(s) becomes unique, so that
	 * different actions cannot be attached to it.  Alternative solution 
	 * involves passing in a label string to mk_path_dialog.
	 *)
	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
		[Menus.TOGGLE ("Relative path names", getRel, setRel, fn _ => true)])

a381 1
	   visible := false;
a393 2
		 Capi.Layout.FIXED relativeRC,
		 Capi.Layout.SPACE,
d401 1
a401 1
    in 
d406 1
a406 1
      updatePathsRef := (fn () => (update(); updateCloseButtons(); updateRel()));
d420 6
a425 9
	 (Capi.set_label_string (label, miniTitle);
	  if (!path_items) <> [] then 
	    relativePaths := Path.isRelative (#1(hd(!path_items)))
	  else ();
    	  visible := true;
    	  set_new_path (!path_items);
    	  Capi.reveal frame;
    	  Capi.reveal shell;
    	  Capi.to_front shell)),
a446 1
	val visible = ref false
d449 3
a451 4
	val disTargets = ref []
	val curTargets = ref []
	val targetDetails = ref []
	val relativePaths = ref false
d457 1
d477 1
a477 1
	 * targets (inc disabled ones) by:  targetDetails := addDetails <allTargets>;
d482 1
a482 1
		val details = List.find (fn (n,_,_,_) => n=name) (!targetDetails)
d501 1
a501 1
		   curTargets
d507 2
a508 2
	      valOf (List.find (fn (n,_,_,_) => n=name) (!targetDetails))
	    val others = List.filter (fn (n,_,_,_) => n <> name) (!targetDetails);
d510 1
a510 1
	    targetDetails := (name, tarType, mode, config) :: others
d515 1
a515 1
	  ProjFile.getTargetDetails ((#1 (valOf (!curSel))), !targetDetails)
d521 1
a521 7
	  let 
	    val rawText = get_file shell
	    val text = 
	      if (!relativePaths) then 
		Path.mkRelative (rawText, getBasePath())
	      else
		rawText
d523 1
a523 1
	    if not (text is_in (!curTargets) orelse text is_in (!disTargets)) 
d526 1
a526 1
		val new_targets = (text,1) :: (map renumber_up (!curTargets))
d550 1
a550 1
		updateTargets (!curTargets)
d588 1
a588 1
	    disSel updateDisabledRef disTargets
d600 1
a600 1
	      val new_disabled = (s,1) :: (map renumber_up (!disTargets))
d603 2
a604 2
	      updateDisabled new_disabled;
	      removeSelCB (curSel, curTargets, changed) updateTargets
d618 1
a618 1
	      val new_enabled = (s,1) :: (map renumber_up (!curTargets))
d621 2
a622 2
	      updateTargets new_enabled;
	      removeSelCB (disSel, disTargets, changed) updateDisabled
d635 1
a635 1
	   updateDisabled (!disTargets);
d638 1
a638 1
	     removeSelCB (curSel, curTargets, changed) updateTargets)
d641 2
a642 2
	fun moveUp () = moveUpCB (curSel, curTargets, changed) updateTargets
	fun moveDown () = moveDownCB (curSel, curTargets, changed) updateTargets
d670 2
a671 2
	  (updateTargets (!curTargets);
	   updateDisabled (!disTargets))
d674 3
a676 3
	  (ProjFile.setTargets (map #1 (!curTargets), 
				map #1 (!disTargets), 
				!targetDetails);
d679 1
a679 1
	   callerUpdate (map #1 (!curTargets)))
d685 3
a687 3
	    curTargets := number_entries (current, 1);
	    disTargets := number_entries (disabled, 1);
	    targetDetails := details;
a701 1
	   visible := false;
a703 37
	fun getRel () = (!relativePaths)
	fun changeName [] names = []
	  | changeName ((n, t, m, c)::rest) (old, new) = 
	      if n = old then 
		(new, t, m, c) :: rest

	      else
		(n, t, m, c) :: (changeName rest (old, new))
	fun changeTargetName names = 
	  targetDetails := changeName (!targetDetails) names

	fun changeSel selRef listRef = 
	  if isSome (!selRef) then
	    let val (name, pos) = valOf (!selRef)
	    in
	      selRef := SOME (find_nth pos (!listRef))
	    end
	  else ()

	fun setRel b = 
	  (relativePaths := b;
	   changed := true;
	   curTargets := 
		(if b then toRel else toAbs) (!curTargets) changeTargetName;
	   disTargets := 
		(if b then toRel else toAbs) (!disTargets) changeTargetName;
	   changeSel curSel curTargets;
	   changeSel disSel disTargets;
	   update())

	val relativeRC = Capi.make_managed_widget 
				("PWT_relativeRC", Capi.RowColumn, frame, [])

	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
		[Menus.TOGGLE ("PWT_relative", getRel, setRel, fn _ => true)])

a714 1
	   updateRel();
a754 1
		 Capi.Layout.FIXED relativeRC,
d776 1
a776 1
	 * 1)	Keep targetDetails consistent with targets
d783 1
a783 4
	  (fn () => (targetDetails := addDetails ((!curTargets) @@ (!disTargets));
        	     if (!targetDetails) <> [] then 
		  	relativePaths := Path.isRelative (#1(hd(!targetDetails)))
		     else ();
a788 1
		     updateRel();
a967 1
	   visible := false;
d1012 2
a1013 4
	val configs = ref []
	val configDetails = ref ([]: ProjFile.config_details list)
	val relativeObj = ref false
	val relativeBin = ref false
d1019 1
a1019 1
	    ({name=n, source=source, library=lib, objects=obj, bins=bin}, !configRef)
d1021 1
a1021 1
	  ProjFile.getConfigDetails (#1 (valOf (!configSel)), !configDetails)
d1025 1
a1025 2
	  Capi.make_main_popup ("propConfigDialog", 
				"Project Properties - Configurations", 
d1034 1
a1034 1
	    configSel configUpdateRef configs
d1039 1
a1039 3
	fun removeConfigCB () = 
	  removeSelCB (configSel, configs, configChanged) updateConfigs

d1054 1
a1054 1
	    if not (config is_in (!configs)) andalso config <> "" then 
d1056 1
a1056 1
		val new_configs = (config,1) :: (map renumber_up (!configs))
d1096 1
a1096 1
	    configDetails := 
d1098 1
a1098 1
				     configDetails);
d1100 1
a1100 1
 	    updateConfigs (!configs);
d1119 1
a1119 1
	    configDetails := 
d1121 1
a1121 1
				     configDetails);
d1123 1
a1123 1
	    updateConfigs (!configs);
d1145 1
a1145 3
	  (relativeObj := Path.isRelative objLoc;
	   relativeBin := Path.isRelative binLoc; 
	   Capi.set_label_string (objLabel, "Location for object files:  " ^ objLoc);
a1147 6
	fun modifyConfig (details as (_, _, _, obj, bin)) = 
	  (configDetails := modifyConfigDetails (details, configDetails);
	   configChanged := true;
	   updateConfigs (!configs);
	   updateObjBinLabels (obj, bin))

d1151 1
a1151 7
	      val rawDir = get_directory (shell, MAY_EXIST)
	      val relRef = if objectChange then relativeObj else relativeBin
	      val dir = 
	        if (!relRef) then 
		  Path.mkRelative (rawDir, getBasePath())
	        else
		  rawDir
d1154 1
a1154 1
		if objectChange then (dir, bins) else (objects, dir)
d1156 7
a1162 2
	      if rawDir <> "" then 
		modifyConfig (name, source, library, obj, bin)
a1166 29
	val relativeRC = Capi.make_managed_widget 
				("PWC_relativeRC", Capi.RowColumn, frame, [])

	fun getRelObj () = (!relativeObj)
	fun getRelBin () = (!relativeBin)
	fun setRelObjBin objectChange b = 
	  if is_sel() then 
	    let 
	      val {name, source, library, objects, bins} = get_cf_details()
	      val toRelAbs' = 
		if b then Path.mkCanonical o Path.mkRelative 
		else Path.mkCanonical o Path.mkAbsolute
	      fun toRelAbs s = toRelAbs' (s, (getBasePath()))
	    in
	      if objectChange then 
		(relativeObj := b;
		 modifyConfig (name, source, library, toRelAbs objects, bins))
	      else 
		(relativeBin := b;
		 modifyConfig (name, source, library, objects, toRelAbs bins));
	      updateConfigs(!configs)
	    end
	  else ()

	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
	    [Menus.TOGGLE ("PWC_relativeObj", getRelObj, setRelObjBin true, is_sel),
	     Menus.TOGGLE ("PWC_relativeBin", getRelBin, setRelObjBin false, is_sel)])

d1178 1
a1178 1
		  List.find (fn {name=n, ...} => n = configName) (!configDetails)
d1191 1
a1191 1
	  (ProjFile.setConfigurations (map #1 (!configs), !configDetails);
d1193 1
a1193 1
	   updateConfigs (!configs))
d1199 2
a1200 2
	    configs := number_entries (configList, 1);
	    configDetails := details;
d1203 1
a1203 1
	    updateConfigs (!configs)
a1207 1
	   visible := false;
d1218 1
a1218 1
	  (configDetails := addCFdetails (!configs);
a1243 1
		 Capi.Layout.FIXED relativeRC,
a1276 1
		  updateRel();
d1283 1
a1283 1
		  updateConfigs (!configs);
d1299 2
a1300 4
	val objectsLoc = ref ""
	val binariesLoc = ref ""
	val relativeObj = ref false
	val relativeBin = ref false
d1322 2
a1323 2
	  (ProjFile.setLocations (!localLibPath, !objectsLoc, !binariesLoc);
	   callerUpdate (!objectsLoc, !binariesLoc) (!localLibPath);
d1332 2
a1333 2
	    objectsLoc := obj;
	    binariesLoc := bin;
a1337 6
	(* This call needs to be made here to get the location refs
	 * before mk_path_dialog dialog is called so that the dialog
	 * displays the correct path initially. 
	 *)
	val _ = reset();

a1339 1
	   visible := false;
d1357 1
a1357 1
	val (mkLibPath, closeLibPath) = 
d1365 1
a1365 1
		(objLabel, "Location for object files: " ^ (!objectsLoc));
d1367 1
a1367 1
		(binLabel, "Location for binary files: " ^ (!binariesLoc)))
d1371 1
a1371 8
	    val rawText = get_directory (shell, MAY_EXIST)
	    val relRef = if objLoc then relativeObj else relativeBin
	    val text = 
	      if (!relRef) then 
		Path.mkRelative (rawText, getBasePath())
	      else
		rawText

d1379 1
a1379 1
	    if objLoc then updateLoc objectsLoc else updateLoc binariesLoc;
d1383 1
a1383 1
	val {update = updateSet, ...} = 
a1388 23
	val relativeRC = Capi.make_managed_widget 
				("PWL_relativeRC", Capi.RowColumn, frame, [])

	fun getRelObj () = (!relativeObj)
	fun getRelBin () = (!relativeBin)
	fun setRel (relRef, relAbs) = 
	  (locChanged := true;
	   relRef := Path.mkCanonical (relAbs (!relRef, getBasePath()));
	   update())

	fun setRelObj b = 
	  (relativeObj := b;
	   setRel (objectsLoc, (if b then Path.mkRelative else Path.mkAbsolute)))

	fun setRelBin b =
	  (relativeBin := b;
	   setRel (binariesLoc, (if b then Path.mkRelative else Path.mkAbsolute)))

	val {update = updateRel, ...} = 
	  Menus.make_buttons (relativeRC, 
	    [Menus.TOGGLE ("PWL_relativeObj", getRelObj, setRelObj, fn _ => true),
	     Menus.TOGGLE ("PWL_relativeBin", getRelBin, setRelBin, fn _ => true)])

a1394 1
	    updateRel();
a1401 1
		 Capi.Layout.FIXED relativeRC,
a1409 1
	closeLibPath();  
a1413 1
	reset();
d1415 1
a1415 3
		  relativeObj := Path.isRelative (!objectsLoc);
		  relativeBin := Path.isRelative (!binariesLoc);
		  update();
@


1.1.1.4
log
@[Bug #30071]
Added support for current configurations, modes and targets.
@
text
@a2 4
 *  Revision 1.1.1.3  1997/11/03  15:57:46  johnh
 *  [Bug #30071]
 *   Continuing work for Project Workspace - adding option for storing relative pathnames
 *
a18 1
require "../main/info";
a28 1
  structure Info: INFO
a35 2
  sharing type Info.Location.T = ProjFile.location
  sharing type Info.options = ProjFile.error_info
a108 24
  val debugMode =
    {name = "Debug",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref true,
     generate_debug_info = ref true,
     generate_variable_debug_info = ref true,
     optimize_leaf_fns = ref false,
     optimize_tail_calls = ref false,
     optimize_self_tail_calls = ref false,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

  val releaseMode =
    {name = "Release",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref false,
     generate_debug_info = ref false,
     generate_variable_debug_info = ref false,
     optimize_leaf_fns = ref true,
     optimize_tail_calls = ref true,
     optimize_self_tail_calls = ref true,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

d113 1
a113 8
       ProjFile.initialize();
       ProjFile.setModes
         (["Debug", "Release"],
	  [debugMode, releaseMode]);
       ProjFile.setCurrentMode
	 (Info.make_default_options (),
	  Info.Location.FILE "Project Properties")
	 "Debug")
d827 1
a827 4
	       if isCurSel() then
		 get_details()
	       else
		 ("", ProjFile.EXECUTABLE, "", "")
d838 2
a839 4
	      modifyTarget
		(name, curType, 
	         parse_name (Capi.Text.get_string modeConfig),
		 config);
d845 1
a845 2
	(* addConfigCB:  changes the configuration of the selected
	   current target *)
d995 7
a1001 7
		 generate_interceptable_code  = ref true,
		 generate_debug_info		= ref true,
		 generate_variable_debug_info = ref true,
		 optimize_leaf_fns		= ref false,
		 optimize_tail_calls		= ref false,
		 optimize_self_tail_calls	= ref false,
		 mips_r4000			= ref true,
d1025 2
a1026 12
	fun removeModeCB () =
	  removeSelCB (modeSel, Lmodes, modeChanged) updateModes

	fun setCurModeCB () =
	  case !modeSel of
	    SOME (name, _) =>
	      ProjFile.setCurrentMode
	        (Info.make_default_options (),
		 Info.Location.FILE "Project Properties")
		name
	  | NONE => ()

d1072 1
a1072 1
	    val (modeList, details, _) = ProjFile.getModes()
d1161 1
a1161 8
	fun setCurConfigCB () =
	  case !configSel of
	    SOME (name, _) =>
	      ProjFile.setCurrentConfiguration
	        (Info.make_default_options (),
		 Info.Location.FILE "Project Properties")
		name
	  | NONE => ()
d1356 1
a1356 1
	    val (configList, details, _) = ProjFile.getConfigurations()
@


1.1.1.5
log
@[Bug #30071]
Make further improvements.
Current mode and config added, improved save/load.
@
text
@a2 4
 *  Revision 1.1.1.4  1997/11/04  10:14:37  daveb
 *  [Bug #30071]
 *  Added support for current configurations, modes and targets.
 *
a21 1
require "../utils/getenv";
a39 1
  structure Getenv: GETENV
a47 2
  fun P s = MLWorks.IO.output (MLWorks.IO.terminal_out, s ^ "\n")

a81 26
  val debugMode =
    {name = "Debug",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref true,
     generate_debug_info = ref true,
     generate_variable_debug_info = ref true,
     optimize_leaf_fns = ref false,
     optimize_tail_calls = ref false,
     optimize_self_tail_calls = ref false,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

  val releaseMode =
    {name = "Release",
     generate_interruptable_code = ref true,
     generate_interceptable_code = ref false,
     generate_debug_info = ref false,
     generate_variable_debug_info = ref false,
     optimize_leaf_fns = ref true,
     optimize_tail_calls = ref true,
     optimize_self_tail_calls = ref true,
     mips_r4000 = ref true,
     sparc_v7 = ref false}

  val need_saved = ref false

d102 1
a102 1
    if (!need_saved) then
d110 1
a110 3
	    (save_project parent;
	     need_saved := false)
	  (* ProjFile.save_proj (ProjFile.getProjectName()) *)
d115 25
a139 2
    else 
      true
d143 1
a143 2
      (need_saved := false;
       ProjFile.setProjectName "untitled.mlp";
a161 1
	   need_saved := false;
d325 1
a325 1
    fun mkCloseButtons {parent, apply, reset, close, changed} = 
d330 1
a330 14
	(* Note that calling apply() has the effect of changing the result
	 * of calling changed().  Calling apply() before calling changed() 
	 * will result in changed() always returning false.
	 *)

	fun ok () = 
	  let val change = changed()
	  in
	    if apply() then 
	      (if change then need_saved := true else ();
	       close())
	    else ()
	  end

a332 5
	fun apply_fn () = 
	  if changed() andalso apply() then 
	    need_saved := true
	  else ()

d335 4
a338 4
		[Menus.PUSH ("PWP_Ok",     ok,       fn _ => true),
		 Menus.PUSH ("PWP_Apply",  apply_fn, changed),
		 Menus.PUSH ("PWP_Reset",  reset,    changed),
		 Menus.PUSH ("PWP_Cancel", cancel,   fn _ => true)])
d343 1
a343 5
    fun getBasePath () = 
      if (!projNameSet) then 
	Path.dir (ProjFile.getProjectName())
      else 
	getOpt (Getenv.get_startup_dir(), ".")
d469 1
a469 2
	   set_new_path (!path_items);
	   true)
d487 1
a487 1
			  changed = fn () => (!pathChanged)}
d789 1
a789 2
	   callerUpdate (map #1 (!curTargets));
	   true)
d857 1
a857 1
			  changed = fn () => (!changed)}
a884 1
	      changed := true;
a897 1
	      changed := true;
a968 1
	val curMode = ref ""
a976 3
	val curLabel = Capi.make_managed_widget
				("PWM_curLabel", Capi.Label, frame, [])

d1073 8
a1080 3
	fun updateCurMode newCurMode = 
	  (curMode := newCurMode;
	   Capi.set_label_string(curLabel, "Current Mode:  " ^ newCurMode))
a1081 11
	fun setCurModeCB () =
	  let 
	    val (selection, pos) = getOpt(!modeSel, ("",0))
	  in
	    if (selection <> "") then 
	      (updateCurMode selection;
	       modeChanged := true;
	       updateModes (!Lmodes))
	    else
	      Capi.beep parent
	  end
d1120 4
a1123 18
	  let
	    val modeNames = map #1 (!Lmodes)
	    val modeExists = List.find (fn c => c = (!curMode)) modeNames
	  in
	    if isSome(modeExists) then
	      (ProjFile.setModes (modeNames, !LmodeDetails);
	       ProjFile.setCurrentMode
		 (Info.make_default_options (),
		  Info.Location.FILE "Project Properties")
		 (!curMode);
	       callerUpdate modeNames;
	       modeChanged := false;
	       update();
	       true)
	    else 
	      (Capi.send_message (shell, "Invalid current mode or none set");
	       false)
	  end
d1127 1
a1127 1
	    val (modeList, details, currentMode) = ProjFile.getModes()
a1130 1
	    curMode := getOpt(currentMode, "");
d1146 1
a1146 1
			  changed = fn () => (!modeChanged)}
a1151 1
		 Capi.Layout.FIXED curLabel,
d1164 1
a1164 2
 	updateModesRef := (fn () => (updateCurMode(!curMode);
				     updateModeDetails(); 
d1178 1
a1178 1
    fun mk_configs_dialog (parent, callerUpdate) = 
a1186 1
	val curConfig = ref ""
a1203 3
	val curLabel = Capi.make_managed_widget
				("PWC_curLabel", Capi.Label, frame, [])

a1215 4
	fun updateCurConfig newCurConfig = 
	  (curConfig := newCurConfig;
	   Capi.set_label_string(curLabel, "Current Configuration:  " ^ newCurConfig))

d1217 7
a1223 10
	  let 
	    val (selection, pos) = getOpt(!configSel, ("",0))
	  in
	    if (selection <> "") then 
	      (updateCurConfig selection;
	       configChanged := true;
	       updateConfigs(!configs))
	    else
	      Capi.beep parent
	  end
d1412 3
a1414 27
	  let 
	    val configNames = map #1 (!configs)
	    val configExists = List.find (fn c => c = (!curConfig)) configNames
	    val details = 
	      if isSome(configExists) then
		SOME (ProjFile.getConfigDetails((!curConfig), (!configDetails)))
	      else
		NONE
	    val valid_cur_config = 
	      isSome(configExists) orelse (configNames = [])
	  in
	    if valid_cur_config then 
	      (ProjFile.setConfigurations (configNames, !configDetails);
	       if isSome(details) then callerUpdate(valOf(details)) else ();
	       if (configNames <> []) then 
		 ProjFile.setCurrentConfiguration
		   (Info.make_default_options (),
		    Info.Location.FILE "Project Properties")
		   (!curConfig)
	       else ();
	       configChanged := false;
	       updateConfigs (!configs);
	       true)
	    else
	      (Capi.send_message (shell, "Invalid current configuration or none set");
	       false)
	  end
d1418 1
a1418 1
	    val (configList, details, currentConfig) = ProjFile.getConfigurations()
a1421 1
	    curConfig := getOpt(currentConfig, "");
d1437 1
a1437 1
			  changed = fn () => (!configChanged)}
a1455 1
		 Capi.Layout.FIXED curLabel,
a1498 1
		  updateCurConfig(!curConfig);
a1543 7
	fun setObjBinSens () = 
	  let
	    val (configList, _, _) = ProjFile.getConfigurations()
	  in
	    (configList = [])
	  end

d1548 2
a1549 4
	  (if setObjBinSens() then 
	     (ProjFile.setLocations (!localLibPath, !objectsLoc, !binariesLoc);
	      callerUpdate (!objectsLoc, !binariesLoc) (!localLibPath))
	   else ();
d1551 1
a1551 2
	   update();
	   true)
d1580 1
a1580 1
			  changed = fn () => (!locChanged)}
d1614 1
a1614 2
		(MLWorks.IO.output (MLWorks.IO.terminal_out, "setting objbins\n");
		 loc := text;
d1619 2
a1620 4
	    if setObjBinSens() then 
	      (if objLoc then updateLoc objectsLoc else updateLoc binariesLoc;
	       updateObjBin())
	    else update()
d1626 2
a1627 2
		 Menus.PUSH ("PWL_setObjLoc", setObjBinLoc true, setObjBinSens),
		 Menus.PUSH ("PWL_setBinLoc", setObjBinLoc false, setObjBinSens)])
d1640 2
a1641 5
	  if setObjBinSens() then 
	    (relativeObj := b;
	     setRel (objectsLoc, (if b then Path.mkRelative else Path.mkAbsolute)))
	  else 
	    update()
d1644 2
a1645 5
	  if setObjBinSens() then 
	    (relativeBin := b;
	     setRel (binariesLoc, (if b then Path.mkRelative else Path.mkAbsolute)))
	  else 
	    update()
d1649 2
a1650 2
	    [Menus.TOGGLE ("PWL_relativeObj", getRelObj, setRelObj, setObjBinSens),
	     Menus.TOGGLE ("PWL_relativeBin", getRelBin, setRelBin, setObjBinSens)])
a1657 2
	    relativeObj := Path.isRelative (!objectsLoc);
	    relativeBin := Path.isRelative (!binariesLoc);
a1658 1
	    updateSet();
d1682 2
@


1.1.1.6
log
@[Bug #30071]
Make targets be just the file name.
Also replaced use of Path by OS.Path.
@
text
@a2 5
 *  Revision 1.1.1.5  1997/11/11  11:23:38  johnh
 *  [Bug #30071]
 *  Make further improvements.
 *  Current mode and config added, improved save/load.
 *
d25 1
a25 1
require "../basis/os";
d44 1
a44 1
  structure OS: OS
d378 1
a378 1
	OS.Path.dir (ProjFile.getProjectName())
d385 1
a385 2
	  val newPath =
	    OS.Path.mkCanonical (OS.Path.mkRelative (a, getBasePath()))
d394 1
a394 2
	  val newPath =
	    OS.Path.mkCanonical (OS.Path.mkAbsolute (a, getBasePath()))
d442 1
a442 1
		OS.Path.mkRelative (rawDir, getBasePath())
d560 1
a560 1
	    relativePaths := OS.Path.isRelative (#1(hd(!path_items)))
d594 1
d665 5
a669 1
	    val text = OS.Path.file rawText
d854 1
d865 26
d902 1
d951 1
d981 3
d989 1
d1407 2
a1408 2
	  (relativeObj := OS.Path.isRelative objLoc;
	   relativeBin := OS.Path.isRelative binLoc; 
d1425 1
a1425 1
		  OS.Path.mkRelative (rawDir, getBasePath())
d1448 2
a1449 2
		if b then OS.Path.mkCanonical o OS.Path.mkRelative 
		else OS.Path.mkCanonical o OS.Path.mkAbsolute
d1724 1
a1724 1
		OS.Path.mkRelative (rawText, getBasePath())
d1755 1
a1755 1
	   relRef := OS.Path.mkCanonical (relAbs (!relRef, getBasePath()));
d1761 1
a1761 3
	     setRel
	       (objectsLoc,
		(if b then OS.Path.mkRelative else OS.Path.mkAbsolute)))
d1768 1
a1768 3
	     setRel
	       (binariesLoc,
		(if b then OS.Path.mkRelative else OS.Path.mkAbsolute)))
d1783 2
a1784 2
	    relativeObj := OS.Path.isRelative (!objectsLoc);
	    relativeBin := OS.Path.isRelative (!binariesLoc);
@


1.1.1.7
log
@[Bug #30071]
Further improvements.
@
text
@a2 5
 *  Revision 1.1.1.6  1997/11/18  17:36:55  daveb
 *  [Bug #30071]
 *  Make targets be just the file name.
 *  Also replaced use of Path by OS.Path.
 *
d663 1
a663 9
	  let 
	    val name = #1 (valOf (!curSel))
	  in
	    ProjFile.getTargetDetails (name, !targetDetails)
	    handle ProjFile.NoTargetDetailsFound n => 
	      (Capi.send_message (shell, 
		 "Error in targets.  No details found for target: " ^ n);
	       (n, ProjFile.EXECUTABLE, "", ""))
	  end
a990 12
	fun initModeDetails modeName = 
	  {name 			= modeName, 
	   generate_interruptable_code  = ref true,
	   generate_interceptable_code  = ref true,
	   generate_debug_info		= ref true,
	   generate_variable_debug_info = ref true,
	   optimize_leaf_fns		= ref false,
	   optimize_tail_calls		= ref false,
	   optimize_self_tail_calls	= ref false,
	   mips_r4000			= ref true,
	   sparc_v7			= ref false}

d992 1
a992 8
	  let val name = #1 (valOf (!modeSel)) 
	  in
	    ProjFile.getModeDetails (#1 (valOf (!modeSel)), !LmodeDetails)
	    handle ProjFile.NoModeDetailsFound m =>
	      (Capi.send_message (shell, 
		 "Error in modes.  No details found for mode: " ^ m);
	       initModeDetails m)
	  end
d1052 10
a1061 1
		(initModeDetails name) :: (addModeDetails t)
d1228 6
a1246 25
	fun initConfigDetails name = 
	  {name = name, 
	   source = [],
	   library = [],
	   objects = "",
	   bins = ""}

	fun modifyConfigDetails ((n, source, lib, obj, bin), configRef) = 
	  ProjFile.modifyConfigDetails
	    ({name=n, source=source, library=lib, objects=obj, bins=bin}, !configRef)
	  handle ProjFile.NoConfigDetailsFound c =>
	      (Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c);
	       (!configDetails))

	fun get_cf_details () = 
	  let val configName = #1 (valOf (!configSel))
	  in
	    ProjFile.getConfigDetails (configName, !configDetails)
	    handle ProjFile.NoConfigDetailsFound c =>
	      (Capi.send_message (shell, 
		 "Error in configurations.  No details found for configuration: " ^ c);
	       initConfigDetails configName)
	  end

d1452 5
a1456 1
		  (initConfigDetails configName) :: (addCFdetails t)
d1464 1
a1464 1
	      (if isSome(configExists) then
d1467 1
a1467 5
		NONE)
	      handle ProjFile.NoConfigDetailsFound c =>
		(Capi.send_message (shell, 
		   "Error in configurations.  No details found for configuration: " ^ c);
		 NONE)
d1473 1
a1473 9
	       if isSome(details) then 
		 let 
		   val {name, source, library, objects, bins} = valOf(details)
		   val (lib, obj, b) = ProjFile.getLocations()
		 in
		   ProjFile.setLocations(lib, objects, bins);
		   callerUpdate(valOf(details)) 
		 end
	       else ();
@


1.1.1.8
log
@[Bug #30071]
ProjFile.getProjectName now returns an option.
Use ProjFile.getProjectDir instead of getBasePath.
@
text
@a2 4
 *  Revision 1.1.1.7  1997/11/19  11:25:06  johnh
 *  [Bug #30071]
 *  Further improvements.
 *
d36 1
d55 1
d68 2
d127 2
a128 6
    case ProjFile.getProjectName()
    of SOME file =>
      (Capi.send_message (parent, "Saved project to " ^ file);
       true)
    | NONE =>
       false
d131 2
a132 3
    case ProjFile.getProjectName()
    of SOME file =>
      (ProjFile.save_proj file;
d134 1
a134 1
    |  NONE =>
d139 1
d148 1
a148 2
        val askSave =
	  Capi.makeYesNoCancel (parent, "Save the current project?", true)
d156 1
d167 2
d185 1
d386 6
d396 1
a396 2
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative (a, ProjFile.getProjectDir()))
d406 1
a406 2
	    OS.Path.mkCanonical
	      (OS.Path.mkAbsolute (a, ProjFile.getProjectDir()))
d454 1
a454 1
		OS.Path.mkRelative (rawDir, ProjFile.getProjectDir ())
d1436 1
a1436 1
		  OS.Path.mkRelative (rawDir, ProjFile.getProjectDir ())
d1461 1
a1461 1
	      fun toRelAbs s = toRelAbs' (s, (ProjFile.getProjectDir ()))
d1743 1
a1743 1
		OS.Path.mkRelative (rawText, ProjFile.getProjectDir ())
d1774 1
a1774 2
	   relRef :=
	     OS.Path.mkCanonical (relAbs (!relRef, ProjFile.getProjectDir ()));
@


1.1.1.9
log
@[Bug #30071]
Comment out any reference to binaries for the time being.
@
text
@a2 5
 *  Revision 1.1.1.8  1997/12/01  11:16:18  daveb
 *  [Bug #30071]
 *  ProjFile.getProjectName now returns an option.
 *  Use ProjFile.getProjectDir instead of getBasePath.
 *
a1410 2

(* BBB
a1412 1
*)
d1417 2
a1418 2
	   Capi.set_label_string (objLabel, "Location for object files:  " ^ objLoc))
(* BBB	   Capi.set_label_string (binLabel, "Location for binary files:  " ^ binLoc)) *)
d1472 2
a1473 2
	    [Menus.TOGGLE ("PWC_relativeObj", getRelObj, setRelObjBin true, is_sel)])
(* BBB	     Menus.TOGGLE ("PWC_relativeBin", getRelBin, setRelObjBin false, is_sel)]) *)
d1479 2
a1480 2
		 Menus.PUSH ("PWC_addObjLoc", addObjBinCB true, is_sel)])
(* BBB		 Menus.PUSH ("PWC_addBinLoc", addObjBinCB false, is_sel)]) *)
d1589 1
a1589 1
(* BBB		 Capi.Layout.FIXED binLabel, *)
a1659 1
(* BBB
a1661 1
*)
d1730 2
a1731 2
		(objLabel, "Location for object files: " ^ (!objectsLoc)))
(* BBB	   Capi.set_label_string 
d1733 1
a1733 1
*)
d1746 2
a1747 1
		(loc := text;
d1761 2
a1762 2
		 Menus.PUSH ("PWL_setObjLoc", setObjBinLoc true, setObjBinSens)])
(* BBB		 Menus.PUSH ("PWL_setBinLoc", setObjBinLoc false, setObjBinSens)]) *)
d1795 2
a1796 2
	    [Menus.TOGGLE ("PWL_relativeObj", getRelObj, setRelObj, setObjBinSens)])
(* BBB	     Menus.TOGGLE ("PWL_relativeBin", getRelBin, setRelBin, setObjBinSens)]) *)
d1817 1
a1817 1
(* 		 Capi.Layout.FIXED binLabel, *)
@


1.1.1.10
log
@[Bug #30071]
Use ProfFile.getProjectName returning SOME "" to mean new project created.
@
text
@a2 4
 *  Revision 1.1.1.9  1997/12/01  13:22:48  johnh
 *  [Bug #30071]
 *  Comment out any reference to binaries for the time being.
 *
d133 1
a133 4
    of SOME "" => 
      (Capi.send_message (parent, "Not saved"); 
       false) 
    | SOME file =>
d136 2
a137 1
    | NONE => false
d141 4
a144 1
    of SOME "" => 
d150 2
a151 10
	else 
	  (Capi.send_message (parent, "Project not saved");
	   false)
      end 
    |  SOME file =>
      (ProjFile.save_proj file;
       confirm_save parent)
    |  NONE =>
      (Capi.send_message (parent, "Error getting project name - project not saved");
       false)
d164 2
a165 1
	    need_saved := not (save_project parent)
@


1.1.1.11
log
@[Bug #30071]
Fixed mk_path_dialog so that the relative paths radio button has a unique action id.
@
text
@a2 4
 *  Revision 1.1.1.10  1997/12/01  15:18:30  johnh
 *  [Bug #30071]
 *  Use ProfFile.getProjectName returning SOME "" to mean new project created.
 *
d433 1
a433 1
    fun mk_path_dialog (parent, caller_id, get, set) = 
a438 16
	(* DO NOT change these strings (of caller_id) as they as also used 
	 * in app-defaults/MLWorks-labels and mswindows/__labelstrings.sml
	 *)
	(* caller_id is used as a label identifier below and is needed so 
	 * that with each call to mk_path_dialog, controls created using
	 * this label id can have unique action ids on Windows (see 
	 * Labelstrings for each entry associated with each caller_id)
	 *)
	val title = 
	  case caller_id of 
	     "files"      => "Project Properties - Files"
	   | "config_src" => "Configuration Source Path"
	   | "config_lib" => "Configuration Library Path"
	   | "lib_path"   => "Set Library Path"
	   | _ => ""

d518 4
a521 2
	(* Please note the comment at the start of this function
	 * about the caller_id string.
d525 1
a525 1
		[Menus.TOGGLE ("PWP_" ^ caller_id, getRel, setRel, fn _ => true)])
d598 1
a598 1
		       	  "files", 
d1390 1
a1390 1
					 "config_src", 
d1413 1
a1413 1
				      "config_lib", 
d1743 1
a1743 1
	  mk_path_dialog (shell, "lib_path", getLibPath, setLibPath)
@


1.1.1.12
log
@[Bug #30071]
Add save_project_as
when properties dialog closes, set focus to project workspace.
@
text
@a2 4
 *  Revision 1.1.1.11  1997/12/02  16:38:38  johnh
 *  [Bug #30071]
 *  Fixed mk_path_dialog so that the relative paths radio button has a unique action id.
 *
a148 11
  fun save_project_as parent = 
    let val filename = Capi.save_as_dialog (parent, ".mlp")
    in
      if isSome(filename) then
	(ProjFile.save_proj (valOf(filename));
	 confirm_save parent)
      else 
	(Capi.send_message (parent, "Project not saved");
	 false)
    end 

d151 10
a160 1
    of SOME "" => save_project_as parent
a559 1
	   Capi.set_focus (Capi.parent shell);
a896 1
	   Capi.set_focus (Capi.parent shell);
a1226 1
	   Capi.set_focus (Capi.parent shell);
a1585 1
	   Capi.set_focus (Capi.parent shell);
a1742 1
	   Capi.set_focus (Capi.parent shell);
@


1.1.1.13
log
@[Bug #30071]
Fix problems with setting library path.
@
text
@a2 5
 *  Revision 1.1.1.12  1997/12/12  11:09:54  johnh
 *  [Bug #30071]
 *  Add save_project_as
 *  when properties dialog closes, set focus to project workspace.
 *
d206 1
a206 1
  fun open_project parent open_ok = 
d211 1
a211 5
	  (ProjFile.initialize();  (* needed here so that projectName <> NONE 
				    * otherwise a dialog will pop up asking the 
				    * user to create a new project or open one. *)
	   open_ok();
	   ProjFile.open_proj (valOf(filename));
d1826 2
a1827 2
	     setRel	
       (objectsLoc,
a1884 99

    fun mk_about_dialog parent = 
      let 
        val description = ref ""
        val version = ref ""
        val visible = ref false

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propAboutDialog", "Project Properties - About Project", 
				parent, false, visible)
	val descLabel = Capi.make_managed_widget 
				("PWA_descLabel", Capi.Label, frame, [])
	val descText = Capi.make_managed_widget
				("PWA_descText", Capi.Text, frame, [])
	val verLabel = Capi.make_managed_widget 
				("PWA_verLabel", Capi.Label, frame, [])
	val verText = Capi.make_managed_widget
				("PWA_verText", Capi.Text, frame, [])

	val updateRef = ref (fn () => ())
	fun update () = (!updateRef)()

	fun about_changed () = 
	  let
	    val desc = Capi.Text.get_string descText
	    val ver = Capi.Text.get_string verText
	  in
	    (desc <> (!description)) orelse (ver <> (!version))
	  end

	fun apply () = 
	  if about_changed() then
	    (description := Capi.Text.get_string descText;
	     version := Capi.Text.get_string verText;
	     ProjFile.setAboutInfo (!description, !version);
	     update();
	     true)
	  else
	    true

	fun reset () = 
	  let 
	    val (desc, ver) = ProjFile.getAboutInfo()
	  in
	    description := desc;
	    version := ver;
	    update()
	  end

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame,
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = about_changed}

	fun setAbout (descript, ver) =
	  (description := descript;
	   version := ver;
	   Capi.Text.set_string (descText, descript);
	   Capi.Text.set_string (verText, ver);
	   updateCloseButtons())

	fun updateAbout () = 
	  (setAbout (!description, !version);
	   updateCloseButtons())

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
	    [Capi.Layout.FIXED descLabel,
	     Capi.Layout.FLEX descText,
	     Capi.Layout.FIXED verLabel,
	     Capi.Layout.FIXED verText,
	     Capi.Layout.SPACE,
	     Capi.Layout.FIXED closeRC,
	     Capi.Layout.SPACE])

      in
	updateRef := updateAbout;
	Capi.Callback.add (descText, Capi.Callback.Activate, updateCloseButtons);
	Capi.Callback.add (verText, Capi.Callback.Activate, updateCloseButtons);
	Capi.remove_menu menuBar;
	Capi.set_close_callback (frame, close);
	do_layout();
	reset();
	(fn () => (visible := true;
		  update();
		  Capi.reveal frame;
		  Capi.reveal shell;
		  Capi.to_front shell),
	close)

      end  (* mk_about_dialog *)
@


1.1.1.14
log
@[Bug #30071]
Add directory location for modes.
Remove objects location from configurations.
@
text
@a2 4
 *  Revision 1.1.1.13  1998/01/06  15:01:46  johnh
 *  [Bug #30071]
 *  Fix problems with setting library path.
 *
a123 1
     location = ref "Debug",
a135 1
     location = ref "Release",
d1037 2
a1038 2
	val modes = ref []
	val modeDetails = ref ([]: mode_details list)
a1052 1
	   location			= ref modeName,  (* default of name of mode *)
d1066 1
a1066 1
	    ProjFile.getModeDetails (#1 (valOf (!modeSel)), !modeDetails)
d1103 1
a1103 1
	    modeSel updateModesRef modes
d1118 1
a1118 1
	      updateModes (!modes)
d1126 1
a1126 1
		List.find (fn {name=n,...} => name=n) (!modeDetails)
d1148 1
a1148 1
	  (modeDetails := addModeDetails (!modes);
d1155 1
a1155 1
	  removeSelCB (modeSel, modes, modeChanged) updateModes
d1168 1
a1168 1
	       updateModes (!modes))
d1188 1
a1188 1
	    if not (mode is_in (!modes)) andalso mode <> "" then 
d1190 1
a1190 1
		val new_modes = (mode,1) :: (map renumber_up (!modes))
a1203 35
	val locLabel = Capi.make_managed_widget
				("PWM_locLabel", Capi.Label, frame, [])
	val locText = Capi.make_managed_widget
				("PWM_locText", Capi.Text, frame, [])

	val locChangeRC = Capi.make_managed_widget
				("PWM_locChangeRC", Capi.RowColumn, frame, [])

	fun locChangeCB () = 
	  if isSome (!modeSel) then
	    let 
	      val dirName = parse_name (Capi.Text.get_string locText)
	      val {name, location, ...} = get_mode_details()
	    in
	      location := dirName;
	      Capi.Text.set_string (locText, "");
	      modeChanged := true;
	      updateModes (!modes)
	    end
	  else ()

	val {update=updateLocButton, ...} = 
	  Menus.make_buttons (locChangeRC, 
		[Menus.PUSH ("PWM_locChange", locChangeCB, fn _ => isSome(!modeSel))])

	fun updateModeLoc () = 
	  if isSome(!modeSel) then
	    let 
	      val {location, ...} = get_mode_details()
	    in
	      Capi.set_label_string (locLabel, "Mode directory name:  " ^ (!location))
	    end
	  else
	    Capi.set_label_string (locLabel, "Mode directory name:  <No mode selected>")

d1207 1
a1207 1
	fun update () = updateModes (!modes)
d1211 1
a1211 1
	    val modeNames = map #1 (!modes)
d1215 1
a1215 1
	      (ProjFile.setModes (modeNames, !modeDetails);
d1233 2
a1234 2
	    modes := number_entries (modeList, 1);
	    modeDetails := details;
a1263 3
		 Capi.Layout.FIXED locLabel,
		 Capi.Layout.FIXED locText,
		 Capi.Layout.FIXED locChangeRC,
d1274 1
a1274 3
				     updateModeButtons();
				     updateModeLoc();
				     updateLocButton()));
d1293 2
d1315 3
a1317 1
	   library = []}
d1319 1
a1319 1
	fun modifyConfigDetails ((n, source, lib), configRef) = 
d1321 1
a1321 1
	    ({name=n, source=source, library=lib}, !configRef)
d1413 1
a1413 1
	  let val {name, source, library} = get_cf_details()
d1418 1
a1418 1
		modifyConfigDetails ((name, theList, library), 
d1436 1
a1436 1
	  let val {name, source, library} = get_cf_details()
d1441 1
a1441 1
		modifyConfigDetails ((name, source, theList), 
d1460 69
d1532 3
a1534 1
		 Menus.PUSH ("PWC_libraryPath", setPathCB libPath, is_sel)])
d1567 7
a1573 1
		 callerUpdate(valOf(details)) 
d1619 1
a1619 1
	       val {name, source, library} = get_cf_details()
d1622 2
a1623 1
	       Capi.Text.set_string (libraryText, list2str library)
d1642 3
d1677 1
d1723 7
d1734 4
a1737 2
	  (ProjFile.setLocations (!localLibPath, !objectsLoc, !binariesLoc);
	   callerUpdate (!objectsLoc, !binariesLoc) (!localLibPath);
d1809 4
a1812 2
	    if objLoc then updateLoc objectsLoc else updateLoc binariesLoc;
	    updateObjBin()
d1818 2
a1819 2
		 Menus.PUSH ("PWL_setObjLoc", setObjBinLoc true, fn _ => true)])
(* BBB		 Menus.PUSH ("PWL_setBinLoc", setObjBinLoc false, fn _ => true)]) *)
d1833 7
a1839 3
	  (relativeObj := b;
	   setRel (objectsLoc,
	     (if b then OS.Path.mkRelative else OS.Path.mkAbsolute)))
d1842 7
a1848 3
	  (relativeBin := b;
	   setRel (binariesLoc,
	     (if b then OS.Path.mkRelative else OS.Path.mkAbsolute)))
d1852 2
a1853 2
	    [Menus.TOGGLE ("PWL_relativeObj", getRelObj, setRelObj, fn _ => true)])
(* BBB	     Menus.TOGGLE ("PWL_relativeBin", getRelBin, setRelBin, fn _ => true)]) *)
d1979 2
a1980 2
	Capi.Callback.add (descText, Capi.Callback.ValueChange, updateCloseButtons);
	Capi.Callback.add (verText, Capi.Callback.ValueChange, updateCloseButtons);
@


1.1.1.15
log
@[Bug #30071]
Split locations dialog in two.
@
text
@a2 5
 *  Revision 1.1.1.14  1998/01/09  11:55:46  johnh
 *  [Bug #30071]
 *  Add directory location for modes.
 *  Remove objects location from configurations.
 *
d507 1
a507 2
		OS.Path.mkCanonical
		  (OS.Path.mkRelative (rawDir, ProjFile.getProjectDir ()))
d1652 5
a1656 1
    fun mk_library_dialog (parent, callerUpdate) = 
d1658 25
a1682 1
	fun getLibPath() = #1 (ProjFile.getLocations())
d1684 13
a1696 3
	fun setLibPath dirList = 
	  let
	    val (libPath, objDir, binDir) = ProjFile.getLocations()
d1698 5
a1702 2
	    callerUpdate (list2str dirList);
	    ProjFile.setLocations (dirList, objDir, binDir)
d1705 27
d1733 4
a1736 1
	  mk_path_dialog (parent, "lib_path", getLibPath, setLibPath)
d1738 32
a1769 5
      in
	((fn () => 
	    mkLibPath "Ordered list of directories where library files are found:"),
	 closeLibPath)
      end
d1771 2
a1772 9
    fun set_objects_dir (parent, objRelativeRef, callerUpdate) = 
      let 
	val rawText = get_directory (parent, MAY_EXIST)
	val text = 
	  if (!objRelativeRef) then 
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
	  else
	    rawText
d1774 17
a1790 9
	val (libPath, objDir, binDir) = ProjFile.getLocations()
	val (_, _, curConfig) = ProjFile.getConfigurations()
      in
	if (text <> "") andalso (text <> objDir) then 
	  (need_saved := true;
	   ProjFile.setLocations (libPath, text, binDir);
	   callerUpdate (OS.Path.concat(text, getOpt(curConfig, ""))))
	else ()
      end
d1792 4
a1795 9
    fun set_binaries_dir (parent, binRelativeRef, callerUpdate) = 
      let 
	val rawText = get_directory (parent, MAY_EXIST)
	val text = 
	  if (!binRelativeRef) then 
	    OS.Path.mkCanonical
	      (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
	  else
	    rawText
d1797 12
a1808 9
	val (libPath, objDir, binDir) = ProjFile.getLocations()
	val (_, _, curConfig) = ProjFile.getConfigurations()
      in
	if (text <> "") andalso (text <> binDir) then 
	  (need_saved := true;
	   ProjFile.setLocations (libPath, objDir, text);
	   callerUpdate (OS.Path.concat(text, getOpt(curConfig, ""))))
	else ()
      end
d1810 12
a1821 8
    fun setRelObjBin (objChange, callerUpdate, relRef) b = 
      let
	val (lib, obj, bin) = ProjFile.getLocations()
	val (_, _, curConfig) = ProjFile.getConfigurations()
	val relAbs = if b then OS.Path.mkRelative else OS.Path.mkAbsolute
	val valueChange = if objChange then obj else bin
	val newValue = 
	  OS.Path.mkCanonical (relAbs (valueChange, ProjFile.getProjectDir ()))
d1823 13
a1835 8
	relRef := b;
	need_saved := true;
	if objChange then 
	  ProjFile.setLocations (lib, newValue, bin)
	else
	  ProjFile.setLocations (lib, obj, newValue);
	callerUpdate (OS.Path.concat(newValue, getOpt(curConfig, "")))
      end	
@


1.1.1.16
log
@[Bug #30071]
Introducing subprojects.
@
text
@a2 4
 *  Revision 1.1.1.15  1998/01/12  15:15:56  johnh
 *  [Bug #30071]
 *  Split locations dialog in two.
 *
a157 1
  val orig_proj = ref NONE
a165 1
       need_saved := false;
d201 3
a203 3
	    save_project parent
	  else false
	else false;
a212 1
       orig_proj := NONE;
d224 1
a224 2
      let 
	val filename = Capi.open_file_dialog (parent, ".mlp")
a231 1
	   orig_proj := filename;
d241 1
a241 1
	 SOME s => OS.Path.mkCanonical s
d255 1
a255 1
           SOME s => OS.Path.mkCanonical s
d614 1
a614 8
      updatePathsRef := 
	(fn () => 
	  (update(); 
	   updateCloseButtons(); 
	   if (!path_items) <> [] then
	     relativePaths := OS.Path.isRelative (#1(hd(!path_items)))
	   else ();
	   updateRel()));
a654 182

    fun mk_subprojects_dialog (parent, callerUpdate, updatePW) = 
      let
	val visible = ref false
	val subChange = ref false
	val subSel = ref NONE
	val subprojects = ref []
	val relSubproj = ref false

	fun isSel () = isSome(!subSel)

	val (shell, frame, menuBar, _) = 
	  Capi.make_main_popup ("propSubProjectsDialog", "Project Properties - Subprojects", 
				parent, false, visible)
	val label = Capi.make_managed_widget 
				("PWS_subprojLabel", Capi.Label, frame, [])

	val updateSubsRef = ref (fn () => ())

	val (scroll, set_new_projs) = 
	  mk_list (frame, "proj_list")
	    subSel updateSubsRef subprojects

	fun apply () = 
	  (ProjFile.setSubprojects (map #1 (!subprojects));
	   callerUpdate (map #1 (!subprojects));
	   subChange := false;
	   set_new_projs (!subprojects);
	   true)

	fun reset () = 
	  (subprojects := number_entries (ProjFile.getSubprojects(), 1);
	   subSel := NONE;
	   subChange := false;
	   set_new_projs (!subprojects))

	fun close () = 
	  (reset();
	   visible := false;
	   Capi.set_focus (Capi.parent shell);
	   Capi.hide shell)

	fun addNewProj () = 
	  let 
	    val rawText = 
	      case Capi.open_file_dialog (shell, ".mlp") of
		 SOME p => OS.Path.mkCanonical p
	      |  NONE => ""
	    val file = 
	      if (!relSubproj) then 
		OS.Path.mkCanonical
		  (OS.Path.mkRelative (rawText, ProjFile.getProjectDir ()))
	      else
		rawText

	    fun isCurProj n = 
	      n = OS.Path.mkCanonical (valOf (ProjFile.getProjectName()))
	  in
	    if rawText = "" orelse file is_in !subprojects then ()
	    else 
	      if isSome (List.find isCurProj (ProjFile.getSubProjects rawText)) then 
		Capi.send_message(shell, 
			"Can't add subproject - results in circular reference")
	      else
	        let
	          val new_projects = 
		    (file, 1) :: (map renumber_up (!subprojects))
	        in
		  subSel := SOME (file, 1);
		  subChange := true;
		  set_new_projs new_projects		
	        end
	  end

	fun removeSel () = removeSelCB (subSel, subprojects, subChange) set_new_projs
	fun openProj' () = 
	  if test_save shell then
	    (ProjFile.open_proj (#1(valOf(!subSel)));
 	     case (!orig_proj) of 
	       NONE => (orig_proj := ProjFile.getProjectName(); updatePW true)
	     | SOME f => updatePW (f = getOpt (ProjFile.getProjectName(), ""));
	     need_saved := false)
	  else ()

	fun openProj () = 
	  (if (!subChange) then need_saved := true else ();
	   apply();
	   openProj'())

	val projRC = Capi.make_managed_widget 
				("PWS_projRC", Capi.RowColumn, frame, [])

	fun backProj' () = 
	  if test_save shell then
	    (case (!orig_proj) of
	       NONE => orig_proj := ProjFile.getProjectName()
	     | SOME filename => ProjFile.open_proj filename;
	     updatePW true)
	  else ()

	fun backProj () = 
	  (if (!subChange) then need_saved := true else ();
	   apply();
	   backProj'())

	fun backSens () = 
	  case (!orig_proj) of 
	    NONE => false
	  | SOME f => f <> getOpt(ProjFile.getProjectName(), "")

	val {update, ...} = 
	  Menus.make_buttons (projRC, 
		[Menus.PUSH ("PWS_addProj", addNewProj, fn _ => true),
		 Menus.PUSH ("PWS_removeProj", removeSel, isSel),
		 Menus.PUSH ("PWS_openProj", openProj, isSel),
		 Menus.PUSH ("PWS_backProj", backProj, backSens)])

	fun getRel () = (!relSubproj)
	fun setRel b = 
	  if b then 
	    (relSubproj := true;
	     subChange := true;
	     subprojects := toRel (!subprojects) (fn _ => ());
	     set_new_projs (!subprojects))
	  else
	    (relSubproj := false;
	     subChange := true;
	     subprojects := toAbs (!subprojects) (fn _ => ());
	     set_new_projs (!subprojects))

	val relProjRC = Capi.make_managed_widget 
				("PWS_relProjRC", Capi.RowColumn, frame, [])

	val {update = updateRel, ...} = 
	  Menus.make_buttons (relProjRC, 
		[Menus.TOGGLE ("PWS_relProj", getRel, setRel, fn _ => true)])

	val (closeRC, updateCloseButtons) = 
	  mkCloseButtons {parent = frame, 
			  apply = apply,
			  reset = reset,
			  close = close,
			  changed = fn () => (!subChange)}

	fun do_layout () = 
	  Capi.Layout.lay_out (frame, 
		[Capi.Layout.FIXED label,
		 Capi.Layout.FIXED relProjRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FLEX scroll,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED projRC,
		 Capi.Layout.SPACE,
		 Capi.Layout.FIXED closeRC,
		 Capi.Layout.SPACE])

      in 
        Capi.remove_menu menuBar;
        Capi.set_close_callback (frame, close);
        do_layout();

        updateSubsRef := 
	  (fn () => 
	    (update(); 
	     updateCloseButtons(); 
	     if (!subprojects) <> [] then
	       relSubproj := OS.Path.isRelative (#1(hd(!subprojects)))
	     else ();
	     updateRel()));

       ((fn () => 
	 (if (!subprojects) <> [] then 
	    relSubproj := OS.Path.isRelative (#1(hd(!subprojects)))
	  else ();
    	  visible := true;
    	  set_new_projs (!subprojects);
    	  Capi.reveal frame;
    	  Capi.reveal shell;
    	  Capi.to_front shell)),
        reset)

      end (* mk_subprojects_dialog *)
@
