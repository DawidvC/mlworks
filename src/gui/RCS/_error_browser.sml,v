head	1.29;
access;
symbols
	MLW_daveb_inline_1_4_99:1.29.1
	MLWorks_21c0_1999_03_25:1.29
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.29
	MLWorks_20b2c2_1998_06_19:1.29
	MLWorks_20b2_Windows_1998_06_12:1.29
	MLWorks_20b1c1_1998_05_07:1.29
	MLWorks_20b0_1998_04_07:1.28
	MLWorks_20b0_1998_03_20:1.27
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.24
	MLWorks_11r1:1.20.4.1.1.1.1
	MLWorks_workspace_97:1.23.2
	MLWorks_dt_wizard:1.23.1
	MLWorks_11c0_1997_09_09:1.20.4.1.1.1
	MLWorks_10r3:1.20.4.1.3
	MLWorks_10r2_551:1.20.4.1.2
	MLWorks_11:1.20.4.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.20.4.1
	MLWorks_20m0_1997_06_20:1.23
	MLWorks_1_0_r2c2_1997_06_14:1.20.4.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.20.4.1
	MLWorks_1_0_r2c1_1997_05_12:1.20.4
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.20
	MLWorks_1_0_r2_Unix_1997_04_04:1.20
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.20.2.1.1
	MLWorks_gui_1996_12_18:1.20.3
	MLWorks_1_0_Win32_1996_12_17:1.20.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.1.1
	JFHgui:1.20.1
	MLWorks_1_0_Irix_1996_11_28:1.19.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.2
	MLWorks_1_0_Unix_1996_11_14:1.19.1
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.16
	MLWorks_Beta_1996_06_07:1.16
	MLWorks_Beta_1996_06_06:1.16
	MLWorks_Beta_1996_06_05:1.16
	MLWorks_Beta_1996_06_03:1.16
	MLWorks_Beta_1996_05_31:1.16
	MLWorks_Beta_1996_05_30:1.16;
locks; strict;
comment	@ * @;


1.29
date	98.04.29.15.03.26;	author johnh;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	98.03.31.15.15.06;	author johnh;	state Exp;
branches;
next	1.27;

1.27
date	98.02.17.16.36.20;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	98.01.27.15.57.14;	author johnh;	state Exp;
branches;
next	1.25;

1.25
date	97.10.30.09.49.55;	author johnh;	state Exp;
branches;
next	1.24;

1.24
date	97.09.24.10.48.18;	author johnh;	state Exp;
branches;
next	1.23;

1.23
date	97.06.12.16.41.53;	author johnh;	state Exp;
branches
	1.23.1.1
	1.23.2.1;
next	1.22;

1.22
date	97.05.16.15.35.40;	author johnh;	state Exp;
branches;
next	1.21;

1.21
date	97.04.14.17.55.25;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	96.12.03.20.52.44;	author daveb;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1;
next	1.19;

1.19
date	96.11.06.11.15.52;	author matthew;	state Exp;
branches
	1.19.1.1
	1.19.2.1;
next	1.18;

1.18
date	96.10.09.16.06.13;	author io;	state Exp;
branches;
next	1.17;

1.17
date	96.07.05.14.24.04;	author daveb;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1;
next	1.16;

1.16
date	96.05.08.18.28.08;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	96.05.08.14.40.33;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.05.07.11.40.04;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.05.01.10.54.30;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.04.30.10.02.17;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.02.23.11.34.09;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	96.02.22.16.58.50;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	96.02.05.11.51.18;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	96.01.25.14.44.21;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	96.01.22.12.11.39;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.22.13.44.47;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.09.11.15.25.19;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.30.13.23.36;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.12.19.27;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.56.07;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.46.08;	author matthew;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.13.01;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.03.41;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.21.56;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	96.11.14.12.45.50;	author hope;	state Exp;
branches
	1.19.1.1.1.1;
next	;

1.19.1.1.1.1
date	96.11.28.14.57.41;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.11.22.18.06.18;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.12.17.09.54.20;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.12.17.17.45.00;	author hope;	state Exp;
branches
	1.20.2.1.1.1;
next	;

1.20.2.1.1.1
date	97.02.24.11.34.28;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.12.18.09.38.59;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	97.05.12.10.31.19;	author hope;	state Exp;
branches
	1.20.4.1.1.1
	1.20.4.1.2.1
	1.20.4.1.3.1;
next	;

1.20.4.1.1.1
date	97.07.28.18.17.11;	author daveb;	state Exp;
branches
	1.20.4.1.1.1.1.1;
next	;

1.20.4.1.1.1.1.1
date	97.10.07.11.42.02;	author jkbrook;	state Exp;
branches;
next	;

1.20.4.1.2.1
date	97.09.08.17.10.44;	author daveb;	state Exp;
branches;
next	;

1.20.4.1.3.1
date	97.09.09.14.06.19;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	97.09.10.19.20.47;	author brucem;	state Exp;
branches;
next	;

1.23.2.1
date	97.09.11.20.52.01;	author daveb;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	97.11.20.17.04.44;	author johnh;	state Exp;
branches;
next	;

1.29.1.1
date	99.04.01.17.55.26;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.29
log
@[Bug #50076]
Called the correct quit function so that EB is not destroyed twice.
@
text
@(*
 * Copyright (c) 1994 Harlequin Ltd.
 * $Log: _error_browser.sml,v $
 * Revision 1.28  1998/03/31  15:15:06  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos.
 *
 * Revision 1.27  1998/02/17  16:36:20  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.26  1998/01/27  15:57:14  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.25  1997/10/30  09:49:55  johnh
 * [Bug #30296]
 * Add buttons for the three main actions.
 *
 * Revision 1.24  1997/09/24  10:48:18  johnh
 * [Bug #30231]
 * Put call to Capi.remove_main_window in quit functions.
 *
 * Revision 1.23.2.2  1997/11/20  17:04:44  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.23.2.1  1997/09/11  20:52:01  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.23  1997/06/12  16:41:53  johnh
 * [Bug #30175]
 * Combine tools and windows menu - goodbye windows menu.
 *
 * Revision 1.22  1997/05/16  15:35:40  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.21  1997/04/14  17:55:25  jont
 * [Bug #2049]
 * Make sure file location is used in error browser title where appropriate
 *
 * Revision 1.20  1996/12/03  20:52:44  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
 * Revision 1.19  1996/11/06  11:15:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.18  1996/10/09  16:06:13  io
 * moving String from toplevel
 *
 * Revision 1.17  1996/07/05  14:24:04  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
 * Revision 1.16  1996/05/08  18:28:08  daveb
 * quit_fun can now be called more than once, so we have to make this safe.
 *
 * Revision 1.15  1996/05/08  14:40:33  daveb
 * Made create return a function that kills the browser.
 *
 * Revision 1.14  1996/05/07  11:40:04  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.13  1996/05/01  10:54:30  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.12  1996/04/30  10:02:17  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.11  1996/02/23  11:34:09  daveb
 * Made the error_to_string function exportable.
 *
 * Revision 1.10  1996/02/22  16:58:50  daveb
 * Added close_action.
 *
 * Revision 1.9  1996/02/05  11:51:18  daveb
 * Capi.make_scrolllist now returns a record, with an add_items field.
 *
 * Revision 1.8  1996/01/25  14:44:21  daveb
 * Replaced title text widgets with labels.
 *
 * Revision 1.7  1996/01/22  12:11:39  daveb
 * Corrected title.
 *
 * Revision 1.6  1995/09/22  13:44:47  daveb
 * Changed edit_action parameter to return both a quit_fn and a clean_fn, with
 * each new call to edit_error calling the previous clean_fn.  (This is used
 * to remove highlighting in the evaluator).
 *
 * Revision 1.5  1995/09/11  15:25:19  matthew
 * Changing top level window initialization
 *
 * Revision 1.4  1995/08/30  13:23:36  matthew
 * Renaming layout constructors
 *
 * Revision 1.3  1995/08/10  12:19:27  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:56:07  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:46:08  matthew
 * new unit
 * New unit
 *
 *  Revision 1.7  1995/07/07  15:24:46  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.6  1995/07/04  13:58:15  matthew
 *  Capification
 *
 *  Revision 1.5  1995/05/25  17:40:26  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.4  1994/08/02  10:22:57  daveb
 *  Added sensitivity to edit button on actions menu.
 *
 *  Revision 1.3  1994/07/26  16:25:38  daveb
 *  Changed menu slightly.  Made first item be selected on startup.
 * 
 *  Revision 1.2  1994/05/20  11:55:44  daveb
 *  Revised interface.
 * 
 *  Revision 1.1  1994/05/13  15:55:04  daveb
 *  new file
 * 
 *)

require "../basis/__int";
require "../utils/lists";
require "capi";
require "menus";
require "../interpreter/shell_utils";
require "gui_utils";
require "tooldata";
require "error_browser";

functor ErrorBrowser(
  structure Lists : LISTS
  structure Capi : CAPI
  structure Menus : MENUS
  structure GuiUtils : GUI_UTILS
  structure ShellUtils : SHELL_UTILS
  structure ToolData : TOOL_DATA

  sharing type Capi.Widget = Menus.Widget = GuiUtils.Widget = ToolData.Widget
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type GuiUtils.user_tool_options = ShellUtils.UserOptions
               
) : ERROR_BROWSER =
  struct
    structure Info = ShellUtils.Info
    structure Location = Info.Location

    type Widget = Capi.Widget
    type Context = ShellUtils.Context
    type options = ShellUtils.Options.options
    type error = Info.error
    type location = Location.T
    type ToolData = ToolData.ToolData
    type user_context = ToolData.ShellTypes.user_context

    fun first_line message =
      let
        fun aux ([],acc) = acc
          | aux (#"\n" :: _,acc) = acc
          | aux (c::l,acc) = aux(l,c::acc)
      in
	 implode (rev (aux (explode message, [])))
      end
        
    fun location_line location =
      case location of
          Location.UNKNOWN => ""
        | Location.FILE s => ""
        | Location.LINE(_,l) => "Line " ^ Int.toString l
        | Location.POSITION (_,l,_) => "Line " ^ Int.toString l
        | Location.EXTENT {s_line,e_line,...} =>
            if s_line = e_line
              then "Line " ^ Int.toString s_line
            else "Line " ^ Int.toString s_line ^ " to " ^ Int.toString e_line
                
    fun error_location (Info.ERROR(_,location,message)) = location

    fun error_to_string (Info.ERROR(severity,location,message)) =
      (case location_line location of
         "" => "error: " ^ first_line message
        | l => l ^ ": error: " ^ first_line message)

    fun print_fn _ (Info.ERROR(severity,location,message)) =
      (case location_line location of
         "" => first_line message
        | l => l ^ ": " ^ first_line message)

    val posRef = ref NONE
    val sizeRef = ref NONE

    fun create
      {parent, errors, file_message, editable, edit_action, 
	redo_action, close_action, mk_tooldata, get_context} =
      let 
        val (shell,mainWindow,menuBar,_) =
          Capi.make_main_popup {name = "errorBrowser", 
				title = "Error Browser",
                                parent = parent, 
				contextLabel = false, 
				visibleRef = ref true,
				pos = getOpt (!posRef, Capi.getNextWindowPos())}

        val frame =
	  Capi.make_managed_widget
	    ("errorBrowserFrame", Capi.Paned, mainWindow, [Capi.PanedMargin true])

        val listPane = Capi.make_managed_widget ("listPane", Capi.Form, frame, [])

        val reason = Capi.make_managed_widget
	  ("errorBrowserTitle", Capi.Label, listPane, [])

        val textPane = Capi.make_managed_widget ("textPane", Capi.Form, frame, [])

        val textTitle = Capi.make_managed_widget
	      ("errorTextLabel", Capi.Label, textPane, [])

        val (textScroll,text) =
	  Capi.make_scrolled_text ("errorBrowserText", textPane, [])

        fun message_fun s = Capi.send_message (shell,s)

        val quit_funs = ref []
	  (* These are evaluated when the Close or Redo actions are selected *)

	val good_clean_fun = ref (fn () => ())
	  (* This is evaluated (and then updated) when the Edit action is selected. *)

        fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

        fun edit_error _ (Info.ERROR(_,location,_)) =
          let
	    val _ = (!good_clean_fun) ();
            val {quit_fn, clean_fn} = edit_action location
          in
            quit_funs := quit_fn :: (!quit_funs);
	    good_clean_fun := clean_fn
          end
        handle ShellUtils.EditFailed s =>
          message_fun ("Edit failed: " ^ s)

        fun show_full_message _ (Info.ERROR(_,_,message)) =
          Capi.Text.set_string(text,message)

        val {scroll,list,set_items,...} =
	  Capi.make_scrolllist
	    {parent = listPane, name = "errorBrowser",
	     select_fn = show_full_message,
             action_fn = edit_error,
             print_fn = print_fn}

        fun edit_fun _ =
          let
            val selected_items = Capi.List.get_selected_pos list
          in
            case MLWorks.Internal.Vector.length selected_items of
               0 => message_fun "No item selected"
             | 1 =>
                 let val index = MLWorks.Internal.Vector.sub(selected_items,0)
                 in
                   edit_error (scroll,list,set_items) 
				(Lists.nth (index-1,errors))
                 end
             | _ => message_fun "Multiple selections"
          end

	fun can_edit _ =
	  let
            val selected_items = Capi.List.get_selected_pos list
          in
	    if MLWorks.Internal.Vector.length selected_items = 1 then
	      let
		val index = MLWorks.Internal.Vector.sub(selected_items,0)
	      in
		case Lists.nth (index-1,errors) of
		   Info.ERROR(_,location,_) => editable location
	      end
	    else
	      false
          end

	local
	  val destroyed = ref false
	in
	  fun quit_fun _ =
	    if not (!destroyed) then
              (* Widget should be reused *)
              (* Though we would like to have more than one at once *)
	      ((!good_clean_fun) ();
	       do_quit_funs();
	       destroyed := true;
	       Capi.remove_main_window shell;
	       Capi.destroy shell)
	     else ()
	end

	fun redo_fun _ =
	  (quit_fun ();
	   redo_action ())

	fun close_fun _ =
	  (quit_fun ();
	   close_action ())

	fun storeSizePos () = 
	  (sizeRef := SOME (Capi.widget_size shell);
	   posRef := SOME (Capi.widget_pos shell))

	val buttonPane =
	  Capi.make_managed_widget ("buttonPane", Capi.RowColumn, textPane, []);

	val _ = 
	  Menus.make_buttons
	    (buttonPane,
	     [Menus.PUSH ("repeatButton", redo_fun, fn _ => true),
	      Menus.PUSH ("editSourceButton", edit_fun, can_edit),
	      Menus.PUSH ("closeButton", close_fun, fn _ => true)])

        val menuspec =
          [ToolData.file_menu [("close", close_fun, fn _ => true)],
           ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
	     copy = SOME (fn _ => Capi.clipboard_set (text,Capi.Text.get_selection text)),
             delete = NONE,
             selection_made = fn _ => Capi.Text.get_selection text <> "",
	     edit_possible = fn _ => false,
	     delete_all = NONE,
	     edit_source = [Menus.PUSH ("editSource", edit_fun, can_edit)] }),
	   ToolData.tools_menu (mk_tooldata, get_context),
	   ToolData.usage_menu ([("repeat", redo_fun, fn _ => true)], []),
	   ToolData.debug_menu []]

	val textPaneLayout =
	  (textPane,
	   [Capi.Layout.FIXED textTitle,
	    Capi.Layout.FLEX textScroll,
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED buttonPane]);
	    
	val listPaneLayout =
	  (listPane,
           [Capi.Layout.FIXED reason,
	    Capi.Layout.FLEX scroll]);
      in
        quit_funs := Menus.quit :: (!quit_funs);
        quit_funs := storeSizePos :: (!quit_funs);
	quit_funs := (fn _ => Capi.remove_main_window shell) :: (!quit_funs);
        Capi.Layout.lay_out
          (mainWindow, !sizeRef,
           [Capi.Layout.MENUBAR menuBar,
            Capi.Layout.PANED (frame, [textPaneLayout, listPaneLayout]),
            Capi.Layout.SPACE]);
            (* Note the destroy method is added to the parent of the popup shell *)
        Menus.make_submenus(menuBar,menuspec);
        Capi.Callback.add (mainWindow, Capi.Callback.Unmap, quit_fun);
        Capi.set_close_callback (mainWindow, close_fun);
        Capi.Callback.add (Capi.parent shell, Capi.Callback.Destroy, quit_fun);
        set_items ShellUtils.Options.default_print_options errors;
        Capi.set_label_string (reason, "Location: " ^ file_message);
        Capi.reveal mainWindow;
	Capi.List.select_pos (list, 1, false);
        show_full_message (scroll,list,set_items) (Lists.nth (0,errors));
	quit_fun
      end

  end;
@


1.29.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.29  1998/04/29  15:03:26  johnh
 * [Bug #50076]
 * Called the correct quit function so that EB is not destroyed twice.
 *
@


1.28
log
@[Bug #30346]
Call Capi.getNextWindowPos.
@
text
@d4 4
d370 1
a370 1
        Capi.Callback.add (mainWindow, Capi.Callback.Unmap, do_quit_funs);
d372 1
a372 1
        Capi.Callback.add (Capi.parent shell, Capi.Callback.Destroy,do_quit_funs);
@


1.27
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d4 4
d211 1
a211 1
				pos = getOpt (!posRef, (100,100))}
@


1.26
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d194 3
d202 6
a207 2
          Capi.make_main_popup ("errorBrowser", "Error Browser",
                                parent, false, ref true)
d310 4
d353 1
d356 1
a356 1
          (mainWindow,
@


1.25
log
@[Bug #30296]
Add buttons for the three main actions.
@
text
@d4 4
d12 7
d323 1
a323 2
	   ToolData.debug_menu [],
	   GuiUtils.paths_menu mainWindow]
@


1.24
log
@[Bug #30231]
Put call to Capi.remove_main_window in quit functions.
@
text
@d4 4
d288 10
d318 3
a320 1
	    Capi.Layout.FLEX textScroll]);
@


1.23
log
@[Bug #30175]
Combine tools and windows menu - goodbye windows menu.
@
text
@d4 4
d312 1
@


1.23.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.23  1997/06/12  16:41:53  johnh
 * [Bug #30175]
 * Combine tools and windows menu - goodbye windows menu.
 *
@


1.23.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a3 3
 * Revision 1.23.2.1  1997/09/11  20:52:01  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d298 2
a299 1
	   ToolData.debug_menu []]
@


1.23.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.23  1997/06/12  16:41:53  johnh
 * [Bug #30175]
 * Combine tools and windows menu - goodbye windows menu.
 *
@


1.22
log
@Implementing single menu bar on Windows.
@
text
@d4 3
d267 1
d295 1
a295 2
	   GuiUtils.paths_menu mainWindow,
	   ToolData.windows_menu ()]
@


1.21
log
@[Bug #2049]
Make sure file location is used in error browser title where appropriate
@
text
@d4 4
d108 1
d117 1
d119 2
a120 2
  sharing type Capi.Widget = Menus.Widget = GuiUtils.Widget
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec
d133 64
d198 6
a203 1
        fun first_line message =
d205 2
a206 3
            fun aux ([],acc) = acc
              | aux (#"\n" :: _,acc) = acc
              | aux (c::l,acc) = aux(l,c::acc)
d208 8
a215 15
	    implode (rev (aux (explode message, [])))
	  end
        
        fun location_line location =
          case location of
            Location.UNKNOWN => ""
          | Location.FILE s => ""
          | Location.LINE(_,l) => "Line " ^ Int.toString l
          | Location.POSITION (_,l,_) => "Line " ^ Int.toString l
          | Location.EXTENT {s_line,e_line,...} =>
              if s_line = e_line
                then "Line " ^ Int.toString s_line
              else "Line " ^ Int.toString s_line ^ " to " ^ Int.toString e_line
                
        fun error_location (Info.ERROR(_,location,message)) = location
d217 6
a222 86
        fun error_to_string (Info.ERROR(severity,location,message)) =
          (case location_line location of
             "" => "error: " ^ first_line message
           | l => l ^ ": error: " ^ first_line message)

        fun print_fn _ (Info.ERROR(severity,location,message)) =
          (case location_line location of
             "" => first_line message
           | l => l ^ ": " ^ first_line message)

        fun create
	      {parent, errors, file_message,
	       editable, edit_action, redo_action, close_action} =
          let 
            val (shell,mainWindow,menuBar,_) =
              Capi.make_main_popup ("errorBrowser",
                                    "Error Browser",
                                    parent, false)

            val frame =
	      Capi.make_managed_widget
	        ("errorBrowserFrame", Capi.Paned, mainWindow,
		 [Capi.PanedMargin true])

            val listPane = Capi.make_managed_widget
			     ("listPane", Capi.Form, frame, [])

            val reason = Capi.make_managed_widget
			   ("errorBrowserTitle", Capi.Label, listPane, [])

            val textPane = Capi.make_managed_widget
			     ("textPane", Capi.Form, frame, [])

            val textTitle = Capi.make_managed_widget
			      ("errorTextLabel", Capi.Label, textPane, [])

            val (textScroll,text) =
	      Capi.make_scrolled_text ("errorBrowserText", textPane, [])

            fun message_fun s = Capi.send_message (shell,s)

            val quit_funs = ref []
	    (* These are evaluated when the Close or Redo actions are
	       selected *)

	    val good_clean_fun = ref (fn () => ())
	    (* This is evaluated (and then updated) when the Edit action is
	       selected. *)

            fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

            fun edit_error _ (Info.ERROR(_,location,_)) =
              let
		val _ = (!good_clean_fun) ();
                val {quit_fn, clean_fn} = edit_action location
              in
                quit_funs := quit_fn :: (!quit_funs);
		good_clean_fun := clean_fn
              end
            handle ShellUtils.EditFailed s =>
              message_fun ("Edit failed: " ^ s)

            fun show_full_message _ (Info.ERROR(_,_,message)) =
              Capi.Text.set_string(text,message)

            val {scroll,list,set_items,...} =
	      Capi.make_scrolllist
		{parent = listPane, name = "errorBrowser",
		 select_fn = show_full_message,
                 action_fn = edit_error,
                 print_fn = print_fn}

            fun edit_fun _ =
              let
                val selected_items = Capi.List.get_selected_pos list
              in
                case MLWorks.Internal.Vector.length selected_items of
                  0 => message_fun "No item selected"
                | 1 =>
                    let val index = MLWorks.Internal.Vector.sub(selected_items,0)
                    in
                      edit_error (scroll,list,set_items) 
				 (Lists.nth (index-1,errors))
                    end
                | _ => message_fun "Multiple selections"
              end
d224 20
a243 1
	    fun can_edit _ =
d245 53
a297 48
                val selected_items = Capi.List.get_selected_pos list
              in
		if MLWorks.Internal.Vector.length selected_items = 1 then
		  let
		    val index = MLWorks.Internal.Vector.sub(selected_items,0)
		  in
		    case Lists.nth (index-1,errors) of
		      Info.ERROR(_,location,_) => editable location
		  end
		else
		  false
              end

	    local
	      val destroyed = ref false
	    in
	      fun quit_fun _ =
	        if not (!destroyed) then
                  (* Widget should be reused *)
                  (* Though we would like to have more than one at once *)
	          ((!good_clean_fun) ();
	           do_quit_funs();
		   destroyed := true;
	           Capi.destroy shell)
	         else
		   ()
	    end

	    fun redo_fun _ =
	      (quit_fun ();
	       redo_action ())

	    fun close_fun _ =
	      (quit_fun ();
	       close_action ())

            val menuspec =
	      Menus.CASCADE ("action",
               		     [Menus.PUSH ("edit", edit_fun, can_edit),
               		      Menus.PUSH ("redo", redo_fun, fn _ => true),
			      Menus.SEPARATOR,
              		      Menus.PUSH ("close", close_fun, fn _ => true)],
			     fn _ => true)

	    val textPaneLayout =
	      (textPane,
	       [Capi.Layout.FIXED textTitle,
		Capi.Layout.FLEX textScroll]);
d299 11
a309 12
	    val listPaneLayout =
	      (listPane,
               [Capi.Layout.FIXED reason,
		Capi.Layout.FLEX scroll]);
          in
            Capi.Layout.lay_out
              (mainWindow,
               [Capi.Layout.MENUBAR menuBar,
                Capi.Layout.PANED (frame, [textPaneLayout, listPaneLayout]),
                Capi.Layout.SPACE]);
             
            Menus.make_submenus(menuBar,[menuspec]);
d311 11
a321 10
            Capi.Callback.add (mainWindow, Capi.Callback.Unmap, do_quit_funs);
            Capi.set_close_callback (mainWindow, close_fun);
            Capi.Callback.add (Capi.parent shell, Capi.Callback.Destroy,do_quit_funs);
            set_items ShellUtils.Options.default_print_options errors;
            Capi.set_label_string (reason, "Location: " ^ file_message);
            Capi.reveal mainWindow;
	    Capi.List.select_pos (list, 1, false);
            show_full_message (scroll,list,set_items) (Lists.nth (0,errors));
	    quit_fun
          end
@


1.20
log
@Replaced the hacky mswindows simulation of unmap callbacks with a call
to Capi.set_close_callback.
@
text
@d4 4
a148 8

        fun location_file location =
          case location of
            Location.UNKNOWN => ""
          | Location.FILE f => f
          | Location.LINE(f,l) => f
          | Location.POSITION (f,l,_) => f
          | Location.EXTENT {name,...} => name
@


1.20.4.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/12/03  20:52:44  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.20.4.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.20.4.1  1997/05/12  10:31:19  hope
 * branched from 1.20
 *
@


1.20.4.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.20.4.1  1997/05/12  10:31:19  hope
 * branched from 1.20
 *
@


1.20.4.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.20.4.1  1997/05/12  10:31:19  hope
 * branched from 1.20
 *
@


1.20.4.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.20.4.1.1.1  1997/07/28  18:17:11  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/12/03  20:52:44  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/12/03  20:52:44  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.20.2.1.1.1
log
@branched from 1.20.2.1
@
text
@a3 3
 * Revision 1.20.2.1  1996/12/17  17:45:00  hope
 * branched from 1.20
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a3 4
 * Revision 1.20  1996/12/03  20:52:44  daveb
 * Replaced the hacky mswindows simulation of unmap callbacks with a call
 * to Capi.set_close_callback.
 *
@


1.19
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d306 1
@


1.19.2.1
log
@branched from 1.19
@
text
@a3 4
 * Revision 1.19  1996/11/06  11:15:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a3 4
 * Revision 1.19  1996/11/06  11:15:52  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.19.1.1.1.1
log
@branched from 1.19.1.1
@
text
@a3 3
 * Revision 1.19.1.1  1996/11/14  12:45:50  hope
 * branched from 1.19
 *
@


1.18
log
@moving String from toplevel
@
text
@d4 3
d90 1
a90 1
require "../basis/__integer";
@


1.17
log
@[Bug #1260]
Changed the Capi layout datatype so that the PANED constructor takes the
layout info for its sub-panes.  This enables the Windows layout code to
calculate the minimum size of each window.
@
text
@d4 6
a87 1

a92 1

d120 1
a120 1
              | aux ("\n" :: _,acc) = acc
d123 2
a124 2
            String.implode (rev (aux (String.explode message,[])))
          end
@


1.17.3.1
log
@branched from 1.17
@
text
@a3 6
 * Revision 1.17  1996/07/05  14:24:04  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a3 6
 * Revision 1.17  1996/07/05  14:24:04  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a3 6
 * Revision 1.17  1996/07/05  14:24:04  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
@


1.16
log
@quit_fun can now be called more than once, so we have to make this safe.
@
text
@d4 3
d275 2
a276 2
          in
	    Capi.Layout.lay_out
d280 2
a281 1
	    Capi.Layout.lay_out
d285 1
d289 1
a289 1
                Capi.Layout.PANED frame,
@


1.15
log
@Made create return a function that kills the browser.
@
text
@d4 3
d242 14
a255 6
	    fun quit_fun _ =
              (* Widget should be reused *)
              (* Though we would like to have more than one at once *)
	      ((!good_clean_fun) ();
	       do_quit_funs();
	       Capi.destroy shell);
@


1.14
log
@Array moving to MLWorks.Array
@
text
@d4 3
d284 2
a285 1
            show_full_message (scroll,list,set_items) (Lists.nth (0,errors))
@


1.13
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d210 1
a210 1
                case Vector.length selected_items of
d213 1
a213 1
                    let val index = Vector.sub(selected_items,0)
d225 1
a225 1
		if Vector.length selected_items = 1 then
d227 1
a227 1
		    val index = Vector.sub(selected_items,0)
@


1.12
log
@Replacing MLWorks.Integer with basis file
@
text
@d4 3
d104 1
a104 1
            implode (rev (aux (explode message,[])))
@


1.11
log
@Made the error_to_string function exportable.
@
text
@d4 3
d63 2
d108 2
a109 2
          | Location.LINE(_,l) => "Line " ^ MLWorks.Integer.makestring l
          | Location.POSITION (_,l,_) => "Line " ^ MLWorks.Integer.makestring l
d112 2
a113 2
                then "Line " ^ MLWorks.Integer.makestring s_line
              else "Line " ^ MLWorks.Integer.makestring s_line ^ " to " ^ MLWorks.Integer.makestring e_line
@


1.10
log
@Added close_action.
@
text
@d4 3
d120 6
a125 1
        fun error_to_string _ (Info.ERROR(severity,location,message)) =
d190 1
a190 1
                 print_fn = error_to_string}
@


1.9
log
@Capi.make_scrolllist now returns a record, with an add_items field.
@
text
@d4 3
d124 1
a124 1
	       editable, edit_action, redo_action} =
d225 4
d234 1
a234 1
              		      Menus.PUSH ("close", quit_fun, fn _ => true)],
@


1.8
log
@Replaced title text widgets with labels.
@
text
@d4 3
d174 1
a174 1
            val (listScroll,list,set_items) =
d190 1
a190 1
                      edit_error (listScroll,list,set_items) 
d237 1
a237 1
		Capi.Layout.FLEX listScroll]);
d252 1
a252 1
            show_full_message (listScroll,list,set_items) (Lists.nth (0,errors))
@


1.7
log
@Corrected title.
@
text
@d4 3
d117 1
a117 1
	      {parent, errors, action_message, file_message,
d124 1
a124 2
            val title = Capi.make_managed_widget ("errorBrowserTitle",Capi.Text,mainWindow,[])
            val title2 = Capi.make_managed_widget ("errorBrowserTitle",Capi.Text,mainWindow,[])
d130 14
a143 1
            val (scroll,text) = Capi.make_scrolled_text("errorBrowserText",frame,[])
d171 1
a171 1
            val (scroll,list,set_items) =
d173 1
a173 1
		{parent = frame, name = "errorBrowser",
d187 1
a187 1
                      edit_error (scroll,list,set_items) 
d227 8
d236 4
a239 8
            (mainWindow,
             [Capi.Layout.MENUBAR menuBar,
              Capi.Layout.SPACE,
              Capi.Layout.FIXED title,
              Capi.Layout.FIXED title2,
              Capi.Layout.SPACE,
              Capi.Layout.PANED frame,
              Capi.Layout.SPACE]);
d246 1
a246 2
            Capi.Text.set_string (title, action_message);
            Capi.Text.set_string (title2,file_message);
d249 1
a249 1
            show_full_message (scroll,list,set_items) (Lists.nth (0,errors))
@


1.6
log
@Changed edit_action parameter to return both a quit_fn and a clean_fn, with
each new call to edit_error calling the previous clean_fn.  (This is used
to remove highlighting in the evaluator).
@
text
@d4 5
d119 1
a119 1
                                    "ErrorBrowser",
@


1.5
log
@Changing top level window initialization
@
text
@d4 3
d110 1
a110 1
	       edit_action, redo_action} =
d126 1
d128 6
d139 2
a140 1
                val quit_fun = edit_action location
d142 2
a143 1
                quit_funs := quit_fun :: (!quit_funs)
d173 1
a173 1
	    fun editable _ =
d182 1
a182 1
		      Info.ERROR(_,location,_) => ShellUtils.editable location
d191 2
a192 1
	      (do_quit_funs();
d201 1
a201 1
               		     [Menus.PUSH ("edit", edit_fun, editable),
@


1.4
log
@Renaming layout constructors
@
text
@d4 3
d110 3
a112 3
              Capi.make_main_window ("errorBrowser",
                                     "ErrorBrowser",
                                     parent, false)
d211 1
a211 2
            Capi.reveal shell;
            Capi.initialize shell;
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
d195 2
a196 2
              Capi.Layout.OTHER title,
              Capi.Layout.OTHER title2,
a205 1
            Capi.manage text;
d208 2
a209 2
            Capi.manage shell;
            Capi.realize shell;
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d189 8
a196 7
            [Capi.Layout.MENUBAR menuBar,
             Capi.Layout.SPACE,
             Capi.Layout.OTHER title,
             Capi.Layout.OTHER title2,
             Capi.Layout.SPACE,
             Capi.Layout.PANED frame,
             Capi.Layout.SPACE];
@


1.1
log
@new unit
New unit
@
text
@d4 4
d32 2
a33 2
require "../library/capi";
require "../library/menus";
@
