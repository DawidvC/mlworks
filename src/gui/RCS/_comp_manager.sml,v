head	1.75;
access;
symbols
	MLWorks_20m1_1997_10_23:1.73
	MLWorks_11r1:1.64.1.1.1.1.1
	MLWorks_workspace_97:1.70.2
	MLWorks_dt_wizard:1.70.1
	MLWorks_11c0_1997_09_09:1.64.1.1.1.1
	MLWorks_10r3:1.64.1.1.3
	MLWorks_10r2_551:1.64.1.1.2
	MLWorks_11:1.64.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.64.1.1
	MLWorks_20m0_1997_06_20:1.68
	MLWorks_1_0_r2c2_1997_06_14:1.64.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.64.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.64.1
	MLWorks_BugFix_1997_04_24:1.64
	MLWorks_1_0_r2_Win32_1997_04_11:1.64
	MLWorks_1_0_r2_Unix_1997_04_04:1.64
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.61.2.1.1
	MLWorks_gui_1996_12_18:1.61.3
	MLWorks_1_0_Win32_1996_12_17:1.61.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.60.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.60.1.1
	JFHgui:1.61.1
	MLWorks_1_0_Irix_1996_11_28:1.60.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.60.2
	MLWorks_1_0_Unix_1996_11_14:1.60.1
	MLWorks_Open_Beta2_1996_10_11:1.56.3
	MLWorks_License_dev:1.56.2
	MLWorks_1_open_beta_1996_09_13:1.56.1
	MLWorks_Open_Beta_1996_08_22:1.56
	MLWorks_Beta_1996_07_02:1.49
	MLWorks_Beta_1996_06_07:1.49
	MLWorks_Beta_1996_06_06:1.49
	MLWorks_Beta_1996_06_05:1.49
	MLWorks_Beta_1996_06_03:1.49
	MLWorks_Beta_1996_05_31:1.49
	MLWorks_Beta_1996_05_30:1.48;
locks; strict;
comment	@ * @;


1.75
date	97.11.07.19.36.05;	author jont;	state Exp;
branches;
next	1.74;

1.74
date	97.10.20.16.04.15;	author jont;	state Exp;
branches;
next	1.73;

1.73
date	97.09.30.12.46.08;	author johnh;	state Exp;
branches;
next	1.72;

1.72
date	97.09.18.15.00.07;	author brucem;	state Exp;
branches;
next	1.71;

1.71
date	97.09.18.13.48.17;	author brucem;	state Exp;
branches;
next	1.70;

1.70
date	97.09.05.09.52.25;	author johnh;	state Exp;
branches
	1.70.1.1
	1.70.2.1;
next	1.69;

1.69
date	97.08.06.14.11.25;	author brucem;	state Exp;
branches;
next	1.68;

1.68
date	97.06.12.15.03.49;	author johnh;	state Exp;
branches;
next	1.67;

1.67
date	97.06.10.11.19.04;	author johnh;	state Exp;
branches;
next	1.66;

1.66
date	97.05.28.11.18.01;	author johnh;	state Exp;
branches;
next	1.65;

1.65
date	97.05.16.15.35.16;	author johnh;	state Exp;
branches;
next	1.64;

1.64
date	97.03.17.16.06.25;	author daveb;	state Exp;
branches
	1.64.1.1;
next	1.63;

1.63
date	97.03.13.14.28.37;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	97.02.26.13.10.34;	author johnh;	state Exp;
branches;
next	1.61;

1.61
date	96.12.03.20.21.39;	author johnh;	state Exp;
branches
	1.61.1.1
	1.61.2.1
	1.61.3.1;
next	1.60;

1.60
date	96.11.06.11.15.42;	author matthew;	state Exp;
branches
	1.60.1.1
	1.60.2.1;
next	1.59;

1.59
date	96.11.01.13.47.31;	author johnh;	state Exp;
branches;
next	1.58;

1.58
date	96.10.31.10.19.21;	author johnh;	state Exp;
branches;
next	1.57;

1.57
date	96.10.10.02.26.40;	author io;	state Exp;
branches;
next	1.56;

1.56
date	96.08.20.13.48.10;	author daveb;	state Exp;
branches
	1.56.1.1
	1.56.2.1
	1.56.3.1;
next	1.55;

1.55
date	96.08.05.14.38.16;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	96.07.29.13.04.17;	author daveb;	state Exp;
branches;
next	1.53;

1.53
date	96.07.29.11.30.01;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.07.29.11.18.14;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.07.09.12.37.05;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	96.07.02.13.55.02;	author andreww;	state Exp;
branches;
next	1.49;

1.49
date	96.05.30.13.35.00;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	96.05.29.14.37.56;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	96.05.28.14.29.46;	author matthew;	state Exp;
branches;
next	1.46;

1.46
date	96.05.24.15.41.09;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	96.05.24.13.43.13;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	96.05.22.16.29.20;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	96.05.16.14.21.07;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	96.05.15.16.00.21;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	96.05.14.14.58.51;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	96.05.14.14.36.30;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.05.08.15.14.35;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	96.05.08.12.20.49;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	96.05.07.16.20.05;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	96.05.02.17.34.52;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	96.05.01.11.21.36;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	96.04.30.10.03.26;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.04.18.15.18.25;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	96.04.09.20.28.27;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	96.04.04.11.29.02;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.04.02.16.40.56;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.04.02.16.14.12;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	96.04.02.14.59.14;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	96.04.02.12.32.52;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.03.28.13.43.10;	author stephenb;	state Exp;
branches;
next	1.25;

1.25
date	96.03.26.09.52.41;	author daveb;	state Exp;
branches;
next	1.24;

1.24
date	96.03.19.16.31.00;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.03.19.11.52.43;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	96.03.15.12.35.48;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	96.03.14.15.13.29;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.03.07.16.26.10;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	96.03.04.16.57.35;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	96.02.27.14.38.26;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	96.02.23.18.02.51;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	96.02.22.17.02.30;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.19.14.12.13;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	96.02.08.11.28.35;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	96.01.25.14.45.22;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	96.01.25.13.18.35;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.01.23.16.09.58;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	96.01.17.11.46.36;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	96.01.12.15.06.06;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	96.01.12.10.51.33;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	96.01.10.12.31.29;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	96.01.08.16.28.25;	author stephenb;	state Exp;
branches;
next	1.5;

1.5
date	95.12.13.12.10.31;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.12.12.11.50.02;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.12.07.17.03.37;	author daveb;	state Exp;
branches;
next	1.2;

1.2
date	95.12.05.13.24.08;	author daveb;	state Exp;
branches;
next	1.1;

1.1
date	95.12.05.10.54.06;	author daveb;	state Exp;
branches;
next	;

1.56.1.1
date	96.09.13.11.12.56;	author hope;	state Exp;
branches;
next	;

1.56.2.1
date	96.10.07.16.03.37;	author hope;	state Exp;
branches;
next	;

1.56.3.1
date	96.10.17.11.21.52;	author hope;	state Exp;
branches;
next	;

1.60.1.1
date	96.11.14.12.45.43;	author hope;	state Exp;
branches
	1.60.1.1.1.1;
next	;

1.60.1.1.1.1
date	96.11.28.14.57.36;	author hope;	state Exp;
branches;
next	;

1.60.2.1
date	96.11.22.18.06.14;	author hope;	state Exp;
branches;
next	;

1.61.1.1
date	96.12.17.09.54.15;	author hope;	state Exp;
branches;
next	;

1.61.2.1
date	96.12.17.17.44.55;	author hope;	state Exp;
branches
	1.61.2.1.1.1;
next	;

1.61.2.1.1.1
date	97.02.24.11.34.24;	author hope;	state Exp;
branches;
next	;

1.61.3.1
date	96.12.18.09.38.55;	author hope;	state Exp;
branches;
next	;

1.64.1.1
date	97.05.12.10.31.14;	author hope;	state Exp;
branches
	1.64.1.1.1.1
	1.64.1.1.2.1
	1.64.1.1.3.1;
next	;

1.64.1.1.1.1
date	97.07.28.18.17.07;	author daveb;	state Exp;
branches
	1.64.1.1.1.1.1.1;
next	;

1.64.1.1.1.1.1.1
date	97.10.07.11.41.58;	author jkbrook;	state Exp;
branches;
next	;

1.64.1.1.2.1
date	97.09.08.17.10.40;	author daveb;	state Exp;
branches;
next	;

1.64.1.1.3.1
date	97.09.09.14.06.14;	author daveb;	state Exp;
branches;
next	;

1.70.1.1
date	97.09.10.19.20.43;	author brucem;	state Exp;
branches;
next	;

1.70.2.1
date	97.09.11.20.51.57;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Replacement for the File Tool, showing details of loaded modules, etc.
@


1.75
log
@[Bug #30089]
Remove use of MLWorks.IO.set_file_modified in favour of basis routine
@
text
@(*
 * $Log: _comp_manager.sml,v $
 * Revision 1.74  1997/10/20  16:04:15  jont
 * [Bug #30089]
 * Remove use of OldOs.mtime in favour of OsFileSys.modTime
 *
 * Revision 1.73  1997/09/30  12:46:08  johnh
 * [Bug #30244]
 * Giving the dependency graph the full menus.
 *
 * Revision 1.72  1997/09/18  15:00:07  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.71  1997/09/18  13:48:17  brucem
 * [Bug #30203]
 * Add graphs for checking files to be compiled.
 *
 * Revision 1.70  1997/09/05  09:52:25  johnh
 * [Bug #30241]
 * Implementing proper find dialog.
 *
 * Revision 1.69  1997/08/06  14:11:25  brucem
 * [Bug #30202]
 * Add functionality to dependency graphs.
 * Graph definitions now appear inside the main create_project_tool function,
 * Graph can be manipulated by the user (expand nodes, change root, search),
 * Code has been tidied up a bit,
 * Graphics have been tidied up a bit.
 *
 * Revision 1.68  1997/06/12  15:03:49  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.67  1997/06/10  11:19:04  johnh
 * [Bug #30075]
 * Allowing only one instance of tools.
 *
 * Revision 1.66  1997/05/28  11:18:01  johnh
 * [Bug #30155]
 * Remove 'action' and 'view' cascade menu items for Win32
 *
 * Revision 1.65  1997/05/16  15:35:16  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.64  1997/03/17  16:06:25  daveb
 * [Bug #1774]
 * Fixed minor compilation error in previous fix.
 *
 * Revision 1.63  1997/03/13  14:28:37  daveb
 * [Bug #1774]
 * Added Info.Stop handler to read_depend_file.
 *
 * Revision 1.62  1997/02/26  13:10:34  johnh
 * [Bug #1813]
 * update selection reference when units are deleted.
 *
 * Revision 1.61  1996/12/03  20:21:39  johnh
 * Putting clear_console in _console to set the write_pos.
 *
 * Revision 1.60  1996/11/06  11:15:42  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.59  1996/11/01  13:47:31  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.58  1996/10/31  10:19:21  johnh
 * Enabling interruption during compilation on Windows.
 *
 * Revision 1.57  1996/10/10  02:26:40  io
 * [Bug #1614]
 * basifying String
 *
 * Revision 1.56  1996/08/20  13:48:10  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
 * Revision 1.55  1996/08/05  14:38:16  daveb
 * [Bug #1360]
 * Added a menu bar to the Graph window.
 *
 * Revision 1.54  1996/07/29  13:04:17  daveb
 * [Bug #1485]
 * Added handler for Info.Stop when raised by Incremental.match_source_path.
 * Split file_action into source_file_action and object_file_action.
 *
 * Revision 1.53  1996/07/29  11:30:01  daveb
 * [Bug #1493]
 * Added a "suffix" argument to the file_action function.
 *
 * Revision 1.52  1996/07/29  11:18:14  daveb
 * [Bug #1478]
 * Disabled Close menu item during evaluations.
 *
 * Revision 1.51  1996/07/09  12:37:05  daveb
 * [Bug #1260]
 * Changed the Capi layout datatype so that the PANED constructor takes the
 * layout info for its sub-panes.  This enables the Windows layout code to
 * calculate the minimum size of each window.
 *
 * Revision 1.50  1996/07/02  13:55:02  andreww
 * redirecting standard IO to the GUI within the compilation manager.
 *
 * Revision 1.49  1996/05/30  13:35:00  daveb
 * The Interrupt and Io exceptions are no longer at top level.
 *
 * Revision 1.48  1996/05/29  14:37:56  daveb
 * DebuggerWindow.make_debugger_window now returns a clean-up function to call
 * at the end of each evaluation.
 *
 * Revision 1.47  1996/05/28  14:29:46  matthew
 * Adding parent_title to GraphWidget.make
 *
 * Revision 1.46  1996/05/24  15:41:09  daveb
 * The extension passed to open_file_dialog does not need a preceding * .
 *
 * Revision 1.45  1996/05/24  13:43:13  daveb
 * Type of GuiUtils.view_option has changed.
 *
 * Revision 1.44  1996/05/22  16:29:20  daveb
 * Reordering menus.
 *
 * Revision 1.43  1996/05/16  14:21:07  daveb
 * Modified contents of labels to print <none> when appropriate.
 *
 * Revision 1.42  1996/05/15  16:00:21  daveb
 * Made the console be a permanent pane of the compilation manager.
 * Added an edit menu.
 *
 * Revision 1.40  1996/05/14  14:36:30  matthew
 * Fixing layout
 *
 * Revision 1.39  1996/05/08  15:14:35  daveb
 * ErrorBrowser.create now returns a quit function.  Used this to kill off
 * old error browsers.
 *
 * Revision 1.38  1996/05/08  12:20:49  daveb
 * ActionQueue.do_actions now takes an Info.options argument.
 *
 * Revision 1.37  1996/05/07  16:20:05  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.36  1996/05/02  17:34:52  daveb
 * Removed ActionQueue.Handled exception.
 *
 * Revision 1.35  1996/05/01  11:21:36  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.34  1996/04/30  10:03:26  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.33  1996/04/18  15:18:25  jont
 * initbasis moves to basis
 *
 * Revision 1.32  1996/04/09  20:28:27  daveb
 * ActionQueue.do_actions now takes a preferences argument (and a record
 * instead of a tuple).
 *
 * Revision 1.31  1996/04/04  11:29:02  matthew
 * Changes to graph interface
 *
 * Revision 1.30  1996/04/02  16:40:56  daveb
 * Implemented touch_all_modules command.
 * Made non-action commands print something on the console.
 * Moved the Graph menu item to the View menu.
 *
 * Revision 1.29  1996/04/02  16:14:12  daveb
 * Made all commands print something on the console.
 *
 * Revision 1.28  1996/04/02  14:59:14  daveb
 * Changed Project.load_dependencies to Incremental.read_dependencies.
 * Replaced "Main" and "Action" menus with "File" and "Module" menus.
 *
 * Revision 1.27  1996/04/02  12:32:52  daveb
 * Improved Layout.
 *
 * Revision 1.26  1996/03/28  13:43:10  stephenb
 * Mark any uses of Os as referring to the old Os interface.
 *
 * Revision 1.25  1996/03/26  09:52:41  daveb
 * Replaced Module.with_source_path with new Incremental.match_source_path.
 * Added delete function.
 *
 * Revision 1.24  1996/03/19  16:31:00  matthew
 * Removing duplicate structures from parameter
 *
 * Revision 1.23  1996/03/19  11:52:43  daveb
 * Implemented check_load.
 *
 * Revision 1.22  1996/03/15  12:35:48  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.21  1996/03/14  15:13:29  matthew
 * Adding compileAndLoad functionality
 *
 * Revision 1.20  1996/03/07  16:26:10  daveb
 * Changed sourceTitleLabel to sourceFileLabel.
 *
 * Revision 1.19  1996/03/04  16:57:35  daveb
 * Type of Project object info has changed.
 *
 * Revision 1.18  1996/02/27  14:38:26  daveb
 * Hid implementation of Project.Unit type.
 *
 * Revision 1.17  1996/02/23  18:02:51  jont
 * newmap becomes map, NEWMAP becomes MAP
 *
 * Revision 1.16  1996/02/22  17:02:30  daveb
 * ErrorBrowser.create now takes a close_action field.
 *
 * Revision 1.15  1996/02/19  14:12:13  daveb
 * Ensured that current selection is more or less visible.
 *
 * Revision 1.14  1996/02/08  11:28:35  daveb
 * Capi.make_scrolllist now returns a record, with an add_items field.
 *
 *  Revision 1.13  1996/01/25  14:45:22  daveb
 *  Minor change to error browser interface.
 *
 *  Revision 1.12  1996/01/25  13:18:35  matthew
 *  Changed interface to graph widget
 *
 *  Revision 1.11  1996/01/23  16:09:58  daveb
 *  Minor changes to the menus.
 *
 *  Revision 1.10  1996/01/17  11:46:36  matthew
 *  Reordering top level menus.
 *
 *  Revision 1.9  1996/01/12  15:06:06  matthew
 *  Fixing layout parameters
 *
 *  Revision 1.8  1996/01/12  10:51:33  daveb
 *  The type of Capi.open_file_dialog has changed.
 *
 *  Revision 1.7  1996/01/10  12:31:29  daveb
 *  Replaced Capi.find_file with Capi.open_file_dialog.
 *
 *  Revision 1.6  1996/01/08  16:28:25  stephenb
 *  Correcting bug in edit action.
 *
 *  Revision 1.5  1995/12/13  12:10:31  daveb
 *  Replaced FileDialog.find_file with Capi.find_file; the type has changed too.
 *
 *  Revision 1.4  1995/12/12  11:50:02  daveb
 *  Module.with_source_path now takes a string describing the action undertaken.
 *
 *  Revision 1.3  1995/12/07  17:03:37  daveb
 *  Added header.
 *
 *  
 * Copyright (c) 1995 Harlequin Ltd.
 *)

require "$.basis.__int";
require "$.basis.__string";
require "$.basis.os";

require "../basics/module_id";
require "../basics/module";
require "../basics/location";
require "../utils/map";
require "../utils/crash";
require "../basis/list";
require "../editor/editor";
require "../main/preferences";
require "../main/user_options";
require "../main/toplevel";
require "../main/project";
require "../debugger/ml_debugger";
require "../interpreter/incremental";
require "../interpreter/shell_utils";
require "../interpreter/action_queue";
require "capi";
require "menus";
require "graph_widget";
require "tooldata";
require "gui_utils";
require "console";
require "debugger_window";
require "error_browser";

require "comp_manager";

functor CompilationManager (
  structure ModuleId: MODULE_ID
  structure Module: MODULE
  structure DebuggerWindow : DEBUGGERWINDOW
  structure Ml_Debugger : ML_DEBUGGER
  structure ErrorBrowser : ERROR_BROWSER
  structure NewMap: MAP
  structure List: LIST
  structure UserOptions: USER_OPTIONS
  structure Preferences: PREFERENCES
  structure Crash: CRASH
  structure Editor: EDITOR
  structure Capi: CAPI
  structure Incremental: INCREMENTAL
  structure OS: OS
  structure TopLevel: TOPLEVEL
  structure Project: PROJECT
  structure ShellUtils: SHELL_UTILS
  structure ActionQueue: ACTION_QUEUE
  structure Menus: MENUS
  structure GraphWidget: GRAPH_WIDGET
  structure ToolData: TOOL_DATA
  structure GuiUtils: GUI_UTILS
  structure Console: CONSOLE

  sharing Project.Info = TopLevel.Info = ShellUtils.Info = ActionQueue.Info =
	  Incremental.InterMake.Compiler.Info
  sharing TopLevel.Options = Ml_Debugger.ValuePrinter.Options =
	  ShellUtils.Options = ToolData.ShellTypes.Options

  sharing type Capi.Widget = Menus.Widget =
	       GraphWidget.Widget = ToolData.Widget = GuiUtils.Widget =
	       Console.Widget = DebuggerWindow.Widget =
	       ErrorBrowser.Widget
  sharing type Ml_Debugger.preferences = Preferences.preferences =
	       ShellUtils.preferences = Editor.preferences =
	       ActionQueue.preferences
  sharing type Preferences.user_preferences = GuiUtils.user_preferences =
               ToolData.ShellTypes.user_preferences = Console.user_preferences
  sharing type ToolData.ShellTypes.Context = ShellUtils.Context
  sharing type UserOptions.user_context_options =
               ToolData.UserContext.user_context_options =
               GuiUtils.user_context_options
  sharing type UserOptions.user_tool_options = ShellUtils.UserOptions =
	       ToolData.ShellTypes.user_options =
	       GuiUtils.user_tool_options = ActionQueue.UserOptions
  sharing type ToolData.ButtonSpec = Menus.ButtonSpec = GuiUtils.ButtonSpec
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context =
	       ActionQueue.user_context = ErrorBrowser.user_context
  sharing type Project.Info.Location.T = ModuleId.Location = Module.Location =
	       ErrorBrowser.location = Incremental.Datatypes.Ident.Location.T
  sharing type Project.ModuleId = ModuleId.ModuleId = Module.ModuleId =
	       TopLevel.ModuleId = Incremental.ModuleId = ShellUtils.ModuleId
  sharing type NewMap.map = Project.Map
  sharing type GraphWidget.GraphicsPort = Capi.GraphicsPorts.GraphicsPort
  sharing type GraphWidget.Point = Capi.Point
  sharing type ToolData.ToolData = DebuggerWindow.ToolData = ErrorBrowser.ToolData
  sharing type Project.Options = TopLevel.Options.options
  sharing type Project.Project = TopLevel.Project =
	       Incremental.InterMake.Project
  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
  sharing type ErrorBrowser.error = Project.Info.error
  sharing type Menus.OptionSpec = GuiUtils.OptionSpec
): COMPILATION_MANAGER =
struct

  structure Info = Project.Info 
  structure Location = Info.Location
  structure ShellTypes = ToolData.ShellTypes
  structure Options = TopLevel.Options
  structure UserContext = ToolData.UserContext

  type ToolData = ToolData.ToolData

  datatype Node =
    NODE of
      ModuleId.ModuleId * (string * int * int * int) option ref
    (* the module name, 
       optionally the name as a string, font ascent, font descent, width *)

  val nodeName = fn (NODE (m,_)) => ModuleId.string m
  
  (* Should be a util *)
  fun location_file (Info.ERROR(_,location,message)) =
    case location of
      Location.UNKNOWN => NONE
    | Location.FILE f => SOME f
    | Location.LINE(f,l) => SOME f
    | Location.POSITION (f,l,_) => SOME f
    | Location.EXTENT {name,...} => SOME name

  (* There should only be one project tool at a time *)
  val project_tool = ref NONE

  (* The selection should persist if you close the tool and open a new
     instance later. So we declare selection out here. *)
  val selection = ref NONE : (string * ModuleId.ModuleId) option ref

  (* This is the most important function.
     All other functions are contained inside this. *)
  fun create_project_tool (tooldata as ToolData.TOOLDATA
		{args, appdata, current_context, motif_context, tools}) =
    let

      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val ShellTypes.LISTENER_ARGS
            {user_options, user_preferences,
             mk_xinterface_fn, prompter, ...} = args

      val local_context = ref motif_context

      fun get_current_user_context () =
        GuiUtils.get_user_context (!local_context)

      fun get_user_context_options () =
        ToolData.UserContext.get_user_options (get_current_user_context ())

      val title = "Project Browser"

      val (shell, frame, menubar, _) =
        Capi.make_main_window
	  ("compManager", title, applicationShell, false, false);
  
      val paned =
        Capi.make_managed_widget ("paned", Capi.Paned, frame, [])

      val listPane =
        Capi.make_managed_widget ("listPane", Capi.Form, paned, []);

      val textPane =
        Capi.make_managed_widget ("textPane", Capi.Form, paned, []);

      val modNameLabel = 
        Capi.make_managed_widget ("modNameLabel", Capi.Label, listPane, [])
      val sourceFileLabel = 
        Capi.make_managed_widget ("sourceFileLabel", Capi.Label, listPane, [])
      val objectFileLabel =
        Capi.make_managed_widget ("objectFileLabel", Capi.Label, listPane, [])
      val listLabel = 
        Capi.make_managed_widget ("listLabel", Capi.Label, listPane, [])
  
      fun get_user_options () = user_options

      fun mk_tooldata () = tooldata

      val consoleLabel = 
        Capi.make_managed_widget ("console", Capi.Label, textPane, [])

      val {instream, outstream, console_widget, console_text, clear_input,
           clear_console, set_window} =
        Console.create (textPane, title, user_preferences)

      fun message_fun s = Capi.send_message(shell,s)

      val (run_debugger, clean_debugger) =
        DebuggerWindow.make_debugger_window
          (shell, title ^ " Debugger", tooldata)

      val debugger_type =
        Ml_Debugger.WINDOWING (run_debugger, message_fun, false)

      fun debugger_function f x =
        Ml_Debugger.with_start_frame
          (fn base_frame =>
             (f x)
             handle
               exn as Capi.SubLoopTerminated => raise exn
             | exn as ToolData.ShellTypes.DebuggerTrapped => raise exn
             | exn as MLWorks.Interrupt => raise exn
             | exn as Info.Stop _ => raise exn
             | exn =>
                (Ml_Debugger.ml_debugger
                   (debugger_type,
                    ShellTypes.new_options
                      (user_options,
                       GuiUtils.get_user_context (!local_context)),
                    Preferences.new_preferences user_preferences)
                   (base_frame,
                    Ml_Debugger.EXCEPTION exn,
                    Ml_Debugger.POSSIBLE
                      ("quit (return to file tool)",
                       Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
                    Ml_Debugger.NOT_POSSIBLE);
                 raise ShellTypes.DebuggerTrapped))

      local
	val error_browser_ref = ref NONE
      in
	fun kill_error_browser () =
	  case !error_browser_ref
	  of NONE => ()
	  |  SOME f =>
	    (f ();
	     error_browser_ref := NONE)

        fun error_handler
              (filename, error, error_list, header,
	       preferences_fn, redo_action) =
          let
              val action_message =
                header ^ ": " ^ filename
  
              val file_message =
                case location_file error of
                  NONE => ""
                | SOME s => s

              fun edit_action location =
                {quit_fn =
		   ShellUtils.edit_location (location, preferences_fn()),
                 clean_fn = fn () => ()}
          in
            MLWorks.IO.output
	      (MLWorks.IO.std_out,header ^ ": Error in " ^
               file_message ^ "\n");
	    error_browser_ref :=
	      SOME
                (ErrorBrowser.create
                   {parent = shell, errors = rev error_list,
                    file_message = file_message,
                    editable = fn _ => true,
	            edit_action = edit_action,
	            close_action = fn _ => (),
	            redo_action = redo_action,
		    mk_tooldata = fn () => tooldata,
		    get_context = get_current_user_context})
          end
      end

      (* update_labels changes the top of the manager window
         and the selection reference, but not the `entries' list *)
      fun update_labels NONE =
        (Capi.set_label_string (modNameLabel, "Selected Unit: <none>");
         Capi.set_label_string (sourceFileLabel, "Source: <none>");
         Capi.set_label_string (objectFileLabel, "Object: <none>"))
      |   update_labels (SOME (s, m)) =
        let
  	  val project = Incremental.get_project ()

	  val source_file =
  	    case Project.get_source_info (project, m) of
  	      NONE => "<none>"
  	    | SOME (file, _, _) => file

	  val object_file =
  	    case Project.get_object_info (project, m) of
  	      NONE => "<none>"
  	    | SOME {file, ...} => file

	  val loaded = 
	    case Project.get_loaded_info (project, m) of
	      NONE => false
	    | SOME _ => true

	  val visible = Project.is_visible (project, m)

	  val status_string =
	    case (loaded, visible)
	    of (false, false) => ""
	    |  (true, false) => " (loaded)"
	    |  (false, true) => " (visible)"
	    |  (true, true) => " (loaded, visible)"
        in
          selection := SOME (s, m);
          Capi.set_label_string
	    (modNameLabel, "Selected Unit: " ^ s ^ status_string);
          Capi.set_label_string
	    (sourceFileLabel, "Source: " ^ source_file);
          Capi.set_label_string
	    (objectFileLabel, "Object: " ^ object_file)
        end


      (* When you create a graph, supply a value
           layout : {style : layout_style, expanded : bool} *)
      datatype layout_style = CASCADE | TREE

      (* Graph windows will update the main window when an item is
         selected in them.  The following reference will be filled
         by a function for doing this (we can't define the function yet
         as we haven't defined the main list -- it requires the graph
         function) *)
      val selectFnForGraphRef = ref (fn _ => ())
      (* It would be nice if the user could turn this off (by the menu) *)

      exception EmptyGraph 

      (* Function to open a window displaying the graph for a given module *)
      (* Several graph windows can be open at any time
         fun project_graph_tool may throw EmptyGraph *)
      fun project_graph_tool
        {parent, project, module = module_id, title, filter, winNamePrefix, layout} =
        let
          val moduleName = ModuleId.string module_id

          val windowName = winNamePrefix ^ moduleName

          val (shell, frame, menuBar, _) =
            Capi.make_main_window
	      ("compManagerGraph", windowName, parent, false, true);

          (* Node at the top when the graph was created *)
          val originalRoot = module_id
          (* Node currently at the top *)
          val currentRoot = ref module_id
          (* Node currently highlighted (or the root node if none) *)
          val graphSelection = ref module_id

          val userExpandedNode = ref false

          (* Function to generate the graph data,
             this has type :
                {ordering, get_children, mk_node, filter}
                 -> unit -> (NODES, ROOTS)
             as GraphWidget.make requires a function (make_graph)
             of type : unit -> (NODES, ROOTS)
           *)
          (* To implement different types of graph, e.g. graphs showing
             only files that need to be recompiled, add extra params to
             this function and stick with the same basic algorithm.
           *)
          fun map_to_graph_fn {ordering, get_children, mk_node, filter} =
            let
              val nodesList = ref []
              val iref = ref 0
              val seen = ref (NewMap.empty' ordering)

              fun do_node key =
                if filter key then
                  case NewMap.tryApply' (!seen, key)
                  of SOME index => SOME index
                  |  NONE =>
                   let
	              (* Warning: this could raise an exception *)
                      val children = get_children key
                      val index = !iref
                      val children_ref = ref []
                      val _ = seen := NewMap.define (!seen, key, index)
                      val _ = nodesList :=
                                (NODE (mk_node key, ref NONE), children_ref) ::
                                      !nodesList
                      val _ = iref := 1 + !iref
                      val children_ids = List.mapPartial do_node children
                    in
                      children_ref := children_ids;
                      SOME index
                    end (* of fun do_node *)
                  else
                    NONE

              val nodesArr = ref (MLWorks.Internal.Array.arrayoflist [])
                  
             fun recompute () = 
                  (nodesList := [] ;
                   iref := 0 ;
                   seen := (NewMap.empty' ordering) ;
                   do_node (!currentRoot);
                   (* The exception should never be raised.
                      As it means the filter has removed all nodes. *)
                   case !nodesList of [] => raise EmptyGraph | _ => ();
                   nodesArr := MLWorks.Internal.Array.arrayoflist
                               (rev (map 
                                    (fn (node,ref children) => (node,children))
                                    (!nodesList)))
                  )

              val _ = recompute ()

              val lastRoot = ref (!currentRoot)

           in
             fn () => ((if !currentRoot <> !lastRoot
                        then (recompute () ; lastRoot := !currentRoot )
                        else () );
                       (!nodesArr, [0]) )
           end

           val layoutRef = ref layout
  
           val graph_spec =
             GraphWidget.GRAPH_SPEC
               {child_position = ref GraphWidget.CENTRE, 
               child_expansion = ref GraphWidget.TOGGLE,
               default_visibility = ref false, 
               show_root_children = ref true,
               indicateHiddenChildren = ref true,
               orientation = ref GraphWidget.VERTICAL,
               line_style = ref GraphWidget.STRAIGHT,
               horizontal_delta = ref 8,
               vertical_delta = ref 60,
               graph_origin = ref (8, 8),
               show_all = ref false
              }

          (* Following few values/functions are for drawing single nodes *)
          (* Ideally these should be in a separate structure and shared with
             other graph drawing code (e.g. inspector). *)
          (* Be VERY carefull if changing sizes, offsets, values etc.,
             it is difficult to get the calculations correct so it works
             on all platforms.  *)
          val baseline_height = 3
          fun max (x: int,y) = if x > y then x else y

          val boxMargin = 4

          (* This returns the data for drawing a node,
             excludes the boxMargin from the extents *)
          fun get_node_data (NODE (entry, extents),gp) =
            case !extents of
              SOME data => data
            | _ =>
                let
                  val s = ModuleId.string entry
                  val {font_ascent,font_descent,width,...} =
                    Capi.GraphicsPorts.text_extent (gp,s)
                  val data = (s,font_ascent,font_descent,width)
                in
                  extents := SOME data;
                  data
               end (* of fun get_node_data *)
  
          fun entry_draw_node (node, selected, gp, Capi.POINT{x,y}) =
            let
              val (s, font_ascent, font_descent, width) =
                get_node_data (node, gp)
              val left = width div 2
              val right = width - left
              val rectangle = Capi.REGION {x = x-left-boxMargin,
                                           y = y-baseline_height-font_ascent-
                                               boxMargin,
                                           width = width + 2 * boxMargin,
                                           height = font_ascent+font_descent+
                                                     2*boxMargin }
              fun canHighlight gp f x =
                if selected then Capi.GraphicsPorts.with_highlighting (gp,f,x)
                else f x
            in 
              if selected
              then Capi.GraphicsPorts.fill_rectangle (gp, rectangle)
              else (Capi.GraphicsPorts.clear_rectangle (gp, rectangle);
                    Capi.GraphicsPorts.draw_rectangle (gp, rectangle) );
              canHighlight
                gp
                 Capi.GraphicsPorts.draw_image_string
                 (gp,s,Capi.POINT{x=x - left, y=y - baseline_height} )
            end (* of fun entry_draw_node *)
          
          fun entry_extent (node,gp) =
            let
              val (s,font_ascent,font_descent,width) = get_node_data (node,gp)
              val left = width div 2
              val right = width - left
            in
              GraphWidget.EXTENT
                {left = left + boxMargin,
                 right = right + 2 + boxMargin,
                 up = baseline_height + font_ascent + 1 + boxMargin,
                 down = max (0, font_descent-baseline_height) + boxMargin}
            end (* of fun entry_extent *)
  
          (* Function to make the graph area within a window. *)
          fun make_project_graph
            {project, module = module_id, parent, title, filter} =
            let
              fun get_requires m = Project.get_requires (project, m)
              fun mk_node m = Project.get_name (project, m)
            in

              GraphWidget.make
                ("projectGraph", "ProjectGraph", "Dependency graph",
                 parent, graph_spec,
                 map_to_graph_fn
                   {ordering = ModuleId.lt, get_children = get_requires,
                    mk_node = mk_node, filter = filter}, 
                 entry_draw_node, entry_extent) 

           end (* of fun make_project_graph *)

          val {initialize, widget, popup_menu, update, initialiseSearch, ...} =
            make_project_graph
             {project = project, module = module_id, parent = frame,
              title = title, filter = filter}

          (* Function to check for substrings, used in the graph search *)
          fun isSubstring (s1, s2) =
            let
              val l1 = explode s1   val l2 = explode s2
              fun isSub l =
                   let
                     fun isPre ([], _) = true
                       | isPre (l, []) = false
                       | isPre ((h1::t1), (h2::t2)) =
                           (h1=h2) andalso (isPre (t1, t2))
                   in
                     (isPre (l1, l)) orelse
                     (case l of (h::t) => isSub t | _ => false)
                   end
            in
              isSub l2
            end

          (* Function to say if a module name contains a substring.  
             For searching the graph *)
          fun matchWeak key (NODE(m,_)) =
              isSubstring (key, (ModuleId.string m))

          (* Function to say if a module name is a string.
             For searching the graph.  *)
          fun matchStrong key (NODE(m,_)) = (ModuleId.string m)=key

          (* Next functions are the menu options *)

          (* Expand the graph completely or contract it.  Boolean parameter
             is new value for #show_all in graph spec *)
          fun setExpanded b = 
            (#show_all ((fn GraphWidget.GRAPH_SPEC gs => gs) graph_spec) := b ;
             userExpandedNode := false ;
             layoutRef := {style = #style (!layoutRef), expanded = b};
             update() )

          fun isExpanded () = #expanded (!layoutRef)

          (* Move a given node to the top of the screen and show only
             its descendants.  *)
          fun focus module () = 
           (currentRoot := module ;
            graphSelection := module;
            (!selectFnForGraphRef) module ;
            update () )

          (* Focus on the current selection *)
          val focusOnSelection = fn () => (focus (!graphSelection) ())

          (* Can we change focus to the current selection? *)
          fun canFocusOnSelection () = (!graphSelection <> !currentRoot)

          (* Can we return focus to original root? *)
          fun canUnfocus () = (!currentRoot <> originalRoot)

          (* Changing the style
             Only two styles are provided, rather than letting the
             user set graph_spec directly using the window from popup_menu *)

          (* Layout file-manager style *)
          fun setCascadeLayout () =
            let val (GraphWidget.GRAPH_SPEC gs) = graph_spec in
            ((#child_position gs) := GraphWidget.BELOW;
             (#orientation gs) := GraphWidget.HORIZONTAL;
             (#line_style gs) := GraphWidget.STEP;
             (#horizontal_delta gs) := 20; (#vertical_delta gs) := 8;
             layoutRef := {expanded = #expanded (!layoutRef), style = CASCADE};
             update () )
            end

          (* Layout in a tree *)
          fun setTreeLayout () =
            let val (GraphWidget.GRAPH_SPEC gs) = graph_spec in
            ((#child_position gs) := GraphWidget.CENTRE;
             (#orientation gs) := GraphWidget.VERTICAL;
             (#line_style gs) := GraphWidget.STRAIGHT;
             (#horizontal_delta gs) := 8; (#vertical_delta gs) := 60;
             layoutRef := {expanded = #expanded (!layoutRef), style = TREE};
             update () )
            end

          fun setLayoutStyle style =
            case style of TREE => setTreeLayout ()
                        | CASCADE => setCascadeLayout ()

          fun getLayoutStyle () =
            #style (!layoutRef)

          val close_push = 
		("close", fn _ => Capi.destroy shell, fn _ => true)

	  val searchFn = 
	    initialiseSearch (fn _ => ModuleId.string (!graphSelection))
			     (matchStrong, matchWeak)

	  datatype expandType = ALL | ROOT
	  val expand = ref ROOT

	  val layoutStyle = ref TREE

	  val graphSettingsSpec = 
	    [Menus.OPTRADIO
		[GuiUtils.toggle_value ("expand_all", expand, ALL),
		 GuiUtils.toggle_value ("only_root", expand, ROOT)],
	     Menus.OPTSEPARATOR,
	     Menus.OPTLABEL "Layout Style",
	     Menus.OPTRADIO
		[GuiUtils.toggle_value ("cascading_layout", layoutStyle, CASCADE),
		 GuiUtils.toggle_value ("tree_layout", layoutStyle, TREE)]]

	  fun update_graph () = 
	    (if isExpanded() = ((!expand) = ROOT) then
		setExpanded ((!expand) = ALL)
	     else ();
	     if getLayoutStyle() <> (!layoutStyle) then 
		setLayoutStyle (!layoutStyle)
	     else ())

          val dep_graph_settings =
            #1 (Menus.create_dialog
	           (shell, "Graph Layout: " ^ moduleName, "depGraphLayout",
                    update_graph, graphSettingsSpec)
               )

	  val menuSpec = 
	    [ToolData.file_menu [close_push],
	     ToolData.edit_menu (frame,
              {cut = NONE,
               paste = NONE,
               copy = NONE,
               delete = NONE,
	       edit_possible = fn _ => false,
               selection_made = fn _ => false,
	       delete_all = NONE,
	       edit_source = []}),
	     ToolData.tools_menu (mk_tooldata, get_current_user_context),
	     ToolData.usage_menu ([("search", searchFn, fn _ => true),
				   ("graph", dep_graph_settings, fn _ => true),
				   ("make_root", 
					focusOnSelection, 
					canFocusOnSelection),
				   ("original_root",
                                        focus originalRoot,
                                        canUnfocus)]
				  ,[]),
	     ToolData.debug_menu [],
	     GuiUtils.paths_menu frame]

          val selectFn =  
            fn (a as (NODE(m,_),_)) => 
              ( graphSelection := m ;
                userExpandedNode := true;
                (!selectFnForGraphRef) m )

        in
          setLayoutStyle (#style layout); 
	  setExpanded (#expanded layout);
          Menus.make_submenus (menuBar, menuSpec);
          Capi.Layout.lay_out (frame,
                               [Capi.Layout.MENUBAR menuBar,
                                Capi.Layout.SPACE,
                                Capi.Layout.FLEX widget,
                                Capi.Layout.SPACE]);
          Capi.initialize_toplevel shell;
          initialize selectFn
        end (* of fun project_graph_tool *)
  

      fun show_graph m =
        project_graph_tool
	  {parent = applicationShell,
           project =  Incremental.get_project (),
           module = m,
           title = title,
           winNamePrefix = "Dependency graph for ",
           layout = {style = TREE, expanded = false},
           filter = fn _ => true }

      fun selectFnForList _ (s, m) = update_labels (SOME (s, m))

      fun action_fn _ (_, m) = show_graph m

      fun print_item _ (s, _) = s;
  
      val {scroll, list, set_items, add_items} =
        Capi.make_scrolllist
          {parent = listPane, name = "list", select_fn = selectFnForList,
           action_fn = action_fn, print_fn = print_item}

      fun redisplay selection_opt =
	let

	  val items =
	    List.filter
	      (fn (s, _) => String.sub (s, 0) <> #" ")
	      (Project.list_units (Incremental.get_project ()))

	  val offset = 2

	  fun index (m, n, []) = NONE
	  |   index (m, n, (s, m') :: rest) =
	    if m = m' then
	      SOME n
	    else
	      index (m, n+1, rest)
	in
          set_items () items;
	  case selection_opt of
	    NONE =>
	      update_labels NONE
	  | SOME (_, m) =>
	      case index (m, 1, items) of
		SOME n =>
		  (Capi.List.select_pos (list, n, true);
		   (* We want to ensure that the selected item is visible.
		      Unfortunately Motif provides no way of finding the
		      current top position, so we redraw the list even if
		      the selected item is already visible.  We also can't
		      find the number of rows in the list (this is odd...),
		      so we assume that there are at least three.  *)
		   if n < offset+1 orelse List.length items < offset then
		     Capi.List.set_pos (list, 1)
		   else
		     Capi.List.set_pos (list, n - offset))
	      | NONE => ()
	    
	end (* of fun redisplay *)
  
      (* Now that we have defined redisplay, we can set the selection
         function for the graph(s) *)
      (* The only parameter for the function is ModuleId.module_id *)
      val setSelectFn =
        selectFnForGraphRef := (fn m => redisplay (SOME(ModuleId.string m, m)))

      val key =	Incremental.add_update_fn (fn () => redisplay (!selection))

      (* Functions to execute when closing the project tool *)
      val quit_funs = ref [fn () => Incremental.remove_update_fn key,
			   fn () => project_tool := NONE]

      fun do_quit_funs () =
	List.app (fn f => f ()) (!quit_funs)

      (* The evaluating flag disables GUI controls during an evaluation. *)
      val evaluating = ref false;
      fun with_evaluating f x =
	let
	  val prev_capi_eval = !Capi.evaluating;
	  val _ = Capi.evaluating := true;
	  val _ = evaluating := true;
	  val result =
	    f x
	    handle exn => (evaluating := false; 
			   Capi.evaluating := prev_capi_eval;
			   raise exn)
	in
	  evaluating := false;
	  Capi.evaluating := prev_capi_eval;
	  result
	end

      (* Functions for the menu *)

      fun reload module_id =
	Incremental.read_dependencies
	  title 
	  (Info.make_default_options ())
	  module_id
  
      fun graph _ =
	case !selection
	of NONE => ()
	|  SOME (_, m) => show_graph m

      fun touch_all _ =
	(MLWorks.IO.output (outstream, "Touch all loaded modules\n");
	 Incremental.delete_all_modules true;
	 redisplay (!selection))

      fun delete _ =
	case !selection
	of NONE => ()
	|  SOME (s, m) =>
	  (MLWorks.IO.output (outstream,
                              "Delete unit " ^ s ^ " from project\n");
	   Incremental.delete_from_project m;
	   selection := NONE;
	   redisplay NONE)

      fun clear_all _ =
	(MLWorks.IO.output (outstream, "Delete all units\n");
	 Incremental.reset_project ();
	 selection := NONE;
	 redisplay NONE)

      fun mk_action f x =
          (clear_input ();
	   kill_error_browser ();
           set_window();
	   with_evaluating
	     Capi.with_window_updates 
	     (fn () => 
	     MLWorks.IO.with_standard_input
               instream
               (fn () =>
                MLWorks.IO.with_standard_output
                  outstream
                  (fn () =>
                   MLWorks.IO.with_standard_error
                   outstream
                   (fn () =>
		      ShellTypes.with_toplevel_name
		        title
		        (fn () =>
                           (Ml_Debugger.with_debugger_type
                              debugger_type
			      (fn _ => f x)))))))
             handle
               MLWorks.Interrupt => ();
	     clean_debugger ())

      (* checkGraph creates a menu callback which creates graphs
         displaying details about a selection of files.
         Parameters are
           commandMessage : string    e.g. `check modules to reload'
           function                   e.g. a Project function
                                           or a function with the
                                           same type as Project.check_load
           noUnitsMessage : string    e.g. `No units to reload'
           winNamePrefix : string     e.g. `files to reload for '
       *)
      fun checkGraph
        {commandMessage, function, noUnitsMessage, winNamePrefix} =
        let
          fun f (modName, module) =
             (Capi.set_busy shell;
              let
                val project = Incremental.get_project ()
                val errorInfo = Info.make_default_options ()
                val toplevelName = ShellTypes.get_current_toplevel_name ()
                val location = Location.FILE toplevelName
                val (newProject, _) = Project.read_dependencies
                                        (errorInfo, location)
                                        (project, module, Project.empty_map)
              in
                Incremental.set_project newProject;
                case function (errorInfo, location) (newProject, module) of
                  [] =>  Capi.send_message (shell, noUnitsMessage)
                | modList =>  project_graph_tool
                           {parent = applicationShell,
                            project = Incremental.get_project (),
                            module = module,
                            title = title,
                            winNamePrefix = winNamePrefix,
                            layout = {style = CASCADE, expanded = true},
                            filter =
                              (fn m => List.exists (fn m' => m'=m) modList)}
              end;
              redisplay (SOME(modName, module));
              Capi.unset_busy shell )
             handle
               Info.Stop (error, error_list) =>
                 (error_handler
                    (modName, error, error_list, commandMessage,
                     fn () => Preferences.new_preferences user_preferences,
                     fn () => mk_action f (modName, module));
                  redisplay (SOME(modName, module));
                  Capi.unset_busy shell)
             | MLWorks.Interrupt =>
                 (redisplay (SOME(modName, module));
                  Capi.unset_busy shell)
        in
          mk_action f
        end

      val checkLoadSourceGraph =
        checkGraph
          {commandMessage = "Check load from source",
           function = Project.check_load_source,
           noUnitsMessage = "No units need loading from source.\n",
           winNamePrefix =  "Source to load for " }

      val checkCompileGraph =
        checkGraph
          {commandMessage = "Check compile",
           function = Project.check_compiled,
           noUnitsMessage = "No units require compilation.\n",
           winNamePrefix = "Units to compile for " }

      val checkLoadGraph =
        checkGraph
          {commandMessage = "Check load",
           function = Project.check_load_objects,
           noUnitsMessage = "No units need loading.\n",
           winNamePrefix = "Units to load for " }

      val edit_file =
        mk_action
          (fn (s, m) =>
	   case Project.get_source_info (Incremental.get_project (), m) of
	     NONE => Capi.send_message (shell, "No source file for " ^ s)
	   | SOME (file, _, _) =>
	       (case Editor.edit
		       (Preferences.new_preferences user_preferences)
		       (file,0) of
		  (NONE,_) => ()
		| (SOME s,_) => message_fun s))

      val read_depend =
	let
	  fun f (s, m) =
	    Capi.with_message (shell, "Reading dependencies from " ^ s)
	      (fn () =>
	         (reload m; redisplay (SOME (s, m))))
            handle
              Info.Stop (error,error_list) =>
                error_handler
                (s, error, error_list, "Reading Dependencies",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
	in
	  mk_action f
	end

      val do_load_source =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message (shell, "Load From Source " ^ s)
                (fn () =>
                   (ActionQueue.add_load_source_module (s,error_info);
		    with_evaluating 
                      ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn = 
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn =
			 fn s => MLWorks.IO.output
                           (MLWorks.IO.std_out,"Compiling " ^ s)}));
              message_fun ("Load From Source of " ^ s ^ " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Load From Source",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

      val touch_loaded =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              ActionQueue.add_touch_loaded_module (s,error_info);
              ActionQueue.do_actions
                {user_context = GuiUtils.get_user_context (!local_context),
                 user_options = user_options,
		 error_info = error_info,
		 debugger = debugger_function,
		 preferences = 
                   Preferences.new_preferences user_preferences,
                 output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                 monitor_fn =
		   fn s => MLWorks.IO.output(MLWorks.IO.std_out,
                                             "Touching loaded unit" ^ s)};
              message_fun ("Touched loaded unit " ^ s)
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Touch Loaded Unit",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

      val compile_and_load =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message
		(shell, "Compile and Load: " ^ s)
                (fn () =>
                   (ActionQueue.add_compile_and_load_module (s,error_info);
                    ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn =
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn =
                         fn s => MLWorks.IO.output
                           (MLWorks.IO.std_out, "Checking " ^ s)}));
              message_fun
		("Compile and Load of " ^ s ^ " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Compile and Load",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

      val do_load =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message (shell, "Load Objects: " ^ s)
                (fn () =>
                   (ActionQueue.add_load_module (s,error_info);
		    with_evaluating
                      ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn =
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn = 
                         fn s => MLWorks.IO.output
                           (MLWorks.IO.std_out, "Loading " ^ s)}));
              message_fun ("Load Objects of " ^ s ^ " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Load Objects",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

      val do_compile =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message (shell, "Compiling " ^ s)
                (fn () =>
                   (ActionQueue.add_compile_module (s,error_info);
		    with_evaluating
                      ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn =
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
		       monitor_fn =
                         fn s => MLWorks.IO.output
                                   (MLWorks.IO.std_out, "Compiling " ^ s)}));
              message_fun ("Compilation of " ^ s ^ " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Compile",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

      val touch_source =
	let
	  fun f (s, m) =
	    (case Project.get_source_info (Incremental.get_project (), m) of
	       SOME (file, module, _) =>
		 ((OS.FileSys.setTime (file, NONE);
                   Capi.send_message (shell, "Touched " ^ file);
		   Project.set_source_info
		   (Incremental.get_project (), m,
		    SOME (file, module, OS.FileSys.modTime file)))
                   handle MLWorks.IO.Io _ =>
                     Capi.send_message (shell, "Can't touch " ^ file))
	     | NONE => ())
	in
	  mk_action f
	end

      val history = ref []

      datatype action =
        EDIT | LOAD_SOURCE | CHECK_LOAD_SOURCE | TOUCH_LOADED | COMPILE |
        CHECK_COMPILE | TOUCH_SOURCE | LOAD |
	CHECK_LOAD | COMPILE_AND_LOAD | READ_DEPEND

      fun get_action EDIT = edit_file
        | get_action LOAD_SOURCE = do_load_source
        | get_action CHECK_LOAD_SOURCE = checkLoadSourceGraph
        | get_action TOUCH_LOADED = touch_loaded
        | get_action LOAD = do_load
        | get_action COMPILE = do_compile
        | get_action TOUCH_SOURCE = touch_source
        | get_action CHECK_COMPILE = checkCompileGraph
	| get_action CHECK_LOAD = checkLoadGraph
	| get_action COMPILE_AND_LOAD = compile_and_load
	| get_action READ_DEPEND = read_depend

      fun get_max_history () =
        let
          val Preferences.USER_PREFERENCES ({history_length,...},_) =
            user_preferences
        in
          !history_length
        end

      fun ministry_of_truth ([], _, _) = []
        | ministry_of_truth (s::l, new_factoid, finish) =
          if finish > 0 then
            if s = new_factoid then
              l
            else
              s :: ministry_of_truth (l, new_factoid, finish - 1)
          else []

      fun add_action a =
        history := a :: (ministry_of_truth (!history,a,get_max_history()))

      fun string_action action =
        case action of
          EDIT => "Edit source of"
	| READ_DEPEND => "Read dependencies from"
        | LOAD_SOURCE => "Load source from"
        | CHECK_LOAD_SOURCE => "Check load source of"
        | LOAD => "Load"
	| CHECK_LOAD => "Check load of"
        | COMPILE => "Compile"
        | CHECK_COMPILE => "Check compile of"
	| COMPILE_AND_LOAD => "Compile and load"
        | TOUCH_SOURCE => "Touch source of"
        | TOUCH_LOADED => "Touch loaded module"

      fun do_action (action, selection as (s, _)) =
	(MLWorks.IO.output (outstream, string_action action ^ " " ^ s ^ "\n");
	 add_action (action, selection);
         (get_action action) selection)

      fun make_callback action _ =
	case !selection
	of NONE => ()
	|  SOME x => do_action (action, x)

      fun read_depend_file _ =
        case Capi.open_file_dialog (shell, ".sml")
        of NONE => ()
        |  SOME s => 
         (set_window();
          MLWorks.IO.with_standard_output
            outstream
            (fn () =>
               MLWorks.IO.with_standard_error
                 outstream
		 (fn () =>
  	            Incremental.match_source_path
	              (fn _ => fn m =>
		         do_action (READ_DEPEND, (ModuleId.string m, m)),
		       Info.make_default_options (),
	               Location.FILE title, s, "reading dependencies from")
	            handle
                      Info.Stop (error,error_list) =>
                        error_handler
                        (s, error, error_list, "Checking Unit Names",
                         fn () => Preferences.new_preferences user_preferences,
                         fn () => read_depend_file ()))))
  
      fun source_file_action action _ =
        case Capi.open_file_dialog (shell, ".sml")
        of NONE => ()
        |  SOME s => 
         (set_window();
          MLWorks.IO.with_standard_output
            outstream
            (fn () =>
               MLWorks.IO.with_standard_error
                 outstream
		 (fn () =>
  	            Incremental.match_source_path
	              (fn _ => fn m =>
		         (do_action (READ_DEPEND, (ModuleId.string m, m));
		          do_action (action, (ModuleId.string m, m))),
		       Info.make_default_options (),
	               Location.FILE title, s, string_action action)
	            handle
                      Info.Stop (error,error_list) =>
                        error_handler
                        (s, error, error_list, "Checking Unit Names",
                         fn () => Preferences.new_preferences user_preferences,
                         fn () => source_file_action action ()))))

      fun object_file_action action _ =
        case Capi.open_file_dialog (shell, ".mo")
        of NONE => ()
        |  SOME s => 
         (set_window();
          MLWorks.IO.with_standard_output
            outstream
            (fn () =>
               MLWorks.IO.with_standard_error
                 outstream
		 (fn () =>
  	            Incremental.match_object_path
	              (fn _ => fn m =>
		         (do_action (READ_DEPEND, (ModuleId.string m, m));
		          do_action (action, (ModuleId.string m, m))),
		       Info.make_default_options (),
	               Location.FILE title, s)
	            handle
                      Info.Stop (error,error_list) =>
                        error_handler
                        (s, error, error_list, "Checking Unit Names",
                         fn () => Preferences.new_preferences user_preferences,
                         fn () => object_file_action action ()))))
  
      fun get_history_menu () =
        map
        (fn (action, (s, m)) =>
         Menus.PUSH (string_action action ^ " " ^ s,
                     fn _ => do_action(action, (s, m)),
                     fn _ => true))
        (!history)

      fun close_window _ =
	if not (!evaluating) then 
	  (do_quit_funs ();
	   Capi.destroy shell)
	else
	  ()
  
      fun is_selection _ =
	case !selection of
	  NONE => false
	| SOME _ => true

      val view_menu =
        GuiUtils.view_options
          {parent = shell, title = title, user_options = user_options,
           user_preferences = user_preferences,
           caller_update_fn = fn _ => (),
           view_type =
	     [GuiUtils.SENSITIVITY,
	      GuiUtils.VALUE_PRINTER,
	      GuiUtils.INTERNALS]}

      (*
	I would like to add the following options to the view menu:

	all
	loaded
	compiled
	visible
	console

	Maybe the results of the check commands should be displayed in 
	the main list, which would affect this menu too.
     *)

      fun get_user_context () = GuiUtils.get_user_context (!local_context)

      val file_menu = ToolData.file_menu
  	   [("save", fn _ =>
		       GuiUtils.save_history
                         (false, get_user_context (), applicationShell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set
                                 (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), applicationShell),
		       fn _ => not (UserContext.null_history
                                      (get_user_context ()))),
	    ("read_depend_file", read_depend_file, fn _ => true),
	    ("load_source_file",
	       source_file_action LOAD_SOURCE,
	       fn _ => not (!evaluating)),
	    ("load_file",
	       object_file_action LOAD,
	       fn _ => not (!evaluating)),
	    ("compile_file",
	       source_file_action COMPILE,
	       fn _ => not (!evaluating)),
	    ("compile_and_load_file",
	       source_file_action COMPILE_AND_LOAD,
	       fn _ => not (!evaluating)),
	    ("close", close_window, fn () => not (!evaluating))]

      val view = ToolData.extract view_menu

      val project_menu = Menus.CASCADE ("project_menu",
	[Menus.PUSH ("check_load_source", 
                     make_callback CHECK_LOAD_SOURCE, is_selection),
	 Menus.PUSH ("check_load",
                      make_callback CHECK_LOAD, is_selection),
	 Menus.PUSH ("check_compile",
                      make_callback CHECK_COMPILE, is_selection),
	 Menus.PUSH ("show_graph", graph, is_selection),
	 Menus.SEPARATOR,
	 Menus.CASCADE ("touch", 
		[Menus.PUSH ("touch_source",
                 make_callback TOUCH_SOURCE, is_selection),
  	         Menus.PUSH ("touch_loaded",
                              make_callback TOUCH_LOADED, is_selection),
  	         Menus.PUSH ("touch_all_loaded", touch_all, fn _ => true)],
  	        is_selection),
	 Menus.SEPARATOR,
	 Menus.PUSH ("load_source", make_callback LOAD_SOURCE,
		fn _ => not (!evaluating) andalso is_selection ()),
	 Menus.PUSH ("load", make_callback LOAD,
		fn _ => not (!evaluating) andalso is_selection ()),
	 Menus.PUSH ("compile", make_callback COMPILE,
		fn _ => not (!evaluating) andalso is_selection ()),
	 Menus.PUSH ("compile_and_load", make_callback COMPILE_AND_LOAD,
		fn _ => not (!evaluating) andalso is_selection ()),
	 Menus.SEPARATOR,
	 Menus.PUSH ("deleteSelection", delete, is_selection),
	 Menus.PUSH ("removeAllUnits", clear_all, fn _ => true),
	 Menus.PUSH ("clear_console",
                     clear_console, fn _ => true)], fn () => true)

      val menuspec =
	[file_menu,
         ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME
              (fn _ => Capi.clipboard_set
                        (console_text, Capi.Text.get_selection console_text)),
             delete = NONE,
             selection_made = 
               fn _ => Capi.Text.get_selection console_text <> "",
             edit_possible = fn _ => false,
	     delete_all = NONE,
             edit_source = [Menus.PUSH ("editSelection",
                            make_callback EDIT, is_selection)] }),
	 ToolData.tools_menu (mk_tooldata, get_current_user_context),
	 ToolData.usage_menu (view, []),
	 project_menu,
	 ToolData.debug_menu [],
         GuiUtils.paths_menu frame,
         Menus.DYNAMIC ("history", get_history_menu, fn _ => true)]

      val textPaneLayout =
	(textPane,
	 [Capi.Layout.FIXED consoleLabel,
	  Capi.Layout.FLEX console_widget,
	  Capi.Layout.SPACE]);

      val listPaneLayout =
        (listPane,
         [Capi.Layout.FIXED modNameLabel,
          Capi.Layout.FIXED sourceFileLabel,
          Capi.Layout.FIXED objectFileLabel,
	  Capi.Layout.SPACE,
          Capi.Layout.FIXED listLabel,
          Capi.Layout.FLEX scroll,
          Capi.Layout.SPACE]);
    in
      project_tool := SOME shell;
      quit_funs := Menus.quit :: (!quit_funs);
      Menus.make_submenus (menubar,menuspec);
      Capi.Layout.lay_out
	(frame,
	 [Capi.Layout.MENUBAR menubar,
	  Capi.Layout.SPACE,
	  Capi.Layout.PANED (paned, [textPaneLayout, listPaneLayout])]);
      Capi.set_close_callback(frame, close_window);
      redisplay (!selection);
      Capi.initialize_toplevel shell
    end (* of create_project_tool *)

  fun create tooldata = 
    if isSome (!project_tool) then
      Capi.to_front (valOf (!project_tool))
    else
      create_project_tool tooldata

end
@


1.74
log
@[Bug #30089]
Remove use of OldOs.mtime in favour of OsFileSys.modTime
@
text
@d3 4
d1374 1
a1374 1
		 ((MLWorks.IO.set_file_modified (file, MLWorks.IO.NOW);
@


1.73
log
@[Bug #30244]
Giving the dependency graph the full menus.
@
text
@d3 4
d256 1
a263 1
require "../make/old_os";
d298 1
a298 1
  structure OldOs: OLD_OS
d1372 3
a1374 10
		   case OldOs.mtime file of
		     OldOs.EXISTS new_time =>
		       Project.set_source_info
		         (Incremental.get_project (), m,
			  SOME (file, module, new_time))
		   | _ =>
		     Crash.impossible
		       ("Can't find time for newly-written file `" ^
                         file ^ "'")
		   )
@


1.72
log
@[Bug #30153]
Remove references to Old.
@
text
@d3 4
d343 1
d425 2
d854 54
a907 18
          val close_push =
            Menus.PUSH ("close", fn _ => Capi.destroy shell, fn _ => true)
          val graph_push =
            Menus.PUSH ("graph", popup_menu, fn _ => true)

          val specialMenu =
            Menus.CASCADE ("dep_graph",
                           [Menus.PUSH ("expand_all",
                                        fn () => setExpanded true,
                                        fn () => isExpanded () = false),
                            Menus.PUSH ("only_root",
                                        fn () => setExpanded false,
                                        fn () => isExpanded () = true  ) ,
                            Menus.SEPARATOR,
                            Menus.PUSH ("make_root",
                                        focusOnSelection,
                                        canFocusOnSelection ),
                            Menus.PUSH ("original_root", 
d909 4
a912 23
                                        canUnfocus),
                            Menus.SEPARATOR,
                            Menus.CASCADE("layout_style",[
                              Menus.PUSH ("cascading_layout",
                                          fn () => setLayoutStyle CASCADE,
                                          fn () =>
                                             getLayoutStyle() <> CASCADE),
                              Menus.PUSH ("tree_layout",
                                          fn () => setLayoutStyle TREE,
                                          fn () => 
                                             getLayoutStyle() <> TREE) ],
                              fn _ => true ),
                            Menus.SEPARATOR,
                            Menus.PUSH ("search",
                                        initialiseSearch
                                          (fn _ => ModuleId.string
                                                     (!graphSelection))
					  (matchStrong, matchWeak),
                                        fn _ => true )],
                            fn _ => true)

          val menuSpec = [Menus.CASCADE ("window", [close_push], fn _ => true),
                          specialMenu ]
d921 3
a923 2
          setLayoutStyle (#style layout); setExpanded (#expanded layout);
          Menus.make_menus (menuBar, menuSpec, false);
a1525 2

      fun mk_tooldata () = tooldata
@


1.71
log
@[Bug #30203]
Add graphs for checking files to be compiled.
@
text
@d3 4
d246 2
a247 1
require "../basis/__int";
a274 1
require "^.basis.__old";
d935 1
a935 1
	      (fn (s, _) => Old.ord s <> ord #" ")
@


1.70
log
@[Bug #30241]
Implementing proper find dialog.
@
text
@d3 4
d325 1
a325 1
	       TopLevel.ModuleId = Incremental.ModuleId
d544 4
d556 2
d559 4
a562 2
      (* Several graph windows can be open at any time *)
      fun project_graph_tool (parent, project, module_id, title) =
d566 1
a566 1
          val windowName = "Dependency Graph of "^moduleName
d583 2
a584 1
                (ordering, get_children, mk_node) -> unit -> (NODES, ROOTS)
d592 1
a592 1
          fun map_to_graph_fn (ordering, get_children, mk_node) =
d599 21
a619 18
                case NewMap.tryApply' (!seen, key)
                of SOME index => index
                |  NONE =>
                 let
	            (* Warning: this could raise an exception *)
                    val children = get_children key
                    val index = !iref
                    val children_ref = ref []
                    val _ = seen := NewMap.define (!seen, key, index)
                    val _ = nodesList :=
                              (NODE (mk_node key, ref NONE), children_ref) ::
                                    !nodesList
                    val _ = iref := 1 + !iref
                    val children_ids = map do_node children
                  in
                    children_ref := children_ids;
                    index
                  end (* of fun do_node *)
d628 3
d647 2
d664 1
a664 1
    
d732 2
a733 1
          fun make_project_graph (project, module_id, parent, title) =
d743 2
a744 1
                   (ModuleId.lt, get_requires, mk_node), 
d750 3
a752 1
            make_project_graph (project, module_id, frame, title);
d785 1
a785 1
          fun showAll b ()  = 
d788 1
d791 1
a791 10
          (* function used to decide whether menu option is allowed *)
          val canExpandAll =
            fn _ =>
              not (!(#show_all
                       ((fn GraphWidget.GRAPH_SPEC gs => gs) graph_spec)))

          val canContract =
            fn _ =>
             (!(#show_all ((fn GraphWidget.GRAPH_SPEC gs => gs) graph_spec)))
             orelse (!userExpandedNode)
d813 1
d821 1
a824 5
          fun isCascadeLayout () =
            let val (GraphWidget.GRAPH_SPEC gs) = graph_spec in
            !(#line_style gs) = GraphWidget.STEP
            end

d832 1
d836 6
a841 4
          fun isTreeLayout () = 
            let val (GraphWidget.GRAPH_SPEC gs) = graph_spec in
            !(#line_style gs) = GraphWidget.STRAIGHT
            end
d850 6
a855 4
                           [Menus.PUSH ("expand_all", showAll true,
                                        canExpandAll),
                            Menus.PUSH ("only_root", showAll false,
                                         canContract ) ,
d866 3
a868 2
                                          setCascadeLayout,
                                          isTreeLayout),
d870 3
a872 2
                                          setTreeLayout,
                                          isCascadeLayout) ],
d893 1
d907 7
a913 1
	  (applicationShell, Incremental.get_project (), m, title);
d1009 1
a1009 2
	|  SOME (_, m) =>
          show_graph m
d1058 75
a1195 37
      val check_load_source =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message
		(shell, "Query Dependencies for Load From Source: " ^ s)
                (fn () =>
                   (ActionQueue.add_check_load_source_module (s,error_info);
                    ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
		       preferences =
                         Preferences.new_preferences user_preferences,
		       output_fn =
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn =
			 fn s => MLWorks.IO.output 
                                   (MLWorks.IO.std_out, "Checking " ^ s)}));
              message_fun
		("Query Dependencies for Load From Source of " ^ s ^ 
                 " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Query Load From Source",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

a1225 36
      val check_load =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message
		(shell, "Query Dependencies for Load Object: " ^ s)
                (fn () =>
                   (ActionQueue.add_check_load_module (s,error_info);
                    ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn =
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn =
                        fn s => MLWorks.IO.output
                                 (MLWorks.IO.std_out, "Checking " ^ s)}));
              message_fun
		("Query Dependencies for Load Object of " ^ s ^ " finished")
            end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Query Load Object",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

a1331 35
      val check_compile =
        let
          fun f (s, m) =
            let
              val error_info = Info.make_default_options()
            in
              Capi.with_message (shell, "Query Dependencies for Compile: " ^ s)
                (fn () =>
                   (ActionQueue.add_check_compile_module (s,error_info);
                    ActionQueue.do_actions
                      {user_context =
			 GuiUtils.get_user_context (!local_context),
                       user_options = user_options,
		       error_info = error_info,
		       debugger = debugger_function,
                       preferences =
			 Preferences.new_preferences user_preferences,
                       output_fn =
                          fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn =
                          fn s => MLWorks.IO.output
                                    (MLWorks.IO.std_out,"Checking " ^ s)}));
              message_fun ("Query Dependencies for Compile: " ^ s ^
                           " finished")
	    end
            handle
              ActionQueue.Error (_,error,error_list) =>
                error_handler
                (s, error, error_list, "Query Compile",
                 fn () => Preferences.new_preferences user_preferences,
                 fn () => mk_action f (s, m))
        in
          mk_action f
        end

d1365 1
a1365 1
        | get_action CHECK_LOAD_SOURCE = check_load_source
d1370 2
a1371 2
        | get_action CHECK_COMPILE = check_compile
	| get_action CHECK_LOAD = check_load
d1569 2
a1570 1
	 Menus.PUSH ("check_load", make_callback CHECK_LOAD, is_selection),
@


1.70.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.70  1997/09/05  09:52:25  johnh
 * [Bug #30241]
 * Implementing proper find dialog.
 *
@


1.70.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.70  1997/09/05  09:52:25  johnh
 * [Bug #30241]
 * Implementing proper find dialog.
 *
@


1.69
log
@[Bug #30202]
Add functionality to dependency graphs.
Graph definitions now appear inside the main create_project_tool function,
Graph can be manipulated by the user (expand nodes, change root, search),
Code has been tidied up a bit,
Graphics have been tidied up a bit.
@
text
@d3 8
d858 1
a858 2
                                          [(matchStrong, "match_whole"),
                                           (matchWeak, "match_part")],
@


1.68
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d3 4
d325 1
d337 2
a338 116
  
  fun map_to_graph_fn (ordering, root, get_children, mk_node) =
    let
      val nodes_ref = ref []
      val iref = ref 0
      val seen = ref (NewMap.empty' ordering)
  
      fun do_node key =
        case NewMap.tryApply' (!seen, key)
        of SOME index => index
        |  NONE =>
          let
  	  (* Warning: this could raise an exception *)
            val children = get_children key
            val index = !iref
            val children_ref = ref []
  	  val _ = seen := NewMap.define (!seen, key, index)
            val _ = nodes_ref :=
                      (NODE (mk_node key, ref NONE), children_ref) :: !nodes_ref
            val _ = iref := 1 + !iref
            val children_ids = map do_node children
          in
            children_ref := children_ids;
            index
          end
  
      val _ = do_node root
  
      val nodes =
        MLWorks.Internal.Array.arrayoflist
        (rev (map (fn (node,ref children) => (node,children)) (!nodes_ref)))
    in
      fn () => (nodes, [0])
    end
  
  val graph_spec =
    GraphWidget.GRAPH_SPEC
      {child_position = ref GraphWidget.CENTRE,
       child_expansion = ref GraphWidget.ALWAYS,
       default_visibility = ref true,
       show_root_children = ref false,
       orientation = ref GraphWidget.VERTICAL,
       line_style = ref GraphWidget.STRAIGHT,
       horizontal_delta = ref 20,
       vertical_delta = ref 30,
       graph_origin = ref (8, 8),
       show_all = ref true 
      }
  
  val baseline_height = 3
  fun max (x: int,y) = if x > y then x else y
  
  fun get_node_data (NODE (entry, extents),gp) =
    case !extents of
      SOME data => data
    | _ =>
        let
          val s = ModuleId.string entry
          val {font_ascent,font_descent,width,...} =
            Capi.GraphicsPorts.text_extent (gp,s)
          val data = (s,font_ascent,font_descent,width)
        in
          extents := SOME data;
          data
        end
  
  fun entry_draw_node (node,selected,gp,Capi.POINT{x,y}) =
    let
      val (s,font_ascent,font_descent,width) = get_node_data (node,gp)
      val left = width div 2
      val right = width - left
      fun wrapper gp f x =
        if selected then Capi.GraphicsPorts.with_highlighting (gp,f,x)
        else f x
    in 
      wrapper
      gp
      Capi.GraphicsPorts.draw_image_string
      (gp,s,Capi.POINT{x=x - left, y=y - baseline_height})
    end
  
  fun entry_extent (node,gp) =
    let
      val (s,font_ascent,font_descent,width) = get_node_data (node,gp)
      val left = width div 2
      val right = width - left
    in
      GraphWidget.EXTENT
        {left = left,
         right = right+2,
         up = baseline_height + font_ascent+1,
         down = max (0,font_descent+3-baseline_height)}
    end
  
  fun make_project_graph (project, module_id, parent, title) =
    let
      fun get_requires m = Project.get_requires (project, m)
      fun mk_node m = Project.get_name (project, m)
    in
      GraphWidget.make
        ("projectGraph", "ProjectGraph", title,parent, graph_spec,
         map_to_graph_fn (ModuleId.lt, module_id, get_requires, mk_node), 
         entry_draw_node, entry_extent)
    end
  
  fun project_graph_tool (parent, project, module_id,title) =
    let
      val (shell, frame, menuBar, _) =
        Capi.make_main_window
	  ("compManagerGraph", "Dependency Graph", parent, false, true);

      val {initialize, widget, popup_menu, ...} =
        make_project_graph (project, module_id, frame, title);

      val close_push = Menus.PUSH ("close", fn _ => Capi.destroy shell, fn _ => true)
      val graph_push = Menus.PUSH ("graph", popup_menu, fn _ => true)
d340 1
a340 17
      (* On Motif this menuspec includes the Cascade buttons, but on Windows, it 
       * does not because the 'action' and 'view' cascade buttons used in the 
       * Motif menu are not found in the single menu bar on Windows.
       *)
      val menuSpec = Menus.get_graph_menuspec (close_push, graph_push)

    in
      Menus.make_submenus (menuBar, menuSpec);
      Capi.Layout.lay_out (frame,
                           [Capi.Layout.MENUBAR menuBar,
                            Capi.Layout.SPACE,
                            Capi.Layout.FLEX widget,
                            Capi.Layout.SPACE]);
      Capi.set_close_callback(frame, fn () => Capi.destroy shell);
      Capi.initialize_toplevel shell;
      initialize (fn _ => ())
    end
d351 1
d354 6
d363 1
d472 2
a473 1
	      (MLWorks.IO.std_out,header ^ ": Error in " ^ file_message ^ "\n");
d488 2
a489 2
      val selection = ref NONE : (string * ModuleId.ModuleId) option ref
  
d530 344
a874 2
      fun select_fn _ (s, m) =
	update_labels (SOME (s, m))
d878 3
a880 1
	  (applicationShell, Incremental.get_project (), m,title);
d888 3
a890 3
          {parent = listPane, name = "list", select_fn = select_fn,
           action_fn = action_fn, print_fn = print_item};
  
d893 1
d928 1
a928 1
	end
d930 5
d938 1
d942 3
d963 1
a963 2
      fun do_quit_funs () =
	List.app (fn f => f ()) (!quit_funs)
d986 2
a987 1
	  (MLWorks.IO.output (outstream, "Delete unit " ^ s ^ " from project\n");
d1070 2
a1071 1
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
d1073 2
a1074 1
			 fn s => MLWorks.IO.output (MLWorks.IO.std_out,"Compiling " ^ s)}));
d1105 2
a1106 1
		       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
d1108 2
a1109 1
			 fn s => MLWorks.IO.output (MLWorks.IO.std_out, "Checking " ^ s)}));
d1111 2
a1112 1
		("Query Dependencies for Load From Source of " ^ s ^ " finished")
d1140 2
a1141 1
		   fn s => MLWorks.IO.output(MLWorks.IO.std_out, "Touching loaded unit" ^ s)};
d1172 5
a1176 2
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn = fn s => MLWorks.IO.output (MLWorks.IO.std_out, "Checking " ^ s)}));
d1208 5
a1212 2
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn = fn s => MLWorks.IO.output (MLWorks.IO.std_out, "Checking " ^ s)}));
d1244 5
a1248 2
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, "Loading " ^ s)}));
d1279 2
a1280 1
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
d1282 2
a1283 1
                         fn s => MLWorks.IO.output(MLWorks.IO.std_out, "Compiling " ^ s)}));
d1313 7
a1319 3
                       output_fn = fn s => MLWorks.IO.output(MLWorks.IO.std_out, s),
                       monitor_fn = fn s => MLWorks.IO.output (MLWorks.IO.std_out,"Checking " ^ s)}));
              message_fun ("Query Dependencies for Compile: " ^ s ^ " finished")
d1345 2
a1346 1
		       ("Can't find time for newly-written file `" ^ file ^ "'")
d1538 2
a1539 1
		       GuiUtils.save_history (false, get_user_context (), applicationShell),
d1542 2
a1543 1
		       andalso UserContext.saved_name_set (get_user_context ())),
d1546 2
a1547 1
		       fn _ => not (UserContext.null_history (get_user_context ()))),
d1566 2
a1567 1
	[Menus.PUSH ("check_load_source", make_callback CHECK_LOAD_SOURCE, is_selection),
d1569 2
a1570 1
	 Menus.PUSH ("check_compile", make_callback CHECK_COMPILE, is_selection),
d1574 4
a1577 2
		[Menus.PUSH ("touch_source", make_callback TOUCH_SOURCE, is_selection),
  	         Menus.PUSH ("touch_loaded", make_callback TOUCH_LOADED, is_selection),
d1592 2
a1593 1
	 Menus.PUSH ("clear_console", clear_console, fn _ => true)], fn () => true)
d1602 2
a1603 2
               (fn _ => Capi.clipboard_set
                          (console_text, Capi.Text.get_selection console_text)),
d1605 2
a1606 1
             selection_made = fn _ => Capi.Text.get_selection console_text <> "",
d1609 2
a1610 1
             edit_source = [Menus.PUSH ("editSelection", make_callback EDIT, is_selection)] }),
d1643 1
a1643 1
      redisplay NONE;
d1645 1
a1645 1
    end
@


1.67
log
@[Bug #30075]
Allowing only one instance of tools.
@
text
@d3 4
d441 1
a441 1
	  ("compManagerGraph", "Dependency Graph", parent, false);
d499 1
a499 1
	  ("compManager", title, applicationShell, false);
d1346 1
a1346 2
         Menus.DYNAMIC ("history", get_history_menu, fn _ => true),
         ToolData.windows_menu ()]
@


1.66
log
@[Bug #30155]
Remove 'action' and 'view' cascade menu items for Win32
@
text
@d3 4
d472 1
a472 1
  val tool_number = ref 1
d474 1
a474 1
  fun create (tooldata as ToolData.TOOLDATA
d491 1
a491 8
      val title =
        let
          val n = !tool_number
        in
          tool_number := n + 1;
          "Project Browser #" ^ (Int.toString n)
        end (* title *)

d700 2
a701 1
      val quit_funs = ref [fn () => Incremental.remove_update_fn key]
d1361 1
d1373 7
@


1.65
log
@Implementing single menu bar on Windows.
@
text
@d3 3
d438 9
a446 9
      val menuSpec =
	[Menus.CASCADE
	   ("action",
	    [Menus.PUSH ("close", fn _ => Capi.destroy shell, fn _ => true)],
	    fn () => true),
	 Menus.CASCADE
	   ("view",
	    [Menus.PUSH ("graph", popup_menu, fn _ => true)],
	    fn () => true)]
@


1.64
log
@[Bug #1774]
Fixed minor compilation error in previous fix.
@
text
@d3 4
d294 1
a294 1
	       ActionQueue.user_context
d302 1
a302 1
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
d314 1
d478 6
d489 1
a489 1
          "Compilation Manager #" ^ (Int.toString n)
d594 3
a596 1
	            redo_action = redo_action})
d1246 1
a1246 1
      val view_options =
a1255 7
      val view_menu =
        Menus.CASCADE
          ("view",
           view_options
           @@ [Menus.PUSH ("show_graph", graph, is_selection),
	      Menus.PUSH ("clear_console", clear_console, fn _ => true)],
           fn _ => true)
d1269 13
a1281 7
      val file_menu =
        Menus.CASCADE
  	  ("file",
  	   [Menus.PUSH ("read_depend_file", read_depend_file, fn _ => true),
	    Menus.SEPARATOR,
	    Menus.PUSH
	      ("load_source_file",
d1284 1
a1284 2
  	    Menus.PUSH
	      ("load_file",
d1287 1
a1287 2
  	    Menus.PUSH
	      ("compile_file",
d1290 1
a1290 2
  	    Menus.PUSH
	      ("compile_and_load_file",
d1293 1
a1293 3
	    Menus.SEPARATOR,
	    Menus.PUSH ("close", close_window, fn () => not (!evaluating))],
  	   fn _ => true)
d1295 1
a1295 2
      fun get_current_user_context () =
        GuiUtils.get_user_context (!local_context)
d1297 13
a1309 9
      fun get_user_context_options () =
        ToolData.UserContext.get_user_options (get_current_user_context ())

      val build_menu =
         Menus.CASCADE
  	   ("module",
  	    [Menus.PUSH
	       ("read_depend",
	        make_callback READ_DEPEND,
d1311 1
a1311 4
	     Menus.SEPARATOR,
  	     Menus.PUSH
	       ("load_source",
		make_callback LOAD_SOURCE,
d1313 1
a1313 3
  	     Menus.PUSH
	       ("load",
		make_callback LOAD,
d1315 1
a1315 3
  	     Menus.PUSH
	       ("compile",
		make_callback COMPILE,
d1317 4
a1320 31
  	     Menus.PUSH
	       ("compile_and_load",
		make_callback COMPILE_AND_LOAD,
		fn _ => not (!evaluating) andalso is_selection ()),
	     Menus.SEPARATOR,
             Menus.CASCADE
  	       ("query",
  	        [Menus.PUSH
	           ("check_load_source",
	            make_callback CHECK_LOAD_SOURCE,
	            is_selection),
  	         Menus.PUSH
		   ("check_load", make_callback CHECK_LOAD, is_selection),
  	         Menus.PUSH
	           ("check_compile",
		    make_callback CHECK_COMPILE,
		    is_selection)],
  	        is_selection),
             Menus.CASCADE
  	       ("touch",
  	        [Menus.PUSH
	           ("touch_source", make_callback TOUCH_SOURCE, is_selection),
  	         Menus.PUSH
	           ("touch_loaded", make_callback TOUCH_LOADED, is_selection),
  	         Menus.PUSH
	           ("touch_all_loaded", touch_all, fn _ => true)],
  	        is_selection),
	     Menus.SEPARATOR,
  	     Menus.PUSH ("deleteSelection", delete, is_selection),
	     Menus.PUSH ("deleteAll", clear_all, fn _ => true)],
  	    fn _ => true)
d1332 1
a1332 2
             selection_made =
  	       fn _ => Capi.Text.get_selection console_text <> "",
d1334 6
a1339 8
             tail =
	       [Menus.PUSH
		  ("editSelection", make_callback EDIT, is_selection)]}),
	 view_menu,
	 build_menu,
         GuiUtils.setup_menu
           (frame, fn () => !local_context,
	    user_preferences, get_user_context_options),
a1340 1
	 ToolData.tools_menu (mk_tooldata, get_current_user_context),
d1360 1
@


1.64.1.1
log
@branched from 1.64
@
text
@a2 4
 * Revision 1.64  1997/03/17  16:06:25  daveb
 * [Bug #1774]
 * Fixed minor compilation error in previous fix.
 *
@


1.64.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.64.1.1  1997/05/12  10:31:14  hope
 * branched from 1.64
 *
@


1.64.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.64.1.1  1997/05/12  10:31:14  hope
 * branched from 1.64
 *
@


1.64.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.64.1.1  1997/05/12  10:31:14  hope
 * branched from 1.64
 *
@


1.64.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.64.1.1.1.1  1997/07/28  18:17:07  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.63
log
@[Bug #1774]
Added Info.Stop handler to read_depend_file.
@
text
@d3 4
d1159 1
a1159 1
                        (Module.sourceName m, error, error_list, "Checking Unit Names",
@


1.62
log
@[Bug #1813]
update selection reference when units are deleted.
@
text
@d3 4
d1144 14
a1157 5
  	       Incremental.match_source_path
	         (fn _ => fn m =>
		    do_action (READ_DEPEND, (ModuleId.string m, m)),
		  Info.make_default_options (),
	          Location.FILE title, s, "reading dependencies from")))
@


1.61
log
@Putting clear_console in _console to set the write_pos.
@
text
@d3 3
d725 1
d731 1
@


1.61.3.1
log
@branched from 1.61
@
text
@a2 3
 * Revision 1.61  1996/12/03  20:21:39  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.61.2.1
log
@branched from 1.61
@
text
@a2 3
 * Revision 1.61  1996/12/03  20:21:39  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.61.2.1.1.1
log
@branched from 1.61.2.1
@
text
@a2 3
 * Revision 1.61.2.1  1996/12/17  17:44:55  hope
 * branched from 1.61
 *
@


1.61.1.1
log
@branched from 1.61
@
text
@a2 3
 * Revision 1.61  1996/12/03  20:21:39  johnh
 * Putting clear_console in _console to set the write_pos.
 *
@


1.60
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
d499 1
a499 1
           set_window} =
a1197 3

      fun clear_console _ =
        Capi.Text.set_string (console_text, "")
@


1.60.2.1
log
@branched from 1.60
@
text
@a2 4
 * Revision 1.60  1996/11/06  11:15:42  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.60.1.1
log
@branched from 1.60
@
text
@a2 4
 * Revision 1.60  1996/11/06  11:15:42  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.60.1.1.1.1
log
@branched from 1.60.1.1
@
text
@a2 3
 * Revision 1.60.1.1  1996/11/14  12:45:43  hope
 * branched from 1.60
 *
@


1.59
log
@Enabling close from control box on top left of window.
@
text
@d3 3
d196 1
a196 1
require "../basis/__integer";
@


1.58
log
@Enabling interruption during compilation on Windows.
@
text
@d3 3
d428 1
d675 2
d680 3
a682 1
	    handle exn => (evaluating := false; raise exn)
d685 1
d726 18
a743 17
	   Capi.with_window_updates 
	   (fn () => 
	   MLWorks.IO.with_standard_input
             instream
             (fn () =>
              MLWorks.IO.with_standard_output
                outstream
                (fn () =>
                 MLWorks.IO.with_standard_error
                 outstream
                 (fn () =>
		    ShellTypes.with_toplevel_name
		      title
		      (fn () =>
                         (Ml_Debugger.with_debugger_type
                            debugger_type
			    (fn _ => f x)))))))
d1196 5
a1200 2
	(do_quit_funs ();
	 Capi.destroy shell)
d1368 1
@


1.57
log
@[Bug #1614]
basifying String
@
text
@d3 4
d717 3
a719 1
           MLWorks.IO.with_standard_input
d733 1
a733 1
                            (fn _ => f x))))))
@


1.56
log
@[Bug #1480]
Implemented compile-and-load properly.
@
text
@d3 4
d214 1
a287 2
  open MLWorks.Option;
  
d428 5
a432 5
      Location.UNKNOWN => MLWorks.Option.NONE
    | Location.FILE f => MLWorks.Option.SOME f
    | Location.LINE(f,l) => MLWorks.Option.SOME f
    | Location.POSITION (f,l,_) => MLWorks.Option.SOME f
    | Location.EXTENT {name,...} => MLWorks.Option.SOME name
d521 1
a521 1
	val error_browser_ref = ref MLWorks.Option.NONE
d525 2
a526 2
	  of MLWorks.Option.NONE => ()
	  |  MLWorks.Option.SOME f =>
d528 1
a528 1
	     error_browser_ref := MLWorks.Option.NONE)
d539 2
a540 2
                  MLWorks.Option.NONE => ""
                | MLWorks.Option.SOME s => s
d550 1
a550 1
	      MLWorks.Option.SOME
d624 1
a624 1
	      (fn (s, _) => String.ord s <> String.ord " ")
d741 2
a742 2
		  (MLWorks.Option.NONE,_) => ()
		| (MLWorks.Option.SOME s,_) => message_fun s))
@


1.56.3.1
log
@branched from 1.56
@
text
@a2 4
 * Revision 1.56  1996/08/20  13:48:10  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.56.2.1
log
@branched from 1.56
@
text
@a2 4
 * Revision 1.56  1996/08/20  13:48:10  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.56.1.1
log
@branched from 1.56
@
text
@a2 4
 * Revision 1.56  1996/08/20  13:48:10  daveb
 * [Bug #1480]
 * Implemented compile-and-load properly.
 *
@


1.55
log
@[Bug #1360]
Added a menu bar to the Graph window.
@
text
@d3 4
d886 33
d1054 1
a1054 1
	| get_action COMPILE_AND_LOAD = (fn x => (do_compile x; do_load x))
@


1.54
log
@[Bug #1485]
Added handler for Info.Stop when raised by Incremental.match_source_path.
Split file_action into source_file_action and object_file_action.
@
text
@d3 5
d391 1
a391 1
      val (shell, frame, menubar, _) =
d395 1
a395 1
      val {initialize, widget, ...} =
d397 10
d408 1
d410 1
a410 1
                           [Capi.Layout.MENUBAR menubar,
d601 2
a602 1
        project_graph_tool (applicationShell, Incremental.get_project (), m,title);
@


1.53
log
@[Bug #1493]
Added a "suffix" argument to the file_action function.
@
text
@d3 4
d1061 26
a1086 2
      fun file_action (action, suffix) _ =
        case Capi.open_file_dialog (shell, suffix)
d1093 15
a1107 6
  	       Incremental.match_source_path
	         (fn _ => fn m =>
		    (do_action (READ_DEPEND, (ModuleId.string m, m));
		     do_action (action, (ModuleId.string m, m))),
		  Info.make_default_options (),
	          Location.FILE title, s, string_action action)))
d1168 1
a1168 1
	       file_action (LOAD_SOURCE, ".sml"),
d1172 1
a1172 1
	       file_action (LOAD, ".mo"),
d1176 1
a1176 1
	       file_action (COMPILE, ".sml"),
d1180 1
a1180 1
	       file_action (COMPILE_AND_LOAD, ".sml"),
@


1.52
log
@[Bug #1478]
Disabled Close menu item during evaluations.
@
text
@d3 4
d1057 2
a1058 2
      fun file_action action _ =
        case Capi.open_file_dialog (shell, ".sml")
d1131 1
a1131 1
	       file_action LOAD_SOURCE,
d1135 1
a1135 1
	       file_action LOAD,
d1139 1
a1139 1
	       file_action COMPILE,
d1143 1
a1143 1
	       file_action COMPILE_AND_LOAD,
@


1.51
log
@[Bug #1260]
Changed the Capi layout datatype so that the PANED constructor takes the
layout info for its sub-panes.  This enables the Windows layout code to
calculate the minimum size of each window.
@
text
@d3 6
d631 13
d737 2
a738 1
                    ActionQueue.do_actions
d866 2
a867 1
                    ActionQueue.do_actions
d898 2
a899 1
                    ActionQueue.do_actions
d1125 16
a1140 8
	    Menus.PUSH ("load_source_file",
		         file_action LOAD_SOURCE,
		         fn _ => true),
  	    Menus.PUSH ("load_file", file_action LOAD, fn _ => true),
  	    Menus.PUSH ("compile_file", file_action COMPILE, fn _ => true),
  	    Menus.PUSH ("compile_and_load_file",
	                 file_action COMPILE_AND_LOAD,
	                 fn _ => true),
d1142 1
a1142 1
	    Menus.PUSH ("close", close_window, fn () => true)],
d1155 3
a1157 1
	       ("read_depend", make_callback READ_DEPEND, is_selection),
d1160 11
a1170 3
		("load_source", make_callback LOAD_SOURCE, is_selection),
  	     Menus.PUSH ("load", make_callback LOAD, is_selection),
  	     Menus.PUSH ("compile", make_callback COMPILE, is_selection),
d1174 1
a1174 1
		is_selection),
@


1.50
log
@redirecting standard IO to the GUI within the compilation manager.
@
text
@d3 3
d1188 2
a1189 3
    in
      Menus.make_submenus (menubar,menuspec);
      Capi.Layout.lay_out
d1194 2
a1195 1
      Capi.Layout.lay_out
d1204 2
d1210 1
a1210 1
	  Capi.Layout.PANED paned]);
@


1.49
log
@The Interrupt and Io exceptions are no longer at top level.
@
text
@d3 3
d443 2
a444 1
      val {instream, outstream, console_widget, console_text, clear_input} =
d658 1
d1018 1
d1026 1
a1026 1
	          Location.FILE title, s, "reading dependencies from"))
d1032 1
d1041 1
a1041 1
	          Location.FILE title, s, string_action action))
@


1.48
log
@DebuggerWindow.make_debugger_window now returns a clean-up function to call
at the end of each evaluation.
@
text
@d3 4
d459 1
a459 1
             | exn as Interrupt => raise exn
d670 1
a670 1
               Interrupt => ();
d939 1
a939 1
                   handle Io _ =>
@


1.47
log
@Adding parent_title to GraphWidget.make
@
text
@d3 3
d441 4
d446 1
a446 5
        Ml_Debugger.WINDOWING
          (DebuggerWindow.make_debugger_window
             (shell, title ^ " Debugger", tooldata),
           message_fun,
           false)
d666 2
a667 1
               Interrupt => ())
@


1.46
log
@The extension passed to open_file_dialog does not need a preceding * .
@
text
@d3 3
d346 1
a346 1
  fun make_project_graph (project, module_id, parent) =
d352 1
a352 1
        ("projectGraph", "ProjectGraph", parent, graph_spec,
d357 1
a357 1
  fun project_graph_tool (parent, project, module_id) =
d364 1
a364 1
        make_project_graph (project, module_id, frame);
d557 1
a557 1
        project_graph_tool (applicationShell, Incremental.get_project (), m);
@


1.45
log
@Type of GuiUtils.view_option has changed.
@
text
@d3 3
d999 1
a999 1
        case Capi.open_file_dialog (shell, "*.sml")
d1012 1
a1012 1
        case Capi.open_file_dialog (shell, "*.sml")
@


1.44
log
@Reordering menus.
@
text
@d3 3
d1049 4
a1052 1
           view_type = GuiUtils.VIEW_ALL}
@


1.43
log
@Modified contents of labels to print <none> when appropriate.
@
text
@d3 3
d1085 48
d1146 3
a1148 1
             tail = []}),
d1150 6
a1155 37
         Menus.CASCADE
  	   ("module",
  	    [Menus.PUSH
	       ("read_depend", make_callback READ_DEPEND, is_selection),
  	     Menus.PUSH
		("load_source", make_callback LOAD_SOURCE, is_selection),
  	     Menus.PUSH ("load", make_callback LOAD, is_selection),
  	     Menus.PUSH ("compile", make_callback COMPILE, is_selection),
  	     Menus.PUSH
	       ("compile_and_load",
		make_callback COMPILE_AND_LOAD,
		is_selection),
  	     Menus.PUSH ("edit", make_callback EDIT, is_selection),
  	     Menus.PUSH ("delete", delete, is_selection),
	     Menus.PUSH ("deleteAll", clear_all, fn _ => true)],
  	    fn _ => true),
         Menus.CASCADE
  	 ("query",
  	  [Menus.PUSH
	     ("check_load_source",
	      make_callback CHECK_LOAD_SOURCE,
	      is_selection),
  	   Menus.PUSH ("check_load", make_callback CHECK_LOAD, is_selection),
  	   Menus.PUSH
	     ("check_compile", make_callback CHECK_COMPILE, is_selection)],
  	  fn _ => true),
         Menus.CASCADE
  	 ("touch",
  	  [Menus.PUSH
	     ("touch_source", make_callback TOUCH_SOURCE, is_selection),
  	   Menus.PUSH
	     ("touch_loaded", make_callback TOUCH_LOADED, is_selection),
  	   Menus.PUSH
	     ("touch_all_loaded", touch_all, fn _ => true)],
  	  fn _ => true),
	 ToolData.tools_menu
           (mk_tooldata, fn () => GuiUtils.get_user_context (!local_context)),
@


1.42
log
@Made the console be a permanent pane of the compilation manager.
Added an edit menu.
@
text
@d3 4
d501 3
a503 3
        (Capi.set_label_string (modNameLabel, "Unit: ");
         Capi.set_label_string (sourceFileLabel, "Source: ");
         Capi.set_label_string (objectFileLabel, "Object: "))
d510 1
a510 1
  	      NONE => ""
d515 1
a515 1
  	      NONE => ""
d533 6
a538 3
          Capi.set_label_string (modNameLabel, "Unit: " ^ s ^ status_string);
          Capi.set_label_string (sourceFileLabel, "Source: " ^ source_file);
          Capi.set_label_string (objectFileLabel, "Object: " ^ object_file)
@


1.41
log
@Moved File menu and Tools menu, adjusting both in minor ways.
@
text
@d394 9
d404 1
a404 1
        Capi.make_managed_widget ("modNameLabel", Capi.Label,frame, [])
d406 1
a406 1
        Capi.make_managed_widget ("sourceFileLabel", Capi.Label, frame, [])
d408 1
a408 1
        Capi.make_managed_widget ("objectFileLabel", Capi.Label, frame, [])
d410 1
a410 1
        Capi.make_managed_widget ("listLabel", Capi.Label, frame, [])
d414 5
a418 3
      val {instream, outstream, console_widget, console_visible,
           show_console, clear_input} =
        Console.create (shell, title, user_preferences)
d546 1
a546 1
          {parent = frame, name = "list", select_fn = select_fn,
d1019 3
d1042 2
a1043 3
           @@ [Menus.TOGGLE
                ("console", console_visible, show_console, fn () => true),
  	      Menus.PUSH ("show_graph", graph, is_selection)],
d1077 12
d1132 7
a1138 4
        (frame,
         [Capi.Layout.MENUBAR menubar,
          Capi.Layout.SPACE,
          Capi.Layout.FIXED modNameLabel,
d1145 5
@


1.40
log
@Fixing layout
@
text
@d3 3
d1045 17
d1063 1
a1063 3
        [ToolData.works_menu
           (mk_tooldata, close_window, fn () => true,
            fn () => GuiUtils.get_user_context (!local_context)),
d1066 15
a1080 24
  	 ("file",
  	  [Menus.PUSH ("read_depend_file", read_depend_file, fn _ => true),
	   Menus.PUSH ("load_source_file",
		       file_action LOAD_SOURCE,
		       fn _ => true),
  	   Menus.PUSH ("load_file", file_action LOAD, fn _ => true),
  	   Menus.PUSH ("compile_file", file_action COMPILE, fn _ => true),
  	   Menus.PUSH ("compile_and_load_file",
	               file_action COMPILE_AND_LOAD,
	               fn _ => true),
	   Menus.PUSH ("deleteAll", clear_all, fn _ => true)],
  	  fn _ => true),
         Menus.CASCADE
  	 ("module",
  	  [Menus.PUSH ("read_depend", make_callback READ_DEPEND, is_selection),
  	   Menus.PUSH ("load_source", make_callback LOAD_SOURCE, is_selection),
  	   Menus.PUSH ("load", make_callback LOAD, is_selection),
  	   Menus.PUSH ("compile", make_callback COMPILE, is_selection),
  	   Menus.PUSH
	     ("compile_and_load", make_callback COMPILE_AND_LOAD, is_selection),
  	   Menus.PUSH ("edit", make_callback EDIT, is_selection),
  	   Menus.PUSH ("delete", delete, is_selection),
	   Menus.PUSH ("deleteAll", clear_all, fn _ => true)],
  	  fn _ => true),
d1088 2
a1089 1
  	   Menus.PUSH ("check_compile", make_callback CHECK_COMPILE, is_selection)],
d1100 2
@


1.39
log
@ErrorBrowser.create now returns a quit function.  Used this to kill off
old error browsers.
@
text
@d3 4
d1102 1
@


1.38
log
@ActionQueue.do_actions now takes an Info.options argument.
@
text
@d3 3
d435 40
a474 24
      fun error_handler
            (filename, error, error_list, header, preferences_fn, redo_action) =
        let
            val action_message =
              header ^ ": " ^ filename

            val file_message =
              case location_file error of
                MLWorks.Option.NONE => ""
              | MLWorks.Option.SOME s => s

            fun edit_action location =
              {quit_fn = ShellUtils.edit_location (location, preferences_fn()),
               clean_fn = fn () => ()}
        in
          MLWorks.IO.output(MLWorks.IO.std_out,header ^ ": Error in " ^ file_message ^ "\n");
          ErrorBrowser.create
            {parent = shell, errors = rev error_list,
             file_message = file_message,
             editable = fn _ => true,
	     edit_action = edit_action,
	     close_action = fn _ => (),
	     redo_action = redo_action}
        end
d609 1
@


1.37
log
@Array moving to MLWorks.Array
@
text
@d3 3
d649 1
d682 1
d712 1
d745 1
d777 1
d808 1
d840 1
@


1.36
log
@Removed ActionQueue.Handled exception.
@
text
@d3 3
d124 1
a124 1
require "../basis/lists";
d252 1
a252 1
        Array.arrayoflist
@


1.35
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
a656 1
            | ActionQueue.Handled => ()
a689 1
            | ActionQueue.Handled => ()
a717 1
            | ActionQueue.Handled => ()
a749 1
            | ActionQueue.Handled => ()
a779 1
            | ActionQueue.Handled => ()
a810 1
            | ActionQueue.Handled => ()
a840 1
            | ActionQueue.Handled => ()
@


1.34
log
@Replacing MLWorks.Integer with basis file
@
text
@d3 3
d435 1
a435 1
          output(std_out,header ^ ": Error in " ^ file_message ^ "\n");
d504 1
a504 1
	      (fn (s, _) => ord s <> ord " ")
d559 1
a559 1
	(output (outstream, "Touch all loaded modules\n");
d567 1
a567 1
	  (output (outstream, "Delete unit " ^ s ^ " from project\n");
d572 1
a572 1
	(output (outstream, "Delete all units\n");
d640 1
a640 1
                       output_fn = fn s => output(std_out, s),
d642 1
a642 1
			 fn s => output (std_out,"Compiling " ^ s)}));
d673 1
a673 1
		       output_fn = fn s => output(std_out, s),
d675 1
a675 1
			 fn s => output (std_out, "Checking " ^ s)}));
d703 1
a703 1
                 output_fn = fn s => output(std_out, s),
d705 1
a705 1
		   fn s => output(std_out, "Touching loaded unit" ^ s)};
d736 2
a737 2
                       output_fn = fn s => output(std_out, s),
                       monitor_fn = fn s => output (std_out, "Checking " ^ s)}));
d768 2
a769 2
                       output_fn = fn s => output(std_out, s),
                       monitor_fn = fn s => output(std_out, "Loading " ^ s)}));
d799 1
a799 1
                       output_fn = fn s => output(std_out, s),
d801 1
a801 1
                         fn s => output(std_out, "Compiling " ^ s)}));
d831 2
a832 2
                       output_fn = fn s => output(std_out, s),
                       monitor_fn = fn s => output (std_out,"Checking " ^ s)}));
d923 1
a923 1
	(output (outstream, string_action action ^ " " ^ s ^ "\n");
@


1.33
log
@initbasis moves to basis
@
text
@d3 3
d105 2
d361 1
a361 1
          "Compilation Manager #" ^ (MLWorks.Integer.makestring n)
@


1.32
log
@ActionQueue.do_actions now takes a preferences argument (and a record
instead of a tuple).
@
text
@d3 4
d107 1
a107 1
require "../initbasis/lists";
@


1.31
log
@Changes to graph interface
@
text
@d3 3
d160 2
a161 1
	       ShellUtils.preferences = Editor.preferences
d618 1
a618 1
              Capi.with_message (shell,"Loading from source " ^ s)
d622 10
a631 6
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s =>
			 output(std_out,"Load From Source: compiling " ^ s))));
              message_fun ("Load from source of " ^ s ^ " finished")
d636 1
a636 1
                (s, error, error_list, "Load from source",
d650 2
a651 1
              Capi.with_message (shell,"Load from source: Checking " ^ s)
d655 11
a665 6
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s =>
			 output (std_out,"Load from source: checking " ^ s))));
              message_fun ("Check load from source of " ^ s ^ " finished")
d670 1
a670 1
                (s, error, error_list, "Check load from source",
d686 8
a693 4
                (GuiUtils.get_user_context (!local_context),
                 user_options, debugger_function,
                 fn s => output(std_out, s),
                 fn s => output(std_out, "Touching loaded unit" ^ s));
d699 1
a699 1
                (s, error, error_list, "Touch loaded",
d713 2
a714 1
              Capi.with_message (shell,"Load objects : Checking " ^ s)
d718 10
a727 6
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s =>
			 output (std_out,"Load objects: checking " ^ s))));
              message_fun ("Check load objects of " ^ s ^ " finished")
d732 1
a732 1
                (s, error, error_list, "Check load objects",
d746 1
a746 1
              Capi.with_message (shell, "Loading " ^ s)
d750 9
a758 5
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s => output(std_out, "Loading " ^ s))));
              message_fun ("Load of " ^ s ^ " finished")
d763 1
a763 1
                (s, error, error_list, "Load",
d781 9
a789 4
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s => output(std_out, "Compiling " ^ s))));
d809 1
a809 1
              Capi.with_message (shell, "Compile: Checking " ^ s)
d813 10
a822 6
                      (GuiUtils.get_user_context (!local_context),
                       user_options, debugger_function,
                       fn s => output(std_out, s),
                       fn s => output(std_out,"Compile: checking " ^ s))));
              message_fun ("Check Object Dependencies of " ^ s ^ " finished")
            end
d826 1
a826 1
                (s, error, error_list, "Check Compile",
@


1.30
log
@Implemented touch_all_modules command.
Made non-action commands print something on the console.
Moved the Graph menu item to the View menu.
@
text
@d3 5
d235 2
a236 2
      {child_position = GraphWidget.CENTRE,
       child_expansion = GraphWidget.ALWAYS,
d238 7
a244 7
       show_root_children = false,
       orientation = GraphWidget.VERTICAL,
       line_style = GraphWidget.STRAIGHT,
       horizontal_delta = 20,
       vertical_delta = 30,
       graph_origin = (8, 8),
       show_all = true 
@


1.29
log
@Made all commands print something on the console.
@
text
@d3 3
d537 5
d545 3
a547 2
	|  SOME (_, m) =>
	  (Incremental.delete_from_project m;
d551 2
a552 1
	(Incremental.reset_project ();
d821 1
a821 1
	CHECK_LOAD | TOUCH_ALL_LOADED | COMPILE_AND_LOAD | READ_DEPEND
a831 1
	| get_action TOUCH_ALL_LOADED = (fn _ => ())
a867 1
	| TOUCH_ALL_LOADED => "Touch all loaded modules"
d937 2
a938 1
                ("console", console_visible, show_console, fn () => true)],
a978 1
  	   Menus.PUSH ("show_graph", graph, is_selection),
d999 1
a999 1
	     ("touch_all_loaded", make_callback TOUCH_ALL_LOADED, fn _ => false)],
@


1.28
log
@Changed Project.load_dependencies to Incremental.read_dependencies.
Replaced "Main" and "Action" menus with "File" and "Module" menus.
@
text
@d3 4
d528 1
a528 1
      fun delete m =
d531 7
a537 1
	|  SOME (s, m) =>
a576 4
      val graph =
	mk_action
	  (fn (_, m) => show_graph m)

d580 3
a582 1
	    (reload m; redisplay (SOME (s, m)))
d586 1
a586 1
                (s, error, error_list, "Loading Dependencies",
d810 1
a810 1
        CHECK_COMPILE | TOUCH_SOURCE | GRAPH | LOAD |
a820 1
	| get_action GRAPH = graph
d846 18
a863 2
      fun do_action (action, selection) =
	(add_action (action, selection);
d882 1
a882 1
	          Location.FILE title, s, "loading dependencies from"))
a883 16
      fun string_action action =
        case action of
          EDIT => "Edit"
        | LOAD_SOURCE => "Do Load Source"
        | CHECK_LOAD_SOURCE => "Check Load Source"
        | TOUCH_LOADED => "Touch Loaded"
        | LOAD => "Do Load"
        | COMPILE => "Do Compile"
        | TOUCH_SOURCE => "Touch Source"
        | CHECK_COMPILE => "Check Compile"
        | GRAPH => "Graph"
	| CHECK_LOAD => "Check Load"
	| TOUCH_ALL_LOADED => "Touch All Loaded"
	| COMPILE_AND_LOAD => "Do Compile and Load"
	| READ_DEPEND => "Load Dependencies"

d970 1
a970 1
  	   Menus.PUSH ("show_graph", make_callback GRAPH, is_selection),
@


1.27
log
@Improved Layout.
@
text
@d3 3
d519 4
a522 4
	Incremental.set_project
	  (#1 (Project.load_dependencies
                 (Info.make_default_options (), Location.FILE title)
  	         (Incremental.get_project (), module_id, Project.empty_map)))
d571 1
a571 1
      val do_load_depend =
d803 1
a803 1
	CHECK_LOAD | TOUCH_ALL_LOADED | COMPILE_AND_LOAD | LOAD_DEPEND
d817 1
a817 1
	| get_action LOAD_DEPEND = do_load_depend
d848 1
a848 1
      fun load_depend _ =
d856 2
a857 1
	         (fn _ => fn m => do_action (LOAD_DEPEND, (s, m)),
d875 1
a875 1
	| LOAD_DEPEND => "Load Dependencies"
d877 14
d941 1
d943 10
a952 2
  	 ("main",
  	  [Menus.PUSH ("load_depend", load_depend, fn _ => true),
a954 1
	 view_menu,
d956 3
a958 2
  	 ("action",
  	  [Menus.PUSH ("load_source", make_callback LOAD_SOURCE, is_selection),
d961 2
a962 1
  	   Menus.PUSH ("compile_and_load", make_callback COMPILE_AND_LOAD, is_selection),
d964 1
d966 1
a966 1
  	   Menus.PUSH ("edit", make_callback EDIT, is_selection)],
@


1.26
log
@Mark any uses of Os as referring to the old Os interface.
@
text
@d3 3
a340 7
      val modNameText =
        Capi.make_managed_widget ("modNameText", Capi.Text, frame, [])
      val sourceText =
        Capi.make_managed_widget ("sourceText", Capi.Text, frame, [])
      val objectText =
        Capi.make_managed_widget ("objectText", Capi.Text, frame, [])
  
d416 5
a420 1
      fun select_fn _ (s, m) =
d423 24
d449 3
a451 9
          Capi.Text.set_string (modNameText, s);
  	  case Project.get_source_info (project, m) of
  	    NONE => ()
  	  | SOME (s', _, _) =>
              Capi.Text.set_string (sourceText, s');
  	  case Project.get_object_info (project, m) of
  	    NONE => ()
  	  | SOME {file, ...} =>
              Capi.Text.set_string (objectText, file)
d454 3
d487 2
a488 1
	    NONE => ()
d926 1
a926 1
	   Menus.PUSH ("delete_all", clear_all, fn _ => true)],
a965 1
          Capi.Layout.FIXED modNameText,
a966 1
          Capi.Layout.FIXED sourceText,
d968 1
a968 2
          Capi.Layout.FIXED objectText,
          Capi.Layout.FIXED listLabel,
@


1.25
log
@Replaced Module.with_source_path with new Incremental.match_source_path.
Added delete function.
@
text
@d3 4
d83 1
a83 1
require "../make/os";
d118 1
a118 1
  structure Os: OS
d757 2
a758 2
		   case Os.mtime file of
		     Os.EXISTS new_time =>
@


1.24
log
@Removing duplicate structures from parameter
@
text
@d3 3
d125 2
a126 1
  sharing Project.Info = TopLevel.Info = ShellUtils.Info = ActionQueue.Info
d150 1
a150 1
	       ErrorBrowser.location
d152 1
a152 1
	       TopLevel.ModuleId
d495 7
d826 3
a828 2
  	       Module.with_source_path
	         (fn m => do_action (LOAD_DEPEND, (s, m)),
d900 1
a900 1
	   Menus.PUSH ("clear_all", clear_all, fn _ => true)],
a908 1
  	   Menus.PUSH ("visible", fn _ => (), fn _ => false),
d910 1
@


1.23
log
@Implemented check_load.
@
text
@d3 3
a108 3
  structure Os: OS
  structure TopLevel: TOPLEVEL
  structure Project: PROJECT
@


1.22
log
@Fixed use of Info.default_options.
@
text
@d3 3
d626 28
d774 1
a774 1
	| get_action CHECK_LOAD = (fn _ => ())
@


1.21
log
@Adding compileAndLoad functionality
@
text
@d3 3
d485 1
a485 1
                 (Info.default_options, Location.FILE title)
@


1.20
log
@Changed sourceTitleLabel to sourceFileLabel.
@
text
@d3 3
d729 1
a729 1
	CHECK_LOAD | CHECK_DO_ALL | TOUCH_ALL_LOADED | DO_ALL | LOAD_DEPEND
a740 1
	| get_action CHECK_DO_ALL = (fn _ => ())
d742 1
a742 1
	| get_action DO_ALL = (fn _ => ())
a796 1
	| CHECK_DO_ALL => "Check Compile and Load"
d798 1
a798 1
	| DO_ALL => "Do Compile and Load"
d859 1
a859 2
  	  [Menus.PUSH
	     ("load_source", make_callback LOAD_SOURCE, is_selection),
d862 1
a862 1
  	   Menus.PUSH ("do_all", make_callback DO_ALL, fn _ => false),
d874 1
a874 4
  	   Menus.PUSH
	     ("check_compile", make_callback CHECK_COMPILE, is_selection),
  	   Menus.PUSH
	     ("check_do_all", make_callback CHECK_DO_ALL, fn _ => false)],
d883 1
a883 3
	     ("touch_all_loaded",
	      make_callback TOUCH_ALL_LOADED,
	      fn _ => false)],
@


1.19
log
@Type of Project object info has changed.
@
text
@d3 3
d328 6
a333 6
      val modNameTitleLabel = 
        Capi.make_managed_widget ("modNameTitleLabel", Capi.Label,frame, [])
      val sourceTitleLabel = 
        Capi.make_managed_widget ("sourceTitleLabel", Capi.Label, frame, [])
      val objectTitleLabel =
        Capi.make_managed_widget ("objectTitleLabel", Capi.Label, frame, [])
d898 1
a898 1
          Capi.Layout.FIXED modNameTitleLabel,
d900 1
a900 1
          Capi.Layout.FIXED sourceTitleLabel,
d902 1
a902 1
          Capi.Layout.FIXED objectTitleLabel,
@


1.18
log
@Hid implementation of Project.Unit type.
@
text
@d3 3
d412 2
a413 2
  	  | SOME (s', _, _, _) =>
              Capi.Text.set_string (objectText, s')
d494 6
a499 3
                    (Ml_Debugger.with_debugger_type
                       debugger_type
                       (fn _ => f x)))))
@


1.17
log
@newmap becomes map, NEWMAP becomes MAP
@
text
@d3 3
d158 1
a158 1
  fun map_to_graph_fn (newmap, root, get_children, mk_node) =
d162 1
a162 1
      val seen = ref (NewMap.empty' (NewMap.get_ordering newmap))
a168 1
            val entry = NewMap.apply' (newmap, key)
d170 1
a170 1
            val children = get_children entry
d175 1
a175 1
                      (NODE (mk_node entry, ref NONE), children_ref) :: !nodes_ref
d251 1
a251 1
  fun make_project_graph (Project.PROJECT map, module_id, parent) =
d253 2
a254 2
      fun get_requires (Project.UNIT {requires, ...}) = !requires
      fun mk_node (Project.UNIT {name, ...}) = name
d258 1
a258 1
         map_to_graph_fn (map, module_id, get_requires, mk_node), 
d399 1
a399 3
  	  val Project.PROJECT map =
	    Incremental.get_project ()
  	  val Project.UNIT unit = NewMap.apply' (map, m)
d403 1
a403 1
  	  case !(#source unit) of
d407 1
a407 1
  	  case !(#object unit) of
@


1.16
log
@ErrorBrowser.create now takes a close_action field.
@
text
@d3 3
d52 1
a52 1
require "../utils/newmap";
d82 1
a82 1
  structure NewMap: NEWMAP
d131 1
a131 1
  sharing type NewMap.T = Project.Map
@


1.15
log
@Ensured that current selection is more or less visible.
@
text
@d3 3
d384 3
a386 1
             editable = fn _ => true, edit_action = edit_action,
@


1.14
log
@Capi.make_scrolllist now returns a record, with an add_items field.
@
text
@d3 3
d424 2
d438 12
a449 1
		SOME n => Capi.List.select_pos (list, n, true)
@


1.13
log
@Minor change to error browser interface.
@
text
@d3 3
d409 1
a409 1
      val (scroll, list, set_items) =
a790 1
           sensitivity = GuiUtils.NO_SENSE_SELECTION,
@


1.12
log
@Changed interface to graph widget
@
text
@d3 3
d365 1
a365 2
              | MLWorks.Option.SOME s =>
                  "Error in: " ^ s
d371 1
a371 1
          output(std_out,header ^ ": " ^ file_message ^ "\n");
d374 1
a374 1
             action_message = action_message, file_message = file_message,
@


1.11
log
@Minor changes to the menus.
@
text
@d3 3
d206 1
a206 1
  fun entry_draw_node (node,gp,Capi.POINT{x,y}) =
d211 3
d215 2
d218 1
a218 1
           (gp,s,Capi.POINT{x=x - left, y=y - baseline_height})
@


1.10
log
@Reordering top level menus.
@
text
@d3 3
a804 1
	 view_menu,
d806 1
a806 1
  	 ("project",
d810 1
d819 1
d843 1
a843 2
	      fn _ => false),
  	   Menus.PUSH ("graph", make_callback GRAPH, is_selection)],
@


1.9
log
@Fixing layout parameters
@
text
@d3 3
d842 2
a843 1
         Menus.DYNAMIC ("history", get_history_menu, fn _ => true)]
@


1.8
log
@The type of Capi.open_file_dialog has changed.
@
text
@d3 3
d240 5
a244 6
      Capi.Layout.lay_out
        (frame,
         [Capi.Layout.MENUBAR menubar,
  	Capi.Layout.SPACE,
          Capi.Layout.FIXED widget,
  	Capi.Layout.SPACE]);
d845 10
a854 10
  	Capi.Layout.SPACE,
  	Capi.Layout.FIXED modNameTitleLabel,
  	Capi.Layout.FIXED modNameText,
  	Capi.Layout.FIXED sourceTitleLabel,
  	Capi.Layout.FIXED sourceText,
  	Capi.Layout.FIXED objectTitleLabel,
  	Capi.Layout.FIXED objectText,
  	Capi.Layout.FIXED listLabel,
          Capi.Layout.FIXED scroll,
  	Capi.Layout.SPACE]);
@


1.7
log
@Replaced Capi.find_file with Capi.open_file_dialog.
@
text
@d3 3
d719 1
a719 1
        case Capi.open_file_dialog (shell, "*.sml", Capi.FILE)
@


1.6
log
@Correcting bug in edit action.
@
text
@d3 3
d716 1
a716 1
        case Capi.find_file (shell, "*.sml", Capi.FILE)
@


1.5
log
@Replaced FileDialog.find_file with Capi.find_file; the type has changed too.
@
text
@d3 3
d448 9
a456 6
          (fn (s, _) =>
           (case Editor.edit
                   (Preferences.new_preferences user_preferences)
                   (s,0)
            of (MLWorks.Option.NONE,_) => ()
            |  (MLWorks.Option.SOME s,_) => message_fun s))
@


1.4
log
@Module.with_source_path now takes a string describing the action undertaken.
@
text
@d3 3
a31 1
require "file_dialog";
a59 2
  structure Capi: CAPI
  structure Incremental: INCREMENTAL
a63 1
  structure FileDialog: FILE_DIALOG
d72 1
a72 1
  sharing type Capi.Widget = FileDialog.Widget = Menus.Widget =
d707 1
a707 1
        case FileDialog.find_file shell
@


1.3
log
@Added header.
@
text
@d2 4
a5 1
 * $Log$
d711 6
a716 2
  	  Module.with_source_path
	    (fn m => do_action (LOAD_DEPEND, (s, m)), Location.FILE title, s)
@


1.2
log
@Changed names of windows.
@
text
@d1 6
@


1.1
log
@new unit
Replacement for the File Tool, showing details of loaded modules, etc.
@
text
@d215 2
a216 2
	  ("projectGraph", "Dependency Graph", parent, false);
  
d263 1
a263 1
	  ("project", title, applicationShell, false);
@
