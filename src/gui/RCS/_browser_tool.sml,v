head	1.59;
access;
symbols
	MLW_daveb_inline_1_4_99:1.59.1
	MLWorks_21c0_1999_03_25:1.59
	MLWorks_20c1_1998_08_20:1.59
	MLWorks_20c0_1998_08_04:1.59
	MLWorks_20b2c2_1998_06_19:1.59
	MLWorks_20b2_Windows_1998_06_12:1.59
	MLWorks_20b1c1_1998_05_07:1.59
	MLWorks_20b0_1998_04_07:1.59
	MLWorks_20b0_1998_03_20:1.58
	MLWorks_20m2_1998_02_16:1.56
	MLWorks_20m1_1997_10_23:1.55
	MLWorks_11r1:1.49.1.1.1.1.1
	MLWorks_workspace_97:1.55.2
	MLWorks_dt_wizard:1.55.1
	MLWorks_11c0_1997_09_09:1.49.1.1.1.1
	MLWorks_10r3:1.49.1.1.3
	MLWorks_10r2_551:1.49.1.1.2
	MLWorks_11:1.49.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.49.1.1
	MLWorks_20m0_1997_06_20:1.53
	MLWorks_1_0_r2c2_1997_06_14:1.49.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.49.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.49.1
	MLWorks_BugFix_1997_04_24:1.49
	MLWorks_1_0_r2_Win32_1997_04_11:1.49
	MLWorks_1_0_r2_Unix_1997_04_04:1.49
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.48.4.1.1
	MLWorks_gui_1996_12_18:1.48.5
	MLWorks_1_0_Win32_1996_12_17:1.48.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.48.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.48.1.1
	JFHgui:1.48.3
	MLWorks_1_0_Irix_1996_11_28:1.48.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.48.2
	MLWorks_1_0_Unix_1996_11_14:1.48.1
	MLWorks_Open_Beta2_1996_10_11:1.46.3
	MLWorks_License_dev:1.46.2
	MLWorks_1_open_beta_1996_09_13:1.46.1
	MLWorks_Open_Beta_1996_08_22:1.46
	MLWorks_Beta_1996_07_02:1.44
	MLWorks_Beta_1996_06_07:1.43
	MLWorks_Beta_1996_06_06:1.43
	MLWorks_Beta_1996_06_05:1.43
	MLWorks_Beta_1996_06_03:1.43
	MLWorks_Beta_1996_05_31:1.43
	MLWorks_Beta_1996_05_30:1.43;
locks; strict;
comment	@ * @;


1.59
date	98.03.31.15.15.52;	author johnh;	state Exp;
branches
	1.59.1.1;
next	1.58;

1.58
date	98.03.16.10.59.10;	author mitchell;	state Exp;
branches;
next	1.57;

1.57
date	98.02.13.15.57.54;	author johnh;	state Exp;
branches;
next	1.56;

1.56
date	98.01.27.15.58.40;	author johnh;	state Exp;
branches;
next	1.55;

1.55
date	97.09.05.09.49.58;	author johnh;	state Exp;
branches
	1.55.1.1
	1.55.2.1;
next	1.54;

1.54
date	97.08.06.14.58.09;	author brucem;	state Exp;
branches;
next	1.53;

1.53
date	97.06.12.15.02.57;	author johnh;	state Exp;
branches;
next	1.52;

1.52
date	97.06.11.12.34.13;	author johnh;	state Exp;
branches;
next	1.51;

1.51
date	97.05.16.15.35.23;	author johnh;	state Exp;
branches;
next	1.50;

1.50
date	97.05.06.09.33.01;	author jont;	state Exp;
branches;
next	1.49;

1.49
date	97.03.19.13.18.22;	author matthew;	state Exp;
branches
	1.49.1.1;
next	1.48;

1.48
date	96.11.06.11.15.37;	author matthew;	state Exp;
branches
	1.48.1.1
	1.48.2.1
	1.48.3.1
	1.48.4.1
	1.48.5.1;
next	1.47;

1.47
date	96.11.01.10.19.48;	author johnh;	state Exp;
branches;
next	1.46;

1.46
date	96.08.09.15.25.45;	author nickb;	state Exp;
branches
	1.46.1.1
	1.46.2.1
	1.46.3.1;
next	1.45;

1.45
date	96.08.07.11.45.12;	author andreww;	state Exp;
branches;
next	1.44;

1.44
date	96.06.11.11.20.28;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.05.28.14.26.00;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	96.05.28.09.35.22;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	96.05.24.14.04.09;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	96.05.14.14.07.08;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	96.05.10.14.45.05;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	96.05.07.11.48.07;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	96.04.30.10.03.36;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.04.17.12.54.14;	author nickb;	state Exp;
branches;
next	1.35;

1.35
date	96.04.04.11.14.33;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	96.02.08.11.28.31;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	96.01.25.13.15.26;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	96.01.23.15.30.00;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	96.01.22.16.35.08;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.01.19.11.41.04;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.01.17.16.12.19;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.01.09.16.25.41;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	95.12.07.14.31.07;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.11.16.16.46.44;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.11.16.13.52.11;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.11.15.17.01.40;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.10.26.10.43.06;	author daveb;	state Exp;
branches;
next	1.22;

1.22
date	95.10.24.16.53.52;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.10.15.14.23.51;	author brianm;	state Exp;
branches;
next	1.20;

1.20
date	95.10.10.16.04.58;	author brianm;	state Exp;
branches;
next	1.19;

1.19
date	95.10.09.11.39.40;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.10.08.21.50.48;	author brianm;	state Exp;
branches;
next	1.17;

1.17
date	95.10.06.12.33.40;	author brianm;	state Exp;
branches;
next	1.16;

1.16
date	95.10.05.17.20.52;	author brianm;	state Exp;
branches;
next	1.15;

1.15
date	95.10.05.12.51.17;	author daveb;	state Exp;
branches;
next	1.14;

1.14
date	95.10.02.15.38.50;	author brianm;	state Exp;
branches;
next	1.13;

1.13
date	95.10.02.12.14.43;	author brianm;	state Exp;
branches;
next	1.12;

1.12
date	95.09.18.14.33.23;	author brianm;	state Exp;
branches;
next	1.11;

1.11
date	95.09.11.13.18.54;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	95.09.07.13.45.55;	author matthew;	state Exp;
branches;
next	1.9;

1.9
date	95.09.06.15.19.07;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.08.31.12.02.51;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.08.31.11.57.07;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.15.14.52.47;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.10.12.12.43;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.03.09.50.38;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.07.27.10.55.16;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.32.24;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.42.29;	author matthew;	state Exp;
branches;
next	;

1.46.1.1
date	96.09.13.11.13.21;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.10.07.16.04.02;	author hope;	state Exp;
branches;
next	;

1.46.3.1
date	96.10.17.11.22.17;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	96.11.14.12.46.19;	author hope;	state Exp;
branches
	1.48.1.1.1.1;
next	;

1.48.1.1.1.1
date	96.11.28.14.58.02;	author hope;	state Exp;
branches;
next	;

1.48.2.1
date	96.11.22.18.06.39;	author hope;	state Exp;
branches;
next	;

1.48.3.1
date	96.12.17.09.54.42;	author hope;	state Exp;
branches;
next	;

1.48.4.1
date	96.12.17.17.45.20;	author hope;	state Exp;
branches
	1.48.4.1.1.1;
next	;

1.48.4.1.1.1
date	97.02.24.11.34.49;	author hope;	state Exp;
branches;
next	;

1.48.5.1
date	96.12.18.09.39.19;	author hope;	state Exp;
branches;
next	;

1.49.1.1
date	97.05.12.10.31.39;	author hope;	state Exp;
branches
	1.49.1.1.1.1
	1.49.1.1.2.1
	1.49.1.1.3.1;
next	;

1.49.1.1.1.1
date	97.07.28.18.17.33;	author daveb;	state Exp;
branches
	1.49.1.1.1.1.1.1;
next	;

1.49.1.1.1.1.1.1
date	97.10.07.11.42.25;	author jkbrook;	state Exp;
branches;
next	;

1.49.1.1.2.1
date	97.09.08.17.11.04;	author daveb;	state Exp;
branches;
next	;

1.49.1.1.3.1
date	97.09.09.14.06.39;	author daveb;	state Exp;
branches;
next	;

1.55.1.1
date	97.09.10.19.21.13;	author brucem;	state Exp;
branches;
next	;

1.55.2.1
date	97.09.11.20.52.25;	author daveb;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	97.11.20.17.02.32;	author johnh;	state Exp;
branches;
next	;

1.59.1.1
date	99.04.01.17.55.39;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.59
log
@[Bug #30346]
Call Capi.getNextWindowPos.
@
text
@(*
 * Copyright (c) 1993 Harlequin Ltd.
 *  $Log: _browser_tool.sml,v $
 * Revision 1.58  1998/03/16  10:59:10  mitchell
 * [Bug #50061]
 * Fix tools so they restart in a saved image
 *
 * Revision 1.57  1998/02/13  15:57:54  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.56  1998/01/27  15:58:40  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.55.2.2  1997/11/20  17:02:32  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.55.2.1  1997/09/11  20:52:25  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.55  1997/09/05  09:49:58  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
 * Revision 1.54  1997/08/06  14:58:09  brucem
 * [Bug #30224]
 * Add search facility.
 * (And change `selection' from text entry box to a text label).
 *
 * Revision 1.53  1997/06/12  15:02:57  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.52  1997/06/11  12:34:13  johnh
 * [Bug #30075]
 * Duplicating tool by cloning only.
 *
 * Revision 1.51  1997/05/16  15:35:23  johnh
 * Implementing single menu bar on Windows.
 * Re-organising menus for Motif.
 *
 * Revision 1.50  1997/05/06  09:33:01  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.49  1997/03/19  13:18:22  matthew
 * Removing debugger argument from eval.
 *
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.47  1996/11/01  10:19:48  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.46  1996/08/09  15:25:45  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.45  1996/08/07  11:45:12  andreww
 * [Bug #1521]
 * propagating changes to typechecker/_types.sml
 *
 * Revision 1.44  1996/06/11  11:20:28  matthew
 * Removing call to reposition function as this is no longer used.
 *
 * Revision 1.43  1996/05/28  14:26:00  matthew
 * Changed GraphWidget.make
 *
 * Revision 1.42  1996/05/28  09:35:22  daveb
 * Removed unused debugging code (that referenced MLWorks.RawIO).
 *
 * Revision 1.41  1996/05/24  14:04:09  daveb
 * Changes in Graph controls.
 *
 * Revision 1.40  1996/05/14  14:07:08  daveb
 * Added File menu.
 *
 * Revision 1.39  1996/05/10  14:45:05  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
 * Revision 1.38  1996/05/07  11:48:07  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.37  1996/04/30  10:03:36  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.36  1996/04/17  12:54:14  nickb
 * Pervasive browser title numbers are knackered.
 *
 * Revision 1.35  1996/04/04  11:14:33  matthew
 * Changing graph interface
 *
 * Revision 1.34  1996/02/08  11:28:31  daveb
 * UserContext.add_update_function now expects update functions that take
 * a list of history entries.
 * Removed the sensitivity type.
 *
 * Revision 1.33  1996/01/25  13:15:26  matthew
 * Changed interface to graph widget
 *
 * Revision 1.32  1996/01/23  15:30:00  daveb
 * Type of GuiUtils.value_menu has changed.
 *
 * Revision 1.31  1996/01/22  16:35:08  matthew
 * Using Info.null_options in call to eval
 *
 * Revision 1.30  1996/01/19  11:41:04  matthew
 * Changing inspector interface.
 *
 * Revision 1.29  1996/01/17  16:12:19  matthew
 * Reordering top level menus.
 *
 * Revision 1.28  1996/01/09  16:25:41  matthew
 * Make pervasive and non-pervasive browsers have different titles.
 *
 * Revision 1.27  1995/12/07  14:31:07  matthew
 * Changing interface to edit_menu
 *
 * Revision 1.26  1995/11/16  16:46:44  matthew
 * Changin layout parameters
 *
 * Revision 1.25  1995/11/16  13:52:11  matthew
 * Changing button resources
 *
 * Revision 1.24  1995/11/15  17:01:40  matthew
 * Adding windows menu
 *
 * Revision 1.23  1995/10/26  10:43:06  daveb
 * Removed context menu, because the search tool wasn't linked to anything.
 *
 * Revision 1.22  1995/10/24  16:53:52  daveb
 * Browser now recognises updates to the context.
 *
 * Revision 1.21  1995/10/15  14:23:51  brianm
 * Made modifications due to introduction of GraphWidget.Extent etc.
 *
 * Revision 1.20  1995/10/10  16:04:58  brianm
 * Modifications due to changes in GraphSpec.
 *
 * Revision 1.19  1995/10/09  11:39:40  daveb
 * Now that we have hidden contexts from the user, the pervasive browser has
 * to be treated somewhat specially.
 *
 * Revision 1.18  1995/10/08  21:50:48  brianm
 * Updates to allow for changed graph widget repositioning interface.
 *
 * Revision 1.17  1995/10/06  12:33:40  brianm
 * Modification to take account of change to graph_widget change and moved
 * graph selection stuff from here to graph_widget ...
 *
 * Revision 1.16  1995/10/05  17:20:52  brianm
 * Adding graphical selection repositioning ...
 *
 * Revision 1.15  1995/10/05  12:51:17  daveb
 * Type of context_menu has changed.
 *
 * Revision 1.14  1995/10/02  15:38:50  brianm
 * Removing the list pane component and associated parts (e.g. history).
 *
 * Revision 1.13  1995/10/02  12:14:43  brianm
 * Adding update of list entry by graph selection ...
 *
 * Revision 1.12  1995/09/18  14:33:23  brianm
 * Updating by adding Capi Point/Region datatypes
 *
 * Revision 1.11  1995/09/11  13:18:54  matthew
 * Changing top level window initialization
 *
 * Revision 1.10  1995/09/07  13:45:55  matthew
 * Extending GraphSpec type
 *
 * Revision 1.9  1995/09/06  15:19:07  matthew
 * Changing for new graph interface
 *
 * Revision 1.8  1995/08/31  12:02:51  matthew
 * Correcting typo
 *
 * Revision 1.7  1995/08/31  11:57:07  matthew
 * Renaming layout constructors
 *
 * Revision 1.6  1995/08/15  14:52:47  matthew
 * Adding some stuff into the menubar
 *
 * Revision 1.5  1995/08/10  12:12:43  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.4  1995/08/03  09:50:38  matthew
 * Improvements to graphs
 *
 * Revision 1.3  1995/07/27  10:55:16  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:42:29  matthew
 * new unit
 * New unit
 *
 *  Revision 1.63  1995/07/26  13:20:39  matthew
 *  Adding support for font dimensions etc.
 *
 *  Revision 1.62  1995/07/20  16:17:04  matthew
 *  Adding scroll_to functions
 *
 *  Revision 1.61  1995/07/17  11:47:52  matthew
 *  Graphics functions abstraction
 *
 *  Revision 1.60  1995/07/14  16:49:34  io
 *  add searching, offload bits to entry for listener use.
 *
 *  Revision 1.59  1995/07/07  15:42:54  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.58  1995/07/04  14:01:27  matthew
 *  Adding graphing functionality
 *
 *  Revision 1.57  1995/06/13  14:19:55  daveb
 *  Made value constructors be displayed with the "con" pseudo-keyword.
 *
 *  Revision 1.56  1995/06/01  10:31:22  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.55  1995/05/22  14:42:00  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.54  1995/05/22  09:54:00  daveb
 *  Added create_initial.
 *
 *  Revision 1.53  1995/05/04  09:51:33  matthew
 *  Changing createPopupShell to create
 *
 *  Revision 1.52  1995/04/28  16:56:05  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.51  1995/04/19  11:57:11  daveb
 *  A new tool is now passed the right user context.
 *
 *  Revision 1.49  1995/04/06  12:35:32  matthew
 *  Replacing Tyfun_id etc. with Stamp
 *
 *  Revision 1.48  1995/03/31  16:52:58  daveb
 *  Added the history number to items in the history.
 *
 *  Revision 1.47  1995/03/31  08:55:32  daveb
 *  Empty lists are now handled automatically by GuiUtils.make_scrolllist.
 *
 *  Revision 1.46  1995/03/17  11:28:26  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.45  1995/03/16  11:46:58  daveb
 *  Removed context_function from register when closing the window.
 *
 *  Revision 1.44  1995/03/15  16:41:09  daveb
 *  Changed to share current context with other tools..
 *
 *  Revision 1.43  1995/03/10  15:44:13  daveb
 *  Registered select function with current context.
 *  Also simplified manipulation of pathStack slightly - no need to store
 *  toplevel items on the stack, as they're always calculated anew.
 *
 *  Revision 1.42  1995/03/02  13:30:32  matthew
 *  Parser and Lexer revisions
 *
 *  Revision 1.41  1995/02/24  16:51:19  daveb
 *  Moved parent and toplevel buttons from the history menu to the main window.
 *
 *  Revision 1.40  1995/02/24  15:29:32  daveb
 *  Added View menu and Filter dialog box.  Made empty structures display
 *  the word "<empty">.
 *
 *  Revision 1.39  1994/11/30  16:26:17  daveb
 *  Simplified Form constraints.
 *
 *  Revision 1.38  1994/09/21  16:19:16  brianm
 *  Adding value menu ...
 *
 *  Revision 1.37  1994/08/09  17:02:24  daveb
 *  Fixed bugs with toplevel command and update behaviour.
 *
 *  Revision 1.36  1994/07/19  08:34:25  daveb
 *  Added automatic updates.
 *
 *  Revision 1.35  1994/07/12  16:04:16  daveb
 *  ToolData.works_menu now takes different arguments.
 *
 *  Revision 1.34  1994/06/20  15:25:19  daveb
 *  Changed context refs to user_contexts.
 *
 *  Revision 1.33  1994/05/05  16:37:05  daveb
 *  Overloaded schemes now include the type variable being overloaded.
 *
 *  Revision 1.32  1994/02/22  00:44:22  nosa
 *  TYCON' for type function functions in lambda code for Modules Debugger;
 *  Extra TYNAME valenv for Modules Debugger.
 *
 *  Revision 1.31  1993/12/15  15:35:12  matthew
 *  Added level field to Basis.
 *
 *  Revision 1.30  1993/12/10  15:34:44  daveb
 *  Added context menu, ensured that changes do the right thing, ensured that
 *  new selection is passed on to child tools.
 *
 *  Revision 1.29  1993/12/09  19:34:19  jont
 *  Added copyright message
 *
 *  Revision 1.28  1993/11/30  14:07:23  matthew
 *  Added is_abs field to TYNAME and METATYNAME
 *
 *  Revision 1.27  1993/11/25  14:25:31  daveb
 *  Changed the way constructors are displayed, so that selecting and pasting
 *  them makes sense.  This involved making two factors orthogonal: namely
 *  whether a component is the last component on a path and whether it has
 *  any entries (a datatype satisfies both of these conditions).
 *
 *  Revision 1.26  1993/10/22  16:59:01  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.25  1993/10/08  16:28:40  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.24  1993/09/16  16:06:03  nosa
 *  Instances for METATYVARs and TYVARs and in schemes for polymorphic debugger.
 *
 *  Revision 1.23.1.3  1993/10/21  14:03:54  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *
 *  Revision 1.23.1.2  1993/10/07  15:43:12  matthew
 *  Uses history utilities in ShellUtils
 *
 *  Revision 1.23.1.1  1993/08/11  11:05:10  jont
 *  Fork for bug fixing
 *
 *  Revision 1.23  1993/08/11  11:05:10  matthew
 *  Get update function from options_menu and put in user_options
 *  Removed preferences menu
 *
 *  Revision 1.22  1993/08/10  10:27:23  matthew
 *  Get maximum history length from options
 *
 *  Revision 1.21  1993/07/30  13:57:37  nosa
 *  Changed type of constructor NULL_TYFUN for value printing in
 *  local and closure variable inspection in the debugger.
 *
 *  Revision 1.20  1993/06/30  16:47:56  daveb
 *  Removed exception environments.
 *
 *  Revision 1.19  1993/05/18  19:05:42  jont
 *  Removed integer parameter
 *
 *  Revision 1.18  1993/05/14  14:27:42  daveb
 *  Changed names of history menu buttons.
 *
 *  Revision 1.17  1993/05/13  12:48:19  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *
 *  Revision 1.16  1993/05/12  16:25:33  daveb
 *  Added pop_history command.
 *
 *  Revision 1.15  1993/05/12  15:38:16  daveb
 *  Added previous fix to update function as well.
 *
 *  Revision 1.14  1993/05/12  15:32:14  daveb
 *  Fixed bug in display of current selection.  Set max history to sensible
 *  number.
 *
 *  Revision 1.13  1993/05/11  15:58:12  matthew
 *  Change to layout resources
 *
 *  Revision 1.12  1993/05/05  12:10:17  daveb
 *  Added tools argument to works_menu(),
 *  removed exitApplication from TOOLDATA (works_menu now accesses it directly).
 *
 *  Revision 1.11  1993/05/04  17:24:52  matthew
 *  Added label with context name
 *  Changed context ref handling
 *
 *  Revision 1.10  1993/05/04  15:19:51  daveb
 *  Removed duplicates from history and restricted history length.
 *  Added selected values (etc.) to the selection display.
 *
 *  Revision 1.9  1993/04/30  14:45:58  daveb
 *  Reorganised menus.
 *
 *  Revision 1.8  1993/04/29  13:49:09  daveb
 *  Added dynamic history and update facility.
 *  Corrected reversed ordering of variables and exceptions.
 *
 *  Revision 1.7  1993/04/28  15:09:55  daveb
 *  Added selection text widget and improved the layout.
 *
 *  Revision 1.6  1993/04/28  10:39:02  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.5  1993/04/27  11:21:25  daveb
 *  Fixed printing of exceptions.  Filtered out value constructors from list.
 *
 *  Revision 1.4  1993/04/26  18:53:45  daveb
 *  Fixed printing of type variables.
 *
 *  Revision 1.3  1993/04/22  08:49:55  daveb
 *  Removed now spurious reference to Valenv.Options.  That version of valenv
 *  was never checked in, as it turned out not to be needed.
 *
 *  Revision 1.2  1993/04/21  16:34:34  daveb
 *  Now browses datatypes, and ignores types and vals.
 *
 *  Revision 1.1  1993/04/21  14:15:43  daveb
 *  Initial revision
 *  
 *  
 *)

require "../basis/__int";

require "capi";
require "menus";
require "../utils/lists";
require "../main/user_options";
require "../main/preferences";
require "../utils/crash";
require "../interpreter/shell_utils";
require "../interpreter/save_image";
require "../interpreter/entry";
require "inspector_tool";
require "graph_widget";
require "gui_utils";
require "tooldata";
require "browser_tool";

functor BrowserTool (
  structure Capi : CAPI
  structure GraphWidget : GRAPH_WIDGET
  structure Crash : CRASH
  structure Lists : LISTS
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure Menus : MENUS
  structure InspectorTool : INSPECTORTOOL
  structure GuiUtils : GUI_UTILS
  structure ToolData : TOOL_DATA
  structure ShellUtils : SHELL_UTILS
  structure SaveImage : SAVE_IMAGE
  structure Entry : ENTRY

  sharing UserOptions.Options = 
	  ToolData.ShellTypes.Options =
          ShellUtils.Options
  sharing type Entry.options = UserOptions.Options.options
  sharing type ToolData.UserContext.identifier = Entry.Identifier
  sharing type UserOptions.user_tool_options =
	       ToolData.ShellTypes.user_options =
	       GuiUtils.user_tool_options = ShellUtils.UserOptions
  sharing type Menus.Widget = GuiUtils.Widget = ToolData.Widget = Capi.Widget =
               GraphWidget.Widget = InspectorTool.Widget
  sharing type Capi.GraphicsPorts.GraphicsPort = GraphWidget.GraphicsPort
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ShellTypes.Context =
               Entry.Context = ShellUtils.Context
  sharing type ToolData.ShellTypes.user_context = GuiUtils.user_context
  sharing type GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options = 
               UserOptions.user_context_options
  sharing type ShellUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       Preferences.user_preferences =
	       GuiUtils.user_preferences
  sharing type GuiUtils.Type = ShellUtils.Type = InspectorTool.Type
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type GraphWidget.Point = Capi.Point
  sharing type GraphWidget.Region = Capi.Region
  sharing type InspectorTool.ToolData = ToolData.ToolData
) : BROWSERTOOL =
struct
    structure UserContext = ToolData.UserContext
    structure Options = UserOptions.Options
    structure Info = ShellUtils.Info
    structure ShellTypes = ToolData.ShellTypes

    type Widget = Capi.Widget
    type UserOptions = UserOptions.user_tool_options
    type ShellData = ShellTypes.ShellData
    type ToolData = ToolData.ToolData


    fun title () = "Browser"
    fun initial_title () = "System Browser"

    (* The following two references store whether these browsers are already created, 
     * and if so, the handle to the window is stored so that the window can be brought
     * to the front.
     *)
    val context_browser = ref NONE
    val system_browser = ref NONE

    (* These references store the number of the duplicated browsers. *)
    val context_number = ref 1
    val system_number = ref 1

    val sizeRef = ref NONE
    val posRef = ref NONE

    (* browser_ref is the option reference for storing the handle to the window, 
     * number_ref stores the number of the latest duplicated browser, and
     * the 'duplicated' boolean indicates whether the number should be included
     * in the title.  The original browsers (ie. those invoked from the tools menu)
     * do not include the number in the title.
     *)

    fun create_internal (browser_ref, number_ref, duplicated) (tooldata, orig_title) =
      let
        val ToolData.TOOLDATA {args,appdata,current_context,motif_context,tools} =
          tooldata
	val ShellTypes.LISTENER_ARGS
	      {user_options, user_preferences, user_context,
	       mk_xinterface_fn, prompter, ...} = args

	val ToolData.APPLICATIONDATA {applicationShell,...} =
	  appdata

	val full_menus =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	    !full_menus

	val local_context = ref motif_context

	fun get_user_context () = GuiUtils.get_user_context (!local_context)

        fun get_user_context_options () =
	  UserContext.get_user_options
	    (GuiUtils.get_user_context (!local_context))

        fun get_compiler_options () =
          UserOptions.new_options (user_options, get_user_context_options())

	fun getItemsFromContext () = let
	  val context = UserContext.get_delta (get_user_context ())
	in
	  Entry.context2entry context
	end

        val title = 
	  if not duplicated then orig_title
	  else 
	    (number_ref := (!number_ref) + 1;
	     orig_title ^ " #" ^ (Int.toString (!number_ref - 1)))

        val (shell,frame,menuBar,contextLabel) =
          Capi.make_main_window 
		{name = "browser",
		 title = title,
		 parent = applicationShell,
		 contextLabel = full_menus, 
		 winMenu = duplicated,
		 pos = getOpt (!posRef, Capi.getNextWindowPos())}

	val listLabel = Capi.make_managed_widget ("listLabel",Capi.Label,frame,[])
	val selectionLabel =
          Capi.make_managed_widget ("selectionLabel",Capi.Label,frame,[])

	fun get_context () = UserContext.get_context (get_user_context ())

        fun set_context_label motif_context =
	  case contextLabel
	  of SOME w =>
            let
              val context_name =
	        GuiUtils.get_context_name motif_context

              val string = "Context: " ^ context_name
            in
              Capi.set_label_string (w,string)
            end
	  |  NONE => ()

	fun get_user_options () = user_options

	local 
          val browse_options = Entry.new_options ()
          val Entry.BROWSE_OPTIONS 
            {show_vars,
             show_cons,
             show_exns,
             show_types,
             show_strs,
             show_sigs,
             show_funs,
             show_conenvs} = browse_options
        in
	  val filter_entries = 
            Entry.filter_entries browse_options


	  fun getter r () = !r
	  fun setter r b = (r := b; true)
	  fun toggle (s,r) = Menus.OPTTOGGLE(s,getter r, setter r)
	      
	  val filter_spec =
	    [toggle ("show_sigs", show_sigs),
	     toggle ("show_funs", show_funs),
	     toggle ("show_strs", show_strs),
	     toggle ("show_types", show_types),
	     toggle ("show_conenvs", show_conenvs),
	     toggle ("show_exns", show_exns),
	     toggle ("show_cons", show_cons),
	     toggle ("show_vars", show_vars)]
	end (* local *)


        (* graph display *)

        datatype Node = ROOT | NODE of Entry.Entry

        fun print_node item =
          let
            val compilerOptions = get_compiler_options()
          in
            case item of
              ROOT => "Top Level"
            | NODE entry => Entry.printEntry compilerOptions entry
          end

        val baseline_height = 3
        fun max (x,y) = if x > y then x else y

        datatype Item = ITEM of Node * Node list * (string * int * int * int) option ref

        fun get_item_data (ITEM (entry,selection,extents),gp) =
          case !extents of
            SOME data => data
          | _ =>
              let
                val s = print_node entry
                val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
                val data = (s,font_ascent,font_descent,width)
              in
                extents := SOME data;
                data
              end

        fun entry_draw_item (item,selected,gp,Capi.POINT{x,y}) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
            fun doit () = 
              ((* Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                       x-left-1,
                                                       y-font_ascent-baseline_height-1,
                                                       left+right+4,
                                                       font_ascent + font_descent + 4); *)
               Capi.GraphicsPorts.draw_image_string
               (gp,s,Capi.POINT{x=x - left, y=y - baseline_height}))
          in
            if selected 
              then Capi.GraphicsPorts.with_highlighting (gp,doit, ())
            else doit ()
          end

        fun entry_extent (item,gp) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in
            GraphWidget.EXTENT{
               left  = left,
               right = right+2,
               up    = baseline_height + font_ascent+1,
               down  = max (0,font_descent+3-baseline_height)
            }
          end
    
        fun make_context_graph () =
          let
            fun entryfun selection entry = ITEM (NODE entry,selection,ref NONE)
            fun top_entry entry = ITEM (NODE entry, [], ref NONE)
            fun toplevel_items () = map top_entry (filter_entries (getItemsFromContext ()))
            fun get_children (ITEM (ROOT,_,_)) = toplevel_items ()
              | get_children (ITEM (node as NODE entry,selection,_)) = 
                map (entryfun (node :: selection)) (filter_entries (Entry.browse_entry true entry))
            fun get_node (ITEM (node,_,_)) = node
            val nodes_ref = ref []
            val iref = ref 0
            fun do_node item =
              let
                val node = get_node item
                val children = get_children item
                val index = !iref
                val children_ref = ref []
                val _ = nodes_ref := (item,children_ref) :: !nodes_ref
                val _ = iref := 1 + !iref
                val children_ids = map do_node (get_children item)
              in
                children_ref := children_ids;
                index
              end
            val _ = do_node (ITEM (ROOT,[],ref NONE))
            val nodes =
              MLWorks.Internal.Array.arrayoflist
              (rev (map (fn (node,ref children) => (node,children)) (!nodes_ref)))
          in
            (nodes,[0])
          end

            
        val graph_spec =
          GraphWidget.GRAPH_SPEC {child_position = ref GraphWidget.BELOW,
                                  child_expansion = ref GraphWidget.TOGGLE,
                                  default_visibility = ref false,
				  show_root_children = ref true,
                                  indicateHiddenChildren = ref false,
                                  orientation = ref GraphWidget.HORIZONTAL,
                                  line_style = ref GraphWidget.STEP,
                                  horizontal_delta = ref 20,
                                  vertical_delta = ref 1,
				  graph_origin = ref (3,3),
                                  show_all = ref false}

        val {widget=graph_window,
             initialize=init_graph,
             update=update_graph,
             set_position, 
             initialiseSearch,
             ...} = 
         GraphWidget.make ("browserGraph","BrowserGraph",title,
                            frame,
                            graph_spec,
                            make_context_graph,
                            entry_draw_item,
                            entry_extent)


(*

        val {reposition_fn,
             h_position,
             v_position,
             h_offset,
	     v_offset,...
            } = GraphWidget.reposition_graph_selection(graph_window,set_position)

        (* Default values *)
        val _ = (h_position := GraphWidget.NONE;
                 v_position := GraphWidget.NONE;
                 h_offset := 20;
                 v_offset := 20)
*)

	val selectionStr = ref ""
        val selectionLength = ref 0
        val shortSelectionStr = ref "" (* this should be the type or val
                                          name, e.g. `option' rather than
                                          `Option.option'.  Also, no
                                          `<type>' postfix *)

        fun removePostfix s = (* change "array<type>" into "array" *)
          let
            fun f [] = []
              | f (#"<" :: t) = []
              | f (h::t) = h::(f t)
          in
            implode (f (explode s))
          end

        fun getShortName ROOT = ""
          | getShortName (NODE entry) = removePostfix (#1(Entry.get_id entry))

        val do_select_fn = ref (fn () => ())

        fun graph_select_fn (item as ITEM (node,selection,_),reg) =
          let
            fun node_string (ROOT) = "ROOT"
              | node_string (NODE entry) = #1 (Entry.get_id entry)
            fun printit (node,[]) = node_string node
              | printit (node,node'::selection) =
                case node' of
                  ROOT => printit (node,selection)
                | NODE(entry) =>
                    if Entry.is_tip(entry)
		    then printit(node,selection)
		    else node_string node' ^ "." ^ printit (node,selection)
            val string = printit (node,rev selection)
            val shortString = getShortName node
          in
(*
            reposition_fn(reg);
*)
            (*Capi.Text.replace (selectionText, 0, !selectionLength, string);*)
            Capi.set_label_string (selectionLabel, "Selection: "^string);
            (*reset_selectionText();*)
            selectionLength := size string;
            selectionStr := string;
            shortSelectionStr := shortString;
            (* For the inspector *)
            (!do_select_fn) ()
          end

        fun initialize_graph () = init_graph graph_select_fn

	val filter_popup =
          #1 (Menus.create_dialog
	      (shell, "Browser Settings", "browserDialog",
	       update_graph, filter_spec))

	val quit_funs = ref []
	  
	fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

        val update_register_key =
          ref (UserContext.add_update_fn
		 (get_user_context (), fn _ => update_graph ()))

        fun with_no_context browser_ref f arg1 arg2 =
            let 
              val browser = !browser_ref
              val user_context = GuiUtils.get_user_context (!local_context)
            in
              browser_ref := NONE;
              UserContext.remove_update_fn
                (user_context, !update_register_key);
              ignore(f arg1 arg2 
                     handle exn => (browser_ref := browser; 
                                    update_register_key :=
                                      UserContext.add_update_fn
                                        (user_context, fn _ => update_graph ());
                                    raise exn));
              browser_ref := browser;
              update_register_key :=
                UserContext.add_update_fn
                  (user_context, fn _ => update_graph ())
            end

	fun set_context c =
	  let
	    val old_user_context = GuiUtils.get_user_context (!local_context)
	    val new_user_context = GuiUtils.get_user_context c
	  in
	    local_context := c;
	    set_context_label c;
            UserContext.remove_update_fn
              (old_user_context, !update_register_key);

            update_register_key :=
              UserContext.add_update_fn
		(new_user_context, fn _ => update_graph ());
            update_graph ()
	  end
  
	val context_key =
	  ToolData.add_context_fn
	  (current_context, (set_context, get_user_options, ToolData.ALL))
	  
	val _ =
	  quit_funs :=
	  (fn _ =>
	   let
	     val user_context = GuiUtils.get_user_context (!local_context)
	   in
	     ToolData.remove_context_fn
	       (current_context, context_key);
             UserContext.remove_update_fn
               (user_context, !update_register_key)
	   end)
	  :: (fn _ => (browser_ref := NONE))
	  :: !quit_funs

        fun select_context user_context =
          (set_context user_context;
           ToolData.set_current
	   (current_context, context_key, user_options, user_context))

        fun close_window _ =
          (do_quit_funs ();
           Capi.destroy shell)

        fun mk_tooldata () =
	  let
	    val user_options = UserOptions.copy_user_tool_options user_options
	  in
            case user_options
            of UserOptions.USER_TOOL_OPTIONS
                 ({set_selection, sense_selection, set_context, sense_context, ...},
                  _) =>
              (set_selection := true;
  	       sense_selection := true;
               set_context := true;
               sense_context := true);
            ToolData.TOOLDATA
              {args = ShellTypes.LISTENER_ARGS
                        {user_options = user_options,
		         user_preferences = user_preferences,
                         user_context =
			   user_context,
			   (*  We used to get the user context from the
		               current motif context, but now that we've 
			       hidden contexts from users we no longer wish
			       to do this.
			   GuiUtils.get_user_context (!local_context),
			   *)
                         prompter = prompter,
                         mk_xinterface_fn = mk_xinterface_fn},
               appdata = appdata,
               current_context = current_context,
	       motif_context = (* !local_context, *)
	         ToolData.get_current current_context,
               tools = tools}
	    end

	val sep_size = 10

        val view_menu =
          GuiUtils.view_options
            {parent = shell, title = title, user_options = user_options,
	     user_preferences = user_preferences,
	     caller_update_fn = fn (_) => (),
	     view_type = [GuiUtils.SENSITIVITY]}

        fun get_current_value () =
          if !selectionStr = ""
            then NONE
          else
            SOME 
            (!selectionStr,
             ShellUtils.eval
             Info.null_options
             (!selectionStr,
              (ShellTypes.new_options (user_options, user_context)),
              UserContext.get_context user_context))
            handle _ => NONE
          
        val inspect_fn = InspectorTool.inspect_value (shell,false, mk_tooldata())
          
        val _ =
          do_select_fn :=
          (fn _ =>
           case get_current_value () of
             NONE => ()
           | SOME x => inspect_fn true x)

	fun duplicate () = create_internal (ref NONE, number_ref, true) (tooldata, orig_title)

	val value_menu = 
	  GuiUtils.value_menu
	     {parent = shell,
              user_preferences = user_preferences, 
              inspect_fn = SOME (inspect_fn false),
              get_value = get_current_value,
	      enabled = not (UserContext.is_const_context 
				(GuiUtils.get_user_context (!local_context))),
	      tail = []}
	val values = ToolData.extract value_menu
	val view = ToolData.extract view_menu

        val search = 
          let
            (* Function to check for substrings, used in the graph search *)
            (* This function also appears in gui._comp_manager, it would
               be nice to have in the utils directory.  *)
            fun isSubstring (s1, s2) =
              let
                val l1 = explode s1   val l2 = explode s2
                fun isSub l =
                     let
                       fun isPre ([], _) = true
                         | isPre (l, []) = false
                         | isPre ((h1::t1), (h2::t2)) =
                             (h1=h2) andalso (isPre (t1, t2))
                     in
                       (isPre (l1, l)) orelse
                       (case l of (h::t) => isSub t | _ => false)
                     end
              in
                isSub l2
              end

            fun getDefault () = (!shortSelectionStr)
            fun matchWeak string (ITEM(entry,_,_))  = 
                  isSubstring(string, getShortName entry)
            fun matchStrong string (ITEM(entry,_,_))  = 
                  string = getShortName entry
          in
            initialiseSearch getDefault (matchStrong, matchWeak)
          end

        val menuSpec =
          [ToolData.file_menu [("save", fn _ =>
		       GuiUtils.save_history (false, get_user_context (), applicationShell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), applicationShell),
		       fn _ => not (UserContext.null_history (get_user_context ()))),
	    ("close", close_window, fn _ => true)],
           ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME (fn _ => Capi.clipboard_set (shell,!selectionStr)),
             delete = NONE,
             selection_made = fn _ => !selectionStr <> "",
	     edit_possible = fn _ => false,
	     delete_all = NONE,
	     edit_source = [value_menu]}),
	   ToolData.tools_menu (mk_tooldata, fn () => user_context),
	   ToolData.usage_menu (("filter", filter_popup, fn _ => true) :: 
				("duplicate", duplicate, fn _ => true) ::
                                ("search", search, fn _ => true) ::
                                values @@ view, []),
	   ToolData.debug_menu values]

	fun storeSizePos () = 
	  (sizeRef := SOME (Capi.widget_size shell);
	   posRef := SOME (Capi.widget_pos shell))

      in
        SaveImage.add_with_fn (with_no_context browser_ref);
	browser_ref := SOME shell;
        quit_funs := Menus.quit :: (!quit_funs);
        quit_funs := storeSizePos :: (!quit_funs);
        Menus.make_submenus (menuBar,menuSpec);
        Capi.Layout.lay_out
        (frame, !sizeRef,
         [Capi.Layout.MENUBAR menuBar] @@
         (case contextLabel of
            SOME w => [Capi.Layout.FIXED w]
          | _ => [Capi.Layout.SPACE]) @@
         [Capi.Layout.FIXED selectionLabel,
          Capi.Layout.SPACE,
          Capi.Layout.FIXED listLabel,
          Capi.Layout.FLEX graph_window,
          Capi.Layout.SPACE]);
	Capi.set_close_callback(frame, close_window);
        Capi.Callback.add (frame, Capi.Callback.Destroy, do_quit_funs);
        set_context_label (!local_context);
        Capi.initialize_toplevel shell;
        initialize_graph ()
      end

    fun create_initial
	  (ToolData.TOOLDATA
	     {args = ShellTypes.LISTENER_ARGS
		{user_context, user_options, user_preferences, prompter,
		 mk_xinterface_fn},
	      appdata, tools, motif_context, current_context, ...}) =
      let
	val initial = GuiUtils.getInitialContext ()
      in
	case user_options
	of UserOptions.USER_TOOL_OPTIONS
	     ({set_selection, sense_selection, set_context, sense_context, ...},
	      _) =>
	  (set_selection := false;
	   sense_selection := false;
	   set_context := false;
	   sense_context := false);

	if isSome (!system_browser) then 
	  Capi.to_front (valOf (!system_browser))
	else
          create_internal (system_browser, system_number, false)
	    (* We have hidden contexts from the user, so we want to pass through
	       the user's context to the tooldata. *)
	    (ToolData.TOOLDATA
             {args =
		ShellTypes.LISTENER_ARGS
		  {user_context = user_context, (* GuiUtils.get_user_context initial, *)
		   user_preferences = user_preferences,
		   user_options = user_options,
		   prompter = prompter,
		   mk_xinterface_fn = mk_xinterface_fn},
	      appdata = appdata,
	      motif_context = initial,
	      current_context = current_context, (* ToolData.make_current (initial), *)
	      tools = tools},
             initial_title ())
      end

    fun create tooldata =
      if isSome (!context_browser) then 
	Capi.to_front (valOf (!context_browser))
      else
        create_internal (context_browser, context_number, false) (tooldata,title())

  end


@


1.59.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.59  1998/03/31  15:15:52  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos.
 *
@


1.58
log
@[Bug #50061]
Fix tools so they restart in a saved image
@
text
@d4 4
d556 1
a556 1
		 pos = getOpt (!posRef, (100,100))}
@


1.57
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d4 4
d419 1
d439 1
d505 1
d811 20
d840 1
d1015 1
d1084 2
@


1.56
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d490 3
d539 7
a545 1
          Capi.make_main_window ("browser",title,applicationShell,full_menus, duplicated)
d982 4
d989 1
d992 1
a992 1
        (frame,
@


1.55
log
@[Bug #30241]
Implement proper find dialog.
@
text
@d4 11
d967 1
a967 2
	   ToolData.debug_menu values,
	   GuiUtils.paths_menu shell]
@


1.55.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.55  1997/09/05  09:49:58  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.55.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a3 3
 * Revision 1.55.2.1  1997/09/11  20:52:25  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d960 2
a961 1
	   ToolData.debug_menu values]
@


1.55.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.55  1997/09/05  09:49:58  johnh
 * [Bug #30241]
 * Implement proper find dialog.
 *
@


1.54
log
@[Bug #30224]
Add search facility.
(And change `selection' from text entry box to a text label).
@
text
@d4 5
d928 1
a928 3
            initialiseSearch getDefault
                             [(matchStrong, "match_whole"),
                              (matchWeak, "match_part")]
@


1.53
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d4 4
d519 2
a520 8
	val selectionLabel = Capi.make_managed_widget ("selectionLabel",Capi.Label,frame,[])
	val selectionText = Capi.make_managed_widget ("selectionText",Capi.Text,frame,[])

        fun reset_selectionText() =
            Capi.Text.set_insertion_position(selectionText,0)
            (* selectionText insertion point set to 0 - otherwise get
               funny behaviour if the Browser is resized.
             *)  
d673 1
d684 3
a686 1
             set_position,...} =  
d713 16
d745 1
d750 3
a752 2
            Capi.Text.replace (selectionText, 0, !selectionLength, string);
            reset_selectionText();
d755 1
a849 2
        fun get_string_nm () = Capi.Text.get_string selectionText

d895 33
d951 2
a952 1
		values @@ view, []),
d967 1
a967 1
          Capi.Layout.FIXED selectionText,
@


1.52
log
@[Bug #30075]
Duplicating tool by cloning only.
@
text
@d4 4
d512 1
a512 1
          Capi.make_main_window ("browser",title,applicationShell,full_menus)
d902 1
a902 2
	   GuiUtils.paths_menu shell,
	   ToolData.windows_menu ()]
@


1.51
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d4 4
d448 2
a449 20
    local
      val browser_number = ref 1
      val initial_browser_number = ref 1
    in
      fun title ()= 
        let
          val n = !browser_number
        in
          browser_number := n + 1;
          "Browser #" ^ (Int.toString n)
        end (* title *)

      fun initial_title ()= 
        let
          val n = !initial_browser_number
        in
          initial_browser_number := n + 1;
          "System Browser #" ^ (Int.toString n)
        end (* title *)
    end
d451 18
a468 2
    (* create : ToolData -> unit *)
    fun create_internal (tooldata,title) =
d500 7
a506 1
      
d781 1
d859 2
d894 2
a895 1
	   ToolData.usage_menu (("filter", filter_popup, fn _ => true) ::
d902 1
d941 8
a948 5
        create_internal
	  (* We have hidden contexts from the user, so we want to pass through
	     the user's context to the tooldata. *)
	  (ToolData.TOOLDATA
           {args =
d959 1
a959 1
           initial_title ())
d961 6
a966 2
    fun create (tooldata) =
      create_internal (tooldata,title())
@


1.50
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d821 1
a821 1
        val view_options =
a827 7
        val view_menu =
          Menus.CASCADE
            ("view",
             view_options
             @@ [Menus.PUSH ("filter", filter_popup, fn _ => true)],
             fn _ => true)

d849 12
a860 6
            
	val file_menu =
	  Menus.CASCADE
	    ("file",
	     [Menus.PUSH ("close", close_window, fn _ => true)],
	     fn _ => true)
d863 9
a871 1
          [file_menu,
d880 9
a888 15
	     tail = []}),
           view_menu]
	  @@ (if UserContext.is_const_context
		  (GuiUtils.get_user_context (!local_context)) then
	       [ToolData.tools_menu (mk_tooldata, fn () => user_context),
	        ToolData.windows_menu ()]
	     else
               [GuiUtils.value_menu
		  {parent = shell,
                   user_preferences = user_preferences, 
                   inspect_fn = SOME (inspect_fn false),
                   get_value = get_current_value,
		   tail = []},
	        ToolData.tools_menu (mk_tooldata, fn () => user_context),
                ToolData.windows_menu ()])
d890 1
a891 1

@


1.49
log
@Removing debugger argument from eval.
@
text
@d4 3
a430 1
    structure Option = MLWorks.Option
d512 1
a512 1
	  of Option.SOME w =>
d521 1
a521 1
	  |  Option.NONE => ()
d573 1
a573 1
        datatype Item = ITEM of Node * Node list * (string * int * int * int) Option.option ref
d577 1
a577 1
            Option.SOME data => data
d584 1
a584 1
                extents := Option.SOME data;
d623 2
a624 2
            fun entryfun selection entry = ITEM (NODE entry,selection,ref Option.NONE)
            fun top_entry entry = ITEM (NODE entry, [], ref Option.NONE)
d645 1
a645 1
            val _ = do_node (ITEM (ROOT,[],ref Option.NONE))
d833 1
a833 1
            then Option.NONE
d835 1
a835 1
            MLWorks.Option.SOME 
d842 1
a842 1
            handle _ => Option.NONE
d850 2
a851 2
             Option.NONE => ()
           | Option.SOME x => inspect_fn true x)
d863 4
a866 4
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME (fn _ => Capi.clipboard_set (shell,!selectionStr)),
             delete = Option.NONE,
d879 1
a879 1
                   inspect_fn = Option.SOME (inspect_fn false),
d891 1
a891 1
            Option.SOME w => [Capi.Layout.FIXED w]
@


1.49.1.1
log
@branched from 1.49
@
text
@a3 3
 * Revision 1.49  1997/03/19  13:18:22  matthew
 * Removing debugger argument from eval.
 *
@


1.49.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.49.1.1  1997/05/12  10:31:39  hope
 * branched from 1.49
 *
@


1.49.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.49.1.1  1997/05/12  10:31:39  hope
 * branched from 1.49
 *
@


1.49.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.49.1.1  1997/05/12  10:31:39  hope
 * branched from 1.49
 *
@


1.49.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 3
 * Revision 1.49.1.1.1.1  1997/07/28  18:17:33  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.48
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d839 1
a839 2
              UserContext.get_context user_context,
              fn f => fn a => f a))
@


1.48.5.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.4.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.4.1.1.1
log
@branched from 1.48.4.1
@
text
@a3 3
 * Revision 1.48.4.1  1996/12/17  17:45:20  hope
 * branched from 1.48
 *
@


1.48.3.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.2.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 4
 * Revision 1.48  1996/11/06  11:15:37  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.48.1.1.1.1
log
@branched from 1.48.1.1
@
text
@a3 3
 * Revision 1.48.1.1  1996/11/14  12:46:19  hope
 * branched from 1.48
 *
@


1.47
log
@Enabling close from control box on top left of window.
@
text
@d4 3
d363 1
a363 1
require "../basis/__integer";
@


1.46
log
@Option dialog setter functions now return accept/reject.
@
text
@d4 3
d890 1
@


1.46.3.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/08/09  15:25:45  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.46.2.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/08/09  15:25:45  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 3
 * Revision 1.46  1996/08/09  15:25:45  nickb
 * Option dialog setter functions now return accept/reject.
 *
@


1.45
log
@[Bug #1521]
propagating changes to typechecker/_types.sml
@
text
@d4 4
d528 5
d534 8
a541 17
	    [Menus.OPTTOGGLE
	       ("show_sigs", fn () => !show_sigs, fn b => show_sigs := b),
	     Menus.OPTTOGGLE
	       ("show_funs", fn () => !show_funs, fn b => show_funs := b),
	     Menus.OPTTOGGLE
	       ("show_strs", fn () => !show_strs, fn b => show_strs := b),
	     Menus.OPTTOGGLE
	       ("show_types", fn () => !show_types, fn b => show_types := b),
	     Menus.OPTTOGGLE
	       ("show_conenvs", fn () => !show_conenvs,
		fn b => show_conenvs := b),
	     Menus.OPTTOGGLE
	       ("show_exns", fn () => !show_exns, fn b => show_exns := b),
	     Menus.OPTTOGGLE
	       ("show_cons", fn () => !show_cons, fn b => show_cons := b),
	     Menus.OPTTOGGLE
	       ("show_vars", fn () => !show_vars, fn b => show_vars := b)]
@


1.44
log
@Removing call to reposition function as this is no longer used.
@
text
@d4 3
d386 1
a386 1
  sharing type Entry.PrintOptions = UserOptions.Options.print_options
d399 2
a400 1
	       ToolData.UserContext.user_context_options
d466 7
d551 1
a551 1
            val printOptions = Options.default_print_options
d555 1
a555 1
            | NODE entry => Entry.printEntry printOptions entry
@


1.43
log
@Changed GraphWidget.make
@
text
@d4 3
d655 1
d669 1
d690 1
d692 1
@


1.42
log
@Removed unused debugging code (that referenced MLWorks.RawIO).
@
text
@d4 3
d434 1
a434 1
          "Pervasives Browser #" ^ (Int.toString n)
d643 3
a645 2
             set_position,...} = 
          GraphWidget.make ("browserGraph","BrowserGraph",frame,
@


1.41
log
@Changes in Graph controls.
@
text
@d4 3
a412 23

(*  Debug tools

    local
       structure IO = MLWorks.RawIO 

       val std_out = IO.std_out
       val output  = IO.output

       structure Value = MLWorks.Internal.Value
       val DEFAULT = Value.DEFAULT
       val print = Value.print
    in
       fun debugP s v =
	   ( output(std_out, s);
	     print(DEFAULT,std_out,v);
	     output(std_out, "\n");
	     v
	   )
    end

    fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")
*)
@


1.40
log
@Added File menu.
@
text
@d4 3
a659 1
             popup_menu=graph_menu,
a669 1
             popup_fn=seln_popup_fn,
d714 1
a714 1
	      (shell, "Context Browser Settings", "browserDialog",
a716 2
	val seln_posn_popup = seln_popup_fn(shell)
	  	      
d808 1
a808 1
	     view_type = GuiUtils.SENSE_ONLY}
d814 1
a814 3
             @@ [Menus.PUSH ("filter", filter_popup, fn _ => true),
	        Menus.PUSH ("graph", graph_menu, fn _ => true),
                Menus.PUSH ("graph_seln_posn", seln_posn_popup, fn _ => true)],
@


1.39
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d4 3
d843 6
d850 1
a850 3
          [ToolData.works_menu
            (mk_tooldata, close_window, fn () => true,
             fn () => user_context (* GuiUtils.get_user_context (!local_context) *) ),
d861 4
a864 2
	  @@ (if UserContext.is_const_context (GuiUtils.get_user_context (!local_context)) 
               then [ToolData.windows_menu ()]
d872 1
@


1.38
log
@Array moving to MLWorks.Array
@
text
@d4 3
d851 1
@


1.37
log
@Replacing MLWorks.Integer with basis file
@
text
@d4 3
d629 1
a629 1
              Array.arrayoflist
@


1.36
log
@Pervasive browser title numbers are knackered.
@
text
@d4 3
d329 2
d431 1
a431 1
          "Browser #" ^ (MLWorks.Integer.makestring n)
d439 1
a439 1
          "Pervasives Browser #" ^ (MLWorks.Integer.makestring n)
@


1.35
log
@Changing graph interface
@
text
@d4 3
d431 1
a431 1
          val n = !browser_number
@


1.34
log
@UserContext.add_update_function now expects update functions that take
a list of history entries.
Removed the sensitivity type.
@
text
@d4 5
d626 2
a627 2
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.BELOW,
                                  child_expansion = GraphWidget.TOGGLE,
d629 7
a635 7
				  show_root_children = true,
                                  orientation = GraphWidget.HORIZONTAL,
                                  line_style = GraphWidget.STEP,
                                  horizontal_delta = 20,
                                  vertical_delta = 1,
				  graph_origin = (3,3),
                                  show_all = false}
@


1.33
log
@Changed interface to graph widget
@
text
@d4 3
a351 1
	       ToolData.UserContext.user_tool_options =
d452 1
a452 1
	  val context = #2(UserContext.get_context_info (get_user_context ()))
d701 2
a702 1
          ref (UserContext.add_update_fn (get_user_context (), update_graph))
d714 2
a715 1
              UserContext.add_update_fn (new_user_context, update_graph);
a786 6
	     sensitivity =
	       if UserContext.is_const_context 
		    (GuiUtils.get_user_context (!local_context)) then
		 GuiUtils.CONTEXT_ONLY	(* Produces an empty list *)
	       else
	         GuiUtils.NO_SET_SELECTION,
@


1.32
log
@Type of GuiUtils.value_menu has changed.
@
text
@d4 3
d552 1
a552 1
        fun entry_draw_item (item,gp,Capi.POINT{x,y}) =
d557 12
a568 10
          in 
(*
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                    x-left-1,
                                                    y-font_ascent-baseline_height-1,
                                                    left+right+4,
                                                    font_ascent + font_descent + 4);
*)
            Capi.GraphicsPorts.draw_image_string
                 (gp,s,Capi.POINT{x=x - left, y=y - baseline_height})
@


1.31
log
@Using Info.null_options in call to eval
@
text
@d4 3
d828 2
a829 1
             selection_made = fn _ => !selectionStr <> ""}),
d834 6
a839 4
               [GuiUtils.value_menu (shell,
                                     user_preferences, 
                                     Option.SOME (inspect_fn false),
                                     get_current_value),
@


1.30
log
@Changing inspector interface.
@
text
@d4 3
d799 1
a799 1
             Info.default_options
@


1.29
log
@Reordering top level menus.
@
text
@d4 3
d344 1
a344 1
               GraphWidget.Widget
d649 2
d669 3
a671 1
            selectionStr := string
d794 2
a795 1
            (ShellUtils.eval
d801 1
d803 1
a803 4
        fun inspect_fn () = 
          case get_current_value () of
            Option.SOME x => InspectorTool.inspect_value false (!selectionStr, x, mk_tooldata())
          | _ => ()
d805 7
d829 1
a829 1
                                     Option.SOME inspect_fn,
@


1.28
log
@Make pervasive and non-pervasive browsers have different titles.
@
text
@d4 3
d311 1
d325 1
d353 1
d357 1
d363 2
d368 1
a368 1
    type ShellData = ToolData.ShellTypes.ShellData
d404 1
a404 1
          "Context Browser #" ^ (MLWorks.Integer.makestring n)
d421 1
a421 1
	val ToolData.ShellTypes.LISTENER_ARGS
d637 5
a641 6
        val _ = (
		   h_position := GraphWidget.CENTER;
		   v_position := GraphWidget.CENTER;
		   h_offset := 20;
		   v_offset := 20
                )
d736 1
a736 1
              {args = ToolData.ShellTypes.LISTENER_ARGS
d782 17
a802 1
           ToolData.windows_menu (),
d811 2
a812 3
	  @@ (if UserContext.is_const_context
		  (GuiUtils.get_user_context (!local_context)) then
	       []
d814 5
a818 3
               [GuiUtils.value_menu_strfun
                  (shell, GuiUtils.get_user_context (!local_context),
                   user_options, user_preferences, get_string_nm)])
d841 1
a841 1
	     {args = ToolData.ShellTypes.LISTENER_ARGS
d862 1
a862 1
		ToolData.ShellTypes.LISTENER_ARGS
@


1.27
log
@Changing interface to edit_menu
@
text
@d4 3
d386 20
a405 1
    val browser_number = ref 1
d408 1
a408 2
    fun create (tooldata as ToolData.TOOLDATA
		{args,appdata,current_context,motif_context,tools}) =
d410 2
a423 8
        val title = 
          let
            val n = !browser_number
          in
            browser_number := n + 1;
            "Context Browser #" ^ (MLWorks.Integer.makestring n)
          end (* title *)

d832 1
a832 1
        create
d836 1
a836 1
	     {args =
d846 2
a847 1
	      tools = tools})
d849 3
@


1.26
log
@Changin layout parameters
@
text
@d4 3
d765 6
a770 3
           {paste = Option.NONE,
            copy = Option.SOME (fn _ => !selectionStr),
            delete = Option.NONE},
@


1.25
log
@Changing button resources
@
text
@d4 3
d785 1
a785 1
          Capi.Layout.FIXED graph_window,
@


1.24
log
@Adding windows menu
@
text
@d4 3
d417 2
a418 2
	val pathLabel = Capi.make_managed_widget ("pathLabel",Capi.Label,frame,[])
	val pathText = Capi.make_managed_widget ("pathText",Capi.Text,frame,[])
d420 3
a422 3
        fun reset_pathText() =
            Capi.Text.set_insertion_position(pathText,0)
            (* pathText insertion point set to 0 - otherwise get
d497 1
a497 1
        fun get_item_data (ITEM (entry,path,extents),gp) =
d543 1
a543 1
            fun entryfun path entry = ITEM (NODE entry,path,ref Option.NONE)
d547 2
a548 2
              | get_children (ITEM (node as NODE entry,path,_)) = 
                map (entryfun (node :: path)) (filter_entries (Entry.browse_entry true entry))
d614 2
a615 2
	val pathStr = ref ""
        val pathLength = ref 0
d617 1
a617 1
        fun graph_select_fn (item as ITEM (node,path,_),reg) =
d622 1
a622 1
              | printit (node,node'::path) =
d624 1
a624 1
                  ROOT => printit (node,path)
d627 3
a629 3
		    then printit(node,path)
		    else node_string node' ^ "." ^ printit (node,path)
            val string = printit (node,rev path)
d632 4
a635 4
            Capi.Text.replace (pathText, 0, !pathLength, string);
            reset_pathText();
            pathLength := size string;
            pathStr := string
d727 1
a727 1
        fun get_string_nm () = Capi.Text.get_string pathText
d760 1
a760 1
            copy = Option.SOME (fn _ => !pathStr),
d779 2
a780 2
         [Capi.Layout.FIXED pathLabel,
          Capi.Layout.FIXED pathText,
@


1.23
log
@Removed context menu, because the search tool wasn't linked to anything.
@
text
@d4 3
d754 6
a759 1
          view_menu]
@


1.22
log
@Browser now recognises updates to the context.
@
text
@d4 3
a758 8
          @@ [GuiUtils.context_menu
               {set_state = select_context,
                get_context = fn () => !local_context,
                writable = GuiUtils.ALL,
                applicationShell = applicationShell,
	        shell = shell,
	        search_opt = MLWorks.Option.SOME (fn x => (), false),
                user_preferences = user_preferences}]
@


1.21
log
@Made modifications due to introduction of GraphWidget.Extent etc.
@
text
@d4 3
d396 2
d399 1
a399 2
	  val context = #2(UserContext.get_context_info
			   (GuiUtils.get_user_context (!local_context)))
d417 1
a417 3
	fun get_context () =
	  UserContext.get_context
	    (GuiUtils.get_user_context (!local_context))
d642 3
d652 4
d670 3
a672 1
	     (current_context, context_key)
@


1.20
log
@Modifications due to changes in GraphSpec.
@
text
@d4 3
d499 1
a499 1
        fun entry_draw_item (item,gp,x,y) =
d522 6
a527 4
            (left,
             right+2,
             baseline_height + font_ascent+1,
             max (0,font_descent+3-baseline_height))
d566 1
d587 15
a601 2
        val {reposition_fn,popup_fn=seln_popup_fn,...} =
            GraphWidget.reposition_graph_selection(graph_window,set_position)
@


1.19
log
@Now that we have hidden contexts from the user, the pervasive browser has
to be treated somewhat specially.
@
text
@d4 4
d560 2
d566 1
@


1.18
log
@Updates to allow for changed graph widget repositioning interface.
@
text
@d4 3
d365 1
a365 1
	      {user_options, user_preferences,
d649 31
a679 12
          ToolData.TOOLDATA
            {args = ToolData.ShellTypes.LISTENER_ARGS
                      {user_options = user_options,
		       user_preferences = user_preferences,
                       user_context =
			 GuiUtils.get_user_context (!local_context),
                       prompter = prompter,
                       mk_xinterface_fn = mk_xinterface_fn},
             appdata = appdata,
             current_context = current_context,
	     motif_context = !local_context,
             tools = tools}
d690 6
a695 1
	     sensitivity = GuiUtils.NO_SET_SELECTION,
d709 18
a726 14
          (mk_tooldata, close_window, fn () => true,
           fn () => GuiUtils.get_user_context (!local_context)),
          view_menu,
          GuiUtils.value_menu_strfun
          (shell, GuiUtils.get_user_context (!local_context),
           user_options, user_preferences, get_string_nm),
          GuiUtils.context_menu
          {set_state = select_context,
           get_context = fn () => !local_context,
           writable = GuiUtils.ALL,
           applicationShell = applicationShell,
	   shell = shell,
	   search_opt =	MLWorks.Option.SOME (fn x => ()),
           user_preferences = user_preferences}]
d752 1
a752 1
	      appdata, tools, ...}) =
d766 2
d771 1
a771 1
		  {user_context = GuiUtils.get_user_context initial,
d778 1
a778 1
	      current_context = ToolData.make_current (initial),
@


1.17
log
@Modification to take account of change to graph_widget change and moved
graph selection stuff from here to graph_widget ...
@
text
@d4 4
d577 1
a577 1
        fun graph_select_fn (item as ITEM (node,path,extents),reg) =
d605 1
a605 1
	val seln_posn_popup = seln_popup_fn(shell,"browserDialog",update_graph)
d677 1
a677 1
                Menus.PUSH ("selection position", seln_posn_popup, fn _ => true)],
@


1.16
log
@Adding graphical selection repositioning ...
@
text
@d4 3
d555 10
a564 2
	val pathStr = ref ""
        val pathLength = ref 0
a565 2
        val current_graph = ref(shell)
            (* initialise to handy widget - set it up properly later *)
d567 2
a568 1
        val set_posn_hook = ref(fn (_) => ())
d570 2
a571 75
        local 

           datatype SelectPosn = NONE | TOP | CENTER | BOTTOM | ORIGIN

           val select_position = ref(NONE)

           fun is_none ()      = (!select_position = NONE)
           fun is_top ()       = (!select_position = TOP)
           fun is_center ()    = (!select_position = CENTER)
           fun is_bottom ()    = (!select_position = BOTTOM)
           fun is_origin ()    = (!select_position = ORIGIN)

           fun set_none (b)   = if b then select_position := NONE else ()
           fun set_top (b)    = if b then select_position := TOP else ()
           fun set_center (b) = if b then select_position := CENTER else ()
           fun set_bottom (b) = if b then select_position := BOTTOM else ()
           fun set_origin (b) = if b then select_position := ORIGIN else ()

           val toolbar_width = 15

        in

	   val seln_posn_spec = 
	       [  Menus.OPTRADIO
		  [
		    Menus.OPTTOGGLE ("no policy",  is_none,    set_none),
		    Menus.OPTTOGGLE ("top"      ,  is_top,     set_top),
		    Menus.OPTTOGGLE ("center"   ,  is_center,  set_center),
		    Menus.OPTTOGGLE ("bottom"   ,  is_bottom,  set_bottom),
		    Menus.OPTTOGGLE ("origin"   ,  is_origin,  set_origin)
		  ]
               ]

        fun reposition_graph_selection
              ( Capi.REGION{x,y,width=r_width,height=r_height},w_wid,w_hgt) =
            let val w_wid   = w_wid  - toolbar_width
                val w_hgt   = w_hgt  - toolbar_width
            in
	       case (!select_position) of
		 NONE => ()
	       | TOP => 
		   let val left'  = (w_wid - r_width) div 2
                       val left   = if left' < 10 then 10 else left'
		       val new_x  = x - left
		       val new_y  = y - 10
		   in
		      (!set_posn_hook) (Capi.POINT{x=new_x,y=new_y})
		   end
	       | CENTER => 
		   let val left' = (w_wid - r_width) div 2
                       val left  = if left' < 10 then 10 else left'
		       val top   = (w_hgt - r_height) div 2
		       val new_x = x - left
		       val new_y = y - top
		   in
		      (!set_posn_hook) (Capi.POINT{x=new_x,y=new_y})
		   end
	       | BOTTOM => 
		   let val left' = (w_wid - r_width) div 2
                       val left  = if left' < 10 then 10 else left'
		       val top   = w_hgt - r_height
		       val new_x = x - left
		       val new_y = y - top
		   in
		      (!set_posn_hook) (Capi.POINT{x=new_x,y=new_y})
		   end
	       | ORIGIN => 
		   let val new_x = x - 10
		       val new_y = y - 10
		   in
		      (!set_posn_hook) (Capi.POINT{x=new_x,y=new_y})
		   end
            end

        end
a585 1
            val (width,height) = Capi.widget_size(!current_graph)
d587 1
a587 1
            reposition_graph_selection(reg,width,height);
d594 1
a594 16
        val {widget=graph_window,
             initialize=initialize_graph,
             update=update_graph,
             popup_menu=graph_menu,
             set_position=set_posn,...} = 
          GraphWidget.make ("browserGraph","BrowserGraph",frame,
                            graph_spec,
                            make_context_graph,
                            graph_select_fn,
                            entry_draw_item,
                            entry_extent)

        val _ = (
                  current_graph := graph_window;
		  set_posn_hook := set_posn
                )
d601 1
a601 4
	val seln_posn_popup =
          #1 (Menus.create_dialog
	      (shell, "Selection Position Settings", "browserDialog",
	       update_graph, seln_posn_spec))
@


1.15
log
@Type of context_menu has changed.
@
text
@d4 3
a263 1
require "^.utils.lisp";
d311 2
d324 24
d390 6
d450 3
d555 82
a636 1
        fun graph_select_fn (ITEM (node,path,_)) =
d642 6
a647 1
                node_string node' ^ "." ^ printit (node,path)
d649 1
d651 1
d653 1
d661 2
a662 1
             popup_menu=graph_menu,...} = 
d670 5
a674 2
        val update_display  = update_graph
           
d678 6
a683 1
	       update_display, filter_spec))
d696 1
a696 1
            update_display ()
d753 3
a755 2
             @@ [Menus.PUSH ("filter", filter_popup, fn () => true),
	        Menus.PUSH ("graph", graph_menu, fn _ => true)],
@


1.14
log
@Removing the list pane component and associated parts (e.g. history).
@
text
@d4 3
d379 2
d396 18
a413 93
	  fun map_selected f print_options l =
	    f print_options (filter_entries l)
	    
	  fun get_user_options () = user_options

	  fun get_print_options () =
	    UserOptions.new_print_options (get_user_options ())

	  fun grep regexp line = let
	    fun startsWith [] ys = true
	      | startsWith xs [] = false
	      | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
	    fun check [] ys = false
	      | check xs [] = false
	      | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
	  in
	    check (explode regexp) (explode line)
	  end (* grep *)
	
	  fun collect f xs = let
	    fun collect f acc [] = rev acc
	      | collect f acc (x::xs) =
		if f x then collect f (x::acc) xs
		else collect f acc xs
	  in (* let *)
	    collect f [] xs
	  end (* collect *)

	  val searchOptions = ref
	    {showSig = true,
	     showStr = true,
	     showFun = true,
	     searchInitial = true,
	     showType = true}
	  
	  fun search s = let
	    val context = getItemsFromContext ()
	    val printOptions = get_print_options()
	    (* datatype Entry is a linear structure, munge to tree like form *)
	    val entrys = map Entry.massage context
	    val entrys' = Entry.printEntry1 (!searchOptions) printOptions entrys
	    val entrys' = map implode entrys'
	    (* val _ = map debug_output entrys' *)
	    val found = collect (grep s) entrys'
	    (* val _ = map debug_output found *)
	    val _ = GuiUtils.list_select
	      (shell, "ListSelect Name") (found, fn x=>(), fn x=>x)
	  in
	    ()
	  end (* search *)
	  
	val search_spec =
	  [
	   Menus.OPTLABEL "Search inside...",
	   Menus.OPTSEPARATOR,
	   Menus.OPTTOGGLE ("signatures", fn ()=> #showSig (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showSig", b, !searchOptions)),
	   Menus.OPTTOGGLE ("structures", fn ()=> #showStr (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showStr", b, !searchOptions)),
	   Menus.OPTTOGGLE ("functors",   fn ()=> #showFun (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showFun", b, !searchOptions)),
	   Menus.OPTSEPARATOR,
	   Menus.OPTTOGGLE ("Display their types", fn ()=> #showType (!searchOptions),
			    fn b=>searchOptions:=Entry.update ("showType", b, !searchOptions)),
	   Menus.OPTSEPARATOR,
	   Menus.OPTTEXT ("Search for Item", fn () => "" , fn s =>search s)
	   ]

	val filter_spec =
	  [Menus.OPTTOGGLE ("show_sigs",
			      fn () => !show_sigs,
			      fn b => show_sigs := b),
	   Menus.OPTTOGGLE ("show_funs",
			    fn () => !show_funs,
			    fn b => show_funs := b),
	   Menus.OPTTOGGLE ("show_strs",
			    fn () => !show_strs,
			    fn b => show_strs := b),
	   Menus.OPTTOGGLE ("show_types",
			    fn () => !show_types,
			    fn b => show_types := b),
	   Menus.OPTTOGGLE ("show_conenvs",
			    fn () => !show_conenvs,
			    fn b => show_conenvs := b),
	   Menus.OPTTOGGLE ("show_exns",
			    fn () => !show_exns,
			    fn b => show_exns := b),
	   Menus.OPTTOGGLE ("show_cons",
			    fn () => !show_cons,
			    fn b => show_cons := b),
	   Menus.OPTTOGGLE ("show_vars",
			    fn () => !show_vars,
			    fn b => show_vars := b)]
d420 1
a420 1
            val printOptions = get_print_options ()
d423 1
a423 1
              ROOT => "Context"
a542 4
	val search_popup =
          #1 (Menus.create_dialog
              (shell, "Search Window", "browserDialog", fn ()=>(), search_spec))

d618 2
a619 1
             @@ [Menus.PUSH ("filter", filter_popup, fn () => true)],
d635 3
a637 5
           user_preferences = user_preferences},
	  Menus.CASCADE
	  ("Search",
	   [Menus.PUSH ("search", search_popup, fn _=> true)],
	   fn _=> true)]
@


1.13
log
@Adding update of list entry by graph selection ...
@
text
@d4 3
d258 1
a311 31
    structure CapiData :
       sig
	  datatype Point = POINT of { x : int, y : int }

	  datatype Region = REGION of { x : int, y :int, width : int, height :int }
       end =
       struct
          open Capi
       end
    open CapiData;

    fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")

    local
       structure IO = MLWorks.RawIO 

       val std_out = IO.std_out
       val output  = IO.output

       structure Value = MLWorks.Internal.Value
       val DEFAULT = Value.DEFAULT
       val print = Value.print
    in
       fun debugP s v =
	   ( output(std_out, s);
	     print(DEFAULT,std_out,v);
	     output(std_out, "\n");
	     v
	   )
    end

a357 1
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, []);
d430 1
a430 2
	
            val entrys = map Entry.massage context
a484 8
      
	(* pathStack records each entry on the path, so that we can go to *)
        (* the parent structure *)
        val pathStack = ref []
	val history = ref []
	val pathLength = ref 0;
	val pathStr = ref ""
	val length_of_last_component = ref 0;
d486 9
a494 61
        fun reset_path_state () =
	  (
            (* resets the state of the selection ... *)
            Capi.Text.set_string (pathText, "");

            pathStack := [];
	    history   := [];
            pathLength := 0;
	    pathStr    := "";
            length_of_last_component := 0	    
          )

	fun add_to_path (str, new_items, false) =
	  (* structures or signatures *)
	  (pathLength := !pathLength + size str;
	   pathStr := !pathStr ^ str;
	   pathStack := (!pathLength, "", new_items) :: (!pathStack))
	  | add_to_path (str, new_items, true) =
            (* datatypes - display of entries overwrites the type name itself *)
            (pathStack := (!pathLength, str, new_items) :: (!pathStack);
             pathStr := !pathStr ^ str)

	fun shorten_path pos =
	  (Capi.Text.replace (pathText, pos, !pathLength, "");
	   pathLength := pos)

        fun select_fn (_,_, set_items) entry =
	  let 
	    val (str, last_component) = Entry.get_id entry
	    val str' =
	      if !pathLength = 0 orelse str = "" then str else "." ^ str
	    val old_str = !pathStr
            val new_items = Entry.browse_entry true entry
	  in
	    (* The behaviour of this function is determined by two values.
	     If last_component is true, the selection is the last component
	     of a long id, and so the path in the selection box should not
	     be extended beyond this point.
	     If in addition new_items is empty, then the list of items should
             not be changed. *)
	    
	    (* Update the selection box. *)
	    Capi.Text.replace
	      (pathText, !pathLength,
	       !pathLength + !length_of_last_component, str');

	    if last_component then
	      length_of_last_component := size str'
	    else
	      length_of_last_component := 0;
	      
	      (* Push the stacks and display the components of the
	       selected entry. *)
	    case (last_component, new_items) of
              (true, []) => ()
	    | _ =>
	      (add_to_path (str', new_items, last_component);
	       ShellUtils.add_history_item
	         ((!pathStr, !pathStack), history,
                  (fn ((s,_),(s',_)) => s = s'), user_preferences);
               map_selected set_items (get_print_options ()) new_items)
d497 4
a500 1
        val set_items_hook = ref(fn(_) => fn(_) => ())
d502 12
a513 1
        val cur_items = ref []
d515 16
a530 2
        fun display_cur_items () =
            map_selected (!set_items_hook) (get_print_options ()) (!cur_items)
d532 43
a574 249
        fun select_path_fn entry_list =
            let
              fun add_entry entry =
		  let 
		    val (str, last_component) = Entry.get_id entry
		    val str' =
		      if !pathLength = 0 orelse str = "" then str else "." ^ str
		    val old_str = !pathStr
		    val new_items = Entry.browse_entry true entry
		  in

		    (* Update the selection box. *)
		    Capi.Text.replace
		      (pathText, !pathLength,
		       !pathLength + !length_of_last_component, str');

		    if last_component then
		      length_of_last_component := size str'
		    else
		      length_of_last_component := 0;

                    (* Set cur_items to the list of new_items *)
                    cur_items := new_items;

		    (* Push the stacks and display the components of the
		       selected entry.
                     *)
		    case (last_component, new_items) of
		      (true, []) => ()
		    | _ =>
		      (add_to_path (str', new_items, last_component);
		       ShellUtils.add_history_item
			 ((!pathStr, !pathStack), history,
			  (fn ((s,_),(s',_)) => s = s'), user_preferences)
                      )
		  end
             in
	       reset_path_state();
               cur_items := [];
               Lists.iterate add_entry entry_list
             end

        val reset_toplevel_hook = ref(fn () => ())
        val select_entry_hook = ref(fn (_ : Entry.Entry) => ())

        val subwindow = 
          Capi.make_managed_widget ("subwindow", Capi.Paned, frame, [Capi.PanedMargin true])

        local (* graph stuff *)

	   fun max (x,y) = if x > y then x else y
           fun ++ (id) = let val x = !id in (id := (!id) + 1; x) end

	   datatype Node = ROOT | NODE of Entry.Entry

	   fun print_node item =
	     let
	       val printOptions = get_print_options ()
	     in
	       case item of
		 ROOT => "Context"
	       | NODE entry => Entry.printEntry printOptions entry
	     end

	   val baseline_height = 3

	   datatype Item = ITEM of Node * Node list * int * (string * int * int * int) Option.option ref
           (* ITEM(entry, path, unique_id, extents) *)

	   fun get_item_data (ITEM (entry,path,_,extents),gp) =
	     case !extents of
	       Option.SOME data => data
	     | _ =>
		 let
		   val s = print_node entry
		   val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
		   val data = (s,font_ascent,font_descent,width)
		 in
		   extents := Option.SOME data;
		   data
		 end

	   fun entry_draw_item (item,gp,x,y) =
	     let
	       val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
	       val left = width div 2
	       val right = width - left
	       val new_point = POINT{x=x - left, y=y - baseline_height}
	     in 
   (*
	       Capi.GraphicsPorts.draw_fill_rectangle (gp,
						       x-left-1,
						       y-font_ascent-baseline_height-1,
						       left+right+4,
						       font_ascent + font_descent + 4);
   *)
	       Capi.GraphicsPorts.draw_image_string (gp,s, new_point)
	     end

	   fun entry_extent (item,gp) =
	     let
	       val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
	       val left = width div 2
	       val right = width - left
	     in
	       (left,
		right+2,
		baseline_height + font_ascent+1,
		max (0,font_descent+3-baseline_height))
	     end


          (*  
  	    fun make_context_graph () =
	      let
		fun entryfun path entry = ITEM (NODE entry,path,ref Option.NONE)
		fun top_entry entry = ITEM (NODE entry, [], ref Option.NONE)
		fun toplevel_items () = map top_entry (filter_entries (getItemsFromContext ()))
		fun get_children (ITEM (ROOT,_,_)) = toplevel_items ()
		  | get_children (ITEM (node as NODE entry,path,_)) = 
		    map (entryfun (node :: path)) (filter_entries (Entry.browse_entry true entry))
		fun get_node (ITEM (node,_,_)) = node
		val nodes_ref = ref []
		val iref = ref 0
		fun do_node item =
		  let
		    val node = get_node item
		    val children = get_children item
		    val index = !iref
		    val children_ref = ref []
		    val _ = nodes_ref := (item,children_ref) :: !nodes_ref
		    val _ = iref := 1 + !iref
		    val children_ids = map do_node (get_children item)
		  in
		    children_ref := children_ids;
		    index
		  end
		val _ = do_node (ITEM (ROOT,[],ref Option.NONE))
		val nodes =
		  Array.arrayoflist
		  (rev (map (fn (node,ref children) => (node,children)) (!nodes_ref)))
	      in
		(nodes,[0])
	      end
           *)

	   fun make_context_graph () =
	     let
               val uid = ref 0

               fun mk_item(node,path) = ITEM (node, path, ++(uid), ref Option.NONE)

	       fun entryfun path entry = mk_item (NODE entry, path)

	       fun top_entry entry = mk_item (NODE entry, [])

	       fun toplevel_items () = map top_entry (filter_entries (getItemsFromContext ()))
	       fun get_children (ITEM (ROOT,_,_,_)) = toplevel_items ()
		 | get_children (ITEM (node as NODE entry,path,_,_)) = 
		   map (entryfun (node :: path)) (filter_entries (Entry.browse_entry true entry))
	       fun get_node (ITEM (node,_,_,_)) = node

	       val nodes_ref = ref []

	       val iref = ref 0

	       fun do_node item =
		 let
		   val node = get_node item
		   val children = get_children item
		   val index = !iref
		   val children_ref = ref []
		   val _ = nodes_ref := (item,children_ref) :: !nodes_ref
		   val _ = ++(iref)
		   val children_ids = map do_node (get_children item)
		 in
		   children_ref := children_ids;
		   index
		 end

	       val _ = do_node (mk_item(ROOT,[]))

	       val nodes =
		 Array.arrayoflist
		 (rev (map (fn (node,ref children) => (node,children)) (!nodes_ref)))

	     in
	       (nodes,[0])
	     end

	   val graph_spec =
	     GraphWidget.GRAPH_SPEC {child_position = GraphWidget.BELOW,
				     orientation = GraphWidget.HORIZONTAL,
				     line_style = GraphWidget.STEP,
				     horizontal_delta = 20,
				     vertical_delta = 1,
				     show_all = false}

           val the_path = ref []
           val last_uid = ref (~1)

	   fun graph_select_fn (ITEM (node,path,uid,_)) =
               if (!last_uid = uid) then () else
	       let
		 val entries = ref []
		 val prev_path = !the_path

		 fun entry_name (entry) = #1 (Entry.get_id entry)

                 fun add_to_path (entry) =
                     (the_path := entry_name entry :: !the_path)

		 fun get_entries ((NODE entry) :: rest) =
		     ( entries := entry :: !entries;
		       add_to_path (entry);
		       get_entries (rest)
		     )
		   | get_entries (_) = ()

		 fun try_redisplay_list_pane (entry) =
		     if (prev_path = !the_path) then () else
		     case !cur_items of
		       [] => !reset_toplevel_hook()
		     | _  => if Entry.is_tip (entry)
			     then display_cur_items()
			     else ()

                fun complete_this_path (NODE entry) =
                    if Entry.is_tip (entry)
                    then ()
                    else the_path := entry_name entry :: rev(!the_path)
                  | complete_this_path (ROOT) = (the_path := [])

	       in

		 the_path := [];
                 last_uid := uid;

		 get_entries (path);
		 select_path_fn (!entries);

                 complete_this_path (node);

		 case node of
		   ROOT =>       !reset_toplevel_hook ()
		 | NODE entry => ( try_redisplay_list_pane (entry);
				   !select_entry_hook (entry)
				 )
	       end
d576 8
a583 42
        in
	   val {widget=graph_window,
		initialize=initialize_graph,
		update=update_graph,
		popup_menu=graph_menu,...} = 
	     GraphWidget.make ("browserGraph","BrowserGraph",subwindow,
			       graph_spec,
			       make_context_graph,
			       graph_select_fn,
			       entry_draw_item,
			       entry_extent)
        end  (* graph stuff *)


        (* Create scrollist ... *)
        (* This puts the list window beneath the graph pane *)

	val (scroll, list, set_items') =
	  Capi.make_scrolllist 
	    {parent = subwindow, name = "contextBrowser", select_fn = select_fn,
	     action_fn = fn _ => fn _ => (), print_fn = Entry.printEntry}


        val list_visible = ref true
        val graph_visible = ref true

        fun toggle_visible (visible,window) b =
          (visible := b;
           if b then Capi.reveal window
           else Capi.hide window)

	(* Massage set_items so that it prints the empty element in the
	 nil case. *)

	(* all instances of map_selected is used in set_items
	 There is some dodgy imperative stuff going on here
	 Commented out set_items and see what happens with new version *)
	(* 
        val set_items = map_selected set_items'
        fun map_selected f print_options l = f print_options (filter_entries l)
	 *)
	fun set_items print_options l = set_items' print_options (filter_entries l)
d585 2
a586 2
        val _ = (set_items_hook    := set_items)
        val _ = (select_entry_hook := select_fn(scroll, list, set_items))
d588 13
a600 33
	fun select (UserContext.ITEM (_, id, context, _, _)) =
	  let
            val entry_opt = Entry.get_entry (id,context)
	  in
	    case entry_opt
	      of Option.NONE => ()
	    |  Option.SOME entry =>
	      let
		val (str, last_component) = Entry.get_id entry
		val new_items = Entry.browse_entry true entry
	      in
                case (last_component, new_items)
                of (true, []) =>
                  ()
                | _ =>
                  (* Push the stacks and display the components of the
                     selected entry. *)
                  (Capi.Text.replace (pathText, 0, !pathLength, str);
		   (* Set pathStack to the top level, then add this item. *)
		   pathStack := [];
		   pathStr := "";
		   pathLength := 0;
		   add_to_path (str, new_items, last_component);
		   if last_component then
                     length_of_last_component := size str
		   else 
		     length_of_last_component := 0;
                   ShellUtils.add_history_item
                     ((!pathStr, !pathStack), history,
                      (fn ((s,_),(s',_))=>s=s'), user_preferences);
                   map_selected set_items (get_print_options ()) new_items)
	      end
	  end
d602 10
a611 61
	fun sense_select user_options =
	  case UserContext.get_selected
	    (GuiUtils.get_user_context (!local_context), user_options)
	    of
	      Option.NONE => ()
	    | Option.SOME entry => select entry
	       
	fun do_history (s, new_path) =
	  (Capi.Text.replace (pathText, 0,
                              !pathLength + !length_of_last_component, s);
	   pathLength := size s;
	   length_of_last_component := 0;
	   pathStr := s;
	   pathStack := new_path;
	   case new_path 
	     of (_, _, new_items) :: _ =>
	       set_items (get_print_options ()) new_items
	   | [] =>
	       set_items (get_print_options ()) (getItemsFromContext ()))
	  
	fun can_pop () =
	  case !pathStack of
	    [] => false
	  | _  => true
	      
	fun toplevel _ =
	  (* Context may have changed, so get current items. *)
	  (do_history ("", []);
	   Capi.set_focus list)

        val _ = (reset_toplevel_hook := toplevel)

	fun pop_history _ =
	  case !pathStack of
	    [_] =>
	      (* Parent is toplevel, so need to get current context *)
	      toplevel ()
	  | _ :: tail as ((n, s, items) :: _) =>
	      (pathStack := tail;
	       pathStr := MLWorks.String.substring (!pathStr, 0, n) ^ s;
	       Capi.Text.replace (pathText, 0,
                                  !pathLength + !length_of_last_component,
                                  !pathStr);
	       length_of_last_component := 0;
	       pathLength := n;
	       set_items (get_print_options ()) items;
               Capi.set_focus list)
	  | _ =>
	      Capi.set_focus list

	fun redisplay () = 
	  case !pathStack
	    of (_, _, items) :: _ =>
	      set_items (get_print_options ()) items
	  | _ =>
	      (* We could store the current toplevel items in a reference,
	       but this function is called so rarely that it doesn't seem
	       worth it.  The state in this module is complicated enough
	       already. *)
	      set_items (get_print_options ()) (getItemsFromContext ())
	      
d617 1
a617 3
        (* This should update the list widget too *)
        fun update_display () =
          (update_graph ())
d623 1
a623 10
	  
	val _ = redisplay ()
	  
	fun update () =
	  (* Update contents if at top level, otherwise leave it alone.
	   Users can't update existing substructures. *)
	  case !pathStack of
	    [] => toplevel ()
	  | _ => ()
	      
a626 11
	  
	(* Add the update function to the current context, so that changes
	 to the context are reflected in the browser. *)
	val update_fn_key =
	  ref (UserContext.add_update_fn
	       (GuiUtils.get_user_context (!local_context), update));

	val select_fn_key =
	  ref (UserContext.add_select_fn
	       (GuiUtils.get_user_context (!local_context),
		(select, get_user_options)))
a632 2
	    UserContext.remove_update_fn (old_user_context, !update_fn_key);
	    UserContext.remove_select_fn (old_user_context, !select_fn_key);
d635 1
a635 12
	    update_fn_key := UserContext.add_update_fn (new_user_context, update);
	    select_fn_key := UserContext.add_select_fn (new_user_context, 
                                                        (select, get_user_options));
	    (* Delete the history.  If you don't do this, then if users select
	       an entry in another context and move through its parents until
	       they reach the top level, they will be surprised when the
	       browser shows the top level of the current context.  The only
	       sane alternative to deleting the history is to add context
	       information to each entry on the history. *)
	    history := [];
            update_graph ();
	    toplevel ()
d637 1
a637 1
	   
a647 4
	     UserContext.remove_update_fn
	     (user_context, !update_fn_key);
	     UserContext.remove_select_fn
	     (user_context, !select_fn_key);
d684 1
a684 1
	     caller_update_fn = sense_select,
d692 1
a692 2
             @@ [Menus.PUSH ("filter", filter_popup, fn () => true),
                Menus.PUSH ("graph", graph_menu, fn () => !graph_visible)],
d694 1
d712 1
a712 21
	   fn _=> true),
          Menus.DYNAMIC
          ("history",
           fn () =>
           (map
            (fn (s,i) =>
             Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
            (!history)),
           fn _ => true),
          Menus.CASCADE
          ("stuff",
           [Menus.TOGGLE ("list",
                          fn _ => !list_visible,
                          toggle_visible (list_visible,scroll),
                          fn _ => true),
            Menus.TOGGLE ("graph",
                          fn _ => !graph_visible,
                          toggle_visible (graph_visible,graph_window),
                          fn _ => true)
            ],
           fn _ => true)]
a713 8
        Menus.make_buttons
        (buttonPane,
         [Menus.PUSH ("parentButton",
                      pop_history,
                      fn _ => true),
          Menus.PUSH ("toplevelButton",
                      toplevel,
                      fn _ => true)]);
a723 1
          Capi.Layout.FIXED buttonPane,
d725 1
a725 1
          Capi.Layout.PANED subwindow,
@


1.12
log
@Updating by adding Capi Point/Region datatypes
@
text
@d4 3
d319 19
d458 2
a459 1
	    val entrys = map Entry.massage context
d522 13
a534 1
	  
d586 52
d641 1
a641 1
        datatype Node = ROOT | NODE of Entry.Entry
d643 2
a644 8
        fun print_node item =
          let
            val printOptions = get_print_options ()
          in
            case item of
              ROOT => "Context"
            | NODE entry => Entry.printEntry printOptions entry
          end
d646 1
a646 2
        val baseline_height = 3
        fun max (x,y) = if x > y then x else y
d648 55
a702 1
        datatype Item = ITEM of Node * Node list * (string * int * int * int) Option.option ref
a703 12
        fun get_item_data (ITEM (entry,path,extents),gp) =
          case !extents of
            Option.SOME data => data
          | _ =>
              let
                val s = print_node entry
                val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
                val data = (s,font_ascent,font_descent,width)
              in
                extents := Option.SOME data;
                data
              end
d705 33
a737 16
        fun entry_draw_item (item,gp,x,y) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
            val new_point = POINT{x=x - left, y=y - baseline_height}
          in 
(*
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                    x-left-1,
                                                    y-font_ascent-baseline_height-1,
                                                    left+right+4,
                                                    font_ascent + font_descent + 4);
*)
            Capi.GraphicsPorts.draw_image_string (gp,s, new_point)
          end
d739 103
a841 43
        fun entry_extent (item,gp) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in
            (left,
             right+2,
             baseline_height + font_ascent+1,
             max (0,font_descent+3-baseline_height))
          end
    
        fun make_context_graph () =
          let
            fun entryfun path entry = ITEM (NODE entry,path,ref Option.NONE)
            fun top_entry entry = ITEM (NODE entry, [], ref Option.NONE)
            fun toplevel_items () = map top_entry (filter_entries (getItemsFromContext ()))
            fun get_children (ITEM (ROOT,_,_)) = toplevel_items ()
              | get_children (ITEM (node as NODE entry,path,_)) = 
                map (entryfun (node :: path)) (filter_entries (Entry.browse_entry true entry))
            fun get_node (ITEM (node,_,_)) = node
            val nodes_ref = ref []
            val iref = ref 0
            fun do_node item =
              let
                val node = get_node item
                val children = get_children item
                val index = !iref
                val children_ref = ref []
                val _ = nodes_ref := (item,children_ref) :: !nodes_ref
                val _ = iref := 1 + !iref
                val children_ids = map do_node (get_children item)
              in
                children_ref := children_ids;
                index
              end
            val _ = do_node (ITEM (ROOT,[],ref Option.NONE))
            val nodes =
              Array.arrayoflist
              (rev (map (fn (node,ref children) => (node,children)) (!nodes_ref)))
          in
            (nodes,[0])
          end
d843 12
a854 8
            
        val graph_spec =
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.BELOW,
                                  orientation = GraphWidget.HORIZONTAL,
                                  line_style = GraphWidget.STEP,
                                  horizontal_delta = 20,
                                  vertical_delta = 1,
                                  show_all = false}
a855 16
        (* This is somewhat crude and ignores, for example, the history *)
        fun graph_select_fn (ITEM (node,path,_)) =
          let
            fun node_string (ROOT) = "ROOT"
              | node_string (NODE entry) = #1 (Entry.get_id entry)
            fun printit (node,[]) = node_string node
              | printit (node,node'::path) =
                node_string node' ^ "." ^ printit (node,path)
            val string = printit (node,rev path)
          in
            Capi.Text.replace (pathText, 0,
                               !pathLength + !length_of_last_component, string);
            pathLength := size string;
            length_of_last_component := 0;
            pathStr := string
          end
d857 2
a858 10
        val {widget=graph_window,
             initialize=initialize_graph,
             update=update_graph,
             popup_menu=graph_menu,...} = 
          GraphWidget.make ("browserGraph","BrowserGraph",subwindow,
                            graph_spec,
                            make_context_graph,
                            graph_select_fn,
                            entry_draw_item,
                            entry_extent)
d865 1
d885 4
a888 1
	  
d952 3
a954 1
	  
@


1.11
log
@Changing top level window initialization
@
text
@d4 3
d305 12
d588 1
d597 1
a597 3
            Capi.GraphicsPorts.draw_image_string (gp,s,
                                                  x - left,
                                                  y - baseline_height)
@


1.10
log
@Extending GraphSpec type
@
text
@d4 3
d970 1
a970 2
        Capi.reveal shell;
        Capi.initialize shell;
@


1.9
log
@Changing for new graph interface
@
text
@d4 3
d523 2
a524 3
	    case (last_component, new_items)
	    of (true, []) =>
	      ()
d599 2
a600 2
            val toplevel_items = map top_entry (getItemsFromContext ())
            fun get_children (ITEM (ROOT,_,_)) = toplevel_items
d602 1
a602 1
                map (entryfun (node :: path)) (Entry.browse_entry true entry)
d633 2
a634 1
                                  vertical_delta = 1}
d782 11
a792 10
	      
	fun search_popup _ =
	  (
	   (#1 (Menus.create_dialog
		(shell, "Search Window", "browserDialog", fn ()=>(), search_spec))) ()
	   )
	  
	fun filter_popup _ =
	  (
	   (#1 (Menus.create_dialog
d794 1
a794 2
	       fn ()=>(), filter_spec))) ()
	   )
d825 2
a826 4
	    UserContext.remove_update_fn
	      (old_user_context, !update_fn_key);
	    UserContext.remove_select_fn
	      (old_user_context, !select_fn_key);
d829 3
a831 5
	    update_fn_key :=
	      UserContext.add_update_fn (new_user_context, update);
	    select_fn_key :=
	      UserContext.add_select_fn
		(new_user_context, (select, get_user_options));
@


1.8
log
@Correcting typo
@
text
@d4 3
d319 7
a325 6
        val title = let
	  val n = !browser_number
	in
	  browser_number := n + 1;
	  "Context Browser #" ^ (MLWorks.Integer.makestring n)
	end (* title *)
d350 1
a350 1
	  of MLWorks.Option.SOME w =>
d359 1
a359 1
	  |  MLWorks.Option.NONE => ()
d471 2
a473 2
	(* pathStack records each entry on the path, so that we can go to
	 the parent structure *)
d477 1
d484 5
a488 5
	  |   add_to_path (str, new_items, true) =
	      (* datatypes - display of entries overwrites the type name itself *)
	      (pathStack := (!pathLength, str, new_items) :: (!pathStack);
	       pathStr := !pathStr ^ str)
	      
a492 2
	val length_of_last_component = ref 0;
	  
d504 3
a506 3
	       be extended beyond this point.
	       If in addition new_items is empty, then the list of items should
	       not be changed. *)
d527 1
a527 1
                  (fn ((s,_),(s',_))=>s=s'), user_preferences);
d548 1
a548 1
        datatype Item = ITEM of Node * (string * int * int * int) Option.option ref
d550 1
a550 1
        fun get_item_data (ITEM (entry,extents),gp) =
d595 26
a620 4
            fun entryfun entry = ITEM (NODE entry,ref MLWorks.Option.NONE)
            val items = map entryfun (getItemsFromContext ())
            fun get_children (ITEM (ROOT,_)) = items
              | get_children (ITEM (NODE entry,_)) = map entryfun(Entry.browse_entry true entry)
d622 1
a622 3
            (ITEM (ROOT,ref MLWorks.Option.NONE),
             get_children,
             Option.NONE) (* No equality function as this is going to be drawn as a tree *)
d625 1
d633 17
d654 6
a659 2
          GraphWidget.make ("browserGraph","BrowserGraph",
                            graph_spec,entry_draw_item,entry_extent,make_context_graph,subwindow)
d691 2
a692 2
	      of MLWorks.Option.NONE => ()
	    |  MLWorks.Option.SOME entry =>
d724 2
a725 2
	      MLWorks.Option.NONE => ()
	    | MLWorks.Option.SOME entry => select entry
d729 1
a729 1
			    !pathLength + !length_of_last_component, s);
d759 2
a760 2
                             !pathLength + !length_of_last_component,
                             !pathStr);
d958 1
a958 1
            MLWorks.Option.SOME w => [Capi.Layout.FIXED w]
@


1.7
log
@Renaming layout constructors
@
text
@d1 1
a1 1
`(*
d4 3
@


1.6
log
@Adding some stuff into the menubar
@
text
@d1 1
a1 1
(*
d4 3
d618 1
a618 1
        val list_visible = ref false
d623 2
a624 2
           if b then Capi.manage window
           else Capi.unmanage window)
d910 1
a910 1
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
d912 4
a915 4
         [Capi.Layout.OTHER pathLabel,
          Capi.Layout.OTHER pathText,
          Capi.Layout.OTHER buttonPane,
          Capi.Layout.OTHER listLabel,
d920 2
a921 2
        Capi.manage shell;
        Capi.realize shell;
@


1.5
log
@Adding make_buttons function to capi
@
text
@d4 3
d875 4
a878 4
           map
           (fn (s,i) =>
            Menus.PUSH (s, fn _ => do_history (s,i), fn _ => true))
           (!history),
@


1.4
log
@Improvements to graphs
@
text
@d4 3
d851 2
a852 12
      in
        Menus.make_submenus
        (buttonPane,
         [Menus.PUSH ("parentButton",
                      pop_history,
                      fn _ => true),
          Menus.PUSH ("toplevelButton",
                      toplevel,
                      fn _ => true)]);
        Menus.make_submenus
        (menuBar,
         [ToolData.works_menu
d888 11
a898 1
           fn _ => true)]);
d901 2
a902 1
        ([Capi.Layout.MENUBAR menuBar] @@
@


1.3
log
@Moved capi etc. to gui
@
text
@d4 3
d516 2
a517 1
        val subwindow = Capi.make_managed_widget ("subwindow", Capi.Paned, frame, [Capi.PanedMargin true])
d554 1
d560 1
a591 1
                                  parent_position = GraphWidget.TOP,
d597 4
a600 1
        val (graph_window,initialize_graph,update_graph) = 
d609 1
a609 1
        val list_visible = ref true
d845 2
a846 1
             @@ [Menus.PUSH ("filter", filter_popup, fn () => true)],
a871 4
	  Menus.CASCADE
	  ("view",
	   [Menus.PUSH ("filter", filter_popup, fn _=> true)],
	   fn _=> true),
@


1.2
log
@Moved graph_widget to gui directory
@
text
@d223 2
a224 2
require "../library/capi";
require "../library/menus";
@


1.1
log
@new unit
New unit
@
text
@d4 4
a223 1
require "../library/graph_widget";
d231 1
@
