head	1.83;
access;
symbols
	MLW_daveb_inline_1_4_99:1.83.1
	MLWorks_21c0_1999_03_25:1.83
	MLWorks_20c1_1998_08_20:1.82
	MLWorks_20c0_1998_08_04:1.81
	MLWorks_20b2c2_1998_06_19:1.81
	MLWorks_20b2_Windows_1998_06_12:1.81
	MLWorks_20b1c1_1998_05_07:1.81
	MLWorks_20b0_1998_04_07:1.80
	MLWorks_20b0_1998_03_20:1.79
	MLWorks_20m2_1998_02_16:1.75
	MLWorks_20m1_1997_10_23:1.73
	MLWorks_11r1:1.68.1.2.1.2.1
	MLWorks_workspace_97:1.72.2
	MLWorks_dt_wizard:1.72.1
	MLWorks_11c0_1997_09_09:1.68.1.2.1.2
	MLWorks_10r3:1.68.1.2.3
	MLWorks_10r2_551:1.68.1.2.2
	MLWorks_11:1.68.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.68.1.2
	MLWorks_20m0_1997_06_20:1.72
	MLWorks_1_0_r2c2_1997_06_14:1.68.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.68.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.68.1
	MLWorks_BugFix_1997_04_24:1.68
	MLWorks_1_0_r2_Win32_1997_04_11:1.68
	MLWorks_1_0_r2_Unix_1997_04_04:1.68
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.65.4.1.1
	MLWorks_gui_1996_12_18:1.65.5
	MLWorks_1_0_Win32_1996_12_17:1.65.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.65.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.65.1.1
	JFHgui:1.65.3
	MLWorks_1_0_Irix_1996_11_28:1.65.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.65.2
	MLWorks_1_0_Unix_1996_11_14:1.65.1
	MLWorks_Open_Beta2_1996_10_11:1.62.3
	MLWorks_License_dev:1.62.2
	MLWorks_1_open_beta_1996_09_13:1.62.1
	MLWorks_Open_Beta_1996_08_22:1.62
	MLWorks_Beta_1996_07_02:1.57
	MLWorks_Beta_1996_06_07:1.53
	MLWorks_Beta_1996_06_06:1.53
	MLWorks_Beta_1996_06_05:1.53
	MLWorks_Beta_1996_06_03:1.53
	MLWorks_Beta_1996_05_31:1.52
	MLWorks_Beta_1996_05_30:1.51;
locks; strict;
comment	@ * @;


1.83
date	99.02.02.15.59.21;	author mitchell;	state Exp;
branches
	1.83.1.1;
next	1.82;

1.82
date	98.08.17.09.23.03;	author mitchell;	state Exp;
branches;
next	1.81;

1.81
date	98.04.24.16.40.00;	author johnh;	state Exp;
branches;
next	1.80;

1.80
date	98.03.24.17.30.37;	author jont;	state Exp;
branches;
next	1.79;

1.79
date	98.03.20.16.12.23;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	98.03.02.15.07.22;	author mitchell;	state Exp;
branches;
next	1.77;

1.77
date	98.02.19.20.15.28;	author mitchell;	state Exp;
branches;
next	1.76;

1.76
date	98.02.18.16.59.21;	author jont;	state Exp;
branches;
next	1.75;

1.75
date	98.01.27.16.09.50;	author johnh;	state Exp;
branches;
next	1.74;

1.74
date	97.10.30.13.13.52;	author johnh;	state Exp;
branches;
next	1.73;

1.73
date	97.10.01.16.54.04;	author jkbrook;	state Exp;
branches;
next	1.72;

1.72
date	97.06.09.10.26.49;	author johnh;	state Exp;
branches
	1.72.1.1
	1.72.2.1;
next	1.71;

1.71
date	97.05.27.11.12.16;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	97.05.16.15.35.03;	author johnh;	state Exp;
branches;
next	1.69;

1.69
date	97.05.02.17.24.13;	author jont;	state Exp;
branches;
next	1.68;

1.68
date	97.03.25.11.26.29;	author matthew;	state Exp;
branches
	1.68.1.1;
next	1.67;

1.67
date	97.03.19.16.56.49;	author matthew;	state Exp;
branches;
next	1.66;

1.66
date	97.03.13.12.21.13;	author johnh;	state Exp;
branches;
next	1.65;

1.65
date	96.11.06.11.16.10;	author matthew;	state Exp;
branches
	1.65.1.1
	1.65.2.1
	1.65.3.1
	1.65.4.1
	1.65.5.1;
next	1.64;

1.64
date	96.11.05.12.42.55;	author johnh;	state Exp;
branches;
next	1.63;

1.63
date	96.10.30.21.32.28;	author io;	state Exp;
branches;
next	1.62;

1.62
date	96.08.15.13.55.02;	author daveb;	state Exp;
branches
	1.62.1.1
	1.62.2.1
	1.62.3.1;
next	1.61;

1.61
date	96.08.09.15.25.20;	author nickb;	state Exp;
branches;
next	1.60;

1.60
date	96.08.06.16.21.45;	author andreww;	state Exp;
branches;
next	1.59;

1.59
date	96.08.05.13.07.49;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	96.07.30.14.39.00;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	96.06.25.09.57.30;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.06.24.12.01.06;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	96.06.18.16.38.30;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	96.06.13.17.00.27;	author brianm;	state Exp;
branches;
next	1.53;

1.53
date	96.05.31.16.10.47;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.05.30.14.28.32;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.05.28.15.13.33;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	96.05.24.13.31.56;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	96.05.24.11.20.14;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	96.05.22.16.32.51;	author daveb;	state Exp;
branches;
next	1.47;

1.47
date	96.05.22.15.09.12;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	96.05.21.16.13.07;	author daveb;	state Exp;
branches;
next	1.45;

1.45
date	96.05.20.15.07.17;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	96.05.15.16.25.27;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	96.05.10.12.22.26;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	96.05.07.11.32.32;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	96.05.01.10.46.28;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	96.04.30.09.28.27;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.03.19.10.30.36;	author matthew;	state Exp;
branches;
next	1.38;

1.38
date	96.03.12.15.13.33;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	96.02.29.14.21.44;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.02.26.16.38.33;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	96.02.19.10.38.10;	author stephenb;	state Exp;
branches;
next	1.34;

1.34
date	96.02.08.11.35.38;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	96.01.23.14.38.43;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.19.17.03.21;	author daveb;	state Exp;
branches;
next	1.31;

1.31
date	96.01.18.14.44.17;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	96.01.17.14.13.03;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.01.16.15.39.27;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	96.01.12.12.06.14;	author daveb;	state Exp;
branches;
next	1.27;

1.27
date	96.01.10.13.35.45;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.01.10.13.14.50;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	96.01.09.13.57.15;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.01.08.17.00.15;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.01.08.16.27.33;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.12.13.14.55.53;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	95.12.13.10.23.02;	author daveb;	state Exp;
branches;
next	1.20;

1.20
date	95.12.07.14.32.40;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.12.04.14.21.34;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.11.30.15.31.41;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	95.11.21.17.30.32;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.16.14.01.20;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.11.15.15.32.01;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.10.26.15.35.52;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.10.25.17.47.39;	author daveb;	state Exp;
branches;
next	1.12;

1.12
date	95.10.17.13.56.53;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.10.13.14.43.13;	author brianm;	state Exp;
branches;
next	1.10;

1.10
date	95.10.13.12.24.25;	author brianm;	state Exp;
branches;
next	1.9;

1.9
date	95.10.09.11.46.23;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.10.06.14.11.00;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	95.10.04.14.43.33;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.10.03.16.26.28;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	95.09.22.15.27.13;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.08.30.13.23.41;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.12.15.00;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.57.30;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.40.39;	author matthew;	state Exp;
branches;
next	;

1.62.1.1
date	96.09.13.11.13.12;	author hope;	state Exp;
branches;
next	;

1.62.2.1
date	96.10.07.16.03.53;	author hope;	state Exp;
branches;
next	;

1.62.3.1
date	96.10.17.11.22.06;	author hope;	state Exp;
branches;
next	;

1.65.1.1
date	96.11.14.12.46.06;	author hope;	state Exp;
branches
	1.65.1.1.1.1;
next	;

1.65.1.1.1.1
date	96.11.28.14.57.51;	author hope;	state Exp;
branches;
next	;

1.65.2.1
date	96.11.22.18.06.29;	author hope;	state Exp;
branches;
next	;

1.65.3.1
date	96.12.17.09.54.32;	author hope;	state Exp;
branches;
next	;

1.65.4.1
date	96.12.17.17.45.11;	author hope;	state Exp;
branches
	1.65.4.1.1.1;
next	;

1.65.4.1.1.1
date	97.02.24.11.34.39;	author hope;	state Exp;
branches;
next	;

1.65.5.1
date	96.12.18.09.39.10;	author hope;	state Exp;
branches;
next	;

1.68.1.1
date	97.05.12.10.31.29;	author hope;	state Exp;
branches;
next	1.68.1.2;

1.68.1.2
date	97.05.19.17.54.58;	author daveb;	state Exp;
branches
	1.68.1.2.1.1
	1.68.1.2.2.1
	1.68.1.2.3.1;
next	;

1.68.1.2.1.1
date	97.07.28.18.17.23;	author daveb;	state Exp;
branches;
next	1.68.1.2.1.2;

1.68.1.2.1.2
date	97.08.08.17.17.47;	author daveb;	state Exp;
branches
	1.68.1.2.1.2.1.1;
next	;

1.68.1.2.1.2.1.1
date	97.10.07.11.42.13;	author jkbrook;	state Exp;
branches;
next	;

1.68.1.2.2.1
date	97.09.08.17.10.55;	author daveb;	state Exp;
branches;
next	;

1.68.1.2.3.1
date	97.09.09.14.06.29;	author daveb;	state Exp;
branches;
next	;

1.72.1.1
date	97.09.10.19.21.01;	author brucem;	state Exp;
branches;
next	;

1.72.2.1
date	97.09.11.20.52.13;	author daveb;	state Exp;
branches;
next	1.72.2.2;

1.72.2.2
date	97.11.12.15.18.48;	author johnh;	state Exp;
branches;
next	1.72.2.3;

1.72.2.3
date	97.11.24.11.43.38;	author johnh;	state Exp;
branches;
next	;

1.83.1.1
date	99.04.01.17.55.32;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.83
log
@[Bug #190500]
Remove redundant require statements
@
text
@(* Copyright (c) 1993 Harlequin Ltd.
 *
 * $Log: _gui_utils.sml,v $
 * Revision 1.82  1998/08/17  09:23:03  mitchell
 * [Bug #50103]
 * Evaluate search function after processing check boxes controlling search
 *
 * Revision 1.81  1998/04/24  16:40:00  johnh
 * [Bug #30229]
 * Group compiler options to allow more flexibility.
 *
 * Revision 1.80  1998/03/24  17:30:37  jont
 * [Bug #30090]
 * Remove uses of MLWorks.IO
 *
 * Revision 1.78  1998/03/02  15:07:22  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
 * Revision 1.77  1998/02/19  20:15:28  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.76  1998/02/18  16:59:21  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.75  1998/01/27  16:09:50  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.74  1997/10/30  13:13:52  johnh
 * [Bug #30233]
 * Make editor interface (dialog) clearer.
 *
 * Revision 1.73  1997/10/01  16:54:04  jkbrook
 * [Bug #20088]
 * Merging from MLWorks_11:
 * SML'96 should be SML'97
 *
 * Revision 1.72.2.3  1997/11/24  11:43:38  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.72.2.1  1997/09/11  20:52:13  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.72  1997/06/09  10:26:49  johnh
 * [Bug #30068]
 * Make Breakpoint and Trace Managers top level tools.
 *
 * Revision 1.71  1997/05/27  11:12:16  daveb
 * [Bug #30136]
 * Removed early-mips-r4000 option.
 *
 * Revision 1.70  1997/05/16  15:35:03  johnh
 * Implementing single menu bar on Windows.
 * Re-organising menus for Motif.
 *
 * Revision 1.69  1997/05/02  17:24:13  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.68  1997/03/25  11:26:29  matthew
 * Platform specific compiler options changes
 *
 * Revision 1.67  1997/03/19  16:56:49  matthew
 * Adding Types structure
 *
 * Revision 1.66  1997/03/13  12:21:13  johnh
 * [Bug #1854]
 * Added a call to Capi.set_close_callback.
 *
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.64  1996/11/05  12:42:55  johnh
 * [Bug #1724]
 * Changing toggles to radio buttons in preferences->editor.
 *
 * Revision 1.63  1996/10/30  21:32:28  io
 * moving String from toplevel
 *
 * Revision 1.62  1996/08/15  13:55:02  daveb
 * [Bug #1519]
 * The type of UserContext.ITEM has changed.
 *
 * Revision 1.61  1996/08/09  15:25:20  nickb
 * Option dialog setter functions now return accept/reject.
 *
 * Revision 1.60  1996/08/06  16:21:45  andreww
 * [Bug #1521]
 * Propagating changes made to interpreter/_entry.sml
 *
 * Revision 1.59  1996/08/05  13:07:49  daveb
 * Removed object path entry from the Paths menu.
 *
 * Revision 1.58  1996/07/30  14:39:00  jont
 * Use a system dependent line terminator when saving history
 *
 * Revision 1.57  1996/06/25  09:57:30  daveb
 * Made button buttons have different names from menu buttons, so that
 * Windows can distinguish between them, and so let us put mnemonics on
 * the menu items but not the buttons.
 *
 * Revision 1.56  1996/06/24  12:01:06  daveb
 * Removed SaveImage.preference_file_name, because Getenv.get_preferences_filename
 * now does this job.
 *
 * Revision 1.55  1996/06/18  16:38:30  daveb
 * Removed Step Mode menu item (replaced with a button on the listener).
 *
 * Revision 1.54  1996/06/13  17:00:27  brianm
 * Modifications to add custom editor interface ...
 *
 * Revision 1.53  1996/05/31  16:10:47  daveb
 * Bug 1074: Capi.list_select now takes a function to be called on any key
 * press handled by the list widget itself.  In the listener, this pops the
 * completions widget down as if the key had been typed at the listener.
 *
 * Revision 1.52  1996/05/30  14:28:32  daveb
 * The Io exception is no longer at top level.
 *
 * Revision 1.51  1996/05/28  15:13:33  daveb
 * Fixed bug 1328: the user_tool_options were hanging on to old update functions.
 * These referenced deleted widgets, and therefore caused SEGVs.
 *
 * Revision 1.49  1996/05/24  11:20:14  daveb
 * Ensure that blank entries never get added to the history.
 *
 * Revision 1.48  1996/05/22  16:32:51  daveb
 * Added a separator to the Languages dialog.
 *
 * Revision 1.47  1996/05/22  15:09:12  daveb
 * Reorganised the options menus.
 *
 * Revision 1.46  1996/05/21  16:13:07  daveb
 * Renamed mode options.
 *
 * Revision 1.45  1996/05/20  15:07:17  daveb
 * UserOptions now defines functions for setting and testing modes.
 *
 * Revision 1.44  1996/05/15  16:25:27  daveb
 * Corrected the titles of some dialog boxes, which were hangovers from the
 * days of multiple contexts.
 *
 * Revision 1.43  1996/05/10  12:22:26  daveb
 * Fixed bug in history_menu.  The history_index was being set after the
 * call to use_entry, which meant that the buttons on the listener were
 * being updated using the old value.  Also, the index was off by one.
 *
 * Revision 1.42  1996/05/07  11:32:32  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.41  1996/05/01  10:46:28  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.40  1996/04/30  09:28:27  matthew
 * Changing to new basis
 *
 * Revision 1.39  1996/03/19  10:30:36  matthew
 * Removing some options
 *
 * Revision 1.38  1996/03/12  15:13:33  matthew
 * Adding path menu
 *
 * Revision 1.37  1996/02/29  14:21:44  matthew
 * Adding "Save preferences" menu item
 *
 * Revision 1.36  1996/02/26  16:38:33  matthew
 * Improving layout of string list manager
 *
 * Revision 1.35  1996/02/19  10:38:10  stephenb
 * Updated wrt Trace.step_status -> Trace.stepping name change.
 *
 * Revision 1.34  1996/02/08  11:35:38  daveb
 * Capi.make_scrolllist now returns a record, with an add_items field.
 * Removed sensitivity type.
 *
 * Revision 1.33  1996/01/23  14:38:43  daveb
 * Minor changes to menu interfaces.
 *
 * Revision 1.32  1996/01/19  17:03:21  daveb
 * Added make_history function.
 *
 * Revision 1.31  1996/01/18  14:44:17  matthew
 * Disable Inspect option in Value menu.
 *
 * Revision 1.30  1996/01/17  14:13:03  matthew
 * Adding Inspect to value menu
 *
 * Revision 1.29  1996/01/16  15:39:27  matthew
 * Changing uses of full_menus
 *
 * Revision 1.28  1996/01/12  12:06:14  daveb
 * Added ".sml" mask to save_as_dialog.
 *
 * Revision 1.27  1996/01/10  13:35:45  daveb
 * Replaced Capi.find_file with Capi.save_as_dialog.
 *
 * Revision 1.26  1996/01/10  13:14:50  matthew
 * Changes to search facility
 *
 * Revision 1.25  1996/01/09  13:57:15  matthew
 * Doing something with list_select
 *
 * Revision 1.24  1996/01/08  17:00:15  matthew
 * Fixing problem with deleting single items.
 *
 * Revision 1.23  1996/01/08  16:27:33  matthew
 * Moving list_select into architecture specific code.
 *
 * Revision 1.22  1995/12/13  14:55:53  jont
 * Add call to ml_debugger to update debugger table when setting break points
 *
 * Revision 1.21  1995/12/13  10:23:02  daveb
 * Added Path Tool to setup_menu.
 * Replaced FileDialog.find_file with Capi.find_file; the type has changed too.
 *
 * Revision 1.20  1995/12/07  14:32:40  matthew
 * Changing interface to clipboard functions
 *
 * Revision 1.19  1995/12/04  14:21:34  daveb
 * Corrected previous fix: the initial context wasn't being set.
 *
 * Revision 1.18  1995/11/30  15:31:41  jont
 * Modification to allow gui to be restarted when restarting an
 * image saved from the GUI.
 *
 * Revision 1.17  1995/11/21  17:30:32  matthew
 * Changing names for search resources.
 *
 * Revision 1.16  1995/11/16  14:01:20  matthew
 * Changing button resources
 *
 * Revision 1.15  1995/11/15  15:32:01  matthew
 * Changing clipboard mechanism
 *
 * Revision 1.14  1995/10/26  15:35:52  daveb
 * Removed "search in structure" option from the search dialog because we
 * always want to search substructures.
 * Changed list_select to destroy the widget on exit.  Tools should create a
 * new list widget each time they need one.  This is so that it pops up with
 * the correct size under TWM.  (The search dialog already does this.).
 *
 * Revision 1.13  1995/10/25  17:47:39  daveb
 * Hid the local variables debugging options unless full_menus is set.
 *
 * Revision 1.12  1995/10/17  13:56:53  matthew
 * Simplifying tracing interface.
 *
 * Revision 1.11  1995/10/13  14:43:13  brianm
 * Another Menu utility ...
 *
 * Revision 1.10  1995/10/13  12:24:25  brianm
 * Adding some PopUp Menu utility functions : (int_value, etc.)
 *
 * Revision 1.9  1995/10/09  11:46:23  daveb
 * Made context_menu include "Save" and "Save As..." options only if the
 * context is writable.
 *
 * Revision 1.8  1995/10/06  14:11:00  daveb
 * Minor improvements to search mechanism.
 *
 * Revision 1.7  1995/10/04  14:43:33  daveb
 * Moved mode options to preference menu until we have proper support for
 * contexts-as-files.
 *
 * Revision 1.6  1995/10/03  16:26:28  daveb
 * Menus.make_buttons now returns a record of functions.
 *
 * Revision 1.5  1995/09/22  15:27:13  daveb
 * Make options visible when full_menus is not set.  The default implementation
 * now hides all mention of multiple contexts, but makes everything else visible.
 *
 * Revision 1.4  1995/08/30  13:23:41  matthew
 * Doesn't work under windows
 *
 * Revision 1.3  1995/08/10  12:15:00  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:57:30  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:40:39  matthew
 * new unit
 * New unit
 *
 *  Revision 1.66  1995/07/17  12:40:56  matthew
 *  Correcting layout of list_select pane
 *
 *  Revision 1.65  1995/07/13  14:12:11  matthew
 *  Adding some debugger utilities
 *
 *  Revision 1.64  1995/07/04  15:58:39  matthew
 *  Capification
 *
 *  Revision 1.63  1995/06/30  16:22:09  daveb
 *  Added float_precision option to ValuePrinter options.
 *
 *  Revision 1.62  1995/06/20  12:39:25  daveb
 *  Added variable info mode.
 *
 *  Revision 1.61  1995/06/14  14:09:39  daveb
 *  ShellUtils.edit_* functions no longer require a context argument.
 *  Added entries for new preferences to setup_menu.
 *
 *  Revision 1.60  1995/06/13  14:30:05  daveb
 *  Removed show_id_class and show_eq_info value printer options from interface.
 *
 *  Revision 1.59  1995/06/05  13:20:48  daveb
 *  Added NO_SENSE_SELECTION option for Sensitivity type.
 *
 *  Revision 1.58  1995/06/01  10:44:27  daveb
 *  Added new type MotifContext, which combines a user_context with
 *  dialog boxes for context-specific options.  Changed context_menu to
 *  incorporate entries for popping up the options dialogs for the current
 *  context.  Put the remaining options dialogs, for tool-specific options,
 *  in the view_options function, which returns items for use in "view"
 *  menus.
 *
 *  Revision 1.57  1995/05/23  14:07:27  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.56  1995/05/22  18:27:13  daveb
 *  Removed erroneous call to debug_output
 *
 *  Revision 1.55  1995/05/15  15:03:21  matthew
 *  Renaming nj_semicolons
 *
 *  Revision 1.54  1995/05/01  15:40:29  matthew
 *  Removing exception EditObject
 *
 *  Revision 1.53  1995/04/28  12:39:32  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.52  1995/04/24  15:54:06  daveb
 *  Removed stepper option, commented out poly_variable and moduler options.
 *  Also commented out default_overloads option.
 *
 *  Revision 1.51  1995/04/24  14:50:38  matthew
 *  Refinements to list manager widgets
 *
 *  Revision 1.50  1995/04/20  12:30:16  matthew
 *  Added list managers
 *  New break/trace menu
 *
 *  Revision 1.49  1995/04/19  10:20:42  daveb
 *  Added rename option to context menu.
 *
 *  Revision 1.48  1995/03/30  18:01:52  daveb
 *  Made make_scrolllist handle empty lists specially.
 *
 *  Revision 1.47  1995/03/16  18:27:05  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.46  1995/03/13  21:31:22  daveb
 *  Added support for propagating changes of context.
 *
 *  Revision 1.45  1995/03/10  15:20:59  daveb
 *  Added support for selections to the options menu.
 *
 *  Revision 1.44  1994/11/30  16:43:35  daveb
 *  Ensured that if full_menus is false, only the required menus and
 *  dialogs are created.
 *
 *  Revision 1.43  1994/09/26  09:42:44  matthew
 *  Change to Basis.lookup_val
 *
 *  Revision 1.42  1994/09/21  16:11:38  brianm
 *  Adding value menu implementation ...
 *
 *  Revision 1.41  1994/08/02  10:57:14  daveb
 *  Revised editor preference dialog.
 *
 *  Revision 1.40  1994/07/27  12:57:56  daveb
 *  Cut down menus for novices.
 *
 *  Revision 1.39  1994/06/20  11:13:34  daveb
 *  Replaced ContextRef with user_context.
 *
 *  Revision 1.38  1994/05/06  10:22:01  daveb
 *  Added default_overloads option.
 *
 *  Revision 1.37  1994/04/06  11:50:58  daveb
 *  Added breakpoints menu.
 *
 *  Revision 1.36  1994/02/22  00:50:13  nosa
 *  Step and Modules Debugger compiler options.
 *
 *  Revision 1.35  1993/12/17  18:15:49  matthew
 *  Added maximum_str_depth to options.
 *
 *  Revision 1.34  1993/12/10  16:57:25  daveb
 *  Added context_menu function.
 *
 *  Revision 1.33  1993/12/01  16:15:33  io
 *  *** empty log message ***
 *
 *  Revision 1.32  1993/12/01  15:33:57  io
 *  Added max_num_errors
 *
 *  Revision 1.31  1993/11/29  13:20:35  matthew
 *  Added handler for SubLoopTerminated in with_message -- otherwise we try and
 *  set the cursor of a window after Motif has exitted.
 *  Changed outstreams so a line at a time is printed.  Scrolling behaviour is bas
 *   bad otherwise.
 *
 *  Revision 1.30  1993/11/18  11:50:06  nickh
 *  Change to outstream arguments.
 *
 *  Revision 1.29  1993/11/08  16:08:35  jont
 *  Added menu iterm for generating interruptable code
 *  .\
 *
 *  Revision 1.28  1993/10/13  11:58:38  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.27  1993/10/08  16:43:29  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.26  1993/09/17  14:05:13  nosa
 *  New compiler option debug_polyvariables for polymorphic debugger.
 *
 *  Revision 1.25  1993/09/13  09:16:33  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.24.1.4  1993/10/12  14:41:15  daveb
 *  Changed print options.
 *
 *  Revision 1.24.1.3  1993/10/08  10:29:28  matthew
 *  Added beep & cut buffer utilities
 *  Fixed problem with generate_variable_debug_info and debugging mode
 *
 *  Revision 1.24.1.2  1993/09/10  11:12:21  daveb
 *  Added name parameter to GuiUtils.list_select.
 *
 *  Revision 1.24.1.1  1993/08/24  12:16:17  jont
 *  Fork for bug fixing
 *
 *  Revision 1.24  1993/08/24  12:16:17  matthew
 *  Rationalized mode option functions
 *
 *  Revision 1.23  1993/08/19  17:25:43  daveb
 *  Removed core-only and functional options, since they didn't do anything.
 *
 *  Revision 1.22  1993/08/11  11:01:50  matthew
 *  Changes for automatic option menu updating
 *
 *  Revision 1.21  1993/08/09  16:21:53  matthew
 *  Extended environment menu
 *
 *  Revision 1.20  1993/08/05  11:52:42  nosa
 *  New compiler option generateVariableDebugInfo in options menu.
 *
 *  Revision 1.19  1993/08/04  09:09:19  matthew
 *  Changed strict option to standard
 *
 *  Revision 1.18  1993/07/29  14:55:37  matthew
 *  Added (unworking and deleted) with_message function
 *  Added working with_message function that sets the cursor to busy
 *
 *  Revision 1.17  1993/06/10  16:02:42  matthew
 *  Added open_fixity and fixity_specs options
 *
 *  Revision 1.16  1993/06/03  16:54:53  daveb
 *  Removed cancel and help buttons from message boxes.
 *
 *  Revision 1.15  1993/05/28  15:52:21  matthew
 *  Added environment options to preferences
 *
 *  Revision 1.14  1993/05/27  16:19:19  matthew
 *  Return exit function from list_select
 *  Added bool ref to control destruction of list select widget
 *
 *  Revision 1.13  1993/05/19  13:58:19  daveb
 *  Revised some exceptions and added Mode dialog box.
 *
 *  Revision 1.12  1993/05/13  18:44:15  daveb
 *  Changed names of scrolllist widgets to simplify the specification
 *  of resources.
 *
 *  Revision 1.11  1993/05/13  14:26:19  daveb
 *  options_menu now takes a string to use for the title of the options
 *  dialogs.
 *
 *  Revision 1.10  1993/05/12  13:59:13  daveb
 *  Added comment about profligracy in creation of options menus.
 *
 *  Revision 1.9  1993/05/06  13:40:45  daveb
 *  Added make_outstream.
 *
 *  Revision 1.8  1993/05/04  16:59:24  matthew
 *  Added fileselect function
 *
 *  Revision 1.7  1993/04/30  15:53:35  daveb
 *  Moved Editor options dialog to new setup menu.
 *
 *  Revision 1.6  1993/04/28  12:10:42  richard
 *  Unified profiling and tracing options into `intercept'.
 *  Removed poly_makestring option.
 *
 *  Revision 1.5  1993/04/28  10:05:53  daveb
 *  Changes to make_scrolllist.
 *
 *  Revision 1.4  1993/04/27  12:48:50  daveb
 *  Added options_menu code from _listener and _fileselect.
 *
 *  Revision 1.3  1993/04/23  15:11:21  matthew
 *  Added send message function
 *
 *  Revision 1.2  1993/04/21  15:51:07  daveb
 *  Whoops.  Gave myself a fright there.  Checked in an old version.
 *
 *  Revision 1.1  1993/04/21  14:40:52  daveb
 *  Initial revision
 *  
 *
 *)

require "../basis/__text_io";
require "../basis/__io";
require "../basis/__text_prim_io";
require "^.utils.__terminal";

require "capi";
require "menus";
require "../utils/lists";
require "../main/user_options";
require "../utils/crash";
require "../utils/getenv";
require "../main/preferences";
require "../main/machspec";
require "../typechecker/types";
require "../interpreter/shell_utils";
require "../interpreter/user_context";
require "../interpreter/entry";
require "../editor/custom";
require "gui_utils";

functor GuiUtils (
  structure Capi: CAPI 
  structure Lists: LISTS
  structure Crash: CRASH
  structure UserOptions: USER_OPTIONS
  structure Preferences: PREFERENCES
  structure MachSpec : MACHSPEC
  structure Menus: MENUS
  structure UserContext: USER_CONTEXT
  structure Entry: ENTRY
  structure ShellUtils: SHELL_UTILS
  structure Getenv: GETENV
  structure Types : TYPES
  structure CustomEditor: CUSTOM_EDITOR

  sharing UserOptions.Options = ShellUtils.Options = UserContext.Options

  sharing type Menus.Widget = Capi.Widget

  sharing type ShellUtils.preferences = Preferences.preferences
  sharing type ShellUtils.user_preferences = Preferences.user_preferences
  sharing type ShellUtils.Context = UserContext.Context = Entry.Context

  sharing type UserOptions.user_tool_options = ShellUtils.UserOptions
  sharing type UserOptions.user_context_options =
	       UserContext.user_context_options
  sharing type ShellUtils.user_context = UserContext.user_context
  sharing type Entry.options = UserOptions.Options.options
): GUI_UTILS =
struct

  structure Options = UserOptions.Options

  type Widget = Capi.Widget
  type ButtonSpec = Menus.ButtonSpec
  type OptionSpec = Menus.OptionSpec
  type Type = ShellUtils.Type

  type user_tool_options = UserOptions.user_tool_options
  type user_context_options = UserOptions.user_context_options
  type user_preferences = Preferences.user_preferences
  type user_context = UserContext.user_context

  val print = Terminal.output

(*
  fun make_outstream insert_text =
    let
      val outbuff = ref [] : string list ref

      (* Motif text widgets don't scroll nicely with multi-line output *)
      (* So break up into nl-terminated lines *)
      (* This could probably all be made a lot more efficient *)

      fun make_strings sl =
        let 
          fun foo ([],[],acc) = rev acc
            | foo ([],l,acc) = rev (implode (rev l) :: acc)
            | foo (#"\n"::rest,l,acc) = foo (rest,[],(implode (rev (#"\n"::l)))::acc)
            | foo (c::rest,l,acc) = foo (rest,c::l,acc)
        in
          foo (explode (concat (rev sl)),[],[])
        end

      fun flush_buffer () =
        let val strings = (make_strings (!outbuff))
        in
          outbuff := [];
          app insert_text strings
        end

      fun output_fn s =
        let
          fun has_nl 0 = false
            | has_nl n =
              if MLWorks.String.ordof (s,n-1) = ord #"\n"
                then true
              else
                has_nl (n-1)
        in
          outbuff := s :: !outbuff;
          if has_nl (size s) then
            flush_buffer()
          else ()
        end
    in
      MLWorks.IO.outstream {output = output_fn,
                            flush_out = flush_buffer,
                            close_out = fn () => (),
			    closed_out = fn () => false}
    end
*)

  fun make_outstream insert_text =
    let
      fun writeVec{buf, i, sz} =
	let
	  val len = case sz of
	    NONE => size buf - i
	  | SOME i => i
	  val _ = insert_text(if i = 0 andalso len = size buf then buf else substring(buf, i, len));
	in
	  len
	end

      val prim_writer =
	TextPrimIO.WR{name = "console writer", 
		      chunkSize = 1, 
		      writeVec = SOME writeVec, 
		      writeArr = NONE,
		      writeVecNB = NONE,
		      writeArrNB = NONE,
		      block = NONE, 
		      canOutput = SOME(fn _ => true), 
		      getPos = NONE, 
		      setPos = NONE, 
		      endPos = NONE,
		      verifyPos = NONE,
		      close = fn _ => (),
		      ioDesc = NONE}

    in
      TextIO.mkOutstream(TextIO.StreamIO.mkOutstream(TextPrimIO.augmentWriter prim_writer, IO.NO_BUF))
    end

  datatype Writable = WRITABLE | ALL

  val title_for_global_dialogs = "MLWorks Preferences"

  (* A MotifContext combines options dialogs with a user_context *)
  abstype MotifContext =
      SHORT_MOTIF_CONTEXT of		(* was used when full_menus = false *)
        {user_context: user_context,
         mode_dialog: unit -> unit,
         update_fn: unit -> unit}
    | FULL_MOTIF_CONTEXT of		(* currently always used *)
        {user_context: user_context,
         mode_dialog: unit -> unit,
         compiler_dialog: unit -> unit,
         language_dialog: unit -> unit,
         update_fn: unit -> unit}
  with
    fun get_user_context (SHORT_MOTIF_CONTEXT r) = #user_context r
    |   get_user_context (FULL_MOTIF_CONTEXT r) = #user_context r;

    fun get_context_name m =
      UserContext.get_context_name (get_user_context m)

    val context_list = ref []

    fun get_mode_dialog (FULL_MOTIF_CONTEXT r) = #mode_dialog r
    |   get_mode_dialog (SHORT_MOTIF_CONTEXT r) = #mode_dialog r

    fun get_compiler_dialog (FULL_MOTIF_CONTEXT r) = #compiler_dialog r
    |   get_compiler_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_compiler_dialog"

    fun get_language_dialog (FULL_MOTIF_CONTEXT r) =
      #language_dialog r
    |   get_language_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_language_dialog"

    fun make_context (user_context, parent, user_preferences) =
        let
	  (* Each MotifContext contains a user_context, which contains a set
	     of user_context_options.  The MotifContext also contains a number
	     of dialog boxes.  When the options are updated, the dialog boxes
	     must be updated to match them.  This is done by storing update
	     functions in the user_context_options. *)
	  val user_context_options = UserContext.get_user_options user_context

	  val UserOptions.USER_CONTEXT_OPTIONS (options, update_fns) =
	    user_context_options

          fun set_context_option_fun f a =
            ((f options) := a;
	     true)
             
          fun get_context_option_fun f () =
            !(f options)
              
          fun int_context_widget (name, accessor) =
            Menus.OPTINT
	      (name,
	       get_context_option_fun accessor,
	       set_context_option_fun accessor)
              
          fun bool_context_widget (name, accessor) =
            Menus.OPTTOGGLE
	      (name,
	       get_context_option_fun accessor,
	       set_context_option_fun accessor)

          fun do_update () = app (fn f => f ()) (!update_fns);

	  fun is_sml'97 _ = 
	     UserOptions.is_sml'97 user_context_options

	  fun sml'97 true =
	    (UserOptions.select_sml'97 user_context_options;
             Types.real_tyname_equality_attribute := false;
	     true)
	    | sml'97 false = true

	  fun is_compatibility _ = 
	     UserOptions.is_compatibility user_context_options

	  fun compatibility true =
	    (UserOptions.select_compatibility user_context_options;
	     true)
	  |   compatibility false = true

	  fun is_sml'90 _ = 
	     UserOptions.is_sml'90 user_context_options

	  fun sml'90 true =
	    (UserOptions.select_sml'90 user_context_options;
             Types.real_tyname_equality_attribute := true;
	     true)
	    | sml'90 false = true

	  fun is_quick_compile _ = 
	     UserOptions.is_quick_compile user_context_options

	  fun quick_compile true = 
	    (UserOptions.select_quick_compile user_context_options;
	     true)
	    | quick_compile false = true

	  fun is_optimizing _ = 
	     UserOptions.is_optimizing user_context_options

	  fun optimizing true =
	    (UserOptions.select_optimizing user_context_options;
	     true)
	    | optimizing false = true

	  fun is_debugging _ = 
	    UserOptions.is_debugging user_context_options

	  fun debugging true =
	    (UserOptions.select_debugging user_context_options;
	     true)
	    | debugging false = true

	  val Preferences.USER_PREFERENCES (user_preferences, _) =
	    user_preferences

	  val full_menus = !(#full_menus user_preferences)

          fun popup_mode_options parent =
            Menus.create_dialog
            (parent,
	     title_for_global_dialogs,
             "modeOptions",
             do_update,
             [Menus.OPTLABEL "modeOptionsLabel",
              Menus.OPTSEPARATOR,
	      Menus.OPTRADIO
	        [Menus.OPTTOGGLE ("sml_97", is_sml'97, sml'97),
                 Menus.OPTTOGGLE ("sml_90", is_sml'90, sml'90),
                 Menus.OPTTOGGLE
		   ("compatibilityMode", is_compatibility, compatibility)],
              Menus.OPTSEPARATOR,
	      Menus.OPTRADIO
		[Menus.OPTTOGGLE ("debugging", is_debugging, debugging),
		 Menus.OPTTOGGLE ("quick_compile", is_quick_compile, quick_compile),
		 Menus.OPTTOGGLE ("optimizing", is_optimizing, optimizing)]])

          val (mode_dialog,mode_dialog_update) =
	    popup_mode_options parent

        in
	    let
              fun popup_compiler_options parent =
                Menus.create_dialog
                (parent,
	         title_for_global_dialogs,
                 "compilerOptions",
                 do_update,
                 [Menus.OPTLABEL "compilerOptionsLabel",
                  Menus.OPTSEPARATOR,
	          bool_context_widget
	  	  ("generateInterruptableCode", #generate_interruptable_code),
                  bool_context_widget
	  	  ("generateInterceptableCode", #generate_interceptable_code),
                  bool_context_widget
	  	  ("generateDebugInfo", #generate_debug_info),
                  bool_context_widget
                  ("generateVariableDebugInfo",#generate_variable_debug_info)]
	  	(*
                  bool_context_widget
	  	  ("generatePolyVariableDebugInfo",
	  	   #generate_polyvariable_debug_info),
                  bool_context_widget("generateModuler", #generate_moduler),
	  	*)
                 @@ [Menus.OPTSEPARATOR,
                    bool_context_widget("optimizeLeafFns", #optimize_leaf_fns),
                    bool_context_widget
		      ("optimizeTailCalls", #optimize_tail_calls),
                    bool_context_widget
	  	      ("optimizeSelfTailCalls",#optimize_self_tail_calls)]
                 @@ 
                 (case MachSpec.mach_type of
                    MachSpec.MIPS => 
                      [Menus.OPTSEPARATOR,
                       bool_context_widget("mipsR4000", #mips_r4000)]
                  | MachSpec.SPARC => 
                      [Menus.OPTSEPARATOR,
                       bool_context_widget("sparcV7", #sparc_v7)]
                  | MachSpec.I386 => 
                      []))
              fun popup_language_options parent =
                Menus.create_dialog
                (parent,
	         title_for_global_dialogs,
                 "languageOptions",
                 do_update,
                 [Menus.OPTLABEL "compatibilityOptionsLabel",
                  Menus.OPTSEPARATOR,
                  (* Need to set the tyname attribute appropriately *)
                  Menus.OPTTOGGLE ("oldDefinition",
                                   get_context_option_fun #old_definition,
                                   fn b =>
                                   (Types.real_tyname_equality_attribute := b;
                                    set_context_option_fun #old_definition b)),
                  bool_context_widget("abstractions",#abstractions),
                  bool_context_widget("opInDatatype", #nj_op_in_datatype),
                  bool_context_widget("njSignatures", #nj_signatures),
                  bool_context_widget("weakTyvars", #weak_type_vars),
                  bool_context_widget("fixitySpecs", #fixity_specs),
                  bool_context_widget("openFixity", #open_fixity),
                  Menus.OPTSEPARATOR,
                  Menus.OPTLABEL "extensionsOptionsLabel",
                  Menus.OPTSEPARATOR,
                  bool_context_widget("requireKeyword",#require_keyword),
                  bool_context_widget("typeDynamic",#type_dynamic)
	  	(*
                  bool_context_widget("defaultOverloads", #default_overloads)
	  	*)
                  ])
                
              val (compiler_dialog,compiler_dialog_update) =
	        popup_compiler_options parent

              val (language_dialog,language_dialog_update) =
	        popup_language_options parent

              fun update_dialogues () =
                app
                (fn f => f ()) 
                [mode_dialog_update,
                 compiler_dialog_update,
                 language_dialog_update]

	      val result = 
                FULL_MOTIF_CONTEXT
                  {user_context = user_context,
	           mode_dialog = mode_dialog,
	  	   compiler_dialog = compiler_dialog,
	  	   language_dialog = language_dialog,
	           update_fn = update_dialogues}
	    in
	      context_list := result :: !context_list;
	      update_fns := [update_dialogues];
	      result
	    end
        end
  end (* abstype MotifContext *)
       
  (* The code for managing the initial MotifContext is similar to that for
     managing the initial UserContext (in the structure of that ilk). *)
  val initialContext = ref NONE

  fun makeInitialContext (parent, user_preferences) =
    let
      val user_context = UserContext.getInitialContext ()

      val motif_context =
	make_context (user_context, parent, user_preferences)
    in
      initialContext := SOME motif_context;
      context_list := [motif_context]
    end

  fun getInitialContext () =
    case !initialContext
    of SOME c => c
    |  _ => Crash.impossible "Bad initial motif context!"

  fun save_history (prompt, user_context, applicationShell) =
    let
      val filename_opt =
        if prompt then
          Capi.save_as_dialog (applicationShell, ".sml")
        else
          case UserContext.get_saved_file_name user_context
          of NONE =>
            Capi.save_as_dialog (applicationShell, ".sml")
          |  x => x
    in
      case filename_opt of
        NONE => ()
      | SOME filename =>
        let
          val file = TextIO.openOut filename

          (* examine_source checks whether the source ends with a
             semi-colon, and if so whether the semicolon is followed
             by a newline.  It skips trailing white space. *)
          fun examine_source (s, ~1, seen_newline) =
            (false, false)
          |   examine_source (s, n, seen_newline) =
            let
              val c = MLWorks.String.ordof (s, n)
            in
              if c = ord #";" then
                (true, seen_newline)
              else if c = ord #"\n" then
                examine_source (s, n-1, true)
              else if c = ord #" " orelse c = ord #"\t" then
                examine_source (s, n-1, seen_newline)
              else
                (false, false)
            end

          fun massage_source s =
            let
              val (has_semicolon, has_newline) =
                examine_source (s, size s - 1, false)
            in
              s ^ (if has_semicolon then "" else ";")
                ^ (if has_newline then "" else Capi.terminator)
            end

          fun write_hist (UserContext.ITEM {source, ...}) =
	    case source
	    of UserContext.STRING str =>
              TextIO.output (file, massage_source str)
	    |  _ => ()

          val context_name = UserContext.get_context_name user_context

          val hist = UserContext.get_history user_context
        in
          app write_hist (rev hist);
          TextIO.flushOut file;
          TextIO.closeOut file;
          Capi.send_message
		(applicationShell, "Saved " ^ context_name ^ " to " ^ filename);
          UserContext.set_saved_file_name (user_context, filename)
        end
        handle IO.Io _ => ()
    end

  fun null_history user_context =
    let
	  val hist = UserContext.get_history user_context
    in
	  length hist = 0
    end

  fun save_name_set user_context =
    case UserContext.get_saved_file_name user_context
    of NONE => false
    |  SOME _ => true

  fun make_search_dialog (shell, get_context, action_fn, choose_contexts) =
    let
      fun flat (x::xs) = (concat x ^ "\n") :: (flat xs)
        | flat [] = []
              
      val searchOptions =
        {showSig = ref true,
         showStr = ref true,
         showFun = ref true,
         searchInitial = ref choose_contexts,
         searchContext = ref choose_contexts,
         showType = ref false}
      
      fun mkSearchOptions
            {showSig, showStr, showFun, searchInitial,
	     searchContext, showType} =
	Entry.SEARCH_OPTIONS
	  {showSig = !showSig,
	   showStr = !showStr,
	   showFun = !showFun,
	   searchInitial = !searchInitial,
	   searchContext = !searchContext,
	   showType = !showType}

      val searchString = ref ""
	
         
      fun search s =
        let
          fun getItemsFromContext c =
	    let
              val context = UserContext.get_delta (get_user_context c)
            in
              Entry.context2entry context
            end
                            
          fun grep regexp line =
            let
              fun startsWith [] ys = true
                | startsWith xs [] = false
                | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
              fun check [] ys = false
                | check xs [] = false
                | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
            in
              check (explode regexp) (explode line)
            end (* grep *)
        
          val _ = searchString := s
	  
          val context_list =
            if !(#searchInitial searchOptions) then
	      if !(#searchContext searchOptions) then
                getItemsFromContext(getInitialContext())
                @@ getItemsFromContext (get_context ())
	      else
                getItemsFromContext(getInitialContext())
            else
              getItemsFromContext (get_context ())

          val options = Options.default_options

          (* datatype Entry is a linear structure, munge to tree like form *)
          val entrys = map Entry.massage context_list
          val entrys' =
	    Entry.printEntry1
	      (mkSearchOptions searchOptions, options, entrys)

          val found = map #1 (Lists.filterp (fn (_,name) => grep s name) entrys')
          val _ =
	    Capi.list_select
              (shell, "searchList", fn _ => ())
              (found, action_fn, fn x => x)
        in
	  ()
        end (* search *)

      fun getter r () = !r
      fun setter r b = (r := b; true)
      fun toggle (s, r) = Menus.OPTTOGGLE(s, getter r, setter r)

      val tail = 
	if choose_contexts then
          [Menus.OPTSEPARATOR,
           toggle ("searchPervasives",#searchInitial searchOptions),
           toggle ("searchUserContext",#searchContext searchOptions)]
	else
	  []

      val search_for = ref NONE

      val searchSpec =
        [Menus.OPTTEXT
         ("itemSearch", fn () => !searchString , 
                        fn s  => (search_for := SOME s; true)),
         Menus.OPTSEPARATOR,
         Menus.OPTLABEL "Search inside...",
         Menus.OPTSEPARATOR,
         toggle ("signatures", #showSig searchOptions),
         toggle ("functors", #showFun searchOptions),
	 Menus.OPTSEPARATOR,
         toggle ("displayEntryTypes", #showType searchOptions)]
	@@ tail
    in
      Menus.create_dialog
        (shell, "Search Dialog", "browserDialog", 
         fn () => (case !search_for of NONE => () | SOME s => (search s; ())), 
         searchSpec)
    end


  fun search_button (shell, get_context, action_fn, choose_contexts) =
    let
      val (searchPopup, _) =
        make_search_dialog (shell, get_context, action_fn, choose_contexts)
    in
      Menus.PUSH ("search", searchPopup, fn _ => true)
    end

  (* All option dialogs for context-specific options are created once for
     each context.  The context menu must get the correct dialogs. (Currently
     the options are on the setup menu instead.  This is temporary). *)
  fun context_menu
	{set_state, get_context, writable, applicationShell,
         shell, user_preferences} =
    let
      val Preferences.USER_PREFERENCES (preferences_record, _) =
	user_preferences

      fun get_current_user_context () =
        get_user_context (get_context ())
      
      (* If full_menus is set, then users can create multiple contexts
	 and select between them.  *)
      val tail_menu =
        if !(#full_menus preferences_record) then
	  let
            fun select_menu () =
	      let
	        fun make_item c =
                  let
	            val name = get_context_name c
                  in
	            Menus.PUSH (name, fn _ => set_state c, fn _ => true)
                  end
      
	        val contexts =
	          if writable = WRITABLE then
	            Lists.filter_outp
	              (UserContext.is_const_context o get_user_context)
		      (!context_list)
	          else
                    !context_list
	      in
                map make_item contexts
	      end
      
            fun push_state _ =
	      set_state
	        (make_context
	           (UserContext.copyUserContext (get_current_user_context ()),
	            applicationShell, user_preferences))
      
            fun initialContext _ =
	            set_state
	        (make_context
	          (UserContext.getNewInitialContext (),
	           applicationShell, user_preferences))
      
            val is_constant =
    	      UserContext.is_const_context o get_current_user_context

	    val sub_tail =
              [Menus.SEPARATOR,
               Menus.DYNAMIC ("contextSelect", select_menu, fn _ => true)]
	  in
	    (* A tool can only create new contexts if it can write to them. *)
            if writable = WRITABLE then
              [Menus.SEPARATOR,
	       Menus.PUSH ("pushContext", push_state, fn _ => true),
               Menus.PUSH ("initialContext", initialContext, fn _ => true)]
	      @@ sub_tail
	    else
	      sub_tail
	  end
	else
	  []

      val save_items =
	if UserContext.is_const_context (get_current_user_context ()) then
	  []
	else
          [Menus.PUSH
             ("save",
              fn _ =>
	        save_history
		  (false, get_current_user_context (), shell),
              fn _ => not (null_history (get_current_user_context ()))
		          andalso save_name_set (get_current_user_context ())),
           Menus.PUSH
             ("saveAs",
              fn _ =>
                save_history
	          (true, get_current_user_context (), shell),
              fn _ => not (null_history (get_current_user_context ())))]
    in
      Menus.CASCADE
        ("context", save_items @@ tail_menu, fn _ => true)
    end

    fun listener_properties (parent, get_context) = 
      let
        fun popup_mode_dialog _ =
	  (get_mode_dialog (get_context ())) ()
          
        fun popup_compiler_dialog _ =
	  (get_compiler_dialog (get_context ())) ()
          
        fun popup_language_dialog _ =
	  (get_language_dialog (get_context ())) ()
      in
	Menus.CASCADE ("listen_props", 
	  [Menus.PUSH("mode", popup_mode_dialog, fn _ => true),
	   Menus.PUSH("compiler", popup_compiler_dialog, fn _ => true),
	   Menus.PUSH("language", popup_language_dialog, fn _ => true)],
	  fn _ => true)
      end

    fun setup_menu (parent, get_context, user_preferences, get_user_context_options) =
      let
        (* When the preferences are updated, the dialog boxes must be
           updated to match them.  This is done by storing update
           functions in the user_preferences. *)
        val Preferences.USER_PREFERENCES (preferences, update_fns) =
          user_preferences

        fun preference_update () = () 

        fun set_preference_fun f a =
          ((f preferences) := a;
	   true)

        fun get_preference_fun f () =
          !(f preferences)

        fun popup_editor_options parent =
          Menus.create_dialog
          (parent,
           title_for_global_dialogs,
	   "editorOptions",
           preference_update,
           [Menus.OPTLABEL "editorOptionsLabel",
            Menus.OPTSEPARATOR,
	    Menus.OPTRADIO 
                [Menus.OPTTOGGLE ("select_external_editor",
                             fn () => case get_preference_fun (#editor) () of
  			                "External" => true
  			              | _ => false,
                             fn true => set_preference_fun (#editor) "External"
                              | false => true),
                 Menus.OPTTOGGLE ("select_one_way_editor",
                             fn () => case get_preference_fun (#editor) () of
  			                "OneWay" => true
  			              | _ => false,
                             fn true => set_preference_fun (#editor) "OneWay"
                              | false => true),
		 Menus.OPTTOGGLE ("select_two_way_editor",
				  fn () => case get_preference_fun (#editor) () of
					"TwoWay" => true
				      | _ => false,
				  fn true => set_preference_fun (#editor) "TwoWay"
				   | false => true)],
	    Menus.OPTTEXT ("external_editor_command",
			   get_preference_fun (#externalEditorCommand),
			   set_preference_fun (#externalEditorCommand)),
	    Menus.OPTLABEL "editorOneWayLabel",
	    Menus.OPTCOMBO ("one_way_editor_name",
			   fn () => (
			      get_preference_fun (#oneWayEditorName) (),
			      CustomEditor.commandNames()),
			   set_preference_fun (#oneWayEditorName)),
	    Menus.OPTLABEL "editorTwoWayLabel",
	    Menus.OPTCOMBO ("two_way_editor_name",
			   fn () => (
			      get_preference_fun (#twoWayEditorName) (),
			      CustomEditor.dialogNames()),
			   set_preference_fun (#twoWayEditorName))])

        fun popup_environment_options parent =
            Menus.create_dialog
              (parent,
               title_for_global_dialogs,
	       "environmentOptions",
               preference_update,
               [Menus.OPTLABEL "environmentOptionsLabel",
                Menus.OPTSEPARATOR,
                Menus.OPTINT ("maximumHistoryLength",
                              get_preference_fun (#history_length),
                              fn x =>
			      x > 0 andalso
			      (set_preference_fun (#history_length) x)),
                Menus.OPTINT ("maximumNumberErrors",
                              get_preference_fun (#max_num_errors),
                              fn x  =>
			      x > 0 andalso
			      (set_preference_fun (#max_num_errors) x)),
                Menus.OPTTOGGLE ("useRelativePathname",
                                 get_preference_fun (#use_relative_pathname),
                                 set_preference_fun (#use_relative_pathname)),
                Menus.OPTTOGGLE ("completionMenu",
                                 get_preference_fun (#completion_menu),
                                 set_preference_fun (#completion_menu)),
                Menus.OPTTOGGLE ("useDebugger",
                                 get_preference_fun (#use_debugger),
                                 set_preference_fun (#use_debugger)),
                Menus.OPTTOGGLE ("useErrorBrowser",
                                 get_preference_fun (#use_error_browser),
                                 set_preference_fun (#use_error_browser)),
                Menus.OPTTOGGLE ("windowDebugger",
                                 get_preference_fun (#window_debugger),
                                 set_preference_fun (#window_debugger))])

        val (editor_dialog,editor_update) =
          popup_editor_options parent

        val (environment_dialog,environment_update) =
          popup_environment_options parent

        fun save_preferences _ =
          case Getenv.get_preferences_filename () of
            NONE => ()
          | SOME pathname =>
              let
                val outstream = TextIO.openOut pathname
              in
                (Preferences.save_to_stream (user_preferences,outstream);
                 UserOptions.save_to_stream (get_user_context_options(),outstream))
                handle exn => (TextIO.closeOut outstream; raise exn);
                TextIO.closeOut outstream
              end

      in
	update_fns := editor_update :: environment_update :: !update_fns;

	[("editor", fn _ => editor_dialog (), fn _ => true),
	 ("environment", fn _ => environment_dialog (), fn _ => true),
	 ("savePreferences", save_preferences, fn _ => true)]
      end

    datatype ViewOptions = SENSITIVITY | VALUE_PRINTER | INTERNALS

    (* This function creates the dialogs when the menu is created.
       This prevents the same dialog being created twice for each window. *)
    (* The caller_update_fn allows the calling tool to be updated as a
       result of setting an option - e.g. making a tool newly sensitive 
       to the current selection. *)
    fun view_options
	  {parent, title, user_options, user_preferences,
	   caller_update_fn, view_type} =
      let
        val UserOptions.USER_TOOL_OPTIONS (options, update_fns) =
          user_options

        val Preferences.USER_PREFERENCES (preferences, _) =
	  user_preferences

        fun set_tool_option_fun f a =
          ((f options) := a;
	   true)
           
        fun get_tool_option_fun f () =
          !(f options)
            
        fun int_tool_widget (name, accessor) =
          Menus.OPTINT
	    (name,
	     get_tool_option_fun accessor,
	     set_tool_option_fun accessor)
            
        fun bool_tool_widget (name, accessor) =
          Menus.OPTTOGGLE
	    (name,
	     get_tool_option_fun accessor,
	     set_tool_option_fun accessor)

        fun do_update () =
          (app
	     (fn f => f ())
	     (!update_fns);
	   caller_update_fn user_options)

        fun popup_valueprinter_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "valuePrinterOptions",
           do_update,
           [Menus.OPTLABEL "valuePrinterOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_tool_widget("showFnDetails",#show_fn_details),
            bool_tool_widget("showExnDetails",#show_exn_details),
            int_tool_widget("floatPrecision",#float_precision),
            int_tool_widget("maximumSeqSize",#maximum_seq_size),
            int_tool_widget("maximumStringSize",#maximum_string_size),
            int_tool_widget("maximumDepth",#maximum_depth),
            int_tool_widget("maximumRefDepth",#maximum_ref_depth),
            int_tool_widget("maximumSigDepth",#maximum_sig_depth),
            int_tool_widget("maximumStrDepth",#maximum_str_depth)
            ])
              
        fun popup_sensitivity_options parent =
          Menus.create_dialog
          (parent,
	   title,
           "sensitivityOptions",
           do_update,
           [Menus.OPTLABEL "sensitivityOptionsLabel",
            Menus.OPTSEPARATOR]
	   @@ (if !(#full_menus preferences) then
                [bool_tool_widget("senseContext",#sense_context),
                 bool_tool_widget("setContext",#set_context)]
	      else
	        []))

        fun popup_internals_options parent =
          Menus.create_dialog
          (parent,
           title,
           "internalsOptions",
           do_update,
           [Menus.OPTLABEL "internalsOptionsLabel",
            Menus.OPTSEPARATOR,
            bool_tool_widget("showAbsyn",#show_absyn),
            bool_tool_widget("showLambda",#show_lambda),
            bool_tool_widget("showOptLambda",#show_opt_lambda),
            bool_tool_widget("showEnviron",#show_environ),
            bool_tool_widget("showMir",#show_mir),
            bool_tool_widget("showOptMir",#show_opt_mir),
            bool_tool_widget("showMach",#show_mach)])

	fun add_item (menu_spec, SENSITIVITY) =
	  if !(#full_menus preferences) then
	    let
              val (sensitivity_dialog, sensitivity_dialog_update) =
	        popup_sensitivity_options parent
	    in
	      update_fns := sensitivity_dialog_update :: !update_fns;
              Menus.PUSH
	        ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true) ::
		menu_spec
	    end
	  else
	    menu_spec
	|   add_item (menu_spec, VALUE_PRINTER) =
	  let
            val (valueprinter_dialog, valueprinter_dialog_update) =
	      popup_valueprinter_options parent
	  in
	    update_fns := valueprinter_dialog_update :: !update_fns;
            Menus.PUSH
	      ("valueprinter", fn _ => valueprinter_dialog (), fn _ => true) ::
	      menu_spec
	  end
	|   add_item (menu_spec, INTERNALS) =
	  let
            val (internals_dialog, internals_dialog_update) =
              popup_internals_options parent
	  in
	    update_fns := internals_dialog_update :: !update_fns;
            Menus.PUSH
	      ("internals", fn _ => internals_dialog (), fn _ => true) ::
	      menu_spec
	  end
      in
	update_fns := [];
	Menus.CASCADE ("dummy", Lists.reducel add_item ([], rev view_type), fn () => false)
      end
              
  local

    val do_debug = false
    fun debug s = if do_debug then Terminal.output(s ^ "\n") else ()

  in
    fun value_menu {parent, user_preferences, inspect_fn, get_value, enabled, tail} =
	let
	  val current_item = ref NONE : (string * (MLWorks.Internal.Value.T * Type)) option ref

	  fun message_fun s =
            Capi.send_message (parent, s)

          fun set_current_item () =
	    current_item := get_value ()

          fun is_current_item _ =
            case !current_item of
              NONE => false
            | _ => true

          fun get_current_item _ =
            case !current_item of
              NONE => Crash.impossible "get_current_item"
            | SOME x => x

          fun get_current_value _ = #1 (#2 (get_current_item ()))
          (* This happens to be the first function called *)
          (* Really there should be a separate "popdown" function *)
	  fun object_editable _ =
	     (set_current_item ();
              is_current_item () andalso enabled andalso
              ShellUtils.object_editable (get_current_value ()))

	  fun object_traceable _ =
            (set_current_item (); is_current_item () andalso enabled andalso
            ShellUtils.object_traceable (get_current_value()))

	  fun edit_object _ =
	    let
              val preferences = Preferences.new_preferences user_preferences
	    in
	      (ignore(ShellUtils.edit_object (get_current_value (), preferences));())
	      handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
	    end

	  fun trace_object _ = ShellUtils.trace (get_current_value())

	  fun untrace_object _ = ShellUtils.untrace(get_current_value())

          val (inspect_object,object_inspectable) =
            case inspect_fn of
              SOME f => (f o get_current_item,
			fn () => (set_current_item(); is_current_item() andalso enabled))
            | _ => (fn _ => Crash.impossible "inspect_fn",fn _ => false)
	in
	   Menus.CASCADE ("value",
			  [Menus.PUSH ("editSource",
				       edit_object,
				       object_editable),
                           Menus.PUSH ("inspect",
                                       inspect_object,
                                       object_inspectable),
			   Menus.PUSH ("trace",
				       trace_object,
				       object_traceable),
			   Menus.PUSH ("untrace",
				       untrace_object,
				       object_traceable)]
			  @@ (case tail
			     of [] => []
			     |  l => Menus.SEPARATOR :: l),
			  fn _ => true)
	end
  end



  local
     fun test_val (r,v) = (fn _ => (!r = v))
     fun set_val  (r,v) = (fn b => ((if b then (r := v) else ());
				    true))

     fun test_ref (r) = (fn _ => !r)
     fun set_ref (r) = (fn n => (r := n;
				 true))
  in
     fun toggle_value (s,r,v)  = Menus.OPTTOGGLE  (s, test_val(r,v), set_val(r,v))
     fun bool_value (s,r)      = Menus.OPTTOGGLE  (s,test_ref r, set_ref r)
     fun text_value (s,r)      = Menus.OPTTEXT    (s,test_ref r, set_ref r)
     fun int_value (s,r)       = Menus.OPTINT     (s,test_ref r, set_ref r)
  end

  (* local functions for the make_history function *)
  local
    (* One day we will have an option for this *)
    fun get_max_history_width user_options = 30

    fun contains_nasty_chars s =
      let
        fun aux n =
          if n = 0 then false
            else
              let val chr = MLWorks.String.ordof(s,n-1)
              in
                if chr = ord #"\n" orelse chr = ord #"\t"
                  then true
                else aux (n-1)
              end
      in
        aux (size s)
      end
  
    fun remove_nasty_chars s =
      let fun subst #"\n" = #" "
            | subst #"\t" = #" "
            | subst c = c
      in
        implode (map subst (explode s))
      end

    fun trim_history_string (s,user_options) =
      let
        val max_width = get_max_history_width user_options
        val trim_string =
          if size s > max_width
            then substring (* could raise Substring *)(s,0,max_width - 2) ^ ".."
          else s
      in
        if contains_nasty_chars trim_string
          then remove_nasty_chars trim_string
        else trim_string
      end
    
    (* There is no need to go throught an options structure for this. *)
    fun get_max_history_length user_preferences =
      let
        val Preferences.USER_PREFERENCES ({history_length,...}, _) =
          user_preferences
      in
        !history_length
      end
        
    fun whitespacep x =
      case x of
        #" " => true
      | #"\n" => true
      | #"\t" => true
      | #"\012" => true
      | #"\013" => true
      | _ => false

    fun strip_whitespace s =
      let
        fun strip [] = []
          | strip (l as (a::b)) =
            if whitespacep a then strip b else l
      in
        implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
      end
  
  in
    (* tool-specific input history *)
    fun make_history (user_preferences, use_entry) =
      let
        (* The history is a list of string * int pairs, where the int is an
	   index number.  The index is used to set the current_index ref when
	   a string is selected from the menu.  The current_index ref is also
	   adjusted by the next_history and prev_history commands, which step
	   forward and back through the history list. *)
  
        val history = ref []: (string * int) list ref;
        val history_size = ref 0;
        val initial_index = ~1;
        val history_index = ref initial_index;

        fun add_history_entry "" = ()
        |   add_history_entry item =
          let
            fun aux ([], _) = ([], 0)
            |   aux ((s,i)::l, ix) =
              if ix <= 1 then
	        ([], 0)
              else if s = item then
		(l, i)
              else
		let
		  val (l, i) = aux (l, ix - 1)
		in
                  ((s, i) :: l, i + 1)
		end

	    val (new_history, new_size) =
              aux (!history, get_max_history_length user_preferences)
          in
	    history := (item, new_size) :: new_history;
	    history_size := new_size + 1
          end

        fun update_history l =
          (app (add_history_entry o strip_whitespace) l;
 	   history_index := initial_index)
  
        fun prev_history () =
          let val _ = history_index := !history_index + 1
              val line = #1 (Lists.nth (!history_index, !history))
          in
	    use_entry line
          end
          handle Lists.Nth => history_index := !history_index - 1;
  
        fun next_history () =
          let val _ = history_index := !history_index - 1;
              val line = #1 (Lists.nth (!history_index, !history))
                         handle
                           Lists.Nth =>
                             (history_index := initial_index;
                              ""  (* empty input *))
          in
	    use_entry line
          end
  
        fun history_end () = !history_index = initial_index
        fun history_start () = !history_index = !history_size - 1
  
        fun warp_history string =
          trim_history_string (string, user_preferences)
  
        val history_menu =
           Menus.DYNAMIC
	     ("history",
              fn () =>
		map
		  (fn (s,i) =>
		     Menus.PUSH
		       (warp_history s,
                        fn _ =>
			  (history_index := !history_size - i - 1;
			   use_entry s),
                        fn _ => true))
                  (!history),
              fn _ => !history <> [])
  
      in
        {update_history = update_history,
         prev_history = prev_history,
         next_history = next_history,
         history_end = history_end,
         history_start = history_start,
         history_menu = history_menu}
      end
  end

end

@


1.83.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.83  1999/02/02  15:59:21  mitchell
 * [Bug #190500]
 * Remove redundant require statements
 *
@


1.82
log
@[Bug #50103]
Evaluate search function after processing check boxes controlling search
@
text
@d4 4
a524 2
require "../basis/__int";
require "../basis/__general";
a527 1
require "../basis/_stream_io";
@


1.81
log
@[Bug #30229]
Group compiler options to allow more flexibility.
@
text
@d4 4
d1100 2
d1104 2
a1105 2
         ("itemSearch", fn () => !searchString , fn s =>(search s;
							 true)),
d1116 3
a1118 1
        (shell, "Search Dialog", "browserDialog", fn ()=>(), searchSpec)
@


1.80
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d4 4
d761 8
d772 2
a773 2
	  fun optimizing b =
	    (UserOptions.select_optimizing (user_context_options, b);
d775 1
d778 1
a778 1
	     UserOptions.is_debugging user_context_options
d780 2
a781 2
	  fun debugging b =
	    (UserOptions.select_debugging (user_context_options, b);
d783 1
d804 4
a807 2
              Menus.OPTTOGGLE ("optimizing", is_optimizing, optimizing),
              Menus.OPTTOGGLE ("debugging", is_debugging, debugging)])
@


1.79
log
@[Bug #30090]
Modify to use TextIO instead of MLWorks.IO
@
text
@d516 3
d581 1
d627 33
d929 1
a929 1
          val file = MLWorks.IO.open_out filename
d962 1
a962 1
              MLWorks.IO.output (file, massage_source str)
d970 2
a971 2
          MLWorks.IO.flush_out file;
          MLWorks.IO.close_out file;
d976 1
a976 1
        handle MLWorks.IO.Io _ => ()
@


1.78
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@d4 4
d515 1
d1283 1
a1283 1
                val outstream = MLWorks.IO.open_out pathname
d1287 2
a1288 2
                handle exn => (MLWorks.IO.close_out outstream; raise exn);
                MLWorks.IO.close_out outstream
@


1.77
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d1351 1
@


1.76
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d1460 1
a1460 1
	      (ShellUtils.edit_object (get_current_value (), preferences);())
@


1.75
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d220 1
a220 1
 * Removed "search in structure" option from the search dialog (because we
d503 1
d563 1
a563 1
  fun print s = MLWorks.IO.output (MLWorks.IO.terminal_out,s)
d1417 1
a1417 1
    fun debug s = if do_debug then MLWorks.IO.output(MLWorks.IO.terminal_out,s ^ "\n") else ()
@


1.74
log
@[Bug #30233]
Make editor interface (dialog) clearer.
@
text
@d4 4
d13 7
a501 1
require "path_tool";
a516 1
  structure PathTool: PATH_TOOL
d532 1
a532 1
  sharing type Menus.Widget = Capi.Widget = PathTool.Widget
d1142 19
a1160 2
    fun setup_menu 
	(parent, get_context, user_preferences, get_user_context_options) =
a1259 9
        fun popup_mode_dialog _ =
	  (get_mode_dialog (get_context ())) ()
          
        fun popup_compiler_dialog _ =
	  (get_compiler_dialog (get_context ())) ()
          
        fun popup_language_dialog _ =
	  (get_language_dialog (get_context ())) ()
          
d1276 1
a1276 2
	[("mode", popup_mode_dialog, fn _ => true),
	 ("editor", fn _ => editor_dialog (), fn _ => true),
d1278 1
a1278 4
	 ("savePreferences", save_preferences, fn _ => true),
	 ("compiler", popup_compiler_dialog, fn _ => true),
	 ("language", popup_language_dialog, fn _ => true)]

a1279 8

    fun paths_menu parent =
      Menus.CASCADE
      ("paths",
       [Menus.PUSH ("setSourcePath", fn _ => PathTool.sourceCreate parent, fn _ => true),
        Menus.PUSH ("setWD", fn _ => PathTool.setWD parent, fn _ => true)],
       fn _ => true)

@


1.73
log
@[Bug #20088]
Merging from MLWorks_11:
SML'96 should be SML'97
@
text
@d4 5
d502 1
d519 1
d1133 2
a1134 1
    fun setup_menu (parent, get_context, user_preferences, get_user_context_options) =
d1160 1
a1160 7
                [Menus.OPTTOGGLE ("select_emacs_server",
                             fn () => case get_preference_fun (#editor) () of
                             		"EmacsServer" => true
  			     	      | _ => false,
                             fn true => set_preference_fun (#editor) "EmacsServer"
			     |  false => true),
                 Menus.OPTTOGGLE ("select_external_editor",
d1166 1
a1166 1
                 Menus.OPTTOGGLE ("select_custom_editor",
d1168 1
a1168 1
  			                "Custom" => true
d1170 8
a1177 2
                             fn true => set_preference_fun (#editor) "Custom"
                              | false => true)],
d1181 12
a1192 3
	    Menus.OPTTEXT ("custom_editor_name",
			   get_preference_fun (#customEditorName),
			   set_preference_fun (#customEditorName))])
@


1.72
log
@[Bug #30068]
Make Breakpoint and Trace Managers top level tools.
@
text
@d4 4
d660 2
a661 2
	  fun is_sml'96 _ = 
	     UserOptions.is_sml'96 user_context_options
d663 2
a664 2
	  fun sml'96 true =
	    (UserOptions.select_sml'96 user_context_options;
d667 1
a667 1
	    | sml'96 false = true
d714 1
a714 1
	        [Menus.OPTTOGGLE ("sml_96", is_sml'96, sml'96),
@


1.72.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.72  1997/06/09  10:26:49  johnh
 * [Bug #30068]
 * Make Breakpoint and Trace Managers top level tools.
 *
@


1.72.2.2
log
@[Bug #30071]
Move menu items from Usage->GeneralPreferences to Listener->Properties.
@
text
@a3 3
 * Revision 1.72.2.1  1997/09/11  20:52:13  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
a1125 18
    fun listener_properties (parent, get_context) = 
      let
        fun popup_mode_dialog _ =
	  (get_mode_dialog (get_context ())) ()
          
        fun popup_compiler_dialog _ =
	  (get_compiler_dialog (get_context ())) ()
          
        fun popup_language_dialog _ =
	  (get_language_dialog (get_context ())) ()
      in
	Menus.CASCADE ("listen_props", 
	  [Menus.PUSH("mode", popup_mode_dialog, fn _ => true),
	   Menus.PUSH("compiler", popup_compiler_dialog, fn _ => true),
	   Menus.PUSH("language", popup_language_dialog, fn _ => true)],
	  fn _ => true)
      end

d1217 9
d1242 2
a1243 1
	[("editor", fn _ => editor_dialog (), fn _ => true),
d1245 4
a1248 1
	 ("savePreferences", save_preferences, fn _ => true)]
@


1.72.2.3
log
@[Bug #30071]
Remove Paths menu.
@
text
@d489 1
d504 1
d519 1
a519 1
  sharing type Menus.Widget = Capi.Widget
d1258 8
@


1.72.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.72  1997/06/09  10:26:49  johnh
 * [Bug #30068]
 * Make Breakpoint and Trace Managers top level tools.
 *
@


1.71
log
@[Bug #30136]
Removed early-mips-r4000 option.
@
text
@d4 4
a488 1
require "../debugger/newtrace";
a502 1
  structure Trace : TRACE
a1253 286
    (* This makes a widget that allows the entry, deletion and display of a *)
    (* list of strings *) 

    fun make_string_list_manager(parent,name,get,set, print_fn, get_trans, set_trans, member_fn, filter_args) =
      let
        (* Some state *)
        val changed = ref false
	val arg_list = ref []
        val stringlist = ref [] : string list ref
        val set_selected_hook = ref (fn () => ())
	val visible = ref false

        (* Make the widgets *)
	(* The 'visible' argument here is used in _capi to correctly minimize and restore
	 * the window when its grandparent is minimized or restored - only on MSWindows. *)
	val (shell,form,menubar,_) = Capi.make_main_popup (name,name, parent, false, visible)
	val _ = Capi.hide menubar
        val text = Capi.make_managed_widget ("stringInput",Capi.Text,form,[])
        val buttonPane = Capi.make_managed_widget ("listManagerButtonPane", Capi.RowColumn, form, []);

        fun set_selected () = 
          (Capi.set_focus text;
           (!set_selected_hook) ())

        val {scroll,list,set_items,...} = 
          Capi.make_scrolllist
          {parent = form,
           name = "listManagerList", (* Note that this name is ignored *)
           (* Do nothing for the moment *)
           select_fn = fn _ => fn s => (),
           action_fn = fn _ => fn s => (),
           print_fn = print_fn}
          
        val dialogButtons = Capi.make_managed_widget ("dialogButtons", Capi.RowColumn,form,[])

        fun initialize () =
          (changed := false;
	   arg_list := get();
           stringlist := map get_trans (!arg_list))

        fun reset_text _ = Capi.Text.set_string (text,"")
        fun set_list _ = set_items Options.default_print_options (!stringlist)
        fun ok_string s = if s = "" then false else true

        fun text_apply _ = 
          let
            val name = Capi.Text.get_string text
          in
            if ok_string name then 
	      let
		val trans = set_trans name
	      in
		if member_fn(trans, !arg_list) then
		  (arg_list := trans ::
		   Lists.filterp (filter_args trans) (!arg_list);
		   stringlist := map get_trans (!arg_list))
		else
		  (stringlist := get_trans trans :: !stringlist;
		   arg_list := trans :: !arg_list);
		  changed := true;
		  reset_text ();
		  set_list ();
		  set_selected ()
	      end
            else
              ()
          end
                
        fun apply_fn _ = (text_apply (); set (!arg_list); changed := false; set_selected ())

        fun reset _ = (initialize (); reset_text (); set_list (); set_selected ())

        fun do_delete _ =
          let
            fun to_list v =
              let
                val l = MLWorks.Internal.Vector.length v
                fun aux (n,acc) =
                  if n = l then rev acc
                  else aux (n+1,MLWorks.Internal.Vector.sub (v,n) :: acc)
              in
                aux (0,[])
              end
            fun trim ([],_,n,acc) = rev acc
              | trim (l,[],_,acc) = (rev acc) @@ l
              | trim (a::b,n::m,p,acc) =
                if n = p then trim (b,m,p+1,acc)
                else trim (b,n::m,p+1,a :: acc)
            val selected = Lists.msort (op < : int * int -> bool) (to_list (Capi.List.get_selected_pos list))
            val (new_arg_list,newlist) = Lists.unzip (trim (Lists.zip (!arg_list,!stringlist),selected,1,[]))
          in
            stringlist := newlist;
            arg_list := new_arg_list;
            changed := true;
            set_list ();
            set_selected ()
          end
        
        fun delete_all _ =
          (stringlist := [];
           arg_list := [];
           changed := true;
           set_list ();
           set_selected ())
            
        val {update = buttons_update_fn, ...} = 
          Menus.make_buttons
          (dialogButtons,
           [Menus.PUSH ("ok",
                        fn _ => (apply_fn ();
                                 Capi.hide form),
                        fn _ => true),
            Menus.PUSH ("apply",
                        fn _ => apply_fn (),
                        fn _ => !changed),
            Menus.PUSH ("reset",
                        reset,
                        fn _ => !changed),
            Menus.PUSH ("cancel",
                        fn _ => (reset (); Capi.hide form),
                        fn _ => true)])
        val {update = other_buttons_update_fn, ...} =
          Menus.make_buttons
          (buttonPane,
           [Menus.PUSH ("addNameButton",
                        text_apply,
                        fn _ => true),
            Menus.PUSH ("deleteSelectedButton",
                        do_delete,
                        fn _ => true),
            Menus.PUSH ("deleteAllButton",
                        delete_all,
                        fn _ => true)])
      in
        set_selected_hook := buttons_update_fn;
        Capi.Callback.add (text, Capi.Callback.Activate, text_apply);
	Capi.set_close_callback(shell, fn () => (visible := false; Capi.hide shell));
        Capi.Layout.lay_out
        (form,
         [Capi.Layout.SPACE,
          Capi.Layout.FIXED text,
          Capi.Layout.FIXED buttonPane,
          Capi.Layout.FLEX scroll,
          Capi.Layout.SPACE,
          Capi.Layout.FIXED dialogButtons,
          Capi.Layout.SPACE]);
        (fn _ =>
         (reset ();
	  visible := true;
          Capi.reveal form;
          Capi.to_front shell))
      end

    fun breakpoints_menu parent =
      let
        val popup_traces =
          make_string_list_manager (parent,
                                    "Trace Manager",
                                    Trace.traces,
                                    Trace.trace_list,
				    fn _ => fn s => s,
				    fn x => x,
				    fn x => x,
				    Lists.member,
				    fn _ => fn x => true)

	fun find_space(arg as (s, i)) =
	  if i >= size s orelse MLWorks.String.ordof arg = ord #" " then
	    i
	  else
	    find_space(s, i+1)

	fun ignore_spaces(arg as (s, i)) =
	  if i >= size s orelse MLWorks.String.ordof arg <> ord #" " then
	    i
	  else
	    ignore_spaces(s, i+1)

	fun find_colon(arg as (s, i)) =
	  if i >= size s then
	    size s
	  else
	    if MLWorks.String.ordof arg = ord #":" then
	      i
	    else
	      find_colon(s, i+1)

	fun strip_trailing(s, i) =
	  if i <= 0 then s
	  else
	    if i >= size s orelse MLWorks.String.ordof(s, i) = ord #" " then
	      strip_trailing(s, i-1)
	    else
	      substring (* could raise Substring *)(s, 0, i+1)

	fun parse_name name =
	  let
	    val i = ignore_spaces(name, 0)
(*
	    val _ = output(std_out, "Parsing " ^ name ^ " ignores spaces to " ^
			   Int.toString i ^ "\n")
*)
	    val size_name = size name
	  in
	    if i >= size_name then
	      ("<null>", 0)
	    else
	      let
		val i' = find_colon(name, i)
(*
		val _ = output(std_out, "Parsing " ^ name ^ " finds colon at " ^
			       Int.toString i' ^ "\n")
*)
		val n' = substring (* could raise Substring *)(name, i, i'-i)
		val n = strip_trailing(n', size n')
	      in
		if i' >= size_name then
		  (n, 1)
		else
		  let
		    val i'' = ignore_spaces(name, i'+1)
(*
		    val _ = output(std_out, "Parsing " ^ name ^ " ignores spaces to " ^
                      Int.toString i'' ^ "\n")
*)
		  in
		    if i'' >= size_name then
		      (n, 1)
		    else
		      let
			val j = General.valOf (Int.fromString (substring (* could raise Substring *)(name, i'', size_name-i'')))
		      in
			(n, if j < 0 then ~1 else j)
		      end
		  end
	      end
	  end

	fun parse name =
	  let
	    val (name, max) = parse_name name
	  in
	    {name=name, hits=0, max=max}
	  end

	fun member_fn(_, []) = false
	  | member_fn(arg1 as {name, hits, max},
		      {name=name', hits=hits', max=max'} :: rest) =
	    name=name' orelse member_fn(arg1, rest)

	fun filter_fn {name, hits, max} =
	  let
	    fun filter{name=name', hits, max} = name <> name'
	  in
	    filter
	  end

        val popup_breakpoints =
          make_string_list_manager (parent,
                                    "Breakpoint Manager",
                                    Trace.breakpoints,
                                    Trace.break_list,
				    fn _ =>
				    fn s => s,
				    fn {name:string,hits:int,max:int} =>
				    name ^ " : (hits " ^
				    Int.toString hits ^
				    ", maximum " ^
				    (if max >= 0 then
				       Int.toString max
				     else
				       "counting")
				    ^ ")",
				    parse,
				    member_fn,
				    filter_fn)

      in
         [Menus.PUSH ("breakManager",
                      popup_breakpoints,
                      fn _ => true),
          Menus.PUSH ("traceManager",
                      popup_traces,
                      fn _ => true)]

      end
@


1.70
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d4 4
d753 1
a753 2
                       bool_context_widget("mipsR4000", #mips_r4000),
                       bool_context_widget("earlyMipsR4000", #early_mips_r4000)]
@


1.69
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d1232 8
a1239 16
        Menus.CASCADE
	  ("setup",
           [Menus.PUSH ("mode", popup_mode_dialog, fn _ => true),
	    Menus.PUSH ("editor", fn _ => editor_dialog (), fn _ => true),
            Menus.PUSH
	      ("environment", fn _ => environment_dialog (), fn _ => true),
            Menus.PUSH
	      ("savePreferences", save_preferences, fn _ => true),
            Menus.SEPARATOR,
            Menus.CASCADE
	      ("options",
               [Menus.PUSH ("compiler", popup_compiler_dialog, fn _ => true),
                Menus.PUSH
	          ("language", popup_language_dialog, fn _ => true)],
                fn _ => true)],
           fn _ => true)
d1259 1
d1262 4
a1265 2
        val shell = Capi.make_popup_shell (name,parent,[])
        val form = Capi.make_subwindow shell
d1385 1
a1385 1
	Capi.set_close_callback(shell, fn () => Capi.hide shell);
d1397 1
d1406 1
a1406 1
                                    "traceManager",
d1508 1
a1508 1
                                    "breakpointManager",
d1527 6
a1532 8
          Menus.CASCADE ("breakTrace",
                         [Menus.PUSH ("breakManager",
                                      popup_breakpoints,
                                      fn _ => true),
                          Menus.PUSH ("traceManager",
                                      popup_traces,
                                      fn _ => true)],
                         fn _ => true)
a1535 4

    (* view_options doesn't return a complete menu, just the items for
       popping up the options dialogs for the tool-specific options. *)

d1661 1
a1661 1
	Lists.reducel add_item ([], rev view_type)
d1670 1
a1670 1
    fun value_menu {parent, user_preferences, inspect_fn, get_value, tail} =
d1695 1
a1695 1
              is_current_item () andalso 
d1699 2
a1700 2
            is_current_item () andalso
            ShellUtils.object_traceable (get_current_value())
d1716 2
a1717 1
              SOME f => (f o get_current_item,is_current_item)
d1721 1
a1721 1
			  [Menus.PUSH ("edit",
@


1.68
log
@Platform specific compiler options changes
@
text
@d4 3
a516 3
  structure Option = MLWorks.Option

  open MLWorks.Option
d1678 1
a1678 1
	  val current_item = ref NONE : (string * (MLWorks.Internal.Value.T * Type)) Option.option ref
@


1.68.1.1
log
@branched from 1.68
@
text
@a3 3
 * Revision 1.68  1997/03/25  11:26:29  matthew
 * Platform specific compiler options changes
 *
@


1.68.1.2
log
@[Bug #30136]
Hid early_mips_r4000 option from users.
@
text
@a3 3
 * Revision 1.68.1.1  1997/05/12  10:31:29  hope
 * branched from 1.68
 *
d748 2
a749 1
                       bool_context_widget("mipsR4000", #mips_r4000)]
@


1.68.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 4
 * Revision 1.68.1.2  1997/05/19  17:54:58  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.68.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 4
 * Revision 1.68.1.2  1997/05/19  17:54:58  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.68.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 4
 * Revision 1.68.1.2  1997/05/19  17:54:58  daveb
 * [Bug #30136]
 * Hid early_mips_r4000 option from users.
 *
@


1.68.1.2.1.2
log
@[Bug #20088]
Change sml'96 to sml'97.
@
text
@a3 3
 * Revision 1.68.1.2.1.1  1997/07/28  18:17:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d656 2
a657 2
	  fun is_sml'97 _ = 
	     UserOptions.is_sml'97 user_context_options
d659 2
a660 2
	  fun sml'97 true =
	    (UserOptions.select_sml'97 user_context_options;
d663 1
a663 1
	    | sml'97 false = true
d710 1
a710 1
	        [Menus.OPTTOGGLE ("sml_97", is_sml'97, sml'97),
@


1.68.1.2.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.68.1.2.1.2  1997/08/08  17:17:47  daveb
 * [Bug #20088]
 * Change sml'96 to sml'97.
 *
@


1.67
log
@Adding Types structure
@
text
@d4 3
d473 1
d488 1
d740 12
a751 2
	  	      ("optimizeSelfTailCalls",#optimize_self_tail_calls)])
            
@


1.66
log
@[Bug #1854]
Added a call to Capi.set_close_callback.
@
text
@d4 4
d471 1
d490 1
d646 1
d663 1
d745 6
a750 1
                  bool_context_widget("oldDefinition", #old_definition),
d1167 3
@


1.65
log
@[Bug #1728]
__integer becomes __int
@
text
@d4 4
d1355 1
@


1.65.5.1
log
@branched from 1.65
@
text
@a3 4
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.65.4.1
log
@branched from 1.65
@
text
@a3 4
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.65.4.1.1.1
log
@branched from 1.65.4.1
@
text
@a3 3
 * Revision 1.65.4.1  1996/12/17  17:45:11  hope
 * branched from 1.65
 *
@


1.65.3.1
log
@branched from 1.65
@
text
@a3 4
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.65.2.1
log
@branched from 1.65
@
text
@a3 4
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.65.1.1
log
@branched from 1.65
@
text
@a3 4
 * Revision 1.65  1996/11/06  11:16:10  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.65.1.1.1.1
log
@branched from 1.65.1.1
@
text
@a3 3
 * Revision 1.65.1.1  1996/11/14  12:46:06  hope
 * branched from 1.65
 *
@


1.64
log
@[Bug #1724]
Changing toggles to radio buttons in preferences->editor.
@
text
@d4 4
d451 1
a451 1
require "../basis/__integer";
@


1.63
log
@moving String from toplevel
@
text
@d4 3
d1085 1
a1085 1
        fun preference_update () = ()
d1102 2
a1103 1
            Menus.OPTTOGGLE ("select_emacs_server",
d1109 1
a1109 1
            Menus.OPTTOGGLE ("select_external_editor",
d1115 1
a1115 4
	    Menus.OPTTEXT ("external_editor_command",
			   get_preference_fun (#externalEditorCommand),
			   set_preference_fun (#externalEditorCommand)),
            Menus.OPTTOGGLE ("select_custom_editor",
d1120 4
a1123 1
                              | false => true),
@


1.62
log
@[Bug #1519]
The type of UserContext.ITEM has changed.
@
text
@d4 4
d519 2
a520 2
            | foo ([],l,acc) = rev (String.implode (rev l) :: acc)
            | foo ("\n"::rest,l,acc) = foo (rest,[],(String.implode (rev ("\n"::l)))::acc)
d523 1
a523 1
          foo (String.explode (String.implode (rev sl)),[],[])
d530 1
a530 1
          Lists.iterate insert_text strings
d537 1
a537 1
              if String.ordof (s,n-1) = String.ord"\n"
d622 1
a622 1
          fun do_update () = Lists.iterate (fn f => f ()) (!update_fns);
d750 1
a750 1
                Lists.iterate 
d773 1
a773 1
  val initialContext = ref MLWorks.Option.NONE
d798 1
a798 1
          of MLWorks.Option.NONE =>
d815 1
a815 1
              val c = String.ordof (s, n)
d817 1
a817 1
              if c = String.ord ";" then
d819 1
a819 1
              else if c = String.ord "\n" then
d821 1
a821 1
              else if c = String.ord " " orelse c = String.ord "\t" then
d846 1
a846 1
          Lists.iterate write_hist (rev hist);
d860 1
a860 1
	  Lists.length hist = 0
d870 1
a870 1
      fun flat (x::xs) = (String.implode x ^ "\n") :: (flat xs)
d913 1
a913 1
              check (String.explode regexp) (String.explode line)
d1372 1
a1372 1
	  if i >= size s orelse String.ordof arg = String.ord" " then
d1378 1
a1378 1
	  if i >= size s orelse String.ordof arg <> String.ord" " then
d1387 1
a1387 1
	    if String.ordof arg = String.ord":" then
d1395 1
a1395 1
	    if i >= size s orelse String.ordof(s, i) = String.ord" " then
d1398 1
a1398 1
	      String.substring(s, 0, i+1)
d1418 1
a1418 1
		val n' = String.substring(name, i, i'-i)
d1435 1
a1435 1
			val j = General.valOf (Int.fromString (String.substring(name, i'', size_name-i'')))
d1535 1
a1535 1
          (Lists.iterate
d1634 1
a1634 1
	  val current_item = ref Option.NONE : (string * (MLWorks.Internal.Value.T * Type)) Option.option ref
d1644 1
a1644 1
              Option.NONE => false
d1728 1
a1728 1
              let val chr = String.ordof(s,n-1)
d1730 1
a1730 1
                if chr = String.ord "\n" orelse chr = String.ord "\t"
d1739 2
a1740 2
      let fun subst "\n" = " "
            | subst "\t" = " "
d1743 1
a1743 1
        String.implode (map subst (String.explode s))
d1751 1
a1751 1
            then String.substring(s,0,max_width - 2) ^ ".."
d1770 5
a1774 5
        " " => true
      | "\n" => true
      | "\t" => true
      | "\012" => true
      | "\013" => true
d1783 1
a1783 1
        String.implode (rev (strip (rev (strip (String.explode s))))) (* Yuk Yuk *)
d1825 1
a1825 1
          (Lists.iterate (add_history_entry o strip_whitespace) l;
@


1.62.3.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/08/15  13:55:02  daveb
 * [Bug #1519]
 * The type of UserContext.ITEM has changed.
 *
@


1.62.2.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/08/15  13:55:02  daveb
 * [Bug #1519]
 * The type of UserContext.ITEM has changed.
 *
@


1.62.1.1
log
@branched from 1.62
@
text
@a3 4
 * Revision 1.62  1996/08/15  13:55:02  daveb
 * [Bug #1519]
 * The type of UserContext.ITEM has changed.
 *
@


1.61
log
@Option dialog setter functions now return accept/reject.
@
text
@d4 3
d832 5
a836 2
          fun write_hist (UserContext.ITEM (_, _, _, _, source)) =
            MLWorks.IO.output (file, massage_source source)
@


1.60
log
@[Bug #1521]
Propagating changes made to interpreter/_entry.sml
@
text
@d4 4
d597 2
a598 1
            (f options) := a
d621 3
a623 2
	    UserOptions.select_sml'96 user_context_options
	  |   sml'96 false = ()
d629 3
a631 2
	    UserOptions.select_compatibility user_context_options
	  |   compatibility false = ()
d637 3
a639 2
	    UserOptions.select_sml'90 user_context_options
	  |   sml'90 false = ()
d645 2
a646 1
	    UserOptions.select_optimizing (user_context_options, b)
d652 2
a653 1
	    UserOptions.select_debugging (user_context_options, b)
d935 4
d942 2
a943 8
           Menus.OPTTOGGLE
             ("searchPervasives",
	      fn ()=> !(#searchInitial searchOptions),
	      fn b => #searchInitial searchOptions := b),
           Menus.OPTTOGGLE
             ("searchUserContext",
	      fn ()=> !(#searchContext searchOptions),
	      fn b => #searchContext searchOptions := b)]
d949 2
a950 1
         ("itemSearch", fn () => !searchString , fn s =>search s),
d954 2
a955 6
         Menus.OPTTOGGLE
           ("signatures", fn ()=> !(#showSig searchOptions),
	    fn b => #showSig searchOptions := b),
         Menus.OPTTOGGLE
           ("functors", fn ()=> !(#showFun searchOptions),
	    fn b => #showFun searchOptions := b),
d957 1
a957 3
         Menus.OPTTOGGLE
           ("displayEntryTypes", fn ()=> !(#showType searchOptions),
	    fn b => #showType searchOptions := b)]
d1075 3
a1077 2
          (f preferences) := a
           
d1094 1
a1094 1
			     |  false => ()),
d1100 1
a1100 1
                              | false => ()),
d1102 2
a1103 2
			   fn () => get_preference_fun (#externalEditorCommand) (),
			   fn s => set_preference_fun (#externalEditorCommand) s),
d1109 1
a1109 1
                              | false => ()),
d1111 2
a1112 2
			   fn () => get_preference_fun (#customEditorName) (),
			   fn s => set_preference_fun (#customEditorName) s)])
d1123 4
a1126 2
                              fn () => get_preference_fun (#history_length) (),
                              fn x => set_preference_fun (#history_length) x),
d1128 4
a1131 2
                              fn () => get_preference_fun (#max_num_errors) (),
                              fn x  => set_preference_fun (#max_num_errors) x),
d1133 2
a1134 2
                                 fn () => get_preference_fun (#completion_menu) (),
                                 fn x => set_preference_fun (#completion_menu) x),
d1136 2
a1137 2
                                 fn () => get_preference_fun (#use_debugger) (),
                                 fn x => set_preference_fun (#use_debugger) x),
d1139 2
a1140 2
                                 fn () => get_preference_fun (#use_error_browser) (),
                                 fn x => set_preference_fun (#use_error_browser) x),
d1142 2
a1143 2
                                 fn () => get_preference_fun (#window_debugger) (),
                                 fn x => set_preference_fun (#window_debugger) x)])
d1506 2
a1507 1
          (f options) := a
d1695 2
a1696 1
     fun set_val  (r,v) = (fn b => if b then (r := v) else ())
d1699 2
a1700 1
     fun set_ref (r) = (fn n => r := n)
d1703 3
a1705 3
     fun bool_value (s,r)      = Menus.OPTTOGGLE  (s,test_ref(r),set_ref(r))
     fun text_value (s,r)      = Menus.OPTTEXT    (s,test_ref(r),set_ref(r))
     fun int_value (s,r)       = Menus.OPTINT     (s,test_ref(r),set_ref(r))
@


1.59
log
@Removed object path entry from the Paths menu.
@
text
@d4 3
d476 1
a476 1
  sharing type Entry.PrintOptions = UserOptions.Options.print_options
d908 1
a908 1
          val printOptions = Options.default_print_options
d914 1
a914 1
	      (mkSearchOptions searchOptions, printOptions, entrys)
@


1.58
log
@Use a system dependent line terminator when saving history
@
text
@d4 3
a1185 1
        Menus.PUSH ("setObjectPath", PathTool.objectCreate parent, fn _ => true),
@


1.57
log
@Made button buttons have different names from menu buttons, so that
Windows can distinguish between them, and so let us put mnemonics on
the menu items but not the buttons.
@
text
@d4 5
d810 1
a810 1
                ^ (if has_newline then "" else "\n")
@


1.56
log
@Removed SaveImage.preference_file_name, because Getenv.get_preferences_filename
now does this job.
@
text
@d4 4
d1303 1
a1303 1
           [Menus.PUSH ("addName",
d1306 1
a1306 1
            Menus.PUSH ("deleteSelected",
d1309 1
a1309 1
            Menus.PUSH ("deleteAll",
@


1.55
log
@Removed Step Mode menu item (replaced with a button on the listener).
@
text
@d4 3
d427 1
a432 1
require "../interpreter/save_image";
d447 1
a447 1
  structure SaveImage: SAVE_IMAGE
d468 2
d750 1
a750 1
      initialContext := MLWorks.Option.SOME motif_context;
d756 1
a756 1
    of MLWorks.Option.SOME c => c
d771 2
a772 2
        MLWorks.Option.NONE => ()
      | MLWorks.Option.SOME filename =>
d830 2
a831 2
    of MLWorks.Option.NONE => false
    |  MLWorks.Option.SOME _ => true
d1138 3
a1140 3
          case SaveImage.preference_file_name () of
            MLWorks.Option.NONE => ()
          | MLWorks.Option.SOME pathname =>
d1616 2
a1617 2
              Option.NONE => Crash.impossible "get_current_item"
            | Option.SOME x => x
d1645 1
a1645 1
              Option.SOME f => (f o get_current_item,is_current_item)
@


1.54
log
@Modifications to add custom editor interface ...
@
text
@d4 3
a1320 3
    fun toggle_stepping _ =
      Trace.set_stepping (not (Trace.stepping ()))

d1447 1
a1447 5
                         [Menus.TOGGLE ("stepToggle",
                                        Trace.stepping,
                                        toggle_stepping,
                                        fn _ => true),
                          Menus.PUSH ("breakManager",
@


1.53
log
@Bug 1074: Capi.list_select now takes a function to be called on any key
press handled by the list widget itself.  In the listener, this pops the
completions widget down as if the key had been typed at the listener.
@
text
@d4 5
d1062 1
a1062 1
            Menus.OPTTOGGLE ("select_emacs",
d1064 1
a1064 1
                             		"emacs_server" => true
d1066 1
a1066 1
                             fn true => set_preference_fun (#editor) "emacs_server"
d1068 1
a1068 1
            Menus.OPTTOGGLE ("select_xterm_editor",
d1070 1
a1070 1
  			                "xterm" => true
d1072 1
a1072 1
                             fn true => set_preference_fun (#editor) "xterm"
d1074 4
a1077 4
	    Menus.OPTTEXT ("xterm_editor_command",
			   fn () => get_preference_fun (#xterm_editor_command) (),
			   fn s => set_preference_fun (#xterm_editor_command) s),
            Menus.OPTTOGGLE ("select_x_editor",
d1079 1
a1079 1
  			                "x" => true
d1081 1
a1081 1
                             fn true => set_preference_fun (#editor) "x"
d1083 3
a1085 3
	    Menus.OPTTEXT ("x_editor_command",
			   fn () => get_preference_fun (#x_editor_command) (),
			   fn s => set_preference_fun (#x_editor_command) s)])
@


1.52
log
@The Io exception is no longer at top level.
@
text
@d4 3
d891 1
a891 1
              (shell, "searchList")
@


1.51
log
@Fixed bug 1328: the user_tool_options were hanging on to old update functions.
These referenced deleted widgets, and therefore caused SEGVs.
@
text
@d4 4
d802 1
a802 1
        handle Io _ => ()
@


1.50
log
@Changed view_options so that it can show just the value printer menu item.
@
text
@d713 1
a713 1
	      update_fns := update_dialogues :: !update_fns;
d1489 3
a1491 1
          (Lists.iterate (fn f => f ()) (!update_fns);
d1576 1
@


1.49
log
@Ensure that blank entries never get added to the history.
@
text
@d4 3
d1453 1
a1453 1
    datatype ViewOptions = VIEW_ALL | SENSE_ONLY
d1539 2
a1540 3
      in
	case view_type
	of SENSE_ONLY =>
d1543 1
a1543 1
              val (sensitivity_dialog,sensitivity_dialog_update) =
d1547 3
a1549 2
              [Menus.PUSH
	         ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true)]
d1552 23
a1574 54
	    (* full_menus is not set, and the tool is not affected by the
	       current selection, so there is nothing to show. *)
	    []
	|  VIEW_ALL =>
	  if !(#full_menus preferences) then
	    let
              val (sensitivity_dialog,sensitivity_dialog_update) =
	        popup_sensitivity_options parent

              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent
                  
              val (internals_dialog,internals_dialog_update) =
                popup_internals_options parent
	   
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [valueprinter_dialog_update,
                 sensitivity_dialog_update,
                 internals_dialog_update]
	    in
	      update_fns := update_dialogues :: !update_fns;
              [Menus.PUSH
	 	 ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true),
               Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true),
               Menus.PUSH
	         ("internals", fn _ => internals_dialog (), fn _ => true)]
	    end
	  else
	    let
              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent

              val (internals_dialog,internals_dialog_update) =
                popup_internals_options parent

	      fun update_dialogues () =
		Lists.iterate
		(fn f => f ())
		[valueprinter_dialog_update,
		 internals_dialog_update]
	    in
	      update_fns := valueprinter_dialog_update :: !update_fns;
              [Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true),
	       Menus.PUSH
		 ("internals", fn _ => internals_dialog (), fn _ => true)]
	    end
@


1.48
log
@Added a separator to the Languages dialog.
@
text
@d4 3
d1778 2
a1779 1
        fun add_history_entry item =
@


1.47
log
@Reorganised the options menus.
@
text
@d4 3
d675 1
@


1.46
log
@Renamed mode options.
@
text
@d4 3
d501 2
d513 1
a513 2
         compatibility_dialog: unit -> unit,
         extensions_dialog: unit -> unit,
d531 4
a534 8
    fun get_compatibility_dialog (FULL_MOTIF_CONTEXT r) =
      #compatibility_dialog r
    |   get_compatibility_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_compatibility_dialog"

    fun get_extensions_dialog (FULL_MOTIF_CONTEXT r) = #extensions_dialog r
    |   get_extensions_dialog (SHORT_MOTIF_CONTEXT r) =
      Crash.impossible "get_extensions_dialog"
a537 2
	  val title = "Global Preferences"

a600 22
	  (* Setting debugging and var_info is a bit subtle.  Each time
	     the dialog is updated, all settings get applied.  var_info
	     depends on debugging, so we never want to unset debugging
	     if var_info is set, or set var_info when debugging is not set.
	   *)	     

	  fun debugging true =
	    UserOptions.select_debugging (user_context_options, true)
	  |   debugging false =
	    UserOptions.select_debugging (user_context_options, false)

	  fun is_var_info _ = 
	     UserOptions.is_var_info user_context_options

	  fun var_info true =
	    if is_debugging () then
	      UserOptions.select_var_info (user_context_options, true)
	    else
	      UserOptions.select_var_info (user_context_options, false)
	  |   var_info false =
	    UserOptions.select_var_info (user_context_options, false)

d609 1
a609 1
	     title,
d621 1
a621 2
              Menus.OPTTOGGLE ("debugging", is_debugging, debugging),
              Menus.OPTTOGGLE ("var_info", is_var_info, var_info)])
d631 1
a631 1
	         title,
d657 1
a657 1
              fun popup_compatibility_options parent =
d660 2
a661 2
	         title,
                 "compatibilityOptions",
d671 5
a675 1
                  bool_context_widget("openFixity", #open_fixity)
a680 11
              fun popup_extensions_options parent =
                Menus.create_dialog
                (parent,
	         title,
                 "extensionsOptions",
                 do_update,
                 [Menus.OPTLABEL "extensionsOptionsLabel",
                  Menus.OPTSEPARATOR,
                  bool_context_widget("requireKeyword",#require_keyword),
                  bool_context_widget("typeDynamic",#type_dynamic)])

d684 2
a685 5
              val (compatibility_dialog,compatibility_dialog_update) =
	        popup_compatibility_options parent

              val (extensions_dialog,extensions_dialog_update) =
	        popup_extensions_options parent
d692 1
a692 2
                 compatibility_dialog_update,
                 extensions_dialog_update]
d699 1
a699 2
	  	   compatibility_dialog = compatibility_dialog,
	  	   extensions_dialog = extensions_dialog,
d1035 1
a1035 1
           "Global Preferences",
d1068 1
a1068 1
               "Global Preferences",
d1104 2
a1105 2
        fun popup_compatibility_dialog _ =
	  (get_compatibility_dialog (get_context ())) ()
a1106 2
        fun popup_extensions_dialog _ =
	  (get_extensions_dialog (get_context ())) ()
d1135 1
a1135 3
	          ("compatibility", popup_compatibility_dialog, fn _ => true),
                Menus.PUSH
	          ("extensions", popup_extensions_dialog, fn _ => true)],
@


1.45
log
@UserOptions now defines functions for setting and testing modes.
@
text
@d4 3
d570 2
a571 2
	  fun is_harlequin _ = 
	     UserOptions.is_harlequin user_context_options
d573 17
a589 17
	  fun harlequin true =
	    UserOptions.select_harlequin user_context_options
	  |   harlequin false = ()

	  fun is_new_jersey _ = 
	     UserOptions.is_new_jersey user_context_options

	  fun new_jersey true =
	    UserOptions.select_new_jersey user_context_options
	  |   new_jersey false = ()

	  fun is_standard _ = 
	     UserOptions.is_standard user_context_options

	  fun standard true =
	    UserOptions.select_standard user_context_options
	  |   standard false = ()
d607 1
a607 3
	     
	     There is a BUG here.  If both debugging and var_info are set,
	     and the user deselects both, debugging pops back on. *)
d639 4
a642 3
	        [Menus.OPTTOGGLE ("harlequin", is_harlequin, harlequin),
                 Menus.OPTTOGGLE ("standard", is_standard, standard),
                 Menus.OPTTOGGLE ("new_jersey", is_new_jersey, new_jersey)],
d691 1
d711 1
a711 2
                  bool_context_widget("typeDynamic",#type_dynamic),
                  bool_context_widget("abstractions",#abstractions)])
a1115 3
                Menus.OPTTOGGLE ("autoOutputWindow",
                                 fn () => get_preference_fun (#auto_output_window) (),
                                 fn x => set_preference_fun (#auto_output_window) x),
@


1.44
log
@Corrected the titles of some dialog boxes, which were hangovers from the
days of multiple contexts.
@
text
@d4 4
d399 1
d414 1
d542 2
d545 1
a545 1
	    UserContext.get_user_options user_context
d567 2
a568 10
	  fun is_harlequin _ =
	    get_context_option_fun #require_keyword () andalso
            get_context_option_fun #type_dynamic () andalso
            not (get_context_option_fun #nj_op_in_datatype ()) andalso
            not (get_context_option_fun #nj_signatures ()) andalso
            not (get_context_option_fun #weak_type_vars ()) andalso
            not (get_context_option_fun #open_fixity ()) andalso
            not (get_context_option_fun #fixity_specs ()) andalso
            (get_context_option_fun #abstractions ()) andalso
            not (get_context_option_fun #old_definition ())
d571 1
a571 9
	    (set_context_option_fun #require_keyword true;
             set_context_option_fun #type_dynamic true;
             set_context_option_fun #nj_op_in_datatype false;
             set_context_option_fun #nj_signatures false;
             set_context_option_fun #weak_type_vars false;
             set_context_option_fun #open_fixity false;
             set_context_option_fun #fixity_specs false;
             set_context_option_fun #abstractions true;
             set_context_option_fun #old_definition false)
d574 2
a575 10
	  fun is_new_jersey _ =
	    not (get_context_option_fun #require_keyword ()) andalso
            not (get_context_option_fun #type_dynamic ()) andalso
            get_context_option_fun #nj_op_in_datatype () andalso
            get_context_option_fun #nj_signatures () andalso
            get_context_option_fun #weak_type_vars () andalso
            get_context_option_fun #open_fixity () andalso
            get_context_option_fun #fixity_specs () andalso
            get_context_option_fun #abstractions () andalso
            get_context_option_fun #old_definition ()
d578 1
a578 9
	    (set_context_option_fun #require_keyword false;
             set_context_option_fun #type_dynamic false;
             set_context_option_fun #nj_op_in_datatype true;
             set_context_option_fun #nj_signatures true;
             set_context_option_fun #weak_type_vars true;
             set_context_option_fun #open_fixity true;
             set_context_option_fun #fixity_specs true;
             set_context_option_fun #abstractions true;
             set_context_option_fun #old_definition true)
d581 2
a582 10
	  fun is_standard _ =
	    not (get_context_option_fun #require_keyword ()) andalso
            not (get_context_option_fun #type_dynamic ()) andalso
            not (get_context_option_fun #nj_op_in_datatype ()) andalso
            not (get_context_option_fun #nj_signatures ()) andalso
            not (get_context_option_fun #weak_type_vars ()) andalso
            not (get_context_option_fun #open_fixity ()) andalso
            not (get_context_option_fun #fixity_specs ()) andalso
            not (get_context_option_fun #abstractions ()) andalso
            not (get_context_option_fun #old_definition ())
d585 1
a585 9
	    (set_context_option_fun #require_keyword false;
             set_context_option_fun #type_dynamic false;
             set_context_option_fun #nj_op_in_datatype false;
             set_context_option_fun #nj_signatures false;
             set_context_option_fun #weak_type_vars false;
             set_context_option_fun #open_fixity false;
             set_context_option_fun #fixity_specs false;
             set_context_option_fun #abstractions false;
             set_context_option_fun #old_definition false)
d588 19
a606 13
	  fun optimizing true =
	    (set_context_option_fun #optimize_leaf_fns true;
             set_context_option_fun #optimize_tail_calls true;
             set_context_option_fun #optimize_self_tail_calls true)
	  |   optimizing false =
	    (set_context_option_fun #optimize_leaf_fns false;
             set_context_option_fun #optimize_tail_calls false;
             set_context_option_fun #optimize_self_tail_calls false)

	  fun is_optimizing _ =
	    get_context_option_fun #optimize_leaf_fns () andalso
            get_context_option_fun #optimize_tail_calls () andalso
            get_context_option_fun #optimize_self_tail_calls ()
d609 1
a609 2
	    (set_context_option_fun #generate_debug_info true;
             set_context_option_fun #generate_interceptable_code true)
d611 1
a611 5
	    if get_context_option_fun #generate_variable_debug_info () then
	      ()
	    else
              (set_context_option_fun #generate_debug_info false;
               set_context_option_fun #generate_interceptable_code false)
d613 2
a614 3
	  fun is_debugging _ =
            get_context_option_fun #generate_debug_info () andalso
            get_context_option_fun #generate_interceptable_code ()
d618 1
a618 1
              set_context_option_fun #generate_variable_debug_info true
d620 1
a620 1
	      ()
d622 1
a622 5
            set_context_option_fun #generate_variable_debug_info false;

	  fun is_var_info _ =
	    is_debugging () andalso
	    get_context_option_fun #generate_variable_debug_info ()
a1146 1

d1148 1
a1148 1
          case ShellUtils.preference_file_name () of
d1150 1
a1150 1
          | MLWorks.Option.SOME pathname => 
d1166 4
a1169 2
            Menus.PUSH ("environment", fn _ => environment_dialog (), fn _ => true),
            Menus.PUSH ("savePreferences",save_preferences,fn _ => true),
@


1.43
log
@Fixed bug in history_menu.  The history_index was being set after the
call to use_entry, which meant that the buttons on the listener were
being updated using the old value.  Also, the index was off by one.
@
text
@d4 5
d529 1
a529 1
	  val title = UserContext.get_context_name user_context
@


1.42
log
@Array moving to MLWorks.Array
@
text
@d4 3
d1911 2
a1912 1
			  (use_entry s; history_index := !history_size - i),
@


1.41
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d1298 1
a1298 1
                val l = Vector.length v
d1301 1
a1301 1
                  else aux (n+1,Vector.sub (v,n) :: acc)
@


1.40
log
@Changing to new basis
@
text
@d4 3
d425 1
a425 1
  fun print s = output (MLWorks.IO.terminal_out,s)
d438 2
a439 2
            | foo ([],l,acc) = rev (implode (rev l) :: acc)
            | foo ("\n"::rest,l,acc) = foo (rest,[],(implode (rev ("\n"::l)))::acc)
d442 1
a442 1
          foo (explode (implode (rev sl)),[],[])
d456 1
a456 1
              if String.ordof (s,n-1) = ord"\n"
d809 1
a809 1
          val file = open_out filename
d820 1
a820 1
              if c = ord ";" then
d822 1
a822 1
              else if c = ord "\n" then
d824 1
a824 1
              else if c = ord " " orelse c = ord "\t" then
d840 1
a840 1
            output (file, massage_source source)
d848 1
a848 1
          close_out file;
d870 1
a870 1
      fun flat (x::xs) = (implode x ^ "\n") :: (flat xs)
d913 1
a913 1
              check (explode regexp) (explode line)
d1183 1
a1183 1
                val outstream = open_out pathname
d1187 2
a1188 2
                handle exn => (close_out outstream; raise exn);
                close_out outstream
d1384 1
a1384 1
	  if i >= size s orelse String.ordof arg = ord" " then
d1390 1
a1390 1
	  if i >= size s orelse String.ordof arg <> ord" " then
d1399 1
a1399 1
	    if String.ordof arg = ord":" then
d1407 1
a1407 1
	    if i >= size s orelse String.ordof(s, i) = ord" " then
d1672 1
a1672 1
    fun debug s = if do_debug then output(MLWorks.IO.terminal_out,s ^ "\n") else ()
d1771 1
a1771 1
                if chr = ord "\n" orelse chr = ord "\t"
d1784 1
a1784 1
        implode (map subst (explode s))
d1824 1
a1824 1
        implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
@


1.39
log
@Removing some options
@
text
@d4 3
d364 3
a370 1
require "../utils/integer";
a383 1
  structure Integer: INTEGER
d1414 1
a1414 1
			   MLWorks.Integer.makestring i ^ "\n")
d1425 1
a1425 1
			       MLWorks.Integer.makestring i' ^ "\n")
d1437 1
a1437 1
			       MLWorks.Integer.makestring i'' ^ "\n")
d1444 1
a1444 1
			val j = Integer.parseinteger(String.substring(name, i'', size_name-i''))
d1480 1
a1480 1
				    MLWorks.Integer.makestring hits ^
d1483 1
a1483 1
				       MLWorks.Integer.makestring max
@


1.38
log
@Adding path menu
@
text
@d4 3
a539 1
            get_context_option_fun #topdec_semicolons () andalso
a541 1
            not (get_context_option_fun #infixr_assoc ()) andalso
d547 1
a547 1
            get_context_option_fun #string_inequalities ()
a550 1
             set_context_option_fun #topdec_semicolons true;
a552 1
             set_context_option_fun #infixr_assoc false;
d558 1
a558 1
             set_context_option_fun #string_inequalities true)
a562 1
            get_context_option_fun #topdec_semicolons () andalso
a564 1
            get_context_option_fun #infixr_assoc () andalso
d570 1
a570 1
            get_context_option_fun #string_inequalities ()
a573 1
             set_context_option_fun #topdec_semicolons true;
a575 1
             set_context_option_fun #infixr_assoc true;
d581 1
a581 1
             set_context_option_fun #string_inequalities true)
a585 1
            not (get_context_option_fun #topdec_semicolons ()) andalso
a587 1
            not (get_context_option_fun #infixr_assoc ()) andalso
d593 1
a593 1
            not (get_context_option_fun #string_inequalities ())
a596 1
             set_context_option_fun #topdec_semicolons false;
a598 1
             set_context_option_fun #infixr_assoc false;
d604 1
a604 1
             set_context_option_fun #string_inequalities false)
d711 1
a711 2
                  bool_context_widget("stringInequalities", #string_inequalities),
                  bool_context_widget("infixrAssoc", #infixr_assoc),
d732 1
a732 2
                  bool_context_widget("abstractions",#abstractions),
                  bool_context_widget("topDecSemiColons", #topdec_semicolons)])
@


1.37
log
@Adding "Save preferences" menu item
@
text
@d4 3
a1199 1
	    Menus.PUSH ("paths", fn _ => PathTool.create parent, fn _ => true),
d1214 8
@


1.36
log
@Improving layout of string list manager
@
text
@d4 3
d1082 1
a1082 1
    fun setup_menu (parent, get_context, user_preferences) =
d1087 1
a1087 1
        val Preferences.USER_PREFERENCES (user_preferences, update_fns) =
d1093 1
a1093 1
          (f user_preferences) := a
d1096 1
a1096 1
          !(f user_preferences)
d1178 14
a1191 1
          
d1199 2
a1200 2
            Menus.PUSH
	      ("environment", fn _ => environment_dialog (), fn _ => true),
d1522 1
a1522 1
        val Preferences.USER_PREFERENCES (user_preferences, _) =
d1573 1
a1573 1
	   @@ (if !(#full_menus user_preferences) then
d1597 1
a1597 1
	  if !(#full_menus user_preferences) then
d1611 1
a1611 1
	  if !(#full_menus user_preferences) then
@


1.35
log
@Updated wrt Trace.step_status -> Trace.stepping name change.
@
text
@d4 3
d1332 2
a1333 1
         [Capi.Layout.FIXED text,
d1337 2
a1338 1
          Capi.Layout.FIXED dialogButtons]);
@


1.34
log
@Capi.make_scrolllist now returns a record, with an add_items field.
Removed sensitivity type.
@
text
@d4 4
d1341 1
a1341 1
      Trace.set_stepping (not (Trace.step_state ()))
d1470 1
a1470 1
                                        Trace.step_state,
@


1.33
log
@Minor changes to menu interfaces.
@
text
@d4 3
d381 1
a381 2
  sharing type UserOptions.user_tool_options = UserContext.user_tool_options =
	       ShellUtils.UserOptions
d835 1
a835 1
          val (_, _, hist, _) = UserContext.get_context_info user_context
d849 1
a849 1
	  val (_, _, hist, _) = UserContext.get_context_info user_context
d890 1
a890 2
              val context =
		#2(UserContext.get_context_info (get_user_context c))
d1211 1
a1211 1
        val (scroll,list,list_set) = 
d1228 1
a1228 1
        fun set_list _ = list_set Options.default_print_options (!stringlist)
a1483 2
    datatype Sensitivity =
      SENSE_ALL | NO_SET_SELECTION | NO_SENSE_SELECTION | CONTEXT_ONLY
d1492 1
a1492 1
	   caller_update_fn, sensitivity, view_type} =
d1552 1
a1552 11
	        [])
	   @@ (case sensitivity
	      of CONTEXT_ONLY =>
	        []
	      |  NO_SENSE_SELECTION =>
                [bool_tool_widget("setSelection",#set_selection)]
	      |  NO_SET_SELECTION =>
                [bool_tool_widget("senseSelection",#sense_selection)]
	      |  SENSE_ALL =>
                [bool_tool_widget("senseSelection",#sense_selection),
                 bool_tool_widget("setSelection",#set_selection)]))
d1572 1
a1572 2
	  if !(#full_menus user_preferences)
	     orelse sensitivity <> CONTEXT_ONLY then
a1612 28
	    end
	  else if sensitivity <> CONTEXT_ONLY then
	    let
              val (sensitivity_dialog,sensitivity_dialog_update) =
	        popup_sensitivity_options parent

              val (valueprinter_dialog,valueprinter_dialog_update) =
	        popup_valueprinter_options parent
                  
              val (internals_dialog,internals_dialog_update) =
                popup_internals_options parent
	   
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [valueprinter_dialog_update,
		 internals_dialog_update,
                 sensitivity_dialog_update]
	    in
	      update_fns := update_dialogues :: !update_fns;
              [Menus.PUSH
	 	 ("sensitivity", fn _ => sensitivity_dialog (), fn _ => true),
               Menus.PUSH
		 ("valueprinter",
		  fn _ => valueprinter_dialog (),
		  fn _ => true),
	       Menus.PUSH
		 ("internals", fn _ => internals_dialog (), fn _ => true)]
@


1.32
log
@Added make_history function.
@
text
@d4 3
d972 8
d985 1
a985 1
         shell, search_opt, user_preferences} =
a992 13
      val searchButtons =
	case search_opt
	of MLWorks.Option.NONE =>
	  []
	|  MLWorks.Option.SOME (action_fn, choose_contexts) => 
	  let
            val (searchPopup, _) =
   	      make_search_dialog
		(shell, get_context, action_fn, choose_contexts)
	  in
	    [Menus.PUSH ("search", searchPopup, fn _ => true)]
	  end

d1068 1
a1068 1
        ("context", save_items @@ searchButtons @@ tail_menu, fn _ => true)
d1468 1
a1468 1
                          Menus.PUSH ("break",
d1471 1
a1471 1
                          Menus.PUSH ("trace",
d1684 1
a1684 4
    fun value_menu (parent, 
                    user_preferences, 
                    inspect_fn,
                    get_value) =
d1745 4
a1748 1
				       object_traceable)],
@


1.31
log
@Disable Inspect option in Value menu.
@
text
@d4 3
d372 1
d1768 158
@


1.30
log
@Adding Inspect to value menu
@
text
@d4 3
a1680 2
    val initial_item = ShellUtils.default_dynamic

d1684 2
a1685 1
                    inspect_fn,get_value) =
d1687 1
a1687 1
	  val current_item = ref initial_item
d1692 2
a1693 4
          fun get_input_value () =
            case get_value () of
              Option.SOME b => b
            | _ => initial_item
d1695 9
a1703 2
          fun set_current_item () =
	    current_item := get_input_value ()
d1705 1
d1710 2
a1711 1
              ShellUtils.object_editable (#1(!current_item)))
d1714 2
a1715 1
	     ShellUtils.object_traceable (#1(!current_item))
d1721 1
a1721 1
	      (ShellUtils.edit_object (#1(!current_item), preferences);())
d1725 3
a1727 1
	  fun trace_object _ = ShellUtils.trace (#1(!current_item))
a1728 1
	  fun untrace_object _ = ShellUtils.untrace (#1 (!current_item))
d1731 1
a1731 1
              Option.SOME f => (f,fn _ => true)
@


1.29
log
@Changing uses of full_menus
@
text
@d4 3
d372 1
d378 1
d383 1
a1677 2
    fun apply f x =  f(x)

a1679 17
    fun get_pane_input [] = ""
      | get_pane_input (txt::panes) =
	let
	  val str = Capi.Text.get_selection txt
	in
	  if str="" then get_pane_input(panes) else str
	end

    fun first_line (message) =
      let
	fun aux ([],_) = message
	  | aux (("\n" :: _),acc) = implode (rev acc)
	  | aux ((a::b),acc) = aux (b,a::acc)
      in
	aux (explode message,[])
      end

d1681 3
a1683 3

    fun value_menu_strfun
	  (parent, user_context, user_options, user_preferences, get_name_fn) =
a1686 3
	  fun get_current_context () =
	    (UserContext.get_context user_context)

d1690 4
a1693 13
	  fun get_input_value () =
	    let
	      val str = get_name_fn()
	    in
	       if str=""
	       then initial_item
	       else let
		      val context = get_current_context ()
                      (* fun msg_fun s = ( message_fun s ; initial_item ) *)
		    in
		      ShellUtils.lookup_name(str,context,initial_item)
		    end
	    end
d1696 1
a1696 3
	    ( current_item := get_input_value () ;
	      ()
            )
d1698 2
d1701 2
a1702 3
	     ( set_current_item ();
 	       ShellUtils.object_editable (#1(!current_item))
             )
a1709 1
	      val input   = get_name_fn()
d1718 4
d1727 3
a1737 11

    fun value_menu
	  (parent, user_context, user_options, user_preferences,
	   text_widget_panes) =
	let
          fun get_string_nm () = get_pane_input text_widget_panes
        in
          value_menu_strfun
	    (parent, user_context, user_options,
	     user_preferences, get_string_nm)
        end
@


1.28
log
@Added ".sml" mask to save_as_dialog.
@
text
@d4 3
d644 2
a645 5
              Menus.OPTTOGGLE ("debugging", is_debugging, debugging)]
	     @@ (if full_menus then
                  [Menus.OPTTOGGLE ("var_info", is_var_info, var_info)]
		else
		  []))
d665 3
a667 7
	  	  ("generateDebugInfo", #generate_debug_info)]
		 @@ (if full_menus then
                      [bool_context_widget
	  	         ("generateVariableDebugInfo",
			  #generate_variable_debug_info)]
		    else
		      [])
d1115 23
a1137 33
               Menus.OPTLABEL "environmentOptionsLabel"
               :: Menus.OPTSEPARATOR
               :: Menus.OPTINT
		    ("maximumHistoryLength",
                     fn () => get_preference_fun (#history_length) (),
                     fn x => set_preference_fun (#history_length) x)
               :: Menus.OPTINT
		    ("maximumNumberErrors",
	    	     fn () => get_preference_fun (#max_num_errors) (),
		     fn x  => set_preference_fun (#max_num_errors) x)
               :: Menus.OPTTOGGLE
		    ("autoOutputWindow",
                     fn () => get_preference_fun (#auto_output_window) (),
                     fn x => set_preference_fun (#auto_output_window) x)
               :: Menus.OPTTOGGLE
		    ("completionMenu",
                     fn () => get_preference_fun (#completion_menu) (),
                     fn x => set_preference_fun (#completion_menu) x)
               :: Menus.OPTTOGGLE
		    ("useDebugger",
                     fn () => get_preference_fun (#use_debugger) (),
                     fn x => set_preference_fun (#use_debugger) x)
               :: Menus.OPTTOGGLE
		    ("useErrorBrowser",
                     fn () => get_preference_fun (#use_error_browser) (),
                     fn x => set_preference_fun (#use_error_browser) x)
	       :: (if !(#full_menus user_preferences) then
		     [Menus.OPTTOGGLE
		        ("windowDebugger",
                         fn () => get_preference_fun (#window_debugger) (),
                         fn x => set_preference_fun (#window_debugger) x)]
	           else
		     nil))
@


1.27
log
@Replaced Capi.find_file with Capi.save_as_dialog.
@
text
@d4 3
d775 1
a775 1
          Capi.save_as_dialog (applicationShell, "")
d779 1
a779 1
            Capi.save_as_dialog (applicationShell, "")
@


1.26
log
@Changes to search facility
@
text
@d4 3
d772 1
a772 1
          Capi.find_file (applicationShell, "", Capi.FILE)
d776 1
a776 1
            Capi.find_file (applicationShell, "", Capi.FILE)
@


1.25
log
@Doing something with list_select
@
text
@d4 3
a843 22
      fun grep regexp line =
      let
        fun startsWith [] ys = true
          | startsWith xs [] = false
          | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
        fun check [] ys = false
          | check xs [] = false
          | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
      in
        check (explode regexp) (explode line)
      end (* grep *)
        
      fun collect f xs =
      let
        fun collect f acc [] = rev acc
          | collect f acc (x::xs) =
            if f x then collect f (x::acc) xs
            else collect f acc xs
      in
        collect f [] xs
      end (* collect *)

d876 12
d908 1
a908 2
          val entrys' = map implode entrys'
          val found = collect (grep s) entrys'
@


1.24
log
@Fixing problem with deleting single items.
@
text
@d4 3
a373 42
  fun list_select (parent,name) =
    let
      val shell = Capi.make_popup_shell (name,parent, [])
      val form = Capi.make_subwindow shell
      exception ListSelect
      val select_fn_ref = ref (fn _ => raise ListSelect)
      val print_fn_ref = ref (fn _ => raise ListSelect)

      val exited = ref false;
      fun exit _ = if !exited then () else (Capi.destroy shell; exited := true)

      val (scroll,_,setitems) =
        Capi.make_scrolllist
        {parent = form,
         name = "listSelect",
         select_fn = fn _ => fn x => (exit();(!select_fn_ref) x),
         action_fn = fn _ => fn _ => (),
         print_fn = fn _ => (!print_fn_ref)}
      val dialogButtons = Capi.make_managed_widget ("dialogButtons", Capi.RowColumn,form,[])
      val {update = buttons_updatefn, ...} = 
        Menus.make_buttons
        (dialogButtons,
         [Menus.PUSH ("cancel",
                      exit,
                      fn _ => true)])
      fun popup (items,select_fn,print_fn) =
        (select_fn_ref := select_fn;
         print_fn_ref := print_fn;
         setitems Options.default_print_options items;
         Capi.reveal form;
         exit)
        
    in
      Capi.Layout.lay_out
      (form,
       [Capi.Layout.FLEX scroll,
        Capi.Layout.SPACE,
        Capi.Layout.FIXED dialogButtons,
        Capi.Layout.SPACE]);
      popup
    end

d918 1
a918 1
	    list_select
@


1.23
log
@Moving list_select into architecture specific code.
@
text
@d4 3
d1319 1
a1319 1
            val newlist = trim (!stringlist,selected,1,[])
d1322 1
@


1.22
log
@Add call to ml_debugger to update debugger table when setting break points
@
text
@d4 3
d1323 8
a1330 1

d1355 3
@


1.21
log
@Added Path Tool to setup_menu.
Replaced FileDialog.find_file with Capi.find_file; the type has changed too.
@
text
@d4 4
d313 1
d327 1
d1230 1
a1230 1
    fun make_string_list_manager (parent,name,get,set) =
d1234 1
d1255 1
a1255 1
           print_fn = fn _ => fn s => s}
d1261 2
a1262 1
           stringlist := get())
d1272 16
a1287 7
            if ok_string name
              then 
                (stringlist := name :: !stringlist;
                 changed := true;
                 reset_text ();
                 set_list ();
                 set_selected ())
d1292 1
a1292 1
        fun apply_fn _ = (text_apply (); set (!stringlist); changed := false; set_selected ())
d1371 98
a1468 1
                                    Trace.trace_list)
d1473 16
a1488 1
                                    Trace.break_list)
@


1.20
log
@Changing interface to clipboard functions
@
text
@d4 3
d307 1
d320 1
d333 1
a333 1
  sharing type Menus.Widget = Capi.Widget
d793 1
a793 1
          Capi.find_file (applicationShell)
d797 1
a797 1
            Capi.find_file (applicationShell)
d1205 1
@


1.19
log
@Corrected previous fix: the initial context wasn't being set.
@
text
@d4 3
a1569 11
    fun cutSelection text_widget =
      (Capi.clipboard_set (Capi.Text.get_selection text_widget);
       Capi.Text.remove_selection text_widget)

    fun copySelection text_widget =
      Capi.clipboard_set (Capi.Text.get_selection text_widget)

    fun pasteSelection text_widget =
      Capi.Text.insert (text_widget,Capi.Text.get_insertion_position text_widget,
                        Capi.clipboard_get ())

@


1.18
log
@Modification to allow gui to be restarted when restarting an
image saved from the GUI.
@
text
@d4 4
a770 4

(*
      exception AlreadyInitialised
*)
d772 1
a772 6
(* Ignore, this should only happen when
      case !initialContext
      of MLWorks.Option.NONE =>
	initialContext := MLWorks.Option.SOME motif_context
      |  _ => raise AlreadyInitialised;
*)
@


1.17
log
@Changing names for search resources.
@
text
@d4 3
d768 1
d770 1
d772 1
d777 1
@


1.16
log
@Changing button resources
@
text
@d4 3
d946 1
a946 1
             ("Search Pervasives",
d950 1
a950 1
             ("Search User Context",
d957 4
a960 1
        [Menus.OPTLABEL "Search inside...",
a968 3
         Menus.OPTTEXT
	   ("Search for Item", fn () => !searchString , fn s =>search s),
         Menus.OPTSEPARATOR,
d970 1
a970 1
           ("Display types of entries", fn ()=> !(#showType searchOptions),
@


1.15
log
@Changing clipboard mechanism
@
text
@d4 3
d1044 1
a1044 1
               Menus.DYNAMIC ("context", select_menu, fn _ => true)]
d1309 1
a1309 1
           [Menus.PUSH ("addNameButton",
d1312 1
a1312 1
            Menus.PUSH ("deleteSelectedButton",
d1348 1
a1348 1
                         [Menus.TOGGLE ("stepToggleButton",
d1352 1
a1352 1
                          Menus.PUSH ("breakButton",
d1355 1
a1355 1
                          Menus.PUSH ("traceButton",
@


1.14
log
@Removed "search in structure" option from the search dialog (because we
always want to search substructures.
Changed list_select to destroy the widget on exit.  Tools should create a
new list widget each time they need one.  This is so that it pops up with
the correct size under TWM.  (The search dialog already does this.).
@
text
@d4 7
a1558 2
    val cut_buffer = ref ""

d1560 1
a1560 1
      (cut_buffer := Capi.Text.get_selection text_widget;
d1564 1
a1564 1
      cut_buffer := Capi.Text.get_selection text_widget
d1567 2
a1568 1
      Capi.Text.insert (text_widget,Capi.Text.get_insertion_position text_widget,!cut_buffer)
@


1.13
log
@Hid the local variables debugging options unless full_menus is set.
@
text
@d4 3
d339 2
a340 1
      fun exit _ = Capi.hide form
a949 3
           ("structures", fn ()=> !(#showStr searchOptions),
	    fn b => #showStr searchOptions := b),
         Menus.OPTTOGGLE
d957 1
a957 1
           ("Display their types", fn ()=> !(#showType searchOptions),
@


1.12
log
@Simplifying tracing interface.
@
text
@d4 3
d608 5
d627 5
a631 2
              Menus.OPTTOGGLE ("debugging", is_debugging, debugging),
              Menus.OPTTOGGLE ("var_info", is_var_info, var_info)])
a635 2
	  val Preferences.USER_PREFERENCES (user_preferences, _) =
	    user_preferences
d651 7
a657 3
	  	  ("generateDebugInfo", #generate_debug_info),
                  bool_context_widget
	  	  ("generateVariableDebugInfo", #generate_variable_debug_info),
d664 6
a669 5
                  Menus.OPTSEPARATOR,
                  bool_context_widget("optimizeLeafFns", #optimize_leaf_fns),
                  bool_context_widget("optimizeTailCalls", #optimize_tail_calls),
                  bool_context_widget
	  	  ("optimizeSelfTailCalls",#optimize_self_tail_calls)])
@


1.11
log
@Another Menu utility ...
@
text
@d4 3
d1314 2
a1315 2
                                    Trace.simple_traces,
                                    Trace.simple_trace_list)
d1319 2
a1320 2
                                    Trace.simple_breakpoints,
                                    Trace.simple_break_list)
d1624 3
a1626 7
	  fun trace_object _ =
	    ShellUtils.trace
	      (!current_item, user_options, get_current_context, message_fun)

	  fun untrace_object _ =
	    ShellUtils.untrace
	      (!current_item, user_options, get_current_context, message_fun)
@


1.10
log
@Adding some PopUp Menu utility functions : (int_value, etc.)
@
text
@d4 3
d1664 1
@


1.9
log
@Made context_menu include "Save" and "Save As..." options only if the
context is writable.
@
text
@d4 4
d310 2
d1649 14
@


1.8
log
@Minor improvements to search mechanism.
@
text
@d4 3
d810 1
a810 1
  fun make_search_dialog (shell, get_context, action_fn) =
d841 2
a842 2
         searchInitial = ref true,
         searchContext = ref true,
d899 14
d931 2
a932 10
	    fn b => #showType searchOptions := b),
         Menus.OPTSEPARATOR,
         Menus.OPTTOGGLE
           ("Search Pervasives",
	    fn ()=> !(#searchInitial searchOptions),
	    fn b => #searchInitial searchOptions := b),
         Menus.OPTTOGGLE
           ("Search User Context",
	    fn ()=> !(#searchContext searchOptions),
	    fn b => #searchContext searchOptions := b)]
d956 1
a956 1
	|  MLWorks.Option.SOME action_fn => 
d959 2
a960 1
   	      make_search_dialog (shell, get_context, action_fn)
d1021 17
d1040 1
a1040 17
        ("context",
         [Menus.PUSH
            ("save",
             fn _ =>
	       save_history
		 (false, get_current_user_context (), shell),
             fn _ => not (null_history (get_current_user_context ()))
		         andalso save_name_set (get_current_user_context ())),
          Menus.PUSH
            ("saveAs",
             fn _ =>
               save_history
		 (true, get_current_user_context (), shell),
             fn _ => not (null_history (get_current_user_context ())))]
	 @@ searchButtons
	 @@ tail_menu,
	 fn _ => true)
@


1.7
log
@Moved mode options to preference menu until we have proper support for
contexts-as-files.
@
text
@d4 4
d834 21
a854 6
      val searchOptions = ref
        {showSig = true,
         showStr = true,
         showFun = true,
         searchInitial = false,
         showType = true}
d860 2
a861 2
              val context = #2(UserContext.get_context_info
                                 (get_user_context c))
d866 9
a874 3
          val context =
            if (#searchInitial (!searchOptions)) then
              getItemsFromContext(getInitialContext())
d881 5
a885 2
          val entrys = map Entry.massage context
          val entrys' = Entry.printEntry1 (!searchOptions) printOptions entrys
d893 1
a893 1
          ()
d900 2
a901 2
           ("signatures", fn ()=> #showSig (!searchOptions),
            fn b=>searchOptions:=Entry.update ("showSig", b, !searchOptions)),
d903 2
a904 2
           ("structures", fn ()=> #showStr (!searchOptions),
            fn b=>searchOptions:=Entry.update ("showStr", b, !searchOptions)),
d906 5
a910 2
           ("functors", fn ()=> #showFun (!searchOptions),
            fn b=>searchOptions:=Entry.update ("showFun", b, !searchOptions)),
d913 2
a914 2
           ("Display their types", fn ()=> #showType (!searchOptions),
            fn b=>searchOptions:=Entry.update ("showType", b, !searchOptions)),
d918 6
a923 5
	    fn ()=> #searchInitial (!searchOptions),
            fn b=>
	      searchOptions:=Entry.update ("searchInitial", b, !searchOptions)),
         Menus.OPTSEPARATOR,
         Menus.OPTTEXT ("Search for Item", fn () => "" , fn s =>search s)]
d926 1
a926 1
        (shell, "Search Window", "browserDialog", fn ()=>(), searchSpec)
@


1.6
log
@Menus.make_buttons now returns a record of functions.
@
text
@d4 3
d265 1
d277 1
d280 1
a280 2
  sharing UserOptions.Options = ShellUtils.Options
                              = UserContext.Options
d285 1
a285 1
  sharing type ShellUtils.Context = UserContext.Context
d291 1
d803 1
a803 4
  (* All option dialogs for context-specific options are created once for
     each context.  The context menu must get the correct dialogs. *)
  fun context_menu
	{set_state, get_context, writable, applicationShell, user_preferences} =
d805 38
a842 5
      fun select_menu () =
	let
	  fun make_item c =
            let
	      val name = get_context_name c
d844 1
a844 1
	      Menus.PUSH (name, fn _ => set_state c, fn _ => true)
d846 21
d868 28
a895 10
	  val contexts =
	    if writable = WRITABLE then
	      Lists.filter_outp
	        (UserContext.is_const_context o get_user_context)
		(!context_list)
	    else
              !context_list
	in
          map make_item contexts
	end
a896 2
      fun get_current_user_context () =
	get_user_context (get_context ())
d898 9
a906 11
      fun push_state _ =
	set_state
	  (make_context
	     (UserContext.copyUserContext (get_current_user_context ()),
	      applicationShell, user_preferences))

      fun initialContext _ =
	set_state
	  (make_context
	    (UserContext.getNewInitialContext (),
	     applicationShell, user_preferences))
d908 14
a921 16
      fun popup_mode_dialog _ =
	(get_mode_dialog (get_context ())) ()
          
      fun popup_compiler_dialog _ =
	(get_compiler_dialog (get_context ())) ()
          
      fun popup_compatibility_dialog _ =
	(get_compatibility_dialog (get_context ())) ()
          
      fun popup_extensions_dialog _ =
	(get_extensions_dialog (get_context ())) ()
          
      val is_constant = UserContext.is_const_context o get_current_user_context

      val Preferences.USER_PREFERENCES (user_preferences, _) =
	user_preferences
d926 1
a926 1
        if !(#full_menus user_preferences) then
d928 35
d982 1
a982 2
         [Menus.PUSH ("mode", popup_mode_dialog, fn _ => not (is_constant ())),
          Menus.PUSH
d986 1
a986 1
		 (false, get_current_user_context (), applicationShell),
d993 3
a995 11
		 (true, get_current_user_context (), applicationShell),
             fn _ => not (null_history (get_current_user_context ()))),
          Menus.SEPARATOR,
          Menus.CASCADE
	    ("options",
             [Menus.PUSH ("compiler", popup_compiler_dialog, fn _ => true),
              Menus.PUSH
	        ("compatibility", popup_compatibility_dialog, fn _ => true),
              Menus.PUSH
	        ("extensions", popup_extensions_dialog, fn _ => true)],
              fn _ => not (is_constant ()))]
d1000 1
a1000 1
    fun setup_menu (parent, user_preferences) =
d1094 13
d1111 2
a1112 1
	   [Menus.PUSH ("editor", fn _ => editor_dialog (), fn _ => true),
d1114 10
a1123 1
	      ("environment", fn _ => environment_dialog (), fn _ => true)],
@


1.5
log
@Make options visible when full_menus is not set.  The default implementation
now hides all mention of multiple contexts, but makes everything else visible.
@
text
@d4 4
d319 1
a319 1
      val buttons_updatefn = 
d1093 1
a1093 1
        val buttons_update_fn = 
d1109 1
a1109 1
        val other_buttons_update_fn =
@


1.4
log
@Doesn't work under windows
@
text
@d4 3
d388 1
a388 1
      SHORT_MOTIF_CONTEXT of			(* full_menus = false *)
d392 1
a392 1
    | FULL_MOTIF_CONTEXT of			(* full_menus = true *)
a599 1
	  if !(#full_menus user_preferences) then
a691 18
	  else
	    (* short menus version *)
	    let
              fun update_dialogues () =
                Lists.iterate 
                (fn f => f ()) 
                [mode_dialog_update]
	    
	      val result = 
                SHORT_MOTIF_CONTEXT 
	  	{user_context = user_context,
	  	 mode_dialog = mode_dialog,
	  	 update_fn = update_dialogues}
	    in
	      context_list := result :: !context_list;
	      update_fns := update_dialogues :: !update_fns;
	      result
	    end
d852 1
a852 1
	 and select between them.  Users can also set individual options. *)
d858 1
a858 10
               Menus.DYNAMIC ("context", select_menu, fn _ => true),
               Menus.SEPARATOR,
               Menus.CASCADE
	         ("options",
                  [Menus.PUSH ("compiler", popup_compiler_dialog, fn _ => true),
                 Menus.PUSH
		   ("compatibility", popup_compatibility_dialog, fn _ => true),
                 Menus.PUSH
	           ("extensions", popup_extensions_dialog, fn _ => true)],
                fn _ => not (is_constant ()))]
d862 2
a863 1
              [Menus.PUSH ("pushContext", push_state, fn _ => true),
d888 10
a897 1
             fn _ => not (null_history (get_current_user_context ())))]
d1317 3
d1324 1
d1333 3
a1335 1
		  fn _ => true)]
d1341 9
d1355 3
a1357 1
		  fn _ => true)]
@


1.3
log
@Adding make_buttons function to capi
@
text
@d4 3
d292 2
d297 1
a297 2
      val form = Capi.make_widget ("listSelectForm", Capi.Form,
                                   shell,[])
d302 1
a302 1
      fun exit _ = Capi.unmanage form
d322 1
a322 1
         Capi.manage form;
d328 1
a328 1
       [Capi.Layout.TEXT scroll,
d330 1
a330 1
        Capi.Layout.OTHER dialogButtons,
d587 3
a589 4
	      Menus.OPTSUBMENU
	        [Menus.OPTTOGGLE ("optimizing", is_optimizing, optimizing),
                 Menus.OPTTOGGLE ("debugging", is_debugging, debugging),
                 Menus.OPTTOGGLE ("var_info", is_var_info, var_info)]])
d1033 1
a1033 1
        val form = Capi.make_widget ("listManagerForm",Capi.Form,shell,[])
d1058 1
a1058 2
        fun ok_string s = 
          if s = "" then false else true
d1109 1
a1109 1
                                 Capi.unmanage form),
d1118 1
a1118 1
                        fn _ => (reset (); Capi.unmanage form),
d1134 3
a1136 3
         [Capi.Layout.OTHER text,
          Capi.Layout.OTHER buttonPane,
          Capi.Layout.TEXT scroll,
d1138 1
a1138 1
          Capi.Layout.OTHER dialogButtons]);
d1141 1
a1141 1
          Capi.manage form;
@


1.2
log
@Moved capi etc. to gui
@
text
@d4 3
d309 1
a309 1
        Menus.make_submenus
d323 5
a327 4
      [Capi.Layout.TEXT scroll,
       Capi.Layout.SPACE,
       Capi.Layout.OTHER dialogButtons,
       Capi.Layout.SPACE];
d1103 1
a1103 1
          Menus.make_submenus
d1119 1
a1119 1
          Menus.make_submenus
d1131 6
a1136 5
        [Capi.Layout.OTHER text,
         Capi.Layout.OTHER buttonPane,
         Capi.Layout.TEXT scroll,
         Capi.Layout.SPACE,
         Capi.Layout.OTHER dialogButtons];
@


1.1
log
@new unit
New unit
@
text
@d4 4
d240 2
a241 2
require "../library/capi";
require "../library/menus";
@
