head	1.32;
access;
symbols
	MLW_daveb_inline_1_4_99:1.32.1
	MLWorks_21c0_1999_03_25:1.32
	MLWorks_20c1_1998_08_20:1.31
	MLWorks_20c0_1998_08_04:1.31
	MLWorks_20b2c2_1998_06_19:1.30
	MLWorks_20b2_Windows_1998_06_12:1.30
	MLWorks_20b1c1_1998_05_07:1.30
	MLWorks_20b0_1998_04_07:1.30
	MLWorks_20b0_1998_03_20:1.29
	MLWorks_20m2_1998_02_16:1.26
	MLWorks_20m1_1997_10_23:1.24
	MLWorks_11r1:1.21.1.1.1.1.1
	MLWorks_workspace_97:1.24.2
	MLWorks_dt_wizard:1.24.1
	MLWorks_11c0_1997_09_09:1.21.1.1.1.1
	MLWorks_10r3:1.21.1.1.3
	MLWorks_10r2_551:1.21.1.1.2
	MLWorks_11:1.21.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.1.1
	MLWorks_20m0_1997_06_20:1.24
	MLWorks_1_0_r2c2_1997_06_14:1.21.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.1
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.20.4.1.1
	MLWorks_gui_1996_12_18:1.20.5
	MLWorks_1_0_Win32_1996_12_17:1.20.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.20.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.20.1.1
	JFHgui:1.20.3
	MLWorks_1_0_Irix_1996_11_28:1.20.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.20.2
	MLWorks_1_0_Unix_1996_11_14:1.20.1
	MLWorks_Open_Beta2_1996_10_11:1.16.3
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.16
	MLWorks_Beta_1996_07_02:1.14
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13;
locks; strict;
comment	@ * @;


1.32
date	99.03.23.18.04.02;	author johnh;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	98.07.09.12.58.10;	author johnh;	state Exp;
branches;
next	1.30;

1.30
date	98.03.31.16.03.20;	author johnh;	state Exp;
branches;
next	1.29;

1.29
date	98.02.19.19.44.23;	author mitchell;	state Exp;
branches;
next	1.28;

1.28
date	98.02.18.11.43.14;	author johnh;	state Exp;
branches;
next	1.27;

1.27
date	98.02.10.15.35.52;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	98.01.27.15.59.52;	author johnh;	state Exp;
branches;
next	1.25;

1.25
date	97.11.09.19.18.47;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	97.06.12.14.58.04;	author johnh;	state Exp;
branches
	1.24.1.1
	1.24.2.1;
next	1.23;

1.23
date	97.05.16.15.35.09;	author johnh;	state Exp;
branches;
next	1.22;

1.22
date	97.05.06.09.12.12;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	97.03.17.14.35.25;	author johnh;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	96.11.06.13.26.15;	author andreww;	state Exp;
branches
	1.20.1.1
	1.20.2.1
	1.20.3.1
	1.20.4.1
	1.20.5.1;
next	1.19;

1.19
date	96.11.06.11.16.27;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	96.11.01.10.20.49;	author johnh;	state Exp;
branches;
next	1.17;

1.17
date	96.10.09.14.54.23;	author io;	state Exp;
branches;
next	1.16;

1.16
date	96.08.14.15.27.33;	author johnh;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1;
next	1.15;

1.15
date	96.08.12.16.40.47;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	96.06.25.13.33.52;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	96.05.01.11.11.23;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.04.30.10.10.34;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	96.04.04.15.13.13;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	96.04.01.15.08.36;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.11.16.13.20.25;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.10.30.14.16.32;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	95.10.25.14.30.35;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.10.24.15.42.18;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.10.24.15.12.58;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.10.20.11.11.34;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	95.10.19.12.15.53;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	95.10.18.13.43.16;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.12.07.00;	author nickb;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.13.35;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.04.14;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.10.17.11.22.27;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.11.14.12.46.34;	author hope;	state Exp;
branches
	1.20.1.1.1.1;
next	;

1.20.1.1.1.1
date	96.11.28.14.58.13;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.11.22.18.06.49;	author hope;	state Exp;
branches;
next	;

1.20.3.1
date	96.12.17.09.54.54;	author hope;	state Exp;
branches;
next	;

1.20.4.1
date	96.12.17.17.45.31;	author hope;	state Exp;
branches
	1.20.4.1.1.1;
next	;

1.20.4.1.1.1
date	97.02.24.11.35.01;	author hope;	state Exp;
branches;
next	;

1.20.5.1
date	96.12.18.09.39.31;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	97.05.12.10.31.51;	author hope;	state Exp;
branches
	1.21.1.1.1.1
	1.21.1.1.2.1
	1.21.1.1.3.1;
next	;

1.21.1.1.1.1
date	97.07.28.18.16.53;	author daveb;	state Exp;
branches
	1.21.1.1.1.1.1.1;
next	;

1.21.1.1.1.1.1.1
date	97.10.07.11.41.43;	author jkbrook;	state Exp;
branches;
next	;

1.21.1.1.2.1
date	97.09.08.17.10.27;	author daveb;	state Exp;
branches;
next	;

1.21.1.1.3.1
date	97.09.09.14.06.00;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	97.09.10.19.20.25;	author brucem;	state Exp;
branches;
next	;

1.24.2.1
date	97.09.11.20.51.37;	author daveb;	state Exp;
branches;
next	1.24.2.2;

1.24.2.2
date	97.11.20.17.03.54;	author johnh;	state Exp;
branches;
next	;

1.32.1.1
date	99.04.01.17.55.15;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New profile tool.
@


1.32
log
@[Bug #190538]
Fix problem with exiting.
@
text
@ (*
 * Graphical Profiler Tool
 * 
 * Copyright (c) 1995 Harlequin Ltd.
 *  $Log: _profile_tool.sml,v $
 * Revision 1.31  1998/07/09  12:58:10  johnh
 * [Bug #30400]
 * Fix returning to and from tty mode.
 *
 * Revision 1.30  1998/03/31  16:03:20  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos().
 *
 * Revision 1.29  1998/02/19  19:44:23  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.28  1998/02/18  11:43:14  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.27  1998/02/10  15:35:52  jont
 * [Bug #70065]
 * Remove uses of MLWorks.IO.messages and use the Messages structure
 *
 * Revision 1.26  1998/01/27  15:59:52  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.25  1997/11/09  19:18:47  jont
 * [Bug #30089]
 * Change use of MLWorks.Time.Interval for corresponding basis function
 *
 * Revision 1.24.2.2  1997/11/20  17:03:54  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.24.2.1  1997/09/11  20:51:37  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.24  1997/06/12  14:58:04  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.23  1997/05/16  15:35:09  johnh
 * Implementing single menu bar on Windows.
 * Re-organising menus for Motif.
 *
 * Revision 1.22  1997/05/06  09:12:12  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.21  1997/03/17  14:35:25  johnh
 * [Bug #1954]
 * Added a call to Capi.set_min_window_size.
 *
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
 * Revision 1.19  1996/11/06  11:16:27  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.18  1996/11/01  10:20:49  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.17  1996/10/09  14:54:23  io
 * moving String from toplevel
 *
 * Revision 1.16  1996/08/14  15:27:33  johnh
 * [Bug #1548]
 * Removed spurious menuBar from the layout of the Peel Off window.
 *
 * Revision 1.15  1996/08/12  16:40:47  nickb
 * Change behaviour of the selected bar.
 * Note that some of this code is getting rather complex.
 *
 * Revision 1.14  1996/06/25  13:33:52  daveb
 * Made button buttons have different names from menu buttons, so that
 * Windows can distinguish between them, and so let us put mnemonics on
 * the menu items but not the buttons.
 *
 * Revision 1.13  1996/05/01  11:11:23  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.12  1996/04/30  10:10:34  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.11  1996/04/04  15:13:13  matthew
 * Renaming close button
 *
 * Revision 1.10  1996/04/01  15:08:36  daveb
 * Changing link system to match that of the listener and source browser.
 *
 * Revision 1.9  1995/11/16  13:20:25  matthew
 * Changing button resources
 *
 *  Revision 1.8  1995/10/30  14:16:32  daveb
 *  Added handler for EditFailed exception.
 *
 *  Revision 1.7  1995/10/25  14:30:35  nickb
 *  1. Make the profile tool a main window, rather than a popup.
 *  2. Reduce the default bar width in the profile bar chart.
 *  3. Fix the edit buttons so that their active state is updated.
 *
 *  Revision 1.6  1995/10/24  15:42:18  nickb
 *  Make info_ref update.
 *
 *  Revision 1.5  1995/10/24  15:12:58  nickb
 *  1. Make printed and graphed time proportions correspond.
 *  2. Add a line for total copying.
 *
 *  Revision 1.4  1995/10/20  11:11:34  daveb
 *  Renamed ShellUtils.edit_source to ShellUtils.edit_location.
 *
 *  Revision 1.3  1995/10/19  12:15:53  nickb
 *  Unchecked division by zero.
 *
 *  Revision 1.2  1995/10/18  13:43:16  nickb
 *  Change argument types to remove dependency on tooldata.
 *
 *  Revision 1.1  1995/10/18  12:07:00  nickb
 *  new unit
 *  New profile tool.
 *
 *)

(* functionality in the profiler tool:
 * 
 * - disconnect/reconnect
 * - close
 * - space/time slider
 * - bar chart (provided by the bar chart tool)
 *    - popup info (provided by this module to the bar chart)
 *    - scroll bars (provided by the bar chart)
 *    - layout popup (provided by the bar chart)
 *)


require "../basis/__int";
require "../basis/__real";
require "../system/__time";

require "capi";
require "menus";
require "../utils/lists";
require "../utils/crash";
require "^.utils.__messages";
require "../interpreter/shell_utils";
require "../main/preferences";
require "tooldata";
require "gui_utils";
require "bar_chart";
require "profile_tool";

functor ProfileTool (
  structure Capi : CAPI
  structure Menus : MENUS
  structure Preferences : PREFERENCES
  structure ShellUtils : SHELL_UTILS
  structure Lists : LISTS
  structure Crash : CRASH
  structure BarChart : BAR_CHART
  structure ToolData : TOOL_DATA
  structure GuiUtils : GUI_UTILS

  sharing type Menus.Widget = Capi.Widget = BarChart.Widget = ToolData.Widget = GuiUtils.Widget
  sharing type Menus.ButtonSpec = ToolData.ButtonSpec = GuiUtils.ButtonSpec
  sharing type ShellUtils.preferences = Preferences.preferences
    ) : PROFILE_TOOL =
  struct
    (* types *)

    type Widget = Capi.Widget
    type user_preferences = Preferences.user_preferences
    type ToolData = ToolData.ToolData
    type user_context = ToolData.ShellTypes.user_context

    (* miscellaneous useful values *)
    structure Profile = MLWorks.Profile

    val int_string = Int.toString
    val real_string = Real.toString
    fun message s = Messages.output("pt: "^s^"\n")

    local
      (* first, simpler data structures for profile analysis *)

      datatype function_cost = Cost of
	{time : real,  (* as a proportion of mutator time *)
	 space : real, (* as a proportion of total allocation *)
	 profile : Profile.function_profile,
	 id: bool ref (* allows simple equality testing;
		       * the bool is 'this function currently selected' *)
	 }
	
      datatype results = Result of

	{total_time : real,   (* seconds *)
	 total_space : real,  (* bytes *)
	 total_copied : real, (* bytes *)
	 total_ticks : int,
	 profile_ticks : int,
	 gc_ticks : int,
	 mutator_ticks : int,
	 functions : function_cost list}

      datatype profile_tool =
	ProfileTool of {update : results -> unit,
			id: unit ref}

      (* now some functions for manipulating multiple profile tools *)
	
      fun update_profile_tool (ProfileTool {update,...}, results) =
	update results
	
      val active_tool_ref : profile_tool option ref = ref NONE
	
      (* functions for computing the 'results' structure from a profile *)
      fun real_size (Profile.Large_Size {megabytes,bytes}) =
	if bytes = ~1 then 0.0 else
	  (real megabytes)* 1048576.0 + (real bytes)
      fun allocated (Profile.Function_Space_Profile {allocated,...}) =
	real_size allocated
      fun copied (Profile.Function_Space_Profile {copied,...}) =
	real_size copied
      fun top_ticks (Profile.Function_Time_Profile {top,...}) =
	real top
      fun proportion (x,y) = if Real.==(y,0.0) then 0.0 else x/y
	
      (* functions for manipulating results structures *)

      fun mix (f1,f2) (Cost {time,space,...}) = f1 * time + f2 * space
      fun mix_greater factors (r1,r2) = let val mix' = mix factors
					in (mix' r1) > (mix' r2)
					end
      val space_factors = (0.0,1.0)
      val time_factors = (1.0,0.0)
      fun factor space_weight = (1.0-space_weight, space_weight)
      fun sort factors functions =
	Lists.msort (mix_greater factors) functions

      fun results (Profile.Profile
		   {general = Profile.General {period, ...},
		    time = Profile.Time {scans, gc_ticks,
					 profile_ticks,...},
		    space = Profile.Space {total_profiled,...},
		    functions,
		    ...}) =
	let
	  (* time *)
	  val period = Time.toReal period
	  val total_ticks = scans + gc_ticks + profile_ticks
	  val real_scans = real scans
	  (* space *)
	  val total_space = allocated total_profiled
	  val total_copied = copied total_profiled

	  (* function *)
	  fun convert (fs,
		       prof as Profile.Function_Profile {id,
							 time,
							 space,...}) =
	    let
	      val alloc = allocated space
	      val ticks = top_ticks time
	    in
	      (* Ignore functions that took no time or space *)
	      if Real.==(alloc,0.0) andalso Real.==(ticks,0.0) then
		fs
	      else 
		Cost {profile = prof,
		       time = proportion (ticks, real_scans),
		       space = proportion (alloc, total_space),
		       id = ref false} :: fs
	    end
	  val functions =
	    Lists.reducel convert ([],functions)
	  val sorted_functions = sort (factor 0.0) functions
	in
	  (* select the most time-costly function *)
	  ((case sorted_functions of
	      ((Cost {id,...})::_) => id := true
	    | _                    => ());
	   Result {total_time = period,
		   total_space = total_space,
		   total_copied = total_copied,
		   total_ticks = total_ticks,
		   profile_ticks = profile_ticks,
		   gc_ticks = gc_ticks,
		   mutator_ticks = scans,
		   functions = sorted_functions})
	end

      (* a function to turn a real into a string with a set number of
       * decimal places *)
      local
	fun pad_zero (n,s) =
	  let
	    val zeroes = "00000"
	    val length = size s
	  in
	    if length >= n then s
	    else (MLWorks.String.substring (zeroes,0,n-length))^s
	  end
      in
	fun decimal_places n =
	  let
	    fun mult (0,x) = x
	      | mult (n,x) = mult(n-1,x*10.0)
	    fun round x = floor (mult(n,x)+0.5)
	    val factor = floor (mult(n,1.0)+0.5)
	    fun dp x =
	      (Int.toString (x div factor))^"."^
	      (pad_zero (n,Int.toString (x mod factor)))
	  in
	    fn x => dp (round x)
	  end
      end
    
      (* reporting a number of bytes as a string *)
    
      fun bytes n =
	let
	  val kilo = 1024.0
	  val mega = kilo * kilo
	  val giga = kilo * mega
	  fun num x = Int.toString (floor x)
	  val num_two = decimal_places 2
	  val (num, prefix) = 
	    if n > 10.0 * giga then (num_two (n/giga), "G")
	    else if n > 10.0 * mega then (num_two (n/mega), "M")
		 else if n > 10.0 * kilo
			then (num_two (n/kilo), "k")
		      else (num n, "")
	in
	  (num^" "^prefix^"bytes")
	end
      
      (* converting a fraction as a percentage to 2 decimals *)
    
      fun percentage (x,y) =
	if Real.==(y,0.0) then "0.00%"
	else (decimal_places 2 (x * 100.0/y))^"%"
	  
      (* profile tool stuff *)
	
      val chart_spec_ref = ref (BarChart.ChartSpec
				{bar_width = 20,
				 maximum_bars = 20,
				 maximum_tick_space = 100,
				 ideal_label_space = 100})

      fun set_chart_spec chart_spec = chart_spec_ref := chart_spec
	    
      val profile_tool_number = ref 1
      val sizeRef = ref NONE
      val posRef = ref NONE

      fun make_profile_tool (parent, results, user_preferences, mk_tooldata, get_context) =  
	let
	  val title = 
	    let val n = !profile_tool_number
	    in
	      (profile_tool_number := n+1;
	       "Profile Tool #" ^ (Int.toString n))
	    end

	  (* the last boolean argument indicates whether this window should 
	   * be included in the dynamic windows menu below the tools menu.
	   *)
	  val (shell, frame, menuBar,_) =
	    Capi.make_main_window
	       {name = "profiler",
		title = title,
		parent = parent,
		contextLabel = false,
		winMenu = true,
		pos = getOpt (!posRef, Capi.getNextWindowPos())}

	  val space_weight = ref 0.0

	  val time_results_widget1 = 
	    Capi.make_managed_widget ("timeResults1",Capi.Label,frame, [])
	  val time_results_widget2 = 
	    Capi.make_managed_widget ("timeResults2",Capi.Label,frame, [])
	  val time_results_widget3 = 
	    Capi.make_managed_widget ("timeResults3",Capi.Label,frame, [])
	  val time_results_widget4 = 
	    Capi.make_managed_widget ("timeResults4",Capi.Label,frame, [])
	  val space_results_widget1 = 
	    Capi.make_managed_widget ("spaceResults1",Capi.Label,frame, [])
	  val space_results_widget2 = 
	    Capi.make_managed_widget ("spaceResults2",Capi.Label,frame, [])
	  val function_name_widget = 
	    Capi.make_managed_widget ("functionName",Capi.Label,frame, [])
	  val function_time_widget =
	    Capi.make_managed_widget ("functionTime",Capi.Label,frame, [])
	  val function_space_widget =
	    Capi.make_managed_widget ("functionSpace",Capi.Label,frame, [])
	  val function_button_pane =
	    Capi.make_managed_widget ("functionButtonPane", Capi.RowColumn,
				      frame,[])
	  val slider_widget =
	    Capi.make_managed_widget ("sliderPane",Capi.RowColumn,frame, [])

	  (* popup management:
	    so killing the profile tool kills all the popups present *)
	    
	  val popups = ref [] : (unit ref * Capi.Widget) list ref
	    
	  local
	    fun kill_popup (_,shell) = Capi.destroy shell
	  in
	    fun add_popup (id,shell) = popups := (id,shell)::(!popups)
	    fun remove_popup id =
	      let
		fun popup_removed (acc,[]) = acc
		  | popup_removed (acc,(popup as (id',_))::xs) =
		    if id = id' then popup_removed (acc,xs)
		    else popup_removed (popup::acc,xs)
	      in
		popups := popup_removed ([],!popups)
	      end
	    fun kill_popups () = (ignore(map kill_popup (!popups));
				  popups := [])
	  end
	
	  (* this ref has the info for the currently displayed function *)
	  (* it starts off with info appropriate if there are no functions in
	   * the profile *)
	  
	  val default_function_info =
	    {fun_id = ref false,	(* true iff current selection *)
	     function_text = "No functions profiled",
	     time_text = "",
	     space_text = "",
	     edit_fn = fn () => (),
	     editable = false,
	     peelable = false}
	    
	  val current_function_info = ref default_function_info

	(* peel off a popup with the current function info *)

	  fun peel_off _ =
	    case !current_function_info of
	      {peelable = false,...} => ()
	    |  {function_text, time_text, space_text,
		edit_fn, editable,...} =>
	       let
		 val visible = ref false
		 val shell = Capi.make_popup_shell("functionProfile",shell,[],visible)
		   
		 val frame = Capi.make_subwindow shell
		   
		 val function_name_widget =
		   Capi.make_managed_widget ("functionName",Capi.Label,
					     frame, [])
		 val function_time_widget =
		   Capi.make_managed_widget ("functionTime",Capi.Label,
					     frame,[])
		 val function_space_widget =
		   Capi.make_managed_widget ("functionSpace",Capi.Label,
					     frame,[])
		 val button_pane =
		   Capi.make_managed_widget ("buttonPane",
					     Capi.RowColumn, frame,[])
		   
		 fun popup () =
		   (Capi.reveal frame;
		    visible := true;
		    Capi.to_front shell)
		   
		 val popup_id = ref ()
		   
		 fun quit _ = (remove_popup popup_id;
			       Capi.destroy shell)
		   
		 val {update = buttons_update,
		      set_focus = buttons_set_focus} =
		   Menus.make_buttons (button_pane,
				       [Menus.PUSH ("editButton",
						    fn _ =>edit_fn(),
						    fn _ => editable),
					Menus.PUSH ("closeButton",quit,
						    fn _ => true)])
		 fun set_focus () = if editable then buttons_set_focus 0
				    else buttons_set_focus 1
	       in
		 Capi.set_label_string(function_name_widget, function_text);
		 Capi.set_label_string(function_time_widget, time_text);
		 Capi.set_label_string(function_space_widget, space_text);
		 add_popup (popup_id, shell);
		 Capi.Layout.lay_out
		 (frame, NONE,
		  [Capi.Layout.FIXED function_name_widget,
		   Capi.Layout.FIXED function_time_widget,
		   Capi.Layout.FIXED function_space_widget,
		   Capi.Layout.SPACE,
		   Capi.Layout.FIXED button_pane]);
		 popup();
		 set_focus();
		 buttons_update()
	       end

	  (* dealing with a code name string *)

	  fun get_name_and_location code_name =
	    let
	      fun aux1(#"["::l,acc) = (acc,l)
		| aux1(c::l,acc) = aux1(l,c::acc)
		| aux1([],acc) = (acc,[])
	      fun aux2([#"]"],acc) = (acc,nil)
		| aux2(#"]"::l,acc) = (acc,l)
		| aux2(c::l,acc) = aux2(l,c::acc)
		| aux2([],acc) = (acc,nil)
	      val (namechars,rest) = aux1(explode code_name,[])
	      val (locchars,rest) = aux2 (rest,[])
	    in
	      (implode(rev namechars),implode(rev locchars),implode rest)
	    end

	  fun name_and_edit code_name = 
	    let
	      val (fun_name,loc_string,_) = get_name_and_location code_name

	      val location =
		ShellUtils.Info.Location.from_string loc_string
		handle ShellUtils.Info.Location.InvalidLocation
		=>  ShellUtils.Info.Location.UNKNOWN
		  
	      fun edit () =
		(ignore(ShellUtils.edit_location
		 (location, Preferences.new_preferences user_preferences));
		 ())
		handle
		  ShellUtils.EditFailed s =>
		    Capi.send_message (shell, "Edit failed: " ^ s)
		
	      val editable = ShellUtils.editable location
	    in
	      (fun_name,edit,editable)
	    end

	  fun edit _ = #edit_fn (!current_function_info) ()
	  fun editable _ = #editable (!current_function_info)
	  fun peelable _ = #peelable (!current_function_info)

	  (* Make the edit and peel buttons. The fn_buttons_update
	   * function should be called when the editable or peelable
	   * buttons might change, i.e. when the current function
	   * might change *)

	  val {update = fn_buttons_update,
	       set_focus = fn_buttons_set_focus} = 
	    Menus.make_buttons
	      (function_button_pane,
	       [Menus.PUSH("editButton",edit,editable),
		Menus.PUSH("peelButton",peel_off,peelable)])

	  (* functions for manipulating the current function info *)

	  fun set_current_function_info fi =
	    (current_function_info := fi;
	     (if #editable fi then
		fn_buttons_set_focus 0
	      else ());
	      fn_buttons_update())

	  fun reset_function_info () =
	    set_current_function_info default_function_info
	    
	  fun show_function_info () =
	    let
	      val {function_text, time_text, space_text,...} =
		!current_function_info
	    in
	      Capi.set_label_string(function_name_widget, function_text);
	      Capi.set_label_string(function_time_widget, time_text);
	      Capi.set_label_string(function_space_widget, space_text)
	    end

	  (* display the text and set the info for a given function *)
	    
	  fun do_function_info (Profile.Function_Profile
				{id, time, space, call_count}, fun_id,
				(mutator_ticks, tick,total_space)) =
	    let val old_fun_id = #fun_id (!current_function_info)
	    in
	      if (fun_id = old_fun_id) then ()
	      else
		let
		  val _ = old_fun_id := false
		  val _ = fun_id := true
		  val (fn_name, edit,editable) = name_and_edit id
		    
		  val function_text = "Function: "^fn_name
		    
		  val Profile.Function_Time_Profile
		    {found,top,scans,depth,self,callers} = time
		    
		  val approx_time = (real top) * tick
		    
		  val time_text =
		    "Time: "^(decimal_places 2 approx_time)^" s ("^
		    percentage (real top,real mutator_ticks)^", "^
		    (int_string top)^ " ticks)"
		    
		  val Profile.Function_Space_Profile
		    {allocated,copied,copies,allocation} = space
		    
		  val alloc = real_size allocated
		  val copy = real_size copied
		    
		  val space_text =
		    "Space: "^ (bytes alloc) ^" ("^
		    percentage (alloc,total_space)^"), "^
		    (bytes copy)^" copied ("^(percentage (copy,alloc))^
		    " alloc)"
		in
		  set_current_function_info 
		  {fun_id = fun_id,
		   function_text = function_text,
		   time_text = time_text,
		   space_text = space_text,
		   edit_fn = edit,
		   editable = editable,
		   peelable = true};
		  show_function_info()
		end
	    end
	  
	  (* show as text the main results of the profile *)
	     
	  fun show_textual_results (total_time, total_space, total_copied,
				    total_ticks, profile_ticks, gc_ticks,
				    mutator_ticks) =
	    let
	      val profile_time = 
		if total_ticks = 0 then 0.0 else
		  total_time * (real profile_ticks/real total_ticks)
	      val non_profile_time = total_time - profile_time
	      val ticks = gc_ticks + mutator_ticks
	      val tick = if ticks = 0 then 0.0
			 else non_profile_time / (real ticks)
	      val mutator_time = (real mutator_ticks) * tick
	      val gc_time = (real gc_ticks) * tick
	      val time_results_1 =
		"Total time: "^(decimal_places 2 total_time)^ " s ("^
		(int_string total_ticks)^" ticks)"
	      val time_results_2 = 
		"Profile time: "^(decimal_places 2 profile_time)^" s ("^
		(int_string profile_ticks)^" ticks, "^
		percentage(profile_time,total_time)^")"
	      val time_results_3 = 
		"ML time: "^(decimal_places 2 mutator_time)^" s ("^
		(int_string mutator_ticks)^" ticks, "^
		percentage(mutator_time, non_profile_time)^")"
	      val time_results_4 = 
		"GC time: "^(decimal_places 2 gc_time)^" s ("^
		(int_string gc_ticks)^" ticks, "^
		percentage(gc_time,non_profile_time)^")"
	      val space_results_1 = "Total allocation: "^(bytes total_space)
	      val space_results_2 = "Total copying: "^(bytes total_copied)
	    in
	      Capi.set_label_string (time_results_widget1,time_results_1);
	      Capi.set_label_string (time_results_widget2,time_results_2);
	      Capi.set_label_string (time_results_widget3,time_results_3);
	      Capi.set_label_string (time_results_widget4,time_results_4);
	      Capi.set_label_string (space_results_widget1,space_results_1);
	      Capi.set_label_string (space_results_widget2,space_results_2);
	      (mutator_ticks, tick, total_space)
	    end
	  
	  (* our notion of the currently selected bar *)

	  val selected_bar = ref 0

	  val bar_list_ref : BarChart.bar list ref = ref []

	  fun get_bar_list () = (!bar_list_ref,!selected_bar)

	  (* making bar values *)

	  fun make_bar_list
	    (info,(cost as Cost {time, space, profile,id})::costs, n, bars) =
	    let
	      val height = (mix (factor (!space_weight)) cost) * 100.0
	      val Profile.Function_Profile {id = key,...} = profile
	      fun click_action n =
		(selected_bar := n;
		 do_function_info (profile,id,info))
	      val bar =
		BarChart.Bar {height=height,key=key,click_action=click_action}
	    in 
	      (if (!id) then click_action n else ();
	       make_bar_list (info, costs, n+1, bar::bars))
	    end
	    | make_bar_list (info, [], _, bars) = rev bars
				  
	  (* making the bar chart *)

	  val {widget = bc_widget,
	       initialize = bc_initialize,
	       update = bc_update, 
	       popup = bc_popup} 
	    = BarChart.make (!chart_spec_ref,set_chart_spec,
			     get_bar_list,frame)
	    
	  (* we keep the current results in this ref, for passing to
	     duplicate tools. *)
	  val results_ref = ref results

	  (* we keep the functions for the current graph in this ref *)
	  val functions_ref = ref [] : function_cost list ref

	  (* shows the top-level results, and updates the functions ref *)

	  fun show_results results = 
	    let
	      val Result {total_time, total_space, total_copied, total_ticks,
			  profile_ticks, gc_ticks, mutator_ticks,
			  functions} = results
	      (* display the new textual results in the top pane *)
	    in
	      reset_function_info();
	      functions_ref := functions;
	      show_textual_results(total_time, total_space, total_copied,
				   total_ticks, profile_ticks, gc_ticks,
				   mutator_ticks)
	    end

	(* we keep what top-level information we need for writing function
	 * info in a ref *)

	  val info_ref = ref (show_results results)

	  fun any_space () = (#3 (!info_ref)) > 0.5
	  fun any_time () = (#1 (!info_ref)) > 0

	  (* call this function when the set of functions or the space
	   * weight has changed; it recomputes and redisplays the bar
	   * chart *)

	  fun show_functions () = 
	    (bar_list_ref := make_bar_list (!info_ref, !functions_ref, 0, []);
	     (case (!functions_ref) of
		[] => show_function_info()
	      | _  => ());
	     bc_update ())

	  (* call this function when we think it's a good idea to sort the
	   * bars according to the current weight *)

	  fun sort_functions () = 
	    let
	      val functions = !functions_ref
	      val factors = factor (!space_weight)
	      val sorted_functions = sort factors functions
	    in
	      functions_ref := sorted_functions;
	      show_functions()
	    end

	  (* when the profile tool is presented with a new set of results: *)

	  fun update results = 
	    (info_ref := (show_results results);
	     results_ref := results;
	     show_functions ())
	    
	  (* we're now ready to create the profile tool value itself : *)

	  val tool_id = ref ()
	    
	  val tool = ProfileTool {update = update,
				  id = tool_id}

	  (* actions for menu buttons, slider, &c *)
	    
	  fun layout_action _ = bc_popup()
	    
          fun storeSizePos () = 
	    (sizeRef := SOME (Capi.widget_size shell);
	     posRef := SOME (Capi.widget_pos shell))

	  fun destroy_action _ = 
		(kill_popups ();
		 Menus.quit ();
		 storeSizePos ();
		 active_tool_ref := NONE)

	  fun quit a = 
		(destroy_action a;
		 Capi.destroy shell)

	  val space_factor = ref 0

	  fun set_space_factor n =
	    if (any_space()) andalso (n <> !space_factor) then
	      (space_factor := n;
	       space_weight := (real n / 100.0);
	       show_functions ())
	    else ()

          fun duplicate _ =
	    (ignore(make_profile_tool (parent, !results_ref,user_preferences,mk_tooldata,get_context));
	     ())
	    
	  (* main menus and buttons *)

	  val menuspec =
	    [ToolData.file_menu [("close",quit, fn _ => true)],
	     ToolData.edit_menu (frame,
              {cut = NONE,
               paste = NONE,
               copy = NONE,
               delete = NONE,
	       edit_possible = fn _ => false,
               selection_made = fn _ => false,
	       delete_all = NONE,
	       edit_source = [Menus.PUSH ("editSource", edit, editable)]}),
	     ToolData.tools_menu (mk_tooldata, get_context),
	     ToolData.usage_menu ([("duplicate", duplicate, fn _ => true),
				   ("layout", layout_action, fn () => true),
				   ("sort", sort_functions, fn _ => true),
				   ("peel", peel_off, peelable)], []),
	     ToolData.debug_menu []]
	    
	  val {update = slider_update,
	       set_focus = slider_set_focus} = 
	    Menus.make_buttons (slider_widget,
				[Menus.LABEL "timeButton",
				 Menus.SLIDER ("slider", 0, 100,
					       set_space_factor),
				 Menus.LABEL "spaceButton"])

	in
	  Menus.make_submenus(menuBar, menuspec);
	  Capi.Layout.lay_out
	  (frame, !sizeRef,
	   [Capi.Layout.MENUBAR menuBar,
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED time_results_widget1,
	    Capi.Layout.FIXED time_results_widget2,
	    Capi.Layout.FIXED time_results_widget3,
	    Capi.Layout.FIXED time_results_widget4,
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED space_results_widget1,
	    Capi.Layout.FIXED space_results_widget2,
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED slider_widget,
	    Capi.Layout.FLEX bc_widget,
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED function_name_widget,
	    Capi.Layout.FIXED function_time_widget,
	    Capi.Layout.FIXED function_space_widget,
	    Capi.Layout.FIXED function_button_pane,
	    Capi.Layout.SPACE
	    ]);
	  Capi.Callback.add (shell, Capi.Callback.Destroy, destroy_action);
	  Capi.set_close_callback(frame, quit);
	  Capi.set_min_window_size(shell, 420, 600);
	  Capi.initialize_toplevel shell;
	  bc_initialize ();
	  show_functions();
	  fn_buttons_update();
	  tool
	end (* make_profile_tool *)
    in
      fun create (shell, user_preferences, mk_tooldata, get_context) profile =
	let val results = results profile
	in
	  case !active_tool_ref of
	    NONE =>
	      let
		val t = make_profile_tool (shell, results, user_preferences, 
					   mk_tooldata, get_context)
	      in
		active_tool_ref := SOME t
	      end
	  | SOME t => update_profile_tool (t,results)
	end
    end (* local *)
  end
@


1.32.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.32  1999/03/23  18:04:02  johnh
 * [Bug #190538]
 * Fix problem with exiting.
 *
@


1.31
log
@[Bug #30400]
Fix returning to and from tty mode.
@
text
@d6 4
d792 9
a800 5
	  fun quit _ = (kill_popups ();
			Menus.quit ();
			storeSizePos ();
			active_tool_ref := NONE;
			Capi.destroy shell)
d866 1
a866 1
	  Capi.Callback.add (shell, Capi.Callback.Destroy, quit);
@


1.30
log
@[Bug #30346]
Call Capi.getNextWindowPos().
@
text
@d6 4
d858 1
@


1.29
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d6 4
d375 1
a375 1
		pos = getOpt (!posRef, (100,100))}
@


1.28
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d6 4
d417 1
a417 1
	    fun kill_popups () = (map kill_popup (!popups);
d526 2
a527 2
		(ShellUtils.edit_location
		 (location, Preferences.new_preferences user_preferences);
d796 1
a796 1
	    (make_profile_tool (parent, !results_ref,user_preferences,mk_tooldata,get_context);
@


1.27
log
@[Bug #70065]
Remove uses of MLWorks.IO.messages and use the Messages structure
@
text
@d6 4
d345 2
d361 7
a367 1
	    Capi.make_main_window("profiler",title,parent,false, true)
d484 1
a484 1
		 (frame,
d772 4
d778 1
d826 1
a826 1
	  (frame,
@


1.26
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d6 4
d132 1
d168 1
a168 1
    fun message s = MLWorks.IO.output(MLWorks.IO.messages,"pt: "^s^"\n");
@


1.25
log
@[Bug #30089]
Change use of MLWorks.Time.Interval for corresponding basis function
@
text
@d6 11
d791 1
a791 2
	     ToolData.debug_menu [],
	     GuiUtils.paths_menu frame]
@


1.24
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d6 4
d111 1
d220 1
a220 1
	  val period = MLWorks.Time.Interval.to_real period
@


1.24.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 4
 * Revision 1.24  1997/06/12  14:58:04  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
@


1.24.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a5 3
 * Revision 1.24.2.1  1997/09/11  20:51:37  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d779 2
a780 1
	     ToolData.debug_menu []]
@


1.24.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 4
 * Revision 1.24  1997/06/12  14:58:04  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
@


1.23
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d6 4
d330 3
d334 1
a334 1
	    Capi.make_main_window("profiler",title,parent,false)
d776 1
a776 2
	     GuiUtils.paths_menu frame,
	     ToolData.windows_menu ()]
@


1.22
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d6 4
d110 2
d123 2
d126 2
a127 1
  sharing type Menus.Widget = Capi.Widget = BarChart.Widget
d135 2
d317 1
a317 1
      fun make_profile_tool (parent, results, user_preferences) =  
d400 2
a401 3
		 
		 val shell = Capi.make_popup_shell("functionProfile",
						   shell,[])
d420 1
d733 1
d747 1
a747 1
	    (make_profile_tool (parent, !results_ref, user_preferences);
d753 18
a770 12
	    [Menus.CASCADE
	       ("action",
	        [Menus.PUSH("edit",edit,editable),
                 Menus.PUSH ("duplicate", duplicate, fn _ => true),
		 Menus.PUSH ("sort", sort_functions, fn _ => true),
		 Menus.SEPARATOR,
	         Menus.PUSH ("close",quit, fn _ => true)],
		fn _ => true),
	     Menus.CASCADE ("view",
			    [Menus.PUSH ("layout",layout_action,
					 fn _ => true)],
			    fn _ => true)]
d812 1
a812 1
      fun create (shell, user_preferences) profile =
d818 2
a819 1
		val t = make_profile_tool (shell, results, user_preferences)
@


1.21
log
@[Bug #1954]
Added a call to Capi.set_min_window_size.
@
text
@d6 4
a128 1
    open MLWorks.Option
@


1.21.1.1
log
@branched from 1.21
@
text
@a5 4
 * Revision 1.21  1997/03/17  14:35:25  johnh
 * [Bug #1954]
 * Added a call to Capi.set_min_window_size.
 *
@


1.21.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.21.1.1  1997/05/12  10:31:51  hope
 * branched from 1.21
 *
@


1.21.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.21.1.1  1997/05/12  10:31:51  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.21.1.1  1997/05/12  10:31:51  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.21.1.1.1.1  1997/07/28  18:16:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.20
log
@[Bug #1711]
Circumventing the problem of reals not being an eqtype.
@
text
@d6 4
d783 1
@


1.20.5.1
log
@branched from 1.20
@
text
@a5 4
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
@


1.20.4.1
log
@branched from 1.20
@
text
@a5 4
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
@


1.20.4.1.1.1
log
@branched from 1.20.4.1
@
text
@a5 3
 * Revision 1.20.4.1  1996/12/17  17:45:31  hope
 * branched from 1.20
 *
@


1.20.3.1
log
@branched from 1.20
@
text
@a5 4
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
@


1.20.2.1
log
@branched from 1.20
@
text
@a5 4
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a5 4
 * Revision 1.20  1996/11/06  13:26:15  andreww
 * [Bug #1711]
 * Circumventing the problem of reals not being an eqtype.
 *
@


1.20.1.1.1.1
log
@branched from 1.20.1.1
@
text
@a5 3
 * Revision 1.20.1.1  1996/11/14  12:46:34  hope
 * branched from 1.20
 *
@


1.19
log
@[Bug #1728]
__integer becomes __int
@
text
@d6 4
d114 2
d170 1
a170 1
      fun proportion (x,y) = if y = 0.0 then 0.0 else x/y
d210 1
a210 1
	      if alloc = 0.0 andalso ticks = 0.0 then
d284 1
a284 1
	if y = 0.0 then "0.00%"
@


1.18
log
@Enabling close from control box on top left of window.
@
text
@d6 3
d85 1
a85 1
require "../basis/__integer";
@


1.17
log
@moving String from toplevel
@
text
@d6 3
d769 1
@


1.16
log
@[Bug #1548]
Removed spurious menuBar from the layout of the Peel Off window.
@
text
@d6 4
d429 1
a429 1
	      fun aux1("["::l,acc) = (acc,l)
d432 2
a433 2
	      fun aux2(["]"],acc) = (acc,nil)
		| aux2("]"::l,acc) = (acc,l)
d436 1
a436 1
	      val (namechars,rest) = aux1(String.explode code_name,[])
d439 1
a439 1
	      (String.implode(rev namechars),String.implode(rev locchars),String.implode rest)
@


1.16.3.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/14  15:27:33  johnh
 * [Bug #1548]
 * Removed spurious menuBar from the layout of the Peel Off window.
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/14  15:27:33  johnh
 * [Bug #1548]
 * Removed spurious menuBar from the layout of the Peel Off window.
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a5 4
 * Revision 1.16  1996/08/14  15:27:33  johnh
 * [Bug #1548]
 * Removed spurious menuBar from the layout of the Peel Off window.
 *
@


1.15
log
@Change behaviour of the selected bar.
Note that some of this code is getting rather complex.
@
text
@d6 4
d411 1
a411 2
		  [Capi.Layout.MENUBAR menuBar,
		   Capi.Layout.FIXED function_name_widget,
@


1.14
log
@Made button buttons have different names from menu buttons, so that
Windows can distinguish between them, and so let us put mnemonics on
the menu items but not the buttons.
@
text
@d6 5
d114 3
a116 1
	 id: unit ref (* allows simple equality testing *)}
d152 12
d196 1
a196 1
		       id = ref ()} :: fs
d200 1
d202 12
a213 8
	  Result {total_time = period,
		  total_space = total_space,
		  total_copied = total_copied,
		  total_ticks = total_ticks,
		  profile_ticks = profile_ticks,
		  gc_ticks = gc_ticks,
		  mutator_ticks = scans,
		  functions = functions}
d216 51
a266 12
      (* functions for manipulating results structures *)

      fun mix (f1,f2) (Cost {time,space,...}) = f1 * time + f2 * space
      fun mix_greater factors (r1,r2) = let val mix' = mix factors
					in (mix' r1) > (mix' r2)
					end
      val space_factors = (0.0,1.0)
      val time_factors = (1.0,0.0)
      fun factor space_weight = (1.0-space_weight, space_weight)
      fun sort factors functions =
	Lists.msort (mix_greater factors) functions

d317 5
a321 3

	  (* a function to turn a real into a string with a set number of
	   * decimal places *)
d323 1
a323 8
	    fun pad_zero (n,s) =
	      let
		val zeroes = "00000"
		val length = size s
	      in
		if length >= n then s
		else (MLWorks.String.substring (zeroes,0,n-length))^s
	      end
d325 2
a326 1
	    fun decimal_places n =
d328 4
a331 7
		fun mult (0,x) = x
		  | mult (n,x) = mult(n-1,x*10.0)
		fun round x = floor (mult(n,x)+0.5)
		val factor = floor (mult(n,1.0)+0.5)
		fun dp x =
		  (Int.toString (x div factor))^"."^
		  (pad_zero (n,Int.toString (x mod factor)))
d333 1
a333 1
		fn x => dp (round x)
d335 2
d338 13
a350 2

	  (* reporting a number of bytes as a string *)
d352 1
a352 16
	  fun bytes n =
	    let
	      val kilo = 1024.0
	      val mega = kilo * kilo
	      val giga = kilo * mega
	      fun num x = Int.toString (floor x)
	      val num_two = decimal_places 2
	      val (num, prefix) = 
		if n > 10.0 * giga then (num_two (n/giga), "G")
		else if n > 10.0 * mega then (num_two (n/mega), "M")
		     else if n > 10.0 * kilo
			    then (num_two (n/kilo), "k")
			  else (num n, "")
	    in
	      (num^" "^prefix^"bytes")
	    end
d354 1
a354 1
	  (* converting a fraction as a percentage to 2 decimals *)
d356 61
a416 3
	  fun percentage (x,y) =
	    if y = 0.0 then "0.00%"
	    else (decimal_places 2 (x * 100.0/y))^"%"
d457 24
a480 14
	  (* this ref has the info for the currently displayed function *)
	  (* it starts off with info appropriate if there are no functions in
	   * the profile *)
	  
	  val default_function_info =
	    {fun_id = ref (),
	     function_text = "No functions profiled",
	     time_text = "",
	     space_text = "",
	     edit_fn = fn () => (),
	     editable = false,
	     peelable = false}
	    
	  val current_function_info = ref default_function_info
d483 1
a483 1
	    current_function_info := default_function_info
d505 2
d533 1
a533 1
		  current_function_info :=
a544 90
	  fun edit _ = #edit_fn (!current_function_info) ()
	  fun editable _ = #editable (!current_function_info)
	  fun peelable _ = #peelable (!current_function_info)

	  (* popup control:
	    so killing the profile tool kills all the popups present *)
	    
	  val popups = ref [] : (unit ref * Capi.Widget) list ref
	    
	  local
	    fun kill_popup (_,shell) = Capi.destroy shell
	  in
	    fun add_popup (id,shell) = popups := (id,shell)::(!popups)
	    fun remove_popup id =
	      let
		fun popup_removed (acc,[]) = acc
		  | popup_removed (acc,(popup as (id',_))::xs) =
		    if id = id' then popup_removed (acc,xs)
		    else popup_removed (popup::acc,xs)
	      in
		popups := popup_removed ([],!popups)
	      end
	    fun kill_popups () = (map kill_popup (!popups);
				  popups := [])
	  end
	
	(* peel off a popup with the current function info *)

	  fun peel_off _ =
	    case !current_function_info of
	      {peelable = false,...} => ()
	    |  {function_text, time_text, space_text,
		edit_fn, editable,...} =>
	       let
		 
		 val shell = Capi.make_popup_shell("functionProfile",
						   shell,[])
		   
		 val frame = Capi.make_subwindow shell
		   
		 val function_name_widget =
		   Capi.make_managed_widget ("functionName",Capi.Label,
					     frame, [])
		 val function_time_widget =
		   Capi.make_managed_widget ("functionTime",Capi.Label,
					     frame,[])
		 val function_space_widget =
		   Capi.make_managed_widget ("functionSpace",Capi.Label,
					     frame,[])
		 val button_pane =
		   Capi.make_managed_widget ("buttonPane",
					     Capi.RowColumn, frame,[])
		   
		 fun popup () =
		   (Capi.reveal frame;
		    Capi.to_front shell)
		   
		 val popup_id = ref ()
		   
		 fun quit _ = (remove_popup popup_id;
			       Capi.destroy shell)
		   
		 val {update = buttons_update,
		      set_focus = buttons_set_focus} =
		   Menus.make_buttons (button_pane,
				       [Menus.PUSH ("editButton",
						    fn _ =>edit_fn(),
						    fn _ => editable),
					Menus.PUSH ("closeButton",quit,
						    fn _ => true)])
		 fun set_focus () = if editable then buttons_set_focus 0
				    else buttons_set_focus 1
	       in
		 Capi.set_label_string(function_name_widget, function_text);
		 Capi.set_label_string(function_time_widget, time_text);
		 Capi.set_label_string(function_space_widget, space_text);
		 add_popup (popup_id, shell);
		 Capi.Layout.lay_out
		 (frame,
		  [Capi.Layout.MENUBAR menuBar,
		   Capi.Layout.FIXED function_name_widget,
		   Capi.Layout.FIXED function_time_widget,
		   Capi.Layout.FIXED function_space_widget,
		   Capi.Layout.SPACE,
		   Capi.Layout.FIXED button_pane]);
		 popup();
		 set_focus();
		 buttons_update()
	       end

d587 8
d597 2
a598 2
	  fun make_bar info
	    (cost as Cost {time, space, profile,id}) =
d602 8
a609 3
	      fun click_action () =
		do_function_info (profile,id,info)
	    in BarChart.Bar {height=height,key=key,click_action=click_action}
d611 2
a612 8
	  
	  fun make_bar_list (info, functions) = 
	    map (make_bar info) functions

	  val bar_list_ref : BarChart.bar list ref = ref []

	  fun get_bar_list () = !bar_list_ref

a644 10
	    (* the function-related buttons *)


	  val {update = fn_buttons_update,
	       set_focus = fn_buttons_set_focus} = 
	    Menus.make_buttons
	      (function_button_pane,
	       [Menus.PUSH("editButton",edit,editable),
		Menus.PUSH("peelButton",peel_off,peelable)])

d653 10
a662 5
	  fun show_first_function functions =
	    case functions of
	      ((Cost{profile,id,...})::_) =>
		do_function_info (profile,id,!info_ref)
	    | _ => show_function_info ()
d664 2
a665 2
	  (* call this function when either the set of functions
	   * or the space weight has changed *)
d667 1
a667 1
	  fun show_functions () = 
a672 1
	      show_first_function sorted_functions;
d674 1
a674 3
	      bar_list_ref := make_bar_list (!info_ref, sorted_functions);
	      fn_buttons_update();
	      bc_update ()
d719 1
a735 8

	  (* focus is on the edit button if that is active *)

	  fun set_focus () =
	    if #editable (!current_function_info) then
	      fn_buttons_set_focus 0
	    else ()

a761 1
	  set_focus ();
@


1.13
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d6 6
d486 1
a486 1
				       [Menus.PUSH ("edit",
a605 1
	  val edit_button = Menus.PUSH("edit",edit,editable)
d609 4
a612 3
	    Menus.make_buttons (function_button_pane,
				[edit_button,
				 Menus.PUSH("peel",peel_off,peelable)])
a680 9
	  val close_button = Menus.PUSH ("close",quit,
					 fn _ => true)

	  val duplicate_button =
            Menus.PUSH
              ("duplicate",
	       duplicate,
               fn _ => true)

d684 2
a685 2
		[edit_button,
		 duplicate_button,
d687 1
a687 1
		 close_button],
d697 1
a697 1
				[Menus.LABEL "time",
d700 1
a700 1
				 Menus.LABEL "space"])
@


1.12
log
@Replacing MLWorks.Integer with basis file
@
text
@d6 3
d94 1
a94 1
    fun message s = output(MLWorks.IO.messages,"pt: "^s^"\n");
d311 1
a311 1
	      val (namechars,rest) = aux1(explode code_name,[])
d314 1
a314 1
	      (implode(rev namechars),implode(rev locchars),implode rest)
@


1.11
log
@Renaming close button
@
text
@d6 3
d57 3
d89 2
a90 2
    val int_string = MLWorks.Integer.makestring
    val real_string = MLWorks.Real.makestring
d213 1
a213 1
	       "Profile Tool #" ^ (MLWorks.Integer.makestring n))
d265 2
a266 2
		  (MLWorks.Integer.makestring (x div factor))^"."^
		  (pad_zero (n,MLWorks.Integer.makestring (x mod factor)))
d279 1
a279 1
	      fun num x = MLWorks.Integer.makestring (floor x)
@


1.10
log
@Changing link system to match that of the listener and source browser.
@
text
@d6 3
d474 1
a474 1
					Menus.PUSH ("close",quit,
@


1.9
log
@Changing button resources
@
text
@d6 3
d78 2
a79 1
    structure Option = MLWorks.Option
d102 1
a102 2
	 functions : function_cost list,
	 zero_functions : Profile.function_id list}
d113 1
a113 1
      val active_tools : profile_tool list ref = ref []
a114 21
      fun activate_tool tool = active_tools := tool :: (!active_tools)
	
      fun deactivate_tool id = 
	let
	  fun remove_tool (acc,[]) = acc
	    | remove_tool (acc,(tool as ProfileTool{id=id',...})::tools) =
	      if id = id' then remove_tool (acc,tools)
	      else remove_tool (tool::acc,tools)
	in
	  active_tools := remove_tool ([],!active_tools)
	end
      
      fun active_tool id = 
	let
	  fun active [] = false
	    | active ((ProfileTool{id=id',...})::tools) =
	      id = id' orelse active tools
	in
	  active (!active_tools)
	end
      
d142 1
d144 1
a144 1
	  fun convert ((fs,zfs),
d152 1
d154 3
a156 2
		(fs,id::zfs) else 
		(Cost {profile = prof,
d159 1
a159 2
		       id = ref ()} :: fs,
		 zfs)
d161 2
a162 2
	  val (functions, zero_functions) =
	    Lists.reducel convert (([],[]),functions)
d171 1
a171 2
		  functions = functions,
		  zero_functions = zero_functions}
d198 1
a198 1
      fun make_profile_tool (shell, results, user_preferences) =  
d208 1
a208 1
	    Capi.make_main_window("profiler",title,shell,false)
a223 2
	  val button_pane =
	    Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, [])
d563 4
a567 1

d576 1
a576 1
			  functions, zero_functions} = results
d630 1
d645 1
a645 1
			deactivate_tool tool_id;
a647 3
	  fun active_action true  = activate_tool tool
	    | active_action false = deactivate_tool tool_id
	      
d657 4
d665 7
d673 7
a679 2
	    [Menus.CASCADE ("action",
			    [edit_button,close_button], fn _ => true),
a684 9
	  val {update = buttons_update,
	       set_focus = buttons_set_focus} =
	    Menus.make_buttons (button_pane,
				[Menus.TOGGLE ("active",
					       fn _ => true,
					       active_action,
					       fn _ => true),
				 close_button])

d697 3
a699 2
	    if #editable (!current_function_info) then fn_buttons_set_focus 0
	    else buttons_set_focus 0
d706 1
d711 1
d714 3
a716 1
	    Capi.Layout.FIXED button_pane,
d722 2
a723 3
	    Capi.Layout.SPACE,
	    Capi.Layout.FIXED slider_widget,
	    Capi.Layout.FLEX bc_widget]);
d728 2
a729 3
	  activate_tool tool;
	  buttons_update ();
	  fn_buttons_update()
d735 8
a742 4
	  case (!active_tools) of
	    [] =>
	      make_profile_tool (shell, results, user_preferences)
	  | l => Lists.iterate (fn t => update_profile_tool (t,results)) l
@


1.8
log
@Added handler for EditFailed exception.
@
text
@d6 3
d487 1
a487 1
				       [Menus.PUSH ("editButton",
d490 1
a490 1
					Menus.PUSH ("closeButton",quit,
d604 1
a604 1
	  val edit_button = Menus.PUSH("editButton",edit,editable)
d610 1
a610 1
				 Menus.PUSH("peelButton",peel_off,peelable)])
d677 1
a677 1
	  val close_button = Menus.PUSH ("closeButton",quit,
d683 1
a683 1
			    [Menus.PUSH ("layoutButton",layout_action,
d690 1
a690 1
				[Menus.TOGGLE ("activeButton",
@


1.7
log
@1. Make the profile tool a main window, rather than a popup.
2. Reduce the default bar width in the profile bar chart.
3. Fix the edit buttons so that their active state is updated.
@
text
@d6 5
d334 3
@


1.6
log
@Make info_ref update.
@
text
@d6 3
d198 1
a198 1
				{bar_width = 40,
d217 1
a217 1
	    Capi.make_main_popup("profiler",title,shell,false)
a218 4
	  fun popup () =
	    (Capi.reveal frame;
	     Capi.to_front shell)
	    
d591 10
d627 1
d637 1
a637 1
	(* we're now ready to create the profile tool value itself : *)
d664 1
a664 1
	  (* menus and buttons *)
a667 2
	  val edit_button = Menus.PUSH("editButton",edit,editable)

a684 6
	  val {update = fn_buttons_update,
	       set_focus = fn_buttons_set_focus} = 
	    Menus.make_buttons (function_button_pane,
				[edit_button,
				 Menus.PUSH("peelButton",peel_off,peelable)])

d698 1
a698 1
	    else ()
d720 1
a720 1
	  popup ();
@


1.5
log
@1. Make printed and graphed time proportions correspond.
2. Add a line for total copying.
@
text
@d6 4
d624 1
a624 1
	    (show_results results;
@


1.4
log
@Renamed ShellUtils.edit_source to ShellUtils.edit_location.
@
text
@d6 3
d62 2
d69 1
a69 1
	{time : real,  (* as a proportion of non-profile time *)
d78 1
d124 2
d141 1
a141 1
	  val non_profile_ticks = real (scans + gc_ticks)
d144 1
d157 1
a157 1
		       time = proportion (ticks, non_profile_ticks),
d167 1
d226 4
a229 2
	  val space_results_widget = 
	    Capi.make_managed_widget ("spaceResults",Capi.Label,frame, [])
d336 13
a348 8
	  val current_function_info =
	    ref {fun_id = ref (),
		 function_text = "No functions profiled",
		 time_text = "",
		 space_text = "",
		 edit_fn = fn () => (),
		 editable = false,
		 peelable = false}
d350 10
d404 1
a404 3
		  Capi.set_label_string(function_name_widget, function_text);
		  Capi.set_label_string(function_time_widget, time_text);
		  Capi.set_label_string(function_space_widget, space_text)
d500 3
a502 2
	  fun show_textual_results (total_time, total_space, total_ticks,
				    profile_ticks, gc_ticks, mutator_ticks) =
d528 2
a529 1
	      val space_results = "Total allocation: "^(bytes total_space)
d535 2
a536 1
	      Capi.set_label_string (space_results_widget,space_results);
d576 1
a576 1
	      val Result {total_time, total_space, total_ticks,
d581 1
d583 3
a585 2
	      show_textual_results(total_time, total_space, total_ticks,
				   profile_ticks, gc_ticks, mutator_ticks)
d593 3
d600 1
a600 1
	    | _ => ()
d644 1
a644 1
	    if (n <> !space_factor) then
d683 1
a683 1
				 Menus.SLIDER ("slider",0,100,
d703 2
a704 1
	    Capi.Layout.FIXED space_results_widget,
@


1.3
log
@Unchecked division by zero.
@
text
@d6 3
d311 1
a311 1
		(ShellUtils.edit_source
@


1.2
log
@Change argument types to remove dependency on tooldata.
@
text
@d6 3
d480 2
a481 1
	      val tick = non_profile_time / (real ticks)
@


1.1
log
@new unit
New profile tool.
@
text
@d5 5
a9 1
 *  $Log$
a25 1
require "tooldata";
a35 1
  structure ToolData : TOOL_DATA
d42 1
a42 3
  sharing type Menus.Widget = Capi.Widget = BarChart.Widget = ToolData.Widget
  sharing type ToolData.ShellTypes.user_preferences =
    Preferences.user_preferences
d47 1
a47 1
    type ToolData = ToolData.ToolData
d184 1
a184 1
      fun make_profile_tool (applicationshell, results, tooldata) =  
a185 2
	  val ToolData.TOOLDATA {args = ToolData.ShellTypes.LISTENER_ARGS
				 {user_preferences,...},...} = tooldata
d194 1
a194 1
	    Capi.make_main_popup("profiler",title,applicationshell,false)
d682 1
a682 1
      fun create (applicationshell, profile, tooldata) =
d686 2
a687 1
	    [] => make_profile_tool (applicationshell, results, tooldata)
@
