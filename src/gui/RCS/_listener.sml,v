head	1.112;
access;
symbols
	MLW_daveb_inline_1_4_99:1.111.1
	MLWorks_21c0_1999_03_25:1.111
	MLWorks_20c1_1998_08_20:1.111
	MLWorks_20c0_1998_08_04:1.111
	MLWorks_20b2c2_1998_06_19:1.111
	MLWorks_20b2_Windows_1998_06_12:1.111
	MLWorks_20b1c1_1998_05_07:1.110
	MLWorks_20b0_1998_04_07:1.110
	MLWorks_20b0_1998_03_20:1.107
	MLWorks_20m2_1998_02_16:1.104
	MLWorks_20m1_1997_10_23:1.102
	MLWorks_11r1:1.89.1.2.1.2.1
	MLWorks_workspace_97:1.99.2
	MLWorks_dt_wizard:1.99.1
	MLWorks_11c0_1997_09_09:1.89.1.2.1.2
	MLWorks_10r3:1.89.1.2.3
	MLWorks_10r2_551:1.89.1.2.2
	MLWorks_11:1.89.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.89.1.2
	MLWorks_20m0_1997_06_20:1.97
	MLWorks_1_0_r2c2_1997_06_14:1.89.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.89.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.89.1
	MLWorks_BugFix_1997_04_24:1.90
	MLWorks_1_0_r2_Win32_1997_04_11:1.89
	MLWorks_1_0_r2_Unix_1997_04_04:1.89
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.84.3.1.1
	MLWorks_gui_1996_12_18:1.84.4
	MLWorks_1_0_Win32_1996_12_17:1.84.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.83.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.83.1.1
	JFHgui:1.84.2
	MLWorks_1_0_Irix_1996_11_28:1.83.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.84.1
	MLWorks_1_0_Unix_1996_11_14:1.83.1
	MLWorks_Open_Beta2_1996_10_11:1.78.3
	MLWorks_License_dev:1.78.2
	MLWorks_1_open_beta_1996_09_13:1.78.1
	MLWorks_Open_Beta_1996_08_22:1.78
	MLWorks_Beta_1996_07_02:1.71
	MLWorks_Beta_1996_06_07:1.66
	MLWorks_Beta_1996_06_06:1.66
	MLWorks_Beta_1996_06_05:1.66
	MLWorks_Beta_1996_06_03:1.66
	MLWorks_Beta_1996_05_31:1.65
	MLWorks_Beta_1996_05_30:1.64;
locks; strict;
comment	@ * @;


1.112
date	99.05.12.11.11.23;	author daveb;	state Exp;
branches;
next	1.111;

1.111
date	98.06.01.14.22.24;	author johnh;	state Exp;
branches
	1.111.1.1;
next	1.110;

1.110
date	98.03.31.15.31.34;	author johnh;	state Exp;
branches;
next	1.109;

1.109
date	98.03.26.15.51.38;	author jont;	state Exp;
branches;
next	1.108;

1.108
date	98.03.26.12.05.56;	author johnh;	state Exp;
branches;
next	1.107;

1.107
date	98.02.19.20.15.53;	author mitchell;	state Exp;
branches;
next	1.106;

1.106
date	98.02.18.17.02.17;	author jont;	state Exp;
branches;
next	1.105;

1.105
date	98.02.13.15.56.48;	author johnh;	state Exp;
branches;
next	1.104;

1.104
date	98.01.27.14.06.16;	author johnh;	state Exp;
branches;
next	1.103;

1.103
date	97.11.09.09.27.53;	author jont;	state Exp;
branches;
next	1.102;

1.102
date	97.10.16.11.23.46;	author johnh;	state Exp;
branches;
next	1.101;

1.101
date	97.10.09.14.46.05;	author johnh;	state Exp;
branches;
next	1.100;

1.100
date	97.10.06.10.59.02;	author johnh;	state Exp;
branches;
next	1.99;

1.99
date	97.07.23.14.21.03;	author johnh;	state Exp;
branches
	1.99.1.1
	1.99.2.1;
next	1.98;

1.98
date	97.06.18.08.39.40;	author johnh;	state Exp;
branches;
next	1.97;

1.97
date	97.06.17.16.18.28;	author johnh;	state Exp;
branches;
next	1.96;

1.96
date	97.06.17.14.59.43;	author johnh;	state Exp;
branches;
next	1.95;

1.95
date	97.06.12.15.04.02;	author johnh;	state Exp;
branches;
next	1.94;

1.94
date	97.06.10.14.30.54;	author johnh;	state Exp;
branches;
next	1.93;

1.93
date	97.06.09.15.59.42;	author johnh;	state Exp;
branches;
next	1.92;

1.92
date	97.05.21.15.26.59;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	97.05.16.15.49.17;	author johnh;	state Exp;
branches;
next	1.90;

1.90
date	97.04.15.09.24.54;	author jont;	state Exp;
branches;
next	1.89;

1.89
date	97.03.21.14.40.05;	author matthew;	state Exp;
branches
	1.89.1.1;
next	1.88;

1.88
date	97.03.21.11.33.56;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	97.03.20.14.41.57;	author johnh;	state Exp;
branches;
next	1.86;

1.86
date	97.03.17.14.34.27;	author andreww;	state Exp;
branches;
next	1.85;

1.85
date	97.03.12.15.25.56;	author andreww;	state Exp;
branches;
next	1.84;

1.84
date	96.11.21.15.00.14;	author jont;	state Exp;
branches
	1.84.1.1
	1.84.2.1
	1.84.3.1
	1.84.4.1;
next	1.83;

1.83
date	96.11.06.11.16.15;	author matthew;	state Exp;
branches
	1.83.1.1;
next	1.82;

1.82
date	96.11.01.15.09.49;	author johnh;	state Exp;
branches;
next	1.81;

1.81
date	96.10.31.10.17.50;	author johnh;	state Exp;
branches;
next	1.80;

1.80
date	96.10.22.12.26.03;	author io;	state Exp;
branches;
next	1.79;

1.79
date	96.10.21.15.22.30;	author jont;	state Exp;
branches;
next	1.78;

1.78
date	96.08.07.12.25.23;	author daveb;	state Exp;
branches
	1.78.1.1
	1.78.2.1
	1.78.3.1;
next	1.77;

1.77
date	96.08.06.16.32.39;	author daveb;	state Exp;
branches;
next	1.76;

1.76
date	96.07.30.13.32.49;	author daveb;	state Exp;
branches;
next	1.75;

1.75
date	96.07.30.09.05.37;	author daveb;	state Exp;
branches;
next	1.74;

1.74
date	96.07.29.09.40.02;	author daveb;	state Exp;
branches;
next	1.73;

1.73
date	96.07.15.13.33.32;	author andreww;	state Exp;
branches;
next	1.72;

1.72
date	96.07.03.13.17.44;	author andreww;	state Exp;
branches;
next	1.71;

1.71
date	96.06.25.09.53.52;	author daveb;	state Exp;
branches;
next	1.70;

1.70
date	96.06.21.11.06.19;	author stephenb;	state Exp;
branches;
next	1.69;

1.69
date	96.06.19.14.35.55;	author daveb;	state Exp;
branches;
next	1.68;

1.68
date	96.06.18.16.03.42;	author daveb;	state Exp;
branches;
next	1.67;

1.67
date	96.06.17.16.36.27;	author nickb;	state Exp;
branches;
next	1.66;

1.66
date	96.05.31.16.11.22;	author daveb;	state Exp;
branches;
next	1.65;

1.65
date	96.05.30.14.28.41;	author daveb;	state Exp;
branches;
next	1.64;

1.64
date	96.05.29.16.48.57;	author daveb;	state Exp;
branches;
next	1.63;

1.63
date	96.05.29.16.06.34;	author daveb;	state Exp;
branches;
next	1.62;

1.62
date	96.05.24.15.48.34;	author daveb;	state Exp;
branches;
next	1.61;

1.61
date	96.05.24.15.33.16;	author daveb;	state Exp;
branches;
next	1.60;

1.60
date	96.05.24.13.35.36;	author daveb;	state Exp;
branches;
next	1.59;

1.59
date	96.05.24.11.09.08;	author daveb;	state Exp;
branches;
next	1.58;

1.58
date	96.05.24.10.44.39;	author daveb;	state Exp;
branches;
next	1.57;

1.57
date	96.05.22.16.00.42;	author daveb;	state Exp;
branches;
next	1.56;

1.56
date	96.05.15.11.43.24;	author daveb;	state Exp;
branches;
next	1.55;

1.55
date	96.05.14.16.15.25;	author daveb;	state Exp;
branches;
next	1.54;

1.54
date	96.05.14.13.43.46;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	96.05.10.14.46.58;	author daveb;	state Exp;
branches;
next	1.52;

1.52
date	96.05.09.15.42.41;	author daveb;	state Exp;
branches;
next	1.51;

1.51
date	96.05.09.13.30.16;	author daveb;	state Exp;
branches;
next	1.50;

1.50
date	96.05.08.14.33.35;	author daveb;	state Exp;
branches;
next	1.49;

1.49
date	96.05.01.11.15.54;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	96.04.30.10.07.41;	author matthew;	state Exp;
branches;
next	1.47;

1.47
date	96.03.15.12.36.22;	author daveb;	state Exp;
branches;
next	1.46;

1.46
date	96.03.14.12.21.06;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	96.02.23.11.43.31;	author daveb;	state Exp;
branches;
next	1.44;

1.44
date	96.02.23.11.26.27;	author daveb;	state Exp;
branches;
next	1.43;

1.43
date	96.02.22.17.28.41;	author daveb;	state Exp;
branches;
next	1.42;

1.42
date	96.02.19.13.52.13;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	96.02.08.11.31.49;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	96.01.25.17.26.56;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	96.01.25.14.45.29;	author daveb;	state Exp;
branches;
next	1.38;

1.38
date	96.01.25.12.31.30;	author daveb;	state Exp;
branches;
next	1.37;

1.37
date	96.01.23.16.25.34;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	96.01.23.15.24.52;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	96.01.22.14.40.11;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	96.01.22.13.55.32;	author daveb;	state Exp;
branches;
next	1.33;

1.33
date	96.01.22.10.18.37;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.19.15.08.26;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	96.01.18.17.01.37;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.01.18.15.58.18;	author daveb;	state Exp;
branches;
next	1.29;

1.29
date	96.01.18.14.23.23;	author daveb;	state Exp;
branches;
next	1.28;

1.28
date	96.01.18.10.40.18;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	96.01.17.14.43.31;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	96.01.17.12.14.28;	author daveb;	state Exp;
branches;
next	1.25;

1.25
date	96.01.16.15.43.24;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	96.01.16.13.29.35;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	96.01.12.16.30.35;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	96.01.09.14.03.41;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	96.01.09.12.03.00;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	96.01.09.11.32.58;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.12.07.14.34.19;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.11.22.12.30.13;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	95.11.17.11.24.01;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	95.11.15.16.59.43;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.11.13.17.10.51;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.10.26.15.11.20;	author daveb;	state Exp;
branches;
next	1.13;

1.13
date	95.10.25.12.27.53;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.10.20.11.20.45;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	95.10.18.13.48.05;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	95.10.09.11.43.33;	author daveb;	state Exp;
branches;
next	1.9;

1.9
date	95.10.05.12.50.03;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.09.11.15.01.26;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.09.08.15.28.32;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.30.13.23.43;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.25.13.27.26;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.25.11.22.14;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.08.10.12.16.16;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.57.59;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.35.20;	author matthew;	state Exp;
branches;
next	;

1.78.1.1
date	96.09.13.11.13.25;	author hope;	state Exp;
branches;
next	;

1.78.2.1
date	96.10.07.16.04.07;	author hope;	state Exp;
branches;
next	;

1.78.3.1
date	96.10.17.11.22.20;	author hope;	state Exp;
branches;
next	;

1.83.1.1
date	96.11.14.12.46.23;	author hope;	state Exp;
branches
	1.83.1.1.1.1;
next	;

1.83.1.1.1.1
date	96.11.28.14.58.05;	author hope;	state Exp;
branches;
next	;

1.84.1.1
date	96.11.22.18.06.42;	author hope;	state Exp;
branches;
next	;

1.84.2.1
date	96.12.17.09.54.46;	author hope;	state Exp;
branches;
next	;

1.84.3.1
date	96.12.17.17.45.23;	author hope;	state Exp;
branches
	1.84.3.1.1.1;
next	;

1.84.3.1.1.1
date	97.02.24.11.34.52;	author hope;	state Exp;
branches;
next	;

1.84.4.1
date	96.12.18.09.39.23;	author hope;	state Exp;
branches;
next	;

1.89.1.1
date	97.05.12.10.31.43;	author hope;	state Exp;
branches;
next	1.89.1.2;

1.89.1.2
date	97.05.21.16.36.13;	author daveb;	state Exp;
branches
	1.89.1.2.1.1
	1.89.1.2.2.1
	1.89.1.2.3.1;
next	;

1.89.1.2.1.1
date	97.07.28.18.17.36;	author daveb;	state Exp;
branches;
next	1.89.1.2.1.2;

1.89.1.2.1.2
date	97.08.05.11.19.21;	author johnh;	state Exp;
branches
	1.89.1.2.1.2.1.1;
next	;

1.89.1.2.1.2.1.1
date	97.10.07.11.42.28;	author jkbrook;	state Exp;
branches;
next	;

1.89.1.2.2.1
date	97.09.08.17.11.07;	author daveb;	state Exp;
branches;
next	;

1.89.1.2.3.1
date	97.09.09.14.06.43;	author daveb;	state Exp;
branches;
next	;

1.99.1.1
date	97.09.10.19.21.17;	author brucem;	state Exp;
branches;
next	;

1.99.2.1
date	97.09.11.20.52.29;	author daveb;	state Exp;
branches;
next	1.99.2.2;

1.99.2.2
date	97.11.12.15.21.26;	author johnh;	state Exp;
branches;
next	1.99.2.3;

1.99.2.3
date	97.11.20.17.09.32;	author johnh;	state Exp;
branches;
next	1.99.2.4;

1.99.2.4
date	97.11.26.13.13.35;	author daveb;	state Exp;
branches;
next	1.99.2.5;

1.99.2.5
date	97.12.02.11.48.12;	author johnh;	state Exp;
branches;
next	;

1.111.1.1
date	99.04.01.17.55.41;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.112
log
@[Bug #190554]
Type of Timer.checkCPUTimer has changed.
@
text
@(* Listener using Capi interface *)
(*
 *
 *  $Log: _listener.sml,v $
 * Revision 1.111  1998/06/01  14:22:24  johnh
 * [Bug #30369]
 * Change type of Capi.open_file_dialog.
 *
 * Revision 1.110  1998/03/31  15:31:34  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos().
 *
 * Revision 1.109  1998/03/26  15:51:38  jont
 * [Bug #30090]
 * Remove uses of MLWorks.IO
 *
 * Revision 1.108  1998/03/26  12:05:56  johnh
 * [Bug #50035]
 * Allow keyboard accelerators to be platform specific.
 *
 * Revision 1.107  1998/02/19  20:15:53  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.106  1998/02/18  17:02:17  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.105  1998/02/13  15:56:48  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.104  1998/01/27  14:06:16  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.103  1997/11/09  09:27:53  jont
 * [Bug #30089]
 * Remove use of MLWorks.Time.Elapsed in favour of basis timer
 *
 * Revision 1.102  1997/10/16  11:23:46  johnh
 * [Bug #30284]
 * Call SaveImage.add_with_fn to add a wrapper function which resets the reference
 * storing the listener_tool widget for the duration of the image save call.
 *
 * Revision 1.101  1997/10/09  14:46:05  johnh
 * [Bug #30193]
 * Reogranise the System Messages implementation.
 *
 * Revision 1.100  1997/10/06  10:59:02  johnh
 * [Bug #30137]
 * Create system messages window.
 *
 * Revision 1.99.2.5  1997/12/02  11:48:12  johnh
 * [Bug #30071]
 * Remove old commands from the File menu.
 *
 * Revision 1.99.2.4  1997/11/26  13:13:35  daveb
 * [Bug #30071]
 * The Shell.Error exception is no longer needed.
 *
 * Revision 1.99.2.3  1997/11/20  17:09:32  johnh
 * [Bug #30071]
 * Generalise open_file_dialog to take any masks.
 *
 * Revision 1.99.2.1  1997/09/11  20:52:29  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.99  1997/07/23  14:21:03  johnh
 * [Bug #30182]
 * Add delete handler.
 *
 * Revision 1.98  1997/06/18  08:39:40  johnh
 * [Bug #30181]
 * Tidy interrupt button code.
 *
 * Revision 1.96  1997/06/17  14:59:43  johnh
 * [Bug #30174]
 * Replace podium with Listener on Motif and create Listener on startup for Windows.
 *
 * Revision 1.95  1997/06/12  15:04:02  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.94  1997/06/10  14:30:54  johnh
 * [Bug #30075]
 * Allowing only one instance of tools.
 *
 * Revision 1.93  1997/06/09  15:59:42  johnh
 * [Bug #02030]
 * Fixing Usage->EditError functionality and remove the menu item for now.
 *
 * Revision 1.92  1997/05/21  15:26:59  matthew
 * [Bug #20057]
 * Add sofar string to key_function function in completion menu
 *
 * Revision 1.91  1997/05/16  15:49:17  johnh
 * Implementing single menu bar on Windows.
 *
 * Revision 1.90  1997/04/15  09:24:54  jont
 * [Bug #2049]
 * Make sure file location is used in error browser title where appropriate
 *
 * Revision 1.89  1997/03/21  14:40:05  matthew
 * Adding missing call to buttons_update_fun after setting evaluating.
 *
 * Revision 1.88  1997/03/21  11:33:56  matthew
 * Adding handler for Shell.Error
 *
 * Revision 1.87  1997/03/20  14:41:57  johnh
 * [Bug #1986]
 * Replacing completions rather than inserting to avoid raising
 * subscript exceptions on Motif and handle completions correctly
 * on Win32.
 *
 * Revision 1.86  1997/03/17  14:34:27  andreww
 * [Bug #1977]
 * Multi-line editing on Listener no longer works!
 *
 * Revision 1.85  1997/03/12  15:25:56  andreww
 * [Bug #1667]
 * adding mutual exclusion primitives for the listener.
 *
 * Revision 1.84  1996/11/21  15:00:14  jont
 * [Bug #1799]
 * Make more calls to Capi.Text.check_insertion
 * Use truncated string from check_insertion where necessary
 *
 * Revision 1.83  1996/11/06  11:16:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.82  1996/11/01  15:09:49  johnh
 * Enabling close from control box on top left of window.
 *
 * Revision 1.81  1996/10/31  10:17:50  johnh
 * Add interrupt button on Windows.
 *
 * Revision 1.80  1996/10/22  12:26:03  io
 * [Bug #1614]
 * remove use of Substring
 *
 * Revision 1.79  1996/10/21  15:22:30  jont
 * Remove references to basis.toplevel
 *
 * Revision 1.78  1996/08/07  12:25:23  daveb
 * [Bug #1517]
 * Bound abandon to Ctrl-G.
 *
 * Revision 1.77  1996/08/06  16:32:39  daveb
 * [Bug #1517]
 * Added functions for moving forward or backward by a character or line.
 *
 * Revision 1.76  1996/07/30  13:32:49  daveb
 * [Bug #1507]
 * Replaced existing handlers for Shell.Exit with a single one in do_evaluate.
 *
 * Revision 1.75  1996/07/30  09:05:37  daveb
 * [Bug #1299]
 * Preserved remaining source after a runtime error.
 *
 * Revision 1.74  1996/07/29  09:40:02  daveb
 * [Bug #1478]
 * Disabled Close menu item during evaluations.
 *
 * Revision 1.73  1996/07/15  13:33:32  andreww
 * propagating changes made to the GUI standard IO redirection mechanism
 * (see __pervasive_library.sml for the StandardIO structure)
 *
 * Revision 1.72  1996/07/03  13:17:44  andreww
 * Redirecting standard IO through GuiStandardIO in pervasive library.
 *
 * Revision 1.71  1996/06/25  09:53:52  daveb
 * Made button buttons have different names from menu buttons, so that
 * Windows can distinguish between them, and so let us put mnemonics on
 * the menu items but not the buttons.
 *
 * Revision 1.70  1996/06/21  11:06:19  stephenb
 * Fix #1429 - change the Load Objects dialog to use .mo instead of .sml
 *
 * Revision 1.69  1996/06/19  14:35:55  daveb
 * Bug 1356: Made file_action call MLWorks.String.ml_string, so that backslashes
 * are correctly escaped.
 *
 * Revision 1.68  1996/06/18  16:03:42  daveb
 * Added Step button.
 *
 * Revision 1.67  1996/06/17  16:36:27  nickb
 * Add profiler button and rearrange buttons.
 *
 * Revision 1.66  1996/05/31  16:11:22  daveb
 * Bug 1074: Capi.list_select now takes a function to be called on any key
 * press handled by the list widget itself.  In the listener, this pops the
 * completions widget down as if the key had been typed at the listener.
 *
 * Revision 1.65  1996/05/30  14:28:41  daveb
 * The Interrupt exception is no longer at top level.
 *
 * Revision 1.64  1996/05/29  16:48:57  daveb
 * Fixed bug with clear_all.  The prompt_pos needs to be set before the
 * contents of the text widget, or else the modification is disallowed by
 * the modication_ok function.
 *
 * Revision 1.63  1996/05/29  16:06:34  daveb
 * DebuggerWindow.make_debugger_window now returns a clean-up function to call
 * at the end of each evaluation.
 *
 * Revision 1.62  1996/05/24  15:48:34  daveb
 * The extension passed to open_file_dialog does not need a preceding * .
 *
 * Revision 1.61  1996/05/24  15:33:16  daveb
 * Removed Path menu.
 *
 * Revision 1.60  1996/05/24  13:35:36  daveb
 * Type of GuiUtils.view_option has changed.
 *
 * Revision 1.59  1996/05/24  11:09:08  daveb
 * Added "Abandon" command.
 *
 * Revision 1.58  1996/05/24  10:44:39  daveb
 * Moved Find to the Edit menu.
 *
 * Revision 1.57  1996/05/22  16:00:42  daveb
 * Added Preferences and Paths menus.
 *
 * Revision 1.56  1996/05/15  11:43:24  daveb
 * Improved behaviour of error browser when the evaluation has written some
 * output to the text widget.
 *
 * Revision 1.55  1996/05/14  16:15:25  daveb
 * Added File menu.
 *
 * Revision 1.54  1996/05/14  13:43:46  matthew
 * Handle Shell.Exit in error browser redo function
 *
 * Revision 1.53  1996/05/10  14:46:58  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
 * Revision 1.52  1996/05/09  15:42:41  daveb
 * Made copying of lines detect our current prompt better.
 *
 * Revision 1.51  1996/05/09  13:30:16  daveb
 * Evaluation of lines copied from before the prompt was broken: the copied
 * line is now appended to any existing input.
 * The buttons are disabled while the listener is reading from std_in.
 *
 * Revision 1.50  1996/05/08  14:33:35  daveb
 * The error browser now returns a quit function.  Use this to make the
 * evaluate command kill any existing error browser.
 *
 * Revision 1.49  1996/05/01  11:15:54  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.48  1996/04/30  10:07:41  matthew
 * Replacing MLWorks.Integer with basis file
 *
 * Revision 1.47  1996/03/15  12:36:22  daveb
 * Fixed use of Info.default_options.
 *
 * Revision 1.46  1996/03/14  12:21:06  matthew
 * Adjust prompt_pos on clearing input.
 *
 * Revision 1.45  1996/02/23  11:43:31  daveb
 * Added Clear All button.
 *
 * Revision 1.44  1996/02/23  11:26:27  daveb
 * Ensured erroneous input is added to the history if not corrected with the
 * Error Browser interface.
 *
 * Revision 1.43  1996/02/22  17:28:41  daveb
 * ErrorBrowser.create now takes a close_action field.
 *
 * Revision 1.42  1996/02/19  13:52:13  matthew
 * Fiddling with edit menu operations
 *
 * Revision 1.41  1996/02/08  11:31:49  daveb
 * Removed sensitivity field from argument to view_options.
 *
 * Revision 1.40  1996/01/25  17:26:56  matthew
 * Changing yank behaviour
 *
 * Revision 1.39  1996/01/25  14:45:29  daveb
 * Minor change to error browser interface.
 *
 * Revision 1.38  1996/01/25  12:31:30  daveb
 * Changed behaviour of Return before the end of buffer.
 *
 * Revision 1.37  1996/01/23  16:25:34  daveb
 * Corrected behaviour of clear.
 *
 * Revision 1.36  1996/01/23  15:24:52  daveb
 * Minor reorganisation of menus.
 *
 * Revision 1.35  1996/01/22  14:40:11  daveb
 * Now handles exceptions and trivial lines.
 *
 * Revision 1.34  1996/01/22  13:55:32  daveb
 * Added get_input_from_stdin function, since get_input_to_evaluate now
 * reads input from prompt_pos instead of write_pos.
 *
 * Revision 1.33  1996/01/22  10:18:37  daveb
 * Added buttons.  This involved adding the time-handler functionality, and
 * moving the history mechanism to gui_utils.  The latter change was needed
 * because the add_history function needs to know about indices (it was in
 * shell_utils, but gui_utils is more appropriate).
 *
 * Revision 1.32  1996/01/19  15:08:26  matthew
 * Changing inspector interface.
 *
 * Revision 1.31  1996/01/18  17:01:37  daveb
 * Added key binding for ^O to insert newline.  Removed yank_current_line
 * because it was never used.
 *
 * Revision 1.30  1996/01/18  15:58:18  daveb
 * The previous change caused crashes with empty lines.  Fixed it.
 *
 * Revision 1.29  1996/01/18  14:23:23  daveb
 * Added support for error browsing.
 *
 * Revision 1.28  1996/01/18  10:40:18  matthew
 * Reordering top level menus.
 *
 * Revision 1.27  1996/01/17  14:43:31  daveb
 * Added newline to end of input - otherwise a null line is treated as an EOF!
 *
 * Revision 1.26  1996/01/17  12:14:28  daveb
 * Now parses everything since the main prompt, so allowing multi-line editing.
 * Uses the revised shell interface (see interpreter/shell).
 *
 * Revision 1.25  1996/01/16  15:43:24  matthew
 * Changing uses of full_menus
 *
 * Revision 1.24  1996/01/16  13:29:35  matthew
 * Fixing problem with previous change for Windows.
 *
 * Revision 1.23  1996/01/12  16:30:35  matthew
 * Adding insertion checks for the benefit of Windows
 *
 * Revision 1.22  1996/01/09  14:03:41  matthew
 * Moved list_select to capi
 *
 * Revision 1.21  1996/01/09  12:03:00  matthew
 * Fixing problem with typing return before prompt.  This doesn't actually
 * insert anything, so should be allowed.
 *
 * Revision 1.20  1996/01/09  11:32:58  matthew
 * Adding checks on modifications before prompt.
 *
 * Revision 1.19  1995/12/07  14:34:19  matthew
 * Changing interface to edit_menu
 *
 * Revision 1.18  1995/11/22  12:30:13  matthew
 * Adding call to transfer_focus
 *
 * Revision 1.17  1995/11/17  11:24:01  matthew
 * Trying to fix completion for windows.
 *
 * Revision 1.16  1995/11/15  16:59:43  matthew
 * Adding window menu
 *
 * Revision 1.15  1995/11/13  17:10:51  matthew
 * Simplifying capi interface.
 *
 * Revision 1.14  1995/10/26  15:11:20  daveb
 * Now creates a new list widget each time that completion is asked for, so that
 * it pops up with the correct size under TWM.
 *
 * Revision 1.13  1995/10/25  12:27:53  nickb
 * Make profile tool a child of the application shell.
 *
 * Revision 1.12  1995/10/20  11:20:45  daveb
 * Renamed ShellUtils.edit_string to ShellUtils.edit_source
 * (and ShellUtils.edit_source to ShellUtils.edit_location).
 *
 * Revision 1.11  1995/10/18  13:48:05  nickb
 * Add profiler to the shelldata made here.
 *
 * Revision 1.10  1995/10/09  11:43:33  daveb
 * The search_opt field of the context menu now takes a boolean component which
 * controls whether users are given the option of which contexts to search.
 * In input tools this should be true, in the context browser it should be false.
 *
 * Revision 1.9  1995/10/05  12:50:03  daveb
 * Moved breakpoints_menu to podium.
 * Combined search menu with (slimline) context menu.
 *
 * Revision 1.8  1995/09/11  15:01:26  matthew
 * Changing top level window initialization
 *
 * Revision 1.7  1995/09/08  15:28:32  matthew
 * Adding flush_stream function to Shell.shell
 *
 * Revision 1.6  1995/08/30  13:23:43  matthew
 * Renaming layout constructors
 *
 * Revision 1.5  1995/08/25  13:27:26  matthew
 * Removing some diagnostic
 *
 * Revision 1.4  1995/08/25  11:22:14  matthew
 * Abstracting text functionality
 *
 * Revision 1.3  1995/08/10  12:16:16  matthew
 * Adding make_buttons function to capi
 *
 * Revision 1.2  1995/07/27  10:57:59  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.1  1995/07/26  14:35:20  matthew
 * new unit
 * New unit
 *
 *  Revision 1.103  1995/07/19  13:10:03  matthew
 *  Adding "external listener" features
 *
 *  Revision 1.102  1995/07/17  11:48:21  matthew
 *  Abstraction of text functionality
 *
 *  Revision 1.101  1995/07/14  17:24:01  io
 *  add searching capability
 *
 *  Revision 1.100  1995/07/07  15:31:47  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.99  1995/07/04  17:17:16  daveb
 *  Replaced ad-hoc handling of CTRL-D (which has stopped working)
 *  with an explicit function.
 *
 *  Revision 1.98  1995/07/04  10:41:19  matthew
 *  Stuff
 *
 *  Revision 1.97  1995/06/15  13:01:10  daveb
 *  Hid details of WINDOWING type in ml_debugger.
 *
 *  Revision 1.96  1995/06/14  13:22:54  daveb
 *  Type of Ml_Debugger.ml_debugger has changed.
 *
 *  Revision 1.95  1995/06/08  14:44:40  daveb
 *  Removed expansion of tabs.
 *
 *  Revision 1.94  1995/06/05  13:23:44  daveb
 *  Changed sensitivity argument of view_options to NO_SENSE_SELECTION,
 *  because the shell functions now set the current selection.
 *
 *  Revision 1.93  1995/06/01  10:32:23  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.92  1995/05/23  14:15:44  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.91  1995/05/23  09:26:52  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.90  1995/05/16  09:52:33  matthew
 *  Adding escape key functionality
 *
 *  Revision 1.89  1995/05/04  09:41:00  matthew
 *  Removed script from ml_debugger
 *
 *  Revision 1.88  1995/04/28  15:03:04  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.87  1995/04/19  10:57:52  daveb
 *  Changes to context_menu.
 *
 *  Revision 1.86  1995/04/13  17:45:13  daveb
 *  Xm.doInput is back to taking unit.
 *
 *  Revision 1.85  1995/04/06  15:37:17  daveb
 *  Type of Xm.doInput has changed.
 *
 *  Revision 1.84  1995/03/17  12:29:42  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *
 *  Revision 1.83  1995/03/16  11:50:43  daveb
 *  Removed context_function from register when closing the window.
 *
 *  Revision 1.82  1995/03/15  17:42:01  daveb
 *  Changed to share current context with other tools..
 *
 *  Revision 1.81  1995/03/10  15:34:41  daveb
 *  MotifUtils.options_menu takes an extra argument.
 *
 *  Revision 1.80  1995/01/13  15:48:40  daveb
 *  Removed obsolete sharing constraint.
 *
 *  Revision 1.79  1994/09/21  16:37:13  brianm
 *  Adding value menu ...
 *
 *  Revision 1.78  1994/08/01  10:50:40  daveb
 *  Moved preferences to separate structure.
 *
 *  Revision 1.77  1994/07/27  14:05:13  daveb
 *  Cut-down menus for novices.
 *
 *  Revision 1.76  1994/07/12  15:51:20  daveb
 *  ToolData.works_menu takes different arguments.
 *
 *  Revision 1.75  1994/06/23  10:06:01  matthew
 *  Changed behaviour of Ctrl-E to go to end of input.
 *
 *  Revision 1.74  1994/06/20  17:13:57  daveb
 *  Changed context refs to user_contexts.  Filter out constant user_contexts
 *  from the selection menu.
 *
 *  Revision 1.72  1994/04/06  12:53:03  daveb
 *  Added breakpoints menu.
 *
 *  Revision 1.71  1994/03/15  11:29:14  matthew
 *  Changed Exit exn to Shell.Exit
 *  Cleaned up history mechanism so erroneous input is also recorded
 *
 *  Revision 1.70  1994/03/11  15:35:13  matthew
 *  Fixing bug with calling debugger
 *
 *  Revision 1.69  1994/02/17  15:07:38  matthew
 *  Fixed C-d
 *
 *  Revision 1.68  1994/02/02  11:57:21  daveb
 *  ActionQueue no longer has Incremental as a substructure.
 *
 *  Revision 1.67  1994/01/28  18:06:34  matthew
 *  Fixing locations in errors
 *
 *  Revision 1.66  1994/01/28  10:35:19  matthew
 *  Added support for C-a going to just after the prompt
 *
 *  Revision 1.65  1993/12/22  10:52:25  daveb
 *  Changed quit message for debugger, since it no longer raises Interrupt.
 *
 *  Revision 1.64  1993/12/01  16:37:28  matthew
 *  Added with_input_disabled to prevent commands being processed while in the debugger.
 *  A better solution should be possible.
 *
 *  Revision 1.63  1993/11/26  12:25:24  matthew
 *  Improvements to calling debugger.
 *
 *  Revision 1.62  1993/11/22  17:49:31  daveb
 *  Ml_Debugger.with_start_frame no longer needs a frame argument, removing
 *  the need for the call to MLWorks.Internal.Value.frame_call.
 *
 *  Revision 1.61  1993/11/18  12:19:09  nickh
 *  Change to instream arguments.
 *
 *  Revision 1.60  1993/10/22  17:02:58  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.59  1993/10/08  16:39:22  matthew
 *  Merging in bug fixes
 *
 *  Revision 1.58  1993/09/13  09:16:08  daveb
 *  Merged in bug fix.
 *
 *  Revision 1.57.1.4  1993/10/22  15:19:33  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  Changed modify_verify to check for EOF, and changed input functions
 *  to deal with EOF.
 *
 *  Revision 1.57.1.3  1993/10/08  15:07:33  matthew
 *  Added destroy Callback to eg. quit from editor windows
 *  Uses history menu utilities
 *
 *  Revision 1.57.1.2  1993/09/10  11:14:01  daveb
 *  Added name parameter to MotifUtils.list_select.
 *
 *  Revision 1.57.1.1  1993/08/31  15:26:36  jont
 *  Fork for bug fixing
 *
 *  Revision 1.57  1993/08/31  15:26:36  matthew
 *  Force a new prompt when changing contexts.
 *
 *  Revision 1.56  1993/08/25  15:03:54  matthew
 *  Return quit function from ShellUtils.edit_string
 *
 *  Revision 1.55  1993/08/24  16:40:39  matthew
 *  >Improved editing error handling
 *
 *  Revision 1.54  1993/08/11  11:25:37  matthew
 *  Changes to user options
 *  Removed preferences menu
 *  Options update
 *
 *  Revision 1.53  1993/08/10  15:20:42  nosa
 *  tooldata passed to make_debugger_window for inspector invocation
 *  in debugger-window.
 *
 *  Revision 1.52  1993/08/10  12:22:27  matthew
 *  Get maximum history length from options
 *  Beep when no completion found
 *  Longest common prefix completion
 *  Pass stream name to Shell.shell
 *
 *  Revision 1.51  1993/08/03  11:59:41  matthew
 *  Added error editing operation
 *
 *  Revision 1.50  1993/06/02  13:07:17  daveb
 *  Removed value menu for the time being, since there's nothing on it.
 *
 *  Revision 1.49  1993/05/28  16:15:37  matthew
 *  Added tty_ok value to WINDOWING
 *
 *  Revision 1.48  1993/05/28  10:10:04  matthew
 *  Added completion
 *  Changed getline function
 *
 *  Revision 1.47  1993/05/21  16:34:44  matthew
 *  Added some very preliminary stuff for completion.
 *
 *  Revision 1.46  1993/05/18  17:29:35  jont
 *  Removed integer parameter
 *
 *  Revision 1.45  1993/05/13  14:20:58  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *
 *  Revision 1.44  1993/05/11  13:34:08  daveb
 *  History no longer allows duplicate entries, nor very short entries,
 *  and is limited in length.
 *
 *  Revision 1.43  1993/05/11  12:46:14  daveb
 *  Added code to check state of meta keys.
 *
 *  Revision 1.42  1993/05/11  12:10:30  daveb
 *  Replaced creation of outstream with MotifUtils.make_outstream.
 *  Revised handling of contexts.
 *
 *  Revision 1.41  1993/05/10  16:07:42  daveb
 *  Changed type of ml_debugger.
 *
 *  Revision 1.40  1993/05/10  14:29:28  daveb
 *   Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *
 *  Revision 1.39  1993/05/10  11:49:39  matthew
 *  Added interrupt handler around debugger
 *  Added Ctrl-U handler and delete_current_line
 *
 *  Revision 1.38  1993/05/07  17:22:42  matthew
 *  Debugger changes
 *
 *  Revision 1.37  1993/05/06  15:11:20  matthew
 *  Simplified state_stack (now context_stack)
 *  ShellTypes revision
 *
 *  Revision 1.36  1993/05/06  11:21:52  daveb
 *  Removed inspector from values menu (It's now in the works menu).
 *  Removed old debugger code.
 *
 *  Revision 1.35  1993/05/05  12:11:04  daveb
 *  Added tools argument to works_menu(),
 *  removed exitApplication from TOOLDATA (works_menu now accesses it directly).
 *
 *  Revision 1.34  1993/05/04  16:24:34  matthew
 *  Added context selection
 *  Changed context ref handling
 *
 *  Revision 1.33  1993/05/04  12:27:20  matthew
 *  Added quit to windowing debugger.
 *  ,
 *
 *  Revision 1.32  1993/04/30  14:44:35  daveb
 *  Reorganised menus.
 *
 *  Revision 1.31  1993/04/27  15:12:43  daveb
 *  Moved options menu code to _GUI_UTILS.
 *
 *  Revision 1.30  1993/04/26  12:40:10  matthew
 *  Indentation change & removed old tracing code
 *  Removed ML_Debugger.BASE_FRAME
 *
 *  Revision 1.29  1993/04/23  15:15:05  matthew
 *  Use Xm.Text.Replace function for replacing topdecs
 *  ModifyVerify takes note of modifications before the prompt
 *  Added yank current line
 *  Changed key bindings
 *
 *  Revision 1.28  1993/04/22  13:10:16  richard
 *  The editor interface is now implemented directly through
 *  Unix system calls, and is not part of the pervasive library
 *  or the runtime system.
 *
 *  Revision 1.27  1993/04/21  14:49:46  daveb
 *  Added browse context menu item.
 *
 *  Revision 1.26  1993/04/21  13:46:57  richard
 *  Commented out old tracing stuff..
 *
 *  Revision 1.25  1993/04/20  16:10:57  matthew
 *  Added debug function do_debug control variable
 *  Removed call to strip_prompt from getline
 *  Rewrite of do_return to handle input properly
 *
 *  Revision 1.24  1993/04/16  17:35:40  daveb
 *  Added history menu.
 *
 *  Revision 1.23  1993/04/16  17:13:49  matthew
 *  *** empty log message ***
 *
 *  Revision 1.22  1993/04/15  16:06:42  matthew
 *  Changed "text" widget name to "textIO";
 *
 *  Revision 1.21  1993/04/14  11:17:11  daveb
 *  Fixed the history mechanism.
 *
 *  Revision 1.20  1993/04/13  09:54:12  matthew
 *  Changed interface to file selection
 *
 *  Revision 1.19  1993/04/08  12:11:31  jont
 *  Added editor options menu and Editor menu
 *
 *  Revision 1.18  1993/04/08  08:36:11  daveb
 *  Fixed input to work with recent changes.  Added working lookahead.
 *  Reinstated change to location of user_options, which I accidentally erased
 *  in the previous revision.
 *
 *  Revision 1.17  1993/04/07  13:40:06  daveb
 *  Added a first stab at a history mechanism.  Buggy.  Lots of support work
 *  needed to get this far, so from here on it's plain sailing
 *
 *  Revision 1.16  1993/04/06  10:10:39  jont
 *  Moved user_options and version from interpreter to main
 *  Added menu stuff for compatibility options
 *
 *  Revision 1.15  1993/04/05  10:55:13  matthew
 *  Changed ordof and MLWorks.String.ordof to MLWorks.String.ordof
 *  Changed interface to inspector tool
 *
 *  Revision 1.14  1993/04/02  15:15:30  matthew
 *  Structure changes
 *  Added File Selection tool
 *
 *  Revision 1.13  1993/03/31  13:52:25  matthew
 *  Added Options menus
 *
 *  Revision 1.12  1993/03/30  11:39:23  matthew
 *  Added state stack and push and pop operations thereon
 *
 *  Revision 1.10  1993/03/24  10:14:03  matthew
 *  Menu modifications
 *  Most of this is test code.
 *
 *  Revision 1.9  1993/03/18  18:08:55  matthew
 *  Added create_new_listener function
 *  Added output_fn field to shell_data
 *
 *  Revision 1.8  1993/03/18  09:56:56  matthew
 *  Add newline when using earlier line
 *
 *  Revision 1.7  1993/03/17  16:18:38  matthew
 *  Used Menus utilities to make menubar menus
 *
 *  Revision 1.6  1993/03/15  17:13:35  matthew
 *  Simplified ShellTypes types
 *
 *  Revision 1.5  1993/03/15  14:34:51  daveb
 *  Fixed problems with prompt and resizing.
 *
 *  Revision 1.4  1993/03/12  11:42:44  matthew
 *  Changed interface to shell.
 *  Haven't tested this
 *
 *  Revision 1.3  1993/03/09  15:57:55  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *
 *  Revision 1.2  1993/03/04  16:40:19  daveb
 *  Replaced mainWindow/text combination with rowColumn/scrolledText.
 *  Scrolling now works properly.
 *
 *  Revision 1.1  1993/03/02  19:18:28  daveb
 *  Initial revision
 *
 *
 *  Copyright (c) 1993 Harlequin Ltd.
 *
 *)

(* Basis *)
require "^.basis.__int";
require "^.basis.__string";
require "^.basis.__timer";
require "^.basis.__text_io";
require "^.system.__time";

(* Utilities *)
require "^.utils.lists";
require "^.utils.crash";
require "^.utils.mutex";
require "^.utils.__terminal";

(* GUI stuff *)
require "capi";
require "menus";
require "gui_utils";
require "tooldata";
require "debugger_window";
require "inspector_tool";
require "profile_tool";
require "error_browser";

(* Environment *)
require "^.main.preferences";
require "^.main.user_options";

(* Compiler *)
require "^.interpreter.shell";
require "^.interpreter.shell_utils";
require "^.interpreter.tty_listener";
require "^.interpreter.save_image";
require "^.debugger.ml_debugger";
require "^.debugger.newtrace";

require "listener";

(* WARNING: Don't use std_out for error tracing when debugging this file.
 Usually you should use MLWorks.IO.terminal_out instead. *)

functor Listener (
  structure Lists: LISTS
  structure Crash : CRASH
  structure Capi: CAPI

  structure Preferences : PREFERENCES
  structure UserOptions : USER_OPTIONS

  structure Shell: SHELL
  structure ShellUtils : SHELL_UTILS
  structure TTYListener : TTY_LISTENER
  structure Ml_Debugger: ML_DEBUGGER
  structure Trace : TRACE
  structure ToolData : TOOL_DATA
  structure GuiUtils : GUI_UTILS
  structure Menus : MENUS
  structure DebuggerWindow : DEBUGGERWINDOW
  structure InspectorTool : INSPECTORTOOL
  structure ProfileTool : PROFILE_TOOL
  structure ErrorBrowser: ERROR_BROWSER
  structure Mutex : MUTEX
  structure SaveImage : SAVE_IMAGE
  
  sharing UserOptions.Options = Ml_Debugger.ValuePrinter.Options =
          ShellUtils.Options = ToolData.ShellTypes.Options
  sharing Shell.Info = ShellUtils.Info

  sharing type ToolData.ShellTypes.user_options = UserOptions.user_tool_options =
               GuiUtils.user_tool_options = ShellUtils.UserOptions
  sharing type GuiUtils.user_context_options =
               ToolData.UserContext.user_context_options
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
  sharing type Shell.Context = ShellUtils.Context = ToolData.ShellTypes.Context
  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData
  sharing type Menus.Widget = DebuggerWindow.Widget = ToolData.Widget = GuiUtils.Widget = 
               Capi.Widget = ProfileTool.Widget = ErrorBrowser.Widget = InspectorTool.Widget
  sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
  sharing type ErrorBrowser.location = ShellUtils.Info.Location.T
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ToolData = DebuggerWindow.ToolData = 
               InspectorTool.ToolData = ProfileTool.ToolData = ErrorBrowser.ToolData
  sharing type Preferences.preferences = ToolData.ShellTypes.preferences =
               Ml_Debugger.preferences = ShellUtils.preferences
  sharing type ShellUtils.user_context = GuiUtils.user_context = 
               ProfileTool.user_context = ErrorBrowser.user_context
  sharing type ShellUtils.Type = GuiUtils.Type = InspectorTool.Type
  sharing type Preferences.user_preferences = ShellUtils.user_preferences =
               ToolData.ShellTypes.user_preferences = GuiUtils.user_preferences =
               ProfileTool.user_preferences
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
  sharing type ErrorBrowser.error = Shell.Info.error
): LISTENER =

  struct
    structure Info = ShellUtils.Info
    structure Location = Info.Location
    structure Options = ShellUtils.Options
    structure ShellTypes = ToolData.ShellTypes
    structure UserContext = ToolData.UserContext
      
    type ToolData = ToolData.ToolData

    val do_debug = false
    fun debug s = if do_debug then Terminal.output(s ^ "\n") else ()
    fun fdebug f = if do_debug then Terminal.output(f() ^ "\n") else ()
    fun ddebug s = Terminal.output(s ^ "\n")

    fun make_debugger_function (debugger_type,user_options,user_preferences,local_context) f x =
      Ml_Debugger.with_start_frame
      (fn base_frame =>
       (f x)
       handle
       exn as ShellTypes.DebuggerTrapped => raise exn
     |  exn as Shell.Exit _ => raise exn
     |  exn as MLWorks.Interrupt => raise exn
     |  exn as Info.Stop _ => raise exn
     |  exn as Capi.SubLoopTerminated => raise exn
     |  exn =>
	  (Ml_Debugger.ml_debugger
	   (debugger_type,
	    ShellTypes.new_options
	    (user_options,
	     GuiUtils.get_user_context (!local_context)),
	    Preferences.new_preferences user_preferences)
	   (base_frame,
	    Ml_Debugger.EXCEPTION exn,
	    Ml_Debugger.POSSIBLE
	    ("quit (return to listener)",
	     Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
	    Ml_Debugger.NOT_POSSIBLE);
	   raise ShellTypes.DebuggerTrapped))
      
    (* Some dull utilities *)
      
    val prompt = "MLWorks>"
    val prompt_len = size prompt
      
    fun strip_prompt (s:string):string =
      if String.isPrefix prompt s then
	String.extract (s, prompt_len, NONE)
      else
	s
	
    exception NoLocation
    fun get_location line =
      let
	val sz = size line
	fun aux index =
	  if index < sz
	    then
	      if String.sub (line,index) = #":" then
		index+1
	      else
		aux (index+1)
	  else
	    raise NoLocation
	(* skip up to second ":" *)
	val result = SOME (substring (line,0,(aux (aux 0))-1))
	handle NoLocation => NONE
      in
	result
      end
    
      (*
       * the mutex is used to control access to all the I/O fns
       * so that position information isn't corrupted between
       * thread switches.
       *
       * See <URI:spring://ML_Notebook/Design/GUI/Mutexes>.
       *
       * inputBuffer is used to store input when concurrent output
       * interleaves with multi-line input.  anyOutput records
       * whether any concurrent output has been printed during the
       * current multi-line input, and anyRecentOutput records
       * whether or not any output occurred since the last line.
       *
       * see <URI:spring://ML_Notebook/Design/GUI/Mutexes#
       *                                   input-over-several-lines>
       *)
    val inputBuffer = ref ""
    val anyOutput = ref false
    val anyRecentOutput = ref false

    local
      val mutex = Mutex.newBinaryMutex false
      val claimant = ref NONE
      val numClaims = ref 0
    in
      fun claimWindow () =
        let
          val me = MLWorks.Threads.Internal.id()
          val notClaimed = case !claimant
                             of (SOME id) => id<>me
                              | NONE => true
        in
          if notClaimed then (Mutex.wait [mutex]; 
                              claimant:=(SOME me);
                              numClaims:=1)
          else numClaims:=(!numClaims+1)
        end

      fun releaseWindow () =
        (numClaims:= !numClaims-1;
         if !numClaims=0 then (claimant:=NONE;
                               Mutex.signal [mutex])
         else ())

      fun lockWindow f a =
             (claimWindow ();              
             (f a)
              before (releaseWindow())
             )
             handle e => (releaseWindow(); raise e)
    end



    (* TEXT UTILITIES *)
      
    (* Most change functions should check that the change is allowable -- only motif *)
    (* will do this automatically *)
      
    fun get_current_line text =
       let
         val pos = Capi.Text.get_insertion_position text
       in
         Capi.Text.get_line (text, pos)
       end
    
    fun get_current_subline (text,start_pos) =
      let
	val (line,ix) = Capi.Text.get_line_and_index (text,start_pos)
	val line2 = strip_prompt line
	val ix2 = ix - (size line - size line2)
      in
	if ix2 > 0 then substring (* could raise Substring *) (line2,0,ix2) else ""
      end
    
    val (input_flag,input_string) = (ref false,ref "")
      
    val text_size = Capi.Text.text_size

    fun replace_current_input ((text,prompt_pos,write_pos),line) =
      if !input_flag then
	()
      else
	let
	  val length = Capi.Text.get_last_position text
	  val line = Capi.Text.check_insertion(text, line, !prompt_pos, [write_pos,prompt_pos])
	in
	  (* Capi.Text.replace doesn't always work properly for X, but
	   setting the whole string causes ridiculous amounts of flicker. *)
	  Capi.Text.replace (text,!prompt_pos,length,line);
	  Capi.Text.set_insertion_position
	  (text, !prompt_pos + text_size line)
	end
      
    fun start_of_line (text,prompt_pos,write_pos) () =
      let
	val ppos = !prompt_pos
	val pos = Capi.Text.get_insertion_position text
	val new_pos =
	  if pos < ppos
	    then Capi.Text.current_line (text,pos)
	  else ppos
      in
	Capi.Text.set_insertion_position (text,new_pos)
      end
    
    fun end_of_line (text,prompt_pos,write_pos) () =
      let
	val ppos = !prompt_pos
	val pos = Capi.Text.get_insertion_position text
	val new_pos =
	  if pos < ppos
	    then Capi.Text.end_line (text,pos)
	  else Capi.Text.get_last_position text
      in
	Capi.Text.set_insertion_position (text,new_pos)
      end
    
    fun forward_char (text,prompt_pos,write_pos) () =
      let
	val pos = Capi.Text.get_insertion_position text
	val last_pos = Capi.Text.get_last_position text
	val end_line = Capi.Text.end_line (text, pos)
	  
	val new_pos =
	  if pos = last_pos orelse pos = last_pos - 1 then
	    last_pos
	  else if pos = end_line - 1 then
	    (* This case handles Windows \r\n. *)
	    pos + size Capi.terminator
	       else
		 pos + 1
      in
	Capi.Text.set_insertion_position (text, new_pos)
      end
    
    fun backward_char (text,prompt_pos,write_pos) () =
      let
	val pos = Capi.Text.get_insertion_position text
	val end_line = Capi.Text.end_line (text, pos)
	val last_pos = Capi.Text.get_last_position text
	val term_size = size Capi.terminator
	  
	val new_pos =
	  if pos = 0 then
	    0
	  else if pos = last_pos then
	    if Capi.Text.substring (text, last_pos - term_size, term_size) =
	      Capi.terminator then
	      pos - term_size
	    else
	      pos - 1
	       else if pos = end_line then
		 (* This case handles Windows \r\n. *)
		 pos - term_size
		    else
		      pos - 1
      in
	Capi.Text.set_insertion_position (text, new_pos)
      end
    
    fun previous_line (text,prompt_pos,write_pos) () =
      let
	val pos = Capi.Text.get_insertion_position text
	val start_line = Capi.Text.current_line (text, pos)
	val end_line = Capi.Text.end_line (text, pos)
	  
	val column =
	  if pos = start_line then
	    0
	  else if pos = end_line then
	    (* This case handles Windows \r\n. *)
	    pos - start_line - (size Capi.terminator - 1)
	       else
		 pos - start_line
		 
	val prev_line =
	  if start_line = 0 then
	    0
	  else
	    Capi.Text.current_line (text, start_line - 1)
	    
	val length_prev_line = start_line - prev_line
	  
	(* If this is the first line, leave the insertion position
	 as it is.  This is Windows semantics, not Motif. *)
	val new_pos =
	  if start_line = 0 then
	    pos
	  else if column > length_prev_line then
	    start_line - 1
	       else
		 prev_line + column
      in
	Capi.Text.set_insertion_position (text, new_pos)
      end
    
    fun next_line (text,prompt_pos,write_pos) () =
      let
	val pos = Capi.Text.get_insertion_position text
	val start_line = Capi.Text.current_line (text, pos)
	val end_line = Capi.Text.end_line (text, pos)
	  
	val column =
	  if pos = end_line then
	    (* This case handles Windows \r\n. *)
	    pos - start_line - (size Capi.terminator - 1)
	  else
	    pos - start_line
	    
	val last_pos = Capi.Text.get_last_position text
	  
	val end_next_line =
	  if last_pos = end_line then
	    last_pos
	  else
	    Capi.Text.end_line (text, end_line + 1)
	    
	val length_next_line = end_next_line - end_line
	  
	(* If this is the last line, leave the insertion position
	 as it is.  This is Windows semantics, not Motif. *)
	val new_pos =
	  if last_pos = end_line then
	    pos
	  else if column >= length_next_line then
	    end_next_line
	       else
		 end_line + column + 1
      in
	Capi.Text.set_insertion_position (text, new_pos)
      end
    



    (* get_current_input gets the text between the start_position
       and the end of the buffer.  When the input is for evaluation,
       start_pos should be !prompt_pos.  When the input is to be
       passed to std_in, start_pos should be !write_pos.
     *)
    fun get_current_input (text, start_pos, write_pos) =
      let
	val last_pos = Capi.Text.get_last_position text

	val input =
	  Capi.Text.substring (text, start_pos, last_pos - start_pos)
      in
	if size input = 0 orelse
	  String.sub (input, size input - 1) <> #"\n" then
	  (debug ("Inserting return at " ^ Int.toString last_pos);
	   (* This is always after the prompt *)
	   Capi.Text.insert (text, last_pos, "\n");
	   write_pos := last_pos + text_size "\n";
	   Capi.Text.set_insertion_position
	   (text, last_pos + text_size "\n");
	   input ^ "\n")
	else
	  (write_pos := last_pos;
	   input)
      end
    



    (* get_input_line gets input to evaluate or to pass to stdin, as
     appropriate.  In the former case, start_pos should be !prompt_pos;
         in the latter case, start_pos should be !write_pos.
       *)
    fun get_input_line (text, start_pos, write_pos) =
       let
         val last_pos = Capi.Text.get_last_position text
         val current_pos = Capi.Text.get_insertion_position text
       in
         if current_pos < start_pos then
           let
             val line =
               strip_prompt (Capi.Text.get_line (text, current_pos)) ^ "\n"
           in
             (* last_pos always after the prompt *)
             Capi.Text.insert(text, last_pos, line);
             write_pos := last_pos + text_size line;
             Capi.Text.set_insertion_position
             (text, last_pos + text_size line);
             line
           end
         else (* current_pos >= start_pos *)
           get_current_input (text, start_pos, write_pos)
       end
    
    (* END TEXT UTILITIES *)
  
    val listener_tool = ref NONE
    val sizeRef = ref NONE
    val posRef = ref NONE

    (*
     * create_listener: the podiumExists boolean here indicates whether MLWorks 
     * has a podium (true on Windows, false on Unix), so that we know whether 
     * to create an interrupt button on the Listener.
     *)    
    fun create_listener podiumExists
      (tooldata as ToolData.TOOLDATA
       {args,appdata,current_context,motif_context,tools}) =
      let
	val ShellTypes.LISTENER_ARGS {user_options,
				      user_preferences,
				      prompter,
				      mk_xinterface_fn,
				      ...} = args
	  
	val ToolData.APPLICATIONDATA {applicationShell,...} = appdata
	  
	val full_menus =
	  case user_preferences
	    of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	      !full_menus
	      
	val title = "Listener"
	
	val location_title = "<"^title^">"
	  
	(*** Make the windows ***)
	val (shell,mainWindow,menuBar,contextLabel) = 
	  if podiumExists then 
	    Capi.make_main_window 
	       {name = "listener",
		title = title,
		parent = applicationShell,
		contextLabel = full_menus, 
		winMenu = false,
		pos = getOpt(!posRef, Capi.getNextWindowPos())}
	  else 
	    let 
	      val (mainWindow, menuBar, contextLabel) = 
		Capi.make_main_subwindows (applicationShell, full_menus)
	    in
	      Capi.reveal mainWindow;
	      (applicationShell, mainWindow, menuBar, contextLabel)
	    end

	val buttonPane =
	  Capi.make_managed_widget ("buttonPane", Capi.RowColumn, mainWindow, []);
	  
	(*** IO Functions ***)
	  
	fun beep () = Capi.beep shell
	fun message_fun s = Capi.send_message (shell,s)
	  
	val local_context = ref motif_context
	  
	(*** Debugger Functions ***)
	  
	(* This creates the debugger window when the listener is being created *)
	(* Strange things happen if done at debugger entry time *)
	val (run_debugger, clean_debugger) =
	  DebuggerWindow.make_debugger_window
	  (shell, title ^ " Debugger", tooldata)
	  
	val debugger_type =
	  Ml_Debugger.WINDOWING
	  (run_debugger,
	   print,
	   true)
	  
	val debugger_function =
	  make_debugger_function
	  (debugger_type,user_options,user_preferences,local_context)
	  
	fun get_current_user_context () =
	  GuiUtils.get_user_context (!local_context)
	  
	fun get_user_context_options () =
	  ToolData.UserContext.get_user_options (get_current_user_context ())

	(* Options and contexts *)
	fun get_user_options () = user_options

	(* Note that val shell_data depends on val profiler which depends on 
	 * mk_tooldata which depends on mk_listener_args below *)
	fun mk_listener_args () =     
	  ShellTypes.LISTENER_ARGS
          {user_context = GuiUtils.get_user_context (!local_context),
           user_options = UserOptions.copy_user_tool_options user_options,
           user_preferences = user_preferences,
           prompter = prompter,
           mk_xinterface_fn = mk_xinterface_fn}


	fun mk_tooldata () = 
	  ToolData.TOOLDATA {args = mk_listener_args(),
			     appdata = appdata,
			     current_context = current_context,
			     motif_context = !local_context,
			     tools = tools}

	(* Profiler functions and values *)
	  
	val profiler =
	  ProfileTool.create (applicationShell, user_preferences, 
			      mk_tooldata, get_current_user_context)

	val time_space_profile_manner =
	  MLWorks.Profile.make_manner
	  {time = true,
	   space = true,
	   calls = false,
	   copies = false,
	   depth = 0,
	   breakdown = []}
	  
	val time_space_profile_options =
	  MLWorks.Profile.Options {scan = 10,
				   selector = fn _ => time_space_profile_manner}

	(* This is a really dirty hack *)
	  
	val profiling = ref false
	  
	fun profile f a =
	  let
	    val (r,p) =
	      MLWorks.Profile.profile time_space_profile_options f a
	  in
	    (profiler p;
	     case r of
	       MLWorks.Profile.Result r => r
	     | MLWorks.Profile.Exception e => raise e)
	  end
	
	fun profiling_debugger_function f a =
	  if (!profiling) then
	    debugger_function (profile f) a
	  else
	    debugger_function f a
	  
	val shell_data =
	  ShellTypes.SHELL_DATA
	  {get_user_context =
	   fn () => GuiUtils.get_user_context (!local_context),
	   user_options = user_options,
	   user_preferences = user_preferences,
	   prompter = prompter,
	   debugger = profiling_debugger_function,
	   profiler = profiler,
	   exit_fn = fn n => raise Shell.Exit n,
	   x_running = true,	(* Can't start X interface from an X listener *)
	   mk_xinterface_fn = mk_xinterface_fn,
	   (* for starting X from a saved image *)
	   mk_tty_listener = TTYListener.listener
	   (* for starting saved images *)
	   }

	val quit_funs = ref [fn () => listener_tool := NONE]
	  
	fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
	  
	(* Text stuff *)
	val (scroll,text) = (Capi.make_scrolled_text ("textIO",mainWindow,[]))
	  
	val interrupt_button = 
	  if podiumExists then 
	    NONE
	  else 
	    let 
	      val i = Capi.make_managed_widget("interruptButton", Capi.Button, mainWindow, [])

	    in
	      Capi.Callback.add (i, Capi.Callback.Activate, fn _ => Capi.set_focus text);
	      SOME i
	    end

	val _ = Capi.transfer_focus (mainWindow,text)

	(* write_pos is the position new input should go in the buffer, usually
	 the end.  Also used as the position from which standard input is read.
         Output from the program should go before this position.  Input is read
         from after it.
	 prompt_pos is the position just after the most recent prompt.
	 The current compiler input lies between prompt_pos and get_last_pos
	 text. 
         *)
	  
	val write_pos = ref 0
	val prompt_pos = ref 0

	fun modification_ok pos =
	  (fdebug (fn () => "modification_ok: pos = " ^ Int.toString pos ^
		   ", prompt_pos = " ^ Int.toString (!prompt_pos));
	   not Capi.Text.read_only_before_prompt orelse pos >= !prompt_pos)
	  
	fun modification_at_current_ok () =
	  modification_ok
	  (Capi.Text.get_insertion_position text
	   - size (Capi.Text.get_selection text))
	  
	val text_info = (text,prompt_pos,write_pos)
	  
	fun insert_at_current s =
	  if modification_at_current_ok ()
	    then Capi.Text.insert (text, Capi.Text.get_insertion_position text, s)
	  else beep ()
	    
	val buttons_update_fn_ref = ref (fn () => ())
	fun buttons_update_fn () = (!buttons_update_fn_ref) ()
	  
	local
	  (* Insert at the current write_pos *)
	  fun insert_text str =
	    (* write_pos always after prompt_pos, so no check *)
	    let
	      val str = Capi.Text.check_insertion 
                           (text,str,!write_pos,[write_pos,prompt_pos])
	      val old_pos = !write_pos
	      val new_pos = old_pos + text_size str;
	    in
	      Capi.Text.insert (text, old_pos, str);
	      (* on motif, insert can call modifyVerify, which can diddle 
               * with write_pos so we need to only update it here
               *)
	      write_pos := new_pos;
	      Capi.Text.set_insertion_position (text, new_pos)
	    end
	  
	  val inbuff as (posref,strref) = (ref 0,ref "")
	    
	  fun input_fun () =
	    (input_flag := true;
	     buttons_update_fn ();
	     Capi.event_loop input_flag;
	     !input_string)
	    
	  fun refill_buff () =
	    let val new_string = input_fun ()
	    in
	      posref := 0;
	      strref := new_string
	    end
	  
	  val eof_flag = ref false
	    
	  fun get_input n =
	    let
	      val string = !strref
	      val pointer = !posref
	      val len = size string
	    in
	      if !eof_flag then
	""
	      else if pointer + n > len then
		(refill_buff ();
		 substring (* could raise Substring *) (string,pointer,len-pointer) ^
		 get_input (n - len + pointer))
		   else
		     let val result = substring (* could raise Substring *) (string,pointer,n)
		     in
		       posref := (!posref + n);
		       result
		     end
	    end
	  
	  fun do_lookahead () =
	    (if !eof_flag then
	       ""
	     else if !posref >= size (!strref) then
	       (refill_buff ();
		do_lookahead ())
		  else
		    substring (* could raise Substring *) (!strref, !posref, 1))
	       
	  fun close_in () = eof_flag := true
	  fun closed_in () = !eof_flag
	  fun clear_eof () = eof_flag := false
	    
            (* Note: all I/O must be controlled by the listener mutex
             * to overcome problems with thread interference.  See
             * <URI:spring://ML_Notebook/Design/GUI/Mutexes>.
             * This also explains the role of anyOutput.
             *)

	  val thisWindow = {output={descriptor=NONE,
				    put=
                                    lockWindow
                                       (fn {buf,i,sz} =>
                                        let val els = case sz of
                                          NONE=>size buf-i
                                        | (SOME s)=> s
                                        in insert_text (substring (buf,i,els));
                                           anyRecentOutput:=true;
                                          els
                                        end),
                                  get_pos=NONE,
                                  set_pos=NONE,
                                  can_output=NONE,
                                  close = fn()=>()},
	    error ={descriptor=NONE,
		    put=lockWindow
                      (fn {buf,i,sz} =>
                       let val els = case sz of
                         NONE=>size buf-i
                       | (SOME s)=> s
                       in insert_text (substring (buf,i,els));
                          anyRecentOutput:=true;
                         els
                       end),
		    
		  get_pos=NONE,
		  set_pos=NONE,
		  can_output=NONE,
		  close=fn()=>()},
	    input ={descriptor=NONE,
		    get= lockWindow (fn _ => input_fun()),
		    get_pos=SOME(lockWindow (fn()=> !posref)),
		    set_pos=SOME(lockWindow (fn i=>posref:=i)),
		    can_input=SOME(lockWindow (fn()=>
                                                  (!posref<size (!strref)))),
		    close=lockWindow(close_in)}
            ,
            (* The access field is used solely to provide a hook for the
             * pervasive library fn Threads.Internal.Preemption.stop,
             * so that this fun can actually claim the window before it
             * shuts down preemption.  See
             * <URI:spring://ML_Notebook/Design/GUI/Mutexes>.
             *)
            access = fn f => lockWindow f ()}
	    
	(*NB, in the above, perhaps #input#get shouldn't ignore
	 its argument...?  *)
	    
	in
	  fun inThisWindow () =
	    MLWorks.Internal.StandardIO.redirectIO thisWindow
	    
	  val outstream = GuiUtils.make_outstream (lockWindow insert_text)
	    
          val clear_input = lockWindow (fn ()=>
             (debug "Clearing input";
              posref := 0;
              strref := "";
              eof_flag := false))
	    
(*
	  val instream =
	    MLWorks.IO.instream {input = lockWindow get_input,
				 lookahead = lockWindow do_lookahead,
				 end_of_stream = lockWindow
				 (fn () => do_lookahead () = ""),
				 clear_eof = lockWindow clear_eof,
				 close_in = lockWindow close_in,
				 closed_in = lockWindow closed_in}
*)	    
	end
      
	fun delete_current_line text_info _ =
	  if modification_at_current_ok () then
	    replace_current_input (text_info,"")
	  else
	    beep ()
	    
	fun eof_or_delete (text,prompt_pos,write_pos) () =
	  let
	    val pos = Capi.Text.get_insertion_position text
	    val last_pos = Capi.Text.get_last_position text
	  in
	    if pos = last_pos andalso pos = !write_pos then
	      (debug "eof";
	       if !input_flag then
		 ((*MLWorks.IO.close_in instream;*)
		  buttons_update_fn ();
		  input_flag := false)
	       else
		 beep ())
	    else
	      if modification_ok pos then
		Capi.Text.replace (text, pos, pos + 1, "")
	      else beep ()
	  end
	
	(* Although edit_error and edit_error_sens are not used at the moment, 
	 * they should be kept as they may be introduced in future to support
	 * a menu item. 
	 *)
	fun edit_error _ =
	  (let
	     (* Get a location string from the current line *)
	     val line = get_current_line text
	     val locstring = 
	       let val lstring = get_location line
	       in 
		 (* NoLocation exception should never be raised here - if so,
		  * either the edit_error_sens function is not working or it 
		  * has not been applied to the menu item.
		  *)
		 if isSome lstring then valOf lstring 
		 else raise NoLocation
	       end
	     val quit_fun =
	       ShellUtils.edit_source
	       (locstring, ShellTypes.get_current_preferences shell_data)
	   in
	     quit_funs := quit_fun :: (!quit_funs)
	   end
	 handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
	      | NoLocation => message_fun "Edit failed: no location info found"
	      | Location.InvalidLocation => message_fun "Edit failed: no location info found")

	(* This function should be used as the sensitivity function of the 
         * Listener->EditError menu option if this menu item is to be brought
	 * back again. 
	 *)
	fun edit_error_sens _ = isSome (get_location (get_current_line text))
	     
	(* SYMBOL COMPLETION *)
	(* Necessary for popping down completion window *)
	local
	  val actions_after_input = ref []
	in
	  fun after_input _ =
	    (Lists.iterate (fn f => f ()) (!actions_after_input);
	     actions_after_input := [])
	  fun add_after_input_action action =
	    actions_after_input := action :: !actions_after_input
	end
      
	(* name completion *)
	fun do_completion start_pos =
	  let
	    (* The current line up to pos *)
	    val subline = get_current_subline (text,start_pos)
	    val use_completion_menu =
	      let
		val preferences = ShellTypes.get_current_preferences shell_data
		val Preferences.PREFERENCES
		  {environment_options =
		   Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
		   ...} =
		  preferences
	      in
		!completion_menu
	      end
	    val options = ShellTypes.get_current_options shell_data
	    val (sofar,completions) =
	      ShellUtils.get_completions
	      (subline, options,
	       UserContext.get_context
	       (GuiUtils.get_user_context (!local_context)))
	      
	    (* Completions are replaced here because on Win32 if the user used single
	     * slashes to separate directory names the completion of the filename was 
	     * out of synch and completions resulting in filenames which did not exist.
	     * On Motif, replacing is necessary to avoid the case that the user types 
	     * more than one slash at the end of a directory name in which case a value
	     * passed to subscript (no longer used here) was negative, resulting in 
	     * raising an exception.  The behaviour is now to remove the extra slash
	     * if one exists (this is done by replacing with a greater length of text) *) 
	    fun replace_at(pos,str) =
	      if modification_ok pos then
		let
		  val npos = pos - size sofar
		in
		  if ((size sofar) > (size str)) then 
		    (Capi.Text.replace (text, npos, npos + size sofar, str);
		     Capi.Text.set_insertion_position (text, npos + size sofar))
		  else
		    (Capi.Text.replace (text, npos, npos + size str, str);
		     Capi.Text.set_insertion_position (text, npos + size str))
		end
	      else
		beep ()
		
	    fun replace_fun a = replace_at (start_pos, a)

	  in
	    case completions of
	      [] => beep ()
	    | [a] => replace_fun a
	    | l =>
		let val c = ShellUtils.find_common_completion l
		in
		  if c = sofar then
		    if (use_completion_menu) then
		      let
			val popdown =
			  Capi.list_select
                          (shell, "completions",
			   fn c => replace_at (start_pos, sofar ^ c))
                          (l,replace_fun, fn x => x)
		      in
			Capi.set_focus text;
			add_after_input_action popdown
		      end
		    else beep ()
		  else replace_fun c
		end
	  end
	
	val replace_current_input = fn s => replace_current_input (text_info,s)
	  
	fun get_input_from_stdin () =
	  get_input_line (text, !write_pos, write_pos)
	  
	(* get_input_to_evaluate first calls get_input_line; if the cursor
	 is before the prompt, this copies the current line to the end of
	 the buffer.  Then it calls get_current_input, which returns all
	 the text between the prompt and the end of the buffer.
	 *)

	fun get_input_to_evaluate () =
          (ignore(get_input_line (text, !prompt_pos, write_pos));
           get_current_input (text, !prompt_pos, write_pos))


	val input_disabled = ref false
	  
	fun with_input_disabled f =
	  (input_disabled := true;
	   let
	     val result = f () handle exn => (input_disabled := false;raise exn)
	   in
	     input_disabled := false;
	     result
	   end)
	  
	val flush_rest = ref false
	(* This function is called if a syntax error is detected in the input *)
	fun flush_stream () = flush_rest := true
	  
	fun get_preferences () = ShellTypes.get_current_preferences shell_data
	  
	fun use_error_browser () =
	  case get_preferences ()
	    of Preferences.PREFERENCES
	      {environment_options =
	       Preferences.ENVIRONMENT_OPTIONS {use_error_browser, ...},
	       ...} =>
	      !use_error_browser
	      
	val (handler'', make_prompt) =
	  Shell.shell (shell_data,location_title,flush_stream)
	  
	(* If using the error browser, we don't want the errors to be printed. *)
	fun handler' s =
	  if use_error_browser () then
	    let
	      (* output warnings to std_out *)
	      fun report_warnings (error as Info.ERROR (severity,location,_)) =
		if severity = Info.WARNING orelse Info.< (severity, Info.WARNING)
		  then TextIO.output (outstream, Info.string_error error ^ "\n")
		else ()
	    in
	      Info.with_report_fun
	      (Info.make_default_options ())
	      report_warnings
	      handler''
	      s
	    end
	  else
	    handler'' (Info.make_default_options ()) s
	    
	fun handler s =
	  (inThisWindow();                 (*redirects PrimIO stdIO to gui*)
	   (Capi.with_window_updates 	
	    (fn () =>
	     (with_input_disabled
	       (fn () =>
		Ml_Debugger.with_debugger_type
		debugger_type
		(fn _ =>
		 ShellTypes.with_toplevel_name location_title
		 (fn _ => handler' s)))))))
	  
	fun time_handler x =
	  let
	    val (start_cpu, start_real) =
	      (Timer.startCPUTimer(), Timer.startRealTimer())
	      
	    fun times_to_string(real_elapsed, {usr, sys}, gc) =
	      concat [Time.toString real_elapsed,
		      " (user: ",
		      Time.toString usr,
		      "(gc: ",
		      Time.toString gc,
		      "), system: ",
		      Time.toString sys,
		      ")"]
	    fun print_time () =
	      let
		val time =
		  (Timer.checkRealTimer start_real,
		   Timer.checkCPUTimer start_cpu,
		   Timer.checkGCTime start_cpu)
	      in
		TextIO.output (outstream, times_to_string time ^ "\n");
		TextIO.flushOut outstream
	      end
	    
	    val result =
	      handler x
	      handle
              exn => (print_time (); raise exn)
	  in
	    case result
	      of ([], _, Shell.OK _) => ()  (* Ignore uncompleted phrases *)
	    |  _ => print_time ();
		 result
	  end
	
	fun output_prompt () =
          (claimWindow();
           anyOutput:=false;
           anyRecentOutput:=false;
           TextIO.output
	   (outstream, make_prompt ("MLWorks", Shell.initial_state));
	   TextIO.flushOut outstream;
	   prompt_pos := !write_pos)


	fun force_prompt () =
	  (TextIO.output (outstream,"\n");
	   output_prompt ())
	  
	fun set_context_state (motif_context) =
	  case contextLabel of
	    SOME w =>
	      (local_context := motif_context;
	       Capi.set_label_string (w,"Context: " ^ GuiUtils.get_context_name motif_context))
	  | NONE => ()
	      
	val _ = set_context_state motif_context
	  
	fun set_state context = (set_context_state context; force_prompt ())
	  
	val context_key =
	  ToolData.add_context_fn
          (current_context, (set_state, get_user_options, ToolData.WRITABLE))
	  
	val _ =
	  quit_funs :=
	  (fn () => ToolData.remove_context_fn (current_context, context_key))
	  :: !quit_funs
	  
	fun select_context motif_context =
	  (set_state motif_context;
	   ToolData.set_current
           (current_context, context_key, user_options, motif_context))

	val {update_history, prev_history, next_history, history_start,
	     history_end, history_menu} =
	  GuiUtils.make_history
	  (user_preferences, 
 	   fn line => (replace_current_input line; buttons_update_fn ())) 

	val update_history = fn x => (inputBuffer:="";
                                      update_history x)
          (*<URI:spring://ML_Notebook/Design/Mutexes#input-over-several-lines>
           *)

	fun finish_up str =
	  (output_prompt ();
	   TextIO.output (outstream, str);
	   TextIO.flushOut outstream;
	   buttons_update_fn ();
	   (* Clear waiting input from std_in. *)
	   clear_input ())
	  
	(* For interface with inspector *)
	val do_select_fn = ref (fn () => ())
	  
	(* str is the input string, loc is the location of the erroneous
	 statement in that string, offset is the position where the last
	 topdec begins in str, and b specifies whether to highlight or
	 unhighlight. *)
	fun highlight (str, loc, b, offset) =
	  let
	    val (s_pos, e_pos) = Info.Location.extract (loc, str)
	  in
	    Capi.Text.set_highlight
            (text,
	     s_pos + !prompt_pos - offset,
	     e_pos + !prompt_pos - offset,
	     b)
	  end
        handle Info.Location.InvalidLocation => ()
	  
	fun error_handler
	  (error_list, redo_action, close_action, input, offset) =
	  let
	    fun edit_action location =
	      if ShellUtils.editable location then
		{quit_fn = ShellUtils.edit_location (location, get_preferences()),
		 clean_fn = fn () => ()}
	      else
		(highlight (input, location, true, offset);
		 {quit_fn = fn () => (),
		  clean_fn = fn () => highlight (input, location, false, offset)})
	    val location_file = case error_list of
	      [] => location_title
	    | Info.ERROR(_, location, _) :: _ =>
		case Location.file_of_location location of
		  "" => location_title
		| s => s
	  in
	    ErrorBrowser.create
            {parent = shell,
             errors = rev error_list,
             file_message = location_file,
             edit_action = edit_action,
             editable = fn _ => true,
	     close_action = close_action,
             redo_action = redo_action,
	     mk_tooldata = mk_tooldata,
	     get_context = get_current_user_context}
	  end
	
	(* The evaluating flag disables GUI controls during an evaluation. *)
	val evaluating = ref false;
	  
	local
	  val error_browser_ref = ref NONE
	    
	  fun kill_error_browser () =
	    case !error_browser_ref
	      of NONE => ()
	    |  SOME f =>
		 (f ();
		  error_browser_ref := NONE)

        in
	  

	  fun do_evaluate time_it =
	    let
	      val _ = kill_error_browser ()
		
              val input = get_input_to_evaluate ()

              (* Next, if a concurrent thread has output data in between
               * lines of a multi-line input, then remember previous
               * part.  If any. *)

              val input = if !anyOutput then !inputBuffer ^ input 
                          else input

              val _ = releaseWindow()

	      val _ = fdebug (fn () => "input: " ^ input);
		
	      val end_pos = !write_pos
	      val prev_capi_eval = !Capi.evaluating
	      val _ = evaluating := true
	      val _ = Capi.evaluating := true
	      val _ = buttons_update_fn ()
		
	      val result =
		(if time_it then
		   time_handler (input, Shell.initial_state)
		 else
		   handler (input, Shell.initial_state))
		   handle exn => (evaluating := false;
				  Capi.evaluating := prev_capi_eval;
                                  buttons_update_fn ();
				  raise exn)
		     
	    in
	      evaluating := false;
	      Capi.evaluating := prev_capi_eval;
	      buttons_update_fn ();
	      clean_debugger ();
	      case result
		of ([], str, Shell.OK _) =>
                  (claimWindow();
                   if !anyRecentOutput then 
                     (anyOutput:=true;
                      inputBuffer:= input;     
                      anyRecentOutput:=false;
                      prompt_pos:= !write_pos)
                       (* don't want to reread old input if 
                        * had intervening output. *)
                     else ()) 
                       (* NOTE that the other cases of this switch
                        *  all call finish_up, which in turn calls
                        *  output_prompt, which claims the window.
                        * See <URI:spring://ML_Notebook/Design/GUI/Mutexes#
                        *                           input-over-several-lines>
                        *)

	      |  (_, _, Shell.TRIVIAL) =>
		   finish_up ""
	      |  (l, str, Shell.INTERRUPT) =>
		   (update_history l;
		    case l of
		      [] => ()
		    | _ => (!do_select_fn) ();
			TextIO.output (outstream, "Interrupt\n");
			TextIO.flushOut outstream;
			finish_up str)
	      |  (l, str, Shell.DEBUGGER_TRAPPED) =>
		   (update_history l;
		    case l of
		      [] => ()
		    | _ => (!do_select_fn) ();
			finish_up str)
	      |  (l, str, Shell.OK _) =>
		   (* OK *)
		   (update_history l;
		    (!do_select_fn) ();
		    finish_up str)
	      |  (l, str, Shell.ERROR (_, error_list)) =>
		   (* Error *)
		   (update_history l;
		    case l of
		      [] => ()
		    | _ => (!do_select_fn) ();
			if use_error_browser () then
			  let
			    (* If any topdecs have been successfully evaluated, then
			     the code below will output a new prompt followed by
			     the remainder of the input.  Any highlighting must
			     be relative to the remaining input, so we have to
			     adjust the location information by the amount of
			     code that we have removed. *)
			    val offset = Lists.reducel (fn (i, s) => i + size s) (0, l)
			      
			    fun print_error () =
			      case rev error_list
				of [] => ()
			      |  (err::_) =>
				   TextIO.output
				   (outstream, ErrorBrowser.error_to_string err ^ "\n")
			  in
			    (* If the evaluation has caused anything to be written,
		              then output a new prompt, with the offending input
		              after.  This means that the input to be evaluated
		              is always at the end of the Widget.
		
		              If users close the error browser in this situation,
			      they are left with the current input at the prompt.
			      Deleting the current input gives the cleanest record
			      of activity, but users may have started to edit the
			      input.  Another alternative is to output a new prompt,
			      but that looks weird.
			      *)
			    if end_pos <> !write_pos then
			      (print_error ();
			       finish_up str;
			       error_browser_ref :=
			       SOME
			       (error_handler
				(error_list,
				 fn () =>
				 do_evaluate time_it,
				 fn () =>
				 (update_history [str];
				  buttons_update_fn ();
				  clear_input ()),
				 input,
				 offset)))
			    else
			      error_browser_ref :=
			      SOME
			      (error_handler
			       (error_list,
				fn () =>
				do_evaluate time_it,
				fn () =>
				(update_history [str];
				 print_error ();
				 finish_up ""),
				input,
				offset))
			  end
			else
			  (update_history [str];
			   finish_up ""))
	    end
	  handle
	  Shell.Exit _ => Capi.destroy shell
	end

	fun do_return () =
	  if !input_flag then
	    let
	      val input = get_input_from_stdin ()
	    in
	      (input_string := input;
	       buttons_update_fn ();
	       input_flag := false;
               releaseWindow())
	    end
	  else if !input_disabled then
	    beep ()
	       else
                  do_evaluate false
		 
	(* More text stuff *)
	(* A flag to indicate whether escape has just been pressed *)
	val escape_pressed = ref false
	  
	fun do_escape () = escape_pressed := true

(*
      fun check_copy_selection _ =
	 Capi.Text.copy_selection text

      fun check_paste_selection _ =
	 if modification_at_current_ok ()
          then Capi.Text.paste_selection text
        else beep ()

      fun check_cut_selection _ =
        if modification_at_current_ok ()
          then Capi.Text.cut_selection text
        else beep ()

      fun check_delete_selection _ =
        if modification_at_current_ok ()
          then Capi.Text.delete_selection text
        else beep ()
*)

	(* These ones attempt to use the capi clipboard *)
	fun check_copy_selection _ =
	  Capi.clipboard_set (text,Capi.Text.get_selection text)

	fun check_paste_selection _ =
	  if modification_at_current_ok ()
	    then
	      Capi.clipboard_get (text,
				  fn s =>
				  Capi.Text.insert (text,
						    Capi.Text.get_insertion_position text,
						    s))
	  else beep ()

	fun check_cut_selection _ =
	  if modification_at_current_ok ()
	    then
	      let
		val s = Capi.Text.get_selection text
	      in
		Capi.Text.delete_selection text;
		Capi.clipboard_set (text,s)
	      end
	  else beep ()

	fun check_delete_selection _ =
	  if modification_at_current_ok ()
	    then Capi.Text.delete_selection text
	  else beep ()

	fun abandon (text, prompt_pos, write_pos) () =
	  (lockWindow update_history
                          [get_current_input (text, !prompt_pos, write_pos)];
           finish_up "")

	val meta_bindings =
	  [("p", prev_history),
	   ("n", next_history)]

	fun delete_to_end () =
	  let
	    val ppos = !prompt_pos
	    val pos = Capi.Text.get_insertion_position text
	    val end_pos =
	      if pos < ppos
		then Capi.Text.end_line (text,pos)
	      else Capi.Text.get_last_position text
	  in
	    if modification_ok pos then
	      (Capi.Text.set_selection (text,pos,end_pos);
	       check_cut_selection ())
	    else
	      beep ()
	  end

	fun do_delete _ = 
	  let 
	    val sel = Capi.Text.get_selection text
	    val pos = Capi.Text.get_insertion_position text
	  in
	    if modification_at_current_ok() then
	      if sel = "" then 
	        Capi.Text.replace(text, pos, pos + 1, "")
	      else
		check_delete_selection()
	    else beep()
	  end

	val common_bindings =
	  [("\t" , fn _ => do_completion (Capi.Text.get_insertion_position text)),
	   ("\r" , do_return),
	   ("\027", do_escape)]

	(* These functions are not used by Windows now as the default 
	 * functionality offered by Windows for the keys: 'HOME', 'END', 
	 * the cursor keys, etc, is at least sufficient if not better.
	 * The main reason for using the standard Windows actions is 
	 * that they allow selection through the keyboard by holding 
	 * down the shift and/or control keys while using the cursor
	 * and other navigation keys. 
	 *)
	val key_handlers = 
	  {startOfLine =    start_of_line text_info,
	   endOfLine = 	    end_of_line text_info,
	   backwardChar =   backward_char text_info,
	   forwardChar =    forward_char text_info,
	   previousLine =   previous_line text_info,
	   nextLine =       next_line text_info,
	   abandon =        abandon text_info,
	   eofOrDelete =    eof_or_delete text_info,
	   deleteToEnd =    delete_to_end,
	   newLine = 	    fn _ => insert_at_current "\n",
	   delCurrentLine = delete_current_line text_info,
	   checkCutSel =    check_cut_selection,
	   checkPasteSel =  check_paste_selection}

	val normal_bindings = 
	  common_bindings @@ (Capi.Text.get_key_bindings key_handlers)

	fun despatch_key bindings key =
	  let
	    fun loop [] = false
	      | loop ((key',action)::rest) =
		if key = key' then (ignore(action ()); true)
		else loop rest
	  in
	    loop bindings
	  end

	val despatch_meta = despatch_key meta_bindings
	val despatch_normal = despatch_key normal_bindings

	(* This part needs to be sorted out and bits moved into capi *)
 	(* This is only used for Motif, so no need to call check_insertion. *)
	fun do_insert_text ((text,prompt_pos,write_pos),start_pos,end_pos,str) =
	   (fdebug (fn _ =>
		   "Verify: start_pos is " ^ Int.toString start_pos ^
		   ", end_pos is " ^ Int.toString end_pos ^
		   ", write_pos is " ^ Int.toString (!write_pos) ^
		   ", prompt_pos is " ^ Int.toString (!prompt_pos) ^
		   ", string is '" ^ str ^ "'");
	  if end_pos < !write_pos
	    then write_pos := (!write_pos) - end_pos + start_pos + text_size str
	  else if start_pos < !write_pos then
	    write_pos := start_pos + text_size str
	       else ();
		 if end_pos < !prompt_pos
		   then prompt_pos := (!prompt_pos) - end_pos + start_pos + text_size str
		 else if start_pos < !prompt_pos
			then prompt_pos := start_pos + text_size str
		      else ())

	(* Motif only *)
	fun modifyVerify (start_pos,end_pos,str,set_fn) =
	  let
	    val _ = after_input ()
	  in
	    if !escape_pressed andalso size str = 1
	      then
		(escape_pressed := false;
		 set_fn false;
                 ignore(despatch_meta str);
		 ())
	    else if not Capi.Text.read_only_before_prompt orelse
	      start_pos >= !prompt_pos then
	      (do_insert_text (text_info,start_pos,end_pos,str);
	       set_fn true)
		 else
		   (beep ();
		    set_fn false)
	  end
	
	fun bad_key key =
	  not (("\000" <= key andalso key <= "\007") orelse
	       ("\009" <= key andalso key <= "\031")) andalso
	  Capi.Text.read_only_before_prompt andalso
	  let
	    val pos = if key = "\008" then !prompt_pos+1 else !prompt_pos
	  in
	    Capi.Text.get_insertion_position text < pos
	  end
	
	(* The checking for bad_key etc. is for the benefit of Windows *)
	(* This code is only called for the keys with activate actions in Motif *)
	fun text_handler (key,modifiers) =
	  (debug ("Text handler: " ^ MLWorks.String.ml_string (key,100));
	   after_input ();
	   if bad_key key then
	     (beep (); true)
	   else if !escape_pressed then
	     (* handle escape characters first *)
	     (escape_pressed := false; despatch_meta key)
		else if Lists.member (Capi.Event.meta_modifier, modifiers) then
		  despatch_meta key
		     else
		       despatch_normal key)
  
	fun close_window _ =
	  if not (!evaluating) then
	    (do_quit_funs ();
	     Capi.destroy shell)
	  else
	    ()
	    
	fun get_user_context () = GuiUtils.get_user_context (!local_context)
	  
	fun get_value () =
	  let
	    val user_context = get_user_context ()
	  in
	    ShellUtils.value_from_user_context (user_context,user_options)
	  end
	
	val inspect_fn = InspectorTool.inspect_value (shell,false,mk_tooldata())
	  
	val _ =
	  do_select_fn :=
	  (fn () =>
	   case get_value () of
	     SOME x => inspect_fn true x
	   | _ => ())
	  
	val searchButtonSpec =
	  GuiUtils.search_button
	  (shell, fn _ => !local_context, insert_at_current, true)
	  
	val value_menu =
	  GuiUtils.value_menu
	  {parent = shell,
	   user_preferences = user_preferences,
	   inspect_fn = SOME (inspect_fn false),
           get_value = get_value,
	   enabled = true,
	   tail = []}
	  
	val view_options =
	  GuiUtils.view_options
	  {parent = shell, title = title, user_options = user_options,
	   user_preferences = user_preferences,
	   caller_update_fn = fn _ => (),
	   view_type =
	   [GuiUtils.SENSITIVITY,
	    GuiUtils.VALUE_PRINTER,
	    GuiUtils.INTERNALS]}
	  
	fun use_action _ =
	  case Capi.open_file_dialog (shell, ".sml", false)
	    of NONE => ()
	  |  SOME [] => ()
	  |  SOME (s::rest) =>
	       (replace_current_input ("use");
		insert_at_current (" \"" ^ MLWorks.String.ml_string (s, ~1) ^ "\";");
		do_evaluate false)
	       
	fun evaluate_fn () = (Capi.set_focus text;
			      do_evaluate false)
	fun step_fn () = (Trace.set_stepping true;
			  Capi.set_focus text;
			  do_evaluate false;
			  Trace.set_stepping false)
	fun time_fn () = (Capi.set_focus text;
			  do_evaluate true)
	fun profile_fn () = (profiling := true;
			     Capi.set_focus text;
			     do_evaluate false;
			     profiling := false)
	fun clear_fn () = (delete_current_line text_info ();
			   Capi.set_focus text)
	fun abandon_fn () = (abandon text_info ();
			     Capi.set_focus text)
	fun previous_fn () = (prev_history ();
			      Capi.set_focus text)
	fun next_fn () = (next_history ();
			  Capi.set_focus text)

	val file_menu = ToolData.file_menu 
           [("use", use_action, fn _ => not (!evaluating)),
	    ("save", fn _ =>
		       GuiUtils.save_history (false, get_user_context (), applicationShell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), applicationShell),
		       fn _ => not (UserContext.null_history (get_user_context ()))),
	    ("close", close_window, fn _ => not (!evaluating) andalso podiumExists)]

	val view = ToolData.extract view_options
	val values = ToolData.extract value_menu
	val search = ToolData.extract 
			(Menus.CASCADE ("dummy", [searchButtonSpec], fn () => false))

	val usage = view @@ values @@ search

	val menuspec =
	  [file_menu,
	   ToolData.edit_menu (shell,
            {cut = SOME (check_cut_selection),
             paste = SOME (check_paste_selection),
             copy = SOME (check_copy_selection),
             delete = SOME (check_delete_selection),
	     edit_possible = fn _ => modification_at_current_ok (),
             selection_made = fn _ => Capi.Text.get_selection text <> "",
	     edit_source = [value_menu],
	     delete_all = SOME ("deleteAll", fn _ => (prompt_pos := 0;
				       write_pos := 0;
				       Capi.Text.set_string (text, "");
				       finish_up "";
				       Capi.set_focus text),
				     fn _ => not (!evaluating)) }),
	   ToolData.tools_menu (mk_tooldata, get_current_user_context),
	   ToolData.usage_menu (usage, []),
	   Menus.CASCADE ("listener_menu", 
	     [Menus.PUSH ("evaluate",  evaluate_fn, fn _ => not (!evaluating)),
	      Menus.PUSH ("stepEval",  step_fn,     fn _ => not (!evaluating)),
	      Menus.PUSH ("time",      time_fn,     fn _ => not (!evaluating)),
	      Menus.PUSH ("profile",   profile_fn,  fn _ => not (!evaluating)),
	      Menus.SEPARATOR,
	      Menus.PUSH ("clear_def", clear_fn,    fn _ => not (!evaluating)),
	      Menus.PUSH ("abandon",   abandon_fn,  fn _ => not (!evaluating)),
	      Menus.PUSH ("previous_def", previous_fn,
				fn () => not (!evaluating) andalso not (history_start ())),
	      Menus.PUSH ("next_def", next_fn,
				fn () => not (!evaluating) andalso not (history_end ())),
	      GuiUtils.listener_properties (shell, fn _ => (!local_context))],
			fn _ => true),
	   ToolData.debug_menu values]
	  @@ (if full_menus then
	       [GuiUtils.context_menu
	        {set_state = select_context,
                 get_context = fn _ => !local_context,
                 writable = GuiUtils.WRITABLE,
                 applicationShell = applicationShell,
                 shell = shell,
                 user_preferences = user_preferences}]
	     else
	       [])
	  @@ [history_menu]

	val {update, ...} =
	  Menus.make_buttons
	  (buttonPane,
	   [Menus.PUSH ("evaluateButton", evaluate_fn, fn _ => not (!evaluating)),
	    Menus.PUSH ("stepButton",     step_fn,     fn _ => not (!evaluating)),
	    Menus.PUSH ("timeButton",     time_fn,     fn _ => not (!evaluating)),
	    Menus.PUSH ("profileButton",  profile_fn,  fn _ => not (!evaluating)),
	    Menus.PUSH ("clearButton",    clear_fn,    fn _ => not (!evaluating)),
	    Menus.PUSH ("abandonButton",  abandon_fn,  fn _ => not (!evaluating)),
	    Menus.PUSH ("prevButton",     previous_fn, 
			fn _ => not (!evaluating) andalso not (history_start ())),
	    Menus.PUSH ("nextButton",     next_fn, 
			fn _ => not (!evaluating) andalso not (history_end ()))]);

	fun with_no_listener f arg1 arg2 =
	  let 
	    val listener = !listener_tool
	    val currentIO = MLWorks.Internal.StandardIO.currentIO()
	  in
	    listener_tool := NONE;
	    MLWorks.Internal.StandardIO.resetIO();
	    ignore(
              f arg1 arg2 handle exn => (listener_tool := listener; 
  				         MLWorks.Internal.StandardIO.redirectIO currentIO;
				         raise exn));
	    listener_tool := listener;
	    MLWorks.Internal.StandardIO.redirectIO currentIO
	  end

	fun store_size_pos () = 
	  (sizeRef := SOME (Capi.widget_size shell);
	   posRef := SOME (Capi.widget_pos shell))

      in
	quit_funs := store_size_pos :: (!quit_funs);
	SaveImage.add_with_fn with_no_listener;
	Capi.Text.add_del_handler(text, do_delete);
	listener_tool := SOME shell;
	buttons_update_fn_ref := update;
	quit_funs := Menus.quit :: (!quit_funs);
	Menus.make_submenus (menuBar,menuspec);
	Capi.Layout.lay_out
	(mainWindow, !sizeRef, 
	 [Capi.Layout.MENUBAR menuBar] @@
	 (case contextLabel of
	    SOME w => [Capi.Layout.FIXED w]
	  | _ => [Capi.Layout.SPACE]) @@
	    (if podiumExists then [] else 
		[Capi.Layout.FIXED (valOf interrupt_button),
		 Capi.Layout.SPACE]) @@
	    [Capi.Layout.FLEX scroll,
	     Capi.Layout.SPACE,
	     Capi.Layout.FIXED buttonPane,
	     Capi.Layout.SPACE]);
	Capi.Text.add_handler (text, text_handler);
	Capi.Text.add_modify_verify (text, modifyVerify);
	Capi.set_close_callback(mainWindow, close_window);
	Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
	Capi.initialize_toplevel shell;
	buttons_update_fn ();
	if podiumExists then 
	  () 
	else 
	  Capi.register_interrupt_widget (valOf interrupt_button);
 	Capi.set_focus text;
	output_prompt ()
      end

    fun create podium tooldata = 
      if isSome (!listener_tool) then
 	Capi.to_front (valOf (!listener_tool))
      else
	create_listener podium tooldata

  end;





@


1.111
log
@[Bug #30369]
Change type of Capi.open_file_dialog.
@
text
@d5 4
d1819 1
a1819 1
	    fun times_to_string(real_elapsed, {usr, sys, gc}) =
d1823 3
a1825 1
		      ", system: ",
a1826 2
		      ", gc: ",
		      Time.toString gc,
d1831 3
a1833 1
		  (Timer.checkRealTimer start_real, Timer.checkCPUTimer start_cpu)
@


1.111.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a4 4
 * Revision 1.111  1998/06/01  14:22:24  johnh
 * [Bug #30369]
 * Change type of Capi.open_file_dialog.
 *
@


1.110
log
@[Bug #30346]
Call Capi.getNextWindowPos().
@
text
@d5 4
d2383 1
a2383 1
	  case Capi.open_file_dialog (shell, ".sml")
d2385 2
a2386 1
	  |  SOME s =>
@


1.109
log
@[Bug #30090]
Remove uses of MLWorks.IO
@
text
@d5 4
d1266 1
a1266 1
		pos = getOpt(!posRef, (100,100))}
@


1.108
log
@[Bug #50035]
Allow keyboard accelerators to be platform specific.
@
text
@d5 4
d771 1
a866 1
    structure IO = MLWorks.IO
d1293 1
a1293 1
	   fn s => MLWorks.IO.output (MLWorks.IO.std_out, s),
d1572 1
d1574 8
a1581 8
	    IO.instream {input = lockWindow get_input,
			 lookahead = lockWindow do_lookahead,
			 end_of_stream = lockWindow
                                           (fn () => do_lookahead () = ""),
			 clear_eof = lockWindow clear_eof,
			 close_in = lockWindow close_in,
			 closed_in = lockWindow closed_in}
	    
d1598 1
a1598 1
		 (MLWorks.IO.close_in instream;
d1778 1
a1778 1
		  then MLWorks.IO.output (outstream, Info.string_error error ^ "\n")
a1794 3
	      (fn () =>
	       IO.with_standard_error          (*redirects MLWorks.IO stdIO *)
	       outstream
d1796 5
a1800 11
		IO.with_standard_output
		outstream
		(fn () =>
		 IO.with_standard_input
		 instream
		 (fn () =>
		  Ml_Debugger.with_debugger_type
		  debugger_type
		  (fn _ =>
		   ShellTypes.with_toplevel_name location_title
		   (fn _ => handler' s))))))))))
d1821 2
a1822 2
		MLWorks.IO.output (outstream, times_to_string time ^ "\n");
		IO.flush_out outstream
d1840 1
a1840 1
           MLWorks.IO.output
d1842 1
a1842 1
	   IO.flush_out outstream;
d1847 1
a1847 1
	  (MLWorks.IO.output (outstream,"\n");
d1888 2
a1889 2
	   MLWorks.IO.output (outstream, str);
	   IO.flush_out outstream;
d2022 2
a2023 2
			MLWorks.IO.output (outstream, "Interrupt\n");
			IO.flush_out outstream;
d2056 1
a2056 1
				   MLWorks.IO.output
@


1.107
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d5 4
d2221 2
a2222 15
	val normal_bindings =
	  [("\^A", start_of_line text_info),
	   ("\^B", backward_char text_info),
	   ("\^D", eof_or_delete text_info),
	   ("\^E", end_of_line text_info),
	   ("\^F", forward_char text_info),
	   ("\^G", abandon text_info),
	   ("\^K", delete_to_end),
	   ("\^N", next_line text_info),
	   ("\^O", fn _ => insert_at_current "\n"),
	   ("\^P", previous_line text_info),
	   ("\^U", delete_current_line text_info),
	   ("\^W", check_cut_selection),
	   ("\^Y", check_paste_selection),
	   ("\t" , fn _ => do_completion (Capi.Text.get_insertion_position text)),
d2226 26
d2285 1
a2285 1

d2329 1
a2329 2

	    
@


1.106
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d5 4
d1730 1
a1730 1
          (get_input_line (text, !prompt_pos, write_pos);
d2239 1
a2239 1
		if key = key' then (action (); true)
d2277 1
a2277 1
               despatch_meta str;
d2476 4
a2479 3
	    f arg1 arg2 handle exn => (listener_tool := listener; 
				       MLWorks.Internal.StandardIO.redirectIO currentIO;
				       raise exn);
@


1.105
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d5 4
d765 1
d859 3
a861 3
    fun debug s = if do_debug then MLWorks.IO.output(IO.terminal_out,s ^ "\n") else ()
    fun fdebug f = if do_debug then MLWorks.IO.output(IO.terminal_out,f() ^ "\n") else ()
    fun ddebug s = MLWorks.IO.output(IO.terminal_out,s ^ "\n")
a1112 9
	(*
	 MLWorks.IO.output
	 (MLWorks.IO.terminal_out,
	 "pos = " ^ Int.toString pos ^
	 " start_line = " ^ Int.toString start_line ^
	 " prev_line = " ^ Int.toString prev_line ^
	 " new_pos = " ^ Int.toString new_pos ^
	 "\n");
	 *)
a1148 9
	(*
	 MLWorks.IO.output
	 (MLWorks.IO.terminal_out,
	 "pos = " ^ Int.toString pos ^
	 " start_line = " ^ Int.toString start_line ^
	 " end_line = " ^ Int.toString end_line ^
	 " new_pos = " ^ Int.toString new_pos ^
	 "\n");
	 *)
@


1.104
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d5 4
d1225 2
d1257 7
a1263 1
	    Capi.make_main_window ("listener",title,applicationShell,full_menus, false)
d2492 4
d2497 1
d2505 1
a2505 1
	(mainWindow,
@


1.103
log
@[Bug #30089]
Remove use of MLWorks.Time.Elapsed in favour of basis timer
@
text
@d5 4
d22 15
a860 2
     (* This represents errors from Make etc. *)
     |  exn as Shell.Error _ => raise exn
d2359 2
a2360 11
	datatype file_action =
	  LOAD_SOURCE | LOAD | COMPILE | COMPILE_AND_LOAD | USE
	  
	fun action_string LOAD_SOURCE = "Shell.File.loadSource"
	  |   action_string LOAD = "Shell.File.loadObject"
	  |   action_string COMPILE = "Shell.File.compile"
	  |   action_string COMPILE_AND_LOAD = "Shell.File.compileAndLoad"
	  |   action_string USE = "use"
	      
	fun file_action fileExtension action _ =
	  case Capi.open_file_dialog (shell, fileExtension)
d2363 1
a2363 1
	       (replace_current_input (action_string action);
a2366 2
	val sourceFileAction = file_action ".sml"

d2389 1
a2389 6
           [("load_source_file", sourceFileAction LOAD_SOURCE, fn _ => not (!evaluating)),
	    ("load_file", file_action ".mo" LOAD, fn _ => not (!evaluating)),
	    ("compile_file", sourceFileAction COMPILE, fn _ => not (!evaluating)),
	    ("compile_and_load_file", sourceFileAction COMPILE_AND_LOAD,
		     fn _ => not (!evaluating)),
	    ("use", sourceFileAction USE, fn _ => not (!evaluating)),
d2436 2
a2437 1
				fn () => not (!evaluating) andalso not (history_end ()))],
d2439 1
a2439 2
	   ToolData.debug_menu values,
           GuiUtils.paths_menu mainWindow]
@


1.102
log
@[Bug #30284]
Call SaveImage.add_with_fn to add a wrapper function which resets the reference
storing the listener_tool widget for the duration of the image save call.
@
text
@d5 5
d668 59
a726 59
 *  needed to get this far, so from here on it's plain sailing :-)
*
*  Revision 1.16  1993/04/06  10:10:39  jont
*  Moved user_options and version from interpreter to main
*  Added menu stuff for compatibility options
*
*  Revision 1.15  1993/04/05  10:55:13  matthew
*  Changed ordof and MLWorks.String.ordof to MLWorks.String.ordof
*  Changed interface to inspector tool
*
*  Revision 1.14  1993/04/02  15:15:30  matthew
*  Structure changes
*  Added File Selection tool
*
*  Revision 1.13  1993/03/31  13:52:25  matthew
*  Added Options menus
*
*  Revision 1.12  1993/03/30  11:39:23  matthew
*  Added state stack and push and pop operations thereon
*
*  Revision 1.10  1993/03/24  10:14:03  matthew
*  Menu modifications
*  Most of this is test code.
*
*  Revision 1.9  1993/03/18  18:08:55  matthew
*  Added create_new_listener function
*  Added output_fn field to shell_data
*
*  Revision 1.8  1993/03/18  09:56:56  matthew
*  Add newline when using earlier line
*
*  Revision 1.7  1993/03/17  16:18:38  matthew
*  Used Menus utilities to make menubar menus
*
*  Revision 1.6  1993/03/15  17:13:35  matthew
*  Simplified ShellTypes types
*
*  Revision 1.5  1993/03/15  14:34:51  daveb
*  Fixed problems with prompt and resizing.
*
*  Revision 1.4  1993/03/12  11:42:44  matthew
*  Changed interface to shell.
*  Haven't tested this
*
*  Revision 1.3  1993/03/09  15:57:55  matthew
*  Options & Info changes
*  Changes for ShellData type
*
*  Revision 1.2  1993/03/04  16:40:19  daveb
*  Replaced mainWindow/text combination with rowColumn/scrolledText.
*  Scrolling now works properly.
*
*  Revision 1.1  1993/03/02  19:18:28  daveb
*  Initial revision
*
*
*  Copyright (c) 1993 Harlequin Ltd.
*
*)
d731 2
d1784 2
a1785 1
	    val start = MLWorks.Time.Elapsed.elapsed ()
d1787 9
d1798 2
a1799 1
		val elapsed = MLWorks.Time.Elapsed.elapsed_since start
d1801 1
a1801 1
		MLWorks.IO.output (outstream, MLWorks.Time.Elapsed.format elapsed ^ "\n");
@


1.101
log
@[Bug #30193]
Reogranise the System Messages implementation.
@
text
@d5 4
d750 1
d780 1
d822 1
a822 1
      
d827 1
a827 1
      
d2447 14
d2462 1
@


1.100
log
@[Bug #30137]
Create system messages window.
@
text
@d5 4
a1356 6
	      (* This dummy text widget is needed so that the messages originally 
	       * sent to the podium are sent somewhere else which is not visible.
	       * This 'dummy' text widget is hidden.  If the message widget is not
	       * set, garbage collection messages are sent to the controlling tty.
	       *)
	      val dummy = Capi.make_widget ("hidden_text", Capi.Text, mainWindow, []);
a1357 1
	      Capi.set_message_widget dummy;
a1362 67

	fun make_message_window () = 
	  let
	    val visible = ref false 

	    val parent = applicationShell
            val (messagesShell, messFrame, messMenuBar, _) =
	      Capi.make_messages_popup (applicationShell, visible)

            val (messages_widget, messages)  = 
	      Capi.make_scrolled_text ("messages", messFrame, [])

	    val buttonRC = Capi.make_managed_widget 
		("messagesRC", Capi.RowColumn, messFrame, [])

	    fun clear_messages () = Capi.Text.set_string (messages, "")

	    fun popup _ = 
		(Capi.reveal messFrame;
		 Capi.to_front messagesShell; 
		 visible := true)

	    fun popdown _ = 
		(Capi.hide messagesShell; 
		 Capi.hide messFrame;
		 visible := false)

	    val {update, ...} = 
	      Menus.make_buttons (buttonRC,
		[Menus.PUSH ("clear_messages", clear_messages, fn _ => true),
		 Menus.PUSH ("close_messages", popdown, fn _ => true)])

	    fun copy _ = 
	      Capi.clipboard_set (messages, Capi.Text.get_selection messages)

	    val menuspec =
	      [ToolData.file_menu [("close", popdown, fn _ => true)],
	       ToolData.edit_menu (messFrame,
                {cut = NONE,
                 paste = NONE,
                 copy = SOME copy,
                 delete = NONE,
	         edit_possible = fn _ => false,
                 selection_made = fn _ => Capi.Text.get_selection messages <> "",
	         delete_all = SOME ("deleteAll", clear_messages, fn _ => true),
	         edit_source = []}),
	     ToolData.tools_menu (mk_tooldata, get_current_user_context),
	     ToolData.usage_menu ([], []),
	     ToolData.debug_menu [],
	     GuiUtils.paths_menu messFrame]

	  in
	    Capi.set_close_callback (messagesShell, popdown);
	    Capi.set_message_widget messages;
	    Menus.make_submenus (messMenuBar, menuspec);
	    Capi.Layout.lay_out (messFrame, 
	      [Capi.Layout.MENUBAR messMenuBar,
	       Capi.Layout.FLEX messages_widget, 
	       Capi.Layout.SPACE,
	       Capi.Layout.FIXED buttonRC]);
	    popup
	  end

	val messageWindow = make_message_window()

	val system = [("sysMessages", messageWindow, fn _ => isSome (!listener_tool))]
	val _ = ToolData.set_global_usage_items (system, []);
@


1.99
log
@[Bug #30182]
Add delete handler.
@
text
@d5 4
d1366 68
a1433 1
	  
d2449 1
@


1.99.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a4 4
 * Revision 1.99  1997/07/23  14:21:03  johnh
 * [Bug #30182]
 * Add delete handler.
 *
@


1.99.2.2
log
@[Bug #30071]
Move menu items from Usage->GeneralPreferences to Listener->Properties.
@
text
@a4 3
 * Revision 1.99.2.1  1997/09/11  20:52:29  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d2413 1
a2413 2
				fn () => not (!evaluating) andalso not (history_end ())),
	      GuiUtils.listener_properties (shell, fn _ => (!local_context))],
@


1.99.2.3
log
@[Bug #30071]
Generalise open_file_dialog to take any masks.
@
text
@d2419 2
a2420 1
	   ToolData.debug_menu values]
@


1.99.2.4
log
@[Bug #30071]
The Shell.Error exception is no longer needed.
@
text
@a4 4
 * Revision 1.99.2.3  1997/11/20  17:09:32  johnh
 * [Bug #30071]
 * Generalise open_file_dialog to take any masks.
 *
d828 2
@


1.99.2.5
log
@[Bug #30071]
Remove old commands from the File menu.
@
text
@a4 4
 * Revision 1.99.2.4  1997/11/26  13:13:35  daveb
 * [Bug #30071]
 * The Shell.Error exception is no longer needed.
 *
d2326 11
a2336 2
	fun use_action _ =
	  case Capi.open_file_dialog (shell, ".sml")
d2339 1
a2339 1
	       (replace_current_input ("use");
d2343 2
d2367 6
a2372 1
           [("use", use_action, fn _ => not (!evaluating)),
@


1.99.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a4 4
 * Revision 1.99  1997/07/23  14:21:03  johnh
 * [Bug #30182]
 * Add delete handler.
 *
@


1.98
log
@[Bug #30181]
Tidy interrupt button code.
@
text
@d5 4
d2159 13
d2440 1
@


1.97
log
@[Bug #30179]
Fixing interrupt button on Unix.
@
text
@d1343 1
a1343 1
	      val i = Capi.make_interrupt_button mainWindow
@


1.96
log
@[Bug #30174]
Replace podium with Listener on Motif and create Listener on startup for Windows.
@
text
@d5 4
d2446 4
@


1.95
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d5 4
d739 20
a758 20
structure Lists: LISTS
structure Crash : CRASH
structure Capi: CAPI
		  
structure Preferences : PREFERENCES
structure UserOptions : USER_OPTIONS
		  
structure Shell: SHELL
structure ShellUtils : SHELL_UTILS
structure TTYListener : TTY_LISTENER
structure Ml_Debugger: ML_DEBUGGER
structure Trace : TRACE
structure ToolData : TOOL_DATA
structure GuiUtils : GUI_UTILS
structure Menus : MENUS
structure DebuggerWindow : DEBUGGERWINDOW
structure InspectorTool : INSPECTORTOOL
structure ProfileTool : PROFILE_TOOL
structure ErrorBrowser: ERROR_BROWSER
structure Mutex : MUTEX
d760 31
a790 34
sharing UserOptions.Options =
  Ml_Debugger.ValuePrinter.Options =
  ShellUtils.Options =
  ToolData.ShellTypes.Options
sharing Shell.Info = ShellUtils.Info
  
sharing type ToolData.ShellTypes.user_options =
  UserOptions.user_tool_options =
  GuiUtils.user_tool_options = ShellUtils.UserOptions
	sharing type GuiUtils.user_context_options =
	  ToolData.UserContext.user_context_options
		sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
			sharing type Shell.Context = ShellUtils.Context =
			  ToolData.ShellTypes.Context
				sharing type Shell.ShellData = ToolData.ShellTypes.ShellData
					sharing type Menus.Widget = DebuggerWindow.Widget = ToolData.Widget =
					  GuiUtils.Widget = Capi.Widget = ProfileTool.Widget =
					  ErrorBrowser.Widget = InspectorTool.Widget
						sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
							sharing type ErrorBrowser.location = ShellUtils.Info.Location.T
								sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
									sharing type ToolData.ToolData = DebuggerWindow.ToolData = InspectorTool.ToolData = ProfileTool.ToolData = ErrorBrowser.ToolData
										sharing type Preferences.preferences = ToolData.ShellTypes.preferences =
										  Ml_Debugger.preferences = ShellUtils.preferences
											sharing type ShellUtils.user_context = GuiUtils.user_context = ProfileTool.user_context = ErrorBrowser.user_context
												sharing type ShellUtils.Type = GuiUtils.Type = InspectorTool.Type
													sharing type Preferences.user_preferences = ShellUtils.user_preferences =
													  ToolData.ShellTypes.user_preferences =
													  GuiUtils.user_preferences =
													  ProfileTool.user_preferences
														sharing type GuiUtils.MotifContext = ToolData.MotifContext
															sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
																sharing type ErrorBrowser.error = Shell.Info.error
																  ): LISTENER =
d1176 6
a1181 2
    (* The main function *)
    fun create_listener external
d1203 12
a1214 3
	val (shell,mainWindow,menuBar,contextLabel) =
	  Capi.make_main_window ("listener",title,applicationShell,full_menus, false)
	  
d1334 19
d2314 22
a2335 1
	  
d2351 1
a2351 1
	    ("close", close_window, fn _ => not (!evaluating))]
d2378 8
a2385 20
		[Menus.PUSH ("evaluate",  fn _ => (Capi.set_focus text; do_evaluate false), 
					  fn _ => not (!evaluating)),
		Menus.PUSH ("stepEval", fn _ => (Trace.set_stepping true;
						Capi.set_focus text;
					 	do_evaluate false;
					 	Trace.set_stepping false),
			    		fn _ => not (!evaluating)),
		Menus.PUSH ("time", fn _ => (Capi.set_focus text; do_evaluate true),
				    fn _ => not (!evaluating)),
		Menus.PUSH ("profile",	fn _ => (profiling := true;
					 Capi.set_focus text;
					 do_evaluate false;
					 profiling := false), fn _ => not (!evaluating)),
		Menus.SEPARATOR,
		Menus.PUSH ("clear_def", fn _ => (delete_current_line text_info ();
					 	  Capi.set_focus text),
					 fn _ => not (!evaluating)),
		Menus.PUSH ("abandon", fn _ => (abandon text_info ();
					 Capi.set_focus text), fn _ => not (!evaluating)),
		Menus.PUSH ("previous_def", fn _ => (prev_history(); Capi.set_focus text), 
d2387 1
a2387 1
		Menus.PUSH ("next_def",  fn _ => (next_history(); Capi.set_focus text), 
d2407 7
a2413 31
	   [Menus.PUSH ("evaluateButton",
			fn _ => (Capi.set_focus text;
				 do_evaluate false),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("stepButton",
			fn _ => (Trace.set_stepping true;
				 Capi.set_focus text;
				 do_evaluate false;
				 Trace.set_stepping false),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("timeButton",
			fn _ => (Capi.set_focus text;
				 do_evaluate true),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("profileButton",
			fn _ => (profiling := true;
				 Capi.set_focus text;
				 do_evaluate false;
				 profiling := false),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("clearButton",
			fn _ => (delete_current_line text_info ();
				 Capi.set_focus text),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("abandonButton",
			fn _ => (abandon text_info ();
				 Capi.set_focus text),
			fn _ => not (!evaluating)),
	    Menus.PUSH ("prevButton",
			fn _ => (prev_history ();
				 Capi.set_focus text),
d2415 1
a2415 3
	    Menus.PUSH ("nextButton",
			fn _ => (next_history ();
				 Capi.set_focus text),
d2417 1
d2429 3
d2442 1
d2446 1
a2446 1
    fun create external tooldata = 
d2450 1
a2450 1
	create_listener external tooldata
d2453 5
@


1.94
log
@[Bug #30075]
Allowing only one instance of tools.
@
text
@d5 4
d1199 1
a1199 1
	  Capi.make_main_window ("listener",title,applicationShell,full_menus)
d2360 1
a2360 2
	  @@ [history_menu,
	     ToolData.windows_menu ()]
@


1.93
log
@[Bug #02030]
Fixing Usage->EditError functionality and remove the menu item for now.
@
text
@d5 4
a858 2
    val listener_number = ref 1
      
d1169 2
d1172 1
a1172 1
    fun create external
d1189 1
a1189 7
	val title =
	  let
	    val n = !listener_number
	  in
	    listener_number := n+1;
	    "Listener #" ^ Int.toString n
	  end
d1309 1
a1309 1
	val quit_funs = ref []
d2399 1
d2421 7
@


1.92
log
@[Bug #20057]
Add sofar string to key_function function in completion menu
@
text
@d5 4
d849 2
a850 1
	val result = substring (* could raise Substring *)(line,0,(aux (aux 0))-1)
d1523 4
d1531 10
a1540 1
	     val locstring = get_location line
d1550 6
d2249 1
a2249 1
	   tail = [Menus.PUSH ("edit_error", edit_error, fn _ => true)]}
d2344 1
a2344 3
				fn () => not (!evaluating) andalso not (history_end ())),
		Menus.SEPARATOR,
		Menus.PUSH ("edit_error", edit_error, fn _ => true)],
@


1.91
log
@Implementing single menu bar on Windows.
@
text
@d5 3
d1606 1
a1606 1
			   fn c => replace_at (start_pos, c))
@


1.90
log
@[Bug #2049]
Make sure file location is used in error browser title where appropriate
@
text
@d5 4
d762 1
a762 1
									sharing type ToolData.ToolData = DebuggerWindow.ToolData = InspectorTool.ToolData
d765 1
a765 1
											sharing type ShellUtils.user_context = GuiUtils.user_context
d1219 27
d1249 3
a1251 2
	  ProfileTool.create (applicationShell,user_preferences)
	  
d1264 1
a1264 1
	  
a1284 3
	    
	(* Options and contexts *)
	fun get_user_options () = user_options
d1302 1
a1302 1
	  
d1759 1
a1759 1
	  
d1763 2
a1764 3
	  (user_preferences,

	   fn line => (replace_current_input line; buttons_update_fn ()))
d1823 3
a1825 1
             redo_action = redo_action}
d2013 3
a2015 3
	  
	(*
fun check_copy_selection _ =
d2017 2
a2018 2
	 
fun check_paste_selection _ =
d2184 2
a2185 8
	  
	fun mk_tooldata () =
	  ToolData.TOOLDATA {args = ShellTypes.get_listener_args shell_data,
			     appdata = appdata,
			     current_context = current_context,
			     motif_context = !local_context,
			     tools = tools}
	  
d2221 1
d2253 23
a2275 51
	val file_menu =
	  Menus.CASCADE
          ("file",
           [Menus.PUSH
	    ("load_source_file",
	     sourceFileAction LOAD_SOURCE,
	     fn _ => not (!evaluating)),
            Menus.PUSH
	    ("load_file",
	     file_action ".mo" LOAD,
	     fn _ => not (!evaluating)),
            Menus.PUSH
	    ("compile_file",
	     sourceFileAction COMPILE,
	     fn _ => not (!evaluating)),
            Menus.PUSH
	    ("compile_and_load_file",
	     sourceFileAction COMPILE_AND_LOAD,
	     fn _ => not (!evaluating)),
            Menus.SEPARATOR,
            Menus.PUSH
	    ("use",
	     sourceFileAction USE,
	     fn _ => not (!evaluating)),
            Menus.SEPARATOR,
            Menus.PUSH
	    ("save",
	     fn _ =>
	     GuiUtils.save_history
	     (false, get_user_context (), applicationShell),
	     fn _ =>
	     not (UserContext.null_history (get_user_context ()))
	     andalso UserContext.saved_name_set (get_user_context ())),
            Menus.PUSH
	    ("saveAs",
	     fn _ =>
	     GuiUtils.save_history
	     (true, get_user_context (), applicationShell),
	     fn _ =>
	     not (UserContext.null_history (get_user_context ()))),
            Menus.SEPARATOR,
            Menus.PUSH
	    ("close", close_window, fn _ => not (!evaluating))],
	   fn _ => true)
	  
	fun get_current_user_context () =
	  GuiUtils.get_user_context (!local_context)
	  
	fun get_user_context_options () =
	  ToolData.UserContext.get_user_options (get_current_user_context ())
	  
d2278 1
a2278 2
	   ToolData.edit_menu
	   (shell,
d2285 38
a2322 3
	     tail = [searchButtonSpec]}),
	   Menus.CASCADE ("view", view_options, fn () => true),
	   value_menu]
d2333 1
a2333 5
	  @@ [GuiUtils.setup_menu
             (mainWindow, fn () => !local_context,
	      user_preferences, get_user_context_options),
	     ToolData.tools_menu (mk_tooldata, get_current_user_context),
	     history_menu,
d2335 1
a2335 2
	  
	  
a2362 7
	    Menus.PUSH ("clearAllButton",
			fn _ => (prompt_pos := 0;
				 write_pos := 0;
				 Capi.Text.set_string (text, "");
				 finish_up "";
				 Capi.set_focus text),
			fn _ => not (!evaluating)),
d2377 1
@


1.89
log
@Adding missing call to buttons_update_fun after setting evaluating.
@
text
@d5 3
d1781 6
d1791 1
a1791 1
             file_message = location_title,
@


1.89.1.1
log
@branched from 1.89
@
text
@a4 3
 * Revision 1.89  1997/03/21  14:40:05  matthew
 * Adding missing call to buttons_update_fun after setting evaluating.
 *
@


1.89.1.2
log
@[Bug #20057]
Added the sofar string to the keypress in the argument to list_select.
@
text
@a4 3
 * Revision 1.89.1.1  1997/05/12  10:31:43  hope
 * branched from 1.89
 *
d1574 1
a1574 1
			   fn c => replace_at (start_pos, sofar ^ c))
@


1.89.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a4 4
 * Revision 1.89.1.2  1997/05/21  16:36:13  daveb
 * [Bug #20057]
 * Added the sofar string to the keypress in the argument to list_select.
 *
@


1.89.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a4 4
 * Revision 1.89.1.2  1997/05/21  16:36:13  daveb
 * [Bug #20057]
 * Added the sofar string to the keypress in the argument to list_select.
 *
@


1.89.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a4 4
 * Revision 1.89.1.2  1997/05/21  16:36:13  daveb
 * [Bug #20057]
 * Added the sofar string to the keypress in the argument to list_select.
 *
@


1.89.1.2.1.2
log
@[Bug #30182]
Merging - add delete handler.
@
text
@a4 4
 *
 * Revision 1.89.1.2.1.1  1997/07/28  18:17:36  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a2059 13
	fun do_delete _ = 
	  let 
	    val sel = Capi.Text.get_selection text
	    val pos = Capi.Text.get_insertion_position text
	  in
	    if modification_at_current_ok() then
	      if sel = "" then 
	        Capi.Text.replace(text, pos, pos + 1, "")
	      else
		check_delete_selection()
	    else beep()
	  end

a2357 1
	Capi.Text.add_del_handler(text, do_delete);
@


1.89.1.2.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a4 4
 * Revision 1.89.1.2.1.2  1997/08/05  11:19:21  johnh
 * [Bug #30182]
 * Merging - add delete handler.
 *
@


1.88
log
@Adding handler for Shell.Error
@
text
@d5 3
d1835 1
@


1.87
log
@[Bug #1986]
Replacing completions rather than inserting to avoid raising
subscript exceptions on Motif and handle completions correctly
on Win32.
@
text
@d5 6
d787 2
@


1.86
log
@[Bug #1977]
Multi-line editing on Listener no longer works!
@
text
@d5 4
d1522 9
a1530 1
	    fun insert_at(pos,str) =
d1533 1
d1535 6
a1540 2
		  Capi.Text.insert (text,pos,str);
		  Capi.Text.set_insertion_position (text, pos + text_size str)
d1545 2
a1546 2
	    fun insert_fun a =
	      insert_at (start_pos,substring (* could raise Substring *) (a, size sofar, size a - size sofar))
d1550 1
a1550 1
	    | [a] => insert_fun a
d1560 2
a1561 2
			   fn c => insert_at (start_pos, c))
                          (l,insert_fun, fn x => x)
d1567 1
a1567 1
		  else insert_fun c
@


1.85
log
@[Bug #1667]
adding mutual exclusion primitives for the listener.
@
text
@d5 4
d831 1
d833 9
d844 2
d1368 1
d1379 1
d1393 1
d1663 2
d1707 2
a1708 1
	val update_history = fn x => (inputBuffer:="";update_history x)
d1782 8
a1789 1
              val input = !inputBuffer ^ input (* buffer old input *)
d1816 9
a1824 3
                  (inputBuffer:= input;     
                   claimWindow();           
                   prompt_pos:= !write_pos) (* don't want to reread old input*)
@


1.84
log
@[Bug #1799]
Make more calls to Capi.Text.check_insertion
Use truncated string from check_insertion where necessary
@
text
@d5 5
d667 1
d715 1
d823 42
d871 5
a875 5
      let
	val pos = Capi.Text.get_insertion_position text
      in
	Capi.Text.get_line (text, pos)
      end
d1062 3
d1073 1
d1091 3
d1099 19
a1117 19
      let
	val last_pos = Capi.Text.get_last_position text
	val current_pos = Capi.Text.get_insertion_position text
      in
	if current_pos < start_pos then
	  let
	    val line =
	      strip_prompt (Capi.Text.get_line (text, current_pos)) ^ "\n"
	  in
	    (* last_pos always after the prompt *)
	    Capi.Text.insert(text, last_pos, line);
	    write_pos := last_pos + text_size line;
	    Capi.Text.set_insertion_position
	    (text, last_pos + text_size line);
	    line
	  end
	else (* current_pos >= start_pos *)
	  get_current_input (text, start_pos, write_pos)
      end
d1255 2
a1256 1
	 text. *)
d1260 1
a1260 1
	  
d1286 2
a1287 1
	      val str = Capi.Text.check_insertion (text,str,!write_pos,[write_pos,prompt_pos])
d1292 3
a1294 2
	      (* on motif, insert can call modifyVerify, which can diddle with write_pos *)
	      (* so we need to only update it here *)
d1323 1
a1323 1
		""
d1349 5
d1355 9
a1363 7
				    put= fn {buf,i,sz} =>
				    let val els = case sz of
				      NONE=>size buf-i
				    | (SOME s)=> s
				    in insert_text (substring (buf,i,els));
				      els
				    end,
d1369 8
a1376 7
		    put= fn {buf,i,sz} =>
		    let val els = case sz of
		      NONE=>size buf-i
		    | (SOME s)=> s
		    in insert_text (substring (buf,i,els));
		      els
		    end,
d1383 14
a1396 6
		    get=fn _ =>input_fun(),
		    get_pos=SOME(fn()=> !posref),
		    set_pos=SOME(fn i=>posref:=i),
		    can_input=SOME(fn()=>
				   (!posref<size (!strref))),
		    close=close_in}}
d1405 1
a1405 1
	  val outstream = GuiUtils.make_outstream insert_text
d1407 5
a1411 5
	  fun clear_input () =
	    (debug "Clearing input";
	     posref := 0;
	     strref := "";
	     eof_flag := false)
d1414 7
a1420 6
	    IO.instream {input = get_input,
			 lookahead = do_lookahead,
			 end_of_stream = fn () => do_lookahead () = "",
			 clear_eof = clear_eof,
			 close_in = close_in,
			 closed_in = closed_in}
d1545 1
d1547 4
a1550 3
	  (get_input_line (text, !prompt_pos, write_pos);
	   get_current_input (text, !prompt_pos, write_pos))
	  
d1637 1
a1637 1
	      of ([], _, Shell.OK _) => ()		(* Ignore uncompleted phrases *)
d1643 2
a1644 1
	  (MLWorks.IO.output
d1648 2
a1649 1
	  
d1683 1
d1685 5
a1689 1
	  
d1751 2
a1752 1
	in
d1754 1
d1759 4
a1762 1
	      val input = get_input_to_evaluate ()
d1787 10
a1796 2
		  (* Nothing to do *)
		  ()
d1897 2
a1898 1
	       input_flag := false)
d1903 1
a1903 1
		 do_evaluate false
d1962 3
a1964 2
	  (update_history [get_current_input (text, !prompt_pos, write_pos)];
	   finish_up "")
d2020 1
a2020 1
	  (fdebug (fn _ =>
d2036 1
@


1.84.4.1
log
@branched from 1.84
@
text
@a4 5
 * Revision 1.84  1996/11/21  15:00:14  jont
 * [Bug #1799]
 * Make more calls to Capi.Text.check_insertion
 * Use truncated string from check_insertion where necessary
 *
@


1.84.3.1
log
@branched from 1.84
@
text
@a4 5
 * Revision 1.84  1996/11/21  15:00:14  jont
 * [Bug #1799]
 * Make more calls to Capi.Text.check_insertion
 * Use truncated string from check_insertion where necessary
 *
@


1.84.3.1.1.1
log
@branched from 1.84.3.1
@
text
@a4 3
 * Revision 1.84.3.1  1996/12/17  17:45:23  hope
 * branched from 1.84
 *
@


1.84.2.1
log
@branched from 1.84
@
text
@a4 5
 * Revision 1.84  1996/11/21  15:00:14  jont
 * [Bug #1799]
 * Make more calls to Capi.Text.check_insertion
 * Use truncated string from check_insertion where necessary
 *
@


1.84.1.1
log
@branched from 1.84
@
text
@a4 5
 * Revision 1.84  1996/11/21  15:00:14  jont
 * [Bug #1799]
 * Make more calls to Capi.Text.check_insertion
 * Use truncated string from check_insertion where necessary
 *
@


1.83
log
@[Bug #1728]
__integer becomes __int
@
text
@d1 1
a1 1
(* Listener using Motif interface *)
d5 4
d596 57
a652 57
 *
 *  Revision 1.16  1993/04/06  10:10:39  jont
 *  Moved user_options and version from interpreter to main
 *  Added menu stuff for compatibility options
 *
 *  Revision 1.15  1993/04/05  10:55:13  matthew
 *  Changed ordof and MLWorks.String.ordof to MLWorks.String.ordof
 *  Changed interface to inspector tool
 *
 *  Revision 1.14  1993/04/02  15:15:30  matthew
 *  Structure changes
 *  Added File Selection tool
 *
 *  Revision 1.13  1993/03/31  13:52:25  matthew
 *  Added Options menus
 *
 *  Revision 1.12  1993/03/30  11:39:23  matthew
 *  Added state stack and push and pop operations thereon
 *
 *  Revision 1.10  1993/03/24  10:14:03  matthew
 *  Menu modifications
 *  Most of this is test code.
 *
 *  Revision 1.9  1993/03/18  18:08:55  matthew
 *  Added create_new_listener function
 *  Added output_fn field to shell_data
 *
 *  Revision 1.8  1993/03/18  09:56:56  matthew
 *  Add newline when using earlier line
 *
 *  Revision 1.7  1993/03/17  16:18:38  matthew
 *  Used Menus utilities to make menubar menus
 *
 *  Revision 1.6  1993/03/15  17:13:35  matthew
 *  Simplified ShellTypes types
 *
 *  Revision 1.5  1993/03/15  14:34:51  daveb
 *  Fixed problems with prompt and resizing.
 *
 *  Revision 1.4  1993/03/12  11:42:44  matthew
 *  Changed interface to shell.
 *  Haven't tested this
 *  
 *  Revision 1.3  1993/03/09  15:57:55  matthew
 *  Options & Info changes
 *  Changes for ShellData type
 *  
 *  Revision 1.2  1993/03/04  16:40:19  daveb
 *  Replaced mainWindow/text combination with rowColumn/scrolledText.
 *  Scrolling now works properly.
 *  
 *  Revision 1.1  1993/03/02  19:18:28  daveb
 *  Initial revision
 *  
 *  
 *  Copyright (c) 1993 Harlequin Ltd.
 *  
d687 1
a687 1
   Usually you should use MLWorks.IO.terminal_out instead. *)
d690 98
a787 99
  structure Lists: LISTS
  structure Crash : CRASH
  structure Capi: CAPI

  structure Preferences : PREFERENCES
  structure UserOptions : USER_OPTIONS

  structure Shell: SHELL
  structure ShellUtils : SHELL_UTILS
  structure TTYListener : TTY_LISTENER
  structure Ml_Debugger: ML_DEBUGGER
  structure Trace : TRACE
  structure ToolData : TOOL_DATA
  structure GuiUtils : GUI_UTILS
  structure Menus : MENUS
  structure DebuggerWindow : DEBUGGERWINDOW
  structure InspectorTool : INSPECTORTOOL
  structure ProfileTool : PROFILE_TOOL
  structure ErrorBrowser: ERROR_BROWSER

  sharing UserOptions.Options =
          Ml_Debugger.ValuePrinter.Options =
	  ShellUtils.Options =
    	  ToolData.ShellTypes.Options
  sharing Shell.Info = ShellUtils.Info

  sharing type ToolData.ShellTypes.user_options =
	       UserOptions.user_tool_options =
	       GuiUtils.user_tool_options = ShellUtils.UserOptions 
  sharing type GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
  sharing type Shell.Context = ShellUtils.Context =
               ToolData.ShellTypes.Context
  sharing type Shell.ShellData = ToolData.ShellTypes.ShellData
  sharing type Menus.Widget = DebuggerWindow.Widget = ToolData.Widget =
    	       GuiUtils.Widget = Capi.Widget = ProfileTool.Widget =
	       ErrorBrowser.Widget = InspectorTool.Widget
  sharing type TTYListener.ListenerArgs = ToolData.ShellTypes.ListenerArgs
  sharing type ErrorBrowser.location = ShellUtils.Info.Location.T
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ToolData = DebuggerWindow.ToolData = InspectorTool.ToolData
  sharing type Preferences.preferences = ToolData.ShellTypes.preferences =
	       Ml_Debugger.preferences = ShellUtils.preferences
  sharing type ShellUtils.user_context = GuiUtils.user_context
  sharing type ShellUtils.Type = GuiUtils.Type = InspectorTool.Type
  sharing type Preferences.user_preferences = ShellUtils.user_preferences =
	       ToolData.ShellTypes.user_preferences =
	       GuiUtils.user_preferences =
	       ProfileTool.user_preferences
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type Ml_Debugger.debugger_window = DebuggerWindow.debugger_window
  sharing type ErrorBrowser.error = Shell.Info.error
): LISTENER =
struct
  structure Info = ShellUtils.Info
  structure Location = Info.Location
  structure Options = ShellUtils.Options
  structure ShellTypes = ToolData.ShellTypes
  structure UserContext = ToolData.UserContext  
  structure IO = MLWorks.IO

  type ToolData = ToolData.ToolData

  val do_debug = false
  fun debug s = if do_debug then MLWorks.IO.output(IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then MLWorks.IO.output(IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = MLWorks.IO.output(IO.terminal_out,s ^ "\n")

  fun make_debugger_function (debugger_type,user_options,user_preferences,local_context) f x =
    Ml_Debugger.with_start_frame
    (fn base_frame =>
     (f x)
     handle
     exn as ShellTypes.DebuggerTrapped => raise exn
   |  exn as Shell.Exit _ => raise exn
   |  exn as MLWorks.Interrupt => raise exn
   |  exn as Info.Stop _ => raise exn
   |  exn as Capi.SubLoopTerminated => raise exn
   |  exn =>
        (Ml_Debugger.ml_debugger
         (debugger_type,
          ShellTypes.new_options
          (user_options,
           GuiUtils.get_user_context (!local_context)),
          Preferences.new_preferences user_preferences)
         (base_frame,
          Ml_Debugger.EXCEPTION exn,
          Ml_Debugger.POSSIBLE
          ("quit (return to listener)",
           Ml_Debugger.DO_RAISE ShellTypes.DebuggerTrapped),
          Ml_Debugger.NOT_POSSIBLE);
         raise ShellTypes.DebuggerTrapped))


  (* Some dull utilities *)

  val prompt = "MLWorks>"
  val prompt_len = size prompt
d789 5
a793 5
  fun strip_prompt (s:string):string = 
    if String.isPrefix prompt s then
      String.extract (s, prompt_len, NONE)
    else
      s
d795 43
a837 18
  exception NoLocation
  fun get_location line =
    let
      val sz = size line
      fun aux index =
        if index < sz
          then
            if String.sub (line,index) = #":" then
	      index+1
            else
              aux (index+1)
        else
          raise NoLocation
      (* skip up to second ":" *)
      val result = substring (* could raise Substring *)(line,0,(aux (aux 0))-1)
    in
      result
    end
d839 1
a839 40
  val listener_number = ref 1

  (* TEXT UTILITIES *)

  (* Most change functions should check that the change is allowable -- only motif *)
  (* will do this automatically *)
  
  fun get_current_line text =
    let
      val pos = Capi.Text.get_insertion_position text
    in
      Capi.Text.get_line (text, pos)
    end
        
  fun get_current_subline (text,start_pos) =
    let
      val (line,ix) = Capi.Text.get_line_and_index (text,start_pos)
      val line2 = strip_prompt line
      val ix2 = ix - (size line - size line2)
    in
      if ix2 > 0 then substring (* could raise Substring *) (line2,0,ix2) else ""
    end
          
  val (input_flag,input_string) = (ref false,ref "")

      val text_size = Capi.Text.text_size

      fun replace_current_input ((text,prompt_pos,write_pos),line) =
	if !input_flag then
	  ()
	else 
	  let 
            val length = Capi.Text.get_last_position text
	  in 
	    (* Capi.Text.replace doesn't always work properly for X, but
	       setting the whole string causes ridiculous amounts of flicker. *)
            Capi.Text.replace (text,!prompt_pos,length,line);
	    Capi.Text.set_insertion_position
	      (text, !prompt_pos + text_size line)
	  end
d841 4
a844 68
      fun start_of_line (text,prompt_pos,write_pos) () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.current_line (text,pos)
            else ppos
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end
          
      fun end_of_line (text,prompt_pos,write_pos) () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val new_pos =
            if pos < ppos
              then Capi.Text.end_line (text,pos)
            else Capi.Text.get_last_position text
        in
          Capi.Text.set_insertion_position (text,new_pos)
        end

      fun forward_char (text,prompt_pos,write_pos) () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
	  val end_line = Capi.Text.end_line (text, pos)

	  val new_pos =
	    if pos = last_pos orelse pos = last_pos - 1 then
	      last_pos
	    else if pos = end_line - 1 then
	      (* This case handles Windows \r\n. *)
	      pos + size Capi.terminator
	    else
	      pos + 1
        in
          Capi.Text.set_insertion_position (text, new_pos)
        end
          
      fun backward_char (text,prompt_pos,write_pos) () =
        let
          val pos = Capi.Text.get_insertion_position text
	  val end_line = Capi.Text.end_line (text, pos)
	  val last_pos = Capi.Text.get_last_position text
	  val term_size = size Capi.terminator

	  val new_pos =
	    if pos = 0 then
	      0
	    else if pos = last_pos then
	      if Capi.Text.substring (text, last_pos - term_size, term_size) =
	         Capi.terminator then
		pos - term_size
	      else
		pos - 1
	    else if pos = end_line then
	      (* This case handles Windows \r\n. *)
	      pos - term_size
	    else
	      pos - 1
        in
          Capi.Text.set_insertion_position (text, new_pos)
        end
          
      fun previous_line (text,prompt_pos,write_pos) () =
d846 2
a847 30
	  val pos = Capi.Text.get_insertion_position text
	  val start_line = Capi.Text.current_line (text, pos)
	  val end_line = Capi.Text.end_line (text, pos)

	  val column =
	    if pos = start_line then
	      0
	    else if pos = end_line then
	      (* This case handles Windows \r\n. *)
	      pos - start_line - (size Capi.terminator - 1)
	    else
	      pos - start_line

	  val prev_line =
	    if start_line = 0 then
	      0
	    else
	      Capi.Text.current_line (text, start_line - 1)

	  val length_prev_line = start_line - prev_line

	  (* If this is the first line, leave the insertion position
	     as it is.  This is Windows semantics, not Motif. *)
	  val new_pos =
	    if start_line = 0 then
	      pos
	    else if column > length_prev_line then
	      start_line - 1
	    else
	      prev_line + column
d849 5
a853 10
	  (*
	  MLWorks.IO.output
	    (MLWorks.IO.terminal_out,
	     "pos = " ^ Int.toString pos ^
	     " start_line = " ^ Int.toString start_line ^
	     " prev_line = " ^ Int.toString prev_line ^
	     " new_pos = " ^ Int.toString new_pos ^
	     "\n");
	  *)
	  Capi.Text.set_insertion_position (text, new_pos)
d855 57
a911 11

      fun next_line (text,prompt_pos,write_pos) () =
	let
	  val pos = Capi.Text.get_insertion_position text
	  val start_line = Capi.Text.current_line (text, pos)
	  val end_line = Capi.Text.end_line (text, pos)
	  
	  val column =
	    if pos = end_line then
	      (* This case handles Windows \r\n. *)
	      pos - start_line - (size Capi.terminator - 1)
d913 73
a985 54
	      pos - start_line

	  val last_pos = Capi.Text.get_last_position text

	  val end_next_line =
	    if last_pos = end_line then
	      last_pos
	    else
	      Capi.Text.end_line (text, end_line + 1)

	  val length_next_line = end_next_line - end_line

	  (* If this is the last line, leave the insertion position
	     as it is.  This is Windows semantics, not Motif. *)
	  val new_pos =
	    if last_pos = end_line then
	      pos
	    else if column >= length_next_line then
	      end_next_line
	    else
	      end_line + column + 1
	in
	  (*
	  MLWorks.IO.output
	    (MLWorks.IO.terminal_out,
	     "pos = " ^ Int.toString pos ^
	     " start_line = " ^ Int.toString start_line ^
	     " end_line = " ^ Int.toString end_line ^
	     " new_pos = " ^ Int.toString new_pos ^
	     "\n");
	  *)
	  Capi.Text.set_insertion_position (text, new_pos)
	end

      (* get_current_input gets the text between the start_position
	 and the end of the buffer.  When the input is for evaluation,
	 start_pos should be !prompt_pos.  When the input is to be
	 passed to std_in, start_pos should be !write_pos.
       *)
      fun get_current_input (text, start_pos, write_pos) =
        let
          val last_pos = Capi.Text.get_last_position text
          val input =
	    Capi.Text.substring (text, start_pos, last_pos - start_pos)
        in
	  if size input = 0 orelse
	    String.sub (input, size input - 1) <> #"\n" then
            (debug ("Inserting return at " ^ Int.toString last_pos);
            (* This is always after the prompt *)
            Capi.Text.insert (text, last_pos, "\n");
            write_pos := last_pos + text_size "\n";
            Capi.Text.set_insertion_position
	      (text, last_pos + text_size "\n");
	    input ^ "\n")
d987 53
a1039 6
	    (write_pos := last_pos;
	     input)
        end

      (* get_input_line gets input to evaluate or to pass to stdin, as
         appropriate.  In the former case, start_pos should be !prompt_pos;
d1042 71
a1112 71
      fun get_input_line (text, start_pos, write_pos) =
	let
          val last_pos = Capi.Text.get_last_position text
          val current_pos = Capi.Text.get_insertion_position text
	in
          if current_pos < start_pos then
	    let
	      val line =
		strip_prompt (Capi.Text.get_line (text, current_pos)) ^ "\n"
	    in
              (* last_pos always after the prompt *)
              Capi.Text.insert(text, last_pos, line);
              write_pos := last_pos + text_size line;
              Capi.Text.set_insertion_position
		(text, last_pos + text_size line);
              line
            end
	  else (* current_pos >= start_pos *)
	    get_current_input (text, start_pos, write_pos)
        end

      (* END TEXT UTILITIES *)

  (* The main function *)
  fun create external
	(tooldata as ToolData.TOOLDATA
	   {args,appdata,current_context,motif_context,tools}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options,
                                    user_preferences,
                                    prompter,
                                    mk_xinterface_fn,
                                    ...} = args

      val ToolData.APPLICATIONDATA {applicationShell,...} = appdata

      val full_menus =
	case user_preferences
	of Preferences.USER_PREFERENCES ({full_menus, ...}, _) =>
	  !full_menus

      val title =
        let
          val n = !listener_number
        in
          listener_number := n+1;
          "Listener #" ^ Int.toString n
        end

      val location_title = "<"^title^">"

      (*** Make the windows ***)
      val (shell,mainWindow,menuBar,contextLabel) =
        Capi.make_main_window ("listener",title,applicationShell,full_menus)

      val buttonPane =
        Capi.make_managed_widget ("buttonPane", Capi.RowColumn, mainWindow, []);

      (*** IO Functions ***)

      fun beep () = Capi.beep shell
      fun message_fun s = Capi.send_message (shell,s)

      val local_context = ref motif_context

      (*** Debugger Functions ***)

      (* This creates the debugger window when the listener is being created *)
      (* Strange things happen if done at debugger entry time *)
      val (run_debugger, clean_debugger) =
	DebuggerWindow.make_debugger_window
d1114 3
a1116 3

      val debugger_type = 
        Ml_Debugger.WINDOWING
d1120 3
a1122 3

      val debugger_function =
        make_debugger_function
d1124 46
a1169 46

      (* Profiler functions and values *)

      val profiler = 
	ProfileTool.create (applicationShell,user_preferences)

      val time_space_profile_manner =
	MLWorks.Profile.make_manner
	{time = true,
	 space = true,
	 calls = false,
	 copies = false,
	 depth = 0,
	 breakdown = []}

      val time_space_profile_options =
	MLWorks.Profile.Options {scan = 10,
			 selector = fn _ => time_space_profile_manner}

      (* This is a really dirty hack *)

      val profiling = ref false

      fun profile f a =
	let
	  val (r,p) =
	    MLWorks.Profile.profile time_space_profile_options f a
	in
	  (profiler p;
	   case r of
	     MLWorks.Profile.Result r => r
	   | MLWorks.Profile.Exception e => raise e)
	end

      fun profiling_debugger_function f a =
	if (!profiling) then
	  debugger_function (profile f) a
	else
	  debugger_function f a

      (* Options and contexts *)
      fun get_user_options () = user_options

      val shell_data = 
        ShellTypes.SHELL_DATA
        {get_user_context =
d1171 24
a1194 24
         user_options = user_options,
	 user_preferences = user_preferences,
         prompter = prompter,
         debugger = profiling_debugger_function,
	 profiler = profiler,
         exit_fn = fn n => raise Shell.Exit n,
         x_running = true,	(* Can't start X interface from an X listener *)
         mk_xinterface_fn = mk_xinterface_fn,
				(* for starting X from a saved image *)
         mk_tty_listener = TTYListener.listener
				(* for starting saved images *)
         }
      
      val quit_funs = ref []

      fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)

      (* Text stuff *)
      val (scroll,text) = (Capi.make_scrolled_text ("textIO",mainWindow,[]))

      val _ = Capi.transfer_focus (mainWindow,text)

      (* write_pos is the position new input should go in the buffer, usually
	 the end.  Also used as the position from which standard input is read. 
d1200 11
a1210 11

      val write_pos = ref 0
      val prompt_pos = ref 0

      fun modification_ok pos =
	(fdebug (fn () => "modification_ok: pos = " ^ Int.toString pos ^
			  ", prompt_pos = " ^ Int.toString (!prompt_pos));
	 not Capi.Text.read_only_before_prompt orelse pos >= !prompt_pos)

      fun modification_at_current_ok () = 
        modification_ok
d1213 72
a1284 72

      val text_info = (text,prompt_pos,write_pos)

      fun insert_at_current s =
        if modification_at_current_ok ()
          then Capi.Text.insert (text, Capi.Text.get_insertion_position text, s)
        else beep ()

      val buttons_update_fn_ref = ref (fn () => ())
      fun buttons_update_fn () = (!buttons_update_fn_ref) ()

      local 
        (* Insert at the current write_pos *)
        fun insert_text str =
          (* write_pos always after prompt_pos, so no check *)
          let
            val _ = Capi.Text.check_insertion (text,str,!write_pos,[write_pos,prompt_pos]);
            val old_pos = !write_pos
            val new_pos = old_pos + text_size str; 
          in
            Capi.Text.insert (text, old_pos, str);
            (* on motif, insert can call modifyVerify, which can diddle with write_pos *)
            (* so we need to only update it here *)
            write_pos := new_pos;
            Capi.Text.set_insertion_position (text, new_pos)
          end

        val inbuff as (posref,strref) = (ref 0,ref "")
            
        fun input_fun () =
          (input_flag := true;
	   buttons_update_fn ();
           Capi.event_loop input_flag;
           !input_string)

        fun refill_buff () =
          let val new_string = input_fun ()
          in
            posref := 0;
            strref := new_string
          end

	val eof_flag = ref false

        fun get_input n =
          let
            val string = !strref
            val pointer = !posref
            val len = size string
          in
            if !eof_flag then
              ""
            else if pointer + n > len then
              (refill_buff ();
               substring (* could raise Substring *) (string,pointer,len-pointer) ^
               get_input (n - len + pointer))
                 else
                   let val result = substring (* could raise Substring *) (string,pointer,n)
                   in
                     posref := (!posref + n);
                     result
                   end
          end

        fun do_lookahead () =
          (if !eof_flag then
             ""
          else if !posref >= size (!strref) then
             (refill_buff ();
              do_lookahead ())
               else 
                 substring (* could raise Substring *) (!strref, !posref, 1))
d1286 12
a1297 12
	fun close_in () = eof_flag := true
	fun closed_in () = !eof_flag
	fun clear_eof () = eof_flag := false

        val thisWindow = {output={descriptor=NONE,
                                  put= fn {buf,i,sz} =>
                                       let val els = case sz of
                                                    NONE=>size buf-i
                                                  | (SOME s)=> s
                                       in insert_text (substring (buf,i,els));
                                          els
                                       end,
d1302 117
a1418 117
                          error ={descriptor=NONE,
                                  put= fn {buf,i,sz} =>
                                       let val els = case sz of
                                                    NONE=>size buf-i
                                                  | (SOME s)=> s
                                       in insert_text (substring (buf,i,els));
                                          els
                                       end,
                                                  
                                  get_pos=NONE,
                                  set_pos=NONE,
                                  can_output=NONE,
                                  close=fn()=>()},
                          input ={descriptor=NONE,
                                  get=fn _ =>input_fun(),
                                  get_pos=SOME(fn()=> !posref),
                                  set_pos=SOME(fn i=>posref:=i),
                                  can_input=SOME(fn()=>
                                                 (!posref<size (!strref))),
                                  close=close_in}}

          (*NB, in the above, perhaps #input#get shouldn't ignore
            its argument...?  *)

      in
        fun inThisWindow () =
             MLWorks.Internal.StandardIO.redirectIO thisWindow

        val outstream = GuiUtils.make_outstream insert_text

        fun clear_input () =
	  (debug "Clearing input";
           posref := 0;
	   strref := "";
	   eof_flag := false)

        val instream = 
          IO.instream {input = get_input,
                       lookahead = do_lookahead,
                       end_of_stream = fn () => do_lookahead () = "",
                       clear_eof = clear_eof,
                       close_in = close_in,
                       closed_in = closed_in}

      end

      fun delete_current_line text_info _ =
        if modification_at_current_ok () then
	  replace_current_input (text_info,"")
	else
	  beep ()

      fun eof_or_delete (text,prompt_pos,write_pos) () =
        let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos = last_pos andalso pos = !write_pos then
            (debug "eof";
             if !input_flag then
               (MLWorks.IO.close_in instream;
		buttons_update_fn ();
                input_flag := false)
             else
               beep ())
          else
            if modification_ok pos then
	      Capi.Text.replace (text, pos, pos + 1, "")
            else beep ()
        end

      fun edit_error _ =
        (let
          (* Get a location string from the current line *)
          val line = get_current_line text
          val locstring = get_location line
          val quit_fun = 
            ShellUtils.edit_source
	      (locstring, ShellTypes.get_current_preferences shell_data)
         in
           quit_funs := quit_fun :: (!quit_funs)
        end 
      handle ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)
           | NoLocation => message_fun "Edit failed: no location info found"
           | Location.InvalidLocation => message_fun "Edit failed: no location info found")

      (* SYMBOL COMPLETION *)
      (* Necessary for popping down completion window *)
      local
        val actions_after_input = ref []
      in
        fun after_input _ =
          (Lists.iterate (fn f => f ()) (!actions_after_input);
           actions_after_input := [])
        fun add_after_input_action action =
          actions_after_input := action :: !actions_after_input
      end

      (* name completion *)
      fun do_completion start_pos =
        let
          (* The current line up to pos *)
          val subline = get_current_subline (text,start_pos)
          val use_completion_menu =
            let
              val preferences = ShellTypes.get_current_preferences shell_data
              val Preferences.PREFERENCES
		{environment_options =
                 Preferences.ENVIRONMENT_OPTIONS {completion_menu,...},
		 ...} =
                preferences
            in
              !completion_menu
            end
          val options = ShellTypes.get_current_options shell_data
          val (sofar,completions) = 
            ShellUtils.get_completions
d1421 26
a1446 23
		 (GuiUtils.get_user_context (!local_context)))

          fun insert_at (pos,str) =
            if modification_ok pos
              then 
                (Capi.Text.insert (text,pos,str);
                 Capi.Text.set_insertion_position (text, pos + text_size str))
            else beep ()

          fun insert_fun a =
            insert_at (start_pos,substring (* could raise Substring *) (a, size sofar, size a - size sofar))
        in
          case completions of
            [] => beep ()
          | [a] => insert_fun a
          | l => 
              let val c = ShellUtils.find_common_completion l 
              in
                if c = sofar then
                  if (use_completion_menu) then
                    let
                      val popdown =
                        Capi.list_select
d1450 15
a1464 15
                    in
                      Capi.set_focus text;
                      add_after_input_action popdown
                    end
                  else beep ()
                else insert_fun c
              end
        end

      val replace_current_input = fn s => replace_current_input (text_info,s)

      fun get_input_from_stdin () = 
        get_input_line (text, !write_pos, write_pos)

      (* get_input_to_evaluate first calls get_input_line; if the cursor
d1468 44
a1511 44
       *)
      fun get_input_to_evaluate () =
	(get_input_line (text, !prompt_pos, write_pos);
	 get_current_input (text, !prompt_pos, write_pos))

      val input_disabled = ref false

      fun with_input_disabled f =
        (input_disabled := true;
         let
           val result = f () handle exn => (input_disabled := false;raise exn)
         in
           input_disabled := false;
           result
         end)

      val flush_rest = ref false
      (* This function is called if a syntax error is detected in the input *)
      fun flush_stream () = flush_rest := true
      
      fun get_preferences () = ShellTypes.get_current_preferences shell_data

      fun use_error_browser () =
	case get_preferences ()
        of Preferences.PREFERENCES
             {environment_options =
                Preferences.ENVIRONMENT_OPTIONS {use_error_browser, ...},
              ...} =>
	  !use_error_browser

      val (handler'', make_prompt) =
	Shell.shell (shell_data,location_title,flush_stream)

      (* If using the error browser, we don't want the errors to be printed. *)
      fun handler' s =
	if use_error_browser () then
          let
            (* output warnings to std_out *)
            fun report_warnings (error as Info.ERROR (severity,location,_)) =
              if severity = Info.WARNING orelse Info.< (severity, Info.WARNING)
                then MLWorks.IO.output (outstream, Info.string_error error ^ "\n")
              else ()
          in
            Info.with_report_fun
d1516 24
a1539 3
          end
	else
	  handler'' (Info.make_default_options ()) s
d1541 15
a1555 36
      fun handler s =
        (inThisWindow();                 (*redirects PrimIO stdIO to gui*)
	(Capi.with_window_updates 	
	 (fn () => 
          (with_input_disabled
          (fn () =>
           IO.with_standard_error          (*redirects MLWorks.IO stdIO *)
           outstream
           (fn () => 
            IO.with_standard_output
            outstream
            (fn () =>
             IO.with_standard_input
             instream
             (fn () =>
              Ml_Debugger.with_debugger_type
              debugger_type
              (fn _ => 
               ShellTypes.with_toplevel_name location_title
               (fn _ => handler' s))))))))))

      fun time_handler x =
        let
          val start = MLWorks.Time.Elapsed.elapsed ()

          fun print_time () =
            let
              val elapsed = MLWorks.Time.Elapsed.elapsed_since start
            in
	      MLWorks.IO.output (outstream, MLWorks.Time.Elapsed.format elapsed ^ "\n");
              IO.flush_out outstream
            end

          val result =
	    handler x
            handle
d1557 9
a1565 9
        in
	  case result
	  of ([], _, Shell.OK _) => ()		(* Ignore uncompleted phrases *)
	  |  _ => print_time ();
          result
        end

      fun output_prompt () =
	(MLWorks.IO.output
d1567 20
a1586 20
         IO.flush_out outstream;
	 prompt_pos := !write_pos)

      fun force_prompt () =
        (MLWorks.IO.output (outstream,"\n");
         output_prompt ())

      fun set_context_state (motif_context) =
	case contextLabel of
          SOME w =>
            (local_context := motif_context;
             Capi.set_label_string (w,"Context: " ^ GuiUtils.get_context_name motif_context))
	| NONE => ()
              
      val _ = set_context_state motif_context

      fun set_state context = (set_context_state context; force_prompt ())

      val context_key =
	ToolData.add_context_fn
d1588 3
a1590 3

      val _ =
	quit_funs :=
d1593 4
a1596 4

      fun select_context motif_context =
        (set_state motif_context;
         ToolData.set_current
d1598 4
a1601 4

      val {update_history, prev_history, next_history, history_start,
	   history_end, history_menu} =
	GuiUtils.make_history
d1604 13
a1616 13

      fun finish_up str =
        (output_prompt ();
	 MLWorks.IO.output (outstream, str);
         IO.flush_out outstream;
	 buttons_update_fn ();
	 (* Clear waiting input from std_in. *)
	 clear_input ())

      (* For interface with inspector *)
      val do_select_fn = ref (fn () => ())

      (* str is the input string, loc is the location of the erroneous
d1620 5
a1624 5
      fun highlight (str, loc, b, offset) =
        let
          val (s_pos, e_pos) = Info.Location.extract (loc, str)
        in
          Capi.Text.set_highlight
d1629 1
a1629 1
        end
d1631 14
a1644 14

      fun error_handler
	    (error_list, redo_action, close_action, input, offset) =
        let
          fun edit_action location =
            if ShellUtils.editable location then
              {quit_fn = ShellUtils.edit_location (location, get_preferences()),
               clean_fn = fn () => ()}
            else
              (highlight (input, location, true, offset);
            {quit_fn = fn () => (),
             clean_fn = fn () => highlight (input, location, false, offset)})
        in
          ErrorBrowser.create
d1652 1
a1652 15
        end

      (* The evaluating flag disables GUI controls during an evaluation. *)
      val evaluating = ref false;

      local
	val error_browser_ref = ref NONE

	fun kill_error_browser () =
	  case !error_browser_ref
	  of NONE => ()
	  |  SOME f =>
	    (f ();
	     error_browser_ref := NONE)
      in
d1654 30
a1683 102
      fun do_evaluate time_it =
	let
	  val _ = kill_error_browser ()

          val input = get_input_to_evaluate ()
	  val _ = fdebug (fn () => "input: " ^ input);

	  val end_pos = !write_pos
	  val prev_capi_eval = !Capi.evaluating
	  val _ = evaluating := true
	  val _ = Capi.evaluating := true
	  val _ = buttons_update_fn ()

	  val result =
	    (if time_it then
	      time_handler (input, Shell.initial_state)
	    else
	      handler (input, Shell.initial_state))
	    handle exn => (evaluating := false;
			  Capi.evaluating := prev_capi_eval;
			  raise exn)

        in
	  evaluating := false;
	  Capi.evaluating := prev_capi_eval;
	  buttons_update_fn ();
	  clean_debugger ();
	  case result
	  of ([], str, Shell.OK _) => 
	    (* Nothing to do *)
	    ()
	  |  (_, _, Shell.TRIVIAL) => 
	    finish_up ""
	  |  (l, str, Shell.INTERRUPT) => 
	    (update_history l;
	     case l of
	       [] => ()
	     | _ => (!do_select_fn) ();
	     MLWorks.IO.output (outstream, "Interrupt\n");
             IO.flush_out outstream;
	     finish_up str)
	  |  (l, str, Shell.DEBUGGER_TRAPPED) => 
	    (update_history l;
	     case l of
	       [] => ()
	     | _ => (!do_select_fn) ();
	     finish_up str)
	  |  (l, str, Shell.OK _) => 
	    (* OK *)
	    (update_history l;
             (!do_select_fn) ();
	     finish_up str)
	  |  (l, str, Shell.ERROR (_, error_list)) =>
	    (* Error *)
	    (update_history l;
	     case l of
	       [] => ()
	     | _ => (!do_select_fn) ();
	     if use_error_browser () then
	       let
	         (* If any topdecs have been successfully evaluated, then
		    the code below will output a new prompt followed by
		    the remainder of the input.  Any highlighting must
		    be relative to the remaining input, so we have to
		    adjust the location information by the amount of
		    code that we have removed. *)
		 val offset = Lists.reducel (fn (i, s) => i + size s) (0, l)

		 fun print_error () =
		   case rev error_list
		   of [] => ()
		   |  (err::_) => 
	             MLWorks.IO.output
		       (outstream, ErrorBrowser.error_to_string err ^ "\n")
	       in
		 (* If the evaluation has caused anything to be written,
		    then output a new prompt, with the offending input
		    after.  This means that the input to be evaluated
		    is always at the end of the Widget.
		    
		    If users close the error browser in this situation,
		    they are left with the current input at the prompt.
		    Deleting the current input gives the cleanest record
		    of activity, but users may have started to edit the
		    input.  Another alternative is to output a new prompt,
		    but that looks weird.
		    *)
		 if end_pos <> !write_pos then
		   (print_error ();
	            finish_up str;
		    error_browser_ref :=
		      SOME
	                (error_handler
		           (error_list,
		            fn () =>
			      do_evaluate time_it,
		            fn () =>
	                      (update_history [str];
	 		       buttons_update_fn ();
	 		       clear_input ()),
		            input,
		            offset)))
d1685 105
a1789 16
		   error_browser_ref :=
		     SOME
	               (error_handler
		          (error_list,
		           fn () =>
			     do_evaluate time_it,
		           fn () =>
	                     (update_history [str];
			      print_error ();
		              finish_up ""),
		           input,
		           offset))
	       end
	     else
	       (update_history [str];
		finish_up ""))
a1790 3
	handle
	  Shell.Exit _ => Capi.destroy shell
      end
d1792 26
a1817 26
      fun do_return () =
        if !input_flag then
	  let
            val input = get_input_from_stdin ()
          in
            (input_string := input;
	     buttons_update_fn ();
             input_flag := false)
	  end
        else if !input_disabled then
	  beep ()
        else
	  do_evaluate false

      (* More text stuff *)
      (* A flag to indicate whether escape has just been pressed *)
      val escape_pressed = ref false

      fun do_escape () = escape_pressed := true

(*
      fun check_copy_selection _ = 
        Capi.Text.copy_selection text

      fun check_paste_selection _ =
        if modification_at_current_ok ()
d1832 71
a1902 3
      (* These ones attempt to use the capi clipboard *)
      fun check_copy_selection _ = 
        Capi.clipboard_set (text,Capi.Text.get_selection text)
d1904 9
a1912 9
      fun check_paste_selection _ =
        if modification_at_current_ok ()
          then
            Capi.clipboard_get (text,
                                fn s =>
                                Capi.Text.insert (text,
                                                  Capi.Text.get_insertion_position text,
                                                  s))
        else beep ()
d1914 2
a1915 10
      fun check_cut_selection _ =
        if modification_at_current_ok ()
          then
            let
              val s = Capi.Text.get_selection text
            in
              Capi.Text.delete_selection text;
              Capi.clipboard_set (text,s)
            end
        else beep ()
d1917 19
a1935 4
      fun check_delete_selection _ =
        if modification_at_current_ok ()
          then Capi.Text.delete_selection text
        else beep ()
d1937 8
a1944 83
      fun abandon (text, prompt_pos, write_pos) () =
        (update_history [get_current_input (text, !prompt_pos, write_pos)];
         finish_up "")

      val meta_bindings =
        [("p", prev_history),
         ("n", next_history)]

      fun delete_to_end () =
        let
          val ppos = !prompt_pos
          val pos = Capi.Text.get_insertion_position text
          val end_pos =
            if pos < ppos
              then Capi.Text.end_line (text,pos)
            else Capi.Text.get_last_position text
        in
	  if modification_ok pos then
            (Capi.Text.set_selection (text,pos,end_pos);
             check_cut_selection ())
	  else
	    beep ()
        end
          
      val normal_bindings =
        [("\^A", start_of_line text_info),
         ("\^B", backward_char text_info),
         ("\^D", eof_or_delete text_info),
         ("\^E", end_of_line text_info),
         ("\^F", forward_char text_info),
         ("\^G", abandon text_info),
	 ("\^K", delete_to_end),
         ("\^N", next_line text_info),
	 ("\^O", fn _ => insert_at_current "\n"),
         ("\^P", previous_line text_info),
         ("\^U", delete_current_line text_info),
         ("\^W", check_cut_selection),
         ("\^Y", check_paste_selection),
         ("\t" , fn _ => do_completion (Capi.Text.get_insertion_position text)),
         ("\r" , do_return),
         ("\027", do_escape)]

      fun despatch_key bindings key =
        let
          fun loop [] = false
            | loop ((key',action)::rest) =
              if key = key' then (action (); true)
              else loop rest
        in
          loop bindings
        end

      val despatch_meta = despatch_key meta_bindings
      val despatch_normal = despatch_key normal_bindings

      (* This part needs to be sorted out and bits moved into capi *)
      (* This is only used for Motif *)
      fun do_insert_text ((text,prompt_pos,write_pos),start_pos,end_pos,str) =
        (fdebug (fn _ =>
                 "Verify: start_pos is " ^ Int.toString start_pos ^
                 ", end_pos is " ^ Int.toString end_pos ^
                 ", write_pos is " ^ Int.toString (!write_pos) ^
                 ", prompt_pos is " ^ Int.toString (!prompt_pos) ^
                 ", string is '" ^ str ^ "'");
        if end_pos < !write_pos 
          then write_pos := (!write_pos) - end_pos + start_pos + text_size str
        else if start_pos < !write_pos then
          write_pos := start_pos + text_size str
	else ();
        if end_pos < !prompt_pos
          then prompt_pos := (!prompt_pos) - end_pos + start_pos + text_size str
        else if start_pos < !prompt_pos 
          then prompt_pos := start_pos + text_size str
        else ())

      fun modifyVerify (start_pos,end_pos,str,set_fn) =
        let
          val _ = after_input ()
        in
          if !escape_pressed andalso size str = 1 
            then 
              (escape_pressed := false;
               set_fn false;
d1946 46
a1991 5
               ())
          else if not Capi.Text.read_only_before_prompt orelse
		  start_pos >= !prompt_pos then
            (do_insert_text (text_info,start_pos,end_pos,str);
             set_fn true)
d1993 22
a2014 63
	    (beep ();
	     set_fn false)
        end

      fun bad_key key =
	not (("\000" <= key andalso key <= "\007") orelse
	     ("\009" <= key andalso key <= "\031")) andalso
        Capi.Text.read_only_before_prompt andalso
        let
          val pos = if key = "\008" then !prompt_pos+1 else !prompt_pos
        in
          Capi.Text.get_insertion_position text < pos
        end

      (* The checking for bad_key etc. is for the benefit of Windows *)
      (* This code is only called for the keys with activate actions in Motif *)
      fun text_handler (key,modifiers) =
        (debug ("Text handler: " ^ MLWorks.String.ml_string (key,100));
         after_input ();
         if bad_key key then
	   (beep (); true)
         else if !escape_pressed then 
           (* handle escape characters first *)
           (escape_pressed := false; despatch_meta key)
         else if Lists.member (Capi.Event.meta_modifier, modifiers) then
	   despatch_meta key
         else
	   despatch_normal key)

      fun mk_tooldata () =
	ToolData.TOOLDATA {args = ShellTypes.get_listener_args shell_data,
                           appdata = appdata,
			   current_context = current_context,
			   motif_context = !local_context,
                           tools = tools}

      fun close_window _ =
	if not (!evaluating) then
          (do_quit_funs ();
           Capi.destroy shell)
	else
	  ()

      fun get_user_context () = GuiUtils.get_user_context (!local_context)

      fun get_value () = 
        let
          val user_context = get_user_context ()
        in
          ShellUtils.value_from_user_context (user_context,user_options)
        end

      val inspect_fn = InspectorTool.inspect_value (shell,false,mk_tooldata())

      val _ =
        do_select_fn :=
        (fn () => 
         case get_value () of
           SOME x => inspect_fn true x
         | _ => ())

      val searchButtonSpec =
	GuiUtils.search_button
d2016 3
a2018 3

      val value_menu =
	GuiUtils.value_menu
d2024 7
a2030 7

      val view_options =
	GuiUtils.view_options
	{parent = shell, title = title, user_options = user_options,
	 user_preferences = user_preferences,
	 caller_update_fn = fn _ => (),
	 view_type =
d2034 22
a2055 22

      datatype file_action =
	LOAD_SOURCE | LOAD | COMPILE | COMPILE_AND_LOAD | USE

      fun action_string LOAD_SOURCE = "Shell.File.loadSource"
      |   action_string LOAD = "Shell.File.loadObject"
      |   action_string COMPILE = "Shell.File.compile"
      |   action_string COMPILE_AND_LOAD = "Shell.File.compileAndLoad"
      |   action_string USE = "use"

      fun file_action fileExtension action _ =
        case Capi.open_file_dialog (shell, fileExtension)
        of NONE => ()
        |  SOME s => 
	  (replace_current_input (action_string action);
	   insert_at_current (" \"" ^ MLWorks.String.ml_string (s, ~1) ^ "\";");
	   do_evaluate false)

      val sourceFileAction = file_action ".sml"

      val file_menu =
        Menus.CASCADE
d2058 3
a2060 3
	      ("load_source_file",
               sourceFileAction LOAD_SOURCE,
               fn _ => not (!evaluating)),
d2062 3
a2064 3
	      ("load_file",
	       file_action ".mo" LOAD,
	       fn _ => not (!evaluating)),
d2066 3
a2068 3
	      ("compile_file",
	       sourceFileAction COMPILE,
	       fn _ => not (!evaluating)),
d2070 3
a2072 3
	      ("compile_and_load_file",
               sourceFileAction COMPILE_AND_LOAD,
               fn _ => not (!evaluating)),
d2075 3
a2077 3
	      ("use",
	       sourceFileAction USE,
	       fn _ => not (!evaluating)),
d2080 7
a2086 7
              ("save",
               fn _ =>
                 GuiUtils.save_history
                   (false, get_user_context (), applicationShell),
               fn _ =>
                 not (UserContext.null_history (get_user_context ()))
                      andalso UserContext.saved_name_set (get_user_context ())),
d2088 6
a2093 6
              ("saveAs",
               fn _ =>
                 GuiUtils.save_history
                   (true, get_user_context (), applicationShell),
               fn _ =>
                 not (UserContext.null_history (get_user_context ()))),
d2096 1
a2096 1
              ("close", close_window, fn _ => not (!evaluating))],
d2098 10
a2107 10
	
      fun get_current_user_context () =
        GuiUtils.get_user_context (!local_context)

      fun get_user_context_options () =
        ToolData.UserContext.get_user_options (get_current_user_context ())

      val menuspec =
	[file_menu,
         ToolData.edit_menu
d2116 4
a2119 4
         Menus.CASCADE ("view", view_options, fn () => true),
         value_menu]
	@@ (if full_menus then
             [GuiUtils.context_menu
d2126 3
a2128 3
	   else
	     [])
	@@ [GuiUtils.setup_menu
d2131 73
a2203 73
	   ToolData.tools_menu (mk_tooldata, get_current_user_context),
	   history_menu,
           ToolData.windows_menu ()]
	     

      val {update, ...} =
        Menus.make_buttons
        (buttonPane,
         [Menus.PUSH ("evaluateButton",
                      fn _ => (Capi.set_focus text;
		      	       do_evaluate false),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("stepButton",
                      fn _ => (Trace.set_stepping true;
                               Capi.set_focus text;
			       do_evaluate false;
                               Trace.set_stepping false),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("timeButton",
                      fn _ => (Capi.set_focus text;
		      	       do_evaluate true),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("profileButton",
                      fn _ => (profiling := true;
                               Capi.set_focus text;
			       do_evaluate false;
			       profiling := false),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("clearButton",
                      fn _ => (delete_current_line text_info ();
                               Capi.set_focus text),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("clearAllButton",
                      fn _ => (prompt_pos := 0;
                               write_pos := 0;
		       	       Capi.Text.set_string (text, "");
			       finish_up "";
                               Capi.set_focus text),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("abandonButton",
		      fn _ => (abandon text_info ();
                               Capi.set_focus text),
                      fn _ => not (!evaluating)),
          Menus.PUSH ("prevButton",
                      fn _ => (prev_history ();
                               Capi.set_focus text),
                      fn _ => not (!evaluating) andalso not (history_start ())),
          Menus.PUSH ("nextButton",
                      fn _ => (next_history ();
                               Capi.set_focus text),
                      fn _ => not (!evaluating) andalso not (history_end ()))]);
    in
      buttons_update_fn_ref := update;
      Menus.make_submenus (menuBar,menuspec);
      Capi.Layout.lay_out
      (mainWindow,
       [Capi.Layout.MENUBAR menuBar] @@
       (case contextLabel of
          SOME w => [Capi.Layout.FIXED w]
        | _ => [Capi.Layout.SPACE]) @@
       [Capi.Layout.FLEX scroll,
	Capi.Layout.SPACE,
	Capi.Layout.FIXED buttonPane,
        Capi.Layout.SPACE]);
      Capi.Text.add_handler (text, text_handler);
      Capi.Text.add_modify_verify (text, modifyVerify);
      Capi.set_close_callback(mainWindow, close_window);
      Capi.Callback.add (shell, Capi.Callback.Destroy,do_quit_funs);
      Capi.initialize_toplevel shell;
      buttons_update_fn ();
      output_prompt ()
    end
end;
@


1.83.1.1
log
@branched from 1.83
@
text
@a4 4
 * Revision 1.83  1996/11/06  11:16:15  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.83.1.1.1.1
log
@branched from 1.83.1.1
@
text
@a4 3
 * Revision 1.83.1.1  1996/11/14  12:46:23  hope
 * branched from 1.83
 *
@


1.82
log
@Enabling close from control box on top left of window.
@
text
@d5 3
d652 1
a652 1
require "^.basis.__integer";
@


1.81
log
@Add interrupt button on Windows.
@
text
@d5 3
d1666 1
d1668 1
d1672 1
a1672 1
	    if time_it then
d1675 5
a1679 1
	      handler (input, Shell.initial_state)
d1682 1
d2187 1
@


1.80
log
@[Bug #1614]
remove use of Substring
@
text
@d5 4
d1509 3
a1511 7
        (with_input_disabled
        (fn () =>
         IO.with_standard_error          (*redirects MLWorks.IO stdIO *)
         outstream
         (fn () => 
          IO.with_standard_output
          outstream
d1513 14
a1526 8
           IO.with_standard_input
           instream
           (fn () =>
            Ml_Debugger.with_debugger_type
            debugger_type
            (fn _ => 
             ShellTypes.with_toplevel_name location_title
             (fn _ => handler' s))))))))
@


1.79
log
@Remove references to basis.toplevel
@
text
@d5 3
d588 1
a588 1
 *  Changed ordof and MLWorks.String.ordof to String.ordof
d642 2
a643 1
require "../basis/__integer";
d646 2
a647 2
require "../utils/lists";
require "../utils/crash";
d660 2
a661 2
require "../main/preferences";
require "../main/user_options";
d664 5
a668 5
require "../interpreter/shell";
require "../interpreter/shell_utils";
require "../interpreter/tty_listener";
require "../debugger/ml_debugger";
require "../debugger/newtrace";
d773 8
a780 13
  fun strip_prompt(string) =
    let
      val prompt = "MLWorks>"
      val prompt_len = size prompt
    in
      if MLWorks.String.substring (string, 0, prompt_len) = prompt then
	MLWorks.String.substring
	  (string, prompt_len, size string - prompt_len)
      else
	string
    end
    handle
      MLWorks.String.Substring => string
d789 2
a790 2
            if String.ordof(line,index) = String.ord ":"
              then index+1
d796 1
a796 1
      val result = String.substring(line,0,(aux (aux 0))-1)
d821 1
a821 1
      if ix2 > 0 then String.substring (line2,0,ix2) else ""
d1011 1
a1011 1
	     String.substring (input, size input - 1, 1) <> "\n" then
d1253 1
a1253 1
               String.substring (string,pointer,len-pointer) ^
d1256 1
a1256 1
                   let val result = String.substring (string,pointer,n)
d1270 1
a1270 1
                 String.substring (!strref, !posref, 1))
d1417 1
a1417 1
            insert_at (start_pos,String.substring (a, size sofar, size a - size sofar))
d1943 1
a1943 1
        (debug ("Text handler: " ^ String.ml_string (key,100));
@


1.78
log
@[Bug #1517]
Bound abandon to Ctrl-G.
@
text
@d5 4
a639 1
require "../basis/toplevel";
@


1.78.3.1
log
@branched from 1.78
@
text
@a4 4
 * Revision 1.78  1996/08/07  12:25:23  daveb
 * [Bug #1517]
 * Bound abandon to Ctrl-G.
 *
@


1.78.2.1
log
@branched from 1.78
@
text
@a4 4
 * Revision 1.78  1996/08/07  12:25:23  daveb
 * [Bug #1517]
 * Bound abandon to Ctrl-G.
 *
@


1.78.1.1
log
@branched from 1.78
@
text
@a4 4
 * Revision 1.78  1996/08/07  12:25:23  daveb
 * [Bug #1517]
 * Bound abandon to Ctrl-G.
 *
@


1.77
log
@[Bug #1517]
Added functions for moving forward or backward by a character or line.
@
text
@d5 4
d1864 1
d1869 1
a1871 1
         ("\^U", delete_current_line text_info),
@


1.76
log
@[Bug #1507]
Replaced existing handlers for Shell.Exit with a single one in do_evaluate.
@
text
@d5 4
a835 3
      fun delete_current_line text_info =
        fn _ => replace_current_input (text_info,"")

d859 18
d878 115
d1080 1
a1080 1
      (*** IO functions ***)
d1082 1
a1082 1
      fun beep _ = Capi.beep shell
d1328 6
d1830 4
d1836 1
a1836 2
         ("n", next_history),
         ("w", check_copy_selection)]
d1847 5
a1851 2
          Capi.Text.set_selection (text,pos,end_pos);
          check_cut_selection ()
a1853 4
      fun abandon (text, prompt_pos, write_pos) () =
        (update_history [get_current_input (text, !prompt_pos, write_pos)];
         finish_up "")

d1856 1
a1856 1
         ("\^C", abandon text_info),
d1859 1
d1861 1
d1863 1
d1868 2
a1869 2
         ("\013",do_return),
         ("\027",do_escape)]
d1923 3
a1925 4
      (* This function has no place in "platform independent" code *)
      fun bad_key "\n" = false
        | bad_key "\013" = false
        | bad_key key =
a1927 1
          (* val _ = output (std_out,"Key is " ^ String.ml_string (key,100) ^ "\n") *)
d1945 2
a1946 1
         else despatch_normal key)
@


1.75
log
@[Bug #1299]
Preserved remaining source after a runtime error.
@
text
@d5 4
d1591 1
a1591 2
			      do_evaluate time_it
			      handle Shell.Exit _ => Capi.destroy shell,
d1604 1
a1604 2
			     do_evaluate time_it
			     handle Shell.Exit _ => Capi.destroy shell,
d1616 2
a1776 1
	handle Shell.Exit _ => Capi.destroy shell
a1802 1
        handle Shell.Exit _ => (Capi.destroy shell; true)
@


1.74
log
@[Bug #1478]
Disabled Close menu item during evaluations.
@
text
@d5 4
d1532 1
a1532 1
	     finish_up "")
d1538 1
a1538 1
	     finish_up "")
@


1.73
log
@propagating changes made to the GUI standard IO redirection mechanism
(see __pervasive_library.sml for the StandardIO structure)
@
text
@d5 4
d1481 3
a1496 1
	  val _ = buttons_update_fn ()
d1503 3
d1512 1
d1806 5
a1810 2
        (do_quit_funs ();
         Capi.destroy shell)
d1874 16
a1889 8
           [Menus.PUSH ("load_source_file",
                         sourceFileAction LOAD_SOURCE,
                         fn _ => true),
            Menus.PUSH ("load_file", file_action ".mo" LOAD, fn _ => true),
            Menus.PUSH ("compile_file", sourceFileAction COMPILE, fn _ => true),
            Menus.PUSH ("compile_and_load_file",
                         sourceFileAction COMPILE_AND_LOAD,
                         fn _ => true),
d1891 4
a1894 1
            Menus.PUSH ("use", sourceFileAction USE, fn _ => true),
d1913 1
a1913 1
              ("close", close_window, fn _ => true)],
d1959 1
a1959 1
                      fn _ => not (!input_flag)),
d1965 1
a1965 1
                      fn _ => not (!input_flag)),
d1969 1
a1969 1
                      fn _ => not (!input_flag)),
d1975 1
a1975 1
                      fn _ => not (!input_flag)),
d1979 1
a1979 1
                      fn _ => not (!input_flag)),
d1986 1
a1986 1
                      fn _ => not (!input_flag)),
d1990 1
a1990 1
                      fn _ => not (!input_flag)),
d1994 1
a1994 1
                      fn _ => not (!input_flag) andalso not (history_start ())),
d1998 1
a1998 1
                      fn _ => not (!input_flag) andalso not (history_end ()))]);
@


1.72
log
@Redirecting standard IO through GuiStandardIO in pervasive library.
@
text
@d5 3
d1124 36
a1159 5
        val thisWindow = {output_fun=insert_text,
                          input_fun=input_fun,
                          eof_flag=eof_flag,
                          buffer_pos=posref,
                          buffer_data=strref}
d1162 1
a1162 1
             MLWorks.Internal.GuiStandardIO.setCurrentWindow thisWindow
@


1.71
log
@Made button buttons have different names from menu buttons, so that
Windows can distinguish between them, and so let us put mnemonics on
the menu items but not the buttons.
@
text
@d5 5
d1120 6
d1127 3
d1312 2
a1313 1
        with_input_disabled
d1315 1
a1315 1
         IO.with_standard_error
d1328 1
a1328 1
             (fn _ => handler' s))))))
@


1.70
log
@Fix #1429 - change the Load Objects dialog to use .mo instead of .sml
@
text
@d5 3
d1883 1
a1883 1
         [Menus.PUSH ("evaluate",
d1887 1
a1887 1
          Menus.PUSH ("step",
d1893 1
a1893 1
          Menus.PUSH ("time",
d1897 1
a1897 1
          Menus.PUSH ("profile",
d1903 1
a1903 1
          Menus.PUSH ("clear",
d1907 1
a1907 1
          Menus.PUSH ("clear_all",
d1914 1
a1914 1
          Menus.PUSH ("abandon",
d1918 1
a1918 1
          Menus.PUSH ("prev",
d1922 1
a1922 1
          Menus.PUSH ("next",
@


1.69
log
@Bug 1356: Made file_action call MLWorks.String.ml_string, so that backslashes
are correctly escaped.
@
text
@d5 4
d1796 2
a1797 2
      fun file_action action _ =
        case Capi.open_file_dialog (shell, ".sml")
d1804 2
d1810 1
a1810 1
                         file_action LOAD_SOURCE,
d1812 2
a1813 2
            Menus.PUSH ("load_file", file_action LOAD, fn _ => true),
            Menus.PUSH ("compile_file", file_action COMPILE, fn _ => true),
d1815 1
a1815 1
                         file_action COMPILE_AND_LOAD,
d1818 1
a1818 1
            Menus.PUSH ("use", file_action USE, fn _ => true),
@


1.68
log
@Added Step button.
@
text
@d5 3
d1797 1
a1797 1
	   insert_at_current (" \"" ^ s ^ "\";");
@


1.67
log
@Add profiler button and rearrange buttons.
@
text
@d5 3
d623 1
d642 1
d1875 6
d1882 2
a1883 2
                      fn _ => (do_evaluate true;
                               Capi.set_focus text),
d1887 1
d1889 1
a1889 2
			       profiling := false;
                               Capi.set_focus text),
@


1.66
log
@Bug 1074: Capi.list_select now takes a function to be called on any key
press handled by the list widget itself.  In the listener, this pops the
completions widget down as if the key had been typed at the listener.
@
text
@d5 5
d936 2
d941 34
d985 1
a985 1
         debugger = debugger_function,
d1870 10
a1883 4
          Menus.PUSH ("abandon",
		      fn _ => (abandon text_info ();
                               Capi.set_focus text),
                      fn _ => not (!input_flag)),
d1891 4
d1902 1
a1902 6
                      fn _ => not (!input_flag) andalso not (history_end ())),
          Menus.PUSH ("time",
                      fn _ => (do_evaluate true;
                               Capi.set_focus text),
                      fn _ => not (!input_flag))]);

@


1.65
log
@The Interrupt exception is no longer at top level.
@
text
@d5 3
d1168 2
a1169 1
                          (shell, "completions")
@


1.64
log
@Fixed bug with clear_all.  The prompt_pos needs to be set before the
contents of the text widget, or else the modification is disallowed by
the modication_ok function.
@
text
@d5 5
d694 1
a694 1
   |  exn as Interrupt => raise exn
d1163 4
a1166 3
                      val popdown = Capi.list_select
			            (shell,"completions")
                                    (l,insert_fun, fn x => x)
@


1.63
log
@DebuggerWindow.make_debugger_window now returns a clean-up function to call
at the end of each evaluation.
@
text
@d5 4
d1828 1
a1828 2
                      fn _ => (Capi.Text.set_string (text, "");
                               prompt_pos := 0;
d1830 1
@


1.62
log
@The extension passed to open_file_dialog does not need a preceding * .
@
text
@d5 3
d905 4
d911 1
a911 1
	  (DebuggerWindow.make_debugger_window (shell, title ^ " Debugger", tooldata),
d916 2
a917 1
        make_debugger_function (debugger_type,user_options,user_preferences,local_context)
d1385 1
@


1.61
log
@Removed Path menu.
@
text
@d5 3
d1721 1
a1721 1
        case Capi.open_file_dialog (shell, "*.sml")
@


1.60
log
@Type of GuiUtils.view_option has changed.
@
text
@d5 3
a1790 1
           GuiUtils.paths_menu mainWindow,
@


1.59
log
@Added "Abandon" command.
@
text
@d5 3
d1700 4
a1703 1
	 view_type = GuiUtils.VIEW_ALL}
@


1.58
log
@Moved Find to the Edit menu.
@
text
@d5 3
d1553 4
d1559 1
d1797 4
@


1.57
log
@Added Preferences and Paths menus.
@
text
@d5 3
d1682 1
a1682 1
	   tail = [searchButtonSpec]}
d1758 1
a1758 1
	     tail = [Menus.PUSH ("edit_error", edit_error, fn _ => true)]}),
@


1.56
log
@Improved behaviour of error browser when the evaluation has written some
output to the text widget.
@
text
@d5 4
d1739 6
d1768 5
a1772 2
	@@ [ToolData.tools_menu
             (mk_tooldata, fn () => GuiUtils.get_user_context (!local_context)),
@


1.55
log
@Added File menu.
@
text
@d5 3
d1242 2
a1243 6
	(*
        (output
	   (outstream,
	    make_prompt (GuiUtils.get_context_name (!local_context)));
	*)
	(MLWorks.IO.output (outstream, make_prompt ("MLWorks", Shell.initial_state));
d1309 2
a1310 2
      fun error_handler ((_, error_list),
                         redo_action, str, input, offset) =
d1327 1
a1327 8
	     close_action =
	       fn () =>
	         (update_history [str];
		  case error_list of
		    hd :: _ =>
	              MLWorks.IO.output (outstream, ErrorBrowser.error_to_string hd ^ "\n")
		  | [] => ();
		  finish_up ""),
d1383 1
a1383 1
	  |  (l, str, Shell.ERROR x) =>
d1398 7
d1409 9
a1417 1
		    is always at the end of the Widget. *)
d1419 15
a1433 1
	           finish_up str
d1435 13
a1447 9
		   ();
		 error_browser_ref :=
		   SOME
	             (error_handler
		        (x,
		         fn () => do_evaluate time_it handle Shell.Exit _ => Capi.destroy shell,
		         str,
		         input,
		         offset))
@


1.54
log
@Handle Shell.Exit in error browser redo function
@
text
@d5 3
d1622 2
d1626 1
a1626 1
          val user_context = GuiUtils.get_user_context (!local_context)
d1658 51
d1711 1
a1711 4
	[ToolData.works_menu
         (mk_tooldata, close_window,
          fn _ => not (!input_flag),
          fn () => GuiUtils.get_user_context (!local_context)),
d1733 3
a1735 1
	@@ [history_menu,
@


1.53
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d5 3
d1416 1
a1416 1
		         fn () => do_evaluate time_it,
@


1.52
log
@Made copying of lines detect our current prompt better.
@
text
@d5 3
d1662 1
@


1.51
log
@Evaluation of lines copied from before the prompt was broken: the copied
line is now appended to any existing input.
The buttons are disabled while the listener is reading from std_in.
@
text
@d5 5
d671 1
a671 1
  (* this should just look for a "prompt character" eg. a ">". *)
a672 21
    let val chars = String.explode string
      fun strip [] = chars
        | strip (">"::(l as ">" :: _)) = strip l
        | strip (">":: " " :: l) = l
        | strip (">":: l) = l
        | strip (_::l) = strip l
    in
      String.implode (strip chars)
    end
  
  (*
  fun whitespacep x =
    case x of
      " " => true
    | "\n" => true
    | "\t" => true
    | "\012" => true
    | "\013" => true
    | _ => false
        
  fun strip_whitespace s =
d674 2
a675 3
      fun strip [] = []
        | strip (l as (a::b)) =
          if whitespacep a then strip b else l
d677 5
a681 1
      String.implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
d683 3
a685 2
  *)
  
d924 3
a926 1
	not Capi.Text.read_only_before_prompt orelse pos >= !prompt_pos
d1565 2
a1566 1
          else
d1569 3
@


1.50
log
@The error browser now returns a quit function.  Use this to make the
evaluate command kill any existing error browser.
@
text
@d5 4
a741 50
(*
      val (outstream,instream,clear_input) =
        if external
          then
            let
              val home = "/usr/users/matthew"
              val server_socket_name = ".my_socket"
              val s = MLWorks.OS.Unix.socket (1, 1, 0)
              val _ = MLWorks.OS.Unix.connect (s, MLWorks.OS.Unix.SOCKADDR_UNIX "/usr/users/matthew/my-server")
              val outstream = 
                MLWorks.IO.outstream {output = fn str => (MLWorks.OS.Unix.write (s,str);()),
                                      flush_out = fn _ => (),
                                      close_out = fn () => (),
                                      closed_out = fn () => false}
              fun env s = MLWorks.Internal.Value.cast (MLWorks.Internal.Runtime.environment s)

              val set_handler : (unit -> unit) -> unit = env "x register handler";

              fun readln s =
                let
                  fun aux acc =
                    let
                      val char = input(s,1)
                    in
                      case char of
                        "" => acc
                      | "\n" => "\n" :: acc
                      | s => aux (s :: acc)
                    end
                in
                  String.implode (rev (aux []))
                end

              fun getinput () =
                let
                  val str = open_in "/tmp/1234"
                  val line = readln str
                in
                  close_in str;
                  line
                end
              fun do_return () =
                do_line (getinput ())

              val _ = set_handler do_return;
            in
              (outstream)
            end
*)

d745 12
a756 8
	let 
          val length = Capi.Text.get_last_position text
	in 
	  (* Capi.Text.replace doesn't always work properly for X. *)
          (* But setting the whole string causes ridiculous amounts of flicker. *)
          Capi.Text.replace (text,!prompt_pos,length,line);
	  Capi.Text.set_insertion_position (text, !prompt_pos + text_size line)
	end
d785 30
a814 4
      (* This function gets input to evaluate or to pass to stdin, as *)
      (* appropriate.  In the former case, start_pos should be !prompt_pos; *)
      (* in the latter case, start_pos should be !write_pos. *)
      fun get_input (text, start_pos, write_pos) =
d832 1
a832 18
            let
              val input =
	        Capi.Text.substring (text, start_pos, last_pos - start_pos)
            in
	      if size input = 0 orelse
	         String.substring (input, size input - 1, 1) <> "\n" then
                (debug ("Inserting return at "
			^ Int.toString last_pos);
                 (* This is always after the prompt *)
                 Capi.Text.insert (text, last_pos, "\n");
                 write_pos := last_pos + text_size "\n";
                 Capi.Text.set_insertion_position
		   (text, last_pos + text_size "\n");
	         input ^ "\n")
	      else
	        (write_pos := last_pos;
	         input)
            end
d950 3
d973 1
d1046 1
d1139 8
d1148 2
a1149 4
	get_input (text, !prompt_pos, write_pos)

      fun get_input_from_stdin () = 
	get_input (text, !write_pos, write_pos)
a1277 3
      val buttons_update_fn_ref = ref (fn () => ())
      fun buttons_update_fn () = (!buttons_update_fn_ref) ()

d1353 1
d1366 1
d1437 1
d1687 3
a1689 3
                      fn _ => (do_evaluate false;
			       Capi.set_focus text),
                      fn _ => true),
d1693 1
a1693 1
                      fn _ => true),
d1700 1
a1700 1
                      fn _ => true),
d1704 1
a1704 1
                      fn _ => not (history_start ())),
d1708 1
a1708 1
                      fn _ => not (history_end ())),
d1712 1
a1712 1
                      fn _ => true)]);
@


1.49
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d5 6
d1365 11
d1378 2
d1439 8
a1446 6
	         error_handler
		   (x,
		    fn () => do_evaluate time_it,
		    str,
		    input,
		    offset)
d1452 1
@


1.48
log
@Replacing MLWorks.Integer with basis file
@
text
@d5 3
d625 3
a627 3
  fun debug s = if do_debug then output(IO.terminal_out,s ^ "\n") else ()
  fun fdebug f = if do_debug then output(IO.terminal_out,f() ^ "\n") else ()
  fun ddebug s = output(IO.terminal_out,s ^ "\n")
d658 1
a658 1
    let val chars = explode string
d665 1
a665 1
      implode (strip chars)
d684 1
a684 1
      implode (rev (strip (rev (strip (explode s))))) (* Yuk Yuk *)
d695 1
a695 1
            if String.ordof(line,index) = ord ":"
d762 1
a762 1
                  implode (rev (aux []))
d913 1
a913 1
	   fn s => output (std_out, s),
d1068 1
a1068 1
               (close_in instream;
d1202 1
a1202 1
                then output (outstream, Info.string_error error ^ "\n")
d1240 1
a1240 1
	      output (outstream, MLWorks.Time.Elapsed.format elapsed ^ "\n");
d1261 1
a1261 1
	(output (outstream, make_prompt ("MLWorks", Shell.initial_state));
d1266 1
a1266 1
        (output (outstream,"\n");
d1305 1
a1305 1
	 output (outstream, str);
d1353 1
a1353 1
	              output (outstream, ErrorBrowser.error_to_string hd ^ "\n")
d1382 1
a1382 1
	     output (outstream, "Interrupt\n");
@


1.47
log
@Fixed use of Info.default_options.
@
text
@d5 3
d524 4
d616 1
a616 3
  structure UserContext = ToolData.UserContext
  structure Integer = MLWorks.Integer
  structure Option = MLWorks.Option
d846 1
a846 1
			^ MLWorks.Integer.makestring last_pos);
d884 1
a884 1
          "Listener #" ^ Integer.makestring n
d1268 1
a1268 1
          MLWorks.Option.SOME w =>
d1271 1
a1271 1
	|  MLWorks.Option.NONE => ()
d1546 4
a1549 4
                 "Verify: start_pos is " ^ Integer.makestring start_pos ^
                 ", end_pos is " ^ Integer.makestring end_pos ^
                 ", write_pos is " ^ Integer.makestring (!write_pos) ^
                 ", prompt_pos is " ^ Integer.makestring (!prompt_pos) ^
d1629 1
a1629 1
           Option.SOME x => inspect_fn true x
d1640 1
a1640 1
	   inspect_fn = MLWorks.Option.SOME (inspect_fn false),
d1658 4
a1661 4
            {cut = Option.SOME (check_cut_selection),
             paste = Option.SOME (check_paste_selection),
             copy = Option.SOME (check_copy_selection),
             delete = Option.SOME (check_delete_selection),
d1718 1
a1718 1
          MLWorks.Option.SOME w => [Capi.Layout.FIXED w]
@


1.46
log
@Adjust prompt_pos on clearing input.
@
text
@d5 3
d1197 5
a1201 1
            Info.with_report_fun Info.default_options report_warnings handler'' s
d1204 1
a1204 1
	  handler'' Info.default_options s
@


1.45
log
@Added Clear All button.
@
text
@d5 3
d1187 9
a1195 1
	  Info.with_report_fun Info.default_options (fn _ => ()) handler'' s
d1315 2
a1316 3
      fun error_handler
	    ((_, error_list),
	     redo_action, str, input, offset) =
d1681 2
@


1.44
log
@Ensured erroneous input is added to the history if not corrected with the
Error Browser interface.
@
text
@d5 4
d1666 4
@


1.43
log
@ErrorBrowser.create now takes a close_action field.
@
text
@d5 3
d1300 3
a1302 1
      fun error_handler ((error, error_list), redo_action, str, offset) =
d1309 1
a1309 1
              (highlight (str, location, true, offset);
d1311 1
a1311 1
             clean_fn = fn () => highlight (str, location, false, offset)})
d1319 8
a1326 1
	     close_action = fn _ => finish_up "",
d1391 6
a1396 1
	         error_handler (x, fn () => do_evaluate time_it, input, offset)
@


1.42
log
@Fiddling with edit menu operations
@
text
@d5 3
d1314 1
@


1.41
log
@Removed sensitivity field from argument to view_options.
@
text
@d5 3
d1401 3
a1403 4
      val meta_bindings =
        [("p", prev_history),
         ("n", next_history),
         ("w", fn _ => Capi.Text.copy_selection text)]
d1419 36
d1613 1
a1613 1
             copy = Option.SOME (fn _ => Capi.Text.copy_selection text),
@


1.40
log
@Changing yank behaviour
@
text
@d5 3
a1563 1
	 sensitivity = GuiUtils.NO_SENSE_SELECTION,
@


1.39
log
@Minor change to error browser interface.
@
text
@d5 3
d791 3
a793 3
      (* This function gets input to evaluate or to pass to stdin, as
	 appropriate.  In the former case, start_pos should be !prompt_pos;
	 in the latter case, start_pos should be !write_pos. *)
d1415 13
d1432 1
@


1.38
log
@Changed behaviour of Return before the end of buffer.
@
text
@d5 3
d1299 1
a1299 2
             action_message = "Evaluate",
             file_message = "Error in: " ^ location_title,
@


1.37
log
@Corrected behaviour of clear.
@
text
@d5 3
d785 4
a788 1
      fun at_end (text) =
a789 1
          val pos = Capi.Text.get_insertion_position text
d791 7
a797 54
        in
	  pos = last_pos
	end

      fun get_input_to_evaluate (text,prompt_pos,write_pos) =
        let
          val length = Capi.Text.get_last_position text

          val input =
	    Capi.Text.substring (text, !prompt_pos, length - !prompt_pos)
        in
	  if size input = 0 orelse
	     String.substring (input, size input - 1, 1) <> "\n" then
            (debug ("Inserting return at " ^ MLWorks.Integer.makestring length);
             (* This is always after the prompt *)
             Capi.Text.insert (text, length, "\n");
             write_pos := length + text_size "\n";
             Capi.Text.set_insertion_position (text, length + text_size "\n");
	     input ^ "\n")
	  else
	    (write_pos := length;
	     input)
        end

      fun get_input_from_stdin (text,prompt_pos,write_pos) =
        let
          val length = Capi.Text.get_last_position text

          val input =
	    Capi.Text.substring (text, !write_pos, length - !write_pos)
        in
	  if size input = 0 orelse
	     String.substring (input, size input - 1, 1) <> "\n" then
            (debug ("Inserting return at " ^ MLWorks.Integer.makestring length);
             (* This is always after the prompt *)
             Capi.Text.insert (text, length, "\n");
             write_pos := length + text_size "\n";
             Capi.Text.set_insertion_position (text, length + text_size "\n");
	     input ^ "\n")
	  else
	    (write_pos := length;
	     input)
        end

      (*
      fun get_input_from_return (text,prompt_pos,write_pos) =
        let
          val pos = Capi.Text.get_insertion_position text
        in
          if pos < !prompt_pos then
            let
              val line = strip_prompt (Capi.Text.get_line (text, pos)) ^ "\n"
              val last_pos = Capi.Text.get_last_position text
            in
d801 2
a802 1
              Capi.Text.set_insertion_position (text, last_pos + text_size line);
d805 19
a823 2
          else
	    get_input_to_evaluate (text,prompt_pos,write_pos)
a824 1
     *)
d829 3
a831 1
  fun create external (tooldata as ToolData.TOOLDATA {args,appdata,current_context,motif_context,tools}) =
d1124 6
a1129 2
      val get_input_to_evaluate = fn () => get_input_to_evaluate text_info
      val get_input_from_stdin = fn () => get_input_from_stdin text_info
d1306 1
d1372 11
a1382 14
	if at_end text then
          if !input_flag then
	    let
              val input = get_input_from_stdin ()
            in
              (input_string := input;
               input_flag := false)
	    end
          else if !input_disabled
            then beep ()
          else
	    do_evaluate false
	else
	  insert_at_current "\n"
@


1.36
log
@Minor reorganisation of menus.
@
text
@d5 3
d1604 1
@


1.35
log
@Now handles exceptions and trivial lines.
@
text
@d5 3
d1543 11
a1553 4
      val value_menu = GuiUtils.value_menu (shell,
                                            user_preferences,
                                            MLWorks.Option.SOME (inspect_fn false),
                                            get_value)
d1568 8
a1575 6
         ToolData.edit_menu (shell,
                             {cut = Option.SOME (check_cut_selection),
                              paste = Option.SOME (check_paste_selection),
                              copy = Option.SOME (fn _ => Capi.Text.copy_selection text),
                              delete = Option.SOME (check_delete_selection),
                              selection_made = fn _ => Capi.Text.get_selection text <> ""}),
d1577 14
a1590 12
         value_menu,
         GuiUtils.context_menu {set_state = select_context,
                                get_context = fn _ => !local_context,
                                writable = GuiUtils.WRITABLE,
                                applicationShell = applicationShell,
                                shell = shell,
                                search_opt = MLWorks.Option.SOME (insert_at_current, true),
                                user_preferences = user_preferences},
         Menus.CASCADE ("error", [Menus.PUSH ("edit", edit_error, fn _ => true)],
                        fn _ => true),
	 history_menu,
         ToolData.windows_menu ()]
@


1.34
log
@Added get_input_from_stdin function, since get_input_to_evaluate now
reads input from prompt_pos instead of write_pos.
@
text
@d5 4
d1331 16
@


1.33
log
@Added buttons.  This involved adding the time-handler functionality, and
moving the history mechanism to gui_utils.  The latter change was needed
because the add_history function needs to know about indices (it was in
shell_utils, but gui_utils is more appropriate).
@
text
@d5 6
d800 20
d1138 1
d1367 1
a1367 1
              val input = get_input_to_evaluate ()
@


1.32
log
@Changing inspector interface.
@
text
@d5 3
d613 1
d631 1
d847 3
d1166 23
d1228 2
a1229 39
      (* HISTORY *)
      (* The history is a list of topdecs, combined with an index number. *)
      (* The index is used to set the current_index ref when a topdec is *)
      (* selected from the menu. *)
      val history = ref []: (string * int) list ref;
      val history_size = ref 0;
      val initial_index = ~1;
      val history_index = ref initial_index;

      fun add_history_entry new_entry =
        if size new_entry > 4 then
          (history_size := !history_size + 1;
           ShellUtils.add_history_item ((new_entry, !history_size),
                                        history,
                                        (fn ((s,_),(s',_))=>s=s'),
                                        user_preferences))
        else ()
        
      fun update_history l =
	Lists.iterate (add_history_entry o strip_whitespace) l;

      fun pop_history () = 
	let val _ = history_index := !history_index + 1
	    val line = #1 (Lists.nth (!history_index, !history))
	in 
	  replace_current_input line
	end
	handle Lists.Nth => history_index := !history_index - 1;

      fun push_history () = 
	let val _ = history_index := !history_index - 1;
	    val line = #1 (Lists.nth (!history_index, !history))
	               handle
	  		 Lists.Nth =>
			   (history_index := initial_index;
			    ""	(* empty input *))
	in 
	  replace_current_input line
	end
d1231 5
a1235 2
      fun warp_history string =
        ShellUtils.trim_history_string (string, user_preferences)
d1241 1
a1241 1
	 history_index := initial_index;
d1285 1
a1285 1
      fun evaluate () =
d1288 7
d1296 42
d1339 6
a1344 2
            (input_string := input;
             input_flag := false)
d1348 1
a1348 44
	    let
	      val end_pos = !write_pos
	    in
	      case handler (input, Shell.initial_state)
	      of ([], str, Shell.OK _) => 
	        (* Nothing to do *)
	        ()
	      |  (l, str, Shell.OK _) => 
	        (* OK *)
	        (update_history l;
                 (!do_select_fn) ();
	         finish_up str)
	      |  (l, str, Shell.ERROR x) =>
	        (* Error *)
	        (update_history l;
	         if use_error_browser () then
		   let
		     (* If any topdecs have been successfully evaluated, then
			the code below will output a new prompt followed by
			the remainder of the input.  Any highlighting must
			be relative to the remaining input, so we have to
			adjust the location information by the amount of
			code that we have removed. *)
		     val offset = Lists.reducel (fn (i, s) => i + size s) (0, l)
		   in
		     (* If the evaluation has caused anything to be written,
			then output a new prompt, with the offending input
			after.  This means that the input to be evaluated
			is always at the end of the Widget. *)
		     if end_pos <> !write_pos then
	               finish_up str
		     else
		       ();
	             error_handler (x, evaluate, input, offset)
		   end
	         else
	           (update_history [str];
		    finish_up ""))
	    end
        end

      fun do_return () =
	if at_end text then
	  evaluate ()
d1359 2
a1360 2
        [("p", pop_history),
         ("n", push_history),
d1528 1
a1528 10
         Menus.DYNAMIC ("history",
			fn () =>
			map (fn (s,i) =>
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_input s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> []),
d1530 25
d1556 1
d1565 2
d1572 1
@


1.31
log
@Added key binding for ^O to insert newline.  Removed yank_current_line
because it was never used.
@
text
@d5 4
d537 1
a537 1
	       ErrorBrowser.Widget
d545 1
a545 1
  sharing type ShellUtils.Type = GuiUtils.Type
d1248 3
d1308 1
a1469 1
      fun inspect_fn () = InspectorTool.create (mk_tooldata())
d1474 1
a1474 3
          case ShellUtils.value_from_user_context (user_context,user_options) of
            Option.SOME (a,b) => Option.SOME b
          | _ => Option.NONE
d1477 9
d1488 1
a1488 1
                                            MLWorks.Option.SOME (inspect_fn),
@


1.30
log
@The previous change caused crashes with empty lines.  Fixed it.
@
text
@d5 3
a732 17
      fun yank_current_line (text,prompt_pos,write_pos) =
        fn _ => 
	let
          val pos = Capi.Text.get_insertion_position text
          val last_pos = Capi.Text.get_last_position text
        in
          if pos < !prompt_pos then
            let val line = strip_prompt (Capi.Text.get_line (text,pos))
            in
              (*last_pos always after the prompt *)
              Capi.Text.insert(text, last_pos, line);
              Capi.Text.set_insertion_position (text, last_pos + text_size line)
            end
          else
            ()
        end

d1367 1
a1370 1
         ("\^J", yank_current_line text_info),
d1441 3
a1443 3
         if bad_key key
           then (beep (); true)
         else
d1445 4
a1448 7
           if !escape_pressed
             then 
               (escape_pressed := false;
                despatch_meta key)
           else if Lists.member (Capi.Event.meta_modifier, modifiers)
              then despatch_meta key
           else despatch_normal key)
@


1.29
log
@Added support for error browsing.
@
text
@d5 3
d784 1
a784 1
	    Capi.Text.substring (text, !prompt_pos,length - !prompt_pos)
d786 2
a787 1
	  if String.substring (input, size input - 1, 1) <> "\n" then
d795 2
a796 1
	    input
@


1.28
log
@Reordering top level menus.
@
text
@d5 3
d473 1
d508 1
d514 1
d526 2
a527 1
    	       GuiUtils.Widget = Capi.Widget = ProfileTool.Widget
d529 1
d542 1
d776 19
d811 1
a811 14
            let
              val length = Capi.Text.get_last_position text
                
              val input =
		Capi.Text.substring (text, !prompt_pos,length - !prompt_pos)
            in
              debug ("Inserting return at " ^
                     MLWorks.Integer.makestring length);
              (* This is always after the prompt *)
              Capi.Text.insert (text, length, "\n");
              write_pos := length + text_size "\n";
              Capi.Text.set_insertion_position (text, length + text_size "\n");
	      input ^ "\n"
            end
d813 1
d899 2
a900 2
      (* write_pos is the position new input should go in the buffer, usually the end.
         Also used as the position from which input is read. 
d904 2
a905 2
	 The current compiler input lies between prompt_pos and 
	 get_last_pos text *)
d1021 2
a1022 2
            if modification_ok pos
              then Capi.Text.replace (text, pos, pos + 1, "")
d1108 1
a1108 1
      val get_input_from_return = fn () => get_input_from_return text_info
d1125 11
a1135 1
      val (handler', make_prompt) =
d1138 7
d1220 2
a1221 1
      fun update_history l = map (add_history_entry o strip_whitespace) l;
d1253 37
d1292 1
a1292 1
          val input = get_input_from_return ()
d1300 38
a1337 13
	    case handler (input, Shell.initial_state)
	    of ([], true, _, _) => 
	      (* Nothing to do *)
	      ()
	    |  (l, true, str, _) => 
	      (* OK *)
	      (update_history l;
	       finish_up str)
	    |  (l, false, str, _) =>
	      (* Error *)
	      (update_history l;
	       update_history [str];
	       finish_up "")
@


1.27
log
@Added newline to end of input - otherwise a null line is treated as an EOF!
@
text
@d5 3
d468 1
d502 1
d523 1
a523 1
  sharing type ToolData.ToolData = DebuggerWindow.ToolData
d526 2
d1378 14
a1391 10
      val value_menu =
          GuiUtils.value_menu
              (shell,
	       GuiUtils.get_user_context (!local_context),
	       user_options,
	       user_preferences,
	       [text]
              )
 
              
a1405 1
         ToolData.windows_menu (),
d1432 2
a1433 1
                        fn _ => !history <> [])]
@


1.26
log
@Now parses everything since the main prompt, so allowing multi-line editing.
Uses the revised shell interface (see interpreter/shell).
@
text
@d5 4
a507 1

a509 1

a510 1

a512 1

a513 1

a515 1

a516 1
   
d788 1
a788 1
	      input
d1212 25
d1239 1
a1239 25
	  let
            val input = get_input_from_return ()
          in
            if !input_flag
              then
                (input_string := input;
                 input_flag := false)
            else
              if !input_disabled
                then beep ()
              else
	        case handler (input, Shell.initial_state)
	        of ([], true, _, _) => 
		  (* Nothing to do *)
		  ()
	        |  (l, true, str, _) => 
		  (* OK *)
		  (update_history l;
		   finish_up str)
	        |  (l, false, str, _) =>
		  (* Error *)
		  (update_history l;
		   update_history [str];
		   finish_up "")
          end
@


1.25
log
@Changing uses of full_menus
@
text
@d5 3
a595 11
  fun trivial s = 
    let
      fun trivial' (~1, _) = true
        | trivial' (n, s) =
          if whitespacep (String.substring (s, n, 1))
            then trivial' (n-1, s)
          else false
    in
      trivial' (size s - 1, s)
    end
  
a604 4
  fun strip_trivia [] = []
    | strip_trivia (l as (a::b)) =
      if trivial a then strip_trivia b else l
        
d755 8
d776 1
a776 1
              [line]
d782 2
a783 10
              fun get_lines ([], current, acc, _) =
                map (implode o rev) (current :: acc)
                |   get_lines ("\n"::rest, current, acc, column) =
                    get_lines (rest, [], ("\n"::current)::acc, 1)
                |   get_lines (c::rest, current, acc, column) =
                    get_lines (rest, c::current, acc, column+1)

              val line = Capi.Text.substring (text, !write_pos,length - !write_pos)
              (* val _ = output (MLWorks.IO.terminal_out,String.ml_string (line,1000) ^ "\n") *)
              val lines = get_lines (explode line,[],[],0)
d785 7
a791 10
              case lines of
                last :: rest =>
                  (debug ("Inserting return at " ^
                          MLWorks.Integer.makestring length);
                   (* This is always after the prompt *)
                   Capi.Text.insert (text, length, "\n");
                   write_pos := length + text_size "\n";
                   Capi.Text.set_insertion_position (text, length + text_size "\n");
                   last ^ "\n" :: rest)
              | _ => lines
d890 3
a892 1
      fun modification_ok pos = not Capi.Text.read_only_before_prompt orelse pos >= !prompt_pos
d894 4
a897 1
        modification_ok (Capi.Text.get_insertion_position text - size (Capi.Text.get_selection text))
d1062 1
d1132 1
a1132 1
	(output (outstream, make_prompt ("MLWorks"));
d1137 2
a1138 3
        (handler "\n"; (* Forces something to happen? *)
         output (outstream,"\n");
         output_prompt())
a1164 11
      val current_topdec = ref [];

      fun add_line line =
        let val topdec =
          case !current_topdec of
            [] => if trivial line then [] else [line]
          | lines => line :: lines
        in
          current_topdec := topdec
        end

d1183 1
a1183 24
      fun do_history_entry () =
        let 
          val topdec = strip_trivia (!current_topdec)
          val new_entry = implode (rev topdec)
        in
          add_history_entry (strip_whitespace new_entry);
          current_topdec := []
        end

      fun update_history (([], false), line) =
        (add_line line;
         do_history_entry ())
        | update_history (([], true), line) =
          add_line line
        | update_history ((h::t, still_valid), line) =
          let 
            val newbit = String.substring (line, 0, h)
            val rest_of_line =
              String.substring (line, h, size line - h)
          in
            (add_line newbit;
             do_history_entry ();
             update_history ((map (fn x => x-h) t, still_valid), rest_of_line))
          end
d1207 1
a1207 1
      fun finish_up () =
d1209 2
d1216 8
a1223 10
	let
          val lines = get_input_from_return ()
        in
          if !input_flag
            then
              (input_string := implode (rev lines);
               input_flag := false)
          else
            if !input_disabled
              then beep ()
d1225 19
a1243 11
              (flush_rest := false;
               Lists.iterate
               (fn line => 
                (* If a syntax error has occurred, then do the history *)
                (* stuff, but don't evaluate the rest of the input *)
                (if !flush_rest then update_history (([],true), line)
                 else update_history (handler line, line)))
               (rev lines);
               if !flush_rest then do_history_entry () else ();
               finish_up ())
        end
d1439 1
a1439 1
      output_prompt()
@


1.24
log
@Fixing problem with previous change for Windows.
@
text
@d5 3
d1418 1
a1418 11
      val tailmenuspec =
	[Menus.DYNAMIC ("history",
			fn () =>
			map (fn (s,i) =>
                             Menus.PUSH (warp_history s,
                                         fn _ => (replace_current_input s;
                                                  history_index :=
                                                  !history_size - i),
                                         fn _ => true))
                        (!history),
                        fn _ => !history <> [])]
d1429 32
a1460 28
	ToolData.works_menu
	(mk_tooldata, close_window,
	 fn _ => not (!input_flag),
	 fn () => GuiUtils.get_user_context (!local_context))
        :: ToolData.windows_menu ()
        :: ToolData.edit_menu (shell,
                               {cut = Option.SOME (check_cut_selection),
                                paste = Option.SOME (check_paste_selection),
                                copy = Option.SOME (fn _ => Capi.Text.copy_selection text),
                                delete = Option.SOME (check_delete_selection),
                                selection_made = fn _ => Capi.Text.get_selection text <> ""})
        :: Menus.CASCADE ("view", view_options, fn () => true)
        :: value_menu
	:: GuiUtils.context_menu
	     {set_state = select_context,
	      get_context = fn _ => !local_context,
	      writable = GuiUtils.WRITABLE,
	      applicationShell = applicationShell,
	      shell = shell,
	      search_opt = MLWorks.Option.SOME (insert_at_current, true),
	      user_preferences = user_preferences}
	:: (if full_menus then
	      Menus.CASCADE
	      ("error", [Menus.PUSH ("edit", edit_error, fn _ => true)],
	       fn _ => true)
	      :: tailmenuspec
	    else
	      tailmenuspec)
@


1.23
log
@Adding insertion checks for the benefit of Windows
@
text
@d5 3
d921 3
a924 1
            Capi.Text.insert (text, old_pos, str);
@


1.22
log
@Moved list_select to capi
@
text
@d5 3
d913 9
a921 3
          (Capi.Text.insert (text, !write_pos, str);
           write_pos := text_size str + !write_pos;
           Capi.Text.set_insertion_position (text, !write_pos))
@


1.21
log
@Fixing problem with typing return before prompt.  This doesn't actually
insert anything, so should be allowed.
@
text
@d5 4
d1067 1
a1067 1
                      val popdown = GuiUtils.list_select
@


1.20
log
@Adding checks on modifications before prompt.
@
text
@d5 3
d1348 3
a1350 1
      fun bad_key key =
d1353 1
@


1.19
log
@Changing interface to edit_menu
@
text
@d5 3
a696 4
      fun insert_at (text,pos,str) =
        (Capi.Text.insert (text,pos,str);
         Capi.Text.set_insertion_position (text, pos + text_size str))

d719 1
d760 1
d783 3
a785 1
                  (debug ("Inserting return at " ^ MLWorks.Integer.makestring length);
d889 3
d895 3
a897 1
        Capi.Text.insert (text, Capi.Text.get_insertion_position text, s)
d902 1
d987 3
a989 2
            (debug "delete";
             Capi.Text.replace (text, pos, pos + 1, ""))
d1041 7
d1049 1
a1049 1
            insert_at (text,start_pos,String.substring (a, size sofar, size a - size sofar))
d1268 15
d1287 2
a1288 2
         ("\^W", fn _ => Capi.Text.cut_selection text),
         ("\^Y", fn _ => Capi.Text.paste_selection text),
d1418 2
a1419 2
                               {cut = Option.SOME (fn _ => Capi.Text.cut_selection text),
                                paste = Option.SOME (fn _ => Capi.Text.paste_selection text),
d1421 1
a1421 1
                                delete = Option.SOME (fn _ => Capi.Text.delete_selection text),
@


1.18
log
@Adding call to transfer_focus
@
text
@d5 3
d1249 1
a1249 1
         ("w", fn _ => GuiUtils.copySelection text)]
d1255 2
a1256 2
         ("\^W", fn _ => GuiUtils.cutSelection text),
         ("\^Y", fn _ => GuiUtils.pasteSelection text),
d1385 6
a1390 3
        :: ToolData.edit_menu {paste = Option.SOME insert_at_current,
                               copy = Option.SOME (fn _ => Capi.Text.get_selection text),
                               delete = Option.SOME (fn _ => Capi.Text.remove_selection text)}
@


1.17
log
@Trying to fix completion for windows.
@
text
@d5 3
d616 1
a616 1
      (* TEXT UTILITIES *)
d618 9
a626 6
      fun get_current_line text =
        let
          val pos = Capi.Text.get_insertion_position text
        in
          Capi.Text.get_line (text, pos)
        end
d628 8
a635 8
      fun get_current_subline (text,start_pos) =
        let
          val (line,ix) = Capi.Text.get_line_and_index (text,start_pos)
          val line2 = strip_prompt line
          val ix2 = ix - (size line - size line2)
        in
          if ix2 > 0 then String.substring (line2,0,ix2) else ""
        end
d637 1
a637 1
      val (input_flag,input_string) = (ref false,ref "")
d779 2
a780 1
                  (Capi.Text.insert (text, length, "\n");
d870 2
d1321 2
a1322 1
        (after_input ();
@


1.16
log
@Adding window menu
@
text
@d5 3
a780 18
      fun do_insert_text ((text,prompt_pos,write_pos),start_pos,end_pos,str) =
        (fdebug (fn _ =>
                 "Verify: start_pos is " ^ Integer.makestring start_pos ^
                 ", end_pos is " ^ Integer.makestring end_pos ^
                 ", write_pos is " ^ Integer.makestring (!write_pos) ^
                 ", prompt_pos is " ^ Integer.makestring (!prompt_pos) ^
                 ", string is '" ^ str ^ "'");
        if end_pos < !write_pos 
          then write_pos := (!write_pos) - end_pos + start_pos + text_size str
        else if start_pos < !write_pos then
          write_pos := start_pos + text_size str
	else ();
        if end_pos < !prompt_pos
          then prompt_pos := (!prompt_pos) - end_pos + start_pos + text_size str
        else if start_pos < !prompt_pos 
          then prompt_pos := start_pos + text_size str
        else ())

d987 9
a995 1
      val actions_after_input = ref []
d1030 8
a1037 5
                    actions_after_input := 
                      GuiUtils.list_select
			(shell,"completions")
                        (l,insert_fun, fn x => x)
		      :: !actions_after_input
d1247 1
d1264 20
d1286 1
a1286 3
          val _ =
            (Lists.iterate (fn f => f ()) (!actions_after_input);
             actions_after_input := [])
a1293 4
          else if str = "\t"
            then
              (do_completion start_pos;
               set_fn false)
d1300 11
d1312 12
a1323 3
        if Lists.member (Capi.Event.meta_modifier, modifiers)
          then despatch_meta key
        else despatch_normal key
@


1.15
log
@Simplifying capi interface.
@
text
@d5 3
d1340 4
@


1.14
log
@Now creates a new list widget each time that completion is asked for, so that
it pops up with the correct size under TWM.
@
text
@d5 4
d1264 1
a1264 1
      fun modifyVerify callback_data =
a1268 2
          val (event,start_pos,end_pos,str,set_fn) =
            Capi.Callback.convert_verify_data callback_data
d1365 1
a1365 1
      Capi.Callback.add (text, Capi.Callback.ModifyVerify, modifyVerify);
@


1.13
log
@Make profile tool a child of the application shell.
@
text
@d5 3
a995 1
      val popup_completion = GuiUtils.list_select (shell,"completions")
d1031 4
a1034 1
                    popup_completion (l,insert_fun, fn x => x) :: !actions_after_input
@


1.12
log
@Renamed ShellUtils.edit_string to ShellUtils.edit_source
(and ShellUtils.edit_source to ShellUtils.edit_location).
@
text
@d5 4
d839 1
a839 1
	ProfileTool.create (shell,user_preferences)
@


1.11
log
@Add profiler to the shelldata made here.
@
text
@d5 3
d977 1
a977 1
            ShellUtils.edit_string
@


1.10
log
@The search_opt field of the context menu now takes a boolean component which
controls whether users are given the option of which contexts to search.
In input tools this should be true, in the context browser it should be false.
@
text
@d5 5
d413 1
d446 1
d468 1
a468 1
    	       GuiUtils.Widget = Capi.Widget
d478 2
a479 1
	       GuiUtils.user_preferences
d831 3
d845 1
@


1.9
log
@Moved breakpoints_menu to podium.
Combined search menu with (slimline) context menu.
@
text
@d5 4
d1314 7
a1320 7
	{set_state = select_context,
	 get_context = fn _ => !local_context,
	 writable = GuiUtils.WRITABLE,
	 applicationShell = applicationShell,
	 shell = shell,
	 search_opt = MLWorks.Option.SOME insert_at_current,
	 user_preferences = user_preferences}
@


1.8
log
@Changing top level window initialization
@
text
@d5 3
a415 1
require "../interpreter/entry";
d436 1
a436 1
  structure Entry : ENTRY
d442 2
a443 3
  sharing type UserOptions.Options.print_options = Entry.PrintOptions

  sharing type ToolData.ShellTypes.user_options = UserOptions.user_tool_options =
d451 1
a451 1
  sharing type Shell.Context = ShellUtils.Context = Entry.Context =
d1030 2
a1031 1
      val (handler', make_prompt) = Shell.shell (shell_data,location_title,flush_stream)
d1052 6
a1057 1
        (output(outstream,make_prompt (GuiUtils.get_context_name (!local_context)));
a1255 17
(* This should be shifted into motif/_capi *)
(*
      fun activate callback_data =
	let 
          val event = Capi.Callback.get_event callback_data
        in
          case Capi.Event.get_key_data event of
            MLWorks.Option.SOME (key,modifiers) =>
              if Lists.member (Capi.Event.meta_modifier, modifiers)
                then despatch_meta key
              else despatch_normal key
          | _ => (debug("activate: non-key event");
                  beep ())
        end
      handle Shell.Exit _ => Capi.destroy shell
*)

d1281 1
a1281 91
      (* added search stuff here *)
      fun get_print_options () = UserOptions.new_print_options (get_user_options ())

      fun flat (x::xs) = (implode x ^ "\n") :: (flat xs)
	| flat [] = []
	      
      fun grep regexp line = let
	fun startsWith [] ys = true
	  | startsWith xs [] = false
	  | startsWith (x::xs) (y::ys) = (x=y) andalso (startsWith xs ys)
	fun check [] ys = false
	  | check xs [] = false
	  | check xs (y::ys) = startsWith xs (y::ys) orelse check xs ys
      in
	check (explode regexp) (explode line)
      end (* grep *)
	
      fun collect f xs = let
	fun collect f acc [] = rev acc
	  | collect f acc (x::xs) =
	    if f x then collect f (x::acc) xs
	    else collect f acc xs
      in (* let *)
	collect f [] xs
      end (* collect *)

      val searchOptions = ref
	{showSig = true,
	 showStr = true,
	 showFun = true,
	 searchInitial = false,
	 showType = true}
	 
      fun search s = let
	fun getItemsFromContext c = let
	  val context = #2(UserContext.get_context_info
			   (GuiUtils.get_user_context c))
	in
	  Entry.context2entry context
	end
      			    
	val context =
	  if (#searchInitial (!searchOptions)) then
	    getItemsFromContext(GuiUtils.getInitialContext())
	  else
	    getItemsFromContext (!local_context)

	val printOptions = get_print_options()

	(* datatype Entry is a linear structure, munge to tree like form *)
	val entrys = map Entry.massage context
	val entrys' = Entry.printEntry1 (!searchOptions) printOptions entrys
	val entrys' = map implode entrys'
	(*
          val _ = debug_output
	  ("search on \""^s^"\" with options..."^Entry.printSearchOptions (!searchOptions))
	  val _ = map debug_output entrys'
	  val _ = debug_output ("applying search now...")
	 *)
	val found = collect (grep s) entrys'
	val _ = GuiUtils.list_select
	  (shell, "ListSelect Name")
	  (found,
	   insert_at_current,
	   fn x => x)
      in
	()
      end (* search *)
	    
      val searchSpec =
	[Menus.OPTLABEL "Search inside...",
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("signatures", fn ()=> #showSig (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showSig", b, !searchOptions)),
	 Menus.OPTTOGGLE ("structures", fn ()=> #showStr (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showStr", b, !searchOptions)),
	 Menus.OPTTOGGLE ("functors",   fn ()=> #showFun (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showFun", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("Display their types", fn ()=> #showType (!searchOptions),
			  fn b=>searchOptions:=Entry.update ("showType", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTOGGLE ("Search in Initial Context", fn ()=> #searchInitial (!searchOptions),
			  fn b=>searchOptions := Entry.update ("searchInitial", b, !searchOptions)),
	 Menus.OPTSEPARATOR,
	 Menus.OPTTEXT ("Search for Item", fn () => "" , fn s =>search s)
	 ]
      fun searchPopup _ =
	((#1 (Menus.create_dialog
	    (shell, "Search Window", "browserDialog", fn ()=>(), searchSpec))) ())
	  
d1283 1
a1283 6
	[GuiUtils.breakpoints_menu shell,
	 Menus.CASCADE
	 ("Search",
	  [Menus.PUSH ("search", searchPopup, fn _=>true)],
	  fn _=>true),
	 Menus.DYNAMIC ("history",
d1314 2
@


1.7
log
@Adding flush_stream function to Shell.shell
@
text
@d5 3
d1033 2
a1034 2
        (fn () => 
         IO.with_standard_output
d1036 3
a1038 3
         (fn () =>
          IO.with_standard_input
          instream
d1040 8
a1047 5
           Ml_Debugger.with_debugger_type
           debugger_type
           (fn _ => 
            ShellTypes.with_toplevel_name location_title
            (fn _ => handler' s)))))
d1440 1
a1440 2
      Capi.reveal shell;
      Capi.initialize shell;
@


1.6
log
@Renaming layout constructors
@
text
@d5 3
d1022 5
a1026 1
      val (handler', make_prompt) = Shell.shell (shell_data,location_title)
d1172 7
a1178 2
              (Lists.iterate
               (fn line => update_history (handler line, line))
d1180 1
@


1.5
log
@Removing some diagnostic
@
text
@d5 3
d805 1
a805 1
	  (DebuggerWindow.make_debugger_window (shell, "debugger", tooldata),
d1414 1
a1414 1
          MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
d1416 1
a1416 1
       [Capi.Layout.TEXT scroll,
d1421 2
a1422 4
      Capi.manage menuBar;
      Capi.manage text;
      Capi.manage shell;
      Capi.realize shell;
@


1.4
log
@Abstracting text functionality
@
text
@d5 3
d726 1
a726 1
              val _ = output (MLWorks.IO.terminal_out,String.ml_string (line,1000) ^ "\n")
@


1.3
log
@Adding make_buttons function to capi
@
text
@d5 3
d638 2
d642 1
a642 1
         Capi.Text.set_insertion_position (text, pos + size str))
d651 1
a651 1
	  Capi.Text.set_insertion_position (text, !prompt_pos + size line)
d667 1
a667 1
              Capi.Text.set_insertion_position (text, last_pos+size line)
d707 2
a708 2
              write_pos := last_pos + size line;
              Capi.Text.set_insertion_position (text, last_pos + size line);
d723 1
d729 2
a730 2
                   write_pos := length + 1;
                   Capi.Text.set_insertion_position (text, length+1);
d744 1
a744 1
          then write_pos := (!write_pos) - end_pos + start_pos + size str
d746 1
a746 1
          write_pos := start_pos + size str
d749 1
a749 1
          then prompt_pos := (!prompt_pos) - end_pos + start_pos + size str
d751 1
a751 1
          then prompt_pos := start_pos + size str
d852 1
a852 1
           write_pos := size str + !write_pos;
d1189 1
a1189 1
          fun loop [] = beep ()
d1191 1
a1191 1
              if key = key' then action ()
d1212 2
a1213 1
               despatch_meta str)
d1224 2
d1239 7
d1269 1
a1269 1
      fun flat (x::xs) = ((implode x)^"\n") :: (flat xs)
d1412 1
a1412 1
      Capi.Callback.add (text, Capi.Callback.Activate, activate);
@


1.2
log
@Moved capi etc. to gui
@
text
@d5 3
d1389 2
a1390 1
      ([Capi.Layout.MENUBAR menuBar] @@
@


1.1
log
@new unit
New unit
@
text
@d5 4
d378 2
a379 2
require "../library/capi";
require "../library/menus";
@
