head	1.61;
access;
symbols
	MLW_daveb_inline_1_4_99:1.61.1
	MLWorks_21c0_1999_03_25:1.61
	MLWorks_20c1_1998_08_20:1.61
	MLWorks_20c0_1998_08_04:1.61
	MLWorks_20b2c2_1998_06_19:1.61
	MLWorks_20b2_Windows_1998_06_12:1.61
	MLWorks_20b1c1_1998_05_07:1.61
	MLWorks_20b0_1998_04_07:1.61
	MLWorks_20b0_1998_03_20:1.60
	MLWorks_20m2_1998_02_16:1.56
	MLWorks_20m1_1997_10_23:1.55
	MLWorks_11r1:1.48.1.1.1.2.1
	MLWorks_workspace_97:1.54.2
	MLWorks_dt_wizard:1.54.1
	MLWorks_11c0_1997_09_09:1.48.1.1.1.2
	MLWorks_10r3:1.48.1.1.3
	MLWorks_10r2_551:1.48.1.1.2
	MLWorks_11:1.48.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.48.1.1
	MLWorks_20m0_1997_06_20:1.52
	MLWorks_1_0_r2c2_1997_06_14:1.48.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.48.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.48.1
	MLWorks_BugFix_1997_04_24:1.48
	MLWorks_1_0_r2_Win32_1997_04_11:1.48
	MLWorks_1_0_r2_Unix_1997_04_04:1.48
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.47.4.1.1
	MLWorks_gui_1996_12_18:1.47.5
	MLWorks_1_0_Win32_1996_12_17:1.47.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.47.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.47.1.1
	JFHgui:1.47.3
	MLWorks_1_0_Irix_1996_11_28:1.47.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.47.2
	MLWorks_1_0_Unix_1996_11_14:1.47.1
	MLWorks_Open_Beta2_1996_10_11:1.46.2
	MLWorks_License_dev:1.46.1
	MLWorks_1_open_beta_1996_09_13:1.45.1
	MLWorks_Open_Beta_1996_08_22:1.45
	MLWorks_Beta_1996_07_02:1.43
	MLWorks_Beta_1996_06_07:1.43
	MLWorks_Beta_1996_06_06:1.43
	MLWorks_Beta_1996_06_05:1.43
	MLWorks_Beta_1996_06_03:1.43
	MLWorks_Beta_1996_05_31:1.43
	MLWorks_Beta_1996_05_30:1.43;
locks; strict;
comment	@ * @;


1.61
date	98.03.31.16.02.40;	author johnh;	state Exp;
branches
	1.61.1.1;
next	1.60;

1.60
date	98.03.02.15.07.22;	author mitchell;	state Exp;
branches;
next	1.59;

1.59
date	98.02.19.20.15.40;	author mitchell;	state Exp;
branches;
next	1.58;

1.58
date	98.02.18.17.00.54;	author jont;	state Exp;
branches;
next	1.57;

1.57
date	98.02.17.16.41.36;	author johnh;	state Exp;
branches;
next	1.56;

1.56
date	98.01.27.15.58.18;	author johnh;	state Exp;
branches;
next	1.55;

1.55
date	97.09.18.15.16.09;	author brucem;	state Exp;
branches;
next	1.54;

1.54
date	97.07.28.13.16.50;	author brucem;	state Exp;
branches
	1.54.1.1
	1.54.2.1;
next	1.53;

1.53
date	97.07.25.13.31.48;	author johnh;	state Exp;
branches;
next	1.52;

1.52
date	97.06.13.11.00.31;	author johnh;	state Exp;
branches;
next	1.51;

1.51
date	97.06.11.12.40.07;	author johnh;	state Exp;
branches;
next	1.50;

1.50
date	97.05.16.15.35.32;	author johnh;	state Exp;
branches;
next	1.49;

1.49
date	97.05.02.17.27.07;	author jont;	state Exp;
branches;
next	1.48;

1.48
date	97.03.06.17.28.18;	author matthew;	state Exp;
branches
	1.48.1.1;
next	1.47;

1.47
date	96.10.09.15.59.06;	author io;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1
	1.47.4.1
	1.47.5.1;
next	1.46;

1.46
date	96.09.30.09.39.04;	author johnh;	state Exp;
branches
	1.46.1.1
	1.46.2.1;
next	1.45;

1.45
date	96.08.15.12.52.45;	author daveb;	state Exp;
branches
	1.45.1.1;
next	1.44;

1.44
date	96.08.07.10.46.44;	author andreww;	state Exp;
branches;
next	1.43;

1.43
date	96.05.28.14.23.51;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	96.05.24.16.21.18;	author daveb;	state Exp;
branches;
next	1.41;

1.41
date	96.05.24.14.39.15;	author daveb;	state Exp;
branches;
next	1.40;

1.40
date	96.05.10.14.46.19;	author daveb;	state Exp;
branches;
next	1.39;

1.39
date	96.05.07.11.36.22;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	96.05.01.10.50.28;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	96.04.19.16.17.47;	author daveb;	state Exp;
branches;
next	1.36;

1.36
date	96.04.04.13.44.48;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	96.02.08.15.31.42;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	96.01.25.13.11.42;	author matthew;	state Exp;
branches;
next	1.33;

1.33
date	96.01.23.16.09.42;	author daveb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.22.16.35.47;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	96.01.22.11.12.47;	author daveb;	state Exp;
branches;
next	1.30;

1.30
date	96.01.19.14.55.25;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	96.01.17.17.24.23;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	95.12.07.14.18.45;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	95.11.23.12.58.12;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	95.11.21.14.43.02;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	95.11.16.13.18.37;	author matthew;	state Exp;
branches;
next	1.24;

1.24
date	95.11.15.16.56.22;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.11.14.14.01.15;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.10.30.16.14.44;	author daveb;	state Exp;
branches;
next	1.21;

1.21
date	95.10.25.12.59.59;	author brianm;	state Exp;
branches;
next	1.20;

1.20
date	95.10.19.15.33.43;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	95.10.18.11.08.55;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	95.10.18.11.01.55;	author brianm;	state Exp;
branches;
next	1.17;

1.17
date	95.10.15.16.12.10;	author brianm;	state Exp;
branches;
next	1.16;

1.16
date	95.10.13.08.39.24;	author brianm;	state Exp;
branches;
next	1.15;

1.15
date	95.10.11.09.36.12;	author brianm;	state Exp;
branches;
next	1.14;

1.14
date	95.10.10.08.56.12;	author brianm;	state Exp;
branches;
next	1.13;

1.13
date	95.10.09.08.42.20;	author brianm;	state Exp;
branches;
next	1.12;

1.12
date	95.10.06.12.37.10;	author brianm;	state Exp;
branches;
next	1.11;

1.11
date	95.10.04.13.26.12;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.09.18.14.45.06;	author brianm;	state Exp;
branches;
next	1.9;

1.9
date	95.09.11.13.20.16;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	95.09.08.15.36.27;	author matthew;	state Exp;
branches;
next	1.7;

1.7
date	95.09.06.13.56.59;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.08.30.13.23.42;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.08.10.12.17.02;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.08.02.15.07.06;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	95.07.27.10.57.51;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	95.07.27.10.32.47;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	95.07.26.14.44.43;	author matthew;	state Exp;
branches;
next	;

1.45.1.1
date	96.09.13.11.13.09;	author hope;	state Exp;
branches;
next	;

1.46.1.1
date	96.10.07.16.03.49;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.10.17.11.22.04;	author hope;	state Exp;
branches;
next	;

1.47.1.1
date	96.11.14.12.46.02;	author hope;	state Exp;
branches
	1.47.1.1.1.1;
next	;

1.47.1.1.1.1
date	96.11.28.14.57.48;	author hope;	state Exp;
branches;
next	;

1.47.2.1
date	96.11.22.18.06.26;	author hope;	state Exp;
branches;
next	;

1.47.3.1
date	96.12.17.09.54.28;	author hope;	state Exp;
branches;
next	;

1.47.4.1
date	96.12.17.17.45.08;	author hope;	state Exp;
branches
	1.47.4.1.1.1;
next	;

1.47.4.1.1.1
date	97.02.24.11.34.36;	author hope;	state Exp;
branches;
next	;

1.47.5.1
date	96.12.18.09.39.07;	author hope;	state Exp;
branches;
next	;

1.48.1.1
date	97.05.12.10.31.27;	author hope;	state Exp;
branches
	1.48.1.1.1.1
	1.48.1.1.2.1
	1.48.1.1.3.1;
next	;

1.48.1.1.1.1
date	97.07.28.18.17.19;	author daveb;	state Exp;
branches;
next	1.48.1.1.1.2;

1.48.1.1.1.2
date	97.08.04.16.16.23;	author johnh;	state Exp;
branches
	1.48.1.1.1.2.1.1;
next	;

1.48.1.1.1.2.1.1
date	97.10.07.11.42.10;	author jkbrook;	state Exp;
branches;
next	;

1.48.1.1.2.1
date	97.09.08.17.10.52;	author daveb;	state Exp;
branches;
next	;

1.48.1.1.3.1
date	97.09.09.14.06.26;	author daveb;	state Exp;
branches;
next	;

1.54.1.1
date	97.09.10.19.20.56;	author brucem;	state Exp;
branches;
next	;

1.54.2.1
date	97.09.11.20.52.09;	author daveb;	state Exp;
branches;
next	1.54.2.2;

1.54.2.2
date	97.11.20.17.04.04;	author johnh;	state Exp;
branches;
next	;

1.61.1.1
date	99.04.01.17.55.30;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New unit
@


1.61
log
@[Bug #30346]
Call Capi.getNextWindowPos.
@
text
@(*
 * Copyright (c) 1993 Harlequin Ltd.
 * $Log: _inspector_tool.sml,v $
 * Revision 1.60  1998/03/02  15:07:22  mitchell
 * [Bug #70074]
 * Add depth limit support for signature printing
 *
 * Revision 1.59  1998/02/19  20:15:40  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
 * Revision 1.58  1998/02/18  17:00:54  jont
 * [Bug #70070]
 * Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 * Revision 1.57  1998/02/17  16:41:36  johnh
 * [Bug #30344]
 * Allow windows to retain size and position.
 *
 * Revision 1.56  1998/01/27  15:58:18  johnh
 * [Bug #30071]
 * Merge in Project Workspace changes.
 *
 * Revision 1.55  1997/09/18  15:16:09  brucem
 * [Bug #30153]
 * Remove references to Old.
 *
 * Revision 1.54.2.2  1997/11/20  17:04:04  johnh
 * [Bug #30071]
 * Remove Paths menu.
 *
 * Revision 1.54.2.1  1997/09/11  20:52:09  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
 * Revision 1.54  1997/07/28  13:16:50  brucem
 * [Bug #30202]
 * Add `indicateHiddenChildren' to GraphSpecs.
 *
 * Revision 1.53  1997/07/25  13:31:48  johnh
 * [Bug #30210]
 * Add value printer update function for inspector.
 *
 * Revision 1.52  1997/06/13  11:00:31  johnh
 * [Bug #30175]
 * Combine tools and windows menus.
 *
 * Revision 1.51  1997/06/11  12:40:07  johnh
 * [Bug #30075]
 * Adding numbers to the titles of the duplicated windows.
 *
 * Revision 1.50  1997/05/16  15:35:32  johnh
 * Implementing single menu bar on Windows.
 * Re-organising menus for Motif.
 *
 * Revision 1.49  1997/05/02  17:27:07  jont
 * [Bug #30088]
 * Get rid of MLWorks.Option
 *
 * Revision 1.48  1997/03/06  17:28:18  matthew
 * Fixing equality
 *
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
 * Revision 1.46  1996/09/30  09:39:04  johnh
 * [Bug #1597]
 * [Bug #1597]
 * Used CAPI function reveal to manage the shell and frame in order.
 *
 * Revision 1.45  1996/08/15  12:52:45  daveb
 * [Bug #1519]
 * Replaced make_value_from_item with ShellUtils.value_from_history_entry.
 *
 * Revision 1.44  1996/08/07  10:46:44  andreww
 * [Bug #1521]
 * Propagating changes made to typechecker/_types.sml
 *
 * Revision 1.43  1996/05/28  14:23:51  matthew
 * Attempting to give dialogs more meaningful names
 *
 * Revision 1.42  1996/05/24  16:21:18  daveb
 * Changed to have a single inspector.
 *
 * Revision 1.41  1996/05/24  14:39:15  daveb
 * Improvements to Graph dialogs.
 *
 * Revision 1.40  1996/05/10  14:46:19  daveb
 * Added edit_possible field to ToolData.edit_menu.
 *
 * Revision 1.39  1996/05/07  11:36:22  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.38  1996/05/01  10:50:28  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.37  1996/04/19  16:17:47  daveb
 * Stopped inspector from calling to_front when called with an automatic
 * selection.  Disabled the auto_select menu item in duplicate inspectors.
 *
 * Revision 1.36  1996/04/04  13:44:48  matthew
 * Pass graph layout settings around.
 *
 * Revision 1.35  1996/02/08  15:31:42  daveb
 * Removed sensitivity field from argument to view_options.
 *
 * Revision 1.34  1996/01/25  13:11:42  matthew
 * Changed interface to graph widget
 *
 * Revision 1.33  1996/01/23  16:09:42  daveb
 * Type of GuiUtils.value_menu has changed.
 *
 * Revision 1.32  1996/01/22  16:35:47  matthew
 * Removing (for the moment) abbreviated nodes.
 *
 * Revision 1.31  1996/01/22  11:12:47  daveb
 * Removed history menu.
 *
 * Revision 1.30  1996/01/19  14:55:25  matthew
 * Changing interface to allow inspector reuse.
 *
 * Revision 1.29  1996/01/17  17:24:23  matthew
 * Various small changes
 *
 * Revision 1.28  1995/12/07  14:18:45  matthew
 * Changing interface to edit_menu
 *
 * Revision 1.27  1995/11/23  12:58:12  matthew
 * Fiddling with draw_item
 *
 * Revision 1.26  1995/11/21  14:43:02  matthew
 * Fixing drawing function
 *
 * Revision 1.25  1995/11/16  13:18:37  matthew
 * Changing button resources
 *
 * Revision 1.24  1995/11/15  16:56:22  matthew
 * Adding windows menu
 *
 * Revision 1.23  1995/11/14  14:01:15  matthew
 * Changing capi interface
 *
 * Revision 1.22  1995/10/30  16:14:44  daveb
 * Added display controls dialog to view menu.
 *
 * Revision 1.21  1995/10/25  12:59:59  brianm
 * Ensuring that atomic values cannot be root candidates - they are always
 * expanded otherwise.
 *
 * Revision 1.20  1995/10/19  15:33:43  matthew
 * Fixing having to click twice on "Previous Roots"
 *
 * Revision 1.19  1995/10/18  11:08:55  matthew
 * Adding a SPACE at the bottom of the layout
 *
 * Revision 1.18  1995/10/18  11:01:55  brianm
 * Changed defaults for `show_atoms' from false to true.
 *
 * Revision 1.17  1995/10/15  16:12:10  brianm
 * Added large number of features:
 *   - middle button provides popup-menu:
 *     - Value/Type display
 *     - Show atomic values?
 *     - Equal values shared?
 *     - Display all children?
 *     - Graph Arity/Depth limits.
 *   - right button acts to contract nodes.
 *
 *   - Added Roots/Previous Roots/Original Root facilities.
 *   - Removed list menu
 * Made modifications due to introduction of GraphWidget.Extent etc.
 *
 * Revision 1.15  1995/10/11  09:36:12  brianm
 * Modifications due to changes in GraphSpec.
 *
 * Revision 1.14  1995/10/10  08:56:12  brianm
 * Switched to child-expansion behaviour, modified label printing for strings and
 * gave lables more `surround' (the code for this made easily modifiable).
 *
 * Revision 1.13  1995/10/09  08:42:20  brianm
 * Made the graph update the value and type display - changed print depth in the
 * graph label to 2 - to get a template effect.
 *
 * Revision 1.12  1995/10/06  12:37:10  brianm
 * Modification to take account of change to graph_widget interface.
 *
 * Revision 1.11  1995/10/04  13:26:12  daveb
 * Type of context_menu has changed.
 *
 * Revision 1.10  1995/09/18  14:45:06  brianm
 * Updating by adding Capi Point/Region datatypes
 *
 * Revision 1.9  1995/09/11  13:20:16  matthew
 * Changing top level window initialization
 *
 * Revision 1.8  1995/09/08  15:36:27  matthew
 * Extending GraphSpec type
 *
 * Revision 1.7  1995/09/06  13:56:59  matthew
 * Changing interface to graph widget
 *
 * Revision 1.6  1995/08/30  13:23:42  matthew
 * Renaming layout constructors
 *
 * Revision 1.5  1995/08/10  12:17:02  matthew
 * Adding mak_buttons function to capi
 *
 * Revision 1.4  1995/08/02  15:07:06  matthew
 * Changing interface to grapher
 *
 * Revision 1.3  1995/07/27  10:57:51  matthew
 * Moved capi etc. to gui
 *
 * Revision 1.2  1995/07/27  10:32:47  matthew
 * Moved graph_widget to gui directory
 *
 * Revision 1.1  1995/07/26  14:44:43  matthew
 * new unit
 * New unit
 *
 *  Revision 1.79  1995/07/26  13:20:35  matthew
 *  Adding support for font dimensions etc.
 *
 *  Revision 1.78  1995/07/20  16:17:40  matthew
 *  Adding Graphs
 *
 *  Revision 1.77  1995/07/13  11:54:33  matthew
 *  Moving identifier type to Ident
 *
 *  Revision 1.76  1995/07/07  15:31:31  daveb
 *  Minor changes to layout.
 *
 *  Revision 1.75  1995/07/04  13:53:27  matthew
 *  Capification
 *
 *  Revision 1.74  1995/06/14  13:21:33  daveb
 *  ShellUtils.edit_* functions no longer require a context argument.
 *
 *  Revision 1.73  1995/06/08  13:39:44  daveb
 *  Removed require "output".
 *
 *  Revision 1.72  1995/06/08  09:29:26  daveb
 *  Removed Output widget and debugger function.
 *
 *  Revision 1.71  1995/06/06  16:07:48  daveb
 *  Removed input window.  Moved parent and toplevel buttons to main
 *  window from menu.  Added source text.
 *
 *  Revision 1.70  1995/06/06  10:30:03  daveb
 *  Removed inspect_variable.  Made create inspect current selection on
 *  start-up, instead of evaluating "it".
 *
 *  Revision 1.69  1995/06/01  10:32:09  daveb
 *  Separated user_options into tool-specific and context-specific parts.
 *
 *  Revision 1.68  1995/05/23  14:12:51  matthew
 *  Changing interface to list_select.
 *
 *  Revision 1.67  1995/05/23  08:47:12  daveb
 *  Made contexts only visible if full_menus set.
 *
 *  Revision 1.66  1995/05/04  09:58:46  matthew
 *  Use create for making top level shell
 *  Removing exception EditObject
 *
 *  Revision 1.65  1995/04/28  16:49:08  daveb
 *  Moved all the user_context stuff from ShellTypes into a separate file.
 *
 *  Revision 1.64  1995/04/18  14:50:53  daveb
 *  Changes to context_menu.
 *  
 *  Revision 1.63  1995/03/31  16:41:11  daveb
 *  Added the history number to items in the history.
 *  
 *  Revision 1.62  1995/03/31  13:43:51  daveb
 *  Removed redundant require.
 *  
 *  Revision 1.61  1995/03/17  11:29:07  daveb
 *  Merged ShellTypes.get_context_name and ShellTypes.string_context_name.
 *  
 *  Revision 1.60  1995/03/16  14:32:43  daveb
 *  Removed context_function from register when closing the window.
 *  
 *  Revision 1.59  1995/03/15  16:19:47  daveb
 *  Changed to share current context with other tools..
 *  
 *  Revision 1.58  1995/03/10  15:28:23  daveb
 *  Added calls to register select function in current context.
 *  
 *  Revision 1.57  1995/03/02  17:13:33  daveb
 *  Added inspect_variable, with takes a context and looks the value up
 *  in that.
 *  
 *  Revision 1.56  1995/02/27  13:08:21  daveb
 *  Changed valLabel and typeLabel widgets to text widgets (and renamed
 *  them), so that we can constrain the number of columns.
 *  
 *  Revision 1.55  1995/02/06  16:58:36  daveb
 *  Removed argument from value_menu.
 *  
 *  Revision 1.54  1995/01/13  15:22:45  daveb
 *  Replaced Option structure with references to MLWorks.Option.
 *  
 *  Revision 1.53  1994/11/30  16:16:02  daveb
 *  Simplified Form constraints.
 *  
 *  Revision 1.52  1994/09/21  16:28:29  brianm
 *  Adding value menu ...
 *  
 *  Revision 1.51  1994/08/10  11:41:01  matthew
 *  Add flush output
 *  
 *  Revision 1.50  1994/08/01  10:30:22  daveb
 *  Moved preferences to separate structure.
 *  
 *  Revision 1.48  1994/07/12  16:11:34  daveb
 *  ToolData.works_menu takes different arguments.
 *  
 *  Revision 1.47  1994/06/20  11:33:53  daveb
 *  Moved output window code to separate file.
 *  Replaced context refs with user_contexts.
 *  
 *  Revision 1.46  1994/03/14  16:43:55  matthew
 *  Added untrace value facility
 *  
 *  Revision 1.45  1994/02/23  17:02:19  nosa
 *  Boolean indicator for Monomorphic debugger decapsulation;
 *  Debugger scripts for tracing tool using debugger.
 *  
 *  Revision 1.44  1994/02/02  11:53:29  daveb
 *  Changed substructure of InterMake.
 *  
 *  Revision 1.43  1993/12/20  12:57:49  matthew
 *  Changed name of output window
 *  
 *  Revision 1.42  1993/12/10  15:16:20  daveb
 *  Added context menu, ensured that changes do the right thing, ensured that
 *  new selection is passed on to child tools.
 *  
 *  Revision 1.41  1993/12/09  19:34:46  jont
 *  Added copyright message
 *  
 *  Revision 1.40  1993/12/06  14:37:38  daveb
 *  Ensured that output window is automatically shown when appropriate
 *  preference is set.
 *  
 *  Revision 1.39  1993/11/26  12:25:38  matthew
 *  Improvements to debugger calling.
 *  
 *  Revision 1.38  1993/10/22  16:59:47  daveb
 *  Merged in bug fix.
 *  
 *  Revision 1.37  1993/10/08  16:33:41  matthew
 *   Merging in bug fixes
 *  
 *  Revision 1.36.1.3  1993/10/21  14:03:30  daveb
 *  Changed ToolData.works_menu to take a (unit -> bool) function that
 *  controls whether the Close menu option is enabled.
 *  
 *  Revision 1.36.1.2  1993/10/08  14:02:45  matthew
 *  Added horizontal scrollbar to input pane
 *  Tests for editability and scrollability of objects
 *  Uses history utilities
 *  Added name completion
 *  
 *  Revision 1.36.1.1  1993/08/29  16:47:08  jont
 *  Fork for bug fixing
 *  
 *  Revision 1.36  1993/08/29  16:47:08  daveb
 *  Changed name of file menu to window.
 *  
 *  Revision 1.35  1993/08/25  15:03:22  matthew
 *  Return quit function from ShellUtils.edit_string
 *  
 *  Revision 1.34  1993/08/24  13:44:40  matthew
 *  Improved editing and tracing error handling
 *  
 *  Revision 1.33  1993/08/12  18:05:30  daveb
 *  Removed spurious sharing constraint.
 *  
 *  Revision 1.32  1993/08/11  11:25:19  matthew
 *  Changes to user options
 *  Removed preferences menu
 *  Options update
 *  
 *  Revision 1.31  1993/08/10  14:46:45  nosa
 *  Debugger-window now passed to Inspector-tool functions.
 *  
 *  Revision 1.30  1993/08/10  10:28:17  matthew
 *  Get maximum history length from options
 *  
 *  Revision 1.29  1993/08/03  14:39:12  matthew
 *  Changed history mechanism.
 *  
 *  Revision 1.28  1993/06/16  16:34:40  matthew
 *  Added value menu with edit and trace options
 *  
 *  Revision 1.27  1993/06/04  10:07:16  daveb
 *  Removed popHistory button.
 *  
 *  Revision 1.26  1993/06/03  17:03:51  matthew
 *  Clear text input on selection from history
 *  
 *  Revision 1.25  1993/06/03  11:54:57  matthew
 *  Limit error messages to first line.
 *  
 *  Revision 1.24  1993/05/28  16:05:01  matthew
 *  Added tty_ok value to WINDOWING
 *  Added history
 *  
 *  Revision 1.23  1993/05/26  17:18:30  matthew
 *  Changed error handling for eval
 *  
 *  Revision 1.22  1993/05/13  11:34:33  daveb
 *  All tools now set their own titles and pass them to their options menus.
 *  
 *  Revision 1.21  1993/05/13  10:00:22  matthew
 *  Fixed problem with debugger window.
 *  
 *  Revision 1.20  1993/05/12  13:09:00  matthew
 *  Uses ShellUtils more
 *  
 *  Revision 1.19  1993/05/11  17:17:07  matthew
 *  Changed layout.
 *  Better debugger interface
 *  
 *  Revision 1.18  1993/05/10  16:03:36  daveb
 *  Changed type of ml_debugger.
 *  
 *  Revision 1.17  1993/05/10  14:25:22  daveb
 *  Removed error_info field from ListenerArgs, ShellData and Incremental.options
 *  
 *  Revision 1.16  1993/05/07  17:25:13  matthew
 *  Added sharing constraint
 *  
 *  Revision 1.15  1993/05/07  11:02:15  daveb
 *  Replaced some stuff with GuiUtils.make_scrolllist.
 *  Greatly improved layout.
 *  
 *  Revision 1.14  1993/05/06  16:08:25  matthew
 *  Removed printer_descriptors
 *  
 *  Revision 1.13  1993/05/06  14:57:36  daveb
 *  Added output widget for showing type errors, etc.
 *  
 *  Revision 1.12  1993/05/05  19:11:53  daveb
 *  Renamed inspect to create, and changed its type so that inspectors can
 *  be added to the list of tools on the Works menu.
 *  
 *  Revision 1.11  1993/05/05  12:00:34  matthew
 *  Print type using completion
 *  
 *  Revision 1.10  1993/04/30  14:01:00  matthew
 *  textInput widget now called textIO
 *  
 *  Revision 1.9  1993/04/23  14:53:09  matthew
 *  Immediately inspect "it" on startup.  Added inspect_value function
 *  Simple error handling for user defined methods
 *  
 *  Revision 1.8  1993/04/21  16:45:28  matthew
 *  Cleaned up
 *  
 *  Revision 1.7  1993/04/20  10:25:26  matthew
 *  Renamed Inspector_Values to InspectorValues
 *  
 *  Revision 1.6  1993/04/06  17:50:36  daveb
 *  Names of Callbacks have changed.
 *  
 *  Revision 1.5  1993/04/06  16:25:10  jont
 *  Moved user_options and version from interpreter to main
 *  
 *  Revision 1.4  1993/04/02  17:51:07  matthew
 *  Added text input window with expression evaluation
 *  
 *  Revision 1.2  1993/03/30  16:35:14  matthew
 *  Removed MENUSPEC data constructor
 *  
 *  Revision 1.1  1993/03/26  16:50:09  matthew
 *  Initial revision
 *  
 *)

require "^.utils.__terminal";
require "capi";
require "menus";
require "../main/user_options";
require "../main/preferences";
require "../utils/lists";
require "../utils/lisp";
require "../interpreter/inspector_values";
require "../interpreter/shell_utils";
require "gui_utils";
require "graph_widget";
require "tooldata";

require "inspector_tool";
require "^.basis.__int";

functor InspectorTool (
  structure Capi : CAPI
  structure GraphWidget : GRAPH_WIDGET
  structure UserOptions : USER_OPTIONS
  structure Preferences : PREFERENCES
  structure Lists : LISTS
  structure LispUtils : LISP_UTILS
  structure InspectorValues : INSPECTOR_VALUES
  structure ShellUtils : SHELL_UTILS
  structure Menus : MENUS
  structure GuiUtils : GUI_UTILS
  structure ToolData : TOOL_DATA

  sharing UserOptions.Options = ToolData.ShellTypes.Options =
    ShellUtils.Options

  sharing type UserOptions.user_tool_options =
	       ToolData.ShellTypes.user_options =
               GuiUtils.user_tool_options = ShellUtils.UserOptions
  sharing type UserOptions.user_context_options =
	       GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type InspectorValues.options = UserOptions.Options.options
  sharing type InspectorValues.Type = ShellUtils.Type = GuiUtils.Type
  sharing type Menus.Widget = Capi.Widget = GuiUtils.Widget = ToolData.Widget = GraphWidget.Widget
  sharing type Capi.GraphicsPorts.GraphicsPort = GraphWidget.GraphicsPort
  sharing type Capi.Region = GraphWidget.Region
  sharing type Capi.Point = GraphWidget.Point
  sharing type ToolData.ShellTypes.Context = ShellUtils.Context
  sharing type Menus.OptionSpec = GuiUtils.OptionSpec
  sharing type ToolData.ButtonSpec = Menus.ButtonSpec = GuiUtils.ButtonSpec
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context = ShellUtils.user_context
  sharing type Preferences.preferences = ShellUtils.preferences
  sharing type ShellUtils.user_preferences = Preferences.user_preferences =
  	       ToolData.ShellTypes.user_preferences =
	       GuiUtils.user_preferences
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type ToolData.UserContext.history_entry = ShellUtils.history_entry
) : INSPECTORTOOL =
struct
    structure Options = UserOptions.Options
    structure ShellTypes = ToolData.ShellTypes
    structure UserContext = ToolData.UserContext
    structure Info = ShellUtils.Info

    type Widget = Capi.Widget
    type Point = Capi.Point
    type Region = Capi.Region
    type ToolData = ToolData.ToolData
    type Type = InspectorValues.Type

    fun debug_output s = Terminal.output(s ^"\n")
    val unwind_protect = LispUtils.unwind_protect
    val inspector_number = ref 0

    val do_abbreviations = false

    datatype GraphType = VALUE | TYPE

    datatype GraphOptions =
      GRAPH_OPTIONS of {graph_type : GraphType,
                        show_atoms : bool,
                        show_strings : bool,
                        graph_sharing : bool,
                        graph_arity : int,
                        graph_depth : int,
                        default_visibility : bool,
                        child_position : GraphWidget.ChildPosition,
                        child_expansion : GraphWidget.ChildExpansion,
                        show_root_children : bool,
                        indicateHiddenChildren : bool,
                        orientation : GraphWidget.Orientation,
                        line_style : GraphWidget.LineStyle,
                        horizontal_delta : int,
                        vertical_delta : int,
                        graph_origin : int * int,
                        show_all : bool
                        }

    val default_options = 
      GRAPH_OPTIONS {graph_type = VALUE,
                     show_atoms = true,
                     show_strings = true,
                     graph_sharing = true,
                     graph_arity = 4,
                     graph_depth = 5,
                     default_visibility = false,
                     child_position = GraphWidget.CENTRE,
                     child_expansion = GraphWidget.TOGGLE,
                     show_root_children = false,
                     indicateHiddenChildren = false,
                     orientation = GraphWidget.VERTICAL,
                     line_style = GraphWidget.STRAIGHT,
                     horizontal_delta = 20,
                     vertical_delta = 30,
                     graph_origin = (8,8),
                     show_all = false}

    val posRef = ref NONE
    val sizeRef = ref NONE

    fun make_inspector_window (initial_item, options,
                               select_auto, debugger_print,
                               parent,tooldata,destroy_fun) =
      let
        val ToolData.TOOLDATA
	      {args as ShellTypes.LISTENER_ARGS
                 {user_options, user_context, user_preferences,
                  prompter, mk_xinterface_fn},
               appdata,current_context, motif_context, tools, ...} =
          tooldata

        (* select_auto is now also used to tell whether the inspector was duplicated *)
        val duplicated = not (isSome select_auto)

        val title = 
	  if duplicated then 
	    (inspector_number := (!inspector_number) + 1;
	     "Inspector #" ^ Int.toString (!inspector_number))
	  else
	    "Inspector"

        val (full_menus, update_fns) =
	  case user_preferences
	  of Preferences.USER_PREFERENCES ({full_menus, ...}, update_fns) =>
	    (!full_menus, update_fns)

        val do_automatic =
	  case select_auto
	  of NONE => ref false
	  |  SOME b => ref b

        val (shell,frame,menuBar,_) =
          Capi.make_main_popup {name = "inspector",
				title = title,
				parent = parent,
				contextLabel = false, 
				visibleRef = ref true,
				pos = getOpt (!posRef, Capi.getNextWindowPos())}

        val valText = Capi.make_managed_widget ("valText",Capi.Text,frame, [])
        val typeText = Capi.make_managed_widget ("typeText", Capi.Text,frame, [])
        val srcText = Capi.make_managed_widget  ("srcText", Capi.Text, frame, [])
	val local_context = ref motif_context

        fun get_current_context () =
	  (UserContext.get_context
	     (GuiUtils.get_user_context (!local_context)))

        fun message_fun s =
          Capi.send_message (shell, s)

        fun get_user_tool_options () = user_options

        fun get_user_context_options () =
	  UserContext.get_user_options
	    (GuiUtils.get_user_context (!local_context))


        fun get_compiler_options () =
          UserOptions.new_options (user_options, get_user_context_options())

	fun get_options () =
	  ShellTypes.new_options (user_options, user_context)

        fun print_fn print_options (label, typed_value) =
	  label ^ ": "
	  ^ ShellUtils.print_value
	      (typed_value,print_options,get_current_context())

        local
          val new_user_options = UserOptions.copy_user_tool_options user_options

          fun make_compiler_options () =
              UserOptions.new_options (new_user_options,
                                       get_user_context_options())

          val UserOptions.USER_TOOL_OPTIONS(r,_) = new_user_options

          val _ =
	    ( #show_fn_details(r) := false;
	      #show_exn_details(r) := false;
	      #maximum_depth(r) := 2;
	      #maximum_ref_depth(r) := 1;
	      #maximum_str_depth(r) := 1;
	      #maximum_sig_depth(r) := 1;
	      #maximum_string_size(r) := 1;
	      #maximum_seq_size(r) := 10
	    )

          val normal_compiler_options = make_compiler_options ()

          val graph_string_size = 5

          val _ = (#maximum_string_size(r) := graph_string_size)

          val graph_label_string_options = make_compiler_options ()

          val compiler_options = ref(normal_compiler_options)
          
          val string_abbreviation    = InspectorValues.string_abbreviation
          val normal_string_ellipsis  = !string_abbreviation
          val graph_label_string_ellipsis   = " .."

          fun set_string_abbrev () =
              string_abbreviation := graph_label_string_ellipsis

          fun reset_string_abbrev () =
              string_abbreviation := normal_string_ellipsis

          fun set_print_string_size (ty) =
              if InspectorValues.is_string_type ty
	      then  compiler_options := graph_label_string_options
              else  compiler_options := normal_compiler_options

          fun print_options (Options.OPTIONS{print_options,...})
            = print_options

        in
          
          fun graph_print_value (typed_value as (_,ty)) =
              ( set_print_string_size(ty);
                set_string_abbrev();
		unwind_protect
                   (fn () =>
                       ShellUtils.print_value
                         (typed_value,(print_options (!compiler_options)),
                                       get_current_context())
                   )
                   reset_string_abbrev
              )

          fun graph_print_type (_,ty) =
              ShellUtils.print_type
              (ty,!compiler_options,get_current_context())
        end

	val (initial_str, initial_item) = initial_item

        val current_root = ref initial_item   (* root of value *)
        val current_string = ref ""

        val select_fn = ref (fn () => ())

        val current_item_ref = ref NONE

        fun set_state (item as (value,ty)) =
          let
            val compiler_options = UserOptions.new_options 
                                      (user_options,get_user_context_options())
            val print_options = UserOptions.new_print_options user_options
            val context = get_current_context ()

            fun print_type ty =
              ShellUtils.print_type (ty,compiler_options,context)

            fun print_value value =
              ShellUtils.print_value (item,print_options,context)
            val value_string = print_value item
            val type_string = print_type ty
          in
	    Capi.Text.set_string (valText, value_string);
	    Capi.Text.set_string (typeText, type_string);
            current_string := value_string;
            current_item_ref := SOME (value_string,item)
          end

        fun eq ( (v,_), (v',_) ) =
          let
            fun cast x = (MLWorks.Internal.Value.cast x) : int ref
          in 
            cast v = cast v'
          end


        fun inspect_root (new_item) =
	    ( current_root := new_item;
	      set_state (new_item)
	    )

        (* Inspector Graph - Application State *)

        val hide_child_flag = ref false 
        fun hide_child(_) = !hide_child_flag

        local
          val GRAPH_OPTIONS {graph_type,show_atoms,show_strings,graph_sharing,graph_arity,
                             graph_depth,default_visibility,child_position,child_expansion,
                             show_root_children, indicateHiddenChildren, orientation,line_style,
                             horizontal_delta,vertical_delta,graph_origin,show_all} =
            options
        in
          val graph_type    =    ref graph_type (* VALUE *)
          val show_atoms    =    ref show_atoms (* true *)
          val show_strings  =    ref show_strings (* true *)
          val graph_sharing =    ref graph_sharing (* true *)
          val graph_arity   =    ref graph_arity (* 4 *)
          val graph_depth   =    ref graph_depth (* 5 *)
          val default_visibility = ref default_visibility (* false *)
          val gspec = {child_position = ref child_position,
                       child_expansion = ref child_expansion,
                       default_visibility = default_visibility,
                       show_root_children = ref show_root_children,
                       indicateHiddenChildren = ref indicateHiddenChildren,
                       orientation = ref orientation,
                       line_style = ref line_style,
                       horizontal_delta = ref horizontal_delta,
                       vertical_delta = ref vertical_delta,
                       graph_origin = ref graph_origin,
                       show_all = ref show_all
                       }
        end

        val graph_spec = GraphWidget.GRAPH_SPEC gspec

        fun make_options () =
          GRAPH_OPTIONS {graph_type = !graph_type,
                         show_atoms = !show_atoms,
                         show_strings = !show_strings,
                         graph_sharing = !graph_sharing,
                         graph_arity = !graph_arity,
                         graph_depth = ! graph_depth,
                         default_visibility = !default_visibility,
                         child_position = !(#child_position gspec),
                         child_expansion = !(#child_expansion gspec),
                         show_root_children = !(#show_root_children gspec),
                         indicateHiddenChildren = !(#indicateHiddenChildren gspec),
                         orientation = !(#orientation gspec),
                         line_style = !(#line_style gspec),
                         horizontal_delta = !(#horizontal_delta gspec),
                         vertical_delta = !(#vertical_delta gspec),
                         graph_origin = !(#graph_origin gspec),
                         show_all = !(#show_all gspec)
                         }

        datatype Item = ITEM of ((MLWorks.Internal.Value.T * Type) *
                                 bool ref *
                                 bool ref *
                                 (string * int * int * int) option ref
                                )
            (* Bundle up a node, abbrev. flag, plus
               some cached display information:-

	       ITEM( (v,ty), atomic, abbrev , extents )
		 - v = MLWorks value
		 - ty = MLWorks type
                 - atomic  = true when atomic value (used to control abbreaviation)
		 - abbrev  = true when graph limits are exceeded ...
		 - extents = cached screen extents data
             *)

        fun abbreviate   (ITEM(_,ref(atom),abbrev,_)) = abbrev := not atom
        fun unabbreviate (ITEM(_,_,abbrev,_)) = abbrev := false

        (* String used to signify node abbreviations in the graph *)
        val abbrev_string = " *** "

        fun massage_graph (root,get_children,eq) =
          let
            (* Build list of items *)
            fun list_items init_depth root =
              let
                val items = ref []  (* lists of triples - (depth,node,children) *)

                fun add (depth,node) =
                  if do_abbreviations andalso (depth > !graph_depth) 
                    then ( abbreviate(node); true ) 
                  else
                    let
                      fun lookup (node,[]) = true
                        | lookup (node,(_,a,_)::b) =
                          if eq (node,a) then false
                          else lookup (node,b)
                    in
                      lookup (node,!items)
                    end

                fun scan (item as (depth,node)) =
                    if add item
                    then let val children = get_children item
                         in
			     items := (depth,node,children) :: !items;
		             app scan children
                         end
                    else ()

              in
                scan (init_depth,root);
                rev(!items)
              end

            (* Index the items and return the graph's list of nodes *)
            fun transform_items itemlist =
              let
                exception Index

                fun index' (node,[],n) = raise Index
                  | index' (node,(_,node',_)::rest,n) =
                    if eq(node,node') then n
                    else index' (node,rest,n+1)

                fun index (_,node) = index' (node,itemlist,0)
              in
                MLWorks.Internal.Array.arrayoflist
                (map 
                 (fn (item as (_,node,children)) => (node,map index children))
                 itemlist)
              end

            val itemlist = list_items 0 root

            val nodes = transform_items itemlist
          in

            nodes

          end

        fun make_graph root =
          let
            fun get_children (depth,ITEM (item,_,ref false,_)) = 
		let
                  val new_depth = depth + 1

                  val not_show_atoms   = not(!show_atoms)
                  val not_show_strings = not(!show_strings)

		  fun is_atomic (x as (v,ty)) =
		      ( InspectorValues.is_scalar_value x
			orelse
			( not_show_strings
                          andalso
			  InspectorValues.is_string_type ty
			)
		      )

                  fun new_item(x,abbrev) =
		      ITEM (x,ref(is_atomic x),ref abbrev,ref NONE)

                  fun push_scan (abbrev_flag, x, acc) =
		      if not_show_atoms andalso (is_atomic x) 
		      then acc
		      else (new_depth,new_item(x,abbrev_flag)):: acc

		  fun scan (_,[],acc) = rev acc
		    | scan (n,(_,x)::rest,acc) =
                      let val abbrev = do_abbreviations andalso (n < 0)
			  val new_acc = push_scan(abbrev,x,acc)
                          val rest'  = if abbrev then [] else rest 
                      in
                          scan (n-1,rest',new_acc)
                      end

                  val inspect_items =
                      InspectorValues.get_inspector_values 
                                 (get_compiler_options()) debugger_print item
		in
		  scan (!graph_arity,inspect_items,[])
		end
              | get_children(_,_) = []

            val cast : 'a -> int ref = MLWorks.Internal.Value.cast

            (* This identifies pointer-equal objects *)
            fun equal_values (ITEM ((v1,ty1),_,_,_), ITEM ((v2,ty2),_,_,_)) =
                cast v1 = cast v2 andalso InspectorValues.type_eq (ty1,ty2)

            (* This function only identifies values that are of reference type *)
            (* r1 and r2 are internal identifiers *)
            fun equal_items (ITEM((v1,ty1),_,r1,_), ITEM((v2,ty2),_,r2,_)) = 
              if InspectorValues.is_ref_type ty1 andalso 
                InspectorValues.is_ref_type ty2
                then cast v1 = cast v2
              else r1 = r2

            val equality_fn = if !graph_sharing then equal_values else equal_items

            val root_item = ITEM (root,ref false,ref false,ref NONE)
            val items = massage_graph (root_item, get_children, equality_fn)
          in
            (items,[0])
          end

        fun make_value_graph () = make_graph (!current_root)

        fun item_string (gp,item,abbrev) =
            if abbrev then abbrev_string else
            case !graph_type of
              VALUE => graph_print_value (item)
            | TYPE  => graph_print_type (item)

        fun get_item_data (ITEM (item,_,ref(abbrev),extents),gp) =
          case !extents of
            SOME data => data
          | _ =>
              let
                val s = item_string  (gp,item,abbrev)
                val {font_ascent,font_descent,width,...} =
                          Capi.GraphicsPorts.text_extent (gp,s)
                val data = (s,font_ascent,font_descent,width)
              in
                extents := SOME data;
                data
              end

        val baseline_height = 3

        val surround = 3
        val topleft_width = 1
        val bottomright_width = 3

	val topleft_w      = surround + topleft_width
	val bottomright_w  = surround + bottomright_width
        val tot_w          = topleft_w + bottomright_w
	val bgnd_w         = topleft_width + bottomright_width

	fun item_draw_item (item,selected,gp,Capi.POINT{x,y}) =
	    let
	      val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
	      val left = width div 2
	      val right = width - left

	      val new_x = x - (left+1+topleft_w)
	      val new_y = y - (font_ascent+1+topleft_w)
	      val new_width = (width+tot_w)
	      val new_height = (font_ascent+font_descent+tot_w)

	      val backgnd_region =
		  Capi.REGION {x = new_x, y = new_y,
			       width= new_width, height= new_height}

	      val foregnd_region =
		  Capi.REGION {x = new_x+topleft_width, y = new_y+topleft_width,
			       width= new_width-bgnd_w, height= new_height-bgnd_w}

	      val new_point = Capi.POINT{x=x - left,y=y}
            in
              Capi.GraphicsPorts.draw_rectangle (gp,foregnd_region);
              if selected then
                Capi.GraphicsPorts.with_highlighting
                (gp,Capi.GraphicsPorts.draw_image_string, (gp,s,new_point))
              else Capi.GraphicsPorts.draw_image_string (gp,s,new_point)
	    end

	fun item_extent (item,gp) =
	    let
	      val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
	      val left = width div 2
	      val right = width - left
	    in
	      GraphWidget.EXTENT {
		 left  = left+topleft_w+1,
		 right = right+bottomright_w,
		 up    = font_ascent+topleft_w,
		 down  = font_descent+bottomright_w
              }
	    end

        val {widget=graph_window,
             initialize=init_graph,
             update=update_graph,
             popup_menu=graph_menu,
             set_position,
             set_button_actions,...} = 
          GraphWidget.make ("inspectorGraph","InspectorGraph",title,frame,
                            graph_spec,make_value_graph,
                            item_draw_item,item_extent)

        val new_root_item = ref NONE

        fun graph_select_fn (item as ITEM (entry,_,ref(abbrev),_),reg) =
            if abbrev then 
              new_root_item := SOME(entry)

                 (* This is some (necessary) jiggery-pokery to _postpone_
                    the graph update needed for setting a new root until
		    after the reset of the selection function (internal to the
		    graph widget) has run (because of highlighting).

		    The rest of the required computation is in the
		    function `try_set_new_root()' 
                 *)
            else
	      set_state (entry)

         fun try_set_new_root () =
	     case !new_root_item of
	       SOME(entry) =>
		 ( new_root_item := NONE;
		   inspect_root(entry);
		   update_graph()
		 )
	     | _ => ()

        fun initialize_graph () = init_graph graph_select_fn

        val insp_item_menu_spec = 
            [ Menus.OPTLABEL "Content",
              Menus.OPTRADIO
                 [ GuiUtils.toggle_value("content_value",graph_type,VALUE),
		   GuiUtils.toggle_value("content_type",graph_type,TYPE)
		 ],
              Menus.OPTSEPARATOR,
	      GuiUtils.bool_value("show_all", (#show_all gspec)),
	      GuiUtils.bool_value("show_atoms",show_atoms),
(* Commented out for the moment: ineffective due to repn.
	      GuiUtils.bool_value("show_strings",show_strings),
*)
              GuiUtils.bool_value("graph_sharing",graph_sharing)] @@
            (if do_abbreviations
               then  [Menus.OPTSEPARATOR,
                      GuiUtils.int_value("graph_arity",graph_arity),
                      GuiUtils.int_value("graph_depth",graph_depth)]
             else [])

        val insp_item_popup =
            #1 (Menus.create_dialog
	           (shell, title ^ ": Display Controls","inspectorItemMenu",
                    update_graph, insp_item_menu_spec
                   )
               )

        local
           fun left_action (pa,_) =
               ( ignore(pa ()); try_set_new_root () )

           fun middle_action (_)  = insp_item_popup ()

           fun set_hide_flag ()   = (hide_child_flag := true)
           fun reset_hide_flag () = (hide_child_flag := false)

           fun right_action (pa,_) =
	       ( set_hide_flag (); unwind_protect pa reset_hide_flag )
        in
           val _ = set_button_actions
                      { left = left_action,
		        middle = middle_action,
			right = right_action }
        end

        val quit_funs = ref [fn () => Capi.remove_main_window shell];

        fun do_quit_funs _ = 
          ((* debug_output "Doing destroy actions"; *)
           app (fn f => f ()) (!quit_funs);
           destroy_fun())

        fun set_root (item) =
	    ( current_root := item;
	      set_state (item);
	      update_graph()
	    )
    
        fun set_previous_roots (item,l) =
            ( set_root (item)
            )
    
        val valTitleLabel = 
          Capi.make_managed_widget ("valTitleLabel",Capi.Label,frame,[])
        val typeTitleLabel = 
          Capi.make_managed_widget ("typeTitleLabel",Capi.Label,frame,[])
        val graphLabel = 
          Capi.make_managed_widget ("graphLabel",Capi.Label,frame,[])
        val srcTitleLabel =
	  Capi.make_managed_widget ("srcTitleLabel", Capi.Label, frame, [])

        fun first_line (message) =
          let
            fun aux ([],_) = message
              | aux ((#"\n" :: _),acc) = implode (rev acc)
              | aux ((a::b),acc) = aux (b,a::acc)
          in
            aux (explode message,[])
          end

      fun select_fn item =
	case ShellUtils.value_from_history_entry (item, get_options ()) of
          SOME (s, v) =>
            (Capi.Text.set_string (srcText, s);
             inspect_root (v);
             update_graph ())
        |  _ => ()

      fun mk_tooldata () =
        ToolData.TOOLDATA
        {args = ShellTypes.LISTENER_ARGS
         {user_options = user_options,
          user_preferences = user_preferences,
          user_context =
          GuiUtils.get_user_context (!local_context),
          prompter = prompter,
          mk_xinterface_fn = mk_xinterface_fn},
         current_context = current_context,
         appdata = appdata,
         motif_context = !local_context,
         tools = tools}

        fun duplicate value =
          (ignore(make_inspector_window
	     (value, make_options(), NONE, debugger_print,
	      parent, mk_tooldata(), fn _ => ()));
           ())

	val sep_size = 10

        fun close_window _ =
          (do_quit_funs ();
           Capi.destroy shell)

        fun storeSizePos () = 
	  (sizeRef := SOME (Capi.widget_size shell);
	   posRef := SOME (Capi.widget_pos shell))

        fun caller_update _ = 
	  if isSome (!current_item_ref) then 
	    set_state (#2 (valOf (!current_item_ref)))
	  else
	    ()

        val view_menu =
          GuiUtils.view_options
            {parent = shell, title = title, user_options = user_options,
	     user_preferences = user_preferences,
             caller_update_fn = caller_update,
	     view_type = [GuiUtils.VALUE_PRINTER]}

        fun get_value () = !current_item_ref
          
	val value_menu = 
	  GuiUtils.value_menu
	     {parent = shell,
	      user_preferences = user_preferences,
	      inspect_fn = NONE,
	      get_value = get_value,
	      enabled = true,
	      tail = []}
	val values = ToolData.extract value_menu
	val view = ToolData.extract view_menu 

	fun get_user_context () = GuiUtils.get_user_context (!local_context)

	val menuSpec =
	  [ToolData.file_menu [("save", fn _ =>
		       GuiUtils.save_history (false, get_user_context (), shell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), shell),
		       fn _ => not (UserContext.null_history (get_user_context ()))),
	    ("close", close_window, fn _ => true)],
           ToolData.edit_menu
           (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME (fn _ => Capi.clipboard_set (shell,!current_string)),
             delete = NONE,
	     edit_possible = fn _ => false,
             selection_made = fn _ => !current_string <> "",
	     delete_all = NONE,
	     edit_source = [value_menu]}),
           (* Need a better interface here -- what is the currently selected object? *)

	   ToolData.tools_menu (mk_tooldata, 
				fn () => GuiUtils.get_user_context (!local_context)),
	   ToolData.usage_menu (values @@ view @@
	     [("duplicate", 
		fn _ => case get_value () of SOME x => duplicate x | _ => (),
                fn _ => case get_value () of SOME x => true | _ => false),
	      ("graph", graph_menu, fn _ => true),
	      ("insp_item", insp_item_popup, fn _ => true)],
	     [("autoSelection",
	       fn _ => !do_automatic,
               fn b => do_automatic := b,
               fn _ => case select_auto of NONE => false | _ => true)]),
	   ToolData.debug_menu values]
      in
        quit_funs := Menus.quit :: (!quit_funs);
        quit_funs := storeSizePos :: (!quit_funs);
	Menus.make_submenus (menuBar, menuSpec);
        Capi.Layout.lay_out
        (frame, !sizeRef,
         [Capi.Layout.MENUBAR menuBar,
          Capi.Layout.SPACE,
          Capi.Layout.FIXED srcTitleLabel,
          Capi.Layout.FIXED srcText,
          Capi.Layout.FIXED valTitleLabel,
          Capi.Layout.FIXED valText,
          Capi.Layout.FIXED typeTitleLabel,
          Capi.Layout.FIXED typeText,
          Capi.Layout.FIXED graphLabel,
          Capi.Layout.FLEX  graph_window,
          Capi.Layout.SPACE]);
        Capi.Text.set_string (srcText, initial_str);
        Capi.Callback.add (frame, Capi.Callback.Destroy, do_quit_funs);
	inspect_root (!current_root);
        Capi.reveal frame;
        initialize_graph ();
        fn (auto,str,item) => 
          if auto andalso not (!do_automatic) then
	    ()
          else
            (inspect_root (item);
             update_graph ();
	     Capi.reveal shell;    (* Required for MSWindows to bring up the shell again *)
	     Capi.reveal frame;    (* Required for unix since frame needs to be managed 
				    * AFTER the shell. *)
             Capi.Text.set_string (srcText,str);
	     if auto then
	       ()
	     else
               Capi.to_front shell)
      end

    local
      val display_fun = ref NONE
      fun destroy_fun _ = display_fun := NONE
    in
      fun inspect_value (parent,debugger_print,tooldata) = 
        fn auto =>
        fn (str,v) =>
        case !display_fun of 
          SOME f => f (auto,str,v)
        | _ =>
            if auto then ()
            else
              let
                val f =
		  make_inspector_window
		    ((str,v), default_options, SOME false,
		     debugger_print, parent, tooldata, destroy_fun)
              in
                display_fun := SOME f
              end
    end

  end
@


1.61.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a3 4
 * Revision 1.61  1998/03/31  16:02:40  johnh
 * [Bug #30346]
 * Call Capi.getNextWindowPos.
 *
@


1.60
log
@[Bug #70074]
Add depth limit support for signature printing
@
text
@d4 4
d639 1
a639 1
				pos = getOpt (!posRef, (100,100))}
@


1.59
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@d4 4
d682 1
@


1.58
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d4 4
d1116 1
a1116 1
               ( pa (); try_set_new_root () )
d1190 1
a1190 1
          (make_inspector_window
d1192 1
a1192 1
	      parent, mk_tooldata(), fn _ => ());
@


1.57
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d4 4
d473 1
d540 1
a540 1
    fun debug_output s = MLWorks.IO.output(MLWorks.IO.terminal_out,s ^"\n")
@


1.56
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d4 4
d582 3
d617 6
a622 1
          Capi.make_main_popup ("inspector",title,parent,false, ref true)
d1192 4
d1261 1
d1264 1
a1264 1
        (frame,
@


1.55
log
@[Bug #30153]
Remove references to Old.
@
text
@d4 11
d1242 1
a1242 2
	   ToolData.debug_menu values,
	   GuiUtils.paths_menu shell]
@


1.54
log
@[Bug #30202]
Add `indicateHiddenChildren' to GraphSpecs.
@
text
@d4 4
a466 1
require "^.basis.__old";
@


1.54.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a3 4
 * Revision 1.54  1997/07/28  13:16:50  brucem
 * [Bug #30202]
 * Add `indicateHiddenChildren' to GraphSpecs.
 *
@


1.54.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a3 3
 * Revision 1.54.2.1  1997/09/11  20:52:09  daveb
 * branched from trunk for label MLWorks_workspace_97
 *
d1232 2
a1233 1
	   ToolData.debug_menu values]
@


1.54.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a3 4
 * Revision 1.54  1997/07/28  13:16:50  brucem
 * [Bug #30202]
 * Add `indicateHiddenChildren' to GraphSpecs.
 *
@


1.53
log
@[Bug #30210]
Add value printer update function for inspector.
@
text
@d4 4
d536 1
d556 1
d745 1
a745 1
                             show_root_children, orientation,line_style,
d760 1
d783 1
@


1.52
log
@[Bug #30175]
Combine tools and windows menus.
@
text
@d4 4
a628 2
          val standard_compiler_options  = make_compiler_options ()

d632 3
a634 1
	    ( #maximum_depth(r) := 2;
d672 1
a672 2
              (
	        set_print_string_size(ty);
d834 1
d1158 6
d1168 1
a1168 1
             caller_update_fn = fn _ => (),
@


1.51
log
@[Bug #30075]
Adding numbers to the titles of the duplicated windows.
@
text
@d4 4
d1085 1
a1085 1
        val quit_funs = ref [];
d1211 1
a1211 2
	   GuiUtils.paths_menu shell,
           ToolData.windows_menu ()]
@


1.50
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d4 4
d452 1
d507 1
a507 1
    val inspector_number = ref 1
d561 9
a569 1
        val title = "Inspector"
@


1.49
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d4 4
d569 1
a569 1
          Capi.make_main_popup ("inspector",title,parent,false)
d1137 1
a1137 1
        val view_options =
d1146 13
a1158 30
        val view_menu =
          Menus.CASCADE
            ("view",
             view_options @@
             [Menus.PUSH ("graph", graph_menu, fn _ => true),
              Menus.PUSH ("insp_item", insp_item_popup, fn _ => true)],
             fn _ => true)

        val main_menu =
          Menus.CASCADE
          ("main",
           [Menus.TOGGLE
	      ("autoSelection",
               fn _ => !do_automatic,
               fn b => do_automatic := b,
               fn _ => case select_auto of NONE => false | _ => true),
            Menus.PUSH
	      ("duplicate",
               fn _ =>
                 case get_value () of
                   SOME x => duplicate x
                 | _ => (),
               fn _ =>
                 case get_value () of
                   SOME x => true
                 | _ => false),
            Menus.SEPARATOR,
            Menus.PUSH ("close", close_window, fn _ => true)],
           fn _ => true)
              
d1160 9
a1168 1
	  [main_menu,
d1177 2
a1178 2
	     tail = []}),
           view_menu,
d1180 15
a1194 6
	   GuiUtils.value_menu
	     {parent = shell,
	      user_preferences = user_preferences,
	      inspect_fn = NONE,
	      get_value = get_value,
	      tail = []},
d1197 2
a1198 1
        Menus.make_submenus (menuBar, menuSpec);
@


1.48
log
@Fixing equality
@
text
@d4 3
a488 1
    structure Option = MLWorks.Option
d763 1
a763 1
                                 (string * int * int * int) Option.option ref
@


1.48.1.1
log
@branched from 1.48
@
text
@a3 3
 * Revision 1.48  1997/03/06  17:28:18  matthew
 * Fixing equality
 *
@


1.48.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:27  hope
 * branched from 1.48
 *
@


1.48.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:27  hope
 * branched from 1.48
 *
@


1.48.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a3 3
 * Revision 1.48.1.1  1997/05/12  10:31:27  hope
 * branched from 1.48
 *
@


1.48.1.1.1.2
log
@[Bug #30210]
Merging - Added caller update function for applying value printer changes.
@
text
@a3 4
 *
 * Revision 1.48.1.1.1.1  1997/07/28  18:17:19  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d608 2
d613 1
a613 3
	    ( #show_fn_details(r) := false;
	      #show_exn_details(r) := false;
	      #maximum_depth(r) := 2;
d651 2
a652 1
              ( set_print_string_size(ty);
a813 1

a1136 6
        fun caller_update _ = 
	  if isSome (!current_item_ref) then 
	    set_state (#2 (valOf (!current_item_ref)))
	  else
	    ()

d1141 1
a1141 1
             caller_update_fn = caller_update,
@


1.48.1.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a3 4
 * Revision 1.48.1.1.1.2  1997/08/04  16:16:23  johnh
 * [Bug #30210]
 * Merging - Added caller update function for applying value printer changes.
 *
@


1.47
log
@moving String from toplevel
@
text
@d4 3
d885 1
d889 7
a895 1
            fun equal_items (ITEM(_,_,r1,_), ITEM(_,_,r2,_)) = (r1 = r2)
@


1.47.5.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
@


1.47.4.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
@


1.47.4.1.1.1
log
@branched from 1.47.4.1
@
text
@a3 3
 * Revision 1.47.4.1  1996/12/17  17:45:08  hope
 * branched from 1.47
 *
@


1.47.3.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
@


1.47.2.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
@


1.47.1.1
log
@branched from 1.47
@
text
@a3 3
 * Revision 1.47  1996/10/09  15:59:06  io
 * moving String from toplevel
 *
@


1.47.1.1.1.1
log
@branched from 1.47.1.1
@
text
@a3 3
 * Revision 1.47.1.1  1996/11/14  12:46:02  hope
 * branched from 1.47
 *
@


1.46
log
@[Bug #1597]
[Bug #1597]
Used CAPI function reveal to manage the shell and frame in order.
@
text
@d4 5
d437 1
d556 2
a557 2
	  of Option.NONE => ref false
	  |  Option.SOME b => ref b
d666 1
a666 1
        val current_item_ref = ref Option.NONE
d686 1
a686 1
            current_item_ref := Option.SOME (value_string,item)
d802 1
a802 1
		             Lists.iterate scan children
d856 1
a856 1
		      ITEM (x,ref(is_atomic x),ref abbrev,ref Option.NONE)
d889 1
a889 1
            val root_item = ITEM (root,ref false,ref false,ref Option.NONE)
d905 1
a905 1
            Option.SOME data => data
d913 1
a913 1
                extents := Option.SOME data;
d980 1
a980 1
        val new_root_item = ref Option.NONE
d984 1
a984 1
              new_root_item := Option.SOME(entry)
d999 2
a1000 2
	       Option.SOME(entry) =>
		 ( new_root_item := Option.NONE;
d1056 1
a1056 1
           Lists.iterate (fn f => f ()) (!quit_funs);
d1081 1
a1081 1
              | aux (("\n" :: _),acc) = String.implode (rev acc)
d1084 1
a1084 1
            aux (String.explode message,[])
d1089 1
a1089 1
          MLWorks.Option.SOME (s, v) =>
d1111 1
a1111 1
	     (value, make_options(), Option.NONE, debugger_print,
d1145 1
a1145 1
               fn _ => case select_auto of Option.NONE => false | _ => true),
d1150 1
a1150 1
                   Option.SOME x => duplicate x
d1154 1
a1154 1
                   Option.SOME x => true
d1164 4
a1167 4
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME (fn _ => Capi.clipboard_set (shell,!current_string)),
             delete = Option.NONE,
d1176 1
a1176 1
	      inspect_fn = Option.NONE,
d1217 2
a1218 2
      val display_fun = ref Option.NONE
      fun destroy_fun _ = display_fun := Option.NONE
d1224 1
a1224 1
          Option.SOME f => f (auto,str,v)
d1231 1
a1231 1
		    ((str,v), default_options, Option.SOME false,
d1234 1
a1234 1
                display_fun := Option.SOME f
@


1.46.2.1
log
@branched from 1.46
@
text
@a3 5
 * Revision 1.46  1996/09/30  09:39:04  johnh
 * [Bug #1597]
 * [Bug #1597]
 * Used CAPI function reveal to manage the shell and frame in order.
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a3 5
 * Revision 1.46  1996/09/30  09:39:04  johnh
 * [Bug #1597]
 * [Bug #1597]
 * Used CAPI function reveal to manage the shell and frame in order.
 *
@


1.45
log
@[Bug #1519]
Replaced make_value_from_item with ShellUtils.value_from_history_entry.
@
text
@d4 4
d1200 3
@


1.45.1.1
log
@branched from 1.45
@
text
@a3 4
 * Revision 1.45  1996/08/15  12:52:45  daveb
 * [Bug #1519]
 * Replaced make_value_from_item with ShellUtils.value_from_history_entry.
 *
@


1.44
log
@[Bug #1521]
Propagating changes made to typechecker/_types.sml
@
text
@d4 4
d466 1
a486 16
    fun make_value_from_item
      (item as UserContext.ITEM (_, id, context, _, src), options) =
      case UserContext.history_entry_name item of
        Option.SOME s =>
          (let
            val value =
              ShellUtils.eval
              Info.null_options
              (s,options, context, fn f => fn a => f a)
          in
            MLWorks.Option.SOME (src, value)
          end
          handle _ => Option.NONE)
      |  _ =>
           MLWorks.Option.NONE

d1078 1
a1078 1
	case make_value_from_item (item, get_options ()) of
@


1.43
log
@Attempting to give dialogs more meaningful names
@
text
@d4 3
d447 1
d581 4
d596 3
a598 2
          fun make_print_options () =
              UserOptions.new_print_options new_user_options
d600 1
a600 1
          val standard_print_options  = make_print_options ()
d612 1
a612 1
          val normal_print_options = make_print_options ()
d618 1
a618 1
          val graph_label_string_options = make_print_options ()
d620 1
a620 1
          val print_options = ref(normal_print_options)
d634 6
a639 2
	      then  print_options := graph_label_string_options
              else  print_options := normal_print_options
d649 2
a650 1
                         (typed_value,(!print_options),get_current_context())
d657 1
a657 1
              (ty,standard_print_options,get_current_context())
d671 2
d677 1
a677 1
              ShellUtils.print_type (ty,print_options,context)
d874 2
a875 1
                      InspectorValues.get_inspector_values debugger_print item
@


1.42
log
@Changed to have a single inspector.
@
text
@d4 3
d960 1
a960 1
          GraphWidget.make ("inspectorGraph","InspectorGraph",frame,
d1013 1
a1013 1
	           (shell, "Display Controls","inspectorItemMenu",
@


1.41
log
@Improvements to Graph dialogs.
@
text
@d4 3
d540 2
a541 9
        val title =
          let
            val n = !inspector_number
            fun p (s, 0) = s
              | p (s, n) = p (String.chr (48+(n mod 10)) ^ s, n div 10)
          in
            inspector_number := n+1;
            "Inspector #" ^ p ("", n)
          end
d1194 5
a1198 5
    fun inspect_value (parent,debugger_print,tooldata) = 
      let
        val display_fun = ref Option.NONE
        fun destroy_fun _ = display_fun := Option.NONE
      in
d1214 1
a1214 1
      end
@


1.40
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d4 3
a740 20
        val insp_item_menu_spec = 
            [ Menus.OPTLABEL "Content",
              Menus.OPTRADIO
                 [
		   GuiUtils.toggle_value("content_value",graph_type,VALUE),
		   GuiUtils.toggle_value("content_type",graph_type,TYPE)
		 ],

              Menus.OPTSEPARATOR,
	      GuiUtils.bool_value("show_atoms",show_atoms),
(* Commented out for the moment: ineffective due to repn.
	      GuiUtils.bool_value("show_strings",show_strings),
*)
              GuiUtils.bool_value("graph_sharing",graph_sharing)] @@
            (if do_abbreviations
               then  [Menus.OPTSEPARATOR,
                      GuiUtils.int_value("graph_arity",graph_arity),
                      GuiUtils.int_value("graph_depth",graph_depth)]
             else [])

a964 14
        val { reposition_fn,
              redisplay_fn,
              popup_fn=seln_popup_fn,
              h_position,
              v_position, ...
            } = GraphWidget.reposition_graph_selection(graph_window,set_position)

        (* This is where the default values are set *)
        (* Should read these things from a preference file perhaps *)
        val _ = (
		  h_position := GraphWidget.NONE;
		  v_position := GraphWidget.NONE
                )

d968 1
a968 2
            if abbrev
	    then 
d979 2
a980 1
            else ( reposition_fn(reg); set_state (entry) )
d993 18
a1010 1
	val seln_posn_popup = seln_popup_fn(shell)
d1111 1
a1111 1
	     view_type = GuiUtils.VIEW_ALL}
d1120 1
a1120 2
              Menus.PUSH ("insp_item", insp_item_popup, fn _ => true),
              Menus.PUSH ("graph_seln_posn", seln_posn_popup, fn _ => true)],
@


1.39
log
@Array moving to MLWorks.Array
@
text
@d4 3
d1168 1
@


1.38
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d4 6
d822 1
a822 1
                Array.arrayoflist
@


1.37
log
@Stopped inspector from calling to_front when called with an automatic
selection.  Disabled the auto_select menu item in duplicate inspectors.
@
text
@d4 4
d454 1
a454 1
    fun debug_output s = output(MLWorks.IO.terminal_out,s ^"\n")
d529 1
a529 1
              | p (s, n) = p (chr (48+(n mod 10)) ^ s, n div 10)
d1071 1
a1071 1
              | aux (("\n" :: _),acc) = implode (rev acc)
d1074 1
a1074 1
            aux (explode message,[])
@


1.36
log
@Pass graph layout settings around.
@
text
@d4 3
d512 1
a512 1
                               debugger_print,
d536 4
a539 1
        val do_automatic = ref false
d1096 3
a1098 2
          (make_inspector_window (value,make_options(),
                                  debugger_print,parent,mk_tooldata(),fn _ => ());
d1128 15
a1142 13
           [Menus.TOGGLE ("autoSelection",
                            fn _ => !do_automatic,
                            fn b => do_automatic := b,
                            fn _ => true),
            Menus.PUSH ("duplicate",
                        fn _ =>
                        case get_value () of
                          Option.SOME x => duplicate x
                        | _ => (),
                        fn _ =>
                        case get_value () of
                          Option.SOME x => true
                        | _ => false),
d1144 1
a1144 3
            Menus.PUSH ("close",
                        close_window,
                        fn _ => true)],
d1193 4
a1196 1
             Capi.to_front shell)
d1212 4
a1215 2
                val f = make_inspector_window ((str,v),default_options,debugger_print,parent,
                                               tooldata,destroy_fun)
@


1.35
log
@Removed sensitivity field from argument to view_options.
@
text
@d4 3
d469 41
a509 1
    fun make_inspector_window (initial_item, debugger_print,
d668 31
a698 1
        datatype GraphType = VALUE | TYPE
d700 18
a717 7
        val graph_type    =    ref VALUE
        val show_atoms    =    ref true
        val show_strings  =    ref true
        val graph_sharing =    ref true
        val graph_arity   =    ref 4
        val graph_depth   =    ref 5
        val default_visibility = ref false
a738 16
        val hide_child_flag = ref false 
        fun hide_child(_) = !hide_child_flag

        val graph_spec =
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.CENTRE,
                                  child_expansion = GraphWidget.SOMETIMES(hide_child),
				  default_visibility = default_visibility,
				  show_root_children = false,
                                  orientation = GraphWidget.VERTICAL,
                                  line_style = GraphWidget.STRAIGHT,
                                  horizontal_delta = 20,
                                  vertical_delta = 30,
				  graph_origin = (8,8),
                                  show_all = false  (* Make graph actively expand *)
                                 }

d1090 2
a1091 1
          (make_inspector_window (value,debugger_print,parent,mk_tooldata(),fn _ => ());
d1202 1
a1202 1
                val f = make_inspector_window ((str,v),debugger_print,parent,
@


1.34
log
@Changed interface to graph widget
@
text
@d4 3
d469 5
a473 6
        val ToolData.TOOLDATA {args as ShellTypes.LISTENER_ARGS
                               {user_options, user_context, user_preferences,
                                prompter, mk_xinterface_fn},
                               appdata as ToolData.APPLICATIONDATA 
                               {applicationShell,...},
                               current_context, motif_context, tools, ...} =
a1035 1
	     sensitivity = GuiUtils.CONTEXT_ONLY,
d1111 7
a1117 7
        if auto andalso not (!do_automatic)
          then ()
        else
          (inspect_root (item);
           update_graph ();
           Capi.Text.set_string (srcText,str);
           Capi.to_front shell)
@


1.33
log
@Type of GuiUtils.value_menu has changed.
@
text
@d4 3
d841 1
a841 1
	fun item_draw_item (item,gp,Capi.POINT{x,y}) =
d863 4
a866 1
              Capi.GraphicsPorts.draw_image_string (gp,s,new_point)
@


1.32
log
@Removing (for the moment) abbreviated nodes.
@
text
@d4 3
a1065 1
           ToolData.windows_menu (),
d1072 2
a1073 1
             selection_made = fn _ => !current_string <> ""}),
d1076 7
a1082 1
	   GuiUtils.value_menu (shell, user_preferences, Option.NONE, get_value)]
@


1.31
log
@Removed history menu.
@
text
@d4 3
d439 2
d448 1
a448 1
              Info.default_options
a450 2
            (* This should be done by with_standard_output *)
            MLWorks.IO.flush_out std_out;
d640 6
a645 6
              GuiUtils.bool_value("graph_sharing",graph_sharing),

              Menus.OPTSEPARATOR,
              GuiUtils.int_value("graph_arity",graph_arity),
              GuiUtils.int_value("graph_depth",graph_depth)
            ]
d693 11
a703 9
                  if (depth > !graph_depth) then ( abbreviate(node); true ) else
                  let
                    fun lookup (node,[]) = true
                      | lookup (node,(_,a,_)::b) =
                        if eq (node,a) then false
                        else lookup (node,b)
                  in
                    lookup (node,!items)
                  end
d773 1
a773 1
                      let val abbrev = (n < 0)
@


1.30
log
@Changing interface to allow inspector reuse.
@
text
@d4 3
a486 2
        val buttonPane = Capi.make_managed_widget ("buttonPane", Capi.RowColumn, frame, []);

a598 3
        val roots = ref []
        val previous_roots = ref []

a605 2
        fun add_action a =
	  ShellUtils.add_history_item (a, roots, eq, user_preferences)
d608 1
a608 2
	    ( add_action (new_item);
	      current_root := new_item;
d898 1
a898 2
              (new_root_item := Option.SOME(entry);
               previous_roots := entry :: !previous_roots)
d962 1
a962 2
            ( previous_roots := l;
	      set_root (item)
a964 41
	fun prev_root () =
	      case !previous_roots of
		_ :: (l as (item :: _)) => set_previous_roots(item,l)
	      | _ =>
                  (case !roots of
                     [_] => ()
                   | l as (item :: _) => set_previous_roots(item,l)
                   | _ => ()
                       ) 

        fun original_root _ =
          let 
            fun doit [] = ()
              | doit (l as [the_root]) =
                set_previous_roots (the_root,the_root::(!roots))
              | doit (a::l) = doit l
          in
            doit (!roots)
          end

        fun make_roots_menu () =
          let
            val print_options = UserOptions.new_print_options user_options 
            val context = get_current_context()

            fun print_value item =
              ShellUtils.trim_history_string
		(ShellUtils.print_value (item, print_options, context),
		 user_preferences)

            fun doone (item) =
              Menus.PUSH ( print_value item,
                           (fn _ => set_root item),
                           (fn _ => true)
			 )

            val items = rev(!roots)
          in
            (map doone items)
          end

a986 2
             roots := [];
             previous_roots := [v];
d1068 1
a1068 2
	   GuiUtils.value_menu (shell, user_preferences, Option.NONE, get_value),
           Menus.DYNAMIC ("roots", make_roots_menu, fn _ => true)]
a1069 8
        Menus.make_buttons
        (buttonPane,
         [Menus.PUSH ("previousRoots",
                      prev_root,
                      fn _ => true),
          Menus.PUSH ("original",
                      original_root,
                      fn _ => true)]);
a1082 1
          Capi.Layout.FIXED buttonPane,
a1086 1
        previous_roots := [!current_root];
a1094 1
           previous_roots := [item];
@


1.29
log
@Various small changes
@
text
@d4 3
d401 1
a401 1
  sharing type InspectorValues.Type = ShellUtils.Type
d423 1
a428 19

    local
       structure IO = MLWorks.RawIO 

       val std_out = IO.std_out
       val output  = IO.output

       structure Value = MLWorks.Internal.Value
       val DEFAULT = Value.DEFAULT
       val print = Value.print
    in
       fun debugP s v =
	   ( output(std_out, s);
	     print(DEFAULT,std_out,v);
	     output(std_out, "\n");
	     v
	   )
    end

a429 1

a430 1

d433 2
a434 2
    fun make_value_from_roots_menu
	  (item as UserContext.ITEM (_, id, context, _, src), options) =
d437 1
a437 1
          let
d447 1
d451 2
a452 10
    fun make_inspector_window
	  debugger_print
          (mk_initial_item,
           tooldata as ToolData.TOOLDATA
	     {args as ShellTypes.LISTENER_ARGS
                {user_options, user_context, user_preferences,
		 prompter, mk_xinterface_fn},
              appdata as ToolData.APPLICATIONDATA 
                {applicationShell,...},
              current_context, motif_context, tools, ...}) =
d454 7
d476 4
a479 2
        val (shell,frame,menuBar,contextLabel) =
          Capi.make_main_window ("inspector",title,applicationShell,full_menus)
d570 1
a570 2
	val (initial_str, initial_item) =
	  mk_initial_item (user_context, user_options)
d575 4
d594 2
a595 1
            current_string := value_string
d956 4
a959 1
        fun do_quit_funs _ = Lists.iterate (fn f => f ()) (!quit_funs)
a1021 12
        fun set_context_label user_context =
	  case contextLabel
	  of MLWorks.Option.SOME w =>
            let
              val context_name =
	        UserContext.get_context_name user_context
              val cstring = "Context: " ^ context_name
            in
              Capi.set_label_string (w, cstring)
            end
	  |  MLWorks.Option.NONE => ()

d1032 7
a1038 7
	case make_value_from_roots_menu (item, get_options ())
	of MLWorks.Option.SOME (s, v) =>
          (Capi.Text.set_string (srcText, s);
	   roots := [];
           previous_roots := [v];
           inspect_root (v);
           update_graph ())
d1041 17
a1057 57
      fun sense_selection user_options =
	case UserContext.get_selected
	       (GuiUtils.get_user_context (!local_context), user_options)
	of MLWorks.Option.NONE => ()
	|  MLWorks.Option.SOME entry => select_fn entry

      val select_fn_key =
	ref (UserContext.add_select_fn
	       (GuiUtils.get_user_context (!local_context),
		(select_fn, get_user_tool_options)))

      fun set_context c =
        (UserContext.remove_select_fn
	   (GuiUtils.get_user_context (!local_context), !select_fn_key);
	 set_context_label (GuiUtils.get_user_context c);
	 select_fn_key :=
	   UserContext.add_select_fn
	     (GuiUtils.get_user_context c,
	      (select_fn, get_user_tool_options));
         roots := [];
	 local_context := c;
	 case UserContext.get_selected
		(GuiUtils.get_user_context c, user_options)
	 of MLWorks.Option.SOME x => select_fn x
	 |  MLWorks.Option.NONE => ())

      val context_key =
	ToolData.add_context_fn
          (current_context, (set_context, get_user_tool_options, ToolData.ALL))

      val _ =
	quit_funs :=
          (fn _ => UserContext.remove_select_fn
		     (GuiUtils.get_user_context (!local_context),
		      !select_fn_key))
	  :: (fn _ => ToolData.remove_context_fn
			(current_context, context_key))
	  :: !quit_funs

      fun select_context user_context =
        (set_context user_context;
         ToolData.set_current
           (current_context, context_key, user_options, user_context))

	fun mk_tooldata () =
          ToolData.TOOLDATA
	    {args = ShellTypes.LISTENER_ARGS
                      {user_options = user_options,
                       user_preferences = user_preferences,
		       user_context =
			 GuiUtils.get_user_context (!local_context),
		       prompter = prompter,
		       mk_xinterface_fn = mk_xinterface_fn},
	     current_context = current_context,
             appdata = appdata,
	     motif_context = !local_context,
             tools = tools}
d1069 2
a1070 2
             caller_update_fn = sense_selection,
	     sensitivity = GuiUtils.NO_SET_SELECTION,
d1073 2
d1084 22
d1107 1
a1107 3
	  [ToolData.works_menu
	    (mk_tooldata, close_window, fn () => true,
	     fn () => GuiUtils.get_user_context (!local_context)),
d1117 2
a1118 1
	   GuiUtils.value_menu (shell, user_preferences, Option.NONE, fn _ => Option.NONE),
d1132 3
a1134 5
         [Capi.Layout.MENUBAR menuBar] @@
         (case contextLabel of
            MLWorks.Option.SOME w => [Capi.Layout.FIXED w]
          | _ => [Capi.Layout.SPACE]) @@
         [Capi.Layout.FIXED srcTitleLabel,
d1148 11
a1158 3
	set_context_label (user_context);
        Capi.initialize_toplevel shell;
        initialize_graph ()
d1161 1
a1161 1
    fun create tooldata =
d1163 2
a1164 5
	fun mk_initial_item (user_context, user_options) =
          (case ShellUtils.value_from_user_context (user_context,user_options) of
             MLWorks.Option.NONE =>
               ("()", ShellUtils.default_dynamic)
           | MLWorks.Option.SOME item => item)
d1166 13
a1178 4
        make_inspector_window
        false
        (mk_initial_item, tooldata);
        ()
a1180 2
    fun inspect_value debugger_print (str, v, tooldata) =
      make_inspector_window debugger_print (fn _ => (str, v), tooldata)
@


1.28
log
@Changing interface to edit_menu
@
text
@d4 3
a363 1
require "../basics/ident";
a380 1
  structure Ident : IDENT
a391 1
  sharing type Ident.Identifier = ToolData.UserContext.identifier
d406 1
a406 1
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
d451 6
a456 6
	  (UserContext.ITEM (_, id, context, _, src), options) =
      case id
      of Ident.VALUE (Ident.VAR s) =>
	let
	  val value =
	    ShellUtils.eval
d458 6
a463 7
              (Ident.Symbol.symbol_name s,
	       options, context, fn f => fn a => f a)
	in
          (* This should be done by with_standard_output *)
          MLWorks.IO.flush_out std_out;
          MLWorks.Option.SOME (src, value)
	end
d465 1
a465 1
	MLWorks.Option.NONE
a653 1
              GuiUtils.bool_value("default_visibility",default_visibility),
d902 2
d905 2
a906 2
		  h_position := GraphWidget.CENTER;
		  v_position := GraphWidget.CENTER
d1155 1
a1155 2
	   GuiUtils.value_menu
	     (shell, user_context, user_options, user_preferences, [srcText]),
d1195 4
a1198 11
          case UserContext.get_selected (user_context, user_options)
          of MLWorks.Option.NONE =>
	    ("()", ShellUtils.default_dynamic)
          |  MLWorks.Option.SOME root_item =>
	    case make_value_from_roots_menu
	           (root_item,
	            ShellTypes.new_options (user_options, user_context))
            of MLWorks.Option.NONE =>
	      ("()", ShellUtils.default_dynamic)
            |  MLWorks.Option.SOME item =>
	      item
d1201 2
a1202 2
	  false
	  (mk_initial_item, tooldata);
d1207 1
a1207 3
      make_inspector_window
	debugger_print
	(fn _ => (str, v), tooldata)
@


1.27
log
@Fiddling with draw_item
@
text
@d4 3
d1148 6
a1153 3
           {paste = Option.NONE,
            copy = Option.SOME (fn _ => !current_string),
            delete = Option.NONE},
@


1.26
log
@Fixing drawing function
@
text
@d4 3
d866 1
a866 1
              Capi.GraphicsPorts.draw_rectangle (gp,backgnd_region);
@


1.25
log
@Changing button resources
@
text
@d4 3
d862 3
a864 13

	      fun draw_backgnd_region () =
		  Capi.GraphicsPorts.fill_rectangle (gp,backgnd_region)

	      fun draw_foregnd_region () =
                Capi.GraphicsPorts.clear_rectangle (gp,foregnd_region)

	      fun draw_content () =
		  Capi.GraphicsPorts.draw_image_string (gp,s,new_point)
	    in 
		draw_backgnd_region ();
                draw_foregnd_region ();
		draw_content ()
@


1.24
log
@Adding windows menu
@
text
@d4 3
d1159 1
a1159 1
         [Menus.PUSH ("previousRootsButton",
d1162 1
a1162 1
          Menus.PUSH ("originalButton",
@


1.23
log
@Changing capi interface
@
text
@d4 3
d578 1
a578 1
        val current_item = ref initial_item   (* current posn. in tree *)
d590 2
d593 3
a595 3
	    Capi.Text.set_string (valText, print_value item);
	    Capi.Text.set_string (typeText, print_type ty);
            current_item := item
d1144 6
a1149 1
	   view_menu,
@


1.22
log
@Added display controls dialog to view menu.
@
text
@d4 3
d853 1
a853 1
		  Capi.GraphicsPorts.draw_fill_rectangle (gp,backgnd_region)
d856 1
a856 1
		  Capi.GraphicsPorts.draw_fill_rectangle (gp,foregnd_region)
d862 1
a862 1
		Capi.GraphicsPorts.with_highlighting (gp, draw_foregnd_region, ());
@


1.21
log
@Ensuring that atomic values cannot be root candidates - they are always
expanded otherwise.
@
text
@d4 4
d1128 1
@


1.20
log
@Fixing having to click twice on "Previous Roots"
@
text
@d4 3
d656 1
d662 1
a662 1
	       ITEM( (v,ty), abbrev , extents )
d665 1
d670 2
a671 2
        fun abbreviate   (ITEM(_,abbrev,_)) = abbrev := true
        fun unabbreviate (ITEM(_,abbrev,_)) = abbrev := false
d736 1
a736 1
            fun get_children (depth,ITEM (item,ref false,_)) = 
d751 1
a751 1
 
d753 1
a753 1
		      ITEM (x,ref abbrev,ref Option.NONE)
d778 1
a778 1
            fun equal_values (ITEM ((v1,ty1),_,_), ITEM ((v2,ty2),_,_)) =
d781 1
a781 1
            fun equal_items (ITEM(_,r1,_), ITEM(_,r2,_)) = (r1 = r2)
d785 1
a785 1
            val root_item = ITEM (root,ref false,ref Option.NONE)
d799 1
a799 1
        fun get_item_data (ITEM (item,ref(abbrev),extents),gp) =
d897 1
a897 1
        fun graph_select_fn (item as ITEM (entry,ref(abbrev),_),reg) =
@


1.19
log
@Adding a SPACE at the bottom of the layout
@
text
@d4 3
d514 1
a514 1
	      #maximum_string_size(r) := 0;
d528 2
a529 2
          val string_abbreaviation    = InspectorValues.string_abbreaviation
          val normal_string_ellipsis  = !string_abbreaviation
d533 1
a533 1
              string_abbreaviation := graph_label_string_ellipsis
d536 1
a536 1
              string_abbreaviation := normal_string_ellipsis
d665 2
a666 2
        fun abbreaviate   (ITEM(_,abbrev,_)) = abbrev := true
        fun unabbreaviate (ITEM(_,abbrev,_)) = abbrev := false
d668 1
a668 1
        (* String used to signify node abbreaviations in the graph *)
d679 1
a679 1
                  if (depth > !graph_depth) then ( abbreaviate(node); true ) else
d894 4
a897 1
	    then new_root_item := Option.SOME(entry)
d966 2
a967 1
                     l as (item :: _) => set_previous_roots(item,l)
d969 1
a969 1
                  ) 
d1037 1
d1159 1
@


1.18
log
@Changed defaults for `show_atoms' from false to true.
@
text
@d4 3
d1146 2
a1147 1
          Capi.Layout.FIXED buttonPane]);
@


1.17
log
@Added large number of features:
  - middle button provides popup-menu:
    - Value/Type display
    - Show atomic values?
    - Equal values shared?
    - Display all children?
    - Graph Arity/Depth limits.
  - right button acts to contract nodes.

  - Added Roots/Previous Roots/Original Root facilities.
  - Removed list menu
Made modifications due to introduction of GraphWidget.Extent etc.
@
text
@d4 14
d601 1
a601 1
        val show_atoms    =    ref false
@


1.16
log
@Tidied up the item_extents computation ...
@
text
@d320 1
d336 1
d356 2
d359 1
d401 2
d405 1
a405 1
    fun make_value_from_history_item
d486 1
d504 1
a504 1
          val long_string_options = make_print_options ()
d508 10
d520 1
a520 1
	      then  print_options := long_string_options
d527 7
a533 2
                ShellUtils.print_value
                    (typed_value,(!print_options),get_current_context())
d538 1
a538 1
              (ty,(!print_options),get_current_context())
d544 2
a545 18
        val current_item = ref initial_item

        fun set_state (set_items, (item as (value,ty),subitems)) =
          let
            val print_options = UserOptions.new_print_options user_options
            val context = get_current_context ()

            fun print_type ty =
              ShellUtils.print_type (ty,print_options,context)

            fun print_value value =
              ShellUtils.print_value (item,print_options,context)
          in
	    Capi.Text.set_string (valText, print_value item);
	    Capi.Text.set_string (typeText, print_type ty);
            current_item := item;
            set_items print_options subitems
          end
d547 1
a547 1
        fun set_state' (item as (value,ty)) =
d563 2
a564 20
        fun edit_object _ =
          let
            val preferences = Preferences.new_preferences user_preferences 
          in
            ShellUtils.edit_object (#1 (!current_item), preferences);
	    ()
          end
          handle
	    ShellUtils.EditFailed s => message_fun ("Edit failed: " ^ s)

        fun trace_object _ =
          ShellUtils.trace
	    (!current_item, user_options, get_current_context, message_fun)

        fun untrace_object _ =
          ShellUtils.untrace
	    (!current_item, user_options, get_current_context, message_fun)

        fun object_editable _ =
	  ShellUtils.object_editable (#1 (!current_item))
d566 1
a566 6
        fun object_traceable _ =
	  ShellUtils.object_traceable (#1 (!current_item))

        val history = ref []

        fun eq ( ((v,t),_), ((v',t'),_) ) =
d574 1
a574 1
	  ShellUtils.add_history_item (a, history, eq, user_preferences)
d576 5
a580 11
        fun inspect_item (set_items, new_item, hist) =
          let
            val new_item_data =
              (new_item, InspectorValues.get_inspector_values debugger_print new_item)
              handle InspectorValues.DuffUserMethod _ =>
                (message_fun "Error in User Inspect Method";
                 (new_item,[]))
          in
            add_action (new_item_data);
            set_state (set_items, new_item_data)
          end
d582 1
a582 2
	fun select (_, _, set_items) (_, chosen_item) =
	  inspect_item (set_items, chosen_item, !history)
d584 1
a584 1
        val pane = Capi.make_managed_widget ("pane",Capi.Paned,frame,[])
d586 23
a608 7
	val (winScroll, winList, set_items) =
	  Capi.make_scrolllist
	    {parent = pane, name = "inspector", print_fn = print_fn,
	     select_fn = select, action_fn = fn _ => fn _ => ()}


        (* Inspector Graph - Application State *)
d610 4
a613 1
        datatype GraphType = VALUE | TYPE
d615 2
a616 6
        val graph_type =    ref VALUE
        val show_atoms =    ref false
        val show_box   =    ref true
        val graph_sharing = ref true
        val graph_arity =   ref 200
        val graph_depth =   ref 300
d620 2
a621 1
                                  child_expansion = GraphWidget.ALWAYS,
d648 2
a649 1
        val abbrev_string = " *** "    (* String used to signify abbreaviations *)
d659 1
a659 1
                  if (depth > !graph_depth) then ( abbreaviate(node); false ) else
d673 2
a674 1
			     items := (depth,node,children) :: !items;		                                 Lists.iterate scan children
d714 12
d731 1
a731 1
		      if InspectorValues.is_scalar_value x andalso not(!show_atoms)
d766 1
a766 1
        fun make_value_graph () = make_graph (!current_item)
a786 3
(*
        fun max (x,y) = if x > y then x else y
*)
d799 1
a799 6
(*
           fun test_ref (r) = (fn _ => !r)
           fun set_ref (r) = (fn n => r := n)
           fun mk_entry(s,r) = Menus.OPTINT (s,test_ref(r),set_ref(r))
*)
	fun item_draw_item (item,gp,x,y) =
d840 6
a845 6
	      (
               left+topleft_w+1,
	       right+bottomright_w,
	       font_ascent+topleft_w,
	       font_descent+bottomright_w
              )
d854 1
a854 1
          GraphWidget.make ("inspectorGraph","InspectorGraph",pane,
d858 35
a892 5
        val {reposition_fn,popup_fn=seln_popup_fn,...} =
            GraphWidget.reposition_graph_selection(graph_window,set_position)

        fun graph_select_fn (item as ITEM (entry,_,_),reg) =
            ( reposition_fn(reg); set_state'(entry) )
d898 7
d906 10
a915 3
           fun left_action (_)   = ()
           fun middle_action (_) = ()
           fun right_action (_)  = graph_menu()
d917 1
a917 1
            val _ = set_button_actions
d927 19
a945 10
        fun can_pop _ =
          (case !history of 
             _ :: _ :: _ => true
           | _ => false)

        fun pop_history _ =
          (case !history of
             _ :: (l as (item_data :: _)) => (history := l;
                                              set_state (set_items, item_data))
           | _ => ())
d947 1
a947 1
        fun top_level _ =
d950 2
a951 3
              | doit (l as [item_data]) =
                (history := l;
                 set_state (set_items,item_data))
d954 1
a954 1
            doit (!history)
d957 1
a957 1
        fun make_history_menu () =
d967 5
a971 4
            fun doone (item_data as (item, _)) =
              Menus.PUSH (print_value item,
                          fn _ =>
                            (set_state (set_items,item_data)), fn _ => true)
d973 1
a973 1
            val items = !history
d982 2
a983 2
        val listLabel = 
          Capi.make_managed_widget ("listLabel",Capi.Label,frame,[])
d1009 1
a1009 1
	case make_value_from_history_item (item, get_options ())
d1012 2
a1013 2
	   history := [];
           inspect_item (set_items, v, []);
d1036 1
a1036 1
         history := [];
d1104 1
a1104 1
           Menus.DYNAMIC ("history", make_history_menu, fn _ => true)]
d1108 2
a1109 2
         [Menus.PUSH ("parentButton",
                      pop_history,
d1111 2
a1112 2
          Menus.PUSH ("toplevelButton",
                      top_level,
a1122 1
          Capi.Layout.FIXED buttonPane,
d1127 3
a1129 3
          Capi.Layout.FIXED listLabel,
          Capi.Layout.FLEX pane,
          Capi.Layout.SPACE]);
d1132 1
a1132 1
	inspect_item (set_items, !current_item, []);
d1144 3
a1146 3
          |  MLWorks.Option.SOME history_item =>
	    case make_value_from_history_item
	           (history_item,
@


1.15
log
@Modifications due to changes in GraphSpec.
@
text
@d4 3
d780 3
a783 3

        fun max (x,y) = if x > y then x else y
 
d787 2
a788 2
        val topleft_box_width = 1
        val bottomright_box_width = 3
d790 2
a791 2
        val topleft_w      = surround + topleft_box_width
        val bottomright_w  = surround + bottomright_box_width
d793 1
a793 1
        val bgnd_w         = topleft_box_width + bottomright_box_width
d795 53
a847 19
        fun item_draw_item (item,gp,x,y) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
            val new_x = x - (left+1+topleft_w)
	    val new_y = y - (font_ascent+baseline_height+1+topleft_w)
	    val new_width = (left+right+tot_w)
            val new_height = (font_ascent+font_descent+tot_w)
            val bckgnd_region =
                Capi.REGION {x = new_x, y = new_y,
                             width= new_width, height= new_height}
            val forgnd_region =
                Capi.REGION {x = new_x+topleft_box_width, y = new_y+topleft_box_width,
                             width= new_width-bgnd_w, height= new_height-bgnd_w}
            val new_point = Capi.POINT{x=x - left,y=y - baseline_height}

            fun draw_backgnd_region () =
                Capi.GraphicsPorts.draw_fill_rectangle (gp,bckgnd_region)
a848 23
            fun draw_foregnd_region () =
                Capi.GraphicsPorts.draw_fill_rectangle (gp,forgnd_region)

            fun draw_content () =
                Capi.GraphicsPorts.draw_image_string (gp,s,new_point)
          in 
	      draw_backgnd_region ();
              Capi.GraphicsPorts.with_highlighting (gp, draw_foregnd_region, ());
              draw_content ()
          end

        fun item_extent (item,gp) =
          let
            val (s,font_ascent,font_descent,width) = get_item_data (item,gp)
            val left = width div 2
            val right = width - left
          in
            (left,
             right+2,
             baseline_height + font_ascent+1,
             max (0,font_descent+3-baseline_height))
          end
    
d853 2
a854 1
             set_position,...} = 
d868 11
@


1.14
log
@Switched to child-expansion behaviour, modified label printing for strings and
gave lables more `surround' (the code for this made easily modifiable).
@
text
@d4 4
d625 2
d631 1
@


1.13
log
@Made the graph update the value and type display - changed print depth in the
graph label to 2 - to get a template effect.
@
text
@d4 4
d368 21
d469 2
a470 2
          val UserOptions.USER_TOOL_OPTIONS({maximum_depth, ...},_) = new_user_options
          val _ = (maximum_depth := 2)
d472 33
a504 5
          val print_options = UserOptions.new_print_options new_user_options
        in 
          fun graph_print_value (typed_value) =
            ShellUtils.print_value
            (typed_value,print_options,get_current_context())
d507 2
a508 2
            ShellUtils.print_type
            (ty,print_options,get_current_context())
d616 2
a617 2
        val graph_arity =   ref 10
        val graph_depth =   ref 5
d623 2
a624 2
                                  horizontal_delta = 10,
                                  vertical_delta = 20,
d632 2
a633 1
            (* Bundle up a node, abbrev. flag plus some cached display information:-
d642 4
a645 2
        fun abbreaviate   (ITEM(_,abbrev, _)) = abbrev := false
        fun unabbreaviate (ITEM(_,abbrev, _)) = abbrev := true
d669 1
a669 2
			     items := (depth,node,children) :: !items;			   
                             Lists.iterate scan children
a671 5

                fun return_items b = if b then !items else rev(!items)

                val deepest_first = true
                val deepest_last  = false
d674 1
a674 1
                return_items deepest_last    (* The optimiser should be able to work this out *)
d676 1
a676 1
            
d706 1
a706 1
            fun get_children (depth,ITEM (item,ref true,_)) = 
d709 3
d713 1
a713 1
                  fun push_scan (vis_flag, x, acc) =
d716 1
a716 1
		      else (new_depth,ITEM (x,ref vis_flag,ref Option.NONE)) :: acc
d720 3
a722 1
                      let val new_acc = push_scan((n < 0),x,acc) 
d724 1
a724 1
                          scan(n-1,rest,new_acc)
d727 2
a728 1
                  val inspect_items = InspectorValues.get_inspector_values debugger_print item
d743 1
a743 1
            val root_item = ITEM (root,ref true,ref Option.NONE)
d751 2
a752 1
        fun item_string (gp,item) =
d754 2
a755 2
              VALUE => graph_print_value item
            | TYPE  => graph_print_type item
d757 1
a757 1
        fun get_item_data (ITEM (item,_,extents),gp) =
d762 3
a764 2
                val s = item_string  (gp,item)
                val {font_ascent,font_descent,width,...} = Capi.GraphicsPorts.text_extent (gp,s)
d771 3
d775 9
a783 3
        val border_width = 4
 
        fun max (x,y) = if x > y then x else y
d790 10
a799 6
            val new_region =
                Capi.REGION
		  {x = x-left-1, y = y-font_ascent-baseline_height-1,
		   width=  left+right+border_width,
                   height= font_ascent + font_descent + border_width
		  }
d801 9
d811 3
a813 2
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,new_region); (* Draw border  *)
            Capi.GraphicsPorts.draw_image_string (gp,s,new_point)   (* Draw content *)
@


1.12
log
@Modification to take account of change to graph_widget interface.
@
text
@d4 3
d359 2
a360 11
    structure CapiData :
       sig
	  datatype Point = POINT of { x : int, y : int }

	  datatype Region = REGION of { x : int, y :int, width : int, height :int }
       end =
       struct
          open Capi
       end
    open CapiData;

d442 6
a447 1
          val print_options = UserOptions.new_print_options user_options
d449 1
a449 1
          fun graph_print_item (typed_value) =
d452 4
d480 16
d554 12
d572 2
a573 1
                                  show_all = true}
d575 15
a589 2
        (* Bundle up a node plus some cached display information *)
        datatype Item = ITEM of ((MLWorks.Internal.Value.T * Type) * (string * int * int * int) Option.option ref)
d593 2
a594 2
        (* return a list of nodes *)
            fun list_nodes root =
d596 4
a599 2
                val nodes = ref []
                fun add node =
d601 2
a602 4
                    fun lookup (node,[]) =
                      (nodes := node :: !nodes;
                       true)
                      | lookup (node,a::b) =
d606 1
a606 1
                    lookup (node,!nodes)
d608 14
a621 4
                fun scan node =
                  (if add node
                     then Lists.iterate scan (get_children node)
                   else ())
d623 2
a624 2
                scan root;
                rev (!nodes)
d627 2
a628 2
            (* Annotate them *)
            fun transform_nodes nodelist =
d631 1
d633 1
a633 1
                  | index' (node,node'::rest,n) =
d636 2
a637 1
                fun index node = index' (node,nodelist,0)
d641 2
a642 2
                 (fn node => (node,map index (get_children node)))
                 nodelist)
d644 4
a647 2
            val nodelist = list_nodes root
            val nodes = transform_nodes nodelist
d649 1
d651 1
d656 22
a677 11
            fun get_children (ITEM (item,_)) = 
              let
                fun scan ([],acc) = rev acc
                  | scan ((_,x)::rest,acc) =
                    if InspectorValues.is_scalar_value x
                      then scan (rest,acc)
                    else
                      scan (rest,ITEM (x,ref Option.NONE) :: acc)
              in
                scan (InspectorValues.get_inspector_values debugger_print item,[])
              end
d679 10
a688 6
            fun equality_fn ((x1,ty1),(x2,ty2)) =
              cast x1 = cast x2 andalso InspectorValues.type_eq (ty1,ty2)
            val items =
              massage_graph (ITEM (root,ref Option.NONE),
                             get_children,
                             fn (ITEM (i1,_),ITEM (i2,_)) => equality_fn (i1,i2))
d695 4
a698 1
        fun item_string (gp,(x,ty)) = graph_print_item (x,ty)
d700 1
a700 1
        fun get_item_data (ITEM (item,extents),gp) =
d714 2
d724 6
a729 3
                REGION{x= x-left-1,y= y-font_ascent-baseline_height-1,
                       width=left+right+4,height= font_ascent + font_descent + 4}
            val new_point = POINT{x=x - left,y=y - baseline_height}
d731 2
a732 2
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,new_region);
            Capi.GraphicsPorts.draw_image_string (gp,s,new_point)
d750 2
a751 1
             popup_menu=graph_menu,...} = 
d756 9
a764 1
        fun initialize_graph () = init_graph (fn (_) => ())
d927 2
a928 1
             [Menus.PUSH ("graph", graph_menu, fn _ => true)],
@


1.11
log
@Type of context_menu has changed.
@
text
@d4 3
d23 1
a23 1
 * Adding make_buttons function to capi
d664 1
a664 1
             initialize=initialize_graph,
a668 1
                            fn _ => (),
d670 2
@


1.10
log
@Updating by adding Capi Point/Region datatypes
@
text
@d4 3
a839 6
	   GuiUtils.context_menu
	     {set_state = select_context,
	      get_context = fn _ => !local_context,
	      writable = GuiUtils.ALL,
	      applicationShell = applicationShell,
	      user_preferences = user_preferences},
a840 1

@


1.9
log
@Changing top level window initialization
@
text
@d4 3
d350 11
d636 4
d641 2
a642 8
	    Capi.GraphicsPorts.draw_fill_rectangle (gp,
                                                    x-left-1,
                                                    y-font_ascent-baseline_height-1,
                                                    left+right+4,
                                                    font_ascent + font_descent + 4);
            Capi.GraphicsPorts.draw_image_string (gp,s,
                                                  x - left,
                                                  y - baseline_height)
@


1.8
log
@Extending GraphSpec type
@
text
@d4 3
d863 1
a863 2
        Capi.reveal shell;
        Capi.initialize shell;
@


1.7
log
@Changing interface to graph widget
@
text
@d4 3
d517 2
a518 1
                                  vertical_delta = 20}
d642 4
a645 1
        val {widget=graph_window,initialize=initialize_graph,update=update_graph,...} = 
d811 2
a812 1
             view_options,
@


1.6
log
@Renaming layout constructors
@
text
@d4 3
d518 48
d582 4
d587 1
a587 3
            (ITEM (root,ref Option.NONE),
             get_children,
             MLWorks.Option.SOME (fn (ITEM (i1,_),ITEM (i2,_)) => equality_fn (i1,i2)))
d639 4
a642 2
          GraphWidget.make ("inspectorGraph","InspectorGraph",
                            graph_spec,item_draw_item,item_extent,make_value_graph,pane)
@


1.5
log
@Adding make_buttons function to capi
@
text
@d4 3
d781 1
a781 1
            MLWorks.Option.SOME w => [Capi.Layout.OTHER w]
d783 9
a791 9
         [Capi.Layout.OTHER srcTitleLabel,
          Capi.Layout.OTHER srcText,
          Capi.Layout.OTHER buttonPane,
          Capi.Layout.OTHER valTitleLabel,
          Capi.Layout.OTHER valText,
          Capi.Layout.OTHER typeTitleLabel,
          Capi.Layout.OTHER typeText,
          Capi.Layout.OTHER listLabel,
          Capi.Layout.TEXT pane,
d797 2
a798 2
        Capi.manage shell;
        Capi.realize shell;
@


1.4
log
@Changing interface to grapher
@
text
@d4 3
d765 1
a765 1
        Menus.make_submenus 
d775 2
a776 1
        ([Capi.Layout.MENUBAR menuBar] @@
@


1.3
log
@Moved capi etc. to gui
@
text
@d4 3
d501 1
a501 2
          GraphWidget.GRAPH_SPEC {child_position = GraphWidget.NEXT,
                                  parent_position = GraphWidget.CENTRE,
d579 1
a579 1
        val (graph_window,initialize_graph,update_graph) = 
@


1.2
log
@Moved graph_widget to gui directory
@
text
@d4 3
d273 2
a274 2
require "../library/capi";
require "../library/menus";
@


1.1
log
@new unit
New unit
@
text
@d4 4
a271 1
require "../library/graph_widget";
d279 1
@
