head	1.20;
access;
symbols
	MLW_daveb_inline_1_4_99:1.20.1
	MLWorks_21c0_1999_03_25:1.20
	MLWorks_20c1_1998_08_20:1.20
	MLWorks_20c0_1998_08_04:1.20
	MLWorks_20b2c2_1998_06_19:1.20
	MLWorks_20b2_Windows_1998_06_12:1.20
	MLWorks_20b1c1_1998_05_07:1.20
	MLWorks_20b0_1998_04_07:1.20
	MLWorks_20b0_1998_03_20:1.18
	MLWorks_20m2_1998_02_16:1.16
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.10.6.1.1.3.1
	MLWorks_workspace_97:1.15.2
	MLWorks_dt_wizard:1.15.1
	MLWorks_11c0_1997_09_09:1.10.6.1.1.3
	MLWorks_10r3:1.10.6.1.3
	MLWorks_10r2_551:1.10.6.1.2
	MLWorks_11:1.10.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.6.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.10.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.6
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.4.1.1
	MLWorks_gui_1996_12_18:1.10.5
	MLWorks_1_0_Win32_1996_12_17:1.10.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.1.1
	JFHgui:1.10.3
	MLWorks_1_0_Irix_1996_11_28:1.10.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.2
	MLWorks_1_0_Unix_1996_11_14:1.10.1
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.7
	MLWorks_Beta_1996_06_06:1.7
	MLWorks_Beta_1996_06_05:1.7
	MLWorks_Beta_1996_06_03:1.7
	MLWorks_Beta_1996_05_31:1.7
	MLWorks_Beta_1996_05_30:1.7;
locks; strict;
comment	@ *  @;


1.20
date	98.03.31.16.22.16;	author johnh;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	98.03.23.15.00.35;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	98.02.18.16.58.05;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	98.02.17.16.38.54;	author johnh;	state Exp;
branches;
next	1.16;

1.16
date	98.01.27.15.57.52;	author johnh;	state Exp;
branches;
next	1.15;

1.15
date	97.08.04.13.20.30;	author johnh;	state Exp;
branches
	1.15.1.1
	1.15.2.1;
next	1.14;

1.14
date	97.06.13.13.31.53;	author johnh;	state Exp;
branches;
next	1.13;

1.13
date	97.06.10.14.26.28;	author johnh;	state Exp;
branches;
next	1.12;

1.12
date	97.05.16.15.35.47;	author johnh;	state Exp;
branches;
next	1.11;

1.11
date	97.05.06.09.01.30;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.11.06.11.16.05;	author matthew;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1;
next	1.9;

1.9
date	96.10.10.02.44.29;	author io;	state Exp;
branches;
next	1.8;

1.8
date	96.06.18.12.44.56;	author stephenb;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1;
next	1.7;

1.7
date	96.05.24.16.47.25;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	96.05.24.10.05.30;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	96.05.16.10.14.13;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.14.46.04;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	96.05.01.10.52.15;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.04.30.10.23.09;	author matthew;	state Exp;
branches;
next	1.1;

1.1
date	96.04.23.13.20.55;	author daveb;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.13.04;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.03.44;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.21.59;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.11.14.12.45.56;	author hope;	state Exp;
branches
	1.10.1.1.1.1;
next	;

1.10.1.1.1.1
date	96.11.28.14.57.44;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.11.22.18.06.22;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.12.17.09.54.23;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.12.17.17.45.03;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	97.02.24.11.34.32;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.12.18.09.39.03;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	97.05.12.10.31.22;	author hope;	state Exp;
branches
	1.10.6.1.1.1
	1.10.6.1.2.1
	1.10.6.1.3.1;
next	;

1.10.6.1.1.1
date	97.07.28.18.17.14;	author daveb;	state Exp;
branches;
next	1.10.6.1.1.2;

1.10.6.1.1.2
date	97.08.04.17.05.52;	author johnh;	state Exp;
branches;
next	1.10.6.1.1.3;

1.10.6.1.1.3
date	97.08.05.11.07.48;	author johnh;	state Exp;
branches
	1.10.6.1.1.3.1.1;
next	;

1.10.6.1.1.3.1.1
date	97.10.07.11.42.06;	author jkbrook;	state Exp;
branches;
next	;

1.10.6.1.2.1
date	97.09.08.17.10.48;	author daveb;	state Exp;
branches;
next	;

1.10.6.1.3.1
date	97.09.09.14.06.22;	author daveb;	state Exp;
branches;
next	1.10.6.1.3.2;

1.10.6.1.3.2
date	97.09.23.10.49.29;	author jkbrook;	state Exp;
branches;
next	;

1.15.1.1
date	97.09.10.19.20.50;	author brucem;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.11.20.52.04;	author daveb;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	97.11.20.17.04.20;	author johnh;	state Exp;
branches;
next	;

1.20.1.1
date	99.04.01.17.55.27;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
File Viewer Tool.
@


1.20
log
@[Bug #30346]
Call Capi.getNextWindowPos().
@
text
@(*
 *  $Log: _file_viewer.sml,v $
 *  Revision 1.19  1998/03/23  15:00:35  jont
 *  [Bug #30090]
 *  Remove use of MLWorks.IO
 *
 *  Revision 1.18  1998/02/18  16:58:05  jont
 *  [Bug #70070]
 *  Remove MLWorks.IO.terminal_out in favour of Terminal.output
 *
 *  Revision 1.17  1998/02/17  16:38:54  johnh
 *  [Bug #30344]
 *  Allow windows to retain size and position.
 *
 *  Revision 1.16  1998/01/27  15:57:52  johnh
 *  [Bug #30071]
 *  Merge in Project Workspace changes.
 *
 *  Revision 1.15.2.2  1997/11/20  17:04:20  johnh
 *  [Bug #30071]
 *  Remove Paths menu.
 *
 *  Revision 1.15.2.1  1997/09/11  20:52:04  daveb
 *  branched from trunk for label MLWorks_workspace_97
 *
 *  Revision 1.15  1997/08/04  13:20:30  johnh
 *  [Bug #30111]
 *  Silently fail view source when source not available, except for explicit action.
 *
 *  Revision 1.14  1997/06/13  13:31:53  johnh
 *  [Bug #30175]
 *  Combine tools and windows menu - goodbye windows menu.
 *
 *  Revision 1.13  1997/06/10  14:26:28  johnh
 *  [Bug #30075]
 *  Number the duplicated file viewers.
 *
 *  Revision 1.12  1997/05/16  15:35:47  johnh
 *  Implementing single menu bar on Windows.
 *  Re-organising menus for Motif.
 *
 *  Revision 1.11  1997/05/06  09:01:30  jont
 *  [Bug #30088]
 *  Get rid of MLWorks.Option
 *
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
 *  Revision 1.9  1996/10/10  02:44:29  io
 *  moving String from toplevel
 *
 *  Revision 1.8  1996/06/18  12:44:56  stephenb
 *  Fix part of bug 1413: namely add an Io handler to read_file so that
 *  it indicates that the file cannot be loaded rather than having the
 *  uncaught Io exception abort MLWorks.
 *
 *  Revision 1.7  1996/05/24  16:47:25  daveb
 *  Changed to have a single file viewer.
 *
 *  Revision 1.6  1996/05/24  10:05:30  daveb
 *  Added source type, so that the file viewer can view a string or a location.
 *  Made window a pop-up, so that closing it pops it down instead of destroying it.
 *
 *  Revision 1.5  1996/05/16  10:14:13  matthew
 *  Adding call to convert_text to cope with Windows CR/LF
 *
 *  Revision 1.4  1996/05/10  14:46:04  daveb
 *  Added edit_possible field to ToolData.edit_menu.
 *
 *  Revision 1.3  1996/05/01  10:52:15  jont
 *  String functions explode, implode, chr and ord now only available from String
 *  io functions and types
 *  instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 *  now only available from MLWorks.IO
 *
 *  Revision 1.2  1996/04/30  10:23:09  matthew
 *  Using basis Integer structure
 *
 *  Revision 1.1  1996/04/23  13:20:55  daveb
 *  new unit
 *  File Viewer Tool.
 *
 *
 *  Copyright (c) 1996 Harlequin Ltd.
 *  
 *)

(* Basis *)
require "../basis/__int";
require "../basis/__text_io";
require "../basis/__io";

(* Utilities *)
require "../utils/lists";
require "../utils/map";
require "../basics/location";
require "^.utils.__terminal";

(* GUI stuff *)
require "capi";
require "menus";
require "gui_utils";
require "tooldata";

require "file_viewer";

functor FileViewer (
  structure Lists: LISTS
  structure Map: MAP
  structure Capi: CAPI

  structure ToolData : TOOL_DATA
  structure GuiUtils : GUI_UTILS
  structure Menus : MENUS
  structure Location : LOCATION

  sharing type ToolData.ShellTypes.user_options =
	       GuiUtils.user_tool_options
  sharing type GuiUtils.user_context_options =
	       ToolData.UserContext.user_context_options
  sharing type Menus.Widget = ToolData.Widget =
    	       GuiUtils.Widget = Capi.Widget
  sharing type Menus.ButtonSpec = GuiUtils.ButtonSpec = ToolData.ButtonSpec
  sharing type ToolData.ShellTypes.user_preferences =
	       GuiUtils.user_preferences
  sharing type GuiUtils.MotifContext = ToolData.MotifContext
  sharing type GuiUtils.user_context = ToolData.ShellTypes.user_context
): FILE_VIEWER =
struct
  structure Location = Location
  structure ShellTypes = ToolData.ShellTypes
  structure UserContext = ToolData.UserContext

  type Widget = Capi.Widget
  type ToolData = ToolData.ToolData

  val do_debug = false
  fun debug s = if do_debug then Terminal.output(s ^ "\n") else ()

  val viewer_number = ref 0

  datatype source = STRING of string | LOCATION of Location.T

  exception ViewFailed of string

  val posRef = ref NONE
  val sizeRef = ref NONE

  (* The main function *)
  fun make_file_viewer
        (src, select_auto, parent, destroy_fun,
	 tooldata as ToolData.TOOLDATA {args, ...}) =
    let
      val ShellTypes.LISTENER_ARGS {user_options, 
				    user_preferences, 
				    user_context, ...} = args

      (* select_auto is now also used to tell whether the file viewer was duplicated *)
      val duplicated = not (isSome select_auto)

      val title = 
	if duplicated then 
	  (viewer_number := (!viewer_number) + 1;
	   "File Viewer #" ^ Int.toString (!viewer_number))
	else
	  "File Viewer"

      (* This records whether we automatically view a new file when the user
	 selects it, or whether they have to issue an explicit command. *)
      val do_automatic =
	case select_auto
	of NONE => ref false
	|  SOME b => ref b

      (*** Make the windows ***)
      val (shell, mainWindow, menuBar, _) =
        Capi.make_main_popup {name = "fileViewer", 
			      title = title, 
			      parent = parent, 
			      contextLabel = false, 
			      visibleRef = ref true,
			      pos = getOpt (!posRef, Capi.getNextWindowPos())}

      val locationLabel =
	Capi.make_managed_widget ("locationLabel", Capi.Label, mainWindow, [])

      (* Text stuff *)
      val (scroll,text) = Capi.make_scrolled_text ("textoutput", mainWindow, [])

      val _ = Capi.transfer_focus (mainWindow,text)

      (* str is the input string, loc is the location of the erroneous
	 statement in that string, and b specifies whether to highlight or
	 unhighlight. *)
      fun highlight (str, loc, b) =
        let
          val (s_pos, e_pos) = Location.extract (loc, str)
        in
          Capi.Text.set_highlight (text, s_pos, e_pos, b)
        end
        handle Location.InvalidLocation => ()

      (* This attempts to use the capi clipboard *)
      fun check_copy_selection _ = 
        Capi.clipboard_set (text,Capi.Text.get_selection text)

      local
	val current_src	= ref (STRING "")
	val current_text = ref ""
	val current_file = ref NONE
	val file_cache = ref (Map.empty' (op< : string * string -> bool))
      in
	fun set_text contents =
          let
            val s = Capi.Text.convert_text contents
          in
            current_text := s;
            Capi.Text.set_string (text, s)
          end

	fun get_text () = !current_text

	fun set_file file = current_file := SOME file
	fun unset_file () = current_file := NONE
	fun get_file () = !current_file

	fun cache_file (arg as (file, contents)) =
	  (set_file file;
	   file_cache := Map.define' (!file_cache, arg))

	fun lookup_file file =
	  Map.tryApply'Eq (!file_cache, file)

	fun set_location loc =
	  (current_src := LOCATION loc;
	   Capi.set_label_string (locationLabel, Location.to_string loc))

	fun set_string str =
	  (current_src := STRING str;
	   unset_file ();
	   Capi.set_label_string (locationLabel, "<User input>"))

	fun get_source () = !current_src
      end


      (* Reads the contents of a file.
       *
       * Note that 
       *
       * 1. To avoid reading the same file multiple times, file names and
       *    their contents are cached.
       * 2. If the file cannot be accessed, the exception ViewFailed is
       *    is raised with the argument being the name of the file.
       *)
      fun read_file filename =
	case lookup_file filename
	of SOME contents =>
	  (set_text contents;
	   set_file filename;
	   NONE)
	| NONE =>
	  let
	    val instream = TextIO.openIn filename
	    val contents = TextIO.inputN (instream, 4194304)
	      (* Max. four megabytes.  This is completely arbitrary,
		 but I had to choose some number (or write a loop). *)
	  in
	    TextIO.closeIn instream;
	    set_text contents;
	    set_file filename;
	    cache_file (filename, contents);
	    NONE
	  end
          handle IO.Io _ => SOME filename


      fun open_file location =
	case Location.file_of_location location
	of "" => ()
	|  filename =>
	  if get_file () = SOME filename then
	    (case get_source () of
	       LOCATION old_loc => 
		 highlight (get_text (), old_loc, false)
	     | _ =>
	       (* Should never happen *)
	       ();
	     highlight (get_text (), location, true);
	     set_location location)
	  else
	    let 
	      val success_opt = read_file filename
	    in 
	      if isSome success_opt then 
		(set_text "";
		 raise ViewFailed (getOpt (success_opt,"")))
	      else
	        (highlight (get_text (), location, true);
		 set_location location)
	    end

      fun popup () =
	let 
	  val main_windows = map (fn (a,b) => b) (Capi.get_main_windows())
	  val exists = Lists.member (title, main_windows)
	in
	  Capi.reveal mainWindow;
	  if not exists then Capi.add_main_window (shell, title) else ();
	  Capi.to_front shell
	end
	
      fun show_source (auto, src) =
	if auto andalso not (!do_automatic) then
	  ()
	else
	  (if src = get_source () then
	     ()
	   else
	     case src of
	       LOCATION loc =>
	         open_file loc
	     | STRING str =>
	         (set_text str;
		  set_string str);
	   if auto then
	     ()
	   else
	     popup ())

      fun duplicate src =
	let 
	  val (f, q) = make_file_viewer (src, NONE, parent, fn _ => (), tooldata)
	in 
	  f (false, src)
	end

      fun storeSizePos () = 
	(sizeRef := SOME (Capi.widget_size shell);
	 posRef := SOME (Capi.widget_pos shell))

      fun quit_fun _ = 
        (destroy_fun ();
	 Menus.quit();
	 storeSizePos();
 	 Capi.remove_main_window shell)

      fun close_window _ =
	(quit_fun();
         Capi.destroy shell)

      fun get_user_context () = user_context

      val menuspec =
	[ToolData.file_menu [("save", fn _ =>
		       GuiUtils.save_history (false, get_user_context (), shell),
		     fn _ =>
		       not (UserContext.null_history (get_user_context ()))
		       andalso UserContext.saved_name_set (get_user_context ())),
	    ("saveAs", fn _ => GuiUtils.save_history
			     (true, get_user_context (), shell),
		       fn _ => not (UserContext.null_history (get_user_context ()))),
	    ("close", close_window, fn _ => true)],
	 ToolData.edit_menu
	   (shell,
            {cut = NONE,
             paste = NONE,
             copy = SOME (check_copy_selection),
             delete = NONE,
	     edit_possible = fn _ => false,
             selection_made = fn _ => Capi.Text.get_selection text <> "",
	     edit_source = [],
	     delete_all = NONE}),
	 ToolData.tools_menu (fn () => tooldata, fn () => user_context),
	 ToolData.usage_menu 
	      ([("duplicate", fn _ => duplicate (get_source ()), fn _ => true)], 
	      [("autoSelection",
               fn _ => !do_automatic,
               fn b => do_automatic := b,
               fn _ => case select_auto of NONE => false | _ => true)]),
	 ToolData.debug_menu []]
    in
      Menus.make_submenus (menuBar,menuspec);
      Capi.Layout.lay_out
      (mainWindow, !sizeRef,
       [Capi.Layout.MENUBAR menuBar,
        Capi.Layout.SPACE,
        Capi.Layout.FIXED locationLabel,
        Capi.Layout.FLEX scroll,
	Capi.Layout.SPACE]);
      Capi.Callback.add (shell, Capi.Callback.Destroy, quit_fun);
      (show_source, close_window)
    end

    (* We cache the update function, so that future calls
       update the same windows. *)
    local
      val display_fun = ref NONE
    in
      fun create (parent, select_auto, tooldata) = 
        let
          fun reset _ = display_fun := NONE;

	  fun update auto source =
            case !display_fun of 
              SOME f => f (auto, source)
            | _ =>
              if auto then
  	        ()
              else
                let
                  val (f, q) = make_file_viewer 
			   (source, SOME select_auto, parent, reset, tooldata)
                in
                  display_fun := SOME f;

		  (* Need the quit function here to kill the File Viewer in the case 
		   * that a file is unreadable, so reset the display reference, kill
		   * the File Viewer, then raise the exception again.
		   *)
		  f (false, source)
 		  handle ViewFailed f => (reset(); q (); raise ViewFailed f)  
                end
  
        in
	  update
        end
    end
  
end;
@


1.20.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 *  Revision 1.20  1998/03/31  16:22:16  johnh
 *  [Bug #30346]
 *  Call Capi.getNextWindowPos().
 *
@


1.19
log
@[Bug #30090]
Remove use of MLWorks.IO
@
text
@d3 4
d183 1
a183 1
			      pos = getOpt (!posRef, (100,100))}
@


1.18
log
@[Bug #70070]
Remove MLWorks.IO.terminal_out in favour of Terminal.output
@
text
@d3 4
d87 2
a128 1
  structure IO = MLWorks.IO
d261 2
a262 2
	    val instream = MLWorks.IO.open_in filename
	    val contents = MLWorks.IO.input (instream, 4194304)
d266 1
a266 1
	    MLWorks.IO.close_in instream;
d272 1
a272 1
          handle MLWorks.IO.Io _ => SOME filename
@


1.17
log
@[Bug #30344]
Allow windows to retain size and position.
@
text
@d3 4
d88 1
d130 1
a130 1
  fun debug s = if do_debug then MLWorks.IO.output(IO.terminal_out,s ^ "\n") else ()
@


1.16
log
@[Bug #30071]
Merge in Project Workspace changes.
@
text
@d3 4
d133 2
d164 6
a169 1
        Capi.make_main_popup ("fileViewer", title, parent, false, ref true)
d325 4
d332 1
d372 1
a372 1
      (mainWindow,
@


1.15
log
@[Bug #30111]
Silently fail view source when source not available, except for explicit action.
@
text
@d3 11
d352 1
a352 2
	 ToolData.debug_menu [],
	 GuiUtils.paths_menu mainWindow]
@


1.15.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 *  Revision 1.15  1997/08/04  13:20:30  johnh
 *  [Bug #30111]
 *  Silently fail view source when source not available, except for explicit action.
 *
@


1.15.2.2
log
@[Bug #30071]
Remove Paths menu.
@
text
@a2 3
 *  Revision 1.15.2.1  1997/09/11  20:52:04  daveb
 *  branched from trunk for label MLWorks_workspace_97
 *
d345 2
a346 1
	 ToolData.debug_menu []]
@


1.15.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 *  Revision 1.15  1997/08/04  13:20:30  johnh
 *  [Bug #30111]
 *  Silently fail view source when source not available, except for explicit action.
 *
@


1.14
log
@[Bug #30175]
Combine tools and windows menu - goodbye windows menu.
@
text
@d3 4
d225 2
a226 1
	   set_file filename)
d237 2
a238 1
	    cache_file (filename, contents)
d240 1
a240 1
          handle MLWorks.IO.Io _ => raise ViewFailed filename
d257 10
a266 3
	    (read_file filename;
	     highlight (get_text (), location, true);
	     set_location location)
d297 5
a301 2
        (make_file_viewer (src, NONE, parent, fn _ => (), tooldata);
         ())
d303 1
a303 1
      fun close_window _ =
d306 5
a310 2
 	 Capi.remove_main_window shell;
         Capi.hide mainWindow)
d352 1
a352 4
      Capi.Callback.add (shell, Capi.Callback.Destroy,destroy_fun);
      Capi.set_close_callback (shell, close_window);
      (* Call show_source to initialise the window *)
      show_source (false, src);
d356 1
a356 1
    (* We cache the update and quit functions, so that future calls
a359 1
      val quit_fun = ref NONE
d363 1
a363 3
          fun reset _ =
	    (display_fun := NONE;
	     quit_fun := NONE)
d373 2
a374 4
                  val (f, q) =
		    make_file_viewer
		      (source, SOME select_auto,
		       parent, fn _ => () (* reset *), tooldata)
d377 7
a383 1
		  quit_fun := SOME q
a385 7
	  fun quit () =
	    (case !quit_fun of
	       NONE => ()
	     | SOME q => q ();
	     (* The references should be reset by the quit function, but
	        there is no harm in being defensive here. *)
	     reset ())
d387 1
a387 1
	  (update, quit)
@


1.13
log
@[Bug #30075]
Number the duplicated file viewers.
@
text
@d3 4
d256 8
a263 2
	(Capi.reveal mainWindow;
	 Capi.to_front shell)
d290 1
d323 1
a323 2
	 GuiUtils.paths_menu mainWindow,
	 ToolData.windows_menu ()]
@


1.12
log
@Implementing single menu bar on Windows.
Re-organising menus for Motif.
@
text
@d3 4
d104 1
a104 1
  val viewer_number = ref 1
d120 9
a128 1
      val title = "File Viewer"
@


1.11
log
@[Bug #30088]
Get rid of MLWorks.Option
@
text
@d3 4
d86 1
d92 1
d112 3
a114 1
      val ShellTypes.LISTENER_ARGS {user_options, user_preferences, ...} = args
d127 1
a127 1
        Capi.make_main_popup ("fileViewer", title, parent, false)
d267 1
d270 1
a270 15
      val main_menu =
        Menus.CASCADE
          ("main",
           [Menus.TOGGLE
	      ("autoSelection",
               fn _ => !do_automatic,
               fn b => do_automatic := b,
               fn _ => case select_auto of NONE => false | _ => true),
            Menus.PUSH
	      ("duplicate",
               fn _ => duplicate (get_source ()),
               fn _ => true),
            Menus.SEPARATOR,
            Menus.PUSH ("close", close_window, fn _ => true)],
           fn _ => true)
d273 9
a281 1
	[main_menu,
d290 11
a300 1
	     tail = []}),
d312 1
@


1.10
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
a85 1
  structure Option = MLWorks.Option
@


1.10.6.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 *  Revision 1.10.6.1  1997/05/12  10:31:22  hope
 *  branched from 1.10
 *
@


1.10.6.1.3.2
log
@[Bug #30111]
Merging from trunk:
Debugger pops up dialog when source not available
@
text
@a2 3
 *  Revision 1.10.6.1.3.1  1997/09/09  14:06:22  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d201 1
a201 2
	   set_file filename;
	   NONE)
d212 1
a212 2
	    cache_file (filename, contents);
	    NONE
d214 1
a214 1
          handle MLWorks.IO.Io _ => SOME filename
d231 3
a233 10
	    let 
	      val success_opt = read_file filename
	    in 
	      if isSome success_opt then 
		(set_text "";
		 raise ViewFailed (getOpt (success_opt,"")))
	      else
	        (highlight (get_text (), location, true);
		 set_location location)
	    end
d258 2
a259 7
	let 
	  val (f, q) = make_file_viewer (src, NONE, parent, fn _ => (), tooldata)
	in 
	  f (false, src)
	end

      fun quit_fun _ = destroy_fun ()
d262 2
a263 2
	(quit_fun();
         Capi.destroy shell)
a280 1

d302 3
a304 1
      Capi.Callback.add (shell, Capi.Callback.Destroy, quit_fun);
d308 1
a308 1
    (* We cache the update function, so that future calls
d312 1
d316 3
a318 1
          fun reset _ = display_fun := NONE;
d328 4
a331 2
                  val (f, q) = make_file_viewer 
			   (source, SOME select_auto, parent, reset, tooldata)
d334 1
a334 7

		  (* Need the quit function here to kill the File Viewer in the case 
		   * that a file is unreadable, so reset the display reference, kill
		   * the File Viewer, then raise the exception again.
		   *)
		  f (false, source)
 		  handle ViewFailed f => (reset(); q (); raise ViewFailed f)  
d337 7
d345 1
a345 1
	  update
@


1.10.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 *  Revision 1.10.6.1  1997/05/12  10:31:22  hope
 *  branched from 1.10
 *
@


1.10.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 *  Revision 1.10.6.1  1997/05/12  10:31:22  hope
 *  branched from 1.10
 *
@


1.10.6.1.1.2
log
@[Bug #30111]
Merging - create fn no longer returns quit function.  Tidied code for creation.
@
text
@a2 4
 *
 *  Revision 1.10.6.1.1.1  1997/07/28  18:17:14  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d201 1
a201 2
	   set_file filename;
	   NONE)
d212 1
a212 2
	    cache_file (filename, contents);
	    NONE
d214 1
a214 1
          handle MLWorks.IO.Io _ => SOME filename
d231 3
a233 10
	    let 
	      val success_opt = read_file filename
	    in 
	      if isSome success_opt then 
		(set_text "";
		 raise ViewFailed (getOpt (success_opt,"")))
	      else
	        (highlight (get_text (), location, true);
		 set_location location)
	    end
d258 2
a259 5
	let 
	  val (f, q) = make_file_viewer (src, NONE, parent, fn _ => (), tooldata)
	in 
	  f (false, src)
	end
d261 1
a261 1
      fun quit_fun _ = 
d263 1
a263 6
	 Menus.quit();
 	 Capi.remove_main_window shell)

      fun close_window _ =
	(quit_fun();
         Capi.destroy shell)
a280 2
      fun get_user_context () = user_context

d302 3
a304 1
      Capi.Callback.add (shell, Capi.Callback.Destroy, quit_fun);
d308 1
a308 1
    (* We cache the update function, so that future calls
d312 1
d316 3
a318 1
          fun reset _ = display_fun := NONE;
d328 4
a331 2
                  val (f, q) = make_file_viewer 
			   (source, SOME select_auto, parent, reset, tooldata)
d334 1
a334 7

		  (* Need the quit function here to kill the File Viewer in the case 
		   * that a file is unreadable, so reset the display reference, kill
		   * the File Viewer, then raise the exception again.
		   *)
		  f (false, source)
 		  handle ViewFailed f => (reset(); q (); raise ViewFailed f)  
d337 7
d345 1
a345 1
	  update
@


1.10.6.1.1.3
log
@[Bug #30111]
Fix merge problem.
@
text
@d277 5
d283 1
a283 1
	(destroy_fun();
d302 2
d325 1
a325 1
      Capi.Callback.add (shell, Capi.Callback.Destroy, destroy_fun);
@


1.10.6.1.1.3.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 4
 *  Revision 1.10.6.1.1.3  1997/08/05  11:07:48  johnh
 *  [Bug #30111]
 *  Fix merge problem.
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a2 3
 *  Revision 1.10.4.1  1996/12/17  17:45:03  hope
 *  branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a2 4
 *  Revision 1.10  1996/11/06  11:16:05  matthew
 *  [Bug #1728]
 *  __integer becomes __int
 *
@


1.10.1.1.1.1
log
@branched from 1.10.1.1
@
text
@a2 3
 *  Revision 1.10.1.1  1996/11/14  12:45:56  hope
 *  branched from 1.10
 *
@


1.9
log
@moving String from toplevel
@
text
@d3 3
d43 1
a43 1
require "../basis/__integer";
@


1.8
log
@Fix part of bug 1413: namely add an Io handler to read_file so that
it indicates that the file cannot be loaded rather than having the
uncaught Io exception abort MLWorks.
@
text
@d3 5
a81 2
  open MLWorks.Option

d108 2
a109 2
	of Option.NONE => ref false
	|  Option.SOME b => ref b
d189 1
a189 1
	of Option.SOME contents =>
d192 1
a192 1
	| Option.NONE =>
d248 1
a248 1
        (make_file_viewer (src, Option.NONE, parent, fn _ => (), tooldata);
d262 1
a262 1
               fn _ => case select_auto of Option.NONE => false | _ => true),
d275 4
a278 4
            {cut = Option.NONE,
             paste = Option.NONE,
             copy = Option.SOME (check_copy_selection),
             delete = Option.NONE,
d301 2
a302 2
      val display_fun = ref Option.NONE
      val quit_fun = ref Option.NONE
d307 2
a308 2
	    (display_fun := Option.NONE;
	     quit_fun := Option.NONE)
d312 1
a312 1
              Option.SOME f => f (auto, source)
d320 1
a320 1
		      (source, Option.SOME select_auto,
d323 2
a324 2
                  display_fun := Option.SOME f;
		  quit_fun := Option.SOME q
d329 2
a330 2
	       Option.NONE => ()
	     | Option.SOME q => q ();
@


1.8.3.1
log
@branched from 1.8
@
text
@a2 5
 *  Revision 1.8  1996/06/18  12:44:56  stephenb
 *  Fix part of bug 1413: namely add an Io handler to read_file so that
 *  it indicates that the file cannot be loaded rather than having the
 *  uncaught Io exception abort MLWorks.
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a2 5
 *  Revision 1.8  1996/06/18  12:44:56  stephenb
 *  Fix part of bug 1413: namely add an Io handler to read_file so that
 *  it indicates that the file cannot be loaded rather than having the
 *  uncaught Io exception abort MLWorks.
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a2 5
 *  Revision 1.8  1996/06/18  12:44:56  stephenb
 *  Fix part of bug 1413: namely add an Io handler to read_file so that
 *  it indicates that the file cannot be loaded rather than having the
 *  uncaught Io exception abort MLWorks.
 *
@


1.7
log
@Changed to have a single file viewer.
@
text
@d3 3
d89 3
d174 10
d201 2
@


1.6
log
@Added source type, so that the file viewer can view a string or a location.
Made window a pop-up, so that closing it pops it down instead of destroying it.
@
text
@d3 4
d93 1
a93 7
      val title =
        let
          val n = !viewer_number
        in
          viewer_number := n+1;
          "File Viewer #" ^ Int.toString n
        end
a134 10
	fun set_location loc =
	  (current_src := LOCATION loc;
	   Capi.set_label_string (locationLabel, Location.to_string loc))

	fun set_string str =
	  (current_src := STRING str;
	   Capi.set_label_string (locationLabel, "<User input>"))

	fun get_source () = !current_src

d146 1
d155 11
d279 39
a317 37
    fun create (parent, select_auto, tooldata) = 
      let
        val display_fun = ref Option.NONE
	val quit_fun = ref Option.NONE

        fun reset _ =
	  (display_fun := Option.NONE;
	   quit_fun := Option.NONE)

	fun update auto source =
          case !display_fun of 
            Option.SOME f => f (auto, source)
          | _ =>
            if auto then
  	      ()
            else
              let
                val (f, q) =
		  make_file_viewer
		    (source, Option.SOME select_auto,
		     parent, fn _ => () (* reset *), tooldata)
              in
                display_fun := Option.SOME f;
		quit_fun := Option.SOME q
              end

	fun quit () =
	  (case !quit_fun of
	     Option.NONE => ()
	   | Option.SOME q => q ();
	   (* The references should be reset by the quit function, but
	      there is no harm in being defensive here. *)
	   reset ())
      in
	(update, quit)
      end

@


1.5
log
@Adding call to convert_text to cope with Windows CR/LF
@
text
@d3 3
d70 2
d80 2
d84 1
a84 1
        (loc, select_auto, parent, destroy_fun,
d106 1
a106 1
        Capi.make_main_window ("fileViewer", title, parent, false)
d132 1
a132 1
	val current_loc	= ref loc
d134 1
a134 1
	val current_file = ref ""
d138 1
a138 1
	  (current_loc := loc;
d140 6
a145 1
	fun get_location () = !current_loc
d157 1
a157 1
	fun set_file file = current_file := file
d161 1
a161 1
	  (current_file := file;
d190 7
a196 2
	  if filename = get_file () then
	    (highlight (get_text (), get_location (), false);
d204 5
a208 1
      fun show_location (auto, loc) =
d211 2
a212 2
	else 
	  (if loc = get_location () then
d215 6
a220 1
	     open_file loc;
d224 1
a224 1
	     Capi.to_front shell)
d226 2
a227 2
      fun duplicate loc =
        (make_file_viewer (loc, Option.NONE, parent, fn _ => (), tooldata);
d232 1
a232 1
         Capi.destroy shell)
d244 1
a244 1
               fn _ => duplicate (get_location ()),
d272 3
a274 4
      Capi.initialize_toplevel shell;
      open_file loc;
      Capi.to_front shell;
      (show_location, close_window)
d279 1
a279 1
    fun view_location (parent, select_auto, tooldata) = 
d288 1
a288 1
	fun update auto loc =
d290 1
a290 1
            Option.SOME f => f (auto, loc)
d292 1
a292 1
            if auto andalso not select_auto then
d298 2
a299 1
		    (loc, Option.SOME select_auto, parent, reset, tooldata)
a314 1

@


1.4
log
@Added edit_possible field to ToolData.edit_menu.
@
text
@d3 3
d136 7
a142 2
	  (current_text := contents;
	   Capi.Text.set_string (text, contents))
@


1.3
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d224 1
@


1.2
log
@Using basis Integer structure
@
text
@d3 3
d62 1
a62 1
  fun debug s = if do_debug then output(IO.terminal_out,s ^ "\n") else ()
d149 2
a150 2
	    val instream = open_in filename
	    val contents = input (instream, 4194304)
d154 1
a154 1
	    close_in instream;
@


1.1
log
@new unit
File Viewer Tool.
@
text
@d2 5
a6 1
 *  $Log$
d12 3
d75 1
a75 1
          "File Viewer #" ^ MLWorks.Integer.makestring n
@
