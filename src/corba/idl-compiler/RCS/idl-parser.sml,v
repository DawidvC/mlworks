head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.1
	MLWorks_21c0_1999_03_25:1.9;
locks; strict;
comment	@ *  @;


1.9
date	99.03.10.15.48.40;	author clive;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	99.03.09.15.05.07;	author clive;	state Exp;
branches;
next	1.7;

1.7
date	99.03.09.09.23.34;	author clive;	state Exp;
branches;
next	1.6;

1.6
date	99.03.03.17.22.58;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	99.02.19.17.04.22;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	99.02.16.13.56.28;	author clive;	state Exp;
branches;
next	1.3;

1.3
date	99.02.04.12.50.58;	author clive;	state Exp;
branches;
next	1.2;

1.2
date	99.02.02.17.14.41;	author clive;	state Exp;
branches;
next	1.1;

1.1
date	99.02.02.16.40.16;	author clive;	state Exp;
branches;
next	;

1.9.1.1
date	99.04.01.17.53.01;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Top level parser file - defines functions that take text and parse it
@


1.9
log
@[Bug #170104]
Print emitted code for testing
@
text
@(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.8 1999/03/09 15:05:07 clive Exp $" *)

require "idl_grm";
require "idl_lex";
require "_idl_grm";
require "__absyn";
require "__emitter";

require "ml-yacc/lib/base.sml";
require "ml-yacc/lib/join.sml";
require "ml-yacc/lib/lrtable.sml";
require "ml-yacc/lib/parser2.sml";
require "ml-yacc/lib/stream.sml";

require "$.basis.__text_io";
require "$.basis.__int";

structure Emitter = Emitter

structure IDLLrVals =
  IDLLrValsFun(structure Token = LrParser.Token structure Absyn = Absyn);

structure IDLLex =
  IDLLexFun (structure Tokens = IDLLrVals.Tokens);

structure IDLParser =
  Join(structure ParserData = IDLLrVals.ParserData
       structure Lex= IDLLex
       structure LrParser=LrParser);

val invoke =
  fn lexstream =>
    let val print_error = fn (s,i:int,_) =>
      TextIO.print("Error: line " ^ (Int.toString i) ^ ", " ^ s ^ "\n")
    in
      IDLParser.parse (0, lexstream, print_error, ())
    end ;

fun preprocess (name, defines) =
  let
    val stream = TextIO.openIn name
    fun check_for_initial_sequence (string,seq) =
      if size(string) < size(seq)
      then false
      else if substring(string,0,size seq) = seq
           then true
           else false
    fun position (c,string,start) =
      let
        val len = size string
        fun search (pos) =
          if pos >= len
          then ~1
          else if substring(string,pos,1) = c
	       then pos
	       else search (pos+1)
      in
        if start < 0
        then ~1
        else search start
      end
    fun line_process sofar =
      let 
	val next_line = TextIO.inputLine stream
      in
        if next_line = ""
        then sofar
        else
          if check_for_initial_sequence (next_line, "#include")
          then 
	    let 
	      val start = position ("\"", next_line, 0)
	      val end' = position ("\"", next_line, start+1)
	      val included_file = name ^ "/../" ^ substring (next_line,start+1, end'-start-1)
            in
	     line_process
	     ((("#include_end \"" ^ included_file ^"\"\n") ::
	       preprocess(included_file,defines))
		@@ 
		(("#include_begin \"" ^ included_file ^"\"\n") :: sofar))
	    end
          else line_process (next_line :: sofar)
      end
    val result = line_process []
    val _ = TextIO.closeIn stream
  in
    result
  end;


val input_on_file =
  fn name =>
   let 
     val _ = IDLLex.UserDeclarations.linenum := 0
     val data = ref (rev(preprocess (name,[])))
   in
     fn (_ : int) => 
        case !data of
          [] =>  ""
        | (res::rest) =>
             (data := rest; res)
   end;

val parse_file =
  fn name => invoke (IDLParser.makeLexer (input_on_file name));

val generate_signatures =
  fn name => 
  let
    val (tree,_) = parse_file name
  in
    map (fn x =>  map (fn x => TextIO.print (x ^ "\n")) x) (Emitter.generate_signatures tree)
  end
@


1.9.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.9 1999/03/10 15:48:40 clive Exp $" *)
@


1.8
log
@[Bug #170104]
Use the emitter to emit signature code
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.7 1999/03/09 09:23:34 clive Exp $" *)
d112 1
a112 1
    Emitter.generate_signatures tree
@


1.7
log
@[Bug #170104]
Call the walker functions for generating code
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.6 1999/03/03 17:22:58 clive Exp $" *)
a6 1
require "__walker";
d18 1
a18 1
structure Walker = Walker;
d112 1
a112 1
    Walker.walk_the_tree (tree, [], fn _ => 0, fn _ => 0)
@


1.6
log
@[Bug #170104]
Import the walker frame work ready to emit code
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.5 1999/02/19 17:04:22 clive Exp $" *)
d8 1
d108 7
@


1.5
log
@[Bug #170104]
Move syntax tree to separate file for sharing
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.4 1999/02/16 13:56:28 clive Exp $" *)
d7 1
d17 2
@


1.4
log
@[Bug #170104]
Get the IDL processor to handle includes
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.3 1999/02/04 12:50:58 clive Exp $" *)
d6 1
d18 1
a18 1
  IDLLrValsFun(structure Token = LrParser.Token);
@


1.3
log
@Added a function for parsing a file of IDL - no include yet, but successfully parses the NameService IDL
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.2 1999/02/02 17:14:41 clive Exp $" *)
d35 50
a84 6
val input_on_string =
  fn st =>
    let val input = ref (st : string)
    in
      fn (_ : int) => let val old = !input in (input := ""; old) end 
    end ;
a85 2
val do_parse = 
  fn text => invoke (IDLParser.makeLexer (input_on_string text));
d89 3
a91 1
   let val stream = TextIO.openIn name 
d93 5
a97 1
     fn (_ : int) => TextIO.inputLine stream
@


1.2
log
@Define utility functions for testing the parser
@
text
@d1 1
a1 1
(* "$Header: /hope/cam1/hope.1/compound/37/MLWcorba-idl-compiler/RCS/idl-parser.sml,v 1.1 1999/02/02 16:40:16 clive Exp $" *)
d44 11
@


1.1
log
@new unit
Top level parser file - defines functions that take text and parse it
@
text
@d1 1
a1 1
(* "$Header$" *)
d34 10
@
