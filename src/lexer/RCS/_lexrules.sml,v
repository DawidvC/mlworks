head	1.47;
access;
symbols
	MLW_daveb_inline_1_4_99:1.47.3
	MLWorks_21c0_1999_03_25:1.47
	MLWorks_20c1_1998_08_20:1.47
	MLWorks_20c0_1998_08_04:1.47
	MLWorks_20b2c2_1998_06_19:1.47
	MLWorks_20b2_Windows_1998_06_12:1.47
	MLWorks_20b1c1_1998_05_07:1.47
	MLWorks_20b0_1998_04_07:1.47
	MLWorks_20b0_1998_03_20:1.47
	MLWorks_20m2_1998_02_16:1.47
	MLWorks_20m1_1997_10_23:1.47
	MLWorks_11r1:1.46.5.1.1.1.1
	MLWorks_workspace_97:1.47.2
	MLWorks_dt_wizard:1.47.1
	MLWorks_11c0_1997_09_09:1.46.5.1.1.1
	MLWorks_10r3:1.46.5.1.3
	MLWorks_10r2_551:1.46.5.1.2
	MLWorks_11:1.46.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.46.5.1
	MLWorks_20m0_1997_06_20:1.46
	MLWorks_1_0_r2c2_1997_06_14:1.46.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.46.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.46.5
	MLWorks_BugFix_1997_04_24:1.46
	MLWorks_1_0_r2_Win32_1997_04_11:1.46
	MLWorks_1_0_r2_Unix_1997_04_04:1.46
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.46.3.1.1
	MLWorks_gui_1996_12_18:1.46.4
	MLWorks_1_0_Win32_1996_12_17:1.46.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.46.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.46.1.1
	MLWorks_1_0_Irix_1996_11_28:1.46.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.46.2
	MLWorks_1_0_Unix_1996_11_14:1.46.1
	MLWorks_Open_Beta2_1996_10_11:1.42.1
	MLWorks_License_dev:1.41.3
	MLWorks_1_open_beta_1996_09_13:1.41.2
	MLWorks_Open_Beta_1996_08_22:1.41
	MLWlexer_basis_io_1996:1.41.1
	MLWorks_Beta_1996_07_02:1.41
	MLWorks_Beta_1996_06_07:1.41
	MLWorks_Beta_1996_06_06:1.41
	MLWorks_Beta_1996_06_05:1.41
	MLWorks_Beta_1996_06_03:1.41
	MLWorks_Beta_1996_05_31:1.41
	MLWorks_Beta_1996_05_30:1.41
	ML_beta_release_12/08/94:1.29
	ML_beta_release_03/08/94:1.29
	ML_revised_beta_release_25/05/94:1.27
	ML_final_beta_release_02/03/94:1.26
	mlworks-28-01-1994:1.26
	Release:1.24
	mlworks-beta-01-09-1993:1.24
	MLWorks-1-0-4-29/01/1993:1.15
	MLWorks-1-0-3-21/12/1992:1.15
	MLWorks-1-0-2-15/12/1992:1.15
	MLWorks-1-0-1-04/12/1992:1.14
	checkpoint_17_08_92:1.10;
locks; strict;
comment	@ * @;


1.47
date	97.07.21.08.52.17;	author daveb;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1;
next	1.46;

1.46
date	96.11.06.10.55.08;	author matthew;	state Exp;
branches
	1.46.1.1
	1.46.2.1
	1.46.3.1
	1.46.4.1
	1.46.5.1;
next	1.45;

1.45
date	96.11.04.16.00.54;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	96.11.01.12.29.19;	author io;	state Exp;
branches;
next	1.43;

1.43
date	96.10.30.16.32.07;	author io;	state Exp;
branches;
next	1.42;

1.42
date	96.10.10.10.25.53;	author andreww;	state Exp;
branches
	1.42.1.1;
next	1.41;

1.41
date	96.05.21.13.43.38;	author daveb;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1;
next	1.40;

1.40
date	96.05.07.10.29.20;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	96.04.30.17.37.16;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	96.04.29.13.20.10;	author matthew;	state Exp;
branches;
next	1.37;

1.37
date	96.03.25.12.18.19;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.03.19.15.38.15;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	95.07.28.14.40.32;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	95.07.24.15.30.30;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	95.07.19.10.14.20;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	95.07.17.10.23.17;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	95.03.17.14.33.34;	author matthew;	state Exp;
branches;
next	1.30;

1.30
date	95.03.10.16.52.18;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	94.06.24.09.25.36;	author nickh;	state Exp;
branches;
next	1.28;

1.28
date	94.06.23.13.17.47;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	94.03.08.13.49.45;	author daveb;	state Exp;
branches;
next	1.26;

1.26
date	93.11.26.17.09.16;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	93.10.07.10.21.32;	author nickh;	state Exp;
branches;
next	1.24;

1.24
date	93.08.25.19.02.21;	author jont;	state Exp;
branches
	1.24.1.1;
next	1.23;

1.23
date	93.05.28.13.30.00;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	93.05.27.15.49.47;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	93.05.20.12.27.41;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	93.05.18.16.17.03;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	93.03.31.10.52.49;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	93.03.30.12.31.32;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.03.23.16.01.05;	author daveb;	state Exp;
branches;
next	1.16;

1.16
date	93.02.12.15.35.57;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	92.12.08.16.01.34;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	92.12.02.17.23.48;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.05.15.29.53;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.08.31.17.00.54;	author richard;	state Exp;
branches;
next	1.11;

1.11
date	92.08.19.14.02.08;	author davidt;	state Exp;
branches;
next	1.10;

1.10
date	92.08.15.16.31.59;	author davidt;	state Exp;
branches;
next	1.9;

1.9
date	92.08.14.08.33.48;	author clive;	state Exp;
branches;
next	1.8;

1.8
date	92.08.07.15.47.05;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.08.05.14.43.54;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.07.28.11.13.47;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	92.05.14.15.20.36;	author richard;	state Exp;
branches;
next	1.4;

1.4
date	92.03.10.12.27.18;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	91.10.09.10.47.44;	author davidt;	state Exp;
branches;
next	1.2;

1.2
date	91.09.11.16.50.34;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	91.09.06.16.48.44;	author nickh;	state Exp;
branches;
next	;

1.24.1.1
date	93.08.25.19.02.21;	author jont;	state Exp;
branches;
next	1.24.1.2;

1.24.1.2
date	93.10.06.16.37.55;	author nickh;	state Exp;
branches;
next	;

1.41.1.1
date	96.08.19.11.49.25;	author hope;	state Exp;
branches;
next	1.41.1.2;

1.41.1.2
date	96.08.20.11.35.36;	author davids;	state Exp;
branches;
next	1.41.1.3;

1.41.1.3
date	96.08.22.10.32.56;	author davids;	state Exp;
branches;
next	;

1.41.2.1
date	96.09.13.11.17.49;	author hope;	state Exp;
branches;
next	;

1.41.3.1
date	96.10.07.16.07.38;	author hope;	state Exp;
branches;
next	;

1.42.1.1
date	96.10.17.11.25.52;	author hope;	state Exp;
branches;
next	;

1.46.1.1
date	96.11.14.12.51.01;	author hope;	state Exp;
branches
	1.46.1.1.1.1;
next	;

1.46.1.1.1.1
date	96.11.28.15.02.07;	author hope;	state Exp;
branches;
next	;

1.46.2.1
date	96.11.22.18.10.19;	author hope;	state Exp;
branches;
next	;

1.46.3.1
date	96.12.17.17.48.56;	author hope;	state Exp;
branches
	1.46.3.1.1.1;
next	;

1.46.3.1.1.1
date	97.02.24.11.39.00;	author hope;	state Exp;
branches;
next	;

1.46.4.1
date	96.12.18.09.42.58;	author hope;	state Exp;
branches;
next	;

1.46.5.1
date	97.05.12.10.35.26;	author hope;	state Exp;
branches
	1.46.5.1.1.1
	1.46.5.1.2.1
	1.46.5.1.3.1;
next	;

1.46.5.1.1.1
date	97.07.28.18.20.49;	author daveb;	state Exp;
branches
	1.46.5.1.1.1.1.1;
next	;

1.46.5.1.1.1.1.1
date	97.10.07.11.46.09;	author jkbrook;	state Exp;
branches;
next	;

1.46.5.1.2.1
date	97.09.08.17.14.16;	author daveb;	state Exp;
branches;
next	;

1.46.5.1.3.1
date	97.09.09.14.10.02;	author daveb;	state Exp;
branches;
next	;

1.47.1.1
date	97.09.10.19.25.57;	author brucem;	state Exp;
branches;
next	;

1.47.2.1
date	97.09.11.20.56.06;	author daveb;	state Exp;
branches;
next	;

1.47.3.1
date	99.04.01.17.57.30;	author daveb;	state Exp;
branches;
next	;


desc
@Lexer rules for the ML language.
.,
@


1.47
log
@[Bug #30090]
Removed spurious require on __old.
@
text
@(*
$Log: _lexrules.sml,v $
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
 * Revision 1.45  1996/11/04  16:00:54  jont
 * [Bug #1725]
 * Remove unsafe string operations introduced when String structure removed
 *
 * Revision 1.44  1996/11/01  12:29:19  io
 * [Bug #1614]
 * leftover String.ord
 *
 * Revision 1.43  1996/10/30  16:32:07  io
 * [Bug #1614]
 * removing toplevel String.
 *
 * Revision 1.42  1996/10/10  10:25:53  andreww
 * [Bug #1646]
 * Adding new escape sequence.
 *
 * Revision 1.41  1996/05/21  13:43:38  daveb
 * abstractions is now a compatibility option.
 *
 * Revision 1.40  1996/05/07  10:29:20  jont
 * Array moving to MLWorks.Array
 *
 * Revision 1.39  1996/04/30  17:37:16  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.38  1996/04/29  13:20:10  matthew
 * Integer changes
 * ,
 *
 * Revision 1.37  1996/03/25  12:18:19  matthew
 * Changing default imperative attibute to false.  This was trying to be too clever.
 *
 * Revision 1.36  1996/03/19  15:38:15  matthew
 * Updating for new language
 *
 * Revision 1.35  1995/07/28  14:40:32  matthew
 * Changin magic open bracker to #(
 *
Revision 1.34  1995/07/24  15:30:30  jont
Add word literal

Revision 1.33  1995/07/19  10:14:20  jont
Add recognition of character special constants

Revision 1.32  1995/07/17  10:23:17  jont
Recognise hex integers as integers

Revision 1.31  1995/03/17  14:33:34  matthew
Adding cached chr function

Revision 1.30  1995/03/10  16:52:18  matthew
Improving message for malformed real literals

Revision 1.29  1994/06/24  09:25:36  nickh
Add a type constraint required by NJ for the daily build.

Revision 1.28  1994/06/23  13:17:47  matthew
Changed the way keywords are lexed.

Revision 1.27  1994/03/08  13:49:45  daveb
Improving location reported for erroneous newline in string.

Revision 1.26  1993/11/26  17:09:16  matthew
Added error check for numeric specification out of range.

Revision 1.25  1993/10/07  10:21:32  nickh
Merging in bug fixes.

Revision 1.24.1.2  1993/10/06  16:37:55  nickh
Fixed error recovery on string reading, and added comment to
describe error conditions.

Revision 1.24  1993/08/25  19:02:21  jont
Removed some handlers in favour of a different mechanism. Comment lexing
and string lexing should improve dramatically

Revision 1.23  1993/05/28  13:30:00  matthew
Better regexp for long_id's

Revision 1.22  1993/05/27  15:49:47  matthew
Allow lexing of longids ending in "."
This is to make completion work.

Revision 1.21  1993/05/20  12:27:41  matthew
Added code for abstractions.

Revision 1.20  1993/05/18  16:17:03  jont
Removed integer parameter

Revision 1.19  1993/03/31  10:52:49  jont
Miinor efficiency improvements

Revision 1.18  1993/03/30  12:31:32  daveb
Replaced lexers for strings and comments with faster, more functional,
simple functions.  EOFs are now annotated with a LexerState value, so
that we can lex strings and comments that extend over multiple lines
in a listener.  Removed the now redundant check_end_state.

Revision 1.17  1993/03/23  16:01:05  daveb
Action functions now take an options parameter.  This is used to control
the interpretation of "require", "<<" and ">>".

Revision 1.16  1993/02/12  15:35:57  matthew
Adding magic brackets tokens.
There should be a switch to lex as normal

Revision 1.15  1992/12/08  16:01:34  matthew
Hack to handle unclosed comments and strings

Revision 1.14  1992/12/02  17:23:48  matthew
Added newline in string error.

Revision 1.13  1992/11/05  15:29:53  matthew
Changed Error structure to Info

Revision 1.12  1992/08/31  17:00:54  richard
Replaced LexBasics error handler by proper global error stuff.

Revision 1.11  1992/08/19  14:02:08  davidt
Added the formfeed character to the list of whitespace characters.
Removed a silly bug which allowed '3' as a string formatting character.

Revision 1.10  1992/08/15  16:31:59  davidt
Modified to provide functions which accept lists of chars (ints)
instead of strings. Comments are now parsed much more quickly
since the regular expressions match more input in one go.

Revision 1.9  1992/08/14  08:33:48  clive
Fixed lexer to read in negative exponents

Revision 1.8  1992/08/07  15:47:05  davidt
String structure is now pervasive.

Revision 1.7  1992/08/05  14:43:54  jont
Removed some structures and sharing

Revision 1.6  1992/07/28  11:13:47  matthew
Changed string definition so that only escapes and printable characters are allowed.
An illegal string character acts as a terminator, rather than being ignored, so this
should catch unclosed strings.

Revision 1.5  1992/05/14  15:20:36  richard
Added IGNORE token to remove recursion from lexing of comments and strings.

Revision 1.4  1992/03/10  12:27:18  matthew
Changed errors to print message and continue rather than raise exception

Revision 1.3  1991/10/09  10:47:44  davidt
Changed definition because the lexers are now numbered from zero,
instead of one ie. !self 1 becomes !self 0 etc.

Revision 1.2  91/09/11  16:50:34  nickh
Added one or two things to make the syntax more legible (infix regexp
operators, for instance).

Revision 1.1  91/09/06  16:48:44  nickh
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/lists";
require "../basics/token";
require "../main/options";
require "../main/info";
require "regexp";
require "inbuffer";
require "lexrules";

require "../basis/__int";
require "^.basis.__string";

functor MLRules
  (structure Crash : CRASH
   structure Lists : LISTS
   structure Token : TOKEN
   structure RegExp : REGEXP
   structure InBuffer : INBUFFER
   structure Options : OPTIONS
   structure Info : INFO) : LEXRULES = 
struct 
  type options = Options.options
  structure InBuffer = InBuffer

  (* This should be an option really *)
  val new_definition = true

  local 

      (* one or two things to make the syntax bearable *)

    val || = RegExp.BAR
    val & = RegExp.DOT
    infix 0 ||
    infix 1 &

    val class = RegExp.CLASS
    val negClass = RegExp.negClass
    val star = RegExp.STAR
    val plus = RegExp.plusRE
    val node = RegExp.NODE

    val digit = RegExp.digit
    val hexDigit = RegExp.hexDigit
    val letter = RegExp.letter

    (* general things *)
      
    val alphanumeric = (class "_'") || digit || letter
    val symbol = class "!%&$#+-/:<=>?@@\\~`^|*"
    val whitespace = plus(class " \n\t\012\013")
      
    (* things for ids *)
      
    val alpha_id = letter & star(alphanumeric)
    val symbolic_id = plus(symbol)
    val id = alpha_id || symbolic_id
    val long_id = id & star(node "." & id) & (node "." || RegExp.EPSILON)
      
    (* things for tyvars *)
      
    val alphas = star(alphanumeric)
    val tyvar = node "'" & alphas

    (* things for numbers *)
      
    val digits = plus(digit)
    val hexdigits = node "0x" & plus(hexDigit)
    val frac = (node "." & digits) || node "." (* Erroneous case *)
    val intnum = digits || (node "~" & digits)
    val intword = node "0w" & digits
    val hexintnum = hexdigits || (node "~" & hexdigits)
    val hexintword = node "0wx" & plus(hexDigit)
    val exp = node "E" & intnum
    val realnum = intnum & (frac || exp || (frac & exp))

    val implode_char = MLWorks.String.implode_char

    fun convert l = implode_char (rev l)

    fun location_file Info.Location.UNKNOWN = Crash.impossible "location_file"
    |   location_file (Info.Location.FILE f) = f
    |   location_file (Info.Location.LINE (f, _)) = f
    |   location_file (Info.Location.POSITION (f, _, _)) = f
    |   location_file (Info.Location.EXTENT {name, ...}) = name

    fun new_location (_, Info.Location.UNKNOWN) = Info.Location.UNKNOWN
    |   new_location (b, l) =
	  Info.Location.POSITION
	    (location_file l, InBuffer.getlinenum b, InBuffer.getlinepos b)
    
    fun newline_location (_, Info.Location.UNKNOWN) = Info.Location.UNKNOWN
    |   newline_location (b, l) =
	  Info.Location.POSITION
	    (location_file l,
	     InBuffer.getlinenum b - 1,
	     InBuffer.getlastlinepos b)
    
    fun extend_location (b, l) =
	  Info.Location.combine
	    (l, Info.Location.EXTENT {name = "", s_col = 0, s_line = 0,
				      e_line = InBuffer.getlinenum b,
				      e_col = InBuffer.getlinepos b})
  in
    structure RegExp = RegExp
    structure Symbol = Token.Symbol
    structure Info = Info
    type Result = Token.Token

    val eof = Token.EOF (Token.PLAIN_STATE)

    (* We read strings and comments locally, for efficiency.  When called
       from the shell after reading a line that ended in the middle of a
       string or comment, the lexer must call the appropriate function. *)

    (* We use comparisons of integer encodings, because comparing
     strings is expensive. *)

    val lparen = ord #"("
    val rparen = ord #")"
    val star = ord #"*"


    val depth' = ref 0

    fun read_comment (buffer, depth) =
      let
	val _ = depth' := depth
	(* Need to take care when placing handlers.
	 Don't lose tail-recursiveness. *)
	fun getchar b = InBuffer.getchar b

	fun aux (b, 0) = Token.IGNORE
	  | aux (b, n) =
            let
	      val c = getchar b
	    in
	      if c = lparen then do_lparen (b, n)
	      else if c = star then do_star (b, n)
		   else aux (b, n)
	    end

	  and do_lparen (b, n) =
            let
	      val c = getchar b
	    in
	      if c = star then (depth' := n+1;
				aux (b, n+1))
	      else if c = lparen then do_lparen (b, n)
		   else aux (b, n)
	    end

	  and do_star (b, n) =
            let
	      val c = getchar b
	    in
	      if c = star then do_star (b, n)
	      else if c = rparen then (depth' := n-1;
				       aux (b, n-1))
		   else aux (b, n)
	    end
      in
	aux (buffer, depth)
	handle InBuffer.Eof => Token.EOF (Token.IN_COMMENT (!depth'))
      end

(* string reading. There are various ways in which string reading can
 go wrong:

 1. an unescaped newline
 2. another unescaped character
 3. a \^c sequence, where c is outside the range 64--95
 4. a \dxy sequence, where one of xy is not a digit
 5. a \x sequence, where x is not n, t, ^, ", \, a format char or a digit (* \" *)
 6. a \fffffx sequence, where x is not \ or a format char
 7. Eof
 8. Numeric specification out of range (> 255).

We report an error for each of these (except Eof in a formatting
string, for the interactive lexer). In case 1, we stop reading and
return the current string (since the programmer has probably failed to
close it, and we don't want to read the rest of the file as a string.
In cases 2-6 we continue reading the string. In case 7, obviously, we
stop.

Nick Haines 06-Oct-93
*)

    fun format_char 32 = true	(* space *)
    |   format_char  9 = true	(* tab *)
    |   format_char 10 = true	(* newline *)
    |   format_char 12 = true	(* formfeed *)
    |   format_char 13 = true	(* return *)
    |   format_char c = false

    fun read_whitespace (location, buffer, error_info) =
      let
	val c = InBuffer.getchar buffer
      in
	if format_char c then
	  read_whitespace (location, buffer, error_info)
	else if c = ord #"\\" then
	  ()
	     else 
	       (Info.error
		error_info
		(Info.RECOVERABLE, new_location (buffer, location),
		 "Missing \\ after formatting characters in string");
		()) (* string reading error case 6 *)
      end

    fun is_digit c = c >= ord #"0" andalso c <= ord #"9"
    fun hexdigit c = 
      if is_digit c then 
	c-ord #"0"
      else if c>=ord #"a" andalso c<=ord #"f" then
	10+c-ord #"a"
      else if c>=ord #"A" andalso
	c<=ord #"Z" then
	10+c-ord #"A"
      else ~1
      
    fun read_string (location, buffer, error_info, so_far) =
      let
	val getchar = InBuffer.getchar

	fun read_digits (_, 0, b, location, c) = c
	  | read_digits (error_info, n, b, location, c) =
	    let
	      val c1 = getchar b
	    in
	      if is_digit c1 then
		read_digits
		(error_info, n - 1, b, location, 10 * c + c1 - ord #"0")
	      else
		(Info.error
		 error_info
		 (Info.RECOVERABLE, new_location (b, location),
		  "Malformed numeric character specification in string");
		 0) (* string reading error case 4 *)
	    end


	fun read_hexdigits (_, 0, b, location, acc) = acc
	  | read_hexdigits (error_info, n, b, location, (acc,chars)) =
	    let
	      val c1 = getchar b
              val d1 = hexdigit c1 (* = ~1 if error *)
	    in
	      if d1 <> ~1 then
		read_hexdigits
		(error_info, n-1, b, location, (16*acc+d1,c1::chars))
	      else
		(Info.error
		 error_info
		 (Info.RECOVERABLE, new_location (b, location),
		  "Malformed hex character specification in string");
		 (0,[])) (* string reading error case 4 *)
	    end
      
	fun printable c = c >= 32 andalso c <= 126	(* includes space *)

        val escapes = [(ord #"n",ord #"\n"),
                       (ord #"t",ord #"\t"),
                       (ord #"\"",ord #"\""),
                       (ord #"\\", ord #"\\"),
                       (* New ones *)
                       (ord #"a", 7),
                       (ord #"b", 8),
                       (ord #"v", 11),
                       (ord #"f", 12),
                       (ord #"r",13)]

        fun is_escape_char c =
          let
            fun mem [] = false
              | mem ((c',_)::rest) = c = c' orelse mem rest
          in
            mem escapes
          end

        fun get_escape_char c =
          let
            fun get [] = Crash.impossible "get_escape_char"
              | get ((c',x)::rest) =
                if c = c' then x else get rest
          in
            get escapes
          end

	fun aux (b, l) = 
	  let
	    val quote = ord #"\"" (* \" *)
	    val backslash = ord #"\\"
	    val newline = ord #"\n"
	    val c = getchar b
	  in
	    if c = quote then
	      Token.STRING (implode_char (rev (l @@ so_far)))
	    else if c = backslash then
	      let
		val c' = getchar b
	      in
		if is_escape_char c' then aux (b, get_escape_char c' :: l)
		else
                  if c' = ord #"^" then
                    let
                      val c'' = getchar b
                    in
                      if c'' >= 64 andalso c'' <= 95 then
                        aux (b, (c'' - 64) :: l)
                      else
                        (Info.error
                         error_info
                         (Info.RECOVERABLE, new_location (b, location),
                          "Illegal character after \\^ in string, " ^
                          "ASCII " ^ Int.toString c'');
                         aux (b, l))
                    (* string reading error case 3 *)
                    end
                  else
                    if is_digit c' then
                      let
                        val c'' = read_digits (error_info, 2, b, location,
                                               c' - ord #"0")
                      in
                        if c'' >= 0 andalso c'' < 256 
                          then aux (b, c'' :: l)
                        else
                          (Info.error
                           error_info
                           (Info.RECOVERABLE, new_location (b, location),
                            "Out of range numeric character specification in string " ^
                            "\"\\" ^ Int.toString c'' ^ "\"");
                           aux (b,l)) (* string reading error case 8 *)
                      end
                    else
                      if c'= ord #"u" then
                        let
                          val (c'',charlist) = read_hexdigits 
                                      (error_info, 4, b, location, (0,[]))
                        in
                        if c'' >= 0 andalso c'' < 256 
                          then aux (b, c'' :: l)
                        else
                          (Info.error
                           error_info
                           (Info.RECOVERABLE, new_location (b, location),
                            "Out of range hexadecimal character specification\
                             \ in string " ^ "\"\\u" ^ 
                            (implode_char (rev charlist)) ^ "\"");
                           aux (b,l)) (* string reading error case 8 *)
                        end
                      else
                        if format_char c' then
                          (read_whitespace (location, b, error_info);
                           aux (b, l))
                          handle InBuffer.Eof =>
                            Token.EOF (Token.IN_STRING (l @@ so_far))
                        else
                          (Info.error
                           error_info
                           (Info.RECOVERABLE, new_location (b, location),
                            "Illegal character after \\ in string, " ^
                            "ASCII " ^ Int.toString c');
                           aux (b, l)) (* string reading error case 5 *)
	      end
		 else
		   if c = newline then
		     (Info.error
		      error_info
		      (Info.RECOVERABLE, newline_location (b, location),
		       "Unexpected newline in string");
		      Token.STRING(implode_char (rev (l @@ so_far))))
		     (* string reading error case 1 *)
		   else
		     if printable c then
		       (* Can do better here - get a substring from the buffer *)
		       aux (b, c :: l)
		     else
		       (Info.error
			error_info
			(Info.RECOVERABLE, new_location (b, location),
			 "Illegal character in string, ASCII " ^
			 Int.toString c);
			aux (b,l)) (* string reading error case 2 *)
	  end
      in
	aux (buffer, [])
	handle InBuffer.Eof =>
	  Info.error' error_info (Info.FATAL, extend_location (buffer, location),
				  "Unexpected end of string")
      end

    fun continue_string (location, buffer, error_info, so_far) =
      (read_whitespace (location, buffer, error_info);
       read_string (location, buffer, error_info, so_far))
      handle InBuffer.Eof => (*  can only be raised by read_whitespace *)
	Token.EOF (Token.IN_STRING so_far)

    fun read_char(arg as (location, buffer, error_info, so_far)) =
      let
	val str = case read_string arg of
	  Token.STRING s => s
	| _ => Crash.impossible"lexrules:read_string fails to return string"
      in
	if size str <> 1 then
	  Info.error' error_info (Info.RECOVERABLE, location,
				  "Character constant has wrong length string")
	else
	  Token.CHAR str
      end

    fun fix chars = Symbol.find_symbol(implode_char chars)

    fun split ([], chars, ids) = fix chars :: ids
      | split (c :: rest, chars, ids) =
	if c = ord #"." then
	  split(rest, [], fix chars :: ids)
	else split(rest, c :: chars, ids)

(*
    fun fix chars = Symbol.find_symbol(implode chars)

    fun split ([], chars, ids) = fix chars :: ids
      | split (c :: rest, chars, ids) =
	if c = ord #"." then
	  split(rest, [], fix chars :: ids)
	else split(rest, chr c :: chars, ids)
*)

    fun getLast ([], _) =
      Crash.impossible "lexrules.getLast"
      | getLast ([id], strids) = (rev strids, id)
      | getLast (strid :: rest, strids) =
	getLast(rest, strid :: strids)

    val symfuns = 
      map (fn (s,f) => (map ord (rev (explode s)),f))
      [("abstype",fn _ => Token.RESERVED (Token.ABSTYPE)),
       ("and",	fn _ => Token.RESERVED (Token.AND)),
	("andalso",fn _ => Token.RESERVED (Token.ANDALSO)),
	("as",	fn _ => Token.RESERVED (Token.AS)),
	("case",	fn _ => Token.RESERVED (Token.CASE)),
	("do",	fn _ => Token.RESERVED (Token.DO)),
	("datatype",fn _ => Token.RESERVED (Token.DATATYPE)),
	("else",	fn _ => Token.RESERVED (Token.ELSE)),
	("end",	fn _ => Token.RESERVED (Token.END)),
	("exception",fn _ => Token.RESERVED (Token.EXCEPTION)),
	("fn",	fn _ => Token.RESERVED (Token.FN)),
	("fun",	fn _ => Token.RESERVED (Token.FUN)),
	("handle",	fn _ => Token.RESERVED (Token.HANDLE)),
	("if",	fn _ => Token.RESERVED (Token.IF)),
	("in",	fn _ => Token.RESERVED (Token.IN)),
	("infix",	fn _ => Token.RESERVED (Token.INFIX)),
	("infixr",	fn _ => Token.RESERVED (Token.INFIXR)),
	("let",	fn _ => Token.RESERVED (Token.LET)),
	("local",	fn _ => Token.RESERVED (Token.LOCAL)),
	("nonfix",	fn _ => Token.RESERVED (Token.NONFIX)),
	("of",	fn _ => Token.RESERVED (Token.OF)),
	("op",	fn _ => Token.RESERVED (Token.OP)),
	("open",	fn _ => Token.RESERVED (Token.OPEN)),
	("orelse",	fn _ => Token.RESERVED (Token.ORELSE)),
	("raise",	fn _ => Token.RESERVED (Token.RAISE)),
	("rec",	fn _ => Token.RESERVED (Token.REC)),
	("require",fn options =>
                        case options of
			    Options.OPTIONS {
			      extension_options = Options.EXTENSIONOPTIONS {
			        require_keyword = true, ...
			      },
			    ...} => Token.RESERVED (Token.REQUIRE)
			  | _ => Token.LONGID ([],
					       Symbol.find_symbol "require")),
	("then",	fn _ => Token.RESERVED (Token.THEN)),
	("type",	fn _ => Token.RESERVED (Token.TYPE)),
	("val",	fn _ => Token.RESERVED (Token.VAL)),
	("with",	fn _ => Token.RESERVED (Token.WITH)),
	("withtype",fn _ => Token.RESERVED (Token.WITHTYPE)),
	("while",	fn _ => Token.RESERVED (Token.WHILE)),
	("eqtype",	fn _ => Token.RESERVED (Token.EQTYPE)),
	("functor",fn _ => Token.RESERVED (Token.FUNCTOR)),
	("include",fn _ => Token.RESERVED (Token.INCLUDE)),
	("sharing",fn _ => Token.RESERVED (Token.SHARING)),
	("sig",	fn _ => Token.RESERVED (Token.SIG)),
	("signature",fn _ => Token.RESERVED (Token.SIGNATURE)),
	("struct",	fn _ => Token.RESERVED (Token.STRUCT)),
	("structure",fn _ => Token.RESERVED (Token.STRUCTURE)),
	("where",
         fn options =>
         let
           val Options.OPTIONS
             {compat_options =
              Options.COMPATOPTIONS {old_definition, ...},...} =
             options
         in
           if old_definition
             then Token.LONGID ([],Symbol.find_symbol "where")
           else Token.RESERVED (Token.WHERE)
         end),
	("abstraction",
         fn options =>
         let
           val Options.OPTIONS
             {compat_options =
              Options.COMPATOPTIONS {abstractions, ...},...} =
             options
         in
           if abstractions
             then Token.RESERVED (Token.ABSTRACTION)
           else Token.LONGID ([],Symbol.find_symbol "abstraction")
         end),
	(":>",
         fn options =>
         let
           val Options.OPTIONS
             {compat_options =
              Options.COMPATOPTIONS {old_definition, ...},...} =
             options
         in
           if old_definition
             then Token.LONGID ([],Symbol.find_symbol ":>")
           else Token.RESERVED (Token.ABSCOLON)
         end),
	(":",	fn _ => Token.RESERVED(Token.COLON)),
	("|",	fn _ => Token.RESERVED(Token.VBAR)),
	("=",	fn _ => Token.RESERVED(Token.EQUAL)),
	("=>",	fn _ => Token.RESERVED(Token.DARROW)),
	("->",	fn _ => Token.RESERVED(Token.ARROW)),
	("#",	fn _ => Token.RESERVED(Token.HASH))]

    val max_length = 15
    val keywords = MLWorks.Internal.Array.array (max_length,[])

      (* NJ requires a type constrant here *)
      : (int list * (Options.options -> Token.Token)) list MLWorks.Internal.Array.array

    val _ =
      map
      (fn (data as (s,f)) =>
       let
         val len = length s
         val entry = MLWorks.Internal.Array.sub (keywords,len)
       in
         MLWorks.Internal.Array.update (keywords,len,data::entry)
       end)
      symfuns

    fun do_long_id s = 
      Token.LONGID(getLast (split(s, [], []), []))

    fun eqchars ([],[]) = true
      | eqchars ([],_::_) = false
      | eqchars (_::_,[]) = false
      | eqchars ((c:int)::rest,(c':int)::rest') = c = c' andalso eqchars (rest,rest')

    fun do_name_token (s,options) =
      let
        fun lookup [] = do_long_id s
          | lookup ((s',f)::rest) =
            if eqchars(s,s') then f options else lookup rest
        val len = length s
      in
        if len < max_length
          then lookup (MLWorks.Internal.Array.sub (keywords,len))
        else do_long_id s
      end

    fun make_tyvar (s,options) = 
      let
        val Options.OPTIONS {compat_options = Options.COMPATOPTIONS {old_definition,...},
                             ...} = options
        val name = convert s
	val sz = size name
        val is_eq = 
	  sz >= 2 andalso
	  String.sub(name, 1) = #"'"
        (* All variable are imperative with the new definition! *)
        val is_imp = 
          if old_definition then
	    if is_eq then
	      (sz >= 3) andalso 
	      String.sub(name, 2) = #"_"
	    else 
	      (sz >= 2) andalso 
	      String.sub(name, 1) = #"_"
	  else
            false
      in
        Token.TYVAR(Symbol.find_symbol name,is_eq,is_imp)
      end (* make_tyvar *)

    val rules =
       [(* numbers *)
	
	(intnum,		fn (_,_,s,_) => Token.INTEGER (convert s)),
	(hexintnum,		fn (_,_,s,_) => Token.INTEGER (convert s)),
	(intword,		fn (_,_,s,_) => Token.WORD (convert s)),

	(hexintword,		fn (_,_,s,_) => Token.WORD (convert s)),
        (* Check that we don't have a misplaced . here *)
	(realnum,
         fn (p,_,s,(error_info,options)) => 
         let
           fun check (#"." ::d::rest) = is_digit (ord d)
             | check [#"." ] = false
             | check (a::b) = check b
             | check [] = true
           val str = convert s
         in
           if check (explode str) then
	     ()
           else
             Info.error error_info
             (Info.RECOVERABLE,p,
              "Malformed real literal: " ^ str);
           Token.REAL (convert s)
         end),
	
	(* type variables *)
	
	(tyvar,			fn (_,_,s,(error_info,options)) => make_tyvar (s,options)),

	(* Symbolic keywords *)
        (* The following are not valid identifiers, so lex them separately *)
	(node "(",	fn _ => Token.RESERVED(Token.LPAR)),
	(node ")",	fn _ => Token.RESERVED(Token.RPAR)),
	(node "[",	fn _ => Token.RESERVED(Token.BRA)),
	(node "]",	fn _ => Token.RESERVED(Token.KET)),
	(node "{",	fn _ => Token.RESERVED(Token.LBRACE)),
	(node "}",	fn _ => Token.RESERVED(Token.RBRACE)),
	(node ",",	fn _ => Token.RESERVED(Token.COMMA)),
	(node ";",	fn _ => Token.RESERVED(Token.SEMICOLON)),
	(node "...",	fn _ => Token.RESERVED(Token.ELLIPSIS)),
	(node "_",	fn _ => Token.RESERVED(Token.UNDERBAR)),
        (* This ought to do something appropriate if dynamic option not set *)
	(node "#(", 
         fn (loc,_,_,(error_info, options)) => 
         case options of
           Options.OPTIONS 
           {extension_options = 
            Options.EXTENSIONOPTIONS 
            {type_dynamic = true, ...},...} => Token.RESERVED (Token.MAGICOPEN)
          | _ => 
              (Info.error
               error_info
               (Info.RECOVERABLE, loc,
                "Dynamic type bracket not valid with these options: replacing with left parenthesis");
               Token.RESERVED (Token.LPAR))),

	(* identifiers and keywords *)
	
        (long_id, fn (_,_,s,(_,options)) => do_name_token (s,options)),
	
	(* comments and strings *)
	
	(node "(*",	fn (loc,buf,_,(error_info, options)) =>
			  read_comment (buf,1)),

	(node "#\"",
	                fn (loc, buf, _, (error_info, _)) =>
			  read_char(loc, buf, error_info, [])),

        (node "\"",	fn (loc,buf,_,(error_info,_)) =>
			  read_string (loc,buf,error_info,[])),
	 
        (* whitespace *)
	 
	 (whitespace,	fn _ => Token.IGNORE)
         
	 ]

  end
	   
end

@


1.47.3.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.47  1997/07/21  08:52:17  daveb
 * [Bug #30090]
 * Removed spurious require on __old.
 *
@


1.47.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 4
 * Revision 1.47  1997/07/21  08:52:17  daveb
 * [Bug #30090]
 * Removed spurious require on __old.
 *
@


1.47.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 4
 * Revision 1.47  1997/07/21  08:52:17  daveb
 * [Bug #30090]
 * Removed spurious require on __old.
 *
@


1.46
log
@[Bug #1728]
__integer becomes __int
@
text
@d3 4
a180 1
require "^.basis.__old";
@


1.46.5.1
log
@branched from 1.46
@
text
@a2 4
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.46.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.46.5.1  1997/05/12  10:35:26  hope
 * branched from 1.46
 *
@


1.46.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.46.5.1  1997/05/12  10:35:26  hope
 * branched from 1.46
 *
@


1.46.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.46.5.1  1997/05/12  10:35:26  hope
 * branched from 1.46
 *
@


1.46.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.46.5.1.1.1  1997/07/28  18:20:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.46.4.1
log
@branched from 1.46
@
text
@a2 4
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.46.3.1
log
@branched from 1.46
@
text
@a2 4
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.46.3.1.1.1
log
@branched from 1.46.3.1
@
text
@a2 3
 * Revision 1.46.3.1  1996/12/17  17:48:56  hope
 * branched from 1.46
 *
@


1.46.2.1
log
@branched from 1.46
@
text
@a2 4
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.46.1.1
log
@branched from 1.46
@
text
@a2 4
 * Revision 1.46  1996/11/06  10:55:08  matthew
 * [Bug #1728]
 * __integer becomes __int
 *
@


1.46.1.1.1.1
log
@branched from 1.46.1.1
@
text
@a2 3
 * Revision 1.46.1.1  1996/11/14  12:51:01  hope
 * branched from 1.46
 *
@


1.45
log
@[Bug #1725]
Remove unsafe string operations introduced when String structure removed
@
text
@d3 4
d176 1
a176 1
require "../basis/__integer";
@


1.44
log
@[Bug #1614]
leftover String.ord
@
text
@d3 4
d174 1
d740 1
a740 1
	  MLWorks.Internal.Value.unsafe_string_sub (name, 1) = ord #"'"
d746 1
a746 1
	      MLWorks.Internal.Value.unsafe_string_sub (name, 2) = ord #"_"
d749 1
a749 1
	      MLWorks.Internal.Value.unsafe_string_sub (name, 1) = ord #"_"
@


1.43
log
@[Bug #1614]
removing toplevel String.
@
text
@d3 4
d496 1
a496 1
                      if c'=(String.ord "u") then
@


1.42
log
@[Bug #1646]
Adding new escape sequence.
@
text
@d3 4
d165 1
d273 3
a275 3
    val lparen = String.ord "("
    val rparen = String.ord ")"
    val star = String.ord "*"
d328 1
a328 1
 5. a \x sequence, where x is not n, t, ^, ", \, a format char or a digit
d356 1
a356 1
	else if c = String.ord "\\" then
d366 11
a376 11
    fun is_digit c = c >= String.ord "0" andalso c <= String.ord "9"
    fun hexdigit c = if is_digit c then c-String.ord "0"
                     else if c>=String.ord "a" andalso c<=String.ord "f"
                            then 10+c-(String.ord "a")
                              else if c>=String.ord "A" andalso
                                      c<=String.ord "Z" 
                                     then 10+c-String.ord "A"
                                   else ~1



d388 1
a388 1
		(error_info, n - 1, b, location, 10 * c + c1-String.ord "0")
d417 4
a420 4
        val escapes = [(String.ord "n",String.ord "\n"),
                       (String.ord "t",String.ord "\t"),
                       (String.ord "\"",String.ord "\""),
                       (String.ord "\\", String.ord "\\"),
d422 5
a426 6
                       (String.ord "a", 7),
                       (String.ord "b", 8),
                       (String.ord "v", 11),
                       (String.ord "f", 12),
                       (String.ord "r",13)]

d447 3
a449 3
	    val quote = String.ord "\""
	    val backslash = String.ord "\\"
	    val newline = String.ord "\n"
d460 1
a460 1
                  if c' = String.ord "^" then
d479 1
a479 1
                                               c' - String.ord "0")
d572 1
a572 1
	if c = String.ord "." then
d581 1
a581 1
	if c = String.ord "." then
d593 1
a593 1
      map (fn (s,f) => (map String.ord (rev (String.explode s)),f))
d696 1
a696 1
         val len = Lists.length s
d716 1
a716 1
        val len = Lists.length s
d728 4
a731 1
        val is_eq = size name >= 2 andalso String.ordof (name,1) = String.ord"'"
d734 8
a741 6
          if old_definition
            then
              if is_eq then
                size name >= 3 andalso String.ordof (name,2) = String.ord"_"
              else size name >= 2 andalso String.ordof (name,1) = String.ord"_"
          else
d745 1
a745 1
      end
d759 2
a760 2
           fun check ("."::d::rest) = is_digit (String.ord d)
             | check ["."] = false
d765 2
a766 2
           if check (String.explode str)
             then ()
@


1.42.1.1
log
@branched from 1.42
@
text
@a2 4
 * Revision 1.42  1996/10/10  10:25:53  andreww
 * [Bug #1646]
 * Adding new escape sequence.
 *
@


1.41
log
@abstractions is now a compatibility option.
@
text
@d3 3
d362 9
d383 1
a383 1
		(error_info, n - 1, b, location, 10 * c + c1 - String.ord "0")
d391 18
d423 1
d488 16
a503 5
                      if format_char c' then
                        (read_whitespace (location, b, error_info);
                         aux (b, l))
                        handle InBuffer.Eof =>
                          Token.EOF (Token.IN_STRING (l @@ so_far))
d505 12
a516 6
                        (Info.error
                         error_info
                         (Info.RECOVERABLE, new_location (b, location),
                          "Illegal character after \\ in string, " ^
                          "ASCII " ^ Int.toString c');
                         aux (b, l)) (* string reading error case 5 *)
@


1.41.3.1
log
@branched from 1.41
@
text
@a2 3
 * Revision 1.41  1996/05/21  13:43:38  daveb
 * abstractions is now a compatibility option.
 *
@


1.41.2.1
log
@branched from 1.41
@
text
@a2 3
 * Revision 1.41  1996/05/21  13:43:38  daveb
 * abstractions is now a compatibility option.
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a2 3
 * Revision 1.41  1996/05/21  13:43:38  daveb
 * abstractions is now a compatibility option.
 *
@


1.41.1.2
log
@Use position instead of inbuffer.
@
text
@a2 3
 * Revision 1.41.1.1  1996/08/19  11:49:25  hope
 * branched from 1.41
 *
d157 1
a157 1
require "position";
d167 1
a167 1
   structure Position : POSITION
a170 1
  structure Position = Position
d172 1
d239 1
a239 1
	    (location_file l, Position.getlinenum b, Position.getlinepos b)
d245 2
a246 2
	     Position.getlinenum b - 1,
	     Position.getlastlinepos b)
d251 2
a252 2
				      e_line = Position.getlinenum b,
				      e_col = Position.getlinepos b})
d280 1
a280 1
	fun getchar b = Position.getchar b
d313 1
a313 1
	handle Position.Eof => Token.EOF (Token.IN_COMMENT (!depth'))
d347 1
a347 1
	val c = Position.getchar buffer
d365 1
a365 1
	val getchar = Position.getchar
d463 1
a463 1
                        handle Position.Eof =>
d495 1
a495 1
	handle Position.Eof =>
d503 1
a503 1
      handle Position.Eof => (*  can only be raised by read_whitespace *)
@


1.41.1.3
log
@Basifying.
@
text
@a2 3
 * Revision 1.41.1.2  1996/08/20  11:35:36  davids
 * Use position instead of inbuffer.
 *
a163 1
require "../basis/__array";
d641 1
a641 1
    val keywords = Array.array (max_length,[])
d644 1
a644 1
      : (int list * (Options.options -> Token.Token)) list Array.array
d651 1
a651 1
         val entry = Array.sub (keywords,len)
d653 1
a653 1
         Array.update (keywords,len,data::entry)
d673 1
a673 1
          then lookup (Array.sub (keywords,len))
@


1.40
log
@Array moving to MLWorks.Array
@
text
@d3 3
d607 2
a608 2
             {extension_options =
              Options.EXTENSIONOPTIONS {abstractions, ...},...} =
@


1.39
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d632 1
a632 1
    val keywords = Array.array (max_length,[])
d635 1
a635 1
      : (int list * (Options.options -> Token.Token)) list Array.array
d642 1
a642 1
         val entry = Array.sub (keywords,len)
d644 1
a644 1
         Array.update (keywords,len,data::entry)
d664 1
a664 1
          then lookup (Array.sub (keywords,len))
@


1.38
log
@Integer changes
,
@
text
@d3 4
d256 3
a258 3
    val lparen = ord "("
    val rparen = ord ")"
    val star = ord "*"
d339 1
a339 1
	else if c = ord "\\" then
d349 1
a349 1
    fun is_digit c = c >= ord "0" andalso c <= ord "9"
d362 1
a362 1
		(error_info, n - 1, b, location, 10 * c + c1 - ord "0")
d373 4
a376 4
        val escapes = [(ord "n",ord "\n"),
                       (ord "t",ord "\t"),
                       (ord "\"",ord "\""),
                       (ord "\\", ord "\\"),
d378 5
a382 5
                       (ord "a", 7),
                       (ord "b", 8),
                       (ord "v", 11),
                       (ord "f", 12),
                       (ord "r",13)]
d403 3
a405 3
	    val quote = ord "\""
	    val backslash = ord "\\"
	    val newline = ord "\n"
d416 1
a416 1
                  if c' = ord "^" then
d435 1
a435 1
                                               c' - ord "0")
d511 1
a511 1
	if c = ord "." then
d520 1
a520 1
	if c = ord "." then
d532 1
a532 1
      map (fn (s,f) => (map ord (rev (explode s)),f))
d667 1
a667 1
        val is_eq = size name >= 2 andalso String.ordof (name,1) = ord"'"
d673 2
a674 2
                size name >= 3 andalso String.ordof (name,2) = ord"_"
              else size name >= 2 andalso String.ordof (name,1) = ord"_"
d693 1
a693 1
           fun check ("."::d::rest) = is_digit (ord d)
d699 1
a699 1
           if check (explode str)
@


1.37
log
@Changing default imperative attibute to false.  This was trying to be too clever.
@
text
@d3 3
d144 2
d423 1
a423 1
                          "ASCII " ^ MLWorks.Integer.makestring c'');
d440 1
a440 1
                            "\"\\" ^ MLWorks.Integer.makestring c'' ^ "\"");
d454 1
a454 1
                          "ASCII " ^ MLWorks.Integer.makestring c');
d474 1
a474 1
			 MLWorks.Integer.makestring c);
@


1.36
log
@Updating for new language
@
text
@d3 3
d667 1
a667 1
            true
@


1.35
log
@Changin magic open bracker to #(
@
text
@d3 3
d150 3
d189 1
a189 4
    val eqtyvar = node "''" & alphas
    val imptyvar = node "'_" & alphas
    val eqimptyvar = node "''_" & alphas
      
d361 28
d402 1
a402 1
		if c' = ord "n" then aux (b, ord "\n" :: l)
d404 44
a447 50
		  if c' = ord "t" then aux (b, ord "\t" :: l)
		  else
		    if c' = quote then aux (b, ord "\"" :: l)
		    else
		      if c' = backslash then aux (b, ord "\\" :: l)
		      else
			if c' = ord "^" then
			  let
			    val c'' = getchar b
			  in
			    if c'' >= 64 andalso c'' <= 95 then
			      aux (b, (c'' - 64) :: l)
			    else
			      (Info.error
			       error_info
			       (Info.RECOVERABLE, new_location (b, location),
				"Illegal character after \\^ in string, " ^
				"ASCII " ^ MLWorks.Integer.makestring c'');
			       aux (b, l))
			      (* string reading error case 3 *)
			  end
			else
			  if is_digit c' then
			    let
			      val c'' = read_digits (error_info, 2, b, location,
						     c' - ord "0")
			    in
                              if c'' >= 0 andalso c'' < 256 
                                then aux (b, c'' :: l)
                              else
                                (Info.error
                                 error_info
                                 (Info.RECOVERABLE, new_location (b, location),
                                  "Out of range numeric character specification in string " ^
                                  "\"\\" ^ MLWorks.Integer.makestring c'' ^ "\"");
                                 aux (b,l)) (* string reading error case 8 *)
			    end
			  else
			    if format_char c' then
			      (read_whitespace (location, b, error_info);
			       aux (b, l))
			      handle InBuffer.Eof =>
				Token.EOF (Token.IN_STRING (l @@ so_far))
			    else
			      (Info.error
			       error_info
			       (Info.RECOVERABLE, new_location (b, location),
				"Illegal character after \\ in string, " ^
				"ASCII " ^ MLWorks.Integer.makestring c');
			       aux (b, l)) (* string reading error case 5 *)
d570 12
d594 12
d650 19
d675 1
d698 1
a698 4
	(eqimptyvar,		fn (_,_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),true,true)),
	(imptyvar,		fn (_,_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),false,true)),
	(eqtyvar,		fn (_,_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),true,false)),
	(tyvar,			fn (_,_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),false,false)),
a734 7
        (* report error and continue *)
        (node "*)",	fn (p,_,_,(error_info, options)) =>
         		  (Info.error
			     error_info
		             (Info.RECOVERABLE, p,
			      "Mismatched comment");
                           Token.IGNORE)),
@


1.34
log
@Add word literal
@
text
@d3 3
d562 1
a562 17
	("#",	fn _ => Token.RESERVED(Token.HASH)),
	("<<",	fn options =>
                        case options of
                           Options.OPTIONS {
			      extension_options = Options.EXTENSIONOPTIONS {
			        type_dynamic = true, ...
			      },
			    ...} => Token.RESERVED (Token.MAGICOPEN)
			  | _ => Token.LONGID ([], Symbol.find_symbol "<<")),
	(">>",	fn options =>
			  case options of
			    Options.OPTIONS {
			      extension_options = Options.EXTENSIONOPTIONS {
			        type_dynamic = true, ...
			      },
			    ...} => Token.RESERVED (Token.MAGICCLOSE)
			  | _ => Token.LONGID ([], Symbol.find_symbol ">>"))]
d646 14
@


1.33
log
@Add recognition of character special constants
@
text
@d3 3
d187 1
a187 1
    val hexdigits = node "0" & node "x" & plus(hexDigit)
d190 1
d192 1
d619 2
@


1.32
log
@Recognise hex integers as integers
@
text
@d3 3
d449 13
d668 4
@


1.31
log
@Adding cached chr function
@
text
@d3 3
d154 1
d181 1
d184 1
d597 1
@


1.30
log
@Improving message for malformed real literals
@
text
@d3 3
d182 3
a184 2
    fun change (res, c) = chr c :: res
    fun convert l = implode(Lists.reducel change ([], l))
d349 1
a349 1
	      Token.STRING (implode (rev (l @@ so_far)))
d354 1
a354 1
		if c' = ord "n" then aux (b, "\n" :: l)
d356 1
a356 1
		  if c' = ord "t" then aux (b, "\t" :: l)
d358 1
a358 1
		    if c' = quote then aux (b, "\"" :: l)
d360 1
a360 1
		      if c' = backslash then aux (b, "\\" :: l)
d367 1
a367 1
			      aux (b, chr (c'' - 64) :: l)
d384 1
a384 1
                                then aux (b, chr c'' :: l)
d413 1
a413 1
		      Token.STRING(implode (rev (l @@ so_far))))
d418 1
a418 1
		       aux (b, chr c :: l)
d440 9
d456 1
@


1.29
log
@Add a type constraint required by NJ for the daily build.
@
text
@d3 3
d174 1
a174 1
    val frac = node "." & digits
d313 2
a318 2
	fun digit c = c >= ord "0" andalso c <= ord "9"

d324 1
a324 1
	      if digit c1 then
d374 1
a374 1
			  if digit c' then
d577 18
a594 1
	(realnum,		fn (_,_,s,_) => Token.REAL (convert s)),
@


1.28
log
@Changed the way keywords are lexed.
@
text
@d3 3
d535 4
@


1.27
log
@Improving location reported for erroneous newline in string.
@
text
@d3 3
d444 30
a473 29
    val rules =
       [(node "abstype",fn _ => Token.RESERVED (Token.ABSTYPE)),
	(node "and",	fn _ => Token.RESERVED (Token.AND)),
	(node "andalso",fn _ => Token.RESERVED (Token.ANDALSO)),
	(node "as",	fn _ => Token.RESERVED (Token.AS)),
	(node "case",	fn _ => Token.RESERVED (Token.CASE)),
	(node "do",	fn _ => Token.RESERVED (Token.DO)),
	(node "datatype",fn _ => Token.RESERVED (Token.DATATYPE)),
	(node "else",	fn _ => Token.RESERVED (Token.ELSE)),
	(node "end",	fn _ => Token.RESERVED (Token.END)),
	(node "exception",fn _ => Token.RESERVED (Token.EXCEPTION)),
	(node "fn",	fn _ => Token.RESERVED (Token.FN)),
	(node "fun",	fn _ => Token.RESERVED (Token.FUN)),
	(node "handle",	fn _ => Token.RESERVED (Token.HANDLE)),
	(node "if",	fn _ => Token.RESERVED (Token.IF)),
	(node "in",	fn _ => Token.RESERVED (Token.IN)),
	(node "infix",	fn _ => Token.RESERVED (Token.INFIX)),
	(node "infixr",	fn _ => Token.RESERVED (Token.INFIXR)),
	(node "let",	fn _ => Token.RESERVED (Token.LET)),
	(node "local",	fn _ => Token.RESERVED (Token.LOCAL)),
	(node "nonfix",	fn _ => Token.RESERVED (Token.NONFIX)),
	(node "of",	fn _ => Token.RESERVED (Token.OF)),
	(node "op",	fn _ => Token.RESERVED (Token.OP)),
	(node "open",	fn _ => Token.RESERVED (Token.OPEN)),
	(node "orelse",	fn _ => Token.RESERVED (Token.ORELSE)),
	(node "raise",	fn _ => Token.RESERVED (Token.RAISE)),
	(node "rec",	fn _ => Token.RESERVED (Token.REC)),
	(node "require",fn (_,_,s,(_,options)) =>
			  case options of
d481 16
a496 16
	(node "then",	fn _ => Token.RESERVED (Token.THEN)),
	(node "type",	fn _ => Token.RESERVED (Token.TYPE)),
	(node "val",	fn _ => Token.RESERVED (Token.VAL)),
	(node "with",	fn _ => Token.RESERVED (Token.WITH)),
	(node "withtype",fn _ => Token.RESERVED (Token.WITHTYPE)),
	(node "while",	fn _ => Token.RESERVED (Token.WHILE)),
	(node "eqtype",	fn _ => Token.RESERVED (Token.EQTYPE)),
	(node "functor",fn _ => Token.RESERVED (Token.FUNCTOR)),
	(node "include",fn _ => Token.RESERVED (Token.INCLUDE)),
	(node "sharing",fn _ => Token.RESERVED (Token.SHARING)),
	(node "sig",	fn _ => Token.RESERVED (Token.SIG)),
	(node "signature",fn _ => Token.RESERVED (Token.SIGNATURE)),
	(node "struct",	fn _ => Token.RESERVED (Token.STRUCT)),
	(node "structure",fn _ => Token.RESERVED (Token.STRUCTURE)),
	(node "abstraction",
         fn (_,_,s,(_,options)) =>
d507 9
a515 19
	(node "(",	fn _ => Token.RESERVED(Token.LPAR)),
	(node ")",	fn _ => Token.RESERVED(Token.RPAR)),
	(node "[",	fn _ => Token.RESERVED(Token.BRA)),
	(node "]",	fn _ => Token.RESERVED(Token.KET)),
	(node "{",	fn _ => Token.RESERVED(Token.LBRACE)),
	(node "}",	fn _ => Token.RESERVED(Token.RBRACE)),
	(node ",",	fn _ => Token.RESERVED(Token.COMMA)),
	(node ":",	fn _ => Token.RESERVED(Token.COLON)),
	(node ";",	fn _ => Token.RESERVED(Token.SEMICOLON)),
	(node "...",	fn _ => Token.RESERVED(Token.ELLIPSIS)),
	(node "_",	fn _ => Token.RESERVED(Token.UNDERBAR)),
	(node "|",	fn _ => Token.RESERVED(Token.VBAR)),
	(node "=",	fn _ => Token.RESERVED(Token.EQUAL)),
	(node "=>",	fn _ => Token.RESERVED(Token.DARROW)),
	(node "->",	fn _ => Token.RESERVED(Token.ARROW)),
	(node "#",	fn _ => Token.RESERVED(Token.HASH)),
	(node "<<",	fn (_,_,s,(_,options)) =>
			  case options of
			    Options.OPTIONS {
d521 1
a521 1
	(node ">>",	fn (_,_,s,(_,options)) =>
d528 37
a564 3
			  | _ => Token.LONGID ([], Symbol.find_symbol ">>")),
	
	(* numbers *)
d575 15
a589 2
	
	(* other identifiers *)
d591 1
a591 1
        (long_id, fn (_,_,s,_) => Token.LONGID(getLast (split(s, [], []), []))),
@


1.26
log
@Added error check for numeric specification out of range.
@
text
@d3 3
d184 7
d398 1
a398 1
		      (Info.RECOVERABLE, new_location (b, location),
@


1.25
log
@Merging in bug fixes.
@
text
@d3 3
d259 1
d360 9
a368 1
			      aux (b, chr c'' :: l)
@


1.24
log
@Removed some handlers in favour of a different mechanism. Comment lexing
and string lexing should improve dramatically
@
text
@d3 8
d245 22
a266 1
      
d287 1
a287 1
		())
d292 1
a292 6
	fun getchar b = InBuffer.getchar b
(*
	  handle InBuffer.Eof =>
	    Info.error' error_info (Info.FATAL, extend_location (b, location),
				    "Unexpected end of string");
*)
d309 1
a309 1
		 0)
d339 1
a339 1
			    if c'' >= ord "@@" andalso c'' <= ord "_" then
d347 2
a348 1
			       Token.STRING (implode (rev (l @@ so_far))))
d370 1
a370 1
			       Token.STRING (implode (rev (l @@ so_far))))
d379 1
d390 1
a390 1
			Token.STRING (implode (rev (l @@ so_far))))
@


1.24.1.1
log
@Fork for bug fixing
@
text
@a2 4
Revision 1.24  1993/08/25  19:02:21  jont
Removed some handlers in favour of a different mechanism. Comment lexing
and string lexing should improve dramatically

@


1.24.1.2
log
@Fixed error recovery on string reading, and added comment to
describe error conditions.
@
text
@d241 1
a241 22

(* string reading. There are various ways in which string reading can
 go wrong:

 1. an unescaped newline
 2. another unescaped character
 3. a \^c sequence, where c is outside the range 64--95
 4. a \dxy sequence, where one of xy is not a digit
 5. a \x sequence, where x is not n, t, ^, ", \, a format char or a digit
 6. a \fffffx sequence, where x is not \ or a format char
 7. Eof

We report an error for each of these (except Eof in a formatting
string, for the interactive lexer). In case 1, we stop reading and
return the current string (since the programmer has probably failed to
close it, and we don't want to read the rest of the file as a string.
In cases 2-6 we continue reading the string. In case 7, obviously, we
stop.

Nick Haines 06-Oct-93
*)

d262 1
a262 1
		()) (* string reading error case 6 *)
d267 6
a272 1
	val getchar = InBuffer.getchar
d289 1
a289 1
		 0) (* string reading error case 4 *)
d319 1
a319 1
			    if c'' >= 64 andalso c'' <= 95 then
d327 1
a327 2
			       aux (b, l))
			      (* string reading error case 3 *)
d349 1
a349 1
			       aux (b, l)) (* string reading error case 5 *)
a357 1
		     (* string reading error case 1 *)
d368 1
a368 1
			aux (b,l)) (* string reading error case 2 *)
@


1.23
log
@Better regexp for long_id's
@
text
@d3 3
d187 2
a188 2
    fun read_comment (buffer, depth) =
      let exception Depth of int
d190 3
a192 4
	  (* Need to take care when placing handlers.
	     Don't lose tail-recursiveness. *)
	  fun getchar (b, n) =
		InBuffer.getchar b handle InBuffer.Eof => raise Depth n
a193 5
	  (* We use comparisons of integer encodings, because comparing
	     strings is expensive. *)
	  val lparen = ord "("
	  val rparen = ord ")"
	  val star = ord "*"
d195 13
a207 3
	  fun aux (b, 0) = Token.IGNORE
	  |   aux (b, n) =
            let val c = getchar (b, n)
d209 3
a211 3
               if c = lparen then do_lparen (b, n)
	       else if c = star then do_star (b, n)
	       else aux (b, n)
d215 2
a216 1
            let val c = getchar (b, n)
d218 4
a221 3
	       if c = star then aux (b, n+1)
               else if c = lparen then do_lparen (b, n)
	       else aux (b, n)
d225 2
a226 1
            let val c = getchar (b, n)
d228 4
a231 3
	       if c = star then do_star (b, n)
               else if c = rparen then aux (b, n-1)
	       else aux (b, n)
d234 2
a235 2
	 aux (buffer, depth)
         handle Depth n => Token.EOF (Token.IN_COMMENT n)
d246 13
a258 11
      let val c = InBuffer.getchar buffer
      in if format_char c then
	   read_whitespace (location, buffer, error_info)
         else if c = ord "\\" then
	   ()
	 else 
	   (Info.error
	      error_info
	      (Info.RECOVERABLE, new_location (buffer, location),
	       "Missing \\ after formatting characters in string");
	       ())
d262 7
a268 1
      let exception SoFar of string list
d270 1
a270 7
	  fun getchar b =
	    InBuffer.getchar b
	    handle InBuffer.Eof =>
              Info.error' error_info (Info.FATAL, extend_location (b, location),
			     	      "Unexpected end of string");
	       
          fun digit c = c >= ord "0" andalso c <= ord "9"
d272 4
a275 21
          fun read_digits (_, 0, b, location, c) = c
          |   read_digits (error_info, n, b, location, c) =
            let val c1 = getchar b
            in if digit c1 then
	         read_digits
		   (error_info, n - 1, b, location, 10 * c + c1 - ord "0")
	       else
	         (Info.error
	            error_info
	            (Info.RECOVERABLE, new_location (b, location),
	             "Malformed numeric character specification in string");
	          0)
            end
      
          fun printable c = c >= 32 andalso c <= 126	(* includes space *)

	  fun aux (b, l) = 
	    let val quote = ord "\""
		val backslash = ord "\\"
		val newline = ord "\n"
		val c = getchar b
d277 3
a279 48
	      if c = quote then
		Token.STRING (implode (rev (l @@ so_far)))
	      else if c = backslash then
		let val c' = getchar b
		in
		  if c' = ord "n" then aux (b, "\n" :: l)
		  else if c' = ord "t" then aux (b, "\t" :: l)
		  else if c' = quote then aux (b, "\"" :: l)
		  else if c' = backslash then aux (b, "\\" :: l)
		  else if c' = ord "^" then
		    let val c'' = getchar b
		    in if c'' >= ord "@@" andalso c'' <= ord "_" then
		         aux (b, chr (c'' - 64) :: l)
		       else
            	         (Info.error
			    error_info
		       	    (Info.RECOVERABLE, new_location (b, location),
			     "Illegal character after \\^ in string, " ^
			     "ASCII " ^ MLWorks.Integer.makestring c'');
			  Token.STRING (implode (rev (l @@ so_far))))
		    end
	       	  else if digit c' then
		    let val c'' = read_digits (error_info, 2, b, location,
					       c' - ord "0")
		    in aux (b, chr c'' :: l)
		    end
		  else if format_char c' then
		    (read_whitespace (location, b, error_info);
		     aux (b, l))
      		    handle InBuffer.Eof =>
		      Token.EOF (Token.IN_STRING (l @@ so_far))
            	  else
		    (Info.error
		       error_info
		       (Info.RECOVERABLE, new_location (b, location),
		        "Illegal character after \\ in string, " ^
		        "ASCII " ^ MLWorks.Integer.makestring c');
		     Token.STRING (implode (rev (l @@ so_far))))
		end
	      else if c = newline then
	        (Info.error
		   error_info
		   (Info.RECOVERABLE, new_location (b, location),
		    "Unexpected newline in string");
            	 Token.STRING(implode (rev (l @@ so_far))))
	      else if printable c then
	        (* Can do better here - get a substring from the buffer *)
		aux (b, chr c :: l)
d282 4
a285 5
		   error_info
		   (Info.RECOVERABLE, new_location (b, location),
		    "Illegal character in string, ASCII " ^
		    MLWorks.Integer.makestring c);
		 Token.STRING (implode (rev (l @@ so_far))))
d287 79
d368 3
a370 1
        handle SoFar l => Token.EOF (Token.IN_STRING (l @@ so_far))
@


1.22
log
@Allow lexing of longids ending in "."
This is to make completion work.
@
text
@d3 4
d135 1
a135 1
    val long_id = id || id & star(node "." & id) & (node "." || node "." & id)
@


1.21
log
@Added code for abstractions.
@
text
@d3 3
d131 1
a131 1
    val long_id = id & star(node "." & id)
@


1.20
log
@Removed integer parameter
@
text
@d3 3
d405 12
@


1.19
log
@Miinor efficiency improvements
@
text
@d3 3
a76 1
require "../utils/integer";
a86 1
   structure Integer : INTEGER
d289 1
a289 1
			     "ASCII " ^ Integer.makestring c'');
d307 1
a307 1
		        "ASCII " ^ Integer.makestring c');
d324 1
a324 1
		    Integer.makestring c);
@


1.18
log
@Replaced lexers for strings and comments with faster, more functional,
simple functions.  EOFs are now annotated with a LexerState value, so
that we can lex strings and comments that extend over multiple lines
in a listener.  Removed the now redundant check_end_state.
@
text
@d3 6
d337 14
d448 1
a448 17
        (long_id, fn (_,_,s,_) => let
                            fun fix chars = Symbol.find_symbol(implode chars)

                            fun split ([], chars, ids) = fix chars :: ids
                              | split (c :: rest, chars, ids) =
                                if c = ord "." then
				  split(rest, [], fix chars :: ids)
                                else split(rest, chr c :: chars, ids)

                            fun getLast ([], _) =
				  Crash.impossible "lexrules.getLast"
                              | getLast ([id], strids) = (rev strids, id)
                              | getLast (strid :: rest, strids) =
				  getLast(rest, strid :: strids)
                          in
                            Token.LONGID(getLast (split(s, [], []), []))
                          end),
@


1.17
log
@Action functions now take an options parameter.  This is used to control
the interpretation of "require", "<<" and ">>".
@
text
@d3 4
d73 1
d82 1
d87 1
d111 1
a111 1
    val whitespace = plus(class " \n\t\012")
a112 13
    (*
     * Comment matching stuff. These rules are designed to match the
     * longest possible comment string, to reduce the number of actions
     * that have to be applied (this follows conventional lex wisdom
     * that the speed of a lexer depends on the number of actions
     * it performs, the complexity of the regular expressions has
     * no effect on speed.
     *)

    val comStart = plus(node "(") & node "*"
    val comEnd   = plus(node "*") & node ")"
    val comOther = negClass "(*" || (plus(node "(") & negClass "(*") || (plus(node "*") & negClass "()*")

a134 5
      
    (* things for strings *)
      
    val thisstring = ref [] : string list ref
    val instring = ref false
d138 17
a154 3
    fun addstring l = thisstring := (Lists.reducel change (!thisstring, l))
    fun addchar c = thisstring := chr c :: !thisstring
    fun addstr s = thisstring := s :: !thisstring
d159 71
a229 1
    type result = Token.Token
d231 2
a232 1
    val eof = Token.RESERVED(Token.EOF)
d234 21
a254 1
    val comment_depth = ref 0
d256 64
a319 4
    fun check_end_state (error_info,location) =
      let
        val string = !instring
        val depth = !comment_depth
d321 2
a322 13
        instring := false;
        comment_depth := 0;
        if string
          then
            Info.error' error_info
			(Info.FATAL,location,"Unclosed string at EOF")
        else
          if depth > 0
            then
              Info.error' error_info
			  (Info.FATAL,location,"Unclosed comment at EOF")
          else
            ()
d324 7
a330 1
 
a331 4
      [
       
       (* 0th (and main) lexer : ML text *)
       
d358 1
a358 1
	(node "require",fn (_,s,(_,options)) =>
d397 1
a397 1
	(node "<<",	fn (_,s,(_,options)) =>
d405 1
a405 1
	(node ">>",	fn (_,s,(_,options)) =>
d416 2
a417 2
	(intnum,		fn (_,s,_) => Token.INTEGER (convert s)),
	(realnum,		fn (_,s,_) => Token.REAL (convert s)),
d421 4
a424 4
	(eqimptyvar,		fn (_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),true,true)),
	(imptyvar,		fn (_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),false,true)),
	(eqtyvar,		fn (_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),true,false)),
	(tyvar,			fn (_,s,_) => Token.TYVAR((Symbol.find_symbol(convert s)),false,false)),
d428 1
a428 1
        (long_id, fn (_,s,_) => let
d448 2
a449 1
	(node "(*",	fn _ => (comment_depth := 1; Token.IGNORE 1)),
d451 9
a459 8
        (node "*)",	fn (p,_,(error_info, options)) =>
         (Info.error error_info
		     (Info.RECOVERABLE, p, "Ignoring mismatched comment");
          Token.IGNORE 0)),

        (node "\"",	fn _ => (instring := true;
				 thisstring := [];
				 Token.IGNORE 2)),
d463 1
a463 1
	 (whitespace,	fn _ => Token.IGNORE 0)
d465 1
a465 1
	 ],
a466 34
	 (* 1st lexer : inside a comment. For correctly nested comments  *)
	 
	 [(comStart, fn _ => (comment_depth := !comment_depth+1;
			      Token.IGNORE 1)),
          (comEnd  , fn _ => (comment_depth := !comment_depth-1;
			      Token.IGNORE (if !comment_depth = 0 then 0
					    else 1))),
	  (comOther, fn _ => Token.IGNORE 1)],

	 (* 2nd lexer : formatting inside strings. Called from first lexer. Ultimately returns STRING x *)

	 [(node "\\n",  fn _ => (addstr "\n"; Token.IGNORE 2)),
	  (node "\\t",  fn _ => (addstr "\t"; Token.IGNORE 2)),
	  (node "\\\"", fn _ => (addstr "\""; Token.IGNORE 2)),
	  (node "\\\\", fn _ => (addstr "\\"; Token.IGNORE 2)),
	  (node "\\^" & class "@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_",
	   fn (_, [m,_,_],_) => (addchar (m-64); Token.IGNORE 2)
	    | _       => Crash.impossible "Bad String Format"),
	  (node "\\" & digit & digit & digit,
	   fn (_, [a,b,c,_],_) => (addchar ((c - ord "0") * 100 + (b - ord "0") * 10 + (a - ord "0")); Token.IGNORE 2)
	    | _ => Crash.impossible "Quoted control char"),
	  (node "\\" & whitespace & node "\\",	fn _ => Token.IGNORE 2),
	  (node "\"", fn _ => (instring:= false;Token.STRING(implode (rev (!thisstring))))),
          (RegExp.printable, fn (_,l,_) => (addstring l; Token.IGNORE 2)),
          (node"\n", fn (p,_,(error_info, options)) =>
           (instring := false;
            Info.error error_info
		       (Info.RECOVERABLE, p, "Unexpected newline in string");
            Token.STRING(implode (rev (!thisstring))))),
          (RegExp.any, fn (p,_,(error_info, options)) =>
           (instring := false;
            Info.error error_info
		       (Info.RECOVERABLE, p, "Closing string on illegal character");
            Token.STRING(implode (rev (!thisstring)))))]]
@


1.16
log
@Adding magic brackets tokens.
There should be a switch to lex as normal
@
text
@d3 4
d66 1
d77 1
d80 2
d162 1
a162 1
    fun check_end_state (options,location) =
d171 2
a172 1
            Info.error' options (Info.FATAL,location,"Unclosed string at EOF")
d176 2
a177 1
              Info.error' options (Info.FATAL,location,"Unclosed comment at EOF")
d181 1
a181 1
      
d187 1
a187 1
       [(node "abstype", fn _ => Token.RESERVED (Token.ABSTYPE)),
d213 9
a221 1
	(node "require",fn _ => Token.RESERVED (Token.REQUIRE)),
d252 16
a267 2
        (node "<<",     fn _ => Token.RESERVED(Token.MAGICOPEN)),
        (node ">>",     fn _ => Token.RESERVED(Token.MAGICCLOSE)),
d283 2
a284 2
	(long_id, fn (_,s,_) => let
			    fun fix chars = Symbol.find_symbol(implode chars)
d286 14
a299 11
			    fun split ([], chars, ids) = fix chars :: ids
			      | split (c :: rest, chars, ids) =
				if c = ord "." then split(rest, [], fix chars :: ids)
				else split(rest, chr c :: chars, ids)

			    fun getLast ([], _) = Crash.impossible "lexrules.getLast"
			      | getLast ([id], strids) = (rev strids, id)
			      | getLast (strid :: rest, strids) = getLast(rest, strid :: strids)
			  in
			    Token.LONGID(getLast (split(s, [], []), []))
			  end),
d305 3
a307 2
        (node "*)",	fn (p,_,opts) =>
         (Info.error opts (Info.RECOVERABLE, p, "Ignoring mismatched comment");
d310 3
a312 1
        (node "\"",	fn _ => (instring := true; thisstring := []; Token.IGNORE 2)),
d322 5
a326 2
	 [(comStart, fn _ => (comment_depth := !comment_depth+1; Token.IGNORE 1)),
          (comEnd  , fn _ => (comment_depth := !comment_depth-1; Token.IGNORE (if !comment_depth = 0 then 0 else 1))),
d344 1
a344 1
          (node"\n", fn (p,_,opts) =>
d346 2
a347 1
            Info.error opts (Info.RECOVERABLE, p, "Unexpected newline in string");
d349 1
a349 1
          (RegExp.any, fn (p,_,opts) =>
d351 2
a352 1
            Info.error opts (Info.RECOVERABLE, p, "Closing string on illegal character");
@


1.15
log
@Hack to handle unclosed comments and strings
@
text
@d3 3
d234 2
@


1.14
log
@Added newline in string error.
@
text
@d3 3
d134 1
d151 18
d269 1
a269 1
        (node "\"",	fn _ => (thisstring := []; Token.IGNORE 2)),
d296 1
a296 1
	  (node "\"", fn _ => Token.STRING(implode (rev (!thisstring)))),
d299 2
a300 1
           (Info.error opts (Info.RECOVERABLE, p, "Unexpected newline in string");
d303 2
a304 1
           (Info.error opts (Info.RECOVERABLE, p, "Closing string on illegal character");
@


1.13
log
@Changed Error structure to Info
@
text
@d3 3
d276 3
@


1.12
log
@Replaced LexBasics error handler by proper global error stuff.
@
text
@d3 3
d53 1
a53 1
require "../main/error";
d63 1
a63 1
   structure Error : ERROR) : LEXRULES = 
d137 1
a137 1
    structure Error = Error
d209 2
a210 2
	(intnum,		fn (_, s) => Token.INTEGER (convert s)),
	(realnum,		fn (_, s) => Token.REAL (convert s)),
d214 4
a217 4
	(eqimptyvar,		fn (_, s) => Token.TYVAR((Symbol.find_symbol(convert s)),true,true)),
	(imptyvar,		fn (_, s) => Token.TYVAR((Symbol.find_symbol(convert s)),false,true)),
	(eqtyvar,		fn (_, s) => Token.TYVAR((Symbol.find_symbol(convert s)),true,false)),
	(tyvar,			fn (_, s) => Token.TYVAR((Symbol.find_symbol(convert s)),false,false)),
d221 1
a221 1
	(long_id, fn (_, s) => let
d240 2
a241 2
        (node "*)",	fn (p, _) =>
         (Error.report (Error.ERROR (Error.RECOVERABLE, p, "Ignoring mismatched comment"));
d265 1
a265 1
	   fn (_, [m,_,_]) => (addchar (m-64); Token.IGNORE 2)
d268 1
a268 1
	   fn (_, [a,b,c,_]) => (addchar ((c - ord "0") * 100 + (b - ord "0") * 10 + (a - ord "0")); Token.IGNORE 2)
d272 3
a274 3
          (RegExp.printable, fn (_, l) => (addstring l; Token.IGNORE 2)),
          (RegExp.any, fn (p, _) =>
           (Error.report (Error.ERROR (Error.RECOVERABLE, p, "Closing string on illegal character"));
@


1.11
log
@Added the formfeed character to the list of whitespace characters.
Removed a silly bug which allowed '3' as a string formatting character.
@
text
@d3 4
d50 1
a51 1
require "lexbasics";
d60 1
a60 1
   structure LexBasics : LEXBASICS) : LEXRULES = 
a62 1
    val LexError = LexBasics.LexError
a132 1
    structure LexBasics = LexBasics
d134 1
d206 2
a207 2
	(intnum,		fn s => Token.INTEGER (convert s)),
	(realnum,		fn s => Token.REAL (convert s)),
d211 4
a214 4
	(eqimptyvar,		fn s => Token.TYVAR((Symbol.find_symbol(convert s)),true,true)),
	(imptyvar,		fn s => Token.TYVAR((Symbol.find_symbol(convert s)),false,true)),
	(eqtyvar,		fn s => Token.TYVAR((Symbol.find_symbol(convert s)),true,false)),
	(tyvar,			fn s => Token.TYVAR((Symbol.find_symbol(convert s)),false,false)),
d218 1
a218 1
	(long_id, fn s => let
d237 3
a239 1
        (node "*)",	fn _ => (LexBasics.report_lex_error "Mismatched Comment"; Token.IGNORE 0)),
d262 2
a263 2
	   fn [m,_,_] => (addchar (m-64); Token.IGNORE 2)
	    | _       => raise LexError "Bad String Format"),
d265 1
a265 1
	   fn [a,b,c,_] => (addchar ((c - ord "0") * 100 + (b - ord "0") * 10 + (a - ord "0")); Token.IGNORE 2)
d269 4
a272 3
          (RegExp.printable, fn l => (addstring l; Token.IGNORE 2)),
          (RegExp.any, fn _ => (LexBasics.report_lex_error"Closing string on illegal character";
				Token.STRING(implode (rev (!thisstring)))))]]
@


1.10
log
@Modified to provide functions which accept lists of chars (ints)
instead of strings. Comments are now parsed much more quickly
since the regular expressions match more input in one go.
@
text
@d3 5
d71 1
a71 1
    fun plus r = r & star r
d81 1
a81 1
    val whitespace = RegExp.plusRE(class " \n\t")
d99 1
a99 1
    val symbolic_id = RegExp.plusRE(symbol)
d113 1
a113 1
    val digits = RegExp.plusRE(digit)
a121 2
    val formattingchr = class " \n\t\0123"
    val formatting = RegExp.plusRE formattingchr
d262 1
a262 1
	  (node "\\" & formatting & node "\\",	fn _ => Token.IGNORE 2),
@


1.9
log
@Fixed lexer to read in negative exponents
@
text
@d3 3
d37 2
d45 7
a51 4
functor MLRules(structure Integer : INTEGER
		structure Token : TOKEN
		structure RegExp : REGEXP
		structure LexBasics : LEXBASICS) : LEXRULES = 
d64 1
d66 1
d78 13
d96 1
a96 1
    val long_id = id & node "."
a116 1
    fun addstring s = thisstring := (s :: (!thisstring))
d120 5
a132 1
    val self = ref (fn (x : int) => Token.RESERVED(Token.EOF))
d140 57
a196 57
       [(node "abstype", fn s => Token.RESERVED (Token.ABSTYPE)),
	(node "and",	fn s => Token.RESERVED (Token.AND)),
	(node "andalso",fn s => Token.RESERVED (Token.ANDALSO)),
	(node "as",	fn s => Token.RESERVED (Token.AS)),
	(node "case",	fn s => Token.RESERVED (Token.CASE)),
	(node "do",	fn s => Token.RESERVED (Token.DO)),
	(node "datatype",fn s => Token.RESERVED (Token.DATATYPE)),
	(node "else",	fn s => Token.RESERVED (Token.ELSE)),
	(node "end",	fn s => Token.RESERVED (Token.END)),
	(node "exception",fn s => Token.RESERVED (Token.EXCEPTION)),
	(node "fn",	fn s => Token.RESERVED (Token.FN)),
	(node "fun",	fn s => Token.RESERVED (Token.FUN)),
	(node "handle",	fn s => Token.RESERVED (Token.HANDLE)),
	(node "if",	fn s => Token.RESERVED (Token.IF)),
	(node "in",	fn s => Token.RESERVED (Token.IN)),
	(node "infix",	fn s => Token.RESERVED (Token.INFIX)),
	(node "infixr",	fn s => Token.RESERVED (Token.INFIXR)),
	(node "let",	fn s => Token.RESERVED (Token.LET)),
	(node "local",	fn s => Token.RESERVED (Token.LOCAL)),
	(node "nonfix",	fn s => Token.RESERVED (Token.NONFIX)),
	(node "of",	fn s => Token.RESERVED (Token.OF)),
	(node "op",	fn s => Token.RESERVED (Token.OP)),
	(node "open",	fn s => Token.RESERVED (Token.OPEN)),
	(node "orelse",	fn s => Token.RESERVED (Token.ORELSE)),
	(node "raise",	fn s => Token.RESERVED (Token.RAISE)),
	(node "rec",	fn s => Token.RESERVED (Token.REC)),
	(node "require",fn s => Token.RESERVED (Token.REQUIRE)),
	(node "then",	fn s => Token.RESERVED (Token.THEN)),
	(node "type",	fn s => Token.RESERVED (Token.TYPE)),
	(node "val",	fn s => Token.RESERVED (Token.VAL)),
	(node "with",	fn s => Token.RESERVED (Token.WITH)),
	(node "withtype",fn s => Token.RESERVED (Token.WITHTYPE)),
	(node "while",	fn s => Token.RESERVED (Token.WHILE)),
	(node "eqtype",	fn s => Token.RESERVED (Token.EQTYPE)),
	(node "functor",fn s => Token.RESERVED (Token.FUNCTOR)),
	(node "include",fn s => Token.RESERVED (Token.INCLUDE)),
	(node "sharing",fn s => Token.RESERVED (Token.SHARING)),
	(node "sig",	fn s => Token.RESERVED (Token.SIG)),
	(node "signature",fn s => Token.RESERVED (Token.SIGNATURE)),
	(node "struct",	fn s => Token.RESERVED (Token.STRUCT)),
	(node "structure",fn s => Token.RESERVED (Token.STRUCTURE)),
	(node "(",	fn s => Token.RESERVED(Token.LPAR)),
	(node ")",	fn s => Token.RESERVED(Token.RPAR)),
	(node "[",	fn s => Token.RESERVED(Token.BRA)),
	(node "]",	fn s => Token.RESERVED(Token.KET)),
	(node "{",	fn s => Token.RESERVED(Token.LBRACE)),
	(node "}",	fn s => Token.RESERVED(Token.RBRACE)),
	(node ",",	fn s => Token.RESERVED(Token.COMMA)),
	(node ":",	fn s => Token.RESERVED(Token.COLON)),
	(node ";",	fn s => Token.RESERVED(Token.SEMICOLON)),
	(node "...",	fn s => Token.RESERVED(Token.ELLIPSIS)),
	(node "_",	fn s => Token.RESERVED(Token.UNDERBAR)),
	(node "|",	fn s => Token.RESERVED(Token.VBAR)),
	(node "=",	fn s => Token.RESERVED(Token.EQUAL)),
	(node "=>",	fn s => Token.RESERVED(Token.DARROW)),
	(node "->",	fn s => Token.RESERVED(Token.ARROW)),
	(node "#",	fn s => Token.RESERVED(Token.HASH)),
d200 2
a201 2
	(intnum,		fn s => Token.INTEGER (s)),
	(realnum,		fn s => Token.REAL (s)),
d205 4
a208 4
	(eqimptyvar,		fn s => Token.TYVAR((Symbol.find_symbol (s)),true,true)),
	(imptyvar,		fn s => Token.TYVAR((Symbol.find_symbol (s)),false,true)),
	(eqtyvar,		fn s => Token.TYVAR((Symbol.find_symbol (s)),true,false)),
	(tyvar,			fn s => Token.TYVAR((Symbol.find_symbol (s)),false,false)),
d212 14
a225 14
	(id,			fn s => Token.LONGID( [], Symbol.find_symbol(s))),
	
	(long_id,		fn s => let val rest = (!self 0)
					    fun trim x = String.substring(x,0,size(x)-1)
					in
					  case rest of
					    Token.LONGID(symlist,id) =>
					      Token.LONGID((Symbol.find_symbol (trim s))::symlist, id)
                                          (* what should this really do in an error situation?
                                           * -- this effectively ignores the dot
                                           *)
					  | _ => (LexBasics.report_lex_error "Illegal dot context";
                                                  Token.LONGID( [],Symbol.find_symbol (trim s)))
					end),
d237 1
a237 1
	 (whitespace,		fn _ => Token.IGNORE 0)
d243 3
a245 4
	 [(node "(*",  fn _ => (comment_depth := !comment_depth+1; Token.IGNORE 1)),
          (node "*)",  fn _ => (comment_depth := !comment_depth-1;
                                Token.IGNORE (if !comment_depth = 0 then 0 else 1))),
	  (RegExp.any, fn s => Token.IGNORE 1)],
d249 4
a252 4
	 [(node "\\n",  fn _ => (addstring "\n"; Token.IGNORE 2)),
	  (node "\\t",  fn _ => (addstring "\t"; Token.IGNORE 2)),
	  (node "\\\"", fn _ => (addstring "\""; Token.IGNORE 2)),
	  (node "\\\\", fn _ => (addstring "\\"; Token.IGNORE 2)),
d254 2
a255 4
	   fn s => ((fn [x,y,m] => (addstring (chr ((ord m)-64)); Token.IGNORE 2)
                      | s       => raise LexError "Bad String Format"
                                   (* This shouldn't happen as the regexp won't match *))
		    (explode s))),
d257 2
a258 2
	   fn s => (addstring (chr (Integer.parseinteger (String.substring(s,1,3))));
		    Token.IGNORE 2)),
d261 3
a263 3
          (RegExp.printable, fn s => (addstring s; Token.IGNORE 2)),
          (RegExp.any,fn _ => (LexBasics.report_lex_error"Closing string on illegal character";
                               Token.STRING(implode (rev (!thisstring)))))]]
@


1.8
log
@String structure is now pervasive.
@
text
@d3 3
a86 1
    val exp = node "E" & digits
d88 1
@


1.7
log
@Removed some structures and sharing
@
text
@d3 3
d30 1
a30 1
require "../utils/string";
a37 1
		structure String : STRING
d186 1
a186 1
					    fun trim x = String.substring(x,0,String.length(x)-1)
@


1.6
log
@Changed string definition so that only escapes and printable characters are allowed.
An illegal string character acts as a terminator, rather than being ignored, so this
should catch unclosed strings.
@
text
@d3 5
a29 1
require "../basics/symbol";
a36 1
		structure Symbol : SYMBOL
d38 1
a38 2
		structure LexBasics : LEXBASICS
		sharing Token.Symbol = Symbol) : LEXRULES = 
d96 1
a96 1
    structure Token = Token
@


1.5
log
@Added IGNORE token to remove recursion from lexing of comments and strings.
@
text
@d3 3
d231 3
a233 1
	  (RegExp.any, fn s => (addstring s; Token.IGNORE 2))]]
@


1.4
log
@Changed errors to print message and continue rather than raise exception
@
text
@d3 3
d97 1
d193 3
a195 4
	(node "(*",	fn _ => (!self 1; !self 0)),
         (* report error and continue *)
	 (node "*)",	fn _ => (LexBasics.report_lex_error "Mismatched Comment";
                                 !self 0)),
d197 1
a197 1
	 (node "\"",	fn _ => (thisstring := []; !self 2)),
d199 1
a199 1
	 (* whitespace *)
d201 2
a202 2
	 (whitespace,		fn _ => !self 0)

d207 4
a210 3
	 [(node "(*",  fn _ => (!self 1; !self 1)),
          (node "*)",  fn _ => Token.RESERVED(Token.EOF)),
	  (RegExp.any, fn _ => !self 1)],
d214 4
a217 4
	 [(node "\\n",  fn _ => (addstring "\n"; !self 2)),
	  (node "\\t",  fn _ => (addstring "\t"; !self 2)),
	  (node "\\\"", fn _ => (addstring "\""; !self 2)),
	  (node "\\\\", fn _ => (addstring "\\"; !self 2)),
d219 3
a221 4
	   fn s => ((fn [x,y,m] => (addstring (chr ((ord m)-64));
                                    !self 2)
                     (* This shouldn't happen as the regexp won't match *)
                      | s       => raise LexError "Bad String Format")
d225 2
a226 2
		    !self 2)),
	  (node "\\" & formatting & node "\\",	fn _ => !self 2),
d228 1
a228 1
	  (RegExp.any, fn s => (addstring s; !self 2))]]
@


1.3
log
@Changed definition because the lexers are now numbered from zero,
instead of one ie. !self 1 becomes !self 0 etc.
@
text
@d2 5
a6 1
$Log:	_lexrules.sml,v $
d180 5
a184 1
					  | _ => raise LexError "Illegal dot context"
d190 3
a192 1
	 (node "*)",	fn _ => raise LexError "Mismatched Comment"),
d215 4
a218 3
	   fn s => ((fn x::y::m::[] => (addstring (chr ((ord m)-64));
					!self 2)
	               | s           => raise LexError "Bad String Format")
@


1.2
log
@Added one or two things to make the syntax more legible (infix regexp
operators, for instance).
@
text
@d3 4
d94 1
a94 1
       (* 1st (and main) lexer : ML text *)
d170 1
a170 1
	(long_id,		fn s => let val rest = (!self 1)
d181 1
a181 2
	(node "(*",	fn _ => (!self 2;
 				         !self 1)),
d184 1
a184 2
	 (node "\"",	fn _ => (thisstring := [];
                               	         !self 3)),
d188 1
a188 1
	 (whitespace,		fn _ => !self 1)
d192 1
a192 1
	 (* 2nd lexer : inside a comment. For correctly nested comments  *)
d194 3
a196 4
	 [(node "(*",fn _ => (!self 2;
	                             !self 2)),
          (node "*)",fn _ => Token.RESERVED(Token.EOF)),
	  (RegExp.any, fn _ => (!self 2))],
d198 1
a198 1
	 (* 3rd lexer : formatting inside strings. Called from first lexer. Ultimately returns STRING x *)
d200 4
a203 8
	 [(node "\\n", fn _ => (addstring "\n";
				       !self 3)),
	  (node "\\t", fn _ => (addstring "\t";
				       !self 3)),
	  (node "\\\"", fn _ => (addstring "\"";
	                                !self 3)),
	  (node "\\\\", fn _ => (addstring "\\";
					!self 3)),
d206 1
a206 1
					!self 3)
d211 2
a212 2
		    !self 3)),
	  (node "\\" & formatting & node "\\",	fn _ => !self 3),
d214 1
a214 2
	  (RegExp.any, fn s => (addstring s;
				!self 3))]]
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d26 12
a37 3
      
    (* general things *)
      
d40 2
a41 3
    val alphanumeric = RegExp.BAR(RegExp.CLASS "_'",RegExp.BAR(digit,letter))
    val symbol = RegExp.CLASS ("!%&$#+-/:<=>?@@\\~`^|*")
    val whitespace = RegExp.plusRE(RegExp.CLASS(" \n\t"))
d43 4
d49 1
a49 1
    val alpha_id = RegExp.DOT(letter,RegExp.STAR(alphanumeric))
d51 2
a52 2
    val id = RegExp.BAR(alpha_id,symbolic_id)
    val long_id = RegExp.DOT(id,RegExp.NODE ".")
d56 5
a60 5
    val alphas = RegExp.STAR(alphanumeric)
    val tyvar = RegExp.DOT(RegExp.NODE "'",alphas)
    val eqtyvar = RegExp.DOT(RegExp.NODE "''", alphas)
    val imptyvar = RegExp.DOT(RegExp.NODE "'_",alphas)
    val eqimptyvar = RegExp.DOT(RegExp.NODE "''_",alphas)
d65 4
a68 4
    val frac = RegExp.DOT(RegExp.NODE ".",digits)
    val exp = RegExp.DOT(RegExp.NODE "E",digits)
    val intnum = RegExp.BAR(digits,RegExp.DOT(RegExp.NODE "~",digits))
    val realnum = RegExp.DOT(intnum,RegExp.BAR(frac,RegExp.BAR(exp,RegExp.DOT(frac,exp))))
d74 1
a74 1
    val formattingchr = RegExp.CLASS " \n\t\0123"
d92 57
a148 57
       [(RegExp.NODE "abstype", fn s => Token.RESERVED (Token.ABSTYPE)),
	(RegExp.NODE "and",	fn s => Token.RESERVED (Token.AND)),
	(RegExp.NODE "andalso",fn s => Token.RESERVED (Token.ANDALSO)),
	(RegExp.NODE "as",	fn s => Token.RESERVED (Token.AS)),
	(RegExp.NODE "case",	fn s => Token.RESERVED (Token.CASE)),
	(RegExp.NODE "do",	fn s => Token.RESERVED (Token.DO)),
	(RegExp.NODE "datatype",fn s => Token.RESERVED (Token.DATATYPE)),
	(RegExp.NODE "else",	fn s => Token.RESERVED (Token.ELSE)),
	(RegExp.NODE "end",	fn s => Token.RESERVED (Token.END)),
	(RegExp.NODE "exception",fn s => Token.RESERVED (Token.EXCEPTION)),
	(RegExp.NODE "fn",	fn s => Token.RESERVED (Token.FN)),
	(RegExp.NODE "fun",	fn s => Token.RESERVED (Token.FUN)),
	(RegExp.NODE "handle",	fn s => Token.RESERVED (Token.HANDLE)),
	(RegExp.NODE "if",	fn s => Token.RESERVED (Token.IF)),
	(RegExp.NODE "in",	fn s => Token.RESERVED (Token.IN)),
	(RegExp.NODE "infix",	fn s => Token.RESERVED (Token.INFIX)),
	(RegExp.NODE "infixr",	fn s => Token.RESERVED (Token.INFIXR)),
	(RegExp.NODE "let",	fn s => Token.RESERVED (Token.LET)),
	(RegExp.NODE "local",	fn s => Token.RESERVED (Token.LOCAL)),
	(RegExp.NODE "nonfix",	fn s => Token.RESERVED (Token.NONFIX)),
	(RegExp.NODE "of",	fn s => Token.RESERVED (Token.OF)),
	(RegExp.NODE "op",	fn s => Token.RESERVED (Token.OP)),
	(RegExp.NODE "open",	fn s => Token.RESERVED (Token.OPEN)),
	(RegExp.NODE "orelse",	fn s => Token.RESERVED (Token.ORELSE)),
	(RegExp.NODE "raise",	fn s => Token.RESERVED (Token.RAISE)),
	(RegExp.NODE "rec",	fn s => Token.RESERVED (Token.REC)),
	(RegExp.NODE "require",fn s => Token.RESERVED (Token.REQUIRE)),
	(RegExp.NODE "then",	fn s => Token.RESERVED (Token.THEN)),
	(RegExp.NODE "type",	fn s => Token.RESERVED (Token.TYPE)),
	(RegExp.NODE "val",	fn s => Token.RESERVED (Token.VAL)),
	(RegExp.NODE "with",	fn s => Token.RESERVED (Token.WITH)),
	(RegExp.NODE "withtype",fn s => Token.RESERVED (Token.WITHTYPE)),
	(RegExp.NODE "while",	fn s => Token.RESERVED (Token.WHILE)),
	(RegExp.NODE "eqtype",	fn s => Token.RESERVED (Token.EQTYPE)),
	(RegExp.NODE "functor",fn s => Token.RESERVED (Token.FUNCTOR)),
	(RegExp.NODE "include",fn s => Token.RESERVED (Token.INCLUDE)),
	(RegExp.NODE "sharing",fn s => Token.RESERVED (Token.SHARING)),
	(RegExp.NODE "sig",	fn s => Token.RESERVED (Token.SIG)),
	(RegExp.NODE "signature",fn s => Token.RESERVED (Token.SIGNATURE)),
	(RegExp.NODE "struct",	fn s => Token.RESERVED (Token.STRUCT)),
	(RegExp.NODE "structure",fn s => Token.RESERVED (Token.STRUCTURE)),
	(RegExp.NODE "(",	fn s => Token.RESERVED(Token.LPAR)),
	(RegExp.NODE ")",	fn s => Token.RESERVED(Token.RPAR)),
	(RegExp.NODE "[",	fn s => Token.RESERVED(Token.BRA)),
	(RegExp.NODE "]",	fn s => Token.RESERVED(Token.KET)),
	(RegExp.NODE "{",	fn s => Token.RESERVED(Token.LBRACE)),
	(RegExp.NODE "}",	fn s => Token.RESERVED(Token.RBRACE)),
	(RegExp.NODE ",",	fn s => Token.RESERVED(Token.COMMA)),
	(RegExp.NODE ":",	fn s => Token.RESERVED(Token.COLON)),
	(RegExp.NODE ";",	fn s => Token.RESERVED(Token.SEMICOLON)),
	(RegExp.NODE "...",	fn s => Token.RESERVED(Token.ELLIPSIS)),
	(RegExp.NODE "_",	fn s => Token.RESERVED(Token.UNDERBAR)),
	(RegExp.NODE "|",	fn s => Token.RESERVED(Token.VBAR)),
	(RegExp.NODE "=",	fn s => Token.RESERVED(Token.EQUAL)),
	(RegExp.NODE "=>",	fn s => Token.RESERVED(Token.DARROW)),
	(RegExp.NODE "->",	fn s => Token.RESERVED(Token.ARROW)),
	(RegExp.NODE "#",	fn s => Token.RESERVED(Token.HASH)),
d177 1
a177 1
	(RegExp.NODE "(*",	fn _ => (!self 2;
d179 1
a179 1
	 (RegExp.NODE "*)",	fn _ => raise LexError "Mismatched Comment"),
d181 1
a181 1
	 (RegExp.NODE "\"",	fn _ => (thisstring := [];
d192 1
a192 1
	 [(RegExp.NODE "(*",fn _ => (!self 2;
d194 1
a194 1
          (RegExp.NODE "*)",fn _ => Token.RESERVED(Token.EOF)),
d199 1
a199 1
	 [(RegExp.NODE "\\n", fn _ => (addstring "\n";
d201 1
a201 1
	  (RegExp.NODE "\\t", fn _ => (addstring "\t";
d203 1
a203 1
	  (RegExp.NODE "\\\"", fn _ => (addstring "\"";
d205 1
a205 1
	  (RegExp.NODE "\\\\", fn _ => (addstring "\\";
d207 1
a207 1
	  (RegExp.DOT (RegExp.NODE "\\^",RegExp.CLASS "@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"),
d212 1
a212 1
	  (RegExp.sequenceRE [RegExp.NODE "\\",digit,digit,digit],
d215 2
a216 2
	  (RegExp.sequenceRE [RegExp.NODE "\\",formatting,RegExp.NODE "\\"],fn _ => !self 3),
	  (RegExp.NODE "\"", fn _ => Token.STRING(implode (rev (!thisstring)))),
@
