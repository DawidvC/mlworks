head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.13
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_20m1_1997_10_23:1.8
	MLWorks_11r1:1.8.10.1.1.1.1
	MLWorks_workspace_97:1.8.12
	MLWorks_dt_wizard:1.8.11
	MLWorks_11c0_1997_09_09:1.8.10.1.1.1
	MLWorks_10r3:1.8.10.1.3
	MLWorks_10r2_551:1.8.10.1.2
	MLWorks_11:1.8.10.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.10.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.8.10.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.10.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.10
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.8.1.1
	MLWorks_gui_1996_12_18:1.8.9
	MLWorks_1_0_Win32_1996_12_17:1.8.8
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.6.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.6.1
	MLWorks_1_0_Irix_1996_11_28:1.8.6.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.7
	MLWorks_1_0_Unix_1996_11_14:1.8.6
	MLWorks_Open_Beta2_1996_10_11:1.8.5
	MLWorks_License_dev:1.8.4
	MLWorks_1_open_beta_1996_09_13:1.8.3
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWlexer_basis_io_1996:1.8.2
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	ML_beta_release_12/08/94:1.8
	ML_beta_release_03/08/94:1.8
	ML_revised_beta_release_25/05/94:1.8
	ML_final_beta_release_02/03/94:1.8
	mlworks-28-01-1994:1.8
	Release:1.8
	mlworks-beta-01-09-1993:1.8
	MLWorks-1-0-4-29/01/1993:1.7
	MLWorks-1-0-3-21/12/1992:1.7
	MLWorks-1-0-2-15/12/1992:1.7
	MLWorks-1-0-1-04/12/1992:1.7
	checkpoint_17_08_92:1.4;
locks; strict;
comment	@ * @;


1.8
date	93.03.02.14.12.00;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1
	1.8.7.1
	1.8.8.1
	1.8.9.1
	1.8.10.1
	1.8.11.1
	1.8.12.1
	1.8.13.1;
next	1.7;

1.7
date	92.10.29.16.16.31;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.10.02.16.36.45;	author clive;	state Exp;
branches;
next	1.5;

1.5
date	92.08.18.11.44.55;	author davidt;	state Exp;
branches;
next	1.4;

1.4
date	92.08.14.19.19.44;	author davidt;	state Exp;
branches;
next	1.3;

1.3
date	92.05.07.11.38.28;	author richard;	state Exp;
branches;
next	1.2;

1.2
date	92.05.06.14.17.55;	author richard;	state Exp;
branches;
next	1.1;

1.1
date	91.10.10.15.13.56;	author davidt;	state Exp;
branches;
next	;

1.8.1.1
date	93.03.02.14.12.00;	author jont;	state Exp;
branches;
next	;

1.8.2.1
date	96.08.19.11.49.28;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.09.13.11.17.52;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.10.07.16.07.41;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	96.10.17.11.25.56;	author hope;	state Exp;
branches;
next	;

1.8.6.1
date	96.11.14.12.51.06;	author hope;	state Exp;
branches
	1.8.6.1.1.1;
next	;

1.8.6.1.1.1
date	96.11.28.15.02.11;	author hope;	state Exp;
branches;
next	;

1.8.7.1
date	96.11.22.18.10.24;	author hope;	state Exp;
branches;
next	;

1.8.8.1
date	96.12.17.17.48.59;	author hope;	state Exp;
branches
	1.8.8.1.1.1;
next	;

1.8.8.1.1.1
date	97.02.24.11.39.03;	author hope;	state Exp;
branches;
next	;

1.8.9.1
date	96.12.18.09.43.02;	author hope;	state Exp;
branches;
next	;

1.8.10.1
date	97.05.12.10.35.30;	author hope;	state Exp;
branches
	1.8.10.1.1.1
	1.8.10.1.2.1
	1.8.10.1.3.1;
next	;

1.8.10.1.1.1
date	97.07.28.18.20.52;	author daveb;	state Exp;
branches
	1.8.10.1.1.1.1.1;
next	;

1.8.10.1.1.1.1.1
date	97.10.07.11.46.14;	author jkbrook;	state Exp;
branches;
next	;

1.8.10.1.2.1
date	97.09.08.17.14.19;	author daveb;	state Exp;
branches;
next	;

1.8.10.1.3.1
date	97.09.09.14.10.05;	author daveb;	state Exp;
branches;
next	;

1.8.11.1
date	97.09.10.19.26.00;	author brucem;	state Exp;
branches;
next	;

1.8.12.1
date	97.09.11.20.56.09;	author daveb;	state Exp;
branches;
next	;

1.8.13.1
date	99.04.01.17.57.32;	author daveb;	state Exp;
branches;
next	;


desc
@> A more abstract implementation of ndfa's which has been removed from
_lexgen. It now uses balanced trees instead of lists to store the
transitions.
@


1.8
log
@Some speed improvements
@
text
@(*
$Log: _ndfa.sml,v $
Revision 1.7  1992/10/29  16:16:31  jont
Redone using integer newmaps for efficiency

Revision 1.6  1992/10/02  16:36:45  clive
Change to NewMap.empty which now takes < and = functions instead of the single-function

Revision 1.5  1992/08/18  11:44:55  davidt
Now uses integers instead of strings to represent characters.

Revision 1.4  1992/08/14  19:19:44  davidt
Took out useless handler for NewMap.Undefined.

Revision 1.3  1992/05/07  11:38:28  richard
Changed NDFA to use integers instead of strings as transition labels.
Speed doubled.

Revision 1.2  1992/05/06  14:17:55  richard
Changed BalancedTree to generic Map

Revision 1.1  1991/10/10  15:13:56  davidt
Initial revision


Copyright (c) 1991 Harlequin Ltd.
*)

require "../utils/crash";
require "../utils/intnewmap";
require "ndfa";

functor Ndfa
  (structure Crash : CRASH
   structure Map : INTNEWMAP
     ) : NDFA =
struct
  type state = int
  type transitions = (int * state) list
  type action = int

  val no_action = 0
  val epsilon_char = ~1

  fun epsilon [] = []
    | epsilon (dest :: rest) = (epsilon_char, dest) :: epsilon rest

  fun single_char (c,dest) = [(c, dest)]

  (*
   get_char(c,trans,accum) accumulates the states reachable by transitions
   on the string c onto the list accum (may contain duplicates).
  *)
  
  fun get_char(_, [], states) = states
    | get_char(c:int, (char, state)::rest, states) =
      get_char(c, rest, if c = char then state::states else states)

  fun get_epsilon (transitions, states) =
    let
      fun find ([], states) = states
        | find ((char, state)::rest, states) =
          find (rest, if char = epsilon_char then state::states else states)
    in
      find (transitions, states)
    end

  fun mk_trans l = l

  datatype ndfa = NDFA of
    {trans : ((transitions * action)) Map.T,
     start : int, fresh : int}

  fun ordering (x : int, y : int) =  (x < y)

  val empty =
    NDFA {trans = Map.empty (*(ordering,op =)*), start = 0, fresh = 0}

  fun add_with_action (NDFA {trans, start, fresh}, transitions, action) =
    let
      val new_trans =
	Map.define (trans, fresh, (transitions, action))
    in
      NDFA {trans = new_trans, start = fresh, fresh = fresh + 1}
    end

  fun add (ndfa, transitions) =
    add_with_action (ndfa, transitions, no_action)

  fun add_final (ndfa, action) =
    add_with_action (ndfa, [], action)

  fun add_start (ndfa, state_list) =
    add (ndfa, epsilon state_list)

  fun add_rec (NDFA {trans, start, fresh}, state_fn) =
    let
      val t1 =
	epsilon [start, fresh + 1]
      val trans1 =
	Map.define (trans, fresh, (t1, no_action))
      val NDFA {trans = trans2, start = start2, fresh = fresh2} =
	state_fn (NDFA {trans = trans1, start = fresh, fresh = fresh + 2})
      val t2 =
	epsilon [start, start2]
      val trans2 =
	Map.define (trans2, fresh + 1, (t2, no_action))
    in
      NDFA {trans = trans2, start = fresh + 1, fresh = fresh2}
    end
  
  fun transitions (NDFA {trans, ...}, state) =
    #1 (Map.apply'(trans, state))

  fun start (NDFA {start, ...}) = start

  fun set_start (NDFA {trans, fresh, ...}, start) =
    NDFA {trans = trans, start = start, fresh = fresh}

  fun action (NDFA {trans, ...}, state) =
    #2 (Map.apply'(trans, state))

  fun num_states (NDFA {fresh, ...}) = fresh
end
@


1.8.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.12.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.11.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.10.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.10.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.8.10.1  1997/05/12  10:35:30  hope
 * branched from 1.8
 *
@


1.8.10.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.8.10.1  1997/05/12  10:35:30  hope
 * branched from 1.8
 *
@


1.8.10.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.8.10.1  1997/05/12  10:35:30  hope
 * branched from 1.8
 *
@


1.8.10.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.8.10.1.1.1  1997/07/28  18:20:52  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.8.9.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.8.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.8.1.1.1
log
@branched from 1.8.8.1
@
text
@a2 3
 * Revision 1.8.8.1  1996/12/17  17:48:59  hope
 * branched from 1.8
 *
@


1.8.7.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.6.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.6.1.1.1
log
@branched from 1.8.6.1
@
text
@a2 3
 * Revision 1.8.6.1  1996/11/14  12:51:06  hope
 * branched from 1.8
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a2 3
 * Revision 1.8  1993/03/02  14:12:00  jont
 * Some speed improvements
 *
@


1.8.1.1
log
@Fork for bug fixing
@
text
@a2 3
Revision 1.8  1993/03/02  14:12:00  jont
Some speed improvements

@


1.7
log
@Redone using integer newmaps for efficiency
@
text
@d3 3
d55 3
a57 8
  fun get_char (c, transitions, states) =
    let
      fun find ([], states) = states
        | find ((char, state)::rest, states) =
          find (rest, if c = char then state::states else states)
    in
      find (transitions, states)
    end
@


1.6
log
@Change to NewMap.empty which now takes < and = functions instead of the single-function
@
text
@d3 3
d27 1
a27 1
require "../utils/newmap";
d32 2
a33 1
   structure Map : NEWMAP) : NDFA =
d73 1
a73 1
    {trans : (int, (transitions * action)) Map.T,
d79 1
a79 1
    NDFA {trans = Map.empty (ordering,op =), start = 0, fresh = 0}
@


1.5
log
@Now uses integers instead of strings to represent characters.
@
text
@d3 3
d72 1
a72 4
  fun ordering (x : int, y : int) =  
    if x < y then Map.LESS
    else if x > y then Map.GREATER
	 else Map.EQUAL
d75 1
a75 1
    NDFA {trans = Map.empty ordering, start = 0, fresh = 0}
@


1.4
log
@Took out useless handler for NewMap.Undefined.
@
text
@d3 3
d38 1
a38 1
  fun single_char (char,dest) = [(ord char, dest)]
d45 1
a45 1
  fun get_char (string, transitions, states) =
a46 2
      val c = ord string

d63 1
a63 1
  fun mk_trans list = map (fn (string, state) => (ord string, state)) list
@


1.3
log
@Changed NDFA to use integers instead of strings as transition labels.
Speed doubled.
@
text
@d3 4
d23 1
a23 2
   structure Map : NEWMAP
     ) : NDFA =
d110 1
a110 2
    #1 (Map.apply trans state)
    handle Map.Undefined => Crash.impossible "Ndfa.transitions"
d118 1
a118 2
    #2 (Map.apply trans state)
    handle Map.Undefined => Crash.impossible "Ndfa.action"
a121 1

@


1.2
log
@Changed BalancedTree to generic Map
@
text
@d3 3
d23 1
a23 1
  type transitions = (string * state) list
d27 1
d30 1
a30 1
    | epsilon (dest :: rest) = ("",dest) :: epsilon rest
d32 1
a32 1
  fun single_char (char,dest) = [(char,dest)]
a36 3

   This function is critical.  The string type is qualified so that the
   equality test is not polymorphic.
d39 19
a57 3
  fun get_char (char, [], accum) = accum
    | get_char (char, (s,n) :: t, accum) =
      get_char (char, t, if s = char then n::accum else accum)
d59 1
a59 1
  fun mk_trans L = L
@


1.1
log
@Initial revision
@
text
@d2 3
a4 1
$Log$
d6 1
d11 1
a11 1
require "../utils/balancedtree";
d16 1
a16 1
   structure BalancedTree : BALANCEDTREE
d33 3
d40 1
a40 2
      if (s = char) then get_char (char, t, n :: accum)
      else get_char (char, t, accum)
d45 1
a45 1
    {trans : (int, (transitions * action)) BalancedTree.btree,
d49 3
a51 3
    if x < y then BalancedTree.LT
    else if x > y then BalancedTree.GT
	 else BalancedTree.EQ
d54 1
a54 1
    NDFA {trans = BalancedTree.empty ordering, start = 0, fresh = 0}
d59 1
a59 1
	BalancedTree.insert(trans, fresh, (transitions, action))
d78 1
a78 1
	BalancedTree.insert (trans, fresh, (t1, no_action))
d84 1
a84 1
	BalancedTree.insert (trans2, fresh + 1, (t2, no_action))
d90 2
a91 3
    case BalancedTree.lookup(trans, state) of
      BalancedTree.YES((tr,_)) => tr
    | BalancedTree.NO => Crash.impossible "Ndfa.transitions"
d99 2
a100 3
    case BalancedTree.lookup(trans, state) of
      BalancedTree.YES((_,action)) => action
    | BalancedTree.NO => Crash.impossible "Ndfa.action"
@
