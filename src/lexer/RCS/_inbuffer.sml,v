head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.1
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.23
	MLWorks_20b2_Windows_1998_06_12:1.23
	MLWorks_20b1c1_1998_05_07:1.23
	MLWorks_20b0_1998_04_07:1.23
	MLWorks_20b0_1998_03_20:1.23
	MLWorks_20m2_1998_02_16:1.22
	MLWorks_20m1_1997_10_23:1.22
	MLWorks_11r1:1.22.5.1.1.1.1
	MLWorks_workspace_97:1.22.7
	MLWorks_dt_wizard:1.22.6
	MLWorks_11c0_1997_09_09:1.22.5.1.1.1
	MLWorks_10r3:1.22.5.1.3
	MLWorks_10r2_551:1.22.5.1.2
	MLWorks_11:1.22.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.22.5.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.22.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.22.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.22.5
	MLWorks_BugFix_1997_04_24:1.22
	MLWorks_1_0_r2_Win32_1997_04_11:1.22
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.22.3.1.1
	MLWorks_gui_1996_12_18:1.22.4
	MLWorks_1_0_Win32_1996_12_17:1.22.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.22.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.22.1.1
	MLWorks_1_0_Irix_1996_11_28:1.22.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.22.2
	MLWorks_1_0_Unix_1996_11_14:1.22.1
	MLWorks_Open_Beta2_1996_10_11:1.21.4
	MLWorks_License_dev:1.21.3
	MLWorks_1_open_beta_1996_09_13:1.21.2
	MLWorks_Open_Beta_1996_08_22:1.21
	MLWlexer_basis_io_1996:1.21.1
	MLWorks_Beta_1996_07_02:1.21
	MLWorks_Beta_1996_06_07:1.21
	MLWorks_Beta_1996_06_06:1.21
	MLWorks_Beta_1996_06_05:1.21
	MLWorks_Beta_1996_06_03:1.21
	MLWorks_Beta_1996_05_31:1.21
	MLWorks_Beta_1996_05_30:1.21
	ML_beta_release_12/08/94:1.19
	ML_beta_release_03/08/94:1.19
	ML_revised_beta_release_25/05/94:1.19
	ML_final_beta_release_02/03/94:1.17
	mlworks-28-01-1994:1.17
	Release:1.15
	mlworks-beta-01-09-1993:1.15
	MLWorks-1-0-4-29/01/1993:1.14
	MLWorks-1-0-3-21/12/1992:1.14
	MLWorks-1-0-2-15/12/1992:1.13
	MLWorks-1-0-1-04/12/1992:1.13
	checkpoint_17_08_92:1.8;
locks; strict;
comment	@ * @;


1.23
date	98.02.19.16.27.40;	author mitchell;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	96.10.30.15.48.55;	author io;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1
	1.22.4.1
	1.22.5.1
	1.22.6.1
	1.22.7.1;
next	1.21;

1.21
date	96.04.30.14.50.42;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1
	1.21.4.1;
next	1.20;

1.20
date	95.06.08.14.44.53;	author daveb;	state Exp;
branches;
next	1.19;

1.19
date	94.03.08.16.36.58;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	94.03.08.14.52.22;	author daveb;	state Exp;
branches;
next	1.17;

1.17
date	93.11.29.12.56.12;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	93.09.02.14.22.39;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	93.04.01.09.38.52;	author daveb;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	92.12.21.11.04.40;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	92.11.19.14.52.53;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	92.11.09.18.36.17;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	92.10.14.11.21.44;	author richard;	state Exp;
branches;
next	1.10;

1.10
date	92.09.02.15.32.07;	author richard;	state Exp;
branches;
next	1.9;

1.9
date	92.08.18.15.06.28;	author davidt;	state Exp;
branches;
next	1.8;

1.8
date	92.08.15.14.01.16;	author davidt;	state Exp;
branches;
next	1.7;

1.7
date	92.08.14.17.40.10;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	92.08.07.15.44.50;	author davidt;	state Exp;
branches;
next	1.5;

1.5
date	92.05.19.17.10.59;	author clive;	state Exp;
branches;
next	1.4;

1.4
date	92.04.02.11.15.21;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	92.03.23.15.27.30;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	92.01.27.14.43.40;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	91.09.06.16.48.22;	author nickh;	state Exp;
branches;
next	;

1.15.1.1
date	93.04.01.09.38.52;	author jont;	state Exp;
branches;
next	1.15.1.2;

1.15.1.2
date	93.09.02.13.24.45;	author jont;	state Exp;
branches;
next	;

1.21.1.1
date	96.08.19.11.49.22;	author hope;	state Exp;
branches;
next	;

1.21.2.1
date	96.09.13.11.17.46;	author hope;	state Exp;
branches;
next	;

1.21.3.1
date	96.10.07.16.07.35;	author hope;	state Exp;
branches;
next	;

1.21.4.1
date	96.10.17.11.25.49;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	96.11.14.12.50.57;	author hope;	state Exp;
branches
	1.22.1.1.1.1;
next	;

1.22.1.1.1.1
date	96.11.28.15.02.05;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.11.22.18.10.16;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.12.17.17.48.54;	author hope;	state Exp;
branches
	1.22.3.1.1.1;
next	;

1.22.3.1.1.1
date	97.02.24.11.38.58;	author hope;	state Exp;
branches;
next	;

1.22.4.1
date	96.12.18.09.42.55;	author hope;	state Exp;
branches;
next	;

1.22.5.1
date	97.05.12.10.35.24;	author hope;	state Exp;
branches
	1.22.5.1.1.1
	1.22.5.1.2.1
	1.22.5.1.3.1;
next	;

1.22.5.1.1.1
date	97.07.28.18.20.46;	author daveb;	state Exp;
branches
	1.22.5.1.1.1.1.1;
next	;

1.22.5.1.1.1.1.1
date	97.10.07.11.46.05;	author jkbrook;	state Exp;
branches;
next	;

1.22.5.1.2.1
date	97.09.08.17.14.14;	author daveb;	state Exp;
branches;
next	;

1.22.5.1.3.1
date	97.09.09.14.10.00;	author daveb;	state Exp;
branches;
next	;

1.22.6.1
date	97.09.10.19.25.55;	author brucem;	state Exp;
branches;
next	;

1.22.7.1
date	97.09.11.20.56.04;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	99.04.01.17.57.28;	author daveb;	state Exp;
branches;
next	;


desc
@Input buffering.
@


1.23
log
@[Bug #30349]
Fix to avoid non-unit sequence warnings
@
text
@(*
$Log: _inbuffer.sml,v $
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
 * Revision 1.21  1996/04/30  14:50:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
 * Revision 1.20  1995/06/08  14:44:53  daveb
 * Removed expansion of tabs.
 *
Revision 1.19  1994/03/08  16:36:58  daveb
Fixed previous log message.

Revision 1.18  1994/03/08  14:52:22  daveb
Minor improvements to locations.  First index of locations now
defined by values in Info.Location.

Revision 1.17  1993/11/29  12:56:12  matthew
Increment column number to next tab stop for a tab character.

Revision 1.16  1993/09/02  14:22:39  jont
Merging in bug fixes

Revision 1.15.1.2  1993/09/02  13:24:45  jont
Improvements to getsomemore to avoid string duplication

Revision 1.15.1.1  1993/04/01  09:38:52  jont
Fork for bug fixing

Revision 1.15  1993/04/01  09:38:52  daveb
Added a boolean eof parameter to mkLineInBuffer, for use with the
incremental parser.

Revision 1.14  1992/12/21  11:04:40  matthew
Change to allow token streams to be created with a given initial line number.

Revision 1.13  1992/11/19  14:52:53  matthew
Added flush_to_nl

Revision 1.12  1992/11/09  18:36:17  daveb
Added clear_eof function.

Revision 1.11  1992/10/14  11:21:44  richard
Added line number to token stream input functions.

Revision 1.10  1992/09/02  15:32:07  richard
Files now start with line 1.  (Oh well.)
Installed central error reporting mechanism.

Revision 1.9  1992/08/18  15:06:28  davidt
Major change which discards already used characters from the
input buffer only when more input is read in, and the buffer
would have to be copied anyway. Removed the forget and flush
functions which are now redundant.

Revision 1.8  1992/08/15  14:01:16  davidt
getChar now returns an integer, using MLWorks.String.ordof

Revision 1.7  1992/08/14  17:40:10  jont
Removed all currying from inbuffer

Revision 1.6  1992/08/07  15:44:50  davidt
String structure is now pervasive.

Revision 1.5  1992/05/19  17:10:59  clive
Fixed line position output from lexer

Revision 1.4  1992/04/02  11:15:21  matthew
Changed position so doesn't raise Eof when positioning to end of file

Revision 1.3  1992/03/23  15:27:30  matthew
Added line numbering

Revision 1.2  1992/01/27  14:43:40  jont
Added type constraints onto bp variables for the benefit of our compiler

Revision 1.1  1991/09/06  16:48:22  nickh
Initial revision

Copyright (c) 1991 Harlequin Ltd.
*)

require "inbuffer";
require "../basics/location";

functor InBuffer (
  structure Location: LOCATION
) : INBUFFER =
  struct
    datatype InBuffer =
      INBUFFER of
        {buffer : string ref,		(* characters read from input *)
         lastpos : int ref,
         position : int ref,		(* position in buffer *)
         bs : int ref,			(* buffer start position *)
         ln : int ref,			(* line number *)
	 col : int ref,			(* column number *)
	 lastcol : int ref,		(* column of last newline lexed *)
	 eof : bool ref,		(* at end of file? *)
	 more : (int -> string)}	(* generating function *)


    (* eof is set if the generating function has generated an empty string
       (which appends a \n to the buffer).  Any read past the end of a stream
       raises Eof.  lastcol is used for the location of an erroneous newline
       in a string.  *)

    type StateEncapsulation = int * int
      
    exception Eof
    (* raised by any function that tries to read past the end of the stream *)

    exception Position
    (* raised by position if it tries to position before the start of the buffer *)

    exception Forget
    (* raised by forget if it tries to forget past the current position *)
    
    fun mkInBuffer (f) = INBUFFER
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0,
       ln = ref Location.first_line, col = ref Location.first_col,
       lastcol = ref Location.first_col, eof = ref false, more = f}

    fun mkLineInBuffer (f,line, eof) = INBUFFER
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0,
       ln = ref line, col = ref Location.first_col,
       lastcol = ref Location.first_col, eof = ref eof, more = f}

      (* getsomemore raises Eof if eof was already set. Otherwise it
       appends the next input to the buffer, returning false if there is no
       more input *)

    fun getsomemore (INBUFFER {buffer, lastpos, position, bs, eof, more, ln, ...}) =
      if (!eof) then
	raise Eof
      else
	let
	  val s = more (!ln)
	  val left = size(!buffer) - !lastpos
	  val some_more = size s <> 0
	  val next = if some_more then s else (eof := true; "")
	  val new =
	    if left = 0 then
	      next
	    else
	      substring (* could raise Substring *)(!buffer, !lastpos, left) ^ next
	in
	  bs := !bs + !lastpos; 
	  position := !position - !lastpos;
	  lastpos := 0;
	  buffer := new;
	  some_more
	end

    fun getpos (INBUFFER {position, bs, col, ...}) = (!position + !bs, !col)
    fun eof (INBUFFER {eof, ...}) = !eof
    fun clear_eof (ib as INBUFFER {eof, ...}) =
      (eof := false;
       ignore(getsomemore ib);
       ()
      )
       

    (* position raises Position if it attempts to read too far back, and
     Eof if too far forward. Otherwise it returns unit.*)

    fun setPosition (x as INBUFFER {buffer, lastpos, position, bs, ln, col, ...}, (n,charpos)) =
      let
        fun count_newlines (buffer,from,to) =
          let fun cnaux (b,f,t,res) =
            (* assume f <= t here *)
            if f = t then res
            else
              if MLWorks.String.ordof(b,f) = ord #"\n" then cnaux (b,f+1,t,res+1)
              else cnaux (b,f+1,t,res)
          in
            if from > to
              then ~(cnaux (buffer,to,from,0))
            else cnaux (buffer,from,to,0)
          end
        val bp = n - !bs
      in
	if bp < 0 then
	  raise Position
	else
	  if bp > size (!buffer) then
	    (ignore(getsomemore x); setPosition (x, (n,charpos)))
	  else
	    let
	      val deltalines = count_newlines (!buffer, !position, bp)
	    in
	      ln := !ln + deltalines;
	      col := charpos;
	      position := bp;
	      lastpos := bp
          end
      end

    val position = setPosition

    (* getchar: a straight-forward definition *)

    val tabsize = 8

    fun getchar (x as INBUFFER {buffer, position, ln, col, lastcol, ...}) =
      let
	val pos = !position
      in
	if pos >= size (!buffer) then
	  if getsomemore x then
	    getchar x
	  else
	    ord #"\n"	(* Dummy value.  Location info unchanged. *)
	else
	  (position := pos+1;
	   let
	     val char = MLWorks.String.ordof(!buffer,pos)
           in
             if char = ord #"\n" then
	       (ln := !ln + 1; lastcol := !col; col := Location.first_col)
             else
	       col := !col + 1;
	     char
           end)
      end

    fun getlinenum (INBUFFER {ln, ...}) = !ln
    fun getlinepos (INBUFFER {col, ...}) = !col
    fun getlastlinepos (INBUFFER {lastcol, ...}) = !lastcol

    fun flush_to_nl (b as (INBUFFER {buffer, position, eof,...})) =
      if (!eof)
        then ()
      else
        let val pos = !position
        in
          if pos > 0 andalso pos-1 < size(!buffer) andalso MLWorks.String.ordof(!buffer,pos-1) = ord #"\n"
            then ()
          else
            while (getchar b) <> ord #"\n"
              do ()
        end
  end
@


1.23.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a2 4
 * Revision 1.23  1998/02/19  16:27:40  mitchell
 * [Bug #30349]
 * Fix to avoid non-unit sequence warnings
 *
@


1.22
log
@moving String from toplevel
@
text
@d3 3
d163 1
a163 1
       getsomemore ib;
d191 1
a191 1
	    (getsomemore x; setPosition (x, (n,charpos)))
@


1.22.7.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.6.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.5.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a2 3
 * Revision 1.22.5.1  1997/05/12  10:35:24  hope
 * branched from 1.22
 *
@


1.22.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a2 3
 * Revision 1.22.5.1  1997/05/12  10:35:24  hope
 * branched from 1.22
 *
@


1.22.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a2 3
 * Revision 1.22.5.1  1997/05/12  10:35:24  hope
 * branched from 1.22
 *
@


1.22.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a2 3
 * Revision 1.22.5.1.1.1  1997/07/28  18:20:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.22.4.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.3.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.3.1.1.1
log
@branched from 1.22.3.1
@
text
@a2 3
 * Revision 1.22.3.1  1996/12/17  17:48:54  hope
 * branched from 1.22
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a2 3
 * Revision 1.22  1996/10/30  15:48:55  io
 * moving String from toplevel
 *
@


1.22.1.1.1.1
log
@branched from 1.22.1.1
@
text
@a2 3
 * Revision 1.22.1.1  1996/11/14  12:50:57  hope
 * branched from 1.22
 *
@


1.21
log
@String functions explode, implode, chr and ord now only available from String
io functions and types
instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
now only available from MLWorks.IO
@
text
@d3 6
d58 1
a58 1
getChar now returns an integer, using String.ordof
d147 1
a147 1
	      String.substring(!buffer, !lastpos, left) ^ next
d175 1
a175 1
              if String.ordof(b,f) = String.ord "\n" then cnaux (b,f+1,t,res+1)
d214 1
a214 1
	    String.ord "\n"	(* Dummy value.  Location info unchanged. *)
d218 1
a218 1
	     val char = String.ordof(!buffer,pos)
d220 1
a220 1
             if char = String.ord "\n" then
d238 1
a238 1
          if pos > 0 andalso pos-1 < size(!buffer) andalso String.ordof(!buffer,pos-1) = String.ord "\n"
d241 1
a241 1
            while (getchar b) <> String.ord "\n"
@


1.21.4.1
log
@branched from 1.21
@
text
@a2 6
 * Revision 1.21  1996/04/30  14:50:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.3.1
log
@branched from 1.21
@
text
@a2 6
 * Revision 1.21  1996/04/30  14:50:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.2.1
log
@branched from 1.21
@
text
@a2 6
 * Revision 1.21  1996/04/30  14:50:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.21.1.1
log
@branched from 1.21
@
text
@a2 6
 * Revision 1.21  1996/04/30  14:50:42  jont
 * String functions explode, implode, chr and ord now only available from String
 * io functions and types
 * instream, oustream, open_in, open_out, close_in, close_out, input, output and end_of_stream
 * now only available from MLWorks.IO
 *
@


1.20
log
@Removed expansion of tabs.
@
text
@d3 3
d169 1
a169 1
              if String.ordof(b,f) = ord "\n" then cnaux (b,f+1,t,res+1)
d208 1
a208 1
	    ord "\n"	(* Dummy value.  Location info unchanged. *)
d214 1
a214 1
             if char = ord "\n" then
d232 1
a232 1
          if pos > 0 andalso pos-1 < size(!buffer) andalso String.ordof(!buffer,pos-1) = ord "\n"
d235 1
a235 1
            while (getchar b) <> ord "\n"
@


1.19
log
@Fixed previous log message.
@
text
@d3 3
a212 2
             else if char = ord "\t" then
               col := tabsize * (((!col) div tabsize) + 1) + Location.first_col
@


1.18
log
@defined by values in Info.Location.
@
text
@d3 4
@


1.17
log
@Increment column number to next tab stop for a tab character.
@
text
@d3 3
d54 1
a54 2
Changed position so doesn't raise Eof when positioningto end of file
to end of file
d69 1
d71 3
a73 1
functor InBuffer () : INBUFFER =
d77 15
a91 2
      {buffer : string ref, lastpos : int ref, position : int ref, bs : int ref,
       ln : int ref, col : int ref, eof : bool ref, more : (int -> string)}
a93 5

      (* buffer, position in buffer, buffer start position, line number, number within line, eof,
       generating function. eof is set if the generating function has
       generated an empty string (which appends a \n to the buffer). Any
       read past the end of a stream raises Eof *)
d105 3
a107 1
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0, ln = ref 1, col = ref 0, eof = ref false, more = f}
d110 3
a112 1
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0, ln = ref line, col = ref 0, eof = ref eof, more = f}
d126 1
a126 1
	  val next = if some_more then s else (eof := true; "\n")
d190 1
a190 1
    fun getchar (x as INBUFFER {buffer, position, ln, col, ...}) =
d195 4
a198 1
	  (getsomemore x; getchar x)
d205 1
a205 1
	       (ln := !ln + 1; col := 0)
d207 1
a207 1
               col := tabsize * (((!col) div tabsize) + 1)
d216 1
@


1.16
log
@Merging in bug fixes
@
text
@d3 3
d171 2
d186 3
a188 1
	     else
@


1.15
log
@Added a boolean eof parameter to mkLineInBuffer, for use with the
incremental parser.
@
text
@d3 10
d104 8
a111 1
	  val remainder = String.substring(!buffer, !lastpos, size (!buffer) - !lastpos)
d116 2
a117 4
	  if (size s = 0) then
	    (eof := true; buffer := remainder ^ "\n"; false)
	  else
	    (buffer := remainder ^ s; true)
@


1.15.1.1
log
@Fork for bug fixing
@
text
@a2 4
Revision 1.15  1993/04/01  09:38:52  daveb
Added a boolean eof parameter to mkLineInBuffer, for use with the
incremental parser.

@


1.15.1.2
log
@Improvements to getsomemore to avoid string duplication
@
text
@a2 3
Revision 1.15.1.1  1993/04/01  09:38:52  jont
Fork for bug fixing

d98 1
a98 8
	  val left = size(!buffer) - !lastpos
	  val some_more = size s <> 0
	  val next = if some_more then s else (eof := true; "\n")
	  val new =
	    if left = 0 then
	      next
	    else
	      String.substring(!buffer, !lastpos, left) ^ next
d103 4
a106 2
	  buffer := new;
	  some_more
@


1.14
log
@Change to allow token streams to be created with a given initial line number.
@
text
@d3 3
d81 2
a82 2
    fun mkLineInBuffer (f,line) = INBUFFER
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0, ln = ref line, col = ref 0, eof = ref false, more = f}
@


1.13
log
@Added flush_to_nl
@
text
@d3 3
d77 3
@


1.12
log
@Added clear_eof function.
@
text
@d3 3
d165 13
@


1.11
log
@Added line number to token stream input functions.
@
text
@d3 3
d95 6
@


1.10
log
@Files now start with line 1.  (Oh well.)
Installed central error reporting mechanism.
@
text
@d3 4
d48 1
a48 1
       ln : int ref, col : int ref, eof : bool ref, more : (unit -> string)}
d73 1
a73 1
    fun getsomemore (INBUFFER {buffer, lastpos, position, bs, eof, more, ...}) =
d78 1
a78 1
	  val s = more()
@


1.9
log
@Major change which discards already used characters from the
input buffer only when more input is read in, and the buffer
would have to be copied anyway. Removed the forget and flush
functions which are now redundant.
@
text
@d3 6
d63 1
a63 1
      {buffer = ref "", lastpos = ref 0, position = ref 0, bs = ref 0, ln = ref 0, col = ref 0, eof = ref false, more = f}
@


1.8
log
@getChar now returns an integer, using String.ordof
@
text
@d3 3
d35 4
a38 3

    type InBuffer = (string ref * int ref * int ref * int ref * int ref * bool ref
		      * (unit -> string)) ref
d56 2
a57 1
    fun mkInBuffer (f) = ref (ref "",ref 0,ref 0, ref 0, ref 0, ref false,f)
d63 2
a64 2
    fun getsomemore (ref (b,_,_,_,_,e, f)) = 
      if (!e) then
d68 2
a69 1
	  val s = f ()
d71 3
d75 1
a75 3
	    (e := true;
	     b := !b ^ "\n";
	     false)
d77 1
a77 2
	    (b := !b ^ s;
	     true)
d80 2
a81 3
    fun getpos (ref (_,ref p,ref bs,_,ref lp,_,_)) = (p+bs : int,lp)
    fun getbuffstart (ref (_,_,ref bs,_,_,_,_)) = bs
    fun eof (ref (_,_,_,_,_,ref e,_)) = e
d86 1
a86 1
    fun position (x as ref (b,p,bs,ln,lp,e,f), (n,charpos)) =
d100 1
a100 1
        val bp:int = n-(!bs)
d105 10
a114 9
	  if bp > size (!b) then
	    (getsomemore x;
	     position (x, (n,charpos)))
	else
          let val deltalines = count_newlines (!b,!p,bp)
          in
            ln := !ln + deltalines;
            lp := charpos;
	    p := bp
d118 1
a118 31
    (* forget raises Forget if you try to forget past the current point. *)

    fun forget (x as ref (b,p,bs,_,lp,e,f), (n,charpos)) =
      let
	val bp:int = n - !bs
      in
	if bp > (!p) then
	  raise Forget
	else
	  if bp <= 0 then
	    ()
	  else
	    (b := String.substring(!b, bp, size (!b) - bp);
	     bs := n;
             lp := charpos;
	     p := !p - bp)
      end

      (* getstring only returns Eof if it must *)

    fun getstring (x as ref (b,p,bs,_,ref linepos,e,f), l) =
       if (!e) andalso (!p) >= size (!b) then
	 raise Eof
       else
	 let
	   val oldp = !p
	 in
	   ((position (x, ((!p)+(!bs)+l,linepos))
	     handle Eof => (p := size (!b)));
	    String.substring(!b, oldp, (!p)-oldp))
	 end
d120 1
a120 1
       (* getchar: a straight-forward definition *)
d122 1
a122 1
    fun getchar (x as ref (b,p,bs,ln,lp,e,f)) =
d124 1
a124 1
	val pos = !p
d126 1
a126 1
	if pos >= size (!b) then
d129 1
a129 1
	  (p := pos+1;
d131 1
a131 1
	     val char = String.ordof(!b,pos)
d134 1
a134 1
	       (ln := !ln + 1; lp := 0)
d136 1
a136 1
	       lp := !lp + 1;
d141 2
a142 3
    fun getlinenum (ref (_,_,_,ln,_,_,_)) = !ln

    fun getlinepos (ref (_,_,_,_,lp,_,_)) = !lp
@


1.7
log
@Removed all currying from inbuffer
@
text
@d3 3
d86 1
a86 2
            if f = t
              then res
d88 1
a88 2
              if String.substring (b,f,1) = "\n"
              then cnaux (b,f+1,t,res+1)
d150 2
a151 4
	if pos >= size (!b)
	  then
	    (getsomemore x;
	     getchar x)
d154 2
a155 1
	   let val char = String.substring(!b,pos,1)
d157 5
a161 5
             (if char = "\n"
                then (ln := !ln + 1;
                      lp := 0)
              else lp := !lp + 1;
                char)
a167 1
	
@


1.6
log
@String structure is now pervasive.
@
text
@d3 3
d78 1
a78 1
    fun position (x as ref (b,p,bs,ln,lp,e,f)) (n,charpos) =
d101 1
a101 1
	     position x (n,charpos))
d113 1
a113 1
    fun forget (x as ref (b,p,bs,_,lp,e,f)) (n,charpos) =
d131 1
a131 1
    fun getstring (x as ref (b,p,bs,_,ref linepos,e,f)) l =
d138 1
a138 1
	   ((position x ((!p)+(!bs)+l,linepos)
@


1.5
log
@Fixed line position output from lexer
@
text
@d3 3
d21 1
a22 1
require "../utils/string";
d24 1
a24 2
functor InBuffer (structure String : STRING
		    ) : INBUFFER =
@


1.4
log
@Changed position so doesn't raise Eof when positioningto end of file
to end of file
@
text
@d3 4
d27 3
a29 1
      
d66 1
a66 1
    fun getpos (ref (_,ref p,ref bs,_,_,_,_)) = p+bs : int
d73 1
a73 1
    fun position (x as ref (b,p,bs,ln,lp,e,f)) n =
d96 1
a96 1
	     position x n)
d101 1
d108 1
a108 1
    fun forget (x as ref (b,p,bs,_,_,e,f)) n =
d120 1
d126 1
a126 1
    fun getstring (x as ref (b,p,bs,_,_,e,f)) l =
d133 1
a133 1
	   ((position x ((!p)+(!bs)+l)
d156 1
a156 1
              char)
@


1.3
log
@Added line numbering
@
text
@d3 3
d88 1
a88 1
	  if bp >= size (!b) then
@


1.2
log
@Added type constraints onto bp variables for the benefit of our compiler
@
text
@d3 3
d18 1
a18 1
    type InBuffer = (string ref * int ref * int ref * bool ref
d21 1
a21 1
      (* buffer, position in buffer, buffer start position, eof,
d35 1
a35 1
    fun mkInBuffer (f) = ref (ref "",ref 0,ref 0,ref false,f)
d41 1
a41 1
    fun getsomemore (ref (b,_,_,e, f)) = 
d57 3
a59 3
    fun getpos (ref (_,ref p,ref bs,_,_)) = p+bs : int
    fun getbuffstart (ref (_,_,ref bs,_,_)) = bs
    fun eof (ref (_,_,_,ref e,_)) = e
d64 1
a64 1
    fun position (x as ref (b,p,bs,e,f)) n =
d66 15
a80 1
	val bp:int = n-(!bs)
d88 4
a91 1
	  else
d93 1
d98 1
a98 1
    fun forget (x as ref (b,p,bs,e,f)) n =
d115 1
a115 1
    fun getstring (x as ref (b,p,bs,e,f)) l =
d129 1
a129 1
    fun getchar (x as ref (b,p,bs,e,f)) =
d139 8
a146 1
	   String.substring(!b,pos,1))
d148 4
a151 1
    
@


1.1
log
@Initial revision
@
text
@d2 4
a5 1
$Log$
d63 1
a63 1
	val bp = n-(!bs)
d79 1
a79 1
	val bp = n - !bs
@
