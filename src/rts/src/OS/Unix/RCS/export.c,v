head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.10
	MLWorks_20b2_Windows_1998_06_12:1.10
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.6.11
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.8.1.1.1.1
	MLWorks_workspace_97:1.6.10
	MLWorks_dt_wizard:1.6.9
	MLWorks_11c0_1997_09_09:1.6.8.1.1.1
	MLWorks_10r3:1.6.8.1.3
	MLWorks_10r2_551:1.6.8.1.2
	MLWorks_11:1.6.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.8.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.8
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MM_ML_release_korma_1997_04_01:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.6.1.1
	MLWorks_gui_1996_12_18:1.6.7
	MLWorks_1_0_Win32_1996_12_17:1.6.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.3.1
	JFHrts:1.6.5
	MLWorks_1_0_Irix_1996_11_28:1.6.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.4
	MLWorks_1_0_Unix_1996_11_14:1.6.3
	MLWorks_Open_Beta2_1996_10_11:1.6.2
	MLWorks_License_dev:1.6.1
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.10
date	98.06.09.15.11.00;	author mitchell;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	98.05.12.10.26.20;	author johnh;	state Exp;
branches;
next	1.8;

1.8
date	98.02.23.18.45.43;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	97.11.26.12.08.21;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	96.09.25.09.35.06;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1
	1.6.9.1
	1.6.10.1
	1.6.11.1;
next	1.5;

1.5
date	96.09.24.14.32.47;	author stephenb;	state Exp;
branches;
next	1.4;

1.4
date	96.08.06.10.46.56;	author jont;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.08.05.13.20.27;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.05.01.08.53.11;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	96.02.20.10.19.27;	author stephenb;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.21.47;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.10.07.16.11.52;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.17.11.30.36;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.11.14.12.56.33;	author hope;	state Exp;
branches
	1.6.3.1.1.1;
next	;

1.6.3.1.1.1
date	96.11.28.15.06.57;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.11.22.18.14.37;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.12.17.10.01.25;	author hope;	state Exp;
branches;
next	;

1.6.6.1
date	96.12.17.17.53.09;	author hope;	state Exp;
branches
	1.6.6.1.1.1;
next	;

1.6.6.1.1.1
date	97.02.24.11.44.03;	author hope;	state Exp;
branches;
next	;

1.6.7.1
date	96.12.18.09.47.43;	author hope;	state Exp;
branches;
next	;

1.6.8.1
date	97.05.12.10.40.06;	author hope;	state Exp;
branches
	1.6.8.1.1.1
	1.6.8.1.2.1
	1.6.8.1.3.1;
next	;

1.6.8.1.1.1
date	97.07.28.18.28.08;	author daveb;	state Exp;
branches
	1.6.8.1.1.1.1.1;
next	;

1.6.8.1.1.1.1.1
date	97.10.07.11.54.02;	author jkbrook;	state Exp;
branches;
next	;

1.6.8.1.2.1
date	97.09.08.17.21.07;	author daveb;	state Exp;
branches;
next	;

1.6.8.1.3.1
date	97.09.09.14.17.12;	author daveb;	state Exp;
branches;
next	;

1.6.9.1
date	97.09.10.19.35.53;	author brucem;	state Exp;
branches;
next	;

1.6.10.1
date	97.09.11.21.04.20;	author daveb;	state Exp;
branches;
next	;

1.6.11.1
date	97.10.31.13.47.25;	author nickb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.03.11;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This used to be src/rts/src/OS/common/unix_export.c
@


1.10
log
@[Bug #30419]
Move free edition check to rts:src:system.c
@
text
@/* Copyright (C) 1996 Harlequin Ltd
 *
 * An interface to exporting functions (unix version).
 *
 * $Log: src:OS:Unix:export.c,v $
 * Revision 1.9  1998/05/12  10:26:20  johnh
 * [Bug #30303]
 * Disable image saving on student edition.
 *
 * Revision 1.8  1998/02/23  18:45:43  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.7  1997/11/26  12:08:21  johnh
 * [Bug #30134]
 * Change deliverFn - can no longer save an image.
 *
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
 * Revision 1.5  1996/09/24  14:32:47  stephenb
 * [Bug #1612]
 * Altered the waitpid loop so that notice is taken of the
 * return value of waitpid so that it can be restarted if
 * it is interrupted.
 *
 * Revision 1.4  1996/08/06  10:46:56  jont
 * [Bug #1513]
 * Prevent messages coming out in the podium from the child process during deliver
 *
 * Revision 1.3  1996/08/05  13:20:27  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
 * Revision 1.2  1996/05/01  08:53:11  nickb
 * Change arguments of deliverFn.
 *
 * Revision 1.1  1996/02/20  10:19:27  stephenb
 * new unit
 * This used to be src/rts/src/OS/common/unix_export.c
 *
 * Revision 1.4  1996/02/19  17:12:13  nickb
 * Get rid of ad-hoc root clearing.
 *
 * Revision 1.3  1996/02/16  12:33:05  nickb
 * Change to global_pack().
 *
 * Revision 1.2  1996/02/14  15:16:02  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.1  1996/02/08  17:34:26  jont
 * new unit
 *
 *
 */

#include "syscalls.h"
#include <sys/types.h>
#include <errno.h>		/* errno, EINTR, EAGAIN, ... */
#include <sys/wait.h>		/* WIFERXITED, ... */
#include <unistd.h>
#include <assert.h>		/* assert */

#include "diagnostic.h"
#include "gc.h"
#include "exceptions.h"
#include "main.h"
#include "global.h"
#include "allocator.h"
#include "image.h"
#include "export.h"
#include "exec_delivery.h"
#include "utils.h"
#include "license.h"
#include "mlw_mklic.h"


/* The child process is in charge of saving the image/executable to disk.
 *
 * The argument is of the form: string * (unit -> unit) * bool
 * where the string is the name of the output file, the boolean controls
 * whether an executable (MLTRUE) or image (MLFALSE) is saved and 
 * the unit function is the function to call when the image/executable
 * is executed.
 * 
 * The child process exits with 0 if all is well, a results indicates
 * some known error and -1 indicates that something wacky has gone on.
 */
static void child_process(mlval argument)
{
  mlval global;
  mlval filename= FIELD(argument, 0);
  image_continuation= FIELD(argument, 1); /* global, and hence a root */
  
  messager_function= NULL;
  message_flusher= NULL; /* Prevent any messages going to the podium from the child */
  declare_root(&filename, 1);
  
  global= global_pack(1);	/* 1 = delivery */
  declare_root(&global, 1);

  gc_clean_image(global);
  
  DIAGNOSTIC(1,"save_executable being called",0,0);
  if (save_executable(CSTRING(filename), global, APP_CURRENT) == MLERROR) {
    DIAGNOSTIC(1,"save_executable failed, exiting with errno %d",errno,0);
    exit(errno ? errno : -1);
  } else {
    DIAGNOSTIC(1,"save_executable succeeded, exiting with errno %d",errno,0);
  }
  
  exit(0);
}



/* All this does is wait for the child process to complete and raise
 * an appropriate exception if there is an error.  If all goes well
 * it currently just returns MLUNIT otherwise it will raise an exception.
 *
 * wait.signal: waitpid has been interrupted by a signal, so try it again.
 *   Note that this should not happen under SunOS, since it 
 *   automatically restarts system calls but the redundancy
 *   doesn't hurt.
 *
 * wait.other: the status could be true for WIFSTOPPED (and perhaps other OS
 *   specific tests).  Not entirely sure what to do in these cases, 
 *   so for now just output a diagnostic and try waiting again.
 */
static mlval parent_process(pid_t child_pid)
{
  int status;
  DIAGNOSTIC(4, "Setting delivery child pid is %d", child_pid, 0);

  for (;;) {
    pid_t pid= waitpid(child_pid, &status, 0);
    if (pid < 0) {		/* wait.signal */
      assert(errno == EINTR);	
      continue;
    }
    assert(child_pid == pid);
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save,
		       "Delivery process terminated by signal %d",
		       WTERMSIG(status));
    }

    if (WIFEXITED(status))
      break;

    /* wait.other */
    DIAGNOSTIC(1, "non-fatal but unusual waitpid status %x", status, 0);
  }

  switch(WEXITSTATUS(status)) {
  case 0:
    break;
  case EIMPL:
    exn_raise_string(perv_exn_ref_save, "Function save not implemented");
  case EIMAGEWRITE:
    exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
  case EIMAGEREAD: /* An error occurred reading the image. */
    exn_raise_string(perv_exn_ref_save, "Unable to read original executable file");
  case EIMAGEOPEN:
    exn_raise_string(perv_exn_ref_save, "Unable to open image file");
  case EIMAGEALLOC:
    exn_raise_string(perv_exn_ref_save, "Unable to allocate memory to create image file");
  default:
    exn_raise_string(perv_exn_ref_save, "Unexpected error from deliverFn");
  }
  return MLUNIT; /* Should later change to return to MLWorks */
}



static void report_fork_failure(void)
{
  switch(errno) {
  case EAGAIN:
    exn_raise_string(perv_exn_ref_save,
		     "Too many processes running to fork deliverfn process");
  case ENOMEM:
    exn_raise_string(perv_exn_ref_save,
		     "Insufficient memory to fork deliverFn process");
  default: 
    exn_raise_format(perv_exn_ref_save,
		     "fork() returned an unexpected error code %d", errno);
  }
}



mlval deliverFn(mlval argument)
{
  pid_t pid= fork();
    
  if(pid == -1) {
    report_fork_failure();
    return MLUNIT;		/* not reached, keep dump compilers happy */
  } else if (pid == 0) {
    child_process(argument);
    return MLUNIT;		/* not reached, keep dump compilers happy */
  } else {
    return parent_process(pid);
  }
}
@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a5 4
 * Revision 1.10  1998/06/09  15:11:00  mitchell
 * [Bug #30419]
 * Move free edition check to rts:src:system.c
 *
@


1.9
log
@[Bug #30303]
Disable image saving on student edition.
@
text
@d6 4
d200 1
a200 9

  /* It is sensible that this test be carried out before forking */
  if (EDITION == STUDENT) {
    exn_raise_string(perv_exn_ref_save, "Delivery not enabled for this edition");
    return MLUNIT;
  }

  {
    pid_t pid= fork();
d202 8
a209 9
    if(pid == -1) {
      report_fork_failure();
      return MLUNIT;		/* not reached, keep dump compilers happy */
    } else if (pid == 0) {
      child_process(argument);
      return MLUNIT;		/* not reached, keep dump compilers happy */
    } else {
      return parent_process(pid);
    }
@


1.8
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d6 5
d74 2
a75 1

a195 1
  pid_t pid= fork();
d197 18
a214 8
  if(pid == -1) {
    report_fork_failure();
    return MLUNIT;		/* not reached, keep dump compilers happy */
  } else if (pid == 0) {
    child_process(argument);
    return MLUNIT;		/* not reached, keep dump compilers happy */
  } else {
    return parent_process(pid);
@


1.7
log
@[Bug #30134]
Change deliverFn - can no longer save an image.
@
text
@d6 4
d91 1
a91 1
  declare_root(&filename);
d94 2
a95 2
  declare_root(&global);
    
@


1.6
log
@Factored deliverFn into three new functions: child_process,
parent_process and report_fork_failure.  Added a block comment to
each one explaining what it does.  Also added some assertions
and more explanation in the waitpid section.
@
text
@d6 6
a82 1
  mlval save_exec= FIELD(argument, 2);
d94 4
a97 9
  if (save_exec == MLFALSE) {
    argument= allocate_record(2);
    FIELD(argument, 0)= filename;
    FIELD(argument, 1)= global;
    retract_root(&filename);
    retract_root(&global);
    
    if(image_save(argument) == MLERROR)
      exit(errno ? errno : -1);
d99 1
a99 7
    DIAGNOSTIC(1,"save_executable being called",0,0);
    if (save_executable(CSTRING(filename), global) == MLERROR) {
      DIAGNOSTIC(1,"save_executable failed, exiting with errno %d",errno,0);
      exit(errno ? errno : -1);
    } else {
      DIAGNOSTIC(1,"save_executable succeeded, exiting with errno %d",errno,0);
    }
@


1.6.11.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.8.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a5 3
 * Revision 1.6.8.1  1997/05/12  10:40:06  hope
 * branched from 1.6
 *
@


1.6.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a5 3
 * Revision 1.6.8.1  1997/05/12  10:40:06  hope
 * branched from 1.6
 *
@


1.6.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a5 3
 * Revision 1.6.8.1  1997/05/12  10:40:06  hope
 * branched from 1.6
 *
@


1.6.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a5 3
 * Revision 1.6.8.1.1.1  1997/07/28  18:28:08  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.7.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.6.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.6.1.1.1
log
@branched from 1.6.6.1
@
text
@a5 3
 * Revision 1.6.6.1  1996/12/17  17:53:09  hope
 * branched from 1.6
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.3.1.1.1
log
@branched from 1.6.3.1
@
text
@a5 3
 * Revision 1.6.3.1  1996/11/14  12:56:33  hope
 * branched from 1.6
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a5 6
 * Revision 1.6  1996/09/25  09:35:06  stephenb
 * Factored deliverFn into three new functions: child_process,
 * parent_process and report_fork_failure.  Added a block comment to
 * each one explaining what it does.  Also added some assertions
 * and more explanation in the waitpid section.
 *
@


1.5
log
@[Bug #1612]
Altered the waitpid loop so that notice is taken of the
return value of waitpid so that it can be restarted if
it is interrupted.
@
text
@d6 6
d44 2
a45 2
#include <errno.h>
#include <sys/wait.h>
d47 1
d60 14
a73 1
mlval deliverFn(mlval argument)
d75 11
a85 24
  pid_t child_pid = fork();

  if(child_pid == -1) {
    switch(errno) {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork deliverfn process");
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork deliverFn process");
      default: 
      exn_raise_format(perv_exn_ref_save,
		       "fork() returned an unexpected error code %d", errno);
    }
  } else if (child_pid == 0) {
    /* The child process */
    mlval global;
    mlval filename = FIELD(argument, 0);
    mlval save_exec = FIELD(argument, 2);
    image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */

    messager_function = NULL;
    message_flusher = NULL; /* Prevent any messages going to the podium from the child */
    declare_root(&filename);
d87 8
a94 2
    global = global_pack(1);	/* 1 = delivery */
    declare_root(&global);
d96 7
a102 11
    gc_clean_image(global);
    
    if (save_exec == MLFALSE) {
      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);
    
      if(image_save(argument) == MLERROR)
	exit(errno ? errno : -1);
d104 1
a104 8
      DIAGNOSTIC(1,"save_executable being called",0,0);
      if (save_executable(CSTRING(filename), global) == MLERROR) {
	DIAGNOSTIC(1,"save_executable failed, exiting with errno %d",errno,0);
	exit(errno ? errno : -1);
      } else {
	DIAGNOSTIC(1,"save_executable succeeded, exiting with errno %d",
		   errno,0);
      }
d106 24
a129 25
    
    exit(0);
  } else {
    /* The parent process */
    int status;
    DIAGNOSTIC(4, "Setting delivery child pid is %d", child_pid, 0);

    /* Now wait for the child to complete, and get its return status */
    for (;;) {
      if (waitpid(child_pid, &status, 0) != child_pid) {
	/* waitpid has been interrupted by a signal, so try it again.
	 * Note that this should not happen under SunOS, since it 
	 * automatically restarts system calls but the redundancy
	 * doesn't hurt.
	 */
	continue;

      }

      if (WIFSIGNALED(status)) {
	/* Child terminated by signal */
	exn_raise_format(perv_exn_ref_save,
			 "Delivery process terminated by signal %d",
			 WTERMSIG(status));
      }
d131 12
a142 2
      if (WIFEXITED(status))
	break;
d145 1
a145 2
    switch(WEXITSTATUS(status)) {
    case 0:
d147 55
a201 14
    case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Function save not implemented");
    case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
    case EIMAGEREAD: /* An error occurred reading the image. */
      exn_raise_string(perv_exn_ref_save, "Unable to read original executable file");
    case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");
    case EIMAGEALLOC:
      exn_raise_string(perv_exn_ref_save, "Unable to allocate memory to create image file");
    default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from deliverFn");
    }
    return MLUNIT; /* Should later change to return to MLWorks */
@


1.4
log
@[Bug #1513]
Prevent messages coming out in the podium from the child process during deliver
@
text
@d6 4
d110 1
d112 20
a131 8
    do {
      waitpid(child_pid, &status, 0);
    } while(!(WIFSIGNALED(status) || WIFEXITED(status)));
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save,
		       "Delivery process terminated by signal %d",
		       WTERMSIG(status));
d133 1
@


1.4.1.1
log
@branched from 1.4
@
text
@a5 4
 * Revision 1.4  1996/08/06  10:46:56  jont
 * [Bug #1513]
 * Prevent messages coming out in the podium from the child process during deliver
 *
@


1.3
log
@[Bug #1528]
Fixing problems when open fails delivering executables
@
text
@d6 4
d47 1
d71 3
@


1.2
log
@Change arguments of deliverFn.
@
text
@d6 3
d115 2
d119 2
@


1.1
log
@new unit
This used to be src/rts/src/OS/common/unix_export.c
@
text
@d5 5
a9 1
 * $Log: src:OS:common:unix_export.c,v $
d39 1
d61 1
d70 6
a75 5
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);
d77 12
a88 2
    if(image_save(argument) == MLERROR)
      exit(errno ? errno : -1);
@
