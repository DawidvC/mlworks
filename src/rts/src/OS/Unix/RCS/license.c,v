head	1.40;
access;
symbols
	MLW_daveb_inline_1_4_99:1.40.1
	MLWorks_21c0_1999_03_25:1.40
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.34
	MLWorks_20b2c2_1998_06_19:1.30
	MLWorks_20b2_Windows_1998_06_12:1.28
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.25
	MLWorks_20m2_1998_02_16:1.24
	MLWorks_MM_adapt:1.23.1
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.14.1.1.1.8.1
	MLWorks_workspace_97:1.21.2
	MLWorks_dt_wizard:1.21.1
	MLWorks_11c0_1997_09_09:1.14.1.1.1.8
	MLWorks_10r3:1.14.1.1.3
	MLWorks_10r2_551:1.14.1.1.2
	MLWorks_11:1.14.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.1.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.14.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.1
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MM_ML_release_korma_1997_04_01:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.2.1.1
	MLWorks_gui_1996_12_18:1.11.3
	MLWorks_1_0_Win32_1996_12_17:1.11.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.1.1
	JFHrts:1.11.1
	MLWorks_1_0_Irix_1996_11_28:1.10.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.2
	MLWorks_1_0_Unix_1996_11_14:1.10.1
	MLWorks_License_dev:1.1.1;
locks; strict;
comment	@ * @;


1.40
date	99.03.25.12.40.07;	author mitchell;	state Exp;
branches
	1.40.1.1;
next	1.39;

1.39
date	99.03.19.17.25.20;	author mitchell;	state Exp;
branches;
next	1.38;

1.38
date	99.03.09.16.00.18;	author mitchell;	state Exp;
branches;
next	1.37;

1.37
date	98.08.23.16.14.51;	author jkbrook;	state Exp;
branches;
next	1.36;

1.36
date	98.08.13.14.02.10;	author jkbrook;	state Exp;
branches;
next	1.35;

1.35
date	98.08.10.19.22.40;	author jkbrook;	state Exp;
branches;
next	1.34;

1.34
date	98.08.04.10.46.16;	author jkbrook;	state Exp;
branches;
next	1.33;

1.33
date	98.07.21.11.01.44;	author jkbrook;	state Exp;
branches;
next	1.32;

1.32
date	98.07.15.15.01.17;	author jkbrook;	state Exp;
branches;
next	1.31;

1.31
date	98.06.19.18.53.59;	author jkbrook;	state Exp;
branches;
next	1.30;

1.30
date	98.06.19.14.33.47;	author jkbrook;	state Exp;
branches;
next	1.29;

1.29
date	98.06.19.11.02.19;	author jkbrook;	state Exp;
branches;
next	1.28;

1.28
date	98.06.11.14.05.54;	author jkbrook;	state Exp;
branches;
next	1.27;

1.27
date	98.05.12.08.27.56;	author johnh;	state Exp;
branches;
next	1.26;

1.26
date	98.04.02.16.39.23;	author jkbrook;	state Exp;
branches;
next	1.25;

1.25
date	98.03.12.14.05.00;	author jkbrook;	state Exp;
branches;
next	1.24;

1.24
date	98.01.23.17.22.11;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	97.10.15.14.24.41;	author jont;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	97.10.15.14.03.34;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	97.09.01.15.38.21;	author jkbrook;	state Exp;
branches
	1.21.1.1
	1.21.2.1;
next	1.20;

1.20
date	97.08.08.09.00.20;	author jkbrook;	state Exp;
branches;
next	1.19;

1.19
date	97.08.04.09.44.08;	author jkbrook;	state Exp;
branches;
next	1.18;

1.18
date	97.08.01.14.06.54;	author jkbrook;	state Exp;
branches;
next	1.17;

1.17
date	97.08.01.13.35.24;	author jkbrook;	state Exp;
branches;
next	1.16;

1.16
date	97.07.24.16.25.45;	author jkbrook;	state Exp;
branches;
next	1.15;

1.15
date	97.07.22.16.19.46;	author jkbrook;	state Exp;
branches;
next	1.14;

1.14
date	97.01.07.15.30.47;	author jont;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	96.12.19.12.06.57;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.12.19.11.12.04;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.12.10.16.37.52;	author daveb;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1;
next	1.10;

1.10
date	96.11.13.13.51.28;	author daveb;	state Exp;
branches
	1.10.1.1
	1.10.2.1;
next	1.9;

1.9
date	96.11.12.17.00.50;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	96.11.12.12.23.27;	author daveb;	state Exp;
branches;
next	1.7;

1.7
date	96.11.12.11.54.17;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	96.11.11.14.53.37;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	96.11.06.16.13.33;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.10.23.11.24.40;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.10.22.10.35.04;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.10.18.16.51.18;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.10.15.15.51.18;	author jont;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	96.10.15.15.51.19;	author jont;	state Exp;
branches;
next	;

1.10.1.1
date	96.11.14.12.56.37;	author hope;	state Exp;
branches
	1.10.1.1.1.1;
next	;

1.10.1.1.1.1
date	96.11.28.15.07.00;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.11.22.18.14.40;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.12.17.10.01.29;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.12.17.17.53.12;	author hope;	state Exp;
branches
	1.11.2.1.1.1;
next	;

1.11.2.1.1.1
date	97.02.24.11.44.06;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.12.18.09.47.46;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	97.05.12.10.40.09;	author hope;	state Exp;
branches
	1.14.1.1.1.1
	1.14.1.1.2.1
	1.14.1.1.3.1;
next	;

1.14.1.1.1.1
date	97.07.28.18.24.56;	author daveb;	state Exp;
branches;
next	1.14.1.1.1.2;

1.14.1.1.1.2
date	97.08.08.18.54.34;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.3;

1.14.1.1.1.3
date	97.08.11.08.37.47;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.4;

1.14.1.1.1.4
date	97.08.11.14.17.23;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.5;

1.14.1.1.1.5
date	97.08.11.15.33.17;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.6;

1.14.1.1.1.6
date	97.08.11.16.34.17;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.7;

1.14.1.1.1.7
date	97.08.11.17.30.08;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.8;

1.14.1.1.1.8
date	97.09.04.11.25.10;	author jkbrook;	state Exp;
branches
	1.14.1.1.1.8.1.1;
next	;

1.14.1.1.1.8.1.1
date	97.10.07.11.50.43;	author jkbrook;	state Exp;
branches;
next	1.14.1.1.1.8.1.2;

1.14.1.1.1.8.1.2
date	97.10.15.16.40.48;	author jkbrook;	state Exp;
branches;
next	;

1.14.1.1.2.1
date	97.09.08.17.18.09;	author daveb;	state Exp;
branches;
next	;

1.14.1.1.3.1
date	97.09.09.14.14.21;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	97.09.10.19.30.42;	author brucem;	state Exp;
branches;
next	;

1.21.2.1
date	97.09.11.21.00.17;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	97.10.31.13.43.26;	author nickb;	state Exp;
branches;
next	;

1.40.1.1
date	99.04.01.18.00.33;	author daveb;	state Exp;
branches;
next	;


desc
@new file on MLWorks_License_dev
@


1.40
log
@[Bug #190509]
Use magic numbers from a working version of hqn_ms...
@
text
@/*  === LICENSING ===
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Uses the Harlequin License Server, and a timer interrupt.
 *
 * 
 *  $Log: src:OS:Unix:license.c,v $
 * Revision 1.39  1999/03/19  17:25:20  mitchell
 * Add strings for new permit
 *
 * Revision 1.38  1999/03/09  16:00:18  mitchell
 * [Bug #190509]
 * Update version strings to 2.1
 *
 * Revision 1.37  1998/08/23  16:14:51  jkbrook
 * [Bug #50100]
 * Set default to PERSONAL when license info is not found during
 * an interactive session
 *
 * Revision 1.36  1998/08/13  14:02:10  jkbrook
 * [Bug #30469]
 * Update license permit secret values (hqn_ms output) for version 2.0
 *
 * Revision 1.35  1998/08/10  19:22:40  jkbrook
 * [Bug #50100]
 * Set edition to Personal in all cases where license is INVALID since
 * we now offer users the choice of continuing in these cases
 *
 * Revision 1.34  1998/08/04  10:46:16  jkbrook
 * [Bug #30456]
 * Update license server details to 2.0 for 2.0 checkpoint
 *
 * Revision 1.33  1998/07/21  11:01:44  jkbrook
 * [Bug #30436]
 * Update edition names
 *
 * Revision 1.32  1998/07/15  15:01:17  jkbrook
 * [Bug #30435]
 * Remove validation and storage code
 *
 * Revision 1.31  1998/06/19  18:53:59  jkbrook
 * [Bug #30411]
 * Change license-server version to enable daily to run until
 * we have new permits
 *
 * Revision 1.30  1998/06/19  14:33:47  jkbrook
 * [Bug #30411]
 * When license-server doesn't serve a license, don't prompt
 * for new license and silently default to free
 *
 * Revision 1.29  1998/06/19  11:02:19  jkbrook
 * [Bug #30411]
 * Update license server version for AAAI release
 *
 * Revision 1.28  1998/06/11  14:05:54  jkbrook
 * [Bug #30411]
 * Handle free copies of MLWorks
 *
 * Revision 1.27  1998/05/12  08:27:56  johnh
 * [Bug #30303]
 * get edition.
 *
 * Revision 1.26  1998/04/02  16:39:23  jkbrook
 * [Bug #30382]
 * Convert date chars to lower case before converting back from
 * base 36
 *
 * Revision 1.25  1998/03/12  14:05:00  jkbrook
 * [Bug #50044]
 * Licence codes should not include 0 or 1
 * or lower-case letters in input
 *
 * Revision 1.24  1998/01/23  17:22:11  jont
 * [Bug #20076]
 * Don't terminate running image on network license loss
 *
 * Revision 1.23  1997/10/15  14:24:41  jont
 * [Bug #20072]
 * check_edition can pass unterminated strings to atoi. Fix this
 *
 * Revision 1.22  1997/10/15  14:03:34  jont
 * [Bug #30282]
 * Fix type of gethostid to match spec in header files under Solaris 2.6
 *
 * Revision 1.21  1997/09/01  15:38:21  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
 * Revision 1.20  1997/08/08  09:00:20  jkbrook
 * [Bug #30223]
 * Shortening license codes by using base 36 for date elements and
 * reducing CHECK_CHARS from 10 to 8
 *
 * Revision 1.19  1997/08/04  09:44:08  jkbrook
 * [Bug #20072]
 * Adding edition info (e.g., student, personal) to licensing
 *
 * Revision 1.18  1997/08/01  14:06:54  jkbrook
 * [Bug #20073]
 * Added datatype license_check_result for more flexible reporting
 * of license validation/checking results.
 *
 * Revision 1.17  1997/08/01  13:35:24  jkbrook
 * [Bug #30223]
 * Shorten license codes by removing number
 *
 * Revision 1.16  1997/07/24  16:25:45  jkbrook
 * [Bug #20077]
 * Adding an install-by date
 *
 * Revision 1.15  1997/07/22  16:19:46  jkbrook
 * [Bug #20077]
 * License expiry should be to the nearest day
 *
 * Revision 1.14  1997/01/07  15:30:47  jont
 * [Bug #1884]
 * Distinguish invalid licenses from expired licenses
 *
 * Revision 1.13  1996/12/19  12:06:57  jont
 * [Bug #1838]
 * Add license to contact message
 *
 * Revision 1.12  1996/12/19  11:12:04  stephenb
 * [Bug #1874]
 * Add a #include <unistd.h> to pick up the prototype for
 * gethostid amongst other things.
 *
 * Revision 1.11  1996/12/10  16:37:52  daveb
 * Made the registration scheme be the default.
 *
 * Revision 1.10  1996/11/13  13:51:28  daveb
 * Fixed bug in conversion of error_string to an ml value: sizeof("....") includes
 * the trailing null.  Replaced the existing code with a call to ml_string.
 * Also removed the trailing newline from the error string.
 *
 * Revision 1.9  1996/11/12  17:00:50  daveb
 * Added an expiration date.
 *
 * Revision 1.8  1996/11/12  12:23:27  daveb
 * Updated expiry message.
 *
 * Revision 1.7  1996/11/12  11:54:17  daveb
 * Fixed a typo in the previous change, which won't compile without it.
 *
 * Revision 1.6  1996/11/11  14:53:37  daveb
 * Added support for registration-style licensing.
 *
 * Revision 1.5  1996/11/06  16:13:33  jont
 * Try to reacquire license if lost/timed out.
 * This should allow processes to be stopped and restarted
 *
 * Revision 1.4  1996/10/23  11:24:40  jont
 * [Bug #1693]
 * Don't hang on license failure when running in batch mode
 *
 * Revision 1.3  1996/10/22  10:35:04  jont
 * [Bug #1685]
 * Change printf into DIAGNOSTIC
 *
 * Revision 1.2  1996/10/18  16:51:18  jont
 * new unit
 * Moving from MLWorks_License_dev to trunk
 *
 * Revision 1.1.1.1  1996/10/15  15:51:19  jont
 * new unit
 * No longer platform specific, so moved to a common place
 *
 * Revision 1.2.2.4  1996/10/14  16:28:06  nickb
 * Improve error behaviour.
 *
 * Revision 1.2.2.3  1996/10/09  12:45:33  nickb
 * Call timer function.
 *
 * Revision 1.2.2.2  1996/10/08  16:15:16  jont
 * Start adding stuff to use HQN_LS
 *
 * Revision 1.2.2.1  1996/10/07  16:13:29  hope
 * branched from 1.2
 *
 * Revision 1.2  1995/02/23  15:41:38  nickb
 * Change assignment of pid.
 *
 * Revision 1.1  1994/07/08  10:43:07  nickh
 * new file
 *
 *
 */

#include <unistd.h>		/* sleep, gethostid */
#include "ansi.h"
#include "syscalls.h"
#include "utils.h"
#include "diagnostic.h"
#include "environment.h"
#include "allocator.h"
#include "license.h"
#include "signals.h"
#include "utils.h"
#include "values.h"
#include "x.h"
#include "hqn_ls.h"
#include "sha.h"
#include "mlw_mklic.h"
#include "version.h"
#include <errno.h>
#include <sys/errno.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#define N_DATA_VALUES 4
#define N_CHALLENGES 4
#ifndef NULL
#define NULL 0
#endif

/* These messages are for the case where we find a corrupt license at 
the start of a session */

static char c_license_error_invalid[] = LICENSE_ERROR_INVALID;
static char c_license_error_expired[] = LICENSE_ERROR_EXPIRED;
static char c_license_error_installdate[] = LICENSE_ERROR_INSTALL;
static char c_license_error_version[] = LICENSE_ERROR_VERSION;
static char c_license_error_lost[] = "License expired or network error, continuing";
static char c_license_error_chars[] = LICENSE_ERROR_CHARS;

int license_failure_hang = 1;

int act_as_free = 0;

/* default to minimum edition allowing delivery (for use in executables) */
/* this is a global whose value is returned by "license get edition" */

enum edition license_edition = PROFESSIONAL;

#ifdef Solaris_License /* Only needed on Solaris */
#include <sys/systeminfo.h>
/* These next to allow the license client to link correctly */

extern void bzero(void *a, size_t b);
extern void bzero(void *a, size_t b)
{
  memset(a,0,b);
}

extern void bcopy(const void *a, void *b, size_t c);
extern void bcopy(const void *a, void *b, size_t c)
{
  memcpy(b,a,c);
}

extern long gethostid(void);
extern long gethostid(void)
{
  char buff [300];
  char *end;
  if (sysinfo (SI_HW_SERIAL,buff, 287) == -1)
    return -1;
  return (strtoul(buff,&end,10) | (buff == end ? -1 : 0));
}
#endif

#define PUBLISHER_NAME	"Harlequin Limited"
#define PRODUCT_NAME	"MLWorks Professional"
#define VERSION_STRING	"Version 2.1"

static int have_a_license = 0;
static int use_license_server = 0;

/* hqn_ms output follows: */
static hls_uint Chalvals[N_CHALLENGES] = {
    0x77d09eeb,
    0x1a7ca930,
    0x3503784,
    0x1c68674c,
};

static hls_uint Signature1[ 16 ] = {
0x6073b5fd, 0x6fa870bc, 0x33ec7a98, 0xbc559b3e,
0x28bfac6f, 0xdefee315, 0xa3a1fa0a, 0x7d7d47a9,
0x826a4563, 0xc4537919, 0xb20d401c, 0xb4776b5b,
0x1d2fc6dc, 0x8eb5dbde, 0x31896029, 0xbfa2f430,
};

static hls_uint Signature2[ 16 ] = {
0x27b7a68c, 0x11ac2c7, 0x5d3b781c, 0x7582c96d,
0xd709b161, 0x5ec6c22e, 0xc71d741d, 0xeb7d2733,
0xf290319c, 0x3e445a04, 0x539c8524, 0x7eca1455,
0xde49f718, 0xaf2342ed, 0x92d2424d, 0xed58d042,
};

static hls_uint Signature3[ 16 ] = {
0x7954b5df, 0xe3f45f21, 0x97b6a687, 0x9573df4d,
0xfc2e93f7, 0x588c6208, 0x2538b956, 0xf64b9b4f,
0x3f2d8521, 0x3e4158d6, 0xc80d2d05, 0x279e921b,
0xd7470970, 0xc61e3486, 0x61d3ae89, 0xee1feefb,
};

static hls_uint Signature4[ 16 ] = {
0xb78c9023, 0x369e1214, 0x418eef21, 0xe93480ca,
0xf88f1631, 0x7d41679e, 0x8572997, 0x7ceaae0c,
0xba9e8071, 0x7d2cd7eb, 0xb1ec8763, 0x8849b302,
0xb6bd93b3, 0xcba247bf, 0x873b734e, 0xd0e251dd,
};

/* the following made static (it is not in the hqn_ms output) */

static hls_uint *Signatures[ N_CHALLENGES ] = {
    Signature1,
    Signature2,
    Signature3,
    Signature4,
};

/* hqn_ms output ends */

static hls_int Databuf[ N_DATA_VALUES + 1];

static LSdata ls_data;

static void init_lsdata(LSdata *ldata,
			const char *LicenseSystem,
			const char *PublisherName,
			const char *ProductName,
			const char *VersionString)
{
  /* casts necessary because the struct defn doesn't have const qualifiers */
  ldata->LicenseSystem = (char*)LicenseSystem;
  ldata->PublisherName = (char*)PublisherName;
  ldata->ProductName   = (char*)ProductName;
  ldata->VersionString = (char*)VersionString;
  ldata->Nchals = N_CHALLENGES;
  ldata->Chalvals = Chalvals;
  ldata->Ndata = N_DATA_VALUES;
  ldata->Data = Databuf;
  ldata->Sig_Index = Signatures;
}

static mlval mlw_license_check_result_make (enum license_check_result index)
{
  return MLINT(index);
}

static void license_lost(void)
{
  x_reveal_podium();
  message(c_license_error_lost);
  message_stderr(c_license_error_lost);
}

static void license_found(void)
{
  x_hide_podium();
}

static int initialise(int starting)
{
  hls_int result;
  result = ls_initialise(&ls_data);
  DIAGNOSTIC(1, "License started with result %d", result, 0);
  if (ls_get_license(&ls_data)) {
    have_a_license = 1;
    if (starting)
      signal_license_timer(ls_data.UpPeriod);
    return 1;
  } else
    return 0;
}

static mlval license_start()
{
  init_lsdata(&ls_data, HQNLS_VERSION,
	      PUBLISHER_NAME,
	      PRODUCT_NAME,
	      VERSION_STRING);
  if (initialise(1)) { /* Starting */
    /* eventually we want to pick up edition info from the server */
    license_edition = PROFESSIONAL;
    env_value("license edition", license_edition);
    return mlw_license_check_result_make(OK);
  } else {
    /* if no licence found run as Free version */
    license_edition = PERSONAL;
    return mlw_license_check_result_make(NOT_FOUND);
  }
}

extern void license_release(void)
{
  if (have_a_license)
    ls_release_lic(&ls_data);
}

void refresh_license(void)
{
  if (use_license_server) {
    if (have_a_license) {
      if (ls_update_lic(&ls_data) == 0) {
	have_a_license = 0;
	if (!initialise(0)) /* Not starting */
	  license_lost();
      }
    } else {
      if (initialise(0)) /* Try to reacquire the license */
	license_found();
    }
  }
}

/*  Implementation 2
 *  ----------------
 *  Uses the SHA algorithm
 * 
 */

static mlval license_error_invalid(mlval arg)
{
  return ml_string(c_license_error_invalid);
}

static mlval license_error_expired(mlval arg)
{
  return ml_string(c_license_error_expired);
}

static mlval license_error_installdate(mlval arg)
{
  return ml_string(c_license_error_installdate);
}

static mlval license_error_version(mlval arg)
{
  return ml_string(c_license_error_version);
}

static mlval license_error_chars(mlval arg)
{
  return ml_string(c_license_error_chars);
}

static const char * name_file_stem = "/.mlworks_user";
static const char * code_file_stem = "/.mlworks_license";

#define BUF_SIZE 1024

/* read_file reads a line from "file" in the user's home directory */
static int read_file(const char *file, char *buffer)
{
  char* path;
  char* home;
  FILE *f;

  home = getenv("HOME");
  if (home == NULL)
    goto could_not_determine_home;

  if (strlen(home)+strlen(file) > BUF_SIZE-1)
    goto buffer_too_small;

  path = malloc(BUF_SIZE);

  if (path == NULL) {
    DIAGNOSTIC (1, "Can't malloc filename string", 0, 0);
    goto malloc_failed;
  }

  strcpy(path, home);
  strcat(path, file);

  f = fopen(path, "r");
  if (f == NULL) {
    DIAGNOSTIC(1, "Could not open %s for reading", path, 0);
    goto could_not_open_file;
  }
  if (fgets(buffer, BUF_SIZE, f) == NULL)
    goto could_not_read;
  
  fclose(f);
  free(path);
  return 1;

 could_not_read:
  fclose(f);
 could_not_open_file:
  free(path);
 malloc_failed:
 buffer_too_small:
 could_not_determine_home:
  return 0;
}

/* get_license gets the encoded license info from the file system. */
static int get_license(char *name, char *code)
{
  char * name_file;
  char * code_file;

  name_file = malloc(strlen(name_file_stem) + strlen(VERSION_STR));
  code_file = malloc(strlen(code_file_stem) + strlen(VERSION_STR));

  strcpy(name_file,name_file_stem);
  strcpy(code_file,code_file_stem);
 
  strcat(name_file,VERSION_STR);
  strcat(code_file,VERSION_STR);

  if (read_file(name_file, name)
      && read_file(code_file, code))
    return 1;
  else
    return 0;
}

/* Users are given their license name and a 15-character check string.  The
 * last 6 characters of this string are the expiry date, in the format ddmmyy.
 * The 6 characters before that are the install-by date, also as ddmmyy.
 * The 1 character before that encodes the edition.
 * The first 8 characters are the last 8 characters
 * of the result of hashing the name, edition, installation date and 
 * expiry date. CHECK_CHARS, EDITION_CHARS and DATE_CHARS are defined in 
 * rts/src/sha/mlw_mklic.h
 */

/* conversion from base 36 to decimal */

static int base_36_to_decimal (char d)
{
  int result;

  if (isalpha(d))
    result = ((int)(tolower(d)) - (int)('a')) + 10;
  else
    result = (int)(d) - (int)('0');

  return result;
};

/* check_date checks that the current date is before the date argument.
 * Its argument is a pointer to the expiry/install-by date, which is 
 * assumed to be DATE_CHARS long.  It is not assumed to be null-terminated  
 * after these chars.  
 */

static int check_date(char *date)
{
  struct tm *tm;
  char year_36, month_36, day_36;
  int year, month, day;
  time_t now;

  /* if sscanf fails here it may mean that we are checking an old license
   * with expiry date of form mmyy.  An appropriate message should
   * be printed (rather than license expired as here).
   */

  if (sscanf (date, "%1c%1c%1c", &day_36, &month_36, &year_36) < 3)
    return 0;

  /* convert back to decimal and remove offset */

  day = base_36_to_decimal(day_36) - 2;
  month = base_36_to_decimal(month_36) - 2;
  year = base_36_to_decimal(year_36) - 2;

  /* convert back to last-two-digits-of-year format in decimal */
  if (year < 10)
    year += 90;  /* C20 dates */
  else 
    year -= 10;  /* C21 dates */

  if (year < 90)
    year += 100;

  if (time(&now) < 0)
    return 0;
  tm = localtime(&now);
  /* struct tm numbers months from 0, whereas we number them from 1. */
  if (tm->tm_year > year || 
      (tm->tm_year == year && tm->tm_mon >= month) ||
      (tm->tm_year == year && tm->tm_mon == (month - 1) && tm->tm_mday > day)) {
    return 0;
  }
  /* Don't free tm; it's a static value in the library. */
  return 1;
}

static mlval license_get_edition(mlval arg)
{
  if (act_as_free) {
    return MLINT(PERSONAL);
  } else {
    return MLINT(license_edition);
  }
}

/* unit -> edition */

static mlval license_set_edition(mlval arg)
{
  /* this is used to default to PERSONAL in case when license is
   corrupt but user continues into session, since real default is 
   Professional */

  license_edition = PERSONAL;
  DIAGNOSTIC(1, "Set license edition to Personal",0,0);

  return 0;
}

static int convert_edition(char edition)
{
  return (((edition - '0') - 2));
}

/* check_license_files checks an existing license */
/* unit -> license_check_result */
/* Returns
 * NOT_FOUND        No license found -- run as Free
 * INVALID          License found but invalid   
 * OK               License found and ok -- run as non-Free
 * EXPIRED          License found but expired   
 * WRONG_EDITION    License is for a different edition
 */

static mlval check_license_files (void)
{
  char *name;
  char *code;

  mlval result = MLUNIT;

  name = malloc (BUF_SIZE);
  if(name == NULL) {
    DIAGNOSTIC (1, "Can't malloc license name string", 0, 0);
    result = mlw_license_check_result_make(INTERNAL_ERROR);
    goto name_malloc_failed;
  }

  code = malloc (BUF_SIZE);
  if(code == NULL) {
    DIAGNOSTIC (1, "Can't malloc license code string", 0, 0);
    result = mlw_license_check_result_make(INTERNAL_ERROR);
    goto code_malloc_failed;
  }

  /* default for interactive sessions */

  license_edition = PERSONAL;

  if (get_license(name, code)) {
    SHA_INFO sha_info;
    char *input, *sha_result;
    long hostid = gethostid();
    int len;

    len = strlen(name);
    input = malloc(len+sizeof(long)+1);
    if (input == NULL)
      error("malloc failed");
    strcpy(input,name);
    memcpy(&input[len],(char*)&hostid,sizeof(long));
    input[len+sizeof(long)] = '\0';
  
    sha_string(&sha_info, input,len+sizeof(long));
    sha_result = sha_sprint(&sha_info);


    if ((strcmp(sha_result,code) == 0)) {
        if (check_date(name)) {
          DIAGNOSTIC (1, "License is valid", 0, 0);
          license_edition = convert_edition(name[DATE_CHARS]);
          DIAGNOSTIC (1, "License edition set to %d", license_edition, 0);
          result = mlw_license_check_result_make(OK); 
        } else {
          result = mlw_license_check_result_make(EXPIRED); 
        }
    } else {
      result = mlw_license_check_result_make(INVALID);  
    }
    free(input);
    free(sha_result);
  } else {
    result = mlw_license_check_result_make(NOT_FOUND);  
  }

  DIAGNOSTIC (1, "Edition is: %d", license_edition, 0);

  free(code);
 code_malloc_failed:
  free(name);
 name_malloc_failed:
  return result;
}

/* By default, license_check starts the license server.  If MLWORKS_LICENSE
 * is set to "keyfile" in the environment, it instead checks the stored
 * license, and prompts the user if necessary. 
 */
/* unit -> license_check_result */
static mlval license_check(mlval arg)
{
  char *license_setting;

  license_setting = getenv("MLWORKS_LICENSE");
  if (license_setting != NULL && (strcmp(license_setting,"server") == 0)) {
    use_license_server = 1;
    return license_start();
  } else {
    return check_license_files();
  }
}

void license_init(void)
{
  env_function("license check", license_check);
  env_function("license error expired", license_error_expired);
  env_function("license error invalid", license_error_invalid);
  env_function("license error install date", license_error_installdate);
  env_function("license error wrong version", license_error_version);
  env_function("license error illegal chars", license_error_chars);

  env_function("license get edition", license_get_edition);

  env_function("license set edition", license_set_edition);

  have_a_license = 0;
  use_license_server = 0;   /* Default use registration scheme */
  license_failure_hang = 1; /* Default wait for user interaction */
  act_as_free = 0;
}
@


1.40.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.40  1999/03/25  12:40:07  mitchell
 * [Bug #190509]
 * Use magic numbers from a working version of hqn_ms...
 *
@


1.39
log
@Add strings for new permit
@
text
@d11 3
d276 4
a279 4
    0x24f5ada4,
    0x39bf6a20,
    0x67ae930,
    0x3bcb0540,
d283 4
a286 4
0xedde8ffb, 0xacc33ed5, 0x59e3a0d1, 0x5fb6b121,
0xedde8ffb, 0xacc33ed5, 0x59e3a0d1, 0x5fb6b121,
0xedde8ffb, 0xacc33ed5, 0x59e3a0d1, 0x5fb6b121,
0xedde8ffb, 0xacc33ed5, 0x59e3a0d1, 0x5fb6b121,
d290 4
a293 4
0xaebc796, 0xf824e175, 0xc8438233, 0x68233273,
0xaebc796, 0xf824e175, 0xc8438233, 0x68233273,
0xaebc796, 0xf824e175, 0xc8438233, 0x68233273,
0xaebc796, 0xf824e175, 0xc8438233, 0x68233273,
d297 4
a300 4
0xd6b3e053, 0x1c36417b, 0x9c194924, 0x37136102,
0xd6b3e053, 0x1c36417b, 0x9c194924, 0x37136102,
0xd6b3e053, 0x1c36417b, 0x9c194924, 0x37136102,
0xd6b3e053, 0x1c36417b, 0x9c194924, 0x37136102,
d304 4
a307 4
0xaae66dc3, 0x7f7bccc2, 0x9197103c, 0x59d2fe65,
0xaae66dc3, 0x7f7bccc2, 0x9197103c, 0x59d2fe65,
0xaae66dc3, 0x7f7bccc2, 0x9197103c, 0x59d2fe65,
0xaae66dc3, 0x7f7bccc2, 0x9197103c, 0x59d2fe65,
@


1.38
log
@[Bug #190509]
Update version strings to 2.1
@
text
@d11 4
a271 1

d273 4
a276 4
    0x6040c1ed,
    0x53875d0a,
    0x436ca756,
    0x2692afb6,
d280 4
a283 4
0xa298bcab, 0xd3c5a620, 0xd9c8655e, 0x2a367547,
0xd205af84, 0x3776cd94, 0xd30d26c2, 0xa2224961,
0x7d6c85e0, 0xdd2e0d08, 0xd739b254, 0x948211f9,
0x294a7ae8, 0xdd9de74a, 0x9a8e69b8, 0xa40a22be,
d287 4
a290 4
0xd53836c0, 0x9d2e630b, 0xfcef3f55, 0x1ec6984d,
0x46eb1676, 0xe381cc35, 0xc9b2809c, 0x5fcbd805,
0xf55b3ee6, 0x1e27a694, 0xb9b62365, 0xb758f16a,
0x84f78996, 0xb1734f33, 0xc931db8d, 0x9d0b9bb7,
d294 4
a297 4
0xa5d926a6, 0xcccce65f, 0xf69708bf, 0x24fdbaf8,
0xc931c7f6, 0xb73d1785, 0x1980ee46, 0xbf7c8e9,
0x6662d95a, 0x74a44f6c, 0x2cb4d78b, 0x7a96bcaf,
0x5b6136e9, 0x8b61febd, 0xc1bbc510, 0x548f5334,
d301 4
a304 4
0x2770804b, 0x3149d22c, 0xe4d6eea2, 0x72c0202f,
0xac5510e9, 0x6f598be4, 0x40931f5a, 0xd5df3923,
0xae9d99f8, 0x8e2e13a2, 0x883472d1, 0x8513f62f,
0x3e79077, 0x85fcea0d, 0x31caa09a, 0x3a57f230,
@


1.37
log
@[Bug #50100]
Set default to PERSONAL when license info is not found during
an interactive session
@
text
@d11 5
d262 1
a262 1
#define VERSION_STRING	"Version 2.0"
@


1.36
log
@[Bug #30469]
Update license permit secret values (hqn_ms output) for version 2.0
@
text
@d11 4
d639 3
a659 3
    /* default for interactive sessions */

    license_edition = PERSONAL;
@


1.35
log
@[Bug #50100]
Set edition to Personal in all cases where license is INVALID since
we now offer users the choice of continuing in these cases
@
text
@d11 5
d261 4
a264 4
    0x611fcd8d,
    0x2e9ea289,
    0x31bf9fa,
    0x412ac807,
d268 4
a271 4
0xb7dcdb64, 0xe6ee81c8, 0x5489902c, 0x72cb5dc7,
0xd41062cd, 0x86bdf55e, 0xa77ec367, 0xe3edf0e8,
0x20e4d6f8, 0x959150a4, 0x1df8e445, 0x859c61e,
0xf80ee071, 0xf5047a7c, 0x6df801dc, 0x107af490,
d275 4
a278 4
0x1e50723a, 0x4a2b933e, 0x435ad8dd, 0x8c16e421,
0x859faeea, 0x9c001979, 0x139dbe51, 0x5e903609,
0xd4215649, 0x6af17a2b, 0x1f262681, 0xd808487c,
0x14f49577, 0x5a69cb01, 0x69df87bd, 0xafd09f74,
d282 4
a285 4
0xaf2a0a82, 0x2da69ac5, 0x4069407c, 0x4f6cb819,
0xb7a6461a, 0xb4721837, 0x5f8a5d00, 0x2de5583d,
0x4d0e98f, 0xf1e8d337, 0x2a814ae6, 0xdd63e341,
0xa69fc3c5, 0x50003554, 0x955e50cb, 0xae339dd9,
d289 4
a292 4
0x941e6469, 0xdb33f41f, 0x3c83612d, 0x1b672b08,
0x2936e509, 0x80506043, 0x943702da, 0xc8566478,
0xc0fd1b69, 0xa1e75f0c, 0x801626b7, 0x3a11c941,
0x3e1b293f, 0xc50ee41b, 0xb108ccfd, 0x9b7fe4e1,
@


1.34
log
@[Bug #30456]
Update license server details to 2.0 for 2.0 checkpoint
@
text
@d11 4
d215 1
a367 1
    env_value("license edition", license_edition);
d576 1
a576 1
    return MLINT(env_lookup("license edition"));
d588 2
a589 2
  license_edition = mlw_license_check_result_make(PERSONAL);
  env_value("license edition", license_edition);
d648 3
a655 1
          env_value("license edition", license_edition);
a666 2
    license_edition = PERSONAL;
    env_value("license edition", license_edition);
d669 1
a709 3
  /* default license edition value */
  env_value("license edition",license_edition);
 
@


1.33
log
@[Bug #30436]
Update edition names
@
text
@d11 4
d242 2
a243 2
#define PRODUCT_NAME	"MLWorks"
#define VERSION_STRING	"Version 1.0"
@


1.32
log
@[Bug #30435]
Remove validation and storage code
@
text
@d11 4
d206 1
a206 1
/* default to an edition allowing delivery for use in executables */
d208 1
a208 1
enum edition license_edition = PERSONAL;
d353 1
a353 1
    license_edition = PERSONAL;
d358 1
a358 1
    license_edition = FREE;
d566 1
a566 1
    return MLINT(FREE);
d576 3
a578 2
  /* used to default to FREE when license is corrupt but user
    continues into session, since real default is Personal */
d580 1
a580 1
  license_edition = mlw_license_check_result_make(FREE);
d657 1
a657 1
    license_edition = FREE;
@


1.31
log
@[Bug #30411]
Change license-server version to enable daily to run until
we have new permits
@
text
@d11 5
a170 1

d188 2
a463 51
/* write_file reads a line from "file" in the user's home directory */
static int write_file(const char *file, char *buffer)
{
  char* path;
  char* home;
  FILE *f;

  home = getenv("HOME");
    DIAGNOSTIC(1, "HOME is %s", home, 0);
  if (home == NULL)
    goto could_not_determine_home;

  if (strlen(home)+strlen(file) > BUF_SIZE-1)
    goto buffer_too_small;

  path = malloc(BUF_SIZE);

  if (path == NULL) {
    DIAGNOSTIC (1, "Can't malloc filename string", 0, 0);
    goto malloc_failed;
  }

  strcpy(path,home);
  strcat(path,file);

  f = fopen(path, "w");
  if (f == NULL) {
    DIAGNOSTIC(1, "Could not open %s for writing", path, 0);
    goto could_not_open_file;
  }
  if (fputs(buffer,f) == -1)
    goto could_not_write;

  if (fclose(f) == -1) {
    DIAGNOSTIC(1, "Could not flush data to %s", path, 0);
    goto could_not_flush;
  }
  free(path);
  return 1;

 could_not_write:
  fclose(f);
 could_not_flush:
 could_not_open_file:
  free(path);
 malloc_failed:
 buffer_too_small:
 could_not_determine_home:
  return 0;
}

a485 45
/* license_store stores the license and its encoded form in the file system. */
/* string -> bool */
static mlval license_store(mlval arg)
{
  mlval result;
  char *name = CSTRING(arg);
  SHA_INFO sha_info;
  char *input, *sha_result;
  long hostid = gethostid();
  int len;

  char * name_file;
  char * code_file;

  name_file = malloc(strlen(name_file_stem) + strlen(VERSION_STR));
  code_file = malloc(strlen(code_file_stem) + strlen(VERSION_STR));

  strcpy(name_file,name_file_stem);
  strcpy(code_file,code_file_stem);

  strcat(name_file,VERSION_STR);
  strcat(code_file,VERSION_STR);

  len = strlen(name);
  input = malloc(len+sizeof(long)+1);
  if (input == NULL)
    error("malloc failed");
  strcpy(input,name);
  memcpy(&input[len],(char*)&hostid,sizeof(long));
  input[len+sizeof(long)] = '\0';
  
  sha_string(&sha_info, input,len+sizeof(long));
  sha_result = sha_sprint(&sha_info);

  if (write_file(name_file, name)
      && write_file(code_file, sha_result))
    result = MLTRUE;
  else
    result = MLFALSE;

  free(input);
  free(sha_result);
  return result;
}

a509 26
/* conversion from input format of SHA (upper case and omitting 0,1) to
internal format */

static char * convert_code (char * code_string) 
{
  
  char *result;
  int i;

  result = malloc(CHECK_CHARS);

  strncpy(result, code_string, CHECK_CHARS);

  for (i = 0; i < CHECK_CHARS; i++) {
     if (result[i] == '@@') {
       result[i] = '0';
     } else if (result[i] == '%') {
       result[i] = '1';
     } else if (isalpha(result[i])) {
       result[i] = tolower(result[i]);
     };
  };

  return result;
};

d568 3
a570 1
static int convert_edition(char edition)
d572 7
a578 1
  return (((edition - '0') - 2));
d581 1
a581 1
static int check_chars(char *code_string) 
d583 1
a583 10
   int len, i;

   len = strlen(code_string);
 
   for (i = 0; i < len; i++) {
     if (code_string[i] == '0' || code_string[i] == '1' || islower(code_string[i])) {
       return 0;
     }
   }
   return 1;
a585 1

a682 72
/* license_validate checks that the user's input is valid. */
/* string * string -> license_check_result */
static mlval license_validate(mlval arg)
{
  char *name = CSTRING(FIELD(arg,0));
  char *check = CSTRING(FIELD(arg,1));
  SHA_INFO sha_info;
  char *input, *sha_result, *convert_check;
  mlval result;

  /* The validation algorithm takes the name, appends the edition
     and the installation and expiry dates, calls SHA, and compares the
     last ten digits of the result with the first ten of the check
     digits after tranformation to restore 0 and 1. 
  */

  if (strlen(check) != CHECK_CHARS + EDITION_CHARS + (2 * DATE_CHARS)) {
    DIAGNOSTIC (1, "License code has %d characters", strlen(check), 0);
    return MLFALSE;
  }

  if (!check_chars(check)) {
    result = mlw_license_check_result_make(ILLEGAL_CHARS);
    return(result);
  }
 
  convert_check = convert_code(check);

  input = malloc(strlen(name) + EDITION_CHARS + (2 * DATE_CHARS) + 1);
  if (input == NULL)
    error("malloc failed");

  strcpy (input, name);
  strcat (input, convert_code(check+CHECK_CHARS));

  sha_string(&sha_info,input,strlen(input));
  sha_result = sha_sprint(&sha_info);


  /* Validation results:
   * INVALID => license invalid (check failed)
   * OK => license OK wrt to installation and expiry dates
   * INSTALLDATE => installation date passed
   * EXPIRED => expiry date passed 
   * WRONG_EDITION => license is for a different edition
   * ILLEGAL_CHARS => code contains zero or one
   */
  
  /* default */
  result = mlw_license_check_result_make(INVALID);

  if (!strncmp(convert_check, &sha_result[strlen(sha_result)-CHECK_CHARS], CHECK_CHARS)) {
      /* check installation date */
       if (check_date(check+CHECK_CHARS+EDITION_CHARS)) {
         if (check_date(&check[CHECK_CHARS+EDITION_CHARS+DATE_CHARS])) {
           result = mlw_license_check_result_make(OK);
         } else {
           result = mlw_license_check_result_make(EXPIRED);
         }
       } else {
         result = mlw_license_check_result_make(INSTALLDATE);
       }
  } else {
    result = mlw_license_check_result_make(INVALID);
  }

  free(input);
  free(sha_result);

  return result;
}

a684 1
  env_function("license validate", license_validate);
a685 1
  env_function("license store", license_store);
d693 2
@


1.30
log
@[Bug #30411]
When license-server doesn't serve a license, don't prompt
for new license and silently default to free
@
text
@d11 5
d228 2
a229 2
#define PRODUCT_NAME	"MLWorks Professional"
#define VERSION_STRING	"Version 2.0"
@


1.29
log
@[Bug #30411]
Update license server version for AAAI release
@
text
@d11 4
d345 1
a345 1
    return mlw_license_check_result_make(INVALID);
@


1.28
log
@[Bug #30411]
Handle free copies of MLWorks
@
text
@d11 4
d219 2
a220 2
#define PRODUCT_NAME	"MLWorks"
#define VERSION_STRING	"Version 1.0"
@


1.27
log
@[Bug #30303]
get edition.
@
text
@d11 4
d157 1
a157 1

d181 6
d328 4
a331 1
  if (initialise(1)) /* Starting */
d333 4
a336 1
  else
d338 1
d394 3
a396 3
 
static const char* name_file = "/.mlworks_user";
static const char* code_file = "/.mlworks_license";
d453 1
d499 12
d529 12
d664 5
a668 1
  return MLINT(EDITION);
d671 1
a671 1
static int check_edition(char edition) 
d673 1
a673 1
  return ((edition - '0') == (EDITION + 2));
d694 1
a694 1
 * NOT_FOUND        No license found            
d696 1
a696 1
 * OK               License found and ok        
d705 1
d722 1
d740 1
a741 1
      if (check_edition(name[DATE_CHARS])) {
d744 3
a750 3
      } else {
        result = mlw_license_check_result_make(WRONG_EDITION);  
      }
d757 2
d761 1
a839 1
    if (check_edition(check[CHECK_CHARS])) {
a849 3
    } else {
      result = mlw_license_check_result_make(WRONG_EDITION);
    }
d856 1
d873 3
d879 1
@


1.26
log
@[Bug #30382]
Convert date chars to lower case before converting back from
base 36
@
text
@d11 5
d620 5
d822 2
@


1.25
log
@[Bug #50044]
Licence codes should not include 0 or 1
or lower-case letters in input
@
text
@d11 5
d532 2
a533 2
  if (islower(d))
    result = ((int)(d) - (int)('a')) + 10;
@


1.24
log
@[Bug #20076]
Don't terminate running image on network license loss
@
text
@d11 4
d163 1
d362 5
d535 26
d582 1
a582 1
  /* convert back to decimal */
d584 3
a586 3
  day = base_36_to_decimal(day_36);
  month = base_36_to_decimal(month_36);
  year = base_36_to_decimal(year_36);
d612 15
a626 1
  return (edition - '0' == EDITION);
d729 1
a729 1
  char *input, *sha_result;
d735 1
a735 1
     digits. 
d743 7
d755 1
a755 1
  strcat (input, &check[CHECK_CHARS]);
d760 1
d767 1
d773 1
a773 1
  if (!strncmp(check, &sha_result[strlen(sha_result)-CHECK_CHARS], CHECK_CHARS)) {
d806 1
a806 1

@


1.23
log
@[Bug #20072]
check_edition can pass unterminated strings to atoi. Fix this
@
text
@d11 4
d158 1
d271 1
a271 1
static void license_expired(void)
d274 7
a280 8
  message(c_license_error_invalid);
  message_stderr(c_license_error_invalid);
  if (license_failure_hang) {
    while(1)
      sleep(3600);
  } else {
    exit(1);
  }
d317 11
a327 5
  if (use_license_server &&
      ls_update_lic(&ls_data) == 0) {
    have_a_license = 0; 
    if (!initialise(0)) /* Not starting */
      license_expired();
@


1.23.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a10 4
 * Revision 1.23  1997/10/15  14:24:41  jont
 * [Bug #20072]
 * check_edition can pass unterminated strings to atoi. Fix this
 *
@


1.22
log
@[Bug #30282]
Fix type of gethostid to match spec in header files under Solaris 2.6
@
text
@d11 4
d566 2
a567 7
  int i;
  i = atoi(&edition);
  if (i == EDITION) 
    return 1; 
  else 
    return 0;
};
@


1.21
log
@[Bug #30227]
Include mlw_mklic.h instead of register.h
@
text
@d11 4
d169 2
a170 2
extern int gethostid(void);
extern int gethostid(void)
@


1.21.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.21  1997/09/01  15:38:21  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
@


1.21.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.21  1997/09/01  15:38:21  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
@


1.20
log
@[Bug #30223]
Shortening license codes by using base 36 for date elements and
reducing CHECK_CHARS from 10 to 8
@
text
@d11 5
d126 1
a126 1
#include "register.h"
d483 1
a483 1
/* Users are given their license name and a 23-character check string.  The
d487 1
a487 1
 * The first 10 characters are the last 10 characters
d490 1
a490 1
 * rts/src/sha/register.h
@


1.19
log
@[Bug #20072]
Adding edition info (e.g., student, personal) to licensing
@
text
@d11 4
d125 1
d488 14
d505 1
a505 1
 * after these chars.
d511 1
d520 1
a520 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 3)
d522 13
@


1.18
log
@[Bug #20073]
Added datatype license_check_result for more flexible reporting
of license validation/checking results.
@
text
@d11 5
d135 1
d323 6
d473 1
a473 1
/* Users are given their license name and a 22-character check string.  The
d476 1
d478 3
a480 2
 * of the result of hashing the name, installation date and expiry date.
 * CHECK_CHARS and DATE_CHARS are defined in rts/src/sha/register.h
d518 11
d536 1
d577 7
a583 3
      if (check_date(name)) {
        DIAGNOSTIC (1, "License is valid", 0, 0);
        result = mlw_license_check_result_make(OK); 
d585 1
a585 1
        result = mlw_license_check_result_make(EXPIRED); 
d631 5
a635 3
  /* The validation algorithm takes the name, appends the installation
     and expiry dates, calls SHA, and compares the last
     ten digits of the result with the first ten of the check digits. */
d637 1
a637 1
  if (strlen(check) != CHECK_CHARS + (2 * DATE_CHARS)) {
d642 1
a642 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + 1);
d657 1
d664 8
a671 4
    /* check installation date */
     if (check_date(check+CHECK_CHARS)) {
       if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
         result = mlw_license_check_result_make(OK);
d673 1
a673 1
         result = mlw_license_check_result_make(EXPIRED);
d675 3
a677 3
     } else {
       result = mlw_license_check_result_make(INSTALLDATE);
     }
d695 2
@


1.17
log
@[Bug #30223]
Shorten license codes by removing number
@
text
@d11 4
d126 1
d237 5
d276 1
a276 1
    return mlw_option_make_some(mlw_option_make_some(MLTRUE));
d278 1
a278 1
    return mlw_option_make_some(mlw_option_make_none());
a317 2


d464 2
a465 2
 * The first 10 characters are the last 10 characters of the result of 
 * hashing the name, installation date and expiry date.
d505 1
a505 1
/* unit -> bool option option */
d507 4
a510 4
 * NONE             No license found
 * SOME NONE        License found but invalid
 * SOME(SOME true)  License found and ok
 * SOME(SOME false) License found but expired
d522 1
a522 1
    result = mlw_option_make_none();
d529 1
a529 1
    result = mlw_option_make_none();
d552 2
a553 2
	DIAGNOSTIC (1, "License is valid", 0, 0);
	result = mlw_option_make_some(mlw_option_make_some(MLTRUE));
d555 1
a555 1
	result = mlw_option_make_some(mlw_option_make_some(MLFALSE));
d558 1
a558 1
      result = mlw_option_make_some(mlw_option_make_none());
d563 1
a563 1
    result = mlw_option_make_none();
d577 1
a577 1
/* unit -> bool option */
d592 1
a592 1
/* string * string -> bool option */
d601 1
a601 1
  /* The validation algorithm takes the name, appends the installation 
d604 1
d621 4
a624 3
   * NONE => license invalid (check failed)
   * SOME (TRUE) => license OK wrt to installation and expiry dates
   * SOME (FALSE) => installation date passed
d628 1
a628 1
  result = mlw_option_make_none();
d631 10
a640 8
      /* check installation date */
      if (check_date (check+CHECK_CHARS)) {
        if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
          result = mlw_option_make_some(MLTRUE);
        }
      } else {
        result = mlw_option_make_some(MLFALSE);
      }
d642 1
a642 1
    result = mlw_option_make_none();
@


1.16
log
@[Bug #20077]
Adding an install-by date
@
text
@d11 4
d453 1
a453 1
/* Users are given their license name and a 19-character check string.  The
d455 4
a458 4
 * The 3 characters before that are the number of the license given to this
 * license name.  The first 10 characters are the last 10 characters
 * of the result of hashing the name, number and date.
 * CHECK_CHARS, NUMBER_CHARS and DATE_CHARS are defined in sha/register.h
d593 2
a594 2
  /* The validation algorithm takes the name, appends the three digit
     number from the check digits, calls SHA, and compares the last
d596 1
a596 1
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + (2 * DATE_CHARS)) {
d601 1
a601 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + NUMBER_CHARS + 1);
d622 2
a623 2
      if (check_date (check+CHECK_CHARS+NUMBER_CHARS)) {
        if (check_date(&check[CHECK_CHARS+NUMBER_CHARS+DATE_CHARS])) {
@


1.15
log
@[Bug #20077]
License expiry should be to the nearest day
@
text
@d11 4
d120 1
d299 7
d457 4
a460 4
/* check_date checks that the current date is before the expiry date.
 * Its argument is a pointer to the expiry date, which is assumed to 
 * be DATE_CHARS long.  It is not assumed to be null-terminated after
 * these chars.
d462 1
d469 6
a474 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 2)
d580 1
a580 1
/* string * string -> bool */
d591 2
a592 2
     the digits of the result with the first ten of the check digits. */
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + DATE_CHARS) {
d597 1
a597 1
  input = malloc(strlen(name) + DATE_CHARS + NUMBER_CHARS + 1);
d606 19
a624 3
  if ((!strncmp(check, &sha_result[strlen(sha_result)-CHECK_CHARS],
		CHECK_CHARS)) && (check_date(&check[CHECK_CHARS+NUMBER_CHARS]))) {
    result = MLTRUE;
d626 1
a626 1
    result = MLFALSE;
d628 1
d641 1
@


1.14
log
@[Bug #1884]
Distinguish invalid licenses from expired licenses
@
text
@d11 4
d100 1
d438 1
a438 1
 * last 4 characters of this string are the expiry date, in the format mmyy.
d442 1
a443 3
#define CHECK_CHARS 10
#define NUMBER_CHARS 3
#define DATE_CHARS 4
d453 1
a453 1
  int year, month;
d456 1
a456 1
  if (sscanf (date, "%2d%2d", &month, &year) < 2)
d465 3
a467 1
  if (tm->tm_year > year || (tm->tm_year == year && tm->tm_mon >= month)) {
a469 1

d482 1
@


1.14.1.1
log
@branched from 1.14
@
text
@a10 4
 * Revision 1.14  1997/01/07  15:30:47  jont
 * [Bug #1884]
 * Distinguish invalid licenses from expired licenses
 *
@


1.14.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.14.1.1  1997/05/12  10:40:09  hope
 * branched from 1.14
 *
@


1.14.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.14.1.1  1997/05/12  10:40:09  hope
 * branched from 1.14
 *
@


1.14.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.14.1.1  1997/05/12  10:40:09  hope
 * branched from 1.14
 *
@


1.14.1.1.1.2
log
@[Bug #20077]
Merging into 1.1:
License expiry should be to the nearest day
@
text
@a10 3
 * Revision 1.14.1.1.1.1  1997/07/28  18:24:56  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a102 1
#include "register.h"
d440 1
a440 1
 * last 6 characters of this string are the expiry date, in the format ddmmyy.
a443 1
 * CHECK_CHARS, NUMBER_CHARS and DATE_CHARS are defined in sha/register.h
d445 3
d457 1
a457 1
  int year, month, day;
d460 1
a460 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 2)
d469 1
a469 3
  if (tm->tm_year > year || 
      (tm->tm_year == year && tm->tm_mon >= month) ||
      (tm->tm_year == year && tm->tm_mon == (month - 1) && tm->tm_mday > day)) {
d472 1
a484 1

@


1.14.1.1.1.3
log
@[Bug #20077]
Merging into 1.1:
Adding install-by date
@
text
@a10 5
 * Revision 1.14.1.1.1.2  1997/08/08  18:54:34  jkbrook
 * [Bug #20077]
 * Merging into 1.1:
 * License expiry should be to the nearest day
 *
a121 1
static char c_license_error_installdate[] = LICENSE_ERROR_INSTALL;
a299 7
static mlval license_error_installdate(mlval arg)
{
  return ml_string(c_license_error_installdate);
}
 


d451 4
a454 4
/* check_date checks that the current date is before the date argument.
 * Its argument is a pointer to the expiry/install-by date, which is 
 * assumed to be DATE_CHARS long.  It is not assumed to be null-terminated  
 * after these chars.
a455 1

d462 1
a462 6
  /* if sscanf fails here it may mean that we are checking an old license
   * with expiry date of form mmyy.  An appropriate message should
   * be printed (rather than license expired as here).
   */

  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 3)
d568 1
a568 1
/* string * string -> bool option */
d579 2
a580 2
     ten digits of the result with the first ten of the check digits. */
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + (2 * DATE_CHARS)) {
d585 1
a585 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + NUMBER_CHARS + 1);
d594 3
a596 19

  /* Validation results:
   * NONE => license invalid (check failed)
   * SOME (TRUE) => license OK wrt to installation and expiry dates
   * SOME (FALSE) => installation date passed
   */
  
  /* default */
  result = mlw_option_make_none();

  if (!strncmp(check, &sha_result[strlen(sha_result)-CHECK_CHARS], CHECK_CHARS)) {
      /* check installation date */
      if (check_date (check+CHECK_CHARS+NUMBER_CHARS)) {
        if (check_date(&check[CHECK_CHARS+NUMBER_CHARS+DATE_CHARS])) {
          result = mlw_option_make_some(MLTRUE);
        }
      } else {
        result = mlw_option_make_some(MLFALSE);
      }
d598 1
a598 1
    result = mlw_option_make_none();
a599 1

a611 1
  env_function("license error install date", license_error_installdate);
@


1.14.1.1.1.4
log
@[Bug #30223]
Merging into 1.1:
Shorten license codes by removing number
@
text
@a10 5
 * Revision 1.14.1.1.1.3  1997/08/11  08:37:47  jkbrook
 * [Bug #20077]
 * Merging into 1.1:
 * Adding install-by date
 *
d456 1
a456 1
/* Users are given their license name and a 22-character check string.  The
d458 4
a461 4
 * The 6 characters before that are the install-by date, also as ddmmyy.
 * The first 10 characters are the last 10 characters of the result of 
 * hashing the name, installation date and expiry date.
 * CHECK_CHARS and DATE_CHARS are defined in rts/src/sha/register.h
d596 2
a597 2
  /* The validation algorithm takes the name, appends the installation 
     and expiry dates, calls SHA, and compares the last
d599 1
a599 1
  if (strlen(check) != CHECK_CHARS + (2 * DATE_CHARS)) {
d604 1
a604 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + 1);
d625 2
a626 2
      if (check_date (check+CHECK_CHARS)) {
        if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
@


1.14.1.1.1.5
log
@[Bug #20073]
Merging into 1.1:
Adding license_check_result datatype/enum
@
text
@a10 5
 * Revision 1.14.1.1.1.4  1997/08/11  14:17:23  jkbrook
 * [Bug #30223]
 * Merging into 1.1:
 * Shorten license codes by removing number
 *
a129 1

a239 5
static mlval mlw_license_check_result_make (enum license_check_result index)
{
  return MLINT(index);
}

d274 1
a274 1
    return mlw_license_check_result_make(OK);
d276 1
a276 1
    return mlw_license_check_result_make(INVALID);
d316 2
d464 2
a465 2
 * The first 10 characters are the last 10 characters
 * of the result of hashing the name, installation date and expiry date.
d505 1
a505 1
/* unit -> license_check_result */
d507 4
a510 4
 * NOT_FOUND        No license found            
 * INVALID          License found but invalid   
 * OK               License found and ok        
 * EXPIRED          License found but expired   
d522 1
a522 1
    result = mlw_license_check_result_make(INTERNAL_ERROR);
d529 1
a529 1
    result = mlw_license_check_result_make(INTERNAL_ERROR);
d552 2
a553 2
        DIAGNOSTIC (1, "License is valid", 0, 0);
        result = mlw_license_check_result_make(OK); 
d555 1
a555 1
        result = mlw_license_check_result_make(EXPIRED); 
d558 1
a558 1
      result = mlw_license_check_result_make(INVALID);  
d563 1
a563 1
    result = mlw_license_check_result_make(NOT_FOUND);  
d577 1
a577 1
/* unit -> license_check_result */
d592 1
a592 1
/* string * string -> license_check_result */
d601 1
a601 1
  /* The validation algorithm takes the name, appends the installation
a603 1

d620 3
a622 4
   * INVALID => license invalid (check failed)
   * OK => license OK wrt to installation and expiry dates
   * INSTALLDATE => installation date passed
   * EXPIRED => expiry date passed 
d626 1
a626 1
  result = mlw_license_check_result_make(INVALID);
d629 8
a636 10
    /* check installation date */
     if (check_date(check+CHECK_CHARS)) {
       if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
         result = mlw_license_check_result_make(OK);
       } else {
         result = mlw_license_check_result_make(EXPIRED);
       }
     } else {
       result = mlw_license_check_result_make(INSTALLDATE);
     }
d638 1
a638 1
    result = mlw_license_check_result_make(INVALID);
@


1.14.1.1.1.6
log
@[Bug #20072]
Merging into 1.1:
Adding edition info
@
text
@a10 5
 * Revision 1.14.1.1.1.5  1997/08/11  15:33:17  jkbrook
 * [Bug #20073]
 * Merging into 1.1:
 * Adding license_check_result datatype/enum
 *
a138 1
static char c_license_error_version[] = LICENSE_ERROR_VERSION;
a325 6

static mlval license_error_version(mlval arg)
{
  return ml_string(c_license_error_version);
}

d470 1
a470 1
/* Users are given their license name and a 23-character check string.  The
a472 1
 * The 1 character before that encodes the edition.
d474 2
a475 3
 * of the result of hashing the name, edition, installation date and 
 * expiry date. CHECK_CHARS, EDITION_CHARS and DATE_CHARS are defined in 
 * rts/src/sha/register.h
a512 11
static int check_edition(char edition) 
{
  int i;
  i = atoi(&edition);
  if (i == EDITION) 
    return 1; 
  else 
    return 0;
};


a519 1
 * WRONG_EDITION    License is for a different edition
d560 3
a562 7
      if (check_edition(name[DATE_CHARS])) {
        if (check_date(name)) {
          DIAGNOSTIC (1, "License is valid", 0, 0);
          result = mlw_license_check_result_make(OK); 
        } else {
          result = mlw_license_check_result_make(EXPIRED); 
        }
d564 1
a564 1
        result = mlw_license_check_result_make(WRONG_EDITION);  
d610 3
a612 5
  /* The validation algorithm takes the name, appends the edition
     and the installation and expiry dates, calls SHA, and compares the
     last ten digits of the result with the first ten of the check
     digits. 
  */
d614 1
a614 1
  if (strlen(check) != CHECK_CHARS + EDITION_CHARS + (2 * DATE_CHARS)) {
d619 1
a619 1
  input = malloc(strlen(name) + EDITION_CHARS + (2 * DATE_CHARS) + 1);
a633 1
   * WRONG_EDITION => license is for a different edition
d640 4
a643 8
    if (check_edition(check[CHECK_CHARS])) {
      /* check installation date */
       if (check_date(check+CHECK_CHARS+EDITION_CHARS)) {
         if (check_date(&check[CHECK_CHARS+EDITION_CHARS+DATE_CHARS])) {
           result = mlw_license_check_result_make(OK);
         } else {
           result = mlw_license_check_result_make(EXPIRED);
         }
d645 1
a645 1
         result = mlw_license_check_result_make(INSTALLDATE);
d647 3
a649 3
    } else {
      result = mlw_license_check_result_make(WRONG_EDITION);
    }
a666 2
  env_function("license error wrong version", license_error_version);

@


1.14.1.1.1.7
log
@[Bug #30223]
Merging into 1.1:
Shortening codes by using base 36 dates and 8 CHECK_CHARS
@
text
@a10 5
 * Revision 1.14.1.1.1.6  1997/08/11  16:34:17  jkbrook
 * [Bug #20072]
 * Merging into 1.1:
 * Adding edition info
 *
a129 1
#include <ctype.h>
a491 14
/* conversion from base 36 to decimal */

static int base_36_to_decimal (char d)
{
  int result;

  if (islower(d))
    result = ((int)(d) - (int)('a')) + 10;
  else
    result = (int)(d) - (int)('0');

  return result;
};

d495 1
a495 1
 * after these chars.  
a500 1
  char year_36, month_36, day_36;
d509 1
a509 1
  if (sscanf (date, "%1c%1c%1c", &day_36, &month_36, &year_36) < 3)
a510 13

  /* convert back to decimal */

  day = base_36_to_decimal(day_36);
  month = base_36_to_decimal(month_36);
  year = base_36_to_decimal(year_36);

  /* convert back to last-two-digits-of-year format in decimal */
  if (year < 10)
    year += 90;  /* C20 dates */
  else 
    year -= 10;  /* C21 dates */

@


1.14.1.1.1.8
log
@[Bug #30227]
Merging into 1.1:
Include mlw_mklic.h not register.h
@
text
@a10 5
 * Revision 1.14.1.1.1.7  1997/08/11  17:30:08  jkbrook
 * [Bug #30223]
 * Merging into 1.1:
 * Shortening codes by using base 36 dates and 8 CHECK_CHARS
 *
d131 1
a131 1
#include "mlw_mklic.h"
d488 1
a488 1
/* Users are given their license name and a 15-character check string.  The
d492 1
a492 1
 * The first 8 characters are the last 8 characters
d495 1
a495 1
 * rts/src/sha/mlw_mklic.h
@


1.14.1.1.1.8.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 5
 * Revision 1.14.1.1.1.8  1997/09/04  11:25:10  jkbrook
 * [Bug #30227]
 * Merging into 1.1:
 * Include mlw_mklic.h not register.h
 *
@


1.14.1.1.1.8.1.2
log
@[Bug #20072]
Merging from trunk:
check_edition can pass unterminated strings to atoi. Fix this
@
text
@a10 3
 * Revision 1.14.1.1.1.8.1.1  1997/10/07  11:50:43  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
d573 7
a579 2
  return (edition - '0' == EDITION);
}
@


1.13
log
@[Bug #1838]
Add license to contact message
@
text
@d11 4
d24 3
a26 3
 * Fixed bug in conversion of error_string to an ml valuree: sizeof("....") incudeludes
 * the trailing null.  Replaced the existing code wihth a call to ml_string.
 * Also removed the retrailing newline from the error string.
d109 3
a140 7
static char c_license_error_string[] = LICENSE_ERROR_STRING;

static mlval license_error_string(mlval arg)
{
  return ml_string(c_license_error_string);
}

d221 2
a222 2
  message(c_license_error_string);
  message_stderr(c_license_error_string);
a244 2


d252 1
a252 1
    return mlw_option_make_some(MLTRUE);
d254 1
a254 1
    return mlw_option_make_some(MLFALSE);
a256 2


a262 2


a272 2


d279 10
a338 2


a388 2


a398 2


a431 2


a441 1

a469 2


d471 8
a478 1
static int check_license_files (void)
d515 9
a523 3
    if ((strcmp(sha_result,code) == 0) && check_date(name)) {
      DIAGNOSTIC (1, "License is valid", 0, 0);
      result = mlw_option_make_some(MLTRUE);
a524 2
    else
      result = mlw_option_make_some(MLFALSE);
d527 2
a529 2
  else
    result = mlw_option_make_none();
a537 2


d545 1
a545 1
   char *license_setting;
d547 7
a553 8
   license_setting = getenv("MLWORKS_LICENSE");
   if (license_setting != NULL && (strcmp(license_setting,"server") == 0)) {
     use_license_server = 1;
     return license_start();
   }
   else {
     return check_license_files();
   }
a555 2


d584 1
a584 2
		CHECK_CHARS)) &&
      check_date (&check[CHECK_CHARS+NUMBER_CHARS]))
d586 1
a586 1
  else
d588 1
a588 1

a593 2


d599 2
a600 1
  env_function("license error string", license_error_string);
@


1.12
log
@[Bug #1874]
Add a #include <unistd.h> to pick up the prototype for
gethostid amongst other things.
@
text
@d11 5
d134 1
a134 7
static char c_license_error_string[] = 
  "Your license is invalid.\n"
  "Contact MLWorks customer support:\n"
  "   North and South America, Japan:\n"
  "     mail mlworks-keys@@harlequin.com\n"
  "   UK, Europe, Australasia, Africa, Asia:\n"
  "     mail mlworks-keys@@harlequin.co.uk";
@


1.11
log
@Made the registration scheme be the default.
@
text
@d11 3
d72 1
@


1.11.3.1
log
@branched from 1.11
@
text
@a10 3
 * Revision 1.11  1996/12/10  16:37:52  daveb
 * Made the registration scheme be the default.
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a10 3
 * Revision 1.11  1996/12/10  16:37:52  daveb
 * Made the registration scheme be the default.
 *
@


1.11.2.1.1.1
log
@branched from 1.11.2.1
@
text
@a10 3
 * Revision 1.11.2.1  1996/12/17  17:53:12  hope
 * branched from 1.11
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a10 3
 * Revision 1.11  1996/12/10  16:37:52  daveb
 * Made the registration scheme be the default.
 *
@


1.10
log
@Fixed bug in conversion of error_string to an ml valuree: sizeof("....") incudeludes
the trailing null.  Replaced the existing code wihth a call to ml_string.
Also removed the retrailing newline from the error string.
@
text
@d11 5
d143 1
a143 1
static int use_license_server = 1;
d545 3
a547 2
   if (license_setting != NULL && (strcmp(license_setting,"keyfile") == 0)) {
     return check_license_files();
d550 1
a550 2
     use_license_server = 1;
     return license_start();
d605 1
a605 1
  use_license_server = 1;   /* Default use license server */
@


1.10.2.1
log
@branched from 1.10
@
text
@a10 5
 * Revision 1.10  1996/11/13  13:51:28  daveb
 * Fixed bug in conversion of error_string to an ml valuree: sizeof("....") incudeludes
 * the trailing null.  Replaced the existing code wihth a call to ml_string.
 * Also removed the retrailing newline from the error string.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a10 5
 * Revision 1.10  1996/11/13  13:51:28  daveb
 * Fixed bug in conversion of error_string to an ml valuree: sizeof("....") incudeludes
 * the trailing null.  Replaced the existing code wihth a call to ml_string.
 * Also removed the retrailing newline from the error string.
 *
@


1.10.1.1.1.1
log
@branched from 1.10.1.1
@
text
@a10 3
 * Revision 1.10.1.1  1996/11/14  12:56:37  hope
 * branched from 1.10
 *
@


1.9
log
@Added an expiration date.
@
text
@d11 3
d126 1
a126 1
  "     mail mlworks-keys@@harlequin.co.uk\n";
d130 1
a130 4
  int len = sizeof(c_license_error_string);
  mlval result = allocate_string(len+1);
  memcpy(CSTRING(result),c_license_error_string,len+1);
  return result;
@


1.8
log
@Updated expiry message.
@
text
@d11 3
d80 1
d430 41
d509 1
a509 1
    if (strcmp(sha_result,code) == 0) {
a550 2
#define CHECK_BITS 10

d564 1
a564 1
  if (strlen(check) != CHECK_BITS+3) {
d569 1
a569 1
  input = malloc(strlen(name)+4);
d573 2
a574 2
  strcpy (input,name);
  strcat (input,&check[CHECK_BITS]);
d578 3
a580 1
  if (!strncmp(check,&sha_result[strlen(sha_result)-CHECK_BITS],CHECK_BITS))
@


1.7
log
@Fixed a typo in the previous change, which won't compile without it.
@
text
@d11 3
d116 4
a119 2
  "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
  "   telephone:        +44 1223 872522";
@


1.6
log
@Added support for registration-style licensing.
@
text
@d11 3
d469 1
a469 1
    result = mlw_option_make_none;
@


1.5
log
@Try to reacquire license if lost/timed out.
This should allow processes to be stopped and restarted
@
text
@d11 4
d57 1
d65 1
d107 2
a108 2
static char license_error_string[] = 
  "Your license has expired or is unavailable.\n"
d113 8
d126 1
d201 2
a202 2
  message(license_error_string);
  message_stderr(license_error_string);
d211 1
a211 1
static void initialise(int starting)
d220 1
d222 1
a222 1
    license_expired();
d225 3
a227 1
static mlval license_start(mlval arg)
d233 4
a236 2
  initialise(1); /* Starting */
  return MLUNIT;
d239 2
d247 2
d251 2
a252 1
  if (ls_update_lic(&ls_data) == 0) {
d254 2
a255 1
    initialise(0); /* Not starting */
d259 280
d541 5
a545 1
  env_function("start license", license_start);
d547 1
@


1.4
log
@[Bug #1693]
Don't hang on license failure when running in batch mode
@
text
@d11 4
d196 1
a196 1
static mlval license_start(mlval arg)
a198 5

  init_lsdata(&ls_data, HQNLS_VERSION,
	      PUBLISHER_NAME,
	      PRODUCT_NAME,
	      VERSION_STRING);
d203 2
a204 1
    signal_license_timer(ls_data.UpPeriod);
d207 9
d227 4
a230 2
  if (ls_update_lic(&ls_data) == 0)
    license_expired();
@


1.3
log
@[Bug #1685]
Change printf into DIAGNOSTIC
@
text
@d11 4
d68 2
d184 6
a189 2
  while(1)
    sleep(3600);
d226 1
@


1.2
log
@new unit
Moving from MLWorks_License_dev to trunk
@
text
@d11 4
d191 1
a191 1
  printf("License started with result %d\n", result);
@


1.1
log
@new file on MLWorks_License_dev
@
text
@d1 212
@


1.1.1.1
log
@new unit
No longer platform specific, so moved to a common place
@
text
@a0 180
/*  === LICENSING ===
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Uses the Harlequin License Server, and a timer interrupt.
 *
 * 
 *  $Log: src:OS:Solaris:license.c,v $
 * Revision 1.2.2.4  1996/10/14  16:28:06  nickb
 * Improve error behaviour.
 *
 * Revision 1.2.2.3  1996/10/09  12:45:33  nickb
 * Call timer function.
 *
 * Revision 1.2.2.2  1996/10/08  16:15:16  jont
 * Start adding stuff to use HQN_LS
 *
 * Revision 1.2.2.1  1996/10/07  16:13:29  hope
 * branched from 1.2
 *
 * Revision 1.2  1995/02/23  15:41:38  nickb
 * Change assignment of pid.
 *
 * Revision 1.1  1994/07/08  10:43:07  nickh
 * new file
 *
 *
 */

#include "ansi.h"
#include "syscalls.h"
#include "utils.h"
#include "diagnostic.h"
#include "environment.h"
#include "license.h"
#include "signals.h"
#include "utils.h"
#include "values.h"
#include "x.h"

#include "hqn_ls.h"

#include <errno.h>
#include <sys/errno.h>
#include <stdlib.h>

#define N_DATA_VALUES 4
#define N_CHALLENGES 4
#ifndef NULL
#define NULL 0
#endif

static char license_error_string[] = 
  "Your license has expired or is unavailable.\n"
  "Contact MLWorks customer support:\n"
  "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
  "   telephone:        +44 1223 872522";

#define PUBLISHER_NAME	"Harlequin Limited"
#define PRODUCT_NAME	"MLWorks"
#define VERSION_STRING	"Version 1.0"

static int have_a_license = 0;

/* hqn_ms output follows: */

static hls_uint Chalvals[N_CHALLENGES] = {
    0x611fcd8d,
    0x2e9ea289,
    0x31bf9fa,
    0x412ac807,
};

static hls_uint Signature1[ 16 ] = {
0xb7dcdb64, 0xe6ee81c8, 0x5489902c, 0x72cb5dc7,
0xd41062cd, 0x86bdf55e, 0xa77ec367, 0xe3edf0e8,
0x20e4d6f8, 0x959150a4, 0x1df8e445, 0x859c61e,
0xf80ee071, 0xf5047a7c, 0x6df801dc, 0x107af490,
};

static hls_uint Signature2[ 16 ] = {
0x1e50723a, 0x4a2b933e, 0x435ad8dd, 0x8c16e421,
0x859faeea, 0x9c001979, 0x139dbe51, 0x5e903609,
0xd4215649, 0x6af17a2b, 0x1f262681, 0xd808487c,
0x14f49577, 0x5a69cb01, 0x69df87bd, 0xafd09f74,
};

static hls_uint Signature3[ 16 ] = {
0xaf2a0a82, 0x2da69ac5, 0x4069407c, 0x4f6cb819,
0xb7a6461a, 0xb4721837, 0x5f8a5d00, 0x2de5583d,
0x4d0e98f, 0xf1e8d337, 0x2a814ae6, 0xdd63e341,
0xa69fc3c5, 0x50003554, 0x955e50cb, 0xae339dd9,
};

static hls_uint Signature4[ 16 ] = {
0x941e6469, 0xdb33f41f, 0x3c83612d, 0x1b672b08,
0x2936e509, 0x80506043, 0x943702da, 0xc8566478,
0xc0fd1b69, 0xa1e75f0c, 0x801626b7, 0x3a11c941,
0x3e1b293f, 0xc50ee41b, 0xb108ccfd, 0x9b7fe4e1,
};

/* the following made static (it is not in the hqn_ms output) */

static hls_uint *Signatures[ N_CHALLENGES ] = {
    Signature1,
    Signature2,
    Signature3,
    Signature4,
};

/* hqn_ms output ends */

static hls_int Databuf[ N_DATA_VALUES + 1];

static LSdata ls_data;

static void init_lsdata(LSdata *ldata,
			const char *LicenseSystem,
			const char *PublisherName,
			const char *ProductName,
			const char *VersionString)
{
  /* casts necessary because the struct defn doesn't have const qualifiers */
  ldata->LicenseSystem = (char*)LicenseSystem;
  ldata->PublisherName = (char*)PublisherName;
  ldata->ProductName   = (char*)ProductName;
  ldata->VersionString = (char*)VersionString;
  ldata->Nchals = N_CHALLENGES;
  ldata->Chalvals = Chalvals;
  ldata->Ndata = N_DATA_VALUES;
  ldata->Data = Databuf;
  ldata->Sig_Index = Signatures;
}

static void license_expired(void)
{
  x_reveal_podium();
  message(license_error_string);
  message_stderr(license_error_string);
  while(1)
    sleep(3600);
}

static mlval license_start(mlval arg)
{
  hls_int result;

  init_lsdata(&ls_data, HQNLS_VERSION,
	      PUBLISHER_NAME,
	      PRODUCT_NAME,
	      VERSION_STRING);
  result = ls_initialise(&ls_data);
  printf("License started with result %d\n", result);
  if (ls_get_license(&ls_data)) {
    have_a_license = 1;
    signal_license_timer(ls_data.UpPeriod);
  } else
    license_expired();
  return MLUNIT;
}

extern void license_release(void)
{
  if (have_a_license)
    ls_release_lic(&ls_data);
}

void refresh_license(void)
{
  if (ls_update_lic(&ls_data) == 0)
    license_expired();
}

void license_init(void)
{
  env_function("start license", license_start);
  have_a_license = 0;
}
@
