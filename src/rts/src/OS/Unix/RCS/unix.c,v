head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.1
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.27
	MLWorks_20b2c2_1998_06_19:1.26
	MLWorks_20b2_Windows_1998_06_12:1.26
	MLWorks_20b1c1_1998_05_07:1.26
	MLWorks_20b0_1998_04_07:1.26
	MLWorks_20b0_1998_03_20:1.26
	MLWorks_20m2_1998_02_16:1.25
	MLWorks_MM_adapt:1.24.3
	MLWorks_20m1_1997_10_23:1.24
	MLWorks_11r1:1.21.1.1.1.1.1
	MLWorks_workspace_97:1.24.2
	MLWorks_dt_wizard:1.24.1
	MLWorks_11c0_1997_09_09:1.21.1.1.1.1
	MLWorks_10r3:1.21.1.1.3
	MLWorks_10r2_551:1.21.1.1.2
	MLWorks_11:1.21.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.21.1.1
	MLWorks_20m0_1997_06_20:1.22
	MLWorks_1_0_r2c2_1997_06_14:1.21.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.21.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.21.1
	MLWorks_BugFix_1997_04_24:1.21
	MLWorks_1_0_r2_Win32_1997_04_11:1.21
	MLWorks_1_0_r2_Unix_1997_04_04:1.21
	MM_ML_release_korma_1997_04_01:1.21
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.19.7.1.1
	MLWorks_gui_1996_12_18:1.19.8
	MLWorks_1_0_Win32_1996_12_17:1.19.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.4.1
	JFHrts:1.19.6
	MLWorks_1_0_Irix_1996_11_28:1.19.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.5
	MLWorks_1_0_Unix_1996_11_14:1.19.4
	MLWorks_Open_Beta2_1996_10_11:1.19.3
	MLWorks_License_dev:1.19.2
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.12
	MLWorks_Beta_1996_06_07:1.7
	MLWorks_Beta_1996_06_06:1.7
	MLWorks_Beta_1996_06_05:1.7
	MLWorks_Beta_1996_06_03:1.7
	MLWorks_Beta_1996_05_31:1.7
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.37
date	99.03.22.17.04.12;	author mitchell;	state Exp;
branches
	1.37.1.1;
next	1.36;

1.36
date	99.03.20.16.19.16;	author daveb;	state Exp;
branches;
next	1.35;

1.35
date	99.03.17.12.10.48;	author daveb;	state Exp;
branches;
next	1.34;

1.34
date	99.01.25.17.58.26;	author johnh;	state Exp;
branches;
next	1.33;

1.33
date	98.09.30.15.06.54;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	98.09.17.14.30.21;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	98.09.16.15.15.45;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	98.09.16.11.16.28;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	98.08.18.11.40.21;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	98.08.17.11.07.27;	author jont;	state Exp;
branches;
next	1.27;

1.27
date	98.07.02.14.55.17;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	98.02.23.18.48.50;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	97.11.09.17.53.59;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	97.08.19.15.14.01;	author nickb;	state Exp;
branches
	1.24.1.1
	1.24.2.1
	1.24.3.1;
next	1.23;

1.23
date	97.06.27.13.18.45;	author stephenb;	state Exp;
branches;
next	1.22;

1.22
date	97.05.22.08.44.06;	author johnh;	state Exp;
branches;
next	1.21;

1.21
date	97.03.21.17.23.20;	author andreww;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	97.03.18.11.00.58;	author andreww;	state Exp;
branches;
next	1.19;

1.19
date	96.08.06.13.15.54;	author stephenb;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1
	1.19.5.1
	1.19.6.1
	1.19.7.1
	1.19.8.1;
next	1.18;

1.18
date	96.08.06.12.42.33;	author stephenb;	state Exp;
branches;
next	1.17;

1.17
date	96.07.17.11.48.47;	author andreww;	state Exp;
branches;
next	1.16;

1.16
date	96.07.15.09.12.39;	author andreww;	state Exp;
branches;
next	1.15;

1.15
date	96.07.10.09.56.02;	author stephenb;	state Exp;
branches;
next	1.14;

1.14
date	96.07.04.09.32.37;	author stephenb;	state Exp;
branches;
next	1.13;

1.13
date	96.07.04.09.19.55;	author stephenb;	state Exp;
branches;
next	1.12;

1.12
date	96.06.19.09.45.23;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.06.18.15.51.59;	author stephenb;	state Exp;
branches;
next	1.10;

1.10
date	96.06.10.15.35.41;	author stephenb;	state Exp;
branches;
next	1.9;

1.9
date	96.06.10.13.03.31;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	96.06.10.10.23.11;	author andreww;	state Exp;
branches;
next	1.7;

1.7
date	96.05.30.08.41.55;	author stephenb;	state Exp;
branches;
next	1.6;

1.6
date	96.05.28.11.53.08;	author stephenb;	state Exp;
branches;
next	1.5;

1.5
date	96.05.16.14.37.17;	author stephenb;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.11.36.37;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.04.17.10.04.21;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.04.01.11.14.19;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.02.20.10.19.27;	author stephenb;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.25.17;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.10.07.16.15.39;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.10.17.11.35.05;	author hope;	state Exp;
branches;
next	;

1.19.4.1
date	96.11.14.13.00.45;	author hope;	state Exp;
branches
	1.19.4.1.1.1;
next	;

1.19.4.1.1.1
date	96.11.28.15.10.49;	author hope;	state Exp;
branches;
next	;

1.19.5.1
date	96.11.22.18.18.35;	author hope;	state Exp;
branches;
next	;

1.19.6.1
date	96.12.17.10.05.19;	author hope;	state Exp;
branches;
next	;

1.19.7.1
date	96.12.17.17.56.53;	author hope;	state Exp;
branches
	1.19.7.1.1.1;
next	;

1.19.7.1.1.1
date	97.02.24.11.48.33;	author hope;	state Exp;
branches;
next	;

1.19.8.1
date	96.12.18.09.51.33;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	97.05.12.10.45.15;	author hope;	state Exp;
branches
	1.21.1.1.1.1
	1.21.1.1.2.1
	1.21.1.1.3.1;
next	;

1.21.1.1.1.1
date	97.07.28.18.28.10;	author daveb;	state Exp;
branches
	1.21.1.1.1.1.1.1;
next	;

1.21.1.1.1.1.1.1
date	97.10.07.11.54.04;	author jkbrook;	state Exp;
branches;
next	;

1.21.1.1.2.1
date	97.09.08.17.21.08;	author daveb;	state Exp;
branches;
next	;

1.21.1.1.3.1
date	97.09.09.14.17.14;	author daveb;	state Exp;
branches;
next	;

1.24.1.1
date	97.09.10.19.35.56;	author brucem;	state Exp;
branches;
next	;

1.24.2.1
date	97.09.11.21.04.22;	author daveb;	state Exp;
branches;
next	;

1.24.3.1
date	97.10.31.13.47.27;	author nickb;	state Exp;
branches;
next	;

1.37.1.1
date	99.04.01.18.03.13;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This used to be src/rts/src/OS/common/unix.c
@


1.37
log
@[Bug #30286]
Support for the Unix structure
@
text
@/* Copyright (C) 1996 Harlequin Ltd
 *
 * An interface to UNIX.  This is is not a full interface to all the system
 * calls, let alone all the libraries.  It is just an interface to those
 * routines which at some point have been needed on the ML side.
 *
 * This is a synthesis of and replaces OS/{Irix,Linux,Solaris,SunOS}/unix.c
 *
 * Since all the systems don't support the same facilities, this file contains
 * the default implementation for each feature.  If the feature is not
 * supported on all systems, then the default implementation is wrapped in
 *
 *  #ifndef MLW_OVERRIDE_<FEATURE>
 *  ...
 *  #endif
 *
 * so that it can be replaced by a version defined in $OS/unixlocal.c
 * which must exist for each Unix OS supported.
 *
 * For historic reasons most of the functions are prefixed by unix_, but
 * there is a rolling program to change the prefix to mlw_ to avoid any
 * namespace collision problems.  Note that the change isn't strictly
 * necessary for static functions/values but for consistency these should
 * have the mlw_ prefix too.
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Unix:unix.c,v $
 * Revision 1.36  1999/03/20  16:19:16  daveb
 * [Bug #190523]
 * OS.Process.status is now a Word32.word.
 *
 * Revision 1.35  1999/03/17  12:10:48  daveb
 * [Bug #190521]
 * Type of OS.FileSys.readDir has changed.
 *
 * Revision 1.34  1999/01/25  17:58:26  johnh
 * Make changes for the Unix structure.
 *
 * Revision 1.33  1998/09/30  15:06:54  jont
 * [Bug #70108]
 * Ensure syscalls.h included before time.h because of Red Hat 5 stupidities
 *
 * Revision 1.32  1998/09/17  14:30:21  jont
 * [Bug #30108]
 * Move dummy definitions os asm_trampoline from unix.c into os.c
 *
 * Revision 1.31  1998/09/16  15:15:45  jont
 * [Bug #70174]
 * Modify type of parse_command_line to fix compiler warnings
 *
 * Revision 1.30  1998/09/16  11:16:28  jont
 * [Bug #30108]
 * Add parse_command_line
 *
 * Revision 1.29  1998/08/18  11:40:21  jont
 * [Bug #70153]
 * Add prototype for system_validate_ml_address
 *
 * Revision 1.28  1998/08/17  11:07:27  jont
 * [Bug #70153]
 * Add system_validate_ml_address
 *
 * Revision 1.27  1998/07/02  14:55:17  jont
 * [Bug #70132]
 * Add signals_finalise
 *
 * Revision 1.26  1998/02/23  18:48:50  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.25  1997/11/09  17:53:59  jont
 * [Bug #30089]
 * Modify unix_rusage to return ru_utime and ru_stime as basis times
 *
 * Revision 1.24  1997/08/19  15:14:01  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.23  1997/06/27  13:18:45  stephenb
 * [Bug #30029]
 * make mlw_raise_syserr an extern so it can be used elsewhere.
 *
 * Revision 1.22  1997/05/22  08:44:06  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
 * Revision 1.21  1997/03/21  17:23:20  andreww
 * [Bug #1968]
 * make stdIn, stdOut and stdErr refs.
 *
 * Revision 1.20  1997/03/18  11:00:58  andreww
 * [Bug #1431]
 * Changing call name of POSIX.Error.errorMsg/Name to make it
 * compatible with win32 implementation.
 *
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
 * Revision 1.18  1996/08/06  12:42:33  stephenb
 * Correct some of the #include comments.
 *
 * Revision 1.17  1996/07/17  11:48:47  andreww
 * Altering the order of arguments given to the lseek system call.
 *
 * Revision 1.16  1996/07/15  09:12:39  andreww
 * Removing system-specific information from the names of the calls
 * to read, write, seek and close.
 *
 * Revision 1.15  1996/07/10  09:56:02  stephenb
 * remove unnecessary declare/retract roots, particularly
 * those surrounding any use of mlw_option_make_some.
 *
 * Revision 1.14  1996/07/04  09:32:37  stephenb
 * Aargh!  Why o why did I check in the previous version before
 * compiling it first.  I missed out a ")" :-<
 *
 * Revision 1.13  1996/07/04  09:19:55  stephenb
 * Add some missing declare/retract_root calls.
 * Specifically to mlw_posix_file_sys_return_stat.
 *
 * Revision 1.12  1996/06/19  09:45:23  stephenb
 * Ensure that rewinddir raises OS.SysErr when applied to a closed dirstream.
 *
 * Revision 1.11  1996/06/18  15:51:59  stephenb
 * Make stat/lstat raise an exception when given "".
 * Strictly speaking the test is only needed under SunOS, all the other
 * Unix varieties do the test, but for the sake of a test it isn't
 * worth creating a SunOS specific version of these functions.
 *
 * Revision 1.10  1996/06/10  15:35:41  stephenb
 * Fix creat and umask calls so as to remove signed/unsigned warnings.
 *
 * Revision 1.9  1996/06/10  13:03:31  stephenb
 * Implement POSIX.FileSys.{openf,creatf,creat} in order to support
 * basis IO.
 *
 * Revision 1.8  1996/06/10  10:23:11  andreww
 * expose unix IO constants to ML system.
 *
 * Revision 1.7  1996/05/30  08:41:55  stephenb
 * unix_init: add a call to mlw_timer_init.
 *
 * Revision 1.6  1996/05/28  11:53:08  stephenb
 * Add support for OS.errorName and OS.syserror
 *
 * Revision 1.5  1996/05/16  14:37:17  stephenb
 * Add support for OS.errorMsg
 * Also finish of the implementation of OS.FileSys.
 *
 * Revision 1.4  1996/05/07  11:36:37  stephenb
 * Add support for OS.IO
 *
 * Revision 1.3  1996/04/17  10:04:21  stephenb
 * Add various routines to support OS_PROCESS as defined in the latest basis.
 *
 * Revision 1.2  1996/04/01  11:14:19  stephenb
 * Rationalise exception handling so that all routines that raise
 * exceptions raise the same one -- this being one that is compatible
 * with OS.SysErr as defined in the latest basis.
 *
 * Revision 1.1  1996/02/20  10:19:27  stephenb
 * new unit
 * This used to be src/rts/src/OS/common/unix.c
 *
 * Revision 1.4  1996/02/19  15:48:09  nickb
 * unix_environment memoizes the Unix environment. This is not
 * necessary: we can do it in ML if we decide it's a good idea.
 *
 * Revision 1.3  1996/02/16  12:51:13  nickb
 * Change to declare_global().
 *
 * Revision 1.2  1996/01/30  17:27:29  stephenb
 * Add <sys/socket.h>
 *
 * Revision 1.1  1996/01/30  14:51:45  stephenb
 * new unit
 * This is a synthesis of and replaces all the unix.c files for each
 * variety of Unix supported by MLWorks.  It presents an idealised
 * interface to Unix.  It is supported in this by the unixlocal.[ch]
 * files in each Unix dialects directories.
 *
 */

#include "unix.h"
#include "mltypes.h"
#include "values.h"		/* FIELD, MLTAIL, cons ... etc.*/
#include "allocator.h"		/* allocate_record, ml_string */
#include "gc.h"
#include "exceptions.h"		/* exn_raise_syserr */
#include "utils.h"		/* alloc */
#include "environment.h"	/* env_function ... etc. */
#include "global.h"		/* declare_global */
#include "mlw_syserr.h"		/* mlw_raise_syserr */
#include "time_date.h"          /* mlw_time_make */
#include "signals.h"		/* signals_finalise */
#include <assert.h>		/* assert */
#include <errno.h>		/* errno */
#include <string.h>
#include <stdlib.h>
#include <unistd.h>		/* read, write, readlink, ... etc. */
#include <sys/param.h>		/* MAXPATHLEN, realpath */
#include <sys/types.h>		/* mode_t ... */
#include <sys/wait.h>		
#include <sys/stat.h>		/* mkdir, chmod, umask, S_ISDIR, ... */
#include <dirent.h>		/* opendir, ... etc. */
#include <fcntl.h>		/* open, creat, O_RDONLY, ... */
#include <sys/ioctl.h>		/* FIONREAD */
#include <pwd.h>		/* struct passwd */
#include <utime.h>		/* utime, utimbuf */

#include "syscalls.h"
#ifndef MLW_OVERRIDE_RUSAGE
#include "mltime.h"		/* ml_time */
#include <sys/time.h>
#include <sys/resource.h>
#endif

#include <sys/socket.h>
#include <sys/un.h>
#include "unixlocal.h"
#include "time_date.h"		/* mlw_time_make,mlw_time_sec,mlw_time_usec */
#include "time_date_init.h"	/* mlw_time_date_init */
#include "mlw_timer_init.h"	/* mlw_timer_init */
#include "os_io_poll.h"		/* mlw_os_poll_io_init */
#include "os_errors.h"		/* mlw_os_error_name, mlw_os_syserror */
#include "os.h"			/* Prototype for system_validate_ml_address */

extern char **environ;		/* why isn't this in a standard header file? */

static int mlw_path_max;

static mlval unix_exn_ref_would_block;

/*
 * The following are only here until the standard Socket library is defined
 * and then they will be replaced by that.
 */
static mlval unix_af_unix;
static mlval unix_af_inet;
static mlval unix_sock_stream;
static mlval unix_sock_dgram;

/*
 * The following are deprecated.  They are here to support the old style
 * unix_open call which has now been superceded by various POSIX.FileSys
 * routines.
 */

static mlval unix_o_rdonly;
static mlval unix_o_wronly;
static mlval unix_o_creat;
static mlval unix_o_append;
static mlval unix_o_trunc;

/*
 * These are not initialised here so that they will end up in the BSS
 * rather than the data section and so save a small amount of space
 * at the expense of a miniscule amount of initialisation time.
 */
static mlval mlw_posix_file_sys_o_append;
static mlval mlw_posix_file_sys_o_excl;
static mlval mlw_posix_file_sys_o_noctty;
static mlval mlw_posix_file_sys_o_nonblock;
static mlval mlw_posix_file_sys_o_sync;
static mlval mlw_posix_file_sys_o_trunc;

#define SOCKADDR_BUFFER		sizeof(struct sockaddr_un)


/* The box and unbox functions duplicate code in x.c,
 * and probably win32.c and windows.c (although
 * Windows uses a different C compiler.
 */

static inline mlval box(unsigned long int x)
{
  mlval b = allocate_string(sizeof(x));

  memcpy(CSTRING(b), (char *)&x, sizeof(x));

  return(b);
}

static inline unsigned long int unbox(mlval b)
{
  unsigned long int x;

  memcpy((char *)&x, CSTRING(b), sizeof(x));

  return(x);
}

/*
 * OS.errorMsg : syserror -> string
 *
 */
static mlval mlw_os_error_msg(mlval arg)
{
  int error_code= CINT(arg);
  char const * error_message= strerror(error_code);
  return ml_string(error_message);
}

void mlw_raise_syserr(int i)
{
  exn_raise_syserr(ml_string(strerror(i)), i);
}

static mlval unix_environment(mlval unit)
{
  mlval result = MLNIL;
  int i;

  declare_root(&result, 0);

  for(i=0; environ[i] != NULL; ++i) {
    mlval poo = ml_string(environ[i]);
    /* Do not inline this function call */
    /* C is too stupid to realise that it should evaluate parameters */
    /* before building the arguments to a function */
    result = cons(poo, result);
  }
  retract_root(&result);
  return result;
}

#ifndef MLW_OVERRIDE_RUSAGE
static mlval unix_rusage(mlval unit)
{
  struct rusage ru;
  mlval utime, stime, result;

  if(getrusage(RUSAGE_SELF, &ru))
    mlw_raise_syserr(errno);

  utime = mlw_time_make(ru.ru_utime.tv_sec, ru.ru_utime.tv_usec);
  declare_root(&utime, 0);
  stime = mlw_time_make(ru.ru_stime.tv_sec, ru.ru_stime.tv_usec);
  declare_root(&stime, 0);

  result = allocate_record(16);
  retract_root(&utime);
  retract_root(&stime);

  /* Lexical ordering for fields -- the result is a record with name fields.
   *
   * idrss	integral resident set size
   * inblock	block input operations
   * isrss	currently 0
   * ixrss	currently 0
   * majflt	page faults requiring physical I/O
   * maxrss	maximum resident set size
   * minflt	page faults not requiring physical I/O
   * msgrcv	messages received
   * msgsnd	messages sent
   * nivcsw	involuntary context switches
   * nsignals	signals received
   * nswap	swaps voluntary
   * nvcsw	context switches
   * oublock	block output operations
   * stime	system time used
   * utime	user time used
   */

  FIELD(result,  0) = MLINT(ru.ru_idrss);
  FIELD(result,  1) = MLINT(ru.ru_inblock);
  FIELD(result,  2) = MLINT(ru.ru_isrss);
  FIELD(result,  3) = MLINT(ru.ru_ixrss);
  FIELD(result,  4) = MLINT(ru.ru_majflt);
  FIELD(result,  5) = MLINT(ru.ru_maxrss);
  FIELD(result,  6) = MLINT(ru.ru_minflt);
  FIELD(result,  7) = MLINT(ru.ru_msgrcv);
  FIELD(result,  8) = MLINT(ru.ru_msgsnd);
  FIELD(result,  9) = MLINT(ru.ru_nivcsw);
  FIELD(result, 10) = MLINT(ru.ru_nsignals);
  FIELD(result, 11) = MLINT(ru.ru_nswap);
  FIELD(result, 12) = MLINT(ru.ru_nvcsw);
  FIELD(result, 13) = MLINT(ru.ru_oublock);
  FIELD(result, 14) = stime;
  FIELD(result, 15) = utime;

  return(result);
}
#endif

/*
 * Deprecated.  Use on of POSIX.FileSys.{openf,creatf,creat} instead.
 */
static mlval unix_open(mlval arg)
{
  int fd = open(CSTRING(FIELD(arg, 0)),
		CINT(FIELD(arg, 1)),
		CINT(FIELD(arg, 2)));

  if (fd == -1)
    mlw_raise_syserr(errno);

  return MLINT(fd);
}

static mlval unix_socket(mlval arg)
{
  int fd = socket(CINT(FIELD(arg, 0)),
		  CINT(FIELD(arg, 1)),
		  CINT(FIELD(arg, 2)));
  if (fd == -1)
    mlw_raise_syserr(errno);
  return MLINT(fd);
}

static mlval unix_bind(mlval arg)
{
  size_t length;
  struct sockaddr_un un;

  length = strlen(CSTRING(FIELD(arg, 1)));
  if (length > sizeof(un.sun_path))
    mlw_raise_syserr(EINVAL);

  un.sun_family = AF_UNIX;
  memcpy(&un.sun_path, CSTRING(FIELD(arg, 1)), length);

  if (bind(CINT(FIELD(arg, 0)),
	   (struct sockaddr *)&un,
	   (int) (sizeof(un.sun_family)+length)) == -1)
    mlw_raise_syserr(errno);

  return MLUNIT;
}

static mlval unix_connect(mlval arg)
{
  size_t length;
  struct sockaddr_un un;

  length = strlen(CSTRING(FIELD(arg, 1)));
  if (length > sizeof(un.sun_path))
    mlw_raise_syserr(EINVAL);

  un.sun_family = AF_UNIX;
  memcpy(&un.sun_path, CSTRING(FIELD(arg, 1)), length);

  if (connect(CINT(FIELD(arg, 0)),
	      (struct sockaddr *)&un,
	      (int)(sizeof(un.sun_family)+length)) == -1)
    mlw_raise_syserr(errno);

  return MLUNIT;
}

static mlval unix_getsockname(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval result;
  size_t length;

  if (getsockname(CINT(arg), sa, &namelen))
    mlw_raise_syserr(errno);

  if (sa->sa_family != AF_UNIX)
    mlw_raise_syserr(EINVAL);

  length = namelen - sizeof(un->sun_family);
  result = allocate_string(length+1);
  memcpy(CSTRING(result), un->sun_path, length);
  CSTRING(result)[length] = '\0';

  return result;
}

static mlval unix_getpeername(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval result;
  size_t length;

  if (getpeername(CINT(arg), sa, &namelen))
    mlw_raise_syserr(errno);

  if (sa->sa_family != AF_UNIX)
    mlw_raise_syserr(EINVAL);

  length = namelen - sizeof(un->sun_family);
  result = allocate_string(length+1);
  memcpy(CSTRING(result), un->sun_path, length);
  CSTRING(result)[length] = '\0';

  return result;
}

static mlval unix_accept(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER, s;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval ml_sockaddr, result;
  size_t length;

  s= accept(CINT(arg), sa, &namelen);

  if (s == -1)
    mlw_raise_syserr(errno);

  if (sa->sa_family != AF_UNIX)
    mlw_raise_syserr(EINVAL);

  length = namelen - sizeof(un->sun_family);
  ml_sockaddr = allocate_string(length+1);
  memcpy(CSTRING(ml_sockaddr), un->sun_path, length);
  CSTRING(ml_sockaddr)[length] = '\0';
  declare_root(&ml_sockaddr, 0);
  result = allocate_record(2);
  FIELD(result, 0) = MLINT(s);
  FIELD(result, 1) = ml_sockaddr;
  retract_root(&ml_sockaddr);

  return result;
}

static mlval unix_listen(mlval arg)
{
  if (listen(CINT(FIELD(arg, 0)), CINT(FIELD(arg, 1))))
    mlw_raise_syserr(errno);

  return MLUNIT;
}

static mlval unix_write(mlval arg)
{
  int w = write(CINT(FIELD(arg, 0)),
		CSTRING(FIELD(arg, 1)) + (unsigned)CINT(FIELD(arg, 2)),
		(unsigned)CINT(FIELD(arg, 3)));
  if (w == -1)
    mlw_raise_syserr(errno);

  return MLINT(w);
}

static mlval unix_seek(mlval arg)
{
  int fd = CINT(FIELD(arg, 0));
  int offset = CINT(FIELD(arg, 1));
  int meth = CINT(FIELD(arg, 2));

  int moveMethod = (meth==0)? SEEK_SET: ((meth==1)? SEEK_CUR : SEEK_END);
  int result = lseek(fd,offset,moveMethod);

  if (result == -1)  mlw_raise_syserr(errno);

  return MLINT(result);
}

#ifndef MLW_OVERRIDE_BLOCK_MODE

static mlval unix_set_block_mode (mlval arg)
{
  int flags;
  int fd = CINT(FIELD(arg, 0));
  int b = CINT(FIELD(arg, 1));

  flags = fcntl (fd, F_GETFL, 0);

  if (flags == -1)
    mlw_raise_syserr(errno);

  if (b == MLTRUE) {
    if (fcntl (fd, F_SETFL, O_NONBLOCK|flags))
      mlw_raise_syserr(errno);
  }
  else {
    if (fcntl (fd, F_SETFL, (~O_NONBLOCK)&flags))
      mlw_raise_syserr(errno);
  }

  return MLUNIT;
}

static mlval unix_can_input (mlval arg)
{
  int fd = CINT(arg);
  long l;

  if (ioctl(fd, FIONREAD, (caddr_t)&l))
    mlw_raise_syserr(errno);

  return MLINT(l);
}

#endif /* !MLW_OVERRIDE_BLOCK_MODE */

static mlval unix_read(mlval arg)
{
  int length = CINT(FIELD(arg, 1));
  char *buffer = alloc((size_t) length, "unix_read"), *s;
  int r = read(CINT(FIELD(arg, 0)), buffer, (unsigned) length);
  mlval string;

  if (r == -1)
  {
    int e= errno;
    free(buffer);
    mlw_raise_syserr(e);
  }

  string = allocate_string((size_t) (r+1));
  s = CSTRING(string);
  memcpy(s, buffer, (size_t) r);
  free(buffer);
  s[r] = '\0';

  return string;
}

static char **list_to_array(mlval list)
{
  size_t i;
  mlval l;
  char **array;

  i = 0;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    ++i;

  array = alloc(sizeof(char *)*(i+1), "list_to_array");

  i = 0;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    array[i++] = CSTRING(MLHEAD(l));
  array[i] = NULL;

  return array;
}

static char **list_to_arg_array(char* fun_location, mlval list)
{
  size_t i;
  mlval l;
  char **array;

  i = 0;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    ++i;

  array = alloc(sizeof(char *)*(i+2), "list_to_arg_array");

  i = 1;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    array[i++] = CSTRING(MLHEAD(l));
  array[i] = NULL;

  array[0] = fun_location;

  return array;
}

static mlval unix_execve(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  char **envp = list_to_array(FIELD(arg, 2));
  int e;

  execve(CSTRING(FIELD(arg, 0)), argv, envp);

  e= errno;

  free(argv);
  free(envp);

  mlw_raise_syserr(errno);
  return MLUNIT;
}

static mlval unix_execv(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  int e;

  execv(CSTRING(FIELD(arg, 0)), argv);

  e= errno;

  free(argv);

  mlw_raise_syserr(errno);
  return MLUNIT;
}

static mlval unix_execvp(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  int e;

  execvp(CSTRING(FIELD(arg, 0)), argv);

  e= errno;

  free(argv);

  mlw_raise_syserr(errno);
  return MLUNIT;
}

#ifndef MLW_OVERRIDE_FORK
/*
 * fork_for_exec defines a fork that will always be used in such a way that
 * it is followed by a fork.  On systems without copy-on-write but which
 * do support vfork, it is suggested you override this with vfork in
 * OS/$OS/unixlocal.h
 *
 */
#define fork_for_exec() fork()
#endif

static mlval unix_pipe (mlval arg)
{
  int filedes[2];
  int result;
  mlval ml_result;

  result = pipe(filedes);

  /*   printf("ML pipe called.  Returned values are %d and %d.\n", filedes[0], filedes[1]); */

  ml_result = allocate_record(2);
  FIELD(ml_result, 0) = MLINT(filedes[0]);
  FIELD(ml_result, 1) = MLINT(filedes[1]);

  return ml_result;
}

static mlval unix_fork_execve(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  char **envp = list_to_array(FIELD(arg, 2));
  int e, pid;
  volatile int exec_errno = 0;
  int in_fd = CINT(FIELD(arg, 3));
  int out_fd = CINT(FIELD(arg, 4));
  int err_fd = CINT(FIELD(arg, 5));

  pid = fork_for_exec();

  if (pid == 0)
  {
    dup2(in_fd, 0);
    dup2(out_fd, 1);
    dup2(err_fd, 2);
    execve(CSTRING(FIELD(arg, 0)), argv, envp);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);
  free(envp);

  if (pid == -1)
    mlw_raise_syserr(e);
  if (exec_errno != 0)
    mlw_raise_syserr(exec_errno);

  return MLINT(pid);
}

static mlval unix_fork_execv(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  int e, pid;
  volatile int exec_errno = 0;
  int in_fd = CINT(FIELD(arg, 2));
  int out_fd = CINT(FIELD(arg, 3));
  int err_fd = CINT(FIELD(arg, 4));

  pid = fork_for_exec();

  if (pid == 0)
  {
    dup2(in_fd, 0);
    dup2(out_fd, 1);
    dup2(err_fd, 2);
    execv(CSTRING(FIELD(arg, 0)), argv);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);

  if (pid == -1)
    mlw_raise_syserr(e);
  if (exec_errno != 0)
    mlw_raise_syserr(exec_errno);

  return MLINT(pid);
}

static mlval unix_fork_execvp(mlval arg)
{
  char **argv = list_to_arg_array(CSTRING(FIELD(arg, 0)), FIELD(arg, 1));
  int e, pid;
  volatile int exec_errno = 0;

  pid = fork_for_exec();

  if (pid == 0)
  {
    execvp(CSTRING(FIELD(arg, 0)), argv);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);

  if (pid == -1)
    mlw_raise_syserr(e);
  if (exec_errno != 0)
    mlw_raise_syserr(exec_errno);

  return MLINT(pid);
}

static mlval unix_wait(mlval arg) {
  pid_t proc = (pid_t)(CINT(arg));
  int stat;

  if (proc == waitpid(proc, &stat, 0)) {
    if (WIFEXITED(stat)) 
      return(box(WEXITSTATUS(stat))); 
    else 
      return(box(-1));
  }
  else {
    mlw_raise_syserr(errno);
    return(box(-1));
  }
}
  

static mlval ml_passwd(struct passwd *pw)
{
  mlval name, passwd, gecos, dir, shell, result;

  /* Lexical ordering of passwd structure fields:
   *
   * dir
   * gecos
   * gid
   * name
   * passwd
   * shell
   * uid
   */

  name = ml_string(pw->pw_name);
  declare_root(&name, 0);
  passwd = ml_string(pw->pw_passwd);
  declare_root(&passwd, 0);
  gecos = ml_string(pw->pw_gecos);
  declare_root(&gecos, 0);
  dir = ml_string(pw->pw_dir);
  declare_root(&dir, 0);
  shell = ml_string(pw->pw_shell);
  declare_root(&shell, 0);
  result = allocate_record(7);
  FIELD(result, 0) = dir;
  FIELD(result, 1) = gecos;
  FIELD(result, 2) = MLINT(pw->pw_gid);
  FIELD(result, 3) = name;
  FIELD(result, 4) = passwd;
  FIELD(result, 5) = shell;
  FIELD(result, 6) = MLINT(pw->pw_uid);
  retract_root(&shell);
  retract_root(&dir);
  retract_root(&gecos);
  retract_root(&passwd);
  retract_root(&name);

  return result;
}

static mlval unix_getpwent(mlval arg)
{
  struct passwd *pw = getpwent();

  if (pw == NULL)
    mlw_raise_syserr(0);

  return ml_passwd(pw);
}

static mlval unix_setpwent(mlval arg)
{
  setpwent();
  return MLUNIT;
}

static mlval unix_endpwent(mlval arg)
{
  endpwent();
  return MLUNIT;
}

static mlval unix_getpwuid(mlval arg)
{
  struct passwd *pw = getpwuid(CINT(arg));

  if (pw == NULL)
    mlw_raise_syserr(0);

  return ml_passwd(pw);
}

static mlval unix_getpwnam(mlval arg)
{
  struct passwd *pw = getpwnam(CSTRING(arg));

  if (pw == NULL)
    mlw_raise_syserr(0);

  return ml_passwd(pw);
}

/*
 * The OS.FileSys.*Dir and POSIX.FileSys.*dir routines require that any
 * attempt to read or rewind a closed stream should raise OS.SysErr.
 * Some systems do the check for readdir(3) but none do it for rewinddir(3).
 * Therefore, the dirstream has to carry some state which indicates whether
 * the stream is open or not.  There are a number of ways of doing this and
 * in the following, making a dirstream a tuple of two values, a dir handle
 * and a boolean indicating open/closed is used.  The state of the dirstream
 * is tested on the C side for no other reason that it only costs one if
 * statement and the alternative of testing it on the ML side doesn't seem
 * to have any particular advantage.
 */
#define mlw_posix_dirstream_make() allocate_record(2)
#define mlw_posix_dirstream_handle(ds) FIELD(ds, 0)
#define mlw_posix_dirstream_state(ds) FIELD(ds, 1)

/*
 * POSIX.FileSys.opendir : string -> dirstream
 */
static mlval mlw_posix_file_sys_opendir(mlval arg)
{
  DIR *dir = opendir(CSTRING(arg));
  mlval dirstream;

  if (dir == NULL)
    mlw_raise_syserr(errno);

  dirstream= mlw_posix_dirstream_make();
  mlw_posix_dirstream_handle(dirstream)= (mlval)dir;
  mlw_posix_dirstream_state(dirstream)= MLTRUE;
  return dirstream;
}

/*
 * POSIX.FileSys.readdir : dirstream -> string option
 */
static mlval mlw_posix_file_sys_readdir(mlval arg)
{
  struct dirent *d;

  if (mlw_posix_dirstream_state(arg) == MLFALSE)
    mlw_raise_syserr(EBADF);

  errno= 0;
  if ((d= readdir((DIR *)mlw_posix_dirstream_handle(arg))) == NULL) {
    if (errno)
      mlw_raise_syserr(errno);
    else
      return mlw_option_make_none();
  }
  return mlw_option_make_some(ml_string(d->d_name));
}

/*
 * POSIX.FileSys.rewinddir : dirstream -> unit
 */
static mlval mlw_posix_file_sys_rewinddir(mlval arg)
{
  if (mlw_posix_dirstream_state(arg) == MLFALSE)
    mlw_raise_syserr(EBADF);
  rewinddir((DIR *)mlw_posix_dirstream_handle(arg));
  return MLUNIT;
}

/*
 * POSIX.FileSys.closedir : dirstream -> unit
 */
static mlval mlw_posix_file_sys_closedir(mlval arg)
{
  if (mlw_posix_dirstream_state(arg) == MLFALSE)
    return MLUNIT;
  if (closedir((DIR *)mlw_posix_dirstream_handle(arg)))
    mlw_raise_syserr(errno);
  mlw_posix_dirstream_state(arg)= MLFALSE;
  return MLUNIT;
}

/*
 * POSIX.FileSys.chdir : string -> unit
 */
static mlval mlw_posix_file_sys_chdir(mlval string)
{
  if (chdir(CSTRING(string)))
    mlw_raise_syserr(errno);

  return MLUNIT;
}

/*
 * POSIX.FileSys.getcwd : unit -> string
 */
static mlval mlw_posix_file_sys_getcwd(mlval unit)
{
  char buffer[MAXPATHLEN];
  char *result = getcwd(buffer, MAXPATHLEN);

  if (result == NULL)
    mlw_raise_syserr(errno);

  return ml_string(buffer);
}

static int
mlw_posix_file_sys_open_modes[]= {O_RDONLY, O_RDWR, O_WRONLY};

/*
 * Instead of implementing openf and creatf as runtime routines, could
 * perhaps just implement one generic routine and do the necessary argument
 * munging on the SML side.  I don't see any clear advantages either way
 * at the moment, so I've arbitrarily implemented both as runtime
 * routines.
 */

/*
 * POSIX.FileSys.openf : string * open_mode * O.flags -> file_desc
 */
static mlval mlw_posix_file_sys_openf(mlval arg)
{
  char const * file_name= CSTRING(FIELD(arg, 0));
  int open_mode= mlw_posix_file_sys_open_modes[CINT(FIELD(arg, 1))];
  int o_flags= CINT(FIELD(arg, 2));
  int fd= open(file_name, open_mode|o_flags);
  if (fd < 0)
    mlw_raise_syserr(errno);
  return MLINT(fd);
}

/*
 * POSIX.FileSys.createf : string * open_mode * O.flags * S.mode -> file_desc
 */
static mlval mlw_posix_file_sys_createf(mlval arg)
{
  char const * file_name= CSTRING(FIELD(arg, 0));
  int open_mode= mlw_posix_file_sys_open_modes[CINT(FIELD(arg, 1))];
  int o_flags= CINT(FIELD(arg, 2));
  int s_mode= CINT(FIELD(arg, 3));
  int fd= open(file_name, open_mode|o_flags|O_CREAT, (mode_t)s_mode);
  if (fd < 0)
    mlw_raise_syserr(errno);
  return MLINT(fd);
}

/*
 * POSIX.FileSys.creat : string * S.mode -> file_desc
 *
 * The docs. describe this as being equivalent to
 *
 *   creatf(s, O_WRONLY, O.trunc, m).
 *
 * But they also state that it should signal an error if the file does
 * not exist!  They can't both be right.  Until such time that a decision
 * is made, creat exists as a separate routine.  If it is equal to the
 * above expression, then it can be removed and done on the SML side.
 */
static mlval mlw_posix_file_sys_creat(mlval arg)
{
  char const * file_name= CSTRING(FIELD(arg, 0));
  int s_mode= CINT(FIELD(arg, 1));
  int fd= creat(file_name, (mode_t)s_mode);
  if (fd < 0)
    mlw_raise_syserr(errno);
  return MLINT(fd);
}

/*
 * POSIX.FileSys.umask : S.mode -> S.mode
 */
static mlval mlw_posix_file_sys_umask(mlval arg)
{
  int omask= CINT(arg);
  mode_t nmask= umask((mode_t)omask);
  return MLINT((int)nmask);
}

/*
 * POSIX.FileSys.link : {old: string, new: string} -> unit
 */
static mlval mlw_posix_file_sys_link(mlval arg)
{
  char const * new= CSTRING(FIELD(arg, 0));
  char const * old= CSTRING(FIELD(arg, 1));
  if (link(old, new) < 0)
    mlw_raise_syserr(errno);
  return MLUNIT;
}

/*
 * POSIX.FileSys.mkdir : string * S.mode -> unit
 */
static mlval mlw_posix_file_sys_mkdir(mlval arg)
{
  if (mkdir(CSTRING(FIELD(arg, 0)), (mode_t) CINT(FIELD(arg, 1))) == -1)
    mlw_raise_syserr(errno);

  return MLUNIT;
}

/*
 * POSIX.FileSys.unlink : string -> unit
 */
static mlval mlw_posix_file_sys_unlink(mlval arg)
{
  if (unlink(CSTRING(arg)))
    mlw_raise_syserr(errno);

  return MLUNIT;
}

/*
 * POSIX.FileSys.rmdir : string -> unit
 */
static mlval mlw_posix_file_sys_rmdir(mlval arg)
{
  if (rmdir(CSTRING(arg)) == -1)
    mlw_raise_syserr(errno);

  return MLUNIT;
}

/*
 * POSIX.FileSys.rename : { new: string, old: string} -> unit
 */
static mlval mlw_posix_file_sys_rename(mlval arg)
{
  if (rename(CSTRING(FIELD(arg, 1)), CSTRING(FIELD(arg, 0))))
    mlw_raise_syserr(errno);

  return MLUNIT;
}

/*
 * POSIX.FileSys.readlink : string -> string
 */
static mlval mlw_posix_file_sys_readlink(mlval arg)
{
  char const * pathname= CSTRING(arg);
  char contents[mlw_path_max];
  int  contents_len;
  mlval tagged_contents;
  if ((contents_len= readlink(pathname, contents, mlw_path_max)) < 0)
    mlw_raise_syserr(errno);
  tagged_contents= allocate_string((size_t)contents_len+1);
  memcpy(CSTRING(tagged_contents), contents, (size_t)contents_len);
  CSTRING(tagged_contents)[contents_len] = '\0';
  return tagged_contents;
}

/*
 * OS.FileSys.fullPath : string -> string
 */
static mlval mlw_os_file_sys_full_path(mlval arg)
{
  char buffer[MAXPATHLEN];
  char *result= realpath(CSTRING(arg), buffer);
  if (result == NULL)
    mlw_raise_syserr(errno);

  return ml_string(buffer);
}

/*
 * OS.FileSys.tmpName : unit -> string
 */
static mlval mlw_os_file_sys_tmp_name(mlval arg)
{
  char * name= tmpnam(NULL);
  if (name == NULL)
    mlw_raise_syserr(errno);

  return ml_string(name);
}

#define stat_offset_atime   0
#define stat_offset_blksize (stat_offset_atime+1)
#define stat_offset_blocks  (stat_offset_blksize+1)
#define stat_offset_ctime   (stat_offset_blocks+1)
#define stat_offset_dev     (stat_offset_ctime+1)
#define stat_offset_gid     (stat_offset_dev+1)
#define stat_offset_ino     (stat_offset_gid+1)
#define stat_offset_mode    (stat_offset_ino+1)
#define stat_offset_mtime   (stat_offset_mode+1)
#define stat_offset_nlink   (stat_offset_mtime+1)
#define stat_offset_rdev    (stat_offset_nlink+1)
#define stat_offset_size    (stat_offset_rdev+1)
#define stat_offset_uid     (stat_offset_size+1)
#define stat_size           (stat_offset_uid+1)

static mlval mlw_posix_file_sys_st_isdir(mlval arg)
{
  return S_ISDIR(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_ischr(mlval arg)
{
  return S_ISCHR(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_isblk(mlval arg)
{
  return S_ISBLK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_isreg(mlval arg)
{
  return S_ISREG(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_isfifo(mlval arg)
{
  return S_ISFIFO(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_islink(mlval arg)
{
  return S_ISLNK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

static mlval mlw_posix_file_sys_st_issock(mlval arg)
{
  return S_ISSOCK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}

/* Converts a C struct stat into an ML POSIX.ST.stat.
 * See src/unix/unixos.sml for the definition of POSIX.ST.stat
 *
 * ALLOCATES.
 */
static mlval mlw_posix_file_sys_return_stat (struct stat * st)
{
  mlval atime, ctime, mtime, result;

  atime= mlw_time_make(st->st_atime, 0);
  declare_root(&atime, 0);

  ctime= mlw_time_make(st->st_ctime, 0);
  declare_root(&ctime, 0);

  mtime= mlw_time_make(st->st_mtime, 0);
  declare_root(&mtime, 0);

  result= allocate_record(stat_size);

  /* Lexical ordering for fields -- the result is a record with name fields.
   *
   * atime      file last access time
   * blksize    preferred blocksize for file system I/O
   * blocks     actual number of blocks allocated
   * ctime      file last status change time
   * dev        device file resides on
   * gid        group ID of owner
   * ino        the file serial number
   * mode       file mode
   * mtime      file last modify time
   * nlink      number of hard links to the file
   * rdev       the device identifier (special files only)
   * size       total size of file, in bytes
   * uid        user ID of owner
   *
   * ino and dev are currently represented as an MLINT.  Since they
   * are generally defined as an (unsigned) long, perhaps these
   * should be represented as a Word32?
   */

  FIELD(result, stat_offset_atime)=   atime;
  FIELD(result, stat_offset_blksize)= MLINT(st->st_blksize);
  FIELD(result, stat_offset_blocks)=  MLINT(st->st_blocks);
  FIELD(result, stat_offset_ctime)=   ctime;
  FIELD(result, stat_offset_dev)=     MLINT(st->st_dev);
  FIELD(result, stat_offset_gid)=     MLINT(st->st_gid);
  FIELD(result, stat_offset_ino)=     MLINT(st->st_ino);
  FIELD(result, stat_offset_mode)=    MLINT(st->st_mode);
  FIELD(result, stat_offset_mtime)=   mtime;
  FIELD(result, stat_offset_nlink)=   MLINT(st->st_nlink);
  FIELD(result, stat_offset_rdev)=    MLINT(st->st_rdev);
  FIELD(result, stat_offset_size)=    MLINT(st->st_size);
  FIELD(result, stat_offset_uid)=     MLINT(st->st_uid);

  retract_root(&mtime);
  retract_root(&ctime);
  retract_root(&atime);

  return result;
}

/*
 * POSIX.FileSys.stat : string -> ST.stat
 *
 * Note POSIX.FileSys.stat is required to raise OS.SysErr if given "".
 * All supported systems except SunOS do this test in stat, but to save
 * having a separate version just for stat, the test is done before
 * calling stat and NOENT is raised explicitly.
 */
static mlval mlw_posix_file_sys_stat (mlval arg)
{
  struct stat st;
  char const * path = CSTRING(arg);

  if (path[0] == '\0')
    mlw_raise_syserr(ENOENT);

  if (stat(path, &st))
    mlw_raise_syserr(errno);

  return mlw_posix_file_sys_return_stat(&st);
}

/*
 * POSIX.FileSys.fstat : file_desc -> ST.stat
 */
static mlval mlw_posix_file_sys_fstat(mlval arg)
{
  struct stat st;
  int fd = CINT (arg);

  if (fstat (fd, &st))
    mlw_raise_syserr(errno);

  return mlw_posix_file_sys_return_stat(&st);
}

/*
 * POSIX.FileSys.lstat : string -> ST.stat
 *
 * Note POSIX.FileSys.lstat is required to raise OS.SysErr if given "".
 * All supported systems except SunOS do this test in lstat, but to save
 * having a separate version just for lstat, the test is done before
 * calling lstat and NOENT is raised explicitly.
 */
static mlval mlw_posix_file_sys_lstat (mlval arg)
{
  struct stat st;
  char const * path = CSTRING(arg);

  if (path[0] == '\0')
    mlw_raise_syserr(ENOENT);

  if (lstat(path, &st))
    mlw_raise_syserr(errno);

  return mlw_posix_file_sys_return_stat(&st);
}

static int
mlw_posix_file_sys_access_mode_ml_to_c[]= {X_OK, R_OK, W_OK};

#define mlw_posix_file_sys_n_access_modes \
  (sizeof(mlw_posix_file_sys_access_mode_ml_to_c)/sizeof(mlw_posix_file_sys_access_mode_ml_to_c[0]))

/*
 * POSIX.FileSys.access : (string * access_mode list) -> bool
 *
 * The description states that :-
 *
 *   ... only raise OS.SysError for errors unrelated to resolving the
 *   pathname and the related permissions, such as being interrupted
 *   by a signal during the the system call.
 *
 * Which seems to leave it to the implementor to decide exactly what
 * are "errors unrelated to resolving the pathname".
 */
static mlval mlw_posix_file_sys_access(mlval arg)
{
  char const * path= CSTRING(FIELD(arg, 0));
  mlval modes= FIELD(arg, 1);
  int access_mode= F_OK;
  int access_status;
  for (; !MLISNIL(modes); modes= MLTAIL(modes)) {
    int ml_mode= CINT(MLHEAD(modes));
    assert(ml_mode >= 0 && ml_mode <= mlw_posix_file_sys_n_access_modes);
    access_mode |= mlw_posix_file_sys_access_mode_ml_to_c[ml_mode];
  }
  if ((access_status= access(path, access_mode)) < 0) {
    switch (errno) {
    case EACCES:
    case ENOENT:
    case ENOTDIR:
    case EROFS:
    case ELOOP:
#ifdef EMULTIHOP
    case EMULTIHOP:
#endif
#ifdef ETIMEDOUT
    case ETIMEDOUT:
#endif
#ifdef ENOLINK
    case ENOLINK:
#endif
      return MLFALSE;
    default:
      mlw_raise_syserr(errno);
    }
  }
  return MLTRUE;
}

/*
 * UnixOS.utime : (string * Time.time * Time.time) -> unit
 *
 * This is used to define POSIX.FileSys.utime.  This is a lower level
 * interface in that you always have to specify the access and modification
 * times.
 */
static mlval mlw_unix_utime(mlval arg)
{
  char const * path= CSTRING(FIELD(arg, 0));
  mlval access_time= FIELD(arg, 1);
  mlval mod_time= FIELD(arg, 2);
  struct utimbuf tb;
  tb.actime= mlw_time_sec(access_time);
  tb.modtime= mlw_time_sec(mod_time);
  if (utime(path, &tb) < 0)
    mlw_raise_syserr(errno);
  return MLUNIT;
}

/*
 * POSIX.IO.close : file_desc -> unit
 */
static mlval mlw_posix_io_close(mlval arg)
{
  if (close(CINT(arg)) == -1)
    mlw_raise_syserr(errno);

  return MLUNIT;
}

static mlval password_file_result = DEAD;

static mlval unix_password_file(mlval arg)
{
  if (password_file_result == DEAD) {
    mlval result = MLNIL,
          str1 = MLNIL,
          str2 = MLNIL,
          pair = MLNIL;
    struct passwd *entry = getpwent();
    password_file_result = MLNIL;
    declare_root(&password_file_result, 0);
    declare_root(&result, 0);
    declare_root(&str1, 0);
    declare_root(&str2, 0);
    declare_root(&pair, 0);
    while (entry != NULL) {
      str1 = ml_string(entry->pw_name);
      str2 = ml_string(entry->pw_dir);
      pair = allocate_record(2);
      FIELD(pair, 0) = str1;
      FIELD(pair, 1) = str2;
      result = cons(pair, result);
      entry = getpwent();
    };
    endpwent();
    retract_root(&result);
    retract_root(&str1);
    retract_root(&str2);
    retract_root(&pair);
    password_file_result = result;
  }
  return password_file_result;
}

static mlval unix_kill(mlval arg)
{ if (kill(CINT(FIELD(arg, 0)), CINT(FIELD(arg, 1)))) {
    mlw_raise_syserr(errno);
  }
  return MLUNIT;
}

/*
 * OS.Process.terminate: Word32.word -> 'a
 */
static mlval unix_exit(mlval exit_code)
{
  exit(unbox(exit_code));
  return MLUNIT;		/* keep dumb compilers happy */
}

/*
 * OS.Process.system: string -> Word32.word
 */
static mlval unix_system(mlval arg)
{
  char const * command= CSTRING(arg);
  int status= system(command);
  if (status == -1 || status == 127)
    mlw_raise_syserr(errno);

  return box(status);
}

static mlval unix_getenv(mlval arg)
{
  char const * name= CSTRING(arg);
  char const * value= getenv(name);
  if (value == NULL) {
    return mlw_option_make_none();
  } else {
    return mlw_option_make_some(ml_string(value));
  }
}

/*
 * OS.IO.kind : io_desc -> iodesc_kind
 * Raises: OS.SysErr
 *
 * Note that this is the only OS.IO routine implemented here.
 * All the poll related routines are implemented in os_io_poll.[ch]
 */

static mlval mlw_os_io_kind(mlval arg)
{
  struct stat st;
  int io_desc= CINT(arg);

  if (fstat(io_desc, &st) < 0)
    mlw_raise_syserr(errno);

  if (S_ISREG(st.st_mode)) {
    return isatty(io_desc) ? MLINT(4) : MLINT(1);
  } else if (S_ISDIR(st.st_mode)) {
    return MLINT(2);
  } else if (S_ISLNK(st.st_mode)) {
    return MLINT(3);
  } else if (S_ISFIFO(st.st_mode)) {
    return MLINT(5);
  } else if (S_ISSOCK(st.st_mode)) {
    return MLINT(6);
  } else if (S_ISBLK(st.st_mode) || S_ISCHR(st.st_mode)) {
    return MLINT(7);
  } else {
    exn_raise_syserr(ml_string("OS.IO.kind: unknown io_desc kind"), 0);
  }
}

extern void unix_init(void)
{
  env_value("system io standard in",MLINT(0));
  env_value("system io standard out",MLINT(1));
  env_value("system io standard err",MLINT(2));

  env_function("OS.errorMsg", mlw_os_error_msg);
  env_function("OS.errorName", mlw_os_error_name);
  env_function("OS.syserror", mlw_os_syserror);

  env_function("system os unix environment", unix_environment);
  env_function("system os unix rusage", unix_rusage);
  env_function("system os unix open", unix_open);
  env_function("POSIX.FileSys.opendir", mlw_posix_file_sys_opendir);
  env_function("POSIX.FileSys.readdir", mlw_posix_file_sys_readdir);
  env_function("POSIX.FileSys.rewinddir", mlw_posix_file_sys_rewinddir);
  env_function("POSIX.FileSys.closedir", mlw_posix_file_sys_closedir);
  env_function("POSIX.FileSys.chdir", mlw_posix_file_sys_chdir);
  env_function("POSIX.FileSys.getcwd", mlw_posix_file_sys_getcwd);

  mlw_posix_file_sys_o_append= MLINT(O_APPEND);
  env_value("POSIX.FileSys.O.append", mlw_posix_file_sys_o_append);

  mlw_posix_file_sys_o_excl= MLINT(O_EXCL);
  env_value("POSIX.FileSys.O.excl", mlw_posix_file_sys_o_excl);

  mlw_posix_file_sys_o_noctty= MLINT(O_NOCTTY);
  env_value("POSIX.FileSys.O.noctty", mlw_posix_file_sys_o_noctty);

  mlw_posix_file_sys_o_nonblock= MLINT(O_NONBLOCK);
  env_value("POSIX.FileSys.O.nonblock", mlw_posix_file_sys_o_nonblock);

  mlw_posix_file_sys_o_sync= MLINT(O_SYNC);
  env_value("POSIX.FileSys.O.sync", mlw_posix_file_sys_o_sync);

  mlw_posix_file_sys_o_trunc= MLINT(O_TRUNC);
  env_value("POSIX.FileSys.O.trunc", mlw_posix_file_sys_o_trunc);

  env_function("POSIX.FileSys.openf", mlw_posix_file_sys_openf);
  env_function("POSIX.FileSys.createf", mlw_posix_file_sys_createf);
  env_function("POSIX.FileSys.creat", mlw_posix_file_sys_creat);
  env_function("POSIX.FileSys.umask", mlw_posix_file_sys_umask);
  env_function("POSIX.FileSys.link", mlw_posix_file_sys_link);
  env_function("POSIX.FileSys.mkdir", mlw_posix_file_sys_mkdir);
  env_function("POSIX.FileSys.rmdir", mlw_posix_file_sys_rmdir);
  env_function("POSIX.FileSys.unlink", mlw_posix_file_sys_unlink);
  env_function("POSIX.FileSys.rename", mlw_posix_file_sys_rename);
  env_function("POSIX.FileSys.readlink", mlw_posix_file_sys_readlink);
  env_function("OS.FileSys.tmpName", mlw_os_file_sys_tmp_name);
  env_function("OS.FileSys.fullPath", mlw_os_file_sys_full_path);

  env_function("POSIX.FileSys.ST.isdir", mlw_posix_file_sys_st_isdir);
  env_function("POSIX.FileSys.ST.ischr", mlw_posix_file_sys_st_ischr);
  env_function("POSIX.FileSys.ST.isblk", mlw_posix_file_sys_st_isblk);
  env_function("POSIX.FileSys.ST.ischr", mlw_posix_file_sys_st_ischr);
  env_function("POSIX.FileSys.ST.isreg", mlw_posix_file_sys_st_isreg);
  env_function("POSIX.FileSys.ST.isfifo", mlw_posix_file_sys_st_isfifo);
  env_function("POSIX.FileSys.ST.islink", mlw_posix_file_sys_st_islink);
  env_function("POSIX.FileSys.ST.issock", mlw_posix_file_sys_st_issock);

  env_function("POSIX.FileSys.stat", mlw_posix_file_sys_stat);
  env_function("POSIX.FileSys.fstat", mlw_posix_file_sys_fstat);
  env_function("POSIX.FileSys.lstat", mlw_posix_file_sys_lstat);

  env_function("POSIX.FileSys.access", mlw_posix_file_sys_access);

  env_function("system os unix utime", mlw_unix_utime);

  env_function("system io read", unix_read);
  env_function("system io seek", unix_seek);
  env_function("system io write", unix_write);
  env_function("system io close", mlw_posix_io_close);
  env_function("system io can input", unix_can_input);
  env_value ("system io standard input", mlw_ref_make(MLINT(0)));
  env_value ("system io standard output", mlw_ref_make(MLINT(1)));
  env_value ("system io standard error", mlw_ref_make(MLINT(2)));

  env_function("system os unix socket", unix_socket);
  env_function("system os unix bind", unix_bind);
  env_function("system os unix connect", unix_connect);
  env_function("system os unix set block mode", unix_set_block_mode);
  env_function("system os unix accept", unix_accept);
  env_function("system os unix listen", unix_listen);
  env_function("system os unix getsockname", unix_getsockname);
  env_function("system os unix getpeername", unix_getpeername);
  env_function("system os unix execve", unix_execve);
  env_function("system os unix execv", unix_execv);
  env_function("system os unix execvp", unix_execvp);
  env_function("system os unix fork_execve", unix_fork_execve);
  env_function("system os unix fork_execv", unix_fork_execv);
  env_function("system os unix fork_execvp", unix_fork_execvp);
  env_function("system os unix wait", unix_wait);
  env_function("system os unix getpwent", unix_getpwent);
  env_function("system os unix setpwent", unix_setpwent);
  env_function("system os unix endpwent", unix_endpwent);
  env_function("system os unix getpwuid", unix_getpwuid);
  env_function("system os unix getpwnam", unix_getpwnam);
  env_function("system os unix password_file", unix_password_file);
  env_function("system os unix kill", unix_kill);

  env_function("system os unix pipe", unix_pipe);

  env_function("system os exit", unix_exit);
  env_function("system os system", unix_system);
  env_function("system os getenv", unix_getenv);

  env_function("OS.IO.kind", mlw_os_io_kind);

  unix_af_unix= MLINT(AF_UNIX);
  env_value("system os unix af_unix", unix_af_unix);

  unix_af_inet= MLINT(AF_INET);
  env_value("system os unix af_inet", unix_af_inet);

  unix_sock_stream= MLINT(SOCK_STREAM);
  env_value("system os unix sock_stream", unix_sock_stream);

  unix_sock_dgram= MLINT(SOCK_DGRAM);
  env_value("system os unix sock_dgram", unix_sock_dgram);

  unix_exn_ref_would_block = ref(exn_default);
  env_value("system os unix exception Would Block", unix_exn_ref_would_block);
  declare_global
    ("system os unix exception Would Block", &unix_exn_ref_would_block,
     GLOBAL_DEFAULT, NULL, NULL, NULL);

  unix_o_rdonly = MLINT(O_RDONLY);
  env_value("system os unix o_rdonly", unix_o_rdonly);

  unix_o_wronly = MLINT(O_WRONLY);
  env_value("system os unix o_wronly", unix_o_wronly);

  unix_o_append = MLINT(O_APPEND);
  env_value("system os unix o_append", unix_o_append);

  unix_o_creat = MLINT(O_CREAT);
  env_value("system os unix o_creat", unix_o_creat);

  unix_o_trunc = MLINT(O_TRUNC);
  env_value("system os unix o_trunc", unix_o_trunc);

  /* PATH_MAX can be set at compile time or runtime or neither!  See
   * section 2.5.7, page 41 of Advanced Programming in the UNIX Environment
   * W. Richard Stevens for more info.
   */
#ifdef PATH_MAX
  mlw_path_max= PATH_MAX;
#else
  if ((mlw_path_max= pathconf("/", _PC_PATH_MAX)) < 0) {
    /* Should only do the following if errno == 0, but since
     * we don't want to signal an error from the initialisation code
     * it is done whether there is an error or not.
     */
    mlw_path_max= MAXPATHLEN;
  }
#endif

  /* Arguably the following should not be here but in os_init.
   * However, since they are the same for all Unix systems there
   * doesn't seem much point in repeating them in each Unix
   * variant's os_init.
   */
  mlw_time_date_init();
  mlw_timer_init();
  mlw_os_io_poll_init();
}

extern void signals_finalise (void)
{
  /* No action required on unix */
}

extern int system_validate_ml_address(void *addr)
{
  return 0;
  /* Temporary implementation until shared objects done */
}

extern const char *const *parse_command_line(int *argc)
{
  error("Unix version of parse_command_line not yet implemented and shouldn't be called");
}

extern void register_time_stamp(unsigned long *addr);

extern void register_time_stamp(unsigned long *addr)
{
  error("Unix version of register_time_stamp not yet implemented and shouldn't be called");
}
@


1.37.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a29 4
 * Revision 1.37  1999/03/22  17:04:12  mitchell
 * [Bug #30286]
 * Support for the Unix structure
 *
@


1.36
log
@[Bug #190523]
OS.Process.status is now a Word32.word.
@
text
@d30 4
d207 1
d748 3
d756 3
d834 17
d1497 1
a1497 2
{
  if (kill(CINT(FIELD(arg, 0)), CINT(FIELD(arg, 1))))
d1499 1
d1660 1
@


1.35
log
@[Bug #190521]
Type of OS.FileSys.readDir has changed.
@
text
@d30 4
d268 24
d1475 3
d1480 1
a1480 1
  exit(CINT(exit_code));
d1484 3
d1494 1
a1494 1
  return MLINT(status);
@


1.34
log
@Make changes for the Unix structure.
@
text
@d30 3
d913 1
a913 1
 * POSIX.FileSys.readdir : dirstream -> string
d927 1
a927 1
      return ml_string("");	/* by analogy with lookahead */
d929 1
a929 1
  return ml_string(d->d_name);
@


1.33
log
@[Bug #70108]
Ensure syscalls.h included before time.h because of Red Hat 5 stupidities
@
text
@d30 4
d609 22
d633 1
a633 1
  char **argv = list_to_array(FIELD(arg, 1));
d650 1
a650 1
  char **argv = list_to_array(FIELD(arg, 1));
d665 1
a665 1
  char **argv = list_to_array(FIELD(arg, 1));
d689 17
d708 1
a708 1
  char **argv = list_to_array(FIELD(arg, 1));
d736 1
a736 1
  char **argv = list_to_array(FIELD(arg, 1));
d739 3
d747 3
d768 1
a768 1
  char **argv = list_to_array(FIELD(arg, 1));
d1602 2
@


1.32
log
@[Bug #30108]
Move dummy definitions os asm_trampoline from unix.c into os.c
@
text
@d30 4
d199 1
a207 1
#include "syscalls.h"
@


1.31
log
@[Bug #70174]
Modify type of parse_command_line to fix compiler warnings
@
text
@d30 4
d1631 1
a1631 1
extern mlval asm_trampoline(mlval x);
d1633 1
a1633 1
extern mlval asm_trampoline(mlval x)
d1635 1
a1635 1
  error("Unix version of asm_trampoline not yet implemented and shouldn't be called");
@


1.30
log
@[Bug #30108]
Add parse_command_line
@
text
@d30 4
d1622 1
a1622 1
extern char **parse_command_line(int *argc)
@


1.29
log
@[Bug #70153]
Add prototype for system_validate_ml_address
@
text
@d30 4
d1616 12
@


1.28
log
@[Bug #70153]
Add system_validate_ml_address
@
text
@d30 4
d198 1
@


1.27
log
@[Bug #70132]
Add signals_finalise
@
text
@d30 4
a194 1

a209 1

a221 2


a233 2


a235 1

a246 2


a251 3



a269 1

d283 1
a283 1
  
a328 2


a343 2


a353 2


a373 2


a393 2


a416 2


a439 2


a469 2


a477 2


a488 2


a502 2


a527 2


a540 2


a563 2


a583 2


a600 1

a615 1

a630 1

a641 2


a669 2


a692 1

a695 2


a721 2


a763 2


a773 2


a779 2


a785 2


a795 2


a805 2


a821 1

a838 3



a858 3



a869 3



a882 3



a893 2


a907 2


a910 1

d912 1
a912 1
 * Instead of implementing openf and creatf as runtime routines, could 
a918 1

a932 2


a947 3



d951 1
a951 1
 * The docs. describe this as being equivalent to 
d955 1
a955 1
 * But they also state that it should signal an error if the file does 
a969 3



a979 3



a991 3



a1002 2


a1013 3



a1024 2


a1035 2


a1052 4




a1065 2


a1077 3



a1092 2


a1097 1

a1102 1

a1107 1

a1112 1

a1117 1

a1122 1

a1127 3



a1147 1

a1189 3



a1211 2


a1225 2


a1247 3



d1259 1
a1259 1
 *   ... only raise OS.SysError for errors unrelated to resolving the 
a1300 3



a1320 3



a1331 3



a1366 2


a1373 2


a1379 2


a1389 3



a1400 3



d1414 1
a1414 1
  if (fstat(io_desc, &st) < 0) 
d1434 1
a1434 3


void unix_init(void)
d1572 1
a1572 2

  /* PATH_MAX can be set at compile time or runtime or neither!  See 
a1587 1

d1590 1
a1590 1
   * doesn't seem much point in repeating them in each Unix 
d1601 6
@


1.26
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d30 5
d160 1
d1757 5
@


1.25
log
@[Bug #30089]
Modify unix_rusage to return ru_utime and ru_stime as basis times
@
text
@d30 4
d259 1
a259 1
  declare_root(&result);
d283 1
a283 1
  declare_root(&utime);
d285 1
a285 1
  declare_root(&stime);
d478 1
a478 1
  declare_root(&ml_sockaddr);
d783 1
a783 1
  declare_root(&name);
d785 1
a785 1
  declare_root(&passwd);
d787 1
a787 1
  declare_root(&gecos);
d789 1
a789 1
  declare_root(&dir);
d791 1
a791 1
  declare_root(&shell);
d1257 1
a1257 1
  declare_root(&atime);
d1260 1
a1260 1
  declare_root(&ctime);
d1263 1
a1263 1
  declare_root(&mtime);
d1482 5
a1486 5
    declare_root(&password_file_result);
    declare_root(&result);
    declare_root(&str1);
    declare_root(&str2);
    declare_root(&pair);
@


1.24
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d30 4
d150 1
d278 1
a278 1
  utime = ml_time(&ru.ru_utime);
d280 1
a280 1
  stime = ml_time(&ru.ru_stime);
@


1.24.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a29 4
 * Revision 1.24  1997/08/19  15:14:01  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.24.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a29 4
 * Revision 1.24  1997/08/19  15:14:01  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.24.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a29 4
 * Revision 1.24  1997/08/19  15:14:01  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.23
log
@[Bug #30029]
make mlw_raise_syserr an extern so it can be used elsewhere.
@
text
@d30 4
a272 2
  result = allocate_record(16);

d274 1
d276 5
@


1.22
log
@[Bug #01702]
Changed definition of exn_raise_syserr.
@
text
@d30 4
d141 1
a141 1

d233 1
a233 1
static void mlw_raise_syserr(int i)
@


1.21
log
@[Bug #1968]
make stdIn, stdOut and stdErr refs.
@
text
@d30 4
d131 1
a131 1
#include "allocator.h"		/* allocate_record */
d231 1
a231 1
  exn_raise_syserr(strerror(i), i);
d1560 1
a1560 1
    exn_raise_syserr("OS.IO.kind: unknown io_desc kind", 0);
@


1.21.1.1
log
@branched from 1.21
@
text
@a29 4
 * Revision 1.21  1997/03/21  17:23:20  andreww
 * [Bug #1968]
 * make stdIn, stdOut and stdErr refs.
 *
@


1.21.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a29 3
 * Revision 1.21.1.1  1997/05/12  10:45:15  hope
 * branched from 1.21
 *
@


1.21.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a29 3
 * Revision 1.21.1.1  1997/05/12  10:45:15  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a29 3
 * Revision 1.21.1.1  1997/05/12  10:45:15  hope
 * branched from 1.21
 *
@


1.21.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a29 3
 * Revision 1.21.1.1.1.1  1997/07/28  18:28:10  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.20
log
@[Bug #1431]
Changing call name of POSIX.Error.errorMsg/Name to make it
compatible with win32 implementation.
@
text
@d30 5
d1635 3
a1637 3
  env_value ("system io standard input", MLINT(0));
  env_value ("system io standard output", MLINT(1));
  env_value ("system io standard error", MLINT(2));
@


1.19
log
@Remove MLW_OVERRIDE_READLINK stuff since it is not needed
with gcc-2.7.2.
@
text
@d30 4
d1563 3
a1565 3
  env_function("POSIX.Error.errorMsg", mlw_os_error_msg);
  env_function("POSIX.Error.errorName", mlw_os_error_name);
  env_function("POSIX.Error.syserror", mlw_os_syserror);
@


1.19.8.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.7.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.7.1.1.1
log
@branched from 1.19.7.1
@
text
@a29 3
 * Revision 1.19.7.1  1996/12/17  17:56:53  hope
 * branched from 1.19
 *
@


1.19.6.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.5.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.4.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.4.1.1.1
log
@branched from 1.19.4.1
@
text
@a29 3
 * Revision 1.19.4.1  1996/11/14  13:00:45  hope
 * branched from 1.19
 *
@


1.19.3.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a29 4
 * Revision 1.19  1996/08/06  13:15:54  stephenb
 * Remove MLW_OVERRIDE_READLINK stuff since it is not needed
 * with gcc-2.7.2.
 *
@


1.18
log
@Correct some of the #include comments.
@
text
@d30 3
a1100 17
/* Most systems define readlink with the following prototype :-
 *
 *  readlink(char const *path, char *buff, int size)
 *
 * Unfortunately, not all do, for example Irix defines it as :-
 *
 *  readlink(char const *path, char *buff, size_t size)
 *
 * So to avoid the warning, the following provides the default definition
 * of readlink, which can be overriden in OS/$(OS)/unixlocal.h as necessary.
 */
#ifndef MLW_OVERRIDE_READLINK
#define mlw_unix_readlink(path, buff, size) readlink(path, buff, size)
#endif



d1110 1
a1110 1
  if ((contents_len= mlw_unix_readlink(pathname, contents, mlw_path_max)) < 0)
@


1.17
log
@Altering the order of arguments given to the lseek system call.
@
text
@d30 3
d126 1
a126 1
#include <unistd.h>		/* read, write, ... etc. */
d128 2
a129 2
#include <sys/types.h>		/* many of the following ... */
#include <sys/stat.h>		/* mkdir, open */
d131 1
a131 1
#include <fcntl.h>
@


1.16
log
@Removing system-specific information from the names of the calls
to read, write, seek and close.
@
text
@d30 4
d479 1
a479 1
  int result = lseek(fd,moveMethod,offset);
@


1.15
log
@remove unnecessary declare/retract roots, particularly
those surrounding any use of mlw_option_make_some.
@
text
@d30 4
d472 4
d477 1
a477 2
  if (lseek(fd, SEEK_SET, offset) == -1)
    mlw_raise_syserr(errno);
d479 1
a479 1
  return MLUNIT;
d1562 4
d1626 1
a1626 1
  env_function("POSIX.IO.close", mlw_posix_io_close);
d1628 8
a1635 1
  env_function("system os unix utime", mlw_unix_utime);
a1639 3
  env_function("system os unix read", unix_read);
  env_function("system os unix seek", unix_seek);
  env_function("system os unix can input", unix_can_input);
a1640 1
  env_function("system os unix write", unix_write);
@


1.14
log
@Aargh!  Why o why did I check in the previous version before
compiling it first.  I missed out a ")" :-<
@
text
@d30 4
d1511 1
a1511 6
    mlval tagged_value= ml_string(value);
    mlval some_value;
    declare_root(&tagged_value);
    some_value= mlw_option_make_some(tagged_value);
    retract_root(&tagged_value);
    return some_value;
@


1.13
log
@Add some missing declare/retract_root calls.
Specifically to mlw_posix_file_sys_return_stat.
@
text
@d30 4
d1266 1
a1266 1
  retract_root(&ctime;
@


1.12
log
@Ensure that rewinddir raises OS.SysErr when applied to a closed dirstream.
@
text
@d30 3
d1205 5
d1214 10
a1223 1
  result = allocate_record(stat_size);
a1224 3
  atime = mlw_time_make(st->st_atime, 0);
  ctime = mlw_time_make(st->st_ctime, 0);
  mtime = mlw_time_make(st->st_mtime, 0);
d1261 4
d1270 1
d1511 1
@


1.11
log
@Make stat/lstat raise an exception when given "".
Strictly speaking the test is only needed under SunOS, all the other
Unix varieties do the test, but for the sake of a test it isn't
worth creating a SunOS specific version of these functions.
@
text
@d30 6
d802 17
d824 1
d829 4
a832 1
  return (mlval)dir;
d837 1
d845 5
a849 2
  errno = 0;
  if ((d= readdir((DIR *)arg)) == NULL) {
d860 1
d866 3
a868 1
  rewinddir((DIR *)arg);
d874 1
d880 3
a882 1
  if (closedir((DIR *)arg))
d884 1
d887 1
@


1.10
log
@Fix creat and umask calls so as to remove signed/unsigned warnings.
@
text
@d30 3
d1215 5
d1226 3
d1255 5
d1265 3
@


1.9
log
@Implement POSIX.FileSys.{openf,creatf,creat} in order to support
basis IO.
@
text
@d30 4
d916 1
a916 1
  int fd= open(file_name, open_mode|o_flags|O_CREAT, s_mode);
d941 1
a941 1
  int fd= creat(file_name, s_mode);
d956 2
a957 2
  int nmask= umask(omask);
  return MLINT(nmask);
@


1.8
log
@expose unix IO constants to ML system.
@
text
@d30 3
d124 4
d133 7
d148 14
d262 3
d874 100
d1483 25
a1508 1
  env_function("POSIX.FileSys.mkdir", mlw_posix_file_sys_mkdir);
@


1.7
log
@unix_init: add a call to mlw_timer_init.
@
text
@d30 3
d126 7
d1428 15
@


1.6
log
@Add support for OS.errorName and OS.syserror
@
text
@d30 3
d107 1
d1429 2
a1430 1
     * we don't want to signal an error from the initialisation code,
d1436 6
d1443 1
@


1.5
log
@Add support for OS.errorMsg
Also finish of the implementation of OS.FileSys.
@
text
@d30 4
d105 1
d123 4
d135 1
d882 17
d908 1
a908 1
  if ((contents_len= readlink(pathname, contents, mlw_path_max)) < 0)
d1326 2
@


1.4
log
@Add support for OS.IO
@
text
@d30 3
d74 2
a75 1
#include <errno.h>
d86 1
d102 1
d105 1
d118 9
a126 1
static void unix_error(int i)
a152 32
static mlval unix_getwd(mlval unit)
{
  char buffer[MAXPATHLEN];
  char *result = getcwd(buffer, MAXPATHLEN);

  if (result == NULL)
    unix_error(errno);

  return ml_string(buffer);
}


static mlval unix_realpath(mlval filename)
{
  char buffer[MAXPATHLEN];
  char *result = realpath(CSTRING(filename),buffer);
  if (result == NULL)
    unix_error(errno);

  return ml_string(buffer);
}


static mlval unix_setwd(mlval string)
{
  if (chdir(CSTRING(string)))
    unix_error(errno);

  return MLUNIT;
}


d160 1
a160 1
    unix_error(errno);
d217 1
a217 1
    unix_error(errno);
a223 41
static mlval unix_close(mlval arg)
{
  if (close(CINT(arg)) == -1)
    unix_error(errno);

  return MLUNIT;
}



static mlval unix_unlink(mlval arg)
{
  if (unlink(CSTRING(arg)))
    unix_error(errno);

  return MLUNIT;
}



static mlval unix_rename(mlval arg)
{
  if (rename(CSTRING(FIELD(arg, 0)), CSTRING(FIELD(arg, 1))))
    unix_error(errno);

  return MLUNIT;
}



static mlval unix_tmpname(mlval arg)
{
  char * name= tmpnam(NULL);
  if (name == NULL)
    unix_error(errno);

  return ml_string(name);
}



d230 1
a230 1
    unix_error(errno);
d243 1
a243 1
    unix_error(EINVAL);
d251 1
a251 1
    unix_error(errno);
d265 1
a265 1
    unix_error(EINVAL);
d273 1
a273 1
    unix_error(errno);
d290 1
a290 1
    unix_error(errno);
d293 1
a293 1
    unix_error(EINVAL);
d315 1
a315 1
    unix_error(errno);
d318 1
a318 1
    unix_error(EINVAL);
d342 1
a342 1
    unix_error(errno);
d345 1
a345 1
    unix_error(EINVAL);
d365 1
a365 1
    unix_error(errno);
d378 1
a378 1
    unix_error(errno);
d391 1
a391 1
    unix_error(errno);
d409 1
a409 1
    unix_error(errno);
d413 1
a413 1
      unix_error(errno);
d417 1
a417 1
      unix_error(errno);
d431 1
a431 1
    unix_error(errno);
a439 141
#define stat_offset_atime   0
#define stat_offset_blksize (stat_offset_atime+1)
#define stat_offset_blocks  (stat_offset_blksize+1)
#define stat_offset_ctime   (stat_offset_blocks+1)
#define stat_offset_dev     (stat_offset_ctime+1)
#define stat_offset_gid     (stat_offset_dev+1)
#define stat_offset_ino     (stat_offset_gid+1)
#define stat_offset_mode    (stat_offset_ino+1)
#define stat_offset_mtime   (stat_offset_mode+1)
#define stat_offset_nlink   (stat_offset_mtime+1)
#define stat_offset_rdev    (stat_offset_nlink+1)
#define stat_offset_size    (stat_offset_rdev+1)
#define stat_offset_uid     (stat_offset_size+1)
#define stat_size           (stat_offset_uid+1)

static mlval unix_return_stat (struct stat * st)
{
  mlval atime, ctime, mtime, result;

  result = allocate_record(stat_size);

  atime = mlw_time_make(st->st_atime, 0);
  ctime = mlw_time_make(st->st_ctime, 0);
  mtime = mlw_time_make(st->st_mtime, 0);

  /* Lexical ordering for fields -- the result is a record with name fields.
   *
   * atime      file last access time
   * blksize    preferred blocksize for file system I/O
   * blocks     actual number of blocks allocated
   * ctime      file last status change time
   * dev        device file resides on
   * gid        group ID of owner
   * ino        the file serial number
   * mode       file mode
   * mtime      file last modify time
   * nlink      number of hard links to the file
   * rdev       the device identifier (special files only)
   * size       total size of file, in bytes
   * uid        user ID of owner
   */

  FIELD(result, stat_offset_atime)=   atime;
  FIELD(result, stat_offset_blksize)= MLINT(st->st_blksize);
  FIELD(result, stat_offset_blocks)=  MLINT(st->st_blocks);
  FIELD(result, stat_offset_ctime)=   ctime;
  FIELD(result, stat_offset_dev)=     MLINT(st->st_dev);
  FIELD(result, stat_offset_gid)=     MLINT(st->st_gid);
  FIELD(result, stat_offset_ino)=     MLINT(st->st_ino);
  FIELD(result, stat_offset_mode)=    MLINT(st->st_mode);
  FIELD(result, stat_offset_mtime)=   mtime;
  FIELD(result, stat_offset_nlink)=   MLINT(st->st_nlink);
  FIELD(result, stat_offset_rdev)=    MLINT(st->st_rdev);
  FIELD(result, stat_offset_size)=    MLINT(st->st_size);
  FIELD(result, stat_offset_uid)=     MLINT(st->st_uid);

  return result;
}



static mlval unix_fstat (mlval arg)
{
  struct stat st;
  int fd = CINT (arg);

  if (fstat (fd, &st))
    unix_error(errno);

  return unix_return_stat(&st);
}


static mlval unix_stat (mlval arg)
{
  struct stat st;
  char const * path = CSTRING(arg);

  if (stat(path, &st))
    unix_error(errno);

  return unix_return_stat(&st);
}


static mlval unix_lstat (mlval arg)
{
  struct stat st;
  char const * path = CSTRING(arg);

  if (lstat(path, &st))
    unix_error(errno);

  return unix_return_stat(&st);
}



static mlval unix_st_isdir(mlval arg)
{
  return S_ISDIR(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_ischr(mlval arg)
{
  return S_ISCHR(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_isblk(mlval arg)
{
  return S_ISBLK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_isreg(mlval arg)
{
  return S_ISREG(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_isfifo(mlval arg)
{
  return S_ISFIFO(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_islink(mlval arg)
{
  return S_ISLNK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}


static mlval unix_st_issock(mlval arg)
{
  return S_ISSOCK(CWORD(FIELD(arg, stat_offset_mode))) ? MLTRUE : MLFALSE;
}



d451 1
a451 1
    unix_error(e);
d500 1
a500 1
  unix_error(errno);
d516 1
a516 1
  unix_error(errno);
d532 1
a532 1
  unix_error(errno);
d571 1
a571 1
    unix_error(e);
d573 1
a573 1
    unix_error(exec_errno);
d599 1
a599 1
    unix_error(e);
d601 1
a601 1
    unix_error(exec_errno);
d628 1
a628 1
    unix_error(e);
d630 1
a630 1
    unix_error(exec_errno);
d686 1
a686 1
    unix_error(0);
d714 1
a714 1
    unix_error(0);
d726 1
a726 1
    unix_error(0);
d733 90
a822 1
static mlval unix_mkdir(mlval arg)
d825 1
a825 1
    unix_error(errno);
d832 18
a849 1
static mlval unix_rmdir(mlval arg)
d852 1
a852 1
    unix_error(errno);
d859 126
a984 1
static mlval unix_opendir(mlval arg)
d986 71
a1056 1
  DIR *dir = opendir(CSTRING(arg));
d1058 2
a1059 2
  if (dir == NULL)
    unix_error(errno);
d1061 1
a1061 1
  return (mlval)dir;
d1066 4
a1069 1
static mlval unix_readdir(mlval arg)
d1071 17
a1087 1
  struct dirent *d;
d1089 43
a1131 6
  errno = 0;
  if ((d= readdir((DIR *)arg)) == NULL) {
    if (errno)
      unix_error(errno);
    else
      return ml_string("");	/* by analogy with lookahead */
d1133 1
a1133 1
  return ml_string(d->d_name);
d1138 9
a1146 1
static mlval unix_rewinddir(mlval arg)
d1148 8
a1155 1
  rewinddir((DIR *)arg);
d1161 5
a1165 1
static mlval unix_closedir(mlval arg)
d1167 3
a1169 2
  if (closedir((DIR *)arg))
    unix_error(errno);
d1175 1
d1216 1
a1216 1
    unix_error(errno);
d1235 1
a1235 1
    unix_error(errno);
d1275 1
a1275 1
    unix_error(errno);
a1295 1

d1298 2
a1300 3
  env_function("system os unix getwd", unix_getwd);
  env_function("system os unix setwd", unix_setwd);
  env_function("system os unix realpath", unix_realpath);
d1303 33
a1335 4
  env_function("system os unix close", unix_close);
  env_function("system os unix unlink", unix_unlink);
  env_function("system os unix rename", unix_rename);
  env_function("system os unix tmpname", unix_tmpname);
a1339 11
  env_function("system os unix stat", unix_stat);
  env_function("system os unix fstat", unix_fstat);
  env_function("system os unix lstat", unix_lstat);
  env_function("system os unix st isdir", unix_st_isdir);
  env_function("system os unix st ischr", unix_st_ischr);
  env_function("system os unix st isblk", unix_st_isblk);
  env_function("system os unix st ischr", unix_st_ischr);
  env_function("system os unix st isreg", unix_st_isreg);
  env_function("system os unix st isfifo", unix_st_isfifo);
  env_function("system os unix st islink", unix_st_islink);
  env_function("system os unix st issock", unix_st_issock);
a1358 6
  env_function("system os unix rmdir", unix_rmdir);
  env_function("system os unix mkdir", unix_mkdir);
  env_function("system os unix opendir", unix_opendir);
  env_function("system os unix readdir", unix_readdir);
  env_function("system os unix rewinddir", unix_rewinddir);
  env_function("system os unix closedir", unix_closedir);
d1385 16
@


1.3
log
@Add various routines to support OS_PROCESS as defined in the latest basis.
@
text
@d20 6
d30 3
d63 1
a63 1
#include "values.h"
d84 1
a84 1
#include "mltime.h"
d93 3
d113 1
a113 1
  exn_raise_syserr(strerror(i), MLINT(i));
d519 3
a521 3
  atime = ml_time_t(st->st_atime);
  ctime = ml_time_t(st->st_ctime);
  mtime = ml_time_t(st->st_mtime);
d598 1
a598 1
  return MLINT(S_ISDIR(CWORD(FIELD(arg, stat_offset_mode))));
d604 1
a604 1
  return MLINT(S_ISCHR(CWORD(FIELD(arg, stat_offset_mode))));
d610 1
a610 1
  return MLINT(S_ISBLK(CWORD(FIELD(arg, stat_offset_mode))));
d616 1
a616 1
  return MLINT(S_ISREG(CWORD(FIELD(arg, stat_offset_mode))));
d622 1
a622 1
  return MLINT(S_ISFIFO(CWORD(FIELD(arg, stat_offset_mode))));
d628 1
a628 1
  return MLINT(S_ISLNK(CWORD(FIELD(arg, stat_offset_mode))));
d634 1
a634 1
  return MLINT(S_ISSOCK(CWORD(FIELD(arg, stat_offset_mode))));
d1063 1
d1069 1
a1069 1
    return MLINT(0);		/* NONE */
d1074 1
a1074 3
    some_value= allocate_record(2);
    FIELD(some_value, 0)= MLINT(1);
    FIELD(some_value, 1)= tagged_value;
d1076 1
a1076 1
    return some_value;		/* SOME value */
d1082 34
d1177 2
d1196 3
@


1.2
log
@Rationalise exception handling so that all routines that raise
exceptions raise the same one -- this being one that is compatible
with OS.SysErr as defined in the latest basis.
@
text
@d20 3
d24 5
a84 1

a141 1

d1031 42
d1127 4
@


1.1
log
@new unit
This used to be src/rts/src/OS/common/unix.c
@
text
@d20 5
a24 1
 * $Log: src:OS:common:unix.c,v $
d47 1
a47 1
#include "allocator.h"
d49 4
a52 4
#include "exceptions.h"
#include "utils.h"		/* for alloc */
#include "environment.h"	/* for env_function ... etc. */
#include "global.h"		/* for declare_global */
d57 5
a61 5
#include <unistd.h>		/* for read, write, ... etc. */
#include <sys/param.h>		/* for MAXPATHLEN, realpath */
#include <sys/types.h>		/* for many of the following ... */
#include <sys/stat.h>		/* for mkdir, open */
#include <dirent.h>		/* for opendir, ... etc. */
d63 2
a64 2
#include <sys/ioctl.h>		/* for FIONREAD */
#include <pwd.h>		/* for struct passwd */
a80 1
mlval unix_exn_ref_unix;
d91 1
d94 1
a94 1
  exn_raise_string(unix_exn_ref_unix, strerror(i));
d99 1
d125 1
a125 1
    exn_raise_string(perv_exn_ref_io, "Error in getcwd()");
d137 1
a137 1
    exn_raise_string(perv_exn_ref_io, buffer);
d235 1
a235 1
  if (unlink(CSTRING(arg)) == -1)
d243 21
d480 16
a495 1
static mlval unix_stat (mlval arg)
a496 1
  struct stat st;
a497 4
  int fd = CINT (arg);

  if (fstat (fd, &st))
    unix_error(errno);
d499 1
a499 1
  result = allocate_record(13);
d501 3
a503 3
  atime = ml_time_t(st.st_atime);
  ctime = ml_time_t(st.st_ctime);
  mtime = ml_time_t(st.st_mtime);
d522 13
a534 13
  FIELD(result,  0) = atime;
  FIELD(result,  1) = MLINT(st.st_blksize);
  FIELD(result,  2) = MLINT(st.st_blocks);
  FIELD(result,  3) = ctime;
  FIELD(result,  4) = MLINT(st.st_dev);
  FIELD(result,  5) = MLINT(st.st_gid);
  FIELD(result,  6) = MLINT(st.st_ino);
  FIELD(result,  7) = MLINT(st.st_mode);
  FIELD(result,  8) = mtime;
  FIELD(result,  9) = MLINT(st.st_nlink);
  FIELD(result, 10) = MLINT(st.st_rdev);
  FIELD(result, 11) = MLINT(st.st_size);
  FIELD(result, 12) = MLINT(st.st_uid);
d541 80
d962 8
d1035 2
d1042 10
d1075 1
a1091 1
  unix_exn_ref_unix = ref(exn_default);
a1092 1
  env_value("system os unix exception Unix", unix_exn_ref_unix);
a1093 2
  declare_global("system os unix exception Unix", &unix_exn_ref_unix,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
@
