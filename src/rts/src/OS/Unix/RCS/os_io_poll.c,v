head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.1
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.7.3
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.6.6.1.1.1.1
	MLWorks_workspace_97:1.7.2
	MLWorks_dt_wizard:1.7.1
	MLWorks_11c0_1997_09_09:1.6.6.1.1.1
	MLWorks_10r3:1.6.6.1.3
	MLWorks_10r2_551:1.6.6.1.2
	MLWorks_11:1.6.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.6.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.6.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.6
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MM_ML_release_korma_1997_04_01:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.4.1.1
	MLWorks_gui_1996_12_18:1.6.5
	MLWorks_1_0_Win32_1996_12_17:1.6.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	JFHrts:1.6.3
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.5.3
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.8
date	98.02.23.18.47.31;	author jont;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	97.05.22.08.43.25;	author johnh;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1;
next	1.6;

1.6
date	96.10.24.08.36.21;	author stephenb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1;
next	1.5;

1.5
date	96.08.06.13.15.02;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	96.07.10.09.53.00;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.07.04.13.20.33;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.23.14.13.25;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.05.07.11.36.09;	author stephenb;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.23.09;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.13.18;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.10.17.11.32.37;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.12.58.30;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.15.08.27;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.16.08;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.10.02.52;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.17.17.54.33;	author hope;	state Exp;
branches
	1.6.4.1.1.1;
next	;

1.6.4.1.1.1
date	97.02.24.11.45.39;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.12.18.09.49.08;	author hope;	state Exp;
branches;
next	;

1.6.6.1
date	97.05.12.10.41.33;	author hope;	state Exp;
branches
	1.6.6.1.1.1
	1.6.6.1.2.1
	1.6.6.1.3.1;
next	;

1.6.6.1.1.1
date	97.07.28.18.26.46;	author daveb;	state Exp;
branches
	1.6.6.1.1.1.1.1;
next	;

1.6.6.1.1.1.1.1
date	97.10.07.11.52.40;	author jkbrook;	state Exp;
branches;
next	;

1.6.6.1.2.1
date	97.09.08.17.19.55;	author daveb;	state Exp;
branches;
next	;

1.6.6.1.3.1
date	97.09.09.14.16.02;	author daveb;	state Exp;
branches;
next	;

1.7.1.1
date	97.09.10.19.33.27;	author brucem;	state Exp;
branches;
next	;

1.7.2.1
date	97.09.11.21.02.39;	author daveb;	state Exp;
branches;
next	;

1.7.3.1
date	97.10.31.13.45.29;	author nickb;	state Exp;
branches;
next	;

1.8.1.1
date	99.04.01.18.01.56;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.8
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@/* Copyright (C) 1996 Harlequin Ltd
 *
 * Implements most of OS.IO.poll using poll.
 *
 * This would have been pushed into rts/src/OS/Unix/unix.c were it not for
 * the fact that Linux does not support poll, it only has select and so
 * needs a completely different implementation.
 *
 * Unless this implementation is being overriden by an OS specific version
 * (as it is under Linux), you will need to create the file
 * rts/src/OS/$OS/os_io_poll_local.h to hold any OS specific declarations. 
 * For example, under SunOS, neither poll or strerror are declared in any
 * header file, so they need to be declared in os_io_poll_local.h.
 *
 * Given that os_io_poll_local.h tends to be empty for other Unix platforms
 * then with hindsight, it would probably be better to define a default
 * os_io_poll_local.h which contains no declarations in this directory.
 * Then it would only be necessary to create one in the OS specific directory
 * if it really did require any declarations (i.e. currently SunOS).
 *
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Unix:os_io_poll.c,v $
 * Revision 1.7  1997/05/22  08:43:25  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
 * Revision 1.5  1996/08/06  13:15:02  stephenb
 * Update to gcc-2.7.2: replace strings.h with string.h
 *
 * Revision 1.4  1996/07/10  09:53:00  stephenb
 * Add more documentation and also optimise the root declaration
 * stuff so that declare/retract_root are not unnecessarily called.
 *
 * Revision 1.3  1996/07/04  13:20:33  stephenb
 * Fix #1456 - add declare/retract roots where necessary.
 *
 * Revision 1.2  1996/05/23  14:13:25  stephenb
 * Various changes to bring it into line with a post March 1996 basis spec.
 * These include: removing pollErr, introducing pollPri and isPri and making
 * poll raise SysErr if there are any errors.
 *
 * Revision 1.1  1996/05/07  11:36:09  stephenb
 * new unit
 *
 */

#include <assert.h>
#include <stropts.h>		/* INFTIM */
#include <poll.h>		/* struct pollfd */
#include <errno.h>		/* errno */
#include <string.h>		/* strerror */
#include "values.h"		/* FIELD, MLTAIL, cons ... etc.*/
#include "exceptions.h"		/* exn_raise_syserr */
#include "environment.h"	/* env_function ... etc. */
#include "global.h"		/* declare_global */
#include "allocator.h"		/* allocate_record, ml_string */
#include "gc.h"			/* declare_root */
#include "alloc.h"		/* malloc, free */
#include "time_date.h"		/* mlw_time_make,mlw_time_sec,mlw_time_usec */
#include "os_io_poll_local.h"
#include "os_io_poll.h"		/* os_poll_io_init */



/* Some macros which partially hide the internal structure of
 * poll_desc and poll_info as defined in unix/_os_io.sml
 * Obviously you shouldn't alter the following without also
 * updating the datatype declarations in the above file.
 */
#define mlw_poll_desc_make() allocate_record(2)
#define mlw_poll_desc_fd(poll_desc) FIELD(poll_desc, 0)
#define mlw_poll_desc_events(poll_desc) FIELD(poll_desc, 1)

#define mlw_poll_info_make() allocate_record(2)
#define mlw_poll_info_desc(poll_info) FIELD(poll_info, 0)
#define mlw_poll_info_revents(poll_info) FIELD(poll_info, 1)



/* An io_desc is currently implemented as an integer.
 * Because of this there is no need to declare as a root
 * any io_desc that is an argument to a function in which
 * any allocation is done.  However, to ensure that the
 * code doesn't break in mysterious ways should the 
 * structure of an io_desc change, the following should
 * be sprinkled liberally around the code to ensure that
 * if the representation does change we get to know about
 * it here straight away.
 */
#define mlw_os_io_poll_is_io_desc(arg) (!MLVALISPTR(arg))



/*
 * Implements OS.IO.pollDesc: io_desc -> poll_desc option
 *
 * XXX: Currently makes no attempt to check if the descriptor is suitable
 * for polling.  In a private message Reppy suggested that fstat could
 * be used to determine if the descriptor is suitable.
 */
static mlval mlw_os_io_poll_desc(mlval arg)
{
  mlval poll_desc;

  assert(mlw_os_io_poll_is_io_desc(arg));
  poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(poll_desc)= arg;
  mlw_poll_desc_events(poll_desc)= MLINT(0);

  return mlw_option_make_some(poll_desc);
}




/*
 * OS.IO.pollIn: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_in(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));

  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|POLLIN);
  return new_poll_desc;
}




/*
 * OS.IO.pollOut: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_out(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;
  
  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|POLLOUT);
  return new_poll_desc;
}




/* Reppy didn't give an explicit description of what "priority" means.
 * This could include POLLWRBAND and POLLRDBAND but since SunOS
 * doesn't support them (and I can't be bothered to set up an #ifdef
 * or separate header file for this one case) I'm taking it to mean
 * high priority only ... - stephenb
 */
#define mlw_event_priority POLLPRI



/*
 * OS.IO.pollPri: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_pri(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));

  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_event_priority);
  return new_poll_desc;
}



/*
 * OS.IO.poll presents a list of descriptors but the poll operation
 * expects an array of descriptors.  Therefore, the following implements a 
 * stretchy array of descriptors which makes the conversion process 
 * simpler.  Note that to avoid leaking or allocating/deallocating on
 * every call, a static fixed sized buffer is initially used and this
 * flips to a dynamically allocated one if the buffer overflows.
 */

#define pollfd_buffer_init_max_elems 10
static struct pollfd pollfd_default_buffer[pollfd_buffer_init_max_elems];
static size_t pollfd_buffer_max_elems= pollfd_buffer_init_max_elems;
static size_t pollfd_buffer_nelems=    pollfd_buffer_init_max_elems;
static struct pollfd * pollfd_buffer=  pollfd_default_buffer;


static void pollfd_buffer_open(void)
{
  /* this is a nop since all the variables are initialised statically
   * and then maintained by pollfd_buffer_and and pollfd_buffer_close
   */
  assert(pollfd_buffer_nelems <= pollfd_buffer_max_elems);
}




static void pollfd_buffer_add(int fd, int events)
{
  if (pollfd_buffer_nelems == pollfd_buffer_max_elems) {
    size_t new_max;
    struct pollfd * new_buffer;

    if (pollfd_buffer_nelems == pollfd_buffer_init_max_elems) {
      new_max= pollfd_buffer_init_max_elems*2;
      if ((new_buffer= (struct pollfd *)malloc(new_max*sizeof(struct pollfd))) == 0) {
	pollfd_buffer_nelems= 0;
	exn_raise_syserr(ml_string(strerror(errno)), errno);
      }
      memcpy(new_buffer, pollfd_buffer, pollfd_buffer_init_max_elems*sizeof(struct pollfd));

    } else {
      new_max= pollfd_buffer_max_elems * 2;
      new_buffer= (struct pollfd *)realloc(pollfd_buffer, new_max*sizeof(struct pollfd));
      if (new_buffer == (struct pollfd *)0) {
	int saved_errno= errno;
	free(pollfd_buffer);
	pollfd_buffer= pollfd_default_buffer;
	pollfd_buffer_nelems= 0;
	pollfd_buffer_max_elems= pollfd_buffer_init_max_elems;
	exn_raise_syserr(ml_string(strerror(saved_errno)), saved_errno);
      }
    }

    pollfd_buffer= new_buffer;
    pollfd_buffer_max_elems= new_max;
  }

  pollfd_buffer[pollfd_buffer_nelems].fd= fd;
  pollfd_buffer[pollfd_buffer_nelems].events= events;
  pollfd_buffer[pollfd_buffer_nelems].revents= 0;
  pollfd_buffer_nelems += 1;
}




static void pollfd_buffer_close(void)
{
  if (pollfd_buffer != pollfd_default_buffer) {
    free(pollfd_buffer);
    pollfd_buffer= pollfd_default_buffer;
    pollfd_buffer_max_elems= pollfd_buffer_init_max_elems;
  }
  pollfd_buffer_nelems= 0;
}





/*
 * OS.IO.poll: (poll_desc list * Time.time option) -> poll_info list
 *
 */
static mlval mlw_os_io_poll(mlval arg)
{
  mlval poll_descs= FIELD(arg, 0);
  mlval optional_timeout= FIELD(arg, 1);
  int   msec_timeout;
  mlval poll_infos= MLNIL;
  mlval l;
  int status;

  pollfd_buffer_open();

  for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l)) {
    mlval poll_desc= MLHEAD(l);
    int fd= CINT(mlw_poll_desc_fd(poll_desc));
    int events= CINT(mlw_poll_desc_events(poll_desc));
    pollfd_buffer_add(fd, events);
  }

  if (mlw_option_is_none(optional_timeout)) {
    msec_timeout= INFTIM;
  } else {
    mlval timeout= mlw_option_some(optional_timeout);
    long secs= mlw_time_sec(timeout);
    long usecs= mlw_time_usec(timeout);
    msec_timeout= secs*mlw_time_msecs_per_sec
                + usecs/(mlw_time_usecs_per_sec/mlw_time_msecs_per_sec);
  }

  status= poll(pollfd_buffer, pollfd_buffer_nelems, msec_timeout);
  if (status < 0) {
    exn_raise_syserr(ml_string(strerror(errno)), errno);
  } else if (status > 0) {
    size_t i= 0;
    declare_root(&l, 0);
    declare_root(&poll_infos, 0);
    for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l), i += 1) {
      short revents= pollfd_buffer[i].revents;
      if (revents & (POLLERR|POLLHUP|POLLNVAL)) {
	/* an error so clean up and raise an exception */
	retract_root(&l);
	retract_root(&poll_infos);
	pollfd_buffer_close();
	exn_raise_syserr(ml_string("OS.IO.poll error"), 0);
      } else if (revents != 0) {
	mlval poll_info;
	poll_info= mlw_poll_info_make();
	mlw_poll_info_desc(poll_info)= MLHEAD(l);
	mlw_poll_info_revents(poll_info)= MLINT(revents);
	poll_infos= cons(poll_info, poll_infos);
      }
    }
    retract_root(&poll_infos);
    retract_root(&l);
  } else {
    /* timeout or no descriptors so just return the empty list */
  }

  pollfd_buffer_close();
  return poll_infos;
}




/*
 * OS.IO.isIn: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_in(mlval arg)
{
  short revents= CINT(mlw_poll_info_revents(arg));
  return (revents&POLLIN) ? MLTRUE : MLFALSE;
}



/*
 * OS.IO.isOut: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_out(mlval arg)
{
  short revents= CINT(mlw_poll_info_revents(arg));
  return (revents&POLLOUT) ? MLTRUE : MLFALSE;
}



/*
 * OS.IO.isPri: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_pri(mlval arg)
{
  short revents= CINT(mlw_poll_info_revents(arg));
  return (revents&mlw_event_priority) ? MLTRUE : MLFALSE;
}




void mlw_os_io_poll_init(void)
{
  env_function("OS.IO.pollDesc", mlw_os_io_poll_desc);
  env_function("OS.IO.pollIn",   mlw_os_io_poll_in);
  env_function("OS.IO.pollOut",  mlw_os_io_poll_out);
  env_function("OS.IO.pollPri",  mlw_os_io_poll_pri);
  env_function("OS.IO.poll",     mlw_os_io_poll);
  env_function("OS.IO.isIn",     mlw_os_io_is_in);
  env_function("OS.IO.isOut",    mlw_os_io_is_out);
  env_function("OS.IO.isPri",    mlw_os_io_is_pri);
}
@


1.8.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a25 5
 * Revision 1.8  1998/02/23  18:47:31  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
@


1.7
log
@[Bug #01702]
Changed definition of exn_raise_syserr.
@
text
@d26 4
d312 2
a313 2
    declare_root(&l);
    declare_root(&poll_infos);
@


1.7.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a25 4
 * Revision 1.7  1997/05/22  08:43:25  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.7.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a25 4
 * Revision 1.7  1997/05/22  08:43:25  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.7.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a25 4
 * Revision 1.7  1997/05/22  08:43:25  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.6
log
@[Bug #1701]
mlw_os_io_poll_desc: remove redundant declare/retract_root.
@
text
@d26 4
d59 1
a59 1
#include "allocator.h"		/* allocate_record */
d227 1
a227 1
	exn_raise_syserr(strerror(errno), errno);
d240 1
a240 1
	exn_raise_syserr(strerror(saved_errno), saved_errno);
d305 1
a305 1
    exn_raise_syserr(strerror(errno), errno);
d317 1
a317 1
	exn_raise_syserr("OS.IO.poll error", 0);
@


1.6.6.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a25 3
 * Revision 1.6.6.1  1997/05/12  10:41:33  hope
 * branched from 1.6
 *
@


1.6.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a25 3
 * Revision 1.6.6.1  1997/05/12  10:41:33  hope
 * branched from 1.6
 *
@


1.6.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a25 3
 * Revision 1.6.6.1  1997/05/12  10:41:33  hope
 * branched from 1.6
 *
@


1.6.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a25 3
 * Revision 1.6.6.1.1.1  1997/07/28  18:26:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.4.1.1.1
log
@branched from 1.6.4.1
@
text
@a25 3
 * Revision 1.6.4.1  1996/12/17  17:54:33  hope
 * branched from 1.6
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a25 4
 * Revision 1.6  1996/10/24  08:36:21  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a25 3
 * Revision 1.6.1.1  1996/11/14  12:58:30  hope
 * branched from 1.6
 *
@


1.5
log
@Update to gcc-2.7.2: replace strings.h with string.h
@
text
@d26 3
d102 1
a102 1
  mlval option, poll_desc;
d109 1
a109 5
  declare_root(&poll_desc);
  option= mlw_option_make_some(poll_desc);
  retract_root(&poll_desc);

  return option;
@


1.5.3.1
log
@branched from 1.5
@
text
@a25 3
 * Revision 1.5  1996/08/06  13:15:02  stephenb
 * Update to gcc-2.7.2: replace strings.h with string.h
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a25 3
 * Revision 1.5  1996/08/06  13:15:02  stephenb
 * Update to gcc-2.7.2: replace strings.h with string.h
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a25 3
 * Revision 1.5  1996/08/06  13:15:02  stephenb
 * Update to gcc-2.7.2: replace strings.h with string.h
 *
@


1.4
log
@Add more documentation and also optimise the root declaration
stuff so that declare/retract_root are not unnecessarily called.
@
text
@d26 4
d47 1
a47 1
#include <strings.h>		/* strerror */
@


1.3
log
@Fix #1456 - add declare/retract roots where necessary.
@
text
@d11 11
a21 2
 * rts/src/OS/$ARCH/$OS/os_io_poll_local.h
 * 
d26 3
d57 4
a60 4
/*
 * datatype event_set = EVENT_SET of int
 * datatype poll_desc = POLL_DESC of io_desc * event_set
 * datatype poll_info = POLL_INFO of poll_desc * event_set
d72 14
d97 1
a97 1
  declare_root(&arg);
a99 1
  retract_root(&arg);
d119 1
d122 2
a123 1
  declare_root(&arg);
d125 1
a125 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a126 1
  retract_root(&arg);
d140 1
d142 2
a143 1
  declare_root(&arg);
d145 1
a145 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a146 1
  retract_root(&arg);
d152 1
d157 1
a157 1
 * high priority only ...
d170 1
d172 3
a174 1
  declare_root(&arg);
d176 1
a176 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a177 1
  retract_root(&arg);
d301 2
d306 4
a312 2
	declare_root(&l);
	declare_root(&poll_infos);
a313 1
	retract_root(&poll_infos);
a316 1
	retract_root(&l);
d319 2
@


1.2
log
@Various changes to bring it into line with a post March 1996 basis spec.
These include: removing pollErr, introducing pollPri and isPri and making
poll raise SysErr if there are any errors.
@
text
@d17 5
d50 1
a50 1
#define mlw_make_poll_desc() allocate_record(2)
d54 1
a54 1
#define mlw_make_poll_info() allocate_record(2)
d71 2
a72 1
  poll_desc= mlw_make_poll_desc();
d74 1
d94 4
a97 1
  mlval new_poll_desc= mlw_make_poll_desc();
d100 1
d114 3
a116 1
  mlval new_poll_desc= mlw_make_poll_desc();
d119 1
d142 3
a144 1
  mlval new_poll_desc= mlw_make_poll_desc();
d147 1
d276 5
a280 1
	mlval poll_info= mlw_make_poll_info();
d284 1
@


1.1
log
@new unit
@
text
@d16 4
a19 1
 * $Log$
d59 2
a60 1
 * for polling.
d111 10
d122 1
a122 1
 * OS.IO.pollErr: poll_desc -> poll_desc
a123 3
 * This just returns the descriptor because detection of errors
 * is done by default with poll -- i.e. you don't have to explicitly check
 * for it as you do with select.
d125 1
a125 1
static mlval mlw_os_io_poll_err(mlval arg)
d127 5
a131 1
  return arg;
d255 9
a263 4
      mlval poll_info= mlw_make_poll_info();
      mlw_poll_info_desc(poll_info)= MLHEAD(l);
      mlw_poll_info_revents(poll_info)= MLINT(pollfd_buffer[i].revents);
      poll_infos= cons(poll_info, poll_infos);
d301 1
a301 1
 * OS.IO.isErr: poll_info -> bool
d304 1
a304 1
static mlval mlw_os_io_is_err(mlval arg)
d307 1
a307 1
  return (revents&POLLERR) ? MLTRUE : MLFALSE;
d312 2
a313 1
extern void mlw_os_io_poll_init(void)
d318 1
a318 1
  env_function("OS.IO.pollErr",  mlw_os_io_poll_err);
d322 1
a322 1
  env_function("OS.IO.isErr",    mlw_os_io_is_err);
@
