head	1.16;
access;
symbols
	MLW_daveb_inline_1_4_99:1.16.1
	MLWorks_21c0_1999_03_25:1.16
	MLWorks_20c1_1998_08_20:1.12
	MLWorks_20c0_1998_08_04:1.12
	MLWorks_20b2c2_1998_06_19:1.12
	MLWorks_20b2_Windows_1998_06_12:1.12
	MLWorks_20b1c1_1998_05_07:1.12
	MLWorks_20b0_1998_04_07:1.12
	MLWorks_20b0_1998_03_20:1.12
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_MM_adapt:1.10.1
	MLWorks_20m1_1997_10_23:1.10
	MLWorks_11r1:1.8.8.1.1.1.1
	MLWorks_workspace_97:1.8.10
	MLWorks_dt_wizard:1.8.9
	MLWorks_11c0_1997_09_09:1.8.8.1.1.1
	MLWorks_10r3:1.8.8.1.3
	MLWorks_10r2_551:1.8.8.1.2
	MLWorks_11:1.8.8.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.8.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.8.8.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.8.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.8
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MM_ML_release_korma_1997_04_01:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.6.1.1
	MLWorks_gui_1996_12_18:1.8.7
	MLWorks_1_0_Win32_1996_12_17:1.8.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.8.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.8.3.1
	JFHrts:1.8.5
	MLWorks_1_0_Irix_1996_11_28:1.8.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.4
	MLWorks_1_0_Unix_1996_11_14:1.8.3
	MLWorks_Open_Beta2_1996_10_11:1.8.2
	MLWorks_License_dev:1.8.1
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.16
date	98.10.09.14.33.57;	author jont;	state Exp;
branches
	1.16.1.1;
next	1.15;

1.15
date	98.10.08.09.18.41;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	98.10.02.13.38.57;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	98.09.30.14.09.59;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	98.02.23.18.47.53;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	97.11.19.20.54.24;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	97.09.30.11.23.09;	author daveb;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	97.09.25.09.11.29;	author brucem;	state Exp;
branches;
next	1.8;

1.8
date	96.10.02.11.32.19;	author stephenb;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1
	1.8.6.1
	1.8.7.1
	1.8.8.1
	1.8.9.1
	1.8.10.1;
next	1.7;

1.7
date	96.07.29.13.55.13;	author stephenb;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	96.05.16.14.02.49;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.05.14.13.49.21;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	96.05.10.12.34.57;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.11.48.38;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.09.16.03.52;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.07.10.53.39;	author stephenb;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.24.24;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.10.07.16.14.43;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.17.11.34.09;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.11.14.12.59.49;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	96.11.28.15.09.50;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.11.22.18.17.37;	author hope;	state Exp;
branches;
next	;

1.8.5.1
date	96.12.17.10.04.20;	author hope;	state Exp;
branches;
next	;

1.8.6.1
date	96.12.17.17.55.55;	author hope;	state Exp;
branches
	1.8.6.1.1.1;
next	;

1.8.6.1.1.1
date	97.02.24.11.47.28;	author hope;	state Exp;
branches;
next	;

1.8.7.1
date	96.12.18.09.50.32;	author hope;	state Exp;
branches;
next	;

1.8.8.1
date	97.05.12.10.44.14;	author hope;	state Exp;
branches
	1.8.8.1.1.1
	1.8.8.1.2.1
	1.8.8.1.3.1;
next	;

1.8.8.1.1.1
date	97.07.28.18.26.23;	author daveb;	state Exp;
branches
	1.8.8.1.1.1.1.1;
next	;

1.8.8.1.1.1.1.1
date	97.10.07.11.52.14;	author jkbrook;	state Exp;
branches;
next	;

1.8.8.1.2.1
date	97.09.08.17.19.34;	author daveb;	state Exp;
branches;
next	;

1.8.8.1.3.1
date	97.09.09.14.15.42;	author daveb;	state Exp;
branches;
next	;

1.8.9.1
date	97.09.10.19.32.53;	author brucem;	state Exp;
branches;
next	;

1.8.10.1
date	97.09.11.21.02.09;	author daveb;	state Exp;
branches;
next	;

1.10.1.1
date	97.10.31.13.45.01;	author nickb;	state Exp;
branches;
next	;

1.16.1.1
date	99.04.01.18.01.37;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.16
log
@[Bug #30489]
Ensure we don't fault strftime results on empty formats
@
text
@/* Copyright 1996 The Harlequin Group Limited.  All rights reserved.
 *
 * Implements various parts of basis/time.sml and basis/date.sml
 *
 * Note that for all Unix varieties you will need to create 
 * rts/src/OS/$ARCH/$OS/time_date_local.h which contains a declaration
 * of the form 
 *
 *   extern int mlw_get_time_now(struct timeval *)
 *
 * which does the equivalent of gettimeofday.  Note the reason that
 * gettimeofday is not used directly is that it seems to have a different
 * prototype on each system, mlw_get_time_now is supposed to hide these
 * differences.
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Unix:time_date.c,v $
 * Revision 1.15  1998/10/08  09:18:41  jont
 * [Bug #70188]
 * Ensure Date.localOffset can cope with timezones ahead of GMT
 * ,
 *
 * Revision 1.14  1998/10/02  13:38:57  jont
 * [Bug #30487]
 * Modify functions dealing in seconds to use Int32
 *
 * Revision 1.13  1998/09/30  14:09:59  jont
 * [Bug #70108]
 * Add include of syscalls.h to get round problems in Red Hat 5 with struct timespec
 *
 * Revision 1.12  1998/02/23  18:47:53  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.11  1997/11/19  20:54:24  jont
 * [Bug #30085]
 * Add Time.start function to give value of Time.now when process started
 *
 * Revision 1.10  1997/09/30  11:23:09  daveb
 * [Bug #30269]
 * Added declare root to Bruce's change.
 *
 * Revision 1.9  1997/09/25  09:11:29  brucem
 * [Bug #30269]
 * Implement routines for revised Date structure.
 *
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
 * Revision 1.7  1996/07/29  13:55:13  stephenb
 * [Bug #1506]
 * mlw_time_sub: fixed the code that dealt with the case where
 * a_usecs < b_usecs -- the previous code was hopelessly wrong.
 *
 * Revision 1.6  1996/05/16  14:02:49  jont
 * Allow ML dates to have full year value, ie 19xx rather than xx
 *
 * Revision 1.5  1996/05/14  13:49:21  nickb
 * Remove my_asctime.
 *
 * Revision 1.4  1996/05/10  12:34:57  jont
 * Fix problem whereby mk_time fiddles with tm_isdst
 *
 * Revision 1.3  1996/05/10  11:48:38  stephenb
 * Fix the time conversion routines to take account of
 * * Unix starting years at 1900.
 * * mapping C months and weekdays into ML months and weekdays
 * * daylight savings time.
 *
 * Revision 1.2  1996/05/09  16:03:52  jont
 * Completing implementation of __date.sml
 *
 * Revision 1.1  1996/05/07  10:53:39  stephenb
 * new unit
 *
 */

#include "syscalls.h"
#include <assert.h>
#include <sys/time.h>		/* struct timeval, mktime, ... */
#include <limits.h>		/* LONG_MAX ... */
#include "alloc.h"		/* free */
#include "allocator.h"		/* allocate_real, allocate_record */
#include "date.h"		/* mlw_date_hour ... */
#include "exceptions.h"		/* exn_raise, perv_exn_ref_overflow */
#include "environment.h"	/* env_value ... */
#include "global.h"		/* declare_global */
#include "gc.h"			/* declare_root, retract_root */
#include "utils.h" 		/* alloc */
#include "values.h"		/* mlw_option_XXX */
#include "words.h"		/* word32_to_num and inverse */
#include "time_date.h"
#include "time_date_init.h"	/* mlw__get_time_now */
#include "time_date_local.h"




static mlval mlw_time_exn_ref_time;
static mlval mlw_date_exn_ref_date;



/* The tv_sec field is a full 32-bit value which can't fit into an ML int
 * so it is split across two fields.  The following defines how many of
 * the low bits of the tv_sec field are stored in the first of the two
 * fields. 
 *
 * The current value is historic and is taken directly from 
 * rts/src/OS/{Irix,Linux,Solaris,SunOS}/time.c
 */

#define mlw_time_low_bits 24


extern long mlw_time_sec(mlval arg)
{
  unsigned long hi= CWORD(FIELD(arg, 0));
  unsigned long lo= CWORD(FIELD(arg, 1));
  long secs= (long)((hi<<mlw_time_low_bits)|lo);
  return secs;
}



extern long mlw_time_usec(mlval arg)
{
  long usec= CINT(FIELD(arg, 2));
  return usec;
}



extern mlval mlw_time_make(long sec, long usec)
{
  mlval t= allocate_record(3);
  unsigned long hi= ((unsigned long)sec) >> mlw_time_low_bits;
  unsigned long lo= ((unsigned long)sec) & ((1<<(mlw_time_low_bits+1))-1);
  FIELD(t, 0)= MLINT(hi);
  FIELD(t, 1)= MLINT(lo);
  FIELD(t, 2)= MLINT(usec);
  return t;
}



/*
 * Time.fromReal: real -> time
 * raises: Time
 */
static mlval mlw_time_from_real(mlval arg)
{
  double time= GETREAL(arg);
  long secs, usecs;

  if (time < 0 || time > LONG_MAX)
    exn_raise(mlw_time_exn_ref_time);

  secs= time;
  usecs= (long)((time - (double)secs)*1000000.0);
  return mlw_time_make(secs, usecs);
}



/*
 * Time.toReal: time -> real
 */
static mlval mlw_time_to_real(mlval arg)
{
  long secs= mlw_time_sec(arg);
  long usecs= mlw_time_usec(arg);
  mlval time= allocate_real();
  (void)SETREAL(time, secs+usecs/1000000.0);
  return time;
}



/*
 * Time.toSeconds: time -> LargeInt.int
 * Raises: Overflow
 */
static mlval mlw_time_to_secs(mlval arg)
{
  mlval result = allocate_word32();
  long secs= mlw_time_sec(arg);
  if (secs > INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  num_to_word32((word)secs, result);
  return result;
  return MLINT(secs);
}




/*
 * Time.toMilliseconds: time -> LargeInt.int
 * Raises: Overflow
 */
static mlval mlw_time_to_msecs(mlval arg)
{
  mlval result = allocate_word32();
  long secs= mlw_time_sec(arg);
  long usecs= mlw_time_usec(arg);
  long msecs= usecs/mlw_time_msecs_per_sec;
  if (secs > INT_MAX/mlw_time_msecs_per_sec)
    exn_raise(perv_exn_ref_overflow);
  if (msecs > (INT_MAX - secs*mlw_time_msecs_per_sec))
    exn_raise(perv_exn_ref_overflow);
  num_to_word32((word)(secs*1000+msecs), result);
  return result;
}



/*
 * Time.toMicroseconds: time -> LargeInt.int
 * Raises: Overflow
 */
static mlval mlw_time_to_usecs(mlval arg)
{
  mlval result = allocate_word32();
  long secs= mlw_time_sec(arg);
  long usecs= mlw_time_usec(arg);

  if (secs > INT_MAX/mlw_time_usecs_per_sec)
    exn_raise(perv_exn_ref_overflow);

  if (usecs > (INT_MAX - secs*mlw_time_usecs_per_sec))
    exn_raise(perv_exn_ref_overflow);

  num_to_word32((word)(secs*mlw_time_usecs_per_sec+usecs), result);
  return result;
}



/*
 * Time.fromSeconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_secs(mlval arg)
{
  long secs= word32_to_num(arg);
  if (secs < 0)
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_make(secs, 0);
}



/*
 * Time.fromMilliseconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_msecs(mlval arg)
{
  long msecs= word32_to_num(arg);
  if (msecs < 0) {
    exn_raise(mlw_time_exn_ref_time);
  } else {
    long secs=  msecs/mlw_time_msecs_per_sec;
    long usecs= (msecs%mlw_time_msecs_per_sec)*mlw_time_msecs_per_sec;
    return mlw_time_make(secs, usecs);
  }
}



/*
 * Time.fromMicroseconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_usecs(mlval arg)
{
  long usecs= word32_to_num(arg);
  if (usecs < 0) {
    exn_raise(mlw_time_exn_ref_time);
  } else {
    long secs=  usecs/mlw_time_usecs_per_sec;
    long normalised_usecs= usecs%mlw_time_usecs_per_sec;
    return mlw_time_make(secs, normalised_usecs);
  }
}



/*
 * Time.+: (time * time) -> time
 * Raises: Overflow
 */
static mlval mlw_time_add(mlval arg)
{
  long a_sec= mlw_time_sec(FIELD(arg, 0));
  long a_usec= mlw_time_usec(FIELD(arg, 0));
  long b_sec= mlw_time_sec(FIELD(arg, 1));
  long b_usec= mlw_time_usec(FIELD(arg, 1));
  long usecs= a_usec + b_usec;
  long secs= b_sec;


  /* cheaper than but equivalent to:
   *    secs += usecs/mlw_time_usecs_per_sec;
   *    usecs %= mlw_time_usecs_per_sec
   */
  if (usecs > mlw_time_usecs_per_sec) {
    secs += 1;  usecs -= mlw_time_usecs_per_sec;
  }

  if ((LONG_MAX - a_sec) < secs)
    exn_raise(perv_exn_ref_overflow);
  
  return mlw_time_make(a_sec+secs, usecs);
}


/*
 * Time.-: (time * time) -> time
 * Raises: Time
 */
static mlval mlw_time_sub(mlval arg)
{
  long a_secs= mlw_time_sec(FIELD(arg, 0));
  long a_usecs= mlw_time_usec(FIELD(arg, 0));
  long b_secs= mlw_time_sec(FIELD(arg, 1));
  long b_usecs= mlw_time_usec(FIELD(arg, 1));
  long secs= a_secs - b_secs;
  long usecs= a_usecs - b_usecs;

  if (secs < 0)
    exn_raise(mlw_time_exn_ref_time);

  if (usecs < 0) {
    if ((secs -= 1) < 0)
      exn_raise(mlw_time_exn_ref_time);
    usecs= (mlw_time_usecs_per_sec - b_usecs) + a_usecs;
  }
  return mlw_time_make(secs, usecs);
}



/*
 * Time.now: unit -> time
 * Raises: Time
 */
static mlval mlw_time_now(mlval unit)
{
  struct timeval tv;
  if (mlw_get_time_now(&tv) < 0)
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_make(tv.tv_sec, tv.tv_usec);
}


#define mlw_date_year_offset 1900

/*
 * Convert a C `struct tm' into an ML `Date.date'.
 * Will set isDst to the value in the C structure.
 * Will set offset to supplied value.
 */
static mlval mlw_tm_to_date(struct tm *tm, mlval offset)
{
  mlval isdst,  date;

  assert(tm->tm_wday >= mlw_date_wday_min && tm->tm_wday <= mlw_date_wday_max);

  declare_root(&offset, 0);
  isdst= mlw_option_make_some(tm->tm_isdst > 0 ? MLTRUE : MLFALSE);
  declare_root(&isdst, 0);

  date= mlw_make_date();
  mlw_date_sec(date)= MLINT(tm->tm_sec);
  mlw_date_min(date)= MLINT(tm->tm_min);
  mlw_date_hour(date)= MLINT(tm->tm_hour);
  mlw_date_mday(date)= MLINT(tm->tm_mday);
  assert(tm->tm_mon >= mlw_date_month_min && tm->tm_mon <= mlw_date_month_max);
  mlw_date_mon(date)= MLINT(mlw_date_month_c_to_ml[tm->tm_mon]);
  mlw_date_year(date)= MLINT(tm->tm_year+mlw_date_year_offset);
  mlw_date_wday(date)= MLINT(mlw_date_wday_c_to_ml[tm->tm_wday]);
  mlw_date_yday(date)= MLINT(tm->tm_yday);
  mlw_date_isdst(date)= isdst;
  mlw_date_offset(date) = offset;
  retract_root(&isdst);
  retract_root(&offset);
  return date;
}


/*
 * Date.localOffset : unit -> Time.time
 * Raises: Date
 */
static mlval mlw_date_local_offset(mlval arg){
  struct tm *gmt;
  time_t t1, t2;
  double offset;
  long secs, usecs;

  t1 = time((time_t)0);
  gmt = gmtime (&t1);
  t2 = mktime(gmt);

  offset = (difftime(t2, t1));

  /* Make sure offset is in the range 0..24 hours */
  if(offset < 0.0)
    offset += (60.0 * 60.0 * 24.0);
 /* Convert the double into an ML Time.time.
     The code is the same as for Time.fromReal */
  if (offset < 0 || offset > LONG_MAX)
    exn_raise(mlw_date_exn_ref_date);

  secs= offset;
  usecs= (long)((offset - (double)secs)*1000000.0);
  return mlw_time_make(secs, usecs);
}

/*
 * Date.fromTimeLocal: Time.time -> Date.date
 */
static mlval mlw_date_from_time_local(mlval arg)
{
  time_t secs= (time_t)mlw_time_sec(arg);
  struct tm *tm= localtime(&secs);
  return mlw_tm_to_date(tm, mlw_option_make_none());
}


/*
 * Date.fromTimeUniv: Time.time -> Date.date
 */
static mlval mlw_date_from_time_univ(mlval arg)
{
  mlval offset;
  time_t secs= (time_t)mlw_time_sec(arg);
  struct tm *tm= gmtime(&secs);

  /* Set up offset */
  offset = mlw_option_make_some(mlw_time_make(0, 0));

  return mlw_tm_to_date(tm, offset);
}




static void mlw_date_to_tm(mlval date, struct tm *tm)
{
  int dst, year;

  tm->tm_sec=  CINT(mlw_date_sec(date));
  tm->tm_min=  CINT(mlw_date_min(date));
  tm->tm_hour= CINT(mlw_date_hour(date));
  tm->tm_mday= CINT(mlw_date_mday(date));
  tm->tm_mon=  mlw_date_month_ml_to_c[CINT(mlw_date_mon(date))];
  year = CINT(mlw_date_year(date))-mlw_date_year_offset;
  if(year<0)
    exn_raise(mlw_date_exn_ref_date);

  tm->tm_year= year;
  tm->tm_wday= 
          mlw_date_wday_ml_to_c[CINT(mlw_date_wday(date))];
  tm->tm_yday= CINT(mlw_date_yday(date));
  tm->tm_isdst= mlw_option_is_none(mlw_date_isdst(date))
    ? 0
    : CBOOL(mlw_option_some(mlw_date_isdst(date)));

  dst = tm->tm_isdst; /* Remember this, because mk_time will screw it */
  tm->tm_isdst=-1;    /* Need to stop mktime fiddling with the hours */
  (void)mktime(tm);   /* Bring all the fields into range */
  tm->tm_isdst = dst; /* Put it back again */
}



/*
 * Date.toTime: date -> Time.time
 * Raises: Date
 */
static mlval mlw_date_to_time(mlval date)
{
  struct tm tm;
  time_t time;

  mlw_date_to_tm(date, &tm);
  time = mktime(&tm);
  if(time==(time_t)-1) /* If the calendar time cannot be represented. */
    exn_raise(mlw_date_exn_ref_date);

  return mlw_time_make(time, 0);
}

/*
 * Date.toString: date -> string
 */
static mlval mlw_date_to_string(mlval date)
{
  char *result;

  struct tm tm;
  mlw_date_to_tm(date, &tm);
  result = (asctime(&tm));
  result[24] = '\0'; /* remove the '\n' from the end. */

  return ml_string(result);
}



static mlval mlw_date_fmt(mlval string_date)
{
  struct tm tm;
  size_t size;
  mlval result = MLUNIT;
  char *format = CSTRING(FIELD(string_date, 0));
  if (strlen(format) == 0) {
    result = allocate_string(1);
    *(CSTRING(result)) = '\0';
    return result;
  } else {
    mlw_date_to_tm(FIELD(string_date, 1), &tm);
    for(size=256; result==MLUNIT; size*=2) {
      char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
      size_t length = strftime(buffer, size-1, format, &tm);

      if(length > 0) {
	result = allocate_string(length+1);
	memcpy(CSTRING(result), buffer, length+1);
      }

      free(buffer);
    }
    return result;
  }
}

static struct timeval start_time;

static mlval mlw_time_start(mlval unit)
{
  return mlw_time_make(start_time.tv_sec, start_time.tv_usec);
}

void mlw_time_date_init(void)
{
  mlw_get_time_now(&start_time);
  mlw_time_exn_ref_time = ref(exn_default);
  mlw_date_exn_ref_date = ref(exn_default);
  env_value("Time.Time", mlw_time_exn_ref_time);
  env_value("Date.Date", mlw_date_exn_ref_date);
  declare_global("Time.Time", &mlw_time_exn_ref_time,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  declare_global("Date.Date", &mlw_date_exn_ref_date,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  env_function("Time.fromReal", mlw_time_from_real);
  env_function("Time.toReal",   mlw_time_to_real);

  env_function("Time.toSeconds",      mlw_time_to_secs);
  env_function("Time.toMilliseconds", mlw_time_to_msecs);
  env_function("Time.toMicroseconds", mlw_time_to_usecs);

  env_function("Time.fromSeconds",      mlw_time_from_secs);
  env_function("Time.fromMilliseconds", mlw_time_from_msecs);
  env_function("Time.fromMicroseconds", mlw_time_from_usecs);

  env_function("Time.+", mlw_time_add);
  env_function("Time.-", mlw_time_sub);

  env_function("Time.now", mlw_time_now);
  env_function("Time.start", mlw_time_start);

  env_function("Date.localOffset", mlw_date_local_offset);
  env_function("Date.fromTimeLocal", mlw_date_from_time_local);
  env_function("Date.fromTimeUniv",  mlw_date_from_time_univ);
  env_function("Date.toTime",   mlw_date_to_time);
  env_function("Date.toString", mlw_date_to_string);
  env_function("Date.fmt", mlw_date_fmt);
}
@


1.16.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a19 4
 * Revision 1.16  1998/10/09  14:33:57  jont
 * [Bug #30489]
 * Ensure we don't fault strftime results on empty formats
 *
@


1.15
log
@[Bug #70188]
Ensure Date.localOffset can cope with timezones ahead of GMT
,
@
text
@d20 5
d525 16
a540 10
  mlw_date_to_tm(FIELD(string_date, 1), &tm);
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, &tm);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
d542 1
a542 2

    free(buffer);
a543 1
  return result;
@


1.14
log
@[Bug #30487]
Modify functions dealing in seconds to use Int32
@
text
@d20 4
d409 4
a412 1
  /* Convert the double into an ML Time.time.
@


1.13
log
@[Bug #70108]
Add include of syscalls.h to get round problems in Red Hat 5 with struct timespec
@
text
@d20 4
d87 1
d177 1
a177 1
 * Time.toSeconds: time -> int
d182 1
d184 1
a184 1
  if (secs > ML_MAX_INT)
d186 2
d195 1
a195 1
 * Time.toMilliseconds: time -> int
d200 1
d204 1
a204 1
  if (secs > ML_MAX_INT/mlw_time_msecs_per_sec)
d206 1
a206 1
  if (msecs > (ML_MAX_INT - secs*mlw_time_msecs_per_sec))
d208 2
a209 1
  return MLINT(secs*1000+msecs);
d215 1
a215 1
 * Time.toMicroseconds: time -> int
d220 1
d224 1
a224 1
  if (secs > ML_MAX_INT/mlw_time_usecs_per_sec)
d227 1
a227 1
  if (usecs > (ML_MAX_INT - secs*mlw_time_usecs_per_sec))
d230 2
a231 1
  return MLINT(secs*mlw_time_usecs_per_sec+usecs);
d237 1
a237 1
 * Time.fromSeconds: int -> time
d242 1
a242 1
  long secs= CINT(arg);
d251 1
a251 1
 * Time.fromMilliseconds: int -> time
d256 1
a256 1
  long msecs= CINT(arg);
d269 1
a269 1
 * Time.fromMicroseconds: int -> time
d274 1
a274 1
  long usecs= CINT(arg);
@


1.12
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d20 5
d70 1
@


1.11
log
@[Bug #30085]
Add Time.start function to give value of Time.now when process started
@
text
@d20 4
d349 1
a349 1
  declare_root(&offset);
d351 1
a351 1
  declare_root(&isdst);
@


1.10
log
@[Bug #30269]
Added declare root to Bruce's change.
@
text
@d20 4
a292 2


d508 1
d510 4
d517 1
d542 1
@


1.10.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a19 4
 * Revision 1.10  1997/09/30  11:23:09  daveb
 * [Bug #30269]
 * Added declare root to Bruce's change.
 *
@


1.9
log
@[Bug #30269]
Implement routines for revised Date structure.
@
text
@d20 4
d343 1
d360 1
@


1.8
log
@[Bug #1629]
mlw_time_add: corrected so that only overflows if the number
of seconds goes out of the range representable by the OS.
@
text
@d20 5
d54 2
a55 2
#include <sys/time.h>		/* struct timeval */
#include <limits.h>		/* LONG_MAX .. etc. */
d58 1
a58 1
#include "date.h"		/* mlw_date_hour etc */
d60 1
a60 1
#include "environment.h"	/* env_value ... etc. */
d73 1
d315 1
a325 2

#define mlw_make_date() allocate_record(9)
d328 8
a336 3
static mlval mlw_tm_to_date(struct tm *tm)
{
  mlval wday,  yday,  isdst,  date;
d338 1
a338 4
  wday= mlw_option_make_some(MLINT(mlw_date_wday_c_to_ml[tm->tm_wday]));
  declare_root(&wday);
  yday= mlw_option_make_some(MLINT(tm->tm_yday));
  declare_root(&yday);
d341 1
d350 2
a351 2
  mlw_date_wday(date)= wday;
  mlw_date_yday(date)= yday;
d353 1
a354 2
  retract_root(&yday);
  retract_root(&wday);
d359 25
d386 1
a386 1
 * Date.fromTime: Time.time -> Date.date
d388 1
a388 1
static mlval mlw_date_from_time(mlval arg)
d392 1
a392 1
  return mlw_tm_to_date(tm);
a395 2


d397 1
a397 1
 * Date.fromUTC: Time.time -> Date.date
d399 1
a399 1
static mlval mlw_date_from_utc(mlval arg)
d401 1
d404 5
a408 1
  return mlw_tm_to_date(tm);
d416 2
a417 1
  int dst;
d423 8
a430 7
  tm->tm_year= CINT(mlw_date_year(date))-mlw_date_year_offset;
  tm->tm_wday= mlw_option_is_none(mlw_date_wday(date))
    ? 0
    : mlw_date_wday_ml_to_c[CINT(mlw_option_some(mlw_date_wday(date)))];
  tm->tm_yday= mlw_option_is_none(mlw_date_yday(date))
    ? 0
    : CINT(mlw_option_some(mlw_date_yday(date)));
d434 1
d445 1
d450 2
d453 5
a457 1
  return mlw_time_make(mktime(&tm), 0);
d465 2
d469 4
a472 1
  return ml_string(asctime(&tm));
d505 1
d507 1
d510 2
d529 3
a531 2
  env_function("Date.fromTime", mlw_date_from_time);
  env_function("Date.fromUTC",  mlw_date_from_utc);
@


1.8.10.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.9.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.8.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.8.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a19 3
 * Revision 1.8.8.1  1997/05/12  10:44:14  hope
 * branched from 1.8
 *
@


1.8.8.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a19 3
 * Revision 1.8.8.1  1997/05/12  10:44:14  hope
 * branched from 1.8
 *
@


1.8.8.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a19 3
 * Revision 1.8.8.1  1997/05/12  10:44:14  hope
 * branched from 1.8
 *
@


1.8.8.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a19 3
 * Revision 1.8.8.1.1.1  1997/07/28  18:26:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.8.7.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.6.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.6.1.1.1
log
@branched from 1.8.6.1
@
text
@a19 3
 * Revision 1.8.6.1  1996/12/17  17:55:55  hope
 * branched from 1.8
 *
@


1.8.5.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.4.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a19 3
 * Revision 1.8.3.1  1996/11/14  12:59:49  hope
 * branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a19 5
 * Revision 1.8  1996/10/02  11:32:19  stephenb
 * [Bug #1629]
 * mlw_time_add: corrected so that only overflows if the number
 * of seconds goes out of the range representable by the OS.
 *
@


1.7
log
@[Bug #1506]
mlw_time_sub: fixed the code that dealt with the case where
a_usecs < b_usecs -- the previous code was hopelessly wrong.
@
text
@d20 5
d170 2
a171 2
  long msecs= usecs/1000;
  if (secs > ML_MAX_INT/1000)
d173 1
a173 1
  if (msecs > (ML_MAX_INT - secs*1000))
d189 1
a189 1
  if (secs > ML_MAX_INT/1000000)
d192 1
a192 1
  if (usecs > (ML_MAX_INT - secs*1000000))
d195 1
a195 1
  return MLINT(secs*1000000+usecs);
d268 2
a269 2
  if (usecs > 1000000) {
    secs += 1;  usecs -= 1000000;
d272 1
a272 1
  if (ML_MAX_INT - a_sec < b_sec)
d275 1
a275 1
  return mlw_time_make(a_sec + b_sec, a_usec + b_usec);
d317 1
@


1.7.1.1
log
@branched from 1.7
@
text
@a19 5
 * Revision 1.7  1996/07/29  13:55:13  stephenb
 * [Bug #1506]
 * mlw_time_sub: fixed the code that dealt with the case where
 * a_usecs < b_usecs -- the previous code was hopelessly wrong.
 *
@


1.6
log
@Allow ML dates to have full year value, ie 19xx rather than xx
@
text
@d20 3
d295 1
a295 1
    usecs= b_usecs - a_usecs;
@


1.5
log
@Remove my_asctime.
@
text
@d20 3
d315 1
a315 1
static mlval mlw_tm_to_time(struct tm *tm)
d332 1
a332 1
  mlw_date_year(date)= MLINT(tm->tm_year);
d351 1
a351 1
  return mlw_tm_to_time(tm);
d364 1
a364 1
  return mlw_tm_to_time(tm);
d378 1
a378 1
  tm->tm_year= CINT(mlw_date_year(date));
@


1.4
log
@Fix problem whereby mk_time fiddles with tm_isdst
@
text
@d20 3
a400 18
}

static char *my_asctime(const struct tm *tm)
{
  /* This copied directly from Plauger */
  static const char wday_name[7][3] = {
    "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
  static const char mon_name[12][3] = {
    "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
  static char result[26];

  sprintf(result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
	  wday_name[tm->tm_wday],
	  mon_name[tm->tm_mon],
	  tm->tm_mday, tm->tm_hour,
	  tm->tm_min, tm->tm_sec,
	  1900 + tm->tm_year);
  return result;
@


1.3
log
@Fix the time conversion routines to take account of
* Unix starting years at 1900.
* mapping C months and weekdays into ML months and weekdays
* daylight savings time.
@
text
@d20 6
d326 1
a326 1
  mlw_date_year(date)= MLINT(tm->tm_year+mlw_date_year_offset);
d366 1
d372 1
a372 1
  tm->tm_year= CINT(mlw_date_year(date)-mlw_date_year_offset);
d382 4
a385 1
  (void)mktime(tm); /* Bring all the fields into range */
d400 17
a416 2


@


1.2
log
@Completing implementation of __date.sml
@
text
@d20 3
d28 1
d300 2
d306 2
a307 1
  wday= mlw_option_make_some(MLINT(tm->tm_wday));
d311 1
a311 1
  isdst= mlw_option_make_some(MLINT(tm->tm_isdst));
d318 3
a320 2
  mlw_date_mon(date)= MLINT(tm->tm_mon);
  mlw_date_year(date)= MLINT(tm->tm_year);
d364 2
a365 2
  tm->tm_mon=  trans_month(mlw_date_mon(date));
  tm->tm_year= CINT(mlw_date_year(date));
d368 1
a368 1
    : trans_wday(mlw_option_some(mlw_date_wday(date)));
d374 1
a374 1
    : CINT(mlw_option_some(mlw_date_isdst(date)));
d378 2
d403 2
d428 2
a457 1

@


1.1
log
@new unit
@
text
@d19 4
a22 1
 * $Log$
d27 1
d29 1
d34 1
a296 12
#define mlw_date_hour(date)  FIELD(date, 0)
#define mlw_date_isdst(date) FIELD(date, 1)
#define mlw_date_mday(date)  FIELD(date, 2)
#define mlw_date_min(date)   FIELD(date, 3)
#define mlw_date_mon(date)   FIELD(date, 4)
#define mlw_date_sec(date)   FIELD(date, 5)
#define mlw_date_wday(date)  FIELD(date, 6)
#define mlw_date_yday(date)  FIELD(date, 7)
#define mlw_date_year(date)  FIELD(date, 8)



d356 1
a356 1
  tm->tm_mon=  CINT(mlw_date_mon(date));
a357 1
  tm->tm_sec=  CINT(mlw_date_isdst(date));
d360 1
a360 1
    : CINT(mlw_date_wday(date));
d363 1
a363 1
    : CINT(mlw_date_yday(date));
d366 2
a367 1
    : CINT(mlw_date_isdst(date));
a369 3



d393 17
d411 4
a414 3



d443 1
@
