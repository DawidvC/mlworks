head	1.50;
access;
symbols
	MLW_daveb_inline_1_4_99:1.50.5
	MLWorks_21c0_1999_03_25:1.50
	MLWorks_20c1_1998_08_20:1.50
	MLWorks_20c0_1998_08_04:1.50
	MLWorks_20b2c2_1998_06_19:1.50
	MLWorks_20b2_Windows_1998_06_12:1.50
	MLWorks_20b1c1_1998_05_07:1.50
	MLWorks_20b0_1998_04_07:1.50
	MLWorks_20b0_1998_03_20:1.50
	MLWorks_20m2_1998_02_16:1.50
	MLWorks_MM_adapt:1.50.4
	MLWorks_20m1_1997_10_23:1.50
	MLWorks_11r1:1.50.1.1.1.1.1
	MLWorks_workspace_97:1.50.3
	MLWorks_dt_wizard:1.50.2
	MLWorks_11c0_1997_09_09:1.50.1.1.1.1
	MLWorks_10r3:1.50.1.1.3
	MLWorks_10r2_551:1.50.1.1.2
	MLWorks_11:1.50.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.50.1.1
	MLWorks_20m0_1997_06_20:1.50
	MLWorks_1_0_r2c2_1997_06_14:1.50.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.50.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.50.1
	MLWorks_BugFix_1997_04_24:1.50
	MLWorks_1_0_r2_Win32_1997_04_11:1.50
	MLWorks_1_0_r2_Unix_1997_04_04:1.50
	MM_ML_release_korma_1997_04_01:1.50
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.49.4.1.1
	MLWorks_gui_1996_12_18:1.49.5
	MLWorks_1_0_Win32_1996_12_17:1.49.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.49.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.49.1.1
	JFHrts:1.49.3
	MLWorks_1_0_Irix_1996_11_28:1.49.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.49.2
	MLWorks_1_0_Unix_1996_11_14:1.49.1
	MLWorks_Open_Beta2_1996_10_11:1.47.3
	MLWorks_License_dev:1.47.2
	MLWorks_1_open_beta_1996_09_13:1.47.1
	MLWorks_Open_Beta_1996_08_22:1.47
	MLWorks_Beta_1996_07_02:1.47
	MLWorks_Beta_1996_06_07:1.47
	MLWorks_Beta_1996_06_06:1.46
	MLWorks_Beta_1996_06_05:1.46
	MLWorks_Beta_1996_06_03:1.46
	MLWorks_Beta_1996_05_31:1.46
	MLWorks_Beta_1996_05_30:1.46
	hope_poo:1.7.1
	ML_beta_release_12/08/94:1.7.1.2
	ML_beta_release_03/08/94:1.7;
locks; strict;
comment	@ * @;


1.50
date	97.01.07.10.47.59;	author matthew;	state Exp;
branches
	1.50.1.1
	1.50.2.1
	1.50.3.1
	1.50.4.1
	1.50.5.1;
next	1.49;

1.49
date	96.11.08.11.03.48;	author matthew;	state Exp;
branches
	1.49.1.1
	1.49.2.1
	1.49.3.1
	1.49.4.1
	1.49.5.1;
next	1.48;

1.48
date	96.10.17.14.52.07;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	96.06.07.09.31.23;	author jont;	state Exp;
branches
	1.47.1.1
	1.47.2.1
	1.47.3.1;
next	1.46;

1.46
date	96.05.23.13.46.24;	author matthew;	state Exp;
branches;
next	1.45;

1.45
date	96.05.23.11.05.48;	author matthew;	state Exp;
branches;
next	1.44;

1.44
date	96.05.23.10.54.07;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	96.04.22.09.16.54;	author matthew;	state Exp;
branches;
next	1.42;

1.42
date	96.04.19.14.22.13;	author matthew;	state Exp;
branches;
next	1.41;

1.41
date	96.02.08.15.49.46;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	96.02.08.13.08.32;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	96.02.07.16.56.12;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	96.02.07.11.45.50;	author nickb;	state Exp;
branches;
next	1.37;

1.37
date	96.01.29.15.09.04;	author stephenb;	state Exp;
branches;
next	1.36;

1.36
date	96.01.17.17.35.47;	author nickb;	state Exp;
branches;
next	1.35;

1.35
date	96.01.16.14.01.11;	author nickb;	state Exp;
branches;
next	1.34;

1.34
date	96.01.16.12.22.15;	author stephenb;	state Exp;
branches;
next	1.33;

1.33
date	96.01.16.10.52.58;	author stephenb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.12.12.45.58;	author stephenb;	state Exp;
branches;
next	1.31;

1.31
date	96.01.11.13.21.49;	author nickb;	state Exp;
branches;
next	1.30;

1.30
date	96.01.08.16.42.35;	author nickb;	state Exp;
branches;
next	1.29;

1.29
date	96.01.02.12.19.20;	author nickb;	state Exp;
branches;
next	1.28;

1.28
date	95.09.19.15.19.33;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	95.09.15.16.27.55;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	95.09.12.15.04.00;	author nickb;	state Exp;
branches;
next	1.25;

1.25
date	95.07.04.13.02.06;	author nickb;	state Exp;
branches;
next	1.24;

1.24
date	95.07.03.10.17.09;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	95.06.12.15.22.47;	author nickb;	state Exp;
branches;
next	1.22;

1.22
date	95.06.06.12.27.30;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.06.06.11.22.07;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	95.06.02.15.52.02;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.04.27.11.57.33;	author daveb;	state Exp;
branches;
next	1.18;

1.18
date	95.04.24.12.47.45;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.04.12.12.25.13;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.04.12.09.39.58;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.04.10.14.30.53;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.03.15.16.20.23;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.01.05.11.10.23;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	94.12.14.14.54.42;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.11.23.16.52.00;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	94.11.15.15.37.37;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	94.10.19.14.32.42;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	94.09.07.10.05.04;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.07.25.13.16.54;	author nickh;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	94.07.22.14.33.33;	author nickh;	state Exp;
branches;
next	1.5;

1.5
date	94.07.08.10.03.57;	author nickh;	state Exp;
branches;
next	1.4;

1.4
date	94.06.14.14.51.09;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.06.13.12.02.58;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.24.13;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.49.10;	author nickh;	state Exp;
branches;
next	;

1.7.1.1
date	95.07.05.10.31.47;	author hope;	state Exp;
branches;
next	1.7.1.2;

1.7.1.2
date	95.07.05.10.36.17;	author jont;	state Exp;
branches;
next	;

1.47.1.1
date	96.09.13.11.22.26;	author hope;	state Exp;
branches;
next	;

1.47.2.1
date	96.10.07.16.12.32;	author hope;	state Exp;
branches;
next	1.47.2.2;

1.47.2.2
date	96.10.09.11.58.43;	author nickb;	state Exp;
branches;
next	;

1.47.3.1
date	96.10.17.11.31.32;	author hope;	state Exp;
branches;
next	;

1.49.1.1
date	96.11.14.12.57.31;	author hope;	state Exp;
branches
	1.49.1.1.1.1;
next	;

1.49.1.1.1.1
date	96.11.28.15.07.38;	author hope;	state Exp;
branches;
next	;

1.49.2.1
date	96.11.22.18.15.20;	author hope;	state Exp;
branches;
next	;

1.49.3.1
date	96.12.17.10.02.04;	author hope;	state Exp;
branches;
next	;

1.49.4.1
date	96.12.17.17.53.49;	author hope;	state Exp;
branches
	1.49.4.1.1.1;
next	;

1.49.4.1.1.1
date	97.02.24.11.44.48;	author hope;	state Exp;
branches;
next	;

1.49.5.1
date	96.12.18.09.48.23;	author hope;	state Exp;
branches;
next	;

1.50.1.1
date	97.05.12.10.40.46;	author hope;	state Exp;
branches
	1.50.1.1.1.1
	1.50.1.1.2.1
	1.50.1.1.3.1;
next	;

1.50.1.1.1.1
date	97.07.28.18.28.23;	author daveb;	state Exp;
branches
	1.50.1.1.1.1.1.1;
next	;

1.50.1.1.1.1.1.1
date	97.10.07.11.54.16;	author jkbrook;	state Exp;
branches;
next	;

1.50.1.1.2.1
date	97.09.08.17.21.22;	author daveb;	state Exp;
branches;
next	;

1.50.1.1.3.1
date	97.09.09.14.17.25;	author daveb;	state Exp;
branches;
next	;

1.50.2.1
date	97.09.10.19.36.18;	author brucem;	state Exp;
branches;
next	;

1.50.3.1
date	97.09.11.21.04.39;	author daveb;	state Exp;
branches;
next	;

1.50.4.1
date	97.10.31.13.47.42;	author nickb;	state Exp;
branches;
next	;

1.50.5.1
date	99.04.01.18.03.27;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.50
log
@Changing diagnostic level for EMT message
@
text
@/* ==== SIGNAL HANDLING ====
 * 
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module abstracts the OS-specific signal handling code from
 * the various parts of the runtime system.
 *
 * 
 * Revision Log
 * ------------
 * $Log: src:OS:SunOS:arch:SPARC:signals.c,v $
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
 * Revision 1.48  1996/10/17  14:52:07  jont
 * Merge in license stuff
 *
 * Revision 1.47.2.2  1996/10/09  11:58:43  nickb
 * Move to Harlequin license server.
 *
 * Revision 1.47.2.1  1996/10/07  16:12:32  hope
 * branched from 1.47
 *
 * Revision 1.47  1996/06/07  09:31:23  jont
 * Update best before to 01/01/97
 *
 * Revision 1.46  1996/05/23  13:46:24  matthew
 * Fixing bungle with comment brackets
 *
 * Revision 1.45  1996/05/23  11:05:48  matthew
 * Fixing matherr again
 *
 * Revision 1.44  1996/05/23  10:54:07  matthew
 * Commenting out matherr
 *
 * Revision 1.43  1996/04/22  09:16:54  matthew
 * removing unused real signal handler
 *
 * Revision 1.42  1996/04/19  14:22:13  matthew
 * Changes to Exception raising
 *
 * Revision 1.41  1996/02/08  15:49:46  jont
 * Removing do_exportFn, as this is no longer architecture dependent
 *
 * Revision 1.40  1996/02/08  13:08:32  jont
 * Modify exportFn mechanism not to use signals at all
 * Use busy waiting in parent instead, thus avoiding
 * potential race contions
 *
 * Revision 1.39  1996/02/07  16:56:12  jont
 * Ensure signal_child_handler only deals with signals from known children
 *
 * Revision 1.38  1996/02/07  11:45:50  nickb
 * Make interval window updates happen even if we stay in ML.
 *
 * Revision 1.37  1996/01/29  15:09:04  stephenb
 * Add <unistd.h>
 *
 * Revision 1.36  1996/01/17  17:35:47  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.35  1996/01/16  14:01:11  nickb
 * Remove "storage manager" interface; replace it with regular functions.
 *
 * Revision 1.34  1996/01/16  12:22:15  stephenb
 * Add a patch to die_on_signal that I should have added in my previous bug fix.
 *
 * Revision 1.33  1996/01/16  10:52:58  stephenb
 * Fix bug #995 - death of last thread due to a fatal signal should
 * result in a non-zero termination code.
 *
 * Revision 1.32  1996/01/12  12:45:58  stephenb
 * Fix fatal signal handler so that it does not loop if a
 * fatal signal is received whilst the handler is active.
 *
 * Revision 1.31  1996/01/11  13:21:49  nickb
 * Add timer-triggered window updates.
 *
 * Revision 1.29  1996/01/02  12:19:20  nickb
 * Update best-before date to 1996-07-01.
 *
 * Revision 1.28  1995/09/19  15:19:33  nickb
 * Improve the full GC we do during function export.
 *
 * Revision 1.27  1995/09/15  16:27:55  jont
 * Add do_exportFn to do the system specific part of exportFn
 *
 * Revision 1.26  1995/09/12  15:04:00  nickb
 * Unusual SIGINT bug.
 *
 * Revision 1.25  1995/07/04  13:02:06  nickb
 * Change to profiler interface.
 *
 * Revision 1.24  1995/07/03  10:17:09  nickb
 * Update best-before date.
 *
 * Revision 1.23  1995/06/12  15:22:47  nickb
 * Fix minor thinko in fatal_signal.
 *
 * Revision 1.22  1995/06/06  12:27:30  nickb
 * Tidy up fatal signal handling some more.
 *
 * Revision 1.21  1995/06/06  11:22:07  nickb
 * Tidy up fatal signal handling.
 *
 * Revision 1.20  1995/06/02  15:52:02  nickb
 * Better fatal signal handling.
 *
 * Revision 1.19  1995/04/27  11:57:33  daveb
 * If signal_ml_handler is called while we are waiting for an X event,
 * the runtime just prints a message.  This avoids problems with pointer
 * grabs in X callbacks.
 *
 * Revision 1.18  1995/04/24  12:47:45  nickb
 * Add thread_preemption_pending.
 *
 * Revision 1.17  1995/04/12  12:25:13  nickb
 * Make fatal signal messages come out on stderr.
 *
 * Revision 1.16  1995/04/12  09:39:58  matthew
 * Changing underflow behaviour in matherr
 *
 * Revision 1.15  1995/04/10  14:30:53  nickb
 * Fix profiler entry.
 *
 * Revision 1.14  1995/03/15  16:20:23  nickb
 * Introduce the threads system.
 *
 * Revision 1.13  1995/01/05  11:10:23  nickb
 * Adjust best-before date to 1995-07-01 00:00
 * Also make child sig handler run on current stack (otherwise the
 * first occurence causes a bus error).
 * Also correct the Harlequin telephone number.
 *
 * Revision 1.12  1994/12/14  14:54:42  matthew
 * Changed error output to be written to stderr
 *
 * Revision 1.11  1994/11/23  16:52:00  nickb
 * Put in declaration for set_stack_underflow().
 *
 * Revision 1.10  1994/11/15  15:37:37  nickb
 * Add cache flushing.
 *
 * Revision 1.9  1994/10/19  14:32:42  nickb
 * Better type checking in Gcc 2.5.8 points out a missing cast.
 *
 * Revision 1.8  1994/09/07  10:05:04  jont
 * Update license expiry date
 *
 * Revision 1.7  1994/07/25  13:16:54  nickh
 * Make sure all handlers execute on signal stack.
 *
 * Revision 1.6  1994/07/22  14:33:33  nickh
 * Add GC trap handling.
 *
 * Revision 1.5  1994/07/08  10:03:57  nickh
 * Add interrupt signal number and reserve two more signals.
 *
 * Revision 1.4  1994/06/14  14:51:09  jont
 * Add critical region support for FP signals
 *
 * Revision 1.3  1994/06/13  12:02:58  nickh
 * Update best-before date.
 *
 * Revision 1.2  1994/06/09  14:24:13  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:49:10  nickh
 * new file
 *
 */

#include "signals.h"
#include "utils.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "values.h"
#include "gc.h"
#include "stacks.h"
#include "syscalls.h"
#include "exceptions.h"
#include "event.h"
#include "license.h"
#include "profiler.h"
#include "ansi.h"
#include "reals.h"
#include "alloc.h"
#include "cache.h"
#include "threads.h"
#include "state.h"
#include "x.h"
#include "main.h"
#include "pervasives.h"
#include "global.h"
#include "allocator.h"
#include "image.h"

#include <unistd.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <string.h>
#include <memory.h>
#include <sys/wait.h>
#include <signal.h>
#include <sys/signal.h>
#include <errno.h>
#include <sys/errno.h>
#include <math.h>

/*  
 * Under SunOS, the signal context does not contain the whole
 * processor state. Some of the state is saved and restored by
 * _sigtramp, the OS library function which is the direct caller of
 * the signal handler. _sigtramp saves this information in its stack
 * frame.
 *
 * We need to modify some of this information. Notably g6, which is
 * the stack limit register, needs to be modified in order to trigger
 * a stack overflow check (which causes ML signal handlers to be run).
 *
 * When dealing with a fatal signal we also want to see register o1,
 * which is in this frame.  */

/* This is very OS-specific */

struct sigtramp_frame {
  struct stack_frame	frame;
  word			pad1;
  int			sig;
  int			code;
  struct sigcontext *	scp;
  char *		addr;
  word			pad2[3];
  double		floats[16];	/* only saved if FP enabled */
  word			fsr;		/* only saved if FP enabled */
  word			y;
  word			g2;
  word			g3;
  word			g4;
  word			g5;
  word			g6;
  word			g7;
};

extern struct sigtramp_frame *get_callers_frame(void);

/* To enter garbage collection we cause a trap. The trap handler, in
   this file, sets up some variables and then calls one of these two
   asm functions: */

extern void gc_trap_entry(void);
extern void gc_trap_entry_leaf(void);

/* The first two things the trap handler sets up are these variables:

   gc_trap_bytes is the number of bytes requested by the GC entry code?
   (if this equals -1, the number of bytes is in register %g4.

   gc_trap_return_address is the value which should be in the register
   used as a link gc register when the GC code performs a jmpl to
   return to ML (i.e. it is the return address -8). */ 

word gc_trap_bytes;
word gc_trap_return_address;

/* The other thing set up by the trap handler is a routine through
   which the GC asm code should return to ML (one instruction in the
   appropriate routine has to be modified to tag the allocation result
   correctly). These two routines (leaf and non-leaf) are written in
   asm and copied into the data segment when we set up the signal
   handler.

   gc_trap_ret_template is the address of the asm
   routine. gc_trap_ret_template_end is where it
   ends. gc_trap_ret_template_overwrite is the address of the
   instruction the copy of which we want to modify.

   gc_trap_ret_code is the address of the data-segment copy of the
   code. gc_trap_ret_overwrite is the address of the instruction to
   modify. */

extern word gc_trap_ret_template, gc_trap_ret_template_end;
extern word gc_trap_ret_template_overwrite;

word *gc_trap_ret_code;
word *gc_trap_ret_overwrite;

/* the same, for the leaf case : */

extern word gc_trap_ret_leaf_template, gc_trap_ret_leaf_template_end;
extern word gc_trap_ret_leaf_template_overwrite;

word *gc_trap_ret_leaf_code;
word *gc_trap_ret_leaf_overwrite;

/* An earlier version of MLWorks generated code for each allocation
   which explicitly tested for heap overflow and called either ml_gc()
   or ml_gc_leaf() accordingly (these two functions are on the
   implicit vector). These functions have been changed to call
   ml_gc_die() and ml_gc_leaf_die() respectively (so the user may get
   a message when attempting to execute out-of-date .mo files */

extern void ml_gc_die(mlval closure);
extern void ml_gc_leaf_die(mlval closure);

/* ML signal handler support */

#define NR_SIGNALS	32
#define SIGNAL_STACK_SIZE 	8192

unsigned int signal_nr_signals = NR_SIGNALS;

/* an array of flags showing how signals are handled */

#define SIGNAL_NOT_HANDLED 	((word)0)
#define SIGNAL_HANDLED_IN_ML	((word)1)
#define SIGNAL_HANDLED_IN_C	((word)2)
#define SIGNAL_HANDLED_FATALLY	((word)4)

static word *signal_handled = NULL;

static struct signal_name {int number;
			   const char *name;
			 } signal_names [] =
{{SIGHUP,	"SIGHUP"},
 {SIGINT,	"SIGINT"},
 {SIGQUIT,	"SIGQUIT"},
 {SIGILL,	"SIGILL"},
 {SIGTRAP,	"SIGTRAP"},
 {SIGABRT,	"SIGABRT"},
 {SIGEMT,	"SIGEMT"},
 {SIGFPE,	"SIGFPE"},
 {SIGKILL,	"SIGKILL"},
 {SIGBUS,	"SIGBUS"},
 {SIGSEGV,	"SIGSEGV"},
 {SIGSYS,	"SIGSYS"},
 {SIGPIPE,	"SIGPIPE"},
 {SIGALRM,	"SIGALRM"},
 {SIGTERM,	"SIGTERM"},
 {SIGURG,	"SIGURG"},
 {SIGSTOP,	"SIGSTOP"},
 {SIGTSTP,	"SIGTSTP"},
 {SIGCONT,	"SIGCONT"},
 {SIGCHLD,	"SIGCHLD"},
 {SIGTTIN,	"SIGTTIN"},
 {SIGTTOU,	"SIGTTOU"},
 {SIGIO,	"SIGIO"},
 {SIGXCPU,	"SIGXCPU"},
 {SIGXFSZ,	"SIGXFSZ"},
 {SIGVTALRM,	"SIGVTALRM"},
 {SIGPROF,	"SIGPROF"},
 {SIGWINCH,	"SIGWINCH"},
 {SIGLOST,	"SIGLOST"},
 {SIGUSR1,	"SIGUSR1"},
 {SIGUSR2,	"SIGUSR2"},
 {0,		NULL}};

static const char *name_that_signal (int sig)
{
  static const char *no_such_signal = "Unknown";
  struct signal_name *this = signal_names;

  while (this->number != sig &&
	 this->name != NULL)
    this++;

  if (this->name == NULL)
    return no_such_signal;
  else
    return this->name;
}

/* SunOS-specific stuff for setting and clearing a signal handler */

typedef void (*signal_handler)(int sig, int, struct sigcontext *, char *);

static int check_sigvec (int sig, struct sigvec *vec)
{
  int result = sigvec (sig,vec,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigvec returned an unexpected error code %d", errno);
    }
  return result;
}

static int set_signal_handler(int sig, signal_handler handler)
{
  struct sigvec sv;
  sv.sv_handler = handler;

  /* due to an OS bug in SunOS 4.1.3, we have to mask our
   * control-flow-changing signals here, because otherwise their
   * handlers can over-ride these ones, with the result that the
   * process signal mask doesn't get reset correctly. See MLWorks
   * change report 1225. */
  sv.sv_mask = sigmask(SIGEMT);	/* mustn't take a GC trap */
  sv.sv_flags = SV_ONSTACK;
      
  return (check_sigvec (sig,&sv));
}

static int restore_default_signal_handler(int sig)
{
  struct sigvec sv;
  sv.sv_handler = SIG_DFL;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  return check_sigvec(sig, &sv);
}

/* signal_event() is called from record_event (in the events
   module). It can be called either synchronously in C or
   asynchronously in C or ML. It should set the 'interrupted' flag
   such that the event is taken synchronously by ML when we return to
   ML. */

extern void signal_event(void)
{
  /* set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
}

static void signal_ml_event (struct sigtramp_frame *sf)
{
  if (global_state.in_ML)
    sf->g6 = (word)-1;
}

/* This function converts a C signal into an ML signal event. */

static void ml_signal_handler (int sig, struct sigtramp_frame *sf)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    record_event(EV_SIGNAL, (word) sig);
    signal_ml_event(sf);
  }
}

static void signal_ml_handler
  (int sig, int code, struct sigcontext *scp, char *addr)
{
  ml_signal_handler(sig, get_callers_frame());
}

/* Install or remove the signal handler for a given signal */

extern int signal_set_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if ((handled & SIGNAL_HANDLED_IN_ML) == 0) {
    signal_handled[sig] = handled + SIGNAL_HANDLED_IN_ML;
    if ((handled & SIGNAL_HANDLED_IN_C) == 0) {
      return set_signal_handler(sig,signal_ml_handler);
    }
  }
  return 0;
}

extern int signal_clear_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if (handled & SIGNAL_HANDLED_IN_ML) {
    signal_handled[sig] = handled = handled - SIGNAL_HANDLED_IN_ML;
    if (handled == 0) {
      return restore_default_signal_handler(sig);
    }
  }
  return 0;
}

/* Do something tolerable in the face of a fatal signal */

static mlval signal_thread_suicide_stub[] = {0, 0, (mlval)thread_suicide};

static void restore_default_fatal_signal_handlers(void)
{
  int i;
  for (i=0; i < NR_SIGNALS; i++) {
    if (signal_handled[i] & SIGNAL_HANDLED_FATALLY) {
      signal_handled[i] -= (SIGNAL_HANDLED_FATALLY + SIGNAL_HANDLED_IN_C);
      if (restore_default_signal_handler(i) != 0)
	error_without_alloc("Could not restore default fatal signal handlers");
    }
  }
}

static void die_in_fatal_signal_handler(char const *message)
{
  /* race condition here if the following call fails with a fatal signal */
  restore_default_fatal_signal_handlers();
  message_stderr("Fatal signal handler dying: %s", message);
}

/* Define a matherr that does nothing */
extern int matherr(struct exception *e)
{
  return(1);
}

static void handle_fatal_signal(int sig, int code,
				  struct sigcontext *scp, char *addr)
{
  if (CURRENT_THREAD == 0) {
    die_in_fatal_signal_handler("Corrupt threads system");

  } else if (CURRENT_THREAD->in_fatal_signal_handler) {
    die_in_fatal_signal_handler("Fatal signal raised by handler");

  } else if (in_GC) {
    die_in_fatal_signal_handler("fatal signal raised during GC.");

  } else {
    const char *signal_name;
    mlval handler;
    struct sigtramp_frame *st_frame;
  
    CURRENT_THREAD->in_fatal_signal_handler= 1;
    signal_name= name_that_signal (sig);
    handler= THREAD_ERROR_HANDLER(CURRENT_THREAD);
    st_frame= get_callers_frame();
    flush_windows();

    DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      ml_signal_handler(sig, st_frame);
  
    if (handler == MLUNIT) {
      /* there is no handler; print a message and kill this thread. */
      if (runnable_threads == 2) {
	die_in_fatal_signal_handler("Last thread dying.");
      } else {
	message ("Thread #%d received an intolerable signal %s (%d : %d) %sin ML and died.",
		 CURRENT_THREAD->number, signal_name, sig, code,
		 global_state.in_ML? "" : "not ");
	backtrace ((struct stack_frame *)scp->sc_sp, CURRENT_THREAD,
		   max_backtrace_depth);
	SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
	if (global_state.in_ML) { 
	  scp->sc_pc = (int)stub_c+CODE_OFFSET;
	  scp->sc_npc = (int)stub_c+CODE_OFFSET+4;
	  scp->sc_o0 = MLUNIT;
	  st_frame->frame.closure = (int)signal_thread_suicide_stub+POINTER;
	} else {
	  scp->sc_pc = (int) thread_suicide;
	  scp->sc_npc = (int)thread_suicide+4;
	}
	/* to reduce the race window the following should be near the
	 * end of thread_suicide.  However, that entails putting it in
	 * the end of the asm routine change_thread, so for simplicity it
	 * is left here. */
	CURRENT_THREAD->in_fatal_signal_handler= 0;
      }
    } else {
      /* there is a handler; skip to it */
      scp->sc_o0 = MLINT(sig);
      st_frame->frame.closure = handler;
      if (global_state.in_ML) {
	scp->sc_pc = FIELD(handler,0)+CODE_OFFSET;
	scp->sc_npc = FIELD(handler,0)+CODE_OFFSET+4;
      } else {
	scp->sc_pc = (int)callml;
	scp->sc_npc = (int)callml+4;
      }
      /* Note that CURRENT_THREAD->in_fatal_signal_handler is not reset here.
       * The onus is on the SML fatal signal handler to call the SML
       * version of thread_reset_fatal_status before returning. */
    }
  }
}

/* Install the above function for a given signal */

static int die_on_signal(int sig)
{
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C | SIGNAL_HANDLED_FATALLY;
  return set_signal_handler(sig,handle_fatal_signal);
}

/* == Integer exception support == 
 *
 * This function is the handler for the emulation trap signals. These
 * are caused by ML arithmetic instructions which overflow (and which
 * should therefore raise an exception) and by allocation sequences
 * which run out of heap (and which should therefore cause a GC).

 * If called while in ML it examines the instruction which caused the
 * exception in order to determine which ML exception to raise, or to
 * do a GC.  The signal context is updated in order to raise the
 * exception (or enter the GC code) when the handler returns.  */

static void signal_integer_exception_handler
  (int sig, int code, struct sigcontext *scp, char *addr)
{
  word instruction = *(word*)addr;

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig, get_callers_frame());
  
  if(!global_state.in_ML) {
    message_stderr("Warning: signal %d outside ML", sig);
    return;
  }

/* Check for allocation traps so we can start a GC.

   Allocation sequences always look like one of the following:

 * 1. Allocating a known amount < 4k:

	taddcctv %g1, #bytes, %g1
	add	rn, %g2, #tag
	add	%g2, %g2, #bytes

 * 2. Allocating an unknown amount, or a known amount > 4k:

 	<get the number of bytes into the 'global' register %g4>
 	taddcctv %g1, %g4, %g1
 	add	rn, %g2, #tag
 	add	%g2, %g2, %g4

 * In a leaf procedure, the 'add rn' instruction (the one after the
 * taddcctv) should be replaced with an 'or rn' instruction. This
 * enables us to distinguish the leaf case.

 * The taddcctv instruction fails if there is insufficient space for
 * the alloc */

#define TADDCCTV_MASK 0xffffc000
#define TADDCCTV_BITS 0x83104000

  if ((instruction & TADDCCTV_MASK) == TADDCCTV_BITS) {
    /* then it's a GC entry point */

    int leaf;
    word instr2;
    word overwrite_instr; /* the instruction to put in the overwrite slot */
    word *overwrite;	/* the address of the overwrite slot */

    /* get the number of bytes */

#define TADDCCTV_IMMEDIATE_FLAG_MASK 0x2000
#define TADDCCTV_IMMEDIATE_MASK 0x1fff

    if (instruction & TADDCCTV_IMMEDIATE_FLAG_MASK) {
      gc_trap_bytes = ((instruction & TADDCCTV_IMMEDIATE_MASK));
    } else {
      /* -1 means "the number is in the 'global' register" */
      gc_trap_bytes = 0xffffffff;
    }

    /* We want to return to address+12, so set the fake link register
       to addr+4 */

    gc_trap_return_address = ((word)addr)+4;

    /* construct tagging instruction, which tags the value in the
       return register and puts it in whatever register the allocation
       routine was going to put it. We do this by getting the tagging
       instruction out of the allocation routine and changing the
       register number */

    instr2 = ((word*)addr)[1];

#define GC_RETURN_REGISTER 0x1u
#define GC_TAGGING_SHIFT 14u
#define GC_TAGGING_MASK 0x1fu

    overwrite_instr =
      ((instr2 & (~(GC_TAGGING_MASK << GC_TAGGING_SHIFT)))
       | (GC_RETURN_REGISTER << GC_TAGGING_SHIFT));

    /* was the allocation routine in a leaf procedure? */

#define GC_ENTRY_LEAF_MASK 0x3f
#define GC_ENTRY_LEAF_SHIFT 19
#define GC_ENTRY_LEAF_VALUE 2

    leaf = (((instr2 & (GC_ENTRY_LEAF_MASK << GC_ENTRY_LEAF_SHIFT))
		 >> GC_ENTRY_LEAF_SHIFT) == GC_ENTRY_LEAF_VALUE);

    if (leaf) {
      scp->sc_pc = (int)gc_trap_entry_leaf;
      scp->sc_npc = ((int)gc_trap_entry_leaf)+4;
      overwrite = gc_trap_ret_leaf_overwrite;
    } else {
      scp->sc_pc = (int)gc_trap_entry;
      scp->sc_npc = ((int)gc_trap_entry)+4;
      overwrite = gc_trap_ret_overwrite;
    }
    *overwrite = overwrite_instr;
    cache_flush((void *)overwrite,sizeof(word));
    return;
  }

  /* Not a GC trap, so what was it? */

  DIAGNOSTIC(3, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(3, "  addr 0x%X: %08X", addr, *(word*)addr);

  /* Switch on the instruction code: SPARC specific */

  switch(instruction & 0xC1F80000) {
    case 0x81180000:
    DIAGNOSTIC(4, "  tsubcctv", 0, 0);
    break;

    case 0x81100000:
    DIAGNOSTIC(4, "  taddcctv", 0, 0);
    break;

    default:
    DIAGNOSTIC(4, "  not a tagged trap int instruction", 0, 0);
    message_stderr("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
    return;
  }
  scp->sc_o0 = DEREF(perv_exn_ref_overflow);
  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
}

/* == Licensing support == 
 * 
 * SIGALRM is handled by refreshing the license. */

static void signal_timer_handler
    (int sig, int code, struct sigcontext *scp, char *addr)
{
  refresh_license();

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig, get_callers_frame());
}

extern void signal_license_timer (int interval) 
{
  struct itimerval period;

  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");

  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */

  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
  period.it_value.tv_usec = 0;
  period.it_interval.tv_sec = interval;
  period.it_interval.tv_usec = 0;
  
  if(setitimer(ITIMER_REAL, &period, NULL) == -1)
    error("Unable to set up licensing timer.  "
	  "setitimer set errno to %d.", errno);
}

/* == Interrupt Support ==
 * 
 * SIGINT is handled and interpreted as an interrupt. */

static void signal_interrupt_handler (int sig, int sig_code,
				      struct sigcontext *scp,
				      char *addr)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      ml_signal_handler(sig, get_callers_frame());
    else 
      signal_ml_event(get_callers_frame());
  
    record_event(EV_INTERRUPT, (word) 0);
  }
}

extern int signal_set_interrupt_handler(void)
{
  signal_handled[SIGINT] |= SIGNAL_HANDLED_IN_C;	/* interrupt */
  return set_signal_handler(SIGINT,signal_interrupt_handler);
}

extern int signal_clear_interrupt_handler(void)
{
  signal_handled[SIGINT] &= !SIGNAL_HANDLED_IN_C;

  if (signal_handled[SIGINT] & SIGNAL_HANDLED_IN_ML)
    return signal_set_ml_handler(SIGINT);
  else
    return restore_default_signal_handler(SIGINT);
}

/* == Timer support ==
 *
 * We need a virtual-time alarm for several purposes: stack-based
 * profiling, thread pre-emption, and window updates.
 */

static struct itimerval interval_timer, residual_timer;
unsigned int current_interval = 0;

/* the number of milliseconds for the profiling and pre-emption intervals. */

unsigned int profiling_interval = 0;
unsigned int thread_preemption_interval = 0;
unsigned int window_update_interval = 0;
static unsigned int window_update_remaining = 0;
static unsigned int window_updates_on = 0;

static void signal_start_timer(void)
{
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, &residual_timer) == -1)
    message("Warning: Unable to set interval timer. \n"
	    " Profiling, preemption, and window updates may not occur");
}

static unsigned int signal_set_timer(unsigned int interval)
{
  unsigned int last_interval = current_interval;
  current_interval = interval;
  interval_timer.it_value.tv_sec = interval/1000;
  interval_timer.it_value.tv_usec = (interval%1000)*1000;
  interval_timer.it_interval.tv_sec = 0;
  interval_timer.it_interval.tv_usec = 0; /* one shot timer */

  signal_start_timer();
  interval = ((residual_timer.it_value.tv_sec * 1000) +
	      (residual_timer.it_value.tv_usec / 1000));
  interval = last_interval - interval;
  return interval;
}

static int signal_update_windows(unsigned int interval)
{
  if (window_update_remaining < interval) {
    window_update_remaining = window_update_interval;
    if (window_updates_on) {
      record_event(EV_WINDOWS, (word) 0);
      return 1;
    }
  } else
    window_update_remaining -= interval;
  return 0;
}
  
static void signal_do_timer(unsigned int interval)
{
  unsigned int residue = signal_set_timer(interval);
  (void)signal_update_windows(residue);
}

/* The signal handler function. If we're profiling we run the
 * profiler. If we're pre-empting we record the event. */

static void signal_interval_alarm (int sig, int sig_code,
				   struct sigcontext *scp,
				   char *addr)
{
  struct sigtramp_frame *sf = get_callers_frame();

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig, sf);
  
  if (profile_on)
    time_profile_scan((struct stack_frame *) scp->sc_sp);
  
  if (thread_preemption_on) {
    thread_preemption_pending = 1;
    record_event(EV_SWITCH, (word) 0);
    if ((signal_handled[sig] & SIGNAL_HANDLED_IN_ML) == 0)
      signal_ml_event(sf);
  }

  if (signal_update_windows (current_interval))
    signal_ml_event(sf);
  
  signal_start_timer();
}


/* == Profiling support == */

extern void signal_profiling_start(void)
{
  signal_do_timer(profiling_interval);
}

extern void signal_profiling_stop(void)
{
  unsigned int interval;
  if (thread_preemption_on)
    interval = thread_preemption_interval;
  else if (window_updates_on)
    interval = window_update_interval;
  else
    interval = 0;
  signal_do_timer(interval);
}

/* == Preemption support == */

extern void signal_preemption_start(void)
{
  if (!profile_on)
    signal_do_timer(thread_preemption_interval);
}

extern void signal_preemption_stop(void)
{
  if (!profile_on) {
    unsigned int interval;
    if (window_updates_on)
      interval = window_update_interval;
    else
      interval = 0;
    signal_do_timer(interval);
  }
}

extern void signal_preemption_change(void)
{
  signal_preemption_start();
}

/* Window update support */

extern void signal_window_updates_start(void)
{
  window_updates_on = 1;
  if (current_interval == 0)
    signal_do_timer(window_update_interval);
}

extern void signal_window_updates_stop(void)
{
  window_updates_on = 0;
}

/* a generic routine to make a new copy of some code */

static word* copy_code(char* start, char* finish)
{
  unsigned int bytes = finish-start;
  word *result = (word*)malloc(bytes);
  memcpy(result,start,bytes);
  return result;
}

/* copy the two GC return codes into the data segment */

static void copy_codes(void)
{
  gc_trap_ret_code = copy_code((char*) &gc_trap_ret_template,
			       (char*) &gc_trap_ret_template_end);
  gc_trap_ret_leaf_code = copy_code((char*) &gc_trap_ret_leaf_template,
				    (char*) &gc_trap_ret_leaf_template_end);

  gc_trap_ret_overwrite = (word*) (((int)gc_trap_ret_code) +
				   ((int)&gc_trap_ret_template_overwrite) -
				   ((int)&gc_trap_ret_template));
  gc_trap_ret_leaf_overwrite =
    (word*) (((int)gc_trap_ret_leaf_code) +
	     ((int)&gc_trap_ret_leaf_template_overwrite)-
	     ((int)&gc_trap_ret_leaf_template));
}

static void establish_signal_table(void)
{
  int i;
  signal_handled = (word*) alloc(NR_SIGNALS * sizeof(word),
				 "Unable to allocate signal table");
  for (i=0; i < NR_SIGNALS; i++)
    signal_handled[i] = SIGNAL_NOT_HANDLED;
  signal_handled[SIGEMT]    = SIGNAL_HANDLED_IN_C;	/* integer exns */
  signal_handled[SIGVTALRM] = SIGNAL_HANDLED_IN_C;	/* intervals */
}

extern void signals_init (void)
{
  struct sigstack ss;
  char *signal_stack;

  /* Initialise the signal stack */
  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack.");

  ss.ss_sp = signal_stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);

  /* set up 'where is signal handled' table */
  establish_signal_table();

  /* establish integer arithmetic exception catcher */
  if(set_signal_handler(SIGEMT, signal_integer_exception_handler))
    error("Unable to set integer exception handler.");

  /* establish virtual interval timer signal handler */
  if(set_signal_handler(SIGVTALRM,signal_interval_alarm))
    error("Unable to set up virtual interval timer signal handler.");

  /* make copies of GC return codes */
  copy_codes();

  /* these signals are fatal */
  die_on_signal (SIGILL);
  die_on_signal (SIGBUS);
  die_on_signal (SIGSEGV);
}

extern void ml_gc_die(mlval closure)
{
  error("ml_gc() called by %s.\n\tYou are probably running out-of-date .mo files\n",
	CSTRING(CCODENAME(FIELD(closure,0))));
}

extern void ml_gc_leaf_die(mlval closure)
{
  error("ml_gc_leaf() called by %s.\n\tYou are probably running out-of-date .mo files\n",
	CSTRING(CCODENAME(FIELD(closure,0))));
}
@


1.50.5.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 3
 * Revision 1.50  1997/01/07  10:47:59  matthew
 * Changing diagnostic level for EMT message
 *
@


1.50.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a13 3
 * Revision 1.50  1997/01/07  10:47:59  matthew
 * Changing diagnostic level for EMT message
 *
@


1.50.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 3
 * Revision 1.50  1997/01/07  10:47:59  matthew
 * Changing diagnostic level for EMT message
 *
@


1.50.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 3
 * Revision 1.50  1997/01/07  10:47:59  matthew
 * Changing diagnostic level for EMT message
 *
@


1.50.1.1
log
@branched from 1.50
@
text
@a13 3
 * Revision 1.50  1997/01/07  10:47:59  matthew
 * Changing diagnostic level for EMT message
 *
@


1.50.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.50.1.1  1997/05/12  10:40:46  hope
 * branched from 1.50
 *
@


1.50.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.50.1.1  1997/05/12  10:40:46  hope
 * branched from 1.50
 *
@


1.50.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.50.1.1  1997/05/12  10:40:46  hope
 * branched from 1.50
 *
@


1.50.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.50.1.1.1.1  1997/07/28  18:28:23  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.49
log
@[Bug #1710]
Adding dummy matherr functions
@
text
@d14 4
d711 2
a712 2
  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *(word*)addr);
d718 1
a718 1
    DIAGNOSTIC(1, "  tsubcctv", 0, 0);
d722 1
a722 1
    DIAGNOSTIC(1, "  taddcctv", 0, 0);
d726 1
a726 1
    DIAGNOSTIC(1, "  not a tagged trap int instruction", 0, 0);
@


1.49.5.1
log
@branched from 1.49
@
text
@a13 4
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
@


1.49.4.1
log
@branched from 1.49
@
text
@a13 4
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
@


1.49.4.1.1.1
log
@branched from 1.49.4.1
@
text
@a13 3
 * Revision 1.49.4.1  1996/12/17  17:53:49  hope
 * branched from 1.49
 *
@


1.49.3.1
log
@branched from 1.49
@
text
@a13 4
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
@


1.49.2.1
log
@branched from 1.49
@
text
@a13 4
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
@


1.49.1.1
log
@branched from 1.49
@
text
@a13 4
 * Revision 1.49  1996/11/08  11:03:48  matthew
 * [Bug #1710]
 * Adding dummy matherr functions
 *
@


1.49.1.1.1.1
log
@branched from 1.49.1.1
@
text
@a13 3
 * Revision 1.49.1.1  1996/11/14  12:57:31  hope
 * branched from 1.49
 *
@


1.48
log
@Merge in license stuff
@
text
@d14 3
d501 6
@


1.47
log
@Update best before to 01/01/97
@
text
@d14 9
d400 1
a400 3
  sv.sv_mask =
    sigmask(SIGEMT) |	/* mustn't take a GC trap */
      sigmask(SIGFPE);    /* or a floating point exception */
a579 30
/*  == Handle math errors in library functions ==
 *
 *  The matherr function is called by the math library when exception
 *  occur.  See matherr(3M).  This function need only handle those
 *  routines we actually provide in reals.[ch]. */

/* Now this should do nothing */
extern int matherr(struct exception *e)
{
/*
  char *problem = e->name;
  int type = e->type;
  if (type != UNDERFLOW)
    {in_ml_fpe = 0;
     if(strcmp(problem, "log") == 0)
       exn_raise(perv_exn_ref_ln);
     else if(strcmp(problem, "fabs") == 0)
       exn_raise(perv_exn_ref_abs);
     else if(strcmp(problem, "exp") == 0)
       exn_raise(perv_exn_ref_exp);
     else if(strcmp(problem, "sqrt") == 0)
       exn_raise(perv_exn_ref_sqrt);
     message_stderr("Warning: Unhandled floating point error in `%s' -- returning %g",
		    problem, e->retval);
   }
*/

  return(1);
}

d703 1
a703 2
  switch(instruction & 0xC1F80000)
  {
a705 1
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
a709 1
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
d717 1
a717 1

d722 1
a722 1
/* == Licensing support ==
d724 1
a724 14
 * The whole licensing mechanism is due to be rewritten, but for now
 * it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */
d726 2
a727 12
#define POLL_PERIOD	600		/* seconds between licence checks */
#define BEST_BEFORE	852076800	/* 1996-07-01 00:00 */

/* The process ID of the child */

int signal_license_child_pid;

/* The handler for SIGCHLD, installed by the main MLWorks process */
/* This handles death of license, and if relevant, export children */

static void signal_child_handler
  (int sig, int code, struct sigcontext *scp, char *addr)
d729 1
a729 4
  int status, available;

  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig, code);
  DIAGNOSTIC(4, "license pid = %d)", signal_license_child_pid, 0);
a732 38
  
  /* Find out what happened to the child.  If waitpid() is interrupted by a */
  /* signal then try again. */
  
  if (signal_license_child_pid != 0) {
    do
      available = waitpid(signal_license_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);
  } else {
    return;
  }

  if (available == 0) {
    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
    return;
  } else {
    if(available == -1)
      error("Unable to determine status of licensing process.  "
	  "waitpid set errno to %d.", errno);

    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
  
    DIAGNOSTIC(4, "available %d status 0x%02X", available, status);

    if(WIFSTOPPED(status))
      error("Licensing process was stopped with signal %d", WSTOPSIG(status));
    else if(WIFSIGNALED(status))
      error("Licensing process was terminated with signal %d", WTERMSIG(status));
    else
      error("Your license has expired.  Contact MLWorks customer support:\n"
	    "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	    "   telephone:        +44 1223 872522");
  }
d735 1
a735 4
/* The handler for SIGALRM, installed by the child (licensing) process */

static void signal_license_alarm_handler
    (int sig, int code, struct sigcontext *scp, char *addr)
d737 1
a737 16
  time_t now;

  now = time(NULL);
  DIAGNOSTIC(4, "child: checking license at time %ld", now, 0);

  if(now == -1)
    message_stderr("child: WARNING: time() returned -1");
  else if (now >= BEST_BEFORE)
  {
    DIAGNOSTIC(1, "child: license expired at time %ld", now, 0);
    exit(1);
  }
}

/* A function called by the main MLWorks process to watch the child
 * process */
d739 3
a741 11
extern void signal_license_watch_child (void)
{
  if(set_signal_handler(SIGCHLD,signal_child_handler))
    error("Unable to set signal handler for SIGCHLD.");
}

/* The licensing child process itself */

extern void signal_license_child (int *pipefd)
{
  struct sigvec sv;
d743 1
a743 3
  char dummy;
  struct itimerval period;
  int i;
d745 2
a746 21
  /* Ignore all signals (if possible) so that signals sent to the */
  /* process group won't affect the licensing process. */
  
  for(i=1; i<NSIG; ++i)
    if (i != SIGALRM)
      /* SIGKILL and SIGSTOP are not blocked by this */
      sigblock(sigmask(i));
  
  /* Check the license once before we start. */
  signal_license_alarm_handler (0,0,NULL,NULL);
  
  /* Set up a real time alarm with a handler to poll the license. */
  
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  sv.sv_handler = signal_license_alarm_handler;
  if(sigvec(SIGALRM, &sv, NULL) == -1)
    error("Licensing process unable to set signal handler for SIGALRM.  "
	  "sigvec set errno to %d.", errno);
  
  period.it_value.tv_sec = POLL_PERIOD;
d748 1
a748 1
  period.it_interval.tv_sec = POLL_PERIOD;
a753 11
  
  /* Read from the child's end of the pipe.  This has the effect of */
  /* blocking the child until the other end is closed by the parent */
  /* exiting. */
  
  close(pipefd[1]);
  if(read(pipefd[0], &dummy, 1))
    error("Licensing process managed to read from pipe.");
  
  DIAGNOSTIC(2, "child: parent died -- exiting", 0, 0);
  exit(0);
d855 2
a856 2
				  struct sigcontext *scp,
				  char *addr)
a974 1
  signal_handled[SIGCHLD]   = SIGNAL_HANDLED_IN_C;	/* licensing */
d999 1
a999 9
  /* establish real arithmetic exception catcher */
/* Don't wish to do this anymore */
/*
  if(ieee_handler("set", "common",
		  (sigfpe_handler_type) signal_real_exception_handler))
    error("Unable to set floating point exception handler.");
*/

  /* establish interval timer signal handler */
d1001 1
a1001 1
    error("Unable to set up interval timer signal handler.");
@


1.47.3.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1996/06/07  09:31:23  jont
 * Update best before to 01/01/97
 *
@


1.47.2.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1996/06/07  09:31:23  jont
 * Update best before to 01/01/97
 *
@


1.47.2.2
log
@Move to Harlequin license server.
@
text
@a13 3
 * Revision 1.47.2.1  1996/10/07  16:12:32  hope
 * branched from 1.47
 *
d394 3
a396 1
  sv.sv_mask = sigmask(SIGEMT);	/* mustn't take a GC trap */
d576 30
d729 2
a730 1
  switch(instruction & 0xC1F80000) {
d733 1
d738 1
d746 1
a746 1
  scp->sc_o0 = DEREF(perv_exn_ref_overflow);
d751 1
a751 1
/* == Licensing support == 
d753 19
a771 1
 * SIGALRM is handled by refreshing the license. */
d773 7
a779 2
static void signal_timer_handler
    (int sig, int code, struct sigcontext *scp, char *addr)
d781 4
a784 1
  refresh_license();
d788 38
d828 23
a850 1
extern void signal_license_timer (int interval) 
d852 3
a854 1
  struct itimerval period;
d856 1
a856 3
  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");
d858 3
a860 1
  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */
d862 25
a886 2
  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
d888 1
a888 1
  period.it_interval.tv_sec = interval;
d894 11
d1006 2
a1007 2
				   struct sigcontext *scp,
				   char *addr)
d1126 1
d1151 9
a1159 1
  /* establish virtual interval timer signal handler */
d1161 1
a1161 1
    error("Unable to set up virtual interval timer signal handler.");
@


1.47.1.1
log
@branched from 1.47
@
text
@a13 3
 * Revision 1.47  1996/06/07  09:31:23  jont
 * Update best before to 01/01/97
 *
@


1.46
log
@Fixing bungle with comment brackets
@
text
@d14 3
d766 1
a766 1
#define BEST_BEFORE	836179200	/* 1996-07-01 00:00 */
@


1.45
log
@Fixing matherr again
@
text
@d14 3
a598 1
*/
@


1.44
log
@Commenting out matherr
@
text
@d14 3
d573 1
a573 2
/* Redundant with new basis now */
/*
d576 1
d592 1
d594 1
a594 1
  return(0);
@


1.43
log
@removing unused real signal handler
@
text
@d14 3
d570 2
d576 1
a576 1
  if (type != UNDERFLOW) /* Ignore underflows */
d592 1
@


1.42
log
@Changes to Exception raising
@
text
@d14 3
a585 90
}

/* == Real arithmetic exception support ==
 *
 *  This function is the handler for the floating point exception
 *  signals.  If called while in ML it examines the instruction which
 *  caused the exception in order to determine which ML exception to
 *  raise.  The signal context is updated in order to change raise the
 *  exception when the handler returns.  */

static void signal_real_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  DIAGNOSTIC(1, "signal %d: IEEE exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig, get_callers_frame());
  
  /* Find out whether the exception occurred in ML or C.  If in C then we */
  /* can ignore it -- the library will call matherr (qv) */

  if( ! global_state.in_ML) {
    if (in_ml_fpe && sig == SIGFPE) {
      in_ml_fpe = 0;
    } else {
      message_stderr("Warning: signal %d outside ML -- ignoring", sig);
    };
    return;
  }

  /* Check that the instruction type is FPOP */
#define FPOP_MASK	0xc1f00000
#define FPOP_BITS	0x81a00000

  if((instruction & FPOP_MASK) != FPOP_BITS)
  {
    DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
    message_stderr("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  /* Switch on the instruction code : SPARC-specific */
#define FPOP_FIELD_MASK 	0x00003fe0
#define FPOP_FIELD_FDTOI 	0x00001a40
#define FPOP_FIELD_FSQRTD 	0x00000540
#define FPOP_FIELD_FADDD 	0x00000840
#define FPOP_FIELD_FSUBD	0x000008c0
#define FPOP_FIELD_FMULD	0x00000940
#define FPOP_FIELD_FDIVD	0x000009c0

  switch(instruction & FPOP_FIELD_MASK)
  {
    /* This case should never happen.  We check the size explicitly,
       because we use 30-bit ints instead of 32-bit ints.
    case FPOP_FIELD_FDTOI:
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
    break;
    */

    case FPOP_FIELD_FSQRTD:
    scp->sc_o0 = DEREF(perv_exn_ref_sqrt);
    break;

    case FPOP_FIELD_FADDD:
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
    break;

    case FPOP_FIELD_FSUBD:
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
    break;

    case FPOP_FIELD_FMULD:
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
    break;

    case FPOP_FIELD_FDIVD:
    scp->sc_o0 = DEREF(perv_exn_ref_overflow);
    break;

    default:
    DIAGNOSTIC(1, "  unknown fpop instruction", 0, 0);
    message_stderr("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
@


1.41
log
@Removing do_exportFn, as this is no longer architecture dependent
@
text
@d14 3
d641 1
a641 1
    scp->sc_o0 = DEREF(perv_exn_ref_floor);
d650 1
a650 1
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
d654 1
a654 1
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
d658 1
a658 1
    scp->sc_o0 = DEREF(perv_exn_ref_prod);
d662 1
a662 1
    scp->sc_o0 = DEREF(perv_exn_ref_quot);
d802 1
a802 1
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
d807 1
a807 1
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
d1221 2
d1226 1
@


1.40
log
@Modify exportFn mechanism not to use signals at all
Use busy waiting in parent instead, thus avoiding
potential race contions
@
text
@d14 5
a919 68
}

/* exportFn support */
mlval do_exportFn(mlval argument)
{
  pid_t child_pid = fork();

  if(child_pid == -1) {
    switch(errno) {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork exportFn process");
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork exportFn process");
      default: 
      exn_raise_format(perv_exn_ref_save,
		       "fork() returned an unexpected error code %d", errno);
    }
  } else if (child_pid == 0) {
    /* The child process */
    mlval global;
    mlval filename = FIELD(argument, 0);
    image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
    declare_root(&filename);
    
    global = global_pack();
    declare_root(&global);
    
    gc_clean_image();
    
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);
    
    if(image_save(argument) == ERROR)
      exit(errno ? errno : -1);
    
    exit(0);
  } else {
    /* The parent process */
    int status;
    DIAGNOSTIC(4, "Setting export child pid is %d", child_pid, 0);
    /* Now wait for the child to complete, and get its return status */
    do {
      waitpid(child_pid, &status, 0);
    } while(!(WIFSIGNALED(status) || WIFEXITED(status)));
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save, "Export process terminated by signal %d",
		       WTERMSIG(status));
    }
    switch(WEXITSTATUS(status)) {
    case 0:
      break;
    case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Function save not implemented");
    case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
    case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");
    default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
    }
    return MLUNIT; /* Should later change to return to MLWorks */
  }
@


1.39
log
@Ensure signal_child_handler only deals with signals from known children
@
text
@d14 3
a835 8
/* The process ID of the exportFn child */

static int signal_export_child_pid = 0;

static int export_exists = 0; /* Something to ensure we don't miss signals */
static int export_child_status = 0;
static int child_exited = 1;

d845 1
a845 1
  DIAGNOSTIC(4, "license and export pids = %d, %d)", signal_license_child_pid, signal_export_child_pid);
d859 1
a859 1
    available = 0;
a862 14
    /* No status available for licensing process, try export */
    if (signal_export_child_pid != 0) {
      do
	available = waitpid(signal_export_child_pid,
			    &status, WNOHANG | WUNTRACED);
      while(available == -1 && errno == EINTR);
    } else {
      available = 0;
    }

    if (available == -1)
      error("Unable to determine status of export process.  "
	    "waitpid set errno to %d.", errno);

d866 1
a866 25

    if (available != 0) {
      DIAGNOSTIC(1, "available %d status 0x%02X", available, status);

      if(WIFSTOPPED(status))
	error("Export process stopped with signal %d", WSTOPSIG(status));
      else if(WIFSIGNALED(status))
	error("Export process terminated with signal %d", WTERMSIG(status));
      else if(WIFEXITED(status)) {
	/* This is the case where the child has exited roughly as expected */
	DIAGNOSTIC(1, "Export process terminated with status %d",
		   WEXITSTATUS(status), 0);
	export_child_status = status;
	child_exited = 1;
	return;
      } else
	error("Export process terminated for unknown reason");

    } else {
      /* else status has changed back again */
      /* Or we have a signal from an unexpected child, caused eg by getcwd */
      DIAGNOSTIC(1, "Ignoring unexpected child signal", 0, 0);
      return;
    }

a888 15
static void clear_export_child_status(void)
{
  child_exited = 0;
}

static int read_export_child_status(void)
{
  return WEXITSTATUS(export_child_status);
}

static int check_export_child_status(void)
{
  return child_exited;
}

a916 12
static void signal_export_watch_child(void)
{
  DIAGNOSTIC(4, "Watching export child", 0, 0);
  export_exists = 1;
}

static void signal_export_unwatch_child(void)
{
  DIAGNOSTIC(4, "Unwatching export child", 0, 0);
  export_exists = 0;
}

d920 1
a920 5
  pid_t child_pid;

  clear_export_child_status();
  signal_export_watch_child();
  child_pid = fork();
d958 2
a959 2
    DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
    signal_export_child_pid = child_pid;
d961 9
a969 4
    /* Busy wait, is there a better way to do this? */
    while (check_export_child_status() == 0);
    signal_export_unwatch_child();
    switch (read_export_child_status()) {
@


1.38
log
@Make interval window updates happen even if we stay in ML.
@
text
@d14 3
d835 1
a835 1
int signal_export_child_pid;
d858 8
a865 4
  do
    available = waitpid(signal_license_child_pid,
			&status, WNOHANG | WUNTRACED);
  while(available == -1 && errno == EINTR);
d869 8
a876 4
    do
      available = waitpid(signal_export_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);
d878 1
a878 1
    if(available == -1)
d886 1
a886 1
    if(available) {
d905 3
a907 1
      error("exportFn:Child status has unexpectedly reverted");
@


1.37
log
@Add <unistd.h>
@
text
@d14 3
a183 2
extern struct stack_frame *get_callers_frame(void);

d205 2
d391 1
a391 5
/* note that signal_ml_event has to be inlined in the signal handler
 * because get_callers_frame has to get the frame for sigtramp. See
 * the comment for struct sigtramp_frame at the head of this file. */

static inline void signal_ml_event (struct sigcontext *scp)
d393 1
a393 2
  if (global_state.in_ML) {
    struct sigtramp_frame *sf = (struct sigtramp_frame *)get_callers_frame();
a394 1
  }
d397 1
a397 3
/* This function converts a C signal into an ML signal event. It must
 * be inlined in an actual signal handler, so that get_callers_frame
 * can work correctly. */
d399 1
a399 2
static inline void ml_signal_handler
  (int sig, struct sigcontext *scp)
d405 1
a405 1
    signal_ml_event(scp);
d412 1
a412 1
  ml_signal_handler(sig,scp);
d457 1
a457 1
static inline void die_in_fatal_signal_handler(char const *message)
d484 1
a484 1
    st_frame= (struct sigtramp_frame *) get_callers_frame();
d490 1
a490 1
      ml_signal_handler(sig,scp);
d588 1
a588 1
    ml_signal_handler(sig,scp);
d679 1
a679 1
    ml_signal_handler(sig,scp);
d850 1
a850 1
    ml_signal_handler(sig,scp);
d1104 1
a1104 1
      ml_signal_handler(sig,scp);
d1106 1
a1106 1
      signal_ml_event(scp);
d1145 1
a1145 1
static inline void signal_start_timer(void)
d1152 1
a1152 1
static inline unsigned int signal_set_timer(unsigned int interval)
d1168 1
a1168 1
static inline void signal_update_windows(unsigned int interval)
d1171 2
a1172 1
    if (window_updates_on)
d1174 2
a1175 1
    window_update_remaining = window_update_interval;
d1178 1
d1181 1
a1181 1
static inline void signal_do_timer(unsigned int interval)
d1184 1
a1184 1
  signal_update_windows(residue);
d1194 2
d1197 1
a1197 1
    ml_signal_handler(sig,scp);
d1206 1
a1206 1
      signal_ml_event(scp);
d1209 3
a1211 1
  signal_update_windows (current_interval);
d1276 1
a1276 1
static inline word* copy_code(char* start, char* finish)
d1286 1
a1286 1
static inline void copy_codes(void)
d1302 1
a1302 1
static inline void establish_signal_table(void)
@


1.36
log
@Disable interrupt handling except when a handler is defined.
@
text
@d14 3
d154 1
@


1.35
log
@Remove "storage manager" interface; replace it with regular functions.
@
text
@d14 3
d326 46
a416 15
static int check_sigvec (int sig, struct sigvec *vec)
{
  int result = sigvec (sig,vec,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigvec returned an unexpected error code %d", errno);
    }
  return result;
}

d425 1
a425 13
      struct sigvec vec;
      vec.sv_handler = signal_ml_handler;

      /* due to an OS bug in SunOS, we have to mask our
       * control-flow-changing signals here, because otherwise their
       * handlers can over-ride these ones, with the result that the
       * process signal mask doesn't get reset correctly. */
      vec.sv_mask =
	sigmask(SIGEMT) |	/* mustn't take a GC trap */
	  sigmask(SIGFPE);    /* or a floating point exception */
      vec.sv_flags = SV_ONSTACK;
      
      return (check_sigvec (sig,&vec));
d437 1
a437 6
      struct sigvec vec;
      vec.sv_handler = SIG_DFL;
      vec.sv_mask = 0;
      vec.sv_flags = SV_ONSTACK;

      return (check_sigvec (sig,&vec));
a446 13


static int restore_default_signal_handler(int sig)
{
  struct sigvec sv;
  sv.sv_handler = SIG_DFL;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  return sigvec(sig, &sv, NULL);
}



a458 2


a465 2


a537 1

a541 5
  struct sigvec vec;

  vec.sv_handler = handle_fatal_signal;
  vec.sv_mask = 0;
  vec.sv_flags = SV_ONSTACK;
d543 1
a543 2
  
  return (sigvec(sig,&vec,NULL));
d676 1
a676 1
  (int sig, int code, struct sigcontext *scp, word *addr)
d678 1
a678 1
  word instruction = *addr;
d746 1
a746 1
    instr2 = addr[1];
d782 1
a782 1
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);
d844 1
a844 1
  (int sig, int code, struct sigcontext *scp, word *addr)
d939 1
a939 1
    (int sig, int code, struct sigcontext *scp, word *addr)
d960 2
a961 8
  struct sigvec sv;

  sv.sv_handler = signal_child_handler;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  if(sigvec(SIGCHLD, &sv, NULL) == -1)
    error("Unable to set signal handler for SIGCHLD.  "
	  "sigvec set errno to %d.", errno);
a1052 3
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  
a1055 1
  sv.sv_handler = SIG_IGN;
d1066 2
d1114 16
a1303 1
  signal_handled[SIGINT]    = SIGNAL_HANDLED_IN_C;	/* interrupt */
a1310 1
  struct sigvec sv;
d1314 10
a1324 1

a1326 8
  /* establish interrupt handler */
  sv.sv_handler = signal_interrupt_handler;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;
  if(sigvec(SIGINT, &sv, NULL) == -1)
    error("Unable to set interrupt signal handler.  "
          "sigvec set errno to %d.", errno);

d1328 2
a1329 7
  sv.sv_handler = signal_integer_exception_handler;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;

  if(sigvec(SIGEMT, &sv, NULL) == -1)
    error("Unable to set integer exception handler.  "
          "sigvec set errno to %d.", errno);
d1334 1
a1334 2
    error("Unable to set floating point exception handler.  "
	  "ieee_handler set errno to %d.", errno);
d1337 2
a1338 19

  sv.sv_handler = signal_interval_alarm;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;

  if(sigvec(SIGVTALRM, &sv, NULL) == -1)
    error("Unable to set up interval timer signal handler.  "
	  "Sigvec set errno to %d.", errno);

  /* Initialise the signal stack */

  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack.");

  ss.ss_sp = signal_stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);
a1340 1

a1343 1

@


1.34
log
@Add a patch to die_on_signal that I should have added in my previous bug fix.
@
text
@d14 3
d146 1
a991 2
  mlval global, filename;

d999 1
a999 2
    switch(errno)
      {
a1002 1

d1005 4
a1008 8
		       "Insufficient memory to fork licensing process");

      default:
      {
	char error_message[200];
	sprintf(error_message, "fork() returned an unexpected error code %d", errno);
	exn_raise_string(perv_exn_ref_save, error_message);
      }
d1010 22
d1033 18
a1050 73
    if (child_pid == 0) {
      /* The child process */
      filename = FIELD(argument, 0);
      image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
      declare_root(&filename);

      global = global_pack();
      declare_root(&global);

      {
	mlval old_message_level = MLSUB(gc_message_level,0);
	clear_handlers(); /* Don't follow the signal handlers */
	clear_thread_roots(); /* Don't follow roots in ml_state etc */
	MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
	/* now do big garbage collections, without scanning the ML stack */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	(void) sm_interface(SM_PROMOTE_ALL, 0, MLUNIT); /* merge all gens */
	MLUPDATE(gc_message_level,0,MLINT(-1));		/* turn on messages */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	MLUPDATE(gc_message_level,0,old_message_level);
      }

      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);

      if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
	switch(errno)
	  {
	  case EIMPL:
	    exit(EIMPL);
	    error("Function save not implemented");

	  case EIMAGEWRITE:
	    exit(EIMAGEWRITE);
	    error("Error writing opened image file");

	  case EIMAGEOPEN:
	    exit(EIMAGEOPEN);
	    error("Unable to open image file");

	  default:
	    exit(errno ? errno : -1);
	    error("Unexpected error from exportFn");
	  }

      exit(0);
    } else {
      /* The parent process */
      DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
      signal_export_child_pid = child_pid;
      /* Now wait for the child to complete, and get its return status */
      /* Busy wait, is there a better way to do this? */
      while (check_export_child_status() == 0);
      signal_export_unwatch_child();
      switch (read_export_child_status()) {
      case 0:
	break;
      case EIMPL:
	exn_raise_string(perv_exn_ref_save, "Function save not implemented");

      case EIMAGEWRITE:
	exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
	exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
	exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
      }
      return MLUNIT; /* Should later change to return to MLWorks */
d1052 1
d1056 1
a1056 1
/* The child process itself */
@


1.33
log
@Fix bug #995 - death of last thread due to a fatal signal should
result in a non-zero termination code.
@
text
@d14 4
d544 1
a544 1
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C;
@


1.32
log
@Fix fatal signal handler so that it does not loop if a
fatal signal is received whilst the handler is active.
@
text
@d14 4
d260 1
d422 28
a449 1
static void install_default_fatal_signal_handlers(void)
d451 3
a453 7
  struct sigaction new_action;
  new_action.sa_handler= SIG_DFL;
  sigemptyset(&new_action.sa_mask);
  if ((sigaction(SIGILL,  &new_action, (struct sigaction *)0) != 0)
  ||  (sigaction(SIGBUS,  &new_action, (struct sigaction *)0) != 0)
  ||  (sigaction(SIGSEGV, &new_action, (struct sigaction *)0) != 0))
    error_without_alloc("Could not install default fatal signal handlers");
d457 1
d462 2
a463 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Corrupt threads.  Dying ...\n");
d465 5
a469 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Fatal signal raised in fatal signal handler!  Dying ...\n");
d475 1
a482 6
    if (in_GC) {
      install_default_fatal_signal_handlers();
      error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	    signal_name, sig, code);
    }

d488 2
a489 13
      void (*old_messager_function)(const char * message) = messager_function;
      messager_function = NULL;
      message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	       signal_name, sig, code, global_state.in_ML? "" : "not ");
      backtrace ((struct stack_frame *)scp->sc_sp, CURRENT_THREAD,
		 max_backtrace_depth);
      messager_function = old_messager_function;
      SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
      if (global_state.in_ML) { 
	scp->sc_pc = (int)stub_c+CODE_OFFSET;
	scp->sc_npc = (int)stub_c+CODE_OFFSET+4;
	scp->sc_o0 = MLUNIT;
	st_frame->frame.closure = (int)signal_thread_suicide_stub+POINTER;
d491 20
a510 2
	scp->sc_pc = (int) thread_suicide;
	scp->sc_npc = (int)thread_suicide+4;
a511 5
      /* to reduce the race window the following should be near the
       * end of thread_suicide.  However, that entails putting it in
       * the end of the asm routine change_thread, so for simplicity it
       * is left here. */
      CURRENT_THREAD->in_fatal_signal_handler= 0;
d529 1
@


1.31
log
@Add timer-triggered window updates.
@
text
@d14 3
d417 12
d432 12
a443 4
  const char *signal_name = name_that_signal (sig);
  mlval handler = THREAD_ERROR_HANDLER(CURRENT_THREAD);
  struct sigtramp_frame *st_frame = 
    (struct sigtramp_frame *) get_callers_frame();
d445 12
a456 1
  flush_windows();
d458 2
a459 9
  DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

  if (in_GC) {
    error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	  signal_name, sig, code);
  }

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig,scp);
d461 24
a484 26
  if (handler == MLUNIT) {
    /* there is no handler; print a message and kill this thread. */
    void (*old_messager_function)(const char * message) = messager_function;
    messager_function = NULL;
    message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	     signal_name, sig, code, global_state.in_ML? "" : "not ");
    backtrace ((struct stack_frame *)scp->sc_sp, CURRENT_THREAD,
	       max_backtrace_depth);
    messager_function = old_messager_function;
    SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
    if (global_state.in_ML) { 
      scp->sc_pc = (int)stub_c+CODE_OFFSET;
      scp->sc_npc = (int)stub_c+CODE_OFFSET+4;
      scp->sc_o0 = MLUNIT;
      st_frame->frame.closure = (int)signal_thread_suicide_stub+POINTER;
    } else {
      scp->sc_pc = (int) thread_suicide;
      scp->sc_npc = (int)thread_suicide+4;
    }
  } else {
    /* there is a handler; skip to it */
    scp->sc_o0 = MLINT(sig);
    st_frame->frame.closure = handler;
    if (global_state.in_ML) {
      scp->sc_pc = FIELD(handler,0)+CODE_OFFSET;
      scp->sc_npc = FIELD(handler,0)+CODE_OFFSET+4;
d486 13
a498 2
      scp->sc_pc = (int)callml;
      scp->sc_npc = (int)callml+4;
@


1.30
log
@Extensions to event handling for non-signal events.
@
text
@d1099 2
a1100 2
 * We need a virtual-time alarm for two purposes: for stack-based profiling
 * and for thread pre-emption.
d1103 2
a1104 1
static struct itimerval interval_timer;
d1110 3
d1116 3
a1118 3
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, NULL) == -1)
    message("Warning: Unable to set interval timer (setitimer set errno "
	    "to %d).  Stack profiling and preemption will not occur.", errno);
d1121 1
a1121 1
static inline void signal_set_timer(unsigned int interval)
d1123 2
d1131 20
d1173 1
d1182 1
a1182 1
  signal_set_timer(profiling_interval);
d1187 1
a1187 1
  signal_set_timer(0);
d1189 6
a1194 1
    signal_set_timer(thread_preemption_interval);
d1202 1
a1202 1
    signal_set_timer(thread_preemption_interval);
d1207 8
a1214 2
  if (!profile_on)
    signal_set_timer(0);
d1220 14
@


1.29
log
@Update best-before date to 1996-07-01.
@
text
@d14 3
d248 8
d307 5
a311 3
/* reserving and releasing signals */

static int reserved[NR_SIGNALS];
d313 1
a313 1
extern int signal_reserve(int sig)
d315 2
a316 33
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 1;
  return 0;
}
    
extern int signal_release(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (!reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 0;
  return 0;
}  

extern int signal_reserved(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  return (reserved[sig]);
d319 3
a321 3
/* note that record_event has to be inlined because get_callers_frame
 * has to get the frame for sigtramp. See the comment for struct
 * sigtramp_frame at the head of this file. */
d323 1
a323 1
static inline void record_event (struct sigcontext *scp)
a328 3

  /* always set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
d331 3
a333 4
/*  == The C signal handler ==
 *
 *  This function converts a C signal into an ML signal event.
 */
d335 2
a336 2
static void signal_ml_handler
  (int sig, int code, struct sigcontext *scp, char *addr)
a337 2
  struct event *event;

d341 4
a344 9
    event = alloc(sizeof(struct event), "Couldn't allocate event");
    event->type = SIGNAL;
    event->the.signal = sig;

    event->forward = &event_queue;
    event->back = event_queue.back;
    event->forward->back = event;
    event->back->forward = event;
    ++event_queue.the.sentinel_count;
d346 4
a349 5
    DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	       sig, event_queue.the.sentinel_count);

    record_event(scp);
  }
a366 1

d371 20
a390 14
  struct sigvec vec;

  vec.sv_handler = signal_ml_handler;

  /* due to an OS bug in SunOS, we have to mask our
   * control-flow-changing signals here, because otherwise their
   * handlers can over-ride these ones, with the result that the
   * process signal mask doesn't get reset correctly. */
  vec.sv_mask =
    sigmask(SIGEMT) |	/* mustn't take a GC trap */
    sigmask(SIGFPE);    /* or a floating point exception */
  vec.sv_flags = SV_ONSTACK;

  return (check_sigvec (sig,&vec));
d395 8
a402 1
  struct sigvec vec;
d404 4
a407 5
  vec.sv_handler = SIG_DFL;
  vec.sv_mask = 0;
  vec.sv_flags = SV_ONSTACK;

  return (check_sigvec (sig,&vec));
d421 1
a421 1

d431 3
d476 1
a480 14
/* == Stack overflow support ==
 * 
 * When we exceed the user-specified number of stack blocks, we want
 * to signal into the ML debugger. This is the portable interface:
 * self_signal (signal_stack_overflow) is called. */

int signal_stack_overflow = SIGUSR1;
int signal_interrupt = SIGINT;

extern void self_signal (int sig)
{
  kill (getpid(),(int) sig);
}

d524 3
d615 3
d619 1
a619 1
    message_stderr("Warning: signal %d outside ML -- ignoring", sig);
a742 1

d786 3
d1077 20
d1134 3
d1142 3
a1144 1
    record_event(scp);
d1212 13
d1231 12
a1243 1

a1252 1

a1287 11

  /* these signals are reserved to the runtime */

  signal_reserve (SIGILL);	/* fatal */
  signal_reserve (SIGBUS);	/* fatal */
  signal_reserve (SIGSEGV);	/* fatal */
  signal_reserve (SIGEMT);	/* integer exceptions */
  signal_reserve (SIGFPE);	/* real exceptions */
  signal_reserve (SIGVTALRM);	/* profiling and preemption */
  signal_reserve (SIGINT);	/* interrupt */
  signal_reserve (SIGUSR1);	/* stack overflow */
@


1.28
log
@Improve the full GC we do during function export.
@
text
@d14 3
d785 1
a785 1
#define BEST_BEFORE	820454400	/* 1996-01-01 00:00 */
@


1.27
log
@Add do_exportFn to do the system specific part of exportFn
@
text
@d14 3
d979 5
a983 2
	MLUPDATE(gc_message_level,0,MLINT(-1));
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
@


1.26
log
@Unusual SIGINT bug.
@
text
@d14 3
d119 4
d785 8
d794 1
d796 1
a796 1
static void signal_license_child_handler
d802 1
a802 1
  DIAGNOSTIC(4, "         child = %d)", signal_license_child_pid, 0);
d811 41
a851 3
  
  if(available == -1)
    error("Unable to determine status of licensing process.  "
d854 3
a856 3
  /* If available is non zero then something happened to the child.  If it */
  /* is zero then the child status changed, but changed back (for example, */
  /* both child and parent were suspended from the shell and restarted. */
a857 2
  if(available)
  {
d871 15
d912 1
a912 1
  sv.sv_handler = signal_license_child_handler;
d918 116
@


1.25
log
@Change to profiler interface.
@
text
@d14 3
d392 8
a399 1
  vec.sv_mask = 0;
d553 2
d556 1
a556 1
  if((instruction & 0xC1F00000) != 0x81A00000)
d564 7
d572 1
a572 1
  switch(instruction & 0x00003FE0)
d576 1
a576 2
    case 0x1A40:
    DIAGNOSTIC(1, "  fdtoi", 0, 0);
d581 1
a581 2
    case 0x0540:
    DIAGNOSTIC(1, "  fsqrtd", 0, 0);
d585 1
a585 2
    case 0x0840:
    DIAGNOSTIC(1, "  faddd", 0, 0);
d589 1
a589 2
    case 0x08C0:
    DIAGNOSTIC(1, "  fsubd", 0, 0);
d593 1
a593 2
    case 0x0940:
    DIAGNOSTIC(1, "  fmuld", 0, 0);
d597 1
a597 2
    case 0x09C0:
    DIAGNOSTIC(1, "  fdivd", 0, 0);
@


1.24
log
@Update best-before date.
@
text
@d14 3
d931 1
a931 1
    profile_scan((struct stack_frame *) scp->sc_sp);
@


1.23
log
@Fix minor thinko in fatal_signal.
@
text
@d14 3
d756 1
a756 1
#define BEST_BEFORE	804553200	/* 1995-07-01 00:00 */
@


1.22
log
@Tidy up fatal signal handling some more.
@
text
@d14 3
d435 1
a435 1
      st_frame->frame.closure = (int)signal_thread_suicide_stub+RECORD;
@


1.21
log
@Tidy up fatal signal handling.
@
text
@d14 3
d428 3
a430 3
    if (global_state.in_ML) {	/* this part works OK */
      scp->sc_pc = (int)stub_c+3;
      scp->sc_npc = (int)stub_c+7;
d432 1
a432 1
      st_frame->frame.closure = (int)signal_thread_suicide_stub+5;
d439 2
d442 2
a443 4
      scp->sc_pc = FIELD(handler,0)+3;
      scp->sc_npc = FIELD(handler,0)+7;
      scp->sc_o0 = MLINT(sig);
      st_frame->frame.closure = handler;
a444 2
      scp->sc_o0 = MLINT(sig);
      st_frame->frame.closure = handler;
@


1.20
log
@Better fatal signal handling.
@
text
@d14 3
d394 2
a397 2
/* Do something tolerable in the face of a fatal signal */

d402 4
a405 3
  void (*old_messager_function)(const char * message) = NULL;
  mlval handler;
  struct sigtramp_frame *st_frame;
a407 2
  st_frame = (struct sigtramp_frame *) get_callers_frame();

a414 1
  handler = THREAD_ERROR_HANDLER(CURRENT_THREAD);
d417 1
a417 1
    old_messager_function = messager_function;
@


1.19
log
@If signal_ml_handler is called while we are waiting for an X event,
the runtime just prints a message.  This avoids problems with pointer
grabs in X callbacks.
@
text
@d14 5
d112 35
a146 7
 * This routine is used on the SPARC to set the saved stack limit
 * register on a signal handler's stack to -1 so that when it is
 * restored on return from the signal handler ML enters the signal
 * handling code. It is is interface.S
 */

extern void set_stack_underflow(void);
d306 3
a308 4
/* note that record_event has to be inlined because
 * set_stack_underflow (an asm function) assumes things about the top
 * of stack which are only true in the signal handling function
 * itself. */
d313 2
a314 1
    set_stack_underflow();
d391 2
d395 1
a395 1
static void handle_die_gracefully(int sig, int code,
d400 5
d412 35
a446 10
  old_messager_function = messager_function;
  messager_function = NULL;
  message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	   signal_name, sig, code, global_state.in_ML? "" : "not ");
  backtrace ((struct stack_frame *)scp->sc_sp, CURRENT_THREAD,
	     max_backtrace_depth);
  messager_function = old_messager_function;
  SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
  scp->sc_pc = (int) thread_suicide;
  scp->sc_npc = (int)thread_suicide+4;
d455 1
a455 1
  vec.sv_handler = handle_die_gracefully;
@


1.18
log
@Add thread_preemption_pending.
@
text
@d14 3
d92 1
d296 1
a296 1
  struct event *event = alloc(sizeof(struct event), "Couldn't allocate event");
d298 12
a309 2
  event->type = SIGNAL;
  event->the.signal = sig;
d311 2
a312 5
  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;
d314 2
a315 4
  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);

  record_event(scp);
@


1.17
log
@Make fatal signal messages come out on stderr.
@
text
@d14 3
d848 2
a849 1
  if (thread_preemption_on)
d851 1
@


1.16
log
@Changing underflow behaviour in matherr
@
text
@d14 3
d352 1
d360 2
d366 1
@


1.15
log
@Fix profiler entry.
@
text
@d14 3
d401 14
a414 13

  in_ml_fpe = 0;
  if(strcmp(problem, "log") == 0)
    exn_raise(perv_exn_ref_ln);
  else if(strcmp(problem, "fabs") == 0)
    exn_raise(perv_exn_ref_abs);
  else if(strcmp(problem, "exp") == 0)
    exn_raise(perv_exn_ref_exp);
  else if(strcmp(problem, "sqrt") == 0)
    exn_raise(perv_exn_ref_sqrt);

  message_stderr("Warning: Unhandled floating point error in `%s' -- returning %g",
	  problem, e->retval);
d416 1
a416 1
  return(e->retval);
@


1.14
log
@Introduce the threads system.
@
text
@d14 3
d832 1
a832 1
    profile_scan((struct stack_frame *) CURRENT_THREAD->ml_state.sp);
@


1.13
log
@Adjust best-before date to 1995-07-01 00:00
Also make child sig handler run on current stack (otherwise the
first occurence causes a bus error).
Also correct the Harlequin telephone number.
@
text
@d14 6
d75 2
d257 15
d293 2
a294 3
  
  set_stack_underflow();
  implicit_vector.interrupt = (word) -1;
d350 7
a356 4
  message_stderr ("Intolerable signal %s (%d : %d) received. Backtrace:",
	   signal_name, sig, code);
  backtrace (stderr, (struct stack_frame *)scp->sc_sp, max_backtrace_depth);
  error ("Dying.");
d431 1
a431 2
  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
a432 3
/*
      message_stderr("FP Signal inside fpe, ignoring");
*/
d513 1
a513 2
  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
d791 26
a816 5
/* == Profiling support ==
 * 
 * We provide a virtual-time alarm, which goes off after a
 * user-specified number of milliseconds. When it goes off, we call
 * profile_scan(), and restart the alarm when it returns. */
d818 2
a819 1
static struct itimerval profiler_timer;
d821 2
a822 1
/* The signal handler function. Note that we don't use the arguments at all */
d824 1
a824 1
static void signal_profiler_alarm (int sig, int sig_code,
d828 5
a832 1
  profile_scan((struct stack_frame *) scp->sc_sp);
d834 1
a834 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message_stderr("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
d837 2
a838 1
/* start things off */
d840 1
a840 1
extern void signal_start_profiler_timer(unsigned int interval)
d842 2
a843 1
  struct sigvec vec = {signal_profiler_alarm, SIGVTALRM, SV_ONSTACK};
d845 6
a850 2
  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    error("Unable to set up profiler signal handler.");
d852 1
a852 4
  profiler_timer.it_value.tv_sec = interval/1000;
  profiler_timer.it_value.tv_usec = (interval%1000)*1000;
  profiler_timer.it_interval.tv_sec = 0;
  profiler_timer.it_interval.tv_usec = 0; /* one shot timer */
d854 4
a857 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message_stderr("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
d860 5
a864 1
/* kill the timer */
d866 1
a866 1
extern void signal_stop_profiler_timer(void)
d868 1
a868 20
  struct sigvec vec = {SIG_DFL, SIGVTALRM, SV_ONSTACK};

  profiler_timer.it_value.tv_sec = profiler_timer.it_value.tv_usec = 0;
  profiler_timer.it_interval.tv_sec = profiler_timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
  {
    message_stderr("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    vec.sv_handler = SIG_IGN;

    if(sigvec(SIGVTALRM, &vec, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigvec set errno to %d).",
	    errno);
  }
  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message_stderr("Warning: Unable to reset alarm signal handler (sigvec set errno "
	    "to %d).", errno);
a899 1

d922 10
d935 1
a935 1
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack in profiler.");
d960 1
a960 1
  signal_reserve (SIGVTALRM);	/* profiling */
@


1.12
log
@Changed error output to be written to stderr
@
text
@d14 3
d621 2
a622 2
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
d637 1
a637 1
#define BEST_BEFORE	788918400	/* 1995-01-01 sometime */
d680 1
a680 1
	    "   telephone:        +44 223 872522");
d712 1
a712 1
  sv.sv_flags = SV_ONSTACK;
@


1.11
log
@Put in declaration for set_stack_underflow().
@
text
@d14 3
d325 1
a325 1
  message ("Intolerable signal %s (%d : %d) received. Backtrace:",
d378 1
a378 1
  message("Warning: Unhandled floating point error in `%s' -- returning %g",
d407 1
a407 1
      message("FP Signal inside fpe, ignoring");
d411 1
a411 1
      message("Warning: signal %d outside ML -- ignoring", sig);
d421 1
a421 1
    message("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
d464 1
a464 1
    message("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
d491 1
a491 1
    message("Warning: signal %d outside ML -- ignoring", sig);
d607 1
a607 1
    message("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
d692 1
a692 1
    message("child: WARNING: time() returned -1");
d785 1
a785 1
    message("Warning: Unable to set profile timer (setitimer set errno "
d804 1
a804 1
    message("Warning: Unable to set profile timer (setitimer set errno "
d819 1
a819 1
    message("Warning: Unable to unset profile timer (setitimer set errno "
d830 1
a830 1
    message("Warning: Unable to reset alarm signal handler (sigvec set errno "
@


1.10
log
@Add cache flushing.
@
text
@d14 3
d75 9
@


1.9
log
@Better type checking in Gcc 2.5.8 points out a missing cast.
@
text
@d14 3
d59 1
d512 2
a513 1
    word overwrite;
d544 1
a544 1
    overwrite =
d560 1
a560 1
      *gc_trap_ret_leaf_overwrite = overwrite;
d564 1
a564 1
      *gc_trap_ret_overwrite = overwrite;
d566 2
@


1.8
log
@Update license expiry date
@
text
@d14 3
d250 1
a250 1
  implicit_vector.interrupt = -1;
@


1.7
log
@Make sure all handlers execute on signal stack.
@
text
@d14 3
d609 1
a609 1
#define BEST_BEFORE	781024732	/* 1994-10-01 sometime */
@


1.7.1.1
log
@branched from 1.7
@
text
@a13 3
 * Revision 1.7  1994/07/25  13:16:54  nickh
 * Make sure all handlers execute on signal stack.
 *
@


1.7.1.2
log
@Update best before
@
text
@a13 3
 * Revision 1.7.1.1  1995/07/05  10:31:47  hope
 * branched from 1.7
 *
d609 1
a609 1
#define BEST_BEFORE	820454400	/* 1996-01-01 00:00 */
@


1.6
log
@Add GC trap handling.
@
text
@d14 3
d681 1
a681 1
  sv.sv_flags = 0;
d845 1
a845 1
  sv.sv_flags = 0;
@


1.5
log
@Add interrupt signal number and reserve two more signals.
@
text
@d14 3
d46 1
d60 59
d446 9
a454 5
 *  This function is the handler for the emulation trap signals.  If
 *  called while in ML it examines the instruction which caused the
 *  exception in order to determine which ML exception to raise.  The
 *  signal context is updated in order to raise the exception when the
 *  handler returns.  */
a460 3
  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

d467 93
d803 28
d866 4
d886 12
@


1.4
log
@Add critical region support for FP signals
@
text
@d14 3
d260 1
d695 2
@


1.3
log
@Update best-before date.
@
text
@d14 3
d39 1
d273 1
d310 8
a317 1
    message("Warning: signal %d outside ML -- ignoring", sig);
@


1.2
log
@new file
@
text
@d14 3
d430 1
a430 1
#define BEST_BEFORE	773017200	/* 1994-07-01 00:00:00 */
@


1.1
log
@new file
@
text
@d13 4
a16 1
 * $Log:$
@
