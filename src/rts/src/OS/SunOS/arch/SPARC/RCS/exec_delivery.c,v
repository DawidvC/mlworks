head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.1
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_MM_adapt:1.7.12
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.7.9.1.1.1.1
	MLWorks_workspace_97:1.7.11
	MLWorks_dt_wizard:1.7.10
	MLWorks_11c0_1997_09_09:1.7.9.1.1.1
	MLWorks_10r3:1.7.9.1.3
	MLWorks_10r2_551:1.7.9.1.2
	MLWorks_11:1.7.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.9.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.7.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.9
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MM_ML_release_korma_1997_04_01:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.7.1.1
	MLWorks_gui_1996_12_18:1.7.8
	MLWorks_1_0_Win32_1996_12_17:1.7.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.4.1
	JFHrts:1.7.6
	MLWorks_1_0_Irix_1996_11_28:1.7.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.5
	MLWorks_1_0_Unix_1996_11_14:1.7.4
	MLWorks_Open_Beta2_1996_10_11:1.7.3
	MLWorks_License_dev:1.7.2
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.5
	MLWorks_Beta_1996_06_07:1.5
	MLWorks_Beta_1996_06_06:1.5
	MLWorks_Beta_1996_06_05:1.5
	MLWorks_Beta_1996_06_03:1.5
	MLWorks_Beta_1996_05_31:1.5
	MLWorks_Beta_1996_05_30:1.5;
locks; strict;
comment	@ * @;


1.9
date	98.04.14.12.48.00;	author mitchell;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	97.11.26.10.40.58;	author johnh;	state Exp;
branches;
next	1.7;

1.7
date	96.08.05.13.24.11;	author jont;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1
	1.7.6.1
	1.7.7.1
	1.7.8.1
	1.7.9.1
	1.7.10.1
	1.7.11.1
	1.7.12.1;
next	1.6;

1.6
date	96.07.30.15.58.03;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.05.01.08.53.05;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	96.02.14.16.06.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.01.11.17.25.48;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	95.11.29.16.02.41;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	95.09.26.15.17.59;	author jont;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.21.54;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.07.16.11.57;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.10.17.11.30.47;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.11.14.12.56.42;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	96.11.28.15.07.04;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	96.11.22.18.14.43;	author hope;	state Exp;
branches;
next	;

1.7.6.1
date	96.12.17.10.01.32;	author hope;	state Exp;
branches;
next	;

1.7.7.1
date	96.12.17.17.53.16;	author hope;	state Exp;
branches
	1.7.7.1.1.1;
next	;

1.7.7.1.1.1
date	97.02.24.11.44.11;	author hope;	state Exp;
branches;
next	;

1.7.8.1
date	96.12.18.09.47.49;	author hope;	state Exp;
branches;
next	;

1.7.9.1
date	97.05.12.10.40.13;	author hope;	state Exp;
branches
	1.7.9.1.1.1
	1.7.9.1.2.1
	1.7.9.1.3.1;
next	;

1.7.9.1.1.1
date	97.07.28.18.28.53;	author daveb;	state Exp;
branches
	1.7.9.1.1.1.1.1;
next	;

1.7.9.1.1.1.1.1
date	97.10.07.11.54.44;	author jkbrook;	state Exp;
branches;
next	;

1.7.9.1.2.1
date	97.09.08.17.21.51;	author daveb;	state Exp;
branches;
next	;

1.7.9.1.3.1
date	97.09.09.14.17.55;	author daveb;	state Exp;
branches;
next	;

1.7.10.1
date	97.09.10.19.37.09;	author brucem;	state Exp;
branches;
next	;

1.7.11.1
date	97.09.11.21.05.11;	author daveb;	state Exp;
branches;
next	;

1.7.12.1
date	97.10.31.13.48.14;	author nickb;	state Exp;
branches;
next	;

1.9.1.1
date	99.04.01.18.03.57;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.9
log
@[Bug #50061]
Reverse treatment of command-line argument passing for executables with embedded image
@
text
@/*  ==== EXECUTABLE FILE DELIVERY AND EXECUTION ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This code deals with delivery executables rather than heap images.
 *  There are two halves to this. Firstly, writing such an object,
 *  and secondly, rerunning it
 *
 *  $Log: src:OS:SunOS:arch:SPARC:exec_delivery.c,v $
 * Revision 1.8  1997/11/26  10:40:58  johnh
 * [Bug #30134]
 * Extra arg needed in save_executable (not used here though).
 *
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
 * Revision 1.6  1996/07/30  15:58:03  jont
 * Change permission on new executable saves to be owner read-write
 *
 * Revision 1.5  1996/05/01  08:53:05  nickb
 * Change to save_executable.
 *
 * Revision 1.4  1996/02/14  16:06:36  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.3  1996/01/11  17:25:48  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.2  1995/11/29  16:02:41  jont
 * Provide a real implementation of loading and saving executables
 * by saving the heap on the end
 *
 * Revision 1.1  1995/09/26  15:17:59  jont
 * new unit
 *
 */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <a.out.h>
#include <unistd.h>

#include "ansi.h"
#include "gc.h"
#include "utils.h"
#include "exec_delivery.h"
#include "diagnostic.h"
#include "image.h"
#include "main.h"
/* No contents yet */

static long round_up_to_8k(long size)
{
  return (size + 0x1fff) & 0xffffe000;
}

mlval save_executable(char *to, mlval heap, int console_app)
/* Save a re-executable version of the current system */
/* returns MLUNIT if ok, MLERROR on error of some sort (with errno set) */
{
  FILE *in_file, *out_file;
  struct exec exec;
  long stroff, size_of_file, heap_start, string_table_size;
  void *exec_part;

/* First find the right point in the executable, */
/* which may already have a heap in it */
  in_file = fopen(runtime, "rb");
  if (in_file == NULL) {
    DIAGNOSTIC(2, "Failed to open %s for reading", runtime, 0);
    errno = EIMAGEOPEN;
    return MLERROR;
  }
  if (fread(&exec, sizeof(struct exec), 1, in_file) != 1) {
    DIAGNOSTIC(2, "Failed to read exec header from %s", runtime, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return MLERROR;
  }

  if (exec.a_magic != ZMAGIC) {
    DIAGNOSTIC(2, "Not an MLWorks executable: bad magic number 0x%04x",
	       exec.a_magic, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return MLERROR;
  }
  else if (exec.a_machtype != M_SPARC) {
    DIAGNOSTIC(2, "Not an MLWorks executable: bad machine type 0x%02x",
	       exec.a_machtype, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return MLERROR;
  }

  stroff = N_STROFF(exec);
  /* Now determine file size */
  if (fseek(in_file, 0, SEEK_END)) {
    DIAGNOSTIC(2, "Failed to seek to end of file %s", runtime, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return MLERROR;
  }
  size_of_file = ftell(in_file);

  if (exec.a_syms == 0) { /* stripped executable */
    heap_start = stroff;
  } else {
    if (fseek(in_file, stroff, SEEK_SET)) {
      DIAGNOSTIC(2, "Failed to seek to start of string table (%d) in file %s",
		 stroff, runtime);
      fclose(in_file);
      errno = EIMAGEREAD;
      return MLERROR;
    }
    if (fread(&string_table_size, sizeof(string_table_size), 1, in_file) != 1) {
      DIAGNOSTIC(2, "Failed to read string table size from %s", runtime, 0);
      fclose(in_file);
      errno = EIMAGEREAD;
      return MLERROR;
    }
    heap_start = round_up_to_8k(stroff+string_table_size);
  }
  /* Now copy entire file up to heap_start */
  if (fseek(in_file, 0, SEEK_SET)) {
    DIAGNOSTIC(2, "Failed to seek to start of heap (%d) in file %s",
	       heap_start, runtime);
    fclose(in_file);
    errno = EIMAGEREAD;
    return MLERROR;
  }
  exec_part = malloc((unsigned long)heap_start);
  if (exec_part == NULL) {
    DIAGNOSTIC(2, "Failed to allocate memory (%d bytes) for executable part of file %s",
	       heap_start, runtime);
    fclose(in_file);
    errno = EIMAGEALLOC;
    return MLERROR;
  }
  if (fread(exec_part, 1, (unsigned long)heap_start, in_file) !=
      heap_start) {
    DIAGNOSTIC(2, "Failed to read executable part of file %s",
	       runtime, 0);
    fclose(in_file);
    free(exec_part);
    errno = EIMAGEREAD;
    return MLERROR;
  }
  out_file = fopen(to, "wb");
  if (out_file == NULL) {
    DIAGNOSTIC(2, "Failed to open %s for saving executable",
	       to, 0);
    fclose(in_file);
    free(exec_part);
    errno = EIMAGEOPEN;
    return MLERROR;
  }
  fclose(in_file); /* Don't need this any more */
  /* Now write the executable part */
  if (fwrite(exec_part, 1, (unsigned long)heap_start, out_file) !=
      heap_start) {
    DIAGNOSTIC(2, "Failed to write executable part to file %s",
	       to, 0);
    fclose(out_file);
    free(exec_part);
    errno = EIMAGEWRITE;
    return MLERROR;
  }
  free(exec_part);
  /* Now save the new heap */
  if (image_save_with_open_file(out_file, heap, to)) {
    fclose(out_file);
    message_start();
    message_string("image save to '");
    message_string(to);
    message_string("' failed, '");
    message_string(to);
    message_string("' removed");
    message_end();
    if (remove(to) != 0) {
      message_stderr("remove failed on '%s'", to);
    }
    return MLERROR;
  };
  /* Now pad up to an 8k boundary */
  {
    long size = ftell(out_file);
    long round_size = round_up_to_8k(size);
    while (size < round_size) {
      char a = '\000';
      if (fwrite(&a, 1, 1, out_file) != 1) {
	DIAGNOSTIC(2, "Failed to pad heap out to 8k boundary", 0, 0);
	fclose(out_file);
	errno = EIMAGEWRITE;
	return MLERROR;
      }
      size++;
    }
  }
  fclose(out_file);
  /* Now make sure it's executable */
  (void)chmod(to, 0750);
  /* Now return success */
  return MLUNIT;
}

int load_heap_from_executable(mlval *heap, const char *runtime, int just_check)
/* Reload the heap from within the executable, or just check if there is one */
/* This returns 0 if done (in which case we shouldn't try to load another heap) */
/* 1 if we failed to find a heap (in which case we continue as before) */
/* otherwise an error has occurred and errno is set */
{
  FILE *in_file;
  struct exec exec;
  long stroff, size_of_file, heap_start, string_table_size;
  
  in_file = fopen(runtime, "rb");
  if (in_file == NULL) {
    DIAGNOSTIC(2, "Failed to open %s for reading heap", runtime, 0);
    errno = EIMAGEOPEN;
    return 2;
  }
  if (fread(&exec, sizeof(struct exec), 1, in_file) != 1) {
    DIAGNOSTIC(2, "Failed to read exec header from %s", runtime, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return 2;
  }

  if (exec.a_magic != ZMAGIC) {
    DIAGNOSTIC(2, "Not an MLWorks executable: bad magic number 0x%04x",
	       exec.a_magic, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return 2;
  }
  else if (exec.a_machtype != M_SPARC) {
    DIAGNOSTIC(2, "Not an MLWorks executable: bad machine type 0x%02x",
	       exec.a_machtype, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return 2;
  }

  stroff = N_STROFF(exec);
  /* Now determine file size */
  if (fseek(in_file, 0, SEEK_END)) {
    DIAGNOSTIC(2, "Failed to seek to end of file %s", runtime, 0);
    fclose(in_file);
    errno = EIMAGEREAD;
    return 2;
  }
  size_of_file = ftell(in_file);

  if (exec.a_syms == 0) { /* stripped executable */
    if (stroff == size_of_file)	/* no heap */
      return 1;
    else heap_start = stroff;
  } else {
    if (fseek(in_file, stroff, SEEK_SET)) {
      DIAGNOSTIC(2, "Failed to seek to start of string table (%d) in file %s",
		 stroff, runtime);
      fclose(in_file);
      errno = EIMAGEREAD;
      return 2;
    }
    if (fread(&string_table_size, sizeof(string_table_size), 1, in_file) != 1) {
      DIAGNOSTIC(2, "Failed to read string table size from %s", runtime, 0);
      fclose(in_file);
      errno = EIMAGEREAD;
      return 2;
    }
    heap_start = round_up_to_8k(stroff+string_table_size);
    DIAGNOSTIC(4, "string table offset = %d, string table size = %d",
	       stroff, string_table_size);
    DIAGNOSTIC(4, "rounded size = %d, size of file = %d",
	       heap_start, size_of_file);
    /* Now see if this is the end of the file */
    if (heap_start == size_of_file)
      return 1;
  }
  if (fseek(in_file, heap_start, SEEK_SET)) {
    DIAGNOSTIC(2, "Failed to seek to start of heap (%d) in file %s",
	       heap_start, runtime);
    fclose(in_file);
    errno = EIMAGEREAD;
    return 2;
  }

  if (just_check) {
    fclose(in_file);
  } else {    
    *heap = image_load_with_open_file(in_file, runtime);
    fclose(in_file);
    if (*heap == MLERROR) {
      /* Something went wrong */
      DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
      return 2;
    }
  }
  return 0;
}
@


1.9.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.9  1998/04/14  12:48:00  mitchell
 * [Bug #50061]
 * Reverse treatment of command-line argument passing for executables with embedded image
 *
@


1.8
log
@[Bug #30134]
Extra arg needed in save_executable (not used here though).
@
text
@d12 4
d211 2
a212 2
int load_heap_from_executable(mlval *heap, const char *runtime)
/* Reload the heap from within the executable */
d293 11
a303 6
  *heap = image_load_with_open_file(in_file, runtime);
  fclose(in_file);
  if (*heap == MLERROR) {
    /* Something went wrong */
    DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
    return 2;
@


1.7
log
@[Bug #1528]
Fixing problems when open fails delivering executables
@
text
@d12 4
d57 1
a57 1
mlval save_executable(char *to, mlval heap)
@


1.7.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.9.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.7.9.1  1997/05/12  10:40:13  hope
 * branched from 1.7
 *
@


1.7.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.7.9.1  1997/05/12  10:40:13  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.7.9.1  1997/05/12  10:40:13  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.7.9.1.1.1  1997/07/28  18:28:53  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.8.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.7.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.7.1.1.1
log
@branched from 1.7.7.1
@
text
@a11 3
 * Revision 1.7.7.1  1996/12/17  17:53:16  hope
 * branched from 1.7
 *
@


1.7.6.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.5.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a11 3
 * Revision 1.7.4.1  1996/11/14  12:56:42  hope
 * branched from 1.7
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a11 4
 * Revision 1.7  1996/08/05  13:24:11  jont
 * [Bug #1528]
 * Fixing problems when open fails delivering executables
 *
@


1.6
log
@Change permission on new executable saves to be owner read-write
@
text
@d12 3
d151 1
a151 1
    errno = EIMAGEREAD;
d162 1
a162 1
    errno = EIMAGEREAD;
d190 1
a190 1
	errno = EIMAGEREAD;
@


1.5
log
@Change to save_executable.
@
text
@d12 3
d195 1
a195 1
  (void)chmod(to, 0550);
@


1.4
log
@Changing ERROR to MLERROR
@
text
@d12 3
d47 1
a47 1
mlval save_executable(mlval argument)
a53 2
  char *to = CSTRING(FIELD(argument, 0));
  mlval heap = FIELD(argument, 1);
d62 1
a62 1
    return 2;
d68 1
a68 1
    return 2;
d76 1
a76 1
    return 2;
d83 1
a83 1
    return 2;
d92 1
a92 1
    return 2;
d104 1
a104 1
      return 2;
d110 1
a110 1
      return 2;
d120 1
a120 1
    return 2;
d128 1
a128 1
    return 2;
d137 1
a137 1
    return 2;
d146 1
a146 1
    return 2;
d157 1
a157 1
    return 2;
d185 1
a185 1
	return 2;
@


1.3
log
@Runtime error message buffer problem.
@
text
@d12 3
d46 1
a46 1
/* returns MLUNIT if ok, ERROR on error of some sort (with errno set) */
d172 1
a172 1
    return ERROR;
d280 1
a280 1
  if (*heap == ERROR) {
@


1.2
log
@Provide a real implementation of loading and saving executables
by saving the heap on the end
@
text
@d12 4
d159 7
a165 1
    message("image save to '%s' failed, '%s' removed", to, to);
@


1.1
log
@new unit
@
text
@d11 4
a14 1
 *  $Log$
d18 4
d23 1
d27 3
d32 5
d41 232
a272 2
  errno = EIMPL;
  return ERROR;
@
