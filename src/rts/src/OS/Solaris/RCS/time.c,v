head	1.20;
access;
symbols
	MLW_daveb_inline_1_4_99:1.20.1
	MLWorks_21c0_1999_03_25:1.20
	MLWorks_20c1_1998_08_20:1.20
	MLWorks_20c0_1998_08_04:1.20
	MLWorks_20b2c2_1998_06_19:1.20
	MLWorks_20b2_Windows_1998_06_12:1.20
	MLWorks_20b1c1_1998_05_07:1.20
	MLWorks_20b0_1998_04_07:1.20
	MLWorks_20b0_1998_03_20:1.20
	MLWorks_20m2_1998_02_16:1.20
	MLWorks_MM_adapt:1.18.3
	MLWorks_20m1_1997_10_23:1.18
	MLWorks_11r1:1.17.1.1.1.1.1
	MLWorks_workspace_97:1.18.2
	MLWorks_dt_wizard:1.18.1
	MLWorks_11c0_1997_09_09:1.17.1.1.1.1
	MLWorks_10r3:1.17.1.1.3
	MLWorks_10r2_551:1.17.1.1.2
	MLWorks_11:1.17.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.1.1
	MLWorks_20m0_1997_06_20:1.18
	MLWorks_1_0_r2c2_1997_06_14:1.17.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.1
	MLWorks_BugFix_1997_04_24:1.18
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MM_ML_release_korma_1997_04_01:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.16.6.1.1
	MLWorks_gui_1996_12_18:1.16.7
	MLWorks_1_0_Win32_1996_12_17:1.16.6
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.16.3.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.16.3.1
	JFHrts:1.16.5
	MLWorks_1_0_Irix_1996_11_28:1.16.3.1.1
	MLWorks_1_0_Win32_1996_11_22:1.16.4
	MLWorks_1_0_Unix_1996_11_14:1.16.3
	MLWorks_Open_Beta2_1996_10_11:1.16.2
	MLWorks_License_dev:1.16.1
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.20
date	97.11.17.19.07.00;	author jont;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	97.11.07.17.07.22;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	97.04.10.12.55.01;	author jont;	state Exp;
branches
	1.18.1.1
	1.18.2.1
	1.18.3.1;
next	1.17;

1.17
date	96.12.19.09.48.03;	author stephenb;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	96.09.20.11.29.28;	author io;	state Exp;
branches
	1.16.1.1
	1.16.2.1
	1.16.3.1
	1.16.4.1
	1.16.5.1
	1.16.6.1
	1.16.7.1;
next	1.15;

1.15
date	96.04.19.14.55.40;	author matthew;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	96.03.01.11.51.49;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.02.14.17.29.45;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	96.02.14.15.11.44;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.01.30.17.41.15;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.07.17.11.27.12;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.05.10.15.58.45;	author daveb;	state Exp;
branches;
next	1.8;

1.8
date	95.05.02.16.40.52;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.04.13.11.18.26;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	95.02.23.13.56.12;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.12.12.11.03.56;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.11.09.12.40.38;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.20.10.43.32;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.07.22.14.15.36;	author nickh;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.07.08.10.45.13;	author nickh;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.28.41;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.22.24;	author hope;	state Exp;
branches;
next	1.15.1.2;

1.15.1.2
date	96.09.20.17.12.20;	author io;	state Exp;
branches;
next	;

1.16.1.1
date	96.10.07.16.12.30;	author hope;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.17.11.31.30;	author hope;	state Exp;
branches;
next	;

1.16.3.1
date	96.11.14.12.57.27;	author hope;	state Exp;
branches
	1.16.3.1.1.1;
next	;

1.16.3.1.1.1
date	96.11.28.15.07.35;	author hope;	state Exp;
branches;
next	;

1.16.4.1
date	96.11.22.18.15.16;	author hope;	state Exp;
branches;
next	;

1.16.5.1
date	96.12.17.10.02.02;	author hope;	state Exp;
branches;
next	;

1.16.6.1
date	96.12.17.17.53.46;	author hope;	state Exp;
branches
	1.16.6.1.1.1;
next	;

1.16.6.1.1.1
date	97.02.24.11.44.46;	author hope;	state Exp;
branches;
next	;

1.16.7.1
date	96.12.18.09.48.21;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	97.05.12.10.40.44;	author hope;	state Exp;
branches
	1.17.1.1.1.1
	1.17.1.1.2.1
	1.17.1.1.3.1;
next	;

1.17.1.1.1.1
date	97.07.28.18.25.30;	author daveb;	state Exp;
branches
	1.17.1.1.1.1.1.1;
next	;

1.17.1.1.1.1.1.1
date	97.10.07.11.51.19;	author jkbrook;	state Exp;
branches;
next	;

1.17.1.1.2.1
date	97.09.08.17.18.43;	author daveb;	state Exp;
branches;
next	;

1.17.1.1.3.1
date	97.09.09.14.14.52;	author daveb;	state Exp;
branches;
next	;

1.18.1.1
date	97.09.10.19.31.36;	author brucem;	state Exp;
branches;
next	;

1.18.2.1
date	97.09.11.21.01.00;	author daveb;	state Exp;
branches;
next	;

1.18.3.1
date	97.10.31.13.44.02;	author nickb;	state Exp;
branches;
next	;

1.20.1.1
date	99.04.01.18.00.56;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.20
log
@[Bug #30089]
Remove functions only used by old MLWorks.Time structure (now removed)
@
text
@/*  ==== PERVASIVE TIME ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 * Clock time and intervals are timestruc pairs of integers (second,
 * nanosecond), obtained from PIOCUSAGE. File modification times
 * obtained from stat(2) get zero nanoseconds (this appears unsafe,
 * but actually is safe because stat(2) times could be on a different
 * machine in any case, so must only ever be compared with each other,
 * and not with now()).
 *
 * Times and intervals are represented to ML as quadruples of ints, a
 * pair for the seconds (each MLint taking 24 bits, allowing for
 * 48-bit values) and a pair for the nanoseconds.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Solaris:time.c,v $
 * Revision 1.19  1997/11/07  17:07:22  jont
 * [Bug #30089]
 * Remove time_file_modified and time_set_file_modified
 *
 * Revision 1.18  1997/04/10  12:55:01  jont
 * [Bug #2036]
 * Cache value of tick to avoid system calls in time conversions
 *
 * Revision 1.17  1996/12/19  09:48:03  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
 * Revision 1.15  1996/04/19  14:55:40  matthew
 * Changes to Exception raising
 *
 * Revision 1.14  1996/03/01  11:51:49  jont
 * Fix implementation of tm_to_time
 *
 * Revision 1.13  1996/02/14  17:29:45  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.12  1996/02/14  15:11:44  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.11  1996/01/30  17:41:15  jont
 * Fix bug 907 (MLWorks.Time.now gives wrong answer)
 *
 * Revision 1.10  1995/07/17  11:27:12  nickb
 * Add ml_time_microseconds()
 *
 * Revision 1.9  1995/05/10  15:58:45  daveb
 * Added ml_time_t.
 *
 * Revision 1.8  1995/05/02  16:40:52  jont
 * Improve error message from set_time_modified
 *
 * Revision 1.7  1995/04/13  11:18:26  jont
 * Add interface to gmtime, localtime, mktime
 *
 * Revision 1.6  1995/02/23  13:56:12  nickb
 * Remove BSDisms.
 *
 * Revision 1.5  1994/12/12  11:03:56  jont
 * Change time.h to mltime.h
 *
 * Revision 1.4  1994/11/09  12:40:38  jont
 * Fix overflowing integer computation in get_current_time
 *
 * Revision 1.3  1994/10/20  10:43:32  nickb
 * Correct some types for gcc 2.5.8
 *
 * Revision 1.2  1994/07/22  14:15:36  nickh
 * user_clock is off by a factor of 1000. Should use times() instead.
 *
 * Revision 1.1  1994/07/08  10:45:13  nickh
 * new file
 * */

#include <sys/times.h>

#include <sys/param.h>

#include "mltime.h" 

typedef unsigned long long int nanoseconds;

static nanoseconds CACHE_TICK;

extern double user_clock(void)
{
  struct tms timebuf;

  (void) times(&timebuf);

  return ((((double)timebuf.tms_utime) * CACHE_TICK) / 1000.0);
}

extern void time_init(void)
{
  CACHE_TICK=TICK;
}
@


1.20.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 4
 * Revision 1.20  1997/11/17  19:07:00  jont
 * [Bug #30089]
 * Remove functions only used by old MLWorks.Time structure (now removed)
 *
@


1.19
log
@[Bug #30089]
Remove time_file_modified and time_set_file_modified
@
text
@d21 4
a83 5
#include <time.h>
#include <errno.h>
#include <limits.h>
#include <utime.h>
#include <sys/time.h>
a84 2
#include <sys/stat.h>
#include <sys/utime.h>
a87 2
#include "ansi.h" 
#include "syscalls.h" 
a88 74
#include "utils.h" 
#include "allocator.h" 
#include "alloc.h"
#include "mltypes.h" 
#include "values.h" 
#include "environment.h" 
#include "exceptions.h"
#include "diagnostic.h" 
#include "marshal.h" 
#include "gc.h"


/* Converting C time values to an ML value */

#define SPLIT0(t)	((unsigned long)((t).tv_sec) & 0xFFFFFF)
#define SPLIT1(t)	(((unsigned long)((t).tv_sec) >> 24))
#define SPLIT2(t)	((unsigned long)((t).tv_nsec) & 0xFFFFFF)
#define SPLIT3(t)	(((unsigned long)((t).tv_nsec) >> 24))

#define MLTIME(r,t)                  \
  do {                               \
    FIELD((r),0) = MLINT(SPLIT0(t)); \
    FIELD((r),1) = MLINT(SPLIT1(t)); \
    FIELD((r),2) = MLINT(SPLIT2(t)); \
    FIELD((r),3) = MLINT(SPLIT3(t)); \
  } while (0)

/* Converting an ML value to a C time value */

#define JOIN0(t0)	((unsigned long) (t0))
#define JOIN1(t1)	(((unsigned long) (t1)) << 24)

#define JOIN(t0,t1)	(JOIN0(t0) | JOIN1(t1))

#define JOINSEC(r) (JOIN(CINT(FIELD((r),0)), \
			 CINT(FIELD((r),1))))

#define JOINNSEC(r)	 (JOIN(CINT(FIELD((r),2)), \
			       CINT(FIELD((r),3))))

/* CTIME should be used with care */

#define CTIME(r,t)             \
  do {                         \
    (t).tv_sec = JOINSEC(r);   \
    (t).tv_nsec = JOINNSEC(r); \
  } while (0)


inline mlval ml_time(struct timestruc *t)
{
  mlval result = allocate_record(4);

  MLTIME (result,*t);
  return(result);
}

extern mlval ml_time_microseconds(double t)
{
  struct timestruc ts;
  ts.tv_sec =  t / 1000000;
  ts.tv_nsec = (t - ((double)ts.tv_sec * 1000000.0))*1000.0;
  return (ml_time(&ts));
}

inline mlval ml_time_t (time_t t)
{
  struct timestruc ts;

  ts.tv_sec = t;
  ts.tv_nsec = 0;		/* safe hack; see comment at head of file */

  return(ml_time(&ts));
}
a93 457
/* We have to perform the following unpleasantness because the Solaris
include files are badly written, and there is no way of including them
which avoids a specific problem. To be specific, when compiling with
__STDC__ set, gethrtime() is prototyped to return a union value
(whereas actually it returns a long long), so calls to it use a
different calling convention. So in order to call gethrtime() with a
more normal convention, we have to cast it. */

static nanoseconds (*get_nano_time)(void) = (nanoseconds(*)(void)) gethrtime;

static inline void nanoseconds_to_timestruc (nanoseconds nsecs,
					     struct timestruc *t)
{
  t->tv_sec = nsecs / 1000000000;
  t->tv_nsec = nsecs % 1000000000;
}

static inline mlval ml_time_nanoseconds(nanoseconds nsecs)
{
  struct timestruc t;

  nanoseconds_to_timestruc(nsecs,&t);
  return ml_time(&t);
}

static mlval time_now(mlval unit)
{
  struct timeval t;
  struct timestruc ts;

  if(gettimeofday(&t, NULL))
    error("Unable to read time of day.  "
	  "gettimeofday() set errno to %d.", errno);

  ts.tv_sec =  t.tv_sec;
  ts.tv_nsec = t.tv_usec * 1000;
  return (ml_time(&ts));
}

static mlval time_format(mlval argument)
{
  mlval time_record = FIELD(argument, 2);
  char *format = CSTRING(FIELD(argument, 0));
  time_t t = JOINSEC(time_record);
  struct tm *timeptr = CINT(FIELD(argument, 1)) ? localtime(&t) : gmtime(&t);
  size_t size;
  mlval result = MLUNIT;

  if(strlen(format) == 0)
    return(ml_string(""));
  
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, timeptr);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
    }

    free(buffer);
  }

  return(result);
}

static mlval tm_to_time(mlval argument)
{
  /* Interface to mktime. Returns a time_t suitably split up for ml */
  mlval result = MLUNIT;
  struct tm time_val;
  time_t t;
  time_val.tm_sec = CINT(FIELD(argument, 0));
  time_val.tm_min = CINT(FIELD(argument, 1));
  time_val.tm_hour = CINT(FIELD(argument, 2));
  time_val.tm_mday = CINT(FIELD(argument, 3));
  time_val.tm_mon = CINT(FIELD(argument, 4));
  time_val.tm_year = CINT(FIELD(argument, 5));
  time_val.tm_wday = CINT(FIELD(argument, 6));
  time_val.tm_yday = CINT(FIELD(argument, 7));
  time_val.tm_isdst = CINT(FIELD(argument, 8));
  if ((t = mktime(&time_val)) == (time_t)-1) {
    exn_raise_string(perv_exn_ref_io, "tm_to_time:invalid tm");
  } else {
    struct timestruc time;
    time.tv_sec = t;
    time.tv_nsec = 0;
    result = allocate_record(4);
    MLTIME (result,time);
  }
  return result;
}

static mlval gmtime_to_tm(mlval argument)
{
  /* interface to gmtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINSEC(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = gmtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "gmtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

static mlval localtime_to_tm(mlval argument)
{
  /* interface to localtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINSEC(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = localtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "localtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

/* Are two ML time values equal? Use this to abstract the ML time type
 * from the loader */

extern int ml_time_eq(mlval t1, mlval t2)
{
  mlval *time1 = CPTR(t1);
  mlval *time2 = CPTR(t2);

  if (memcmp(time1, time2, 4*sizeof(mlval)))
    return 0;
  else return 1;
}

/* get the modified timestamp of a file as an ML value; use this in
 * the loader and also provide it to the ML environment */

inline mlval ml_stat(const char *filename)
{
  struct stat stbuf;
  
  DIAGNOSTIC(2, "stat(\"%s\")", filename, 0);
  
  if (stat (filename, &stbuf) == -1)
    return MLERROR;

  DIAGNOSTIC(2, "  mtime = %lu", stbuf.st_mtime, 0);


  return(ml_time_t(stbuf.st_mtime));
}
  
static mlval time_less(mlval arg)
{
  struct timestruc t1, t2;
  mlval time_record1 = FIELD(arg, 0);
  mlval time_record2 = FIELD(arg, 1);

  CTIME(time_record1, t1);
  CTIME(time_record2, t2);

  return(((t1.tv_sec < t2.tv_sec) 
	  || ((t1.tv_sec == t2.tv_sec) && (t1.tv_nsec < t2.tv_nsec))) 
	 ? MLTRUE : MLFALSE);
}

mlval time_encode(mlval arg)
{
  char buffer[2*MARSHAL_SIZE_LONG], *end;
  struct timestruc t;
  size_t length;
  mlval result;

  CTIME(arg,t);

  end = marshal(buffer, "ll", t.tv_sec,t.tv_nsec);

  length = end - buffer;

  result = allocate_string(length+1);
  memcpy(CSTRING(result), buffer, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

mlval time_decode(mlval arg)
{
  struct timestruc t;

  unmarshal(CSTRING(arg), "ll", &t.tv_sec,&t.tv_nsec);

  return(ml_time(&t));
}

static inline void norm_timestruc (struct timestruc *t)
{
  long secs = t->tv_nsec / 1000000000;
  long rem = t->tv_nsec % 1000000000;

  if (rem < 0) {		/* hack to get around C nastiness */
    secs--;
    rem+= 1000000000;
  }

  t->tv_nsec = rem;
  t->tv_sec += secs;
}

static void timestruc_sub (struct timestruc *t1,
			   struct timestruc *t2,
			   struct timestruc *result)
{
  result->tv_sec  = t1->tv_sec  - t2->tv_sec;
  result->tv_nsec = t1->tv_nsec - t2->tv_nsec;
  norm_timestruc(result);
}

static void timestruc_add (struct timestruc *t1,
			 struct timestruc *t2,
			 struct timestruc *result)
{
  result->tv_sec  = t1->tv_sec  + t2->tv_sec;
  result->tv_nsec = t1->tv_nsec + t2->tv_nsec;
  norm_timestruc(result);
}

static mlval interval_to_real (mlval arg)
{
  mlval result;
  struct timestruc t;
  double tm;

  CTIME (arg,t);

  result = allocate_real();

  tm = t.tv_sec + (t.tv_nsec / 1000000000.0);

  (void) SETREAL(result,tm);
  return result;
}

static mlval interval_from_real (mlval arg)
{
  struct timestruc t;
  double tm = GETREAL(arg);

  if (tm > LONG_MAX || tm < LONG_MIN) {
    exn_raise (perv_exn_ref_overflow);
  }

  t.tv_sec = tm;
  t.tv_nsec = 1000000000.0*(tm-t.tv_sec);
  norm_timestruc(&t);

  return (ml_time (&t));
}

static struct timestruc start_time;

static struct time_record {struct timestruc t_user;
			   struct timestruc t_sys;
			   struct timestruc t_gc;
			   struct timestruc t_real;
			 } current_time;

static inline void get_current_time (void)
{
  struct tms timebuf;
  struct timestruc t;

  current_time.t_gc.tv_sec = gc_clock / 1000000;
  current_time.t_gc.tv_nsec =
    (gc_clock - ((double)current_time.t_gc.tv_sec * 1000000.0)) * 1000.0;

  (void) times(&timebuf);

  nanoseconds_to_timestruc(((nanoseconds)timebuf.tms_utime) * CACHE_TICK, &t);

  timestruc_sub(&t, &current_time.t_gc, &current_time.t_user);

  nanoseconds_to_timestruc(((nanoseconds)timebuf.tms_stime) * CACHE_TICK,
			   &current_time.t_sys);

  nanoseconds_to_timestruc(get_nano_time(),&t);
  timestruc_sub(&t, &start_time, &current_time.t_real);
}  

static inline mlval return_current_time (void)
{
  mlval result;
  mlval t_gc,t_real,t_sys,t_user;

  t_gc = ml_time(&current_time.t_gc);
  declare_root(&t_gc);
  t_real = ml_time(&current_time.t_real);
  declare_root(&t_real);
  t_user = ml_time(&current_time.t_user);
  declare_root(&t_user);
  t_sys = ml_time(&current_time.t_sys);   
  declare_root(&t_sys);

  result = allocate_record(4);

  /* field ordering alphabetic: gc, real, sys, user */

  FIELD(result,0) = t_gc;
  FIELD(result,1) = t_real;
  FIELD(result,2) = t_sys;
  FIELD(result,3) = t_user;

  retract_root(&t_gc);
  retract_root(&t_user);
  retract_root(&t_sys);
  retract_root(&t_real);

  return(result);
}

static mlval elapsed (mlval unit)
{
  get_current_time ();
  return (return_current_time());
}

static mlval elapsed_since (mlval arg)
{
  struct timestruc t1;

  get_current_time();

  CTIME(FIELD(arg,0),t1);
  timestruc_sub(&current_time.t_gc, &t1, &current_time.t_gc);
  CTIME(FIELD(arg,1),t1);
  timestruc_sub(&current_time.t_real, &t1, &current_time.t_real);
  CTIME(FIELD(arg,2),t1);
  timestruc_sub(&current_time.t_sys, &t1, &current_time.t_sys);
  CTIME(FIELD(arg,3),t1);
  timestruc_sub(&current_time.t_user, &t1, &current_time.t_user);

  return(return_current_time());
}

static mlval interval (mlval arg)
{
  struct timestruc t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timestruc_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}


static mlval time_subtract (mlval arg)
{
  struct timestruc t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timestruc_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_add (mlval arg)
{
  struct timestruc t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timestruc_add (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_to_string (mlval arg)
{
  struct timestruc t;
  int digits = CINT(FIELD(arg,1));
  long int whole,frac,i;
  char buffer[50];
  char *p = buffer;

  CTIME(FIELD(arg,0),t);

  whole = t.tv_sec;
  frac = t.tv_nsec;

  /* give a maximum of 9 digits */

  if (digits > 9 || digits < 0)
    digits = 9;

  /* negatives need to be normalized, as nanosecond parts are always +ve */

  if (whole < 0) {
    *p++ = '~';
    whole = -whole;
    if (frac != 0) {
      whole--;
      frac = 1000000000-frac;
    }
  }
  
  /* round for whole numbers, and return without a decimal point */
  
  if (digits == 0) {
    if (frac >= 500000000) {
      whole++;
    }
    sprintf(p,"%li",whole);
    
  } else {
    
    /* round for others */

    if (digits != 9) {
      for (i=8; i != digits; i--)
	frac /= 10;
      if  (frac % 10 >= 5)
	frac += 10;
      frac /= 10;
    }
    /* print with a point, left padded with zeroes */
    sprintf(p,"%li.%0*li",whole,digits,frac);
  }

  return (ml_string(buffer));
}

/*  user_clock() is like clock(3) except that it returns only the user
 *  virtual time elapsed (in microseconds).
 */

d103 1
a103 1
void time_init()
d105 1
a105 34
  mlval zero;

  zero = allocate_record(4);
  FIELD(zero, 0) = MLINT(0);
  FIELD(zero, 1) = MLINT(0);
  FIELD(zero, 2) = MLINT(0);
  FIELD(zero, 3) = MLINT(0);

  /* get clock start time for elapsed record */

  nanoseconds_to_timestruc(get_nano_time(),&start_time);

  env_value("time zero", zero);
  env_function("time now", time_now);
  env_function("time less", time_less);
  env_function("time add", time_add);
  env_function("time subtract", time_subtract);

  env_function("time encode", time_encode);
  env_function("time decode", time_decode);

  env_function("time to string",time_to_string);
  env_function("time format", time_format);
  env_function("time mktime", tm_to_time);
  env_function("time gmtime", gmtime_to_tm);
  env_function("time localtime", localtime_to_tm);

  env_function("time interval",interval);
  env_function("interval to real",interval_to_real);
  env_function("interval from real",interval_from_real);

  env_function("time elapsed",elapsed);
  env_function("time elapsed since",elapsed_since);
  CACHE_TICK = TICK;
@


1.18
log
@[Bug #2036]
Cache value of tick to avoid system calls in time conversions
@
text
@d21 4
a344 33
static mlval time_file_modified(mlval arg)
{
  mlval result = ml_stat (CSTRING(arg));

  if (result == MLERROR)
    exn_raise_format(perv_exn_ref_io,
		     "Cannot mtime %s: does not exist",
		     CSTRING(arg));
  return result;
}

static mlval time_set_file_modified(mlval arg)
{
  struct utimbuf utbuf[1], *utp = NULL;
  char* path = CSTRING(FIELD(arg, 0));

  /*  datatype modtime = NOW | TIME of Time.time  */
  if (MLVALISPTR(FIELD(arg, 1))) {
    mlval time_record = FIELD(FIELD(arg, 0), 1);
    utbuf[0].actime = 0L;
    utbuf[0].modtime = JOINSEC(time_record);
    utp = utbuf;
  }

  DIAGNOSTIC(2, "real_set_file_modified(\"%s\"), modtime = %lu",
	     path, utp ? utbuf[0].modtime : 0L);

  if(utime(path, utp) == -1)
    exn_raise_format(perv_exn_ref_io, "Cannot set time of %s", path);

  return MLUNIT;
}

a666 3

  env_function("time file modified", time_file_modified);
  env_function("time set file modified", time_set_file_modified);
@


1.18.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a20 4
 * Revision 1.18  1997/04/10  12:55:01  jont
 * [Bug #2036]
 * Cache value of tick to avoid system calls in time conversions
 *
@


1.18.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 * Revision 1.18  1997/04/10  12:55:01  jont
 * [Bug #2036]
 * Cache value of tick to avoid system calls in time conversions
 *
@


1.18.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 4
 * Revision 1.18  1997/04/10  12:55:01  jont
 * [Bug #2036]
 * Cache value of tick to avoid system calls in time conversions
 *
@


1.17
log
@[Bug #1791]
MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
to avoid any binding problems
@
text
@d21 5
d167 2
d500 1
a500 1
  nanoseconds_to_timestruc(((nanoseconds)timebuf.tms_utime) * TICK, &t);
d504 1
a504 1
  nanoseconds_to_timestruc(((nanoseconds)timebuf.tms_stime) * TICK,
d665 1
a665 1
  return ((((double)timebuf.tms_utime) * TICK) / 1000.0);
d706 1
@


1.17.1.1
log
@branched from 1.17
@
text
@a20 5
 * Revision 1.17  1996/12/19  09:48:03  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
@


1.17.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 3
 * Revision 1.17.1.1  1997/05/12  10:40:44  hope
 * branched from 1.17
 *
@


1.17.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 3
 * Revision 1.17.1.1  1997/05/12  10:40:44  hope
 * branched from 1.17
 *
@


1.17.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 3
 * Revision 1.17.1.1  1997/05/12  10:40:44  hope
 * branched from 1.17
 *
@


1.17.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 * Revision 1.17.1.1.1.1  1997/07/28  18:25:30  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.16
log
@[Bug #1607]
remove getrusage and modify gettimeofday prototype
@
text
@d21 4
d104 7
a110 4
#define MLTIME(r,t)	{FIELD((r),0) = MLINT(SPLIT0(t)); \
			 FIELD((r),1) = MLINT(SPLIT1(t)); \
			 FIELD((r),2) = MLINT(SPLIT2(t)); \
			 FIELD((r),3) = MLINT(SPLIT3(t));}
d127 5
a131 2
#define CTIME(r,t) {(t).tv_sec = JOINSEC(r); \
		      (t).tv_nsec = JOINNSEC(r);}
@


1.16.7.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.6.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.6.1.1.1
log
@branched from 1.16.6.1
@
text
@a20 3
 * Revision 1.16.6.1  1996/12/17  17:53:46  hope
 * branched from 1.16
 *
@


1.16.5.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.4.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.3.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.3.1.1.1
log
@branched from 1.16.3.1
@
text
@a20 3
 * Revision 1.16.3.1  1996/11/14  12:57:27  hope
 * branched from 1.16
 *
@


1.16.2.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/20  11:29:28  io
 * [Bug #1607]
 * remove getrusage and modify gettimeofday prototype
 *
@


1.15
log
@Changes to Exception raising
@
text
@d21 3
d75 1
a75 1
#include <sys/rusage.h>
@


1.15.1.1
log
@branched from 1.15
@
text
@a20 3
 * Revision 1.15  1996/04/19  14:55:40  matthew
 * Changes to Exception raising
 *
@


1.15.1.2
log
@[Bug #1607]
getrusage.h has dissappeared in Solaris 2.5 and gettimeofday needs to be changed
so the Solaris builds can run
@
text
@a20 3
 * Revision 1.15.1.1  1996/09/13  11:22:24  hope
 * branched from 1.15
 *
d75 1
a75 1

@


1.14
log
@Fix implementation of tm_to_time
@
text
@d21 3
d451 1
a451 1
    exn_raise (perv_exn_ref_floor);
@


1.13
log
@ISPTR becomes MLVALISPTR
@
text
@d21 3
d220 9
a228 9
  time_val.tm_sec = CINT(FIELD(result, 0));
  time_val.tm_min = CINT(FIELD(result, 1));
  time_val.tm_hour = CINT(FIELD(result, 2));
  time_val.tm_mday = CINT(FIELD(result, 3));
  time_val.tm_mon = CINT(FIELD(result, 4));
  time_val.tm_year = CINT(FIELD(result, 5));
  time_val.tm_wday = CINT(FIELD(result, 6));
  time_val.tm_yday = CINT(FIELD(result, 7));
  time_val.tm_isdst = CINT(FIELD(result, 8));
@


1.12
log
@Changing ERROR to MLERROR
@
text
@d21 3
d332 1
a332 1
  if (ISPTR(FIELD(arg, 1))) {
@


1.11
log
@Fix bug 907 (MLWorks.Time.now gives wrong answer)
@
text
@d21 3
d304 1
a304 1
    return ERROR;
d316 1
a316 1
  if (result == ERROR)
@


1.10
log
@Add ml_time_microseconds()
@
text
@d21 3
d164 10
a173 1
  return (ml_time_nanoseconds(get_nano_time()));
@


1.9
log
@Added ml_time_t.
@
text
@d21 3
d112 8
@


1.8
log
@Improve error message from set_time_modified
@
text
@d21 3
d111 10
a273 1
  struct timestruc ts;
a281 2
  ts.tv_sec = stbuf.st_mtime;
  ts.tv_nsec = 0;		/* safe hack; see comment at head of file */
d283 1
a283 1
  return(ml_time(&ts));
@


1.7
log
@Add interface to gmtime, localtime, mktime
@
text
@d21 3
d304 1
a304 1
    exn_raise_format(perv_exn_ref_io, "Cannot utime %s", path);
@


1.6
log
@Remove BSDisms.
@
text
@d21 3
d166 73
d625 3
@


1.5
log
@Change time.h to mltime.h
@
text
@d8 5
a12 5
 * nanosecond), obtained from getrusage(2) and gettimeofday(2). File
 * modification times obtained from stat(2) get zero nanoseconds
 * (this appears unsafe, but actually is safe because stat(2) times
 * could be on a different machine in any case, so must only ever be
 * compared with each other, and not with now()).
d21 3
d35 1
a35 2
 *
 */
a126 14
}

/* For the time being, a lot of things (e.g. timeofday) are
 * unavailable in nanosecond form, so we need to do conversions
 * to/from struct timeval */

static inline mlval ml_time_timeval(struct timeval *tv)
{
  struct timestruc t;

  t.tv_sec = tv->tv_sec;
  t.tv_nsec = tv->tv_usec * 1000;
 
  return ml_time (&t);
@


1.4
log
@Fix overflowing integer computation in get_current_time
@
text
@d21 3
d48 1
a48 1
#include "time.h" 
@


1.3
log
@Correct some types for gcc 2.5.8
@
text
@d21 3
d361 1
a361 1
    (gc_clock - (current_time.t_gc.tv_sec * 1000000)) * 1000.0;
@


1.2
log
@user_clock is off by a factor of 1000. Should use times() instead.
@
text
@d21 3
d466 1
a466 1
  int whole,frac,i;
@


1.2.1.1
log
@branched from 1.2
@
text
@a20 3
 * Revision 1.2  1994/07/22  14:15:36  nickh
 * user_clock is off by a factor of 1000. Should use times() instead.
 *
@


1.1
log
@new file
@
text
@d20 4
a23 1
 *  $Log: time.c,v $
d353 1
a353 1
  current_time.t_gc.tv_sec = gc_clock / 1000000000;
d355 1
a355 1
    gc_clock - (current_time.t_gc.tv_sec * 1000000000);
d515 1
a515 1
 *  virtual time elapsed.
d520 1
a520 1
  struct rusage rusage;
d522 1
a522 3
  if (getrusage(RUSAGE_SELF, &rusage))
    error ("Unable to read resource usage, "
	   "getrusage set errno to %d.",errno);
d524 1
a524 2
  return (((double) rusage.ru_utime.tv_nsec / 1000.0)
	  + (double) rusage.ru_utime.tv_sec * 1000000.0);
@
