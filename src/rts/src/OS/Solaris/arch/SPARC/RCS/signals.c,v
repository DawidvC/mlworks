head	1.41;
access;
symbols
	MLW_daveb_inline_1_4_99:1.41.5
	MLWorks_21c0_1999_03_25:1.41
	MLWorks_20c1_1998_08_20:1.41
	MLWorks_20c0_1998_08_04:1.41
	MLWorks_20b2c2_1998_06_19:1.41
	MLWorks_20b2_Windows_1998_06_12:1.41
	MLWorks_20b1c1_1998_05_07:1.41
	MLWorks_20b0_1998_04_07:1.41
	MLWorks_20b0_1998_03_20:1.41
	MLWorks_20m2_1998_02_16:1.41
	MLWorks_MM_adapt:1.41.4
	MLWorks_20m1_1997_10_23:1.41
	MLWorks_11r1:1.41.1.1.1.1.1
	MLWorks_workspace_97:1.41.3
	MLWorks_dt_wizard:1.41.2
	MLWorks_11c0_1997_09_09:1.41.1.1.1.1
	MLWorks_10r3:1.41.1.1.3
	MLWorks_10r2_551:1.41.1.1.2
	MLWorks_11:1.41.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.41.1.1
	MLWorks_20m0_1997_06_20:1.41
	MLWorks_1_0_r2c2_1997_06_14:1.41.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.41.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.41.1
	MLWorks_BugFix_1997_04_24:1.41
	MLWorks_1_0_r2_Win32_1997_04_11:1.41
	MLWorks_1_0_r2_Unix_1997_04_04:1.41
	MM_ML_release_korma_1997_04_01:1.41
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.40.4.1.1
	MLWorks_gui_1996_12_18:1.40.5
	MLWorks_1_0_Win32_1996_12_17:1.40.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.40.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.40.1.1
	JFHrts:1.40.3
	MLWorks_1_0_Irix_1996_11_28:1.40.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.40.2
	MLWorks_1_0_Unix_1996_11_14:1.40.1
	MLWorks_Open_Beta2_1996_10_11:1.38.3
	MLWorks_License_dev:1.38.2
	MLWorks_1_open_beta_1996_09_13:1.38.1
	MLWorks_Open_Beta_1996_08_22:1.38
	MLWorks_Beta_1996_07_02:1.38
	MLWorks_Beta_1996_06_07:1.38
	MLWorks_Beta_1996_06_06:1.37
	MLWorks_Beta_1996_06_05:1.37
	MLWorks_Beta_1996_06_03:1.37
	MLWorks_Beta_1996_05_31:1.37
	MLWorks_Beta_1996_05_30:1.37
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.41
date	97.01.07.10.48.33;	author matthew;	state Exp;
branches
	1.41.1.1
	1.41.2.1
	1.41.3.1
	1.41.4.1
	1.41.5.1;
next	1.40;

1.40
date	96.10.23.17.45.11;	author jont;	state Exp;
branches
	1.40.1.1
	1.40.2.1
	1.40.3.1
	1.40.4.1
	1.40.5.1;
next	1.39;

1.39
date	96.10.17.14.35.16;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	96.06.07.09.31.05;	author jont;	state Exp;
branches
	1.38.1.1
	1.38.2.1
	1.38.3.1;
next	1.37;

1.37
date	96.05.23.11.12.48;	author matthew;	state Exp;
branches;
next	1.36;

1.36
date	96.04.19.14.50.11;	author matthew;	state Exp;
branches;
next	1.35;

1.35
date	96.02.08.15.34.31;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	96.02.08.13.03.43;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	96.02.07.12.12.25;	author nickb;	state Exp;
branches;
next	1.32;

1.32
date	96.01.17.16.47.51;	author nickb;	state Exp;
branches;
next	1.31;

1.31
date	96.01.16.13.45.57;	author nickb;	state Exp;
branches;
next	1.30;

1.30
date	96.01.16.10.28.44;	author stephenb;	state Exp;
branches;
next	1.29;

1.29
date	96.01.12.16.41.43;	author stephenb;	state Exp;
branches;
next	1.28;

1.28
date	96.01.11.15.34.22;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	96.01.11.11.58.59;	author stephenb;	state Exp;
branches;
next	1.26;

1.26
date	96.01.11.11.15.18;	author nickb;	state Exp;
branches;
next	1.25;

1.25
date	96.01.10.16.01.02;	author stephenb;	state Exp;
branches;
next	1.24;

1.24
date	96.01.09.11.52.02;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	96.01.02.12.20.50;	author nickb;	state Exp;
branches;
next	1.22;

1.22
date	95.09.19.15.20.21;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.09.15.15.01.48;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	95.07.17.10.10.50;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.07.03.10.17.34;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	95.06.12.15.28.00;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.06.06.11.49.33;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.04.27.12.54.03;	author daveb;	state Exp;
branches;
next	1.15;

1.15
date	95.04.24.15.16.54;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.04.13.15.46.42;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.04.12.12.27.32;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.03.28.13.28.26;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.02.28.14.09.32;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.02.24.09.41.18;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.02.23.16.21.57;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.01.05.12.55.06;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	94.11.23.16.51.32;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	94.11.15.15.37.26;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.10.20.10.44.21;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.09.07.10.38.10;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.08.11.14.30.03;	author nickh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.07.22.14.33.48;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.07.08.10.30.41;	author nickh;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.31.06;	author hope;	state Exp;
branches;
next	;

1.38.1.1
date	96.09.13.11.24.45;	author hope;	state Exp;
branches;
next	;

1.38.2.1
date	96.10.07.16.15.05;	author hope;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	96.10.09.11.56.57;	author nickb;	state Exp;
branches;
next	;

1.38.3.1
date	96.10.17.11.34.31;	author hope;	state Exp;
branches;
next	;

1.40.1.1
date	96.11.14.13.00.10;	author hope;	state Exp;
branches
	1.40.1.1.1.1;
next	;

1.40.1.1.1.1
date	96.11.28.15.10.13;	author hope;	state Exp;
branches;
next	;

1.40.2.1
date	96.11.22.18.17.59;	author hope;	state Exp;
branches;
next	;

1.40.3.1
date	96.12.17.10.04.42;	author hope;	state Exp;
branches;
next	;

1.40.4.1
date	96.12.17.17.56.18;	author hope;	state Exp;
branches
	1.40.4.1.1.1;
next	;

1.40.4.1.1.1
date	97.02.24.11.47.53;	author hope;	state Exp;
branches;
next	;

1.40.5.1
date	96.12.18.09.50.57;	author hope;	state Exp;
branches;
next	;

1.41.1.1
date	97.05.12.10.44.36;	author hope;	state Exp;
branches
	1.41.1.1.1.1
	1.41.1.1.2.1
	1.41.1.1.3.1;
next	;

1.41.1.1.1.1
date	97.07.28.18.24.22;	author daveb;	state Exp;
branches
	1.41.1.1.1.1.1.1;
next	;

1.41.1.1.1.1.1.1
date	97.10.07.11.50.07;	author jkbrook;	state Exp;
branches;
next	;

1.41.1.1.2.1
date	97.09.08.17.17.42;	author daveb;	state Exp;
branches;
next	;

1.41.1.1.3.1
date	97.09.09.14.13.55;	author daveb;	state Exp;
branches;
next	;

1.41.2.1
date	97.09.10.19.30.07;	author brucem;	state Exp;
branches;
next	;

1.41.3.1
date	97.09.11.20.59.46;	author daveb;	state Exp;
branches;
next	;

1.41.4.1
date	97.10.31.13.42.54;	author nickb;	state Exp;
branches;
next	;

1.41.5.1
date	99.04.01.17.59.54;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.41
log
@Changing diagnostic level for EMT message
@
text
@/* ==== SIGNAL HANDLING ====
 * 
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module abstracts the OS-specific signal handling code from
 * the various parts of the runtime system.
 *
 * Note:
 * According to the sigaction manual page, sa_sigaction rather than
 * sa_handler should be set if SA_SIGINFO is set in sa_flags.  This
 * is not done in the following (i.e. sa_sigaction is never set, sa_handler
 * always is) because of header file problems which mean that the
 * sa_sigaction field is not visible.  The code works because in the
 * current version of Solaris, sa_handler and sa_sigaction are a union.
 *
 * Revision Log
 * ------------
 * $Log: src:OS:Solaris:arch:SPARC:signals.c,v $
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
 * Revision 1.39  1996/10/17  14:35:16  jont
 * Merge in license stuff
 *
 * Revision 1.38.2.2  1996/10/09  11:56:57  nickb
 * Move to Harlequin license server.
 *
 * Revision 1.38.2.1  1996/10/07  16:15:05  hope
 * branched from 1.38
 *
 * Revision 1.38  1996/06/07  09:31:05  jont
 * Update best before to 01/01/97
 *
 * Revision 1.37  1996/05/23  11:12:48  matthew
 * Belatedly fixing for new basis
 *
 * Revision 1.36  1996/04/19  14:50:11  matthew
 * Changes to Exception raising
 *
 * Revision 1.35  1996/02/08  15:34:31  jont
 * Moving do_exportFn to a common place independent of architecture
 *
 * Revision 1.34  1996/02/08  13:03:43  jont
 * Modify exportFn mechanism not to use signals at all
 * Use busy waiting in parent instead, thus avoiding
 * potential race contions
 *
 * Revision 1.33  1996/02/07  12:12:25  nickb
 * Make interval window updates happen even if we stay in ML.
 *
 * Revision 1.32  1996/01/17  16:47:51  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.31  1996/01/16  13:45:57  nickb
 * Getting rid of sm_interface().
 *
 * Revision 1.30  1996/01/16  10:28:44  stephenb
 * fix so that the termination of the final thread due to a fatal
 * signal returns a non-zero exit status.  Also that a fatal signal
 * caught in a fatal signal handler kills the thread rather than
 * the whole of MLWorks (unless it is the last thread of course).
 *
 * Revision 1.29  1996/01/12  16:41:43  stephenb
 * handle_fatal_signal: ensure that it does not get caught in a loop
 * if a fatal signal occurs while handling a fatal signal.
 *
 * Revision 1.28  1996/01/11  15:34:22  nickb
 * Add timer-triggered window updates.
 *
 * Revision 1.27  1996/01/11  11:58:59  stephenb
 * Added a comment noting that the sa_handler rather than sa_sigaction
 * field is being set and the reasons why this is.
 *
 * Revision 1.26  1996/01/11  11:15:18  nickb
 * SIGCHLD handler problems under /bin/sh again
 *
 * Revision 1.25  1996/01/10  16:01:02  stephenb
 * handle_fatal_signal: fix so that NPC is set as well as PC.
 *
 * Revision 1.24  1996/01/09  11:52:02  nickb
 * Extensions to event handling for non-signal events.
 *
 * Revision 1.23  1996/01/02  12:20:50  nickb
 * Update best-before date to 1996-07-01.
 *
 * Revision 1.22  1995/09/19  15:20:21  nickb
 * Improve the full GC we do during function export.
 *
 * Revision 1.21  1995/09/15  15:01:48  jont
 * Add stuff to handle the temporary child process created for exportFn
 *
 * Revision 1.20  1995/07/17  10:10:50  nickb
 * Change to profiler interface.
 *
 * Revision 1.19  1995/07/03  10:17:34  nickb
 * Update best-before date.
 *
 * Revision 1.18  1995/06/12  15:28:00  nickb
 * Fix minor thinko in fatal_signal.
 *
 * Revision 1.17  1995/06/06  11:49:33  nickb
 * Improve fatal signal support.
 *
 * Revision 1.16  1995/04/27  12:54:03  daveb
 * If signal_ml_handler is called while we are waiting for an X event,
 * the runtime just prints a message.  This avoids problems with pointer
 * grabs in X callbacks.
 *
 * Revision 1.15  1995/04/24  15:16:54  nickb
 * Add thread_preemption_pending.
 *
 * Revision 1.14  1995/04/13  15:46:42  matthew
 * Changing underflow behaviour in matherr
 *
 * Revision 1.13  1995/04/12  12:27:32  nickb
 * Make fatal signal messages come out on stderr.
 *
 * Revision 1.12  1995/03/28  13:28:26  nickb
 * Introduce the threads system.
 *
 * Revision 1.11  1995/02/28  14:09:32  jont
 * Fix interrupted system call problems during child liveness check through pipe
 *
 * Revision 1.10  1995/02/24  09:41:18  nickb
 * Fix diagnostic message.
 *
 * Revision 1.9  1995/02/23  16:21:57  nickb
 * Fix licensing signal handling.
 *
 * Revision 1.8  1995/01/05  12:55:06  nickb
 * Amend best-before date to 1st July.
 * Also fix Harlequin's telephone number.
 * Also make license signal handler run on the current stack.
 *
 * Revision 1.7  1994/11/23  16:51:32  nickb
 * Put in declaration for set_stack_underflow().
 *
 * Revision 1.6  1994/11/15  15:37:26  nickb
 * Add cache flushing.
 *
 * Revision 1.5  1994/10/20  10:44:21  nickb
 * Add cast to avoid type warning.
 *
 * Revision 1.4  1994/09/07  10:38:10  nickb
 * Update best-before to 1995-Jan-01.
 *
 * Revision 1.3  1994/08/11  14:30:03  nickh
 * Make sure signal handlers get executed on the signal stack.
 *
 * Revision 1.2  1994/07/22  14:33:48  nickh
 * Add GC trap handling.
 *
 * Revision 1.1  1994/07/08  10:30:41  nickh
 * new file
 *
 *
 */

#include "syscalls.h"

#include <signal.h>
#include <sys/signal.h>
#include <sys/ucontext.h>
#include <ucontext.h>
#include <siginfo.h>
#include <errno.h>
#include <sys/errno.h>
#include <math.h>
#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <string.h>
#include <memory.h>
#include <sys/wait.h>
#include <floatingpoint.h>

#include "signals.h"
#include "utils.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "values.h"
#include "gc.h"
#include "stacks.h"
#include "exceptions.h"
#include "event.h"
#include "license.h"
#include "profiler.h"
#include "ansi.h"
#include "reals.h"
#include "alloc.h"
#include "cache.h"
#include "threads.h"
#include "state.h"
#include "x.h"
#include "main.h"
#include "pervasives.h"
#include "global.h"
#include "allocator.h"
#include "image.h"

/* To enter garbage collection we cause a trap. The trap handler, in
   this file, sets up some variables and then calls one of these two
   asm functions: */

extern void gc_trap_entry(void);
extern void gc_trap_entry_leaf(void);

/* The first two things the trap handler sets up are these variables:

   gc_trap_bytes is the number of bytes requested by the GC entry code?
   (if this equals -1, the number of bytes is in register %g4.

   gc_trap_return_address is the value which should be in the register
   used as a link gc register when the GC code performs a jmpl to
   return to ML (i.e. it is the return address -8). */ 

word gc_trap_bytes;
word gc_trap_return_address;

/* The other thing set up by the trap handler is a routine through
   which the GC asm code should return to ML (one instruction in the
   appropriate routine has to be modified to tag the allocation result
   correctly). These two routines (leaf and non-leaf) are written in
   asm and copied into the data segment when we set up the signal
   handler.

   gc_trap_ret_template is the address of the asm
   routine. gc_trap_ret_template_end is where it
   ends. gc_trap_ret_template_overwrite is the address of the
   instruction the copy of which we want to modify.

   gc_trap_ret_code is the address of the data-segment copy of the
   code. gc_trap_ret_overwrite is the address of the instruction to
   modify. */

extern word gc_trap_ret_template, gc_trap_ret_template_end;
extern word gc_trap_ret_template_overwrite;

word *gc_trap_ret_code;
word *gc_trap_ret_overwrite;

/* the same, for the leaf case : */

extern word gc_trap_ret_leaf_template, gc_trap_ret_leaf_template_end;
extern word gc_trap_ret_leaf_template_overwrite;

word *gc_trap_ret_leaf_code;
word *gc_trap_ret_leaf_overwrite;

/* An earlier version of MLWorks generated code for each allocation
   which explicitly tested for heap overflow and called either ml_gc()
   or ml_gc_leaf() accordingly (these two functions are on the
   implicit vector). These functions have been changed to call
   ml_gc_die() and ml_gc_leaf_die() respectively (so the user may get
   a message when attempting to execute out-of-date .mo files */

extern void ml_gc_die(mlval closure);
extern void ml_gc_leaf_die(mlval closure);

/* ML signal handler support */

#define NR_SIGNALS	32
#define SIGNAL_STACK_SIZE 	SIGSTKSZ

unsigned int signal_nr_signals = NR_SIGNALS;

/* an array of flags showing how signals are handled */

#define SIGNAL_NOT_HANDLED 	((word)0)
#define SIGNAL_HANDLED_IN_ML	((word)1)
#define SIGNAL_HANDLED_IN_C	((word)2)
#define SIGNAL_HANDLED_FATALLY	((word)4)


static word *signal_handled = NULL;

static struct signal_name {int number;
			   const char *name;
			 } signal_names [] =
{{SIGHUP,	"SIGHUP"},
 {SIGINT,	"SIGINT"},
 {SIGQUIT,	"SIGQUIT"},
 {SIGILL,	"SIGILL"},
 {SIGTRAP,	"SIGTRAP"},
 {SIGIOT,	"SIGIOT"},
 {SIGABRT,	"SIGABRT"},
 {SIGEMT,	"SIGEMT"},
 {SIGFPE,	"SIGFPE"},
 {SIGKILL,	"SIGKILL"},
 {SIGBUS,	"SIGBUS"},
 {SIGSEGV,	"SIGSEGV"},
 {SIGSYS,	"SIGSYS"},
 {SIGPIPE,	"SIGPIPE"},
 {SIGALRM,	"SIGALRM"},
 {SIGTERM,	"SIGTERM"},
 {SIGUSR1,	"SIGUSR1"},
 {SIGUSR2,	"SIGUSR2"},
 {SIGCHLD,	"SIGCHLD"},
 {SIGPWR,	"SIGPWR"},
 {SIGWINCH,	"SIGWINCH"},
 {SIGURG,	"SIGURG"},
 {SIGPOLL,	"SIGPOLL"},
 {SIGSTOP,	"SIGSTOP"},
 {SIGTSTP,	"SIGTSTP"},
 {SIGCONT,	"SIGCONT"},
 {SIGTTIN,	"SIGTTIN"},
 {SIGTTOU,	"SIGTTOU"},
 {SIGVTALRM,	"SIGVTALRM"},
 {SIGPROF,	"SIGPROF"},
 {SIGXCPU,	"SIGXCPU"},
 {SIGXFSZ,	"SIGXFSZ"},
 {SIGWAITING,	"SIGWAITING"},
 {SIGLWP,	"SIGLWP"},
 {0,		NULL}};

static const char *name_that_signal (int sig)
{
  static const char *no_such_signal = "Unknown";
  struct signal_name *this = signal_names;

  while (this->number != sig &&
	 this->name != NULL)
    this++;

  if (this->name == NULL)
    return no_such_signal;
  else
    return this->name;
}

#define CONTEXT_REG(thecontext,name)				\
	       ((thecontext)->uc_mcontext.gregs[REG_ ## name])
#define CONTEXT_SP(c)	(CONTEXT_REG(c,O6))
#define CONTEXT_PC(c)	(CONTEXT_REG(c,PC))
#define CONTEXT_NPC(c)	(CONTEXT_REG(c,nPC))
#define CONTEXT_G6(c)	(CONTEXT_REG(c,G6))
#define CONTEXT_ARG(c)	(CONTEXT_REG(c,O0))

/* Solaris-specific stuff for setting and clearing a signal handler */

typedef void (*signal_handler)(int sig, siginfo_t *info, ucontext_t *context);

static int check_sigaction (int sig, struct sigaction *act)
{
  int result = sigaction (sig,act,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  return result;
}

static int set_signal_handler(int sig, signal_handler handler)
{
  struct sigaction sa;
  sa.sa_handler = handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = SA_ONSTACK | SA_SIGINFO | SA_RESTART;
      
  return (check_sigaction (sig,&sa));
}

static int restore_default_signal_handler(int sig)
{
  struct sigaction sa;
  sa.sa_handler= SIG_DFL;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags= 0;
  return check_sigaction(sig, &sa);
}

/* signal_event() is called from record_event (in the events
   module). It can be called either synchronously in C or
   asynchronously in C or ML. It should set the 'interrupted' flag
   such that the event is taken synchronously by ML when we return to
   ML. */

extern void signal_event(void)
{
  /* set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
}

static void signal_ml_event (ucontext_t *context)
{
  if (global_state.in_ML) {
    CONTEXT_G6(context) = -1;		/* set g6 register to -1 */
  }
}

/*  == The C signal handler ==
 *
 *  This function converts a C signal into an ML signal event.
 */

static void signal_ml_handler
  (int sig, siginfo_t *info, ucontext_t *context)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    record_event(EV_SIGNAL, (word) sig);
    signal_ml_event(context);
  }
}

/* Install or remove the signal handler for a given signal */

extern int signal_set_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if ((handled & SIGNAL_HANDLED_IN_ML) == 0) {
    signal_handled[sig] = handled + SIGNAL_HANDLED_IN_ML;
    if ((handled & SIGNAL_HANDLED_IN_C) == 0) {
      return set_signal_handler(sig,signal_ml_handler);
    }
  }
  return 0;
}

extern int signal_clear_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if (handled & SIGNAL_HANDLED_IN_ML) {
    signal_handled[sig] = handled = handled - SIGNAL_HANDLED_IN_ML;
    if (handled == 0) {
      return restore_default_signal_handler(sig);
    }
  }
  return 0;
}

/* Do something tolerable in the face of a fatal signal */

static mlval signal_thread_suicide_stub[] = {0, 0, (mlval)thread_suicide};

static void restore_default_fatal_signal_handlers(void)
{
  int i;
  for (i=0; i < NR_SIGNALS; i++) {
    if (signal_handled[i] & SIGNAL_HANDLED_FATALLY) {
      signal_handled[i] -= (SIGNAL_HANDLED_FATALLY + SIGNAL_HANDLED_IN_C);
      if (restore_default_signal_handler(i) != 0)
	error_without_alloc("Could not restore default fatal signal handlers");
    }
  }
}

static void die_in_fatal_signal_handler(char const *message)
{
  /* race condition here if the following call fails with a fatal signal */
  restore_default_fatal_signal_handlers();
  message_stderr("Fatal signal handler dying: %s", message);
}

static void handle_fatal_signal
  (int sig, siginfo_t *info, ucontext_t *context)
{
  if (CURRENT_THREAD == 0) {
    die_in_fatal_signal_handler("corrupt threads system");

  } else if (CURRENT_THREAD->in_fatal_signal_handler) {
    die_in_fatal_signal_handler("fatal signal raised by handler");

  } else if (in_GC) {
    die_in_fatal_signal_handler("fatal signal raised during GC.");

  } else {
    const char *signal_name;
    mlval handler;

    CURRENT_THREAD->in_fatal_signal_handler= 1;
    signal_name= name_that_signal (sig);
    handler= THREAD_ERROR_HANDLER(CURRENT_THREAD);
    flush_windows();

    DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,info,context);
  
    if (handler == MLUNIT) {
      /* there is no handler; print a message and kill this thread */
      if (runnable_threads == 2) {
	die_in_fatal_signal_handler("Last thread dying.");
      } else {
	message ("Thread #%d received an intolerable signal %s (%d : %d) %sin ML and died.",
		 CURRENT_THREAD->number, signal_name, sig, info->si_code,
		 global_state.in_ML? "" : "not ");
	backtrace ((struct stack_frame *)CONTEXT_SP(context),
		   CURRENT_THREAD, max_backtrace_depth);

	SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
	if (global_state.in_ML) {
	  CONTEXT_PC(context) = (int) stub_c+CODE_OFFSET;
	  CONTEXT_NPC(context) = (int) stub_c+CODE_OFFSET+4;
	  CONTEXT_ARG(context) = MLUNIT;
	  CONTEXT_REG(context, O1) = (int)signal_thread_suicide_stub+POINTER;
	} else {
	  CONTEXT_PC(context) = (int)thread_suicide;
	  CONTEXT_NPC(context) = (int)thread_suicide+4;
	}
	/* to reduce the race window the following should be near the
	 * end of thread_suicide.  However, that entails putting it in
	 * the end of the asm routine change_thread, so for simplicity it
	 * is left here. */
	CURRENT_THREAD->in_fatal_signal_handler= 0;
      }
    } else {
      CONTEXT_ARG(context) = MLINT(sig);
      CONTEXT_REG(context,O1) = handler;
      /* if there is a handler, skip to it: */
      if (global_state.in_ML) {
	CONTEXT_PC(context) = FIELD(handler,0)+CODE_OFFSET;
	CONTEXT_NPC(context) = FIELD(handler,0)+CODE_OFFSET+4;
      } else {
	CONTEXT_PC(context) = (int)callml;
	CONTEXT_NPC(context) = (int)callml+4;
      }
      /* Note that CURRENT_THREAD->in_fatal_signal_handler is not reset here.
       * The onus is on the SML fatal signal handler to call the SML
       * version of thread_reset_fatal_status before returning. */
    }
  }
}

/* Install the above function for a given signal */

static int die_on_signal(int sig)
{
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C | SIGNAL_HANDLED_FATALLY;
  return set_signal_handler(sig,handle_fatal_signal);
}


/* == Integer exception support == 
 *
 * This function is the handler for the emulation trap signals. These
 * are caused by ML arithmetic instructions which overflow (and which
 * should therefore raise an exception) and by allocation sequences
 * which run out of heap (and which should therefore cause a GC).

 * If called while in ML it examines the instruction which caused the
 * exception in order to determine which ML exception to raise, or to
 * do a GC.  The signal context is updated in order to raise the
 * exception (or enter the GC code) when the handler returns.  */

static void signal_integer_exception_handler
  (int sig, siginfo_t *info, ucontext_t *context)
{
  word instruction = *(word*)CONTEXT_PC(context);

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,info,context);
  
  if (!global_state.in_ML) {
    message_stderr("Warning: signal %d outside ML -- ignoring", sig);
    return;
  }

/* Check for allocation traps so we can start a GC.

   Allocation sequences always look like one of the following:

 * 1. Allocating a known amount < 4k:

	taddcctv %g1, #bytes, %g1
	add	rn, %g2, #tag
	add	%g2, %g2, #bytes

 * 2. Allocating an unknown amount, or a known amount > 4k:

 	<get the number of bytes into the 'global' register %g4>
 	taddcctv %g1, %g4, %g1
 	add	rn, %g2, #tag
 	add	%g2, %g2, %g4

 * In a leaf procedure, the 'add rn' instruction (the one after the
 * taddcctv) should be replaced with an 'or rn' instruction. This
 * enables us to distinguish the leaf case.

 * The taddcctv instruction fails if there is insufficient space for
 * the alloc */

#define TADDCCTV_MASK 0xffffc000
#define TADDCCTV_BITS 0x83104000

  if ((instruction & TADDCCTV_MASK) == TADDCCTV_BITS) {
    /* then it's a GC entry point */

    int leaf;
    word instr2;
    word overwrite_instr;	/* the instr to go in the overwrite slot */
    word *overwrite;		/* the address of the overwrite slot */


    /* get the number of bytes */

#define TADDCCTV_IMMEDIATE_FLAG_MASK 0x2000
#define TADDCCTV_IMMEDIATE_MASK 0x1fff

    if (instruction & TADDCCTV_IMMEDIATE_FLAG_MASK) {
      gc_trap_bytes = ((instruction & TADDCCTV_IMMEDIATE_MASK));
    } else {
      /* -1 means "the number is in the 'global' register" */
      gc_trap_bytes = 0xffffffff;
    }

    /* We want to return to address+12, so set the fake link register
       to addr+4 */

    gc_trap_return_address = ((word)CONTEXT_PC(context))+4;

    /* construct tagging instruction, which tags the value in the
       return register and puts it in whatever register the allocation
       routine was going to put it. We do this by getting the tagging
       instruction out of the allocation routine and changing the
       register number */

    instr2 = ((word*)CONTEXT_PC(context))[1];

#define GC_RETURN_REGISTER 0x1u
#define GC_TAGGING_SHIFT 14u
#define GC_TAGGING_MASK 0x1fu

    overwrite_instr =
      ((instr2 & (~(GC_TAGGING_MASK << GC_TAGGING_SHIFT)))
       | (GC_RETURN_REGISTER << GC_TAGGING_SHIFT));

    /* was the allocation routine in a leaf procedure? */

#define GC_ENTRY_LEAF_MASK 0x3f
#define GC_ENTRY_LEAF_SHIFT 19
#define GC_ENTRY_LEAF_VALUE 2

    leaf = (((instr2 & (GC_ENTRY_LEAF_MASK << GC_ENTRY_LEAF_SHIFT))
		 >> GC_ENTRY_LEAF_SHIFT) == GC_ENTRY_LEAF_VALUE);

    if (leaf) {
      CONTEXT_PC(context) = (int)gc_trap_entry_leaf;
      CONTEXT_NPC(context) = ((int)gc_trap_entry_leaf)+4;
      overwrite = gc_trap_ret_leaf_overwrite;
    } else {
      CONTEXT_PC(context) = (int)gc_trap_entry;
      CONTEXT_NPC(context) = ((int)gc_trap_entry)+4;
      overwrite = gc_trap_ret_overwrite;
    }
    *overwrite = overwrite_instr;
    cache_flush((void*)overwrite, sizeof(word));
    return;
  }

  DIAGNOSTIC(3, "signal %d: EMT exception code 0x%X", sig, info->si_code);
  DIAGNOSTIC(3, "  addr 0x%X: %08X", CONTEXT_PC(context), instruction);

  /* Switch on the instruction code: SPARC specific */

  switch(instruction & 0xC1F80000) {
    case 0x81180000:
    DIAGNOSTIC(4, "  tsubcctv", 0, 0);
    break;

    case 0x81100000:
    DIAGNOSTIC(4, "  taddcctv", 0, 0);
    break;

    default:
    DIAGNOSTIC(4, "  not a tagged trap int instruction", 0, 0);
    message("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
    return;
  }
  CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
  CONTEXT_PC(context) = (int)ml_raise;
  CONTEXT_NPC(context) = (int)ml_raise+4;
}


/* == Licensing support == 
 * 
 * SIGALRM is handled by refreshing the license. */

static void signal_timer_handler
  (int sig, siginfo_t *info, ucontext_t *context)
{
  refresh_license();

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,info,context);
}

extern void signal_license_timer (int interval) 
{
  struct itimerval period;

  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");

  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */

  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
  period.it_value.tv_usec = 0;
  period.it_interval.tv_sec = interval;
  period.it_interval.tv_usec = 0;
  
  if(setitimer(ITIMER_REAL, &period, NULL) == -1)
    error("Unable to set up licensing timer.  "
	  "setitimer set errno to %d.", errno);
}

/* == Interrupt Support ==
 * 
 * SIGINT is handled and interpreted as an interrupt. */

static void signal_interrupt_handler
  (int sig, siginfo_t *info, ucontext_t *context)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,info,context);
    else 
      signal_ml_event(context);
  
    record_event(EV_INTERRUPT, (word) 0);
  }
}

extern int signal_set_interrupt_handler(void)
{
  signal_handled[SIGINT] |= SIGNAL_HANDLED_IN_C;	/* interrupt */
  return set_signal_handler(SIGINT,signal_interrupt_handler);
}

extern int signal_clear_interrupt_handler(void)
{
  signal_handled[SIGINT] &= !SIGNAL_HANDLED_IN_C;

  if (signal_handled[SIGINT] & SIGNAL_HANDLED_IN_ML)
    return signal_set_ml_handler(SIGINT);
  else
    return restore_default_signal_handler(SIGINT);
}

/* == Timer support ==
 *
 * We need a virtual-time alarm for two purposes: for stack-based profiling
 * and for thread pre-emption.
 */

static struct itimerval interval_timer, residual_timer;
unsigned int current_interval = 0;

/* the number of milliseconds for the profiling and pre-emption intervals. */

unsigned int profiling_interval = 0;
unsigned int thread_preemption_interval = 0;
unsigned int window_update_interval = 0;
static unsigned int window_update_remaining = 0;
static unsigned int window_updates_on = 0;

static void signal_start_timer(void)
{
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, &residual_timer) == -1)
    message("Warning: Unable to set interval timer. \n"
	    " Profiling, preemption, and window updates may not occur");
}

static unsigned int signal_set_timer(unsigned int interval)
{
  unsigned int last_interval = current_interval;
  current_interval = interval;
  interval_timer.it_value.tv_sec = interval/1000;
  interval_timer.it_value.tv_usec = (interval%1000)*1000;
  interval_timer.it_interval.tv_sec = 0;
  interval_timer.it_interval.tv_usec = 0; /* one shot timer */

  signal_start_timer();
  interval = ((residual_timer.it_value.tv_sec * 1000) +
	      (residual_timer.it_value.tv_usec / 1000));
  interval = last_interval - interval;
  return interval;
}

static int signal_update_windows(unsigned int interval)
{
  if (window_update_remaining < interval) {
    window_update_remaining = window_update_interval;
    if (window_updates_on) {
      record_event(EV_WINDOWS, (word) 0);
      return 1;
    }
  } else
    window_update_remaining -= interval;
  return 0;
}
  
static void signal_do_timer(unsigned int interval)
{
  unsigned int residue = signal_set_timer(interval);
  (void) signal_update_windows(residue);
}

/* The signal handler function. If we're profiling we run the
 * profiler. If we're pre-empting we record the event. */

static void signal_interval_alarm
  (int sig, siginfo_t *info, ucontext_t *context)
{
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,info,context);
  
  if (profile_on)
    time_profile_scan((struct stack_frame *) CONTEXT_SP(context));
  
  if (thread_preemption_on) {
    thread_preemption_pending = 1;
    record_event(EV_SWITCH, (word) 0);
    if ((signal_handled[sig] & SIGNAL_HANDLED_IN_ML) == 0)
      signal_ml_event(context);
  }

  if (signal_update_windows (current_interval))
      signal_ml_event(context);
  signal_start_timer();
}

/* == Profiling support == */

extern void signal_profiling_start(void)
{
  signal_do_timer(profiling_interval);
}

extern void signal_profiling_stop(void)
{
  unsigned int interval;
  if (thread_preemption_on)
    interval = thread_preemption_interval;
  else if (window_updates_on)
    interval = window_update_interval;
  else
    interval = 0;
  signal_do_timer(interval);
}

/* == Preemption support == */

extern void signal_preemption_start(void)
{
  if (!profile_on)
    signal_do_timer(thread_preemption_interval);
}

extern void signal_preemption_stop(void)
{
  if (!profile_on) {
    unsigned int interval;
    if (window_updates_on)
      interval = window_update_interval;
    else
      interval = 0;
    signal_do_timer(interval);
  }
}

extern void signal_preemption_change(void)
{
  signal_preemption_start();
}

/* Window update support */

extern void signal_window_updates_start(void)
{
  window_updates_on = 1;
  if (current_interval == 0)
    signal_do_timer(window_update_interval);
}

extern void signal_window_updates_stop(void)
{
  window_updates_on = 0;
}

/* a generic routine to make a new copy of some code */

static word* copy_code(char* start, char* finish)
{
  unsigned int bytes = finish-start;
  word *result = (word*)malloc(bytes);
  memcpy(result,start,bytes);
  return result;
}

/* copy the two GC return codes into the data segment */

static void copy_codes(void)
{
  gc_trap_ret_code = copy_code((char*) &gc_trap_ret_template,
			       (char*) &gc_trap_ret_template_end);
  gc_trap_ret_leaf_code = copy_code((char*) &gc_trap_ret_leaf_template,
				    (char*) &gc_trap_ret_leaf_template_end);

  gc_trap_ret_overwrite = (word*) (((int)gc_trap_ret_code) +
				   ((int)&gc_trap_ret_template_overwrite) -
				   ((int)&gc_trap_ret_template));
  gc_trap_ret_leaf_overwrite =
    (word*) (((int)gc_trap_ret_leaf_code) +
	     ((int)&gc_trap_ret_leaf_template_overwrite)-
	     ((int)&gc_trap_ret_leaf_template));
}

static void establish_signal_table(void)
{
  int i;
  signal_handled = (word*) alloc(NR_SIGNALS * sizeof(word),
				 "Unable to allocate signal table");
  for (i=0; i < NR_SIGNALS; i++)
    signal_handled[i] = SIGNAL_NOT_HANDLED;
  signal_handled[SIGEMT]    = SIGNAL_HANDLED_IN_C;	/* integer exns */
  signal_handled[SIGVTALRM] = SIGNAL_HANDLED_IN_C;	/* intervals */
}

extern void signals_init (void)
{
  stack_t ss;
  char *signal_stack;

  /* Initialise the signal stack */
  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack.");

  ss.ss_sp = signal_stack;
  ss.ss_size = SIGNAL_STACK_SIZE;
  ss.ss_flags = 0;

  if(sigaltstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigaltstack set errno to %d).",
	  errno);

  /* set up 'where is signal handled' table */
  establish_signal_table();

  /* establish integer arithmetic exception catcher */
  if (set_signal_handler(SIGEMT, signal_integer_exception_handler))
    error("Unable to set integer exception handler.");

  /* establish virtual interval timer signal handler */
  if (set_signal_handler(SIGVTALRM, signal_interval_alarm))
    error("Unable to set up virtual interval timer signal handler.");

  /* make copies of GC return codes */
  copy_codes();

  /* these signals are fatal */
  die_on_signal (SIGILL);
  die_on_signal (SIGBUS);
  die_on_signal (SIGSEGV);
}


extern void ml_gc_die(mlval closure)
{
  error("ml_gc() called by %s.\n\tYou are probably running out-of-date .mo files\n",
	CSTRING(CCODENAME(FIELD(closure,0))));
}

extern void ml_gc_leaf_die(mlval closure)
{
  error("ml_gc_leaf() called by %s.\n\tYou are probably running out-of-date .mo files\n",
	CSTRING(CCODENAME(FIELD(closure,0))));
}
@


1.41.5.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 3
 * Revision 1.41  1997/01/07  10:48:33  matthew
 * Changing diagnostic level for EMT message
 *
@


1.41.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a20 3
 * Revision 1.41  1997/01/07  10:48:33  matthew
 * Changing diagnostic level for EMT message
 *
@


1.41.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 3
 * Revision 1.41  1997/01/07  10:48:33  matthew
 * Changing diagnostic level for EMT message
 *
@


1.41.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 3
 * Revision 1.41  1997/01/07  10:48:33  matthew
 * Changing diagnostic level for EMT message
 *
@


1.41.1.1
log
@branched from 1.41
@
text
@a20 3
 * Revision 1.41  1997/01/07  10:48:33  matthew
 * Changing diagnostic level for EMT message
 *
@


1.41.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 3
 * Revision 1.41.1.1  1997/05/12  10:44:36  hope
 * branched from 1.41
 *
@


1.41.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 3
 * Revision 1.41.1.1  1997/05/12  10:44:36  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 3
 * Revision 1.41.1.1  1997/05/12  10:44:36  hope
 * branched from 1.41
 *
@


1.41.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 * Revision 1.41.1.1.1.1  1997/07/28  18:24:22  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.40
log
@Use SA_RESTART to avoid interrupted system calls
@
text
@d21 3
d661 2
a662 2
  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, info->si_code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", CONTEXT_PC(context), instruction);
d668 1
a668 1
    DIAGNOSTIC(1, "  tsubcctv", 0, 0);
d672 1
a672 1
    DIAGNOSTIC(1, "  taddcctv", 0, 0);
d676 1
a676 1
    DIAGNOSTIC(1, "  not a tagged trap int instruction", 0, 0);
@


1.40.5.1
log
@branched from 1.40
@
text
@a20 3
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
@


1.40.4.1
log
@branched from 1.40
@
text
@a20 3
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
@


1.40.4.1.1.1
log
@branched from 1.40.4.1
@
text
@a20 3
 * Revision 1.40.4.1  1996/12/17  17:56:18  hope
 * branched from 1.40
 *
@


1.40.3.1
log
@branched from 1.40
@
text
@a20 3
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
@


1.40.2.1
log
@branched from 1.40
@
text
@a20 3
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
@


1.40.1.1
log
@branched from 1.40
@
text
@a20 3
 * Revision 1.40  1996/10/23  17:45:11  jont
 * Use SA_RESTART to avoid interrupted system calls
 *
@


1.40.1.1.1.1
log
@branched from 1.40.1.1
@
text
@a20 3
 * Revision 1.40.1.1  1996/11/14  13:00:10  hope
 * branched from 1.40
 *
@


1.39
log
@Merge in license stuff
@
text
@d21 3
d363 1
a363 1
  sa.sa_flags = SA_ONSTACK | SA_SIGINFO;
@


1.38
log
@Update best before to 01/01/97
@
text
@d21 9
a537 30
/*  == Handle math errors in library functions ==
 *
 *  The matherr function is called by the math library when exception
 *  occur.  See matherr(3M).  This function need only handle those
 *  routines we actually provide in reals.[ch]. */

extern int matherr(struct exception *e)
{
/*
  char *problem = e->name;
  int type = e->type;
  if (type != UNDERFLOW)
    {in_ml_fpe = 0;
     if(strcmp(problem, "log") == 0)
       exn_raise(perv_exn_ref_ln);
     else if(strcmp(problem, "fabs") == 0)
       exn_raise(perv_exn_ref_abs);
     else if(strcmp(problem, "exp") == 0)
       exn_raise(perv_exn_ref_exp);
     else if(strcmp(problem, "sqrt") == 0)
       exn_raise(perv_exn_ref_sqrt);
     message_stderr("Warning: Unhandled floating point error in `%s' -- returning %g",
		    problem, e->retval);
   }

*/

  return(1);
}

d660 1
a660 2
  switch(instruction & 0xC1F80000)
  {
a662 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
a666 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
d674 1
a674 1

d680 1
a680 1
/* == Licensing support ==
d682 1
a682 17
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */

#define POLL_PERIOD	600		/* seconds between licence checks */
#define BEST_BEFORE	852076800	/* 1996-07-01 00:00 */
d684 1
a684 15
/* The process ID of the licensing child */

int signal_license_child_pid;

/* The handler for SIGCHLD, installed by the main MLWorks process */
/* This handles death of license child */

/* Note that when text is passed to the runtime through a pipe under
 * /bin/sh on Solaris (e.g. "echo foo | runtime"), this signal handler
 * gets called (almost?) as soon as it is installed. This is when the
 * license set-up runs, which is before most other things run
 * (e.g. signals system initialization). So this handler has to be
 * robust. */

static void signal_child_handler
d687 1
a687 2
  int status, available;
  pid_t pid = 0;
d689 2
a690 45
  if (signal_handled && (signal_handled[sig] & SIGNAL_HANDLED_IN_ML))
    signal_ml_handler(sig,info,context);
  
  if (info != NULL) {
    pid = info->_data._proc._pid;
    DIAGNOSTIC(4, "sigchild with non-NULL data", 0, 0);
  } else {
    DIAGNOSTIC(4, "sigchild with NULL data, ignored", 0, 0);
    return;
  }

  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig,(info ? info->si_code : 0));
  DIAGNOSTIC(4, "         child = %d)", pid, 0);
  DIAGNOSTIC(4, "license pid = %d)", signal_license_child_pid, 0);

  /* Find out what happened to the child.  If waitpid() is interrupted by a */
  /* signal then try again. */

  if (signal_license_child_pid == pid) {
    do
      available = waitpid(signal_license_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);

    if(available == -1)
      error("Unable to determine status of licensing process.  "
	    "waitpid set errno to %d.", errno);

    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */

    if(available) {
      DIAGNOSTIC(1, "available %d status 0x%02X", available, status);

      if(WIFSTOPPED(status))
	error("Licensing process stopped with signal %d", WSTOPSIG(status));
      else if(WIFSIGNALED(status))
	error("Licensing process terminated with signal %d", WTERMSIG(status));
      else
	error("Your license has expired.  Contact MLWorks customer support:\n"
	      "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	      "   telephone:        +44 1223 872522");
    }
  }
d693 1
a693 4
/* The handler for SIGALRM, installed by the child (licensing) process */
  
static void signal_license_alarm_handler
  (int sig, siginfo_t *info, ucontext_t *context)
d695 1
a695 25
  time_t now;

  now = time(NULL);
  DIAGNOSTIC(4, "checking license at time %ld", now, 0);

  if(now == -1)
    message("WARNING: time() returned -1");
  else if (now >= BEST_BEFORE) {
    DIAGNOSTIC(1, "child: license expired at time %ld", now,0);
    exit(1);
  }
}

/* A function called by the main MLWorks process to watch the child
 * process */

extern void signal_license_watch_child (void)
{
  if (set_signal_handler(SIGCHLD, signal_child_handler))
    error("Unable to set signal handler for SIGCHLD");
}

/* The child process itself */

extern char *_sys_errlist[];
d697 3
a699 8
extern void signal_license_child (int *pipefd)
{
  struct sigaction act;
  sigset_t signals_to_block;

  char dummy;
  struct itimerval period;
  int read_from_child = 0;
d701 1
a701 18
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
  act.sa_handler = signal_license_alarm_handler;
  
  /* Ignore all signals (if possible) so that signals sent to the */
  /* process group won't affect the licensing process. */
  /* SIGKILL and SIGSTOP are not blocked by this */
  sigfillset(&signals_to_block);
  sigdelset(&signals_to_block,SIGALRM);
  sigprocmask(SIG_BLOCK,&signals_to_block,NULL);
  
  /* Check the license once before we start. */
  signal_license_alarm_handler (0,NULL,NULL);
  
  /* Set up a real time alarm with a handler to poll the license. */
  if(sigaction(SIGALRM, &act, NULL) == -1)
    error("Licensing process unable to set signal handler for SIGALRM.  "
	  "sigaction set errno to %d.", errno);
d703 2
a704 1
  period.it_value.tv_sec = POLL_PERIOD;
d706 1
a706 1
  period.it_interval.tv_sec = POLL_PERIOD;
a711 15
  
  /* Read from the child's end of the pipe.  This has the effect of */
  /* blocking the child until the other end is closed by the parent */
  /* exiting. */
  
  close(pipefd[1]);
  do {
    read_from_child = read(pipefd[0], &dummy, 1);
  } while (read_from_child == -1 && errno == EINTR);
  /* Ignore stupid system V interrupted system call crap */
  if(read_from_child != 0)
    error("Licensing process managed to read %d characters from pipe.", read_from_child);

  DIAGNOSTIC(2,"child: parent died -- exiting",0,0);
  exit(0);
a925 1
  signal_handled[SIGFPE]    = SIGNAL_HANDLED_IN_C;	/* float exns */
a926 1
  signal_handled[SIGCHLD]   = SIGNAL_HANDLED_IN_C;	/* licensing */
d953 1
a953 1
  /* establish interval timer signal handler */
d955 1
a955 1
    error("Unable to set up interval timer signal handler.");
@


1.38.3.1
log
@branched from 1.38
@
text
@a20 3
 * Revision 1.38  1996/06/07  09:31:05  jont
 * Update best before to 01/01/97
 *
@


1.38.2.1
log
@branched from 1.38
@
text
@a20 3
 * Revision 1.38  1996/06/07  09:31:05  jont
 * Update best before to 01/01/97
 *
@


1.38.2.2
log
@Move to Harlequin license server.
@
text
@a20 3
 * Revision 1.38.2.1  1996/10/07  16:15:05  hope
 * branched from 1.38
 *
d532 30
d684 2
a685 1
  switch(instruction & 0xC1F80000) {
d688 1
d693 1
d701 1
a701 1
  CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
d707 1
a707 1
/* == Licensing support == 
d709 19
a727 1
 * SIGALRM is handled by refreshing the license. */
d729 13
a741 1
static void signal_timer_handler
d744 13
a756 1
  refresh_license();
d758 61
a818 2
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,info,context);
d821 5
a825 1
extern void signal_license_timer (int interval) 
d827 4
d832 1
d834 18
a851 5
  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");

  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */
d853 1
a853 2
  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
d855 1
a855 1
  period.it_interval.tv_sec = interval;
d861 15
d1090 1
d1092 1
d1119 1
a1119 1
  /* establish virtual interval timer signal handler */
d1121 1
a1121 1
    error("Unable to set up virtual interval timer signal handler.");
@


1.38.1.1
log
@branched from 1.38
@
text
@a20 3
 * Revision 1.38  1996/06/07  09:31:05  jont
 * Update best before to 01/01/97
 *
@


1.37
log
@Belatedly fixing for new basis
@
text
@d21 3
d722 1
a722 1
#define BEST_BEFORE	836179200	/* 1996-07-01 00:00 */
@


1.36
log
@Changes to Exception raising
@
text
@d21 3
d534 1
d537 1
a537 1
  if (type != UNDERFLOW) /* Ignore underflows */
d551 1
a551 67
  return(0);
}

/* == Real arithmetic exception support ==
 *
 *  This function is the handler for the floating point exception
 *  signals.  If called while in ML it examines the instruction which
 *  caused the exception in order to determine which ML exception to
 *  raise.  The signal context is updated in order to change raise the
 *  exception when the handler returns.  */

static void signal_real_exception_handler
  (int sig, siginfo_t *info, ucontext_t *context)
{
  word instruction = *(word*)CONTEXT_PC(context);
  
  DIAGNOSTIC(1, "signal %d: IEEE exception code 0x%X", sig, info->si_code);
  
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,info,context);
  
  /* Find out whether the exception occurred in ML or C.  If in C then we */
  /* can ignore it -- the library will call matherr (qv) */
  
  if(! global_state.in_ML) {
    if (in_ml_fpe && sig == SIGFPE) {
      in_ml_fpe = 0;
    } else {
      message("Warning: signal %d outside ML -- ignoring", sig);
    }
    return;
  }
     
  /* Check that the instruction type is FPOP */
     
  if((instruction & 0xC1F00000) != 0x81A00000) {
    DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
    message("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
    return;
  }
  
  /* Switch on the instruction code : SPARC-specific */

  switch(instruction & 0x00003FE0)
  {
    /* This case should never happen.  We check the size explicitly,
       because we use 30-bit ints instead of 32-bit ints.
    case 0x1A40:
    DIAGNOSTIC(1, "  fdtoi", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
    break;
    */

    case 0x0540:
    DIAGNOSTIC(1, "  fsqrtd", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_sqrt);
    break;

    case 0x0840:
    DIAGNOSTIC(1, "  faddd", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
    break;

    case 0x08C0:
    DIAGNOSTIC(1, "  fsubd", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
    break;
d553 1
a553 18
    case 0x0940:
    DIAGNOSTIC(1, "  fmuld", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
    break;

    case 0x09C0:
    DIAGNOSTIC(1, "  fdivd", 0, 0);
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_overflow);
    break;

    default:
    DIAGNOSTIC(1, "  unknown fpop instruction", 0, 0);
    message("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  CONTEXT_PC(context) = (int)ml_raise;
  CONTEXT_NPC(context) = (int)ml_raise+4;
a1111 6

  /* establish real arithmetic exception catcher */
  /* can't use ieee_handler here because it doesn't seem to exist on
   * Solaris 2.2 */
  if (set_signal_handler(SIGFPE, signal_real_exception_handler))
    error("Unable to set real exception handler.");
@


1.35
log
@Moving do_exportFn to a common place independent of architecture
@
text
@d21 3
d596 1
a596 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_floor);
d607 1
a607 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_sum);
d612 1
a612 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_diff);
d617 1
a617 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_prod);
d622 1
a622 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_quot);
d761 1
a761 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_diff);
d766 1
a766 1
    CONTEXT_ARG(context) = DEREF(perv_exn_ref_sum);
@


1.34
log
@Modify exportFn mechanism not to use signals at all
Use busy waiting in parent instead, thus avoiding
potential race contions
@
text
@d21 5
a888 68
}

/* exportFn support */
mlval do_exportFn(mlval argument)
{
  pid_t child_pid = fork();

  if(child_pid == -1) {
    switch(errno) {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork exportFn process");
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork exportFn process");
      default: 
      exn_raise_format(perv_exn_ref_save,
		       "fork() returned an unexpected error code %d", errno);
    }
  } else if (child_pid == 0) {
    /* The child process */
    mlval global;
    mlval filename = FIELD(argument, 0);
    image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
    declare_root(&filename);
    
    global = global_pack();
    declare_root(&global);
    
    gc_clean_image();
    
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);
    
    if(image_save(argument) == ERROR)
      exit(errno ? errno : -1);
    
    exit(0);
  } else {
    /* The parent process */
    int status;
    DIAGNOSTIC(4, "Setting export child pid is %d", child_pid, 0);
    /* Now wait for the child to complete, and get its return status */
    do {
      waitpid(child_pid, &status, 0);
    } while(!(WIFSIGNALED(status) || WIFEXITED(status)));
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save, "Export process terminated by signal %d",
		       WTERMSIG(status));
    }
    switch(WEXITSTATUS(status)) {
    case 0:
      break;
    case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Function save not implemented");
    case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
    case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");
    default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
    }
    return MLUNIT; /* Should later change to return to MLWorks */
  }
@


1.33
log
@Make interval window updates happen even if we stay in ML.
@
text
@d21 3
a795 8
/* The process ID of the exportFn child */

int signal_export_child_pid;

static int export_exists = 0; /* Something to ensure we don't miss signals */
static int export_child_status = 0;
static int child_exited = 1;

d797 1
a797 1
/* This handles death of license, and if relevant, export children */
d825 1
a825 1
  DIAGNOSTIC(4, "license and export pids = %d, %d)", signal_license_child_pid, signal_export_child_pid);
a856 54
  else if (signal_export_child_pid == pid) {
    do
      available = waitpid(signal_export_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);

    if(available == -1)
      error("Unable to determine status of export process.  "
	    "waitpid set errno to %d.", errno);

    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */

    if(available) {
      DIAGNOSTIC(1, "available %d status 0x%02X", available, status);

      if(WIFSTOPPED(status))
	error("Export process stopped with signal %d", WSTOPSIG(status));
      else if(WIFSIGNALED(status))
	error("Export process terminated with signal %d", WTERMSIG(status));
      else if(WIFEXITED(status)) {
	/* This is the case where the child has exited roughly as expected */
	DIAGNOSTIC(1, "Export process terminated with status %d",
		   WEXITSTATUS(status), 0);
	export_child_status = status;
	child_exited = 1;
	return;
      } else
	error("Export process terminated for unknown reason");

    } else {
      /* else status has changed back again */
      error("exportFn:Child status has unexpectedly reverted");
    }
  } else if (export_exists) {
    /* Oh dear, a race condition */
    error("Unexpected SIGCHLD for unknown pid %d", pid);
  }
}

static void clear_export_child_status(void)
{
  child_exited = 0;
}

static int read_export_child_status(void)
{
  return WEXITSTATUS(export_child_status);
}

static int check_export_child_status(void)
{
  return child_exited;
a885 12
static void signal_export_watch_child(void)
{
  DIAGNOSTIC(4, "Watching export child", 0, 0);
  export_exists = 1;
}

static void signal_export_unwatch_child(void)
{
  DIAGNOSTIC(4, "Unwatching export child", 0, 0);
  export_exists = 0;
}

d889 1
a889 5
  pid_t child_pid;

  clear_export_child_status();
  signal_export_watch_child();
  child_pid = fork();
d927 2
a928 2
    DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
    signal_export_child_pid = child_pid;
d930 9
a938 4
    /* Busy wait, is there a better way to do this? */
    while (check_export_child_status() == 0);
    signal_export_unwatch_child();
    switch (read_export_child_status()) {
a1246 3

  /* No exportFn in progress right now */
  signal_export_unwatch_child();
@


1.32
log
@Disable interrupt handling except when a handler is defined.
@
text
@d21 3
d425 1
a425 1
static inline void die_in_fatal_signal_handler(char const *message)
d1133 1
a1133 1
static inline void signal_start_timer(void)
d1140 1
a1140 1
static inline unsigned int signal_set_timer(unsigned int interval)
d1156 1
a1156 1
static inline void signal_update_windows(unsigned int interval)
d1159 2
a1160 1
    if (window_updates_on)
d1162 2
a1163 1
    window_update_remaining = window_update_interval;
d1166 1
d1169 1
a1169 1
static inline void signal_do_timer(unsigned int interval)
d1172 1
a1172 1
  signal_update_windows(residue);
d1194 2
a1195 1
  signal_update_windows (current_interval);
d1259 1
a1259 1
static inline word* copy_code(char* start, char* finish)
d1269 1
a1269 1
static inline void copy_codes(void)
d1285 1
a1285 1
static inline void establish_signal_table(void)
@


1.31
log
@Getting rid of sm_interface().
@
text
@d21 3
d307 38
a379 16
static int check_sigaction (int sig, struct sigaction *act)
{
  int result = sigaction (sig,act,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  return result;
}


d388 1
a388 7
      struct sigaction act;

      act.sa_handler = signal_ml_handler;
      sigemptyset(&act.sa_mask);
      act.sa_flags = SA_ONSTACK | SA_SIGINFO;

      return (check_sigaction (sig,&act));
d400 1
a400 7
      struct sigaction act;

      act.sa_handler = SIG_DFL;
      sigemptyset(&act.sa_mask);
      act.sa_flags = SA_ONSTACK;

      return (check_sigaction (sig,&act));
a409 12

static int restore_default_signal_handler(int signal)
{
  struct sigaction new_action;
  new_action.sa_handler= SIG_DFL;
  sigemptyset(&new_action.sa_mask);
  new_action.sa_flags= 0;
  return sigaction(signal, &new_action, (struct sigaction *)0);
}



a421 2


a428 2


a499 1

a503 5
  struct sigaction act;

  act.sa_handler = handle_fatal_signal;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;
d505 1
a505 2
  
  return (sigaction(sig,&act,NULL));
d938 2
a939 9
  struct sigaction act;

  act.sa_handler = signal_child_handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_SIGINFO;
  signal_license_child_pid = 0; /* Avoid random values here */
  if(sigaction(SIGCHLD, &act, NULL) == -1)
    error("Unable to set signal handler for SIGCHLD.  "
	  "sigaction set errno to %d.", errno);
d1097 16
a1284 1
  signal_handled[SIGINT]    = SIGNAL_HANDLED_IN_C;	/* interrupt */
a1291 1

a1292 1
  struct sigaction act;
d1296 12
a1308 1

a1313 8
  /* establish interrupt handler */
  act.sa_handler = signal_interrupt_handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;
  if(sigaction(SIGINT, &act, NULL) == -1)
    error("Unable to set interrupt signal handler.  "
          "sigvec set errno to %d.", errno);

d1315 2
a1316 8

  act.sa_handler = signal_integer_exception_handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;

  if(sigaction(SIGEMT, &act, NULL) == -1)
    error("Unable to set integer exception handler.  "
          "sigaction set errno to %d.", errno);
a1318 1

d1321 2
d1324 2
a1325 15
  act.sa_handler = signal_real_exception_handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;
  
  if(sigaction(SIGFPE, &act, NULL) == -1)
    error("Unable to set real exception handler.  "
          "sigaction set errno to %d.", errno);

  act.sa_handler = signal_interval_alarm;
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;

  sigemptyset(&act.sa_mask);
  sigaddset(&act.sa_mask,SIGVTALRM);

  if(sigaction(SIGVTALRM, &act, NULL) == -1)
a1327 13
  /* Initialise the signal stack */

  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack.");

  ss.ss_sp = signal_stack;
  ss.ss_size = SIGNAL_STACK_SIZE;
  ss.ss_flags = 0;

  if(sigaltstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigaltstack set errno to %d).",
	  errno);

a1328 1

a1331 1

@


1.30
log
@fix so that the termination of the final thread due to a fatal
signal returns a non-zero exit status.  Also that a fatal signal
caught in a fatal signal handler kills the thread rather than
the whole of MLWorks (unless it is the last thread of course).
@
text
@d21 6
d164 1
a973 2
  mlval global, filename;

d981 1
a981 2
    switch(errno)
      {
a984 1

d987 27
a1013 9
		       "Insufficient memory to fork licensing process");

      default:
      {
	char error_message[200];
	sprintf(error_message, "fork() returned an unexpected error code %d", errno);
	exn_raise_string(perv_exn_ref_save, error_message);
      }
    }
d1015 18
a1032 74
    if (child_pid == 0) {
      /* The child process */
      filename = FIELD(argument, 0);
      image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
      declare_root(&filename);

      global = global_pack();
      declare_root(&global);

      {
	mlval old_message_level = MLSUB(gc_message_level,0);
	clear_handlers(); /* Don't follow the signal handlers */
	clear_thread_roots(); /* Don't follow roots in ml_state etc */
	MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
	MLUPDATE(gc_message_level,0,MLINT(-1));
	/* now do big garbage collections, without scanning the ML stack */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	(void) sm_interface(SM_PROMOTE_ALL, 0, MLUNIT); /* merge all gens */
	MLUPDATE(gc_message_level,0,MLINT(-1));		/* turn on messages */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	MLUPDATE(gc_message_level,0,old_message_level);
      }

      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);

      if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
	switch(errno)
	  {
	  case EIMPL:
	    exit(EIMPL);
	    error("Function save not implemented");

	  case EIMAGEWRITE:
	    exit(EIMAGEWRITE);
	    error("Error writing opened image file");

	  case EIMAGEOPEN:
	    exit(EIMAGEOPEN);
	    error("Unable to open image file");

	  default:
	    exit(errno ? errno : -1);
	    error("Unexpected error from exportFn");
	  }

      exit(0);
    } else {
      /* The parent process */
      DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
      signal_export_child_pid = child_pid;
      /* Now wait for the child to complete, and get its return status */
      /* Busy wait, is there a better way to do this? */
      while (check_export_child_status() == 0);
      signal_export_unwatch_child();
      switch (read_export_child_status()) {
      case 0:
	break;
      case EIMPL:
	exn_raise_string(perv_exn_ref_save, "Function save not implemented");

      case EIMAGEWRITE:
	exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
	exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
	exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
      }
      return MLUNIT; /* Should later change to return to MLWorks */
d1034 1
@


1.29
log
@handle_fatal_signal: ensure that it does not get caught in a loop
if a fatal signal occurs while handling a fatal signal.
@
text
@d21 4
d230 2
d378 2
a379 2
      act.sa_flags = 0;
      
d391 1
a391 1
static void install_default_fatal_signal_handlers(void)
d397 24
a420 4
  if ((sigaction(SIGILL,  &new_action, (struct sigaction *)0) != 0)
  ||  (sigaction(SIGBUS,  &new_action, (struct sigaction *)0) != 0)
  ||  (sigaction(SIGSEGV, &new_action, (struct sigaction *)0) != 0))
    error_without_alloc("Could not install default fatal signal handlers");
d424 1
d429 2
a430 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Corrupt threads.  Dying ...\n");
d432 5
a436 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Fatal signal raised in fatal signal handler!  Dying ...\n");
a447 6
    if (in_GC) {
      install_default_fatal_signal_handlers();
      error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	    signal_name, sig, info->si_code);
    }
  
d453 2
a454 13
      void (*old_messager_function)(const char * message) = messager_function;
      messager_function = NULL;
      message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	       signal_name, sig, info->si_code, global_state.in_ML? "" : "not ");
      backtrace ((struct stack_frame *)CONTEXT_SP(context),
	       CURRENT_THREAD, max_backtrace_depth);
      messager_function = old_messager_function;
      SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
      if (global_state.in_ML) {
	CONTEXT_PC(context) = (int) stub_c+CODE_OFFSET;
	CONTEXT_NPC(context) = (int) stub_c+CODE_OFFSET+4;
	CONTEXT_ARG(context) = MLUNIT;
	CONTEXT_REG(context, O1) = (int)signal_thread_suicide_stub+POINTER;
d456 21
a476 2
	CONTEXT_PC(context) = (int)thread_suicide;
	CONTEXT_NPC(context) = (int)thread_suicide+4;
a477 5
      /* to reduce the race window the following should be near the
       * end of thread_suicide.  However, that entails putting it in
       * the end of the asm routine change_thread, so for simplicity it
       * is left here. */
      CURRENT_THREAD->in_fatal_signal_handler= 0;
d506 1
a506 1
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C;
@


1.28
log
@Add timer-triggered window updates.
@
text
@d21 3
d384 14
d401 24
a424 10
  const char *signal_name = name_that_signal (sig);
  mlval handler = THREAD_ERROR_HANDLER(CURRENT_THREAD);
  flush_windows();

  DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

  if (in_GC) {
    error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	  signal_name, sig, info->si_code);
  }
d426 2
a427 2
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,info,context);
d429 7
a435 7
  if (handler == MLUNIT) {
    /* there is no handler; print a message and kill this thread */
    void (*old_messager_function)(const char * message) = messager_function;
    messager_function = NULL;
    message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	     signal_name, sig, info->si_code, global_state.in_ML? "" : "not ");
    backtrace ((struct stack_frame *)CONTEXT_SP(context),
d437 16
a452 7
    messager_function = old_messager_function;
    SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
    if (global_state.in_ML) {
      CONTEXT_PC(context) = (int) stub_c+CODE_OFFSET;
      CONTEXT_NPC(context) = (int) stub_c+CODE_OFFSET+4;
      CONTEXT_ARG(context) = MLUNIT;
      CONTEXT_REG(context, O1) = (int)signal_thread_suicide_stub+POINTER;
d454 13
a466 13
      CONTEXT_PC(context) = (int)thread_suicide;
      CONTEXT_NPC(context) = (int)thread_suicide+4;
    }
  } else {
    CONTEXT_ARG(context) = MLINT(sig);
    CONTEXT_REG(context,O1) = handler;
    /* if there is a handler, skip to it: */
    if (global_state.in_ML) {
      CONTEXT_PC(context) = FIELD(handler,0)+CODE_OFFSET;
      CONTEXT_NPC(context) = FIELD(handler,0)+CODE_OFFSET+4;
    } else {
      CONTEXT_PC(context) = (int)callml;
      CONTEXT_NPC(context) = (int)callml+4;
d471 1
d485 1
@


1.27
log
@Added a comment noting that the sa_handler rather than sa_sigaction
field is being set and the reasons why this is.
@
text
@d21 4
d1087 2
a1088 1
static struct itimerval interval_timer;
d1094 3
d1100 3
a1102 3
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, NULL) == -1)
    message("Warning: Unable to set interval timer (setitimer set errno "
	    "to %d).  Stack profiling and preemption will not occur.", errno);
d1105 1
a1105 1
static inline void signal_set_timer(unsigned int interval)
d1107 2
d1115 20
d1156 1
d1164 1
a1164 1
  signal_set_timer(profiling_interval);
d1169 1
a1169 1
  signal_set_timer(0);
d1171 6
a1176 1
    signal_set_timer(thread_preemption_interval);
d1184 1
a1184 1
    signal_set_timer(thread_preemption_interval);
d1189 8
a1196 2
  if (!profile_on)
    signal_set_timer(0);
d1202 14
@


1.26
log
@SIGCHLD handler problems under /bin/sh again
@
text
@d10 8
a17 1
 * 
d21 3
@


1.25
log
@handle_fatal_signal: fix so that NPC is set as well as PC.
@
text
@d14 3
d723 7
d736 1
a736 1
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
@


1.24
log
@Extensions to event handling for non-signal events.
@
text
@d14 3
d398 1
a398 1
      CONTEXT_PC(context) = (int)thread_suicide+4;
d406 1
a406 1
      CONTEXT_PC(context) = FIELD(handler,0)+CODE_OFFSET+4;
d409 1
a409 1
      CONTEXT_PC(context) = (int)callml+4;
@


1.23
log
@Update best-before date to 1996-07-01.
@
text
@d14 3
d198 8
a259 41
/* reserving and releasing signals */

static int reserved[NR_SIGNALS];

extern int signal_reserve(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 1;
  return 0;
}
    
extern int signal_release(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (!reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 0;
  return 0;
}  

extern int signal_reserved(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  return (reserved[sig]);
}

d268 13
a280 1
static void record_event (ucontext_t *context)
a284 3

  /* always set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
a294 2
  struct event *event;

d298 2
a299 14
    event = alloc(sizeof(struct event), "Couldn't allocate event");
    event->type = SIGNAL;
    event->the.signal = sig;

    event->forward = &event_queue;
    event->back = event_queue.back;
    event->forward->back = event;
    event->back->forward = event;
    ++event_queue.the.sentinel_count;

    DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	       sig, event_queue.the.sentinel_count);

    record_event(context);
d323 9
a331 1
  struct sigaction act;
d333 4
a336 5
  act.sa_handler = signal_ml_handler;
  sigemptyset(&act.sa_mask);
  act.sa_flags = SA_ONSTACK | SA_SIGINFO;

  return (check_sigaction (sig,&act));
d341 14
a354 7
  struct sigaction act;

  act.sa_handler = SIG_DFL;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;

  return (check_sigaction (sig,&act));
d375 3
d420 1
a424 14
/* == Stack overflow support ==
 * 
 * When we exceed the user-specified number of stack blocks, we want
 * to signal into the ML debugger. This is the portable interface:
 * self_signal (signal_stack_overflow) is called. */

int signal_stack_overflow = SIGUSR1;
int signal_interrupt = SIGINT;

extern void self_signal (int sig)
{
  kill (getpid(),(int) sig);
}

d467 3
d554 3
d722 4
d1035 19
d1090 3
d1098 3
a1100 1
    record_event(context);
d1167 14
d1188 4
d1195 8
a1202 3
/*
  signal_license_child_pid = 0;
*/
a1256 11

  /* these signals are reserved to the runtime */

  signal_reserve (SIGILL);	/* fatal */
  signal_reserve (SIGBUS);	/* fatal */
  signal_reserve (SIGSEGV);	/* fatal */
  signal_reserve (SIGEMT);	/* integer exceptions */
  signal_reserve (SIGFPE);	/* real exceptions */
  signal_reserve (SIGVTALRM);	/* profiling */
  signal_reserve (SIGINT);	/* interrupt */
  signal_reserve (SIGUSR1);	/* stack overflow */
@


1.22
log
@Improve the full GC we do during function export.
@
text
@d14 3
d725 1
a725 2
#define BEST_BEFORE	820454400	/* 1996-01-01 00:00 */
			
@


1.21
log
@Add stuff to handle the temporary child process created for exportFn
@
text
@d14 3
d934 5
a938 1
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
@


1.20
log
@Change to profiler interface.
@
text
@d14 3
d118 4
d722 1
a722 1
/* The process ID of the child */
d726 8
d735 1
d737 1
a737 1
static void signal_license_child_handler
d741 8
d750 3
a752 2
  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig, info->si_code);
  DIAGNOSTIC(4, "         child = %d)", signal_license_child_pid, 0);
d757 1
a757 2
  if (signal_license_child_pid != 0) {
  
d762 1
a762 1
    
d766 1
a766 1
    
d770 1
a770 1
    
d773 1
a773 1
	
d781 37
a817 1
	      "   telephone:        +44 223 872522");
d819 3
d823 16
a838 1
}  
d865 1
a865 1
  act.sa_handler = signal_license_child_handler;
d867 2
a868 1
  act.sa_flags = 0;
d874 116
d1162 6
@


1.19
log
@Update best-before date.
@
text
@d14 3
d889 1
a889 1
    profile_scan((struct stack_frame *) CONTEXT_SP(context));
@


1.18
log
@Fix minor thinko in fatal_signal.
@
text
@d14 3
d709 1
a709 1
#define BEST_BEFORE	804553200	/* 1995-07-01 00:00 */
@


1.17
log
@Improve fatal signal support.
@
text
@d14 3
d391 1
a391 1
      CONTEXT_REG(context, O1) = (int)signal_thread_suicide_stub+RECORD;
@


1.16
log
@If signal_ml_handler is called while we are waiting for an X event,
the runtime just prints a message.  This avoids problems with pointer
grabs in X callbacks.
@
text
@d14 5
d358 3
a360 1
static void handle_die_gracefully
d364 2
a365 1
  void (*old_messager_function)(const char * message) = NULL;
d373 32
a404 10
  old_messager_function = messager_function;
  messager_function = NULL;
  message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	   signal_name, sig, info->si_code, global_state.in_ML? "" : "not ");
  backtrace ((struct stack_frame *)CONTEXT_SP(context),
	     CURRENT_THREAD, max_backtrace_depth);
  messager_function = old_messager_function;
  SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
  CONTEXT_PC(context) = (int) thread_suicide;
  CONTEXT_NPC(context) = (int) thread_suicide+4;
d413 1
a413 1
  act.sa_handler = handle_die_gracefully;
@


1.15
log
@Add thread_preemption_pending.
@
text
@d14 3
d100 1
d289 1
a289 1
  struct event *event = alloc(sizeof(struct event), "Couldn't allocate event");
d291 12
a302 2
  event->type = SIGNAL;
  event->the.signal = sig;
d304 2
a305 5
  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;
d307 2
a308 4
  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);

  record_event(context);
@


1.14
log
@Changing underflow behaviour in matherr
@
text
@d14 3
d843 2
a844 1
  if (thread_preemption_on)
d846 1
@


1.13
log
@Make fatal signal messages come out on stderr.
@
text
@d14 3
d401 14
a414 13

  in_ml_fpe = 0;
  if(strcmp(problem, "log") == 0)
    exn_raise(perv_exn_ref_ln);
  else if(strcmp(problem, "fabs") == 0)
    exn_raise(perv_exn_ref_abs);
  else if(strcmp(problem, "exp") == 0)
    exn_raise(perv_exn_ref_exp);
  else if(strcmp(problem, "sqrt") == 0)
    exn_raise(perv_exn_ref_sqrt);

  message("Warning: Unhandled floating point error in `%s' -- returning %g",
	  problem, e->retval);
d416 1
a416 1
  return(e->retval);
@


1.12
log
@Introduce the threads system.
@
text
@d14 3
d342 1
d350 2
d356 1
@


1.11
log
@Fix interrupted system call problems during child liveness check through pipe
@
text
@d14 3
d86 2
a87 9

/*  
 * This routine is used on the SPARC to set the saved stack limit
 * register on a signal handler's stack to -1 so that when it is
 * restored on return from the signal handler ML enters the signal
 * handling code. It is is interface.S
 */

extern void set_stack_underflow(void);
d258 10
d290 1
a290 2
  CONTEXT_G6(context) = -1;	/* Set g6 register to -1 */
  implicit_vector.interrupt = (word) -1;
d346 7
a352 6
  message ("Intolerable signal %s (%d : %d) received. Backtrace:",
	   signal_name, sig, info->si_code);
  backtrace (stderr,
	     (struct stack_frame *)CONTEXT_SP(context),
	     max_backtrace_depth);
  error ("Dying.");
d426 1
a426 1
  if(is_ml_frame((struct stack_frame *)CONTEXT_SP(context)) == MLUNIT) {
a427 1
      /* message("FP Signal inside fpe, ignoring"); */
a433 1
   
d435 1
a435 1
     /* Check that the instruction type is FPOP */
d437 2
a438 2
     if((instruction & 0xC1F00000) != 0x81A00000) {
       DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
d442 1
a442 1

d507 5
a606 6
  if(is_ml_frame((struct stack_frame *)CONTEXT_SP(context)) == MLUNIT)
  {
    message("Warning: signal %d outside ML -- ignoring", sig);
    return;
  }

d790 9
a798 5
/* == Profiling support ==
 * 
 * We provide a virtual-time alarm, which goes off after a
 * user-specified number of milliseconds. When it goes off, we call
 * profile_scan(), and restart the alarm when it returns. */
d800 2
a801 1
static struct itimerval profiler_timer;
d803 6
a808 2
static void signal_profiler_alarm
  (int sig, siginfo_t *info, ucontext_t *context)
d810 1
d812 4
a815 1
  profile_scan((struct stack_frame *) CONTEXT_SP(context));
d817 1
a817 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
d820 2
a821 1
/* start things off */
d823 2
a824 1
extern void signal_start_profiler_timer(unsigned int interval)
d826 5
a830 1
  struct sigaction act;
d832 2
a833 2
  act.sa_handler = signal_profiler_alarm;
  act.sa_flags = SA_ONSTACK;
d835 1
a835 2
  sigemptyset(&act.sa_mask);
  sigaddset(&act.sa_mask,SIGVTALRM);
d837 4
a840 2
  if(sigaction(SIGVTALRM, &act, NULL) == -1)
    error("Unable to set up profiler signal handler.");
d842 5
a846 8
  profiler_timer.it_value.tv_sec = interval/1000;
  profiler_timer.it_value.tv_usec = (interval%1000)*1000;
  profiler_timer.it_interval.tv_sec = 0;
  profiler_timer.it_interval.tv_usec = 0; /* one shot timer */

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
d849 1
a849 1
/* kill the timer */
d851 1
a851 1
extern void signal_stop_profiler_timer(void)
d853 3
a855 1
  struct sigaction act;
d857 5
a861 3
  act.sa_handler = SIG_DFL;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0;
d863 3
a865 18
  profiler_timer.it_value.tv_sec = profiler_timer.it_value.tv_usec = 0;
  profiler_timer.it_interval.tv_sec = profiler_timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
  {
    message("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    act.sa_handler = SIG_IGN;

    if(sigaction(SIGVTALRM, &act, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigvec set errno to %d).",
	    errno);
  }
  if(sigaction(SIGVTALRM, &act, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message("Warning: Unable to reset alarm signal handler (sigvec set errno "
	    "to %d).", errno);
d926 9
d938 1
a938 1
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack in profiler.");
@


1.10
log
@Fix diagnostic message.
@
text
@d14 3
d732 2
d741 1
d776 7
a782 3
  if(read(pipefd[0], &dummy, 1))
    error("Licensing process managed to read from pipe.");
  
@


1.9
log
@Fix licensing signal handling.
@
text
@d14 3
d773 1
a773 1
  DIAGNOSTIC(2,"child: parent died -- exiting",0);
@


1.8
log
@Amend best-before date to 1st July.
Also fix Harlequin's telephone number.
Also make license signal handler run on the current stack.
@
text
@d14 5
d660 2
d663 25
a687 25
  do
    available = waitpid(signal_license_child_pid,
			&status, WNOHANG | WUNTRACED);
  while(available == -1 && errno == EINTR);
  
  if(available == -1)
    error("Unable to determine status of licensing process.  "
	  "waitpid set errno to %d.", errno);

  /* If available is non zero then something happened to the child.  If it */
  /* is zero then the child status changed, but changed back (for example, */
  /* both child and parent were suspended from the shell and restarted. */
  
  if(available)
  {
    DIAGNOSTIC(4, "available %d status 0x%02X", available, status);

    if(WIFSTOPPED(status))
      error("Licensing process was stopped with signal %d", WSTOPSIG(status));
    else if(WIFSIGNALED(status))
      error("Licensing process was terminated with signal %d", WTERMSIG(status));
    else
      error("Your license has expired.  Contact MLWorks customer support:\n"
	    "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	    "   telephone:        +44 223 872522");
d689 1
a689 1
}
d692 1
a692 1

d699 1
a699 1
  DIAGNOSTIC(4, "child: checking license at time %ld", now, 0);
d702 3
a704 4
    message("child: WARNING: time() returned -1");
  else if (now >= BEST_BEFORE)
  {
    DIAGNOSTIC(1, "child: license expired at time %ld", now, 0);
d752 1
a752 1
  
d770 1
a770 1
  DIAGNOSTIC(2, "child: parent died -- exiting", 0, 0);
@


1.7
log
@Put in declaration for set_stack_underflow().
@
text
@d14 3
d636 1
a636 1
#define BEST_BEFORE	788918400	/* 1995-01-01 */
d712 1
a712 1
  act.sa_flags = SA_ONSTACK;
@


1.6
log
@Add cache flushing.
@
text
@d14 3
d69 9
@


1.5
log
@Add cast to avoid type warning.
@
text
@d14 3
d65 1
d509 3
a511 1
    word overwrite;
d542 1
a542 1
    overwrite =
d558 1
a558 1
      *gc_trap_ret_leaf_overwrite = overwrite;
d562 1
a562 1
      *gc_trap_ret_overwrite = overwrite;
d564 2
@


1.4
log
@Update best-before to 1995-Jan-01.
@
text
@d14 3
d255 1
a255 1
  implicit_vector.interrupt = -1;
@


1.3
log
@Make sure signal handlers get executed on the signal stack.
@
text
@d14 3
d610 2
a611 1
#define BEST_BEFORE	781024732	/* 1994-10-01 sometime */
@


1.3.1.1
log
@branched from 1.3
@
text
@a13 3
 * Revision 1.3  1994/08/11  14:30:03  nickh
 * Make sure signal handlers get executed on the signal stack.
 *
@


1.2
log
@Add GC trap handling.
@
text
@d14 3
d682 1
a682 1
  act.sa_flags = 0;
d851 1
a851 1
  act.sa_flags = SA_ONSTACK;
d864 1
a864 1
  act.sa_flags = SA_ONSTACK;
@


1.1
log
@new file
@
text
@d13 3
a15 1
 * $Log: $
d17 1
d52 60
d449 9
a457 5
 *  This function is the handler for the emulation trap signals.  If
 *  called while in ML it examines the instruction which caused the
 *  exception in order to determine which ML exception to raise.  The
 *  signal context is updated in order to raise the exception when the
 *  handler returns.  */
d464 88
d582 1
a582 1
  CONTEXT_PC(context) = (int)ml_raise+4;
d809 28
d880 4
d900 13
@
