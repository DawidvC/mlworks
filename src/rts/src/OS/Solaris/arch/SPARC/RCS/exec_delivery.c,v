head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.1
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_MM_adapt:1.4.12
	MLWorks_20m1_1997_10_23:1.4
	MLWorks_11r1:1.4.9.1.1.1.1
	MLWorks_workspace_97:1.4.11
	MLWorks_dt_wizard:1.4.10
	MLWorks_11c0_1997_09_09:1.4.9.1.1.1
	MLWorks_10r3:1.4.9.1.3
	MLWorks_10r2_551:1.4.9.1.2
	MLWorks_11:1.4.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.9.1
	MLWorks_20m0_1997_06_20:1.4
	MLWorks_1_0_r2c2_1997_06_14:1.4.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.9
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MM_ML_release_korma_1997_04_01:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.7.1.1
	MLWorks_gui_1996_12_18:1.4.8
	MLWorks_1_0_Win32_1996_12_17:1.4.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.4.1
	JFHrts:1.4.6
	MLWorks_1_0_Irix_1996_11_28:1.4.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.5
	MLWorks_1_0_Unix_1996_11_14:1.4.4
	MLWorks_Open_Beta2_1996_10_11:1.4.3
	MLWorks_License_dev:1.4.2
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.4
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.4
	MLWorks_Beta_1996_06_05:1.4
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4;
locks; strict;
comment	@ * @;


1.6
date	98.04.14.12.47.19;	author mitchell;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	97.11.26.10.39.55;	author johnh;	state Exp;
branches;
next	1.4;

1.4
date	96.05.01.08.52.20;	author nickb;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1
	1.4.8.1
	1.4.9.1
	1.4.10.1
	1.4.11.1
	1.4.12.1;
next	1.3;

1.3
date	96.02.14.15.14.11;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.09.26.15.42.14;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	95.09.26.15.17.26;	author jont;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.23.40;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.10.07.16.13.53;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.10.17.11.33.19;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.11.14.12.59.02;	author hope;	state Exp;
branches
	1.4.4.1.1.1;
next	;

1.4.4.1.1.1
date	96.11.28.15.09.01;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	96.11.22.18.16.45;	author hope;	state Exp;
branches;
next	;

1.4.6.1
date	96.12.17.10.03.29;	author hope;	state Exp;
branches;
next	;

1.4.7.1
date	96.12.17.17.55.06;	author hope;	state Exp;
branches
	1.4.7.1.1.1;
next	;

1.4.7.1.1.1
date	97.02.24.11.46.15;	author hope;	state Exp;
branches;
next	;

1.4.8.1
date	96.12.18.09.49.42;	author hope;	state Exp;
branches;
next	;

1.4.9.1
date	97.05.12.10.42.07;	author hope;	state Exp;
branches
	1.4.9.1.1.1
	1.4.9.1.2.1
	1.4.9.1.3.1;
next	;

1.4.9.1.1.1
date	97.07.28.18.29.43;	author daveb;	state Exp;
branches
	1.4.9.1.1.1.1.1;
next	;

1.4.9.1.1.1.1.1
date	97.10.07.11.55.33;	author jkbrook;	state Exp;
branches;
next	;

1.4.9.1.2.1
date	97.09.08.17.22.42;	author daveb;	state Exp;
branches;
next	;

1.4.9.1.3.1
date	97.09.09.14.18.46;	author daveb;	state Exp;
branches;
next	;

1.4.10.1
date	97.09.10.19.38.18;	author brucem;	state Exp;
branches;
next	;

1.4.11.1
date	97.09.11.21.06.00;	author daveb;	state Exp;
branches;
next	;

1.4.12.1
date	97.10.31.13.49.05;	author nickb;	state Exp;
branches;
next	;

1.6.1.1
date	99.04.01.18.04.41;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.6
log
@[Bug #50061]
Reverse treatment of command-line argument passing for executables with embedded image
@
text
@/*  ==== EXECUTABLE FILE DELIVERY AND EXECUTION ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This code deals with delivery executables rather than heap images.
 *  There are two halves to this. Firstly, writing such an object,
 *  and secondly, rerunning it
 *
 *  $Log: src:OS:Solaris:arch:SPARC:exec_delivery.c,v $
 * Revision 1.5  1997/11/26  10:39:55  johnh
 * [Bug #30134]
 * Extra arg needed in save_executable (not used here though).
 *
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
 * Revision 1.3  1996/02/14  15:14:11  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.2  1995/09/26  15:42:14  jont
 * Ensure existing ML heap sections are ignored when producing a new executable
 *
 * Revision 1.1  1995/09/26  15:17:26  jont
 * new unit
 *
 */

#include <libelf.h>
#include <fcntl.h>
#include <unistd.h>
#include <stdlib.h>
#include <errno.h>

#include "exec_delivery.h"
#include "gc.h"
#include "diagnostic.h"
#include "image.h"
#include "main.h"
#include "utils.h"

/* A type for an ml heap elf section */

#define	SHT_ML_HEAP (SHT_LOUSER | 0x1)

#define PRINT_PHDR 0
#if PRINT_PHDR
static void print_phdr(Elf32_Phdr *phdr)
{
  printf("phdr->p_type = 0x%x\n", phdr->p_type);
  printf("phdr->p_offset = 0x%x\n", phdr->p_offset);
  printf("phdr->p_vaddr = 0x%x\n", phdr->p_vaddr);
  printf("phdr->p_paddr = 0x%x\n", phdr->p_paddr);
  printf("phdr->p_filesz = 0x%x\n", phdr->p_filesz);
  printf("phdr->p_memsz = 0x%x\n", phdr->p_memsz);
  printf("phdr->p_flags = 0x%x\n", phdr->p_flags);
  printf("phdr->p_align = 0x%x\n", phdr->p_align);
}
#endif

static void copy_shdr(Elf32_Shdr *shdr_in, Elf32_Shdr *shdr_out)
{
  shdr_out->sh_name = shdr_in->sh_name; /* Index into string table */
  shdr_out->sh_type = shdr_in->sh_type; /* Same section type */
  shdr_out->sh_flags = shdr_in->sh_flags; /* Same section flags */
  shdr_out->sh_addr = shdr_in->sh_addr; /* Same section addr */
  /* offset and size done by elf_update */
  shdr_out->sh_link = shdr_in->sh_link; /* Same section link */
  shdr_out->sh_info = shdr_in->sh_info; /* Same section info */
  shdr_out->sh_addralign = shdr_in->sh_addralign; /* Same section addralign */
  shdr_out->sh_entsize = shdr_in->sh_entsize; /* Same section entsize */
}

static void copy_data(Elf_Data *data_in, Elf_Data *data_out)
{
  data_out->d_buf = data_in->d_buf;
  data_out->d_type = data_in->d_type;
  data_out->d_size = data_in->d_size;
  data_out->d_off = data_in->d_off;
  data_out->d_align = data_in->d_align;
  data_out->d_version = elf_version(EV_CURRENT);
}

static void free_string_buffer(void *buffer)
{
  if (buffer != NULL) {
    free(buffer);
  } else {
    DIAGNOSTIC(1, "string table write not done", 0, 0);
  }
}

#define ML_HEAP_SECTION "ML HEAP"

mlval save_executable(char *to, mlval heap, int console_app)
/* Save a re-executable version of the current system */
/* returns MLUNIT if ok, MLERROR on error of some sort (with errno set) */
{
  int fd_in, fd_out;
  Elf *elf_in, *elf_out;
  Elf32_Ehdr *ehdr_in, *ehdr_out;
  Elf32_Phdr *phdr_in, *phdr_out;
  size_t count;
  Elf_Scn *scn_in, *scn_out;
  Elf32_Shdr *shdr_in, *shdr_out;
  Elf_Data *data_in, *data_out;
  int sec_names = 0, new_sec_names = 0;
  void *string_table_buffer = NULL;
  int ml_heap_name = 0;

  fd_in = open(runtime, O_RDONLY);
  if (fd_in < 0) {
    errno = EIMAGEOPEN;
    return MLERROR;
  }
  fd_out = open(to, O_RDWR | O_TRUNC | O_CREAT, 0770);
  if (fd_out < 0) {
    errno = EIMAGEOPEN;
    close(fd_in);
    return MLERROR;
  }
  /* Reset ELF error number */
  elf_errno();
  /* Check ELF version ... */
  if (elf_version(EV_CURRENT) == EV_NONE) {
    close(fd_in);
    close(fd_out);
    return MLERROR;
  };
  /*  Begin ELF processing of file - allocate ELF descriptor
   *  This also initially allocates internal memory used for ELF
   *  Also start for the output file
   */
  elf_in = elf_begin(fd_in, ELF_C_READ, (Elf *)NULL);
  elf_out = elf_begin(fd_out, ELF_C_WRITE, (Elf *)NULL);
  /* Now copy the entirity of the input executable to the output */
  /* except for any sections already containing ml heaps */
  /* First find out how many sections in the input */
  ehdr_in = elf32_newehdr(elf_in);
  count = ehdr_in->e_phnum; /* How many headers */
  ehdr_out = elf32_newehdr(elf_out);
  memcpy(ehdr_out->e_ident, ehdr_in->e_ident, EI_NIDENT); /* Identify */
  ehdr_out->e_type = ehdr_in->e_type; /* File type as before */
  ehdr_out->e_machine = ehdr_in->e_machine; /* Machine as before */
  ehdr_out->e_version = elf_version(EV_CURRENT);
  ehdr_out->e_entry = ehdr_in->e_entry; /* Entry as before */
  ehdr_out->e_ehsize = sizeof(Elf32_Ehdr); /* size of the Elf header */
  /* phoff and shoff are calculated by elf_update */
  ehdr_out->e_flags = ehdr_in->e_flags; /* Flags as before */
  ehdr_out->e_phentsize = sizeof(Elf32_Phdr); /* size of the program header */
  ehdr_out->e_phnum = ehdr_in->e_phnum; /* Phnum as before */
  ehdr_out->e_shentsize = sizeof(Elf32_Shdr); /* size of the section header */
  DIAGNOSTIC(3, "Section table names in section %d", ehdr_in->e_shstrndx, 0);
  ehdr_out->e_shstrndx = ehdr_in->e_shstrndx; /* Shstrndx as before */
  /* Ehdr all done bar shoff, which requires a file offset to be calculated */
  phdr_in = elf32_getphdr(elf_in); /* The previous program header */
  phdr_out = elf32_newphdr(elf_out, count); /* A new program header */
  /* Copy the entire set of program headers over */
  memcpy(phdr_out, phdr_in, count * sizeof(Elf32_Phdr));
  /* Copy all output sections */
  scn_in = (Elf_Scn *)NULL;
  while((scn_in = elf_nextscn(elf_in, scn_in)) != NULL) {
    /* Make sure we ignore existing ML heap sections, we don't want to copy them */
    sec_names++;
    shdr_in = elf32_getshdr(scn_in);
    data_in = elf_getdata(scn_in, (Elf_Data *)NULL);
    if (shdr_in->sh_type != SHT_ML_HEAP) {
      new_sec_names++;
      scn_out = elf_newscn(elf_out);
      shdr_out = elf32_getshdr(scn_out);
      data_out = elf_newdata(scn_out);
      copy_shdr(shdr_in, shdr_out);
      copy_data(data_in, data_out);
      if (sec_names == ehdr_in->e_shstrndx) {
	if (shdr_in->sh_type == SHT_STRTAB) {
	  /* Found the string table of section names */
	  size_t data_size = data_in->d_size;
	  size_t extra_data_size = strlen(ML_HEAP_SECTION) + 1;
	  size_t new_data_size = data_size + extra_data_size;
	  string_table_buffer = malloc(new_data_size);
	  memcpy(string_table_buffer, data_in->d_buf, data_size);
	  memcpy(((char *)string_table_buffer) + data_size, ML_HEAP_SECTION, extra_data_size);
	  data_out->d_size = new_data_size;
	  data_out->d_buf = string_table_buffer;
	  ml_heap_name = data_size;
	  ehdr_out->e_shstrndx = new_sec_names; /* Index in the new file */
	} else {
	  error("Section shstrndx (%d) is not a string table\n", sec_names);
	}
      }
    } else {
      DIAGNOSTIC(1, "Ignoring existing ML HEAP section", 0, 0);
    }
  }
  /* Now build the ML heap section */
  scn_out = elf_newscn(elf_out);
  shdr_out = elf32_getshdr(scn_out);
  data_out = elf_newdata(scn_out);
  /* Set up the final header entry */
  shdr_out->sh_name = ml_heap_name; /* Name in string table */
  shdr_out->sh_type = SHT_ML_HEAP; /* ML heap section */
  shdr_out->sh_flags = 0; /* No special,flags */
  shdr_out->sh_addr = 0; /* Not memory mapped */
  /* offset and size done by elf_update */
  shdr_out->sh_link = SHN_UNDEF; /* Same section link */
  shdr_out->sh_info = 0; /* No extra info */
  shdr_out->sh_addralign = 0; /* No alignment constraints */
  shdr_out->sh_entsize = 0; /* No fixed size entries */
  /* Set up the final data section */
  if (memory_image_save_size(heap, &data_out->d_size) == MLERROR) {
    /* Calculate required size */
    elf_end(elf_out);
    elf_end(elf_in);
    close(fd_in);
    close(fd_out);
    free_string_buffer(string_table_buffer);
    return MLERROR;
  };
  data_out->d_buf = malloc(data_out->d_size);
  data_out->d_type = ELF_T_BYTE;
  /*I think Elf fills in d_off */
  data_out->d_align = 0; /* No special alignment */
  data_out->d_version = elf_version(EV_CURRENT);
  if (memory_image_save(heap, data_out->d_buf, data_out->d_size, &data_out->d_size)) {
    elf_end(elf_out);
    elf_end(elf_in);
    free(data_out->d_buf);
    close(fd_in);
    close(fd_out);
    free_string_buffer(string_table_buffer);
    return MLERROR;
  };
  elf_update(elf_out, ELF_C_WRITE);
  elf_end(elf_out);
  elf_end(elf_in);
  free(data_out->d_buf);
  close(fd_in);
  close(fd_out);
  free_string_buffer(string_table_buffer);
  return MLUNIT;
}

int load_heap_from_executable(mlval *heap, const char *runtime, int just_check)
/* Reload the heap from within the executable, or just check if there is one */
/* This returns 0 if done (in which case we shouldn't try to load another heap) */
/* 1 if we failed to find such a section (in which case we continue as before) */
/* otherwise an error has occurred and errno is set */
{
  int fd;
  Elf *elf;
  Elf32_Ehdr *ehdr;
  Elf_Scn *scn;
  Elf32_Shdr *shdr;
  Elf_Data *data = NULL;
  void *heap_data = NULL;
  size_t heap_size = 0;

  fd = open(runtime, O_RDONLY);
  if (fd < 0) {
    errno = EIMAGEOPEN;
    return 2;
  }
  /* Reset ELF error number */
  elf_errno();
  /* Check ELF version ... */
  if (elf_version(EV_CURRENT) == EV_NONE) {
    close(fd);
    return 1;
  };
  /*  Begin ELF processing of file - allocate ELF descriptor
   *  This also initially allocates internal memory used for ELF
   */
  elf = elf_begin(fd, ELF_C_READ, (Elf *)NULL);
  /* Get ELF header ... */
  ehdr = elf32_getehdr(elf);
  scn = (Elf_Scn *)NULL;
  /* Find ml heap section. It has type SHT_ML_HEAP */ 
  while((scn = elf_nextscn(elf,scn)) != NULL) {
    shdr = elf32_getshdr(scn);
    if (shdr->sh_type == SHT_ML_HEAP ) {
      data = elf_getdata(scn, (Elf_Data *)NULL);
      if (data->d_type != ELF_T_BYTE) {
	close(fd);
	elf_end(elf);
	DIAGNOSTIC(1, "Error, bad data type %d in ML heap section\n", data-> d_type, 0);
	errno = EIMAGEFORMAT;
	return 2;
      }
      break;
    }
  };
  if (data == NULL) {
    DIAGNOSTIC(1, "No ML heap section found", 0, 0);
    /* Failed to find an ML heap section */
    close(fd);
    elf_end(elf);
    return 1;
  }
  heap_data = data->d_buf;
  heap_size = data->d_size;
  DIAGNOSTIC(1, "Found ML heap with pointer %p and size %d", heap, heap_size);

  if (just_check) {
    close(fd);
    elf_end(elf);
  } else {    
    *heap = memory_image_load(heap_data, heap_size);
    close(fd);
    elf_end(elf);
    if (*heap == MLERROR) {
      /* Something went wrong */
      DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
      return 2;
    }
  }
  return 0;
}

@


1.6.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.6  1998/04/14  12:47:19  mitchell
 * [Bug #50061]
 * Reverse treatment of command-line argument passing for executables with embedded image
 *
@


1.5
log
@[Bug #30134]
Extra arg needed in save_executable (not used here though).
@
text
@d12 4
d244 2
a245 2
int load_heap_from_executable(mlval *heap, const char *runtime)
/* Reload the heap from within the executable */
d303 13
a315 7
  *heap = memory_image_load(heap_data, heap_size);
  close(fd);
  elf_end(elf);
  if (*heap == MLERROR) {
    /* Something went wrong */
    DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
    return 2;
d319 1
@


1.4
log
@Change to save_executable.
@
text
@d12 3
d92 1
a92 1
mlval save_executable(char *to, mlval heap)
@


1.4.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.9.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.4.9.1  1997/05/12  10:42:07  hope
 * branched from 1.4
 *
@


1.4.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.4.9.1  1997/05/12  10:42:07  hope
 * branched from 1.4
 *
@


1.4.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.4.9.1  1997/05/12  10:42:07  hope
 * branched from 1.4
 *
@


1.4.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.4.9.1.1.1  1997/07/28  18:29:43  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.8.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.7.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.7.1.1.1
log
@branched from 1.4.7.1
@
text
@a11 3
 * Revision 1.4.7.1  1996/12/17  17:55:06  hope
 * branched from 1.4
 *
@


1.4.6.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.5.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.4.1.1.1
log
@branched from 1.4.4.1
@
text
@a11 3
 * Revision 1.4.4.1  1996/11/14  12:59:02  hope
 * branched from 1.4
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a11 3
 * Revision 1.4  1996/05/01  08:52:20  nickb
 * Change to save_executable.
 *
@


1.3
log
@Changing ERROR to MLERROR
@
text
@d12 3
d89 1
a89 1
mlval save_executable(mlval argument)
a100 2
  char *to = CSTRING(FIELD(argument, 0));
  mlval heap = FIELD(argument, 1);
@


1.2
log
@Ensure existing ML heap sections are ignored when producing a new executable
@
text
@d12 3
d88 1
a88 1
/* returns MLUNIT if ok, ERROR on error of some sort (with errno set) */
d107 1
a107 1
    return ERROR;
d113 1
a113 1
    return ERROR;
d121 1
a121 1
    return ERROR;
d203 1
a203 1
  if (memory_image_save_size(heap, &data_out->d_size) == ERROR) {
d210 1
a210 1
    return ERROR;
d224 1
a224 1
    return ERROR;
d298 1
a298 1
  if (*heap == ERROR) {
@


1.1
log
@new unit
@
text
@d11 4
a14 1
 *  $Log$
d97 1
a97 1
  int sec_names = 0;
d153 1
a154 3
    scn_out = elf_newscn(elf_out);
    shdr_out = elf32_getshdr(scn_out);
    data_out = elf_newdata(scn_out);
a155 1
    copy_shdr(shdr_in, shdr_out);
d157 23
a179 15
    copy_data(data_in, data_out);
    if (sec_names == ehdr_in->e_shstrndx) {
      if (shdr_in->sh_type == SHT_STRTAB) {
	/* Found the string table of section names */
	size_t data_size = data_in->d_size;
	size_t extra_data_size = strlen(ML_HEAP_SECTION) + 1;
	size_t new_data_size = data_size + extra_data_size;
	string_table_buffer = malloc(new_data_size);
	memcpy(string_table_buffer, data_in->d_buf, data_size);
	memcpy(((char *)string_table_buffer) + data_size, ML_HEAP_SECTION, extra_data_size);
	data_out->d_size = new_data_size;
	data_out->d_buf = string_table_buffer;
	ml_heap_name = data_size;
      } else {
	error("Section shstrndx (%d) is not a string table\n", sec_names);
d181 2
@
