head	1.31;
access;
symbols
	MLW_daveb_inline_1_4_99:1.31.1
	MLWorks_21c0_1999_03_25:1.31
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.29
	MLWorks_20b2c2_1998_06_19:1.29
	MLWorks_20b2_Windows_1998_06_12:1.29
	MLWorks_20b1c1_1998_05_07:1.29
	MLWorks_20b0_1998_04_07:1.29
	MLWorks_20b0_1998_03_20:1.29
	MLWorks_20m2_1998_02_16:1.29
	MLWorks_MM_adapt:1.29.4
	MLWorks_20m1_1997_10_23:1.29
	MLWorks_11r1:1.29.1.1.1.1.1
	MLWorks_workspace_97:1.29.3
	MLWorks_dt_wizard:1.29.2
	MLWorks_11c0_1997_09_09:1.29.1.1.1.1
	MLWorks_10r3:1.29.1.1.3
	MLWorks_10r2_551:1.29.1.1.2
	MLWorks_11:1.29.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.29.1.1
	MLWorks_20m0_1997_06_20:1.29
	MLWorks_1_0_r2c2_1997_06_14:1.29.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.29.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.29.1
	MLWorks_BugFix_1997_04_24:1.29
	MLWorks_1_0_r2_Win32_1997_04_11:1.29
	MLWorks_1_0_r2_Unix_1997_04_04:1.29
	MM_ML_release_korma_1997_04_01:1.29
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.28.7.1.1
	MLWorks_gui_1996_12_18:1.28.8
	MLWorks_1_0_Win32_1996_12_17:1.28.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.28.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.28.4.1
	JFHrts:1.28.6
	MLWorks_1_0_Irix_1996_11_28:1.28.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.28.5
	MLWorks_1_0_Unix_1996_11_14:1.28.4
	MLWorks_Open_Beta2_1996_10_11:1.28.3
	MLWorks_License_dev:1.28.2
	MLWorks_1_open_beta_1996_09_13:1.28.1
	MLWorks_Open_Beta_1996_08_22:1.28
	MLWorks_Beta_1996_07_02:1.28
	MLWorks_Beta_1996_06_07:1.28
	MLWorks_Beta_1996_06_06:1.27
	MLWorks_Beta_1996_06_05:1.27
	MLWorks_Beta_1996_06_03:1.27
	MLWorks_Beta_1996_05_31:1.27
	MLWorks_Beta_1996_05_30:1.27;
locks; strict;
comment	@ * @;


1.31
date	98.10.06.11.10.08;	author jont;	state Exp;
branches
	1.31.1.1;
next	1.30;

1.30
date	98.09.30.15.53.59;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	97.01.30.18.11.49;	author jont;	state Exp;
branches
	1.29.1.1
	1.29.2.1
	1.29.3.1
	1.29.4.1;
next	1.28;

1.28
date	96.06.07.09.32.04;	author jont;	state Exp;
branches
	1.28.1.1
	1.28.2.1
	1.28.3.1
	1.28.4.1
	1.28.5.1
	1.28.6.1
	1.28.7.1
	1.28.8.1;
next	1.27;

1.27
date	96.02.08.16.06.14;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	96.02.08.14.52.40;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	96.02.07.12.15.46;	author nickb;	state Exp;
branches;
next	1.24;

1.24
date	96.01.17.17.06.40;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	96.01.17.11.39.57;	author nickb;	state Exp;
branches;
next	1.22;

1.22
date	96.01.16.13.03.25;	author stephenb;	state Exp;
branches;
next	1.21;

1.21
date	96.01.12.16.45.38;	author stephenb;	state Exp;
branches;
next	1.20;

1.20
date	96.01.12.16.29.10;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	96.01.11.15.08.09;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	96.01.09.13.27.35;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	96.01.02.16.45.03;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.11.24.11.36.15;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	95.09.19.14.42.39;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.09.15.17.17.52;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.09.01.10.10.46;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.08.04.16.00.07;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.08.04.13.32.35;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	95.07.17.12.37.37;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.07.03.10.18.33;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.05.05.12.07.49;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.04.27.13.04.10;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.04.24.15.17.49;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.03.15.16.51.18;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.01.05.12.51.51;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.11.23.16.50.21;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.10.12.09.58.16;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.36.01;	author jont;	state Exp;
branches;
next	;

1.28.1.1
date	96.09.13.11.23.47;	author hope;	state Exp;
branches;
next	;

1.28.2.1
date	96.10.07.16.14.04;	author hope;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	96.10.09.11.13.32;	author nickb;	state Exp;
branches;
next	;

1.28.3.1
date	96.10.17.11.33.28;	author hope;	state Exp;
branches;
next	;

1.28.4.1
date	96.11.14.12.59.09;	author hope;	state Exp;
branches
	1.28.4.1.1.1;
next	;

1.28.4.1.1.1
date	96.11.28.15.09.09;	author hope;	state Exp;
branches;
next	;

1.28.5.1
date	96.11.22.18.16.53;	author hope;	state Exp;
branches;
next	;

1.28.6.1
date	96.12.17.10.03.37;	author hope;	state Exp;
branches;
next	;

1.28.7.1
date	96.12.17.17.55.14;	author hope;	state Exp;
branches
	1.28.7.1.1.1;
next	;

1.28.7.1.1.1
date	97.02.24.11.46.24;	author hope;	state Exp;
branches;
next	;

1.28.8.1
date	96.12.18.09.49.50;	author hope;	state Exp;
branches;
next	;

1.29.1.1
date	97.05.12.10.43.32;	author hope;	state Exp;
branches
	1.29.1.1.1.1
	1.29.1.1.2.1
	1.29.1.1.3.1;
next	;

1.29.1.1.1.1
date	97.07.28.18.27.33;	author daveb;	state Exp;
branches
	1.29.1.1.1.1.1.1;
next	;

1.29.1.1.1.1.1.1
date	97.10.07.11.53.33;	author jkbrook;	state Exp;
branches;
next	1.29.1.1.1.1.1.2;

1.29.1.1.1.1.1.2
date	97.10.07.12.51.07;	author jkbrook;	state Exp;
branches;
next	;

1.29.1.1.2.1
date	97.09.08.17.20.38;	author daveb;	state Exp;
branches;
next	;

1.29.1.1.3.1
date	97.09.09.14.16.45;	author daveb;	state Exp;
branches;
next	1.29.1.1.3.2;

1.29.1.1.3.2
date	97.09.22.13.16.17;	author jont;	state Exp;
branches;
next	;

1.29.2.1
date	97.09.10.19.34.56;	author brucem;	state Exp;
branches;
next	;

1.29.3.1
date	97.09.11.21.03.43;	author daveb;	state Exp;
branches;
next	;

1.29.4.1
date	97.10.31.13.46.39;	author nickb;	state Exp;
branches;
next	;

1.31.1.1
date	99.04.01.18.02.44;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.31
log
@[Bug #70108]
Modify to get working on Red Hat 4 and 5
@
text
@/* ==== SIGNAL HANDLING ====
 * 
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module abstracts the OS-specific signal handling code from
 * the various parts of the runtime system.
 *
 * 
 * Revision Log
 * ------------
 * $Log: src:OS:Linux:arch:I386:signals.c,v $
 * Revision 1.30  1998/09/30  15:53:59  jont
 * [Bug #70108]
 * Sort out Red Hat 5 signal rearrangement problems
 *
 * Revision 1.29  1997/01/30  18:11:49  jont
 * Merge in license stuff
 *
 * Revision 1.28.2.2  1996/10/09  11:13:32  nickb
 * Move to Harlequin license server.
 *
 * Revision 1.28.2.1  1996/10/07  16:14:04  hope
 * branched from 1.28
 *
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
 * Revision 1.27  1996/02/08  16:06:14  jont
 * Removing do_exportFn, as this is no longer architecture dependent
 *
 * Revision 1.26  1996/02/08  14:52:40  jont
 * Modify exportFn mechanism not to use signals at all
 * Use busy waiting in parent instead, thus avoiding
 * potential race contions
 *
 * Revision 1.25  1996/02/07  12:15:46  nickb
 * Make interval window updates happen even if we stay in ML.
 *
 * Revision 1.24  1996/01/17  17:06:40  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.23  1996/01/17  11:39:57  nickb
 * Remove storage manager interface.
 *
 * Revision 1.22  1996/01/16  13:03:25  stephenb
 * Fix bug #995 - death of last thread due to a fatal signal should
 * result in a non-zero termination code.
 *
 * Revision 1.21  1996/01/12  16:45:38  stephenb
 * Fix handle_fatal_signal so that it is a little more robust
 * with respect to dealing with fatal signals that occur whilst
 * it is active i.e. generally stop it looping.
 *
 * Revision 1.20  1996/01/12  16:29:10  nickb
 * Stupid omission.
 *
 * Revision 1.19  1996/01/11  15:08:09  nickb
 * Add timer-triggered window updates.
 *
 * Revision 1.18  1996/01/09  13:27:35  nickb
 * Extensions to event handling for non-signal events.
 *
 * Revision 1.17  1996/01/02  16:45:03  nickb
 * Update best-before date.
 *
 * Revision 1.16  1995/11/24  11:36:15  nickb
 * Add code to fixup the sp before profiling.
 *
 * Revision 1.15  1995/09/19  14:42:39  nickb
 * Improve the full GC we do during function export.
 *
 * Revision 1.14  1995/09/15  17:17:52  jont
 * Add do_exportFn to do the system specific part of exportFn
 *
 * Revision 1.13  1995/09/01  10:10:46  nickb
 * Fix licensing code (the read call is being interrupted by the timing
 * interrupt).
 *
 * Revision 1.12  1995/08/04  16:00:07  nickb
 * record_event() using wrong slot in the implicit vector.
 *
 * Revision 1.11  1995/08/04  13:32:35  nickb
 * Linux signal handling; a first attempt.
 * ,
 *
 * Revision 1.10  1995/07/17  12:37:37  nickb
 * Change profiler interface.
 *
 * Revision 1.9  1995/07/03  10:18:33  nickb
 * Update best-before date.
 *
 * Revision 1.8  1995/05/05  12:07:49  nickb
 * Remove an X-Windows line.
 *
 * Revision 1.7  1995/04/27  13:04:10  daveb
 * If signal_ml_handler is called while we are waiting for an X event,
 * the runtime just prints a message.  This avoids problems with pointer
 * grabs in X callbacks.
 *
 * Revision 1.6  1995/04/24  15:17:49  nickb
 * Add thread_preemption_pending.
 *
 * Revision 1.5  1995/03/15  16:51:18  nickb
 * Introduce the threads system.
 *
 * Revision 1.4  1995/01/05  12:51:51  nickb
 * Amend best-before date to 1st July 1995.
 * Also fix Harlequin's telephone number.
 * Also make license signal handler run on the current stack.
 *
 * Revision 1.3  1994/11/23  16:50:21  nickb
 * Remove set_stack_underflow() call.
 *
 * Revision 1.2  1994/10/12  09:58:16  jont
 * Remove gc trap stuff
 *
 * Revision 1.1  1994/10/04  16:36:01  jont
 * new file
 *
 * Revision 1.8  1994/09/07  10:05:04  jont
 * Update license expiry date
 *
 * Revision 1.7  1994/07/25  13:16:54  nickh
 * Make sure all handlers execute on signal stack.
 *
 * Revision 1.6  1994/07/22  14:33:33  nickh
 * Add GC trap handling.
 *
 * Revision 1.5  1994/07/08  10:03:57  nickh
 * Add interrupt signal number and reserve two more signals.
 *
 * Revision 1.4  1994/06/14  14:51:09  jont
 * Add critical region support for FP signals
 *
 * Revision 1.3  1994/06/13  12:02:58  nickh
 * Update best-before date.
 *
 * Revision 1.2  1994/06/09  14:24:13  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:49:10  nickh
 * new file
 *
 */

#include "signals.h"
#include "utils.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "values.h"
#include "gc.h"
#include "stacks.h"
#include "syscalls.h"
#include "exceptions.h"
#include "event.h"
#include "license.h"
#include "profiler.h"
#include "ansi.h"
#include "reals.h"
#include "alloc.h"
#include "state.h"
#include "x.h"
#include "main.h"
#include "global.h"
#include "allocator.h"
#include "i386_code.h"
#include "image.h"

#ifndef __USE_POSIX
#define __USE_POSIX
#define __USED_POSIX
#endif
#include <signal.h>

#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <string.h>
#include <memory.h>
#include <sys/wait.h>
#include <errno.h>
#include <sys/errno.h>
#include <math.h>
#include <unistd.h>

/* ML signal handler support */

#define NR_SIGNALS	32
#define SIGNAL_STACK_SIZE 	8192

unsigned int signal_nr_signals = NR_SIGNALS;

/* an array of flags showing how signals are handled */

#define SIGNAL_NOT_HANDLED 	((word)0)
#define SIGNAL_HANDLED_IN_ML	((word)1)
#define SIGNAL_HANDLED_IN_C	((word)2)
#define SIGNAL_HANDLED_FATALLY	((word)4)


static word *signal_handled = NULL;

static struct signal_name {int number;
			   const char *name;
			 } signal_names [] =
{{SIGHUP,	"SIGHUP"},
 {SIGINT,	"SIGINT"},
 {SIGQUIT,	"SIGQUIT"},
 {SIGILL,	"SIGILL"},
 {SIGTRAP,	"SIGTRAP"},
 {SIGABRT,	"SIGABRT"},
 {SIGBUS,	"SIGBUS"},
 {SIGFPE,	"SIGFPE"},
 {SIGKILL,	"SIGKILL"},
 {SIGUSR1,	"SIGUSR1"},
 {SIGSEGV,	"SIGSEGV"},
 {SIGUSR2,	"SIGUSR2"},
 {SIGPIPE,	"SIGPIPE"},
 {SIGALRM,	"SIGALRM"},
 {SIGTERM,	"SIGTERM"},
 {SIGSTKFLT,	"SIGSTKFLT"},
 {SIGCHLD,	"SIGCHLD"},
 {SIGCONT,	"SIGCONT"},
 {SIGSTOP,	"SIGSTOP"},
 {SIGTSTP,	"SIGTSTP"},
 {SIGTTIN,	"SIGTTIN"},
 {SIGTTOU,	"SIGTTOU"},
 {SIGURG,	"SIGURG"},
 {SIGXCPU,	"SIGXCPU"},
 {SIGXFSZ,	"SIGXFSZ"},
 {SIGVTALRM,	"SIGVTALRM"},
 {SIGPROF,	"SIGPROF"},
 {SIGWINCH,	"SIGWINCH"},
 {SIGIO,	"SIGIO"},
 {SIGPWR,	"SIGPWR"},
 {SIGUNUSED,	"SIGUNUSED"},
 {0,		NULL}};

static const char *name_that_signal (int sig)
{
  static const char *no_such_signal = "Unknown";
  struct signal_name *this = signal_names;

  while (this->number != sig &&
	 this->name != NULL)
    this++;

  if (this->name == NULL)
    return no_such_signal;
  else
    return this->name;
}

/* Linux-specific stuff for setting and clearing a signal handler */

typedef void (*signal_handler)(int sig, struct sigcontext sc);

static int check_sigaction (int sig, struct sigaction *act)
{
  int result = sigaction (sig,act,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  return result;
}

static int set_signal_handler(int sig, signal_handler handler)
{
  struct sigaction sa;
  sa.sa_handler = (__sighandler_t) handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
      
  return (check_sigaction (sig,&sa));
}

static int restore_default_signal_handler(int sig)
{
  struct sigaction sa;
  sa.sa_handler= SIG_DFL;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags= 0;
  return check_sigaction(sig, &sa);
}

/* signal_event() is called from record_event (in the events
   module). It can be called either synchronously in C or
   asynchronously in C or ML. It should set the 'interrupted' flag
   such that the event is taken synchronously by ML when we return to
   ML. */

extern void signal_event(void)
{
  /* set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
}

static void signal_ml_event (void)
{
  if (global_state.in_ML)
    CURRENT_THREAD->implicit.register_stack_limit = (unsigned)-1;
}

/*  == The C signal handler ==
 *
 *  This function converts a C signal into an ML signal event.
 */

static void ml_signal_handler(int sig)
{
  record_event(EV_SIGNAL, (word) sig);
  signal_ml_event();
}

static void signal_ml_handler(int sig, struct sigcontext sc)
{
  ml_signal_handler(sig);
}

/* Install or remove the signal handler for a given signal */

extern int signal_set_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if ((handled & SIGNAL_HANDLED_IN_ML) == 0) {
    signal_handled[sig] = handled + SIGNAL_HANDLED_IN_ML;
    if ((handled & SIGNAL_HANDLED_IN_C) == 0) {
      return set_signal_handler(sig,signal_ml_handler);
    }
  }
  return 0;
}

extern int signal_clear_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if (handled & SIGNAL_HANDLED_IN_ML) {
    signal_handled[sig] = handled = handled - SIGNAL_HANDLED_IN_ML;
    if (handled == 0) {
      return restore_default_signal_handler(sig);
    }
  }
  return 0;
}

/* Do something tolerable in the face of a fatal signal */

static mlval signal_thread_suicide_stub[] = {0, 0, (mlval)thread_suicide};

static void restore_default_fatal_signal_handlers(void)
{
  int i;
  for (i=0; i < NR_SIGNALS; i++) {
    if (signal_handled[i] & SIGNAL_HANDLED_FATALLY) {
      signal_handled[i] -= (SIGNAL_HANDLED_FATALLY + SIGNAL_HANDLED_IN_C);
      if (restore_default_signal_handler(i) != 0)
	error_without_alloc("Could not restore default fatal signal handlers");
    }
  }
}

static void die_in_fatal_signal_handler(char const *message)
{
  /* race condition here if the following call fails with a fatal signal */
  restore_default_fatal_signal_handlers();
  message_stderr("Fatal signal handler dying: %s", message);
}

static void handle_fatal_signal(int sig, struct sigcontext sc)
{
  if (CURRENT_THREAD == 0) {
    die_in_fatal_signal_handler("corrupt threads system");

  } else if (CURRENT_THREAD->in_fatal_signal_handler) {
    die_in_fatal_signal_handler("fatal signal raised by handler");

  } else if (in_GC) {
    die_in_fatal_signal_handler("fatal signal raised during GC.");

  } else {
    const char *signal_name;
    mlval handler;

    CURRENT_THREAD->in_fatal_signal_handler= 1;
    signal_name= name_that_signal (sig);
    handler= THREAD_ERROR_HANDLER(CURRENT_THREAD);

    DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      ml_signal_handler(sig);

    if (handler == MLUNIT) {
      /* there is no handler; print a message and kill this thread. */
      if (runnable_threads == 2) {
	die_in_fatal_signal_handler("Last thread dying.");
      } else {
	word sp = i386_fixup_sp(sc.esp,sc.eip,sc.edi,sc.ebp,sc.ecx);
	message ("Thread #%d received an intolerable signal %s (%d) %sin ML and died.",
		 CURRENT_THREAD->number, signal_name, sig, 
		 global_state.in_ML? "" : "not ");

	backtrace ((struct stack_frame *)sp, CURRENT_THREAD, max_backtrace_depth);
	SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
	if (global_state.in_ML) { 
	  sc.eip = (int)stub_c+CODE_OFFSET;                 /* code pointer */
	  sc.ebx = MLUNIT;	                            /* argument */
	  sc.ebp = (int)signal_thread_suicide_stub+POINTER; /* closure */
	} else {
	  /* this will be very lucky to work */
	  sc.eip = (int) thread_suicide;                    /* code pointer */
	}
	/* to reduce the race window the following should be near the
	 * end of thread_suicide.  However, that entails putting it in
	 * the end of the asm routine change_thread, so for simplicity it
	 * is left here. */
	CURRENT_THREAD->in_fatal_signal_handler= 0;
      }
    } else {
      /* there is a handler; skip to it */
      sc.ebx = MLINT(sig);				/* argument */
      sc.ebp = handler;					/* closure */
      if (global_state.in_ML)
	sc.eip = FIELD(handler,0)+CODE_OFFSET;		/* code pointer */
      else
	/* this won't work at all */
	sc.eip = (int)callml;				/* code pointer */

      /* Note that CURRENT_THREAD->in_fatal_signal_handler is not reset here.
       * The onus is on the SML fatal signal handler to call the SML
       * version of thread_reset_fatal_status before returning. */
    }
  }
}

/* Install the above function for a given signal */

static int die_on_signal(int sig)
{
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C | SIGNAL_HANDLED_FATALLY;
  return set_signal_handler(sig,handle_fatal_signal);
}

/* == Licensing support == 
 * 
 * SIGALRM is handled by refreshing the license. */

static void signal_timer_handler
    (int sig, struct sigcontext sc)
{
  refresh_license();

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig);
}

extern void signal_license_timer (int interval) 
{
  struct itimerval period;

  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");

  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */

  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
  period.it_value.tv_usec = 0;
  period.it_interval.tv_sec = interval;
  period.it_interval.tv_usec = 0;
  
  if(setitimer(ITIMER_REAL, &period, NULL) == -1)
    error("Unable to set up licensing timer.  "
	  "setitimer set errno to %d.", errno);
}

/* == Interrupt Support ==
 * 
 * SIGINT is handled and interpreted as an interrupt. */

static void signal_interrupt_handler (int sig, struct sigcontext sc)
{
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig);
  else 
    signal_ml_event();
  
  record_event(EV_INTERRUPT, (word) 0);
}

extern int signal_set_interrupt_handler(void)
{
  signal_handled[SIGINT] |= SIGNAL_HANDLED_IN_C;	/* interrupt */
  return set_signal_handler(SIGINT,signal_interrupt_handler);
}

extern int signal_clear_interrupt_handler(void)
{
  signal_handled[SIGINT] &= !SIGNAL_HANDLED_IN_C;

  if (signal_handled[SIGINT] & SIGNAL_HANDLED_IN_ML)
    return signal_set_ml_handler(SIGINT);
  else
    return restore_default_signal_handler(SIGINT);
}

/* == Timer support ==
 *
 * We need a virtual-time alarm for several purposes: stack-based
 * profiling, thread pre-emption, and window updates.
 */

static struct itimerval interval_timer, residual_timer;
unsigned int current_interval = 0;

/* the number of milliseconds for the profiling and pre-emption intervals. */

unsigned int profiling_interval = 0;
unsigned int thread_preemption_interval = 0;
unsigned int window_update_interval = 0;
static unsigned int window_update_remaining = 0;
static unsigned int window_updates_on = 0;

static void signal_start_timer(void)
{
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, &residual_timer) == -1)
    message("Warning: Unable to set interval timer. \n"
	    " Profiling, preemption, and window updates may not occur");
}

static unsigned int signal_set_timer(unsigned int interval)
{
  unsigned int last_interval = current_interval;
  current_interval = interval;
  interval_timer.it_value.tv_sec = interval/1000;
  interval_timer.it_value.tv_usec = (interval%1000)*1000;
  interval_timer.it_interval.tv_sec = 0;
  interval_timer.it_interval.tv_usec = 0; /* one shot timer */

  signal_start_timer();
  interval = ((residual_timer.it_value.tv_sec * 1000) +
	      (residual_timer.it_value.tv_usec / 1000));
  interval = last_interval - interval;
  return interval;
}

static int signal_update_windows(unsigned int interval)
{
  if (window_update_remaining < interval) {
    window_update_remaining = window_update_interval;
    if (window_updates_on) {
      record_event(EV_WINDOWS, (word) 0);
      return 1;
    }
  } else
    window_update_remaining -= interval;
  return 0;
}
  
static void signal_do_timer(unsigned int interval)
{
  unsigned int residue = signal_set_timer(interval);
  (void) signal_update_windows(residue);
}

/* The signal handler function. If we're profiling we run the
 * profiler. If we're pre-empting we record the event. */

static void signal_interval_alarm (int sig, struct sigcontext sc)
{
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig);

  if (profile_on) {
    time_profile_scan((struct stack_frame *)
		      i386_fixup_sp(sc.esp,sc.eip,sc.edi,sc.ebp,sc.ecx));
  }
  if (thread_preemption_on) {
    thread_preemption_pending = 1;
    record_event(EV_SWITCH, (word)0);
    if ((signal_handled[sig] & SIGNAL_HANDLED_IN_ML) == 0)
      signal_ml_event();
  }

  if (signal_update_windows (current_interval))
    signal_ml_event();
  signal_start_timer();
}

/* == Profiling support == */

extern void signal_profiling_start(void)
{
  signal_do_timer(profiling_interval);
}

extern void signal_profiling_stop(void)
{
  unsigned int interval;
  if (thread_preemption_on)
    interval = thread_preemption_interval;
  else if (window_updates_on)
    interval = window_update_interval;
  else
    interval = 0;
  signal_do_timer(interval);
}

/* == Preemption support == */

extern void signal_preemption_start(void)
{
  if (!profile_on)
    signal_do_timer(thread_preemption_interval);
}

extern void signal_preemption_stop(void)
{
  if (!profile_on) {
    unsigned int interval;
    if (window_updates_on)
      interval = window_update_interval;
    else
      interval = 0;
    signal_do_timer(interval);
  }
}

extern void signal_preemption_change(void)
{
  signal_preemption_start();
}

/* Window update support */

extern void signal_window_updates_start(void)
{
  window_updates_on = 1;
  if (current_interval == 0)
    signal_do_timer(window_update_interval);
}

extern void signal_window_updates_stop(void)
{
  window_updates_on = 0;
}

static void establish_signal_table(void)
{
  int i;
  signal_handled = (word*) alloc(NR_SIGNALS * sizeof(word),
				 "Unable to allocate signal table");
  for (i=0; i < NR_SIGNALS; i++)
    signal_handled[i] = SIGNAL_NOT_HANDLED;
  signal_handled[SIGVTALRM] = SIGNAL_HANDLED_IN_C;	/* intervals */
}

extern void signals_init (void)
{
  establish_signal_table();
  
  /* virtual interval alarm handler */
  if (set_signal_handler(SIGVTALRM, signal_interval_alarm))
    error("Unable to set up virtual interval timer signal handler.");

  /* these signals are fatal */

  die_on_signal (SIGILL);
  die_on_signal (SIGSEGV);
}
@


1.31.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 4
 * Revision 1.31  1998/10/06  11:10:08  jont
 * [Bug #70108]
 * Modify to get working on Red Hat 4 and 5
 *
@


1.30
log
@[Bug #70108]
Sort out Red Hat 5 signal rearrangement problems
@
text
@d14 4
d172 6
a177 1
#include <asm/signal.h>
a187 6

/* Stuff that Red Hat 5 screws up */

extern int	sigaction __P ((int __sig, struct sigaction *__act,
			struct sigaction *__oldact));
extern int	sigemptyset __P ((sigset_t *__mask));
@


1.29
log
@Merge in license stuff
@
text
@d14 3
a162 1
#include "pervasives.h"
d168 1
a174 2
#include <signal.h>
#include <sys/signal.h>
d179 6
@


1.29.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a13 3
 * Revision 1.29  1997/01/30  18:11:49  jont
 * Merge in license stuff
 *
@


1.29.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 3
 * Revision 1.29  1997/01/30  18:11:49  jont
 * Merge in license stuff
 *
@


1.29.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 3
 * Revision 1.29  1997/01/30  18:11:49  jont
 * Merge in license stuff
 *
@


1.29.1.1
log
@branched from 1.29
@
text
@a13 3
 * Revision 1.29  1997/01/30  18:11:49  jont
 * Merge in license stuff
 *
@


1.29.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.29.1.1  1997/05/12  10:43:32  hope
 * branched from 1.29
 *
@


1.29.1.1.3.2
log
@[Bug #30274]
Use SA_RESTART to avoid problems with interrupted system calls.
Check awaiting_x_event
@
text
@a13 3
 * Revision 1.29.1.1.3.1  1997/09/09  14:16:45  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d277 1
a277 1
  sa.sa_flags = SA_RESTART;
d316 2
a317 6
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    record_event(EV_SIGNAL, (word) sig);
    signal_ml_event();
  }
d489 6
a494 10
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      ml_signal_handler(sig);
    else 
      signal_ml_event();

    record_event(EV_INTERRUPT, (word) 0);
  }
@


1.29.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.29.1.1  1997/05/12  10:43:32  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.29.1.1  1997/05/12  10:43:32  hope
 * branched from 1.29
 *
@


1.29.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.29.1.1.1.1  1997/07/28  18:27:33  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.29.1.1.1.1.1.2
log
@[Bug #30274]
Merging from MLWorks_10r3:
Add SA_RESTART and awaiting_x_event stuff
@
text
@a13 1
 *
d280 1
a280 1
  sa.sa_flags = SA_RESTART;
d319 2
a320 6
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    record_event(EV_SIGNAL, (word) sig);
    signal_ml_event();
  }
d492 6
a497 10
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      ml_signal_handler(sig);
    else 
      signal_ml_event();

    record_event(EV_INTERRUPT, (word) 0);
  }
@


1.28
log
@Update best before to 01/01/97
@
text
@d14 9
d443 1
a443 4
/* == Real arithmetic exception support isn't done here on Intel */
/* == Integer exception support isn't done here on Intel */

/* == Licensing support ==
d445 1
a445 19
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */

#define POLL_PERIOD	600		/* seconds between licence checks */
#define BEST_BEFORE	852076800	/* 1996-07-01 00:00 */

/* The process ID of the child */
d447 2
a448 7
int signal_license_child_pid;

/* The handler for SIGCHLD, installed by the main MLWorks process */
/* This handles death of license, and if relevant, export children */

static void signal_child_handler
  (int sig, struct sigcontext sc)
d450 1
a450 4
  int status, available;

  DIAGNOSTIC(4, "sigchild(sig = %d)", sig, 0);
  DIAGNOSTIC(4, "license pid = %d)", signal_license_child_pid, 0);
a453 38

  /* Find out what happened to the child.  If waitpid() is interrupted by a */
  /* signal then try again. */

  if (signal_license_child_pid != 0) {
    do
      available = waitpid(signal_license_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);
  } else {
    return;
  }

  if (available == 0) {
    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
    return;
  } else {
    if(available == -1)
      error("Unable to determine status of licensing process.  "
	    "waitpid set errno to %d.", errno);
  
    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
  
    DIAGNOSTIC(4, "available %d status 0x%02X", available, status);
    
    if(WIFSTOPPED(status))
      error("Licensing process stopped with signal %d", WSTOPSIG(status));
    else if(WIFSIGNALED(status))
      error("Licensing process terminated with signal %d", WTERMSIG(status));
    else
      error("Your license has expired.  Contact MLWorks customer support:\n"
	    "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	    "   telephone:        +44 1223 872522");
  }
d456 1
a456 3
/* The handler for SIGALRM, installed by the child (licensing) process */

static void signal_license_alarm_handler (int sig, struct sigcontext sc)
a457 33
  time_t now;

  now = time(NULL);
  DIAGNOSTIC(4, "child: checking license at time %ld", now, 0);

  if(now == -1)
    message("child: WARNING: time() returned -1");
  else if (now >= BEST_BEFORE)
  {
    DIAGNOSTIC(1, "child: license expired at time %ld", now, 0);
    exit(1);
  }
}

/* A function called by the main MLWorks process to watch the child
 * process */

extern void signal_license_watch_child (void)
{
  if (set_signal_handler(SIGCHLD, signal_child_handler))
    error("Unable to set signal handler for SIGCHLD");
}

#define sigmask(i) (1 << (i))

/* The licensing child process itself */

extern void signal_license_child (int *pipefd)
{
  struct sigaction sa;
  long signals_to_block;
  /* signals_to_block should be a sigset_t but that generates warnings */
  struct sigcontext sc;
a458 2
  char dummy;
  int result;
d460 3
a462 6
  /* Ignore all signals (if possible) so that signals sent to the */
  /* process group won't affect the licensing process. */
  /* SIGKILL and SIGSTOP are not blocked by this */
  sigfillset(&signals_to_block);
  sigdelset(&signals_to_block,SIGALRM);
  sigprocmask(SIG_BLOCK,&signals_to_block,NULL);
d464 1
a464 11
    /* Check the license once before we start. */
  signal_license_alarm_handler (0,sc);
  
  /* Set up a real time alarm with a handler to poll the license. */
  sa.sa_handler = (__sighandler_t)signal_license_alarm_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  
  if(sigaction(SIGALRM, &sa, NULL) == -1)
    error("Licensing process unable to set signal handler for SIGALRM.  "
	  "sigaction set errno to %d.", errno);
d466 2
a467 1
  period.it_value.tv_sec = POLL_PERIOD;
d469 1
a469 1
  period.it_interval.tv_sec = POLL_PERIOD;
a474 15

  /* Read from the child's end of the pipe.  This has the effect of */
  /* blocking the child until the other end is closed by the parent */
  /* exiting. */
  
  close(pipefd[1]);
  do {
    result = read(pipefd[0], &dummy, 1);
  } while (result == -1 && errno == EINTR);

  if (result)
    error("Licensing process managed to read from pipe.");
  
  DIAGNOSTIC(2, "child: parent died -- exiting", 0, 0);
  exit(0);
a655 1
  signal_handled[SIGCHLD]   = SIGNAL_HANDLED_IN_C;	/* licensing */
d662 1
a662 1
  /* interval alarm handler */
d664 1
a664 1
    error("Unable to set up interval timer signal handler.");
@


1.28.8.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.7.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.7.1.1.1
log
@branched from 1.28.7.1
@
text
@a13 3
 * Revision 1.28.7.1  1996/12/17  17:55:14  hope
 * branched from 1.28
 *
@


1.28.6.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.5.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.4.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.4.1.1.1
log
@branched from 1.28.4.1
@
text
@a13 3
 * Revision 1.28.4.1  1996/11/14  12:59:09  hope
 * branched from 1.28
 *
@


1.28.3.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.2.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.28.2.2
log
@Move to Harlequin license server.
@
text
@a13 3
 * Revision 1.28.2.1  1996/10/07  16:14:04  hope
 * branched from 1.28
 *
d437 4
a440 1
/* == Licensing support == 
d442 17
a458 1
 * SIGALRM is handled by refreshing the license. */
d460 9
a468 2
static void signal_timer_handler
    (int sig, struct sigcontext sc)
d470 4
a473 1
  refresh_license();
d477 38
d517 3
a519 1
extern void signal_license_timer (int interval) 
d521 33
d555 2
d558 6
a563 3
  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");
d565 11
a575 1
  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */
d577 1
a577 2
  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
d579 1
a579 1
  period.it_interval.tv_sec = interval;
d585 15
d781 1
d788 1
a788 1
  /* virtual interval alarm handler */
d790 1
a790 1
    error("Unable to set up virtual interval timer signal handler.");
@


1.28.1.1
log
@branched from 1.28
@
text
@a13 3
 * Revision 1.28  1996/06/07  09:32:04  jont
 * Update best before to 01/01/97
 *
@


1.27
log
@Removing do_exportFn, as this is no longer architecture dependent
@
text
@d14 3
d455 1
a455 1
#define BEST_BEFORE	836179200	/* 1996-07-01 00:00 */
@


1.26
log
@Modify exportFn mechanism not to use signals at all
Use busy waiting in parent instead, thus avoiding
potential race contions
@
text
@d14 5
a535 68
}

/* exportFn support */
mlval do_exportFn(mlval argument)
{
  pid_t child_pid = fork();

  if(child_pid == -1) {
    switch(errno) {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork exportFn process");
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork exportFn process");
      default: 
      exn_raise_format(perv_exn_ref_save,
		       "fork() returned an unexpected error code %d", errno);
    }
  } else if (child_pid == 0) {
    /* The child process */
    mlval global;
    mlval filename = FIELD(argument, 0);
    image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
    declare_root(&filename);
    
    global = global_pack();
    declare_root(&global);
    
    gc_clean_image();
    
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);
    
    if(image_save(argument) == ERROR)
      exit(errno ? errno : -1);
    
    exit(0);
  } else {
    /* The parent process */
    int status;
    DIAGNOSTIC(4, "Setting export child pid is %d", child_pid, 0);
    /* Now wait for the child to complete, and get its return status */
    do {
      waitpid(child_pid, &status, 0);
    } while(!(WIFSIGNALED(status) || WIFEXITED(status)));
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save, "Export process terminated by signal %d",
		       WTERMSIG(status));
    }
    switch(WEXITSTATUS(status)) {
    case 0:
      break;
    case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Function save not implemented");
    case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
    case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");
    default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
    }
    return MLUNIT; /* Should later change to return to MLWorks */
  }
@


1.25
log
@Make interval window updates happen even if we stay in ML.
@
text
@d14 3
a452 8
/* The process ID of the exportFn child */

int signal_export_child_pid;

static int export_exists = 0; /* Something to ensure we don't miss signals */
static int export_child_status = 0;
static int child_exited = 1;

d462 1
a462 1
  DIAGNOSTIC(4, "license and export pids = %d, %d)", signal_license_child_pid, signal_export_child_pid);
d470 1
a470 7
  do
    available = waitpid(signal_license_child_pid,
			&status, WNOHANG | WUNTRACED);
  while(available == -1 && errno == EINTR);
  
  if (available == 0) {
    /* No status available for licensing process, try export */
d472 1
a472 1
      available = waitpid(signal_export_child_pid,
d475 3
d479 1
a479 4
    if(available == -1)
      error("Unable to determine status of export process.  "
	    "waitpid set errno to %d.", errno);

d483 1
a483 23

    if(available) {
      DIAGNOSTIC(1, "available %d status 0x%02X", available, status);

      if(WIFSTOPPED(status))
	error("Export process stopped with signal %d", WSTOPSIG(status));
      else if(WIFSIGNALED(status))
	error("Export process terminated with signal %d", WTERMSIG(status));
      else if(WIFEXITED(status)) {
	/* This is the case where the child has exited roughly as expected */
	DIAGNOSTIC(1, "Export process terminated with status %d",
		   WEXITSTATUS(status), 0);
	export_child_status = status;
	child_exited = 1;
	return;
      } else
	error("Export process terminated for unknown reason");

    } else {
      /* else status has changed back again */
      error("exportFn:Child status has unexpectedly reverted");
    }

a505 15
static void clear_export_child_status(void)
{
  child_exited = 0;
}

static int read_export_child_status(void)
{
  return WEXITSTATUS(export_child_status);
}

static int check_export_child_status(void)
{
  return child_exited;
}

a532 12
static void signal_export_watch_child(void)
{
  DIAGNOSTIC(4, "Watching export child", 0, 0);
  export_exists = 1;
}

static void signal_export_unwatch_child(void)
{
  DIAGNOSTIC(4, "Unwatching export child", 0, 0);
  export_exists = 0;
}

d536 1
a536 5
  pid_t child_pid;

  clear_export_child_status();
  signal_export_watch_child();
  child_pid = fork();
d574 2
a575 2
    DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
    signal_export_child_pid = child_pid;
d577 9
a585 4
    /* Busy wait, is there a better way to do this? */
    while (check_export_child_status() == 0);
    signal_export_unwatch_child();
    switch (read_export_child_status()) {
@


1.24
log
@Disable interrupt handling except when a handler is defined.
@
text
@d14 3
d288 1
a288 1
static inline void ml_signal_handler(int sig)
d341 1
a341 1
static inline void die_in_fatal_signal_handler(char const *message)
d765 1
a765 1
static inline void signal_start_timer(void)
d772 1
a772 1
static inline unsigned int signal_set_timer(unsigned int interval)
d788 1
a788 1
static inline void signal_update_windows(unsigned int interval)
d791 2
a792 1
    if (window_updates_on)
d794 2
a795 1
    window_update_remaining = window_update_interval;
d798 1
d801 1
a801 1
static inline void signal_do_timer(unsigned int interval)
d804 1
a804 1
  signal_update_windows(residue);
d826 2
a827 1
  signal_update_windows (current_interval);
d889 1
a889 1
static inline void establish_signal_table(void)
@


1.23
log
@Remove storage manager interface.
@
text
@d14 3
d224 38
a295 15
static int check_sigaction (int sig, struct sigaction *act)
{
  int result = sigaction (sig,act,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  return result;
}

d304 1
a304 7
      struct sigaction act;

      act.sa_handler = (__sighandler_t )signal_ml_handler;
      sigemptyset(&act.sa_mask);
      act.sa_flags = 0;
      
      return (check_sigaction (sig,&act));
d316 1
a316 7
      struct sigaction act;

      act.sa_handler = SIG_DFL;
      sigemptyset(&act.sa_mask);
      act.sa_flags = 0;
      
      return (check_sigaction (sig,&act));
a325 12

static int restore_default_signal_handler(int signal)
{
  struct sigaction new_action;
  new_action.sa_handler= SIG_DFL;
  sigemptyset(&new_action.sa_mask);
  new_action.sa_flags= 0;
  return sigaction(signal, &new_action, (struct sigaction *)0);
}



a337 2


a344 1

a411 1

a415 5
  struct sigaction act;

  act.sa_handler = (__sighandler_t)handle_fatal_signal;
  sigemptyset(&act.sa_mask);
  act.sa_flags = 0; 
d417 1
a417 2
 
  return (sigaction(sig,&act,NULL));
a419 2


d574 2
a575 8
  struct sigaction sa;

  sa.sa_handler = (__sighandler_t)signal_child_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  if(sigaction(SIGCHLD, &sa, NULL) == -1)
    error("Unable to set signal handler for SIGCHLD.  "
	  "sigaction set errno to %d.", errno);
a670 4
  sa.sa_handler = (__sighandler_t)signal_license_alarm_handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags = 0;
  
d682 4
d729 16
a888 1
  signal_handled[SIGINT]    = SIGNAL_HANDLED_IN_C;	/* interrupt */
a894 2
  struct sigaction sa;

a896 10
  /* interrupt handler */

  sa.sa_handler = (__sighandler_t) signal_interrupt_handler;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  sigaddset(&sa.sa_mask,SIGINT);

  if(sigaction(SIGINT, &sa, NULL) == -1)
    error("Unable to set up interrupt signal handler.");

d898 1
a898 7

  sa.sa_handler = (__sighandler_t) signal_interval_alarm;
  sa.sa_flags = 0;
  sigemptyset(&sa.sa_mask);
  sigaddset(&sa.sa_mask,SIGVTALRM);

  if(sigaction(SIGVTALRM, &sa, NULL) == -1)
@


1.22
log
@Fix bug #995 - death of last thread due to a fatal signal should
result in a non-zero termination code.
@
text
@d14 4
d138 1
a608 2
  mlval global, filename;

d616 1
a616 2
    switch(errno)
      {
a619 1

d622 4
a625 8
		       "Insufficient memory to fork licensing process");

      default:
      {
	char error_message[200];
	sprintf(error_message, "fork() returned an unexpected error code %d", errno);
	exn_raise_string(perv_exn_ref_save, error_message);
      }
d627 22
d650 18
a667 73
    if (child_pid == 0) {
      /* The child process */
      filename = FIELD(argument, 0);
      image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
      declare_root(&filename);

      global = global_pack();
      declare_root(&global);

      {
	mlval old_message_level = MLSUB(gc_message_level,0);
	clear_handlers(); /* Don't follow the signal handlers */
	clear_thread_roots(); /* Don't follow roots in ml_state etc */
	MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
	/* now do big garbage collections, without scanning the ML stack */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	(void) sm_interface(SM_PROMOTE_ALL, 0, MLUNIT); /* merge all gens */
	MLUPDATE(gc_message_level,0,MLINT(-1));		/* turn on messages */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	MLUPDATE(gc_message_level,0,old_message_level);
      }

      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);

      if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
	switch(errno)
	  {
	  case EIMPL:
	    exit(EIMPL);
	    error("Function save not implemented");

	  case EIMAGEWRITE:
	    exit(EIMAGEWRITE);
	    error("Error writing opened image file");

	  case EIMAGEOPEN:
	    exit(EIMAGEOPEN);
	    error("Unable to open image file");

	  default:
	    exit(errno ? errno : -1);
	    error("Unexpected error from exportFn");
	  }

      exit(0);
    } else {
      /* The parent process */
      DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
      signal_export_child_pid = child_pid;
      /* Now wait for the child to complete, and get its return status */
      /* Busy wait, is there a better way to do this? */
      while (check_export_child_status() == 0);
      signal_export_unwatch_child();
      switch (read_export_child_status()) {
      case 0:
	break;
      case EIMPL:
	exn_raise_string(perv_exn_ref_save, "Function save not implemented");

      case EIMAGEWRITE:
	exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
	exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
	exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
      }
      return MLUNIT; /* Should later change to return to MLWorks */
d669 1
d675 1
a675 1
/* The child process itself */
@


1.21
log
@Fix handle_fatal_signal so that it is a little more robust
with respect to dealing with fatal signals that occur whilst
it is active i.e. generally stop it looping.
@
text
@d14 5
d160 2
d276 1
a276 1
      act.sa_mask = 0;
d294 1
a294 1
      act.sa_mask = 0;
d308 1
a308 1
static void install_default_fatal_signal_handlers(void)
d312 1
a312 1
  new_action.sa_mask= 0;
d314 24
a337 3
  if ((sigaction(SIGILL,  &new_action, (struct sigaction *)0) != 0)
  ||  (sigaction(SIGSEGV, &new_action, (struct sigaction *)0) != 0))
    error_without_alloc("Could not install default fatal signal handlers");
d344 2
a345 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Corrupt threads.  Dying ...\n");
d347 5
a351 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Fatal signal raised in fatal signal handler!  Dying ...\n");
a361 6
    if (in_GC) {
      install_default_fatal_signal_handlers();
      error("Received intolerable signal %s (%d) during GC. Dying.",
	    signal_name, sig);
    }

d367 2
a368 12
      word sp = i386_fixup_sp(sc.esp,sc.eip,sc.edi,sc.ebp,sc.ecx);
      void (*old_messager_function)(const char * message) = messager_function;
      messager_function = NULL;
      message ("Intolerable signal %s (%d) received %sin ML. Backtrace:",
	       signal_name, sig, global_state.in_ML? "" : "not ");
      backtrace ((struct stack_frame *)sp, CURRENT_THREAD, max_backtrace_depth);
      messager_function = old_messager_function;
      SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
      if (global_state.in_ML) { 
	sc.eip = (int)stub_c+CODE_OFFSET;			/* code pointer */
	sc.ebx = MLUNIT;					/* argument */
	sc.ebp = (int)signal_thread_suicide_stub+POINTER; /* closure */
d370 20
a389 2
	/* this will be very lucky to work */
	sc.eip = (int) thread_suicide;			/* code pointer */
a390 5
      /* to reduce the race window the following should be near the
       * end of thread_suicide.  However, that entails putting it in
       * the end of the asm routine change_thread, so for simplicity it
       * is left here. */
      CURRENT_THREAD->in_fatal_signal_handler= 0;
d416 1
a416 1
  act.sa_mask = 0;
d418 1
a418 1
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C;
d423 2
d582 1
a582 1
  sa.sa_mask = 0;
d723 1
a723 1
  sa.sa_mask = 0;
@


1.20
log
@Stupid omission.
@
text
@d14 3
d300 13
d315 11
a325 2
  const char *signal_name = name_that_signal (sig);
  mlval handler = THREAD_ERROR_HANDLER(CURRENT_THREAD);
d327 11
a337 6
  DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

  if (in_GC) {
    error("Received intolerable signal %s (%d) during GC. Dying.",
	  signal_name, sig);
  }
d339 2
a340 2
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    ml_signal_handler(sig);
d342 23
a364 14
  if (handler == MLUNIT) {
    /* there is no handler; print a message and kill this thread. */
    word sp = i386_fixup_sp(sc.esp,sc.eip,sc.edi,sc.ebp,sc.ecx);
    void (*old_messager_function)(const char * message) = messager_function;
    messager_function = NULL;
    message ("Intolerable signal %s (%d) received %sin ML. Backtrace:",
	     signal_name, sig, global_state.in_ML? "" : "not ");
    backtrace ((struct stack_frame *)sp, CURRENT_THREAD, max_backtrace_depth);
    messager_function = old_messager_function;
    SET_RESULT(ML_THREAD(CURRENT_THREAD), THREAD_DIED);
    if (global_state.in_ML) { 
      sc.eip = (int)stub_c+CODE_OFFSET;			/* code pointer */
      sc.ebx = MLUNIT;					/* argument */
      sc.ebp = (int)signal_thread_suicide_stub+POINTER; /* closure */
d366 12
a377 2
      /* this will be very lucky to work */
      sc.eip = (int) thread_suicide;			/* code pointer */
a378 9
  } else {
    /* there is a handler; skip to it */
    sc.ebx = MLINT(sig);				/* argument */
    sc.ebp = handler;					/* closure */
    if (global_state.in_ML)
      sc.eip = FIELD(handler,0)+CODE_OFFSET;		/* code pointer */
    else
      /* this won't work at all */
      sc.eip = (int)callml;				/* code pointer */
d381 1
@


1.19
log
@Add timer-triggered window updates.
@
text
@d14 3
d863 2
@


1.18
log
@Extensions to event handling for non-signal events.
@
text
@d14 3
d710 2
a711 2
 * We need a virtual-time alarm for two purposes: for stack-based profiling
 * and for thread pre-emption.
d714 2
a715 1
static struct itimerval interval_timer;
d721 3
d727 3
a729 3
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, NULL) == -1)
    message("Warning: Unable to set interval timer (setitimer set errno "
	    "to %d).  Stack profiling and preemption will not occur.", errno);
d732 1
a732 1
static inline void signal_set_timer(unsigned int interval)
d734 2
d742 20
d783 1
d791 1
a791 1
  signal_set_timer(profiling_interval);
d796 1
a796 1
  signal_set_timer(0);
d798 6
a803 1
    signal_set_timer(thread_preemption_interval);
d811 1
a811 1
    signal_set_timer(thread_preemption_interval);
d816 8
a823 2
  if (!profile_on)
    signal_set_timer(0);
d829 14
@


1.17
log
@Update best-before date.
@
text
@d14 3
d141 8
d200 5
a204 1
/* reserving and releasing signals */
d206 1
a206 3
static int reserved[NR_SIGNALS];

extern int signal_reserve(int sig)
d208 2
a209 10
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 1;
  return 0;
a210 14
    
extern int signal_release(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (!reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 0;
  return 0;
}  
d212 1
a212 1
extern int signal_reserved(int sig)
d214 2
a215 5
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  return (reserved[sig]);
d223 1
a223 1
static void record_event(void)
d225 2
a226 3
  if (global_state.in_ML)
    CURRENT_THREAD->implicit.register_stack_limit = (unsigned)-1;
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
d229 1
a229 2
static void signal_ml_handler
  (int sig, struct sigcontext sc)
d231 1
a231 16
  struct event *event;

  event = alloc(sizeof(struct event), "Couldn't allocate event");
  event->type = SIGNAL;
  event->the.signal = sig;

  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;

  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);
  
  record_event();
d253 14
a266 7
  struct sigaction act;

  act.sa_handler = (__sighandler_t )signal_ml_handler;
  act.sa_mask = 0;
  act.sa_flags = 0;

  return (check_sigaction (sig,&act));
d271 14
a284 7
  struct sigaction act;

  act.sa_handler = SIG_DFL;
  act.sa_mask = 0;
  act.sa_flags = 0;

  return (check_sigaction (sig,&act));
d303 3
d344 3
a346 2
  act.sa_flags = 0;
  
a349 14
/* == Stack overflow support ==
 * 
 * When we exceed the user-specified number of stack blocks, we want
 * to signal into the ML debugger. This is the portable interface:
 * self_signal (signal_stack_overflow) is called. */

int signal_stack_overflow = SIGUSR1;
int signal_interrupt = SIGINT;

extern void self_signal (int sig)
{
  kill (getpid(),(int) sig);
}

d396 3
d691 14
d740 3
d749 3
a751 1
    record_event();
d790 12
d806 10
a829 8

  /* these signals are reserved to the runtime */

  signal_reserve (SIGILL);	/* fatal */
  signal_reserve (SIGSEGV);	/* fatal */
  signal_reserve (SIGVTALRM);	/* profiling */
  signal_reserve (SIGINT);	/* interrupt */
  signal_reserve (SIGUSR1);	/* stack overflow */
@


1.16
log
@Add code to fixup the sp before profiling.
@
text
@d14 3
d396 1
a396 1
#define BEST_BEFORE	820454400	/* 1996-01-01 00:00 */
@


1.15
log
@Improve the full GC we do during function export.
@
text
@d14 3
d113 1
d317 1
d322 1
a322 2
    backtrace ((struct stack_frame *)sc.esp, CURRENT_THREAD,
	       max_backtrace_depth);
d745 4
a748 3
  if (profile_on)
    time_profile_scan((struct stack_frame *) CURRENT_THREAD->ml_state.sp);

@


1.14
log
@Add do_exportFn to do the system specific part of exportFn
@
text
@d14 3
d585 5
a589 2
	MLUPDATE(gc_message_level,0,MLINT(-1));
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
@


1.13
log
@Fix licensing code (the read call is being interrupted by the timing
interrupt).
@
text
@d14 4
d103 4
d368 17
d392 8
d401 1
d403 1
a403 1
static void signal_license_child_handler
d408 2
a409 2
  DIAGNOSTIC(4, "sigchild(sig = %d, child = %d)",
	     sig, signal_license_child_pid);
d419 41
a459 3
  if(available == -1)
    error("Unable to determine status of licensing process.  "
	  "waitpid set errno to %d.", errno);
d461 3
a463 3
  /* If available is non zero then something happened to the child.  If it */
  /* is zero then the child status changed, but changed back (for example, */
  /* both child and parent were suspended from the shell and restarted. */
a464 1
  if(available) {
d470 1
a470 1
	error("Licensing process terminated with signal %d", WTERMSIG(status));
d478 15
d518 1
a518 1
  sa.sa_handler = (__sighandler_t)signal_license_child_handler;
d524 116
@


1.12
log
@record_event() using wrong slot in the implicit vector.
@
text
@d14 3
d379 1
a379 1
  
d388 1
a388 1

d395 1
a395 1

d397 1
a397 1
      error("Licensing process was stopped with signal %d", WSTOPSIG(status));
d399 1
a399 1
      error("Licensing process was terminated with signal %d", WTERMSIG(status));
d409 1
a409 2
static void signal_license_alarm_handler
    (int sig, struct sigcontext sc)
d450 1
a450 1

d452 1
a452 1
  struct itimerval period;
d465 1
a465 2
  
  /* Check the license once before we start. */
d472 1
a472 1
  
d481 1
a481 1
  
d487 5
a491 1
  if(read(pipefd[0], &dummy, 1))
@


1.11
log
@Linux signal handling; a first attempt.
,
@
text
@d14 4
d217 1
a217 1
    CURRENT_THREAD->implicit.stack_limit = (unsigned)-1;
@


1.10
log
@Change profiler interface.
@
text
@d14 3
d104 1
d122 1
a122 3
/*
 {SIGEMT,	"SIGEMT"},
*/
d125 1
a125 1
 {SIGBUS,	"SIGBUS"},
d127 1
a127 3
/*
 {SIGSYS,	"SIGSYS"},
*/
d131 3
a133 1
 {SIGURG,	"SIGURG"},
a135 2
 {SIGCONT,	"SIGCONT"},
 {SIGCHLD,	"SIGCHLD"},
d138 1
a138 1
 {SIGIO,	"SIGIO"},
d144 3
a146 5
/*
 {SIGLOST,	"SIGLOST"},
*/
 {SIGUSR1,	"SIGUSR1"},
 {SIGUSR2,	"SIGUSR2"},
d218 1
a218 1
  (int sig, int code, struct sigcontext *scp, char *addr)
d222 9
a230 14
/*
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
*/
    event = alloc(sizeof(struct event), "Couldn't allocate event");
    event->type = SIGNAL;
    event->the.signal = sig;

    event->forward = &event_queue;
    event->back = event_queue.back;
    event->forward->back = event;
    event->back->forward = event;
    ++event_queue.the.sentinel_count;
d232 2
a233 2
    DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	       sig, event_queue.the.sentinel_count);
d235 1
a235 4
    record_event();
/*
  }
*/
d238 1
a238 1
static int check_sigvec (int sig, struct sigaction *vec)
d240 1
a240 1
  int result = sigaction (sig,vec,NULL);
a252 1

d257 1
a257 1
  struct sigaction vec;
d259 3
a261 3
  vec.sa_handler = signal_ml_handler;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;
d263 1
a263 1
  return (check_sigvec (sig,&vec));
d268 1
a268 1
  struct sigaction vec;
d270 3
a272 3
  vec.sa_handler = SIG_DFL;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;
d274 1
a274 1
  return (check_sigvec (sig,&vec));
d279 3
a281 2
static void handle_die_gracefully(int sig, int code,
				  struct sigcontext *scp, char *addr)
d284 1
d289 31
a319 2
    error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	  signal_name, sig, code);
a320 6
  message ("Intolerable signal %s (%d : %d) received. Backtrace:",
	   signal_name, sig, code);
/*
  backtrace (stderr, (struct stack_frame *)scp->sc_sp, max_backtrace_depth);
*/
  error ("Dying.");
d327 1
a327 1
  struct sigaction vec;
d329 3
a331 3
  vec.sa_handler = handle_die_gracefully;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;
d333 1
a333 1
  return (sigaction(sig,&vec,NULL));
d350 2
a351 276
/*  == Handle math errors in library functions ==
 *
 *  The matherr function is called by the math library when exception
 *  occur.  See matherr(3M).  This function need only handle those
 *  routines we actually provide in reals.[ch]. */

#if 0
extern int matherr(struct exception *e)
{
  char *problem = e->name;

  in_ml_fpe = 0;
  if(strcmp(problem, "log") == 0)
    exn_raise(perv_exn_ref_ln);
  else if(strcmp(problem, "fabs") == 0)
    exn_raise(perv_exn_ref_abs);
  else if(strcmp(problem, "exp") == 0)
    exn_raise(perv_exn_ref_exp);
  else if(strcmp(problem, "sqrt") == 0)
    exn_raise(perv_exn_ref_sqrt);

  message("Warning: Unhandled floating point error in `%s' -- returning %g",
	  problem, e->retval);

  return(e->retval);
}
#endif

/* == Real arithmetic exception support ==
 *
 *  This function is the handler for the floating point exception
 *  signals.  If called while in ML it examines the instruction which
 *  caused the exception in order to determine which ML exception to
 *  raise.  The signal context is updated in order to change raise the
 *  exception when the handler returns.  */

#if 0
static void signal_real_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  DIAGNOSTIC(1, "signal %d: IEEE exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  /* Find out whether the exception occurred in ML or C.  If in C then we */
  /* can ignore it -- the library will call matherr (qv) */

  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
    if (in_ml_fpe && sig == SIGFPE) {
/*
      message("FP Signal inside fpe, ignoring");
*/
      in_ml_fpe = 0;
    } else {
      message("Warning: signal %d outside ML -- ignoring", sig);
    };
    return;
  }

  /* Check that the instruction type is FPOP */

  if((instruction & 0xC1F00000) != 0x81A00000)
  {
    DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
    message("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  /* Switch on the instruction code : SPARC-specific */

  switch(instruction & 0x00003FE0)
  {
    /* This case should never happen.  We check the size explicitly,
       because we use 30-bit ints instead of 32-bit ints.
    case 0x1A40:
    DIAGNOSTIC(1, "  fdtoi", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_floor);
    break;
    */

    case 0x0540:
    DIAGNOSTIC(1, "  fsqrtd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sqrt);
    break;

    case 0x0840:
    DIAGNOSTIC(1, "  faddd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
    break;

    case 0x08C0:
    DIAGNOSTIC(1, "  fsubd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
    break;

    case 0x0940:
    DIAGNOSTIC(1, "  fmuld", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_prod);
    break;

    case 0x09C0:
    DIAGNOSTIC(1, "  fdivd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_quot);
    break;

    default:
    DIAGNOSTIC(1, "  unknown fpop instruction", 0, 0);
    message("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
}
#endif

/* == Integer exception support == 
 *
 * This function is the handler for the emulation trap signals. These
 * are caused by ML arithmetic instructions which overflow (and which
 * should therefore raise an exception) and by allocation sequences
 * which run out of heap (and which should therefore cause a GC).

 * If called while in ML it examines the instruction which caused the
 * exception in order to determine which ML exception to raise, or to
 * do a GC.  The signal context is updated in order to raise the
 * exception (or enter the GC code) when the handler returns.  */

#if 0
static void signal_integer_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
    message("Warning: signal %d outside ML -- ignoring", sig);
    return;
  }

/* Check for allocation traps so we can start a GC.

   Allocation sequences always look like one of the following:

 * 1. Allocating a known amount < 4k:

	taddcctv %g1, #bytes, %g1
	add	rn, %g2, #tag
	add	%g2, %g2, #bytes

 * 2. Allocating an unknown amount, or a known amount > 4k:

 	<get the number of bytes into the 'global' register %g4>
 	taddcctv %g1, %g4, %g1
 	add	rn, %g2, #tag
 	add	%g2, %g2, %g4

 * In a leaf procedure, the 'add rn' instruction (the one after the
 * taddcctv) should be replaced with an 'or rn' instruction. This
 * enables us to distinguish the leaf case.

 * The taddcctv instruction fails if there is insufficient space for
 * the alloc */

#define TADDCCTV_MASK 0xffffc000
#define TADDCCTV_BITS 0x83104000

  if ((instruction & TADDCCTV_MASK) == TADDCCTV_BITS) {
    /* then it's a GC entry point */

    int leaf;
    word instr2;
    word overwrite;

    /* get the number of bytes */

#define TADDCCTV_IMMEDIATE_FLAG_MASK 0x2000
#define TADDCCTV_IMMEDIATE_MASK 0x1fff

    if (instruction & TADDCCTV_IMMEDIATE_FLAG_MASK) {
      gc_trap_bytes = ((instruction & TADDCCTV_IMMEDIATE_MASK));
    } else {
      /* -1 means "the number is in the 'global' register" */
      gc_trap_bytes = 0xffffffff;
    }

    /* We want to return to address+12, so set the fake link register
       to addr+4 */

    gc_trap_return_address = ((word)addr)+4;

    /* construct tagging instruction, which tags the value in the
       return register and puts it in whatever register the allocation
       routine was going to put it. We do this by getting the tagging
       instruction out of the allocation routine and changing the
       register number */

    instr2 = addr[1];

#define GC_RETURN_REGISTER 0x1u
#define GC_TAGGING_SHIFT 14u
#define GC_TAGGING_MASK 0x1fu

    overwrite =
      ((instr2 & (~(GC_TAGGING_MASK << GC_TAGGING_SHIFT)))
       | (GC_RETURN_REGISTER << GC_TAGGING_SHIFT));

    /* was the allocation routine in a leaf procedure? */

#define GC_ENTRY_LEAF_MASK 0x3f
#define GC_ENTRY_LEAF_SHIFT 19
#define GC_ENTRY_LEAF_VALUE 2

    leaf = (((instr2 & (GC_ENTRY_LEAF_MASK << GC_ENTRY_LEAF_SHIFT))
		 >> GC_ENTRY_LEAF_SHIFT) == GC_ENTRY_LEAF_VALUE);

    if (leaf) {
      scp->sc_pc = (int)gc_trap_entry_leaf;
      scp->sc_npc = ((int)gc_trap_entry_leaf)+4;
      *gc_trap_ret_leaf_overwrite = overwrite;
    } else {
      scp->sc_pc = (int)gc_trap_entry;
      scp->sc_npc = ((int)gc_trap_entry)+4;
      *gc_trap_ret_overwrite = overwrite;
    }
    return;
  }

  /* Not a GC trap, so what was it? */

  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  /* Switch on the instruction code: SPARC specific */

  switch(instruction & 0xC1F80000)
  {
    case 0x81180000:
    DIAGNOSTIC(1, "  tsubcctv", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
    break;

    case 0x81100000:
    DIAGNOSTIC(1, "  taddcctv", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
    break;

    default:
    DIAGNOSTIC(1, "  not a tagged trap int instruction", 0, 0);
    message("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
}
#endif

/* == Licensing support ==
 * 
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */
d363 1
a363 1
  (int sig, int code, struct sigcontext *scp, word *addr)
d367 2
a368 2
  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig, code);
  DIAGNOSTIC(4, "         child = %d)", signal_license_child_pid, 0);
d386 1
a386 2
  if(available)
  {
d403 1
a403 1
    (int sig, int code, struct sigcontext *scp, word *addr)
d424 1
a424 1
  struct sigaction sv;
d426 4
a429 4
  sv.sa_handler = signal_license_child_handler;
  sv.sa_mask = 0;
  sv.sa_flags = 0;
  if(sigaction(SIGCHLD, &sv, NULL) == -1)
d431 1
a431 1
	  "sigvec set errno to %d.", errno);
d440 4
a443 1
  struct sigaction sv;
a446 1
  int i;
d448 3
a450 2
  sv.sa_mask = 0;
  sv.sa_flags = 0;
d454 5
a458 6
  
  sv.sa_handler = SIG_IGN;
  for(i=1; i<NSIG; ++i)
    if (i != SIGALRM)
      /* SIGKILL and SIGSTOP are not blocked by this */
      sigblock(sigmask(i));
d461 1
a461 1
  signal_license_alarm_handler (0,0,NULL,NULL);
d464 1
a464 3
  
  sv.sa_handler = signal_license_alarm_handler;
  if(sigaction(SIGALRM, &sv, NULL) == -1)
d522 1
a522 3
static void signal_interval_alarm (int sig, int sig_code,
				  struct sigcontext *scp,
				  char *addr)
a567 30
/* a generic routine to make a new copy of some code */

static inline word* copy_code(char* start, char* finish)
{
  unsigned int bytes = finish-start;
  word *result = (word*)malloc(bytes);
  memcpy(result,start,bytes);
  return result;
}

/* copy the two GC return codes into the data segment */

static inline void copy_codes(void)
{
#if 0
  gc_trap_ret_code = copy_code((char*) &gc_trap_ret_template,
			       (char*) &gc_trap_ret_template_end);
  gc_trap_ret_leaf_code = copy_code((char*) &gc_trap_ret_leaf_template,
				    (char*) &gc_trap_ret_leaf_template_end);

  gc_trap_ret_overwrite = (word*) (((int)gc_trap_ret_code) +
				   ((int)&gc_trap_ret_template_overwrite) -
				   ((int)&gc_trap_ret_template));
  gc_trap_ret_leaf_overwrite =
    (word*) (((int)gc_trap_ret_leaf_code) +
	     ((int)&gc_trap_ret_leaf_template_overwrite)-
	     ((int)&gc_trap_ret_leaf_template));
#endif
}

a568 1

d570 3
a572 37
  struct sigaction sv;
/*
  struct sigstack ss;
*/
  char *signal_stack;

  /* establish integer arithmetic exception catcher */

#if 0
  sv.sa_handler = signal_integer_exception_handler;
  sv.sa_mask = 0;
  sv.sa_flags = SA_STACK;

  if(sigaction(SIGEMT, &sv, NULL) == -1)
    error("Unable to set integer exception handler.  "
          "sigaction set errno to %d.", errno);
#endif
  /* establish real arithmetic exception catcher */

#if 0
  if(ieee_handler("set", "common",
		  (sigfpe_handler_type) signal_real_exception_handler))
    error("Unable to set floating point exception handler.  "
	  "ieee_handler set errno to %d.", errno);
#endif
  /* Initialise the signal stack */

#if 0
  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack in profiler.");

  ss.ss_sp = signal_stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);
#endif
d574 4
a577 1
  /* make copies of GC return codes */
d579 2
a580 1
  copy_codes();
a584 1
  die_on_signal (SIGBUS);
a589 1
  signal_reserve (SIGBUS);	/* fatal */
a590 4
#if 0
  signal_reserve (SIGEMT);	/* integer exceptions */
#endif
  signal_reserve (SIGFPE);	/* real exceptions */
@


1.9
log
@Update best-before date.
@
text
@d14 3
d788 1
a788 1
    profile_scan((struct stack_frame *) CURRENT_THREAD->ml_state.sp);
@


1.8
log
@Remove an X-Windows line.
@
text
@d14 3
d611 1
a611 1
#define BEST_BEFORE	804553200	/* 1995-07-01 00:00 */
@


1.7
log
@If signal_ml_handler is called while we are waiting for an X event,
the runtime just prints a message.  This avoids problems with pointer
grabs in X callbacks.
@
text
@d14 5
d218 1
d222 1
d237 1
d239 1
@


1.6
log
@Add thread_preemption_pending.
@
text
@d14 3
d77 1
d211 1
a211 4
  struct event *event = alloc(sizeof(struct event), "Couldn't allocate event");

  event->type = SIGNAL;
  event->the.signal = sig;
d213 12
a224 5
  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;
d226 2
a227 2
  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);
d229 2
a230 1
  record_event();
@


1.5
log
@Introduce the threads system.
@
text
@d14 3
d766 2
a767 1
  if (thread_preemption_on)
d769 1
@


1.4
log
@Amend best-before date to 1st July 1995.
Also fix Harlequin's telephone number.
Also make license signal handler run on the current stack.
@
text
@d14 5
d70 1
d194 7
d218 1
a218 2
  /* must set stack underflow here */
  implicit_vector.interrupt = -1;
d723 26
a748 5
/* == Profiling support ==
 * 
 * We provide a virtual-time alarm, which goes off after a
 * user-specified number of milliseconds. When it goes off, we call
 * profile_scan(), and restart the alarm when it returns. */
d750 2
a751 1
static struct itimerval profiler_timer;
d753 2
a754 1
/* The signal handler function. Note that we don't use the arguments at all */
d756 1
a756 1
static void signal_profiler_alarm (int sig, int sig_code,
d760 5
a764 3
/*
  profile_scan((struct stack_frame *) scp->sc_sp);
*/
d766 1
a766 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
d769 1
a769 1
/* start things off */
d771 1
a771 1
extern void signal_start_profiler_timer(unsigned int interval)
d773 2
a774 1
  struct sigaction vec = {signal_profiler_alarm, SIGVTALRM, SA_STACK};
d776 6
a781 2
  if(sigaction(SIGVTALRM, &vec, NULL) == -1)
    error("Unable to set up profiler signal handler.");
d783 1
a783 4
  profiler_timer.it_value.tv_sec = interval/1000;
  profiler_timer.it_value.tv_usec = (interval%1000)*1000;
  profiler_timer.it_interval.tv_sec = 0;
  profiler_timer.it_interval.tv_usec = 0; /* one shot timer */
d785 4
a788 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
d791 5
a795 1
/* kill the timer */
d797 1
a797 1
extern void signal_stop_profiler_timer(void)
d799 1
a799 20
  struct sigaction vec = {SIG_DFL, SIGVTALRM, SA_STACK};

  profiler_timer.it_value.tv_sec = profiler_timer.it_value.tv_usec = 0;
  profiler_timer.it_interval.tv_sec = profiler_timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
  {
    message("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    vec.sa_handler = SIG_IGN;

    if(sigaction(SIGVTALRM, &vec, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigaction set errno to %d).",
	    errno);
  }
  if(sigaction(SIGVTALRM, &vec, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message("Warning: Unable to reset alarm signal handler (sigaction set errno "
	    "to %d).", errno);
@


1.3
log
@Remove set_stack_underflow() call.
@
text
@d14 3
d575 1
a575 1
#define BEST_BEFORE	788918400	/* 1995-01-01 sometime */
d618 1
a618 1
	    "   telephone:        +44 223 872522");
d650 1
a650 1
  sv.sa_flags = SA_STACK;
@


1.2
log
@Remove gc trap stuff
@
text
@d14 3
d202 1
a202 1
  set_stack_underflow();
@


1.1
log
@new file
@
text
@d13 4
a16 1
 * $Log: src:OS:SunOS:arch:SPARC:signals.c,v $
a71 49
/* To enter garbage collection we cause a trap. The trap handler, in
   this file, sets up some variables and then calls one of these two
   asm functions: */

extern void gc_trap_entry(void);
extern void gc_trap_entry_leaf(void);

/* The first two things the trap handler sets up are these variables:

   gc_trap_bytes is the number of bytes requested by the GC entry code?
   (if this equals -1, the number of bytes is in register %g4.

   gc_trap_return_address is the value which should be in the register
   used as a link gc register when the GC code performs a jmpl to
   return to ML (i.e. it is the return address -8). */ 

word gc_trap_bytes;
word gc_trap_return_address;

/* The other thing set up by the trap handler is a routine through
   which the GC asm code should return to ML (one instruction in the
   appropriate routine has to be modified to tag the allocation result
   correctly). These two routines (leaf and non-leaf) are written in
   asm and copied into the data segment when we set up the signal
   handler.

   gc_trap_ret_template is the address of the asm
   routine. gc_trap_ret_template_end is where it
   ends. gc_trap_ret_template_overwrite is the address of the
   instruction the copy of which we want to modify.

   gc_trap_ret_code is the address of the data-segment copy of the
   code. gc_trap_ret_overwrite is the address of the instruction to
   modify. */

extern word gc_trap_ret_template, gc_trap_ret_template_end;
extern word gc_trap_ret_template_overwrite;

word *gc_trap_ret_code;
word *gc_trap_ret_overwrite;

/* the same, for the leaf case : */

extern word gc_trap_ret_leaf_template, gc_trap_ret_leaf_template_end;
extern word gc_trap_ret_leaf_template_overwrite;

word *gc_trap_ret_leaf_code;
word *gc_trap_ret_leaf_overwrite;

d787 1
d800 1
@
