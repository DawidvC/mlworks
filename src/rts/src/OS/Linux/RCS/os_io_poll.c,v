head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.1
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.7
	MLWorks_20c0_1998_08_04:1.7
	MLWorks_20b2c2_1998_06_19:1.7
	MLWorks_20b2_Windows_1998_06_12:1.7
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_MM_adapt:1.6.3
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.5.6.1.1.1.1
	MLWorks_workspace_97:1.6.2
	MLWorks_dt_wizard:1.6.1
	MLWorks_11c0_1997_09_09:1.5.6.1.1.1
	MLWorks_10r3:1.5.6.1.3
	MLWorks_10r2_551:1.5.6.1.2
	MLWorks_11:1.5.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.6.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.5.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.6
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.5
	MM_ML_release_korma_1997_04_01:1.5
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.5.4.1.1
	MLWorks_gui_1996_12_18:1.5.5
	MLWorks_1_0_Win32_1996_12_17:1.5.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.5.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.5.1.1
	JFHrts:1.5.3
	MLWorks_1_0_Irix_1996_11_28:1.5.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.5.2
	MLWorks_1_0_Unix_1996_11_14:1.5.1
	MLWorks_Open_Beta2_1996_10_11:1.4.1
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.2
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.8
date	98.09.30.14.20.37;	author jont;	state Exp;
branches
	1.8.1.1;
next	1.7;

1.7
date	98.02.24.11.19.01;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	97.05.22.09.12.02;	author johnh;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	96.10.24.08.36.49;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1
	1.5.5.1
	1.5.6.1;
next	1.4;

1.4
date	96.10.08.10.35.59;	author stephenb;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	96.07.05.13.15.08;	author stephenb;	state Exp;
branches
	1.3.1.1
	1.3.2.1;
next	1.2;

1.2
date	96.05.24.11.17.10;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.05.07.12.19.38;	author stephenb;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.22.53;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.13.03;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.10.17.11.32.18;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	96.11.14.12.58.14;	author hope;	state Exp;
branches
	1.5.1.1.1.1;
next	;

1.5.1.1.1.1
date	96.11.28.15.08.10;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.11.22.18.15.51;	author hope;	state Exp;
branches;
next	;

1.5.3.1
date	96.12.17.10.02.35;	author hope;	state Exp;
branches;
next	;

1.5.4.1
date	96.12.17.17.54.17;	author hope;	state Exp;
branches
	1.5.4.1.1.1;
next	;

1.5.4.1.1.1
date	97.02.24.11.45.20;	author hope;	state Exp;
branches;
next	;

1.5.5.1
date	96.12.18.09.48.53;	author hope;	state Exp;
branches;
next	;

1.5.6.1
date	97.05.12.10.41.16;	author hope;	state Exp;
branches
	1.5.6.1.1.1
	1.5.6.1.2.1
	1.5.6.1.3.1;
next	;

1.5.6.1.1.1
date	97.07.28.18.28.49;	author daveb;	state Exp;
branches
	1.5.6.1.1.1.1.1;
next	;

1.5.6.1.1.1.1.1
date	97.10.07.11.54.42;	author jkbrook;	state Exp;
branches;
next	;

1.5.6.1.2.1
date	97.09.08.17.21.46;	author daveb;	state Exp;
branches;
next	;

1.5.6.1.3.1
date	97.09.09.14.17.51;	author daveb;	state Exp;
branches;
next	;

1.6.1.1
date	97.09.10.19.37.04;	author brucem;	state Exp;
branches;
next	;

1.6.2.1
date	97.09.11.21.05.08;	author daveb;	state Exp;
branches;
next	;

1.6.3.1
date	97.10.31.13.48.10;	author nickb;	state Exp;
branches;
next	;

1.8.1.1
date	99.04.01.18.03.54;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.8
log
@[Bug #70108]
Add include of syscalls.h to get round problems in Red Hat 5 with struct timespec
@
text
@/* Copyright (C) 1996 Harlequin Ltd
 *
 * Implements most of OS.IO.poll using select since Linux doesn't support poll.
 * This overrides the version in rts/src/OS/Unix/os_io_poll.[ch] that is
 * implemented using poll.
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Linux:os_io_poll.c,v $
 * Revision 1.7  1998/02/24  11:19:01  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.6  1997/05/22  09:12:02  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
 * Revision 1.4  1996/10/08  10:35:59  stephenb
 * [Bug #1561]
 *   Problem: the select call was always indicating that
 *   there were no events detected for the given file descriptors.
 *
 *   Cause: the first argument to select was the number of file
 *   descriptors to check for events on.  This is correct according to
 *   the Linux manual page, but doesn't produce the desired results.
 *
 *   Fix: change the first argument to be the maximum file descriptor + 1
 *   (as indicated in Advanded Programming in the Unix Environment -
 *   W. Richard Stevens).
 *
 *   Removed some redundant (due to rts.alloc.rule.hybrid.args)
 *   declare/retract root calls and added some assertions to ensure that
 *   if the type does change in the future such that the declare/retract
 *   calls are necessary the result will be an easy to diagnose assertion
 *   rather than a mysterious and hard to reproduce GC error.
 *
 * Revision 1.3  1996/07/05  13:15:08  stephenb
 * Fix #1427 - poll doesn't filter descriptors.
 * Also added declare/retract_roots where necessary.
 *
 * Revision 1.2  1996/05/24  11:17:10  stephenb
 * Various changes to bring it into line with a post March 1996 basis spec.
 * These include: removing pollErr, introducing pollPri and isPri and making
 * poll raise SysErr if there are any errors.
 *
 * Revision 1.1  1996/05/07  12:19:38  stephenb
 * new unit
 *
 */


#include "syscalls.h"
#include <string.h>		/* strerror might be here */
#include <assert.h>		/* assert */
#include <errno.h>		/* errno and maybe strerror */
#include <sys/types.h>		/* select */
#include <sys/time.h>		/* select */
#include <unistd.h>		/* select */
#include "values.h"		/* FIELD, MLTAIL, mlw_cons ... etc.*/
#include "exceptions.h"		/* exn_raise_syserr */
#include "environment.h"	/* env_function ... etc. */
#include "allocator.h"		/* allocate_record, ml_string */
#include "gc.h"			/* declare_root */
#include "time_date.h"		/* mlw_time_make,mlw_time_sec,mlw_time_usec */
#include "os_io_poll.h"		/* os_poll_io_init */



/*
 * datatype event_set = EVENT_SET of int
 * datatype poll_desc = POLL_DESC of io_desc * event_set
 * datatype poll_info = POLL_INFO of poll_desc * event_set
 */
#define mlw_poll_desc_make() allocate_record(2)
#define mlw_poll_desc_fd(poll_desc) FIELD(poll_desc, 0)
#define mlw_poll_desc_events(poll_desc) FIELD(poll_desc, 1)

#define mlw_poll_info_make() allocate_record(2)
#define mlw_poll_info_desc(poll_info) FIELD(poll_info, 0)
#define mlw_poll_info_revents(poll_info) FIELD(poll_info, 1)



/*
 * The SML interface is based on SysV poll which is defined in terms of
 * event sets which indicate the type of events you are interested in.
 * The following codes are used to represent the three types of event
 * that SML knows about.  Note that the codes should have values of the 
 * form 2**n with each value being distinct and n in the range
 * [1, ML_MAX_INT_BITS].  This is so that it is easy to use bit masking
 * to check if a given value is defined.
 */
#define mlw_poll_event_in  0x1
#define mlw_poll_event_out 0x2
#define mlw_poll_event_pri 0x4


/* The final event type is the empty event and
 * should always have the value 0
 */
#define mlw_poll_event_none 0x0



/* An io_desc is currently implemented as an integer.
 * Because of this there is no need to declare as a root
 * any io_desc that is an argument to a function in which
 * any allocation is done.  However, to ensure that the
 * code doesn't break in mysterious ways should the 
 * structure of an io_desc change, the following should
 * be sprinkled liberally around the code to ensure that
 * if the representation does change we get to know about
 * it here straight away.
 */
#define mlw_os_io_poll_is_io_desc(arg) (!MLVALISPTR(arg))


/*
 * Implements OS.IO.pollDesc: io_desc -> poll_desc option
 *
 * XXX: Currently makes no attempt to check if the descriptor is suitable
 * for polling.  In a private message Reppy suggested that fstat could
 * be used to determine if the descriptor is suitable.
 */
static mlval mlw_os_io_poll_desc(mlval arg)
{
  mlval poll_desc;

  assert(mlw_os_io_poll_is_io_desc(arg));
  poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(poll_desc)= arg;
  mlw_poll_desc_events(poll_desc)= MLINT(mlw_poll_event_none);

  return mlw_option_make_some(poll_desc);
}




/*
 * OS.IO.pollIn: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_in(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;  

  assert(mlw_os_io_poll_is_io_desc(io_desc));

  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_in);
  return new_poll_desc;
}



/*
 * OS.IO.pollOut: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_out(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_out);
  return new_poll_desc;
}



/*
 * OS.IO.pollPri: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_pri(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_pri);
  return new_poll_desc;
}



/*
 * OS.IO.poll: (poll_desc list * Time.time option) -> poll_info list
 *
 * NOTE: The Linux manual page states that the first argument to select
 * should be "numfds" but does not expand on that.  If this is taken
 * literally to be the number of file descriptors, then you won't get
 * the correct results.  As is stated in :-
 *
 *   Advanced Unix Programming in the Unix Environment
 *   W. Richard Stevens
 *   Addison Wesley
 *
 * the first argument actually should be the maximum file descriptor
 * plus one.
 */
static mlval mlw_os_io_poll(mlval arg)
{
  mlval poll_descs= FIELD(arg, 0);
  mlval optional_timeout= FIELD(arg, 1);
  mlval poll_infos= MLNIL;
  mlval l;
  int status;
  int max_fd= -1;
  fd_set in_fds, out_fds, pri_fds;

  FD_ZERO(&in_fds);
  FD_ZERO(&out_fds);
  FD_ZERO(&pri_fds);
  for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l)) {
    mlval poll_desc= MLHEAD(l);
    int fd= CINT(mlw_poll_desc_fd(poll_desc));
    int events= CINT(mlw_poll_desc_events(poll_desc));
    if (fd > max_fd)
      max_fd= fd;
    if (events&mlw_poll_event_in)
      FD_SET(fd, &in_fds);
    if (events&mlw_poll_event_out)
      FD_SET(fd, &out_fds);
    if (events&mlw_poll_event_pri)
      FD_SET(fd, &pri_fds);
  }

  if (mlw_option_is_none(optional_timeout)) {
    status= select(max_fd+1, &in_fds, &out_fds, &pri_fds, NULL);
  } else {
    mlval timeout= mlw_option_some(optional_timeout);
    struct timeval tv;
    tv.tv_sec= mlw_time_sec(timeout);
    tv.tv_usec= mlw_time_usec(timeout);
    status= select(max_fd+1, &in_fds, &out_fds, &pri_fds, &tv);
  }

  if (status < 0) {
    exn_raise_syserr(ml_string(strerror(errno)), errno);
  } else if (status > 0) {
    declare_root(&l, 0);
    declare_root(&poll_infos, 0);
    for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l)) {
      mlval poll_desc= MLHEAD(l);
      int fd= CINT(mlw_poll_desc_fd(poll_desc));
      int events= CINT(mlw_poll_desc_events(poll_desc));
      int revents= 0;
      if (events&mlw_poll_event_in && FD_ISSET(fd, &in_fds))
	revents |= mlw_poll_event_in;
      if (events&mlw_poll_event_out && FD_ISSET(fd, &out_fds))
	revents |= mlw_poll_event_out;
      if (events&mlw_poll_event_pri && FD_ISSET(fd, &pri_fds))
	revents |= mlw_poll_event_pri;
      if (revents != 0) {
	mlval poll_info= mlw_poll_info_make();
	mlw_poll_info_desc(poll_info)= MLHEAD(l);
	mlw_poll_info_revents(poll_info)= MLINT(revents);
	poll_infos= mlw_cons(poll_info, poll_infos);
      } else {
	/* no events detected for this descriptor */
      }
    }
    retract_root(&poll_infos);
    retract_root(&l);
  } else {
    /* timeout or no events for any descriptor, just return the empty list */
  }

  return poll_infos;
}




/*
 * OS.IO.isIn: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_in(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_in);
}



/*
 * OS.IO.isOut: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_out(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_out);
}



/*
 * OS.IO.isPri: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_pri(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_pri);
}




void mlw_os_io_poll_init(void)
{
  env_function("OS.IO.pollDesc", mlw_os_io_poll_desc);
  env_function("OS.IO.pollIn",   mlw_os_io_poll_in);
  env_function("OS.IO.pollOut",  mlw_os_io_poll_out);
  env_function("OS.IO.pollPri",  mlw_os_io_poll_pri);
  env_function("OS.IO.poll",     mlw_os_io_poll);
  env_function("OS.IO.isIn",     mlw_os_io_is_in);
  env_function("OS.IO.isOut",    mlw_os_io_is_out);
  env_function("OS.IO.isPri",    mlw_os_io_is_pri);
}
@


1.8.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.8  1998/09/30  14:20:37  jont
 * [Bug #70108]
 * Add include of syscalls.h to get round problems in Red Hat 5 with struct timespec
 *
@


1.7
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d11 5
d58 2
d61 1
a61 1
#include <errno.h>		/* errno */
@


1.6
log
@[Bug #01702]
Changed definition of exn_raise_syserr.
@
text
@d11 4
d252 2
a253 2
    declare_root(&l);
    declare_root(&poll_infos);
@


1.6.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a10 4
 * Revision 1.6  1997/05/22  09:12:02  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.6.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.6  1997/05/22  09:12:02  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.6.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.6  1997/05/22  09:12:02  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr.
 *
@


1.5
log
@[Bug #1701]
mlw_os_io_poll_desc: remove redundant declare/retract_root.
@
text
@d11 4
d57 1
a57 1
#include "allocator.h"		/* allocate_record */
d246 1
a246 1
    exn_raise_syserr(strerror(errno), errno);
@


1.5.6.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.5.6.1  1997/05/12  10:41:16  hope
 * branched from 1.5
 *
@


1.5.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.5.6.1  1997/05/12  10:41:16  hope
 * branched from 1.5
 *
@


1.5.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.5.6.1  1997/05/12  10:41:16  hope
 * branched from 1.5
 *
@


1.5.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.5.6.1.1.1  1997/07/28  18:28:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.5.5.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.4.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.4.1.1.1
log
@branched from 1.5.4.1
@
text
@a10 3
 * Revision 1.5.4.1  1996/12/17  17:54:17  hope
 * branched from 1.5
 *
@


1.5.3.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.2.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/10/24  08:36:49  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.5.1.1.1.1
log
@branched from 1.5.1.1
@
text
@a10 3
 * Revision 1.5.1.1  1996/11/14  12:58:14  hope
 * branched from 1.5
 *
@


1.4
log
@[Bug #1561]
  Problem: the select call was always indicating that
  there were no events detected for the given file descriptors.

  Cause: the first argument to select was the number of file
  descriptors to check for events on.  This is correct according to
  the Linux manual page, but doesn't produce the desired results.

  Fix: change the first argument to be the maximum file descriptor + 1
  (as indicated in Advanded Programming in the Unix Environment -
  W. Richard Stevens).

  Removed some redundant (due to rts.alloc.rule.hybrid.args)
  declare/retract root calls and added some assertions to ensure that
  if the type does change in the future such that the declare/retract
  calls are necessary the result will be an easy to diagnose assertion
  rather than a mysterious and hard to reproduce GC error.
@
text
@d11 19
d118 1
a118 1
  mlval option, poll_desc;
d125 1
a125 5
  declare_root(&poll_desc);
  option= mlw_option_make_some(poll_desc);
  retract_root(&poll_desc);

  return option;
@


1.4.1.1
log
@branched from 1.4
@
text
@a10 19
 * Revision 1.4  1996/10/08  10:35:59  stephenb
 * [Bug #1561]
 *   Problem: the select call was always indicating that
 *   there were no events detected for the given file descriptors.
 *
 *   Cause: the first argument to select was the number of file
 *   descriptors to check for events on.  This is correct according to
 *   the Linux manual page, but doesn't produce the desired results.
 *
 *   Fix: change the first argument to be the maximum file descriptor + 1
 *   (as indicated in Advanded Programming in the Unix Environment -
 *   W. Richard Stevens).
 *
 *   Removed some redundant (due to rts.alloc.rule.hybrid.args)
 *   declare/retract root calls and added some assertions to ensure that
 *   if the type does change in the future such that the declare/retract
 *   calls are necessary the result will be an easy to diagnose assertion
 *   rather than a mysterious and hard to reproduce GC error.
 *
@


1.3
log
@Fix #1427 - poll doesn't filter descriptors.
Also added declare/retract_roots where necessary.
@
text
@d11 4
d26 1
a26 1
#include <assert.h>
d28 4
a31 3
#include <sys/types.h>		/* select, fd_set */
#include <sys/time.h>		/* struct timeval */
#include "values.h"		/* FIELD, MLTAIL, cons ... etc.*/
d77 13
d101 1
a101 1
  declare_root(&arg);
a103 1
  retract_root(&arg);
d123 4
a126 1
  mlval new_poll_desc;
a127 1
  declare_root(&arg);
d129 1
a129 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a130 1
  retract_root(&arg);
d143 1
d146 1
a146 1
  declare_root(&arg);
d148 1
a148 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a149 1
  retract_root(&arg);
d162 1
d165 1
a165 1
  declare_root(&arg);
d167 1
a167 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a168 1
  retract_root(&arg);
d177 11
a187 1
 * XXX: optimise the use of declare/retract_root
d196 1
a196 1
  int nfds;
d202 1
a202 1
  for (l= poll_descs, nfds= 0; !MLISNIL(l); l= MLTAIL(l), nfds += 1) {
d206 2
d217 1
a217 1
    status= select(nfds, &in_fds, &out_fds, &pri_fds, NULL);
d223 1
a223 1
    status= select(nfds, &in_fds, &out_fds, &pri_fds, &tv);
d229 3
a231 2
    size_t i= 0;
    for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l), i += 1) {
d243 2
a244 6
	mlval poll_info;
	declare_root(&l);
	declare_root(&poll_infos);
	poll_info= mlw_poll_info_make();
	retract_root(&poll_infos);
	mlw_poll_info_desc(poll_info)= poll_desc;
d246 3
a248 2
	poll_infos= cons(poll_info, poll_infos);
	retract_root(&l);
d251 2
d254 1
a254 1
    /* timeout or no descriptors so just return the empty list */
d270 1
a270 1
  return (revents&mlw_poll_event_in) ? MLTRUE : MLFALSE;
d282 1
a282 1
  return (revents&mlw_poll_event_out) ? MLTRUE : MLFALSE;
d294 1
a294 1
  return (revents&mlw_poll_event_pri) ? MLTRUE : MLFALSE;
@


1.3.2.1
log
@branched from 1.3
@
text
@a10 4
 * Revision 1.3  1996/07/05  13:15:08  stephenb
 * Fix #1427 - poll doesn't filter descriptors.
 * Also added declare/retract_roots where necessary.
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a10 4
 * Revision 1.3  1996/07/05  13:15:08  stephenb
 * Fix #1427 - poll doesn't filter descriptors.
 * Also added declare/retract_roots where necessary.
 *
@


1.2
log
@Various changes to bring it into line with a post March 1996 basis spec.
These include: removing pollErr, introducing pollPri and isPri and making
poll raise SysErr if there are any errors.
@
text
@d11 5
d41 1
a41 1
#define mlw_make_poll_desc() allocate_record(2)
d45 1
a45 1
#define mlw_make_poll_info() allocate_record(2)
d83 2
a84 1
  poll_desc= mlw_make_poll_desc();
d86 1
d106 4
a109 1
  mlval new_poll_desc= mlw_make_poll_desc();
d112 1
d125 4
a128 1
  mlval new_poll_desc= mlw_make_poll_desc();
d131 1
d144 4
a147 1
  mlval new_poll_desc= mlw_make_poll_desc();
d150 1
d159 1
a159 2
 * XXX: change this to only create a poll_info for a poll_desc for
 * which an event has occured.
a200 1
      mlval poll_info= mlw_make_poll_info();
d211 11
a221 3
      mlw_poll_info_desc(poll_info)= poll_desc;
      mlw_poll_info_revents(poll_info)= MLINT(revents);
      poll_infos= cons(poll_info, poll_infos);
d270 1
a270 1
extern void mlw_os_io_poll_init(void)
@


1.1
log
@new unit
@
text
@d10 4
a13 1
 * $Log$
d55 4
a58 3
#define mlw_poll_event_in   0x1
#define mlw_poll_event_out  0x2
#define mlw_poll_event_err  0x4
d71 2
a72 1
 * for polling.
d123 1
a123 1
 * OS.IO.pollErr: poll_desc -> poll_desc
d126 1
a126 1
static mlval mlw_os_io_poll_err(mlval arg)
d131 1
a131 1
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_err);
d139 3
d151 1
a151 1
  fd_set in_fds, out_fds, err_fds;
d155 1
a155 1
  FD_ZERO(&err_fds);
d164 2
a165 2
    if (events&mlw_poll_event_err)
      FD_SET(fd, &err_fds);
d169 1
a169 1
    status= select(nfds, &in_fds, &out_fds, &err_fds, NULL);
d175 1
a175 1
    status= select(nfds, &in_fds, &out_fds, &err_fds, &tv);
d192 2
a193 2
      if (events&mlw_poll_event_err && FD_ISSET(fd, &err_fds))
	revents |= mlw_poll_event_err;
d233 1
a233 1
 * OS.IO.isErr: poll_info -> bool
d236 1
a236 1
static mlval mlw_os_io_is_err(mlval arg)
d239 1
a239 1
  return (revents&mlw_poll_event_err) ? MLTRUE : MLFALSE;
d250 1
a250 1
  env_function("OS.IO.pollErr",  mlw_os_io_poll_err);
d254 1
a254 1
  env_function("OS.IO.isErr",    mlw_os_io_is_err);
@
