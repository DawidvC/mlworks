head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.1
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.2
	MLWorks_20c0_1998_08_04:1.2
	MLWorks_20b2c2_1998_06_19:1.2
	MLWorks_20b2_Windows_1998_06_12:1.2
	MLWorks_20b1c1_1998_05_07:1.2
	MLWorks_20b0_1998_04_07:1.1
	MLWorks_20b0_1998_03_20:1.1
	MLWorks_20m2_1998_02_16:1.1
	MLWorks_MM_adapt:1.1.12
	MLWorks_20m1_1997_10_23:1.1
	MLWorks_workspace_97:1.1.11
	MLWorks_dt_wizard:1.1.10
	MLWorks_10r3:1.1.9.1.3
	MLWorks_10r2_551:1.1.9.1.2
	MLWorks_11:1.1.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.1.9.1
	MLWorks_20m0_1997_06_20:1.1
	MLWorks_1_0_r2c2_1997_06_14:1.1.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.1.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.1.9
	MLWorks_BugFix_1997_04_24:1.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.1
	MLWorks_1_0_r2_Unix_1997_04_04:1.1
	MM_ML_release_korma_1997_04_01:1.1
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.1.7.1.1
	MLWorks_gui_1996_12_18:1.1.8
	MLWorks_1_0_Win32_1996_12_17:1.1.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.1.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.1.4.1
	JFHrts:1.1.6
	MLWorks_1_0_Irix_1996_11_28:1.1.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.1.5
	MLWorks_1_0_Unix_1996_11_14:1.1.4
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ * @;


1.3
date	98.09.30.11.53.11;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	97.09.11.15.38.12;	author jkbrook;	state Exp;
branches;
next	1.1;

1.1
date	96.05.10.12.48.50;	author brianm;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1
	1.1.5.1
	1.1.6.1
	1.1.7.1
	1.1.8.1
	1.1.9.1
	1.1.10.1
	1.1.11.1
	1.1.12.1;
next	;

1.1.1.1
date	96.09.13.11.22.25;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.12.31;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.31.31;	author hope;	state Exp;
branches;
next	;

1.1.4.1
date	96.11.14.12.57.29;	author hope;	state Exp;
branches
	1.1.4.1.1.1;
next	;

1.1.4.1.1.1
date	96.11.28.15.07.36;	author hope;	state Exp;
branches;
next	;

1.1.5.1
date	96.11.22.18.15.18;	author hope;	state Exp;
branches;
next	;

1.1.6.1
date	96.12.17.10.02.03;	author hope;	state Exp;
branches;
next	;

1.1.7.1
date	96.12.17.17.53.47;	author hope;	state Exp;
branches
	1.1.7.1.1.1;
next	;

1.1.7.1.1.1
date	97.02.24.11.44.47;	author hope;	state Exp;
branches;
next	;

1.1.8.1
date	96.12.18.09.48.22;	author hope;	state Exp;
branches;
next	;

1.1.9.1
date	97.05.12.10.40.45;	author hope;	state Exp;
branches
	1.1.9.1.1.1
	1.1.9.1.2.1
	1.1.9.1.3.1;
next	;

1.1.9.1.1.1
date	97.07.28.18.25.35;	author daveb;	state Exp;
branches;
next	;

1.1.9.1.2.1
date	97.09.08.17.18.49;	author daveb;	state Exp;
branches;
next	;

1.1.9.1.3.1
date	97.09.09.14.14.57;	author daveb;	state Exp;
branches;
next	1.1.9.1.3.2;

1.1.9.1.3.2
date	97.09.11.15.38.12;	author jkbrook;	state Exp;
branches;
next	;

1.1.10.1
date	97.09.10.19.31.45;	author brucem;	state Exp;
branches;
next	;

1.1.11.1
date	97.09.11.21.01.08;	author daveb;	state Exp;
branches;
next	;

1.1.12.1
date	97.10.31.13.44.08;	author nickb;	state Exp;
branches;
next	;

1.3.1.1
date	99.04.01.18.00.59;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Moved from architecture specific location.
@


1.3
log
@[Bug #70108]
Acquire libelf.h from the correct place, ie libelf/libelf.h
@
text
@/*  ==== FOREIGN OBJECT LOADER ====
 *
 *  Copyright (C) 1997 The Harlequin Group Ltd.  All rights reserved.
 *
 *  Implementation  (* Linux *)
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.2  1997/09/11  15:38:12  jkbrook
 * [Bug #30354]
 * Merge from MLWorks_10r3:
 * Port of old FI to Linux
 *
 * Revision 1.1.9.1.3.2  1997/09/11  15:38:12  jkbrook
 * [Bug #30262]
 * Adapted from Solaris version for use under Linux
 *
 * Revision 1.1.9.1.3.1  1997/09/09  14:14:57  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
 * Revision 1.1.9.1  1997/05/12  10:40:45  hope
 * branched from 1.1
 *
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
 * Revision 1.4  1996/04/19  15:36:44  jont
 * Add check_big_endian function
 *
 * Revision 1.3  1995/03/24  12:20:24  brianm
 * Adding prototypes due to modification of header file.
 * Simplified code to yield `unimplemented' exception.
 *
 * Revision 1.2  1995/03/08  14:59:04  brianm
 * Minor corrections
 *
 * Revision 1.1  1995/03/01  10:57:04  brianm
 * new unit
 *  Foreign Object loading routines
 *
 */

#include <assert.h>
#include "mltypes.h"
#include "allocator.h"
#include "values.h"
#include "diagnostic.h"
#include "exceptions.h"
#include "environment.h"
#include "words.h"
#include "foreign_loader.h"

#include <dlfcn.h>      /* Run-Time Dynamic Linking libraries */ 
#include <libelf/libelf.h>     /* ELF libraries -- Linux            */

#include <fcntl.h>
#include <unistd.h>

/* Macros */


#define INDEXPTR(base,index,size)  ((unsigned long int)(base) + ((size)*(index)))

#define bit(a)                     (1u << (a))
#define bitblk(hi,lo)              (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)               ((x) & (m))
#define rshift(x,lo)               ((unsigned)(x) >> (lo))
#define getbitblk(u,hi,lo)         (appmask(rshift((u),(lo)),bitblk(1+(hi) - (lo),0)))

/* Local Procedure/Function stub decls. */

static void  setup_symtab(Elf *,Elf_Scn *,Elf_Scn*,int);
static char  *show_symtab_type(unsigned char);
static void  show_errmsg(void);

static mlval pack_foreign_value(void *);
static void  *unpack_foreign_value(mlval);


/* Forward decls. of exported ML functions */

static mlval load_foreign_object(mlval);
static mlval lookup_foreign_value(mlval);
static mlval call_unit_function(mlval);
static mlval call_foreign_function(mlval);

static mlval open_symtab_file(mlval);
static mlval next_symtab_entry(mlval);
static mlval close_symtab_file(mlval);

/* Definitions */


#define raise_error(str)   exn_raise_string(perv_exn_ref_value, (str))


enum load_mode {load_later, load_now};

typedef enum load_mode load_mode;


/* ==== <ML> load_foreign_object : (string * load_mode) -> foreign_object
 *
 *  Given a pathname (as a string), this dynamiclly links, using the
 *  specified load_mode, the executable object file and returns a
 *  foreign_object pointer.
 */
static mlval load_foreign_object(mlval argument)
{
   char      *path;
   unsigned  *handle;
   mlval result;

   load_mode lmode;
   int mode = RTLD_LAZY;

   path = CSTRING(FIELD(argument,0));
   lmode = CINT(FIELD(argument,1));

   switch (lmode) {
      case load_later  : mode = RTLD_LAZY; break;
      case load_now    : mode = RTLD_NOW;  break;
   }

   handle = (unsigned *)dlopen(path,mode);

   if (handle == NULL) raise_error("Shared object not found ...\n");

   result = allocate_word32();
   num_to_word32((unsigned)handle,result);
 
   return(result);
}

/* ==== <ML> lookup_foreign_value : (foreign_object * string) -> foreign_value
 *
 *  Given a name (as a ML string) and a foreign object, this looks up
 *  the foreign value within the given foreign object.
 */
static mlval lookup_foreign_value(mlval arg)
{
   mlval fstruct, word;
   char *name;
   void *object;

   fstruct = FIELD(arg,0);
   name    = CSTRING(FIELD(arg,1));

   word    = FIELD(fstruct,2);

   object  = dlsym((void *)word32_to_num(word),name);

   if (object == NULL) raise_error("Named value not found in object.\n");

   return(pack_foreign_value(object));
}

/* ==== <ML> call_unit_function : foreign_object -> unit
 *
 *  Calls a foreign unit function (included for testing purposes only).
 */
static mlval call_unit_function(mlval f_val)
{
   void (*f)(void);

   f = (void (*)(void))unpack_foreign_value(f_val);
   (*f)();

   return(MLUNIT);
}


/* ==== <ML> call_foreign_function : (function * memory * int * memory) -> unit
 *
 *  Calls a foreign function on a given array of (4 byte) argument values and
 *  returning a 4 byte value.  The integer argument specifies the number of
 *  arguments to be passed.
 */
static mlval call_foreign_function(mlval f_arg)
{
   void *ffun;
   void *argv;
   int argc;
   unsigned *result;
   int i;
   int *data;

   ffun     =      (void *)unpack_foreign_value(FIELD(f_arg, 0));
   argv     =      (void *)unpack_foreign_value(FIELD(f_arg, 1));
   argc     =         CINT(FIELD(f_arg, 2));
   result   =  (unsigned *)unpack_foreign_value(FIELD(f_arg, 3));

   data = argv;
   i=0;
#if 0
   printf("<C>call_foreign_function ... \n");

   printf("argv = %i = 0x%x\n",(int)argv,(unsigned)argv);
   printf("argc = %i\n", argc);
   
   for (i=0;i<argc;i++)
      printf("  ARG[ %i ] = %i = 0x%x\n",i,(int)data[i],(unsigned)data[i]);
#endif

   *result  =  (unsigned)call_ffun(ffun,argv,argc);

   return(MLUNIT);
}

extern mlval call_ffun_error(int argv)
{
   fprintf(stderr,"Too many args to foreign function:\n");
   fprintf(stderr,"Number of supplied args = %i (max: %i)\n",argv,MAX_FI_ARG_LIMIT);
   return(MLINT(0));
}


/* ==== <ML> check_big_endian : unit -> bool
 *
 *  Returns true for big_endian encoding 
 *
 */
static mlval check_big_endian (mlval argument)
{
   unsigned i = 1;
   char *bytes;

   bytes = (char *)&i;

   if (0 != bytes[3]) { return(MLTRUE); };

   return(MLFALSE);
}


/* OS specific -- Linux */
/* Uses: ELF             */

/* ==== Extracting a symbol table ====

   The intention in the following code is to produce a stream of strings
   extracted from an ELF file as part of creating an ML version of the
   symbol table info.  However, to avoid complications with ML's GC, we
   need to avoid ML list creation within C.

   The idea is that we provide ML-usable routines for:

     - opening an ELF format file.

     - getting the next symtab entry (as an ML string ...), returning
       the null string at the end.

     - closing the ELF format file.

   and then ML uses these to generate an ML list from ML - which will
   then be GC-safe.  (Creating ML objects in C can invalidate mlval
   objects since the GC can move them around - suitable care is needed to
   make C copies of data.)

   To simplify the ML interface, some state is maintained in C for this.
   This means that only one ELF file can be processed at a time.
*/


/**********************************/
/*                                */
/* SYMTAB READING STATE VARIABLES */
/*                                */
/**********************************/

static int fd             = -1;     /* Active if +ve */
static int entry          = -1;     /* Valid if +ve */
static int entries        = -1;     /* Valid if +ve */
static int sh_num         = -1;     /* Valid if +ve */
static Elf *elf           = (Elf *)NULL;
static Elf32_Sym *symtab  = (Elf32_Sym  *)NULL;
static char      *strtab  = (char *)NULL;


static mlval open_symtab_file(mlval argument)
{

   /* External Variables
      extern int fd;
      extern Elf *elf;
   */

   /* Local Variables */
   Elf32_Ehdr *ehdr;
   Elf_Scn    *scn;

   char *path;

   if (fd >= 0) { return(MLFALSE); };
   
   path = CSTRING(argument);
   fd = open(path, O_RDONLY);

   if (fd < 0) { return(MLFALSE); };

   /* Reset ELF error number ... */
   elf_errno();

   /* Check ELF version ... */
   if (elf_version(EV_CURRENT) == EV_NONE)
     { show_errmsg();
       return(MLFALSE);
     };

   /*  Begin ELF processing of file - allocate ELF descriptor.
    *  This also initially allocates internal memory used for ELF ...
    */
   elf = elf_begin(fd,ELF_C_READ,(Elf *)NULL);

   /* Get ELF header ... */
   ehdr = elf32_getehdr(elf);

   scn = (Elf_Scn *)NULL;

   /* Find symbol table section ... it's the first one of type SHT_DYNSYM */ 
   while ((scn = elf_nextscn(elf, scn)) != NULL) {
     Elf32_Shdr *shdr= elf32_getshdr(scn);
     assert(shdr != (Elf32_Shdr *)0);
     if (shdr->sh_type == SHT_DYNSYM) {
       Elf32_Shdr * dynstr_hdr;
       Elf_Scn * dynstr= elf_getscn(elf, shdr->sh_link);
       assert(dynstr != (Elf_Scn *)0);
       dynstr_hdr= elf32_getshdr(dynstr);
       assert(dynstr_hdr != (Elf32_Shdr *)0);
       assert(dynstr_hdr->sh_type == SHT_STRTAB);
       setup_symtab(elf, scn, dynstr,(int)(ehdr -> e_shnum));
       break;
     }
   }
   /* Initialisation completed */
   return(MLTRUE);
}


static void setup_symtab(Elf *elf, Elf_Scn *symscn, Elf_Scn *strscn, int head_num)
{
  /* External Variables
     extern int        entry;
     extern int        entries;
     extern int        sh_num;
     extern Elf32_Sym  *symtab;
     extern char       *strtab;
  */

  /* Local Variables */
  Elf_Data   *symdata;
  Elf_Data   *strdata;

  int size;

  symdata = elf_getdata(symscn,(Elf_Data *)NULL);
  assert(symdata->d_type == ELF_T_SYM);
  size    = (int)(symdata -> d_size);
  entries = (int)(size/sizeof(Elf32_Sym));
  symtab  = (Elf32_Sym *)(symdata -> d_buf);

  strdata = elf_getdata(strscn,(Elf_Data *)NULL);
  assert(strdata->d_type == ELF_T_BYTE);
  strtab  = (char *)(strdata -> d_buf);

  sh_num  = head_num;
  entry = 0;
}


static mlval next_symtab_entry(mlval argument)
{

  /* External Variables:
     extern int        entry;
     extern int        entries;
     extern int        sh_num;
     extern Elf32_Sym  *symtab;
     extern char       *strtab;
  */

  /* Local Variables */
  Elf32_Sym    *symentry;
  Elf32_Word   st_name;
  Elf32_Addr   st_value;
  Elf32_Half   st_shndx;

  unsigned char st_info, st_bind, st_type;

  char buf[BUFSIZ];
  char *bufptr;

  int i;

  mlval result = ml_string("");

  /* Check for valid processing and end of symtab */
  if ((fd < 0) || (entry >= entries)) { return(result); };


  /* Iterate through entries to find something interesting to return */

  for(i=entry;i<entries;i++){

     symentry = (Elf32_Sym *)INDEXPTR(symtab,i,sizeof(Elf32_Sym));

     st_info   =  symentry -> st_info;
     st_bind   =  ELF32_ST_BIND(st_info);
     st_type   =  ELF32_ST_TYPE(st_info);

     st_shndx  =  symentry -> st_shndx;

     if ((st_bind == STB_GLOBAL) && (0 < st_shndx) && (st_shndx < sh_num))
       { /* Symbol is global and possibly relevent ... */

	 switch (st_type) {
	    case STT_FUNC : /* FALL-THROUGH */
	    case STT_OBJECT :
		 { /* get symbol name */

		   st_name   =  symentry -> st_name;
		   st_value  =  symentry -> st_value;

		   strcpy(buf,(char *)(strtab + st_name)); 

		   /* move bufptr to end of symbol name ... */
		   bufptr = (char *)(buf + strlen(buf));

		   /* ... and add in some other info ... */
		   sprintf( bufptr, " %s:type 0x%x:value"
			  , show_symtab_type(st_type)
			  , (unsigned int)st_value
			  );

		   /* turn string into an ML object */
		   result = ml_string(buf);

                   /* Save next entry position */
                   entry = i + 1;

                   return(result);

		   break;
		 };

	    default : break;
	 };
       };
  };

  entry = entries; /* Loop is exhausted */

  return(result);
}


static mlval close_symtab_file(mlval argument)
{
   /* External Variables
      extern int        fd;
      extern int        entry;
      extern int        entries;
      extern int        sh_num;
      extern Elf        *elf;
      extern Elf32_Sym  *symtab;
      extern char       *strtab;
   */

   close(fd);      /* Close the file descriptor     */
   elf_end(elf);   /* Deallocate memory used in Elf */ 

   fd = entry = entries = sh_num = -1;

   elf     =  (Elf *)NULL;
   symtab  =  (Elf32_Sym  *)NULL;
   strtab  =  (char *)NULL;

   return(MLUNIT);
}

static char *show_symtab_type(unsigned char st_type)
{
   static char msg[20];

   switch (st_type) {
       case STT_NOTYPE   : strcpy(msg,"none=STT_NOTYPE");  break;
       case STT_OBJECT   : strcpy(msg,"var=STT_OBJECT");   break;
       case STT_FUNC     : strcpy(msg,"code=STT_FUNC");    break;
       case STT_SECTION  : strcpy(msg,"none=STT_SECTION"); break;
       case STT_FILE     : strcpy(msg,"none=STT_FILE");    break;
       default           : strcpy(msg,"none=**unknown**"); break;
   };

   return(msg);
}

static mlval pack_foreign_value(void *ptr)
{
   mlval result;
   unsigned *object;

   result  = allocate_word32();

   object  = (unsigned *)CWORD32(result);
   *object = (unsigned)ptr;

#if 0
   printf("pack: pointer = (0x%x)\n",ptr);
   printf("pack: result = (0x%x)\n",result);
#endif
   
   return(result);
}

static void *unpack_foreign_value(mlval object)
{
   unsigned *ptr;

   ptr = (unsigned *)CWORD32(object);

#if 0
   printf("unpack: pointer = (0x%x)\n",*ptr);
#endif

   return((void *)*ptr);
}

static void show_errmsg(void)
{
   printf("*** %s\n", elf_errmsg(elf_errno()));
}

void foreign_init(void)
{
  env_function("load foreign object",   load_foreign_object);
  env_function("lookup foreign value",  lookup_foreign_value);

  env_function("call unit function",    call_unit_function);
  env_function("call foreign function", call_foreign_function);

  env_function("open symtab file",  open_symtab_file);
  env_function("next symtab entry", next_symtab_entry);
  env_function("close symtab file", close_symtab_file);

  env_function("big endian flag", check_big_endian);
}
@


1.3.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.3  1998/09/30  11:53:11  jont
 * [Bug #70108]
 * Acquire libelf.h from the correct place, ie libelf/libelf.h
 *
@


1.2
log
@[Bug #30354]
Merge from MLWorks_10r3:
Port of old FI to Linux
@
text
@d11 5
d57 1
a57 1
#include <libelf.h>     /* ELF libraries -- Linux            */
a61 19
#if 0

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>

#endif


#if FAKE_RTS

#include "fake_foreign_loader.h"
#include "mylib.h"
#include "fake_rts.h"

#endif


a66 2
#ifndef FAKE_RTS

a71 3

#endif

@


1.1
log
@new unit
Moved from architecture specific location.
@
text
@d3 1
a3 1
 *  Copyright (C) 1995 Harlequin Ltd.
d5 1
a5 1
 *  Implementation
a6 2
 *  This implementation provides dummy stubs for those ML ports
 *  where foreign object loading is not yet supported.  
d10 15
a24 1
 *  $Log: src:OS:Linux:arch:I386:foreign_loader.c,v $
d41 1
a41 2

#include "ansi.h"
d46 1
d48 1
a48 1
#include "exceptions.h"
d51 15
d69 1
a74 1
#define raise_unimpl(str)    exn_raise_string(perv_exn_ref_value, (str))
d76 1
d78 25
a102 1
/* Forward decls. */
d109 3
d115 16
a130 1
static mlval load_foreign_object(mlval string)
d132 23
a154 1
   raise_unimpl("unimplemented : load_foreign_object");
d157 5
a161 1

d164 8
a171 1
   raise_unimpl("unimplemented : lookup_foreign_value");
d173 5
d180 4
d186 6
a191 1
   raise_unimpl("unimplemented : call_unit_function");
d194 8
a201 1
static mlval call_foreign_function(mlval f_val)
d203 27
a229 1
   raise_unimpl("unimplemented : call_foreign_function");
a231 1

d234 3
a236 1
   raise_unimpl("unimplemented : call_ffun_error");
d239 1
d258 297
d557 9
a565 4
  env_function("load foreign object",load_foreign_object);
  env_function("lookup foreign value",lookup_foreign_value);
  env_function("call unit function",call_unit_function);
  env_function("call foreign function",call_foreign_function);
@


1.1.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.9.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.1.9.1  1997/05/12  10:40:45  hope
 * branched from 1.1
 *
@


1.1.9.1.3.2
log
@[Bug #30262]
Adapted from Solaris version for use under Linux
@
text
@d3 1
a3 1
 *  Copyright (C) 1997 The Harlequin Group Ltd.  All rights reserved.
d5 1
a5 1
 *  Implementation  (* Linux *)
d7 2
a12 3
 * Revision 1.1.9.1.3.1  1997/09/09  14:14:57  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d36 2
a37 1
#include <assert.h>
d42 1
a43 2
#include "environment.h"
#include "words.h"
a45 15
#include <dlfcn.h>      /* Run-Time Dynamic Linking libraries */ 
#include <libelf.h>     /* ELF libraries -- Linux            */

#include <fcntl.h>
#include <unistd.h>

#if 0

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <sys/types.h>

#endif

a48 1
#include "fake_foreign_loader.h"
d54 1
a55 24
/* Macros */


#define INDEXPTR(base,index,size)  ((unsigned long int)(base) + ((size)*(index)))

#ifndef FAKE_RTS

#define bit(a)                     (1u << (a))
#define bitblk(hi,lo)              (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)               ((x) & (m))
#define rshift(x,lo)               ((unsigned)(x) >> (lo))
#define getbitblk(u,hi,lo)         (appmask(rshift((u),(lo)),bitblk(1+(hi) - (lo),0)))

#endif


/* Local Procedure/Function stub decls. */

static void  setup_symtab(Elf *,Elf_Scn *,Elf_Scn*,int);
static char  *show_symtab_type(unsigned char);
static void  show_errmsg(void);

static mlval pack_foreign_value(void *);
static void  *unpack_foreign_value(mlval);
d57 1
a57 2

/* Forward decls. of exported ML functions */
a63 3
static mlval open_symtab_file(mlval);
static mlval next_symtab_entry(mlval);
static mlval close_symtab_file(mlval);
d67 1
a67 16

#define raise_error(str)   exn_raise_string(perv_exn_ref_value, (str))


enum load_mode {load_later, load_now};

typedef enum load_mode load_mode;


/* ==== <ML> load_foreign_object : (string * load_mode) -> foreign_object
 *
 *  Given a pathname (as a string), this dynamiclly links, using the
 *  specified load_mode, the executable object file and returns a
 *  foreign_object pointer.
 */
static mlval load_foreign_object(mlval argument)
d69 2
a70 16
   char      *path;
   unsigned  *handle;
   mlval result;

   load_mode lmode;
   int mode = RTLD_LAZY;

   path = CSTRING(FIELD(argument,0));
   lmode = CINT(FIELD(argument,1));

   switch (lmode) {
      case load_later  : mode = RTLD_LAZY; break;
      case load_now    : mode = RTLD_NOW;  break;
   }

   handle = (unsigned *)dlopen(path,mode);
a71 1
   if (handle == NULL) raise_error("Shared object not found ...\n");
a72 11
   result = allocate_word32();
   num_to_word32((unsigned)handle,result);
 
   return(result);
}

/* ==== <ML> lookup_foreign_value : (foreign_object * string) -> foreign_value
 *
 *  Given a name (as a ML string) and a foreign object, this looks up
 *  the foreign value within the given foreign object.
 */
d75 1
a75 6
   mlval fstruct, word;
   char *name;
   void *object;

   fstruct = FIELD(arg,0);
   name    = CSTRING(FIELD(arg,1));
a76 7
   word    = FIELD(fstruct,2);

   object  = dlsym((void *)word32_to_num(word),name);

   if (object == NULL) raise_error("Named value not found in object.\n");

   return(pack_foreign_value(object));
a78 4
/* ==== <ML> call_unit_function : foreign_object -> unit
 *
 *  Calls a foreign unit function (included for testing purposes only).
 */
d81 1
a81 6
   void (*f)(void);

   f = (void (*)(void))unpack_foreign_value(f_val);
   (*f)();

   return(MLUNIT);
d84 1
a84 8

/* ==== <ML> call_foreign_function : (function * memory * int * memory) -> unit
 *
 *  Calls a foreign function on a given array of (4 byte) argument values and
 *  returning a 4 byte value.  The integer argument specifies the number of
 *  arguments to be passed.
 */
static mlval call_foreign_function(mlval f_arg)
d86 2
a87 23
   void *ffun;
   void *argv;
   int argc;
   unsigned *result;
   int i;
   int *data;

   ffun     =      (void *)unpack_foreign_value(FIELD(f_arg, 0));
   argv     =      (void *)unpack_foreign_value(FIELD(f_arg, 1));
   argc     =         CINT(FIELD(f_arg, 2));
   result   =  (unsigned *)unpack_foreign_value(FIELD(f_arg, 3));

   data = argv;
   i=0;
#if 0
   printf("<C>call_foreign_function ... \n");

   printf("argv = %i = 0x%x\n",(int)argv,(unsigned)argv);
   printf("argc = %i\n", argc);
   
   for (i=0;i<argc;i++)
      printf("  ARG[ %i ] = %i = 0x%x\n",i,(int)data[i],(unsigned)data[i]);
#endif
a88 4
   *result  =  (unsigned)call_ffun(ffun,argv,argc);

   return(MLUNIT);
}
d92 1
a92 3
   fprintf(stderr,"Too many args to foreign function:\n");
   fprintf(stderr,"Number of supplied args = %i (max: %i)\n",argv,MAX_FI_ARG_LIMIT);
   return(MLINT(0));
a94 1

a112 297
/* OS specific -- Linux */
/* Uses: ELF             */

/* ==== Extracting a symbol table ====

   The intention in the following code is to produce a stream of strings
   extracted from an ELF file as part of creating an ML version of the
   symbol table info.  However, to avoid complications with ML's GC, we
   need to avoid ML list creation within C.

   The idea is that we provide ML-usable routines for:

     - opening an ELF format file.

     - getting the next symtab entry (as an ML string ...), returning
       the null string at the end.

     - closing the ELF format file.

   and then ML uses these to generate an ML list from ML - which will
   then be GC-safe.  (Creating ML objects in C can invalidate mlval
   objects since the GC can move them around - suitable care is needed to
   make C copies of data.)

   To simplify the ML interface, some state is maintained in C for this.
   This means that only one ELF file can be processed at a time.
*/


/**********************************/
/*                                */
/* SYMTAB READING STATE VARIABLES */
/*                                */
/**********************************/

static int fd             = -1;     /* Active if +ve */
static int entry          = -1;     /* Valid if +ve */
static int entries        = -1;     /* Valid if +ve */
static int sh_num         = -1;     /* Valid if +ve */
static Elf *elf           = (Elf *)NULL;
static Elf32_Sym *symtab  = (Elf32_Sym  *)NULL;
static char      *strtab  = (char *)NULL;


static mlval open_symtab_file(mlval argument)
{

   /* External Variables
      extern int fd;
      extern Elf *elf;
   */

   /* Local Variables */
   Elf32_Ehdr *ehdr;
   Elf_Scn    *scn;

   char *path;

   if (fd >= 0) { return(MLFALSE); };
   
   path = CSTRING(argument);
   fd = open(path, O_RDONLY);

   if (fd < 0) { return(MLFALSE); };

   /* Reset ELF error number ... */
   elf_errno();

   /* Check ELF version ... */
   if (elf_version(EV_CURRENT) == EV_NONE)
     { show_errmsg();
       return(MLFALSE);
     };

   /*  Begin ELF processing of file - allocate ELF descriptor.
    *  This also initially allocates internal memory used for ELF ...
    */
   elf = elf_begin(fd,ELF_C_READ,(Elf *)NULL);

   /* Get ELF header ... */
   ehdr = elf32_getehdr(elf);

   scn = (Elf_Scn *)NULL;

   /* Find symbol table section ... it's the first one of type SHT_DYNSYM */ 
   while ((scn = elf_nextscn(elf, scn)) != NULL) {
     Elf32_Shdr *shdr= elf32_getshdr(scn);
     assert(shdr != (Elf32_Shdr *)0);
     if (shdr->sh_type == SHT_DYNSYM) {
       Elf32_Shdr * dynstr_hdr;
       Elf_Scn * dynstr= elf_getscn(elf, shdr->sh_link);
       assert(dynstr != (Elf_Scn *)0);
       dynstr_hdr= elf32_getshdr(dynstr);
       assert(dynstr_hdr != (Elf32_Shdr *)0);
       assert(dynstr_hdr->sh_type == SHT_STRTAB);
       setup_symtab(elf, scn, dynstr,(int)(ehdr -> e_shnum));
       break;
     }
   }
   /* Initialisation completed */
   return(MLTRUE);
}


static void setup_symtab(Elf *elf, Elf_Scn *symscn, Elf_Scn *strscn, int head_num)
{
  /* External Variables
     extern int        entry;
     extern int        entries;
     extern int        sh_num;
     extern Elf32_Sym  *symtab;
     extern char       *strtab;
  */

  /* Local Variables */
  Elf_Data   *symdata;
  Elf_Data   *strdata;

  int size;

  symdata = elf_getdata(symscn,(Elf_Data *)NULL);
  assert(symdata->d_type == ELF_T_SYM);
  size    = (int)(symdata -> d_size);
  entries = (int)(size/sizeof(Elf32_Sym));
  symtab  = (Elf32_Sym *)(symdata -> d_buf);

  strdata = elf_getdata(strscn,(Elf_Data *)NULL);
  assert(strdata->d_type == ELF_T_BYTE);
  strtab  = (char *)(strdata -> d_buf);

  sh_num  = head_num;
  entry = 0;
}


static mlval next_symtab_entry(mlval argument)
{

  /* External Variables:
     extern int        entry;
     extern int        entries;
     extern int        sh_num;
     extern Elf32_Sym  *symtab;
     extern char       *strtab;
  */

  /* Local Variables */
  Elf32_Sym    *symentry;
  Elf32_Word   st_name;
  Elf32_Addr   st_value;
  Elf32_Half   st_shndx;

  unsigned char st_info, st_bind, st_type;

  char buf[BUFSIZ];
  char *bufptr;

  int i;

  mlval result = ml_string("");

  /* Check for valid processing and end of symtab */
  if ((fd < 0) || (entry >= entries)) { return(result); };


  /* Iterate through entries to find something interesting to return */

  for(i=entry;i<entries;i++){

     symentry = (Elf32_Sym *)INDEXPTR(symtab,i,sizeof(Elf32_Sym));

     st_info   =  symentry -> st_info;
     st_bind   =  ELF32_ST_BIND(st_info);
     st_type   =  ELF32_ST_TYPE(st_info);

     st_shndx  =  symentry -> st_shndx;

     if ((st_bind == STB_GLOBAL) && (0 < st_shndx) && (st_shndx < sh_num))
       { /* Symbol is global and possibly relevent ... */

	 switch (st_type) {
	    case STT_FUNC : /* FALL-THROUGH */
	    case STT_OBJECT :
		 { /* get symbol name */

		   st_name   =  symentry -> st_name;
		   st_value  =  symentry -> st_value;

		   strcpy(buf,(char *)(strtab + st_name)); 

		   /* move bufptr to end of symbol name ... */
		   bufptr = (char *)(buf + strlen(buf));

		   /* ... and add in some other info ... */
		   sprintf( bufptr, " %s:type 0x%x:value"
			  , show_symtab_type(st_type)
			  , (unsigned int)st_value
			  );

		   /* turn string into an ML object */
		   result = ml_string(buf);

                   /* Save next entry position */
                   entry = i + 1;

                   return(result);

		   break;
		 };

	    default : break;
	 };
       };
  };

  entry = entries; /* Loop is exhausted */

  return(result);
}


static mlval close_symtab_file(mlval argument)
{
   /* External Variables
      extern int        fd;
      extern int        entry;
      extern int        entries;
      extern int        sh_num;
      extern Elf        *elf;
      extern Elf32_Sym  *symtab;
      extern char       *strtab;
   */

   close(fd);      /* Close the file descriptor     */
   elf_end(elf);   /* Deallocate memory used in Elf */ 

   fd = entry = entries = sh_num = -1;

   elf     =  (Elf *)NULL;
   symtab  =  (Elf32_Sym  *)NULL;
   strtab  =  (char *)NULL;

   return(MLUNIT);
}

static char *show_symtab_type(unsigned char st_type)
{
   static char msg[20];

   switch (st_type) {
       case STT_NOTYPE   : strcpy(msg,"none=STT_NOTYPE");  break;
       case STT_OBJECT   : strcpy(msg,"var=STT_OBJECT");   break;
       case STT_FUNC     : strcpy(msg,"code=STT_FUNC");    break;
       case STT_SECTION  : strcpy(msg,"none=STT_SECTION"); break;
       case STT_FILE     : strcpy(msg,"none=STT_FILE");    break;
       default           : strcpy(msg,"none=**unknown**"); break;
   };

   return(msg);
}

static mlval pack_foreign_value(void *ptr)
{
   mlval result;
   unsigned *object;

   result  = allocate_word32();

   object  = (unsigned *)CWORD32(result);
   *object = (unsigned)ptr;

#if 0
   printf("pack: pointer = (0x%x)\n",ptr);
   printf("pack: result = (0x%x)\n",result);
#endif
   
   return(result);
}

static void *unpack_foreign_value(mlval object)
{
   unsigned *ptr;

   ptr = (unsigned *)CWORD32(object);

#if 0
   printf("unpack: pointer = (0x%x)\n",*ptr);
#endif

   return((void *)*ptr);
}

static void show_errmsg(void)
{
   printf("*** %s\n", elf_errmsg(elf_errno()));
}

d115 4
a118 9
  env_function("load foreign object",   load_foreign_object);
  env_function("lookup foreign value",  lookup_foreign_value);

  env_function("call unit function",    call_unit_function);
  env_function("call foreign function", call_foreign_function);

  env_function("open symtab file",  open_symtab_file);
  env_function("next symtab entry", next_symtab_entry);
  env_function("close symtab file", close_symtab_file);
@


1.1.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.1.9.1  1997/05/12  10:40:45  hope
 * branched from 1.1
 *
@


1.1.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.1.9.1  1997/05/12  10:40:45  hope
 * branched from 1.1
 *
@


1.1.8.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.7.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.7.1.1.1
log
@branched from 1.1.7.1
@
text
@a12 3
 * Revision 1.1.7.1  1996/12/17  17:53:47  hope
 * branched from 1.1
 *
@


1.1.6.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.5.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.4.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.4.1.1.1
log
@branched from 1.1.4.1
@
text
@a12 3
 * Revision 1.1.4.1  1996/11/14  12:57:29  hope
 * branched from 1.1
 *
@


1.1.3.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Linux:foreign_loader.c,v $
 * Revision 1.1  1996/05/10  12:48:50  brianm
 * new unit
 * Moved from architecture specific location.
 *
@
