head	1.11;
access;
symbols
	MLWorks_11r1:1.11.1.1.1.1.1
	MLWorks_11c0_1997_09_09:1.11.1.1.1.1
	MLWorks_10r3:1.11.1.1.3
	MLWorks_10r2_551:1.11.1.1.2
	MLWorks_11:1.11.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.1.1
	MLWorks_1_0_r2c2_1997_06_14:1.11.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.1
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MM_ML_release_korma_1997_04_01:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.2.1.1
	MLWorks_gui_1996_12_18:1.10.3
	MLWorks_1_0_Win32_1996_12_17:1.10.2
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.1.1
	JFHrts:1.10.1
	MLWorks_1_0_Irix_1996_11_28:1.9.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.2
	MLWorks_1_0_Unix_1996_11_14:1.9.1
	MLWorks_Open_Beta2_1996_10_11:1.8.3
	MLWorks_License_dev:1.8.2
	MLWorks_1_open_beta_1996_09_13:1.8.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8;
locks; strict;
comment	@ * @;


1.11
date	97.03.25.17.34.39;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	96.12.03.17.43.08;	author johnh;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	96.10.17.14.04.18;	author jont;	state Exp;
branches
	1.9.1.1
	1.9.2.1;
next	1.8;

1.8
date	96.03.04.12.49.46;	author stephenb;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1;
next	1.7;

1.7
date	96.02.08.16.42.57;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.01.17.17.06.15;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	96.01.11.15.23.36;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	96.01.09.13.53.51;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	95.12.13.16.06.20;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	95.11.15.13.17.25;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	95.10.17.13.59.34;	author jont;	state Exp;
branches;
next	;

1.8.1.1
date	96.09.13.11.22.35;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.10.07.16.12.42;	author hope;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	96.10.09.11.16.38;	author nickb;	state Exp;
branches;
next	;

1.8.3.1
date	96.10.17.11.31.46;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.11.14.12.57.49;	author hope;	state Exp;
branches
	1.9.1.1.1.1;
next	;

1.9.1.1.1.1
date	96.11.28.15.07.50;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.11.22.18.15.31;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.12.17.10.02.15;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.12.17.17.53.59;	author hope;	state Exp;
branches
	1.10.2.1.1.1;
next	;

1.10.2.1.1.1
date	97.02.24.11.45.01;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.12.18.09.48.33;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	97.05.12.10.40.58;	author hope;	state Exp;
branches
	1.11.1.1.1.1
	1.11.1.1.2.1
	1.11.1.1.3.1;
next	;

1.11.1.1.1.1
date	97.07.28.18.26.16;	author daveb;	state Exp;
branches
	1.11.1.1.1.1.1.1;
next	;

1.11.1.1.1.1.1.1
date	97.10.07.11.52.06;	author jkbrook;	state Exp;
branches;
next	;

1.11.1.1.2.1
date	97.09.08.17.19.28;	author daveb;	state Exp;
branches;
next	;

1.11.1.1.3.1
date	97.09.09.14.15.36;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.11
log
@Stop trying to set profiling intervals of zero
@
text
@/* ==== SIGNAL HANDLING ====
 * 
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module abstracts the OS-specific signal handling code from
 * the various parts of the runtime system.
 *
 * 
 * Revision Log
 * ------------
 * $Log: src:OS:Win95:arch:I386:signals.c,v $
 * Revision 1.10  1996/12/03  17:43:08  johnh
 * Implementing the interrupt button.
 *
 * Revision 1.9  1996/10/17  14:04:18  jont
 * Merging in license server stuff
 *
 * Revision 1.8.2.2  1996/10/09  11:16:38  nickb
 * Move to Harlequin license server.
 *
 * Revision 1.8.2.1  1996/10/07  16:12:42  hope
 * branched from 1.8
 *
 * Revision 1.8  1996/03/04  12:49:46  stephenb
 * Update wrt wintimer.h -> timer.h change.
 *
 * Revision 1.7  1996/02/08  16:42:57  jont
 * Removing do_exportFn, as this is no longer architecture dependent
 *
 * Revision 1.6  1996/01/17  17:06:15  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.5  1996/01/11  15:23:36  nickb
 * Add stubs for timer-triggered window updates.
 *
 * Revision 1.4  1996/01/09  13:53:51  nickb
 * Extensions to event handling for non-signal events.
 *
 * Revision 1.3  1995/12/13  16:06:20  nickb
 * Extend time profiling.
 *
 * Revision 1.2  1995/11/15  13:17:25  nickb
 * Add timer capabilities.
 *
 * Revision 1.1  1995/10/17  13:59:34  jont
 * new unit
 *
 * Revision 1.4  1995/09/15  17:37:31  jont
 * Add dummy implementation of do_exportFn
 *
 * Revision 1.3  1995/07/17  15:48:47  nickb
 * Change profiler interface.
 *
 * Revision 1.2  1995/03/15  16:53:15  nickb
 * Introduce the threads system.
 *
 * Revision 1.1  1994/12/12  15:05:07  jont
 * new file
 *
 * Revision 1.3  1994/11/23  16:50:21  nickb
 * Remove set_stack_underflow() call.
 *
 * Revision 1.2  1994/10/12  09:58:16  jont
 * Remove gc trap stuff
 *
 * Revision 1.1  1994/10/04  16:36:01  jont
 * new file
 *
 * Revision 1.8  1994/09/07  10:05:04  jont
 * Update license expiry date
 *
 * Revision 1.7  1994/07/25  13:16:54  nickh
 * Make sure all handlers execute on signal stack.
 *
 * Revision 1.6  1994/07/22  14:33:33  nickh
 * Add GC trap handling.
 *
 * Revision 1.5  1994/07/08  10:03:57  nickh
 * Add interrupt signal number and reserve two more signals.
 *
 * Revision 1.4  1994/06/14  14:51:09  jont
 * Add critical region support for FP signals
 *
 * Revision 1.3  1994/06/13  12:02:58  nickh
 * Update best-before date.
 *
 * Revision 1.2  1994/06/09  14:24:13  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:49:10  nickh
 * new file
 *
 */

#include "signals.h"
#include "utils.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "values.h"
#include "gc.h"
#include "stacks.h"
#include "syscalls.h"
#include "exceptions.h"
#include "event.h"
#include "license.h"
#include "profiler.h"
#include "ansi.h"
#include "reals.h"
#include "alloc.h"
#include "main.h"
#include "pervasives.h"
#include "global.h"
#include "allocator.h"
#include "timer.h"
#include "native_threads.h"
#include "state.h"

#include <time.h>
#include <sys/types.h>
#include <string.h>
#include <memory.h>
#include <signal.h>
#include <errno.h>
#include <math.h>

/* ML signal handler support */

#define NR_SIGNALS	0
extern unsigned int signal_nr_signals = NR_SIGNALS;

/* Install or remove the signal handler for a given signal */

extern int signal_set_ml_handler(int sig)
{
  errno = ESIGNALNO;
  return 1;
}

extern int signal_clear_ml_handler(int sig)
{
  errno = ESIGNALNO;
  return 1;
}

/* == Event support ==
 */

/* signal_event() is called from record_event (in the events
   module). It can be called either synchronously in C or
   asynchronously in C or ML. It should set the 'interrupted' flag
   such that the event is taken synchronously by ML when we return to
   ML. */

extern void signal_event(void)
{
  /* set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
  if (global_state.in_ML)
    CURRENT_THREAD->implicit.register_stack_limit = (unsigned)-1;
}

/* == Licensing support ==
 * 
 * We don't support licensing on Windows. */

extern void signal_license_timer (int interval)
{
  error("Licensing not operative on Windows 95");
}

/* == Interrupt support == */

extern int signal_set_interrupt_handler(void)
{
  return win32_set_ctrl_c_handler();
}

extern int signal_clear_interrupt_handler(void)
{
  return win32_clear_ctrl_c_handler();
}

/* == Timer support ==
 * 
 * We have a timer for two purposes: for stack-based profiling and for
 * thread pre-emption. The timer is mainly implemented in wintimer.c
 * and native_threads.c
 */

static unsigned int timer_interval;

/* the number of milliseconds for the profiling, pre-emption and
 * window update intervals. */

unsigned int profiling_interval = 0;
unsigned int thread_preemption_interval = 0;
unsigned int window_update_interval = 0;
static unsigned int window_update_remaining = 0;
static unsigned int window_updates_on = 0;


/* signal_update_windows: return value needed to comply with the shared
 * header file in <URI: src/rts/src/os.h>.  If window updates are started
 * (which is typically during compilation or computation within a 
 * listener), then an event is recorded to handle Window messages sent to
 * the MLWorks environment, and to check for the interrupt button being 
 * pressed. See <URI: src/rts/src/OS/Win32/os.c> and also 
 * <URI: src/rts/src/OS/Win32/window.c:mlw_expose_windows>. 
 */
static int signal_update_windows(unsigned int interval)
{
  if (window_update_remaining < interval) {
    window_update_remaining = window_update_interval;
    if (window_updates_on) {
      record_event(EV_WINDOWS, (word) 0);
      return 1;
    }
  } else
    window_update_remaining -= interval;
  return 0;
}

static inline void signal_set_timer(unsigned int interval)
{
  if (interval != 0) {
    timer_interval = interval;
    start_timer(timer_interval);
  }
}

/* The timer function. If we're profiling we run the profiler. If
 * we're pre-empting we record the event. */

static void signal_interval_alarm(void)
{
  if (profile_on) {
    word *current_thread = suspend_current_thread();
    time_profile_scan((struct stack_frame *)
		      reconstruct_thread_sp(current_thread));
    resume_current_thread(current_thread);
  }

  if (thread_preemption_on) {
    thread_preemption_pending = 1;
    record_event(EV_SWITCH, (word)0);
  }

  signal_update_windows (timer_interval);

  start_timer(timer_interval);
}

static void timer_thread(void)
{
  for(;;) {
    timer_thread_wait();
    signal_interval_alarm();
  }
}

/* == Profiling support == */

extern void signal_profiling_start(void)
{
  signal_set_timer(profiling_interval);
}

extern void signal_profiling_stop(void)
{
  unsigned int interval;
  stop_timer();
  if (thread_preemption_on)
    interval = thread_preemption_interval;
  else if (window_updates_on)
    interval = window_update_interval;
  else
    interval = 0;
  signal_set_timer(interval);
}

/* == Preemption support == */

extern void signal_preemption_start(void)
{
  if (!profile_on)
    signal_set_timer(thread_preemption_interval);
}

extern void signal_preemption_stop(void)
{
  if (!profile_on) {
    unsigned int interval;
    stop_timer();
    if (window_updates_on)
      interval = window_update_interval;
    else 
      interval = 0;
    signal_set_timer(interval);
  }
}

extern void signal_preemption_change(void)
{
  signal_preemption_start();
}

/* == Window updates == */

/* signal_window_updates_{start,stop} used in <URI: src/rts/src/OS/Win32/window.c>
 * Started typically before compilation and before any computation in a 
 * listener.  Note: starting window updates also allows the checking of an 
 * interrupt button being pressed.
 */ 
extern void signal_window_updates_start()
{
  window_updates_on = 1;
  if (timer_interval == 0)
    signal_set_timer(window_update_interval);
}

extern void signal_window_updates_stop()
{
  window_updates_on = 0;
}

extern void signals_init (void)
{
  make_timer_thread(timer_thread);
  init_timer();
}
@


1.11.1.1
log
@branched from 1.11
@
text
@a13 3
 * Revision 1.11  1997/03/25  17:34:39  jont
 * Stop trying to set profiling intervals of zero
 *
@


1.11.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.11.1.1  1997/05/12  10:40:58  hope
 * branched from 1.11
 *
@


1.11.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.11.1.1  1997/05/12  10:40:58  hope
 * branched from 1.11
 *
@


1.11.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.11.1.1  1997/05/12  10:40:58  hope
 * branched from 1.11
 *
@


1.11.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.11.1.1.1.1  1997/07/28  18:26:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.10
log
@Implementing the interrupt button.
@
text
@d14 3
d228 4
a231 2
  timer_interval = interval;
  start_timer(timer_interval);
@


1.10.3.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/12/03  17:43:08  johnh
 * Implementing the interrupt button.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/12/03  17:43:08  johnh
 * Implementing the interrupt button.
 *
@


1.10.2.1.1.1
log
@branched from 1.10.2.1
@
text
@a13 3
 * Revision 1.10.2.1  1996/12/17  17:53:59  hope
 * branched from 1.10
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a13 3
 * Revision 1.10  1996/12/03  17:43:08  johnh
 * Implementing the interrupt button.
 *
@


1.9
log
@Merging in license server stuff
@
text
@d14 3
d192 2
a193 1
/* the number of milliseconds for the profiling and pre-emption intervals. */
d198 24
d232 1
a232 1
static void signal_interval_alarm (void)
d246 2
d268 1
d271 6
a276 1
    signal_set_timer(thread_preemption_interval);
d289 2
a290 1
  if (!profile_on)
d292 6
d305 1
a305 1
/* == Window updates not supported on Windows == */
d307 5
d314 3
d321 1
@


1.9.2.1
log
@branched from 1.9
@
text
@a13 3
 * Revision 1.9  1996/10/17  14:04:18  jont
 * Merging in license server stuff
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a13 3
 * Revision 1.9  1996/10/17  14:04:18  jont
 * Merging in license server stuff
 *
@


1.9.1.1.1.1
log
@branched from 1.9.1.1
@
text
@a13 3
 * Revision 1.9.1.1  1996/11/14  12:57:49  hope
 * branched from 1.9
 *
@


1.8
log
@Update wrt wintimer.h -> timer.h change.
@
text
@d14 9
d163 1
a163 10
/* A function called by the main MLWorks process to watch the child
 * process */

int signal_license_child_pid = 0;

extern void signal_license_watch_child (void)
{
}

extern void signal_license_child (int *pipefd)
d165 1
@


1.8.3.1
log
@branched from 1.8
@
text
@a13 3
 * Revision 1.8  1996/03/04  12:49:46  stephenb
 * Update wrt wintimer.h -> timer.h change.
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a13 3
 * Revision 1.8  1996/03/04  12:49:46  stephenb
 * Update wrt wintimer.h -> timer.h change.
 *
@


1.8.2.2
log
@Move to Harlequin license server.
@
text
@a13 3
 * Revision 1.8.2.1  1996/10/07  16:12:42  hope
 * branched from 1.8
 *
d157 10
a166 1
extern void signal_license_timer (int interval)
a167 1
  error("Licensing not operative on Windows 95");
@


1.8.1.1
log
@branched from 1.8
@
text
@a13 3
 * Revision 1.8  1996/03/04  12:49:46  stephenb
 * Update wrt wintimer.h -> timer.h change.
 *
@


1.7
log
@Removing do_exportFn, as this is no longer architecture dependent
@
text
@d14 3
d102 1
a102 1
#include "wintimer.h"
@


1.6
log
@Disable interrupt handling except when a handler is defined.
@
text
@d14 3
a161 5
}

mlval do_exportFn(mlval argument)
{
  exn_raise_string(perv_exn_ref_save, "Function save not implemented");
@


1.5
log
@Add stubs for timer-triggered window updates.
@
text
@d14 3
d164 12
@


1.4
log
@Extensions to event handling for non-signal events.
@
text
@d14 3
d176 1
d243 10
@


1.3
log
@Extend time profiling.
@
text
@d14 3
d104 1
a104 1
#define NR_SIGNALS	32
a106 47
/* reserving and releasing signals */

static int reserved[NR_SIGNALS];

extern int signal_reserve(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    return (-1);
  }
  if (reserved[sig]) {
    return (-1);
  }
  reserved[sig] = 1;
  return 0;
}
    
extern int signal_release(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    return (-1);
  }
  if (!reserved[sig]) {
    return (-1);
  }
  reserved[sig] = 0;
  return 0;
}  

extern int signal_reserved(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    return (-1);
  }
  return (reserved[sig]);
}

static void record_event (void)
{
  if (global_state.in_ML) {
    /* set the stack limit register to -1 */
    CURRENT_THREAD->implicit.register_stack_limit = (word)-1;
  }

  /* always set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
}

d111 2
a112 1
  return 0;
d117 2
a118 1
  return 0;
d121 2
a122 5
/* == Stack overflow support ==
 * 
 * When we exceed the user-specified number of stack blocks, we want
 * to signal into the ML debugger. This is the portable interface:
 * self_signal (signal_stack_overflow) is called. */
d124 5
a128 2
int signal_stack_overflow = 0/*SIGUSR1*/;
int signal_interrupt = 0/*SIGINT*/;
d130 1
a130 1
extern void self_signal (int sig)
d132 4
a135 3
#if 0
  kill (getpid(),(int) sig);
#endif
d140 1
a140 83
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */

#define POLL_PERIOD	600		/* seconds between licence checks */
#define BEST_BEFORE	788918400	/* 1995-01-01 sometime */

/* The process ID of the child */

int signal_license_child_pid;

/* The handler for SIGCHLD, installed by the main MLWorks process */

#if 0
static void signal_license_child_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  int status, available;

  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig, code);
  DIAGNOSTIC(4, "         child = %d)", signal_license_child_pid, 0);

  /* Find out what happened to the child.  If waitpid() is interrupted by a */
  /* signal then try again. */
  
  do
    available = waitpid(signal_license_child_pid,
			&status, WNOHANG | WUNTRACED);
  while(available == -1 && errno == EINTR);
  
  if(available == -1)
    error("Unable to determine status of licensing process.  "
	  "waitpid set errno to %d.", errno);

  /* If available is non zero then something happened to the child.  If it */
  /* is zero then the child status changed, but changed back (for example, */
  /* both child and parent were suspended from the shell and restarted. */
  
  if(available)
  {
    DIAGNOSTIC(4, "available %d status 0x%02X", available, status);

    if(WIFSTOPPED(status))
      error("Licensing process was stopped with signal %d", WSTOPSIG(status));
    else if(WIFSIGNALED(status))
      error("Licensing process was terminated with signal %d", WTERMSIG(status));
    else
      error("Your license has expired.  Contact MLWorks customer support:\n"
	    "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	    "   telephone:        +44 223 872522");
  }
}

/* The handler for SIGALRM, installed by the child (licensing) process */

static void signal_license_alarm_handler
    (int sig, int code, struct sigcontext *scp, word *addr)
{
  time_t now;

  now = time(NULL);
  DIAGNOSTIC(4, "child: checking license at time %ld", now, 0);

  if(now == -1)
    message("child: WARNING: time() returned -1");
  else if (now >= BEST_BEFORE)
  {
    DIAGNOSTIC(1, "child: license expired at time %ld", now, 0);
    exit(1);
  }
}
#endif
d145 2
a148 10
#if 0
  struct sigaction sv;

  sv.sa_handler = signal_license_child_handler;
  sv.sa_mask = 0;
  sv.sa_flags = SA_STACK;
  if(sigaction(SIGCHLD, &sv, NULL) == -1)
    error("Unable to set signal handler for SIGCHLD.  "
	  "sigvec set errno to %d.", errno);
#endif
a150 2
/* The child process itself */

a152 49
#if 0
  struct sigaction sv;

  char dummy;
  struct itimerval period;
  int i;

  sv.sa_mask = 0;
  sv.sa_flags = 0;
  
  /* Ignore all signals (if possible) so that signals sent to the */
  /* process group won't affect the licensing process. */
  
  sv.sa_handler = SIG_IGN;
  for(i=1; i<NSIG; ++i)
    if (i != SIGALRM)
      /* SIGKILL and SIGSTOP are not blocked by this */
      sigblock(sigmask(i));
  
  /* Check the license once before we start. */
  signal_license_alarm_handler (0,0,NULL,NULL);
  
  /* Set up a real time alarm with a handler to poll the license. */
  
  sv.sa_handler = signal_license_alarm_handler;
  if(sigaction(SIGALRM, &sv, NULL) == -1)
    error("Licensing process unable to set signal handler for SIGALRM.  "
	  "sigaction set errno to %d.", errno);
  
  period.it_value.tv_sec = POLL_PERIOD;
  period.it_value.tv_usec = 0;
  period.it_interval.tv_sec = POLL_PERIOD;
  period.it_interval.tv_usec = 0;
  
  if(setitimer(ITIMER_REAL, &period, NULL) == -1)
    error("Unable to set up licensing timer.  "
	  "setitimer set errno to %d.", errno);
  
  /* Read from the child's end of the pipe.  This has the effect of */
  /* blocking the child until the other end is closed by the parent */
  /* exiting. */
  
  close(pipefd[1]);
  if(read(pipefd[0], &dummy, 1))
    error("Licensing process managed to read from pipe.");
  
  DIAGNOSTIC(2, "child: parent died -- exiting", 0, 0);
  exit(0);
#endif
d194 1
a194 1
    record_event();
@


1.2
log
@Add timer capabilities.
@
text
@d14 3
d369 2
a370 1
    time_profile_scan((struct stack_frame *) CURRENT_THREAD->ml_state.sp);
@


1.1
log
@new unit
@
text
@d13 4
a16 1
 * $Log: src:OS:NT:arch:I386:signals.c,v $
d84 3
a89 3
#ifndef OS_NT
#include <sys/time.h>
#endif
a91 3
#ifndef OS_NT
#include <sys/wait.h>
#endif
a92 3
#ifndef OS_NT
#include <sys/signal.h>
#endif
a93 3
#ifndef OS_NT
#include <sys/errno.h>
#endif
a98 2
#define SIGNAL_STACK_SIZE 	8192

a100 59
#if 0
static struct signal_name {int number;
			   const char *name;
			 } signal_names [] =
{{SIGHUP,	"SIGHUP"},
 {SIGINT,	"SIGINT"},
 {SIGQUIT,	"SIGQUIT"},
 {SIGILL,	"SIGILL"},
 {SIGTRAP,	"SIGTRAP"},
 {SIGABRT,	"SIGABRT"},
/*
 {SIGEMT,	"SIGEMT"},
*/
 {SIGFPE,	"SIGFPE"},
 {SIGKILL,	"SIGKILL"},
 {SIGBUS,	"SIGBUS"},
 {SIGSEGV,	"SIGSEGV"},
/*
 {SIGSYS,	"SIGSYS"},
*/
 {SIGPIPE,	"SIGPIPE"},
 {SIGALRM,	"SIGALRM"},
 {SIGTERM,	"SIGTERM"},
 {SIGURG,	"SIGURG"},
 {SIGSTOP,	"SIGSTOP"},
 {SIGTSTP,	"SIGTSTP"},
 {SIGCONT,	"SIGCONT"},
 {SIGCHLD,	"SIGCHLD"},
 {SIGTTIN,	"SIGTTIN"},
 {SIGTTOU,	"SIGTTOU"},
 {SIGIO,	"SIGIO"},
 {SIGXCPU,	"SIGXCPU"},
 {SIGXFSZ,	"SIGXFSZ"},
 {SIGVTALRM,	"SIGVTALRM"},
 {SIGPROF,	"SIGPROF"},
 {SIGWINCH,	"SIGWINCH"},
/*
 {SIGLOST,	"SIGLOST"},
*/
 {SIGUSR1,	"SIGUSR1"},
 {SIGUSR2,	"SIGUSR2"},
 {0,		NULL}};

static const char *name_that_signal (int sig)
{
  static const char *no_such_signal = "Unknown";
  struct signal_name *this = signal_names;

  while (this->number != sig &&
	 this->name != NULL)
    this++;

  if (this->name == NULL)
    return no_such_signal;
  else
    return this->name;
}
#endif

a107 3
/*
    errno = ESIGNALNO;
*/
a110 3
/*
    errno = ESIGNALRES;
*/
a119 3
/*
    errno = ESIGNALNO;
*/
a122 3
/*
    errno = ESIGNALRES;
*/
a131 3
/*
    errno = ESIGNALNO;
*/
d137 1
a137 28
#if 0
/*  == The C signal handler ==
 *
 *  This function converts a C signal into an ML signal event.
 */

static void signal_ml_handler
  (int sig, int code, struct sigcontext *scp, char *addr)
{
  struct event *event = alloc(sizeof(struct event), "Couldn't allocate event");

  event->type = SIGNAL;
  event->the.signal = sig;

  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;

  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);
  
  /* must set stack underflow here */
  implicit_vector.interrupt = -1;
}

static int check_sigvec (int sig, struct sigaction *vec)
d139 4
a142 1
  int result = sigaction (sig,vec,NULL);
d144 2
a145 9
  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  return result;
a146 2
#endif

a151 9
#if 0
  struct sigaction vec;

  vec.sa_handler = signal_ml_handler;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;

  return (check_sigvec (sig,&vec));
#endif
a156 9
#if 0
  struct sigaction vec;

  vec.sa_handler = SIG_DFL;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;

  return (check_sigvec (sig,&vec));
#endif
a159 36
#if 0
/* Do something tolerable in the face of a fatal signal */

static void handle_die_gracefully(int sig, int code,
				  struct sigcontext *scp, char *addr)
{
  const char *signal_name = name_that_signal (sig);

  DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

  if (in_GC) {
    error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	  signal_name, sig, code);
  }
  message ("Intolerable signal %s (%d : %d) received. Backtrace:",
	   signal_name, sig, code);
/*
  backtrace (stderr, (struct stack_frame *)scp->sc_sp, max_backtrace_depth);
*/
  error ("Dying.");
}

/* Install the above function for a given signal */

static int die_on_signal(int sig)
{
  struct sigaction vec;

  vec.sa_handler = handle_die_gracefully;
  vec.sa_mask = 0;
  vec.sa_flags = SA_STACK;
  
  return (sigaction(sig,&vec,NULL));
}

#endif
d171 1
a171 1
/*
a172 29
*/
}

/*  == Handle math errors in library functions ==
 *
 *  The matherr function is called by the math library when exception
 *  occur.  See matherr(3M).  This function need only handle those
 *  routines we actually provide in reals.[ch]. */

#if 0
extern int matherr(struct exception *e)
{
  char *problem = e->name;

  in_ml_fpe = 0;
  if(strcmp(problem, "log") == 0)
    exn_raise(perv_exn_ref_ln);
  else if(strcmp(problem, "fabs") == 0)
    exn_raise(perv_exn_ref_abs);
  else if(strcmp(problem, "exp") == 0)
    exn_raise(perv_exn_ref_exp);
  else if(strcmp(problem, "sqrt") == 0)
    exn_raise(perv_exn_ref_sqrt);

  message("Warning: Unhandled floating point error in `%s' -- returning %g",
	  problem, e->retval);

  return(e->retval);
}
a173 230

/* == Real arithmetic exception support ==
 *
 *  This function is the handler for the floating point exception
 *  signals.  If called while in ML it examines the instruction which
 *  caused the exception in order to determine which ML exception to
 *  raise.  The signal context is updated in order to change raise the
 *  exception when the handler returns.  */

#if 0
static void signal_real_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  DIAGNOSTIC(1, "signal %d: IEEE exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  /* Find out whether the exception occurred in ML or C.  If in C then we */
  /* can ignore it -- the library will call matherr (qv) */

  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
    if (in_ml_fpe && sig == SIGFPE) {
/*
      message("FP Signal inside fpe, ignoring");
*/
      in_ml_fpe = 0;
    } else {
      message("Warning: signal %d outside ML -- ignoring", sig);
    };
    return;
  }

  /* Check that the instruction type is FPOP */

  if((instruction & 0xC1F00000) != 0x81A00000)
  {
    DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
    message("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  /* Switch on the instruction code : SPARC-specific */

  switch(instruction & 0x00003FE0)
  {
    /* This case should never happen.  We check the size explicitly,
       because we use 30-bit ints instead of 32-bit ints.
    case 0x1A40:
    DIAGNOSTIC(1, "  fdtoi", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_floor);
    break;
    */

    case 0x0540:
    DIAGNOSTIC(1, "  fsqrtd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sqrt);
    break;

    case 0x0840:
    DIAGNOSTIC(1, "  faddd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
    break;

    case 0x08C0:
    DIAGNOSTIC(1, "  fsubd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
    break;

    case 0x0940:
    DIAGNOSTIC(1, "  fmuld", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_prod);
    break;

    case 0x09C0:
    DIAGNOSTIC(1, "  fdivd", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_quot);
    break;

    default:
    DIAGNOSTIC(1, "  unknown fpop instruction", 0, 0);
    message("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
}
#endif

/* == Integer exception support == 
 *
 * This function is the handler for the emulation trap signals. These
 * are caused by ML arithmetic instructions which overflow (and which
 * should therefore raise an exception) and by allocation sequences
 * which run out of heap (and which should therefore cause a GC).

 * If called while in ML it examines the instruction which caused the
 * exception in order to determine which ML exception to raise, or to
 * do a GC.  The signal context is updated in order to raise the
 * exception (or enter the GC code) when the handler returns.  */

#if 0
static void signal_integer_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  if(is_ml_frame((struct stack_frame *)scp->sc_sp) == MLUNIT)
  {
    message("Warning: signal %d outside ML -- ignoring", sig);
    return;
  }

/* Check for allocation traps so we can start a GC.

   Allocation sequences always look like one of the following:

 * 1. Allocating a known amount < 4k:

	taddcctv %g1, #bytes, %g1
	add	rn, %g2, #tag
	add	%g2, %g2, #bytes

 * 2. Allocating an unknown amount, or a known amount > 4k:

 	<get the number of bytes into the 'global' register %g4>
 	taddcctv %g1, %g4, %g1
 	add	rn, %g2, #tag
 	add	%g2, %g2, %g4

 * In a leaf procedure, the 'add rn' instruction (the one after the
 * taddcctv) should be replaced with an 'or rn' instruction. This
 * enables us to distinguish the leaf case.

 * The taddcctv instruction fails if there is insufficient space for
 * the alloc */

#define TADDCCTV_MASK 0xffffc000
#define TADDCCTV_BITS 0x83104000

  if ((instruction & TADDCCTV_MASK) == TADDCCTV_BITS) {
    /* then it's a GC entry point */

    int leaf;
    word instr2;
    word overwrite;

    /* get the number of bytes */

#define TADDCCTV_IMMEDIATE_FLAG_MASK 0x2000
#define TADDCCTV_IMMEDIATE_MASK 0x1fff

    if (instruction & TADDCCTV_IMMEDIATE_FLAG_MASK) {
      gc_trap_bytes = ((instruction & TADDCCTV_IMMEDIATE_MASK));
    } else {
      /* -1 means "the number is in the 'global' register" */
      gc_trap_bytes = 0xffffffff;
    }

    /* We want to return to address+12, so set the fake link register
       to addr+4 */

    gc_trap_return_address = ((word)addr)+4;

    /* construct tagging instruction, which tags the value in the
       return register and puts it in whatever register the allocation
       routine was going to put it. We do this by getting the tagging
       instruction out of the allocation routine and changing the
       register number */

    instr2 = addr[1];

#define GC_RETURN_REGISTER 0x1u
#define GC_TAGGING_SHIFT 14u
#define GC_TAGGING_MASK 0x1fu

    overwrite =
      ((instr2 & (~(GC_TAGGING_MASK << GC_TAGGING_SHIFT)))
       | (GC_RETURN_REGISTER << GC_TAGGING_SHIFT));

    /* was the allocation routine in a leaf procedure? */

#define GC_ENTRY_LEAF_MASK 0x3f
#define GC_ENTRY_LEAF_SHIFT 19
#define GC_ENTRY_LEAF_VALUE 2

    leaf = (((instr2 & (GC_ENTRY_LEAF_MASK << GC_ENTRY_LEAF_SHIFT))
		 >> GC_ENTRY_LEAF_SHIFT) == GC_ENTRY_LEAF_VALUE);

    if (leaf) {
      scp->sc_pc = (int)gc_trap_entry_leaf;
      scp->sc_npc = ((int)gc_trap_entry_leaf)+4;
      *gc_trap_ret_leaf_overwrite = overwrite;
    } else {
      scp->sc_pc = (int)gc_trap_entry;
      scp->sc_npc = ((int)gc_trap_entry)+4;
      *gc_trap_ret_overwrite = overwrite;
    }
    return;
  }

  /* Not a GC trap, so what was it? */

  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  /* Switch on the instruction code: SPARC specific */

  switch(instruction & 0xC1F80000)
  {
    case 0x81180000:
    DIAGNOSTIC(1, "  tsubcctv", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_diff);
    break;

    case 0x81100000:
    DIAGNOSTIC(1, "  taddcctv", 0, 0);
    scp->sc_o0 = DEREF(perv_exn_ref_sum);
    break;

    default:
    DIAGNOSTIC(1, "  not a tagged trap int instruction", 0, 0);
    message("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc = (int)ml_raise;
  scp->sc_npc = (int)ml_raise+4;
a174 1
#endif
a278 7
#define sigmask(i) (1 << (i))

mlval do_exportFn(mlval argument)
{
  exn_raise_string(perv_exn_ref_save, "Function save not implemented");
}

d334 6
a339 1
/* == Profiling support ==
d341 6
a346 3
 * We provide a virtual-time alarm, which goes off after a
 * user-specified number of milliseconds. When it goes off, we call
 * profile_scan(), and restart the alarm when it returns. */
d348 3
a351 1
unsigned int profiling_interval = 0;
d353 1
a353 1
extern void signal_preemption_start(void)
d355 2
d359 4
a362 1
extern void signal_preemption_stop(void)
d364 10
a373 4
}
extern void signal_preemption_change(void)
{
}
d375 1
a375 2
extern void signal_profiling_start(void)
{
d378 1
a378 1
extern void signal_profiling_stop(void)
d380 4
d386 1
a386 4
#if 0
static struct itimerval profiler_timer;

/* The signal handler function. Note that we don't use the arguments at all */
d388 1
a388 3
static void signal_profiler_alarm (int sig, int sig_code,
				  struct sigcontext *scp,
				  char *addr)
d390 1
a390 7
/*
   time_profile_scan((struct stack_frame *) scp->sc_sp);
*/

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
d393 1
a393 4
/* start things off */

#endif
extern void signal_start_profiler_timer(unsigned int interval)
d395 3
a397 15
#if 0
  struct sigaction vec = {signal_profiler_alarm, SIGVTALRM, SA_STACK};

  if(sigaction(SIGVTALRM, &vec, NULL) == -1)
    error("Unable to set up profiler signal handler.");

  profiler_timer.it_value.tv_sec = interval/1000;
  profiler_timer.it_value.tv_usec = (interval%1000)*1000;
  profiler_timer.it_interval.tv_sec = 0;
  profiler_timer.it_interval.tv_usec = 0; /* one shot timer */

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
#endif
d400 1
a400 1
/* kill the timer */
d402 1
a402 1
extern void signal_stop_profiler_timer(void)
d404 2
a405 22
#if 0
  struct sigaction vec = {SIG_DFL, SIGVTALRM, SA_STACK};

  profiler_timer.it_value.tv_sec = profiler_timer.it_value.tv_usec = 0;
  profiler_timer.it_interval.tv_sec = profiler_timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
  {
    message("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    vec.sa_handler = SIG_IGN;

    if(sigaction(SIGVTALRM, &vec, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigaction set errno to %d).",
	    errno);
  }
  if(sigaction(SIGVTALRM, &vec, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message("Warning: Unable to reset alarm signal handler (sigaction set errno "
	    "to %d).", errno);
#endif
d408 1
a408 4
/* a generic routine to make a new copy of some code */

#if 0
static inline word* copy_code(char* start, char* finish)
d410 2
a411 4
  unsigned int bytes = finish-start;
  word *result = (word*)malloc(bytes);
  memcpy(result,start,bytes);
  return result;
d414 1
a414 3
/* copy the two GC return codes into the data segment */

static inline void copy_codes(void)
d416 1
a416 14
#if 0
  gc_trap_ret_code = copy_code((char*) &gc_trap_ret_template,
			       (char*) &gc_trap_ret_template_end);
  gc_trap_ret_leaf_code = copy_code((char*) &gc_trap_ret_leaf_template,
				    (char*) &gc_trap_ret_leaf_template_end);

  gc_trap_ret_overwrite = (word*) (((int)gc_trap_ret_code) +
				   ((int)&gc_trap_ret_template_overwrite) -
				   ((int)&gc_trap_ret_template));
  gc_trap_ret_leaf_overwrite =
    (word*) (((int)gc_trap_ret_leaf_code) +
	     ((int)&gc_trap_ret_leaf_template_overwrite)-
	     ((int)&gc_trap_ret_leaf_template));
#endif
a418 1
#endif
a419 1

d421 2
a422 62
#if 0
  struct sigaction sv;
/*
  struct sigstack ss;
*/
  char *signal_stack;

  /* establish integer arithmetic exception catcher */

#if 0
  sv.sa_handler = signal_integer_exception_handler;
  sv.sa_mask = 0;
  sv.sa_flags = SA_STACK;

  if(sigaction(SIGEMT, &sv, NULL) == -1)
    error("Unable to set integer exception handler.  "
          "sigaction set errno to %d.", errno);
#endif
  /* establish real arithmetic exception catcher */

#if 0
  if(ieee_handler("set", "common",
		  (sigfpe_handler_type) signal_real_exception_handler))
    error("Unable to set floating point exception handler.  "
	  "ieee_handler set errno to %d.", errno);
#endif
  /* Initialise the signal stack */

#if 0
  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack in profiler.");

  ss.ss_sp = signal_stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);
#endif

  /* make copies of GC return codes */

  copy_codes();

  /* these signals are fatal */

  die_on_signal (SIGILL);
  die_on_signal (SIGBUS);
  die_on_signal (SIGSEGV);

  /* these signals are reserved to the runtime */

  signal_reserve (SIGILL);	/* fatal */
  signal_reserve (SIGBUS);	/* fatal */
  signal_reserve (SIGSEGV);	/* fatal */
#if 0
  signal_reserve (SIGEMT);	/* integer exceptions */
#endif
  signal_reserve (SIGFPE);	/* real exceptions */
  signal_reserve (SIGVTALRM);	/* profiling */
  signal_reserve (SIGINT);	/* interrupt */
  signal_reserve (SIGUSR1);	/* stack overflow */
#endif
@
