head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.15
	MLWorks_20c0_1998_08_04:1.15
	MLWorks_20b2c2_1998_06_19:1.15
	MLWorks_20b2_Windows_1998_06_12:1.15
	MLWorks_20b1c1_1998_05_07:1.15
	MLWorks_20b0_1998_04_07:1.15
	MLWorks_20b0_1998_03_20:1.15
	MLWorks_20m2_1998_02_16:1.15
	MLWorks_MM_adapt:1.13.4
	MLWorks_20m1_1997_10_23:1.13
	MLWorks_11r1:1.13.1.1.1.1.1
	MLWorks_workspace_97:1.13.3
	MLWorks_dt_wizard:1.13.2
	MLWorks_11c0_1997_09_09:1.13.1.1.1.1
	MLWorks_10r3:1.13.1.1.3
	MLWorks_10r2_551:1.13.1.1.2
	MLWorks_11:1.13.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.1.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.1
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MM_ML_release_korma_1997_04_01:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.5.1.1
	MLWorks_gui_1996_12_18:1.11.6
	MLWorks_1_0_Win32_1996_12_17:1.11.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.11.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.11.2.1
	JFHrts:1.11.4
	MLWorks_1_0_Irix_1996_11_28:1.11.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.11.3
	MLWorks_1_0_Unix_1996_11_14:1.11.2
	MLWorks_Open_Beta2_1996_10_11:1.11.1
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.8
	MLWorks_Beta_1996_07_02:1.7
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.15
date	97.11.18.09.24.37;	author jont;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	97.11.07.17.08.17;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	97.03.14.10.34.06;	author johnh;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1;
next	1.12;

1.12
date	96.12.19.10.17.26;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.10.07.17.04.12;	author jont;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1
	1.11.4.1
	1.11.5.1
	1.11.6.1;
next	1.10;

1.10
date	96.09.09.17.55.06;	author jont;	state Exp;
branches
	1.10.1.1
	1.10.2.1;
next	1.9;

1.9
date	96.08.22.13.28.49;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.08.07.16.38.24;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	96.06.24.14.20.18;	author stephenb;	state Exp;
branches;
next	1.6;

1.6
date	96.04.22.14.50.50;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.03.01.11.27.07;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	96.02.14.17.37.14;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.02.14.16.23.29;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.02.14.13.15.16;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	95.10.17.13.43.52;	author jont;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.21.55;	author hope;	state Exp;
branches;
next	1.10.1.2;

1.10.1.2
date	96.10.04.15.18.28;	author jont;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.11.59;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.10.17.11.30.50;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.11.14.12.56.45;	author hope;	state Exp;
branches
	1.11.2.1.1.1;
next	;

1.11.2.1.1.1
date	96.11.28.15.07.06;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.11.22.18.14.46;	author hope;	state Exp;
branches;
next	;

1.11.4.1
date	96.12.17.10.01.34;	author hope;	state Exp;
branches;
next	;

1.11.5.1
date	96.12.17.17.53.18;	author hope;	state Exp;
branches
	1.11.5.1.1.1;
next	;

1.11.5.1.1.1
date	97.02.24.11.44.13;	author hope;	state Exp;
branches;
next	;

1.11.6.1
date	96.12.18.09.47.51;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	97.05.12.10.40.15;	author hope;	state Exp;
branches
	1.13.1.1.1.1
	1.13.1.1.2.1
	1.13.1.1.3.1;
next	;

1.13.1.1.1.1
date	97.07.28.18.26.05;	author daveb;	state Exp;
branches
	1.13.1.1.1.1.1.1;
next	;

1.13.1.1.1.1.1.1
date	97.10.07.11.51.51;	author jkbrook;	state Exp;
branches;
next	;

1.13.1.1.2.1
date	97.09.08.17.19.18;	author daveb;	state Exp;
branches;
next	;

1.13.1.1.3.1
date	97.09.09.14.15.26;	author daveb;	state Exp;
branches;
next	;

1.13.2.1
date	97.09.10.19.32.28;	author brucem;	state Exp;
branches;
next	;

1.13.3.1
date	97.09.11.21.01.47;	author daveb;	state Exp;
branches;
next	;

1.13.4.1
date	97.10.31.13.44.44;	author nickb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.18.01.25;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.15
log
@[Bug #30089]
Remove stuff required by old MLWorks.Time
@
text
@/*  ==== PERVASIVE TIME ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 * Now that basis/time.sml and basis/timer.sml are fully implemented on all
 * platforms, all users of the interface (in the pervasive library) which
 * this file implements should move over to using the new basis interface.  
 * Until that time, this file (and the other five like it) has to be
 * maintained :-<
 * 
 *  Implementation
 *  --------------
 * Clock time and intervals are timeval pairs of integers (second,
 * microsecond), obtained from getrusage(2) and gettimeofday(2). File
 * modification times obtained from stat(2) get zero microseconds
 * (this appears unsafe, but actually is safe because stat(2) times
 * could be on a different machine in any case, so must only ever be
 * compared with each other, and not with now()).
 *
 * Times and intervals are represented to ML as triples of ints, a
 * pair for the seconds (each MLint taking 24 bits, allowing for
 * 48-bit values) and one for the microseconds.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win95:time.c,v $
 * Revision 1.14  1997/11/07  17:08:17  jont
 * [Bug #30089]
 * Remove time_file_modified and time_set_file_modified
 *
 * Revision 1.13  1997/03/14  10:34:06  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
 * Revision 1.12  1996/12/19  10:17:26  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
 * Revision 1.10.1.2  1996/10/04  15:18:28  jont
 * Modify timestamp reading to take account of different file systems
 *  types
 *
 * Revision 1.10.1.1  1996/09/13  11:21:55  hope
 * branched from 1.10
 *
 * Revision 1.10  1996/09/09  17:55:06  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
 * Revision 1.9  1996/08/22  13:28:49  jont
 * More problems with time stamp clamping
 *
 * Revision 1.8  1996/08/07  16:38:24  jont
 * Reduce accuracy of file time stamps to cope with portability to FAT
 *
 * Revision 1.7  1996/06/24  14:20:18  stephenb
 * Fix #1363 - Win95: Timings are bogus
 * Replaced the #ifdef'd out bodies of user_clock, get_current_time with
 * versions that get the real time and use that since Win95 doesn't
 * support process timing.
 *
 * Revision 1.6  1996/04/22  14:50:50  jont
 * Sort out removal of floor
 *
 * Revision 1.5  1996/03/01  11:27:07  jont
 * Add mktime, gmtime and localtime
 *
 * Revision 1.4  1996/02/14  17:37:14  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.3  1996/02/14  16:23:29  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.2  1996/02/14  13:15:16  jont
 * Add some type casts to remove warnings under VC++
 *
 * Revision 1.1  1995/10/17  13:43:52  jont
 * new unit
 *
 * Revision 1.8  1995/08/02  14:52:01  jont
 * Rearrange to get rid of compiler errors
 *
 * Revision 1.7  1995/07/17  15:47:47  nickb
 * Add ml_time_microseconds()
 *
 * Revision 1.6  1995/05/02  16:50:23  jont
 * Improve error message from set_time_modified
 *
 * Revision 1.5  1995/03/15  18:11:39  jont
 * Fix problem with the use of FindFirstFile and GetFileTime
 *
 * Revision 1.4  1995/02/07  12:05:25  jont
 * Remove manifest floating point constants in favour of type casts
 *
 * Revision 1.3  1995/01/19  12:51:16  jont
 * Fix decoding of timestamps to be same order as encoding
 *
 * Revision 1.2  1995/01/18  17:20:25  jont
 * Fix timings function bugs (negative and wrong order of magnitude answers)
 * Modified user_time to divide by 10 instead of multiply by 10
 *
 * Revision 1.1  1994/12/12  14:27:40  jont
 * new file
 *
 * Revision 1.2  1994/11/09  11:13:19  jont
 * Fix overflowing integer computation in get_current_time
 *
 * Revision 1.1  1994/10/04  16:29:22  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:27:56  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:52:22  nickh
 * new file
 *
 *  Revision 1.11  1994/03/30  14:57:28  daveb
 *  Revised set_file_modified to take a datatype.
 *
 *  Revision 1.10  1994/03/30  13:49:43  daveb
 *  Added set_file_modified.
 *
 *  Revision 1.9  1994/01/28  17:40:03  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.8  1993/11/23  17:40:25  jont
 *  Exposed the encode and decode time functions for runtime consistency checking
 *  Increased the size of the marshalling buffer to the required size
 *
 *  Revision 1.7  1993/11/17  12:23:56  nickh
 *  Runtime support for new pervasive time structure.
 *  (radical change).
 *
 *  Revision 1.6  1993/06/02  13:10:08  richard
 *  Removed unused variable.
 *
 *  Revision 1.5  1993/04/26  11:50:51  richard
 *  Increased diagnostic levels.
 *
 *  Revision 1.4  1993/02/01  16:04:34  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.3  1992/12/23  13:57:43  richard
 *  Fixed the use of strftime in the case where the format string is empty.
 *
 *  Revision 1.2  1992/11/09  11:58:46  richard
 *  Corrected some missing initialisation.
 *
 *  Revision 1.1  1992/11/03  14:17:17  richard
 *  Initial revision
 *
 */

#include <windows.h> /* FILETIME */

#include "utils.h"
#include "mltypes.h"
#include "time_date.h"

extern void time_init(void)
{
}

/*  user_clock() is like clock(3) except that it returns only the user
 *  virtual time elapsed.
 *
 * Win95 doesn't support processes, so the real time (to the nearest
 * millisecond) is returned instead.
 */

double user_clock(void)
{
  SYSTEMTIME system_time;
  FILETIME user;
  double foo1, foo2;
  GetLocalTime(&system_time);
  (void)SystemTimeToFileTime(&system_time, &user);

  foo1 = (double)user.dwLowDateTime;
  foo2 = (double)user.dwHighDateTime;

  foo1 = foo1 / (double)10;
  foo2 = (foo2 * two_to_32) / (double)10;
  return ((double)user.dwLowDateTime / (double)10
	  + ((double) user.dwHighDateTime * two_to_32) / (double)10);
}
@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a26 4
 * Revision 1.15  1997/11/18  09:24:37  jont
 * [Bug #30089]
 * Remove stuff required by old MLWorks.Time
 *
@


1.14
log
@[Bug #30089]
Remove time_file_modified and time_set_file_modified
@
text
@d27 4
d158 1
a158 6
#include <limits.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
a159 3
#include "ansi.h"
#include "syscalls.h"
#include "mltime.h"
a160 1
#include "allocator.h"
a161 6
#include "values.h"
#include "environment.h"
#include "exceptions.h"
#include "diagnostic.h"
#include "marshal.h"
#include "gc.h"
a162 178
#include "time_zone.h"

/* Converting C time values to an ML value */

#define SPLIT0(t)	((unsigned long)((t).dwHighDateTime) & 0xFFFFFF)
#define SPLIT1(t)	(((unsigned long)((t).dwHighDateTime) >> 24))
#define SPLIT2(t)       ((t).dwLowDateTime >> 2)

#define MLTIME(r,t)                  \
  do {                               \
    FIELD((r),0) = MLINT(SPLIT0(t)); \
    FIELD((r),1) = MLINT(SPLIT1(t)); \
    FIELD((r),2) = MLINT(SPLIT2(t)); \
  } while (0)

/* Converting an ML value to a C time value */

#define JOIN0(t0)       ((unsigned long) (t0))
#define JOIN1(t1)       (((unsigned long) (t1)) << 24)

#define JOIN(t0,t1)	(JOIN0(t0) | JOIN1(t1))

#define JOINI(r)        (JOIN(CINT(FIELD((r),0)), \
                              CINT(FIELD((r),1))))

/* CTIME should be used with care */

#define CTIME(r,t)                               \
  do {                                           \
    (t).dwHighDateTime =  JOINI(r);              \
    (t).dwLowDateTime = (CINT(FIELD(r,2))) << 2; \
  } while (0)

inline mlval ml_time(FILETIME *t)
{
  mlval result = allocate_record(3);

  MLTIME (result,*t);

  return(result);
}

static mlval time_now(mlval unit)
{
  SYSTEMTIME t;
  FILETIME ft;

  GetLocalTime(&t);
  if (!SystemTimeToFileTime(&t, &ft))
    error("Unable to read time of day.  "
	  "SystemTimeToFileTime() set errno to %d.", GetLastError());
  return (ml_time(&ft));
}

static mlval time_format(mlval argument)
{
  mlval result = MLUNIT;
  mlval time_record = FIELD(argument, 2);
  char *format = CSTRING(FIELD(argument, 0));
  time_t t = JOINI(time_record);
  struct tm *timeptr = CINT(FIELD(argument, 1)) ? localtime(&t) : gmtime(&t);
  size_t size;

  if(strlen(format) == 0)
    return(ml_string(""));
  
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, timeptr);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
    }

    free(buffer);
  }

  result = allocate_string(1);
  CSTRING(result)[0] = '\0';
  return(result);
}

static mlval tm_to_time(mlval argument)
{
  /* Interface to mktime. Returns a time_t suitably split up for ml */
  mlval result = MLUNIT;
  struct tm time_val;
  time_t t;
  time_val.tm_sec = CINT(FIELD(argument, 0));
  time_val.tm_min = CINT(FIELD(argument, 1));
  time_val.tm_hour = CINT(FIELD(argument, 2));
  time_val.tm_mday = CINT(FIELD(argument, 3));
  time_val.tm_mon = CINT(FIELD(argument, 4));
  time_val.tm_year = CINT(FIELD(argument, 5));
  time_val.tm_wday = CINT(FIELD(argument, 6));
  time_val.tm_yday = CINT(FIELD(argument, 7));
  time_val.tm_isdst = CINT(FIELD(argument, 8));
  if ((t = mktime(&time_val)) == (time_t)-1) {
    exn_raise_string(perv_exn_ref_io, "tm_to_time:invalid tm");
  } else {
    FILETIME time;
    time.dwHighDateTime = t;
    time.dwLowDateTime = 0;
    result = allocate_record(3);
    MLTIME(result, time);
  }
  return result;
}

static mlval gmtime_to_tm(mlval argument)
{
  /* interface to gmtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = gmtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "gmtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

static mlval localtime_to_tm(mlval argument)
{
  /* interface to localtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = localtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "localtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

/* Are two ML time values equal? Use this to abstract the ML time type
 * from the loader */

extern int ml_time_eq(mlval t1, mlval t2)
{
  mlval *time1 = CPTR(t1);
  mlval *time2 = CPTR(t2);

  if (memcmp(time1, time2, 3*sizeof(mlval)))
    return 0;
  else return 1;
}

extern mlval ml_time_microseconds(double t)
{
  FILETIME tv;
  tv.dwHighDateTime = (unsigned long)(t * 10.0 / two_to_32);
  tv.dwLowDateTime = (unsigned long)(t * 10.0 - ((double)tv.dwHighDateTime * two_to_32));
  return (ml_time(&tv));
}
d164 1
a164 1
static mlval time_print(mlval time)
a165 4
  FILETIME f_time;
  CTIME(time, f_time);
  message("Printed time is %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
  return MLUNIT;
a167 302
/* get the modified timestamp of a file as an ML value; use this in
 * the loader and also provide it to the ML environment */
inline mlval ml_stat(const char *filename)
{
  WIN32_FIND_DATA file_data;
  HANDLE file_handle;

  DIAGNOSTIC(2, "stat(\"%s\")", filename, 0);

  file_handle = FindFirstFile(filename, &file_data);

  if (file_handle == INVALID_HANDLE_VALUE) {
    DIAGNOSTIC(2, "FindFirstFile returns INVALID_HANDLE_VALUE for %s, last error was 0x%x", filename, GetLastError());
    return MLERROR;
  }

  (void)ml_stat_sub(filename, &file_data.ftLastWriteTime);

  return ml_time(&file_data.ftLastWriteTime);
}

static mlval time_less(mlval arg)
{
  FILETIME t1, t2;
  mlval time_record1 = FIELD(arg, 0);
  mlval time_record2 = FIELD(arg, 1);

  CTIME(time_record1, t1);
  CTIME(time_record2, t2);

  return(((t1.dwHighDateTime < t2.dwHighDateTime) 
	  || ((t1.dwHighDateTime == t2.dwHighDateTime) && (t1.dwLowDateTime < t2.dwLowDateTime))) 
	 ? MLTRUE : MLFALSE);
}

mlval time_encode(mlval arg)
{
  char buffer[2*MARSHAL_SIZE_LONG], *end;
  FILETIME t;
  size_t length;
  mlval result;

  CTIME(arg,t);

  end = marshal(buffer, "ll", t.dwHighDateTime,t.dwLowDateTime);

  length = end - buffer;

  result = allocate_string(length+1);
  memcpy(CSTRING(result), buffer, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

mlval time_decode(mlval arg)
{
  FILETIME t;

  unmarshal(CSTRING(arg), "ll", &t.dwHighDateTime, &t.dwLowDateTime);

  return(ml_time(&t));

}

static void timeval_sub (FILETIME *t1,
			 FILETIME *t2,
			 FILETIME *result)
{
  unsigned long a = (unsigned long)t1->dwLowDateTime;
  unsigned long b = (unsigned long)t2->dwLowDateTime;
  result->dwHighDateTime  = t1->dwHighDateTime  - t2->dwHighDateTime;
  result->dwLowDateTime = t1->dwLowDateTime - t2->dwLowDateTime;
  /* Now sort out extended overflow */
  if (a < b) result->dwHighDateTime -= 1;
}

static void timeval_add (FILETIME *t1,
			 FILETIME *t2,
			 FILETIME *result)
{
  unsigned long a = (unsigned long)t1->dwLowDateTime;
  result->dwHighDateTime  = t1->dwHighDateTime  + t2->dwHighDateTime;
  result->dwLowDateTime = t1->dwLowDateTime + t2->dwLowDateTime;
  /* Now sort out extended overflow */
  if (a < (unsigned long)result->dwLowDateTime) result->dwHighDateTime += 1;
}

static mlval interval_to_real (mlval arg)
{
  mlval result;
  FILETIME t;
  double tm;

  CTIME (arg,t);

  result = allocate_real();

  tm = (t.dwHighDateTime * two_to_32 + t.dwLowDateTime) / ((double)mlw_time_ticks_per_sec);

  (void) SETREAL(result,tm);
  return result;
}

static mlval interval_from_real (mlval arg)
{
  FILETIME t;
  double tm = GETREAL(arg);
  double foo = tm * ((double)mlw_time_ticks_per_sec);
  if (tm > LONG_MAX || tm < LONG_MIN) {
    exn_raise (perv_exn_ref_overflow);
  }


  t.dwHighDateTime = (DWORD)(foo / two_to_32);
  t.dwLowDateTime = (DWORD)(foo - t.dwHighDateTime * two_to_32);

  return (ml_time (&t));
}


static FILETIME start_time;

static struct time_record {FILETIME t_user;
			   FILETIME t_sys;
			   FILETIME t_gc;
			   FILETIME t_real;
			 } current_time;

/*
 * Win95 does not support processes, so instead of GetProcessTimes, 
 * GetSystemTime is used to get the real time used.  It is a hack
 * but it is the best that can be done.
 */

static inline void get_current_time (void)
{
  FILETIME user;
  FILETIME t;
  DWORD time = GetTickCount();

  current_time.t_gc.dwHighDateTime = (DWORD)((gc_clock * 10) / two_to_32);
  current_time.t_gc.dwLowDateTime =
    (DWORD)(gc_clock * 10 - ((double)current_time.t_gc.dwHighDateTime * two_to_32));

  {
    SYSTEMTIME system_time;
    GetLocalTime(&system_time);
    (void)SystemTimeToFileTime(&system_time, &user);
  }

  timeval_sub(&user, &current_time.t_gc, &current_time.t_user);

  t.dwHighDateTime = (DWORD)(((double)time * (double)10000) / two_to_32);
  t.dwLowDateTime = (DWORD)(((double)time * (double)10000) - t.dwHighDateTime * two_to_32);

  timeval_sub(&t, &start_time, &current_time.t_real);
}  




static inline mlval return_current_time (void)
{
  mlval result;
  mlval t_gc,t_real,t_sys,t_user;

  t_gc = ml_time(&current_time.t_gc);
  declare_root(&t_gc);
  t_real = ml_time(&current_time.t_real);
  declare_root(&t_real);
  t_user = ml_time(&current_time.t_user);
  declare_root(&t_user);
  t_sys = ml_time(&current_time.t_sys);   
  declare_root(&t_sys);

  result = allocate_record(4);

  /* field ordering alphabetic: gc, real, sys, user */

  FIELD(result,0) = t_gc;
  FIELD(result,1) = t_real;
  FIELD(result,2) = t_sys;
  FIELD(result,3) = t_user;

  retract_root(&t_gc);
  retract_root(&t_user);
  retract_root(&t_sys);
  retract_root(&t_real);

  return(result);
}

static mlval elapsed (mlval unit)
{
  get_current_time ();
  return (return_current_time());
}

#define DEBUG_TIMES 0

static mlval elapsed_since (mlval arg)
{
  FILETIME t1;

  get_current_time();

  CTIME(FIELD(arg,0),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous gc time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current gc time set to %u, %u\n",
	  current_time.t_gc.dwHighDateTime, current_time.t_gc.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_gc, &t1, &current_time.t_gc);
  CTIME(FIELD(arg,1),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous real time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current real time set to %u, %u\n",
	  current_time.t_real.dwHighDateTime, current_time.t_real.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_real, &t1, &current_time.t_real);
  CTIME(FIELD(arg,2),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous system time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current system time set to %u, %u\n",
	  current_time.t_sys.dwHighDateTime, current_time.t_sys.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_sys, &t1, &current_time.t_sys);
  CTIME(FIELD(arg,3),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous user time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current user time set to %u, %u\n",
	  current_time.t_user.dwHighDateTime, current_time.t_user.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_user, &t1, &current_time.t_user);

  return(return_current_time());
}

static mlval interval (mlval arg)
{
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}


static mlval time_subtract (mlval arg)
{
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_add (mlval arg)
{
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_add (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_to_string (mlval arg)
{
  FILETIME t;
  int digits = CINT(FIELD(arg,1));
  double the_time;
  char buffer[50];
  char *p = buffer;

  CTIME(FIELD(arg,0),t);

  /* Convert to seconds */
  the_time = (((double)t.dwHighDateTime) * two_to_32 + t.dwLowDateTime) / ((double)mlw_time_ticks_per_sec);

  /* give a maximum of 6 digits */

  if (digits > 6 || digits < 0)
    digits = 6;

  sprintf(p, "%.*f", digits, the_time);

  return (ml_string(buffer));
}



a189 41
}



void time_init()
{
  mlval zero;

  DWORD time = GetTickCount();
  /* get clock start time for elapsed record */
  start_time.dwHighDateTime = (DWORD)(((double)time * (double)10000) / two_to_32);
  start_time.dwLowDateTime = (DWORD)(((double)time * (double)10000) - start_time.dwHighDateTime * two_to_32);

  zero = allocate_record(4);
  FIELD(zero, 0) = MLINT(0);
  FIELD(zero, 1) = MLINT(0);
  FIELD(zero, 2) = MLINT(0);
  FIELD(zero, 3) = MLINT(0);

  env_value("time zero", zero);
  env_function("time now", time_now);
  env_function("time less", time_less);
  env_function("time add", time_add);
  env_function("time subtract", time_subtract);

  env_function("time encode", time_encode);
  env_function("time decode", time_decode);

  env_function("time to string",time_to_string);
  env_function("time format", time_format);
  env_function("time mktime", tm_to_time);
  env_function("time gmtime", gmtime_to_tm);
  env_function("time localtime", localtime_to_tm);

  env_function("time interval",interval);
  env_function("interval to real",interval_to_real);
  env_function("interval from real",interval_from_real);

  env_function("time elapsed",elapsed);
  env_function("time elapsed since",elapsed_since);
  env_function("time print", time_print);
@


1.13
log
@[Bug #1850]
Replacing FindFirstFile with CreateFile - see comments.
@
text
@d27 4
a381 55
static mlval time_file_modified(mlval arg)
{
  mlval result = ml_stat(CSTRING(arg));

  if (result == MLERROR)
    exn_raise_format(perv_exn_ref_io,
		     "Cannot mtime %s: does not exist",
		     CSTRING(arg));
  return result;
}

static mlval time_set_file_modified(mlval arg)
{
  FILETIME m_tv;
  HANDLE file_handle;

  char* path = CSTRING(FIELD(arg, 0));

  /* This call to CreateFile replaced a call to FindFirstFile which waas simpler,
     but the problem was that it returned the wrong type of file handle.  The
     file handle returned by calls to FindFirstFile and FindNextFile cannot be 
     used by SetFileTime.  File handles returned by FindFirstFile and FindNextFile
     should be used to find a list of files matching certain criteria, but if 
     any of the file attributes need to be changed, these file handles are of 
     no use since they do not have write access, and therefore the file handle
     returned by CreateFile is needed.  Also note that although the function is
     called CreateFile, in the case below it only opens existing files.  */

  if ((file_handle = CreateFile(path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
	OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    exn_raise_format(perv_exn_ref_io, "Cannot SetFileTime %s", path);

  /*  datatype modtime = NOW | TIME of Time.time  */
  if (MLVALISPTR(FIELD(arg, 1))) {
    mlval time_record = FIELD(FIELD(arg, 1), 1);
    CTIME(time_record, m_tv);
  } else {
    SYSTEMTIME system_time;
    GetSystemTime(&system_time);
    if (SystemTimeToFileTime(&system_time, &m_tv) != TRUE)
      exn_raise_format(perv_exn_ref_io, "Cannot set time of %s", path);
  }

  DIAGNOSTIC(2, "real_set_file_modified(\"%s\"), modtime = %s",
	     path, MLVALISPTR(FIELD(arg, 1)) ? "user specified time" : "now");

  if(SetFileTime(file_handle, NULL, NULL, &m_tv) != TRUE)
    exn_raise_format(perv_exn_ref_io, "Cannot SetFileTime %s", path);

  if (CloseHandle(file_handle) == 0)
    exn_raise_format(perv_exn_ref_io, "Cannot CloseHandle");

  return MLUNIT;
}

a717 3

  env_function("time file modified", time_file_modified);
  env_function("time set file modified", time_set_file_modified);
@


1.13.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a26 4
 * Revision 1.13  1997/03/14  10:34:06  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.13.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a26 4
 * Revision 1.13  1997/03/14  10:34:06  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.13.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a26 4
 * Revision 1.13  1997/03/14  10:34:06  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a26 4
 * Revision 1.13  1997/03/14  10:34:06  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.13.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a26 3
 * Revision 1.13.1.1  1997/05/12  10:40:15  hope
 * branched from 1.13
 *
@


1.13.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a26 3
 * Revision 1.13.1.1  1997/05/12  10:40:15  hope
 * branched from 1.13
 *
@


1.13.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a26 3
 * Revision 1.13.1.1  1997/05/12  10:40:15  hope
 * branched from 1.13
 *
@


1.13.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a26 3
 * Revision 1.13.1.1.1.1  1997/07/28  18:26:05  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.12
log
@[Bug #1791]
MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
to avoid any binding problems
@
text
@d27 5
a391 1
  WIN32_FIND_DATA file_data;
d396 12
a407 1
  if ((file_handle = FindFirstFile(path, &file_data)) == INVALID_HANDLE_VALUE)
d409 1
a409 1
  
d426 3
@


1.11
log
@Merging in beta updates
@
text
@d27 3
d173 6
a178 3
#define MLTIME(r,t)      {FIELD((r),0) = MLINT(SPLIT0(t)); \
                          FIELD((r),1) = MLINT(SPLIT1(t)); \
			  FIELD((r),2) = MLINT(SPLIT2(t));}
d192 5
a196 2
#define CTIME(r,t)      {(t).dwHighDateTime =  JOINI(r); \
                         (t).dwLowDateTime = (CINT(FIELD(r,2))) << 2;}
@


1.11.6.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.11.5.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.11.5.1.1.1
log
@branched from 1.11.5.1
@
text
@a26 3
 * Revision 1.11.5.1  1996/12/17  17:53:18  hope
 * branched from 1.11
 *
@


1.11.4.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.11.3.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.11.2.1.1.1
log
@branched from 1.11.2.1
@
text
@a26 3
 * Revision 1.11.2.1  1996/11/14  12:56:45  hope
 * branched from 1.11
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a26 3
 * Revision 1.11  1996/10/07  17:04:12  jont
 * Merging in beta updates
 *
@


1.10
log
@Remove use of ten_million in favour of mlw_ticks_per_sec
Move two_to_32 into time_date.h
@
text
@d27 11
a188 1

d335 7
a341 1
#define double_time(t) (((double)t.dwHighDateTime * two_to_32) + ((double)t.dwLowDateTime))
a344 1

a348 3
  TIME_ZONE_INFORMATION tz;
  LONG bias;
  int res;
a351 8
  res = get_timezone(&tz);
  if (res) {
    bias = tz.Bias;
    if (bias != 0) {
      tz.Bias = 0;
      set_timezone(&tz);
    };
  }
a352 4
  if (res && (bias != 0)) {
    tz.Bias = bias;
    set_timezone(&tz);
  };
d358 4
a361 18
/*
  message("Original time was %lu, %lu, %f", file_data.ftLastWriteTime.dwHighDateTime, file_data.ftLastWriteTime.dwLowDateTime, double_time(file_data.ftLastWriteTime));
*/
  DIAGNOSTIC(2, "  mtime = %lu, %lu", file_data.ftLastWriteTime.dwHighDateTime, file_data.ftLastWriteTime.dwLowDateTime);
  
  time_stamp_clamp(&(file_data.ftLastWriteTime));
/*
  message("Clamped time is %lu, %lu, %f", file_data.ftLastWriteTime.dwHighDateTime, file_data.ftLastWriteTime.dwLowDateTime, double_time(file_data.ftLastWriteTime));
*/
  return(ml_time(&(file_data.ftLastWriteTime)));
}
  
static mlval time_print(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  message("Printed time is %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
  return MLUNIT;
d366 1
a366 1
  mlval result = ml_stat (CSTRING(arg));
@


1.10.2.1
log
@branched from 1.10
@
text
@a26 4
 * Revision 1.10  1996/09/09  17:55:06  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a26 4
 * Revision 1.10  1996/09/09  17:55:06  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
@


1.10.1.2
log
@Modify timestamp reading to take account of different file systems
 types
@
text
@a26 3
 * Revision 1.10.1.1  1996/09/13  11:21:55  hope
 * branched from 1.10
 *
d182 1
d329 1
a329 7
static mlval time_print(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  message("Printed time is %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
  return MLUNIT;
}
d333 1
d338 3
d344 8
d353 4
d362 18
a379 4

  (void)ml_stat_sub(filename, &file_data.ftLastWriteTime);

  return ml_time(&file_data.ftLastWriteTime);
d384 1
a384 1
  mlval result = ml_stat(CSTRING(arg));
@


1.9
log
@More problems with time stamp clamping
@
text
@d27 3
d151 1
a316 3
static double two_to_32 = (double)(1 << 16) * (double)(1 << 16);
static double ten_million = (double)10000000;

a324 29
/*
 * A function to clamp timestamps to one second because FAT
 * is too stupid to do any better. It turns out that InstallShield
 * rounds up to the nearest two seconds, so that's what we must do.
 */

#define ticks_per_two_secs (2*mlw_time_ticks_per_sec)

inline void time_stamp_clamp(FILETIME *t)
{
  DWORD hi = t->dwHighDateTime,
        lo = t->dwLowDateTime;
  unsigned long remainder = (((((((((((((hi % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 4) + lo % ticks_per_two_secs) % ticks_per_two_secs;
  /* The above horrible expression is done this way to ensure */
  /* that the modulus we calculate doesn't have an overflow in the middle */
  /* I'm not sure if it's necessary, but it's certainly sufficient! */
  if (remainder != 0) {
    /* Only round up if not an exact second */
    unsigned long up = ticks_per_two_secs - remainder;
    lo += up;
    if (lo < up) {
      /* Addition overflow */
      hi += 1;
    }
  }
  t->dwHighDateTime = hi;
  t-> dwLowDateTime = lo; /* And put the result back */
}

d334 3
d339 9
d349 4
d370 8
d497 1
a497 1
  tm = (t.dwHighDateTime * two_to_32 + t.dwLowDateTime) / ten_million;
d507 1
a507 1
  double foo = tm * ten_million;
d687 1
a687 1
  the_time = (((double)t.dwHighDateTime) * two_to_32 + t.dwLowDateTime) / ten_million;
d766 1
@


1.8
log
@Reduce accuracy of file time stamps to cope with portability to FAT
@
text
@d27 3
d336 1
a336 1
  unsigned long remainder = (((((((((hi % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) + lo % ticks_per_two_secs) % ticks_per_two_secs;
@


1.7
log
@Fix #1363 - Win95: Timings are bogus
Replaced the #ifdef'd out bodies of user_clock, get_current_time with
versions that get the real time and use that since Win95 doesn't
support process timing.
@
text
@d27 6
d144 1
d321 31
d367 4
d372 4
a375 1
  DIAGNOSTIC(2, "  mtime = %lu, %lu", file_data.ftLastWriteTime.dwHighDateTime, file_data.ftLastWriteTime.dwLowDateTime);
a376 1

a767 1
  
@


1.6
log
@Sort out removal of floor
@
text
@d5 6
d27 3
d485 6
d493 1
a493 4
#ifdef Win95
/* Don't try anything with Process Time on Win95 */
#else
  FILETIME creation, death, user;
d501 5
a505 3
  if((GetProcessTimes(GetCurrentProcess(), &creation, &death, &current_time.t_sys, &user)) != TRUE)
    error("Unable to read resource consumption.  "
	  "GetProcessTimes() set errno to %d.", GetLastError());
d513 3
a515 1
#endif
a516 1
}  
d656 2
d660 3
d665 1
a665 1
extern double user_clock(void)
d667 2
a668 6
#ifdef Win95
/* No GetProcessTimes on Win95 */
  return 0.0;
#else
  FILETIME creation, death, kernel, user;

d670 2
a671 3
  if((GetProcessTimes(GetCurrentProcess(), &creation, &death, &kernel, &user)) != TRUE)
    error("Unable to read resource consumption.  "
	  "GetProcessTimes() set errno to %d.", GetLastError());
a679 1
#endif
d681 2
@


1.5
log
@Add mktime, gmtime and localtime
@
text
@d21 3
d457 1
a457 1
    exn_raise (perv_exn_ref_floor);
@


1.4
log
@ISPTR becomes MLVALISPTR
@
text
@d21 3
d205 73
d297 2
a298 2
  tv.dwHighDateTime = (unsigned)(t * 10.0 / two_to_32);
  tv.dwLowDateTime = (unsigned)(t * 10.0 - ((double)tv.dwHighDateTime * two_to_32));
d691 3
@


1.3
log
@Changing ERROR to MLERROR
@
text
@d21 3
d270 1
a270 1
  if (ISPTR(FIELD(arg, 1))) {
d281 1
a281 1
	     path, ISPTR(FIELD(arg, 1)) ? "user specified time" : "now");
@


1.2
log
@Add some type casts to remove warnings under VC++
@
text
@d21 3
d236 1
a236 1
    return ERROR;
d248 1
a248 1
  if (result == ERROR)
@


1.1
log
@new unit
@
text
@d20 4
a23 1
 *  $Log: src:OS:NT:time.c,v $
d215 2
a216 2
  tv.dwHighDateTime = t * 10.0 / two_to_32;
  tv.dwLowDateTime = t * 10.0 - ((double)tv.dwHighDateTime * two_to_32);
@
