head	1.37;
access;
symbols
	MLW_daveb_inline_1_4_99:1.37.10
	MLWorks_21c0_1999_03_25:1.37
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.37
	MLWorks_20b0_1998_04_07:1.37
	MLWorks_20b0_1998_03_20:1.37
	MLWorks_20m2_1998_02_16:1.37
	MLWorks_MM_adapt:1.37.9
	MLWorks_20m1_1997_10_23:1.37
	MLWorks_11r1:1.37.6.1.1.1.1
	MLWorks_workspace_97:1.37.8
	MLWorks_dt_wizard:1.37.7
	MLWorks_11c0_1997_09_09:1.37.6.1.1.1
	MLWorks_10r3:1.37.6.1.3
	MLWorks_10r2_551:1.37.6.1.2
	MLWorks_11:1.37.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.37.6.1
	MLWorks_20m0_1997_06_20:1.37
	MLWorks_1_0_r2c2_1997_06_14:1.37.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.37.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.37.6
	MLWorks_BugFix_1997_04_24:1.37
	MLWorks_1_0_r2_Win32_1997_04_11:1.37
	MLWorks_1_0_r2_Unix_1997_04_04:1.37
	MM_ML_release_korma_1997_04_01:1.37
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.37.4.1.1
	MLWorks_gui_1996_12_18:1.37.5
	MLWorks_1_0_Win32_1996_12_17:1.37.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.37.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.37.1.1
	JFHrts:1.37.3
	MLWorks_1_0_Irix_1996_11_28:1.37.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.37.2
	MLWorks_1_0_Unix_1996_11_14:1.37.1
	MLWorks_Open_Beta2_1996_10_11:1.35.3
	MLWorks_License_dev:1.35.2
	MLWorks_1_open_beta_1996_09_13:1.35.1
	MLWorks_Open_Beta_1996_08_22:1.35
	MLWorks_Beta_1996_07_02:1.35
	MLWorks_Beta_1996_06_07:1.35
	MLWorks_Beta_1996_06_06:1.34
	MLWorks_Beta_1996_06_05:1.34
	MLWorks_Beta_1996_06_03:1.34
	MLWorks_Beta_1996_05_31:1.34
	MLWorks_Beta_1996_05_30:1.34
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.37
date	96.10.25.12.49.08;	author stephenb;	state Exp;
branches
	1.37.1.1
	1.37.2.1
	1.37.3.1
	1.37.4.1
	1.37.5.1
	1.37.6.1
	1.37.7.1
	1.37.8.1
	1.37.9.1
	1.37.10.1;
next	1.36;

1.36
date	96.10.17.14.55.11;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	96.06.07.09.31.44;	author jont;	state Exp;
branches
	1.35.1.1
	1.35.2.1
	1.35.3.1;
next	1.34;

1.34
date	96.05.14.12.11.48;	author stephenb;	state Exp;
branches;
next	1.33;

1.33
date	96.04.30.12.00.58;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	96.04.19.11.01.58;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	96.02.08.15.59.21;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	96.02.08.13.21.13;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	96.02.07.12.14.38;	author nickb;	state Exp;
branches;
next	1.28;

1.28
date	96.01.17.16.30.23;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	96.01.16.13.46.13;	author nickb;	state Exp;
branches;
next	1.26;

1.26
date	96.01.16.12.06.31;	author stephenb;	state Exp;
branches;
next	1.25;

1.25
date	96.01.12.16.25.22;	author stephenb;	state Exp;
branches;
next	1.24;

1.24
date	96.01.11.14.47.48;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	96.01.09.12.34.10;	author nickb;	state Exp;
branches;
next	1.22;

1.22
date	96.01.02.12.23.04;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.12.12.16.17.27;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	95.09.19.15.18.55;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.09.15.16.28.30;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	95.07.17.10.01.00;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.07.03.10.18.13;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.06.12.15.28.23;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	95.06.06.12.22.52;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.05.23.09.29.10;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.05.04.10.45.52;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.05.02.12.33.50;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.04.27.13.03.59;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	95.04.24.15.17.19;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.04.12.12.09.30;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.03.15.16.43.58;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.01.05.11.33.44;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	94.11.23.16.50.02;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.10.19.16.52.53;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.09.07.10.06.43;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.07.25.14.01.54;	author nickh;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.07.13.16.20.23;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.47.45;	author jont;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.29.04;	author hope;	state Exp;
branches;
next	;

1.35.1.1
date	96.09.13.11.21.43;	author hope;	state Exp;
branches;
next	;

1.35.2.1
date	96.10.07.16.11.47;	author hope;	state Exp;
branches;
next	1.35.2.2;

1.35.2.2
date	96.10.09.11.57.33;	author nickb;	state Exp;
branches;
next	;

1.35.3.1
date	96.10.17.11.30.30;	author hope;	state Exp;
branches;
next	;

1.37.1.1
date	96.11.14.12.56.27;	author hope;	state Exp;
branches
	1.37.1.1.1.1;
next	;

1.37.1.1.1.1
date	96.11.28.15.06.53;	author hope;	state Exp;
branches;
next	;

1.37.2.1
date	96.11.22.18.14.33;	author hope;	state Exp;
branches;
next	;

1.37.3.1
date	96.12.17.10.01.20;	author hope;	state Exp;
branches;
next	;

1.37.4.1
date	96.12.17.17.53.04;	author hope;	state Exp;
branches
	1.37.4.1.1.1;
next	;

1.37.4.1.1.1
date	97.02.24.11.43.58;	author hope;	state Exp;
branches;
next	;

1.37.5.1
date	96.12.18.09.47.38;	author hope;	state Exp;
branches;
next	;

1.37.6.1
date	97.05.12.10.40.02;	author hope;	state Exp;
branches
	1.37.6.1.1.1
	1.37.6.1.2.1
	1.37.6.1.3.1;
next	;

1.37.6.1.1.1
date	97.07.28.18.28.44;	author daveb;	state Exp;
branches
	1.37.6.1.1.1.1.1;
next	;

1.37.6.1.1.1.1.1
date	97.10.07.11.54.35;	author jkbrook;	state Exp;
branches;
next	;

1.37.6.1.2.1
date	97.09.08.17.21.40;	author daveb;	state Exp;
branches;
next	;

1.37.6.1.3.1
date	97.09.09.14.17.45;	author daveb;	state Exp;
branches;
next	;

1.37.7.1
date	97.09.10.19.36.53;	author brucem;	state Exp;
branches;
next	;

1.37.8.1
date	97.09.11.21.05.01;	author daveb;	state Exp;
branches;
next	;

1.37.9.1
date	97.10.31.13.48.04;	author nickb;	state Exp;
branches;
next	;

1.37.10.1
date	99.04.01.18.03.47;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.37
log
@[Bug #1700]
Convert from sigvec -> sigaction so that it is possible to
add a SA_RESTART to the flags in set_signal_handler and therefore
avoid interrupted system calls.
@
text
@/* ==== SIGNAL HANDLING ====
 * 
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * This module abstracts the OS-specific signal handling code from
 * the various parts of the runtime system.
 *
 * 
 * Revision Log
 * ------------
 * $Log: src:OS:Irix:arch:MIPS:signals.c,v $
 * Revision 1.36  1996/10/17  14:55:11  jont
 * Merge in license stuff
 *
 * Revision 1.35.2.2  1996/10/09  11:57:33  nickb
 * Move to Harlequin license server.
 *
 * Revision 1.35.2.1  1996/10/07  16:11:47  hope
 * branched from 1.35
 *
 * Revision 1.35  1996/06/07  09:31:44  jont
 * Update best before to 01/01/97
 *
 * Revision 1.34  1996/05/14  12:11:48  stephenb
 * Remove the #define LANGUAGE_C as this is now defined for all files
 *
 * Revision 1.33  1996/04/30  12:00:58  matthew
 * Reinstating signal handler for integer
 *
 * Revision 1.32  1996/04/19  11:01:58  matthew
 * Different exceptions for integer operations
 * No trapping for real operations
 *
 * Revision 1.31  1996/02/08  15:59:21  jont
 * Removing do_exportFn, as this is no longer architecture dependent
 *
 * Revision 1.30  1996/02/08  13:21:13  jont
 * Modify exportFn mechanism not to use signals at all
 * Use busy waiting in parent instead, thus avoiding
 * potential race contions
 *
 * Revision 1.29  1996/02/07  12:14:38  nickb
 * Make interval window updates happen even if we stay in ML.
 *
 * Revision 1.28  1996/01/17  16:30:23  nickb
 * Disable interrupt handling except when a handler is defined.
 *
 * Revision 1.27  1996/01/16  13:46:13  nickb
 * Getting rid of sm_interface().
 *
 * Revision 1.26  1996/01/16  12:06:31  stephenb
 * Fix bug #995 - death of last thread due to a fatal signal should
 * result in a non-zero termination code.
 *
 * Revision 1.25  1996/01/12  16:25:22  stephenb
 * Fix handle_fatal_signal so that it deals with a fatal signal
 * being raised whilst handling a fatal signal.
 *
 * Revision 1.24  1996/01/11  14:47:48  nickb
 * Add timer-triggered window updates.
 *
 * Revision 1.23  1996/01/09  12:34:10  nickb
 * Extensions to event handling for non-signal events.
 *
 * Revision 1.22  1996/01/02  12:23:04  nickb
 * Update best-before date to 1996-07-01.
 *
 * Revision 1.21  1995/12/12  16:17:27  nickb
 * Extend closure check in the profiling code.
 *
 * Revision 1.20  1995/09/19  15:18:55  nickb
 * Improve the full GC we do during function export.
 *
 * Revision 1.19  1995/09/15  16:28:30  jont
 * Add do_exportFn to do the system specific part of exportFn
 *
 * Revision 1.18  1995/07/17  10:01:00  nickb
 * Change profiler interface.
 *
 * Revision 1.17  1995/07/03  10:18:13  nickb
 * Update best-before date.
 *
 * Revision 1.16  1995/06/12  15:28:23  nickb
 * Fix minor thinko in fatal_signal.
 *
 * Revision 1.15  1995/06/06  12:22:52  nickb
 * Improve fatal signal support.
 *
 * Revision 1.14  1995/05/23  09:29:10  nickb
 * Fatal signal code not fixing up the stack correctly.
 *
 * Revision 1.13  1995/05/04  10:45:52  nickb
 * Remove diagnostic printing.
 *
 * Revision 1.12  1995/05/02  12:33:50  nickb
 * Get signal handling &c to work.
 *
 * Revision 1.11  1995/04/27  13:03:59  daveb
 * If signal_ml_handler is called while we are waiting for an X event,
 * the runtime just prints a message.  This avoids problems with pointer
 * grabs in X callbacks.
 *
 * Revision 1.10  1995/04/24  15:17:19  nickb
 * Add thread_preemption_pending.
 *
 * Revision 1.9  1995/04/12  12:09:30  nickb
 * Make fatal signal messages come out on stderr.
 *
 * Revision 1.8  1995/03/15  16:43:58  nickb
 * Introduce the threads system.
 *
 * Revision 1.7  1995/01/05  11:33:44  nickb
 * Amend best-before date to 1st July 1995.
 * Also fix Harlequin's telephone number.
 * Also make license signal handler run on the current stack.
 *
 * Revision 1.6  1994/11/23  16:50:02  nickb
 * Remove set_stack_underflow() call.
 *
 * Revision 1.5  1994/10/19  16:52:53  nickb
 * Add includes.
 *
 * Revision 1.4  1994/09/07  10:06:43  jont
 * Update license expiry date
 *
 * Revision 1.3  1994/07/25  14:01:54  nickh
 * Make sure signal handlers get executed on the signal stack.
 *
 * Revision 1.2  1994/07/13  16:20:23  jont
 * Add signal_interrupt
 *
 * Revision 1.1  1994/07/12  12:47:45  jont
 * new file
 *
 */

#include <math.h>
#include "signals.h"
#include "utils.h"
#include "diagnostic.h"
#include "interface.h"
#include "implicit.h"
#include "values.h"
#include "gc.h"
#include "stacks.h"
#include "syscalls.h"
#include "exceptions.h"
#include "event.h"
#include "license.h"
#include "profiler.h"
#include "ansi.h"
#include "reals.h"
#include "state.h"
#include "threads.h"
#include "x.h"
#include "main.h"
#include "pervasives.h"
#include "global.h"
#include "allocator.h"
#include "image.h"

#include <time.h>
#include <sys/types.h>
#include <sys/time.h>
#include <signal.h>		/* sigaction */
#include <string.h>
#include <memory.h>
#include <errno.h>		/* errno */
#include <sym.h>
#include <exception.h>
#include <unistd.h>
#include <sys/fpu.h>

#define SC_REG(scp,reg)	((scp)->sc_regs[reg].lo32)

#define SC_ARG(scp)	SC_REG(scp,4)
#define SC_SLIMIT(scp)	SC_REG(scp,7)
#define SC_SP(scp)	SC_REG(scp,29)
#define SC_FP(scp)	SC_REG(scp,30)
#define SC_CLOSURE(scp)	SC_REG(scp,6)
#define SC_BASE(scp)	SC_REG(scp,25)
#define SC_PC(scp)	((scp)->sc_pc.lo32)
#define SC_BRANCH_DELAY(scp)	(((long)(scp)->sc_cause.lo32)<0)

/* ML signal handler support */

#define NR_SIGNALS	32
#define SIGNAL_STACK_SIZE 	8192

unsigned int signal_nr_signals = NR_SIGNALS;

/* an array of flags showing how signals are handled */

#define SIGNAL_NOT_HANDLED 	((word)0)
#define SIGNAL_HANDLED_IN_ML	((word)1)
#define SIGNAL_HANDLED_IN_C	((word)2)
#define SIGNAL_HANDLED_FATALLY	((word)4)

static word *signal_handled = NULL;

static struct signal_name {int number;
			   const char *name;
			 } signal_names [] =
{{SIGHUP,	"SIGHUP"},
 {SIGINT,	"SIGINT"},
 {SIGQUIT,	"SIGQUIT"},
 {SIGILL,	"SIGILL"},
 {SIGTRAP,	"SIGTRAP"},
 {SIGABRT,	"SIGABRT"},
 {SIGEMT,	"SIGEMT"},
 {SIGFPE,	"SIGFPE"},
 {SIGKILL,	"SIGKILL"},
 {SIGBUS,	"SIGBUS"},
 {SIGSEGV,	"SIGSEGV"},
 {SIGSYS,	"SIGSYS"},
 {SIGPIPE,	"SIGPIPE"},
 {SIGALRM,	"SIGALRM"},
 {SIGTERM,	"SIGTERM"},
 {SIGUSR1,	"SIGUSR1"},
 {SIGUSR2,	"SIGUSR2"},
 {SIGCHLD,	"SIGCHLD"},
 {SIGPWR,	"SIGPWR"},
 {SIGWINCH,	"SIGWINCH"},
 {SIGURG,	"SIGURG"},
 {SIGIO,	"SIGIO"},
 {SIGSTOP,	"SIGSTOP"},
 {SIGTSTP,	"SIGTSTP"},
 {SIGCONT,	"SIGCONT"},
 {SIGTTIN,	"SIGTTIN"},
 {SIGTTOU,	"SIGTTOU"},
 {SIGVTALRM,	"SIGVTALRM"},
 {SIGPROF,	"SIGPROF"},
 {SIGXCPU,	"SIGXCPU"},
 {SIGXFSZ,	"SIGXFSZ"},
 {0,		NULL}};

static const char *name_that_signal (int sig)
{
  static const char *no_such_signal = "Unknown";
  struct signal_name *this = signal_names;

  while (this->number != sig &&
	 this->name != NULL)
    this++;

  if (this->name == NULL)
    return no_such_signal;
  else
    return this->name;
}

/* Irix-specific stuff for setting and clearing a signal handler */

static int check_sigaction(int sig, struct sigaction * act)
{
  int result= sigaction(sig, act, NULL);
  if (result) {
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigaction returned an unexpected error code %d", errno);
    }
  }
  return result;
}


typedef void (*signal_handler)(int, int, struct sigcontext *);
/*
 * Note that unlike the Solaris case, SA_SIGINFO is not used in
 * the following and so a signal handler has the above prototype.
 * This has been done to try an limit the amount of code that has
 * to change in the sigvec->sigaction conversion that is necessary
 * to allow the SA_RESTART handler to be used.
 * 
 * Using SA_SIGINFO requires the ucontext_t structure to be used,
 * and as usual this is not clearly documented, especially the part
 * about setting PC -- ucontext_t only appears to have an EPC, not a PC,
 * and according to Kane&Heinrich page 6-21, EPC register is read only
 * on all but R4000.  Perhaps when you fill in the EPC field it
 * really fills in the PC.  This is something to test if/when
 * the upgrade to SA_SIGINFO is done - stephenb.
 */
static int set_signal_handler(int sig, signal_handler handler)
{
  struct sigaction sa;
  sa.sa_handler= handler;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags= SA_ONSTACK | SA_RESTART;
  return check_sigaction(sig, &sa);
}


static int restore_default_signal_handler(int sig)
{
  struct sigaction sa;
  sa.sa_handler= SIG_DFL;
  sigemptyset(&sa.sa_mask);
  sa.sa_flags= 0;
  return check_sigaction(sig, &sa);
}

/* signal_event() is called from record_event (in the events
   module). It can be called either synchronously in C or
   asynchronously in C or ML. It should set the 'interrupted' flag
   such that the event is taken synchronously by ML when we return to
   ML. */

extern void signal_event(void)
{
  /* set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
}

static void signal_ml_event (struct sigcontext *scp)
{
  if (global_state.in_ML) {
    /* set the stack limit register to -1 */
    SC_SLIMIT(scp) = (word)-1;
  }
}

/*  == The C signal handler ==
 *
 *  This function converts a C signal into an ML signal event.
 */

static void signal_ml_handler
  (int sig, int code, struct sigcontext *scp)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    record_event(EV_SIGNAL, (word) sig);
    signal_ml_event(scp);
  }
}

/* Install or remove the signal handler for a given signal */

extern int signal_set_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if ((handled & SIGNAL_HANDLED_IN_ML) == 0) {
    signal_handled[sig] = handled + SIGNAL_HANDLED_IN_ML;
    if ((handled & SIGNAL_HANDLED_IN_C) == 0) {
      return set_signal_handler(sig,signal_ml_handler);
    }
  }
  return 0;
}

extern int signal_clear_ml_handler(int sig)
{
  word handled = signal_handled[sig];
  if (handled & SIGNAL_HANDLED_IN_ML) {
    signal_handled[sig] = handled = handled - SIGNAL_HANDLED_IN_ML;
    if (handled == 0) {
      return restore_default_signal_handler(sig);
    }
  }
  return 0;
}

/* Up to two 'stack frames' of interest to the profiler or to a fatal
   signal backtrace may be kept in registers. We diagnose the current
   state from the registers and build fake frames if necessary: */

static struct stack_frame signal_fake_frames[2];

/* This tells us whether a given ML value is a valid closure */

static int is_closure(mlval clos)
{
  /* first check that it is an ML pointer into a heap area */
  if (ISORDPTR(clos)) {
    int type = SPACE_TYPE(clos);
    if (type != TYPE_RESERVED
	&& type != TYPE_FREE) {
      /* next check that it indicates a record, or a shared closure */
      mlval header = GETHEADER(clos);
      if (header == 0 || SECONDARY(header) == RECORD) {
	/* then check that the first field is a pointer */
	mlval code = FIELD(clos,0);
	if (PRIMARY(code) == POINTER) {
	  if (code == stub_c || code == stub_asm ||
	      SECONDARY(GETHEADER(code)) == BACKPTR)
	    return 1;
	}
      }
    }
  }
  return 0;
}

/* This checks whether the given PC indicates code within the code
 * item associated with the given closure */

static int pc_in_closure(word pc, mlval clos)
{
  mlval code = FIELD(clos,0);
  word code_start = (word)CCODESTART(code);
  /* is it after the start of this function ? */
  if (pc >= code_start) {
    mlval codeobj = FOLLOWBACK(code);
    word code_end = ((word)OBJECT(codeobj)) + (LENGTH(OBJECT(codeobj)[0]) << 2);
    /* is it before the end of this code object ? */
    if (pc < code_end) { 
      int codenum = CCODENUMBER(code);
      int codes = NFIELDS(FIELD(CCVANCILLARY(codeobj), ANC_NAMES));
      if (codes != codenum+1) {
	if (FIELD(clos,1) == 0) {
	  /* so we are in a shared closure; not the case for stub_c */
	  mlval nextcode = FIELD(clos,2);
	  if (nextcode > code) {
	    code_end = (word)CCODESTART(nextcode);
	    /* is it after the end of this code item ? */
	    if (pc >= code_end)
	      return 0;
	  } else {
	    error("signal handler found code vectors in wrong order\n");
	  }
	}
      }
      return 1;
    }
  }
  return 0;
}

/* this function examines the registers and the instructions around
 * the PC to establish the contents of the fake stack frames. It
 * returns an sp which can be passed to the profiler or a backtrace */

static struct sigcontext *debug_scp = NULL;

static struct stack_frame * signal_fixup_ML_state(struct sigcontext *scp)
{
  struct stack_frame *profile_top = NULL;
  word pc = SC_PC(scp);
  debug_scp = scp;
  if ((global_state.in_ML) /* &&
       (   TYPE(pc) == TYPE_GEN
	|| TYPE(pc) == TYPE_STATIC)) */) {
    mlval clos6 = SC_CLOSURE(scp);
    mlval clos5 = SC_REG(scp,5);
    word instr = *(word *)pc;
    
    signal_fake_frames->fp = signal_fake_frames+1;
    signal_fake_frames[1].closure = clos6;
    signal_fake_frames[0].closure = clos5;
    
    /* if clos5 == clos6 or the pc is not in clos5, we take the pc to be in
       clos6 */
    
    if (clos5 != clos6 && is_closure(clos5) && pc_in_closure(pc,clos5))
      profile_top = signal_fake_frames;
    else
      profile_top = signal_fake_frames+1;
    
    /* these are the only three instructions between sp being changed and
     * the closure list $6::stack($sp) being valid. These instructions
     * only occur there.  While there, the closure list $5::$6::stack($fp)
     * should be used instead. */
    
#define SW_CLOS_SP_4		0xafa60004
#define SW_LINK_SP_8		0xafbf0008
#define MV_CLOS_CCLOS		0x00a03025
    
    /* this is the only instruction between the closure being changed and
     * the $sp being right for that closure when leaving or tailing from a
     * function. While at this instruction, $6::stack($fp) should be
     * used. */
    
#define MV_SP_FP		0x03c0e825
    
    if (   (instr == SW_CLOS_SP_4)
	|| (instr == SW_LINK_SP_8)
	|| (instr == MV_CLOS_CCLOS)
	|| (instr == MV_SP_FP))
      signal_fake_frames[1].fp = (struct stack_frame *)SC_FP(scp);
    else
      signal_fake_frames[1].fp = (struct stack_frame *)SC_SP(scp);
    
    if (SC_SP(scp) != SC_FP(scp))
      ((struct stack_frame *)SC_SP(scp))->fp =
	(struct stack_frame *)SC_FP(scp);
  } else {
    profile_top = (struct stack_frame *)CURRENT_THREAD->ml_state.sp;
  }
  return profile_top;
}

/* Do something tolerable in the face of a fatal signal */

static mlval signal_thread_suicide_stub[] = {0, 0, (mlval)thread_suicide};

static void restore_default_fatal_signal_handlers(void)
{
  int i;
  for (i=0; i < NR_SIGNALS; i++) {
    if (signal_handled[i] & SIGNAL_HANDLED_FATALLY) {
      signal_handled[i] -= (SIGNAL_HANDLED_FATALLY + SIGNAL_HANDLED_IN_C);
      if (restore_default_signal_handler(i) != 0)
	error_without_alloc("Could not restore default fatal signal handlers");
    }
  }
}

static void die_in_fatal_signal_handler(char const *message)
{
  /* race condition here if the following call fails with a fatal signal */
  restore_default_fatal_signal_handlers();
  message_stderr("Fatal signal handler dying: %s", message);
}

static void handle_fatal_signal(int sig, int code, struct sigcontext *scp)
{
  if (CURRENT_THREAD == 0) {
    die_in_fatal_signal_handler("Corrupt threads system");

  } else if (CURRENT_THREAD->in_fatal_signal_handler) {
    die_in_fatal_signal_handler("Fatal signal raised by handler");

  } else if (in_GC) {
    die_in_fatal_signal_handler("fatal signal raised during GC.");

  } else {

    const char *signal_name;
    mlval handler;
    CURRENT_THREAD->in_fatal_signal_handler= 1;

    signal_name= name_that_signal (sig);
    handler= THREAD_ERROR_HANDLER(CURRENT_THREAD);

    DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,code,scp);
  
    if (handler == MLUNIT) {
      /* there is no handler; print a message and kill this thread. */
      if (runnable_threads == 2) {
	die_in_fatal_signal_handler("Last thread dying.");
      } else {
	struct stack_frame *sp = signal_fixup_ML_state(scp);
	message ("Thread #%d received an intolerable signal %s (%d : %d) %sin ML and died.",
		 CURRENT_THREAD->number, signal_name, sig, code,
		 global_state.in_ML? "" : "not ");
	backtrace (sp, CURRENT_THREAD, max_backtrace_depth);
	SET_RESULT(ML_THREAD(CURRENT_THREAD),THREAD_DIED);

	if (global_state.in_ML) {
	  SC_PC(scp) = (word)stub_c+CODE_OFFSET;
	  SC_ARG(scp) = MLUNIT;
	  SC_REG(scp,5) = (word)signal_thread_suicide_stub+POINTER;
	} else {
	  SC_PC(scp) = (word)thread_suicide;
	  SC_BASE(scp) = (word)thread_suicide;
	}
	/* to reduce the race window the following should be near the
	 * end of thread_suicide.  However, that entails putting it in
	 * the end of the asm routine change_thread, so for simplicity it
	 * is left here. */
	CURRENT_THREAD->in_fatal_signal_handler= 0;
      }
    } else {
      /* there is a handler; skip to it */
      SC_ARG(scp) = MLINT(sig);
      SC_REG(scp,5) = handler;
      if (global_state.in_ML) {
	SC_PC(scp) = FIELD(handler,0)+CODE_OFFSET;
      } else {
	SC_PC(scp) = (word)callml;
      }
      /* Note that CURRENT_THREAD->in_fatal_signal_handler is not reset here.
       * The onus is on the SML fatal signal handler to call the SML
       * version of thread_reset_fatal_status before returning. */
    }
  }
}



/* Install the above function for a given signal */

static int die_on_signal(int sig)
{
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C | SIGNAL_HANDLED_FATALLY;
  return set_signal_handler(sig,handle_fatal_signal);
}


/* == Arithmetic exception support == 
 *
 *  This function is the handler for the floating point signals.  If
 *  called while in ML it examines the instruction which caused the
 *  exception in order to determine which ML exception to raise.  The
 *  signal context is updated in order to raise the exception when the
 *  handler returns.  */

static void signal_arithmetic_exception_handler
  (int sig, int code, struct sigcontext *scp)
{
  word *pc = (word*)SC_PC(scp);
  word instruction;

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,code,scp);
  
  if (SC_BRANCH_DELAY(scp)) /* we're in a delay slot; pc is the branch */
    pc++;

  instruction = *pc;

  /* Switch on the instruction code: MIPS specific */
  switch(instruction & 0xfc000000) {	/* opcode field: top 6 bits */
  case 0x00000000:	/* SPECIAL */
    switch (instruction & 0x000007ff) {	/* shamt,funct fields: bottom 11 bits*/
    case 0x00000020:	/* ADD */
      break;
    case 0x00000022:	/* SUB */
      break;
    default:
      message("Arithmetic signal on non-trapping instruction 0x%08x",
	      instruction);
    }
    break;
  case 0x20000000:	/* ADDI */
    break;
  default:
    message("Arithmetic signal on non-trapping instruction 0x%08x",
	    instruction);
  }

  if (global_state.in_ML) {
    SC_PC(scp) = (word) ml_raise;
    SC_ARG(scp) = DEREF(perv_exn_ref_overflow);
  } else {
    message("Warning: FPE signal outside ML");
    SC_BASE(scp) = (word) exn_raise;
    SC_PC(scp) = (word) exn_raise;
    SC_ARG(scp) = perv_exn_ref_overflow;
  }
}

/* == Licensing support == 
 * 
 * SIGALRM is handled by refreshing the license. */

static void signal_timer_handler
  (int sig, int code, struct sigcontext *scp)
{
  refresh_license();

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,code,scp);
}

extern void signal_license_timer (int interval) 
{
  struct itimerval period;

  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");

  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */

  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
  period.it_value.tv_usec = 0;
  period.it_interval.tv_sec = interval;
  period.it_interval.tv_usec = 0;
  
  if(setitimer(ITIMER_REAL, &period, NULL) == -1)
    error("Unable to set up licensing timer.  "
	  "setitimer set errno to %d.", errno);
}

/* == Interrupt Support ==
 * 
 * SIGINT is handled and interpreted as an interrupt. */

static void signal_interrupt_handler (int sig, int sig_code,
				      struct sigcontext *scp)
{
  if (awaiting_x_event) {
    message ("Signal %s at top level", name_that_signal (sig));
  } else {
    if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
      signal_ml_handler(sig,sig_code,scp);
    else 
      signal_ml_event(scp);
  
    record_event(EV_INTERRUPT, (word) 0);
  }
}

extern int signal_set_interrupt_handler(void)
{
  signal_handled[SIGINT] |= SIGNAL_HANDLED_IN_C;	/* interrupt */
  return set_signal_handler(SIGINT,signal_interrupt_handler);
}

extern int signal_clear_interrupt_handler(void)
{
  signal_handled[SIGINT] &= !SIGNAL_HANDLED_IN_C;

  if (signal_handled[SIGINT] & SIGNAL_HANDLED_IN_ML)
    return signal_set_ml_handler(SIGINT);
  else
    return restore_default_signal_handler(SIGINT);
}

/* == Timer support ==
 *
 * We need a virtual-time alarm for several purposes: stack-based
 * profiling, thread pre-emption, and window updates.
 */

static struct itimerval interval_timer, residual_timer;
unsigned int current_interval = 0;

/* the number of milliseconds for the profiling and pre-emption intervals. */

unsigned int profiling_interval = 0;
unsigned int thread_preemption_interval = 0;
unsigned int window_update_interval = 0;
static unsigned int window_update_remaining = 0;
static unsigned int window_updates_on = 0;

static void signal_start_timer(void)
{
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, &residual_timer) == -1)
    message("Warning: Unable to set interval timer. \n"
	    " Profiling, preemption, and window updates may not occur");
}

static unsigned int signal_set_timer(unsigned int interval)
{
  unsigned int last_interval = current_interval;
  current_interval = interval;
  interval_timer.it_value.tv_sec = interval/1000;
  interval_timer.it_value.tv_usec = (interval%1000)*1000;
  interval_timer.it_interval.tv_sec = 0;
  interval_timer.it_interval.tv_usec = 0; /* one shot timer */

  signal_start_timer();
  interval = ((residual_timer.it_value.tv_sec * 1000) +
	      (residual_timer.it_value.tv_usec / 1000));
  interval = last_interval - interval;
  return interval;
}

static int signal_update_windows(unsigned int interval)
{
  if (window_update_remaining < interval) {
    window_update_remaining = window_update_interval;
    if (window_updates_on) {
      record_event(EV_WINDOWS, (word) 0);
      return 1;
    }
  } else
    window_update_remaining -= interval;
  return 0;
}
  
static void signal_do_timer(unsigned int interval)
{
  unsigned int residue = signal_set_timer(interval);
  (void) signal_update_windows(residue);
}

/* The signal handler function. If we're profiling we run the
 * profiler. If we're pre-empting we record the event. */

static void signal_interval_alarm (int sig, int sig_code,
				  struct sigcontext *scp)
{
  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,sig_code,scp);
  
  if (profile_on)
    time_profile_scan(signal_fixup_ML_state(scp));
  
  if (thread_preemption_on) {
    thread_preemption_pending = 1;
    record_event(EV_SWITCH, (word) 0);
    if ((signal_handled[sig] & SIGNAL_HANDLED_IN_ML) == 0)
      signal_ml_event(scp);
  }

  if (signal_update_windows (current_interval))
    signal_ml_event(scp);
    
  signal_start_timer();
}


/* == Profiling support == */

extern void signal_profiling_start(void)
{
  signal_do_timer(profiling_interval);
}

extern void signal_profiling_stop(void)
{
  unsigned int interval;
  if (thread_preemption_on)
    interval = thread_preemption_interval;
  else if (window_updates_on)
    interval = window_update_interval;
  else
    interval = 0;
  signal_do_timer(interval);
}

/* == Preemption support == */

extern void signal_preemption_start(void)
{
  if (!profile_on)
    signal_do_timer(thread_preemption_interval);
}

extern void signal_preemption_stop(void)
{
  if (!profile_on) {
    unsigned int interval;
    if (window_updates_on)
      interval = window_update_interval;
    else
      interval = 0;
    signal_do_timer(interval);
  }
}

extern void signal_preemption_change(void)
{
  signal_preemption_start();
}

/* Window update support */

extern void signal_window_updates_start(void)
{
  window_updates_on = 1;
  if (current_interval == 0)
    signal_do_timer(window_update_interval);
}

extern void signal_window_updates_stop(void)
{
  window_updates_on = 0;
}

static void establish_signal_table(void)
{
  int i;
  signal_handled = (word*) alloc(NR_SIGNALS * sizeof(word),
				 "Unable to allocate signal table");
  for (i=0; i < NR_SIGNALS; i++)
    signal_handled[i] = SIGNAL_NOT_HANDLED;
  signal_handled[SIGFPE]    = SIGNAL_HANDLED_IN_C;	/* float exns */
  signal_handled[SIGVTALRM] = SIGNAL_HANDLED_IN_C;	/* intervals */
}

extern void signals_init (void)
{
  struct sigstack ss;
  char *signal_stack;

  /* Initialise the signal stack */
  signal_stack =
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack.");

  ss.ss_sp = signal_stack + SIGNAL_STACK_SIZE;
  ss.ss_onstack = 0;

  if(sigstack(&ss, NULL) == -1)
    error("Unable to set up signal stack (sigstack set errno to %d).", errno);

  /* set up 'where is signal handled' table */
  establish_signal_table();

  /* establish arithmetic exception catcher */
  /* No longer required */
  if (set_signal_handler(SIGFPE,signal_arithmetic_exception_handler))
    error("Unable to set arithmetic exception handler.");

  /* establish virtual interval timer signal handler */
  if (set_signal_handler(SIGVTALRM, signal_interval_alarm))
    error("Unable to set up interval timer signal handler.");

  /* these signals are fatal */
  die_on_signal (SIGILL);
  die_on_signal (SIGBUS);
  die_on_signal (SIGSEGV);
}
@


1.37.10.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.6.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a13 3
 * Revision 1.37.6.1  1997/05/12  10:40:02  hope
 * branched from 1.37
 *
@


1.37.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a13 3
 * Revision 1.37.6.1  1997/05/12  10:40:02  hope
 * branched from 1.37
 *
@


1.37.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a13 3
 * Revision 1.37.6.1  1997/05/12  10:40:02  hope
 * branched from 1.37
 *
@


1.37.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a13 3
 * Revision 1.37.6.1.1.1  1997/07/28  18:28:44  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.37.5.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.4.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.4.1.1.1
log
@branched from 1.37.4.1
@
text
@a13 3
 * Revision 1.37.4.1  1996/12/17  17:53:04  hope
 * branched from 1.37
 *
@


1.37.3.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.2.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.1.1
log
@branched from 1.37
@
text
@a13 6
 * Revision 1.37  1996/10/25  12:49:08  stephenb
 * [Bug #1700]
 * Convert from sigvec -> sigaction so that it is possible to
 * add a SA_RESTART to the flags in set_signal_handler and therefore
 * avoid interrupted system calls.
 *
@


1.37.1.1.1.1
log
@branched from 1.37.1.1
@
text
@a13 3
 * Revision 1.37.1.1  1996/11/14  12:56:27  hope
 * branched from 1.37
 *
@


1.36
log
@Merge in license stuff
@
text
@d14 3
d167 1
a167 2
#include <signal.h>
#include <sys/signal.h>
d170 1
a170 3
#include <sys/wait.h>
#include <errno.h>
#include <sys/errno.h>
d256 1
a256 3
typedef void (*signal_handler)(int sig, int, struct sigcontext *, char *);

static int check_sigvec (int sig, struct sigvec *vec)
d258 2
a259 3
  int result = sigvec (sig,vec,NULL);

  if (result)
d265 1
a265 1
      error("sigvec returned an unexpected error code %d", errno);
d267 1
d271 17
d290 5
a294 6
  struct sigvec sv;
  sv.sv_handler = handler;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;
      
  return (check_sigvec (sig,&sv));
d297 1
d300 5
a304 5
  struct sigvec sv;
  sv.sv_handler = SIG_DFL;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  return check_sigvec(sig, &sv);
d333 1
a333 1
  (int sig, int code, struct sigcontext *scp, char *addr)
d521 1
a521 2
static void handle_fatal_signal(int sig, int code,
				struct sigcontext *scp, char *addr)
d544 1
a544 1
      signal_ml_handler(sig,code,scp,addr);
d608 1
a608 1
  (int sig, int code, struct sigcontext *scp, char *addr)
d614 1
a614 1
    signal_ml_handler(sig,code,scp,addr);
d657 1
a657 1
  (int sig, int code, struct sigcontext *scp, char *addr)
d662 1
a662 1
    signal_ml_handler(sig,code,scp,addr);
d691 1
a691 2
				      struct sigcontext *scp,
				      char *addr)
d697 1
a697 1
      signal_ml_handler(sig,sig_code,scp,addr);
d784 1
a784 2
				  struct sigcontext *scp,
				  char *addr)
d787 1
a787 1
    signal_ml_handler(sig,sig_code,scp,addr);
@


1.35
log
@Update best before to 01/01/97
@
text
@d14 9
a597 1
  mlval exception;
d607 5
a611 22
  if(!global_state.in_ML && in_ml_fpe) {
      exception = ml_fpe_exn;
      in_ml_fpe = 0;
  } else {
    if (!global_state.in_ML)
      message("Warning: FPE signal outside ML");

    /* Switch on the instruction code: MIPS specific */
    switch(instruction & 0xfc000000) {
    case 0x00000000:
      switch (instruction & 0x000007ff) {
      case 0x00000020:
	exception = perv_exn_ref_overflow;
	break;
      case 0x00000022:
	exception = perv_exn_ref_overflow;
	break;
      default:
	message("Arithmetic signal on non-trapping instruction 0x%08x",
		instruction);
	exception = perv_exn_ref_overflow;
      }
d613 1
a613 23
    case 0x20000000:
      exception = perv_exn_ref_overflow;
      break;
    case 0x44000000:
      switch (instruction & 0x0000003f) {
      case 0x00000000:
	exception = perv_exn_ref_overflow;
	break;
      case 0x00000001:
	exception = perv_exn_ref_overflow;
	break;
      case 0x00000002:
	exception = perv_exn_ref_overflow;
	break;
      case 0x00000003:
	exception = perv_exn_ref_overflow;
	break;
      default:
	message("Arithmetic signal on non-trapping instruction 0x%08x",
		instruction);
	exception = perv_exn_ref_overflow;
	break;
      }
a617 1
      exception = perv_exn_ref_overflow;
d619 6
d629 1
a629 1
    SC_ARG(scp) = DEREF(exception);
d631 1
d634 1
a634 1
    SC_ARG(scp) = exception;
d638 1
a638 1
/* == Licensing support ==
d640 1
a640 19
 * The whole licensing mechanism is due to be rewritten, but for now
 * it lives in here. See license.[ch] for more background.
 *
 * The MLWorks process forks a child process, which runs a real-time
 * alarm clock, going off every POLL_PERIOD seconds. The alarm handler
 * calls exit() if time() is after BEST_BEFORE. The child process sits
 * blocked (on a pipe read), and exits normally when the main MLWorks
 * process does.
 *
 * The main MLWorks process watches the child. If the child dies or is
 * stopped, or otherwise becomes invisible, the main process calls
 * exit.
 *
 */

#define POLL_PERIOD	600		/* seconds between licence checks */
#define BEST_BEFORE	852076800	/* 1996-07-01 00:00 */

/* The process ID of the child */
d642 1
a642 5
int signal_license_child_pid;

/* The handler for SIGCHLD, installed by the main MLWorks process */

static void signal_child_handler
d645 1
a645 1
  int status, available;
a646 6
  DIAGNOSTIC(4, "sigchild(sig = %d, code = %d, ...", sig, code);
  DIAGNOSTIC(4, "license pid = %d)", signal_license_child_pid, 0);

  /* Find out what happened to the child.  If waitpid() is interrupted by a */
  /* signal then try again. */
  
a648 35
  
  if (signal_license_child_pid != 0) {
    do
      available = waitpid(signal_license_child_pid,
			  &status, WNOHANG | WUNTRACED);
    while(available == -1 && errno == EINTR);
  } else {
    return;
  }

  if (available == 0) {
    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
    return;
  } else {
    if(available == -1)
      error("Unable to determine status of licensing process.  "
	  "waitpid set errno to %d.", errno);

    /* If available is non zero then something happened to the child.  If it */
    /* is zero then the child status changed, but changed back (for example, */
    /* both child and parent were suspended from the shell and restarted. */
  
    DIAGNOSTIC(4, "available %d status 0x%02X", available, status);

    if(WIFSTOPPED(status))
      error("Licensing process was stopped with signal %d", WSTOPSIG(status));
    else if(WIFSIGNALED(status))
      error("Licensing process was terminated with signal %d", WTERMSIG(status));
    else
      error("Your license has expired.  Contact MLWorks customer support:\n"
	    "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
	    "   telephone:        +44 1223 872522");
  }
d651 1
a651 4
/* The handler for SIGALRM, installed by the child (licensing) process */

static void signal_license_alarm_handler
    (int sig, int code, struct sigcontext *scp, word *addr)
d653 1
a653 1
  time_t now;
d655 3
a657 11
  now = time(NULL);
  DIAGNOSTIC(4, "child: checking license at time %ld", now, 0);

  if(now == -1)
    message("child: WARNING: time() returned -1");
  else if (now >= BEST_BEFORE)
  {
    DIAGNOSTIC(1, "child: license expired at time %ld", now, 0);
    exit(1);
  }
}
d659 1
a659 18
/* A function called by the main MLWorks process to watch the child
 * process */

extern void signal_license_watch_child (void)
{
  if(set_signal_handler(SIGCHLD,signal_child_handler))
    error("Unable to set signal handler for SIGCHLD.");
}

/* The licensing child process itself */

extern void signal_license_child (int *pipefd)
{
  struct sigvec sv;

  char dummy;
  struct itimerval period;
  int i;
d661 2
a662 21
  /* Ignore all signals (if possible) so that signals sent to the */
  /* process group won't affect the licensing process. */
  
  for(i=1; i<NSIG; ++i)
    if (i != SIGALRM)
      /* SIGKILL and SIGSTOP are not blocked by this */
      sigblock(sigmask(i));
  
  /* Check the license once before we start. */
  signal_license_alarm_handler (0,0,NULL,NULL);
  
  /* Set up a real time alarm with a handler to poll the license. */
  
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  sv.sv_handler = signal_license_alarm_handler;
  if(sigvec(SIGALRM, &sv, NULL) == -1)
    error("Licensing process unable to set signal handler for SIGALRM.  "
	  "sigvec set errno to %d.", errno);
  
  period.it_value.tv_sec = POLL_PERIOD;
d664 1
a664 1
  period.it_interval.tv_sec = POLL_PERIOD;
a669 11
  
  /* Read from the child's end of the pipe.  This has the effect of */
  /* blocking the child until the other end is closed by the parent */
  /* exiting. */
  
  close(pipefd[1]);
  if(read(pipefd[0], &dummy, 1))
    error("Licensing process managed to read from pipe.");
  
  DIAGNOSTIC(2, "child: parent died -- exiting", 0, 0);
  exit(0);
a860 1
  signal_handled[SIGCHLD]   = SIGNAL_HANDLED_IN_C;	/* licensing */
d886 1
a886 1
  /* establish interval timer signal handler */
a893 14

  /* MIPS magic to get the fp unit to raise an exception on particular
   * conditions; i.e. Invalid, DivZero, and Overflow. Do _not_ turn on
   * the Underflow or Inexact exceptions, as these are raised at odd
   * times */

/* No longer required */
/*
#define FPC_CSR_INVALID 0x00000800
#define FPC_CSR_DIVZERO 0x00000400
#define FPC_CSR_OVERFLW 0x00000200

  set_fpc_csr(FPC_CSR_INVALID | FPC_CSR_DIVZERO | FPC_CSR_OVERFLW);
*/
@


1.35.3.1
log
@branched from 1.35
@
text
@a13 3
 * Revision 1.35  1996/06/07  09:31:44  jont
 * Update best before to 01/01/97
 *
@


1.35.2.1
log
@branched from 1.35
@
text
@a13 3
 * Revision 1.35  1996/06/07  09:31:44  jont
 * Update best before to 01/01/97
 *
@


1.35.2.2
log
@Move to Harlequin license server.
@
text
@a13 3
 * Revision 1.35.2.1  1996/10/07  16:11:47  hope
 * branched from 1.35
 *
d592 1
d602 22
a623 5
  /* Switch on the instruction code: MIPS specific */
  switch(instruction & 0xfc000000) {	/* opcode field: top 6 bits */
  case 0x00000000:	/* SPECIAL */
    switch (instruction & 0x000007ff) {	/* shamt,funct fields: bottom 11 bits*/
    case 0x00000020:	/* ADD */
d625 23
a647 1
    case 0x00000022:	/* SUB */
d652 1
a653 6
    break;
  case 0x20000000:	/* ADDI */
    break;
  default:
    message("Arithmetic signal on non-trapping instruction 0x%08x",
	    instruction);
d658 1
a658 1
    SC_ARG(scp) = DEREF(perv_exn_ref_overflow);
a659 1
    message("Warning: FPE signal outside ML");
d662 1
a662 1
    SC_ARG(scp) = perv_exn_ref_overflow;
d666 1
a666 1
/* == Licensing support == 
d668 23
a690 1
 * SIGALRM is handled by refreshing the license. */
d692 1
a692 1
static void signal_timer_handler
d695 1
a695 1
  refresh_license();
d697 6
d705 54
d761 4
a764 1
extern void signal_license_timer (int interval) 
d766 5
a770 1
  struct itimerval period;
d772 3
a774 3
  /* establish real interval timer signal handler */
  if(set_signal_handler(SIGALRM, signal_timer_handler))
    error("Unable to set up real interval timer signal handler.");
d776 3
a778 1
  signal_handled[SIGALRM]   |= SIGNAL_HANDLED_IN_C;	/* licensing */
d780 21
a800 2
  /* Establish timer for refreshing the license */
  period.it_value.tv_sec = interval;
d802 1
a802 1
  period.it_interval.tv_sec = interval;
d808 11
d1010 1
d1036 1
a1036 1
  /* establish virtual interval timer signal handler */
d1044 14
@


1.35.1.1
log
@branched from 1.35
@
text
@a13 3
 * Revision 1.35  1996/06/07  09:31:44  jont
 * Update best before to 01/01/97
 *
@


1.34
log
@Remove the #define LANGUAGE_C as this is now defined for all files
@
text
@d14 3
d681 1
a681 1
#define BEST_BEFORE	836179200	/* 1996-07-01 00:00 */
@


1.33
log
@Reinstating signal handler for integer
@
text
@d14 3
a161 2

#define LANGUAGE_C
@


1.32
log
@Different exceptions for integer operations
No trapping for real operations
@
text
@d14 4
a1025 1
/*
a1027 1
*/
@


1.31
log
@Removing do_exportFn, as this is no longer architecture dependent
@
text
@d14 3
d603 1
a603 1
	exception = perv_exn_ref_sum;
d606 1
a606 1
	exception = perv_exn_ref_diff;
d611 1
a611 1
	exception = perv_exn_ref_sum;
d615 1
a615 4
      if (instruction & 0x00008000) /* the immediate is -ve: a subtraction */
	exception = perv_exn_ref_diff;
      else			/* the immediate is +ve: an addition */
	exception = perv_exn_ref_sum;
d620 1
a620 1
	exception = perv_exn_ref_sum;
d623 1
a623 1
	exception = perv_exn_ref_diff;
d626 1
a626 1
	exception = perv_exn_ref_prod;
d629 1
a629 1
	exception = perv_exn_ref_div;
d634 1
a634 1
	exception = perv_exn_ref_sum;
d641 1
a641 1
      exception = perv_exn_ref_sum;
d1021 2
d1025 1
d1041 2
d1048 1
@


1.30
log
@Modify exportFn mechanism not to use signals at all
Use busy waiting in parent instead, thus avoiding
potential race contions
@
text
@d14 5
a756 68
}

/* exportFn support */
mlval do_exportFn(mlval argument)
{
  pid_t child_pid = fork();

  if(child_pid == -1) {
    switch(errno) {
      case EAGAIN:
      exn_raise_string(perv_exn_ref_save,
		       "Too many processes running to fork exportFn process");
      case ENOMEM:
      exn_raise_string(perv_exn_ref_save,
		       "Insufficient memory to fork exportFn process");
      default: 
      exn_raise_format(perv_exn_ref_save,
		       "fork() returned an unexpected error code %d", errno);
    }
  } else if (child_pid == 0) {
    /* The child process */
    mlval global;
    mlval filename = FIELD(argument, 0);
    image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
    declare_root(&filename);
    
    global = global_pack();
    declare_root(&global);
    
    gc_clean_image();
    
    argument = allocate_record(2);
    FIELD(argument, 0) = filename;
    FIELD(argument, 1) = global;
    retract_root(&filename);
    retract_root(&global);
    
    if(image_save(argument) == ERROR)
      exit(errno ? errno : -1);
    
    exit(0);
  } else {
    /* The parent process */
    int status;
    DIAGNOSTIC(4, "Setting export child pid is %d", child_pid, 0);
    /* Now wait for the child to complete, and get its return status */
    do {
      waitpid(child_pid, &status, 0);
    } while(!(WIFSIGNALED(status) || WIFEXITED(status)));
    if (WIFSIGNALED(status)) {
      /* Child terminated by signal */
      exn_raise_format(perv_exn_ref_save, "Export process terminated by signal %d",
		       WTERMSIG(status));
    }
    switch(WEXITSTATUS(status)) {
    case 0:
      break;
    case EIMPL:
      exn_raise_string(perv_exn_ref_save, "Function save not implemented");
    case EIMAGEWRITE:
      exn_raise_string(perv_exn_ref_save, "Error writing opened image file");
    case EIMAGEOPEN:
      exn_raise_string(perv_exn_ref_save, "Unable to open image file");
    default:
      exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
    }
    return MLUNIT; /* Should later change to return to MLWorks */
  }
@


1.29
log
@Make interval window updates happen even if we stay in ML.
@
text
@d14 3
a673 8
/* The process ID of the exportFn child */

int signal_export_child_pid;

static int export_exists = 0; /* Something to ensure we don't miss signals */
static int export_child_status = 0;
static int child_exited = 1;

d682 1
a682 1
  DIAGNOSTIC(4, "license and export pids = %d, %d)", signal_license_child_pid, signal_export_child_pid);
d690 1
a690 7
  do
    available = waitpid(signal_license_child_pid,
			&status, WNOHANG | WUNTRACED);
  while(available == -1 && errno == EINTR);

  if (available == 0) {
    /* No status available for licensing process, try export */
d692 1
a692 1
      available = waitpid(signal_export_child_pid,
d695 3
d699 1
a699 4
    if(available == -1)
      error("Unable to determine status of export process.  "
	    "waitpid set errno to %d.", errno);

d703 1
a703 23

    if(available) {
      DIAGNOSTIC(1, "available %d status 0x%02X", available, status);

      if(WIFSTOPPED(status))
	error("Export process stopped with signal %d", WSTOPSIG(status));
      else if(WIFSIGNALED(status))
	error("Export process terminated with signal %d", WTERMSIG(status));
      else if(WIFEXITED(status)) {
	/* This is the case where the child has exited roughly as expected */
	DIAGNOSTIC(1, "Export process terminated with status %d",
		   WEXITSTATUS(status), 0);
	export_child_status = status;
	child_exited = 1;
	return;
      } else
	error("Export process terminated for unknown reason");

    } else {
      /* else status has changed back again */
      error("exportFn:Child status has unexpectedly reverted");
    }

a725 15
static void clear_export_child_status(void)
{
  child_exited = 0;
}

static int read_export_child_status(void)
{
  return WEXITSTATUS(export_child_status);
}

static int check_export_child_status(void)
{
  return child_exited;
}

a753 12
static void signal_export_watch_child(void)
{
  DIAGNOSTIC(4, "Watching export child", 0, 0);
  export_exists = 1;
}

static void signal_export_unwatch_child(void)
{
  DIAGNOSTIC(4, "Unwatching export child", 0, 0);
  export_exists = 0;
}

d757 1
a757 5
  pid_t child_pid;

  clear_export_child_status();
  signal_export_watch_child();
  child_pid = fork();
d795 2
a796 2
    DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
    signal_export_child_pid = child_pid;
d798 9
a806 4
    /* Busy wait, is there a better way to do this? */
    while (check_export_child_status() == 0);
    signal_export_unwatch_child();
    switch (read_export_child_status()) {
@


1.28
log
@Disable interrupt handling except when a handler is defined.
@
text
@d14 3
d334 1
a334 1
static inline int is_closure(mlval clos)
d360 1
a360 1
static inline int pc_in_closure(word pc, mlval clos)
d471 1
a471 1
static inline void die_in_fatal_signal_handler(char const *message)
d985 1
a985 1
static inline void signal_start_timer(void)
d992 1
a992 1
static inline unsigned int signal_set_timer(unsigned int interval)
d1008 1
a1008 1
static inline void signal_update_windows(unsigned int interval)
d1011 2
a1012 1
    if (window_updates_on)
d1014 2
a1015 1
    window_update_remaining = window_update_interval;
d1018 1
d1021 1
a1021 1
static inline void signal_do_timer(unsigned int interval)
d1024 1
a1024 1
  signal_update_windows(residue);
d1047 3
a1049 1
  signal_update_windows (current_interval);
d1112 1
a1112 1
static inline void establish_signal_table(void)
@


1.27
log
@Getting rid of sm_interface().
@
text
@d14 3
d223 38
a296 16
static int check_sigvec (int sig, struct sigvec *vec)
{
  int result = sigvec (sig,vec,NULL);

  if (result)
    switch(errno) {
    case EINVAL:
      errno = ESIGNALNO;
      break;
    default:
      error("sigvec returned an unexpected error code %d", errno);
    }
  return result;
}


d305 1
a305 7
      struct sigvec vec;
      
      vec.sv_handler = signal_ml_handler;
      vec.sv_mask = 0;
      vec.sv_flags = SV_ONSTACK;
      
      return (check_sigvec (sig,&vec));
d317 1
a317 7
      struct sigvec vec;

      vec.sv_handler = SIG_DFL;
      vec.sv_mask = 0;
      vec.sv_flags = SV_ONSTACK;
      
      return (check_sigvec (sig,&vec));
a455 14



static int restore_default_signal_handler(int sig)
{
  struct sigvec sv;
  sv.sv_handler = SIG_DFL;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  return sigvec(sig, &sv, NULL);
}



a467 2


a474 2


a548 5
  struct sigvec vec;

  vec.sv_handler = handle_fatal_signal;
  vec.sv_mask = 0;
  vec.sv_flags = SV_ONSTACK;
d550 1
a550 2
  
  return (sigvec(sig,&vec,NULL));
d795 2
a796 8
  struct sigvec sv;

  sv.sv_handler = signal_child_handler;
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  if(sigvec(SIGCHLD, &sv, NULL) == -1)
    error("Unable to set signal handler for SIGCHLD.  "
	  "sigvec set errno to %d.", errno);
a887 3
  sv.sv_mask = 0;
  sv.sv_flags = 0;
  
a890 1
  sv.sv_handler = SIG_IGN;
d901 2
d949 16
a1110 1
  signal_handled[SIGINT]    = SIGNAL_HANDLED_IN_C;	/* interrupt */
a1117 1
  struct sigvec sv;
a1120 31
  /* set up 'where is signal handled' table */
  establish_signal_table();

  /* establish interrupt handler */
  sv.sv_handler = signal_interrupt_handler;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;
  if(sigvec(SIGINT, &sv, NULL) == -1)
    error("Unable to set interrupt signal handler.  "
          "sigvec set errno to %d.", errno);

  /* establish arithmetic exception catcher */

  sv.sv_handler = signal_arithmetic_exception_handler;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;

  if(sigvec(SIGFPE, &sv, NULL) == -1)
    error("Unable to set arithmetic exception handler.  "
          "sigvec set errno to %d.", errno);

  /* establish interval timer signal handler */

  sv.sv_handler = signal_interval_alarm;
  sv.sv_mask = 0;
  sv.sv_flags = SV_ONSTACK;

  if(sigvec(SIGVTALRM, &sv, NULL) == -1)
    error("Unable to set up interval timer signal handler.  "
	  "Sigvec set errno to %d.", errno);

a1121 1

d1131 11
a1142 1

@


1.26
log
@Fix bug #995 - death of last thread due to a fatal signal should
result in a non-zero termination code.
@
text
@d14 4
d123 1
a830 2
  mlval global, filename;

d838 1
a838 2
    switch(errno)
      {
a841 1

d844 27
a870 9
		       "Insufficient memory to fork licensing process");

      default:
      {
	char error_message[200];
	sprintf(error_message, "fork() returned an unexpected error code %d", errno);
	exn_raise_string(perv_exn_ref_save, error_message);
      }
    }
d872 18
a889 73
    if (child_pid == 0) {
      /* The child process */
      filename = FIELD(argument, 0);
      image_continuation = FIELD(argument, 1); /* This is a global, and hence a root */
      declare_root(&filename);

      global = global_pack();
      declare_root(&global);

      {
	mlval old_message_level = MLSUB(gc_message_level,0);
	clear_handlers(); /* Don't follow the signal handlers */
	clear_thread_roots(); /* Don't follow roots in ml_state etc */
	MLUPDATE(modules, 0, MLNIL); /* Clear the module table */
	/* now do big garbage collections, without scanning the ML stack */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	(void) sm_interface(SM_PROMOTE_ALL, 0, MLUNIT); /* merge all gens */
	MLUPDATE(gc_message_level,0,MLINT(-1));		/* turn on messages */
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* collect all gens */
	MLUPDATE(gc_message_level,0,old_message_level);
      }

      argument = allocate_record(2);
      FIELD(argument, 0) = filename;
      FIELD(argument, 1) = global;
      retract_root(&filename);
      retract_root(&global);

      if(sm_interface(SM_IMAGE_SAVE, 1, argument) == ERROR)
	switch(errno)
	  {
	  case EIMPL:
	    exit(EIMPL);
	    error("Function save not implemented");

	  case EIMAGEWRITE:
	    exit(EIMAGEWRITE);
	    error("Error writing opened image file");

	  case EIMAGEOPEN:
	    exit(EIMAGEOPEN);
	    error("Unable to open image file");

	  default:
	    exit(errno ? errno : -1);
	    error("Unexpected error from exportFn");
	  }

      exit(0);
    } else {
      /* The parent process */
      DIAGNOSTIC(4, "Setting signal_export_child_pid to %d", child_pid, 0);
      signal_export_child_pid = child_pid;
      /* Now wait for the child to complete, and get its return status */
      /* Busy wait, is there a better way to do this? */
      while (check_export_child_status() == 0);
      signal_export_unwatch_child();
      switch (read_export_child_status()) {
      case 0:
	break;
      case EIMPL:
	exn_raise_string(perv_exn_ref_save, "Function save not implemented");

      case EIMAGEWRITE:
	exn_raise_string(perv_exn_ref_save, "Error writing opened image file");

      case EIMAGEOPEN:
	exn_raise_string(perv_exn_ref_save, "Unable to open image file");

      default:
	exn_raise_string(perv_exn_ref_save, "Unexpected error from exportFn");
      }
      return MLUNIT; /* Should later change to return to MLWorks */
d891 1
d895 1
a895 1
/* The child process itself */
@


1.25
log
@Fix handle_fatal_signal so that it deals with a fatal signal
being raised whilst handling a fatal signal.
@
text
@d14 4
d160 1
d439 14
a452 1
static void install_default_fatal_signal_handlers(void)
d454 17
a470 7
  struct sigvec new_action;
  new_action.sv_handler= SIG_DFL;
  new_action.sv_mask= 0;
  if ((sigvec(SIGILL,  &new_action, (struct sigvec *)0) != 0)
  ||  (sigvec(SIGBUS,  &new_action, (struct sigvec *)0) != 0)
  ||  (sigvec(SIGSEGV, &new_action, (struct sigvec *)0) != 0))
    error_without_alloc("Could not install default fatal signal handlers");
d479 2
a480 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Corrupt threads.  Dying ...\n");
d482 5
a486 3
    /* race condition here if the following call fails with a fatal signal */
    install_default_fatal_signal_handlers();
    error_without_alloc("Fatal signal raised in fatal signal handler!  Dying ...\n");
d488 1
a497 6
    if (in_GC) {
      install_default_fatal_signal_handlers();
      error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	    signal_name, sig, code);
    }

d503 2
a504 14
      struct stack_frame *sp = signal_fixup_ML_state(scp);
      void (*old_messager_function)(const char * message) = NULL;
      old_messager_function = messager_function;
      messager_function = NULL;
      message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	       signal_name, sig, code, global_state.in_ML ? "" : "not ");
      backtrace (sp, CURRENT_THREAD, max_backtrace_depth);
      messager_function = old_messager_function;
      SET_RESULT(ML_THREAD(CURRENT_THREAD),THREAD_DIED);

      if (global_state.in_ML) {
	SC_PC(scp) = (word)stub_c+CODE_OFFSET;
	SC_ARG(scp) = MLUNIT;
	SC_REG(scp,5) = (word)signal_thread_suicide_stub+POINTER;
d506 20
a525 2
	SC_PC(scp) = (word)thread_suicide;
	SC_BASE(scp) = (word)thread_suicide;
a526 5
      /* to reduce the race window the following should be near the
       * end of thread_suicide.  However, that entails putting it in
       * the end of the asm routine change_thread, so for simplicity it
       * is left here. */
      CURRENT_THREAD->in_fatal_signal_handler= 0;
d543 2
d554 1
a554 1
  signal_handled[sig] |= SIGNAL_HANDLED_IN_C;
d558 1
@


1.24
log
@Add timer-triggered window updates.
@
text
@d14 3
d433 14
d450 23
a472 2
  const char *signal_name = name_that_signal (sig);
  mlval handler = THREAD_ERROR_HANDLER(CURRENT_THREAD);
d474 2
a475 9
  DIAGNOSTIC(2, "signal_handler(sig = %d)", sig, 0);

  if (in_GC) {
    error("Received intolerable signal %s (%d : %d) during GC. Dying.",
	  signal_name, sig, code);
  }

  if (signal_handled[sig] & SIGNAL_HANDLED_IN_ML)
    signal_ml_handler(sig,code,scp,addr);
d477 25
a501 16
  if (handler == MLUNIT) {
    /* there is no handler; print a message and kill this thread. */
    struct stack_frame *sp = signal_fixup_ML_state(scp);
    void (*old_messager_function)(const char * message) = NULL;
    old_messager_function = messager_function;
    messager_function = NULL;
    message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	     signal_name, sig, code, global_state.in_ML ? "" : "not ");
    backtrace (sp, CURRENT_THREAD, max_backtrace_depth);
    messager_function = old_messager_function;
    SET_RESULT(ML_THREAD(CURRENT_THREAD),THREAD_DIED);

    if (global_state.in_ML) {
      SC_PC(scp) = (word)stub_c+CODE_OFFSET;
      SC_ARG(scp) = MLUNIT;
      SC_REG(scp,5) = (word)signal_thread_suicide_stub+POINTER;
d503 11
a513 11
      SC_PC(scp) = (word)thread_suicide;
      SC_BASE(scp) = (word)thread_suicide;
    }
  } else {
    /* there is a handler; skip to it */
    SC_ARG(scp) = MLINT(sig);
    SC_REG(scp,5) = handler;
    if (global_state.in_ML) {
      SC_PC(scp) = FIELD(handler,0)+CODE_OFFSET;
    } else {
      SC_PC(scp) = (word)callml;
@


1.23
log
@Extensions to event handling for non-signal events.
@
text
@d14 3
d937 2
a938 2
 * We need a virtual-time alarm for two purposes: for stack-based profiling
 * and for thread pre-emption.
d941 2
a942 1
static struct itimerval interval_timer;
d948 3
d954 3
a956 3
  if(setitimer(ITIMER_VIRTUAL, &interval_timer, NULL) == -1)
    message("Warning: Unable to set interval timer (setitimer set errno "
	    "to %d).  Stack profiling and preemption will not occur.", errno);
d959 1
a959 1
static inline void signal_set_timer(unsigned int interval)
d961 2
d969 20
d998 3
d1003 1
a1003 1

d1011 1
d1015 1
d1020 1
a1020 1
  signal_set_timer(profiling_interval);
d1025 1
a1025 1
  signal_set_timer(0);
d1027 6
a1032 1
    signal_set_timer(thread_preemption_interval);
d1040 1
a1040 1
    signal_set_timer(thread_preemption_interval);
d1045 8
a1052 2
  if (!profile_on)
    signal_set_timer(0);
d1058 14
@


1.22
log
@Update best-before date to 1996-07-01.
@
text
@d14 3
d145 8
d204 5
a208 3
/* reserving and releasing signals */

static int reserved[NR_SIGNALS];
d210 1
a210 1
extern int signal_reserve(int sig)
d212 2
a213 33
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 1;
  return 0;
}
    
extern int signal_release(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  if (!reserved[sig]) {
    errno = ESIGNALRES;
    return (-1);
  }
  reserved[sig] = 0;
  return 0;
}  

extern int signal_reserved(int sig)
{
  if (sig <= 0 || sig >= NR_SIGNALS) {
    errno = ESIGNALNO;
    return (-1);
  }
  return (reserved[sig]);
d216 1
a216 1
static void record_event (struct sigcontext *scp)
d220 1
a220 1
    SC_SLIMIT(scp) = (unsigned int) -1;
a221 3

  /* always set the thread state interrupt slot to -1 */
  CURRENT_THREAD->implicit.interrupt = (unsigned)-1;
a231 2
  struct event *event;

d235 2
a236 14
    event = alloc(sizeof(struct event), "Couldn't allocate event");
    event->type = SIGNAL;
    event->the.signal = sig;

    event->forward = &event_queue;
    event->back = event_queue.back;
    event->forward->back = event;
    event->back->forward = event;
    ++event_queue.the.sentinel_count;

    DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	       sig, event_queue.the.sentinel_count);

    record_event(scp);
d260 14
a273 7
  struct sigvec vec;

  vec.sv_handler = signal_ml_handler;
  vec.sv_mask = 0;
  vec.sv_flags = SV_ONSTACK;

  return (check_sigvec (sig,&vec));
d278 14
a291 7
  struct sigvec vec;

  vec.sv_handler = SIG_DFL;
  vec.sv_mask = 0;
  vec.sv_flags = SV_ONSTACK;

  return (check_sigvec (sig,&vec));
d302 1
a302 1
static int inline is_closure(mlval clos)
d440 3
d484 1
a488 14
/* == Stack overflow support ==
 * 
 * When we exceed the user-specified number of stack blocks, we want
 * to signal into the ML debugger. This is the portable interface:
 * self_signal (signal_stack_overflow) is called. */

int signal_stack_overflow = SIGUSR1;
int signal_interrupt = SIGINT;

extern void self_signal (int sig)
{
  kill (getpid(),(int) sig);
}

d498 1
a498 1
  (int sig, int code, struct sigcontext *scp)
d504 3
d614 1
a614 1
  (int sig, int code, struct sigcontext *scp, word *addr)
d624 3
d912 20
d974 3
a976 1
    record_event(scp);
d1015 13
a1028 1

d1034 11
a1080 8

  /* these signals are reserved to the runtime */

  signal_reserve (SIGILL);	/* fatal */
  signal_reserve (SIGBUS);	/* fatal */
  signal_reserve (SIGSEGV);	/* fatal */
  signal_reserve (SIGFPE);	/* integer and real exceptions */
  signal_reserve (SIGVTALRM);	/* profiling and preemption */
@


1.21
log
@Extend closure check in the profiling code.
@
text
@d14 3
d625 1
a625 1
#define BEST_BEFORE	820454400	/* 1996-01-01 00:00 */
@


1.20
log
@Improve the full GC we do during function export.
@
text
@d14 3
d320 1
a320 1
static inline int is_closure(mlval clos)
d322 17
a338 9
  /* first check that the closure is an ML pointer into a heap area */
  if (ISORDPTR(clos)
      && SPACE_TYPE(clos) != TYPE_RESERVED
      && SPACE_TYPE(clos) != TYPE_FREE) {
    mlval code = FIELD(clos,0);
    /* then check that it's a closure */
    if (PRIMARY(code) == POINTER
	&& SECONDARY(GETHEADER(code)) == BACKPTR)
      return 1;
@


1.19
log
@Add do_exportFn to do the system specific part of exportFn
@
text
@d14 3
d807 5
a811 2
	MLUPDATE(gc_message_level,0,MLINT(-1));
	(void) sm_interface(SM_COLLECT_ALL, 0, MLUNIT); /* Don't scan the stack during gc */
@


1.18
log
@Change profiler interface.
@
text
@d14 3
d93 4
d614 8
d624 1
a624 1
static void signal_license_child_handler
d630 1
a630 1
  DIAGNOSTIC(4, "         child = %d)", signal_license_child_pid, 0);
d639 41
a679 3
  
  if(available == -1)
    error("Unable to determine status of licensing process.  "
d682 3
a684 3
  /* If available is non zero then something happened to the child.  If it */
  /* is zero then the child status changed, but changed back (for example, */
  /* both child and parent were suspended from the shell and restarted. */
a685 2
  if(available)
  {
d699 15
d740 1
a740 1
  sv.sv_handler = signal_license_child_handler;
d746 116
@


1.17
log
@Update best-before date.
@
text
@d14 3
d773 1
a773 1
    profile_scan(signal_fixup_ML_state(scp));
@


1.16
log
@Fix minor thinko in fatal_signal.
@
text
@d14 3
d598 1
a598 1
#define BEST_BEFORE	804553200	/* 1995-07-01 00:00 */
@


1.15
log
@Improve fatal signal support.
@
text
@d14 3
d446 1
a446 1
      SC_REG(scp,5) = (word)signal_thread_suicide_stub+RECORD;
@


1.14
log
@Fatal signal code not fixing up the stack correctly.
@
text
@d14 3
d411 1
a411 10
/* save some thread-independent ML state so we can kill this thread */

static void signal_save_ML_state(struct sigcontext *scp)
{
  /* we have to save some ML state as if entering C */
  global_state.in_ML = 0;
  CURRENT_THREAD->implicit.gc_base = SC_REG(scp,2);
  CURRENT_THREAD->implicit.handler = SC_REG(scp,8);
  CURRENT_THREAD->ml_state.sp = (word)SC_SP(scp);
}
d413 1
a413 1
/* Do something tolerable in the face of a fatal signal */
d415 2
a416 2
static void handle_die_gracefully(int sig, int code,
				  struct sigcontext *scp, char *addr)
d419 1
a419 2
  void (*old_messager_function)(const char * message) = NULL;
  struct stack_frame *sp = signal_fixup_ML_state(scp);
d427 31
a457 14
  old_messager_function = messager_function;
  messager_function = NULL;
  message ("Intolerable signal %s (%d : %d) received %sin ML. Backtrace:",
	   signal_name, sig, code, global_state.in_ML ? "" : "not ");

  /* do a back-trace */
  if (global_state.in_ML)
    signal_save_ML_state(scp);
  backtrace (sp, CURRENT_THREAD, max_backtrace_depth);

  messager_function = old_messager_function;
  SET_RESULT(ML_THREAD(CURRENT_THREAD),THREAD_DIED);
  SC_PC(scp) = (word)thread_suicide;
  SC_BASE(scp) = (word)thread_suicide;
d466 1
a466 1
  vec.sv_handler = handle_die_gracefully;
@


1.13
log
@Remove diagnostic printing.
@
text
@d14 3
d426 1
d442 1
a442 2
  backtrace (signal_fixup_ML_state(scp),
	     CURRENT_THREAD, max_backtrace_depth);
@


1.12
log
@Get signal handling &c to work.
@
text
@d14 3
d323 2
a324 4
	if (FIELD(clos,1) != 0) {
	  printf("non-zero closure intercalated value.\n");
	  printf("closure %x codes %d codenum %d\n", clos, codes, codenum);
	} else {
d332 1
a332 1
	    printf("code vectors in funny order!\n");
d346 2
d352 4
a355 5
  if (in_GC)
    printf("in GC\n");
  else if ((global_state.in_ML &&
	    (   TYPE(pc) == TYPE_GEN
	     || TYPE(pc) == TYPE_STATIC))) {
d372 1
a372 1
    /* these are the only four instructions between sp being changed and
a376 1
#define SW_ARG_SP_12		0xafa4000c
d388 1
a388 2
    if (   (instr == SW_ARG_SP_12)
	|| (instr == SW_CLOS_SP_4)
@


1.11
log
@If signal_ml_handler is called while we are waiting for an X event,
the runtime just prints a message.  This avoids problems with pointer
grabs in X callbacks.
@
text
@d14 5
d281 125
a405 4
/* This is a real hack; there are all sorts of circumstances under
   which it will not work. When we want to get profiling working
   properly for the MIPS, we shall have to fix this. Nick B,
   1995-03-15 */
a408 5
  /* the sp is in a register */
  struct stack_frame *sp = (struct stack_frame *)SC_SP(scp);
  /* and so is the fp and closure */
  sp->fp = (struct stack_frame *) SC_FP(scp);
  sp->closure = SC_CLOSURE(scp);
d413 1
a413 1
  CURRENT_THREAD->ml_state.sp = (word)sp;
d438 1
a438 1
  backtrace ((struct stack_frame *)CURRENT_THREAD->ml_state.sp,
d750 2
a751 5
  if (profile_on) {
    if (global_state.in_ML)
      signal_save_ML_state(scp);
    profile_scan((struct stack_frame *) CURRENT_THREAD->ml_state.sp);
  }
@


1.10
log
@Add thread_preemption_pending.
@
text
@d14 3
d66 1
d214 1
a214 1
  struct event *event = alloc(sizeof(struct event), "Couldn't allocate event");
d216 12
a227 2
  event->type = SIGNAL;
  event->the.signal = sig;
d229 2
a230 5
  event->forward = &event_queue;
  event->back = event_queue.back;
  event->forward->back = event;
  event->back->forward = event;
  ++event_queue.the.sentinel_count;
d232 2
a233 4
  DIAGNOSTIC(2, "signal_handler(sig = %d)  %d pending",
	     sig, event_queue.the.sentinel_count);

  record_event(scp);
@


1.9
log
@Make fatal signal messages come out on stderr.
@
text
@d14 3
d626 2
a627 1
  if (thread_preemption_on)
d629 1
@


1.8
log
@Introduce the threads system.
@
text
@d14 3
d289 1
d297 1
d308 1
@


1.7
log
@Amend best-before date to 1st July 1995.
Also fix Harlequin's telephone number.
Also make license signal handler run on the current stack.
@
text
@d14 5
d55 2
d72 14
a126 3
#if 0 /* Not available on Irix */
 {SIGLOST,	"SIGLOST"},
#endif
d185 11
d218 1
a218 2
  /* must set stack underflow here */  
  implicit_vector.interrupt = 0x7fffffff;
d261 19
d293 13
a305 4
  message ("Intolerable signal %s (%d : %d) received. Backtrace:",
	   signal_name, sig, code);
  backtrace (stderr, (struct stack_frame *)scp->sc_regs[29].lo32, max_backtrace_depth);
  error ("Dying.");
d335 1
a335 117
/*  == Handle math errors in library functions ==
 *
 *  The matherr function is called by the math library when exception
 *  occur.  See matherr(3M).  This function need only handle those
 *  routines we actually provide in reals.[ch]. */

extern int matherr(struct exception *e)
{
  char *problem = e->name;

  in_ml_fpe = 0;
  if(strcmp(problem, "log") == 0)
    exn_raise(perv_exn_ref_ln);
  else if(strcmp(problem, "fabs") == 0)
    exn_raise(perv_exn_ref_abs);
  else if(strcmp(problem, "exp") == 0)
    exn_raise(perv_exn_ref_exp);
  else if(strcmp(problem, "sqrt") == 0)
    exn_raise(perv_exn_ref_sqrt);

  message("Warning: Unhandled floating point error in `%s' -- returning %g",
	  problem, e->retval);

  return(e->retval);
}

/* == Real arithmetic exception support ==
 *
 *  This function is the handler for the floating point exception
 *  signals.  If called while in ML it examines the instruction which
 *  caused the exception in order to determine which ML exception to
 *  raise.  The signal context is updated in order to change raise the
 *  exception when the handler returns.  */

static void signal_real_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
{
  word instruction = *addr;

  DIAGNOSTIC(1, "signal %d: IEEE exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);

  /* Find out whether the exception occurred in ML or C.  If in C then we */
  /* can ignore it -- the library will call matherr (qv) */

  if(is_ml_frame((struct stack_frame *)scp->sc_regs[29].lo32) == MLUNIT)
  {
    if (in_ml_fpe && sig == SIGFPE) {
/*
      message("FP Signal inside fpe, ignoring");
*/
      in_ml_fpe = 0;
    } else {
      message("Warning: signal %d outside ML -- ignoring", sig);
    };
    return;
  }

  /* Check that the instruction type is FPOP */

  if((instruction & 0xC1F00000) != 0x81A00000)
  {
    DIAGNOSTIC(1, "  not an fpop instruction", 0, 0);
    message("Warning: signal %d on non-FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  /* Switch on the instruction code : SPARC-specific */

  switch(instruction & 0x00003FE0)
  {
    /* This case should never happen.  We check the size explicitly,
       because we use 30-bit ints instead of 32-bit ints.
    case 0x1A40:
    DIAGNOSTIC(1, "  fdtoi", 0, 0);
    scp->sc_regs[4] = DEREF(perv_exn_ref_floor);
    break;
    */

    case 0x0540:
    DIAGNOSTIC(1, "  fsqrtd", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_sqrt);
    break;

    case 0x0840:
    DIAGNOSTIC(1, "  faddd", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_sum);
    break;

    case 0x08C0:
    DIAGNOSTIC(1, "  fsubd", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_diff);
    break;

    case 0x0940:
    DIAGNOSTIC(1, "  fmuld", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_prod);
    break;

    case 0x09C0:
    DIAGNOSTIC(1, "  fdivd", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_quot);
    break;

    default:
    DIAGNOSTIC(1, "  unknown fpop instruction", 0, 0);
    message("Warning: signal %d on unknown FP instruction %08X -- ignoring", sig, instruction);
    return;
  }

  scp->sc_pc.lo32 = (int)ml_raise;
/*
  scp->sc_npc = (int)ml_raise+4;
*/
}

/* == Integer exception support == 
d337 1
a337 1
 *  This function is the handler for the emulation trap signals.  If
d343 2
a344 2
static void signal_integer_exception_handler
  (int sig, int code, struct sigcontext *scp, word *addr)
d346 3
a348 1
  word instruction = *addr;
d350 2
a351 2
  DIAGNOSTIC(1, "signal %d: EMT exception code 0x%X", sig, code);
  DIAGNOSTIC(1, "  addr 0x%X: %08X", addr, *addr);
d353 1
a353 5
  if(is_ml_frame((struct stack_frame *)scp->sc_regs[29].lo32) == MLUNIT)
  {
    message("Warning: signal %d outside ML -- ignoring", sig);
    return;
  }
d355 50
a404 14
  /* Switch on the instruction code: SPARC specific */

  switch(instruction & 0xC1F80000)
  {
    case 0x81180000:
    DIAGNOSTIC(1, "  tsubcctv", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_diff);
    break;

    case 0x81100000:
    DIAGNOSTIC(1, "  taddcctv", 0, 0);
    scp->sc_regs[4].lo32 = DEREF(perv_exn_ref_sum);
    break;

d406 4
a409 3
    DIAGNOSTIC(1, "  not a tagged trap int instruction", 0, 0);
    message("Warning: signal %d on non-trap instruction %08X -- ignoring", sig, instruction);
    return;
d412 8
a419 4
  scp->sc_pc.lo32 = (int)ml_raise;
/*
  scp->sc_npc = (int)ml_raise+4;
*/
a421 1

d574 26
a599 5
/* == Profiling support ==
 * 
 * We provide a virtual-time alarm, which goes off after a
 * user-specified number of milliseconds. When it goes off, we call
 * profile_scan(), and restart the alarm when it returns. */
d601 2
a602 1
static struct itimerval profiler_timer;
d604 2
a605 1
/* The signal handler function. Note that we don't use the arguments at all */
d607 1
a607 1
static void signal_profiler_alarm (int sig, int sig_code,
d611 5
a615 1
  profile_scan((struct stack_frame *) scp->sc_regs[29].lo32);
d617 4
a620 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Frequency profiling will not occur.", errno);
d623 1
a623 1
/* start things off */
d625 1
a625 1
extern void signal_start_profiler_timer(unsigned int interval)
d627 2
a628 1
  struct sigvec vec = {signal_profiler_alarm, SIGVTALRM, SV_ONSTACK};
d630 6
a635 2
  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    error("Unable to set up profiler signal handler.");
d637 1
a637 4
  profiler_timer.it_value.tv_sec = interval/1000;
  profiler_timer.it_value.tv_usec = (interval%1000)*1000;
  profiler_timer.it_interval.tv_sec = 0;
  profiler_timer.it_interval.tv_usec = 0; /* one shot timer */
d639 4
a642 3
  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
    message("Warning: Unable to set profile timer (setitimer set errno "
	    "to %d).  Stack scan profiling will not occur.", errno);
d645 5
a649 1
/* kill the timer */
d651 1
a651 1
extern void signal_stop_profiler_timer(void)
d653 1
a653 20
  struct sigvec vec = {SIG_DFL, SIGVTALRM, SV_ONSTACK};

  profiler_timer.it_value.tv_sec = profiler_timer.it_value.tv_usec = 0;
  profiler_timer.it_interval.tv_sec = profiler_timer.it_interval.tv_usec = 0;

  if(setitimer(ITIMER_VIRTUAL, &profiler_timer, NULL) == -1)
  {
    message("Warning: Unable to unset profile timer (setitimer set errno "
	    "to %d).  Future alarm signals will be ignored.", errno);
    vec.sv_handler = SIG_IGN;

    if(sigvec(SIGVTALRM, &vec, NULL) == -1)
      /* this is an error because we can't stop profiling */
      error("Unable to reset alarm signal handler (sigvec set errno to %d).",
	    errno);
  }
  if(sigvec(SIGVTALRM, &vec, NULL) == -1)
    /* this is not a serious error: we've turned off the clock anyway */
    message("Warning: Unable to reset alarm signal handler (sigvec set errno "
	    "to %d).", errno);
d663 1
a663 1
  /* establish integer arithmetic exception catcher */
d665 1
a665 1
  sv.sv_handler = signal_integer_exception_handler;
d669 2
a670 2
  if(sigvec(SIGEMT, &sv, NULL) == -1)
    error("Unable to set integer exception handler.  "
d673 1
a673 1
  /* establish real arithmetic exception catcher */
d675 7
a681 6
#if 0 /* Can't do this bit yet */
  if(ieee_handler("set", "common",
		  (sigfpe_handler_type) signal_real_exception_handler))
    error("Unable to set floating point exception handler.  "
	  "ieee_handler set errno to %d.", errno);
#endif
d686 1
a686 1
    (char *)alloc(SIGNAL_STACK_SIZE, "Unable to allocate signal stack in profiler.");
d705 13
a717 3
  signal_reserve (SIGEMT);	/* integer exceptions */
  signal_reserve (SIGFPE);	/* real exceptions */
  signal_reserve (SIGVTALRM);	/* profiling */
@


1.6
log
@Remove set_stack_underflow() call.
@
text
@d14 3
d446 2
a447 2
 * The whole licensing mechanism is due to be rewritten in 1994, but
 * for now it lives in here. See license.[ch] for more background.
d462 1
a462 1
#define BEST_BEFORE	788918400	/* 1995-01-01 sometime */
d505 1
a505 1
	    "   telephone:        +44 223 872522");
d537 1
a537 1
  sv.sv_flags = SV_ONSTACK;
@


1.5
log
@Add includes.
@
text
@d14 3
d185 2
a186 2
  
  set_stack_underflow();
@


1.4
log
@Update license expiry date
@
text
@d14 3
d55 1
d57 1
@


1.3
log
@Make sure signal handlers get executed on the signal stack.
@
text
@d14 3
d451 1
a451 1
#define BEST_BEFORE	781024732	/* 1994-10-01 sometime */
@


1.3.1.1
log
@branched from 1.3
@
text
@a13 3
 * Revision 1.3  1994/07/25  14:01:54  nickh
 * Make sure signal handlers get executed on the signal stack.
 *
@


1.2
log
@Add signal_interrupt
@
text
@d14 3
d523 1
a523 1
  sv.sv_flags = 0;
d659 1
a659 1
  sv.sv_flags = 0;
@


1.1
log
@new file
@
text
@d13 4
a16 1
 * $Log$
d255 1
@
