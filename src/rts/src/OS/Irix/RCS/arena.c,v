head	1.15;
access;
symbols
	MLW_daveb_inline_1_4_99:1.15.1
	MLWorks_21c0_1999_03_25:1.15
	MLWorks_20c1_1998_08_20:1.14
	MLWorks_20c0_1998_08_04:1.14
	MLWorks_20b2c2_1998_06_19:1.13
	MLWorks_20b2_Windows_1998_06_12:1.13
	MLWorks_20b1c1_1998_05_07:1.11
	MLWorks_20b0_1998_04_07:1.11
	MLWorks_20b0_1998_03_20:1.11
	MLWorks_20m2_1998_02_16:1.11
	MLWorks_MM_adapt:1.11.9
	MLWorks_20m1_1997_10_23:1.11
	MLWorks_11r1:1.11.6.1.1.1.1
	MLWorks_workspace_97:1.11.8
	MLWorks_dt_wizard:1.11.7
	MLWorks_11c0_1997_09_09:1.11.6.1.1.1
	MLWorks_10r3:1.11.6.1.3
	MLWorks_10r2_551:1.11.6.1.2
	MLWorks_11:1.11.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.11.6.1
	MLWorks_20m0_1997_06_20:1.11
	MLWorks_1_0_r2c2_1997_06_14:1.11.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.11.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.11.6
	MLWorks_BugFix_1997_04_24:1.11
	MLWorks_1_0_r2_Win32_1997_04_11:1.11
	MLWorks_1_0_r2_Unix_1997_04_04:1.11
	MM_ML_release_korma_1997_04_01:1.11
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.11.4.1.1
	MLWorks_gui_1996_12_18:1.11.5
	MLWorks_1_0_Win32_1996_12_17:1.11.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.11.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.11.1.1
	JFHrts:1.11.3
	MLWorks_1_0_Irix_1996_11_28:1.11.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.11.2
	MLWorks_1_0_Unix_1996_11_14:1.11.1
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.10
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9
	hope_poo:1.1.1
	ML_beta_release_12/08/94:1.1.1.1
	ML_beta_release_03/08/94:1.1;
locks; strict;
comment	@ * @;


1.15
date	98.08.21.14.27.06;	author jont;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	98.07.15.13.28.29;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	98.05.22.10.34.07;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	98.05.15.13.28.18;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.10.29.17.27.33;	author nickb;	state Exp;
branches
	1.11.1.1
	1.11.2.1
	1.11.3.1
	1.11.4.1
	1.11.5.1
	1.11.6.1
	1.11.7.1
	1.11.8.1
	1.11.9.1;
next	1.10;

1.10
date	96.05.31.14.00.18;	author nickb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1;
next	1.9;

1.9
date	96.05.14.16.32.17;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.04.05.14.04.01;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.28.14.48.29;	author io;	state Exp;
branches;
next	1.6;

1.6
date	95.03.01.13.44.29;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	94.12.14.17.23.57;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.11.30.14.54.16;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.10.19.16.47.34;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.10.13.13.04.42;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	94.07.25.16.06.52;	author jont;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.07.05.10.28.29;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.25.13;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.15.35;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.35.01;	author hope;	state Exp;
branches;
next	;

1.11.1.1
date	96.11.14.13.00.40;	author hope;	state Exp;
branches
	1.11.1.1.1.1;
next	;

1.11.1.1.1.1
date	96.11.28.15.10.44;	author hope;	state Exp;
branches;
next	;

1.11.2.1
date	96.11.22.18.18.31;	author hope;	state Exp;
branches;
next	;

1.11.3.1
date	96.12.17.10.05.13;	author hope;	state Exp;
branches;
next	;

1.11.4.1
date	96.12.17.17.56.48;	author hope;	state Exp;
branches
	1.11.4.1.1.1;
next	;

1.11.4.1.1.1
date	97.02.24.11.48.28;	author hope;	state Exp;
branches;
next	;

1.11.5.1
date	96.12.18.09.51.29;	author hope;	state Exp;
branches;
next	;

1.11.6.1
date	97.05.12.10.45.09;	author hope;	state Exp;
branches
	1.11.6.1.1.1
	1.11.6.1.2.1
	1.11.6.1.3.1;
next	;

1.11.6.1.1.1
date	97.07.28.18.24.54;	author daveb;	state Exp;
branches
	1.11.6.1.1.1.1.1;
next	;

1.11.6.1.1.1.1.1
date	97.10.07.11.50.41;	author jkbrook;	state Exp;
branches;
next	;

1.11.6.1.2.1
date	97.09.08.17.18.07;	author daveb;	state Exp;
branches;
next	;

1.11.6.1.3.1
date	97.09.09.14.14.19;	author daveb;	state Exp;
branches;
next	;

1.11.7.1
date	97.09.10.19.30.39;	author brucem;	state Exp;
branches;
next	;

1.11.8.1
date	97.09.11.21.00.15;	author daveb;	state Exp;
branches;
next	;

1.11.9.1
date	97.10.31.13.43.24;	author nickb;	state Exp;
branches;
next	;

1.15.1.1
date	99.04.01.18.00.31;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.15
log
@[Bug #20134]
Implement system_validate_address
@
text
@/*  ==== ARENA MANAGEMENT ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *  The system call mmap() is used to map in areas of virtual memory at
 *  fairly arbitrary addresses throughout the arena.  The functions map()
 *  and unmap() deal with this.  In particular, map() always succeeds or
 *  causes an error.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Irix:arena.c,v $
 * Revision 1.14  1998/07/15  13:28:29  jont
 * [Bug #20124]
 * Add implementation of system_valid_address
 *
 * Revision 1.13  1998/05/22  10:34:07  jont
 * [Bug #70035]
 * Allow block_free to call space_free when appropriate
 *
 * Revision 1.12  1998/05/15  13:28:18  jont
 * [Bug #70029]
 * Modify space management to allow OS to place mmapped space
 *
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
 * Revision 1.10  1996/05/31  14:00:18  nickb
 * Correct mmap failure switch and add some testing code.
 * Also reserve the process stack space.
 *
 * Revision 1.9  1996/05/14  16:32:17  nickb
 * Improve out-of-memory behaviour.
 *
 * Revision 1.8  1995/04/05  14:04:01  nickb
 * Add maximum memory use reporting.
 *
 * Revision 1.7  1995/03/28  14:48:29  io
 * add nonzero exit status for EOF case when no vm avail
 *
 * Revision 1.6  1995/03/01  13:44:29  nickb
 * Add interface for holes and make space_gen array general.
 *
 * Revision 1.5  1994/12/14  17:23:57  nickb
 * Fix for Irix bad handling of munmap to truncate mmap() areas
 *
 * Revision 1.4  1994/11/30  14:54:16  nickb
 * Handle mmap() EAGAIN failure properly.
 *
 * Revision 1.3  1994/10/19  16:47:34  nickb
 * Add include.
 *
 * Revision 1.2  1994/10/13  13:04:42  nickb
 * Allow multiple block spaces, so blocks can occupy more of arena.
 *
 * Revision 1.1  1994/07/25  16:06:52  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:25:14  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:50:00  nickh
 * new file
 *
 *  Revision 1.9  1994/01/28  17:47:14  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.8  1993/12/14  17:41:08  nickh
 *  Added comment, a couple of minor fixes resulting from a code read-through.
 *
 *  Revision 1.7  1993/06/02  13:11:46  richard
 *  Added parentheses suggested by GCC 2.
 *
 *  Revision 1.6  1992/12/14  12:25:29  daveb
 *  Instead of suspending when we run out of virtual memory, we now prompt
 *  the user to continue or quit.
 *
 *  Revision 1.5  1992/10/19  11:43:36  richard
 *  Changed the grain rounding mechanism to lessen the overhead of small
 *  spaces.
 *
 *  Revision 1.4  1992/10/02  08:32:30  richard
 *  Added missing include of utils.h.
 *
 *  Revision 1.3  1992/08/27  16:20:08  richard
 *  Changed output of suspension message again.
 *
 *  Revision 1.2  1992/08/25  15:12:18  richard
 *  Improved the messages.
 *
 *  Revision 1.1  1992/08/04  11:35:46  richard
 *  Initial revision
 *
 */

#include "ansi.h"
#include "arena.h"
#include "mem.h"
#include "types.h"
#include "diagnostic.h"
#include "utils.h"
#include "syscalls.h"

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

#include <sys/mman.h>
#include <sys/types.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/signal.h>
#include <sys/fault.h>
#include <sys/syscall.h>
#include <sys/procfs.h>

/* type and extent tables */

byte space_type[NR_SPACES];
size_t space_extent[NR_SPACES];
void *space_info[NR_SPACES];

/* Under Irix 5.2, when using munmap(2) to truncate a region allocated
 * by mmap(2), the freed swap space is not unreserved at once. This is
 * a bug in Irix 5.2, and can cause us to leak swap space until we run
 * out. To get around it, we never truncate a region which mmap()
 * created. This means we can keep a lot of space mapped unnecessarily.
 * 
 * The mechanism we use for this work-around is to keep track of how
 * much memory is mapped in each arena space. When resizing a space,
 * we only map if the new extent exceeds the mapped amount. We only
 * unmap when the extent falls to zero. */

static size_t space_mapped[NR_SPACES];

/* The first block space has a statically-allocated map. Later block
   spaces have their maps in a reserved region within the first block
   space. The pointer 'block_maps' indicates the next available
   location for a map in this region */

/* Now modified */
/* first_block_space_map is still the pointer
   to the map for the initial block space.
   Later block spaces have their maps allocated
   within the space allocated as block_maps, according
   to their space number,
   ie for block j in space i, its type is block_maps[i][j]
   But we still use the space_info array as Iliffe vectors
   for speed rather than calculating each time.
   This also ensures that we don't use the wrong block_map
   for the initial block space */

byte first_block_space_map[BLOCKS_PER_SPACE];
byte *block_maps = NULL;

size_t arena_extent = 0;
#ifdef COLLECT_STATS
size_t max_arena_extent = 0;
#endif

static int zero_device;
static int page_size;

#define BACKOFF_LIMIT	5

/* arena_state is UNINITIALIZED until the arena has been initialized.
 * See arena_init() and block_alloc() below.
 *
 * GCC 2.x calls __main() before main(). __main() can call malloc().
 * Our malloc(), on first call, calls block_alloc() to get some heap.
 * If the arena has been initialized, we simply allocate a block.
 * Otherwise we initialize the arena then. */

enum {
  UNINITIALIZED = 0,
  INITIALIZING,
  INITIALIZED};

static int arena_state = UNINITIALIZED;

/* grains. The purpose of grain_round is to round its argument (a
number of bytes) up to a convenient size, where "convenient" means "a
multiple of 2^n (where n<=20), which does not waste more than
GRAIN_OVERHEAD bytes per 0x100". */

#define MAX_GRAIN_SIZE		0x100000	/* 1Mb */
#define GRAIN_OVERHEAD		0x10		/* per 0x100 */
#define GRAINROUND(grain, size)	(((size)+(grain)-1) & ~((grain)-1))

static size_t grain_round(size_t size)
{
  int grain;
  /* we round at least to the nearest page */
  size_t rounded = GRAINROUND(page_size, size);
  /* maximum is the maximum acceptable size (any more wastes too much) */
  size_t maximum = (size * (0x100+GRAIN_OVERHEAD))/ 0x100;

  if(rounded > 0)
    for(grain = MAX_GRAIN_SIZE; grain >= page_size; grain >>= 1)
    {
      rounded = GRAINROUND(grain, size);
      
      if (rounded < maximum)
	break;
    }

  return(rounded);
}

unsigned long map_attempt = 0;

static void map(void *start, size_t length)
{
  map_attempt ++;

  if (arena_state != INITIALIZED)
    error_without_alloc("Trying to map memory before arena initialized.\n");

  while(length > 0 &&
	mmap((caddr_t)start, length,
	     PROT_READ | PROT_WRITE | PROT_EXEC,
	     MAP_FIXED | MAP_PRIVATE,
	     zero_device, 0) == (caddr_t)-1)
    switch(errno)
    {

/* Irix mmap man page says:

     EAGAIN The	amount of logical swap space required is temporarily
	    unavailable.

     ENOMEM MAP_FIXED was specified and	the range [addr, addr +	len) is
	    invalid or exceeds that allowed for	the address space of a
	    process, or	MAP_FIXED was not specified and	there is insufficient
	    room in the	address	space to effect	the mapping.
*/

    case EAGAIN:
    case ENOMEM:

      if ((out_of_memory_dialog == NULL) ||
	  ((*out_of_memory_dialog)(map_attempt, arena_extent, length) == 0))
	error_without_alloc("Out of virtual memory.\n");
      break;

    default:
      error("mmap(0x%08x, 0x%08x) returned an unexpected error code %d",
	    start, length, errno);
    }

  arena_extent += length;
#ifdef COLLECT_STATS
  if (arena_extent > max_arena_extent)
    max_arena_extent = arena_extent;
#endif
}

static void unmap(void *start, size_t length)
{
  /* We simply rereserve this via mmap on reserve_device,
   * rather than unmapping */
  int space = SPACE(start);
  off_t offset = (unsigned long)start - (unsigned long)(SPACE_BASE(space));
  if (length > 0 &&
      mmap(start, length, PROT_NONE, MAP_FIXED | MAP_SHARED,
	   zero_device, offset) == (caddr_t)-1) {
    error("unmap has failed with an unexpected error code %d meaning %s\n",
	  errno, strerror(errno));
  };
  arena_extent -= length;
}

#ifdef DEBUG

void test_mapping(void)
{
  int i,j;
  byte *block_map;
  for (i=0 ; i<NR_SPACES; ++i) {
    switch (space_type[i]) {
    case TYPE_RESERVED:
      /* these are reserved */
      message("space at 0x%08x reserved",SPACE_BASE(i));
      break;
    case TYPE_BLOCKS:
      /* test each block */
      block_map = SPACE_MAP(i);
      message("testing block space at 0x%08x",SPACE_BASE(i));
      for (j=0; j < BLOCKS_PER_SPACE; j++) {
	switch (block_map[j]) {
	case TYPE_FREE:
	  message("  testing block at 0x%08x",BLOCK_BASE(i,j));
	  map (BLOCK_BASE(i,j), BLOCK_SIZE);
	  unmap (BLOCK_BASE(i,j), BLOCK_SIZE);
	  break;
	default:
	  message("  block at 0x%08x has type %d",
		  BLOCK_BASE(i,j),block_map[j]);
	}
      }
      break;
    case TYPE_FREE:
      /* test the whole space */
      message("testing space at 0x%08x",SPACE_BASE(i));
      map(SPACE_BASE(i), SPACE_SIZE >> 1);
      unmap(SPACE_BASE(i), SPACE_SIZE >> 1);
      break;
    default:
      message("space at 0x%08x used with type %d",
	      SPACE_BASE(i), space_type[i]);
    }
  }
}

#endif

/* Under Irix the process stack grows downwards from 0x80000000.
   Allowing 64k for the process stack (which is only used for thread
   0), we set the following limit: */

#define ARENA_LIMIT	0x7fff0000

static int reserve_arena_space(caddr_t *base)
{
  int space;
  *base = mmap((void *)0, SPACE_SIZE, PROT_NONE, MAP_SHARED | MAP_AUTORESRV,
	       zero_device, (off_t)0);
  if (*base == (caddr_t)-1 || ((unsigned long)*base) > ARENA_LIMIT) {
    /* Failed to reserve */
    return 1;
  }
  space = SPACE(((word)(*base)) + (SPACE_SIZE) -1);
  if ((caddr_t)(SPACE_BASE(space)) != *base) {
    /* Oh dear, we've got an unaligned piece of space */
    /* Unmap it, get double then junk the bits on the ends */
    if (munmap(*base, SPACE_SIZE) == -1) {
      error("munmap(1)(0x%x, 0x%x) has returned an unexpected error code %d meaning %s", *base, SPACE_SIZE, errno, strerror(errno));
    }
    *base = mmap((void *)0, 2*(SPACE_SIZE), PROT_NONE, MAP_SHARED | MAP_AUTORESRV,
		 zero_device, (off_t)0);
    if (*base == (caddr_t)-1) {
      /* Failed to reserve */
      return 1;
    }
    /* Now unmap the bits over at the start and end */
    space = SPACE(((word)(*base)) + (SPACE_SIZE) -1);
    if ((caddr_t)(SPACE_BASE(space)) != *base) {
      /* unmap the leftover at the start */
      if (munmap(*base, (unsigned long)(SPACE_BASE(space))-(unsigned long)(*base)) == -1) {
	error("munmap(2)(0x%x, 0x%x) has returned an unexpected error code %d meaning %s", *base, (unsigned long)(SPACE_BASE(space))-(unsigned long)(*base), errno, strerror(errno));
      }
    }
    if (((unsigned long)(SPACE_BASE(space+1))) !=
	((unsigned long)(*base)) + 2 *(SPACE_SIZE)) {
      /* unmap the leftover at the end */
      if (munmap((caddr_t)(SPACE_BASE(space+1)),
		 (unsigned long)(*base)-((unsigned long)(SPACE_BASE(space-1)))) == -1) {
	error("munmap(3)(0x%x, 0x%x) has returned an unexpected error code %d meaning %s", SPACE_BASE(space+1), (unsigned long)(*base)-((unsigned long)(SPACE_BASE(space-1))), errno, strerror(errno));
      }
    }
  }
  space_type[space]   = TYPE_FREE;
  space_extent[space] = 0;
  SPACE_MAP(space) = NULL;
  return 0;
}

/*
 * Non-returning version of reserve_arena_space
 * for use by space_alloc
 */
static void acquire_arena_space(void)
{
  caddr_t base;
  if (reserve_arena_space(&base)) {
    error("Run out of arena spaces.");
  }
}

static void release_arena_space(int space)
{
  if (munmap((caddr_t)(SPACE_BASE(space)), SPACE_SIZE) == -1) {
    error("munmap(4)(0x%x, 0x%x) has returned an unexpected error code %d meaning %s", SPACE_BASE(space), errno, strerror(errno));
  }
  /* Now mark the space reserved */
  space_type[space]   = TYPE_RESERVED;
  space_extent[space] = 0;
  space_mapped[space] = 0;
  SPACE_MAP(space)    = NULL;
}

#ifdef DEBUG
void test_validate_address(void)
{
  unsigned int i = 0;
  do {
    if (system_validate_address((void *)i)) {
      printf("Address 0x%x ok\n", i);
    } else {
      printf("Address 0x%x bad\n", i);
    }
    i += page_size;
  } while (i != 0);
}
#endif

void arena_init(void)
{
  int first_block_space = 0, i;
  
  switch (arena_state) {
    
  case UNINITIALIZED: {
    arena_state = INITIALIZING;
    page_size = getpagesize();
    
    zero_device = open("/dev/zero", O_RDONLY);
    if(zero_device == -1)
      error_without_alloc("Arena initializing unable to open /dev/zero.");
    
    /* First mark all spaces reserved */
    for (i = 0; i < NR_SPACES; i++) {
      space_type[i]   = TYPE_RESERVED;
      space_extent[i] = (size_t)-1;
      SPACE_MAP(i)    = NULL;
    }

    /* Now allocate the spaces we want */
    for (i = 0; i < 2; i++) {
      int space;
      caddr_t base;
      if (reserve_arena_space(&base)) {
	error_without_alloc("Arena initializing unable to reserve memory\n");
      }
      space = SPACE(((word)base) + (SPACE_SIZE) -1);
      if (first_block_space == 0) {
	/* Allocate first block space to what we've just got */
	int i;
	first_block_space = space;
	for (i=0; i < BLOCKS_PER_SPACE; ++i) {
	  first_block_space_map[i] = TYPE_FREE;
	}
	SPACE_MAP(first_block_space) = first_block_space_map;
	space_type[first_block_space] = TYPE_BLOCKS;
	space_extent[first_block_space] = (size_t)-2;
      }
    }

    arena_extent = 0;
#ifdef COLLECT_STATS
    max_arena_extent = 0;
#endif
    arena_state = INITIALIZED;

    /* The arena is now initialized, so we can call block_alloc */
    block_maps = block_alloc(TYPE_RESERVED,
			     (unsigned long)SPACES_IN_ARENA*BLOCKS_PER_SPACE);
    break;
  }
  case INITIALIZING:
    error_without_alloc("Allocation during arena startup.");
  case INITIALIZED:
    /* Could get to here if we alloc before arena_init gets called. */
    break;
  default:
    error_without_alloc("Arena state inconsistent.");
  }
}

void space_free(byte *space)
{
  int space_no = SPACE(space);
  unmap(space, space_mapped[space_no]);
  release_arena_space(space_no);
}

void space_resize(byte *space, size_t extent)
{
  unsigned int space_no = SPACE(space);
  size_t mapped = space_mapped[space_no];

  extent = grain_round(extent);

  if(extent > mapped) {
    map(space+mapped, extent-mapped);
    space_mapped[space_no] = extent;
  } else if(extent == 0) {
    unmap(space, mapped);
    space_mapped[space_no] = 0;
  }

  space_extent[space_no] = extent;
}

byte *space_alloc(byte type, size_t extent)
{
  unsigned int i;

  if (extent > SPACE_SIZE) {
    error("Allocating too large a space");
  }

  while(1) {
    for(i=0; i<SPACES_IN_ARENA; ++i)
      if(space_type[i] == TYPE_FREE) {
	space_type[i] = type;
	space_extent[i] = 0;
	space_mapped[i] = 0;
	space_resize(SPACE_BASE(i), extent);
	return SPACE_BASE(i);
      }
    acquire_arena_space();
  }

  error("Run out of arena spaces.");
  return 0; /* NOT REACHED */
}

/* Allow general mapping holes inside spaces; note that both of these
 * functions can be no-ops to start with */

void space_allow_hole(byte *hole, size_t extent)
{
}

void space_remove_hole(byte *hole, size_t extent)
{
}

byte *block_alloc(byte type, size_t size)
{
  int s, b, found = 0, blocks = BLOCKS(size);
  byte *block_map;
  byte *space;

  if (arena_state != INITIALIZED)
    arena_init();

  if (blocks > BLOCKS_PER_SPACE)
    error("Trying to allocate too many contiguous blocks.");

  for(s=0; s<SPACES_IN_ARENA; ++s) {
    if (space_type[s] == TYPE_BLOCKS) {
      block_map = SPACE_MAP(s);
      for (b=0; b<BLOCKS_PER_SPACE; b++) {
	if (block_map[b] == TYPE_FREE) {
	  found ++;
	  if(found >= blocks) {
	    int start = b+1-found, k;

	    for(k=start; k<=b; ++k)
	      block_map[k] = type;
	    map(BLOCK_BASE(s,start), GRAINROUND(page_size, size));
	    return(BLOCK_BASE(s,start));
	  }
	}
	else
	  found = 0;
      }
      found = 0;
    }
  }

  /* None of the existing block spaces have room; let's make a new one */

  space = space_alloc(TYPE_BLOCKS,0);    /* allocate the new space */
  s = SPACE(space);
  block_map = SPACE_MAP(s) = block_maps + s*BLOCKS_PER_SPACE;
  /* This is where the map is */

  for(b=0; b< blocks; ++b)
    block_map[b] = type;
  for (b=blocks; b < BLOCKS_PER_SPACE; b++)
    block_map[b] = TYPE_FREE;		 /* ... and initialize it */

  map(space, GRAINROUND(page_size, size));
  return(space);
}

void block_free(byte *block, size_t size)
{
  unsigned int space_nr = SPACE(block);
  unsigned int block_nr = BLOCK_NR(block);
  size_t blocks = BLOCKS(size);
  byte *block_map = SPACE_MAP(space_nr);
  int i;
  int ok = 1;

  for(i=0; i<blocks; ++i)
    block_map[block_nr+i] = TYPE_FREE;
  /* See if we can free the entire space */
  for (i=0; i<BLOCKS_PER_SPACE; i++) {
    if (block_map[i] != TYPE_FREE) {
      ok = 0;
      break;
    }
  }

  unmap(block, GRAINROUND(page_size, size));
  if (ok) {
    /* Free the entire space */
    release_arena_space(space_nr);
  }
}

int system_validate_address(void *addr)
{
#if 0
  /* This is the implementation as it would be if the Irix designers weren't
   * so stupid as to disallow the relevant ioctls except to su programs.
   * Still irix will be dead within a year or so when SGI stop making MIPS
   * after which it will all be somewhat academic.
   */
  int page_mask = -1 ^ (page_size-1);
  caddr_t start_addr = (caddr_t)(((int)addr) & page_mask);
  int pid = getpid();
  char buffer[256];
  int fildes;
  int j;
  int mappings;
  prmap_t *maps;
  sprintf(buffer, "/proc/pinfo/%05d", pid);
  printf("Opening '%s'\n", buffer);
  fildes = open(buffer, O_RDONLY);
  if (fildes == -1) {
    error("system_validate_address fails with errno %d(%s) to open '%s'\n", errno, strerror(errno), buffer);
  }
  if (ioctl(fildes, PIOCNMAP, &mappings) == -1) {
    error("ioctl PIOCNMAP fails with errno %d(%s)\n", errno, strerror(errno));
  }
  maps = malloc((mappings+1) * sizeof(prmap_t));
  if (maps == NULL) {
    error("system_validate_address: malloc has returned NULL on request for 0x%x bytes\n",
	  (mappings+1) * sizeof(prmap_t));
  }
  if (ioctl(fildes, PIOCMAP, maps) == -1) {
    error("ioctl PIOCMAP fails with errno %d(%s)\n", errno, strerror(errno));
  }
  if (ioctl(fildes, PIOCNMAP, &mappings) == -1) {
    error("ioctl PIOCNMAP fails with errno %d(%s)\n", errno, strerror(errno));
  }
  /* This allows for the fact that the malloc might cause an extra SPACE to be created */
  close(fildes);
  for(j=0; j<mappings; j++) {
    if (maps[j].pr_vaddr <= start_addr && start_addr < maps[j].pr_vaddr + maps[j].pr_size) {
      long flags = maps[j].pr_mflags;
      free(maps);
      return (flags & MA_READ) ? 1 : 0;
    }
  }
  free(maps);
  return 0;
#else
  return 1; /* Best we can do given the stupid OS design */
#endif
}
@


1.15.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a14 4
 * Revision 1.15  1998/08/21  14:27:06  jont
 * [Bug #20134]
 * Implement system_validate_address
 *
@


1.14
log
@[Bug #20124]
Add implementation of system_valid_address
@
text
@d15 4
d116 4
d396 15
d612 48
a659 1
  return 1; /* Dummy until we find a real implementation */
@


1.13
log
@[Bug #70035]
Allow block_free to call space_free when appropriate
@
text
@d15 4
d585 5
@


1.12
log
@[Bug #70029]
Modify space management to allow OS to place mmapped space
@
text
@d15 4
d133 12
a317 3
  /*
  printf("Entered reserve_arena_space\n");
  */
a323 3
  /*
  printf("Entered reserve_arena_space(1), base = 0x%x, SPACE_BASE(SPACE(base)) = 0x%x\n", *base, SPACE_BASE(SPACE(((word)(*base)) + (SPACE_SIZE) -1)));
  */
a327 3
    /*
    printf("Entered reserve_arena_space(2)\n");
    */
a332 3
    /*
    printf("Entered reserve_arena_space(3), base = 0x%x, SPACE_BASE(SPACE(base)) = 0x%x\n", *base, SPACE_BASE(SPACE(((word)(*base)) + (SPACE_SIZE) -1)));
    */
a336 3
    /*
    printf("Entered reserve_arena_space(4)\n");
    */
a340 3
      /*
      printf("unmapping at 0x%x, length1 0x%x, length2 0x%x\n", *base, (unsigned long)(SPACE_BASE(space)), (unsigned long)(*base));
      */
a344 3
    /*
    printf("Entered reserve_arena_space(5)\n");
    */
a353 6
  /*
  printf("Entered reserve_arena_space(6)\n");
  */
  /*
  printf("arena_init reserved 0x%x bytes at 0x%x\n", SPACE_SIZE, *base);
  */
a356 3
  /*
  printf("reserve_arena_space at 0x%x\n", (unsigned)*base);
  */
a387 3
  /*
  printf("Entered arena_init\n");
  */
a397 3
    /*
    printf("Entered arena_init(1)\n");
    */
a404 3
    /*
    printf("Entered arena_init(2)\n");
    */
a411 3
      /*
      printf("Entered arena_init(3)\n");
      */
a412 3
      /*
      printf("arena_init reserved 0x%x bytes at 0x%x\n", SPACE_SIZE, base);
      */
a424 3
    /*
    printf("Entered arena_init(4)\n");
    */
a449 3
  /*
  printf("space_free: at 0x%x\n", (unsigned)space);
  */
d545 2
a546 2
  block_map = SPACE_MAP(s) = block_maps; /* allocate a map ... */
  block_maps += BLOCKS_PER_SPACE;       
d564 1
d568 7
d577 4
a581 1

@


1.11
log
@Fix space lookup for pointers with top bit set.
@
text
@d15 3
a101 1
#include <sys/lock.h>
a102 1
#include <signal.h>
d236 10
a245 3
  if(length > 0 && munmap((caddr_t)start, length) == -1)
    error("munmap() has returned an unexpected error code %d", errno);

d299 99
d400 1
a400 2
  byte *data_end;
  int first_block_space, i;
d402 3
a408 2
    data_end = (byte *)sbrk(0);
    first_block_space = SPACE(data_end)+1;
d412 1
a412 1
    if(zero_device < 0)
d415 5
a419 1
    for(i=0; i<first_block_space; ++i) {
a421 1
      space_mapped[i] = (size_t)-1;
d425 28
a452 26
    for (i=0; i < BLOCKS_PER_SPACE; ++i) {
      first_block_space_map[i] = TYPE_FREE;
    }
    
    SPACE_MAP(first_block_space) = first_block_space_map;
    space_type[first_block_space] = TYPE_BLOCKS;
    space_extent[first_block_space] = (size_t)-2;
    space_mapped[first_block_space] = (size_t)-2;
    
    for(i=first_block_space+1; i<SPACES_IN_ARENA; ++i) {
      space_type[i]   = TYPE_FREE;
      space_extent[i] = 0;
      space_mapped[i] = 0;
      SPACE_MAP(i) = NULL;
    }

    if (SPACE(ARENA_LIMIT) < SPACES_IN_ARENA)
      i = SPACE(ARENA_LIMIT);
    else
      i = SPACES_IN_ARENA;
      
    for (; i < NR_SPACES; ++i) {
      space_type[i] = TYPE_RESERVED;
      space_extent[i] = (size_t)-1;
      space_mapped[i] = (size_t)-1;
      SPACE_MAP(i)    = NULL;
d454 3
d481 4
a484 1
  unsigned int space_no = SPACE(space);
d486 1
a486 3
  space_type[space_no] = TYPE_FREE;
  space_extent[space_no] = 0;
  space_mapped[space_no] = 0;
d515 11
a525 8
  for(i=0; i<SPACES_IN_ARENA; ++i)
    if(space_type[i] == TYPE_FREE) {
      space_type[i] = type;
      space_extent[i] = 0;
      space_mapped[i] = 0;
      space_resize(SPACE_BASE(i), extent);
      return SPACE_BASE(i);
    }
@


1.11.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.6.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a14 3
 * Revision 1.11.6.1  1997/05/12  10:45:09  hope
 * branched from 1.11
 *
@


1.11.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a14 3
 * Revision 1.11.6.1  1997/05/12  10:45:09  hope
 * branched from 1.11
 *
@


1.11.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a14 3
 * Revision 1.11.6.1  1997/05/12  10:45:09  hope
 * branched from 1.11
 *
@


1.11.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a14 3
 * Revision 1.11.6.1.1.1  1997/07/28  18:24:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.11.5.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.4.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.4.1.1.1
log
@branched from 1.11.4.1
@
text
@a14 3
 * Revision 1.11.4.1  1996/12/17  17:56:48  hope
 * branched from 1.11
 *
@


1.11.3.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.2.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.1.1
log
@branched from 1.11
@
text
@a14 3
 * Revision 1.11  1996/10/29  17:27:33  nickb
 * Fix space lookup for pointers with top bit set.
 *
@


1.11.1.1.1.1
log
@branched from 1.11.1.1
@
text
@a14 3
 * Revision 1.11.1.1  1996/11/14  13:00:40  hope
 * branched from 1.11
 *
@


1.10
log
@Correct mmap failure switch and add some testing code.
Also reserve the process stack space.
@
text
@d3 1
a3 1
 *  Copyright (C) 1992 Harlequin Ltd
d15 4
d314 4
d321 2
a322 2
    space_extent[i] = (size_t)-2;
    space_mapped[i] = (size_t)-2;
d324 1
a324 1
    for(i=first_block_space+1; i<NR_SPACES; ++i) {
d331 11
a341 3
    if (SPACE(ARENA_LIMIT) < NR_SPACES)
      for (i=SPACE(ARENA_LIMIT); i < NR_SPACES; ++i)
	space_type[i] = TYPE_RESERVED;
a342 4
    for (i=0; i < BLOCKS_PER_SPACE; ++i) {
      first_block_space_map[i] = TYPE_FREE;
    }
    
d351 1
a351 1
			     (unsigned long)NR_SPACES*BLOCKS_PER_SPACE);
d399 2
a400 3
  for(i=0; i<NR_SPACES; ++i)
    if(space_type[i] == TYPE_FREE)
    {
d435 1
a435 1
  for(s=0; s<NR_SPACES; ++s) {
@


1.10.3.1
log
@branched from 1.10
@
text
@a14 4
 * Revision 1.10  1996/05/31  14:00:18  nickb
 * Correct mmap failure switch and add some testing code.
 * Also reserve the process stack space.
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a14 4
 * Revision 1.10  1996/05/31  14:00:18  nickb
 * Correct mmap failure switch and add some testing code.
 * Also reserve the process stack space.
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a14 4
 * Revision 1.10  1996/05/31  14:00:18  nickb
 * Correct mmap failure switch and add some testing code.
 * Also reserve the process stack space.
 *
@


1.9
log
@Improve out-of-memory behaviour.
@
text
@d15 3
d197 12
d218 2
a219 1
      error("mmap() has returned an unexpected error code %d", errno);
d237 50
d322 5
a326 1
    
@


1.8
log
@Add maximum memory use reporting.
@
text
@d15 3
d78 1
d178 2
d182 1
a182 1
  unsigned int backoff = 1;
d197 3
a199 28
      if(backoff >= BACKOFF_LIMIT)
      {
	int pid = getpid();

	message("Unable to obtain virtual memory (%uMb used, %uKb requested);\n"
		"Has your Irix objectserver process grown too large?\n"
		"Enter q to quit mlworks, c to continue.",
		arena_extent >> 20, length >> 10, pid);
	while (1) {
	  int c;
	  c = getchar();
	  if (c == EOF)
	    exit(1);
	  else if (c == 'q')
	    exit(0);
	  else if (c == 'c') {
	    backoff = 1;
	    break;
	  }
	}
      } else {
        message(
	  "Warning: Unable to obtain virtual memory.  Waiting %u seconds.",
	  backoff
	);
        sleep(backoff);
        backoff <<= 1;
      }
d202 1
a202 1
      default:
@


1.7
log
@add nonzero exit status for EOF case when no vm avail
@
text
@d15 3
d121 3
d226 4
d281 3
@


1.6
log
@Add interface for holes and make space_gen array general.
@
text
@d15 3
d195 5
a199 2
	  if ((c = getchar()) == -1 || c == 'q')
	    exit (0);
@


1.5
log
@Fix for Irix bad handling of munmap to truncate mmap() areas
@
text
@d15 3
d91 1
a91 1
byte *space_map[NR_SPACES];
d245 1
a245 1
      space_map[i]    = NULL;
d248 1
a248 1
    space_map[first_block_space] = first_block_space_map;
d257 1
a257 1
      space_map[i] = NULL;
d331 11
d356 1
a356 1
      block_map = space_map[s];
d380 1
a380 1
  block_map = space_map[s] = block_maps; /* allocate a map ... */
d397 1
a397 1
  byte *block_map = space_map[space_nr];
@


1.4
log
@Handle mmap() EAGAIN failure properly.
@
text
@d15 3
d90 13
d241 1
d248 1
d253 1
d282 1
a282 1
  unmap(space, space_extent[space_no]);
d285 1
d291 1
a291 1
  size_t current = space_extent[space_no];
d295 7
a301 4
  if(extent > current)
    map(space+current, extent-current);
  else if(current > extent)
    unmap(space+extent, current-extent);
d319 1
@


1.3
log
@Add include.
@
text
@d15 3
d160 2
a161 24
#ifdef PLOCK
      case EAGAIN:
      if(plock(UNLOCK) == -1)
	switch(errno)
	{
	  case EINVAL:
	  error
	    ("mmap() reported that real memory had been exhausted and yet "
	     "plock() said that the process wasn't locked in real memory.");

	  case EPERM:
	  error
	    ("Real memory is exhausted and unable to unlock the process.");

	  default:
	  error
	    ("plock(UNLOCK) returned an unexpected error code %d.", errno);
	}
      message("Warning: Real memory has been exhausted."
	      "Process unlocked from real memory.");
      break;
#endif

      case ENOMEM:
d168 1
@


1.2
log
@Allow multiple block spaces, so blocks can occupy more of arena.
@
text
@d15 3
d76 1
@


1.1
log
@new file
@
text
@d14 4
a17 1
 *  $Log: src:OS:SunOS:arena.c,v $
a75 2
byte *block_base;
byte block_type[NR_BLOCKS];
d78 10
d101 1
a101 2
 * Otherwise we initialize the arena then.
 */
d122 1
d124 2
d132 1
a132 1
      if(((rounded-size) * 0x100) / size <= GRAIN_OVERHEAD)
d221 2
a222 2
  byte *text_end;
  int free_space, i;
d228 2
a229 2
    text_end = (byte *)sbrk(0);
    free_space = SPACE(text_end)+1;
d236 1
a236 1
    for(i=0; i<free_space; ++i) {
d239 1
d242 3
a244 6
    block_base = SPACE_BASE(free_space);
    
    for(i=free_space; i<free_space+BLOCK_SPACES; ++i) {
      space_type[i]   = TYPE_BLOCKS;
      space_extent[i] = (size_t)-2;
    }
d246 1
a246 1
    for(i=free_space+BLOCK_SPACES; i<NR_SPACES; ++i) {
d249 1
d252 2
a253 2
    for (i=0; i < NR_BLOCKS; ++i) {
      block_type[i] = TYPE_FREE;
d258 4
d274 1
a274 32
int block_alloc(byte type, size_t size)
{
  int i, found = 0, blocks = BLOCKS(size);

  if (arena_state != INITIALIZED)
    arena_init();

  for(i=0; i<NR_BLOCKS; ++i)
  {
    if(block_type[i] == TYPE_FREE)
    {
      if(++found >= blocks)
      {
	int start = i+1-found, j;

	for(j=start; j<=i; ++j)
	  block_type[j] = type;

	map(BLOCK_BASE(start), GRAINROUND(page_size, size));

	return(start);
      }
    }
    else
      found = 0;
  }

  error("Unable to find %u contiguous free blocks in the block space.", blocks);
  return 0; /* NOT REACHED */
}

void block_free(int block, size_t size)
d276 4
a279 7
  size_t blocks = BLOCKS(size);
  int i;

  for(i=0; i<blocks; ++i)
    block_type[block+i] = TYPE_FREE;

  unmap(BLOCK_BASE(block), GRAINROUND(page_size, size));
d282 1
a282 1
void space_resize(unsigned int space, size_t extent)
d284 2
a285 1
  size_t current = space_extent[space];
d290 1
a290 1
    map(SPACE_BASE(space)+current, extent-current);
d292 1
a292 1
    unmap(SPACE_BASE(space)+extent, current-extent);
d294 1
a294 1
  space_extent[space] = extent;
d297 1
a297 1
int space_alloc(byte type, size_t extent)
d310 2
a311 2
      space_resize(i, extent);
      return(i);
d318 51
a368 1
void space_free(unsigned int space)
d370 10
a379 3
  unmap(SPACE_BASE(space), space_extent[space]);
  space_type[space] = TYPE_FREE;
  space_extent[space] = 0;
d381 1
@


1.1.1.1
log
@branched from 1.1
@
text
@d14 1
a14 4
 *  $Log: src:OS:Irix:arena.c,v $
 * Revision 1.1  1994/07/25  16:06:52  jont
 * new file
 *
@
