head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.1
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_MM_adapt:1.15.3
	MLWorks_20m1_1997_10_23:1.15
	MLWorks_11r1:1.14.1.1.1.1.1
	MLWorks_workspace_97:1.15.2
	MLWorks_dt_wizard:1.15.1
	MLWorks_11c0_1997_09_09:1.14.1.1.1.1
	MLWorks_10r3:1.14.1.1.3
	MLWorks_10r2_551:1.14.1.1.2
	MLWorks_11:1.14.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.14.1.1
	MLWorks_20m0_1997_06_20:1.14
	MLWorks_1_0_r2c2_1997_06_14:1.14.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.14.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.14.1
	MLWorks_BugFix_1997_04_24:1.14
	MLWorks_1_0_r2_Win32_1997_04_11:1.14
	MLWorks_1_0_r2_Unix_1997_04_04:1.14
	MM_ML_release_korma_1997_04_01:1.14
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.13.7.1.1
	MLWorks_gui_1996_12_18:1.13.8
	MLWorks_1_0_Win32_1996_12_17:1.13.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.13.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.13.4.1
	JFHrts:1.13.6
	MLWorks_1_0_Irix_1996_11_28:1.13.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.13.5
	MLWorks_1_0_Unix_1996_11_14:1.13.4
	MLWorks_Open_Beta2_1996_10_11:1.13.3
	MLWorks_License_dev:1.13.2
	MLWorks_1_open_beta_1996_09_13:1.13.1
	MLWorks_Open_Beta_1996_08_22:1.13
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13
	hope_poo:1.1.1
	ML_beta_release_12/08/94:1.1.1.1
	ML_beta_release_03/08/94:1.1;
locks; strict;
comment	@ * @;


1.17
date	97.11.18.15.21.41;	author jont;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	97.11.07.17.06.40;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	97.08.19.15.13.53;	author nickb;	state Exp;
branches
	1.15.1.1
	1.15.2.1
	1.15.3.1;
next	1.14;

1.14
date	96.12.19.09.49.34;	author stephenb;	state Exp;
branches
	1.14.1.1;
next	1.13;

1.13
date	96.04.19.11.03.56;	author matthew;	state Exp;
branches
	1.13.1.1
	1.13.2.1
	1.13.3.1
	1.13.4.1
	1.13.5.1
	1.13.6.1
	1.13.7.1
	1.13.8.1;
next	1.12;

1.12
date	96.03.01.12.03.05;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.02.14.17.36.35;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.02.14.15.38.35;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.01.29.13.15.19;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	95.07.17.09.53.55;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.05.10.16.54.19;	author daveb;	state Exp;
branches;
next	1.6;

1.6
date	95.05.02.16.48.45;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.04.13.15.55.36;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.12.09.16.28.08;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.11.09.12.39.02;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.19.16.24.27;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.40.48;	author jont;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.07.05.10.29.49;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	96.09.13.11.23.04;	author hope;	state Exp;
branches;
next	;

1.13.2.1
date	96.10.07.16.13.13;	author hope;	state Exp;
branches;
next	;

1.13.3.1
date	96.10.17.11.32.30;	author hope;	state Exp;
branches;
next	;

1.13.4.1
date	96.11.14.12.58.25;	author hope;	state Exp;
branches
	1.13.4.1.1.1;
next	;

1.13.4.1.1.1
date	96.11.28.15.08.22;	author hope;	state Exp;
branches;
next	;

1.13.5.1
date	96.11.22.18.16.03;	author hope;	state Exp;
branches;
next	;

1.13.6.1
date	96.12.17.10.02.46;	author hope;	state Exp;
branches;
next	;

1.13.7.1
date	96.12.17.17.54.28;	author hope;	state Exp;
branches
	1.13.7.1.1.1;
next	;

1.13.7.1.1.1
date	97.02.24.11.45.33;	author hope;	state Exp;
branches;
next	;

1.13.8.1
date	96.12.18.09.49.03;	author hope;	state Exp;
branches;
next	;

1.14.1.1
date	97.05.12.10.41.28;	author hope;	state Exp;
branches
	1.14.1.1.1.1
	1.14.1.1.2.1
	1.14.1.1.3.1;
next	;

1.14.1.1.1.1
date	97.07.28.18.25.26;	author daveb;	state Exp;
branches
	1.14.1.1.1.1.1.1;
next	;

1.14.1.1.1.1.1.1
date	97.10.07.11.51.17;	author jkbrook;	state Exp;
branches;
next	;

1.14.1.1.2.1
date	97.09.08.17.18.41;	author daveb;	state Exp;
branches;
next	;

1.14.1.1.3.1
date	97.09.09.14.14.50;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	97.09.10.19.31.33;	author brucem;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.11.21.00.58;	author daveb;	state Exp;
branches;
next	;

1.15.3.1
date	97.10.31.13.44.00;	author nickb;	state Exp;
branches;
next	;

1.17.1.1
date	99.04.01.18.00.54;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.17
log
@[Bug #30089]
Remove stuff only required by old (now removed) MLWorks.Time
@
text
@/*  ==== PERVASIVE TIME ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 * Clock time and intervals are timeval pairs of integers (second,
 * microsecond), obtained from getrusage(2) and gettimeofday(2). File
 * modification times obtained from stat(2) get zero microseconds
 * (this appears unsafe, but actually is safe because stat(2) times
 * could be on a different machine in any case, so must only ever be
 * compared with each other, and not with now()).
 *
 * Times and intervals are represented to ML as triples of ints, a
 * pair for the seconds (each MLint taking 24 bits, allowing for
 * 48-bit values) and one for the microseconds.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Irix:time.c,v $
 * Revision 1.16  1997/11/07  17:06:40  jont
 * [Bug #30089]
 * Remove time_file_modified and time_set_file_modified
 *
 * Revision 1.15  1997/08/19  15:13:53  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.14  1996/12/19  09:49:34  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
 * Revision 1.12  1996/03/01  12:03:05  jont
 * Fix implementation of tm_to_time
 *
 * Revision 1.11  1996/02/14  17:36:35  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.10  1996/02/14  15:38:35  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.9  1996/01/29  13:15:19  stephenb
 * Add <sys/resource.h> since syscalls.h no longer pulls this in.
 *
 * Revision 1.8  1995/07/17  09:53:55  nickb
 * Add ml_time_microseconds.
 *
 * Revision 1.7  1995/05/10  16:54:19  daveb
 * Added ml_time_t.
 *
 * Revision 1.6  1995/05/02  16:48:45  jont
 * Improve error message from set_time_modified
 *
 * Revision 1.5  1995/04/13  15:55:36  jont
 * Add interface to gmtime, localtime, mktime
 *
 * Revision 1.4  1994/12/09  16:28:08  jont
 * Change time.h to mltime.h
 *
 * Revision 1.3  1994/11/09  12:39:02  jont
 * Fix overflowing integer computation in get_current_time
 *
 * Revision 1.2  1994/10/19  16:24:27  nickb
 * Change ints to long ints.
 *
 * Revision 1.1  1994/07/12  12:40:48  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:27:56  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:52:22  nickh
 * new file
 *
 *  Revision 1.11  1994/03/30  14:57:28  daveb
 *  Revised set_file_modified to take a datatype.
 *
 *  Revision 1.10  1994/03/30  13:49:43  daveb
 *  Added set_file_modified.
 *
 *  Revision 1.9  1994/01/28  17:40:03  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.8  1993/11/23  17:40:25  jont
 *  Exposed the encode and decode time functions for runtime consistency checking
 *  Increased the size of the marshalling buffer to the required size
 *
 *  Revision 1.7  1993/11/17  12:23:56  nickh
 *  Runtime support for new pervasive time structure.
 *  (radical change).
 *
 *  Revision 1.6  1993/06/02  13:10:08  richard
 *  Removed unused variable.
 *
 *  Revision 1.5  1993/04/26  11:50:51  richard
 *  Increased diagnostic levels.
 *
 *  Revision 1.4  1993/02/01  16:04:34  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.3  1992/12/23  13:57:43  richard
 *  Fixed the use of strftime in the case where the format string is empty.
 *
 *  Revision 1.2  1992/11/09  11:58:46  richard
 *  Corrected some missing initialisation.
 *
 *  Revision 1.1  1992/11/03  14:17:17  richard
 *  Initial revision
 *
 */

#include <errno.h>
#include <sys/resource.h>

#include "mltime.h"
#include "utils.h"

/*  user_clock() is like clock(3) except that it returns only the user
 *  virtual time elapsed.
 */

extern double user_clock(void)
{
  struct rusage rusage;

  if (getrusage(RUSAGE_SELF, &rusage))
    error ("Unable to read resource usage, "
	   "getrusage set errno to %d.",errno);

  return (rusage.ru_utime.tv_usec
	  + (double) rusage.ru_utime.tv_sec * 1000000.0);
}

void time_init()
{
}
@


1.17.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 4
 * Revision 1.17  1997/11/18  15:21:41  jont
 * [Bug #30089]
 * Remove stuff only required by old (now removed) MLWorks.Time
 *
@


1.16
log
@[Bug #30089]
Remove time_file_modified and time_set_file_modified
@
text
@d21 4
a115 5
#include <limits.h>
#include <time.h>
#include <utime.h>
#include <string.h>
#include <stdlib.h>
a116 3
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/time.h>
a118 2
#include "ansi.h"
#include "syscalls.h"
a120 492
#include "allocator.h"
#include "mltypes.h"
#include "values.h"
#include "environment.h"
#include "exceptions.h"
#include "diagnostic.h"
#include "marshal.h"
#include "gc.h"

/* Converting C time values to an ML value */

#define SPLIT0(t)	((unsigned long)((t).tv_sec) & 0xFFFFFF)
#define SPLIT1(t)	(((unsigned long)((t).tv_sec) >> 24))
#define SPLIT2(t)       ((t).tv_usec)

#define MLTIME(r,t)                  \
  do {                               \
    FIELD((r),0) = MLINT(SPLIT0(t)); \
    FIELD((r),1) = MLINT(SPLIT1(t)); \
    FIELD((r),2) = MLINT(SPLIT2(t)); \
  } while (0)


/* Converting an ML value to a C time value */

#define JOIN0(t0)       ((unsigned long) (t0))
#define JOIN1(t1)       (((unsigned long) (t1)) << 24)

#define JOIN(t0,t1)	(JOIN0(t0) | JOIN1(t1))

#define JOINI(r)        (JOIN(CINT(FIELD((r),0)), \
                              CINT(FIELD((r),1))))

/* CTIME should be used with care */

#define CTIME(r,t)                   \
  do {                               \
    (t).tv_sec =  JOINI(r);          \
    (t).tv_usec = CINT(FIELD(r,2));  \
  } while (0)


inline mlval ml_time(struct timeval *t)
{
  mlval result = allocate_record(3);

  MLTIME (result,*t);

  return(result);
}

extern mlval ml_time_microseconds(double t)
{
  struct timeval tv;
  tv.tv_sec =  t / 1000000;
  tv.tv_usec = t - ((double)tv.tv_sec * 1000000.0);
  return (ml_time(&tv));
}

inline mlval ml_time_t (time_t t)
{
  struct timeval tv;

  tv.tv_sec = t;
  tv.tv_usec = 0;		/* safe hack; see comment at head of file */

  return(ml_time(&tv));
}
  
static mlval time_now(mlval unit)
{
  struct timeval t;

  if(gettimeofday(&t, NULL))
    error("Unable to read time of day.  "
	  "gettimeofday() set errno to %d.", errno);

  return (ml_time(&t));
}

static mlval time_format(mlval argument)
{
  mlval time_record = FIELD(argument, 2);
  char *format = CSTRING(FIELD(argument, 0));
  time_t t = JOINI(time_record);
  struct tm *timeptr = CINT(FIELD(argument, 1)) ? localtime(&t) : gmtime(&t);
  size_t size;
  mlval result = MLUNIT;

  if(strlen(format) == 0)
    return(ml_string(""));
  
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, timeptr);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
    }

    free(buffer);
  }

  return(result);
}

static mlval tm_to_time(mlval argument)
{
  /* Interface to mktime. Returns a time_t suitably split up for ml */
  mlval result = MLUNIT;
  struct tm time_val;
  time_t t;
  time_val.tm_sec = CINT(FIELD(argument, 0));
  time_val.tm_min = CINT(FIELD(argument, 1));
  time_val.tm_hour = CINT(FIELD(argument, 2));
  time_val.tm_mday = CINT(FIELD(argument, 3));
  time_val.tm_mon = CINT(FIELD(argument, 4));
  time_val.tm_year = CINT(FIELD(argument, 5));
  time_val.tm_wday = CINT(FIELD(argument, 6));
  time_val.tm_yday = CINT(FIELD(argument, 7));
  time_val.tm_isdst = CINT(FIELD(argument, 8));
  if ((t = mktime(&time_val)) == (time_t)-1) {
    exn_raise_string(perv_exn_ref_io, "tm_to_time:invalid tm");
  } else {
    struct timeval time;
    time.tv_sec = t;
    time.tv_usec = 0;
    result = ml_time(&time);
  }
  return result;
}

static mlval gmtime_to_tm(mlval argument)
{
  /* interface to gmtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = gmtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "gmtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

static mlval localtime_to_tm(mlval argument)
{
  /* interface to localtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = localtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "localtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

/* Are two ML time values equal? Use this to abstract the ML time type
 * from the loader */

extern int ml_time_eq(mlval t1, mlval t2)
{
  mlval *time1 = CPTR(t1);
  mlval *time2 = CPTR(t2);

  if (memcmp(time1, time2, 3*sizeof(mlval)))
    return 0;
  else return 1;
}

/* get the modified timestamp of a file as an ML value; use this in
 * the loader and also provide it to the ML environment */

inline mlval ml_stat(const char *filename)
{
  struct stat stbuf;
  
  DIAGNOSTIC(2, "stat(\"%s\")", filename, 0);
  
  if (stat (filename, &stbuf) == -1)
    return MLERROR;

  DIAGNOSTIC(2, "  mtime = %lu", stbuf.st_mtime, 0);

  return(ml_time_t(stbuf.st_mtime));
}

static mlval time_less(mlval arg)
{
  struct timeval t1, t2;
  mlval time_record1 = FIELD(arg, 0);
  mlval time_record2 = FIELD(arg, 1);

  CTIME(time_record1, t1);
  CTIME(time_record2, t2);

  return(((t1.tv_sec < t2.tv_sec) 
	  || ((t1.tv_sec == t2.tv_sec) && (t1.tv_usec < t2.tv_usec))) 
	 ? MLTRUE : MLFALSE);
}

mlval time_encode(mlval arg)
{
  char buffer[2*MARSHAL_SIZE_LONG], *end;
  struct timeval t;
  size_t length;
  mlval result;

  CTIME(arg,t);

  end = marshal(buffer, "ll", t.tv_sec,t.tv_usec);

  length = end - buffer;

  result = allocate_string(length+1);
  memcpy(CSTRING(result), buffer, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

mlval time_decode(mlval arg)
{
  struct timeval t;

  unmarshal(CSTRING(arg), "ll", &t.tv_sec,&t.tv_usec);

  return(ml_time(&t));
}

static inline void norm_timeval (struct timeval *t)
{
  long secs = t->tv_usec / 1000000;
  long rem = t->tv_usec % 1000000;

  if (rem < 0) {		/* hack to get around C nastiness */
    secs--;
    rem+= 1000000;
  }

  t->tv_usec = rem;
  t->tv_sec += secs;
}

static void timeval_sub (struct timeval *t1,
			 struct timeval *t2,
			 struct timeval *result)
{
  result->tv_sec  = t1->tv_sec  - t2->tv_sec;
  result->tv_usec = t1->tv_usec - t2->tv_usec;
  norm_timeval(result);
}

static void timeval_add (struct timeval *t1,
			 struct timeval *t2,
			 struct timeval *result)
{
  result->tv_sec  = t1->tv_sec  + t2->tv_sec;
  result->tv_usec = t1->tv_usec + t2->tv_usec;
  norm_timeval(result);
}

static mlval interval_to_real (mlval arg)
{
  mlval result;
  struct timeval t;
  double tm;

  CTIME (arg,t);

  result = allocate_real();

  tm = t.tv_sec + (t.tv_usec / 1000000.0);

  (void) SETREAL(result,tm);
  return result;
}

static mlval interval_from_real (mlval arg)
{
  struct timeval t;
  double tm = GETREAL(arg);

  if (tm > LONG_MAX || tm < LONG_MIN) {
    exn_raise (perv_exn_ref_overflow);
  }

  t.tv_sec = tm;
  t.tv_usec = 1000000.0*(tm-t.tv_sec);
  norm_timeval(&t);

  return (ml_time (&t));
}


static struct timeval start_time;

static struct time_record {struct timeval t_user;
			   struct timeval t_sys;
			   struct timeval t_gc;
			   struct timeval t_real;
			 } current_time;

static inline void get_current_time (void)
{
  struct rusage ru;
  struct timeval t;

  current_time.t_gc.tv_sec = gc_clock / 1000000;
  current_time.t_gc.tv_usec = gc_clock - ((double)current_time.t_gc.tv_sec * 1000000.0);

  if(getrusage(RUSAGE_SELF, &ru))
    error("Unable to read resource consumption.  "
	  "getrusage() set errno to %d.", errno);

  timeval_sub(&ru.ru_utime, &current_time.t_gc, &current_time.t_user);
  current_time.t_sys = ru.ru_stime;

  if(gettimeofday(&t, NULL))
    error("Unable to read time of day.  "
	  "gettimeofday() set errno to %d.", errno);

  timeval_sub(&t, &start_time, &current_time.t_real);
}  

static inline mlval return_current_time (void)
{
  mlval result;
  mlval t_gc,t_real,t_sys,t_user;

  t_gc = ml_time(&current_time.t_gc);
  declare_root(&t_gc);
  t_real = ml_time(&current_time.t_real);
  declare_root(&t_real);
  t_user = ml_time(&current_time.t_user);
  declare_root(&t_user);
  t_sys = ml_time(&current_time.t_sys);   
  declare_root(&t_sys);

  result = allocate_record(4);

  /* field ordering alphabetic: gc, real, sys, user */

  FIELD(result,0) = t_gc;
  FIELD(result,1) = t_real;
  FIELD(result,2) = t_sys;
  FIELD(result,3) = t_user;

  retract_root(&t_gc);
  retract_root(&t_user);
  retract_root(&t_sys);
  retract_root(&t_real);

  return(result);
}

static mlval elapsed (mlval unit)
{
  get_current_time ();
  return (return_current_time());
}

static mlval elapsed_since (mlval arg)
{
  struct timeval t1;

  get_current_time();

  CTIME(FIELD(arg,0),t1);
  timeval_sub(&current_time.t_gc, &t1, &current_time.t_gc);
  CTIME(FIELD(arg,1),t1);
  timeval_sub(&current_time.t_real, &t1, &current_time.t_real);
  CTIME(FIELD(arg,2),t1);
  timeval_sub(&current_time.t_sys, &t1, &current_time.t_sys);
  CTIME(FIELD(arg,3),t1);
  timeval_sub(&current_time.t_user, &t1, &current_time.t_user);

  return(return_current_time());
}

static mlval interval (mlval arg)
{
  struct timeval t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}


static mlval time_subtract (mlval arg)
{
  struct timeval t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_add (mlval arg)
{
  struct timeval t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_add (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_to_string (mlval arg)
{
  struct timeval t;
  int digits = CINT(FIELD(arg,1));
  long int whole,frac,i;
  char buffer[50];
  char *p = buffer;

  CTIME(FIELD(arg,0),t);

  whole = t.tv_sec;
  frac = t.tv_usec;

  /* give a maximum of 6 digits */

  if (digits > 6 || digits < 0)
    digits = 6;

  /* negatives need to be normalized, as microsecond parts are always +ve */

  if (whole < 0) {
    *p++ = '~';
    whole = -whole;
    if (frac != 0) {
      whole--;
      frac = 1000000-frac;
    }
  }
  
  /* round for whole numbers, and return without a decimal point */
  
  if (digits == 0) {
    if (frac >= 500000) {
      whole++;
    }
    sprintf(p,"%li",whole);
    
  } else {
    
    /* round for others */

    if (digits != 6) {
      for (i=5; i != digits; i--)
	frac /= 10;
      if  (frac % 10 >= 5)
	frac += 10;
      frac /= 10;
    }
    /* print with a point, left padded with zeroes */
    sprintf(p,"%li.%0*li",whole,digits,frac);
  }

  return (ml_string(buffer));
}
a139 35
  mlval zero;

  zero = allocate_record(4);
  FIELD(zero, 0) = MLINT(0);
  FIELD(zero, 1) = MLINT(0);
  FIELD(zero, 2) = MLINT(0);
  FIELD(zero, 3) = MLINT(0);

  /* get clock start time for elapsed record */

  if(gettimeofday(&start_time, NULL))
    error("Unable to read time of day.  "
	  "gettimeofday() set errno to %d.", errno);

  env_value("time zero", zero);
  env_function("time now", time_now);
  env_function("time less", time_less);
  env_function("time add", time_add);
  env_function("time subtract", time_subtract);

  env_function("time encode", time_encode);
  env_function("time decode", time_decode);

  env_function("time to string",time_to_string);
  env_function("time format", time_format);
  env_function("time mktime", tm_to_time);
  env_function("time gmtime", gmtime_to_tm);
  env_function("time localtime", localtime_to_tm);

  env_function("time interval",interval);
  env_function("interval to real",interval_to_real);
  env_function("interval from real",interval_from_real);

  env_function("time elapsed",elapsed);
  env_function("time elapsed since",elapsed_since);
a140 1
  
@


1.15
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d21 4
a337 33
static mlval time_file_modified(mlval arg)
{
  mlval result = ml_stat (CSTRING(arg));

  if (result == MLERROR)
    exn_raise_format(perv_exn_ref_io,
		     "Cannot mtime %s: does not exist",
		     CSTRING(arg));
  return result;
}

static mlval time_set_file_modified(mlval arg)
{
  struct utimbuf utbuf[1], *utp = NULL;
  char* path = CSTRING(FIELD(arg, 0));

  /*  datatype modtime = NOW | TIME of Time.time  */
  if (MLVALISPTR(FIELD(arg, 1))) {
    mlval time_record = FIELD(FIELD(arg, 1), 1);
    utbuf[0].actime = 0L;
    utbuf[0].modtime = JOINI(time_record);
    utp = utbuf;
  }

  DIAGNOSTIC(2, "real_set_file_modified(\"%s\"), modtime = %lu",
	     path, utp ? utbuf[0].modtime : 0L);

  if(utime(path, utp) == -1)
    exn_raise_format(perv_exn_ref_io, "Cannot set time of %s", path);

  return MLUNIT;
}

a665 3

  env_function("time file modified", time_file_modified);
  env_function("time set file modified", time_set_file_modified);
@


1.15.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a20 4
 * Revision 1.15  1997/08/19  15:13:53  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.15.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 * Revision 1.15  1997/08/19  15:13:53  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.15.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 4
 * Revision 1.15  1997/08/19  15:13:53  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
@


1.14
log
@[Bug #1791]
MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
to avoid any binding problems
@
text
@d21 5
d253 1
a253 2
    result = allocate_record(4);
    MLTIME (result,time);
@


1.14.1.1
log
@branched from 1.14
@
text
@a20 5
 * Revision 1.14  1996/12/19  09:49:34  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
@


1.14.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 3
 * Revision 1.14.1.1  1997/05/12  10:41:28  hope
 * branched from 1.14
 *
@


1.14.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 3
 * Revision 1.14.1.1  1997/05/12  10:41:28  hope
 * branched from 1.14
 *
@


1.14.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 3
 * Revision 1.14.1.1  1997/05/12  10:41:28  hope
 * branched from 1.14
 *
@


1.14.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 * Revision 1.14.1.1.1.1  1997/07/28  18:25:26  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.13
log
@Changes to exceptions]
@
text
@d21 3
d133 7
a139 3
#define MLTIME(r,t)      {FIELD((r),0) = MLINT(SPLIT0(t)); \
                          FIELD((r),1) = MLINT(SPLIT1(t)); \
			  FIELD((r),2) = MLINT(SPLIT2(t));}
d153 5
a157 2
#define CTIME(r,t)      {(t).tv_sec =  JOINI(r); \
                         (t).tv_usec = CINT(FIELD(r,2));}
@


1.13.8.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.7.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.7.1.1.1
log
@branched from 1.13.7.1
@
text
@a20 3
 * Revision 1.13.7.1  1996/12/17  17:54:28  hope
 * branched from 1.13
 *
@


1.13.6.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.5.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.4.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.4.1.1.1
log
@branched from 1.13.4.1
@
text
@a20 3
 * Revision 1.13.4.1  1996/11/14  12:58:25  hope
 * branched from 1.13
 *
@


1.13.3.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.2.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.13.1.1
log
@branched from 1.13
@
text
@a20 3
 * Revision 1.13  1996/04/19  11:03:56  matthew
 * Changes to exceptions]
 *
@


1.12
log
@Fix implementation of tm_to_time
@
text
@d21 3
d450 1
a450 1
    exn_raise (perv_exn_ref_floor);
@


1.11
log
@ISPTR becomes MLVALISPTR
@
text
@d21 3
d220 9
a228 9
  time_val.tm_sec = CINT(FIELD(result, 0));
  time_val.tm_min = CINT(FIELD(result, 1));
  time_val.tm_hour = CINT(FIELD(result, 2));
  time_val.tm_mday = CINT(FIELD(result, 3));
  time_val.tm_mon = CINT(FIELD(result, 4));
  time_val.tm_year = CINT(FIELD(result, 5));
  time_val.tm_wday = CINT(FIELD(result, 6));
  time_val.tm_yday = CINT(FIELD(result, 7));
  time_val.tm_isdst = CINT(FIELD(result, 8));
@


1.10
log
@Changing ERROR to MLERROR
@
text
@d21 3
d331 1
a331 1
  if (ISPTR(FIELD(arg, 1))) {
@


1.9
log
@Add <sys/resource.h> since syscalls.h no longer pulls this in.
@
text
@d21 3
d304 1
a304 1
    return ERROR;
d315 1
a315 1
  if (result == ERROR)
@


1.8
log
@Add ml_time_microseconds.
@
text
@d21 3
d97 1
@


1.7
log
@Added ml_time_t.
@
text
@d21 3
d141 8
@


1.6
log
@Improve error message from set_time_modified
@
text
@d21 3
d140 10
a281 1
  struct timeval tv;
d290 2
a291 2
  tv.tv_sec = stbuf.st_mtime;
  tv.tv_usec = 0;		/* safe hack; see comment at head of file */
a292 3
  return(ml_time(&tv));
}
  
@


1.5
log
@Add interface to gmtime, localtime, mktime
@
text
@d21 3
d312 1
a312 1
    exn_raise_format(perv_exn_ref_io, "Cannot utime %s", path);
@


1.4
log
@Change time.h to mltime.h
@
text
@d21 3
d174 73
d639 3
@


1.3
log
@Fix overflowing integer computation in get_current_time
@
text
@d21 3
d85 1
a85 1
#include "time.h"
d223 1
a223 1
    mlval time_record = FIELD(FIELD(arg, 0), 1);
@


1.2
log
@Change ints to long ints.
@
text
@d21 3
d357 1
a357 1
  current_time.t_gc.tv_usec = gc_clock - (current_time.t_gc.tv_sec * 1000000);
@


1.1
log
@new file
@
text
@d20 4
a23 1
 *  $Log: src:OS:SunOS:time.c,v $
d463 1
a463 1
  int whole,frac,i;
@


1.1.1.1
log
@branched from 1.1
@
text
@d20 1
a20 4
 *  $Log: src:OS:Irix:time.c,v $
 * Revision 1.1  1994/07/12  12:40:48  jont
 * new file
 *
@
