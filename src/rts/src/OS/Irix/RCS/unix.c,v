head	1.8;
access;
symbols
	hope_poo:1.1.1
	ML_beta_release_12/08/94:1.1.1.1
	ML_beta_release_03/08/94:1.1;
locks; strict;
comment	@ * @;


1.8
date	96.01.26.11.43.48;	author stephenb;	state Exp;
branches;
next	1.7;

1.7
date	96.01.22.17.00.12;	author stephenb;	state Exp;
branches;
next	1.6;

1.6
date	95.09.19.14.54.45;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.05.11.13.36.05;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	95.05.10.17.04.35;	author daveb;	state Exp;
branches;
next	1.3;

1.3
date	94.12.09.16.23.43;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.19.17.09.46;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.41.17;	author jont;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.07.05.10.30.15;	author hope;	state Exp;
branches;
next	;


desc
@new file
@


1.8
log
@Modify unix_write so that it takes (fd, buff, offset, len).  This makes
it much more useful from the ML side.
@
text
@/*  ==== PERVASIVE UNIX FUNCTIONS ====
 *
 *  Copyright (C) 1993 Harlequin Ltd
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Irix:unix.c,v $
 * Revision 1.7  1996/01/22  17:00:12  stephenb
 * rename the Unix exceptions since they are no longer pervasive.
 *
 * Revision 1.6  1995/09/19  14:54:45  jont
 * Fix problems with C ordering of evaluation of function parameters
 * interaction with gc and C roots
 *
 * Revision 1.5  1995/05/11  13:36:05  daveb
 * Added missing #include.
 *
 * Revision 1.4  1995/05/10  17:04:35  daveb
 * Make the Unix exception take the string returned by perror instead
 * of the integer errno.
 * Added the stat, seek, can_input and set_block_mode functions.
 *
 * Revision 1.3  1994/12/09  16:23:43  jont
 * Change time.h to mltime.h
 *
 * Revision 1.2  1994/10/19  17:09:46  nickb
 * Put in casts to agree with prototypes.
 *
 * Revision 1.1  1994/07/12  12:41:17  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:27:16  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:51:46  nickh
 * new file
 *
 *  Revision 1.11  1994/02/08  14:40:39  matthew
 *  Added realpath function
 *
 *  Revision 1.10  1994/01/28  17:40:14  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.9  1993/11/12  16:54:13  nickh
 *  changed interface to ml_time values.
 *
 *  Revision 1.8  1993/08/27  19:29:54  daveb
 *  Added unix_unlink, unix_mkdir and unix_rmdir.
 *
 *  Revision 1.7  1993/08/25  10:26:51  richard
 *  Added kill function.
 *
 *  Revision 1.6  1993/06/22  11:18:29  richard
 *  Added system calls interfaces to opendir etc. (for opening and reading
 *  directories) and to getpwent etc. (for reading password database
 *  entries).  unix_password_file() should be removed later.
 *
 *  Revision 1.5  1993/06/10  14:27:20  richard
 *  Used the shared-memory semantics of vfork() to pass an error code
 *  from child to parent in the vfork_exec functions.
 *
 *  Revision 1.4  1993/05/06  14:47:43  jont
 *  Added fix to close password file when it's finished with
 *
 *  Revision 1.3  1993/05/05  17:27:26  jont
 *  Added a function to get the password file entries for translating
 *  filenames with ~ in them
 *
 *  Revision 1.2  1993/04/21  14:54:57  richard
 *  Removed defunct Editor interface and added sytem calls to enable
 *  its replacement.
 *
 *  Revision 1.1  1993/04/07  14:05:44  richard
 *  Initial revision
 *
 */

#include "unix.h"
#include "mltypes.h"
#include "values.h"
#include "allocator.h"
#include "gc.h"
#include "environment.h"
#include "global.h"
#include "mltime.h"
#include "utils.h"
#include "exceptions.h"

#define OPEN_MODE_ARGUMENT 1
#include "syscalls.h"

#include <errno.h>
#include <string.h>
#include <memory.h>
#include <stdlib.h>
#include <pwd.h>
#include <dirent.h>
#include <sys/filio.h>
#include <sys/errno.h>
#include <sys/types.h>
#include <sys/param.h>
#include <sys/errno.h>
#include <sys/time.h>
#include <sys/file.h>
#include <sys/un.h>
#include <netinet/in.h>
#include <unistd.h>
#include <fcntl.h>

static mlval unix_exn_ref_unix;
static mlval unix_exn_ref_would_block;

static mlval unix_af_unix;
static mlval unix_af_inet;
static mlval unix_sock_stream;
static mlval unix_sock_dgram;

#define SOCKADDR_BUFFER		sizeof(struct sockaddr_un)

static void unix_error (int i)
{
  exn_raise_string(unix_exn_ref_unix, sys_errlist[i]);
}

static int vfork(void)
{
  /* Only here because the SGI doesn't have vfork of its own */
  message("vfork unavailable, using fork instead\n");
  return fork();
}

static mlval unix_environment(mlval unit)
{
  static mlval result = DEAD;
  int i;

  if(result == DEAD)
  {
    result = MLNIL;
    declare_root(&result);

    for(i=0; environ[i] != NULL; ++i) {
      mlval poo = ml_string(environ[i]);
      /* Do not inline this function call */
      /* C is to stupid to realise that it should evaluate parameters */
      /* before building the arguments to a function */
      result = cons(poo, result);
    }
  }

  return(result);
}

static mlval unix_getwd(mlval unit)
{
  char buffer[MAXPATHLEN];
  char *result = getwd(buffer);

  if(result == NULL)
    exn_raise_string(perv_exn_ref_io, buffer);

  return(ml_string(buffer));
}

static mlval unix_realpath(mlval filename)
{
  char buffer[MAXPATHLEN];
  char *result = realpath(CSTRING(filename),buffer);

  if(result == NULL)
    exn_raise_string(perv_exn_ref_io, buffer);

  return(ml_string(buffer));
}

static mlval unix_setwd(mlval string)
{
  if(chdir(CSTRING(string)))
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_rusage(mlval unit)
{
  struct rusage ru;
  mlval utime, stime, result;

  if(getrusage(RUSAGE_SELF, &ru))
    unix_error (errno);

  result = allocate_record(16);

  utime = ml_time(&ru.ru_utime);
  stime = ml_time(&ru.ru_stime);

  /* Lexical ordering for fields -- the result is a record with name fields.
   *
   * idrss	integral resident set size
   * inblock	block input operations
   * isrss	currently 0
   * ixrss	currently 0
   * majflt	page faults requiring physical I/O
   * maxrss	maximum resident set size
   * minflt	page faults not requiring physical I/O
   * msgrcv	messages received
   * msgsnd	messages sent
   * nivcsw	involuntary context switches
   * nsignals	signals received
   * nswap	swaps voluntary
   * nvcsw	context switches
   * oublock	block output operations
   * stime	system time used
   * utime	user time used
   */

  FIELD(result,  0) = MLINT(ru.ru_idrss);
  FIELD(result,  1) = MLINT(ru.ru_inblock);
  FIELD(result,  2) = MLINT(ru.ru_isrss);
  FIELD(result,  3) = MLINT(ru.ru_ixrss);
  FIELD(result,  4) = MLINT(ru.ru_majflt);
  FIELD(result,  5) = MLINT(ru.ru_maxrss);
  FIELD(result,  6) = MLINT(ru.ru_minflt);
  FIELD(result,  7) = MLINT(ru.ru_msgrcv);
  FIELD(result,  8) = MLINT(ru.ru_msgsnd);
  FIELD(result,  9) = MLINT(ru.ru_nivcsw);
  FIELD(result, 10) = MLINT(ru.ru_nsignals);
  FIELD(result, 11) = MLINT(ru.ru_nswap);
  FIELD(result, 12) = MLINT(ru.ru_nvcsw);
  FIELD(result, 13) = MLINT(ru.ru_oublock);
  FIELD(result, 14) = stime;
  FIELD(result, 15) = utime;

  return(result);
}

static mlval unix_open(mlval arg)
{
  int fd = open(CSTRING(FIELD(arg, 0)),
		CINT(FIELD(arg, 1)),
		CINT(FIELD(arg, 2)));

  if(fd == -1)
    unix_error (errno);

  return(MLINT(fd));
}

static mlval unix_close(mlval arg)
{
  if(close(CINT(arg)) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_unlink(mlval arg)
{
  if(unlink(CSTRING(arg)) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_socket(mlval arg)
{
  int fd = socket(CINT(FIELD(arg, 0)),
		
		CINT(FIELD(arg, 1)),
		
		CINT(FIELD(arg, 2)));
  if(fd == -1)
    unix_error (errno);

  return(MLINT(fd));
}

static mlval unix_bind(mlval arg)
{
  size_t length;
  struct sockaddr_un un;

  length = strlen(CSTRING(FIELD(arg, 1)));
  if(length > sizeof(un.sun_path))
    unix_error (EINVAL);

  un.sun_family = AF_UNIX;
  memcpy(&un.sun_path, CSTRING(FIELD(arg, 1)), length);

  if(bind(CINT(FIELD(arg, 0)),
	  (struct sockaddr *)&un,
	  (int) (sizeof(un.sun_family)+length)) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_connect(mlval arg)
{
  size_t length;
  struct sockaddr_un un;

  length = strlen(CSTRING(FIELD(arg, 1)));
  if(length > sizeof(un.sun_path))
    unix_error (EINVAL);

  un.sun_family = AF_UNIX;
  memcpy(&un.sun_path, CSTRING(FIELD(arg, 1)), length);

  if(connect(CINT(FIELD(arg, 0)),
	    (struct sockaddr *)&un,
	    (int) (sizeof(un.sun_family)+length)) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_getsockname(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval result;
  size_t length;

  if(getsockname(CINT(arg), sa, &namelen))
    unix_error (errno);

  if(sa->sa_family != AF_UNIX)
    unix_error (EINVAL);

  length = namelen - sizeof(un->sun_family);
  result = allocate_string(length+1);
  memcpy(CSTRING(result), un->sun_path, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

static mlval unix_getpeername(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval result;
  size_t length;

  if(getpeername(CINT(arg), sa, &namelen))
    unix_error (errno);

  if(sa->sa_family != AF_UNIX)
    unix_error (EINVAL);

  length = namelen - sizeof(un->sun_family);
  result = allocate_string(length+1);
  memcpy(CSTRING(result), un->sun_path, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

static mlval unix_accept(mlval arg)
{
  char buffer[SOCKADDR_BUFFER];
  int namelen = SOCKADDR_BUFFER, s;
  struct sockaddr *sa = (struct sockaddr *)buffer;
  struct sockaddr_un *un = (struct sockaddr_un *)buffer;
  mlval ml_sockaddr, result;
  size_t length;

  s = accept(CINT(arg), sa, &namelen);

  if(s == -1)
    unix_error (errno);

  if(sa->sa_family != AF_UNIX)
    unix_error (EINVAL);

  length = namelen - sizeof(un->sun_family);
  ml_sockaddr = allocate_string(length+1);
  memcpy(CSTRING(ml_sockaddr), un->sun_path, length);
  CSTRING(ml_sockaddr)[length] = '\0';
  declare_root(&ml_sockaddr);
  result = allocate_record(2);
  FIELD(result, 0) = MLINT(s);
  FIELD(result, 1) = ml_sockaddr;
  retract_root(&ml_sockaddr);

  return(result);
}

static mlval unix_listen(mlval arg)
{
  if(listen(CINT(FIELD(arg, 0)), CINT(FIELD(arg, 1))))
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_write(mlval arg)
{
  int w = write(CINT(FIELD(arg, 0)),
		CSTRING(FIELD(arg, 1)) + CINT(FIELD(arg, 2)),
		CINT(FIELD(arg, 3)));

  if(w == -1)
    unix_error (errno);

  return(MLINT(w));
}

static mlval unix_seek(mlval arg)
{
  int fd = CINT(FIELD(arg, 0));
  int offset = CINT(FIELD(arg, 1));

  if (lseek (fd, SEEK_SET, offset) == -1)
    unix_error (errno);

  return (MLUNIT);
}

static mlval unix_set_block_mode (mlval arg)
{
  int flags;
  int fd = CINT(FIELD(arg, 0));
  int b = CINT(FIELD(arg, 1));

  flags = fcntl (fd, F_GETFL, 0);

  if (flags == -1)
    unix_error (errno);

  if (b == MLTRUE) {
    if (fcntl (fd, F_SETFL, O_NONBLOCK|flags))
      unix_error (errno);
  }
  else {
    if (fcntl (fd, F_SETFL, (~O_NONBLOCK)&flags))
      unix_error (errno);
  }

  return (MLUNIT);
}

static mlval unix_can_input (mlval arg)
{
  int fd = CINT(arg);
  long l;

  if (ioctl (fd, FIONREAD, (caddr_t)&l))
    unix_error (errno);

  return (MLINT (l));
}

static mlval unix_stat (mlval arg)
{
  struct stat st;
  mlval atime, ctime, mtime, result;
  int fd = CINT (arg);

  if (fstat (fd, &st))
    unix_error(errno);

  result = allocate_record(13);

  atime = ml_time_t(st.st_atime);
  ctime = ml_time_t(st.st_ctime);
  mtime = ml_time_t(st.st_mtime);

  /* Lexical ordering for fields -- the result is a record with name fields.
   *
   * atime      file last access time
   * blksize    preferred blocksize for file system I/O
   * blocks     actual number of blocks allocated
   * ctime      file last status change time
   * dev        device file resides on
   * gid        group ID of owner
   * ino        the file serial number
   * mode       file mode
   * mtime      file last modify time
   * nlink      number of hard links to the file
   * rdev       the device identifier (special files only)
   * size       total size of file, in bytes
   * uid        user ID of owner
   */

  FIELD(result,  0) = atime;
  FIELD(result,  1) = MLINT(st.st_blksize);
  FIELD(result,  2) = MLINT(st.st_blocks);
  FIELD(result,  3) = ctime;
  FIELD(result,  4) = MLINT(st.st_dev);
  FIELD(result,  5) = MLINT(st.st_gid);
  FIELD(result,  6) = MLINT(st.st_ino);
  FIELD(result,  7) = MLINT(st.st_mode);
  FIELD(result,  8) = mtime;
  FIELD(result,  9) = MLINT(st.st_nlink);
  FIELD(result, 10) = MLINT(st.st_rdev);
  FIELD(result, 11) = MLINT(st.st_size);
  FIELD(result, 12) = MLINT(st.st_uid);

  return(result);
}

static mlval unix_read(mlval arg)
{
  int length = CINT(FIELD(arg, 1));
  char *buffer = alloc((size_t) length, "unix_read"), *s;
  int r = read(CINT(FIELD(arg, 0)), buffer, (unsigned int)length);
  mlval string;

  if(r == -1)
  {
    int e = errno;
    free(buffer);
    unix_error (e);
  }

  string = allocate_string((size_t) (r+1));
  s = CSTRING(string);
  memcpy(s, buffer, (size_t) r);
  free(buffer);
  s[r] = '\0';

  return(string);
}

static char **list_to_array(mlval list)
{
  size_t i;
  mlval l;
  char **array;

  i = 0;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    ++i;

  array = alloc(sizeof(char *)*(i+1), "list_to_array");

  i = 0;
  for(l=list; l!=MLNIL; l=MLTAIL(l))
    array[i++] = CSTRING(MLHEAD(l));
  array[i] = NULL;

  return(array);
}

static mlval unix_execve(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  char **envp = list_to_array(FIELD(arg, 2));
  int e;

  execve(CSTRING(FIELD(arg, 0)), argv, envp);

  e = errno;

  free(argv);
  free(envp);

  unix_error (errno);
  return MLUNIT; /* NOT REACHED */
}
  
static mlval unix_execv(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  int e;

  execv(CSTRING(FIELD(arg, 0)), argv);

  e = errno;

  free(argv);

  unix_error (errno);
  return MLUNIT; /* NOT REACHED */
}
  
static mlval unix_execvp(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  int e;

  execvp(CSTRING(FIELD(arg, 0)), argv);

  e = errno;

  free(argv);

  unix_error (errno);
  return MLUNIT; /* NOT REACHED */
}
  
static mlval unix_vfork_execve(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  char **envp = list_to_array(FIELD(arg, 2));
  int e, pid;
  volatile int exec_errno = 0;

  pid = vfork();

  if(pid == 0)
  {
    execve(CSTRING(FIELD(arg, 0)), argv, envp);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);
  free(envp);

  if(pid == -1)
    unix_error (e);
  if(exec_errno != 0)
    unix_error (exec_errno);

  return(MLINT(pid));
}

static mlval unix_vfork_execv(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  int e, pid;
  volatile int exec_errno = 0;

  pid = vfork();

  if(pid == 0)
  {
    execv(CSTRING(FIELD(arg, 0)), argv);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);

  if(pid == -1)
    unix_error (e);
  if(exec_errno != 0)
    unix_error (exec_errno);


  return(MLINT(pid));
}

static mlval unix_vfork_execvp(mlval arg)
{
  char **argv = list_to_array(FIELD(arg, 1));
  int e, pid;
  volatile int exec_errno = 0;

  pid = vfork();

  if(pid == 0)
  {
    execvp(CSTRING(FIELD(arg, 0)), argv);
    exec_errno = errno;
    _exit(-1);			/* only reached on error */
  }

  e = errno;
  free(argv);

  if(pid == -1)
    unix_error (e);
  if(exec_errno != 0)
    unix_error (exec_errno);

  return(MLINT(pid));
}

static mlval ml_passwd(struct passwd *pw)
{
  mlval name, passwd, gecos, dir, shell, result;

  /* Lexical ordering of passwd structure fields:
   *
   * dir
   * gecos
   * gid
   * name
   * passwd
   * shell
   * uid
   */

  name = ml_string(pw->pw_name);
  declare_root(&name);
  passwd = ml_string(pw->pw_passwd);
  declare_root(&passwd);
  gecos = ml_string(pw->pw_gecos);
  declare_root(&gecos);
  dir = ml_string(pw->pw_dir);
  declare_root(&dir);
  shell = ml_string(pw->pw_shell);
  declare_root(&shell);
  result = allocate_record(7);
  FIELD(result, 0) = dir;
  FIELD(result, 1) = gecos;
  FIELD(result, 2) = MLINT(pw->pw_gid);
  FIELD(result, 3) = name;
  FIELD(result, 4) = passwd;
  FIELD(result, 5) = shell;
  FIELD(result, 6) = MLINT(pw->pw_uid);
  retract_root(&shell);
  retract_root(&dir);
  retract_root(&gecos);
  retract_root(&passwd);
  retract_root(&name);

  return(result);
}

static mlval unix_getpwent(mlval arg)
{
  struct passwd *pw = getpwent();

  if(pw == NULL)
    unix_error (0);

  return(ml_passwd(pw));
}

static mlval unix_setpwent(mlval arg)
{
  setpwent();
  return(MLUNIT);
}

static mlval unix_endpwent(mlval arg)
{
  endpwent();
  return(MLUNIT);
}

static mlval unix_getpwuid(mlval arg)
{
  struct passwd *pw = getpwuid(CINT(arg));

  if(pw == NULL)
    unix_error (0);

  return(ml_passwd(pw));
}

static mlval unix_getpwnam(mlval arg)
{
  struct passwd *pw = getpwnam(CSTRING(arg));

  if(pw == NULL)
    unix_error (0);

  return(ml_passwd(pw));
}

static mlval unix_mkdir(mlval arg)
{
  if(mkdir(CSTRING(FIELD(arg, 0)),
	   CINT(FIELD(arg, 1))) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_rmdir(mlval arg)
{
  if(rmdir(CSTRING(arg)) == -1)
    unix_error (errno);

  return(MLUNIT);
}

static mlval unix_opendir(mlval arg)
{
  DIR *dir = opendir(CSTRING(arg));

  if(dir == NULL)
    unix_error (errno);

  return((mlval)dir);
}

static mlval unix_readdir(mlval arg)
{
  struct dirent *d;

  errno = 0;

  d = readdir((DIR *)arg);

  if(errno)
    unix_error (errno);

  if(d == NULL)			/* EOF */
    return(ml_string(""));	/* by analogy with lookahead */

  return(ml_string(d->d_name));
}

static mlval unix_closedir(mlval arg)
{
  if(closedir((DIR *)arg))
    unix_error (errno);

  return(MLUNIT);
}

static mlval password_file_result = DEAD;

static mlval unix_password_file(mlval arg)
{
  if (password_file_result == DEAD) {
    mlval result = MLNIL,
          str1 = MLNIL,
          str2 = MLNIL,
          pair = MLNIL;
    struct passwd *entry = getpwent();
    password_file_result = MLNIL;
    declare_root(&password_file_result);
    declare_root(&result);
    declare_root(&str1);
    declare_root(&str2);
    declare_root(&pair);
    while (entry != NULL) {
      str1 = ml_string(entry->pw_name);
      str2 = ml_string(entry->pw_dir);
      pair = allocate_record(2);
      FIELD(pair, 0) = str1;
      FIELD(pair, 1) = str2;
      result = cons(pair, result);
      entry = getpwent();
    };
    endpwent();
    retract_root(&result);
    retract_root(&str1);
    retract_root(&str2);
    retract_root(&pair);
    password_file_result = result;
  }
  return password_file_result;
}

static mlval unix_kill(mlval arg)
{
  if(kill(CINT(FIELD(arg, 0)), CINT(FIELD(arg, 1))))
    unix_error (errno);

  return(MLUNIT);
}

void unix_init(void)
{
  env_function("system os unix environment", unix_environment);
  env_function("system os unix getwd", unix_getwd);
  env_function("system os unix setwd", unix_setwd);
  env_function("system os unix realpath", unix_realpath);
  env_function("system os unix rusage", unix_rusage);
  env_function("system os unix open", unix_open);
  env_function("system os unix close", unix_close);
  env_function("system os unix unlink", unix_unlink);
  env_function("system os unix socket", unix_socket);
  env_function("system os unix bind", unix_bind);
  env_function("system os unix connect", unix_connect);
  env_function("system os unix read", unix_read);
  env_function("system os unix set block mode", unix_set_block_mode);
  env_function("system os unix can input", unix_can_input);
  env_function("system os unix seek", unix_seek);
  env_function("system os unix stat", unix_stat);
  env_function("system os unix write", unix_write);
  env_function("system os unix accept", unix_accept);
  env_function("system os unix listen", unix_listen);
  env_function("system os unix getsockname", unix_getsockname);
  env_function("system os unix getpeername", unix_getpeername);
  env_function("system os unix execve", unix_execve);
  env_function("system os unix execv", unix_execv);
  env_function("system os unix execvp", unix_execvp);
  env_function("system os unix vfork_execve", unix_vfork_execve);
  env_function("system os unix vfork_execv", unix_vfork_execv);
  env_function("system os unix vfork_execvp", unix_vfork_execvp);
  env_function("system os unix getpwent", unix_getpwent);
  env_function("system os unix setpwent", unix_setpwent);
  env_function("system os unix endpwent", unix_endpwent);
  env_function("system os unix getpwuid", unix_getpwuid);
  env_function("system os unix getpwnam", unix_getpwnam);
  env_function("system os unix rmdir", unix_rmdir);
  env_function("system os unix mkdir", unix_mkdir);
  env_function("system os unix opendir", unix_opendir);
  env_function("system os unix readdir", unix_readdir);
  env_function("system os unix closedir", unix_closedir);
  env_function("system os unix password_file", unix_password_file);
  env_function("system os unix kill", unix_kill);

  unix_af_unix= MLINT(AF_UNIX);
  env_value("system os unix af_unix", unix_af_unix);
  declare_global("system os unix af_unix", &unix_af_unix, NULL);

  unix_af_inet= MLINT(AF_INET);
  env_value("system os unix af_inet", unix_af_inet);
  declare_global("system os unix af_inet", &unix_af_inet, NULL);

  unix_sock_stream= MLINT(SOCK_STREAM);
  env_value("system os unix sock_stream", unix_sock_stream);
  declare_global("system os unix sock_stream", &unix_sock_stream, NULL);

  unix_sock_dgram= MLINT(SOCK_DGRAM);
  env_value("system os unix sock_dgram", unix_sock_dgram);
  declare_global("system os unix sock_dgram", &unix_sock_dgram, NULL);

  unix_exn_ref_unix = ref(exn_default);
  unix_exn_ref_would_block = ref(exn_default);
  env_value("system os unix exception Unix", unix_exn_ref_unix);
  env_value("system os unix exception Would Block", unix_exn_ref_would_block);
  declare_global("system os unix exception Unix", &unix_exn_ref_unix, NULL);
  declare_global
      ("system os unix exception Would Block", &unix_exn_ref_would_block, NULL);
}
@


1.7
log
@rename the Unix exceptions since they are no longer pervasive.
@
text
@d8 3
d113 5
d405 2
a406 2
		CSTRING(FIELD(arg, 1)),
		strlen(CSTRING(FIELD(arg, 1))));
d899 16
@


1.6
log
@Fix problems with C ordering of evaluation of function parameters
interaction with gc and C roots
@
text
@d8 4
d107 2
a108 3
static mlval perv_exn_ref_unix;
static mlval perv_exn_ref_not_unix;
static mlval perv_exn_ref_would_block;
d114 1
a114 1
  exn_raise_string(perv_exn_ref_unix, sys_errlist[i]);
d892 5
a896 8
  perv_exn_ref_unix = ref(exn_default);
  perv_exn_ref_not_unix = ref(exn_default);
  perv_exn_ref_would_block = ref(exn_default);
  env_value("exception Unix", perv_exn_ref_unix);
  env_value("exception NotUnix", perv_exn_ref_not_unix);
  env_value("exception Would Block", perv_exn_ref_would_block);
  declare_global("pervasive exception Unix", &perv_exn_ref_unix, NULL);
  declare_global("pervasive exception Not Unix", &perv_exn_ref_not_unix, NULL);
d898 1
a898 1
      ("pervasive exception Would Block", &perv_exn_ref_would_block, NULL);
@


1.5
log
@Added missing #include.
@
text
@d8 3
d131 7
a137 2
    for(i=0; environ[i] != NULL; ++i)
      result = cons(ml_string(environ[i]), result);
@


1.4
log
@Make the Unix exception take the string returned by perror instead
of the integer errno.
Added the stat, seek, can_input and set_block_mode functions.
@
text
@d8 5
d98 1
@


1.3
log
@Change time.h to mltime.h
@
text
@d8 3
d83 1
d96 1
d98 1
d100 4
a103 1
#define SOCKADDR_BUFFER		sizeof(struct sockaddr_un)
d154 1
a154 1
    exn_raise_int(perv_exn_ref_unix, errno);
d165 1
a165 1
    exn_raise_int(perv_exn_ref_unix, errno);
d167 2
a169 1
  declare_root(&utime);
a170 4
  declare_root(&stime);
  result = allocate_record(16);
  retract_root(&stime);
  retract_root(&utime);
d219 1
a219 1
    exn_raise_int(perv_exn_ref_unix, errno);
d227 1
a227 1
    exn_raise_int(perv_exn_ref_unix, errno);
d235 1
a235 1
    exn_raise_int(perv_exn_ref_unix, errno);
d248 1
a248 1
    exn_raise_int(perv_exn_ref_unix, errno);
d260 1
a260 1
    exn_raise_int(perv_exn_ref_unix, EINVAL);
d268 1
a268 1
    exn_raise_int(perv_exn_ref_unix, errno);
d280 1
a280 1
    exn_raise_int(perv_exn_ref_unix, EINVAL);
d288 1
a288 1
    exn_raise_int(perv_exn_ref_unix, errno);
d303 1
a303 1
    exn_raise_int(perv_exn_ref_unix, errno);
d306 1
a306 1
    exn_raise_int(perv_exn_ref_unix, EINVAL);
d326 1
a326 1
    exn_raise_int(perv_exn_ref_unix, errno);
d329 1
a329 1
    exn_raise_int(perv_exn_ref_unix, EINVAL);
d351 1
a351 1
    exn_raise_int(perv_exn_ref_unix, errno);
d354 1
a354 1
    exn_raise_int(perv_exn_ref_unix, EINVAL);
d372 1
a372 1
    exn_raise_int(perv_exn_ref_unix, errno);
d384 1
a384 1
    exn_raise_int(perv_exn_ref_unix, errno);
d389 94
d494 1
a494 1
    exn_raise_int(perv_exn_ref_unix, e);
d539 1
a539 1
  exn_raise_int(perv_exn_ref_unix, errno);
d554 1
a554 1
  exn_raise_int(perv_exn_ref_unix, errno);
d569 1
a569 1
  exn_raise_int(perv_exn_ref_unix, errno);
d594 1
a594 1
    exn_raise_int(perv_exn_ref_unix, e);
d596 1
a596 1
    exn_raise_int(perv_exn_ref_unix, exec_errno);
d620 1
a620 1
    exn_raise_int(perv_exn_ref_unix, e);
d622 1
a622 1
    exn_raise_int(perv_exn_ref_unix, exec_errno);
d647 1
a647 1
    exn_raise_int(perv_exn_ref_unix, e);
d649 1
a649 1
    exn_raise_int(perv_exn_ref_unix, exec_errno);
d701 1
a701 1
    exn_raise_int(perv_exn_ref_unix, 0);
d723 1
a723 1
    exn_raise_int(perv_exn_ref_unix, 0);
d733 1
a733 1
    exn_raise_int(perv_exn_ref_unix, 0);
d742 1
a742 1
    exn_raise_int(perv_exn_ref_unix, errno);
d750 1
a750 1
    exn_raise_int(perv_exn_ref_unix, errno);
d760 1
a760 1
    exn_raise_int(perv_exn_ref_unix, errno);
d774 1
a774 1
    exn_raise_int(perv_exn_ref_unix, errno);
d785 1
a785 1
    exn_raise_int(perv_exn_ref_unix, errno);
d828 1
a828 1
    exn_raise_int(perv_exn_ref_unix, errno);
d847 4
d877 1
d880 1
d883 2
@


1.2
log
@Put in casts to agree with prototypes.
@
text
@d8 3
d67 1
a67 1
#include "time.h"
d91 2
d772 1
d774 1
d776 1
@


1.1
log
@new file
@
text
@d7 4
a10 1
 *  $Log: src:OS:SunOS:unix.c,v $
d82 1
d85 1
d255 2
a256 2
	 (struct sockaddr *)&un,
	 sizeof(un.sun_family)+length) == -1)
d276 1
a276 1
	    sizeof(un.sun_family)+length) == -1)
d382 1
a382 1
  int r = read(CINT(FIELD(arg, 0)), buffer, length);
@


1.1.1.1
log
@branched from 1.1
@
text
@d7 1
a7 4
 *  $Log: src:OS:Irix:unix.c,v $
 * Revision 1.1  1994/07/12  12:41:17  jont
 * new file
 *
@
