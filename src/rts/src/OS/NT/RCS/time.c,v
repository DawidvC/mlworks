head	1.21;
access;
symbols
	MLW_daveb_inline_1_4_99:1.21.1
	MLWorks_21c0_1999_03_25:1.21
	MLWorks_20c1_1998_08_20:1.21
	MLWorks_20c0_1998_08_04:1.21
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.21
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_MM_adapt:1.19.4
	MLWorks_20m1_1997_10_23:1.19
	MLWorks_11r1:1.19.1.1.1.1.1
	MLWorks_workspace_97:1.19.3
	MLWorks_dt_wizard:1.19.2
	MLWorks_11c0_1997_09_09:1.19.1.1.1.1
	MLWorks_10r3:1.19.1.1.3
	MLWorks_10r2_551:1.19.1.1.2
	MLWorks_11:1.19.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.1.1
	MLWorks_20m0_1997_06_20:1.19
	MLWorks_1_0_r2c2_1997_06_14:1.19.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.1
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MM_ML_release_korma_1997_04_01:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.5.1.1
	MLWorks_gui_1996_12_18:1.17.6
	MLWorks_1_0_Win32_1996_12_17:1.17.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.2.1
	JFHrts:1.17.4
	MLWorks_1_0_Irix_1996_11_28:1.17.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.3
	MLWorks_1_0_Unix_1996_11_14:1.17.2
	MLWorks_Open_Beta2_1996_10_11:1.17.1
	MLWorks_License_dev:1.16.2
	MLWorks_1_open_beta_1996_09_13:1.16.1
	MLWorks_Open_Beta_1996_08_22:1.14
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.13
	MLWorks_Beta_1996_06_06:1.13
	MLWorks_Beta_1996_06_05:1.13
	MLWorks_Beta_1996_06_03:1.13
	MLWorks_Beta_1996_05_31:1.13
	MLWorks_Beta_1996_05_30:1.13;
locks; strict;
comment	@ * @;


1.21
date	97.11.18.09.24.59;	author jont;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	97.11.07.17.08.01;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	97.03.14.10.34.49;	author johnh;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1;
next	1.18;

1.18
date	96.12.19.09.52.02;	author stephenb;	state Exp;
branches;
next	1.17;

1.17
date	96.10.07.17.03.38;	author jont;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1;
next	1.16;

1.16
date	96.09.09.17.55.04;	author jont;	state Exp;
branches
	1.16.1.1
	1.16.2.1;
next	1.15;

1.15
date	96.08.22.13.29.10;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	96.08.07.17.06.09;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	96.04.19.11.05.49;	author matthew;	state Exp;
branches;
next	1.12;

1.12
date	96.03.01.11.02.59;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	96.02.14.17.37.01;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.02.14.16.09.17;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	96.02.13.18.10.16;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	95.08.02.14.52.01;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.07.17.15.47.47;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.05.02.16.50.23;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	95.03.15.18.11.39;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	95.02.07.12.05.25;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	95.01.19.12.51.16;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.01.18.17.20.25;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.12.12.14.27.40;	author jont;	state Exp;
branches;
next	;

1.16.1.1
date	96.09.13.11.25.27;	author hope;	state Exp;
branches;
next	1.16.1.2;

1.16.1.2
date	96.10.07.10.51.09;	author jont;	state Exp;
branches;
next	;

1.16.2.1
date	96.10.07.16.15.51;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.17.11.35.17;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.11.14.13.00.56;	author hope;	state Exp;
branches
	1.17.2.1.1.1;
next	;

1.17.2.1.1.1
date	96.11.28.15.10.59;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.11.22.18.18.47;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.12.17.10.05.30;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	96.12.17.17.57.04;	author hope;	state Exp;
branches
	1.17.5.1.1.1;
next	;

1.17.5.1.1.1
date	97.02.24.11.48.44;	author hope;	state Exp;
branches;
next	;

1.17.6.1
date	96.12.18.09.51.43;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	97.05.12.10.45.26;	author hope;	state Exp;
branches
	1.19.1.1.1.1
	1.19.1.1.2.1
	1.19.1.1.3.1;
next	;

1.19.1.1.1.1
date	97.07.28.18.29.46;	author daveb;	state Exp;
branches
	1.19.1.1.1.1.1.1;
next	;

1.19.1.1.1.1.1.1
date	97.10.07.11.55.35;	author jkbrook;	state Exp;
branches;
next	;

1.19.1.1.2.1
date	97.09.08.17.22.44;	author daveb;	state Exp;
branches;
next	;

1.19.1.1.3.1
date	97.09.09.14.18.48;	author daveb;	state Exp;
branches;
next	;

1.19.2.1
date	97.09.10.19.38.21;	author brucem;	state Exp;
branches;
next	;

1.19.3.1
date	97.09.11.21.06.02;	author daveb;	state Exp;
branches;
next	;

1.19.4.1
date	97.10.31.13.49.06;	author nickb;	state Exp;
branches;
next	;

1.21.1.1
date	99.04.01.18.04.43;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.21
log
@[Bug #30089]
Remove stuff required by old MLWorks.Time
@
text
@/*  ==== PERVASIVE TIME ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 * Clock time and intervals are timeval pairs of integers (second,
 * microsecond), obtained from getrusage(2) and gettimeofday(2). File
 * modification times obtained from stat(2) get zero microseconds
 * (this appears unsafe, but actually is safe because stat(2) times
 * could be on a different machine in any case, so must only ever be
 * compared with each other, and not with now()).
 *
 * Times and intervals are represented to ML as triples of ints, a
 * pair for the seconds (each MLint taking 24 bits, allowing for
 * 48-bit values) and one for the microseconds.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:NT:time.c,v $
 * Revision 1.20  1997/11/07  17:08:01  jont
 * [Bug #30089]
 * Remove time_file_modified and time_set_file_modified
 *
 * Revision 1.19  1997/03/14  10:34:49  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
 * Revision 1.18  1996/12/19  09:52:02  stephenb
 * [Bug #1791]
 * MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
 * to avoid any binding problems
 *
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
 * Revision 1.16.1.2  1996/10/07  10:51:09  jont
 * Add ml_stat_sub for doing stuff common to ml_stat for Win95 and NT.
 * Includes stuff to deal with timezone variation problems on FAT
 *
 * Revision 1.16  1996/09/09  17:55:04  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
 * Revision 1.15  1996/08/22  13:29:10  jont
 * More problems with time stamp clamping
 *
 * Revision 1.14  1996/08/07  17:06:09  jont
 * Add time stamp clamping as per the Win95 so installation works properly
 *
 * Revision 1.13  1996/04/19  11:05:49  matthew
 * Renaming exceptions
 *
 * Revision 1.12  1996/03/01  11:02:59  jont
 * Add localtime, gmtime and mktime
 *
 * Revision 1.11  1996/02/14  17:37:01  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.10  1996/02/14  16:09:17  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.9  1996/02/13  18:10:16  jont
 * Add some type casts to allow compilation without warnings under VC++
 *
 * Revision 1.8  1995/08/02  14:52:01  jont
 * Rearrange to get rid of compiler errors
 *
 * Revision 1.7  1995/07/17  15:47:47  nickb
 * Add ml_time_microseconds()
 *
 * Revision 1.6  1995/05/02  16:50:23  jont
 * Improve error message from set_time_modified
 *
 * Revision 1.5  1995/03/15  18:11:39  jont
 * Fix problem with the use of FindFirstFile and GetFileTime
 *
 * Revision 1.4  1995/02/07  12:05:25  jont
 * Remove manifest floating point constants in favour of type casts
 *
 * Revision 1.3  1995/01/19  12:51:16  jont
 * Fix decoding of timestamps to be same order as encoding
 *
 * Revision 1.2  1995/01/18  17:20:25  jont
 * Fix timings function bugs (negative and wrong order of magnitude answers)
 * Modified user_time to divide by 10 instead of multiply by 10
 *
 * Revision 1.1  1994/12/12  14:27:40  jont
 * new file
 *
 * Revision 1.2  1994/11/09  11:13:19  jont
 * Fix overflowing integer computation in get_current_time
 *
 * Revision 1.1  1994/10/04  16:29:22  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:27:56  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:52:22  nickh
 * new file
 *
 *  Revision 1.11  1994/03/30  14:57:28  daveb
 *  Revised set_file_modified to take a datatype.
 *
 *  Revision 1.10  1994/03/30  13:49:43  daveb
 *  Added set_file_modified.
 *
 *  Revision 1.9  1994/01/28  17:40:03  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.8  1993/11/23  17:40:25  jont
 *  Exposed the encode and decode time functions for runtime consistency checking
 *  Increased the size of the marshalling buffer to the required size
 *
 *  Revision 1.7  1993/11/17  12:23:56  nickh
 *  Runtime support for new pervasive time structure.
 *  (radical change).
 *
 *  Revision 1.6  1993/06/02  13:10:08  richard
 *  Removed unused variable.
 *
 *  Revision 1.5  1993/04/26  11:50:51  richard
 *  Increased diagnostic levels.
 *
 *  Revision 1.4  1993/02/01  16:04:34  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.3  1992/12/23  13:57:43  richard
 *  Fixed the use of strftime in the case where the format string is empty.
 *
 *  Revision 1.2  1992/11/09  11:58:46  richard
 *  Corrected some missing initialisation.
 *
 *  Revision 1.1  1992/11/03  14:17:17  richard
 *  Initial revision
 *
 */

#include <windows.h> /* FILETIME */

#include "utils.h"
#include "mltypes.h"
#include "time_date.h"

#define DEBUG_TIMES 0

/*  user_clock() is like clock(3) except that it returns only the user
 *  virtual time elapsed.
 */

extern void time_init(void)
{
}

extern double user_clock(void)
{
  FILETIME creation, death, kernel, user;

  double foo1, foo2;
  if((GetProcessTimes(GetCurrentProcess(), &creation, &death, &kernel, &user)) != TRUE)
    error("Unable to read resource consumption.  "
	  "GetProcessTimes() set errno to %d.", GetLastError());

  foo1 = (double)user.dwLowDateTime;
  foo2 = (double)user.dwHighDateTime;

  foo1 = foo1 / (double)10;
  foo2 = (foo2 * two_to_32) / (double)10;
  return ((double)user.dwLowDateTime / (double)10
	  + ((double) user.dwHighDateTime * two_to_32) / (double)10);
}
@


1.21.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a20 4
 * Revision 1.21  1997/11/18  09:24:59  jont
 * [Bug #30089]
 * Remove stuff required by old MLWorks.Time
 *
@


1.20
log
@[Bug #30089]
Remove time_file_modified and time_set_file_modified
@
text
@d21 4
d140 1
a140 6
#include <limits.h>
#include <time.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <sys/stat.h>
a141 3
#include "ansi.h"
#include "syscalls.h"
#include "mltime.h"
a142 1
#include "allocator.h"
a143 6
#include "values.h"
#include "environment.h"
#include "exceptions.h"
#include "diagnostic.h"
#include "marshal.h"
#include "gc.h"
a144 376
#include "time_zone.h"

/* Converting C time values to an ML value */

#define SPLIT0(t)	((unsigned long)((t).dwHighDateTime) & 0xFFFFFF)
#define SPLIT1(t)	(((unsigned long)((t).dwHighDateTime) >> 24))
#define SPLIT2(t)       ((t).dwLowDateTime >> 2)


#define MLTIME(r,t)                  \
  do {                               \
    FIELD((r),0) = MLINT(SPLIT0(t)); \
    FIELD((r),1) = MLINT(SPLIT1(t)); \
    FIELD((r),2) = MLINT(SPLIT2(t)); \
  } while (0)


/* Converting an ML value to a C time value */

#define JOIN0(t0)       ((unsigned long) (t0))
#define JOIN1(t1)       (((unsigned long) (t1)) << 24)

#define JOIN(t0,t1)	(JOIN0(t0) | JOIN1(t1))

#define JOINI(r)        (JOIN(CINT(FIELD((r),0)), \
                              CINT(FIELD((r),1))))

/* CTIME should be used with care */

#define CTIME(r,t)                               \
  do {                                           \
    (t).dwHighDateTime =  JOINI(r);              \
    (t).dwLowDateTime = (CINT(FIELD(r,2))) << 2; \
  } while (0)


inline mlval ml_time(FILETIME *t)
{
  mlval result = allocate_record(3);

  MLTIME (result,*t);

  return(result);
}

static mlval time_now(mlval unit)
{
  SYSTEMTIME t;
  FILETIME ft;

  GetLocalTime(&t);
  if (!SystemTimeToFileTime(&t, &ft))
    error("Unable to read time of day.  "
	  "SystemTimeToFileTime() set errno to %d.", GetLastError());
  return (ml_time(&ft));
}

static mlval time_format(mlval argument)
{
  mlval result = MLUNIT;
  mlval time_record = FIELD(argument, 2);
  char *format = CSTRING(FIELD(argument, 0));
  time_t t = JOINI(time_record);
  struct tm *timeptr = CINT(FIELD(argument, 1)) ? localtime(&t) : gmtime(&t);
  size_t size;

  if(strlen(format) == 0)
    return(ml_string(""));
  
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, timeptr);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
    }

    free(buffer);
  }

  result = allocate_string(1);
  CSTRING(result)[0] = '\0';
  return(result);
}

static mlval tm_to_time(mlval argument)
{
  /* Interface to mktime. Returns a time_t suitably split up for ml */
  mlval result = MLUNIT;
  struct tm time_val;
  time_t t;
  time_val.tm_sec = CINT(FIELD(argument, 0));
  time_val.tm_min = CINT(FIELD(argument, 1));
  time_val.tm_hour = CINT(FIELD(argument, 2));
  time_val.tm_mday = CINT(FIELD(argument, 3));
  time_val.tm_mon = CINT(FIELD(argument, 4));
  time_val.tm_year = CINT(FIELD(argument, 5));
  time_val.tm_wday = CINT(FIELD(argument, 6));
  time_val.tm_yday = CINT(FIELD(argument, 7));
  time_val.tm_isdst = CINT(FIELD(argument, 8));
  if ((t = mktime(&time_val)) == (time_t)-1) {
    exn_raise_string(perv_exn_ref_io, "tm_to_time:invalid tm");
  } else {
    FILETIME time;
    time.dwHighDateTime = t;
    time.dwLowDateTime = 0;
    result = allocate_record(3);
    MLTIME(result, time);
  }
  return result;
}

static mlval gmtime_to_tm(mlval argument)
{
  /* interface to gmtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = gmtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "gmtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

static mlval localtime_to_tm(mlval argument)
{
  /* interface to localtime. Returns an ml version of a struct tm */
  mlval result = MLUNIT;
  time_t t = JOINI(argument);  /* Convert argument to a time_t */
  struct tm *time_ptr;
  if ((time_ptr = localtime(&t)) == NULL) {
    exn_raise_string(perv_exn_ref_io, "localtime_to_tm:invalid Time.time");
  } else {
    result = allocate_record(9);
    FIELD(result, 0) = MLINT(time_ptr->tm_hour);
    FIELD(result, 1) = MLINT(time_ptr->tm_isdst);
    FIELD(result, 2) = MLINT(time_ptr->tm_mday);
    FIELD(result, 3) = MLINT(time_ptr->tm_min);
    FIELD(result, 4) = MLINT(time_ptr->tm_mon);
    FIELD(result, 5) = MLINT(time_ptr->tm_sec);
    FIELD(result, 6) = MLINT(time_ptr->tm_wday);
    FIELD(result, 7) = MLINT(time_ptr->tm_yday);
    FIELD(result, 8) = MLINT(time_ptr->tm_year);
  };
  return result;
}

/* Are two ML time values equal? Use this to abstract the ML time type
 * from the loader */

extern int ml_time_eq(mlval t1, mlval t2)
{
  mlval *time1 = CPTR(t1);
  mlval *time2 = CPTR(t2);

  if (memcmp(time1, time2, 3*sizeof(mlval)))
    return 0;
  else return 1;
}

extern mlval ml_time_microseconds(double t)
{
  FILETIME tv;
  tv.dwHighDateTime = (unsigned long)(t * 10.0 / two_to_32);
  tv.dwLowDateTime = (unsigned long)(t * 10.0 - ((double)tv.dwHighDateTime * two_to_32));
  return (ml_time(&tv));
}

static mlval time_print(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  message("Printed time is %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
  return MLUNIT;
}

/* get the modified timestamp of a file as an ML value; use this in
 * the loader and also provide it to the ML environment */
inline mlval ml_stat(const char *filename)
{
  WIN32_FIND_DATA file_data;
  HANDLE file_handle;

  DIAGNOSTIC(2, "stat(\"%s\")", filename, 0);

  file_handle = FindFirstFile(filename, &file_data);

  if (file_handle == INVALID_HANDLE_VALUE) {
    DIAGNOSTIC(2, "FindFirstFile returns INVALID_HANDLE_VALUE for %s, last error was 0x%x", filename, GetLastError());
    return MLERROR;
  }

  (void)ml_stat_sub(filename, &file_data.ftLastWriteTime);

  return ml_time(&file_data.ftLastWriteTime);
}

static mlval time_less(mlval arg)
{
  FILETIME t1, t2;
  mlval time_record1 = FIELD(arg, 0);
  mlval time_record2 = FIELD(arg, 1);

  CTIME(time_record1, t1);
  CTIME(time_record2, t2);

  return(((t1.dwHighDateTime < t2.dwHighDateTime) 
	  || ((t1.dwHighDateTime == t2.dwHighDateTime) && (t1.dwLowDateTime < t2.dwLowDateTime))) 
	 ? MLTRUE : MLFALSE);
}

mlval time_encode(mlval arg)
{
  char buffer[2*MARSHAL_SIZE_LONG], *end;
  FILETIME t;
  size_t length;
  mlval result;

  CTIME(arg,t);

  end = marshal(buffer, "ll", t.dwHighDateTime,t.dwLowDateTime);

  length = end - buffer;

  result = allocate_string(length+1);
  memcpy(CSTRING(result), buffer, length);
  CSTRING(result)[length] = '\0';

  return(result);
}

mlval time_decode(mlval arg)
{
  FILETIME t;

  unmarshal(CSTRING(arg), "ll", &t.dwHighDateTime, &t.dwLowDateTime);

  return(ml_time(&t));

}

static void timeval_sub (FILETIME *t1,
			 FILETIME *t2,
			 FILETIME *result)
{
  unsigned long a = (unsigned long)t1->dwLowDateTime;
  unsigned long b = (unsigned long)t2->dwLowDateTime;
  result->dwHighDateTime  = t1->dwHighDateTime  - t2->dwHighDateTime;
  result->dwLowDateTime = t1->dwLowDateTime - t2->dwLowDateTime;
  /* Now sort out extended overflow */
  if (a < b) result->dwHighDateTime -= 1;
}

static void timeval_add (FILETIME *t1,
			 FILETIME *t2,
			 FILETIME *result)
{
  unsigned long a = (unsigned long)t1->dwLowDateTime;
  result->dwHighDateTime  = t1->dwHighDateTime  + t2->dwHighDateTime;
  result->dwLowDateTime = t1->dwLowDateTime + t2->dwLowDateTime;
  /* Now sort out extended overflow */
  if (a < (unsigned long)result->dwLowDateTime) result->dwHighDateTime += 1;
}

static mlval interval_to_real (mlval arg)
{
  mlval result;
  FILETIME t;
  double tm;

  CTIME (arg,t);

  result = allocate_real();

  tm = (t.dwHighDateTime * two_to_32 + t.dwLowDateTime) / ((double)mlw_time_ticks_per_sec);

  (void) SETREAL(result,tm);
  return result;
}

static mlval interval_from_real (mlval arg)
{
  FILETIME t;
  double tm = GETREAL(arg);
  double foo = tm * ((double)mlw_time_ticks_per_sec);
  if (tm > LONG_MAX || tm < LONG_MIN) {
    exn_raise (perv_exn_ref_overflow);
  }


  t.dwHighDateTime = (DWORD)(foo / two_to_32);
  t.dwLowDateTime = (DWORD)(foo - t.dwHighDateTime * two_to_32);

  return (ml_time (&t));
}


static FILETIME start_time;

static struct time_record {FILETIME t_user;
			   FILETIME t_sys;
			   FILETIME t_gc;
			   FILETIME t_real;
			 } current_time;

static inline void get_current_time (void)
{
  FILETIME creation, death, user;
  FILETIME t;
  DWORD time = GetTickCount();

  current_time.t_gc.dwHighDateTime = (DWORD)((gc_clock * 10) / two_to_32);
  current_time.t_gc.dwLowDateTime =
    (DWORD)(gc_clock * 10 - ((double)current_time.t_gc.dwHighDateTime * two_to_32));
  if((GetProcessTimes(GetCurrentProcess(), &creation, &death, &current_time.t_sys, &user)) != TRUE)
    error("Unable to read resource consumption.  "
	  "GetProcessTimes() set errno to %d.", GetLastError());

  timeval_sub(&user, &current_time.t_gc, &current_time.t_user);

  t.dwHighDateTime = (DWORD)(((double)time * (double)10000) / two_to_32);
  t.dwLowDateTime = (DWORD)(((double)time * (double)10000) - t.dwHighDateTime * two_to_32);

  timeval_sub(&t, &start_time, &current_time.t_real);
}  

static inline mlval return_current_time (void)
{
  mlval result;
  mlval t_gc,t_real,t_sys,t_user;

  t_gc = ml_time(&current_time.t_gc);
  declare_root(&t_gc);
  t_real = ml_time(&current_time.t_real);
  declare_root(&t_real);
  t_user = ml_time(&current_time.t_user);
  declare_root(&t_user);
  t_sys = ml_time(&current_time.t_sys);   
  declare_root(&t_sys);

  result = allocate_record(4);

  /* field ordering alphabetic: gc, real, sys, user */

  FIELD(result,0) = t_gc;
  FIELD(result,1) = t_real;
  FIELD(result,2) = t_sys;
  FIELD(result,3) = t_user;

  retract_root(&t_gc);
  retract_root(&t_user);
  retract_root(&t_sys);
  retract_root(&t_real);

  return(result);
}

static mlval elapsed (mlval unit)
{
  get_current_time ();
  return (return_current_time());
}
d148 3
a150 38
static mlval elapsed_since (mlval arg)
{
  FILETIME t1;

  get_current_time();

  CTIME(FIELD(arg,0),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous gc time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current gc time set to %u, %u\n",
	  current_time.t_gc.dwHighDateTime, current_time.t_gc.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_gc, &t1, &current_time.t_gc);
  CTIME(FIELD(arg,1),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous real time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current real time set to %u, %u\n",
	  current_time.t_real.dwHighDateTime, current_time.t_real.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_real, &t1, &current_time.t_real);
  CTIME(FIELD(arg,2),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous system time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current system time set to %u, %u\n",
	  current_time.t_sys.dwHighDateTime, current_time.t_sys.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_sys, &t1, &current_time.t_sys);
  CTIME(FIELD(arg,3),t1);
#if DEBUG_TIMES
  fprintf(stderr, "Previous user time set to %u, %u\n",
	  t1.dwHighDateTime, t1.dwLowDateTime);
  fprintf(stderr, "Current user time set to %u, %u\n",
	  current_time.t_user.dwHighDateTime, current_time.t_user.dwLowDateTime);
#endif
  timeval_sub(&current_time.t_user, &t1, &current_time.t_user);
d152 1
a152 4
  return(return_current_time());
}

static mlval interval (mlval arg)
a153 7
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
a155 50

static mlval time_subtract (mlval arg)
{
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_sub (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_add (mlval arg)
{
  FILETIME t1, t2;

  CTIME(FIELD(arg,0),t1);
  CTIME(FIELD(arg,1),t2);
  timeval_add (&t1,&t2,&t1);

  return (ml_time(&t1));
}

static mlval time_to_string (mlval arg)
{
  FILETIME t;
  int digits = CINT(FIELD(arg,1));
  double the_time;
  char buffer[50];
  char *p = buffer;

  CTIME(FIELD(arg,0),t);

  /* Convert to seconds */
  the_time = (((double)t.dwHighDateTime) * two_to_32 + t.dwLowDateTime) / ((double)mlw_time_ticks_per_sec);

  /* give a maximum of 6 digits */

  if (digits > 6 || digits < 0)
    digits = 6;

  sprintf(p, "%.*f", digits, the_time);

  return (ml_string(buffer));
}

/*  user_clock() is like clock(3) except that it returns only the user
 *  virtual time elapsed.
 */

a171 46
}

extern void print_time(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  printf(" %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
}

void time_init()
{
  mlval zero;

  DWORD time = GetTickCount();
  /* get clock start time for elapsed record */
  start_time.dwHighDateTime = (DWORD)(((double)time * (double)10000) / two_to_32);
  start_time.dwLowDateTime = (DWORD)(((double)time * (double)10000) - start_time.dwHighDateTime * two_to_32);

  zero = allocate_record(4);
  FIELD(zero, 0) = MLINT(0);
  FIELD(zero, 1) = MLINT(0);
  FIELD(zero, 2) = MLINT(0);
  FIELD(zero, 3) = MLINT(0);

  env_value("time zero", zero);
  env_function("time now", time_now);
  env_function("time less", time_less);
  env_function("time add", time_add);
  env_function("time subtract", time_subtract);

  env_function("time encode", time_encode);
  env_function("time decode", time_decode);

  env_function("time to string",time_to_string);
  env_function("time format", time_format);
  env_function("time mktime", tm_to_time);
  env_function("time gmtime", gmtime_to_tm);
  env_function("time localtime", localtime_to_tm);

  env_function("time interval",interval);
  env_function("interval to real",interval_to_real);
  env_function("interval from real",interval_from_real);

  env_function("time elapsed",elapsed);
  env_function("time elapsed since",elapsed_since);
  env_function("time print", time_print);
@


1.19
log
@[Bug #1850]
Replacing FindFirstFile with CreateFile - see comments.
@
text
@d21 4
a366 55
static mlval time_file_modified(mlval arg)
{
  mlval result = ml_stat(CSTRING(arg));

  if (result == MLERROR)
    exn_raise_format(perv_exn_ref_io,
		     "Cannot mtime %s: does not exist",
		     CSTRING(arg));
  return result;
}

static mlval time_set_file_modified(mlval arg)
{
  FILETIME m_tv;
  HANDLE file_handle;

  char* path = CSTRING(FIELD(arg, 0));

  /* This call to CreateFile replaced a call to FindFirstFile which waas simpler,
     but the problem was that it returned the wrong type of file handle.  The
     file handle returned by calls to FindFirstFile and FindNextFile cannot be 
     used by SetFileTime.  File handles returned by FindFirstFile and FindNextFile
     should be used to find a list of files matching certain criteria, but if 
     any of the file attributes need to be changed, these file handles are of 
     no use since they do not have write access, and therefore the file handle
     returned by CreateFile is needed.  Also note that although the function is
     called CreateFile, in the case below it only opens existing files.  */

  if ((file_handle = CreateFile(path, GENERIC_WRITE, FILE_SHARE_WRITE, NULL, 
	OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE)
    exn_raise_format(perv_exn_ref_io, "Cannot SetFileTime %s", path);

  /*  datatype modtime = NOW | TIME of Time.time  */
  if (MLVALISPTR(FIELD(arg, 1))) {
    mlval time_record = FIELD(FIELD(arg, 1), 1);
    CTIME(time_record, m_tv);
  } else {
    SYSTEMTIME system_time;
    GetSystemTime(&system_time);
    if (SystemTimeToFileTime(&system_time, &m_tv) != TRUE)
      exn_raise_format(perv_exn_ref_io, "Cannot set time of %s", path);
  }

  DIAGNOSTIC(2, "real_set_file_modified(\"%s\"), modtime = %s",
	     path, MLVALISPTR(FIELD(arg, 1)) ? "user specified time" : "now");

  if(SetFileTime(file_handle, NULL, NULL, &m_tv) != TRUE)
    exn_raise_format(perv_exn_ref_io, "Cannot SetFileTime %s", path);

  if (CloseHandle(file_handle) == 0)
    exn_raise_format(perv_exn_ref_io, "Cannot CloseHandle");

  return MLUNIT;
}

a691 3

  env_function("time file modified", time_file_modified);
  env_function("time set file modified", time_set_file_modified);
@


1.19.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a20 4
 * Revision 1.19  1997/03/14  10:34:49  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.19.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a20 4
 * Revision 1.19  1997/03/14  10:34:49  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.19.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a20 4
 * Revision 1.19  1997/03/14  10:34:49  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a20 4
 * Revision 1.19  1997/03/14  10:34:49  johnh
 * [Bug #1850]
 * Replacing FindFirstFile with CreateFile - see comments.
 *
@


1.19.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a20 3
 * Revision 1.19.1.1  1997/05/12  10:45:26  hope
 * branched from 1.19
 *
@


1.19.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a20 3
 * Revision 1.19.1.1  1997/05/12  10:45:26  hope
 * branched from 1.19
 *
@


1.19.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a20 3
 * Revision 1.19.1.1  1997/05/12  10:45:26  hope
 * branched from 1.19
 *
@


1.19.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a20 3
 * Revision 1.19.1.1.1.1  1997/07/28  18:29:46  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.18
log
@[Bug #1791]
MLTIME+CTIME: wrap the macro bodies in do { ... } while (0)
to avoid any binding problems
@
text
@d21 5
a376 1
  WIN32_FIND_DATA file_data;
d381 12
a392 1
  if ((file_handle = FindFirstFile(path, &file_data)) == INVALID_HANDLE_VALUE)
d394 1
a394 1
  
d411 3
@


1.17
log
@Merging in beta updates
@
text
@d21 3
d155 8
a162 3
#define MLTIME(r,t)      {FIELD((r),0) = MLINT(SPLIT0(t)); \
                          FIELD((r),1) = MLINT(SPLIT1(t)); \
			  FIELD((r),2) = MLINT(SPLIT2(t));}
d176 5
a180 2
#define CTIME(r,t)      {(t).dwHighDateTime =  JOINI(r); \
                         (t).dwLowDateTime = (CINT(FIELD(r,2))) << 2;}
@


1.17.6.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.17.5.1.1.1
log
@branched from 1.17.5.1
@
text
@a20 3
 * Revision 1.17.5.1  1996/12/17  17:57:04  hope
 * branched from 1.17
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.17.2.1.1.1
log
@branched from 1.17.2.1
@
text
@a20 3
 * Revision 1.17.2.1  1996/11/14  13:00:56  hope
 * branched from 1.17
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a20 3
 * Revision 1.17  1996/10/07  17:03:38  jont
 * Merging in beta updates
 *
@


1.16
log
@Remove use of ten_million in favour of mlw_ticks_per_sec
Move two_to_32 into time_date.h
@
text
@d21 8
d318 7
a324 1
#define double_time(t) (((double)t.dwHighDateTime * two_to_32) + ((double)t.dwLowDateTime))
a327 1

a331 3
  TIME_ZONE_INFORMATION tz;
  LONG bias;
  int res;
a334 8
  res = get_timezone(&tz);
  if (res) {
    bias = tz.Bias;
    if (bias != 0) {
      tz.Bias = 0;
      set_timezone(&tz);
    };
  }
a335 4
  if (res && (bias != 0)) {
    tz.Bias = bias;
    set_timezone(&tz);
  };
d341 4
a344 4
  
  DIAGNOSTIC(2, "  mtime = %lu, %lu", file_data.ftLastWriteTime.dwHighDateTime, file_data.ftLastWriteTime.dwLowDateTime);
  time_stamp_clamp(&(file_data.ftLastWriteTime));
  return(ml_time(&(file_data.ftLastWriteTime)));
d346 1
a346 1
  
d349 1
a349 1
  mlval result = ml_stat (CSTRING(arg));
d678 7
d724 1
a725 1
  
@


1.16.2.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/09  17:55:04  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
@


1.16.1.1
log
@branched from 1.16
@
text
@a20 4
 * Revision 1.16  1996/09/09  17:55:04  jont
 * Remove use of ten_million in favour of mlw_ticks_per_sec
 * Move two_to_32 into time_date.h
 *
@


1.16.1.2
log
@Add ml_stat_sub for doing stuff common to ml_stat for Win95 and NT.
Includes stuff to deal with timezone variation problems on FAT
@
text
@d314 1
a314 7
static mlval time_print(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  message("Printed time is %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
  return MLUNIT;
}
d318 1
d323 3
d329 8
d338 4
d347 4
a350 4

  (void)ml_stat_sub(filename, &file_data.ftLastWriteTime);

  return ml_time(&file_data.ftLastWriteTime);
d352 1
a352 1

d355 1
a355 1
  mlval result = ml_stat(CSTRING(arg));
a683 7
extern void print_time(mlval time)
{
  FILETIME f_time;
  CTIME(time, f_time);
  printf(" %lu, %lu, %f", f_time.dwHighDateTime, f_time.dwLowDateTime, double_time(f_time));
}

a722 1
  env_function("time print", time_print);
d724 1
@


1.15
log
@More problems with time stamp clamping
@
text
@d21 3
d136 1
a301 3
static double two_to_32 = (double)(1 << 16) * (double)(1 << 16);
static double ten_million = (double)10000000;

a309 29
/*
 * A function to clamp timestamps to one second because FAT
 * is too stupid to do any better. It turns out that InstallShield
 * rounds up to the nearest two seconds, so that's what we must do.
 */

#define ticks_per_two_secs (2*mlw_time_ticks_per_sec)

inline void time_stamp_clamp(FILETIME *t)
{
  DWORD hi = t->dwHighDateTime,
        lo = t->dwLowDateTime;
  unsigned long remainder = (((((((((((((hi % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 4) + lo % ticks_per_two_secs) % ticks_per_two_secs;
  /* The above horrible expression is done this way to ensure */
  /* that the modulus we calculate doesn't have an overflow in the middle */
  /* I'm not sure if it's necessary, but it's certainly sufficient! */
  if (remainder != 0) {
    /* Only round up if not an exact second */
    unsigned long up = ticks_per_two_secs - remainder;
    lo += up;
    if (lo < up) {
      /* Addition overflow */
      hi += 1;
    }
  }
  t->dwHighDateTime = hi;
  t-> dwLowDateTime = lo; /* And put the result back */
}

d319 3
d324 9
d334 4
d468 1
a468 1
  tm = (t.dwHighDateTime * two_to_32 + t.dwLowDateTime) / ten_million;
d478 1
a478 1
  double foo = tm * ten_million;
d646 1
a646 1
  the_time = (((double)t.dwHighDateTime) * two_to_32 + t.dwLowDateTime) / ten_million;
@


1.14
log
@Add time stamp clamping as per the Win95 so installation works properly
@
text
@d21 3
d321 1
a321 1
  unsigned long remainder = (((((((((hi % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) % ticks_per_two_secs) * 256) + lo % ticks_per_two_secs) % ticks_per_two_secs;
@


1.13
log
@Renaming exceptions
@
text
@d21 3
d129 1
d306 31
d354 1
a355 1

@


1.12
log
@Add localtime, gmtime and mktime
@
text
@d21 3
d454 1
a454 1
    exn_raise (perv_exn_ref_floor);
@


1.11
log
@ISPTR becomes MLVALISPTR
@
text
@d21 3
d202 73
a478 5

/*
  fprintf(stderr, "Current gc time set to %u, %u\n",
	  current_time.t_gc.dwHighDateTime, current_time.t_gc.dwLowDateTime);
*/
a482 2
  fprintf(stderr, "in get_current_time GetProcessTimes returns high = 0x%x, low = 0x%x\n",
	  user.dwHighDateTime, user.dwLowDateTime);
a488 4
/*
  fprintf(stderr, "Current real time set to %u, %u\n",
	  current_time.t_real.dwHighDateTime, current_time.t_real.dwLowDateTime);
*/
a641 4
/*
  fprintf(stderr, "in user_clock GetProcessTimes returns high = 0x%x, low = 0x%x\n",
	  user.dwHighDateTime, user.dwLowDateTime);
*/
a643 11
/*
  fprintf(stderr, "in user_clock GetProcessTimes returns high = %g, low = %g\n",
	  foo2, foo1);
  fprintf(stderr, "in user_clock two_to_32 = %g, foo2 * two_to_32 = %g\n",
	  two_to_32, foo2 * two_to_32);
  fprintf(stderr, "in user_clock foo1 / 10.0 = %g, (foo2 * two_to_32) / 10.0 = %g\n",
	  foo1 / 10.0, (foo2 * two_to_32) / 10.0);

  fprintf(stderr, "in user_clock foo1 / (double)10 = %g, (foo2 * two_to_32) / (double)10 = %g\n",
	  foo1 / (double)10, (foo2 * two_to_32) / (double)10);
*/
a646 3
/*
  fprintf(stderr, "Returning %g + %g = %g\n", foo1, foo2, foo1 + foo2);
*/
a648 4
/*
  return foo1 / (double)10 + (foo2 * two_to_32) / (double)10;
  return foo1 + foo2;
*/
d677 3
@


1.10
log
@Changing ERROR to MLERROR
@
text
@d21 3
d267 1
a267 1
  if (ISPTR(FIELD(arg, 1))) {
d278 1
a278 1
	     path, ISPTR(FIELD(arg, 1)) ? "user specified time" : "now");
@


1.9
log
@Add some type casts to allow compilation without warnings under VC++
@
text
@d21 3
d233 1
a233 1
    return ERROR;
d245 1
a245 1
  if (result == ERROR)
@


1.8
log
@Rearrange to get rid of compiler errors
@
text
@d21 3
d212 2
a213 2
  tv.dwHighDateTime = t * 10.0 / two_to_32;
  tv.dwLowDateTime = t * 10.0 - ((double)tv.dwHighDateTime * two_to_32);
@


1.7
log
@Add ml_time_microseconds()
@
text
@d21 3
a146 8
extern mlval ml_time_microseconds(double t)
{
  FILETIME tv;
  tv.dwHighDateTime = t * 10.0 / two_to_32;
  tv.dwLowDateTime = t * 10.0 - ((double)tv.dwHighDateTime * two_to_32);
  return (ml_time(&tv));
}

d206 8
a218 2
#if 1 /* Doesn't seem to work */
  /* Works now that I understand the documentation a bit better */
a229 6
/*
  if (GetFileTime(file_handle, &c_tv, &a_tv, &m_tv) != TRUE) {
    DIAGNOSTIC(2, "GetFileTime returns FALSE for %s, last error was 0x%X", filename, GetLastError());
    return ERROR;
  }
*/
a232 16
#else
  FILETIME m_tv, a_tv, c_tv;
  struct _stat stbuf;
  DIAGNOSTIC(2, "stat(\"%s\")", filename, 0);
  
  if (stat (filename, &stbuf) == -1)
    return ERROR;

  DIAGNOSTIC(2, "  mtime = %lu", stbuf.st_mtime, 0);

  m_tv.dwHighDateTime = (DWORD)(((double)stbuf.st_mtime * ten_million) / two_to_32);
  m_tv.dwLowDateTime =
    (DWORD)(((double)stbuf.st_mtime * ten_million) - m_tv.dwHighDateTime * two_to_32);

  return(ml_time(&m_tv));
#endif
@


1.6
log
@Improve error message from set_time_modified
@
text
@d21 3
d142 8
@


1.5
log
@Fix problem with the use of FindFirstFile and GetFileTime
@
text
@d21 3
d275 1
a275 1
      exn_raise_format(perv_exn_ref_io, "Cannot SetFileTime %s", path);
@


1.4
log
@Remove manifest floating point constants in favour of type casts
@
text
@d21 3
d202 2
a203 2
  FILETIME m_tv, a_tv, c_tv;
#if 0 /* Doesn't seem to work */
d215 1
d220 3
a222 2

  DIAGNOSTIC(2, "  mtime = %lu, %lu", m_tv.dwHighDateTime, m_tv.dwLowDateTime);
d225 1
d238 1
a239 1
  return(ml_time(&m_tv));
@


1.3
log
@Fix decoding of timestamps to be same order as encoding
@
text
@d21 3
d192 1
a192 1
static double ten_million = 10000000.0;
d220 1
a220 1
  struct stat stbuf;
d404 2
d408 2
a409 2
  t.dwHighDateTime = (DWORD)(((double)time * 10000.0) / two_to_32);
  t.dwLowDateTime = (DWORD)(((double)time * 10000.0) - t.dwHighDateTime * two_to_32);
d564 1
d569 29
a597 2
  return ((double)user.dwLowDateTime / 10.0
	  + ((double) user.dwHighDateTime * two_to_32) / 10.0);
d606 2
a607 2
  start_time.dwHighDateTime = (DWORD)(((double)time * 10000.0) / two_to_32);
  start_time.dwLowDateTime = (DWORD)(((double)time * 10000.0) - start_time.dwHighDateTime * two_to_32);
@


1.2
log
@Fix timings function bugs (negative and wrong order of magnitude answers)
Modified user_time to divide by 10 instead of multiply by 10
@
text
@d21 4
d313 1
a313 1
  unmarshal(CSTRING(arg), "ll", &t.dwLowDateTime,&t.dwHighDateTime);
@


1.1
log
@new file
@
text
@d20 4
a23 1
 *  $Log: src:OS:Linux:time.c,v $
d319 2
a320 2
  long a = (long)t1->dwLowDateTime;
  long b = (long)t2->dwLowDateTime;
d389 4
d403 4
d446 2
d455 6
d463 6
d471 6
d479 6
d528 1
a528 1
  int whole,frac,i;
d534 2
a535 2
  whole = t.dwHighDateTime;
  frac = t.dwLowDateTime;
d542 1
a542 33
  /* negatives need to be normalized, as microsecond parts are always +ve */

  if (whole < 0) {
    *p++ = '~';
    whole = -whole;
    if (frac != 0) {
      whole--;
      frac = 1000000-frac;
    }
  }
  
  /* round for whole numbers, and return without a decimal point */
  
  if (digits == 0) {
    if (frac >= 500000) {
      whole++;
    }
    sprintf(p,"%li",whole);
    
  } else {
    
    /* round for others */

    if (digits != 6) {
      for (i=5; i != digits; i--)
	frac /= 10;
      if  (frac % 10 >= 5)
	frac += 10;
      frac /= 10;
    }
    /* print with a point, left padded with zeroes */
    sprintf(p,"%li.%0*li",whole,digits,frac);
  }
d559 2
a560 2
  return ((double)user.dwLowDateTime * 10.0
	  + (double) user.dwHighDateTime * 10.0 * two_to_32);
@
