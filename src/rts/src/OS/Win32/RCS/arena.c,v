head	1.11;
access;
symbols
	MLW_daveb_inline_1_4_99:1.11.1
	MLWorks_21c0_1999_03_25:1.11
	MLWorks_20c1_1998_08_20:1.11
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.6.9
	MLWorks_20m1_1997_10_23:1.6
	MLWorks_11r1:1.6.6.1.1.1.1
	MLWorks_workspace_97:1.6.8
	MLWorks_dt_wizard:1.6.7
	MLWorks_11c0_1997_09_09:1.6.6.1.1.1
	MLWorks_10r3:1.6.6.1.3
	MLWorks_10r2_551:1.6.6.1.2
	MLWorks_11:1.6.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.6.1
	MLWorks_20m0_1997_06_20:1.6
	MLWorks_1_0_r2c2_1997_06_14:1.6.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.6
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MM_ML_release_korma_1997_04_01:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.4.1.1
	MLWorks_gui_1996_12_18:1.6.5
	MLWorks_1_0_Win32_1996_12_17:1.6.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.1.1
	JFHrts:1.6.3
	MLWorks_1_0_Irix_1996_11_28:1.6.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.2
	MLWorks_1_0_Unix_1996_11_14:1.6.1
	MLWorks_Open_Beta2_1996_10_11:1.4.3
	MLWorks_License_dev:1.4.2
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.11
date	98.08.07.12.58.46;	author jont;	state Exp;
branches
	1.11.1.1;
next	1.10;

1.10
date	98.07.15.15.21.30;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	98.07.14.12.27.15;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	98.05.22.10.55.07;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	98.01.23.15.59.16;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	96.10.31.12.02.57;	author nickb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1
	1.6.9.1;
next	1.5;

1.5
date	96.10.29.17.28.27;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	96.07.31.11.32.50;	author stephenb;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1;
next	1.3;

1.3
date	96.05.31.15.32.20;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.14.16.31.57;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	96.03.06.11.23.04;	author stephenb;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.24.31;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.10.07.16.14.51;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.10.17.11.34.16;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.11.14.12.59.55;	author hope;	state Exp;
branches
	1.6.1.1.1.1;
next	;

1.6.1.1.1.1
date	96.11.28.15.09.57;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.11.22.18.17.44;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.12.17.10.04.27;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.12.17.17.56.03;	author hope;	state Exp;
branches
	1.6.4.1.1.1;
next	;

1.6.4.1.1.1
date	97.02.24.11.47.36;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.12.18.09.50.40;	author hope;	state Exp;
branches;
next	;

1.6.6.1
date	97.05.12.10.44.21;	author hope;	state Exp;
branches
	1.6.6.1.1.1
	1.6.6.1.2.1
	1.6.6.1.3.1;
next	;

1.6.6.1.1.1
date	97.07.28.18.25.54;	author daveb;	state Exp;
branches
	1.6.6.1.1.1.1.1;
next	;

1.6.6.1.1.1.1.1
date	97.10.07.11.51.40;	author jkbrook;	state Exp;
branches;
next	;

1.6.6.1.2.1
date	97.09.08.17.19.09;	author daveb;	state Exp;
branches;
next	;

1.6.6.1.3.1
date	97.09.09.14.15.17;	author daveb;	state Exp;
branches;
next	;

1.6.7.1
date	97.09.10.19.32.14;	author brucem;	state Exp;
branches;
next	;

1.6.8.1
date	97.09.11.21.01.34;	author daveb;	state Exp;
branches;
next	;

1.6.9.1
date	97.10.31.13.44.31;	author nickb;	state Exp;
branches;
next	;

1.11.1.1
date	99.04.01.18.01.14;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This replaces src/rts/src/OS/{NT,Win95}/arena.c
@


1.11
log
@[Bug #70111]
Don't lose memory we can't use.
@
text
@/*  ==== ARENA MANAGEMENT ====
 *
 *  Copyright (C) 1992 Harlequin Ltd
 *
 *  Implementation
 *  --------------
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win32:arena.c,v $
 * Revision 1.10  1998/07/15  15:21:30  jont
 * [Bug #20134]
 * Provide address validation outside of ml heap
 *
 * Revision 1.9  1998/07/14  12:27:15  jont
 * [Bug #70113]
 * Modify to reserve only when required, and not to demand contiguity
 *
 * Revision 1.8  1998/05/22  10:55:07  jont
 * [Bug #70030]
 * Modify block_free to free entire space where appropriate
 *
 * Revision 1.7  1998/01/23  15:59:16  jont
 * [Bug #30340]
 * Loop to repeat the mmap after out of memory dialog says do so
 *
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
 * Revision 1.5  1996/10/29  17:28:27  nickb
 * Fix space lookup for pointers with top bit set.
 *
 * Revision 1.4  1996/07/31  11:32:50  stephenb
 * Replaced the #include of syscalls.h with <windows.h> since
 * syscalls.h no longer contains copies of the declarations
 * in <windows.h>
 *
 * Revision 1.3  1996/05/31  15:32:20  nickb
 * Add test_mapping().
 *
 * Revision 1.2  1996/05/14  16:31:57  nickb
 * Improve out-of-memory behaviour.
 *
 * Revision 1.1  1996/03/06  11:23:04  stephenb
 * new unit
 * This replaces src/rts/src/OS/{NT,Win95}/arena.c
 *
 * Revision 1.7  1995/10/09  14:54:17  jont
 * Improve space number algorithm to allow transfer of images between
 * NT and Win95.
 *
 * Revision 1.6  1995/08/02  14:23:05  jont
 * Remove windows.h from include list
 *
 * Revision 1.5  1995/04/05  14:12:43  nickb
 * Add maximum memory use reporting.
 *
 * Revision 1.4  1995/03/01  13:45:52  nickb
 * Add interface for holes and make space_gen array general.
 *
 * Revision 1.3  1995/02/03  17:41:30  jont
 * Further fix to error handling from VirtualAlloc
 *
 * Revision 1.2  1995/02/03  17:29:44  jont
 * Handle errors from VirtualAlloc gracefully
 *
 * Revision 1.1  1994/12/12  14:21:20  jont
 * new file
 *
 * Revision 1.2  1994/10/13  13:06:02  nickb
 * Allow multiple block spaces, so blocks can occupy more of arena.
 *
 * Revision 1.1  1994/10/04  16:25:59  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:25:14  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:50:00  nickh
 * new file
 */

#include <windows.h>		/* SYSTEM_INFO, MEM_RESERVE, ... etc. */
#include "ansi.h"
#include "arena.h"
#include "mem.h"
#include "types.h"
#include "diagnostic.h"
#include "utils.h"

#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <string.h>
#include <stdio.h>

#include <sys/types.h>
#include <fcntl.h>
#include <signal.h>

/* type and extent tables */

byte space_type[NR_SPACES];
size_t space_extent[NR_SPACES];
void *space_info[NR_SPACES];
void *free_map[NR_SPACES];

/* The first block space has a statically-allocated map. Later block
   spaces have their maps in a reserved region within the first block
   space. The pointer 'block_maps' indicates the next available
   location for a map in this region */

/* Now modified */
/* first_block_space_map is still the pointer
   to the map for the initial block space.
   Later block spaces have their maps allocated
   within the space allocated as block_maps, according
   to their space number,
   ie for block j in space i, its type is block_maps[i][j]
   But we still use the space_info array as Iliffe vectors
   for speed rather than calculating each time.
   This also ensures that we don't use the wrong block_map
   for the initial block space */

/* free_map gives us a mapping from space number to
   the actual address returned by VirtualAlloc when
   we allocated this space. We need this because
   VirtualFree has a crap interface demanding that
   we can only release memory in the same size chunks
   as allocated by VirtualAlloc. Since VirtualAlloc can
   give us stuff which is unaligned with our arena spaces
   we sometimes have to accept pieces which are too big
   and ignore the bits on the ends. But we need the
   original addresses when we release. */

byte first_block_space_map[BLOCKS_PER_SPACE];
byte *block_maps = NULL;

size_t arena_extent = 0;
#ifdef COLLECT_STATS
size_t max_arena_extent = 0;
#endif

static int zero_device;
static int page_size;

#define BACKOFF_LIMIT	5

/* arena_state is UNINITIALIZED until the arena has been initialized.
 * See arena_init() and block_alloc() below.
 *
 * GCC 2.x calls __main() before main(). __main() can call malloc().
 * Our malloc(), on first call, calls block_alloc() to get some heap.
 * If the arena has been initialized, we simply allocate a block.
 * Otherwise we initialize the arena then. */

enum {
  UNINITIALIZED = 0,
  INITIALIZING,
  INITIALIZED
};

static int arena_state = UNINITIALIZED;

/* grains. The purpose of grain_round is to round its argument (a
number of bytes) up to a convenient size, where "convenient" means "a
multiple of 2^n (where n<=20), which does not waste more than
GRAIN_OVERHEAD bytes per 0x100". */

#define MAX_GRAIN_SIZE		0x100000	/* 1Mb */
#define GRAIN_OVERHEAD		0x10		/* per 0x100 */
#define GRAINROUND(grain, size)	(((size)+(grain)-1) & ~((grain)-1))

static size_t grain_round(size_t size)
{
  int grain;
  /* we round at least to the nearest page */
  size_t rounded = GRAINROUND(page_size, size);
  /* maximum is the maximum acceptable size (any more wastes too much) */
  size_t maximum = (size * (0x100+GRAIN_OVERHEAD))/ 0x100;

  if(rounded > 0)
    for(grain = MAX_GRAIN_SIZE; grain >= page_size; grain >>= 1)
    {
      rounded = GRAINROUND(grain, size);
      
      if (rounded < maximum)
	break;
    }

  return(rounded);
}

static unsigned long map_attempt = 0;

static void map(void *start, size_t length)
{
  map_attempt ++;

  if (arena_state != INITIALIZED)
    error_without_alloc("Trying to map memory before arena initialized.\n");

  if(length > 0) {
    while (VirtualAlloc((LPVOID)start, (DWORD)length,
			MEM_COMMIT,
			PAGE_EXECUTE_READWRITE) == NULL) {
      unsigned int error = GetLastError();
      if ((out_of_memory_dialog == NULL) ||
	  ((*out_of_memory_dialog)(map_attempt, arena_extent, length) == 0))
	error_without_alloc("Out of virtual memory.\n");
    }
  }
  arena_extent += length;
#ifdef COLLECT_STATS
  if (arena_extent > max_arena_extent)
    max_arena_extent = arena_extent;
#endif
}

static void unmap(void *start, size_t length)
{
  if(length > 0 &&
     !VirtualFree(start, (DWORD)length, MEM_DECOMMIT))
    error("VirtualFree has returned an unexpected error code %lu", GetLastError());

  arena_extent -= length;
}

#ifdef DEBUG

void test_mapping(void)
{
  int i,j;
  byte *block_map;
  for (i=0 ; i<NR_SPACES; ++i) {
    switch (space_type[i]) {
    case TYPE_RESERVED:
      /* these are reserved */
      message("space at 0x%08x reserved",SPACE_BASE(i));
      break;
    case TYPE_BLOCKS:
      /* test each block */
      block_map = SPACE_MAP(i);
      message("testing block space at 0x%08x",SPACE_BASE(i));
      for (j=0; j < BLOCKS_PER_SPACE; j++) {
	switch (block_map[j]) {
	case TYPE_FREE:
	  message("  testing block at 0x%08x",BLOCK_BASE(i,j));
	  map (BLOCK_BASE(i,j), BLOCK_SIZE);
	  unmap (BLOCK_BASE(i,j), BLOCK_SIZE);
	  break;
	default:
	  message("  block at 0x%08x has type %d",
		  BLOCK_BASE(i,j),block_map[j]);
	}
      }
      break;
    case TYPE_FREE:
      /* test the whole space */
      message("testing space at 0x%08x",SPACE_BASE(i));
      map(SPACE_BASE(i), SPACE_SIZE);
      unmap(SPACE_BASE(i), SPACE_SIZE);
      break;
    default:
      message("space at 0x%08x used with type %d",
	      SPACE_BASE(i), space_type[i]);
    }
  }
}

#endif

/*
 * Attempt to reserve a space within the arena
 * Return 0 for success, 1 for failure
 * The arena maps will be updated, so functions searching
 * for a SPACE of type TYPE_FREE can redo their searches
 * This function is a bit of a pi's ear due to the lousy
 * MS interface VirtualAlloc/Free
 * In particular, when releasing memory, you can only
 * release at an address returned by VirtualAlloc. Hence
 * the technique used by the other arena managers of allocating
 * twice as much and then freeing the bits on the end doesn't work.
 * MPS used to just take the hit of using twice as much VM,
 * but we don't want this. So we try to do an allocation that
 * will leave the next allocation aligned.
 */

static int reserve_arena_space(LPVOID *base)
{
  int space;
  *base = VirtualAlloc(NULL, SPACE_SIZE, MEM_RESERVE, PAGE_NOACCESS);
  if(*base == NULL) {
    /* Failed to reserve */
    return 1;
  }
  space = SPACE(*base);
  if ((SPACE_BASE(space)) != *base) {
    /* Oh dear, we've got an unaligned piece of space */
    /* Unmap it, get the extra we need then junk the bit at the start */
    LPVOID base1;
    unsigned long new_size =
      (unsigned long)(SPACE_BASE(space+1)) - (unsigned long)*base;
    if (!VirtualFree(*base, 0, MEM_RELEASE)) {
      error("VirtualFree has returned an unexpected error code %lu", GetLastError());
    }
    /* We try to be friendly here, by allocating the bit to fill the gap we can't */
    /* use, then allocating the bit we want, and then freeing the bit we first */
    /* allocated. If that fails we do the unfriendly thing and lose some VM */
    base1 = VirtualAlloc(NULL, new_size, MEM_RESERVE, PAGE_NOACCESS);
    if(base1 == NULL) {
      /* Failed to reserve */
      /* If we can't reserve the little bit, we won't succeed with the bigger bit */
      return 1;
    }
    *base = VirtualAlloc(NULL, SPACE_SIZE, MEM_RESERVE, PAGE_NOACCESS);
    if(*base == NULL) {
      /* Failed to reserve */
      /* This was the bit we really wanted */
      return 1;
    }
    /* Now get rid of the bit at the start */
    if (!VirtualFree(base1, 0, MEM_RELEASE)) {
      error("VirtualFree has returned an unexpected error code %lu", GetLastError());
    }
    space = SPACE(*base);
    if (*base == SPACE_BASE(space)) {
      free_map[space] = *base;
      /* This is what we hope will happen, to keep the VM usage clean */
    } else {
      /* Ok, go for the algorithm that loses a bit of VM */
      /* First release the bit that failed */
      if (!VirtualFree(*base, 0, MEM_RELEASE)) {
	error("VirtualFree has returned an unexpected error code %lu", GetLastError());
      }
      new_size += SPACE_SIZE;
      do {
	*base = VirtualAlloc(NULL, new_size, MEM_RESERVE, PAGE_NOACCESS);
	if(*base == NULL) {
	  /* Failed to reserve */
	  return 1;
	}
	/* Now check that we have covered an entire space */
	space = SPACE(*base);
	if (*base == SPACE_BASE(space)) {
	  free_map[space] = *base;
	  break;
	  /* Unexpected case, but we'll settle for it */
	}
	if ((unsigned long)*base <= (unsigned long)SPACE_BASE(space+1) &&
	    (unsigned long)*base + new_size >= (unsigned long)SPACE_BASE(space+2)) {
	  space++;
	  free_map[space] = *base;
	  *base = SPACE_BASE(space);
	  break;
	  /* The case we expected */
	}
	/* Still not enough room */
	/* Increase extra and try again */
	new_size = (SPACE_SIZE) + (unsigned long)(SPACE_BASE(space+1)) - (unsigned long)*base;
	if (!VirtualFree(*base, 0, MEM_RELEASE)) {
	  error("VirtualFree has returned an unexpected error code %lu", GetLastError());
	}
      } while(1);
    }
    /* We don't unmap the space bit at the start */
    /* because the crap interface of VirtualFree won't do it */
    /* See comment above */
  } else {
    free_map[space] = *base;
  }
  space_type[space]   = TYPE_FREE;
  space_extent[space] = 0;
  SPACE_MAP(space) = NULL;
  return 0;
}

/*
 * Non-returning version of reserve_arena_space
 * for use by space_alloc
 */
static void acquire_arena_space(void)
{
  void *base;
  if (reserve_arena_space(&base)) {
    error("Run out of arena spaces.");
  }
}

static void release_arena_space(int space)
{
  if (!VirtualFree(free_map[space], 0, MEM_RELEASE)) {
    error("VirtualFree has returned an unexpected error code %lu", GetLastError());
  }
  /* Now mark the space reserved */
  space_type[space]   = TYPE_RESERVED;
  space_extent[space] = (size_t)-1;
  SPACE_MAP(space)    = NULL;
}

void arena_init(void)
{
  int first_block_space=0 ,i;
  
  switch (arena_state) {
    
  case UNINITIALIZED: {
    SYSTEM_INFO sysinfo;

    arena_state = INITIALIZING;

    /* First mark all spaces reserved */
    for (i = 0; i < NR_SPACES; i++) {
      space_type[i]   = TYPE_RESERVED;
      space_extent[i] = (size_t)-1;
      SPACE_MAP(i)    = NULL;
    }

    /* Now allocate the spaces we want */
    for (i = 0; i < 2; i++) {
      int space;
      void *base;
      if (reserve_arena_space(&base)) {
	error_without_alloc("Arena initializing unable to reserve memory\n");
      }
      space = SPACE(((word)base) + (SPACE_SIZE) -1);
      if (first_block_space == 0) {
	/* Allocate first block space to what we've just got */
	int i;
	first_block_space = space;
	for (i=0; i < BLOCKS_PER_SPACE; ++i) {
	  first_block_space_map[i] = TYPE_FREE;
	}
	SPACE_MAP(first_block_space) = first_block_space_map;
	space_type[first_block_space] = TYPE_BLOCKS;
	space_extent[first_block_space] = (size_t)-2;
      }
    }

    GetSystemInfo(&sysinfo);
    page_size = sysinfo.dwPageSize;

    arena_extent = 0;
#ifdef COLLECT_STATS
    max_arena_extent = 0;
#endif
    arena_state = INITIALIZED;

    /* The arena is now initialized, so we can call block_alloc */
    block_maps = block_alloc(TYPE_RESERVED,
			     (unsigned long)SPACES_IN_ARENA*BLOCKS_PER_SPACE);
    break;
  }
  case INITIALIZING:
    error_without_alloc("Allocation during arena startup.");
  case INITIALIZED:
    /* Could get to here if we alloc before arena_init gets called. */
    break;
  default:
    error_without_alloc("Arena state inconsistent.");
  }
}

void space_free(byte *space)
{
  unsigned int space_no = SPACE(space);
  unmap(space, space_extent[space_no]);
  release_arena_space(space_no);
}

void space_resize(byte *space, size_t extent)
{
  unsigned int space_no = SPACE(space);
  size_t current = space_extent[space_no];

  extent = grain_round(extent);

  if(extent > current)
    map(space+current, extent-current);
  else if(current > extent)
    unmap(space+extent, current-extent);

  space_extent[space_no] = extent;
}

byte *space_alloc(byte type, size_t extent)
{
  unsigned int i;

  if (extent > SPACE_SIZE) {
    error("Allocating too large a space");
  }

  while(1) {
    for(i=0; i<SPACES_IN_ARENA; ++i)
      if(space_type[i] == TYPE_FREE) {
	space_type[i] = type;
	space_extent[i] = 0;
	space_resize(SPACE_BASE(i), extent);
	return SPACE_BASE(i);
      }
    acquire_arena_space();
  }

  error("Run out of arena spaces.");
}

/* Allow general mapping holes inside spaces; note that both of these
 * functions can be no-ops to start with */

void space_allow_hole(byte *hole, size_t extent)
{
}

void space_remove_hole(byte *hole, size_t extent)
{
}

byte *block_alloc(byte type, size_t size)
{
  int s, b, found = 0, blocks = BLOCKS(size);
  byte *block_map;
  byte *space;

  if (arena_state != INITIALIZED)
    arena_init();

  if (blocks > BLOCKS_PER_SPACE)
    error("Trying to allocate too many contiguous blocks.");

  for(s=0; s<SPACES_IN_ARENA; ++s) {
    if (space_type[s] == TYPE_BLOCKS) {
      block_map = SPACE_MAP(s);
      for (b=0; b<BLOCKS_PER_SPACE; b++) {
	if (block_map[b] == TYPE_FREE) {
	  found ++;
	  if(found >= blocks) {
	    int start = b+1-found, k;

	    for(k=start; k<=b; ++k)
	      block_map[k] = type;
	    map(BLOCK_BASE(s,start), GRAINROUND(page_size, size));
	    return(BLOCK_BASE(s,start));
	  }
	}
	else
	  found = 0;
      }
      found = 0;
    }
  }

  /* None of the existing block spaces have room; let's make a new one */

  space = space_alloc(TYPE_BLOCKS,0);    /* allocate the new space */
  s = SPACE(space);
  block_map = SPACE_MAP(s) = block_maps + s*BLOCKS_PER_SPACE;
  /* This is where the map is */

  for(b=0; b< blocks; ++b)
    block_map[b] = type;
  for (b=blocks; b < BLOCKS_PER_SPACE; b++)
    block_map[b] = TYPE_FREE;		 /* ... and initialize it */

  map(space, GRAINROUND(page_size, size));
  return(space);
}

void block_free(byte *block, size_t size)
{
  unsigned int space_nr = SPACE(block);
  unsigned int block_nr = BLOCK_NR(block);
  size_t blocks = BLOCKS(size);
  byte *block_map = SPACE_MAP(space_nr);
  unsigned i;
  int ok = 1;

  for(i=0; i<blocks; ++i)
    block_map[block_nr+i] = TYPE_FREE;

  /* See if we can free the entire space */
  for (i=0; i<BLOCKS_PER_SPACE; i++) {
    if (block_map[i] != TYPE_FREE) {
      ok = 0;
      break;
    }
  }
  unmap(block, GRAINROUND(page_size, size));
  if (ok) {
    /* Free the entire space */
    space_type[space_nr] = TYPE_FREE;
    space_extent[space_nr] = 0;
    SPACE_MAP(space_nr) = NULL;
  }
}

int system_validate_address(void *addr)
{
  /* A function for validating addresses outside the ml heap */
  MEMORY_BASIC_INFORMATION info;
  (void)VirtualQuery(addr, &info, sizeof(info));
  if ((info.AllocationProtect & PAGE_NOACCESS) || (info.AllocationProtect & PAGE_EXECUTE)) {
    return 0; /* Can't access if execute only or no access */
  }
  return (info.State & MEM_COMMIT); /* Need area to be committed */
}
@


1.11.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.11  1998/08/07  12:58:46  jont
 * [Bug #70111]
 * Don't lose memory we can't use.
 *
@


1.10
log
@[Bug #20134]
Provide address validation outside of ml heap
@
text
@d11 4
d281 2
a282 2
 * release at an address returned by VirtualAlloc. Hnece
 * teh technique used by the other arena managers of allocating
d300 2
a301 1
    /* Unmap it, get double then junk the bits on the ends */
a302 1
      (SPACE_SIZE) +
d307 26
a332 24
    do {
      *base = VirtualAlloc(NULL, new_size, MEM_RESERVE, PAGE_NOACCESS);
      if(*base == NULL) {
	/* Failed to reserve */
	return 1;
      }
      /* Now check that we have covered an entire space */
      space = SPACE(*base);
      if (*base == SPACE_BASE(space)) {
	free_map[space] = *base;
	break;
	/* Unexpected case, but we'll settle for it */
      }
      if ((unsigned long)*base <= (unsigned long)SPACE_BASE(space+1) &&
	  (unsigned long)*base + new_size >= (unsigned long)SPACE_BASE(space+2)) {
	space++;
	free_map[space] = *base;
	*base = SPACE_BASE(space);
	break;
	/* The case we expected */
      }
      /* Still not enough room */
      /* Increase extra and try again */
      new_size = (SPACE_SIZE) + (unsigned long)(SPACE_BASE(space+1)) - (unsigned long)*base;
d336 30
a365 1
    } while(1);
@


1.9
log
@[Bug #70113]
Modify to reserve only when required, and not to demand contiguity
@
text
@d11 4
a299 5
    /*
    if (arena_state == INITIALIZED) {
      printf("reserve_arena_space fails to allocate an aligned space, retrying with new_size = 0x%x\n", new_size);
    }
    */
d560 11
@


1.8
log
@[Bug #70030]
Modify block_free to free entire space where appropriate
@
text
@d11 4
d98 1
d117 11
d199 1
d215 1
a215 1
     !VirtualFree((LPVOID)start, (DWORD)length, MEM_DECOMMIT))
d265 102
d369 1
a369 1
  int first_block_space,i;
a373 1
    LPVOID base;
d378 2
a379 16
    base = VirtualAlloc(NULL, 1lu<<ARENA_WIDTH, MEM_RESERVE, PAGE_NOACCESS);
    if(base == NULL)
      error_without_alloc("Unable to reserve address space for arena.");
    first_block_space = SPACE(((word)base) + (1 << SPACE_WIDTH) -1);

    /* make sure that the arena includes several spaces! This is a very
     * unsatisfactory hack; the arena interface could do with cleaning
     * up so that this isn't necessary. */

    if (first_block_space > SPACES_IN_ARENA-8)
      error_without_alloc("Reserved address space too high for arena.");

    GetSystemInfo(&sysinfo);
    page_size = sysinfo.dwPageSize;

    for(i=0; i<first_block_space; ++i) {
d385 19
a403 2
    for (i=0; i < BLOCKS_PER_SPACE; ++i) {
      first_block_space_map[i] = TYPE_FREE;
d405 4
a408 17
    
    SPACE_MAP(first_block_space) = first_block_space_map;
    space_type[first_block_space] = TYPE_BLOCKS;
    space_extent[first_block_space] = (size_t)-2;
    
    for(i=first_block_space+1; i<SPACES_IN_ARENA; ++i) {
      space_type[i]   = TYPE_FREE;
      space_extent[i] = 0;
      SPACE_MAP(i) = NULL;
    }
    
    for(i=SPACES_IN_ARENA; i<NR_SPACES; ++i) {
      space_type[i]   = TYPE_RESERVED;
      space_extent[i] = (size_t)-1;
      SPACE_MAP(i) = NULL;
    }
    
d434 1
a434 2
  space_type[space_no] = TYPE_FREE;
  space_extent[space_no] = 0;
d460 10
a469 7
  for(i=0; i<SPACES_IN_ARENA; ++i)
    if(space_type[i] == TYPE_FREE) {
      space_type[i] = type;
      space_extent[i] = 0;
      space_resize(SPACE_BASE(i), extent);
      return SPACE_BASE(i);
    }
@


1.7
log
@[Bug #30340]
Loop to repeat the mmap after out of memory dialog says do so
@
text
@d11 4
d100 12
d413 2
a414 2
  block_map = SPACE_MAP(s) = block_maps; /* allocate a map ... */
  block_maps += BLOCKS_PER_SPACE;       
d432 1
d437 7
d445 6
a451 1

@


1.6
log
@Oops. The most recent change broke the Win32 arena.
@
text
@d11 3
d163 8
a170 7
  if(length > 0 &&
     VirtualAlloc((LPVOID)start, (DWORD)length,
		  MEM_COMMIT,
		  PAGE_EXECUTE_READWRITE) == NULL) {
    if ((out_of_memory_dialog == NULL) ||
	((*out_of_memory_dialog)(map_attempt, arena_extent, length) == 0))
      error_without_alloc("Out of virtual memory.\n");
@


1.6.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.6.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.6.6.1  1997/05/12  10:44:21  hope
 * branched from 1.6
 *
@


1.6.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.6.6.1  1997/05/12  10:44:21  hope
 * branched from 1.6
 *
@


1.6.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.6.6.1  1997/05/12  10:44:21  hope
 * branched from 1.6
 *
@


1.6.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.6.6.1.1.1  1997/07/28  18:25:54  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.4.1.1.1
log
@branched from 1.6.4.1
@
text
@a10 3
 * Revision 1.6.4.1  1996/12/17  17:56:03  hope
 * branched from 1.6
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a10 3
 * Revision 1.6  1996/10/31  12:02:57  nickb
 * Oops. The most recent change broke the Win32 arena.
 *
@


1.6.1.1.1.1
log
@branched from 1.6.1.1
@
text
@a10 3
 * Revision 1.6.1.1  1996/11/14  12:59:55  hope
 * branched from 1.6
 *
@


1.5
log
@Fix space lookup for pointers with top bit set.
@
text
@d11 3
d240 1
a240 1
    base = VirtualAlloc(NULL, 1lu<<ADDRESS_WIDTH, MEM_RESERVE, PAGE_NOACCESS);
d242 1
a242 1
      error_without_alloc("Arena initializing unable to reserve address space.");
d244 7
@


1.4
log
@Replaced the #include of syscalls.h with <windows.h> since
syscalls.h no longer contains copies of the declarations
in <windows.h>
@
text
@d11 5
d251 4
d259 1
a259 1
    for(i=first_block_space+1; i<NR_SPACES; ++i) {
d265 4
a268 2
    for (i=0; i < BLOCKS_PER_SPACE; ++i) {
      first_block_space_map[i] = TYPE_FREE;
d279 1
a279 1
			     (unsigned long)NR_SPACES*BLOCKS_PER_SPACE);
d323 2
a324 3
  for(i=0; i<NR_SPACES; ++i)
    if(space_type[i] == TYPE_FREE)
    {
d357 1
a357 1
  for(s=0; s<NR_SPACES; ++s) {
@


1.4.3.1
log
@branched from 1.4
@
text
@a10 5
 * Revision 1.4  1996/07/31  11:32:50  stephenb
 * Replaced the #include of syscalls.h with <windows.h> since
 * syscalls.h no longer contains copies of the declarations
 * in <windows.h>
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a10 5
 * Revision 1.4  1996/07/31  11:32:50  stephenb
 * Replaced the #include of syscalls.h with <windows.h> since
 * syscalls.h no longer contains copies of the declarations
 * in <windows.h>
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a10 5
 * Revision 1.4  1996/07/31  11:32:50  stephenb
 * Replaced the #include of syscalls.h with <windows.h> since
 * syscalls.h no longer contains copies of the declarations
 * in <windows.h>
 *
@


1.3
log
@Add test_mapping().
@
text
@d11 3
d56 1
a62 1
#include "syscalls.h"
@


1.2
log
@Improve out-of-memory behaviour.
@
text
@d11 3
d172 44
@


1.1
log
@new unit
This replaces src/rts/src/OS/{NT,Win95}/arena.c
@
text
@d10 5
a14 1
 *  $Log: src:OS:NT:arena.c,v $
d52 1
d137 2
d141 2
d149 5
a153 6
		  PAGE_EXECUTE_READWRITE) == NULL)
    /* **** decode cryptic and arcane windows error code here! */
    {
      message("VirtualAlloc failed with %lu", GetLastError());
      error("Unable to allocate virtual memory of length 0x%x", length);
    };
@
