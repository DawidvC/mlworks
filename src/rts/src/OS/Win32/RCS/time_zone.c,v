head	1.3;
access;
symbols
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_MM_adapt:1.3.3
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.2.7.1.1.1.1
	MLWorks_workspace_97:1.3.2
	MLWorks_dt_wizard:1.3.1
	MLWorks_11c0_1997_09_09:1.2.7.1.1.1
	MLWorks_10r3:1.2.7.1.3
	MLWorks_10r2_551:1.2.7.1.2
	MLWorks_11:1.2.7.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.7.1
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.2.7.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.7.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.7
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MM_ML_release_korma_1997_04_01:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.5.1.1
	MLWorks_gui_1996_12_18:1.2.6
	MLWorks_1_0_Win32_1996_12_17:1.2.5
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.2.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.2.1
	JFHrts:1.2.4
	MLWorks_1_0_Irix_1996_11_28:1.2.2.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.3
	MLWorks_1_0_Unix_1996_11_14:1.2.2
	MLWorks_Open_Beta2_1996_10_11:1.2.1
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	97.05.22.09.18.40;	author johnh;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1;
next	1.2;

1.2
date	96.10.07.17.01.55;	author jont;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1;
next	1.1;

1.1
date	96.09.09.17.26.58;	author jont;	state Exp;
branches
	1.1.1.1
	1.1.2.1;
next	;

1.1.1.1
date	96.09.13.11.25.04;	author hope;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	96.10.04.15.28.10;	author jont;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.15.27;	author hope;	state Exp;
branches;
next	;

1.2.1.1
date	96.10.17.11.34.53;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.11.14.13.00.33;	author hope;	state Exp;
branches
	1.2.2.1.1.1;
next	;

1.2.2.1.1.1
date	96.11.28.15.10.35;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.11.22.18.18.23;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.12.17.10.05.05;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.12.17.17.56.41;	author hope;	state Exp;
branches
	1.2.5.1.1.1;
next	;

1.2.5.1.1.1
date	97.02.24.11.48.19;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.18.09.51.19;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	97.05.12.10.45.01;	author hope;	state Exp;
branches
	1.2.7.1.1.1
	1.2.7.1.2.1
	1.2.7.1.3.1;
next	;

1.2.7.1.1.1
date	97.07.28.18.29.20;	author daveb;	state Exp;
branches
	1.2.7.1.1.1.1.1;
next	;

1.2.7.1.1.1.1.1
date	97.10.07.11.55.11;	author jkbrook;	state Exp;
branches;
next	;

1.2.7.1.2.1
date	97.09.08.17.22.19;	author daveb;	state Exp;
branches;
next	;

1.2.7.1.3.1
date	97.09.09.14.18.24;	author daveb;	state Exp;
branches;
next	;

1.3.1.1
date	97.09.10.19.37.56;	author brucem;	state Exp;
branches;
next	;

1.3.2.1
date	97.09.11.21.05.37;	author daveb;	state Exp;
branches;
next	;

1.3.3.1
date	97.10.31.13.48.40;	author nickb;	state Exp;
branches;
next	;


desc
@new unit
@


1.3
log
@[Bug #01702]
Changing definition of mlw_raise_win32_syserr.
@
text
@/* Copyright (C) 1996 The Harlequin Group Limited.  All rights reserved.
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Win32:time_zone.c,v $
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
 * Revision 1.1.1.2  1996/10/04  15:28:10  jont
 * Add ml_stat_sub for doing stuff common to ml_stat for Win95 and NT.
 * Includes stuff to deal with timezone variation problems on FAT
 *
 * Revision 1.1.1.1  1996/09/13  11:25:04  hope
 * branched from 1.1
 *
 * Revision 1.1  1996/09/09  17:26:58  jont
 * new unit
 *
 *
 */

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>		/* assert */
#include "diagnostic.h"
#include "extensions.h"
#include "time_date.h"
#include "time_zone.h"
#include "os_errors.h"		/* mlw_os_syserror ... */
#include "win32_error.h"        /* mlw_win32_strerror ... */
#include "tags.h"

/*
 * A function to clamp timestamps to one second because FAT
 * is too stupid to do any better. It turns out that InstallShield
 * rounds up to the nearest two seconds, so that's what we must do.
 */

#define ticks_per_two_secs (2*mlw_time_ticks_per_sec)

static void time_stamp_clamp(FILETIME *t)
{
  DWORD hi = t->dwHighDateTime,
        lo = t->dwLowDateTime;
  unsigned long remainder = (((((((((((((hi % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 64) % ticks_per_two_secs) * 4) + lo % ticks_per_two_secs) % ticks_per_two_secs;
  /* The above horrible expression is done this way to ensure */
  /* that the modulus we calculate doesn't have an overflow in the middle */
  /* I'm not sure if it's necessary, but it's certainly sufficient! */
  if (remainder != 0) {
    /* Only round up if not an exact second */
    unsigned long up = ticks_per_two_secs - remainder;
    lo += up;
    if (lo < up) {
      /* Addition overflow */
      hi += 1;
    }
  }
  t->dwHighDateTime = hi;
  t->dwLowDateTime = lo; /* And put the result back */

}

void ml_stat_sub(const char *filename, FILETIME *result)
{
  int bias;
  int res;
  FILETIME converted;

  res = FileTimeToLocalFileTime(result, &converted);
  if (res) {
    bias = ((result->dwHighDateTime == converted.dwHighDateTime) &&
	    (result->dwLowDateTime == converted.dwLowDateTime))
      ? 0 : 1;
  } else {
    mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in MS */
  }
  
/*
  message("Original time was %lu, %lu, %f", result->dwHighDateTime, result->dwLowDateTime, double_time(file_data.ftLastWriteTime));
*/
  DIAGNOSTIC(2, "  mtime = %lu, %lu", result->dwHighDateTime, result->dwLowDateTime);
  DIAGNOSTIC(2, "  mtime = %f", double_time((*result)), 0);
  
  time_stamp_clamp(result);
/*
  message("Clamped time is %lu, %lu, %f", result->dwHighDateTime, result->dwLowDateTime, double_time((*result)));
*/
  /* Now, if the bias is non-zero, see if we need to adjust the stamp */
  if (bias != 0) {
    char fixed_buffer[MAX_PATH];
    char *buffer = fixed_buffer;
    DWORD buffer_size = MAX_PATH;
    char *final_name;
    DWORD size = GetFullPathName(filename, MAX_PATH, buffer, &final_name);
    if (size <= 4) /* Any full path name should be at least this long */
      mlw_raise_win32_syserr(GetLastError());
    if (size >= buffer_size) {
      buffer_size = size;
      if ((buffer = malloc(buffer_size)) == 0)
	mlw_raise_c_syserr(errno);
      (void)memcpy(buffer, fixed_buffer, buffer_size);
      if ((size = GetFullPathName(buffer, buffer_size, buffer, &final_name)) == 0) {
	free(buffer);
	mlw_raise_win32_syserr(GetLastError());
      }
      assert(size == buffer_size - 1);
    }
    /* Now parse out the root */
    /* We're looking for something of the form \\foo\bar\ or x:\ */
    {
      int type = 0; /* Assume normal drive type */
      char *root = buffer; /* Start looking at the beginning */
      if (*root == '\\') {
	/* Remote mounted type */
	root += 2;
	while (*root != '\\' && *root != '\0') root++;
	if (*root = '\0') {
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in GetFullPathName */
	}
	root++; /* Step past \ */
	while (*root != '\\' && *root != '\0') root++;
	if (*root = '\0') {
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in GetFullPathName */
	}
	root[1] = '\0'; /* Terminate the buffer after the root directory */
      } else {
	root[3] = '\0'; /* Terminate the buffer after the root directory */
      }
      DIAGNOSTIC(2, "Root directory for %s is %s", filename, root);
      /* Ok, now read the volume info */
      {
	DWORD length, flags;
	char fixed_buffer[MAX_PATH];
	BOOL res = GetVolumeInformation(root, NULL, 0, NULL, &length, &flags,
					fixed_buffer, MAX_PATH);
	DIAGNOSTIC(2, "Volume info %s", fixed_buffer, 0);
	if (res == TRUE) {
#define FAT "FAT"
#define NTFS "NTFS"
#define HPFS "HPFS"
	  if (strcmp(NTFS, fixed_buffer) == 0) {
	    /* No adjustment needed */
	    DIAGNOSTIC(2, "mtime not adjusted for NTFS", 0, 0);
	  } else {
	    if (strcmp(HPFS, fixed_buffer) == 0) {
	      /* dunno what to do with this one yet */
	      /* Apparently it's to do with OS2 */
	      DIAGNOSTIC(2, "mtime not adjusted for HPFS", 0, 0);
	    } else {
	      if (strcmp(FAT, fixed_buffer) == 0) {
		/* Adjust according to the timezone */
		DIAGNOSTIC(2, "Adjusted mtime for FAT = %lu, %lu", converted.dwHighDateTime, converted.dwLowDateTime);
		DIAGNOSTIC(2, "  mtime = %f", double_time(converted), 0);
		result->dwHighDateTime = converted.dwHighDateTime;
		result->dwLowDateTime = converted.dwLowDateTime;
	      } else {
		/* Oh dear, one we don't know about */
		DIAGNOSTIC(0, "File system type was %s unknown", fixed_buffer, 0);
		if (*root = '\0') {
		  if (buffer != fixed_buffer)
		    free(buffer);
		  mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in GetFullPathName */
		}
	      }
	    }
	  }
	} else {
	  /* Failed to get the info */
	  DIAGNOSTIC(0, "Failed to get volume info for %s", root, 0);
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in GetVolumeInformation */
	}
      }
    }
    if (buffer != fixed_buffer)
      free(buffer);
  }
}
@


1.3.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a6 4
 * Revision 1.3  1997/05/22  09:18:40  johnh
 * [Bug #01702]
 * Changing definition of mlw_raise_win32_syserr.
 *
@


1.3.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 4
 * Revision 1.3  1997/05/22  09:18:40  johnh
 * [Bug #01702]
 * Changing definition of mlw_raise_win32_syserr.
 *
@


1.3.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 4
 * Revision 1.3  1997/05/22  09:18:40  johnh
 * [Bug #01702]
 * Changing definition of mlw_raise_win32_syserr.
 *
@


1.2
log
@Merging in beta updates
@
text
@d7 3
a27 1
#include "exceptions.h"
d31 2
a32 1
#include "os_errors.h"		/* mlw_win32_strerror, mlw_os_syserror ... */
a34 11
static void mlw_raise_win32_syserr()
{
  int i= GetLastError();
  exn_raise_syserr(mlw_win32_strerror(i), (i<<1));
}

static void mlw_raise_c_syserr(int errno)
{
  exn_raise_syserr(strerror(errno), (errno<<1)|1);
}

d77 1
a77 1
    mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in MS */
d98 1
a98 1
      mlw_raise_win32_syserr();
d106 1
a106 1
	mlw_raise_win32_syserr();
d122 1
a122 1
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
d129 1
a129 1
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
d168 1
a168 1
		  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
d178 1
a178 1
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetVolumeInformation */
@


1.2.7.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.7.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.2.7.1  1997/05/12  10:45:01  hope
 * branched from 1.2
 *
@


1.2.7.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.2.7.1  1997/05/12  10:45:01  hope
 * branched from 1.2
 *
@


1.2.7.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.2.7.1  1997/05/12  10:45:01  hope
 * branched from 1.2
 *
@


1.2.7.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.2.7.1.1.1  1997/07/28  18:29:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.2.6.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.5.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.5.1.1.1
log
@branched from 1.2.5.1
@
text
@a6 3
 * Revision 1.2.5.1  1996/12/17  17:56:41  hope
 * branched from 1.2
 *
@


1.2.4.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.2.2.1.1.1
log
@branched from 1.2.2.1
@
text
@a6 3
 * Revision 1.2.2.1  1996/11/14  13:00:33  hope
 * branched from 1.2
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1996/10/07  17:01:55  jont
 * Merging in beta updates
 *
@


1.1
log
@new unit
@
text
@d6 11
a16 1
 * $Log$
d23 3
d28 3
d32 1
a32 1
int get_timezone(TIME_ZONE_INFORMATION *tz)
d34 3
a36 11
  DWORD result = GetTimeZoneInformation(tz);
  switch (result) {
    case TIME_ZONE_ID_DAYLIGHT:
    case TIME_ZONE_ID_STANDARD:
    {
/*
      LONG bias = tz->Bias;
      printf("bias is %ld\n", bias);
*/
      return 1;
    }
d38 3
a40 9
    case TIME_ZONE_ID_UNKNOWN:
    default:
    {
/*
      printf("No bias found\n");
*/
      return 0;
    }
  }
d51 1
a51 1
inline void time_stamp_clamp(FILETIME *t)
a54 1
  FILETIME ft;
d69 1
a69 1
  t-> dwLowDateTime = lo; /* And put the result back */
d73 1
a73 1
void set_timezone(TIME_ZONE_INFORMATION *tz)
d75 118
a192 1
  SetTimeZoneInformation(tz);
@


1.1.2.1
log
@branched from 1.1
@
text
@d6 1
a6 4
 * $Log: src:OS:Win32:time_zone.c,v $
 * Revision 1.1  1996/09/09  17:26:58  jont
 * new unit
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d6 1
a6 4
 * $Log: src:OS:Win32:time_zone.c,v $
 * Revision 1.1  1996/09/09  17:26:58  jont
 * new unit
 *
@


1.1.1.2
log
@Add ml_stat_sub for doing stuff common to ml_stat for Win95 and NT.
Includes stuff to deal with timezone variation problems on FAT
@
text
@a6 3
 * Revision 1.1.1.1  1996/09/13  11:25:04  hope
 * branched from 1.1
 *
a15 3
#include <assert.h>		/* assert */
#include "diagnostic.h"
#include "exceptions.h"
a17 3
#include "time_zone.h"
#include "os_errors.h"		/* mlw_win32_strerror, mlw_os_syserror ... */
#include "tags.h"
d19 1
a19 1
static void mlw_raise_win32_syserr()
d21 11
a31 3
  int i= GetLastError();
  exn_raise_syserr(mlw_win32_strerror(i), (i<<1));
}
d33 9
a41 3
static void mlw_raise_c_syserr(int errno)
{
  exn_raise_syserr(strerror(errno), (errno<<1)|1);
d52 1
a52 1
static void time_stamp_clamp(FILETIME *t)
d56 1
d71 1
a71 1
  t->dwLowDateTime = lo; /* And put the result back */
d75 1
a75 1
void ml_stat_sub(const char *filename, FILETIME *result)
d77 1
a77 118
  int bias;
  int res;
  FILETIME converted;

  res = FileTimeToLocalFileTime(result, &converted);
  if (res) {
    bias = ((result->dwHighDateTime == converted.dwHighDateTime) &&
	    (result->dwLowDateTime == converted.dwLowDateTime))
      ? 0 : 1;
  } else {
    mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in MS */
  }
  
/*
  message("Original time was %lu, %lu, %f", result->dwHighDateTime, result->dwLowDateTime, double_time(file_data.ftLastWriteTime));
*/
  DIAGNOSTIC(2, "  mtime = %lu, %lu", result->dwHighDateTime, result->dwLowDateTime);
  DIAGNOSTIC(2, "  mtime = %f", double_time((*result)), 0);
  
  time_stamp_clamp(result);
/*
  message("Clamped time is %lu, %lu, %f", result->dwHighDateTime, result->dwLowDateTime, double_time((*result)));
*/
  /* Now, if the bias is non-zero, see if we need to adjust the stamp */
  if (bias != 0) {
    char fixed_buffer[MAX_PATH];
    char *buffer = fixed_buffer;
    DWORD buffer_size = MAX_PATH;
    char *final_name;
    DWORD size = GetFullPathName(filename, MAX_PATH, buffer, &final_name);
    if (size <= 4) /* Any full path name should be at least this long */
      mlw_raise_win32_syserr();
    if (size >= buffer_size) {
      buffer_size = size;
      if ((buffer = malloc(buffer_size)) == 0)
	mlw_raise_c_syserr(errno);
      (void)memcpy(buffer, fixed_buffer, buffer_size);
      if ((size = GetFullPathName(buffer, buffer_size, buffer, &final_name)) == 0) {
	free(buffer);
	mlw_raise_win32_syserr();
      }
      assert(size == buffer_size - 1);
    }
    /* Now parse out the root */
    /* We're looking for something of the form \\foo\bar\ or x:\ */
    {
      int type = 0; /* Assume normal drive type */
      char *root = buffer; /* Start looking at the beginning */
      if (*root == '\\') {
	/* Remote mounted type */
	root += 2;
	while (*root != '\\' && *root != '\0') root++;
	if (*root = '\0') {
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
	}
	root++; /* Step past \ */
	while (*root != '\\' && *root != '\0') root++;
	if (*root = '\0') {
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
	}
	root[1] = '\0'; /* Terminate the buffer after the root directory */
      } else {
	root[3] = '\0'; /* Terminate the buffer after the root directory */
      }
      DIAGNOSTIC(2, "Root directory for %s is %s", filename, root);
      /* Ok, now read the volume info */
      {
	DWORD length, flags;
	char fixed_buffer[MAX_PATH];
	BOOL res = GetVolumeInformation(root, NULL, 0, NULL, &length, &flags,
					fixed_buffer, MAX_PATH);
	DIAGNOSTIC(2, "Volume info %s", fixed_buffer, 0);
	if (res == TRUE) {
#define FAT "FAT"
#define NTFS "NTFS"
#define HPFS "HPFS"
	  if (strcmp(NTFS, fixed_buffer) == 0) {
	    /* No adjustment needed */
	    DIAGNOSTIC(2, "mtime not adjusted for NTFS", 0, 0);
	  } else {
	    if (strcmp(HPFS, fixed_buffer) == 0) {
	      /* dunno what to do with this one yet */
	      /* Apparently it's to do with OS2 */
	      DIAGNOSTIC(2, "mtime not adjusted for HPFS", 0, 0);
	    } else {
	      if (strcmp(FAT, fixed_buffer) == 0) {
		/* Adjust according to the timezone */
		DIAGNOSTIC(2, "Adjusted mtime for FAT = %lu, %lu", converted.dwHighDateTime, converted.dwLowDateTime);
		DIAGNOSTIC(2, "  mtime = %f", double_time(converted), 0);
		result->dwHighDateTime = converted.dwHighDateTime;
		result->dwLowDateTime = converted.dwLowDateTime;
	      } else {
		/* Oh dear, one we don't know about */
		DIAGNOSTIC(0, "File system type was %s unknown", fixed_buffer, 0);
		if (*root = '\0') {
		  if (buffer != fixed_buffer)
		    free(buffer);
		  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetFullPathName */
		}
	      }
	    }
	  }
	} else {
	  /* Failed to get the info */
	  DIAGNOSTIC(0, "Failed to get volume info for %s", root, 0);
	  if (buffer != fixed_buffer)
	    free(buffer);
	  mlw_raise_win32_syserr(); /* Shouldn't happen, indicates bug in GetVolumeInformation */
	}
      }
    }
    if (buffer != fixed_buffer)
      free(buffer);
  }
@
