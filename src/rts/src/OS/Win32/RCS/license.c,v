head	1.29;
access;
symbols
	MLW_daveb_inline_1_4_99:1.29.1
	MLWorks_21c0_1999_03_25:1.29
	MLWorks_20c1_1998_08_20:1.29
	MLWorks_20c0_1998_08_04:1.27
	MLWorks_20b2c2_1998_06_19:1.25
	MLWorks_20b2_Windows_1998_06_12:1.25
	MLWorks_20b1c1_1998_05_07:1.23
	MLWorks_20b0_1998_04_07:1.23
	MLWorks_20b0_1998_03_20:1.22
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_MM_adapt:1.20.1
	MLWorks_20m1_1997_10_23:1.20
	MLWorks_11r1:1.10.1.2.1.9.1
	MLWorks_workspace_97:1.19.2
	MLWorks_dt_wizard:1.19.1
	MLWorks_11c0_1997_09_09:1.10.1.2.1.9
	MLWorks_10r3:1.10.1.2.3
	MLWorks_10r2_551:1.10.1.2.2
	MLWorks_11:1.10.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.10.1.2
	MLWorks_20m0_1997_06_20:1.12
	MLWorks_1_0_r2c2_1997_06_14:1.10.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.10.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.10.1
	MLWorks_BugFix_1997_04_24:1.10
	MLWorks_1_0_r2_Win32_1997_04_11:1.10
	MLWorks_1_0_r2_Unix_1997_04_04:1.10
	MM_ML_release_korma_1997_04_01:1.10
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.8.3.1.1
	MLWorks_gui_1996_12_18:1.8.4
	MLWorks_1_0_Win32_1996_12_17:1.8.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.1.1
	JFHrts:1.8.2
	MLWorks_1_0_Irix_1996_11_28:1.7.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.8.1
	MLWorks_1_0_Unix_1996_11_14:1.7.1
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ * @;


1.29
date	98.08.24.08.39.30;	author jkbrook;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	98.08.11.11.48.32;	author jkbrook;	state Exp;
branches;
next	1.27;

1.27
date	98.07.17.15.13.26;	author jkbrook;	state Exp;
branches;
next	1.26;

1.26
date	98.07.13.15.06.14;	author jkbrook;	state Exp;
branches;
next	1.25;

1.25
date	98.06.11.14.13.07;	author jkbrook;	state Exp;
branches;
next	1.24;

1.24
date	98.05.11.16.58.34;	author johnh;	state Exp;
branches;
next	1.23;

1.23
date	98.04.02.16.37.28;	author jkbrook;	state Exp;
branches;
next	1.22;

1.22
date	98.03.11.17.46.20;	author jkbrook;	state Exp;
branches;
next	1.21;

1.21
date	97.12.23.17.51.22;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	97.10.15.13.54.11;	author jont;	state Exp;
branches
	1.20.1.1;
next	1.19;

1.19
date	97.09.03.15.41.40;	author jkbrook;	state Exp;
branches
	1.19.1.1
	1.19.2.1;
next	1.18;

1.18
date	97.08.07.17.05.30;	author jkbrook;	state Exp;
branches;
next	1.17;

1.17
date	97.08.04.13.48.08;	author jkbrook;	state Exp;
branches;
next	1.16;

1.16
date	97.08.01.14.45.21;	author jkbrook;	state Exp;
branches;
next	1.15;

1.15
date	97.08.01.13.36.03;	author jkbrook;	state Exp;
branches;
next	1.14;

1.14
date	97.07.24.16.47.03;	author jkbrook;	state Exp;
branches;
next	1.13;

1.13
date	97.07.22.16.17.39;	author jkbrook;	state Exp;
branches;
next	1.12;

1.12
date	97.06.16.14.14.27;	author daveb;	state Exp;
branches;
next	1.11;

1.11
date	97.06.16.10.15.29;	author daveb;	state Exp;
branches;
next	1.10;

1.10
date	97.01.07.15.30.19;	author jont;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	96.12.19.12.06.54;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	96.11.19.13.14.27;	author jont;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1;
next	1.7;

1.7
date	96.11.13.15.41.26;	author daveb;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	96.11.12.12.30.00;	author daveb;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.09.56.25;	author daveb;	state Exp;
branches;
next	1.4;

1.4
date	96.10.23.11.25.09;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.10.22.14.28.34;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	96.07.31.12.21.54;	author stephenb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1;
next	1.1;

1.1
date	96.03.06.11.23.04;	author stephenb;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.21.41;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.11.44;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.30.27;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.11.14.12.56.24;	author hope;	state Exp;
branches
	1.7.1.1.1.1;
next	;

1.7.1.1.1.1
date	96.11.28.15.06.50;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	96.11.22.18.14.31;	author hope;	state Exp;
branches;
next	;

1.8.2.1
date	96.12.17.10.01.19;	author hope;	state Exp;
branches;
next	;

1.8.3.1
date	96.12.17.17.53.02;	author hope;	state Exp;
branches
	1.8.3.1.1.1;
next	;

1.8.3.1.1.1
date	97.02.24.11.43.55;	author hope;	state Exp;
branches;
next	;

1.8.4.1
date	96.12.18.09.47.37;	author hope;	state Exp;
branches;
next	;

1.10.1.1
date	97.05.12.10.40.00;	author hope;	state Exp;
branches;
next	1.10.1.2;

1.10.1.2
date	97.06.05.19.37.12;	author daveb;	state Exp;
branches
	1.10.1.2.1.1
	1.10.1.2.2.1
	1.10.1.2.3.1;
next	;

1.10.1.2.1.1
date	97.07.28.18.26.34;	author daveb;	state Exp;
branches;
next	1.10.1.2.1.2;

1.10.1.2.1.2
date	97.08.08.18.56.42;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.3;

1.10.1.2.1.3
date	97.08.11.08.42.52;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.4;

1.10.1.2.1.4
date	97.08.11.14.29.54;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.5;

1.10.1.2.1.5
date	97.08.11.15.35.44;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.6;

1.10.1.2.1.6
date	97.08.11.16.38.18;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.7;

1.10.1.2.1.7
date	97.08.11.17.31.55;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.8;

1.10.1.2.1.8
date	97.08.15.17.41.53;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.9;

1.10.1.2.1.9
date	97.09.04.11.36.21;	author jkbrook;	state Exp;
branches
	1.10.1.2.1.9.1.1;
next	;

1.10.1.2.1.9.1.1
date	97.10.07.11.52.25;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.1.9.1.2;

1.10.1.2.1.9.1.2
date	97.10.15.16.37.41;	author jkbrook;	state Exp;
branches;
next	;

1.10.1.2.2.1
date	97.09.08.17.19.43;	author daveb;	state Exp;
branches;
next	;

1.10.1.2.3.1
date	97.09.09.14.15.49;	author daveb;	state Exp;
branches;
next	1.10.1.2.3.2;

1.10.1.2.3.2
date	97.09.23.09.14.02;	author jkbrook;	state Exp;
branches;
next	1.10.1.2.3.3;

1.10.1.2.3.3
date	97.11.13.15.36.07;	author jkbrook;	state Exp;
branches;
next	;

1.19.1.1
date	97.09.10.19.33.06;	author brucem;	state Exp;
branches;
next	;

1.19.2.1
date	97.09.11.21.02.20;	author daveb;	state Exp;
branches;
next	;

1.20.1.1
date	97.10.31.13.45.11;	author nickb;	state Exp;
branches;
next	;

1.29.1.1
date	99.04.01.18.01.47;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This replaces src/rts/src/OS/{NT,Win95}/license.c
@


1.29
log
@[Bug #50100]
Set default to PERSONAL when license info is not found during
an interactive session
@
text
@/*  === LICENSING ===
 *
 *  Copyright (C) 1992 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  Uses the Harlequin License Server, and a timer interrupt.
 * 
 *  $Log: src:OS:Win32:license.c,v $
 * Revision 1.28  1998/08/11  11:48:32  jkbrook
 * [Bug #50100]
 * Fix continuing into Personal edition when license is invalid
 * now edition names have changed
 *
 * Revision 1.27  1998/07/17  15:13:26  jkbrook
 * [Bug #30436]
 * Update edition names
 *
 * Revision 1.26  1998/07/13  15:06:14  jkbrook
 * [Bug #30435]
 * Add function to set edition to free
 * and remove validation and storage code
 *
 * Revision 1.25  1998/06/11  14:13:07  jkbrook
 * [Bug #30411]
 * Handle free copies of MLWorks
 *
 * Revision 1.24  1998/05/11  16:58:34  johnh
 * [Bug #30303]
 * read edition.
 *
 * Revision 1.23  1998/04/02  16:37:28  jkbrook
 * [Bug #30382]
 * Convert date-chars to lower case before converting back from base 36
 *
 * Revision 1.22  1998/03/11  17:46:20  jkbrook
 * [Bug #50044]
 * Licence codes should not contain 0 or 1
 * or lower-case letters
 *
 * Revision 1.21  1997/12/23  17:51:22  jont
 * [Bug #30150]
 * Ensure allocation for key values is large enough for trailing zero
 *
 * Revision 1.20  1997/10/15  13:54:11  jont
 * [Bug #20072]
 * check_edition can pass unterminated strings to atoi. Fix this
 *
 * Revision 1.19  1997/09/03  15:41:40  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
 * Revision 1.18  1997/08/07  17:05:30  jkbrook
 * [Bug #30223]
 *  Shortening license codes by using base 36 for date elements and
 *  reducing CHECK_CHARS from 10 to 8
 *
 * Revision 1.17  1997/08/04  13:48:08  jkbrook
 * [Bug #20072]
 * Adding edition info (e.g., student, personal) to licensing
 *
 * Revision 1.16  1997/08/01  14:45:21  jkbrook
 * [Bug #20073]
 * Added datatype license_check_result for more flexible reporting
 * of license validation/checking results.
 *
 * Revision 1.15  1997/08/01  13:36:03  jkbrook
 * [Bug #30223]
 * Shorten license codes by removing number
 *
 * Revision 1.14  1997/07/24  16:47:03  jkbrook
 * [Bug #20077]
 * Adding an install-by date
 *
 * Revision 1.13  1997/07/22  16:17:39  jkbrook
 * [Bug #20077]
 * License expiry should be to the nearest day
 *
 * Revision 1.12  1997/06/16  14:14:27  daveb
 * [Bug #30176]
 * Removed the version sub-key of the MLWorks key.
 *
 * Revision 1.11  1997/06/16  10:15:29  daveb
 * [Bug #30169]
 * Updated version strings for 2.0m0.
 *
 * Revision 1.10  1997/01/07  15:30:19  jont
 * [Bug #1884]
 * Distinguish invalid licenses from expired licenses
 *
 * Revision 1.9  1996/12/19  12:06:54  jont
 * [Bug #1838]
 * Add license to contact message
 *
 * Revision 1.8  1996/11/19  13:14:27  jont
 * [Bug #0]
 * Modify to use initial section of the code for checking
 * as opposed to unix version which uses the final section
 *
 * Revision 1.7  1996/11/13  15:41:26  daveb
 * Added expiry date to licenses.
 * Also corrected definition of license_error_string.
 *
 * Revision 1.6  1996/11/12  12:30:00  daveb
 * Updated expiry message.
 *
 * Revision 1.5  1996/11/12  09:56:25  daveb
 * Added license checking for Windows.
 *
 * Revision 1.4  1996/10/23  11:25:09  jont
 * [Bug #1693]
 * Add flag to indicate how to process license failure
 *
 * Revision 1.3  1996/10/22  14:28:34  jont
 * new unit
 * New license serving stuff
 *
 *
 */

#include "environment.h"
#include "allocator.h"
#include "license.h"
#include "mltypes.h"
#include "utils.h"
#include "values.h"
#include "sha.h"
#include "mlw_mklic.h"
#include "diagnostic.h"
#include "version.h"
#include <ctype.h>
#include <stdlib.h>
#include <windows.h>

int license_failure_hang = 1;
DWORD license_size = 20;  
DWORD line_size = 1024;

/* default to version with delivery capability for delivered apps */

enum edition license_edition = PROFESSIONAL;

/* default to trying to get edition from license if present */

int act_as_free = 0;

static char c_license_error_invalid[] = LICENSE_ERROR_INVALID;
static char c_license_error_expired[] = LICENSE_ERROR_EXPIRED;
static char c_license_error_installdate[] = LICENSE_ERROR_INSTALL;
static char c_license_error_version[] = LICENSE_ERROR_VERSION;
static char c_license_error_chars[] = LICENSE_ERROR_CHARS;

static mlval license_error_invalid(mlval arg)
{
  return ml_string(c_license_error_invalid);
}

static mlval license_error_expired(mlval arg)
{
  return ml_string(c_license_error_expired);
}

static mlval license_error_installdate(mlval arg)
{
  return ml_string(c_license_error_installdate);
}

static mlval license_error_version(mlval arg)
{
  return ml_string(c_license_error_version);
}

static mlval license_error_chars(mlval arg)
{
  return ml_string(c_license_error_chars);
}

static mlval mlw_license_check_result_make (enum license_check_result index)
{
  return MLINT(index);
}

/* open_mlworks_key opens the key where the license is stored in the
   registry */
static int open_mlworks_key(HKEY *result) {
  DWORD disposition;
  HKEY software;
 
  char * edition_key;

  static char key_stem[] = "Harlequin\\MLWorks\\";

  edition_key = malloc (strlen(key_stem) + strlen(VERSION_STR) + 1);
  strcpy(edition_key,key_stem);
  strcat(edition_key,VERSION_STR);

  if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, "SOFTWARE", 0, /* NULL, */
		    KEY_EXECUTE, &software) == ERROR_SUCCESS) {
    if (RegCreateKeyEx (software, edition_key, 0, NULL,
		        REG_OPTION_NON_VOLATILE, KEY_EXECUTE|KEY_WRITE, NULL,
		        result, &disposition) == ERROR_SUCCESS) {
      return 1;
 
    } else {
      DIAGNOSTIC(1,"Could not open HKEY_LOCAL_MACHINE\\SOFTWARE\\%s",edition_key,0);
      message_stderr
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks'"
         " in the registry");
      free(edition_key);
      return 0;
    }
  } else {
    message_stderr ("In license.c");
    message_stderr
      ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE' "
       "in the registry");
    free(edition_key);
    return 0;
  }
}

static char* query_value (HKEY hkey, char* vkey)
{
  DWORD len = 0;
  char *buffer;
  int status;

  status = RegQueryValueEx(hkey, vkey, NULL, NULL, NULL, &len);
  if (status != ERROR_SUCCESS) {
    DIAGNOSTIC (1, "Can't find %s in the registry", vkey, 0);
    return NULL;
  }

  buffer = malloc(len+1);
  if (buffer == NULL) {
    DIAGNOSTIC (1, "Can't malloc license string", 0, 0);
    return NULL;
  }

  status = RegQueryValueEx(hkey, vkey, NULL, NULL, buffer, &len);
     
  if (status != ERROR_SUCCESS) {
    free(buffer);
    return NULL;
  }
  else {
    buffer[len] = '\0';
    return buffer;
  }

}

/* get_license returns the encoded license info from the registry. */
static int get_license(char **name, char **code)
{
  HKEY hkey;

  if (open_mlworks_key(&hkey)) {
    *name = query_value(hkey, "User");
    if (*name == NULL)
      return 0;

    *code = query_value(hkey, "License");
    if (*code == NULL) {
      free(*name);
      return 0;
    }

    return 1;
  }
  else {
    DIAGNOSTIC (1, "open_mlworks_key failed", NULL, NULL);
    return 0;
  }
}

static int base_36_to_decimal (char d)
{
   int result;

   if (isalpha(d))
     result = ((int)(tolower(d)) - (int)('a')) + 10;
   else
     result = (int)(d) - (int)('0');

   return result;
};

 /* check_date checks that the current date is before the date argument.
  * Its argument is a pointer to the expiry/install-by date, which is 
  * assumed to be DATE_CHARS long.  It is not assumed to be null-terminated  
  * after these chars.
 */

static int check_date(char *date)
{
  struct tm *tm;
  char year_36, month_36, day_36;
  int year, month, day;
  time_t now;

  /* if sscanf fails here it may mean that we are checking an old license
   * with expiry date of form mmyy.  An appropriate message should
   * be printed (rather than license expired as here).
   */

  if (sscanf (date, "%1c%1c%1c", &day_36, &month_36, &year_36) < 3) {
    DIAGNOSTIC(1, "sscanf failed", 0, 0);
    return 0;
  };

  /* convert back to decimal and remove offset */

  day = base_36_to_decimal(day_36) - 2;
  month = base_36_to_decimal(month_36) - 2;
  year = base_36_to_decimal(year_36) - 2;

  /* convert back to last-two-digits-of-year format in decimal */
  if (year < 10)
    year += 90;  /* C20 dates */
  else
    year -= 10;  /* C21 dates */

  if (year < 90)
    year += 100;

  if (time(&now) < 0) {
    DIAGNOSTIC(1, "time failed", 0, 0);
    return 0;
  }
  tm = localtime(&now);
  /* struct tm numbers months from 0, whereas we number them from 1. */
   if (tm->tm_year > year || 
       (tm->tm_year == year && tm->tm_mon >= month) ||
       (tm->tm_year == year && tm->tm_mon == (month - 1) && tm->tm_mday > day)) {
    return 0;
  }

  /* Don't free tm; it's a static value in the library. */
  return 1;
}

static mlval license_get_edition(mlval arg)
{
  if (act_as_free) {
    return MLINT(PERSONAL);
  } else {
    return MLINT(license_edition);
  }
}

/* used to default to PERSONAL when license is corrupt in registry
    but user continues into a session, since actual default is Personal */
/* unit -> edition */

static mlval license_set_edition(mlval arg)
{
   license_edition = PERSONAL;
   DIAGNOSTIC(1,"Setting edition to Personal",0,0);

   return 0;
}

static int convert_edition(char edition) 
{
  return (((edition - '0') - 2));
}

/* license_check checks an existing license */
/* unit -> license_check_result */
/* Returns
 * NOT_FOUND        No license found -- run as Free
 * INVALID          License found but invalid
 * OK               License found and ok -- run as non-Free
 * EXPIRED          License found but expired
 * ILLEGAL_CHARS    Code contains zero or one
 */
static mlval license_check(mlval arg)
{
  char *name, *code;
  mlval result = MLUNIT;

  /* default for interactive versions */

  license_edition = PERSONAL;

  if (get_license(&name, &code)) {
    SHA_INFO sha_info;
    char *input, *sha_result;
    DWORD serial_num;
    int len;

    if (!GetVolumeInformation("C:\\", NULL, 0, &serial_num,
			      NULL, NULL, NULL, 0)) {
      result = mlw_license_check_result_make(NOT_FOUND);
      goto no_serial_num;
    }
    len = strlen(name);
    input = malloc(len + sizeof(DWORD) + 1);
    if (input == NULL)
      error("malloc failed");
    strcpy(input,name);
    memcpy(input+len, (char*)&serial_num, sizeof(DWORD));
    input[len + sizeof(DWORD)] = '\0';

    sha_string(&sha_info, input, len+sizeof(DWORD));
    sha_result = sha_sprint(&sha_info);


    if ((strcmp(sha_result,code) == 0)) {
	if (check_date(name)) {
	  DIAGNOSTIC (1, "License is valid", 0, 0);
          license_edition = convert_edition(name[DATE_CHARS]);
	  DIAGNOSTIC (1, "License edition set to %d", license_edition, 0);
	  result = mlw_license_check_result_make(OK);
	} else {
	  result = mlw_license_check_result_make(EXPIRED);
	}
    } else {
      result = mlw_license_check_result_make(INVALID);
    }

    free(input);
    free(sha_result);
 no_serial_num:
    free(name);
    free(code);
  } else {
    result = mlw_license_check_result_make(NOT_FOUND);
  }
  DIAGNOSTIC (1, "Edition is : %d", license_edition, 0);
  return result;
}

void license_release(void)
{
  /* No action required on Windows for this one */
}

void license_init(void)
{
  env_function("license check", license_check);
  env_function("license error expired", license_error_expired);
  env_function("license error invalid", license_error_invalid);
  env_function("license error install date", license_error_installdate);
  env_function("license error wrong version", license_error_version);
  env_function("license error illegal chars", license_error_chars);

  env_function("license get edition", license_get_edition);

  env_function("license set edition", license_set_edition);

  license_failure_hang = 1; /* Default wait for user interaction */
  act_as_free = 0; /* Default: check for license and set edition */

}

@


1.29.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a9 5
 * Revision 1.29  1998/08/24  08:39:30  jkbrook
 * [Bug #50100]
 * Set default to PERSONAL when license info is not found during
 * an interactive session
 *
@


1.28
log
@[Bug #50100]
Fix continuing into Personal edition when license is invalid
now edition names have changed
@
text
@d10 5
d383 4
a391 4

    /* default for interactive versions */

    license_edition = PERSONAL;
@


1.27
log
@[Bug #30436]
Update edition names
@
text
@d10 4
d343 1
a343 1
    return MLINT(env_lookup("license edition"));
d353 2
a354 2
   license_edition = mlw_license_check_result_make(PERSONAL);
   env_value("license edition", license_edition);
d384 4
d404 1
a408 1
          env_value("license edition",license_edition);
a423 2
    license_edition = PERSONAL;
    env_value("license edition",license_edition);
a446 4

  /* Default to an edition allowing delivery for use from executables */

  env_value("license edition",license_edition);
@


1.26
log
@[Bug #30435]
Add function to set edition to free
and remove validation and storage code
@
text
@d10 5
d132 1
a132 1
enum edition license_edition = PERSONAL;
d337 1
a337 1
    return MLINT(FREE);
d343 1
a343 1
/* used to default to FREE when license is corrupt in registry
d349 1
a349 1
   license_edition = mlw_license_check_result_make(FREE);
d416 1
a416 1
    license_edition = FREE;
@


1.25
log
@[Bug #30411]
Handle free copies of MLWorks
@
text
@d10 4
a262 46
/* license_store stores the license and its encoded form in the file system. */
/* string -> bool */
static mlval license_store(mlval arg)
{
  mlval result = MLUNIT;
  HKEY hkey;
  char *name;
  SHA_INFO sha_info;
  DWORD serial_num;
  char *input, *sha_result;
  int len;

  name = CSTRING(arg);
  len = strlen(name);
  if (!GetVolumeInformation("C:\\", NULL, 0, &serial_num,
			    NULL, NULL, NULL, 0))
    return MLFALSE;

  input = malloc(len + sizeof(DWORD) + 1);
  if (input == NULL)
    error("malloc failed");
  strcpy(input,name);
  memcpy(input+len, (char*)&serial_num, sizeof(DWORD));
  input[len+sizeof(DWORD)] = '\0';

  sha_string(&sha_info, input, len + sizeof(DWORD));
  sha_result = sha_sprint(&sha_info);

  if (open_mlworks_key(&hkey))
    if ((RegSetValueEx(hkey, "User", 0, REG_BINARY,
		       name, strlen(name)) == ERROR_SUCCESS) &&
        (RegSetValueEx(hkey, "License", 0, REG_BINARY,
		       sha_result, strlen(sha_result)) == ERROR_SUCCESS))
      result = MLTRUE;
    else
      result = MLFALSE;
  else
    result = MLFALSE;

  free(input);
  free(sha_result);
  return result;
}

/* conversion from base 36 to decimal */

a274 29
/* conversion from input format of SHA (upper case and omitting 0,1) to
internal format */

static char * convert_code (char * code_string) 
{
  
  char *result;
  int i;

  result = malloc(CHECK_CHARS);

  strncpy(result, code_string, CHECK_CHARS);

  for (i = 0; i < CHECK_CHARS; i++) {
     if (result[i] == '@@') {
       result[i] = '0';
     } else if (result[i] == '%') {
       result[i] = '1';
     } else if (isalpha(result[i])) {
       result[i] = tolower(result[i]);
     };
  };

  result[CHECK_CHARS] = '\0';

  return result;
};


d338 5
a342 1
static int convert_edition(char edition) 
d344 4
a347 1
  return (((edition - '0') - 2));
d350 1
a350 1
static int check_chars(char *code_string) 
d352 1
a352 10
  int len, i;

  len = strlen(code_string);

  for (i = 0; i < len; i++) {
    if (code_string[i] == '0' || code_string[i] == '1') {
      return 0;
    }
  }
  return 1;
a418 70
/* license_validate checks that the user's input is valid, by repeating the
 * hash operation described above.
 */
/* string * string -> license_check_result */
static mlval license_validate(mlval arg)
{
  char *name = CSTRING(FIELD(arg,0));
  char *check = CSTRING(FIELD(arg,1));
  SHA_INFO sha_info;
  char *input, *sha_result, *convert_check;
  mlval result;

  /* The validation algorithm takes the name, appends the edition 
     and the installation and expiry dates, calls SHA, and compares the last
     ten digits of the result with the first ten of the check digits 
     after transformation to restore 0 and 1. 
  */
  if (strlen(check) != CHECK_CHARS + EDITION_CHARS + (2 * DATE_CHARS)) {
    DIAGNOSTIC (1, "License code has %d characters", strlen(check), 0);
    return MLFALSE;
  }

  input = malloc(strlen(name) + EDITION_CHARS + (2 * DATE_CHARS) + 1);
  if (input == NULL)
    error("malloc failed");

  strcpy (input, name);
  strcat (input, convert_code(check + CHECK_CHARS));

  if (!check_chars(check)) {
    result = mlw_license_check_result_make(ILLEGAL_CHARS);
    return(result);
  }

  convert_check = convert_code(check); 

  sha_string(&sha_info, input, strlen(input));
  sha_result = sha_sprint(&sha_info);
 
  /* Validation results:
   INVALID           license invalid (check failed)
   OK                license OK wrt to installation and expiry dates
   EXPIRED           expiry date passed
   INSTALLDATE       installation date passed
   WRONG_EDITION     license is for a different edition (e.g., student, personal)
  */

  /* default */
  result = mlw_license_check_result_make(INVALID);

  if ((strncmp(convert_check, sha_result, CHECK_CHARS)) == 0) {
      /* check installation date */
      if (check_date (check+CHECK_CHARS+EDITION_CHARS)) {
	if (check_date(&check[CHECK_CHARS+EDITION_CHARS+DATE_CHARS])) {
	  result = mlw_license_check_result_make(OK);
	} else {
	  result = mlw_license_check_result_make(EXPIRED);
	}
      } else {
	result = mlw_license_check_result_make(INSTALLDATE);
      }
  } else {
    result = mlw_license_check_result_make(INVALID);
  }

  free(input);
  free(sha_result);
  return result;
}

a425 1
  env_function("license validate", license_validate);
a426 1
  env_function("license store", license_store);
d434 2
@


1.24
log
@[Bug #30303]
read edition.
@
text
@d10 4
d112 1
d121 8
d170 8
d180 2
a181 2
		    KEY_EXECUTE, &software) == ERROR_SUCCESS)
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks", 0, NULL,
d183 1
a183 1
		        result, &disposition) == ERROR_SUCCESS)
d185 3
a187 1
    else {
d191 1
d194 2
a195 1
  else {
d199 1
d402 5
a406 1
  return MLINT(EDITION);
d409 1
a409 1
static int check_edition(char edition) 
d411 1
a411 1
  return ((edition - '0') == (EDITION + 2));
d431 1
a431 1
 * NOT_FOUND        No license found
d433 1
a433 1
 * OK               License found and ok
a464 1
      if (check_edition(name[DATE_CHARS])) {
d467 3
a473 3
      } else {
        result = mlw_license_check_result_make(WRONG_EDITION);
      }
d484 2
d488 1
a542 1
    if (check_edition (check[CHECK_CHARS])) {
a552 3
    } else {
      result = mlw_license_check_result_make(WRONG_EDITION);
    }
d580 4
d585 1
d588 1
@


1.23
log
@[Bug #30382]
Convert date-chars to lower case before converting back from base 36
@
text
@d10 4
d374 5
d436 2
a437 2
        if (check_date(name)) {
  	  DIAGNOSTIC (1, "License is valid", 0, 0);
d439 1
a439 1
        } else {
d441 1
a441 1
        }
d512 10
a521 10
        /* check installation date */
        if (check_date (check+CHECK_CHARS+EDITION_CHARS)) {
          if (check_date(&check[CHECK_CHARS+EDITION_CHARS+DATE_CHARS])) {
            result = mlw_license_check_result_make(OK);
          } else {
            result = mlw_license_check_result_make(EXPIRED);
          }
        } else {
          result = mlw_license_check_result_make(INSTALLDATE);
        }
d549 2
@


1.22
log
@[Bug #50044]
Licence codes should not contain 0 or 1
or lower-case letters
@
text
@d10 5
d279 2
a280 2
   if (islower(d))
     result = ((int)(d) - (int)('a')) + 10;
@


1.21
log
@[Bug #30150]
Ensure allocation for key values is large enough for trailing zero
@
text
@d10 4
d111 1
d133 5
d282 29
d334 1
a334 1
  /* convert back to decimal */
d336 3
a338 3
  day = base_36_to_decimal(day_36);
  month = base_36_to_decimal(month_36);
  year = base_36_to_decimal(year_36);
d367 1
a367 1
  return (edition - '0' == EDITION);
d370 13
d391 1
d455 1
a455 1
  char *input, *sha_result;
d460 3
a462 1
     ten digits of the result with the first ten of the check digits. */
d473 8
a480 1
  strcat (input, check + CHECK_CHARS);
d496 1
a496 1
  if ((strncmp(check, sha_result, CHECK_CHARS)) == 0) {
d534 1
@


1.20
log
@[Bug #20072]
check_edition can pass unterminated strings to atoi. Fix this
@
text
@d10 4
d171 1
a171 1
  buffer = malloc(len);
@


1.20.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a9 4
 * Revision 1.20  1997/10/15  13:54:11  jont
 * [Bug #20072]
 * check_edition can pass unterminated strings to atoi. Fix this
 *
@


1.19
log
@[Bug #30227]
Include mlw_mklic.h instead of register.h
@
text
@d10 4
d324 2
a325 7
  int i;
  i = atoi(&edition);
  if (i == EDITION) 
    return 1; 
  else 
    return 0;
};
@


1.19.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a9 4
 * Revision 1.19  1997/09/03  15:41:40  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
@


1.19.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a9 4
 * Revision 1.19  1997/09/03  15:41:40  jkbrook
 * [Bug #30227]
 * Include mlw_mklic.h instead of register.h
 *
@


1.18
log
@[Bug #30223]
 Shortening license codes by using base 36 for date elements and
 reducing CHECK_CHARS from 10 to 8
@
text
@d10 5
d85 1
a85 1
#include "register.h"
@


1.17
log
@[Bug #20072]
Adding edition info (e.g., student, personal) to licensing
@
text
@d10 4
d82 2
d245 14
d268 1
d277 1
a277 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 3) {
d280 14
a293 1
  }
@


1.16
log
@[Bug #20073]
Added datatype license_check_result for more flexible reporting
of license validation/checking results.
@
text
@d10 5
d87 1
d104 5
d279 11
d326 7
a332 3
      if (check_date(name)) {
	DIAGNOSTIC (1, "License is valid", 0, 0);
	result = mlw_license_check_result_make(OK);
d334 1
a334 1
	result = mlw_license_check_result_make(EXPIRED);
d363 2
a364 2
  /* The validation algorithm takes the name, appends the installation
     and expiry dates, calls SHA, and compares the last
d366 1
a366 1
  if (strlen(check) != CHECK_CHARS + (2 * DATE_CHARS)) {
d371 1
a371 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + 1);
d386 1
d393 8
a400 4
      /* check installation date */
      if (check_date (check+CHECK_CHARS)) {
        if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
          result = mlw_license_check_result_make(OK);
d402 1
a402 1
          result = mlw_license_check_result_make(EXPIRED);
d404 3
a406 3
      } else {
        result = mlw_license_check_result_make(INSTALLDATE);
      }
d429 1
@


1.15
log
@[Bug #30223]
Shorten license codes by removing number
@
text
@d10 4
d98 5
d269 1
a269 1
/* unit -> bool option option */
d271 4
a274 4
 * NONE             No license found
 * SOME NONE        License found but invalid
 * SOME(SOME true)  License found and ok
 * SOME(SOME false) License found but expired
d289 1
a289 1
      result = mlw_option_make_none();
d306 1
a306 1
	result = mlw_option_make_some(mlw_option_make_some(MLTRUE));
d308 1
a308 1
	result = mlw_option_make_some(mlw_option_make_some(MLFALSE));
d311 1
a311 1
      result = mlw_option_make_some(mlw_option_make_none());
d320 1
a320 1
    result = mlw_option_make_none();
d328 1
a328 1
/* string * string -> bool option */
d356 4
a359 3
   NONE           license invalid (check failed)
   SOME (TRUE)    license OK wrt to installation and expiry dates
   SOME (FALSE)   installation date passed
d363 1
a363 1
  result = mlw_option_make_none();
d369 3
a371 1
          result = mlw_option_make_some(MLTRUE);
d374 1
a374 1
        result = mlw_option_make_some(MLFALSE);
d377 1
a377 1
    result = mlw_option_make_none();
@


1.14
log
@[Bug #20077]
Adding an install-by date
@
text
@d10 4
d328 2
a329 2
  /* The validation algorithm takes the name, appends the three digit
     number from the check digits, calls SHA, and compares the last
d331 1
a331 1
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + (2 * DATE_CHARS)) {
d336 1
a336 1
  input = malloc(strlen(name) + NUMBER_CHARS + (2 * DATE_CHARS) + 1);
d357 2
a358 2
      if (check_date (check+CHECK_CHARS+NUMBER_CHARS)) {
        if (check_date(&check[CHECK_CHARS+NUMBER_CHARS+DATE_CHARS])) {
@


1.13
log
@[Bug #20077]
License expiry should be to the nearest day
@
text
@d10 4
d68 1
a68 1
DWORD license_size = 20;
d73 1
d85 5
d215 4
a218 4
/* check_date checks that the current date is before the expiry date.
 * Its argument is a pointer to the expiry date, which is assumed to
 * be DATE_CHARS long.  It is not assumed to be null-terminated after
 * these chars.
d220 1
d227 6
a232 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 2) {
d315 1
a315 1
/* string * string -> bool */
d326 2
a327 2
     the digits of the result with the first ten of the check digits. */
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + DATE_CHARS) {
d332 1
a332 1
  input = malloc(strlen(name) + NUMBER_CHARS + DATE_CHARS + 1);
d341 22
a362 6

  if ((strncmp(check, sha_result, CHECK_CHARS) == 0) &&
      check_date (check+CHECK_CHARS+NUMBER_CHARS))
    result = MLTRUE;
  else
    result = MLFALSE;
d381 1
@


1.12
log
@[Bug #30176]
Removed the version sub-key of the MLWorks key.
@
text
@d10 4
d213 1
a213 1
  int year, month;
d216 1
a216 1
  if (sscanf (date, "%2d%2d", &month, &year) < 2) {
d229 3
a231 1
  if (tm->tm_year > year || (tm->tm_year == year && tm->tm_mon >= month)) {
@


1.11
log
@[Bug #30169]
Updated version strings for 2.0m0.
@
text
@d10 4
d84 1
a84 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\2.0", 0, NULL,
d90 1
a90 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\2.0'"
d345 1
@


1.10
log
@[Bug #1884]
Distinguish invalid licenses from expired licenses
@
text
@d10 4
d80 1
a80 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\1.0", 0, NULL,
d86 1
a86 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\1.0'"
@


1.10.1.1
log
@branched from 1.10
@
text
@a9 4
 * Revision 1.10  1997/01/07  15:30:19  jont
 * [Bug #1884]
 * Distinguish invalid licenses from expired licenses
 *
@


1.10.1.2
log
@[Bug #30168]
Updated version number.
@
text
@a9 3
 * Revision 1.10.1.1  1997/05/12  10:40:00  hope
 * branched from 1.10
 *
d80 1
a80 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\1.0r2", 0, NULL,
d86 1
a86 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\1.0r2'"
@


1.10.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a9 4
 * Revision 1.10.1.2  1997/06/05  19:37:12  daveb
 * [Bug #30168]
 * Updated version number.
 *
@


1.10.1.2.3.2
log
@[Bug #30271]
Updating version strings for 1.0r3
@
text
@a9 3
 * Revision 1.10.1.2.3.1  1997/09/09  14:15:49  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d87 1
a87 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\1.0r3", 0, NULL,
d93 1
a93 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\1.0r3'"
@


1.10.1.2.3.3
log
@[Bug #30271]
Changing version number from 1.0r3 to 1.0r2
@
text
@a9 4
 * Revision 1.10.1.2.3.2  1997/09/23  09:14:02  jkbrook
 * [Bug #30271]
 * Updating version strings for 1.0r3
 *
d90 1
a90 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\1.0r2", 0, NULL,
d96 1
a96 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\1.0r2'"
@


1.10.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a9 4
 * Revision 1.10.1.2  1997/06/05  19:37:12  daveb
 * [Bug #30168]
 * Updated version number.
 *
@


1.10.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a9 4
 * Revision 1.10.1.2  1997/06/05  19:37:12  daveb
 * [Bug #30168]
 * Updated version number.
 *
@


1.10.1.2.1.2
log
@[Bug #20077]
Merging into 1.1:
License expiry should be to the nearest day
@
text
@a9 3
 * Revision 1.10.1.2.1.1  1997/07/28  18:26:34  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
d212 1
a212 1
  int year, month, day;
d215 1
a215 1
  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 2) {
d228 1
a228 3
   if (tm->tm_year > year || 
       (tm->tm_year == year && tm->tm_mon >= month) ||
       (tm->tm_year == year && tm->tm_mon == (month - 1) && tm->tm_mday > day)) {
@


1.10.1.2.1.3
log
@[Bug #20077]
Merging into 1.1
Adding install-by date
@
text
@a9 5
 * Revision 1.10.1.2.1.2  1997/08/08  18:56:42  jkbrook
 * [Bug #20077]
 * Merging into 1.1:
 * License expiry should be to the nearest day
 *
d66 1
a66 1
DWORD license_size = 20;  
a70 1
static char c_license_error_installdate[] = LICENSE_ERROR_INSTALL;
a81 5
static mlval license_error_installdate(mlval arg)
{
  return ml_string(c_license_error_installdate);
}

d207 4
a210 4
 /* check_date checks that the current date is before the date argument.
  * Its argument is a pointer to the expiry/install-by date, which is 
  * assumed to be DATE_CHARS long.  It is not assumed to be null-terminated  
  * after these chars.
a211 1

d218 1
a218 6
  /* if sscanf fails here it may mean that we are checking an old license
   * with expiry date of form mmyy.  An appropriate message should
   * be printed (rather than license expired as here).
   */

  if (sscanf (date, "%2d%2d%2d", &day, &month, &year) < 3) {
d301 1
a301 1
/* string * string -> bool option */
d312 2
a313 2
     ten digits of the result with the first ten of the check digits. */
  if (strlen(check) != CHECK_CHARS + NUMBER_CHARS + (2 * DATE_CHARS)) {
d318 1
a318 1
  input = malloc(strlen(name) + NUMBER_CHARS + (2 * DATE_CHARS) + 1);
d327 6
a332 22
 
  /* Validation results:
   NONE           license invalid (check failed)
   SOME (TRUE)    license OK wrt to installation and expiry dates
   SOME (FALSE)   installation date passed
  */

  /* default */
  result = mlw_option_make_none();

  if ((strncmp(check, sha_result, CHECK_CHARS)) == 0) {
      /* check installation date */
      if (check_date (check+CHECK_CHARS+NUMBER_CHARS)) {
        if (check_date(&check[CHECK_CHARS+NUMBER_CHARS+DATE_CHARS])) {
          result = mlw_option_make_some(MLTRUE);
        }
      } else {
        result = mlw_option_make_some(MLFALSE);
      }
  } else {
    result = mlw_option_make_none();
  }
a350 1
  env_function("license error install date", license_error_installdate);
@


1.10.1.2.1.4
log
@[Bug #30223]
Merging into 1.1:
Shorten license codes by removing number
@
text
@a9 5
 * Revision 1.10.1.2.1.3  1997/08/11  08:42:52  jkbrook
 * [Bug #20077]
 * Merging into 1.1
 * Adding install-by date
 *
d327 2
a328 2
  /* The validation algorithm takes the name, appends the installation
     and expiry dates, calls SHA, and compares the last
d330 1
a330 1
  if (strlen(check) != CHECK_CHARS + (2 * DATE_CHARS)) {
d335 1
a335 1
  input = malloc(strlen(name) + (2 * DATE_CHARS) + 1);
d356 2
a357 2
      if (check_date (check+CHECK_CHARS)) {
        if (check_date(&check[CHECK_CHARS+DATE_CHARS])) {
@


1.10.1.2.1.5
log
@[Bug #20073]
Merging into 1.1:
Adding license_check_result datatype/enum
@
text
@a9 5
 * Revision 1.10.1.2.1.4  1997/08/11  14:29:54  jkbrook
 * [Bug #30223]
 * Merging into 1.1:
 * Shorten license codes by removing number
 *
a97 5
static mlval mlw_license_check_result_make (enum license_check_result index)
{
  return MLINT(index);
}

d264 1
a264 1
/* unit -> license_check_result */
d266 4
a269 4
 * NOT_FOUND        No license found
 * INVALID          License found but invalid
 * OK               License found and ok
 * EXPIRED          License found but expired
d284 1
a284 1
      result = mlw_license_check_result_make(NOT_FOUND);
d301 1
a301 1
	result = mlw_license_check_result_make(OK);
d303 1
a303 1
	result = mlw_license_check_result_make(EXPIRED);
d306 1
a306 1
      result = mlw_license_check_result_make(INVALID);
d315 1
a315 1
    result = mlw_license_check_result_make(NOT_FOUND);
d323 1
a323 1
/* string * string -> license_check_result */
d351 3
a353 4
   INVALID           license invalid (check failed)
   OK                license OK wrt to installation and expiry dates
   EXPIRED           expiry date passed
   INSTALLDATE       installation date passed
d357 1
a357 1
  result = mlw_license_check_result_make(INVALID);
d363 1
a363 3
          result = mlw_license_check_result_make(OK);
        } else {
          result = mlw_license_check_result_make(EXPIRED);
d366 1
a366 1
        result = mlw_license_check_result_make(INSTALLDATE);
d369 1
a369 1
    result = mlw_license_check_result_make(INVALID);
@


1.10.1.2.1.6
log
@[Bug #20072]
Merging into 1.1:
Adding edition info
@
text
@a9 5
 * Revision 1.10.1.2.1.5  1997/08/11  15:35:44  jkbrook
 * [Bug #20073]
 * Merging into 1.1:
 * Adding license_check_result datatype/enum
 *
a86 1
static char c_license_error_version[] = LICENSE_ERROR_VERSION;
a102 5
static mlval license_error_version(mlval arg)
{
  return ml_string(c_license_error_version);
}

a272 11
static int check_edition(char edition) 
{
  int i;
  i = atoi(&edition);
  if (i == EDITION) 
    return 1; 
  else 
    return 0;
};


d309 3
a311 7
      if (check_edition(name[DATE_CHARS])) {
        if (check_date(name)) {
  	  DIAGNOSTIC (1, "License is valid", 0, 0);
	  result = mlw_license_check_result_make(OK);
        } else {
	  result = mlw_license_check_result_make(EXPIRED);
        }
d313 1
a313 1
        result = mlw_license_check_result_make(WRONG_EDITION);
d342 2
a343 2
  /* The validation algorithm takes the name, appends the edition 
     and the installation and expiry dates, calls SHA, and compares the last
d345 1
a345 1
  if (strlen(check) != CHECK_CHARS + EDITION_CHARS + (2 * DATE_CHARS)) {
d350 1
a350 1
  input = malloc(strlen(name) + EDITION_CHARS + (2 * DATE_CHARS) + 1);
a364 1
   WRONG_EDITION     license is for a different edition (e.g., student, personal)
d371 4
a374 8
    if (check_edition (check[CHECK_CHARS])) {
        /* check installation date */
        if (check_date (check+CHECK_CHARS+EDITION_CHARS)) {
          if (check_date(&check[CHECK_CHARS+EDITION_CHARS+DATE_CHARS])) {
            result = mlw_license_check_result_make(OK);
          } else {
            result = mlw_license_check_result_make(EXPIRED);
          }
d376 1
a376 1
          result = mlw_license_check_result_make(INSTALLDATE);
d378 3
a380 3
    } else {
      result = mlw_license_check_result_make(WRONG_EDITION);
    }
a402 1
  env_function("license error wrong version", license_error_version);
@


1.10.1.2.1.7
log
@[Bug #30223]
Merging into 1.1:
Shortening codes by using base 36 dates and 8 CHECK_CHARS
@
text
@a9 5
 * Revision 1.10.1.2.1.6  1997/08/11  16:38:18  jkbrook
 * [Bug #20072]
 * Merging into 1.1:
 * Adding edition info
 *
a82 2
#include <ctype.h>
#include <stdlib.h>
a243 14
/* conversion from base 36 to decimal */

static int base_36_to_decimal (char d)
{
   int result;

   if (islower(d))
     result = ((int)(d) - (int)('a')) + 10;
   else
     result = (int)(d) - (int)('0');

   return result;
};

a252 1
  char year_36, month_36, day_36;
d261 1
a261 1
  if (sscanf (date, "%1c%1c%1c", &day_36, &month_36, &year_36) < 3) {
d264 1
a264 14
  };

  /* convert back to decimal */

  day = base_36_to_decimal(day_36);
  month = base_36_to_decimal(month_36);
  year = base_36_to_decimal(year_36);

  /* convert back to last-two-digits-of-year format in decimal */
  if (year < 10)
    year += 90;  /* C20 dates */
  else
    year -= 10;  /* C21 dates */

@


1.10.1.2.1.8
log
@[Bug #30196]
Changing registry info from using version number to edition name
for student edition
@
text
@a9 5
 * Revision 1.10.1.2.1.7  1997/08/11  17:31:55  jkbrook
 * [Bug #30223]
 * Merging into 1.1:
 * Shortening codes by using base 36 dates and 8 CHECK_CHARS
 *
d134 1
a134 1
    if (RegCreateKeyEx (software, "Harlequin\\MLWorks\\Student", 0, NULL,
d140 1
a140 1
        ("Can't open `HKEY_LOCAL_MACHINE\\SOFTWARE\\Harlequin\\MLWorks\\Student'"
@


1.10.1.2.1.9
log
@[Bug #30227]
Merging into 1.1:
Include mlw_mklic.h instead of register.h
@
text
@a9 5
 * Revision 1.10.1.2.1.8  1997/08/15  17:41:53  jkbrook
 * [Bug #30196]
 * Changing registry info from using version number to edition name
 * for student edition
 *
d91 1
a91 1
#include "mlw_mklic.h"
@


1.10.1.2.1.9.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a9 5
 * Revision 1.10.1.2.1.9  1997/09/04  11:36:21  jkbrook
 * [Bug #30227]
 * Merging into 1.1:
 * Include mlw_mklic.h instead of register.h
 *
@


1.10.1.2.1.9.1.2
log
@[Bug #20072]
Merging from trunk:
check_edition can pass unterminated strings to atoi. Fix this
@
text
@a9 3
 * Revision 1.10.1.2.1.9.1.1  1997/10/07  11:52:25  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
d336 7
a342 2
  return (edition - '0' == EDITION);
}
@


1.9
log
@[Bug #1838]
Add license to contact message
@
text
@d10 4
d55 2
a56 1
static char c_license_error_string[] = LICENSE_ERROR_STRING;
d58 1
a58 1
static mlval license_error_string(mlval arg)
d60 1
a60 1
  return ml_string(c_license_error_string);
d63 4
a66 1

a93 1

a124 2


a148 2


a224 2


d226 7
a232 1
/* unit -> bool option */
d260 9
a268 3
    if ((strcmp(sha_result, code) == 0) && check_date(name)) {
      DIAGNOSTIC (1, "License is valid", 0, 0);
      result = mlw_option_make_some(MLTRUE);
a269 2
    else
      result = mlw_option_make_some(MLFALSE);
d276 2
a278 3
  else
    result = mlw_option_make_none();

a281 2


a322 2


a327 2


d333 2
a334 1
  env_function("license error string", license_error_string);
@


1.8
log
@[Bug #0]
Modify to use initial section of the code for checking
as opposed to unix version which uses the final section
@
text
@d10 5
d51 1
a51 9
/* Copied from <URI:/OS/Unix/license.c> */
static char c_license_error_string[] = 
  "Your license is invalid.\n"
  "Contact MLWorks customer support:\n"
  "   North and South America, Japan:\n"
  "     mail mlworks-keys@@harlequin.com\n"
  "   UK, Europe, Australasia, Africa, Asia:\n"
  "     mail mlworks-keys@@harlequin.co.uk";

@


1.8.4.1
log
@branched from 1.8
@
text
@a9 5
 * Revision 1.8  1996/11/19  13:14:27  jont
 * [Bug #0]
 * Modify to use initial section of the code for checking
 * as opposed to unix version which uses the final section
 *
@


1.8.3.1
log
@branched from 1.8
@
text
@a9 5
 * Revision 1.8  1996/11/19  13:14:27  jont
 * [Bug #0]
 * Modify to use initial section of the code for checking
 * as opposed to unix version which uses the final section
 *
@


1.8.3.1.1.1
log
@branched from 1.8.3.1
@
text
@a9 3
 * Revision 1.8.3.1  1996/12/17  17:53:02  hope
 * branched from 1.8
 *
@


1.8.2.1
log
@branched from 1.8
@
text
@a9 5
 * Revision 1.8  1996/11/19  13:14:27  jont
 * [Bug #0]
 * Modify to use initial section of the code for checking
 * as opposed to unix version which uses the final section
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a9 5
 * Revision 1.8  1996/11/19  13:14:27  jont
 * [Bug #0]
 * Modify to use initial section of the code for checking
 * as opposed to unix version which uses the final section
 *
@


1.7
log
@Added expiry date to licenses.
Also corrected definition of license_error_string.
@
text
@d10 4
d38 1
d171 1
a171 1
  memcpy(&input[len], (char*)&serial_num, sizeof(DWORD));
a192 13


/* Users are given their license name and a 19-character check string.  The
 * last 4 characters of this string are the expiry date, in the format mmyy.
 * The 3 characters before that are the number of the license given to this
 * license name.  The first 10 characters are the last 10 characters
 * of the result of hashing the name, number and date.
 */
#define CHECK_CHARS 10
#define NUMBER_CHARS 3
#define DATE_CHARS 4


d250 1
a250 1
    memcpy(&input[len], (char*)&serial_num, sizeof(DWORD));
d302 1
a302 1
  strcat (input, &check[CHECK_CHARS]);
d307 2
a308 3
  if ((!strncmp(check, &sha_result[strlen(sha_result)-CHECK_CHARS],
                CHECK_CHARS)) &&
      check_date (&check[CHECK_CHARS+NUMBER_CHARS]))
@


1.7.1.1
log
@branched from 1.7
@
text
@a9 4
 * Revision 1.7  1996/11/13  15:41:26  daveb
 * Added expiry date to licenses.
 * Also corrected definition of license_error_string.
 *
@


1.7.1.1.1.1
log
@branched from 1.7.1.1
@
text
@a9 3
 * Revision 1.7.1.1  1996/11/14  12:56:24  hope
 * branched from 1.7
 *
@


1.6
log
@Updated expiry message.
@
text
@d10 3
d48 1
a48 1
  "     mail mlworks-keys@@harlequin.co.uk\n";
d53 1
a53 4
  int len = sizeof(c_license_error_string);
  mlval result = allocate_string(len+1);
  memcpy(CSTRING(result), c_license_error_string, len + 1);
  return result;
d190 45
d264 1
a264 1
    if (strcmp(sha_result, code) == 0) {
a284 8
/* Users are given their license name and a 13-character check string.  The
 * last three characters of this string are the number of the license given
 * to this license name.  The first 10 characters are the last 10 characters
 * of the result of hashing the name and number.
 */
#define CHECK_CHARS 10
#define NUM_CHARS 3

d300 1
a300 1
  if (strlen(check) != CHECK_CHARS + NUM_CHARS) {
d305 1
a305 1
  input = malloc(strlen(name) + NUM_CHARS + 1);
d315 3
a317 1
  if (!strncmp(check, &sha_result[strlen(sha_result)-CHECK_CHARS], CHECK_CHARS))
@


1.5
log
@Added license checking for Windows.
@
text
@d10 3
d42 4
a45 3
  "   electronic mail:  mlworks-support@@harlequin.co.uk\n"
  "   telephone:        +44 1223 872522";

@


1.4
log
@[Bug #1693]
Add flag to indicate how to process license failure
@
text
@d10 4
d22 1
d25 1
d27 2
d32 10
d43 2
a44 1
static mlval license_start(mlval arg)
d46 64
a109 2
  /* Does nothing so far, but will do stuff with hostid and password */
  return MLUNIT;
d112 174
d288 1
a288 1
  /* No action required on the PC for this one */
d291 2
d295 5
a299 1
  env_function("start license", license_start);
@


1.3
log
@new unit
New license serving stuff
@
text
@d9 5
a13 1
 *  $Log$
d23 2
d39 1
@


1.2
log
@Remove redundant #include "syscalls.h".
@
text
@d7 3
a9 65
 *  The process is forked.  The parent continues with the normal running,
 *  but traps child status changes by putting a signal handler on SIGCHLD.
 *  The child monitors the license and exits if it expires.
 *
 *  Care is taken to deal with tampering.  In particular, if the child is
 *  stopped or killed the parent exits.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win32:license.c,v $
 * Revision 1.1  1996/03/06  11:23:04  stephenb
 * new unit
 * This replaces src/rts/src/OS/{NT,Win95}/license.c
 *
 * Revision 1.1  1994/12/12  14:23:41  jont
 * new file
 *
 * Revision 1.1  1994/10/04  16:26:38  jont
 * new file
 *
 * Revision 1.2  1994/06/09  14:28:15  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:52:40  nickh
 * new file
 *
 *  Revision 1.11  1994/01/28  17:22:49  nickh
 *  Moved extern function declarations to header files.
 *
 *  Revision 1.9  1994/01/04  10:31:37  nickh
 *  Update best-before date to 1st April.
 *
 *  Revision 1.8  1993/09/28  09:46:54  jont
 *  Merging in bug fixes
 *
 *  Revision 1.7.1.2  1993/09/28  09:44:29  jont
 *  Fixed to poll license expiry regularly
 *
 *  Revision 1.7.1.1  1993/09/01  09:32:09  jont
 *  Fork for bug fixing
 *
 *  Revision 1.7  1993/09/01  09:32:09  daveb
 *  Changed BEST_BEFORE date to 1994-01-01 00:00:00.
 *
 *  Revision 1.6  1993/05/11  13:18:47  daveb
 *  Increased a diagnostic level.
 *
 *  Revision 1.5  1993/04/26  10:44:05  richard
 *  Increased diagnostic levels.
 *
 *  Revision 1.4  1993/03/25  14:30:00  daveb
 *  Added a few extra checks and diagnostics.  Used sigblock instead of
 *  sigvec where appropriate.
 *
 *  Revision 1.3  1993/02/01  13:14:03  richard
 *  Abolished SETFIELD and GETFIELD in favour of lvalue FIELD.
 *
 *  Revision 1.2  1993/01/06  16:50:36  richard
 *  The mechanism is now considerably more secure.  The parent and child
 *  roles have been swapped so that interfering with the child is easily
 *  spotted.  The child monitors the status of the parent using a dummy
 *  pipe.
 *
 *  Revision 1.1  1992/12/21  15:38:29  richard
 *  Initial revision
d13 1
a13 3
#include "ansi.h"
#include "utils.h"
#include "diagnostic.h"
d15 3
a17 1
#include "signals.h"
d19 5
a23 4
#include <errno.h>
#ifndef OS_NT
#include <sys/errno.h>
#endif
d25 1
a25 1
void license(void)
d27 2
a28 3
  int pipefd[2];
  
  /* Start watching the child before forking */
d30 3
a32 28
  signal_license_watch_child();

/*
  if(pipe(pipefd))
    error("Unable to create pipe for licensing.  "
	  "pipe set errno to %d.", errno);
*/

  signal_license_child_pid = 1/*fork()*/;

  if(signal_license_child_pid == -1)
    switch(errno)
    {
      case EAGAIN:
      error("Too many processes running to fork licensing process.");

      case ENOMEM:
      error("Insufficient memory to fork licensing process.");

      default:
      error("fork() returned an unexpected error code %d", errno);
    }

  if(signal_license_child_pid == 0)
    /* the child process */
    signal_license_child(pipefd);

  DIAGNOSTIC(1, "licensing process id %d", signal_license_child_pid, 0);
@


1.2.3.1
log
@branched from 1.2
@
text
@a16 3
 * Revision 1.2  1996/07/31  12:21:54  stephenb
 * Remove redundant #include "syscalls.h".
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a16 3
 * Revision 1.2  1996/07/31  12:21:54  stephenb
 * Remove redundant #include "syscalls.h".
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a16 3
 * Revision 1.2  1996/07/31  12:21:54  stephenb
 * Remove redundant #include "syscalls.h".
 *
@


1.1
log
@new unit
This replaces src/rts/src/OS/{NT,Win95}/license.c
@
text
@d16 5
a20 1
 *  $Log: src:OS:NT:license.c,v $
a75 1
#include "syscalls.h"
@
