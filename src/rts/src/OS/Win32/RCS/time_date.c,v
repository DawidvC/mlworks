head	1.25;
access;
symbols
	MLW_daveb_inline_1_4_99:1.25.1
	MLWorks_21c0_1999_03_25:1.25
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.22
	MLWorks_20b2c2_1998_06_19:1.21
	MLWorks_20b2_Windows_1998_06_12:1.21
	MLWorks_20b1c1_1998_05_07:1.21
	MLWorks_20b0_1998_04_07:1.21
	MLWorks_20b0_1998_03_20:1.21
	MLWorks_20m2_1998_02_16:1.20
	MLWorks_MM_adapt:1.17.1
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.13.1.1.1.1.1
	MLWorks_workspace_97:1.15.2
	MLWorks_dt_wizard:1.15.1
	MLWorks_11c0_1997_09_09:1.13.1.1.1.1
	MLWorks_10r3:1.13.1.1.3
	MLWorks_10r2_551:1.13.1.1.2
	MLWorks_11:1.13.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.13.1.1
	MLWorks_20m0_1997_06_20:1.13
	MLWorks_1_0_r2c2_1997_06_14:1.13.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.13.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.13.1
	MLWorks_BugFix_1997_04_24:1.13
	MLWorks_1_0_r2_Win32_1997_04_11:1.13
	MLWorks_1_0_r2_Unix_1997_04_04:1.13
	MM_ML_release_korma_1997_04_01:1.13
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.10.7.1.1
	MLWorks_gui_1996_12_18:1.10.8
	MLWorks_1_0_Win32_1996_12_17:1.10.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.10.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.10.4.1
	JFHrts:1.10.6
	MLWorks_1_0_Irix_1996_11_28:1.10.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.10.5
	MLWorks_1_0_Unix_1996_11_14:1.10.4
	MLWorks_Open_Beta2_1996_10_11:1.10.3
	MLWorks_License_dev:1.10.2
	MLWorks_1_open_beta_1996_09_13:1.10.1
	MLWorks_Open_Beta_1996_08_22:1.10
	MLWorks_Beta_1996_07_02:1.10
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.25
date	98.10.09.14.34.22;	author jont;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	98.10.02.15.10.29;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	98.08.13.15.57.05;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	98.08.03.14.45.10;	author mitchell;	state Exp;
branches;
next	1.21;

1.21
date	98.02.24.11.22.10;	author jont;	state Exp;
branches;
next	1.20;

1.20
date	97.11.19.21.23.35;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	97.11.19.20.57.10;	author jont;	state Exp;
branches;
next	1.18;

1.18
date	97.11.17.09.01.52;	author jont;	state Exp;
branches;
next	1.17;

1.17
date	97.09.30.11.25.25;	author daveb;	state Exp;
branches
	1.17.1.1;
next	1.16;

1.16
date	97.09.25.09.16.29;	author brucem;	state Exp;
branches;
next	1.15;

1.15
date	97.08.27.15.33.57;	author jont;	state Exp;
branches
	1.15.1.1
	1.15.2.1;
next	1.14;

1.14
date	97.08.19.15.14.06;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	97.04.01.08.18.34;	author jont;	state Exp;
branches
	1.13.1.1;
next	1.12;

1.12
date	97.03.27.14.08.57;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	97.03.27.10.14.34;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	96.06.20.10.58.15;	author stephenb;	state Exp;
branches
	1.10.1.1
	1.10.2.1
	1.10.3.1
	1.10.4.1
	1.10.5.1
	1.10.6.1
	1.10.7.1
	1.10.8.1;
next	1.9;

1.9
date	96.06.14.08.37.50;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	96.06.13.14.42.59;	author stephenb;	state Exp;
branches;
next	1.7;

1.7
date	96.06.12.12.23.27;	author stephenb;	state Exp;
branches;
next	1.6;

1.6
date	96.05.16.14.02.53;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	96.05.14.12.52.41;	author stephenb;	state Exp;
branches;
next	1.4;

1.4
date	96.05.13.12.44.38;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.05.13.12.28.56;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.09.16.04.09;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.05.07.12.08.47;	author stephenb;	state Exp;
branches;
next	;

1.10.1.1
date	96.09.13.11.23.49;	author hope;	state Exp;
branches;
next	;

1.10.2.1
date	96.10.07.16.14.06;	author hope;	state Exp;
branches;
next	;

1.10.3.1
date	96.10.17.11.33.31;	author hope;	state Exp;
branches;
next	;

1.10.4.1
date	96.11.14.12.59.12;	author hope;	state Exp;
branches
	1.10.4.1.1.1;
next	;

1.10.4.1.1.1
date	96.11.28.15.09.11;	author hope;	state Exp;
branches;
next	;

1.10.5.1
date	96.11.22.18.16.55;	author hope;	state Exp;
branches;
next	;

1.10.6.1
date	96.12.17.10.03.40;	author hope;	state Exp;
branches;
next	;

1.10.7.1
date	96.12.17.17.55.16;	author hope;	state Exp;
branches
	1.10.7.1.1.1;
next	;

1.10.7.1.1.1
date	97.02.24.11.46.26;	author hope;	state Exp;
branches;
next	;

1.10.8.1
date	96.12.18.09.49.52;	author hope;	state Exp;
branches;
next	;

1.13.1.1
date	97.05.12.10.43.35;	author hope;	state Exp;
branches
	1.13.1.1.1.1
	1.13.1.1.2.1
	1.13.1.1.3.1;
next	;

1.13.1.1.1.1
date	97.07.28.18.27.35;	author daveb;	state Exp;
branches
	1.13.1.1.1.1.1.1;
next	;

1.13.1.1.1.1.1.1
date	97.10.07.11.53.35;	author jkbrook;	state Exp;
branches;
next	;

1.13.1.1.2.1
date	97.09.08.17.20.40;	author daveb;	state Exp;
branches;
next	;

1.13.1.1.3.1
date	97.09.09.14.16.47;	author daveb;	state Exp;
branches;
next	;

1.15.1.1
date	97.09.10.19.35.00;	author brucem;	state Exp;
branches;
next	;

1.15.2.1
date	97.09.11.21.03.46;	author daveb;	state Exp;
branches;
next	;

1.17.1.1
date	97.10.31.13.46.44;	author nickb;	state Exp;
branches;
next	;

1.25.1.1
date	99.04.01.18.02.46;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.25
log
@[Bug #30489]
Ensure we don't fault strftime results on empty formats
@
text
@/* Copyright 1996 The Harlequin Group Limited.  All rights reserved.
 *
 * Implements various parts of basis/time.sml and basis/date.sml
 *
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Win32:time_date.c,v $
 * Revision 1.24  1998/10/02  15:10:29  jont
 * [Bug #30487]
 * Modify conversions to and from seconds and parts thereof to return int32
 *
 * Revision 1.23  1998/08/13  15:57:05  jont
 * [Bug #70152]
 * Ensure Time.start uses GetSystemTime
 *
 * Revision 1.22  1998/08/03  14:45:10  mitchell
 * [Bug #30460]
 * Fix times so they are UTC rather than local where necessary
 *
 * Revision 1.21  1998/02/24  11:22:10  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.20  1997/11/19  21:23:35  jont
 * [Bug #30085]
 * Fix typo
 *
 * Revision 1.19  1997/11/19  20:57:10  jont
 * [Bug #30085]
 * Add Time.start function to give value of Time.now when process started
 *
 * Revision 1.18  1997/11/17  09:01:52  jont
 * [Bug #30089]
 * Add mlw_time_make for converting doubles to basis times
 *
 * Revision 1.17  1997/09/30  11:25:25  daveb
 * [Bug #30269]
 * Added declare root to Bruce's change.
 *
 * Revision 1.16  1997/09/25  09:16:29  brucem
 * [Bug #30269]
 * Implement routines for revised Date structure.
 *
 * Revision 1.15  1997/08/27  15:33:57  jont
 * [Bug #30250]
 * Fix up overloading of the name yday in mlw_date_from_system_time
 *
 * Revision 1.14  1997/08/19  15:14:06  nickb
 * [Bug #30250]
 * Bugs in use of allocate_record and allocate_array: add debug-filling code.
 *
 * Revision 1.13  1997/04/01  08:18:34  jont
 * Fix inaccuracies in Time.+ and Time.-
 *
 * Revision 1.12  1997/03/27  14:08:57  jont
 * Fix loss of precision when converting from time to FILETIME
 *
 * Revision 1.11  1997/03/27  10:14:34  jont
 * Modify calculation of tm_year in mlw_date_to_tm to
 * apply CINT before subtracting mlw_date_year_offset
 * Calculate yday in fromTime as this is required by the basis specification
 *
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
 * Revision 1.9  1996/06/14  08:37:50  stephenb
 * Add mlw_time_to_timeval as needed by select (which is used to
 * implement OS.IO.poll).
 *
 * Revision 1.8  1996/06/13  14:42:59  stephenb
 * Make mlw_time_to_file_time external so that it can be used by the
 * rts support routine for OS.FileSys.setTime.
 * Also alters the mlw_time_2_to_32 constant so that it actually defines 2^32
 * and so means that the time conversions now work!  Doesn't say much
 * for our test suite that it didn't catch this.
 *
 * Revision 1.7  1996/06/12  12:23:27  stephenb
 * Flesh out all the time stubs.
 *
 * Revision 1.6  1996/05/16  14:02:53  jont
 * Modify representation of ML year to be full value, rather than value since 1900
 *
 * Revision 1.5  1996/05/14  12:52:41  stephenb
 * Flesh out some of the stubs.
 * There are still lots of stubs left though.
 *
 * Revision 1.4  1996/05/13  12:44:38  jont
 * Fix problem whereby mk_time fiddles with tm_isdst
 *
 * Revision 1.3  1996/05/13  12:28:56  stephenb
 * Update wrt removal of trans_month ... etc. from date.h
 *
 * Revision 1.2  1996/05/09  16:04:09  jont
 * Completing implementation of __date.sml
 *
 * Revision 1.1  1996/05/07  12:08:47  stephenb
 * new unit
 *
 */

#include <assert.h>		/* assert */
#include <windows.h>		/* DWORD, SystemTimeToFileTime, ... etc. */
#include <math.h>		/* fmod, floor */
#include <limits.h>		/* LONG_MAX .. etc. */
#include "allocator.h"		/* allocate_real, allocate_record */
#include "date.h"		/* mlw_date_hour etc */
#include "exceptions.h"		/* exn_raise, perv_exn_ref_overflow */
#include "environment.h"	/* env_value ... etc. */
#include "global.h"		/* declare_global */
#include "utils.h" 		/* alloc */
#include "gc.h"			/* declare_root, retract_root */
#include "words.h"		/* num_to_word32 */
#include "time_date.h"
#include "time_date_init.h"

static mlval mlw_time_exn_ref_time;
static mlval mlw_date_exn_ref_date;

#define mlw_time_2_to_32 ((double)ULONG_MAX)

/* Win32 time is defined as a 64-bit value which ticks every 100 nanoseconds.
 * Due to lack of 64 bit arithmetic support in Visual C++ and the fact
 * that I don't have the time to write a 64/32 -> (64,32) division/remainder
 * routine either in portable C or assembler, floating point is used to
 * do division in the following.  This massages a 64 bit value into
 * a 41 bit value representing the seconds and a 28 bit value representing
 * the number of 100 nanoseconds.  
 *
 * If and when the 64-bit routines are written, most of the floating point
 * stuff should be removed and replaced by the 64-bit routines.
 *
 * If nobody does get around to writing the required integer division 
 * routines, then it may be worthwhile changing the internal representation
 * from a triple of ints to a double.
 */

#define mlw_time_secs_lo_bits 20

#define mlw_time_secs_lo_val (1 << mlw_time_secs_lo_bits)

static long mlw_time_sec(mlval arg)
{
  double secs= ((double)CINT(FIELD(arg, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(arg, 1));
  return (long)secs;
}

static mlval mlw_time_from_ints(unsigned long secs_hi, unsigned long secs_lo, unsigned long nsecs100)
{
  mlval mltime= allocate_record(3);
  FIELD(mltime, 0)= MLINT(secs_hi);
  FIELD(mltime, 1)= MLINT(secs_lo);
  FIELD(mltime, 2)= MLINT(nsecs100);
  return mltime;
}

mlval mlw_time_from_double(double time)
{
  unsigned long secs_hi= (unsigned long)(time/mlw_time_secs_lo_val);
  unsigned long secs_lo= (unsigned long)fmod(time,mlw_time_secs_lo_val);
  unsigned long nsecs100= (unsigned long)((time-floor(time))*mlw_time_ticks_per_sec);
  return mlw_time_from_ints(secs_hi, secs_lo, nsecs100);
}

mlval mlw_time_from_file_time(FILETIME *ft)
{
  double ticks= ((double)ft->dwHighDateTime)*mlw_time_2_to_32 + (double)(ft->dwLowDateTime);
  double time= ticks/mlw_time_ticks_per_sec;
  return mlw_time_from_double(time);
}

/* 
 * This is external since it is needed to implement OS.FileSys.setTime
 */
void mlw_time_to_file_time(mlval time, FILETIME *ft)
{
  double secs= ((double)CINT(FIELD(time, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(time, 1));
  double nsec100s= (double)CINT(FIELD(time, 2));
  double ticks= secs*(double)mlw_time_ticks_per_sec + nsec100s;
  ft->dwHighDateTime= (DWORD)(ticks/mlw_time_2_to_32);
  ft->dwLowDateTime= (DWORD)(fmod(ticks,mlw_time_2_to_32));
  /* Possible loss of precision here, so we increment by 2 */
  ft->dwLowDateTime+=2;
  if (ft->dwLowDateTime < 2) ft->dwHighDateTime++;
}

/* 
 * This is external since it is needed to implement OS.IO.poll
 */
void mlw_time_to_timeval(mlval time, struct timeval *tv)
{
  double secs= ((double)CINT(FIELD(time, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(time, 1));
  double nsec100s= (double)CINT(FIELD(time, 2));
  tv->tv_sec= (long)secs;
  tv->tv_usec= (long)(nsec100s/10.0);
}

#define mlw_time_low_bits 24
extern mlval mlw_time_make(long sec, long usec)
{
  mlval t= allocate_record(3);
  unsigned long hi= ((unsigned long)sec) >> mlw_time_low_bits;
  unsigned long lo= ((unsigned long)sec) & ((1<<(mlw_time_low_bits+1))-1);
  FIELD(t, 0)= MLINT(hi);
  FIELD(t, 1)= MLINT(lo);
  FIELD(t, 2)= MLINT(usec);
  return t;
}

/*
 * Time.fromReal: real -> time
 * raises: Time
 */
static mlval mlw_time_from_real(mlval arg)
{
  double time= GETREAL(arg);
  if (time < 0.0 || time > ((double)ULONG_MAX)*((double)ULONG_MAX))
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_from_double(time);
}

/*
 * Time.toReal: time -> real
 */
static mlval mlw_time_to_real(mlval arg)
{
  double secs= ((double)CINT(FIELD(arg, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(arg, 1));
  double nsecs100= (double)CINT(FIELD(arg, 2));
  mlval time= allocate_real();
  double real_time= secs + (nsecs100/mlw_time_ticks_per_sec);
  return SETREAL(time, real_time);
}

/*
 * Time.toSeconds: time -> LargeInt.int
 */
static mlval mlw_time_to_secs(mlval arg)
{
  mlval result = allocate_word32();
  double secs= ((double)CINT(FIELD(arg, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(arg, 1));
  if (secs > (double)INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  num_to_word32((word)secs,result);
  return (result);
}

/*
 * Time.toMilliseconds: time -> LargeInt.int
 */
static mlval mlw_time_to_msecs(mlval arg)
{
  mlval result = allocate_word32();
  double secs= ((double)CINT(FIELD(arg, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(arg, 1));
  double nsecs100= (double)CINT(FIELD(arg, 2));
  double real_time= secs + (nsecs100/mlw_time_ticks_per_sec);
  double msecs= real_time*1000.0;
  if (real_time > (double)INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  if (msecs > (double)INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  num_to_word32((word)msecs,result);
  return (result);
}

/*
 * Time.toMicroseconds: time -> LargeInt.int
 */
static mlval mlw_time_to_usecs(mlval arg)
{
  mlval result = allocate_word32();
  double secs= ((double)CINT(FIELD(arg, 0)))*mlw_time_secs_lo_val + (double)CINT(FIELD(arg, 1));
  double nsecs100= (double)CINT(FIELD(arg, 2));
  double real_time= secs + (nsecs100/mlw_time_ticks_per_sec);
  double usecs= real_time*1000000.0;
  if (real_time > (double)INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  if (usecs > (double)INT_MAX)
    exn_raise(perv_exn_ref_overflow);
  num_to_word32((word)usecs,result);
  return (result);
}

/*
 * Time.fromSeconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_secs(mlval arg)
{
  int secs = word32_to_num(arg);
  if (secs < 0)
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_from_double((double)secs);
}

/*
 * Time.fromMilliseconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_msecs(mlval arg)
{
  int msecs = word32_to_num(arg);
  if (msecs < 0)
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_from_double((double)(msecs/1000));
}

/*
 * Time.fromMicroseconds: LargeInt.int -> time
 * Raises: Time
 */
static mlval mlw_time_from_usecs(mlval arg)
{
  int usecs = word32_to_num(arg);
  if (usecs < 0)
    exn_raise(mlw_time_exn_ref_time);
  return mlw_time_from_double((double)(usecs/1000000));
}

/*
 * Time.+: (time * time) -> time
 * Raises: time
 *
 * If and when a 64-bit addition routines is written, the following
 * should be rewritten to use it.
 * And now it has.
 */
static mlval mlw_time_add(mlval arg)
{
  mlval a= FIELD(arg, 0);
  mlval b= FIELD(arg, 1);
  unsigned long lo_a = CINT(FIELD(a, 2));
  unsigned long lo_b = CINT(FIELD(b, 2));
  unsigned long mid_a = CINT(FIELD(a, 1));
  unsigned long mid_b = CINT(FIELD(b, 1));
  unsigned long hi_a = CINT(FIELD(a, 0));
  unsigned long hi_b = CINT(FIELD(b, 0));
  unsigned long mid_c, hi_c;
  unsigned long lo_c = lo_a + lo_b;
  int carry = lo_c >= mlw_time_ticks_per_sec;
  if (carry) {
    lo_c -= mlw_time_ticks_per_sec;
    mid_b += 1;
  }
  mid_c = mid_a + mid_b;
  carry = mid_c >= mlw_time_secs_lo_val;
  if (carry) {
    mid_c -= mlw_time_secs_lo_val;
    hi_b += 1;
  }
  hi_c = hi_b + hi_a;
  if ((hi_b == 0 && carry) || hi_b > hi_c)
    exn_raise(mlw_time_exn_ref_time);
  /* This would mean time going negative or overflowing */
  return mlw_time_from_ints(hi_c, mid_c, lo_c);
}

/*
 * Time.-: (time * time) -> time
 * Raises: Time
 *
 * If and when a 64-bit subtraction routine is written, the following
 * should be rewritten to use it.
 * And now it has.
 */
static mlval mlw_time_sub(mlval arg)
{
  mlval a= FIELD(arg, 0);
  mlval b= FIELD(arg, 1);
  unsigned long lo_a = CINT(FIELD(a, 2));
  unsigned long lo_b = CINT(FIELD(b, 2));
  unsigned long mid_a = CINT(FIELD(a, 1));
  unsigned long mid_b = CINT(FIELD(b, 1));
  unsigned long hi_a = CINT(FIELD(a, 0));
  unsigned long hi_b = CINT(FIELD(b, 0));
  unsigned long lo_c, mid_c, hi_c;
  int carry = lo_a < lo_b;
  if (carry) {
    lo_a += mlw_time_ticks_per_sec;
    mid_b += 1;
  }
  lo_c = lo_a - lo_b;
  carry = mid_a < mid_b;
  if (carry) {
    mid_a += mlw_time_secs_lo_val;
    hi_b += 1;
  }
  mid_c = mid_a - mid_b;
  if ((hi_b == 0 && carry) || hi_b > hi_a)
    exn_raise(mlw_time_exn_ref_time);
  /* This would mean time going negative or overflowing */
  hi_c = hi_a - hi_b;
  return mlw_time_from_ints(hi_c, mid_c, lo_c);
}

/*
 * Time.now: unit -> time
 * Raises: Time
 */
static mlval mlw_time_now(mlval unit)
{
  SYSTEMTIME system_time;
  FILETIME file_time;
  GetSystemTime(&system_time); 
  if (!SystemTimeToFileTime(&system_time, &file_time))
    exn_raise(mlw_time_exn_ref_time);
  
  return mlw_time_from_file_time(&file_time);
}

#define mlw_date_year_offset 1900

static void mlw_date_to_tm(mlval date, struct tm *tm)
{
  int dst;
  tm->tm_sec=  CINT(mlw_date_sec(date));
  tm->tm_min=  CINT(mlw_date_min(date));
  tm->tm_hour= CINT(mlw_date_hour(date));
  tm->tm_mday= CINT(mlw_date_mday(date));
  tm->tm_mon=  mlw_date_month_ml_to_c[CINT(mlw_date_mon(date))];
  tm->tm_year= CINT(mlw_date_year(date))-mlw_date_year_offset;
  tm->tm_wday= mlw_date_wday_ml_to_c[CINT(mlw_date_wday(date))];
  tm->tm_yday= CINT(mlw_date_yday(date));
  tm->tm_isdst= mlw_option_is_none(mlw_date_isdst(date))
    ? 0
    : CBOOL(mlw_option_some(mlw_date_isdst(date)));
  dst = tm->tm_isdst; /* Remember this, because mk_time will screw it */
  tm->tm_isdst=-1;    /* Need to stop mktime fiddling with the hours */
  (void)mktime(tm); /* Bring all the fields into range */
  tm->tm_isdst = dst; /* Put it back again */
}

static int month_lengths[] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

static int is_leap_year(int year)
{
  return (year % 4 != 0) ? 0 :
         (year % 100 == 0) ? ((year % 400 == 0) ? 1 : 0) : 1;
}

static int yday(int mday, int month, int year)
{
  int i = 0;
  int yday = mday-1; /* Day of month starts at 1 */
  while (i < month) {
    yday += month_lengths[i++];
  }
  if (month > 2 && is_leap_year(year)) yday++;
  return yday;
}


/*
 * Convert a C SYSTEMTIME into an ML `Date.date'.
 * Will set isDst to NONE.
 * Will set offset to supplied value.
 */
static mlval mlw_date_from_system_time(SYSTEMTIME *st, mlval offset)
{
  mlval date;

  assert(st->wDayOfWeek >= mlw_date_wday_min &&
         st->wDayOfWeek <= mlw_date_wday_max);

  declare_root(&offset, 0);
  date= mlw_make_date();
  retract_root(&offset);

  mlw_date_sec(date)= MLINT(st->wSecond);
  mlw_date_min(date)= MLINT(st->wMinute);
  mlw_date_hour(date)= MLINT(st->wHour);
  mlw_date_mday(date)= MLINT(st->wDay);

  assert(st->wMonth-1 >= mlw_date_month_min &&
         st->wMonth-1 <= mlw_date_month_max);

  mlw_date_mon(date)= MLINT(mlw_date_month_c_to_ml[st->wMonth-1]);
  mlw_date_year(date)= MLINT(st->wYear);
  mlw_date_wday(date)= MLINT(mlw_date_wday_c_to_ml[st->wDayOfWeek]);
  mlw_date_yday(date)= MLINT(yday(st->wDay, st->wMonth-1, st->wYear)); 
  mlw_date_isdst(date)= mlw_option_make_none();
  mlw_date_offset(date)= offset;

  return date;
}

static void mlw_date_to_system_time(mlval date, SYSTEMTIME *st)
{
  st->wMilliseconds= 0;
  st->wSecond= CINT(mlw_date_sec(date));
  st->wMinute= CINT(mlw_date_min(date));
  st->wHour=   CINT(mlw_date_hour(date));
  st->wDay=    CINT(mlw_date_mday(date));
  st->wMonth=  mlw_date_month_ml_to_c[CINT(mlw_date_mon(date))]+1;
  st->wYear=   CINT(mlw_date_year(date));
  st->wDayOfWeek=
    mlw_date_wday_ml_to_c[CINT(mlw_date_wday(date))];
}


/*
 * Date.localOffset : unit -> Time.time
 * Raises: Date
 */
static mlval mlw_date_local_offset(mlval arg){
  struct tm *gmt;
  time_t t1, t2;
  double offset;

  t1 = time((time_t)0);
  gmt = gmtime (&t1);
  t2 = mktime(gmt);

  offset = (difftime(t2, t1));
  /* Make sure offset is in the range 0..24 hours */
  if(offset < 0.0)
    offset = (60.0 * 60.0 * 24.0) + offset;

  return mlw_time_from_double(offset);
}


/*
 * Date.fromTimeLocal: Time.time -> Date.date
 */
static mlval mlw_date_from_time_local(mlval arg)
{
  FILETIME ft;
  FILETIME utc_file_time; 
  SYSTEMTIME st;

  mlw_time_to_file_time(arg, &utc_file_time); 
  (void)FileTimeToLocalFileTime(&utc_file_time, &ft); 

  (void)FileTimeToSystemTime(&ft, &st);

  return mlw_date_from_system_time(&st, mlw_option_make_none());
}

/*
 * Date.fromTimeUniv: Time.time -> Date.date
 */
static mlval mlw_date_from_time_univ(mlval arg)
{
  FILETIME utc_file_time;
  SYSTEMTIME st;
  mlval offset;

  mlw_time_to_file_time(arg, &utc_file_time); 
  (void)FileTimeToSystemTime(&utc_file_time, &st);

  /* Returned date should have offset = SOME(time.zeroTime) */
  offset = mlw_option_make_some(mlw_time_from_double(0.0));

  return mlw_date_from_system_time(&st, offset);
}

/*
 * Date.toTime: date -> Time.time
 * Raises: Date
 */
static mlval mlw_date_to_time(mlval date)
{
  /* Within the translation date -> system time -> file time we introduce 
     non-zero fractions of a second, and this is what causes the date test 
     to fail sometimes on NT.  If possible we should replace this mechanism. 
  */ 
  SYSTEMTIME st;
  FILETIME ft, utc_ft;
  mlw_date_to_system_time(date, &st);
  if (!SystemTimeToFileTime(&st, &ft))
    exn_raise(mlw_date_exn_ref_date);
  if (mlw_option_is_none(mlw_date_offset(date))) {
    (void)LocalFileTimeToFileTime(&ft, &utc_ft);
    return mlw_time_from_file_time(&utc_ft);
  } else {
    /* Need to deal with possibility of non-trivial offset here eventually,
       but we only generate dates with the trivial case at the moment. */
    return mlw_time_from_file_time(&ft);
  }
}

/*
 * Date.toString: date -> string
 */
static mlval mlw_date_to_string(mlval date)
{
  struct tm tm;
  char date_string[26], *ascdate, ch;
  int i;
  mlw_date_to_tm(date, &tm);
  ascdate = asctime(&tm);
  /* Win32 has a fault whereby it zero pads the month day,
     instead of space padding */
  /* We sort that out here */
  for (i = 0; i < 26; i++) {
    date_string[i] = ascdate[i];
  }
  ch = ascdate[8];
  date_string[8] = (ch == '0') ? ' ' : ch;
  date_string[24] = '\0'; /* Remove '\n' */
  return ml_string(date_string);
}

static mlval mlw_date_fmt(mlval string_date)
{
  struct tm tm;
  size_t size;
  mlval result = MLUNIT;
  char *format = CSTRING(FIELD(string_date, 0));
  if (strlen(format) == 0) {
    result = allocate_string(1);
    *(CSTRING(result)) = '\0';
    return result;
  } else {
    mlw_date_to_tm(FIELD(string_date, 1), &tm);
    for(size=256; result==MLUNIT; size*=2) {
      char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
      size_t length = strftime(buffer, size-1, format, &tm);

      if(length > 0) {
	result = allocate_string(length+1);
	memcpy(CSTRING(result), buffer, length+1);
      }

      free(buffer);
    }
    return result;
  }
}

static FILETIME start_time;

static mlval mlw_time_start(mlval unit)
{
  return mlw_time_from_file_time(&start_time);
}

void mlw_time_date_init(void)
{
  SYSTEMTIME system_time;
  GetSystemTime(&system_time);
  SystemTimeToFileTime(&system_time, &start_time);
  mlw_time_exn_ref_time = ref(exn_default);
  mlw_date_exn_ref_date = ref(exn_default);
  env_value("Time.Time", mlw_time_exn_ref_time);
  env_value("Date.Date", mlw_date_exn_ref_date);
  declare_global("Time.Time", &mlw_time_exn_ref_time,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  declare_global("Date.Date", &mlw_date_exn_ref_date,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);

  env_function("Time.fromReal", mlw_time_from_real);
  env_function("Time.toReal", mlw_time_to_real);

  env_function("Time.toSeconds", mlw_time_to_secs);
  env_function("Time.toMilliseconds", mlw_time_to_msecs);
  env_function("Time.toMicroseconds", mlw_time_to_usecs);

  env_function("Time.fromSeconds", mlw_time_from_secs);
  env_function("Time.fromMilliseconds", mlw_time_from_msecs);
  env_function("Time.fromMicroseconds", mlw_time_from_usecs);

  env_function("Time.+", mlw_time_add);
  env_function("Time.-", mlw_time_sub);

  env_function("Time.now", mlw_time_now);
  env_function("Time.start", mlw_time_start);

  env_function("Date.localOffset", mlw_date_local_offset);
  env_function("Date.fromTimeLocal", mlw_date_from_time_local);
  env_function("Date.fromTimeUniv",  mlw_date_from_time_univ);
  env_function("Date.toTime",   mlw_date_to_time);
  env_function("Date.toString", mlw_date_to_string);
  env_function("Date.fmt", mlw_date_fmt);

}
@


1.25.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a8 4
 * Revision 1.25  1998/10/09  14:34:22  jont
 * [Bug #30489]
 * Ensure we don't fault strftime results on empty formats
 *
@


1.24
log
@[Bug #30487]
Modify conversions to and from seconds and parts thereof to return int32
@
text
@d9 4
d616 16
a631 10
  mlw_date_to_tm(FIELD(string_date, 1), &tm);
  for(size=256; result==MLUNIT; size*=2)
  {
    char *buffer = alloc(size, "Unable to allocate buffer for time_format()");
    size_t length = strftime(buffer, size-1, format, &tm);

    if(length > 0)
    {
      result = allocate_string(length+1);
      memcpy(CSTRING(result), buffer, length+1);
d633 1
a633 2

    free(buffer);
a634 1
  return result;
@


1.23
log
@[Bug #70152]
Ensure Time.start uses GetSystemTime
@
text
@d9 4
d115 1
d237 1
a237 1
 * Time.toSeconds: time -> int
d241 1
d243 1
a243 1
  if (secs > (double)ML_MAX_INT)
d245 2
a246 1
  return MLINT((int)secs);
d250 1
a250 1
 * Time.toMilliseconds: time -> int
d254 1
d259 1
a259 1
  if (real_time > (double)ML_MAX_INT)
d261 1
a261 1
  if (msecs > (double)ML_MAX_INT)
d263 2
a264 1
  return MLINT((int)msecs);
d268 1
a268 1
 * Time.toMicroseconds: time -> int
d272 1
d277 1
a277 1
  if (real_time > (double)ML_MAX_INT)
d279 1
a279 1
  if (usecs > (double)ML_MAX_INT)
d281 2
a282 1
  return MLINT((int)usecs);
d286 1
a286 1
 * Time.fromSeconds: int -> time
d291 1
a291 1
  int secs= CINT(arg);
d298 1
a298 1
 * Time.fromMilliseconds: int -> time
d303 1
a303 1
  int msecs= CINT(arg);
d310 1
a310 1
 * Time.fromMicroseconds: int -> time
d315 1
a315 1
  int usecs= CINT(arg);
@


1.22
log
@[Bug #30460]
Fix times so they are UTC rather than local where necessary
@
text
@d9 4
d628 1
a628 1
  GetLocalTime(&system_time);
@


1.21
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d9 5
d390 1
a390 1
  GetLocalTime(&system_time);
d515 1
d518 3
a520 1
  mlw_time_to_file_time(arg, &ft);
d531 1
a531 1
  FILETIME local_file_time, utc_file_time;
d535 1
a535 2
  mlw_time_to_file_time(arg, &local_file_time);
  (void)LocalFileTimeToFileTime(&local_file_time, &utc_file_time);
d550 4
d555 1
a555 1
  FILETIME ft;
d559 8
a566 1
  return mlw_time_from_file_time(&ft);
@


1.20
log
@[Bug #30085]
Fix typo
@
text
@d9 4
d446 1
a446 1
  declare_root(&offset);
@


1.19
log
@[Bug #30085]
Add Time.start function to give value of Time.now when process started
@
text
@d9 4
d592 1
a592 1
static FILETIME start_time = MLUNIT;
@


1.18
log
@[Bug #30089]
Add mlw_time_make for converting doubles to basis times
@
text
@d9 4
d588 7
d597 3
d624 1
@


1.17
log
@[Bug #30269]
Added declare root to Bruce's change.
@
text
@d9 4
d172 12
@


1.17.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a8 4
 * Revision 1.17  1997/09/30  11:25:25  daveb
 * [Bug #30269]
 * Added declare root to Bruce's change.
 *
@


1.16
log
@[Bug #30269]
Implement routines for revised Date structure.
@
text
@d9 4
d418 1
d420 1
@


1.15
log
@[Bug #30250]
Fix up overloading of the name yday in mlw_date_from_system_time
@
text
@d9 4
d86 1
d235 1
d247 1
d259 1
d271 1
d309 1
d347 1
a359 1
#define mlw_make_date() allocate_record(9)
d371 2
a372 6
  tm->tm_wday= mlw_option_is_none(mlw_date_wday(date))
    ? 0
    : mlw_date_wday_ml_to_c[CINT(mlw_option_some(mlw_date_wday(date)))];
  tm->tm_yday= mlw_option_is_none(mlw_date_yday(date))
    ? 0
    : CINT(mlw_option_some(mlw_date_yday(date)));
d386 2
a387 1
  return (year % 4 != 0) ? 0 : (year % 100 == 0) ? ((year % 400 == 0) ? 1 : 0) : 1;
d401 7
a407 1
static mlval mlw_date_from_system_time(SYSTEMTIME *st)
d409 2
a410 1
  mlval wday, yearday, date;
d413 1
a413 4
  wday= mlw_option_make_some(MLINT(mlw_date_wday_c_to_ml[st->wDayOfWeek]));
  declare_root(&wday);
  yearday = mlw_option_make_some(MLINT(yday(st->wDay, st->wMonth-1, st->wYear)));
  declare_root(&yearday);
d415 1
d420 1
d423 1
d426 2
a427 2
  mlw_date_wday(date)= wday;
  mlw_date_yday(date)= yearday; 
d429 2
a430 1
  retract_root(&wday);
d443 24
a466 3
  st->wDayOfWeek= mlw_option_is_none(mlw_date_wday(date))
    ? 0
    : mlw_date_wday_ml_to_c[CINT(mlw_option_some(mlw_date_wday(date)))];
d469 1
d471 1
a471 1
 * Date.fromTime: Time.time -> Date.date
d473 1
a473 1
static mlval mlw_date_from_time(mlval arg)
d477 1
d480 2
a481 1
  return mlw_date_from_system_time(&st);
d485 1
a485 1
 * Date.fromUTC: Time.time -> Date.date
d487 1
a487 1
static mlval mlw_date_from_utc(mlval arg)
d491 2
d496 5
a500 1
  return mlw_date_from_system_time(&st);
d505 1
d513 1
a513 1
    exn_raise(mlw_time_exn_ref_time); /* XXX: perhaps should be Date?*/
d527 2
a528 1
  /* Win32 has a fault whereby it zero pads the month day, instead of space padding */
d535 1
a535 1
  date_string[25] = '\0'; /* Just in case */
d565 1
d567 1
d570 2
d589 3
a591 2
  env_function("Date.fromTime", mlw_date_from_time);
  env_function("Date.fromUTC",  mlw_date_from_utc);
@


1.15.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a8 4
 * Revision 1.15  1997/08/27  15:33:57  jont
 * [Bug #30250]
 * Fix up overloading of the name yday in mlw_date_from_system_time
 *
@


1.15.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a8 4
 * Revision 1.15  1997/08/27  15:33:57  jont
 * [Bug #30250]
 * Fix up overloading of the name yday in mlw_date_from_system_time
 *
@


1.14
log
@[Bug #30250]
Bugs in use of allocate_record and allocate_array: add debug-filling code.
@
text
@d9 4
d396 1
a396 1
  mlval wday, yday, date;
d401 2
a402 2
  yday = mlw_option_make_some(MLINT(yday(st->wDay, st->wMonth-1, st->wYear)));
  declare_root(&yday);
d413 1
a413 1
  mlw_date_yday(date)= yday; 
@


1.13
log
@Fix inaccuracies in Time.+ and Time.-
@
text
@d9 3
d392 1
a392 1
  mlval wday,  date;
d397 2
d409 1
a409 1
  mlw_date_yday(date)= mlw_option_make_some(MLINT(yday(st->wDay, st->wMonth-1, st->wYear)));
@


1.13.1.1
log
@branched from 1.13
@
text
@a8 3
 * Revision 1.13  1997/04/01  08:18:34  jont
 * Fix inaccuracies in Time.+ and Time.-
 *
@


1.13.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a8 3
 * Revision 1.13.1.1  1997/05/12  10:43:35  hope
 * branched from 1.13
 *
@


1.13.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a8 3
 * Revision 1.13.1.1  1997/05/12  10:43:35  hope
 * branched from 1.13
 *
@


1.13.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a8 3
 * Revision 1.13.1.1  1997/05/12  10:43:35  hope
 * branched from 1.13
 *
@


1.13.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a8 3
 * Revision 1.13.1.1.1.1  1997/07/28  18:27:35  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.12
log
@Fix loss of precision when converting from time to FILETIME
@
text
@d9 3
d96 2
d100 1
a100 1
  double secs= ((double)CINT(FIELD(arg, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(arg, 1));
d104 1
a104 1
mlval mlw_time_from_double(double time)
a106 3
  unsigned long secs_hi= (unsigned long)(time/(1<<mlw_time_secs_lo_bits));
  unsigned long secs_lo= (unsigned long)fmod(time,(1<<mlw_time_secs_lo_bits));
  unsigned long nsecs100= (unsigned long)((time-floor(time))*mlw_time_ticks_per_sec);
d113 8
d133 1
a133 1
  double secs= ((double)CINT(FIELD(time, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(time, 1));
d148 1
a148 1
  double secs= ((double)CINT(FIELD(time, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(time, 1));
d171 1
a171 1
  double secs= ((double)CINT(FIELD(arg, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(arg, 1));
d183 1
a183 1
  double secs= ((double)CINT(FIELD(arg, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(arg, 1));
d194 1
a194 1
  double secs= ((double)CINT(FIELD(arg, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(arg, 1));
d210 1
a210 1
  double secs= ((double)CINT(FIELD(arg, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(arg, 1));
d259 1
d265 24
a288 6
  double at= ((double)CINT(FIELD(a, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(a, 1)) + ((double)CINT(FIELD(a, 2))/mlw_time_ticks_per_sec);
  double bt= ((double)CINT(FIELD(b, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(b, 1)) + ((double)CINT(FIELD(b, 2))/mlw_time_ticks_per_sec);
  double t= at+bt;
  if (t < 0.0 || t > ((double)ULONG_MAX)*((double)ULONG_MAX))
    exn_raise(perv_exn_ref_overflow);
  return mlw_time_from_double(t);
d296 1
d302 20
a321 4
  double at= ((double)CINT(FIELD(a, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(a, 1)) + ((double)CINT(FIELD(a, 2))/mlw_time_ticks_per_sec);
  double bt= ((double)CINT(FIELD(b, 0)))*(1<<mlw_time_secs_lo_bits) + (double)CINT(FIELD(b, 1)) + ((double)CINT(FIELD(b, 2))/mlw_time_ticks_per_sec);
  double t= at-bt;
  if (t < 0.0 || t > ((double)ULONG_MAX)*((double)ULONG_MAX))
d323 3
a325 1
  return mlw_time_from_double(t);
@


1.11
log
@Modify calculation of tm_year in mlw_date_to_tm to
apply CINT before subtracting mlw_date_year_offset
Calculate yday in fromTime as this is required by the basis specification
@
text
@d9 5
d127 4
a130 1
  ft->dwLowDateTime= (DWORD)(fmod(ticks,mlw_time_2_to_32));;
@


1.10
log
@Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
library routines rather than the Unix ones provided in the Visual
C++ compatability library.  It was either this or put some hack in
to convert between the time used by Time (native Win32 time) and
that expected by the previous Date implementation (Unix style time
since 1970).
@
text
@d9 8
a65 2


a69 1

a85 1

a87 2


a93 3



a105 3



a112 1

a124 2


a135 3



a147 3



a159 3



a170 2


a186 2


a202 2


a213 2


a224 2


a235 3



a253 3



a271 3



a285 4




a288 1

d297 1
a297 1
  tm->tm_year= CINT(mlw_date_year(date)-mlw_date_year_offset);
d313 1
d315 15
d348 1
a348 1
  mlw_date_yday(date)= mlw_option_make_none();
a353 2


a367 2


a379 3



a392 3



a405 2


d412 2
d415 10
a424 1
  return ml_string(asctime(&tm));
a426 4




a448 2


@


1.10.8.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.7.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.7.1.1.1
log
@branched from 1.10.7.1
@
text
@a8 3
 * Revision 1.10.7.1  1996/12/17  17:55:16  hope
 * branched from 1.10
 *
@


1.10.6.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.5.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.4.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.4.1.1.1
log
@branched from 1.10.4.1
@
text
@a8 3
 * Revision 1.10.4.1  1996/11/14  12:59:12  hope
 * branched from 1.10
 *
@


1.10.3.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.2.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.10.1.1
log
@branched from 1.10
@
text
@a8 8
 * Revision 1.10  1996/06/20  10:58:15  stephenb
 * Rewrite Date.from{Time,UTC} and Date.toTime to use native Win32
 * library routines rather than the Unix ones provided in the Visual
 * C++ compatability library.  It was either this or put some hack in
 * to convert between the time used by Time (native Win32 time) and
 * that expected by the previous Date implementation (Unix style time
 * since 1970).
 *
@


1.9
log
@Add mlw_time_to_timeval as needed by select (which is used to
implement OS.IO.poll).
@
text
@d9 4
d317 1
d324 1
d328 28
a355 1
static mlval mlw_tm_to_date(struct tm *tm)
d357 4
a360 3
  mlval wday,  yday,  isdst,  date;
  assert(tm->tm_wday >= mlw_date_wday_min && tm->tm_wday <= mlw_date_wday_max);
  wday= mlw_option_make_some(MLINT(mlw_date_wday_c_to_ml[tm->tm_wday]));
a361 4
  yday= mlw_option_make_some(MLINT(tm->tm_yday));
  declare_root(&yday);
  isdst= mlw_option_make_some(tm->tm_isdst > 0 ? MLTRUE : MLFALSE);
  declare_root(&isdst);
d363 8
a370 7
  mlw_date_sec(date)= MLINT(tm->tm_sec);
  mlw_date_min(date)= MLINT(tm->tm_min);
  mlw_date_hour(date)= MLINT(tm->tm_hour);
  mlw_date_mday(date)= MLINT(tm->tm_mday);
  assert(tm->tm_mon >= mlw_date_month_min && tm->tm_mon <= mlw_date_month_max);
  mlw_date_mon(date)= MLINT(mlw_date_month_c_to_ml[tm->tm_mon]);
  mlw_date_year(date)= MLINT(tm->tm_year);
d372 2
a373 4
  mlw_date_yday(date)= yday;
  mlw_date_isdst(date)= isdst;
  retract_root(&isdst);
  retract_root(&yday);
d380 14
d401 5
a405 3
  time_t secs= (time_t)mlw_time_sec(arg);
  struct tm *tm= localtime(&secs);
  return mlw_tm_to_date(tm);
d416 6
a421 29
  time_t secs= (time_t)mlw_time_sec(arg);
  struct tm *tm= gmtime(&secs);
  return mlw_tm_to_date(tm);
}



static void mlw_date_to_tm(mlval date, struct tm *tm)
{
  int dst;
  tm->tm_sec=  CINT(mlw_date_sec(date));
  tm->tm_min=  CINT(mlw_date_min(date));
  tm->tm_hour= CINT(mlw_date_hour(date));
  tm->tm_mday= CINT(mlw_date_mday(date));
  tm->tm_mon=  mlw_date_month_ml_to_c[CINT(mlw_date_mon(date))];
  tm->tm_year= CINT(mlw_date_year(date)-mlw_date_year_offset);
  tm->tm_wday= mlw_option_is_none(mlw_date_wday(date))
    ? 0
    : mlw_date_wday_ml_to_c[CINT(mlw_option_some(mlw_date_wday(date)))];
  tm->tm_yday= mlw_option_is_none(mlw_date_yday(date))
    ? 0
    : CINT(mlw_option_some(mlw_date_yday(date)));
  tm->tm_isdst= mlw_option_is_none(mlw_date_isdst(date))
    ? 0
    : CBOOL(mlw_option_some(mlw_date_isdst(date)));
  dst = tm->tm_isdst; /* Remember this, because mk_time will screw it */
  tm->tm_isdst=-1;    /* Need to stop mktime fiddling with the hours */
  (void)mktime(tm); /* Bring all the fields into range */
  tm->tm_isdst = dst; /* Put it back again */
d432 6
a437 3
  struct tm tm;
  mlw_date_to_tm(date, &tm);
  return mlw_time_from_double((double)mktime(&tm));
@


1.8
log
@Make mlw_time_to_file_time external so that it can be used by the
rts support routine for OS.FileSys.setTime.
Also alters the mlw_time_2_to_32 constant so that it actually defines 2^32
and so means that the time conversions now work!  Doesn't say much
for our test suite that it didn't catch this.
@
text
@d9 7
d114 3
a116 1

d124 13
@


1.7
log
@Flesh out all the time stubs.
@
text
@d9 3
d51 1
a51 1
#define mlw_time_2_to_32 ((1<<33)-1)
d101 1
a101 1
  double ticks= ((double)ft->dwHighDateTime)*mlw_time_2_to_32 + (ft->dwLowDateTime);
d107 2
a108 1
static void mlw_time_to_file_time(mlval time, FILETIME *ft)
d112 3
a114 3
  double ticks= secs*10000000.0+nsec100s;
  ft->dwHighDateTime= (DWORD)(ticks/(double)mlw_time_2_to_32);
  ft->dwLowDateTime= (DWORD)(fmod(ticks,(double)mlw_time_2_to_32));;
@


1.6
log
@Modify representation of ML year to be full value, rather than value since 1900
@
text
@d9 3
d32 1
d51 14
a64 2
/* Win32 time is defined as a 64-bit value.  This is split into three
 * parts of 20, 22 and 22 bits respectively.
d67 2
a68 2
#define mlw_time_low_bits 22
#define mlw_time_mid_bits 22
d71 2
a72 1
DWORD mlw_time_lo(mlval time)
d74 2
a75 4
  unsigned int ml_mid= CINT(FIELD(time, 1));
  unsigned int ml_lo=  CINT(FIELD(time, 2));
  DWORD lo= ((ml_mid & (32-mlw_time_low_bits)) << mlw_time_low_bits) & ml_lo;
  return lo;
d79 3
a81 1
DWORD mlw_time_hi(mlval time)
d83 8
a90 5
  unsigned int ml_hi=  CINT(FIELD(time, 0));
  unsigned int ml_mid= CINT(FIELD(time, 1));
  DWORD hi= (ml_hi << (mlw_time_mid_bits-(32-mlw_time_mid_bits)))
          & (ml_mid >> (32-mlw_time_low_bits));
  return hi;
a93 1
/* XXX: just a stub for now */
d95 2
a96 1
static long mlw_time_sec(mlval arg)
d98 3
a100 1
  return 0;
d104 1
a104 3


mlval mlw_time_make(DWORD hi, DWORD lo)
d106 5
a110 9
  mlval time= allocate_record(3);
  unsigned int ml_hi= hi >> (mlw_time_mid_bits-(32-mlw_time_low_bits));
  unsigned int ml_mid= (hi & (mlw_time_mid_bits-(32-mlw_time_low_bits)))
                     | (lo >> mlw_time_low_bits);
  unsigned int ml_lo= lo & ((1<<(mlw_time_low_bits+1))-1);
  FIELD(time, 0)= MLINT(ml_hi);
  FIELD(time, 1)= MLINT(ml_mid);
  FIELD(time, 2)= MLINT(ml_lo);
  return time;
d123 1
a123 2
  DWORD hi, lo;
  if (time < 0)
d125 1
a125 3
  hi= (DWORD)(time/(double)mlw_time_2_to_32);
  lo= (DWORD)(time - (double)((double)hi*(double)mlw_time_2_to_32));
  return mlw_time_make(hi, lo);
d136 2
a137 2
  DWORD hi= mlw_time_hi(arg);
  DWORD lo= mlw_time_lo(arg);
d139 1
a139 1
  double real_time=(((double)hi)*mlw_time_2_to_32 + lo)/mlw_time_ticks_per_sec;
d145 1
d151 4
a154 3
  DWORD hi= mlw_time_hi(arg);
  DWORD lo= mlw_time_lo(arg);
  return MLINT(0);
d164 9
a172 3
  DWORD hi= mlw_time_hi(arg);
  DWORD lo= mlw_time_lo(arg);
  return MLINT(0);
d182 9
a190 3
  DWORD hi= mlw_time_hi(arg);
  DWORD lo= mlw_time_lo(arg);
  return MLINT(0);
d200 4
a203 1
  return mlw_time_make(0, 0);
d213 4
a216 1
  return mlw_time_make(0, 0);
d226 4
a229 1
  return mlw_time_make(0, 0);
d234 1
d237 3
d243 8
a250 1
  return mlw_time_make(0, 0);
d255 1
d258 3
d264 8
a271 1
  return mlw_time_make(0, 0);
d275 2
d287 1
a287 1
  return mlw_time_make(file_time.dwHighDateTime, file_time.dwLowDateTime);
d290 3
d325 2
a351 1

d378 1
a384 2
  long secs;
  DWORD hi, lo;
d386 1
a386 4
  secs= mktime(&tm);
  /* XXX: change the following to break secs up and assign to hi and lo */
  hi= lo= 0;
  return mlw_time_make(hi, lo);
@


1.5
log
@Flesh out some of the stubs.
There are still lots of stubs left though.
@
text
@d9 4
a229 3



d231 1
a231 1

d296 1
a296 1
  tm->tm_year= CINT(mlw_date_year(date));
@


1.4
log
@Fix problem whereby mk_time fiddles with tm_isdst
@
text
@d9 3
d23 1
d32 1
d51 1
a51 1
extern DWORD mlw_time_lo(mlval time)
d60 1
a60 1
extern DWORD mlw_time_hi(mlval time)
d70 1
d72 9
a80 1
extern mlval mlw_time_make(DWORD hi, DWORD lo)
d229 31
a262 1
 * XXX: just a stub for now
d266 3
a268 1
  return MLUNIT;
a275 1
 * XXX: just a stub for now
d279 3
a281 1
  return MLUNIT;
d286 1
a314 1
 * XXX: just a stub for now
d318 8
a325 1
  return mlw_time_make(0, 0);
a331 1
 * XXX: just a stub for now
d335 3
a337 1
  return ml_string("");
d339 4
@


1.3
log
@Update wrt removal of trans_month ... etc. from date.h
@
text
@d9 3
d241 1
d257 2
d260 1
@


1.2
log
@Completing implementation of __date.sml
@
text
@d9 3
d234 2
d242 1
a242 1
  tm->tm_mon=  trans_month(mlw_date_mon(date));
d246 1
a246 1
    : trans_wday(mlw_option_some(mlw_date_wday(date)));
d252 1
a252 1
    : CINT(mlw_option_some(mlw_date_isdst(date)));
d256 2
d300 2
@


1.1
log
@new unit
@
text
@d8 4
a11 1
 * $Log$
d17 1
d21 1
d231 19
a249 2


d271 23
d321 1
@
