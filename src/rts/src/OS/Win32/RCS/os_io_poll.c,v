head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.10
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_MM_adapt:1.8.3
	MLWorks_20m1_1997_10_23:1.8
	MLWorks_11r1:1.7.6.1.1.1.1
	MLWorks_workspace_97:1.8.2
	MLWorks_dt_wizard:1.8.1
	MLWorks_11c0_1997_09_09:1.7.6.1.1.1
	MLWorks_10r3:1.7.6.1.3
	MLWorks_10r2_551:1.7.6.1.2
	MLWorks_11:1.7.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.6.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.7.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.6
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MM_ML_release_korma_1997_04_01:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.4.1.1
	MLWorks_gui_1996_12_18:1.7.5
	MLWorks_1_0_Win32_1996_12_17:1.7.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.1.1
	JFHrts:1.7.3
	MLWorks_1_0_Irix_1996_11_28:1.7.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.2
	MLWorks_1_0_Unix_1996_11_14:1.7.1
	MLWorks_Open_Beta2_1996_10_11:1.6.1
	MLWorks_License_dev:1.5.2
	MLWorks_1_open_beta_1996_09_13:1.5.1
	MLWorks_Open_Beta_1996_08_22:1.5
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.2
	MLWorks_Beta_1996_06_06:1.2
	MLWorks_Beta_1996_06_05:1.2
	MLWorks_Beta_1996_06_03:1.2
	MLWorks_Beta_1996_05_31:1.2
	MLWorks_Beta_1996_05_30:1.2;
locks; strict;
comment	@ * @;


1.10
date	98.07.16.11.30.21;	author jont;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	98.02.24.11.21.56;	author jont;	state Exp;
branches;
next	1.8;

1.8
date	97.05.22.09.16.47;	author johnh;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1;
next	1.7;

1.7
date	96.10.24.08.37.12;	author stephenb;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1
	1.7.6.1;
next	1.6;

1.6
date	96.10.08.10.57.51;	author stephenb;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	96.07.04.14.48.28;	author stephenb;	state Exp;
branches
	1.5.1.1
	1.5.2.1;
next	1.4;

1.4
date	96.07.04.12.00.54;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.06.14.11.18.18;	author stephenb;	state Exp;
branches;
next	1.2;

1.2
date	96.05.24.11.17.35;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.05.07.12.37.47;	author stephenb;	state Exp;
branches;
next	;

1.5.1.1
date	96.09.13.11.22.08;	author hope;	state Exp;
branches;
next	;

1.5.2.1
date	96.10.07.16.12.13;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.10.17.11.31.11;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.11.14.12.57.06;	author hope;	state Exp;
branches
	1.7.1.1.1.1;
next	;

1.7.1.1.1.1
date	96.11.28.15.07.19;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.11.22.18.15.00;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.12.17.10.01.47;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.12.17.17.53.32;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	97.02.24.11.44.31;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	96.12.18.09.48.05;	author hope;	state Exp;
branches;
next	;

1.7.6.1
date	97.05.12.10.40.30;	author hope;	state Exp;
branches
	1.7.6.1.1.1
	1.7.6.1.2.1
	1.7.6.1.3.1;
next	;

1.7.6.1.1.1
date	97.07.28.18.27.38;	author daveb;	state Exp;
branches
	1.7.6.1.1.1.1.1;
next	;

1.7.6.1.1.1.1.1
date	97.10.07.11.53.38;	author jkbrook;	state Exp;
branches;
next	;

1.7.6.1.2.1
date	97.09.08.17.20.44;	author daveb;	state Exp;
branches;
next	;

1.7.6.1.3.1
date	97.09.09.14.16.50;	author daveb;	state Exp;
branches;
next	;

1.8.1.1
date	97.09.10.19.35.05;	author brucem;	state Exp;
branches;
next	;

1.8.2.1
date	97.09.11.21.03.50;	author daveb;	state Exp;
branches;
next	;

1.8.3.1
date	97.10.31.13.46.49;	author nickb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.02.50;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
@


1.10
log
@[Bug #20135]
Sort out return code handling from WSA functions
@
text
@/* Copyright (C) 1996 Harlequin Ltd
 *
 * Implements most of OS.IO.poll using select since Win32 doesn't support poll.
 * This has hardly been tested since there is currently no way to create
 * a socket.  Roll on the standard Socket Library.
 * 
 * Revision Log
 * ------------
 *
 * $Log: src:OS:Win32:os_io_poll.c,v $
 * Revision 1.9  1998/02/24  11:21:56  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.8  1997/05/22  09:16:47  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr to include an mlval string.
 *
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
 * Revision 1.6  1996/10/08  10:57:51  stephenb
 * Do the same declare/root retract cleanup that was done as
 * part of fix 1561 for Linux.
 *
 * Revision 1.5  1996/07/04  14:48:28  stephenb
 * How oh how did I manage to check this in without compiling it!
 * s/retrace/retract/
 *
 * Revision 1.4  1996/07/04  12:00:54  stephenb
 * Fix #1456 - add declare/retract roots.
 *
 * Revision 1.3  1996/06/14  11:18:18  stephenb
 * Make mlw_os_io_poll take account of non-NONE timeouts and filter the
 * result list so that it only contains info for those descriptors that
 * have an event associated with them.
 *
 * Revision 1.2  1996/05/24  11:17:35  stephenb
 * Various changes to bring it into line with a post March 1996 basis spec.
 * These include: removing pollErr, introducing pollPri and isPri and making
 * poll raise SysErr if there are any errors.
 *
 * Revision 1.1  1996/05/07  12:37:47  stephenb
 * new unit
 *
 */


#include <windows.h>		/* select */
#if !defined(_WIN32) && !defined(WIN32)
#include <ver.h>
#endif
#include <assert.h>		/* assert */
#include <stdlib.h>		/* atexit */
#include "values.h"		/* FIELD, MLTAIL, cons ... */
#include "exceptions.h"		/* exn_raise_syserr */
#include "environment.h"	/* env_function, ... */
#include "allocator.h"		/* allocate_record, ml_string */
#include "gc.h"			/* declare_root, ... */
#include "utils.h"		/* error, message_stderr */
#include "time_date.h"		/* mlw_time_make, ... */
#include "os_io_poll.h"		/* os_poll_io_init */


/*
 * datatype event_set = EVENT_SET of int
 * datatype poll_desc = POLL_DESC of io_desc * event_set
 * datatype poll_info = POLL_INFO of poll_desc * event_set
 */
#define mlw_poll_desc_make() allocate_record(2)
#define mlw_poll_desc_fd(poll_desc) FIELD(poll_desc, 0)
#define mlw_poll_desc_events(poll_desc) FIELD(poll_desc, 1)

#define mlw_poll_info_make() allocate_record(2)
#define mlw_poll_info_desc(poll_info) FIELD(poll_info, 0)
#define mlw_poll_info_revents(poll_info) FIELD(poll_info, 1)



/*
 * The SML interface is based on SysV poll which is defined in terms of
 * event sets which indicate the type of events you are interested in.
 * The following codes are used to represent the three types of event
 * that SML knows about.  Note that the codes should have values of the 
 * form 2**n with each value being distinct and n in the range
 * [1, ML_MAX_INT_BITS].  This is so that it is easy to use bit masking
 * to check if a given value is defined.
 */
#define mlw_poll_event_in  0x1
#define mlw_poll_event_out 0x2
#define mlw_poll_event_pri 0x3


/* The final event type is the empty event and
 * should always have the value 0
 */
#define mlw_poll_event_none 0x0



/* An io_desc is currently implemented as an integer.
 * Because of this there is no need to declare as a root
 * any io_desc that is an argument to a function in which
 * any allocation is done.  However, to ensure that the
 * code doesn't break in mysterious ways should the 
 * structure of an io_desc change, the following should
 * be sprinkled liberally around the code to ensure that
 * if the representation does change we get to know about
 * it here straight away.
 */
#define mlw_os_io_poll_is_io_desc(arg) (!MLVALISPTR(arg))



/*
 * Implements OS.IO.pollDesc: io_desc -> poll_desc option
 *
 * XXX: Currently makes no attempt to check if the descriptor is suitable
 * for polling.
 */
static mlval mlw_os_io_poll_desc(mlval arg)
{
  mlval poll_desc;

  assert(mlw_os_io_poll_is_io_desc(arg));
  poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(poll_desc)= arg;
  mlw_poll_desc_events(poll_desc)= MLINT(mlw_poll_event_none);

  return mlw_option_make_some(poll_desc);
}




/*
 * OS.IO.pollIn: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_in(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_in);
  return new_poll_desc;
}




/*
 * OS.IO.pollOut: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_out(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_out);
  return new_poll_desc;
}




/*
 * OS.IO.pollPri: poll_desc -> poll_desc
 *
 */
static mlval mlw_os_io_poll_pri(mlval arg)
{
  int events= CINT(mlw_poll_desc_events(arg));
  mlval io_desc= mlw_poll_desc_fd(arg);
  mlval new_poll_desc;

  assert(mlw_os_io_poll_is_io_desc(io_desc));
  new_poll_desc= mlw_poll_desc_make();
  mlw_poll_desc_fd(new_poll_desc)= io_desc;
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_pri);
  return new_poll_desc;
}




/*
 * OS.IO.poll: (poll_desc list * Time.time option) -> poll_info list
 *
 * If and when the Socket Library is fully defined, this could probably
 * be defined in SML.  Until that time, this is difficult to test because
 * there is no way of creating a legal socket in MLWorks.
 *
 * NOTE: development library page for select notes that the first argument
 * to select is ignored -- it is only there for compatability.  Nevertheless
 * the correct value is generated, just in case.
 */
static mlval mlw_os_io_poll(mlval arg)
{
  mlval poll_descs= FIELD(arg, 0);
  mlval optional_timeout= FIELD(arg, 1);
  mlval poll_infos= MLNIL;
  mlval l;
  int status;
  int max_fd= -1;
  fd_set in_fds, out_fds, pri_fds;

  FD_ZERO(&in_fds);
  FD_ZERO(&out_fds);
  FD_ZERO(&pri_fds);
  for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l)) {
    mlval poll_desc= MLHEAD(l);
    int fd= CINT(mlw_poll_desc_fd(poll_desc));
    int events= CINT(mlw_poll_desc_events(poll_desc));
    if (fd > max_fd)
      max_fd= fd;
    if (events&mlw_poll_event_in)
      FD_SET(fd, &in_fds);
    if (events&mlw_poll_event_out)
      FD_SET(fd, &out_fds);
    if (events&mlw_poll_event_pri)
      FD_SET(fd, &pri_fds);
  }

  if (mlw_option_is_none(optional_timeout)) {
    status= select(max_fd+1, &in_fds, &out_fds, &pri_fds, NULL);
  } else {
    struct timeval timeout;
    mlw_time_to_timeval(mlw_option_some(optional_timeout), &timeout);
    status= select(max_fd+1, &in_fds, &out_fds, &pri_fds, &timeout);
  }

  if (status < 0) {
    exn_raise_syserr(ml_string("OS.IO.poll failed"), WSAGetLastError());
  } else if (status > 0) {
    declare_root(&l, 0);
    declare_root(&poll_infos, 0);
    for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l)) {
      mlval poll_desc= MLHEAD(l);
      int fd= CINT(mlw_poll_desc_fd(poll_desc));
      int events= CINT(mlw_poll_desc_events(poll_desc));
      int revents= 0;
      if (events&mlw_poll_event_in && FD_ISSET(fd, &in_fds))
	revents |= mlw_poll_event_in;
      if (events&mlw_poll_event_out && FD_ISSET(fd, &out_fds))
	revents |= mlw_poll_event_out;
      if (events&mlw_poll_event_pri && FD_ISSET(fd, &pri_fds))
	revents |= mlw_poll_event_pri;
      if (revents != 0) {
	mlval poll_info= mlw_poll_info_make();
	mlw_poll_info_desc(poll_info)= MLHEAD(l);
	mlw_poll_info_revents(poll_info)= MLINT(revents);
	poll_infos= mlw_cons(poll_info, poll_infos);
      } else {
	/* no events detected for this descriptor */
      }
    }
    retract_root(&poll_infos);
    retract_root(&l);
  } else {
    /* timeout or no events for any descriptor, just return the empty list */
  }

  return poll_infos;
}



/*
 * OS.IO.isIn: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_in(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_in);
}



/*
 * OS.IO.isOut: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_out(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_out);
}



/*
 * OS.IO.isPri: poll_info -> bool
 *
 */
static mlval mlw_os_io_is_pri(mlval arg)
{
  int revents= CINT(mlw_poll_info_revents(arg));
  return MLBOOL(revents&mlw_poll_event_pri);
}




/* Ideally the error messages in mlw_socket_open and mlw_socket_close
 * should be generated from winerror.h or an equivalent.  Until that
 * time we have to make do with the following hard coded versions.
 */
static void mlw_socket_open(void)
{
  WORD requested_version= MAKEWORD(1, 1);
  WSADATA actual_version;
  int status= WSAStartup(requested_version, &actual_version);
  switch (status) {
  case 0:
    break;
  case WSASYSNOTREADY:
    error("WSASYSNOTREADY (%d): Network subsystem is not ready for network communication", WSASYSNOTREADY);
  case WSAVERNOTSUPPORTED:
    error("WSAVERNOTSUPPORTED (%d): The version of Windows Socket support requested is not supported by installed Windows Socket implementation", WSAVERNOTSUPPORTED);
  case WSAEINPROGRESS:
    error("WSAEINPROGRESS (%d): A blocking Windows Socket 1.1 operation is in progress", WSAEINPROGRESS);
  case WSAEPROCLIM:
    error("WSAEPROCLIM (%d): Limit on the number of tasks supported by the Windows Sockets implementation has been reached.", WSAEPROCLIM);
  case WSAEFAULT:
    error("WSAEFAULT (%d): The lpWSAData is not a valid pointer.", WSAEFAULT);
  default:
    message("Invalid return code (%d) from WSAStartup", status);
  }
}




static void mlw_socket_close(void)
{
  int status= WSACleanup();
  if (status == SOCKET_ERROR) {
    status = WSAGetLastError();
  } else {
    status = 0;
  }
  switch (status) {
  case 0:
    break;
  case WSANOTINITIALISED:
    message("WSANOTINITIALISED (%d): Windows Sockets were not initialised", WSANOTINITIALISED);
    break;
  case WSAENETDOWN:
    message("WSAENETDOWN (%d): network subsystem has failed.", WSAEINPROGRESS);
    break;
  case WSAEINPROGRESS:
    message("WSAEINPROGRESS (%d): a blocking Windows Sockets operation is in progress.", WSAEINPROGRESS);
    break;
  default:
    message("Invalid return code (%d) from WSACleanup", status);
  }
}




void mlw_os_io_poll_init(void)
{
  env_function("OS.IO.pollDesc", mlw_os_io_poll_desc);
  env_function("OS.IO.pollIn",   mlw_os_io_poll_in);
  env_function("OS.IO.pollOut",  mlw_os_io_poll_out);
  env_function("OS.IO.pollPri",  mlw_os_io_poll_pri);
  env_function("OS.IO.poll",     mlw_os_io_poll);
  env_function("OS.IO.isIn",     mlw_os_io_is_in);
  env_function("OS.IO.isOut",    mlw_os_io_is_out);
  env_function("OS.IO.isPri",    mlw_os_io_is_pri);
  mlw_socket_open();
  if (atexit(mlw_socket_close) != 0)
    message("MLWorks could not register a socket cleanup function.\n Consequently socket resources may still be allocated when MLWorks terminates.");
}

@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a10 4
 * Revision 1.10  1998/07/16  11:30:21  jont
 * [Bug #20135]
 * Sort out return code handling from WSA functions
 *
@


1.9
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d11 5
d333 6
a338 2
  case WSAEINVAL:
    error("WSAEINVAL (%d): The version of Windows Socket support requested is not supported by installed Windows Socket DLL", WSAEINVAL);
d350 5
@


1.8
log
@[Bug #01702]
Changed definition of exn_raise_syserr to include an mlval string.
@
text
@d11 4
d242 2
a243 2
    declare_root(&l);
    declare_root(&poll_infos);
@


1.8.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a10 4
 * Revision 1.8  1997/05/22  09:16:47  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr to include an mlval string.
 *
@


1.8.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a10 4
 * Revision 1.8  1997/05/22  09:16:47  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr to include an mlval string.
 *
@


1.8.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a10 4
 * Revision 1.8  1997/05/22  09:16:47  johnh
 * [Bug #01702]
 * Changed definition of exn_raise_syserr to include an mlval string.
 *
@


1.7
log
@[Bug #1701]
mlw_os_io_poll_desc: remove redundant declare/retract_root.
@
text
@d11 4
d51 1
a51 1
#include "allocator.h"		/* allocate_record */
d236 1
a236 1
    exn_raise_syserr("OS.IO.poll failed", WSAGetLastError());
@


1.7.6.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a10 3
 * Revision 1.7.6.1  1997/05/12  10:40:30  hope
 * branched from 1.7
 *
@


1.7.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a10 3
 * Revision 1.7.6.1  1997/05/12  10:40:30  hope
 * branched from 1.7
 *
@


1.7.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a10 3
 * Revision 1.7.6.1  1997/05/12  10:40:30  hope
 * branched from 1.7
 *
@


1.7.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a10 3
 * Revision 1.7.6.1.1.1  1997/07/28  18:27:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.5.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a10 3
 * Revision 1.7.4.1  1996/12/17  17:53:32  hope
 * branched from 1.7
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a10 4
 * Revision 1.7  1996/10/24  08:37:12  stephenb
 * [Bug #1701]
 * mlw_os_io_poll_desc: remove redundant declare/retract_root.
 *
@


1.7.1.1.1.1
log
@branched from 1.7.1.1
@
text
@a10 3
 * Revision 1.7.1.1  1996/11/14  12:57:06  hope
 * branched from 1.7
 *
@


1.6
log
@Do the same declare/root retract cleanup that was done as
part of fix 1561 for Linux.
@
text
@d11 4
d112 1
a112 1
  mlval option, poll_desc;
d119 1
a119 5
  declare_root(&poll_desc);
  option= mlw_option_make_some(poll_desc);
  retract_root(&poll_desc);

  return option;
@


1.6.1.1
log
@branched from 1.6
@
text
@a10 4
 * Revision 1.6  1996/10/08  10:57:51  stephenb
 * Do the same declare/root retract cleanup that was done as
 * part of fix 1561 for Linux.
 *
@


1.5
log
@How oh how did I manage to check this in without compiling it!
s/retrace/retract/
@
text
@d11 4
d34 1
a34 1
#include <windows.h>
d38 1
d86 14
d110 1
a110 1
  declare_root(&arg);
a112 1
  retract_root(&arg);
d132 1
d134 2
a135 1
  declare_root(&arg);
d137 1
a137 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a138 1
  retract_root(&arg);
d152 1
d154 2
a155 1
  declare_root(&arg);
d157 1
a157 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a158 1
  retract_root(&arg);
d172 1
d174 2
a175 1
  declare_root(&arg);
d177 1
a177 1
  mlw_poll_desc_fd(new_poll_desc)= mlw_poll_desc_fd(arg);
a178 1
  retract_root(&arg);
d191 4
d203 1
a203 1
  int nfds;
d209 1
a209 1
  for (l= poll_descs, nfds= 0; !MLISNIL(l); l= MLTAIL(l), nfds += 1) {
d213 2
d224 1
a224 1
    status= select(nfds, &in_fds, &out_fds, &pri_fds, NULL);
d228 1
a228 1
    status= select(nfds, &in_fds, &out_fds, &pri_fds, &timeout);
d234 3
a236 2
    size_t i= 0;
    for (l= poll_descs; !MLISNIL(l); l= MLTAIL(l), i += 1) {
d248 1
a248 5
	mlval poll_info;
	declare_root(&l);
	declare_root(&poll_infos);
	poll_info= mlw_poll_info_make();
	retract_root(&poll_infos);
d251 3
a253 2
	poll_infos= cons(poll_info, poll_infos);
	retract_root(&l);
d256 2
d259 1
a259 1
    /* timeout or no descriptors so just return the empty list */
d274 1
a274 1
  return (revents&mlw_poll_event_in) ? MLTRUE : MLFALSE;
d286 1
a286 1
  return (revents&mlw_poll_event_out) ? MLTRUE : MLFALSE;
d298 1
a298 1
  return (revents&mlw_poll_event_pri) ? MLTRUE : MLFALSE;
@


1.5.2.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/07/04  14:48:28  stephenb
 * How oh how did I manage to check this in without compiling it!
 * s/retrace/retract/
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a10 4
 * Revision 1.5  1996/07/04  14:48:28  stephenb
 * How oh how did I manage to check this in without compiling it!
 * s/retrace/retract/
 *
@


1.4
log
@Fix #1456 - add declare/retract roots.
@
text
@d11 3
d119 1
a119 1
  retrace_root(&arg);
d138 1
a138 1
  retrace_root(&arg);
@


1.3
log
@Make mlw_os_io_poll take account of non-NONE timeouts and filter the
result list so that it only contains info for those descriptors that
have an event associated with them.
@
text
@d11 5
d47 1
a47 1
#define mlw_make_poll_desc() allocate_record(2)
d51 1
a51 1
#define mlw_make_poll_info() allocate_record(2)
d88 2
a89 1
  poll_desc= mlw_make_poll_desc();
d91 1
d111 3
a113 1
  mlval new_poll_desc= mlw_make_poll_desc();
d116 1
d122 1
d130 3
a132 1
  mlval new_poll_desc= mlw_make_poll_desc();
d135 1
d141 1
d149 3
a151 1
  mlval new_poll_desc= mlw_make_poll_desc();
d154 1
d160 1
d202 1
a202 1
    exn_raise_syserr("select", WSAGetLastError());
d217 6
a222 2
	mlval poll_info= mlw_make_poll_info();
	mlw_poll_info_desc(poll_info)= poll_desc;
d225 1
d273 5
d296 1
@


1.2
log
@Various changes to bring it into line with a post March 1996 basis spec.
These include: removing pollErr, introducing pollPri and isPri and making
poll raise SysErr if there are any errors.
@
text
@d4 4
a7 2
 *
  * Revision Log
d11 5
d26 1
d32 1
a36 1

a143 1
 * XXX: deal with non-NONE time.
d145 3
a147 2
 * XXX: change this to only create a poll_info for a poll_desc for
 * which an event has occured.
d177 3
a179 1
    status= select(nfds, &in_fds, &out_fds, &pri_fds, NULL);
a186 1
      mlval poll_info= mlw_make_poll_info();
d197 6
a202 3
      mlw_poll_info_desc(poll_info)= poll_desc;
      mlw_poll_info_revents(poll_info)= MLINT(revents);
      poll_infos= cons(poll_info, poll_infos);
d249 22
a270 1
static void mlw_socket_init(void)
d272 15
a286 4
  WORD requestedVersion= MAKEWORD(1, 0);
  WSADATA actualVersion;
  if (WSAStartup(requestedVersion, &actualVersion) != 0) {
    /* do something */
d293 1
a293 1
extern void mlw_os_io_poll_init(void)
d303 3
a305 1
  mlw_socket_init();
@


1.1
log
@new unit
@
text
@d8 4
a11 1
 * $Log$
d42 2
d55 1
a55 1
#define mlw_poll_event_err 0x3
d120 1
a120 1
 * OS.IO.pollErr: poll_desc -> poll_desc
d123 1
a123 1
static mlval mlw_os_io_poll_err(mlval arg)
d128 1
a128 1
  mlw_poll_desc_events(new_poll_desc)= MLINT(events|mlw_poll_event_err);
d137 3
d149 1
a149 1
  fd_set in_fds, out_fds, err_fds;
d153 1
a153 1
  FD_ZERO(&err_fds);
d162 2
a163 2
    if (events&mlw_poll_event_err)
      FD_SET(fd, &err_fds);
d167 1
a167 1
    status= select(nfds, &in_fds, &out_fds, &err_fds, NULL);
d169 1
a169 1
    status= select(nfds, &in_fds, &out_fds, &err_fds, NULL);
d186 2
a187 2
      if (events&mlw_poll_event_err && FD_ISSET(fd, &err_fds))
	revents |= mlw_poll_event_err;
d226 1
a226 1
 * OS.IO.isErr: poll_info -> bool
d229 1
a229 1
static mlval mlw_os_io_is_err(mlval arg)
d232 1
a232 1
  return (revents&mlw_poll_event_err) ? MLTRUE : MLFALSE;
d254 1
a254 1
  env_function("OS.IO.pollErr",  mlw_os_io_poll_err);
d258 1
a258 1
  env_function("OS.IO.isErr",    mlw_os_io_is_err);
@
