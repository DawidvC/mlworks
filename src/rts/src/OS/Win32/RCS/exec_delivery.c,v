head	1.10;
access;
symbols
	MLW_daveb_inline_1_4_99:1.10.1
	MLWorks_21c0_1999_03_25:1.10
	MLWorks_20c1_1998_08_20:1.10
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.6
	MLWorks_20m2_1998_02_16:1.6
	MLWorks_MM_adapt:1.5.4
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.5.1.1.1.1.1
	MLWorks_workspace_97:1.5.3
	MLWorks_dt_wizard:1.5.2
	MLWorks_11c0_1997_09_09:1.5.1.1.1.1
	MLWorks_10r3:1.5.1.1.3
	MLWorks_10r2_551:1.5.1.1.2
	MLWorks_11:1.5.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.5.1.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.5.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.5.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.5.1
	MLWorks_BugFix_1997_04_24:1.5
	MLWorks_1_0_r2_Win32_1997_04_11:1.5
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MM_ML_release_korma_1997_04_01:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.3.7.1.1
	MLWorks_gui_1996_12_18:1.3.8
	MLWorks_1_0_Win32_1996_12_17:1.3.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.3.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.3.4.1
	JFHrts:1.3.6
	MLWorks_1_0_Irix_1996_11_28:1.3.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.3.5
	MLWorks_1_0_Unix_1996_11_14:1.3.4
	MLWorks_Open_Beta2_1996_10_11:1.3.3
	MLWorks_License_dev:1.3.2
	MLWorks_1_open_beta_1996_09_13:1.3.1
	MLWorks_Open_Beta_1996_08_22:1.3
	MLWorks_Beta_1996_07_02:1.3
	MLWorks_Beta_1996_06_07:1.3
	MLWorks_Beta_1996_06_06:1.3
	MLWorks_Beta_1996_06_05:1.3
	MLWorks_Beta_1996_06_03:1.3
	MLWorks_Beta_1996_05_31:1.3
	MLWorks_Beta_1996_05_30:1.3;
locks; strict;
comment	@ * @;


1.10
date	98.08.28.16.10.40;	author mitchell;	state Exp;
branches
	1.10.1.1;
next	1.9;

1.9
date	98.05.19.08.45.50;	author mitchell;	state Exp;
branches;
next	1.8;

1.8
date	98.04.14.12.48.50;	author mitchell;	state Exp;
branches;
next	1.7;

1.7
date	98.04.03.14.26.02;	author johnh;	state Exp;
branches;
next	1.6;

1.6
date	97.11.26.11.44.40;	author johnh;	state Exp;
branches;
next	1.5;

1.5
date	97.04.08.14.18.44;	author jont;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1
	1.5.4.1;
next	1.4;

1.4
date	97.02.26.18.23.08;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	96.05.02.12.00.45;	author nickb;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1
	1.3.6.1
	1.3.7.1
	1.3.8.1;
next	1.2;

1.2
date	96.05.01.08.53.03;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	96.02.12.11.58.40;	author stephenb;	state Exp;
branches;
next	;

1.3.1.1
date	96.09.13.11.25.49;	author hope;	state Exp;
branches;
next	;

1.3.2.1
date	96.10.07.16.16.20;	author hope;	state Exp;
branches;
next	;

1.3.3.1
date	96.10.17.11.35.41;	author hope;	state Exp;
branches;
next	;

1.3.4.1
date	96.11.14.13.01.17;	author hope;	state Exp;
branches
	1.3.4.1.1.1;
next	;

1.3.4.1.1.1
date	96.11.28.15.11.23;	author hope;	state Exp;
branches;
next	;

1.3.5.1
date	96.11.22.18.19.09;	author hope;	state Exp;
branches;
next	;

1.3.6.1
date	96.12.17.10.05.53;	author hope;	state Exp;
branches;
next	;

1.3.7.1
date	96.12.17.17.57.26;	author hope;	state Exp;
branches
	1.3.7.1.1.1;
next	;

1.3.7.1.1.1
date	97.02.24.11.49.10;	author hope;	state Exp;
branches;
next	;

1.3.8.1
date	96.12.18.09.52.07;	author hope;	state Exp;
branches;
next	;

1.5.1.1
date	97.05.12.10.47.07;	author hope;	state Exp;
branches
	1.5.1.1.1.1
	1.5.1.1.2.1
	1.5.1.1.3.1;
next	;

1.5.1.1.1.1
date	97.07.28.18.27.16;	author daveb;	state Exp;
branches
	1.5.1.1.1.1.1.1;
next	;

1.5.1.1.1.1.1.1
date	97.10.07.11.53.17;	author jkbrook;	state Exp;
branches;
next	;

1.5.1.1.2.1
date	97.09.08.17.20.21;	author daveb;	state Exp;
branches;
next	;

1.5.1.1.3.1
date	97.09.09.14.16.28;	author daveb;	state Exp;
branches;
next	;

1.5.2.1
date	97.09.10.19.34.15;	author brucem;	state Exp;
branches;
next	;

1.5.3.1
date	97.09.11.21.03.20;	author daveb;	state Exp;
branches;
next	;

1.5.4.1
date	97.10.31.13.46.12;	author nickb;	state Exp;
branches;
next	;

1.10.1.1
date	99.04.01.18.02.24;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This used to be src/rts/src/OS/{NT,Win95}/win_exec_delivery.c
@


1.10
log
@[Bug #30484]
Fix delivery for W95
@
text
@/*  ==== EXECUTABLE FILE DELIVERY AND EXECUTION ====
 *
 *  Copyright (C) 1995 Harlequin Ltd.
 *
 *  Description
 *  -----------
 *  This code deals with delivery executables rather than heap images.
 *  There are two halves to this. Firstly, writing such an object,
 *  and secondly, rerunning it
 *  Win32 version.
 *
 *  $Log: src:OS:Win32:exec_delivery.c,v $
 * Revision 1.9  1998/05/19  08:45:50  mitchell
 * [Bug #30383]
 * Find new runtime relative to current one instead of using registry
 *
 * Revision 1.8  1998/04/14  12:48:50  mitchell
 * [Bug #50061]
 * Reverse treatment of command-line argument passing for executables with embedded image
 *
 * Revision 1.7  1998/04/03  14:26:02  johnh
 * [Bug #30383]
 * Initialised length of string passed to RegQueryValueEx.
 *
 * Revision 1.6  1997/11/26  11:44:40  johnh
 * [Bug #30134]
 * Change save_executable to save either console or window application.
 *
 * Revision 1.5  1997/04/08  14:18:44  jont
 * Minor diagnostic fix
 *
 * Revision 1.4  1997/02/26  18:23:08  jont
 * [Bug #1811]
 * Fix ERROR to be MLERROR
 *
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
 * Revision 1.2  1996/05/01  08:53:03  nickb
 * Change to save_executable.
 *
 * Revision 1.1  1996/02/12  11:58:40  stephenb
 * new unit
 * This used to be src/rts/src/OS/{NT,Win95}/win_exec_delivery.c
 *
 * Revision 1.2  1996/01/11  17:22:48  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.1  1995/11/28  13:28:38  jont
 * new unit
 *
 *
 */

#include <errno.h>
#include <stdlib.h>
#include <stdio.h>
#include <windows.h>

#include "gc.h"
#include "utils.h"
#include "exec_delivery.h"
#include "diagnostic.h"
#include "image.h"
#include "main.h"

#define SYMNMLEN 8

#define HEAP_NAME "ML_HEAP"

#define FILE_BUF_LENGTH 256 /* Buffer for expanded executable file names */

/* A COFF header */
typedef struct scnhdr
{
  char            s_name[SYMNMLEN];/* section name */
  long            s_paddr;    /* physical address */
  long            s_vaddr;    /* virtual address */
  long            s_size;     /* section size */
  long            s_scnptr;   /* file ptr to raw data */
  long            s_relptr;   /* file ptr to relocation */
  long            s_lnnoptr;  /* file ptr to line numbers */
  unsigned short  s_nreloc;   /* # reloc entries */
  unsigned short  s_nlnno;    /* # line number entries */
  long            s_flags;    /* flags */
} scnhdr;

long round_heap_size(long size)
{
  /* Round (towards +infinity) to the next 0x200 boundary */
  /* The linker etc seem to like 0x200 boundaries, dunno why */
  return (size + 0x1ff) & 0xfffffe00;
}

mlval save_executable(char *out_file, mlval heap, int console_app)
/* Save a re-executable version of the current system */
/* returns MLUNIT if ok, MLERROR on error of some sort (with errno set) */
{
  FILE *file_in, *file_out;
  int sec_names = 0, new_sec_names = 0;
  void *string_table_buffer = NULL;
  char *rest;
  int ml_heap_name = 0;
  IMAGE_DOS_HEADER dos_header;
  DWORD Signature;
  IMAGE_FILE_HEADER file_header;
  IMAGE_OPTIONAL_HEADER opt_header;
  WORD opt_header_size;
  size_t heap_size, rounded_heap_size;
  long nt_headers_offset, pos1, pos2, ml_heap_increment;
  unsigned long sections, heap_section, ml_heap_ptr, old_heap_size, s, rest_size;
  scnhdr *section = NULL;
  char new_runtime[FILE_BUF_LENGTH];
  DWORD new_length = FILE_BUF_LENGTH;

  if (console_app == APP_CURRENT) {
    new_length = GetModuleFileName(NULL, new_runtime, FILE_BUF_LENGTH-1);
  } else {
    char *tl; DWORD l;
    HANDLE handle;
    WIN32_FIND_DATA found;
    char full_path[FILE_BUF_LENGTH];

    GetModuleFileName(NULL, new_runtime, FILE_BUF_LENGTH-1);

    /* The filename is potentially in short form, so convert to long form */
    strcpy(full_path, new_runtime);
    handle = FindFirstFile(full_path, &found);
    FindClose(handle);
    *(strrchr(full_path, '\\') + 1) = '\0';
    sprintf(new_runtime, "%s%s", full_path, found.cFileName);

    /* Strip off .exe, -g and -windows suffixes */
    l = strlen(new_runtime);
    if (l > 4) { 
      tl = new_runtime + (l-4); 
      if (strcmp(tl, ".exe")     ==0) { *tl = 0; l -= 4; } }
    if (l > 2) {
      tl = new_runtime + (l-2); 
      if (strcmp(tl, "-g")       ==0) { *tl = 0; l -= 2; } }
    if (l > 8) {
      tl = new_runtime + (l-8); 
      if (strcmp(tl, "-windows") ==0) { *tl = 0; l -= 8; } }

    /* Add appropriate suffix */
    if (console_app == APP_CONSOLE) 
      strcat(new_runtime, ".exe");
    else
      strcat(new_runtime, "-windows.exe");
    new_length = strlen(new_runtime);
  }

  if (new_length == 0 || new_length == (FILE_BUF_LENGTH-1)) {
    DIAGNOSTIC(2, "Failed to get module file name %s", runtime, 0);
    errno = EIMAGEOPEN;
    return MLERROR;
  }
  DIAGNOSTIC(1, "saving heap to %s from runtime = %s", out_file, new_runtime);
  file_in = fopen(new_runtime, "rb");
  if (file_in == NULL) {
    errno = EIMAGEOPEN;
    return MLERROR;
  }
  file_out = fopen(out_file, "wb");
  if (file_out == NULL) {
    errno = EIMAGEOPEN;
    fclose(file_in);
    return MLERROR;
  }
  /* Now copy the entirity of the input executable to the output */
  /* Replace an ml heap with the new one */
  /* Expanding or contracting appropriately */
  /* First sort out the early part of the input */
  /* Up to the section table */

  if (fread(&dos_header, sizeof(dos_header), 1, file_in) != 1) {
    DIAGNOSTIC(2, "Failed to read dos file header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  nt_headers_offset = dos_header.e_lfanew;
  if (fseek(file_in, nt_headers_offset, SEEK_SET)) {
    DIAGNOSTIC(2, "Failed to seek to nt image headers in '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  if (fread(&Signature, sizeof(Signature), 1, file_in) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header Signature from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  if (fread(&file_header, sizeof(file_header), 1, file_in) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header file_header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  opt_header_size = file_header.SizeOfOptionalHeader;
  if (fread(&opt_header, opt_header_size, 1, file_in) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header opt_header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  sections = file_header.NumberOfSections;
  DIAGNOSTIC(4, "%d sections found", sections, 0);
  DIAGNOSTIC(4, "allocating %d bytes for sections", sections*sizeof(*section), 0);
  section = malloc(sections * sizeof(*section));  
  if (section == NULL) {
    DIAGNOSTIC(2, "Malloc failed to allocate section header table", 0, 0);
    errno = EIMAGEALLOC;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  DIAGNOSTIC(4, "Sections begin at offset 0x%x", ftell(file_in), 0);
  if (fread(section, sizeof(*section), sections, file_in) != sections) {
    DIAGNOSTIC(2, "Failed to read section header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* Now copy everything from input to output, expanding ML HEAP section */
  if (fwrite(&dos_header, sizeof(dos_header), 1, file_out) != 1) {
    DIAGNOSTIC(2, "Failed to write dos file header to '%s'", out_file, 0);
    errno = EIMAGEWRITE;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* Now we need to pad */
  if (ftell(file_out) != nt_headers_offset) {
    while (ftell(file_out) != nt_headers_offset) {
      char a = '\000';
      if (fwrite(&a, 1, 1, file_out) != 1) {
	DIAGNOSTIC(2, "Failed to write dos file header padding to '%s'", out_file, 0);
	errno = EIMAGEWRITE;
	fclose(file_in);
	fclose(file_out);
	return MLERROR;
      }
    }
  }
  /* Now we're ready for the next bit, */
  /* the Signature, header and optional header */
  if (fwrite(&Signature, sizeof(Signature), 1, file_out) != 1) {
    DIAGNOSTIC(2, "Failed to write nt image header Signature to '%s'", out_file, 0);
    errno = EIMAGEWRITE;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  if (fwrite(&file_header, sizeof(file_header), 1, file_out) != 1) {
    DIAGNOSTIC(2, "Failed to write nt image header file_header to '%s'", out_file, 0);
    errno = EIMAGEWRITE;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* Now the optional bit */
  if (fwrite(&opt_header, opt_header_size, 1, file_out) != 1) {
    DIAGNOSTIC(2, "Failed to write nt image header opt_header to '%s'", out_file, 0);
    errno = EIMAGEWRITE;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* Now find the ML heap section */
  {
    for (heap_section = 0; heap_section < sections; heap_section++) {
      if (strcmp(section[heap_section].s_name, HEAP_NAME) == 0) {
	break;
      }
    }
    if (heap_section >= sections) {
      DIAGNOSTIC(2, "ML heap section missing from '%s'", new_runtime, 0);
      errno = EIMAGEREAD;
      fclose(file_in);
      fclose(file_out);
      return MLERROR;
    }
    ml_heap_ptr = section[heap_section].s_scnptr;
    old_heap_size = section[heap_section].s_size;
    DIAGNOSTIC(4, "ML heap found in section %d", heap_section, 0);
    DIAGNOSTIC(4, "starting at file offset 0x%x, of size 0x%x",
	       ml_heap_ptr, old_heap_size);
  }
  /* Now calculate new heap size */
  if (memory_image_save_size(heap, &heap_size) == MLERROR) {
    /* Calculate required size */
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  };
  rounded_heap_size = round_heap_size(heap_size);
  /* This might be negative. It is how much the following sections have to move */
  ml_heap_increment = rounded_heap_size - section[heap_section].s_size;
  DIAGNOSTIC(3, "New heap requires %d, which rounds to %d",
	  heap_size, rounded_heap_size);
  /* Now increment the section size for ML heap */
  /* Set new heap size */
  section[heap_section].s_size = rounded_heap_size;
  /* Now the section headers */
  for (s = heap_section+1; s < sections; s++) {
    section[s].s_scnptr += ml_heap_increment;
  }
  if (fwrite(section, sizeof(*section), sections, file_out) != sections) {
    DIAGNOSTIC(2, "Failed to write section header to '%s'", out_file, 0);
    errno = EIMAGEWRITE;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* Now the main data */
  /* First see how much there is */
  pos1 = ftell(file_in);
  if (fseek(file_in, 0, SEEK_END)) {
    DIAGNOSTIC(2, "Failed to seek to end of '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  pos2 = ftell(file_in);
  rest_size = pos2 - pos1;
  DIAGNOSTIC(4, "remaining file size = %d, from position %d beyond section headers",
	 rest_size, pos1);
  rest = malloc(rest_size);
  if (rest == NULL) {
    DIAGNOSTIC(2, "Malloc failed to allocate space (%d) for rest of file",
	       rest_size, 0);
    errno = EIMAGEALLOC;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  fseek(file_in, pos1, SEEK_SET);
  DIAGNOSTIC(4, "%s reset to %d", new_runtime, ftell(file_in));
  /* read sections */
  if (fread(rest, 1, rest_size, file_in) != rest_size) {
    DIAGNOSTIC(2, "Failed to read rest of file from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    fclose(file_in);
    fclose(file_out);
    return MLERROR;
  }
  /* print all up to but not including ML_HEAP */
  {
    /* First write out sections before ML_HEAP */
    unsigned long pre_ml_size = ml_heap_ptr - pos1;
    if (fwrite(rest, 1, pre_ml_size, file_out) != pre_ml_size) {
      DIAGNOSTIC(2, "Failed to write early sections of rest of file to '%s'",
		 out_file, 0);
      errno = EIMAGEWRITE;
      fclose(file_in);
      fclose(file_out);
      return MLERROR;
    }
    /* Now write the new ML heap */
    if (image_save_with_open_file(file_out, heap, out_file)) {
      free(rest);
      fclose(file_in);
      fclose(file_out);
      message_start();
      message_string("image save to '");
      message_string(out_file);
      message_string("'failed, '");
      message_string(out_file);
      message_string("' removed");
      message_end();
      if (remove(out_file) != 0) {
	message_stderr("remove failed on '%s'", out_file);
      }
      return MLERROR;
    };
    /* Now pad with rounded_heap_size - heap_size bytes */
    if (rounded_heap_size - heap_size != 0) {
      long i = rounded_heap_size - heap_size;
      while (i-- > 0) {
	char a = '\000';
	if (fwrite(&a, 1, 1, file_out) != 1) {
	  DIAGNOSTIC(2, "Failed to ML heap padding to '%s'", out_file, 0);
	  errno = EIMAGEWRITE;
	  fclose(file_in);
	  fclose(file_out);
	  return MLERROR;
	}
      }
    }
    /* Now write out remaining sections */
    if (fwrite(rest + pre_ml_size + old_heap_size, 1,
	       rest_size - pre_ml_size - old_heap_size, file_out) !=
	rest_size - pre_ml_size - old_heap_size) {
      DIAGNOSTIC(2, "Failed to write remaining sections of rest of file to '%s'",
		 out_file, 0);
      errno = EIMAGEWRITE;
      fclose(file_in);
      fclose(file_out);
      return MLERROR;
    }
  }

  return MLUNIT;
}

int load_heap_from_executable(mlval *heap, const char *runtime, int just_check)
/* Reload the heap from within the executable, or just check if there is one */
/* This returns 0 if done (in which case we shouldn't try to load another heap) */
/* 1 if we failed to find such a section (in which case we continue as before) */
/* otherwise an error has occurred and errno is set */
{
  FILE *file;
  IMAGE_DOS_HEADER dos_header;
  DWORD Signature;
  IMAGE_FILE_HEADER file_header;
  IMAGE_OPTIONAL_HEADER opt_header;
  WORD opt_header_size;
  scnhdr *section = NULL;
  void *heap_data = NULL;
  long ml_heap_ptr;
  long nt_headers_offset;
  unsigned long sections, heap_section;
  size_t heap_size = 0;

  /* First sort out the proper name of the executable, */
  /* since NT isn't clever enough to give it to you */
  char new_runtime[FILE_BUF_LENGTH];
  DWORD new_length = GetModuleFileName(NULL, new_runtime, FILE_BUF_LENGTH-1);
  if (new_length == 0 || new_length == (FILE_BUF_LENGTH-1)) {
    DIAGNOSTIC(2, "Failed to get module file name %s", runtime, 0);
    errno = EIMAGEOPEN;
    return 2;
  }
  DIAGNOSTIC(2, "Entering load_heap_from_executable with runtime = %s", new_runtime, 0);
  file = fopen(new_runtime, "rb");
  if (file == NULL) {
    errno = EIMAGEOPEN;
    return 2;
  }
  DIAGNOSTIC(4, "Opened %s", new_runtime, 0);
  if (fread(&dos_header, sizeof(dos_header), 1, file) != 1) {
    DIAGNOSTIC(2, "Failed to read dos file header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  DIAGNOSTIC(4, "Read DOS header from %s", new_runtime, 0);
  nt_headers_offset = dos_header.e_lfanew;
  if (fseek(file, nt_headers_offset, SEEK_SET)) {
    DIAGNOSTIC(2, "Failed to seek to nt image headers in '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  DIAGNOSTIC(4, "Seeked to nt header in %s", new_runtime, 0);
  if (fread(&Signature, sizeof(Signature), 1, file) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header Signature from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  DIAGNOSTIC(4, "Read signature from %s", new_runtime, 0);
  if (fread(&file_header, sizeof(file_header), 1, file) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header file_header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  opt_header_size = file_header.SizeOfOptionalHeader;
  if (fread(&opt_header, opt_header_size, 1, file) != 1) {
    DIAGNOSTIC(2, "Failed to read nt image header opt_header from '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  sections = file_header.NumberOfSections;
  DIAGNOSTIC(4, "%d sections found", sections, 0);
  DIAGNOSTIC(4, "allocating %d bytes for sections", sections*sizeof(*section), 0);
  section = malloc(sections * sizeof(*section));  
  if (section == NULL) {
    DIAGNOSTIC(2, "Malloc failed to allocate section header table", 0, 0);
    errno = EIMAGEALLOC;
    return 2;
  }
  DIAGNOSTIC(4, "Sections begin at offset 0x%x", ftell(file), 0);
  if (fread(section, sizeof(*section), sections, file) != sections) {
    DIAGNOSTIC(2, "Failed to read section header from '%s'", new_runtime, 0);
    free(section);
    errno = EIMAGEREAD;
    return 2;
  }
  /* Now find the ML_HEAP section header */
  {
    for (heap_section = 0; heap_section < sections; heap_section++) {
      if (strcmp(section[heap_section].s_name, HEAP_NAME) == 0) {
	break;
      }
    }
    if (heap_section >= sections) {
      DIAGNOSTIC(2, "ML heap section missing from '%s'", new_runtime, 0);
      free(section);
      return 1; /* All ok, but no section found */
    }
    ml_heap_ptr = section[heap_section].s_scnptr;
    heap_size = section[heap_section].s_size;
  }
  free(section); /* Table not needed any more */
  /* Now check that this is a real heap, */
  /* not just the dummy one in all executables */
  if (fseek(file, ml_heap_ptr, SEEK_SET)) {
    DIAGNOSTIC(2, "Failed to seek to ML heap data in '%s'", new_runtime, 0);
    errno = EIMAGEREAD;
    return 2;
  }
  if (heap_size <= 0x200) {
    /* Not a real heap */
    DIAGNOSTIC(3, "Not a real heap, returning 1", 0, 0);
    return 1;
  }
  DIAGNOSTIC(1, "Found ML heap with pointer 0x%x and size 0x%x",
	     ml_heap_ptr, heap_size);
  
  if (just_check) {
    fclose(file);
  } else {    
    *heap = image_load_with_open_file(file, new_runtime);
    fclose(file);
    if (*heap == MLERROR) {
      /* Something went wrong */
      DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
      return 2;
    }
  }
  return 0;
}

@


1.10.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.10  1998/08/28  16:10:40  mitchell
 * [Bug #30484]
 * Fix delivery for W95
 *
@


1.9
log
@[Bug #30383]
Find new runtime relative to current one instead of using registry
@
text
@d13 4
d120 4
d125 7
@


1.8
log
@[Bug #50061]
Reverse treatment of command-line argument passing for executables with embedded image
@
text
@d13 4
a110 3
  int key_result;
  long query_result;
  HKEY key, key2;
d115 14
a128 32
    key_result = 
      RegOpenKeyEx(HKEY_CURRENT_USER, "Software", 0, KEY_EXECUTE, &key);
    if (key_result) {
      DIAGNOSTIC(2, 
	 "Failed to open registry key:  HKEY_CURRENT_USER/Software", new_runtime, 0);
      errno = EIMAGEOPEN;
      return MLERROR;
    }
    key_result = 
      RegOpenKeyEx(key, "Harlequin", 0, KEY_EXECUTE, &key2);
    if (key_result) {
      DIAGNOSTIC(2, 
         "Failed to open registry key:  HKEY_CURRENT_USER/Software/Harlequin", new_runtime, 0);
      errno = EIMAGEOPEN;
      return MLERROR;
    }
    key_result = 
      RegOpenKeyEx(key2, "MLWorks", 0, KEY_EXECUTE, &key);
    if (key_result) {
      DIAGNOSTIC(2, 
         "Failed to open registry key:  HKEY_CURRENT_USER/Software/Harlequin/MLWorks", new_runtime, 0);
      errno = EIMAGEOPEN;
      return MLERROR;
    }
    query_result = RegQueryValueEx(key, "Startup Directory", NULL, NULL,
				   new_runtime, &new_length);
    if (query_result) {
      DIAGNOSTIC(2, 
         "Failed to query registry key:  HKEY_CURRENT_USER/Software/Harlequin/MLWorks", new_runtime, 0);
      errno = EIMAGEOPEN;
      return MLERROR;
    }
d130 1
d132 1
a132 1
      strcat(new_runtime, "/bin/main.exe");
d134 2
a135 1
      strcat(new_runtime, "/bin/main-windows.exe");
@


1.7
log
@[Bug #30383]
Initialised length of string passed to RegQueryValueEx.
@
text
@d13 4
d415 2
a416 2
int load_heap_from_executable(mlval *heap, const char *runtime)
/* Reload the heap from within the executable */
d527 10
a536 6
  *heap = image_load_with_open_file(file, new_runtime);
  fclose(file);
  if (*heap == MLERROR) {
    /* Something went wrong */
    DIAGNOSTIC(1, "load_heap_from_executable gets bad heap %p", *heap, 0);
    return 2;
d540 1
@


1.6
log
@[Bug #30134]
Change save_executable to save either console or window application.
@
text
@d13 4
d102 1
a102 1
  DWORD new_length;
d134 1
a134 1
    query_result = RegQueryValueEx(key, "Startup Directory", NULL, NULL, 
@


1.5
log
@Minor diagnostic fix
@
text
@d13 3
d79 1
a79 1
mlval save_executable(char *out_file, mlval heap)
d98 47
a144 1
  DWORD new_length = GetModuleFileName(NULL, new_runtime, FILE_BUF_LENGTH-1);
@


1.5.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 3
 * Revision 1.5  1997/04/08  14:18:44  jont
 * Minor diagnostic fix
 *
@


1.5.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 3
 * Revision 1.5  1997/04/08  14:18:44  jont
 * Minor diagnostic fix
 *
@


1.5.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 3
 * Revision 1.5  1997/04/08  14:18:44  jont
 * Minor diagnostic fix
 *
@


1.5.1.1
log
@branched from 1.5
@
text
@a12 3
 * Revision 1.5  1997/04/08  14:18:44  jont
 * Minor diagnostic fix
 *
@


1.5.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.5.1.1  1997/05/12  10:47:07  hope
 * branched from 1.5
 *
@


1.5.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.5.1.1  1997/05/12  10:47:07  hope
 * branched from 1.5
 *
@


1.5.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.5.1.1  1997/05/12  10:47:07  hope
 * branched from 1.5
 *
@


1.5.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.5.1.1.1.1  1997/07/28  18:27:16  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4
log
@[Bug #1811]
Fix ERROR to be MLERROR
@
text
@d13 4
d97 1
a97 1
    DIAGNOSTIC(2, "Failed to get module file name %s\n", runtime, 0);
d101 1
a101 1
  DIAGNOSTIC(1, "saving heap to %s from runtime = %s\n", out_file, new_runtime);
d120 1
a120 1
    DIAGNOSTIC(2, "Failed to read dos file header from '%s'\n", new_runtime, 0);
d128 1
a128 1
    DIAGNOSTIC(2, "Failed to seek to nt image headers in '%s'\n", new_runtime, 0);
d135 1
a135 1
    DIAGNOSTIC(2, "Failed to read nt image header Signature from '%s'\n", new_runtime, 0);
d142 1
a142 1
    DIAGNOSTIC(2, "Failed to read nt image header file_header from '%s'\n", new_runtime, 0);
d150 1
a150 1
    DIAGNOSTIC(2, "Failed to read nt image header opt_header from '%s'\n", new_runtime, 0);
d157 2
a158 2
  DIAGNOSTIC(4, "%d sections found\n", sections, 0);
  DIAGNOSTIC(4, "allocating %d bytes for sections\n", sections*sizeof(*section), 0);
d161 1
a161 1
    DIAGNOSTIC(2, "Malloc failed to allocate section header table\n", 0, 0);
d167 1
a167 1
  DIAGNOSTIC(4, "Sections begin at offset 0x%x\n", ftell(file_in), 0);
d169 1
a169 1
    DIAGNOSTIC(2, "Failed to read section header from '%s'\n", new_runtime, 0);
d177 1
a177 1
    DIAGNOSTIC(2, "Failed to write dos file header to '%s'\n", out_file, 0);
d188 1
a188 1
	DIAGNOSTIC(2, "Failed to write dos file header padding to '%s'\n", out_file, 0);
d199 1
a199 1
    DIAGNOSTIC(2, "Failed to write nt image header Signature to '%s'\n", out_file, 0);
d206 1
a206 1
    DIAGNOSTIC(2, "Failed to write nt image header file_header to '%s'\n", out_file, 0);
d214 1
a214 1
    DIAGNOSTIC(2, "Failed to write nt image header opt_header to '%s'\n", out_file, 0);
d228 1
a228 1
      DIAGNOSTIC(2, "ML heap section missing from '%s'\n", new_runtime, 0);
d236 2
a237 2
    DIAGNOSTIC(4, "ML heap found in section %d\n", heap_section, 0);
    DIAGNOSTIC(4, "starting at file offset 0x%x, of size 0x%x\n",
d250 1
a250 1
  DIAGNOSTIC(3, "New heap requires %d, which rounds to %d\n",
d260 1
a260 1
    DIAGNOSTIC(2, "Failed to write section header to '%s'\n", out_file, 0);
d270 1
a270 1
    DIAGNOSTIC(2, "Failed to seek to end of '%s'\n", new_runtime, 0);
d278 1
a278 1
  DIAGNOSTIC(4, "remaining file size = %d, from position %d beyond section headers\n",
d282 1
a282 1
    DIAGNOSTIC(2, "Malloc failed to allocate space (%d) for rest of file\n",
d290 1
a290 1
  DIAGNOSTIC(4, "%s reset to %d\n", new_runtime, ftell(file_in));
d293 1
a293 1
    DIAGNOSTIC(2, "Failed to read rest of file from '%s'\n", new_runtime, 0);
d304 1
a304 1
      DIAGNOSTIC(2, "Failed to write early sections of rest of file to '%s'\n",
d334 1
a334 1
	  DIAGNOSTIC(2, "Failed to ML heap padding to '%s'\n", out_file, 0);
d346 1
a346 1
      DIAGNOSTIC(2, "Failed to write remaining sections of rest of file to '%s'\n",
d382 1
a382 1
    DIAGNOSTIC(2, "Failed to get module file name %s\n", runtime, 0);
d386 1
a386 1
  DIAGNOSTIC(2, "Entering load_heap_from_executable with runtime = %s\n", new_runtime, 0);
d392 1
a392 1
  DIAGNOSTIC(4, "Opened %s\n", new_runtime, 0);
d394 1
a394 1
    DIAGNOSTIC(2, "Failed to read dos file header from '%s'\n", new_runtime, 0);
d398 1
a398 1
  DIAGNOSTIC(4, "Read DOS header from %s\n", new_runtime, 0);
d401 1
a401 1
    DIAGNOSTIC(2, "Failed to seek to nt image headers in '%s'\n", new_runtime, 0);
d405 1
a405 1
  DIAGNOSTIC(4, "Seeked to nt header in %s\n", new_runtime, 0);
d407 1
a407 1
    DIAGNOSTIC(2, "Failed to read nt image header Signature from '%s'\n", new_runtime, 0);
d411 1
a411 1
  DIAGNOSTIC(4, "Read signature from %s\n", new_runtime, 0);
d413 1
a413 1
    DIAGNOSTIC(2, "Failed to read nt image header file_header from '%s'\n", new_runtime, 0);
d419 1
a419 1
    DIAGNOSTIC(2, "Failed to read nt image header opt_header from '%s'\n", new_runtime, 0);
d424 2
a425 2
  DIAGNOSTIC(4, "%d sections found\n", sections, 0);
  DIAGNOSTIC(4, "allocating %d bytes for sections\n", sections*sizeof(*section), 0);
d428 1
a428 1
    DIAGNOSTIC(2, "Malloc failed to allocate section header table\n", 0, 0);
d432 1
a432 1
  DIAGNOSTIC(4, "Sections begin at offset 0x%x\n", ftell(file), 0);
d434 1
a434 1
    DIAGNOSTIC(2, "Failed to read section header from '%s'\n", new_runtime, 0);
d447 1
a447 1
      DIAGNOSTIC(2, "ML heap section missing from '%s'\n", new_runtime, 0);
d458 1
a458 1
    DIAGNOSTIC(2, "Failed to seek to ML heap data in '%s'\n", new_runtime, 0);
d464 1
a464 1
    DIAGNOSTIC(3, "Not a real heap, returning 1\n", 0, 0);
@


1.3
log
@Cockup.
@
text
@d13 3
d74 1
a74 1
/* returns MLUNIT if ok, ERROR on error of some sort (with errno set) */
d237 1
a237 1
  if (memory_image_save_size(heap, &heap_size) == ERROR) {
d468 1
a468 1
  if (*heap == ERROR) {
@


1.3.8.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.7.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.7.1.1.1
log
@branched from 1.3.7.1
@
text
@a12 3
 * Revision 1.3.7.1  1996/12/17  17:57:26  hope
 * branched from 1.3
 *
@


1.3.6.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.5.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.4.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.4.1.1.1
log
@branched from 1.3.4.1
@
text
@a12 3
 * Revision 1.3.4.1  1996/11/14  13:01:17  hope
 * branched from 1.3
 *
@


1.3.3.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.2.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a12 3
 * Revision 1.3  1996/05/02  12:00:45  nickb
 * Cockup.
 *
@


1.2
log
@Change to save_executable.
@
text
@d13 3
d76 1
@


1.1
log
@new unit
This used to be src/rts/src/OS/{NT,Win95}/win_exec_delivery.c
@
text
@d12 5
a16 1
 *  $Log: src:OS:common:win_exec_delivery.c,v $
d66 1
a66 1
mlval save_executable(mlval argument)
a70 2
  char *out_file = CSTRING(FIELD(argument, 0)), *rest;
  mlval heap = FIELD(argument, 1);
d88 1
a88 1
    return 2;
d94 1
a94 1
    return ERROR;
d100 1
a100 1
    return ERROR;
d113 1
a113 1
    return ERROR;
d121 1
a121 1
    return ERROR;
d128 1
a128 1
    return ERROR;
d135 1
a135 1
    return ERROR;
d143 1
a143 1
    return ERROR;
d154 1
a154 1
    return ERROR;
d162 1
a162 1
    return ERROR;
d170 1
a170 1
    return ERROR;
d181 1
a181 1
	return ERROR;
d192 1
a192 1
    return ERROR;
d199 1
a199 1
    return ERROR;
d207 1
a207 1
    return ERROR;
d221 1
a221 1
      return ERROR;
d234 1
a234 1
    return ERROR;
d253 1
a253 1
    return ERROR;
d263 1
a263 1
    return ERROR;
d276 1
a276 1
    return ERROR;
d286 1
a286 1
    return ERROR;
d298 1
a298 1
      return ERROR;
d315 1
a315 1
      return ERROR;
d327 1
a327 1
	  return ERROR;
d340 1
a340 1
      return ERROR;
a342 2


@
