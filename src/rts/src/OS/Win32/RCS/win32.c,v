head	1.50;
access;
symbols
	MLW_daveb_inline_1_4_99:1.50.1
	MLWorks_21c0_1999_03_25:1.50
	MLWorks_20c1_1998_08_20:1.41
	MLWorks_20c0_1998_08_04:1.38
	MLWorks_20b2c2_1998_06_19:1.36
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.34
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.30
	MLWorks_MM_adapt:1.29.1
	MLWorks_20m1_1997_10_23:1.28
	MLWorks_11r1:1.26.1.2.1.1.1
	MLWorks_workspace_97:1.28.2
	MLWorks_dt_wizard:1.28.1
	MLWorks_11c0_1997_09_09:1.26.1.2.1.1
	MLWorks_10r3:1.26.1.2.3
	MLWorks_10r2_551:1.26.1.2.2
	MLWorks_11:1.26.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.26.1.2
	MLWorks_20m0_1997_06_20:1.28
	MLWorks_1_0_r2c2_1997_06_14:1.26.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.26.1.2
	MLWorks_1_0_r2c1_1997_05_12:1.26.1
	MLWorks_BugFix_1997_04_24:1.26
	MLWorks_1_0_r2_Win32_1997_04_11:1.26
	MLWorks_1_0_r2_Unix_1997_04_04:1.26
	MM_ML_release_korma_1997_04_01:1.25
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.22.3.1.1
	MLWorks_gui_1996_12_18:1.22.4
	MLWorks_1_0_Win32_1996_12_17:1.22.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.21.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.21.1.1
	JFHrts:1.22.2
	MLWorks_1_0_Irix_1996_11_28:1.21.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.22.1
	MLWorks_1_0_Unix_1996_11_14:1.21.1
	MLWorks_Open_Beta2_1996_10_11:1.19.3
	MLWorks_License_dev:1.19.2
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.18
	MLWorks_Beta_1996_07_02:1.13
	MLWorks_Beta_1996_06_07:1.10
	MLWorks_Beta_1996_06_06:1.10
	MLWorks_Beta_1996_06_05:1.10
	MLWorks_Beta_1996_06_03:1.9
	MLWorks_Beta_1996_05_31:1.9
	MLWorks_Beta_1996_05_30:1.9;
locks; strict;
comment	@ * @;


1.50
date	99.03.18.12.41.29;	author daveb;	state Exp;
branches
	1.50.1.1;
next	1.49;

1.49
date	99.03.18.12.28.28;	author daveb;	state Exp;
branches;
next	1.48;

1.48
date	98.11.03.14.30.08;	author jont;	state Exp;
branches;
next	1.47;

1.47
date	98.11.02.15.07.18;	author jont;	state Exp;
branches;
next	1.46;

1.46
date	98.10.29.16.30.14;	author jont;	state Exp;
branches;
next	1.45;

1.45
date	98.10.27.15.58.22;	author jont;	state Exp;
branches;
next	1.44;

1.44
date	98.10.12.16.29.11;	author jont;	state Exp;
branches;
next	1.43;

1.43
date	98.10.02.09.56.13;	author jont;	state Exp;
branches;
next	1.42;

1.42
date	98.08.21.14.09.29;	author jont;	state Exp;
branches;
next	1.41;

1.41
date	98.08.18.11.52.29;	author jont;	state Exp;
branches;
next	1.40;

1.40
date	98.08.17.11.16.52;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	98.08.11.14.57.47;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	98.08.04.08.20.25;	author mitchell;	state Exp;
branches;
next	1.37;

1.37
date	98.07.03.12.32.17;	author mitchell;	state Exp;
branches;
next	1.36;

1.36
date	98.06.17.14.48.16;	author johnh;	state Exp;
branches;
next	1.35;

1.35
date	98.06.05.14.24.58;	author mitchell;	state Exp;
branches;
next	1.34;

1.34
date	98.04.22.12.31.24;	author johnh;	state Exp;
branches;
next	1.33;

1.33
date	98.04.21.11.37.01;	author jont;	state Exp;
branches;
next	1.32;

1.32
date	98.04.07.14.25.08;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	98.02.24.11.22.58;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	98.01.16.15.39.35;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	97.10.30.10.53.24;	author johnh;	state Exp;
branches
	1.29.1.1;
next	1.28;

1.28
date	97.05.22.08.50.07;	author johnh;	state Exp;
branches
	1.28.1.1
	1.28.2.1;
next	1.27;

1.27
date	97.05.21.10.51.55;	author stephenb;	state Exp;
branches;
next	1.26;

1.26
date	97.03.27.16.23.51;	author andreww;	state Exp;
branches
	1.26.1.1;
next	1.25;

1.25
date	97.03.24.11.58.14;	author andreww;	state Exp;
branches;
next	1.24;

1.24
date	97.03.24.11.31.41;	author andreww;	state Exp;
branches;
next	1.23;

1.23
date	97.03.05.17.48.33;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	96.11.22.14.21.41;	author daveb;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1
	1.22.4.1;
next	1.21;

1.21
date	96.10.28.10.54.59;	author stephenb;	state Exp;
branches
	1.21.1.1;
next	1.20;

1.20
date	96.10.25.10.33.06;	author johnh;	state Exp;
branches;
next	1.19;

1.19
date	96.08.22.12.00.39;	author stephenb;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1;
next	1.18;

1.18
date	96.08.19.13.28.17;	author stephenb;	state Exp;
branches;
next	1.17;

1.17
date	96.08.19.13.22.37;	author stephenb;	state Exp;
branches;
next	1.16;

1.16
date	96.07.15.16.35.20;	author andreww;	state Exp;
branches;
next	1.15;

1.15
date	96.07.04.18.42.57;	author andreww;	state Exp;
branches;
next	1.14;

1.14
date	96.07.04.11.25.46;	author stephenb;	state Exp;
branches;
next	1.13;

1.13
date	96.06.13.12.55.37;	author stephenb;	state Exp;
branches;
next	1.12;

1.12
date	96.06.13.10.10.04;	author stephenb;	state Exp;
branches;
next	1.11;

1.11
date	96.06.12.12.40.42;	author stephenb;	state Exp;
branches;
next	1.10;

1.10
date	96.06.04.12.15.02;	author stephenb;	state Exp;
branches;
next	1.9;

1.9
date	96.05.28.13.08.18;	author stephenb;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.12.09.18;	author stephenb;	state Exp;
branches;
next	1.7;

1.7
date	96.04.22.12.47.12;	author brianm;	state Exp;
branches;
next	1.6;

1.6
date	96.04.17.09.29.29;	author stephenb;	state Exp;
branches;
next	1.5;

1.5
date	96.04.11.16.19.33;	author brianm;	state Exp;
branches;
next	1.4;

1.4
date	96.04.01.09.41.09;	author stephenb;	state Exp;
branches;
next	1.3;

1.3
date	96.03.12.16.02.27;	author matthew;	state Exp;
branches;
next	1.2;

1.2
date	96.03.05.12.54.51;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	96.02.20.10.19.28;	author stephenb;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.22.34;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.10.07.16.12.40;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.10.17.11.31.43;	author hope;	state Exp;
branches;
next	;

1.21.1.1
date	96.11.14.12.57.47;	author hope;	state Exp;
branches
	1.21.1.1.1.1;
next	;

1.21.1.1.1.1
date	96.11.28.15.07.48;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	96.11.22.18.15.30;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.12.17.10.02.13;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.12.17.17.53.57;	author hope;	state Exp;
branches
	1.22.3.1.1.1;
next	;

1.22.3.1.1.1
date	97.02.24.11.44.59;	author hope;	state Exp;
branches;
next	;

1.22.4.1
date	96.12.18.09.48.31;	author hope;	state Exp;
branches;
next	;

1.26.1.1
date	97.05.12.10.40.56;	author hope;	state Exp;
branches;
next	1.26.1.2;

1.26.1.2
date	97.05.21.13.18.55;	author daveb;	state Exp;
branches
	1.26.1.2.1.1
	1.26.1.2.2.1
	1.26.1.2.3.1;
next	;

1.26.1.2.1.1
date	97.07.28.18.29.08;	author daveb;	state Exp;
branches
	1.26.1.2.1.1.1.1;
next	;

1.26.1.2.1.1.1.1
date	97.10.07.11.54.58;	author jkbrook;	state Exp;
branches;
next	;

1.26.1.2.2.1
date	97.09.08.17.22.06;	author daveb;	state Exp;
branches;
next	;

1.26.1.2.3.1
date	97.09.09.14.18.10;	author daveb;	state Exp;
branches;
next	;

1.28.1.1
date	97.09.10.19.37.30;	author brucem;	state Exp;
branches;
next	;

1.28.2.1
date	97.09.11.21.05.26;	author daveb;	state Exp;
branches;
next	;

1.29.1.1
date	97.10.31.13.48.29;	author nickb;	state Exp;
branches;
next	;

1.50.1.1
date	99.04.01.18.04.12;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
This used to be src/rts/src/OS/common/win32.c
@


1.50
log
@[Bug #190523]
Changes to the Windows structure.
@
text
@/* Copyright (C) 1994 Harlequin Ltd
 *
 * A misc. collection of Win32 routines needed to support various libraries,
 * but mainly OS.*.  For historic reasons many of the functions are prefixed
 * by win32_, but there is a rolling program to change the prefix to mlw_
 * to avoid any namespace collision problems.  Note that the change isn't
 * strictly necessary for static functions/values but for consistency
 * these have the mlw_ prefix too.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win32:win32.c,v $
 * Revision 1.49  1999/03/18  12:28:28  daveb
 * [Bug #190521]
 * OS.FileSys.readDir now returns an option type.
 *
 * Revision 1.48  1998/11/03  14:30:08  jont
 * [Bug #70234]
 * Add calls to GetEnvironmentStrings and FreeEnvironmentStrings
 * and pass result as environment in call to CreateProcess
 *
 * Revision 1.47  1998/11/02  15:07:18  jont
 * [Bug #70238]
 * Use WaitForSingleObject istead of busy wait in Windows.execute
 *
 * Revision 1.46  1998/10/29  16:30:14  jont
 * [Bug #70232]
 * Pass correct command line to CreateProcess (70233)
 * Close leftover handles
 *
 * Revision 1.45  1998/10/27  15:58:22  jont
 * [Bug #70220]
 * Add reap function
 *
 * Revision 1.44  1998/10/12  16:29:11  jont
 * [Bug #30490]
 * Get streams from Windows.streamsOf in the right order (they were reversed)
 *
 * Revision 1.43  1998/10/02  09:56:13  jont
 * [Bug #50095]
 * Fix Windows.hasOwnConsole
 *
 * Revision 1.42  1998/08/21  14:09:29  jont
 * [Bug #30108]
 * Implement DLL based ML code
 *
 * Revision 1.41  1998/08/18  11:52:29  jont
 * [Bug #70153]
 * Add prototype for system_validate_ml_address
 *
 * Revision 1.40  1998/08/17  11:16:52  jont
 * [Bug #70153]
 * Add system_validate_ml_address
 *
 * Revision 1.39  1998/08/11  14:57:47  jont
 * [Bug #50094]
 * Fix problems where findExecutable is returning wrong answers
 *
 * Revision 1.38  1998/08/04  08:20:25  mitchell
 * [Bug #30461]
 * Add missing FindClose to  mlw_os_file_sys_full_path
 *
 * Revision 1.37  1998/07/03  12:32:17  mitchell
 * [Bug #30434]
 * Fix access path parameter passing for registry functions
 *
 * Revision 1.36  1998/06/17  14:48:16  johnh
 * [Bug #50083]
 * Convert from short filename to long.
 *
 * Revision 1.35  1998/06/05  14:24:58  mitchell
 * [Bug #30416]
 * Add support for CREATE_ALWAYS
 *
 * Revision 1.34  1998/04/22  12:31:24  johnh
 * [Bug #70042]
 * Fix fullPath to succeed on root directories.
 *
 * Revision 1.33  1998/04/21  11:37:01  jont
 * [Bug #70107]
 * Add a function to close file descriptors opened by _open_osfhandle
 *
 * Revision 1.32  1998/04/07  14:25:08  jont
 * [Bug #70086]
 * Add functions necessary to implement WINDOWS signature in basis
 *
 * Revision 1.31  1998/02/24  11:22:58  jont
 * [Bug #70018]
 * Modify declare_root to accept a second parameter
 * indicating whether the root is live for image save
 *
 * Revision 1.30  1998/01/16  15:39:35  jont
 * [Bug #70028]
 * Fix problem with trailing \
 * in mlval mlw_os_file_sys_full_path
 *
 * Revision 1.29  1997/10/30  10:53:24  johnh
 * [Bug #30233]
 * Fix create_process.
 *
 * Revision 1.28  1997/05/22  08:50:07  johnh
 * [Bug #01702]
 * mlw_win32_strerror moved to win32_error.h.
 *
 * Revision 1.27  1997/05/21  10:51:55  stephenb
 * [Bug #30142]
 * Change the type of a handle in mlw_dirstream from an int to a boxed
 * int since under Win95 the handle seems to have its bottom bits set.
 *
 * Revision 1.26  1997/03/27  16:23:51  andreww
 * [Bug #2004]
 * make win32_seek seek to current position when third arg=1
 *
 * Revision 1.25  1997/03/24  11:58:14  andreww
 * whoops, correcting previous bug numeber from 1431 -> 1968
 *
 * Revision 1.24  1997/03/24  11:31:41  andreww
 * [Bug #1968]
 * Have to fix stdIN, stdOut and stdErr on every image load.
 *
 * Revision 1.23  1997/03/05  17:48:33  jont
 * [Bug #1940]
 * Modify fullPath to raise OS.SysErr if the file/dir doesn't exist
 *
 * Revision 1.22  1996/11/22  14:21:41  daveb
 * Prevented reg_query_value from raising an exception.
 *
 * Revision 1.21  1996/10/28  10:54:59  stephenb
 * [Bug #1701]
 * mlw_os_process_getenv: remove redundant calls to declare/retract_root.
 *
 * Revision 1.20  1996/10/25  10:33:06  johnh
 * [Bug #1426]
 * Replaced Win32 environment with Windows registry.
 *
 * Revision 1.19  1996/08/22  12:00:39  stephenb
 * [Bug #1554]
 * Reimplement OS.IO.kind
 *
 * Revision 1.18  1996/08/19  13:28:17  stephenb
 * win32_open: change the mode to FILE_SHARE_READ|FILE_SHARE_WRITE so
 * that it is possible to open the same file as input and output.
 * This feature is used by test_suite/basis/os_io.sml to test out
 * the OS.IO stuff.
 *
 * Revision 1.17  1996/08/19  13:22:37  stephenb
 * mlw_os_error_msg: remove a debugging printf left over from
 * when this was originally being implemented.
 *
 * Revision 1.16  1996/07/15  16:35:20  andreww
 * Removing system-specific information from the names of the calls
 * to read, write, seek and close.
 *
 * Revision 1.15  1996/07/04  18:42:57  andreww
 * Debugging code of the win32 size and seek routines,
 * and adding handles for standard in, standard out and standard error
 * streams.
 *
 * Revision 1.14  1996/07/04  11:25:46  stephenb
 * Fix #1456 - add declare/retract roots where necessary.
 *
 * Revision 1.13  1996/06/13  12:55:37  stephenb
 * Add support for OS.FileSys.{setTime,isDir}.
 *
 * Revision 1.12  1996/06/13  10:10:04  stephenb
 * Change the filename part of the dirstream type to be a ref.
 * This is because it the filename is updated by the runtime and without
 * going via a ref, the GC gets confused.  Updated the OS.FileSys.*Dir
 * routines accordingly.
 *
 * Revision 1.10  1996/06/04  12:15:02  stephenb
 * Add more functions to support the latest revised basis definition.
 *
 * Revision 1.9  1996/05/28  13:08:18  stephenb
 * Add support for OS.errorName, OS.syserror and OS.errorMsg
 *
 * Revision 1.8  1996/05/07  12:09:18  stephenb
 * Add support for Time and OS.IO
 *
 * Revision 1.7  1996/04/22  12:47:12  brianm
 * Adding launch process with priority.
 *
 * Revision 1.6  1996/04/17  09:29:29  stephenb
 * Add various routines to support OS.Process.
 *
 * Revision 1.5  1996/04/11  16:19:33  brianm
 * Adding dde_init() call ...
 *
 * Revision 1.4  1996/04/01  09:41:09  stephenb
 * Rationalise the exception handling so that all the routines that
 * raise exceptions raise one that is compatible with Os.SysErr as
 * defined in the latest basis.
 *
 * Revision 1.3  1996/03/12  16:02:27  matthew
 * Adding set wd.
 *
 * Revision 1.2  1996/03/05  12:54:51  jont
 * Add support for osprimio in revised initial basis
 *
 * Revision 1.1  1996/02/20  10:19:28  stephenb
 * new unit
 * This used to be src/rts/src/OS/common/win32.c
 *
 * Revision 1.12  1996/02/19  15:48:01  nickb
 * win32_environment memoizes the Windows environment. This is not
 * necessary: we can do it in ML if we decide it's a good idea.
 *
 * Revision 1.11  1996/02/16  12:51:41  nickb
 * Change to declare_global().
 *
 * Revision 1.10  1996/01/22  16:07:21  stephenb
 * Update the declare_global so that it uses the same name as the env_value
 * for the Win32 exception.
 *
 * Revision 1.9  1996/01/22  15:20:11  stephenb
 * Generally replace "win_nt" with "win32".
 * Change the name of the exceptions since they are no longer pervasive.
 * Removed any functions that are not actually made available on the ML side.
 *
 * Revision 1.8  1996/01/18  15:41:46  stephenb
 * Now that the name of the file has changed (nt -> win32), the
 * name of the corresponding .h file needs to change.
 *
 * Revision 1.7  1996/01/15  16:04:41  matthew
 * Adding directory functions
 *
 * Revision 1.6  1995/09/19  15:41:10  jont
 * Fix problems with C ordering of evaluation of function parameters
 * interaction with gc and C roots
 *
 * Revision 1.5  1995/08/02  15:33:57  jont
 * Remove windows.h
 *
 * Revision 1.4  1995/02/08  13:43:18  jont
 * Change environ to _environ
 *
 * Revision 1.3  1995/01/24  17:51:00  jont
 * Fix problem with realpath (nt_getpathname)
 *
 * Revision 1.2  1995/01/12  15:32:04  jont
 * Add getcd connecting to GetCurrentDirectory
 * Add get_path_name connecting to GetFullPathName
 *
 * Revision 1.1  1994/12/12  14:29:34  jont
 * new file
 *
 *
 */

#include <windows.h>
#include <io.h>			/* _open_osfhandle, access */
#include <fcntl.h>		/* _open_osfhandle, O_RDONLY */
#include <assert.h>		/* assert */
#include <errno.h>		/* errno, ENOENT, ... etc. */
#include <sys/types.h>		/* _fstat, _open_osfhandle */
#include <sys/stat.h>		/* _fstat, _open_osfhandle */
#include <stdlib.h>
#include "win32.h"
#include "values.h"
#include "allocator.h"
#include "gc.h"
#include "environment.h"
#include "global.h"
#include "exceptions.h"
#include "utils.h"
#include "time_date.h"		/* mlw_time_to_file_time */
#include "os_errors.h"		/* mlw_os_syserror ... */
#include "win32_error.h"        /* mlw_win32_strerror ... */
#include "os.h"		        /* system_validate_ml_address ... */
#include "window.h"
#include "words.h"
#include "cache.h"

mlval win32_std_in;
mlval win32_std_out;
mlval win32_std_err;

/* the standard In/Out/Err handles have to be fixed up at every
 * invocation of MLWorks.  Otherwise, (e.g.) a batch compiler will try
 * to use the handle defined for the compiler that compiled it!
 */

static void fix_win32_std_io(const char *name, mlval *root, mlval value)
{
  if(root == &win32_std_in)
    mlw_ref_update(value,MLINT(GetStdHandle(STD_INPUT_HANDLE)));
  else if(root == &win32_std_out)
    mlw_ref_update(value,MLINT(GetStdHandle(STD_OUTPUT_HANDLE)));
  else if(root == &win32_std_err)
    mlw_ref_update(value,MLINT(GetStdHandle(STD_ERROR_HANDLE)));
  else
    error("fix_win32_std_io was called on a unknown root 0x%X", root);

  *root = value;
}


/*
 * OS.errorMsg : syserror -> string
 */
static mlval mlw_os_error_msg(mlval arg)
{
  unsigned int error_code= CWORD(arg);
  mlval error_msg;
  error_msg= ((error_code&0x1) == 0)
    ? mlw_win32_strerror(error_code>>1)
    : ml_string(strerror((int)(error_code>>1)));
  return error_msg;
}



/* Some utilities */

static inline mlval box(UINT x)
{
  mlval b = allocate_string(sizeof(x));
  memcpy(CSTRING(b), (char *)&x, sizeof(x));
  return(b);
}

static inline UINT unbox(mlval b)
{
  UINT x;
  memcpy((char *)&x, CSTRING(b), sizeof(x));
  return(x);
}

#define CHKEY(x) ((HKEY)unbox (x))
#define MLHKEY(x) ((mlval)box ((UINT)x))

#define CREGSAM(x) ((REGSAM)unbox (x))
#define MLREGSAM(x) ((mlval)box ((UINT)x))

mlval ml_hkey_classes_root;
mlval ml_hkey_current_user;
mlval ml_hkey_local_machine;
mlval ml_hkey_users;

/* REGISTRY FUNCTIONS */

/* Security Access Masks */

static REGSAM convert_sam_values (mlval arg)
{
  extern unsigned word32_to_num(mlval word32);
  return (word32_to_num (arg));
}

static mlval reg_close_key (mlval arg)
{
  HKEY hkey = CHKEY (arg);
  long result;

  result = RegCloseKey(hkey);
  if (result)
    exn_raise_syserr(mlw_win32_strerror(result), (result<<1));
  return (MLUNIT);
}

/* This function returns an HKEY option value as opposed to the
 * Windows functionality of returning an indication of success or failure */
static mlval reg_open_key_ex (mlval arg)
{
  HKEY hkey = CHKEY(FIELD(arg, 0));
  char *subkey = CSTRING(FIELD(arg, 1));
  REGSAM security_mask = (REGSAM) convert_sam_values (FIELD (arg, 2));
  HKEY return_key;
  int result;

  result = RegOpenKeyEx(hkey, subkey, 0, security_mask, &return_key);
  if (result) {
    return mlw_option_make_none();
  } else {
    return mlw_option_make_some(MLHKEY (return_key));
  }
}

/*
 * This function returns an create_result option value as opposed to the
 * Windows functionality of returning an indication of success or failure
 * datatype create_result = CREATED_NEW_KEY of hkey | OPENED_EXISTING_KEY of hkey
 * datatype options = VOLATILE | NON_VOLATILE
 */

static mlval reg_create_key_ex (mlval arg)
{
  HKEY hkey = CHKEY(FIELD(arg, 0));
  char *subkey = CSTRING(FIELD(arg, 1));
  int options = ((CINT(FIELD(arg, 2))) == 0) ? REG_OPTION_NON_VOLATILE : REG_OPTION_VOLATILE;
  REGSAM security_mask = (REGSAM) convert_sam_values (FIELD (arg, 3));
  HKEY return_key;
  SECURITY_ATTRIBUTES attr = {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
  DWORD disposition;
  long result = RegCreateKeyEx(hkey, subkey, 0, NULL, options, security_mask, &attr, &return_key, &disposition);
  if (result == ERROR_SUCCESS) {
    int res_type = MLINT((disposition == REG_CREATED_NEW_KEY) ? 0 : 1);
    mlval create_result;
    mlval res_key = MLHKEY(return_key);
    declare_root(&res_key, 0);
    create_result = allocate_record(2);
    FIELD(create_result, 0) = res_type;
    FIELD(create_result, 1) = res_key;
    retract_root(&res_key);
    return mlw_option_make_some(create_result);
  } else {
    exn_raise_syserr(mlw_win32_strerror(result), (result<<1));
  }
}

/* This function only returns a string value of the key. */
static mlval reg_query_value_ex (mlval arg)
{
  HKEY hkey = CHKEY(FIELD(arg, 0));
  char *valuename = CSTRING(FIELD(arg, 1));
  mlval datas;
  DWORD datasize;
  long result;

  result = RegQueryValueEx(hkey, valuename, NULL, NULL, NULL, &datasize);
  if (result) {
    return ml_string (NULL); }
  else {
    /* datasize here INCLUDES the NULL character at the end of the string */
    datas = allocate_string(datasize);
    result = RegQueryValueEx(hkey, valuename, NULL, NULL,
			     CSTRING(datas), &datasize);
    if (result) {
      return ml_string (NULL);
    } else {
      return datas;
    }
  }
}

/* This function sets an open key to a string value. */
static mlval reg_set_value_ex (mlval arg)
{
  HKEY hkey = CHKEY(FIELD(arg, 0));
  char *valuename = CSTRING(FIELD(arg, 1));
  char *value = CSTRING(FIELD(arg, 2));
  long result = RegSetValueEx(hkey, valuename, 0, REG_SZ, value, strlen(value)+1);
  if (result == ERROR_SUCCESS) {
    return MLUNIT;
  } else {
    exn_raise_syserr(mlw_win32_strerror(result), (result<<1));
  }
}

/* This function deletes a subkey of a key. */
static mlval reg_delete_key (mlval arg)
{
  HKEY hkey = CHKEY(FIELD(arg, 0));
  char *valuename = CSTRING(FIELD(arg, 1));
  long result = RegDeleteKey(hkey, valuename);
  if (result == ERROR_SUCCESS) {
    return MLUNIT;
  } else {
    exn_raise_syserr(mlw_win32_strerror(result), (result<<1));
  }
}

/* ------------------------------------- */

static mlval win32_open(mlval argument)
{
  char const * file_name= CSTRING(FIELD(argument, 0));
  int acc = CINT(FIELD(argument, 1));
  int act = CINT(FIELD(argument,2));
  DWORD access= (acc == 0)
    ? GENERIC_READ
    : (acc == 1)
      ? GENERIC_READ | GENERIC_WRITE
      : GENERIC_WRITE;
  DWORD action = (act == 0) ? CREATE_ALWAYS 
              : ((acc == 1) ? OPEN_ALWAYS 
                            : OPEN_EXISTING);
  DWORD mode = FILE_SHARE_READ|FILE_SHARE_WRITE;
  HANDLE file_handle = CreateFile(file_name, access, mode,
				  NULL, action, FILE_ATTRIBUTE_NORMAL, NULL);

  if (file_handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());

  return MLINT(file_handle);
}




/*
 * file_desc -> unit
 * Raises: SysErr
 */
static mlval win32_close(mlval argument)
{
  HANDLE file_handle= (HANDLE)CINT(argument);
  if (CloseHandle(file_handle) == FALSE)
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}




/* the following is dummy --- it is required by pervasive library
 * for compatibility with the unix interface.  Since I don't know
 * how to do non-blocking input on win32, this function is never
 * called. This will change if ever I figure out how to do nonblocking IO
 */
static mlval win32_can_input(mlval ignore)
{
  mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}




static mlval win32_read(mlval argument)
{
  HANDLE file_handle = (HANDLE)(CINT(FIELD(argument, 0)));
  DWORD bytes_to_read = CINT(FIELD(argument, 1));
  DWORD bytes_read;
  char *buffer = alloc((size_t) bytes_to_read, "win32_read"), *s;
  mlval string;
  if (ReadFile(file_handle, buffer, bytes_to_read, &bytes_read, NULL) == TRUE) {
    string = allocate_string((size_t) (bytes_read+1));
    s = CSTRING(string);
    memcpy(s, buffer, (size_t) bytes_read);
    free(buffer);
    s[bytes_read] = '\0';
    return string;
  } else {
    mlw_raise_win32_syserr(GetLastError());
  }
}




static mlval win32_write(mlval argument)
{
  HANDLE file_handle = (HANDLE)(CINT(FIELD(argument, 0)));
  char *buffer = CSTRING(FIELD(argument, 1));
  unsigned int first = CINT(FIELD(argument, 2));
  DWORD bytes_to_write = CINT(FIELD(argument, 3));
  DWORD bytes_written;
  if (WriteFile(file_handle, buffer + first, bytes_to_write, &bytes_written, NULL) == TRUE)
    return MLINT(bytes_written);

  mlw_raise_win32_syserr(GetLastError());
}




/*
 * Win32OS.seek: file_desc * int * seek_direction -> int
 */
static mlval win32_seek(mlval argument)
{
  HANDLE file_handle = (HANDLE)(CINT(FIELD(argument, 0)));
  int meth = CINT(FIELD(argument,2));
  long newPos = CINT(FIELD(argument, 1));
  DWORD moveMethod = (meth == 0) ? FILE_BEGIN :
                                   ((meth == 1) ? FILE_CURRENT : FILE_END);
  DWORD result = SetFilePointer(file_handle, newPos, NULL, moveMethod);
  if (result == 0xffffffff)
    mlw_raise_win32_syserr(GetLastError());
  return MLINT(result);
}



static mlval win32_size(mlval argument)
{
  HANDLE file_handle = (HANDLE)(CINT(argument));
  DWORD size = GetFileSize(file_handle, NULL);
  if (size == 0xffffffff)
    mlw_raise_win32_syserr(GetLastError());

  if (size > ML_MAX_INT)
    exn_raise_syserr(ml_string("File Too Large"), 0);

  return MLINT(size);
}


/*
 * Unlike opendir under Unix, FindFirstFile returns a handle and also
 * the first file found.  Therefore the distream needs to contain the
 * name of the file that was last found so that when readDir is called
 * it returns this and then retrieves the next one.
 *
 * Win32 doesn't have a direct equivalent of rewinddir, so that
 * is implemented by closing the HANDLE and reopening it on the given
 * directory.  To support this, the directory name needs to be stored
 * in the dirstream.
 */

#define mlw_dirstream_make() allocate_record(3)
#define mlw_dirstream_dir_name(ds)   FIELD(ds, 0)
#define mlw_dirstream_dir_handle(ds) FIELD(ds, 1)
#define mlw_dirstream_file_name(ds)  FIELD(ds, 2)



/*
 * OS.FileSys.openDir : string -> dirstream
 */
static mlval mlw_os_file_sys_open_dir(mlval arg)
{
  char dir_name[MAX_PATH];
  WIN32_FIND_DATA file_data;
  HANDLE handle;
  mlval ml_file_name, ml_file_name_ref;
  mlval ml_handle, ml_handle_ref;
  mlval dirstream;

  strcpy(dir_name, CSTRING(arg));
  if (dir_name == "") 
    strcpy(dir_name, "*");
  else
    sprintf(dir_name, "%s\\*", get_long_name(dir_name));

  handle = FindFirstFile(dir_name, &file_data);

  if (handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());

  declare_root(&arg, 0);
  ml_file_name= ml_string(file_data.cFileName);
  ml_file_name_ref= mlw_ref_make(ml_file_name);
  declare_root(&ml_file_name_ref, 0);
  ml_handle= box((UINT)handle);
  ml_handle_ref= mlw_ref_make(ml_handle);
  declare_root(&ml_handle_ref, 0);
  dirstream= mlw_dirstream_make();
  mlw_dirstream_dir_name(dirstream)= ml_string (dir_name);
  mlw_dirstream_dir_handle(dirstream)= ml_handle_ref;
  mlw_dirstream_file_name(dirstream)= ml_file_name_ref;
  retract_root (&ml_handle_ref);
  retract_root (&ml_file_name_ref);
  retract_root(&arg);
  return dirstream;
}



/*
 * OS.FileSys.readDir : dirstream -> string option
 */
static mlval mlw_os_file_sys_read_dir(mlval arg)
{
  WIN32_FIND_DATA file_data;
  mlval result;
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));

  if (handle == INVALID_HANDLE_VALUE)
    exn_raise_syserr(ml_string("OS.FileSys.readDir: attempt to read from closed dirstream"), 0);

  if (!FindNextFile(handle, &file_data)) {
    if (GetLastError() != ERROR_NO_MORE_FILES)
      mlw_raise_win32_syserr(GetLastError());
    return mlw_option_make_none();
  } else {
    mlval ml_file_name;
    declare_root(&arg, 0);
    ml_file_name= ml_string(file_data.cFileName);
    result= mlw_ref_value(mlw_dirstream_file_name(arg));
    declare_root(&result, 0);
    mlw_ref_update(mlw_dirstream_file_name(arg), ml_file_name);
    retract_root(&result);
    retract_root(&arg);
    return mlw_option_make_some(result);
  }
}




/*
 * OS.FileSys.rewindDir : dirstream -> unit
 *
 * Win32 doesn't have a direct equivalent of rewinddir, so the following
 * implements it by closing the dirstream and then reopening it on the
 * original directory.
 */
static mlval mlw_os_file_sys_rewind_dir(mlval arg)
{
  WIN32_FIND_DATA file_data;
  LPCSTR dir_name;
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));
  mlval boxed_handle;
  mlval ml_file_name;

  if (handle == INVALID_HANDLE_VALUE)
    exn_raise_syserr(ml_string("OS.FileSys.rewindDir: attempt to rewind closed dirstream"), 0);

  if (!FindClose(handle))
    mlw_raise_win32_syserr(GetLastError());

  dir_name= CSTRING(mlw_dirstream_dir_name (arg));
  if ((handle= FindFirstFile(dir_name, &file_data)) == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());

  declare_root(&arg, 0);
  boxed_handle= box((UINT)handle);
  mlw_ref_update(mlw_dirstream_dir_handle(arg), boxed_handle);
  ml_file_name= ml_string(file_data.cFileName);
  mlw_ref_update(mlw_dirstream_file_name(arg), ml_file_name);
  retract_root(&arg);

  return MLUNIT;
}




/*
 * OS.FileSys.closeDir : dirstream -> unit
 */
static mlval mlw_os_file_sys_close_dir(mlval arg)
{
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));
  mlval boxed_handle;

  if (handle == INVALID_HANDLE_VALUE)
    return MLUNIT;

  if (!FindClose(handle))
    mlw_raise_win32_syserr(GetLastError());

  declare_root(&arg, 0);
  boxed_handle= box((UINT)INVALID_HANDLE_VALUE);
  mlw_ref_update(mlw_dirstream_dir_handle(arg), boxed_handle);
  retract_root(&arg);
  return MLUNIT;
}




/*
 * OS.FileSys.chDir : string -> unit
 */
static mlval mlw_os_file_sys_ch_dir(mlval arg)
{
  char const * new_dir= CSTRING(arg);
  if (!SetCurrentDirectory(new_dir))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}




/*
 * OS.FileSys.getDir : unit -> string
 *
 * If GetCurrentDirectory can locate the current directory, but cannot
 * write it back to the buffer because it is not large enough, it returns
 * the size the buffer needs to be.  The following tries to make use of
 * this information to always return the path if at all possible.
 * Unfortunately, this does tend to make it rather cryptic.
 */
static mlval mlw_os_file_sys_get_dir(mlval unit)
{
  char fixed_buffer[MAX_PATH];
  char * buffer= fixed_buffer;
  DWORD buffer_size= MAX_PATH;
  DWORD size= GetCurrentDirectory(buffer_size, buffer);

  if (size == 0)
    mlw_raise_win32_syserr(GetLastError());

  if (size >= buffer_size) {
    buffer_size= size;
    if ((buffer= malloc(buffer_size)) == 0)
      mlw_raise_c_syserr(errno);
    (void)memcpy(buffer, fixed_buffer, size);
    if ((size= GetCurrentDirectory(buffer_size, buffer)) == 0) {
      free(buffer);
      mlw_raise_win32_syserr(GetLastError());
    }
    assert(size == buffer_size-1);
  }

  {
    mlval path= ml_string(buffer);
    if (buffer != fixed_buffer)
      free(buffer);
    return path;
  }
}




/*
 * OS.FileSys.mkDir: string -> unit
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_mk_dir(mlval arg)
{
  char const * dir_name= CSTRING(arg);
  SECURITY_ATTRIBUTES attributes= {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
  if (!CreateDirectory(dir_name, &attributes))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}



/*
 * OS.FileSys.rmDir: string -> unit
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_rm_dir(mlval arg)
{
  char const * dir_name= CSTRING(arg);
  if (!RemoveDirectory(dir_name))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}



/*
 * OS.FileSys.isDir: string -> bool
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_is_dir(mlval arg)
{
  LPCTSTR dir_name= CSTRING(arg);
  DWORD file_attributes= GetFileAttributes(dir_name);
  if (file_attributes == 0xffffffff)
    mlw_raise_win32_syserr(GetLastError());
  return MLBOOL((file_attributes & FILE_ATTRIBUTE_DIRECTORY) == FILE_ATTRIBUTE_DIRECTORY);
}

/* This function faults bad values returned by GetFullPathName */

static void fail_buffer(char *buffer)
{
#define BAD_FILE_NAME "Bad file name from GetFullPathName "
  /* This should never happen (it would be a bug in GetFullPathName) */
  mlval ml_error = MLUNIT;
  char *c_error = malloc(strlen(BAD_FILE_NAME) + strlen(buffer) + 1);
  strcpy(c_error, BAD_FILE_NAME);
  strcat(c_error, buffer);
  ml_error = ml_string(c_error);
  free(c_error);
  free(buffer);
  exn_raise_syserr(ml_error, 0);
}

/* This function checks values returned by GetFullPathName */
static void check_root(char *root, char *buffer)
{
  if (*root == '\0') fail_buffer(buffer);
}

/*
 * OS.FileSys.fullPath: string -> string
 * Raises: OS.SysErr
 *
 * See mlw_os_file_sys_get_dir comment for the reasons why the following is
 * baroque.
 */
static mlval mlw_os_file_sys_full_path(mlval arg)
{
  char const * path= CSTRING(arg);
  char fixed_buffer[MAX_PATH];
  char * buffer= fixed_buffer;
  DWORD buffer_size= MAX_PATH;
  char *final_name;
  DWORD size= GetFullPathName(path, MAX_PATH, buffer, &final_name);

  if (size == 0)
    mlw_raise_win32_syserr(GetLastError());
  if (size >= buffer_size) {
    buffer_size= size;
    if ((buffer= malloc(buffer_size)) == 0)
      mlw_raise_c_syserr(errno);
    (void)memcpy(buffer, fixed_buffer, buffer_size);
    if ((size= GetFullPathName(buffer, buffer_size, buffer, &final_name)) == 0) {
      free(buffer);
      mlw_raise_win32_syserr(GetLastError());
    }
    assert(size == buffer_size - 1);
  }
  /* Now check for and remove a trailing \ (except for root directories) */
  {
    DWORD i = strlen(buffer);
    /* We start by looking for something of the form \\foo\bar\ or a:\ */
    char *root = buffer;
    if (*root == '\\') {
      root++; /* Skip first \ */
      if (*root != '\\') {
	fail_buffer(buffer);
      }
      root++; /* Skip second \ */
      do {
	root++; /* Skip foo section */
      } while (*root != '\\' && *root != '\0');
      check_root(root, buffer);
      root++; /* Skip third \ */
      check_root(root, buffer);
      do {
	root++; /* Skip bar section */
      } while (*root != '\\' && *root != '\0');
      check_root(root, buffer);
      root++; /* Skip fourth \ */
    } else {
      if (strlen(root) < 3 || root[1] != ':' || root[2] != '\\')
	fail_buffer(buffer);
      root += 3;
    }
    if ((root < (buffer + i)) && (buffer[i-1] == '\\'))
      buffer[i-1] = '\0'; /* Remove trailing \ except from file system roor */
  }

  size = strlen(buffer);

  /* Now check that this file exists, and raise syserr if not */
  /* FindFirstFile fails if given the root directory, so don't call it 
   * if the buffer contains the root directory.
   */
  if ((size != 3) || (buffer[2] != '\\')) {
    WIN32_FIND_DATA file_data;
    HANDLE file_handle = FindFirstFile(buffer, &file_data);

    if (file_handle == INVALID_HANDLE_VALUE) {
      if (buffer != fixed_buffer) free(buffer);
      mlw_raise_win32_syserr(GetLastError());
    }
    FindClose(file_handle);
  }

  {
    mlval path= ml_string(buffer);
    if (buffer != fixed_buffer)
      free(buffer);
    return path;
  }
}




/*
 * OS.FileSys.modTime: string -> Time.time
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_mod_time(mlval arg)
{
  char const * file_name= CSTRING(arg);
  WIN32_FIND_DATA file_data;
  HANDLE file_handle= FindFirstFile(file_name, &file_data);  
  mlval mod_time;
  if (file_handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());

  mod_time= mlw_time_from_file_time(&file_data.ftLastWriteTime);
  if (FindClose(file_handle) == FALSE) {
    message_start();
    message_content("MLWorks non-fatal error: could not close ");
    message_string(file_name);
    message_end();
  }
  return mod_time;
}




/*
 * OS.FileSys.fileSize: string -> Position.int
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_file_size(mlval arg)
{
  char const * file_name= CSTRING(arg);
  WIN32_FIND_DATA file_data;
  HANDLE file_handle= FindFirstFile(file_name, &file_data);
  mlval file_size;

  if (file_handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());

  if (file_data.nFileSizeHigh != 0 || file_data.nFileSizeLow > ML_MAX_INT)
    exn_raise_syserr(ml_string("OS.FileSys.fileSize: file too large"), 0);

  file_size= MLINT(file_data.nFileSizeLow);
  if (FindClose(file_handle) == FALSE) {
    message_start();
    message_content("MLWorks non-fatal error: could not close ");
    message_string(file_name);
    message_end();
  }
  return file_size;
}




/*
 * OS.FileSys.setTime_: string * Time.time -> unit
 * Raises: OS.SysErr
 */
static mlval mlw_os_file_sys_set_time(mlval arg)
{
  LPCTSTR file_name= CSTRING(FIELD(arg, 0));
  SECURITY_ATTRIBUTES security_attributes= {sizeof(SECURITY_ATTRIBUTES), NULL, TRUE};
  FILETIME file_time;
  HANDLE file_handle= CreateFile(file_name, GENERIC_WRITE, 0, &security_attributes, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (file_handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr(GetLastError());
  mlw_time_to_file_time(FIELD(arg, 1), &file_time);
  if (!SetFileTime(file_handle, NULL, &file_time, &file_time))
    mlw_raise_win32_syserr(GetLastError());
  if (!CloseHandle(file_handle))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}




/*
 * OS.FileSys.remove : string -> unit
 */
static mlval mlw_os_file_sys_remove(mlval arg)
{
  char const *file_name= CSTRING(arg);
  if (!DeleteFile(file_name))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}




/*
 * OS.FileSys.rename : { new: string, old: string} -> unit
 */
static mlval mlw_os_file_sys_rename(mlval arg)
{
  char const *old= CSTRING(FIELD(arg, 1));
  char const *new= CSTRING(FIELD(arg, 0));
  if (!MoveFile(old, new))
    mlw_raise_win32_syserr(GetLastError());
  return MLUNIT;
}



/*
 * OS.FileSys.access : (string * access_mode list) -> bool
 *
 * The description states that :-
 *
 *   ... only raise OS.SysError for errors unrelated to resolving the
 *   pathname and the related permissions, such as being interrupted
 *   by a signal during the the system call.
 *
 * Which seems to leave it to the implementor to decide exactly what
 * are "errors unrelated to resolving the pathname".
 *
 * Note that although Visual C++ compatability library provides access
 * the documentation doesn't list any flag/value to test if a file is
 * executable.  I don't have the time or the inclination to determine
 * if it can really detect executable files using some undocumented flag
 * so I've implemented access using _fstat.
 */
static int
mlw_os_file_sys_access_mode_ml_to_c[]= {_S_IEXEC, _S_IREAD, _S_IWRITE};


#define mlw_os_file_sys_n_access_modes \
  (sizeof(mlw_os_file_sys_access_mode_ml_to_c)/sizeof(mlw_os_file_sys_access_mode_ml_to_c[0]))


static mlval mlw_os_file_sys_access(mlval arg)
{
  char const * path= CSTRING(FIELD(arg, 0));
  mlval modes= FIELD(arg, 1);
  int access_mode= 0;
  int stat_status;
  struct _stat st;

  for (; !MLISNIL(modes); modes= MLTAIL(modes)) {
    int ml_mode= CINT(MLHEAD(modes));
    assert(ml_mode >= 0 && ml_mode <= mlw_os_file_sys_n_access_modes);
    access_mode |= mlw_os_file_sys_access_mode_ml_to_c[ml_mode];
  }
  if ((stat_status= _stat(path, &st)) < 0) {
    switch (errno) {
    case ENOENT:
      return MLFALSE;
    default:
      mlw_raise_c_syserr(errno);
    }
  }
  return MLBOOL((st.st_mode & access_mode) == access_mode);
}




/*
 * OS.FileSys.tmpName : unit -> string
 *
 * See mlw_os_file_sys_get_dir comment for the reasons why the following is
 * broque.
 */
static mlval mlw_os_file_sys_tmp_name(mlval unit)
{
  char fixed_dir[MAX_PATH];
  char * dir= fixed_dir;
  DWORD dir_size= MAX_PATH;
  DWORD size= GetTempPath(dir_size, dir);

  if (size == 0)
    mlw_raise_win32_syserr(GetLastError());

  if (size >= dir_size) {
    if ((dir= malloc(size)) == 0)
      mlw_raise_c_syserr(errno);
    (void)memcpy(dir, fixed_dir, size);
    dir_size= size;
    if ((size= GetTempPath(dir_size, dir)) == 0) {
      free(dir);
      mlw_raise_win32_syserr(GetLastError());
    }
    assert(size == dir_size-1);
  }

  {
    mlval path;
    char * buffer= malloc(size+MAX_PATH); /* could be more accurate */
    if (buffer == 0)
      mlw_raise_c_syserr(errno);
    if (GetTempFileName(dir, "MLW", 1, buffer) != 1) {
      if (dir != fixed_dir);
      free(dir);
      free(buffer);
      mlw_raise_win32_syserr(GetLastError());
    }
    path= ml_string(buffer);
    free(buffer);
    if (dir != fixed_dir)
      free(dir);
    return path;
  }
}




/*
 * OS.Process.exit: word32 -> 'a
 */
static mlval mlw_os_process_exit(mlval exit_code)
{
  exit(unbox(exit_code));
  return MLUNIT;		/* keep dumb compilers happy */
}



/*
 * OS.Process.system: string -> word32
 * Raises: OS.SysErr
 */
static mlval mlw_os_process_system(mlval arg)
{
  char const * command= CSTRING(arg);
  int status= system(command);
  if (status == -1 || status == 127)
    mlw_raise_c_syserr(errno);

  return box(status);
}



/*
 * OS.Process.getenv: string -> string option
 *
 * This is the same as the Unix version and so could probably
 * move to a common file such as rts/src/system.c
 */
static mlval mlw_os_process_getenv(mlval arg)
{
  char const * name= CSTRING(arg);
  char const * value= getenv(name);
  if (value == NULL) {
    return mlw_option_make_none();
  } else {
    return mlw_option_make_some(ml_string(value));
  }
}




/*
 * The following values are C versions of the values defined
 * in the Kind structure in win32/os_io.sml.
 *
 * In an ideal world the SML & C versions would be generated
 * from a common source to avoid possible update problems.
 */
#define mlw_os_io_kind_file    MLINT(1)
#define mlw_os_io_kind_dir     MLINT(2)
#define mlw_os_io_kind_symlink MLINT(3)
#define mlw_os_io_kind_tty     MLINT(4)
#define mlw_os_io_kind_pipe    MLINT(5)
#define mlw_os_io_kind_socket  MLINT(6)
#define mlw_os_io_kind_device  MLINT(7)



/*
 * OS.IO.kind : io_desc -> io_desc_kind
 * Raises: OS.SysErr
 *
 * Much the same as the Unix version, except that Win32 supports less
 * kinds.
 *
 * Could implement this with native Win32 calls such as
 * GetFileType and GetFileInformationByHandle, but this doesn't
 * seem to provide as much information as _fstat (presumably
 * there is some other Win32 call I'm missing which does).
 *
 * Note that this is the only OS.IO routine implemented here.
 * All the poll related routines are implemented in os_io_poll.[ch]
 */

static mlval mlw_os_io_kind(mlval arg)
{
  struct _stat st;
  int io_desc= CINT(arg);

  if (_fstat(io_desc, &st) < 0)
    mlw_raise_c_syserr(errno);

  switch (st.st_mode & _S_IFMT) {
  case _S_IFREG:
    return isatty(io_desc) ? mlw_os_io_kind_tty : mlw_os_io_kind_file;
  case _S_IFDIR:
    return mlw_os_io_kind_dir;
  case _S_IFIFO:
    return mlw_os_io_kind_socket;
  case _S_IFCHR:
    return mlw_os_io_kind_device;
  default:
    exn_raise_syserr(ml_string("OS.IO.kind: unknown io_desc kind"), 0);
  }
}




/*
 * Win32.fdToIOD: file_desc -> io_desc
 *
 * Converts a HANDLE into a Unix style file descriptor
 * for use by the VC++ compatability library routines.
 * The name comes from POSIX.FileSys.fdToIOD.
 *
 * The VC++ manual isn't very clear on if and when these
 * descriptors should be closed (presumably by _close).
 * Currently no attempt is made to close them.
 * But now there is, as not doing so eventually causes
 * fopen to fail. See mlw_win32_close_iod
 */

static mlval mlw_win32_fd_to_io_desc(mlval arg)
{
  HANDLE io_desc= (HANDLE)CINT(arg);
  int fd= _open_osfhandle((long)io_desc, O_RDONLY);

  if (fd < 0) {
    int saved_errno= errno;
    (void)_close(fd);
    mlw_raise_c_syserr(saved_errno);
  }
  return MLINT(fd);
}

/*
 * mlw_win32_close_iod
 * Note that this routine will automatically close the result
 * of CreateFile if the handle was acquired using _open_osfhandle
 * on the result of CreateFile. So under those circumstances,
 * eg in __os_prim_io.sml, if we close an ioDesc, we should then not
 * try to close the fd as this will fail.
 */

static mlval mlw_win32_close_iod(mlval arg)
{
  int fd = CINT(arg);
  (void)_close(fd);
  return MLUNIT;
}


#define ML_BACKGROUND_PRIORITY  0
#define ML_NORMAL_PRIORITY      1
#define ML_HIGH_PRIORITY        2
#define ML_REALTIME_PRIORITY    3


static mlval win32_create_process (mlval arg)
{
   BOOL                 result;
   STARTUPINFO          startup_info;
   PROCESS_INFORMATION  proc_info;
   DWORD                PriorityClass, CreationFlags;

   char *cmd_line;
   long int priority;

   cmd_line = CSTRING(  FIELD(arg,0));
   priority = CINT(     FIELD(arg,1));

   switch (priority) {
   case ML_NORMAL_PRIORITY :
        PriorityClass = NORMAL_PRIORITY_CLASS;
        break;

   case ML_HIGH_PRIORITY :
        PriorityClass = HIGH_PRIORITY_CLASS;
        break;

   case ML_BACKGROUND_PRIORITY :
        PriorityClass = IDLE_PRIORITY_CLASS;
        break;

   case ML_REALTIME_PRIORITY :
        PriorityClass = REALTIME_PRIORITY_CLASS;
        break;

   default :
        PriorityClass = NORMAL_PRIORITY_CLASS;
   }

   GetStartupInfo(&startup_info);   /* Grab current Startup_info for Windows etc. */

   CreationFlags = CREATE_NEW_CONSOLE;
   CreationFlags = CreationFlags | PriorityClass;

   result =
      CreateProcess( (LPCTSTR)NULL,                 /* Module (i.e. command) name */
		     (LPTSTR)cmd_line,              /* Command args */
		     (LPSECURITY_ATTRIBUTES)NULL,   /* Process security */
		     (LPSECURITY_ATTRIBUTES)NULL,   /* Thread  security */
		     FALSE,                         /* Handle inheritance flag */
		     CreationFlags,                 /* Creation flags */
		     (LPVOID)NULL,                  /* Environment */
		     (LPCTSTR)NULL,                 /* Current directory */
		     (LPSTARTUPINFO)&startup_info,        /* Start up info */
		     (LPPROCESS_INFORMATION)&proc_info    /* Process information */
		   );
   /* Now avoid hanging onto the process and main thread handles */
   CloseHandle(proc_info.hThread);
   CloseHandle(proc_info.hProcess);
   return MLBOOL(result != 0);
}

/* Time.time -> Time.time */
static mlval ml_filetimetolocalfiletime(mlval arg)
{
  FILETIME ft, converted;
  mlw_time_to_file_time(arg, &ft);
  if (FileTimeToLocalFileTime(&ft, &converted)) {
    return mlw_time_from_file_time(&converted);
  } else {
    mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in MS */
  }
}

/* Time.time -> Time.time */
static mlval ml_localfiletimetofiletime(mlval arg)
{
  FILETIME ft, converted;
  mlw_time_to_file_time(arg, &ft);
  if (LocalFileTimeToFileTime(&ft, &converted)) {
  return mlw_time_from_file_time(&converted);
  } else {
    mlw_raise_win32_syserr(GetLastError()); /* Shouldn't happen, indicates bug in MS */
  }
}

/*
 * string ->
 *    {volumeName: string,
 *     systemName: string,
 *     serialNumber: SysWord.word,
 *     maximumComponentLength: int,
 *     flags: SysWord.word}
 */
static mlval ml_getvolumeinformation(mlval arg)
{
  char volumeName[MAX_PATH+1];
  DWORD serial;
  DWORD component_length;
  DWORD flags;
  char fixed_buffer[MAX_PATH+1];
  BOOL res = GetVolumeInformation(CSTRING(arg), volumeName, MAX_PATH, &serial, &component_length, &flags,
				  fixed_buffer, MAX_PATH);
  if (res == TRUE) {
    mlval volName;
    mlval sysName;
    mlval serNum;
    mlval result;
    volName = ml_string(volumeName);
    declare_root(&volName, 0);
    sysName = ml_string(fixed_buffer);
    declare_root(&sysName, 0);
    serNum = box(serial);
    declare_root(&serNum, 0);
    result = allocate_record(4);
    FIELD(result, 0) = MLINT(component_length);
    FIELD(result, 1) = serNum;
    FIELD(result, 2) = sysName;
    FIELD(result, 3) = volName;
    retract_root(&volName);
    retract_root(&sysName);
    retract_root(&serNum);
    return result;
  } else {
    mlw_raise_win32_syserr(GetLastError());
  }
}

/* string -> string option */
static mlval ml_find_executable(mlval arg)
{
  char *name = CSTRING(arg);
  char fixed_buffer[MAX_PATH+1];
  HINSTANCE handle = FindExecutable(name, NULL, fixed_buffer);
  if ((DWORD)handle < 32) {
    switch((DWORD)handle) {
    case 0:
      exn_raise_syserr(ml_string("System out of resource during Windows.findExecutable"), 0);
    case ERROR_FILE_NOT_FOUND:
      return mlw_option_make_none();
    case ERROR_PATH_NOT_FOUND:
      /* This should only occur when parameter 2 to Findexecutable is not NULL */
      exn_raise_syserr(ml_string("A path was not found during Windows.findExecutable"), 0);
    case ERROR_BAD_FORMAT:
      exn_raise_syserr(format_to_ml_string("file '%s' does not specify a valid Win32 executable", name), 0);
    default: mlw_raise_win32_syserr(GetLastError());
    }
  } else {
    return mlw_option_make_some(ml_string(fixed_buffer));
  }
}

static char *get_args(mlval list, const char *fun)
{
  mlval list1;
  char *args;
  unsigned int len = 0;
  for (list1 = list; list1 != MLNIL; list1 = MLTAIL(list1)) {
    char *head = CSTRING(MLHEAD(list1));
    len += strlen(head) + 1; /* Allow room for a space or a terminator */
  }
  args = malloc(len+1);
  *args = '\0';
  if (args == NULL) {
    exn_raise_syserr(format_to_ml_string("Failed to concatenate args for %s", fun), 0);
  } else {
    for (list1 = list; list1 != MLNIL; list1 = MLTAIL(list1)) {
      char *head = CSTRING(MLHEAD(list1));
      strcat(args, head);
      strcat(args, " ");
    }
    args[strlen(args)] = '\0'; /* Get rid of terminating space */
  }
  return args;
}

/*
 * shell_execute is called by ml_open_document and ml_launch_application.
 * It calls ShellExecute, frees the arguments, and checks the result status.
 */
static void shell_execute (char *name, char* c_args, char* fn)
{
  HINSTANCE handle = ShellExecute(NULL, "open", name, c_args, NULL, SW_NORMAL);
  free(c_args);
  if ((DWORD)handle < 32) {
    switch((DWORD)handle) {
    case SE_ERR_OOM:
    case 0:
      exn_raise_syserr(format_to_ml_string("System out of resource during %s", fn), 0);
#ifdef Win95
    case SE_ERR_FNF:
#else
    case ERROR_FILE_NOT_FOUND:
#endif
      exn_raise_syserr(format_to_ml_string("file '%s' not found", name), 0);
#ifdef Win95
    case SE_ERR_PNF:
#else
    case ERROR_PATH_NOT_FOUND:
#endif
      exn_raise_syserr(format_to_ml_string("A path was not found during %s", fn), 0);
    case ERROR_BAD_FORMAT:
      exn_raise_syserr(format_to_ml_string("file '%s' does not specify a valid Win32 executable", name), 0);
    case SE_ERR_ACCESSDENIED:
      exn_raise_syserr(format_to_ml_string("Access denied to '%s'", name), 0);
    case SE_ERR_ASSOCINCOMPLETE:
      exn_raise_syserr(format_to_ml_string("Association to '%s' incomplete or invalid", name), 0);
    case SE_ERR_DDEBUSY:
      exn_raise_syserr(format_to_ml_string("The DDE transaction could not be completed because other DDE transactions were being processed during %s", fn), 0);
    case SE_ERR_DDEFAIL:
      exn_raise_syserr(format_to_ml_string("DDE transaction failed during %s", fn), 0);
    case SE_ERR_DDETIMEOUT:
      exn_raise_syserr(format_to_ml_string("The DDE transaction request timed out during %s", fn), 0);
    case SE_ERR_DLLNOTFOUND:
      exn_raise_syserr(ml_string("DLL not found"), 0);
    case SE_ERR_NOASSOC:
      exn_raise_syserr(format_to_ml_string("No application associated with the given filename extension in '%s'", name), 0);
    case SE_ERR_SHARE:
      exn_raise_syserr(format_to_ml_string("A sharing violation occurred during %s of '%s'", fn, name), 0);
    default: mlw_raise_win32_syserr(GetLastError());
    }
  }
}

static mlval ml_launch_application(mlval arg)
{
  char *name = CSTRING(FIELD(arg, 0));
  mlval args = FIELD(arg, 1);
  char *c_args = get_args(args, "Windows.shellExecute");
  shell_execute (name, c_args, "Windows.launchApplication");
  return MLUNIT;
}

static mlval ml_open_document(mlval arg)
{
  char *name = CSTRING(arg);
  shell_execute (name, NULL, "Windows.openDocument");
  return MLUNIT;
}


static BOOL CALLBACK find_child_console(HWND hwnd, DWORD pid)
{
  DWORD thread_id;
  DWORD process_id;

  thread_id = GetWindowThreadProcessId (hwnd, &process_id);
  if (thread_id) {
    if (process_id == pid) {
      char window_class[32];
      GetClassName (hwnd, window_class, sizeof (window_class));
      if (strcmp(window_class, "tty") == 0 ||
	  strcmp(window_class, "ConsoleWindowClass") == 0) {
	return FALSE;
      }
    }
  }
  /* keep looking */
  return TRUE;
}

static mlval ml_has_console(mlval arg)
{
  HANDLE console_handle =
    CreateFile("CONOUT$",
	       GENERIC_READ | GENERIC_WRITE,
	       FILE_SHARE_READ | FILE_SHARE_WRITE,
	       NULL,
	       OPEN_EXISTING,
	       0,
	       NULL);
  if (console_handle == INVALID_HANDLE_VALUE) {
    mlw_raise_win32_syserr(GetLastError());
  } else {
    if (EnumWindows(find_child_console, (LPARAM)GetCurrentProcessId()) == TRUE) {
      return MLFALSE;
    } else {
      return MLTRUE;
    }
  }
}

#define BUFSIZE 4096

/* XXX: The error cases in ml_execute don't close the duplicated handles.
 * Is this a problem?  -- daveb, 26/1/99.
 */
static mlval ml_execute(mlval arg)
{
  HANDLE hChildStdinRd, hChildStdinWr, hChildStdinWrDup,
    hChildStdoutRd, hChildStdoutWr, hChildStdoutRdDup,
    hSaveStdin, hSaveStdout;
  PROCESS_INFORMATION piProcInfo;
  STARTUPINFO siStartInfo;
  mlval name = FIELD(arg, 0);
  mlval args = FIELD(arg, 1);
  char *c_args = get_args(mlw_cons(name, args), "Windows.execute");
  SECURITY_ATTRIBUTES saAttr;
  BOOL fSuccess;
  LPVOID env;
  BOOL created_console;
  
  /* Set the bInheritHandle flag so pipe handles are inherited. */
  saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
  saAttr.bInheritHandle = TRUE;
  saAttr.lpSecurityDescriptor = NULL;

  /* First we allocate a console, if we don't have one already */
  created_console = AllocConsole();
 
  hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);
  if (!CreatePipe(&hChildStdoutRd, &hChildStdoutWr, &saAttr, 0))
    exn_raise_syserr(ml_string("Stdout pipe creation failed in Windows.execute"), 0);
  if (!SetStdHandle(STD_OUTPUT_HANDLE, hChildStdoutWr)) {
    CloseHandle(hChildStdoutRd);  /* Get rid of the pipe */
    CloseHandle(hChildStdoutWr);
    exn_raise_syserr(ml_string("Redirecting stdOut failed in Windows.execute"), 0);
  }
  fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdoutRd,
			     GetCurrentProcess(), &hChildStdoutRdDup , 0,
			     FALSE,
			     DUPLICATE_SAME_ACCESS);
  if( !fSuccess ) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    CloseHandle(hChildStdoutRd);  /* Get rid of the pipe */
    CloseHandle(hChildStdoutWr);
    exn_raise_syserr(ml_string("DuplicateHandle failed on stdOut in Windows.execute"), 0);
  }
  CloseHandle(hChildStdoutRd);

  hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
  if (! CreatePipe(&hChildStdinRd, &hChildStdinWr, &saAttr, 0)) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
    exn_raise_syserr(ml_string("Stdin pipe creation failed in Windows.execute"), 0);
  }
  if (! SetStdHandle(STD_INPUT_HANDLE, hChildStdinRd)) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    CloseHandle(hChildStdoutWr); /* Get rid of the pipes */
    CloseHandle(hChildStdinRd);
    CloseHandle(hChildStdinWr);
    exn_raise_syserr(ml_string("Redirecting StdIn failed in Windows.execute"), 0);
  }
  fSuccess = DuplicateHandle(GetCurrentProcess(), hChildStdinWr,
			     GetCurrentProcess(), &hChildStdinWrDup, 0,
			     FALSE,                  // not inherited
			     DUPLICATE_SAME_ACCESS);
  if (! fSuccess) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    CloseHandle(hChildStdoutWr); /* Get rid of the pipes */
    CloseHandle(hChildStdinRd);
    CloseHandle(hChildStdinWr);
    exn_raise_syserr(ml_string("DuplicateHandle failed on stdIn in Windows.execute"), 0);
  }
  CloseHandle(hChildStdinWr);

  ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
  siStartInfo.cb = sizeof(STARTUPINFO);
  env = GetEnvironmentStrings();
  if (CreateProcess(NULL, c_args, NULL, NULL, TRUE, 0, env, NULL, &siStartInfo, &piProcInfo) == FALSE) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);   /* Restore original stdIn */
    CloseHandle(hChildStdoutWr); /* Get rid of the pipes */
    CloseHandle(hChildStdinRd);
    (void)FreeEnvironmentStrings(env);
    mlw_raise_win32_syserr(GetLastError());
  }
  (void)FreeEnvironmentStrings(env);
  CloseHandle(piProcInfo.hThread); /* We don't need this, so we close it straight away */
  SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
  SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);   /* Restore original stdIn */
  CloseHandle(hChildStdoutWr); /* Get rid of the pipes */
  CloseHandle(hChildStdinRd);

  /* Here we need to create something to hold the stdOut and stdIn so we can return them to ML */
  /* We also need the process handle so we can reap */
  {
    mlval streams = allocate_record(2);
    mlval proc;
    FIELD(streams, 0) = MLINT(hChildStdoutRdDup);
    FIELD(streams, 1) = MLINT(hChildStdinWrDup);
    declare_root(&streams, 0);
    proc = allocate_record(2);
    FIELD(proc, 0) = streams;
    FIELD(proc, 1) = MLINT(piProcInfo.hProcess);
    retract_root(&streams);
    if (created_console)
      FreeConsole ();
    return proc;
  }
}

static mlval ml_execute_null_streams(mlval arg)
{
  HANDLE hNullDevice, hSaveStdin, hSaveStdout, hSaveStderr;
  PROCESS_INFORMATION piProcInfo;
  STARTUPINFO siStartInfo;
  mlval name = FIELD(arg, 0);
  mlval args = FIELD(arg, 1);
  char *c_args = get_args(mlw_cons(name, args), "Windows.simpleExecute");
  SECURITY_ATTRIBUTES saAttr;
  /*  BOOL fSuccess;  */
  LPVOID env;

  /* Set the bInheritHandle flag so pipe handles are inherited. */
  saAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
  saAttr.bInheritHandle = TRUE;
  saAttr.lpSecurityDescriptor = NULL;

  hNullDevice = CreateFile("NUL:", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE,
				   NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
  if (hNullDevice == INVALID_HANDLE_VALUE)
    exn_raise_syserr(ml_string("Failed to open null device in Windows.simpleExecute"), 0);

  hSaveStdout = GetStdHandle(STD_OUTPUT_HANDLE);
  if (!SetStdHandle(STD_OUTPUT_HANDLE, hNullDevice)) {
    CloseHandle(hNullDevice);
    exn_raise_syserr(ml_string("Redirecting STDOUT failed in Windows.simpleExecute"), 0);
  }

  hSaveStdin = GetStdHandle(STD_INPUT_HANDLE);
  if (! SetStdHandle(STD_INPUT_HANDLE, hNullDevice)) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    CloseHandle(hNullDevice);
    exn_raise_syserr(ml_string("Redirecting Stdin failed in Windows.simpleExecute"), 0);
  }

  hSaveStderr = GetStdHandle(STD_ERROR_HANDLE);
  if (! SetStdHandle(STD_ERROR_HANDLE, hNullDevice)) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    SetStdHandle(STD_INPUT_HANDLE, hSaveStdin); /* Restore original stdin */
    CloseHandle(hNullDevice);
    exn_raise_syserr(ml_string("Redirecting Stderr failed in Windows.simpleExecute"), 0);
  }

  ZeroMemory(&siStartInfo, sizeof(STARTUPINFO));
  siStartInfo.cb = sizeof(STARTUPINFO);
  env = GetEnvironmentStrings();
  if (CreateProcess(NULL, c_args, NULL, NULL, TRUE, 0, env, NULL, &siStartInfo, &piProcInfo) == FALSE) {
    SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
    SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);   /* Restore original stdIn */
    SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);   /* Restore original stdErr */
    CloseHandle(hNullDevice);
    (void)FreeEnvironmentStrings(env);
    mlw_raise_win32_syserr(GetLastError());
  }

  (void)FreeEnvironmentStrings(env);
  CloseHandle(piProcInfo.hThread); /* We don't need this, so we close it straight away */
  SetStdHandle(STD_OUTPUT_HANDLE, hSaveStdout); /* Restore original stdOut */
  SetStdHandle(STD_INPUT_HANDLE, hSaveStdin);   /* Restore original stdIn */
  SetStdHandle(STD_ERROR_HANDLE, hSaveStderr);   /* Restore original stdErr */
  CloseHandle(hNullDevice);

  /* Here we need to create dummy stdIn/stdOut values so we can return them to ML */
  /* We also need the process handle so we can reap */
  {
    mlval streams = allocate_record(2);
    mlval proc;
    FIELD(streams, 0) = MLINT(0);
    FIELD(streams, 1) = MLINT(0);
    declare_root(&streams, 0);
    proc = allocate_record(2);
    FIELD(proc, 0) = streams;
    FIELD(proc, 1) = MLINT(piProcInfo.hProcess);
    retract_root(&streams);
    return proc;
  }
}


/*
 * NB, we probably need to do something about these streams
 * when we stop and restart, as they will no longer be valid
 * Turns out the basis does this for us
 */

static mlval ml_streams_of(mlval arg)
{
  return (FIELD(arg, 0)); /* The arg is a pair of the streams and the process handle */
}


/*
 * reap a windows function, ie wait for it to die and return its status
 */

static mlval ml_reap(mlval arg)
{
  HANDLE hProcess = (HANDLE)(CINT(FIELD(arg, 1)));
  mlval streams = FIELD(arg, 0);
  HANDLE out = (HANDLE)(CINT(FIELD(streams, 0)));
  HANDLE in = (HANDLE)(CINT(FIELD(streams, 1)));
  DWORD status;
  DWORD res = WaitForSingleObject(hProcess, INFINITE);

  switch(res) {
  case WAIT_OBJECT_0:
    if (GetExitCodeProcess(hProcess, &status)) {
      /* Close our resources */
      CloseHandle(hProcess);
      CloseHandle(in);
      CloseHandle(out);
      return box(status);
    };
    /* Fall through */
  case WAIT_FAILED:
  default:
    {
      /* Failed */
      int error = GetLastError();
      mlw_raise_win32_syserr(error);
    }
  }
}


/* === Handle uniqueness of DLLs and SOs
 *
 * During DLL init we set up a table
 * chained through the dlls, each element of which
 * conforms to the following struct
 * struct info {
 * unsigned long stamp1, stamp2, stamp3, stamp4; A GUID
 * unsigned long *text_start,
 *               *data_start,
 *               *text_end,
 *               *data_end; The text and data bounds of this dll
 * struct info *next; A pointer to the next element, or NULL(0)
 * char          name[]; A name by which this can be identified
 * }
 *
 * At environment init we translate this table
 * into a global root with the following semantics
 * At save:    Save the table away in the image
 * At deliver: Save the table away in the image (unclear what to do here)
 * At reload:  Compare the table from the image with the one we have
 *             and error exit if different in the stamps
 *             If different in the addresses, fix up the heap
 */

typedef struct dll_info *dll_info_ptr;

typedef struct dll_info
{
  word stamp1, stamp2, stamp3, stamp4;
  word text_start, data_start, text_end, data_end;
  dll_info_ptr next;
  char name; /* Really an inline string */
} dll_info;

static mlval shared_object_info = MLNIL;

static void fix(mlval *what, dll_info_ptr old, dll_info_ptr new)
{
  mlval value = *what;
  if (MLVALISPTR(value)) {
    word addr = (word)value;
    while (old != NULL) {
      word text_start = old->text_start;
      word text_end = old->text_end;
      word data_start = old->data_start;
      word data_end = old->data_end;
      word new_text_start = new->text_start;
      word new_data_start = new->data_start;
      /*
      printf("fix 0x%p(0x%x)\n", what, value);
      */
      if (addr >= text_start && addr < text_end) {
	*what = (mlval)(addr + new_text_start - text_start);
	/*
	if (value != *what)
	  printf("fix 0x%p(0x%x) to 0x%x\n", what, value, *what);
	  */
	break;
      } else if (addr >= data_start && addr < data_end) {
	*what = (mlval)(addr + new_data_start - data_start);
	/*
	if (value != *what)
	  printf("fix 0x%p(0x%x) to 0x%x\n", what, value, *what);
	  */
	break;
      }
      old = old->next;
      new = new->next;
    }
  } else {
    return;
  }
}

static void scan(mlval *start, mlval *end, dll_info_ptr old, dll_info_ptr new)
{
  while(start < end) {
    mlval value = *start;
    
    switch(PRIMARY(value)) {
      case INTEGER0:
      case INTEGER1:
      case PRIMARY6:
      case PRIMARY7:
      ++start;
      break;
      
      case HEADER:
      switch(SECONDARY(value)) {
	case STRING:
	case BYTEARRAY:
	start = (mlval *)double_align((byte *)(start+1) + LENGTH(value));
	continue;

	case CODE:
	fix(start+1, old, new);
	cache_flush((void*)(start+2), (LENGTH(value)+1) * sizeof(mlval));
	start += LENGTH(value)+1;
	continue;
	
	case ARRAY:
	case WEAKARRAY:
	{
	  union ml_array_header *array = (union ml_array_header *)start;
	  /* No need to deal with forward or backward pointers */
	  /* As these can't go through the dll area */
	  start = &array->the.element[0];
	}
	break;
	
	default:
	++start;
      }
      break;
      
      default:
      fix(start, old, new);
      ++start;
    }
  }
}

static void display_bounds(dll_info_ptr old, dll_info_ptr new)
{
  while (old != NULL) {
    printf("DLL %s has bounds 0x%x - 0x%x (text), 0x%x - 0x%x (data) moved to 0x%x - 0x%x, 0x%x - 0x%x\n",
	   &old->name, old->text_start, old->text_end, old->data_start, old->data_end,
	   new->text_start, new->text_end, new->data_start, new->data_end);
    old = old->next;
    new = new->next;
  }
}

static void fix_heap(dll_info_ptr old, dll_info_ptr new)
{
  struct ml_heap *gen;
  /*
  display_bounds(old, new);
  */
  /* Modelled on the relevant part of image_load_common from <URI://MLWrts/src/image.c> */
  for(gen = creation; gen != NULL; gen = gen->parent) {
    struct ml_static_object *stat = gen->statics.forward;
    /* No need to look at entry lists, as we have no static reference objects */
    /* Fix the static object chain */
    while(stat != &gen->statics) {
      mlval header = stat->object[0];
      mlval secondary = SECONDARY(header);
      mlval length = LENGTH(header);
      size_t size = OBJECT_SIZE(secondary,length);
      mlval *base = &stat->object[0];
      mlval *top = (mlval*) ((byte*)base + size);

      stat->gen = gen;
      scan(base, top, old, new);

      stat = stat->forward;
    }
    /* Now do the rest of the normal heap */
    scan(gen->start, gen->top, old, new);
  }
}

void put_nibble(unsigned char x)
{
  char s[2];
  s[1] = '\0';
  s[0] = (x < 10) ? '0' + x : 'a' + x - 10;
  fputs(s, stdout);
}

/*
void put_byte(unsigned char x)
{
  put_nibble((x >> 4) & 0xf);
  put_nibble(x & 0xf);
}

void put_short(unsigned short x)
{
  put_byte((x >> 8) & 0xff);
  put_byte(x & 0xff);
}

void put_long(unsigned long x)
{
  put_short((unsigned short)((x >> 16) & 0xffff));
  put_short((unsigned short)(x & 0xffff));
}
*/

static unsigned long *time_stamps = NULL;

int dll_validate(void *addr)
{
  dll_info_ptr ptr = (dll_info_ptr)time_stamps;
  while (ptr != NULL) {
    word text_start = ptr->text_start;
    word text_end = ptr->text_end;
    word data_start = ptr->data_start;
    word data_end = ptr->data_end;
    if ((word)addr >= text_start && (word)addr < text_end) {
      return 1;
    } else if ((word)addr >= data_start && (word)addr < data_end) {
      return 1;
    }
    ptr = ptr->next;
  }
  return 0;
}

void register_time_stamp(unsigned long *addr)
{
  /*
  fputs("stamp found address: ", stdout);
  put_long((unsigned long)addr);
  fputs("\nvalue: ", stdout);
  put_long(addr[0]);
  fputs(", ", stdout);
  put_long(addr[1]);
  fputs(", ", stdout);
  put_long(addr[2]);
  fputs(", ", stdout);
  put_long(addr[3]);
  fputs(", ", stdout);
  put_long(addr[4]);
  fputs(", ", stdout);
  put_long(addr[5]);
  fputs(", ", stdout);
  put_long(addr[6]);
  fputs(", ", stdout);
  put_long(addr[7]);
  fputs("\n", stdout);
  */
  /* Now save them away */
  if (time_stamps == NULL) {
    time_stamps = addr;
  } else {
    unsigned long *stamps = time_stamps;
    while (stamps[8] != 0) {
      /*
      fputs("Following stamp at ", stdout);
      put_long((unsigned long)stamps);
      fputs(" to ", stdout);
      put_long(stamps[8]);
      fputs("\n", stdout);
      */
      stamps = (unsigned long *)(stamps[8]);
    }
    stamps[8] = (unsigned long)addr;
  }
}

static dll_info_ptr make_image_stamps(mlval list)
{
  mlval head;
  if (list != MLNIL) {
    dll_info_ptr tail = make_image_stamps(MLTAIL(list));
    dll_info_ptr result = malloc(sizeof(struct dll_info));
    if (result == NULL) {
      error_without_alloc("failed to allocate dll_info structure when fixing dll relocation");
    };
    result->next = tail;
    head = MLHEAD(list);
    result->stamp1 = word32_to_num(FIELD(head, 0));
    result->stamp2 = word32_to_num(FIELD(head, 1));
    result->stamp3 = word32_to_num(FIELD(head, 2));
    result->stamp4 = word32_to_num(FIELD(head, 3));
    result->text_start = word32_to_num(FIELD(head, 4));
    result->data_start = word32_to_num(FIELD(head, 5));
    result->text_end = word32_to_num(FIELD(head, 6));
    result->data_end = word32_to_num(FIELD(head, 7));
    /* Don't both with the name as we won't be accessing it */
    return result;
  } else {
    return NULL;
  }
}

static mlval initialise_shared_object_info(unsigned long *stamps)
{
  if (stamps == NULL) {
    return MLNIL;
  } else {
    mlval name = MLUNIT;
    mlval record = MLUNIT;
    mlval word32 = MLUNIT;
    mlval temp = MLUNIT;
    mlval result = initialise_shared_object_info((unsigned long *)(stamps[8]));
    /* Get result from tail of list first */
    int i;
    declare_root(&name, 0);
    declare_root(&record, 0);
    declare_root(&temp, 0);
    declare_root(&result, 0);
    temp = allocate_array(8);
    /* We need an array because we're going to allocate and update */
    for (i=0; i<8; ++i) {
      MLUPDATE(temp, i, MLUNIT);
    }
    name = ml_string((char *)(stamps+9));
    for (i = 0; i< 8; ++i) {
      word32 = allocate_word32();
      num_to_word32(stamps[i], word32);
      MLUPDATE(temp, i, word32);
      /* Copy in unique stamp plus memory limits */
    }
    record = allocate_record(9);
    FIELD(record, 8) = name;
    for (i = 0; i< 8; ++i) {
      FIELD(record, i) = MLSUB(temp, i);
      /* Put this stuff in the right place */
    }
    result = mlw_cons(record, result);
    retract_root(&name);
    retract_root(&record);
    retract_root(&temp);
    retract_root(&result);
    return result;
  }
}

static void check_loaded_shared_object_info(const char *name, mlval *root, mlval value)
{
  /* We're given the global name, the heap image root and the value for this name */
  mlval head;
  mlval list = value;
  int i;
  char *image_name;
  unsigned long *stamps = time_stamps;
  dll_info_ptr image_stamps;
  /*
  printf("Check_Loaded_Shared_Object_Info of %s\n", name);
  */
  while (list != MLNIL) {
    head = MLHEAD(list);
    image_name = CSTRING(FIELD(head, 8));
    if (stamps == NULL) {
      error("DLL %s found in image but not loaded\n", image_name);
    }
    if (strcmp(image_name, (char *)(stamps+9)) != 0) {
      error("DLL %s found in image but %s loaded\n", image_name, (char *)(stamps+9));
    }
    for (i = 0; i < 4; ++i) {
      if (stamps[i] != word32_to_num(FIELD(head, i))) {
	error("Consistency failure for DLL %s\n", image_name);
      }
    }
    /*
    printf("DLL %s found\n", CSTRING(FIELD(head, 8)));
    */
    list = MLTAIL(list);
    stamps = (unsigned long *)(stamps[8]);
  }
  image_stamps = make_image_stamps(value);
  fix_heap(image_stamps, (dll_info_ptr)time_stamps);
  *root = initialise_shared_object_info(time_stamps);
  /* Reinitialise as image loading will have wiped this */
  return;
}

extern int system_validate_ml_address(void *addr)
{
  return dll_validate(addr);
  return 0;
  /* Temporary implementation until shared objects done */
}

void win32_init(void)
{

  /* first: set up the standard IO.  On win32, these have to be
   * fixed every time an image is loaded, otherwise we'll attempt
   * to IO via handles declared in the compiler.
   * note that we declare references to the handle, so that
   * the win32 and unix interfaces to the pervasive library are
   * uniform with minimal fuss.
   */

  win32_std_in = mlw_ref_make(MLINT(GetStdHandle(STD_INPUT_HANDLE)));
  declare_global("pervasive win32 std in", &win32_std_in,
		 GLOBAL_DEFAULT, NULL, fix_win32_std_io, NULL);
  env_value("system io standard input",win32_std_in);

  win32_std_out = mlw_ref_make(MLINT(GetStdHandle(STD_OUTPUT_HANDLE)));
  declare_global("pervasive win32 std out", &win32_std_out,
		 GLOBAL_DEFAULT, NULL, fix_win32_std_io, NULL);
  env_value("system io standard output",win32_std_out);

  win32_std_err = mlw_ref_make(MLINT(GetStdHandle(STD_ERROR_HANDLE)));
  declare_global("pervasive win32 std err", &win32_std_err,
		 GLOBAL_DEFAULT, NULL, fix_win32_std_io, NULL);
  env_value("system io standard error", win32_std_err);



  ml_hkey_classes_root = MLHKEY (HKEY_CLASSES_ROOT);
  declare_global("nt reg hkey classes root", &ml_hkey_classes_root,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("nt reg hkey classes root", ml_hkey_classes_root);

  ml_hkey_current_user = MLHKEY (HKEY_CURRENT_USER);
  declare_global("nt reg hkey current user", &ml_hkey_current_user,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("nt reg hkey current user", ml_hkey_current_user);

  ml_hkey_local_machine = MLHKEY (HKEY_LOCAL_MACHINE);
  declare_global("nt reg hkey local machine", &ml_hkey_local_machine,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("nt reg hkey local machine", ml_hkey_local_machine);

  ml_hkey_users = MLHKEY (HKEY_USERS);
  declare_global("nt reg hkey users", &ml_hkey_users,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
  env_value("nt reg hkey users", ml_hkey_users);


  env_function("system os win32 open", win32_open);
  env_function("system os win32 size", win32_size);

  env_function("system io close", win32_close);
  env_function("system io write", win32_write);
  env_function("system io read", win32_read);
  env_function("system io seek", win32_seek);
  env_function("system io can input", win32_can_input);

  env_function("OS.errorMsg",  mlw_os_error_msg);
  env_function("OS.errorName", mlw_os_error_name);
  env_function("OS.syserror",  mlw_os_syserror);

  env_function("OS.FileSys.openDir",   mlw_os_file_sys_open_dir);
  env_function("OS.FileSys.readDir",   mlw_os_file_sys_read_dir);
  env_function("OS.FileSys.rewindDir", mlw_os_file_sys_rewind_dir);
  env_function("OS.FileSys.closeDir",  mlw_os_file_sys_close_dir);
  env_function("OS.FileSys.chDir",     mlw_os_file_sys_ch_dir);
  env_function("OS.FileSys.getDir",    mlw_os_file_sys_get_dir);
  env_function("OS.FileSys.mkDir",     mlw_os_file_sys_mk_dir);
  env_function("OS.FileSys.isDir",     mlw_os_file_sys_is_dir);
  env_function("OS.FileSys.rmDir",     mlw_os_file_sys_rm_dir);
  env_function("OS.FileSys.fullPath",  mlw_os_file_sys_full_path);
  env_function("OS.FileSys.modTime",   mlw_os_file_sys_mod_time);
  env_function("OS.FileSys.fileSize",  mlw_os_file_sys_file_size);
  env_function("OS.FileSys.setTime_",  mlw_os_file_sys_set_time);
  env_function("OS.FileSys.remove",    mlw_os_file_sys_remove);
  env_function("OS.FileSys.rename",    mlw_os_file_sys_rename);
  env_function("OS.FileSys.access",    mlw_os_file_sys_access);
  env_function("OS.FileSys.tmpName",   mlw_os_file_sys_tmp_name);

  env_function("OS.IO.kind", mlw_os_io_kind);

  env_function("Win32.fdToIOD", mlw_win32_fd_to_io_desc);
  env_function("Win32.closeIOD", mlw_win32_close_iod);

  env_function("system os exit",   mlw_os_process_exit);
  env_function("system os system", mlw_os_process_system);
  env_function("system os getenv", mlw_os_process_getenv);

  env_function("system os win32 create_process", win32_create_process);

  /* Registry stuff */
  env_function("nt reg close key", reg_close_key);
  env_function("nt reg create key ex", reg_create_key_ex);
  env_function("nt reg open key ex", reg_open_key_ex);
  env_function("nt reg query value ex", reg_query_value_ex);
  env_function("nt reg set value ex", reg_set_value_ex);
  env_function("nt reg delete key", reg_delete_key);

  /* File system */
  env_function("Windows.fileTimeToLocalFileTime", ml_filetimetolocalfiletime);
  env_function("Windows.localFileTimeToFileTime", ml_localfiletimetofiletime);
  env_function("Windows.getVolumeInformation", ml_getvolumeinformation);

  /* Processes */
  env_function("Windows.findExecutable", ml_find_executable);
  env_function("Windows.openDocument", ml_open_document);
  env_function("Windows.launchApplication", ml_launch_application);
  env_function("Windows.hasOwnConsole", ml_has_console);
  env_function("Windows.execute", ml_execute);
  env_function("Windows.executeNullStreams", ml_execute_null_streams);
  env_function("Windows.streamsOf", ml_streams_of);
  env_function("Windows.reap", ml_reap);

  /* DLL/SO initialisation */
  declare_global("shared_object_info", &shared_object_info, GLOBAL_DEFAULT,
		 NULL, check_loaded_shared_object_info, NULL);
  shared_object_info = initialise_shared_object_info(time_stamps);
}
@


1.50.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.50  1999/03/18  12:41:29  daveb
 * [Bug #190523]
 * Changes to the Windows structure.
 *
@


1.49
log
@[Bug #190521]
OS.FileSys.readDir now returns an option type.
@
text
@d13 4
d490 1
d1164 1
a1164 1
 * OS.Process.exit: int -> 'a
d1168 1
a1168 1
  exit(CINT(exit_code));
d1175 1
a1175 1
 * OS.Process.system: string -> int
d1185 1
a1185 1
  return MLINT(status);
a1419 1
    mlval ml_flags;
d1427 5
a1431 8
    ml_flags = box(flags);
    declare_root(&ml_flags, 0);
    result = allocate_record(5);
    FIELD(result, 0) = ml_flags;
    FIELD(result, 1) = MLINT(component_length);
    FIELD(result, 2) = serNum;
    FIELD(result, 3) = sysName;
    FIELD(result, 4) = volName;
a1434 1
    retract_root(&ml_flags);
d1489 5
a1493 1
static mlval ml_shell_execute(mlval arg)
a1494 3
  char *name = CSTRING(FIELD(arg, 0));
  mlval args = FIELD(arg, 1);
  char *c_args = get_args(args, "Windows.shellExcute");
d1501 1
a1501 1
      exn_raise_syserr(ml_string("System out of resource during Windows.shellExecute"), 0);
d1513 1
a1513 1
      exn_raise_syserr(ml_string("A path was not found during Windows.shellExecute"), 0);
d1521 1
a1521 1
      exn_raise_syserr(ml_string("The DDE transaction could not be completed because other DDE transactions were being processed during Windows.shellExecute"), 0);
d1523 1
a1523 1
      exn_raise_syserr(ml_string("DDE transaction failed during Windows.shellExecute"), 0);
d1525 1
a1525 1
      exn_raise_syserr(ml_string("The DDE transaction request timed out during Windows.shellExecute"), 0);
d1531 1
a1531 1
      exn_raise_syserr(format_to_ml_string("A sharing violation occurred during Windows.shellExecute of '%s'", name), 0);
a1533 2
  } else {
    return MLUNIT;
d1537 1
a1537 1
static mlval ml_new_console(mlval arg)
d1539 12
a1550 11
  BOOL res = FreeConsole();
  if (res == TRUE) {
    res = AllocConsole();
    if (res == TRUE) {
      return MLUNIT;
    } else {
      mlw_raise_win32_syserr(GetLastError());
    }
  } else {
    mlw_raise_win32_syserr(GetLastError());
  }
d1553 1
d1597 3
d1609 1
a1609 1
  char *c_args = get_args(mlw_cons(name, args), "Windows.excute");
d1613 2
a1615 1

d1619 4
d1626 5
a1630 2
  if (!SetStdHandle(STD_OUTPUT_HANDLE, hChildStdoutWr))
    exn_raise_syserr(ml_string("Redirecting STDOUT failed in Windows.execute"), 0);
d1637 3
a1639 3
    CloseHandle(hChildStdoutRd);
    CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
    exn_raise_syserr(ml_string("DuplicateHandle failed in Windows.execute"), 0);
d1642 1
d1651 1
a1651 1
    CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
d1653 2
a1654 2
    CloseHandle(hChildStdinWr); /* Get rid of the pipe */
    exn_raise_syserr(ml_string("Redirecting Stdin failed in Windows.execute"), 0);
d1662 1
a1662 1
    CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
d1664 1
a1664 1
    CloseHandle(hChildStdinWr); /* Get rid of the pipe */
d1675 2
a1676 2
    CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
    CloseHandle(hChildStdinRd);  /* Get rid of the pipe */
d1684 3
a1686 2
  CloseHandle(hChildStdoutWr); /* Get rid of the pipe */
  CloseHandle(hChildStdinRd);  /* Get rid of the pipe */
d1699 2
d1705 79
d1792 1
a1792 1
  return (FIELD(arg, 0)); /* The arg is a pair of the stream and the process handle */
d1795 1
d1803 3
a1805 3
  mlval pair = FIELD(arg, 0);
  HANDLE in = (HANDLE)(CINT(FIELD(pair, 0)));
  HANDLE out = (HANDLE)(CINT(FIELD(pair, 1)));
d1808 1
d1816 1
a1816 1
      return MLINT(status);
d1823 2
a1824 2
      int err = GetLastError();
      mlw_raise_win32_syserr(err);
d1829 1
d2303 2
a2304 2
  env_function("Windows.shellExecute", ml_shell_execute);
  env_function("Windows.newConsole", ml_new_console);
d2307 1
@


1.48
log
@[Bug #70234]
Add calls to GetEnvironmentStrings and FreeEnvironmentStrings
and pass result as environment in call to CreateProcess
@
text
@d13 5
d647 1
a647 1
 * OS.FileSys.readDir : dirstream -> string
d661 1
a661 6
    result= mlw_ref_value(mlw_dirstream_file_name(arg));
    if (CSTRING(result)[0] != '\0') {
      declare_root(&result, 0);
      mlw_ref_update(mlw_dirstream_file_name(arg), ml_string(""));
      retract_root(&result);
    }
d671 1
a672 1
  return result;
@


1.47
log
@[Bug #70238]
Use WaitForSingleObject istead of busy wait in Windows.execute
@
text
@d13 4
d1608 1
d1658 2
a1659 1
  if (CreateProcess(NULL, c_args, NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo) == FALSE) {
d1664 1
d1667 1
@


1.46
log
@[Bug #70232]
Pass correct command line to CreateProcess (70233)
Close leftover handles
@
text
@d13 5
d1700 2
a1701 2
  HANDLE in = FIELD(pair, 0);
  HANDLE out = FIELD(pair, 1);
d1703 3
a1705 1
  do {
d1707 10
a1716 13
      switch(status) {
      case STILL_ACTIVE:
	/* sleep for a bit (10 ms) and try again */
	Sleep(10);
	break;
      default:
	/* Close our resources */
	CloseHandle(hProcess);
	CloseHandle(in);
	CloseHandle(out);
	return MLINT(status);
      }
    } else {
d1721 1
a1721 1
  } while (1);
@


1.45
log
@[Bug #70220]
Add reap function
@
text
@d13 4
d1355 3
a1357 1

d1594 1
a1594 1
  char *name = CSTRING(FIELD(arg, 0));
d1596 1
a1596 1
  char *c_args = get_args(args, "Windows.excute");
d1648 1
a1648 1
  if (CreateProcess(name, c_args, NULL, NULL, TRUE, 0, NULL, NULL, &siStartInfo, &piProcInfo) == FALSE) {
d1658 2
d1694 3
d1706 1
d1708 2
@


1.44
log
@[Bug #30490]
Get streams from Windows.streamsOf in the right order (they were reversed)
@
text
@d13 4
d1649 1
d1653 1
d1655 9
a1663 3
    mlval proc = allocate_record(2);
    FIELD(proc, 0) = MLINT(hChildStdoutRdDup);
    FIELD(proc, 1) = MLINT(hChildStdinWrDup);
d1671 1
d1676 28
a1703 1
  return arg; /* At present, this is precisely what we want */
d2184 1
@


1.43
log
@[Bug #50095]
Fix Windows.hasOwnConsole
@
text
@d13 4
d1650 2
a1651 2
    FIELD(proc, 0) = MLINT(hChildStdinWrDup);
    FIELD(proc, 1) = MLINT(hChildStdoutRdDup);
@


1.42
log
@[Bug #30108]
Implement DLL based ML code
@
text
@d13 4
d1530 20
d1552 12
a1563 4
  HANDLE stdOut = GetStdHandle(STD_OUTPUT_HANDLE);
  CONSOLE_SCREEN_BUFFER_INFO info;
  if (GetConsoleScreenBufferInfo(stdOut, &info) == TRUE) {
    if (info.dwCursorPosition.X == 0 && info.dwCursorPosition.Y == 0) {
a1567 2
  } else {
    mlw_raise_win32_syserr(GetLastError());
@


1.41
log
@[Bug #70153]
Add prototype for system_validate_ml_address
@
text
@d13 4
d237 2
d1632 360
d1994 1
d2110 5
@


1.40
log
@[Bug #70153]
Add system_validate_ml_address
@
text
@d13 4
d231 1
@


1.39
log
@[Bug #50094]
Fix problems where findExecutable is returning wrong answers
@
text
@d13 4
d1619 6
@


1.38
log
@[Bug #30461]
Add missing FindClose to  mlw_os_file_sys_full_path
@
text
@d13 4
d1410 1
a1410 1
      exn_raise_syserr(format_to_ml_string("file '%s' not found", name), 0);
d1412 1
@


1.37
log
@[Bug #30434]
Fix access path parameter passing for registry functions
@
text
@d13 4
d890 1
d912 1
a912 1
  HANDLE file_handle= FindFirstFile(file_name, &file_data);
@


1.36
log
@[Bug #50083]
Convert from short filename to long.
@
text
@d13 4
a286 14
static REGSAM sam_values[] =
{
  KEY_ALL_ACCESS,
  KEY_CREATE_LINK,
  KEY_CREATE_SUB_KEY,
  KEY_ENUMERATE_SUB_KEYS,
  KEY_EXECUTE,
  KEY_NOTIFY,
  KEY_QUERY_VALUE,
  KEY_READ,
  KEY_SET_VALUE,
  KEY_WRITE
};

d289 2
a290 6
  return (sam_values[CINT (arg)]);
}

static mlval ml_convert_sam_values (mlval arg)
{
  return MLINT(convert_sam_values(arg));
d315 1
a315 1
  if (result)
d317 1
a317 1
  else
d319 1
d364 2
a365 2
  if (result)
    return ml_string (NULL);
a1698 1
  env_function("nt ml convert sam values", ml_convert_sam_values);
@


1.35
log
@[Bug #30416]
Add support for CREATE_ALWAYS
@
text
@d13 4
d211 1
a211 1

d569 1
a569 1
  LPCTSTR dir_name= CSTRING(arg);
d571 1
a571 1
  HANDLE handle= FindFirstFile(dir_name, &file_data);
d576 8
d595 1
a595 1
  mlw_dirstream_dir_name(dirstream)= arg;
d664 1
a664 1
  dir_name= CSTRING(mlw_dirstream_dir_name(arg));
@


1.34
log
@[Bug #70042]
Fix fullPath to succeed on root directories.
@
text
@d13 4
d427 3
a429 1
  DWORD action = (act == 0) ? OPEN_ALWAYS : OPEN_EXISTING;
@


1.33
log
@[Bug #70107]
Add a function to close file descriptors opened by _open_osfhandle
@
text
@d13 4
d866 3
d870 4
a873 1
  {
@


1.32
log
@[Bug #70086]
Add functions necessary to implement WINDOWS signature in basis
@
text
@d13 4
d1209 2
a1222 1

d1226 8
d1235 6
d1675 1
@


1.31
log
@[Bug #70018]
Modify declare_root to accept a second parameter
indicating whether the root is live for image save
@
text
@d5 1
a5 1
 * by win32_, but there is a rolling program to change the prefix to mlw_ 
d7 1
a7 1
 * strictly necessary for static functions/values but for consistency 
d13 5
d267 1
a267 1
static REGSAM sam_values[] = 
d273 1
a273 1
  KEY_EXECUTE, 
d293 1
a293 1
  HKEY hkey = CHKEY (arg); 
d297 1
a297 1
  if (result) 
d302 1
a302 1
/* This function returns an HKEY option value as opposed to the 
d307 1
a307 1
  char* subkey = CSTRING(FIELD(arg, 1));
d313 3
a315 3
  if (result) 
    return mlw_option_make_none(); 
  else 
d319 32
d354 2
a355 2
  HKEY hkey = CHKEY(FIELD(arg, 0)); 
  char* valuename = CSTRING(FIELD(arg, 1));
d361 1
a361 1
  if (result) 
d376 27
d443 1
a443 1
/* the following is dummy --- it is required by pervasive library 
d503 1
a503 1
  DWORD moveMethod = (meth == 0) ? FILE_BEGIN : 
d637 1
a637 1
  
d827 1
a827 1
  } 
d992 1
a992 1
 *   ... only raise OS.SysError for errors unrelated to resolving the 
d1066 1
a1066 1
  } 
d1138 1
a1138 1
 * The following values are C versions of the values defined 
d1161 1
a1161 1
 * Could implement this with native Win32 calls such as 
d1175 1
a1175 1
  if (_fstat(io_desc, &st) < 0) 
d1236 1
a1236 1
   
d1244 1
a1244 1
   case ML_NORMAL_PRIORITY :        
d1252 1
a1252 1
   case ML_BACKGROUND_PRIORITY :        
d1256 1
a1256 1
   case ML_REALTIME_PRIORITY :        
d1285 11
d1297 275
d1602 2
a1603 2
  declare_global("nt reg hkey classes root", &ml_hkey_classes_root, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);  
d1607 2
a1608 2
  declare_global("nt reg hkey current user", &ml_hkey_current_user, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);  
d1612 2
a1613 2
  declare_global("nt reg hkey local machine", &ml_hkey_local_machine, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);  
d1617 2
a1618 2
  declare_global("nt reg hkey users", &ml_hkey_users, 
		 GLOBAL_DEFAULT, NULL, NULL, NULL);  
d1663 2
a1664 1
  env_function("nt ml convert sam values", ml_convert_sam_values); 
d1666 1
d1668 16
a1683 2
  env_function("nt reg query value ex", reg_query_value_ex); 

@


1.30
log
@[Bug #70028]
Fix problem with trailing \
in mlval mlw_os_file_sys_full_path
@
text
@d13 5
d497 1
a497 1
  declare_root(&arg);
d500 1
a500 1
  declare_root(&ml_file_name_ref);
d503 1
a503 1
  declare_root(&ml_handle_ref);
d533 1
a533 1
      declare_root(&result);
d539 1
a539 1
    declare_root(&arg);
d542 1
a542 1
    declare_root(&result);
d578 1
a578 1
  declare_root(&arg);
d605 1
a605 1
  declare_root(&arg);
@


1.29
log
@[Bug #30233]
Fix create_process.
@
text
@d13 4
d708 1
d710 13
d724 5
d759 30
@


1.29.1.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 4
 * Revision 1.29  1997/10/30  10:53:24  johnh
 * [Bug #30233]
 * Fix create_process.
 *
@


1.28
log
@[Bug #01702]
mlw_win32_strerror moved to win32_error.h.
@
text
@d13 4
d1160 1
a1160 5
   switch (result) {
   case TRUE  : return( MLINT(0) ) ;
   case FALSE : return( MLINT(1) ) ;
   default    : return( MLINT(1) ) ;
   }
@


1.28.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 * Revision 1.28  1997/05/22  08:50:07  johnh
 * [Bug #01702]
 * mlw_win32_strerror moved to win32_error.h.
 *
@


1.28.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 4
 * Revision 1.28  1997/05/22  08:50:07  johnh
 * [Bug #01702]
 * mlw_win32_strerror moved to win32_error.h.
 *
@


1.27
log
@[Bug #30142]
Change the type of a handle in mlw_dirstream from an int to a boxed
int since under Win95 the handle seems to have its bottom bits set.
@
text
@d13 5
d175 2
a176 40
#include "os_errors.h"		/* mlw_win32_strerror, mlw_os_syserror ... */

/* A note on error codes
 * ---------------------
 * 
 * Most Win32 functions that fail set an error code that can be obtained
 * using GetLastError.  Unfortunately, Win32 doesn't seem to support all
 * the functionallity MLWorks needs and so some use needs to be made of
 * routines that are to be found in the Visual C++ compatability (Unix) 
 * library.  These routines generally set errno when they fail.  This means
 * that there are two types of error codes that needs to be returned by
 * OS.SysErr when a failure occurs.  The simple approach would be to 
 * define syserror as something like :-
 *
 *   datatype syserror = WIN32_ERROR int | UNIX_ERROR int
 *
 * and then just inject the error code into the correct one.  Note that
 * this would be different from the Unix definition which can get by
 * with just
 *
 *   type syserror = int
 * 
 * Unfortunately, due to problems with the rebinding of exceptions, the
 * SysErr exception is defined in MLWorks.Internal.Error and has the type
 * 
 *   type syserror = int
 *   exception SysError of syserror Option.option
 *
 * i.e. it is hardwired to be just an int :-<
 *
 * The solution adopted for Win32 is to squeeze both types of error
 * into the one int by encoding them as :-
 *
 *   Win32 error == (GetLastError()<<1)|0
 *   Unix error  == (errno<<1)|1
 *
 * This is feasible because errno rarely gets above 100 and the error code
 * portion of GetLastError is a 16-bit value.
 *
 */
a202 16


static void mlw_raise_win32_syserr()
{
  int i= GetLastError();
  exn_raise_syserr(mlw_win32_strerror(i), (i<<1));
}


static void mlw_raise_c_syserr(int errno)
{
  exn_raise_syserr(strerror(errno), (errno<<1)|1);
}



d209 1
a209 1
  char const *error_msg;
d212 2
a213 2
    : strerror((int)(error_code>>1));
  return ml_string(error_msg);
d344 1
a344 1
    mlw_raise_win32_syserr();
d359 1
a359 1
    mlw_raise_win32_syserr();
d373 1
a373 1
  mlw_raise_win32_syserr();
d395 1
a395 1
    mlw_raise_win32_syserr();
d412 1
a412 1
  mlw_raise_win32_syserr();
d430 1
a430 1
    mlw_raise_win32_syserr();
d441 1
a441 1
    mlw_raise_win32_syserr();
d444 1
a444 1
    exn_raise_syserr("File Too Large", 0);
d482 1
a482 1
    mlw_raise_win32_syserr();
d513 1
a513 1
    exn_raise_syserr("OS.FileSys.readDir: attempt to read from closed dirstream", 0);
d517 1
a517 1
      mlw_raise_win32_syserr();
d556 1
a556 1
    exn_raise_syserr("OS.FileSys.rewindDir: attempt to rewind closed dirstream", 0);
d559 1
a559 1
    mlw_raise_win32_syserr();
d563 1
a563 1
    mlw_raise_win32_syserr();
d590 1
a590 1
    mlw_raise_win32_syserr();
d609 1
a609 1
    mlw_raise_win32_syserr();
d633 1
a633 1
    mlw_raise_win32_syserr();
d642 1
a642 1
      mlw_raise_win32_syserr();
d667 1
a667 1
    mlw_raise_win32_syserr();
d681 1
a681 1
    mlw_raise_win32_syserr();
d696 1
a696 1
    mlw_raise_win32_syserr();
d720 1
a720 1
    mlw_raise_win32_syserr();
d728 1
a728 1
      mlw_raise_win32_syserr();
d739 1
a739 1
      mlw_raise_win32_syserr();
d765 1
a765 1
    mlw_raise_win32_syserr();
d792 1
a792 1
    mlw_raise_win32_syserr();
d795 1
a795 1
    exn_raise_syserr("OS.FileSys.fileSize: file too large", 0);
d821 1
a821 1
    mlw_raise_win32_syserr();
d824 1
a824 1
    mlw_raise_win32_syserr();
d826 1
a826 1
    mlw_raise_win32_syserr();
d840 1
a840 1
    mlw_raise_win32_syserr();
d855 1
a855 1
    mlw_raise_win32_syserr();
d928 1
a928 1
    mlw_raise_win32_syserr();
d937 1
a937 1
      mlw_raise_win32_syserr();
d951 1
a951 1
      mlw_raise_win32_syserr();
d1062 1
a1062 1
    exn_raise_syserr("OS.IO.kind: unknown io_desc kind", 0);
@


1.26
log
@[Bug #2004]
make win32_seek seek to current position when third arg=1
@
text
@d13 4
a508 6
 *
 * Win32 doesn't say anything about the structure of HANDLE (no reason
 * that it should really), but they appear to be ints/pointers that
 * don't have the bottom bits set.  Therefore they are treated as ints
 * by MLWorks.  Just to make sure, various asserts are in the code
 * to ensure that if they aren't, we hear about it quickly.
a516 7
/* Used to indicate the the dirstream cannot be read from.
 * Could perhaps use INVALID_HANDLE_VALUE, but I believe that is -1
 * and hence might look like some kind of pointer to the GC system.
 */
#define mlw_dirstream_closed 0


a524 1
  mlval ml_file_name, ml_file_name_ref, dirstream;
d526 3
a532 2
  assert(!MLVALISPTR(handle));

d537 3
d542 1
a542 1
  mlw_dirstream_dir_handle(dirstream)= (mlval)handle;
d544 1
d559 1
a559 1
  HANDLE handle= (HANDLE)mlw_dirstream_dir_handle(arg);
d561 1
a561 1
  if (handle == mlw_dirstream_closed)
d568 5
a572 2
    if (CSTRING(result)[0] != '\0')
      mlw_ref_update(mlw_dirstream_file_name(arg), ml_string(NULL));
d578 1
d580 1
d600 3
a602 1
  HANDLE handle= (HANDLE)mlw_dirstream_dir_handle(arg);
d604 1
a604 1
  if (handle == mlw_dirstream_closed)
a613 3
  assert(!MLVALISPTR(handle));

  mlw_dirstream_dir_handle(arg)= (mlval)handle;
d615 4
a618 1
  mlw_ref_update(mlw_dirstream_file_name(arg),  ml_string(file_data.cFileName));
d632 2
a633 1
  HANDLE handle= (HANDLE)mlw_dirstream_dir_handle(arg);
d635 1
a635 1
  if (handle == mlw_dirstream_closed)
d637 1
d640 5
a644 1
  mlw_dirstream_dir_handle(arg)= mlw_dirstream_closed;
@


1.26.1.1
log
@branched from 1.26
@
text
@a12 4
 * Revision 1.26  1997/03/27  16:23:51  andreww
 * [Bug #2004]
 * make win32_seek seek to current position when third arg=1
 *
@


1.26.1.2
log
@[Bug #30142]
Changed the type of a dir_handle in DIRSTREAM from an int to a Word32.word ref,
because these values aren't always aligned on Windows 95.
@
text
@a12 8
 * Revision 1.26.1.1  1997/05/12  10:40:56  hope
 * branched from 1.26
 *
 * Revision 1.27  1997/05/21  10:51:55  stephenb
 * [Bug #30142]
 * Change the type of a handle in mlw_dirstream from an int to a boxed
 * int since under Win95 the handle seems to have its bottom bits set.
 *
d509 6
d523 7
d538 1
a539 3
  mlval ml_file_name, ml_file_name_ref;
  mlval ml_handle, ml_handle_ref;
  mlval dirstream;
d544 2
a549 3
  ml_handle= box((UINT)handle);
  ml_handle_ref= mlw_ref_make(ml_handle);
  declare_root(&ml_handle_ref);
d552 1
a552 1
  mlw_dirstream_dir_handle(dirstream)= ml_handle_ref;
a553 1
  retract_root (&ml_handle_ref);
d568 1
a568 1
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));
d570 1
a570 1
  if (handle == INVALID_HANDLE_VALUE)
d577 2
a578 5
    if (CSTRING(result)[0] != '\0') {
      declare_root(&result);
      mlw_ref_update(mlw_dirstream_file_name(arg), ml_string(""));
      retract_root(&result);
    }
a583 1
    declare_root(&result);
a584 1
    retract_root(&result);
d604 1
a604 3
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));
  mlval boxed_handle;
  mlval ml_file_name;
d606 1
a606 1
  if (handle == INVALID_HANDLE_VALUE)
d616 3
d620 1
a620 4
  boxed_handle= box((UINT)handle);
  mlw_ref_update(mlw_dirstream_dir_handle(arg), boxed_handle);
  ml_file_name= ml_string(file_data.cFileName);
  mlw_ref_update(mlw_dirstream_file_name(arg), ml_file_name);
d634 1
a634 2
  HANDLE handle= (HANDLE)unbox(mlw_ref_value(mlw_dirstream_dir_handle(arg)));
  mlval boxed_handle;
d636 1
a636 1
  if (handle == INVALID_HANDLE_VALUE)
a637 1

d640 1
a640 5

  declare_root(&arg);
  boxed_handle= box((UINT)INVALID_HANDLE_VALUE);
  mlw_ref_update(mlw_dirstream_dir_handle(arg), boxed_handle);
  retract_root(&arg);
@


1.26.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 5
 * Revision 1.26.1.2  1997/05/21  13:18:55  daveb
 * [Bug #30142]
 * Changed the type of a dir_handle in DIRSTREAM from an int to a Word32.word ref,
 * because these values aren't always aligned on Windows 95.
 *
@


1.26.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 5
 * Revision 1.26.1.2  1997/05/21  13:18:55  daveb
 * [Bug #30142]
 * Changed the type of a dir_handle in DIRSTREAM from an int to a Word32.word ref,
 * because these values aren't always aligned on Windows 95.
 *
@


1.26.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 5
 * Revision 1.26.1.2  1997/05/21  13:18:55  daveb
 * [Bug #30142]
 * Changed the type of a dir_handle in DIRSTREAM from an int to a Word32.word ref,
 * because these values aren't always aligned on Windows 95.
 *
@


1.26.1.2.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 3
 * Revision 1.26.1.2.1.1  1997/07/28  18:29:08  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25
log
@whoops, correcting previous bug numeber from 1431 -> 1968
@
text
@d13 3
d471 2
a472 1
  DWORD moveMethod = (meth == 0) ? FILE_BEGIN : FILE_END;
@


1.24
log
@[Bug #1431]
Have to fix stdIN, stdOut and stdErr on every image load.
@
text
@d13 4
@


1.23
log
@[Bug #1940]
Modify fullPath to raise OS.SysErr if the file/dir doesn't exist
@
text
@d13 4
d200 25
a224 3
static mlval win32_std_in;
static mlval win32_std_out;
static mlval win32_std_err;
a1199 2
  win32_std_in = MLINT(GetStdHandle(STD_INPUT_HANDLE));
  env_value("system io standard input", win32_std_in);
d1201 22
a1222 2
  win32_std_out = MLINT(GetStdHandle(STD_OUTPUT_HANDLE));
  env_value("system io standard output", win32_std_out);
a1223 2
  win32_std_err = MLINT(GetStdHandle(STD_ERROR_HANDLE));
  env_value("system io standard error", win32_std_err);
@


1.22
log
@Prevented reg_query_value from raising an exception.
@
text
@d13 3
d739 10
@


1.22.4.1
log
@branched from 1.22
@
text
@a12 3
 * Revision 1.22  1996/11/22  14:21:41  daveb
 * Prevented reg_query_value from raising an exception.
 *
@


1.22.3.1
log
@branched from 1.22
@
text
@a12 3
 * Revision 1.22  1996/11/22  14:21:41  daveb
 * Prevented reg_query_value from raising an exception.
 *
@


1.22.3.1.1.1
log
@branched from 1.22.3.1
@
text
@a12 3
 * Revision 1.22.3.1  1996/12/17  17:53:57  hope
 * branched from 1.22
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a12 3
 * Revision 1.22  1996/11/22  14:21:41  daveb
 * Prevented reg_query_value from raising an exception.
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a12 3
 * Revision 1.22  1996/11/22  14:21:41  daveb
 * Prevented reg_query_value from raising an exception.
 *
@


1.21
log
@[Bug #1701]
mlw_os_process_getenv: remove redundant calls to declare/retract_root.
@
text
@d13 4
a18 1
 * [Bug #1426]
a320 6
    exn_raise_syserr(mlw_win32_strerror(result), (result<<1));

/* datasize here INCLUDES the NULL character at the end of the string */
  datas = allocate_string(datasize);
  result = RegQueryValueEx(hkey, valuename, NULL, NULL, CSTRING(datas), &datasize);
  if (result) {
d322 10
a331 2
  } else {
    return datas;
a332 1

@


1.21.1.1
log
@branched from 1.21
@
text
@a12 4
 * Revision 1.21  1996/10/28  10:54:59  stephenb
 * [Bug #1701]
 * mlw_os_process_getenv: remove redundant calls to declare/retract_root.
 *
@


1.21.1.1.1.1
log
@branched from 1.21.1.1
@
text
@a12 3
 * Revision 1.21.1.1  1996/11/14  12:57:47  hope
 * branched from 1.21
 *
@


1.20
log
@[Bug #1426]
[Bug #1426]
Replaced Win32 environment with Windows registry.
@
text
@d13 5
d994 1
a994 6
    mlval tagged_value= ml_string(value);
    mlval some_value;
    declare_root(&tagged_value);
    some_value= mlw_option_make_some(tagged_value);
    retract_root(&tagged_value);
    return some_value;		/* SOME value */
@


1.19
log
@[Bug #1554]
Reimplement OS.IO.kind
@
text
@d13 4
a145 1

d219 10
a228 1
static mlval win32_environment(mlval unit)
d230 17
a246 2
  mlval result = MLNIL;
  int i;
d248 52
a299 11
  declare_root(&result);
  
  for(i=0; environ[i] != NULL; ++i) {
    mlval poo = ml_string(environ[i]);
    /* Do not inline this function call */
    /* C is to stupid to realise that it should evaluate parameters */
    /* before building the arguments to a function */
    result = cons(poo, result);
  }
  retract_root(&result);
  return(result);
d302 21
d324 1
d326 1
a1087 1

a1154 2


d1167 21
a1187 1
  env_function("system os win32 environment", win32_environment);
d1228 6
@


1.19.3.1
log
@branched from 1.19
@
text
@a12 4
 * Revision 1.19  1996/08/22  12:00:39  stephenb
 * [Bug #1554]
 * Reimplement OS.IO.kind
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a12 4
 * Revision 1.19  1996/08/22  12:00:39  stephenb
 * [Bug #1554]
 * Reimplement OS.IO.kind
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a12 4
 * Revision 1.19  1996/08/22  12:00:39  stephenb
 * [Bug #1554]
 * Reimplement OS.IO.kind
 *
@


1.18
log
@win32_open: change the mode to FILE_SHARE_READ|FILE_SHARE_WRITE so
that it is possible to open the same file as input and output.
This feature is used by test_suite/basis/os_io.sml to test out
the OS.IO stuff.
@
text
@d13 6
d124 3
a126 5
#if !defined(_WIN32) && !defined(WIN32)
#include <ver.h>
#endif
#include <assert.h>
#include <io.h>			/* access */
d128 2
a129 2
#include <sys/types.h>		/* _fstat */
#include <sys/stat.h>		/* _fstat */
d164 1
a164 1
 * SysErr exception is defined in MLWorks.Internal and has the type
d166 2
a167 1
 *   exception SysError of int Option.option
d171 1
a171 3
 * This could be altered, but it would require having two SysErr exceptions.
 *
 * Therefore the solution adopted for Win32 is to squeeze both types of error
d239 1
d242 5
a246 2
  DWORD access = (acc == 0) ? GENERIC_READ : (acc == 1) ? GENERIC_WRITE
    : (acc == 2) ? GENERIC_READ | GENERIC_WRITE : GENERIC_READ;
d249 1
a249 1
  HANDLE file_handle = CreateFile(CSTRING(FIELD(argument, 0)), access, mode,
d251 2
a252 1
  if (file_handle == INVALID_HANDLE_VALUE) {
d254 2
a255 4
    return (MLUNIT); /* NOT REACHED */
  } else {
    return (MLINT(file_handle));
  }
d260 4
a263 1

d266 4
a269 2
  CloseHandle((HANDLE)(CINT(argument)));
  return (MLUNIT);
d273 2
d278 3
a280 3
 * called. This will change if ever I figure out how to do nonblocking IO */

static mlval win32_can_input(mlval argument)
d282 2
a283 2
 mlw_raise_win32_syserr();
 return(MLINT(0));
a304 1
    return (MLUNIT); /* NOT REACHED */
d318 4
a321 6
  if (WriteFile(file_handle, buffer + first, bytes_to_write, &bytes_written, NULL) == TRUE) {
    return (MLINT(bytes_written));
  } else {
    mlw_raise_win32_syserr();
    return (MLUNIT); /* NOT REACHED */
  }
d327 3
d337 1
a337 1
  if (result == 0xffffffff) {
a338 1
  };
d373 1
a373 1
 * to ensure that if they aren't, we here about it quickly.
d910 16
d934 5
d947 1
d950 1
d953 1
a953 1
    return isatty(io_desc) ? MLINT(4) : MLINT(1);
d955 1
a955 1
    return MLINT(2);
d957 1
a957 1
    return MLINT(5);
d959 1
a959 1
    return MLINT(7);
d968 29
d1112 2
@


1.17
log
@mlw_os_error_msg: remove a debugging printf left over from
when this was originally being implemented.
@
text
@d13 4
d241 1
a241 1
  DWORD mode = FILE_SHARE_READ;
@


1.16
log
@Removing system-specific information from the names of the calls
to read, write, seek and close.
@
text
@d13 4
d133 1
a133 1
#include <stdio.h>
a200 1
  printf("ERROR_CODE_BIT = %d\n", error_code&0x1);
@


1.15
log
@Debugging code of the win32 size and seek routines,
and adding handles for standard in, standard out and standard error
streams.
@
text
@d13 5
d255 12
d320 1
a320 1
  return (MLUNIT);
d995 1
d999 1
a999 1
  env_value("system os win32 standard in", win32_std_in);
d1002 1
a1002 1
  env_value("system os win32 standard out", win32_std_out);
d1005 1
a1005 1
  env_value("system os win32 standard err", win32_std_err);
a1009 4
  env_function("system os win32 close", win32_close);
  env_function("system os win32 write", win32_write);
  env_function("system os win32 read", win32_read);
  env_function("system os win32 seek", win32_seek);
d1011 6
@


1.14
log
@Fix #1456 - add declare/retract roots where necessary.
@
text
@d13 3
d124 1
a124 1

d166 5
d225 1
d228 1
d231 1
a231 1
				  NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
d295 2
a296 1
  HANDLE file_handle = (HANDLE)(FIELD(argument, 0));
d298 3
a300 2
  DWORD result = SetFilePointer(file_handle, newPos, NULL, FILE_BEGIN);
  if (result = 0xffffffff) {
d310 1
a310 1
  HANDLE file_handle = (HANDLE)argument;
a321 1

d980 10
@


1.13
log
@Add support for OS.FileSys.{setTime,isDir}.
@
text
@d13 3
d304 1
a304 1
    exn_raise_syserr("File To Large", 0);
d321 6
d356 3
d367 1
d392 3
a394 1
    mlval ml_file_name= ml_string(file_data.cFileName);
d397 1
d404 1
d428 2
d431 1
d433 1
d565 1
a565 1
 * broque.
d600 1
d615 6
a620 1
  (void)FindClose(file_handle);
d642 1
a642 1
    exn_raise_syserr("File To Large", 0);
d645 6
a650 1
  (void)FindClose(file_handle);
@


1.12
log
@Change the filename part of the dirstream type to be a ref.
This is because it the filename is updated by the runtime and without
going via a ref, the GC gets confused.  Updated the OS.FileSys.*Dir
routines accordingly.
@
text
@d13 6
d116 1
a116 1
#include "time_date.h"
d523 15
d624 24
d956 1
d959 1
d961 1
a961 1
  env_function("OS.FileSys.modTime",   mlw_os_file_sys_mod_time);
@


1.11
log
@Reimplement the OS.FileSys.{open,read,rewind,close}Dir runtime
routines so that they support the semantics defined in the
March 1996 basis revision.
@
text
@a202 45
#if 0

static mlval win32_find_first_file (mlval arg)
{
  LPCTSTR name = CSTRING (arg);
  WIN32_FIND_DATA data;
  HANDLE handle = FindFirstFile (name,&data);
  mlval mlname,result;
  if (handle == INVALID_HANDLE_VALUE)
    mlw_raise_win32_syserr();
  mlname = allocate_string (strlen (data.cFileName)+1);
  strcpy (CSTRING (mlname),data.cFileName);
  declare_root (&mlname);
  result = allocate_record (2);
  retract_root (&mlname);
  FIELD (result,0) = mlname;
  FIELD (result,1) = (mlval)handle;
  return (result);
}



static mlval win32_find_next_file (mlval arg)
{
  WIN32_FIND_DATA data;
  HANDLE handle = (HANDLE)arg;
  mlval result;
  if (!FindNextFile(handle,&data))
    mlw_raise_win32_syserr();
  result = allocate_string (strlen (data.cFileName)+1);
  strcpy (CSTRING (result),data.cFileName);
  return result;
}



static mlval win32_find_close (mlval arg)
{
  if (!FindClose ((HANDLE)arg))
    mlw_raise_win32_syserr();
  return (MLUNIT);
}


#endif
d319 5
d327 1
d333 1
a333 1
  LPCTSTR dir_name = CSTRING(arg);
d335 1
a336 1
  mlval ml_file_name, dirstream;
d342 2
a343 1
  declare_root(&ml_file_name);
d347 2
a348 12
  mlw_dirstream_file_name(dirstream)= ml_file_name;
  retract_root (&ml_file_name);

#if 0
  printf("OPENDIR dirstream=%x\n", dirstream);
  printf("HEADER %x = %x\n", (mlval *)dirstream-5, GETHEADER(dirstream));
  printf("NFIELDS= %d\n", NFIELDS(dirstream));
  printf("DIRNAME %x = %x (%s)\n", &mlw_dirstream_dir_name(dirstream), mlw_dirstream_dir_name(dirstream), CSTRING(mlw_dirstream_dir_name(dirstream)));
  printf("HANDLE %x = %x\n", &mlw_dirstream_dir_handle(dirstream), mlw_dirstream_dir_handle(dirstream));
  printf("FILENAME %x = %x (%s)\n", &mlw_dirstream_file_name(dirstream), mlw_dirstream_file_name(dirstream), CSTRING(mlw_dirstream_file_name(dirstream)));
#endif

a362 9
#if 0
  printf("OPENDIR dirstream=%x\n", arg);
  printf("HEADER %x = %x\n", (mlval *)arg-5, GETHEADER(arg));
  printf("NFIELDS= %d\n", NFIELDS(arg));
  printf("DIRNAME %x = %x (%s)\n", &mlw_dirstream_dir_name(arg), mlw_dirstream_dir_name(arg), CSTRING(mlw_dirstream_dir_name(arg)));
  printf("HANDLE %x = %x\n", &mlw_dirstream_dir_handle(arg), mlw_dirstream_dir_handle(arg));
  printf("FILENAME %x = %x (%s)\n", &mlw_dirstream_file_name(arg), mlw_dirstream_file_name(arg), CSTRING(mlw_dirstream_file_name(arg)));
#endif

d369 1
a369 1
    result= mlw_dirstream_file_name(arg);
d371 1
a371 1
      mlw_dirstream_file_name(arg)= ml_string(NULL);
d374 2
a375 2
    result= mlw_dirstream_file_name(arg);
    mlw_dirstream_file_name(arg)= ml_file_name;
d406 1
a406 1
  mlw_dirstream_file_name(arg)= ml_string(file_data.cFileName);
d420 1
@


1.10
log
@Add more functions to support the latest revised basis definition.
@
text
@d13 3
d203 1
d247 2
d347 140
d627 1
a627 2
  mod_time= mlw_time_make(file_data.ftLastWriteTime.dwHighDateTime,
			  file_data.ftLastWriteTime.dwLowDateTime);
a948 3
  env_function("system os win32 find_first_file", win32_find_first_file);
  env_function("system os win32 find_next_file", win32_find_next_file);
  env_function("system os win32 find_close", win32_find_close);
d960 15
a974 11
  env_function("OS.FileSys.chDir",    mlw_os_file_sys_ch_dir);
  env_function("OS.FileSys.getDir",   mlw_os_file_sys_get_dir);
  env_function("OS.FileSys.mkDir",    mlw_os_file_sys_mk_dir);
  env_function("OS.FileSys.rmDir",    mlw_os_file_sys_rm_dir);
  env_function("OS.FileSys.fullPath", mlw_os_file_sys_full_path);
  env_function("OS.FileSys.fileSize", mlw_os_file_sys_file_size);
  env_function("OS.FileSys.modTime",  mlw_os_file_sys_mod_time);
  env_function("OS.FileSys.remove",   mlw_os_file_sys_remove);
  env_function("OS.FileSys.rename",   mlw_os_file_sys_rename);
  env_function("OS.FileSys.access",   mlw_os_file_sys_access);
  env_function("OS.FileSys.tmpName",  mlw_os_file_sys_tmp_name);
@


1.9
log
@Add support for OS.errorName, OS.syserror and OS.errorMsg
@
text
@d3 6
a8 6
 * A misc. collection of Win32 routines needed to support various libraries.
 * For historic reasons most of the functions are prefixed by win32_, but
 * there is a rolling program to change the prefix to mlw_ to avoid any
 * namespace collision problems.  Note that the change isn't strictly
 * necessary for static functions/values but for consistency these should
 * have the mlw_ prefix too.
d13 3
d93 6
d107 2
a109 3
#include "time_date.h"
#include <stdlib.h>
#include "os_errors.h"		/* mlw_os_strerror, mlw_os_syserror ... etc. */
d111 39
d151 1
a151 1
static void win32_error()
d154 7
a160 1
  exn_raise_syserr(mlw_os_strerror(i), i);
d164 1
d170 7
a176 2
  DWORD error_code= CWORD(arg);
  return ml_string(mlw_os_strerror(error_code));
a199 35
#define MAXPATHLEN 1023
static mlval win32_getcd(mlval unit)
{
  char buffer[MAXPATHLEN+1];
  DWORD status = GetCurrentDirectory(MAXPATHLEN, buffer);

  if(status == 0)
    win32_error();

  return(ml_string(buffer));
}

static mlval win32_setcd(mlval arg)
{
  if (!SetCurrentDirectory(CSTRING (arg)))
    win32_error();
  return (MLUNIT);
}



static mlval win32_getpathname(mlval filename)
{
  char buffer[MAXPATHLEN+1];
  char *final_name;
  DWORD status = GetFullPathName(CSTRING(filename), MAXPATHLEN, buffer, &final_name);

  if(status == 0)
    win32_error();
  if (status > MAXPATHLEN)
    win32_error();
  return(ml_string(buffer));
}


d208 1
a208 1
    win32_error();
d227 1
a227 1
    win32_error();
d238 1
a238 1
    win32_error();
d253 1
a253 1
    win32_error();
d262 1
d271 1
d287 1
a287 1
    win32_error();
d294 1
d305 1
a305 1
    win32_error();
d312 1
d319 1
a319 1
    win32_error();
d331 1
a331 1
    win32_error();
d343 126
d479 1
a479 1
    win32_error();
d502 1
a502 1
    win32_error();
d514 130
d648 1
a648 1
static mlval win32_exit(mlval exit_code)
d660 1
a660 1
static mlval win32_system(mlval arg)
d665 1
a665 1
    win32_error();
a670 17
/* Some wrappers to abstract away the details of the Option type.
 * These could probably go somewhere more generic.
 */

#define mlw_make_option_none() MLINT(0)
#define mlw_option_isnone(opt) (opt == MLINT(0))
#define mlw_option_some(opt) FIELD(opt, 1)

static mlval mlw_make_option_some(mlval arg)
{
  mlval some= allocate_record(2);
  FIELD(some, 0)= MLINT(1);
  FIELD(some, 1)= arg;
  return arg;
}


d674 3
d678 1
a678 1
static mlval win32_getenv(mlval arg)
d683 1
a683 1
    return mlw_make_option_none();
d688 1
a688 3
    some_value= allocate_record(2);
    FIELD(some_value, 0)= MLINT(1);
    FIELD(some_value, 1)= tagged_value;
d697 1
d699 1
a699 1
 * OS.IO.kind : io_desc -> iodesc_kind
d702 5
a706 1
 * XXX: implement!
d711 16
a726 2
  exn_raise_syserr("OS.IO.kind: unknown io_desc kind", 0);
  return MLUNIT;		/* keep dumb compilers happy */
d800 1
a803 3
  env_function("system os win32 getcd", win32_getcd);
  env_function("system os win32 setcd", win32_setcd);
  env_function("system os win32 get_path_name", win32_getpathname);
d818 5
a822 2
  env_function("OS.IO.kind",     mlw_os_io_kind);

d825 10
a834 4

  env_function("system os exit",   win32_exit);
  env_function("system os system", win32_system);
  env_function("system os getenv", win32_getenv);
@


1.8
log
@Add support for Time and OS.IO
@
text
@d13 3
d101 1
a101 1

d107 11
a117 1
  exn_raise_syserr("Error", i);
d528 4
@


1.7
log
@Adding launch process with priority.
@
text
@d1 1
a1 1
/*  ==== PERVASIVE NT FUNCTIONS ====
d3 6
a8 1
 *  Copyright (C) 1994 Harlequin Ltd
d13 3
a94 1
#include "dde_lib.h"
d96 1
d104 1
a104 1
  exn_raise_syserr("Error", MLINT(i));
d289 1
a289 1
  if (size == 0xffffffff) {
d291 52
a342 4
    return (MLUNIT); /* NOT REACHED */
  } else {
    return MLINT(size);
  }
d347 4
d359 4
d374 17
d392 3
d400 1
a400 1
    return MLINT(0);		/* NONE */
d413 20
d499 1
d515 7
a521 1
  env_function("system os exit", win32_exit);
d524 1
a525 2

  dde_init();
@


1.6
log
@Add various routines to support OS.Process.
@
text
@d8 3
d329 64
d413 2
@


1.5
log
@Adding dde_init() call ...
@
text
@d8 3
d288 40
d343 3
a345 1

@


1.4
log
@Rationalise the exception handling so that all the routines that
raise exceptions raise one that is compatible with Os.SysErr as
defined in the latest basis.
@
text
@d8 5
d81 2
d300 2
@


1.3
log
@Adding set wd.
@
text
@d8 3
a77 1
static mlval win32_exn_ref_Win32;
d79 8
a86 1
#define SOCKADDR_BUFFER		sizeof(struct sockaddr_un)
d106 1
d114 1
a114 1
    exn_raise_string(perv_exn_ref_io, buffer);
d122 1
a122 1
    exn_raise_format (perv_exn_ref_io, "Can't set current directory to %d", CSTRING (arg));
d126 2
d135 1
a135 1
    exn_raise_string(perv_exn_ref_io, buffer);
d137 1
a137 1
    exn_raise_string(perv_exn_ref_io, buffer); /* Buffer too small */
d141 2
d150 1
a150 1
    exn_raise_int (win32_exn_ref_Win32,GetLastError());
d161 2
d169 1
a169 1
    exn_raise_int (win32_exn_ref_Win32,GetLastError());
d175 2
d180 1
a180 1
    exn_raise_int (win32_exn_ref_Win32,GetLastError());
d184 2
d195 1
a195 2
    exn_raise_format(perv_exn_ref_io,
		     "File create failed with error code %d", GetLastError());
d202 2
d210 2
d227 1
a227 2
    exn_raise_format(perv_exn_ref_io,
		     "File read failed with error code %d", GetLastError());
d232 2
d244 1
a244 2
    exn_raise_format(perv_exn_ref_io,
		     "File write failed with error code %d", GetLastError());
d249 2
d257 1
a257 2
    exn_raise_format(perv_exn_ref_io,
		     "File seek failed with error code %d", GetLastError());
d262 2
d269 1
a269 2
    exn_raise_format(perv_exn_ref_io,
		     "File size failed with error code %d", GetLastError());
d276 2
a292 5

  win32_exn_ref_Win32 = ref(exn_default);
  env_value("system os win32 exception Win32", win32_exn_ref_Win32);
  declare_global("system os win32 exception Win32", &win32_exn_ref_Win32,
		 GLOBAL_DEFAULT, NULL, NULL, NULL);
@


1.2
log
@Add support for osprimio in revised initial basis
@
text
@d8 3
d109 7
d255 1
@


1.1
log
@new unit
This used to be src/rts/src/OS/common/win32.c
@
text
@d7 5
a11 1
 *  $Log: src:OS:common:win32.c,v $
d69 1
d156 84
d249 6
@
