head	1.3;
access;
symbols
	MLW_daveb_inline_1_4_99:1.3.5
	MLWorks_21c0_1999_03_25:1.3
	MLWorks_20c1_1998_08_20:1.3
	MLWorks_20c0_1998_08_04:1.3
	MLWorks_20b2c2_1998_06_19:1.3
	MLWorks_20b2_Windows_1998_06_12:1.3
	MLWorks_20b1c1_1998_05_07:1.3
	MLWorks_20b0_1998_04_07:1.3
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_MM_adapt:1.3.4
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_workspace_97:1.3.3
	MLWorks_dt_wizard:1.3.2
	MLWorks_10r3:1.3.1.2.3
	MLWorks_10r2_551:1.3.1.2.2
	MLWorks_11:1.3.1.2.1
	MLWorks_1_0_r2c2_1997_07_28:1.3.1.2
	MLWorks_20m0_1997_06_20:1.3
	MLWorks_1_0_r2c2_1997_06_14:1.3.1.2
	MLWorks_1_0_r2c1_released_1997_05_23:1.3.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.3.1
	MLWorks_BugFix_1997_04_24:1.3
	MLWorks_1_0_r2_Win32_1997_04_11:1.3
	MLWorks_1_0_r2_Unix_1997_04_04:1.3
	MM_ML_release_korma_1997_04_01:1.3
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.1.7.1.1
	MLWorks_gui_1996_12_18:1.1.8
	MLWorks_1_0_Win32_1996_12_17:1.1.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.1.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.1.4.1
	JFHrts:1.1.6
	MLWorks_1_0_Irix_1996_11_28:1.1.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.1.5
	MLWorks_1_0_Unix_1996_11_14:1.1.4
	MLWorks_Open_Beta2_1996_10_11:1.1.3
	MLWorks_License_dev:1.1.2
	MLWorks_1_open_beta_1996_09_13:1.1.1
	MLWorks_Open_Beta_1996_08_22:1.1
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ * @;


1.3
date	97.03.07.11.16.49;	author stephenb;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1
	1.3.4.1
	1.3.5.1;
next	1.2;

1.2
date	96.12.18.11.55.08;	author stephenb;	state Exp;
branches;
next	1.1;

1.1
date	96.02.26.14.20.00;	author brianm;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.3.1
	1.1.4.1
	1.1.5.1
	1.1.6.1
	1.1.7.1
	1.1.8.1;
next	;

1.1.1.1
date	96.09.13.11.24.59;	author hope;	state Exp;
branches;
next	;

1.1.2.1
date	96.10.07.16.15.20;	author hope;	state Exp;
branches;
next	;

1.1.3.1
date	96.10.17.11.34.47;	author hope;	state Exp;
branches;
next	;

1.1.4.1
date	96.11.14.13.00.28;	author hope;	state Exp;
branches
	1.1.4.1.1.1;
next	;

1.1.4.1.1.1
date	96.11.28.15.10.30;	author hope;	state Exp;
branches;
next	;

1.1.5.1
date	96.11.22.18.18.18;	author hope;	state Exp;
branches;
next	;

1.1.6.1
date	96.12.17.10.05.00;	author hope;	state Exp;
branches;
next	;

1.1.7.1
date	96.12.17.17.56.36;	author hope;	state Exp;
branches
	1.1.7.1.1.1;
next	;

1.1.7.1.1.1
date	97.02.24.11.48.12;	author hope;	state Exp;
branches;
next	;

1.1.8.1
date	96.12.18.09.51.14;	author hope;	state Exp;
branches;
next	;

1.3.1.1
date	97.05.12.10.44.55;	author hope;	state Exp;
branches;
next	1.3.1.2;

1.3.1.2
date	97.06.10.13.47.17;	author stephenb;	state Exp;
branches
	1.3.1.2.1.1
	1.3.1.2.2.1
	1.3.1.2.3.1;
next	;

1.3.1.2.1.1
date	97.07.28.18.28.37;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.2.1
date	97.09.08.17.21.35;	author daveb;	state Exp;
branches;
next	1.3.1.2.2.2;

1.3.1.2.2.2
date	97.09.09.12.20.10;	author daveb;	state Exp;
branches;
next	;

1.3.1.2.3.1
date	97.09.09.14.17.40;	author daveb;	state Exp;
branches;
next	;

1.3.2.1
date	97.09.10.19.36.45;	author brucem;	state Exp;
branches;
next	;

1.3.3.1
date	97.09.11.21.04.55;	author daveb;	state Exp;
branches;
next	;

1.3.4.1
date	97.10.31.13.47.58;	author nickb;	state Exp;
branches;
next	;

1.3.5.1
date	99.04.01.18.03.41;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
Moved from architecture specific location.
@


1.3
log
@[Bug #1871]
open_symtab_file: removed the calls to printf(3).
get_export_symtab: removed the calls to exit(1).
@
text
@/*  ==== FOREIGN OBJECT LOADER ====
 *
 *  Copyright (C) 1995,1996,1997 Harlequin Ltd.
 *
 *  Implementation
 *  --------------
 *  This implementation provides dummy stubs for those ML ports
 *  where foreign object loading is not yet supported.  
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.2  1996/12/18  11:55:08  stephenb
 * [Bug #1868]
 * Change various uses of #if 1 -> #if 0 so that that code contained
 * by the #if is not run.  This stops various bits of debugging info
 * being displayed when a user calls a foreign function.
 *
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
 * Revision 1.5  1996/02/14  16:44:09  brianm
 * Minor corrections to check_big_endian function ...
 *
 * Revision 1.4  1996/02/14  16:16:56  brianm
 * New version - implementing Win32/WinNT support.
 *
 * Revision 1.3  1995/03/24  12:19:37  brianm
 * Adding prototypes due to modification of header file.
 * Simplified code to yield `unimplemented' exception.
 *
 * Revision 1.2  1995/03/08  15:01:22  brianm
 * Minor corrections.
 *
 * Revision 1.1  1995/03/01  10:54:56  brianm
 * new unit
 * Foreign Object loading routines
 *
 *
 */


#include "mltypes.h"
#include "allocator.h"
#include "values.h"
#include "diagnostic.h"
#include "exceptions.h"
#include "environment.h"
#include "words.h"
#include "foreign_loader.h"

#include <windows.h>

#if !defined(_WIN32) && !defined(WIN32)
#include <ver.h>
#endif

#include <stdio.h>
#include <string.h>
#include <stdlib.h>


/* Macros */

#define bit(a)                     (1u << (a))
#define bitblk(hi,lo)              (bit(hi) | (bit(hi) - bit(lo)))
#define appmask(x,m)               ((x) & (m))
#define rshift(x,lo)               ((unsigned)(x) >> (lo))
#define getbitblk(u,hi,lo)         (appmask(rshift((u),(lo)),bitblk(1+(hi) - (lo),0)))


/* Forward decls. of `exported' ML functions - (see foreign_init) */

static mlval load_foreign_object (mlval);
static mlval lookup_foreign_value (mlval);
static mlval call_unit_function (mlval);
static mlval call_foreign_function (mlval);

static mlval open_symtab_file (mlval);
static mlval next_symtab_entry (mlval);
static mlval close_symtab_file (mlval);

/* Local Procedure/Function stub decls. */

static mlval pack_foreign_value(void *);
static void  *unpack_foreign_value(mlval);


/* Definitions */

#define raise_error(str)   exn_raise_string(perv_exn_ref_value, (str))


/* Global variables */

static char errmsgbuf[BUFSIZ];


/* Code */

/* ==== <ML> load_foreign_object : (string * load_mode) -> foreign_object
 *
 *  Given a pathname (as a string), this dynamiclly links, using the
 *  specified load_mode, the executable object file and returns a
 *  foreign_object pointer.
 */
static mlval load_foreign_object(mlval argument)
{
   char      *path;
   unsigned  *handle;
   mlval     result;

   path = CSTRING(FIELD(argument,0));

   handle = (unsigned *)LoadLibrary(path);

   if (handle == NULL) {
     sprintf(errmsgbuf,"LoadLibrary failed : %i\n",  GetLastError());
     raise_error(errmsgbuf);
   };

   result = allocate_word32();
   num_to_word32((unsigned)handle,result);
 
   return(result);
}

/* ==== <ML> lookup_foreign_value : (foreign_object * string) -> foreign_value
 *
 *  Given a name (as a ML string) and a foreign object, this looks up
 *  the foreign value within the given foreign object.
 */
static mlval lookup_foreign_value(mlval arg)
{
   mlval fstruct, word;
   char *name;
   void *object;

   fstruct = FIELD(arg,0);
   name    = CSTRING(FIELD(arg,1));

   word    = FIELD(fstruct,2);

   object  = GetProcAddress((void *)word32_to_num(word),name);

   if (object == NULL) raise_error("Named value not found in object.\n");

   return(pack_foreign_value(object));
}

/* ==== <ML> call_unit_function : foreign_object -> unit
 *
 *  Calls a foreign unit function (included for testing purposes only).
 */
static mlval call_unit_function(mlval f_val)
{
   void (*f)(void);

   f = (void (*)(void))unpack_foreign_value(f_val);
   (*f)();

   return(MLUNIT);
}


/* ==== <ML> call_foreign_function : (function * memory * int * memory) -> unit
 *
 *  Calls a foreign function on a given array of (4 byte) argument values and
 *  returning a 4 byte value.  The integer argument specifies the number of
 *  arguments to be passed.
 */
static mlval call_foreign_function(mlval f_arg)
{
   void *ffun;
   void *argv;
   int argc;
   unsigned *result;
   int i;
   int *data;

   ffun     =      (void *)unpack_foreign_value(FIELD(f_arg, 0));
   argv     =      (void *)unpack_foreign_value(FIELD(f_arg, 1));
   argc     =              CINT(FIELD(f_arg, 2));
   result   =  (unsigned *)unpack_foreign_value(FIELD(f_arg, 3));

   data = argv;
   i=0;
#if 0
   printf("<C>call_foreign_function ... \n");

   printf("argv = %i = 0x%x\n",(int)argv,(unsigned)argv);
   printf("argc = %i\n", argc);
   
   for (i=0;i<argc;i++)
      printf("  ARG[ %i ] = %i = 0x%x\n",i,(int)data[i],(unsigned)data[i]);
#endif

   *result  =  (unsigned)call_ffun(ffun,argv,argc);

   return(MLUNIT);
}

extern mlval call_ffun_error(int argv)
{
   fprintf(stderr,"Too many args to foreign function:\n");
   fprintf(stderr,"Number of supplied args = %i (max: %i)\n",argv,MAX_FI_ARG_LIMIT);
   return(MLINT(0));
}


/* ==== <ML> check_big_endian : unit -> bool
 *
 *  Returns true for big_endian encoding 
 *
 */
static mlval check_big_endian (mlval argument)
{
   unsigned i = 1;
   char *bytes;

   bytes = (char *)&i;

   if (0 != bytes[3]) { return(MLTRUE); };

   return(MLFALSE);
}


/*  OS specific part : WinNT   */

/* Types */


typedef struct _export_entry {
    char     *Name;
    USHORT    Ordinal;
    ULONG    *Code;
} export_entry;

typedef struct _export_symtab {
    int Size;
    export_entry *Table;
} export_symtab;


/* Local Procedure/Function stub decls. */

static void cleanup_open_symtab (void);

static export_symtab *get_export_symtab (ULONG);
static ULONG section_size (IMAGE_SECTION_HEADER *);
static IMAGE_SECTION_HEADER *RVA_to_psection (ULONG);
static ULONG RVA_to_file_pointer (ULONG);

static char **get_name_table(int);


/* Definitions */

#define IMAGE_FILE    0
#define OBJECT_FILE   1
#define DOS_MAGIC     0x5a4d       /* DOS Magic number = "MZ" */


/* ==== Extracting a symbol table ====

   The following code produces a stream of strings
   extracted from an PE executable file as part of creating an ML version of the
   symbol table info.  However, to avoid complications with ML's GC, we
   need to avoid ML list creation within C.

   The idea is that we provide ML-usable routines for:

     - opening an PE format file.

     - getting the next symtab entry (as an ML string ...), returning
       the null string at the end.

     - closing the PE format file.

   and then ML uses these to generate an ML list from ML - which will
   then be GC-safe.  (Creating ML objects in C can invalidate mlval
   objects since the GC can move them around - suitable care is needed to
   make C copies of data.)

   To simplify the ML interface, some state is maintained in C for this.
   This means that only one executable file can be processed at a time.

Some details of the PE file format interface.
=============================================

Terminology:

   Image File
       An image file is produced from object files by the link-loader.  It will
       have various extra sections added and the RVA's computed for use in an
       image.  All external references will have been resolved and relocation
       information computed.

   Object File
       An object file is produced as output by a compiler and is generally
       incomplete i.e.  contains unresolved external references.  Also,
       various sections added by the linker will be absent (e.g. standard
       MS-DOS stub and header).

   Image Base
       The preferred address for loading the image into memory.  If loaded
       here, no fix-up relocations need be done.  Typical values are:

        -  0x10000  - Windows NT (Win32)
        - 0x400000  - DLL's and Win95 (i.e. Chicago) executables

   RVA
       Relative Virtual Address - an offset relative to some base address,
       **once the file has been memory-mapped**.  The base address could be
       Image Base or the base address of a section.

       RVA's dont in general correspond to file pointers, unfortunately, since
       sections are guaranteed to be aligned on page boundaries.   Also,
       within a file, sections are aligned on disk-sector boundaries.  This means
       that RVA's don't need adjusting once they are loaded into memory.

       Obtaining file pointers from RVA's (i.e. without memory-mapping) is
       therefore not entirely straightforward.  Fortunately, section headers
       contain both a file pointer (i.e. PointerToRawData) and a Virtual
       Address that represent the base address of each section.  This
       information can then be used to convert RVA's into a particular
       section into file positions.

   Virtual Address
       An address assuming that the image is loaded at the Image Base address.
       To convert this to an RVA, subtract the Image Base. 


References:

  - Microsoft Portable Executable and Common Object File Format Specification 4.1,
    (Revision 4.1, August 1994), Microsoft Corporation

  - The Portable Executable File Format from Top to Bottom,
    Randy Kath, Microsoft Corporation, June 1992.

  - Peering inside the PE : A Tour of the Win32 Portable Executable File Format,
    Matt Pietrek, MSJ, 1994, #3 (Mar)


*/


/**********************************/
/*                                */
/* SYMTAB READING STATE VARIABLES */
/*                                */
/**********************************/

static  FILE *file;                           /* Object file handle */
static  char *filename;                       /* File name */

static  int  sections      = -1;              /* No. of sections (= No. of headers) */
static  IMAGE_SECTION_HEADER    *sec_hdrs;    /* Section headers    */
static  export_symtab  *symtab;

static  long int entry          = -1;     /* Entry number    - (valid when +ve) */
static  long int entries        = -1;     /* No. of entries  - (valid when +ve) */


static mlval open_symtab_file(mlval argument)
{

   /* Local Variables */

   IMAGE_DOS_HEADER        dos_header;
   DWORD                   NT_sig;
   IMAGE_FILE_HEADER       coff_header;
   IMAGE_OPTIONAL_HEADER   opt_header;
   IMAGE_DATA_DIRECTORY    *pddirs;

   IMAGE_SECTION_HEADER    section;

   USHORT  coff_flags;
   ULONG  export_rva;

   int  i, opt_header_size;
   long NT_headers_offset;
   

   filename = CSTRING(argument);
   file = fopen(filename, "rb");  /* Opening binary file */ 

   if (file == NULL)
     return MLFALSE;

   if (fread(&dos_header, sizeof(IMAGE_DOS_HEADER), 1, file) != 1) {
     (void)fclose(file);
     return MLFALSE;
   }

   if (dos_header.e_magic != DOS_MAGIC) {
     (void)fclose(file);
     return MLFALSE;
   }

   NT_headers_offset =  dos_header.e_lfanew;

   if (fseek(file, NT_headers_offset, SEEK_SET)) {
     (void)fclose(file);
     return MLFALSE;
   }

   if (fread(&NT_sig, 4, 1, file) != 1) {
     fclose(file);
     return MLFALSE;
   }

   if (NT_sig != IMAGE_NT_SIGNATURE) {
     fclose(file);
     return MLFALSE;
   }

   /* Read COFF File Header */
   if (fread(&coff_header, sizeof(IMAGE_FILE_HEADER), 1, file) != 1) {
     fclose(file);
     return MLFALSE;
   }

   coff_flags = coff_header.Characteristics;
   if ((coff_flags & IMAGE_FILE_DLL) == 0) {
     fclose(file);
     return MLFALSE;
   }


   /* Get size of `optional' header */
   opt_header_size = coff_header.SizeOfOptionalHeader;

   if (opt_header_size <= 0) {
     fclose(file);
     return MLFALSE;
   }

   /* Read `optional' header */
   if (fread(&opt_header, opt_header_size, 1, file) != 1) {
     fclose(file);
     return MLFALSE;
   }

   /* Get pointer to Data Directories */
   pddirs = opt_header.DataDirectory;

   /* Get no. of sections */
   sections = coff_header.NumberOfSections;

   if (sections <= 0) {
     fclose(file);
     return MLFALSE;
   }

   /* Allocate space for section headers */
   sec_hdrs = (IMAGE_SECTION_HEADER *)malloc(sections * sizeof(IMAGE_SECTION_HEADER));

   /* Read in the section headers */
   for( i=0 ; i < sections; i++) {
     if (fread(&section, sizeof(IMAGE_SECTION_HEADER), 1, file) != 1) {
       fclose(file);
       cleanup_open_symtab();
       return MLFALSE;
     };

     sec_hdrs[i] = section;
   };

   /* Get the RVA for the export section */
   export_rva  = pddirs[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress;

   if (export_rva == (ULONG)NULL) {
     fclose(file);
     cleanup_open_symtab();
     return MLFALSE;
   };

   if ((symtab= get_export_symtab(export_rva)) == 0) {
     fclose(file);
     cleanup_open_symtab();
     return MLFALSE;
   }
   
   /* Initialisation completed */
   cleanup_open_symtab();

   /* Set Global Variables */
   entries = symtab -> Size;
   entry = 0;
   return MLTRUE;
}

static void cleanup_open_symtab(void)
{
   sections = entry = entries = -1;

   if (NULL != sec_hdrs) free(sec_hdrs);
}

static mlval next_symtab_entry(mlval argument)
{
  char strbuf[BUFSIZ];
  export_entry item;

  if ((entries >= 0) && (entry >= entries)) {
    return(ml_string(""));
  };

  item = (symtab -> Table)[entry];

  sprintf(strbuf,"%s c %d 0x%x", item.Name, item.Ordinal, item.Code);

  entry++;

  return(ml_string(strbuf));
}


static mlval close_symtab_file(mlval argument)
{

   fclose(file);      /* Close the file descriptor     */

   entry = entries = -1;

   free(symtab -> Table);
   free(symtab);

   return(MLUNIT);
}

static export_symtab *get_export_symtab (ULONG rva)
{
   IMAGE_SECTION_HEADER  *psecn;
   IMAGE_EXPORT_DIRECTORY  export_dir;

   export_entry  *table;

   char   **names;       /* Table of (char *)  */
   USHORT *ordinals;     /* Table of USHORT    */
   void   **codes;       /* Table of (void *)  */

   export_entry  entry;

   ULONG  secn_fp, export_fp, names_fp, anames_fp, ordinals_fp, codes_fp;
   ULONG  secn_rva, names_rva, anames_rva, ordinals_rva, codes_rva;

   int  i, entries;

   psecn = RVA_to_psection (rva);

   secn_rva = psecn -> VirtualAddress;     /* RVA of section          */
   secn_fp  = psecn -> PointerToRawData;   /* File pointer to section */

   export_fp = secn_fp + (rva - secn_rva);

   /* Seek to export section file pointer ... */
   if (fseek(file, export_fp, SEEK_SET))
     return (export_symtab *)0;

   /* ... and read the export directory structure */
   if (fread(&export_dir, sizeof(export_dir), 1, file) != 1)
     return (export_symtab *)0;

   entries = export_dir.NumberOfNames;

   table = (export_entry *)malloc(entries * sizeof(export_entry));

   names_rva  = (ULONG)export_dir.AddressOfNames;
   names_fp   = secn_fp + (names_rva - secn_rva);

   /* Names_fp now points at the ADDRESS of the actual RVA for the name table */
   fseek(file,names_fp,SEEK_SET);

   /* Read the actual names rva */
   fread(&anames_rva,sizeof(void *),1,file);

   /* Converting the actual names rva to a file pointer */
   anames_fp   = secn_fp + (anames_rva - secn_rva);
   fseek(file,anames_fp,SEEK_SET);

   if ((names= get_name_table(entries)) == (char **)0) {
     free(table);
     return (export_symtab *)0;
   }


   ordinals_rva  = (ULONG)export_dir.AddressOfNameOrdinals;
   ordinals_fp   = secn_fp + (ordinals_rva - secn_rva);

   fseek(file,ordinals_fp,SEEK_SET);
   ordinals = (USHORT *)malloc(entries * sizeof(USHORT));
   fread(ordinals,sizeof(USHORT),entries,file);

   codes_rva  = (ULONG)export_dir.AddressOfFunctions;
   codes_fp   = secn_fp + (codes_rva - secn_rva);

   fseek(file,codes_fp,SEEK_SET);
   codes = (void **)malloc(entries * sizeof(void *));
   fread(codes,sizeof(void *),entries,file);

   /* Transfer information to symtab */
   for (i=0; i < entries; i++) {
      entry.Name     = names[i];
      entry.Ordinal  = ordinals[i];
      entry.Code     = codes[i];
      table[i]       = entry;
   };

   free(codes);
   free(ordinals);
   free(names);

   symtab = (export_symtab *)malloc(sizeof(export_symtab));
   symtab -> Size  = entries;
   symtab -> Table = table;

   return symtab;
}


IMAGE_SECTION_HEADER *RVA_to_psection(ULONG rva)
{
    IMAGE_SECTION_HEADER *psecn;
    unsigned long secn_rva, secn_top;
    int i;

    for (i=0; i < sections; i++) {
       psecn = &sec_hdrs[i];
       secn_rva = psecn -> VirtualAddress;
       secn_top = secn_rva + section_size (psecn);
       if ((secn_rva <= rva) && (rva < secn_top))
         return(psecn);
    };

    return((IMAGE_SECTION_HEADER *)NULL);
}

ULONG section_size (IMAGE_SECTION_HEADER *psecn)
{
    return(psecn -> Misc.VirtualSize);
}

char **get_name_table(int num_str)
{
   char input[BUFSIZ];

   char **names;
   char *table;
   int i, j, size, first;
   long posn;

   if (num_str < 1)
     return ((char **)NULL);

   posn = ftell(file);

   /* Compute size of string table incl. terminating NULL's */
   size = 0;
   i = num_str;
   while (i > 0) {
       if (fscanf(file,"%s",input) == 1) {
	 i--;
	 size += strlen(input) + 1;
       } else {
	 return (char **)0;
       }
   }       


   /* Reset file pointer to beginning of string table */
   fseek (file,posn,SEEK_SET);

   /* Allocate heap memory and (re)read the string table into it */  
   table = (char *)malloc (size);
   fread ((void *)table,1,size,file);

   /* Create name table */
   names = (char **)malloc(num_str * sizeof(char *));

   /* Scan down string table, entering string ptrs into name table */
   first = 1;
   j = 0;
   for (i=0; j < num_str; i++) {
     if (first != 0) {
       names[j] = &table[i];
       j++;
     };
     first = (table[i] == 0);
   };

   return (names);
}



static mlval pack_foreign_value(void *ptr)
{
   mlval result;
   unsigned *object;

   result  = allocate_word32();

   object  = (unsigned *)CWORD32(result);
   *object = (unsigned)ptr;

#if 0
   printf("pack: pointer = (0x%x)\n",ptr);
   printf("pack: result = (0x%x)\n",result);
#endif
   
   return(result);
}

static void *unpack_foreign_value(mlval object)
{
   unsigned *ptr;

   ptr = (unsigned *)CWORD32(object);

#if 0
   printf("unpack: pointer = (0x%x)\n",*ptr);
#endif

   return((void *)*ptr);
}




void foreign_init(void)
{
  env_function("load foreign object",   load_foreign_object);
  env_function("lookup foreign value",  lookup_foreign_value);

  env_function("call unit function",    call_unit_function);
  env_function("call foreign function", call_foreign_function);

  env_function("open symtab file",  open_symtab_file);
  env_function("next symtab entry", next_symtab_entry);
  env_function("close symtab file", close_symtab_file);

  env_function("big endian flag", check_big_endian);
}
@


1.3.5.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 5
 * Revision 1.3  1997/03/07  11:16:49  stephenb
 * [Bug #1871]
 * open_symtab_file: removed the calls to printf(3).
 * get_export_symtab: removed the calls to exit(1).
 *
@


1.3.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 5
 * Revision 1.3  1997/03/07  11:16:49  stephenb
 * [Bug #1871]
 * open_symtab_file: removed the calls to printf(3).
 * get_export_symtab: removed the calls to exit(1).
 *
@


1.3.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 5
 * Revision 1.3  1997/03/07  11:16:49  stephenb
 * [Bug #1871]
 * open_symtab_file: removed the calls to printf(3).
 * get_export_symtab: removed the calls to exit(1).
 *
@


1.3.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 5
 * Revision 1.3  1997/03/07  11:16:49  stephenb
 * [Bug #1871]
 * open_symtab_file: removed the calls to printf(3).
 * get_export_symtab: removed the calls to exit(1).
 *
@


1.3.1.1
log
@branched from 1.3
@
text
@a12 5
 * Revision 1.3  1997/03/07  11:16:49  stephenb
 * [Bug #1871]
 * open_symtab_file: removed the calls to printf(3).
 * get_export_symtab: removed the calls to exit(1).
 *
@


1.3.1.2
log
@[Bug #50010]
get_name_table: replace the code that calculates the size of the
function name table -- it is completely broken.
@
text
@a12 3
 * Revision 1.3.1.1  1997/05/12  10:44:55  hope
 * branched from 1.3
 *
d653 1
a653 39



static void mlw_fl_skip_over_names(size_t n_names)
{
  size_t n_nulls= n_names+1;
  int c;
  
  while ((c= fgetc(file)) != EOF) {
    if ((c == '\0') && (--n_nulls == 0))
      return;
  }
  abort();			/* should never get here! */
}



/*
 * Returns the size of the strings section in bytes.
 * 
 * Assumes that the global `file' is positioned at the start of the strings
 * data, and leaves the `file' positioned at that point.
 *
 * Unlike ELF, PE doesn't seems to have a simple way of determing the
 * size of the strings in a strings table.  So, the following uses a 
 * brute force approach.  Each strings starts with a NUL and we know how
 * many strings there are, so scan along, counting the NUL characters
 * and when the last one has been read, the size is equal to the difference
 * in the file pointers.
 *
 * Note that it is assumed that there is at least one symbol in the file.
 * The code this is replacing was schizophrenic about this point.
 *
 * This is all rather hacky, but since this FI is not going into version 2.0
 * I'm not spending any time on making it clean (given the lack of checks
 * on return values elsewhere, it is unlikely to get this far if there 
 * really is something wrong).
 */
static int mlw_fl_strings_size(int num_str)
d655 1
a655 13
  long strings_start= ftell(file);
  long strings_end;
  int size;

  mlw_fl_skip_over_names(num_str);
  strings_end= ftell(file);
  size= (int)(strings_end - strings_start);
  fseek(file, strings_start, SEEK_SET);
  return size;
}



a656 2
char **get_name_table(int num_str)
{
d660 1
d665 17
a681 1
   size= mlw_fl_strings_size(num_str);
@


1.3.1.2.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 5
 * Revision 1.3.1.2  1997/06/10  13:47:17  stephenb
 * [Bug #50010]
 * get_name_table: replace the code that calculates the size of the
 * function name table -- it is completely broken.
 *
@


1.3.1.2.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 5
 * Revision 1.3.1.2  1997/06/10  13:47:17  stephenb
 * [Bug #50010]
 * get_name_table: replace the code that calculates the size of the
 * function name table -- it is completely broken.
 *
@


1.3.1.2.2.2
log
@[Bug #30260]
Added call to SearchPath in open_symtab_file.
@
text
@a12 3
 * Revision 1.3.1.2.2.1  1997/09/08  17:21:35  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
 *
a371 1
static  char pathname[MAX_PATH];              /* Full pathname of file */
d399 1
a399 2
   LPTSTR *file_offset = NULL;
   DWORD path_len;
d402 1
a402 6

   path_len = SearchPath(NULL, filename, NULL, MAX_PATH, pathname, file_offset);
   if (path_len == 0 || path_len >= MAX_PATH)
     return MLFALSE;

   file = fopen(pathname, "rb");  /* Opening binary file */ 
@


1.3.1.2.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 5
 * Revision 1.3.1.2  1997/06/10  13:47:17  stephenb
 * [Bug #50010]
 * get_name_table: replace the code that calculates the size of the
 * function name table -- it is completely broken.
 *
@


1.2
log
@[Bug #1868]
Change various uses of #if 1 -> #if 0 so that that code contained
by the #if is not run.  This stops various bits of debugging info
being displayed when a user calls a foreign function.
@
text
@d3 1
a3 1
 *  Copyright (C) 1995 Harlequin Ltd.
d13 6
d391 2
a392 4
   if (file == NULL) {
     fprintf(stderr, "Failed to find file `%s'\n", filename);
     return(MLFALSE);
   };
d395 3
a397 4
     fprintf(stderr, "Failed to read dos file header from '%s'\n", filename);
     fclose (file);
     return(MLFALSE);
   };
d400 3
a402 4
     fprintf(stderr, "File `%s' is not an MS-DOS executable.\n", filename);
     fclose(file);
     return(MLFALSE);
   }; 
d407 3
a409 4
     fprintf(stderr, "Failed to seek to image headers in '%s'\n", filename);
     fclose(file);
     return(MLFALSE);
   };
a411 1
     fprintf(stderr, "Failed to read NT header signature from '%s'\n", filename);
d413 2
a414 2
     return(MLFALSE);
   }; 
a416 1
     fprintf(stderr, "File `%s' is not a Windows executable in PE file format.\n", filename);
d418 2
a419 2
     return(MLFALSE);
   }; 
a422 1
     fprintf(stderr, "Failed to read COFF file header from '%s'\n", filename);
d424 2
a425 2
     return(MLFALSE);
   };
a428 1
     fprintf(stderr,"File `%s' is not a DLL.\n", filename);
d430 2
a431 2
     return(MLFALSE);
   };
d438 3
a440 4
       fprintf(stderr, "File `%s' doesn't possess an `optional' image header.\n", filename);
       fclose(file);
       return(MLFALSE);
   };
a443 1
     fprintf(stderr, "Failed to read optional image header from '%s'\n", filename);
d445 2
a446 2
     return(MLFALSE);
   };
a454 1
     fprintf(stderr, "File `%s' doesn't have any COFF sections.\n", filename); 
d456 2
a457 2
     return(MLFALSE);
   };
a464 1
       fprintf(stderr, "Failed to read section header from '%s'\n", filename);
d467 1
a467 1
       return(MLFALSE);
a476 1
     fprintf(stderr, "Duff export section RVA in file `%s'.\n", filename);
d479 1
a479 1
     return(MLFALSE);
d482 6
a487 2
   symtab = get_export_symtab(export_rva);

d494 1
a494 1
   return(MLTRUE);
d562 2
a563 5
   if (fseek(file, export_fp, SEEK_SET)) {
     fprintf(stderr, "Failed to seek to export section in '%s'\n", filename);
     fclose(file);
     exit(1);
   };
d566 2
a567 5
   if (fread(&export_dir, sizeof(export_dir), 1, file) != 1) {
      fprintf(stderr, "Failed to read export directory from '%s'\n", filename);
      fclose(file);
      exit(1);
   };
d586 5
a590 1
   names = get_name_table(entries);
d622 1
a622 1
   return( symtab );
d669 2
d672 1
a672 7
       else {
	 fprintf(stderr,"Failed reading string table in %s\n",filename);
	 fclose(file);
         cleanup_open_symtab();
         exit(1);
       };
   };          
@


1.1
log
@new unit
Moved from architecture specific location.
@
text
@d12 5
a16 1
 *  $Log: src:OS:NT:arch:I386:foreign_loader.c,v $
d183 1
a183 1
#if 1
d721 1
a721 1
#if 1
d735 1
a735 1
#if 1
@


1.1.8.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.7.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.7.1.1.1
log
@branched from 1.1.7.1
@
text
@a12 3
 * Revision 1.1.7.1  1996/12/17  17:56:36  hope
 * branched from 1.1
 *
@


1.1.6.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.5.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.4.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.4.1.1.1
log
@branched from 1.1.4.1
@
text
@a12 3
 * Revision 1.1.4.1  1996/11/14  13:00:28  hope
 * branched from 1.1
 *
@


1.1.3.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.2.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@


1.1.1.1
log
@branched from 1.1
@
text
@d12 1
a12 5
 *  $Log: src:OS:Win32:foreign_loader.c,v $
 * Revision 1.1  1996/02/26  14:20:00  brianm
 * new unit
 * Moved from architecture specific location.
 *
@
