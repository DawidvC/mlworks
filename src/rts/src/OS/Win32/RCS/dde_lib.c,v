head	1.7;
access;
symbols
	MLW_daveb_inline_1_4_99:1.7.1
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.6
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.3
	MLWorks_20m2_1998_02_16:1.3
	MLWorks_MM_adapt:1.3.3
	MLWorks_20m1_1997_10_23:1.3
	MLWorks_11r1:1.2.9.1.1.2.1
	MLWorks_workspace_97:1.3.2
	MLWorks_dt_wizard:1.3.1
	MLWorks_11c0_1997_09_09:1.2.9.1.1.2
	MLWorks_10r3:1.2.9.1.3
	MLWorks_10r2_551:1.2.9.1.2
	MLWorks_11:1.2.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.2.9.1
	MLWorks_20m0_1997_06_20:1.2
	MLWorks_1_0_r2c2_1997_06_14:1.2.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.2.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.2.9
	MLWorks_BugFix_1997_04_24:1.2
	MLWorks_1_0_r2_Win32_1997_04_11:1.2
	MLWorks_1_0_r2_Unix_1997_04_04:1.2
	MM_ML_release_korma_1997_04_01:1.2
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.2.7.1.1
	MLWorks_gui_1996_12_18:1.2.8
	MLWorks_1_0_Win32_1996_12_17:1.2.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.2.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.2.4.1
	JFHrts:1.2.6
	MLWorks_1_0_Irix_1996_11_28:1.2.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.2.5
	MLWorks_1_0_Unix_1996_11_14:1.2.4
	MLWorks_Open_Beta2_1996_10_11:1.2.3
	MLWorks_License_dev:1.2.2
	MLWorks_1_open_beta_1996_09_13:1.2.1
	MLWorks_Open_Beta_1996_08_22:1.2
	MLWorks_Beta_1996_07_02:1.1
	MLWorks_Beta_1996_06_07:1.1
	MLWorks_Beta_1996_06_06:1.1
	MLWorks_Beta_1996_06_05:1.1
	MLWorks_Beta_1996_06_03:1.1
	MLWorks_Beta_1996_05_31:1.1
	MLWorks_Beta_1996_05_30:1.1;
locks; strict;
comment	@ * @;


1.7
date	99.03.11.16.36.13;	author daveb;	state Exp;
branches
	1.7.1.1;
next	1.6;

1.6
date	98.03.30.15.13.55;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	98.03.27.18.57.24;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	98.03.23.16.06.36;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	97.07.15.15.50.15;	author johnh;	state Exp;
branches
	1.3.1.1
	1.3.2.1
	1.3.3.1;
next	1.2;

1.2
date	96.07.05.10.33.47;	author stephenb;	state Exp;
branches
	1.2.1.1
	1.2.2.1
	1.2.3.1
	1.2.4.1
	1.2.5.1
	1.2.6.1
	1.2.7.1
	1.2.8.1
	1.2.9.1;
next	1.1;

1.1
date	96.04.16.16.44.38;	author brianm;	state Exp;
branches;
next	;

1.2.1.1
date	96.09.13.11.25.48;	author hope;	state Exp;
branches;
next	;

1.2.2.1
date	96.10.07.16.16.18;	author hope;	state Exp;
branches;
next	;

1.2.3.1
date	96.10.17.11.35.38;	author hope;	state Exp;
branches;
next	;

1.2.4.1
date	96.11.14.13.01.15;	author hope;	state Exp;
branches
	1.2.4.1.1.1;
next	;

1.2.4.1.1.1
date	96.11.28.15.11.21;	author hope;	state Exp;
branches;
next	;

1.2.5.1
date	96.11.22.18.19.07;	author hope;	state Exp;
branches;
next	;

1.2.6.1
date	96.12.17.10.05.51;	author hope;	state Exp;
branches;
next	;

1.2.7.1
date	96.12.17.17.57.24;	author hope;	state Exp;
branches
	1.2.7.1.1.1;
next	;

1.2.7.1.1.1
date	97.02.24.11.49.08;	author hope;	state Exp;
branches;
next	;

1.2.8.1
date	96.12.18.09.52.05;	author hope;	state Exp;
branches;
next	;

1.2.9.1
date	97.05.12.10.47.05;	author hope;	state Exp;
branches
	1.2.9.1.1.1
	1.2.9.1.2.1
	1.2.9.1.3.1;
next	;

1.2.9.1.1.1
date	97.07.28.18.25.52;	author daveb;	state Exp;
branches;
next	1.2.9.1.1.2;

1.2.9.1.1.2
date	97.08.05.15.23.52;	author johnh;	state Exp;
branches
	1.2.9.1.1.2.1.1;
next	;

1.2.9.1.1.2.1.1
date	97.10.07.11.51.38;	author jkbrook;	state Exp;
branches;
next	;

1.2.9.1.2.1
date	97.09.08.17.19.07;	author daveb;	state Exp;
branches;
next	;

1.2.9.1.3.1
date	97.09.09.14.15.15;	author daveb;	state Exp;
branches;
next	;

1.3.1.1
date	97.09.10.19.32.11;	author brucem;	state Exp;
branches;
next	;

1.3.2.1
date	97.09.11.21.01.31;	author daveb;	state Exp;
branches;
next	;

1.3.3.1
date	97.10.31.13.44.28;	author nickb;	state Exp;
branches;
next	;

1.7.1.1
date	99.04.01.18.01.13;	author daveb;	state Exp;
branches;
next	;


desc
@new unit
New file.
@


1.7
log
@[Bug #190523]
Removed dde_send_request_string.
@
text
@/*  ==== DYNAMIC DATA EXCHANGE for Win32 ====
 *
 *  Copyright (C) 1996 Harlequin Ltd
 *
 *  Description
 *  -----------
 *  This provides some low-level support for DDE in MLworks.  This is
 *  likely to be replaced by a FI implementation.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:OS:Win32:dde_lib.c,v $
 * Revision 1.6  1998/03/30  15:13:55  jont
 * [Bug #70086]
 * Add a request function for use by the Windows structure
 *
 * Revision 1.5  1998/03/27  18:57:24  jont
 * [Bug #30090]
 * Fix further problem with perv_exn_ref_io (oops)
 *
 * Revision 1.4  1998/03/23  16:06:36  jont
 * [Bug #30090]
 * Replace use of MLWorks.IO.Io with syserr
 *
 * Revision 1.3  1997/07/15  15:50:15  johnh
 * [Bug #30124]
 * Add web location function for use by help menu.
 *
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
 * Revision 1.1  1996/04/16  16:44:38  brianm
 * new unit
 * New file.
 *
 * */

#include <windows.h>
#include <ddeml.h>
#include <time.h>
#include <math.h>
#include <shellapi.h>

#include "mltypes.h"
#include "allocator.h"
#include "environment.h"
#include "exceptions.h"
#include "values.h"
#include "tags.h"
#include "utils.h"
#include "words.h"
#include "gc.h"
#include "dde_lib.h"


/*   ==== DDE Interface ====

We provide some basic C-level operators 

     - start a DDE dialog
     - send a DDE execute string
     - stop a DDE dialog

This basic repertoire is the minimal required to set up an interface
to simple server applications accepting particular execute strings.

*/

#define TICKS_PER_MSEC    (CLOCKS_PER_SEC / 1000)  /* ticks per millisecond */

#define TIMEOUT_SYNC     500

#define POSNUM(x)  ((x > 0) ? x : 0)

/* ==== DDE info data type ==== */

typedef struct _dde_info {
   /* DDE Initialize parameters */
   DWORD         idInst;    
   PFNCALLBACK   callbackFn;
   DWORD         afCmd;

   /* DDE Connect conversation parameters */
   HSZ           hszService;
   HSZ           hszTopic;
   HCONV         hConv;
} dde_info;


/* ==== Utilities ==== */

static HSZ dde_string (DWORD, char *);
static void dde_error (DWORD, char *, char *);
static void dde_error_action (DWORD, char *, char *);
static mlval pack_dde_info (dde_info *);
static dde_info *unpack_dde_info (mlval);
static void pause (long int);
static void print_dde_info (dde_info *);

/* ==== `The' callback function ====
  
The DDE service supported here is restricted to:

  - standard (i.e non-monitoring)
  - client only
  - ignoring all notifications

Callbacks are used almost exclusively by DDE servers - there are only
a few occasions when a client needs to handle events via the callback
function.  Hence, we only need to deal with the following transaction
types:

  XTYP_ERROR
  - something went wrong ....

  XTYP_ADVDATA
  - data has been received from a server as part of
  a client request advise loop.  Such events result from
  data in the server having changed.

  Since we restrict clients not to enter advise loops, this cannot
  arise in any of our conversations - in any event, we return
  DDE_FNOTPROCESSED to reject the transaction.

  XTYPE_XACT_COMPLETE
  - asynchronous transaction has been completed.  But our clients cannot
  initiate asynchronous transactions - so we return 0.
*/

static HDDEDATA
       std_dde_callback_fn
          ( UINT     wType,
            UINT     wFmt,
            HCONV    hConv,
            HSZ      hsz1,
            HSZ      hsz2,
            HDDEDATA hData,
            DWORD    dwData1,
            DWORD    dwData2
          )
{
   switch (wType & XTYP_MASK) {
   case XTYP_ADVDATA       :
        return ( DDE_FNOTPROCESSED );

   case XTYP_XACT_COMPLETE : return (0);
        
   case XTYP_ERROR         :
        switch (dwData1 & 0xffff) {
        case DMLERR_LOW_MEMORY :
             exn_raise_syserr(ml_string("DML error - DDE running out of memory"), 0);
	default :
             exn_raise_syserr(ml_string("General DML error"), 0);
        };

   default : return(0);
   };
}


/* ==== Main definitions ==== */


static mlval start_dde_dialog (mlval arg)
{
   DWORD        idInst;
   HCONV        hConv;
   dde_info     *info;
   HSZ          serviceName, topicName;

   /* Allocate the DDE info */
   info = malloc(sizeof(dde_info));

   if (NULL == info)
     exn_raise_syserr(ml_string("start_dde_dialog : Couldn't allocate DDE info. object"), 0);

   info -> callbackFn = (PFNCALLBACK)std_dde_callback_fn;
   info -> afCmd =
        APPCLASS_STANDARD         |
        CBF_SKIP_ALLNOTIFICATIONS | 
        APPCMD_CLIENTONLY;

   idInst = 0;

   switch (DdeInitialize(&idInst,info -> callbackFn,info -> afCmd,0L)) {
   case DMLERR_NO_ERROR : break;

   case DMLERR_INVALIDPARAMETER :
        exn_raise_syserr (ml_string("start_dde_dialog : DdeInitialize - bad parameter"), DMLERR_INVALIDPARAMETER);

   case DMLERR_DLL_USAGE :
        exn_raise_syserr (ml_string("start_dde_dialog : DdeInitialize - DLL failed"), DMLERR_DLL_USAGE);

   case DMLERR_SYS_ERROR :
        exn_raise_syserr (ml_string("start_dde_dialog : DdeInitialize - system error"), DMLERR_SYS_ERROR);
   };

   info -> idInst = idInst;

   serviceName = dde_string( idInst,  CSTRING( FIELD(arg,0) ) );
   topicName   = dde_string( idInst,  CSTRING( FIELD(arg,1) ) );

   info -> hszService = serviceName;
   info -> hszTopic   = topicName;


   hConv = DdeConnect(idInst,serviceName,topicName,NULL);

   if ((HCONV)NULL == hConv)
     { dde_error (idInst, "start_dde_dialog", "DdeConnect"); };

   info -> hConv = hConv;

   return (pack_dde_info(info));
}


static mlval send_dde_execute_string (mlval arg)
{
   dde_info *info;
   char *cmd;
   long int busy_retry_delay, retry, busy_retry;

   HDDEDATA   result;
   HCONV      hConv;
   DWORD      idInst;
   DWORD      error;

   info             = unpack_dde_info(  FIELD(arg,0) );

   cmd              = CSTRING(          FIELD(arg,1) );
   retry            = CINT(             FIELD(arg,2) );
   busy_retry_delay = CINT(             FIELD(arg,3) );

   retry = POSNUM( retry );
   busy_retry_delay = POSNUM( busy_retry_delay );

   busy_retry = ((busy_retry_delay > 0) && (retry > 0)) ? 1 : 0;

   hConv = info -> hConv;
   idInst = info -> idInst;

   while (retry >= 0) {
      retry--;

      result = DdeClientTransaction (
		   (LPBYTE)cmd,  /* The command to be sent ...          */
		   strlen(cmd),  /* Size of the command                 */
		   hConv,        /* Conversation being used             */
		   0L,           /* handle to item name - not needed    */
		   0,            /* clipboard data format - not needed  */
		   XTYP_EXECUTE, /* Type of transaction */
		   TIMEOUT_SYNC, /* timeout                             */
		   NULL);        /* transaction result pointer - unused */

      if ((HDDEDATA)NULL != result) { retry = -1; }
      else
         { error = DdeGetLastError (idInst); 
	   switch ( error ) {
	   case DMLERR_BUSY :
	       if (1 == busy_retry && retry >= 0)
		  { pause(busy_retry_delay);
		    break;
		  };
	   default :
	       dde_error_action(error,"send_dde_execute_string","DdeClientTransaction");
	   };
         };
   };

   return MLUNIT;
}

static mlval stop_dde_dialog (mlval arg)
{
   dde_info   *info;
   HCONV      hConv;
   DWORD      idInst;

   info = unpack_dde_info( arg );

   hConv = info -> hConv;
   idInst = info -> idInst;


   if (FALSE == DdeDisconnect( hConv ))
       { dde_error( idInst,"stop_dde_dialog","DdeDisconnect"); };

   if (FALSE == DdeFreeStringHandle( idInst, info -> hszService ))
       { dde_error( idInst,"stop_dde_dialog","DdeFreeStringHandle"); };

   if (FALSE == DdeFreeStringHandle( idInst, info -> hszTopic ))
       { dde_error( idInst,"stop_dde_dialog","DdeFreeStringHandle"); };

   free( info );

   return ((mlval)MLUNIT );
}



/* 
 * netscape_dde_link:  Netscape is already running so use it to 
 *   show the specified web location.
 *
 *  Ddeinitialize;
 *  openURL = DdeConnect("netscape", "WWW_openURL");
 *  DdeClientTransaction(openURL, request, <http file to open>);
 *  activate = DdeConnect("netscape", "WWW_Activate");
 *  DdeClientTransaction(activate, request, "");
 *  return; 
 */

void netscape_dde_link(HCONV openConv, 
		       DWORD idInst, 
		       HSZ serviceName, 
		       const char filename[])
{
  HDDEDATA result;
  HSZ itemstr, topicName;
  HCONV actConv;
  char const activate_args[] = "0xFFFFFFFF,0x0";
  char open_url_args[MAX_PATH + 20];
    
  /* open_url_args stores the arguments that are passed to the DDE topic
   * WWW_OpenURL.  See netscape DDE documentation for more details.
   * The 0xFFFFFFFF value instructs Netscape to use the last active
   * window, and if there is no last active window, Netscape attempts
   * to create a new window.
   */
    
  sprintf(open_url_args, "%s,,0xFFFFFFFF,0x0,,,", filename); 
  itemstr = DdeCreateStringHandle(idInst, open_url_args, CP_WINANSI);
  if (itemstr == 0L) 
    dde_error(idInst, "open_web_location", "DdeCreateStringHandle");
  
  result = DdeClientTransaction((LPBYTE)NULL, 
				0, 
				openConv,       
				itemstr,     
				CF_TEXT,           
				XTYP_REQUEST,
				TIMEOUT_SYNC,
				NULL);       
  if ((HDDEDATA)NULL == result)
    dde_error(idInst, "open_web_location", "DdeClientTransaction");
  
  if (DdeFreeStringHandle(idInst, itemstr) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeDisconnect(openConv) == 0) 
    dde_error(idInst, "open_web_location", "DdeDisconnect");
  
  topicName = dde_string(idInst,"WWW_Activate");
  
  actConv = DdeConnect(idInst, serviceName, topicName, NULL);
  if (actConv == 0L)
    dde_error(idInst, "open_web_location", "DdeConnect");
  if (DdeFreeStringHandle(idInst, serviceName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeFreeStringHandle(idInst, topicName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  
  itemstr = DdeCreateStringHandle(idInst, activate_args, CP_WINANSI);
  if (itemstr == 0L) 
    dde_error(idInst, "open_web_location", "DdeCreateStringHandle");
  
  result = DdeClientTransaction((LPBYTE)NULL,
				0, 
				actConv,       
				itemstr,
				CF_TEXT,
				XTYP_REQUEST,
				TIMEOUT_SYNC,
				NULL);       
  if ((HDDEDATA)NULL == result)
    dde_error(idInst, "open_web_location", "DdeClientTransaction");
  
  if (DdeFreeStringHandle(idInst, itemstr) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeDisconnect(actConv) == 0) 
    dde_error(idInst, "open_web_location", "DdeDisconnect");      
  
  if (DdeUninitialize(idInst) == 0)
    exn_raise_syserr(ml_string("open_web_location: DdeUninitialize failed"), 0);
}



/* 
 * netscape_location:  tries to connect to a Netscape window which 
 *   is already running using dde commands, and if it fails it calls
 *   ShellExecute which either starts Netscape and displays the 
 *   specified web location or starts another web browser.
 */

void netscape_location(const char* filename)
{
  PFNCALLBACK callbackFn;
  DWORD       afCmd, idInst;
  HSZ         serviceName, topicName;
  HCONV       openConv;
  int         result;

  callbackFn = (PFNCALLBACK)std_dde_callback_fn;
  afCmd =
    APPCLASS_STANDARD         |
    CBF_SKIP_ALLNOTIFICATIONS | 
    APPCMD_CLIENTONLY;
  idInst = 0;
  
  result = DdeInitialize(&idInst, callbackFn, afCmd, 0L);  
  if (result != DMLERR_NO_ERROR)
    exn_raise_syserr(ml_string("open_web_location: DdeInitialize failed"), 0);
  
  serviceName = dde_string(idInst, "NETSCAPE");
  topicName   = dde_string(idInst, "WWW_OpenURL");
  
  openConv = DdeConnect(idInst, serviceName, topicName, NULL);

  if (DdeFreeStringHandle(idInst, topicName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");

  if ((HCONV)NULL == openConv) {
    /* Either Netscape doesn't exist or is not running, so can just use 
     * ShellExecute, which will either start Netscape manually or start 
     * another web browser, eg. MS Internet Explorer.
     */
    if (DdeUninitialize(idInst) == 0)
      exn_raise_syserr(ml_string("open_web_location: DdeUninitialize failed"), 0);
    if (((int)ShellExecute(0, "open", filename, 0, 0, SW_NORMAL)) <= 32) 
      dde_error(idInst, "open_web_location", "ShellExecute");
  } else {
    netscape_dde_link(openConv, idInst, serviceName, filename);
  }

}



/* 
 * open_web_location:  attempts to open a web browser at the specified location.
 * 
 * if Web Browser exists (FindExcecutable) then 
 *   call netscape_location(<name of html file to open>)
 * else  
 *   raise system error - browser could not be opened - why?
 *
 * return;
 */

static mlval open_web_location(mlval arg)
{
  char        ignored_exestr[MAX_PATH], *filename;
  int         result;

  filename = CSTRING(arg);

  /* if FindExecutable succeeds the return value is greater than 32,
   * otherwise it returns a value indicating the type of error it failed by.
   */
  if ((result = (int)FindExecutable(filename, "", ignored_exestr)) > 32)
    netscape_location(filename);
  else
    switch (result) {
    case 0:
      exn_raise_syserr(ml_string("The system is out of memory or resources"), 0);
      break;
    case 31:
      exn_raise_syserr(ml_string("There is no association for the specified file type"), 0);
      break;
    case ERROR_FILE_NOT_FOUND:
      exn_raise_syserr(ml_string("HTML file not found"), 0);
      break;
    case ERROR_PATH_NOT_FOUND:
      exn_raise_syserr(ml_string("HTML path not found"), 0);
      break;
    case ERROR_BAD_FORMAT:
      exn_raise_syserr(ml_string("HTML: bad exe format"), 0);
      break;
    default:
      exn_raise_syserr(ml_string("Loading html page: unknown error"), 0);      
    }
    
  return MLUNIT;
}

static HSZ dde_string (DWORD idInst, char *str)
{

   if (strlen(str) <= 0)
     { return((HSZ)0L); }
   else 
     return( DdeCreateStringHandle(idInst,str,CP_WINANSI) );
}

static void raise_dde_error (char *fn_name, char *lib_fn_name, char *msg)
{
  mlval error_string = format_to_ml_string("%s : %s - %s", fn_name, lib_fn_name, msg);
  exn_raise_syserr(error_string, 0);
}

static void dde_error_action ( DWORD error, char *fn_name, char *lib_fn )
{
    switch ( error ) {
    case DMLERR_ADVACKTIMEOUT :
      raise_dde_error(fn_name,lib_fn,"synch. advise transaction timed out");
      break;

    case DMLERR_BUSY :
      raise_dde_error(fn_name,lib_fn,"busy transaction flag set");
      break;

    case DMLERR_DATAACKTIMEOUT :
      raise_dde_error(fn_name,lib_fn,"synch. request transaction timed out");
      break;

    case DMLERR_DLL_NOT_INITIALIZED :
      raise_dde_error(fn_name,lib_fn,"DDEML not initialised");
      break;

    case DMLERR_EXECACKTIMEOUT :
      raise_dde_error(fn_name,lib_fn,"synch. execute transaction timed out");
      break;

    case DMLERR_INVALIDPARAMETER :
      raise_dde_error(fn_name,lib_fn,"bad parameter to library function (various causes)");
      break;

    case DMLERR_LOW_MEMORY :
      raise_dde_error(fn_name,lib_fn,"low memory (caused by server outrunning client)");
      break;

    case DMLERR_MEMORY_ERROR :
      raise_dde_error(fn_name,lib_fn,"memory allocation failed");
      break;

    case DMLERR_NO_CONV_ESTABLISHED :
      raise_dde_error(fn_name,lib_fn,"no conversation established");
      break;

    case DMLERR_NOTPROCESSED :
      raise_dde_error(fn_name,lib_fn,"transaction failed");
      break;

    case DMLERR_POKEACKTIMEOUT :
      raise_dde_error(fn_name,lib_fn,"synch. poke transaction timed out");
      break;

    case DMLERR_POSTMSG_FAILED :
      raise_dde_error(fn_name,lib_fn,"an internal call to PostMessage failed");
      break;

    case DMLERR_REENTRANCY :
      raise_dde_error(fn_name,lib_fn,"reentrant synch. transaction attempted");
      break;

    case DMLERR_SERVER_DIED :
      raise_dde_error(fn_name,lib_fn,"partner has died");
      break;

    case DMLERR_SYS_ERROR :
      raise_dde_error(fn_name,lib_fn,"internal DDEML system error");
      break;

    case DMLERR_UNADVACKTIMEOUT :
      raise_dde_error(fn_name,lib_fn,"request to terminate advise transaction timed out");
      break;

    case DMLERR_UNFOUND_QUEUE_ID :
      raise_dde_error(fn_name,lib_fn,"invalid transaction identifier passed to DDEML");
      break;
    };
}

static void dde_error (DWORD idInst, char *fn_name, char *lib_fn )
{
   dde_error_action (DdeGetLastError (idInst), fn_name, lib_fn);
}


static mlval pack_dde_info (dde_info *pinfo)
{
   mlval object;

   object = allocate_word32();
   num_to_word32((unsigned long)pinfo, object);

   return(object);
}

static dde_info *unpack_dde_info(mlval arg)
{
   dde_info *pinfo;

   pinfo = (dde_info *)word32_to_num(arg);
   return(pinfo);
}  


static void pause (long int time)
{
   clock_t stop;
   unsigned x = 0;

   if (0 == time) return;

   stop = clock() + (clock_t)ceil(time / TICKS_PER_MSEC);

   while (clock() < stop) { x = x++; };

}

static void print_dde_info(dde_info *info)
{
   DWORD idInst ;
   PFNCALLBACK callbackFn ;
   DWORD  afCmd ;

   HSZ     hszService ;
   HSZ     hszTopic ;
   HCONV   hConv ;

   idInst     = info -> idInst;
   callbackFn = info -> callbackFn;
   afCmd      = info -> afCmd;

   hszService = info -> hszService;
   hszTopic   = info -> hszTopic;
   hConv      = info -> hConv;

   printf("\nDDE Info object (0x%x)\n", (unsigned long)info);
   printf("  info -> idInst     = %i (0x%x)\n", (long)idInst, (unsigned long)idInst);
   printf("  info -> callbackFn = %i (0x%x)\n", (long)callbackFn, (unsigned long)callbackFn);
   printf("  info -> hszService = %i (0x%x)\n", (long)hszService, (unsigned long)hszService);
   printf("  info -> hszTopic   = %i (0x%x)\n", (long)hszTopic, (unsigned long)hszTopic);
   printf("  info -> hConv      = %i (0x%x)\n\n", (long)hConv, (unsigned long)hConv);

}

extern void dde_init(void)
{
  env_function("dde start dialog",         start_dde_dialog);
  env_function("dde send execute string",  send_dde_execute_string);
  env_function("dde stop dialog",          stop_dde_dialog);
  env_function("win32 open web location",  open_web_location);
}
@


1.7.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a12 4
 * Revision 1.7  1999/03/11  16:36:13  daveb
 * [Bug #190523]
 * Removed dde_send_request_string.
 *
@


1.6
log
@[Bug #70086]
Add a request function for use by the Windows structure
@
text
@d13 4
d218 1
a218 1
static mlval send_dde_command (mlval arg, DWORD type)
d252 1
a252 1
		   type,         /* Type of transaction */
a273 10
static mlval send_dde_execute_string (mlval arg)
{
  return send_dde_command(arg, XTYP_EXECUTE);
}

static mlval send_dde_request_string (mlval arg)
{
  return send_dde_command(arg, XTYP_REQUEST);
}

a643 1
  env_function("dde send request string",  send_dde_request_string);
@


1.5
log
@[Bug #30090]
Fix further problem with perv_exn_ref_io (oops)
@
text
@d13 4
d214 1
a214 1
static mlval send_dde_execute_string (mlval arg)
d248 1
a248 1
		   XTYP_EXECUTE, /* Type of transaction = execute       */
d267 11
a277 1
   return ( FIELD(arg,0) );
a492 9
extern void dde_init(void)
{
  env_function("dde start dialog",         start_dde_dialog);
  env_function("dde send execute string",  send_dde_execute_string);
  env_function("dde stop dialog",          stop_dde_dialog);
  env_function("win32 open web location",  open_web_location);
}


d644 9
@


1.4
log
@[Bug #30090]
Replace use of MLWorks.IO.Io with syserr
@
text
@d13 4
d42 1
d498 3
a500 2
{  
   exn_raise_strings(perv_exn_ref_io, fn_name, " : ", lib_fn_name, " - ", msg, NULL);
@


1.3
log
@[Bug #30124]
Add web location function for use by help menu.
@
text
@d13 4
a57 2
#define raise_io_exn(s)   exn_raise_string(perv_exn_ref_io,(s))

d138 1
a138 1
             raise_io_exn("DML error - DDE running out of memory");
d140 1
a140 1
             raise_io_exn("General DML error");
d162 1
a162 1
     raise_io_exn( "start_dde_dialog : Couldn't allocate DDE info. object");
d176 1
a176 1
        raise_io_exn ( "start_dde_dialog : DdeInitialize - bad parameter");
d179 1
a179 1
        raise_io_exn ("start_dde_dialog : DdeInitialize - DLL failed");
d182 1
a182 1
        raise_io_exn ("start_dde_dialog : DdeInitialize - system error");
d371 1
a371 1
    raise_io_exn("open_web_location: DdeUninitialize failed");
d400 1
a400 1
    raise_io_exn("open_web_location: DdeInitialize failed");
d416 1
a416 1
      raise_io_exn("open_web_location: DdeUninitialize failed");
@


1.3.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a12 4
 * Revision 1.3  1997/07/15  15:50:15  johnh
 * [Bug #30124]
 * Add web location function for use by help menu.
 *
@


1.3.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a12 4
 * Revision 1.3  1997/07/15  15:50:15  johnh
 * [Bug #30124]
 * Add web location function for use by help menu.
 *
@


1.3.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a12 4
 * Revision 1.3  1997/07/15  15:50:15  johnh
 * [Bug #30124]
 * Add web location function for use by help menu.
 *
@


1.2
log
@pack_dde_info: remove bogus declare_root
@
text
@d13 3
d26 1
d285 187
d477 1
d540 1
a540 1
     break;
@


1.2.9.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a12 3
 * Revision 1.2.9.1  1997/05/12  10:47:05  hope
 * branched from 1.2
 *
@


1.2.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a12 3
 * Revision 1.2.9.1  1997/05/12  10:47:05  hope
 * branched from 1.2
 *
@


1.2.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a12 3
 * Revision 1.2.9.1  1997/05/12  10:47:05  hope
 * branched from 1.2
 *
@


1.2.9.1.1.2
log
@[Bug #30124]
Merging - Help interface to documentation (Win32).
Add open_web_location function.
@
text
@a12 4
 *
 * Revision 1.2.9.1.1.1  1997/07/28  18:25:52  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
a28 1
#include <shellapi.h>
a286 187


/* 
 * netscape_dde_link:  Netscape is already running so use it to 
 *   show the specified web location.
 *
 *  Ddeinitialize;
 *  openURL = DdeConnect("netscape", "WWW_openURL");
 *  DdeClientTransaction(openURL, request, <http file to open>);
 *  activate = DdeConnect("netscape", "WWW_Activate");
 *  DdeClientTransaction(activate, request, "");
 *  return; 
 */

void netscape_dde_link(HCONV openConv, 
		       DWORD idInst, 
		       HSZ serviceName, 
		       const char filename[])
{
  HDDEDATA result;
  HSZ itemstr, topicName;
  HCONV actConv;
  char const activate_args[] = "0xFFFFFFFF,0x0";
  char open_url_args[MAX_PATH + 20];
    
  /* open_url_args stores the arguments that are passed to the DDE topic
   * WWW_OpenURL.  See netscape DDE documentation for more details.
   * The 0xFFFFFFFF value instructs Netscape to use the last active
   * window, and if there is no last active window, Netscape attempts
   * to create a new window.
   */
    
  sprintf(open_url_args, "%s,,0xFFFFFFFF,0x0,,,", filename); 
  itemstr = DdeCreateStringHandle(idInst, open_url_args, CP_WINANSI);
  if (itemstr == 0L) 
    dde_error(idInst, "open_web_location", "DdeCreateStringHandle");
  
  result = DdeClientTransaction((LPBYTE)NULL, 
				0, 
				openConv,       
				itemstr,     
				CF_TEXT,           
				XTYP_REQUEST,
				TIMEOUT_SYNC,
				NULL);       
  if ((HDDEDATA)NULL == result)
    dde_error(idInst, "open_web_location", "DdeClientTransaction");
  
  if (DdeFreeStringHandle(idInst, itemstr) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeDisconnect(openConv) == 0) 
    dde_error(idInst, "open_web_location", "DdeDisconnect");
  
  topicName = dde_string(idInst,"WWW_Activate");
  
  actConv = DdeConnect(idInst, serviceName, topicName, NULL);
  if (actConv == 0L)
    dde_error(idInst, "open_web_location", "DdeConnect");
  if (DdeFreeStringHandle(idInst, serviceName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeFreeStringHandle(idInst, topicName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  
  itemstr = DdeCreateStringHandle(idInst, activate_args, CP_WINANSI);
  if (itemstr == 0L) 
    dde_error(idInst, "open_web_location", "DdeCreateStringHandle");
  
  result = DdeClientTransaction((LPBYTE)NULL,
				0, 
				actConv,       
				itemstr,
				CF_TEXT,
				XTYP_REQUEST,
				TIMEOUT_SYNC,
				NULL);       
  if ((HDDEDATA)NULL == result)
    dde_error(idInst, "open_web_location", "DdeClientTransaction");
  
  if (DdeFreeStringHandle(idInst, itemstr) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");
  if (DdeDisconnect(actConv) == 0) 
    dde_error(idInst, "open_web_location", "DdeDisconnect");      
  
  if (DdeUninitialize(idInst) == 0)
    raise_io_exn("open_web_location: DdeUninitialize failed");
}



/* 
 * netscape_location:  tries to connect to a Netscape window which 
 *   is already running using dde commands, and if it fails it calls
 *   ShellExecute which either starts Netscape and displays the 
 *   specified web location or starts another web browser.
 */

void netscape_location(const char* filename)
{
  PFNCALLBACK callbackFn;
  DWORD       afCmd, idInst;
  HSZ         serviceName, topicName;
  HCONV       openConv;
  int         result;

  callbackFn = (PFNCALLBACK)std_dde_callback_fn;
  afCmd =
    APPCLASS_STANDARD         |
    CBF_SKIP_ALLNOTIFICATIONS | 
    APPCMD_CLIENTONLY;
  idInst = 0;
  
  result = DdeInitialize(&idInst, callbackFn, afCmd, 0L);  
  if (result != DMLERR_NO_ERROR)
    raise_io_exn("open_web_location: DdeInitialize failed");
  
  serviceName = dde_string(idInst, "NETSCAPE");
  topicName   = dde_string(idInst, "WWW_OpenURL");
  
  openConv = DdeConnect(idInst, serviceName, topicName, NULL);

  if (DdeFreeStringHandle(idInst, topicName) == 0)
    dde_error(idInst, "open_web_location", "DdeFreeStringHandle");

  if ((HCONV)NULL == openConv) {
    /* Either Netscape doesn't exist or is not running, so can just use 
     * ShellExecute, which will either start Netscape manually or start 
     * another web browser, eg. MS Internet Explorer.
     */
    if (DdeUninitialize(idInst) == 0)
      raise_io_exn("open_web_location: DdeUninitialize failed");
    if (((int)ShellExecute(0, "open", filename, 0, 0, SW_NORMAL)) <= 32) 
      dde_error(idInst, "open_web_location", "ShellExecute");
  } else {
    netscape_dde_link(openConv, idInst, serviceName, filename);
  }

}



/* 
 * open_web_location:  attempts to open a web browser at the specified location.
 * 
 * if Web Browser exists (FindExcecutable) then 
 *   call netscape_location(<name of html file to open>)
 * else  
 *   raise system error - browser could not be opened - why?
 *
 * return;
 */

static mlval open_web_location(mlval arg)
{
  char        ignored_exestr[MAX_PATH], *filename;
  int         result;

  filename = CSTRING(arg);

  /* if FindExecutable succeeds the return value is greater than 32,
   * otherwise it returns a value indicating the type of error it failed by.
   */
  if ((result = (int)FindExecutable(filename, "", ignored_exestr)) > 32)
    netscape_location(filename);
  else
    switch (result) {
    case 0:
      exn_raise_syserr("The system is out of memory or resources", 0);
      break;
    case 31:
      exn_raise_syserr("There is no association for the specified file type", 0);
      break;
    case ERROR_FILE_NOT_FOUND:
      exn_raise_syserr("HTML file not found", 0);
      break;
    case ERROR_PATH_NOT_FOUND:
      exn_raise_syserr("HTML path not found", 0);
      break;
    case ERROR_BAD_FORMAT:
      exn_raise_syserr("HTML: bad exe format", 0);
      break;
    default:
      exn_raise_syserr("Loading html page: unknown error", 0);      
    }
    
  return MLUNIT;
}

a291 1
  env_function("win32 open web location",  open_web_location);
d354 1
a354 1
      break;
@


1.2.9.1.1.2.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a12 5
 * Revision 1.2.9.1.1.2  1997/08/05  15:23:52  johnh
 * [Bug #30124]
 * Merging - Help interface to documentation (Win32).
 * Add open_web_location function.
 *
@


1.2.8.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.7.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.7.1.1.1
log
@branched from 1.2.7.1
@
text
@a12 3
 * Revision 1.2.7.1  1996/12/17  17:57:24  hope
 * branched from 1.2
 *
@


1.2.6.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.5.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.4.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.4.1.1.1
log
@branched from 1.2.4.1
@
text
@a12 3
 * Revision 1.2.4.1  1996/11/14  13:01:15  hope
 * branched from 1.2
 *
@


1.2.3.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.2.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.2.1.1
log
@branched from 1.2
@
text
@a12 3
 * Revision 1.2  1996/07/05  10:33:47  stephenb
 * pack_dde_info: remove bogus declare_root
 *
@


1.1
log
@new unit
New file.
@
text
@d12 5
a16 1
 *  $Log$
d19 13
a386 1
   declare_root(&object);
@
