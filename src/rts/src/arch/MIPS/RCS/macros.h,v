head	1.23;
access;
symbols
	MLW_daveb_inline_1_4_99:1.23.4
	MLWorks_21c0_1999_03_25:1.23
	MLWorks_20c1_1998_08_20:1.23
	MLWorks_20c0_1998_08_04:1.23
	MLWorks_20b2c2_1998_06_19:1.23
	MLWorks_20b2_Windows_1998_06_12:1.23
	MLWorks_20b1c1_1998_05_07:1.23
	MLWorks_20b0_1998_04_07:1.23
	MLWorks_20b0_1998_03_20:1.23
	MLWorks_20m2_1998_02_16:1.23
	MLWorks_MM_adapt:1.23.3
	MLWorks_20m1_1997_10_23:1.23
	MLWorks_11r1:1.22.9.1.1.1.1
	MLWorks_workspace_97:1.23.2
	MLWorks_dt_wizard:1.23.1
	MLWorks_11c0_1997_09_09:1.22.9.1.1.1
	MLWorks_10r3:1.22.9.1.3
	MLWorks_10r2_551:1.22.9.1.2
	MLWorks_11:1.22.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.22.9.1
	MLWorks_20m0_1997_06_20:1.23
	MLWorks_1_0_r2c2_1997_06_14:1.22.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.22.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.22.9
	MLWorks_BugFix_1997_04_24:1.22
	MLWorks_1_0_r2_Win32_1997_04_11:1.22
	MLWorks_1_0_r2_Unix_1997_04_04:1.22
	MM_ML_release_korma_1997_04_01:1.22
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.22.7.1.1
	MLWorks_gui_1996_12_18:1.22.8
	MLWorks_1_0_Win32_1996_12_17:1.22.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.22.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.22.4.1
	JFHrts:1.22.6
	MLWorks_1_0_Irix_1996_11_28:1.22.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.22.5
	MLWorks_1_0_Unix_1996_11_14:1.22.4
	MLWorks_Open_Beta2_1996_10_11:1.22.3
	MLWorks_License_dev:1.22.2
	MLWorks_1_open_beta_1996_09_13:1.22.1
	MLWorks_Open_Beta_1996_08_22:1.22
	MLWorks_Beta_1996_07_02:1.22
	MLWorks_Beta_1996_06_07:1.22
	MLWorks_Beta_1996_06_06:1.22
	MLWorks_Beta_1996_06_05:1.22
	MLWorks_Beta_1996_06_03:1.22
	MLWorks_Beta_1996_05_31:1.22
	MLWorks_Beta_1996_05_30:1.22
	hope_poo:1.9.1
	ML_beta_release_12/08/94:1.9.1.1
	ML_beta_release_03/08/94:1.8;
locks; strict;
comment	@ * @;


1.23
date	97.05.06.10.41.39;	author stephenb;	state Exp;
branches
	1.23.1.1
	1.23.2.1
	1.23.3.1
	1.23.4.1;
next	1.22;

1.22
date	96.04.25.17.33.15;	author jont;	state Exp;
branches
	1.22.1.1
	1.22.2.1
	1.22.3.1
	1.22.4.1
	1.22.5.1
	1.22.6.1
	1.22.7.1
	1.22.8.1
	1.22.9.1;
next	1.21;

1.21
date	95.09.07.11.40.54;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	95.05.05.10.51.51;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.05.04.10.49.40;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	95.04.06.16.07.23;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.03.30.11.09.46;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.03.20.14.32.19;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	95.03.20.12.57.40;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	94.12.19.11.42.33;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	94.12.13.10.46.21;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	94.11.08.16.26.03;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	94.10.25.13.06.19;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	94.10.20.11.28.36;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	94.08.03.13.42.02;	author jont;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	94.08.02.13.58.21;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.07.29.14.09.01;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.07.25.15.38.03;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.07.22.16.38.01;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.07.22.09.00.28;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.07.18.15.58.17;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.07.14.11.12.13;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.03.25;	author jont;	state Exp;
branches;
next	;

1.9.1.1
date	95.07.05.10.28.44;	author hope;	state Exp;
branches;
next	;

1.22.1.1
date	96.09.13.11.21.28;	author hope;	state Exp;
branches;
next	;

1.22.2.1
date	96.10.07.16.11.29;	author hope;	state Exp;
branches;
next	;

1.22.3.1
date	96.10.17.11.30.00;	author hope;	state Exp;
branches;
next	;

1.22.4.1
date	96.11.14.12.56.01;	author hope;	state Exp;
branches
	1.22.4.1.1.1;
next	;

1.22.4.1.1.1
date	96.11.28.15.06.34;	author hope;	state Exp;
branches;
next	;

1.22.5.1
date	96.11.22.18.14.15;	author hope;	state Exp;
branches;
next	;

1.22.6.1
date	96.12.17.10.01.02;	author hope;	state Exp;
branches;
next	;

1.22.7.1
date	96.12.17.17.52.46;	author hope;	state Exp;
branches
	1.22.7.1.1.1;
next	;

1.22.7.1.1.1
date	97.02.24.11.43.34;	author hope;	state Exp;
branches;
next	;

1.22.8.1
date	96.12.18.09.47.17;	author hope;	state Exp;
branches;
next	;

1.22.9.1
date	97.05.12.10.39.42;	author hope;	state Exp;
branches
	1.22.9.1.1.1
	1.22.9.1.2.1
	1.22.9.1.3.1;
next	;

1.22.9.1.1.1
date	97.07.28.18.26.12;	author daveb;	state Exp;
branches
	1.22.9.1.1.1.1.1;
next	;

1.22.9.1.1.1.1.1
date	97.10.07.11.52.02;	author jkbrook;	state Exp;
branches;
next	;

1.22.9.1.2.1
date	97.09.08.17.19.24;	author daveb;	state Exp;
branches;
next	;

1.22.9.1.3.1
date	97.09.09.14.15.33;	author daveb;	state Exp;
branches;
next	;

1.23.1.1
date	97.09.10.19.32.40;	author brucem;	state Exp;
branches;
next	;

1.23.2.1
date	97.09.11.21.01.57;	author daveb;	state Exp;
branches;
next	;

1.23.3.1
date	97.10.31.13.44.51;	author nickb;	state Exp;
branches;
next	;

1.23.4.1
date	99.04.01.18.01.30;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.23
log
@[Bug #30031]
{push,pop}_[all]_ML_regs: now save/restore $gp.  See .preserve-gp
for more information.
@
text
@/*
 * ==== ML TO C INTERFACE MACROS ====
 *		MIPS
 *
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * These macros are used by other MIPS assembly language routines in
 * the ML to C interface.  They deal with various conventions between
 * the C runtime system and ML.
 *
 * Notes
 * -----
 *
 * Take great care modifying this file. As well as getting the
 * semantics right for MIPS (remember those delay slots!), you have to
 * maintain hidden invariants or you will break the profiler. See the
 * profiler comment in the body of the file.
 *
 * Revision Log
 * ------------
 * $Log: src:arch:MIPS:macros.h,v $
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
 * Revision 1.21  1995/09/07  11:40:54  nickb
 * Change to c_sp protocol.
 *
 * Revision 1.20  1995/05/05  10:51:51  nickb
 * Add a cautionary comment.
 *
 * Revision 1.19  1995/05/04  10:49:40  nickb
 * Change the manipulation of the in_ML flag so that:
 * (a) in_ML false => thread->ml_state.sp is meaningful
 * (b) in_ML true => sp,fp,closures make some sense for ML.
 *
 * Revision 1.18  1995/04/06  16:07:23  nickb
 * Non-gcable value getting into $5.
 *
 * Revision 1.17  1995/03/30  11:09:46  nickb
 * Threads system.
 *
 * Revision 1.16  1995/03/20  14:32:19  matthew
 * Fixing syntax error
 *
 * Revision 1.15  1995/03/20  12:57:40  matthew
 * Debugger stuff
 *
 * Revision 1.14  1994/12/19  11:42:33  nickb
 * c_raise getting the wrong closure.
 *
 * Revision 1.13  1994/12/13  10:46:21  nickb
 * Rewrote most of these macros.
 *
 * Revision 1.12  1994/11/08  16:26:03  matthew
 * Added macros to save and restore fp registers
 *
 * Revision 1.11  1994/10/25  13:06:19  nickb
 * Add clean_caller_saves macro.
 *
 * Revision 1.10  1994/10/20  11:28:36  nickb
 * Make 'save_all_ML_regs' stack frame double-word aligned.
 *
 * Revision 1.9  1994/08/03  13:42:02  jont
 * Add closure to ml_state
 *
 * Revision 1.8  1994/08/02  13:58:21  jont
 * Ensure stub_c etc preserve $5
 *
 * Revision 1.7  1994/07/29  14:09:01  jont
 * Fix tagged value test in unwind stack
 *
 * Revision 1.6  1994/07/25  15:38:03  jont
 * Move architecture dependent stuff from values.h into mach_values.h
 *
 * Revision 1.5  1994/07/22  16:38:01  jont
 * Remove handler and implicit from register saved when entering stubs
 *
 * Revision 1.4  1994/07/22  09:00:28  jont
 * Add unwind_stack
 *
 * Revision 1.3  1994/07/18  15:58:17  jont
 * Get clean_current_registers round the right way
 *
 * Revision 1.2  1994/07/14  11:12:13  jont
 * Modifications for store_C_globals etc
 *
 * Revision 1.1  1994/07/12  12:03:25  jont
 * new file
 * */

/* The signal-handling interface for the profiler, and for printing
 * backtraces after fatal signals, deduces the current topmost few
 * frames on the logical ML stack from the contents of certain
 * registers and the C variable global_state.in_ML.
 *
 * In order to do this it needs to assume certain invariants. Take
 * great care when modifying this file or you will break these
 * invariants.
 *
 * The signal-handler interface has the following pseudocode:
 * 
 * if global_state.in_ML == 0,
 * 	backtrace = CURRENT_THREAD->ml_state.sp
 * if global_state.in_ML != 0,
 * 	local 
 * 	  val missing_closures = 
 * 		(if $5 <> $6, andalso $5 is a closure,
 * 		    andalso $pc is in that code item,
 * 		then [$5,$6] else [$6])
 * 	  val rest_of_stack =
 * 		(if the instruction under pc is one of a small magic set,
 * 		 (connected with function entry and return)
 * 		then $fp else $sp)
 * 	  val _ = if $sp <> $fp then *($sp) := $fp
 * 	in
 * 	  backtrace = missing_closures @@ rest_of_stack
 * 	end
 * 
 * frames upwards from 'backtrace' are then examined by the profiler
 * or the backtrace printer, treating any without ML-tagged closures
 * as C frames.
 *
 * So, for instance, invariants obviously include:
 *
 * - when in_ML == 0, ml_sp must be valid
 * - when in_ML != 0,
 *		- $5 and $6 must not contain non-ML garbage
 *		- $sp and $fp must make _some_ sense together.
 * 		- if $sp doesn't point to a stack frame with 
 *		  a valid closure, one must be at a 'magic' instruction.
 * (see signals.c for a list).  */

#include "offsets.h"
#include "mach_values.h"
#include "asm_offsets.h"

/* ML boolean values; these must agree with those defined in values.h */

#define TRUE	4
#define FALSE	0

/* Clean the registers */

/* Clean caller-save registers (should be done when moving from C to ML) */
#define clean_caller_saves		\
	move	$16,	$0	;	\
	move	$17,	$0	;	\
	move	$18,	$0	;	\
	move	$19,	$0	;	\
	move	$20,	$0	;	\
	move	$21,	$0	;	\
	move	$22,	$0	;	\
	move	$23,	$0

/* Clean callee-save registers */
#define clean_callee_saves		\
	move	$10,	$0	;	\
	move	$11,	$0	;	\
	move	$12,	$0	;	\
	move	$13,	$0	;	\
	move	$14,	$0	;	\
	move	$15,	$0	;	\
	move	$24,	$0	;	\
	move	$25,	$0

#define clean_current_registers		\
	clean_caller_saves	;	\
	clean_callee_saves

/*
 *.preserve-gp: It is possible that a called C function alters the value
 * of $gp.  This can play havoc with the few implicit uses of $gp in MLWorks
 * code -- for example, see uses of la in 
 * <URI:hope://MLWsrc/rts/src/arch/MIPS/Irix/poly_equal.S#ml_eq_not_eq
 * <URI:hope://MLWsrc/rts/src/arch/MIPS/Irix/poly_equal.S#ml_eq_pointer).
 * This change of $gp has only been observed in dynamically loaded C code, 
 * and so a special case could be made for just saving $gp then.  However,
 * given that there are so many registers being saved already when calling
 * C, one more won't make much of a difference.
 */



/* push_ML_regs and pop_ML_regs:
 *
 * push_ML_regs creates a new ML stack frame to save all the ML callee
 * save registers prior to calling C.
 *
 * pop_ML_regs pops the stack frame and restores all the registers. It
 * also clears $5, as that can contain a bad value at this point.
 */

#define	push_ML_regs			;			\
	sw	$30, 0($29)		;/* Save current fp */	\
	move	$30, $29		;/* New fp */		\
	subu	$29, 48			;/* Create frame */	\
	sw	$6, 4($29)		;/* save caller's closure */\
	sw	$31, 8($29)		;/* save link reg */	\
	move	$6, $5			;/* As per normal function entry */ \
	sw	$30, 0($29)		;/* Fill fp slot */	\
	sw	$10, 12($29)		;/* save ML callee-saves */\
	sw	$11, 16($29)		;			\
	sw	$12, 20($29)		;			\
	sw	$13, 24($29)		;			\
	sw	$14, 28($29)		;			\
	sw	$15, 32($29)		;			\
	sw	$24, 36($29)		;			\
	sw	$25, 40($29)		;			\
	sw	$28, 44($29)		; /* .preserve-gp */


#define	pop_ML_regs						\
	move	$5, $0			; /* clear $5 */	\
	lw	$31, 8($29)		; /* restore link reg */\
	lw	$10, 12($29)		; /* restore callee-saves */\
	lw	$11, 16($29)		;			\
	lw	$12, 20($29)		;			\
	lw	$13, 24($29)		;			\
	lw	$14, 28($29)		;			\
	lw	$15, 32($29)		;			\
	lw	$24, 36($29)		;			\
	lw	$25, 40($29)		;			\
	lw	$28, 44($29)		; /* .preserve-gp */	\
	lw	$6, 4($29)		; /* restore closure */	\
	move	$29,$30			;/* pop frame */	\
	lw	$30, 0($29)		;/* restore fp */

/*
 * push_all_ML_regs and pop_all_ML_regs
 *
 * push_all_ML_regs is used when entering C when ML has not had
 * opportunity to save any values (e.g. at GC entry), so all the
 * general-purpose registers, including the caller-saves, must be
 * saved on the ML stack so the GC can fix them up.
 *
 * pop_all_ML_regs restores all the registers from that stack frame
 *
 */

#define	push_all_ML_regs			;		\
	sw	$30, 0($29)		;/* Save current fp */	\
	move	$30, $29		;/* New fp */		\
	subu	$29, 88			;/* Create aligned frame */\
	sw	$6,   4($29)		;/* save caller's closure */\
	sw	$31,  8($29)		;/* save link register */\
	sw	$30,  0($29)		;/* Save new fp */	\
	sw	$10, 12($29)		;/* save callee-saves */\
	sw	$11, 16($29)		;			\
	sw	$12, 20($29)		;			\
	sw	$13, 24($29)		;			\
	sw	$14, 28($29)		;			\
	sw	$15, 32($29)		;			\
	sw	$24, 36($29)		;			\
	sw	$25, 40($29)		;			\
	sw	$16, 44($29)		;/* save caller-saves */\
	sw	$17, 48($29)		;			\
	sw	$18, 52($29)		;			\
	sw	$19, 56($29)		;			\
	sw	$20, 60($29)		;			\
	sw	$21, 64($29)		;			\
	sw	$22, 68($29)		;			\
	sw	$23, 72($29)		;			\
	sw	$4,  76($29)		;/* save arg */		\
	sw	$5,  80($29)		;/* save callee's closure */\
	sw	$28, 84($29)		;/* .preserve-gp */

#define	pop_all_ML_regs			;			\
	lw	$6,   4($29)		;/* load caller's closure */\
	lw	$31,  8($29)		;/* load link register */\
	lw	$10, 12($29)		;/* load callee-saves */\
	lw	$11, 16($29)		;			\
	lw	$12, 20($29)		;			\
	lw	$13, 24($29)		;			\
	lw	$14, 28($29)		;			\
	lw	$15, 32($29)		;			\
	lw	$24, 36($29)		;			\
	lw	$25, 40($29)		;			\
	lw	$16, 44($29)		;/* load caller-saves */\
	lw	$17, 48($29)		;			\
	lw	$18, 52($29)		;			\
	lw	$19, 56($29)		;			\
	lw	$20, 60($29)		;			\
	lw	$21, 64($29)		;			\
	lw	$22, 68($29)		;			\
	lw	$23, 72($29)		;			\
	lw	$28, 84($29)		;/* .preserve-gp */	\
	lw	$4,  76($29)		;/* load arg */		\
	lw	$5,  80($29)		;/* load callee's closure */\
	move	$29, $30		; /* pop frame */	\
	lw	$30, 0($29)		;/* Can't delay this */ \
	nop

/* save C callee-saves; push a stack frame and save $16-$23, $30 in
   it. Note that we leave 4 slots so when ML calls back into C the arg
   slots are pre-allocated. */

#define push_C_regs						\
	addu	$29, -14*4	;				\
	sw	$16, 16($29)	;	/* gp callee saves */	\
	sw	$17, 20($29)	;				\
	sw	$18, 24($29)	;				\
	sw	$19, 28($29)	;				\
	sw	$20, 32($29)	;				\
	sw	$21, 36($29)	;				\
	sw	$22, 40($29)	;				\
	sw	$23, 44($29)	;				\
	sw	$30, 48($29)

/* load C callee-saves; this reloads the registers saved by
   push_C_regs above and pops that stack frame. */

#define pop_C_regs						\
	lw	$16, 16($29)	;       /* gp callee saves */	\
	lw	$17, 20($29)	;       			\
	lw	$18, 24($29)	;       			\
	lw	$19, 28($29)	;       			\
	lw	$20, 32($29)	;       			\
	lw	$21, 36($29)	;       			\
	lw	$22, 40($29)	;       			\
	lw	$23, 44($29)	;       			\
	lw	$30, 48($29)	;       			\
	addu	$29, 14*4

/* save caller-save floating point registers */

#define push_fps						\
        addu 	$29,-80		        ;/* Make some room */   \
        swc1	$f0, 0($29)		;			\
        swc1	$f1, 4($29)		;			\
        swc1	$f2, 8($29)		;			\
        swc1	$f3, 12($29)		;			\
        swc1	$f4, 16($29)		;			\
        swc1	$f5, 20($29)		;			\
        swc1	$f6, 24($29)		;			\
        swc1	$f7, 28($29)		;			\
        swc1	$f8, 32($29)		;			\
        swc1	$f9, 36($29)		;			\
        swc1	$f10, 40($29)		;			\
        swc1	$f11, 44($29)		;			\
        swc1	$f12, 48($29)		;			\
        swc1	$f13, 52($29)		;			\
        swc1	$f14, 56($29)		;			\
        swc1	$f15, 60($29)		;			\
        swc1	$f16, 64($29)		;			\
        swc1	$f17, 68($29)		;			\
        swc1	$f18, 72($29)		;			\
        swc1	$f19, 76($29)		;			\

/* reload them */

#define pop_fps				       			\
        lwc1	$f0, 0($29)		;			\
        lwc1	$f1, 4($29)		;			\
        lwc1	$f2, 8($29)		;			\
        lwc1	$f3, 12($29)		;			\
        lwc1	$f4, 16($29)		;			\
        lwc1	$f5, 20($29)		;			\
        lwc1	$f6, 24($29)		;			\
        lwc1	$f7, 28($29)		;			\
        lwc1	$f8, 32($29)		;			\
        lwc1	$f9, 36($29)		;			\
        lwc1	$f10, 40($29)		;			\
        lwc1	$f11, 44($29)		;			\
        lwc1	$f12, 48($29)		;			\
        lwc1	$f13, 52($29)		;			\
        lwc1	$f14, 56($29)		;			\
        lwc1	$f15, 60($29)		;			\
        lwc1	$f16, 64($29)		;			\
        lwc1	$f17, 68($29)		;			\
        lwc1	$f18, 72($29)		;			\
        lwc1	$f19, 76($29)		;			\
	addu	$29,80

/* Thread state loading and saving code */

#define load_thread_floats(use)					\
	lwc1	$f20, THREAD_c_float_saves(use);		\
	lwc1	$f21, THREAD_c_float_saves+4(use);		\
	lwc1	$f22, THREAD_c_float_saves+8(use);		\
	lwc1	$f23, THREAD_c_float_saves+12(use);		\
	lwc1	$f24, THREAD_c_float_saves+16(use);		\
	lwc1	$f25, THREAD_c_float_saves+20(use);		\
	lwc1	$f26, THREAD_c_float_saves+24(use);		\
	lwc1	$f27, THREAD_c_float_saves+28(use);		\
	lwc1	$f28, THREAD_c_float_saves+32(use);		\
	lwc1	$f29, THREAD_c_float_saves+36(use);		\
	lwc1	$f30, THREAD_c_float_saves+40(use);		\
	lwc1	$f31, THREAD_c_float_saves+44(use)

#define save_thread_floats(use)					\
	swc1	$f20, THREAD_c_float_saves(use);		\
	swc1	$f21, THREAD_c_float_saves+4(use);		\
	swc1	$f22, THREAD_c_float_saves+8(use);		\
	swc1	$f23, THREAD_c_float_saves+12(use);		\
	swc1	$f24, THREAD_c_float_saves+16(use);		\
	swc1	$f25, THREAD_c_float_saves+20(use);		\
	swc1	$f26, THREAD_c_float_saves+24(use);		\
	swc1	$f27, THREAD_c_float_saves+28(use);		\
	swc1	$f28, THREAD_c_float_saves+32(use);		\
	swc1	$f29, THREAD_c_float_saves+36(use);		\
	swc1	$f30, THREAD_c_float_saves+40(use);		\
	swc1	$f31, THREAD_c_float_saves+44(use)

#define load_thread_saves(use)					\
		lw	$16, THREAD_c_callee_saves(use);	\
		lw	$17, THREAD_c_callee_saves+4(use);	\
		lw	$18, THREAD_c_callee_saves+8(use);	\
		lw	$19, THREAD_c_callee_saves+12(use);	\
		lw	$20, THREAD_c_callee_saves+16(use);	\
		lw	$21, THREAD_c_callee_saves+20(use);	\
		lw	$22, THREAD_c_callee_saves+24(use);	\
		lw	$23, THREAD_c_callee_saves+28(use);	\
		lw	$30, THREAD_c_callee_saves+32(use)

#define save_thread_saves(use)					\
		sw	$16, THREAD_c_callee_saves(use);	\
		sw	$17, THREAD_c_callee_saves+4(use);	\
		sw	$18, THREAD_c_callee_saves+8(use);	\
		sw	$19, THREAD_c_callee_saves+12(use);	\
		sw	$20, THREAD_c_callee_saves+16(use);	\
		sw	$21, THREAD_c_callee_saves+20(use);	\
		sw	$22, THREAD_c_callee_saves+24(use);	\
		sw	$23, THREAD_c_callee_saves+28(use);	\
		sw	$30, THREAD_c_callee_saves+32(use)

/* These next macros load and store the ML state. */

/* Saves 'global', 'gc1', and 'handler' in a thread state given by $9
 * Does _not_ save gc2 (which is just a copy of the value in the
 * thread state) or the stack limit. */

#define store_ML_state						\
	sw	$1, THREAD_ml_global($9);			\
	sw	$2, IMPLICIT_gc_base($9);			\
	sw	$8, IMPLICIT_handler($9);			

/* Loads the global registers from a thread state given by $9. The
   stack register is loaded and then ORed with the interrupt stack
   slot, which is left in $16. This is so when we return to ML the
   stack register is -1 if there has been an asynchronous event */

#define load_ML_state						\
	lw	$1, THREAD_ml_global($9);			\
	lw	$2, IMPLICIT_gc_base($9);			\
	lw	$7, IMPLICIT_stack_limit($9);			\
	lw	$8, IMPLICIT_handler($9);			\
	lw	$16, IMPLICIT_interrupt($9);			\
	lw	$3, IMPLICIT_gc_limit($9);			\
	or	$7, $7, $16

/* Call C from ML : Saves the ML state and restore the C state, then
 * calls the function, passing registers $4 to $6 as arguments for C.
 * The C return value is returned in $4. */

#define ML_to_C(what)							\
	store_ML_state		 	;			 	\
	sw	$29, THREAD_ml_sp($9)	;/* Save ML sp   	     */	\
	sw	$30, 0($29)		;/* Save fp in this frame */    \
	lw	$16, THREAD_global($9)	;/* get the global state */	\
	lw	$29, THREAD_c_sp($9)	; /* Fetch the previous C sp */	\
	jal	what			; /* Call function	     */	\
	sw	$0, GLOBAL_in_ML($16)	; /* Not in ML */		\
									\
	lw	$9, GLOBAL_current_thread($16); /* current thread */	\
	move	$4, $2			; /* Get returned value */	\
	lw	$29, THREAD_ml_sp($9)  ; /* re-load the ML sp */	\
	move	$5, $0			; /* clear clos5 for profiling */\
	move	$6, $0			; /* clear clos6 for profiling */\
	sw	$16, GLOBAL_in_ML($16)	; /* back in ML; $16 != 0 */	\
	load_ML_state			;

/* finds the number of saves for the frame pushed by a given closure */

#define number_of_saves(closure,use)					\
	lw	use, -1(closure)	; /* Get code vector */		\
	nop				;				\
	lw	use, -1(use)		; /* Get ancillary */		\
	nop				;				\
	srl	use, use, CCODE_SAVES_SHIFT;				\
	andi	use, use, CCODE_MAX_SAVES	; /* Number of callee saves */

/* computes the number of words for saves+linkage of a frame produced
 * by a given closure */

#define compute_frame_size(closure,answer)				\
	number_of_saves(closure,answer)	;				\
	addiu	answer, answer, 3	; /* Plus three for the linkage */

/* Unwind stack to a particular point
 *
 * The ML stack is unwound by repeatedly popping until the fp equals $18.
 * On entry, $6 is the closure for the current frame
 * The argument is a label prefix.
 */

#define unwind_stack(label)						\
label ## _unwind:			;				\
	beqz	$0, label ## _unw_while	;				\
	ori	$17, $0, STACK_C_CALL	;				\
label ## _unw_loop:			;				\
      	andi	$5, $6, 3		;/* is the closure tagged? */	\
	subu	$5, 1			;				\
	bnez	$5, label ## _unw_loaded;/*if so, restore callee-saves */\
	nop				;				\
	number_of_saves($6,$5)		;/* how many are there? */	\
	addiu	$1, $5, -9		;/* maximum for this code */	\
	bgez	$1, label ## _unw_error	;/* are there too many? */	\
	nop				;				\
	.set at				;     /* just for this instr: */\
	la	$16, label ## _unw_loaded ;/* base for computed goto */	\
	.set noat			;     				\
	sll	$5, $5, 2		;/* this block of register */	\
	sub	$16, $16, $5		;/* restores according to */	\
	jr	$16			;/* the number of callee-saves*/\
	nop				;				\
	lw	$25, 40($29)		;/* restore 8th callee-save */  \
	lw	$24, 36($29)		;/* restore 7th callee-save */  \
	lw	$15, 32($29)		;/* restore 6th callee-save */  \
	lw	$14, 28($29)		;/* restore 5th callee-save */  \
	lw	$13, 24($29)		;/* restore 4th callee-save */  \
	lw	$12, 20($29)		;/* restore 3th callee-save */  \
	lw	$11, 16($29)		;/* restore 2nd callee-save */  \
	lw	$10, 12($29)		;/* restore 1st callee-save */  \
label ## _unw_loaded:			;				\
	lw	$6, 4($29)		;/* Get caller's closure back */\
	nop				;/* delay slot */		\
	bne	$17, $6, label ## _unw_skip ;	/* if a c_sp frame */	\
        nop				;				\
	lw	$5, 12($29)		; /* then restore c_sp from it*/\
	lw	$10, 12($30)		; /* and restore callee-saves */\
	lw	$11, 16($30)		; /* from previous frame */     \
	lw	$12, 20($30)		;				\
	lw	$13, 24($30)		;				\
	lw	$14, 28($30)		;				\
	lw	$15, 32($30)		;				\
	lw	$24, 36($30)		;				\
	lw	$25, 40($30)		;				\
	sw	$5, THREAD_c_sp($9)	;				\
label ## _unw_skip:			;				\
	move	$29, $30		;/* Point to previous frame */	\
        lw	$30,0($29)		;/* Restore fp as well */	\
	nop				;				\
label ## _unw_while:			;/* while $18 != $fp */		\
	bne	$30, $18, label ## _unw_loop ;				\
	nop				;				\
label ## _unw_callC:			;				\
									\
/* We now have the correct callee-saves to return to ML. Also the	\
 * closure register, our sp and fp are all correct. We have just to	\
call unwind_stack and return to ML. Of course, in order to call		\
unwind_stack we have to save the ML callee-saves.... */			\
									\
	move	$17, $4			;/* preserve handler result */	\
	move	$4, $29			;/* move sp into argument */	\
	push_ML_regs			;				\
	ML_to_C(unwind_stack)		;				\
	move	$4, $17			;/* restore handler result */	\
	pop_ML_regs			;/* restore callee-saves */	\
	clean_caller_saves		;				\
	b	label ## _unw_done	;/* Finished! */		\
	nop				;				\
label ## _unw_error:			;				\
	break 0				;/* cause breakpoint trap */	\
	nop				;				\
label ## _unw_done:

@


1.23.4.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a23 5
 * Revision 1.23  1997/05/06  10:41:39  stephenb
 * [Bug #30031]
 * {push,pop}_[all]_ML_regs: now save/restore $gp.  See .preserve-gp
 * for more information.
 *
@


1.23.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a23 5
 * Revision 1.23  1997/05/06  10:41:39  stephenb
 * [Bug #30031]
 * {push,pop}_[all]_ML_regs: now save/restore $gp.  See .preserve-gp
 * for more information.
 *
@


1.23.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a23 5
 * Revision 1.23  1997/05/06  10:41:39  stephenb
 * [Bug #30031]
 * {push,pop}_[all]_ML_regs: now save/restore $gp.  See .preserve-gp
 * for more information.
 *
@


1.23.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a23 5
 * Revision 1.23  1997/05/06  10:41:39  stephenb
 * [Bug #30031]
 * {push,pop}_[all]_ML_regs: now save/restore $gp.  See .preserve-gp
 * for more information.
 *
@


1.22
log
@Remove copy_up and copy_down, no longer required
@
text
@d24 3
d172 14
d211 2
a212 1
	sw	$0,  44($29)		; /* clear slot */
d225 1
d267 1
a267 1
	sw	$0,  84($29)		; /* clear slot */
d288 1
@


1.22.9.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a23 3
 * Revision 1.22.9.1  1997/05/12  10:39:42  hope
 * branched from 1.22
 *
@


1.22.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a23 3
 * Revision 1.22.9.1  1997/05/12  10:39:42  hope
 * branched from 1.22
 *
@


1.22.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a23 3
 * Revision 1.22.9.1  1997/05/12  10:39:42  hope
 * branched from 1.22
 *
@


1.22.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a23 3
 * Revision 1.22.9.1.1.1  1997/07/28  18:26:12  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.22.8.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.7.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.7.1.1.1
log
@branched from 1.22.7.1
@
text
@a23 3
 * Revision 1.22.7.1  1996/12/17  17:52:46  hope
 * branched from 1.22
 *
@


1.22.6.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.5.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.4.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.4.1.1.1
log
@branched from 1.22.4.1
@
text
@a23 3
 * Revision 1.22.4.1  1996/11/14  12:56:01  hope
 * branched from 1.22
 *
@


1.22.3.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.2.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.22.1.1
log
@branched from 1.22
@
text
@a23 3
 * Revision 1.22  1996/04/25  17:33:15  jont
 * Remove copy_up and copy_down, no longer required
 *
@


1.21
log
@Change to c_sp protocol.
@
text
@d24 3
a548 28
/*
 * copy_down(size, pointer, temp)
 * copy callee save values plus linkage down two words
 */
#define	copy_down(name, size,pointer,temp)				\
	subu	$29, 8			;/* Create space */		\
	addu	pointer, $29, 8		;/* Pointer */			\
copy_down_ ## name ## _start:		;				\
	lw	temp, 0(pointer)	;				\
	subu	size, 1			;				\
	sw	temp, -8(pointer)	;/* copy down */		\
	bnez	size, copy_down_ ## name ## _start ;/* Loop if more to do */ \
	addu	pointer, pointer, 4

/*
 * copy_up(size, pointer, temp)
 * copy callee save values plus linkage up two words
 */
#define	copy_up(name,size,pointer,temp)					\
	sll	temp, size, 2		;				\
	addu	pointer, $29, temp	;/* Pointer */			\
copy_up_ ## name ## _start:		;				\
	lw	temp, -8(pointer)	;				\
	subu	size, 1			;				\
	sw	temp, 0(pointer)	;/* copy up */			\
	bnez	size, copy_up_ ## name ## _start; /* Loop if more to do */ \
	subu	pointer, pointer, 4	;				\
	addu	$29, 8			;/* Throw away space */
@


1.20
log
@Add a cautionary comment.
@
text
@d24 3
a170 3
 * It also saves c_sp, so that this can be readily restored when
 * returning from C to ML.
 *
a189 1
	lw	$10, THREAD_c_sp($9)	; /* load c_sp */	\
d191 1
a191 1
	sw	$10,  44($29)		; /* save it */
a193 1
	lw	$10 , 44($29)		; /* reload c_sp */	\
a194 1
	sw	$10, THREAD_c_sp($9)	; /* restore c_sp */	\
a217 1
 * this pair of functions similarly saves and restores the c_sp.
d227 1
a227 1
	sw	$10, 12($29)		;/* save gp regs */	\
d233 13
a245 14
	sw	$16, 36($29)		;			\
	sw	$17, 40($29)		;			\
	sw	$18, 44($29)		;			\
	sw	$19, 48($29)		;			\
	sw	$20, 52($29)		;			\
	sw	$21, 56($29)		;			\
	sw	$22, 60($29)		;			\
	sw	$23, 64($29)		;			\
	sw	$24, 68($29)		;			\
	sw	$25, 72($29)		;			\
	sw	$4, 76($29)		;/* save arg */		\
	lw	$10, THREAD_c_sp($9)	; /* load c_sp */	\
	sw	$5, 80($29)		;/* save callee's closure */\
	sw	$10, 84($29)		; /* save the c_sp */
a247 1
	lw	$10, 84($29)		;/* reload c_sp */	\
a248 1
	sw	$10, THREAD_c_sp($9)	; /* save c_sp */	\
d250 1
a250 1
	lw	$10, 12($29)		;/* load gp regs */	\
d256 12
a267 12
	lw	$16, 36($29)		;			\
	lw	$17, 40($29)		;			\
	lw	$18, 44($29)		;			\
	lw	$19, 48($29)		;			\
	lw	$20, 52($29)		;			\
	lw	$21, 56($29)		;			\
	lw	$22, 60($29)		;			\
	lw	$23, 64($29)		;			\
	lw	$24, 68($29)		;			\
	lw	$25, 72($29)		;			\
	lw	$4, 76($29)		;/* load arg */		\
	lw	$5, 80($29)		;/* load callee's closure */\
a444 1
	sw	$29, THREAD_c_sp($9)	; /* re-save the C sp */       	\
d509 8
a516 1
	nop				;				\
@


1.19
log
@Change the manipulation of the in_ML flag so that:
(a) in_ML false => thread->ml_state.sp is meaningful
(b) in_ML true => sp,fp,closures make some sense for ML.
@
text
@d16 5
d24 5
d82 43
a124 2
 *
 */
@


1.18
log
@Non-gcable value getting into $5.
@
text
@d19 3
a127 1
	sw	$30, 0($29)		;/* Fill fp slot */	\
d130 2
d141 1
a141 2
	sw	$10,  44($29)		; /* save it */		\
	move	$6, $5			;/* As per normal function entry */ \
a143 1
	lw	$6, 4($29)		; /* restore closure */	\
d156 1
a176 1
	sw	$30,  0($29)		;/* Save new fp */	\
d179 1
d399 1
d401 4
a404 1
	lw	$9, GLOBAL_current_thread($16); /* current thread */	\
d406 1
a406 3
	sw	$29, THREAD_c_sp($9)	; /* re-save the C sp */       	\
	load_ML_state			;				\
	lw	$29, THREAD_ml_sp($9)  ; /* re-load the ML sp */
a422 1
        /* This should be 4 with a saved argument also */               \
d437 1
a437 1
	andi	$5, $6, 3		;/* is the closure tagged? */	\
@


1.17
log
@Threads system.
@
text
@d19 3
d117 2
a118 1
 * pop_ML_regs pops the stack frame and restores all the registers.
d141 1
d143 1
a143 1
	lw	$6, 4($29)		; /* restore closure */	\
d478 1
a478 1
	move	$5, $4			;/* preserve handler result */	\
d482 1
a482 1
	nop				;				\
d486 1
a486 1
	move	$4, $5			;/* restore handler result */	\
@


1.16
log
@Fixing syntax error
@
text
@d19 3
d71 1
d109 4
a112 3
 * save registers prior to calling C. It also saves $5 (the callee's
 * closure), although this need not be preserved, we do need to return
 * to ML with a GCable value in this register.
d131 1
d133 1
a133 1
	sw	$5,  44($29)		; 			\
d137 1
d139 1
a148 1
	lw	$5 , 44($29)		;/* restore closure */	\
d161 2
d189 1
d191 1
a191 1
	sw	$0, 84($29)		; /* clear padding word */
d194 1
d196 1
d301 52
d355 22
a376 45
/* Saves the global registers in an ml_state indicated by the first
 * arg register. The stack limit register $7 is not stored. */

#define store_ML_state_with(use)				\
	sw	$1, 0(use)		;			\
	sw	$2, 4(use)		;			\
	sw	$3, 8(use)		;			\
	sw	$8, 16(use)		;			\
	sw	$9, 20(use)

/* Saves the global registers in an ml_state given by the first arg,
   leaving the address in the second arg register. The stack register
   $7 is not stored */

#define store_ML_state(where, use)				\
	la	use, where		;			\
	nop				;			\
        store_ML_state_with(use)

/* Loads the global registers from an ml_state indicated by the first
   arg register. The stack register is loaded and then ORed with the
   interrupt stack slot on the implicit vector, which is left in the
   second arg. This is so when we return to ML the stack register is
   -1 if there has been an asynchronous event */

#define load_ML_state_with(use, intreg)				\
	lw	$1, 0(use)		;			\
	lw	$2, 4(use)		;			\
	lw	$7, 12(use)		;			\
	lw	$9, 20(use)		;			\
	lw	$8, 16(use)		;			\
	lw	intreg, IMPLICIT_interrupt($9);			\
	lw	$3, 8(use)		;			\
	or	$7, $7, intreg

/* Loads the global registers from an ml_state labelled with the first
   arg, leaving the address in the second arg.  The stack register $7
   is ORed with the interrupt stack slot on the implicit vector, which
   is left in the third arg. This is so when we return to ML the stack
   register is -1 if there has been an asynchronous event */

 #define load_ML_state(where, use, intreg)			\
	la	use, where		;			\
	nop				;			\
	load_ML_state_with(use,intreg)
d380 1
a380 3
 * The C return value is returned in $4. Registers $16 and $17 are
 * used. $16 finishes with the address of ml_state, $17 with that of
 * c_state. The sp should not be used in the following instruction */
d383 2
a384 2
	store_ML_state(ml_state,$16) 	;/* Use a caller save arg */ 	\
	sw	$29, 24($16)		;/* Save ML sp   	     */	\
d386 2
a387 3
	la	$17, c_state		;				\
	nop				;				\
	lw	$29, 0($17)		; /* Fetch the previous C sp */	\
d389 1
a389 1
	nop				; 				\
d392 5
a396 4
	/* $16 (ml_state) and $17 (c_state) are preserved in C */	\
	sw	$29, 0($17)		; /* re-save the C sp */       	\
	load_ML_state_with($16,$18)	;				\
	lw	$29, 24($16)		 /* re-load the ML sp */
d418 1
a418 2
 * The ML stack is unwound by repeatedly popping
 * until the first register arg equals $18.
d420 1
a420 1
 * The other arg is a label prefix.
d423 1
a423 1
#define unwind_stack(to_where, label)					\
d426 1
a426 1
	nop				;				\
a427 9
	lw	$31, 4($29)		;/* Look at closure in this frame */\
	ori	$5, $0, STACK_C_CALL	;				\
	bne	$5, $31, label ## _unw_skip ;/* if we must restore c_state.sp */\
	nop				;				\
	lw	$17, 12($sp)		;/* then load it */		\
	la	$16, c_state		;				\
	nop				;/* delay slot */		\
	sw	$17, 0($16)		;/* and save it in c_state.sp */\
label ## _unw_skip:			;				\
d430 1
a430 1
	bnez	$5, label ## _unw_notML	;/*if so, restore callee-saves */\
d437 2
a438 2
	la	$16, label ## _unw_notML;/* base for computed goto */	\
	.set noat			;     /* and revert */		\
d451 1
a451 1
label ## _unw_notML:			;				\
d453 7
d464 1
a464 1
	bne	to_where, $18, label ## _unw_loop ;			\
@


1.15
log
@Debugger stuff
@
text
@d19 3
d374 1
a374 1
        /* This should be 4 with a saved argument also */
@


1.14
log
@c_raise getting the wrong closure.
@
text
@d19 3
d371 1
@


1.13
log
@Rewrote most of these macros.
@
text
@d19 3
a291 1
	sw	$6, 32(use)		;			\
@


1.12
log
@Added macros to save and restore fp registers
@
text
@d19 3
d58 1
d93 8
a100 54
/* Saves the global registers in a C struct labelled with the first
 * arg, address of that label in the second arg register.  The stack
 * register $7 is only stored if is not -1. */

#define store_ML_state(where, use,label)			\
	la	use, where		;			\
	nop				;			\
	sw	$1, 0(use)		;			\
	sw	$2, 4(use)		;			\
	sw	$3, 8(use)		;			\
	sw	$6, 32(use)		;			\
	bltz	$7, label ## store	;/* Is stack negative? */	\
	sw	$8, 16(use)		;			\
	sw	$7, 12(use)		;			\
label ## store:	sw	$9, 20(use)

/* Loads the global registers from a C struct labelled with the first
 * arg, leaving the address of that label in the second arg.  The
 * stack register %g6 is ORed with the interrupt stack slot on the
 * implicit vector, which is left in the third arg */

#define load_ML_state(where, use, intreg)			\
	la	use, where		;			\
	nop				;			\
	lw	$1, 0(use)		;			\
	lw	$2, 4(use)		;			\
	lw	$6, 32(use)		;			\
	lw	$7, 12(use)		;			\
	lw	$9, 20(use)		;			\
	lw	$8, 16(use)		;/* Reordered to avoid nop */	\
	lw	intreg, IMPLICIT_interrupt($9);			\
	lw	$3, 8(use)		;/* Reordered to avoid nop */	\
	or	$7, $7, intreg

/* Saves those global registers used by C in an aligned area at an
 * address (first arg).  Also sets reg (second arg) to address. */

#define	address_C_globals(where, use)				\
	la	use, where		;			\
	nop

#define store_C_globals(where, use)				\
	la	use, where

/* Loads the global registers used by C from an aligned area at an
 * address (first arg). Also sets reg (second arg) to the address */

#define load_C_globals(where, use)				\
	la	use, where

/*
 * save_ML_regs
 * create a new ml stack frame to save all the ml callee save
 * registers prior to calling C
d103 1
a103 1
#define	save_ML_regs			;			\
d106 5
a110 4
	subu	$29, 12*4		;/* Create frame */	\
	sw	$6, 4($29)		;			\
	sw	$31, 8($29)		;			\
	sw	$10, 12($29)		;			\
d118 17
a134 2
	move	$6, $5			;/* As per normal function entry */	\
	sw	$5, 44($29)
d137 8
a144 3
 * save_all_ML_regs
 * create a new ml stack frame to save all the ml gc (including caller saves)
 * registers prior to calling C
d147 1
a147 1
#define	save_all_ML_regs			;		\
d150 28
a177 35
	subu	$29, 12+80+4		;/* Create aligned frame */	\
	sw	$6, 4($29)		;			\
	sw	$31, 8($29)		;			\
	sw	$8, 12($29)		;			\
	sw	$9, 16($29)		;			\
	sw	$10, 20($29)		;			\
	sw	$11, 24($29)		;			\
	sw	$12, 28($29)		;			\
	sw	$13, 32($29)		;			\
	sw	$14, 36($29)		;			\
	sw	$15, 40($29)		;			\
	sw	$16, 44($29)		;			\
	sw	$17, 48($29)		;			\
	sw	$18, 52($29)		;			\
	sw	$19, 56($29)		;			\
	sw	$20, 60($29)		;			\
	sw	$21, 64($29)		;			\
	sw	$22, 68($29)		;			\
	sw	$23, 72($29)		;			\
	sw	$24, 76($29)		;			\
	sw	$25, 80($29)		;			\
	sw	$4, 84($29)		;			\
	sw	$5, 88($29)		;			\
	sw	$0, 92($29)		; /* clear padding word */

/*
 * load_ML_regs
 * restore all the ml callee save
 * registers after calling C
 */

#define	load_ML_regs						\
	lw	$6, 4($29)		;			\
	lw	$31, 8($29)		;			\
	lw	$10, 12($29)		;			\
d183 140
a322 5
	lw	$24, 36($29)		;			\
	lw	$25, 40($29)		;			\
	lw	$5, 44($29)		;			\
	move	$29, $30		;			\
	lw	$30, 0($29)		;/* Can't delay this */
d324 4
a327 5
/*
 * load_all_ML_regs
 * restore all ml registers (including caller saves)
 * after calling C
 */
d329 5
a333 126
#define	load_all_ML_regs		;			\
	lw	$6, 4($29)		;			\
	lw	$31, 8($29)		;			\
	lw	$8, 12($29)		;			\
	lw	$9, 16($29)		;			\
	lw	$10, 20($29)		;			\
	lw	$11, 24($29)		;			\
	lw	$12, 28($29)		;			\
	lw	$13, 32($29)		;			\
	lw	$14, 36($29)		;			\
	lw	$15, 40($29)		;			\
	lw	$16, 44($29)		;			\
	lw	$17, 48($29)		;			\
	lw	$18, 52($29)		;			\
	lw	$19, 56($29)		;			\
	lw	$20, 60($29)		;			\
	lw	$21, 64($29)		;			\
	lw	$22, 68($29)		;			\
	lw	$23, 72($29)		;			\
	lw	$24, 76($29)		;			\
	lw	$25, 80($29)		;			\
	lw	$4, 84($29)		;			\
	lw	$5, 88($29)		;			\
	move	$29, $30		;			\
	lw	$30, 0($29)		;/* Can't delay this */

#define store_fps(where)					\
        sub where,where,128             ;/* Make some room */   \
        swc1	$f0, 0(where)		;			\
        swc1	$f1, 4(where)		;			\
        swc1	$f2, 8(where)		;			\
        swc1	$f3, 12(where)		;			\
        swc1	$f4, 16(where)		;			\
        swc1	$f5, 20(where)		;			\
        swc1	$f6, 24(where)		;			\
        swc1	$f7, 28(where)		;			\
        swc1	$f8, 32(where)		;			\
        swc1	$f9, 36(where)		;			\
        swc1	$f10, 40(where)		;			\
        swc1	$f11, 44(where)		;			\
        swc1	$f12, 48(where)		;			\
        swc1	$f13, 52(where)		;			\
        swc1	$f14, 56(where)		;			\
        swc1	$f15, 60(where)		;			\
        swc1	$f16, 64(where)		;			\
        swc1	$f17, 68(where)		;			\
        swc1	$f18, 72(where)		;			\
        swc1	$f19, 76(where)		;			\
        swc1	$f20, 80(where)		;			\
        swc1	$f21, 84(where)		;			\
        swc1	$f22, 88(where)		;			\
        swc1	$f23, 92(where)		;			\
        swc1	$f24, 96(where)		;			\
        swc1	$f25, 100(where)	;			\
        swc1	$f26, 104(where)	;			\
        swc1	$f27, 108(where)	;			\
        swc1	$f28, 112(where)	;			\
        swc1	$f29, 116(where)	;			\
        swc1	$f30, 120(where)	;			\
        swc1	$f31, 124(where)	;	

#define load_fps(where)			       			\
        lwc1	$f0, 0(where)		;			\
        lwc1	$f1, 4(where)		;			\
        lwc1	$f2, 8(where)		;			\
        lwc1	$f3, 12(where)		;			\
        lwc1	$f4, 16(where)		;			\
        lwc1	$f5, 20(where)		;			\
        lwc1	$f6, 24(where)		;			\
        lwc1	$f7, 28(where)		;			\
        lwc1	$f8, 32(where)		;			\
        lwc1	$f9, 36(where)		;			\
        lwc1	$f10, 40(where)		;			\
        lwc1	$f11, 44(where)		;			\
        lwc1	$f12, 48(where)		;			\
        lwc1	$f13, 52(where)		;			\
        lwc1	$f14, 56(where)		;			\
        lwc1	$f15, 60(where)		;			\
        lwc1	$f16, 64(where)		;			\
        lwc1	$f17, 68(where)		;			\
        lwc1	$f18, 72(where)		;			\
        lwc1	$f19, 76(where)		;			\
        lwc1	$f20, 80(where)		;			\
        lwc1	$f21, 84(where)		;			\
        lwc1	$f22, 88(where)		;			\
        lwc1	$f23, 92(where)		;			\
        lwc1	$f24, 96(where)		;			\
        lwc1	$f25, 100(where)	;			\
        lwc1	$f26, 104(where)	;			\
        lwc1	$f27, 108(where)	;			\
        lwc1	$f28, 112(where)	;			\
        lwc1	$f29, 116(where)	;			\
        lwc1	$f30, 120(where)	;			\
        lwc1	$f31, 124(where)	;			\
        nop				;  /* just for luck */

#define store_callee_save_fps(where)					\
        sub where,where,40              ;/* Make some room */   \
        swc1	$f0, 0(where)		;			\
        swc1	$f1, 4(where)		;			\
        swc1	$f2, 8(where)		;			\
        swc1	$f3, 12(where)		;			\
        swc1	$f4, 16(where)		;			\
        swc1	$f5, 20(where)		;			\
        swc1	$f6, 24(where)		;			\
        swc1	$f7, 28(where)		;			\
        swc1	$f26, 32(where)	;			\
        swc1	$f27, 36(where)	;

#define load_callee_save_fps(where)	       			\
        lwc1	$f0, 0(where)		;			\
        lwc1	$f1, 4(where)		;			\
        lwc1	$f2, 8(where)		;			\
        lwc1	$f3, 12(where)		;			\
        lwc1	$f4, 16(where)		;			\
        lwc1	$f5, 20(where)		;			\
        lwc1	$f6, 24(where)		;			\
        lwc1	$f7, 28(where)		;			\
        lwc1	$f26, 32(where)	        ; /* I'm not sure this is necessary */ \
        lwc1	$f27, 36(where)	        ;			\
        nop				;  /* just for luck */

/* Call C from ML : 
 * Saves the ML state and restore the C state, then calls the
 * function, propagating registers $4 to $6 as arguments for
 * C.	 The C return value is returned in $4. */
d336 5
a340 4
	store_ML_state(ml_state, $16, what)	;/* Use a caller save arg */	\
	sw	$29, 24($16)		;/* Save ML stack base	     */	\
	sw	$30, 0($29)		;/* Ensure fp correct in this frame */	\
	address_C_globals(c_state, $17)	;				\
d343 2
a344 1
	nop				; /* Save ptr to ML frame for GC*/\
d346 17
a362 4
	address_C_globals(c_state, $16)	;				\
	sw	$29, 0($16)		;				\
	load_ML_state(ml_state,$17,$18)	;				\
	lw	$29, 24($17)		 /* Return to ML stack	     */
d364 4
d369 1
a369 1
 * 
d371 1
a371 1
 * until the first register arg equals $1.
a375 2
#include "mach_values.h"

d377 2
a378 2
label ## unwind:			;				\
	beqz	$0, label ## start	;				\
d380 2
a381 2
label ## loop:				;				\
	lw	$31, 4($29)		;/* Look at closure in this frame */	\
d383 1
a383 1
	bne	$5, $31, label ## c	;/* Branch if no c_state.sp to restore */	\
d385 6
a390 5
	lw	$17, 12($sp)		;/* old c_sp */			\
	address_C_globals(c_state, $16)	;				\
	sw	$17, 0($16)		;/* Save it back in c_state.sp */	\
label ## c:				;				\
	andi	$5, $6, 3		;/* tagged? */			\
d392 1
a392 3
	bnez	$5, label ## done	;				\
	nop				;				\
	lw	$5, -1($6)		;/* Current code vector */	\
d394 3
a396 1
	lw	$5, -1($5)		;/*Ancillary */			\
d398 6
a403 3
	srl	$5, $5, CCODE_SAVES_SHIFT	;			\
	andi	$5, $5, CCODE_MAX_SAVES	;/* Number of callee saves */	\
	beqz	$5, label ## done	;/* Branch if none */		\
d405 10
a414 24
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$10, 12($29)		;/* Restore first callee save */	\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$11, 16($29)		;/* Restore second callee save */	\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$12, 20($29)		;/*etc */			\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$13, 24($29)		;/*etc */			\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$14, 28($29)		;/*etc */			\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$15, 32($29)		;/*etc */			\
	subu	$5, 1			;				\
	beqz	$5, label ## done	;				\
	lw	$24, 36($29)		;/*etc */			\
	lw	$25, 40($29)		;/*etc */			\
label ## done:				;				\
	lw	$6, 4($29)		;/* Get caller's closure back */	\
d418 23
a440 19
label ## start:				;				\
	bne	to_where, $1, label ##loop	;			\
	nop			;					\
label ## exit:

/* This stuff is part of unwind_stack, but isn't implemented at present */
#if 0	/* Some stuff to unwind the stack if more than one is in use */
	mov	%o0, %i0		/* Propagate handler result */  \
	save	%sp, -0x40, %sp						\
	mov	%fp, %o0						\
	ML_to_C(unwind_stack)		/* Unwind stack extensions */   \
	addcc	%g6, 1, %g0		/* Is an event flagged? */	\
	beq,a	label ## exit		/* Finished if so. */		\
	restore								\
	sethi	%hi(_ml_state), %o1					\
	or	%o1, %lo(_ml_state), %o1				\
	ld	[%o1+16], %g6		/* Install the new stack area */\
	restore								
#endif									
@


1.11
log
@Add clean_caller_saves macro.
@
text
@d19 3
d248 96
@


1.10
log
@Make 'save_all_ML_regs' stack frame double-word aligned.
@
text
@d19 3
d58 1
a58 1
/* Clean the registers in the current window */
d60 2
a61 7
#define clean_current_registers		\
	move	$10,	$0	;	\
	move	$11,	$0	;	\
	move	$12,	$0	;	\
	move	$13,	$0	;	\
	move	$14,	$0	;	\
	move	$15,	$0	;	\
d69 10
a78 1
	move	$23,	$0	;	\
d81 4
@


1.9
log
@Add closure to ml_state
@
text
@d19 3
d157 1
a157 1
	subu	$29, 12+80		;/* Create frame */	\
d179 2
a180 1
	sw	$5, 88($29)
d338 1
a338 1
 * copy callee save values plus linkage down one word
d340 4
a343 4
#define	copy_down(size,pointer,temp)					\
	subu	$29, 4			;/* Create space */		\
	addu	pointer, $29, 4		;/* Pointer */			\
copy_down ## start:			;				\
d346 2
a347 2
	sw	temp, -4(pointer)	;/* copy down */		\
	bnez	size, copy_down ## start	;/* Loop if more to do */	\
d352 1
a352 1
 * copy callee save values plus linkage up one word
d354 1
a354 1
#define	copy_up(size,pointer,temp)					\
d356 3
a358 3
	addu	pointer, $29, temp		;/* Pointer */			\
copy_up ## start:			;				\
	lw	temp, -4(pointer)	;				\
d361 1
a361 1
	bnez	size, copy_up ## start	;/* Loop if more to do */	\
d363 1
a363 2
	addu	$29, 4			;/* Throw away space */

@


1.9.1.1
log
@branched from 1.9
@
text
@a18 3
 * Revision 1.9  1994/08/03  13:42:02  jont
 * Add closure to ml_state
 *
@


1.8
log
@Ensure stub_c etc preserve $5
@
text
@d19 3
d82 1
d98 1
d142 1
@


1.7
log
@Fix tagged value test in unwind stack
@
text
@d19 3
d126 1
a126 1
	subu	$29, 11*4		;/* Create frame */	\
d136 2
a137 1
	sw	$25, 40($29)
d189 1
@


1.6
log
@Move architecture dependent stuff from values.h into mach_values.h
@
text
@d19 3
d262 2
a263 2
	andi	$5, $6, 7		;/* tagged? */			\
	subu	$5, 5			;				\
@


1.5
log
@Remove handler and implicit from register saved when entering stubs
@
text
@d19 3
d244 1
a244 29
/* From values.h */
#define CCODE_SPILLS_BITS	11
#define CCODE_SAVES_BITS	5
#define CCODE_NUMBER_BITS	8

/* The next few macros calculate the sizes and offsets of the other
fields; they're used in other macros in this file but shouldn't be
used directly.
 */

#define CCODE_INTERCEPT_BITS	(31 - CCODE_SPILLS_BITS - CCODE_SAVES_BITS - CCODE_NUMBER_BITS)
#define CCODE_LEAF_BIT		(31 - CCODE_SPILLS_BITS - CCODE_SAVES_BITS)
#define CCODE_SPILLS_SHIFT	(32 - CCODE_SPILLS_BITS)
#define CCODE_SAVES_SHIFT	(32 - CCODE_SPILLS_BITS - CCODE_SAVES_BITS)
#define CCODE_INTERCEPT_SHIFT	CCODE_NUMBER_BITS
#define CCODE_INTERCEPT_MASK	((1 << CCODE_INTERCEPT_BITS)-1)

/* Now we get on to macros used out there in the runtime system:

CCODE_MAX_<field> is the maximum valid number in a field.
CCODE_NO_INTERCEPT is the value placed in the 'intercept' field of a
code item not compiled for tracing or call-counting.
*/

#define CCODE_MAX_NUMBER	((1 << CCODE_NUMBER_BITS)-1)
#define CCODE_MAX_SAVES		((1 << CCODE_SAVES_BITS)-1)
#define CCODE_MAX_SPILL		((1 << CCODE_SPILLS_BITS)-1)
#define CCODE_MAX_INTERCEPT	(CCODE_INTERCEPT_MASK -1)
#define CCODE_NO_INTERCEPT	CCODE_INTERCEPT_MASK
@


1.4
log
@Add unwind_stack
@
text
@d19 3
d117 1
a117 1
	subu	$29, 12+40+4		;/* Create frame */	\
d120 8
a127 10
	sw	$8, 12($29)		;			\
	sw	$9, 16($29)		;			\
	sw	$10, 20($29)		;			\
	sw	$11, 24($29)		;			\
	sw	$12, 28($29)		;			\
	sw	$13, 32($29)		;			\
	sw	$14, 36($29)		;			\
	sw	$15, 40($29)		;			\
	sw	$24, 44($29)		;			\
	sw	$25, 48($29)
d171 8
a178 10
	lw	$8, 12($29)		;			\
	lw	$9, 16($29)		;			\
	lw	$10, 20($29)		;			\
	lw	$11, 24($29)		;			\
	lw	$12, 28($29)		;			\
	lw	$13, 32($29)		;			\
	lw	$14, 36($29)		;			\
	lw	$15, 40($29)		;			\
	lw	$24, 44($29)		;			\
	lw	$25, 48($29)		;			\
@


1.3
log
@Get clean_current_registers round the right way
@
text
@d19 3
d137 1
a137 1
	subu	$29, 12+80+4		;/* Create frame */	\
d159 1
a159 1
	sw	$5, 84($29)
a233 1
#if 0
d236 15
a250 2
 * The ML stack is unwound by repeatedly restoring register windows
 * until the first register arg equals $1.  the other arg is a label prefix.*/
d252 20
d273 58
a330 8
label ## unwind:							\
	beqz	$0, label ## start					\
	nop								\
label ## loop:								\
        lw	$29,[$29 + 0]	 /* Pop one stack frame */		\
label ## start:								\
	bnez	to_where, $1, label ##loop				\
	nop								\
d334 1
a334 1
	ML_to_C(_unwind_stack)		/* Unwind stack extensions */   \
d340 32
a371 3
	ld	[%o1+16], %g6		/* Install the new stack area */ \
	restore								\
label ## exit:
a372 1
#endif
@


1.2
log
@Modifications for store_C_globals etc
@
text
@d19 3
d37 16
a52 16
	move	$0,	$10	;	\
	move	$0,	$11	;	\
	move	$0,	$12	;	\
	move	$0,	$13	;	\
	move	$0,	$14	;	\
	move	$0,	$15	;	\
	move	$0,	$16	;	\
	move	$0,	$17	;	\
	move	$0,	$18	;	\
	move	$0,	$19	;	\
	move	$0,	$20	;	\
	move	$0,	$21	;	\
	move	$0,	$22	;	\
	move	$0,	$23	;	\
	move	$0,	$24	;	\
	move	$0,	$25
@


1.1
log
@new file
@
text
@d18 4
a21 1
 * $Log$
d86 4
d100 1
a100 1
 * save_ml_regs
d123 34
a156 1
 * load_ml_regs
d177 32
d216 3
a218 3
	sw	$29, 28($16)		;/* Save ML stack base	     */	\
	load_C_globals(c_state, $17)	;				\
	nop				;				\
a219 3
	nop				;				\
	subu	$29, 20+4		; /* Space for parameters and link */ \
	sw	$31, 16($29)		; /* Save return address */	\
d221 1
a221 1
	sw	$29, 24($16)		; /* Save ptr to ML frame for GC*/\
d223 4
a226 4
	sw	$31, 16($29)		; /* Get return address back */	\
	store_C_globals(c_state, $16)	;				\
	load_ML_state(ml_state,$17,$18);				\
	lw	$29, 28($17)		 /* Return to ML stack	     */
@
