head	1.25;
access;
symbols
	MLW_daveb_inline_1_4_99:1.25.1
	MLWorks_21c0_1999_03_25:1.25
	MLWorks_20c1_1998_08_20:1.24
	MLWorks_20c0_1998_08_04:1.24
	MLWorks_20b2c2_1998_06_19:1.24
	MLWorks_20b2_Windows_1998_06_12:1.24
	MLWorks_20b1c1_1998_05_07:1.24
	MLWorks_20b0_1998_04_07:1.24
	MLWorks_20b0_1998_03_20:1.24
	MLWorks_20m2_1998_02_16:1.21
	MLWorks_MM_adapt:1.21.3
	MLWorks_20m1_1997_10_23:1.21
	MLWorks_11r1:1.19.6.1.1.1.1
	MLWorks_workspace_97:1.21.2
	MLWorks_dt_wizard:1.21.1
	MLWorks_11c0_1997_09_09:1.19.6.1.1.1
	MLWorks_10r3:1.19.6.1.3
	MLWorks_10r2_551:1.19.6.1.2
	MLWorks_11:1.19.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.19.6.1
	MLWorks_20m0_1997_06_20:1.21
	MLWorks_1_0_r2c2_1997_06_14:1.19.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.19.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.19.6
	MLWorks_BugFix_1997_04_24:1.19
	MLWorks_1_0_r2_Win32_1997_04_11:1.19
	MLWorks_1_0_r2_Unix_1997_04_04:1.19
	MM_ML_release_korma_1997_04_01:1.19
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.19.4.1.1
	MLWorks_gui_1996_12_18:1.19.5
	MLWorks_1_0_Win32_1996_12_17:1.19.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.19.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.19.1.1
	JFHrts:1.19.3
	MLWorks_1_0_Irix_1996_11_28:1.19.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.19.2
	MLWorks_1_0_Unix_1996_11_14:1.19.1
	MLWorks_Open_Beta2_1996_10_11:1.17.2
	MLWorks_License_dev:1.17.1
	MLWorks_1_open_beta_1996_09_13:1.15.1
	MLWorks_Open_Beta_1996_08_22:1.15
	MLWorks_Beta_1996_07_02:1.15
	MLWorks_Beta_1996_06_07:1.15
	MLWorks_Beta_1996_06_06:1.15
	MLWorks_Beta_1996_06_05:1.15
	MLWorks_Beta_1996_06_03:1.15
	MLWorks_Beta_1996_05_31:1.15
	MLWorks_Beta_1996_05_30:1.15
	hope_poo:1.3.1
	ML_beta_release_12/08/94:1.3.1.1
	ML_beta_release_03/08/94:1.3;
locks; strict;
comment	@ * @;


1.25
date	98.09.18.11.09.23;	author jont;	state Exp;
branches
	1.25.1.1;
next	1.24;

1.24
date	98.03.19.11.53.59;	author jont;	state Exp;
branches;
next	1.23;

1.23
date	98.03.03.17.15.46;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	98.02.18.17.43.58;	author jont;	state Exp;
branches;
next	1.21;

1.21
date	97.06.03.16.27.27;	author jont;	state Exp;
branches
	1.21.1.1
	1.21.2.1
	1.21.3.1;
next	1.20;

1.20
date	97.05.30.10.44.20;	author jont;	state Exp;
branches;
next	1.19;

1.19
date	96.11.07.17.35.52;	author stephenb;	state Exp;
branches
	1.19.1.1
	1.19.2.1
	1.19.3.1
	1.19.4.1
	1.19.5.1
	1.19.6.1;
next	1.18;

1.18
date	96.11.04.16.10.44;	author stephenb;	state Exp;
branches;
next	1.17;

1.17
date	96.10.03.13.31.10;	author stephenb;	state Exp;
branches
	1.17.1.1
	1.17.2.1;
next	1.16;

1.16
date	96.09.06.13.16.34;	author stephenb;	state Exp;
branches;
next	1.15;

1.15
date	96.02.14.17.34.59;	author jont;	state Exp;
branches
	1.15.1.1;
next	1.14;

1.14
date	96.02.14.12.25.46;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	96.01.11.17.24.15;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.12.18.13.55.39;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	95.11.21.14.32.03;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.05.30.10.16.00;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.05.24.10.38.15;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.05.04.10.49.21;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.29.14.59.15;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.03.20.12.43.23;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.03.16.14.24.13;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	95.03.01.17.29.07;	author matthew;	state Exp;
branches;
next	1.3;

1.3
date	94.07.18.16.42.12;	author jont;	state Exp;
branches
	1.3.1.1;
next	1.2;

1.2
date	94.07.18.14.16.00;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.04.00;	author jont;	state Exp;
branches;
next	;

1.3.1.1
date	95.07.05.10.29.58;	author hope;	state Exp;
branches;
next	;

1.15.1.1
date	96.09.13.11.24.17;	author hope;	state Exp;
branches;
next	;

1.17.1.1
date	96.10.07.16.14.35;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.17.11.34.01;	author hope;	state Exp;
branches;
next	;

1.19.1.1
date	96.11.14.12.59.41;	author hope;	state Exp;
branches
	1.19.1.1.1.1;
next	;

1.19.1.1.1.1
date	96.11.28.15.09.43;	author hope;	state Exp;
branches;
next	;

1.19.2.1
date	96.11.22.18.17.28;	author hope;	state Exp;
branches;
next	;

1.19.3.1
date	96.12.17.10.04.12;	author hope;	state Exp;
branches;
next	;

1.19.4.1
date	96.12.17.17.55.48;	author hope;	state Exp;
branches
	1.19.4.1.1.1;
next	;

1.19.4.1.1.1
date	97.02.24.11.47.21;	author hope;	state Exp;
branches;
next	;

1.19.5.1
date	96.12.18.09.50.24;	author hope;	state Exp;
branches;
next	;

1.19.6.1
date	97.05.12.10.44.06;	author hope;	state Exp;
branches
	1.19.6.1.1.1
	1.19.6.1.2.1
	1.19.6.1.3.1;
next	;

1.19.6.1.1.1
date	97.07.28.18.24.27;	author daveb;	state Exp;
branches
	1.19.6.1.1.1.1.1;
next	;

1.19.6.1.1.1.1.1
date	97.10.07.11.50.15;	author jkbrook;	state Exp;
branches;
next	;

1.19.6.1.2.1
date	97.09.08.17.17.47;	author daveb;	state Exp;
branches;
next	;

1.19.6.1.3.1
date	97.09.09.14.14.00;	author daveb;	state Exp;
branches;
next	;

1.21.1.1
date	97.09.10.19.30.14;	author brucem;	state Exp;
branches;
next	;

1.21.2.1
date	97.09.11.20.59.50;	author daveb;	state Exp;
branches;
next	;

1.21.3.1
date	97.10.31.13.42.59;	author nickb;	state Exp;
branches;
next	;

1.25.1.1
date	99.04.01.17.59.57;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.25
log
@[Bug #20124]
Fix is_ml_frame to use validate_ml_address,
and make backtrace more robust against bad addresses
@
text
@/*  === MIPS STACK ROUTINES ===
 *
 *  Copyright (C) 1994 Harlequin Ltd
 *
 *  Description
 *  -----------
 * All architecture-dependent routines that deal with the stack.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:arch:MIPS:stacks.c,v $
 * Revision 1.24  1998/03/19  11:53:59  jont
 * [Bug #70026]
 * Allow profiling of stub_c functions, recording the time according
 * to the name of the runtime system functions
 *
 * Revision 1.23  1998/03/03  17:15:46  jont
 * [Bug #70018]
 * Split stack_crawl into two phases
 *
 * Revision 1.22  1998/02/18  17:43:58  jont
 * [Bug #30242]
 * Ensure we don't fix pseudo return addresses in raise frames
 * Also check return address we fix are within code
 *
 * Revision 1.21  1997/06/03  16:27:27  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
 * Revision 1.20  1997/05/30  10:44:20  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
 * Revision 1.18  1996/11/04  16:10:44  stephenb
 * [Bug #1441]
 * frame_next: change the offset to be a byte rather than word
 * offset since instructions are not word aligned on an I386 and
 * so the debugger has been changed to expect byte offsets.
 *
 * Revision 1.17  1996/10/03  13:31:10  stephenb
 * [Bug #1446]
 * frame_next: adjust the offset by -2 in the case of an ML frame.
 *
 * Revision 1.16  1996/09/06  13:16:34  stephenb
 * [Bug #1595]
 *   Changed the offset calculatation in frame_next to use the return
 *   address of in the frame pointed to by the frame pointer instead of
 *   the stack pointer.  That is, the line :-
 *
 *     FIELD(result, 2) = MLINT((word *)sp->lr - CCODESTART(code));
 *
 *   becomes
 *
 *     FIELD(result, 2) = MLINT((word *)sp->fp->lr - CCODESTART(code));
 *
 *   Also removed flush and ml_is_top_frame since they are never used.
 *
 * Revision 1.15  1996/02/14  17:34:59  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.14  1996/02/14  12:25:46  nickb
 * Add heap-exploration hooks.
 *
 * Revision 1.13  1996/01/11  17:24:15  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.12  1995/12/18  13:55:39  matthew
 * Adding set_frame_return_value
 *
 * Revision 1.11  1995/11/21  14:32:03  jont
 * Add debugger_double for getting floats straight from spills
 *
 * Revision 1.10  1995/05/30  10:16:00  nickb
 * Add frame_argument function.
 *
 * Revision 1.9  1995/05/24  10:38:15  nickb
 * Fix all the register save frames, not just one.
 *
 * Revision 1.8  1995/05/04  10:49:21  nickb
 * Clear up SPARCisms in is_ml_frame &c.
 *
 * Revision 1.7  1995/03/29  14:59:15  nickb
 * Threads system.
 *
 * Revision 1.6  1995/03/20  12:43:23  matthew
 * Adding is_top_frame ml functions
 *
 * Revision 1.5  1995/03/16  14:24:13  matthew
 * Adding check on stack_top
 *
 * Revision 1.4  1995/03/01  17:29:07  matthew
 * Adding is_ml_frame
 *
 * Revision 1.3  1994/07/18  16:42:12  jont
 * Fix use of fix_reg to avoid ++ in macro call
 * Sort out stack_crawl to spot cases where there is no ml stack (eg image saving)
 *
 * Revision 1.2  1994/07/18  14:16:00  jont
 * Modify for MIPS version
 *
 * Revision 1.1  1994/07/12  12:04:00  jont
 * new file
 *
 */

#include <assert.h>

#include "mltypes.h"
#include "diagnostic.h"
#include "values.h"
#include "stacks.h"
#include "arena.h"
#include "mem.h"
#include "fixup.h"
#include "environment.h"
#include "state.h"
#include "interface.h"
#include "utils.h"
#include "allocator.h"
#include "ansi.h"
#include "tags.h"
#include "explore.h"
#include "ml_utilities.h"

/* First the GC stack-crawling code.
 *
 *  NOTE: 1. This code is highly MIPS-specific
 *
 *  This function fixes the stack contents between GC_SP and the
 *  first frame pointer since entry to ML.  fix() is called on any
 *  GC values, and link registers (return addresses) are shifted to
 *  correspond with any movement of code.
 *
 *  On entry GC_SP should point the last save area that needs to be fixed.
 *  This area contains the link register which points into the innermost
 *  executing ML function, i.e., the last link that needs fixing.
 *
 *  The obvious one-pass version of this will not work because a
 *  closure may be referred to by more than one frame.  If the closure
 *  is fixed the first time it is seen then information is lost and
 *  later link registers will not be fixed.
 *
 *  The number of non-GC spills in each frame is fetched from the
 *  first word of the code vector.
 */

#define final_frame(sp,thread) ((word)((sp)->fp)==(thread)->ml_state.stack_top)

/* fix a 'register save frame', i.e. a frame saved when entering C
 * from ML, consisting solely of ML register saves (with no
 * stack-allocated objects or non-gcable values) */

static inline mlval *fix_reg_save_frame(struct stack_frame *sp, mlval *to)
{
  mlval *base = (mlval *)(sp+1);
  mlval *top = (mlval *)(sp->fp);
  while (base < top) {
    fix_reg(to, base);
    base++;
  }
  return to;
}

extern void stack_crawl_phase_one(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  DIAGNOSTIC(4, "stack_crawl first pass:", 0, 0);

  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    DIAGNOSTIC (4,"  thread %d",thread->number,0);
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      /* turn each ML link slot into an offset from the closure code address */
      for(; !(final_frame(sp,thread)); sp = sp->fp)
	if(SPACE_TYPE(sp->lr) == TYPE_FROM) {
	  mlval codeptr = FIELD(sp->closure,0);
	  DIAGNOSTIC(5, "   frame 0x%X  next 0x%X", sp, sp->fp);
	  DIAGNOSTIC(5, "     lr 0x%X from `%s'", sp->lr,
		     CSTRING(CCODENAME(codeptr)));
	  if (sp->lr) {
	    assert(pc_in_closure(sp->lr, sp->closure));
	    sp->lr -= codeptr;			/* NB: no longer aligned */
	  }
	  DIAGNOSTIC(5, "     lr is 0x%X+0x%X", codeptr, sp->lr);
	}
    }
  }
}
extern mlval *stack_crawl_phase_two(mlval *to)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
  DIAGNOSTIC(4, " second pass", 0, 0);
  /* Now fix everything on the stacks, restoring link slots as we go */
  
  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    DIAGNOSTIC (4,"  thread %d",thread->number,0);
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      int register_save_frame = 1;
      for(; !(final_frame(sp,thread)); sp = sp->fp) {
	struct stack_frame *fp = sp->fp;
	DIAGNOSTIC(5, "   frame 0x%X (to = 0x%X)", sp, to);
	
	if (register_save_frame) {
	  to = fix_reg_save_frame(sp,to);
	  register_save_frame = 0;
	}

	if(MLVALISPTR(sp->closure)) {
	  mlval *top, closure, code;
	  fix(to, &sp->closure);		/* fix the caller's closure */
	  closure = sp->closure;
	  fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	  code = FIELD(closure, 0);
	  
	  /* if the link address is unaligned, it must be restored: */
	  if(word_align(sp->lr) != sp->lr) {
	    DIAGNOSTIC(5, "     lr is 0x%X+0x%X", code, sp->lr);
	    sp->lr += code;
	    DIAGNOSTIC(5, "     fixed to 0x%X", sp->lr, 0);
	  }
	  
	  top = (mlval *)fp->fp - CCODENONGC(code);
	  scan((mlval *)(fp+1), top, to); /* fix stack allocated area */
	  /* fp+1 is the top of the struct stack_frame */

	} else if (sp->closure == STACK_C_CALL)
	  /* the next frame we come to is a register save frame */
	  register_save_frame = 1;
      }
    }
  }
  return(to);
}

#ifdef EXPLORER

/* The explorer needs to find any potential roots on the stacks. */

extern void explore_stacks(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  for (thread= TOP_THREAD.next; thread != &TOP_THREAD; thread = thread->next) {
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      int register_save_frame = 1;
      for(; !(final_frame(sp,thread)); sp = sp->fp) {
	struct stack_frame *fp = sp->fp;
	
	if (register_save_frame) {
	  explore_stack_registers(thread, sp, (mlval*)sp+1, (mlval*)fp);
	  register_save_frame = 0;
	}

	if(MLVALISPTR(sp->closure)) {
	  mlval *top, code;
	  explore_stack_registers(thread, sp, &sp->closure, (&sp->closure)+1);
	  code = FIELD(sp->closure, 0);
	  
	  top = (mlval *)fp->fp - CCODENONGC(code);
	  explore_stack_allocated(thread, fp, (mlval *)(fp+1), top);
	  /* fp+1 is the top of the struct stack_frame */
	} else if (sp->closure == STACK_C_CALL)
	  /* the next frame we come to is a register save frame */
	  register_save_frame = 1;
      }
    }
  }
}

#endif

/* Stack backtrace */

static const char *code_vector_name(word closure)
{
  if (validate_ml_address(&(FIELD(closure, 0)))) {
    word code = FIELD(closure, 0);
    if (validate_ml_address((void *)code) && validate_ml_address((void *)(OBJECT(code)))) {
      if (validate_ml_address(&(CCODEANCILLARY(code))) &&
	  validate_ml_address(&(CCODEANCRECORD(code, NAMES))) &&
	  validate_ml_address(&(CCODEANCVALUE(code, NAMES))) &&
	  validate_ml_address(CSTRING(CCODENAME(code)))) {
	return CSTRING(CCODENAME(code));
      } else {	
	return "invalid code ancillary";
      }
    } else {
      return "invalid code pointer";
    }
  } else {
    return "invalid closure";
  }
}

int max_backtrace_depth = 50;

void backtrace(struct stack_frame *sp, struct thread_state *thread,
	       int depth_max)
{
  message_content("Stack backtrace\n");
  if (!sp)
    message_content("  No stack!\n");
  else if ((word)sp == thread->ml_state.stack_top)
    message_content("  %p empty stack.\n",sp);
  else {
    while(depth_max-- && sp &&
	  (word)sp != thread->ml_state.stack_top) {
      if (validate_address(&sp->closure)) {
	const char *name =
	  MLVALISPTR(sp->closure) ? code_vector_name(sp->closure) :
	  MLVALISPTR(sp->closure) ? CSTRING(CCODENAME(FIELD(sp->closure, 0))) :
	  sp->closure == STACK_START ? "stack start" :
	  sp->closure == STACK_DISTURB_EVENT ? "disturb event" :
	  sp->closure == STACK_EXTENSION ? "stack extension" :
	  sp->closure == STACK_RAISE ? "raise" :
	  sp->closure == STACK_EVENT ? "asynchronous event handler" :
	  sp->closure == STACK_C_RAISE ? "raise from C" :
	  sp->closure == STACK_C_CALL ? "call to C" :
	  sp->closure == STACK_INTERCEPT ? "intercept" :
	  sp->closure == STACK_SPACE_PROFILE ? "space profile" : "special";

	message_content("  %p closure 0x%08X: ", sp, sp->closure);
	message_string(name);
	message_string("\n");
      } else {
	message_content("  %p cannot read closure address %p\n",
			sp, &sp->closure);
	break;
      }
      if (validate_address(&sp->fp)) {
	sp = sp->fp;
      } else {
	break;
      }
    }
    if (sp == NULL || (word)sp == thread->ml_state.stack_top)
      message_content("--- base of stack --- \n");
    else if (depth_max > 0 && !validate_address(&sp->fp)) {
      /* Not at top of stack, but address invalid */
      message_content("  %p cannot read frame address %p\n", sp, &sp->fp);
    }
  }
}

mlval is_ml_frame(struct stack_frame *sp)
{
  mlval closure = sp->closure;

  if(ISORDPTR(closure) && validate_ml_address((void *)closure)) {
    mlval secondary = SECONDARY(GETHEADER(closure));
    if(secondary == RECORD || secondary == 0) {
      mlval code = FIELD(closure, 0);
      if(validate_ml_address((void *)code) && PRIMARY(code) == POINTER &&
	 SECONDARY(GETHEADER(code)) == BACKPTR)
	return(code);
    }
  }
  return(MLUNIT);
}

/* Pervasive stack functions */

/* These first few are not MIPS-specific, assuming we have an fp, the
 * stack is full descending, &c */

static mlval ml_is_ml_frame (mlval frame)
{
  if (is_ml_frame ((struct stack_frame *)frame) == MLUNIT)
    return MLFALSE;
  else
    return MLTRUE;
}



static mlval current(mlval arg)
{
  return((mlval)(GC_SP(CURRENT_THREAD)->fp));
}



static mlval sub(mlval arg)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(arg, 0);
  int index = CINT(FIELD(arg, 1));

  return(((mlval *)sp)[index]);
}

static mlval update(mlval arg)
{
  ((mlval *)FIELD(arg, 0))[CINT(FIELD(arg, 1))] = FIELD(arg, 2);
  return(MLUNIT);
}

static mlval frame_call(mlval argument)
{
  return(callml((mlval)GC_SP(CURRENT_THREAD), argument));
}

static mlval frame_offset(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1));
  return(*((mlval *)(((int)(sp->fp))+index)));
}

static mlval frame_double(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1)); /* This is a pointer to an unboxed double */
  mlval real = allocate_real();
  char *ptr = (char *)(((int)(sp->fp))+index);
  memcpy (((char *)real)+(8-POINTER), ptr, 8); /* Copy into double from stack */
  return (real);
}

/* Now these are MIPS-specific */


/*
 * All the following sizes are in bytes.
 */
#define mlw_mips_call_instr_size 4
#define mlw_mips_delay_slot_size 4
#define mlw_mips_call_size (mlw_mips_call_instr_size+mlw_mips_delay_slot_size)


/*
 * Returns a triple: (isMLFrame:bool, framePointer:mlval, instrByteOffset:int)
 *
 * The instrByteOffset is only meaningful if the frame is an ML frame,
 * if the frame is a C frame then instrByteOffset is 0.
 *
 * It is possible that there are no frames and in that case
 * isMLFrame = false and framePointer = MLUNIT.
 */

static mlval frame_next(mlval arg)
{
  struct stack_frame *sp = (struct stack_frame *)arg;
  mlval result= allocate_record(3);

  if (!is_stack_top(sp->fp,CURRENT_THREAD)) {
    mlval code= is_ml_frame(sp->fp);
    if(code != MLUNIT) {
      word code_start_addr= (word)CCODESTART(code);
      word next_instr_addr= sp->fp->lr;
      word call_offset= next_instr_addr - code_start_addr - mlw_mips_call_size;
      FIELD(result, 0)= MLTRUE;
      FIELD(result, 1)= (mlval)sp->fp;
      FIELD(result, 2)= MLINT(call_offset);
      return result;
    } else {
      FIELD(result,0)= MLTRUE;
      FIELD(result, 1)= (mlval)sp->fp;
      FIELD(result,2)= MLINT(0);
      return result;
    }
  } else { /* No frames on the stack! */
    FIELD(result, 0)= MLFALSE;
    FIELD(result, 1)= MLUNIT;
    FIELD(result, 2)= MLINT(0);
    return result;
  }
}



static mlval frame_argument(mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;
  mlval code = FIELD(sp->closure,0);
  int saves = CCODESAVES(code);
  struct stack_frame *fp = sp->fp;
  mlval *save_area = (mlval*)(fp+1);
  return (save_area[saves]);
}

/* 76 is kind of magic */
static mlval set_frame_return_value(mlval arg)
{
  mlval frame = FIELD (arg,0);
  mlval value = FIELD (arg,1);
  mlval *mlsp = (mlval *)(frame+76);
  *mlsp = value;
  return (MLUNIT);
}

static mlval frame_allocations(mlval frame)
{
  /* not clear what to do here for MIPS; we don't have enough information */
  return MLTRUE;
}

void stacks_init()
{
  env_function("stack frame sub", sub);
  env_function("stack frame update", update);
  env_function("stack frame current", current);
  env_function("stack is ml frame", ml_is_ml_frame);
  env_function("debugger frame call", frame_call);
  env_function("debugger frame next", frame_next);
  env_function("debugger frame sub", sub);
  env_function("debugger frame offset", frame_offset);
  env_function("debugger frame double", frame_double);
  env_function("debugger frame argument", frame_argument);
  env_function("debugger set frame return value", set_frame_return_value);
  env_function("debugger frame allocations", frame_allocations);
}
@


1.25.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 5
 * Revision 1.25  1998/09/18  11:09:23  jont
 * [Bug #20124]
 * Fix is_ml_frame to use validate_ml_address,
 * and make backtrace more robust against bad addresses
 *
@


1.24
log
@[Bug #70026]
Allow profiling of stub_c functions, recording the time according
to the name of the runtime system functions
@
text
@d12 5
d286 21
d320 4
a323 2
      const char *name =
	MLVALISPTR(sp->closure) ? CSTRING(CCODENAME(FIELD(sp->closure, 0))) :
d334 13
a346 4
      message_content("  %p closure 0x%08X: ", sp, sp->closure);
      message_string(name);
      message_string("\n");
      sp = sp->fp;
d350 4
d361 1
a361 1
  if(ISORDPTR(closure)) {
d364 4
a367 8
      mlval *object = OBJECT(closure);
      if(is_ml_heap(object) || is_ml_stack(object)) {
	mlval code = FIELD(closure, 0);
	if((is_ml_heap(OBJECT(code)) || code == stub_c) &&
	   PRIMARY(code) == POINTER &&
	   SECONDARY(GETHEADER(code)) == BACKPTR)
	  return(code);
      }
a369 1

@


1.23
log
@[Bug #70018]
Split stack_crawl into two phases
@
text
@d12 4
d326 1
a326 1
	if(is_ml_heap(OBJECT(code)) &&
@


1.22
log
@[Bug #30242]
Ensure we don't fix pseudo return addresses in raise frames
Also check return address we fix are within code
@
text
@d12 5
d159 1
a159 1
extern mlval *stack_crawl(mlval *to)
d164 1
a164 2
  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
  DIAGNOSTIC(4, " first pass",0,0);
d185 7
a191 1
  
@


1.21
log
@[Bug #30076]
Modify to make NONGC spills be counted in words
@
text
@d12 4
d96 2
d113 1
d173 4
a176 1
	  sp->lr -= codeptr;			/* NB: no longer aligned */
@


1.21.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 4
 * Revision 1.21  1997/06/03  16:27:27  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.21.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 4
 * Revision 1.21  1997/06/03  16:27:27  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.21.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 4
 * Revision 1.21  1997/06/03  16:27:27  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
@


1.20
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d12 4
d203 1
a203 1
	  top = (mlval *)fp->fp - (CCODENONGC(code)/sizeof(mlval));
d242 1
a242 1
	  top = (mlval *)fp->fp - (CCODENONGC(code)/sizeof(mlval));
@


1.19
log
@[Bug #1461]
Fix stack closure tags.
@
text
@d12 4
d199 1
a199 1
	  top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
d238 1
a238 1
	  top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
@


1.19.6.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.19.6.1  1997/05/12  10:44:06  hope
 * branched from 1.19
 *
@


1.19.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.19.6.1  1997/05/12  10:44:06  hope
 * branched from 1.19
 *
@


1.19.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.19.6.1  1997/05/12  10:44:06  hope
 * branched from 1.19
 *
@


1.19.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.19.6.1.1.1  1997/07/28  18:24:27  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.19.5.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.4.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.4.1.1.1
log
@branched from 1.19.4.1
@
text
@a11 3
 * Revision 1.19.4.1  1996/12/17  17:55:48  hope
 * branched from 1.19
 *
@


1.19.3.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.2.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.1.1
log
@branched from 1.19
@
text
@a11 4
 * Revision 1.19  1996/11/07  17:35:52  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
@


1.19.1.1.1.1
log
@branched from 1.19.1.1
@
text
@a11 3
 * Revision 1.19.1.1  1996/11/14  12:59:41  hope
 * branched from 1.19
 *
@


1.18
log
@[Bug #1441]
frame_next: change the offset to be a byte rather than word
offset since instructions are not word aligned on an I386 and
so the debugger has been changed to expect byte offsets.
@
text
@d12 6
d264 9
a272 10
  	sp->closure == STACK_EXTENSION ? "stack extension" :
	sp->closure == STACK_LEAF_RAISE ? "leaf raise" :
	sp->closure == STACK_RAISE ? "raise" :
	sp->closure == STACK_RESUME ? "resume" :
	sp->closure == STACK_PROFILE ? "profiler" :
	sp->closure == STACK_EVENT ? "asynchronous event handler" :
	sp->closure == STACK_C_RAISE ? "raise from C" : 
	sp->closure == STACK_C_CALL ? "call to C" :
	sp->closure == STACK_START ? "call from C" :
        sp->closure == STACK_INTERCEPT ? "intercept" : "special";
@


1.17
log
@[Bug #1446]
frame_next: adjust the offset by -2 in the case of an ML frame.
@
text
@d12 4
d362 1
a362 3
 * This value was determined empirically.  At some point someone
 * should spend some time to explain why this value is necessary.
 * - stephenb
d364 3
a366 1
#define mlw_magic_frame_offset 2
d387 3
d392 1
a392 1
      FIELD(result, 2)= MLINT((word *)sp->fp->lr - CCODESTART(code) - mlw_magic_frame_offset);
@


1.17.2.1
log
@branched from 1.17
@
text
@a11 4
 * Revision 1.17  1996/10/03  13:31:10  stephenb
 * [Bug #1446]
 * frame_next: adjust the offset by -2 in the case of an ML frame.
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a11 4
 * Revision 1.17  1996/10/03  13:31:10  stephenb
 * [Bug #1446]
 * frame_next: adjust the offset by -2 in the case of an ML frame.
 *
@


1.16
log
@[Bug #1595]
  Changed the offset calculatation in frame_next to use the return
  address of in the frame pointed to by the frame pointer instead of
  the stack pointer.  That is, the line :-

    FIELD(result, 2) = MLINT((word *)sp->lr - CCODESTART(code));

  becomes

    FIELD(result, 2) = MLINT((word *)sp->fp->lr - CCODESTART(code));

  Also removed flush and ml_is_top_frame since they are never used.
@
text
@d12 14
d358 8
d385 1
a385 1
      FIELD(result, 2)= MLINT((word *)sp->fp->lr - CCODESTART(code));
@


1.15
log
@ISPTR becomes MLVALISPTR
@
text
@d12 3
a294 9
static mlval ml_is_top_frame (mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;
  
  if (is_stack_top(sp->fp, CURRENT_THREAD))
    return (MLTRUE);
  else
    return (MLFALSE);
}
a295 5
static mlval flush(mlval arg)
{
  flush_windows(); /* a nop on non-SPARCs */
  return(MLUNIT);
}
d302 2
a319 2
  flush_windows();

d342 11
a354 1
  mlval result;
d356 1
a356 4

  flush_windows();

  result = allocate_record(3);
d359 1
a359 3
    mlval code;

    code = is_ml_frame(sp->fp);
d361 4
a364 5
      FIELD(result, 0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result, 2) = MLINT((word *)sp->lr - CCODESTART(code));

      return(result);
d366 4
a369 5
      FIELD(result,0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result,2) = MLINT(0);
	
      return(result);
d372 6
a378 3
    FIELD(result, 0) = MLFALSE;
    FIELD(result, 1) = MLUNIT;
    FIELD(result, 2) = MLINT(0);
a379 3
    return(result);
  }
}
a408 1
  env_function("stack flush", flush);
a412 1
  env_function("stack is top frame", ml_is_top_frame);
@


1.15.1.1
log
@branched from 1.15
@
text
@a11 3
 * Revision 1.15  1996/02/14  17:34:59  jont
 * ISPTR becomes MLVALISPTR
 *
@


1.14
log
@Add heap-exploration hooks.
@
text
@d12 3
d154 1
a154 1
	if(ISPTR(sp->closure)) {
d202 1
a202 1
	if(ISPTR(sp->closure)) {
d236 1
a236 1
	ISPTR(sp->closure) ? CSTRING(CCODENAME(FIELD(sp->closure, 0))) :
@


1.13
log
@Runtime error message buffer problem.
@
text
@d12 3
d68 1
d177 39
@


1.12
log
@Adding set_frame_return_value
@
text
@d12 3
d202 3
a204 1
	message_content("  %p closure 0x%08X: %s\n", sp, sp->closure, name);
@


1.11
log
@Add debugger_double for getting floats straight from spills
@
text
@d12 3
d348 10
d360 1
a360 2
/* not clear what to do here for MIPS; we don't have enough information */

d378 1
@


1.10
log
@Add frame_argument function.
@
text
@d12 3
d58 1
d287 12
d364 1
@


1.9
log
@Fix all the register save frames, not just one.
@
text
@d12 3
d319 10
d348 1
@


1.8
log
@Clear up SPARCisms in is_ml_frame &c.
@
text
@d12 3
d77 15
d124 1
a124 9
      /* fix registers saved in first frame */
      mlval *base = (mlval *)(sp+1);
      mlval *top = (mlval *)(sp->fp);
      while (base < top) {
	fix_reg(to, base);
	base++;
      }
      /* Now fix all other saved values in all other frames */

d129 5
d149 6
a154 3
	  scan((mlval *)(sp->fp+1), top, to); /* fix stack allocated area */
	  /* sp->fp+1 is the top of the struct stack_frame */
	}
@


1.7
log
@Threads system.
@
text
@d12 3
d85 1
a85 1
    if (sp && ((word)sp != thread->ml_state.stack_top)) {
d105 1
a105 1
    if (sp && ((word)sp != thread->ml_state.stack_top)) {
a178 3
/* A MIPS stack frame contains ML values iff its frame pointer points
 * into an ML stack area. */

d183 1
a183 2
  if(is_ml_stack(sp->fp) && ISORDPTR(closure))
  {
d185 1
a185 3

    if(secondary == RECORD || secondary == 0)
    {
d187 1
a187 3

      if(is_ml_heap(object) || is_ml_stack(object))
      {
d189 3
a191 3

	if(is_ml_heap(OBJECT(code)) && PRIMARY(code) == POINTER &&
	   (SECONDARY(GETHEADER(code)) == CODE || SECONDARY(GETHEADER(code)) == BACKPTR))
d217 1
a217 1
  if (sp->fp == (struct stack_frame *)CURRENT_THREAD->ml_state.stack_top)
d225 1
a225 1
  flush_windows();		/* I assume this is a nop on non-SPARCs */
a261 2
/* Now these are SPARC-specific */

d271 1
a271 2
  while(sp->fp != NULL)
  {
d288 5
d294 1
a294 1
    sp = sp->fp;
a295 8

  /* No frames on the stack! */

  FIELD(result, 0) = MLFALSE;
  FIELD(result, 1) = MLUNIT;
  FIELD(result, 2) = MLINT(0);

  return(result);
d300 1
a300 1
  struct stack_frame *sp = (struct stack_frame *)frame;
d302 1
a302 14
  if (((int)sp) < 0)
    return(MLFALSE);
    
  switch(((int)(sp->fp))-((int)(sp))-64)
    {
      case 0 : 
	{
	  return(MLFALSE);
	}
      default :
	{
	  return(MLTRUE);
	}
    }
@


1.6
log
@Adding is_top_frame ml functions
@
text
@d12 3
d69 1
a69 1
#define final_frame(sp) (((sp)->closure == STACK_C_CALL) && (((sp)+1)->fp == NULL))
d73 2
a74 1
  struct stack_frame *sp = GC_SP;
a75 4
  if (sp != ml_state.stack_top) {
    
  mlval *base = (mlval *)(sp+1);
  mlval *top = (mlval *)(sp->fp);
d77 1
a77 2
  flush_windows();
  DIAGNOSTIC(4, " first pass", 0, 0);
d79 30
a108 13
  /* If we're not inside the linked set of ml frames, don't bother with this */
  if (TYPE(sp->fp) == TYPE_STACK) {
    /* turn each ML link slot into an offset from the closure code address */
    for(sp = GC_SP; !(final_frame(sp)); sp = sp->fp)
      if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(sp->lr) == TYPE_FROM) {

	DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, sp->fp);
	DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		   CSTRING(CCODENAME(FIELD(sp->closure, 0))));
	/* Note that the lr and closure for it are in the same frame for the MIPS */
	sp->lr -= FIELD(sp->closure, 0); /* NB: no longer aligned */

	DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(sp->closure, 0), sp->lr);
d110 1
d112 4
a115 9
    DIAGNOSTIC(4, " second pass", 0, 0);

    /* Now fix everything on the stack, restoring the link slots as we go */

    for(sp = GC_SP; !(final_frame(sp)); sp = sp->fp) {
      struct stack_frame *fp = sp->fp;
      if (TYPE(sp->fp) == TYPE_STACK) {
	DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);

d119 1
a119 1
	  closure = sp->closure;		/* Note caller's closure is in our frame */
d122 1
a122 1

d125 1
a125 1
	    DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, sp->lr);
d127 1
a127 1
	    DIAGNOSTIC(5, "    fixed to 0x%X", sp->lr, 0);
d129 1
a129 1

d131 1
a131 1
	  scan((mlval *)(sp->fp+1), top, to); /* fix the stack allocated area */
a133 2
	/* Now fix the register slots */
	/* There are none of these on the MIPS */
a135 5
    sp = GC_SP;
    if(TYPE(sp->fp) == TYPE_STACK) {
      while (base < top) { fix_reg(to, base); base++; };
      /* Note, top will need to be revised when floating point is saved */
    }
a136 1
}
d142 1
a142 1
int max_backtrace_depth = 25;
d144 2
a145 1
void backtrace(FILE *stream, struct stack_frame *sp, int depth_max)
d147 8
a154 9
  fprintf(stream, "Stack backtrace\n");
  fprintf(stream, "  %p closure 0x%08X\n", sp, sp->closure);

  while(depth_max-- && !(final_frame(sp->fp)))
  {
    struct stack_frame *fp = sp->fp;

    if(is_ml_stack(fp))
    {
d156 11
a166 11
	ISPTR(fp->closure) ? CSTRING(CCODENAME(FIELD(fp->closure, 0))) :
	fp->closure == STACK_EXTENSION ? "stack extension" :
	fp->closure == STACK_LEAF_RAISE ? "leaf raise" :
	fp->closure == STACK_RAISE ? "raise" :
	fp->closure == STACK_RESUME ? "resume" :
	fp->closure == STACK_PROFILE ? "profiler" :
	fp->closure == STACK_EVENT ? "asynchronous event handler" :
	fp->closure == STACK_C_RAISE ? "raise from C" : 
	fp->closure == STACK_C_CALL ? "call to C" :
	fp->closure == STACK_START ? "ML stack start" :
        fp->closure == STACK_INTERCEPT ? "intercept" : "special";
d168 2
a169 1
      fprintf(stream, "  %p closure 0x%08X: %s\n", fp, fp->closure, name);
d171 2
a172 2

    sp = sp->fp;
d205 4
d212 4
a215 1
  return (is_ml_frame ((struct stack_frame *)frame) == MLUNIT ? MLFALSE : MLTRUE);
d222 1
a222 1
  if (sp->fp == ml_state.stack_top)
a227 5
/* Pervasive stack functions */

/* These first few are not MIPS-specific, assuming we have an fp, the
 * stack is full descending, &c */

d236 1
a236 1
  return((mlval)ml_state.sp->fp);
d257 1
a257 1
  return(callml((mlval)ml_state.sp, argument));
@


1.5
log
@Adding check on stack_top
@
text
@d12 3
d206 10
d329 1
@


1.4
log
@Adding is_ml_frame
@
text
@d12 3
d69 2
d129 1
@


1.3
log
@Fix use of fix_reg to avoid ++ in macro call
Sort out stack_crawl to spot cases where there is no ml stack (eg image saving)
@
text
@d12 4
d191 6
d309 1
@


1.3.1.1
log
@branched from 1.3
@
text
@a11 4
 * Revision 1.3  1994/07/18  16:42:12  jont
 * Fix use of fix_reg to avoid ++ in macro call
 * Sort out stack_crawl to spot cases where there is no ml stack (eg image saving)
 *
@


1.2
log
@Modify for MIPS version
@
text
@d12 3
d68 11
a78 9
  /* turn each ML link slot into an offset from the closure code address */
  for(sp = GC_SP; !(final_frame(sp)); sp = sp->fp)
    if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(sp->lr) == TYPE_FROM) {

      DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, sp->fp);
      DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		 CSTRING(CCODENAME(FIELD(sp->closure, 0))));
      /* Note that the lr and closure for it are in the same frame for the MIPS */
      sp->lr -= FIELD(sp->closure, 0); /* NB: no longer aligned */
d80 2
a81 2
      DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(sp->closure, 0), sp->lr);
    }
d83 1
a83 1
  DIAGNOSTIC(4, " second pass", 0, 0);
d85 1
a85 1
  /* Now fix everything on the stack, restoring the link slots as we go */
d87 22
a108 18
  for(sp = GC_SP; !(final_frame(sp)); sp = sp->fp)
  {
    struct stack_frame *fp = sp->fp;
    if (TYPE(sp->fp) == TYPE_STACK) {
      DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);

      if(ISPTR(sp->closure)) {
	mlval *top, closure, code;
	fix(to, &sp->closure);		/* fix the caller's closure */
	closure = sp->closure;		/* Note caller's closure is in our frame */
	fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	code = FIELD(closure, 0);

	/* if the link address is unaligned, it must be restored: */
	if(word_align(sp->lr) != sp->lr) {
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, sp->lr);
	  sp->lr += code;
	  DIAGNOSTIC(5, "    fixed to 0x%X", sp->lr, 0);
d110 2
a111 4

	top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
	scan((mlval *)(sp->fp+1), top, to); /* fix the stack allocated area */
			/* sp->fp+1 is the top of the struct stack_frame */
d113 5
a117 2
      /* Now fix the register slots */
      /* There are none of these on the MIPS */
a119 2
  while (base < top) fix_reg(to, base++);
  /* Note, top will need to be revised when floating point is saved */
@


1.1
log
@new file
@
text
@d1 1
a1 1
/*  === SPARC STACK ROUTINES ===
d11 2
a12 8
 *  $Log: src:arch:SPARC:stacks.c,v $
 * Revision 1.3  1994/06/21  15:58:40  nickh
 * New ancillary structure.
 *
 * Revision 1.2  1994/06/09  14:30:53  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:55:28  nickh
a14 1
 *
d33 1
a33 2
 *  NOTE: 1. This code is highly SPARC-specific
 *        2. Register windows need to have been flushed before entry
d53 2
d59 2
d66 1
a66 1
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
a67 1
      struct stack_frame *fp = sp->fp;
d69 1
a69 1
      DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, fp);
d71 3
a73 3
		 CSTRING(CCODENAME(FIELD(fp->closure, 0))));
      
      sp->lr -= FIELD(fp->closure, 0); /* NB: no longer aligned */
d75 1
a75 1
      DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(fp->closure, 0), sp->lr);
d82 1
a82 1
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
d88 1
a88 1
      if(ISPTR(fp->closure)) {
d90 2
a91 2
	fix(to, &fp->closure);		/* fix the caller's closure */
	closure = fp->closure;
d98 1
a98 1
	  sp->lr += code;    
d107 1
a107 6
      fix_reg(to, &sp->l0); fix_reg(to, &sp->l1); fix_reg(to, &sp->l2);
      fix_reg(to, &sp->l3); fix_reg(to, &sp->l4); fix_reg(to, &sp->l5);
      fix_reg(to, &sp->l6); fix_reg(to, &sp->l7);

      fix_reg(to, &sp->i0); fix_reg(to, &sp->closure); fix_reg(to, &sp->i2);
      fix_reg(to, &sp->i3); fix_reg(to, &sp->i4); fix_reg(to, &sp->i5);
d110 2
d124 1
a124 1
  while(depth_max-- && sp->fp)
d150 1
a150 1
/* A SPARC stack frame contains ML values iff its frame pointer points
d181 1
a181 1
/* These first few are not SPARC-specific, assuming we have an fp, the
@
