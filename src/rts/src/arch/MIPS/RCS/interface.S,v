head	1.36;
access;
symbols
	MLW_daveb_inline_1_4_99:1.36.1
	MLWorks_21c0_1999_03_25:1.36
	MLWorks_20c1_1998_08_20:1.35
	MLWorks_20c0_1998_08_04:1.35
	MLWorks_20b2c2_1998_06_19:1.35
	MLWorks_20b2_Windows_1998_06_12:1.35
	MLWorks_20b1c1_1998_05_07:1.35
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.35
	MLWorks_MM_adapt:1.35.9
	MLWorks_20m1_1997_10_23:1.35
	MLWorks_11r1:1.35.6.1.1.1.1
	MLWorks_workspace_97:1.35.8
	MLWorks_dt_wizard:1.35.7
	MLWorks_11c0_1997_09_09:1.35.6.1.1.1
	MLWorks_10r3:1.35.6.1.3
	MLWorks_10r2_551:1.35.6.1.2
	MLWorks_11:1.35.6.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.35.6.1
	MLWorks_20m0_1997_06_20:1.35
	MLWorks_1_0_r2c2_1997_06_14:1.35.6.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.35.6.1
	MLWorks_1_0_r2c1_1997_05_12:1.35.6
	MLWorks_BugFix_1997_04_24:1.35
	MLWorks_1_0_r2_Win32_1997_04_11:1.35
	MLWorks_1_0_r2_Unix_1997_04_04:1.35
	MM_ML_release_korma_1997_04_01:1.35
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.35.4.1.1
	MLWorks_gui_1996_12_18:1.35.5
	MLWorks_1_0_Win32_1996_12_17:1.35.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.35.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.35.1.1
	JFHrts:1.35.3
	MLWorks_1_0_Irix_1996_11_28:1.35.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.35.2
	MLWorks_1_0_Unix_1996_11_14:1.35.1
	MLWorks_Open_Beta2_1996_10_11:1.34.3
	MLWorks_License_dev:1.34.2
	MLWorks_1_open_beta_1996_09_13:1.34.1
	MLWorks_Open_Beta_1996_08_22:1.34
	MLWorks_Beta_1996_07_02:1.32
	MLWorks_Beta_1996_06_07:1.32
	MLWorks_Beta_1996_06_06:1.32
	MLWorks_Beta_1996_06_05:1.32
	MLWorks_Beta_1996_06_03:1.32
	MLWorks_Beta_1996_05_31:1.32
	MLWorks_Beta_1996_05_30:1.32
	hope_poo:1.6.1
	ML_beta_release_12/08/94:1.6.1.1
	ML_beta_release_03/08/94:1.5;
locks; strict;
comment	@ *@;


1.36
date	98.10.30.17.18.01;	author jont;	state Exp;
branches
	1.36.1.1;
next	1.35;

1.35
date	96.11.07.17.32.55;	author stephenb;	state Exp;
branches
	1.35.1.1
	1.35.2.1
	1.35.3.1
	1.35.4.1
	1.35.5.1
	1.35.6.1
	1.35.7.1
	1.35.8.1
	1.35.9.1;
next	1.34;

1.34
date	96.08.16.13.44.37;	author io;	state Exp;
branches
	1.34.1.1
	1.34.2.1
	1.34.3.1;
next	1.33;

1.33
date	96.08.16.13.37.58;	author io;	state Exp;
branches;
next	1.32;

1.32
date	96.04.25.17.23.14;	author stephenb;	state Exp;
branches;
next	1.31;

1.31
date	95.12.12.15.22.02;	author nickb;	state Exp;
branches;
next	1.30;

1.30
date	95.12.11.15.52.19;	author nickb;	state Exp;
branches;
next	1.29;

1.29
date	95.11.13.12.34.39;	author nickb;	state Exp;
branches;
next	1.28;

1.28
date	95.09.06.15.13.30;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	95.07.17.09.45.21;	author nickb;	state Exp;
branches;
next	1.26;

1.26
date	95.06.27.14.20.24;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	95.06.15.14.19.46;	author jont;	state Exp;
branches;
next	1.24;

1.24
date	95.06.01.09.10.02;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	95.05.26.09.20.51;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	95.05.24.13.55.03;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.05.23.12.26.31;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	95.05.09.15.39.19;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.05.05.15.00.08;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	95.05.05.11.08.29;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.05.05.10.54.03;	author nickb;	state Exp;
branches;
next	1.16;

1.16
date	95.05.04.10.52.52;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	95.03.30.12.20.41;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.01.12.11.21.56;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	94.12.13.13.39.40;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	94.11.24.17.29.07;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	94.11.08.16.20.36;	author matthew;	state Exp;
branches;
next	1.10;

1.10
date	94.10.28.12.42.19;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	94.10.25.13.07.53;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	94.10.20.11.23.35;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	94.09.15.17.20.15;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.08.03.13.44.19;	author jont;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	94.07.27.13.50.32;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.07.22.16.43.28;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.07.20.14.24.35;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.07.15.16.48.59;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.06.12;	author jont;	state Exp;
branches;
next	;

1.6.1.1
date	95.07.05.10.29.34;	author hope;	state Exp;
branches;
next	;

1.34.1.1
date	96.09.13.11.25.47;	author hope;	state Exp;
branches;
next	;

1.34.2.1
date	96.10.07.16.16.17;	author hope;	state Exp;
branches;
next	;

1.34.3.1
date	96.10.17.11.35.37;	author hope;	state Exp;
branches;
next	;

1.35.1.1
date	96.11.14.13.01.14;	author hope;	state Exp;
branches
	1.35.1.1.1.1;
next	;

1.35.1.1.1.1
date	96.11.28.15.11.20;	author hope;	state Exp;
branches;
next	;

1.35.2.1
date	96.11.22.18.19.06;	author hope;	state Exp;
branches;
next	;

1.35.3.1
date	96.12.17.10.05.50;	author hope;	state Exp;
branches;
next	;

1.35.4.1
date	96.12.17.17.57.23;	author hope;	state Exp;
branches
	1.35.4.1.1.1;
next	;

1.35.4.1.1.1
date	97.02.24.11.49.07;	author hope;	state Exp;
branches;
next	;

1.35.5.1
date	96.12.18.09.52.04;	author hope;	state Exp;
branches;
next	;

1.35.6.1
date	97.05.12.10.47.04;	author hope;	state Exp;
branches
	1.35.6.1.1.1
	1.35.6.1.2.1
	1.35.6.1.3.1;
next	;

1.35.6.1.1.1
date	97.07.28.18.26.35;	author daveb;	state Exp;
branches
	1.35.6.1.1.1.1.1;
next	;

1.35.6.1.1.1.1.1
date	97.10.07.11.52.23;	author jkbrook;	state Exp;
branches;
next	;

1.35.6.1.2.1
date	97.09.08.17.19.44;	author daveb;	state Exp;
branches;
next	;

1.35.6.1.3.1
date	97.09.09.14.15.50;	author daveb;	state Exp;
branches;
next	;

1.35.7.1
date	97.09.10.19.33.08;	author brucem;	state Exp;
branches;
next	;

1.35.8.1
date	97.09.11.21.02.22;	author daveb;	state Exp;
branches;
next	;

1.35.9.1
date	97.10.31.13.45.13;	author nickb;	state Exp;
branches;
next	;

1.36.1.1
date	99.04.01.18.01.48;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.36
log
@[Bug #70226]
Remove raise_count and stack_extension_count (gone to mlw_start.c)
@
text
@/*
 * ==== ML TO C INTERFACING CODE ====
 *		MIPS
 *
 * Copyright (C) 1994 Harlequin Ltd
 *
 * Description
 * -----------
 * This code does the job of managing the calls between ML and C.  The ML
 * and C states are stored in C structures declared in `state.c'.
 *
 * Notes
 * -----
 * Take great care modifying this file. As well as getting the
 * semantics right for MIPS (remember those delay slots!), you have to
 * maintain hidden invariants or you will break the profiler. See the
 * profiler comment in the body of the file.
 *
 * This code uses some predefined macros as parameters.  These are
 * defined (or not) in the Makefile.  They are as follows:
 *
 *   COLLECT_STATS: If defined the routines will update various
 *                  counters defined in callc_codes.c when called.
 *
 * This file must be run through CPP to produce an assembler file. 
 *
 * Revision Log
 * ------------
 * $Log: src:arch:MIPS:interface.S,v $
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
 *Revision 1.34  1996/08/16  13:44:37  io
 *Some URI comments for replacement_code
 *
 *Revision 1.33  1996/08/16  13:37:58  io
 *Some URI comments for replacement_code
 *
 *Revision 1.32  1996/04/25  17:23:14  stephenb
 *Load delay slot hazard not warned by SGI's shit assembler.
 *
 *Revision 1.31  1995/12/12  15:22:02  nickb
 *Fix bug in space profiling; can't use jal as the SGI assembler expands it.
 *
 *Revision 1.30  1995/12/11  15:52:19  nickb
 *Add space profiling.
 *
 *Revision 1.29  1995/11/13  12:34:39  nickb
 *Move CURRENT_THREAD manipulation out of asm into portable C.
 *
 *Revision 1.28  1995/09/06  15:13:30  nickb
 *Change to c_sp protocol.
 *
 *Revision 1.27  1995/07/17  09:45:21  nickb
 *Add dummy sequences for space profiling.
 *
 *Revision 1.26  1995/06/27  14:20:24  jont
 *Fix unbounded stack growth from leaf raise problems
 *
 *Revision 1.25  1995/06/15  14:19:46  jont
 *Modify raise code to remove stack copying down and up in favour of
 *a small extra frame.
 *
 *Revision 1.24  1995/06/01  09:10:02  matthew
 *Save argument on stack in intercept and replace leaf
 *
 *Revision 1.23  1995/05/26  09:20:51  matthew
 *leaf intercept and replace were the wrong way round too
 *
 *Revision 1.22  1995/05/24  13:55:03  nickb
 *Workaround for the Irix 'as' silently removing our instructions.
 *
 *Revision 1.21  1995/05/23  12:26:31  matthew
 *ml_replace and ml_intercept were the wrong way round
 *
 *Revision 1.20  1995/05/09  15:39:19  nickb
 *Fix ml_disturbance; a closure/link address pair are not getting in
 *the same stack frame.
 *
 *Revision 1.19  1995/05/05  15:00:08  nickb
 *Got the operands to jalr backwards in the intercept/replace pieces of code.
 *
 *Revision 1.18  1995/05/05  11:08:29  nickb
 *Oops. Of course I meant clean_caller_saves, not clean_callee_saves.
 *
 *Revision 1.17  1995/05/05  10:54:03  nickb
 *Fix some problems with c_raise.
 *Also add a cautionary comment.
 *
 *Revision 1.16  1995/05/04  10:52:52  nickb
 *Change the manipulation of the in_ML flag so that:
 *(a) in_ML false => thread->ml_state.sp is meaningful
 *(b) in_ML true => sp,fp,closures make some sense for ML.
 *
 *Revision 1.15  1995/03/30  12:20:41  nickb
 *Add threads system.
 *
 *Revision 1.14  1995/01/12  11:21:56  nickb
 *Make ml_raise_leaf do something. Also fix c_raise (it's
 *getting the wrong closure).
 *
 *Revision 1.13  1994/12/13  13:39:40  nickb
 *Rewrote most of this file, including getting the stack extension to work.
 *
 *Revision 1.11  1994/11/08  16:20:36  matthew
 *Save and restore fp registers around gc and C calls
 *
 *Revision 1.10  1994/10/28  12:42:19  jont
 *Untag continuation offsets before use
 *
 *Revision 1.9  1994/10/25  13:07:53  nickb
 *Also fix typo bug in c_raise.
 *
 *Revision 1.8  1994/10/20  11:23:35  nickb
 *Add a name to copy_up and copy_down.
 *
 *Revision 1.7  1994/09/15  17:20:15  jont
 *Reduce handler frame size to four words by leaving out fp
 *
 * Revision 1.6  1994/08/03  13:44:19  jont
 * Add closure to ml_state
 *
 * Revision 1.5  1994/07/27  13:50:32  jont
 * Remove dummy realpath (only there for Ultrix anyway)
 *
 * Revision 1.4  1994/07/22  16:43:28  jont
 * Add c_raise
 *
 * Revision 1.3  1994/07/20  14:24:35  jont
 * Add ml_raise code
 *
 * Revision 1.2  1994/07/15  16:48:59  jont
 * gc entry stuff
 *
 * Revision 1.1  1994/07/12  12:06:12  jont
 * new file
 *
 */

/* The signal-handling interface for the profiler, and for printing
 * backtraces after fatal signals, deduces the current topmost few
 * frames on the logical ML stack from the contents of certain
 * registers and the C variable global_state.in_ML.
 *
 * In order to do this it needs to assume certain invariants. Take
 * great care when modifying this file or you will break these
 * invariants.
 *
 * The signal-handler interface has the following pseudocode:
 * 
 * if global_state.in_ML == 0,
 * 	backtrace = CURRENT_THREAD->ml_state.sp
 * if global_state.in_ML != 0,
 * 	local 
 * 	  val missing_closures = 
 * 		(if $5 <> $6, andalso $5 is a closure,
 * 		    andalso $pc is in that code item,
 * 		then [$5,$6] else [$6])
 * 	  val rest_of_stack =
 * 		(if the instruction under pc is one of a small magic set,
 * 		 (connected with function entry and return)
 * 		then $fp else $sp)
 * 	  val _ = if $sp <> $fp then *($sp) := $fp
 * 	in
 * 	  backtrace = missing_closures @@ rest_of_stack
 * 	end
 * 
 * frames upwards from 'backtrace' are then examined by the profiler
 * or the backtrace printer, treating any without ML-tagged closures
 * as C frames.
 *
 * So, for instance, invariants obviously include:
 *
 * - when in_ML == 0, ml_sp must be valid
 * - when in_ML != 0,
 *		- $5 and $6 must not contain non-ML garbage
 *		- $sp and $fp must make _some_ sense together.
 * 		- if $sp doesn't point to a stack frame with 
 *		  a valid closure, one must be at a 'magic' instruction.
 * (see signals.c for a list).  */

#include "tags.h"
#include "offsets.h"
#include "macros.h"


	.set	noat
	.set	noreorder


/* === CALL ML FROM C ===
 *
 * callml is a C-like function which allows C to invoke an ML function in
 * the manner of a coroutine.
 *
 * The C global registers are stored in the structure c_state, and the
 * ML global state is loaded.  A new ML stack frame is allocated below
 * the base pointer of the current ML stack area (pointed to by %g6).
 * The ML function is then called.  On return the stack area base
 * pointer is restored to its calue on entry, the ML state is stored
 * and the C state loaded, then control returns to C.
 *
 *
 * Parameters:
 *   $4		 Argument for the ML function
 *   $5		 Closure of the function to call
 *   $31	 Link register for return to C
 * Returns:
 *   $2		 Result of the ML function
 */

	.globl	callml
callml:
	push_C_regs			/* save C callee saves on C stack */
	clean_callee_saves		/* clean $10-$15, $24-$25 */
	la	$10, global_state	/* global_state (GC-safe) in $10 */
	nop
	lw	$9, GLOBAL_current_thread($10) 		/* current thread */
	nop
	lw	$11, THREAD_c_sp($9)	/* old c_state.sp (GC-safe) in $11 */
	sw	$29, THREAD_c_sp($9)	/* Save new c_state.sp */
	load_ML_state
	lw	$30, THREAD_ml_sp($9)	/* Get ml_state.sp into fp */
	ori	$6, $0, STACK_C_CALL
	addiu	$29, $30, -4*4		/* make frame on the ML stack */
	sw	$11, 12($29)		/* old c_state.sp */
	sw	$31, 8($29)		/* link to caller */
	sw	$6, 4($29)		/* closure slot = STACK_C_CALL */
	sw	$10, GLOBAL_in_ML($10)	/* now in ML */
	clean_caller_saves		/* clean $16-$23 */
	lw	$1, -1($5)		/* Function closure */
	nop
	addu	$1, CODE_OFFSET
	jal	$1			/* Call ML */
	ori	$6, $0, STACK_START	/* with callee-closure = STACK_START*/

/* Enter ML with:

$4	argument
$5	closure
$6	caller's closure = STACK_START
$10	global_state (callee save)
$11	old c_sp (callee save)
$13-$25	all zero

So when we return, $10 and $11 will still have these values....
*/
	lw	$31, 8($29)
	addu	$29, 16			/* Pop ml frame */
	store_ML_state
	sw	$29, THREAD_ml_sp($9)		/* restore ml_state.sp */
	sw	$0, GLOBAL_in_ML($10)	/* no longer in_ML */
	lw	$29, THREAD_c_sp($9)	/* Get old C stack back */
	sw	$11, THREAD_c_sp($9)	/* restore c_sp */
	nop				/* delay slot */
	pop_C_regs			/* reload those C callee saves */
	j	$31			/* Return to C */
	move	$2, $4			/* Get result into C result reg */
/*
 * === STUBS FROM ML ===
 * 
 * These are static ML code vectors which call the routine pointed to
 * by their first closure element.  The C calling stub swaps into the
 * C state before calling the function, whereas the assembler version
 * does not. Since the MIPS assembler cannot build the constants we
 * need, we copy this code into code objects by hand in stubs.c, q.v.
 *
 * Note that the Irix calling convention passes the code address in $25.
 */

	.globl	text_internal_stub_c
	.globl	text_internal_stub_c_end
text_internal_stub_c:
	push_ML_regs			/* save ML callee-saves */
	lw	$16, THREAD_global($9)  /* get global state */
	store_ML_state
	sw	$29, THREAD_ml_sp($9)	/* Save last ML frame for GC */
	lw	$25, 3($5)		/* code address */
	sw	$0, GLOBAL_in_ML($16)	/* No longer in_ML */
	jal	$25			/* Call C function */
	lw	$29, THREAD_c_sp($9)	/* load C sp */

/* Enter C with these values in C callee-save regs (they will be preserved):
	$16	global_state
	$30	ML fp */

	move	$4, $2			/* answer into ML result reg */
	lw	$9, GLOBAL_current_thread($16)
	move    $5, $0			/* clear clos5 so profiling works */
	move    $6, $0			/* clear clos6 so profiling works */
	lw	$29, THREAD_ml_sp($9)	/* restore ML sp */
	sw	$16, GLOBAL_in_ML($16)	/* back in ML */
	load_ML_state
	pop_ML_regs			/* restore callee-saves */
	clean_caller_saves		/* clean caller saves, which could */
					/* contain dead values if C did a GC */
	j	$31			/* return */
	nop
text_internal_stub_c_end:

	.globl	text_internal_stub_asm
	.globl	text_internal_stub_asm_end
text_internal_stub_asm:
	lw	$1, 3($5)		/* Address to call */
	nop
	j	$1			/* Tail to it */
	nop
text_internal_stub_asm_end:

/* === LOOK UP A VALUE IN THE RUNTIME ENVIRONMENT ===
 *
 * Calls directly through to env_lookup() from environment.h.
 */

	.globl ml_lookup_pervasive
ml_lookup_pervasive:
	push_ML_regs
	ML_to_C(perv_lookup)
	nop				/* sp has just been loaded */
	pop_ML_regs
	j	$31			/* As the ml may immediately use it */
	nop

/*
 * === GARBAGE COLLECTOR ENTRY POINTS ===
 *
 * Non-leaf case:
 *  Parameters:
 *    $1  Number of bytes required
 *    $2  Top of live data + $1
 *    $6  Current closure
 *  Returns:
 *    $1  Address of allocated space
 *    $2  New top of live data + $1
 *    $3  New heap limit
 *    Other registers preserved.
 *
 * The address of this code is stored in the implcit vector (see
 * `implicit.h').  It is called when the heap start exceeds the heap
 * limit (i.e. when additional space needs to be found).
*/
	.globl	ml_gc
ml_gc:
	push_all_ML_regs		/* Save all the GCable registers */
	move	$4, $1			/* Size needed in C arg 1 */
	lw	$16, THREAD_global($9)	/* get global state */
	store_ML_state
	sw	$29, THREAD_ml_sp($9)	/* Save last frame for gc */
	sw	$0, GLOBAL_in_ML($16)	/* in_ML := 0 */
	lw	$29, THREAD_c_sp ($9)	/* Onto c stack */
	nop				/* delay slot */
	push_fps			/* save floating-point regs */
	jal	gc			/* Call garbage collector */
	move	$5, $6			/* With caller's closure in arg 2 */
	
/* Enter C with ML fp in $30 and global_state in $16; these are preserved */

	lw	$9, GLOBAL_current_thread($16)
	pop_fps				/* restore floating-point regs */
	lw	$29, THREAD_ml_sp($9)	/* Back onto the ML stack */
	move    $5, $0			/* clear clos5 so profiling works */
	move    $6, $0			/* clear clos6 so profiling works */
	sw	$16, GLOBAL_in_ML($16)	/* back in ML */
	load_ML_state			/* Puts GC return value in $1 */
	pop_all_ML_regs			/* reload all the GCable regs */
	j	$31			/* return */
	nop

/* Leaf case:
 *  Parameters:
 *    $1  Number of bytes required
 *    $2  Top of live data + $1
 *    $3  Link register back to ML code
 *  Returns:
 *    As non-leaf case.
 */
	.globl	ml_gc_leaf
ml_gc_leaf:
	sw	$30, 0($29)		/* Make a frame for the leaf */
	move	$30, $29	
	subu	$29, 16
	sw	$6,  4($29)		/* caller's closure */
	sw	$31, 8($29)		/* link to caller */
	move	$6,  $5			/* leaf's closure in closure reg */
	sw	$4, 12($29)		/* 'argument' slot */
	move	$31, $3			/* link to leaf in link reg */

/* Now proceed as for the non-leaf case : */

	push_all_ML_regs		/* Save all the GCable registers */
	move	$4, $1			/* amount to allocate */
	store_ML_state
	lw	$16, THREAD_global($9)	/* get global_state */
	sw	$29, THREAD_ml_sp($9)	/* Save last frame for gc */
	sw	$0, GLOBAL_in_ML($16)	/* in_ML := 0 */
	lw	$29, THREAD_c_sp($9)	/* Onto c stack */
	nop
	push_fps			/* save floating-point regs */
	jal	gc			/* Call garbage collector */
	move	$5, $6			/* With caller's closure in arg 2 */
	
/* Enter C with ML fp in $30 and global_state in $16; these are preserved */

	lw	$9, GLOBAL_current_thread($16)
	pop_fps				/* restore floating-point regs */
	lw	$29, THREAD_ml_sp($9)	/* Back onto the ML stack */
	move	$5, $0			/* clear clos5 so profiling works */
	move	$6, $0			/* clear clos6 so profiling works */
	sw	$16, GLOBAL_in_ML($16)	/* in_ML != 0 */
	load_ML_state			/* Puts GC return value in $1 */
	pop_all_ML_regs			/* reload all the GCable regs */

/* Now we need to pop the special frame made for the leaf
 * function. All our registers except $6, $31, sp and fp are as they
 * need to be at re-entry. $31 currently has the address to which we
 * need to re-enter; we have to hold that in fp temporarily. */

	move	$30, $31		/* keep return address in fp */
	lw	$6,  4($29)		/* reload caller's closure */
	lw	$31, 8($29)		/* reload caller's return address */
	addu	$29, 16			/* pop the leaf's frame */
	j	$30			/* return */
	lw	$30, 0($29)		/* restore the fp */
	
/* === FLUSH REGISTER WINDOWS ===
 *
 * This routine would invoke the window flushing trap on SPARC.  We
 * have it for portability of interface.h.
 */

	.globl	flush_windows

flush_windows:
	j	$31			/* Do nothing */
	nop

/*
 * === STACK OVERFLOW / ASYNCHRONOUS EVENT ===
 *
 * This code is called by ML when sp-STACK_BUFFER < slimit (unsigned).
 * This condition is checked by ML on function entry to ensure that
 * there is enough room for a frame, and is used by the asynchronous
 * event handler to trip up ML at a `safe' moment.
 * 
 * The comments here use function names as if e called f called g,
 * and g is the disturbed function.
 *
 * g jumps here with the following values in registers
 *
 *  $1	frame size required 
 *       (not including usual safety zone)
 *  $3  link to continue g
 *  $4, $17-$23: arguments of g
 *  $5  closure of g
 *  $6	closure of f
 *  $7	stack limit (or -1 if there's been an asynchronous event)
 *  $16 caller-save, so we can use it
 *  $29 the unchanged sp
 *  $30 fp = sp (the old fp has already been saved)
 *  $31 link to f
 */

	.globl	ml_disturbance

ml_disturbance:

/* make new stack frame */

	addiu	$sp, $sp, -16			/* make new stack frame: */
	sw	$1, 12($sp)			/* +12:	requirement	*/
	sw	$31, 8($sp)			/* +8:	link to f	*/
	sw	$6, 4($sp)			/* +4:  closure of f	*/
	lw	$16, -PAIRPTR($5)		/* code ptr of g */
	move	$31, $0
	addiu	$16, $16, CODE_OFFSET		/* code base of g */
	subu	$16, $3, $16			/* continuation offset for g */

/* Now we check whether a stack extension is required */
	lw	$3, IMPLICIT_stack_limit($9)	/* get true stack limit */
	subu	$6, $sp, $1			/* calculate new sp */
	slt	$6, $6, $3			/* do we require extension? */
	beq	$6, $0, check_for_events	/* if not, skip it */
	li	$6, STACK_DISTURB_EVENT		/* with $6 = DISTURB */

/* We  do require a stack extension, so we call make_stack */
	push_all_ML_regs
#ifdef COLLECT_STATS				
	la	$4, stack_extension_count	/* inc stack_extension_count */
	nop
	lw	$5, 0($4)
	nop
	addiu	$5, $5, 1
	sw	$5, 0($4)
#endif
/* we have requirement in $1, true stack limit in $3 */
	addiu	$4, $3, -(STACK_BUFFER+DEFAULT_STACK_SIZE)
						/* arg 0 = current stack */
	addiu	$5, $1, STACK_BUFFER+DEFAULT_STACK_SIZE
						/* arg 1 = requirement */
	ML_to_C(make_ml_stack)			/* exits with $9 = thread */
	addiu	$16, $4, STACK_BUFFER+DEFAULT_STACK_SIZE
						/* calculate new stack limit */
	sw	$16, IMPLICIT_stack_limit($9)	/* save it away */
	move	$7, $16				/* update the limit reg */
	lw	$1, 4($4)			/* new sp in global */

/* move onto new stack */
	pop_all_ML_regs
	move	$3, $sp				/* remember old sp in temp */
	lw	$6, 4($3)			/* get f closure */
	addiu	$sp, $1, -16			/* make frame on new block: */
	sw	$6, 4($sp)			/* +4: f closure */
	lw	$1, 12($3)			/* get required frame size */
	lw	$3, 8($3)			/* get link to f */
	sw	$1, 12($sp)			/* +12: required frame size */
	sw	$3, 8($sp)			/* +8: link to f */
	li	$6, STACK_EXTENSION

/* Now we test for events. We get here by one of two routes (depending
 * on whether we have extended the stack or not). Either way, $1
 * (required frame size), $4 $10-$15, $17-$25 have not changed, $7 is
 * the stack limit, $5 is g's closure, $6 is either STACK_EXTENSION or
 * STACK_DISTURB_EVENT, depending on whether we've done a stack
 * extension */

check_for_events:
	lw	$3, IMPLICIT_interrupt($9)	/* if either interrupt slot */
	nop					/* (delay slot) */
	or	$3, $3, $7			/* or stack limit register */
	bgtz	$3, call_disturbed_fn		/* is set, we have an event */
	nop					/* ... */

/* We have an event; call ev_poll */
	sw	$0, IMPLICIT_interrupt($9)	/* clear the interrupt slot */
	lw	$7, IMPLICIT_stack_limit($9)	/* restore the stack limit */
	push_all_ML_regs
	ML_to_C(ev_poll)
	pop_all_ML_regs

/* Now continue and call the disturbed function. Note that $6 is now
 * either STACK_EXTENSION or STACK_EVENT, according to whether we've
 * done a stack extension or not. */

/* Note that we must continue with fp = sp, *sp = old fp, and $1 unchanged */

call_disturbed_fn:
	lw	$1, -PAIRPTR($5)		/* code ptr of g */
	lw	$3, IMPLICIT_gc_limit($9)	/* restore GC limit */
	addiu	$1, $1, CODE_OFFSET		/* code base of g */
	addu	$16, $1, $16			/* continuation for g */
	sw	$fp, 0($sp)			/* save fp */
	lw	$1, 12($sp)			/* get global from frame */
	jalr	$31, $16			/* continue */
	move	$fp, $sp			/* fp = sp */

/* When we return, sp points to a frame size 12, either on the old or
 * new stack, which contains the caller's closure and return address. We
 * must determine whether we extended the stack, and un-extend it if
 * so. */

return_from_disturbed_fn:
	li	$1, STACK_EXTENSION		/* did we extend the stack? */
	lw	$31, 8($sp)			/* get link to caller */
	bne	$6, $1, return_to_caller	/* if not, return now */
	lw	$6, 4($sp)			/* get caller's closure */

/* We did a stack extension; we need to move back to the previous
 * stack and call unmake_stack. We have loads of registers free at
 * this point (result is in $4, but $1, $5, $16-$23 are all free). We
 * have to push a frame on the old stack containing all the
 * callee-saves, then call unmake_stack. We have to be careful to pass
 * the returned value back to the caller */
	
	addiu	$sp, $fp, -48			/* push frame on old stack */
	sw	$6, 4($sp)			/* save caller's closure */
	sw	$31, 8($sp)			/* save link to caller */
	sw	$30, 0($sp)			/* Fill Fp Slot */
	sw	$10, 12($sp)			/* Save ML Callee-Saves */
	sw	$11, 16($sp)
	sw	$12, 20($sp)
	sw	$13, 24($sp)
	sw	$14, 28($sp)
	sw	$15, 32($sp)
	sw	$24, 36($sp)
	sw	$25, 40($sp)
	sw	 $4, 44($sp)			/* save result */

	lw	$4, IMPLICIT_stack_limit($9)	/* get stack limit in $4 */
	nop
	addiu	$4, $4, -(STACK_BUFFER+DEFAULT_STACK_SIZE)
						/* arg 0 = new stack base */
	ML_to_C(unmake_ml_stack)
	addiu	$4, $4, (STACK_BUFFER+DEFAULT_STACK_SIZE) /* old stack limit */
	sw	$4, IMPLICIT_stack_limit($9)	/* save it in ml_state */
	move	$7, $4				/* and in the slimit reg */
	lw	$16, IMPLICIT_interrupt($9)	/* or slimit with interrupt */
	lw	$6, 4($sp)			/* restore clos in delay slot*/
	or	$7, $7, $16
	lw	$31, 8($sp)			/* restore link to caller */
	lw	$10, 12($sp)			/* Restore ML Callee-Saves */
	lw	$11, 16($sp)
	lw	$12, 20($sp)
	lw	$13, 24($sp)
	lw	$14, 28($sp)
	lw	$15, 32($sp)
	lw	$24, 36($sp)
	lw	$25, 40($sp)
	lw	 $4, 44($sp)			/* result of disturbed fn */

return_to_caller:
	move	$sp,$fp				/* pop the stack */
	lw	$fp, 0($sp)			/* restore fp */
		
	jr	$31				/* return to caller */
	nop		

/* event_check is entered when an explicit check is made on the stack
 * limit: has it been set to -1? If so, we come here with all
 * registers live. For ml_event_check the continuation address is in
 * $31. For ml_event_check_leaf the continuation is in $3. */

	.globl	ml_event_check
ml_event_check:
	push_all_ML_regs
	sw	$0, IMPLICIT_interrupt($9)
	ML_to_C(ev_poll)
	nop
	pop_all_ML_regs
	jr	$31
	nop

	.globl	ml_event_check_leaf
ml_event_check_leaf:
	sw	$30, 0($29)		/* create dummy frame for leaf fn */
	move	$30, $29
	subu	$29, 16
	sw	$0, 12($29)
	sw	$31, 8($29)
	sw	$6, 4($29)
	move	$31, $3			/* set up lr as if called */
	move	$6, $5			/* likewise closure */
	push_all_ML_regs		/* create new frame for all registers*/
	lw	$3, IMPLICIT_gc_limit($9)
	sw	$0, IMPLICIT_interrupt($9)
	ML_to_C(ev_poll)
	nop
	pop_all_ML_regs
	move	$5, $6
	move	$1, $31			/* return address in global */
	lw	$31, 8($29)		/* pop dummy frame */
	lw	$6, 4($29)
	move	$29, $30
	lw	$30, 0($29)
	jr	$1
	nop
	
/* === RAISE AN EXCEPTION FROM C === */
/* This is an entry point to _ml_raise which may be called from C. */

	.globl	c_raise
c_raise:

/* We unwind the stack to the most recent ML frame and raise the
 * exception from there. */

	la	$10, global_state	/* global_state (GC-safe) in $10 */
	move	$6, $0			/* clear clos6 so profiling works */
	lw	$9, GLOBAL_current_thread($10) 		/* current thread */
	move	$5, $0			/* clear clos5 so profiling works */
	load_ML_state
	lw	$29, THREAD_ml_sp($9)	/* back onto the ML stack */
	clean_caller_saves
	lw	$30, 0($29)		/* restore the fp */
	sw	$10, GLOBAL_in_ML($10)	/* now in ML */
	pop_ML_regs			/* restore ML callee-saves */

/* Now it looks as if we are raising the exception from the ML
 * function which made the call into C */

	/* \/\/ fall through \/\/ */

/* 
 * === RAISE AN EXCEPTION ===
 *
 * When an exception is raised the first exception handler function on
 * the handler chain is called to deal with it.	If the handler
 * function returns then the exception was handled.  The context of
 * the function in which the handler was created (the `creator') must
 * be restored and that function continued.  The stack frame is
 * restored repeatedly until we reach the one recorded in the handler
 * record (this is done by the unwind_stack macro).
 *
 * Handler record format:
 *   -1	Previous handler
 *    3	Frame pointer of creator
 *    7	Stack pointer of creator
 *   11	Handler function closure
 *   15	Offset within creator of continuation code
 *
 * Parameters:
 *   $4		The exception packet to raise
 *   $6		The current function's closure
 *   $31	Return address for resumption (not used at present, and not true for leaf)
 *   $8		Exception handler record
 *
 *
 * Warning. This code assumes that all procedures containing handler
 * continuations are non-leaf. This is currently true because setting
 * up a handler calls adr, which forces non-leaf because it corrupts $31.
 * However, should we produce a leaf adr by preserving $31 in $1, then
 * all hell will break loose.
 *
 */
	.globl	ml_raise
	.globl	ml_raise_leaf

/* Note: in a leaf function on MIPS the leaf's closure is not
 * available since it may have been overwritten. So we raise as if
 * from the calling function. */

ml_raise_leaf:
ml_raise:
#ifdef COLLECT_STATS
	la	$16, raise_count
	nop
	lw	$17, 0($16)
	nop
	addiu	$17, $17, 1
	sw	$17, 0($16)
#endif
	li	$1, STACK_RAISE		/* do not exchange with next instr */
	sw	$30, 0($29)		/* Save current frame pointer if not already done */
	beq	$6, $1, ml_raise10	/* Branch if already got a spare frame */
	lw	$5, 7($8)		/* Get handler closure */
	move	$30, $29		/* New fp */
	subu	$29, 16			/* New sp */
	sw	$30, 0($29)		/* Save fp just in case */
	sw	$6, 4($29)		/* Save caller's closure */
	sw	$0, 8($29)		/* Zero return address to avoid gc fiddling */
ml_raise10:
	sw	$8, 12($29)		/* Save current handler pointer */
	lw	$1, -1($5)		/* Get handler address */
	li	$6, STACK_RAISE		/* Our closure mark */
	addiu	$1, CODE_OFFSET
	jalr	$1			/* Call the handler */
	lw	$8, -1($8)		/* With previous handler pointer */
/*
 * Remove dummy frame from stack
 */
	lw	$6, 4($29)		/* Restore caller's closure */
	lw	$8, 12($29)		/* Restore handler pointer */
	move	$29, $30		/* Pop frame */
	lw	$30, 0($29)		/* And fp */
	lw	$1, 3($8)		/* Get sp of handler creator */
	nop
	lw	$18, 0($1)		/* And get fp from that */

	unwind_stack(raise)		/* Unwind to that fp, propagating result */
	lw	$1, 11($8)		/* Offset of continuation */
	lw	$5, -1($6)		/* Start of creator function */
	srl	$1, $1, 2		/* Untag it */
	addu	$1, CODE_OFFSET
	addu	$1, $5
	j	$1
	nop

/*
 * === CODE VECTOR REPLACEMENT AND INTERCEPTION ===
 *
 *
 * When compiled for debugging, code vectors contain a sequence of
 * three nop operations which can be replaced with code to intercept or
 * replace the flow of control.  This is used to implement tracing,
 * profiling, etc.
 *
 *  _ml_intercept (_ml_intercept_leaf) is jumped to by the instructions
 * inserted into a code vector when it is to be intercepted (see
 * `intercept_on' below).  It calls the C function `intercept', passing
 * its parameter and closure (see intercept.c).  When `intercept'
 * returns, the intercepted function is continued.
 * 
 * The above comments hold (mutatis mutandis) for 'replace'; in that
 * case the intercepted function is abandoned.
 *
 * These four routines all live on the implicit vector.
 *
 *  Parameters:
 *    $4, 17-23	parameters } of intercepted function
 *    $5/$6	closure    }
 *
 * Return address is in $31, or $3 for leaf versions.
 *
 */
	.globl	ml_replace
	.globl	ml_replace_leaf
	.globl	ml_intercept
	.globl	ml_intercept_leaf

ml_replace:
	push_all_ML_regs	/* this creates the frame passed to the intercept function */
	move	$4, $29		/* Pass frame to replace() */
	ML_to_C(replace)
	nop
	pop_all_ML_regs

/* Now we need to pop the function's own frame and return to the caller */

	lw 	$31, 8($29)
	lw	$6,  4($29)
	move	$29, $30
	lw	$30, 0($29)
	jr	$31
	nop

ml_intercept:
	push_all_ML_regs	/* this creates the frame passed to the intercept function */
	move	$4, $29		/* Pass frame to intercept() */
	ML_to_C(intercept)
	nop
	pop_all_ML_regs
	jr 	$31
	nop

ml_replace_leaf:
	sw	$30, 0($29)
	move	$30, $29
	subu	$29, 16
	sw	$4, 12($29)	/* The debugger expects the function arg here */
	sw	$31, 8($29)
	sw	$6, 4($29)
	move	$31, $3
	move	$6, $5
	push_all_ML_regs	/* this creates the frame passed to the intercept function */
	lw	$3, IMPLICIT_gc_limit($9)
	move	$4, $29
	ML_to_C(replace)
	nop
	pop_all_ML_regs
	move	$5, $6
	lw	$31, 8($29)
	lw	$6, 4($29)
	move	$29, $30
	lw	$30, 0($29)
	jr	$31
	nop

ml_intercept_leaf:
	sw	$30, 0($29)
	move	$30, $29
	subu	$29, 16
	sw	$4, 12($29)	/* The debugger expects the function arg here */
	sw	$31, 8($29)
	sw	$6, 4($29)
	move	$31, $3
	move	$6, $5
	push_all_ML_regs	/* this creates the frame passed to the intercept function */
	lw	$3, IMPLICIT_gc_limit($9)
	move	$4, $29
	ML_to_C(intercept)
	nop
	pop_all_ML_regs
	move	$5, $6
	move	$1, $31
	lw	$31, 8($29)
	lw	$6, 4($29)
	move	$29, $30
	lw	$30, 0($29)
	jr	$1
	nop

/* == Replacement code ==
 *
 * These are sections of code which are inserted at the start of a code
 * vector and altered to implement interception.  They are
 * INTERCEPT_LENGTH words long; four in the MIPS case.
 * 
 * There are four interception code segments; for intercepting and
 * replacing, for leaf and non-leaf functions. They call the relevant
 * bit of code above (_ml_intercept_on calls _ml_intercept, for
 * instance). _ml_nop is the sequence of three special nops which are
 * replaced by the intercepts; they are here so we can undo
 * interception.
 */
	.globl	ml_replace_on
	.globl	ml_replace_on_leaf
	.globl	ml_intercept_on
	.globl	ml_intercept_on_leaf
	.globl	ml_nop

ml_replace_on:
	lw	$1, IMPLICIT_replace($9)
	nop	
	jalr	$31, $1
	nop
ml_replace_on_leaf:
	lw	$1, IMPLICIT_replace_leaf($9)
	nop	
	jalr	$3, $1
	nop
ml_intercept_on:
	lw	$1, IMPLICIT_intercept($9)
	nop	
	jalr	$31, $1
	nop
ml_intercept_on_leaf:
	lw	$1, IMPLICIT_intercept_leaf($9)
	nop	
	jalr	$3, $1
	nop

/* <URI:mips/_mach_cg.sml#trace_dummy_instructions>
 * <URI:rts/gen/__tags.sml#MIPS_INTERCEPT_LENGTH>
 *
 * ml_nop should be the special no-op instruction "srl $0,$0,0",
 * repeated 4 times. However, there is no way of forcing the Irix 'as'
 * to assemble this instruction. So we hand-assemble it (it is
 * 0x00000002). There is also no way of forcing the Irix 'as' to
 * put constant words in the text segment. What a piece of shit. So we
 * put it in the data segment. */

	.data
ml_nop:
	.word	2
	.word	2
	.word	2
	.word	2
	.text

	.globl	generate_debugger_trap

generate_debugger_trap:
	break	0
	nop


	.globl switch_to_thread

switch_to_thread:
		save_thread_floats($4)
		save_thread_saves($4)
		sw	$31, THREAD_c_pc($4)	/* save pc */
		sw	$29, THREAD_c_tsp($4)	/* save fp */
		load_thread_floats($5)
		load_thread_saves($5)
		lw	$25, THREAD_c_pc($5)
		lw	$29, THREAD_c_tsp($5)
		jr	$25
		move	$2, $4			/* returns old thread to new */

/* Space profiling. ml_profile_alloc and ml_profile_alloc_leaf are
 * entered as if they were ml_gc and ml_gc_leaf respectively,
 * on every allocation in a profiled function, without a proper test
 * having been made for allocation overflow. We have a couple of slots
 * on the implicit vector for temporaries, if we need them. */

/*
 * Non-leaf case:
 *  Parameters:
 *    $1  Number of bytes required
 *    $2  Top of live data + $1
 *    $6  Current closure
 *  Returns:
 *    $1  Address of allocated space
 *    $2  New top of live data + $1
 *    $3  New heap limit
 *    Other registers preserved. */
	.globl	ml_profile_alloc
ml_profile_alloc:
	sw	$1, IMPLICIT_profile_alloc_2($9) /* save alloc amount */
	sub	$1, $2, $3			/* test for GC */
	bltz	$1, ml_profile_alloc_noGC	/* no GC */
	lw	$1, IMPLICIT_profile_alloc_2($9) /* restore alloc amount */
	sw	$30, 0($29)			/* save fp */
	move	$30, $29			/* new fp */
	subu	$29, 16 			/* create fake frame */
	sw	$6, 4($29)			/* allocator's closure */
	sw	$31, 8($29)			/* link to allocator */
	sw	$0, 12($29)			/* frame padding */
	la	$6, ml_gc			/* can't use a JAL here */
	nop
	jalr	$6				/* do the GC */
	ori	$6, $0, STACK_SPACE_PROFILE	/* fake frame closure */
	lw	$31, 8($29)			/* pop fake frame */
	lw	$6, 4($29)
	move	$29, $30
	lw	$30, 0($29)
	beq	$0, $0, ml_profile_alloc_record
	nop
ml_profile_alloc_noGC:	
	nop
	sub	$1, $2, $1			/* allocated point */
ml_profile_alloc_record:
	sw	$2, IMPLICIT_profile_alloc_2($9)	/* save alloc point */
	lw	$2, THREAD_ml_profile($9)	/* profile point */
	nop
	sw	$6, 0($2)		/* first word is the closure */
	sw	$1, 4($2)		/* second word is the alloc point */
	add	$2, 8			/* advance the profile point */
	sw	$2, THREAD_ml_profile($9) /* and save it */
	j	$31			/* return to caller */
	lw	$2, IMPLICIT_profile_alloc_2($9)	/* restore alloc pt */

/* Leaf case:
 *  Parameters:
 *    $1  Number of bytes required
 *    $2  Top of live data + $1
 *    $3  Link register back to ML code
 *  Returns:
 *    As non-leaf case.
 */
	.globl	ml_profile_alloc_leaf
ml_profile_alloc_leaf:
	sw	$3, IMPLICIT_profile_alloc_3($9) /* save link to allocator */
	lw	$3, IMPLICIT_gc_limit($9)	/* restore alloc limit */
	sw	$1, IMPLICIT_profile_alloc_2($9) /* save alloc amount */
	sub	$1, $2, $3			/* test for GC */
	bltz	$1, ml_profile_alloc_leaf_noGC	/* no GC */
	lw	$1, IMPLICIT_profile_alloc_2($9) /* restore alloc amount */

	sw	$30, 0($29)			/* save fp */
	move	$30, $29			/* new fp */
	subu	$29, 16 			/* create fake frame 1 */
	sw	$6, 4($29)			/* alloc's caller's closure */
	sw	$31, 8($29)			/* link to alloc's caller */
	sw	$0, 12($29)			/* frame padding */
	move	$6, $5
	lw	$31, IMPLICIT_profile_alloc_3($9) /* link to allocator */
	sw	$30, 0($29)			/* save fp */
	move	$30, $29			/* new fp */
	subu	$29, 16				/* create fake frame 2 */
	sw	$6, 4($29)			/* allocator's closure */
	sw	$31, 8($29)			/* link to allocator */
	sw	$0, 12($29)			/* frame padding */
	la	$6, ml_gc			/* can't use a JAL here */
	nop
	jalr	$6				/* do the GC */
	ori	$6, $0, STACK_SPACE_PROFILE	/* fake frame closure */
	lw	$31, 8($29)			/* pop fake frame 2 */
	lw	$6, 4($29)
	move	$29, $30			
	lw	$30, 0($29)			
	sw	$31, IMPLICIT_profile_alloc_3($9)	/* link to alloc */
	move	$5, $6				/* restore allocator */
	lw	$31, 8($29)			/* pop fake frame 1 */
	lw	$6, 4($29)
	move	$29, $30
	lw	$30, 0($29)
	beq	$0, $0, ml_profile_alloc_leaf_record
	nop
ml_profile_alloc_leaf_noGC:	
	nop
	sub	$1, $2, $1			/* allocated point */
ml_profile_alloc_leaf_record:
	sw	$2, IMPLICIT_profile_alloc_2($9)	/* save alloc point */
	lw	$2, THREAD_ml_profile($9)	/* profile point */
	nop
	sw	$5, 0($2)		/* first word is the closure */
	sw	$1, 4($2)		/* second word is the alloc point */
	add	$2, 8			/* advance the profile point */
	sw	$2, THREAD_ml_profile($9) /* and save it */
	lw	$2, IMPLICIT_profile_alloc_3($9)	/* link to allocator */
	nop	
	j	$2			/* return to caller */
	lw	$2, IMPLICIT_profile_alloc_2($9)	/* restore alloc pt */
	
#ifdef COLLECT_STATS
	.globl raise_count
	.globl stack_extension_count
#endif
@


1.36.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a29 4
 *Revision 1.36  1998/10/30  17:18:01  jont
 *[Bug #70226]
 *Remove raise_count and stack_extension_count (gone to mlw_start.c)
 *
@


1.35
log
@[Bug #1461]
Remove fake frame builds from ml_disturbance.
@
text
@d30 4
a1069 6
	.sdata
	.align 2
raise_count:
	.word 0
stack_extension_count:
	.word 0
@


1.35.9.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.8.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.7.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.6.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.6.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a29 3
 *Revision 1.35.6.1  1997/05/12  10:47:04  hope
 *branched from 1.35
 *
@


1.35.6.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a29 3
 *Revision 1.35.6.1  1997/05/12  10:47:04  hope
 *branched from 1.35
 *
@


1.35.6.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a29 3
 *Revision 1.35.6.1  1997/05/12  10:47:04  hope
 *branched from 1.35
 *
@


1.35.6.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a29 3
 *Revision 1.35.6.1.1.1  1997/07/28  18:26:35  daveb
 *branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.35.5.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.4.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.4.1.1.1
log
@branched from 1.35.4.1
@
text
@a29 3
 *Revision 1.35.4.1  1996/12/17  17:57:23  hope
 *branched from 1.35
 *
@


1.35.3.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.2.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.1.1
log
@branched from 1.35
@
text
@a29 4
 *Revision 1.35  1996/11/07  17:32:55  stephenb
 *[Bug #1461]
 *Remove fake frame builds from ml_disturbance.
 *
@


1.35.1.1.1.1
log
@branched from 1.35.1.1
@
text
@a29 3
 *Revision 1.35.1.1  1996/11/14  13:01:14  hope
 *branched from 1.35
 *
@


1.34
log
@Some URI comments for replacement_code
@
text
@d30 3
d440 6
a445 2
 * event handler to trip up ML at a `safe' moment.  The function
 * jumps here with the following values in registers:
d449 4
a452 4
 *  $3  link to continue disturbed function
 *  $4, $17-$23: arguments
 *  $5  closure
 *  $6	caller's closure
d454 1
a454 1
 *  $16 corrupted by entry to this code
d457 1
a457 1
 *  $31 link to caller
d464 17
a480 21
/* first we create a new stack frame; this frees up register 5 and
 * regularises the contents of the other registers. We save the
 * required frame size in one of the slots of this frame */

	addiu	$sp, $sp, -16			/* create dummy stack frame */
	sw	$1, 12($sp)			/* save required frame size */
	sw	$31, 8($sp)			/* with link to caller */
	sw	$6, 4($sp)			/* and caller's closure */
	move	$6, $5				/* free register 5 */
	move	$31, $3				/* move link */
	lw	$3, IMPLICIT_gc_limit($9)	/* restore  register 3 */

/* Now we check that a stack extension is required (could be we've
 * just had an event) */

extend_stack:
	lw	$16, IMPLICIT_stack_limit($9)	/* get true stack limit */
	subu	$5, $sp, $1			/* calculate new sp */
	slt	$5,$5,$16			/* if stack extension not */
	beq	$5, $0, check_for_events	/* required, skip it */
	li	$5, STACK_EVENT			/* with $5 = STACK_EVENT */
d483 1
a483 4
/* using $16 = true stack limit, $1 = required frame size */

	push_all_ML_regs			/* save all the ML regs */

d489 1
a489 1
	addiu	$5,$5,1
d492 2
a493 1
	addiu	$4, $16, -(STACK_BUFFER+DEFAULT_STACK_SIZE)
d498 1
a498 1
	addiu	$6, $4, STACK_BUFFER+DEFAULT_STACK_SIZE
d500 2
a501 2
	sw	$6, IMPLICIT_stack_limit($9)	/* save it away */
	move	$7, $6				/* update the limit reg */
d503 2
d506 9
a514 14
	
/* Having made a new stack block, we move our special frame off the
 * old stack block onto it. We keep the same $fp. The instructions
 * here have to be carefully ordered to satisfy the profiler */

	move	$16, $sp			/* remember old sp in temp */
	lw	$5, 4($16)			/* get caller's closure */
	addiu	$sp, $1, -16			/* make frame (keep old fp) */
	sw	$5, 4($sp)			/* save closure in new frame */
	lw	$1, 12($16)			/* get required frame size */
	lw	$16, 8($16)			/* get link to caller */
	sw	$1, 12($sp)			/* save required frame size */
	sw	$16, 8($sp)			/* save link to caller */
	li	$5, STACK_EXTENSION
d518 4
a521 4
 * (required frame size), $4 $10-$15, $17-$25 have not changed,
 * $7 is the stack limit, $6 is the closure of the disturbed function,
 * $5 is either STACK_EXTENSION or STACK_EVENT, depending on whether we've
 * done a stack extension */
d524 1
a524 1
	lw	$16, IMPLICIT_interrupt($9)	/* if either interrupt slot */
d526 2
a527 2
	or	$16, $16, $7			/* or stack limit register */
	bgtz	$16, call_disturbed_fn		/* is set, we have an event */
a533 1
	move	$6, $5				/* set our closure */
d537 1
a537 1
/* Now continue and call the disturbed function. Note that $5 is now
d544 4
a547 3
	move	$16, $5				/* swap closures */
	move	$5, $6
	move	$6, $16
a549 1
	move	$16, $31			/* link to continue in temp */
d554 1
a554 1
new stack, which contains the caller's closure and return address. We
d571 1
a571 1
	addiu	$sp, $30, -48			/* push frame on old stack */
@


1.34.3.1
log
@branched from 1.34
@
text
@a29 3
 *Revision 1.34  1996/08/16  13:44:37  io
 *Some URI comments for replacement_code
 *
@


1.34.2.1
log
@branched from 1.34
@
text
@a29 3
 *Revision 1.34  1996/08/16  13:44:37  io
 *Some URI comments for replacement_code
 *
@


1.34.1.1
log
@branched from 1.34
@
text
@a29 3
 *Revision 1.34  1996/08/16  13:44:37  io
 *Some URI comments for replacement_code
 *
@


1.33
log
@Some URI comments for replacement_code
@
text
@d30 3
d871 1
a871 3
/* <TAG:Replacement code>
 * <URI:mips/_mach_cg.sml#trace_dummy_instructions>
 * <URI:rts/gen/__tags.sml#MIPS_INTERCEPT_LENGTH
d911 4
a914 1
/* ml_nop should be the special no-op instruction "srl $0,$0,0",
@


1.32
log
@Load delay slot hazard not warned by SGI's shit assembler.
@
text
@d30 3
d868 3
a870 1
/* == Replacement code ==
@


1.31
log
@Fix bug in space profiling; can't use jal as the SGI assembler expands it.
@
text
@d30 3
d725 1
a726 1
	li	$1, STACK_RAISE
@


1.30
log
@Add space profiling.
@
text
@d30 3
d967 3
a970 2
	jal	ml_gc				/* do the GC */
	nop
d1022 3
a1024 1
	jal	ml_gc				/* do the GC */
@


1.29
log
@Move CURRENT_THREAD manipulation out of asm into portable C.
@
text
@d30 3
d935 5
a939 1
/* Space profiling. This is not yet implemented for the MIPS. */
d941 25
a965 4
	.globl	implicit_profile_alloc_code
	.globl	implicit_profile_alloc_code_end

implicit_profile_alloc_code:
d967 5
d973 1
d975 56
d1032 1
d1034 14
a1047 4
	nop
implicit_profile_alloc_code_end:
	nop

@


1.28
log
@Change to c_sp protocol.
@
text
@d30 3
d921 8
a928 19
		la	$8, global_state
		nop
		lw	$9, GLOBAL_current_thread($8)
		sw	$4, GLOBAL_current_thread($8)
		save_thread_floats($9)
		save_thread_saves($9)

/* if interrupt flag set in old thread, set it in the new thread also */

		lw	$10, IMPLICIT_interrupt($9)
		sw	$31, THREAD_c_pc($9)	/* save pc in delay slot */
		beq	$10, $0, switch_skip
		sw	$29, THREAD_c_tsp($9)	/* save fp in delay slot */
		sw	$10, IMPLICIT_interrupt($4)
switch_skip:		
		load_thread_floats($4)
		load_thread_saves($4)
		lw	$25, THREAD_c_pc($4)
		lw	$29, THREAD_c_tsp($4)
d930 1
a930 1
		move	$2, $9			/* returns old thread to new */
@


1.27
log
@Add dummy sequences for space profiling.
@
text
@d30 3
d230 1
d250 1
a250 1
	push_ML_regs			/* save ML callee-saves and c_sp */
d270 1
a270 1
	pop_ML_regs			/* restore callee-saves and c_sp */
d326 1
a326 1
	lw	$29, THREAD_c_sp($9)	/* Onto c stack */
d657 1
a657 1
	pop_ML_regs			/* restore ML callee-saves and c_sp */
d930 1
a930 1
		sw	$29, THREAD_c_sp($9)	/* save fp in delay slot */
d936 1
a936 1
		lw	$29, THREAD_c_sp($4)
@


1.26
log
@Fix unbounded stack growth from leaf raise problems
@
text
@d30 3
d935 15
@


1.25
log
@Modify raise code to remove stack copying down and up in favour of
a small extra frame.
@
text
@d30 4
a155 1
#define NEW_HANDLERS 1
d273 1
a273 1
	lw	$1, 3($5)		# Address to call
d275 1
a275 1
	j	$1			# Tail to it
d655 1
a655 1
	# \/\/ fall through \/\/
d706 4
a709 3
	sw	$30, 0($29)		# Save current frame pointer if not already done
	lw	$5, 7($8)		# Get handler closure
#if NEW_HANDLERS
d715 1
a718 12
#else
	andi	$16, $6, 1		# is caller closure an ML value? 
	beq	$16, $0, call_handler	# if not, skip this next part....
	lw	$1, -1($5)		# Get handler address
	compute_frame_size($6,$16)
	sll	$19, $16, 2
	copy_down(raise,$16, $17, $18)	# Copy down callee saves and linkage
	addu	$19, $29
	sw	$8, 0($19)		# Save old handler pointer
call_handler:
	nop
#endif
d720 2
a721 3
	jalr	$1			# Call the handler
	lw	$8, -1($8)		# With previous handler pointer
#if NEW_HANDLERS
d729 1
a729 8
#else
	compute_frame_size($6,$16)
	sll	$19, $16, 2
	addu	$19, $29
	lw	$8, 0($19)		# Get handler pointer back
	copy_up(raise, $16, $17, $18)	# Copy up callee saves and frame
#endif
	lw	$1, 3($8)		# Get sp of handler creator
d731 1
a731 1
	lw	$18, 0($1)		# And get fp from that
d733 4
a736 4
	unwind_stack(raise)		# Unwind to that fp, propagating result
	lw	$1, 11($8)		# Offset of continuation
	lw	$5, -1($6)		# Start of creator function
	srl	$1, $1, 2		# Untag it
@


1.24
log
@Save argument on stack in intercept and replace leaf
@
text
@d30 3
d86 18
a103 18
# Revision 1.6  1994/08/03  13:44:19  jont
# Add closure to ml_state
#
# Revision 1.5  1994/07/27  13:50:32  jont
# Remove dummy realpath (only there for Ultrix anyway)
#
# Revision 1.4  1994/07/22  16:43:28  jont
# Add c_raise
#
# Revision 1.3  1994/07/20  14:24:35  jont
# Add ml_raise code
#
# Revision 1.2  1994/07/15  16:48:59  jont
# gc entry stuff
#
# Revision 1.1  1994/07/12  12:06:12  jont
# new file
#
d152 2
d705 10
d716 1
a716 1
	beq	$16, $0, call_handler	# if so, skip this next part....
d725 1
d729 9
d743 1
@


1.23
log
@leaf intercept and replace were the wrong way round too
@
text
@d30 3
d764 2
a765 2
	push_all_ML_regs
	move	$4, $29
d780 2
a781 2
	push_all_ML_regs
	move	$4, $29			/* Pass frame to replace() */
d792 1
a792 1
	sw	$0, 12($29)
d797 1
a797 1
	push_all_ML_regs
d815 1
a815 1
	sw	$0, 12($29)
d820 1
a820 1
	push_all_ML_regs
@


1.22
log
@Workaround for the Irix 'as' silently removing our instructions.
@
text
@d30 3
d763 1
a763 1
	ML_to_C(intercept)
d779 1
a779 1
	ML_to_C(replace)
a800 1
	move	$1, $31
d805 1
a805 1
	jr	$1
d824 1
d829 1
a829 1
	jr	$31
@


1.21
log
@ml_replace and ml_intercept were the wrong way round
@
text
@d30 3
d868 9
d878 5
a882 4
	srl	$0,$0,0		/* these instructions are used in _mach_cg */
	srl	$0,$0,0		/* so the scheduler doesn't remove them */
	srl	$0,$0,0
	srl	$0,$0,0
@


1.20
log
@Fix ml_disturbance; a closure/link address pair are not getting in
the same stack frame.
@
text
@d30 4
a755 9
	move	$4, $29			/* Pass frame to replace() */
	ML_to_C(replace)
	nop
	pop_all_ML_regs
	jr 	$31
	nop

ml_intercept:
	push_all_ML_regs
d768 9
@


1.19
log
@Got the operands to jalr backwards in the intercept/replace pieces of code.
@
text
@d30 3
d396 1
d402 2
a403 1
 *  $30 link to continue function
d406 1
d411 3
a413 3
/* first we create a new stack frame; this frees up register 6 and
 * gives us a working fp. We save the required frame size in one of
 * the slots of this frame */
d419 3
a421 2
	move	$31, $30			/* move link out of fp */
	addiu	$30, $sp, 16			/* set fp up correctly */
d428 4
a431 4
	subu	$6, $sp, $1			/* calculate new sp */
	slt	$6,$6,$16			/* if stack extension not */
	beq	$6, $0, check_for_events	/* required, skip it */
	li	$6, STACK_EVENT
d459 2
a460 1
 * old stack block onto it. We keep the same $fp */
d463 1
d465 1
a465 1
	lw	$6, 4($16)			/* get caller's closure */
d468 1
a468 1
	sw	$6, 4($sp)			/* save closure in new frame */
d470 1
a470 2
	sw	$1, 12($sp)			/* save required frame size */
	li	$6, STACK_EXTENSION
d474 4
a477 3
 * (required frame size), $4, $5, $10-$15, $17-$25 have not changed,
 * $7 is the stack limit, $31 is the link to continue the disturbed
 * function, $6 = STACK_EXTENSION or STACK_EVENT */
d486 1
a486 1
/* We have an event; call event_poll */
d490 1
a491 1
	nop
d494 1
a494 1
/* Now continue and call the disturbed function. Note that $6 is now
d501 3
d521 6
a526 6
/* We did a stack extension; we need to move back to the previous stack and
 * call unmake_stack. We have loads of registers free at this point
 * (result is in $4, but $16-$23 are all free). We have to push a
frame on the old stack containing all the callee-saves, then call
unmake_stack. We have to be careful to pass the returned value back to
the caller */
a528 1
	sw	$30, 0($sp)			/* Fill Fp Slot */
d531 1
d550 3
a552 4
	lw	$16, IMPLICIT_interrupt($9)	/* and or that with the */
	nop					/* (delay) */
	or	$7, $7, $16			/* interrupt slot */
	lw	$6, 4($sp)			/* restore caller's closure */
@


1.18
log
@Oops. Of course I meant clean_caller_saves, not clean_callee_saves.
@
text
@d30 3
d729 1
a729 1
 *    $5	closure    }
d731 1
a731 1
 * Return address is in $31, or $16 for leaf versions.
d833 1
a833 1
	jalr	$1, $31
d838 1
a838 1
	jalr	$1, $3
d843 1
a843 1
	jalr	$1, $31
d848 1
a848 1
	jalr	$1, $3
@


1.17
log
@Fix some problems with c_raise.
Also add a cautionary comment.
@
text
@d30 4
d612 1
a612 1
	clean_callee_saves
@


1.16
log
@Change the manipulation of the in_ML flag so that:
(a) in_ML false => thread->ml_state.sp is meaningful
(b) in_ML true => sp,fp,closures make some sense for ML.
@
text
@d14 5
d30 5
d79 43
d608 2
@


1.15
log
@Add threads system.
@
text
@d25 3
d105 1
a105 1
	sw	$10, GLOBAL_in_ML($10)	/* now in ML */
d115 1
d138 1
a138 1
	move	$2, $4			/* Get result into C result reg */
d143 1
a143 2
	sw	$0, GLOBAL_in_ML($10)	/* no longer in_ML */

d164 2
a166 2
	jal	$25			/* Call C function */
	sw	$0, GLOBAL_in_ML($16)	/* No longer in_ML */
d174 4
a177 1
	sw	$16, GLOBAL_in_ML($16)
a178 2
	lw	$29, THREAD_ml_sp($9)	/* restore ML sp */
	nop
d234 1
d236 1
a236 1
	move	$5, $6			/* With caller's closure in arg 2 */
d239 1
a239 1
	sw	$0, GLOBAL_in_ML($16)	/* in_ML := 0 */
d244 4
a248 1
	pop_fps				/* restore floating-point regs */
a249 2
	lw	$29, THREAD_ml_sp($9)	/* Back onto the ML stack */
	nop
d269 1
a271 1
	move	$6,  $5			/* leaf's closure in closure reg */
d278 1
d280 1
d282 1
a282 1
	lw	$16, THREAD_global($9)	/* get global_state */
d284 1
a285 2
	jal	gc			/* Call garbage collector */
	sw	$0, GLOBAL_in_ML($16)	/* in_ML := 0 */
d291 3
a294 1
	lw	$29, THREAD_ml_sp($9)	/* Back onto the ML stack */
d550 1
a550 1
	nop
d552 3
a555 2
	lw	$29, THREAD_ml_sp($9)	/* back onto the ML stack */
	load_ML_state
@


1.14
log
@Make ml_raise_leaf do something. Also fix c_raise (it's
getting the wrong closure).
@
text
@d25 4
d99 1
a99 1
	la	$10, c_state		/* c_state (GC-safe) in $10 */
d101 6
a106 5
	lw	$11, 0($10)		/* old c_state.sp (GC-safe) in $11 */
	sw	$29, 0($10)		/* Save new c_state.sp */
	load_ML_state(ml_state, $12, $16) /* ml_state (GC-safe) in $12 */
					  /* $16 caller-save (will clean)*/
	lw	$30, 24($12)		/* Get ml_state.sp into fp */
d124 2
a125 3
$10	c_state (callee save)
$11	old c_state.sp (callee save)
$12	ml_state (callee save)
d128 1
a128 1
So when we return, $10-$12 will still have these values....
d132 2
a133 2
	store_ML_state_with($12)
	sw	$29, 24($12)		/* restore ml_state.sp */
d135 2
a136 2
	lw	$29, 0($10)		/* Get old C stack back */
	sw	$11, 0($10)		/* Save old c_state.sp */
d139 1
a139 1
	nop
d156 4
a159 4
	push_ML_regs			/* save ML callee-saves */
	store_ML_state(ml_state, $16)
	sw	$29, 24($16)		/* Save last ML frame for GC */
	la	$17, c_state
d161 1
a161 1
	lw	$29, 0($17)		/* load C sp */
d163 1
a163 1
	nop				
d166 1
a166 2
	$16	ml_state
	$17	c_state
d170 4
a173 2
	load_ML_state_with($16, $18)	/* restore ML state */
	lw	$29, 24($16)		/* restore ML sp */
d175 1
a175 1
	pop_ML_regs			/* restore callee-saves */
d227 5
a231 6
	store_ML_state(ml_state, $16)
	sw	$29, 24($16)		/* Save last frame for gc */
	la	$17, c_state
	nop
	lw	$29, 0($17)		/* Onto c stack */
	nop
d234 1
a234 1
	move	$5, $6			/* With caller's closure in arg 2 */
d236 1
a236 1
/* Enter C with ML fp in $30 and ml_state in $16; these are preserved */
d238 2
d241 2
a242 2
	load_ML_state_with($16, $11)	/* Puts GC return value in $1 */
	lw	$29, 24($16)		/* Back onto the ML stack */
d271 4
a274 6
	store_ML_state(ml_state, $16)
	sw	$29, 24($16)		/* Save last frame for gc */
	la	$17, c_state
	nop
	lw	$29, 0($17)		/* Onto c stack */
	nop
d276 1
d278 1
a278 1
	move	$5, $6			/* With caller's closure in arg 2 */
d280 1
a280 1
/* Enter C with ML fp in $30 and ml_state in $16; these are preserved */
d282 1
d284 3
a286 3
	load_ML_state_with($16, $11)	/* Puts GC return value in $1 */
	lw	$29, 24($10)		/* Back onto the ML stack */
	nop
d351 1
a351 3
	la	$6, ml_state
	nop
	lw	$16, 12($6)			/* get true stack limit */
d355 1
a355 1
	li	$6, STACK_EXTENSION
d374 1
a374 1
	ML_to_C(make_stack) 			/* exist with $16= &ml_state */
d377 1
a377 1
	sw	$6, 12($16)			/* save it away */
d399 1
a399 1
 * function, $6 = STACK_EXTENSION */
d410 1
a410 4
	la	$16,ml_state
	nop
	lw	$7, 12($16)			/* restore the stack limit */
	li	$6, STACK_EVENT
d461 1
a461 3
	la	$16, ml_state
	nop
	lw	$4, 12($16)			/* get stack limit in $4 */
d465 1
a465 1
	ML_to_C(unmake_stack)
d467 1
a467 3
	la	$16, ml_state
	nop
	sw	$4, 12($16)			/* save it in ml_state */
d491 4
a494 1
/* SPARC version of ml_disturbance removed here */
a496 1
	.globl	ml_event_check_die
d498 3
a500 1
	jal	ml_event_check_die
d502 2
a503 10
#if 0
	save	%sp, -0x40, %sp		! Create extra frame
	sethi	%hi(ml_state), %o0
	or	%o0, %lo(ml_state), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	mov	STACK_EVENT, %i1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
	ML_to_C(_ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
d505 1
a505 6
/*
 * %o1 function closure
 * %o7 function return address
 * %g4 return address from here
 */
#endif
a506 1
	.globl	ml_event_check_leaf_die
d508 21
a528 1
	jal	ml_event_check_leaf_die
a529 15
#if 0
	save	%sp, -0x40, %sp		! Create a frame, so %i1 = function closure
	mov	%g4, %o7		! Save return address

/* Poll code */

	save	%sp, -0x40, %sp		! Create extra frame
	sethi	%hi(ml_state), %o0
	or	%o0, %lo(ml_state), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	mov	STACK_EVENT, %i1
	ML_to_C(_ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	restore
a533 1
#endif
a534 1

d537 2
a538 7
/*
 * Now we must wind back the c stack explicitly to avoid the ml stack
 * threading back through a bit of C stack we have thrown away and
 * then reused.
 *
 * Rewind to previous ml_state.sp
 */
d540 1
a540 2
	load_ML_state(ml_state, $10, $11)
	lw	$29, 24($10)		# Reload ml_state.sp
d542 8
a549 3
	lw	$30, 0($29)		# And frame pointer
	lw	$6, 44($29)		# closure as saved by push_ML_regs
	clean_caller_saves
d558 1
a558 1
 * function returns then the exception was handled.  In the context of
d560 3
a562 13
 * be restored and that function continued.  Restore instructions are
 * executed repeatedly until the current stack pointer matches the
 * pointer that was stored in the handler record.
 *
 * There are some subtleties.  The stack may be disjoint, so, after
 * crawling our way back up it the C function _unwind_stack is called
 * to deallocate an extensions that are no longer required.
 *
 * If the handler record is zero then the next handler is the top-level
 * handler, and the C function handle() is called.  This returns iff a
 * debugger is installed, and passes some information about where to
 * find it.  In this case, the debugger is called, and that in turn
 * returns instructions for what to do next.
d588 4
d594 7
a600 6
#if 0 /*def COLLECT_STATS*/
	sethi	%hi(_raise_count), %o1
	or	%o1, %lo(_raise_count), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
d604 3
a609 1
	lw	$1, -1($5)		# Get handler address
d612 2
d615 1
a615 1
	jal	$1			# Call the handler
d626 1
a626 1
	unwind_stack($30, raise)	# Wind back to that frame, propagating result
a634 52
#if 0
#ifdef COLLECT_STATS
	sethi	%hi(_raise_count), %o1
	or	%o1, %lo(_raise_count), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
#endif

/* New code for stack extending when needed for leaf raise */

	sub	%sp, STACK_BUFFER+0x40, %g4	! Extension needed test
	cmp	%g4, %g6		! The test
	bcc	_ml_raise		! Branch if ok
	ld	[%g5+IMPLICIT_extend], %g4
	jmpl	%g4, %o4		! Extend stack
	mov	STACK_BUFFER+0x40, %o3	! Required size
	save	%sp, -0x40, %sp		! New frame on new stack
	mov	%i0, %o0		! Argument to raise
	ba	_ml_raise		! And as before (note handler continuation
	mov	STACK_RAISE, %i1	! will unwind the stack extension)

toplevel_handler:
	ML_to_C(_handler)
	ta	1			! Should never return

continue_from_interrupt:
	mov	%o0, %g4		! The resume frame from the exn packet
	unwind_stack(%sp, top)		! Wind back to that frame
	retl
	nop

/* === CAUSE A FATAL ERROR ===
 *
 * Expects an error format string to follow the call instruction and
 * delay slot.
 */

error:	add	%o7, 8, %o0
	ML_to_C(_error)
	ta	1


/* === DEBUGGING TRAP === */

	.globl	_ml_trap

_ml_trap:
	ta 1
	retl
	nop

d656 2
a657 2
 *    %o0	parameter } of intercepted function
 *    %o1	closure   }
d659 1
a659 1
 * Return address is in %o7, or %g4 for leaf versions.
a661 1
#endif
a665 4
	.globl	ml_replace_die
	.globl	ml_replace_leaf_die
	.globl	ml_intercept_die
	.globl	ml_intercept_leaf_die
d668 22
a689 1
	jal	ml_replace_die
a690 6
#if 0
	mov	%sp, %o0		! Pass frame to replace()
	ML_to_C(replace)
	ret
	restore				! Pop callers frame
#endif
d693 12
a704 1
	jal	ml_replace_leaf_die
d706 8
a713 9
#if 0
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%sp, %o0		! Pass frame to replace()
	ML_to_C(_replace)
	ret				! Return to function caller
	restore				! Throw away dummy frame
#endif
ml_intercept:
	jal	ml_intercept_die
d715 1
a715 8
#if 0
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(_intercept)
	ret				! Return to intercepted code
	restore
#endif
d717 20
a736 1
	jal	ml_intercept_leaf_die
a737 10
#if 0
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%g4, %o7		! Pretend it called here
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(_intercept)
	restore
	jmpl	%o7+8, %g0		! Back to caller...
	restore				! ...removing its frame
d743 1
a743 1
 * INTERCEPT_LENGTH words long (from tags.h); three in the SPARC case.
a751 1
#endif
a756 5
	.globl	ml_replace_on_die
	.globl	ml_replace_on_leaf_die
	.globl	ml_intercept_on_die
	.globl	ml_intercept_on_leaf_die
	.globl	ml_nop_die
d759 3
a761 5
	jal	ml_replace_on_die
	nop
#if 0
	ld	[%g5+IMPLICIT_replace], %g4
	jmpl	%g4, %o7
a762 1
#endif
d764 3
a766 5
	jal	ml_replace_on_leaf_die
	nop
#if 0
	ld	[%g5+IMPLICIT_replace_leaf], %g4
	jmpl	%g4, %g4
a767 1
#endif
d769 3
a771 1
	jal	ml_intercept_on_die
a772 5
#if 0
	ld	[%g5+IMPLICIT_intercept], %g4
	jmpl	%g4, %o7
	nop
#endif
d774 3
a776 1
	jal	ml_intercept_on_leaf_die
a777 6
#if 0
	ld	[%g5+IMPLICIT_intercept_leaf], %g4
	jmpl	%g4, %g4
	nop

#endif
d779 4
a782 5
	nop		/* nops are used in mach_cg so that */
	nop		/* the scheduler does not move them. */
	nop
	jal	ml_nop_die
	nop
d789 37
@


1.13
log
@Rewrote most of this file, including getting the stack extension to work.
@
text
@d25 3
d559 1
a559 5
#if 0	/* This is incorrect, as it misses out the stub frame */
	/* The problem is sorted in load_ML_state */
	lw	$6, 4($29)		# /*And caller's closure*/
#endif

a561 6
#if 0
	clean_windows
	save	%sp, -0x40, %sp		! Make first ML stack frame below the base
	mov	STACK_C_RAISE, %i1	! Mark this frame
	mov	%i0, %o0		! Propagate exception
#endif
a607 1
	.globl	ml_raise_leaf_die
d609 1
a646 3
ml_raise_leaf:
	jal	ml_raise_leaf_die
	nop
@


1.12
log
@Temporary hacked version.
@
text
@a87 1

a88 1

d90 9
a98 16
	addu	$29, -14*4		/* 9 words for C callee saves, 1 for lr, 4 for args */
	sw	$31, 16($29)		/* lr */
	sw	$16, 20($29)
	sw	$17, 24($29)
	sw	$18, 28($29)
	sw	$19, 32($29)
	sw	$20, 36($29)
	sw	$21, 40($29)
	sw	$22, 44($29)
	sw	$23, 48($29)
	sw	$30, 52($29)		/* nine C callee saves */
	address_C_globals(c_state, $10)
	lw	$16, 0($10)		/* get c_state.sp */
	sw	$29, 0($10)		/* Save new value */
	load_ML_state(ml_state, $11, $12)
	lw	$30, 24($11)		/* saved ml_state.sp */
d100 5
a104 5
	addiu	$29, $30, -4*4		/* fp, closure, lr, c_sp */
	sw	$16, 12($29)
	sw	$31, 8($29)
	sw	$6, 4($29)
	clean_current_registers
d109 15
a123 2
	ori	$6, $0, STACK_START	/* (marking start of ML stack) */
	lw	$16, 12($29)		/* Reload c_sp */
d125 3
a127 4
	store_ML_state(ml_state, $11, callml)
	sw	$29, 24($11)		/* restore ml_state.sp */
	move	$2, $4			/* Get result */
	address_C_globals(c_state, $10)
d129 2
a130 12
	sw	$16, 0($10)		/* Remember previous C stack */
	lw	$31, 16($29)		/* lr */
	lw	$16, 20($29)
	lw	$17, 24($29)
	lw	$18, 28($29)
	lw	$19, 32($29)
	lw	$20, 36($29)
	lw	$21, 40($29)
	lw	$22, 44($29)
	lw	$23, 48($29)
	lw	$30, 52($29)		/* nine C callee saves */
	addu	$29, 14*4
d132 1
a132 1
	nop				/* Dunno what code we return to will access */
d136 6
d143 1
a143 4
 * These are static ML code vectors which call the routine pointed to
 * by their first closure element.  The C calling stub swaps into the C
 * state before calling the function, whereas the assembler version
 * does not.
a145 52
#if 0 /* Now in C */
	.data
	.globl	stub_c
	.globl	stub_asm

stub_c:	.word	internal_stub_c+POINTER
stub_asm:	.word	internal_stub_asm+POINTER


/* We have to build fake ancillary information */

	.align	8
stubancill:				# this is a pair
	.word	stubnames + PAIRPTR
	.word	stubprofiles + PAIRPTR

	.align	8
stubnames:				# this is a pair
	.word	sc_name + POINTER
	.word	sa_name + POINTER

	.align	8
stubprofiles:				# this is a pair
	.word 0
	.word 0

	.align	8
sc_name:
	.word	((sc_name_end - sc_name - 4) << 6) | STRING
	.asciiz	"stub to C"
sc_name_end:

	.align	8
sa_name:
	.word	((sa_name_end - sa_name_4) << 6) | STRING
sa_name_4:
	.asciiz	"stub to assembler"
sa_name_end:

	.align	8
stub_code_vector:
	.word	(((stub_code_end-stub_code_vector)-4)<<6) | CODE
	.word	stubancill + PAIRPTR

	.align	8
internal_stub_c:	.word	(internal_stub_c - stub_code_vector) << 6 | BACKPTR
	.word	0x7f00			# Code element 0
					# (no spills,leaf,intercept)

#endif

	.text
d149 22
a170 23
	save_ML_regs
	store_ML_state(ml_state, $16, stub_c)
	sw	$29, 24($16)		# Save last ML frame for GC
	sw	$30, 0($29)		# And get the fp correct in it
	address_C_globals(c_state, $17)

	lw	$25, 3($5)
	lw	$29, 0($17)		# address of last C stack frame
	nop
	store_callee_save_fps ($29)	# save away necessary fps

	jal	$25			# Call C function (should perserve $30)
	nop				# Note that the use of $25 here is important
	move	$4, $2			# Get the answer

	load_callee_save_fps ($29)	# restore fps

/* Shouldn't be needed
	address_C_globals(c_state, $17)
	sw	$29, 0($17)
*/
	load_ML_state(ml_state, $16, $18)
	lw	$29, 24($16)		# Point back to ml frame
d172 1
a172 6
	lw	$30, 0($29)		# Reload fp as well
	load_ML_regs
	clean_caller_saves		# caller saves could contain dead
					# values if C caused a GC
	j	$31
	nop
a173 15
text_internal_stub_c_end:
#if	0
	.data
	.globl	data_internal_stub_c
data_internal_stub_c:
	.space	text_internal_stub_c_end - text_internal_stub_c
	/* Room to copy the code in here */

	.align	8
internal_stub_asm:
	.word	(internal_stub_asm - stub_code_vector) << 6 | BACKPTR
	.word	0x7f01			# Code element 1
					# (no spills, leaf, intercept)
#endif
	.text
a181 10
#if 0
	.data
	.globl	data_internal_stub_asm
data_internal_stub_asm:
	.space	(text_internal_stub_asm_end - text_internal_stub_asm)
	/* Room to copy the code in here */
#endif
	.text
stub_code_end:
	.align	4
a188 1

d190 1
a190 1
	save_ML_regs
d192 2
a193 2
	nop
	load_ML_regs
d196 1
a196 1
#if 0
d198 1
a198 1
 * === GARBAGE COLLECTOR ENTRY POINT ===
d204 1
a210 8
 * Leaf case:
 *  Parameters:
 *    $1  Number of bytes required
 *    $2  Top of live data + $1
 *    $3  Link register back to ML code
 *  Returns:
 *    As non-leaf case.
 *
a214 2

#endif
d217 5
a221 7
	save_all_ML_regs		/* Save all the standard registers */
	move	$4, $1			/* Size needed */
	store_ML_state(ml_state, $10, ml_gc)
	sw	$29, 24($10)		/* Save last frame for gc */
	sw	$30, 0($29)		/* and get fp correct in it */
	address_C_globals(c_state, $11)
	lw	$29, 0($11)		/* Onto c stack */
d223 3
a225 3
	store_fps($29)			/* Store fps */

	move	$5, $6			/* With caller's closure in parameter */
d227 3
a229 3
	nop

	load_fps($29)			/* And restore; don't bother resetting sp */
d231 3
a233 5
/* Shouldn't be needed
	store_C_globals(c_state, %o2)
*/
	load_ML_state(ml_state, $10, $11)	# Puts return value in $1
	lw	$29, 24($10)		# Point back to ml frame
d235 2
a236 3
	lw	$30, 0($29)		# Reload fp as well
	load_all_ML_regs
	j	$31
d239 8
a246 3
/* this should call ml_gc_leaf_die, but that doesn't exist any
more. Temporary change. */

a247 1
	.globl	ml_disturbance_die
d249 18
a266 1
	jal	ml_disturbance_die
d268 5
a272 22
#if 0
	save	%sp, -64, %sp		! Make frame for caller registers
	mov	%g4, %o0
	mov	%i1, %o1		! Propagate closure for gc
	mov	%g2, %o7		! Store leaf case link register
	store_ML_state(ml_state, %o2, _ml_gc_leaf)
	st	%sp, [%o2 + 32]		! Save base of ML stack (see callml)
	load_C_globals(c_state, %o3)
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp		! Switch to C stack
	st	%sp, [%i2 + 28]		! Save last ML frame for GC
	store_fps(%sp+88)
	mov	%i0, %o0
	call	_gc			! Call garabage collector
	mov	%i1, %o1		! (with size and closure)
	load_fps(%sp+88)
	store_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	restore				! Switch back to ML stack
	clean_windows
	jmpl	%o7+8, %g0		! Return to ML
	restore				! Pop back caller's `o' registers
d274 18
a291 2

#endif
d294 2
a295 2
 * This routine simply invokes the window flushing trap.  It is here so
 * that C can do it neatly.
d301 1
a301 1
	j	$31			/* Still in use?? */
a303 6
#if 0
	xnor	%g0, %g0, %o0
	retl
	st	%o0, [%fp+0xf8]		! Blech!  Blat %g6 with -1.


d307 1
a307 1
 * This code is called by ML when %sp-STACK_BUFFER < %g6 (unsigned).
d311 1
a311 1
 * jumps here with the following parameters:
d313 9
a321 8
 *  %o0  function argument
 *  %o1  function closure
 *  %o3  minimum stack requirement of function
 *       (not including safety zone of 2kb or the normal register save area)
 *       (these are added in here)
 *  %o4  link to continue function
 *  %o7  link to functions caller
 *  %g6  current stack area or -1 for asynchronous event
a322 1
#endif
a323 1
	.globl	ml_disturbance_die
d326 14
a339 18
	jal	ml_disturbance_die
	nop
#if 0
	save	%sp, -0x40, %sp
	mov	%i4, %o7		! So gc can fix return link
	addcc	%g6, 1, %g0		! Is %g6 -1? (events pending)
	beq,a	event_poll
	nop
	! \/\/ fall through \/\/

/* == Extend ML stack ==
 *
 * If a function is disturbed by lack of stack this code allocates a
 * new stack area by calling make_stack() in the storage manager and
 * linking to the new stack using a special stack frame.  It then calls
 * the remainder of the disturbed function, deallocating the stack on
 * its return.
 */
d342 35
a376 47
#ifdef COLLECT_STATS
	sethi	%hi(_stack_extension_count), %o0
	or	%o0, %lo(_stack_extension_count), %o0
	ld	[%o0], %g4
	add	%g4, 1, %g4
	st	%g4, [%o0]
#endif
	add	%i3, STACK_BUFFER+DEFAULT_STACK_SIZE, %o1
				! Minimum stack requirement is second arg
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
				! Current stack area is first arg
	ML_to_C(_make_stack)		! Allocate a new stack area
	sethi	%hi(ml_state), %i2
	or	%i2, %lo(ml_state), %i2
	ld	[%o0+0x4], %g4		! Get top of new stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%i2+16]		! Install the new stack in ml_state
	addcc	%g6, 1, %g0		! Was there an event while in C?
	bne,a	ext0
	mov	%o0, %g6		! Install the new stack in %g6
ext0:	restore	
	save	%g4, -0x40, %sp		! Link to new stack
	mov	%i1, %o1		! Propagate arguments
	mov	%i0, %o0
	jmpl	%i4+8, %o7		! Call rest of disturbed function
	mov	STACK_EXTENSION, %i1	! (Mark the extra frame)
	! \/\/ fall through \/\/

extend_return:
	mov	%o0, %i0		! Propagate result to caller
	restore				! Restore back to the old stack, since it is about to disappear
	save	%sp, -0x40, %sp		! Make a frame on the old stack
	addcc	%g6, 1, %g0		! Is an event flagged?
	beq,a	ext1
	sethi	%hi(ml_state), %i2
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	ML_to_C(_unmake_stack)		! Deallocate the stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %g6
	ret
	restore
ext1:	or	%i2, %lo(ml_state), %i2
	ld	[%i2+16], %o0		! (Fetch real stack from ml_state.)
	ML_to_C(_unmake_stack)		! Deallocate the stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%i2+16]		! Update ml_state with older stack
	ret
	restore				! Return to functions caller
d378 112
a489 5
/* == Poll asynchronous events ==
 *
 * If a function has been disturbed by having %g6 = -1 then poll the
 * event handler.
 */
d491 1
a491 19
event_poll:
	sethi	%hi(ml_state), %o0
	or	%o0, %lo(ml_state), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	st	%g0, [%g5+IMPLICIT_interrupt] ! Clear the interrupt flag
	sub	%sp, %i3, %g4		! Does the stack really need extending?
	cmp	%g4, %g6
	bgeu	int1
	sethi	%hi(_ml_disturbance), %o4
	or	%o4, %lo(_ml_disturbance), %o4
	jmpl	%o4, %o4		! Really extend the stack
	mov	%i3, %o3
int1:	save	%sp, -0x40, %sp		! NB %i7 contains disturbed function continuation
	mov	STACK_EVENT, %i1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
	ML_to_C(_ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	restore
a492 10
/*
 * === CHECK FOR AN ML EVENT ===
 *
 * We arrive here when g6 has been detected to be -1
 *
 * All registers potentially significant
 * %o7 return address
 * %i1 function closure
 */
#endif
d627 1
a627 7
	lw	$1, -1($6)		# Get code vector
	nop
	lw	$1, -1($1)		# Get ancillary
	nop
	srl	$1, $1, CCODE_SAVES_SHIFT
	andi	$1, $1, CCODE_MAX_SAVES	# Number of callee saves
	addiu	$16, $1, 3		# Plus three for the frame
d636 1
a636 7
	lw	$1, -1($6)		# Get code vector
	nop
	lw	$1, -1($1)		# Get ancillary
	nop
	srl	$1, $1, CCODE_SAVES_SHIFT
	andi	$1, $1, CCODE_MAX_SAVES	# Number of callee saves
	addiu	$16, $1, 3		# Plus three for the frame
d643 2
a644 1
	lw	$1, 0($1)		# And get fp from that
@


1.11
log
@Save and restore fp registers around gc and C calls
@
text
@d25 3
d341 3
d345 1
a345 1
	.globl	ml_gc_leaf_die
d347 1
a347 1
	jal	ml_gc_leaf_die
a385 17


/* === CAUSE A CALL TO EVENT POLL ===
 *
 * This routine is called from the asynchronous event handler in order
 * to cause ML to call the event poll routine at the next opportinuty.
 * It does this by modifying the value of %g6 (the stack limit
 * register) to -1.  IT ONLY WORKS IF CALLED DIRECTLY FROM A SIGNAL
 * HANDLER.  Ack gag barf.
 */

	.globl set_stack_underflow
	.globl set_stack_underflow_die

set_stack_underflow:
	jal	set_stack_underflow_die
	nop
@


1.10
log
@Untag continuation offsets before use
@
text
@d25 3
d207 1
a207 5
#if 0
	std	%f0, [%sp+0x58]		# Preserve non-corrupted floats
	std	%f2, [%sp+0x60]
	std	%f6, [%sp+0x70]
#endif
d210 3
d216 2
a217 1
#if 0
a218 4
	ldd	[%sp+0x70], %f6
	ldd	[%sp+0x60], %f2
	ldd	[%sp+0x58], %f0
#endif
d318 5
a322 6
	
#if 0
	store_fps(%sp+88)
#endif
	move	$5, $6			/* With caller's closure in parameter 1 */
	jal	gc			# Call garabage collector
d324 3
a326 3
#if 0
	load_fps(%sp+88)
#endif
@


1.9
log
@Also fix typo bug in c_raise.
@
text
@d25 3
d698 1
@


1.8
log
@Add a name to copy_up and copy_down.
@
text
@d25 3
d226 2
d596 3
a598 11
/*
 * Clean caller save registers
 */
	ori	$16, 0
	ori	$17, 0
	ori	$18, 0
	ori	$19, 0
	ori	$20, 0
	ori	$21, 0
	ori	$22, 0
	ori	$23, 0
@


1.7
log
@Reduce handler frame size to four words by leaving out fp
@
text
@d25 3
d674 1
a674 1
	copy_down($16, $17, $18)	# Copy down callee saves and linkage
d691 1
a691 1
	copy_up($16, $17, $18)		# Copy up callee saves and frame
@


1.6
log
@Add closure to ml_state
@
text
@d25 3
d661 2
a662 1
	lw	$5, 11($8)		# Get handler closure
d689 3
a691 1
	lw	$1, 3($8)		# Get fp of handler creator
d693 1
a693 1
	lw	$1, 15($8)		# Offset of continuation
@


1.6.1.1
log
@branched from 1.6
@
text
@a24 3
 *Revision 1.6  1994/08/03  13:44:19  jont
 *Add closure to ml_state
 *
@


1.5
log
@Remove dummy realpath (only there for Ultrix anyway)
@
text
@d25 3
d581 2
d584 1
d634 1
@


1.4
log
@Add c_raise
@
text
@d25 3
a887 7

/* Temporary code for realpath which isn't in Ultrix */
	.globl	realpath

realpath:
	j	$31
	move	$2, $4
@


1.3
log
@Add ml_raise code
@
text
@d25 3
a559 1
	.globl	c_raise_die
d562 1
a562 3
	jal	c_raise_die
	nop
#if 0
a563 5
 * This used to store the globals in c_state using %o2:
 *	st	%sp, [%o2 + 28]		! Remember C stack ptr for calls to C
 * But that extends the unix stack in an unlimited fashion,
 * and is unnecessary.
 *
d571 17
a587 9
	load_ML_state(ml_state, %o3, %o4)
	ld	[%o3 + 28], %g4		! save ml_state.sp
	mov	%o0, %i0		! Propagate exception argument
_c_raise10:
	restore				! Pop a frame
	cmp	%sp, %g4
	bne	_c_raise10		! Loop until back to ml stack
	mov	%o0, %i0		! Propagate exception argument
	restore				! One more for luck (one beyond ml_state.sp)
d592 2
a593 1
	! \/\/ fall through \/\/
a635 1
#endif
@


1.2
log
@gc entry stuff
@
text
@d25 3
d620 3
a622 3
 *   %o0	 The exception packet to raise
 *   %o7  Return address for resumption (not used at present, and not true for leaf)
 *   %g3	 Exception handler record
d627 2
a628 2
 * up a handler calls adr, which forces non-leaf because it corrupts o7.
 * However, should we produce a leaf adr by preserving o7 in g4, then
a634 1
	.globl	ml_raise_die
d638 1
a638 4
	jal	ml_raise_die
	nop
#if 0
#ifdef COLLECT_STATS
d645 2
a646 14
	ld	[%g3+11], %o1		! Get handler closure
	ld	[%o1-1], %g4
	sub	%sp, 8, %sp		! Extend current stack slightly
	std	%g2, [%sp+64]		! Save current handler pointer
	jmpl	%g4+CODE_OFFSET, %o7	! The call to the handler
	ld	[%g3-1], %g3		! Call the handler with previous handler restored
	ld	[%sp+68], %g3		! Reinstate the handler
	add	%sp, 8, %sp		! Return stack to its previous size
	ld	[%g3+3], %g4		! Load fp of creator function
	unwind_stack(%fp, raise)	! Wind back to that frame, propagating result
	ld	[%g3+15], %g4		! Fetch the offset of the continuation...
	ld	[%i1-1], %o1		! ...and the address of the creator function
	add	%g4, %o1, %g4		! Tagged address of continuation
	jmp	%g4+CODE_OFFSET
d648 32
a679 1
#endif
@


1.1
log
@new file
@
text
@d24 4
a27 1
 * $Log$
d62 14
a75 3
	store_C_globals(c_state, $10)
	nop
	sw	$29, 0($10)
d77 4
a80 4
	lw	$12, 24($11)		/* saved ml_state.sp */
	lw	$13, 28($11)		/* the current base of the ML stack area */
	move	$30, $29		/* Set fp = current sp */
	addiu	$29, $13, -11*4		/* $16 - $23 plus other stuff */
d82 1
a82 8
	sw	$16, 12($29)
	sw	$17, 16($29)
	sw	$18, 20($29)
	sw	$19, 24($29)
	sw	$20, 28($29)
	sw	$21, 32($29)
	sw	$22, 36($29)
	sw	$23, 40($29)
d86 1
a86 1
	addiu	$1, $1, CODE_OFFSET
d89 4
a92 13
	lw	$31, 8($29)
	lw	$16, 12($29)
	lw	$17, 16($29)
	lw	$18, 20($29)
	lw	$19, 24($29)
	lw	$20, 28($29)
	lw	$21, 32($29)
	lw	$22, 36($29)
	lw	$23, 40($29)
	move	$29, $30		/* Get back to C stack */
	store_ML_state(ml_state, $11,callml)
	sw	$12, 24($11)		/* restore ml_state.sp */
	sw	$13, 28($11)		/* restore base of the ML stack area */
d94 14
a107 1
	load_C_globals(c_state, $10)
d109 1
a109 1
	nop
a174 1
	nop				# Very important, do not remove
a176 6
	sw	$29, 28($16)		# Save base of ML stack area (see callml)
	load_C_globals(c_state, $17)
	nop
	lw	$29, 0($17)		# address of last C stack frame
	nop
	subu	$29, 20+4		# Switch to C stack
d178 2
d186 1
a186 1
	nop				# Load delay
d196 4
a199 1
	store_C_globals(c_state, $17)
d201 1
a201 1
	lw	$29, 28($16)		# Save base of ML stack area (see callml)
d203 1
d262 2
a263 2
 *    %g4  Number of bytes required
 *    %g1  Top of live data + %g4
d265 3
a267 3
 *    %g4  Address of allocated space
 *    %g1  New top of live data + %g4
 *    %g2  New heap limit
d272 3
a274 3
 *    %g4  Number of bytes required
 *    %g1  Top of live data + %g4
 *    %g2  Link register back to ML code
a284 1
	.globl	ml_gc_die
d286 13
a298 1
	jal	ml_gc_die
a300 14
	mov	%i1, %g2		! Copy callers closure for later
	save	%sp, -64, %sp		/* Make extra stack frame for */
					/* caller's 'out' registers */
	mov	%g4, %o0
	store_ML_state(ml_state, %o2, _ml_gc)
	st	%sp, [%o2 + 28]		! Save last ML frame for GC
	st	%sp, [%o2 + 32]		! Save base of ML stack (see callml)
	load_C_globals(c_state, %o3)
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp		! Switch to C stack
	store_fps(%sp+88)
	mov	%i0, %o0
	call	_gc			! Call garabage collector
	ld	[%i2 + 0], %o1		! (with size and callers closure)
d302 2
d305 8
a312 6
	load_ML_state(ml_state, %o3, %o4)
	restore				! Switch back to ML stack
	restore 			! Pop back caller's `o' registers
	retl				! Return to ML
	clean_windows			! Clean C values from windows
#endif
@
