head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.13
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.9
	MLWorks_20c0_1998_08_04:1.9
	MLWorks_20b2c2_1998_06_19:1.9
	MLWorks_20b2_Windows_1998_06_12:1.9
	MLWorks_20b1c1_1998_05_07:1.9
	MLWorks_20b0_1998_04_07:1.9
	MLWorks_20b0_1998_03_20:1.9
	MLWorks_20m2_1998_02_16:1.9
	MLWorks_MM_adapt:1.9.12
	MLWorks_20m1_1997_10_23:1.9
	MLWorks_11r1:1.9.9.1.1.1.1
	MLWorks_workspace_97:1.9.11
	MLWorks_dt_wizard:1.9.10
	MLWorks_11c0_1997_09_09:1.9.9.1.1.1
	MLWorks_10r3:1.9.9.1.3
	MLWorks_10r2_551:1.9.9.1.2
	MLWorks_11:1.9.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.9.9.1
	MLWorks_20m0_1997_06_20:1.9
	MLWorks_1_0_r2c2_1997_06_14:1.9.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.9.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.9.9
	MLWorks_BugFix_1997_04_24:1.9
	MLWorks_1_0_r2_Win32_1997_04_11:1.9
	MLWorks_1_0_r2_Unix_1997_04_04:1.9
	MM_ML_release_korma_1997_04_01:1.9
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.9.7.1.1
	MLWorks_gui_1996_12_18:1.9.8
	MLWorks_1_0_Win32_1996_12_17:1.9.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.9.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.9.4.1
	JFHrts:1.9.6
	MLWorks_1_0_Irix_1996_11_28:1.9.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.9.5
	MLWorks_1_0_Unix_1996_11_14:1.9.4
	MLWorks_Open_Beta2_1996_10_11:1.9.3
	MLWorks_License_dev:1.9.2
	MLWorks_1_open_beta_1996_09_13:1.9.1
	MLWorks_Open_Beta_1996_08_22:1.9
	MLWorks_Beta_1996_07_02:1.8
	MLWorks_Beta_1996_06_07:1.8
	MLWorks_Beta_1996_06_06:1.8
	MLWorks_Beta_1996_06_05:1.8
	MLWorks_Beta_1996_06_03:1.8
	MLWorks_Beta_1996_05_31:1.8
	MLWorks_Beta_1996_05_30:1.8
	hope_poo:1.1.1
	ML_beta_release_12/08/94:1.1.1.1
	ML_beta_release_03/08/94:1.1;
locks; strict;
comment	@ *  @;


1.9
date	96.08.19.15.37.33;	author nickb;	state Exp;
branches
	1.9.1.1
	1.9.2.1
	1.9.3.1
	1.9.4.1
	1.9.5.1
	1.9.6.1
	1.9.7.1
	1.9.8.1
	1.9.9.1
	1.9.10.1
	1.9.11.1
	1.9.12.1
	1.9.13.1;
next	1.8;

1.8
date	96.02.14.16.01.35;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	95.06.28.11.36.30;	author nickb;	state Exp;
branches;
next	1.6;

1.6
date	95.05.26.12.56.44;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	95.05.24.15.02.38;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	95.05.23.13.07.29;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	95.05.22.14.49.28;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	95.05.11.12.36.41;	author nickb;	state Exp;
branches;
next	1.1;

1.1
date	94.07.12.12.07.07;	author jont;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.07.05.10.31.18;	author hope;	state Exp;
branches;
next	;

1.9.1.1
date	96.09.13.11.24.21;	author hope;	state Exp;
branches;
next	;

1.9.2.1
date	96.10.07.16.14.40;	author hope;	state Exp;
branches;
next	;

1.9.3.1
date	96.10.17.11.34.07;	author hope;	state Exp;
branches;
next	;

1.9.4.1
date	96.11.14.12.59.46;	author hope;	state Exp;
branches
	1.9.4.1.1.1;
next	;

1.9.4.1.1.1
date	96.11.28.15.09.48;	author hope;	state Exp;
branches;
next	;

1.9.5.1
date	96.11.22.18.17.34;	author hope;	state Exp;
branches;
next	;

1.9.6.1
date	96.12.17.10.04.17;	author hope;	state Exp;
branches;
next	;

1.9.7.1
date	96.12.17.17.55.52;	author hope;	state Exp;
branches
	1.9.7.1.1.1;
next	;

1.9.7.1.1.1
date	97.02.24.11.47.25;	author hope;	state Exp;
branches;
next	;

1.9.8.1
date	96.12.18.09.50.29;	author hope;	state Exp;
branches;
next	;

1.9.9.1
date	97.05.12.10.44.11;	author hope;	state Exp;
branches
	1.9.9.1.1.1
	1.9.9.1.2.1
	1.9.9.1.3.1;
next	;

1.9.9.1.1.1
date	97.07.28.18.27.03;	author daveb;	state Exp;
branches
	1.9.9.1.1.1.1.1;
next	;

1.9.9.1.1.1.1.1
date	97.10.07.11.53.03;	author jkbrook;	state Exp;
branches;
next	;

1.9.9.1.2.1
date	97.09.08.17.20.10;	author daveb;	state Exp;
branches;
next	;

1.9.9.1.3.1
date	97.09.09.14.16.16;	author daveb;	state Exp;
branches;
next	;

1.9.10.1
date	97.09.10.19.33.54;	author brucem;	state Exp;
branches;
next	;

1.9.11.1
date	97.09.11.21.03.04;	author daveb;	state Exp;
branches;
next	;

1.9.12.1
date	97.10.31.13.45.56;	author nickb;	state Exp;
branches;
next	;

1.9.13.1
date	99.04.01.18.02.11;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.9
log
@Change error behaviour.
@
text
@/* ==== MIPS FIX: COLLECT ONE OBJECT ====
 * 
 *  Copyright (C) 1994 Harlequin Ltd.
 * 
 *  Description
 *  -----------
 *  mach_fixup() is the most critical garbage collection routine; the
 *  GC spends most time here, even when the code is highly tweaked.
 *  This file contains a MIPS assembly language version of the
 *  fixup() subroutine (in fixup.c), which is called in gc.c when
 *  MACH_FIXUP is defined.  Have a look in fixup.h for documentation
 *  of the purpose of fixup().
 *  
 * See the matching SPARC file for extensive notes on the cost of
 * fixup() and its principal caller, the scan() macro in gc.c, and on
 * means of improving their performance by about 30%.
 *  
 *  The code here is full of clever tricks and implicit dependencies.
 *  Modify with extreme care, and test rigorously (just recompiling
 *  MLWorks is insufficient).
 * 
 *  Notes
 *  -----
 *  This file must be run through the m4 macro processor to produce an
 *  assembler file.
 * 
 *  Revision Log
 *  ------------
 *  $Log: src:arch:MIPS:mach_fixup.S,v $
 *  Revision 1.8  1996/02/14  16:01:35  jont
 *  Changing ERROR to MLERROR
 *
 *  Revision 1.7  1995/06/28  11:36:30  nickb
 *  Using a loaded value in the delay slot.
 *
 *  Revision 1.6  1995/05/26  12:56:44  nickb
 *  Bus error when fixing a static shared closure.
 *
 *  Revision 1.5  1995/05/24  15:02:38  nickb
 *  Fix unuusual static objects correctly.
 *
 *  Revision 1.4  1995/05/23  13:07:29  nickb
 *  Change warning message entry code so we can continue afterwards.
 *
 *  Revision 1.3  1995/05/22  14:49:28  nickb
 *  First round of fixes.
 *
 *  Revision 1.2  1995/05/11  12:36:41  nickb
 *  write mach_fixup for MIPS.
 *
 * Revision 1.1  1994/07/12  12:07:07  jont
 * new file
 *
 * Revision 1.3  1994/06/15  09:31:47  nickh
 * Fix bug in copying bytearrays.
 *
 * Revision 1.2  1994/06/09  14:31:07  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:55:46  nickh
 * new file
 *
 *  Revision 1.13  1994/02/07  16:42:13  nickh
 *  increase stack frame size; this is _not_ a leaf function!
 * 
 *  Revision 1.12  1994/02/07  13:53:58  nickh
 *  Got bytearrays and boxed double floats right.
 * 
 *  Revision 1.11  1994/01/25  16:43:49  nickh
 *  Removed int test (which is now in the fix() macro).
 * 
 *  Revision 1.10  1993/03/25  11:32:00  jont
 *  Fixed handling of byte arrays as ref tagged items
 * 
 *  Revision 1.9  1993/02/03  17:53:33  jont
 *  Shortened some of the critical loops
 * 
 *  Revision 1.8  1992/11/12  13:32:04  richard
 *  Changed fixup errors to print a message and attempt to continue
 *  rather than exiting straight away.
 * 
 *  Revision 1.7  1992/08/05  17:37:34  richard
 *  Code vectors are now tagged differently to strings.
 * 
 *  Revision 1.6  1992/07/31  09:05:41  richard
 *  Changed the memory organisation.  This required a couple of small
 *  changes to do with what were previously `block types'.
 * 
 *  Revision 1.5  1992/06/23  10:30:30  richard
 *  Added marking code for large objects.
 * 
 *  Revision 1.4  1992/05/19  13:51:36  richard
 *  Increased the size of the secondary switch table to catch more
 *  illegal secondary tags.
 * 
 *  Revision 1.3  1992/04/14  16:08:30  richard
 *  Converted to use m4 macro processor and renamed to fixup.m4s.
 * 
 *  Revision 1.2  1992/04/06  10:47:45  richard
 *  Corrected a fault in backpointer code.
 * 
 *  Revision 1.1  1992/04/03  10:46:59  richard
 *  Initial revision
 */

/*  Note: various costs are listed in the code below, for instance:
 * 
 *  record size 1: 29 instrs, 3t, 2n.
 *  
 *  This means "to fixup a record of size 1 requires 29 instructions, of
 *  which 3 are taken branches and 2 are non-taken branches."
 *  
 *  The costs are measured from the entry to mach_fixup.
 *  
 *  At various points "costs so far" are noted, along with information
 *  about the current content of registers &c.
 */

#include "tags.h"

/* === FIX AN ML VALUE ===

 Parameters:
   $4   Where to copy objects to
   $5   Pointer to value to fix
   $6   Contents of that value
 Returns:
   $2   Where to copy to next

 Registers:
   $2-$15, $24,$25 are fair game.
   $1 is the assembler temporary, and should be used with care
   $16-$23, $30 are callee-saves
   $26-$28 are not to be fiddled with
   $31 is the return address
*/

.set noreorder
	.globl mach_fixup
mach_fixup:
	la	$2, space_type		/* find the space type */
	srl	$7, $6, 24
	add	$2, $7, $2
	lb	$2, 0($2)
	li	$3, 2			/* 2 = TYPE_FROM */
	beq	$2, $3, fix1
	srl	$7, $6, 3		/* header address >> 3 */
	li	$3, 5			/* 5 = TYPE_STATIC */
	beq	$2, $3, static
	sll	$7, $7, 3
return:	jr $31
	move	$2, $4			/* return 'to' */

/* pointer to a static object. There are three cases:
 * - POINTER to shared closure: must step backwards; 
 * - POINTER to BACKPTR: must skip backwards;
 * - any other pointer.
 */

static:
	and	$10, $6, 7		/* primary tag */
	li	$3, POINTER
	bne	$10, $3, static_return	/* not a special case */
	move	$2, $4			/* we return 'to' */
static_loop:
	lw	$8, 0($7)		/* the header word */
	addiu	$7, $7, -8		/* loop to find a true header */
	beq	$8, $0, static_loop
	andi	$12, $8, 63		/* secondary tag */

	li	$11, BACKPTR		/* if backptr then */
	bne	$11, $12, static_return
	addiu	$7, $7, 8
	srl	$14, $8, 6		/* skip back to true head */
	sub	$7, $7, $14
static_return:	
	jr	$31
	sw	$0, -4($7)		/* mark the mark word */


/* notfrom: 12 instrs, 2n
   static nonptr : 16 instrs, 1n,2t
   static ptr : 23 instrs, 3n,2t + 4 instrs, 1t per shared closure step
   static backptr : 25 instrs, 4n, 1t
*/ 

fix1:
/* value is in fromspace. 7 instrs, 1t
 *	0	1	2	3	4	5	6	7
 *	0	--	--	--	to	what	*what	&hdr>>3 */

	sll	$7, $7 ,3		/* get header address */
	lw	$8, 0($7)		/* header word */
	li	$2, EVACUATED
	bne	$8, $2, notevac		/* if EVAC... */
	lw	$9, 4($7)
	move	$2, $4			/* ... return 'to' */
	jr	$31
	sw	$9, 0($5)		/* and fix with the forwarding ptr */
/* already: 15 instrs, 1t, 1n */

notevac:
/* value is in fromspace and not already evacuated. 12 instrs, 2t
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	--	to	what	*what	&hdr
 * +8	hdr	word1	--	--	--	--	--	--	*/

	andi	$10, $6, 7		/* get primary tag */
	li	$11, PAIRPTR
	bne	$11, $10, not_a_pair
	add	$3, $10, $4		/* new tagged value */
	sw	$2, 0($7)		/* mark the pair */
	sw	$3, 4($7)		/* forward the pair */
	addiu	$2, $4, 8		/* return to+8 */
	sw	$8, 0($4)		/* copy the pair */
	sw	$9, 4($4)
	jr	$31
	sw	$3, 0($5)		/* and fix the root */

/* pair: 23 instrs, 2t, 1n */

not_a_pair:
/* 16 instrs, 3t
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	PAIRPTR	--	--	--	--	*/

	li	$11, POINTER
	bne	$11, $10, not_a_ptr
	andi	$12, $8, 63		/* secondary tag */

	li	$11, RECORD
	bne	$11, $12, not_a_record
	srl	$13, $8, 6		/* length */

record:
/* 22 instrs, 3t, 2n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	RECORD	2dary	length	--	--	*/

	sw	$2, 0($7)		/* mark the object */
	sw	$3, 4($7)		/* forward it */
	sw	$8, 0($4)		/* save the header */
	addiu	$13, $13, -2		/* length -= 2 */
	bltz	$13, copy1		/* if finished, goto end... */
	sw	$9, 4($4)		/* ...saving first word */

/* now loop, copying the rest of the object */
/* code order here to maximise the length of load/store dependencies */
copy0:	lw	$8, 8($7)		/* get next two words */
	lw	$9, 12($7)
	addiu	$4, $4, 8		/* increment both pointers */
	addiu	$7, $7, 8
	addiu	$13, $13, -2		/* decrement the length */
	sw	$8, 0($4)		/* save the two words */
	bgez	$13, copy0		/* loop */
	sw	$9, 4($4)

copy1:	addiu	$2, $4, 8		/* return to+4 */
	jr	$31
	sw	$3, 0($5)		/* fix *what */

/* record size 1: 31 instrs, 4t, 2n
 * other record: 23 instrs, 1t, 4n; plus 8 instrs, 1t per double word
 * direct code objects: as for records but +11 instrs, +5t, -1n */

not_a_record:
/* 22 instrs, 4t, 1n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	RECORD	2dary	length	--	--	*/

/* catch string and bytearray headers here, as we can do so for one extra
 * instruction and it will catch boxed reals (which have regular POINTERs
 * to 12-byte BYTEARRAY-headed objects). */

	andi	$14, $12, 47		/* strings and bytearrays */
	li	$11, STRING
	bne	$14, $11, not_a_string
	addiu	$14, $13, 3		/* compute length in words */
	srl	$13, $14, 2
string:	
	sw	$2, 0($7)		/* forward the object */
	sw	$3, 4($7)
	sw	$8, 0($4)		/* save the header */
	addiu	$13, $13, -2		/* length -= 2 */
	bltz	$13, scopy1		/* if finished, goto end... */
	sw	$9, 4($4)		/* ...saving first word */

/* now loop, copying the rest of the object */
/* code order here to maximise the length of load/store dependencies */
scopy0:	lw	$8, 8($7)		/* load next two words */
	lw	$9, 12($7)
	addiu	$4, $4, 8		/* increment pointers */
	addiu	$7, $7, 8
	addiu	$13, $13, -2		/* decrement length */
	sw	$8, 0($4)		/* save two words */
	bgez	$13, scopy0		/* ... and loop */
	sw	$9, 4($4)

scopy1:	addiu	$2, $4, 8
	jr	$31
	sw	$3, 0($5)

/* string size 0-4: 36 instrs, 5t, 2n
 * other strings  : 28 instrs, 2t, 4n, +8 instrs, 1t per double word */

not_a_string:
/* 26 instrs, 5t, 1n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	STRING	2dary	length	len+3	--	*/

	li	$11, BACKPTR
	bne	$12, $11, not_a_backptr
	nop
	subu	$14, $7, $13		/* find the actual header */
	lw	$10, 0($14)		/* load the actual header */
	lw	$11, 4($14)		/* load the actual first word */
	bne	$10, $2, back0		/* if it's already evacuated... */
	nop
	add	$3, $11, $13		/* new value = forward + offset */
	sw	$2, 0($7)		/* mark the original */
	sw	$3, 4($7)		/* forward the original */
	move	$2, $4			/* get return value ready */
	jr	$31
	sw	$3, 0($5)		/* fix *what */

/* already-forwarded backptr: 39 instrs, 5t, 3n */

back0:
/* 34 instrs, 6t, 2n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	truehd	truew1	2dary	length	&truehd	--	*/

	sw	$2, 0($14)		/* mark and forward whole object */
	sw	$3, 4($14)
	addu	$3, $3, $13		/* recompute fix for original */
	srl	$13, $10, 6		/* compute true length */
	sw	$10, 0($4)		/* copy first two words */
	sw	$11, 4($4)
	addiu	$13, $13, -2		/* length -= 2 */

/* now loop, copying the rest of the object */
bkcopy:	lw	$8, 8($14)		/* load two words */
	lw	$9, 12($14)
	addiu	$4, $4, 8		/* inc pointers and dec length */
	addiu	$13, $13, -2
	addiu	$14, $14, 8
	sw	$8, 0($4)		/* save two words */
	bgez	$13, bkcopy
	sw	$9, 4($4)

/* can't mark or forward the original until we've done the copy! */
	sw	$2, 0($7)		/* mark and forward the original */
	sw	$3, 4($7)
	sw	$3, 0($5)		/* fix *what */
	jr	$31
	addiu	$2, $4, 8

/* code from backptrs : 38 instrs, 5t, 2n, +8 instrs, 1t per double word. */

not_a_backptr:
/* 29 instrs, 6t, 1n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BACKPTR	2dary	length	len+3	--	*/

	bne	$8,$0,not_a_shared_closure
	move	$14,$7
shared_closure:
/* loop back to the head of the closure */
	lw	$10, -8($14)
	addiu	$8, $8, 8		/* accumulate offset in $8 */
	beq	$10,$0, shared_closure
	addiu	$14, $14,-8
	bne	$10, $2, clos0		/* if evacuated... */
	lw	$11, 4($14)
	sw	$2, 0($7)		/* mark original */
	add	$3, $8, $11		/* compute corrected fix */
	sw	$3, 4($7)		/* forward original */
	move	$2, $4			/* prepare to return 'to' */
	jr	$31			/* return */
	sw	$3, 0($5)		/* fix *what */

/* already-forwarded shared clos: 37 instrs, 6t, 4n, +4 instrs, 1t per step */

clos0:
/* 33 instrs, 7t, 3n, +4 instrs, 1t per step
 * 	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	offset	word1	truehd	truew1	2dary	length	&truehd	--	*/

	srl	$13, $10, 6		/* length */
	sw	$2, 0($14)		/* mark and forward the closure */
	sw	$3, 4($14)
	add	$3, $3, $8		/* compute the fix for the original */
	sw	$10, 0($4)		/* save the header */
	sw	$11, 4($4)		/* save first word */
	addiu	$13, $13, -2		/* length -= 2 */
/* now loop, copying the rest of the object */
ccopy:	addiu	$4, $4, 8
	lw	$8, 8($14)
	lw	$9, 12($14)
	sw	$8, 0($4)
	sw	$9, 4($4)
	addiu	$13, $13, -2
	bgez	$13, ccopy
	addiu	$14, $14, 8
	sw	$2, 0($7)		/* mark original */
	sw	$3, 4($7)		/* forward original */
	sw	$3, 0($5)		/* fix *what */
	jr	$31
	addiu	$2, $4, 8

/* shared clos: 35 instrs, 5t, 3n, +8 instrs, 1t per double word, 
 * 				   +4instrs, 1t per step
 */

/* not a regular pointer, so it must be a refptr (otherwise it's an error) */

not_a_ptr:
/* 19 instrs, 4t
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	POINTER 2dary	--	--	--	*/

	li	$11, REFPTR
	bne	$10,$11,primary7
	li	$11, BYTEARRAY
	sw	$3, 0($5)		/* fix *what */
	beq	$11,$12,bytearray	
	sw	$2, 0($7)		/* mark and forward original */
	sw	$3, 4($7)
	sw	$8, 0($4)		/* copy first two words */
	lw	$13, 8($7)		/* get entry-list backptr */
	sw	$9, 4($4)
	lw	$14, 12($7)		/* get first element */
	beq	$13, $0, rcopy		/* if backptr non-zero... */
	srl	$15, $8, 6		/* length */

	sw	$4, 8($9)		/* forward->back = new address */
	sw	$4, 4($13)		/* back->forward = new address */
rcopy:	sw	$13, 8($4)		/* copy backptr */
	addiu	$15, $15,-2
	bltz	$15, rcopy1
	sw	$14, 12($4)		/* copy first element */
rcopy0:	lw	$13, 16($7)		/* load next pair of elements */
	lw	$14, 20($7)
	addiu	$7,$7,8			/* increment pointers */
	addiu	$4,$4,8
	sw	$13, 8($4)		/* save the pair of elements */
	addiu	$15,$15,-2		/* decrement length */
	bgez	$15, rcopy0		/* loop */
	sw	$14, 12($4)
rcopy1:	jr	$31
	addiu	$2, $4, 16		/* return new 'to' pointer */

/* arrays size 1: 38 instrs, 6t, 2n
 * +8 instrs, 1t per additional double word
 * +2 instrs, 1n, -1t if on an entry list */

bytearray:
/* 25 instrs, 5t, 1n, *what fixed, original marked
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BYTEARR BYTEARR	--	--	--	*/

	srl	$13, $8, 6		/* length */
	addiu	$13, $13, 3		/* compute length in words */
	srl	$13, $13, 2
	sw	$3, 4($7)		/* forward the original */
	sw	$8, 0($4)		/* save the header */
	addiu	$13, $13, -2		/* length -= 2 */
	bltz	$13, bcopy1		/* if finished, goto end... */
	sw	$9, 4($4)		/* ...saving first word */
/* now loop, copying the rest of the object */
bcopy0:	lw	$8, 8($7)
	lw	$9, 12($7)
	addiu	$4, $4, 8
	addiu	$13, $13, -2
	addiu	$7, $7, 8
	sw	$8, 0($4)
	bgez	$13, bcopy0
	sw	$9, 4($4)
bcopy1:	jr	$31
	addiu	$2, $4, 8

/* bytearray size 0-4: 35 instrs, 6t, 1n
 * other bytearrays : 27 instrs, 3t, 3n, +8 instrs, 1t per double word */

/* we only get here if we have a direct pointer to a code object,
 * which is very unusual (basically it means the GC has been entered in
 * the middle of loading a code object). */

not_a_shared_closure:
/* 31 instrs, 7t, 1n
 *	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BACKPTR	2dary	length	&hdr	--	*/

	li	$11, CODE
	beq	$11, $12, record
	nop

/* Call fixup_bad_header(what, *what, header, obj) */

	addiu	$sp,$sp,-24		/* save 'to' so we can return it */
	sw	$4, 16($sp)
	sw	$31, 20($sp)
	move	$4, $5
	la	$25, fixup_bad_header
	move	$5, $6
	jalr	$31,$25
	move	$6, $8
	lw	$31,20($sp)
	lw	$2, 16($sp)
	jr	$31
	addiu	$sp,$sp,24

primary7:

/*	0	1	2	3	4	5	6	7
 *	0	--	EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BARRAY  2dary	--	--	--	*/

/* Call fixup_bad_primary(what, *what) */

	addiu	$sp,$sp,-24		/* save 'to' so we can return it */
	sw	$4, 16($sp)
	sw	$31, 20($sp)
	la	$25, fixup_bad_primary
	move	$4, $5
	jalr	$31,$25
	move	$5, $6
	lw	$31,20($sp)
	lw	$2, 16($sp)
	jr	$31
	addiu	$sp,$sp,24

@


1.9.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.9.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a29 3
 *  Revision 1.9.9.1  1997/05/12  10:44:11  hope
 *  branched from 1.9
 *
@


1.9.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a29 3
 *  Revision 1.9.9.1  1997/05/12  10:44:11  hope
 *  branched from 1.9
 *
@


1.9.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a29 3
 *  Revision 1.9.9.1  1997/05/12  10:44:11  hope
 *  branched from 1.9
 *
@


1.9.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a29 3
 *  Revision 1.9.9.1.1.1  1997/07/28  18:27:03  daveb
 *  branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.9.8.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.7.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.7.1.1.1
log
@branched from 1.9.7.1
@
text
@a29 3
 *  Revision 1.9.7.1  1996/12/17  17:55:52  hope
 *  branched from 1.9
 *
@


1.9.6.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.5.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.4.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.4.1.1.1
log
@branched from 1.9.4.1
@
text
@a29 3
 *  Revision 1.9.4.1  1996/11/14  12:59:46  hope
 *  branched from 1.9
 *
@


1.9.3.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.2.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.9.1.1
log
@branched from 1.9
@
text
@a29 3
 *  Revision 1.9  1996/08/19  15:37:33  nickb
 *  Change error behaviour.
 *
@


1.8
log
@Changing ERROR to MLERROR
@
text
@d30 3
d432 1
a433 1
	li	$11, BYTEARRAY
a493 6
primary7:
	la	$2, primary_error
	b	fixup_message
	nop


d507 24
a530 5
	la	$2, header_error
	move	$7, $8
fixup_message:
	li	$3, MLERROR
	sw	$3, 0($5)
d534 2
a535 2
	la	$25, message
	nop
d537 1
a537 1
	move	$4, $2
d542 1
a542 8
.globl mach_fixup_end
mach_fixup_end:
	nop
.data
primary_error:
	.asciiz	"MIPS GC fixup 0x%X (0x%X): illegal primary tag -- fixed to MLERROR"
header_error:
	.asciiz	"MIPS GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to MLERROR"
@


1.7
log
@Using a loaded value in the delay slot.
@
text
@d30 3
d513 1
a513 1
	li	$3, ERROR
d531 1
a531 1
	.asciiz	"MIPS GC fixup 0x%X (0x%X): illegal primary tag -- fixed to ERROR"
d533 1
a533 1
	.asciiz	"MIPS GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to ERROR"
@


1.6
log
@Bus error when fixing a static shared closure.
@
text
@d30 3
d375 1
a376 1
	sw	$2, 0($7)		/* mark original */
@


1.5
log
@Fix unuusual static objects correctly.
@
text
@d30 3
d158 1
a158 1
	addiu	$7, $7, -2		/* loop to find a true header */
d164 1
a164 1
	addiu	$7, $7, 2
d315 1
a369 5

/* note that for shared closures we must _not_ mark or evacuate the
 * original, since this would break the pattern that the fake headers
 * in a shared closure are all 0 */

d372 3
a375 1
	add	$3, $8, $11		/* compute corrected fix */
d403 4
a407 2
	jr	$31
	sw	$3, 0($5)		/* fix *what */
@


1.4
log
@Change warning message entry code so we can continue afterwards.
@
text
@d30 3
d137 3
a139 1
	bne	$2, $3, return
d141 25
a165 1
	sll	$7, $7, 3		/* header address */
d167 7
a173 4
return:	jr $31
	nop
/* notfrom: 12 instrs, 1t, 1n
   static : 14 instrs, 2n	*/
@


1.3
log
@First round of fixes.
@
text
@d30 3
d474 3
a476 3
	addiu	$sp,$sp,-8		/* save 'to' so we can return it */
	sw	$4, 0($sp)
	sw	$31, 4($sp)
d481 2
a482 2
	lw	$31,4($sp)
	lw	$2, 0($sp)
d484 1
a484 1
	addiu	$sp,$sp,8
@


1.2
log
@write mach_fixup for MIPS.
@
text
@d30 3
d120 3
a122 2
	.global _mach_fixup
_mach_fixup:
d124 1
a124 1
	srl	$6, $7, $24
d129 1
a129 1
	srl	$6, $7, 3		/* header address >> 3 */
d137 2
a138 2
/* notfrom: 13 instrs, 1t, 1n
   static : 15 instrs, 2n	*/
d141 1
a141 1
/* value is in fromspace. 8 instrs, 1t
d143 1
a143 1
 *	0				to	what	*what	&hdr>>3 */
d150 1
a150 1
	mov	$2, $4			/* ... return 'to' */
d153 1
a153 1
/* already: 16 instrs, 1t, 1n */
d156 1
a156 1
/* value is in fromspace and not already evacuated. 13 instrs, 2t
d158 2
a159 2
 *	0		EVAC		to	what	*what	&hdr
 * +8	hdr	word1							*/
d165 3
a169 3
	sw	$2, 0($7)		/* and forward it */
	sw	$3, 4($7)
	addiu	$2, $4, 8		/* return to+8 */
d173 1
a173 1
/* pair: 24 instrs, 2t, 1n */
d176 1
a176 1
/* 17 instrs, 3t
d178 2
a179 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	PAIRPTR					*/
d190 1
a190 1
/* 23 instrs, 3t, 2n
d192 2
a193 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	RECORD	2dary	length			*/
d195 2
a196 2
	sw	$2, 0($7)		/* forward the object */
	sw	$3, 4($7)
d199 1
a199 1
	blez	$13, $0, copy1		/* if finished, goto end... */
d201 1
d203 2
a204 2
copy0:	addiu	$4, $4, 8
	lw	$8, 8($7)
d206 5
a210 1
	sw	$8, 0($4)
d212 2
a213 4
	addiu	$13, $13, -2
	blez	$13, $0, copy0
	addiu	$7, $7, 8
copy1:	addiu	$2, $4, 8
d215 1
a215 1
	sw	$3, 0($5)
d217 3
a219 3
/* record size 1: 32 instrs, 4t, 2n
 * other record: 24 instrs, 1t, 4n; plus 8 instrs, 1t per double word
 * direct code objects: as for records but +12 instrs, +5t, -1n */
d222 1
a222 1
/* 23 instrs, 4t, 1n
d224 2
a225 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	RECORD	2dary	length			*/
d228 2
a229 2
 * instruction and it will catch boxed reals (which have regular pointers
 * to 12-byte bytearray-headed objects). */
d241 1
a241 1
	blez	$13, $0, scopy1		/* if finished, goto end... */
d243 1
d245 2
a246 2
scopy0:	addiu	$4, $4, 8
	lw	$8, 8($7)
d248 5
a252 1
	sw	$8, 0($4)
d254 1
a254 3
	addiu	$13, $13, -2
	blez	$13, $0, scopy0
	addiu	$7, $7, 8
d259 2
a260 2
/* string size 0-4: 37 instrs, 5t, 2n
 * other strings  : 29 instrs, 2t, 4n, +8 instrs, 1t per double word */
d263 1
a263 1
/* 27 instrs, 5t, 1n
d265 2
a266 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	STRING	2dary	length	len+3		*/
d270 1
a270 1
	sw	$2, 0($7)		/* mark the original */
d282 1
a282 1
/* already-forwarded backptr: 40 instrs, 5t, 3n */
d285 1
a285 1
/* 35 instrs, 6t, 2n, original marked but not forwarded,
d287 2
a288 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	truehd	truew1	2dary	length	&truehd		*/
a289 2
	addu	$9, $3, $13
	srl	$13, $10, 6
d292 2
a293 1
	sw	$9, 4($7)		/* forward original */
d296 1
a297 3
	addiu	$13, $13, -2		/* length -= 2 */
	blez	$13, $0, bkcopy1	/* if finished, goto end... */
	sw	$9, 0($5)		/* fix *what */
d299 1
a299 2
bkcopy0:addiu	$4, $4, 8
	lw	$8, 8($14)
d301 1
a301 2
	sw	$8, 0($4)
	sw	$9, 4($4)
a302 1
	blez	$13, $0, bkcopy0
d304 9
a312 1
bkcopy1:jr	$31
d315 1
a315 2
/* [code vector of one word: 47 instrs, 7t, 1n] - this case is nonexistent
 * code vectors : 39 instrs, 4t, 3n, +8 instrs, 1t per double word. */
d318 1
a318 1
/* 30 instrs, 6t, 1n, *(&hdr) := EVAC
d320 2
a321 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BACKPTR	2dary	length	len+3		*/
d328 1
a328 1
	addiu	$8, $8, 2		/* accumulate offset in $8 */
d336 1
a336 1
	bne	$10, $2, clos0
d338 3
a340 2
	sw	$0, 0($7)		/* un-mark the original */
	add	$3, $8, $14
a341 2
	jr	$31			/* return */
	move	$2, $4	
d343 1
a343 1
/* already-forwarded shared clos: 40 instrs, 6t, 4n, +4 instrs, 1t per step */
d346 1
a346 1
/* 34 instrs, 7t, 1n, +4 instrs, 1t per step
d348 2
a349 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	offset	word1	truehd	truew1	2dary	length	&truehd		*/
a350 1
	sw	$0, 0($7)		/* un-mark the original */
d356 1
a357 2
	blez	$13, $0, ccopy1		/* if finished, goto end... */
	sw	$11, 4($4)		/* ...saving first word */
d359 1
a359 1
ccopy0:	addiu	$4, $4, 8
d365 1
a365 1
	blez	$13, $0, ccopy0
d367 1
a367 1
ccopy1:	addiu	$2, $4, 8
d371 1
a371 1
/* shared clos: 38 instrs, 5t, 3n, +8 instrs, 1t per double word, 
d378 1
a378 1
/* 20 instrs, 4t
d380 2
a381 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	POINTER 2dary				*/
d396 1
d401 1
a401 1
	blez	$15, rcopy1
d409 1
a409 1
	bgtz	$15, rcopy0		/* loop */
d414 1
a414 1
/* arrays size 1: 39 instrs, 6t, 2n
d419 1
a419 1
/* 26 instrs, 5t, 1n, *what fixed, original marked
d421 2
a422 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BYTEARR BYTEARR				*/
a427 1

d430 1
a430 1
	blez	$13, $0, bcopy1		/* if finished, goto end... */
d433 1
a433 2
bcopy0:	addiu	$4, $4, 8
	lw	$8, 8($7)
d435 3
d439 1
a440 3
	addiu	$13, $13, -2
	blez	$13, $0, bcopy0
	addiu	$7, $7, 8
d444 2
a445 2
/* bytearray size 0-4: 36 instrs, 6t, 1n
 * other bytearrays : 28 instrs, 3t, 3n, +8 instrs, 1t per double word */
a451 2
primary_error:
	.asciiz	"MIPS GC fixup 0x%X (0x%X): illegal primary tag -- fixed to ERROR"
d458 1
a458 1
/* 32 instrs, 7t, 1n, *(&hdr) := EVAC
d460 2
a461 2
 *	0		EVAC	fixed	to	what	*what	&hdr
 * +8	hdr	word1	primary	BACKPTR	2dary	length	&hdr		*/
d469 2
d474 2
a475 1
	la	$25, C_NAME(message)
d478 1
a479 1
	lw	$31,4($sp)
d482 6
d489 1
a489 2
	.asciz	"MIPS GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to ERROR"
	.align 4
@


1.1
log
@new file
@
text
@d1 1
a1 1
/* ==== SPARC FIX: COLLECT ONE OBJECT ====
d9 1
a9 1
 *  This file contains a SPARC assembly language version of the
d14 3
a16 3
 *  This file also contains extensive notes on the cost of fixup() and
 *  its principal caller, the scan() macro in gc.c, and on means of
 *  improving their performance by about 30%.
d29 13
a41 10
 *  $Log: src:arch:SPARC:mach_fixup.S,v $
# Revision 1.3  1994/06/15  09:31:47  nickh
# Fix bug in copying bytearrays.
#
# Revision 1.2  1994/06/09  14:31:07  nickh
# new file
#
# Revision 1.1  1994/06/09  10:55:46  nickh
# new file
#
a84 363
/*
 *  ========================================================================
 * 
 *  Notes on costs of fixup, and of it's principal caller, the
 *  scan macro in gc.c.: Nick Haines 1994-03-31
 * 
 *  1. case frequency breakdown and instruction count table for scan
 *  
 *  The instruction counts include the scan loop, which makes over 95% of
 *  calls to fixup.

 *  "ints" are ML integers, tested and eliminated in the scan loop.
 *  "not from" are objects not in from space. "evac" are objects already
 *  evacuated. "backptrs" are pointers to code vectors. "shared" are
 *  pointers to members of shared closures.
 *  
 *                case frequency breakdown
 *                MLWorks         Lego            instructions
 *  
 *  ints          0.447           0.250           11      
 *  not from      0.331           0.495           26      
 *  evac          0.0332          0.079           28
 *  pairs         0.149           0.118           36
 *  records       0.0296          0.0336          44
 *  strings       0.0017          0.000344        49
 *  arrays        0.0090          0.0230          35
 *  backptrs      0.00013         0.00005         51
 *        evac:   0.0000033       0.00000092      41
 *  shared        0.0000076       0.000006        52
 *        evac:   0.0000051       0.000020        46
 *  
 *  +copied       0.08            0.08            6
 *  
 *  (nonints:     0.554           0.75)
 *  (nonsave:     0.190           0.176)
 *  ("nonsave" = no "save" executed in fixup)
 *  
 *  total instrs  22.005          24.864
 *  
 *  Possible improvements (see section 2 below for more details).
 *  
 *  (a) By modifying the scan macro in C, it is possible to save 2
 *  instructions on the non-int case.
 *  
 *  (b) By recoding the scan macro in assembler, it is possible to save 3
 *  instructions on the int case and 7 on non-ints (knowing what we do
 *  about what mach_fixup does with registers).
 *  
 *  (c) By coding the whole of scan into assembler, inlining mach_fixup,
 *  it would be possible to save at least 2 more instructions per loop
 *  (loading the space_type array base), and also the save instrs.
 *  
 *  These are the savings available:
 *  
 *  (a)           -1.1            -1.5
 *  (b)           -5.2            -6.0
 *  (c)           -7.4            -8.2
 *  
 *  2. how to improve scan
 *  
 *  2.1. Current scan
 *  
 *  2.1.1. source:
 *  
 *    while(f < (end)) {
 *      mlval value = *f; 
 *   
 *      if(FIXABLE(value)) {
 *        fix(to, f); 
 *        ++f; 
 *      } else
 *        switch(SECONDARY(value)) { ...
 *        }
 *    }
 *  
 *  2.1.2. object (generated by gcc2):
 *  
 *        0x1e718  cmp  %l0, %l2                  ; f < end
 *        0x1e71c  bcc,a   0x1e8e8
 *        0x1e720  ld  [ %l6 + 0x40 ], %l2
 *        0x1e724  ld  [ %l0 ], %l1               ; value = *f
 *        0x1e728  and  0xf, %l1, %o0             ; FIXABLE(value)
 *        0x1e72c  cmp  %o0, 0xa
 *        0x1e730  be  0x1e758
 *        0x1e734  btst  1, %l1                   ; pointer?
 *        0x1e738  be  0x1e750
 *        0x1e73c  mov  %l3, %o0                  ; set up registers for
 *        0x1e740  mov  %l0, %o1                  ; call to
 *        0x1e744  call  0x256a8 <mach_fixup>     ; mach_fixup
 *        0x1e748  mov  %l1, %o2                  ; ...
 *        0x1e74c  mov  %o0, %l3                  ; update 'to'.
 *        0x1e750  b  0x1e718                     ; loop
 *        0x1e754  add  4, %l0, %l0               ; ++f
 *  
 *  ints  11 instrs, 2t, 1n, 1an
 *  fixup 15 instrs, 1t, 2n, 1an
 *  
 *  2.2. Improvement in C:
 *  
 *  2.2.1. source:
 *  
 *    while (f < (end)) {
 *      mlval value = *f;
 *      if (value & 1) {
 *        to = mach_fixup(to,f,value);
 *        f++;
 *      } else if FIXABLE(value) {
 *        ...
 *      }
 *    }
 *  
 *  2.2.2. object generated by gcc2:
 *  
 *  loop:
 *        cmp     %i1,%i2                         ; f < end
 *        bgeu    over
 *        nop
 *        ld      [%i1],%l0                       ; value = *f
 *        andcc   %l0,1,%g0                       ; ptr?
 *        be      nonptr
 *        mov     %i0,%o0                         ; set up registers
 *        mov     %i1,%o1                         ; for call to
 *        call    _mach_fixup                     ; mach_fixup
 *        mov     %l0,%o2                         ; ...
 *        mov     %o0,%i0                         ; update 'to'
 *        b       loop                            ; loop
 *        add     %i1,4,%i1                       ; f++
 *  nonptr
 *        and     %l0,15,%o0                      ; FIXABLE
 *        cmp     %o0,10                          ; ...
 *        be      loop
 *        and     %l0,63,%o0                      ; do non-fixables
 *  
 *  ints  11 instrs, 2t, 1n
 *  fixup 13 instrs, 1t, 2n)
 *  
 *  2.2.3. code we would like to be generated:
 *  
 *  .loop:        cmp     %f, %end
 *                bcc,a   .endloop
 *                <annulled slot>
 *                ld      [%f],%val
 *                andcc   #1, %val, %foo
 *                beq,a   .nonptr
 *                and     #f, %val, %foo
 *                mov     %to, %arg0
 *                mov     %f, %arg1
 *                call    mach_fixup
 *                mov     %val, %arg2
 *                mov     %arg0, %to
 *                b       .loop
 *                add     #4, %f, %f
 *  
 *  .nonptr       cmp     %foo, 0xa
 *                bne     .loop
 *                add     #4, %f, %f
 *  
 *  ints  9 instrs, 1an, 1at, 1t  save 18%
 *  fixup 12 instrs, 2an, 1t      save 20%
 *  
 *  2.3. Assembly-language version (mach_fixup still out-of-line):
 *  
 *  keep f in arg1                (make mach_fixup take it as f+4)
 *       to in arg0
 *  
 *  .loop:        bcc,a   .endloop
 *                <annulled slot>
 *                ld      [%arg1],%arg2
 *                andcc   #1, %arg2, %foo
 *                beq,a   .nonptr
 *                and     #f, %arg2, %foo
 *                call    mach_fixup
 *                add     #4, %f, %f
 *                b       .loop
 *                cmp     %arg1, %end
 *         
 *  .nonptr       cmp     %foo, 0xa
 *                bne     .loop
 *                cmp     %arg1, %end
 *        
 *  ints  8 instrs, 1an, 1at, 1t  save 27%
 *  fixup 8 instrs, 2an, 1t       save 47%
 *  
 *  3. raw data for case frequencies:
 *  
 *  By instrumenting the C version of fixup, counts were obtained for each
 *  possible case. Two tests were run: a compilation of MLWorks, and a
 *  compilation and test of the Lego software.
 *  
 *  3.1. Summary
 *  
 *  (Lego results marked L):
 *  
 *  25(L)--44.6% are integers
 *  of ptrs, 59.8--66(L)% are not into from space. There are no large objects.
 *  of from-space ptrs, 14.9--31.3(L)% are already fixed.
 *  of ptrs which need fixing,
 *        67.4(L)-78.6% are pair pointers,
 *        16.6-19.4(L)% are regular pointers,
 *        4.7-13.1(L)% are ref pointers.
 *  of regular ptrs which need fixing,
 *        0.041%-0.076(L)% have zero header (i.e. are sharing closures)
 *        94--98.7(L)% are records
 *        1.0(L)--5.4% (81.6(L)--92.3% of non-records) are strings
 *        0.15(L)--0.41% (66.4(L)--91.1% of non-string non-records) are backptrs
 *  
 *        39.8--78.8(L)% of shared closures have already been evacuated
 *        1.8(L)--2.4% of backptrs have already been evacuated
 *  
 *        records and strings evacuated average 2.88--5.04(L) double words
 *        code vectors (backptrs) evacuated average 43.79(L)--60.1 double words
 *        shared closures (zero hdrs) evacuated average 22.1--24.6(L) doubles
 *  
 *  of ref ptrs which need fixing,
 *  
 *        all but a tiny fraction (5(L)--15 per million) are arrays/ref cells
 *        the rest are weak arrays
 *        evacuees average 2.01(L)--3.50 double words (a ref cell is 2).
 *  
 *  3.2. MLWorks compiling itself:
 *  
 *  616856337 fixed, of which:
 *  
 *  141910034 even ints
 *   87336121 odd ints
 *   45941366 headers
 *  =========
 *  275187521 integers (44.6% of total)
 *  
 *  341668816 pointers, of which:
 *  
 *  204420028 not in from space (59.8%, 33.1% of fixed) (0 large objects)
 *  
 *  137248788 pointers into from space (40.1%, 22.2% of fixed), of which:
 *  
 *  20480547 already fixed (14.9%, 5.9% of ptrs, 3.3% of fixed)
 *  
 *  116768241 need fixing (85.0%, 34.1% of ptrs, 18.9% of fixed), of which:
 *  
 *  91824468 pair pointers (78.6%, 66.9% of froms, 26.8% of ptrs, 14.8% of fixed)
 *  19390655 pointers (16.6%, 14.1% of froms, 5.6% of ptrs, 3.1% of fixed)
 *  5553118 ref pointers (4.7%, 4.0% of froms, 1.6% of ptrs, 0.9% of fixed)
 *  
 *  of pointers which need fixing, 99.96% have a header word, of which:
 *  
 *  18244705 records (94%, 15.6% examined, 13.2% froms, 5.3% ptrs, 2.9% fixed)
 *   1057435 strings (5.4%, 0.9% examined)
 *     80665 backptrs (0.41%)
 *     (of which 2008, 2.4%, already evac) 
 *         0 code vectors
 *  
 *  18244705+1057435+36216501 = 55518641 double words copied for records,
 *  strings (average 2.876 double words each).
 *  
 *  80665-2008+4718891 = 4797548 double words coped for backptrs (average
 *  60.99 double words each)
 *  
 *      7850 shared closures (0.041%)
 *     (of which 3132, 39.8%, already evac)
 *  
 *  7850-3132+99727 = 104445 double words copied for shared closures
 *  (average 22.137 double words each)
 *  
 *  of ref pointers which need fixing,
 *  
 *   5553032 arrays (damn near all of 'em)
 *        86 weak arrays
 *         0 bytearrays
 *  
 *  (5553032+86)*2+8352725 = 19458961 double words copied for arrays and
 *  weak arrays (average of 3.504 double words each)
 *  
 *  3.3. MLWorks running Lego:
 *  
 *  117499824 fixed
 *  
 *  of which
 *  
 *   9145167 even ints
 *  10747092 odd ints
 *   9521364 headers
 *  ========
 *  29413623 integers (25.0% of total)
 *  
 *  88086201 pointers
 *  
 *  of which
 *  
 *  58141904 not in from space (66.0%, 49.4% of fixed) (0 large objects)
 *  
 *  29944297 pointers into from space (33.9%, 25.4% of fixed)
 *  
 *  of which
 *  
 *   9391625 already fixed (31.3%, 10.6% of ptrs, 7.9% of fixed)
 *  20552672 need fixing (68.6%, 23.3% of ptrs, 17.4% of fixed)
 *  
 *  of which
 *  
 *  13855968 pair pointers (67.4%, 46.2% of froms, 15.7% of ptrs, 11.7% of fixed)
 *   3999226 pointers (19.4%, 13.3% of froms, 4.5% of ptrs, 3.4% of fixed)
 *   2697838 ref pointers (13.1%, 9.0% of froms, 3.0% of ptrs, 2.2% of fixed)
 *  
 *  of pointers which need fixing,
 *  
 *  3949648 records (98.7%, 19.2% examined, 13.1% froms, 4.4% ptrs, 3.3% total)
 *    40470 strings (1.0%, 0.1% examined)
 *     6051 backptrs (0.15%)
 *     (of which 108, 1.8%, already evac)
 *        0 code vectors
 *  
 *  3949648+40470+16126963 = 20117081 double words copied for records,
 *  strings (average 5.041 double words each)
 *  
 *  6051-108+213003 = 218946 double words copied for backptrs (average
 *  43.789 double words each)
 *  
 *     3057 shared closures (0.076%)
 *     (of which 2410, 78.8%, already evac)
 *  
 *  3057-2410+15256 = 15903 double words copied for shared closures
 *  (average 24.58 double words each)
 *  
 *  of ref pointers which need fixing,
 *  
 *  2697825 arrays (i.e. pretty much everything)
 *        0 bytearrays
 *       13 weak arrays
 *  
 *  (2697825+13)*2+25925 = 5421601 double words coped for arrays and weak
 *  arrays = 2.01 double words each.
 *  
 *  
 *  4. Data copying rates
 *  
 *  Based on the case frequencies in section 1:
 *  
 *  doublewords copied per scan:
 *  
 *                MLWorks         Lego
 *  
 *  pairs         0.149           0.118
 *  records       0.0296          0.0336
 *  strings       0.0017          0.000344
 *  arrays        0.0090          0.0230
 *  back          0.00013         0.00005
 *  shared        0.0000076       0.000006
 *  bodies        0.08            0.08
 *  
 *  total words per scan:
 *  
 *                0.5388752       0.51
 *  
 *  instructions/word copied:
 *  
 *  now           40.84           48.75
 *  (a)           38.79           45.81
 *  (b)           31.18           36.99
 *  (c)           27.10           32.67
 * 
 *  =====================================================================
 */

d87 1
a87 1
 *  record size 1: 29 instrs, 3t, 2n, 1an, save.
d90 1
a90 2
 *  which 3 are taken branches, 2 are non-taken branches, and 1 is a
 *  non-taken annulled branch. Registers are saved and restored."
d100 16
a115 8
! === FIX AN ML VALUE ===
!
! Parameters:
!   %o0  Where to copy objects to
!   %o1  Pointer to value to fix
!   %o2  Contents of that value
! Returns:
!   %o0  Where to copy to next
d119 13
a131 11
	sethi	%hi(_space_type), %o4
	srl	%o2, 24, %o3		! Calculate block number of object
	or	%o4, %lo(_space_type), %o4
	ldub	[%o4 + %o3], %o5	! Fetch the type of the block
	cmp	%o5, 2			! Is it TYPE_FROM?
	beq	fix1
	andn	%o2, 7, %o3		! Mask out the primary tag in any case
	cmp	%o5, 5			! Is it TYPE_LARGE
	beq,a	return
	st	%g0, [%o3-4]		! Clear the mark word
return:	jmpl	%o7+8, %g0
d133 2
d136 32
a167 42
fix1:	ldd	[%o3], %o4		! Load header and first word
	cmp	%o4, EVACUATED		! Is the object evacuated?
	be,a	return
	st	%o5, [%o1]		! Fix the value and return if so

! notfrom: 11 instrs, 1an
! large  : 12 instrs, 1at
! already: 13 instrs, 1t, 1at.

! mach_fixup is not a leaf (it calls message() in error cases), so we
! have to push 24 words to allow for callee argument space.

	save	%sp, -0x60, %sp
	mov	EVACUATED, %o4		! Secondary for EVACUATED
	and	%i2, 7, %o3		! Mask in the primary tag
	add	%i0, %o3, %o5		! New tagged value
	cmp	%o3, PAIRPTR

! Current costs and state:
!
! 15 instrs, 1t, 1an, save.
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed	sp

	bne	not_a_pair
	st	%o5, [%i1]		! fix the original value
	std	%o4, [%i3]		! store fix
	std	%i4, [%i0]		! evacuate pair
	jmpl	%i7+8, %g0		! return
	restore %i0, 8, %o0		! increment the 'to' value and restore

! pair case: 21 instrs, 1t, 1n, 1an, save.

! Current costs and state:
!
! 17 instrs, 2t, 1an, save. *what fixed. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed	sp
d169 2
d172 12
a183 9
	cmp	%o3, POINTER
	bne	not_a_ptr
	std	%o4, [%i3]		! store fix in delay slot
	and	%i4, 63, %o2
	cmp	%o2, RECORD
	bne	not_a_record
	srl	%i4, 6, %o0		! object length in delay slot

! so this is a record...
d186 27
a212 27
	subcc	%o0, 2, %o0
	bneg	copy1
	std	%i4, [%i0]		! fixup header
copy0:	add	%i3, 8, %i3
	ldd 	[%i3], %i4
	std	%i4, [%i0 + 8]
	subcc	%o0, 2, %o0
	bpos	copy0
	add	%i0, 8, %i0
copy1:	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0		! can we fill this add??
	
! record size 1: 29 instrs, 3t, 2n, 1an, save.
! record size 2,3: 35 instrs, 2t, 4n, 1an, save.
! + 6 instrs, 1t per double word.

! Current costs and state:
!
! 24 instrs, 3t, 1n, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length		second	tag	EVAC	fixed	sp

! catch string and bytearray headers here, as we can do so for one extra
! instruction and it will catch boxed reals (which have regular pointers
! to 12-byte bytearray-headed objects).
d215 33
a247 29
	and	%o2, 47, %o1		! Check for bytearrays too
	cmp	%o1, STRING
	bne	not_a_string
	add	%o0, 3, %o1		! Wasted if branch taken, who cares?
	srl	%o1, 2, %o0
string:
	subcc	%o0, 2, %o0
	bneg	scopy1
	std	%i4, [%i0]
scopy0: add	%i3, 8, %i3
	ldd	[%i3], %i4
	std	%i4, [%i0 + 8]
	subcc	%o0, 2, %o0
	bpos	copy0
	add	%i0, 8, %i0
scopy1:	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0

! string size 0-4: 34 instrs, 4t, 2n, 1an, save
! string size 5-12: 40 instrs, 3t, 4n, 1an, save
! +6 instrs, 1t per 8 bytes

! Current costs and state:
!
! 28 instrs, 4t, 1n, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length	len+3		tag	EVAC	fixed	sp
d249 3
d253 49
a301 42
	cmp	%o2, BACKPTR
	bne	not_a_backptr
	std	%i4, [%i3]		! Undo the forwarding
	sub	%i3, %o0, %o1		! Find the actual header
	ldd	[%o1], %o2
	mov	%o4, %i4		! Copy the evacuation marker
	cmp	%o2, %o4		! Has the whole code vector been evacuated?
	bne,a	back0
	add	%o5, %o0, %i5		! New value = new pointer + offset
	add	%o3, %o0, %i5		! New value = forward + offset
	std	%i4, [%i3]		! Evacuate the original
	st	%i5, [%i1]		! Fix the original again
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! already-evacuated backptr, 41 instrs, 4t, 2n, 3an, save.

back0:	srl	%o2, 6, %o0		! Calculate length of code vector in words
	std	%o4, [%o1]		! Evacuate the whole code vector
	std	%o2, [%i0]
	subcc	%o0, 2, %o0
back1:	add	%o1, 8, %o1
	ldd	[%o1], %o2
	std	%o2, [%i0 + 8]		! Copy the whole code vector
	subcc	%o0, 2, %o0
	bpos	back1
	add	%i0, 8, %i0
	std	%i4, [%i3]		! Evacuate the original value
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0

! code vector size 4: 51 instrs, 4t, 3n, 1at, 2an, save.
! + 6 instrs, 1t per double word.

! Current costs and state:
!
! 31 instrs, 5t, 1n, 2an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length	&hdr-len	tag	EVAC	fixed	sp
d303 3
d307 4
a310 2
	cmp	%i4, 0
	bne	not_a_shared_closure
d312 50
a361 1
/* this stuff not so well-optimised because it's a very rare case (~0.05%) */
d363 3
a365 43
	sub	%i3, 8, %o0		! Who cares if we fill this slot...
shared_closure:
	ldd	[%o0], %o2		! Search back for the actual header
	cmp	%o2, %g0
	bz,a	shared_closure
	sub	%o0, 8, %o0
	sub	%i3, %o0, %o1		! Calculate the offset within the closure
	mov	%o4, %i4		! Copy evacuation marker
	cmp	%o2, %o4		! Has the whole record been evacuated?
	bne,a	clos0
	add	%o5, %o1, %i5		! New value = new pointer + offset
	add	%o3, %o1, %i5		! New value = forward + offset
	std	%i4, [%i3]		! Evacuate the original
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0
clos0:	srl	%o2, 6, %o1		! Calculate length of closure
	std	%o4, [%o0]		! Evacuate the whole closure
	std	%o2, [%i0]		! Copy the whole closure
	subcc	%o1, 2, %o1
	bneg	clos2
	add	%i0, 8, %i0
clos1:	add	%o0, 8, %o0
	ldd	[%o0], %o2
	std	%o2, [%i0]		! Copy the whole closure
	subcc	%o1, 2, %o1
	bpos	clos1
	add	%i0, 8, %i0
clos2:	std	%i4, [%i3]		! Evacuate the original value
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! shared closures already evac: 46 instrs, 5t, 1n, 4an, save.
! shared closures not evac: 52 instrs, 5t, 1n, 3an, 1at, save
! + 6/additional double word
! + 4 instrs, 1at per step

! 20 instrs, 3t, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	sp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed
d370 38
a407 39
	cmp	%o3, REFPTR
	bne	primary7
	and	%i4, 63, %o2		! Get secondary tag
	cmp	%o2, BYTEARRAY		! Is it a bytearray?
	be	bytearray
	std	%i4, [%i0]
	ldd	[%i3 + 8], %o2		! Fetch back pointer and first element
	cmp	%o2, %g0		! Is the backward pointer non-zero?
	bz	rcopy			! Copy the rest as a record
	srl	%i4, 6, %o0		! Calculate the length from the header
	st	%i0, [%i5 + 8]		! forward->back = new address
	st	%i0, [%o2 + 4]		! back->forward = new address

! Costs to here: 30 instrs, + 2 optional instrs

rcopy:	subcc	%o0, 2, %o0		! Copy double words to end of record or string
	bneg	rcopy1
	std	%o2, [%i0 + 8]		! Copy back pointer and first element
rcopy0: ldd	[%i3 + 16], %i4
	std	%i4, [%i0 + 16]
	subcc	%o0, 2, %o0
	add	%i3, 8, %i3
	bpos	rcopy0
	add	%i0, 8, %i0
rcopy1:	jmpl	%i7+8, %g0
	restore	%i0, 16, %o0

! ref cells 35 instrs, 5t, 2n, 1an, save.
! array size 2/3 41 instrs, 4t, 4n, 1an, save.
! + 6 instrs, 1t per double
! + 2 instrs, 1n, -1t if on an entry list

! Current costs and state:
!
! 26 instrs, 4t, 1n, 1an, save. *what fixed, forwarded, evac. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	sp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!			primary	tag	EVAC	fixed
d410 28
a437 18
	srl	%i4, 6, %o0
	add	%o0, 3, %o1
	srl	%o1, 2, %o0		! Round length to words
	subcc	%o0, 2, %o0		! Copy double words to end of record or string
	bneg	bcopy1
	add %i0, 8, %i0			! Could merge this with the restore
bcopy0: ldd	[%i3 + 8], %i4
	std	%i4, [%i0]
	subcc	%o0, 2, %o0
	add	%i3, 8, %i3
	bpos	rcopy0
	add	%i0, 8, %i0
bcopy1:	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! bytearray size 0-4 34 instrs, 5t, 1n, 1an, save.
! bytearray size 5-12 40 instrs, 4t, 3n, 1an, save.
! + 6 instrs, 1t per 8 bytes.
d440 4
a443 9
	sethi	%hi(primary_error), %o0
	or	%o0, %lo(primary_error), %o0
	mov	%i1, %o1
	call	_message
	mov	%i2, %o2
	mov	ERROR, %i3
	st	%i3, [%i1]
	ret
	restore
d445 1
a445 2
	.asciz	"SPARC GC fixup 0x%X (0x%X): illegal primary tag -- fixed to ERROR"
	.align	4
d447 3
a449 3
! we only get here if we have a direct pointer to a code object,
! which is very unusual (basically it means the GC has been entered in
! the middle of loading a code object).
d452 4
a455 2
	cmp	%o2, CODE		! extremely unusual case (<< 1 ppm)
	bne	bad_header
d457 16
a472 18
! In getting here, we have done a couple of things in delay slots that
! are undesireable. We have to fix them.

	std	%i4, [%i3]		! redo the forwarding
	ba	record
	srl	%i4, 6, %o0		! recalculate the length

bad_header:
	sethi	%hi(header_error), %o0
	or	%o0, %lo(header_error), %o0
	mov	%i1, %o1
	mov	%i2, %o2
	call	_message
	mov	%i4, %o3
	mov	ERROR, %i3
	st	%i3, [%i1]
	ret
	restore
d474 1
a474 1
	.asciz	"SPARC GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to ERROR"
@


1.1.1.1
log
@branched from 1.1
@
text
@d29 1
a29 4
 *  $Log: src:arch:MIPS:mach_fixup.S,v $
 *  Revision 1.1  1994/07/12  12:07:07  jont
 *  new file
 *
@
