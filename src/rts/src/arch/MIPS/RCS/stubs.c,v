head	1.6;
access;
symbols
	MLW_daveb_inline_1_4_99:1.6.1
	MLWorks_21c0_1999_03_25:1.6
	MLWorks_20c1_1998_08_20:1.6
	MLWorks_20c0_1998_08_04:1.6
	MLWorks_20b2c2_1998_06_19:1.6
	MLWorks_20b2_Windows_1998_06_12:1.6
	MLWorks_20b1c1_1998_05_07:1.5
	MLWorks_20b0_1998_04_07:1.5
	MLWorks_20b0_1998_03_20:1.5
	MLWorks_20m2_1998_02_16:1.5
	MLWorks_MM_adapt:1.5.3
	MLWorks_20m1_1997_10_23:1.5
	MLWorks_11r1:1.4.9.1.1.1.1
	MLWorks_workspace_97:1.5.2
	MLWorks_dt_wizard:1.5.1
	MLWorks_11c0_1997_09_09:1.4.9.1.1.1
	MLWorks_10r3:1.4.9.1.3
	MLWorks_10r2_551:1.4.9.1.2
	MLWorks_11:1.4.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.4.9.1
	MLWorks_20m0_1997_06_20:1.5
	MLWorks_1_0_r2c2_1997_06_14:1.4.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.4.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.4.9
	MLWorks_BugFix_1997_04_24:1.4
	MLWorks_1_0_r2_Win32_1997_04_11:1.4
	MLWorks_1_0_r2_Unix_1997_04_04:1.4
	MM_ML_release_korma_1997_04_01:1.4
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.4.7.1.1
	MLWorks_gui_1996_12_18:1.4.8
	MLWorks_1_0_Win32_1996_12_17:1.4.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.4.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.4.4.1
	JFHrts:1.4.6
	MLWorks_1_0_Irix_1996_11_28:1.4.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.4.5
	MLWorks_1_0_Unix_1996_11_14:1.4.4
	MLWorks_Open_Beta2_1996_10_11:1.4.3
	MLWorks_License_dev:1.4.2
	MLWorks_1_open_beta_1996_09_13:1.4.1
	MLWorks_Open_Beta_1996_08_22:1.4
	MLWorks_Beta_1996_07_02:1.4
	MLWorks_Beta_1996_06_07:1.4
	MLWorks_Beta_1996_06_06:1.4
	MLWorks_Beta_1996_06_05:1.4
	MLWorks_Beta_1996_06_03:1.4
	MLWorks_Beta_1996_05_31:1.4
	MLWorks_Beta_1996_05_30:1.4
	hope_poo:1.2.1
	ML_beta_release_12/08/94:1.2.1.1
	ML_beta_release_03/08/94:1.2;
locks; strict;
comment	@ * @;


1.6
date	98.05.20.15.15.27;	author jont;	state Exp;
branches
	1.6.1.1;
next	1.5;

1.5
date	97.05.30.09.41.40;	author jont;	state Exp;
branches
	1.5.1.1
	1.5.2.1
	1.5.3.1;
next	1.4;

1.4
date	95.02.10.16.17.42;	author jont;	state Exp;
branches
	1.4.1.1
	1.4.2.1
	1.4.3.1
	1.4.4.1
	1.4.5.1
	1.4.6.1
	1.4.7.1
	1.4.8.1
	1.4.9.1;
next	1.3;

1.3
date	94.11.23.17.03.03;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.07.22.16.34.08;	author jont;	state Exp;
branches
	1.2.1.1;
next	1.1;

1.1
date	94.07.12.12.08.13;	author jont;	state Exp;
branches;
next	;

1.2.1.1
date	95.07.05.10.28.32;	author hope;	state Exp;
branches;
next	;

1.4.1.1
date	96.09.13.11.21.48;	author hope;	state Exp;
branches;
next	;

1.4.2.1
date	96.10.07.16.11.53;	author hope;	state Exp;
branches;
next	;

1.4.3.1
date	96.10.17.11.30.38;	author hope;	state Exp;
branches;
next	;

1.4.4.1
date	96.11.14.12.56.34;	author hope;	state Exp;
branches
	1.4.4.1.1.1;
next	;

1.4.4.1.1.1
date	96.11.28.15.06.58;	author hope;	state Exp;
branches;
next	;

1.4.5.1
date	96.11.22.18.14.38;	author hope;	state Exp;
branches;
next	;

1.4.6.1
date	96.12.17.10.01.26;	author hope;	state Exp;
branches;
next	;

1.4.7.1
date	96.12.17.17.53.10;	author hope;	state Exp;
branches
	1.4.7.1.1.1;
next	;

1.4.7.1.1.1
date	97.02.24.11.44.04;	author hope;	state Exp;
branches;
next	;

1.4.8.1
date	96.12.18.09.47.44;	author hope;	state Exp;
branches;
next	;

1.4.9.1
date	97.05.12.10.40.07;	author hope;	state Exp;
branches
	1.4.9.1.1.1
	1.4.9.1.2.1
	1.4.9.1.3.1;
next	;

1.4.9.1.1.1
date	97.07.28.18.24.55;	author daveb;	state Exp;
branches
	1.4.9.1.1.1.1.1;
next	;

1.4.9.1.1.1.1.1
date	97.10.07.11.50.42;	author jkbrook;	state Exp;
branches;
next	;

1.4.9.1.2.1
date	97.09.08.17.18.08;	author daveb;	state Exp;
branches;
next	;

1.4.9.1.3.1
date	97.09.09.14.14.20;	author daveb;	state Exp;
branches;
next	;

1.5.1.1
date	97.09.10.19.30.41;	author brucem;	state Exp;
branches;
next	;

1.5.2.1
date	97.09.11.21.00.16;	author daveb;	state Exp;
branches;
next	;

1.5.3.1
date	97.10.31.13.43.25;	author nickb;	state Exp;
branches;
next	;

1.6.1.1
date	99.04.01.18.00.32;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.6
log
@[Bug #70035]
Add stubs_code_start, stubs_code_end, stubs_data_start, stubs_data_end
@
text
@/* stubs.c
 *
 * A file to generate the assembler and c stubs because the MIPS
 * assembler is defective and can't do it itself
 *
 * $Log: src:arch:MIPS:stubs.c,v $
 * Revision 1.5  1997/05/30  09:41:40  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
 * Revision 1.3  1994/11/23  17:03:03  nickb
 * Remove set_stack_underflow_die.
 *
 * Revision 1.2  1994/07/22  16:34:08  jont
 * Add callee save count to stubs
 *
 * Revision 1.1  1994/07/12  12:08:13  jont
 * new file
 *
 * Copyright (C) 1994 Harlequin
 *
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "tags.h"
#include "mltypes.h"
#include "stubs.h"
#include "print.h"
#include "mach_values.h"
#include "values.h"

void *stubs_code_start;
void *stubs_code_end;
void *stubs_data_start;
void *stubs_data_end;

extern char text_internal_stub_c;		/* Where the stub to C code is */
extern char text_internal_stub_c_end;		/* Where it ends */
extern char text_internal_stub_asm;		/* Where the stub to assembler is */
extern char text_internal_stub_asm_end;	/* Where the stub to assembler is */

mlval stub_c = (mlval)NULL;
mlval stub_asm = (mlval)NULL; /* The vectors */

/* A place holder to indicate the start of the data for stubs */
/* Must come before all the data */

static int bar;

static struct {
  char *first;
  char *second;
} stubancill, stubnames, stubprofiles;

static struct {
  unsigned int first;
  unsigned int second;
} dummy;

#define STUB_C_NAME "stub to C"

static struct {
  unsigned int len;
  char name[sizeof(STUB_C_NAME)];
} sc_name =
{
  0,
  "stub to C"
};

static struct {
  unsigned int len;
  char name[100];
} sa_name =
{
  0,
  "stub to assembler"
};

/* A place holder to indicate the end of the data for stubs */
/* Must come after all the data */

static int foo;

static unsigned int align_to_double_word(unsigned int value)
{
  return ((value + 7) & ~7u);
}

void stubs_init(void)
{
  unsigned int stub_c_len =
    align_to_double_word((unsigned)(&text_internal_stub_c_end - &text_internal_stub_c));
  unsigned int stub_asm_len =
    align_to_double_word((unsigned)(&text_internal_stub_asm_end - &text_internal_stub_asm));
  unsigned long stubs_len = stub_c_len + stub_asm_len + 8 + 8 + 8 + 4;
  char *stub_vector = malloc(stubs_len);
  stub_vector = (char *) align_to_double_word((unsigned)stub_vector); /* Ensure alignment */
  /* Set up pointers */
  stub_c = (mlval)stub_vector + 8;
  stub_asm = (mlval)stub_vector + 8 + 8 + stub_c_len;
  /* Copy in code */
  memcpy((void *)((char *)stub_c + 8), &text_internal_stub_c, stub_c_len);
  memcpy((void *)((char *)stub_asm + 8), &text_internal_stub_asm, stub_asm_len);
  stubprofiles.first = NULL;
  stubprofiles.second = NULL;
  sc_name.len = ((strlen(sc_name.name) + 1) << 6) | STRING;
  sa_name.len = ((strlen(sa_name.name) + 1) << 6) | STRING;
  stubnames.first = ((char *)(&sc_name)) + POINTER;
  stubnames.second = ((char *)(&sa_name)) + POINTER;
  stubancill.first = ((char *)(&stubnames)) + PAIRPTR;
  stubancill.second = ((char *)(&stubprofiles)) + PAIRPTR;
  dummy.first = (8 << 6) | BACKPTR;
  dummy.second = CCODE_MAKE_ANCILL(8, 0, 0, CCODE_NO_INTERCEPT, 0, 0);
  /* Eight callee saved registers stacked */
  memcpy((void *)stub_c, (void *)&dummy, 8);
  dummy.first = ((stub_c_len + 8 + 8) << 6) | BACKPTR;
  dummy.second = CCODE_MAKE_ANCILL(0, 0, 0, CCODE_NO_INTERCEPT, 0, 1);
  /* No callee save registers */
  memcpy((void *)stub_asm, (void *)&dummy, 8);
  dummy.first = ((stub_c_len + stub_asm_len + 8 + 8 + 8 - 4) << 6) | CODE;
  dummy.second = (int)(&stubancill) + PAIRPTR;
  memcpy(stub_vector, (void *)&dummy, 8);
  stub_c += POINTER;
  stub_asm += POINTER;
  stubs_code_start = stub_vector;
  stubs_code_end = stub_vector + stubs_len;
  stubs_data_start = &bar;
  stubs_data_end = &foo;
}

/* Temporary code */

extern void ml_disturbance_die(void);

extern void ml_disturbance_die(void)
{
  fprintf(stderr, "ml_disturbance_die called\n");
  exit(0);
}

extern void ml_event_check_die(void);

extern void ml_event_check_die(void)
{
  fprintf(stderr, "ml_event_check_die called\n");
  exit(0);
}

extern void ml_event_check_leaf_die(void);

extern void ml_event_check_leaf_die(void)
{
  fprintf(stderr, "ml_event_check_leaf_die called\n");
  exit(0);
}

extern void c_raise_die(mlval);

extern void c_raise_die(mlval v)
{
  fprintf(stderr, "c_raise_die called\n");
  print(&print_defaults, stderr, v);
  exit(0);
}

extern void ml_raise_die(void);

extern void ml_raise_die(void)
{
  fprintf(stderr, "ml_raise_die called\n");
  exit(0);
}

extern void ml_raise_leaf_die(void);

extern void ml_raise_leaf_die(void)
{
  fprintf(stderr, "ml_raise_leaf_die called\n");
  exit(0);
}

extern void ml_replace_die(void);

extern void ml_replace_die(void)
{
  fprintf(stderr, "ml_replace_die called\n");
  exit(0);
}

extern void ml_replace_leaf_die(void);

extern void ml_replace_leaf_die(void)
{
  fprintf(stderr, "ml_replace_leaf_die called\n");
  exit(0);
}

extern void ml_intercept_die(void);

extern void ml_intercept_die(void)
{
  fprintf(stderr, "ml_intercept_die called\n");
  exit(0);
}

extern void ml_intercept_leaf_die(void);

extern void ml_intercept_leaf_die(void)
{
  fprintf(stderr, "ml_intercept_leaf_die called\n");
  exit(0);
}

extern void ml_replace_on_die(void);

extern void ml_replace_on_die(void)
{
  fprintf(stderr, "ml_replace_on_die called\n");
  exit(0);
}

extern void ml_replace_on_leaf_die(void);

extern void ml_replace_on_leaf_die(void)
{
  fprintf(stderr, "ml_replace_on_leaf_die called\n");
  exit(0);
}

extern void ml_intercept_on_die(void);

extern void ml_intercept_on_die(void)
{
  fprintf(stderr, "ml_intercept_on_die called\n");
  exit(0);
}

extern void ml_intercept_on_leaf_die(void);

extern void ml_intercept_on_leaf_die(void)
{
  fprintf(stderr, "ml_intercept_on_leaf_die called\n");
  exit(0);
}

extern void ml_nop_die(void);

extern void ml_nop_die(void)
{
  fprintf(stderr, "ml_nop_die called\n");
  exit(0);
}

@


1.6.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a6 4
 * Revision 1.6  1998/05/20  15:15:27  jont
 * [Bug #70035]
 * Add stubs_code_start, stubs_code_end, stubs_data_start, stubs_data_end
 *
@


1.5
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d7 4
d38 5
d51 5
d86 5
d102 2
a103 1
  char *stub_vector = malloc(stub_c_len + stub_asm_len + 8 + 8 + 8 + 4);
d132 4
@


1.5.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a6 4
 * Revision 1.5  1997/05/30  09:41:40  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.5.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 4
 * Revision 1.5  1997/05/30  09:41:40  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.5.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 4
 * Revision 1.5  1997/05/30  09:41:40  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.4
log
@Modified to create ancillaries for stub functions using the macros
@
text
@d7 3
d100 1
a100 1
  dummy.second = CCODE_MAKE_ANCILL(8, 0, 0, CCODE_NO_INTERCEPT, 0);
d104 1
a104 1
  dummy.second = CCODE_MAKE_ANCILL(0, 0, 0, CCODE_NO_INTERCEPT, 1);
@


1.4.9.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.4.9.1  1997/05/12  10:40:07  hope
 * branched from 1.4
 *
@


1.4.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.4.9.1  1997/05/12  10:40:07  hope
 * branched from 1.4
 *
@


1.4.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.4.9.1  1997/05/12  10:40:07  hope
 * branched from 1.4
 *
@


1.4.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.4.9.1.1.1  1997/07/28  18:24:55  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.4.8.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.7.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.7.1.1.1
log
@branched from 1.4.7.1
@
text
@a6 3
 * Revision 1.4.7.1  1996/12/17  17:53:10  hope
 * branched from 1.4
 *
@


1.4.6.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.5.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.4.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.4.1.1.1
log
@branched from 1.4.4.1
@
text
@a6 3
 * Revision 1.4.4.1  1996/11/14  12:56:34  hope
 * branched from 1.4
 *
@


1.4.3.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.2.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.4.1.1
log
@branched from 1.4
@
text
@a6 3
 * Revision 1.4  1995/02/10  16:17:42  jont
 * Modified to create ancillaries for stub functions using the macros
 *
@


1.3
log
@Remove set_stack_underflow_die.
@
text
@d7 3
d28 2
d97 2
a98 1
  dummy.second = 0x87f00;
d101 2
a102 1
  dummy.second = 0x7f01;
@


1.2
log
@Add callee save count to stubs
@
text
@d7 3
a104 24

extern void ml_gc_die(void);

extern void ml_gc_die(void)
{
  fprintf(stderr, "ml_gc called, dying\n");
  exit(0);
}

extern void ml_gc_leaf_die(void);

extern void ml_gc_leaf_die(void)
{
  fprintf(stderr, "ml_gc_leaf called, dying\n");
  exit(0);
}

extern void set_stack_underflow_die(void);

extern void set_stack_underflow_die(void)
{
  fprintf(stderr, "set_stack_underflow_die called\n");
  exit(0);
}
@


1.2.1.1
log
@branched from 1.2
@
text
@a6 3
 * Revision 1.2  1994/07/22  16:34:08  jont
 * Add callee save count to stubs
 *
@


1.1
log
@new file
@
text
@d6 4
a9 1
 * $Log$
d89 1
a89 1
  dummy.second = 0x7f00;
@
