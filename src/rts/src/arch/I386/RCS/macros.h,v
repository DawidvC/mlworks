head	1.17;
access;
symbols
	MLW_daveb_inline_1_4_99:1.17.13
	MLWorks_21c0_1999_03_25:1.17
	MLWorks_20c1_1998_08_20:1.17
	MLWorks_20c0_1998_08_04:1.17
	MLWorks_20b2c2_1998_06_19:1.17
	MLWorks_20b2_Windows_1998_06_12:1.17
	MLWorks_20b1c1_1998_05_07:1.17
	MLWorks_20b0_1998_04_07:1.17
	MLWorks_20b0_1998_03_20:1.17
	MLWorks_20m2_1998_02_16:1.17
	MLWorks_MM_adapt:1.17.12
	MLWorks_20m1_1997_10_23:1.17
	MLWorks_11r1:1.17.9.1.1.1.1
	MLWorks_workspace_97:1.17.11
	MLWorks_dt_wizard:1.17.10
	MLWorks_11c0_1997_09_09:1.17.9.1.1.1
	MLWorks_10r3:1.17.9.1.3
	MLWorks_10r2_551:1.17.9.1.2
	MLWorks_11:1.17.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.17.9.1
	MLWorks_20m0_1997_06_20:1.17
	MLWorks_1_0_r2c2_1997_06_14:1.17.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.17.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.17.9
	MLWorks_BugFix_1997_04_24:1.17
	MLWorks_1_0_r2_Win32_1997_04_11:1.17
	MLWorks_1_0_r2_Unix_1997_04_04:1.17
	MM_ML_release_korma_1997_04_01:1.17
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.17.7.1.1
	MLWorks_gui_1996_12_18:1.17.8
	MLWorks_1_0_Win32_1996_12_17:1.17.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.17.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.17.4.1
	JFHrts:1.17.6
	MLWorks_1_0_Irix_1996_11_28:1.17.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.17.5
	MLWorks_1_0_Unix_1996_11_14:1.17.4
	MLWorks_Open_Beta2_1996_10_11:1.17.3
	MLWorks_License_dev:1.17.2
	MLWorks_1_open_beta_1996_09_13:1.17.1
	MLWorks_Open_Beta_1996_08_22:1.17
	MLWorks_Beta_1996_07_02:1.17
	MLWorks_Beta_1996_06_07:1.17
	MLWorks_Beta_1996_06_06:1.17
	MLWorks_Beta_1996_06_05:1.17
	MLWorks_Beta_1996_06_03:1.17
	MLWorks_Beta_1996_05_31:1.17
	MLWorks_Beta_1996_05_30:1.17;
locks; strict;
comment	@ * @;


1.17
date	95.11.24.11.33.43;	author nickb;	state Exp;
branches
	1.17.1.1
	1.17.2.1
	1.17.3.1
	1.17.4.1
	1.17.5.1
	1.17.6.1
	1.17.7.1
	1.17.8.1
	1.17.9.1
	1.17.10.1
	1.17.11.1
	1.17.12.1
	1.17.13.1;
next	1.16;

1.16
date	95.11.16.13.36.38;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	95.09.07.11.56.23;	author nickb;	state Exp;
branches;
next	1.14;

1.14
date	95.09.06.14.48.11;	author nickb;	state Exp;
branches;
next	1.13;

1.13
date	95.08.29.13.55.44;	author nickb;	state Exp;
branches;
next	1.12;

1.12
date	95.06.02.15.54.46;	author jont;	state Exp;
branches;
next	1.11;

1.11
date	95.06.01.16.33.02;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.04.25.12.27.03;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.03.15.17.28.10;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	94.12.09.14.53.23;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.11.18.15.32.34;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.10.28.00.38.19;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.10.20.12.33.52;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.10.14.15.37.40;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.05.16.35.26;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.05.13.30.14;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.53.30;	author jont;	state Exp;
branches;
next	;

1.17.1.1
date	96.09.13.11.23.22;	author hope;	state Exp;
branches;
next	;

1.17.2.1
date	96.10.07.16.13.33;	author hope;	state Exp;
branches;
next	;

1.17.3.1
date	96.10.17.11.32.56;	author hope;	state Exp;
branches;
next	;

1.17.4.1
date	96.11.14.12.58.43;	author hope;	state Exp;
branches
	1.17.4.1.1.1;
next	;

1.17.4.1.1.1
date	96.11.28.15.08.41;	author hope;	state Exp;
branches;
next	;

1.17.5.1
date	96.11.22.18.16.22;	author hope;	state Exp;
branches;
next	;

1.17.6.1
date	96.12.17.10.03.09;	author hope;	state Exp;
branches;
next	;

1.17.7.1
date	96.12.17.17.54.46;	author hope;	state Exp;
branches
	1.17.7.1.1.1;
next	;

1.17.7.1.1.1
date	97.02.24.11.45.53;	author hope;	state Exp;
branches;
next	;

1.17.8.1
date	96.12.18.09.49.22;	author hope;	state Exp;
branches;
next	;

1.17.9.1
date	97.05.12.10.41.46;	author hope;	state Exp;
branches
	1.17.9.1.1.1
	1.17.9.1.2.1
	1.17.9.1.3.1;
next	;

1.17.9.1.1.1
date	97.07.28.18.28.33;	author daveb;	state Exp;
branches
	1.17.9.1.1.1.1.1;
next	;

1.17.9.1.1.1.1.1
date	97.10.07.11.54.27;	author jkbrook;	state Exp;
branches;
next	;

1.17.9.1.2.1
date	97.09.08.17.21.32;	author daveb;	state Exp;
branches;
next	;

1.17.9.1.3.1
date	97.09.09.14.17.38;	author daveb;	state Exp;
branches;
next	;

1.17.10.1
date	97.09.10.19.36.42;	author brucem;	state Exp;
branches;
next	;

1.17.11.1
date	97.09.11.21.04.52;	author daveb;	state Exp;
branches;
next	;

1.17.12.1
date	97.10.31.13.47.54;	author nickb;	state Exp;
branches;
next	;

1.17.13.1
date	99.04.01.18.03.37;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.17
log
@Add in_ML hacking.
@
text
@/*
 * ==== ML TO C INTERFACE MACROS ====
 *
 * Copyright (C) 1994 Harlequin Ltd.
 *
 * Description
 * -----------
 * These macros are used by other I386 assembly language routines in
 * the ML to C interface.  They deal with various conventions between
 * the C runtime system and ML.
 *
 * Notes
 * -----
 *
 * Revision Log
 * ------------
 * $Log: src:arch:I386:macros.h,v $
 * Revision 1.16  1995/11/16  13:36:38  nickb
 * Fix in_ML setting and unsetting to allow profiling.
 *
 * Revision 1.15  1995/09/07  11:56:23  nickb
 * Restore callee-saves when unwinding past c_sp.
 *
 * Revision 1.14  1995/09/06  14:48:11  nickb
 * Change to c_sp protocol.
 *
 * Revision 1.13  1995/08/29  13:55:44  nickb
 * Fix stack extension and various other things.
 *
 * Revision 1.12  1995/06/02  15:54:46  jont
 * Add stack extension code
 *
 * Revision 1.11  1995/06/01  16:33:02  jont
 * Remove call to unwind_stack at present
 *
 * Revision 1.10  1995/04/25  12:27:03  nickb
 * A space after a backslash causing code to be dropped.
 *
 * Revision 1.9  1995/03/15  17:28:10  nickb
 * Add threads system.
 *
 * Revision 1.8  1994/12/09  14:53:23  jont
 * Fix incorrect register usage in ML_to_C
 *
 * Revision 1.7  1994/11/18  15:32:34  jont
 * Modify to new register assignment
 *
 * Revision 1.6  1994/10/28  00:38:19  jont
 * Improvements to state saving and loading macros
 *
 * Revision 1.5  1994/10/20  12:33:52  jont
 * Add macros for raise handling
 *
 * Revision 1.4  1994/10/14  15:37:40  jont
 * Add save_all_regs and load_all_regs macros
 *
 * Revision 1.3  1994/10/05  16:35:26  jont
 * Also save_regs and load_regs
 *
 * Revision 1.2  1994/10/05  13:30:14  jont
 * Get copying to/from implicit vector corrected
 *
 * Revision 1.1  1994/10/04  16:53:30  jont
 * new file
 *
 */

#include "offsets.h"
#include "asm_offsets.h"
#include "naming.h"

/* ML boolean values; these must agree with those defined in values.h */

#define TRUE	4
#define FALSE	0

/* Clean caller-save registers (should be done when moving from C to ML) */
#define clean_caller_saves		\
	xor	%ebp, %ebp	;	\
	xor	%ecx, %ecx

/* Register definitions */

#define	thread		%esi
#define	fnarg		%ebx

/*
 * save_all_ML_regs
 * create a new ml stack frame to save all the ml gc (including caller saves)
 * registers prior to calling C.
 * Preserve ecx, this contains the gc size argument
 */

#define	save_all_ML_regs					\
	push	fnarg			;			\
	push	%ebp			; /* Caller saves */	\
	push	%edx			;			\
	push	%eax			; /* Callee saves */	\
	push	%edi			; /* Closure */		\
	lea	24(%esp), %ebp		;			\
	push	%ebp			; /* fp */

/*
 * save_ML_regs
 * create a new ml stack frame to save all the ml callee save
 * registers prior to calling C
 */

#define	save_ML_regs						\
	push	%ebp			;/* gc register */	\
	push	%edx			;/* Save callee saves */\
	push	%eax			;			\
	push	%edi			;/* Save callee_clos */	\
	lea	20(%esp), %ecx		;/* Calculate fp */	\
	push	%ecx			;/* And push it */	\
	mov	%ebp, %edi		;/* Copy in closure */

/*
 * load_all_ML_regs
 * discard ml stack frame created for gc entry
 * prior to calling C
 * Preserve ecx, this contains the gc result
 */

#define	load_all_ML_regs					\
	add	$4, %esp		;			\
	pop	%edi			; /* Closure */		\
	pop	%eax			; /* Callee saves */	\
	pop	%edx			;			\
	pop	%ebp			; /* Caller saves */	\
	pop	fnarg			;

/*
 * load_ML_regs
 * restore all the ml callee save
 * registers after calling C
 */

#define	load_ML_regs						\
	add	$4, %esp		;/* Throw away fp */	\
	pop	%edi			;			\
	pop	%eax			;			\
	pop	%edx			;			\
	pop	%ebp			;

/*
 * save_C_regs
 * save the C callee saves
 * ie %esi, %edi, %ebx, %ebp
 */
#define	save_C_regs						\
	push	%ebx			;			\
	push	%ebp			;			\
	push	%esi			;			\
	push	%edi

/*
 * load_C_regs
 * restore the C callee saves
 * ie %esi, %edi, %ebx, %ebp
 */
#define	load_C_regs						\
	pop	%edi			;			\
	pop	%esi			;			\
	pop	%ebp			;			\
	pop	%ebx

#define load_thread_registers(use)				\
	mov	THREAD_c_ebp(use), %ebp	;			\
	mov	THREAD_c_esi(use), %esi ;			\
	mov	THREAD_c_edi(use), %edi ;			\
	mov	THREAD_c_ebx(use), %ebx

#define save_thread_registers(use)				\
	mov	%ebp, THREAD_c_ebp(use) ;			\
	mov	%esi, THREAD_c_esi(use) ;			\
	mov	%edi, THREAD_c_edi(use) ;			\
	mov	%ebx, THREAD_c_ebx(use)

/* Combines the implicit stack_limit slot with the implicit interrupt
 * slot, so that while in ML the stack limit slot reflects any
 * interrupts done while last in C. Careful to avoid a race
 * condition. Uses the only argument as a scratch. */

#define load_ML_state(use)					\
	mov	IMPLICIT_stack_limit(thread), use	; 	\
	mov	use, IMPLICIT_register_stack_limit(thread) ;	\
	mov	IMPLICIT_interrupt(thread), use		;	\
        or      use, IMPLICIT_register_stack_limit(thread)

/* Call C from ML : 
 * Calls the given function on the args in fnarg, %eax, %edx as
 * arguments for C.
 * The C return value is returned in fnarg. */

#define ML_to_C(what)							\
	mov	%esp, THREAD_ml_sp(thread) ; /* Save ML sp     */	\
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML ;	/* ml_sp now valid */ \
	mov	THREAD_c_sp(thread), %esp ; /* Fetch the previous C sp */ \
	push	thread			; /* Save thread so we can use it */ \
	mov	THREAD_global(thread), thread ; /* global state in thread */ \
	push	%edx			; /* Push args */		\
	push	%eax			; /* Push args */		\
	push	fnarg			; /* Push args */		\
	call	C_NAME(what)		; /* Call function	     */	\
	add	$12, %esp		; /* Pop arguments off stack */	\
	pop	thread			; /* Restore thread register */ \
	mov	%eax, fnarg		; /* Get returned value */	\
	load_ML_state(%ecx) ;						\
	mov	THREAD_ml_sp(thread), %esp ; /* Back on ml stack */	\
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* ml_sp invalid */

/* finds the number of saves for the frame pushed by a given closure;
 * the flags are set accordingly. */

#define number_of_saves(closure,use)					\
	mov	-1(closure),use		;	/* get code vector */	\
	mov	-1(use), use		;	/* get ancillary word */\
	shr	$CCODE_SAVES_SHIFT, use;				\
	and	$CCODE_MAX_SAVES, use

/* Unwind stack to a particular point
 * 
 * The ML stack is unwound by repeatedly popping until the sp equals
 * ecx.  The arg is a label prefix.*/

#define unwind_stack(label)					\
label ## _unwind:							\
	cmp	0(%esp), %ecx	; /*in the right frame already?*/ 	\
	jmp	label ## _start	;					\
label ## _c:								\
	test	$3, %edi	; /* Is the closure tagged */		\
	je	label ## _done	; /* Branch if not */			\
	number_of_saves(%edi, %ebp) ;					\
	je	label ## _done	;					\
	mov	8(%esp), %eax	;					\
	sub	$1, %ebp	;					\
	je	label ## _done	;					\
	mov	12(%esp), %edx	;					\
label ## _done:								\
	mov	4(%esp), %edi	; /* Get caller's closure back */	\
	cmp	$STACK_C_CALL, %edi ;					\
	jne	label ## _over	;					\
	mov	8(%esp), %ebp	; /* restore c_sp */			\
	mov	%ebp, THREAD_c_sp(thread) ;				\
	mov	0(%esp), %eax	; /* restore callee-saves */		\
	mov	12(%eax), %edx	;					\
	mov	8(%eax), %eax	;					\
label ## _over:								\
	mov	0(%esp), %esp	; /* And pop off stack */ 		\
	cmp	0(%esp), %ecx	; /* In the right frame yet? */		\
label ## _start:							\
	jne	label ## _c	;					\
									\
/* Now we have finished unwinding the stack and have the right callee	\
 * saves, and esp and edi are both correct. We have to call the C	\
 * function unwind_stack() and then return to ML. */			\
									\
label ## _callC:       							\
	push	fnarg		; /* preserve handler result */		\
	mov	%esp, fnarg	; /* argument is the SP */		\
	save_ML_regs		; /* Preserve ML callee saves */	\
	ML_to_C(unwind_stack)	; /* unwind */				\
	load_ML_regs		; /* Restore ML callee saves */		\
	clean_caller_saves	; /* Get rid of any crap C values */	\
	pop	fnarg		; /* restore handler result */		\
label ## exit:

@


1.17.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.9.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a17 3
 * Revision 1.17.9.1  1997/05/12  10:41:46  hope
 * branched from 1.17
 *
@


1.17.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a17 3
 * Revision 1.17.9.1  1997/05/12  10:41:46  hope
 * branched from 1.17
 *
@


1.17.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a17 3
 * Revision 1.17.9.1  1997/05/12  10:41:46  hope
 * branched from 1.17
 *
@


1.17.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a17 3
 * Revision 1.17.9.1.1.1  1997/07/28  18:28:33  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.17.8.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.7.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.7.1.1.1
log
@branched from 1.17.7.1
@
text
@a17 3
 * Revision 1.17.7.1  1996/12/17  17:54:46  hope
 * branched from 1.17
 *
@


1.17.6.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.5.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.4.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.4.1.1.1
log
@branched from 1.17.4.1
@
text
@a17 3
 * Revision 1.17.4.1  1996/11/14  12:58:43  hope
 * branched from 1.17
 *
@


1.17.3.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.2.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.17.1.1
log
@branched from 1.17
@
text
@a17 3
 * Revision 1.17  1995/11/24  11:33:43  nickb
 * Add in_ML hacking.
 *
@


1.16
log
@Fix in_ML setting and unsetting to allow profiling.
@
text
@d18 3
d198 1
d210 2
a211 1
	mov	THREAD_ml_sp(thread), %esp ; /* Back on ml stack */
@


1.15
log
@Restore callee-saves when unwinding past c_sp.
@
text
@d18 3
a197 1
	movl	$0, GLOBAL_in_ML(thread) ; /* Not in ML */		\
a201 1
	mov	thread, GLOBAL_in_ML(thread) ; /* Back in ML */		\
@


1.14
log
@Change to c_sp protocol.
@
text
@d18 3
d238 1
a238 1
	mov	8(%esp), %ebp	;					\
d240 3
@


1.13
log
@Fix stack extension and various other things.
@
text
@d18 3
d189 1
a189 1
	mov	THREAD_c_esp(thread), %esp ; /* Fetch the previous C sp */ \
a200 1
	mov	%esp, THREAD_c_esp(thread); /* Save C sp */		\
d235 2
a236 2
	mov	12(%esp), %ebp	;					\
	mov	%ebp, THREAD_c_esp(thread) ;				\
@


1.12
log
@Add stack extension code
@
text
@d18 3
d168 4
a171 3
/* Ors the implicit stack_limit slot with the implicit interrupt slot,
 * so that while in ML the stack limit slot reflects any interrupts
 * done while last in C. Uses the only argument as a scratch */
d175 3
a177 2
	or	IMPLICIT_interrupt(thread), use		;	\
	mov	use, IMPLICIT_register_stack_limit(thread)
d199 1
a199 1
	load_ML_state(%ecx)		;				\
d252 1
a252 1
	pop	%ebx		; /* restore handler result */		\
a254 30
/*
 * copy_down(size, pointer, temp)
 * copy callee save values plus linkage down one word
 */
#define	copy_down(size,pointer,temp)					\
	mov	%esp, pointer		;/* From pointer */		\
	sub	$4, %esp		;/* Create space */		\
copy_down ## start:			;				\
	mov	0(pointer), temp	;				\
	mov	temp, -4(pointer)	;/* copy down */		\
	add	$4, pointer		;				\
	sub	$1, size		;				\
	jne	copy_down ## start	;/* Loop if more to do */

/*
 * copy_up(size, pointer, temp)
 * copy callee save values plus linkage up one word
 */
#define	copy_up(size,pointer,temp)					\
	mov	size, temp		;				\
	shl	$2, temp		;				\
	mov	%esp, pointer		;				\
	add	temp, pointer		;/* Pointer into stack */	\
copy_up ## start:			;				\
	mov	-4(pointer), temp	;				\
	mov	temp, 0(pointer)	;/* copy up */			\
	sub	$4, pointer		;				\
	sub	$1, size		;				\
	jne	copy_up ## start	;/* Loop if more to do */	\
	add	$4, %esp		;/* Throw away extra space space */
@


1.11
log
@Remove call to unwind_stack at present
@
text
@d18 3
d62 4
a65 3
/* Clean register windows */

#define	clean_windows    ta 4
a71 6
/* Clean the registers in the current window */

#define clean_current_registers		\
	xor	%edx,	%edx	;	\
	xor	%eax,	%eax

d171 2
a172 2
	or	IMPLICIT_interrupt(thread), use	;	\
	mov	use, IMPLICIT_stack_limit(thread)
d238 1
a238 6
 * function unwind_stack() and then return to ML. */
/* Following stuff not included yet */
/* It is incorrect in its assumptions about ML_to_C arguments */
/* And does not preserve the registers it should */
			\
/*
d240 4
a243 3
label ## _callC:       							\ */
	push	%ebx		; /* preserve handler result */		\
	mov	%esp, %ebx	; /* argument is the SP */		\
d245 2
d248 1
a248 1
/*label ## exit:*/
@


1.10
log
@A space after a backslash causing code to be dropped.
@
text
@d18 3
d240 6
a245 1
 * function unwind_stack() and then return to ML. */			\
d247 1
a247 1
label ## _callC:       							\
d252 1
a252 1
label ## exit:
@


1.9
log
@Add threads system.
@
text
@d18 3
d190 1
a190 1
	pop	thread			; /* Restore thread register */ \ 
@


1.8
log
@Fix incorrect register usage in ML_to_C
@
text
@d18 3
d45 1
d59 1
a59 1
#define	implicit	%esi
a67 52
/* Saves the global registers in a C struct labelled with the first
 * arg, address of that label in the second arg register.  The stack
 * register %g6 is only stored if is not -1. */

/* Note the fiddling with g1/g2/g4 here. This is to make sure that,
   while in C, GC_HEAP_LIMIT points to the limit of the creation
   space, but while in ML, %g1 contains 0x7ffffffc - (limit-alloc). */

#define store_ML_state(where, use, temp, label)			\
	lea	(C_NAME(where)), use	;			\
	mov	%edi, 32(use)		; /* Save current closure */	\
	mov	IMPLICIT_gc_base(implicit), temp	;		\
	mov	temp, 0(use)		;			\
	mov	IMPLICIT_gc_limit(implicit), temp	;		\
	mov	temp, 20(use)		; /* Save gc pointer */	\
	mov	IMPLICIT_handler(implicit), temp	;		\
	mov	temp, 4(use)		; /* Save handler */	\
	mov	IMPLICIT_stack_limit(implicit), temp	;	\
	cmp	$0, temp		; /* Limit < 0 ? */	\
	jl	label ## store		;			\
	mov	temp, 16(use)		; /* Save stack */	\
label ## store:

/* Loads the global registes from a C struct labelled with the first
 * arg, leaving the address of that label in the second arg.  The
 * stack register %g6 is ORed with the interrupt stack slot on the
 * implicit vector, which is left in the third arg */

/* Note the fiddling with g1/g2/g4 here. This is to make sure that,
   while in C, GC_HEAP_LIMIT points to the limit of the creation
   space, but while in ML, %g1 contains 0x7ffffffc - (limit-alloc). */

#define load_ML_state(where, use, intreg)			\
	lea	(C_NAME(where)), use	;			\
	mov	32(use), %edi		; /* Restore current closure */	\
	mov	12(use), implicit		; /* Set up implicit */	\
	mov	0(use), intreg		;			\
	mov	intreg, IMPLICIT_gc_base(implicit)	;		\
	mov	20(use), intreg		; /* Set up gc */	\
	mov	intreg, IMPLICIT_gc_limit(implicit)	;		\
	mov	4(use), intreg		; /* Set up handler */	\
	mov	intreg, IMPLICIT_handler(implicit)	;		\
	mov	16(use), intreg		; /* Set up stack */	\
	or	IMPLICIT_interrupt(implicit), intreg	;	\
	mov	intreg, IMPLICIT_stack_limit(implicit)	;

/* Sets reg (second arg) to the address (first arg).
 */

#define address_C_globals(where, use)				\
	lea	(C_NAME(where)), use

d149 21
d171 3
a173 3
 * Saves the ML state and restore the C state, then calls the
 * function, propagating registers fnarg, %eax, %edx as arguments for
 * C.	 The C return value is returned in %o0. */
d176 5
a180 4
	store_ML_state(ml_state, %ebp, %ecx, what)	;		\
	mov	%esp, 24(%ebp)		; /* Save ML stack base	     */	\
	address_C_globals(c_state, %ecx)	;				\
	mov	28(%ecx), %esp		; /* Fetch the previous C sp */	\
d185 1
d187 1
d189 12
a200 4
	address_C_globals(c_state, %ecx)	;				\
	mov	%esp, 28(%ecx)		; /* Save C sp */		\
	load_ML_state(ml_state, %ebp, %ecx);				\
	mov	24(%ebp), %esp		; /* Back on ml stack */
d204 2
a205 2
 * The ML stack is unwound by repeatedly restoring register windows
 * until the first register arg equals %g4.  the other arg is a label prefix.*/
d208 1
a208 1
label ## unwind:							\
d210 2
a211 4
	jmp	label ## start	;					\
label ## loop:								\
/* Stuff to do with restoring c_state.sp here  */			\
label ## c:								\
d213 3
a215 6
	je	label ## done	; /* Branch if not */			\
	mov	-1(%edi), %ebp	; /* Get code vector */			\
	mov	-1(%ebp), %ebp	; /* Get ancillary information */	\
	shr	$CCODE_SAVES_SHIFT, %ebp	;				\
	and	$CCODE_MAX_SAVES, %ebp	; /* Number of callee saves */	\
	je	label ## done	;					\
d218 1
a218 1
	je	label ## done	;					\
d220 1
a220 1
label ## done:			;					\
d222 5
d229 12
a240 2
label ## start:								\
	jne	label ##loop	;					\
a242 17
#if 0
	mov	%o0, %i0	;	/* Propagate handler result */  \
	save	%sp, -0x40, %sp	;					\
	mov	%fp, %o0	;					\
	ML_to_C(unwind_stack)	;	/* Unwind stack extensions */   \
	addcc	%g6, 1, %g0	;	/* Is an event flagged? */	\
	beq,a	label ## exit	;	/* Finished if so. */		\
	restore			;					\
	sethi	%hi(C_NAME(ml_state)), %o1 ;				\
	or	%o1, %lo(C_NAME(ml_state)), %o1;			\
	ld	[%o1+16], %g6	;	/* Install the new stack area */ \
	restore			;					
#endif

/* Save all the FP's away. The arg is a register pointing to the save
 * area (size 128). */

a272 38

#define store_fps(where)			\
	std	%f0,  [where]		;	\
	std	%f2,  [where+8]		;	\
	std	%f4,  [where+16]	;	\
	std	%f6,  [where+24]	;	\
	std	%f8,  [where+32]	;	\
	std	%f10, [where+40]	;	\
	std	%f12, [where+48]	;	\
	std	%f14, [where+56]	;	\
	std	%f16, [where+64]	;	\
	std	%f18, [where+72]	;	\
	std	%f20, [where+80]	;	\
	std	%f22, [where+88]	;	\
	std	%f24, [where+96]	;	\
	std	%f26, [where+104]	;	\
	std	%f28, [where+112]	;	\
	std	%f30, [where+120]

/* Load the FPs. The arg is a register pointing to the saved values */

#define load_fps(from_where)			\
	ldd	[from_where],     %f0	;	\
	ldd	[from_where+8],   %f2	;	\
	ldd	[from_where+16],  %f4	;	\
	ldd	[from_where+24],  %f6	;	\
	ldd	[from_where+32],  %f8	;	\
	ldd	[from_where+40],  %f10	;	\
	ldd	[from_where+48],  %f12	;	\
	ldd	[from_where+56],  %f14	;	\
	ldd	[from_where+64],  %f16	;	\
	ldd	[from_where+72],  %f18	;	\
	ldd	[from_where+80],  %f20	;	\
	ldd	[from_where+88],  %f22	;	\
	ldd	[from_where+96],  %f24	;	\
	ldd	[from_where+104], %f26	;	\
	ldd	[from_where+112], %f28	;	\
	ldd	[from_where+120], %f30
@


1.7
log
@Modify to new register assignment
@
text
@d4 1
a4 1
 * Copyright (C) 1992 Harlequin Ltd.
d8 1
a8 1
 * These macros are used by other SPARC assembly language routines in
a13 2
 * This file must be run through the m4 macro processor to produce an
 * assembler file.
d18 3
d204 1
a204 1
	mov	%esp, 24(%ecx)		; /* Save ML stack base	     */	\
d216 1
a216 1
	mov	24(%ecx), %esp		; /* Back on ml stack */
@


1.6
log
@Improvements to state saving and loading macros
@
text
@d20 3
d52 5
d74 1
a74 1
	mov	IMPLICIT_gc_base(%ebx), temp	;		\
d76 1
a76 1
	mov	IMPLICIT_gc_limit(%ebx), temp	;		\
d78 1
a78 1
	mov	IMPLICIT_handler(%ebx), temp	;		\
d80 1
a80 1
	mov	IMPLICIT_stack_limit(%ebx), temp	;	\
d98 1
a98 1
	mov	12(use), %ebx		; /* Set up implicit */	\
d100 1
a100 1
	mov	intreg, IMPLICIT_gc_base(%ebx)	;		\
d102 1
a102 1
	mov	intreg, IMPLICIT_gc_limit(%ebx)	;		\
d104 1
a104 1
	mov	intreg, IMPLICIT_handler(%ebx)	;		\
d106 2
a107 2
	or	IMPLICIT_interrupt(%ebx), intreg	;	\
	mov	intreg, IMPLICIT_stack_limit(%ebx)	;
d123 1
a123 1
	push	%esi			;			\
d159 1
a159 1
	pop	%esi			;
d174 22
d198 1
a198 1
 * function, propagating registers %esi, %eax, %edx as arguments for
d208 1
a208 1
	push	%esi			; /* Push args */		\
d211 1
a211 1
	mov	%eax, %esi		; /* Get returned value */	\
@


1.5
log
@Add macros for raise handling
@
text
@d20 3
d65 1
d89 1
d134 1
a134 1
	lea	-20(%esp), %ecx		;/* Calculate fp */	\
@


1.4
log
@Add save_all_regs and load_all_regs macros
@
text
@d20 3
a31 68
 * Revision 1.4  1994/07/22  14:31:10  nickh
 * Add fiddles with heap_limit field in ml_state.
 *
 * Revision 1.3  1994/07/06  13:30:52  nickh
 * Asm and C name prefixes differ according to OS.
 *
 * Revision 1.2  1994/06/09  14:30:20  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:54:50  nickh
 * new file
 *
 * Revision 1.16  1994/03/09  13:46:14  jont
 * Removed loading and storing of globals on entry/exit to C.
 * We still have to restore/save the stack pointer though.
 *
 * Revision 1.15  1993/02/26  17:52:31  jont
 * Added a macro to initialise all unused registers before calling ml
 *
 * Revision 1.14  1992/10/23  11:29:25  richard
 * Shortened some long names.  Changed event handling
 * stuff.
 *
 * Revision 1.13  1992/09/15  11:20:54  clive
 * Added macros to load and save floating point registers
 *
 * Revision 1.12  1992/07/31  08:37:03  richard
 * Removed redundant declaration of EVAC.
 *
 * Revision 1.11  1992/07/29  13:33:02  clive
 * Changes to single-step and calling of debugger now we can callml from C - so
 * errors ironed out
 *
 * Revision 1.10  1992/07/21  15:48:27  richard
 * Moved unwind_stack here from interface.m4s.  It now calls C only
 * once to unwind stack extension areas, removing the need to
 * recognise particular stack frames and thus allowing it to traverse
 * C stack.
 *
 * Revision 1.9  1992/07/16  16:31:10  richard
 * Implemented re-entrant ML.
 *
 * Revision 1.8  1992/07/16  10:58:47  clive
 * Removed load_allocation_details which is no longer needed
 *
 * Revision 1.7  1992/07/15  11:16:31  richard
 * offsets.h is now included and used.
 *
 * Revision 1.6  1992/07/03  09:55:46  richard
 * Changed the way thay interrupts are generated and handled.
 *
 * Revision 1.5  1992/06/22  15:24:32  clive
 * Wrote a macro to detect waiting interrupts, which could not be handled before as we were in C
 *
 * Revision 1.4  1992/05/15  10:31:55  clive
 * Memory profiling result in bytes - to get tagging automatically
 *
 * Revision 1.3  1992/05/08  17:14:49  clive
 * Added memory profiling
 *
 * Revision 1.2  1992/04/15  10:18:30  richard
 * Converted to use the m4 macro processor and renamed to macros.m4s.
 *
 * Revision 1.2  1992/04/14  16:35:05  richard
 * Converted to use m4 macro processor and renamed to macros.m4s.
 *
 * Revision 1.1  1992/04/02  09:45:08  richard
 * Initial revision
d187 1
a187 1
#define unwind_stack(to_where, label)					\
d189 2
a190 2
	ba	label ## start	;					\
	cmp	to_where, %g4	;	/*in the right frame already?*/ \
d192 17
a208 2
        restore			;					\
	cmp	to_where, %g4	;	/* Is it the correct frame? */  \
d210 4
a213 1
	bne,a	label ##loop	;					\
d224 2
a225 2
	restore			;					\
label ## exit:
d229 31
@


1.3
log
@Also save_regs and load_regs
@
text
@d20 3
d161 2
a162 3

/* Saves those global registers used by C in an aligned area at an
 * address (first arg).  Also sets reg (second arg) to address. */
d164 1
a164 1
#define store_C_globals(where, use)				\
d167 6
a172 2
/* Loads the global registers used by C from an aligned area at an
 * address (first arg). Also sets reg (second arg) to the address */
d174 8
a181 2
#define load_C_globals(where, use)				\
	lea	(C_NAME(where)), use
d199 15
d234 1
a234 1
	load_C_globals(c_state, %ecx)	;				\
d242 1
a242 1
	store_C_globals(c_state, %ecx)	;				\
@


1.2
log
@Get copying to/from implicit vector corrected
@
text
@d20 3
d171 28
d201 1
a201 1
 * function, propagating registers %o0 to %o2 as arguments for
d205 7
a211 8
	store_ML_state(ml_state, %o3)	;				\
	st	%sp, [%o3+32]		; /* Save ML stack base	     */	\
	load_C_globals(c_state, %o4)	;				\
	ld	[%o4 + 28], %o5		; /* Fetch the previous C sp */	\
	save	%o5, -88, %sp		; /* Make a C stack frame */    \
	st	%sp, [%i3 + 28]		; /*Save ptr to ML frame for GC*/\
	mov	%i0, %o0		; /* Propagate arguments     */	\
	mov	%i1, %o1		;				\
d213 6
a218 6
	mov	%i2, %o2		;				\
	mov	%o0, %i0		; /* Propagate result	     */	\
	store_C_globals(c_state, %o2)	;				\
	load_ML_state(ml_state,%o3,%o4);				\
	restore	%g0, 0, %g0		; /* Return to ML stack	     */	\
	clean_windows			; /* Clean the register windows */
@


1.1
log
@new file
@
text
@d19 4
a22 1
 * $Log: src:arch:SPARC:macros.h,v $
a120 1
	mov	%ebx, 12(use)		; /* Save implicit */	\
d122 1
a122 1
	mov	temp, 28(use)		;			\
d124 1
a124 1
	mov	temp, 0(use)		; /* Save gc pointer */	\
d145 1
a145 1
	mov	28(use), intreg		;			\
d147 1
a147 1
	mov	0(use), intreg		; /* Set up gc */	\
@
