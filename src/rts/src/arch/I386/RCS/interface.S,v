head	1.41;
access;
symbols
	MLW_daveb_inline_1_4_99:1.41.1
	MLWorks_21c0_1999_03_25:1.41
	MLWorks_20c1_1998_08_20:1.37
	MLWorks_20c0_1998_08_04:1.37
	MLWorks_20b2c2_1998_06_19:1.37
	MLWorks_20b2_Windows_1998_06_12:1.37
	MLWorks_20b1c1_1998_05_07:1.36
	MLWorks_20b0_1998_04_07:1.35
	MLWorks_20b0_1998_03_20:1.35
	MLWorks_20m2_1998_02_16:1.35
	MLWorks_MM_adapt:1.33.3
	MLWorks_20m1_1997_10_23:1.33
	MLWorks_11r1:1.32.1.1.1.1.1
	MLWorks_workspace_97:1.33.2
	MLWorks_dt_wizard:1.33.1
	MLWorks_11c0_1997_09_09:1.32.1.1.1.1
	MLWorks_10r3:1.32.1.1.3
	MLWorks_10r2_551:1.32.1.1.2
	MLWorks_11:1.32.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.32.1.1
	MLWorks_20m0_1997_06_20:1.33
	MLWorks_1_0_r2c2_1997_06_14:1.32.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.32.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.32.1
	MLWorks_BugFix_1997_04_24:1.32
	MLWorks_1_0_r2_Win32_1997_04_11:1.32
	MLWorks_1_0_r2_Unix_1997_04_04:1.31
	MM_ML_release_korma_1997_04_01:1.31
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.31.3.1.1
	MLWorks_gui_1996_12_18:1.31.4
	MLWorks_1_0_Win32_1996_12_17:1.31.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.30.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.30.4.1
	JFHrts:1.31.2
	MLWorks_1_0_Irix_1996_11_28:1.30.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.31.1
	MLWorks_1_0_Unix_1996_11_14:1.30.4
	MLWorks_Open_Beta2_1996_10_11:1.30.3
	MLWorks_License_dev:1.30.2
	MLWorks_1_open_beta_1996_09_13:1.30.1
	MLWorks_Open_Beta_1996_08_22:1.30
	MLWorks_Beta_1996_07_02:1.30
	MLWorks_Beta_1996_06_07:1.30
	MLWorks_Beta_1996_06_06:1.30
	MLWorks_Beta_1996_06_05:1.30
	MLWorks_Beta_1996_06_03:1.30
	MLWorks_Beta_1996_05_31:1.30
	MLWorks_Beta_1996_05_30:1.30;
locks; strict;
comment	@ * @;


1.41
date	98.10.30.17.08.27;	author jont;	state Exp;
branches
	1.41.1.1;
next	1.40;

1.40
date	98.10.20.10.37.15;	author jont;	state Exp;
branches;
next	1.39;

1.39
date	98.09.15.10.25.22;	author jont;	state Exp;
branches;
next	1.38;

1.38
date	98.07.31.11.05.23;	author jont;	state Exp;
branches;
next	1.37;

1.37
date	98.06.09.09.36.28;	author jont;	state Exp;
branches;
next	1.36;

1.36
date	98.04.22.10.47.18;	author jont;	state Exp;
branches;
next	1.35;

1.35
date	98.02.05.13.11.47;	author jont;	state Exp;
branches;
next	1.34;

1.34
date	98.01.26.10.38.29;	author jont;	state Exp;
branches;
next	1.33;

1.33
date	97.06.04.10.39.32;	author jont;	state Exp;
branches
	1.33.1.1
	1.33.2.1
	1.33.3.1;
next	1.32;

1.32
date	97.04.11.12.56.28;	author jont;	state Exp;
branches
	1.32.1.1;
next	1.31;

1.31
date	96.11.15.13.05.42;	author nickb;	state Exp;
branches
	1.31.1.1
	1.31.2.1
	1.31.3.1
	1.31.4.1;
next	1.30;

1.30
date	95.12.13.11.27.30;	author nickb;	state Exp;
branches
	1.30.1.1
	1.30.2.1
	1.30.3.1
	1.30.4.1;
next	1.29;

1.29
date	95.12.12.17.45.14;	author nickb;	state Exp;
branches;
next	1.28;

1.28
date	95.12.12.17.23.16;	author nickb;	state Exp;
branches;
next	1.27;

1.27
date	95.11.23.15.36.58;	author nickb;	state Exp;
branches;
next	1.26;

1.26
date	95.11.16.13.34.27;	author nickb;	state Exp;
branches;
next	1.25;

1.25
date	95.11.15.15.03.02;	author nickb;	state Exp;
branches;
next	1.24;

1.24
date	95.11.13.15.34.13;	author nickb;	state Exp;
branches;
next	1.23;

1.23
date	95.10.17.14.56.51;	author jont;	state Exp;
branches;
next	1.22;

1.22
date	95.09.07.11.54.25;	author nickb;	state Exp;
branches;
next	1.21;

1.21
date	95.09.06.14.25.07;	author nickb;	state Exp;
branches;
next	1.20;

1.20
date	95.09.04.16.22.12;	author nickb;	state Exp;
branches;
next	1.19;

1.19
date	95.09.01.10.37.52;	author nickb;	state Exp;
branches;
next	1.18;

1.18
date	95.07.17.12.32.56;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	95.06.13.16.15.36;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	95.06.08.11.00.07;	author jont;	state Exp;
branches;
next	1.15;

1.15
date	95.06.06.10.17.54;	author jont;	state Exp;
branches;
next	1.14;

1.14
date	95.05.30.12.54.41;	author jont;	state Exp;
branches;
next	1.13;

1.13
date	95.05.18.15.47.00;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.03.15.17.35.13;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.01.30.16.21.24;	author jont;	state Exp;
branches;
next	1.10;

1.10
date	95.01.23.12.32.11;	author jont;	state Exp;
branches;
next	1.9;

1.9
date	94.11.23.17.02.16;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	94.11.18.15.30.27;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	94.11.03.14.46.48;	author jont;	state Exp;
branches;
next	1.6;

1.6
date	94.11.02.15.40.23;	author jont;	state Exp;
branches;
next	1.5;

1.5
date	94.10.27.22.40.33;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.10.20.16.11.09;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.18.11.24.49;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.06.17.30.14;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.49.58;	author jont;	state Exp;
branches;
next	;

1.30.1.1
date	96.09.13.11.23.51;	author hope;	state Exp;
branches;
next	;

1.30.2.1
date	96.10.07.16.14.09;	author hope;	state Exp;
branches;
next	;

1.30.3.1
date	96.10.17.11.33.34;	author hope;	state Exp;
branches;
next	;

1.30.4.1
date	96.11.14.12.59.15;	author hope;	state Exp;
branches
	1.30.4.1.1.1;
next	;

1.30.4.1.1.1
date	96.11.28.15.09.14;	author hope;	state Exp;
branches;
next	;

1.31.1.1
date	96.11.22.18.16.57;	author hope;	state Exp;
branches;
next	;

1.31.2.1
date	96.12.17.10.03.43;	author hope;	state Exp;
branches;
next	;

1.31.3.1
date	96.12.17.17.55.19;	author hope;	state Exp;
branches
	1.31.3.1.1.1;
next	;

1.31.3.1.1.1
date	97.02.24.11.46.29;	author hope;	state Exp;
branches;
next	;

1.31.4.1
date	96.12.18.09.49.55;	author hope;	state Exp;
branches;
next	;

1.32.1.1
date	97.05.12.10.43.38;	author hope;	state Exp;
branches
	1.32.1.1.1.1
	1.32.1.1.2.1
	1.32.1.1.3.1;
next	;

1.32.1.1.1.1
date	97.07.28.18.24.37;	author daveb;	state Exp;
branches
	1.32.1.1.1.1.1.1;
next	;

1.32.1.1.1.1.1.1
date	97.10.07.11.50.24;	author jkbrook;	state Exp;
branches;
next	;

1.32.1.1.2.1
date	97.09.08.17.17.54;	author daveb;	state Exp;
branches;
next	;

1.32.1.1.3.1
date	97.09.09.14.14.07;	author daveb;	state Exp;
branches;
next	;

1.33.1.1
date	97.09.10.19.30.21;	author brucem;	state Exp;
branches;
next	;

1.33.2.1
date	97.09.11.20.59.57;	author daveb;	state Exp;
branches;
next	;

1.33.3.1
date	97.10.31.13.43.08;	author nickb;	state Exp;
branches;
next	;

1.41.1.1
date	99.04.01.18.00.05;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.41
log
@[Bug #70226]
Fix alignment of raise_count and stack_extensions
@
text
@/*
 * ==== ML TO C INTERFACING CODE ====
 *		I386
 *
 * Copyright (C) 1994 Harlequin Ltd
 *
 * Description
 * -----------
 * This code does the job of managing the interface between ML and C -
 * calls, exception raising, interception, garbage collection entry,
 * &c.
 *
 * Notes
 * -----
 * This code uses some predefined macros as parameters.  These are
 * defined (or not) in the Makefile.  They are as follows:
 *
 *   COLLECT_STATS: If defined the routines will update various
 *                  counters defined in callc_codes.c when called.
 *
 * This file must be run through CPP to produce an assembler file. 
 *
 * Revision Log
 * ------------
 * $Log: src:arch:I386:interface.S,v $
 * Revision 1.40  1998/10/20  10:37:15  jont
 * [Bug #70201]
 * Add interface to retract_root
 *
 * Revision 1.39  1998/09/15  10:25:22  jont
 * [Bug #20133]
 * Add an extra gc_limit slot so we can modify the other one when space profiling
 *
 * Revision 1.38  1998/07/31  11:05:23  jont
 * [Bug #70146]
 * Make sure that ml_profile_alloc is all excuted not in ML
 * This requires making a macro of the guts of ml_gc, and
 * placing that in both ml_gc and ml_profile_alloc
 *
 * Revision 1.37  1998/06/09  09:36:28  jont
 * [Bug #70129]
 * Make sure code is not in data section
 *
 * Revision 1.36  1998/04/22  10:47:18  jont
 * [Bug #30395]
 * Pop fp stack after testing for negative zeroes
 *
 * Revision 1.35  1998/02/05  13:11:47  jont
 * [Bug #70039]
 * Add code to check for negative real zero, to patch up broken
 * Win32 sprintf
 *
 * Revision 1.34  1998/01/26  10:38:29  jont
 * [Bug #70025]
 * Fix critical in_ML regions which were breaking profiler
 *
 * Revision 1.33  1997/06/04  10:39:32  jont
 * [Bug #30076]
 * Modifications to disturbance code to allow stack passing of procedure arguments
 *
 * Revision 1.32  1997/04/11  12:56:28  jont
 * [Bug #1412]
 * [Bug #1412]
 * Add piece of assembler to read fpu control word
 * for benefit of setting/getting rounding mode
 *
 * Revision 1.31  1996/11/15  13:05:42  nickb
 * Fix ml_disturbance "fake stack frame" behaviour.
 *
 * Revision 1.30  1995/12/13  11:27:30  nickb
 * OK, now let's make space profiling work.
 *
 * Revision 1.29  1995/12/12  17:45:14  nickb
 * Whoops; error in space profiling.
 *
 * Revision 1.28  1995/12/12  17:23:16  nickb
 * Add space profiling hooks.
 *
 * Revision 1.27  1995/11/23  15:36:58  nickb
 * Additional in_ML hacking.
 *
 * Revision 1.26  1995/11/16  13:34:27  nickb
 * Fix in_ML setting and unsetting to allow profiling.
 *
 * Revision 1.25  1995/11/15  15:03:02  nickb
 * Clear interrupt flags when entering ev_poll.
 *
 * Revision 1.24  1995/11/13  15:34:13  nickb
 * Move CURRENT_THREAD manipulation out of asm into portable C.
 * Also add native threads support for Win95.
 *
 * Revision 1.23  1995/10/17  14:56:51  jont
 * Temporarily remove stack switching to aid development on Win95
 *
 * Revision 1.22  1995/09/07  11:54:25  nickb
 * Restore callee-saves when unwinding past c_sp.
 *
 * Revision 1.21  1995/09/06  14:25:07  nickb
 * Change to c_sp protocol.
 *
 * Revision 1.20  1995/09/04  16:22:12  nickb
 * Interception/replacement.
 *
 * Revision 1.19  1995/09/01  10:37:52  nickb
 * Fix stack extension and various other things.
 *
 * Revision 1.18  1995/07/17  12:32:56  nickb
 * Add dummy sequences for space profiling.
 *
 * Revision 1.17  1995/06/13  16:15:36  jont
 * Event polling code
 * Also modify raise code to remove stack copying down and up in favour of
 * a small extra frame.
 *
 * Revision 1.16  1995/06/08  11:00:07  jont
 * Improvements to stack overflow and event handling
 * Also fixed some bugs in handling exceptions raised in C
 *
 * Revision 1.15  1995/06/06  10:17:54  jont
 * Add stack extension code
 *
 * Revision 1.14  1995/05/30  12:54:41  jont
 * Fix c_raise to work with thread system
 *
 * Revision 1.13  1995/05/18  15:47:00  jont
 * Modify comments on c_raise
 *
 * Revision 1.12  1995/03/15  17:35:13  nickb
 * Add threads system.
 *
 * Revision 1.11  1995/01/30  16:21:24  jont
 * Add stuff to make it work with gcc
 *
 * Revision 1.10  1995/01/23  12:32:11  jont
 * Modification of stub values for windows NT
 *
 * Revision 1.9  1994/11/23  17:02:16  nickb
 * Remove set_stack_underflow.
 *
 * Revision 1.8  1994/11/18  15:30:27  jont
 * Modify to new register assignment
 *
 * Revision 1.7  1994/11/03  14:46:48  jont
 * Fix problem with old c_state.sp being corrupted during callml
 *
 * Revision 1.6  1994/11/02  15:40:23  jont
 * Add ml_raise_leaf
 * Intended to add ml_gc_leaf, but this may not be necessary
 *
 * Revision 1.5  1994/10/27  22:40:33  jont
 * Add code for C_raise
 *
 * Revision 1.4  1994/10/20  16:11:09  jont
 * Add code for non-leaf raise
 *
 * Revision 1.3  1994/10/18  11:24:49  jont
 * Add gc entry code
 *
 * Revision 1.2  1994/10/06  17:30:14  jont
 * Also stub_c and stub_asm
 *
 * Revision 1.1  1994/10/04  16:49:58  jont
 * new file
 *
 *
*/

#include "tags.h"
#include "offsets.h"
#include "mach_values.h"
#include "macros.h"

/* === CALL ML FROM C ===
 *
 * callml is a C-like function which allows C to invoke an ML function in
 * the manner of a coroutine.
 *
 * Parameters:
 *   8(ESP)	Closure of the function to call
 *   4(ESP)	Argument for the ML function -- no multiple arg calls here.
 *   0(ESP)	Link register for return to C
 *   ESP	Current stack pointer
 *   EBP	Current (C) frame pointer (callee save)
 *   EBX	Callee save
 *   ESI	Callee save
 *   EDI	Callee save
 * Returns:
 *   EAX	Result of the ML function
 */

/* enter with in_ML = 0 */

	.global C_NAME(callml)
C_NAME(callml):
	mov	%esp, %eax		/* save esp so we can refer to args */
	save_C_regs
	mov	4(%eax), fnarg		/* argument */
	mov	8(%eax), %ebp		/* closure */
	lea	(C_NAME(global_state)), %eax
	mov	GLOBAL_current_thread(%eax), %esi
	mov	THREAD_c_sp(%esi), %edi  /* Old c_state.sp */
	mov	%esp, THREAD_c_sp(%esi)  /* Remember C sp for calls to C */
	load_ML_state(%ecx)
	mov	THREAD_ml_sp(%esi), %esp	/* saved ml_state.sp */
/* Now create a small frame at the top of the ml stack */
	mov	%esp, %edx		/* Remember current esp */
	pushl	$0			/* Dummy link here */
	push	%edi			/* Save old c_state.sp */
	pushl	$STACK_C_CALL		/* Dummy closure value */
	push	%edx			/* Link fp */
	movl	$1, GLOBAL_in_ML(%eax)	/* now in ML */
	mov	$STACK_START, %edi	/* Set up old closure value */
	mov	-1(%ebp), %ecx		/* Get code pointer */
	add	$CODE_OFFSET, %ecx
	call	%ecx

/* we enter ML with eax = global_state, edx = old ml_sp, esi = thread */
/* all these values are preserved in ML */
	movl	$2, GLOBAL_in_ML(%eax)		/* no longer in ML */
	mov	8(%esp), %ecx
	add	$16, %esp			/* Pop ML frame */
	mov	%esp, THREAD_ml_sp(thread)
	movl	$0, GLOBAL_in_ML(%eax)		/* ml_sp is valid */
	mov	THREAD_c_sp(thread), %esp	/* Reset to C stack */
	mov	%ecx, THREAD_c_sp(thread)	/* restore c_sp */
	mov	fnarg, %eax			/* Get result */
	load_C_regs
	ret

/*
 * === STUBS FROM ML ===
 *
 * These are static ML code vectors which call the routine pointed to
 * by their first closure element.  The C calling stub swaps into the C
 * state before calling the function, whereas the assembler version
 * does not. */

	.text
	.globl	C_NAME(text_internal_stub_c)
	.globl	C_NAME(text_internal_stub_c_end)
C_NAME(text_internal_stub_c):
	save_ML_regs
	mov	%esp, THREAD_ml_sp(thread) /* ml_sp = %sp */
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* ml_sp is valid */
	mov	THREAD_c_sp(thread), %esp  /* %sp = c_sp */
	push	fnarg			/* Stack argument */

#if __WINNT__
	mov	3(%ebp), %ecx
	shr	$2, %ecx
	call	%ecx
#else
	call	3(%ebp)			/* Call C function */
#endif

	mov	%eax, fnarg		/* Get the answer */
	load_ML_state(%ecx)
	pop	%ecx			/* pop argument */
	mov	THREAD_ml_sp(thread), %esp /* %sp = ml_sp */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML /* ml_sp becomes invalid here */
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML /* Now back to ML */
	ret
C_NAME(text_internal_stub_c_end):

	.text
	.globl	C_NAME(text_internal_stub_asm)
	.globl	C_NAME(text_internal_stub_asm_end)
C_NAME(text_internal_stub_asm):
#if __WINNT__
	mov	3(%ebp), %ecx
	shr	$2, %ecx
	jmp	%ecx
#else
	jmp	3(%ebp)			/* Tail to it */
#endif

C_NAME(text_internal_stub_asm_end):
	.text

stub_code_end:
	.align 4

/* === LOOK UP A VALUE IN THE RUNTIME ENVIRONMENT ===
 *
 * Calls directly through to perv_lookup() from environment.h.
 */

	.global C_NAME(ml_lookup_pervasive)

C_NAME(ml_lookup_pervasive):
	save_ML_regs
	ML_to_C(perv_lookup)
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret
#define ml_gc_internals								  \
	save_all_ML_regs		/* Save all the standard registers */	; \
	mov	%esp, THREAD_ml_sp(thread) /* Save last frame for gc */		; \
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML */		; \
	mov	THREAD_c_sp(thread), %esp  /* Onto c stack */			; \
	push	%edi								; \
	push	%ecx								; \
	call	C_NAME(gc)		/* Call garbage collector */		; \
	load_ML_state(%ecx)							; \
	mov	THREAD_ml_sp(thread), %esp /* Point back to ml frame */		; \
	mov	THREAD_ml_global(thread), %ecx /* Answer in correct place */	; \
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML, ml_sp invalid*/; \
	load_all_ML_regs		/* restore ml's registers */

/*
 * Call declare_root
 * ebx is root address
 *
 */
	.globl	ml_declare_root
ml_declare_root:
	save_ML_regs
	mov	$0, %eax	/* This is not a root as far as image saving is concerened */
	ML_to_C(declare_root)
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret
/*
 * Call retract_root
 * eax is root address
 *
 */
	.globl	ml_retract_root
ml_retract_root:
	save_ML_regs
	ML_to_C(retract_root)
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret
/*
 * Add a setup function result to the module table
 * %ebx is value to be added
 * %eax is module name
 * %edx is timestamp
 */
	.globl	ml_mt_update
ml_mt_update:
	save_ML_regs
	ML_to_C(mt_update)
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

/*
 * Add a code item to the weak table of code items
 * %ebx is value to be added
 */
	.globl	ml_loader_code_add
ml_loader_code_add:
	save_ML_regs
	ML_to_C(loader_code_add)
	load_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

/*
 * Add a global to be reinstated on image reload
 * %ebx is value to be added
 * %eax is module name
 */
	.globl	ml_declare_global
ml_declare_global:
	push	%eax
	push	%ebx
	call	C_NAME(declare_global_result)
	add	$8, %esp
	ret
	
/*
 * Record the time stamp of a dll
 * %eax is start address
 */
	.globl	ml_register_time_stamp
ml_register_time_stamp:
	push	%eax
	call	C_NAME(register_time_stamp)
	add	$4,%esp
	ret

/*
 * ml_internal_gc
 *
 * ecx = requested size
 * return address on stack
 * edi = current closure
 */
	.global C_NAME(ml_internal_gc)
C_NAME(ml_internal_gc):
	mov	IMPLICIT_profile_alloc_2(thread), %ecx	/* alloc amount back */
	save_all_ML_regs				/* Save all the standard registers */
	mov	%esp, THREAD_ml_sp(thread)		/* Save last frame for gc */
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML */
	mov	THREAD_c_sp(thread), %esp		/* Onto c stack */
	push	%edi
	push	%ecx
	call	C_NAME(gc)				/* Call garbage collector */
	load_ML_state(%ecx)
	mov	THREAD_ml_sp(thread), %esp		/* Point back to ml frame */
	mov	THREAD_ml_global(thread), %ecx		/* Answer in correct place */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML, ml_sp invalid*/
	load_all_ML_regs				/* restore ml's registers */
	ret

/* On the Intel x86 we do not allow allocation in leaf functions */

	.global C_NAME(ml_gc_leaf)
C_NAME(ml_gc_leaf):
	call	C_NAME(ml_gc_leaf_die)

/* === FLUSH REGISTER WINDOWS ===
 *
 * This routine would invoke the window flushing trap on SPARC.  We
 * have it for portability of interface.h.
 */
	.global C_NAME(flush_windows)

C_NAME(flush_windows):
	ret

/*
 * === STACK OVERFLOW / ASYNCHRONOUS EVENT ===
 *
 * This code is called by ML when %esp < stack_limit.
 * This condition is checked by ML on function entry to ensure that
 * there is enough room for a frame, and is used by the asynchronous
 * event handler to trip up ML at a `safe' moment.  The function
 * jumps here with the following parameters:
 *
 * (in all these comments, we assume that f called g which was disturbed)
 *
 *  ebx  g argument
 *  ebp  g
 *  edi  f
 *  ecx  minimum stack requirement of g
 *       (not including safety zone of 2kb or the normal register save area)
 *  esp[0]  link to continue g
 *  esp[1]  link to f
 *  esp+8   g's arguments (caller push, callee pop)
 *  esp+12  more g's arguments (Nb, there may be no arguments)
 *  esp+...
 *  esp+8+(#args*4)   f's frame
 */
	.global C_NAME(ml_disturbance)

C_NAME(ml_disturbance):

/* first we create a dummy stack frame for the disturbed function. This 
 * leaves us with a consistent stack */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */

	push	%edi			/* Save f's closure */
	mov	-1(%ebp), %edi		/* g's code item */
	mov	-1(%edi), %edi		/* g's ancillary field */
	shr	$CCODE_ARGS_SHIFT, %edi
	and	$CCODE_MAX_ARGS, %edi	/* # args */
	lea	12(%esp, %edi, 4), %edi	/* calc frame pointer */
	push 	%edi			/* Save frame pointer */
	xchg	%ecx, 8(%esp)		/* swap frame size with continuation */
	mov	-1(%ebp), %edi		/* g's code item */
	sub	%edi, %ecx		/* g's code offset */
	shl	$2, %ecx		/* as an ML value */

/* build a new frame */

	pushl	$0			/* link slot */
	push	%ecx			/* ML(g offset) */
	push	%ebx			/* g arg */
	push	%ebp			/* g; stack_crawl depends heavily on
	                                 * the placement of this value */
	push	%edx			/* callee saves */
	push	%eax
	push	$STACK_DISTURB_EVENT
	lea	28(%esp), %ebp
	push	%ebp			/* frame pointer */
/* now we've saved the registers, we dink with the arguments to g
 * that were passed on the stack.
 * The first argument and f's link (return address in f) are swapped.
 * This puts the return address in the "correct place" for stack_crawl
 * to find.
 * Note that this is done (and does "the right thing") even when
 * there are no argumens.
 */
/* %edi - g's code item */
	mov	-1(%edi), %edi		/* g's ancillary field */
	shr	$CCODE_ARGS_SHIFT, %edi
	and	$CCODE_MAX_ARGS, %edi	/* # args */
	mov	44(%esp), %ecx		/* load link f */
	xchg	%ecx, 44(%esp, %edi, 4) /* swap with g's 1st arg */
	mov	%ecx, 44(%esp)		/* store g's 1st arg */
	mov	$STACK_DISTURB_EVENT, %edi /* frame closure tag */

/* Now we check that a stack extension is required (could be we've
 * just had an event) */

extend_stack:
	mov	%esp, %ebp
	mov	40(%esp), %ecx		/* recover frame size from stack */
	sub	%ecx, %ebp		/* Calculate required new sp */
	cmp	IMPLICIT_stack_limit(thread), %ebp /* compare with slimit */
	jae	check_for_events	/* Branch if not */

/* We need a stack extension */

#ifdef COLLECT_STATS				
	incl	C_NAME(stack_extension_count)	/* Inc stack extension count */
#endif
	mov	IMPLICIT_stack_limit(thread), %eax
	lea	-(STACK_BUFFER+DEFAULT_STACK_SIZE)(%eax), %ebx
					/* arg 0 = current stack */
	lea	(STACK_BUFFER+DEFAULT_STACK_SIZE)(%ecx), %eax
					/* arg 1 = requested amount */
	ML_to_C(make_ml_stack)
	lea	(STACK_BUFFER+DEFAULT_STACK_SIZE)(%ebx), %ecx /* new slimit */
	mov	%ecx, IMPLICIT_stack_limit(thread)	/* save it */
	mov	%ecx, IMPLICIT_register_stack_limit(thread)
	mov	4(%ebx), %ecx		/* The new sp */

/* Having made a new stack block, we move our final frame onto it */

	load_all_ML_regs		/* All ML registers as before call */
	pop	%edi			/* ML(g offset) */
	mov	%edi, -4(%ecx)		/* ML(g offset) */
	mov	%ebx, -8(%ecx)		/* g argument */
	mov	%ebp, -12(%ecx)		/* g */
	mov	%edx, -16(%ecx)		/* saved edx */
	mov	%eax, -20(%ecx)		/* saved eax */
	movl	$STACK_EXTENSION, %edi	/* closure */
	movl	%edi, -24(%ecx)		/* in closure slot */
	lea	4(%esp), %ebx		/* frame pointer */
	mov	%ebx, -28(%ecx)		/* fp slot */
	lea	-28(%ecx), %esp		/* onto new stack */
	
/* Now we test for events. We get here by one of two routes (depending
 * on whether we have extended the stack or not).
 * eax Callee save (already saved)
 * ebx -
 * ecx -
 * edx Callee save (already saved)
 * esi thread
 * edi STACK_DISTURB_EVENT or STACK_EXTENSION
 * ebp -
 */

check_for_events:
	mov	IMPLICIT_interrupt(thread), %ecx
	or	IMPLICIT_register_stack_limit(thread), %ecx
	jg	call_disturbed_fn	/* Branch if no interrupts pending */
	movl	$0, IMPLICIT_interrupt(thread)
	mov	IMPLICIT_stack_limit(thread), %ecx
	mov	%ecx, IMPLICIT_register_stack_limit(thread)
	ML_to_C(ev_poll)

/* We need to call the disturbed function with caller's closure set to
 * STACK_EXTENSION or STACK_EVENT as appropriate, and the stack size in ecx.
*/

call_disturbed_fn:
	mov	4(%esp), %edi		/* restore STACK_* */
	mov	16(%esp),%ebp		/* restore g */
	mov	-1(%ebp),%ecx		/* code item */
	mov	-1(%ecx),%ecx		/* ancillary word */
	shr	$CCODE_ARGS_SHIFT,%ecx
	and	$CCODE_MAX_ARGS,%ecx	/* # args */
	mov	%ecx,%eax		/* save #args */
	jecxz	copy_no_more_args	/* break early for no stack args */
	mov	0(%esp),%edx		/* locate g's arguments... */
	push	12(%edx)		/* 1st arg has been dinked */
	dec	%ecx
	jecxz	copy_no_more_args	/* only 1 arg */
	mov	0(%edx),%edx		/* 2 frames back ... */
	/* the following loop could probably be improved */
	lea	-8(%edx),%edx		/* points to 2nd pushed arg */
copy_args:
	push	(%edx)			/* copy an argument down */
	lea	-4(%edx),%edx
	dec	%ecx
	jnz	copy_args
copy_no_more_args:
	/* eax contains number of args */
	mov	12(%esp,%eax,4),%edx	/* restore saved edx */
	mov	20(%esp,%eax,4),%ebx	/* restore g's argument */
	mov	24(%esp,%eax,4),%ecx	/* ML (g offset) */
	shr	$2, %ecx		/* g offset */
	add	-PAIRPTR(%ebp), %ecx	/* g continuation */
	push	%ecx			/* push anything */
	push	%ecx			/* push continuation address */
	lea	return_from_disturbed_fn, %ecx	/* Our return address */
	mov	%ecx, 4(%esp)		/* Put it on the stack */
	mov	8(%esp,%eax,4), %ecx	/* frame pointer */
	mov	8(%ecx), %ecx		/* size requested */
	mov	16(%esp,%eax,4),%eax	/* restore saved eax */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret				/* Call the rest of the disturbed fn */

return_from_disturbed_fn:
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML */
	cmp	$STACK_EXTENSION, %edi	/* Did we extend the stack */
	jne	return_to_caller	/* Branch if not */

/* We did a stack extension; we need to move back to the previous
 * stack and call unmake_stack.
 * eax Callee save
 * ebx Result
 * ecx -
 * edx Callee save
 * esi thread
 * edi STACK_EXTENSION
 * ebp -

 * We have to push a frame on the old stack containing the
 * callee-saves, then call unmake_stack. We have to be careful to pass
 * the returned value back to the caller. */

	mov	0(%esp), %esp		/* back to old stack */
	pushl	$0			/* link slot */
	save_all_ML_regs
	mov	IMPLICIT_stack_limit(thread), fnarg
					/* Stack limit of stack to discard */
	sub	$(STACK_BUFFER+DEFAULT_STACK_SIZE), fnarg
					/* Get proper pointer to it */
	ML_to_C(unmake_ml_stack)	/* Throw away the stack */
	add	$(STACK_BUFFER+DEFAULT_STACK_SIZE), fnarg
					/* Calculate new slimit */
	mov	fnarg, IMPLICIT_stack_limit(thread) /* Save it */
	mov	fnarg, IMPLICIT_register_stack_limit(thread)
	mov	IMPLICIT_interrupt(thread),fnarg	/* interrupt status */
	or	fnarg,IMPLICIT_register_stack_limit(thread)
	load_all_ML_regs
	pop	%ecx			/* discard */
	pop	%ecx			/* fp */
	pop	%edi			/* f's closure */
	lea	-4(%ecx),%esp		/* junk frame except for link f */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret				/* return to caller */

return_to_caller:
	mov	0(%esp),%esp		/* discard frame */
	pop	%ecx			/* fp */
	pop	%edi			/* f's closure */
	lea	-4(%ecx),%esp		/* junk frame except for link f */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

/*
 * === CHECK FOR AN ML EVENT ===
 *
 * We arrive here when register_stack_limit(thread) has been detected to be -1
 * in a non-leaf function.
 *
 * All registers potentially significant
 * 4(esp) frame pointer
 * 0(esp) return address
 * edi function closure
 */
	.global	C_NAME(ml_event_check)
C_NAME(ml_event_check):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	movl	$0, IMPLICIT_interrupt(thread)
	mov	IMPLICIT_stack_limit(thread), %ecx
	mov	%ecx, IMPLICIT_register_stack_limit(thread)
	save_all_ML_regs
	ML_to_C(ev_poll)
	load_all_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
	ret

/*
 * We arrive here when register_stack_limit(thread) has been detected to be -1
 * in a leaf function
 *
 * All registers potentially significant
 * 8(esp) frame pointer for caller of leaf function
 * 4(esp) return address from leaf function
 * 0(esp) return address to polling (leaf) function
 * ebp function closure
 */

	.globl	C_NAME(ml_event_check_leaf)
C_NAME(ml_event_check_leaf):
/*
 * Need to create a dummy frame for the leaf function
 */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	lea	8(%esp), %ecx	/* New fp */
	push	%ecx		/* Save on stack */
	push	4(%esp)		/* Move the return address down */
	mov	%edi, 8(%esp)	/* Save caller's caller's closure */
	mov	%ebp, %edi	/* Set up closure as if from non-leaf */
/* Now in common with ml_event_check */
	movl	$0, IMPLICIT_interrupt(thread)
	mov	IMPLICIT_stack_limit(thread), %ecx
	mov	%ecx, IMPLICIT_register_stack_limit(thread)
	save_all_ML_regs
	ML_to_C(ev_poll)
	load_all_ML_regs
/* Now undo dummy frame */
	mov	8(%esp), %edi	/* Restore caller's caller's closure */
	pop	%ecx		/* get return address */
	mov	%ecx, 4(%esp)	/* to where we want it */
	add	$4, %esp
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret			/* return */

/* === RAISE AN EXCEPTION FROM C === */
/* This is an entry point to ml_raise which may be called from C. */

	.global C_NAME(c_raise)

C_NAME(c_raise):

/*
 * Cut back to last ml frame, as saved in stub_c
 * Raise argument is at 4(ESP)
 * Rewind to previous ml_state.sp
 */
	mov	C_NAME(global_state)+GLOBAL_current_thread, thread
					/* get current thread pointer */
	load_ML_state(%ecx)
	mov	4(%esp), fnarg		/* Place exception argument in fnarg */
	mov	THREAD_ml_sp(thread), %esp	/* Restore ml_state.sp */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */

	xor	%ebp, %ebp				/* clean caller clos */
	load_ML_regs
	/* \/\/ fall through \/\/ */
/* At this point, the return address to whatever called C is at
 * 0(esp)
 */

/* 
 * === RAISE AN EXCEPTION ===
 *
 * When an exception is raised the first exception handler function on
 * the handler chain is called to deal with it.	If the handler
 * function returns then the exception was handled.  In the context of
 * the function in which the handler was created (the `creator') must
 * be restored and that function continued.  Restore instructions are
 * executed repeatedly until the current stack pointer matches the
 * pointer that was stored in the handler record.
 *
 * There are some subtleties.  The stack may be disjoint, so, after
 * crawling our way back up it the C function unwind_stack is called
 * to deallocate an extensions that are no longer required.
 *
 * If the handler record is zero then the next handler is the top-level
 * handler, and the C function handle() is called.  This returns iff a
 * debugger is installed, and passes some information about where to
 * find it.  In this case, the debugger is called, and that in turn
 * returns instructions for what to do next.
 *
 * Handler record format:
 *   -1	Previous handler
 *    3	Stack pointer of creator
 *    7	Handler function closure
 *   11	Offset within creator of continuation code
 *
 * Parameters:
 *   fnarg		The exception packet to raise
 *   EDI		Current function's closure
 *   thread		Thread state
 *   0(ESP)		Return address for resumption
			 (not used at present, and not true for leaf)
 *   64(thread)	Exception handler record
 *
 *
 * Warning. This code assumes that all procedures containing handler
 * continuations are non-leaf. This is currently true because handlers
 * are stack allocated.
 *
 */
	.global C_NAME(ml_raise)
	.global C_NAME(ml_raise_leaf)

C_NAME(ml_raise):
#ifdef COLLECT_STATS
	incl	C_NAME(raise_count)
#endif
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */

	add	$4, %esp		/* Throw away return address */
	mov	IMPLICIT_handler(thread), %ecx
	pushl	$0			/* Dummy return address */
	push	%ecx			/* Save current handler */
	lea	8(%esp), %ebp		/* Calculate fp for this frame */
	push	%edi			/* Save caller's closure */
	push	%ebp			/* Save fp */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
	mov	7(%ecx), %ebp		/* Handler closure */
	movl	$STACK_RAISE, %edi	/* This frame's closure */
	mov	-1(%ecx), %ecx		/* Previous handler frame */
	mov	%ecx, IMPLICIT_handler(thread)	/* Set new handler */
	mov	-1(%ebp), %ecx		/* Code pointer of handling function */
	add	$CODE_OFFSET, %ecx	/* Plus offset */
	call	%ecx			/* Call the handler function */
/*
 * Remove dummy frame from stack
 */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	add	$4, %esp		/* Throw away fp */
	pop	%edi			/* Caller's closure back */
	pop	%ecx			/* Current handler frame for unwind */
	add	$4, %esp		/* Throw away return address */
	xor	%ebp, %ebp		/* Clean out potential non-GC value */
	mov	%ecx, IMPLICIT_handler(thread) 	/* Restore original handler */
	mov	3(%ecx), %ecx		/* Get sp value from handler frame */
	mov	0(%ecx), %ecx		/* And get its fp */
	unwind_stack(raise)		/* Unwind to that frame */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
	mov	IMPLICIT_handler(thread), %ebp
	mov	11(%ebp), %ecx		/* Fetch offset of the continuation */
	shr	$2, %ecx		/* Untag it */
	add	-1(%edi), %ecx		/* Add in start of creator function */
	add	$CODE_OFFSET, %ecx	/* Plus tag */
	jmp	%ecx			/* Back we go */

C_NAME(ml_raise_leaf):
#ifdef COLLECT_STATS
	incl	C_NAME(raise_count)
#endif

	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
/*
 * Here we may have some arguments on the stack to throw away
 */
	mov	-1(%ebp), %ecx		/* Get code vector */
	mov	-1(%ecx), %ecx		/* Get ancillary word */
	shr	$CCODE_ARGS_SHIFT, %ecx	/* Move args part into ls bits */
	and	$CCODE_MAX_ARGS, %ecx	/* Get rid of other bits */
	lea	4(%esp, %ecx, 4), %esp	/* Throw away one return address and args */
	jmp	C_NAME(ml_raise)

/*
 * === CODE VECTOR REPLACEMENT AND INTERCEPTION ===
 *
 *
 * When compiled for debugging, code vectors contain a sequence of
 * nop operations which can be replaced with code to intercept or
 * replace the flow of control.  This is used to implement tracing,
 * profiling, etc.
 * 
 * ml_intercept (ml_intercept_leaf) is jumped to by the instructions
 * inserted into a code vector when it is to be intercepted (see
 * `intercept_on' below).  It calls the C function `intercept',
 * passing its frame.  When `intercept' returns, the intercepted
 * function is continued.
 * 
 * The above comments hold (mutatis mutandis) for 'replace'; in that
 * case the intercepted function is abandoned.
 *
 * These four routines are all pointed to from the implicit vector.
 *
 */
	.global	C_NAME(ml_replace)
	.global	C_NAME(ml_replace_leaf)
	.global C_NAME(ml_intercept)
	.global C_NAME(ml_intercept_leaf)

C_NAME(ml_replace):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML
	save_all_ML_regs		/* dummy frame */
	mov	%esp, fnarg
	ML_to_C(replace)
	load_all_ML_regs
	mov	8(%esp), %edi		/* restore caller's closure */
	mov	4(%esp), %ecx		/* fp of parent frame */
	lea	-4(%ecx), %esp		/* sp = fp-4, below return address */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

C_NAME(ml_intercept):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	save_all_ML_regs
	mov	%esp, fnarg
	ML_to_C(intercept)
	load_all_ML_regs
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
	ret

C_NAME(ml_replace_leaf):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	pop	%ecx			/* pop continuation address */
	push	fnarg			/* dummy frame 1 : argument */
	push	%edi			/*                 caller's closure */
	lea	12(%esp), %edi		/*		   fp */
	push	%edi
	push	%ecx			/* dummy frame 2: continuation address */
	push	fnarg			/*		  argument */
	push	%edx			/*		  callee-save */
	push	%eax			/*		  callee-save */
	push	%ebp			/*		  closure */
	lea	20(%esp),%ecx		/*		  fp */
	push	%ecx
	mov	%esp, fnarg		/* frame as argument */
	ML_to_C(replace)
	add	$8, %esp
	pop	%eax			/* restore callee-saves */
	pop	%edx
	pop	fnarg			/* restore result */
	mov	8(%esp), %edi		/* restore caller's closure */
	add	$16, %esp		/* pop dummy frame 1 */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

/* interception is the same except for the very last part. */

C_NAME(ml_intercept_leaf):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML
	pop	%ecx			/* pop continuation address */
	push	fnarg			/* dummy frame 1 : argument */
	push	%edi			/*                 caller's closure */
	lea	12(%esp), %edi		/*		   fp */
	push	%edi
	push	%ecx			/* dummy frame 2: continuation address */
	push	fnarg			/*		  argument */
	push	%edx			/*		  callee-save */
	push	%eax			/*		  callee-save */
	push	%ebp			/*		  closure */
	lea	20( %esp),%ecx		/*		  fp */
	push	%ecx
	mov	%esp, fnarg		/* frame as argument */
	ML_to_C(replace)
	add	$4, %esp
	pop	%ebp
	pop	%eax			/* restore callee-saves */
	pop	%edx
	pop	fnarg			/* restore result */
	pop	%ecx			/* continuation address */
	add	$4, %esp		/* skip frame ptr */
	pop	%edi			/* restore caller's closure */
	add	$4, %esp		/* skip arg slot */
	push	%ecx			/* push continuation address */
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
	ret

/* == Replacement code ==
 *
 * These are sections of code which are inserted at the start of a code
 * vector and altered to implement interception.  They are
 * *_INTERCEPT_LENGTH bytes long (from tags.h); three in the intel case.
 * 
 * There are four interception code segments; for intercepting and
 * replacing, for leaf and non-leaf functions. They call the relevant
 * bit of code above (ml_intercept_on calls ml_intercept, for
 * instance). ml_nop is the sequence of three special nops which are
 * replaced by the intercepts; they are here so we can undo
 * interception.
 */

	.global C_NAME(ml_replace_on)
	.global	C_NAME(ml_replace_on_leaf)
	.global C_NAME(ml_intercept_on)
	.global C_NAME(ml_intercept_on_leaf)
	.global C_NAME(ml_nop)

C_NAME(ml_replace_on):
	call	IMPLICIT_replace(thread)

C_NAME(ml_replace_on_leaf):
	call	IMPLICIT_replace_leaf(thread)

C_NAME(ml_intercept_on):
	call	IMPLICIT_intercept(thread)

C_NAME(ml_intercept_on_leaf):
	call	IMPLICIT_intercept_leaf(thread)

C_NAME(ml_nop):
	cmc
	cmc	
	cmc

/* This generates a debugger trap. */

	.global C_NAME(generate_debugger_trap)

C_NAME(generate_debugger_trap):
	int 	$3

	.global C_NAME(switch_to_thread)
#ifdef NATIVE_THREADS
C_NAME(switch_to_thread):
	mov	4(%esp),%eax			  /* eax = old thread */
	mov	8(%esp),%edx			  /* edx = new thread */
	pop	%ecx				  /* save old eip */
	mov	%ecx, THREAD_c_eip(%eax)
	push	%edx				  /* new thread */
	push	%eax				  /* old thread */
	call	C_NAME(native_thread_yield)	  /* returns previous thread */
	pop	%edx				  /* this thread */
	add	$4, %esp			  /* discard */
	mov	THREAD_c_eip(%edx), %ecx
	push	%ecx				  /* install continuation */
	ret					  /* return previous thread */
#else
C_NAME(switch_to_thread):
	mov	4(%esp),%eax			 /* the old thread */
	mov	8(%esp),%edx			 /* the new thread */
	save_thread_registers(%eax)		  /* swap saved registers */
	load_thread_registers(%edx)		  /* (ebp, esi, edi, ebx) */
	pop	%ecx				  /* save and set esp, eip */
	mov	%ecx, THREAD_c_eip(%eax)
	mov	THREAD_c_eip(%edx), %ecx
	mov	%esp, THREAD_c_esp(%eax)
	mov	THREAD_c_esp(%edx), %esp
	push	%ecx				/* the address to return to */
	ret					/* return the old thread */
#endif

/* Space profiling. We come here as if we were going to ml_gc. */
	.global	C_NAME(ml_gc)
/*
 * ml_gc
 *
 * ecx = requested size
 * return address on stack
 * edi = current closure
 */

C_NAME(ml_gc):
	mov	%ecx, IMPLICIT_profile_alloc_2(thread)	/* save alloc amount */
	mov	IMPLICIT_gc_base(thread), %ecx		/* test for GC */
	cmp	IMPLICIT_real_gc_limit(thread), %ecx
	jbe	ml_gc_noGC				/* no GC */

/* a GC is required */	

	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	push	%edi					/* create fake frame */
	lea	8(%esp), %ecx
	push	%ecx
	mov	IMPLICIT_profile_alloc_2(thread), %ecx	/* restore alloc amt */
	movl	$STACK_SPACE_PROFILE, %edi		/* fake frame closure */
	call	C_NAME(ml_internal_gc)
	add	$4, %esp				/* pop fp */
	pop	%edi
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* back in ML */
	jmp	ml_gc_record
ml_gc_noGC:	
	mov	IMPLICIT_gc_base(thread), %ecx		/* advanced alloc point */
	sub	IMPLICIT_profile_alloc_2(thread), %ecx	/* alloc point */
ml_gc_record:
/*
 * Now determine if we are space profiling
 */
	.globl	C_NAME(space_profile_active)
	mov	%eax, IMPLICIT_profile_alloc_2(thread)	/* save eax */
	mov	C_NAME(space_profile_active), %eax	/* get flag */
	cmp	$0, %eax
	je	ml_gc_exit				/* branch if not space profiling */
	mov	THREAD_ml_profile(thread), %eax
	mov	%edi, 0(%eax)
	mov	%ecx, 4(%eax)
	add	$8, %eax
	mov	%eax, THREAD_ml_profile(thread)
#ifdef	SPACE_PROFILE_OVERFLOW
/*
 * Now ensure that the limit is set to the base so we reenter at next allocation
 */
	mov	IMPLICIT_gc_base(thread), %eax
	mov	%eax, IMPLICIT_gc_limit(thread)
#endif
ml_gc_exit:
	mov	IMPLICIT_profile_alloc_2(thread), %eax	/* restore eax */
	ret

	.global	C_NAME(ml_profile_alloc)
C_NAME(ml_profile_alloc):
#ifdef	SPACE_PROFILE_OVERFLOW
	jmp	C_NAME(ml_gc)
#else
/* Deprecated interface */
	call	C_NAME(ml_profile_alloc_die)
#endif

/* leaf allocation is not allowed on the x86 */

	.global	C_NAME(ml_profile_alloc_leaf)
C_NAME(ml_profile_alloc_leaf):
	call	C_NAME(ml_gc_leaf_die)

/* fpu control word reading for linux */
	
	.global	C_NAME(get_fpu_control_word)
C_NAME(get_fpu_control_word):
	sub	$4, %esp	/* Make some space on stack */
	fnstcw	2(%esp)		/* Store the control word there */
	movw	2(%esp), %ax	/* Load it into %ax */
	and	$0xf3f, %eax	/* Clean out rubbish */
	add	$4, %esp	/* Don't need the space any more */
	ret			/* Return, answer in eax */

	.global	C_NAME(asm_check_neg_zero)
C_NAME(asm_check_neg_zero):
	mov	4(%esp), %eax
	fldl	0(%eax)		/* Get the real to be tested */
	fxam			/* Check status */
	fstsw	%ax		/* Get float status into ax */
	fstp	%ST(0)		/* Pop fp stack again */
	andw	$0x4300, %ax	/* Mask out crap */
	cmpw	$0x4000, %ax	/* Check for +0 */
	jz	l0
	cmpw	$0x4200, %ax	/* Check for -0 */
	jz	l1
	movl	$0, %eax	/* Return 0 */
	ret
l0:	movl	$1, %eax	/* Return 1 */
	ret
l1:	movl	$2, %eax	/* Return 2 */
	ret

/* Trampoline call ML from C
 *
 * trampoline is a C-like function which allows C to invoke an ML function in
 * the manner of a coroutine.
 *
 * Parameters:
 *   4(ESP)     Function to be called
 *   0(ESP)	Link register for return to C
 *   ESP	Current stack pointer
 *   EBP	Current (C) frame pointer (callee save)
 *   EBX	Callee save
 *   ESI	Callee save
 *   EDI	Callee save
 *   EAX	Function to be called
 * Returns:
 *   EAX	Result of the ML function
 */

/* enter with in_ML = 0 */

	.global C_NAME(asm_trampoline)
C_NAME(asm_trampoline):
	mov	%esp, %eax		/* save esp so we can refer to args */
	save_C_regs
	mov	4(%eax), %ebp		/* The function closure */
	lea	(C_NAME(global_state)), %eax
	mov	GLOBAL_current_thread(%eax), %esi
	mov	THREAD_c_sp(%esi), %edi  /* Old c_state.sp */
	mov	%esp, THREAD_c_sp(%esi)  /* Remember C sp for calls to C */
	load_ML_state(%ecx)
	mov	THREAD_ml_sp(%esi), %esp	/* saved ml_state.sp */
/* Now create a small frame at the top of the ml stack */
	mov	%esp, %edx		/* Remember current esp */
	pushl	$0			/* Dummy link here */
	push	%edi			/* Save old c_state.sp */
	pushl	$STACK_C_CALL		/* Dummy closure value */
	push	%edx			/* Link fp */
	movl	$1, GLOBAL_in_ML(%eax)	/* now in ML */
	mov	$STACK_START, %edi	/* Set up old closure value */
	mov	-1(%ebp), %ecx		/* Get code pointer */
	add	$CODE_OFFSET, %ecx
	call	%ecx
/* we enter ML with edx = old ml_sp, esi = thread */
/* all these values are preserved in ML */
	lea	(C_NAME(global_state)), %eax
	movl	$2, GLOBAL_in_ML(%eax)		/* no longer in ML */
	mov	8(%esp), %ecx
	add	$16, %esp			/* Pop ML frame */
	mov	%esp, THREAD_ml_sp(thread)
	movl	$0, GLOBAL_in_ML(%eax)		/* ml_sp is valid */
	mov	THREAD_c_sp(thread), %esp	/* Reset to C stack */
	mov	%ecx, THREAD_c_sp(thread)	/* restore c_sp */
	mov	fnarg, %eax			/* Get result */
	load_C_regs
	ret


	.section	.drectve
	.asciz	"-export:ml_declare_root"
	.asciz	"-export:ml_retract_root"
	.asciz	"-export:ml_mt_update"
	.asciz	"-export:ml_declare_global"
	.asciz	"-export:ml_register_time_stamp"
	.asciz	"-export:ml_loader_code_add"

#ifdef COLLECT_STATS
	.global C_NAME(raise_count)
	.global C_NAME(stack_extension_count)
#endif
@


1.41.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a25 4
 * Revision 1.41  1998/10/30  17:08:27  jont
 * [Bug #70226]
 * Fix alignment of raise_count and stack_extensions
 *
@


1.40
log
@[Bug #70201]
Add interface to retract_root
@
text
@d26 4
a1184 6
	.data
	.align 2
C_NAME(raise_count):
	.long 0
C_NAME(stack_extension_count):
	.long 0
@


1.39
log
@[Bug #20133]
Add an extra gc_limit slot so we can modify the other one when space profiling
@
text
@d26 4
d315 1
a315 1
	mov	$1, %eax	/* This is a root as far as image saving is concerened */
d321 12
d1172 1
@


1.38
log
@[Bug #70146]
Make sure that ml_profile_alloc is all excuted not in ML
This requires amking a macro of the guts of ml_gc, and
placing that in both ml_gc and ml_profile_alloc
@
text
@d26 6
d278 1
a278 1
 * Calls directly through to env_lookup() from environment.h.
d304 64
a367 1
 * ml_gc
d373 15
a387 6

	.global C_NAME(ml_gc)
C_NAME(ml_gc):
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
	ml_gc_internals
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
d996 1
d998 1
a998 11
 * ml_gc_internal
 * This is a version of ml_gc without setting and reseting in_ML
 * It allows ml_profile_alloc to work correctly
 * and not to have an otherwise irremovable critical region at the pop edi
 */
ml_gc_internal:
	ml_gc_internals
	ret
	.global	C_NAME(ml_profile_alloc)
/*
 * ml_profile_alloc
d1005 2
a1006 2
C_NAME(ml_profile_alloc):
	mov	%ecx, IMPLICIT_profile_alloc_2(thread) /* save alloc amount */
d1008 2
a1009 2
	cmp	IMPLICIT_gc_limit(thread), %ecx
	jbe	ml_profile_alloc_noGC	/* no GC */
d1014 1
a1014 1
	push	%edi				/* create fake frame */
d1017 4
a1020 4
	mov	IMPLICIT_profile_alloc_2(thread), %ecx /* restore alloc amt */
	movl	$STACK_SPACE_PROFILE, %edi	/* fake frame closure */
	call	ml_gc_internal
	add	$4, %esp			/* pop fp */
d1023 3
a1025 3
	jmp	ml_profile_alloc_record
ml_profile_alloc_noGC:	
	mov	IMPLICIT_gc_base(thread), %ecx	/* advanced alloc point */
d1027 5
a1031 1
ml_profile_alloc_record:
d1033 3
d1041 8
d1052 9
d1065 1
a1065 1
	call	C_NAME(ml_gc_leaf_die);
d1096 64
@


1.37
log
@[Bug #70129]
Make sure code is not in data section
@
text
@d26 4
d283 14
d308 1
a308 12
	save_all_ML_regs		/* Save all the standard registers */
	mov	%esp, THREAD_ml_sp(thread) /* Save last frame for gc */
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML */
	mov	THREAD_c_sp(thread), %esp  /* Onto c stack */
	push	%edi
	push	%ecx
	call	C_NAME(gc)		/* Call garbage collector */
	load_ML_state(%ecx)
	mov	THREAD_ml_sp(thread), %esp /* Point back to ml frame */
	mov	THREAD_ml_global(thread), %ecx /* Answer in correct place */
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML, ml_sp invalid*/
	load_all_ML_regs		/* restore ml's registers */
d918 9
a926 1

d929 1
a929 1
 * ml_gc
d950 1
a950 1
	call	C_NAME(ml_gc)
@


1.36
log
@[Bug #30395]
Pop fp stack after testing for negative zeroes
@
text
@d26 4
a958 104
#ifdef COLLECT_STATS
	.global C_NAME(raise_count)
	.global C_NAME(stack_extension_count)
	.data
	.align 2
C_NAME(raise_count):
	.long 0
C_NAME(stack_extension_count):
	.long 0
#endif

#if __WINNT__
/* stub functions to do the calling to the kernel, which doesn't */
/* use the c calling convention. Anyother great stupidity from Microsoft */

#define	ChangeConvention0(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	call	C_NAME(name@@0)		;\
	pop	%ebp			;\
	ret

#define	ChangeConvention4(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	push	8(%ebp)			;\
	call	C_NAME(name@@4)		;\
	pop	%ebp			;\
	ret

#define	ChangeConvention8(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	push	12(%ebp)		;\
	push	8(%ebp)			;\
	call	C_NAME(name@@8)		;\
	pop	%ebp			;\
	ret

#define	ChangeConvention12(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	push	16(%ebp)		;\
	push	12(%ebp)		;\
	push	8(%ebp)			;\
	call	C_NAME(name@@12)		;\
	pop	%ebp			;\
	ret

#define	ChangeConvention16(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	push	20(%ebp)		;\
	push	16(%ebp)		;\
	push	12(%ebp)		;\
	push	8(%ebp)			;\
	call	C_NAME(name@@16)		;\
	pop	%ebp			;\
	ret

#define	ChangeConvention20(name)	\
	.global	C_NAME(name)		;\
C_NAME(name):				;\
	push	%ebp			;\
	mov	%esp, %ebp		;\
	push	24(%ebp)		;\
	push	20(%ebp)		;\
	push	16(%ebp)		;\
	push	12(%ebp)		;\
	push	8(%ebp)			;\
	call	C_NAME(name@@20)		;\
	pop	%ebp			;\
	ret

	ChangeConvention8(GetCurrentDirectoryA)
	ChangeConvention8(FindFirstFileA)
	ChangeConvention0(GetCurrentProcess)
	ChangeConvention4(GetSystemInfo)
	ChangeConvention4(GetSystemTime)
	ChangeConvention16(GetFullPathNameA)
	ChangeConvention0(GetLastError)
	ChangeConvention4(GetLocalTime)
	ChangeConvention16(VirtualAlloc)
	ChangeConvention12(VirtualFree)
	ChangeConvention20(GetProcessTimes)
	ChangeConvention0(GetTickCount)
	ChangeConvention16(SetFileTime)
	ChangeConvention8(SystemTimeToFileTime)

	.global	C_NAME(__main)
C_NAME(__main):
	ret
#endif

d988 11
@


1.35
log
@[Bug #70039]
Add code to check for negative real zero, to patch up broken
Win32 sprintf
@
text
@d26 5
d1076 1
@


1.34
log
@[Bug #70025]
Fix critical in_ML regions which were breaking profiler
@
text
@d26 4
d1064 18
@


1.33
log
@[Bug #30076]
Modifications to disturbance code to allow stack passing of procedure arguments
@
text
@d26 4
d229 1
d231 1
a231 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML
d287 1
d789 1
a789 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
d820 1
a820 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
a922 1
	movl	$2, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
@


1.33.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a25 4
 * Revision 1.33  1997/06/04  10:39:32  jont
 * [Bug #30076]
 * Modifications to disturbance code to allow stack passing of procedure arguments
 *
@


1.33.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a25 4
 * Revision 1.33  1997/06/04  10:39:32  jont
 * [Bug #30076]
 * Modifications to disturbance code to allow stack passing of procedure arguments
 *
@


1.33.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a25 4
 * Revision 1.33  1997/06/04  10:39:32  jont
 * [Bug #30076]
 * Modifications to disturbance code to allow stack passing of procedure arguments
 *
@


1.32
log
@[Bug #1412]
[Bug #1412]
Add piece of assembler to read fpu control word
for benefit of setting/getting rounding mode
@
text
@d26 6
d320 4
a323 1
 *  esp+8   f's frame
d334 5
a338 1
	lea	12(%esp), %edi		/* Calculate frame pointer */
d341 1
a341 1
	mov	-PAIRPTR(%ebp), %edi	/* g's code item */
a343 1
	mov	$STACK_DISTURB_EVENT, %edi /* frame closure tag */
d350 2
a351 1
	push	%ebp			/* g */
d354 1
a354 1
	push	%edi			/* STACK_DISTURB_EVENT */
d357 16
d382 1
a382 1
	jae	check_for_events	/* Branch if not (edx >= eax) */
a440 2
	mov	8(%esp), %eax		/* restore saved eax */
	mov	12(%esp),%edx		/* restore saved edx */
d442 23
a464 2
	mov	20(%esp),%ebx		/* restore g's argument */
	mov	24(%esp),%ecx		/* ML (g offset) */
d471 1
a471 1
	mov	8(%esp), %ecx		/* frame pointer */
d473 1
d511 4
a514 2
	mov	8(%esp), %edi		/* f's closure */
	add	$16, %esp		/* pop esp */
d520 3
a522 3
	pop	%ecx			/* discard fp */
	pop	%edi			/* restore f's closure */
	pop	%ecx			/* Throw away size requested */
d704 8
a711 1
	add	$4, %esp		/* Throw away one return address */
@


1.32.1.1
log
@branched from 1.32
@
text
@a25 6
 * Revision 1.32  1997/04/11  12:56:28  jont
 * [Bug #1412]
 * [Bug #1412]
 * Add piece of assembler to read fpu control word
 * for benefit of setting/getting rounding mode
 *
@


1.32.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a25 3
 * Revision 1.32.1.1  1997/05/12  10:43:38  hope
 * branched from 1.32
 *
@


1.32.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a25 3
 * Revision 1.32.1.1  1997/05/12  10:43:38  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a25 3
 * Revision 1.32.1.1  1997/05/12  10:43:38  hope
 * branched from 1.32
 *
@


1.32.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a25 3
 * Revision 1.32.1.1.1.1  1997/07/28  18:24:37  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.31
log
@Fix ml_disturbance "fake stack frame" behaviour.
@
text
@d26 3
d986 11
@


1.31.4.1
log
@branched from 1.31
@
text
@a25 3
 * Revision 1.31  1996/11/15  13:05:42  nickb
 * Fix ml_disturbance "fake stack frame" behaviour.
 *
@


1.31.3.1
log
@branched from 1.31
@
text
@a25 3
 * Revision 1.31  1996/11/15  13:05:42  nickb
 * Fix ml_disturbance "fake stack frame" behaviour.
 *
@


1.31.3.1.1.1
log
@branched from 1.31.3.1
@
text
@a25 3
 * Revision 1.31.3.1  1996/12/17  17:55:19  hope
 * branched from 1.31
 *
@


1.31.2.1
log
@branched from 1.31
@
text
@a25 3
 * Revision 1.31  1996/11/15  13:05:42  nickb
 * Fix ml_disturbance "fake stack frame" behaviour.
 *
@


1.31.1.1
log
@branched from 1.31
@
text
@a25 3
 * Revision 1.31  1996/11/15  13:05:42  nickb
 * Fix ml_disturbance "fake stack frame" behaviour.
 *
@


1.30
log
@OK, now let's make space profiling work.
@
text
@d26 3
d302 6
a307 4
 *  ebx  function argument
 *  ebp  function closure
 *  edi  caller's closure
 *  ecx  minimum stack requirement of function
d309 3
a311 3
 *  esp[0]  link to disturbed function
 *  esp[1]  link to caller
 *  esp+8   caller's frame
d321 1
a321 1
	push	%edi			/* Save caller's closure */
d324 17
a340 7
	mov	8(%esp), %edi		/* Get link to disturbed fn */
	mov	%ecx, 8(%esp)		/* Save frame size in that slot */

/* start another frame by saving the link register */

	push	%edi			/* Save link to disturbed function */
	mov	%ebp, %edi		/* Closure is consistent */
d347 1
a349 1
	mov	$STACK_EVENT, %ebp	/* New closure tag */
a356 1
	save_all_ML_regs		/* Push all the ML regs */
a366 1
	load_all_ML_regs		/* All ML registers as before call */
d368 1
a368 2
/* Having made a new stack block, we move our special frame off the
 * old stack block onto it. We keep the same fp. */
d370 13
a382 16
/* use eax and ebp */
	push	%eax
	mov	20(%esp), %ebp		/* Return to disturbed fn's caller */
	mov	16(%esp), %eax		/* Size of frame required */
	mov	%ebp, -4(%ecx)
	mov	%eax, -8(%ecx)
	mov	12(%esp), %ebp		/* caller's closure */
	mov	8(%esp), %eax		/* frame pointer */
	mov	%ebp, -12(%ecx)
	mov	%eax, -16(%ecx)
	mov	4(%esp), %ebp		/* Return into disturbed function */
	mov	%ebp, -20(%ecx)		/* Saved on new stack */
	pop	%eax
	mov	$STACK_EXTENSION, %ebp
	lea	-20(%ecx), %esp		/* Onto new stack */
check_for_events:
d385 4
a388 4
 * eax Callee save
 * ebx argument of disturbed function
 * ecx Junk
 * edx Callee save
d390 3
a392 3
 * edi Disturbed function closure
 * ebp Either STACK_EXTENSION or STACK_EVENT
 * esp points to return into disturbed function, in either new or old stack */
d394 1
a400 1
	save_all_ML_regs
a401 1
	load_all_ML_regs
d404 2
a405 4
 * STACK_EXTENSION or STACK_EVENT as appropriate.
 *
 * We have the address to call at TOS, and we wish to call it,
 * replacing it with the return to here at the same time. */
d408 10
a417 2
	xchg	%edi, %ebp		/* Swap round closures */
	push	0(%esp)			/* Move address down */
d420 2
a421 1
	mov	16(%esp), %ecx		/* Size requested */
d434 1
a434 1
 * ecx Junk
d437 2
a438 3
 * edi Junk
 * esp Points to fp value for caller
 * ebp Junk
d440 1
a440 1
 * We have to push a frame on the old stack containing all the
d442 5
a446 15
 * the returned value back to the caller. Note that if there has been
 * a GC, the closure in the frame on the new stack will be corrected,
 * as will the return address in the frame on the _old_ stack (since
 * it is at fp-4). */

	mov	4(%esp), %edi		/* caller's closure */
	mov	0(%esp), %ecx		/* Back to old stack */
	sub	$4, %ecx		/* make frame on old stack */
	mov	%ecx, %esp		/* holding (old stack) return addr, */
	push	%ebx			/* result and */
	push	%edx			/* caller saves */
	push	%eax
	push	%edi
	lea	20(%esp),%ecx		/* fp */
	push	%ecx
d458 3
a460 5
	add	$4, %esp
	pop	%edi			/* restore closure, */
	pop	%eax			/* saves, */
	pop	%edx
	pop	%ebx			/* and result */
d465 3
a467 2
	pop	%ecx			/* Throw away fp */
	pop	%edi			/* Restore caller's closure */
@


1.30.4.1
log
@branched from 1.30
@
text
@a25 3
 * Revision 1.30  1995/12/13  11:27:30  nickb
 * OK, now let's make space profiling work.
 *
@


1.30.4.1.1.1
log
@branched from 1.30.4.1
@
text
@a25 3
 * Revision 1.30.4.1  1996/11/14  12:59:15  hope
 * branched from 1.30
 *
@


1.30.3.1
log
@branched from 1.30
@
text
@a25 3
 * Revision 1.30  1995/12/13  11:27:30  nickb
 * OK, now let's make space profiling work.
 *
@


1.30.2.1
log
@branched from 1.30
@
text
@a25 3
 * Revision 1.30  1995/12/13  11:27:30  nickb
 * OK, now let's make space profiling work.
 *
@


1.30.1.1
log
@branched from 1.30
@
text
@a25 3
 * Revision 1.30  1995/12/13  11:27:30  nickb
 * OK, now let's make space profiling work.
 *
@


1.29
log
@Whoops; error in space profiling.
@
text
@d26 3
d841 1
a841 1
	cmp	%ecx, IMPLICIT_gc_limit(thread)
@


1.28
log
@Add space profiling hooks.
@
text
@d26 3
d849 1
a849 1
	call	ml_gc
@


1.27
log
@Additional in_ML hacking.
@
text
@d26 3
d821 1
a821 1
/* Space profiling. This is not yet implemented for the Intel */
d823 16
a838 2
	.global	C_NAME(implicit_profile_alloc_code)
	.global	C_NAME(implicit_profile_alloc_code_end)
d840 30
a869 27
C_NAME(implicit_profile_alloc_code):
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
	nop
C_NAME(implicit_profile_alloc_code_end):
	nop
@


1.26
log
@Fix in_ML setting and unsetting to allow profiling.
@
text
@d26 3
d135 2
d155 1
a155 1
	mov	%eax, GLOBAL_in_ML(%eax)	/* now in ML */
d163 1
a163 1
	movl	$0, GLOBAL_in_ML(%eax)	/* no longer in ML */
d165 1
a165 1
	add	$16, %esp		/* Pop ML frame */
d167 1
d170 1
a170 1
	mov	fnarg, %eax		/* Get result */
a185 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML
d188 1
a234 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d250 1
a250 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d253 1
d305 1
a305 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d402 1
a402 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not in ML */
d450 1
d473 1
a473 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d499 1
a499 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d537 1
d594 1
a594 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d603 1
a609 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
d614 1
a614 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d624 1
a629 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* Now in ML */
d637 1
a637 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d668 1
a668 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML
d680 1
a680 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d689 1
a689 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML	/* Not really in ML */
d710 1
a710 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
d716 1
a716 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML
d741 1
a741 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
@


1.25
log
@Clear interrupt flags when entering ev_poll.
@
text
@d26 3
a139 1
	mov	%eax, GLOBAL_in_ML(%eax)	/* now in ML */
d150 1
d158 1
a163 1
	movl	$0, GLOBAL_in_ML(%eax)	/* no longer in ML */
d180 1
a184 1
	movl	$0, C_NAME(global_state)+GLOBAL_in_ML
a194 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML
d199 1
d229 1
d233 1
d245 1
d256 1
d299 1
d392 1
d396 1
d450 1
d466 1
d473 1
d492 1
d510 1
a531 1
	movl	$1, C_NAME(global_state)+GLOBAL_in_ML	/* We are now in ML */
d586 2
d601 1
d606 1
d621 1
d629 1
d660 1
d668 1
d672 1
d677 1
d681 1
d702 1
d708 1
d733 1
@


1.24
log
@Move CURRENT_THREAD manipulation out of asm into portable C.
Also add native threads support for Win95.
@
text
@d26 4
d365 3
d455 3
a458 1
	movl	$0, IMPLICIT_interrupt(thread)
d485 3
a488 1
	movl	$0, IMPLICIT_interrupt(thread)
@


1.23
log
@Temporarily remove stack switching to aid development on Win95
@
text
@d26 3
d742 15
a756 1

d758 2
a759 5
	lea	(C_NAME(global_state)),%ecx	  /* change current thread */
	mov	4(%esp),%edx
	mov	GLOBAL_current_thread(%ecx),%eax
	mov	%edx, GLOBAL_current_thread(%ecx)

a761 7

	mov	IMPLICIT_interrupt(%eax), %ecx	  /* transfer interrupt flag */
	cmp	$0, %ecx
	je	switch_skip
	mov	%ecx, IMPLICIT_interrupt(%edx)
switch_skip:	

a765 1
/* No thread switching yet, as Win95 can't cope
a766 4
*/

/* The old thread is still in eax (the result register) so it gets returned */

d768 2
a769 1
	ret
@


1.22
log
@Restore callee-saves when unwinding past c_sp.
@
text
@d26 3
d759 1
d761 1
@


1.21
log
@Change to c_sp protocol.
@
text
@d26 3
d400 2
a401 2
	push	%eax			/* caller saves */
	push	%edx
d418 2
a419 2
	pop	%edx			/* saves, */
	pop	%eax
d675 1
a675 1
	lea	20(%esp),%ecx		/*		  fp */
@


1.20
log
@Interception/replacement.
@
text
@d26 3
d125 2
a126 2
	mov	THREAD_c_esp(%esi), %edi /* Old c_state.sp */
	mov	%esp, THREAD_c_esp(%esi) /* Remember C sp for calls to C */
d131 1
a132 1
	pushl	$0			/* Dummy link here */
d142 1
d145 2
a146 1
	mov	THREAD_c_esp(thread), %esp	/* Reset to C stack */
d166 1
a166 1
	mov	THREAD_c_esp(thread), %esp /* %sp = c_sp */
a181 1
	mov	%esp, THREAD_c_esp(thread) /* resave c_sp */
d229 1
a229 1
	mov	THREAD_c_esp(thread), %esp /* Onto c stack */
@


1.19
log
@Fix stack extension and various other things.
@
text
@d26 3
a608 7
 *  Parameters:
 *    %ebx	parameter } of intercepted function
 *    %ebp	closure   }
 *    esp[0]	continuation address
 *    esp[1]    return address
 *    esp+2     caller's frame
 *
d615 9
a623 1
/* this is a first cut, nickb 1995-08-31 */
d625 1
a625 1
C_NAME(ml_replace):
d628 1
a628 1
	ML_to_C(replace)
a629 1
	add	$4, %esp
d633 13
a645 4
	call	C_NAME(ml_replace_leaf_die)
#if 0
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%sp, %o0		! Pass frame to replace()
d647 7
a653 3
	ret				! Return to function caller
	restore				! Throw away dummy frame
#endif
d655 1
a655 10
C_NAME(ml_intercept):
	call	C_NAME(ml_intercept_die)
#if 0
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(intercept)
	ret				! Return to intercepted code
	restore
#endif
d658 25
a682 12
	call	C_NAME(ml_intercept_leaf_die)
#if 0
	save	%sp, -0x40, %sp		! Dummy frame for function
	mov	%g4, %o7		! Pretend it called here
	save	%sp, -0x40, %sp		! Local frame
	mov	STACK_INTERCEPT, %i1	! Mark it
	mov	%fp, %o0		! Pass frame to intercept()
	ML_to_C(intercept)
	restore
	jmpl	%o7+8, %g0		! Back to caller...
	restore				! ...removing its frame
#endif
@


1.18
log
@Add dummy sequences for space profiling.
@
text
@d9 3
a11 2
 * This code does the job of managing the calls between ML and C.  The ML
 * and C states are stored in C structures declared in `state.c'.
d21 1
a21 2
 * This file must be run through both CPP and the m4 macro processor to
 * produce an assembler file. 
d26 3
a91 1
#define NEW_HANDLERS 1
a110 1

a135 1

d143 1
d150 1
a150 2
 * does not.
 */
d160 2
d169 1
d171 1
d174 1
a174 1
	mov	%esp, THREAD_c_esp(thread) /* c_sp = %sp */
d279 1
a279 1
/* Now we save a few more things on the stack to give us more breathing room */
a281 2
	push	%eax			/* Save registers */
	push	%edx
d288 3
a290 4
	mov	%esp, %edx
	mov	IMPLICIT_stack_limit(thread), %eax	/* get true stack limit */
	sub	%ecx, %edx		/* Calculate required new sp */
	cmp	%eax, %edx		/* See if stack extension needed */
d294 2
a295 4
/*
 * We need a stack extension
 */
	save_all_ML_regs		/* Push all the ML regs */
d297 1
a297 1
	incl	C_NAME(stack_extension_count)	/* Increment stack extension count */
d299 2
d302 1
a302 1
					/* Arg 0 = current stack */
d304 1
a304 1
					/* Arg1 = requested amount */
d306 2
a307 4
	lea	(STACK_BUFFER+DEFAULT_STACK_SIZE)(%ebx), %ecx
					/* Calculate new stack limit */
	mov	%ecx, IMPLICIT_stack_limit(thread)
					/* Store it away */
a308 1
					/* Also set up new copy for use of ML code */
d310 1
a310 1
	load_all_ML_regs		/* All ML registers back as before call */
d313 15
a327 14
 * old stack block onto it. We keep the same fp. The instructions
 * here have to be carefully ordered to satisfy the profiler */
/* Last part probably not true yet as the Intel rts has no profiler */

/* Two spare registers here, eax and edx */
	mov	24(%esp), %eax		/* Return to disturbed function's caller */
	mov	20(%esp), %edx		/* Size of frame required */
	mov	%eax, -4(%ecx)
	mov	%edx, -8(%ecx)
	mov	12(%esp), %eax
	mov	16(%esp), %edx
	mov	%eax, -16(%ecx)		/* Frame pointer */
	mov	%edx, -12(%ecx)		/* Copy caller's closure register */
	mov	8(%esp), %eax		/* Return into disturbed function */
a328 3
	mov	%eax, -20(%ecx)		/* Saved on new stack */
	pop	%edx
	pop	%eax			/* Pop two relevant registers */
a329 1
	jmp	check_for_events_common
d331 1
a331 5
	pop	%edx
	pop	%eax
check_for_events_common:
/*
 * Now we test for events. We get here by one of two routes (depending
d334 1
a334 1
 * ebx (argument of disturbed function)
d340 1
a340 5
 * esp If we've extended the stack, points to return into disturbed function
 *     in new stack
 *     If we've not extended the stack, points to return into disturbed function
 *     in existing frame
 */
d349 3
a351 4
/*
 * We need to call the disturbed function with caller's closure set to
 * STACK_EXTENSION or STACK_EVENT as appropriate
 * This is nasty.
d353 2
a354 7
 * replacing it with the return to here at the same time.
 * Method:
 * Move this address one place down the stack
 * Place the return address to here where the address was originally
 * Reload ecx as appropriate
 * Return
 */
d361 1
a361 1
	ret				/* Call the rest of the disturbed function */
d377 1
d380 15
a394 7
 * the returned value back to the caller.
 */
	mov	0(%esp), %esp		/* Back to old stack */
	sub	$16, %esp		/* Don't trample on dummy frame */
	push	%ebx			/* Save result */
	push	%eax
	push	%edx			/* Save callee saves */
d396 2
a397 2
					/* Stack limit of stack to be discarded */
	sub	$(STACK_BUFFER+DEFAULT_STACK_SIZE), %ebx
d401 2
a402 5
					/* Calculate new limit */
	mov	fnarg, IMPLICIT_stack_limit(thread)
					/* Save away */
	or	IMPLICIT_interrupt(thread), fnarg
					/* Get potential interrupt status */
d404 8
a411 5
					/* This is what function entry uses */
	pop	%edx			
	pop	%eax			/* Callee saves */
	pop	%ebx			/* Result from disturbed function */

a419 4
 * Event checking not yet implemented, simply return
 */

/*
d445 1
a445 1
 * 0(esp) return address to polling function
d466 4
a469 1
	ret	$8		/* return, junking 8 bytes */
d483 2
a484 1
	mov	C_NAME(global_state)+GLOBAL_current_thread, thread	/* get current thread pointer */
d487 3
a489 5
	mov	THREAD_ml_sp(thread), %esp		/* Restore ml_state.sp */
/*
 * Clean caller save register
 */
	xor	%ebp, %ebp
d493 1
a493 2
/*
 * At this point, the return address from whatever called C is at
d528 2
a529 1
 *   0(ESP)		Return address for resumption (not used at present, and not true for leaf)
a545 1
#if NEW_HANDLERS
a555 22
#else
	mov	IMPLICIT_handler(thread), %ebp
	mov	7(%ebp), %ebp		/* Get handler closure */
	number_of_saves(%edi, %ecx)
	add	$4, %ecx		/* Add two for this part of the frame */
	push	%eax
	push	%edx			/* and two for these registers */
	mov	%ecx, %ebp
	copy_down(%ecx, %eax, %edx)	/* Copy down callee saves and linkage */
	shl	$2, %ebp		/* size * 4 */
	add	%esp, %ebp		/* Point to where to save old handler */
/*
 * Some stuff to do with sorting out sp values in handlers needed here
 * Or maybe not...
 */
	mov	IMPLICIT_handler(thread), %ecx
	mov	%ecx, 0(%ebp)		/* Store away old handler pointer */
	mov	IMPLICIT_handler(thread), %ecx
	mov	7(%ecx), %ebp		/* Closure of handling function */
	mov	-1(%ecx), %eax		/* Previous handler */
	mov	%eax, IMPLICIT_handler(thread)	/* Install it */
#endif
a557 5
#if NEW_HANDLERS
#else
	pop	%edx
	pop	%eax			/* Straighten the stack */
#endif
a558 1
#if NEW_HANDLERS
d564 1
a564 1
	pop	%ecx			/* Current handler frame for wind back */
a568 21
#else
	mov	IMPLICIT_handler(thread), %ebp
	mov	7(%ebp), %ebp		/* Get handler closure */
	mov	-1(%edi), %ecx		/* Get code vector */
	mov	-1(%ecx), %ecx		/* Get ancillary word from it */
	shr	$CCODE_SAVES_SHIFT, %ecx	/* Move required part down */
	and	$CCODE_MAX_SAVES, %ecx	/* Find number of callee saves */
	add	$4, %ecx		/* Add two for this part of the frame */
	push	%eax
	push	%edx			/* and two for these registers */
	mov	%ecx, %ebp
	shl	$2, %ebp		/* size * 4 */
	add	%esp, %ebp		/* Point to where old handler was saved */
	mov	0(%ebp), %eax		/* Get previous handler */
	mov	%eax, IMPLICIT_handler(thread)	/* And make it the current one */
	mov	%eax, %ebp		/* Remember current handler */
	copy_up(%ecx, %eax, %edx)	/* Copy up callee saves and frame */
	pop	%edx
	pop	%eax
	mov	3(%ebp), %ecx		/* sp of creator function */
#endif
d570 1
a570 1
	unwind_stack(raise)		/* Wind back to that frame, propagating result */
d572 2
a573 2
	mov	11(%ebp), %ecx		/* Fetch the offset of the continuation... */
	shr	$2, %ecx		/* Convert from tagged representation */
a582 3
/* New code for stack extending when needed for leaf raise */
/* If we leave this out, we get a raise apparently from the calling procedure */
/* This seems ok */
a584 25
#if 0

	sub	%sp, STACK_BUFFER+0x40, %g4	! Extension needed test
	cmp	%g4, %g6		! The test
	bcc	C_NAME(ml_raise)	! Branch if ok
	ld	[%g5+IMPLICIT_extend], %g4
	jmpl	%g4, %g4		! Extend stack
	mov	STACK_BUFFER+0x40, %g7	! Required size
	save	%sp, -0x40, %sp		! New frame on new stack
	mov	%i0, %o0		! Argument to raise
	ba	C_NAME(ml_raise)	! And as before (note handler continuation
	mov	STACK_RAISE, %i1	! will unwind the stack extension)
#endif

/* === CAUSE A FATAL ERROR ===
 *
 * Expects an error format string to follow the call instruction and
 * delay slot.
 */

#if 0
error:	add	%o7, 8, %o0
	ML_to_C(error)
	ta	1
#endif
d591 1
a591 1
 * three nop operations which can be replaced with code to intercept or
d594 2
a595 2
 *
 *  ml_intercept (ml_intercept_leaf) is jumped to by the instructions
d597 3
a599 3
 * `intercept_on' below).  It calls the C function `intercept', passing
 * its parameter and closure (see intercept.c).  When `intercept'
 * returns, the intercepted function is continued.
d604 1
a604 1
 * These four routines all live on the implicit vector.
d607 5
a611 4
 *    %o0	parameter } of intercepted function
 *    %o1	closure   }
 *
 * Return address is in %o7, or %g4 for leaf versions.
d619 2
d622 2
a623 3
	call	C_NAME(ml_replace_die)
#if 0
	mov	%sp, %o0		! Pass frame to replace()
d625 2
a627 2
	restore				! Pop callers frame
#endif
d668 1
a668 1
 * INTERCEPT_LENGTH words long (from tags.h); three in the SPARC case.
d685 1
a685 6
	call	C_NAME(ml_replace_on_die)
#if 0
	ld	[%g5+IMPLICIT_replace], %g4
	jmpl	%g4, %o7
	nop
#endif
d688 1
a688 6
	call	C_NAME(ml_replace_on_leaf_die)
#if 0
	ld	[%g5+IMPLICIT_replace_leaf], %g4
	jmpl	%g4, %g4
	nop
#endif
d691 1
a691 6
	call	C_NAME(ml_intercept_on_die)
#if 0
	ld	[%g5+IMPLICIT_intercept], %g4
	jmpl	%g4, %o7
	nop
#endif
d694 1
a694 6
	call	C_NAME(ml_intercept_on_leaf_die)
#if 0
	ld	[%g5+IMPLICIT_intercept_leaf], %g4
	jmpl	%g4, %g4
	nop
#endif
d697 3
a699 6
	call	C_NAME(ml_nop_die)
#if 0
	sethi	0, %g0		! These nops are used in mach_cg so that
	sethi	0, %g0		! the scheduler does not move them.
	sethi	0, %g0
#endif
d733 2
a734 1
	call	%ecx
d736 1
a736 1
/* Space profiling. This is not yet implemented for the MIPS. */
a867 3
	.global	C_NAME(stat)
C_NAME(stat):
	jmp	__stat
@


1.17
log
@Event polling code
Also modify raise code to remove stack copying down and up in favour of
a small extra frame.
@
text
@d26 5
d845 34
a878 1
	
@


1.16
log
@Improvements to stack overflow and event handling
Also fixed some bugs in handling exceptions raised in C
@
text
@d26 4
d84 1
d363 5
d371 5
a375 5
#if 0	/* Can't afford this */
	mov	12(%esp), %ecx		/* Size requested */
#endif
	pop	%ecx			/* Where to call */
	call	%ecx			/* Off we go */
a426 7
#if 0

/* == Poll asynchronous events ==
 *
 * If a function has been disturbed by having %g6 = -1 then poll the
 * event handler.
 */
a427 20
event_poll:
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	st	%g0, [%g5+IMPLICIT_interrupt] ! Clear the interrupt flag
	sub	%sp, %g7, %g4		! Does the stack really need extending?
	cmp	%g4, %g6
	bgeu	int1
	sethi	%hi(C_NAME(ml_disturbance)), %o4
	or	%o4, %lo(C_NAME(ml_disturbance)), %o4
	jmpl	%o4, %o4		! Really extend the stack
	nop
int1:	save	%sp, -0x40, %sp		! NB %i7 contains disturbed function continuation
	mov	STACK_EVENT, %i1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
	ML_to_C(ev_poll)
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	restore

d431 2
a432 1
 * We arrive here when g6 has been detected to be -1
d435 3
a437 2
 * %o7 return address
 * %i1 function closure
a438 1
#endif
d441 2
a442 8
	call	C_NAME(ml_event_check_die)
#if 0
	save	%sp, -0x40, %sp		! Create extra frame
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	mov	STACK_EVENT, %i1
	mov	0, %o7			! Ensure o7 not mistaken for a return to ML
d444 3
a446 4
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	nop
#endif
d448 8
a455 3
 * %o1 function closure
 * %o7 function return address
 * %g4 return address from here
d457 1
d460 11
a470 12
	call	C_NAME(ml_event_check_leaf_die)
#if 0
	save	%sp, -0x40, %sp		! Create a frame, so %i1 = function closure
	mov	%g4, %o7		! Save return address

/* Poll code */

	save	%sp, -0x40, %sp		! Create extra frame
	sethi	%hi(C_NAME(ml_state)), %o0
	or	%o0, %lo(C_NAME(ml_state)), %o0
	ld	[%o0+16], %g6		! Restore the real stack in %g6
	mov	STACK_EVENT, %i1
d472 4
a475 4
	restore
	jmp	%o7+8			! Do the rest of the disturbed function
	restore
#endif
a488 3
#if 0
	lea	C_NAME(global_state), %ecx	/* Point to global state */
#endif
d553 12
d581 1
d585 1
d588 2
d592 1
d594 12
d625 1
d627 1
a627 1
	unwind_stack(raise)		/*  Wind back to that frame, propagating result */
@


1.15
log
@Add stack extension code
@
text
@d26 3
a348 1
	mov	%ebp, %edi		/* Set our closure */
d507 4
a510 2
	lea	C_NAME(global_state), thread	/* Point to global state */
	mov	GLOBAL_current_thread(thread), thread	/* get current thread pointer */
d518 2
a519 1
	push	%ebp			/* Dummy element on frame */
d521 4
@


1.14
log
@Fix c_raise to work with thread system
@
text
@d26 3
d258 1
a258 1
	push 	%edi			/* save frame pointer */
a271 2
	call C_NAME(ml_disturbance_die)
#if 0
d273 67
a339 15
	cmp	$1, 
	save	%sp, -0x40, %sp
	mov	%g4, %o7		/* So gc can fix return link */
	addcc	%g6, 1, %g0		/* Is %g6 -1? (events pending) */
	beq,a	event_poll
	nop
	/* \/\/ fall through \/\/ */

/* == Extend ML stack ==
 *
 * If a function is disturbed by lack of stack this code allocates a
 * new stack area by calling make_stack() in the storage manager and
 * linking to the new stack using a special stack frame.  It then calls
 * the remainder of the disturbed function, deallocating the stack on
 * its return.
d342 19
a360 3
extend_stack:
#ifdef COLLECT_STATS
	incl	C_NAME(stack_extension_count)
d362 48
a409 35
	add	%g7, STACK_BUFFER+DEFAULT_STACK_SIZE, %o1
				! Minimum stack requirement is second arg
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
				! Current stack area is first arg
	ML_to_C(make_stack)		! Allocate a new stack area
	sethi	%hi(C_NAME(ml_state)), %o2
	or	%o2, %lo(C_NAME(ml_state)), %o2
	ld	[%o0+0x4], %g4		! Get top of new stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%o2+16]		! Install the new stack in ml_state
	addcc	%g6, 1, %g0		! Was there an event while in C?
	bne,a	ext0
	mov	%o0, %g6		! Install the new stack in %g6
ext0:	restore	
	save	%g4, -0x40, %sp		! Link to new stack
	mov	%i0, %o0		! Propagate arguments
	mov	%i1, %o1
	mov	%i2, %o2
	mov	%i3, %o3
	mov	%i4, %o4
	mov	%i5, %o5
	jmpl	%o7+8, %o7		! Call rest of disturbed function
	mov	STACK_EXTENSION, %i1	! (Mark the extra frame)
	! \/\/ fall through \/\/

extend_return:
	mov	%o0, %i0		! Propagate result to caller
	restore				! Restore back to the old stack, since it is about to disappear
	save	%sp, -0x40, %sp		! Make a frame on the old stack
	addcc	%g6, 1, %g0		! Is an event flagged?
	beq,a	ext1
	sethi	%hi(C_NAME(ml_state)), %o2
	sub	%g6, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	ML_to_C(unmake_stack)		! Deallocate the stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %g6
d411 5
a415 8
	restore
ext1:	or	%o2, %lo(C_NAME(ml_state)), %o2
	ld	[%o2+16], %o0		! (Fetch real stack from _ml_state.)
	ML_to_C(unmake_stack)		! Deallocate the stack
	add	%o0, STACK_BUFFER+DEFAULT_STACK_SIZE, %o0
	st	%o0, [%o2+16]		! Update _ml_state with older stack
	ret
	restore				! Return to functions caller
@


1.13
log
@Modify comments on c_raise
@
text
@d26 3
d426 2
d430 1
a430 1
	mov	24(%ecx), %esp		/* Restore ml_state.sp */
@


1.12
log
@Add threads system.
@
text
@d26 3
d420 1
a420 1
 * Raise argument is at -4(ESP)
@


1.11
log
@Add stuff to make it work with gcc
@
text
@d26 3
a72 8
 * The C global registers are stored in the structure c_state, and the
 * ML global state is loaded.  A new ML stack frame is allocated below
 * the base pointer of the current ML stack area (pointed to by %g6).
 * The ML function is then called.  On return the stack area base
 * pointer is restored to its calue on entry, the ML state is stored
 * and the C state loaded, then control returns to C.
 *
 *
d89 1
d91 9
a99 8
	address_C_globals(c_state, %eax)
	mov	28(%eax), %edi		/* Old c_state.sp */
	mov	%esp, 28(%eax)		/* Remember C stack ptr for calls to C */
	mov	%edi, %eax		/* EDI will be overwritten by load_ML_state */
	mov	20(%esp), fnarg		/* Get arg to callml */
	mov	24(%esp), %ebp
	load_ML_state(ml_state, %ecx, %edx)
	mov	24(%ecx), %esp		/* saved ml_state.sp */
d101 2
a102 2
	mov	%esp, %ecx		/* Remember current esp */
	push	%eax			/* Save old c_state.sp */
d105 1
a105 6
	push	%ecx			/* Link fp */
	clean_current_registers
/*
	Assume that we are calling a closure so there is only
	one argument to propagate.
*/
d110 8
a117 7
	add	$12, %esp		/* Pop ml_frame */
	pop	%edi			/* Previous c_state.sp */
	store_ML_state(ml_state, %ecx, %edx, callml)
	mov	%esp, 24(%ecx)
	address_C_globals(c_state, %eax)
	mov	28(%eax), %esp		/* Reset to C stack */
	mov	%edi, 28(%eax)		/* Restore old c_state.sp */
d135 2
a136 9
	store_ML_state(ml_state, %ecx, %edx, stub_c)
	mov	%esp, 24(%ecx)		/* Save last ML frame for GC */
	address_C_globals(c_state, %eax)
#if 0
	std	%f0, [%sp+0x58]		/* Preserve non-corrupted floats */
	std	%f2, [%sp+0x60]
	std	%f6, [%sp+0x70]
#endif
	mov	28(%eax), %esp		/* address of last C stack frame */
d146 4
a149 7
#if 0
	ldd	[%sp+0x70], %f6
	ldd	[%sp+0x60], %f2
	ldd	[%sp+0x58], %f0
#endif
	load_ML_state(ml_state, %ecx, %edx)
	mov	24(%ecx), %esp		/* Point back to ml frame */
d152 1
a153 1
C_NAME(text_internal_stub_c_end):
d195 2
a196 4
	store_ML_state(ml_state, %eax, %edx, ml_gc)
	mov	%esp, 24(%eax)		/* Save last frame for gc */
	address_C_globals(c_state, %eax)
	mov	28(%eax), %esp		/* Onto c stack */
d199 4
a202 10
#if 0
	store_fps(%sp+88)
#endif
	call	C_NAME(gc)		/* Call garabage collector */
#if 0
	load_fps(%sp+88)
#endif
	load_ML_state(ml_state, %ecx, %edx)	/* Answer in ml_state.temp */
	mov	24(%ecx), %esp		/* Point back to ml frame */
	mov	8(%ecx), %ecx		/* Answer in correct place */
d206 2
a210 12
#if 0
	mov	%o1, %o0
#endif
/*
 * gc called from leaf function, a rarity for the intel.
 *
 * Stack stack is:-
 * 0(ESP) return address to leaf function
 * 4(ESP) return address from leaf function
 * 8(ESP) frame pointer for caller of leaf function
 *
 */
d225 1
a225 1
 * This code is called by ML when %sp-STACK_BUFFER < %g6 (unsigned).
d231 4
a234 4
 *  %o0  function argument
 *  %o1  function closure
 *  %o2 - %o5 rest of arguments
 *  %g7  minimum stack requirement of function
d236 3
a238 4
 *       (these are added in here)
 *  %g4  link to continue function
 *  %o7  link to functions caller
 *  %g6  current stack area or -1 for asynchronous event
d243 21
a263 1
	call	C_NAME(ml_disturbance_die)
d265 2
d285 1
a285 5
	sethi	%hi(C_NAME(stack_extension_count)), %o0
	or	%o0, %lo(C_NAME(stack_extension_count)), %o0
	ld	[%o0], %g4
	add	%g4, 1, %g4
	st	%g4, [%o0]
a356 1
#endif
d367 1
d420 1
a420 1
	load_ML_state(ml_state, %ecx, %edx)
d460 1
a460 1
 *   implicit		Implicit vector
d462 1
a462 1
 *   64(implicit)	Exception handler record
a473 1
#if 0
d475 1
a475 5
	sethi	%hi(C_NAME(raise_count)), %o1
	or	%o1, %lo(C_NAME(raise_count)), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
a476 1
#endif
d478 1
a478 1
	mov	IMPLICIT_handler(implicit), %ebp
d480 1
a480 4
	mov	-1(%edi), %ecx		/* Get code vector */
	mov	-1(%ecx), %ecx		/* Get ancillary word from it */
	shr	$CCODE_SAVES_SHIFT, %ecx	/* Move required part down */
	and	$CCODE_MAX_SAVES, %ecx	/* Find number of callee saves */
d492 1
a492 1
	mov	IMPLICIT_handler(implicit), %ecx
d496 1
a496 1
	mov	%eax, IMPLICIT_handler(implicit)	/* Install it */
d502 1
a502 1
	mov	IMPLICIT_handler(implicit), %ebp
d515 1
a515 1
	mov	%eax, IMPLICIT_handler(implicit)	/* And make it the current one */
d523 1
a523 1
	mov	IMPLICIT_handler(implicit), %ebp
a530 1
#if 0
d532 1
a532 6
	sethi	%hi(C_NAME(raise_count)), %o1
	or	%o1, %lo(C_NAME(raise_count)), %o1
	ld	[%o1], %g4
	add	%g4, 1, %g4
	st	%g4, [%o1]
#endif
d707 1
a707 5
	nop
#if 0
	ta	1
	nop
#endif
d709 1
a709 1
/* == GARBAGE COLLECTION ENTRY POINTS ==
d711 20
a730 4
 * When a garbage collection is required, we cause a trap. See
 * signals.c for the trap handler, which sets up some state on the C
 * side before 'returning' to either gc_trap_entry or
 * gc_trap_entry_leaf:
d732 1
a732 2
	gc_trap_return_address now contains the address to which we
		should return after the GC.
d734 1
a734 70
	gc_trap_ret_code points to code which tags the destination
		register and returns (see gc_trap_ret_template, below).

	gc_trap_bytes contains the number of bytes requested, or -1 if
		the number is in register g4.

 * The allocation attempt has not yet modified any registers.

 * We have to fake an entry to the portable function gc(), the
 * arguments being the number of bytes requested and the closure of
 * the calling function. On entry to gc(), ml_state.heap_start should
 * point to the current allocation point plus the number of requested
 * bytes.
*/

#if 0
	.global C_NAME(gc_trap_entry)

C_NAME(gc_trap_entry):
	call	C_NAME(gc_trap_entry_die)
#if 0

	mov	%i1, %g1			/* save closure */
	save	%sp, -64, %sp			/* make ML stack frame */

/* get return address into i7 so the stack frame looks normal */

	mov	%i7, %l0			/* Preserve link reg in l0 */
	sethi	%hi(C_NAME(gc_trap_return_address)), %o0
	or	%o0, %lo(C_NAME(gc_trap_return_address)), %o0
	ld	[%o0],%i7

/* get number of bytes requested */

	sethi	%hi(C_NAME(gc_trap_bytes)), %o0
	or	%o0, %lo(C_NAME(gc_trap_bytes)), %o0
	ld	[%o0], %o0			/* get 'bytes requested' */
	addcc	%o0, 1, %g0			/* is it -1? */
	beq,a	got_bytes
	mov	%g4, %o0			/* if so, use %g4 instead */
got_bytes:
	add	%g2, %o0, %g2			/* add to GC_HEAP_START */
	mov	%g1, %o1			/* get closure back */

	store_ML_state(ml_state,%o2)		/* save ML state */
	st	%sp, [%o2 + 28]			/* Save last ML frame for GC */
	st	%sp, [%o2 + 32]			/* Save base of ML stack */

	address_C_globals(c_state,%o3)		/* load C state */
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp			/* Switch to C stack */
	store_fps(%sp+88)			/* save FP registers */
	mov	%i0, %o0			/* number of bytes */
	call	C_NAME(gc)			/* call GC ... */
	mov	%i1, %o1			/* with closure */

/* On exit from gc(), ml_state.heap_start and ml_state.heap_limit have
 * been updated to reflect the new creation space, and ml_state.global
 * contains the address at which bytes have been allocated. */

/* We now have a tricky sequence, split between here and
 * gc_trap_ret_template (below). WE need to enter that code with one
 * restore still to do and with g1, g2, and g4 set in particular ways:
*/

	load_fps(%sp+88)
	address_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	mov	%o3, %g2			/* address of ml_state in g2 */
	restore
d736 9
a744 138
/* The template for the return code has been copied to
 * *gc_trap_ret_code */

	sethi	%hi(C_NAME(gc_trap_ret_code)), %g1
	or	%g1, %lo(C_NAME(gc_trap_ret_code)), %g1
	ld	[%g1], %g1			/* code address in g1 */
	mov	%i7, %g4			/* return address in g4 */
	jmpl	%g1, %g0
	mov	%l0, %i7			/* restore link register */
#endif

/* -------- end of gc_trap_entry ----------- */

/* Code to return to ML after a GC. Note that this code is copied into
  the data segment and the instruction at gc_trap_ret_template_overwrite
  is overwritten with a result-tagging instruction. This code is
  called from gc_trap_entry, above.

  We enter this code with
	%g4 = the return address,
	%g2 = ml_state
	%g1 = this code

  We need to get the GC return value from the ml_state into g1, do a
  restore, do the tagging operation, load g1 and g2 from the ml_state,
  and return to g4. This sequence is carefully chosen to make sure we
  get back to ML with all the registers correctly set (except g4).
  */
	.global C_NAME(gc_trap_ret_template)
	.global C_NAME(gc_trap_ret_template_end)
	.global C_NAME(gc_trap_ret_template_overwrite)

C_NAME(gc_trap_ret_template):
	call	C_NAME(gc_trap_ret_template_die)
#if 0
	ld	[%g2+8], %g1
	restore
#endif
C_NAME(gc_trap_ret_template_overwrite):
	call	C_NAME(gc_trap_ret_template_overwrite_die)
#if 0
	nop			/* this instr to be overwritten */
	ret
	ld	[%g2+24],%g1
	ld	[%g2],%g2	
	jmpl	%g4+8, %g0
	clean_windows
#endif
C_NAME(gc_trap_ret_template_end):
	call	C_NAME(gc_trap_ret_template_end_die)
#if 0
	nop
#endif

/* gc_trap_entry_leaf is almost identical to gc_trap_entry
  (above). This is entered on return from the trap handler after an
  allocation trap in a leaf function. */

	.global C_NAME(gc_trap_entry_leaf)

C_NAME(gc_trap_entry_leaf):
	call	C_NAME(gc_trap_entry_leaf_die)
#if 0

	save	%sp, -64, %sp			/* make ML stack frame */
	mov	%i1, %o1			/* save closure */

/* get return address into o7 so the stack frame looks normal */

	sethi	%hi(C_NAME(gc_trap_return_address)), %o0
	or	%o0, %lo(C_NAME(gc_trap_return_address)), %o0
	ld	[%o0],%o7

/* get number of bytes requested */

	sethi	%hi(C_NAME(gc_trap_bytes)), %o0
	or	%o0, %lo(C_NAME(gc_trap_bytes)), %o0
	ld	[%o0], %o0			/* get 'bytes requested' */
	addcc	%o0, 1, %g0			/* is it -1? */
	beq,a	leaf_got_bytes
	mov	%g4, %o0			/* if so, use %g4 instead */
leaf_got_bytes:
	add	%g2, %o0, %g2			/* add to GC_HEAP_START */
	add	%g1, %o0, %g1			/* add to GC_HEAP_LIMIT */

	store_ML_state(ml_state,%o2)		/* save ML state */
	st	%sp, [%o2 + 32]			/* Save base of ML stack */

	address_C_globals(c_state,%o3)		/* load C state */
	ld	[%o3 + 28], %o4
	save	%o4, -216, %sp			/* Switch to C stack */
	st	%sp, [%i2 + 28]			/* Save last ML frame for GC */
	store_fps(%sp+88)			/* save FP registers */
	mov	%i0, %o0			/* number of bytes */
	call	C_NAME(gc)			/* call GC ... */
	mov	%i1, %o1			/* with closure */
	load_fps(%sp+88)
	address_C_globals(c_state, %o2)
	load_ML_state(ml_state, %o3, %o4)
	mov	%o3, %g2			/* address of ml_state in g2 */
	restore
	
	sethi	%hi(C_NAME(gc_trap_ret_leaf_code)), %g1
	or	%g1, %lo(C_NAME(gc_trap_ret_leaf_code)), %g1
	ld	[%g1], %g1			/* code address in g1 */
	jmpl	%g1, %g0
	mov	%o7, %g4			/* return address in g4 */
#endif

/* Code to return to an ML leaf procedure after GC. As for
  gc_trap_ret_template (above). Actually these two routines are
  identical now; they are distinct in case we want to change one of
  them later. */

	.global C_NAME(gc_trap_ret_leaf_template)
	.global C_NAME(gc_trap_ret_leaf_template_end)
	.global C_NAME(gc_trap_ret_leaf_template_overwrite)

C_NAME(gc_trap_ret_leaf_template):
	call	C_NAME(gc_trap_ret_leaf_template_die)
#if 0
	ld	[%g2+8], %g1
	restore
#endif
C_NAME(gc_trap_ret_leaf_template_overwrite):
	call	C_NAME(gc_trap_ret_leaf_template_overwrite_die)
#if 0
	nop			/* this instr to be overwritten */
	ld	[%g2+24],%g1
	ld	[%g2],%g2	
	jmpl	%g4+8, %g0
	clean_windows
#endif
C_NAME(gc_trap_ret_leaf_template_end):
	call	C_NAME(gc_trap_ret_leaf_template_end_die)
#if 0
	nop
#endif
@


1.10
log
@Modification of stub values for windows NT
@
text
@d26 3
d965 96
@


1.9
log
@Remove set_stack_underflow.
@
text
@d26 3
d149 5
d155 1
d172 5
d178 1
@


1.8
log
@Modify to new register assignment
@
text
@d26 3
d231 2
a232 2
 * This routine simply invokes the window flushing trap.  It is here so
 * that C can do it neatly.
a233 1

a237 19

/* === CAUSE A CALL TO EVENT POLL ===
 *
 * This routine is called from the asynchronous event handler in order
 * to cause ML to call the event poll routine at the next opportinuty.
 * It does this by modifying the value of %g6 (the stack limit
 * register) to -1.  IT ONLY WORKS IF CALLED DIRECTLY FROM A SIGNAL
 * HANDLER.  Ack gag barf.
 */

	.global C_NAME(set_stack_underflow)

C_NAME(set_stack_underflow):
	call	C_NAME(set_stack_underflow_die)
#if 0
	xnor	%g0, %g0, %o0
	retl
	st	%o0, [%fp+0xf8]		/* Blech!  Blat %g6 with -1. */
#endif
@


1.7
log
@Fix problem with old c_state.sp being corrupted during callml
@
text
@d26 3
d70 1
a71 1
 *   8(ESP)	Closure of the function to call
d75 1
d85 1
a85 3
	push	%ebp
	push	%esi
	push	%edi
d90 2
a91 2
	mov	16(%esp), %esi		/* Get arg to callml */
	mov	20(%esp), %ebp
d116 2
a117 4
	mov	%esi, %eax		/* Get result */
	pop	%edi
	pop	%esi
	pop	%ebp
d142 1
a142 1
	push	%esi			/* Stack argument */
d144 1
a144 1
	mov	%eax, %esi		/* Get the answer */
d438 1
a438 1
	mov	4(%esp), %esi		/* Place exception argument in ESI */
d475 5
a479 5
 *   ESI	The exception packet to raise
 *   EDI	Current function's closure
 *   EBX	Implicit vector
 *   0(ESP)	Return address for resumption (not used at present, and not true for leaf)
 *   64(EBX)	Exception handler record
d501 1
a501 1
	mov	IMPLICIT_handler(%ebx), %ebp
d518 1
a518 1
	mov	IMPLICIT_handler(%ebx), %ecx
d522 1
a522 1
	mov	%eax, IMPLICIT_handler(%ebx)	/* Install it */
d528 1
a528 1
	mov	IMPLICIT_handler(%ebx), %ebp
d541 1
a541 1
	mov	%eax, IMPLICIT_handler(%ebx)	/* And make it the current one */
d549 1
a549 1
	mov	IMPLICIT_handler(%ebx), %ebp
@


1.6
log
@Add ml_raise_leaf
Intended to add ml_gc_leaf, but this may not be necessary
@
text
@d26 4
d87 1
d94 1
a94 1
	push	%edi			/* Save old c_state.sp */
@


1.5
log
@Add code for C_raise
@
text
@d26 3
a208 1
	call	C_NAME(ml_gc_leaf_die)
d211 9
a551 1
	call	C_NAME(ml_raise_leaf_die)
d560 1
d563 5
@


1.4
log
@Add code for non-leaf raise
@
text
@d3 1
a3 1
 *		SPARC
d5 1
a5 1
 * Copyright (C) 1991 Harlequin Ltd
d26 3
d126 1
a126 2
	lea	4(%esp), %edx		/* Last fp address */
	mov	%edx, 24(%ecx)		/* Save last ML frame for GC */
d143 1
a143 3
	mov	24(%ecx), %edx		/* Point back to ml frame */
	lea	-4(%edx), %esp		/* Note, we need not throw away the C arg */
					/* as we've swapped back to the ml stack */
d417 2
a418 9
 * This used to store the globals in c_state using %o2:
 *	st	%sp, [%o2 + 28]		! Remember C stack ptr for calls to C
 * But that extends the unix stack in an unlimited fashion,
 * and is unnecessary.
 *
 * Now we must wind back the c stack explicitly to avoid the ml stack
 * threading back through a bit of C stack we have thrown away and
 * then reused.
 *
d421 9
a429 17
	call	C_NAME(c_raise_die)
#if 0
	load_ML_state(ml_state, %o3, %o4)
	ld	[%o3 + 28], %g4		! save ml_state.sp
	mov	%o0, %i0		! Propagate exception argument
c_raise10:
	restore				! Pop a frame
	cmp	%sp, %g4
	bne	c_raise10		! Loop until back to ml stack
	mov	%o0, %i0		! Propagate exception argument
	restore				! One more for luck (one beyond ml_state.sp)
	clean_windows
	save	%sp, -0x40, %sp		! Make first ML stack frame below the base
	mov	STACK_C_RAISE, %i1	! Mark this frame
	mov	%i0, %o0		! Propagate exception
	! \/\/ fall through \/\/
#endif
d463 1
a463 1
 *   64(ESP)	Exception handler record
d535 1
@


1.3
log
@Add gc entry code
@
text
@d26 3
d40 1
d474 5
a478 3
 *   %o0	 The exception packet to raise
 *   %o7  Return address for resumption (not used at present, and not true for leaf)
 *   %g3	 Exception handler record
d482 2
a483 4
 * continuations are non-leaf. This is currently true because setting
 * up a handler calls adr, which forces non-leaf because it corrupts o7.
 * However, should we produce a leaf adr by preserving o7 in g4, then
 * all hell will break loose.
a489 1
	call	C_NAME(ml_raise_die)
a497 22
	ld	[%g3+7], %o1		! Get handler closure
	ld	[%o1-1], %g4
	sub	%sp, 8, %sp		! Extend current stack slightly
	std	%g2, [%sp+64]		! Save current handler pointer
	jmpl	%g4+CODE_OFFSET, %o7	! The call to the handler
	ld	[%g3-1], %g3		! Call the handler with previous handler restored
	ld	[%sp+68], %g3		! Reinstate the handler
	add	%sp, 8, %sp		! Return stack to its previous size
	ld	[%g3+3], %g4		! Load sp of creator function
	cmp	%g4, %sp		! See if there already
	bcs	do_unwind		! Branch if we must unwind
	cmp	%g4, %fp		! See if sp < g4 < fp
	bcs	unwound			! Branch if in correct frame
	nop
do_unwind:
	unwind_stack(%sp, raise)	! Wind back to that frame, propagating result
unwound:
	ld	[%g3+11], %g4		! Fetch the offset of the continuation...
	ld	[%i1-1], %o1		! ...and the address of the creator function
	add	%g4, %o1, %g4		! Tagged address of continuation
	jmp	%g4+CODE_OFFSET
	nop
d499 54
@


1.2
log
@Also stub_c and stub_asm
@
text
@d26 2
a27 5
# Revision 1.1  1994/10/04  16:49:58  jont
# new file
#
 * Revision 1.9  1994/09/05  12:20:36  nickb
 * Preserve o7 (link register) over non-leaf GC entry.
d29 1
a29 23
 * Revision 1.8  1994/08/25  09:41:16  matthew
 * Change stack extension entry to free up O registers.
 *
 * Revision 1.7  1994/07/22  16:21:24  nickh
 * Add routines to get us into GC from a trap handler and back again.
 * (see gc_trap_entry, gc_trap_entry_leaf, &c).
 *
 * Revision 1.6  1994/07/06  13:31:35  nickh
 * Asm and C name prefixes differ according to OS.
 *
 * Revision 1.5  1994/07/01  10:39:59  nickh
 * Add debugger trap.
 *
 * Revision 1.4  1994/06/21  15:58:21  nickh
 * New ancillary layout.
 *
 * Revision 1.3  1994/06/15  16:16:56  jont
 * Put non ML return values in o7 when marking STACK_EVENT frames
 *
 * Revision 1.2  1994/06/09  14:30:02  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:54:32  nickh
a31 181
 * Revision 1.79  1994/03/15  12:54:48  nickh
 * Fix intercept comments.
 *
 * Revision 1.78  1994/03/10  14:23:20  jont
 * Changes to handler records following LEO opcode
 *
 * Revision 1.77  1993/11/17  17:05:41  jont
 * Added the missing fields for stubs and rearranged the others into the right order
 *
 * Revision 1.76  1993/11/17  16:20:07  jont
 * Changed the header words on the strings 'stub to C' and 'stub to assembler'
 * so the value printer can understand them.
 *
 * Revision 1.75  1993/11/05  14:56:16  jont
 * Added check_event entries for leaf and non-leaf.
 *
 * Revision 1.74  1993/10/12  10:29:21  matthew
 * Fixed problem in extend_stack where g6 was getting set regardless of whether a signal had
 * been handled.
 *
 * Revision 1.73  1993/08/24  15:51:57  richard
 * Missing +8 offset on return from ml_intercept_leaf.
 *
 * Revision 1.72  1993/08/17  12:11:13  jont
 * Modified _c_raise to discard the c stack before raising its exception
 *
 * Revision 1.71  1993/06/22  11:15:56  richard
 * Marked intercept frames with STACK_INTERCEPT.  See tags.h.
 *
 * Revision 1.70  1993/06/01  14:59:00  richard
 * The interception code had some strange ideas about stack frames
 * which were confusing the garbage collector.  This goes back to the
 * time when interception was always done by overwriting the three nops
 * at the start of the code vector.
 *
 * Revision 1.69  1993/05/05  14:44:16  jont
 * Modified stack unwind code to use fp instead of sp to fix problems
 * with multiple handlers at the same stack level
 *
 * Revision 1.68  1993/04/30  15:47:08  jont
 * Changed to distinguish the real base of the stack from the stack limit pointer
 *
 * Revision 1.67  1993/04/30  12:37:57  jont
 * Made stub_asm a tail
 * Redid ml_raise to stack away current handler at top of stack rather
 * than using an unchecked save. Made ml_raise_leaf do a stack overflow
 * check before opening the stack to save current handler
 *
 * Revision 1.66  1993/04/22  16:44:18  jont
 * Added leaf raise code
 *
 * Revision 1.65  1993/04/20  13:54:25  richard
 * Ripped out old tracing mechanism and installed a new one.
 *
 * Revision 1.64  1993/04/16  14:49:15  jont
 * ml_raise no longers restores the handler chain, this is now done by the ml code
 *
 * Revision 1.63  1993/03/18  10:30:15  jont
 * Fixed some minor problems with the names of the stubs
 *
 * Revision 1.62  1993/02/26  17:52:55  jont
 * Now initialises all unused registers before calling ml.
 * This may have been a source of bad values
 *
 * Revision 1.61  1993/02/10  17:48:48  jont
 * Changes for code vector reform.
 *
 * Revision 1.60  1992/12/08  11:23:21  clive
 * Changed the type of nop used for tracing to store it being moved
 * by the scheduler
 *
 * Revision 1.59  1992/11/11  16:45:48  clive
 * Added some function needed for tracing
 *
 * Revision 1.58  1992/11/05  17:58:40  richard
 * Removed debugger related stuff and replaced it with a more general
 * event handling mechanism.
 *
 * Revision 1.57  1992/09/15  11:24:49  clive
 * Added a save of floating point registers to leaf_gc
 *
 * Revision 1.56  1992/09/09  15:16:20  clive
 * The assembler stub needed to be double-word aligned
 *
 * Revision 1.55  1992/09/02  12:13:59  clive
 * A bug in the disturbance code in the region of ext0 fixed
 *
 * Revision 1.54  1992/08/18  09:01:27  clive
 * Single-stepping wasn't working around calls to C
 *
 * Revision 1.53  1992/08/11  15:37:20  clive
 * Fixed the single-step code
 *
 * Revision 1.52  1992/08/10  13:06:43  richard
 * Added floating point reservation around calls to C and the garbage collector.
 *
 * Revision 1.51  1992/08/07  13:52:48  clive
 * Changed the functionality of some of the debugger functions - added support
 * for tracing
 *
 * Revision 1.50  1992/08/03  08:25:04  richard
 * The C and assembler calling stubs are now single static code vectors.
 * Fixed unwind_stack() for resumable exceptions.
 * Added ml_trap.
 *
 * Revision 1.49  1992/07/30  17:16:45  clive
 * Some changes to the single step hook, which now passes the 'current' function
 * to the hook
 *
 * Revision 1.48  1992/07/30  17:08:37  richard
 * Took the call counting out of the stubs until I can fix it.
 *
 * Revision 1.47  1992/07/29  14:10:59  clive
 * Changes to single-step and calling of debugger now we can callml from C - so
 * errors ironed out
 *
 * Revision 1.46  1992/07/27  14:04:05  richard
 * Implemented callasm stub and c_raise.
 *
 * Revision 1.45  1992/07/22  13:39:05  clive
 * Took out ml_profile
 *
 * Revision 1.44  1992/07/21  15:31:46  richard
 * Removed redundent `flush' instructions, and implemented a
 * _flush_windows routine which can be called from C instead.
 * Moved the unwind stack macro to macros.m4s.  Altered the
 * C calling stub slightly.
 *
 * Revision 1.43  1992/07/16  16:22:29  richard
 * Implemented re-entrant ML using stack bases.
 *
 * Revision 1.42  1992/07/16  15:53:44  clive
 * Did some work on single-stepping, and corrected some bugs in
 * the interrupt handling code
 *
 * Revision 1.41  1992/07/16  10:34:20  richard
 * Added a new way of calling C, although it isn't used yet.
 *
 * Revision 1.40  1992/07/14  15:27:06  richard
 * Removed obsolete memory profiling code and profiler entry point.
 * Changed calls to GC to include the closure of the caller.
 *
 * Revision 1.39  1992/07/09  14:39:53  clive
 * Removed call debugger - now written in ML plus C
 *
 * Revision 1.38  1992/07/08  15:09:55  clive
 * Added code for manually calling the debugger
 *
 * Revision 1.37  1992/07/03  14:40:10  richard
 * Generalised the idea of a `disturbance' and changed the way that
 * interrupts are generated and handled.
 *
 * Revision 1.36  1992/06/25  14:12:05  richard
 * Added a missing stack frame in the stack extension code.
 *
 * Revision 1.35  1992/06/23  12:59:02  richard
 * Altered stack extension return code to pop out of the stack
 * block it deallocates in case it gets unmapped.
 *
 * Revision 1.34  1992/06/22  14:55:36  clive
 * More work on the debugger
 *
 * Revision 1.33  1992/06/18  11:47:51  richard
 * Changed the way that stack extension frames are marked.  Also merged
 * in some of Clive's top level handler code.
 *
 * Revision 1.32  1992/06/17  14:37:46  richard
 * Added _ml_gc_leaf entry point.
 *
 * Revision 1.31  1992/06/11  11:08:14  clive
 * First attempt at converting a user ^C into an ML interrupt Interrupt
 * Also, entry from toplevel into the ML debugger hook function
 * Code need neatening ...
 *
 * Revision 1.30  1992/05/22  11:01:15  clive
 * ml_raise was winding back too many frames at a stack extension -
 * it wound back two before testing for the required frame
 *
 * Revision 1.29  1992/05/21  16:01:51  richard
 * Changed statistics collection to use the scratch register
 * to avoid confusion.
a32 64
 * Revision 1.28  1992/05/15  10:29:32  clive
 * Memory profiling result in bytes - to get tagging automatically
 *
 * Revision 1.27  1992/05/14  11:37:57  clive
 * Added memory profiling
 *
 * Revision 1.26  1992/04/15  10:25:47  richard
 * Converted to use the m4 macro processor and renamed to interface.m4s.
 * Added Clive's profiler stub.
 * Moved polymorphic equality code to a separate file.
 *
 * Revision 1.26  1992/04/14  16:06:13  richard
 * Converted to use m4 macro processor and renamed to interface.m4s.
 * Added Clive's code for profiling.
 *
 * Revision 1.24  1992/04/03  10:41:14  richard
 * Moved macros to a shared file.
 *
 * Revision 1.22  1992/03/26  15:21:42  richard
 * Added new statistics gathering code.  Removed definition of STATS.
 * COLLECT_STATS and TRAP_FLUSH are now defined by the Makefile so that
 * the behaviour can easily be reconfigured.
 *
 * Revision 1.21  1992/03/25  13:28:34  richard
 * Wrote an assembler version of polymorphic equality that intercepts
 * calls to the C version.  Very fast.
 *
 * Revision 1.20  1992/03/24  15:34:06  richard
 * Rewrote virtually everything again.  There are now far fewer save and
 * restore instructions and the `ml_external' routine looks up the
 * pervasive C function directly.
 *
 * Revision 1.19	 1992/03/18  12:23:58  clive
 * Added a flush windows in ML_TO_C2T in case a garbage collection occurs
 * whilst we are inside the C (in which case we expect the registers on the
 * stack )
 *
 * Revision 1.18	 1992/02/24  10:17:21  clive
 * ML_TO_C2 and like functions were causing one extra C-stack to be allocated
 * per ML call to C - changed them to use SAVE_C_STATE_WITHOUT_SP which saves
 * the C state but doesn't save away a new sp - this was the easiest fix to the
 * problem... C cannot now be used as a coroutine as the stack is reset to where
 * it started out
 *
 * Revision 1.17	 1992/01/20  16:48:42  richard
 * Revised some of the raise code.
 * Added a macro to call C with a window flush trap in the right place
 * for the garbage collector.
 *
 * Revision 1.16	 1992/01/15  18:18:45  richard
 * Further development of _ml_raise.
 *
 * Revision 1.15	 1992/01/14  16:26:35  richard
 * Added new exception raising code, plus other minor changes.
 *
 * Revision 1.14	 1992/01/13  11:03:44  richard
 * Used macros for C calling to simplify code for several procedures, and
 * to allow correct calls (in terms of stack frames) to the garbage collector.
 * Added ml_extend.
 *
 * Revision 1.13	 1992/01/08  14:18:17  richard
 * Rewrote almost everything to remove some redundant saves and restores.
 * Introduces the C preprocessor to allow macros.
 *
d70 1
a70 1
	store_C_globals(c_state, %eax)
d96 1
a96 1
	load_C_globals(c_state, %eax)
d121 1
a121 1
	load_C_globals(c_state, %eax)
d168 7
d178 11
a188 1
	ret
d190 1
a190 2
	call	C_NAME(ml_gc_die)
	mov	%i1, %o0
d192 5
a198 1
	ret
d200 1
a215 4
#if 0
	retl
	ta 3
#endif
d229 1
a229 1
	ret
d258 1
a258 1
	ret
d367 1
a367 1
	ret
d387 1
a387 1
	ret
d424 1
a424 1
	ret
d486 1
a486 1
	ret
d520 1
a520 1
	ret
d589 1
a589 1
	ret
d598 1
a598 1
	ret
d608 1
a608 1
	ret
d619 1
a619 1
	ret
d653 1
a653 1
	ret
d661 1
a661 1
	ret
d669 1
a669 1
	ret
d677 1
a677 1
	ret
d685 1
a685 1
	ret
d697 1
a697 1
	ret
d728 1
d732 1
a732 1
	ret
d761 1
a761 1
	load_C_globals(c_state,%o3)		/* load C state */
d779 1
a779 1
	store_C_globals(c_state, %o2)
d817 1
a817 1
	ret
d823 1
a823 1
	ret
d833 1
a833 1
	ret
d845 1
a845 1
	ret
d872 1
a872 1
	load_C_globals(c_state,%o3)		/* load C state */
d881 1
a881 1
	store_C_globals(c_state, %o2)
d903 1
a903 1
	ret
d909 1
a909 1
	ret
d918 1
a918 1
	ret
d922 1
a922 1

@


1.1
log
@new file
@
text
@d25 4
a28 1
 * $Log: src:arch:SPARC:interface.S,v $
d365 1
a382 57
#if 0 /* Now in C */
	.global	C_NAME(stub_c)
	.global	C_NAME(stub_asm)

C_NAME(stub_c):		.word internal_stub_c+POINTER
C_NAME(stub_asm):	.word internal_stub_asm+POINTER

/* We have to build fake ancillary information */

	.align 	8
stubancill:				/* this is a pair */
	.word	stubnames + PAIRPTR
	.word	stubprofiles + PAIRPTR

	.align 8
stubnames:				/* this is a pair */
	.word	sc_name + POINTER
	.word	sa_name + POINTER

	.align 8
stubprofiles:				/* this is a pair */
	.word 0
	.word 0

	.align 	8
sc_name:
/* Not done yet
	.word	((sc_name_end - sc_name - 4) << 6) | STRING
	.asciz	'stub to C'
*/
sc_name_end:

	.align 	8
sa_name:
/* Not done yet
	.word	((sa_name_end - sa_name - 4) << 6) | STRING
	.asciz	'stub to assembler'
*/
sa_name_end:

	.align	8
stub_code_vector:
/* Not done yet
	.word	(((stub_code_end-stub_code_vector)-4)<<6) | CODE
*/
	.word	stubancill + PAIRPTR

	.align 8
internal_stub_c:
/* Not done yet
	.word	(internal_stub_c - stub_code_vector) << 6 | BACKPTR
*/
	.word	0x7f00			/* Code element 0 */

					/* (no spills,leaf,intercept) */
#endif

a386 1
#if 0 /*** NYI ***/
d388 4
a391 4
	store_ML_state(ml_state, $16, stub_c)
	sw	$29, 24($16)		# Save last ML frame for GC
	sw	$30, 0($29)		# And get the fp correct in it
	address_C_globals(c_state, $17)
d393 1
a393 1
	std	%f0, [%sp+0x58]		# Preserve non-corrupted floats
d397 4
a400 5
	lw	$25, 3($5)
	lw	$29, 0($17)		# address of last C stack frame
	jal	$25			# Call C function (should perserve $30)
	nop				# Note that the use of $25 here is important
	move	$4, $2			# Get the answer
a401 1

d406 4
a409 8
/* Shouldn't be needed
	address_C_globals(c_state, $17)
	sw	$29, 0($17)
*/
	load_ML_state(ml_state, $16, $18)
	lw	$29, 24($16)		# Point back to ml frame
	nop
	lw	$30, 0($29)		# Reload fp as well
d411 1
a411 3
	j	$31
	nop
#endif
a413 13
#if	0
	.data
	.globl	data_internal_stub_c
data_internal_stub_c:
	.space	text_internal_stub_c_end - text_internal_stub_c
	/* Room to copy the code in here */

	.align	8
internal_stub_asm:
	.word	(internal_stub_asm - stub_code_vector) << 6 | BACKPTR
	.word	0x7f01			# Code element 1
					# (no spills, leaf, intercept)
#endif
d418 1
a418 6
#if 0 /*** NYI ***/
	lw	$1, 3($5)		# Address to call
	nop
	j	$1			# Tail to it
	nop
#endif
a420 7
#if 0
	.data
	.globl	data_internal_stub_asm
data_internal_stub_asm:
	.space	(text_internal_stub_asm_end - text_internal_stub_asm)
	/* Room to copy the code in here */
#endif
a422 38
#if 0
	store_ML_state(ml_state, %o2)
	st	%sp, [%o2+32]		/* Save base of ML stack area (see callml) */
	load_C_globals(c_state, %o3)
	ld	[%o3+28], %o4		/* address of last C stack frame */
	save	%o4, -0x78, %sp		/* Switch to C stack */
	st	%sp, [%i2+28]		/* Save last ML frame for GC */
	std	%f0, [%sp+0x58]		/* Preserve non-corrupted floats */
	std	%f2, [%sp+0x60]
	std	%f6, [%sp+0x70]
	ld	[%i1+3], %o1		/* address of C function to call */
	jmpl	%o1, %o7		/* Call the C function */
	mov	%i0, %o0		/* (propagating the argument) */
	mov	%o0, %i0		/* Propagate the result */
	ldd	[%sp+0x70], %f6
	ldd	[%sp+0x60], %f2
	ldd	[%sp+0x58], %f0
	restore				/* Back to ML stack */
	store_C_globals(c_state, %o3)
	load_ML_state(ml_state, %o2, %o4)
	retl
	clean_windows			/* Clean dirty C windows */
#endif

	.align	8
internal_stub_asm:
/* Not done yet
	.word	(internal_stub_asm - stub_code_vector) << 6 | BACKPTR
*/
	.word	0x7f01			/* Code element 1 */
					/* (no spills, leaf, intercept) */
	ret
#if 0
	ld	[%o1+3], %g4		/* address of subroutine */
	jmp	%g4			/* Tail to subroutine */
	nop
#endif

d434 1
a434 5
	ret
#if 0
	save	%sp, -0x40, %sp
	mov	STACK_C_CALL, %i1
	mov	%i0, %o0
d436 1
a436 1
	mov	%o0, %i0
a437 11
	restore
#endif


/*
 * These used to be called from ML when a GC was required. Now we
 * cause a trap instead, so these routines call a non-returning error
 * routine which prints the name of the calling closure instead.
 *
 * See also gc_trap_entry and gc_trap_entry_leaf, also in this file.
*/
@
