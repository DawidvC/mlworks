head	1.9;
access;
symbols
	MLW_daveb_inline_1_4_99:1.9.1
	MLWorks_21c0_1999_03_25:1.9
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.7.3
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.6.9.1.1.1.1
	MLWorks_workspace_97:1.7.2
	MLWorks_dt_wizard:1.7.1
	MLWorks_11c0_1997_09_09:1.6.9.1.1.1
	MLWorks_10r3:1.6.9.1.3
	MLWorks_10r2_551:1.6.9.1.2
	MLWorks_11:1.6.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.6.9.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.6.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.6.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.6.9
	MLWorks_BugFix_1997_04_24:1.6
	MLWorks_1_0_r2_Win32_1997_04_11:1.6
	MLWorks_1_0_r2_Unix_1997_04_04:1.6
	MM_ML_release_korma_1997_04_01:1.6
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.6.7.1.1
	MLWorks_gui_1996_12_18:1.6.8
	MLWorks_1_0_Win32_1996_12_17:1.6.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.6.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.6.4.1
	JFHrts:1.6.6
	MLWorks_1_0_Irix_1996_11_28:1.6.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.6.5
	MLWorks_1_0_Unix_1996_11_14:1.6.4
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.9
date	98.09.15.10.24.45;	author jont;	state Exp;
branches
	1.9.1.1;
next	1.8;

1.8
date	98.05.20.15.02.01;	author jont;	state Exp;
branches;
next	1.7;

1.7
date	97.05.30.12.07.18;	author jont;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1;
next	1.6;

1.6
date	95.02.28.16.39.46;	author jont;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1
	1.6.4.1
	1.6.5.1
	1.6.6.1
	1.6.7.1
	1.6.8.1
	1.6.9.1;
next	1.5;

1.5
date	95.01.17.17.05.46;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	94.11.25.11.25.35;	author nickb;	state Exp;
branches;
next	1.3;

1.3
date	94.11.23.17.01.28;	author nickb;	state Exp;
branches;
next	1.2;

1.2
date	94.10.06.15.49.28;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.56.36;	author jont;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.23.24;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.13.36;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.33.00;	author hope;	state Exp;
branches;
next	;

1.6.4.1
date	96.11.14.12.58.46;	author hope;	state Exp;
branches
	1.6.4.1.1.1;
next	;

1.6.4.1.1.1
date	96.11.28.15.08.43;	author hope;	state Exp;
branches;
next	;

1.6.5.1
date	96.11.22.18.16.25;	author hope;	state Exp;
branches;
next	;

1.6.6.1
date	96.12.17.10.03.12;	author hope;	state Exp;
branches;
next	;

1.6.7.1
date	96.12.17.17.54.49;	author hope;	state Exp;
branches
	1.6.7.1.1.1;
next	;

1.6.7.1.1.1
date	97.02.24.11.45.55;	author hope;	state Exp;
branches;
next	;

1.6.8.1
date	96.12.18.09.49.25;	author hope;	state Exp;
branches;
next	;

1.6.9.1
date	97.05.12.10.41.49;	author hope;	state Exp;
branches
	1.6.9.1.1.1
	1.6.9.1.2.1
	1.6.9.1.3.1;
next	;

1.6.9.1.1.1
date	97.07.28.18.26.38;	author daveb;	state Exp;
branches
	1.6.9.1.1.1.1.1;
next	;

1.6.9.1.1.1.1.1
date	97.10.07.11.52.26;	author jkbrook;	state Exp;
branches;
next	;

1.6.9.1.2.1
date	97.09.08.17.19.46;	author daveb;	state Exp;
branches;
next	;

1.6.9.1.3.1
date	97.09.09.14.15.52;	author daveb;	state Exp;
branches;
next	;

1.7.1.1
date	97.09.10.19.33.11;	author brucem;	state Exp;
branches;
next	;

1.7.2.1
date	97.09.11.21.02.25;	author daveb;	state Exp;
branches;
next	;

1.7.3.1
date	97.10.31.13.45.15;	author nickb;	state Exp;
branches;
next	;

1.9.1.1
date	99.04.01.18.01.50;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.9
log
@[Bug #20133]
Add ml_profile_alloc_die
@
text
@/* stubs.c
 *
 * A file to generate the assembler and c stubs because the Intel
 * assembler is defective and can't do it itself
 *
 * $Log: src:arch:I386:stubs.c,v $
 * Revision 1.8  1998/05/20  15:02:01  jont
 * [Bug #70035]
 * Add stubs_code_start, stubs_code_end, stubs_data_start, stubs_data_end
 *
 * Revision 1.7  1997/05/30  12:07:18  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
 * Revision 1.5  1995/01/17  17:05:46  jont
 * Fix problems with ancillary words in stub_c and stub_asm
 *
 * Revision 1.4  1994/11/25  11:25:35  nickb
 * Replace ml_gc_leaf_die (removed in error).
 *
 * Revision 1.3  1994/11/23  17:01:28  nickb
 * Remove set_stack_underflow_die.
 *
 * Revision 1.2  1994/10/06  15:49:28  jont
 * Make it Intel architecture specific
 *
 *
 * Copyright (C) 1994 Harlequin
 *
 */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>

#include "tags.h"
#include "mltypes.h"
#include "stubs.h"
#include "print.h"
#include "mach_values.h"
#include "values.h"

void *stubs_code_start;
void *stubs_code_end;
void *stubs_data_start;
void *stubs_data_end;

extern char text_internal_stub_c;		/* Where the stub to C code is */
extern char text_internal_stub_c_end;		/* Where it ends */
extern char text_internal_stub_asm;		/* Where the stub to assembler is */
extern char text_internal_stub_asm_end;	/* Where the stub to assembler is */

mlval stub_c = (mlval)NULL;
mlval stub_asm = (mlval)NULL; /* The vectors */

/* A place holder to indicate the start of the data for stubs */
/* Must come before all the data */

static int bar;

static struct {
  char *first;
  char *second;
} stubancill, stubnames, stubprofiles;

static struct {
  unsigned int first;
  unsigned int second;
} dummy;

#define STUB_C_NAME "stub to C"

static struct {
  unsigned int len;
  char name[sizeof(STUB_C_NAME)];
} sc_name =
{
  0,
  "stub to C"
};

static struct {
  unsigned int len;
  char name[100];
} sa_name =
{
  0,
  "stub to assembler"
};

/* A place holder to indicate the end of the data for stubs */
/* Must come after all the data */

static int foo;

static unsigned int align_to_double_word(unsigned int value)
{
  return ((value + 7) & ~7u);
}

void stubs_init(void)
{
  unsigned int stub_c_len =
    align_to_double_word((unsigned)(&text_internal_stub_c_end - &text_internal_stub_c));
  unsigned int stub_asm_len =
    align_to_double_word((unsigned)(&text_internal_stub_asm_end - &text_internal_stub_asm));
  unsigned long stubs_len = stub_c_len + stub_asm_len + 8 + 8 + 8 + 4;
  char *stub_vector = malloc(stubs_len);
  stub_vector = (char *) align_to_double_word((unsigned)stub_vector); /* Ensure alignment */
  /* Set up pointers */
  stub_c = (mlval)stub_vector + 8;
  stub_asm = (mlval)stub_vector + 8 + 8 + stub_c_len;
  /* Copy in code */
  memcpy((void *)((char *)stub_c + 8), &text_internal_stub_c, stub_c_len);
  memcpy((void *)((char *)stub_asm + 8), &text_internal_stub_asm, stub_asm_len);
  stubprofiles.first = NULL;
  stubprofiles.second = NULL;
  sc_name.len = ((strlen(sc_name.name) + 1) << 6) | STRING;
  sa_name.len = ((strlen(sa_name.name) + 1) << 6) | STRING;
  stubnames.first = ((char *)(&sc_name)) + POINTER;
  stubnames.second = ((char *)(&sa_name)) + POINTER;
  stubancill.first = ((char *)(&stubnames)) + PAIRPTR;
  stubancill.second = ((char *)(&stubprofiles)) + PAIRPTR;
  dummy.first = (8 << 6) | BACKPTR;
  dummy.second = CCODE_MAKE_ANCILL(2, 0, 0, CCODE_NO_INTERCEPT, 0, 0);
  /* Two callee saved registers stacked */
  /* No stacked parameters */
  memcpy((void *)stub_c, (void *)&dummy, 8);
  dummy.first = ((stub_c_len + 8 + 8) << 6) | BACKPTR;
  dummy.second = CCODE_MAKE_ANCILL(0, 0, 0, CCODE_NO_INTERCEPT, 0, 1);
  /* No callee save registers */
  /* No stacked parameters */
  memcpy((void *)stub_asm, (void *)&dummy, 8);
  dummy.first = ((stub_c_len + stub_asm_len + 8 + 8 + 8 - 4) << 6) | CODE;
  dummy.second = (int)(&stubancill) + PAIRPTR;
  memcpy(stub_vector, (void *)&dummy, 8);
  stub_c += POINTER;
  stub_asm += POINTER;
  stubs_code_start = stub_vector;
  stubs_code_end = stub_vector + stubs_len;
  stubs_data_start = &bar;
  stubs_data_end = &foo;
}

/* Temporary code */

extern void ml_gc_leaf_die(void);

extern void ml_gc_leaf_die(void)
{
  fprintf(stderr, "ml_gc_leaf_die called\n");
  exit(1);
}

extern void ml_profile_alloc_die(void);

extern void ml_profile_alloc_die(void)
{
  fprintf(stderr, "ml_profile_alloc_die called\n");
  exit(1);
}

extern void ml_disturbance_die(void);

extern void ml_disturbance_die(void)
{
  fprintf(stderr, "ml_disturbance_die called\n");
  exit(1);
}

extern void ml_event_check_die(void);

extern void ml_event_check_die(void)
{
  fprintf(stderr, "ml_event_check_die called\n");
  exit(1);
}

extern void ml_event_check_leaf_die(void);

extern void ml_event_check_leaf_die(void)
{
  fprintf(stderr, "ml_event_check_leaf_die called\n");
  exit(1);
}

extern void c_raise_die(mlval);

extern void c_raise_die(mlval v)
{
  fprintf(stderr, "c_raise_die called\n");
  print(&print_defaults, stderr, v);
  exit(1);
}

extern void ml_raise_die(void);

extern void ml_raise_die(void)
{
  fprintf(stderr, "ml_raise_die called\n");
  exit(1);
}

extern void ml_raise_leaf_die(void);

extern void ml_raise_leaf_die(void)
{
  fprintf(stderr, "ml_raise_leaf_die called\n");
  exit(1);
}

extern void ml_replace_die(void);

extern void ml_replace_die(void)
{
  fprintf(stderr, "ml_replace_die called\n");
  exit(1);
}

extern void ml_replace_leaf_die(void);

extern void ml_replace_leaf_die(void)
{
  fprintf(stderr, "ml_replace_leaf_die called\n");
  exit(1);
}

extern void ml_intercept_die(void);

extern void ml_intercept_die(void)
{
  fprintf(stderr, "ml_intercept_die called\n");
  exit(1);
}

extern void ml_intercept_leaf_die(void);

extern void ml_intercept_leaf_die(void)
{
  fprintf(stderr, "ml_intercept_leaf_die called\n");
  exit(1);
}

extern void ml_replace_on_die(void);

extern void ml_replace_on_die(void)
{
  fprintf(stderr, "ml_replace_on_die called\n");
  exit(1);
}

extern void ml_replace_on_leaf_die(void);

extern void ml_replace_on_leaf_die(void)
{
  fprintf(stderr, "ml_replace_on_leaf_die called\n");
  exit(1);
}

extern void ml_intercept_on_die(void);

extern void ml_intercept_on_die(void)
{
  fprintf(stderr, "ml_intercept_on_die called\n");
  exit(1);
}

extern void ml_intercept_on_leaf_die(void);

extern void ml_intercept_on_leaf_die(void)
{
  fprintf(stderr, "ml_intercept_on_leaf_die called\n");
  exit(1);
}

extern void ml_nop_die(void);

extern void ml_nop_die(void)
{
  fprintf(stderr, "ml_nop_die called\n");
  exit(1);
}
@


1.9.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a6 4
 * Revision 1.9  1998/09/15  10:24:45  jont
 * [Bug #20133]
 * Add ml_profile_alloc_die
 *
@


1.8
log
@[Bug #70035]
Add stubs_code_start, stubs_code_end, stubs_data_start, stubs_data_end
@
text
@d7 4
d157 9
@


1.7
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d7 4
d42 5
d55 5
d90 5
d106 2
a107 1
  char *stub_vector = malloc(stub_c_len + stub_asm_len + 8 + 8 + 8 + 4);
d138 4
a272 1

@


1.7.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a6 4
 * Revision 1.7  1997/05/30  12:07:18  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.7.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a6 4
 * Revision 1.7  1997/05/30  12:07:18  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.7.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a6 4
 * Revision 1.7  1997/05/30  12:07:18  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
@


1.6
log
@Make calls to *_die return code 1.
@
text
@d7 3
d104 1
a104 1
  dummy.second = CCODE_MAKE_ANCILL(2, 0, 0, CCODE_NO_INTERCEPT, 0);
d106 1
d109 1
a109 1
  dummy.second = CCODE_MAKE_ANCILL(0, 0, 0, CCODE_NO_INTERCEPT, 1);
d111 1
@


1.6.9.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a6 3
 * Revision 1.6.9.1  1997/05/12  10:41:49  hope
 * branched from 1.6
 *
@


1.6.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a6 3
 * Revision 1.6.9.1  1997/05/12  10:41:49  hope
 * branched from 1.6
 *
@


1.6.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a6 3
 * Revision 1.6.9.1  1997/05/12  10:41:49  hope
 * branched from 1.6
 *
@


1.6.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a6 3
 * Revision 1.6.9.1.1.1  1997/07/28  18:26:38  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.6.8.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.7.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.7.1.1.1
log
@branched from 1.6.7.1
@
text
@a6 3
 * Revision 1.6.7.1  1996/12/17  17:54:49  hope
 * branched from 1.6
 *
@


1.6.6.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.5.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.4.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.4.1.1.1
log
@branched from 1.6.4.1
@
text
@a6 3
 * Revision 1.6.4.1  1996/11/14  12:58:46  hope
 * branched from 1.6
 *
@


1.6.3.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a6 3
 * Revision 1.6  1995/02/28  16:39:46  jont
 * Make calls to *_die return code 1.
 *
@


1.5
log
@Fix problems with ancillary words in stub_c and stub_asm
@
text
@d7 3
d122 1
a122 1
  exit(0);
d129 1
a129 1
  exit(0);
d137 1
a137 1
  exit(0);
d145 1
a145 1
  exit(0);
d154 1
a154 1
  exit(0);
d162 1
a162 1
  exit(0);
d170 1
a170 1
  exit(0);
d178 1
a178 1
  exit(0);
d186 1
a186 1
  exit(0);
d194 1
a194 1
  exit(0);
d202 1
a202 1
  exit(0);
d210 1
a210 1
  exit(0);
d218 1
a218 1
  exit(0);
d226 1
a226 1
  exit(0);
d234 1
a234 1
  exit(0);
d242 1
a242 1
  exit(0);
@


1.4
log
@Replace ml_gc_leaf_die (removed in error).
@
text
@d7 3
d29 2
d98 2
a99 1
  dummy.second = 0x27f00; /* Two callee saved registers stacked */
d102 2
a103 1
  dummy.second = 0x7f01;
@


1.3
log
@Remove set_stack_underflow_die.
@
text
@d7 3
d107 7
@


1.2
log
@Make it Intel architecture specific
@
text
@d6 3
a8 1
 * $Log$
d10 1
a102 24

extern void ml_gc_die(void);

extern void ml_gc_die(void)
{
  fprintf(stderr, "ml_gc called, dying\n");
  exit(0);
}

extern void ml_gc_leaf_die(void);

extern void ml_gc_leaf_die(void)
{
  fprintf(stderr, "ml_gc_leaf called, dying\n");
  exit(0);
}

extern void set_stack_underflow_die(void);

extern void set_stack_underflow_die(void)
{
  fprintf(stderr, "set_stack_underflow_die called\n");
  exit(0);
}
@


1.1
log
@new file
@
text
@d3 1
a3 1
 * A file to generate the assembler and c stubs because the MIPS
d6 1
a6 3
 * $Log: src:arch:MIPS:stubs.c,v $
 * Revision 1.2  1994/07/22  16:34:08  jont
 * Add callee save count to stubs
a7 3
 * Revision 1.1  1994/07/12  12:08:13  jont
 * new file
 *
d87 1
a87 1
  dummy.second = 0x87f00;
@
