head	1.33;
access;
symbols
	MLW_daveb_inline_1_4_99:1.33.1
	MLWorks_21c0_1999_03_25:1.33
	MLWorks_20c1_1998_08_20:1.32
	MLWorks_20c0_1998_08_04:1.32
	MLWorks_20b2c2_1998_06_19:1.31
	MLWorks_20b2_Windows_1998_06_12:1.31
	MLWorks_20b1c1_1998_05_07:1.31
	MLWorks_20b0_1998_04_07:1.31
	MLWorks_20b0_1998_03_20:1.31
	MLWorks_20m2_1998_02_16:1.28
	MLWorks_MM_adapt:1.28.3
	MLWorks_20m1_1997_10_23:1.28
	MLWorks_11r1:1.25.5.1.1.1.1
	MLWorks_workspace_97:1.28.2
	MLWorks_dt_wizard:1.28.1
	MLWorks_11c0_1997_09_09:1.25.5.1.1.1
	MLWorks_10r3:1.25.5.1.3
	MLWorks_10r2_551:1.25.5.1.2
	MLWorks_11:1.25.5.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.25.5.1
	MLWorks_20m0_1997_06_20:1.28
	MLWorks_1_0_r2c2_1997_06_14:1.25.5.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.25.5.1
	MLWorks_1_0_r2c1_1997_05_12:1.25.5
	MLWorks_BugFix_1997_04_24:1.25
	MLWorks_1_0_r2_Win32_1997_04_11:1.25
	MLWorks_1_0_r2_Unix_1997_04_04:1.25
	MM_ML_release_korma_1997_04_01:1.25
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.25.3.1.1
	MLWorks_gui_1996_12_18:1.25.4
	MLWorks_1_0_Win32_1996_12_17:1.25.3
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.23.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.23.1.1
	JFHrts:1.25.2
	MLWorks_1_0_Irix_1996_11_28:1.23.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.25.1
	MLWorks_1_0_Unix_1996_11_14:1.23.1
	MLWorks_Open_Beta2_1996_10_11:1.20.2
	MLWorks_License_dev:1.20.1
	MLWorks_1_open_beta_1996_09_13:1.19.1
	MLWorks_Open_Beta_1996_08_22:1.19
	MLWorks_Beta_1996_07_02:1.19
	MLWorks_Beta_1996_06_07:1.19
	MLWorks_Beta_1996_06_06:1.19
	MLWorks_Beta_1996_06_05:1.19
	MLWorks_Beta_1996_06_03:1.19
	MLWorks_Beta_1996_05_31:1.19
	MLWorks_Beta_1996_05_30:1.19;
locks; strict;
comment	@ * @;


1.33
date	98.09.17.15.22.35;	author jont;	state Exp;
branches
	1.33.1.1;
next	1.32;

1.32
date	98.07.15.15.20.26;	author jont;	state Exp;
branches;
next	1.31;

1.31
date	98.03.19.11.54.25;	author jont;	state Exp;
branches;
next	1.30;

1.30
date	98.03.03.17.17.33;	author jont;	state Exp;
branches;
next	1.29;

1.29
date	98.02.13.15.07.16;	author jont;	state Exp;
branches;
next	1.28;

1.28
date	97.06.05.12.45.56;	author jont;	state Exp;
branches
	1.28.1.1
	1.28.2.1
	1.28.3.1;
next	1.27;

1.27
date	97.06.03.16.28.48;	author jont;	state Exp;
branches;
next	1.26;

1.26
date	97.06.02.17.02.22;	author jont;	state Exp;
branches;
next	1.25;

1.25
date	96.11.18.15.05.31;	author nickb;	state Exp;
branches
	1.25.1.1
	1.25.2.1
	1.25.3.1
	1.25.4.1
	1.25.5.1;
next	1.24;

1.24
date	96.11.14.15.19.05;	author stephenb;	state Exp;
branches;
next	1.23;

1.23
date	96.11.14.09.54.29;	author stephenb;	state Exp;
branches
	1.23.1.1;
next	1.22;

1.22
date	96.11.07.17.41.33;	author stephenb;	state Exp;
branches;
next	1.21;

1.21
date	96.11.04.14.12.53;	author stephenb;	state Exp;
branches;
next	1.20;

1.20
date	96.10.04.13.05.47;	author stephenb;	state Exp;
branches
	1.20.1.1
	1.20.2.1;
next	1.19;

1.19
date	96.02.14.17.35.14;	author jont;	state Exp;
branches
	1.19.1.1;
next	1.18;

1.18
date	96.02.14.13.11.36;	author nickb;	state Exp;
branches;
next	1.17;

1.17
date	96.02.14.11.06.02;	author jont;	state Exp;
branches;
next	1.16;

1.16
date	96.01.11.17.23.58;	author nickb;	state Exp;
branches;
next	1.15;

1.15
date	95.12.18.15.58.52;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	95.12.18.13.53.27;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	95.11.21.14.32.04;	author jont;	state Exp;
branches;
next	1.12;

1.12
date	95.05.30.10.18.09;	author nickb;	state Exp;
branches;
next	1.11;

1.11
date	95.05.24.10.43.27;	author nickb;	state Exp;
branches;
next	1.10;

1.10
date	95.05.05.12.04.03;	author nickb;	state Exp;
branches;
next	1.9;

1.9
date	95.04.25.13.21.30;	author nickb;	state Exp;
branches;
next	1.8;

1.8
date	95.03.29.14.13.38;	author nickb;	state Exp;
branches;
next	1.7;

1.7
date	95.03.20.13.58.50;	author matthew;	state Exp;
branches;
next	1.6;

1.6
date	95.03.02.13.52.29;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	95.02.27.16.16.14;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.12.02.16.04.03;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	94.10.12.11.41.31;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.07.11.08.06;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.55.28;	author jont;	state Exp;
branches;
next	;

1.19.1.1
date	96.09.13.11.21.36;	author hope;	state Exp;
branches;
next	;

1.20.1.1
date	96.10.07.16.11.38;	author hope;	state Exp;
branches;
next	;

1.20.2.1
date	96.10.17.11.30.17;	author hope;	state Exp;
branches;
next	;

1.23.1.1
date	96.11.14.12.56.14;	author hope;	state Exp;
branches
	1.23.1.1.1.1;
next	;

1.23.1.1.1.1
date	96.11.28.15.06.44;	author hope;	state Exp;
branches;
next	;

1.25.1.1
date	96.11.22.18.14.25;	author hope;	state Exp;
branches;
next	;

1.25.2.1
date	96.12.17.10.01.13;	author hope;	state Exp;
branches;
next	;

1.25.3.1
date	96.12.17.17.52.56;	author hope;	state Exp;
branches
	1.25.3.1.1.1;
next	;

1.25.3.1.1.1
date	97.02.24.11.43.47;	author hope;	state Exp;
branches;
next	;

1.25.4.1
date	96.12.18.09.47.28;	author hope;	state Exp;
branches;
next	;

1.25.5.1
date	97.05.12.10.39.54;	author hope;	state Exp;
branches
	1.25.5.1.1.1
	1.25.5.1.2.1
	1.25.5.1.3.1;
next	;

1.25.5.1.1.1
date	97.07.28.18.26.20;	author daveb;	state Exp;
branches
	1.25.5.1.1.1.1.1;
next	;

1.25.5.1.1.1.1.1
date	97.10.07.11.52.10;	author jkbrook;	state Exp;
branches;
next	1.25.5.1.1.1.1.2;

1.25.5.1.1.1.1.2
date	97.10.16.13.30.34;	author jkbrook;	state Exp;
branches;
next	;

1.25.5.1.2.1
date	97.09.08.17.19.31;	author daveb;	state Exp;
branches;
next	;

1.25.5.1.3.1
date	97.09.09.14.15.39;	author daveb;	state Exp;
branches;
next	1.25.5.1.3.2;

1.25.5.1.3.2
date	97.10.16.11.20.43;	author jkbrook;	state Exp;
branches;
next	;

1.28.1.1
date	97.09.10.19.32.50;	author brucem;	state Exp;
branches;
next	;

1.28.2.1
date	97.09.11.21.02.07;	author daveb;	state Exp;
branches;
next	;

1.28.3.1
date	97.10.31.13.44.59;	author nickb;	state Exp;
branches;
next	;

1.33.1.1
date	99.04.01.18.01.35;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.33
log
@[Bug #20124]
Remove compiler warning and improve backtrace and is_ml_frame
@
text
@/*  === INTEL x86 STACK ROUTINES ===
 *
 *  Copyright (C) 1994 Harlequin Ltd
 *
 *  Description
 *  -----------
 * All architecture-dependent routines that deal with the stack.
 *
 *  Revision Log
 *  ------------
 *  $Log: src:arch:I386:stacks.c,v $
 * Revision 1.32  1998/07/15  15:20:26  jont
 * [Bug #20124]
 * Stop assuming all code and closures must be on ml heap
 *
 * Revision 1.31  1998/03/19  11:54:25  jont
 * [Bug #70026]
 * Allow profiling of stub_c functions, recording the time according
 * to the name of the runtime system functions
 *
 * Revision 1.30  1998/03/03  17:17:33  jont
 * [Bug #70018]
 * Split stack_crawl into two phases
 *
 * Revision 1.29  1998/02/13  15:07:16  jont
 * [Bug #30242]
 * Use ml_utilities for function pc_in_clousre when finxing return addresses
 *
 * Revision 1.28  1997/06/05  12:45:56  jont
 * [Bug #30076]
 * More work for stack parameter passing, getting the gc scan right.
 *
 * Revision 1.27  1997/06/03  16:28:48  jont
 * [Bug #30076]
 * Modify to make NONGC spills be counted in words
 *
 * Revision 1.26  1997/06/02  17:02:22  jont
 * [Bug #30076]
 * Modifications to allow stack based parameter passing on the I386
 *
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fix stack_crawl to fit new stack invariants.
 *
 * Revision 1.24  1996/11/14  15:19:05  stephenb
 * [Bug #1760]
 * frame_next: Change the offset from 0 to 1 since 0 is used to
 * indicate that the frame is a C frame.
 *
 * Revision 1.23  1996/11/14  09:54:29  stephenb
 * [Bug #1760]
 * See .fake_frame in the comment associated with frame_next.
 *
 * Revision 1.22  1996/11/07  17:41:33  stephenb
 * [Bug #1461]
 * Fix stack closure tags.
 *
 * Revision 1.21  1996/11/04  14:12:53  stephenb
 * [Bug #1441]
 * frame_next: change the offset to be a byte rather than word
 * offset since instructions are not word aligned on an I386.
 *
 * Revision 1.20  1996/10/04  13:05:47  stephenb
 * [Bug #1445]
 * frame_next: adjust the offset calculated for an ML frame so that
 * it produces values that correctly index into the debugger annotation
 * tables.
 *
 * Revision 1.19  1996/02/14  17:35:14  jont
 * ISPTR becomes MLVALISPTR
 *
 * Revision 1.18  1996/02/14  13:11:36  nickb
 * Add heap-exploration hooks.
 *
 * Revision 1.17  1996/02/14  11:06:02  jont
 * Fixing some compiler warnings under VC++
 *
 * Revision 1.16  1996/01/11  17:23:58  nickb
 * Runtime error message buffer problem.
 *
 * Revision 1.15  1995/12/18  15:58:52  matthew
 * Fixing bungle with last change
 *
 * Revision 1.14  1995/12/18  13:53:27  matthew
 * Adding set_frame_return_value
 *
 * Revision 1.13  1995/11/21  14:32:04  jont
 * Add debugger_double for getting floats straight from spills
 *
 * Revision 1.12  1995/05/30  10:18:09  nickb
 * Add frame_argument function.
 *
 * Revision 1.11  1995/05/24  10:43:27  nickb
 * Fix all the register save frames, not just one.
 *
 * Revision 1.10  1995/05/05  12:04:03  nickb
 * Remove some SPARCisms.
 *
 * Revision 1.9  1995/04/25  13:21:30  nickb
 * Bug in stack_crawl fixing up return addresses.
 *
 * Revision 1.8  1995/03/29  14:13:38  nickb
 * Threads system.
 *
 * Revision 1.7  1995/03/20  13:58:50  matthew
 * Adding is_top_frame function
 *
 * Revision 1.6  1995/03/02  13:52:29  matthew
 * Adding is_ml_frame
 *
 * Revision 1.5  1995/02/27  16:16:14  nickb
 * TYPE_LARGE becomes TYPE_STATIC
 *
 * Revision 1.4  1994/12/02  16:04:03  jont
 * Avoid running off stack tops
 *
 * Revision 1.3  1994/10/12  11:41:31  jont
 * Modify link address fixing to be done for all ml link addresses
 *
 * Revision 1.2  1994/10/07  11:08:06  jont
 * Make it Intel architecture specific
 *
 * Revision 1.1  1994/10/04  16:55:28  jont
 * new file
 *
 * Revision 1.3  1994/06/21  15:58:40  nickh
 * New ancillary structure.
 *
 * Revision 1.2  1994/06/09  14:30:53  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:55:28  nickh
 * new file
 *
 *
 */

#include <assert.h>		/* assert */
#include "mltypes.h"
#include "diagnostic.h"
#include "values.h"
#include "stacks.h"
#include "arena.h"
#include "mem.h"
#include "fixup.h"
#include "environment.h"
#include "state.h"
#include "interface.h"
#include "utils.h"
#include "allocator.h"
#include "ansi.h"
#include "tags.h"
#include "explore.h"
#include "ml_utilities.h"

#include <string.h>

/* First the GC stack-crawling code.
 *
 *  NOTE: This code is highly Intel-specific
 *
 *  This function fixes the stack contents between GC_SP and the
 *  first frame pointer since entry to ML.  fix() is called on any
 *  GC values, and link registers (return addresses) are shifted to
 *  correspond with any movement of code.
 *
 *  On entry GC_SP should point the last save area that needs to be fixed.
 *  This area contains the link register which points into the innermost
 *  executing ML function, i.e., the last link that needs fixing.
 *
 *  The obvious one-pass version of this will not work because a
 *  closure may be referred to by more than one frame.  If the closure
 *  is fixed the first time it is seen then information is lost and
 *  later link registers will not be fixed.
 *
 *  The number of non-GC spills in each frame is fetched from the
 *  first word of the code vector.
 */

#define prev_slot(sp) ((mlval *)((unsigned int)(sp)-4))

#define return_slot(frame,args)      (((mlval*)(frame)->fp)-args-1)
#define return_address(frame,code)   return_slot(frame,CCODEARGS(code))

#define final_frame(sp,thread) ((word)((sp)->fp)==(thread)->ml_state.stack_top)

/* fix a 'non-ML frame', i.e. a frame created in the ML/C interface,
 * consisting solely of GCable values */

static inline mlval *fix_non_ML_frame(struct stack_frame *sp, mlval *to)
{
  mlval *base = prev_slot(sp+1);
  mlval *top = prev_slot(sp->fp);
  if (sp->closure == STACK_EXTENSION) {
    /* then this should be a stack extension frame, and the fp should 
     * lie on a different arena block. Note that "fp is in different arena
     * block" is not a sufficient test for stack extensions, as stack sections
     * can cover more than one arena block, in the case where an ML function
     * has in the past requested a huge stack frame. */
    DIAGNOSTIC(5,"    stack extension frame 0x%08x, fp 0x%08x",sp,sp->fp);
    if (SPACE(top) == SPACE(base) && BLOCK_NR(top) == BLOCK_NR(base)) {
      DIAGNOSTIC(1, "EXTENSION frame [0x%08x,0x%08x] not on block boundary",
		 sp, sp->fp);
    } else {
      top = (mlval*)(BLOCK_BASE(SPACE(base),BLOCK_NR(base)+1));
    }
  }
  while (base < top) {
    fix_reg(to, base);
    base++;
  }
  return to;
}

extern void stack_crawl_phase_one(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;
  DIAGNOSTIC(4, "stack_crawl first pass", 0, 0);

  for (thread = TOP_THREAD.next; thread != &TOP_THREAD; thread =thread->next) {
    mlval *ret_addr;
    DIAGNOSTIC (4, "  thread %d", thread->number,0);
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      /* turn each ML link slot into an offset from the closure code address */
      ret_addr = return_slot(sp,0);
      for(; !final_frame(sp,thread); sp = sp->fp) {
	struct stack_frame *fp = sp->fp;
	if(MLVALISPTR(sp->closure)) {
	  mlval codeptr = FIELD(sp->closure, 0);
	  DIAGNOSTIC(5, "   frame 0x%X  next 0x%X", sp, fp);
	  DIAGNOSTIC(5, "     lr 0x%X from `%s'", *ret_addr,
		     CSTRING(CCODENAME(codeptr)));
	  if (*ret_addr) {
	    assert(pc_in_closure(*ret_addr, sp->closure));
	    *ret_addr -= codeptr;
	  }
	  DIAGNOSTIC(5, "     lr is 0x%X+0x%X", codeptr,
		     ret_addr);
	  ret_addr = return_address(fp, codeptr);
	} else {
	  ret_addr = return_slot(fp,0);
	}
      }
    }
  }
}

extern mlval *stack_crawl_phase_two(mlval *to)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
  DIAGNOSTIC(4, " second pass", 0, 0);
  /* Now fix everything on the stacks,  restoring link slots as we go */

  for (thread = TOP_THREAD.next; thread != &TOP_THREAD; thread =thread->next) {
    DIAGNOSTIC (4, "  thread %d", thread->number,0);
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      mlval *ret_addr = return_slot(sp,0);
      to = fix_non_ML_frame(sp,to);	/* first frame is never an ML frame */
      for(; !final_frame(sp,thread); sp = sp->fp) {
	struct stack_frame *fp = sp->fp;
	DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);
	
	if(MLVALISPTR(sp->closure)) { /* then fp is an ML frame */
	  mlval *top, *base, closure, code;
	  fix(to, &sp->closure);		/* fix the caller's closure */
	  closure = sp->closure;
	  fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	  code = FIELD(closure, 0);

	  /* restore the link address */
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, *ret_addr);
	  if (*ret_addr) {
	    *ret_addr += code;
	  }
	  DIAGNOSTIC(5, "    fixed to 0x%X", *ret_addr, 0);
	  /* scan the arguments */
	  top = (mlval*)(fp->fp);
	  base = top-CCODEARGS(code);
	  scan(base, top, to);

	  /* scan the gc spills and saves */
	  top = (mlval*)(fp->fp) - CCODEARGS(code) - 1
	                         - (CCODENONGC(code));
	  base = prev_slot(fp+1);	 	  /* top of the stack_frame */
	  scan(base, top, to);
	  ret_addr = return_address(fp, code);
	} else {
	  to = fix_non_ML_frame(fp,to);
	  ret_addr = return_slot(fp,0);
	}
      }
    }
  }
  return(to);
}

#ifdef EXPLORER

/* The explorer needs to find any potential roots on the stacks. */

static void explore_non_ML_frame(struct thread_state *thread,
				 struct stack_frame *sp)
{
  mlval *base = prev_slot(sp+1);
  mlval *top = prev_slot(sp->fp);
  if (sp->closure == STACK_EXTENSION) {
    /* then this should be a stack extension frame, and the fp should 
     * lie on a different arena block. Note that "fp is in different arena
     * block" is not a sufficient test for stack extensions, as stack sections
     * can cover more than one arena block, in the case where an ML function
     * has in the past requested a huge stack frame. */
    if (SPACE(top) == SPACE(base) && BLOCK_NR(top) == BLOCK_NR(base)) {
      /* do nothing */
    } else {
      top = (mlval*)(BLOCK_BASE(SPACE(base),BLOCK_NR(base)+1));
    }
  }
  explore_stack_registers(thread,sp,base,top);
}

extern void explore_stacks(void)
{
  struct thread_state *thread;
  struct stack_frame *sp;

  for (thread = TOP_THREAD.next; thread != &TOP_THREAD; thread =thread->next) {
    sp = GC_SP(thread);
    if (!is_stack_top(sp,thread)) {
      explore_non_ML_frame(thread,sp);
      for(; !final_frame(sp,thread); sp = sp->fp) {
	struct stack_frame *fp = sp->fp;
	
	if(MLVALISPTR(sp->closure)) {
	  mlval *top, *base, code;
	  explore_stack_registers(thread,sp,&sp->closure, (&sp->closure)+1);
	  code = FIELD(sp->closure, 0);

	  /* arguments */
	  top = (mlval*)(fp->fp);
	  base = top-CCODEARGS(code);
	  explore_stack_allocated(thread, fp, base, top);

	  /* gc spills and saves */
	  top = (mlval*)(fp->fp) - CCODEARGS(code) - 1
	                         - (CCODENONGC(code));
	  base = prev_slot(fp+1); 		  /* top of the stack_frame */
	  explore_stack_allocated(thread,fp, base, top);
	} else {
	  explore_non_ML_frame(thread, fp);
	}
      }
    }
  }
}

#endif

/* Stack backtrace */

static const char *code_vector_name(word closure)
{
  if (validate_ml_address(&(FIELD(closure, 0)))) {
    word code = FIELD(closure, 0);
    if (validate_ml_address((void *)code) && validate_ml_address((void *)(OBJECT(code)))) {
      if (validate_ml_address(&(CCODEANCILLARY(code))) &&
	  validate_ml_address(&(CCODEANCRECORD(code, NAMES))) &&
	  validate_ml_address(&(CCODEANCVALUE(code, NAMES))) &&
	  validate_ml_address(CSTRING(CCODENAME(code)))) {
	return CSTRING(CCODENAME(code));
      } else {	
	return "invalid code ancillary";
      }
    } else {
      return "invalid code pointer";
    }
  } else {
    return "invalid closure";
  }
}

int max_backtrace_depth = 25;

void backtrace(struct stack_frame *sp, struct thread_state *thread,
	       int depth_max)
{
  message_content("Stack backtrace\n");
  if (!sp)
    message_content("  No stack!\n");
  else if ((word)sp == thread->ml_state.stack_top)
    message_content("  %p empty stack.\n",sp);
  else {
    while(depth_max-- && sp &&
	  (word)sp != thread->ml_state.stack_top) {
      if (validate_address(&sp->closure)) {
	const char *name =
	  MLVALISPTR(sp->closure) ? code_vector_name(sp->closure) :
	  sp->closure == STACK_START ? "stack start" :
	  sp->closure == STACK_DISTURB_EVENT ? "disturb event" :
	  sp->closure == STACK_EXTENSION ? "stack extension" :
	  sp->closure == STACK_RAISE ? "raise" :
	  sp->closure == STACK_EVENT ? "asynchronous event handler" :
	  sp->closure == STACK_C_RAISE ? "raise from C" :
	  sp->closure == STACK_C_CALL ? "call to C" :
	  sp->closure == STACK_INTERCEPT ? "intercept" :
	  sp->closure == STACK_SPACE_PROFILE ? "space profile" : "special";

	message_content("  %p closure 0x%08X: ", sp, sp->closure);
	message_string(name);
	message_string("\n");
      } else {
	message_content("  %p cannot read closure address %p\n",
			sp, &sp->closure);
	break;
      }
      if (validate_address(&sp->fp)) {
	sp = sp->fp;
      } else {
	break;
      }
    }
    if (sp == NULL || (word)sp == thread->ml_state.stack_top)
      message_content("--- base of stack --- \n");
    else if (depth_max > 0 && !validate_address(&sp->fp)) {
      /* Not at top of stack, but address invalid */
      message_content("  %p cannot read frame address %p\n", sp, &sp->fp);
    }
  }
}

mlval is_ml_frame(struct stack_frame *sp)
{
  mlval closure = sp->closure;

  if(ISORDPTR(closure) && validate_ml_address((void *)closure)) {
    mlval secondary = SECONDARY(GETHEADER(closure));
    if(secondary == RECORD || secondary == 0) {
      mlval code = FIELD(closure, 0);
      if(validate_ml_address((void *)code) && PRIMARY(code) == POINTER &&
	 SECONDARY(GETHEADER(code)) == BACKPTR)
	return(code);
    }
  }
  return(MLUNIT);
}

/* Pervasive stack functions */

/* These first few are not I386-specific, assuming we have an fp, the
 * stack is full descending, &c */

static mlval ml_is_ml_frame (mlval frame)
{
  if (is_ml_frame ((struct stack_frame *)frame) == MLUNIT)
    return MLFALSE;
  else
    return MLTRUE;
}

static mlval ml_is_top_frame (mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;
  
  if (is_stack_top(sp->fp,CURRENT_THREAD))
    return (MLTRUE);
  else
    return (MLFALSE);
}

static mlval flush(mlval arg)
{
  return(MLUNIT);
}

static mlval current(mlval arg)
{
  return((mlval)GC_SP(CURRENT_THREAD)->fp);
}

static mlval sub(mlval arg)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(arg, 0);
  int index = CINT(FIELD(arg, 1));

  return(((mlval *)sp)[index]);
}

static mlval update(mlval arg)
{
  ((mlval *)FIELD(arg, 0))[CINT(FIELD(arg, 1))] = FIELD(arg, 2);
  return(MLUNIT);
}

static mlval frame_call(mlval argument)
{
  flush_windows(); /* a nop on non-SPARCs */

  return(callml((mlval)GC_SP(CURRENT_THREAD), argument));
}

static mlval frame_offset(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1));
  return(*((mlval *)(((int)(sp->fp))+index)));
}

static mlval frame_double(mlval argument)
{
  struct stack_frame *sp = (struct stack_frame *)FIELD(argument, 0);
  int index = CINT(FIELD(argument, 1)); /* This is a pointer to an unboxed double */
  mlval real = allocate_real();
  char *ptr = (char *)(((int)(sp->fp))+index);
  memcpy (((char *)real)+(8-POINTER), ptr, 8); /* Copy into double from stack */
  return (real);
}

/* Now these are I386-specific */


/*
 * All the following sizes are in bytes.
 */
#define mlw_i386_call_instr_size 1
#define mlw_i386_call_addr_size 4
#define mlw_i386_call_size (mlw_i386_call_instr_size+mlw_i386_call_addr_size)


/*
 * Returns a triple: (isMLFrame:bool, framePointer:mlval, instrByteOffset:int)
 *
 * The instrByteOffset is only meaningful if the frame is an ML frame
 * and not a fake frame (see .fake-frame below).
 * 
 * If the frame is a C frame then instrByteOffset is 0.
 *
 * It is possible that there are no frames and in that case
 * isMLFrame = false and framePointer = MLUNIT.
 *
 * .fake-frame: In certain cicumstances a fake frame is pushed on the stack 
 * (see <URI:hope//MLWsrc/rts/arch/I386/interface.S#ml_raise>).  Such a frame
 *  can be distinguished from normal frames in two ways :-
 * 
 *   1. The return address in the stack frame is set to zero.
 *   2. The frame above it on the stack will have STACK_RAISE in the closure
 *      field.
 * 
 * The debugger (currently) doesn't have any special knowledge of thse fake 
 * frames and so treats them like any other ML frame.  Consequently the 0 
 * return address has to be dealt with here to avoid the calculation of 
 * instrByteOffset generating a large negative number.
 */

/*
 * This is the offset that is returned in a fake frame.
 * It cannot be 0 because a 0 offset is interpreted as meaning
 * that the frame is a C frame 
 * <URI:hope://MLWsrc/debugger/_newtrace.sml#gather_recipes>
 * It should not match a real offset to avoid the debugger
 * incorrectly deriving a type for the associated function.
 * It probably shouldn't be a negative value so the following
 * is a compromise.
 */
#define mlw_fake_frame_offset 1


static mlval frame_next(mlval arg)
{
  mlval result;
  struct stack_frame *sp = (struct stack_frame *)arg;

  result= allocate_record(3);
  if (!is_stack_top(sp->fp,CURRENT_THREAD)) {
    mlval code= is_ml_frame(sp->fp);
    if(code != MLUNIT) { /* it's an ML frame */
      word code_start_addr= (word)CCODESTART(code);
      mlval sp_code = is_ml_frame(sp);
      word arguments = (sp_code == MLUNIT) ? 0 : CCODEARGS(sp_code);
      word return_addr = *return_slot(sp->fp, arguments);
      word call_offset= return_addr - code_start_addr - mlw_i386_call_size;
      if (return_addr == 0)	/* see .fake_frame */
	call_offset= mlw_fake_frame_offset;
      else
	assert(code_start_addr < return_addr);
      FIELD(result, 0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result, 2) = MLINT(call_offset);
    } else { /* not an ML frame */
      FIELD(result,0) = MLTRUE;
      FIELD(result, 1) = (mlval)sp->fp;
      FIELD(result,2) = MLINT(0);
    }
  } else { /* No frames on the stack! */
    FIELD(result, 0) = MLFALSE;
    FIELD(result, 1) = MLUNIT;
    FIELD(result, 2) = MLINT(0);
  }
  return(result);
}



static mlval frame_argument(mlval frame)
{
  struct stack_frame *sp = (struct stack_frame *)frame;
  mlval code = FIELD(sp->closure,0);
  int saves = CCODESAVES(code);
  struct stack_frame *fp = sp->fp;
  mlval *save_area = (mlval*)(fp+1)-1;
  return (save_area[saves]);
}

static mlval set_frame_return_value(mlval arg)
{
  mlval frame = FIELD (arg,0);
  mlval value = FIELD (arg,1);
  struct stack_frame *sp = (struct stack_frame *)frame;
  mlval code = FIELD(sp->closure,0);
  mlval *mlsp = (mlval *) (frame + (CCODELEAF (code) ? 16 : 20));
  *mlsp = value;
  return (MLUNIT);
}

static mlval frame_allocations(mlval frame)
{
  /* not clear what to do here for Intel; we don't have enough information */
  return MLTRUE;
}

void stacks_init()
{
  env_function("stack flush", flush);
  env_function("stack frame sub", sub);
  env_function("stack frame update", update);
  env_function("stack frame current", current);
  env_function("stack is ml frame", ml_is_ml_frame);
  env_function("stack is top frame", ml_is_top_frame);
  env_function("debugger frame call", frame_call);
  env_function("debugger frame next", frame_next);
  env_function("debugger frame sub", sub);
  env_function("debugger frame offset", frame_offset);
  env_function("debugger frame double", frame_double);
  env_function("debugger frame argument", frame_argument);
  env_function("debugger set frame return value", set_frame_return_value);
  env_function("debugger frame allocations", frame_allocations);
}
@


1.33.1.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a11 4
 * Revision 1.33  1998/09/17  15:22:35  jont
 * [Bug #20124]
 * Remove compiler warning and improve backtrace and is_ml_frame
 *
@


1.32
log
@[Bug #20124]
Stop assuming all code and closures must be on ml heap
@
text
@d12 4
d365 21
d399 3
a401 2
      const char *name =
	MLVALISPTR(sp->closure) ? CSTRING(CCODENAME(FIELD(sp->closure, 0))) :
d412 13
a424 4
      message_content("  %p closure 0x%08X: ", sp, sp->closure);
      message_string(name);
      message_string("\n");
      sp = sp->fp;
d428 4
d439 1
a439 1
  if(ISORDPTR(closure) && validate_address((void *)closure)) {
a441 1
      mlval *object = OBJECT(closure);
d443 1
a443 1
      if(validate_address((void *)code) && PRIMARY(code) == POINTER &&
@


1.31
log
@[Bug #70026]
Allow profiling of stub_c functions, recording the time according
to the name of the runtime system functions
@
text
@d12 5
a276 1

d400 1
a400 1
  if(ISORDPTR(closure)) {
a401 1

d404 4
a407 9

      if(is_ml_heap(object) || is_ml_stack(object)) {
	mlval code = FIELD(closure, 0);

	if((is_ml_heap(OBJECT(code)) || code == stub_c) &&
	   PRIMARY(code) == POINTER &&
	   SECONDARY(GETHEADER(code)) == BACKPTR)
	  return(code);
      }
a409 1

@


1.30
log
@[Bug #70018]
Split stack_crawl into two phases
@
text
@d12 4
d405 1
a405 1
	if(is_ml_heap(OBJECT(code)) &&
@


1.29
log
@[Bug #30242]
Use ml_utilities for function pc_in_clousre when finxing return addresses
@
text
@d12 4
d201 1
a201 1
extern mlval *stack_crawl(mlval *to)
d205 1
a205 3

  DIAGNOSTIC(4, "stack_crawl(to = 0x%X):", to, 0);
  DIAGNOSTIC(4, " first pass", 0, 0);
d234 8
@


1.28
log
@[Bug #30076]
[Bug #30076]
More work for stack parameter passing, getting the gc scan right.
@
text
@d12 4
d136 1
d219 4
a222 1
	  *ret_addr -= codeptr;
d254 3
a256 1
	  *ret_addr += code;
@


1.28.3.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a11 5
 * Revision 1.28  1997/06/05  12:45:56  jont
 * [Bug #30076]
 * [Bug #30076]
 * More work for stack parameter passing, getting the gc scan right.
 *
@


1.28.2.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a11 5
 * Revision 1.28  1997/06/05  12:45:56  jont
 * [Bug #30076]
 * [Bug #30076]
 * More work for stack parameter passing, getting the gc scan right.
 *
@


1.28.1.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a11 5
 * Revision 1.28  1997/06/05  12:45:56  jont
 * [Bug #30076]
 * [Bug #30076]
 * More work for stack parameter passing, getting the gc scan right.
 *
@


1.27
log
@[Bug #30076]
Modify to make NONGC spills be counted in words
@
text
@d12 8
d21 1
a21 1
 * Fx stack_crawl to fit new stack invariants.
d159 2
a160 2
#define link_slot(sp) prev_slot((sp)->fp)
#define lr(sp) (*link_slot(sp))
d201 1
d206 3
a208 1
      for(; !final_frame(sp,thread); sp = sp->fp)
d211 2
a212 2
	  DIAGNOSTIC(5, "   frame 0x%X  next 0x%X", sp, sp->fp);
	  DIAGNOSTIC(5, "     lr 0x%X from `%s'", lr(sp),
d214 6
a219 2
	  lr(sp) -= codeptr;
	  DIAGNOSTIC(5, "     lr is 0x%X+0x%X", codeptr, lr(sp));
d221 1
d231 1
d245 16
a260 9
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, lr(sp));
	  lr(sp) += code;
	  DIAGNOSTIC(5, "    fixed to 0x%X", lr(sp), 0);

	  top = (mlval *)prev_slot(fp->fp) - CCODENONGC(code);
	  base = (mlval *)prev_slot(fp+1); 	  /* top of the stack_frame */
	  scan(base, top, to); /* fix the stack allocated area */

	} else
d262 2
d311 10
a320 3
	  top = (mlval *)prev_slot(fp->fp) - CCODENONGC(code);
	  base = (mlval *)prev_slot(fp+1); 	  /* top of the stack_frame */
	  explore_stack_allocated(thread,fp,base,top);
d520 1
a520 1
    if(code != MLUNIT) {
d522 3
a524 1
      word return_addr= lr(sp->fp);
d533 1
a533 1
    } else {
@


1.26
log
@[Bug #30076]
Modifications to allow stack based parameter passing on the I386
@
text
@d232 1
a232 1
	  top = (mlval *)prev_slot(fp->fp) - (CCODENONGC(code)/sizeof(mlval));
d285 1
a285 1
	  top = (mlval *)prev_slot(fp->fp) - (CCODENONGC(code)/sizeof(mlval));
@


1.25
log
@Fx stack_crawl to fit new stack invariants.
@
text
@d12 3
d232 1
a232 1
	  top = (mlval *)prev_slot(fp->fp) - (CCODESPILLS(code)/sizeof(mlval));
d285 1
a285 1
	  top = (mlval *)prev_slot(fp->fp) - (CCODESPILLS(code)/sizeof(mlval));
@


1.25.5.1
log
@branched from 1.25
@
text
@a11 3
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fx stack_crawl to fit new stack invariants.
 *
@


1.25.5.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a11 3
 * Revision 1.25.5.1  1997/05/12  10:39:54  hope
 * branched from 1.25
 *
@


1.25.5.1.3.2
log
@[Bug #30287]
Workaround for assertion failure
@
text
@a11 3
 * Revision 1.25.5.1.3.1  1997/09/09  14:15:39  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
 *
d496 2
a497 13
      else {
        if (return_addr == 0) {    /* see .fake_frame */
            call_offset= mlw_fake_frame_offset;
        } else if (code_start_addr < return_addr) {
            DIAGNOSTIC(0, "Error in frame_next: code_start_addr = %p,"
                          "return_addr = %p", code_start_addr, return_addr);
            /* Something wrong.  Set call_offset to 0 to allow
             * the debugger to
               run.  This frame will appear as a C frame.  */
            call_offset= 0;
        }
      }

d513 1
@


1.25.5.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a11 3
 * Revision 1.25.5.1  1997/05/12  10:39:54  hope
 * branched from 1.25
 *
@


1.25.5.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a11 3
 * Revision 1.25.5.1  1997/05/12  10:39:54  hope
 * branched from 1.25
 *
@


1.25.5.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a11 3
 * Revision 1.25.5.1.1.1  1997/07/28  18:26:20  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.25.5.1.1.1.1.2
log
@[Bug #30287]
Merging from MLWorks_10r3
Workaround for assertion failure
@
text
@a11 3
 * Revision 1.25.5.1.1.1.1.1  1997/10/07  11:52:10  jkbrook
 * branched from MLWorks_11 for label MLWorks_11r1
 *
d499 2
a500 13
      else {
        if (return_addr == 0) {    /* see .fake_frame */
            call_offset= mlw_fake_frame_offset;
        } else if (code_start_addr < return_addr) {
            DIAGNOSTIC(0, "Error in frame_next: code_start_addr = %p,"
                          "return_addr = %p", code_start_addr, return_addr);
            /* Something wrong.  Set call_offset to 0 to allow
             * the debugger to
               run.  This frame will appear as a C frame.  */
            call_offset= 0;
        }
      }

d516 1
@


1.25.4.1
log
@branched from 1.25
@
text
@a11 3
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fx stack_crawl to fit new stack invariants.
 *
@


1.25.3.1
log
@branched from 1.25
@
text
@a11 3
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fx stack_crawl to fit new stack invariants.
 *
@


1.25.3.1.1.1
log
@branched from 1.25.3.1
@
text
@a11 3
 * Revision 1.25.3.1  1996/12/17  17:52:56  hope
 * branched from 1.25
 *
@


1.25.2.1
log
@branched from 1.25
@
text
@a11 3
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fx stack_crawl to fit new stack invariants.
 *
@


1.25.1.1
log
@branched from 1.25
@
text
@a11 3
 * Revision 1.25  1996/11/18  15:05:31  nickb
 * Fx stack_crawl to fit new stack invariants.
 *
@


1.24
log
@[Bug #1760]
frame_next: Change the offset from 0 to 1 since 0 is used to
indicate that the frame is a C frame.
@
text
@d12 5
d149 1
a149 1
#define lr(sp) ((word)*link_slot(sp))
d153 2
a154 3
/* fix a 'register save frame', i.e. a frame saved when entering C
 * from ML, consisting solely of ML register saves (with no
 * stack-allocated objects or non-gcable values) */
d156 1
a156 1
static inline mlval *fix_reg_save_frame(struct stack_frame *sp, mlval *to)
d160 14
d212 1
a212 1
      int register_save_frame = 1;
d217 1
a217 6
	if (register_save_frame) {
	  to = fix_reg_save_frame(sp,to);
	  register_save_frame = 0;
	}

	if(MLVALISPTR(sp->closure)) {
d230 1
a230 1
	  base = (mlval *)prev_slot(sp->fp+1); 	  /* top of the stack_frame */
d233 2
a234 3
	} else if (sp->closure == STACK_C_CALL)
	  /* the next frame we come to is a register save frame */
	  register_save_frame = 1;
d245 20
d273 1
a273 1
      int register_save_frame = 1;
a276 5
	if (register_save_frame) {
	  explore_stack_registers(thread, sp, (mlval*)sp+1, (mlval*)fp);
	  register_save_frame = 0;
	}

d283 1
a283 1
	  base = (mlval *)prev_slot(sp->fp+1); 	  /* top of the stack_frame */
d285 3
a287 3
	} else if (sp->closure == STACK_C_CALL)
	  /* the next frame we come to is a register save frame */
	  register_save_frame = 1;
@


1.23
log
@[Bug #1760]
See .fake_frame in the comment associated with frame_next.
@
text
@d12 4
a410 1

d436 13
d462 1
a462 1
	call_offset= 0;
@


1.23.1.1
log
@branched from 1.23
@
text
@a11 4
 * Revision 1.23  1996/11/14  09:54:29  stephenb
 * [Bug #1760]
 * See .fake_frame in the comment associated with frame_next.
 *
@


1.23.1.1.1.1
log
@branched from 1.23.1.1
@
text
@a11 3
 * Revision 1.23.1.1  1996/11/14  12:56:14  hope
 * branched from 1.23
 *
@


1.22
log
@[Bug #1461]
Fix stack closure tags.
@
text
@d12 4
d407 26
d445 4
a448 1
      assert(code_start_addr < return_addr);
@


1.21
log
@[Bug #1441]
frame_next: change the offset to be a byte rather than word
offset since instructions are not word aligned on an I386.
@
text
@d12 5
d277 9
a285 10
  	sp->closure == STACK_EXTENSION ? "stack extension" :
	sp->closure == STACK_LEAF_RAISE ? "leaf raise" :
	sp->closure == STACK_RAISE ? "raise" :
	sp->closure == STACK_RESUME ? "resume" :
	sp->closure == STACK_PROFILE ? "profiler" :
	sp->closure == STACK_EVENT ? "asynchronous event handler" :
	sp->closure == STACK_C_RAISE ? "raise from C" : 
	sp->closure == STACK_C_CALL ? "call to C" :
	sp->closure == STACK_START ? "call from C" :
        sp->closure == STACK_INTERCEPT ? "intercept" : "special";
@


1.20
log
@[Bug #1445]
frame_next: adjust the offset calculated for an ML frame so that
it produces values that correctly index into the debugger annotation
tables.
@
text
@d12 6
d87 1
d390 9
d404 1
a404 4
  flush_windows();

  result = allocate_record(3);

d406 1
a406 3
    mlval code;

    code = is_ml_frame(sp->fp);
d408 4
d414 1
a414 1
      FIELD(result, 2) = MLINT((word *)lr(sp->fp) - CCODESTART(code));
a420 1

d427 2
@


1.20.2.1
log
@branched from 1.20
@
text
@a11 6
 * Revision 1.20  1996/10/04  13:05:47  stephenb
 * [Bug #1445]
 * frame_next: adjust the offset calculated for an ML frame so that
 * it produces values that correctly index into the debugger annotation
 * tables.
 *
@


1.20.1.1
log
@branched from 1.20
@
text
@a11 6
 * Revision 1.20  1996/10/04  13:05:47  stephenb
 * [Bug #1445]
 * frame_next: adjust the offset calculated for an ML frame so that
 * it produces values that correctly index into the debugger annotation
 * tables.
 *
@


1.19
log
@ISPTR becomes MLVALISPTR
@
text
@d12 3
d399 1
a399 1
      FIELD(result, 2) = MLINT((word *)sp->lr - CCODESTART(code));
@


1.19.1.1
log
@branched from 1.19
@
text
@a11 3
 * Revision 1.19  1996/02/14  17:35:14  jont
 * ISPTR becomes MLVALISPTR
 *
@


1.18
log
@Add heap-exploration hooks.
@
text
@d12 3
d154 1
a154 1
	if(ISPTR(sp->closure)) {
d181 1
a181 1
	if(ISPTR(sp->closure)) {
d227 1
a227 1
	if(ISPTR(sp->closure)) {
d261 1
a261 1
	ISPTR(sp->closure) ? CSTRING(CCODENAME(FIELD(sp->closure, 0))) :
@


1.17
log
@Fixing some compiler warnings under VC++
@
text
@d12 3
d89 1
d202 39
@


1.16
log
@Runtime error message buffer problem.
@
text
@d12 3
d86 2
@


1.15
log
@Fixing bungle with last change
@
text
@d12 3
d222 3
a224 1
	message_content("  %p closure 0x%08X: %s\n", sp, sp->closure, name);
@


1.14
log
@Adding set_frame_return_value
@
text
@d12 3
d371 1
a371 1
  mlval *mlsp = (mlval *) (frame + CCODELEAF (code) ? 16 : 20);
a375 9
static mlval set_frame_return_value(mlval arg)
{
  mlval frame = FIELD (arg,0);
  mlval value = FIELD (arg,1);
  mlval *sp = (mlval *)(frame+76);
  *sp = value;
  return (MLUNIT);
}

d396 1
@


1.13
log
@Add debugger_double for getting floats straight from spills
@
text
@d12 3
d360 20
@


1.12
log
@Add frame_argument function.
@
text
@d12 3
d73 1
d306 11
a316 1
/* Now these are SPARC-specific */
d377 1
@


1.11
log
@Fix all the register save frames, not just one.
@
text
@d12 3
d335 10
d363 1
@


1.10
log
@Remove some SPARCisms.
@
text
@d12 3
d97 15
d143 1
a143 9
      /* fix registers saved in first frame */
      mlval *base = prev_slot(sp+1);
      mlval *top = prev_slot(sp->fp);
      while (base < top) {
	fix_reg(to, base);
	base++;
      }
      /* Now fix all other saved values in all other frames */
      
d147 5
d154 1
a154 1
	  mlval closure, code;
d164 1
d167 1
d169 3
a171 2
	  scan(base, top, to); /* fix the stack allocated area */
	}
@


1.9
log
@Bug in stack_crawl fixing up return addresses.
@
text
@d1 1
a1 1
/*  === SPARC STACK ROUTINES ===
d12 3
d105 1
a105 1
    if (sp && ((word)sp != thread->ml_state.stack_top)) {
d124 1
a124 2
    if (sp && ((word)sp != thread->ml_state.stack_top)) {

a195 3
/* An I386 stack frame contains ML values iff its frame pointer points
 * into an ML stack area. */

d200 1
a200 2
  if(is_ml_stack(sp->fp) && ISORDPTR(closure))
  {
d203 1
a203 2
    if(secondary == RECORD || secondary == 0)
    {
d206 1
a206 2
      if(is_ml_heap(object) || is_ml_stack(object))
      {
d209 3
a211 2
	if(is_ml_heap(OBJECT(code)) && PRIMARY(code) == POINTER &&
	   (SECONDARY(GETHEADER(code)) == CODE || SECONDARY(GETHEADER(code)) == BACKPTR))
d237 1
a237 1
  if (sp->fp == CURRENT_THREAD->ml_state.stack_top)
d269 1
a269 1
  flush_windows();
d292 1
a292 2
  while(sp->fp != NULL)
  {
a299 2

      return(result);
a303 2
	
      return(result);
d305 1
d307 3
a309 1
    sp = sp->fp;
a310 7

  /* No frames on the stack! */

  FIELD(result, 0) = MLFALSE;
  FIELD(result, 1) = MLUNIT;
  FIELD(result, 2) = MLINT(0);

d316 2
a317 16
  struct stack_frame *sp = (struct stack_frame *)frame;

  if (((int)sp) < 0)
    return(MLFALSE);
    
  switch(((int)(sp->fp))-((int)(sp))-64)
    {
      case 0 : 
	{
	  return(MLFALSE);
	}
      default :
	{
	  return(MLTRUE);
	}
    }
@


1.8
log
@Threads system.
@
text
@d12 3
d84 1
a84 1
#define prev_slot(sp) (mlval *)(((unsigned int)(sp))-4)
d86 2
a87 2
#define lr_addr(sp) (word *)(prev_slot((sp)->fp))
#define lr_val(sp) *(lr_addr(sp))
d105 1
a105 1
	if(SPACE_TYPE(sp->lr) == TYPE_FROM) {
d108 1
a108 1
	  DIAGNOSTIC(5, "     lr 0x%X from `%s'", lr_val(sp),
d110 2
a111 2
	  lr_val(sp) -= codeptr;
	  DIAGNOSTIC(5, "     lr is 0x%X+0x%X", codeptr, lr_val(sp));
d144 3
a146 3
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, lr_val(sp));
	  lr_val(sp) += code;
	  DIAGNOSTIC(5, "    fixed to 0x%X", lr_val(sp), 0);
@


1.7
log
@Adding is_top_frame function
@
text
@d12 3
d61 1
a61 2
 *  NOTE: 1. This code is highly SPARC-specific
 *        2. Register windows need to have been flushed before entry
a80 3
#define final_frame(sp) (((sp)->fp) == top_stack_pointer)

#define next_slot(sp) (mlval *)(((unsigned int)(sp))+4)
d86 1
a86 1
#define in_ml_space(ptr) ((SPACE_TYPE(ptr) == TYPE_FROM) || (SPACE_TYPE(ptr) == TYPE_GEN) || (SPACE_TYPE(ptr) == TYPE_STATIC))
a87 2
struct stack_frame *top_stack_pointer = NULL;

d90 2
a91 1
  struct stack_frame *sp = GC_SP;
d96 14
a109 13
  if (sp != top_stack_pointer && TYPE(sp->fp) == TYPE_STACK) {
    /* turn each ML link slot into an offset from the closure code address */
    for(sp = GC_SP; !final_frame(sp); sp = sp->fp)
      if(TYPE(sp->fp) == TYPE_STACK && ISORDPTR(sp->closure)) {

	DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, sp->fp);
	DIAGNOSTIC(5, "    lr 0x%X from `%s'", lr_val(sp),
		   CSTRING(CCODENAME(FIELD(sp->closure, 0))));
	/* Note that the lr and closure for it are in the same frame for the I386 */

	*lr_addr(sp) -= FIELD(sp->closure, 0); /* NB: no longer aligned */

	DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(sp->closure, 0), sp->lr);
d111 3
d115 16
a130 7
    DIAGNOSTIC(4, " second pass", 0, 0);

    /* Now fix everything on the stack, restoring the link slots as we go */

    for(sp = GC_SP; (sp != top_stack_pointer) && !(final_frame(sp)); sp = sp->fp) {
      struct stack_frame *fp = sp->fp;
      if (TYPE(sp->fp) == TYPE_STACK) {
d133 2
a134 2
	if(ISORDPTR(sp->closure)) {
	  mlval *top, closure, code;
d140 1
a140 1
	  /* Always restore the link address */
d142 4
a145 2
	  *lr_addr(sp) += code;
	  DIAGNOSTIC(5, "    fixed to 0x%X", lr_addr(sp), 0);
d147 1
a147 3
	  top = (mlval *)prev_slot(fp->fp) - (CCODESPILLS(code)/sizeof(mlval));
	  scan((mlval *)(prev_slot(sp->fp+1)), top, to); /* fix the stack allocated area */
	  /* prev_slot(sp->fp+1) is the top of the struct stack_frame */
a148 2
	/* Now fix the register slots */
	/* There are none of these on the I386 */
a150 8
    sp = GC_SP;
    if(sp != top_stack_pointer && TYPE(sp->fp) == TYPE_STACK) {
      mlval *base = prev_slot(sp+1);	/* Point just above the saved closure*/
					/* The lr is at the top of the frame */
      mlval *top = prev_slot(sp->fp);	/* Point just below the return address */
      while (base < top) { fix_reg(to, base); base++; };
      /* Note, top will need to be revised when floating point is saved */
    }
d159 2
a160 1
void backtrace(FILE *stream, struct stack_frame *sp, int depth_max)
d162 8
a169 9
  fprintf(stream, "Stack backtrace\n");
  fprintf(stream, "  %p closure 0x%08X\n", sp, sp->closure);

  while(depth_max--)
  {
    struct stack_frame *fp = sp->fp;

    if(is_ml_stack(fp))
    {
d171 11
a181 11
	ISPTR(fp->closure) ? CSTRING(CCODENAME(FIELD(fp->closure, 0))) :
	fp->closure == STACK_EXTENSION ? "stack extension" :
	fp->closure == STACK_LEAF_RAISE ? "leaf raise" :
	fp->closure == STACK_RAISE ? "raise" :
	fp->closure == STACK_RESUME ? "resume" :
	fp->closure == STACK_PROFILE ? "profiler" :
	fp->closure == STACK_EVENT ? "asynchronous event handler" :
	fp->closure == STACK_C_RAISE ? "raise from C" : 
	fp->closure == STACK_C_CALL ? "call to C" :
	fp->closure == STACK_START ? "ML stack start" :
        fp->closure == STACK_INTERCEPT ? "intercept" : "special";
d183 2
a184 1
      fprintf(stream, "  %p closure 0x%08X: %s\n", fp, fp->closure, name);
d186 2
a187 4

    if final_frame(sp) break;

    sp = sp->fp;
d220 5
d227 4
a230 1
  return (is_ml_frame ((struct stack_frame *)frame) == MLUNIT ? MLFALSE : MLTRUE);
a232 1
/* Possibly bogus */
d237 1
a237 1
  if (final_frame (sp))
a242 5
/* Pervasive stack functions */

/* These first few are not I386-specific, assuming we have an fp, the
 * stack is full descending, &c */

d250 1
a250 1
  return((mlval)ml_state.sp->fp);
d271 1
a271 1
  return(callml((mlval)ml_state.sp, argument));
d281 1
a281 1
/* Now these are machine specific */
@


1.6
log
@Adding is_ml_frame
@
text
@d12 3
d225 11
d279 1
a279 1
/* Now these are SPARC-specific */
d348 1
@


1.5
log
@TYPE_LARGE becomes TYPE_STATIC
@
text
@d12 3
d217 5
d333 1
@


1.4
log
@Avoid running off stack tops
@
text
@d12 3
d81 1
a81 1
#define in_ml_space(ptr) ((SPACE_TYPE(ptr) == TYPE_FROM) || (SPACE_TYPE(ptr) == TYPE_GEN) || (SPACE_TYPE(ptr) == TYPE_LARGE))
@


1.3
log
@Modify link address fixing to be done for all ml link addresses
@
text
@d12 3
a85 3
  mlval *base = prev_slot(sp+1);	/* Point just above the saved closure*/
					/* The lr is at the top of the frame */
  mlval *top = prev_slot(sp->fp);	/* Point just below the return address */
d135 3
d154 1
a154 1
  while(depth_max-- && sp->fp)
d175 2
@


1.2
log
@Make it Intel architecture specific
@
text
@d12 3
d75 2
d92 1
a92 1
      if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(lr_val(sp)) == TYPE_FROM) {
d113 1
a113 1
	if(ISPTR(sp->closure)) {
d120 4
a123 6
	  /* if the link address is unaligned, it must be restored: */
	  if(word_align(lr_val(sp)) != lr_val(sp)) {
	    DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, lr_val(sp));
	    *lr_addr(sp) += code;
	    DIAGNOSTIC(5, "    fixed to 0x%X", lr_addr(sp), 0);
	  }
@


1.1
log
@new file
@
text
@d11 4
a14 1
 *  $Log: src:arch:SPARC:stacks.c,v $
d64 10
d78 3
a81 1
  flush_windows();
d84 9
a92 4
  /* turn each ML link slot into an offset from the closure code address */
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
    if(TYPE(sp->fp) == TYPE_STACK && SPACE_TYPE(sp->lr) == TYPE_FROM) {
      struct stack_frame *fp = sp->fp;
d94 1
a94 5
      DIAGNOSTIC(5, "  frame 0x%X  next 0x%X", sp, fp);
      DIAGNOSTIC(5, "    lr 0x%X from `%s'", sp->lr,
		 CSTRING(CCODENAME(FIELD(fp->closure, 0))));
      
      sp->lr -= FIELD(fp->closure, 0); /* NB: no longer aligned */
d96 1
a96 1
      DIAGNOSTIC(5, "    lr is 0x%X+0x%X", FIELD(fp->closure, 0), sp->lr);
d99 1
a99 1
  DIAGNOSTIC(4, " second pass", 0, 0);
d101 1
a101 1
  /* Now fix everything on the stack, restoring the link slots as we go */
d103 4
a106 5
  for(sp = GC_SP; sp != NULL; sp = sp->fp)
  {
    struct stack_frame *fp = sp->fp;
    if (TYPE(sp->fp) == TYPE_STACK) {
      DIAGNOSTIC(5, "  frame 0x%X (to = 0x%X)", sp, to);
d108 17
a124 12
      if(ISPTR(fp->closure)) {
	mlval *top, closure, code;
	fix(to, &fp->closure);		/* fix the caller's closure */
	closure = fp->closure;
	fix(to, &FIELD(closure, 0));	/* fix the caller's code vector */
	code = FIELD(closure, 0);

	/* if the link address is unaligned, it must be restored: */
	if(word_align(sp->lr) != sp->lr) {
	  DIAGNOSTIC(5, "    lr is 0x%X+0x%X", code, sp->lr);
	  sp->lr += code;    
	  DIAGNOSTIC(5, "    fixed to 0x%X", sp->lr, 0);
d126 2
a127 4

	top = (mlval *)fp->fp - (CCODESPILLS(code)/sizeof(mlval));
	scan((mlval *)(sp->fp+1), top, to); /* fix the stack allocated area */
			/* sp->fp+1 is the top of the struct stack_frame */
d129 5
a133 7
      /* Now fix the register slots */
      fix_reg(to, &sp->l0); fix_reg(to, &sp->l1); fix_reg(to, &sp->l2);
      fix_reg(to, &sp->l3); fix_reg(to, &sp->l4); fix_reg(to, &sp->l5);
      fix_reg(to, &sp->l6); fix_reg(to, &sp->l7);

      fix_reg(to, &sp->i0); fix_reg(to, &sp->closure); fix_reg(to, &sp->i2);
      fix_reg(to, &sp->i3); fix_reg(to, &sp->i4); fix_reg(to, &sp->i5);
d174 1
a174 1
/* A SPARC stack frame contains ML values iff its frame pointer points
d205 1
a205 1
/* These first few are not SPARC-specific, assuming we have an fp, the
a209 1
  flush_windows();		/* I assume this is a nop on non-SPARCs */
@
