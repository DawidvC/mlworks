head	1.7;
access;
symbols
	MLW_daveb_inline_1_4_99:1.7.13
	MLWorks_21c0_1999_03_25:1.7
	MLWorks_20c1_1998_08_20:1.7
	MLWorks_20c0_1998_08_04:1.7
	MLWorks_20b2c2_1998_06_19:1.7
	MLWorks_20b2_Windows_1998_06_12:1.7
	MLWorks_20b1c1_1998_05_07:1.7
	MLWorks_20b0_1998_04_07:1.7
	MLWorks_20b0_1998_03_20:1.7
	MLWorks_20m2_1998_02_16:1.7
	MLWorks_MM_adapt:1.7.12
	MLWorks_20m1_1997_10_23:1.7
	MLWorks_11r1:1.7.9.1.1.1.1
	MLWorks_workspace_97:1.7.11
	MLWorks_dt_wizard:1.7.10
	MLWorks_11c0_1997_09_09:1.7.9.1.1.1
	MLWorks_10r3:1.7.9.1.3
	MLWorks_10r2_551:1.7.9.1.2
	MLWorks_11:1.7.9.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.7.9.1
	MLWorks_20m0_1997_06_20:1.7
	MLWorks_1_0_r2c2_1997_06_14:1.7.9.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.7.9.1
	MLWorks_1_0_r2c1_1997_05_12:1.7.9
	MLWorks_BugFix_1997_04_24:1.7
	MLWorks_1_0_r2_Win32_1997_04_11:1.7
	MLWorks_1_0_r2_Unix_1997_04_04:1.7
	MM_ML_release_korma_1997_04_01:1.7
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.7.1.1
	MLWorks_gui_1996_12_18:1.7.8
	MLWorks_1_0_Win32_1996_12_17:1.7.7
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.4.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.4.1
	JFHrts:1.7.6
	MLWorks_1_0_Irix_1996_11_28:1.7.4.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.5
	MLWorks_1_0_Unix_1996_11_14:1.7.4
	MLWorks_Open_Beta2_1996_10_11:1.7.3
	MLWorks_License_dev:1.7.2
	MLWorks_1_open_beta_1996_09_13:1.7.1
	MLWorks_Open_Beta_1996_08_22:1.7
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6;
locks; strict;
comment	@ * @;


1.7
date	96.08.19.15.56.25;	author nickb;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1
	1.7.6.1
	1.7.7.1
	1.7.8.1
	1.7.9.1
	1.7.10.1
	1.7.11.1
	1.7.12.1
	1.7.13.1;
next	1.6;

1.6
date	96.05.13.14.57.23;	author nickb;	state Exp;
branches;
next	1.5;

1.5
date	96.02.14.15.58.12;	author jont;	state Exp;
branches;
next	1.4;

1.4
date	95.08.21.16.28.31;	author jont;	state Exp;
branches;
next	1.3;

1.3
date	95.06.23.10.09.11;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	95.05.31.09.30.55;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.51.30;	author jont;	state Exp;
branches;
next	;

1.7.1.1
date	96.09.13.11.22.48;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.10.07.16.12.56;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.10.17.11.32.10;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.11.14.12.58.10;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	96.11.28.15.08.05;	author hope;	state Exp;
branches;
next	;

1.7.5.1
date	96.11.22.18.15.45;	author hope;	state Exp;
branches;
next	;

1.7.6.1
date	96.12.17.10.02.28;	author hope;	state Exp;
branches;
next	;

1.7.7.1
date	96.12.17.17.54.12;	author hope;	state Exp;
branches
	1.7.7.1.1.1;
next	;

1.7.7.1.1.1
date	97.02.24.11.45.15;	author hope;	state Exp;
branches;
next	;

1.7.8.1
date	96.12.18.09.48.48;	author hope;	state Exp;
branches;
next	;

1.7.9.1
date	97.05.12.10.41.11;	author hope;	state Exp;
branches
	1.7.9.1.1.1
	1.7.9.1.2.1
	1.7.9.1.3.1;
next	;

1.7.9.1.1.1
date	97.07.28.18.25.17;	author daveb;	state Exp;
branches
	1.7.9.1.1.1.1.1;
next	;

1.7.9.1.1.1.1.1
date	97.10.07.11.51.11;	author jkbrook;	state Exp;
branches;
next	;

1.7.9.1.2.1
date	97.09.08.17.18.32;	author daveb;	state Exp;
branches;
next	;

1.7.9.1.3.1
date	97.09.09.14.14.41;	author daveb;	state Exp;
branches;
next	;

1.7.10.1
date	97.09.10.19.31.18;	author brucem;	state Exp;
branches;
next	;

1.7.11.1
date	97.09.11.21.00.49;	author daveb;	state Exp;
branches;
next	;

1.7.12.1
date	97.10.31.13.43.50;	author nickb;	state Exp;
branches;
next	;

1.7.13.1
date	99.04.01.18.00.48;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.7
log
@Change error behaviour.
@
text
@/* ==== I386 FIX: COLLECT ONE OBJECT ====
 * 
 *  Copyright (C) 1994 Harlequin Ltd.
 * 
 *  Description
 *  -----------
 *  mach_fixup() is the most critical garbage collection routine; the
 *  GC spends most time here, even when the code is highly tweaked.
 *  This file contains an I386 assembly language version of the
 *  fixup() subroutine (in fixup.c), which is called in gc.c when
 *  MACH_FIXUP is defined.  Have a look in fixup.h for documentation
 *  of the purpose of fixup().
 *  
 *  This file also contains extensive notes on the cost of fixup() and
 *  its principal caller, the scan() macro in gc.c, and on means of
 *  improving their performance by about 30%.
 *  
 *  The code here is full of clever tricks and implicit dependencies.
 *  Modify with extreme care, and test rigorously (just recompiling
 *  MLWorks is insufficient).
 * 
 *  Revision Log
 *  ------------
 *  $Log: src:arch:I386:mach_fixup.S,v $
 * Revision 1.6  1996/05/13  14:57:23  nickb
 * Remove an out-of-date conditionalized instruction.
 *
 * Revision 1.5  1996/02/14  15:58:12  jont
 * Changing ERROR to MLERROR
 *
 * Revision 1.4  1995/08/21  16:28:31  jont
 * Change SPARC to I386
 *
 * Revision 1.3  1995/06/23  10:09:11  jont
 * Modify to work under NT as well
 *
 * Revision 1.2  1995/05/31  09:30:55  jont
 * Produce first version in I386 machine code
 *
 * Revision 1.1  1994/10/04  16:51:30  jont
 * new file
 *
 * Revision 1.5  1994/08/10  11:50:41  nickh
 * Fix another bug in bytearray copying (a dumb typo).
 *
 * Revision 1.4  1994/07/06  13:38:46  nickh
 * Asm and C name prefixes differ according to OS.
 *
 * Revision 1.3  1994/06/15  09:31:47  nickh
 * Fix bug in copying bytearrays.
 *
 * Revision 1.2  1994/06/09  14:31:07  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:55:46  nickh
 * new file
 *
 *  Revision 1.13  1994/02/07  16:42:13  nickh
 *  increase stack frame size; this is _not_ a leaf function!
 * 
 *  Revision 1.12  1994/02/07  13:53:58  nickh
 *  Got bytearrays and boxed double floats right.
 * 
 *  Revision 1.11  1994/01/25  16:43:49  nickh
 *  Removed int test (which is now in the fix() macro).
 * 
 *  Revision 1.10  1993/03/25  11:32:00  jont
 *  Fixed handling of byte arrays as ref tagged items
 * 
 *  Revision 1.9  1993/02/03  17:53:33  jont
 *  Shortened some of the critical loops
 * 
 *  Revision 1.8  1992/11/12  13:32:04  richard
 *  Changed fixup errors to print a message and attempt to continue
 *  rather than exiting straight away.
 * 
 *  Revision 1.7  1992/08/05  17:37:34  richard
 *  Code vectors are now tagged differently to strings.
 * 
 *  Revision 1.6  1992/07/31  09:05:41  richard
 *  Changed the memory organisation.  This required a couple of small
 *  changes to do with what were previously `block types'.
 * 
 *  Revision 1.5  1992/06/23  10:30:30  richard
 *  Added marking code for large objects.
 * 
 *  Revision 1.4  1992/05/19  13:51:36  richard
 *  Increased the size of the secondary switch table to catch more
 *  illegal secondary tags.
 * 
 *  Revision 1.3  1992/04/14  16:08:30  richard
 *  Converted to use m4 macro processor and renamed to fixup.m4s.
 * 
 *  Revision 1.2  1992/04/06  10:47:45  richard
 *  Corrected a fault in backpointer code.
 * 
 *  Revision 1.1  1992/04/03  10:46:59  richard
 *  Initial revision
 */

/*
 * This version is based in the MIPS implementation
 */

#include "tags.h"
#include "naming.h"

/* === FIX AN ML VALUE ===

 Parameters:
   0(esp)   Link
   4(esp)   Where to copy objects to
   8(esp)   Pointer to value to fix
   12(esp)  Contents of that value
 Returns:
   eax      Where to copy to next

 Registers:
   esp      Stack pointer
   ebp      Frame pointer (callee save)
   ebx      Callee save
   esi      Callee save
   edi      Callee save
   ecx      Caller save
   edx      Caller save
*/
	.global C_NAME(mach_fixup)
C_NAME(mach_fixup):
	lea	C_NAME(space_type), %edx /* Access the space_type info */
	mov	12(%esp), %ecx		/* The value we're fixing */
	shr	$24, %ecx		/* Get index into space type table */
	movb	0(%ecx, %edx), %al	/* Index the table */ /* Compiled wrong */
	mov	12(%esp), %ecx
	shr	$3, %ecx		/* Remove primary tag from *what */
	cmpb	$2, %al			/* 2 = TYPE_FROM *//* Compiled wrong */
	je	fix1			/* Branch if from */
	cmpb	$5, %al			/* 5 = 	TYPE_STATIC */
	je	static			/* Return if not static */

return:	mov	4(%esp), %eax		/* Return to */
	ret

/* pointer to a static object. There are three cases:
 * - POINTER to shared closure: must step backwards; 
 * - POINTER to BACKPTR: must skip backwards;
 * - any other pointer.
 */
static:
/* value is in static
 * stack as for mach_fixup
 * callee saves as for mach_fixup
 * eax unknown
 * ecx header address >> 3
 * edx space table
 */
	mov	12(%esp), %edx		/* *what */
	shl	$3, %ecx		/* Header address for static object */
	andl	$7, %edx		/* Primary tag */
	cmp	$POINTER, %edx		/* Is it a standard pointer? */
	jne	static_return		/* Just return to if not */
static_loop:
	mov	0(%ecx), %edx		/* The header word */
	subl	$8, %ecx		/* loop to find a true header */
	test	%edx, %edx		/* Header 0? */
	je	static_loop		/* Loop if so */
	mov	%edx, %eax
	add	$8, %ecx		/* Correct overshoot */
	and	$63, %eax		/* Secondary tag */
	cmp	$BACKPTR, %eax		/* Is it backptr? */
	jne	static_return		/* Branch if not */
	shr	$6, %edx		/* Get back pointer length */
	sub	%edx, %ecx		/* And pointer to true header */
static_return:
	movl	$0, -4(%ecx)		/* Clear the mark word */
	mov	4(%esp), %eax		/* Return to */
	ret

fix1:
/* value is in fromspace
 * stack as for mach_fixup
 * callee saves as for mach_fixup
 * eax unknown
 * ecx header address >> 3
 * edx space table
 */
	shl	$3, %ecx		/* Header address for from object */
	mov	0(%ecx), %edx		/* Value at start */
	cmp	$EVACUATED, %edx	/* Is the object evacuated? */
	jne	notevac			/* Jump if not */
	mov	4(%ecx), %ecx		/* Get forwarding pointer */
	mov	8(%esp), %edx		/* Get what */
	mov	%ecx, 0(%edx)		/* Update what with forwarding pointer */
	mov	4(%esp), %eax		/* Return to */
	ret

notevac:
/* value is in fromspace and not already evacuated.
 * stack as for mach_fixup
 * callee saves as for mach_fixup
 * eax unknown
 * ecx header address
 * edx *(header address)
 */
/* Time for some more free registers */
	push	%ebx
	push	%esi
	push	%edi
	mov	24(%esp), %ebx		/* *what */
	mov	16(%esp), %esi		/* to */
	and	$7, %ebx		/* Get its primary tag */
	mov	%esi, %edi		/* A copy of to */
	add	%ebx, %edi		/* New tagged value in to space */
	cmp	$PAIRPTR, %ebx		/* Is it a pair? */
	mov	4(%ecx), %eax		/* Get the second of the (potential) pair */
	jne	not_a_pair		/* Branch if not */
	movl	$EVACUATED, 0(%ecx)	/* Mark the pair evacuated */
	mov	%edi, 4(%ecx)		/* And put in the forwarding pointer */
	mov	%eax, 4(%esi)		/* Copy the second of the pair */
	mov	%edx, 0(%esi)		/* Copy the first of the pair */
	mov	20(%esp), %ebx		/* what */
	lea	8(%esi), %eax		/* New value of to */
	mov	%edi, 0(%ebx)		/* Fix the root */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret				/* Return to */

not_a_pair:
/* value is in fromspace and not already evacuated, and not a pair
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (first element of value)
 * esi to
 * edi tagged to
 */
	cmp	$POINTER, %ebx		/* Is it a standard pointer? */
	mov	%edx, %esi		/* Prepare to get secondary tag */
	jne	not_a_ptr		/* Jump if not */
	and	$63, %esi		/* Get secondary tag */
	cmp	$RECORD, %esi		/* Is this a record? */
	jne	not_a_record		/* Branch if not */
	mov	%edx, %esi		/* Prepare to get length */
	shr	$6, %esi		/* Length */
record:
/* Value is a record
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (header itself)
 * esi length
 * edi tagged to
 */
	mov	20(%esp), %ebx		/* what */
	mov	%edi, 4(%ecx)		/* Put in forwarding pointer */
	mov	%edi, 0(%ebx)		/* Fix *what */
	movl	$EVACUATED, 0(%ecx)	/* Mark as forwarded */
	mov	16(%esp), %edi		/* to */
	sub	$2, %esi		/* Length -= 2 */
	mov	%edx, 0(%edi)		/* Save header */
	mov	%eax, 4(%edi)		/* Save first element */
	jl	copy1			/* Branch if finished */

copy0:	mov	8(%ecx), %edx
	mov	12(%ecx), %eax		/* Get two values from fromspace */
	add	$8, %edi
	add	$8, %ecx		/* Increment from and to pointers */
	mov	%edx, 0(%edi)
	sub	$2, %esi		/* Decrement length */
	mov	%eax, 4(%edi)		/* Save two values */
	jge	copy0			/* Loop if more to go */

copy1:	lea	8(%edi), %eax		/* New value of to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret				/* Return to */

not_a_record:
/* Value is standardly tagged but not a record
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (header itself)
 * esi secondary tag
 * edi tagged to
 */
/* catch string and bytearray headers here, as we can do so for one extra
 * instruction and it will catch boxed reals (which have standard POINTERs
 * to 12-byte BYTEARRAY-headed objects). */

	push	%ebp
	mov	%esi, %ebp
	and	$47, %ebp		/* Strings and bytearrays */
	cmp	$STRING, %ebp
	jne	not_a_string
	lea	192(%edx), %esi		/* Prepare to get length */
	pop	%ebp
	shr	$8, %esi		/* Length (commuted the +3 with the >> 6) */
	jmp	record	

not_a_string:
/* Value is standardly tagged but not a record or a string
 * 0(esp)  saved value of ebp
 * 4(esp)  saved value of edi
 * 8(esp)  saved value of esi
 * 12(esp) saved value of ebx
 * 16(esp) link
 * 20(esp) to
 * 24(esp) what
 * 28(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (header itself)
 * esi secondary tag
 * edi tagged to
 * ebp secondary tag & 47
 */

	cmp	$BACKPTR, %esi		/* Partway through some code? */
	jne	not_a_backptr		/* Branch if not */
/* Don't need
 * ebx : we know the tag, it's 005
 * esi : we know it's BACKPTR
 * ebp : became irrelevant when we knew we didn't have a string
 */
	mov	%edx, %esi		/* The header */
	mov	%ecx, %ebx		/* Copy of original */
	shr	$6, %esi		/* The length (back) */
	mov	%ecx, %ebp		/* Pointer to original */
	sub	%esi, %ecx		/* Point to start of original */
	mov	0(%ecx), %edx		/* Real header */
	mov	4(%ecx), %eax		/* Next word */
	cmp	$EVACUATED, %edx	/* Already done? */
	jne	back0			/* Branch if not */
	add	%esi, %eax		/* New value = forward + offset */
	mov	24(%esp), %ebx		/* what */
	mov	%edx, 0(%ebp)		/* Mark original evacuated */
	mov	%eax, 4(%ebp)		/* Forward the original */
	mov	%eax, 0(%ebx)		/* Fix *what */
	pop	%ebp
	mov	16(%esp), %eax		/* Ready to return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret				/* Return to */

back0:
/* Value is an unforwarded back pointer
 * 0(esp)  saved value of ebp
 * 4(esp)  saved value of edi
 * 8(esp)  saved value of esi
 * 12(esp) saved value of ebx
 * 16(esp) link
 * 20(esp) to
 * 24(esp) what
 * 28(esp) *what
 * 
 * eax second element of value
 * ebx pointer to original backptr
 * ecx header address of entire code object
 * edx *(header address) (header itself)
 * esi length back to start
 * edi tagged to
 * ebp header address where backptr found
 */

	movl	$EVACUATED, 0(%ecx)	/* Mark object */
	mov	%edi, 4(%ecx)		/* Forward it */
	add	%esi, %edi		/* Compute fix for original */
	push	%edi			/* Can't use this until we've done the copying */
	mov	%edx, %esi
	mov	24(%esp), %edi		/* to */
	shr	$6, %esi		/* Compute length of full object */
	mov	%edx, 0(%edi)
	mov	%eax, 4(%edi)		/* Save header and first word */
	sub	$2, %esi		/* Length -= 2 */

/* now loop, copying the rest of the object */
bkcopy:	mov	8(%ecx), %edx
	mov	12(%ecx), %eax		/* Get two values from fromspace */
	add	$8, %edi
	add	$8, %ecx		/* Increment from and to pointers */
	mov	%edx, 0(%edi)
	sub	$2, %esi		/* Decrement length */
	mov	%eax, 4(%edi)		/* Save two values */
	jge	bkcopy			/* Loop if more to go */

/* can't mark or forward the original until we've done the copy! */
	mov	%ebp, %ecx
	lea	8(%edi), %eax		/* Value of to for return */
	pop	%edi
	movl	$EVACUATED, 0(%ecx)	/* Mark original evacuated */
	mov	%edi, 4(%ecx)		/* Forward original */
	mov	24(%esp), %ebx		/* what */
	pop	%ebp
	mov	%edi, 0(%ebx)		/* Fix *what */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret				/* Return to */
not_a_backptr:
/* Value is standardly tagged but not a record or a string or a backptr
 * 0(esp)  saved value of ebp
 * 4(esp)  saved value of edi
 * 8(esp)  saved value of esi
 * 12(esp) saved value of ebx
 * 16(esp) link
 * 20(esp) to
 * 24(esp) what
 * 28(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (header itself)
 * esi secondary tag
 * edi tagged to
 * ebp secondary tag & 47
 */
	test	%edx, %edx		/* Shared closure? */
	jne	not_a_shared_closure	/* Jump if not */
shared_closure:
/* loop back to the start of the closure */
/* Note edx = 0 here */
	sub	$8, %edx		/* edx accumulates -offset */
	cmp	$0, 0(%ecx,%edx)	/* Use ecx in the search */
	je	shared_closure		/* Loop until we find a non-zero header */

/* note that for shared closures we must _not_ mark or evacuate the
 * original, since this would break the pattern that the fake headers
 * in a shared closure are all 0 */
/* This comment is wrong, we can evacuate and forward,
 * because then things work properly anyway:-)
 */
/*
 * A suggested optimisation for this case (both halves)
 * is to forward all pointers at this stage
 * thus making all future references to the shared closure
 * drop out at the evac stage
 */
	push	%ecx			/* Save pointer partway through closure */
	add	%edx, %ecx		/* Point to start of closure */
	mov	0(%ecx), %ebp		/* Get header */
	cmp	$EVACUATED, %ebp	/* Already evacuated? */
	jne	clos0			/* Branch if not */
	mov	4(%ecx), %ecx		/* Where it's gone */
	pop	%esi			/* Original pointer into shared closure */
	mov	24(%esp), %ebx		/* what */
	sub	%edx, %ecx		/* Compute corrected fix */
	pop	%ebp
	mov	%ecx, 0(%ebx)		/* Fix *what */
	movl	$EVACUATED, 0(%esi)	/* Mark original */
	mov	%ecx, 4(%esi)		/* Forward original */
	mov	16(%esp), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret				/* Return to */

clos0:
/* Value is a shared closure which hasn't been forwarded
 * 0(esp)  saved original pointer into shared closure
 * 4(esp)  saved value of ebp
 * 8(esp)  saved value of edi
 * 12(esp) saved value of esi
 * 16(esp) saved value of ebx
 * 20(esp) link
 * 24(esp) to
 * 28(esp) what
 * 32(esp) *what
 * 
 * eax second element of original value at share point
 * ebx tag(*what)
 * ecx header address of full value
 * edx -offset of value to be fixed
 * esi secondary tag
 * edi tagged to
 * ebp header of full value
 */

	neg	%edx			/* Convert to positive offset */
	mov	%ebp, %esi		/* Copy of true header */
	add	%edi, %edx		/* Fix for original place */
	movl	$EVACUATED, 0(%ecx)	/* Mark record evacuated */
	shr	$6, %esi		/* Compute record length */
	xchg	4(%ecx), %edi		/* Remember the first value in the record */
					/* And fix at the same time */
	sub	$2, %esi		/* Length -= 2 */
/*
 * eax element 2 at original place
 * ebx tag(*what)
 * ecx pointer to closure
 * edx Fix for original place
 * esi Length
 * edi Element one
 * ebp original header
 */

	mov	28(%esp), %eax		/* what */
	mov	24(%esp), %ebx		/* to */
	mov	%edx, 0(%eax)		/* fix *what */
	mov	%edx, %eax		/* Save the fix for later use */
	mov	%ebp, 0(%ebx)		/* save the header */
	mov	%edi, 4(%ebx)		/* save first word */
/* now loop, copying the rest of the object */
ccopy:	add	$8, %ebx		/* to += 8 */
	mov	8(%ecx), %ebp
	mov	12(%ecx), %edi
	mov	%ebp, 0(%ebx)
	mov	%edi, 4(%ebx)		/* Copy two words */
	add	$8, %ecx
	sub	$2, %esi
	jge	ccopy			/* Loop if more to go */
	pop	%esi			/* Original pointer into shared closure */
	pop	%ebp 
	movl	$EVACUATED, 0(%esi)	/* Mark original */
	mov	%eax, 4(%esi)		/* Forward original */
	lea	8(%ebx), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret

/* not a standard pointer, so it must be a refptr (otherwise it's an error) */

not_a_ptr:
/* value is in fromspace and not already evacuated, and not a pair or standard pointer
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (first element of value)
 * esi edx
 * edi tagged to
 */

	and	$63, %esi		/* Get secondary tag */
	cmp	$REFPTR, %ebx		/* Check primary is ref */
	jne	primary7		/* Error if not */
	mov	20(%esp), %ebx		/* what */
	cmp	$BYTEARRAY, %esi	/* Array or bytearray? */
	mov	%edi, 0(%ebx)		/* Fix *what */
	movl	$EVACUATED, 0(%ecx)	/* Mark original */
	mov	%edi, 4(%ecx)		/* Forward original */
	je	bytearray		/* Branch if bytearray */
	mov	16(%esp), %edi		/* to */
	mov	%edx, 0(%edi)		/* Copy first two words */
	mov	%eax, 4(%edi)
/*
 * eax second element of value
 * ebx REFPTR
 * ecx header address
 * edx *(header address) (first element of value)
 * esi secondary tag
 * edi to
 */
/* Now fiddle about with back pointers */
	mov	%edx, %esi		/* Copy of header word */
	mov	8(%ecx), %edx		/* Get entry list backptr */
	shr	$6, %esi		/* Compute array length */
	test	%edx, %edx		/* backptr zero? */
	je	rcopy			/* Branch if not */
	mov	%edi, 8(%eax)		/* forward->back = new address */
	mov	%edi, 4(%edx)		/* back->forward = new address */
rcopy:	mov	12(%ecx), %eax		/* Get first element of array */
	mov	%edx, 8(%edi)		/* Copy backptr */
	mov	%eax, 12(%edi)		/* and first element of array */
	sub	$2, %esi		/* Length -= 2 */
	jl	rcopy1			/* Branch if finished already */
rcopy0:	mov	16(%ecx), %edx
	mov	20(%ecx), %eax		/* Next two words */
	add	$8, %edi
	add	$8, %ecx		/* Increment pointers */
	mov	%edx, 8(%edi)		/* Store two words */
	sub	$2, %esi		/* Decrement count */
	mov	%eax, 12(%edi)
	jge	rcopy0			/* And loop if not finished */
rcopy1:	lea	16(%edi), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret

bytearray:
/* value is in fromspace and not already evacuated, and is a bytearray
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx what
 * ecx header address
 * edx *(header address) (first element of value)
 * esi BYTEARRAY
 * edi tagged to
 */
	lea	192(%edx), %esi		/* Prepare to get length */
	mov	16(%esp), %edi		/* to */
	shr	$8, %esi		/* Length (commuted the +3 with the >> 6) */
	mov	%edx, 0(%edi)		/* Save the header */
	sub	$2, %esi		/* Length -= 2 */
	mov	%eax, 4(%edi)		/* Save first word */
	jl	bcopy1			/* Branch if finished */
/* now loop, copying the rest of the object */
bcopy0:	mov	8(%ecx), %edx
	mov	12(%ecx), %eax		/* Next two words */
	add	$8, %edi
	add	$8, %ecx		/* Increment pointers */
	mov	%edx, 0(%edi)		/* Store two words */
	sub	$2, %esi		/* Decrement count */
	mov	%eax, 4(%edi)
	jge	bcopy0			/* And loop if not finished */
bcopy1:	lea	8(%edi), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret

/*
 * we only get here if we have a direct pointer to a code object,
 * which is very unusual (basically it means the GC has been entered in
 * the middle of loading a code object).
 */

not_a_shared_closure:
/* Value is standardly tagged but not a record or a string or a backptr or a shared closure
 * 0(esp)  saved value of ebp
 * 4(esp)  saved value of edi
 * 8(esp)  saved value of esi
 * 12(esp) saved value of ebx
 * 16(esp) link
 * 20(esp) to
 * 24(esp) what
 * 28(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (header itself)
 * esi secondary tag
 * edi tagged to
 * ebp secondary tag & 47
 */

	mov	%edx, %ebp
	mov	%edx, %esi
	and	$63, %ebp		/* Full secondary tag */
	shr	$6, %esi		/* Compute length */
	cmp	$CODE, %ebp		/* Code? */
	pop	%ebp			/* Straighten stack */
	je	record			/* Branch if so */
/*
 * Oops, bad header value
 * 
 * Call fixup_bad_header(what,*what,header,obj)
 */
	push	%ebp
	mov	%esp, %ebp
	push	%ecx			/* obj */
	push	%edx			/* header */
	push	36(%esp)		/* *what */
	push	36(%esp)		/* what */
	call	C_NAME(fixup_bad_header)
	add	$16, %esp		/* Junk parameters */
	pop	%ebp			/* Throw away frame */
	mov	16(%esp), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret

primary7:
/* value is in fromspace and not already evacuated, and not a pair or standard pointer
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx tag(*what)
 * ecx header address
 * edx *(header address) (first element of value)
 * esi secondary tag
 * edi tagged to
 *
 * Call fixup_bad_primary(what,*what)
 *
 */

	push	%ebp
	mov	%esp, %ebp
	push	28(%esp)		/* Push *what */
	push	28(%esp)		/* Push what */
	call	C_NAME(fixup_bad_primary)
	add	$8, %esp		/* Junk parameters */
	pop	%ebp			/* Throw away frame */
	mov	16(%esp), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret
@


1.7.13.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.12.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.11.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.10.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.9.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.9.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a24 3
 * Revision 1.7.9.1  1997/05/12  10:41:11  hope
 * branched from 1.7
 *
@


1.7.9.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a24 3
 * Revision 1.7.9.1  1997/05/12  10:41:11  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a24 3
 * Revision 1.7.9.1  1997/05/12  10:41:11  hope
 * branched from 1.7
 *
@


1.7.9.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a24 3
 * Revision 1.7.9.1.1.1  1997/07/28  18:25:17  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7.8.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.7.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.7.1.1.1
log
@branched from 1.7.7.1
@
text
@a24 3
 * Revision 1.7.7.1  1996/12/17  17:54:12  hope
 * branched from 1.7
 *
@


1.7.6.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.5.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a24 3
 * Revision 1.7.4.1  1996/11/14  12:58:10  hope
 * branched from 1.7
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a24 3
 * Revision 1.7  1996/08/19  15:56:25  nickb
 * Change error behaviour.
 *
@


1.6
log
@Remove an out-of-date conditionalized instruction.
@
text
@d25 3
a656 38
primary7:
/* value is in fromspace and not already evacuated, and not a pair or standard pointer
 * 0(esp)  saved value of edi
 * 4(esp)  saved value of esi
 * 8(esp)  saved value of ebx
 * 12(esp) link
 * 16(esp) to
 * 20(esp) what
 * 24(esp) *what
 * 
 * eax second element of value
 * ebx 7 (ERROR)
 * ecx header address
 * edx *(header address) (first element of value)
 * esi secondary tag
 * edi tagged to
 */

	lea	primary_error, %ecx	/* The message to be used */
fixup_message:
/* Create a stack frame for a call to C */
	push	%ebp
	mov	%esp, %ebp
	push	%edx			/* Push potential bad header word */
	push	32(%esp)		/* Push *what */
	push	32(%esp)		/* Push what */
	push	%ecx			/* The message to be used */
	call	C_NAME(message)
	add	$4, %esp		/* Junk message parameter */
	pop	%ecx			/* what */
	movl	$MLERROR, 0(%ecx)	/* Fix to MLERROR */
	add	$8, %esp		/* Junk remaining parameters to call */
	pop	%ebp			/* Throw away frame */
	mov	16(%esp), %eax		/* Return to */
	pop	%edi
	pop	%esi
	pop	%ebx
	ret
d692 37
d730 13
a742 12
	lea	header_error, %ecx
	jmp	fixup_message		/* And complain */
.globl mach_fixup_end
mach_fixup_end:
	nop
.data
primary_error:
	.asciz	"I386 GC fixup 0x%X (0x%X): illegal primary tag -- fixed to MLERROR"
	.align	4
header_error:
	.asciz	"I386 GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to MLERROR"
	.align 4
@


1.5
log
@Changing ERROR to MLERROR
@
text
@d25 3
a126 1
					/* Note, this will be different for NT */
a127 3
#ifdef OS_NT
	sub	C_NAME(arena_base), %ecx	/* Subtract start of arena */
#endif
@


1.4
log
@Change SPARC to I386
@
text
@d25 3
d683 5
a687 2
	add	$16, %esp		/* Junk parameters */
	pop	%ebp
d736 1
a736 1
	.asciz	"I386 GC fixup 0x%X (0x%X): illegal primary tag -- fixed to ERROR"
d739 1
a739 1
	.asciz	"I386 GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to ERROR"
@


1.3
log
@Modify to work under NT as well
@
text
@d25 3
d733 1
a733 1
	.asciz	"SPARC GC fixup 0x%X (0x%X): illegal secondary tag on header 0x%X -- fixed to ERROR"
@


1.2
log
@Produce first version in I386 machine code
@
text
@d25 3
d120 3
a123 1
					/* This probably needs a subtraction first for NT */
@


1.1
log
@new file
@
text
@d1 1
a1 1
/* ==== SPARC FIX: COLLECT ONE OBJECT ====
d9 1
a9 1
 *  This file contains a SPARC assembly language version of the
a21 5
 *  Notes
 *  -----
 *  This file must be run through the m4 macro processor to produce an
 *  assembler file.
 * 
d24 19
a42 16
 *  $Log: src:arch:SPARC:mach_fixup.S,v $
# Revision 1.5  1994/08/10  11:50:41  nickh
# Fix another bug in bytearray copying (a dumb typo).
#
# Revision 1.4  1994/07/06  13:38:46  nickh
# Asm and C name prefixes differ according to OS.
#
# Revision 1.3  1994/06/15  09:31:47  nickh
# Fix bug in copying bytearrays.
#
# Revision 1.2  1994/06/09  14:31:07  nickh
# new file
#
# Revision 1.1  1994/06/09  10:55:46  nickh
# new file
#
d87 1
a87 360
 *  ========================================================================
 * 
 *  Notes on costs of fixup, and of it's principal caller, the
 *  scan macro in gc.c.: Nick Haines 1994-03-31
 * 
 *  1. case frequency breakdown and instruction count table for scan
 *  
 *  The instruction counts include the scan loop, which makes over 95% of
 *  calls to fixup.

 *  "ints" are ML integers, tested and eliminated in the scan loop.
 *  "not from" are objects not in from space. "evac" are objects already
 *  evacuated. "backptrs" are pointers to code vectors. "shared" are
 *  pointers to members of shared closures.
 *  
 *                case frequency breakdown
 *                MLWorks         Lego            instructions
 *  
 *  ints          0.447           0.250           11      
 *  not from      0.331           0.495           26      
 *  evac          0.0332          0.079           28
 *  pairs         0.149           0.118           36
 *  records       0.0296          0.0336          44
 *  strings       0.0017          0.000344        49
 *  arrays        0.0090          0.0230          35
 *  backptrs      0.00013         0.00005         51
 *        evac:   0.0000033       0.00000092      41
 *  shared        0.0000076       0.000006        52
 *        evac:   0.0000051       0.000020        46
 *  
 *  +copied       0.08            0.08            6
 *  
 *  (nonints:     0.554           0.75)
 *  (nonsave:     0.190           0.176)
 *  ("nonsave" = no "save" executed in fixup)
 *  
 *  total instrs  22.005          24.864
 *  
 *  Possible improvements (see section 2 below for more details).
 *  
 *  (a) By modifying the scan macro in C, it is possible to save 2
 *  instructions on the non-int case.
 *  
 *  (b) By recoding the scan macro in assembler, it is possible to save 3
 *  instructions on the int case and 7 on non-ints (knowing what we do
 *  about what mach_fixup does with registers).
 *  
 *  (c) By coding the whole of scan into assembler, inlining mach_fixup,
 *  it would be possible to save at least 2 more instructions per loop
 *  (loading the space_type array base), and also the save instrs.
 *  
 *  These are the savings available:
 *  
 *  (a)           -1.1            -1.5
 *  (b)           -5.2            -6.0
 *  (c)           -7.4            -8.2
 *  
 *  2. how to improve scan
 *  
 *  2.1. Current scan
 *  
 *  2.1.1. source:
 *  
 *    while(f < (end)) {
 *      mlval value = *f; 
 *   
 *      if(FIXABLE(value)) {
 *        fix(to, f); 
 *        ++f; 
 *      } else
 *        switch(SECONDARY(value)) { ...
 *        }
 *    }
 *  
 *  2.1.2. object (generated by gcc2):
 *  
 *        0x1e718  cmp  %l0, %l2                  ; f < end
 *        0x1e71c  bcc,a   0x1e8e8
 *        0x1e720  ld  [ %l6 + 0x40 ], %l2
 *        0x1e724  ld  [ %l0 ], %l1               ; value = *f
 *        0x1e728  and  0xf, %l1, %o0             ; FIXABLE(value)
 *        0x1e72c  cmp  %o0, 0xa
 *        0x1e730  be  0x1e758
 *        0x1e734  btst  1, %l1                   ; pointer?
 *        0x1e738  be  0x1e750
 *        0x1e73c  mov  %l3, %o0                  ; set up registers for
 *        0x1e740  mov  %l0, %o1                  ; call to
 *        0x1e744  call  0x256a8 <mach_fixup>     ; mach_fixup
 *        0x1e748  mov  %l1, %o2                  ; ...
 *        0x1e74c  mov  %o0, %l3                  ; update 'to'.
 *        0x1e750  b  0x1e718                     ; loop
 *        0x1e754  add  4, %l0, %l0               ; ++f
 *  
 *  ints  11 instrs, 2t, 1n, 1an
 *  fixup 15 instrs, 1t, 2n, 1an
 *  
 *  2.2. Improvement in C:
 *  
 *  2.2.1. source:
 *  
 *    while (f < (end)) {
 *      mlval value = *f;
 *      if (value & 1) {
 *        to = mach_fixup(to,f,value);
 *        f++;
 *      } else if FIXABLE(value) {
 *        ...
 *      }
 *    }
 *  
 *  2.2.2. object generated by gcc2:
 *  
 *  loop:
 *        cmp     %i1,%i2                         ; f < end
 *        bgeu    over
 *        nop
 *        ld      [%i1],%l0                       ; value = *f
 *        andcc   %l0,1,%g0                       ; ptr?
 *        be      nonptr
 *        mov     %i0,%o0                         ; set up registers
 *        mov     %i1,%o1                         ; for call to
 *        call    _mach_fixup                     ; mach_fixup
 *        mov     %l0,%o2                         ; ...
 *        mov     %o0,%i0                         ; update 'to'
 *        b       loop                            ; loop
 *        add     %i1,4,%i1                       ; f++
 *  nonptr
 *        and     %l0,15,%o0                      ; FIXABLE
 *        cmp     %o0,10                          ; ...
 *        be      loop
 *        and     %l0,63,%o0                      ; do non-fixables
 *  
 *  ints  11 instrs, 2t, 1n
 *  fixup 13 instrs, 1t, 2n)
 *  
 *  2.2.3. code we would like to be generated:
 *  
 *  .loop:        cmp     %f, %end
 *                bcc,a   .endloop
 *                <annulled slot>
 *                ld      [%f],%val
 *                andcc   #1, %val, %foo
 *                beq,a   .nonptr
 *                and     #f, %val, %foo
 *                mov     %to, %arg0
 *                mov     %f, %arg1
 *                call    mach_fixup
 *                mov     %val, %arg2
 *                mov     %arg0, %to
 *                b       .loop
 *                add     #4, %f, %f
 *  
 *  .nonptr       cmp     %foo, 0xa
 *                bne     .loop
 *                add     #4, %f, %f
 *  
 *  ints  9 instrs, 1an, 1at, 1t  save 18%
 *  fixup 12 instrs, 2an, 1t      save 20%
 *  
 *  2.3. Assembly-language version (mach_fixup still out-of-line):
 *  
 *  keep f in arg1                (make mach_fixup take it as f+4)
 *       to in arg0
 *  
 *  .loop:        bcc,a   .endloop
 *                <annulled slot>
 *                ld      [%arg1],%arg2
 *                andcc   #1, %arg2, %foo
 *                beq,a   .nonptr
 *                and     #f, %arg2, %foo
 *                call    mach_fixup
 *                add     #4, %f, %f
 *                b       .loop
 *                cmp     %arg1, %end
 *         
 *  .nonptr       cmp     %foo, 0xa
 *                bne     .loop
 *                cmp     %arg1, %end
 *        
 *  ints  8 instrs, 1an, 1at, 1t  save 27%
 *  fixup 8 instrs, 2an, 1t       save 47%
 *  
 *  3. raw data for case frequencies:
 *  
 *  By instrumenting the C version of fixup, counts were obtained for each
 *  possible case. Two tests were run: a compilation of MLWorks, and a
 *  compilation and test of the Lego software.
 *  
 *  3.1. Summary
 *  
 *  (Lego results marked L):
 *  
 *  25(L)--44.6% are integers
 *  of ptrs, 59.8--66(L)% are not into from space. There are no large objects.
 *  of from-space ptrs, 14.9--31.3(L)% are already fixed.
 *  of ptrs which need fixing,
 *        67.4(L)-78.6% are pair pointers,
 *        16.6-19.4(L)% are regular pointers,
 *        4.7-13.1(L)% are ref pointers.
 *  of regular ptrs which need fixing,
 *        0.041%-0.076(L)% have zero header (i.e. are sharing closures)
 *        94--98.7(L)% are records
 *        1.0(L)--5.4% (81.6(L)--92.3% of non-records) are strings
 *        0.15(L)--0.41% (66.4(L)--91.1% of non-string non-records) are backptrs
 *  
 *        39.8--78.8(L)% of shared closures have already been evacuated
 *        1.8(L)--2.4% of backptrs have already been evacuated
 *  
 *        records and strings evacuated average 2.88--5.04(L) double words
 *        code vectors (backptrs) evacuated average 43.79(L)--60.1 double words
 *        shared closures (zero hdrs) evacuated average 22.1--24.6(L) doubles
 *  
 *  of ref ptrs which need fixing,
 *  
 *        all but a tiny fraction (5(L)--15 per million) are arrays/ref cells
 *        the rest are weak arrays
 *        evacuees average 2.01(L)--3.50 double words (a ref cell is 2).
 *  
 *  3.2. MLWorks compiling itself:
 *  
 *  616856337 fixed, of which:
 *  
 *  141910034 even ints
 *   87336121 odd ints
 *   45941366 headers
 *  =========
 *  275187521 integers (44.6% of total)
 *  
 *  341668816 pointers, of which:
 *  
 *  204420028 not in from space (59.8%, 33.1% of fixed) (0 large objects)
 *  
 *  137248788 pointers into from space (40.1%, 22.2% of fixed), of which:
 *  
 *  20480547 already fixed (14.9%, 5.9% of ptrs, 3.3% of fixed)
 *  
 *  116768241 need fixing (85.0%, 34.1% of ptrs, 18.9% of fixed), of which:
 *  
 *  91824468 pair pointers (78.6%, 66.9% of froms, 26.8% of ptrs, 14.8% of fixed)
 *  19390655 pointers (16.6%, 14.1% of froms, 5.6% of ptrs, 3.1% of fixed)
 *  5553118 ref pointers (4.7%, 4.0% of froms, 1.6% of ptrs, 0.9% of fixed)
 *  
 *  of pointers which need fixing, 99.96% have a header word, of which:
 *  
 *  18244705 records (94%, 15.6% examined, 13.2% froms, 5.3% ptrs, 2.9% fixed)
 *   1057435 strings (5.4%, 0.9% examined)
 *     80665 backptrs (0.41%)
 *     (of which 2008, 2.4%, already evac) 
 *         0 code vectors
 *  
 *  18244705+1057435+36216501 = 55518641 double words copied for records,
 *  strings (average 2.876 double words each).
 *  
 *  80665-2008+4718891 = 4797548 double words coped for backptrs (average
 *  60.99 double words each)
 *  
 *      7850 shared closures (0.041%)
 *     (of which 3132, 39.8%, already evac)
 *  
 *  7850-3132+99727 = 104445 double words copied for shared closures
 *  (average 22.137 double words each)
 *  
 *  of ref pointers which need fixing,
 *  
 *   5553032 arrays (damn near all of 'em)
 *        86 weak arrays
 *         0 bytearrays
 *  
 *  (5553032+86)*2+8352725 = 19458961 double words copied for arrays and
 *  weak arrays (average of 3.504 double words each)
 *  
 *  3.3. MLWorks running Lego:
 *  
 *  117499824 fixed
 *  
 *  of which
 *  
 *   9145167 even ints
 *  10747092 odd ints
 *   9521364 headers
 *  ========
 *  29413623 integers (25.0% of total)
 *  
 *  88086201 pointers
 *  
 *  of which
 *  
 *  58141904 not in from space (66.0%, 49.4% of fixed) (0 large objects)
 *  
 *  29944297 pointers into from space (33.9%, 25.4% of fixed)
 *  
 *  of which
 *  
 *   9391625 already fixed (31.3%, 10.6% of ptrs, 7.9% of fixed)
 *  20552672 need fixing (68.6%, 23.3% of ptrs, 17.4% of fixed)
 *  
 *  of which
 *  
 *  13855968 pair pointers (67.4%, 46.2% of froms, 15.7% of ptrs, 11.7% of fixed)
 *   3999226 pointers (19.4%, 13.3% of froms, 4.5% of ptrs, 3.4% of fixed)
 *   2697838 ref pointers (13.1%, 9.0% of froms, 3.0% of ptrs, 2.2% of fixed)
 *  
 *  of pointers which need fixing,
 *  
 *  3949648 records (98.7%, 19.2% examined, 13.1% froms, 4.4% ptrs, 3.3% total)
 *    40470 strings (1.0%, 0.1% examined)
 *     6051 backptrs (0.15%)
 *     (of which 108, 1.8%, already evac)
 *        0 code vectors
 *  
 *  3949648+40470+16126963 = 20117081 double words copied for records,
 *  strings (average 5.041 double words each)
 *  
 *  6051-108+213003 = 218946 double words copied for backptrs (average
 *  43.789 double words each)
 *  
 *     3057 shared closures (0.076%)
 *     (of which 2410, 78.8%, already evac)
 *  
 *  3057-2410+15256 = 15903 double words copied for shared closures
 *  (average 24.58 double words each)
 *  
 *  of ref pointers which need fixing,
 *  
 *  2697825 arrays (i.e. pretty much everything)
 *        0 bytearrays
 *       13 weak arrays
 *  
 *  (2697825+13)*2+25925 = 5421601 double words coped for arrays and weak
 *  arrays = 2.01 double words each.
 *  
 *  
 *  4. Data copying rates
 *  
 *  Based on the case frequencies in section 1:
 *  
 *  doublewords copied per scan:
 *  
 *                MLWorks         Lego
 *  
 *  pairs         0.149           0.118
 *  records       0.0296          0.0336
 *  strings       0.0017          0.000344
 *  arrays        0.0090          0.0230
 *  back          0.00013         0.00005
 *  shared        0.0000076       0.000006
 *  bodies        0.08            0.08
 *  
 *  total words per scan:
 *  
 *                0.5388752       0.51
 *  
 *  instructions/word copied:
 *  
 *  now           40.84           48.75
 *  (a)           38.79           45.81
 *  (b)           31.18           36.99
 *  (c)           27.10           32.67
 * 
 *  =====================================================================
a89 14
/*  Note: various costs are listed in the code below, for instance:
 * 
 *  record size 1: 29 instrs, 3t, 2n, 1an, save.
 *  
 *  This means "to fixup a record of size 1 requires 29 instructions, of
 *  which 3 are taken branches, 2 are non-taken branches, and 1 is a
 *  non-taken annulled branch. Registers are saved and restored."
 *  
 *  The costs are measured from the entry to mach_fixup.
 *  
 *  At various points "costs so far" are noted, along with information
 *  about the current content of registers &c.
 */

d93 1
a93 8
! === FIX AN ML VALUE ===
!
! Parameters:
!   %o0  Where to copy objects to
!   %o1  Pointer to value to fix
!   %o2  Contents of that value
! Returns:
!   %o0  Where to copy to next
d95 17
d114 15
a128 12
	sethi	%hi(C_NAME(space_type)), %o4
	srl	%o2, 24, %o3		! Calculate block number of object
	or	%o4, %lo(C_NAME(space_type)), %o4
	ldub	[%o4 + %o3], %o5	! Fetch the type of the block
	cmp	%o5, 2			! Is it TYPE_FROM?
	beq	fix1
	andn	%o2, 7, %o3		! Mask out the primary tag in any case
	cmp	%o5, 5			! Is it TYPE_LARGE
	beq,a	return
	st	%g0, [%o3-4]		! Clear the mark word
return:	jmpl	%o7+8, %g0
	nop
d130 34
a163 42
fix1:	ldd	[%o3], %o4		! Load header and first word
	cmp	%o4, EVACUATED		! Is the object evacuated?
	be,a	return
	st	%o5, [%o1]		! Fix the value and return if so

! notfrom: 11 instrs, 1an
! large  : 12 instrs, 1at
! already: 13 instrs, 1t, 1at.

! mach_fixup is not a leaf (it calls message() in error cases), so we
! have to push 24 words to allow for callee argument space.

	save	%sp, -0x60, %sp
	mov	EVACUATED, %o4		! Secondary for EVACUATED
	and	%i2, 7, %o3		! Mask in the primary tag
	add	%i0, %o3, %o5		! New tagged value
	cmp	%o3, PAIRPTR

! Current costs and state:
!
! 15 instrs, 1t, 1an, save.
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed	sp

	bne	not_a_pair
	st	%o5, [%i1]		! fix the original value
	std	%o4, [%i3]		! store fix
	std	%i4, [%i0]		! evacuate pair
	jmpl	%i7+8, %g0		! return
	restore %i0, 8, %o0		! increment the 'to' value and restore

! pair case: 21 instrs, 1t, 1n, 1an, save.

! Current costs and state:
!
! 17 instrs, 2t, 1an, save. *what fixed. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed	sp
d165 17
a181 8
not_a_pair:
	cmp	%o3, POINTER
	bne	not_a_ptr
	std	%o4, [%i3]		! store fix in delay slot
	and	%i4, 63, %o2
	cmp	%o2, RECORD
	bne	not_a_record
	srl	%i4, 6, %o0		! object length in delay slot
d183 31
a213 1
! so this is a record...
d215 25
d241 40
a280 27
	subcc	%o0, 2, %o0
	bneg	copy1
	std	%i4, [%i0]		! fixup header
copy0:	add	%i3, 8, %i3
	ldd 	[%i3], %i4
	std	%i4, [%i0 + 8]
	subcc	%o0, 2, %o0
	bpos	copy0
	add	%i0, 8, %i0
copy1:	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0		! can we fill this add??
	
! record size 1: 29 instrs, 3t, 2n, 1an, save.
! record size 2,3: 35 instrs, 2t, 4n, 1an, save.
! + 6 instrs, 1t per double word.

! Current costs and state:
!
! 24 instrs, 3t, 1n, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length		second	tag	EVAC	fixed	sp

! catch string and bytearray headers here, as we can do so for one extra
! instruction and it will catch boxed reals (which have regular pointers
! to 12-byte bytearray-headed objects).
d283 29
a311 29
	and	%o2, 47, %o1		! Check for bytearrays too
	cmp	%o1, STRING
	bne	not_a_string
	add	%o0, 3, %o1		! Wasted if branch taken, who cares?
	srl	%o1, 2, %o0
string:
	subcc	%o0, 2, %o0
	bneg	scopy1
	std	%i4, [%i0]
scopy0: add	%i3, 8, %i3
	ldd	[%i3], %i4
	std	%i4, [%i0 + 8]
	subcc	%o0, 2, %o0
	bpos	copy0
	add	%i0, 8, %i0
scopy1:	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0

! string size 0-4: 34 instrs, 4t, 2n, 1an, save
! string size 5-12: 40 instrs, 3t, 4n, 1an, save
! +6 instrs, 1t per 8 bytes

! Current costs and state:
!
! 28 instrs, 4t, 1n, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length	len+3		tag	EVAC	fixed	sp
d314 66
a379 42
	cmp	%o2, BACKPTR
	bne	not_a_backptr
	std	%i4, [%i3]		! Undo the forwarding
	sub	%i3, %o0, %o1		! Find the actual header
	ldd	[%o1], %o2
	mov	%o4, %i4		! Copy the evacuation marker
	cmp	%o2, %o4		! Has the whole code vector been evacuated?
	bne,a	back0
	add	%o5, %o0, %i5		! New value = new pointer + offset
	add	%o3, %o0, %i5		! New value = forward + offset
	std	%i4, [%i3]		! Evacuate the original
	st	%i5, [%i1]		! Fix the original again
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! already-evacuated backptr, 41 instrs, 4t, 2n, 3an, save.

back0:	srl	%o2, 6, %o0		! Calculate length of code vector in words
	std	%o4, [%o1]		! Evacuate the whole code vector
	std	%o2, [%i0]
	subcc	%o0, 2, %o0
back1:	add	%o1, 8, %o1
	ldd	[%o1], %o2
	std	%o2, [%i0 + 8]		! Copy the whole code vector
	subcc	%o0, 2, %o0
	bpos	back1
	add	%i0, 8, %i0
	std	%i4, [%i3]		! Evacuate the original value
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%i0, 8, %o0

! code vector size 4: 51 instrs, 4t, 3n, 1at, 2an, save.
! + 6 instrs, 1t per double word.

! Current costs and state:
!
! 31 instrs, 5t, 1n, 2an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	fp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!	length	&hdr-len	tag	EVAC	fixed	sp
d381 34
d416 78
a493 2
	cmp	%i4, 0
	bne	not_a_shared_closure
d495 17
a511 1
/* this stuff not so well-optimised because it's a very rare case (~0.05%) */
d513 24
a536 43
	sub	%i3, 8, %o0		! Who cares if we fill this slot...
shared_closure:
	ldd	[%o0], %o2		! Search back for the actual header
	cmp	%o2, %g0
	bz,a	shared_closure
	sub	%o0, 8, %o0
	sub	%i3, %o0, %o1		! Calculate the offset within the closure
	mov	%o4, %i4		! Copy evacuation marker
	cmp	%o2, %o4		! Has the whole record been evacuated?
	bne,a	clos0
	add	%o5, %o1, %i5		! New value = new pointer + offset
	add	%o3, %o1, %i5		! New value = forward + offset
	std	%i4, [%i3]		! Evacuate the original
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0
clos0:	srl	%o2, 6, %o1		! Calculate length of closure
	std	%o4, [%o0]		! Evacuate the whole closure
	std	%o2, [%i0]		! Copy the whole closure
	subcc	%o1, 2, %o1
	bneg	clos2
	add	%i0, 8, %i0
clos1:	add	%o0, 8, %o0
	ldd	[%o0], %o2
	std	%o2, [%i0]		! Copy the whole closure
	subcc	%o1, 2, %o1
	bpos	clos1
	add	%i0, 8, %i0
clos2:	std	%i4, [%i3]		! Evacuate the original value
	st	%i5, [%i1]		! Fix the original value
	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! shared closures already evac: 46 instrs, 5t, 1n, 4an, save.
! shared closures not evac: 52 instrs, 5t, 1n, 3an, 1at, save
! + 6/additional double word
! + 4 instrs, 1at per step

! 20 instrs, 3t, 1an, save. *what fixed, forwarded. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	sp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!				tag	EVAC	fixed
d538 1
a538 1
/* not a regular pointer, so it must be a refptr (otherwise it's an error) */
d541 63
a603 39
	cmp	%o3, REFPTR
	bne	primary7
	and	%i4, 63, %o2		! Get secondary tag
	cmp	%o2, BYTEARRAY		! Is it a bytearray?
	be	bytearray
	std	%i4, [%i0]
	ldd	[%i3 + 8], %o2		! Fetch back pointer and first element
	cmp	%o2, %g0		! Is the backward pointer non-zero?
	bz	rcopy			! Copy the rest as a record
	srl	%i4, 6, %o0		! Calculate the length from the header
	st	%i0, [%i5 + 8]		! forward->back = new address
	st	%i0, [%o2 + 4]		! back->forward = new address

! Costs to here: 30 instrs, + 2 optional instrs

rcopy:	subcc	%o0, 2, %o0		! Copy double words to end of record or string
	bneg	rcopy1
	std	%o2, [%i0 + 8]		! Copy back pointer and first element
rcopy0: ldd	[%i3 + 16], %i4
	std	%i4, [%i0 + 16]
	subcc	%o0, 2, %o0
	add	%i3, 8, %i3
	bpos	rcopy0
	add	%i0, 8, %i0
rcopy1:	jmpl	%i7+8, %g0
	restore	%i0, 16, %o0

! ref cells 35 instrs, 5t, 2n, 1an, save.
! array size 2/3 41 instrs, 4t, 4n, 1an, save.
! + 6 instrs, 1t per double
! + 2 instrs, 1n, -1t if on an entry list

! Current costs and state:
!
! 26 instrs, 4t, 1n, 1an, save. *what fixed, forwarded, evac. registers:
!	i0	i1	i2	i3	i4	i5	i6	i7
!	to	what	*what	&hdr	hdr	word1	sp	return	
!	o0	o1	o2	o3	o4	o5	o6	o7
!			primary	tag	EVAC	fixed
d606 37
a642 18
	srl	%i4, 6, %o0
	add	%o0, 3, %o1
	srl	%o1, 2, %o0		! Round length to words
	subcc	%o0, 2, %o0		! Copy double words to end of record or string
	bneg	bcopy1
	add %i0, 8, %i0			! Could merge this with the restore
bcopy0: ldd	[%i3 + 8], %i4
	std	%i4, [%i0]
	subcc	%o0, 2, %o0
	add	%i3, 8, %i3
	bpos	bcopy0
	add	%i0, 8, %i0
bcopy1:	jmpl	%i7+8, %g0
	restore	%g0, 0, %g0

! bytearray size 0-4 34 instrs, 5t, 1n, 1an, save.
! bytearray size 5-12 40 instrs, 4t, 3n, 1an, save.
! + 6 instrs, 1t per 8 bytes.
d645 26
a670 3
	sethi	%hi(primary_error), %o0
	or	%o0, %lo(primary_error), %o0
	mov	%i1, %o1
d672 6
a677 3
	mov	%i2, %o2
	mov	ERROR, %i3
	st	%i3, [%i1]
d679 5
a683 8
	restore
primary_error:
	.asciz	"SPARC GC fixup 0x%X (0x%X): illegal primary tag -- fixed to ERROR"
	.align	4

! we only get here if we have a direct pointer to a code object,
! which is very unusual (basically it means the GC has been entered in
! the middle of loading a code object).
d686 18
a703 2
	cmp	%o2, CODE		! extremely unusual case (<< 1 ppm)
	bne	bad_header
d705 19
a723 18
! In getting here, we have done a couple of things in delay slots that
! are undesireable. We have to fix them.

	std	%i4, [%i3]		! redo the forwarding
	ba	record
	srl	%i4, 6, %o0		! recalculate the length

bad_header:
	sethi	%hi(header_error), %o0
	or	%o0, %lo(header_error), %o0
	mov	%i1, %o1
	mov	%i2, %o2
	call	C_NAME(message)
	mov	%i4, %o3
	mov	ERROR, %i3
	st	%i3, [%i1]
	ret
	restore
@
