head	1.3;
access;
symbols;
locks; strict;
comment	@ * @;


1.3
date	95.02.08.13.52.53;	author jont;	state Exp;
branches;
next	1.2;

1.2
date	94.10.07.10.48.56;	author jont;	state Exp;
branches;
next	1.1;

1.1
date	94.10.04.16.56.02;	author jont;	state Exp;
branches;
next	;


desc
@new file
@


1.3
log
@Add a type cast
@
text
@/*
 * state.c
 * The ML and C states are stored here.
 * $Log: src:arch:I386:state.c,v $
 * Revision 1.2  1994/10/07  10:48:56  jont
 * Add initialisation of initial stack pointer
 *
 * Revision 1.1  1994/10/04  16:56:02  jont
 * new file
 *
 *
 * Copyright (c) 1994 Harlequin Ltd.
 */

#include "mltypes.h"
#include "tags.h"
#include "state.h"
#include "stacks.h"
#include "mem.h"
#include "gc.h"
#include "implicit.h"
#include "values.h"
#include "extensions.h"

struct ml_state data_aligned(ml_state,8);
struct c_state data_aligned(c_state,8);

unsigned int stack_extension_count;
unsigned int raise_count;

extern void state_initialise(struct stack *initial_stack)
{
  GC_STACK = STACK_LIMIT(initial_stack);
  ml_state.base = initial_stack->top;
  GC_SP = initial_stack->top;

  top_stack_pointer = GC_SP;

  c_state.sp = (word)NULL; /* Required by I386 for spotting top of stack */

  ml_state.implicit = &implicit_vector;
  GC_MODIFIED_LIST = NULL;
  declare_root(&GC_CLOSURE); /* Ensure this gets fixed if necessary */
}
@


1.2
log
@Add initialisation of initial stack pointer
@
text
@d5 3
d39 1
a39 1
  c_state.sp = NULL; /* Required by I386 for spotting top of stack */
@


1.1
log
@new file
@
text
@d4 3
a6 1
 * $Log$
d8 1
d15 1
d33 2
@
