head	1.8;
access;
symbols
	MLW_daveb_inline_1_4_99:1.8.5
	MLWorks_21c0_1999_03_25:1.8
	MLWorks_20c1_1998_08_20:1.8
	MLWorks_20c0_1998_08_04:1.8
	MLWorks_20b2c2_1998_06_19:1.8
	MLWorks_20b2_Windows_1998_06_12:1.8
	MLWorks_20b1c1_1998_05_07:1.8
	MLWorks_20b0_1998_04_07:1.8
	MLWorks_20b0_1998_03_20:1.8
	MLWorks_20m2_1998_02_16:1.8
	MLWorks_MM_adapt:1.8.4
	MLWorks_20m1_1997_10_23:1.8
	MLWorks_11r1:1.8.1.1.1.1.1
	MLWorks_workspace_97:1.8.3
	MLWorks_dt_wizard:1.8.2
	MLWorks_11c0_1997_09_09:1.8.1.1.1.1
	MLWorks_10r3:1.8.1.1.3
	MLWorks_10r2_551:1.8.1.1.2
	MLWorks_11:1.8.1.1.1
	MLWorks_1_0_r2c2_1997_07_28:1.8.1.1
	MLWorks_20m0_1997_06_20:1.8
	MLWorks_1_0_r2c2_1997_06_14:1.8.1.1
	MLWorks_1_0_r2c1_released_1997_05_23:1.8.1.1
	MLWorks_1_0_r2c1_1997_05_12:1.8.1
	MLWorks_BugFix_1997_04_24:1.8
	MLWorks_1_0_r2_Win32_1997_04_11:1.8
	MLWorks_1_0_r2_Unix_1997_04_04:1.8
	MM_ML_release_korma_1997_04_01:1.8
	MLWorks_1_0_1_ULTRASPARC_1997_02_24:1.7.4.1.1
	MLWorks_gui_1996_12_18:1.7.5
	MLWorks_1_0_Win32_1996_12_17:1.7.4
	MLWorks_1_0_Irix_1996_11_28_released_1996_12_17:1.7.1.1.1.1
	MLWorks_1_0_Unix_1996_11_14_released_1996_12_17:1.7.1.1
	JFHrts:1.7.3
	MLWorks_1_0_Irix_1996_11_28:1.7.1.1.1
	MLWorks_1_0_Win32_1996_11_22:1.7.2
	MLWorks_1_0_Unix_1996_11_14:1.7.1
	MLWorks_Open_Beta2_1996_10_11:1.6.3
	MLWorks_License_dev:1.6.2
	MLWorks_1_open_beta_1996_09_13:1.6.1
	MLWorks_Open_Beta_1996_08_22:1.6
	MLWorks_Beta_1996_07_02:1.6
	MLWorks_Beta_1996_06_07:1.6
	MLWorks_Beta_1996_06_06:1.6
	MLWorks_Beta_1996_06_05:1.6
	MLWorks_Beta_1996_06_03:1.6
	MLWorks_Beta_1996_05_31:1.6
	MLWorks_Beta_1996_05_30:1.6
	hope_poo:1.4.1
	ML_beta_release_12/08/94:1.4.1.1
	ML_beta_release_03/08/94:1.4;
locks; strict;
comment	@ * @;


1.8
date	97.02.06.11.41.53;	author nickb;	state Exp;
branches
	1.8.1.1
	1.8.2.1
	1.8.3.1
	1.8.4.1
	1.8.5.1;
next	1.7;

1.7
date	96.10.31.17.21.35;	author nickb;	state Exp;
branches
	1.7.1.1
	1.7.2.1
	1.7.3.1
	1.7.4.1
	1.7.5.1;
next	1.6;

1.6
date	95.09.06.15.22.33;	author nickb;	state Exp;
branches
	1.6.1.1
	1.6.2.1
	1.6.3.1;
next	1.5;

1.5
date	95.03.15.17.21.40;	author nickb;	state Exp;
branches;
next	1.4;

1.4
date	94.07.22.14.31.10;	author nickh;	state Exp;
branches
	1.4.1.1;
next	1.3;

1.3
date	94.07.06.13.30.52;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.30.20;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.54.50;	author nickh;	state Exp;
branches;
next	;

1.4.1.1
date	95.07.05.10.29.12;	author hope;	state Exp;
branches;
next	;

1.6.1.1
date	96.09.13.11.25.09;	author hope;	state Exp;
branches;
next	;

1.6.2.1
date	96.10.07.16.15.31;	author hope;	state Exp;
branches;
next	;

1.6.3.1
date	96.10.17.11.34.56;	author hope;	state Exp;
branches;
next	;

1.7.1.1
date	96.11.14.13.00.36;	author hope;	state Exp;
branches
	1.7.1.1.1.1;
next	;

1.7.1.1.1.1
date	96.11.28.15.10.39;	author hope;	state Exp;
branches;
next	;

1.7.2.1
date	96.11.22.18.18.27;	author hope;	state Exp;
branches;
next	;

1.7.3.1
date	96.12.17.10.05.09;	author hope;	state Exp;
branches;
next	;

1.7.4.1
date	96.12.17.17.56.44;	author hope;	state Exp;
branches
	1.7.4.1.1.1;
next	;

1.7.4.1.1.1
date	97.02.24.11.48.22;	author hope;	state Exp;
branches;
next	1.7.4.1.1.2;

1.7.4.1.1.2
date	97.02.24.14.25.03;	author jont;	state Exp;
branches;
next	;

1.7.5.1
date	96.12.18.09.51.24;	author hope;	state Exp;
branches;
next	;

1.8.1.1
date	97.05.12.10.45.05;	author hope;	state Exp;
branches
	1.8.1.1.1.1
	1.8.1.1.2.1
	1.8.1.1.3.1;
next	;

1.8.1.1.1.1
date	97.07.28.18.27.19;	author daveb;	state Exp;
branches
	1.8.1.1.1.1.1.1;
next	;

1.8.1.1.1.1.1.1
date	97.10.07.11.53.21;	author jkbrook;	state Exp;
branches;
next	;

1.8.1.1.2.1
date	97.09.08.17.20.24;	author daveb;	state Exp;
branches;
next	;

1.8.1.1.3.1
date	97.09.09.14.16.31;	author daveb;	state Exp;
branches;
next	;

1.8.2.1
date	97.09.10.19.34.22;	author brucem;	state Exp;
branches;
next	;

1.8.3.1
date	97.09.11.21.03.25;	author daveb;	state Exp;
branches;
next	;

1.8.4.1
date	97.10.31.13.46.18;	author nickb;	state Exp;
branches;
next	;

1.8.5.1
date	99.04.01.18.02.26;	author daveb;	state Exp;
branches;
next	;


desc
@new file
@


1.8
log
@The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
effect is that the registers which are current at the time of the trap may
reappear in a later register window. So whenever we invoke it, we have to
ensure that the current registers (ins, locals, and outs) are GC-safe.
@
text
@/*
 * ==== ML TO C INTERFACE MACROS ====
 *
 * Copyright (C) 1992 Harlequin Ltd.
 *
 * Description
 * -----------
 * These macros are used by other SPARC assembly language routines in
 * the ML to C interface.  They deal with various conventions between
 * the C runtime system and ML.
 *
 * Notes
 * -----
 * This file must be run through the m4 macro processor to produce an
 * assembler file.
 *
 * Revision Log
 * ------------
 * $Log: src:arch:SPARC:macros.h,v $
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
 * Revision 1.6  1995/09/06  15:22:33  nickb
 * Change to c_sp protocol.
 *
 * Revision 1.5  1995/03/15  17:21:40  nickb
 * Add threads system.
 *
 * Revision 1.4  1994/07/22  14:31:10  nickh
 * Add fiddles with heap_limit field in ml_state.
 *
 * Revision 1.3  1994/07/06  13:30:52  nickh
 * Asm and C name prefixes differ according to OS.
 *
 * Revision 1.2  1994/06/09  14:30:20  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:54:50  nickh
 * new file
 *
 * Revision 1.16  1994/03/09  13:46:14  jont
 * Removed loading and storing of globals on entry/exit to C.
 * We still have to restore/save the stack pointer though.
 *
 * Revision 1.15  1993/02/26  17:52:31  jont
 * Added a macro to initialise all unused registers before calling ml
 *
 * Revision 1.14  1992/10/23  11:29:25  richard
 * Shortened some long names.  Changed event handling
 * stuff.
 *
 * Revision 1.13  1992/09/15  11:20:54  clive
 * Added macros to load and save floating point registers
 *
 * Revision 1.12  1992/07/31  08:37:03  richard
 * Removed redundant declaration of EVAC.
 *
 * Revision 1.11  1992/07/29  13:33:02  clive
 * Changes to single-step and calling of debugger now we can callml from C - so
 * errors ironed out
 *
 * Revision 1.10  1992/07/21  15:48:27  richard
 * Moved unwind_stack here from interface.m4s.  It now calls C only
 * once to unwind stack extension areas, removing the need to
 * recognise particular stack frames and thus allowing it to traverse
 * C stack.
 *
 * Revision 1.9  1992/07/16  16:31:10  richard
 * Implemented re-entrant ML.
 *
 * Revision 1.8  1992/07/16  10:58:47  clive
 * Removed load_allocation_details which is no longer needed
 *
 * Revision 1.7  1992/07/15  11:16:31  richard
 * offsets.h is now included and used.
 *
 * Revision 1.6  1992/07/03  09:55:46  richard
 * Changed the way thay interrupts are generated and handled.
 *
 * Revision 1.5  1992/06/22  15:24:32  clive
 * Wrote a macro to detect waiting interrupts, which could not be handled before as we were in C
 *
 * Revision 1.4  1992/05/15  10:31:55  clive
 * Memory profiling result in bytes - to get tagging automatically
 *
 * Revision 1.3  1992/05/08  17:14:49  clive
 * Added memory profiling
 *
 * Revision 1.2  1992/04/15  10:18:30  richard
 * Converted to use the m4 macro processor and renamed to macros.m4s.
 *
 * Revision 1.2  1992/04/14  16:35:05  richard
 * Converted to use m4 macro processor and renamed to macros.m4s.
 *
 * Revision 1.1  1992/04/02  09:45:08  richard
 * Initial revision
 */

#include "offsets.h"
#include "asm_offsets.h"
#include "naming.h"

/* we can't get these from an include file because under SunOS
 * they are in /usr/include/machine/trap.h and under Solaris they are in
 * /usr/include/sys/trap.h */

#define ST_BREAKPOINT 1
#define ST_FLUSH_WINDOWS 3
#define ST_CLEAN_WINDOWS 4

/* ML boolean values; these must agree with those defined in values.h */

#define TRUE	4
#define FALSE	0

/* Clean register windows */

#define	clean_windows    ta ST_CLEAN_WINDOWS

/* Clean the registers in the current window */

#define clean_current_registers		\
	mov	%g0,	%l0	;	\
	mov	%g0,	%l1	;	\
	mov	%g0,	%l2	;	\
	mov	%g0,	%l3	;	\
	mov	%g0,	%l4	;	\
	mov	%g0,	%l5	;	\
	mov	%g0,	%l6	;	\
	mov	%g0,	%l7	;	\
	mov	%g0,	%o2	;	\
	mov	%g0,	%o3	;	\
	mov	%g0,	%o4	;	\
	mov	%g0,	%o5

/* Saves g3 (handler), g4 (scratch), g7 (general register), g2
 * (allocation point) in the ML state of the current thread, offset
 * from the current thread register (given in the argument). */

#define store_ML_state_with(use)				\
	st	%g2, [use + IMPLICIT_gc_base] ;			\
	st	%g3, [use + IMPLICIT_handler] ;			\
	st	%g4, [use + THREAD_ml_global] ;			\
	st	%g7, [use + THREAD_ml_g7] ;

/* Loads the global registers g1, g2, g3, g4, g6, g7 from the ML state
 * of the current thread, offset from the current thread register
 * (given in the first argument). The stack limit register %g6 is ORed
 * with the interrupt stack slot in the current implicit vector, which
 * is left in the third arg */

/* Note the fiddling with g1/g2/g4 here. This is to make sure that,
   while in C, GC_HEAP_LIMIT points to the limit of the creation
   space, but while in ML, %g1 contains 0x7ffffffc - (limit-alloc). */

#define load_ML_state_with(use, intreg)				\
	ld	[use + IMPLICIT_gc_limit], %g1 ;		\
	ld	[use + IMPLICIT_gc_base], %g2 ;			\
								\
	/* set limit register g1 for trapping GC entry */	\
								\
	sethi	%hi(0x7ffffffc), %g4	;			\
	or	%g4, %lo(0x7ffffffc), %g4	;		\
	sub	%g4, %g1, %g1		;			\
	add	%g1, %g2, %g1		;			\
								\
	ld	[use + IMPLICIT_handler], %g3 ;			\
	ld	[use + THREAD_ml_global], %g4 ;			\
	ld	[use + IMPLICIT_stack_limit], %g6 ;		\
	ld	[use + THREAD_ml_g7], %g7 ;			\
	ld	[use + IMPLICIT_interrupt], intreg ;		\
	or	%g6, intreg, %g6


/* On UltraSPARC, we have to clean some registers when we do a
 * clean_windows trap. We use this macro, so that if we want to
 * conditionalize these cleans (i.e. build separate runtimes for
 * UltraSPARC and SPARC), we can do so trivially here */

#define ultra_clean(register)	mov	%g0, register

/* Call C from ML :
 * Saves the ML state and restore the C state, then calls the
 * function, propagating registers %o0 to %o2 as arguments for
 * C.	 The C return value is returned in %o0. */

/* Note that all registers must be GC-safe when ML_to_C is invoked */

#define ML_to_C(what)							\
	store_ML_state_with(%g5)	;				\
	st	%sp, [%g5+THREAD_ml_sp] ; /* Save ML stack base */	\
	ld	[%g5 + THREAD_c_sp], %o5; /* Fetch the previous C sp */	\
	save	%o5, -88, %sp		; /* Make a C stack frame */    \
	st	%sp, [%g5+THREAD_ml_gc_sp] ; /* Save topmost GCable sp */  \
	ld	[%g5+THREAD_global], %i3 ; /* get the global state */	\
	mov	%i0, %o0		; /* Propagate arguments     */	\
	mov	%i1, %o1		;				\
	mov	%i2, %o2		;				\
	call	C_NAME(what)		; /* Call function	     */	\
	st	%g0, [%i3 +GLOBAL_in_ML]; /* Not in ML ... */		\
									\
	st	%i3, [%i3 +GLOBAL_in_ML]; /* ... Back in ML */		\
	ld	[%i3 +GLOBAL_current_thread], %g5 ; /* current thread */ \
	mov	%o0, %i0		; /* Propagate result	     */	\
	load_ML_state_with(%g5,%o4)	;				\
	restore	%g0, 0, %g0		; /* Return to ML stack	     */	\
	clean_windows			; /* Clean the register windows */ \
	ultra_clean(%o4)		; /* clean %o4 */

/* Ultra: ins, locals, o1 and o2 are as they were when ML_to_C was
   invoked, o0=result, o3=global, o5=c_sp. */

/* Unwind stack to a particular point
 *
 * The ML stack is unwound by repeatedly restoring register windows
 * until %sp = %g4. In the meantime, if we pass a frame with %fp =
 * c_sp, we set c_sp to %i3. The argument is a label prefix. */

#define unwind_stack(label)						\
label ## unwind:							\
	ld	[%g5 + THREAD_c_sp], %g7 ; /* cache c_sp in a register */\
	ba	label ## start	;					\
	cmp	%fp, %g7	;	/*is this the c_sp frame ? */	\
label ## loop:								\
        restore			;					\
	cmp	%fp, %g7	;	/*is this the c_sp frame ? */	\
label ## start:								\
	beq,a	label ## not_c_sp;					\
	mov	%i3, %g7	;	/* if so, reload c_sp from %i3 */\
label ## not_c_sp:							\
	cmp	%sp, %g4	;	/* Is it the final frame? */	\
	bne,a	label ## loop	;	/* if not, go around */		\
	mov	%o0, %i0	;	/* Propagate handler result */  \
	st	%g7, [%g5 + THREAD_c_sp] ; /* save c_sp back */		\
	save	%sp, -0x40, %sp	;					\
	mov	%fp, %o0	;					\
	ML_to_C(unwind_stack)	;	/* Unwind stack extensions */   \
	addcc	%g6, 1, %g0	;	/* Is an event flagged? */	\
	beq,a	label ## exit	;	/* Finished if so. */		\
	restore			;					\
	ld	[%g5+IMPLICIT_stack_limit], %g6 ; /* Install new stack area */\
	restore			;					\
label ## exit:

/* Save all the FP's away. The arg is a register pointing to the save
 * area (size 128). */

#define store_fps(where)			\
	std	%f0,  [where]		;	\
	std	%f2,  [where+8]		;	\
	std	%f4,  [where+16]	;	\
	std	%f6,  [where+24]	;	\
	std	%f8,  [where+32]	;	\
	std	%f10, [where+40]	;	\
	std	%f12, [where+48]	;	\
	std	%f14, [where+56]	;	\
	std	%f16, [where+64]	;	\
	std	%f18, [where+72]	;	\
	std	%f20, [where+80]	;	\
	std	%f22, [where+88]	;	\
	std	%f24, [where+96]	;	\
	std	%f26, [where+104]	;	\
	std	%f28, [where+112]	;	\
	std	%f30, [where+120]

/* Load the FPs. The arg is a register pointing to the saved values */

#define load_fps(from_where)			\
	ldd	[from_where],     %f0	;	\
	ldd	[from_where+8],   %f2	;	\
	ldd	[from_where+16],  %f4	;	\
	ldd	[from_where+24],  %f6	;	\
	ldd	[from_where+32],  %f8	;	\
	ldd	[from_where+40],  %f10	;	\
	ldd	[from_where+48],  %f12	;	\
	ldd	[from_where+56],  %f14	;	\
	ldd	[from_where+64],  %f16	;	\
	ldd	[from_where+72],  %f18	;	\
	ldd	[from_where+80],  %f20	;	\
	ldd	[from_where+88],  %f22	;	\
	ldd	[from_where+96],  %f24	;	\
	ldd	[from_where+104], %f26	;	\
	ldd	[from_where+112], %f28	;	\
	ldd	[from_where+120], %f30
@


1.8.5.1
log
@branched from trunk for label MLW_daveb_inline_1_4_99
@
text
@a19 6
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.8.4.1
log
@branched from trunk for label MLWorks_MM_adapt
@
text
@a19 6
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.8.3.1
log
@branched from trunk for label MLWorks_workspace_97
@
text
@a19 6
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.8.2.1
log
@branched from trunk for label MLWorks_dt_wizard
@
text
@a19 6
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.8.1.1
log
@branched from 1.8
@
text
@a19 6
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
@


1.8.1.1.3.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r3
@
text
@a19 3
 * Revision 1.8.1.1  1997/05/12  10:45:05  hope
 * branched from 1.8
 *
@


1.8.1.1.2.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_10r2_551
@
text
@a19 3
 * Revision 1.8.1.1  1997/05/12  10:45:05  hope
 * branched from 1.8
 *
@


1.8.1.1.1.1
log
@branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
@
text
@a19 3
 * Revision 1.8.1.1  1997/05/12  10:45:05  hope
 * branched from 1.8
 *
@


1.8.1.1.1.1.1.1
log
@branched from MLWorks_11 for label MLWorks_11r1
@
text
@a19 3
 * Revision 1.8.1.1.1.1  1997/07/28  18:27:19  daveb
 * branched from MLWorks_1_0_r2c1_1997_05_12 for label MLWorks_11
 *
@


1.7
log
@Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
@
text
@d20 3
d103 8
d118 1
a118 1
#define	clean_windows    ta 4
d174 9
a182 1
/* Call C from ML : 
d187 2
d207 5
a211 1
	clean_windows			; /* Clean the register windows */
d214 1
a214 1
 * 
@


1.7.5.1
log
@branched from 1.7
@
text
@a19 3
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
@


1.7.4.1
log
@branched from 1.7
@
text
@a19 3
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
@


1.7.4.1.1.1
log
@branched from 1.7.4.1
@
text
@a19 3
 * Revision 1.7.4.1  1996/12/17  17:56:44  hope
 * branched from 1.7
 *
@


1.7.4.1.1.2
log
@[Bug #0]
Make ULTRA SPARC capable version
@
text
@a19 9
 * Revision 1.8  1997/02/06  11:41:53  nickb
 * The ST_CLEAN_WINDOWS trap semantics are subtly different on UltraSPARCs. The
 * effect is that the registers which are current at the time of the trap may
 * reappear in a later register window. So whenever we invoke it, we have to
 * ensure that the current registers (ins, locals, and outs) are GC-safe.
 *
 * Revision 1.7.4.1.1.1  1997/02/24  11:48:22  hope
 * branched from 1.7.4.1
 *
a105 8
/* we can't get these from an include file because under SunOS
 * they are in /usr/include/machine/trap.h and under Solaris they are in
 * /usr/include/sys/trap.h */

#define ST_BREAKPOINT 1
#define ST_FLUSH_WINDOWS 3
#define ST_CLEAN_WINDOWS 4

d113 1
a113 1
#define	clean_windows    ta ST_CLEAN_WINDOWS
d169 1
a169 9

/* On UltraSPARC, we have to clean some registers when we do a
 * clean_windows trap. We use this macro, so that if we want to
 * conditionalize these cleans (i.e. build separate runtimes for
 * UltraSPARC and SPARC), we can do so trivially here */

#define ultra_clean(register)	mov	%g0, register

/* Call C from ML :
a173 2
/* Note that all registers must be GC-safe when ML_to_C is invoked */

d192 1
a192 5
	clean_windows			; /* Clean the register windows */ \
	ultra_clean(%o4)		; /* clean %o4 */

/* Ultra: ins, locals, o1 and o2 are as they were when ML_to_C was
   invoked, o0=result, o3=global, o5=c_sp. */
d195 1
a195 1
 *
@


1.7.3.1
log
@branched from 1.7
@
text
@a19 3
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
@


1.7.2.1
log
@branched from 1.7
@
text
@a19 3
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
@


1.7.1.1
log
@branched from 1.7
@
text
@a19 3
 * Revision 1.7  1996/10/31  17:21:35  nickb
 * Exchange ml_state.base and ml_state.sp, to be consistent with other platforms.
 *
@


1.7.1.1.1.1
log
@branched from 1.7.1.1
@
text
@a19 3
 * Revision 1.7.1.1  1996/11/14  13:00:36  hope
 * branched from 1.7
 *
@


1.6
log
@Change to c_sp protocol.
@
text
@d20 3
d170 1
a170 1
	st	%sp, [%g5+THREAD_ml_base] ; /* Save ML stack base */	\
d173 1
a173 1
	st	%sp, [%g5+THREAD_ml_sp] ; /* Save topmost GCable sp */	\
@


1.6.3.1
log
@branched from 1.6
@
text
@a19 3
 * Revision 1.6  1995/09/06  15:22:33  nickb
 * Change to c_sp protocol.
 *
@


1.6.2.1
log
@branched from 1.6
@
text
@a19 3
 * Revision 1.6  1995/09/06  15:22:33  nickb
 * Change to c_sp protocol.
 *
@


1.6.1.1
log
@branched from 1.6
@
text
@a19 3
 * Revision 1.6  1995/09/06  15:22:33  nickb
 * Change to c_sp protocol.
 *
@


1.5
log
@Add threads system.
@
text
@d20 3
a179 1
	st	%i5, [%g5+THREAD_c_sp]	; /* Resave C sp */		\
@


1.4
log
@Add fiddles with heap_limit field in ml_state.
@
text
@d20 3
d91 1
d119 15
a133 3
/* Saves the global registers in a C struct labelled with the first
 * arg, address of that label in the second arg register.  The stack
 * register %g6 is only stored if is not -1. */
d139 3
a141 4
#define store_ML_state(where, use)				\
	sethi	%hi(C_NAME(where)), use	;			\
	or	use, %lo(C_NAME(where)), use ;			\
	std	%g4, [use + 8]		;			\
d143 1
a143 1
	/* restore ML state limit (trapping GC entry) */	\
d150 6
a155 63
	st	%g1, [use + 24]		;			\
	std	%g2, [use + 0]		;			\
	addcc	%g6, 1, %g0		; /* Is stack -1? */	\
	beq	.+12			;			\
	st	%g7, [use + 20]		;			\
	st	%g6, [use + 16]					

/* Loads the global registes from a C struct labelled with the first
 * arg, leaving the address of that label in the second arg.  The
 * stack register %g6 is ORed with the interrupt stack slot on the
 * implicit vector, which is left in the third arg */

/* Note the fiddling with g1/g2/g4 here. This is to make sure that,
   while in C, GC_HEAP_LIMIT points to the limit of the creation
   space, but while in ML, %g1 contains 0x7ffffffc - (limit-alloc). */

#define load_ML_state(where, use, intreg)			\
	sethi	%hi(C_NAME(where)), use ;			\
	or	use, %lo(C_NAME(where)), use ;			\
	ld	[use + 24], %g1		;			\
	ldd	[use + 0], %g2		;			\
								\
	/* set limit register for trapping GC entry */		\
								\
	sethi	%hi(0x7ffffffc), %g4	;			\
	or	%g4, %lo(0x7ffffffc), %g4	;		\
	sub	%g4, %g1, %g1		;			\
	add	%g1, %g2, %g1		;			\
	st	%g1, [use + 24]		;			\
	ldd	[use + 8], %g4		;			\
	ldd	[use + 16], %g6		;			\
	ld	[%g5 + IMPLICIT_interrupt], intreg	;	\
	or	%g6, intreg, %g6				

/* Saves those global registers used by C in an aligned area at an
 * address (first arg).  Also sets reg (second arg) to address. */

#define store_C_globals(where, use)				\
	sethi	%hi(C_NAME(where)), use	;			\
	or	use, %lo(C_NAME(where)), use

/*	(Don't have to save/restore globals for C, as it does not use them).

	st	%g1, [use + 24]		;			\
	std	%g2, [use + 0]		;			\
	std	%g4, [use + 8]		;			\
	std	%g6, [use + 16]					
*/

/* Loads the global registers used by C from an aligned area at an
 * address (first arg). Also sets reg (second arg) to the address */

#define load_C_globals(where, use)				\
	sethi	%hi(C_NAME(where)), use	;			\
	or	use, %lo(C_NAME(where)), use

/* *Don't have to save/restore globals for C, as it does not use them).

	ld	[use + 24], %g1		;			\
	ldd	[use + 0], %g2		;			\
	ldd	[use + 8], %g4		;			\
	ldd	[use + 16], %g6
*/
d163 3
a165 4
	store_ML_state(ml_state, %o3)	;				\
	st	%sp, [%o3+32]		; /* Save ML stack base	     */	\
	load_C_globals(c_state, %o4)	;				\
	ld	[%o4 + 28], %o5		; /* Fetch the previous C sp */	\
d167 2
a168 1
	st	%sp, [%i3 + 28]		; /*Save ptr to ML frame for GC*/\
d171 1
d173 5
a177 1
	mov	%i2, %o2		;				\
d179 1
a179 2
	store_C_globals(c_state, %o2)	;				\
	load_ML_state(ml_state,%o3,%o4);				\
d186 2
a187 1
 * until the first register arg equals %g4.  the other arg is a label prefix.*/
d189 1
a189 1
#define unwind_stack(to_where, label)					\
d191 1
d193 1
a193 1
	cmp	to_where, %g4	;	/*in the right frame already?*/ \
d196 1
a196 1
	cmp	to_where, %g4	;	/* Is it the correct frame? */  \
d198 5
a202 1
	bne,a	label ##loop	;					\
d204 1
d211 1
a211 3
	sethi	%hi(C_NAME(ml_state)), %o1 ;				\
	or	%o1, %lo(C_NAME(ml_state)), %o1;			\
	ld	[%o1+16], %g6	;	/* Install the new stack area */ \
@


1.4.1.1
log
@branched from 1.4
@
text
@a19 3
 * Revision 1.4  1994/07/22  14:31:10  nickh
 * Add fiddles with heap_limit field in ml_state.
 *
@


1.3
log
@Asm and C name prefixes differ according to OS.
@
text
@d20 3
d119 4
d126 9
a136 1
	std	%g4, [use + 8]		;			\
d147 4
d156 8
@


1.2
log
@new file
@
text
@d20 3
d85 1
d117 2
a118 2
	sethi	%hi(where), use		;			\
	or	use, %lo(where), use	;			\
d133 2
a134 2
	sethi	%hi(where), use		;			\
	or	use, %lo(where), use	;			\
d146 2
a147 2
	sethi	%hi(where), use		;			\
	or	use, %lo(where), use
d161 2
a162 2
	sethi	%hi(where), use		;			\
	or	use, %lo(where), use
d178 1
a178 1
	store_ML_state(_ml_state, %o3)	;				\
d180 1
a180 1
	load_C_globals(_c_state, %o4)	;				\
d186 1
a186 1
	call	what			; /* Call function	     */	\
d189 2
a190 2
	store_C_globals(_c_state, %o2)	;				\
	load_ML_state(_ml_state,%o3,%o4);				\
d211 1
a211 1
	ML_to_C(_unwind_stack)	;	/* Unwind stack extensions */   \
d215 2
a216 2
	sethi	%hi(_ml_state), %o1	;				\
	or	%o1, %lo(_ml_state), %o1;				\
@


1.1
log
@new file
@
text
@d19 4
a22 1
 * $Log: macros.m4s,v $
@
