head	1.5;
access;
symbols
	hope_poo:1.5.1
	ML_beta_release_12/08/94:1.5.1.1
	ML_beta_release_03/08/94:1.5;
locks; strict;
comment	@ * @;


1.5
date	94.07.22.14.48.46;	author nickh;	state Exp;
branches
	1.5.1.1;
next	1.4;

1.4
date	94.07.19.09.14.50;	author nickh;	state Exp;
branches;
next	1.3;

1.3
date	94.07.08.09.03.37;	author nickh;	state Exp;
branches;
next	1.2;

1.2
date	94.06.09.14.29.07;	author nickh;	state Exp;
branches;
next	1.1;

1.1
date	94.06.09.10.53.31;	author nickh;	state Exp;
branches;
next	;

1.5.1.1
date	95.07.05.10.28.34;	author hope;	state Exp;
branches;
next	;


desc
@new file
@


1.5
log
@Change to heap limit register.
@
text
@/*
 * state.h
 * The ML and C states are stored here.
 * $Log: src:arch:SPARC:state.h,v $
 * Revision 1.4  1994/07/19  09:14:50  nickh
 * Abstract state initialising into state_initialise().
 *
 * Revision 1.3  1994/07/08  09:03:37  nickh
 * Add alignment to ml_state and c_state.
 *
 * Revision 1.2  1994/06/09  14:29:07  nickh
 * new file
 *
 * Revision 1.1  1994/06/09  10:53:31  nickh
 * new file
 *
 * Revision 1.8  1992/07/27  12:47:00  richard
 * Moved stack_extension_count and raise_count here from the obsolete
 * callc_codes.h.
 *
 * Revision 1.7  1992/06/30  09:41:59  richard
 * Moved declaration of ml_state to storeman.h.
 *
 * Revision 1.6  1992/03/24  15:19:16  richard
 * Changed the types of the C and ML states to reflect changes in
 * interface.s.
 *
 * Revision 1.5  1992/01/07  16:21:03  richard
 * Changed g6 to `stack' to reflect its new meaning.
 *
 * Revision 1.4  1991/10/24  15:36:31  davidt
 * Gave g4 and g4 their proper names (global and implicit).
 *
 * Revision 1.3  91/10/23  16:00:45  davidt
 * The complete register set in now stored in ml_state and c_state
 * so that ml_callc can function correctly.
 * 
 * Revision 1.2  91/10/18  18:36:21  davidt
 * We don't need the setjmp stuff any more.
 * 
 * Revision 1.1  91/10/18  16:26:19  davidt
 * Initial revision
 * 
 *
 * Copyright (c) 1991 Harlequin Ltd.
 */

#ifndef state_h
#define state_h

#include "extensions.h"

struct c_state
{
  word g2, g3, g4, g5, g6, g7, g1;
  word sp;
} data_aligned(c_state,8);

/* heap limit register has different values depending on whether we're
   in ML or in C:

   in ML, it contains (0x7ffffffc - number of bytes until next GC)
   in C, it contains the address of the first non-allocatable word
*/

extern struct ml_state
{
  mlval *heap_start;			/* %g2  next allocatable word */
  mlval handler;			/* %g3  current handler record */
  mlval *global;			/* %g4  global scratch register */
  struct implicit_vector *implicit;	/* %g5  the implicit vector */
  struct stack *stack;			/* %g6  current stack area */
  mlval g7;			        /* %g7  general purpose */
  mlval *heap_limit;			/* %g1  heap limit register */
  struct stack_frame *sp;	        /* %sp  last ML frame */
  struct stack_frame *base;		/*      lowest frame in stack area */
} data_aligned(ml_state,8);

#define GC_SP			ml_state.sp
#define GC_STACK		ml_state.stack
#define GC_MODIFIED_LIST	ml_state.implicit->gc_modified_list
#define GC_HEAP_START		ml_state.heap_start
#define GC_HEAP_LIMIT		ml_state.heap_limit
#define GC_RETURN		ml_state.global

/* Statistics collected by interface.m4s */

extern unsigned int stack_extension_count;
extern unsigned int raise_count;

extern void state_initialise(struct stack *initial_stack);

#endif
@


1.5.1.1
log
@branched from 1.5
@
text
@a4 3
 * Revision 1.5  1994/07/22  14:48:46  nickh
 * Change to heap limit register.
 *
@


1.4
log
@Abstract state initialising into state_initialise().
@
text
@d5 3
d59 7
d68 1
a68 1
  mlval *heap_limit;			/* %g2  first non-allocatable word */
d74 1
a74 1
  mlval *heap_start;			/* %g1  next allocatable word */
@


1.3
log
@Add alignment to ml_state and c_state.
@
text
@d5 3
d80 2
@


1.2
log
@new file
@
text
@d5 3
d45 2
d51 1
a51 1
} c_state;
d64 1
a64 1
} ml_state;
@


1.1
log
@new file
@
text
@d4 4
a7 1
 * $Log: state.h,v $
@
